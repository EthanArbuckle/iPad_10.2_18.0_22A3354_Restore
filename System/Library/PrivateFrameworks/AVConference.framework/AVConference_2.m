uint64_t TPListenOnPhysicalInterface(uint64_t a1, _WORD *a2, int a3, uint64_t a4, const unsigned __int8 *a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int LocalInterfaceListWithOptionsAndCellInterfaceName;
  unsigned int LocalIFIndexForDstIPPort;
  uint64_t v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t *v18;
  int v19;
  char *v20;
  char *v21;
  uint64_t v22;
  int v23;
  char *v24;
  _BOOL4 v26;
  const unsigned __int8 *v27;
  int *v28;
  __int128 v29;
  __int128 v30;
  int v31;
  _BOOL4 v32;
  NSObject *v33;
  int v34;
  int **v35;
  int **v36;
  int *v37;
  uint64_t v38;
  uint64_t v39;
  NSObject *v40;
  _BOOL4 v41;
  uint64_t v42;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  pthread_rwlock_t *v47;
  void *v48;
  uint64_t v49;
  int v50;
  int *v51;
  char *v52;
  uint8_t buf[4];
  uint64_t v54;
  __int16 v55;
  const char *v56;
  __int16 v57;
  int v58;
  __int16 v59;
  int v60;
  __int16 v61;
  _BOOL4 v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;

  v65 = *MEMORY[0x1E0C80C00];
  v10 = 2148466710;
  v11 = CheckInHandleDebug();
  if (v11)
  {
    v12 = v11;
    if (*(_DWORD *)v11)
    {
      v10 = 2148466704;
LABEL_50:
      CheckOutHandleDebug();
      return v10;
    }
    v51 = (int *)0xAAAAAAAAAAAAAAAALL;
    v52 = 0;
    v63 = 0;
    v64 = 0;
    *(_WORD *)(v11 + 20) = *a2;
    *(_DWORD *)(v11 + 16) = 10;
    TPSetupCTContext(a1, v11, a3);
    if (*(_DWORD *)(v12 + 34384))
    {
      LocalInterfaceListWithOptionsAndCellInterfaceName = 1;
      v52 = (char *)malloc_type_calloc(1uLL, 0x28uLL, 0x100004053E81896uLL);
      MakeIPPORT();
      LocalIFIndexForDstIPPort = GetLocalIFIndexForDstIPPort();
      if_indextoname(LocalIFIndexForDstIPPort, v52 + 4);
    }
    else
    {
      LocalInterfaceListWithOptionsAndCellInterfaceName = GetLocalInterfaceListWithOptionsAndCellInterfaceName();
      if (!LocalInterfaceListWithOptionsAndCellInterfaceName)
      {
        FreeLocalInterfaceList();
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            TPListenOnPhysicalInterface_cold_1();
        }
        goto LABEL_50;
      }
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v15 = VRTraceErrorLogLevelToCSTR();
      v16 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        v54 = v15;
        v55 = 2080;
        v56 = "ListenUDP";
        v57 = 1024;
        v58 = 2664;
        v59 = 1024;
        v60 = LocalInterfaceListWithOptionsAndCellInterfaceName;
        _os_log_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d %d interfaces found.", buf, 0x22u);
      }
    }
    v47 = (pthread_rwlock_t *)(v12 + 1064);
    v48 = (void *)a1;
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v12 + 1064));
    if (LocalInterfaceListWithOptionsAndCellInterfaceName < 1)
    {
      v50 = 0;
LABEL_44:
      pthread_rwlock_unlock(v47);
      FreeLocalInterfaceList();
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v39 = VRTraceErrorLogLevelToCSTR();
        v40 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v41 = *(_QWORD *)(v12 + 1056) == 0;
          *(_DWORD *)buf = 136316162;
          v54 = v39;
          v55 = 2080;
          v56 = "ListenUDP";
          v57 = 1024;
          v58 = 2727;
          v59 = 1024;
          v60 = v50;
          v61 = 1024;
          v62 = v41;
          _os_log_impl(&dword_1D8A54000, v40, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d %d valid interfaces found. (pTP->pCList == NULL) = %d", buf, 0x28u);
        }
      }
      v10 = 2148466710;
      if (*(_QWORD *)(v12 + 1056))
      {
        v42 = TPEnsureRecvProcStarted(v48, v12);
        if ((v42 & 0x80000000) != 0)
        {
          v10 = v42;
          FreeLocalInterfaceList();
          pthread_rwlock_wrlock(v47);
          v44 = *(_QWORD *)(v12 + 1056);
          if (v44)
          {
            do
            {
              VTP_Close(*(_DWORD *)v44);
              v45 = *(_QWORD *)(v44 + 2144);
              v46 = *(_QWORD *)(v44 + 2128);
              if (v46 != 0xFFFFFFFFLL)
              {
                if (*(_QWORD *)(v44 + 2136) != 0xFFFFFFFFLL)
                {
                  ARPLSessionRelease();
                  *(_QWORD *)(v44 + 2136) = 0xFFFFFFFFLL;
                  v46 = *(_QWORD *)(v44 + 2128);
                }
                DTLS_Cleanup(v46);
              }
              free((void *)v44);
              v44 = v45;
            }
            while (v45);
          }
          pthread_rwlock_unlock(v47);
        }
        else
        {
          v10 = 0;
        }
      }
      goto LABEL_50;
    }
    v17 = 0;
    v50 = 0;
    v18 = (uint64_t *)(v12 + 1056);
    while (1)
    {
      v19 = (unsigned __int16)*a2;
      v20 = v52;
      v21 = &v52[40 * v17];
      *((_WORD *)v21 + 18) = v19;
      v22 = *v18;
      if (*v18)
        break;
LABEL_26:
      v26 = TransportMapPacketMultiplexModeToVTPMode(*(unsigned int *)(v12 + 4));
      if ((CreateSocketAndBind((__int128 *)v21, &v51, 0, a5, v26) & 0x80000000) == 0)
      {
        v27 = a5;
        v28 = v51;
        *a2 = *((_WORD *)v51 + 1054);
        if (a4)
        {
          v29 = *(_OWORD *)(v28 + 518);
          v30 = *(_OWORD *)(v28 + 522);
          *(_QWORD *)(a4 + 32) = *((_QWORD *)v28 + 263);
          *(_OWORD *)a4 = v29;
          *(_OWORD *)(a4 + 16) = v30;
        }
        VCTestMonitorManager_GetEnableLoopbackInterface();
        v31 = ICESetEnableLoopbackInterface();
        if (v31 < 0)
        {
          v32 = v31;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            v49 = VRTraceErrorLogLevelToCSTR();
            v33 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136316162;
              v54 = v49;
              v55 = 2080;
              v56 = "ListenUDP";
              v57 = 1024;
              v58 = 2690;
              v59 = 1024;
              v60 = 2690;
              v61 = 1024;
              v62 = v32;
              _os_log_error_impl(&dword_1D8A54000, v33, OS_LOG_TYPE_ERROR, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/Transport.c:%d: ICESetEnableLoopbackInterface failed(%08X)", buf, 0x28u);
            }
          }
        }
        v34 = ICEAddOneInterface();
        v35 = (int **)(v12 + 1056);
        if (v34 < 0)
        {
          VTP_Close(*v28);
          v38 = *((_QWORD *)v28 + 266);
          a5 = v27;
          if (v38 != 0xFFFFFFFFLL)
          {
            if (*((_QWORD *)v28 + 267) != 0xFFFFFFFFLL)
            {
              ARPLSessionRelease();
              *((_QWORD *)v28 + 267) = 0xFFFFFFFFLL;
              v38 = *((_QWORD *)v28 + 266);
            }
            DTLS_Cleanup(v38);
          }
          free(v28);
        }
        else
        {
          do
          {
            v36 = v35;
            v37 = *v35;
            v35 = (int **)(*v35 + 536);
          }
          while (v37);
          *v36 = v28;
          ++v50;
          a5 = v27;
        }
      }
LABEL_41:
      if (++v17 == LocalInterfaceListWithOptionsAndCellInterfaceName)
        goto LABEL_44;
    }
    v23 = *(_DWORD *)v21 & 1;
    v24 = &v20[40 * v17 + 20];
    while (1)
    {
      if (v23 == (*(_DWORD *)(v22 + 2072) & 1))
      {
        if (v23)
        {
          if (*(_QWORD *)v24 == *(_QWORD *)(v22 + 2092) && *((_QWORD *)v24 + 1) == *(_QWORD *)(v22 + 2100))
          {
LABEL_24:
            if (v19 == *(unsigned __int16 *)(v22 + 2108))
              goto LABEL_41;
          }
        }
        else if (*(_DWORD *)v24 == *(_DWORD *)(v22 + 2092))
        {
          goto LABEL_24;
        }
      }
      v22 = *(_QWORD *)(v22 + 2144);
      if (!v22)
        goto LABEL_26;
    }
  }
  return 2148466690;
}

uint64_t TPStopListen(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  __int128 v5;
  pthread_rwlock_t *v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  const char *v17;
  int ErrorLogLevelForModule;
  uint64_t v19;
  NSObject *v20;
  int v21;
  int v23;
  uint8_t buf[4];
  uint64_t v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  __int16 v34;
  int v35;
  __int128 v36;
  __int128 v37;
  _BYTE v38[22];
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v3 = CheckInHandleDebug();
  if (!v3)
    return 2148466690;
  v4 = v3;
  *(_QWORD *)&v38[14] = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v37 = v5;
  *(_OWORD *)v38 = v5;
  v36 = v5;
  v6 = (pthread_rwlock_t *)(v3 + 1064);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(v3 + 1064));
  v7 = *(_QWORD *)(v4 + 1056);
  if (!v7)
  {
    v10 = 0;
    goto LABEL_35;
  }
  v8 = 0;
  v9 = "SIP";
  v10 = *(_QWORD *)(v4 + 1056);
  do
  {
    v11 = v7;
    while (!a2)
    {
      if (!*(_BYTE *)(v11 + 4))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v12 = VRTraceErrorLogLevelToCSTR();
          v13 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v14 = IPPORTToStringWithSize();
            v15 = *(_DWORD *)v11;
            *(_DWORD *)buf = 136316418;
            v25 = v12;
            v26 = 2080;
            v27 = "TPStopListen";
            v28 = 1024;
            v29 = 2859;
            v30 = 2080;
            v31 = v14;
            v32 = 2080;
            v33 = v11 + 2076;
            v34 = 1024;
            v35 = v15;
            _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Stop listening on %s(%s) vfd %d", buf, 0x36u);
          }
        }
        ICERemoveOneInterface();
        if (!*(_DWORD *)(v11 + 2068))
          VTP_Close(*(_DWORD *)v11);
        v16 = *(_QWORD *)(v11 + 2128);
        if (v16 != 0xFFFFFFFFLL)
        {
          if (*(_QWORD *)(v11 + 2136) != 0xFFFFFFFFLL)
          {
            ARPLSessionRelease();
            *(_QWORD *)(v11 + 2136) = 0xFFFFFFFFLL;
            v16 = *(_QWORD *)(v11 + 2128);
          }
          DTLS_Cleanup(v16);
        }
        v7 = *(_QWORD *)(v11 + 2144);
        v9 = "SIP";
        if (v8)
          goto LABEL_21;
        goto LABEL_22;
      }
LABEL_9:
      v8 = v11;
      v11 = *(_QWORD *)(v11 + 2144);
      if (!v11)
        goto LABEL_35;
    }
    if (!*(_BYTE *)(v11 + 4))
      goto LABEL_9;
    v17 = v9;
    ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    if (ErrorLogLevelForModule >= 7)
    {
      v19 = VRTraceErrorLogLevelToCSTR();
      v20 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v21 = *(_DWORD *)v11;
        *(_DWORD *)buf = 136315906;
        v25 = v19;
        v26 = 2080;
        v27 = "TPStopListen";
        v28 = 1024;
        v29 = 2829;
        v30 = 1024;
        LODWORD(v31) = v21;
        _os_log_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Stop listening on IDS interface vfd %d", buf, 0x22u);
      }
    }
    if (!*(_DWORD *)(v11 + 2068))
      VTP_Close(*(_DWORD *)v11);
    v7 = *(_QWORD *)(v11 + 2144);
    v9 = v17;
    if (v8)
LABEL_21:
      *(_QWORD *)(v8 + 2144) = v7;
LABEL_22:
    if (v11 == v10)
      v10 = v7;
    free((void *)v11);
  }
  while (v7);
LABEL_35:
  *(_QWORD *)(v4 + 1056) = v10;
  v23 = *(_DWORD *)(v4 + 12);
  if (v23 != -1)
    VTP_Close(v23);
  *(_DWORD *)(v4 + 12) = -1;
  pthread_rwlock_unlock(v6);
  if ((a2 & 1) == 0)
    TPCleanupBaseband(v4);
  CheckOutHandleDebug();
  return 0;
}

uint64_t TPSend(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  _DWORD *v4;
  uint64_t v5;
  _QWORD *v6;
  __int128 v7;
  __int128 *v8;
  BOOL v9;
  uint64_t v10;
  NSObject *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  NSObject *v17;
  int v18;
  __int128 v19;
  int v20;
  __int128 v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  NSObject *v26;
  __int128 v28;
  uint64_t v29;
  uint64_t v31;
  NSObject *v32;
  int v33;
  uint64_t v34;
  NSObject *v35;
  int v36;
  int v37;
  uint64_t v38;
  uint64_t *v39;
  int v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  NSObject *v44;
  uint64_t v45;
  _BYTE *v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  _DWORD *v51;
  int v52;
  uint8_t v53[4];
  uint64_t v54;
  __int16 v55;
  const char *v56;
  __int16 v57;
  int v58;
  __int16 v59;
  _BYTE v60[10];
  uint64_t v61;
  __int128 v62;
  __int128 v63;
  _WORD v64[11];
  __int128 v65;
  __int128 v66;
  _BYTE v67[22];
  __int128 v68;
  __int128 v69;
  _QWORD v70[6];
  __int128 v71[5];
  uint8_t buf[2712];
  unint64_t v73;
  _BYTE __b[2048];
  _OWORD v75[130];
  _BYTE v76[22];
  uint64_t v77;

  MEMORY[0x1E0C80A78](a1);
  v77 = *MEMORY[0x1E0C80C00];
  v2 = 2148466728;
  if (!v1)
    return 2148466689;
  v3 = v1;
  v4 = (_DWORD *)CheckInHandleDebug();
  if (v4)
  {
    v5 = (uint64_t)v4;
    if (*v4)
    {
      v2 = 2148466704;
LABEL_101:
      CheckOutHandleDebug();
      return v2;
    }
    v6 = (_QWORD *)(v3 + 716);
    *(_QWORD *)&v76[14] = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v75[129] = v7;
    *(_OWORD *)v76 = v7;
    v75[128] = v7;
    memset(v75, 170, 0x800uLL);
    memset(__b, 170, sizeof(__b));
    v52 = 2048;
    v8 = (__int128 *)(v3 + 696);
    if ((*(_DWORD *)(v3 + 696) & 1) == (*(_DWORD *)(v3 + 816) & 1))
    {
      if ((*(_DWORD *)(v3 + 696) & 1) != 0)
      {
        v9 = *v6 == *(_QWORD *)(v3 + 836) && *(_QWORD *)(v3 + 724) == *(_QWORD *)(v3 + 844);
        if (!v9)
          goto LABEL_18;
      }
      else if (*(_DWORD *)(v3 + 716) != *(_DWORD *)(v3 + 836))
      {
        goto LABEL_18;
      }
      if (*(unsigned __int16 *)(v3 + 732) == *(unsigned __int16 *)(v3 + 852) && !*(_BYTE *)(v5 + 34648))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v25 = VRTraceErrorLogLevelToCSTR();
          v26 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315906;
            *(_QWORD *)&buf[4] = v25;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "SendUDP";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 3071;
            *(_WORD *)&buf[28] = 2080;
            *(_QWORD *)&buf[30] = IPPORTToStringWithSize();
            _os_log_impl(&dword_1D8A54000, v26, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Same Local and Destination IP:Port(%s)", buf, 0x26u);
          }
        }
        goto LABEL_101;
      }
    }
LABEL_18:
    if (!*(_QWORD *)(v3 + 552))
    {
      v14 = ConstructSipMsg((char *)v75, 0x800uLL, v3);
      if ((v14 & 0x80000000) != 0)
      {
        v2 = v14;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            TPSend_cold_1();
        }
        goto LABEL_101;
      }
      ReplaceKeyword((const char *)v75, 2048, "%CLENGTH%", "0", 2);
      v52 = strlen((const char *)v75);
      goto LABEL_95;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v10 = VRTraceErrorLogLevelToCSTR();
      v11 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v12 = *(_DWORD *)(v3 + 564);
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = v10;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "SendUDP";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 3076;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v12;
        _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d()()()()() SIP BODY IS BINARY? (%d)", buf, 0x22u);
      }
    }
    if (*(_DWORD *)(v3 + 564))
    {
      v13 = CompressMsg((uint64_t)__b);
      if ((v13 & 0x80000000) != 0)
      {
        v2 = v13;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            TPSend_cold_4();
        }
        goto LABEL_101;
      }
LABEL_95:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v43 = VRTraceErrorLogLevelToCSTR();
        v44 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v45 = IPPORTToStringWithSize();
          v9 = *(_QWORD *)(v3 + 552) == 0;
          v46 = __b;
          *(_DWORD *)buf = 136316162;
          if (v9)
            v46 = v75;
          *(_QWORD *)&buf[4] = v43;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "SendUDP";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 3197;
          *(_WORD *)&buf[28] = 2080;
          *(_QWORD *)&buf[30] = v45;
          *(_WORD *)&buf[38] = 2080;
          *(_QWORD *)&buf[40] = v46;
          _os_log_impl(&dword_1D8A54000, v44, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Send to %s [%s]", buf, 0x30u);
        }
      }
      memset(buf, 0, 320);
      v47 = *(_OWORD *)(v3 + 656);
      *(_OWORD *)&buf[88] = *(_OWORD *)(v3 + 640);
      *(_OWORD *)&buf[104] = v47;
      *(_OWORD *)&buf[120] = *(_OWORD *)(v3 + 672);
      v48 = *(_OWORD *)(v3 + 592);
      *(_OWORD *)&buf[24] = *(_OWORD *)(v3 + 576);
      *(_OWORD *)&buf[40] = v48;
      v49 = *(_OWORD *)(v3 + 624);
      *(_OWORD *)&buf[56] = *(_OWORD *)(v3 + 608);
      *(_DWORD *)&buf[8] = *(_DWORD *)(v3 + 572);
      *(_QWORD *)&buf[136] = *(_QWORD *)(v3 + 688);
      *(_OWORD *)&buf[72] = v49;
      buf[169] = 1;
      v2 = VTP_Send(-1, v75, v52, 0, (uint64_t)buf);
      goto LABEL_101;
    }
    v15 = *(_DWORD *)(v3 + 4);
    if (v15 == 2)
    {
      if (*(_DWORD *)(v3 + 8) != 6 || *(int *)(v3 + 560) < 1)
      {
LABEL_50:
        v24 = CompressMsg((uint64_t)__b);
        if ((v24 & 0x80000000) != 0)
        {
          v2 = v24;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              TPSend_cold_2();
          }
          goto LABEL_101;
        }
        goto LABEL_95;
      }
    }
    else if (v15 != 1 || *(_DWORD *)(v3 + 8) != 1)
    {
      goto LABEL_50;
    }
    v73 = 0xAAAAAAAAAAAAAAAALL;
    memset(buf, 170, 0xA8CuLL);
    memset(v71, 0, sizeof(v71));
    __strlcpy_chk();
    v68 = 0u;
    v69 = 0u;
    memset(v70, 0, sizeof(v70));
    v66 = 0u;
    memset(v67, 0, sizeof(v67));
    v65 = 0u;
    v63 = 0u;
    memset(v64, 0, sizeof(v64));
    v62 = 0u;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v16 = VRTraceErrorLogLevelToCSTR();
      v17 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v53 = 136316162;
        v54 = v16;
        v55 = 2080;
        v56 = "SendUDP";
        v57 = 1024;
        v58 = 3102;
        v59 = 2080;
        *(_QWORD *)v60 = IPPORTToStringWithSize();
        *(_WORD *)&v60[8] = 2080;
        v61 = IPPORTToStringWithSize();
        _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d RTP using %s and %s as hints", v53, 0x30u);
      }
    }
    RTPCreateSockets(*(_QWORD *)(v3 + 976), v3 + 696, (int *)(v3 + 776), (int *)&v73, (int *)v71);
    if (v18 < 0)
    {
      v19 = *(_OWORD *)(v3 + 712);
      v71[0] = *v8;
      v71[1] = v19;
      *(_QWORD *)&v71[2] = *(_QWORD *)(v3 + 728);
    }
    v51 = (_DWORD *)(v3 + 776);
    RTPCreateSockets(*(_QWORD *)(v3 + 984), v3 + 696, (int *)(v3 + 776), (int *)&v73 + 1, (int *)&v71[2] + 2);
    if (v20 < 0)
    {
      v21 = *(_OWORD *)(v3 + 712);
      *(__int128 *)((char *)&v71[2] + 8) = *v8;
      *(__int128 *)((char *)&v71[3] + 8) = v21;
      *((_QWORD *)&v71[4] + 1) = *(_QWORD *)(v3 + 728);
    }
    v22 = *(_DWORD *)v8 & 1;
    if (v22 == (v71[0] & 1))
    {
      if (v22)
      {
        if (*v6 != *(_QWORD *)((char *)&v71[1] + 4) || *(_QWORD *)(v3 + 724) != *(_QWORD *)((char *)&v71[1] + 12))
        {
          if (v22 != (*v51 & 1))
            goto LABEL_78;
          goto LABEL_70;
        }
      }
      else
      {
        v23 = *(_DWORD *)v6;
        if (*(_DWORD *)v6 != DWORD1(v71[1]))
        {
          if ((*(_BYTE *)v51 & 1) != 0)
          {
LABEL_78:
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v31 = VRTraceErrorLogLevelToCSTR();
              v32 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                v33 = *(unsigned __int16 *)(v3 + 732);
                *(_DWORD *)v53 = 136316162;
                v54 = v31;
                v55 = 2080;
                v56 = "SendUDP";
                v57 = 1024;
                v58 = 3130;
                v59 = 1024;
                *(_DWORD *)v60 = v33;
                *(_WORD *)&v60[4] = 1024;
                *(_DWORD *)&v60[6] = WORD2(v71[2]);
                _os_log_impl(&dword_1D8A54000, v32, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Overriding Video RTCP port from %u to %u", v53, 0x28u);
              }
            }
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v34 = VRTraceErrorLogLevelToCSTR();
              v35 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                v36 = *(unsigned __int16 *)(v3 + 732);
                *(_DWORD *)v53 = 136316162;
                v54 = v34;
                v55 = 2080;
                v56 = "SendUDP";
                v57 = 1024;
                v58 = 3132;
                v59 = 1024;
                *(_DWORD *)v60 = v36;
                *(_WORD *)&v60[4] = 1024;
                *(_DWORD *)&v60[6] = WORD6(v71[4]);
                _os_log_impl(&dword_1D8A54000, v35, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Overriding Video RTCP port from %u to %u", v53, 0x28u);
              }
            }
            AddToCListRTP(v5, *(_DWORD *)(v3 + 572), v73, v71, 2);
            AddToCListRTP(v5, *(_DWORD *)(v3 + 572), SHIDWORD(v73), (__int128 *)((char *)&v71[2] + 8), 4);
            VTP_AddPktType(v73, 4);
            VTP_AddPktType(SHIDWORD(v73), 4);
            ICEGetExtIPPorts();
            VTP_RemovePktType(v73, 4);
            VTP_RemovePktType(SHIDWORD(v73), 4);
            v37 = *(_DWORD *)(v3 + 572);
            pthread_rwlock_wrlock((pthread_rwlock_t *)(v5 + 1272));
            v38 = *(_QWORD *)(v5 + 1264);
            if (v38)
            {
              v39 = (uint64_t *)(v5 + 1264);
              do
              {
                if (*(_DWORD *)(v38 + 2064) == v37)
                {
                  *v39 = *(_QWORD *)(v38 + 2144);
                  ICERemoveOneInterface();
                  free((void *)v38);
                }
                else
                {
                  v39 = (uint64_t *)(v38 + 2144);
                }
                v38 = *v39;
              }
              while (*v39);
            }
            pthread_rwlock_unlock((pthread_rwlock_t *)(v5 + 1272));
            pthread_rwlock_wrlock((pthread_rwlock_t *)(v5 + 1064));
            v40 = *(_DWORD *)(v5 + 12);
            *(_DWORD *)(v5 + 12) = -1;
            VTP_Close(v40);
            pthread_rwlock_unlock((pthread_rwlock_t *)(v5 + 1064));
LABEL_91:
            IPToString();
            if ((*(_DWORD *)(v3 + 776) & 1) != 0)
              v41 = 3559497;
            else
              v41 = 3428425;
            *(_DWORD *)(v3 + 944) = v41;
            __sprintf_chk((char *)(v3 + 948), 0, 6uLL, "%d", *(unsigned __int16 *)(v3 + 812));
            __sprintf_chk((char *)(v3 + 960), 0, 6uLL, "%d", *(unsigned __int16 *)(v3 + 812));
            __sprintf_chk((char *)(v3 + 954), 0, 6uLL, "%d", WORD2(v70[0]));
            __sprintf_chk((char *)(v3 + 966), 0, 6uLL, "%d", WORD2(v70[5]));
            ReplaceKeyword((const char *)buf, 2700, "%RTP-IP-AF%", (const char *)(v3 + 944), 4);
            ReplaceKeyword((const char *)buf, 2700, "%RTP-IP%", (const char *)(v3 + 896), 48);
            ReplaceKeyword((const char *)buf, 2700, "%VRTP-PORT%", (const char *)(v3 + 948), 6);
            ReplaceKeyword((const char *)buf, 2700, "%VRTCP-PORT%", (const char *)(v3 + 954), 6);
            ReplaceKeyword((const char *)buf, 2700, "%ARTP-PORT%", (const char *)(v3 + 960), 6);
            ReplaceKeyword((const char *)buf, 2700, "%ARTCP-PORT%", (const char *)(v3 + 966), 6);
            strlen((const char *)buf);
            v42 = CompressMsg((uint64_t)__b);
            if ((v42 & 0x80000000) != 0)
            {
              v2 = v42;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  TPSend_cold_3();
              }
              goto LABEL_101;
            }
            goto LABEL_95;
          }
          goto LABEL_68;
        }
      }
      if (*(unsigned __int16 *)(v3 + 732) == WORD2(v71[2]))
      {
        v28 = *(_OWORD *)(v3 + 792);
        v68 = *(_OWORD *)v51;
        v69 = v28;
        v29 = *(_QWORD *)(v3 + 808);
        v70[0] = v29;
        *(_OWORD *)&v70[1] = v68;
        *(_OWORD *)&v70[3] = v28;
        goto LABEL_77;
      }
    }
    if (v22 != (*v51 & 1))
      goto LABEL_78;
    if (!v22)
    {
      v23 = *(_DWORD *)(v3 + 716);
LABEL_68:
      if (v23 != *(_DWORD *)(v3 + 796))
        goto LABEL_78;
      goto LABEL_75;
    }
LABEL_70:
    if (*v6 != *(_QWORD *)(v3 + 796) || *(_QWORD *)(v3 + 724) != *(_QWORD *)(v3 + 804))
      goto LABEL_78;
LABEL_75:
    if (*(unsigned __int16 *)(v3 + 732) != *(unsigned __int16 *)(v3 + 812))
      goto LABEL_78;
    v68 = v71[0];
    v69 = v71[1];
    v70[0] = *(_QWORD *)&v71[2];
    *(_OWORD *)&v70[1] = *(__int128 *)((char *)&v71[2] + 8);
    *(_OWORD *)&v70[3] = *(__int128 *)((char *)&v71[3] + 8);
    v29 = *((_QWORD *)&v71[4] + 1);
LABEL_77:
    v70[5] = v29;
    goto LABEL_91;
  }
  return 2148466690;
}

uint64_t partial apply(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v11;
  uint64_t v12;
  _DWORD *v13;
  _DWORD *v14;

  result = 2148466689;
  if (a3 && *(_DWORD *)(a3 + 4) == 1)
  {
    v7 = *(_QWORD *)(a3 + 504);
    if (v7)
    {
      v11 = CheckInHandleDebug();
      if (v11)
      {
        v12 = v11;
        v13 = malloc_type_calloc(1uLL, 0x90uLL, 0x10A00402FEC5419uLL);
        if (v13)
        {
          v14 = v13;
          *v13 = a2;
          __strlcpy_chk();
          v14[17] = *(_DWORD *)(a3 + 8);
          if (a2 == 1)
          {
            __strlcpy_chk();
            *((_WORD *)v14 + 56) = *(_WORD *)(v7 + 52);
          }
          *((_QWORD *)v14 + 15) = a4;
          *((_QWORD *)v14 + 16) = a5;
          pthread_mutex_lock((pthread_mutex_t *)(v12 + 1480));
          *((_QWORD *)v14 + 17) = *(_QWORD *)(v12 + 1472);
          *(_QWORD *)(v12 + 1472) = v14;
          pthread_mutex_unlock((pthread_mutex_t *)(v12 + 1480));
          CheckOutHandleDebug();
          return 0;
        }
        else
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              TPAddTransaction_cold_2();
          }
          CheckOutHandleDebug();
          return 2148466691;
        }
      }
      else
      {
        return 2148466690;
      }
    }
    else
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          TPAddTransaction_cold_1();
      }
      return 2148466709;
    }
  }
  return result;
}

uint64_t TPRemoveTransaction(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  pthread_mutex_t *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2148466690;
  v4 = v3;
  v5 = (pthread_mutex_t *)(v3 + 1480);
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 1480));
  v6 = *(_QWORD **)(v4 + 1472);
  if (v6)
  {
    if (v6[16] == a2)
    {
      v8 = (_QWORD *)(v4 + 1472);
LABEL_9:
      *v8 = v6[17];
      free(v6);
    }
    else
    {
      while (1)
      {
        v7 = v6;
        v6 = (_QWORD *)v6[17];
        if (!v6)
          break;
        if (v6[16] == a2)
        {
          v8 = v7 + 17;
          goto LABEL_9;
        }
      }
    }
  }
  pthread_mutex_unlock(v5);
  CheckOutHandleDebug();
  return 0;
}

uint64_t TPGetType(uint64_t a1, _DWORD *a2)
{
  uint64_t v2;
  _DWORD *v4;

  v2 = 2148466689;
  if (a2)
  {
    v4 = (_DWORD *)CheckInHandleDebug();
    if (v4)
    {
      *a2 = *v4;
      CheckOutHandleDebug();
      return 0;
    }
    else
    {
      return 2148466690;
    }
  }
  return v2;
}

uint64_t TPStopHeartbeat(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  __int128 v5;
  pthread_mutex_t *v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v11;
  NSObject *v12;
  int v14;
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  _BYTE v24[22];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v3 = CheckInHandleDebug();
  if (!v3)
    return 2148466690;
  v4 = v3;
  *(_QWORD *)&v24[14] = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v23 = v5;
  *(_OWORD *)v24 = v5;
  v22 = v5;
  v6 = (pthread_mutex_t *)(v3 + 992);
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 992));
  v7 = 0;
  v8 = *(_DWORD *)a2 & 1;
  while (1)
  {
    v9 = v4 + v7;
    if ((*(_DWORD *)(v4 + v7 + 80) & 1) != v8)
      goto LABEL_14;
    if (v8)
      break;
    if (*(_DWORD *)(v9 + 100) == *(_DWORD *)(a2 + 20))
      goto LABEL_12;
LABEL_14:
    v7 += 96;
    if (v7 == 960)
      goto LABEL_15;
  }
  if (*(_QWORD *)(v9 + 100) != *(_QWORD *)(a2 + 20) || *(_QWORD *)(v9 + 108) != *(_QWORD *)(a2 + 28))
    goto LABEL_14;
LABEL_12:
  if (*(unsigned __int16 *)(v4 + v7 + 116) != *(unsigned __int16 *)(a2 + 36) || !*(_DWORD *)(v9 + 32))
    goto LABEL_14;
  *(_DWORD *)(v4 + v7 + 32) = 0;
LABEL_15:
  pthread_mutex_unlock(v6);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v11 = VRTraceErrorLogLevelToCSTR();
    v12 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v14 = 136315906;
      v15 = v11;
      v16 = 2080;
      v17 = "TPStopHeartbeat";
      v18 = 1024;
      v19 = 3354;
      v20 = 2080;
      v21 = IPPORTToStringWithSize();
      _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Stop heartbeat to %s", (uint8_t *)&v14, 0x26u);
    }
  }
  CheckOutHandleDebug();
  return 0;
}

uint64_t TPGetInterfaceStillExists(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  pthread_rwlock_t *v8;
  uint64_t v9;
  int v10;

  v3 = 2148466689;
  if (!a2 || !a3 || !IsIPPORTValid())
    return v3;
  v6 = CheckInHandleDebug();
  if (!v6)
    return 2148466690;
  v7 = v6;
  v8 = (pthread_rwlock_t *)(v6 + 1064);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(v6 + 1064));
  v9 = *(_QWORD *)(v7 + 1056);
  if (!v9)
    goto LABEL_19;
  v10 = *(_DWORD *)a2 & 1;
  while (1)
  {
    if (v10 != (*(_DWORD *)(v9 + 2072) & 1))
      goto LABEL_15;
    if (v10)
      break;
    if (*(_DWORD *)(a2 + 20) == *(_DWORD *)(v9 + 2092))
      goto LABEL_18;
LABEL_15:
    v9 = *(_QWORD *)(v9 + 2144);
    if (!v9)
      goto LABEL_19;
  }
  if (*(_QWORD *)(a2 + 20) != *(_QWORD *)(v9 + 2092) || *(_QWORD *)(a2 + 28) != *(_QWORD *)(v9 + 2100))
    goto LABEL_15;
LABEL_18:
  LODWORD(v9) = 1;
LABEL_19:
  *a3 = v9;
  pthread_rwlock_unlock(v8);
  CheckOutHandleDebug();
  return 0;
}

uint64_t TPShouldCheckForExternalCandidate(uint64_t a1)
{
  pthread_rwlock_t *v2;
  uint64_t v3;
  uint64_t v4;

  v2 = (pthread_rwlock_t *)(a1 + 1064);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 1064));
  v3 = *(_QWORD *)(a1 + 1056);
  if (v3)
  {
    while ((*(_BYTE *)(v3 + 2072) & 1) == 0
         && (*(unsigned __int16 *)(v3 + 2094) == 43518 || !strncmp((const char *)(v3 + 2076), "lo", 2uLL)))
    {
      v3 = *(_QWORD *)(v3 + 2144);
      if (!v3)
        goto LABEL_6;
    }
    v4 = 1;
  }
  else
  {
LABEL_6:
    v4 = 0;
  }
  pthread_rwlock_unlock(v2);
  return v4;
}

uint64_t TPGetConnectionData(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, const unsigned __int8 *a13)
{
  uint64_t v15;
  uint64_t v16;
  pthread_rwlock_t *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  _BOOL4 v24;
  int *v25;
  int *v26;
  uint64_t v27;
  uint64_t v29;
  int *v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  v15 = CheckInHandleDebug();
  if (!v15)
    return 2148466690;
  v16 = v15;
  if (!a10 || (*(_BYTE *)a10 & 1) != 0)
    goto LABEL_28;
  v17 = (pthread_rwlock_t *)(v15 + 1064);
  v18 = v15;
  pthread_rwlock_wrlock((pthread_rwlock_t *)(v15 + 1064));
  v29 = v18;
  v19 = *(_QWORD *)(v18 + 1056);
  if (!v19)
    goto LABEL_27;
  v20 = *(_DWORD *)a10 & 1;
  do
  {
    v21 = v19;
    if (v20 != (*(_DWORD *)(v19 + 2072) & 1))
      goto LABEL_16;
    if (v20)
    {
      v22 = *(_QWORD *)(v19 + 2100);
      if (*(_QWORD *)(a10 + 20) != *(_QWORD *)(v21 + 2092) || *(_QWORD *)(a10 + 28) != v22)
        goto LABEL_16;
    }
    else if (*(_DWORD *)(a10 + 20) != *(_DWORD *)(v19 + 2092))
    {
      goto LABEL_16;
    }
    if (*(unsigned __int16 *)(a10 + 36) == *(unsigned __int16 *)(v21 + 2108))
      goto LABEL_27;
LABEL_16:
    v19 = *(_QWORD *)(v21 + 2144);
  }
  while (v19);
  v30 = (int *)0xAAAAAAAAAAAAAAAALL;
  v24 = TransportMapPacketMultiplexModeToVTPMode(*(unsigned int *)(v29 + 4));
  if ((CreateSocketAndBind((__int128 *)a10, &v30, 1, a13, v24) & 0x80000000) != 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        TPGetConnectionData_cold_1();
    }
  }
  else
  {
    v25 = v30;
    v30[516] = a3;
    *(_QWORD *)(v21 + 2144) = v25;
    v26 = v25;
    v45 = 0u;
    v46 = 0u;
    v43 = 0u;
    v44 = 0u;
    v41 = 0u;
    v42 = 0u;
    v39 = 0u;
    v40 = 0u;
    v37 = 0u;
    v38 = 0u;
    v35 = 0u;
    v36 = 0u;
    v33 = 0u;
    v34 = 0u;
    v31 = 0u;
    v32 = 0u;
    IPPORTToStringWithSize();
    IPPORTToStringWithSize();
    *(_WORD *)(a10 + 76) = *((_WORD *)v26 + 1054);
    if ((ICEAddOneInterfaceWithPriorityHints() & 0x80000000) != 0 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        TPGetConnectionData_cold_2();
    }
    v26[528] = *(_DWORD *)(a10 + 80);
  }
LABEL_27:
  pthread_rwlock_unlock(v17);
  v16 = v29;
LABEL_28:
  if (a7)
    TPShouldCheckForExternalCandidate(v16);
  v27 = ICEGetCandidates();
  CheckOutHandleDebug();
  return v27;
}

uint64_t TPStartConnectionCheck(double a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const void *v14;
  CFTypeRef v15;
  uint64_t v16;
  NSObject *v17;
  NSObject *v19;
  uint64_t v20;
  uint8_t buf[4];
  uint64_t v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  int v26;
  __int16 v27;
  double v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v11 = CheckInHandleDebug();
  if (!v11)
    return 2148466690;
  v12 = v11 + 34328;
  if (!_CTServerConnectionCarrierSettingsCopyValue() && !*MEMORY[0x1E0C9AE50])
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v20 = VRTraceErrorLogLevelToCSTR();
      v19 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        v22 = v20;
        v23 = 2080;
        v24 = "TPStartConnectionCheck";
        v25 = 1024;
        v26 = 3564;
        _os_log_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d _CTServerConnectionCarrierSettingsCopyValue return TRUE!", buf, 0x1Cu);
      }
    }
    ICEUpdateServingNetworkInfo();
  }
  ICEUpdateCellTech();
  v14 = *(const void **)(v12 + 200);
  if (a9)
    v15 = CFRetain(a9);
  else
    v15 = 0;
  *(_QWORD *)(v12 + 200) = v15;
  if (v14)
    CFRelease(v14);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v16 = VRTraceErrorLogLevelToCSTR();
    v17 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      v22 = v16;
      v23 = 2080;
      v24 = "TPStartConnectionCheck";
      v25 = 1024;
      v26 = 3582;
      v27 = 2048;
      v28 = a1;
      _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Setting ice timeout to iceTimeout = %f", buf, 0x26u);
    }
  }
  ICESetTimeout();
  v13 = ICEStartConnectivityCheck();
  CheckOutHandleDebug();
  return v13;
}

uint64_t TPDiscardConnectionResult()
{
  uint64_t v0;

  if (!CheckInHandleDebug())
    return 2148466690;
  v0 = ICEDiscardResult();
  CheckOutHandleDebug();
  return v0;
}

uint64_t TPDiscardRelayBinding()
{
  uint64_t v0;

  if (!CheckInHandleDebug())
    return 2148466690;
  v0 = ICEDiscardRelayBinding();
  CheckOutHandleDebug();
  return v0;
}

uint64_t TPDiscardRelayBindingWithChannelNumber()
{
  uint64_t v0;

  if (!CheckInHandleDebug())
    return 2148466690;
  v0 = ICEDiscardOneRelayBindingWithChannelNumber();
  CheckOutHandleDebug();
  return v0;
}

uint64_t TPRemovePreservedPortBindForCallID(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  _BOOL4 v7;
  uint64_t v8;
  NSObject *v9;
  int v10;
  uint64_t v11;
  pthread_rwlock_t *v13;
  uint8_t buf[4];
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v3 = CheckInHandleDebug();
  if (!v3)
    return 2148466690;
  v4 = v3;
  v13 = (pthread_rwlock_t *)(v3 + 1064);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(v3 + 1064));
  v5 = *(_QWORD *)(v4 + 1056);
  if (v5)
  {
    v6 = (uint64_t *)(v4 + 1056);
    do
    {
      v7 = a2 == -1 || *(_DWORD *)(v5 + 2064) == a2;
      if (v7 && (*(_DWORD *)(v5 + 2112) & 9) != 0)
      {
        *v6 = *(_QWORD *)(v5 + 2144);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v8 = VRTraceErrorLogLevelToCSTR();
          v9 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v10 = *(_DWORD *)(v5 + 2064);
            *(_DWORD *)buf = 136316162;
            v15 = v8;
            v16 = 2080;
            v17 = "RemoveCListForCallID";
            v18 = 1024;
            v19 = 3480;
            v20 = 1024;
            v21 = a2;
            v22 = 1024;
            v23 = v10;
            _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d RemoveCListForCallID for a callid [%d == %d]", buf, 0x28u);
          }
        }
        ICERemoveOneInterface();
        v11 = *(_QWORD *)(v5 + 2128);
        if (v11 != 0xFFFFFFFFLL)
        {
          if (*(_QWORD *)(v5 + 2136) != 0xFFFFFFFFLL)
          {
            ARPLSessionRelease();
            *(_QWORD *)(v5 + 2136) = 0xFFFFFFFFLL;
            v11 = *(_QWORD *)(v5 + 2128);
          }
          DTLS_Cleanup(v11);
        }
        free((void *)v5);
      }
      else
      {
        v6 = (uint64_t *)(v5 + 2144);
      }
      v5 = *v6;
    }
    while (*v6);
  }
  pthread_rwlock_unlock(v13);
  CheckOutHandleDebug();
  return 0;
}

uint64_t TPSetCellConditionChangeHandler(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;

  v5 = CheckInHandleDebug();
  if (!v5)
    return 2148466690;
  *(_QWORD *)(v5 + 34496) = a2;
  *(_QWORD *)(v5 + 34504) = a3;
  CheckOutHandleDebug();
  return 0;
}

uint64_t TPUpdateInterfaceList(uint64_t a1, uint64_t a2, int *a3, int a4, const unsigned __int8 *a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  int LocalInterfaceListWithOptionsAndCellInterfaceName;
  unsigned int LocalIFIndexForDstIPPort;
  uint64_t v15;
  NSObject *v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t *v19;
  uint64_t v20;
  char *v21;
  _QWORD *v22;
  int v23;
  int v24;
  _QWORD *v25;
  uint64_t v27;
  NSObject *v28;
  uint64_t v29;
  __int128 *v30;
  _BOOL4 v31;
  unsigned int v32;
  int v33;
  int v34;
  uint64_t v35;
  NSObject *v36;
  int *v37;
  int **v38;
  int **v39;
  int *v40;
  uint64_t v41;
  NSObject *v42;
  uint64_t v43;
  uint64_t *v44;
  uint64_t *v45;
  uint64_t v46;
  uint64_t v47;
  NSObject *v48;
  uint64_t v49;
  int *v50;
  uint64_t v51;
  int v52;
  char flags;
  char v54;
  int *v55;
  int *v56;
  int v57;
  int ErrorLogLevelForModule;
  uint64_t v59;
  NSObject *v60;
  int v61;
  NSObject *v62;
  const char *v63;
  uint32_t v64;
  uint64_t v65;
  NSObject *v66;
  int **v67;
  int **v68;
  int *v69;
  uint64_t v70;
  NSObject *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  pthread_mutex_t *v75;
  uint64_t v76;
  uint64_t *v77;
  _QWORD *v78;
  uint64_t v80;
  uint64_t v81;
  NSObject *v82;
  _BOOL4 v83;
  int *v84;
  int v85;
  uint64_t v86;
  uint64_t v87;
  NSObject *v88;
  BOOL v89;
  int v90;
  int *v92;
  uint64_t v94;
  unsigned int v95;
  uint64_t v96;
  uint64_t v97;
  char *v98;
  int *v99;
  uint8_t buf[4];
  uint64_t v101;
  __int16 v102;
  const char *v103;
  __int16 v104;
  int v105;
  __int16 v106;
  _WORD v107[17];
  __int128 v108;
  __int128 v109;
  _BYTE v110[22];
  uint64_t v111;

  v111 = *MEMORY[0x1E0C80C00];
  v96 = 0;
  v97 = 0;
  v8 = 2148466710;
  *(_QWORD *)&v107[9] = 0;
  *(_QWORD *)&v107[13] = 0;
  v9 = CheckInHandleDebug();
  if (!v9)
    return 2148466690;
  v10 = v9;
  v92 = a3;
  *(_QWORD *)&v110[14] = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v11 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v109 = v11;
  *(_OWORD *)v110 = v11;
  v12 = v9 + 34328;
  v108 = v11;
  v98 = (char *)0xAAAAAAAAAAAAAAAALL;
  TPSetupCTContext(a1, v9, a4);
  if (*(_DWORD *)(v12 + 56))
  {
    LocalInterfaceListWithOptionsAndCellInterfaceName = 1;
    v98 = (char *)malloc_type_calloc(1uLL, 0x28uLL, 0x100004053E81896uLL);
    MakeIPPORT();
    LocalIFIndexForDstIPPort = GetLocalIFIndexForDstIPPort();
    if_indextoname(LocalIFIndexForDstIPPort, v98 + 4);
LABEL_6:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v15 = VRTraceErrorLogLevelToCSTR();
      v16 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        v101 = v15;
        v102 = 2080;
        v103 = "TPUpdateInterfaceList";
        v104 = 1024;
        v105 = 3730;
        v106 = 1024;
        *(_DWORD *)v107 = LocalInterfaceListWithOptionsAndCellInterfaceName;
        _os_log_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d %d interfaces found.", buf, 0x22u);
      }
    }
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v10 + 1064));
    if (LocalInterfaceListWithOptionsAndCellInterfaceName < 1)
    {
      v95 = 0;
      v18 = 0;
    }
    else
    {
      v17 = 0;
      v18 = 0;
      v95 = 0;
      v19 = (uint64_t *)(v10 + 1056);
      v94 = LocalInterfaceListWithOptionsAndCellInterfaceName;
      do
      {
        v20 = *v19;
        if (*v19)
        {
          v21 = &v98[40 * v17];
          v23 = *(_DWORD *)v21;
          v22 = v21 + 20;
          v24 = v23 & 1;
          v25 = (_QWORD *)(v10 + 1056);
          do
          {
            if (v24 == (*(_DWORD *)(v20 + 2072) & 1))
            {
              if (v24)
              {
                if (*v22 == *(_QWORD *)(v20 + 2092) && v22[1] == *(_QWORD *)(v20 + 2100))
                {
LABEL_37:
                  v99 = (int *)v20;
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
                  {
                    v41 = VRTraceErrorLogLevelToCSTR();
                    v42 = *MEMORY[0x1E0CF2758];
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                    {
                      v43 = IPPORTToStringWithSize();
                      *(_DWORD *)buf = 136315906;
                      v101 = v41;
                      v102 = 2080;
                      v103 = "TPUpdateInterfaceList";
                      v104 = 1024;
                      v105 = 3740;
                      v106 = 2080;
                      *(_QWORD *)v107 = v43;
                      _os_log_impl(&dword_1D8A54000, v42, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Keep listening on %s", buf, 0x26u);
                    }
                  }
                  if ((v98[40 * v17] & 1) != 0)
                  {
                    VCNAT64ResolverIsBehindNat64((uint64_t)&v98[40 * v17 + 4]);
                    ICEUpdateNAT64FlagForInterface();
                  }
                  *v25 = *(_QWORD *)(v20 + 2144);
                  *(_QWORD *)(v20 + 2144) = 0;
                  v44 = &v96;
                  do
                  {
                    v45 = v44;
                    v46 = *v44;
                    v44 = (uint64_t *)(*v44 + 2144);
                  }
                  while (v46);
                  *v45 = v20;
                  goto LABEL_45;
                }
              }
              else if (*(_DWORD *)v22 == *(_DWORD *)(v20 + 2092))
              {
                goto LABEL_37;
              }
            }
            v25 = (_QWORD *)(v20 + 2144);
            v20 = *(_QWORD *)(v20 + 2144);
          }
          while (v20);
        }
        v99 = 0;
        HIDWORD(v97) = 1;
        *(_WORD *)&v98[40 * v17 + 36] = *(_WORD *)(v10 + 20);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v27 = VRTraceErrorLogLevelToCSTR();
          v28 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v29 = IPPORTToStringWithSize();
            *(_DWORD *)buf = 136315906;
            v101 = v27;
            v102 = 2080;
            v103 = "TPUpdateInterfaceList";
            v104 = 1024;
            v105 = 3767;
            v106 = 2080;
            *(_QWORD *)v107 = v29;
            _os_log_impl(&dword_1D8A54000, v28, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Adding [%s] to list", buf, 0x26u);
          }
        }
        v30 = (__int128 *)&v98[40 * v17];
        v31 = TransportMapPacketMultiplexModeToVTPMode(*(unsigned int *)(v10 + 4));
        v32 = CreateSocketAndBind(v30, &v99, 0, a5, v31);
        if ((v32 & 0x80000000) != 0)
        {
          v18 = v32;
        }
        else
        {
          VCTestMonitorManager_GetEnableLoopbackInterface();
          v33 = ICESetEnableLoopbackInterface();
          if (v33 < 0)
          {
            v34 = v33;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              v35 = VRTraceErrorLogLevelToCSTR();
              v36 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136316162;
                v101 = v35;
                v102 = 2080;
                v103 = "TPUpdateInterfaceList";
                v104 = 1024;
                v105 = 3777;
                v106 = 1024;
                *(_DWORD *)v107 = 3777;
                v107[2] = 1024;
                *(_DWORD *)&v107[3] = v34;
                _os_log_error_impl(&dword_1D8A54000, v36, OS_LOG_TYPE_ERROR, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/Transport.c:%d: ICESetEnableLoopbackInterface failed(%08X)", buf, 0x28u);
              }
            }
          }
          v37 = v99;
          v18 = ICEAddOneInterface();
          if ((v18 & 0x80000000) != 0)
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v47 = VRTraceErrorLogLevelToCSTR();
              v48 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315906;
                v101 = v47;
                v102 = 2080;
                v103 = "TPUpdateInterfaceList";
                v104 = 1024;
                v105 = 3784;
                v106 = 1024;
                *(_DWORD *)v107 = v18;
                _os_log_impl(&dword_1D8A54000, v48, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d ICEAddOneInterface failed %08x", buf, 0x22u);
              }
            }
            VTP_Close(*v37);
            v49 = *((_QWORD *)v37 + 266);
            if (v49 != 0xFFFFFFFFLL)
            {
              if (*((_QWORD *)v37 + 267) != 0xFFFFFFFFLL)
              {
                ARPLSessionRelease();
                *((_QWORD *)v37 + 267) = 0xFFFFFFFFLL;
                v49 = *((_QWORD *)v37 + 266);
              }
              DTLS_Cleanup(v49);
            }
            free(v37);
          }
          else
          {
            if ((v98[40 * v17] & 1) != 0)
            {
              VCNAT64ResolverIsBehindNat64((uint64_t)(v37 + 519));
              ICEUpdateNAT64FlagForInterface();
            }
            v38 = (int **)&v96;
            do
            {
              v39 = v38;
              v40 = *v38;
              v38 = (int **)(*v38 + 536);
            }
            while (v40);
            *v39 = v37;
LABEL_45:
            ++v95;
          }
        }
        ++v17;
      }
      while (v17 != v94);
    }
    FreeLocalInterfaceList();
    v50 = *(int **)(v10 + 1056);
    v99 = v50;
    if (!v50)
    {
      LODWORD(v51) = v95;
      goto LABEL_113;
    }
    v51 = v95;
LABEL_59:
    v52 = v50[518];
    if (nwi_state_copy())
    {
      if (nwi_state_get_ifstate())
      {
        flags = nwi_ifstate_get_flags();
        v54 = flags;
        if ((v52 & 1) == 0 && (flags & 1) != 0)
        {
          nwi_state_release();
LABEL_66:
          v56 = v99;
          v57 = *((unsigned __int8 *)v99 + 4);
          ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
          if (v57)
          {
            if (ErrorLogLevelForModule >= 7)
            {
              v59 = VRTraceErrorLogLevelToCSTR();
              v60 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                v61 = *v56;
                *(_DWORD *)buf = 136315906;
                v101 = v59;
                v102 = 2080;
                v103 = "TPUpdateInterfaceList";
                v104 = 1024;
                v105 = 3828;
                v106 = 1024;
                *(_DWORD *)v107 = v61;
                v62 = v60;
                v63 = "SIP [%s] %s:%d Keep listening on virtual interface (vfd %d)";
                v64 = 34;
                goto LABEL_73;
              }
            }
          }
          else if (ErrorLogLevelForModule >= 7)
          {
            v65 = VRTraceErrorLogLevelToCSTR();
            v66 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315906;
              v101 = v65;
              v102 = 2080;
              v103 = "TPUpdateInterfaceList";
              v104 = 1024;
              v105 = 3830;
              v106 = 2080;
              *(_QWORD *)v107 = v56 + 519;
              v62 = v66;
              v63 = "SIP [%s] %s:%d Interface '%s' is not in the routing table but still valid. Keeping it";
              v64 = 38;
LABEL_73:
              _os_log_impl(&dword_1D8A54000, v62, OS_LOG_TYPE_DEFAULT, v63, buf, v64);
            }
          }
          v50 = (int *)*((_QWORD *)v56 + 268);
          *((_QWORD *)v56 + 268) = 0;
          v67 = (int **)&v96;
          do
          {
            v68 = v67;
            v69 = *v67;
            v67 = (int **)(*v67 + 536);
          }
          while (v69);
          *v68 = v56;
          v51 = (v51 + 1);
          goto LABEL_110;
        }
        nwi_state_release();
        if ((v52 & 1) != 0 && (v54 & 2) != 0)
          goto LABEL_66;
      }
      else
      {
        nwi_state_release();
      }
    }
    v55 = v99;
    if (*((_BYTE *)v99 + 4))
      goto LABEL_66;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v70 = VRTraceErrorLogLevelToCSTR();
      v71 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v72 = IPPORTToStringWithSize();
        *(_DWORD *)buf = 136315906;
        v101 = v70;
        v102 = 2080;
        v103 = "TPUpdateInterfaceList";
        v104 = 1024;
        v105 = 3848;
        v106 = 2080;
        *(_QWORD *)v107 = v72;
        _os_log_impl(&dword_1D8A54000, v71, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Stop listening on %s", buf, 0x26u);
      }
    }
    v73 = 0;
    HIDWORD(v97) = 1;
    v50 = (int *)*((_QWORD *)v55 + 268);
    while (1)
    {
      v74 = v10 + (v73 << 7);
      v75 = (pthread_mutex_t *)(v74 + 1560);
      pthread_mutex_lock((pthread_mutex_t *)(v74 + 1560));
      v76 = *(_QWORD *)(v74 + 1552);
      if (v76)
        break;
LABEL_96:
      pthread_mutex_unlock(v75);
      if (++v73 == 256)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() <= 6)
        {
          v84 = v99;
        }
        else
        {
          v80 = v51;
          v81 = VRTraceErrorLogLevelToCSTR();
          v82 = *MEMORY[0x1E0CF2758];
          v83 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
          v84 = v99;
          if (v83)
          {
            v85 = v99[516];
            *(_DWORD *)buf = 136315906;
            v101 = v81;
            v102 = 2080;
            v103 = "TPUpdateInterfaceList";
            v104 = 1024;
            v105 = 3871;
            v106 = 1024;
            *(_DWORD *)v107 = v85;
            _os_log_impl(&dword_1D8A54000, v82, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TPUpdateInterfaceList: %u", buf, 0x22u);
          }
          v51 = v80;
        }
        ICERemoveOneInterface();
        VTP_Close(*v84);
        v86 = *((_QWORD *)v84 + 266);
        if (v86 != 0xFFFFFFFFLL)
        {
          if (*((_QWORD *)v84 + 267) != 0xFFFFFFFFLL)
          {
            ARPLSessionRelease();
            *((_QWORD *)v84 + 267) = 0xFFFFFFFFLL;
            v86 = *((_QWORD *)v84 + 266);
          }
          DTLS_Cleanup(v86);
        }
        free(v84);
LABEL_110:
        v99 = v50;
        if (!v50)
        {
LABEL_113:
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v87 = VRTraceErrorLogLevelToCSTR();
            v88 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315906;
              v101 = v87;
              v102 = 2080;
              v103 = "TPUpdateInterfaceList";
              v104 = 1024;
              v105 = 3890;
              v106 = 1024;
              *(_DWORD *)v107 = v51;
              _os_log_impl(&dword_1D8A54000, v88, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TPUpdateInterfaceList:%d valid interfaces found.", buf, 0x22u);
            }
          }
          if (v96)
            v8 = v18;
          else
            v8 = 2148466710;
          *(_QWORD *)(v10 + 1056) = v96;
          VTP_Close(*(_DWORD *)(v10 + 12));
          *(_DWORD *)(v10 + 12) = -1;
          pthread_rwlock_unlock((pthread_rwlock_t *)(v10 + 1064));
          if (!HIDWORD(v97))
            ICEInterfaceNeedsUpdateExternalMapping();
          CheckOutHandleDebug();
          if ((v8 & 0x80000000) == 0)
          {
            *(_DWORD *)buf = 0;
            v8 = TPGetRemoteICEVersion();
            if ((v8 & 0x80000000) != 0)
            {
              v90 = 0;
            }
            else
            {
              if (HIDWORD(v97))
                v89 = (*(_DWORD *)buf - 1010) >= 0xFFFFFC0F;
              else
                v89 = 1;
              v90 = !v89;
            }
            *v92 = v90;
          }
          return v8;
        }
        goto LABEL_59;
      }
    }
    v77 = (uint64_t *)(v74 + 1552);
    while ((*(_DWORD *)(v76 + 2056) & 1) == (v99[518] & 1))
    {
      v78 = (_QWORD *)(v76 + 2076);
      if ((*(_DWORD *)(v76 + 2056) & 1) != 0)
      {
        if (*v78 != *(_QWORD *)(v99 + 523) || *(_QWORD *)(v76 + 2084) != *(_QWORD *)(v99 + 525))
          break;
      }
      else if (*(_DWORD *)v78 != v99[523])
      {
        break;
      }
      if (*(unsigned __int16 *)(v76 + 2092) != *((unsigned __int16 *)v99 + 1054))
        break;
      *v77 = *(_QWORD *)(v76 + 2144);
      free((void *)v76);
LABEL_95:
      v76 = *v77;
      if (!*v77)
        goto LABEL_96;
    }
    v77 = (uint64_t *)(v76 + 2144);
    goto LABEL_95;
  }
  LocalInterfaceListWithOptionsAndCellInterfaceName = GetLocalInterfaceListWithOptionsAndCellInterfaceName();
  if (LocalInterfaceListWithOptionsAndCellInterfaceName)
    goto LABEL_6;
  FreeLocalInterfaceList();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      TPUpdateInterfaceList_cold_1();
  }
  CheckOutHandleDebug();
  return v8;
}

void TPSetupCTContext(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  NSObject *v7;
  pthread_mutex_t *v8;
  uint64_t v9;
  NSObject *v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  int ErrorLogLevelForModule;
  uint64_t v16;
  NSObject *v17;
  uint64_t v18;
  NSObject *v19;
  uint8_t buf[4];
  uint64_t v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  _BYTE v27[10];
  __int16 v28;
  int v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v4 = a2 + 34456;
  v5 = *(_DWORD *)(a2 + 34512);
  if (!(v5 | a3))
  {
    *(_DWORD *)(a2 + 34512) = 1;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v6 = VRTraceErrorLogLevelToCSTR();
      v7 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        v21 = v6;
        v22 = 2080;
        v23 = "TPSetupCTContext";
        v24 = 1024;
        v25 = 2520;
        _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Device hw model supports FaceTime over cellular network.", buf, 0x1Cu);
      }
    }
    v5 = *(_DWORD *)(v4 + 56);
  }
  if (v5)
  {
    v8 = (pthread_mutex_t *)(a2 + 34392);
    pthread_mutex_lock(v8);
    if (!*(_QWORD *)v4)
    {
      dispatch_get_global_queue(0, 0);
      v14 = _CTServerConnectionCreateOnTargetQueue();
      *(_QWORD *)v4 = v14;
      ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
      if (v14)
      {
        if (ErrorLogLevelForModule >= 7)
        {
          v16 = VRTraceErrorLogLevelToCSTR();
          v17 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315650;
            v21 = v16;
            v22 = 2080;
            v23 = "TPSetupCTContext";
            v24 = 1024;
            v25 = 2532;
            _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d _CTServerConnectionCreateOnTargetQueue succeeded!", buf, 0x1Cu);
          }
        }
        if (!_CTServerConnectionRegisterForNotification())
        {
          *(_DWORD *)(v4 + 68) = 1;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v18 = VRTraceErrorLogLevelToCSTR();
            v19 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315650;
              v21 = v18;
              v22 = 2080;
              v23 = "TPSetupCTContext";
              v24 = 1024;
              v25 = 2536;
              _os_log_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d kCTRegistrationDataStatusChangedNotification registered.", buf, 0x1Cu);
            }
          }
        }
      }
      else if (ErrorLogLevelForModule >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          TPSetupCTContext_cold_1();
      }
    }
    if (!VCCTServiceMonitor_GetSignalStrength() && (int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v9 = VRTraceErrorLogLevelToCSTR();
      v10 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v11 = *(_DWORD *)(v4 + 20);
        v12 = *(_DWORD *)(v4 + 24);
        v13 = *(_DWORD *)(v4 + 28);
        *(_DWORD *)buf = 136316418;
        v21 = v9;
        v22 = 2080;
        v23 = "TPSetupCTContext";
        v24 = 1024;
        v25 = 2544;
        v26 = 1024;
        *(_DWORD *)v27 = v11;
        *(_WORD *)&v27[4] = 1024;
        *(_DWORD *)&v27[6] = v12;
        v28 = 1024;
        v29 = v13;
        _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Received cellular signal strength. [Strength: %d displayBars: %d maxDisplayBars: %d]", buf, 0x2Eu);
      }
    }
    *(_DWORD *)(v4 + 16) = TPGetLocalCellTech(*(_QWORD *)v4);
    VCCTServiceMonitor_CopyConnectionStatusInterfaceName();
    pthread_mutex_unlock(v8);
  }
}

uint64_t CreateSocketAndBind(__int128 *a1, int **a2, int a3, const unsigned __int8 *a4, int a5)
{
  sockaddr v10;
  int *v11;
  _OWORD *v12;
  __int128 v13;
  __int128 v14;
  int v15;
  int v16;
  __int128 v17;
  const char *v18;
  uint64_t v19;
  unsigned __int16 *v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  uint64_t v27;
  socklen_t v28;
  int v29;
  int v30;
  __int128 v31;
  uint64_t v32;
  NSObject *v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  NSObject *v38;
  __int128 v40;
  __int128 v41;
  int v42;
  int ErrorLogLevelForModule;
  uint64_t v44;
  NSObject *v45;
  const char *v46;
  NSObject *v47;
  uint32_t v48;
  uint64_t v49;
  NSObject *v50;
  NSObject *v51;
  int v52;
  int v53;
  socklen_t v54;
  char __str[8];
  addrinfo v56;
  __int16 v57;
  int v58;
  uuid_string_t out;
  _BYTE buf[54];
  _OWORD v61[2];
  unint64_t v62;
  sockaddr v63[10];
  _BYTE v64[22];
  uint64_t v65;

  v65 = *MEMORY[0x1E0C80C00];
  v54 = -1431655766;
  memset(__str, 170, 6);
  *(_QWORD *)&v64[14] = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v10.sa_len = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v10.sa_data[6] = 0xAAAAAAAAAAAAAAAALL;
  v63[9] = v10;
  *(sockaddr *)v64 = v10;
  v63[8] = v10;
  v63[6] = v10;
  v63[7] = v10;
  v63[4] = v10;
  v63[5] = v10;
  v63[2] = v10;
  v63[3] = v10;
  v63[0] = v10;
  v63[1] = v10;
  v11 = (int *)malloc_type_calloc(1uLL, 0x868uLL, 0x10200406FE3F67FuLL);
  *a2 = v11;
  if (v11)
  {
    *((_QWORD *)v11 + 258) = 0;
    *((_QWORD *)v11 + 266) = 0xFFFFFFFFLL;
    *((_QWORD *)*a2 + 267) = 0xFFFFFFFFLL;
    v12 = *a2 + 518;
    v13 = *a1;
    v14 = a1[1];
    *((_QWORD *)*a2 + 263) = *((_QWORD *)a1 + 4);
    *v12 = v13;
    v12[1] = v14;
    v15 = *(_DWORD *)a1;
    if ((*(_DWORD *)a1 & 1) != 0)
      v16 = 30;
    else
      v16 = 2;
    *(_QWORD *)&v17 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v17 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&buf[16] = v17;
    *(_OWORD *)&buf[32] = v17;
    *(_OWORD *)buf = v17;
    *(_QWORD *)&v61[0] = 0xAAAAAAAAAAAAAAAALL;
    memset(&v56.ai_socktype, 0, 40);
    v56.ai_flags = 5;
    v56.ai_family = v16;
    v56.ai_socktype = 2;
    if ((v15 & 1) != 0)
    {
      if (*(_QWORD *)((char *)a1 + 20) != *MEMORY[0x1E0C83920]
        || *(_QWORD *)((char *)a1 + 28) != *(_QWORD *)(MEMORY[0x1E0C83920] + 8))
      {
        goto LABEL_7;
      }
    }
    else if (*((_DWORD *)a1 + 5))
    {
LABEL_7:
      v18 = (const char *)IPToString();
      goto LABEL_17;
    }
    v18 = 0;
LABEL_17:
    v21 = (unsigned __int16 *)a1 + 18;
    snprintf(__str, 6uLL, "%d", *((unsigned __int16 *)a1 + 18));
    v22 = getaddrinfo(v18, __str, &v56, (addrinfo **)v61);
    if (v22)
    {
      v19 = v22 | 0xB00F0000;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          CreateSocketAndBind_cold_6();
      }
      goto LABEL_52;
    }
    v23 = *(_QWORD *)&v61[0];
    if (!*(_QWORD *)&v61[0])
    {
      v19 = 2148466692;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          CreateSocketAndBind_cold_2();
          v19 = 2148466692;
        }
      }
      goto LABEL_52;
    }
    v24 = *(_QWORD *)&v61[0];
    while (*(_DWORD *)(v24 + 4) != v16)
    {
      v24 = *(_QWORD *)(v24 + 40);
      if (!v24)
      {
        v16 = *(_DWORD *)(*(_QWORD *)&v61[0] + 4);
        goto LABEL_30;
      }
    }
    v23 = v24;
LABEL_30:
    v25 = VTP_Socket(v16, *(_DWORD *)(v23 + 8), *(_DWORD *)(v23 + 12));
    **a2 = v25;
    if (v25 == -1)
    {
      v19 = *__error() | 0xC00F0000;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          CreateSocketAndBind_cold_3();
      }
      freeaddrinfo(*(addrinfo **)&v61[0]);
      goto LABEL_52;
    }
    VTP_SetSocketMode(v25, a5);
    v26 = **a2;
    v27 = *(_QWORD *)(v23 + 32);
    v28 = *(_DWORD *)(v23 + 16);
    if (a3)
      v29 = VTP_BindNew(v26, v27, v28);
    else
      v29 = VTP_Bind(v26, v27, v28);
    v30 = v29;
    VTP_DetectNAT64Prefix(**a2, (const char *)*a2 + 2076);
    freeaddrinfo(*(addrinfo **)&v61[0]);
    if (v30 == -1)
    {
      v19 = *__error() | 0xC00F0000;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v37 = VRTraceErrorLogLevelToCSTR();
        v38 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          CreateSocketAndBind_cold_4(v37, v21, v38);
      }
    }
    else
    {
      VTP_SetPktType(**a2, 48142);
      v54 = 128;
      if (VTP_Getsockname(**a2, v63, &v54) != -1)
      {
        v62 = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v31 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v31 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v61[0] = v31;
        v61[1] = v31;
        SAToIPPORT();
        *((_WORD *)*a2 + 1054) = WORD2(v62);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
        {
          v32 = VRTraceErrorLogLevelToCSTR();
          v33 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v34 = IPPORTToStringWithSize();
            v35 = (uint64_t)(*a2 + 519);
            v36 = **a2;
            *(_DWORD *)buf = 136316418;
            *(_QWORD *)&buf[4] = v32;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "CreateSocketAndBind";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 2432;
            *(_WORD *)&buf[28] = 2080;
            *(_QWORD *)&buf[30] = v34;
            *(_WORD *)&buf[38] = 2080;
            *(_QWORD *)&buf[40] = v35;
            *(_WORD *)&buf[48] = 1024;
            *(_DWORD *)&buf[50] = v36;
            _os_log_impl(&dword_1D8A54000, v33, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Start listening on %s(%s) sock %d", buf, 0x36u);
          }
        }
        if (uuid_is_null(a4))
          goto LABEL_44;
        *(_QWORD *)&buf[46] = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v40 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v40 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)&buf[16] = v40;
        *(_OWORD *)&buf[32] = v40;
        *(_OWORD *)buf = v40;
        IPPORTToStringWithSize();
        *(_QWORD *)&out[29] = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v41 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v41 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)out = v41;
        *(_OWORD *)&out[16] = v41;
        uuid_unparse(a4, out);
        v42 = VTP_Setsockopt(**a2, 0xFFFF, 4360, a4, 0x10u);
        ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
        if (v42 == -1)
        {
          if (ErrorLogLevelForModule < 8)
            goto LABEL_44;
          v49 = VRTraceErrorLogLevelToCSTR();
          v50 = *MEMORY[0x1E0CF2758];
          v51 = *MEMORY[0x1E0CF2758];
          if (!*MEMORY[0x1E0CF2748])
          {
            if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
            {
              v53 = *__error();
              v56.ai_flags = 136316418;
              *(_QWORD *)&v56.ai_family = v49;
              LOWORD(v56.ai_protocol) = 2080;
              *(_QWORD *)((char *)&v56.ai_protocol + 2) = "CreateSocketAndBind";
              *((_WORD *)&v56.ai_addrlen + 3) = 1024;
              LODWORD(v56.ai_canonname) = 2442;
              WORD2(v56.ai_canonname) = 2080;
              *(char **)((char *)&v56.ai_canonname + 6) = out;
              HIWORD(v56.ai_addr) = 2080;
              v56.ai_next = (addrinfo *)buf;
              v57 = 1024;
              v58 = v53;
              _os_log_debug_impl(&dword_1D8A54000, v50, OS_LOG_TYPE_DEBUG, "SIP [%s] %s:%d CreateSocketAndBind: Unable to set delegatedUUID(%s) for socket %s with error %d)", (uint8_t *)&v56, 0x36u);
            }
            goto LABEL_44;
          }
          if (!os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
          {
LABEL_44:
            v19 = 0;
            (*a2)[2] = 2048;
            return v19;
          }
          v52 = *__error();
          v56.ai_flags = 136316418;
          *(_QWORD *)&v56.ai_family = v49;
          LOWORD(v56.ai_protocol) = 2080;
          *(_QWORD *)((char *)&v56.ai_protocol + 2) = "CreateSocketAndBind";
          *((_WORD *)&v56.ai_addrlen + 3) = 1024;
          LODWORD(v56.ai_canonname) = 2442;
          WORD2(v56.ai_canonname) = 2080;
          *(char **)((char *)&v56.ai_canonname + 6) = out;
          HIWORD(v56.ai_addr) = 2080;
          v56.ai_next = (addrinfo *)buf;
          v57 = 1024;
          v58 = v52;
          v46 = "SIP [%s] %s:%d CreateSocketAndBind: Unable to set delegatedUUID(%s) for socket %s with error %d)";
          v47 = v50;
          v48 = 54;
        }
        else
        {
          if (ErrorLogLevelForModule < 7)
            goto LABEL_44;
          v44 = VRTraceErrorLogLevelToCSTR();
          v45 = *MEMORY[0x1E0CF2758];
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            goto LABEL_44;
          v56.ai_flags = 136316162;
          *(_QWORD *)&v56.ai_family = v44;
          LOWORD(v56.ai_protocol) = 2080;
          *(_QWORD *)((char *)&v56.ai_protocol + 2) = "CreateSocketAndBind";
          *((_WORD *)&v56.ai_addrlen + 3) = 1024;
          LODWORD(v56.ai_canonname) = 2444;
          WORD2(v56.ai_canonname) = 2080;
          *(char **)((char *)&v56.ai_canonname + 6) = out;
          HIWORD(v56.ai_addr) = 2080;
          v56.ai_next = (addrinfo *)buf;
          v46 = "SIP [%s] %s:%d CreateSocketAndBind: Set delegatedUUID(%s) for socket %s)";
          v47 = v45;
          v48 = 48;
        }
        _os_log_impl(&dword_1D8A54000, v47, OS_LOG_TYPE_DEFAULT, v46, (uint8_t *)&v56, v48);
        goto LABEL_44;
      }
      v19 = *__error() | 0xC00F0000;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          CreateSocketAndBind_cold_5();
      }
    }
    VTP_Close(**a2);
LABEL_52:
    free(*a2);
    return v19;
  }
  v19 = 2148466691;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      CreateSocketAndBind_cold_1();
  }
  return v19;
}

BOOL TransportMapPacketMultiplexModeToVTPMode(_BOOL8 result)
{
  if (!result && result != 2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      TransportMapPacketMultiplexModeToVTPMode_cold_1();
    }
    return 0;
  }
  return result;
}

uint64_t TPGetRemoteICEVersion()
{
  uint64_t v0;

  if (!CheckInHandleDebug())
    return 2148466690;
  v0 = ICEGetRemoteICEVersion();
  CheckOutHandleDebug();
  return v0;
}

uint64_t TPStopConnectivityCheck()
{
  uint64_t v0;

  if (!CheckInHandleDebug())
    return 2148466690;
  v0 = ICEStopConnectivityCheck();
  CheckOutHandleDebug();
  return v0;
}

uint64_t TPGetNextBestCandidate()
{
  uint64_t BestCandidate;

  if (!CheckInHandleDebug())
    return 2148466690;
  BestCandidate = ICEGetNextBestCandidate();
  CheckOutHandleDebug();
  return BestCandidate;
}

uint64_t TPGetRemoteCIDForDstIPPort()
{
  uint64_t v0;

  if (!CheckInHandleDebug())
    return 2148466690;
  v0 = ICEGetRemoteCIDForDstIPPort();
  CheckOutHandleDebug();
  return v0;
}

uint64_t TPSetSKEState()
{
  uint64_t v0;

  if (!CheckInHandleDebug())
    return 2148466690;
  v0 = ICESetSKEState();
  CheckOutHandleDebug();
  return v0;
}

uint64_t TPSetForceRelay()
{
  if (!CheckInHandleDebug())
    return 2148466690;
  ICESetForceRelay();
  CheckOutHandleDebug();
  return 0;
}

uint64_t TPSetForceIPv6()
{
  if (!CheckInHandleDebug())
    return 2148466690;
  ICESetForceIPv6();
  CheckOutHandleDebug();
  return 0;
}

uint64_t TPSetReportingAgent()
{
  uint64_t v0;

  if (!CheckInHandleDebug())
    return 2148466690;
  v0 = ICESetReportingAgent();
  CheckOutHandleDebug();
  return v0;
}

uint64_t TPSetICETimeout(double a1)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  int v6;
  uint64_t v7;
  __int16 v8;
  const char *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  double v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (!CheckInHandleDebug())
    return 2148466690;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v6 = 136315906;
      v7 = v2;
      v8 = 2080;
      v9 = "TPSetICETimeout";
      v10 = 1024;
      v11 = 4047;
      v12 = 2048;
      v13 = a1;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Setting ice timeout to %f", (uint8_t *)&v6, 0x26u);
    }
  }
  v4 = ICESetTimeout();
  CheckOutHandleDebug();
  return v4;
}

uint64_t TPSetARPLHandler(uint64_t a1, const void *a2)
{
  uint64_t result;
  void **v4;
  const void *v5;

  result = CheckInHandleDebug();
  if (result)
  {
    v4 = (void **)(result + 34544);
    v5 = *(const void **)(result + 34544);
    if (v5)
      _Block_release(v5);
    *v4 = _Block_copy(a2);
    return CheckOutHandleDebug();
  }
  return result;
}

uint64_t TPCleanupARPLHandler()
{
  uint64_t result;
  _QWORD *v1;
  const void *v2;

  result = CheckInHandleDebug();
  if (result)
  {
    v1 = (_QWORD *)(result + 34544);
    v2 = *(const void **)(result + 34544);
    if (v2)
    {
      _Block_release(v2);
      *v1 = 0;
    }
    return CheckOutHandleDebug();
  }
  return result;
}

uint64_t TPUpdateICERole(uint64_t a1, uint64_t a2, int a3, int a4, const __CFString *a5)
{
  uint64_t v8;
  uint64_t v9;
  pthread_rwlock_t *v10;
  uint64_t v11;
  uint64_t v12;

  v8 = CheckInHandleDebug();
  if (!v8)
    return 2148466690;
  v9 = v8;
  *(_DWORD *)(v8 + 34536) = a3;
  v10 = (pthread_rwlock_t *)(v8 + 1064);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(v8 + 1064));
  v11 = *(_QWORD *)(v9 + 1056);
  if (v11)
  {
    if (!a4)
      a5 = 0;
    do
    {
      *(_QWORD *)(v11 + 2116) = 0;
      if (!*(_DWORD *)(v11 + 2068))
      {
        VTP_SetSessionID(*(_DWORD *)v11, a5);
        *(_DWORD *)(v11 + 2120) = a4;
        *(_DWORD *)(v11 + 2116) = a3;
      }
      v11 = *(_QWORD *)(v11 + 2144);
    }
    while (v11);
  }
  pthread_rwlock_unlock(v10);
  v12 = ICEUpdateRole();
  CheckOutHandleDebug();
  return v12;
}

uint64_t TPUpdateQoS(uint64_t a1, int a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2148466690;
  *(_DWORD *)(v3 + 34516) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t TPGetConnErrorCode()
{
  uint64_t v0;

  if (!CheckInHandleDebug())
    return 2148466690;
  v0 = ICEGetConnErrorCode();
  CheckOutHandleDebug();
  return v0;
}

uint64_t TPSetDataPacketReceivedCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  _QWORD *v6;
  pthread_mutex_t *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  void (*v12)(void);
  void (*v13)(uint64_t);
  BOOL v14;

  v5 = CheckInHandleDebug();
  if (!v5)
    return 2148466690;
  v6 = (_QWORD *)(v5 + 34552);
  v7 = (pthread_mutex_t *)(v5 + 34584);
  pthread_mutex_lock((pthread_mutex_t *)(v5 + 34584));
  *v6 = a2;
  if (a3)
  {
    v10 = v6[1];
    v9 = v6 + 1;
    v8 = v10;
    v11 = *(_QWORD *)(a3 + 16);
    *(_OWORD *)v9 = *(_OWORD *)a3;
    v12 = (void (*)(void))v9[1];
    v13 = (void (*)(uint64_t))v9[2];
    v9[2] = v11;
    if (v12 && *v9)
      v12();
    if (v13)
      v14 = v8 == 0;
    else
      v14 = 1;
    if (!v14)
      v13(v8);
  }
  pthread_mutex_unlock(v7);
  CheckOutHandleDebug();
  return 0;
}

uint64_t TPProcessRemoteInterfaceChangeMessage(uint64_t a1, int a2, int a3, const UInt8 *a4, int a5, int a6)
{
  CFDataRef v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  pthread_mutex_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  NSObject *v23;
  int v25;
  uint64_t v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  int v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (CheckInHandleDebug())
  {
    if (!a4)
    {
      v17 = 2148859905;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          TPProcessRemoteInterfaceChangeMessage_cold_1();
      }
      goto LABEL_25;
    }
    if (a3 && (v11 = CFDataCreate(0, a4, a5), v12 = ICEConnectionDataContainsCallID(), CFRelease(v11), !v12))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v18 = VRTraceErrorLogLevelToCSTR();
        v19 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v25 = 136315650;
          v26 = v18;
          v27 = 2080;
          v28 = "needUpdateRemoteCandidateList";
          v29 = 1024;
          v30 = 4196;
          _os_log_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d HandoverReport: needUpdateRemoteCandidateList didn't find matched callID", (uint8_t *)&v25, 0x1Cu);
        }
      }
    }
    else
    {
      v13 = CheckInHandleDebug();
      if (v13)
      {
        v14 = v13;
        v15 = (pthread_mutex_t *)(v13 + 168);
        pthread_mutex_lock((pthread_mutex_t *)(v13 + 168));
        v16 = *(_QWORD *)(v14 + 232);
        if (v16)
        {
          while (*(_DWORD *)(v16 + 148) != a2)
          {
            v16 = *(_QWORD *)(v16 + 912);
            if (!v16)
              goto LABEL_9;
          }
          v20 = *(_DWORD *)(v16 + 208);
          pthread_mutex_unlock(v15);
          CheckOutHandleDebug();
          if (v20 < a6)
          {
            v21 = ICEAddRemovedRemoteIPPort();
            if ((v21 & 0x80000000) == 0)
              v21 = ICEProcessRemoteInterfaceChange();
            v17 = v21;
            goto LABEL_25;
          }
        }
        else
        {
LABEL_9:
          pthread_mutex_unlock(v15);
          CheckOutHandleDebug();
        }
      }
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v22 = VRTraceErrorLogLevelToCSTR();
      v23 = *MEMORY[0x1E0CF2758];
      v17 = 0;
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
LABEL_25:
        CheckOutHandleDebug();
        return v17;
      }
      v25 = 136315650;
      v26 = v22;
      v27 = 2080;
      v28 = "TPProcessRemoteInterfaceChangeMessage";
      v29 = 1024;
      v30 = 4236;
      _os_log_impl(&dword_1D8A54000, v23, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d HandoverReport: TPProcessRemoteInterfaceChangeMessage, remote candidate list already updated", (uint8_t *)&v25, 0x1Cu);
    }
    v17 = 0;
    goto LABEL_25;
  }
  return 2148466690;
}

uint64_t TPSetAllowSameSourceDestination(uint64_t a1, char a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2148466690;
  *(_BYTE *)(v3 + 34648) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t SendUDPPacketForCList(uint64_t a1, void *a2, int a3, uint64_t a4, int *a5, int *a6)
{
  int ErrorLogLevelForModule;
  _BYTE *v12;
  uint64_t v13;
  NSObject *v14;
  NSObject *v15;
  int v16;
  uint64_t v17;
  NSObject *v18;
  NSObject *v19;
  int v20;
  uint64_t v21;
  _QWORD *v22;
  int v23;
  _QWORD *v24;
  int v25;
  int v28;
  uint64_t v29;
  NSObject *v30;
  uint64_t v31;
  sockaddr *v32;
  int v33;
  int v34;
  BOOL v35;
  _BOOL4 v36;
  uint64_t v37;
  int v38;
  int v40;
  int v41;
  void *v42;
  socklen_t v44;
  uint8_t v45[4];
  uint64_t v46;
  __int16 v47;
  const char *v48;
  __int16 v49;
  int v50;
  _BYTE v51[44];
  __int16 v52;
  uint8_t *v53;
  __int16 v54;
  int v55;
  uint8_t buf[48];
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  _BYTE v62[136];
  uint64_t v63;

  v63 = *MEMORY[0x1E0C80C00];
  if (*a6 == 5 && !*((_BYTE *)a6 + 12) && (int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      SendUDPPacketForCList_cold_1();
  }
  memset(v62, 0, 128);
  IPToString();
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  v12 = (_BYTE *)MEMORY[0x1E0CF2748];
  if (ErrorLogLevelForModule >= 8)
  {
    v13 = VRTraceErrorLogLevelToCSTR();
    v14 = *MEMORY[0x1E0CF2758];
    v15 = *MEMORY[0x1E0CF2758];
    if (*v12)
    {
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        v16 = *(unsigned __int16 *)(a4 + 36);
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)&buf[4] = v13;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "SendUDPPacketForCList";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 218;
        *(_WORD *)&buf[28] = 2080;
        *(_QWORD *)&buf[30] = v62;
        *(_WORD *)&buf[38] = 1024;
        *(_DWORD *)&buf[40] = v16;
        _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SendUDPPacketForCList: SENDING PACKET FROM %s:%d", buf, 0x2Cu);
      }
    }
    else if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      v40 = *(unsigned __int16 *)(a4 + 36);
      *(_DWORD *)buf = 136316162;
      *(_QWORD *)&buf[4] = v13;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "SendUDPPacketForCList";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 218;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = v62;
      *(_WORD *)&buf[38] = 1024;
      *(_DWORD *)&buf[40] = v40;
      _os_log_debug_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEBUG, "SIP [%s] %s:%d SendUDPPacketForCList: SENDING PACKET FROM %s:%d", buf, 0x2Cu);
    }
  }
  v60 = 0u;
  v61 = 0u;
  v58 = 0u;
  v59 = 0u;
  v57 = 0u;
  memset(buf, 0, sizeof(buf));
  IPToString();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v17 = VRTraceErrorLogLevelToCSTR();
    v18 = *MEMORY[0x1E0CF2758];
    v19 = *MEMORY[0x1E0CF2758];
    if (*v12)
    {
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        v20 = *((unsigned __int16 *)a5 + 18);
        *(_DWORD *)&v51[16] = 136316162;
        *(_QWORD *)&v51[20] = v17;
        *(_WORD *)&v51[28] = 2080;
        *(_QWORD *)&v51[30] = "SendUDPPacketForCList";
        *(_WORD *)&v51[38] = 1024;
        *(_DWORD *)&v51[40] = 222;
        v52 = 2080;
        v53 = buf;
        v54 = 1024;
        v55 = v20;
        _os_log_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SendUDPPacketForCList: SENDING PACKET TO %s:%d", &v51[16], 0x2Cu);
      }
    }
    else if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      v41 = *((unsigned __int16 *)a5 + 18);
      *(_DWORD *)&v51[16] = 136316162;
      *(_QWORD *)&v51[20] = v17;
      *(_WORD *)&v51[28] = 2080;
      *(_QWORD *)&v51[30] = "SendUDPPacketForCList";
      *(_WORD *)&v51[38] = 1024;
      *(_DWORD *)&v51[40] = 222;
      v52 = 2080;
      v53 = buf;
      v54 = 1024;
      v55 = v41;
      _os_log_debug_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_DEBUG, "SIP [%s] %s:%d SendUDPPacketForCList: SENDING PACKET TO %s:%d", &v51[16], 0x2Cu);
    }
  }
  v21 = 2148466710;
  if (!a1)
    return v21;
  v42 = a2;
  v22 = (_QWORD *)MEMORY[0x1E0C83920];
  while (1)
  {
    v23 = *(_DWORD *)(a1 + 2072) & 1;
    if (v23 == (*(_DWORD *)a4 & 1))
    {
      v24 = (_QWORD *)(a1 + 2092);
      if (v23)
      {
        if (*v24 != *(_QWORD *)(a4 + 20) || *(_QWORD *)(a1 + 2100) != *(_QWORD *)(a4 + 28))
        {
LABEL_34:
          if (*(_QWORD *)(a1 + 2092) != *v22 || *(_QWORD *)(a1 + 2100) != v22[1])
            goto LABEL_40;
          goto LABEL_39;
        }
      }
      else
      {
        v25 = *(_DWORD *)v24;
        if (v25 != *(_DWORD *)(a4 + 20))
        {
          if (v25)
            goto LABEL_40;
          goto LABEL_39;
        }
      }
      if (*(unsigned __int16 *)(a1 + 2108) == *(unsigned __int16 *)(a4 + 36))
        break;
    }
    if (v23)
      goto LABEL_34;
    if (*(_DWORD *)(a1 + 2092))
      goto LABEL_40;
LABEL_39:
    if (*(unsigned __int16 *)(a1 + 2108) == *(unsigned __int16 *)(a4 + 36))
      break;
LABEL_40:
    if (a6[40])
      break;
LABEL_46:
    a1 = *(_QWORD *)(a1 + 2144);
    if (!a1)
      return v21;
  }
  memset(v51, 170, sizeof(v51));
  v28 = *a5;
  if (!v23 && (v28 & 1) != 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v29 = VRTraceErrorLogLevelToCSTR();
      v30 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v45 = 136315650;
        v46 = v29;
        v47 = 2080;
        v48 = "SendUDPPacketForCList";
        v49 = 1024;
        v50 = 237;
        _os_log_impl(&dword_1D8A54000, v30, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SendUDPPacketForCList: skip mismatched interface: IPv4", v45, 0x1Cu);
      }
    }
    goto LABEL_46;
  }
  if ((v28 & 1) != 0)
  {
    v44 = 28;
    v31 = IPPORTToSA6();
  }
  else
  {
    v44 = 16;
    v31 = IPPORTToSA();
  }
  v32 = (sockaddr *)v31;
  v33 = *(_DWORD *)(a1 + 2120);
  if (v33 && *(_DWORD *)(a1 + 2116))
  {
    v34 = *a6;
    goto LABEL_55;
  }
  v34 = *a6;
  if ((*a6 | 4) != 6)
  {
    v36 = 0;
    *a6 = 0;
    v35 = 1;
    goto LABEL_58;
  }
LABEL_55:
  v35 = (v34 & 0xFFFFFFFE) != 4;
  v36 = (v34 & 0xFFFFFFFE) == 4;
  if ((v34 | 4) != 6)
LABEL_58:
    a6[1] = v33;
  a6[37] = v36;
  if (v35 || (v37 = *(_QWORD *)(a1 + 2136), v37 == 0xFFFFFFFFLL))
    v38 = VTP_Sendto(*(_DWORD *)a1, v42, a3, 0, (uint64_t)v32, v44, a6);
  else
    v38 = ARPL_Sendto(v37, *(_DWORD *)a1, v42, a3, 0, v32, v44, a6);
  if (v38 == -1)
    return *__error() | 0xC00F0000;
  else
    return 0;
}

uint64_t TPEnsureRecvProcStarted(void *a1, uint64_t a2)
{
  pthread_rwlock_t *v4;
  uint64_t *v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  int v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v4 = (pthread_rwlock_t *)(a2 + 1064);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(a2 + 1064));
  v5 = (uint64_t *)(a2 + 24);
  if (*(_QWORD *)(a2 + 24))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      v6 = VRTraceErrorLogLevelToCSTR();
      v7 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v14 = 136315650;
        v15 = v6;
        v16 = 2080;
        v17 = "TPEnsureRecvProcStarted";
        v18 = 1024;
        v19 = 2589;
        _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TPRecvProc already started", (uint8_t *)&v14, 0x1Cu);
      }
    }
    VTP_Close(*(_DWORD *)(a2 + 12));
    v8 = 0;
    *(_DWORD *)(a2 + 12) = -1;
  }
  else
  {
    v10 = pthread_create((pthread_t *)(a2 + 24), 0, (void *(__cdecl *)(void *))TPRecvProc, a1);
    if (!v10)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
      {
        v11 = VRTraceErrorLogLevelToCSTR();
        v12 = *MEMORY[0x1E0CF2758];
        v8 = 0;
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          goto LABEL_6;
        v13 = *v5;
        v14 = 136315906;
        v15 = v11;
        v16 = 2080;
        v17 = "TPEnsureRecvProcStarted";
        v18 = 1024;
        v19 = 2587;
        v20 = 2048;
        v21 = v13;
        _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TPRecvProc(%p) started", (uint8_t *)&v14, 0x26u);
      }
      v8 = 0;
      goto LABEL_6;
    }
    v8 = v10 | 0xC00F0000;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        TPEnsureRecvProcStarted_cold_1();
    }
  }
LABEL_6:
  pthread_rwlock_unlock(v4);
  return v8;
}

uint64_t TPRecvProc(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  double v6;
  signed int v7;
  double v8;
  unint64_t v9;
  int v10;
  uint64_t i;
  int v12;
  uint64_t j;
  int v14;
  double v15;
  uint64_t v16;
  int v17;
  uint64_t k;
  int v19;
  int v20;
  signed int v21;
  int v22;
  uint64_t m;
  int v24;
  int v25;
  signed int v26;
  int v27;
  int ErrorLogLevelForModule;
  uint64_t v30;
  NSObject *v31;
  unint64_t v32;
  unint64_t v33;
  uint8_t v34[4];
  uint64_t v35;
  __int16 v36;
  const char *v37;
  __int16 v38;
  int v39;
  __int16 v40;
  signed int v41;
  uint8_t buf[32];
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  v32 = 0xAAAAAAAAAAAAAAAALL;
  v33 = 0xAAAAAAAAAAAAAAAALL;
  pthread_setname_np("com.apple.avconference.transport.recvproc");
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = v2;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "TPRecvProc";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 1733;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Transport(UDP) Thread start...", buf, 0x1Cu);
    }
  }
  v4 = CheckInHandleDebug();
  if (!v4)
    return -2146500606;
  v5 = v4;
  v6 = micro();
  v7 = 0;
LABEL_6:
  v8 = v6 + 30.0;
  while (1)
  {
    v47 = 0u;
    v48 = 0u;
    v45 = 0u;
    v46 = 0u;
    v43 = 0u;
    v44 = 0u;
    memset(buf, 0, sizeof(buf));
    pthread_rwlock_rdlock((pthread_rwlock_t *)(v5 + 1064));
    pthread_rwlock_rdlock((pthread_rwlock_t *)(v5 + 1272));
    if (*(_DWORD *)(v5 + 8))
    {
      pthread_rwlock_unlock((pthread_rwlock_t *)(v5 + 1272));
      pthread_rwlock_unlock((pthread_rwlock_t *)(v5 + 1064));
      goto LABEL_64;
    }
    if (*(_DWORD *)(v5 + 12) == -1)
      *(_DWORD *)(v5 + 12) = VTP_Socket(2, 1, 6);
    pthread_rwlock_unlock((pthread_rwlock_t *)(v5 + 1272));
    v9 = *(int *)(v5 + 12);
    if ((_DWORD)v9 == -1)
      break;
    if (__darwin_check_fd_set_overflow(*(_DWORD *)(v5 + 12), buf, 0))
      *(_DWORD *)&buf[(v9 >> 3) & 0x1FFFFFFFFFFFFFFCLL] |= 1 << v9;
    v10 = *(_DWORD *)(v5 + 12);
    for (i = *(_QWORD *)(v5 + 1056); i; i = *(_QWORD *)(i + 2144))
    {
      v12 = *(_DWORD *)i;
      if (__darwin_check_fd_set_overflow(*(_DWORD *)i, buf, 0))
        *(_DWORD *)&buf[((unint64_t)v12 >> 3) & 0x1FFFFFFFFFFFFFFCLL] |= 1 << v12;
      if (*(_DWORD *)i > v10)
        v10 = *(_DWORD *)i;
    }
    pthread_rwlock_unlock((pthread_rwlock_t *)(v5 + 1064));
    pthread_rwlock_rdlock((pthread_rwlock_t *)(v5 + 1272));
    for (j = *(_QWORD *)(v5 + 1264); j; j = *(_QWORD *)(j + 2144))
    {
      v14 = *(_DWORD *)j;
      if (__darwin_check_fd_set_overflow(*(_DWORD *)j, buf, 0))
        *(_DWORD *)&buf[((unint64_t)v14 >> 3) & 0x1FFFFFFFFFFFFFFCLL] |= 1 << v14;
      if (*(_DWORD *)j > v10)
        v10 = *(_DWORD *)j;
    }
    pthread_rwlock_unlock((pthread_rwlock_t *)(v5 + 1272));
    v15 = v8 - micro();
    if (v15 <= 0.0)
    {
LABEL_55:
      v6 = micro();
      SendRelayHB();
      goto LABEL_6;
    }
    v32 = (int)v15;
    LODWORD(v33) = (int)((v15 - (double)(int)v15) * 1000000.0);
    v16 = (v10 + 1);
    v17 = VTP_Select(v16, (__int128 *)buf, 0, 0, (uint64_t)&v32);
    if (v17 == -1)
    {
      if (*__error() != 9)
      {
        v7 = *__error() | 0xC00F0000;
        ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
        if (ErrorLogLevelForModule >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            TPRecvProc_cold_2();
        }
        goto LABEL_64;
      }
    }
    else
    {
      if (!v17)
        goto LABEL_55;
      pthread_rwlock_rdlock((pthread_rwlock_t *)(v5 + 1064));
      for (k = *(_QWORD *)(v5 + 1056); k; k = *(_QWORD *)(k + 2144))
      {
        v19 = *(_DWORD *)k;
        if (__darwin_check_fd_set_overflow(*(_DWORD *)k, buf, 0))
        {
          if (((*(_DWORD *)&buf[((unint64_t)v19 >> 3) & 0x1FFFFFFFFFFFFFFCLL] >> v19) & 1) != 0)
          {
            v32 = 0;
            LODWORD(v33) = 0;
            v20 = *(_DWORD *)k;
            if (__darwin_check_fd_set_overflow(*(_DWORD *)k, buf, 0))
            {
              if (((*(_DWORD *)&buf[((unint64_t)v20 >> 3) & 0x1FFFFFFFFFFFFFFCLL] >> v20) & 1) != 0)
              {
                while (1)
                {
                  v21 = RecvMessageUDP(a1, v5, k);
                  if (v21 < 0)
                    break;
                  if ((int)VTP_Select(v16, (__int128 *)buf, 0, 0, (uint64_t)&v32) > 0)
                  {
                    v22 = *(_DWORD *)k;
                    if (__darwin_check_fd_set_overflow(*(_DWORD *)k, buf, 0))
                    {
                      if (((*(_DWORD *)&buf[((unint64_t)v22 >> 3) & 0x1FFFFFFFFFFFFFFCLL] >> v22) & 1) != 0)
                        continue;
                    }
                  }
                  v7 = 0;
                  goto LABEL_41;
                }
                v7 = v21;
              }
            }
          }
        }
LABEL_41:
        ;
      }
      pthread_rwlock_unlock((pthread_rwlock_t *)(v5 + 1064));
      pthread_rwlock_rdlock((pthread_rwlock_t *)(v5 + 1272));
      for (m = *(_QWORD *)(v5 + 1264); m; m = *(_QWORD *)(m + 2144))
      {
        v24 = *(_DWORD *)m;
        if (__darwin_check_fd_set_overflow(*(_DWORD *)m, buf, 0))
        {
          if (((*(_DWORD *)&buf[((unint64_t)v24 >> 3) & 0x1FFFFFFFFFFFFFFCLL] >> v24) & 1) != 0)
          {
            v32 = 0;
            LODWORD(v33) = 0;
            v25 = *(_DWORD *)m;
            if (__darwin_check_fd_set_overflow(*(_DWORD *)m, buf, 0))
            {
              if (((*(_DWORD *)&buf[((unint64_t)v25 >> 3) & 0x1FFFFFFFFFFFFFFCLL] >> v25) & 1) != 0)
              {
                while (1)
                {
                  v26 = RecvMessageUDP(a1, v5, m);
                  if (v26 < 0)
                    break;
                  if ((int)VTP_Select(v16, (__int128 *)buf, 0, 0, (uint64_t)&v32) > 0)
                  {
                    v27 = *(_DWORD *)m;
                    if (__darwin_check_fd_set_overflow(*(_DWORD *)m, buf, 0))
                    {
                      if (((*(_DWORD *)&buf[((unint64_t)v27 >> 3) & 0x1FFFFFFFFFFFFFFCLL] >> v27) & 1) != 0)
                        continue;
                    }
                  }
                  v7 = 0;
                  goto LABEL_53;
                }
                v7 = v26;
              }
            }
          }
        }
LABEL_53:
        ;
      }
      pthread_rwlock_unlock((pthread_rwlock_t *)(v5 + 1272));
    }
  }
  pthread_rwlock_unlock((pthread_rwlock_t *)(v5 + 1064));
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      TPRecvProc_cold_1();
  }
LABEL_64:
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v30 = VRTraceErrorLogLevelToCSTR();
    v31 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v34 = 136315906;
      v35 = v30;
      v36 = 2080;
      v37 = "TPRecvProc";
      v38 = 1024;
      v39 = 1880;
      v40 = 1024;
      v41 = v7;
      _os_log_impl(&dword_1D8A54000, v31, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Transport(UDP) Thread end(%08X)...", v34, 0x22u);
    }
  }
  CheckOutHandleDebug();
  return v7;
}

void SendRelayHB()
{
  uint64_t i;
  void *v1;
  int v2;
  int v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v2 = -1431655766;
  v3 = -1431655766;
  v1 = 0;
  DLFindActiveDialogs(&v3, &v1);
  if (v3 < 1)
  {
    ICERefreshAllRelayBinding();
  }
  else
  {
    for (i = 0; i < v3; ++i)
    {
      DLGetCallID(*((_QWORD *)v1 + i), &v2);
      ICERefreshRelayBinding();
    }
    if (v1)
      free(v1);
  }
}

uint64_t RecvMessageUDP(uint64_t a1, uint64_t a2, uint64_t a3)
{
  char *v6;
  size_t v7;
  _DWORD *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  int v13;
  char v14;
  uint64_t v15;
  NSObject *v16;
  int v17;
  const char *v18;
  NSObject *v19;
  uint32_t v20;
  char *v21;
  uint64_t v22;
  NSObject *v23;
  int v24;
  uint64_t v25;
  int v26;
  int v27;
  __int128 v28;
  int v29;
  uint64_t *v30;
  _QWORD *v31;
  __int128 v32;
  uint64_t v33;
  NSObject *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  _QWORD *v39;
  char *v40;
  int v41;
  uint64_t v42;
  double v43;
  uint64_t v44;
  _QWORD *v45;
  _QWORD *v47;
  uint64_t v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  pthread_mutex_t *v54;
  uint64_t v55;
  NSObject *v56;
  NSObject *v57;
  _QWORD *v58;
  pthread_mutex_t *v59;
  void (*v60)(uint64_t, _DWORD *, size_t, _QWORD, _QWORD, _QWORD);
  void (*v61)(uint64_t);
  uint64_t v62;
  void (*v63)(uint64_t);
  void *v64;
  NSObject *global_queue;
  uint64_t v66;
  NSObject *v67;
  uint64_t v68;
  NSObject *v69;
  _OWORD *v71;
  _OWORD *v72;
  uint64_t v73;
  __int128 v74;
  char *v75;
  __int128 v76;
  __int128 v77;
  uint64_t v78;
  _QWORD *v79;
  _QWORD *v80;
  uint64_t v81;
  uint64_t v82;
  void *v83;
  char *v84;
  NSObject *v85;
  uint64_t v86;
  NSObject *v87;
  _QWORD v88[9];
  int v89;
  char *v90;
  _QWORD block[7];
  _BYTE v92[320];
  char *v93;
  int v94;
  uint8_t v95[4];
  uint64_t v96;
  __int16 v97;
  const char *v98;
  __int16 v99;
  int v100;
  __int16 v101;
  uint64_t v102;
  __int16 v103;
  uint64_t v104;
  uint8_t buf[352];
  __int128 v106;
  _BYTE v107[40];
  uint64_t v108;
  uint64_t v109;
  uint64_t *v110;
  uint64_t v111;
  __int128 v112;
  __int128 v113;
  unint64_t v114;
  char __b[2049];
  uint64_t v116;

  v116 = *MEMORY[0x1E0C80C00];
  v90 = 0;
  memset(__b, 170, sizeof(__b));
  if (*(_DWORD *)(a3 + 2120) && *(_DWORD *)(a3 + 2116) && *(_QWORD *)(a3 + 2136) != 0xFFFFFFFFLL
    || (VTP_Recvfrom(*(_DWORD *)a3, &v90) & 0x80000000) != 0)
  {
    v10 = *__error() | 0xC00F0000;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v11 = VRTraceErrorLogLevelToCSTR();
      v12 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v13 = *(_DWORD *)a3;
        *(_DWORD *)buf = 136316418;
        *(_QWORD *)&buf[4] = v11;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "RecvMessageUDP";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 1473;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = 1473;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = v13;
        *(_WORD *)&buf[40] = 1024;
        *(_DWORD *)&buf[42] = v10;
        _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/Transport.c:%d: recvfrom(%d) failed(%08X)", buf, 0x2Eu);
      }
    }
    return v10;
  }
  v6 = v90;
  if (*((_QWORD *)v90 + 64) >= 0x800uLL)
    v7 = 2048;
  else
    v7 = *((_QWORD *)v90 + 64);
  v8 = (_DWORD *)(a3 + 12);
  memcpy((void *)(a3 + 12), *((const void **)v90 + 65), v7);
  if (!(_DWORD)v7)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 5)
      return 0;
    v15 = VRTraceErrorLogLevelToCSTR();
    v16 = *MEMORY[0x1E0CF2758];
    v10 = 0;
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      return v10;
    v17 = *(_DWORD *)a3;
    *(_DWORD *)buf = 136316162;
    *(_QWORD *)&buf[4] = v15;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = "RecvMessageUDP";
    *(_WORD *)&buf[22] = 1024;
    *(_DWORD *)&buf[24] = 1469;
    *(_WORD *)&buf[28] = 1024;
    *(_DWORD *)&buf[30] = 1469;
    *(_WORD *)&buf[34] = 1024;
    *(_DWORD *)&buf[36] = v17;
    v18 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/Transport.c"
          ":%d: recvfrom(%d) returned 0: empty message";
LABEL_22:
    v19 = v16;
    v20 = 40;
LABEL_23:
    _os_log_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_DEFAULT, v18, buf, v20);
    return 0;
  }
  *((_WORD *)v6 + 88) = *(_WORD *)(a3 + 2108);
  *((_DWORD *)v6 + 35) |= *(_DWORD *)(a3 + 2072);
  if (*(_DWORD *)(a3 + 2120) && *(_DWORD *)(a3 + 2116))
  {
    v9 = *((_DWORD *)v6 + 46);
    goto LABEL_16;
  }
  v9 = *((_DWORD *)v6 + 46);
  if ((v9 | 4) == 6)
  {
LABEL_16:
    v14 = 1;
    switch(v9)
    {
      case 0:
        goto LABEL_25;
      case 1:
      case 2:
      case 6:
        goto LABEL_42;
      case 3:
        if (DTLS_IsConnected())
          return 0;
        goto LABEL_42;
      case 4:
        if (!v6[196] || !DTLS_IsConnected())
          return 0;
        goto LABEL_42;
      case 5:
        if (!v6[196])
          goto LABEL_96;
        if (DTLS_IsConnected())
          goto LABEL_42;
        if (!v90[196])
        {
LABEL_96:
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v66 = VRTraceErrorLogLevelToCSTR();
            v67 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315650;
              *(_QWORD *)&buf[4] = v66;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "RecvMessageUDP";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 1536;
              _os_log_impl(&dword_1D8A54000, v67, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d >>>> SKIPPING INCOMING ARPL PACKET! <!bEncrypted>  (in Transport) <<<<<", buf, 0x1Cu);
            }
          }
        }
        if (DTLS_IsConnected() || (int)VRTraceGetErrorLogLevelForModule() < 7)
          return 0;
        v68 = VRTraceErrorLogLevelToCSTR();
        v69 = *MEMORY[0x1E0CF2758];
        v10 = 0;
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          return v10;
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = v68;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "RecvMessageUDP";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 1539;
        v18 = "SIP [%s] %s:%d >>>> SKIPPING INCOMING ARPL PACKET! <!DTLS_IsConnected(pCList->hDTLS)>  (in Transport) <<<<<";
        v19 = v69;
        v20 = 28;
        break;
      default:
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v22 = VRTraceErrorLogLevelToCSTR();
          v23 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v24 = *((_DWORD *)v90 + 47);
            *(_DWORD *)buf = 136315906;
            *(_QWORD *)&buf[4] = v22;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "RecvMessageUDP";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 1553;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = v24;
            _os_log_impl(&dword_1D8A54000, v23, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d RecvMessageUDP: ignore unrecognized OFT packet for callID %08X", buf, 0x22u);
          }
        }
        if ((int)VRTraceGetErrorLogLevelForModule() < 7)
          return 0;
        v25 = VRTraceErrorLogLevelToCSTR();
        v16 = *MEMORY[0x1E0CF2758];
        v10 = 0;
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          return v10;
        v26 = *(_DWORD *)(a3 + 2064);
        v27 = *(_DWORD *)(a3 + 2120);
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)&buf[4] = v25;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "RecvMessageUDP";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 1554;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v26;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = v27;
        v18 = "SIP [%s] %s:%d RecvMessageUDP: localCallID == %08X remoteCallID == %08X";
        goto LABEL_22;
    }
    goto LABEL_23;
  }
  *((_DWORD *)v6 + 46) = 0;
LABEL_25:
  __strncpy_chk();
  __b[v7] = 0;
  v21 = strchr(__b, 10);
  if (v21)
    *v21 = 0;
  if (strnstr(__b, "SIP/", v7))
  {
    v10 = 0;
    if (*(_QWORD *)(a3 + 2128) != 0xFFFFFFFFLL)
      return v10;
    v14 = 0;
  }
  else
  {
    v14 = 1;
  }
LABEL_42:
  if ((*((_DWORD *)v90 + 46) | 4) == 4)
    *(_BYTE *)(a3 + v7 + 12) = 0;
  v109 = 0;
  v110 = &v109;
  v111 = 0x4000000000;
  *(_QWORD *)&v28 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v28 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v112 = v28;
  v113 = v28;
  v114 = 0xAAAAAAAAAAAAAAAALL;
  SAToIPPORT();
  if ((v14 & 1) == 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v55 = VRTraceErrorLogLevelToCSTR();
      v56 = *MEMORY[0x1E0CF2758];
      v57 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = v55;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "RecvMessageUDP";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 1567;
          _os_log_impl(&dword_1D8A54000, v56, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d RecvMessageUDP: pass message SIP", buf, 0x1Cu);
        }
      }
      else if (os_log_type_enabled(v57, OS_LOG_TYPE_DEBUG))
      {
        RecvMessageUDP_cold_2();
      }
    }
    *(_QWORD *)&v106 = 0;
    *((_QWORD *)&v106 + 1) = &v106;
    *(_QWORD *)v107 = 0x4000000000;
    *(_OWORD *)&v107[8] = *(_OWORD *)(v90 + 140);
    *(_OWORD *)&v107[24] = *(_OWORD *)(v90 + 156);
    v108 = *(_QWORD *)(v90 + 172);
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x15800000000;
    memcpy(&buf[24], v90 + 184, 0x140uLL);
    v64 = malloc_type_malloc(v7 + 1, 0x2449DABBuLL);
    memcpy(v64, v8, v7 + 1);
    *((_BYTE *)v64 + v7) = 0;
    global_queue = dispatch_get_global_queue(2, 0);
    v88[0] = MEMORY[0x1E0C809B0];
    v88[1] = 0x40000000;
    v88[2] = __RecvMessageUDP_block_invoke;
    v88[3] = &unk_1E9E558A0;
    v88[7] = a1;
    v88[8] = v64;
    v89 = v7;
    v88[4] = buf;
    v88[5] = &v106;
    v88[6] = &v109;
    dispatch_async(global_queue, v88);
    _Block_object_dispose(buf, 8);
    _Block_object_dispose(&v106, 8);
    goto LABEL_93;
  }
  v29 = *((_DWORD *)v90 + 46);
  if ((_DWORD)v7 != 16 || v29 || *v8 != 0x1000000)
  {
    v58 = (_QWORD *)(a2 + 34544);
    switch(v29)
    {
      case 2:
      case 6:
        v59 = (pthread_mutex_t *)(a2 + 34584);
        pthread_mutex_lock((pthread_mutex_t *)(a2 + 34584));
        v60 = *(void (**)(uint64_t, _DWORD *, size_t, _QWORD, _QWORD, _QWORD))(a2 + 34552);
        if (!v60)
        {
          v54 = (pthread_mutex_t *)(a2 + 34584);
          goto LABEL_77;
        }
        v62 = *(_QWORD *)(a2 + 34560);
        v61 = (void (*)(uint64_t))v58[3];
        v63 = (void (*)(uint64_t))v58[4];
        if (v61 && v62)
          v61(v62);
        pthread_mutex_unlock(v59);
        v60(v62, v8, v7, *((unsigned int *)v90 + 47), v90[196], *((unsigned int *)v90 + 46));
        if (v63 && v62)
          v63(v62);
        goto LABEL_93;
      case 4:
        v83 = malloc_type_malloc(v7 + 1, 0x6C26E4FBuLL);
        memcpy(v83, v8, v7 + 1);
        v84 = v90;
        memcpy(buf, v90 + 184, 0x140uLL);
        v85 = dispatch_get_global_queue(2, 0);
        block[0] = MEMORY[0x1E0C809B0];
        block[1] = 0x40000000;
        block[2] = __RecvMessageUDP_block_invoke_11;
        block[3] = &unk_1E9E558C8;
        block[5] = a1;
        block[6] = v83;
        v94 = v7;
        memcpy(v92, buf, sizeof(v92));
        v93 = v84;
        block[4] = &v109;
        dispatch_async(v85, block);
        goto LABEL_93;
      case 5:
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v86 = VRTraceErrorLogLevelToCSTR();
          v87 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136316162;
            *(_QWORD *)&buf[4] = v86;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "RecvMessageUDP";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 1629;
            *(_WORD *)&buf[28] = 2080;
            *(_QWORD *)&buf[30] = v8;
            *(_WORD *)&buf[38] = 1024;
            *(_DWORD *)&buf[40] = v7;
            _os_log_impl(&dword_1D8A54000, v87, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d >>>>> Received incoming ARPL data with szMessage=[%s] and length=[%d] <NEED TO DO SOMETHING HERE> (in Transport) <<<<<", buf, 0x2Cu);
          }
        }
        (*(void (**)(void))(*v58 + 16))();
        goto LABEL_93;
      default:
        v71 = malloc_type_calloc(1uLL, 0x868uLL, 0x1020040D8EC2E6EuLL);
        if (v71)
        {
          v72 = v71;
          __memcpy_chk();
          v73 = v110[7];
          v74 = *(_OWORD *)(v110 + 5);
          v72[131] = *(_OWORD *)(v110 + 3);
          v72[132] = v74;
          *((_QWORD *)v72 + 266) = v73;
          *((_DWORD *)v72 + 513) = v7;
          v75 = v90;
          v76 = *(_OWORD *)(v90 + 156);
          v77 = *(_OWORD *)(v90 + 140);
          *((_QWORD *)v72 + 261) = *(_QWORD *)(v90 + 172);
          *(_OWORD *)((char *)v72 + 2056) = v77;
          *(_OWORD *)((char *)v72 + 2072) = v76;
          *((_QWORD *)v72 + 267) = *(_QWORD *)v75;
          pthread_mutex_lock((pthread_mutex_t *)(a2 + 1544 + ((uint64_t)*((int *)v75 + 46) << 7) + 16));
          v78 = *((int *)v90 + 46);
          v79 = (_QWORD *)(a2 + 1544 + (v78 << 7) + 8);
          do
          {
            v80 = v79;
            v81 = *v79;
            v79 = (_QWORD *)(*v79 + 2144);
          }
          while (v81);
          *v80 = v72;
          v82 = a2 + 1544;
          pthread_cond_signal((pthread_cond_t *)(v82 + (v78 << 7) + 80));
          v54 = (pthread_mutex_t *)(v82 + ((uint64_t)*((int *)v90 + 46) << 7) + 16);
          goto LABEL_77;
        }
        v10 = 2148466691;
        VTP_ReleasePacket((void **)&v90);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            RecvMessageUDP_cold_1();
        }
        break;
    }
    goto LABEL_94;
  }
  v30 = v110;
  v31 = v110 + 3;
  *(_QWORD *)&buf[46] = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v32 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v32 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&buf[16] = v32;
  *(_OWORD *)&buf[32] = v32;
  *(_OWORD *)buf = v32;
  *(_QWORD *)&v107[30] = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)v107 = v32;
  *(_OWORD *)&v107[16] = v32;
  v106 = v32;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v33 = VRTraceErrorLogLevelToCSTR();
    v34 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v35 = IPPORTToStringWithSize();
      v36 = IPPORTToStringWithSize();
      *(_DWORD *)v95 = 136316162;
      v96 = v33;
      v97 = 2080;
      v98 = "RecvMessageUDP";
      v99 = 1024;
      v100 = 1593;
      v101 = 2080;
      v102 = v35;
      v103 = 2080;
      v104 = v36;
      _os_log_impl(&dword_1D8A54000, v34, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Updating heartbeat from %s to %s", v95, 0x30u);
    }
  }
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 992));
  v37 = 0;
  v38 = 0;
  v39 = v90;
  v40 = v90 + 140;
  v41 = *((_DWORD *)v90 + 35) & 1;
  v42 = -960;
  v43 = 1.0e10;
  while (1)
  {
    v44 = a2 + v42;
    if ((*(_DWORD *)(a2 + v42 + 1000) & 1) != v41)
      goto LABEL_72;
    v45 = (_QWORD *)(v44 + 1020);
    if (v41)
    {
      if (*v45 != *((_QWORD *)v90 + 20) || *(_QWORD *)(v44 + 1028) != *((_QWORD *)v90 + 21))
        goto LABEL_72;
    }
    else if (*(_DWORD *)v45 != *((_DWORD *)v90 + 40))
    {
      goto LABEL_72;
    }
    if (*(unsigned __int16 *)(a2 + v42 + 1036) != *((unsigned __int16 *)v90 + 88)
      || (*(_DWORD *)(a2 + v42 + 1040) & 1) != (*(_DWORD *)v31 & 1))
    {
      goto LABEL_72;
    }
    v47 = (_QWORD *)(a2 + v42 + 1060);
    if ((*(_DWORD *)(a2 + v42 + 1040) & 1) == 0)
      break;
    if (*v47 == *(uint64_t *)((char *)v30 + 44) && *(_QWORD *)(a2 + v42 + 1068) == *(uint64_t *)((char *)v30 + 52))
      goto LABEL_71;
LABEL_72:
    if (*(double *)(v44 + 1080) < v43)
    {
      v38 = v37;
      v43 = *(double *)(v44 + 1080);
    }
    ++v37;
    v42 += 96;
    if (!v42)
    {
      v37 = v38;
      v49 = a2 + 96 * v38;
      *(_DWORD *)(v49 + 32) = 0;
      v50 = *(_OWORD *)v40;
      v51 = *((_OWORD *)v40 + 1);
      *(_QWORD *)(v49 + 72) = *((_QWORD *)v40 + 4);
      *(_OWORD *)(v49 + 56) = v51;
      *(_OWORD *)(v49 + 40) = v50;
      v52 = *(_OWORD *)v31;
      v53 = *((_OWORD *)v31 + 1);
      *(_QWORD *)(v49 + 112) = v31[4];
      *(_OWORD *)(v49 + 80) = v52;
      *(_OWORD *)(v49 + 96) = v53;
      goto LABEL_76;
    }
  }
  if (*(_DWORD *)v47 != *((_DWORD *)v30 + 11))
    goto LABEL_72;
LABEL_71:
  if (*(_DWORD *)(a2 + v42 + 996))
    goto LABEL_72;
  *(_WORD *)(a2 + v42 + 1076) = *((_WORD *)v30 + 30);
LABEL_76:
  *(_QWORD *)(a2 + 96 * v37 + 120) = *v39;
  v54 = (pthread_mutex_t *)(a2 + 992);
LABEL_77:
  pthread_mutex_unlock(v54);
LABEL_93:
  VTP_ReleasePacket((void **)&v90);
  v10 = 0;
LABEL_94:
  _Block_object_dispose(&v109, 8);
  return v10;
}

void PassMessage(uint64_t a1)
{
  __int128 *v1;
  __int128 *v2;
  __int128 *v3;
  __int128 *v4;
  __int128 *v5;
  __int128 *v6;
  int v7;
  int v8;
  char *v9;
  char *v10;
  __int128 v11;
  char *v12;
  uint8_t *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  int v19;
  uint64_t v20;
  NSObject *v21;
  const char *v22;
  NSObject *v23;
  uint32_t v24;
  uint64_t v25;
  NSObject *v26;
  _OWORD *v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  NSObject *v35;
  char *v36;
  int *v37;
  int v38;
  int v39;
  uint64_t v40;
  NSObject *v41;
  int v42;
  const char *v43;
  NSObject *v44;
  uint32_t v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  uint64_t v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  _OWORD *v58;
  _OWORD *v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  _OWORD *v64;
  __int128 v65;
  __int128 v66;
  uint64_t v67;
  uint64_t v68;
  NSObject *v69;
  uint64_t v70;
  int v71;
  int v72;
  _OWORD *v73;
  _OWORD *v74;
  __int128 v75;
  unsigned int *v76;
  uint64_t v77;
  const char *v78;
  uint64_t (*v79)(_QWORD, uint8_t *, int *, uint8_t *, _QWORD, unsigned int *);
  int v80;
  int v81;
  int ErrorLogLevelForModule;
  uint64_t v83;
  NSObject *v84;
  int v85;
  const char *v86;
  NSObject *v87;
  uint32_t v88;
  uint64_t v89;
  NSObject *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  NSObject *v94;
  int v95;
  int v96;
  uint64_t v97;
  int v98;
  uint64_t v99;
  NSObject *v100;
  uint64_t v101;
  NSObject *v102;
  int v103;
  uint64_t v104;
  uint8_t *v105;
  void *v106;
  int *v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  pthread_mutex_t *v112;
  int v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  int v117;
  int v118;
  uint64_t v119;
  void *v120;
  uint8_t buf[5408];
  int v122;
  uint64_t v123;
  __int16 v124;
  const char *v125;
  __int16 v126;
  int v127;
  __int16 v128;
  uint64_t v129;
  __int16 v130;
  int v131;
  __int16 v132;
  int v133;
  _BYTE v134[54];
  __int128 v135;
  __int128 v136;
  _OWORD v137[2];
  char __s2[16];
  __int128 v139;
  __int128 v140;
  uint64_t v141;

  MEMORY[0x1E0C80A78](a1);
  v2 = v1;
  v4 = v3;
  v6 = v5;
  v8 = v7;
  v10 = v9;
  v141 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v11 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v139 = v11;
  v140 = v11;
  *(_OWORD *)__s2 = v11;
  *(_QWORD *)((char *)v137 + 14) = 0xAAAAAAAAAAAAAAAALL;
  v136 = v11;
  v137[0] = v11;
  v135 = v11;
  v120 = (void *)0xAAAAAAAAAAAAAAAALL;
  v12 = strstr(v9, "\r\n\r\n");
  if (v12)
  {
    v12[2] = 0;
    v13 = (uint8_t *)(v12 + 4);
    v14 = (_DWORD)v10 - ((_DWORD)v12 + 4) + v8;
  }
  else
  {
    v14 = 0;
    v13 = (uint8_t *)&v10[strlen(v10)];
  }
  v15 = (v8 + 1);
  ReplaceKeyword(v10, v15, "\r\n ", "", 1);
  ReplaceKeyword(v10, v15, "\r\n\t", "", 1);
  if (v14 >= 1)
  {
    v16 = 0;
    v17 = MEMORY[0x1E0C80978];
    while (1)
    {
      v18 = (char)v13[v16];
      if ((v18 & 0x80000000) != 0)
      {
        if (!__maskrune((char)v13[v16], 0x40000uLL) && !__maskrune(v18, 0x4000uLL))
          goto LABEL_15;
      }
      else
      {
        v19 = *(_DWORD *)(v17 + 4 * v18 + 60);
        if ((v19 & 0x40000) == 0 && (v19 & 0x4000) == 0)
          goto LABEL_15;
      }
      if (v14 == ++v16)
        goto LABEL_16;
    }
  }
  LODWORD(v16) = 0;
LABEL_15:
  if ((_DWORD)v16 == v14)
  {
LABEL_16:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v20 = VRTraceErrorLogLevelToCSTR();
      v21 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136316418;
        *(_QWORD *)&buf[4] = v20;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "PassMessage";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 1192;
        *(_WORD *)&buf[28] = 2080;
        *(_QWORD *)&buf[30] = v10;
        *(_WORD *)&buf[38] = 2080;
        *(_QWORD *)&buf[40] = v13;
        *(_WORD *)&buf[48] = 2080;
        *(_QWORD *)&buf[50] = IPPORTToStringWithSize();
        v22 = "SIP [%s] %s:%d [[%s\n%s]] from %s";
        v23 = v21;
        v24 = 58;
LABEL_22:
        _os_log_impl(&dword_1D8A54000, v23, OS_LOG_TYPE_DEFAULT, v22, buf, v24);
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v25 = VRTraceErrorLogLevelToCSTR();
    v26 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136316162;
      *(_QWORD *)&buf[4] = v25;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "PassMessage";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 1195;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = v10;
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = IPPORTToStringWithSize();
      v22 = "SIP [%s] %s:%d [[%s\n<binary>]] from %s";
      v23 = v26;
      v24 = 48;
      goto LABEL_22;
    }
  }
  if ((ParseMessage(&v120, v10) & 0x80000000) == 0)
  {
    v27 = v120;
    if (*((_DWORD *)v120 + 1) == 1 && *((_DWORD *)v120 + 2) == 1 && !*((_QWORD *)v120 + 28))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 5)
        goto LABEL_74;
      v91 = VRTraceErrorLogLevelToCSTR();
      v90 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        goto LABEL_74;
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = v91;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "PassMessage";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 1207;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 1207;
      v43 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/Transport"
            ".c:%d: INVITE doesn't have Contact header.";
    }
    else
    {
      *((_DWORD *)v120 + 140) = v14;
      if (v6)
      {
        v28 = *v6;
        v29 = v6[1];
        v30 = v6[3];
        v27[38] = v6[2];
        v27[39] = v30;
        v27[36] = v28;
        v27[37] = v29;
        v31 = v6[4];
        v32 = v6[5];
        v33 = v6[6];
        *((_QWORD *)v27 + 86) = *((_QWORD *)v6 + 14);
        v27[41] = v32;
        v27[42] = v33;
        v27[40] = v31;
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v34 = VRTraceErrorLogLevelToCSTR();
        v35 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = v34;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "PassMessage";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 1219;
          _os_log_impl(&dword_1D8A54000, v35, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d doesn't have valid source destination info", buf, 0x1Cu);
        }
      }
      v36 = (char *)v120;
      v37 = (int *)*((_QWORD *)v120 + 32);
      if (v37)
      {
        v38 = *v37;
        if (*v37 < 0)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() < 5)
            goto LABEL_74;
          v40 = VRTraceErrorLogLevelToCSTR();
          v41 = *MEMORY[0x1E0CF2758];
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            goto LABEL_74;
          v42 = *v37;
          *(_DWORD *)buf = 136316162;
          *(_QWORD *)&buf[4] = v40;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "PassMessage";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 1232;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = 1232;
          *(_WORD *)&buf[34] = 1024;
          *(_DWORD *)&buf[36] = v42;
          v43 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/Trans"
                "port.c:%d: CONTENT-LENGTH less than 0 (%d).";
          v44 = v41;
          v45 = 40;
          goto LABEL_73;
        }
        if (*((_QWORD *)v120 + 66) || *((_QWORD *)v120 + 30))
        {
          v39 = *((_DWORD *)v120 + 140);
          if (v38 <= v39)
          {
            *((_DWORD *)v120 + 140) = v38;
          }
          else
          {
            if (v38 - v39 > 15)
            {
              if ((int)VRTraceGetErrorLogLevelForModule() < 5)
                goto LABEL_74;
              v93 = VRTraceErrorLogLevelToCSTR();
              v94 = *MEMORY[0x1E0CF2758];
              if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                goto LABEL_74;
              v95 = *v37;
              v96 = *((_DWORD *)v120 + 140);
              *(_DWORD *)buf = 136316418;
              *(_QWORD *)&buf[4] = v93;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "PassMessage";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 1254;
              *(_WORD *)&buf[28] = 1024;
              *(_DWORD *)&buf[30] = 1254;
              *(_WORD *)&buf[34] = 1024;
              *(_DWORD *)&buf[36] = v95;
              *(_WORD *)&buf[40] = 1024;
              *(_DWORD *)&buf[42] = v96;
              v43 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/T"
                    "ransport.c:%d: CONTENT-LENGTH incorrect (%d/%d).";
              v44 = v94;
              v45 = 46;
              goto LABEL_73;
            }
            *v37 = v39;
          }
        }
      }
      *(_DWORD *)v36 = 3;
      if (*((_DWORD *)v36 + 1) == 1 && *((_DWORD *)v36 + 2) == 1)
      {
        v46 = *v4;
        v47 = v4[1];
        *((_QWORD *)v36 + 91) = *((_QWORD *)v4 + 4);
        *(_OWORD *)(v36 + 696) = v46;
        *(_OWORD *)(v36 + 712) = v47;
        v48 = *v2;
        v49 = v2[1];
        *((_QWORD *)v36 + 96) = *((_QWORD *)v2 + 4);
        *((_OWORD *)v36 + 46) = v48;
        *((_OWORD *)v36 + 47) = v49;
        v50 = *v2;
        v51 = v2[1];
        *((_QWORD *)v36 + 106) = *((_QWORD *)v2 + 4);
        *((_OWORD *)v36 + 51) = v50;
        *((_OWORD *)v36 + 52) = v51;
      }
      else
      {
        v119 = 0xAAAAAAAAAAAAAAAALL;
        memset(buf, 170, 0x388uLL);
        v52 = *((_QWORD *)v4 + 4);
        v53 = v4[1];
        *(_OWORD *)(v36 + 696) = *v4;
        *(_OWORD *)(v36 + 712) = v53;
        *((_QWORD *)v36 + 91) = v52;
        v55 = *v2;
        v54 = v2[1];
        *((_QWORD *)v36 + 96) = *((_QWORD *)v2 + 4);
        *((_OWORD *)v36 + 46) = v55;
        *((_OWORD *)v36 + 47) = v54;
        v57 = *v2;
        v56 = v2[1];
        *((_QWORD *)v36 + 106) = *((_QWORD *)v2 + 4);
        *((_OWORD *)v36 + 51) = v57;
        *((_OWORD *)v36 + 52) = v56;
        if ((DLFindWithSipMsgAndLock(&v119, (uint64_t)v36) & 0x80000000) != 0)
        {
          v73 = (char *)v120 + 776;
          v74 = (char *)v120 + 696;
          *((_QWORD *)v120 + 101) = *((_QWORD *)v120 + 91);
          v75 = v74[1];
          *v73 = *v74;
          v73[1] = v75;
        }
        else
        {
          DLGetData(v119, (uint64_t)buf);
          DLUnlock();
          v58 = v120;
          v59 = (char *)v120 + 696;
          *((_QWORD *)v120 + 91) = *(_QWORD *)&buf[60];
          v60 = *(_OWORD *)&buf[44];
          *v59 = *(_OWORD *)&buf[28];
          v59[1] = v60;
          v61 = *(_OWORD *)&buf[84];
          v58[46] = *(_OWORD *)&buf[68];
          v58[47] = v61;
          *((_QWORD *)v58 + 96) = *(_QWORD *)&buf[100];
          *((_QWORD *)v58 + 101) = *(_QWORD *)&buf[140];
          v62 = *(_OWORD *)&buf[124];
          *(_OWORD *)((char *)v58 + 776) = *(_OWORD *)&buf[108];
          *(_OWORD *)((char *)v58 + 792) = v62;
          if (IsIPPORTValid())
          {
            *(_QWORD *)&v134[46] = 0xAAAAAAAAAAAAAAAALL;
            *(_QWORD *)&v63 = 0xAAAAAAAAAAAAAAAALL;
            *((_QWORD *)&v63 + 1) = 0xAAAAAAAAAAAAAAAALL;
            *(_OWORD *)&v134[32] = v63;
            *(_OWORD *)&v134[16] = v63;
            *(_OWORD *)v134 = v63;
            v64 = v120;
            v65 = *(_OWORD *)&buf[188];
            v66 = *(_OWORD *)&buf[204];
            *((_OWORD *)v120 + 51) = *(_OWORD *)&buf[188];
            v64[52] = v66;
            v67 = *(_QWORD *)&buf[220];
            *((_QWORD *)v64 + 106) = *(_QWORD *)&buf[220];
            *(_OWORD *)((char *)v64 + 856) = v65;
            *(_OWORD *)((char *)v64 + 872) = v66;
            *((_QWORD *)v64 + 111) = v67;
            *((_DWORD *)v64 + 142) = *(_DWORD *)&buf[24];
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v68 = VRTraceErrorLogLevelToCSTR();
              v69 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                v70 = IPPORTToStringWithSize();
                v71 = *((unsigned __int16 *)v120 + 284);
                v72 = *((unsigned __int16 *)v120 + 285);
                v122 = 136316418;
                v123 = v68;
                v124 = 2080;
                v125 = "PassMessage";
                v126 = 1024;
                v127 = 1295;
                v128 = 2080;
                v129 = v70;
                v130 = 1024;
                v131 = v71;
                v132 = 1024;
                v133 = v72;
                _os_log_impl(&dword_1D8A54000, v69, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Use relay external addr [%s], relay %u, channel %x", (uint8_t *)&v122, 0x32u);
              }
            }
          }
        }
      }
      IPToString();
      v76 = (unsigned int *)v120;
      v77 = *((_QWORD *)v120 + 63);
      if (v77 && *(int *)v77 > 0)
      {
        if (!*(_BYTE *)(v77 + 118) && strcmp((const char *)(v77 + 12), __s2))
        {
          IPToString();
          v76 = (unsigned int *)v120;
        }
        if (*((_QWORD *)v76 + 34))
        {
          if ((int)v76[140] < 1)
          {
LABEL_106:
            v108 = CheckInHandleDebug();
            if (v108)
            {
              v109 = v108;
              v110 = v108 + 34312;
              if (!*((_QWORD *)v76 + 63) || (v111 = *((_QWORD *)v76 + 34)) == 0)
              {
                if (((*(uint64_t (**)(_QWORD, unsigned int *))v110)(*(_QWORD *)(v108 + 34320), v76) & 0x80000000) != 0
                  && (int)VRTraceGetErrorLogLevelForModule() >= 3)
                {
                  VRTraceErrorLogLevelToCSTR();
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                    PassMessage_cold_4();
                }
                goto LABEL_149;
              }
              v112 = (pthread_mutex_t *)(v108 + 1480);
              pthread_mutex_lock((pthread_mutex_t *)(v108 + 1480));
              if (v76[1] == 1)
              {
                if (v76[2] == 2)
                  v113 = 1;
                else
                  v113 = v76[2];
                v114 = *(_QWORD *)(v109 + 1472);
                if (v114)
                {
                  while (*(_DWORD *)v114 != 1
                       || strcmp((const char *)(v77 + 54), (const char *)(v114 + 4))
                       || strcmp((const char *)(v77 + 12), (const char *)(v114 + 72))
                       || *(unsigned __int16 *)(v77 + 52) != *(unsigned __int16 *)(v114 + 112)
                       || *(_DWORD *)(v114 + 68) != v113)
                  {
                    v114 = *(_QWORD *)(v114 + 136);
                    if (!v114)
                      goto LABEL_136;
                  }
                  if (((*(uint64_t (**)(_QWORD, unsigned int *))(v114 + 120))(*(_QWORD *)(v114 + 128), v76) & 0x80000000) != 0
                    && (int)VRTraceGetErrorLogLevelForModule() >= 3)
                  {
                    VRTraceErrorLogLevelToCSTR();
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                      PassMessage_cold_6();
                  }
LABEL_148:
                  pthread_mutex_unlock(v112);
LABEL_149:
                  CheckOutHandleDebug();
                  return;
                }
              }
              else
              {
                v116 = *(_QWORD *)(v109 + 1472);
                if (v116)
                {
                  while (*(_DWORD *)v116
                       || strcmp((const char *)(v77 + 54), (const char *)(v116 + 4))
                       || *(_DWORD *)(v111 + 8) != *(_DWORD *)(v116 + 68))
                  {
                    v116 = *(_QWORD *)(v116 + 136);
                    if (!v116)
                      goto LABEL_136;
                  }
                  if (((*(uint64_t (**)(_QWORD, unsigned int *))(v116 + 120))(*(_QWORD *)(v116 + 128), v76) & 0x80000000) != 0
                    && (int)VRTraceGetErrorLogLevelForModule() >= 3)
                  {
                    VRTraceErrorLogLevelToCSTR();
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                      PassMessage_cold_7();
                  }
                  goto LABEL_148;
                }
              }
LABEL_136:
              pthread_mutex_unlock((pthread_mutex_t *)(v109 + 1480));
              if (((*(uint64_t (**)(_QWORD, unsigned int *))v110)(*(_QWORD *)(v110 + 8), v76) & 0x80000000) != 0
                && (int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  PassMessage_cold_5();
              }
              goto LABEL_149;
            }
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                PassMessage_cold_3();
            }
            goto LABEL_74;
          }
          v78 = (const char *)*((_QWORD *)v76 + 33);
          if (v78)
          {
            memset(buf, 170, 0x1518uLL);
            v122 = 5400;
            v79 = (uint64_t (*)(_QWORD, uint8_t *, int *, uint8_t *, _QWORD, unsigned int *))*((_QWORD *)v76 + 127);
            if (!v79)
              goto LABEL_97;
            v80 = v79(v76[252], buf, &v122, v13, v76[140], v76);
            if (v80 < 0)
            {
              v98 = v80;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                v99 = VRTraceErrorLogLevelToCSTR();
                v100 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                {
                  v117 = *((_DWORD *)v120 + 252);
                  v118 = *((_DWORD *)v120 + 140);
                  *(_DWORD *)v134 = 136316674;
                  *(_QWORD *)&v134[4] = v99;
                  *(_WORD *)&v134[12] = 2080;
                  *(_QWORD *)&v134[14] = "PassMessage";
                  *(_WORD *)&v134[22] = 1024;
                  *(_DWORD *)&v134[24] = 1340;
                  *(_WORD *)&v134[28] = 1024;
                  *(_DWORD *)&v134[30] = 1340;
                  *(_WORD *)&v134[34] = 1024;
                  *(_DWORD *)&v134[36] = v117;
                  *(_WORD *)&v134[40] = 1024;
                  *(_DWORD *)&v134[42] = v118;
                  *(_WORD *)&v134[46] = 1024;
                  *(_DWORD *)&v134[48] = v98;
                  _os_log_error_impl(&dword_1D8A54000, v100, OS_LOG_TYPE_ERROR, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/Transport.c:%d: Decompress failed: %d, %d, (%08X)", v134, 0x34u);
                }
              }
              v76 = (unsigned int *)v120;
              *((_DWORD *)v120 + 33) = 1;
              goto LABEL_97;
            }
            buf[v122] = 0;
            v81 = strcmp(v78, "application/sdp");
            ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
            if (v81)
            {
              if (ErrorLogLevelForModule < 7)
                goto LABEL_96;
              v83 = VRTraceErrorLogLevelToCSTR();
              v84 = *MEMORY[0x1E0CF2758];
              if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                goto LABEL_96;
              v85 = *((_DWORD *)v120 + 140);
              *(_DWORD *)v134 = 136316162;
              *(_QWORD *)&v134[4] = v83;
              *(_WORD *)&v134[12] = 2080;
              *(_QWORD *)&v134[14] = "PassMessage";
              *(_WORD *)&v134[22] = 1024;
              *(_DWORD *)&v134[24] = 1349;
              *(_WORD *)&v134[28] = 1024;
              *(_DWORD *)&v134[30] = v85;
              *(_WORD *)&v134[34] = 1024;
              *(_DWORD *)&v134[36] = v122;
              v86 = "SIP [%s] %s:%d Uncompress binary body from %d to %d";
              v87 = v84;
              v88 = 40;
            }
            else
            {
              if (ErrorLogLevelForModule < 6)
                goto LABEL_96;
              v101 = VRTraceErrorLogLevelToCSTR();
              v102 = *MEMORY[0x1E0CF2758];
              if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                goto LABEL_96;
              v103 = *((_DWORD *)v120 + 140);
              *(_DWORD *)v134 = 136316418;
              *(_QWORD *)&v134[4] = v101;
              *(_WORD *)&v134[12] = 2080;
              *(_QWORD *)&v134[14] = "PassMessage";
              *(_WORD *)&v134[22] = 1024;
              *(_DWORD *)&v134[24] = 1346;
              *(_WORD *)&v134[28] = 1024;
              *(_DWORD *)&v134[30] = v122;
              *(_WORD *)&v134[34] = 2080;
              *(_QWORD *)&v134[36] = buf;
              *(_WORD *)&v134[44] = 1024;
              *(_DWORD *)&v134[46] = v103;
              v86 = "SIP [%s] %s:%d Uncompressed SDP(%d): [%s] from size %d";
              v87 = v102;
              v88 = 50;
            }
            _os_log_impl(&dword_1D8A54000, v87, OS_LOG_TYPE_DEFAULT, v86, v134, v88);
LABEL_96:
            v76 = (unsigned int *)v120;
            *((_DWORD *)v120 + 140) = v122;
            v13 = buf;
LABEL_97:
            if (strcmp(v78, "application/ske") && v14 >= 1)
            {
              v104 = v14;
              v105 = v13;
              do
              {
                if (*v105 == 240)
                  *v105 = 95;
                ++v105;
                --v104;
              }
              while (v104);
              v76 = (unsigned int *)v120;
            }
            v106 = malloc_type_malloc((int)v76[140] + 1, 0x5C63A61CuLL);
            v107 = (int *)v120;
            *((_QWORD *)v120 + 69) = v106;
            if (v106)
            {
              memcpy(v106, v13, v107[140]);
              *(_BYTE *)(*((_QWORD *)v120 + 69) + *((int *)v120 + 140)) = 0;
              v76 = (unsigned int *)v120;
              goto LABEL_106;
            }
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              v115 = VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                PassMessage_cold_2(v115);
            }
LABEL_74:
            FreeSipMsg(v120);
            return;
          }
          if ((int)VRTraceGetErrorLogLevelForModule() < 5)
            goto LABEL_74;
          v97 = VRTraceErrorLogLevelToCSTR();
          v90 = *MEMORY[0x1E0CF2758];
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            goto LABEL_74;
          *(_DWORD *)buf = 136315906;
          *(_QWORD *)&buf[4] = v97;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "PassMessage";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 1327;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = 1327;
          v43 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/Trans"
                "port.c:%d: CONTENT-TYPE null when body not empty.";
        }
        else
        {
          if ((int)VRTraceGetErrorLogLevelForModule() < 5)
            goto LABEL_74;
          v92 = VRTraceErrorLogLevelToCSTR();
          v90 = *MEMORY[0x1E0CF2758];
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            goto LABEL_74;
          *(_DWORD *)buf = 136315906;
          *(_QWORD *)&buf[4] = v92;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "PassMessage";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 1316;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = 1316;
          v43 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/Trans"
                "port.c:%d: CSeq header missing";
        }
      }
      else
      {
        if ((int)VRTraceGetErrorLogLevelForModule() < 5)
          goto LABEL_74;
        v89 = VRTraceErrorLogLevelToCSTR();
        v90 = *MEMORY[0x1E0CF2758];
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          goto LABEL_74;
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = v89;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "PassMessage";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 1305;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = 1305;
        v43 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/Transpo"
              "rt.c:%d: Via header missing or no field value";
      }
    }
    v44 = v90;
    v45 = 34;
LABEL_73:
    _os_log_impl(&dword_1D8A54000, v44, OS_LOG_TYPE_DEFAULT, v43, buf, v45);
    goto LABEL_74;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      PassMessage_cold_1();
  }
}

uint64_t CompressMsg(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  const char *v7;
  int *v8;
  int *v9;
  char *v10;
  char *v11;
  void *v12;
  int (*v13)(_QWORD, _BYTE *, int *, const char *, uint64_t, uint64_t);
  _BOOL4 v14;
  uint64_t v15;
  int v16;
  int ErrorLogLevelForModule;
  uint64_t v18;
  NSObject *v19;
  const char *v20;
  NSObject *v21;
  uint32_t v22;
  void *v23;
  const char *v24;
  int *v25;
  const char *v26;
  int v27;
  uint64_t v28;
  NSObject *v29;
  int v31;
  int v32;
  char *v33;
  int v34;
  int __n;
  int __n_4;
  uint64_t v37;
  __int16 v38;
  const char *v39;
  __int16 v40;
  int v41;
  __int16 v42;
  int v43;
  __int16 v44;
  const char *v45;
  __int16 v46;
  int v47;
  _BYTE __b[5400];
  _QWORD __str[3];

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v11 = v10;
  v12 = (void *)v1;
  __str[2] = *MEMORY[0x1E0C80C00];
  __str[0] = 0xAAAAAAAAAAAAAAAALL;
  __str[1] = 0xAAAAAAAAAAAAAAAALL;
  memset(__b, 170, sizeof(__b));
  __n = 5400;
  v13 = *(int (**)(_QWORD, _BYTE *, int *, const char *, uint64_t, uint64_t))(v3 + 1016);
  if (v13)
    v14 = v13(*(unsigned int *)(v3 + 1008), __b, &__n, v7, v5, v3) >= 0;
  else
    v14 = 0;
  v15 = ConstructSipMsg(v11, *v9, v3);
  if ((v15 & 0x80000000) == 0)
  {
    v16 = *(_DWORD *)(v3 + 564);
    if (!v14)
    {
      if (!v16)
      {
        snprintf((char *)__str, 0x10uLL, "%d", v5);
        v31 = strlen(v11);
        ReplaceKeyword(v11, (v31 + 1), "%CLENGTH%", (const char *)__str, 16);
        v32 = strlen(v11);
        v33 = strncat(v11, v7, ~v32 + *v9);
        v34 = strlen(v33);
        *v9 = v34;
        memcpy(v12, v11, v34 + 1);
        return v15;
      }
      v23 = v12;
      v24 = v11;
      v25 = v9;
      v26 = v7;
      v27 = v5;
      goto LABEL_20;
    }
    ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    if (v16)
    {
      if (ErrorLogLevelForModule < 7)
        goto LABEL_19;
      v18 = VRTraceErrorLogLevelToCSTR();
      v19 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        goto LABEL_19;
      __n_4 = 136316162;
      v37 = v18;
      v38 = 2080;
      v39 = "CompressMsg";
      v40 = 1024;
      v41 = 3037;
      v42 = 1024;
      v43 = v5;
      v44 = 1024;
      LODWORD(v45) = __n;
      v20 = "SIP [%s] %s:%d Compress binary body from %d to %d";
      v21 = v19;
      v22 = 40;
    }
    else
    {
      if (ErrorLogLevelForModule < 6)
        goto LABEL_19;
      v28 = VRTraceErrorLogLevelToCSTR();
      v29 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        goto LABEL_19;
      __n_4 = 136316418;
      v37 = v28;
      v38 = 2080;
      v39 = "CompressMsg";
      v40 = 1024;
      v41 = 3039;
      v42 = 1024;
      v43 = v5;
      v44 = 2080;
      v45 = v7;
      v46 = 1024;
      v47 = __n;
      v20 = "SIP [%s] %s:%d Compress SDP(%d): [%s] to size %d";
      v21 = v29;
      v22 = 50;
    }
    _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, v20, (uint8_t *)&__n_4, v22);
LABEL_19:
    *(_DWORD *)(v3 + 564) = 1;
    memcpy(*(void **)(v3 + 552), __b, __n);
    v27 = __n;
    *(_DWORD *)(v3 + 560) = __n;
    v26 = __b;
    v23 = v12;
    v24 = v11;
    v25 = v9;
LABEL_20:
    AppendBinaryBody(v23, v24, v25, v26, v27);
    return v15;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      CompressMsg_cold_1();
  }
  return v15;
}

uint64_t AddToCListRTP(uint64_t a1, int a2, int a3, __int128 *a4, int a5)
{
  pthread_rwlock_t *v10;
  char *v11;
  void *v12;
  __int128 v13;
  __int128 v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  int v18;

  v10 = (pthread_rwlock_t *)(a1 + 1272);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 1272));
  v11 = (char *)malloc_type_calloc(1uLL, 0x868uLL, 0x10200406FE3F67FuLL);
  if (v11)
  {
    v12 = v11;
    *(_DWORD *)v11 = a3;
    *((_QWORD *)v11 + 266) = 0xFFFFFFFFLL;
    *((_DWORD *)v11 + 2) = 2048;
    *((_DWORD *)v11 + 517) = a5;
    *((_DWORD *)v11 + 516) = a2;
    v13 = *a4;
    v14 = a4[1];
    *((_QWORD *)v11 + 263) = *((_QWORD *)a4 + 4);
    *(_OWORD *)(v11 + 2072) = v13;
    *(_OWORD *)(v11 + 2088) = v14;
    if ((ICEAddOneInterface() & 0x80000000) != 0)
    {
      free(v12);
    }
    else
    {
      v15 = (_QWORD *)(a1 + 1264);
      do
      {
        v16 = v15;
        v17 = *v15;
        v15 = (_QWORD *)(*v15 + 2144);
      }
      while (v17);
      *v16 = v12;
      pthread_rwlock_unlock(v10);
      v10 = (pthread_rwlock_t *)(a1 + 1064);
      pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 1064));
      v18 = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 12) = -1;
      VTP_Close(v18);
    }
  }
  return pthread_rwlock_unlock(v10);
}

void *AppendBinaryBody(void *a1, const char *a2, int *a3, const void *a4, int a5)
{
  int v10;
  int v11;
  uint64_t v12;
  NSObject *v13;
  int v14;
  void *result;
  uint8_t buf[4];
  uint64_t v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  char __str[16];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  memset(__str, 170, sizeof(__str));
  snprintf(__str, 0x10uLL, "%d", a5);
  v10 = strlen(a2);
  ReplaceKeyword(a2, (v10 + 1), "%CLENGTH%", __str, 16);
  v11 = strlen(a2);
  *a3 = v11;
  memcpy(a1, a2, v11);
  strcpy((char *)a1 + *a3, "<Binary>");
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v12 = VRTraceErrorLogLevelToCSTR();
    v13 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v14 = *a3;
      *(_DWORD *)buf = 136316162;
      v17 = v12;
      v18 = 2080;
      v19 = "AppendBinaryBody";
      v20 = 1024;
      v21 = 3012;
      v22 = 1024;
      v23 = v14;
      v24 = 1024;
      v25 = a5;
      _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d()()()()() TP BINARY BODY (%d + %d)", buf, 0x28u);
    }
  }
  result = memcpy((void *)&a2[*a3], a4, a5);
  *a3 += a5;
  return result;
}

uint64_t TPGetLocalCellTech(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  uint8_t buf[4];
  uint64_t v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  __int16 v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    VCCTServiceMonitor_GetRadioAccessTechnology();
    if (!VCCTServiceMonitor_GetDataIndicatorStatus())
      VCCTServiceMonitor_GetDataIndicatorStatusOverride();
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v1 = VRTraceErrorLogLevelToCSTR();
      v2 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        v5 = v1;
        v6 = 2080;
        v7 = "TPGetLocalCellTech";
        v8 = 1024;
        v9 = 340;
        v10 = 1024;
        v11 = 0;
        _os_log_impl(&dword_1D8A54000, v2, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Active wireless technology: [%d]", buf, 0x22u);
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      TPGetLocalCellTech_cold_1();
  }
  return 0;
}

void VCBasebandCongestionDetector_SetMode(uint64_t a1, int a2)
{
  uint64_t v2;
  NSObject *v3;

  if (a1)
  {
    *(_DWORD *)(a1 + 12) = a2;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCBasebandCongestionDetector_SetMode_cold_1(v2, v3);
  }
}

BOOL VCRateControlProcessBasebandNotification(void *a1, uint64_t a2)
{
  if (a1)
    objc_msgSend(a1, "processBasebandNotification:arrivalTime:error:", a2, 0);
  return a1 != 0;
}

uint64_t VCTransportStreamRunLoopVTPCreate(const __CFAllocator *a1, _QWORD *a2)
{
  int v4;
  _QWORD *DerivedStorage;
  CFMutableArrayRef Mutable;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  int v11;
  uint8_t buf[4];
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    VCTransportStreamRunLoopGetClassID();
    v4 = CMDerivedObjectCreate();
    if (v4)
    {
      if (v4 >= 0)
        v11 = v4;
      else
        v11 = -v4;
      v9 = v11 | 0xD0360000;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCTransportStreamRunLoopVTPCreate_cold_3();
      }
    }
    else
    {
      DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage();
      Mutable = CFArrayCreateMutable(a1, 0, MEMORY[0x1E0C9B378]);
      *DerivedStorage = Mutable;
      if (Mutable)
      {
        DerivedStorage[1] = 0xFFFFFFFF00000000;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v7 = VRTraceErrorLogLevelToCSTR();
          v8 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315906;
            v13 = v7;
            v14 = 2080;
            v15 = "VCTransportStreamRunLoopVTPCreate";
            v16 = 1024;
            v17 = 90;
            v18 = 2048;
            v19 = 0;
            _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d [%p]", buf, 0x26u);
          }
        }
        v9 = 0;
        *a2 = 0;
      }
      else
      {
        v9 = 2151022594;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            VCTransportStreamRunLoopVTPCreate_cold_2();
            return 2151022594;
          }
        }
      }
    }
  }
  else
  {
    v9 = 2151022593;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCTransportStreamRunLoopVTPCreate_cold_1();
    }
  }
  return v9;
}

uint64_t _VCTransportStreamRunLoopVTPFinalize()
{
  uint64_t DerivedStorage;
  uint64_t result;

  DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (*(_QWORD *)DerivedStorage)
    CFRelease(*(CFTypeRef *)DerivedStorage);
  result = *(unsigned int *)(DerivedStorage + 12);
  if ((_DWORD)result != -1)
    return VTP_Close(result);
  return result;
}

uint64_t _VCTransportStreamRunLoopVTPAddTransportStream(uint64_t a1, const void *a2)
{
  CFMutableArrayRef *DerivedStorage;
  uint64_t v5;

  if (a1)
  {
    if (a2)
    {
      if (VCTransportStreamIsOfKindVTP((uint64_t)a2))
      {
        DerivedStorage = (CFMutableArrayRef *)CMBaseObjectGetDerivedStorage();
        if (!FigCFArrayContainsValue())
        {
          CFArrayAppendValue(*DerivedStorage, a2);
          return _VCTransportStreamRunLoopVTPUpdateFDSet((uint64_t)DerivedStorage);
        }
        if ((int)VRTraceGetErrorLogLevelForModule() < 3)
        {
          return 2151022633;
        }
        else
        {
          VRTraceErrorLogLevelToCSTR();
          v5 = 2151022633;
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VCTransportStreamRunLoopVTPAddTransportStream_cold_3();
        }
      }
      else
      {
        v5 = 2151022593;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VCTransportStreamRunLoopVTPAddTransportStream_cold_4();
        }
      }
    }
    else
    {
      v5 = 2151022593;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCTransportStreamRunLoopVTPAddTransportStream_cold_2();
      }
    }
  }
  else
  {
    v5 = 2151022593;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCTransportStreamRunLoopVTPAddTransportStream_cold_1();
    }
  }
  return v5;
}

uint64_t _VCTransportStreamRunLoopVTPRemoveTransportStream(uint64_t a1, const void *a2)
{
  CFArrayRef *DerivedStorage;
  const __CFArray *v4;
  CFIndex FirstIndexOfValue;
  uint64_t v7;
  CFRange v8;

  if (a1)
  {
    if (a2)
    {
      DerivedStorage = (CFArrayRef *)CMBaseObjectGetDerivedStorage();
      v4 = *DerivedStorage;
      v8.length = CFArrayGetCount(*DerivedStorage);
      v8.location = 0;
      FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v4, v8, a2);
      if (FirstIndexOfValue != -1)
      {
        CFArrayRemoveValueAtIndex(*DerivedStorage, FirstIndexOfValue);
        return _VCTransportStreamRunLoopVTPUpdateFDSet((uint64_t)DerivedStorage);
      }
      v7 = 2151022614;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          _VCTransportStreamRunLoopVTPRemoveTransportStream_cold_3();
          return 2151022614;
        }
      }
    }
    else
    {
      v7 = 2151022593;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCTransportStreamRunLoopVTPRemoveTransportStream_cold_2();
      }
    }
  }
  else
  {
    v7 = 2151022593;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCTransportStreamRunLoopVTPRemoveTransportStream_cold_1();
    }
  }
  return v7;
}

uint64_t _VCTransportStreamRunLoopVTPWaitForReceive(uint64_t a1, double a2)
{
  uint64_t v3;
  uint64_t DerivedStorage;
  uint64_t v6;
  uint64_t *v7;
  int v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v12;
  NSObject *v13;
  NSObject *v14;
  const char *v15;
  uint64_t v16;
  NSObject *v17;
  uint64_t v18;
  int v19;
  int v20;
  __int128 __dst[8];
  _BYTE buf[24];
  __int128 v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    v3 = 2151022593;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCTransportStreamRunLoopVTPWaitForReceive_cold_1();
    }
    return v3;
  }
  v3 = 2151022593;
  if (a2 < 0.0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCTransportStreamRunLoopVTPWaitForReceive_cold_2();
    }
    return v3;
  }
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  if ((int)CFArrayGetCount(*(CFArrayRef *)DerivedStorage) < 1)
    return 2151022653;
  if (*(_DWORD *)(DerivedStorage + 12) == -1)
  {
    v6 = _VCTransportStreamRunLoopVTPUpdateFDSet(DerivedStorage);
    if ((v6 & 0x80000000) != 0)
      return v6;
  }
  memmove(__dst, (const void *)(DerivedStorage + 16), 0x80uLL);
  v18 = (uint64_t)a2;
  v20 = -1431655766;
  v19 = (int)((a2 - (double)(uint64_t)a2) * 1000000.0);
  if (a2 <= 0.0)
    v7 = 0;
  else
    v7 = &v18;
  v8 = VTP_Select((*(_DWORD *)(DerivedStorage + 144) + 1), __dst, 0, 0, (uint64_t)v7);
  if (v8 == -1)
  {
    if (*__error() != 9)
    {
      v3 = *__error() | 0xC0360000;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v9 = VRTraceErrorLogLevelToCSTR();
        v10 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCTransportStreamRunLoopVTPWaitForReceive_cold_4(v9, v10);
      }
      return v3;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() < 8)
      return 2151022622;
    v12 = VRTraceErrorLogLevelToCSTR();
    v13 = *MEMORY[0x1E0CF2758];
    v14 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      v3 = 2151022622;
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        return v3;
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = v12;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "_VCTransportStreamRunLoopVTPWaitForReceive";
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v23) = 177;
      WORD2(v23) = 2048;
      *(_QWORD *)((char *)&v23 + 6) = a1;
      v15 = " [%s] %s:%d RunLoop %p wait for receive was cancelled";
LABEL_33:
      _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, v15, buf, 0x26u);
      return v3;
    }
    v3 = 2151022622;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      _VCTransportStreamRunLoopVTPWaitForReceive_cold_3();
    return v3;
  }
  if (v8)
  {
    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
    *(_QWORD *)&buf[8] = 0x40000000;
    *(_QWORD *)&buf[16] = ___VCTransportStreamRunLoopVTPPerformReceive_block_invoke;
    *(_QWORD *)&v23 = &__block_descriptor_tmp_2_0;
    *((_QWORD *)&v23 + 1) = __dst;
    return _VCTransportStreamRunLoopVTPIterateTransportStreams((CFArrayRef *)DerivedStorage, (uint64_t)buf);
  }
  if ((int)VRTraceGetErrorLogLevelForModule() < 8)
    return 2151022615;
  v16 = VRTraceErrorLogLevelToCSTR();
  v13 = *MEMORY[0x1E0CF2758];
  v17 = *MEMORY[0x1E0CF2758];
  if (*MEMORY[0x1E0CF2748])
  {
    v3 = 2151022615;
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      return v3;
    *(_DWORD *)buf = 136315906;
    *(_QWORD *)&buf[4] = v16;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = "_VCTransportStreamRunLoopVTPWaitForReceive";
    *(_WORD *)&buf[22] = 1024;
    LODWORD(v23) = 179;
    WORD2(v23) = 2048;
    *(_QWORD *)((char *)&v23 + 6) = a1;
    v15 = " [%s] %s:%d RunLoop %p wait for receive timed out";
    goto LABEL_33;
  }
  v3 = 2151022615;
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
    _VCTransportStreamRunLoopVTPWaitForReceive_cold_5();
  return v3;
}

uint64_t _VCTransportStreamRunLoopVTPCancelWait(uint64_t a1)
{
  os_unfair_lock_s *DerivedStorage;
  uint64_t v3;
  NSObject *v4;
  int os_unfair_lock_opaque;
  uint64_t v6;
  int v8;
  uint64_t v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    DerivedStorage = (os_unfair_lock_s *)CMBaseObjectGetDerivedStorage();
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v3 = VRTraceErrorLogLevelToCSTR();
      v4 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v8 = 136315906;
        v9 = v3;
        v10 = 2080;
        v11 = "_VCTransportStreamRunLoopVTPCancelWait";
        v12 = 1024;
        v13 = 196;
        v14 = 2048;
        v15 = a1;
        _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d [%p]", (uint8_t *)&v8, 0x26u);
      }
    }
    os_unfair_lock_lock(DerivedStorage + 2);
    os_unfair_lock_opaque = DerivedStorage[3]._os_unfair_lock_opaque;
    DerivedStorage[3]._os_unfair_lock_opaque = -1;
    os_unfair_lock_unlock(DerivedStorage + 2);
    if (os_unfair_lock_opaque == -1)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      {
        return 2151022653;
      }
      else
      {
        VRTraceErrorLogLevelToCSTR();
        v6 = 2151022653;
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCTransportStreamRunLoopVTPCancelWait_cold_2();
      }
    }
    else
    {
      VTP_Close(os_unfair_lock_opaque);
      return 0;
    }
  }
  else
  {
    v6 = 2151022593;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCTransportStreamRunLoopVTPCancelWait_cold_1();
    }
  }
  return v6;
}

uint64_t _VCTransportStreamRunLoopVTPUpdateFDSet(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  os_unfair_lock_s *v4;
  int v5;
  int v6;
  int v7;
  _QWORD *v8;
  uint64_t v10;
  NSObject *v11;
  _QWORD v12[6];
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v1 = 2151022593;
  v13 = 0;
  v14 = &v13;
  v15 = 0x2000000000;
  v16 = 0x80000000;
  v17 = 0;
  v18 = &v17;
  v19 = 0x9800000000;
  v20 = 0u;
  v21 = 0u;
  v22 = 0u;
  v23 = 0u;
  v24 = 0u;
  v25 = 0u;
  v26 = 0u;
  v27 = 0u;
  if (a1)
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 0x40000000;
    v12[2] = ___VCTransportStreamRunLoopVTPUpdateFDSet_block_invoke;
    v12[3] = &unk_1E9E559E8;
    v12[4] = &v13;
    v12[5] = &v17;
    v3 = _VCTransportStreamRunLoopVTPIterateTransportStreams((CFArrayRef *)a1, (uint64_t)v12);
    if ((v3 & 0x80000000) != 0 && (_DWORD)v3 != -2143944639)
    {
      v1 = v3;
    }
    else
    {
      v4 = (os_unfair_lock_s *)(a1 + 8);
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 8));
      v5 = *(_DWORD *)(a1 + 12);
      if (v5 == -1 && (v5 = VTP_Socket(2, 2, 17), *(_DWORD *)(a1 + 12) = v5, v5 == -1))
      {
        v1 = *__error() | 0xC0360000;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v10 = VRTraceErrorLogLevelToCSTR();
          v11 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VCTransportStreamRunLoopVTPUpdateFDSet_cold_2(v10, v11);
        }
        os_unfair_lock_unlock(v4);
      }
      else
      {
        v6 = *((_DWORD *)v14 + 6);
        if (v6 <= v5)
          v6 = v5;
        *((_DWORD *)v14 + 6) = v6;
        v7 = *(_DWORD *)(a1 + 12);
        v8 = v18 + 3;
        if (__darwin_check_fd_set_overflow(v7, v18 + 3, 0))
          *(_DWORD *)((char *)v8 + (((unint64_t)v7 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v7;
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 8));
        memmove((void *)(a1 + 16), v18 + 3, 0x80uLL);
        v1 = 0;
        *(_DWORD *)(a1 + 144) = *((_DWORD *)v14 + 6);
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCTransportStreamRunLoopVTPUpdateFDSet_cold_1();
  }
  _Block_object_dispose(&v17, 8);
  _Block_object_dispose(&v13, 8);
  return v1;
}

uint64_t _VCTransportStreamRunLoopVTPIterateTransportStreams(CFArrayRef *a1, uint64_t a2)
{
  uint64_t v2;
  int Count;
  CFIndex v6;
  uint64_t v7;
  uint64_t v8;
  const void *ValueAtIndex;
  uint64_t v10;
  uint64_t CMBaseObject;
  uint64_t (*v12)(uint64_t, const __CFString *, uint64_t, CFNumberRef *);
  uint64_t v13;
  NSObject *v14;
  CFNumberRef number;
  unsigned int valuePtr;
  uint64_t v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  int v24;
  __int16 v25;
  const void *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v2 = 2151022593;
  if (a1)
  {
    Count = CFArrayGetCount(*a1);
    if (Count < 1)
    {
      return 2151022657;
    }
    else
    {
      v6 = 0;
      v7 = *MEMORY[0x1E0C9AE00];
      v8 = Count;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*a1, v6);
        number = 0;
        CMBaseObject = VCPacketFilterGetCMBaseObject(ValueAtIndex, v10);
        v12 = *(uint64_t (**)(uint64_t, const __CFString *, uint64_t, CFNumberRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                                            + 48);
        if (!v12)
          break;
        v2 = v12(CMBaseObject, CFSTR("UnderlyingVFD"), v7, &number);
        if ((v2 & 0x80000000) != 0)
          goto LABEL_11;
        if (!number)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              _VCTransportStreamRunLoopVTPIterateTransportStreams_cold_2();
          }
          return v2;
        }
        valuePtr = -1;
        CFNumberGetValue(number, kCFNumberIntType, &valuePtr);
        CFRelease(number);
        v2 = (*(uint64_t (**)(uint64_t, CFArrayRef *, const void *, _QWORD))(a2 + 16))(a2, a1, ValueAtIndex, valuePtr);
        if ((v2 & 0x80000000) == 0 && v8 != ++v6)
          continue;
        return v2;
      }
      v2 = 4294954514;
LABEL_11:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v13 = VRTraceErrorLogLevelToCSTR();
        v14 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          valuePtr = 136316162;
          v18 = v13;
          v19 = 2080;
          v20 = "_VCTransportStreamRunLoopVTPIterateTransportStreams";
          v21 = 1024;
          v22 = 279;
          v23 = 1024;
          v24 = v2;
          v25 = 2048;
          v26 = ValueAtIndex;
          _os_log_error_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_ERROR, " [%s] %s:%d Could not get VFD %d from tranportStream %p", (uint8_t *)&valuePtr, 0x2Cu);
        }
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCTransportStreamRunLoopVTPIterateTransportStreams_cold_1();
  }
  return v2;
}

double SRTPClearExchangeInfo(uint64_t a1)
{
  double result;

  if (a1)
  {
    VCMediaKeyIndex_Release((const void **)(a1 + 96));
    *(_QWORD *)(a1 + 96) = 0;
    result = 0.0;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
  }
  return result;
}

double SRTPClearKeyDerivationInfo(uint64_t a1)
{
  double result;

  if (a1)
  {
    VCMediaKeyIndex_Release((const void **)(a1 + 144));
    *(_QWORD *)(a1 + 144) = 0;
    result = 0.0;
    *(_OWORD *)(a1 + 112) = 0u;
    *(_OWORD *)(a1 + 128) = 0u;
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 96) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)a1 = 0u;
  }
  return result;
}

void HexToByte(_BYTE *a1, int a2, char *__s1, int a4)
{
  uint64_t v7;
  size_t v8;
  uint64_t v9;
  unint64_t v10;
  int v11;
  _BYTE *v12;
  char *v15;
  uint64_t v16;
  _BYTE *v17;
  char *v18;
  BOOL v19;
  int v20;
  int v21;
  char v22;
  char v23;
  char v24;

  v7 = a4;
  v8 = strnlen(__s1, a4) >> 1;
  if ((int)v8 >= a2)
    v9 = a2;
  else
    v9 = v8;
  v10 = (unint64_t)&a1[a2];
  v11 = a2 - v8;
  if (a2 > (int)v8)
  {
    v12 = &a1[(int)v8];
    if (v10 < (unint64_t)v12 || v12 < a1 || v10 - (unint64_t)v12 < v11)
    {
LABEL_37:
      __break(0x5519u);
      return;
    }
    bzero(v12, v11);
  }
  if ((int)v9 >= 1)
  {
    v15 = &__s1[v7];
    v16 = v9;
    v17 = a1;
    v18 = __s1;
    do
    {
      if (v18 > v15)
        goto LABEL_37;
      if (v18 < __s1)
        goto LABEL_37;
      v19 = v7 < 2;
      v7 -= 2;
      if (v19)
        goto LABEL_37;
      v20 = *v18;
      v21 = v18[1];
      if ((v20 - 48) >= 0xA)
      {
        if ((v20 - 65) >= 6)
        {
          if ((v20 - 97) > 5)
            goto LABEL_32;
          v22 = -87;
        }
        else
        {
          v22 = -55;
        }
      }
      else
      {
        v22 = -48;
      }
      if ((v21 - 48) >= 0xA)
      {
        if ((v21 - 65) >= 6)
        {
          if ((v21 - 97) > 5)
          {
LABEL_32:
            v24 = 0;
            goto LABEL_33;
          }
          v23 = -87;
        }
        else
        {
          v23 = -55;
        }
      }
      else
      {
        v23 = -48;
      }
      v24 = v21 + 16 * (v22 + v20) + v23;
LABEL_33:
      if ((unint64_t)v17 >= v10 || v17 < a1)
        goto LABEL_37;
      *v17++ = v24;
      v18 += 2;
      --v16;
    }
    while (v16);
  }
}

unint64_t ByteToHex(unint64_t result, int a2, unsigned __int8 *a3, int a4)
{
  int v4;
  uint64_t v5;
  unint64_t v6;
  _BYTE *v7;
  uint64_t v8;
  unsigned __int8 *v9;
  unsigned int v10;
  BOOL v11;
  int v12;
  int v13;
  unsigned int v14;
  _BOOL4 v16;
  char v17;
  uint64_t v18;
  int v19;
  unint64_t v20;
  unint64_t v21;

  if (a2 >= 0)
    v4 = a2;
  else
    v4 = a2 + 1;
  LODWORD(v5) = v4 >> 1;
  if ((int)v5 >= a4)
    v5 = a4;
  else
    v5 = v5;
  v6 = result + a2;
  if ((int)v5 >= 1)
  {
    v7 = (_BYTE *)(result + 1);
    v8 = v5;
    v9 = a3;
    while (v9 < &a3[a4] && v9 >= a3)
    {
      v10 = *v9;
      v11 = (unint64_t)(v7 - 1) < v6 && (unint64_t)(v7 - 1) >= result;
      v12 = v11;
      if (v10 > 0x9F)
      {
        if (!v12)
          goto LABEL_45;
        v13 = (v10 >> 4) + 55;
      }
      else
      {
        if (!v12)
          goto LABEL_45;
        v13 = (v10 >> 4) | 0x30;
      }
      v14 = v10 & 0xF;
      *(v7 - 1) = v13;
      v16 = (unint64_t)v7 < v6 && (unint64_t)v7 >= result;
      if (v14 > 9)
      {
        if (!v16)
          goto LABEL_45;
        v17 = v14 + 55;
      }
      else
      {
        if (!v16)
          goto LABEL_45;
        v17 = v14 | 0x30;
      }
      *v7 = v17;
      v7 += 2;
      ++v9;
      if (!--v8)
        goto LABEL_34;
    }
    goto LABEL_45;
  }
LABEL_34:
  v18 = (2 * v5);
  v19 = a2 - v18;
  if (a2 <= (int)v18)
    return v18;
  v20 = result + (int)v18;
  v11 = v6 >= v20;
  v21 = v6 - v20;
  if (v11 && v20 >= result && v21 >= v19)
  {
    bzero((void *)(result + (int)v18), v19);
    return v18;
  }
LABEL_45:
  __break(0x5519u);
  return result;
}

void setTransformPolicyFromCipherSuite(int a1, uint64_t a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  int v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  switch(a1)
  {
    case 0:
      goto LABEL_6;
    case 1:
      *(_OWORD *)a2 = xmmword_1D910D310;
      *(_QWORD *)(a2 + 16) = 0x1400000002;
      *(_DWORD *)(a2 + 24) = 10;
      v5 = 0x1400000001;
      break;
    case 2:
      *(_OWORD *)a2 = xmmword_1D910ACF0;
      *(_QWORD *)(a2 + 16) = 0;
      *(_DWORD *)(a2 + 24) = 0;
      v5 = 0x1400000002;
      break;
    case 3:
      *(_OWORD *)a2 = xmmword_1D910ACF0;
      *(_QWORD *)(a2 + 16) = 1;
      *(_DWORD *)(a2 + 24) = 4;
      v5 = 0x1400000003;
      break;
    case 4:
      *(_OWORD *)a2 = xmmword_1D910ACF0;
      *(_QWORD *)(a2 + 16) = 0x1400000002;
      *(_DWORD *)(a2 + 24) = 10;
      v5 = 0x1400000004;
      break;
    case 5:
      if (a3)
        v8 = 32;
      else
        v8 = 16;
      *(_DWORD *)a2 = 2;
      *(_DWORD *)(a2 + 4) = v8;
      *(_OWORD *)(a2 + 8) = xmmword_1D910D300;
      *(_DWORD *)(a2 + 24) = 0;
      v5 = 0x1400000005;
      break;
    case 6:
      *(_OWORD *)a2 = xmmword_1D910D2F0;
      *(_QWORD *)(a2 + 16) = 1;
      *(_DWORD *)(a2 + 24) = 4;
      v5 = 0x1400000006;
      break;
    case 7:
      *(_OWORD *)a2 = xmmword_1D910D2F0;
      *(_QWORD *)(a2 + 16) = 0x1400000002;
      *(_DWORD *)(a2 + 24) = 10;
      v5 = 0x1400000007;
      break;
    case 8:
      *(_OWORD *)a2 = xmmword_1D910ACF0;
      *(_QWORD *)(a2 + 16) = 0x2000000004;
      *(_DWORD *)(a2 + 24) = 10;
      v5 = 0x2000000008;
      break;
    case 9:
      *(_OWORD *)a2 = xmmword_1D910ACF0;
      *(_QWORD *)(a2 + 16) = 0x2000000003;
      *(_DWORD *)(a2 + 24) = 4;
      v5 = 0x2000000009;
      break;
    default:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v6 = VRTraceErrorLogLevelToCSTR();
        v7 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v9 = 136316162;
          v10 = v6;
          v11 = 2080;
          v12 = "setTransformPolicyFromCipherSuite";
          v13 = 1024;
          v14 = 205;
          v15 = 1024;
          v16 = a1;
          v17 = 1024;
          v18 = 0;
          _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Unknown cipherSuite=%d, defaulting to %d ", (uint8_t *)&v9, 0x28u);
        }
      }
LABEL_6:
      *(_QWORD *)a2 = 0;
      *(_QWORD *)(a2 + 8) = 0;
      *(_DWORD *)(a2 + 24) = 0;
      *(_QWORD *)(a2 + 16) = 0;
      v5 = 0x1400000000;
      break;
  }
  *(_QWORD *)(a2 + 28) = v5;
}

void SRTPGetROC(uint64_t a1, unsigned int a2, int *a3, int a4)
{
  unsigned int v8;
  BOOL v9;
  int v10;
  int v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  NSObject *v16;
  NSObject *v17;
  int v18;
  int v19;
  uint64_t v20;
  NSObject *v21;
  NSObject *v22;
  int v23;
  int v24;
  int v25;
  int v26;
  uint64_t v27;
  __int16 v28;
  const char *v29;
  __int16 v30;
  int v31;
  __int16 v32;
  int v33;
  __int16 v34;
  unsigned int v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v8 = *(_DWORD *)(a1 + 408);
  v9 = v8 > 4;
  v10 = (1 << v8) & 0x1A;
  if (v9 || v10 == 0)
  {
    v12 = 0;
  }
  else
  {
    if ((*(_BYTE *)a1 & 4) != 0)
    {
      *a3 = *(_DWORD *)(a1 + 124);
      return;
    }
    v12 = 1;
  }
  v13 = *(unsigned __int16 *)(a1 + 130);
  v14 = *(_DWORD *)(a1 + 124);
  if (((a2 - v13) & 0x8000) != 0)
  {
    if (a2 > v13)
    {
      if (v14)
      {
        v18 = v14 - 1;
        if (a4)
          *(_WORD *)(a1 + 130) = a2;
      }
      else
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            SRTPGetROC_cold_1();
        }
        v18 = 0;
      }
      if (v12)
        v14 = v18 & 0xFFF;
      else
        v14 = v18;
      *a3 = v14;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v20 = VRTraceErrorLogLevelToCSTR();
        v21 = *MEMORY[0x1E0CF2758];
        v22 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
          {
            v23 = *a3;
            v26 = 136316162;
            v27 = v20;
            v28 = 2080;
            v29 = "SRTPGetROC";
            v30 = 1024;
            v31 = 461;
            v32 = 1024;
            v33 = v23;
            v34 = 1024;
            v35 = a2;
            _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d PreCalc: use dwROC=%u (wSeq=%u)", (uint8_t *)&v26, 0x28u);
          }
        }
        else if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
        {
          v25 = *a3;
          v26 = 136316162;
          v27 = v20;
          v28 = 2080;
          v29 = "SRTPGetROC";
          v30 = 1024;
          v31 = 461;
          v32 = 1024;
          v33 = v25;
          v34 = 1024;
          v35 = a2;
          _os_log_debug_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEBUG, " [%s] %s:%d PreCalc: use dwROC=%u (wSeq=%u)", (uint8_t *)&v26, 0x28u);
        }
      }
      goto LABEL_40;
    }
  }
  else
  {
    if (a2 >= v13)
    {
      v19 = 0;
    }
    else
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v15 = VRTraceErrorLogLevelToCSTR();
        v16 = *MEMORY[0x1E0CF2758];
        v17 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            v26 = 136316162;
            v27 = v15;
            v28 = 2080;
            v29 = "SRTPGetROC";
            v30 = 1024;
            v31 = 435;
            v32 = 1024;
            v33 = v14;
            v34 = 1024;
            v35 = a2;
            _os_log_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d PreCalc: dwROC=%u (wSeq=%u)", (uint8_t *)&v26, 0x28u);
          }
        }
        else if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
        {
          v26 = 136316162;
          v27 = v15;
          v28 = 2080;
          v29 = "SRTPGetROC";
          v30 = 1024;
          v31 = 435;
          v32 = 1024;
          v33 = v14;
          v34 = 1024;
          v35 = a2;
          _os_log_debug_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEBUG, " [%s] %s:%d PreCalc: dwROC=%u (wSeq=%u)", (uint8_t *)&v26, 0x28u);
        }
      }
      v19 = 1;
    }
    v24 = v19 + v14;
    if (a4)
      *(_WORD *)(a1 + 130) = a2;
    if (v12)
      v14 = v24 & 0xFFF;
    else
      v14 = v24;
  }
  *a3 = v14;
LABEL_40:
  if (a4)
    *(_DWORD *)(a1 + 124) = v14;
}

void SRTPGetSendROC(uint64_t a1, unsigned int a2, int *a3)
{
  SRTPGetROC(a1, a2, a3, 0);
}

uint64_t SRTPCleanUpEncryption()
{
  uint64_t v0;
  uint64_t v1;

  v0 = CheckInHandleDebug();
  if (!v0)
    return 2147549186;
  v1 = v0;
  SRTPCleanUp(v0 + 7080);
  SRTPCleanUp(v1 + 7520);
  SRTPCleanUp(v1 + 7960);
  SRTPCleanUp(v1 + 8400);
  CheckOutHandleDebug();
  return 0;
}

uint64_t SRTPCleanUp(uint64_t a1)
{
  _CCCryptor *v2;

  if (!*(_DWORD *)a1)
    return 2149711928;
  *(_DWORD *)a1 = 0;
  VCMediaKeyIndex_Release((const void **)(a1 + 352));
  VCMediaKeyIndex_Release((const void **)(a1 + 360));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 288));
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 376));
  v2 = *(_CCCryptor **)(a1 + 384);
  if (v2)
  {
    CCCryptorRelease(v2);
    *(_QWORD *)(a1 + 384) = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 376));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 8));
  pthread_cond_destroy((pthread_cond_t *)(a1 + 72));
  return 0;
}

uint64_t SRTPInitCrypt(uint64_t a1, const void *a2)
{
  os_unfair_lock_s *v4;
  _CCCryptor *v5;
  uint64_t v6;

  v4 = (os_unfair_lock_s *)(a1 + 376);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 376));
  v5 = *(_CCCryptor **)(a1 + 384);
  if (v5)
  {
    CCCryptorRelease(v5);
    *(_QWORD *)(a1 + 384) = 0;
  }
  v6 = CCCryptorCreateWithMode(0, 4u, 0, 0, 0, a2, *(int *)(a1 + 156), 0, 0, 0, 2u, (CCCryptorRef *)(a1 + 384));
  if ((_DWORD)v6)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SRTPInitCrypt_cold_1();
    }
  }
  os_unfair_lock_unlock(v4);
  return v6;
}

unint64_t SRTPPrepareEncryption()
{
  uint64_t v0;
  unint64_t result;
  unint64_t v2;

  v0 = 2147549186;
  result = CheckInHandleDebug();
  if (!result)
    return v0;
  v2 = result;
  if (result == 0xFFFFFFFF)
    return 2147549190;
  v0 = 2149711911;
  if (*(_DWORD *)(result + 7080)
    || *(_DWORD *)(result + 7520)
    || *(_DWORD *)(result + 7960)
    || *(_DWORD *)(result + 8400))
  {
LABEL_10:
    CheckOutHandleDebug();
    return v0;
  }
  if (result < result + 27616)
  {
    *(_QWORD *)(result + 7512) = 0;
    *(_OWORD *)(result + 7480) = 0u;
    *(_OWORD *)(result + 7496) = 0u;
    *(_OWORD *)(result + 7448) = 0u;
    *(_OWORD *)(result + 7464) = 0u;
    *(_OWORD *)(result + 7416) = 0u;
    *(_OWORD *)(result + 7432) = 0u;
    *(_OWORD *)(result + 7384) = 0u;
    *(_OWORD *)(result + 7400) = 0u;
    *(_OWORD *)(result + 7352) = 0u;
    *(_OWORD *)(result + 7368) = 0u;
    *(_OWORD *)(result + 7320) = 0u;
    *(_OWORD *)(result + 7336) = 0u;
    *(_OWORD *)(result + 7288) = 0u;
    *(_OWORD *)(result + 7304) = 0u;
    *(_OWORD *)(result + 7256) = 0u;
    *(_OWORD *)(result + 7272) = 0u;
    *(_OWORD *)(result + 7224) = 0u;
    *(_OWORD *)(result + 7240) = 0u;
    *(_OWORD *)(result + 7192) = 0u;
    *(_OWORD *)(result + 7208) = 0u;
    *(_OWORD *)(result + 7160) = 0u;
    *(_OWORD *)(result + 7176) = 0u;
    *(_OWORD *)(result + 7128) = 0u;
    *(_OWORD *)(result + 7144) = 0u;
    *(_OWORD *)(result + 7096) = 0u;
    *(_OWORD *)(result + 7112) = 0u;
    *(_OWORD *)(result + 7080) = 0u;
    *(_QWORD *)(result + 7952) = 0;
    *(_OWORD *)(result + 7920) = 0u;
    *(_OWORD *)(result + 7936) = 0u;
    *(_OWORD *)(result + 7888) = 0u;
    *(_OWORD *)(result + 7904) = 0u;
    *(_OWORD *)(result + 7856) = 0u;
    *(_OWORD *)(result + 7872) = 0u;
    *(_OWORD *)(result + 7824) = 0u;
    *(_OWORD *)(result + 7840) = 0u;
    *(_OWORD *)(result + 7792) = 0u;
    *(_OWORD *)(result + 7808) = 0u;
    *(_OWORD *)(result + 7760) = 0u;
    *(_OWORD *)(result + 7776) = 0u;
    *(_OWORD *)(result + 7728) = 0u;
    *(_OWORD *)(result + 7744) = 0u;
    *(_OWORD *)(result + 7696) = 0u;
    *(_OWORD *)(result + 7712) = 0u;
    *(_OWORD *)(result + 7664) = 0u;
    *(_OWORD *)(result + 7680) = 0u;
    *(_OWORD *)(result + 7632) = 0u;
    *(_OWORD *)(result + 7648) = 0u;
    *(_OWORD *)(result + 7600) = 0u;
    *(_OWORD *)(result + 7616) = 0u;
    *(_OWORD *)(result + 7568) = 0u;
    *(_OWORD *)(result + 7584) = 0u;
    *(_OWORD *)(result + 7536) = 0u;
    *(_OWORD *)(result + 7552) = 0u;
    *(_OWORD *)(result + 7520) = 0u;
    *(_DWORD *)(result + 7080) = 1;
    *(_DWORD *)(result + 7200) = *(_DWORD *)(result + 200);
    *(_WORD *)(result + 7210) = *(_WORD *)(result + 192);
    *(_DWORD *)(result + 7520) = 1;
    pthread_mutex_init((pthread_mutex_t *)(result + 7088), 0);
    pthread_cond_init((pthread_cond_t *)(v2 + 7152), 0);
    pthread_mutex_init((pthread_mutex_t *)(v2 + 7528), 0);
    pthread_cond_init((pthread_cond_t *)(v2 + 7592), 0);
    pthread_mutex_init((pthread_mutex_t *)(v2 + 7368), 0);
    pthread_mutex_init((pthread_mutex_t *)(v2 + 7808), 0);
    *(_DWORD *)(v2 + 7456) = 0;
    *(_DWORD *)(v2 + 7896) = 0;
    *(_OWORD *)(v2 + 7960) = 0u;
    *(_OWORD *)(v2 + 7976) = 0u;
    *(_OWORD *)(v2 + 7992) = 0u;
    *(_OWORD *)(v2 + 8008) = 0u;
    *(_OWORD *)(v2 + 8024) = 0u;
    *(_OWORD *)(v2 + 8040) = 0u;
    *(_OWORD *)(v2 + 8056) = 0u;
    *(_OWORD *)(v2 + 8072) = 0u;
    *(_OWORD *)(v2 + 8088) = 0u;
    *(_OWORD *)(v2 + 8104) = 0u;
    *(_OWORD *)(v2 + 8120) = 0u;
    *(_OWORD *)(v2 + 8136) = 0u;
    *(_OWORD *)(v2 + 8152) = 0u;
    *(_OWORD *)(v2 + 8168) = 0u;
    *(_OWORD *)(v2 + 8184) = 0u;
    *(_OWORD *)(v2 + 8200) = 0u;
    *(_OWORD *)(v2 + 8216) = 0u;
    *(_OWORD *)(v2 + 8232) = 0u;
    *(_OWORD *)(v2 + 8248) = 0u;
    *(_OWORD *)(v2 + 8264) = 0u;
    *(_OWORD *)(v2 + 8280) = 0u;
    *(_OWORD *)(v2 + 8296) = 0u;
    *(_OWORD *)(v2 + 8312) = 0u;
    *(_OWORD *)(v2 + 8328) = 0u;
    *(_OWORD *)(v2 + 8344) = 0u;
    *(_OWORD *)(v2 + 8360) = 0u;
    *(_OWORD *)(v2 + 8376) = 0u;
    *(_QWORD *)(v2 + 8392) = 0;
    *(_QWORD *)(v2 + 8832) = 0;
    *(_OWORD *)(v2 + 8800) = 0u;
    *(_OWORD *)(v2 + 8816) = 0u;
    *(_OWORD *)(v2 + 8768) = 0u;
    *(_OWORD *)(v2 + 8784) = 0u;
    *(_OWORD *)(v2 + 8736) = 0u;
    *(_OWORD *)(v2 + 8752) = 0u;
    *(_OWORD *)(v2 + 8704) = 0u;
    *(_OWORD *)(v2 + 8720) = 0u;
    *(_OWORD *)(v2 + 8672) = 0u;
    *(_OWORD *)(v2 + 8688) = 0u;
    *(_OWORD *)(v2 + 8640) = 0u;
    *(_OWORD *)(v2 + 8656) = 0u;
    *(_OWORD *)(v2 + 8608) = 0u;
    *(_OWORD *)(v2 + 8624) = 0u;
    *(_OWORD *)(v2 + 8576) = 0u;
    *(_OWORD *)(v2 + 8592) = 0u;
    *(_OWORD *)(v2 + 8544) = 0u;
    *(_OWORD *)(v2 + 8560) = 0u;
    *(_OWORD *)(v2 + 8512) = 0u;
    *(_OWORD *)(v2 + 8528) = 0u;
    *(_OWORD *)(v2 + 8480) = 0u;
    *(_OWORD *)(v2 + 8496) = 0u;
    *(_OWORD *)(v2 + 8448) = 0u;
    *(_OWORD *)(v2 + 8464) = 0u;
    *(_OWORD *)(v2 + 8416) = 0u;
    *(_OWORD *)(v2 + 8432) = 0u;
    *(_OWORD *)(v2 + 8400) = 0u;
    *(_DWORD *)(v2 + 7960) = 1;
    *(_DWORD *)(v2 + 8400) = 1;
    *(_DWORD *)(v2 + 8080) = *(_DWORD *)(v2 + 200);
    pthread_mutex_init((pthread_mutex_t *)(v2 + 7968), 0);
    pthread_cond_init((pthread_cond_t *)(v2 + 8032), 0);
    pthread_mutex_init((pthread_mutex_t *)(v2 + 8408), 0);
    pthread_cond_init((pthread_cond_t *)(v2 + 8472), 0);
    pthread_mutex_init((pthread_mutex_t *)(v2 + 8248), 0);
    pthread_mutex_init((pthread_mutex_t *)(v2 + 8688), 0);
    v0 = 0;
    *(_DWORD *)(v2 + 8336) = 0;
    *(_DWORD *)(v2 + 8776) = 0;
    goto LABEL_10;
  }
  __break(0x5519u);
  return result;
}

void SRTPUseEncryption(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, unsigned int a6)
{
  _DWORD *v11;
  _DWORD *v12;
  _DWORD *v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  size_t v28;
  int64_t v29;
  void *v30;
  uint64_t v31;
  _BYTE *v32;
  int64_t v33;
  size_t v34;
  size_t v35;
  size_t v36;
  size_t v37;
  BOOL BoolValueForKey;
  uint64_t v39;
  uint64_t v40;
  _DWORD *v41;
  _DWORD *v42;
  _DWORD *v43;
  _DWORD *v44;
  uint64_t *v45;
  size_t v46;
  _BYTE *v47;
  _BYTE *v48;
  __int128 v49;
  __int128 v50;
  int v51;
  __int128 v52;
  __int128 v53;
  int v54;
  _QWORD v55[2];
  _QWORD v56[4];

  v56[2] = *MEMORY[0x1E0C80C00];
  if (a6 >= 3)
    return;
  v11 = (_DWORD *)CheckInHandleDebug();
  if (!v11)
    return;
  v12 = v11;
  if (v11 == (_DWORD *)0xFFFFFFFFLL)
    return;
  if (v11[1770] && v11[1880] && v11[1990] && v11[2100])
  {
    v13 = v11 + 6904;
    v54 = -1431655766;
    *(_QWORD *)&v14 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v52 = v14;
    v53 = v14;
    v51 = -1431655766;
    v49 = v14;
    v50 = v14;
    setTransformPolicyFromCipherSuite(a4, (uint64_t)&v52, a6 == 2);
    setTransformPolicyFromCipherSuite(a5, (uint64_t)&v49, a6 == 2);
    v15 = v53;
    *((_OWORD *)v12 + 467) = v52;
    *((_OWORD *)v12 + 468) = v15;
    v12[1876] = v54;
    v12[1877] = a6;
    if (v12 >= v13)
      goto LABEL_53;
    v16 = *(_QWORD *)(v12 + 1869);
    *((_QWORD *)v12 + 904) = v16;
    v17 = (uint64_t)(v12 + 1770);
    v18 = (uint64_t)(v12 + 1880);
    v12[1986] = v54;
    v19 = (uint64_t)(v12 + 1990);
    v20 = (uint64_t)(v12 + 2100);
    v21 = v53;
    *(_OWORD *)(v12 + 1978) = v52;
    *(_OWORD *)(v12 + 1982) = v21;
    v12[1987] = a6;
    v22 = *(_QWORD *)(v12 + 1979);
    *((_QWORD *)v12 + 959) = v22;
    v23 = v50;
    *((_OWORD *)v12 + 522) = v49;
    v24 = v49;
    *((_OWORD *)v12 + 523) = v50;
    v25 = v51;
    v12[2096] = v51;
    v12[2097] = a6;
    v26 = *(_QWORD *)(v12 + 2089);
    *((_QWORD *)v12 + 1014) = v26;
    v12[2206] = v25;
    *(_OWORD *)(v12 + 2198) = v24;
    *(_OWORD *)(v12 + 2202) = v23;
    v12[2207] = a6;
    v27 = *(_QWORD *)(v12 + 2199);
    *((_QWORD *)v12 + 1069) = v27;
    if (!(a5 | a4))
    {
LABEL_52:
      v39 = v19;
      v40 = v18;
      SRTPInitializedEncryption(v17, 1);
      SRTPInitializedEncryption(v40, 0);
      SRTPInitializedEncryption(v39, 1);
      SRTPInitializedEncryption(v20, 0);
      CheckOutHandleDebug();
      return;
    }
    if (a2 && a3)
    {
      v44 = v12 + 1770;
      v42 = v12 + 1880;
      v43 = v12 + 1990;
      v41 = v12 + 2100;
      v45 = (uint64_t *)&v41;
      if ((int)v16 <= (int)v26)
        v28 = v26;
      else
        v28 = v16;
      if ((int)v22 <= (int)v27)
        v29 = v27;
      else
        v29 = v22;
      v30 = (void *)MEMORY[0x1E0C80A78](v17);
      v32 = (char *)&v41 - v31;
      if ((_DWORD)v28)
        v30 = memset((char *)&v41 - v31, 170, v28);
      v48 = v32;
      v46 = v28;
      MEMORY[0x1E0C80A78](v30);
      memset(v56, 170, 14);
      if ((_DWORD)v29)
        memset((char *)&v41 - ((v29 + 15) & 0x1FFFFFFF0), 170, v29);
      v47 = (char *)&v41 - ((v29 + 15) & 0x1FFFFFFF0);
      memset(v55, 170, 14);
      v33 = v46;
      if ((v46 & 0x80000000) != 0)
        goto LABEL_53;
      HexToByte(v48, v46, (char *)a2, 65);
      HexToByte(v56, 14, (char *)(a2 + 65), 29);
      if ((v29 & 0x80000000) != 0)
        goto LABEL_53;
      HexToByte(v47, v29, (char *)a3, 65);
      HexToByte(v55, 14, (char *)(a3 + 65), 29);
      if (!a4)
        goto LABEL_43;
      v34 = v12[1808];
      if ((v34 & 0x80000000) != 0 || (int)v34 > v33)
        goto LABEL_53;
      if (SRTPUseEncryptionInternal((uint64_t)v44, v48, v34, v56, *(void **)(a2 + 96), 1))
        goto LABEL_50;
      v35 = v12[1918];
      if ((v35 & 0x80000000) != 0 || (int)v35 > v29)
        goto LABEL_53;
      if (!SRTPUseEncryptionInternal((uint64_t)v42, v47, v35, v55, *(void **)(a3 + 96), 1))
      {
LABEL_43:
        if (!a5)
        {
LABEL_51:
          BoolValueForKey = VCDefaults_GetBoolValueForKey(CFSTR("enableEncryptionDebug"), 0);
          *((_BYTE *)v12 + 7512) = BoolValueForKey;
          *((_BYTE *)v12 + 7952) = BoolValueForKey;
          v20 = (uint64_t)v41;
          v19 = (uint64_t)v43;
          v18 = (uint64_t)v42;
          v17 = (uint64_t)v44;
          goto LABEL_52;
        }
        v36 = v12[2028];
        if ((v36 & 0x80000000) != 0 || (int)v36 > v33)
        {
LABEL_53:
          __break(0x5519u);
          return;
        }
        if (!SRTPUseEncryptionInternal((uint64_t)v43, v48, v36, v56, *(void **)(a2 + 96), 0))
        {
          v37 = v12[2138];
          if ((v37 & 0x80000000) == 0 && (int)v37 <= v29)
          {
            if (SRTPUseEncryptionInternal((uint64_t)v41, v47, v37, v55, *(void **)(a3 + 96), 0))
              goto LABEL_50;
            goto LABEL_51;
          }
          goto LABEL_53;
        }
      }
LABEL_50:
      CheckOutHandleDebug();
      return;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SRTPUseEncryption_cold_2();
    }
    CheckOutHandleDebug();
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SRTPUseEncryption_cold_1();
    }
    CheckOutHandleDebug();
  }
}

uint64_t SRTPUseEncryptionInternal(uint64_t result, const void *a2, size_t __n, _QWORD *a4, void *a5, int a6)
{
  unsigned int v9;
  uint64_t v11;
  uint64_t v12;
  int v13;
  BOOL v14;
  char v15;
  char v16;
  char v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;

  if (__n >= 0x21)
    goto LABEL_24;
  v9 = __n;
  v11 = result;
  memcpy((void *)(result + 160), a2, __n);
  v12 = *(_QWORD *)((char *)a4 + 6);
  *(_QWORD *)(v11 + 192) = *a4;
  *(_QWORD *)(v11 + 198) = v12;
  pthread_mutex_lock((pthread_mutex_t *)(v11 + 288));
  VCMediaKeyIndex_ReleaseAndCopyNewValue((const void **)(v11 + 352), a5);
  result = pthread_mutex_unlock((pthread_mutex_t *)(v11 + 288));
  v13 = *(_DWORD *)(v11 + 428);
  v14 = a6 == 0;
  if (a6)
    v15 = 1;
  else
    v15 = 4;
  if (v14)
    v16 = 5;
  else
    v16 = 2;
  if (v14)
    v17 = 3;
  else
    v17 = 0;
  if (*(_DWORD *)(v11 + 392))
  {
    v18 = *(_DWORD *)(v11 + 400);
    if (v18 > 0x20 || a2 && !v9)
      goto LABEL_24;
    result = (uint64_t)MakeSessionKey(v13 == 2, a2, v9, (uint64_t)a4, v17, (void *)(v11 + 206), v18);
    v19 = *(_DWORD *)(v11 + 404);
    if (v19 > 0xE)
      goto LABEL_24;
    MakeSessionKey(v13 == 2, a2, v9, (uint64_t)a4, v16, (void *)(v11 + 238), v19);
    result = SRTPInitCrypt(v11, (const void *)(v11 + 206));
    if ((result & 0x80000000) != 0)
      return result;
  }
  if (*(_DWORD *)(v11 + 408))
  {
    v20 = *(_DWORD *)(v11 + 412);
    if (v20 <= 0x20 && (!a2 || v9))
    {
      MakeSessionKey(v13 == 2, a2, v9, (uint64_t)a4, v15, (void *)(v11 + 252), v20);
      return 0;
    }
LABEL_24:
    __break(0x5519u);
    return result;
  }
  return 0;
}

uint64_t SRTPInitializedEncryption(uint64_t a1, int a2)
{
  pthread_mutex_t *v4;
  int v5;

  v4 = (pthread_mutex_t *)(a1 + 8);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  if (a2)
    v5 = 10;
  else
    v5 = 12;
  *(_DWORD *)a1 |= v5;
  pthread_cond_broadcast((pthread_cond_t *)(a1 + 72));
  return pthread_mutex_unlock(v4);
}

uint64_t _SRTPUpdateEncryption(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t v6;
  _OWORD v8[6];
  const void *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  const void *v16[2];

  v16[1] = *(const void **)MEMORY[0x1E0C80C00];
  v2 = 2147549186;
  if (a1)
  {
    if (a1 == 0xFFFFFFFFLL)
      return 2147549190;
    if (*(_DWORD *)(a1 + 7080) && *(_DWORD *)(a1 + 7520) && *(_DWORD *)(a1 + 7960) && *(_DWORD *)(a1 + 8400))
    {
      v16[0] = 0;
      v14 = 0u;
      v15 = 0u;
      v12 = 0u;
      v13 = 0u;
      v10 = 0u;
      v11 = 0u;
      v9 = 0;
      memset(v8, 0, sizeof(v8));
      SRTPDeriveMediaKeyInfo(a1 + 7080, (unint64_t)&v10, a2);
      if (!(_DWORD)v5)
      {
        os_unfair_lock_lock((os_unfair_lock_t)(a1 + 8844));
        if (!*(_BYTE *)(a1 + 8840))
        {
          *(_DWORD *)(a1 + 7640) = *(_DWORD *)(a1 + 4832);
          *(_BYTE *)(a1 + 8840) = 1;
        }
        SRTPDeriveMediaKeyInfo(a1 + 7520, (unint64_t)v8, a2);
        v2 = v6;
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 8844));
        if ((_DWORD)v2)
          goto LABEL_25;
        if (!*(_DWORD *)(a1 + 7472) || (v5 = SRTPUpdateEncryptionInfo(a1 + 7080, (uint64_t)&v10, 1), !(_DWORD)v5))
        {
          if (!*(_DWORD *)(a1 + 7912) || (v5 = SRTPUpdateEncryptionInfo(a1 + 7520, (uint64_t)v8, 1), !(_DWORD)v5))
          {
            if (!*(_DWORD *)(a1 + 8352) || (v5 = SRTPUpdateEncryptionInfo(a1 + 7960, (uint64_t)&v10, 0), !(_DWORD)v5))
            {
              if (!*(_DWORD *)(a1 + 8792))
              {
                v2 = 0;
                goto LABEL_25;
              }
              v5 = SRTPUpdateEncryptionInfo(a1 + 8400, (uint64_t)v8, 0);
            }
          }
        }
      }
      v2 = v5;
LABEL_25:
      VCMediaKeyIndex_Release((const void **)(a2 + 144));
      VCMediaKeyIndex_Release(v16);
      v16[0] = 0;
      v14 = 0u;
      v15 = 0u;
      v12 = 0u;
      v13 = 0u;
      v10 = 0u;
      v11 = 0u;
      VCMediaKeyIndex_Release(&v9);
      return v2;
    }
    v2 = 2149711928;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _SRTPUpdateEncryption_cold_1();
    }
  }
  return v2;
}

uint64_t SRTPUpdateKeyMaterialForRTPInfo(uint64_t a1, const __CFDictionary *a2)
{
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  int v8;
  uint64_t v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  int v13;
  _OWORD v14[9];
  const void *v15[2];

  v15[1] = *(const void **)MEMORY[0x1E0C80C00];
  v15[0] = 0;
  memset(v14, 0, sizeof(v14));
  SRTPGetKeyDerivationCryptoSet((unint64_t)v14, a2);
  if ((_DWORD)v3)
  {
    v6 = v3;
    _SRTPCancelEncryption(a1);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SRTPUpdateKeyMaterialForRTPInfo_cold_2();
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v4 = VRTraceErrorLogLevelToCSTR();
      v5 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v8 = 136315650;
        v9 = v4;
        v10 = 2080;
        v11 = "SRTPUpdateKeyMaterialForRTPInfo";
        v12 = 1024;
        v13 = 941;
        _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Configuring Crypto Set", (uint8_t *)&v8, 0x1Cu);
      }
    }
    v6 = _SRTPUpdateEncryption(a1, (uint64_t)v14);
    if ((_DWORD)v6)
    {
      _SRTPCancelEncryption(a1);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          SRTPUpdateKeyMaterialForRTPInfo_cold_1();
      }
    }
  }
  VCMediaKeyIndex_Release(v15);
  return v6;
}

void SRTPGetKeyDerivationCryptoSet(unint64_t a1, CFDictionaryRef theDict)
{
  const __CFData *Value;
  const __CFData *v5;
  const __CFData *v7;
  void *v8;
  unsigned int Length;
  CFIndex ErrorLogLevelForModule;
  unsigned int v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  NSObject *v15;
  void *v16;
  uint64_t v17;
  void *v18;
  uint8_t buf[4];
  uint64_t v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  int v26;
  __int16 v27;
  unsigned int v28;
  uint64_t v29;
  CFRange v30;
  CFRange v31;

  v29 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    Value = (const __CFData *)CFDictionaryGetValue(theDict, CFSTR("SecurityKey"));
    v5 = (const __CFData *)CFDictionaryGetValue(theDict, CFSTR("SecuritySalt"));
    if (Value && v5 != 0)
    {
      v7 = v5;
      v8 = (void *)CFDictionaryGetValue(theDict, CFSTR("SecurityKeyIndex"));
      if ((CFDataGetLength(Value) & 0xFFFFFFE0) != 0)
        Length = 32;
      else
        Length = CFDataGetLength(Value);
      ErrorLogLevelForModule = CFDataGetLength(v7);
      v18 = v8;
      if ((ErrorLogLevelForModule & 0xFFFFFFE0) != 0)
      {
        v11 = 32;
      }
      else
      {
        ErrorLogLevelForModule = CFDataGetLength(v7);
        v11 = ErrorLogLevelForModule;
      }
      if ((int)Length > 32)
      {
        ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
        if ((int)ErrorLogLevelForModule >= 7)
        {
          v12 = VRTraceErrorLogLevelToCSTR();
          v13 = *MEMORY[0x1E0CF2758];
          ErrorLogLevelForModule = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
          if ((_DWORD)ErrorLogLevelForModule)
          {
            *(_DWORD *)buf = 136316162;
            v20 = v12;
            v21 = 2080;
            v22 = "SRTPGetKeyDerivationCryptoSet";
            v23 = 1024;
            v24 = 110;
            v25 = 1024;
            v26 = 32;
            v27 = 1024;
            v28 = Length;
            _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Oversize member key length (limit=%d, given=%d)", buf, 0x28u);
          }
        }
      }
      if ((int)v11 >= 33)
      {
        ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
        if ((int)ErrorLogLevelForModule >= 7)
        {
          v14 = VRTraceErrorLogLevelToCSTR();
          v15 = *MEMORY[0x1E0CF2758];
          ErrorLogLevelForModule = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
          if ((_DWORD)ErrorLogLevelForModule)
          {
            *(_DWORD *)buf = 136316162;
            v20 = v14;
            v21 = 2080;
            v22 = "SRTPGetKeyDerivationCryptoSet";
            v23 = 1024;
            v24 = 113;
            v25 = 1024;
            v26 = 32;
            v27 = 1024;
            v28 = v11;
            _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Oversize member salt length (limit=%d, given=%d)", buf, 0x28u);
          }
        }
      }
      v16 = (void *)MEMORY[0x1E0C80A78](ErrorLogLevelForModule);
      if (Length)
        v16 = memset((char *)&v17 - ((Length + 15) & 0x1FFFFFFF0), 170, Length);
      MEMORY[0x1E0C80A78](v16);
      if (v11)
        memset((char *)&v17 - ((v11 + 15) & 0x1FFFFFFF0), 170, v11);
      v30.location = 0;
      v30.length = Length;
      CFDataGetBytes(Value, v30, (UInt8 *)&v17 - ((Length + 15) & 0x1FFFFFFF0));
      v31.location = 0;
      v31.length = v11;
      CFDataGetBytes(v7, v31, (UInt8 *)&v17 - ((v11 + 15) & 0x1FFFFFFF0));
      if ((Length & 0x80000000) != 0
        || (*(_DWORD *)(a1 + 68) = ByteToHex(a1, 65, (unsigned __int8 *)&v17 - ((Length + 15) & 0x1FFFFFFF0), Length), (v11 & 0x80000000) != 0))
      {
        __break(0x5519u);
      }
      else
      {
        *(_DWORD *)(a1 + 140) = ByteToHex(a1 + 72, 65, (unsigned __int8 *)&v17 - ((v11 + 15) & 0x1FFFFFFF0), v11);
        VCMediaKeyIndex_ReleaseAndCopyNewValue((const void **)(a1 + 144), v18);
      }
    }
  }
}

void _SRTPCancelEncryption(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a1 && a1 != 0xFFFFFFFFLL)
  {
    if (*(_DWORD *)(a1 + 7080) && *(_DWORD *)(a1 + 7520))
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 7088));
      *(_DWORD *)(a1 + 7084) = 1;
      pthread_cond_broadcast((pthread_cond_t *)(a1 + 7152));
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 7088));
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 7528));
      *(_DWORD *)(a1 + 7524) = 1;
      pthread_cond_broadcast((pthread_cond_t *)(a1 + 7592));
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 7528));
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v2 = VRTraceErrorLogLevelToCSTR();
        v3 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v4 = 136315650;
          v5 = v2;
          v6 = 2080;
          v7 = "_SRTPCancelEncryption";
          v8 = 1024;
          v9 = 928;
          _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Canceld SRTP encryption", (uint8_t *)&v4, 0x1Cu);
        }
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _SRTPCancelEncryption_cold_1();
    }
  }
}

uint64_t SRTPUpdateKeyMaterial(uint64_t a1, const __CFDictionary *a2)
{
  uint64_t v3;
  uint64_t v4;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149711873;
  v4 = SRTPUpdateKeyMaterialForRTPInfo(v3, a2);
  CheckOutHandleDebug();
  return v4;
}

uint64_t SRTPUpdateEncryptionInfo(uint64_t a1, uint64_t a2, int a3)
{
  _BOOL8 isValid;
  size_t v7;
  uint64_t result;
  uint64_t v9;
  void *v10;
  _QWORD v11[3];

  v11[2] = *MEMORY[0x1E0C80C00];
  isValid = VCMediaKeyIndex_isValid(*(_QWORD **)(a2 + 96));
  if (!isValid)
  {
    v9 = 2149711873;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SRTPUpdateEncryptionInfo_cold_1();
    }
    return v9;
  }
  v7 = *(unsigned int *)(a1 + 152);
  MEMORY[0x1E0C80A78](isValid);
  if ((_DWORD)v7)
    memset((char *)&v11[-1] - ((v7 + 15) & 0x1FFFFFFF0), 170, v7);
  v10 = 0;
  memset(v11, 170, 14);
  result = VCMediaKeyIndex_ReleaseAndCopyNewValue((const void **)&v10, *(void **)(a2 + 96));
  if ((v7 & 0x80000000) == 0)
  {
    HexToByte((_BYTE *)&v11[-1] - ((v7 + 15) & 0x1FFFFFFF0), v7, (char *)a2, 65);
    HexToByte(v11, 14, (char *)(a2 + 65), 29);
    v9 = SRTPUseEncryptionInternal(a1, (char *)&v11[-1] - ((v7 + 15) & 0x1FFFFFFF0), v7, v11, v10, a3);
    VCMediaKeyIndex_Release((const void **)&v10);
    return v9;
  }
  __break(0x5519u);
  return result;
}

void SRTPDeriveMediaKeyInfo(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v4;
  size_t v7;
  void *v8;
  uint64_t v9;
  _BYTE *v10;
  unsigned int v11;
  int v12;
  int v13;
  size_t v14;
  uint64_t v15;
  char *v16;
  unsigned int v17;
  unsigned int v18;
  int64_t v19;
  uint64_t v20;
  char *v21;
  int v22;
  unsigned __int8 *v23;
  _QWORD v24[2];
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (!a2)
    return;
  if (!a3)
    return;
  v4 = *(unsigned int *)(a3 + 68);
  if ((int)v4 > 65 || (int)v4 < 1 || (*(_DWORD *)(a3 + 140) - 66) < 0xFFFFFFBF)
    return;
  v24[1] = v24;
  v7 = v4 >> 1;
  v8 = (void *)MEMORY[0x1E0C80A78](a1);
  v10 = (char *)v24 - v9;
  if (v11 >= 2)
    v8 = memset((char *)v24 - v9, 170, v7);
  v12 = *(_DWORD *)(a3 + 140);
  if (v12 >= 0)
    v13 = *(_DWORD *)(a3 + 140);
  else
    v13 = v12 + 1;
  v14 = (v13 >> 1);
  MEMORY[0x1E0C80A78](v8);
  v16 = (char *)v24 - v15;
  if ((v12 + 1) >= 3)
    memset(v16, 170, v14);
  v17 = *(_DWORD *)(a3 + 68);
  if (v17 >= 0x42 || (HexToByte(v10, v7, (char *)a3, v17), v12 < -1) || (v18 = *(_DWORD *)(a3 + 140), v18 > 0x41))
  {
LABEL_29:
    __break(0x5519u);
    return;
  }
  HexToByte(v16, v14, (char *)(a3 + 72), v18);
  v25 = *(_DWORD *)(a1 + 120);
  v19 = (*(_DWORD *)(a1 + 152) + 14);
  MEMORY[0x1E0C80A78](v20);
  v21 = (char *)v24 - ((v19 + 15) & 0x1FFFFFFF0);
  if ((_DWORD)v19)
    memset((char *)v24 - ((v19 + 15) & 0x1FFFFFFF0), 170, v19);
  if (!CCKeyDerivationHMac())
  {
    v22 = *(_DWORD *)(a1 + 152);
    if ((v22 & 0x80000000) == 0 && v22 <= v19)
    {
      ByteToHex(a2, 65, (unsigned __int8 *)v24 - ((v19 + 15) & 0x1FFFFFFF0), v22);
      v23 = (unsigned __int8 *)&v21[*(int *)(a1 + 152)];
      if (&v21[v19] >= (char *)v23 && v21 <= (char *)v23 && v19 - *(int *)(a1 + 152) >= 14)
      {
        ByteToHex(a2 + 65, 29, v23, 14);
        VCMediaKeyIndex_ReleaseAndCopyNewValue((const void **)(a2 + 96), *(void **)(a3 + 144));
        return;
      }
    }
    goto LABEL_29;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      SRTPDeriveMediaKeyInfo_cold_1();
  }
}

uint64_t SRTPEncryptData(uint64_t a1)
{
  uint64_t v1;
  int v2;
  unsigned int v3;
  unsigned __int8 *v4;
  int v5;
  unsigned int v6;
  unsigned __int8 *v7;
  unsigned int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  uint64_t v14;
  unsigned int v15;
  unsigned int v16;
  int16x8_t v17;
  int16x8_t v18;
  unsigned int v19;
  unint64_t v20;
  uint64_t v21;
  NSObject *v22;
  NSObject *v23;
  uint64_t v24;
  NSObject *v25;
  const char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  NSObject *v30;
  NSObject *v31;
  size_t v33;
  unsigned int v34;
  _BYTE iv[14];
  __int16 v36;
  _BYTE v37[22];
  __int16 v38;
  int v39;
  __int16 v40;
  uint8_t *v41;
  __int16 v42;
  unsigned int v43;
  uint8_t buf[4008];
  uint64_t v45;

  v1 = MEMORY[0x1E0C80A78](a1);
  v45 = *MEMORY[0x1E0C80C00];
  v34 = 0;
  v33 = 0;
  v36 = 0;
  if (v5 < 0)
    return 2149711873;
  v6 = v5;
  v7 = v4;
  v8 = v3;
  v9 = v2;
  v10 = v1;
  if (!g_fReportFirstCounter)
    goto LABEL_10;
  memset(v37, 170, 17);
  ByteToHex((unint64_t)v37, 17, v4, v5);
  if ((int)VRTraceGetErrorLogLevelForModule() < 8)
    goto LABEL_10;
  v11 = VRTraceErrorLogLevelToCSTR();
  v12 = *MEMORY[0x1E0CF2758];
  v13 = *MEMORY[0x1E0CF2758];
  if (!*MEMORY[0x1E0CF2748])
  {
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      SRTPEncryptData_cold_5();
      if (v9)
        goto LABEL_11;
      goto LABEL_13;
    }
LABEL_10:
    if (v9)
      goto LABEL_11;
LABEL_13:
    v8 = *(_DWORD *)(v10 + 368);
    v15 = HIWORD(v8);
    v34 = HIWORD(v8);
    goto LABEL_14;
  }
  if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    goto LABEL_10;
  *(_DWORD *)buf = 136315906;
  *(_QWORD *)&buf[4] = v11;
  *(_WORD *)&buf[12] = 2080;
  *(_QWORD *)&buf[14] = "SRTPEncryptData";
  *(_WORD *)&buf[22] = 1024;
  *(_DWORD *)&buf[24] = 1057;
  *(_WORD *)&buf[28] = 2080;
  *(_QWORD *)&buf[30] = v37;
  _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d SRTPEncryptData: In=[%s]", buf, 0x26u);
  if (!v9)
    goto LABEL_13;
LABEL_11:
  SRTPGetROC(v10, v8, (int *)&v34, 1);
  v15 = v34;
LABEL_14:
  v16 = *(_DWORD *)(v10 + 120);
  *(_QWORD *)&iv[6] = *(_QWORD *)(v10 + 244);
  *(_QWORD *)iv = *(_QWORD *)(v10 + 238);
  *(uint32x2_t *)v17.i8 = vshl_u32((uint32x2_t)vdup_n_s32(v16), (uint32x2_t)0xFFFFFFF0FFFFFFE8);
  *(uint32x2_t *)v18.i8 = vshl_u32((uint32x2_t)vdup_n_s32(v15), (uint32x2_t)0xFFFFFFF0FFFFFFE8);
  v17.i32[2] = v16 >> 8;
  v17.i32[3] = v16;
  v18.i32[2] = v15 >> 8;
  v18.i32[3] = v15;
  *(int8x8_t *)&iv[4] = veor_s8(*(int8x8_t *)&iv[4], vmovn_s16(vuzp1q_s16(v17, v18)));
  iv[13] ^= v8;
  v36 = 0;
  v19 = *(_DWORD *)(v10 + 428);
  if (v19 >= 3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SRTPEncryptData_cold_4();
    }
    LOBYTE(v20) = 8;
  }
  else
  {
    v20 = 0x800080001uLL >> (16 * v19);
  }
  iv[12] ^= (unsigned __int16)v8 >> v20;
  if (g_fReportFirstCounter)
  {
    memset(buf, 170, 0xFA0uLL);
    --g_fReportFirstCounter;
    ByteToHex((unint64_t)buf, 4000, iv, 16);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v21 = VRTraceErrorLogLevelToCSTR();
      v22 = *MEMORY[0x1E0CF2758];
      v23 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v37 = 136316162;
          *(_QWORD *)&v37[4] = v21;
          *(_WORD *)&v37[12] = 2080;
          *(_QWORD *)&v37[14] = "MakeCounter";
          v38 = 1024;
          v39 = 417;
          v40 = 2080;
          v41 = buf;
          v42 = 1024;
          v43 = v15;
          _os_log_impl(&dword_1D8A54000, v22, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d   counters: [%s], ROC=%d", v37, 0x2Cu);
        }
      }
      else if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)v37 = 136316162;
        *(_QWORD *)&v37[4] = v21;
        *(_WORD *)&v37[12] = 2080;
        *(_QWORD *)&v37[14] = "MakeCounter";
        v38 = 1024;
        v39 = 417;
        v40 = 2080;
        v41 = buf;
        v42 = 1024;
        v43 = v15;
        _os_log_debug_impl(&dword_1D8A54000, v22, OS_LOG_TYPE_DEBUG, " [%s] %s:%d   counters: [%s], ROC=%d", v37, 0x2Cu);
      }
    }
  }
  if (*(_BYTE *)(v10 + 432))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v24 = VRTraceErrorLogLevelToCSTR();
      v25 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v26 = VCMediaKeyIndex_Description(*(void **)(v10 + 360));
        *(_DWORD *)buf = 136316418;
        *(_QWORD *)&buf[4] = v24;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "SRTPEncryptData";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 1070;
        *(_WORD *)&buf[28] = 2080;
        *(_QWORD *)&buf[30] = v26;
        *(_WORD *)&buf[38] = 2048;
        *(_QWORD *)&buf[40] = v15;
        *(_WORD *)&buf[48] = 1024;
        *(_DWORD *)&buf[50] = (unsigned __int16)v8;
        _os_log_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d SRTPEncData: MKI=%s, ROC==%08lX, SEQ==%u):", buf, 0x36u);
      }
    }
  }
  os_unfair_lock_lock((os_unfair_lock_t)(v10 + 376));
  v27 = CCCryptorReset(*(CCCryptorRef *)(v10 + 384), iv);
  if ((_DWORD)v27)
  {
    v14 = v27;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SRTPEncryptData_cold_3();
    }
  }
  else
  {
    v28 = CCCryptorUpdate(*(CCCryptorRef *)(v10 + 384), v7, v6, v7, v6, &v33);
    if ((_DWORD)v28)
    {
      v14 = v28;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          SRTPEncryptData_cold_2();
      }
    }
    else
    {
      if (g_fReportFirstCounter)
      {
        memset(v37, 170, 17);
        ByteToHex((unint64_t)v37, 17, v7, v6);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          v29 = VRTraceErrorLogLevelToCSTR();
          v30 = *MEMORY[0x1E0CF2758];
          v31 = *MEMORY[0x1E0CF2758];
          if (*MEMORY[0x1E0CF2748])
          {
            if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315906;
              *(_QWORD *)&buf[4] = v29;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "SRTPEncryptData";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 1084;
              *(_WORD *)&buf[28] = 2080;
              *(_QWORD *)&buf[30] = v37;
              _os_log_impl(&dword_1D8A54000, v30, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d SRTPEncryptData: Out=[%s]", buf, 0x26u);
            }
          }
          else if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
          {
            SRTPEncryptData_cold_1();
          }
        }
      }
      v14 = 0;
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(v10 + 376));
  return v14;
}

void SRTPEncrypt(uint64_t a1, int a2, uint64_t a3, int a4)
{
  int v7;
  int v8;
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  const char *v12;
  uint64_t v13;
  unint64_t v14;
  const char *v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  int v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  if ((*(_BYTE *)a1 & 2) == 0 || !*(_DWORD *)(a1 + 392))
    return;
  v7 = *(unsigned __int8 *)(a1 + 432);
  if (!g_fReportFirstCounter)
  {
    if (!*(_BYTE *)(a1 + 432))
      goto LABEL_18;
    v7 = 1;
  }
  if (v7)
    v8 = 7;
  else
    v8 = 8;
  if (v8 <= (int)VRTraceGetErrorLogLevelForModule())
  {
    v9 = VRTraceErrorLogLevelToCSTR();
    if (v7)
    {
      v10 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        goto LABEL_18;
      goto LABEL_15;
    }
    v10 = *MEMORY[0x1E0CF2758];
    v11 = *MEMORY[0x1E0CF2758];
    if (!*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        v15 = VCMediaKeyIndex_Description(*(void **)(a1 + 352));
        v16 = *(unsigned int *)(a1 + 120);
        v17 = 136316418;
        v18 = v9;
        v19 = 2080;
        v20 = "SRTPEncrypt";
        v21 = 1024;
        v22 = 1124;
        v23 = 2080;
        v24 = v15;
        v25 = 2048;
        v26 = v16;
        v27 = 1024;
        v28 = a2;
        _os_log_debug_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEBUG, " [%s] %s:%d SRTPEnc: MKI=%s, SSRC==%08lX, SEQ==%u):", (uint8_t *)&v17, 0x36u);
      }
      goto LABEL_18;
    }
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
LABEL_15:
      v12 = VCMediaKeyIndex_Description(*(void **)(a1 + 352));
      v13 = *(unsigned int *)(a1 + 120);
      v17 = 136316418;
      v18 = v9;
      v19 = 2080;
      v20 = "SRTPEncrypt";
      v21 = 1024;
      v22 = 1124;
      v23 = 2080;
      v24 = v12;
      v25 = 2048;
      v26 = v13;
      v27 = 1024;
      v28 = a2;
      _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d SRTPEnc: MKI=%s, SSRC==%08lX, SEQ==%u):", (uint8_t *)&v17, 0x36u);
    }
  }
LABEL_18:
  v14 = *(_QWORD *)(a1 + 144) + 1;
  *(_QWORD *)(a1 + 144) = v14;
  if (v14 < 0x1000000000001)
  {
    if (a4 < 0)
    {
      __break(0x5519u);
    }
    else if (a4)
    {
      SRTPEncryptData(a1);
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      SRTPEncrypt_cold_1();
  }
}

uint64_t SRTPDecrypt(uint64_t a1, int a2, uint64_t a3, int a4)
{
  int v8;
  int v9;
  uint64_t v10;
  NSObject *v11;
  NSObject *v12;
  const char *v13;
  uint64_t v14;
  const char *v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  int v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  if ((*(_BYTE *)a1 & 4) == 0)
    return 2149711928;
  if (!*(_DWORD *)(a1 + 392))
    return 0;
  v8 = *(unsigned __int8 *)(a1 + 432);
  if (!g_fReportFirstCounter)
  {
    if (!*(_BYTE *)(a1 + 432))
      goto LABEL_19;
    v8 = 1;
  }
  if (v8)
    v9 = 7;
  else
    v9 = 8;
  if (v9 > (int)VRTraceGetErrorLogLevelForModule())
  {
LABEL_19:
    if (a4 < 0)
      goto LABEL_24;
    goto LABEL_20;
  }
  v10 = VRTraceErrorLogLevelToCSTR();
  if (!v8)
  {
    v11 = *MEMORY[0x1E0CF2758];
    v12 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        goto LABEL_16;
    }
    else if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      v15 = VCMediaKeyIndex_Description(*(void **)(a1 + 352));
      v16 = *(unsigned int *)(a1 + 120);
      v17 = 136316418;
      v18 = v10;
      v19 = 2080;
      v20 = "SRTPDecrypt";
      v21 = 1024;
      v22 = 1152;
      v23 = 2080;
      v24 = v15;
      v25 = 2048;
      v26 = v16;
      v27 = 1024;
      v28 = a2;
      _os_log_debug_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEBUG, " [%s] %s:%d SRTPDec: MKI=%s, SSRC==%08lX, SEQ==%u):", (uint8_t *)&v17, 0x36u);
      if (a4 < 0)
        goto LABEL_24;
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  v11 = *MEMORY[0x1E0CF2758];
  if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    goto LABEL_19;
LABEL_16:
  v13 = VCMediaKeyIndex_Description(*(void **)(a1 + 352));
  v14 = *(unsigned int *)(a1 + 120);
  v17 = 136316418;
  v18 = v10;
  v19 = 2080;
  v20 = "SRTPDecrypt";
  v21 = 1024;
  v22 = 1152;
  v23 = 2080;
  v24 = v13;
  v25 = 2048;
  v26 = v14;
  v27 = 1024;
  v28 = a2;
  _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d SRTPDec: MKI=%s, SSRC==%08lX, SEQ==%u):", (uint8_t *)&v17, 0x36u);
  if (a4 < 0)
LABEL_24:
    __break(0x5519u);
LABEL_20:
  if (a4)
    return SRTPEncryptData(a1);
  return 0;
}

uint64_t SRTCPEncrypt(uint64_t result, unint64_t a2, int a3, int a4, _DWORD *a5)
{
  uint64_t v5;
  uint64_t v7;
  int v9;
  unsigned int v10;
  uint64_t v12;
  _DWORD *v13;
  unint64_t v14;

  v5 = 2149711891;
  if ((*(_BYTE *)result & 2) == 0)
    return 2149711928;
  v7 = result;
  if (!*(_DWORD *)(result + 392))
  {
    v5 = 0;
    *a5 = a3;
    return v5;
  }
  v9 = a3 + 4;
  if (a3 + 4 > a4)
    return 2149711873;
  v10 = *(_DWORD *)(result + 368) + 1;
  *(_DWORD *)(result + 368) = v10;
  if (v10 > 0x7FFFFFFE)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SRTCPEncrypt_cold_1();
    }
    return v5;
  }
  if ((a4 & 0x80000000) == 0 && (a3 & 0x80000000) == 0)
  {
    v12 = a3;
    if (a3)
    {
      result = SRTPEncryptData(result);
      v5 = result;
      v10 = *(_DWORD *)(v7 + 368);
    }
    else
    {
      v5 = 0;
    }
    v13 = (_DWORD *)(a2 + v12);
    if (a2 + v12 >= a2)
    {
      v14 = a2 + a4;
      if ((unint64_t)v13 <= v14 && v14 - (unint64_t)v13 >= 4)
      {
        *v13 = bswap32(v10 | 0x80000000);
        *a5 = v9;
        return v5;
      }
    }
  }
  __break(0x5519u);
  return result;
}

uint64_t SRTCPDecrypt(uint64_t result, unint64_t a2, int a3, int *a4)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int *v6;
  unsigned int v7;

  v4 = 2149711880;
  if ((*(_BYTE *)result & 4) == 0)
    return 2149711928;
  if (!*(_DWORD *)(result + 392))
  {
    v4 = 0;
    *a4 = a3;
    return v4;
  }
  if (a3 <= 3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SRTCPDecrypt_cold_1();
    }
    return v4;
  }
  v5 = (a3 - 4);
  v6 = (unsigned int *)(a2 + v5);
  if (a2 + a3 < a2 + v5 || (unint64_t)v6 < a2 || (unint64_t)a3 - v5 < 4)
  {
    __break(0x5519u);
  }
  else
  {
    v4 = 0;
    v7 = bswap32(*v6);
    *(_DWORD *)(result + 368) = v7 & 0x7FFFFFFF;
    *a4 = v5;
    if (a3 == 4 || (v7 & 0x80000000) == 0)
      return v4;
    return SRTPEncryptData(result);
  }
  return result;
}

uint64_t SRTPCalculateTotalSuffixBytes(uint64_t a1, uint64_t a2, char a3)
{
  int v3;
  int v4;
  int v5;
  BOOL v6;
  int v7;
  int v8;

  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SRTPCalculateTotalSuffixBytes_cold_1();
    }
    return 0xFFFFFFFFLL;
  }
  v3 = *(_DWORD *)(a1 + 408);
  if (v3 != 1)
  {
    if (v3 == 4)
    {
      v4 = 10;
    }
    else
    {
      if (v3 != 3)
      {
        v4 = *(_DWORD *)(a1 + 416);
        if (v4 == -1)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              SRTPCalculateTotalSuffixBytes_cold_2();
          }
          return 0xFFFFFFFFLL;
        }
        v6 = v3 == 1;
        goto LABEL_11;
      }
      v4 = 4;
    }
    v6 = (a3 & 0x7F) == 0;
LABEL_11:
    v7 = v6;
    v5 = 4 * v7;
    goto LABEL_15;
  }
  v4 = 0;
  v5 = 4;
LABEL_15:
  v8 = _SRTP_MKISize(a1, a2);
  if (v8 != -1)
    return (v5 + v4 + v8);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      SRTPCalculateTotalSuffixBytes_cold_3();
  }
  return 0xFFFFFFFFLL;
}

uint64_t _SRTP_MKISize(uint64_t a1, uint64_t a2)
{
  int v3;
  pthread_mutex_t *v4;
  uint64_t v5;

  v3 = *(_DWORD *)(a1 + 408);
  if ((v3 - 3) < 2)
    goto LABEL_2;
  if (v3 != 1)
    return 0;
  if (VCSecurityKeyHolder_SecurityKeyMode(a2) != 1)
  {
LABEL_2:
    v4 = (pthread_mutex_t *)(a1 + 288);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 288));
    v5 = VCMediaKeyIndex_UniquePrefixSize(*(_QWORD *)(a1 + 352));
    pthread_mutex_unlock(v4);
    return v5;
  }
  return 16;
}

uint64_t SRTPAddAuthenticationTag(uint64_t a1, uint64_t a2, unsigned int a3, signed int a4, char *a5, signed int a6, signed int *a7)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  unsigned int v16;
  signed int v17;
  signed int v18;
  unsigned int v19;
  uint64_t v20;
  char *v21;
  int v22;
  int v23;
  char *v24;
  uint64_t v25;
  NSObject *v26;
  NSObject *v27;
  char *v28;
  unsigned int v30;
  uint64_t v31;
  NSObject *v32;
  unsigned int v33;
  char *v35;
  char v37;
  int v38;
  unsigned int __src;
  uint64_t v40;
  __int16 v41;
  const char *v42;
  __int16 v43;
  int v44;
  __int16 v45;
  signed int v46;
  __int16 v47;
  int v48;
  __int16 v49;
  int v50;
  __int16 v51;
  signed int v52;
  __int16 v53;
  signed int v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    v12 = 2149711873;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SRTPAddAuthenticationTag_cold_1();
    }
    return v12;
  }
  if (!a7)
  {
    v12 = 2149711873;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SRTPAddAuthenticationTag_cold_2();
    }
    return v12;
  }
  *a7 = a6;
  v37 = -86;
  v12 = 0;
  if ((SRTPIsAuthenticationEnabled(a1, (BOOL *)&v37) & 0x80000000) != 0 || !v37)
    return v12;
  v13 = _SRTP_MKISize(a1, a2);
  if ((_DWORD)v13 == -1)
  {
    v12 = 2149711873;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SRTPAddAuthenticationTag_cold_3();
    }
    return v12;
  }
  v14 = v13;
  v15 = *(_DWORD *)(a1 + 408);
  if (v15 - 3 >= 2)
  {
    v17 = a4;
    if (v15 == 1)
    {
      v16 = 4;
      goto LABEL_15;
    }
    v16 = 0;
  }
  else
  {
    v16 = 4 * ((a3 & 0x7F) == 0);
    v17 = a4;
  }
  if (v15 != 1)
  {
    if (v15 == 4)
    {
      v18 = 10;
    }
    else if (v15 == 3)
    {
      v18 = 4;
    }
    else
    {
      v18 = *(_DWORD *)(a1 + 416);
      if (v18 == -1)
      {
        v12 = 2149711873;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            SRTPAddAuthenticationTag_cold_4();
        }
        return v12;
      }
    }
    goto LABEL_18;
  }
LABEL_15:
  v18 = 0;
LABEL_18:
  v19 = v13 + a6;
  v20 = (_DWORD)v13 + a6 + v16 + v18;
  if (v20 > v17)
  {
    v30 = v16;
    v12 = 2149711886;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v31 = VRTraceErrorLogLevelToCSTR();
      v32 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        __src = 136316930;
        v40 = v31;
        v41 = 2080;
        v42 = "SRTPAddAuthenticationTag";
        v43 = 1024;
        v44 = 1537;
        v45 = 1024;
        v46 = a6;
        v47 = 1024;
        v48 = v14;
        v49 = 1024;
        v50 = v30;
        v51 = 1024;
        v52 = v18;
        v53 = 1024;
        v54 = a4;
        _os_log_error_impl(&dword_1D8A54000, v32, OS_LOG_TYPE_ERROR, " [%s] %s:%d SRTP authentication tag does not fit in packet. dataLength=%d, mkiSize=%d, rocSize=%d, hmacSize=%d,  maxBufferLength=%d", (uint8_t *)&__src, 0x3Au);
        return 2149711886;
      }
    }
  }
  else
  {
    v35 = &a5[v17];
    if (v15 > 4 || ((1 << v15) & 0x1A) == 0)
    {
LABEL_50:
      if (!v18)
        return 0;
      v28 = &a5[*a7];
      if (v28 <= v35
        && v28 >= a5
        && ((v18 | v17) & 0x80000000) == 0
        && v35 - v28 >= v18
        && a6 <= v17
        && (a6 & 0x80000000) == 0)
      {
        SRTPGenerateAuthenticationTag((_DWORD *)a1, 1, a3, a5, a6, v28, v18);
        v12 = 0;
        *a7 += v18;
        return v12;
      }
LABEL_85:
      __break(0x5519u);
    }
    if (VCMediaKeyIndex_isValid(*(_QWORD **)(a1 + 352)))
    {
      v21 = &a5[a6];
      if (v21)
      {
        v33 = v16;
        if (v21 >= v35 || v21 < a5)
          goto LABEL_85;
        pthread_mutex_lock((pthread_mutex_t *)(a1 + 288));
        VCMediaKeyIndex_UniquePrefixBytes(*(_QWORD *)(a1 + 352), &a5[a6], v14);
        if (!VCMediaKeyIndex_isEqual(*(_QWORD *)(a1 + 360), *(_QWORD *)(a1 + 352)))
          VCMediaKeyIndex_ReleaseAndCopyNewValue((const void **)(a1 + 360), *(void **)(a1 + 352));
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 288));
        *a7 += v14;
        if (a4 < 0)
          goto LABEL_85;
        if (a5)
        {
          v22 = *(_DWORD *)(a1 + 408);
          if (v22 == 1 || (v23 = 0, (a3 & 0x7F) == 0) && (v22 - 3) <= 1)
          {
            v38 = 0;
            SRTPGetROC(a1, a3, &v38, 1);
            __src = bswap32((16 * (v14 & 0xF)) | (v38 << 8));
            v24 = &a5[v19];
            if (v24 < a5 || v24 > &a5[v20] || v20 - (unint64_t)v19 < v16)
              goto LABEL_85;
            memcpy(v24, &__src, v16);
            v23 = v16;
          }
        }
        else
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              SRTPAddAuthenticationTag_cold_8();
          }
          v23 = -1;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          v25 = VRTraceErrorLogLevelToCSTR();
          v26 = *MEMORY[0x1E0CF2758];
          v27 = *MEMORY[0x1E0CF2758];
          if (*MEMORY[0x1E0CF2748])
          {
            if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
            {
              __src = 136316418;
              v40 = v25;
              v41 = 2080;
              v42 = "SRTPAddAuthenticationTag";
              v43 = 1024;
              v44 = 1547;
              v45 = 1024;
              v46 = v33;
              v47 = 1024;
              v48 = v18;
              v49 = 1024;
              v50 = v14;
              _os_log_impl(&dword_1D8A54000, v26, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d uplink rocSize=%d, hmacSize=%d, mkiSize=%d", (uint8_t *)&__src, 0x2Eu);
            }
          }
          else if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
          {
            __src = 136316418;
            v40 = v25;
            v41 = 2080;
            v42 = "SRTPAddAuthenticationTag";
            v43 = 1024;
            v44 = 1547;
            v45 = 1024;
            v46 = v33;
            v47 = 1024;
            v48 = v18;
            v49 = 1024;
            v50 = v14;
            _os_log_debug_impl(&dword_1D8A54000, v26, OS_LOG_TYPE_DEBUG, " [%s] %s:%d uplink rocSize=%d, hmacSize=%d, mkiSize=%d", (uint8_t *)&__src, 0x2Eu);
          }
        }
        if (v23 != -1)
        {
          *a7 += v23;
          v17 = a4;
          goto LABEL_50;
        }
        v12 = 2149711873;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            SRTPAddAuthenticationTag_cold_7();
        }
      }
      else
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            SRTPAddAuthenticationTag_cold_6();
        }
        v12 = 2149711873;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            SRTPAddAuthenticationTag_cold_5();
        }
      }
    }
    else
    {
      v12 = 2149711873;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          SRTPAddAuthenticationTag_cold_9();
      }
    }
  }
  return v12;
}

uint64_t SRTPIsAuthenticationEnabled(uint64_t a1, BOOL *a2)
{
  uint64_t v2;
  int v3;

  v2 = 2149711876;
  if ((*(_BYTE *)a1 & 8) == 0)
    return 2149711928;
  v3 = *(_DWORD *)(a1 + 408);
  *a2 = v3 != 0;
  if (!v3 || *(int *)(a1 + 416) > 0)
    return 0;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      SRTPIsAuthenticationEnabled_cold_1();
  }
  return v2;
}

void *SRTPGenerateAuthenticationTag(_DWORD *a1, int a2, unsigned int a3, const void *a4, unsigned int a5, void *a6, unsigned int a7)
{
  size_t v13;
  __int128 v14;
  unsigned int v15;
  _BYTE v17[12];
  unsigned int v18;
  _BYTE *v19;
  unsigned int v20;
  CCHmacContext v21;
  uint64_t v22;

  v18 = a3;
  v19 = v17;
  v22 = *MEMORY[0x1E0C80C00];
  v13 = a1[106];
  MEMORY[0x1E0C80A78](a1);
  if ((_DWORD)v13)
    memset(&v17[-((v13 + 15) & 0x1FFFFFFF0)], 170, v13);
  *(_QWORD *)&v14 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v21.ctx[88] = v14;
  *(_OWORD *)&v21.ctx[92] = v14;
  *(_OWORD *)&v21.ctx[80] = v14;
  *(_OWORD *)&v21.ctx[84] = v14;
  *(_OWORD *)&v21.ctx[72] = v14;
  *(_OWORD *)&v21.ctx[76] = v14;
  *(_OWORD *)&v21.ctx[64] = v14;
  *(_OWORD *)&v21.ctx[68] = v14;
  *(_OWORD *)&v21.ctx[56] = v14;
  *(_OWORD *)&v21.ctx[60] = v14;
  *(_OWORD *)&v21.ctx[48] = v14;
  *(_OWORD *)&v21.ctx[52] = v14;
  *(_OWORD *)&v21.ctx[40] = v14;
  *(_OWORD *)&v21.ctx[44] = v14;
  *(_OWORD *)&v21.ctx[32] = v14;
  *(_OWORD *)&v21.ctx[36] = v14;
  *(_OWORD *)&v21.ctx[24] = v14;
  *(_OWORD *)&v21.ctx[28] = v14;
  *(_OWORD *)&v21.ctx[16] = v14;
  *(_OWORD *)&v21.ctx[20] = v14;
  *(_OWORD *)&v21.ctx[8] = v14;
  *(_OWORD *)&v21.ctx[12] = v14;
  v15 = a1[102] - 3;
  *(_OWORD *)v21.ctx = v14;
  *(_OWORD *)&v21.ctx[4] = v14;
  CCHmacInit(&v21, 2 * (v15 < 2), a1 + 63, (int)a1[103]);
  CCHmacUpdate(&v21, a4, a5);
  if (a2)
  {
    v20 = -1431655766;
    SRTPGetROC((uint64_t)a1, v18, (int *)&v20, 1);
    v20 = bswap32(v20);
    CCHmacUpdate(&v21, &v20, 4uLL);
  }
  CCHmacFinal(&v21, &v17[-((v13 + 15) & 0x1FFFFFFF0)]);
  if (v13 < a7)
    __break(0x5519u);
  return memcpy(a6, &v17[-((v13 + 15) & 0x1FFFFFFF0)], a7);
}

uint64_t SRTPVerifyAuthenticationTag(uint64_t a1, unsigned int a2, char *a3, unsigned int a4, unsigned int *a5, _BYTE *a6)
{
  int64_t v11;
  int v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  BOOL v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  int v25;
  unsigned int v26;
  unint64_t v27;
  id MKIWithBytes;
  NSObject *v29;
  const char *v30;
  uint64_t v31;
  NSObject *v32;
  NSObject *v33;
  char *v34;
  unsigned int v35;
  unsigned int *v37;
  _BOOL4 v38;
  unsigned int *v39;
  uint64_t v40;
  const char *v41;
  uint64_t v42;
  unsigned int v43;
  unsigned int v44;
  unsigned int *v45;
  _BYTE *v46;
  uint64_t v47;
  unsigned int v48;
  char v49;
  uint8_t buf[4];
  uint64_t v51;
  __int16 v52;
  const char *v53;
  __int16 v54;
  int v55;
  __int16 v56;
  _BYTE v57[10];
  const char *v58;
  uint64_t v59;

  v48 = a2;
  v59 = *MEMORY[0x1E0C80C00];
  v11 = *(unsigned int *)(a1 + 416);
  MEMORY[0x1E0C80A78](a1);
  if ((_DWORD)v11)
    memset((char *)&v40 - ((v11 + 15) & 0x1FFFFFFF0), 170, v11);
  if (!a3)
  {
    v15 = 2149711873;
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      goto LABEL_93;
    v37 = a5;
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      SRTPVerifyAuthenticationTag_cold_1();
    goto LABEL_89;
  }
  if (!a6)
  {
    v15 = 2149711873;
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      goto LABEL_93;
    v37 = a5;
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      SRTPVerifyAuthenticationTag_cold_2();
    goto LABEL_89;
  }
  if (!a5)
  {
    v15 = 2149711873;
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      goto LABEL_93;
    v37 = 0;
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      SRTPVerifyAuthenticationTag_cold_3();
    goto LABEL_89;
  }
  v49 = -86;
  v12 = SRTPIsAuthenticationEnabled(a1, (BOOL *)&v49);
  v13 = 0;
  v14 = v49;
  *a5 = a4;
  v15 = 0;
  if (v12 < 0 || !v14)
    goto LABEL_67;
  v16 = *(_DWORD *)(a1 + 408);
  if (v16 == 1)
  {
    v15 = 0;
    v17 = 4;
    goto LABEL_21;
  }
  if (v16 == 4)
  {
    v15 = 10;
    goto LABEL_14;
  }
  if (v16 != 3)
  {
    v15 = *(unsigned int *)(a1 + 416);
    if ((_DWORD)v15 != -1)
    {
      v18 = v16 == 1;
      goto LABEL_17;
    }
    v15 = 2149711873;
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      goto LABEL_93;
    v37 = a5;
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      SRTPVerifyAuthenticationTag_cold_4();
LABEL_89:
    v13 = 0;
    goto LABEL_71;
  }
  v15 = 4;
LABEL_14:
  v18 = (v48 & 0x7F) == 0;
LABEL_17:
  v19 = v18;
  v17 = 4 * v19;
LABEL_21:
  v13 = v17 + v15;
  v20 = a4 - (v17 + (_DWORD)v15);
  if (a4 < v17 + v15)
  {
    v15 = 2149711880;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v39 = a5;
      VRTraceErrorLogLevelToCSTR();
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v13 = 0;
        goto LABEL_99;
      }
      SRTPVerifyAuthenticationTag_cold_5();
      v13 = 0;
      goto LABEL_105;
    }
LABEL_93:
    v13 = 0;
    goto LABEL_67;
  }
  v21 = (int)a4;
  if (v16 > 4 || ((1 << v16) & 0x1A) == 0)
    goto LABEL_59;
  v46 = a6;
  if ((a4 & 0x80000000) != 0)
    goto LABEL_106;
  v47 = (int)a4;
  if (v16 != 1)
  {
    v22 = v16 - 3;
    if ((v48 & 0x7F) != 0 || v22 > 1)
    {
      if (v22 < 2)
      {
        v43 = v17;
        v25 = 2;
        goto LABEL_35;
      }
      v15 = 2149711873;
      if ((int)VRTraceGetErrorLogLevelForModule() < 3)
        goto LABEL_67;
      v37 = a5;
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SRTPVerifyAuthenticationTag_cold_10();
LABEL_71:
      a5 = v37;
      goto LABEL_67;
    }
  }
  *(_DWORD *)buf = 0;
  if (&a3[a4] < &a3[v20] || &a3[v20] < a3 || (unint64_t)a4 - v20 < v17)
    goto LABEL_106;
  v43 = v17;
  __memcpy_chk();
  v23 = bswap32(*(unsigned int *)buf);
  *(_DWORD *)(a1 + 124) = v23 >> 8;
  v24 = v23 >> 4;
  if (v24)
    v25 = v24;
  else
    v25 = 16;
  v21 = v47;
LABEL_35:
  v26 = v25 + v13;
  if (v25 + v13 > a4)
  {
    v15 = 2149711880;
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      goto LABEL_67;
    v39 = a5;
    VRTraceErrorLogLevelToCSTR();
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      goto LABEL_99;
    SRTPVerifyAuthenticationTag_cold_7();
LABEL_105:
    v15 = 2149711880;
    goto LABEL_99;
  }
  v27 = (unint64_t)&a3[v21 - v26];
  v45 = a5;
  v44 = v25;
  if (&a3[v21] == (char *)v26)
  {
    LODWORD(v42) = -2145255423;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SRTPVerifyAuthenticationTag_cold_9();
    }
  }
  else
  {
    if (v27 >= (unint64_t)&a3[v21] || v27 < (unint64_t)a3)
      goto LABEL_106;
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 288));
    VCMediaKeyIndex_Release((const void **)(a1 + 360));
    MKIWithBytes = VCMediaKeyIndex_CreateMKIWithBytes(v27, v44);
    *(_QWORD *)(a1 + 360) = MKIWithBytes;
    if (!VCMediaKeyIndex_isStartingWithPrefix(*(_QWORD *)(a1 + 352), (uint64_t)MKIWithBytes))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
      {
        v42 = VRTraceErrorLogLevelToCSTR();
        v29 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v41 = VCMediaKeyIndex_Description(*(void **)(a1 + 352));
          v30 = VCMediaKeyIndex_Description(*(void **)(a1 + 360));
          *(_DWORD *)buf = 136316162;
          v51 = v42;
          v52 = 2080;
          v53 = "_SRTP_ReadVariableMKI";
          v54 = 1024;
          v55 = 1445;
          v56 = 2080;
          *(_QWORD *)v57 = v41;
          *(_WORD *)&v57[8] = 2080;
          v58 = v30;
          _os_log_impl(&dword_1D8A54000, v29, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d MKI has changed from '%s' to '%s'", buf, 0x30u);
        }
      }
      *v46 = 1;
    }
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 288));
    LODWORD(v42) = 0;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() < 8)
    goto LABEL_56;
  v31 = VRTraceErrorLogLevelToCSTR();
  v32 = *MEMORY[0x1E0CF2758];
  v33 = *MEMORY[0x1E0CF2758];
  if (!*MEMORY[0x1E0CF2748])
  {
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136316418;
      v51 = v31;
      v52 = 2080;
      v53 = "SRTPVerifyAuthenticationTag";
      v54 = 1024;
      v55 = 1596;
      v56 = 1024;
      *(_DWORD *)v57 = v43;
      *(_WORD *)&v57[4] = 1024;
      *(_DWORD *)&v57[6] = v15;
      LOWORD(v58) = 1024;
      *(_DWORD *)((char *)&v58 + 2) = v44;
      _os_log_debug_impl(&dword_1D8A54000, v32, OS_LOG_TYPE_DEBUG, " [%s] %s:%d downlink rocSize=%d, hmacSize=%d, mkiSize=%d", buf, 0x2Eu);
      if (!v27)
        goto LABEL_73;
      goto LABEL_57;
    }
    goto LABEL_56;
  }
  if (!os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
  {
LABEL_56:
    if (!v27)
      goto LABEL_73;
    goto LABEL_57;
  }
  *(_DWORD *)buf = 136316418;
  v51 = v31;
  v52 = 2080;
  v53 = "SRTPVerifyAuthenticationTag";
  v54 = 1024;
  v55 = 1596;
  v56 = 1024;
  *(_DWORD *)v57 = v43;
  *(_WORD *)&v57[4] = 1024;
  *(_DWORD *)&v57[6] = v15;
  LOWORD(v58) = 1024;
  *(_DWORD *)((char *)&v58 + 2) = v44;
  _os_log_impl(&dword_1D8A54000, v32, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d downlink rocSize=%d, hmacSize=%d, mkiSize=%d", buf, 0x2Eu);
  if (v27)
  {
LABEL_57:
    a5 = v45;
    if (*v46)
    {
      v15 = 0;
      v13 = v26;
      goto LABEL_67;
    }
    v13 = v26;
    v21 = v47;
LABEL_59:
    if (!(_DWORD)v15)
      goto LABEL_67;
    v34 = &a3[v21];
    if (&a3[v21] >= a3 && (v15 & 0x80000000) == 0 && (int)v15 <= v11)
    {
      v35 = a4 - v13;
      if ((int)(a4 - v13) <= (int)a4 && (v35 & 0x80000000) == 0)
      {
        SRTPGenerateAuthenticationTag((_DWORD *)a1, 1, v48, a3, v35, (char *)&v40 - ((v11 + 15) & 0x1FFFFFFF0), v15);
        if (!timingsafe_bcmp(&v34[-v15], (char *)&v40 - ((v11 + 15) & 0x1FFFFFFF0), v15))
        {
          v15 = 0;
          goto LABEL_67;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() < 3)
        {
          v15 = 2149711929;
          goto LABEL_67;
        }
        v39 = a5;
        VRTraceErrorLogLevelToCSTR();
        v15 = 2149711929;
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          SRTPVerifyAuthenticationTag_cold_6();
LABEL_99:
        a5 = v39;
        goto LABEL_67;
      }
    }
LABEL_106:
    __break(0x5519u);
  }
LABEL_73:
  if ((int)VRTraceGetErrorLogLevelForModule() < 3)
  {
    v13 = v26;
    a5 = v45;
    v15 = v42;
  }
  else
  {
    VRTraceErrorLogLevelToCSTR();
    v38 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
    v15 = v42;
    if (v38)
      SRTPVerifyAuthenticationTag_cold_8();
    v13 = v26;
    a5 = v45;
  }
LABEL_67:
  *a5 -= v13;
  return v15;
}

uint64_t SRTCPAddAuthenticationTag(_DWORD *a1, signed int a2, char *a3, signed int a4, signed int *a5)
{
  uint64_t result;
  uint64_t v11;
  int64_t v12;
  char *v13;
  char *v14;
  char v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  *a5 = a4;
  v15 = -86;
  result = SRTPIsAuthenticationEnabled((uint64_t)a1, (BOOL *)&v15);
  v11 = result;
  if ((result & 0x80000000) != 0 || !v15)
    return v11;
  v12 = (int)a1[104];
  if ((int)v12 + a4 > a2)
  {
    v11 = 2149711873;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SRTCPAddAuthenticationTag_cold_1();
    }
    return v11;
  }
  v13 = &a3[a2];
  v14 = &a3[a4];
  if (v14 <= v13
    && v14 >= a3
    && v13 - v14 >= v12
    && ((v12 | a2) & 0x80000000) == 0
    && a4 <= a2
    && (a4 & 0x80000000) == 0)
  {
    SRTPGenerateAuthenticationTag(a1, 0, 0, a3, a4, v14, v12);
    v11 = 0;
    *a5 += a1[104];
    return v11;
  }
  __break(0x5519u);
  return result;
}

uint64_t SRTCPVerifyAuthenticationTag(_DWORD *a1, char *a2, int a3, int *a4)
{
  uint64_t v8;
  uint64_t v9;
  int64_t v10;
  uint64_t result;
  int64_t v12;
  int v13;
  _BYTE v14[7];
  char v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  *a4 = a3;
  v15 = -86;
  v8 = SRTPIsAuthenticationEnabled((uint64_t)a1, (BOOL *)&v15);
  v9 = v8;
  if ((v8 & 0x80000000) != 0 || !v15)
    return v9;
  v10 = a1[104];
  if ((int)v10 > a3)
  {
    v9 = 2149711873;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SRTCPVerifyAuthenticationTag_cold_1();
    }
    return v9;
  }
  result = MEMORY[0x1E0C80A78](v8);
  if ((_DWORD)v10)
    result = (uint64_t)memset(&v14[-((v10 + 15) & 0x1FFFFFFF0)], 170, v10);
  v12 = (int)a1[104];
  if (v12 <= v10 && ((v12 | a3) & 0x80000000) == 0 && ((a3 - (_DWORD)v12) & 0x80000000) == 0)
  {
    SRTPGenerateAuthenticationTag(a1, 0, 0, a2, a3 - v12, &v14[-((v10 + 15) & 0x1FFFFFFF0)], v12);
    v13 = a1[104];
    if (!memcmp(&a2[a3 - v13], &v14[-((v10 + 15) & 0x1FFFFFFF0)], v13))
    {
      v9 = 0;
      *a4 -= v13;
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() < 3)
    {
      return 2149711929;
    }
    else
    {
      VRTraceErrorLogLevelToCSTR();
      v9 = 2149711929;
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SRTCPVerifyAuthenticationTag_cold_2();
    }
    return v9;
  }
  __break(0x5519u);
  return result;
}

uint64_t WaitUseEncryption(uint64_t a1, double *a2)
{
  pthread_mutex_t *v4;
  uint64_t v5;
  double v7;
  __darwin_time_t v8;
  uint64_t v9;
  double v10;
  timespec v11;
  timeval v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v12.tv_usec = 0xAAAAAAAAAAAAAAAALL;
  v4 = (pthread_mutex_t *)(a1 + 8);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  if (*(_DWORD *)(a1 + 4))
  {
    v5 = 2149711902;
  }
  else
  {
    if ((*(_BYTE *)a1 & 6) != 0)
    {
LABEL_5:
      pthread_mutex_unlock(v4);
      return 0;
    }
    v5 = 2149711902;
    while (1)
    {
      gettimeofday(&v12, 0);
      v7 = (double)v12.tv_sec + (double)v12.tv_usec * 0.000001;
      v11.tv_sec = 0xAAAAAAAAAAAAAAAALL;
      v11.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
      convertTimeoutToRelativeTimespec(*a2);
      v11.tv_sec = v8;
      v11.tv_nsec = v9;
      pthread_cond_timedwait_relative_np((pthread_cond_t *)(a1 + 72), v4, &v11);
      gettimeofday(&v12, 0);
      v10 = (double)v12.tv_sec + (double)v12.tv_usec * 0.000001 - v7;
      if (v10 >= *a2)
        break;
      if (*(_DWORD *)(a1 + 4))
        goto LABEL_3;
      *a2 = *a2 - v10;
      if ((*(_BYTE *)a1 & 6) != 0)
        goto LABEL_5;
    }
    v5 = 2149711876;
  }
LABEL_3:
  *a2 = 0.0;
  pthread_mutex_unlock(v4);
  return v5;
}

uint64_t SRTPCancelEncryption()
{
  uint64_t result;

  result = CheckInHandleDebug();
  if (result)
  {
    _SRTPCancelEncryption(result);
    return CheckOutHandleDebug();
  }
  return result;
}

unint64_t SRTPWaitUseEncryption(uint64_t a1, double *a2)
{
  uint64_t v3;
  unint64_t result;
  unint64_t v5;

  v3 = 2147549186;
  result = CheckInHandleDebug();
  if (!result)
    return v3;
  v5 = result;
  if (result == 0xFFFFFFFF)
    return 2147549190;
  v3 = 2149711928;
  if (!*(_DWORD *)(result + 7080) || !*(_DWORD *)(result + 7520))
  {
LABEL_9:
    CheckOutHandleDebug();
    return v3;
  }
  if (result < result + 27616)
  {
    v3 = WaitUseEncryption(result + 7080, a2);
    if (!(_DWORD)v3)
    {
      *a2 = *a2 + 0.1;
      v3 = WaitUseEncryption(v5 + 7520, a2);
    }
    goto LABEL_9;
  }
  __break(0x5519u);
  return result;
}

unint64_t SRTPGetFramingOverhead(uint64_t a1, uint64_t *a2)
{
  unint64_t result;
  uint64_t v4;

  if (!a2)
    return 2149711873;
  result = CheckInHandleDebug();
  if (!result)
    return 2147549186;
  v4 = 10;
  switch(*(_DWORD *)(result + 7500))
  {
    case 1:
    case 4:
    case 7:
      goto LABEL_10;
    case 3:
    case 6:
      if (result >= result + 27616)
      {
        __break(0x5519u);
      }
      else
      {
        v4 = _SRTP_MKISize(result + 7080, *(_QWORD *)(result + 10448)) + 4;
LABEL_10:
        *a2 = v4;
LABEL_11:
        CheckOutHandleDebug();
        result = 0;
      }
      break;
    case 8:
      v4 = 12;
      goto LABEL_10;
    case 9:
      v4 = 6;
      goto LABEL_10;
    default:
      goto LABEL_11;
  }
  return result;
}

void *MakeSessionKey(uint64_t a1, const void *a2, unsigned int a3, uint64_t a4, char a5, void *a6, unsigned int a7)
{
  size_t v7;
  int v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  void *v18;
  char *dataOut;
  int v20;
  unsigned __int8 v21;
  char *v22;
  int v23;
  unint64_t v24;
  _QWORD *v25;
  char *v26;
  char *v27;
  char *v28;
  CCOptions v29;
  size_t v31[2];

  v14 = a1;
  v31[1] = *MEMORY[0x1E0C80C00];
  LODWORD(v7) = vcvtd_n_s64_f64(ceil((double)(int)a7 * 0.0625), 4uLL);
  v15 = (v7 + 15) & 0x1FFFFFFF0;
  v16 = MEMORY[0x1E0C80A78](a1);
  v17 = (char *)v31 - v15;
  if ((_DWORD)v7)
  {
    v18 = memset((char *)v31 - v15, 170, v7);
    MEMORY[0x1E0C80A78](v18);
    dataOut = (char *)v31 - v15;
    memset(dataOut, 170, v7);
    v31[0] = 0xAAAAAAAAAAAAAAAALL;
    if ((v7 & 0x80000000) == 0)
      v20 = v7;
    else
      v20 = v7 + 15;
    if ((int)v7 >= 16)
    {
      v21 = 0;
      v22 = &v17[v7];
      v23 = v20 >> 4;
      v24 = v7;
      v25 = v17;
      while (v25 <= (_QWORD *)v22)
      {
        if (v17 > (char *)v25)
          break;
        if (v24 <= 0xD)
          break;
        *v25 = *(_QWORD *)a4;
        *(_QWORD *)((char *)v25 + 6) = *(_QWORD *)(a4 + 6);
        v26 = (char *)v25 + 14;
        if (v26 >= v22)
          break;
        if (v26 < v17)
          break;
        *v26 = 0;
        v27 = v26 + 1;
        if (v27 >= v22)
          break;
        if (v27 < v17)
          break;
        *v27 = v21;
        v28 = v27 - 8;
        if (v28 >= v22 || v28 < v17)
          break;
        *v28 = *(_BYTE *)(a4 + 7) ^ a5;
        v25 = v28 + 9;
        ++v21;
        v24 -= 16;
        if (v23 <= v21)
          goto LABEL_19;
      }
LABEL_24:
      __break(0x5519u);
    }
  }
  else
  {
    MEMORY[0x1E0C80A78](v16);
    dataOut = (char *)v31 - v15;
    v31[0] = 0xAAAAAAAAAAAAAAAALL;
  }
LABEL_19:
  if (v14)
    v29 = 2;
  else
    v29 = 0;
  CCCrypt(0, 0, v29, a2, a3, 0, v17, (int)v7, dataOut, (int)v7, v31);
  if (v7 < a7)
    goto LABEL_24;
  return memcpy(a6, dataOut, a7);
}

uint64_t VCCCMessageReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  int v15;
  unint64_t v17;
  char v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char v23;
  void *Data;
  id v25;
  uint64_t v26;
  void *String;
  uint64_t result;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        return *(_BYTE *)(a2 + *v5) == 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        v14 = v9++ >= 9;
        if (v14)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        return *(_BYTE *)(a2 + *v5) == 0;
      v17 = v10 >> 3;
      if ((v10 >> 3) == 3)
      {
        Data = (void *)PBReaderReadData();

        v25 = Data;
        v26 = 16;
      }
      else
      {
        if ((_DWORD)v17 != 2)
        {
          if ((_DWORD)v17 == 1)
          {
            v18 = 0;
            v19 = 0;
            v20 = 0;
            while (1)
            {
              v21 = *v3;
              v22 = *(_QWORD *)(a2 + v21);
              if (v22 == -1 || v22 >= *(_QWORD *)(a2 + *v4))
                break;
              v23 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v22);
              *(_QWORD *)(a2 + v21) = v22 + 1;
              v20 |= (unint64_t)(v23 & 0x7F) << v18;
              if ((v23 & 0x80) == 0)
                goto LABEL_34;
              v18 += 7;
              v14 = v19++ >= 9;
              if (v14)
              {
                v20 = 0;
                goto LABEL_36;
              }
            }
            *(_BYTE *)(a2 + *v5) = 1;
LABEL_34:
            if (*(_BYTE *)(a2 + *v5))
              v20 = 0;
LABEL_36:
            *(_QWORD *)(a1 + 8) = v20;
          }
          else
          {
            result = PBReaderSkipValueWithTag();
            if (!(_DWORD)result)
              return result;
          }
          continue;
        }
        String = (void *)PBReaderReadString();

        v25 = String;
        v26 = 24;
      }
      *(_QWORD *)(a1 + v26) = v25;
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

uint64_t VideoReceiverUtil_CreateTempFile(int a1, uint64_t a2, _DWORD *a3, char *a4)
{
  uint64_t result;
  int v7;

  result = open(a4, 1538, 420);
  if ((_DWORD)result)
  {
    v7 = result;
    fcntl(result, 48, 0);
    *a3 = v7;
    result = FigFileWrapDarwinFileDesc();
    if (a2)
    {
      if (!(_DWORD)result)
        return FigByteStreamCreateFromOpenFile();
    }
  }
  return result;
}

uint64_t VideoReceiverUtil_CaptureBitstreamFile(OpaqueCMBlockBuffer *a1, int32_t timescale, uint64_t a3, const opaqueCMFormatDescription *a4, int a5)
{
  __int128 v9;
  int v10;
  const __CFAllocator *v11;
  uint64_t TempFile;
  const __CFArray *SampleAttachmentsArray;
  __CFDictionary *ValueAtIndex;
  const void *v15;
  uint64_t v16;
  uint64_t v17;
  CMSampleBufferRef v18;
  uint64_t (*v19)(uint64_t, uint64_t, CMSampleBufferRef);
  uint64_t v20;
  uint64_t v21;
  uint64_t (*v22)(uint64_t, _QWORD);
  uint64_t v23;
  uint64_t (*v24)(uint64_t, _QWORD);
  tm *v25;
  uint64_t v26;
  uint64_t (*v27)(uint64_t, uint64_t, _QWORD, uint64_t);
  uint64_t FigBaseObject;
  uint64_t v29;
  void (*v30)(uint64_t);
  const void *v31;
  int v32;
  size_t sampleSizeArray;
  time_t v35;
  _BYTE v36[24];
  CMSampleTimingInfo sampleTimingArray;
  CMSampleBufferRef sbuf;
  char v39[1000];
  _BYTE __b[1000];
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  sbuf = (CMSampleBufferRef)0xAAAAAAAAAAAAAAAALL;
  sampleTimingArray.decodeTimeStamp.epoch = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v9 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&sampleTimingArray.presentationTimeStamp.timescale = v9;
  *(_OWORD *)&sampleTimingArray.decodeTimeStamp.value = v9;
  *(_OWORD *)&sampleTimingArray.duration.value = v9;
  *(_OWORD *)&sampleTimingArray.duration.epoch = v9;
  if (a5)
    v10 = a5;
  else
    v10 = 33;
  if (*(_DWORD *)(a3 + 60))
  {
    v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  }
  else
  {
    memset(v36, 170, sizeof(v36));
    gettimeofday((timeval *)v36, &v36[16]);
    v35 = *(_QWORD *)v36;
    memset(__b, 170, sizeof(__b));
    memset(v39, 170, sizeof(v39));
    v25 = localtime(&v35);
    strftime(v39, 0x3E8uLL, "%m-%d-%Y_%T", v25);
    snprintf(__b, 0x3E8uLL, "/tmp/Capture%s.mov", v39);
    TempFile = VideoReceiverUtil_CreateTempFile((int)a3 + 32, a3 + 40, (_DWORD *)(a3 + 64), __b);
    if ((_DWORD)TempFile)
      goto LABEL_35;
    v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    TempFile = FigMovieFormatWriterCreateWithByteStream();
    if ((_DWORD)TempFile)
      goto LABEL_35;
    v26 = *(_QWORD *)(a3 + 48);
    v27 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 8);
    if (!v27)
    {
LABEL_21:
      v20 = 4294954514;
      goto LABEL_22;
    }
    v20 = v27(v26, 1986618469, 0, a3 + 56);
    if ((_DWORD)v20)
      goto LABEL_22;
  }
  CMTimeMake(&sampleTimingArray.duration, v10, timescale);
  CMTimeMake((CMTime *)__b, *(int *)(a3 + 60), timescale);
  sampleTimingArray.presentationTimeStamp = *(CMTime *)__b;
  sampleTimingArray.decodeTimeStamp = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E18];
  sampleSizeArray = CMBlockBufferGetDataLength(a1);
  TempFile = CMSampleBufferCreate(v11, a1, 1u, 0, 0, a4, 1, 1, &sampleTimingArray, 1, &sampleSizeArray, &sbuf);
  if ((_DWORD)TempFile)
  {
LABEL_35:
    v20 = TempFile;
    goto LABEL_22;
  }
  SampleAttachmentsArray = CMSampleBufferGetSampleAttachmentsArray(sbuf, 1u);
  if (SampleAttachmentsArray)
  {
    ValueAtIndex = (__CFDictionary *)CFArrayGetValueAtIndex(SampleAttachmentsArray, 0);
    v15 = (const void *)*MEMORY[0x1E0C9AE50];
    CFDictionarySetValue(ValueAtIndex, (const void *)*MEMORY[0x1E0CA2620], (const void *)*MEMORY[0x1E0C9AE50]);
    CFDictionarySetValue(ValueAtIndex, (const void *)*MEMORY[0x1E0CA25C8], v15);
    CFDictionarySetValue(ValueAtIndex, (const void *)*MEMORY[0x1E0CA25E0], v15);
  }
  v16 = *(_QWORD *)(a3 + 48);
  v17 = *(unsigned int *)(a3 + 56);
  v18 = sbuf;
  v19 = *(uint64_t (**)(uint64_t, uint64_t, CMSampleBufferRef))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 32);
  if (!v19)
  {
    CFRelease(sbuf);
    goto LABEL_21;
  }
  v20 = v19(v16, v17, v18);
  CFRelease(sbuf);
  if (!(_DWORD)v20)
  {
    v21 = *(_QWORD *)(a3 + 48);
    v22 = *(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 40);
    if (v22)
    {
      TempFile = v22(v21, 0);
      if (!(_DWORD)TempFile)
      {
        v23 = *(_QWORD *)(a3 + 48);
        v24 = *(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 48);
        if (v24)
          v20 = v24(v23, 0);
        else
          v20 = 4294954514;
        *(_DWORD *)(a3 + 60) += v10;
        return v20;
      }
      goto LABEL_35;
    }
    goto LABEL_21;
  }
LABEL_22:
  if (*(_QWORD *)(a3 + 48))
  {
    FigBaseObject = FigFormatWriterGetFigBaseObject();
    if (FigBaseObject)
    {
      v29 = FigBaseObject;
      v30 = *(void (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 24);
      if (v30)
        v30(v29);
    }
    CFRelease(*(CFTypeRef *)(a3 + 48));
  }
  v31 = *(const void **)(a3 + 40);
  if (v31)
    CFRelease(v31);
  if (*(_QWORD *)(a3 + 32))
  {
    FigFileForkClose();
    v32 = *(_DWORD *)(a3 + 64);
    if (v32)
      close(v32);
  }
  return v20;
}

uint64_t FigFormatWriterInvalidate()
{
  uint64_t result;
  uint64_t v1;
  uint64_t (*v2)(uint64_t);

  result = FigFormatWriterGetFigBaseObject();
  if (result)
  {
    v1 = result;
    result = CMBaseObjectGetVTable();
    v2 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(result + 8) + 24);
    if (v2)
      return v2(v1);
  }
  return result;
}

uint64_t VideoReceiverUtil_Capture2vuyFile(void *memoryBlock, int a2, int32_t a3, int32_t a4, int32_t a5, uint64_t a6, int a7)
{
  __int128 v14;
  const __CFAllocator *v15;
  uint64_t TempFile;
  uint64_t v17;
  uint64_t (*v18)(uint64_t, uint64_t, _QWORD, uint64_t);
  const __CFArray *SampleAttachmentsArray;
  __CFDictionary *ValueAtIndex;
  const void *v21;
  uint64_t v22;
  uint64_t v23;
  CMSampleBufferRef v24;
  uint64_t (*v25)(uint64_t, uint64_t, CMSampleBufferRef);
  uint64_t v26;
  uint64_t (*v27)(uint64_t, _QWORD);
  uint64_t v28;
  uint64_t (*v29)(uint64_t, _QWORD);
  uint64_t v30;
  const void *v31;
  int v32;
  size_t sampleSizeArray;
  CMTime v35;
  CMBlockBufferRef dataBuffer;
  CMSampleTimingInfo v37;
  CMVideoFormatDescriptionRef formatDescriptionOut;
  CMSampleBufferRef v39[3];

  v39[1] = *(CMSampleBufferRef *)MEMORY[0x1E0C80C00];
  formatDescriptionOut = 0;
  v39[0] = (CMSampleBufferRef)0xAAAAAAAAAAAAAAAALL;
  v37.decodeTimeStamp.epoch = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v14 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v37.presentationTimeStamp.timescale = v14;
  *(_OWORD *)&v37.decodeTimeStamp.value = v14;
  *(_OWORD *)&v37.duration.value = v14;
  *(_OWORD *)&v37.duration.epoch = v14;
  if (*(_DWORD *)(a6 + 60))
  {
    v15 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  }
  else
  {
    TempFile = VideoReceiverUtil_CreateTempFile((int)a6 + 32, a6 + 40, (_DWORD *)(a6 + 64), "/var/mobile/Capture_2vuy.mov");
    if ((_DWORD)TempFile)
      goto LABEL_29;
    v15 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    TempFile = FigMovieFormatWriterCreateWithByteStream();
    if ((_DWORD)TempFile)
      goto LABEL_29;
    v17 = *(_QWORD *)(a6 + 48);
    v18 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 8);
    if (!v18)
      goto LABEL_18;
    TempFile = v18(v17, 1986618469, 0, a6 + 56);
    if ((_DWORD)TempFile)
    {
LABEL_29:
      v30 = TempFile;
      goto LABEL_19;
    }
  }
  dataBuffer = 0;
  TempFile = CMBlockBufferCreateWithMemoryBlock(v15, memoryBlock, a2, (CFAllocatorRef)*MEMORY[0x1E0C9AE20], 0, 0, a2, 1u, &dataBuffer);
  if ((_DWORD)TempFile)
    goto LABEL_29;
  CMTimeMake(&v37.duration, a7, a5);
  CMTimeMake(&v35, *(int *)(a6 + 60), a5);
  v37.presentationTimeStamp = v35;
  v37.decodeTimeStamp = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E18];
  sampleSizeArray = a2;
  TempFile = CMVideoFormatDescriptionCreate(v15, 0x34323076u, a3, a4, 0, &formatDescriptionOut);
  if ((_DWORD)TempFile)
    goto LABEL_29;
  TempFile = CMSampleBufferCreate(v15, dataBuffer, 1u, 0, 0, formatDescriptionOut, 1, 1, &v37, 1, &sampleSizeArray, v39);
  if ((_DWORD)TempFile)
    goto LABEL_29;
  SampleAttachmentsArray = CMSampleBufferGetSampleAttachmentsArray(v39[0], 1u);
  if (SampleAttachmentsArray)
  {
    ValueAtIndex = (__CFDictionary *)CFArrayGetValueAtIndex(SampleAttachmentsArray, 0);
    v21 = (const void *)*MEMORY[0x1E0C9AE50];
    CFDictionarySetValue(ValueAtIndex, (const void *)*MEMORY[0x1E0CA2620], (const void *)*MEMORY[0x1E0C9AE50]);
    CFDictionarySetValue(ValueAtIndex, (const void *)*MEMORY[0x1E0CA25C8], v21);
    CFDictionarySetValue(ValueAtIndex, (const void *)*MEMORY[0x1E0CA25E0], v21);
  }
  v22 = *(_QWORD *)(a6 + 48);
  v23 = *(unsigned int *)(a6 + 56);
  v24 = v39[0];
  v25 = *(uint64_t (**)(uint64_t, uint64_t, CMSampleBufferRef))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 32);
  if (!v25)
    goto LABEL_18;
  TempFile = v25(v22, v23, v24);
  if ((_DWORD)TempFile)
    goto LABEL_29;
  v26 = *(_QWORD *)(a6 + 48);
  v27 = *(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 40);
  if (v27)
  {
    TempFile = v27(v26, 0);
    if (!(_DWORD)TempFile)
    {
      v28 = *(_QWORD *)(a6 + 48);
      v29 = *(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 48);
      if (v29)
        v30 = v29(v28, 0);
      else
        v30 = 4294954514;
      *(_DWORD *)(a6 + 60) += a7;
      return v30;
    }
    goto LABEL_29;
  }
LABEL_18:
  v30 = 4294954514;
LABEL_19:
  if (*(_QWORD *)(a6 + 48))
  {
    FigFormatWriterInvalidate();
    CFRelease(*(CFTypeRef *)(a6 + 48));
  }
  v31 = *(const void **)(a6 + 40);
  if (v31)
    CFRelease(v31);
  if (*(_QWORD *)(a6 + 32))
  {
    FigFileForkClose();
    v32 = *(_DWORD *)(a6 + 64);
    if (v32)
      close(v32);
  }
  return v30;
}

const tm *_VideoReceiverUtil_GenerateTimeString(char *a1, size_t a2)
{
  const tm *result;
  time_t v5;
  uint64_t v6;

  result = 0;
  v6 = *MEMORY[0x1E0C80C00];
  if (a1 && a2)
  {
    v5 = 0xAAAAAAAAAAAAAAAALL;
    setlocale(0, "");
    time(&v5);
    result = localtime(&v5);
    if (result)
      result = (const tm *)strftime(a1, a2, "%m%d%g_%H%M%S", result);
    *((_BYTE *)&result->tm_sec + (_QWORD)a1) = 0;
  }
  return result;
}

uint64_t _VideoReceiverUtil_Generate2vuyName(char *a1, size_t a2)
{
  _QWORD v5[4];

  v5[3] = *MEMORY[0x1E0C80C00];
  memset(v5, 170, 20);
  _VideoReceiverUtil_GenerateTimeString((char *)v5, 0x14uLL);
  return snprintf(a1, a2, "%s%s-rxSourceYuv.%dx%d.%s.yuv", "/tmp/", (const char *)v5, 1, 2, "2vuy");
}

size_t _VideoReceiverUtil_GenerateBitStreamDumpName(char *a1, size_t a2, const char *a3, const char *a4)
{
  _QWORD v9[4];

  v9[3] = *MEMORY[0x1E0C80C00];
  memset(v9, 170, 20);
  _VideoReceiverUtil_GenerateTimeString((char *)v9, 0x14uLL);
  strlcpy(a1, "/tmp/vcp/", a2);
  strlcat(a1, a3, a2);
  strlcat(a1, (const char *)v9, a2);
  strlcat(a1, a4, a2);
  return strlcat(a1, "-recvBitstream.26l", a2);
}

uint64_t _VideoReceiverUtil_LogRtpMediaPacket(uint64_t result, FILE *a2, int a3)
{
  uint64_t v4;
  __int128 v5;
  unint64_t v6;
  int v7;
  int v8;
  unint64_t v9;
  uint64_t v10;
  char v11[8];
  char v12[17];
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  _BYTE v23[23];
  char v24;
  _OWORD v25[11];
  _BYTE v26[23];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v4 = result;
    result = fprintf(a2, "RTPMediaPacket header,seqNum,marker,payload,ts,arrival time,data length,total bytes,ext data length,stream index, %d, 0x%x, %d, %u, %f, %ld, %ld, %ld, %d\n", *(unsigned __int16 *)(result + 12), *(_DWORD *)result, *(_DWORD *)(result + 4), *(_DWORD *)(result + 16), *(double *)(result + 32), *(_QWORD *)(result + 152), *(_QWORD *)(result + 112), *(_QWORD *)(result + 128), a3);
    *(_QWORD *)&v26[15] = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)v26 = v5;
    v25[10] = v5;
    v25[9] = v5;
    v25[8] = v5;
    v25[7] = v5;
    v25[6] = v5;
    v25[5] = v5;
    v25[4] = v5;
    v25[3] = v5;
    v25[2] = v5;
    v25[1] = v5;
    v25[0] = v5;
    v24 = 0;
    if (*(_QWORD *)(v4 + 152))
    {
      v6 = 0;
      v7 = 0;
      v8 = 0;
      do
      {
        memset(v12, 170, 7);
        __sprintf_chk(v12, 0, 7uLL, "0x%02X, ", *(unsigned __int8 *)(*(_QWORD *)(v4 + 160) + v6));
        result = __strlcat_chk();
        if ((~(_BYTE)v6 & 0x1F) != 0)
        {
          v7 += 6;
        }
        else
        {
          *((_BYTE *)v25 + v7 + 3) = 0;
          result = fprintf(a2, "RTPMediaPacket data,sN=%d,\"DumpRow# %d -> [ %s ]\"\n", *(unsigned __int16 *)(v4 + 12), v8, &v24);
          v7 = 0;
          v24 = 0;
          ++v8;
        }
        ++v6;
      }
      while (v6 < *(_QWORD *)(v4 + 152));
      *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
      if ((v6 & 0x1F) >= 3)
      {
        v23[v7 + 21] = 0;
        result = fprintf(a2, "RTPMediaPacket data,sN=%d,\"DumpRow# %d -> [ %s ]\"\n", *(unsigned __int16 *)(v4 + 12), v8, &v24);
        *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
      }
    }
    *(_QWORD *)&v23[15] = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)v23 = v5;
    v22 = v5;
    v21 = v5;
    v20 = v5;
    v19 = v5;
    v18 = v5;
    v17 = v5;
    v16 = v5;
    v15 = v5;
    v14 = v5;
    v13 = v5;
    *(_OWORD *)&v12[1] = v5;
    v12[0] = 0;
    if (*(_QWORD *)(v4 + 128))
    {
      v9 = 0;
      v10 = -2;
      do
      {
        memset(v11, 170, 7);
        __sprintf_chk(v11, 0, 7uLL, "0x%02x, ", *(unsigned __int8 *)(*(_QWORD *)(v4 + 136) + v9));
        __strlcat_chk();
        ++v9;
        v10 += 6;
      }
      while (v9 < *(_QWORD *)(v4 + 128));
      v12[v10] = 0;
      return fprintf(a2, "RTPMediaPacket extData,sN=%d,\"{ %s }\", \n", *(unsigned __int16 *)(v4 + 12), v12);
    }
  }
  return result;
}

uint64_t VCPacketFilterGetClassID()
{
  if (VCPacketFilterGetClassID_onceToken != -1)
    dispatch_once(&VCPacketFilterGetClassID_onceToken, &__block_literal_global_45);
  return VCPacketFilterGetClassID_classID;
}

CFStringRef _VCPacketFilterCopyFormattingDescription(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[VCPacketFilter %p]"), a1);
}

void sub_1D8CD1750(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    objc_begin_catch(exception_object);
    JUMPOUT(0x1D8CD1670);
  }
  _Unwind_Resume(exception_object);
}

void sub_1D8CD1904(void *a1)
{
  objc_begin_catch(a1);
  JUMPOUT(0x1D8CD18CCLL);
}

void sub_1D8CD1914(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void OUTLINED_FUNCTION_10_9(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, &a9, 0x22u);
}

void OUTLINED_FUNCTION_11_8(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_fault_impl(a1, log, OS_LOG_TYPE_FAULT, a4, (uint8_t *)va, 0x28u);
}

double OUTLINED_FUNCTION_20(float a1)
{
  return a1;
}

_DWORD *_VCFECPacketListEntry_Allocate(OSQueueHead *a1, const void *a2, int a3)
{
  _DWORD *v5;
  _DWORD *v6;

  v5 = VCMemoryPool_Alloc(a1);
  v6 = v5;
  if (v5)
  {
    v5[2] = a3;
    *((_QWORD *)v5 + 4) = 0;
    *((_QWORD *)v5 + 5) = 0;
    *((_QWORD *)v5 + 2) = a2;
    *((_QWORD *)v5 + 3) = 0;
    CFRetain(a2);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCFECPacketListEntry_Allocate_cold_1();
  }
  return v6;
}

uint64_t VCFECPacketList_AllocateAndPush(OSQueueHead *a1, const void *a2, int a3, uint64_t a4, __int128 *a5)
{
  _DWORD *v8;
  void *v9;
  __int128 v10;
  uint64_t v11;

  v8 = _VCFECPacketListEntry_Allocate(a1, a2, a3);
  v9 = v8;
  if (!v8)
  {
    v11 = 2150825985;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCFECPacketList_AllocateAndPush_cold_1();
    }
    goto LABEL_12;
  }
  v10 = *a5;
  *((_QWORD *)v8 + 5) = *((_QWORD *)a5 + 2);
  *(_OWORD *)(v8 + 6) = v10;
  if ((VCSingleLinkedListPush(a4, v8) & 1) == 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
    {
      v11 = 2150826039;
    }
    else
    {
      VRTraceErrorLogLevelToCSTR();
      v11 = 2150826039;
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCFECPacketList_AllocateAndPush_cold_2();
    }
LABEL_12:
    VCMemoryPool_Free(a1, v9);
    return v11;
  }
  return 0;
}

uint64_t *VCFECPacketList_Flush(OSQueueHead *a1, uint64_t *a2)
{
  uint64_t *result;
  CFTypeRef *v5;

  result = VCSingleLinkedListPop(a2);
  if (result)
  {
    v5 = (CFTypeRef *)result;
    do
    {
      CFRelease(v5[2]);
      VCMemoryPool_Free(a1, v5);
      result = VCSingleLinkedListPop(a2);
      v5 = (CFTypeRef *)result;
    }
    while (result);
  }
  return result;
}

uint64_t VCFECPacketList_CompareEntries(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;
  BOOL v4;
  unsigned int v5;

  v2 = *(_DWORD *)(a1 + 8);
  v3 = *(_DWORD *)(a2 + 8);
  v4 = v2 == v3;
  v5 = 2 * (v2 >= v3);
  if (v4)
    return 1;
  else
    return v5;
}

const void *symptomReporterCallback(void *a1, CFDictionaryRef theDict)
{
  const void *Value;
  const void *result;
  BOOL v6;

  Value = CFDictionaryGetValue(theDict, CFSTR("SymptomReporterCallbackKeySymptomID"));
  result = CFDictionaryGetValue(theDict, CFSTR("SymptomReporterCallbackKeyGroupID"));
  if (Value)
    v6 = result == 0;
  else
    v6 = 1;
  if (!v6)
    return (const void *)objc_msgSend(a1, "sendSymptomToRemote:groupID:", Value, result);
  return result;
}

uint64_t VCCMDuplicationCallback_0(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend(a1, "setDuplicationFlag:withPreferredLocalLinkTypeForDuplication:notifyPeer:", a2, a3, a4);
}

void sub_1D8CD6BA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  uint64_t v26;

  _Block_object_dispose(&a22, 8);
  _Block_object_dispose(&a26, 8);
  _Block_object_dispose((const void *)(v26 - 136), 8);
  _Unwind_Resume(a1);
}

void sub_1D8CD6BE8()
{
  JUMPOUT(0x1D8CD6BD4);
}

void sub_1D8CD6BF0()
{
  JUMPOUT(0x1D8CD6BE0);
}

uint64_t WRMReportMetricsCallback(void *a1, const char *a2)
{
  return objc_msgSend(a1, "reportWRMMetrics:", a2);
}

uint64_t VCCMWRMStatusUpdateCallback_0(void *a1, const char *a2)
{
  return objc_msgSend(a1, "sendWRMStatusUpdate:", a2);
}

void sub_1D8CE35D0(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 160), 8);
  _Unwind_Resume(a1);
}

uint64_t MediaCallback(int a1, void *a2, unsigned int *a3, uint64_t a4)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  NSObject *v17;
  uint64_t v18;
  NSObject *v19;
  int v21;
  uint64_t v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (!a2)
    return 2148597761;
  v8 = objc_msgSend(a2, "callID");
  v9 = 0;
  switch(a1)
  {
    case 0:
      v10 = *a3;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v11 = VRTraceErrorLogLevelToCSTR();
        v12 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v21 = 136316162;
          v22 = v11;
          v23 = 2080;
          v24 = "MediaCallback";
          v25 = 1024;
          v26 = 4702;
          v27 = 1024;
          v28 = v8;
          v29 = 1024;
          v30 = v10;
          _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, "VCCallSession [%s] %s:%d MediaCallback: call (%08X) is not using relay for connection %d", (uint8_t *)&v21, 0x28u);
        }
      }
      objc_msgSend(a2, "handleMediaReceivedOverPeerToPeerLinkWithConnectionId:", v10);
      goto LABEL_18;
    case 1:
      if ((int)VRTraceGetErrorLogLevelForModule() < 7)
        goto LABEL_18;
      v13 = VRTraceErrorLogLevelToCSTR();
      v14 = *MEMORY[0x1E0CF2758];
      v9 = 0;
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v21 = 136315906;
        v22 = v13;
        v23 = 2080;
        v24 = "MediaCallback";
        v25 = 1024;
        v26 = 4708;
        v27 = 1024;
        v28 = v8;
        _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, "VCCallSession [%s] %s:%d MediaCallback: call (%08X) is upgraded from relay to P2P, relay will be torn down in handlePrimaryConnChange.", (uint8_t *)&v21, 0x22u);
LABEL_18:
        v9 = 0;
      }
      break;
    case 2:
      v15 = *a3;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v16 = VRTraceErrorLogLevelToCSTR();
        v17 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v21 = 136316162;
          v22 = v16;
          v23 = 2080;
          v24 = "MediaCallback";
          v25 = 1024;
          v26 = 4713;
          v27 = 1024;
          v28 = v8;
          v29 = 1024;
          v30 = v15;
          _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, "VCCallSession [%s] %s:%d MediaCallback: call (%08X) started with relay for connection %d", (uint8_t *)&v21, 0x28u);
        }
      }
      objc_msgSend(a2, "handleMediaReceivedOverRelayLinkWithConnectionId:", v15);
      goto LABEL_18;
    case 3:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v18 = VRTraceErrorLogLevelToCSTR();
        v19 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v21 = 136315906;
          v22 = v18;
          v23 = 2080;
          v24 = "MediaCallback";
          v25 = 1024;
          v26 = 4720;
          v27 = 1024;
          v28 = v8;
          _os_log_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_DEFAULT, "VCCallSession [%s] %s:%d MediaCallback: flush baseband queue for call (%08X).", (uint8_t *)&v21, 0x22u);
        }
      }
      return objc_msgSend(a2, "flushBasebandQueueWithPayloads:flushCount:", a3, a4);
    case 4:
      v9 = 2148597776;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          MediaCallback_cold_2();
          return 2148597776;
        }
      }
      return v9;
    case 5:
      return v9;
    default:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          MediaCallback_cold_1();
      }
      return 2148597761;
  }
  return v9;
}

void sub_1D8CE9A7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t VCCallSessionFillMediaControlInfoCallback(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t result;

  result = VCMediaControlInfoGeneratorGetType();
  if (!(_DWORD)result)
    return objc_msgSend(a2, "fillMediaControlInfo:", a3);
  return result;
}

uint64_t VCCallSessionProcessMediaControlInfoCallback(uint64_t a1, void *a2, uint64_t a3)
{
  return objc_msgSend(a2, "processMediaControlInfo:isAudio:", a3, VCMediaControlInfoGeneratorGetType() == 0);
}

void sub_1D8CF68C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  _Unwind_Resume(exception_object);
}

_DWORD *getMaxImageDimensions(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6)
{
  _DWORD *v12;
  _DWORD *v13;
  VCVideoRuleCollectionsCamera *v14;
  unsigned __int8 v15;
  id v16;
  uint64_t v17;
  void *v18;
  void *v19;
  VCDefaults *v20;
  unsigned int v21;
  uint64_t v23;

  v12 = malloc_type_calloc(1uLL, 0x24uLL, 0x10000408AA14F5FuLL);
  v13 = v12;
  if (v12)
  {
    *(_OWORD *)v12 = xmmword_1D910D510;
    *((_QWORD *)v12 + 2) = 0xF000000000;
    *((_QWORD *)v12 + 3) = 0x3F0000000000000FLL;
    v12[8] = a2;
    v14 = +[VCVideoRuleCollectionsCamera sharedInstance](VCVideoRuleCollectionsCamera, "sharedInstance");
    if ((_DWORD)a1 == 1)
      v15 = 1;
    else
      v15 = 2;
    v16 = objc_alloc(MEMORY[0x1E0C99DE8]);
    if ((_DWORD)a2 == 2)
      v17 = -[VCVideoRuleCollections supportedVideoRulesForBitrate:transportType:payload:encodingType:](v14, "supportedVideoRulesForBitrate:transportType:payload:encodingType:", objc_msgSend(a5, "limitingRule"), 1, a4, v15);
    else
      v17 = -[VCVideoRuleCollections getVideoRulesForTransport:payload:encodingType:](v14, "getVideoRulesForTransport:payload:encodingType:", 2, a4, v15);
    v18 = (void *)objc_msgSend(v16, "initWithArray:", v17);
    v19 = v18;
    if ((_DWORD)a1 != 1)
      remove16x9Resolutions(v18);
    if (-[VCDefaults forceHWI](+[VCDefaults sharedInstance](VCDefaults, "sharedInstance"), "forceHWI"))
    {
      v20 = +[VCDefaults sharedInstance](VCDefaults, "sharedInstance");
      v21 = (_DWORD)a1 == 1
          ? -[VCDefaults forceVideoPayload](v20, "forceVideoPayload")
          : -[VCDefaults forceRecvVideoPayload](v20, "forceRecvVideoPayload");
      if (v21 != 128 && v21 != (_DWORD)a4)
        objc_msgSend(v19, "removeAllObjects");
    }
    LOBYTE(v23) = 0;
    objc_msgSend(a3, "getNegotiatedResolutionForPayload:forInterface:withRule:direction:result:remoteSupportsHD:screenSharing:", a4, a2, v19, a1, v13, a6, v23);

    if (!v13[5] && !v13[2])
    {
      free(v13);
      return 0;
    }
  }
  return v13;
}

void remove16x9Resolutions(void *a1)
{
  id v2;
  uint64_t v3;
  __int128 v4;
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  uint64_t i;
  void *v9;
  int v10;
  BOOL v11;
  int v12;
  int v13;
  uint64_t v14;
  NSObject *v15;
  id v16;
  const char *v17;
  int v18;
  int v19;
  float v20;
  __int128 v21;
  void *v22;
  uint8_t buf[4];
  uint64_t v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  __int16 v33;
  double v34;
  _BYTE v35[128];
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v2 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  v36 = 0u;
  v37 = 0u;
  v38 = 0u;
  v39 = 0u;
  v3 = objc_msgSend(a1, "countByEnumeratingWithState:objects:count:", &v36, v35, 16);
  if (v3)
  {
    v5 = v3;
    v6 = *(_QWORD *)v37;
    v7 = "VCCallSession";
    *(_QWORD *)&v4 = 136316418;
    v21 = v4;
    v22 = a1;
    do
    {
      for (i = 0; i != v5; ++i)
      {
        if (*(_QWORD *)v37 != v6)
          objc_enumerationMutation(a1);
        v9 = *(void **)(*((_QWORD *)&v36 + 1) + 8 * i);
        v10 = (int)(9 * objc_msgSend(v9, "iWidth", v21)) / 16;
        v12 = v10 + 15;
        v11 = v10 < -15;
        v13 = v10 + 30;
        if (!v11)
          v13 = v12;
        if (objc_msgSend(v9, "iHeight") == (v13 & 0xFFFFFFF0))
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
          {
            v14 = VRTraceErrorLogLevelToCSTR();
            v15 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              v16 = v2;
              v17 = v7;
              v18 = objc_msgSend(v9, "iWidth");
              v19 = objc_msgSend(v9, "iHeight");
              objc_msgSend(v9, "fRate");
              *(_DWORD *)buf = v21;
              v24 = v14;
              v25 = 2080;
              v26 = "remove16x9Resolutions";
              v27 = 1024;
              v28 = 5774;
              v29 = 1024;
              v30 = v18;
              v7 = v17;
              v2 = v16;
              a1 = v22;
              v31 = 1024;
              v32 = v19;
              v33 = 2048;
              v34 = v20;
              _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, "VCCallSession [%s] %s:%d Removing resolution %dx%d %f for SDP", buf, 0x32u);
            }
          }
          objc_msgSend(v2, "addObject:", v9);
        }
      }
      v5 = objc_msgSend(a1, "countByEnumeratingWithState:objects:count:", &v36, v35, 16);
    }
    while (v5);
  }
  objc_msgSend(a1, "removeObjectsInArray:", v2);

}

_DWORD *addWifiInterfaceForImageDimensions(_DWORD *result, int a2, char a3, void *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v16;
  _DWORD *v17;
  uint64_t v18;
  void *v19;
  float v20;
  int v21;
  int v22;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;

  if (a2 >= 1)
  {
    v24 = v11;
    v25 = v10;
    v26 = v9;
    v27 = v8;
    v28 = v7;
    v29 = v6;
    v30 = v5;
    v31 = v4;
    v32 = v12;
    v33 = v13;
    v16 = 0;
    v17 = result + 5;
    v18 = a2;
    while (1)
    {
      result = (_DWORD *)objc_msgSend(a4, "objectAtIndexedSubscript:", v16, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33);
      v19 = result;
      if ((a3 & 1) == 0)
        break;
      if (result)
        goto LABEL_5;
LABEL_6:
      ++v16;
      v17 += 9;
      if (v18 == v16)
        return result;
    }
    v22 = objc_msgSend(result, "iWidth");
    result = (_DWORD *)objc_msgSend(v19, "iHeight");
    if ((int)result * v22 > 307200 || v19 == 0)
      goto LABEL_6;
LABEL_5:
    *(v17 - 5) = objc_msgSend(v19, "iWidth");
    *(v17 - 3) = objc_msgSend(v19, "iWidth");
    *(v17 - 2) = objc_msgSend(v19, "iHeight");
    *v17 = objc_msgSend(v19, "iHeight");
    objc_msgSend(v19, "fRate");
    v17[1] = (int)v20;
    result = (_DWORD *)objc_msgSend(v19, "fPref");
    v17[2] = v21;
    v17[3] = 2;
    goto LABEL_6;
  }
  return result;
}

void **addCellInterfaceForImageDimensions(void **result, int *a2, int a3, void *a4)
{
  void **v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int *v10;
  void **v11;
  uint64_t v12;
  void **v13;
  void *v14;
  int v15;
  _DWORD *v16;
  int v17;
  _DWORD *v18;
  float v19;
  uint64_t v20;
  int v21;
  _BYTE v22[128];
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;

  v6 = result;
  v27 = *MEMORY[0x1E0C80C00];
  LODWORD(v7) = *a2;
  if (*a2 >= 1)
  {
    v8 = 0;
    if (a3 == 100)
      v9 = 1;
    else
      v9 = 2;
    v10 = (int *)((char *)*result + 32);
    do
    {
      *v10 = v9;
      v10 += 9;
      ++v8;
      v7 = *a2;
    }
    while (v8 < v7);
  }
  if (a3 == 123)
  {
    *result = malloc_type_realloc(*result, 36 * (objc_msgSend(a4, "count") + (int)v7), 0x10000408AA14F5FuLL);
    v23 = 0u;
    v24 = 0u;
    v25 = 0u;
    v26 = 0u;
    result = (void **)objc_msgSend(a4, "countByEnumeratingWithState:objects:count:", &v23, v22, 16);
    if (result)
    {
      v11 = result;
      v12 = *(_QWORD *)v24;
      do
      {
        v13 = 0;
        do
        {
          if (*(_QWORD *)v24 != v12)
            objc_enumerationMutation(a4);
          v14 = *(void **)(*((_QWORD *)&v23 + 1) + 8 * (_QWORD)v13);
          *((_DWORD *)*v6 + 9 * *a2 + 2) = objc_msgSend(v14, "iWidth");
          v15 = objc_msgSend(v14, "iWidth");
          v16 = *v6;
          v16[9 * *a2] = v15;
          v16[9 * *a2 + 1] = 0;
          *((_DWORD *)*v6 + 9 * *a2 + 5) = objc_msgSend(v14, "iHeight");
          v17 = objc_msgSend(v14, "iHeight");
          v18 = *v6;
          *((_DWORD *)*v6 + 9 * *a2 + 3) = v17;
          v18[9 * *a2 + 4] = 0;
          objc_msgSend(v14, "fRate");
          *((_DWORD *)*v6 + 9 * *a2 + 6) = (int)v19;
          objc_msgSend(v14, "fPref");
          v20 = (uint64_t)*v6 + 36 * *a2;
          *(_DWORD *)(v20 + 28) = v21;
          *(_DWORD *)(v20 + 32) = 1;
          ++*a2;
          v13 = (void **)((char *)v13 + 1);
        }
        while (v11 != v13);
        result = (void **)objc_msgSend(a4, "countByEnumeratingWithState:objects:count:", &v23, v22, 16);
        v11 = result;
      }
      while (result);
    }
  }
  return result;
}

uint64_t OUTLINED_FUNCTION_16_3@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  *(_QWORD *)(v2 - 24) = a2;
  return *(_QWORD *)a1;
}

void OUTLINED_FUNCTION_19_0(float a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(float *)a3 = a1;
  *(_QWORD *)(a3 + 4) = a4;
  *(_WORD *)(a3 + 12) = 2080;
}

uint64_t OUTLINED_FUNCTION_21(uint64_t result, uint64_t a2)
{
  __int16 v2;
  int v3;

  *(_DWORD *)(a2 + 24) = v3;
  *(_WORD *)(a2 + 28) = v2;
  *(_QWORD *)(a2 + 30) = result;
  return result;
}

void OUTLINED_FUNCTION_22(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_fault_impl(a1, v9, OS_LOG_TYPE_FAULT, a4, &a9, 0x26u);
}

void OUTLINED_FUNCTION_23(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_QWORD *)(a2 + 14) = v2;
  *(_WORD *)(a2 + 22) = 1024;
}

void OUTLINED_FUNCTION_42(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, a5, 0x26u);
}

uint64_t OUTLINED_FUNCTION_43(uint64_t a1, void *a2)
{
  return objc_msgSend(a2, "description");
}

uint64_t RTPSendUncompressedVideoPacket(uint64_t a1, char a2, int a3, int a4, void *a5, signed int a6, _DWORD *a7, const void *a8, double a9, unsigned __int8 a10, int a11, int a12, unsigned __int8 a13, _DWORD *a14, int a15, uint64_t a16, int a17, uint64_t a18, uint64_t a19, __int128 *a20,char a21,int a22)
{
  uint64_t v22;
  uint64_t v32;
  unint64_t v33;
  unsigned int v34;
  uint64_t v35;
  NSObject *v36;

  v22 = a18;
  if (a7)
  {
    *a7 = 0;
    v32 = CheckInHandleDebug();
    if (v32 == 0xFFFFFFFFLL)
    {
      VCMediaControlInfoDispose(a18);
      return 2147549190;
    }
    else if (v32)
    {
      v33 = 2147549198;
      if (a6 < 1)
      {
        v33 = 2147549199;
      }
      else
      {
        *(_WORD *)(v32 + 16) = *(_WORD *)(v32 + 16) & 0x80FF | ((a2 & 0x7F) << 8);
        v34 = (a2 & 0x7F) - 110;
        if (v34 <= 0xF && ((1 << v34) & 0xC001) != 0)
        {
          if (a6 < 0x5B5)
          {
            v33 = SendRTP(a1, v32, a3, a4, 0, 0, a5, a6, a9, a7, a8, a10, a11, a12, a13, a14, a15, a16, a17,
                    a18,
                    a19,
                    a20,
                    a21,
                    a22);
            v22 = 0;
          }
          else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            v35 = VRTraceErrorLogLevelToCSTR();
            v36 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              RTPSendUncompressedVideoPacket_cold_1(v35, a6 + 12, v36);
          }
        }
        else
        {
          v33 = 2147549199;
        }
      }
      VCMediaControlInfoDispose(v22);
      CheckOutHandleDebug();
    }
    else
    {
      VCMediaControlInfoDispose(a18);
      return 2147549186;
    }
  }
  else
  {
    VCMediaControlInfoDispose(a18);
    return 2147549185;
  }
  return v33;
}

void sub_1D8CFF5B4(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1D8CFFEC8(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1D8D035C0(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

double VCRateControlAlgorithmBasePriv_StateEnter(uint64_t a1)
{
  double result;

  if (*(_DWORD *)(a1 + 1040) == 3)
  {
    result = *(double *)(a1 + 1096);
    *(double *)(a1 + 1104) = result;
  }
  return result;
}

void VCRateControlAlgorithmBasePriv_StateExit(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v9;

  if (*(_DWORD *)(a1 + 1040) == 1)
  {
    VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Initial Rampup done!", a3, a4, a5, a6, a7, a8, v9);
    if (!*(_BYTE *)(a1 + 1122))
      *(_BYTE *)(a1 + 1122) = 1;
  }
}

double VCRateControlAlgorithmBasePriv_CheckPaused(uint64_t a1)
{
  _BOOL4 IsPaused;
  double result;
  int v4;
  BOOL v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  int ErrorLogLevelForModule;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  NSObject *v22;
  int v23;
  uint64_t v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  int v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 1040) != 1)
  {
    IsPaused = VCRateControlAlgorithm_IsPaused(a1);
    v4 = *(_DWORD *)(a1 + 1040);
    if (v4)
      v5 = !IsPaused;
    else
      v5 = 1;
    if (v5)
    {
      if (!v4)
      {
        if (!IsPaused || (result = *(double *)(a1 + 1096) - *(double *)(a1 + 1032), result > *(double *)(a1 + 656)))
        {
          (*(void (**)(uint64_t))(a1 + 32))(a1);
          *(_DWORD *)(a1 + 1040) = 3;
          (*(void (**)(uint64_t))(a1 + 24))(a1);
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v12 = VRTraceErrorLogLevelToCSTR();
            v13 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              v23 = 136315650;
              v24 = v12;
              v25 = 2080;
              v26 = "VCRateControlAlgorithmBasePriv_CheckPaused";
              v27 = 1024;
              v28 = 110;
              _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Resume VCRateControl algorithm", (uint8_t *)&v23, 0x1Cu);
            }
          }
          VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Resume rate control algorithm", v6, v7, v8, v9, v10, v11, v23);
          VCRateControlAlgorithm_SetPaused(a1, 0);
        }
      }
    }
    else
    {
      (*(void (**)(uint64_t))(a1 + 32))(a1);
      *(_DWORD *)(a1 + 1040) = 0;
      (*(void (**)(uint64_t))(a1 + 24))(a1);
      ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
      if (ErrorLogLevelForModule >= 7)
      {
        v21 = VRTraceErrorLogLevelToCSTR();
        v22 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v23 = 136315650;
          v24 = v21;
          v25 = 2080;
          v26 = "VCRateControlAlgorithmBasePriv_CheckPaused";
          v27 = 1024;
          v28 = 104;
          _os_log_impl(&dword_1D8A54000, v22, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Pause VCRateControl algorithm", (uint8_t *)&v23, 0x1Cu);
        }
      }
      VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Pause rate control algorithm", v15, v16, v17, v18, v19, v20, v23);
      result = *(double *)(a1 + 1096);
      *(double *)(a1 + 1032) = result;
    }
  }
  return result;
}

BOOL VCRateControlAlgorithm_IsPaused(uint64_t a1)
{
  unsigned __int8 v1;
  _BOOL8 result;

  if (a1)
  {
    v1 = atomic_load((unsigned __int8 *)(a1 + 1024));
    return v1 & 1;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    VCRateControlAlgorithm_IsPaused_cold_1();
  }
  return 0;
}

uint64_t VCRateControlAlgorithmBasePriv_StateChange(uint64_t result, int a2)
{
  uint64_t v3;

  if (*(_DWORD *)(result + 1040) != a2)
  {
    v3 = result;
    (*(void (**)(void))(result + 32))();
    *(_DWORD *)(v3 + 1040) = a2;
    return (*(uint64_t (**)(uint64_t))(v3 + 24))(v3);
  }
  return result;
}

void VCRateControlAlgorithmBasePriv_LogToDumpFiles(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19[2];

  v19[1] = *(char **)MEMORY[0x1E0C80C00];
  if (a2)
  {
    v19[0] = 0;
    vasprintf(v19, a2, &a9);
    v16 = v19[0];
    if (v19[0])
    {
      v17 = *(_QWORD *)(a1 + 5112);
      if (v17)
      {
        VRLogfilePrint(v17, "%s\n", v10, v11, v12, v13, v14, v15, (char)v19[0]);
        v16 = v19[0];
      }
      v18 = *(_QWORD *)(a1 + 5120);
      if (v18)
      {
        VRLogfilePrint(v18, "%s\n", v10, v11, v12, v13, v14, v15, (char)v16);
        v16 = v19[0];
      }
      free(v16);
    }
  }
}

void VCRateControlAlgorithm_SetPaused(uint64_t a1, unsigned __int8 a2)
{
  if (a1)
  {
    atomic_store(a2, (unsigned __int8 *)(a1 + 1024));
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlAlgorithm_SetPaused_cold_1();
  }
}

void VCRateControlAlgorithm_EnableLogDump(uint64_t a1, uint64_t a2, char a3)
{
  if (a1)
  {
    if (a2)
      *(_QWORD *)(a1 + 5112) = a2;
    *(_BYTE *)(a1 + 5128) = a3;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlAlgorithm_EnableLogDump_cold_1();
  }
}

void VCRateControlAlgorithm_EnableBasebandDump(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  int v6;
  uint64_t v7;
  __int16 v8;
  const char *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  uint64_t v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (a1 && a2)
  {
    *(_QWORD *)(a1 + 5120) = a2;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      v6 = 136316162;
      v7 = v4;
      v8 = 2080;
      v9 = "VCRateControlAlgorithm_EnableBasebandDump";
      v10 = 1024;
      v11 = 129;
      v12 = 2048;
      v13 = a1;
      v14 = 2048;
      v15 = a2;
      _os_log_error_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_ERROR, "VCRC [%s] %s:%d Invalid parameter. algorithm=%p logBasebandDump=%p", (uint8_t *)&v6, 0x30u);
    }
  }
}

double VCRateControlAlgorithmBasePriv_GetDoubleTimeFromTimestamp(unsigned int a1, unsigned int a2, unsigned int a3)
{
  return (double)a1 / (double)a2 + (double)a3 * 64.0;
}

uint64_t VCRateControlAlgorithmBasePriv_GetTimestampFromMicroTime(double a1)
{
  unint64_t v1;

  v1 = MicroToNTP(a1);
  return (unsigned __int16)(NTPToMiddle32(v1) >> 6);
}

double VCRateControlAlgorithmBasePriv_CalculateCongestionMetrics(uint64_t a1, double a2, double a3)
{
  _BOOL4 v4;
  __int128 v5;

  *(_QWORD *)(a1 + 2832) = *(_QWORD *)(a1 + 2880);
  v4 = VCRateControlUtil_CalculateCongestionMetrics(a1 + 1200, a1 + 40, *(_DWORD *)(a1 + 1040) == 1, a2, a3);
  *(_BYTE *)(a1 + 2848) = v4;
  if (v4)
  {
    *(_QWORD *)(a1 + 2864) = *(_QWORD *)(a1 + 2816);
    v5 = *(_OWORD *)(a1 + 2824);
    *(_OWORD *)(a1 + 2872) = v5;
    if (*(double *)(a1 + 2856) <= 0.0)
    {
      *(_BYTE *)(a1 + 2849) = 0;
LABEL_6:
      *(_QWORD *)&v5 = *(_QWORD *)(a1 + 1096);
      *(_QWORD *)(a1 + 2888) = v5;
      return *(double *)&v5;
    }
    *(_BYTE *)(a1 + 2849) = *(double *)&v5 == 0.0;
    if (*(double *)&v5 != 0.0)
      goto LABEL_6;
  }
  return *(double *)&v5;
}

uint64_t VCRateControlAlgorithmBasePriv_CheckBandwidthOvershoot(uint64_t result, unsigned int a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  double v6;
  unsigned int v7;
  int v8;
  double v9;

  if (a2)
  {
    v2 = *(_DWORD *)(result + 1052);
    if (v2 >= 48)
      v3 = 48;
    else
      v3 = *(_DWORD *)(result + 1052);
    v4 = v3 + 1;
    v5 = *(_QWORD *)(result + 48);
    v6 = *(double *)(result + 176);
    v7 = ((double)*(unsigned int *)(result + 1072)
                      + (double)(*(_DWORD *)(v5 + 4 * v4) - *(_DWORD *)(result + 1072)) * v6);
    *(_BYTE *)(result + 1193) = v7 > a2;
    if (v7 <= a2)
      *(_QWORD *)(result + 1176) = *(_QWORD *)(result + 1096);
    v8 = *(_DWORD *)(result + 240) + v2;
    if (v8 >= 48)
      v8 = 48;
    v9 = (double)*(unsigned int *)(v5 + 4 * v8)
       + (double)(*(_DWORD *)(v5 + 4 * v8 + 4) - *(_DWORD *)(v5 + 4 * v8)) * v6;
    *(_BYTE *)(result + 1192) = v9 < a2;
    if (v9 >= a2)
    {
      *(_QWORD *)(result + 1184) = 0;
    }
    else if (*(double *)(result + 1184) == 0.0)
    {
      *(_QWORD *)(result + 1184) = *(_QWORD *)(result + 1096);
    }
  }
  else
  {
    *(_QWORD *)(result + 1176) = *(_QWORD *)(result + 1096);
    *(_BYTE *)(result + 1192) = 0;
  }
  return result;
}

BOOL VCRateControlAlgorithmBasePriv_KeepOvershootingRampDownBandwidth(uint64_t a1)
{
  return *(_BYTE *)(a1 + 410)
      && *(_DWORD *)(a1 + 1168)
      && *(double *)(a1 + 1096) - *(double *)(a1 + 1176) > *(double *)(a1 + 168);
}

BOOL VCRateControlAlgorithmBasePriv_RecentlyGoAboveRampUpBandwidth(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 1040) == 1 && !*(_BYTE *)(a1 + 1122)
    || !*(_DWORD *)(a1 + 1168)
    || !*(_BYTE *)(a1 + 410)
    || VCRateControlMediaController_IsVideoStopped(*(_BYTE **)(a1 + 1016)))
  {
    return 0;
  }
  if (*(_BYTE *)(a1 + 1192))
    return *(double *)(a1 + 1096) - *(double *)(a1 + 1184) < *(double *)(a1 + 224);
  return 1;
}

uint64_t VCRateControlAlgorithmBasePriv_UpdateLossEvent(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  double v6;
  double v7;
  BOOL v8;
  double v9;
  double v10;

  if (*(double *)(result + 5072) > 0.0)
  {
    v1 = *(unsigned int *)(result + 4944);
    v2 = result + 2896 + 32 * v1;
    v3 = *(_QWORD *)(result + 4992);
    *(_QWORD *)v2 = *(_QWORD *)(result + 1096);
    *(_QWORD *)(v2 + 8) = v3;
    v4 = *(unsigned __int8 *)(result + 5104);
    if (*(_BYTE *)(result + 5104))
      v5 = *(_QWORD *)(result + 5056);
    else
      v5 = 0;
    *(_QWORD *)(v2 + 16) = v5;
    v6 = *(double *)(result + 4992);
    v7 = *(double *)(result + 5000);
    v8 = v7 > 0.0;
    if (v6 - v7 <= 0.001)
      v8 = 0;
    *(_BYTE *)(v2 + 24) = v8;
    *(_DWORD *)(v2 + 26) = *(_DWORD *)(result + 4980);
    v9 = v6;
    if (v4)
    {
      v9 = *(double *)(result + 5056);
      if (v6 >= v9)
        v9 = v6;
    }
    v10 = *(double *)(result + 5016);
    if (v10 != -1.0)
      v9 = v9 * 0.03 + v10 * 0.97;
    *(double *)(result + 5016) = v9;
    *(_DWORD *)(result + 4944) = ((_BYTE)v1 + 1) & 0x3F;
    *(double *)(result + 5000) = v6;
  }
  return result;
}

void VCRateControlAlgorithmBasePriv_ResetLossEventBuffer(uint64_t a1)
{
  bzero((void *)(a1 + 2896), 0x800uLL);
  *(_DWORD *)(a1 + 4944) = 0;
}

void VCRateControlAlgorithmBasePriv_ResetOWRDList(uint64_t a1)
{
  bzero((void *)(a1 + 1200), 0x670uLL);
}

uint64_t VCRateControlAlgorithmBasePriv_AllowRampUpWithContinuousTargetBitrate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  double v8;
  int v9;
  int v10;
  unsigned int v11;

  if (*(double *)(a1 + 4960) != 0.0)
  {
    v8 = *(double *)(a1 + 1064);
    if (*(_DWORD *)(a1 + 1072) != v8)
    {
      v9 = *(_DWORD *)(a1 + 1052);
      if (v9 + 1 < *(_DWORD *)(a1 + 60))
        v10 = v9 + 1;
      else
        v10 = *(_DWORD *)(a1 + 60);
      v11 = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * v10);
      if (v8 <= (double)v11)
      {
        VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "LossEventRampUp is blocked due to continuousTargetBitrate=%u, currentTargetBitrate=%u, nextTargetBitrate=%u, bandwidthLimit=%u, confidence=%u", a3, a4, a5, a6, a7, a8, v8);
        return 0;
      }
      *(double *)(a1 + 1064) = (double)v11;
    }
  }
  return 1;
}

uint64_t VCRateControlAlgorithmBasePriv_ShouldBlockRampUpDueToLossEventThreshold(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  double v8;
  _BOOL8 v9;
  int v10;
  double v11;

  if (*(double *)(a1 + 256) == 0.0 || *(double *)(a1 + 4960) <= 0.0)
    return 0;
  v8 = *(double *)(a1 + 5016);
  v9 = v8 > *(double *)(a1 + 736);
  v10 = *(_DWORD *)(a1 + 248);
  if (*(_DWORD *)(a1 + 4968) >= v10)
  {
    if (v8 <= *(double *)(a1 + 752))
    {
      if (*(double *)(a1 + 4992) > *(double *)(a1 + 5008))
        return 1;
    }
    else
    {
      *(double *)(a1 + 5040) = v8;
      v11 = v8 * 3.0;
      if (v8 * 3.0 >= *(double *)(a1 + 744))
        v11 = *(double *)(a1 + 744);
      *(double *)(a1 + 5008) = v11;
      *(_QWORD *)(a1 + 4960) = 0;
      *(_QWORD *)(a1 + 4972) = 0;
      VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "LossEventRampDown no use and tried ramped down with badTrendCount=%d, nullify lossEventRampDown RTT=%f, avgPLR=%f, previous avgPLR=%f, PLRThreshold=%f", a3, a4, a5, a6, a7, a8, v10);
    }
  }
  return v9;
}

uint64_t VCRateControlAlgorithmBasePriv_ShouldRampDownDueToLossEvent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  int v10;
  int i;
  _BOOL4 v12;
  double v13;
  int v14;
  int v15;
  double v16;
  int v17;
  int v19;
  int v20;
  uint64_t v21;
  int v22;
  double v23;
  double v24;
  double v25;
  uint64_t v26;
  double v27;
  double v28;
  BOOL v29;
  int v30;
  double v31;
  BOOL v32;
  uint64_t v33;
  double v34;
  double v35;
  uint64_t v36;
  int v37;
  unsigned int v38;
  unsigned int v39;
  int v40;
  double v41;
  unsigned int v42;
  unsigned int v43;

  v9 = *(_DWORD *)(a1 + 244);
  if (v9 < 1)
    goto LABEL_8;
  v10 = 0;
  for (i = -1; i != -65; --i)
  {
    if (v9 + i == -1)
      break;
    v10 += *(unsigned __int8 *)(a1 + 2896 + 32 * (((_BYTE)i + *(_DWORD *)(a1 + 4944)) & 0x3F) + 24);
  }
  if (v10 < v9 || *(double *)(a1 + 2864) <= *(double *)(a1 + 272))
LABEL_8:
    v12 = 0;
  else
    v12 = *(_DWORD *)(a1 + 1052) >= *(_DWORD *)(a1 + 112);
  v13 = *(double *)(a1 + 256);
  if (v13 == 0.0
    || (v14 = *(_DWORD *)(a1 + 4968), v14 >= *(_DWORD *)(a1 + 248))
    || (v15 = *(_DWORD *)(a1 + 1040), v15 == 5)
    || (v16 = *(double *)(a1 + 4960), v16 == 0.0)
    && (v15 == 3 || *(double *)(a1 + 1096) - *(double *)(a1 + 1144) < *(double *)(a1 + 472)))
  {
    v17 = 0;
  }
  else
  {
    v19 = 0;
    v20 = 0;
    v21 = a1 + 2896;
    v22 = *(_DWORD *)(a1 + 4944) - 1;
    v23 = 0.0;
    v24 = 0.0;
    while (1)
    {
      v25 = *(double *)(v21 + 32 * (((_BYTE)v22 + (_BYTE)v19) & 0x3F));
      if (!v19)
        v24 = *(double *)(v21 + 32 * (v22 & 0x3F));
      if (v25 == 0.0)
        break;
      if (v24 - v25 > *(double *)(a1 + 264))
      {
        v30 = -v19;
        if (v30 < 2)
          break;
        goto LABEL_32;
      }
      v26 = v21 + 32 * (((_BYTE)v22 + (_BYTE)v19) & 0x3F);
      v27 = *(double *)(v26 + 8);
      v28 = *(double *)(a1 + 5008);
      v29 = v27 >= 0.95 || v27 <= v28;
      if (!v29 || *(double *)(v26 + 16) > v28)
        ++v20;
      if (--v19 == -64)
      {
        v30 = 64;
LABEL_32:
        v23 = (double)v20 / (double)v30;
        break;
      }
    }
    if (v23 < v13 || *(double *)(a1 + 2864) <= *(double *)(a1 + 272))
    {
      v17 = 0;
    }
    else
    {
      v31 = *(double *)(a1 + 5016);
      if (v31 >= *(double *)(a1 + 5008))
      {
        if (v16 == 0.0)
        {
          VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "LossEventRampDown start ramping down with RTT=%f, avgPLR=%f, PLRThreshold=%f, ratio=%f", a3, a4, a5, a6, a7, a8, *(_QWORD *)(a1 + 5072));
        }
        else
        {
          v32 = v31 > *(double *)(a1 + 5024) && v31 > *(double *)(a1 + 752);
          *(_DWORD *)(a1 + 4968) = v14 + (v32 || *(double *)(a1 + 5032) < v31);
          VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "LossEventRampDown doesn't seem to stabilized yet with RTT=%f, avgPLR=%f, previousAvgPLR=%f, PLRThreshold=%f, badTrendCount=%d, PLR trend is going %s, %s improvement", a3, a4, a5, a6, a7, a8, *(_QWORD *)(a1 + 5072));
        }
      }
      else
      {
        VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "LossEventRampDown ramping down may be too aggressive with RTT=%f, avgPLR=%f, PLRThreshold=%f", a3, a4, a5, a6, a7, a8, *(_QWORD *)(a1 + 5072));
      }
      v16 = *(double *)(a1 + 4960);
      v33 = *(_QWORD *)(a1 + 5016);
      if (v16 == 0.0)
      {
        v16 = *(double *)(a1 + 1096);
        *(double *)(a1 + 4960) = v16;
        *(_QWORD *)(a1 + 5032) = v33;
      }
      *(_QWORD *)(a1 + 5024) = v33;
      v17 = 1;
    }
    if (v16 > 0.0)
    {
      v34 = *(double *)(a1 + 736);
      v35 = *(double *)(a1 + 5008);
      if (v35 >= *(double *)(a1 + 5016))
        v35 = *(double *)(a1 + 5016);
      if (v34 < v35)
        v34 = v35;
      *(double *)(a1 + 5008) = v34;
    }
    if (v17)
    {
      v36 = *(int *)(a1 + 112);
      v37 = *(_DWORD *)(a1 + 1052);
      if (v37 >= (int)v36 && *(_DWORD *)(a1 + 1080) >= *(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * v36))
      {
        if (*(_DWORD *)(a1 + 1056) < v37)
        {
          v38 = *(_DWORD *)(a1 + 1072);
          v39 = *(_DWORD *)(a1 + 4972);
          if (v39)
          {
            if ((int)(v38 - v39) >= 0)
              v40 = v38 - v39;
            else
              v40 = v39 - v38;
            v41 = (double)v39;
            if ((double)v39 * 0.35 <= (double)v40)
              v42 = 0;
            else
              v42 = *(_DWORD *)(a1 + 4976) + 1;
            if (v42 >= 0xA)
              v42 = 10;
            *(_DWORD *)(a1 + 4976) = v42;
            v43 = ((double)v38 * 0.5 + v41 * 0.5);
            *(_DWORD *)(a1 + 4972) = v43;
            VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "LossEventRampDown update bandwidth limit=%u, confidence=%u, diff=%d", a3, a4, a5, a6, a7, a8, v43);
          }
          else
          {
            *(_DWORD *)(a1 + 4972) = v38;
            ++*(_DWORD *)(a1 + 4976);
          }
        }
        v17 = 1;
      }
      else
      {
        bzero((void *)(a1 + 2896), 0x800uLL);
        v17 = 0;
        *(_DWORD *)(a1 + 4944) = 0;
      }
    }
  }
  return v12 | v17;
}

uint64_t VCRateControlAlgorithmBasePriv_UpdateCongestionStatusWhenRampUp(uint64_t result)
{
  unsigned int v1;
  unsigned int v2;
  int v3;
  unsigned int v4;
  double v5;
  double v6;
  double v7;
  BOOL v8;
  double v9;
  double v10;

  *(_DWORD *)(result + 1124) = 0;
  *(_QWORD *)(result + 1128) = 0;
  v1 = *(_DWORD *)(result + 1072);
  v2 = *(_DWORD *)(result + 4972);
  v3 = v1 - v2;
  if ((int)(v1 - v2) < 0)
    v3 = v2 - v1;
  if ((double)v2 * 0.35 > (double)v3 && (v4 = *(_DWORD *)(result + 4976)) != 0)
  {
    v5 = *(double *)(result + 1064);
    v6 = (double)v3 * 0.16 / v5 / (double)v4;
    v7 = v6 + 1.0;
    v8 = v6 < 0.01;
    v9 = 1.01;
    if (!v8)
      v9 = v7;
    v10 = v5 * v9;
  }
  else
  {
    v10 = (double)v1;
  }
  *(double *)(result + 1064) = v10;
  return result;
}

double VCRateControlAlgorithmBasePriv_UpdateCongestionStatusWhenRampDown(uint64_t a1, double a2)
{
  unsigned int v2;
  double v3;
  double result;

  v2 = *(_DWORD *)(a1 + 1124) + 1;
  *(_DWORD *)(a1 + 1124) = v2;
  v3 = *(double *)(a1 + 1128);
  if (v3 == 0.0)
  {
    *(double *)(a1 + 1128) = a2;
  }
  else if (a2 - v3 >= *(double *)(a1 + 184))
  {
    *(_DWORD *)(a1 + 1124) = 0;
    *(_QWORD *)(a1 + 1128) = 0;
  }
  else if (v2 >= *(_DWORD *)(a1 + 360))
  {
    *(_BYTE *)(a1 + 1112) = 1;
    *(double *)(a1 + 1136) = a2;
  }
  LODWORD(a2) = *(_DWORD *)(a1 + 1072);
  result = (double)*(unint64_t *)&a2;
  *(double *)(a1 + 1064) = result;
  return result;
}

void VCRateControlAlgorithm_Configure(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  int v6;
  uint64_t v7;
  __int16 v8;
  const char *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  uint64_t v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (a1 && a2)
  {
    (*(void (**)(uint64_t, uint64_t))(a1 + 8))(a1, a2);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      v6 = 136316162;
      v7 = v4;
      v8 = 2080;
      v9 = "VCRateControlAlgorithm_Configure";
      v10 = 1024;
      v11 = 546;
      v12 = 2048;
      v13 = a1;
      v14 = 2048;
      v15 = a2;
      _os_log_error_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_ERROR, "VCRC [%s] %s:%d Invalid parameter. algorithm=%p configuration=%p", (uint8_t *)&v6, 0x30u);
    }
  }
}

uint64_t VCRateControlAlgorithm_DoRateControl(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  NSObject *v6;
  int v7;
  uint64_t v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  uint64_t v14;
  __int16 v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (a1 && a2)
    return (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 16))(a1, a2);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v5 = VRTraceErrorLogLevelToCSTR();
    v6 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      v7 = 136316162;
      v8 = v5;
      v9 = 2080;
      v10 = "VCRateControlAlgorithm_DoRateControl";
      v11 = 1024;
      v12 = 554;
      v13 = 2048;
      v14 = a1;
      v15 = 2048;
      v16 = a2;
      _os_log_error_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_ERROR, "VCRC [%s] %s:%d Invalid parameter. algorithm=%p statistics=%p", (uint8_t *)&v7, 0x30u);
    }
  }
  return 0;
}

uint64_t VCCaptionsSegmentBlobReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  int v15;
  unint64_t v17;
  char v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char v23;
  void *String;
  char v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  char v30;
  uint64_t result;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        v14 = v9++ >= 9;
        if (v14)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      v17 = v10 >> 3;
      if ((v10 >> 3) == 3)
      {
        String = (void *)PBReaderReadString();

        *(_QWORD *)(a1 + 16) = String;
      }
      else if ((_DWORD)v17 == 2)
      {
        v25 = 0;
        v26 = 0;
        v27 = 0;
        *(_BYTE *)(a1 + 28) |= 2u;
        while (1)
        {
          v28 = *v3;
          v29 = *(_QWORD *)(a2 + v28);
          if (v29 == -1 || v29 >= *(_QWORD *)(a2 + *v4))
            break;
          v30 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v29);
          *(_QWORD *)(a2 + v28) = v29 + 1;
          v27 |= (unint64_t)(v30 & 0x7F) << v25;
          if ((v30 & 0x80) == 0)
            goto LABEL_43;
          v25 += 7;
          v14 = v26++ >= 9;
          if (v14)
          {
            v27 = 0;
            goto LABEL_45;
          }
        }
        *(_BYTE *)(a2 + *v5) = 1;
LABEL_43:
        if (*(_BYTE *)(a2 + *v5))
          v27 = 0;
LABEL_45:
        *(_BYTE *)(a1 + 24) = v27 != 0;
      }
      else if ((_DWORD)v17 == 1)
      {
        v18 = 0;
        v19 = 0;
        v20 = 0;
        *(_BYTE *)(a1 + 28) |= 1u;
        while (1)
        {
          v21 = *v3;
          v22 = *(_QWORD *)(a2 + v21);
          if (v22 == -1 || v22 >= *(_QWORD *)(a2 + *v4))
            break;
          v23 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v22);
          *(_QWORD *)(a2 + v21) = v22 + 1;
          v20 |= (unint64_t)(v23 & 0x7F) << v18;
          if ((v23 & 0x80) == 0)
            goto LABEL_39;
          v18 += 7;
          v14 = v19++ >= 9;
          if (v14)
          {
            LODWORD(v20) = 0;
            goto LABEL_41;
          }
        }
        *(_BYTE *)(a2 + *v5) = 1;
LABEL_39:
        if (*(_BYTE *)(a2 + *v5))
          LODWORD(v20) = 0;
LABEL_41:
        *(_DWORD *)(a1 + 8) = v20;
      }
      else
      {
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
      }
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void sub_1D8D16258(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t OUTLINED_FUNCTION_13_5(uint64_t a1, id *a2)
{
  return objc_msgSend(*a2, "userInfo");
}

uint64_t _VCMediaQueuePacketBundler_BundlePacketsWithNonePolicy(uint64_t a1, uint64_t a2)
{
  _BYTE *v4;
  __int16 IDSHeaderSizeWithChannelDataFormatArray;
  __int16 v6;
  BOOL v7;
  int v8;
  int v9;
  NSObject *v10;
  uint64_t v12;
  uint8_t buf[4];
  uint64_t v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 32)) >= 1)
  {
    do
    {
      v4 = CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 32));
      IDSHeaderSizeWithChannelDataFormatArray = VCIDSChannelData_GetIDSHeaderSizeWithChannelDataFormatArray((uint64_t)(v4 + 16), 1u);
      if (v4[293])
        v6 = 48;
      else
        v6 = 28;
      if (v4)
        v7 = v4 >= v4 + 312;
      else
        v7 = 0;
      if (v7)
        __break(0x5519u);
      if (a2)
      {
        v8 = (*(uint64_t (**)(uint64_t, _BYTE *, _QWORD, _QWORD, _QWORD))(a2 + 16))(a2, v4, (unsigned __int16)(v6 + IDSHeaderSizeWithChannelDataFormatArray), *((unsigned __int16 *)v4 + 2), 0);
        if (v8)
        {
          v9 = v8;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            v12 = VRTraceErrorLogLevelToCSTR();
            v10 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136315906;
              v14 = v12;
              v15 = 2080;
              v16 = "_VCMediaQueuePacketBundler_ReturnProcessedPackets";
              v17 = 1024;
              v18 = 76;
              v19 = 1024;
              v20 = v9;
              _os_log_error_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_ERROR, " [%s] %s:%d Output Block failed (%d)", buf, 0x22u);
            }
          }
        }
      }
    }
    while (CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 32)) > 0);
  }
  return 0;
}

uint64_t _VCMediaQueuePacketBundler_BundlePacketsWithFCFSPolicy(uint64_t a1, uint64_t a2)
{
  unsigned __int16 v3;
  unint64_t v4;
  unint64_t v5;
  int v6;
  BOOL v7;
  BOOL v8;
  __int16 v9;
  int v10;
  _BYTE *v11;
  int SizeOfHeaderWithBundledPackets;
  _BOOL4 v13;
  BOOL v14;
  char v15;
  unint64_t v16;
  unint64_t v17;
  int v18;
  uint64_t v19;
  __int16 v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;
  NSObject *v25;
  uint64_t v26;
  int v28;
  uint8_t buf[4];
  uint64_t v31;
  __int16 v32;
  const char *v33;
  __int16 v34;
  int v35;
  __int16 v36;
  int v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v3 = atomic_load((unsigned int *)(a1 + 20));
  if (CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 32)) >= 1)
  {
    v4 = 0;
    v5 = 0;
    v6 = 0;
    v7 = 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    v28 = v3;
    while (1)
    {
      v11 = CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 32));
      if (v4 && v4 >= v5)
        __break(0x5519u);
      SizeOfHeaderWithBundledPackets = _VCMediaQueuePacketBundler_GetSizeOfHeaderWithBundledPackets(v4, (uint64_t)v11);
      v13 = v7 || v11[288] != 0;
      if (v8)
      {
        v14 = 1;
        if (v13)
          goto LABEL_20;
      }
      else
      {
        v14 = v11[290] != 0;
        if (v13)
        {
LABEL_20:
          v20 = v9 + SizeOfHeaderWithBundledPackets;
          goto LABEL_22;
        }
      }
      v9 += SizeOfHeaderWithBundledPackets;
      v15 = *((unsigned __int16 *)v11 + 2) + (unsigned __int16)v6 > v28 - SizeOfHeaderWithBundledPackets || v14;
      if ((v15 & 1) == 0 && v10 < 8)
      {
        ++v10;
        if (v4)
        {
          v16 = v4;
          do
          {
            v17 = v16;
            v16 = *(_QWORD *)(v16 + 304);
          }
          while (v16);
          *(_QWORD *)(v17 + 304) = v11;
          v18 = v6;
          v19 = v4;
          goto LABEL_29;
        }
        v18 = v6;
        goto LABEL_28;
      }
      v20 = v9;
LABEL_22:
      v21 = _VCMediaQueuePacketBundler_GetSizeOfHeaderWithBundledPackets(v4, 0);
      v10 = 0;
      if (!a2)
      {
        v9 = 0;
        v18 = 0;
LABEL_28:
        v19 = (uint64_t)v11;
        goto LABEL_29;
      }
      v9 = 0;
      v18 = 0;
      v19 = (uint64_t)v11;
      if (v4)
      {
        v22 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t, _QWORD, _QWORD))(a2 + 16))(a2, v4, v21, (unsigned __int16)v6, (__int16)(v20 - v21));
        if (v22)
        {
          v23 = v22;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            v24 = VRTraceErrorLogLevelToCSTR();
            v25 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136315906;
              v31 = v24;
              v32 = 2080;
              v33 = "_VCMediaQueuePacketBundler_ReturnProcessedPackets";
              v34 = 1024;
              v35 = 76;
              v36 = 1024;
              v37 = v23;
              _os_log_error_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_ERROR, " [%s] %s:%d Output Block failed (%d)", buf, 0x22u);
            }
          }
        }
        v10 = 0;
        v9 = 0;
        v18 = 0;
        goto LABEL_28;
      }
LABEL_29:
      v5 = v19 + 312;
      v6 = *((unsigned __int16 *)v11 + 2) + v18;
      v7 = v11[288] != 0;
      v8 = v11[290] != 0;
      v4 = v19;
      if (CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 32)) <= 0)
        goto LABEL_35;
    }
  }
  v9 = 0;
  LOWORD(v6) = 0;
  v19 = 0;
LABEL_35:
  v26 = _VCMediaQueuePacketBundler_GetSizeOfHeaderWithBundledPackets(v19, 0);
  if (a2)
  {
    if (v19)
    {
      if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD))(a2 + 16))(a2, v19, v26, (unsigned __int16)v6, (__int16)(v9 - v26)))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VCMediaQueuePacketBundler_BundlePacketsWithFCFSPolicy_cold_1();
        }
      }
    }
  }
  return 0;
}

uint64_t _VCMediaQueuePacketBundler_GetSizeOfHeaderWithBundledPackets(uint64_t a1, uint64_t a2)
{
  BOOL v4;
  unsigned __int16 v5;
  _OWORD *v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  int v10;
  int v11;
  unsigned __int16 v12;
  _OWORD *v13;
  __int128 v14;
  __int128 v15;
  __int16 IDSHeaderSizeWithChannelDataFormatArray;
  __int16 v17;
  _OWORD __b[75];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  memset(__b, 170, sizeof(__b));
  if (!a1)
  {
    v5 = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    if (!a2)
      goto LABEL_15;
LABEL_10:
    v13 = &__b[5 * v5];
    v14 = *(_OWORD *)(a2 + 64);
    v13[2] = *(_OWORD *)(a2 + 48);
    v13[3] = v14;
    v13[4] = *(_OWORD *)(a2 + 80);
    v15 = *(_OWORD *)(a2 + 32);
    *v13 = *(_OWORD *)(a2 + 16);
    v13[1] = v15;
LABEL_11:
    ++v5;
    v11 = *(unsigned __int8 *)(a2 + 293);
    goto LABEL_13;
  }
  v4 = 0;
  v5 = 0;
  do
  {
    if (v5 <= 0xEu)
    {
      v6 = &__b[5 * v5];
      *v6 = *(_OWORD *)(a1 + 16);
      v7 = *(_OWORD *)(a1 + 32);
      v8 = *(_OWORD *)(a1 + 48);
      v9 = *(_OWORD *)(a1 + 80);
      v6[3] = *(_OWORD *)(a1 + 64);
      v6[4] = v9;
      v6[1] = v7;
      v6[2] = v8;
    }
    ++v5;
    v10 = *(unsigned __int8 *)(a1 + 293) | v4;
    v4 = v10 != 0;
    a1 = *(_QWORD *)(a1 + 304);
  }
  while (a1);
  if (a2)
  {
    if (v5 > 0xEu)
      goto LABEL_11;
    goto LABEL_10;
  }
  v11 = 0;
LABEL_13:
  if (v5 >= 0x10u && (int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCMediaQueuePacketBundler_GetSizeOfHeaderWithBundledPackets_cold_1();
  }
  v12 = v5;
LABEL_15:
  IDSHeaderSizeWithChannelDataFormatArray = VCIDSChannelData_GetIDSHeaderSizeWithChannelDataFormatArray((uint64_t)__b, v12);
  if (v11 | v10)
    v17 = 48;
  else
    v17 = 28;
  return (unsigned __int16)(IDSHeaderSizeWithChannelDataFormatArray + v17);
}

uint64_t _VCMediaQueuePacketBundlerClassRegister(uint64_t *a1)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

unint64_t VCMediaQueuePacketBundler_Create(uint64_t a1, _QWORD *a2, int a3, int a4)
{
  unint64_t result;
  const void *v8;

  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCMediaQueuePacketBundler_Create_cold_1();
    }
    return 4294954516;
  }
  if (VCMediaQueuePacketBundlerGetTypeID_initOnce != -1)
    dispatch_once_f(&VCMediaQueuePacketBundlerGetTypeID_initOnce, &VCMediaQueuePacketBundlerGetTypeID_typeID, (dispatch_function_t)_VCMediaQueuePacketBundlerClassRegister);
  result = _CFRuntimeCreateInstance();
  if (!result)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCMediaQueuePacketBundler_Create_cold_2();
    }
    return 4294954516;
  }
  v8 = (const void *)result;
  *(_DWORD *)(result + 16) = a3;
  *(_DWORD *)(result + 20) = a4;
  *(_BYTE *)(result + 24) = 0;
  if (result >= result + 40)
  {
    __break(0x5519u);
  }
  else
  {
    result = CMSimpleQueueCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 1000, (CMSimpleQueueRef *)(result + 32));
    if ((_DWORD)result)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCMediaQueuePacketBundler_Create_cold_3();
      }
      CFRelease(v8);
      return 0;
    }
    else
    {
      *a2 = v8;
    }
  }
  return result;
}

uint64_t VCMediaQueuePacketBundler_AddPacket(uint64_t a1, _QWORD *element)
{
  unsigned __int16 v4;
  unsigned __int8 v5;
  int v6;
  uint64_t result;
  uint64_t v8;
  NSObject *v9;
  int v10;
  int v11;
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCMediaQueuePacketBundler_AddPacket_cold_1();
    }
    return 4294954516;
  }
  if (!element)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCMediaQueuePacketBundler_AddPacket_cold_2();
    }
    return 4294954516;
  }
  if (element[38])
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCMediaQueuePacketBundler_AddPacket_cold_4();
    }
    return 4294954516;
  }
  v4 = atomic_load((unsigned int *)(a1 + 20));
  v5 = atomic_load((unsigned __int8 *)(a1 + 24));
  if ((v5 & 1) == 0)
  {
    v6 = v4;
    if (v4 < *((unsigned __int16 *)element + 2) && (int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v8 = VRTraceErrorLogLevelToCSTR();
      v9 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v10 = *((unsigned __int16 *)element + 2);
        v11 = 136316162;
        v12 = v8;
        v13 = 2080;
        v14 = "VCMediaQueuePacketBundler_AddPacket";
        v15 = 1024;
        v16 = 241;
        v17 = 1024;
        v18 = v10;
        v19 = 1024;
        v20 = v6;
        _os_log_error_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_ERROR, " [%s] %s:%d mediaPacket->dataSizeByte(%u) is bigger than bundler->currentMTUBytes(%u)", (uint8_t *)&v11, 0x28u);
      }
    }
  }
  result = CMSimpleQueueEnqueue(*(CMSimpleQueueRef *)(a1 + 32), element);
  if ((_DWORD)result)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!(_DWORD)result)
        return result;
      VCMediaQueuePacketBundler_AddPacket_cold_3();
    }
    return 0;
  }
  return result;
}

uint64_t VCMediaQueuePacketBundler_SetMTU(unsigned int *a1, unsigned int a2)
{
  if (a1)
  {
    CFRetain(a1);
    atomic_store(a2, a1 + 5);
    CFRelease(a1);
    return 0;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCMediaQueuePacketBundler_SetMTU_cold_1();
    }
    return 4294954516;
  }
}

uint64_t VCMediaQueuePacketBundler_SetOneToOne(uint64_t a1, unsigned __int8 a2)
{
  uint64_t result;

  if (a1)
  {
    result = 0;
    atomic_store(a2, (unsigned __int8 *)(a1 + 24));
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCMediaQueuePacketBundler_SetOneToOne_cold_1();
    }
    return 4294954516;
  }
  return result;
}

uint64_t VCMediaQueuePacketBundler_BundlePackets(uint64_t a1, uint64_t a2)
{
  unsigned __int8 v4;
  int v5;

  if (a1)
  {
    if (a2)
    {
      CFRetain((CFTypeRef)a1);
      v4 = atomic_load((unsigned __int8 *)(a1 + 24));
      if ((v4 & 1) != 0)
        goto LABEL_6;
      v5 = *(_DWORD *)(a1 + 16);
      if (v5 == 1)
      {
        _VCMediaQueuePacketBundler_BundlePacketsWithFCFSPolicy(a1, a2);
        goto LABEL_7;
      }
      if (!v5)
LABEL_6:
        _VCMediaQueuePacketBundler_BundlePacketsWithNonePolicy(a1, a2);
LABEL_7:
      CFRelease((CFTypeRef)a1);
      return 0;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCMediaQueuePacketBundler_BundlePackets_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCMediaQueuePacketBundler_BundlePackets_cold_1();
  }
  return 4294954516;
}

_QWORD *_VCMediaQueuePacketBundler_Init(_QWORD *result)
{
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  return result;
}

void _VCMediaQueuePacketBundler_Finalize(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

uint64_t _VCTextReceiver_ReceiveProc(void *a1, const char *a2)
{
  return objc_msgSend(a1, "receiverThreadCallback:", a2);
}

void sub_1D8D1D194(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t VTPCallback(int a1, void *a2, double *a3, unsigned int *a4)
{
  uint64_t v8;
  NSObject *v9;
  id v10;
  double v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  id v15;
  void *v16;
  uint64_t v17;
  int v19;
  uint64_t v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  double v26;
  __int16 v27;
  int v28;
  __int16 v29;
  double *v30;
  __int16 v31;
  unsigned int *v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v8 = VRTraceErrorLogLevelToCSTR();
    v9 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v19 = 136316674;
      v20 = v8;
      v21 = 2080;
      v22 = "VTPCallback";
      v23 = 1024;
      v24 = 925;
      v25 = 2048;
      v26 = *(double *)&a2;
      v27 = 1024;
      v28 = a1;
      v29 = 2048;
      v30 = a3;
      v31 = 2048;
      v32 = a4;
      _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCM:VTPCallback: context (%p) notification (%d) data (%p) optional (%p).", (uint8_t *)&v19, 0x40u);
    }
  }
  v10 = objc_alloc_init(MEMORY[0x1E0CB34A8]);
  if (a1 == 2)
    goto LABEL_19;
  if (a1 != 1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTPCallback_cold_1();
    }
    goto LABEL_19;
  }
  if (!a3)
  {
LABEL_19:
    v17 = 0xFFFFFFFFLL;
    goto LABEL_20;
  }
  v11 = *a3;
  v12 = *a4;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v13 = VRTraceErrorLogLevelToCSTR();
    v14 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v19 = 136316162;
      v20 = v13;
      v21 = 2080;
      v22 = "VTPCallback";
      v23 = 1024;
      v24 = 936;
      v25 = 2048;
      v26 = v11;
      v27 = 1024;
      v28 = v12;
      _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCM: Receive remote-no-remote-packet notification, %f. callID %d", (uint8_t *)&v19, 0x2Cu);
    }
  }
  if ((_DWORD)v12)
  {
    v15 = (id)objc_msgSend(a2, "conferenceForCallID:", v12);
    v16 = v15;
    if (v15 && objc_msgSend(v15, "shouldReinitializeCallWithDuration:forCallID:", v12, v11))
      objc_msgSend(+[AVConferenceXPCServer AVConferenceXPCServerSingleton](AVConferenceXPCServer, "AVConferenceXPCServerSingleton"), "sendMessageAsync:arguments:context:", "conferenceReinitializeCall", 0, v16);

  }
  v17 = 0;
LABEL_20:

  return v17;
}

uint64_t SIPCallback(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  id v15;
  uint64_t v16;
  NSObject *v17;
  id v18;
  uint64_t v19;
  id v20;
  uint64_t v21;
  NSObject *v22;
  const char *v23;
  uint8_t buf[4];
  uint64_t v27;
  __int16 v28;
  const char *v29;
  __int16 v30;
  int v31;
  __int16 v32;
  void *v33;
  __int16 v34;
  _QWORD v35[3];

  v35[2] = *MEMORY[0x1E0C80C00];
  v15 = objc_alloc_init(MEMORY[0x1E0CB34A8]);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v16 = VRTraceErrorLogLevelToCSTR();
    v17 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136316418;
      v27 = v16;
      v28 = 2080;
      v29 = "SIPCallback";
      v30 = 1024;
      v31 = 872;
      v32 = 2048;
      v33 = a2;
      v34 = 1024;
      LODWORD(v35[0]) = a4;
      WORD2(v35[0]) = 1024;
      *(_DWORD *)((char *)v35 + 6) = a3;
      _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d SIPCallback: %p, dwCallID = %d (%d)", buf, 0x32u);
    }
  }
  if ((objc_msgSend(a2, "isSIPHandleValid:", a1) & 1) != 0)
  {
    if ((_DWORD)a4)
    {
      v18 = (id)objc_msgSend(a2, "conferenceForCallID:", a4);
    }
    else
    {
      if ((_DWORD)a3 != 13 || !a5)
      {
LABEL_19:
        v18 = (id)objc_msgSend(a2, "activeConference");
        if (!v18)
        {
          v19 = 3;
          goto LABEL_21;
        }
LABEL_20:
        v19 = objc_msgSend(v18, "sipCallbackNotification:callID:msgIn:msgOut:optional:confIndex:", a3, a4, a5, a6, a7, a8);
LABEL_21:

        return v19;
      }
      v20 = (id)objc_msgSend(a2, "conferenceForParticipantID:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a5));
      v18 = v20;
      if (a6 && !v20)
        v18 = (id)objc_msgSend(a2, "conferenceForSourceDestinationInfo:", a6);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v21 = VRTraceErrorLogLevelToCSTR();
        v22 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          if (v18)
            v23 = (const char *)objc_msgSend((id)objc_msgSend(v18, "description"), "UTF8String");
          else
            v23 = "<nil>";
          *(_DWORD *)buf = 136316162;
          v27 = v21;
          v28 = 2080;
          v29 = "SIPCallback";
          v30 = 1024;
          v31 = 895;
          v32 = 2048;
          v33 = a2;
          v34 = 2080;
          v35[0] = v23;
          _os_log_impl(&dword_1D8A54000, v22, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d SIPCallback: VCManager %p matched VC %s to get callee callID", buf, 0x30u);
        }
      }
    }
    if (v18)
      goto LABEL_20;
    goto LABEL_19;
  }
  objc_msgSend(v15, "drain");
  return 3;
}

void CellConditionChangeCallback(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  NSObject *v7;
  id v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v6 = VRTraceErrorLogLevelToCSTR();
    v7 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315650;
      v10 = v6;
      v11 = 2080;
      v12 = "CellConditionChangeCallback";
      v13 = 1024;
      v14 = 914;
      _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VideoConferenceManager: CellConditionChangeCallback", (uint8_t *)&v9, 0x1Cu);
    }
  }
  v8 = objc_alloc_init(MEMORY[0x1E0CB34A8]);
  objc_msgSend(a1, "broadcastCellTechChange:cellularMaxPktLen:", a2, a3);

}

uint64_t VTP_Initialize()
{
  int *v0;
  int v1;
  CFAllocatorRef *v2;
  uint64_t v3;
  const __CFAllocator *v4;
  OpaqueCMMemoryPool *v5;
  CFAllocatorRef Allocator;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  NSObject *metadata;
  NSObject *v11;
  NSObject *v12;
  void *v13;
  const CFDictionaryValueCallBacks *v14;
  void *v15;
  void *v16;
  CFDictionaryRef v17;
  uint64_t *v18;
  int v19;
  CFPropertyListRef v20;
  const void *v21;
  uint64_t v22;
  NSObject *v23;
  int v24;
  const char *v25;
  CFIndex AppIntegerValue;
  int v27;
  uint64_t v28;
  NSObject *v29;
  uint64_t v30;
  NSObject *v31;
  uint64_t v33;
  NSObject *v34;
  uint64_t v35;
  uint64_t v36;
  NSObject *v37;
  const char *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  NSObject *v42;
  Boolean keyExistsAndHasValidFormat;
  _BYTE buf[44];
  __int16 v45;
  uint64_t v46;
  void *values[2];
  void *keys[3];

  keys[2] = *(void **)MEMORY[0x1E0C80C00];
  pthread_mutex_lock(&g_x_hvtp);
  if (g_hVTP != 0xFFFFFFFFLL)
  {
    pthread_mutex_unlock(&g_x_hvtp);
    v0 = __error();
    v1 = 17;
LABEL_67:
    *v0 = v1;
    return 0xFFFFFFFFLL;
  }
  v2 = (CFAllocatorRef *)malloc_type_calloc(1uLL, 0x5638uLL, 0x10E00402DC61C48uLL);
  if (!v2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
    {
      VRTraceErrorLogLevelToCSTR();
      if ((VRTraceIsOSFaultDisabled() & 1) != 0)
      {
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VTP_Initialize_cold_1();
      }
      else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_FAULT))
      {
        VTP_Initialize_cold_2();
      }
    }
    goto LABEL_65;
  }
  v3 = (uint64_t)v2;
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (VCAllocatorFirstCome_Create((const __CFAllocator *)*MEMORY[0x1E0C9AE00], (uint64_t)"VTPBlockBufferHeaderAllocator", v2 + 2752))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
    {
      VRTraceErrorLogLevelToCSTR();
      if ((VRTraceIsOSFaultDisabled() & 1) != 0)
      {
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VTP_Initialize_cold_23();
      }
      else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_FAULT))
      {
        VTP_Initialize_cold_24();
      }
    }
    goto LABEL_134;
  }
  if (VCUseFigMemoryPoolForDataBlockBuffer())
  {
    v5 = CMMemoryPoolCreate(0);
    *(_QWORD *)(v3 + 5904) = v5;
    if (!v5)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
      {
        VRTraceErrorLogLevelToCSTR();
        if ((VRTraceIsOSFaultDisabled() & 1) != 0)
        {
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VTP_Initialize_cold_5();
        }
        else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_FAULT))
        {
          VTP_Initialize_cold_6();
        }
      }
      goto LABEL_134;
    }
    Allocator = CMMemoryPoolGetAllocator(v5);
    *(_QWORD *)(v3 + 22024) = Allocator;
    if (!Allocator)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
      {
        VRTraceErrorLogLevelToCSTR();
        if ((VRTraceIsOSFaultDisabled() & 1) != 0)
        {
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VTP_Initialize_cold_7();
        }
        else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_FAULT))
        {
          VTP_Initialize_cold_8();
        }
      }
      goto LABEL_134;
    }
    CFRetain(Allocator);
  }
  else
  {
    *(_OWORD *)buf = xmmword_1D910D5A0;
    *(_OWORD *)&buf[16] = xmmword_1D910D5B0;
    *(_QWORD *)&buf[32] = 2049;
    if (VCAllocatorMultiQueue_Create(v4, (uint64_t)"VTPBlockBufferDataAllocator", 5u, (unint64_t *)buf, (CFAllocatorRef *)(v3 + 22024)))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
      {
        VRTraceErrorLogLevelToCSTR();
        if ((VRTraceIsOSFaultDisabled() & 1) != 0)
        {
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VTP_Initialize_cold_21();
        }
        else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_FAULT))
        {
          VTP_Initialize_cold_22();
        }
      }
      goto LABEL_134;
    }
  }
  if (VCAllocatorFirstCome_Create(v4, (uint64_t)"VTPPacketRoutingInfoAllocatorName", (CFAllocatorRef *)(v3 + 22040)))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
    {
      VRTraceErrorLogLevelToCSTR();
      if ((VRTraceIsOSFaultDisabled() & 1) != 0)
      {
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VTP_Initialize_cold_19();
      }
      else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_FAULT))
      {
        VTP_Initialize_cold_20();
      }
    }
    goto LABEL_134;
  }
  v7 = VCMemoryPool_Create(0x210uLL);
  *(_QWORD *)(v3 + 22032) = v7;
  if (!v7)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
    {
      VRTraceErrorLogLevelToCSTR();
      if ((VRTraceIsOSFaultDisabled() & 1) != 0)
      {
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VTP_Initialize_cold_9();
      }
      else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_FAULT))
      {
        VTP_Initialize_cold_10();
      }
    }
    goto LABEL_134;
  }
  v8 = VCMemoryPool_Create(0x230uLL);
  *(_QWORD *)(v3 + 5872) = v8;
  if (!v8)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
    {
      VRTraceErrorLogLevelToCSTR();
      if ((VRTraceIsOSFaultDisabled() & 1) != 0)
      {
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VTP_Initialize_cold_11();
      }
      else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_FAULT))
      {
        VTP_Initialize_cold_12();
      }
    }
LABEL_134:
    _VTP_ReleaseAllocators(v3);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
    {
      VRTraceErrorLogLevelToCSTR();
      if ((VRTraceIsOSFaultDisabled() & 1) != 0)
      {
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VTP_Initialize_cold_3();
      }
      else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_FAULT))
      {
        VTP_Initialize_cold_4();
      }
    }
    goto LABEL_64;
  }
  v9 = v3 + 21624;
  metadata = nw_ip_create_metadata();
  *(_QWORD *)(v3 + 22048) = metadata;
  nw_ip_metadata_set_service_class(metadata, nw_service_class_interactive_voice);
  if (!*(_QWORD *)(v3 + 22048))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 5)
      goto LABEL_105;
    v36 = VRTraceErrorLogLevelToCSTR();
    v37 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      goto LABEL_105;
    *(_DWORD *)buf = 136315650;
    *(_QWORD *)&buf[4] = v36;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = "_VTP_PrepareServiceClassMetadataForNWConnection";
    *(_WORD *)&buf[22] = 1024;
    *(_DWORD *)&buf[24] = 5175;
    v38 = " [%s] %s:%d NW connection metadata creation failed for voice";
LABEL_104:
    _os_log_impl(&dword_1D8A54000, v37, OS_LOG_TYPE_DEFAULT, v38, buf, 0x1Cu);
    goto LABEL_105;
  }
  v11 = nw_ip_create_metadata();
  *(_QWORD *)(v3 + 22056) = v11;
  nw_ip_metadata_set_service_class(v11, nw_service_class_interactive_video);
  if (!*(_QWORD *)(v3 + 22056))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 5)
      goto LABEL_105;
    v39 = VRTraceErrorLogLevelToCSTR();
    v37 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      goto LABEL_105;
    *(_DWORD *)buf = 136315650;
    *(_QWORD *)&buf[4] = v39;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = "_VTP_PrepareServiceClassMetadataForNWConnection";
    *(_WORD *)&buf[22] = 1024;
    *(_DWORD *)&buf[24] = 5179;
    v38 = " [%s] %s:%d NW connection metadata creation failed for video";
    goto LABEL_104;
  }
  v12 = nw_ip_create_metadata();
  *(_QWORD *)(v3 + 22064) = v12;
  nw_ip_metadata_set_service_class(v12, nw_service_class_background);
  if (*(_QWORD *)(v3 + 22064))
    goto LABEL_20;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v40 = VRTraceErrorLogLevelToCSTR();
    v37 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = v40;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "_VTP_PrepareServiceClassMetadataForNWConnection";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 5183;
      v38 = " [%s] %s:%d NW connection metadata creation failed for background";
      goto LABEL_104;
    }
  }
LABEL_105:
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v41 = VRTraceErrorLogLevelToCSTR();
    v42 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = v41;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "VTP_Initialize";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 415;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 415;
      _os_log_impl(&dword_1D8A54000, v42, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VTP/VTransport.m:%d: Failed to create metadata for service class", buf, 0x22u);
    }
  }
LABEL_20:
  *(_DWORD *)(v3 + 16) = 1074937874;
  *(_QWORD *)(v3 + 20) = 0xFFFFFFFF00000000;
  *(_DWORD *)(v3 + 5864) = 16;
  *(_BYTE *)(v3 + 21636) = 0;
  *(_QWORD *)(v3 + 112) = 0;
  *(_QWORD *)(v3 + 120) = 0;
  *(_BYTE *)v9 = VCDefaults_GetBoolValueForKey(CFSTR("forceDSCPTagging"), 0);
  v13 = malloc_type_calloc(1uLL, 0x140uLL, 0x1000040A86A77D5uLL);
  *(_QWORD *)(v3 + 5856) = v13;
  if (!v13)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
    {
      VRTraceErrorLogLevelToCSTR();
      if ((VRTraceIsOSFaultDisabled() & 1) != 0)
      {
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VTP_Initialize_cold_13();
      }
      else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_FAULT))
      {
        VTP_Initialize_cold_14();
      }
    }
    _VTP_ReleaseAllocators(v3);
LABEL_64:
    free((void *)v3);
LABEL_65:
    pthread_mutex_unlock(&g_x_hvtp);
LABEL_66:
    v0 = __error();
    v1 = 22;
    goto LABEL_67;
  }
  memset((void *)(v3 + 14232), 255, 0x1CE0uLL);
  g_hVTP = CreateHandle();
  pthread_mutex_unlock(&g_x_hvtp);
  if (g_hVTP == 0xFFFFFFFFLL)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_Initialize_cold_15();
    }
    free(*(void **)(v3 + 5856));
    _VTP_ReleaseAllocators(v3);
    free((void *)v3);
    goto LABEL_66;
  }
  pthread_mutex_init((pthread_mutex_t *)(v3 + 48), 0);
  pthread_mutex_init((pthread_mutex_t *)(v3 + 4224), 0);
  pthread_mutex_init((pthread_mutex_t *)(v3 + 4288), 0);
  pthread_mutex_init((pthread_mutex_t *)(v3 + 5792), 0);
  pthread_rwlock_init((pthread_rwlock_t *)(v3 + 5376), 0);
  pthread_rwlock_init((pthread_rwlock_t *)(v3 + 5584), 0);
  pthread_rwlock_init((pthread_rwlock_t *)(v3 + 21640), 0);
  v14 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  *(_QWORD *)(v3 + 21840) = CFDictionaryCreateMutable(v4, 0, MEMORY[0x1E0C9AEB8], MEMORY[0x1E0C9B3A0]);
  -[VCDatagramChannelManager setReadHandler:](+[VCDatagramChannelManager sharedInstance](VCDatagramChannelManager, "sharedInstance"), "setReadHandler:", &__block_literal_global_42);
  v15 = (void *)*MEMORY[0x1E0CA52D0];
  keys[0] = *(void **)MEMORY[0x1E0CA52C8];
  keys[1] = v15;
  v16 = (void *)*MEMORY[0x1E0C9AE40];
  values[0] = CFSTR("com.apple.avconference.vtransport.recvproc");
  values[1] = v16;
  v17 = CFDictionaryCreate(v4, (const void **)keys, (const void **)values, 2, MEMORY[0x1E0C9B390], v14);
  v18 = (uint64_t *)(v3 + 32);
  v19 = FigThreadCreate();
  if (v17)
    CFRelease(v17);
  if (v19)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
    {
      VRTraceErrorLogLevelToCSTR();
      if ((VRTraceIsOSFaultDisabled() & 1) != 0)
      {
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VTP_Initialize_cold_17();
      }
      else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_FAULT))
      {
        VTP_Initialize_cold_18();
      }
    }
    VTP_Cleanup();
    return 0xFFFFFFFFLL;
  }
  *(_QWORD *)(v3 + 5888) = 0xFFFFFFFFLL;
  *(_BYTE *)(v3 + 5896) = 0;
  *(_BYTE *)(v3 + 5897) = -[VCDefaults enablePacketLogging](+[VCDefaults sharedInstance](VCDefaults, "sharedInstance"), "enablePacketLogging");
  *(_BYTE *)(v3 + 21625) = 0;
  v20 = CFPreferencesCopyAppValue(CFSTR("DisableWMM"), CFSTR("com.apple.VideoConference"));
  if (v20)
  {
    v21 = v20;
    if (CFEqual(v20, (CFTypeRef)*MEMORY[0x1E0C9AE50]))
      *(_BYTE *)(v3 + 21625) = 1;
    CFRelease(v21);
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v22 = VRTraceErrorLogLevelToCSTR();
    v23 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v24 = *(unsigned __int8 *)(v3 + 21625);
      *(_DWORD *)buf = 136315906;
      if (v24)
        v25 = "disabled";
      else
        v25 = "enabled";
      *(_QWORD *)&buf[4] = v22;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "VTP_Initialize";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 494;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = v25;
      _os_log_impl(&dword_1D8A54000, v23, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d WMM is=%s.", buf, 0x26u);
    }
  }
  *(_DWORD *)(v3 + 21628) = 0;
  *(double *)(v3 + 21992) = micro();
  keyExistsAndHasValidFormat = -86;
  AppIntegerValue = CFPreferencesGetAppIntegerValue(CFSTR("fttc"), CFSTR("com.apple.VideoConference"), &keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat)
  {
    v27 = AppIntegerValue;
    if (AppIntegerValue > 999 || AppIntegerValue % 100)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VTP_Initialize_cold_16();
      }
    }
    else
    {
      if (AppIntegerValue && *(_BYTE *)(v9 + 1))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v28 = VRTraceErrorLogLevelToCSTR();
          v29 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = v28;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "VTP_Initialize";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 504;
            _os_log_impl(&dword_1D8A54000, v29, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Override DisableWMM due to FT traffic class is set.", buf, 0x1Cu);
          }
        }
        *(_BYTE *)(v9 + 1) = 0;
      }
      *(_DWORD *)(v9 + 4) = v27;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v30 = VRTraceErrorLogLevelToCSTR();
        v31 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315906;
          *(_QWORD *)&buf[4] = v30;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "VTP_Initialize";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 508;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = v27;
          _os_log_impl(&dword_1D8A54000, v31, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Force FaceTime traffic class=%d.", buf, 0x22u);
        }
      }
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v33 = VRTraceErrorLogLevelToCSTR();
    v34 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v35 = *v18;
      *(_DWORD *)buf = 136316418;
      *(_QWORD *)&buf[4] = v33;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "VTP_Initialize";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 514;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 514;
      *(_WORD *)&buf[34] = 2048;
      *(_QWORD *)&buf[36] = v35;
      v45 = 2048;
      v46 = g_hVTP;
      _os_log_impl(&dword_1D8A54000, v34, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VTP/VTransport.m:%d: VTPRecvProc thread=%p started. g_hVTP:[%p]", buf, 0x36u);
    }
  }
  return 0;
}

void _VTP_ReleaseAllocators(uint64_t a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  OpaqueCMMemoryPool *v5;
  const void *v6;

  VCMemoryPool_Destroy(*(OSQueueHead **)(a1 + 5872));
  *(_QWORD *)(a1 + 5872) = 0;
  VCMemoryPool_Destroy(*(OSQueueHead **)(a1 + 22032));
  *(_QWORD *)(a1 + 22032) = 0;
  v2 = *(const void **)(a1 + 22040);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 22040) = 0;
  }
  v3 = *(const void **)(a1 + 22024);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 22024) = 0;
  }
  v4 = *(const void **)(a1 + 22016);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 22016) = 0;
  }
  v5 = *(OpaqueCMMemoryPool **)(a1 + 5904);
  if (v5)
  {
    CMMemoryPoolInvalidate(v5);
    v6 = *(const void **)(a1 + 5904);
    if (v6)
    {
      CFRelease(v6);
      *(_QWORD *)(a1 + 5904) = 0;
    }
  }
}

uint64_t VTPRecvProc(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  pthread_rwlock_t *v3;
  signed int v4;
  uint64_t v5;
  int v7;
  int v8;
  uint64_t i;
  unint64_t v10;
  int v11;
  int v12;
  double v13;
  double v14;
  uint64_t v16;
  NSObject *v17;
  int v18;
  uint64_t j;
  uint64_t v20;
  NSObject *v21;
  int v22;
  uint64_t v23;
  _BYTE *v24;
  unint64_t v25;
  void *v26;
  _BYTE *v27;
  _BYTE *v28;
  double v29;
  __int128 v30;
  char *v31;
  ssize_t v32;
  int v33;
  unsigned int *msg_control;
  _OWORD *v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int v38;
  unsigned int v39;
  uint64_t v40;
  NSObject *v41;
  NSObject *v42;
  const char *v43;
  uint32_t v44;
  uint64_t v45;
  NSObject *v46;
  __int128 v47;
  _BYTE *v48;
  char *v49;
  int v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  unsigned int v54;
  uint64_t v55;
  NSObject *v56;
  const char *v57;
  int v58;
  _BYTE *v59;
  int v60;
  NSObject *v61;
  const char *v62;
  int v63;
  uint64_t v64;
  NSObject *v65;
  const char *v66;
  int v67;
  int v68;
  uint64_t v69;
  NSObject *v70;
  int v71;
  uint64_t v72;
  NSObject *v73;
  uint64_t k;
  int v75;
  int v77;
  void *v78;
  NSObject *v79;
  int ErrorLogLevelForModule;
  uint64_t v81;
  _BYTE *v82;
  int v83;
  timeval v84;
  char *v85;
  fd_set v86;
  uint8_t buf[64];
  __int128 v88;
  __int128 v89;
  __int128 v90;
  unint64_t v91;
  uint8_t v92[4];
  uint64_t v93;
  __int16 v94;
  const char *v95;
  __int16 v96;
  int v97;
  __int16 v98;
  int v99;
  msghdr v100;
  _QWORD v101[5];

  MEMORY[0x1E0C80A78](a1);
  v101[2] = *MEMORY[0x1E0C80C00];
  v84.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v84.tv_usec = 0xAAAAAAAAAAAAAAAALL;
  v83 = 0;
  v1 = CheckInHandleDebug();
  if (v1)
  {
    v2 = v1;
    v3 = (pthread_rwlock_t *)(v1 + 5376);
    memset(&v86, 0, sizeof(v86));
    pthread_rwlock_rdlock((pthread_rwlock_t *)(v1 + 5376));
    if (*(_DWORD *)(v2 + 20))
    {
LABEL_3:
      pthread_rwlock_unlock(v3);
      v4 = 0;
LABEL_4:
      CheckOutHandleDebug();
      return v4;
    }
    while (1)
    {
      v7 = *(_DWORD *)(v2 + 24);
      if (v7 == -1)
      {
        v7 = socket(2, 1, 6);
        *(_DWORD *)(v2 + 24) = v7;
        if (v7 == -1)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            v72 = VRTraceErrorLogLevelToCSTR();
            v73 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136315906;
              *(_QWORD *)&buf[4] = v72;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "VTPRecvProc";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 4105;
              *(_WORD *)&buf[28] = 1024;
              *(_DWORD *)&buf[30] = 4105;
              _os_log_error_impl(&dword_1D8A54000, v73, OS_LOG_TYPE_ERROR, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VTP/VTransport.m:%d: socket failed. We may run out of file descriptors", buf, 0x22u);
            }
          }
          usleep(0x2710u);
          goto LABEL_159;
        }
      }
      if (__darwin_check_fd_set_overflow(v7, &v86, 0))
        *(__int32_t *)((char *)v86.fds_bits + (((unint64_t)v7 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v7;
      v8 = *(_DWORD *)(v2 + 24);
      for (i = *(_QWORD *)(v2 + 5576); i; i = *(_QWORD *)(i + 352))
      {
        v10 = *(int *)(i + 20);
        if (v10 <= 0xFFFFFFFD)
        {
          if (__darwin_check_fd_set_overflow(*(_DWORD *)(i + 20), &v86, 0))
            *(__int32_t *)((char *)v86.fds_bits + ((v10 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v10;
          if (*(_DWORD *)(i + 20) > v8)
            v8 = *(_DWORD *)(i + 20);
        }
      }
      pthread_rwlock_unlock(v3);
      v84.tv_sec = 5;
      v84.tv_usec = 0;
      v11 = select(v8 + 1, &v86, 0, 0, &v84);
      v12 = *__error();
      v13 = micro();
      v14 = *(double *)(v2 + 21992);
      if (v14 > 0.0 && v13 - v14 > 5.0)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v16 = VRTraceErrorLogLevelToCSTR();
          v17 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v18 = *(_DWORD *)(v2 + 21984);
            *(_DWORD *)buf = 136315906;
            *(_QWORD *)&buf[4] = v16;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VTP_LogOSChannelInfoWithInterval";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 4040;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = v18;
            _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Triggering osChannelInfoLog [IDS readyToReadCount: %d]", buf, 0x22u);
          }
        }
        *(double *)(v2 + 21992) = v13;
        *(_DWORD *)(v2 + 21984) = 0;
        pthread_rwlock_rdlock(v3);
        for (j = *(_QWORD *)(v2 + 5576); j; j = *(_QWORD *)(j + 352))
        {
          if (*(_DWORD *)(j + 20) <= 0xFFFFFFFD && *(_DWORD *)(j + 392) == 4)
            _VTP_LogOSChannelInfoToIDSDatagramChannel(*(void **)(j + 504));
        }
        pthread_rwlock_unlock(v3);
      }
      if (!v11)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
        {
          v20 = VRTraceErrorLogLevelToCSTR();
          v21 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136316162;
            *(_QWORD *)&buf[4] = v20;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "VTPRecvProc";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 4140;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = 4140;
            *(_WORD *)&buf[34] = 1024;
            *(_DWORD *)&buf[36] = v83;
            _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VTP/VTransport.m:%d: Select timeout, VTP has received a total of %d packets", buf, 0x28u);
          }
        }
        bzero(buf, 0x1001uLL);
        pthread_rwlock_rdlock(v3);
        if (*(_BYTE *)(v2 + 40))
          v22 = snprintf((char *)buf, 0x1000uLL, "reset:%d", *(_DWORD *)(v2 + 24));
        else
          v22 = 0;
        for (k = *(_QWORD *)(v2 + 5576); k; k = *(_QWORD *)(k + 352))
        {
          if (*(_DWORD *)(k + 20) <= 0xFFFFFFFD && *(_DWORD *)(k + 392) == 4)
            _VTP_LogOSChannelInfoToIDSDatagramChannel(*(void **)(k + 504));
          if (*(_BYTE *)(v2 + 40))
          {
            v75 = snprintf((char *)&buf[v22], 4096 - v22, ",%d->%d", *(_DWORD *)k, *(_DWORD *)(k + 20));
            if (4096 - v22 <= v75 || v75 <= 0)
              v77 = 0;
            else
              v77 = v75;
            v22 += v77;
          }
        }
        if (*(_BYTE *)(v2 + 40))
        {
          *(_BYTE *)(v2 + 40) = 0;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
          {
            v78 = (void *)VRTraceErrorLogLevelToCSTR();
            v79 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(v100.msg_name) = 136315906;
              *(void **)((char *)&v100.msg_name + 4) = v78;
              *((_WORD *)&v100.msg_namelen + 2) = 2080;
              *(_QWORD *)((char *)&v100.msg_namelen + 6) = "_VTP_LogOSChannelInfoWhenSelectTimeout";
              HIWORD(v100.msg_iov) = 1024;
              v100.msg_iovlen = 4071;
              *((_WORD *)&v100.msg_iovlen + 2) = 2080;
              *(_QWORD *)((char *)&v100.msg_iovlen + 6) = buf;
              _os_log_impl(&dword_1D8A54000, v79, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Select timeout with fds:[%s]", (uint8_t *)&v100, 0x26u);
            }
          }
        }
LABEL_159:
        pthread_rwlock_unlock(v3);
        goto LABEL_160;
      }
      if (v11 != -1)
        break;
      if (v12 != 9)
      {
        v4 = v12 | 0xC0170000;
        ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
        if (ErrorLogLevelForModule >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VTPRecvProc_cold_2();
        }
        goto LABEL_4;
      }
LABEL_160:
      memset(&v86, 0, sizeof(v86));
      pthread_rwlock_rdlock(v3);
      if (*(_DWORD *)(v2 + 20))
        goto LABEL_3;
    }
    pthread_rwlock_rdlock(v3);
    v23 = *(_QWORD *)(v2 + 5576);
    if (!v23)
    {
      v24 = 0;
LABEL_158:
      VTP_DemuxPacketsToVFDList(v2, v24, &v83);
      goto LABEL_159;
    }
    v24 = 0;
    while (1)
    {
      v25 = *(int *)(v23 + 20);
      if (v25 <= 0xFFFFFFFD
        && __darwin_check_fd_set_overflow(*(_DWORD *)(v23 + 20), &v86, 0)
        && ((*(unsigned int *)((char *)v86.fds_bits + ((v25 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> v25) & 1) != 0)
      {
        break;
      }
LABEL_130:
      v23 = *(_QWORD *)(v23 + 352);
      if (!v23)
        goto LABEL_158;
    }
    v85 = (char *)0xAAAAAAAAAAAAAAAALL;
    if (*(_DWORD *)(v23 + 392) == 4)
    {
      v26 = *(void **)(v23 + 504);
      if (v26)
      {
        objc_msgSend(v26, "readyToRead");
        ++*(_DWORD *)(v2 + 21984);
        v85 = *(char **)(v2 + 21848);
        *(_QWORD *)(v2 + 21848) = 0;
        *(_DWORD *)(v2 + 21856) = 0;
LABEL_50:
        v27 = v24;
        if (v24)
        {
          do
          {
            v28 = v27;
            v27 = (_BYTE *)*((_QWORD *)v27 + 66);
          }
          while (v27);
          *((_QWORD *)v28 + 66) = v85;
        }
        else
        {
          v24 = v85;
        }
LABEL_128:
        v68 = *(_DWORD *)(v23 + 20);
        if (__darwin_check_fd_set_overflow(v68, &v86, 0))
          *(__int32_t *)((char *)v86.fds_bits + (((unint64_t)v68 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) &= ~(1 << v68);
        goto LABEL_130;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() < 3)
        goto LABEL_128;
      v40 = VRTraceErrorLogLevelToCSTR();
      v41 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        goto LABEL_128;
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = v40;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "VTP_RecvAndProcessPacketsFromDatagramChannel";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 5733;
      v42 = v41;
      v43 = " [%s] %s:%d nil dataChannel, cannot receive packet!";
      v44 = 28;
LABEL_88:
      _os_log_error_impl(&dword_1D8A54000, v42, OS_LOG_TYPE_ERROR, v43, buf, v44);
      goto LABEL_128;
    }
    v29 = micro();
    if ((_VTP_AllocatePacketWithBufferFreeCallback(v2, 0, 0x801uLL, 0, 0, (CMBlockBufferRef **)&v85) & 0x80000000) != 0)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 3)
        goto LABEL_128;
      v45 = VRTraceErrorLogLevelToCSTR();
      v46 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        goto LABEL_128;
      *(_DWORD *)buf = 136316162;
      *(_QWORD *)&buf[4] = v45;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "VTP_RecvFromSocket";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 5827;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 5827;
      *(_WORD *)&buf[34] = 1024;
      *(_DWORD *)&buf[36] = 560;
      v42 = v46;
      v43 = " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VTP/VTransport.m"
            ":%d: calloc failed to allocate=%d bytes";
      v44 = 40;
      goto LABEL_88;
    }
    if (*(_DWORD *)(v23 + 8) == 2)
    {
      *(_QWORD *)&v30 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v30 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)&buf[32] = v30;
      *(_OWORD *)&buf[48] = v30;
      *(_OWORD *)buf = v30;
      *(_OWORD *)&buf[16] = v30;
      v31 = v85;
      v101[0] = *((_QWORD *)v85 + 69);
      v101[1] = 2048;
      *((_DWORD *)v85 + 44) = 128;
      memset(&v100.msg_namelen, 170, 24);
      v100.msg_name = v31 + 48;
      v100.msg_iov = (iovec *)v101;
      v100.msg_namelen = 128;
      v100.msg_iovlen = 1;
      v100.msg_control = buf;
      *(_QWORD *)&v100.msg_controllen = 64;
      v32 = recvmsg(*(_DWORD *)(v23 + 20), &v100, 0);
      v82 = v24;
      if ((int)v32 <= 0)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          v69 = VRTraceErrorLogLevelToCSTR();
          v70 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v71 = *(_DWORD *)(v23 + 20);
            *(_DWORD *)v92 = 136315906;
            v93 = v69;
            v94 = 2080;
            v95 = "_VTP_RecvFromDatagramSocket";
            v96 = 1024;
            v97 = 5771;
            v98 = 1024;
            v99 = v71;
            _os_log_impl(&dword_1D8A54000, v70, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d recvmsg failed for socket=%d", v92, 0x22u);
          }
        }
      }
      else
      {
        *((_DWORD *)v31 + 44) = v100.msg_namelen;
        if (*(_BYTE *)(v23 + 368)
          && v31[49] == 30
          && !memcmp(v31 + 56, (const void *)(v23 + 376), *(unsigned int *)(v23 + 372)))
        {
          v33 = *((_DWORD *)v31 + 17);
          *((_DWORD *)v31 + 44) = 16;
          *((_WORD *)v31 + 24) = 528;
          *((_DWORD *)v31 + 13) = v33;
          *((_QWORD *)v31 + 7) = 0;
        }
        if (v100.msg_controllen >= 0xC)
        {
          msg_control = (unsigned int *)v100.msg_control;
          if (v100.msg_control)
          {
            v35 = v31 + 28;
            while (1)
            {
              v36 = msg_control[1];
              if (!v36)
                break;
              if (v36 == 41)
              {
                v37 = msg_control[2];
                if (v37 == 47)
                  goto LABEL_75;
                if (v37 == 46)
                {
                  if (msg_control[3] || msg_control[4] || msg_control[5] != -65536)
                    *v35 = *(_OWORD *)(msg_control + 3);
                  else
                    *(_DWORD *)v35 = bswap32(msg_control[6]);
                  v39 = msg_control[7];
LABEL_79:
                  VTP_IFIndexToName(v2, v39, v31 + 12);
                }
              }
LABEL_80:
              msg_control = (unsigned int *)((char *)msg_control + ((*msg_control + 3) & 0x1FFFFFFFCLL));
              if ((char *)(msg_control + 3) > (char *)v100.msg_control + v100.msg_controllen)
                goto LABEL_81;
            }
            v38 = msg_control[2];
            if (v38 != 24)
            {
              if (v38 != 20)
              {
                if (v38 == 7)
                  *(_DWORD *)v35 = bswap32(msg_control[3]);
                goto LABEL_80;
              }
              v39 = *((unsigned __int16 *)msg_control + 7);
              goto LABEL_79;
            }
LABEL_75:
            v31[352] = *((_BYTE *)msg_control + 12);
            goto LABEL_80;
          }
        }
      }
LABEL_81:
      v24 = v82;
    }
    else
    {
      v31 = v85;
      v32 = recv(*(_DWORD *)(v23 + 20), *((void **)v85 + 69), *((_QWORD *)v85 + 68), 0);
    }
    if ((_DWORD)v32 == 2048)
    {
      v32 = 2048;
      if (v31)
        goto LABEL_93;
      goto LABEL_123;
    }
    if ((_VTP_ShrinkPacket(v2, (int)v32, (uint64_t)v31) & 0x80000000) != 0)
    {
      v32 = 0xFFFFFFFFLL;
    }
    else if ((int)v32 > 0)
    {
      goto LABEL_105;
    }
    _VTP_ReleasePacket(v2, (void **)&v85);
LABEL_105:
    switch((_DWORD)v32)
    {
      case 0x80170003:
        goto LABEL_128;
      case 0xFFFFFFFF:
        v59 = v24;
        v60 = *__error();
        if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          v81 = VRTraceErrorLogLevelToCSTR();
          v61 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v62 = "recv";
            if (*(_DWORD *)(v23 + 8) == 2)
              v62 = "recvfrom";
            v63 = *(_DWORD *)(v23 + 20);
            *(_DWORD *)buf = 136316674;
            *(_QWORD *)&buf[4] = v81;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "VTP_RecvAndProcessOnePacketFromSocket";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 5679;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = 5679;
            *(_WORD *)&buf[34] = 2080;
            *(_QWORD *)&buf[36] = v62;
            *(_WORD *)&buf[44] = 1024;
            *(_DWORD *)&buf[46] = v63;
            *(_WORD *)&buf[50] = 1024;
            *(_DWORD *)&buf[52] = v60 | 0xC0170000;
            _os_log_impl(&dword_1D8A54000, v61, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VTP/VTransport.m:%d: %s(%d) failed (%08X)", buf, 0x38u);
          }
        }
        v24 = v59;
        goto LABEL_128;
      case 0:
        if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          v55 = VRTraceErrorLogLevelToCSTR();
          v56 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v57 = "recv";
            if (*(_DWORD *)(v23 + 8) == 2)
              v57 = "recvfrom";
            v58 = *(_DWORD *)(v23 + 20);
            *(_DWORD *)buf = 136316418;
            *(_QWORD *)&buf[4] = v55;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "VTP_RecvAndProcessOnePacketFromSocket";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 5674;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = 5674;
            *(_WORD *)&buf[34] = 2080;
            *(_QWORD *)&buf[36] = v57;
            *(_WORD *)&buf[44] = 1024;
            *(_DWORD *)&buf[46] = v58;
            _os_log_impl(&dword_1D8A54000, v56, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VTP/VTransport.m:%d: %s(%d) returned 0: empty message", buf, 0x32u);
          }
        }
        _VTP_ReleasePacket(v2, (void **)&v85);
        goto LABEL_50;
    }
    v31 = v85;
    if (v85)
    {
LABEL_93:
      *((double *)v31 + 23) = v29;
      memset(&v100, 0, 40);
      SAToIPPORTWithInterfaceIndexToNameCallback();
      v91 = 0xAAAAAAAAAAAAAAAALL;
      *(_QWORD *)&v47 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v47 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v89 = v47;
      v90 = v47;
      *(_OWORD *)&buf[48] = v47;
      v88 = v47;
      *(_OWORD *)&buf[16] = v47;
      *(_OWORD *)&buf[32] = v47;
      *(_OWORD *)buf = v47;
      VCSDInfoConstructWithIPPorts((uint64_t)(v85 + 8), (uint64_t)&v100, 0, 0, (uint64_t)buf);
      VTP_SetConnectionFlagsForPacket(v2, v23, (uint64_t)v85, (int *)buf);
      if ((VTP_ProcessPacketType(v2, (_DWORD *)v23, *(_DWORD *)(v23 + 20), (uint64_t)v85) & 0x80000000) != 0)
      {
        _VTP_ReleasePacket(v2, (void **)&v85);
        goto LABEL_128;
      }
      v48 = v24;
      v49 = v85;
      v50 = *(_DWORD *)v85;
      if (*(_DWORD *)v85 == 2)
      {
        v51 = *(_OWORD *)&buf[16];
        *(_OWORD *)(v85 + 232) = *(_OWORD *)buf;
        *(_OWORD *)(v49 + 248) = v51;
        v52 = v89;
        *(_OWORD *)(v49 + 296) = v88;
        *(_OWORD *)(v49 + 312) = v52;
        *(_OWORD *)(v49 + 328) = v90;
        v53 = *(_OWORD *)&buf[48];
        *(_OWORD *)(v49 + 264) = *(_OWORD *)&buf[32];
        *((_QWORD *)v49 + 43) = v91;
        *(_OWORD *)(v49 + 280) = v53;
      }
      v54 = *((_DWORD *)v49 + 56);
      VTP_UpdateReceivedBytes(*((_DWORD *)v49 + 54), v32, (v50 & 0xF0) != 0, v49[223], (uint64_t)buf, v49[413], v49[408], v49[412] != 0);
      if ((v50 & 0x100) == 0 && v54 != -1)
        _VTP_HealthPrint(v2, *((_QWORD *)v85 + 68), v54, 0, 0);
      v24 = v48;
      goto LABEL_50;
    }
LABEL_123:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v64 = VRTraceErrorLogLevelToCSTR();
      v65 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v66 = "recv";
        if (*(_DWORD *)(v23 + 8) == 2)
          v66 = "recvfrom";
        v67 = *(_DWORD *)(v23 + 20);
        *(_DWORD *)buf = 136316418;
        *(_QWORD *)&buf[4] = v64;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "VTP_RecvAndProcessOnePacketFromSocket";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 5684;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = 5684;
        *(_WORD *)&buf[34] = 2080;
        *(_QWORD *)&buf[36] = v66;
        *(_WORD *)&buf[44] = 1024;
        *(_DWORD *)&buf[46] = v67;
        _os_log_impl(&dword_1D8A54000, v65, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VTP/VTransport.m:%d: %s(%d) error. Empty buffer returned!", buf, 0x32u);
      }
    }
    goto LABEL_128;
  }
  v5 = -2145976318;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VTPRecvProc_cold_1();
  }
  return v5;
}

uint64_t VTP_Cleanup()
{
  uint64_t v0;
  uint64_t v1;
  pthread_rwlock_t *v2;
  uint64_t i;
  int v4;
  int ErrorLogLevelForModule;
  os_log_t *v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t j;
  _QWORD *v14;
  void *v15;
  _BYTE v17[12];
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  pthread_mutex_lock(&g_x_hvtp);
  v0 = CheckInHandleDebug();
  if (v0)
  {
    v1 = v0;
    v2 = (pthread_rwlock_t *)(v0 + 5376);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v0 + 5376));
    for (i = *(_QWORD *)(v1 + 5576); i; i = *(_QWORD *)(i + 352))
      *(_QWORD *)(i + 504) = 0;
    *(_DWORD *)(v1 + 20) = 1;
    v4 = *(_DWORD *)(v1 + 24);
    if (v4 != -1)
      close(v4);
    *(_DWORD *)(v1 + 24) = -1;
    pthread_rwlock_unlock(v2);
    if (*(_QWORD *)(v1 + 32))
    {
      *(_QWORD *)v17 = 0xAAAAAAAAAAAAAAAALL;
      FigThreadJoin();
    }
    ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    v6 = (os_log_t *)MEMORY[0x1E0CF2758];
    if (ErrorLogLevelForModule >= 7)
    {
      v7 = VRTraceErrorLogLevelToCSTR();
      v8 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
      {
        v9 = *(_QWORD *)(v1 + 32);
        *(_DWORD *)v17 = 136315906;
        *(_QWORD *)&v17[4] = v7;
        v18 = 2080;
        v19 = "VTP_Cleanup";
        v20 = 1024;
        v21 = 556;
        v22 = 2048;
        v23 = v9;
        _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VTPRecvProc thread[%p] end...", v17, 0x26u);
      }
    }
    pthread_rwlock_wrlock(v2);
    while (1)
    {
      v10 = *(_QWORD **)(v1 + 5576);
      if (!v10)
        break;
      VTP_CloseOneVFDList(v1, *(int **)(v1 + 5576));
      *(_QWORD *)(v1 + 5576) = v10[44];
      free(v10);
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v11 = VRTraceErrorLogLevelToCSTR();
      v12 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v17 = 136315650;
        *(_QWORD *)&v17[4] = v11;
        v18 = 2080;
        v19 = "VTP_Cleanup";
        v20 = 1024;
        v21 = 567;
        _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d removed all vfd from the list", v17, 0x1Cu);
      }
    }
    for (j = *(_QWORD *)(v1 + 21848); j; *(_QWORD *)(v1 + 21848) = j)
    {
      j = *(_QWORD *)(j + 528);
      _VTP_ReleasePacket(v1, (void **)(v1 + 21848));
    }
    while (1)
    {
      v14 = *(_QWORD **)(v1 + 5880);
      if (!v14)
        break;
      *(_QWORD *)(v1 + 5880) = v14[257];
      free(v14);
    }
    pthread_rwlock_unlock(v2);
    CheckOutHandleDebug();
    g_hVTP = 0xFFFFFFFFLL;
    pthread_mutex_unlock(&g_x_hvtp);
    pthread_mutex_destroy((pthread_mutex_t *)(v1 + 48));
    pthread_mutex_destroy((pthread_mutex_t *)(v1 + 4224));
    pthread_mutex_destroy((pthread_mutex_t *)(v1 + 4288));
    pthread_mutex_destroy((pthread_mutex_t *)(v1 + 5792));
    pthread_rwlock_destroy(v2);
    pthread_rwlock_destroy((pthread_rwlock_t *)(v1 + 5584));
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v1 + 21640));
    CFRelease(*(CFTypeRef *)(v1 + 21840));
    pthread_rwlock_unlock((pthread_rwlock_t *)(v1 + 21640));
    pthread_rwlock_destroy((pthread_rwlock_t *)(v1 + 21640));
    nw_release(*(void **)(v1 + 22056));
    nw_release(*(void **)(v1 + 22048));
    nw_release(*(void **)(v1 + 22064));
    _VTP_ReleaseAllocators(v1);
    v15 = *(void **)(v1 + 5856);
    if (v15)
      free(v15);
    free((void *)v1);
    return 0;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_Cleanup_cold_1();
    }
    *__error() = 13;
    pthread_mutex_unlock(&g_x_hvtp);
    return 0xFFFFFFFFLL;
  }
}

uint64_t VTP_CloseOneVFDList(uint64_t a1, int *a2)
{
  uint64_t i;
  int v5;
  char *v6;
  uint64_t v7;
  NSObject *v8;
  int v9;
  const char *v10;
  int v11;
  void *v12;
  int v13;
  _QWORD *v14;
  void *v15;
  unint64_t v17;
  uint8_t buf[4];
  uint64_t v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  __int16 v26;
  const char *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v17 = 0xAAAAAAAAAAAAAAAALL;
  VCNAT64ResolverDeregisterAll(a2);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 5584));
  for (i = *(_QWORD *)(a1 + 5784); i; i = *(_QWORD *)(i + 152))
  {
    v5 = *a2;
    v6 = *(char **)(i + 128);
    if (__darwin_check_fd_set_overflow(*a2, v6, 0)
      && ((*(_DWORD *)&v6[((unint64_t)v5 >> 3) & 0x1FFFFFFFFFFFFFFCLL] >> v5) & 1) != 0)
    {
      pthread_mutex_lock((pthread_mutex_t *)(i + 8));
      *(_BYTE *)(i + 121) = 1;
      pthread_cond_signal((pthread_cond_t *)(i + 72));
      pthread_mutex_unlock((pthread_mutex_t *)(i + 8));
    }
  }
  pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 5584));
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v7 = VRTraceErrorLogLevelToCSTR();
    v8 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v9 = *a2;
      v10 = "UDP";
      if (a2[3] == 6)
        v10 = "TCP";
      *(_DWORD *)buf = 136316162;
      v19 = v7;
      v20 = 2080;
      v21 = "VTP_CloseOneVFDList";
      v22 = 1024;
      v23 = 1805;
      v24 = 1024;
      v25 = v9;
      v26 = 2080;
      v27 = v10;
      _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d vfd=%d protocol=%s closed.", buf, 0x2Cu);
    }
  }
  VTP_ReleaseVFD((pthread_mutex_t *)a1, *a2);
  if (a2[5] <= 0xFFFFFFFD && a2[98] != 4)
    _VTP_ReleaseSocket(a1, (uint64_t)a2);
  v11 = a2[98];
  if (v11 == 4)
  {
    *((_QWORD *)a2 + 63) = 0;
    if (a2[5] <= 0xFFFFFFFD)
    {
      a2[5] = -1;
      v13 = *(_DWORD *)(a1 + 24);
      if (v13 != -1)
      {
        close(v13);
        *(_DWORD *)(a1 + 24) = -1;
      }
    }
  }
  else if (v11 == 5)
  {
    v12 = (void *)*((_QWORD *)a2 + 50);
    if (v12)
    {
      nw_release(v12);
      *((_QWORD *)a2 + 50) = 0;
    }
  }
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 28));
  v14 = (_QWORD *)*((_QWORD *)a2 + 13);
  while (1)
  {
    v17 = (unint64_t)v14;
    if (!v14)
      break;
    v14 = (_QWORD *)v14[66];
    _VTP_ReleasePacket(a1, (void **)&v17);
  }
  *((_QWORD *)a2 + 13) = 0;
  *((_BYTE *)a2 + 25) = 1;
  pthread_cond_broadcast((pthread_cond_t *)(a2 + 44));
  pthread_mutex_unlock((pthread_mutex_t *)(a2 + 28));
  v15 = (void *)*((_QWORD *)a2 + 4);
  if (v15)
    free(v15);
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 60));
  if (a2[56] >= 1)
  {
    do
      pthread_cond_wait((pthread_cond_t *)(a2 + 76), (pthread_mutex_t *)(a2 + 60));
    while (a2[56] > 0);
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a2 + 60));
  pthread_mutex_destroy((pthread_mutex_t *)(a2 + 28));
  pthread_cond_destroy((pthread_cond_t *)(a2 + 44));
  pthread_mutex_destroy((pthread_mutex_t *)(a2 + 60));
  return pthread_cond_destroy((pthread_cond_t *)(a2 + 76));
}

void _VTP_ReleasePacket(uint64_t a1, void **a2)
{
  void *v3;
  uint64_t v5;
  NSObject *v6;
  int v7;
  uint64_t v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  int v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v3 = *a2;
    if (*a2)
    {
      VCBlockBuffer_Clear((uint64_t)v3 + 536);
      VCMemoryPool_Free(*(OSQueueHead **)(a1 + 5872), v3);
      *a2 = 0;
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v5 = VRTraceErrorLogLevelToCSTR();
    v6 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v7 = 136315650;
      v8 = v5;
      v9 = 2080;
      v10 = "_VTP_ReleasePacket";
      v11 = 1024;
      v12 = 694;
      _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Releasing NULL packet reference", (uint8_t *)&v7, 0x1Cu);
    }
  }
}

uint64_t VTP_SetCallback(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  pthread_mutex_t *v6;

  v4 = CheckInHandleDebug();
  if (v4)
  {
    v5 = v4;
    v6 = (pthread_mutex_t *)(v4 + 48);
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 48));
    *(_QWORD *)(v5 + 112) = a1;
    *(_QWORD *)(v5 + 120) = a2;
    pthread_mutex_unlock(v6);
    CheckOutHandleDebug();
    return 0;
  }
  else
  {
    *__error() = 13;
    return 0xFFFFFFFFLL;
  }
}

uint64_t VTP_SetSessionID(int a1, const __CFString *a2)
{
  int *v2;
  int v3;
  pthread_mutex_t *v6;
  pthread_mutex_t *v7;
  pthread_mutex_t *v8;
  CFTypeRef *v9;
  CFStringRef Copy;

  if ((a1 - 1024) <= 0xFFFFFC63)
  {
    v2 = __error();
    v3 = 22;
LABEL_10:
    *v2 = v3;
    return 0xFFFFFFFFLL;
  }
  v6 = (pthread_mutex_t *)CheckInHandleDebug();
  if (!v6)
  {
    v2 = __error();
    v3 = 13;
    goto LABEL_10;
  }
  v7 = v6;
  v8 = v6 + 66;
  pthread_mutex_lock(v6 + 66);
  v9 = (CFTypeRef *)&v7[106].__opaque[8 * (a1 - 100) + 48];
  if (*v9)
    CFRelease(*v9);
  Copy = 0;
  if (a2)
    Copy = CFStringCreateCopy(0, a2);
  *v9 = Copy;
  pthread_mutex_unlock(v8);
  CheckOutHandleDebug();
  return 0;
}

uint64_t VTP_SetDTLS(int a1, uint64_t a2)
{
  int *v2;
  int v3;
  pthread_mutex_t *v6;
  pthread_mutex_t *v7;
  pthread_mutex_t *v8;

  if ((a1 - 1024) > 0xFFFFFC63)
  {
    v6 = (pthread_mutex_t *)CheckInHandleDebug();
    if (v6)
    {
      v7 = v6;
      v8 = v6 + 66;
      pthread_mutex_lock(v6 + 66);
      *(_QWORD *)&v7[222].__opaque[8 * (a1 - 100) + 16] = a2;
      pthread_mutex_unlock(v8);
      CheckOutHandleDebug();
      return 0;
    }
    v2 = __error();
    v3 = 13;
  }
  else
  {
    v2 = __error();
    v3 = 22;
  }
  *v2 = v3;
  return 0xFFFFFFFFLL;
}

uint64_t VTP_Socket(int a1, int a2, int a3)
{
  return VTP_SocketWithRealSocket(a1, a2, a3, -1);
}

uint64_t VTP_SocketWithRealSocket(int a1, int a2, int a3, int a4)
{
  uint64_t v8;
  uint64_t v9;
  _DWORD v11[4];
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v8 = CheckInHandleDebug();
  if (v8)
  {
    v41 = 0u;
    v42 = 0u;
    v39 = 0u;
    v40 = 0u;
    v37 = 0u;
    v38 = 0u;
    v35 = 0u;
    v36 = 0u;
    v33 = 0u;
    v34 = 0u;
    v31 = 0u;
    v32 = 0u;
    v29 = 0u;
    v30 = 0u;
    v27 = 0u;
    v28 = 0u;
    v25 = 0u;
    v26 = 0u;
    v23 = 0u;
    v24 = 0u;
    v21 = 0u;
    v22 = 0u;
    v19 = 0u;
    v20 = 0u;
    v17 = 0u;
    v18 = 0u;
    v15 = 0u;
    v16 = 0u;
    v13 = 0u;
    v14 = 0u;
    v11[0] = 0;
    v12 = 0u;
    v11[1] = a1;
    v11[2] = a2;
    v11[3] = a3;
    DWORD1(v12) = a4;
    v9 = _VTP_SocketWithRealSocketFromFVDList(v8, (uint64_t)v11);
    CheckOutHandleDebug();
  }
  else
  {
    *__error() = 13;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_SocketWithRealSocket_cold_1();
    }
    return 0xFFFFFFFFLL;
  }
  return v9;
}

uint64_t VTP_NWConnectionContext()
{
  if (VTP_NWConnectionContext_once != -1)
    dispatch_once(&VTP_NWConnectionContext_once, &__block_literal_global_48);
  return VTP_NWConnectionContext_context;
}

uint64_t VTP_NWConnectionQueue()
{
  if (VTP_NWConnectionQueue_once != -1)
    dispatch_once(&VTP_NWConnectionQueue_once, &__block_literal_global_14);
  return VTP_NWConnectionQueue_queue;
}

uint64_t VTP_CopyPreferredSendQueue(int a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  pthread_rwlock_t *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int *v10;
  int v11;
  NSObject *v13;

  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_CopyPreferredSendQueue_cold_1();
    }
    v10 = __error();
    v11 = 22;
    goto LABEL_17;
  }
  v4 = CheckInHandleDebug();
  if (!v4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_CopyPreferredSendQueue_cold_2();
    }
    v10 = __error();
    v11 = 13;
LABEL_17:
    *v10 = v11;
    return 0xFFFFFFFFLL;
  }
  v5 = v4;
  v6 = (pthread_rwlock_t *)(v4 + 5376);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(v4 + 5376));
  v7 = *(_QWORD *)(v5 + 5576);
  if (v7)
  {
    while (*(_DWORD *)v7 != a1)
    {
      v7 = *(_QWORD *)(v7 + 352);
      if (!v7)
        goto LABEL_6;
    }
    if (*(_DWORD *)(v7 + 392) == 5)
    {
      if (VTP_NWConnectionQueue_once != -1)
        dispatch_once(&VTP_NWConnectionQueue_once, &__block_literal_global_14);
      v13 = VTP_NWConnectionQueue_queue;
      *a2 = VTP_NWConnectionQueue_queue;
      dispatch_retain(v13);
      v9 = 0;
      v8 = 0;
    }
    else
    {
      v9 = 0;
      v8 = 0;
      *a2 = 0;
    }
  }
  else
  {
LABEL_6:
    v8 = 0xFFFFFFFFLL;
    v9 = 1;
  }
  pthread_rwlock_unlock(v6);
  CheckOutHandleDebug();
  if (v9)
    *__error() = 9;
  return v8;
}

uint64_t VTP_SocketWithNWConnection(unsigned int a1, int a2, NSObject *a3)
{
  uint64_t v5;
  uint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  unsigned int VFD;
  NSObject *v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  NSObject *v14;
  NSObject *v15;
  uint64_t v16;
  NSObject *v17;
  int v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  _BYTE v24[48];
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (!a3)
  {
    *__error() = 22;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_SocketWithNWConnection_cold_1();
    }
    return 0xFFFFFFFFLL;
  }
  if (a2 != 17)
  {
    *__error() = 22;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_SocketWithNWConnection_cold_6();
    }
    return 0xFFFFFFFFLL;
  }
  v5 = CheckInHandleDebug();
  if (!v5)
  {
    *__error() = 13;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_SocketWithNWConnection_cold_2();
    }
    return 0xFFFFFFFFLL;
  }
  v6 = v5;
  v7 = (unsigned int *)malloc_type_calloc(1uLL, 0x200uLL, 0x10B2040A7A77763uLL);
  if (!v7)
  {
    *__error() = 12;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
    {
      VRTraceErrorLogLevelToCSTR();
      if ((VRTraceIsOSFaultDisabled() & 1) != 0)
      {
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VTP_SocketWithNWConnection_cold_3();
      }
      else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_FAULT))
      {
        VTP_SocketWithNWConnection_cold_4();
      }
    }
    goto LABEL_33;
  }
  v8 = v7;
  VFD = VTP_GetVFD((pthread_mutex_t *)v6);
  *v8 = VFD;
  if (VFD == -1)
  {
    *__error() = 24;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_SocketWithNWConnection_cold_5();
    }
    free(v8);
LABEL_33:
    CheckOutHandleDebug();
    return 0xFFFFFFFFLL;
  }
  v10 = nw_connection_copy_endpoint(a3);
  v8[1] = nw_endpoint_get_address(v10)->sa_family;
  nw_release(v10);
  v8[2] = a1;
  v8[5] = -1;
  *((_BYTE *)v8 + 24) = 0;
  v8[7] = 0;
  v8[56] = 0;
  *((_QWORD *)v8 + 45) = 0xFFFFFFFFLL;
  *(_QWORD *)(v8 + 3) = 0x100000011;
  pthread_rwlock_wrlock((pthread_rwlock_t *)(v6 + 5376));
  nw_retain(a3);
  VCSDInfoConstructWithNWConnection((uint64_t)a3, (uint64_t)v24);
  v11 = v27;
  *(_OWORD *)(v8 + 114) = v26;
  *(_OWORD *)(v8 + 118) = v11;
  *(_OWORD *)(v8 + 122) = v28;
  *((_QWORD *)v8 + 63) = v29;
  v12 = *(_OWORD *)&v24[16];
  *(_OWORD *)(v8 + 98) = *(_OWORD *)v24;
  *(_OWORD *)(v8 + 102) = v12;
  v13 = v25;
  *(_OWORD *)(v8 + 106) = *(_OWORD *)&v24[32];
  *(_OWORD *)(v8 + 110) = v13;
  v14 = nw_connection_copy_parameters(a3);
  v15 = nw_parameters_copy_local_endpoint(v14);
  if (nw_endpoint_get_address(v15))
    SAToIPPORT();
  nw_release(v15);
  nw_release(v14);
  pthread_mutex_init((pthread_mutex_t *)(v8 + 28), 0);
  pthread_cond_init((pthread_cond_t *)(v8 + 44), 0);
  pthread_mutex_init((pthread_mutex_t *)(v8 + 60), 0);
  pthread_cond_init((pthread_cond_t *)(v8 + 76), 0);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v16 = VRTraceErrorLogLevelToCSTR();
    v17 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v18 = *v8;
      v19 = v8[5];
      *(_DWORD *)v24 = 136316162;
      *(_QWORD *)&v24[4] = v16;
      *(_WORD *)&v24[12] = 2080;
      *(_QWORD *)&v24[14] = "VTP_SocketWithNWConnection";
      *(_WORD *)&v24[22] = 1024;
      *(_DWORD *)&v24[24] = 1039;
      *(_WORD *)&v24[28] = 1024;
      *(_DWORD *)&v24[30] = v18;
      *(_WORD *)&v24[34] = 1024;
      *(_DWORD *)&v24[36] = v19;
      _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d new vfd=%d->fd=%d, and add to list", v24, 0x28u);
    }
  }
  v20 = *(_QWORD *)(v6 + 5576);
  if (v20)
  {
    do
    {
      v21 = v20;
      v20 = *(_QWORD *)(v20 + 352);
    }
    while (v20);
    v22 = (_QWORD *)(v21 + 352);
  }
  else
  {
    v22 = (_QWORD *)(v6 + 5576);
  }
  *v22 = v8;
  pthread_rwlock_unlock((pthread_rwlock_t *)(v6 + 5376));
  CheckOutHandleDebug();
  return *v8;
}

uint64_t VTP_GetVFD(pthread_mutex_t *a1)
{
  pthread_mutex_t *v2;
  uint64_t v3;
  pthread_mutex_t *v4;
  const void *v7;
  uint64_t v8;

  if (!a1)
    return 0xFFFFFFFFLL;
  v2 = a1 + 66;
  pthread_mutex_lock(a1 + 66);
  v3 = -924;
  v4 = a1;
  while (a1[106].__opaque[v3 + 44])
  {
    v4 = (pthread_mutex_t *)((char *)v4 + 8);
    if (__CFADD__(v3++, 1))
    {
      pthread_mutex_unlock(v2);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VTP_GetVFD_cold_1();
      }
      return 0xFFFFFFFFLL;
    }
  }
  v7 = *(const void **)&v4[106].__opaque[48];
  v8 = (uint64_t)&a1[92].__opaque[v3 + 16];
  if (v7)
    CFRelease(v7);
  *(_QWORD *)&v4[106].__opaque[48] = 0;
  *(_QWORD *)&v4[222].__opaque[16] = 0xFFFFFFFFLL;
  *(_BYTE *)(v8 + 924) = 1;
  pthread_mutex_unlock(v2);
  return (v3 + 1024);
}

uint64_t VTP_DuplicateVFD(int a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD v7[5];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  const char *v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v8 = 0;
  v9 = &v8;
  v10 = 0x22010000000;
  v11 = "";
  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  v16 = 0u;
  v17 = 0u;
  v18 = 0u;
  v19 = 0u;
  v20 = 0u;
  v21 = 0u;
  v22 = 0u;
  v23 = 0u;
  v24 = 0u;
  v25 = 0u;
  v26 = 0u;
  v27 = 0u;
  v28 = 0u;
  v29 = 0u;
  v30 = 0u;
  v31 = 0u;
  v32 = 0u;
  v33 = 0u;
  v34 = 0u;
  v35 = 0u;
  v36 = 0u;
  v37 = 0u;
  v38 = 0u;
  v39 = 0u;
  v40 = 0u;
  v41 = 0u;
  v42 = 0u;
  v43 = 0u;
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 3221225472;
  v7[2] = __VTP_DuplicateVFD_block_invoke;
  v7[3] = &unk_1E9E560D8;
  v7[4] = &v8;
  v2 = CheckInHandleDebug();
  v3 = v2;
  if (v2)
  {
    VTP_ProcessVFD(v2, a1, 0, (uint64_t)v7);
    if (*((_DWORD *)v9 + 13) == -1)
    {
      *__error() = 9;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VTP_DuplicateVFD_cold_2();
      }
      v4 = 0xFFFFFFFFLL;
    }
    else
    {
      v4 = _VTP_SocketWithRealSocketFromFVDList(v3, (uint64_t)(v9 + 4));
      pthread_rwlock_wrlock((pthread_rwlock_t *)(v3 + 5376));
      v5 = v3 + 4 * *((int *)v9 + 13);
      --*(_DWORD *)(v5 + 128);
      pthread_rwlock_unlock((pthread_rwlock_t *)(v3 + 5376));
    }
    CheckOutHandleDebug();
  }
  else
  {
    *__error() = 13;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_DuplicateVFD_cold_1();
    }
    v4 = 0xFFFFFFFFLL;
  }
  _Block_object_dispose(&v8, 8);
  return v4;
}

void sub_1D8D26820(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  _Unwind_Resume(exception_object);
}

uint64_t VTP_ProcessVFD(uint64_t a1, int a2, int a3, uint64_t a4)
{
  pthread_rwlock_t *v7;
  pthread_rwlock_t *v8;
  uint64_t v9;

  v7 = (pthread_rwlock_t *)(a1 + 5376);
  v8 = (pthread_rwlock_t *)(a1 + 5376);
  if (a3)
    pthread_rwlock_rdlock(v8);
  else
    pthread_rwlock_wrlock(v8);
  v9 = *(_QWORD *)(a1 + 5576);
  if (v9)
  {
    while (*(_DWORD *)v9 != a2)
    {
      v9 = *(_QWORD *)(v9 + 352);
      if (!v9)
        return pthread_rwlock_unlock(v7);
    }
    (*(void (**)(uint64_t, uint64_t))(a4 + 16))(a4, a1);
  }
  return pthread_rwlock_unlock(v7);
}

uint64_t _VTP_SocketWithRealSocketFromFVDList(uint64_t a1, uint64_t a2)
{
  unsigned int *v4;
  unsigned int *v5;
  unsigned int VFD;
  int *v7;
  int v8;
  int *v9;
  int v10;
  int v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  int v15;
  __int128 v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  NSObject *v20;
  uint64_t v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;
  NSObject *v34;
  int v35;
  unsigned int v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  int v41;
  int v42;
  socklen_t v43;
  _BYTE buf[48];
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    *__error() = 22;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
    {
      VRTraceErrorLogLevelToCSTR();
      if ((VRTraceIsOSFaultDisabled() & 1) != 0)
      {
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VTP_SocketWithRealSocketFromFVDList_cold_1();
      }
      else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_FAULT))
      {
        _VTP_SocketWithRealSocketFromFVDList_cold_2();
      }
    }
    return 0xFFFFFFFFLL;
  }
  v4 = (unsigned int *)malloc_type_calloc(1uLL, 0x200uLL, 0x10B2040A7A77763uLL);
  if (!v4)
  {
    *__error() = 12;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
    {
      VRTraceErrorLogLevelToCSTR();
      if ((VRTraceIsOSFaultDisabled() & 1) != 0)
      {
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VTP_SocketWithRealSocketFromFVDList_cold_3();
      }
      else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_FAULT))
      {
        _VTP_SocketWithRealSocketFromFVDList_cold_4();
      }
    }
    return 0xFFFFFFFFLL;
  }
  v5 = v4;
  VFD = VTP_GetVFD((pthread_mutex_t *)a1);
  *v5 = VFD;
  if (VFD == -1)
  {
    *__error() = 24;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VTP_SocketWithRealSocketFromFVDList_cold_5();
    }
    goto LABEL_27;
  }
  *(_QWORD *)(v5 + 1) = *(_QWORD *)(a2 + 4);
  v5[3] = *(_DWORD *)(a2 + 12);
  v7 = (int *)(v5 + 5);
  *((_BYTE *)v5 + 24) = 0;
  v5[7] = 0;
  v5[56] = 0;
  *((_QWORD *)v5 + 45) = 0xFFFFFFFFLL;
  *((_QWORD *)v5 + 2) = 0xFFFFFFFF00000001;
  pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 5376));
  if (*(_DWORD *)(a2 + 12) == 17)
  {
    v8 = *(_DWORD *)(a2 + 20);
    if (v8 == -1)
    {
      v11 = socket(*(_DWORD *)(a2 + 4), *(_DWORD *)(a2 + 8), 17);
      *v7 = v11;
      if (v11 == -1)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VTP_SocketWithRealSocketFromFVDList_cold_6();
        }
        pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 5376));
        VTP_ReleaseVFD((pthread_mutex_t *)a1, *v5);
        goto LABEL_27;
      }
      if (v11 >= 1025)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VTP_SocketWithRealSocketFromFVDList_cold_7();
        }
        close(v5[5]);
        pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 5376));
        VTP_ReleaseVFD((pthread_mutex_t *)a1, *v5);
        v9 = __error();
        v10 = 24;
        goto LABEL_17;
      }
      ++*(_DWORD *)(a1 + 4 * v11 + 128);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v19 = VRTraceErrorLogLevelToCSTR();
        v20 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v21 = *v7;
          v22 = *(_DWORD *)(a1 + 4 * v21 + 128);
          *(_DWORD *)buf = 136316162;
          *(_QWORD *)&buf[4] = v19;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VTP_SocketWithRealSocketFromFVDList";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 1103;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = v21;
          *(_WORD *)&buf[34] = 1024;
          *(_DWORD *)&buf[36] = v22;
          _os_log_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d fd=%d increase. RefCount=%d", buf, 0x28u);
        }
      }
    }
    else
    {
      if (v8 >= 1025)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VTP_SocketWithRealSocketFromFVDList_cold_8();
        }
        pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 5376));
        VTP_ReleaseVFD((pthread_mutex_t *)a1, *v5);
        v9 = __error();
        v10 = 9;
LABEL_17:
        *v9 = v10;
LABEL_27:
        free(v5);
        return 0xFFFFFFFFLL;
      }
      v5[5] = v8;
      *((_BYTE *)v5 + 24) = 1;
      ++*(_DWORD *)(a1 + 4 * v8 + 128);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v12 = VRTraceErrorLogLevelToCSTR();
        v13 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v14 = *v7;
          v15 = *(_DWORD *)(a1 + 4 * v14 + 128);
          *(_DWORD *)buf = 136316162;
          *(_QWORD *)&buf[4] = v12;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VTP_SocketWithRealSocketFromFVDList";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 1114;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = v14;
          *(_WORD *)&buf[34] = 1024;
          *(_DWORD *)&buf[36] = v15;
          _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d fd=%d increase. RefCount=%d", buf, 0x28u);
        }
      }
      *(_QWORD *)&v16 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v48 = v16;
      v49 = v16;
      v46 = v16;
      v47 = v16;
      *(_OWORD *)&buf[32] = v16;
      v45 = v16;
      *(_OWORD *)buf = v16;
      *(_OWORD *)&buf[16] = v16;
      v43 = 128;
      getsockname(v5[5], (sockaddr *)buf, &v43);
      SAToIPPORT();
      v17 = *(_DWORD *)(a1 + 24);
      if (v17 != -1)
      {
        close(v17);
        *(_DWORD *)(a1 + 24) = -1;
      }
    }
  }
  v42 = 1;
  setsockopt(*v7, 0xFFFF, 4130, &v42, 4u);
  v41 = 1;
  v23 = *v7;
  if (*(_DWORD *)(a2 + 4) == 2)
  {
    setsockopt(v23, 0, 7, &v41, 4u);
    v24 = *v7;
    v25 = 0;
    v26 = 20;
  }
  else
  {
    setsockopt(v23, 41, 27, &v41, 4u);
    v24 = *v7;
    v25 = 41;
    v26 = 61;
  }
  setsockopt(v24, v25, v26, &v41, 4u);
  pthread_mutex_init((pthread_mutex_t *)(v5 + 28), 0);
  pthread_cond_init((pthread_cond_t *)(v5 + 44), 0);
  pthread_mutex_init((pthread_mutex_t *)(v5 + 60), 0);
  pthread_cond_init((pthread_cond_t *)(v5 + 76), 0);
  v27 = *(_OWORD *)(a2 + 440);
  v29 = *(_OWORD *)(a2 + 392);
  v28 = *(_OWORD *)(a2 + 408);
  *(_OWORD *)(v5 + 106) = *(_OWORD *)(a2 + 424);
  *(_OWORD *)(v5 + 110) = v27;
  *(_OWORD *)(v5 + 98) = v29;
  *(_OWORD *)(v5 + 102) = v28;
  v31 = *(_OWORD *)(a2 + 472);
  v30 = *(_OWORD *)(a2 + 488);
  v32 = *(_OWORD *)(a2 + 456);
  *((_QWORD *)v5 + 63) = *(_QWORD *)(a2 + 504);
  *(_OWORD *)(v5 + 118) = v31;
  *(_OWORD *)(v5 + 122) = v30;
  *(_OWORD *)(v5 + 114) = v32;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v33 = VRTraceErrorLogLevelToCSTR();
    v34 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v35 = *v5;
      v36 = v5[5];
      *(_DWORD *)buf = 136316162;
      *(_QWORD *)&buf[4] = v33;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "_VTP_SocketWithRealSocketFromFVDList";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 1158;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = v35;
      *(_WORD *)&buf[34] = 1024;
      *(_DWORD *)&buf[36] = v36;
      _os_log_impl(&dword_1D8A54000, v34, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d new vfd=%d->fd=%d, and add to list", buf, 0x28u);
    }
  }
  v37 = *(_QWORD *)(a1 + 5576);
  if (v37)
  {
    do
    {
      v38 = v37;
      v37 = *(_QWORD *)(v37 + 352);
    }
    while (v37);
    v39 = (_QWORD *)(v38 + 352);
  }
  else
  {
    v39 = (_QWORD *)(a1 + 5576);
  }
  *v39 = v5;
  v18 = *v5;
  pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 5376));
  return v18;
}

uint64_t VTP_SocketForIDS()
{
  return VTP_SocketForIDSWithFileDescriptor(-2, 0);
}

uint64_t VTP_SocketForIDSWithFileDescriptor(int a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int *v6;
  unsigned int VFD;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  int v11;
  uint64_t v12;
  NSObject *v13;
  int v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v20;
  NSObject *v21;
  int v22;
  int v23;
  int *v24;
  int v25;
  _BYTE v26[48];
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v4 = CheckInHandleDebug();
  if (!v4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_SocketForIDSWithFileDescriptor_cold_1();
    }
    *__error() = 13;
    return 0xFFFFFFFFLL;
  }
  if (a1 >= 1025)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_SocketForIDSWithFileDescriptor_cold_3();
    }
    v24 = __error();
    v6 = 0;
    v25 = 24;
    goto LABEL_31;
  }
  v5 = v4;
  v6 = (unsigned int *)malloc_type_calloc(1uLL, 0x200uLL, 0x10B2040A7A77763uLL);
  if (!v6)
  {
    v24 = __error();
    v25 = 12;
LABEL_31:
    *v24 = v25;
    goto LABEL_32;
  }
  VFD = VTP_GetVFD((pthread_mutex_t *)v5);
  *v6 = VFD;
  if (VFD == -1)
  {
    *__error() = 24;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_SocketForIDSWithFileDescriptor_cold_4();
    }
LABEL_32:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3
      && (VRTraceErrorLogLevelToCSTR(), os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR)))
    {
      VTP_SocketForIDSWithFileDescriptor_cold_2();
      if (!v6)
        goto LABEL_36;
    }
    else if (!v6)
    {
LABEL_36:
      CheckOutHandleDebug();
      return 0xFFFFFFFFLL;
    }
    free(v6);
    goto LABEL_36;
  }
  v6[2] = 2;
  *((_BYTE *)v6 + 24) = 1;
  v6[7] = 0;
  v6[56] = 0;
  *((_QWORD *)v6 + 45) = 0xFFFFFFFFLL;
  v6[4] = 1;
  v6[5] = a1;
  if ((_DWORD)a2)
  {
    VCSDInfoConstructWithDatagramChannel((uint64_t)-[VCDatagramChannelManager datagramChannelWithChannelToken:](+[VCDatagramChannelManager sharedInstance](VCDatagramChannelManager, "sharedInstance"), "datagramChannelWithChannelToken:", a2), 0, 0, 0, (uint64_t)v26);
    v8 = v29;
    *(_OWORD *)(v6 + 114) = v28;
    *(_OWORD *)(v6 + 118) = v8;
    *(_OWORD *)(v6 + 122) = v30;
    *((_QWORD *)v6 + 63) = v31;
    v9 = *(_OWORD *)&v26[16];
    *(_OWORD *)(v6 + 98) = *(_OWORD *)v26;
    *(_OWORD *)(v6 + 102) = v9;
    v10 = v27;
    *(_OWORD *)(v6 + 106) = *(_OWORD *)&v26[32];
    *(_OWORD *)(v6 + 110) = v10;
  }
  pthread_rwlock_wrlock((pthread_rwlock_t *)(v5 + 5376));
  v11 = *(_DWORD *)(v5 + 24);
  if (v11 != -1)
  {
    close(v11);
    *(_DWORD *)(v5 + 24) = -1;
  }
  pthread_mutex_init((pthread_mutex_t *)(v6 + 28), 0);
  pthread_cond_init((pthread_cond_t *)(v6 + 44), 0);
  pthread_mutex_init((pthread_mutex_t *)(v6 + 60), 0);
  pthread_cond_init((pthread_cond_t *)(v6 + 76), 0);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v12 = VRTraceErrorLogLevelToCSTR();
    v13 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v14 = *v6;
      v15 = v6[5];
      *(_DWORD *)v26 = 136316162;
      *(_QWORD *)&v26[4] = v12;
      *(_WORD *)&v26[12] = 2080;
      *(_QWORD *)&v26[14] = "VTP_SocketForIDSWithFileDescriptor";
      *(_WORD *)&v26[22] = 1024;
      *(_DWORD *)&v26[24] = 1296;
      *(_WORD *)&v26[28] = 1024;
      *(_DWORD *)&v26[30] = v14;
      *(_WORD *)&v26[34] = 1024;
      *(_DWORD *)&v26[36] = v15;
      _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d new vfd=%d->fd=%d, and add to list", v26, 0x28u);
    }
  }
  v16 = *(_QWORD *)(v5 + 5576);
  if (v16)
  {
    do
    {
      v17 = v16;
      v16 = *(_QWORD *)(v16 + 352);
    }
    while (v16);
    v18 = (_QWORD *)(v17 + 352);
  }
  else
  {
    v18 = (_QWORD *)(v5 + 5576);
  }
  *v18 = v6;
  if (a1 <= 0xFFFFFFFD)
  {
    *(_BYTE *)(v5 + 40) = 1;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v20 = VRTraceErrorLogLevelToCSTR();
      v21 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v22 = *(unsigned __int8 *)(v5 + 40);
        v23 = *v6;
        *(_DWORD *)v26 = 136316418;
        *(_QWORD *)&v26[4] = v20;
        *(_WORD *)&v26[12] = 2080;
        *(_QWORD *)&v26[14] = "VTP_SocketForIDSWithFileDescriptor";
        *(_WORD *)&v26[22] = 1024;
        *(_DWORD *)&v26[24] = 1310;
        *(_WORD *)&v26[28] = 1024;
        *(_DWORD *)&v26[30] = v22;
        *(_WORD *)&v26[34] = 1024;
        *(_DWORD *)&v26[36] = v23;
        *(_WORD *)&v26[40] = 1024;
        *(_DWORD *)&v26[42] = a1;
        _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VTP set shouldLogFDsAtTimeout=%d with vfd=%d, fileDescriptor=%d", v26, 0x2Eu);
      }
    }
  }
  pthread_rwlock_unlock((pthread_rwlock_t *)(v5 + 5376));
  CheckOutHandleDebug();
  return *v6;
}

uint64_t VTP_SetPayloadList(int a1, int a2, const void *a3)
{
  uint64_t v6;
  uint64_t v7;
  pthread_rwlock_t *v8;
  int *v9;
  int *v10;
  uint64_t result;
  int *v12;
  int *v13;
  int v14;
  const void *v15;
  int v16;
  int v17;
  uint64_t v18;
  NSObject *v19;
  int v20;
  int v21;
  uint8_t buf[4];
  uint64_t v23;
  __int16 v24;
  const char *v25;
  __int16 v26;
  int v27;
  __int16 v28;
  int v29;
  __int16 v30;
  int v31;
  __int16 v32;
  char *v33;
  char __s[16];
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v6 = CheckInHandleDebug();
    if (v6)
    {
      v7 = v6;
      v8 = (pthread_rwlock_t *)(v6 + 5376);
      pthread_rwlock_wrlock((pthread_rwlock_t *)(v6 + 5376));
      v9 = *(int **)(v7 + 5576);
      if (!v9)
      {
LABEL_6:
        pthread_rwlock_unlock(v8);
        CheckOutHandleDebug();
        v10 = __error();
        result = 0;
        *v10 = 9;
        return result;
      }
      while (*v9 != a1)
      {
        v9 = (int *)*((_QWORD *)v9 + 44);
        if (!v9)
          goto LABEL_6;
      }
      v40 = 0u;
      v41 = 0u;
      v38 = 0u;
      v39 = 0u;
      v36 = 0u;
      v37 = 0u;
      *(_OWORD *)__s = 0u;
      v35 = 0u;
      v12 = (int *)malloc_type_calloc(v9[10] + (uint64_t)a2, 4uLL, 0x100004052888210uLL);
      if (v12)
      {
        v13 = v12;
        v14 = v9[10];
        if (v14)
        {
          v15 = (const void *)*((_QWORD *)v9 + 4);
          if (v15)
          {
            memcpy(v12, v15, 4 * v14);
            free(*((void **)v9 + 4));
            v14 = v9[10];
          }
        }
        memcpy(&v13[v14], a3, 4 * a2);
        v16 = v9[10] + a2;
        v9[10] = v16;
        *((_QWORD *)v9 + 4) = v13;
        if (v16 >= 1)
        {
          do
          {
            if (strlen(__s) > 0x77)
              break;
            v17 = *v13++;
            __sprintf_chk(__s, 0, 0x80uLL, "%s %i,", __s, v17);
          }
          while ((unint64_t)v13 < *((_QWORD *)v9 + 4) + 4 * v9[10]);
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v18 = VRTraceErrorLogLevelToCSTR();
          v19 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v20 = *v9;
            v21 = v9[10];
            *(_DWORD *)buf = 136316418;
            v23 = v18;
            v24 = 2080;
            v25 = "VTP_SetPayloadList";
            v26 = 1024;
            v27 = 1371;
            v28 = 1024;
            v29 = v20;
            v30 = 1024;
            v31 = v21;
            v32 = 2080;
            v33 = __s;
            _os_log_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VTP_SetPayloadList for vfd=%d: nPlList=%i payloads=%s", buf, 0x32u);
          }
        }
        pthread_rwlock_unlock(v8);
        CheckOutHandleDebug();
        return 0;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
      {
        VRTraceErrorLogLevelToCSTR();
        if ((VRTraceIsOSFaultDisabled() & 1) != 0)
        {
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VTP_SetPayloadList_cold_2();
        }
        else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_FAULT))
        {
          VTP_SetPayloadList_cold_3();
        }
      }
      pthread_rwlock_unlock(v8);
      *__error() = 12;
      CheckOutHandleDebug();
    }
    else
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VTP_SetPayloadList_cold_1();
      }
      *__error() = 13;
    }
    return 0xFFFFFFFFLL;
  }
  return 0;
}

uint64_t VTP_SetSocketMode(int a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  pthread_rwlock_t *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int *v10;
  int v11;

  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_SetSocketMode_cold_1();
    }
    v10 = __error();
    v11 = 22;
    goto LABEL_15;
  }
  v4 = CheckInHandleDebug();
  if (!v4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_SetSocketMode_cold_2();
    }
    v10 = __error();
    v11 = 13;
LABEL_15:
    *v10 = v11;
    return 0xFFFFFFFFLL;
  }
  v5 = v4;
  v6 = (pthread_rwlock_t *)(v4 + 5376);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(v4 + 5376));
  v7 = *(_QWORD *)(v5 + 5576);
  if (v7)
  {
    while (*(_DWORD *)v7 != a1)
    {
      v7 = *(_QWORD *)(v7 + 352);
      if (!v7)
        goto LABEL_6;
    }
    v9 = 0;
    v8 = 0;
    *(_DWORD *)(v7 + 16) = a2;
  }
  else
  {
LABEL_6:
    v8 = 0xFFFFFFFFLL;
    v9 = 1;
  }
  pthread_rwlock_unlock(v6);
  CheckOutHandleDebug();
  if (v9)
    *__error() = 9;
  return v8;
}

uint64_t VTP_SetPktType(int a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  pthread_rwlock_t *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;

  v4 = CheckInHandleDebug();
  if (v4)
  {
    v5 = v4;
    v6 = (pthread_rwlock_t *)(v4 + 5376);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v4 + 5376));
    v7 = *(_QWORD *)(v5 + 5576);
    if (v7)
    {
      while (*(_DWORD *)v7 != a1)
      {
        v7 = *(_QWORD *)(v7 + 352);
        if (!v7)
          goto LABEL_5;
      }
      v9 = 0;
      v8 = 0;
      *(_DWORD *)(v7 + 28) = a2;
    }
    else
    {
LABEL_5:
      v8 = 0xFFFFFFFFLL;
      v9 = 1;
    }
    pthread_rwlock_unlock(v6);
    CheckOutHandleDebug();
    if (v9)
      *__error() = 9;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_SetPktType_cold_1();
    }
    *__error() = 13;
    return 0xFFFFFFFFLL;
  }
  return v8;
}

uint64_t VTP_AddPktType(int a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  pthread_rwlock_t *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;

  v4 = CheckInHandleDebug();
  if (v4)
  {
    v5 = v4;
    v6 = (pthread_rwlock_t *)(v4 + 5376);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v4 + 5376));
    v7 = *(_QWORD *)(v5 + 5576);
    if (v7)
    {
      while (*(_DWORD *)v7 != a1)
      {
        v7 = *(_QWORD *)(v7 + 352);
        if (!v7)
          goto LABEL_5;
      }
      v9 = 0;
      v8 = 0;
      *(_DWORD *)(v7 + 28) |= a2;
    }
    else
    {
LABEL_5:
      v8 = 0xFFFFFFFFLL;
      v9 = 1;
    }
    pthread_rwlock_unlock(v6);
    CheckOutHandleDebug();
    if (v9)
      *__error() = 9;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_AddPktType_cold_1();
    }
    *__error() = 13;
    return 0xFFFFFFFFLL;
  }
  return v8;
}

uint64_t VTP_RemovePktType(int a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  pthread_rwlock_t *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;

  v4 = CheckInHandleDebug();
  if (v4)
  {
    v5 = v4;
    v6 = (pthread_rwlock_t *)(v4 + 5376);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v4 + 5376));
    v7 = *(_QWORD *)(v5 + 5576);
    if (v7)
    {
      while (*(_DWORD *)v7 != a1)
      {
        v7 = *(_QWORD *)(v7 + 352);
        if (!v7)
          goto LABEL_5;
      }
      v9 = 0;
      v8 = 0;
      *(_DWORD *)(v7 + 28) &= ~a2;
    }
    else
    {
LABEL_5:
      v8 = 0xFFFFFFFFLL;
      v9 = 1;
    }
    pthread_rwlock_unlock(v6);
    CheckOutHandleDebug();
    if (v9)
      *__error() = 9;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_RemovePktType_cold_1();
    }
    *__error() = 13;
    return 0xFFFFFFFFLL;
  }
  return v8;
}

uint64_t VTP_Getsockname(int a1, sockaddr *a2, socklen_t *a3)
{
  uint64_t v6;
  uint64_t v7;
  pthread_rwlock_t *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  NSObject *v12;
  NSObject *v13;
  const sockaddr *address;
  const sockaddr *v15;

  v6 = CheckInHandleDebug();
  if (v6)
  {
    v7 = v6;
    v8 = (pthread_rwlock_t *)(v6 + 5376);
    pthread_rwlock_rdlock((pthread_rwlock_t *)(v6 + 5376));
    v9 = *(_QWORD *)(v7 + 5576);
    if (v9)
    {
      while (*(_DWORD *)v9 != a1)
      {
        v9 = *(_QWORD *)(v9 + 352);
        if (!v9)
          goto LABEL_5;
      }
      if (*(_DWORD *)(v9 + 392) == 5 && (v12 = *(NSObject **)(v9 + 400)) != 0)
      {
        v13 = nw_connection_copy_endpoint(v12);
        address = nw_endpoint_get_address(v13);
        if (address)
        {
          v15 = address;
          memcpy(a2, address, address->sa_len);
          v10 = 0;
          *a3 = v15->sa_len;
        }
        else
        {
          v10 = 0xFFFFFFFFLL;
        }
        nw_release(v13);
      }
      else
      {
        v10 = getsockname(*(_DWORD *)(v9 + 20), a2, a3);
      }
      v11 = 0;
    }
    else
    {
LABEL_5:
      v10 = 0xFFFFFFFFLL;
      v11 = 1;
    }
    pthread_rwlock_unlock(v8);
    CheckOutHandleDebug();
    if (v11)
      *__error() = 9;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_Getsockname_cold_1();
    }
    *__error() = 13;
    return 0xFFFFFFFFLL;
  }
  return v10;
}

uint64_t _VTP_SetSSRC(int a1, int a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  pthread_rwlock_t *v8;
  uint64_t v9;
  int v10;

  v6 = CheckInHandleDebug();
  if (v6)
  {
    v7 = v6;
    v8 = (pthread_rwlock_t *)(v6 + 5376);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v6 + 5376));
    v9 = *(_QWORD *)(v7 + 5576);
    if (v9)
    {
      while (*(_DWORD *)v9 != a1 || (*(_BYTE *)(v9 + 28) & 0xF0) == 0)
      {
        v9 = *(_QWORD *)(v9 + 352);
        if (!v9)
          goto LABEL_6;
      }
      v10 = 0;
      if ((_DWORD)a3)
      {
        a3 = 0;
        *(_DWORD *)(v9 + 48) = a2;
        *(_BYTE *)(v9 + 27) = 1;
      }
      else
      {
        *(_DWORD *)(v9 + 44) = a2;
        *(_BYTE *)(v9 + 26) = 1;
      }
    }
    else
    {
LABEL_6:
      a3 = 0xFFFFFFFFLL;
      v10 = 1;
    }
    pthread_rwlock_unlock(v8);
    CheckOutHandleDebug();
    if (v10)
      *__error() = 9;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VTP_SetSSRC_cold_1();
    }
    *__error() = 13;
    return 0xFFFFFFFFLL;
  }
  return a3;
}

uint64_t VTP_SetRemoteSSRC(int a1, int a2)
{
  return _VTP_SetSSRC(a1, a2, 0);
}

uint64_t VTP_SetLocalSSRC(int a1, int a2)
{
  return _VTP_SetSSRC(a1, a2, 1);
}

uint64_t VTP_SetTransportSessionID(int a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  pthread_rwlock_t *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int *v10;
  int v11;

  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_SetTransportSessionID_cold_1();
    }
    v10 = __error();
    v11 = 22;
    goto LABEL_15;
  }
  v4 = CheckInHandleDebug();
  if (!v4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_SetTransportSessionID_cold_2();
    }
    v10 = __error();
    v11 = 13;
LABEL_15:
    *v10 = v11;
    return 0xFFFFFFFFLL;
  }
  v5 = v4;
  v6 = (pthread_rwlock_t *)(v4 + 5376);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(v4 + 5376));
  v7 = *(_QWORD *)(v5 + 5576);
  if (v7)
  {
    while (*(_DWORD *)v7 != a1)
    {
      v7 = *(_QWORD *)(v7 + 352);
      if (!v7)
        goto LABEL_6;
    }
    v9 = 0;
    v8 = 0;
    *(_DWORD *)(v7 + 56) = a2;
  }
  else
  {
LABEL_6:
    v8 = 0xFFFFFFFFLL;
    v9 = 1;
  }
  pthread_rwlock_unlock(v6);
  CheckOutHandleDebug();
  if (v9)
    *__error() = 9;
  return v8;
}

uint64_t VTP_GetTransportSessionID(int a1, _DWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  pthread_rwlock_t *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int *v10;
  int v11;

  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_GetTransportSessionID_cold_1();
    }
    v10 = __error();
    v11 = 22;
    goto LABEL_15;
  }
  v4 = CheckInHandleDebug();
  if (!v4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_GetTransportSessionID_cold_2();
    }
    v10 = __error();
    v11 = 13;
LABEL_15:
    *v10 = v11;
    return 0xFFFFFFFFLL;
  }
  v5 = v4;
  v6 = (pthread_rwlock_t *)(v4 + 5376);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(v4 + 5376));
  v7 = *(_QWORD *)(v5 + 5576);
  if (v7)
  {
    while (*(_DWORD *)v7 != a1)
    {
      v7 = *(_QWORD *)(v7 + 352);
      if (!v7)
        goto LABEL_6;
    }
    v9 = 0;
    v8 = 0;
    *a2 = *(_DWORD *)(v7 + 56);
  }
  else
  {
LABEL_6:
    v8 = 0xFFFFFFFFLL;
    v9 = 1;
  }
  pthread_rwlock_unlock(v6);
  CheckOutHandleDebug();
  if (v9)
    *__error() = 9;
  return v8;
}

uint64_t VTP_Setsockopt(int a1, int a2, int a3, const void *a4, socklen_t a5)
{
  uint64_t v10;
  uint64_t v11;
  pthread_rwlock_t *v12;
  uint64_t v13;
  uint64_t v14;
  int v15;

  v10 = CheckInHandleDebug();
  if (v10)
  {
    v11 = v10;
    v12 = (pthread_rwlock_t *)(v10 + 5376);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v10 + 5376));
    v13 = *(_QWORD *)(v11 + 5576);
    if (v13)
    {
      while (*(_DWORD *)v13 != a1)
      {
        v13 = *(_QWORD *)(v13 + 352);
        if (!v13)
          goto LABEL_5;
      }
      if (a2 == 258 && a3 == 1 || *(_DWORD *)(v13 + 392) == 5 && *(_QWORD *)(v13 + 400))
      {
        v15 = 0;
        v14 = 0;
      }
      else
      {
        v14 = setsockopt(*(_DWORD *)(v13 + 20), a2, a3, a4, a5);
        v15 = 0;
      }
    }
    else
    {
LABEL_5:
      v14 = 0xFFFFFFFFLL;
      v15 = 1;
    }
    pthread_rwlock_unlock(v12);
    CheckOutHandleDebug();
    if (v15)
      *__error() = 9;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_Setsockopt_cold_1();
    }
    *__error() = 13;
    return 0xFFFFFFFFLL;
  }
  return v14;
}

uint64_t VTP_SetSourceDestinationWithToken(int a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  pthread_rwlock_t *v6;
  uint64_t v7;
  int *v8;
  int v9;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  _OWORD v14[7];
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v4 = CheckInHandleDebug();
  if (!v4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_SetSourceDestinationWithToken_cold_1();
    }
    v8 = __error();
    v9 = 13;
    goto LABEL_10;
  }
  v5 = v4;
  v6 = (pthread_rwlock_t *)(v4 + 5376);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(v4 + 5376));
  v7 = *(_QWORD *)(v5 + 5576);
  if (!v7)
  {
LABEL_5:
    pthread_rwlock_unlock(v6);
    CheckOutHandleDebug();
    v8 = __error();
    v9 = 9;
LABEL_10:
    *v8 = v9;
    return 0xFFFFFFFFLL;
  }
  while (*(_DWORD *)v7 != a1)
  {
    v7 = *(_QWORD *)(v7 + 352);
    if (!v7)
      goto LABEL_5;
  }
  VCSDInfoConstructWithDatagramChannel((uint64_t)-[VCDatagramChannelManager datagramChannelWithChannelToken:](+[VCDatagramChannelManager sharedInstance](VCDatagramChannelManager, "sharedInstance"), "datagramChannelWithChannelToken:", a2), 0, 0, 0, (uint64_t)v14);
  v11 = v14[5];
  *(_OWORD *)(v7 + 456) = v14[4];
  *(_OWORD *)(v7 + 472) = v11;
  *(_OWORD *)(v7 + 488) = v14[6];
  *(_QWORD *)(v7 + 504) = v15;
  v12 = v14[1];
  *(_OWORD *)(v7 + 392) = v14[0];
  *(_OWORD *)(v7 + 408) = v12;
  v13 = v14[3];
  *(_OWORD *)(v7 + 424) = v14[2];
  *(_OWORD *)(v7 + 440) = v13;
  pthread_rwlock_unlock(v6);
  CheckOutHandleDebug();
  return 0;
}

uint64_t VTP_SetSourceDestinationWithIPPort(int a1)
{
  uint64_t v2;
  uint64_t v3;
  pthread_rwlock_t *v4;
  uint64_t v5;
  int *v6;
  int v7;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  _OWORD v13[7];
  uint64_t v14;
  _OWORD v15[2];
  unint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v2 = CheckInHandleDebug();
  if (!v2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_SetSourceDestinationWithIPPort_cold_1();
    }
    v6 = __error();
    v7 = 13;
    goto LABEL_10;
  }
  v3 = v2;
  v4 = (pthread_rwlock_t *)(v2 + 5376);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(v2 + 5376));
  v5 = *(_QWORD *)(v3 + 5576);
  if (!v5)
  {
LABEL_5:
    pthread_rwlock_unlock(v4);
    CheckOutHandleDebug();
    v6 = __error();
    v7 = 9;
LABEL_10:
    *v6 = v7;
    return 0xFFFFFFFFLL;
  }
  while (*(_DWORD *)v5 != a1)
  {
    v5 = *(_QWORD *)(v5 + 352);
    if (!v5)
      goto LABEL_5;
  }
  if (*(_DWORD *)(v5 + 392) != 5 || !*(_QWORD *)(v5 + 400))
  {
    v16 = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)&v9 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v15[0] = v9;
    v15[1] = v9;
    SAToIPPORT();
    VCSDInfoConstructWithSocket(*(_DWORD *)(v5 + 20), (uint64_t)v15, (uint64_t)v13);
    v10 = v13[5];
    *(_OWORD *)(v5 + 456) = v13[4];
    *(_OWORD *)(v5 + 472) = v10;
    *(_OWORD *)(v5 + 488) = v13[6];
    *(_QWORD *)(v5 + 504) = v14;
    v11 = v13[1];
    *(_OWORD *)(v5 + 392) = v13[0];
    *(_OWORD *)(v5 + 408) = v11;
    v12 = v13[3];
    *(_OWORD *)(v5 + 424) = v13[2];
    *(_OWORD *)(v5 + 440) = v12;
  }
  pthread_rwlock_unlock(v4);
  CheckOutHandleDebug();
  return 0;
}

uint64_t VTP_Close(int a1)
{
  uint64_t v2;
  uint64_t v3;
  pthread_rwlock_t *v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  NSObject *v12;
  int v14;
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v2 = CheckInHandleDebug();
  if (!v2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_Close_cold_1();
    }
    v9 = 0xFFFFFFFFLL;
    v10 = 13;
    goto LABEL_19;
  }
  v3 = v2;
  v4 = (pthread_rwlock_t *)(v2 + 5376);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(v2 + 5376));
  v5 = *(_QWORD *)(v3 + 5576);
  if (!v5)
    goto LABEL_13;
  if (*(_DWORD *)v5 != a1)
  {
    while (1)
    {
      v7 = v5;
      v5 = *(_QWORD *)(v5 + 352);
      if (!v5)
        break;
      if (*(_DWORD *)v5 == a1)
      {
        v6 = (_QWORD *)(v7 + 352);
        goto LABEL_8;
      }
    }
LABEL_13:
    v8 = 1;
    goto LABEL_14;
  }
  v6 = (_QWORD *)(v3 + 5576);
LABEL_8:
  VTP_CloseOneVFDList(v3, (int *)v5);
  *v6 = *(_QWORD *)(v5 + 352);
  free((void *)v5);
  v8 = 0;
LABEL_14:
  pthread_rwlock_unlock(v4);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v11 = VRTraceErrorLogLevelToCSTR();
    v12 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v14 = 136315906;
      v15 = v11;
      v16 = 2080;
      v17 = "VTP_Close";
      v18 = 1024;
      v19 = 1884;
      v20 = 1024;
      v21 = a1;
      _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d removed vfd (%d) from the list", (uint8_t *)&v14, 0x22u);
    }
  }
  CheckOutHandleDebug();
  v9 = 0;
  if (v8)
  {
    v10 = 9;
LABEL_19:
    *__error() = v10;
  }
  return v9;
}

uint64_t VTP_Bind(int a1, uint64_t a2, socklen_t a3)
{
  __int128 v6;
  uint64_t v7;
  uint64_t v8;
  pthread_rwlock_t *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  int *v14;
  int v15;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  NSObject *v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  unsigned int v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v33;
  NSObject *v34;
  __int128 v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  NSObject *v39;
  uint64_t v40;
  int v41;
  __int128 v42;
  socklen_t v43;
  _BYTE buf[48];
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  _BYTE v51[24];
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v51[16] = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v50 = v6;
  *(_OWORD *)v51 = v6;
  v7 = CheckInHandleDebug();
  if (!v7)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_Bind_cold_1();
    }
    v11 = 0xFFFFFFFFLL;
    v13 = 13;
    goto LABEL_18;
  }
  v8 = v7;
  v9 = (pthread_rwlock_t *)(v7 + 5376);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(v7 + 5376));
  v10 = *(_QWORD *)(v8 + 5576);
  if (!v10)
  {
LABEL_5:
    v11 = 0xFFFFFFFFLL;
    v12 = 1;
    goto LABEL_16;
  }
  while (*(_DWORD *)v10 != a1)
  {
    v10 = *(_QWORD *)(v10 + 352);
    if (!v10)
      goto LABEL_5;
  }
  if (*(_DWORD *)(v10 + 20) == -1)
  {
    v14 = __error();
    v12 = 0;
    v15 = 9;
    goto LABEL_14;
  }
  if (*(_BYTE *)(v10 + 24) == 1)
  {
    v14 = __error();
    v12 = 0;
    v15 = 22;
LABEL_14:
    *v14 = v15;
LABEL_15:
    v11 = 0xFFFFFFFFLL;
    goto LABEL_16;
  }
  SAToIPPORT();
  v17 = *(unsigned __int16 *)&v51[20];
  if (*(_DWORD *)(v10 + 16) == 2)
  {
    v18 = *(_QWORD *)(v8 + 5576);
    if (v18)
    {
      v19 = 0;
      while (1)
      {
        if (v10 != v18
          && *(_DWORD *)(v10 + 4) == *(_DWORD *)(v18 + 4)
          && *(_DWORD *)(v10 + 8) == *(_DWORD *)(v18 + 8)
          && *(_DWORD *)(v10 + 12) == *(_DWORD *)(v18 + 12)
          && *(_DWORD *)(v18 + 16) == 2
          && (v50 & 1) == (*(_DWORD *)(v18 + 60) & 1))
        {
          if ((v50 & 1) != 0)
          {
            if (*(_QWORD *)&v51[4] == *(_QWORD *)(v18 + 80) && *(_QWORD *)&v51[12] == *(_QWORD *)(v18 + 88))
            {
LABEL_37:
              if (!v19)
                v19 = v18;
              if (*(unsigned __int16 *)&v51[20] == *(unsigned __int16 *)(v18 + 96) && *(_BYTE *)(v18 + 24))
              {
                _VTP_ReleaseSocket(v8, v10);
                v37 = *(int *)(v18 + 20);
                *(_DWORD *)(v10 + 20) = v37;
                *(_BYTE *)(v10 + 24) = 1;
                ++*(_DWORD *)(v8 + 4 * v37 + 128);
                if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
                {
                  v38 = VRTraceErrorLogLevelToCSTR();
                  v39 = *MEMORY[0x1E0CF2758];
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                  {
                    v40 = *(int *)(v10 + 20);
                    v41 = *(_DWORD *)(v8 + 4 * v40 + 128);
                    *(_DWORD *)buf = 136316162;
                    *(_QWORD *)&buf[4] = v38;
                    *(_WORD *)&buf[12] = 2080;
                    *(_QWORD *)&buf[14] = "VTP_Bind";
                    *(_WORD *)&buf[22] = 1024;
                    *(_DWORD *)&buf[24] = 1940;
                    *(_WORD *)&buf[28] = 1024;
                    *(_DWORD *)&buf[30] = v40;
                    *(_WORD *)&buf[34] = 1024;
                    *(_DWORD *)&buf[36] = v41;
                    _os_log_impl(&dword_1D8A54000, v39, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d fd[%d] increase. RefCount[%d]", buf, 0x28u);
                  }
                }
                v12 = 0;
                v11 = 0;
                v42 = *(_OWORD *)v51;
                *(_OWORD *)(v10 + 60) = v50;
                *(_OWORD *)(v10 + 76) = v42;
                *(_QWORD *)(v10 + 92) = *(_QWORD *)&v51[16];
                goto LABEL_16;
              }
            }
          }
          else if (*(_DWORD *)&v51[4] == *(_DWORD *)(v18 + 80))
          {
            goto LABEL_37;
          }
        }
        v18 = *(_QWORD *)(v18 + 352);
        if (!v18)
        {
          if (!v19 || !*(_BYTE *)(v19 + 24))
            break;
          v21 = v19;
          _VTP_ReleaseSocket(v8, v10);
          v22 = *(int *)(v21 + 20);
          *(_DWORD *)(v10 + 20) = v22;
          *(_BYTE *)(v10 + 24) = 1;
          ++*(_DWORD *)(v8 + 4 * v22 + 128);
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v23 = VRTraceErrorLogLevelToCSTR();
            v24 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              v25 = *(int *)(v10 + 20);
              v26 = *(_DWORD *)(v8 + 4 * v25 + 128);
              *(_DWORD *)buf = 136316162;
              *(_QWORD *)&buf[4] = v23;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "VTP_Bind";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 1959;
              *(_WORD *)&buf[28] = 1024;
              *(_DWORD *)&buf[30] = v25;
              *(_WORD *)&buf[34] = 1024;
              *(_DWORD *)&buf[36] = v26;
              _os_log_impl(&dword_1D8A54000, v24, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d fd[%d] increase. RefCount[%d]", buf, 0x28u);
            }
          }
LABEL_69:
          v12 = 0;
          v11 = 0;
          goto LABEL_16;
        }
      }
    }
    *(_WORD *)(a2 + 2) = 4672;
    v17 = 16402;
  }
  v27 = bind(*(_DWORD *)(v10 + 20), (const sockaddr *)a2, a3);
  v11 = v27;
  if (*(_DWORD *)(v10 + 16) == 2 && (_DWORD)v27 == -1)
  {
    v28 = 1;
    do
    {
      *(_WORD *)(a2 + 2) = bswap32(v17 - v28) >> 16;
      v29 = bind(*(_DWORD *)(v10 + 20), (const sockaddr *)a2, a3);
      v30 = v28 + 1;
    }
    while ((_DWORD)v29 == -1 && v28++ < 9);
    v11 = v29;
    if ((_DWORD)v29 == -1 || v30 == 10)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v33 = VRTraceErrorLogLevelToCSTR();
        v34 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = v33;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "VTP_Bind";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 1978;
          _os_log_impl(&dword_1D8A54000, v34, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d All binding tries failed. Trying a random port...\n", buf, 0x1Cu);
        }
      }
      *(_WORD *)(a2 + 2) = 0;
      v11 = bind(*(_DWORD *)(v10 + 20), (const sockaddr *)a2, a3);
      if ((_DWORD)v11 == -1)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VTP_Bind_cold_2();
        }
        v12 = 0;
        goto LABEL_15;
      }
    }
  }
  if (!(_DWORD)v11)
  {
    *(_QWORD *)&v35 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v35 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v48 = v35;
    v49 = v35;
    v46 = v35;
    v47 = v35;
    *(_OWORD *)&buf[32] = v35;
    v45 = v35;
    *(_OWORD *)buf = v35;
    *(_OWORD *)&buf[16] = v35;
    v43 = 128;
    *(_BYTE *)(v10 + 24) = 1;
    getsockname(*(_DWORD *)(v10 + 20), (sockaddr *)buf, &v43);
    SAToIPPORT();
    v36 = *(_DWORD *)(v8 + 24);
    if (v36 != -1)
    {
      close(v36);
      *(_DWORD *)(v8 + 24) = -1;
    }
    goto LABEL_69;
  }
  v12 = 0;
LABEL_16:
  pthread_rwlock_unlock(v9);
  CheckOutHandleDebug();
  if (v12)
  {
    v13 = 9;
LABEL_18:
    *__error() = v13;
  }
  return v11;
}

void _VTP_ReleaseSocket(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  int v5;
  uint64_t v6;
  NSObject *v7;
  int v8;
  uint64_t v9;
  NSObject *v10;
  int v11;
  const char *v12;
  NSObject *v13;
  uint32_t v14;
  uint64_t v15;
  NSObject *v16;
  int v17;
  int v18;
  uint64_t v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v2 = *(unsigned int *)(a2 + 20);
  if (v2 <= 0x3FF)
  {
    v4 = a1 + 4 * v2;
    v5 = *(_DWORD *)(v4 + 128);
    *(_DWORD *)(v4 + 128) = v5 - 1;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v6 = VRTraceErrorLogLevelToCSTR();
      v7 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v8 = *(_DWORD *)(a2 + 20);
        v18 = 136316162;
        v19 = v6;
        v20 = 2080;
        v21 = "_VTP_ReleaseSocket";
        v22 = 1024;
        v23 = 619;
        v24 = 1024;
        v25 = v8;
        v26 = 1024;
        v27 = v5 - 1;
        _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d fd=%d decrease. RefCount=%d", (uint8_t *)&v18, 0x28u);
      }
    }
    if (v5 <= 0)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 7)
        goto LABEL_14;
      v15 = VRTraceErrorLogLevelToCSTR();
      v16 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        goto LABEL_14;
      v17 = *(_DWORD *)(a2 + 20);
      v18 = 136316162;
      v19 = v15;
      v20 = 2080;
      v21 = "_VTP_ReleaseSocket";
      v22 = 1024;
      v23 = 621;
      v24 = 1024;
      v25 = v17;
      v26 = 1024;
      v27 = v5 - 1;
      v12 = " [%s] %s:%d fd=%d over released. RefCount=%d";
      v13 = v16;
      v14 = 40;
    }
    else
    {
      if (v5 != 1)
        return;
      close(*(_DWORD *)(a2 + 20));
      if ((int)VRTraceGetErrorLogLevelForModule() < 7)
        goto LABEL_14;
      v9 = VRTraceErrorLogLevelToCSTR();
      v10 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        goto LABEL_14;
      v11 = *(_DWORD *)(a2 + 20);
      v18 = 136315906;
      v19 = v9;
      v20 = 2080;
      v21 = "_VTP_ReleaseSocket";
      v22 = 1024;
      v23 = 625;
      v24 = 1024;
      v25 = v11;
      v12 = " [%s] %s:%d fd=%d closed.";
      v13 = v10;
      v14 = 34;
    }
    _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, v12, (uint8_t *)&v18, v14);
LABEL_14:
    *(_DWORD *)(a2 + 20) = -1;
  }
}

uint64_t VTP_BindNew(int a1, uint64_t a2, socklen_t a3)
{
  uint64_t v6;
  uint64_t v7;
  pthread_rwlock_t *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  int *v14;
  int v15;
  int v17;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v24;
  NSObject *v25;
  __int128 v26;
  int v27;
  socklen_t v28;
  _BYTE buf[32];
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v6 = CheckInHandleDebug();
  if (!v6)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_BindNew_cold_1();
    }
    v10 = 0xFFFFFFFFLL;
    v12 = 13;
    goto LABEL_18;
  }
  v7 = v6;
  v8 = (pthread_rwlock_t *)(v6 + 5376);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(v6 + 5376));
  v9 = *(_QWORD *)(v7 + 5576);
  if (!v9)
  {
LABEL_5:
    v10 = 0xFFFFFFFFLL;
    v11 = 1;
    goto LABEL_16;
  }
  while (*(_DWORD *)v9 != a1)
  {
    v9 = *(_QWORD *)(v9 + 352);
    if (!v9)
      goto LABEL_5;
  }
  v13 = *(_DWORD *)(v9 + 20);
  if (v13 == -1)
  {
    v14 = __error();
    v11 = 0;
    v15 = 9;
    goto LABEL_14;
  }
  if (*(_BYTE *)(v9 + 24) == 1)
  {
    v14 = __error();
    v11 = 0;
    v15 = 22;
LABEL_14:
    *v14 = v15;
LABEL_15:
    v10 = 0xFFFFFFFFLL;
    goto LABEL_16;
  }
  v17 = *(unsigned __int16 *)(a2 + 2);
  if (*(_DWORD *)(v9 + 16) == 2 && v17 == 0)
  {
    *(_WORD *)(a2 + 2) = 4416;
    v17 = 16401;
  }
  v19 = bind(v13, (const sockaddr *)a2, a3);
  v10 = v19;
  if (*(_DWORD *)(v9 + 16) == 2 && (_DWORD)v19 == -1)
  {
    v20 = 1;
    do
    {
      *(_WORD *)(a2 + 2) = bswap32(v17 - v20) >> 16;
      v21 = bind(*(_DWORD *)(v9 + 20), (const sockaddr *)a2, a3);
      v22 = v20 + 1;
    }
    while ((_DWORD)v21 == -1 && v20++ < 9);
    if (v22 == 10 || (v10 = v21, (_DWORD)v21 == -1))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v24 = VRTraceErrorLogLevelToCSTR();
        v25 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = v24;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "VTP_BindNew";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 2059;
          _os_log_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d All binding tries failed. Trying a random port...\n", buf, 0x1Cu);
        }
      }
      *(_WORD *)(a2 + 2) = 0;
      v10 = bind(*(_DWORD *)(v9 + 20), (const sockaddr *)a2, a3);
      if ((_DWORD)v10 == -1)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VTP_BindNew_cold_2();
        }
        v11 = 0;
        goto LABEL_15;
      }
    }
  }
  if ((_DWORD)v10)
  {
    v11 = 0;
  }
  else
  {
    *(_QWORD *)&v26 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v26 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v34 = v26;
    v35 = v26;
    v32 = v26;
    v33 = v26;
    v30 = v26;
    v31 = v26;
    *(_OWORD *)buf = v26;
    *(_OWORD *)&buf[16] = v26;
    v28 = 128;
    *(_BYTE *)(v9 + 24) = 1;
    getsockname(*(_DWORD *)(v9 + 20), (sockaddr *)buf, &v28);
    SAToIPPORT();
    v27 = *(_DWORD *)(v7 + 24);
    if (v27 != -1)
    {
      close(v27);
      *(_DWORD *)(v7 + 24) = -1;
    }
    v11 = 0;
    v10 = 0;
  }
LABEL_16:
  pthread_rwlock_unlock(v8);
  CheckOutHandleDebug();
  if (v11)
  {
    v12 = 9;
LABEL_18:
    *__error() = v12;
  }
  return v10;
}

uint64_t VTP_Sendto(int a1, const void *a2, size_t a3, int a4, uint64_t a5, socklen_t a6, int *a7)
{
  char **p_name;
  uint64_t v15;
  unint64_t *v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  __int128 v21;
  unint64_t v22;
  unint64_t v23;
  int v24;
  int v26;
  unint64_t v28;
  int v29;
  __int128 v30;
  unsigned int v31;
  uint64_t v32;
  char v33;
  uint64_t v34;
  int v35;
  unint64_t v36;
  socklen_t v37;
  int v38;
  _QWORD *v39;
  unint64_t v41;
  unint64_t v42;
  _QWORD *v43;
  unsigned __int16 *v44;
  uint64_t v46;
  uint64_t v47;
  const void *v48;
  char **v49;
  uint64_t v50;
  int v51;
  int v52;
  uint64_t v53;
  unsigned int v54;
  int v55;
  int v56;
  unint64_t v57;
  char v58;
  int v59;
  _BOOL4 v60;
  int v61;
  __int128 v62;
  _DWORD *v63;
  NSObject *v64;
  NSObject *v65;
  NSObject *v66;
  int v67;
  uint64_t v68;
  size_t v69;
  unint64_t v70;
  int v71;
  uint64_t v72;
  int v73;
  unint64_t v74;
  socklen_t v75;
  int *v76;
  _QWORD *v77;
  int v78;
  int v79;
  char **v82;
  uint64_t v83;
  uint64_t v84;
  unsigned __int16 *v85;
  NSObject *v87;
  int v88;
  uint64_t v89;
  size_t v90;
  unint64_t v91;
  int v92;
  int v93;
  uint64_t v94;
  uint64_t v95;
  NSObject *v96;
  int v97;
  unint64_t v99;
  uint64_t v100;
  NSObject *v101;
  uint64_t v102;
  unint64_t v103;
  _QWORD *v104;
  uint64_t v105;
  NSObject *v106;
  uint64_t v107;
  pthread_rwlock_t *v109;
  int v110;
  int v111;
  unsigned int *v112;
  int v113;
  unsigned int v114;
  int v115;
  unint64_t v117;
  socklen_t v118;
  unint64_t v119;
  uint64_t v120;
  unsigned __int16 *v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  size_t v125;
  size_t v126;
  size_t v127;
  int log;
  int loga;
  NSObject *logb;
  int v131;
  _BOOL4 v132;
  pthread_rwlock_t *v133;
  unint64_t *v134;
  _BYTE v135[54];
  __int16 v136;
  int v137;
  __int16 v138;
  int v139;
  __int16 v140;
  size_t v141;
  __int16 v142;
  int v143;
  __int16 v144;
  int v145;
  __int128 v146;
  __int128 v147;
  unint64_t v148;
  _OWORD v149[2];
  _OWORD v150[2];
  _BYTE buf[54];
  uint64_t v152;

  v152 = *MEMORY[0x1E0C80C00];
  if (!a7)
  {
    *__error() = 22;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_Sendto_cold_1();
    }
    return -1;
  }
  if (*a7 >= 0x100)
  {
    *__error() = 22;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_Sendto_cold_2();
    }
    return -1;
  }
  p_name = &OBJC_PROTOCOL___GKNATObserverDelegate.name;
  v15 = CheckInHandleDebug();
  if (!v15)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_Sendto_cold_3();
    }
    *__error() = 13;
    return -1;
  }
  v16 = (unint64_t *)v15;
  v17 = *a7;
  if (*a7 >= 4 && (a7[37] & 3) == 1)
  {
    v18 = *(_QWORD *)(v15 + 8 * a1 + 13432);
    *(_QWORD *)v135 = a3;
    if ((DTLS_Write(v18, a2, a3, (size_t *)v135, v17) & 0x80000000) != 0)
    {
      *__error() = 22;
      if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      {
        v19 = -1;
      }
      else
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VTP_Sendto_cold_4();
        v19 = -1;
      }
    }
    else
    {
      v19 = *(_QWORD *)v135;
    }
    CheckOutHandleDebug();
    return v19;
  }
  v133 = (pthread_rwlock_t *)(v15 + 5376);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(v15 + 5376));
  v20 = a7[40];
  *(_QWORD *)&v135[32] = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v21 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v21 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)v135 = v21;
  *(_OWORD *)&v135[16] = v21;
  v134 = v16;
  v131 = a4;
  if (!v20)
  {
    v23 = v16[697];
    if (!v23)
    {
LABEL_49:
      v26 = 0;
      v22 = 0xAAAAAAAAAAAAAAAALL;
      goto LABEL_51;
    }
    while (*(_DWORD *)v23 != a1)
    {
      v23 = *(_QWORD *)(v23 + 352);
      if (!v23)
        goto LABEL_49;
    }
    SAToIPPORT();
    v22 = v16[735];
    if (!v22)
    {
LABEL_167:
      v26 = 0;
      v22 = 0xAAAAAAAAAAAAAAAALL;
      goto LABEL_52;
    }
    v78 = *(_DWORD *)(v23 + 60) & 1;
    v79 = v135[0] & 1;
    while (1)
    {
      if (v78 != (*(_DWORD *)(v22 + 28) & 1))
        goto LABEL_153;
      if (v78)
      {
        if (*(_QWORD *)(v23 + 80) != *(_QWORD *)(v22 + 48) || *(_QWORD *)(v23 + 88) != *(_QWORD *)(v22 + 56))
          goto LABEL_153;
      }
      else if (*(_DWORD *)(v23 + 80) != *(_DWORD *)(v22 + 48))
      {
        goto LABEL_153;
      }
      if (*(unsigned __int16 *)(v23 + 96) != *(unsigned __int16 *)(v22 + 64) || v79 != (*(_DWORD *)(v22 + 148) & 1))
        goto LABEL_153;
      if ((v135[0] & 1) != 0)
      {
        if (*(_QWORD *)&v135[20] != *(_QWORD *)(v22 + 168) || *(_QWORD *)&v135[28] != *(_QWORD *)(v22 + 176))
          goto LABEL_153;
      }
      else if (*(_DWORD *)&v135[20] != *(_DWORD *)(v22 + 168))
      {
        goto LABEL_153;
      }
      if (*(unsigned __int16 *)&v135[36] == *(unsigned __int16 *)(v22 + 184))
        goto LABEL_220;
LABEL_153:
      v82 = p_name;
      v83 = *(unsigned int *)(v22 + 320);
      if ((int)v83 >= 1)
      {
        v84 = 0;
        v85 = (unsigned __int16 *)(v22 + 512);
        do
        {
          if (v79 == (*((_DWORD *)v85 - 9) & 1))
          {
            if ((v135[0] & 1) != 0)
            {
              if (*(_QWORD *)&v135[20] == *((_QWORD *)v85 - 2) && *(_QWORD *)&v135[28] == *((_QWORD *)v85 - 1))
              {
LABEL_164:
                if (*(unsigned __int16 *)&v135[36] == *v85)
                {
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
                  {
                    v123 = VRTraceErrorLogLevelToCSTR();
                    logb = *MEMORY[0x1E0CF2758];
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 136315906;
                      *(_QWORD *)&buf[4] = v123;
                      *(_WORD *)&buf[12] = 2080;
                      *(_QWORD *)&buf[14] = "FindConnectionResultByKey";
                      *(_WORD *)&buf[22] = 1024;
                      *(_DWORD *)&buf[24] = 2447;
                      *(_WORD *)&buf[28] = 1024;
                      *(_DWORD *)&buf[30] = v84;
                      _os_log_impl(&dword_1D8A54000, logb, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d HandoverReport: packet destination matched connection result %d", buf, 0x22u);
                    }
                  }
                  v26 = v84 + 2;
                  p_name = v82;
LABEL_48:
                  v16 = v134;
                  goto LABEL_52;
                }
              }
            }
            else if (*(_DWORD *)&v135[20] == *((_DWORD *)v85 - 4))
            {
              goto LABEL_164;
            }
          }
          ++v84;
          v85 += 160;
        }
        while (v83 != v84);
      }
      v22 = *(_QWORD *)(v22 + 2056);
      p_name = v82;
      v16 = v134;
      if (!v22)
        goto LABEL_167;
    }
  }
  v22 = v16[735];
  if (!v22)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_Sendto_cold_5();
      v26 = 0;
      v22 = 0xAAAAAAAAAAAAAAAALL;
      goto LABEL_47;
    }
    goto LABEL_49;
  }
  v23 = v16[697];
  if (!v23)
  {
LABEL_29:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_Sendto_cold_6();
      v26 = 0;
LABEL_47:
      v23 = 0xAAAAAAAAAAAAAAAALL;
      goto LABEL_48;
    }
    v26 = 0;
LABEL_51:
    v23 = 0xAAAAAAAAAAAAAAAALL;
    goto LABEL_52;
  }
  v24 = *(_DWORD *)(v22 + 356) & 1;
  while (1)
  {
    if ((*(_DWORD *)(v23 + 60) & 1) == v24)
    {
      if (v24)
      {
        if (*(_QWORD *)(v23 + 80) != *(_QWORD *)(v22 + 376) || *(_QWORD *)(v23 + 88) != *(_QWORD *)(v22 + 384))
          goto LABEL_28;
      }
      else if (*(_DWORD *)(v23 + 80) != *(_DWORD *)(v22 + 376))
      {
        goto LABEL_28;
      }
      if (*(unsigned __int16 *)(v23 + 96) == *(unsigned __int16 *)(v22 + 392))
        break;
    }
LABEL_28:
    v23 = *(_QWORD *)(v23 + 352);
    if (!v23)
      goto LABEL_29;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v126 = a3;
    v95 = VRTraceErrorLogLevelToCSTR();
    v96 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v97 = *(_DWORD *)v23;
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = v95;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "FindConnectionResultByKey";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 2410;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = v97;
      _os_log_impl(&dword_1D8A54000, v96, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VTP default result key uses vfd(%d) for send.", buf, 0x22u);
    }
    v26 = 1;
    a3 = v126;
    goto LABEL_48;
  }
LABEL_220:
  v26 = 1;
LABEL_52:
  if (a7[39])
  {
    v28 = v16[697];
    if (v28)
    {
      while (*(_DWORD *)v28 != a1)
      {
        v28 = *(_QWORD *)(v28 + 352);
        if (!v28)
          goto LABEL_56;
      }
      v52 = v26;
      v53 = SendOnePacketOnVFDList(v134, (int *)v28, (uint64_t)a2, a3, v131, a5, a6, a7, 0);
      v26 = v52;
      v19 = v53;
      v29 = 1;
    }
    else
    {
LABEL_56:
      v29 = 0;
      v19 = -1;
    }
    log = v26;
    if (v26)
    {
      if (v26 == 3)
      {
        v54 = *(_DWORD *)(v22 + 676);
        v55 = v54 & (v54 << 29 >> 31);
        v56 = (v54 >> 2) & 1;
        goto LABEL_112;
      }
LABEL_111:
      v56 = 0;
      v55 = 0;
LABEL_112:
      v60 = v56 != 0;
      v61 = v55 != 0;
      if (!v29)
      {
        v28 = 0;
        goto LABEL_219;
      }
      v132 = v55 != 0;
      v125 = a3;
LABEL_114:
      *(_QWORD *)&buf[46] = 0xAAAAAAAAAAAAAAAALL;
      *(_QWORD *)&v62 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v62 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)&buf[16] = v62;
      *(_OWORD *)&buf[32] = v62;
      *(_OWORD *)buf = v62;
      *(_QWORD *)((char *)v150 + 14) = 0xAAAAAAAAAAAAAAAALL;
      v149[1] = v62;
      v150[0] = v62;
      v149[0] = v62;
      v148 = 0xAAAAAAAAAAAAAAAALL;
      v146 = v62;
      v147 = v62;
      SAToIPPORT();
      v63 = (_DWORD *)(v28 + 60);
      IPPORTToStringWithSize();
      IPPORTToStringWithSize();
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v122 = VRTraceErrorLogLevelToCSTR();
        v64 = *MEMORY[0x1E0CF2758];
        v65 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
          {
            v66 = v64;
            v67 = *v63 & 4;
            v68 = 48;
            if (!v55)
              v68 = 28;
            v69 = v68 + v125;
            v70 = v134[735];
            if (v70)
            {
              v71 = *(_DWORD *)(v70 + 320);
              v72 = v122;
              if (v71 == 2)
              {
                v73 = *(_DWORD *)(v70 + 676) & 4;
                v71 = 2;
              }
              else
              {
                v73 = -1;
              }
            }
            else
            {
              v71 = -1;
              v73 = -1;
              v72 = v122;
            }
            *(_DWORD *)v135 = 136317698;
            *(_QWORD *)&v135[4] = v72;
            *(_WORD *)&v135[12] = 2080;
            *(_QWORD *)&v135[14] = "VTP_Sendto";
            *(_WORD *)&v135[22] = 1024;
            *(_DWORD *)&v135[24] = 2588;
            *(_WORD *)&v135[28] = 2080;
            *(_QWORD *)&v135[30] = v149;
            *(_WORD *)&v135[38] = 1024;
            *(_DWORD *)&v135[40] = v67;
            *(_WORD *)&v135[44] = 2080;
            *(_QWORD *)&v135[46] = buf;
            v136 = 1024;
            v137 = log;
            v138 = 1024;
            v139 = v56;
            v140 = 2048;
            v141 = v69;
            v142 = 1024;
            v143 = v71;
            v144 = 1024;
            v145 = v73;
            _os_log_impl(&dword_1D8A54000, v66, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VTP_Sendto: isICEPacket = 1  mbLocal = %s, mbLocalIsCellular = %d, mbDst = %s, matchedType = %d, shouldCountBytes = %d, length = %lu, numResult = %d, isSecondaryCellular = %d", v135, 0x58u);
          }
        }
        else if (os_log_type_enabled(v65, OS_LOG_TYPE_DEBUG))
        {
          v87 = v64;
          v88 = *v63 & 4;
          v89 = 48;
          if (!v55)
            v89 = 28;
          v90 = v89 + v125;
          v91 = v134[735];
          if (v91)
          {
            v92 = *(_DWORD *)(v91 + 320);
            v94 = v122;
            if (v92 == 2)
            {
              v93 = *(_DWORD *)(v91 + 676) & 4;
              v92 = 2;
            }
            else
            {
              v93 = -1;
            }
          }
          else
          {
            v92 = -1;
            v93 = -1;
            v94 = v122;
          }
          *(_DWORD *)v135 = 136317698;
          *(_QWORD *)&v135[4] = v94;
          *(_WORD *)&v135[12] = 2080;
          *(_QWORD *)&v135[14] = "VTP_Sendto";
          *(_WORD *)&v135[22] = 1024;
          *(_DWORD *)&v135[24] = 2588;
          *(_WORD *)&v135[28] = 2080;
          *(_QWORD *)&v135[30] = v149;
          *(_WORD *)&v135[38] = 1024;
          *(_DWORD *)&v135[40] = v88;
          *(_WORD *)&v135[44] = 2080;
          *(_QWORD *)&v135[46] = buf;
          v136 = 1024;
          v137 = log;
          v138 = 1024;
          v139 = v56;
          v140 = 2048;
          v141 = v90;
          v142 = 1024;
          v143 = v92;
          v144 = 1024;
          v145 = v93;
          _os_log_debug_impl(&dword_1D8A54000, v87, OS_LOG_TYPE_DEBUG, " [%s] %s:%d VTP_Sendto: isICEPacket = 1  mbLocal = %s, mbLocalIsCellular = %d, mbDst = %s, matchedType = %d, shouldCountBytes = %d, length = %lu, numResult = %d, isSecondaryCellular = %d", v135, 0x58u);
        }
      }
      v109 = v133;
      v61 = v132;
      goto LABEL_225;
    }
    v57 = v134[735];
    if (!v57 || *(_DWORD *)(v57 + 320) != 2)
      goto LABEL_111;
    v58 = v29 ^ 1;
    if ((*(_DWORD *)(v57 + 676) & 4) == 0)
      v58 = 1;
    if ((v58 & 1) != 0)
      goto LABEL_111;
    v59 = *(_DWORD *)(v28 + 60);
    v125 = a3;
    if ((v59 & 1) == (*(_DWORD *)(v57 + 676) & 1))
    {
      if ((v59 & 1) == 0)
      {
        if (*(_DWORD *)(v28 + 80) != *(_DWORD *)(v57 + 696))
          goto LABEL_252;
LABEL_250:
        if (*(unsigned __int16 *)(v28 + 96) != *(unsigned __int16 *)(v57 + 712))
          goto LABEL_252;
        v55 = v59 & 1;
        v60 = 1;
        v22 = v134[735];
        v23 = v28;
LABEL_253:
        v132 = v55 != 0;
        v56 = v60;
        goto LABEL_114;
      }
      if (*(_QWORD *)(v28 + 80) == *(_QWORD *)(v57 + 696) && *(_QWORD *)(v28 + 88) == *(_QWORD *)(v57 + 704))
        goto LABEL_250;
    }
LABEL_252:
    v60 = 0;
    v55 = 0;
    goto LABEL_253;
  }
  *(_QWORD *)&v30 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v30 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v135[16] = v30;
  *(_OWORD *)&v135[32] = v30;
  *(_OWORD *)v135 = v30;
  v31 = v26 - 2;
  if ((v26 - 2) >= 2)
  {
    if (v26)
    {
      if (v26 == 1)
      {
        if (*(int *)(v22 + 320) < 1)
        {
          LOBYTE(v34) = 0;
          v33 = 0;
          v28 = 0;
          v19 = -1;
          goto LABEL_217;
        }
        v124 = a3;
        v32 = 0;
        v28 = 0;
        v33 = 0;
        v34 = 0;
        v19 = -1;
        v35 = -1;
        v119 = v22;
        while (1)
        {
          v36 = v22 + 320 * v32;
          v37 = *(_DWORD *)(v22 + 4 * v32 + 1224);
          v38 = *(_DWORD *)(v36 + 356) & 1;
          if (v38 == (*(_DWORD *)(v23 + 60) & 1))
          {
            v39 = (_QWORD *)(v22 + 320 * v32 + 376);
            if (v38)
            {
              if (*v39 == *(_QWORD *)(v23 + 80) && *(_QWORD *)(v22 + 320 * v32 + 384) == *(_QWORD *)(v23 + 88))
              {
LABEL_71:
                v41 = v23;
                if (*(unsigned __int16 *)(v22 + 320 * v32 + 392) == *(unsigned __int16 *)(v23 + 96))
                  goto LABEL_87;
              }
            }
            else if (*(_DWORD *)v39 == *(_DWORD *)(v23 + 80))
            {
              goto LABEL_71;
            }
          }
          v41 = v134[697];
          if (!v41)
          {
LABEL_85:
            v28 = 0;
            goto LABEL_88;
          }
          v42 = v22 + 320 * v32;
          v43 = (_QWORD *)(v42 + 376);
          v44 = (unsigned __int16 *)(v42 + 392);
          while (1)
          {
            if (v38 == (*(_DWORD *)(v41 + 60) & 1))
            {
              if (v38)
              {
                if (*v43 != *(_QWORD *)(v41 + 80) || v43[1] != *(_QWORD *)(v41 + 88))
                  goto LABEL_84;
              }
              else if (*(_DWORD *)v43 != *(_DWORD *)(v41 + 80))
              {
                goto LABEL_84;
              }
              if (*v44 == *(unsigned __int16 *)(v41 + 96))
                break;
            }
LABEL_84:
            v41 = *(_QWORD *)(v41 + 352);
            if (!v41)
              goto LABEL_85;
          }
          v28 = v41;
LABEL_87:
          v46 = v22 + (v32 << 7) + 968;
          v47 = (uint64_t)a2;
          v48 = a2;
          v49 = p_name;
          v50 = v34;
          v35 = SendOnePacketOnVFDList(v134, (int *)v41, v47, v124, v131, v46, v37, a7, v36 + 328);
          v34 = v50;
          p_name = v49;
          a2 = v48;
          v22 = v119;
LABEL_88:
          if (v35 != -1)
          {
            v19 = v35;
            if (v32)
            {
              v51 = *(_DWORD *)(v36 + 356);
              v34 = (v51 & 4) != 0 ? 1 : v34;
              if ((v51 & 4) != 0)
                v33 = v51 & 1;
            }
          }
          if (*(_DWORD *)(v22 + 324))
          {
            if (++v32 < *(int *)(v22 + 320))
              continue;
          }
LABEL_217:
          v60 = v34 & 1;
          v61 = v33 & 1;
          goto LABEL_219;
        }
      }
      v60 = 0;
      v61 = 0;
      v28 = 0;
    }
    else
    {
      v28 = v16[697];
      if (v28)
      {
        while (*(_DWORD *)v28 != a1)
        {
          v28 = *(_QWORD *)(v28 + 352);
          if (!v28)
            goto LABEL_171;
        }
        v19 = SendOnePacketOnVFDList(v134, (int *)v28, (uint64_t)a2, a3, v131, a5, a6, a7, 0);
        v60 = 0;
        v61 = 0;
LABEL_219:
        v109 = v133;
        goto LABEL_225;
      }
LABEL_171:
      v60 = 0;
      v61 = 0;
    }
    v19 = -1;
    goto LABEL_219;
  }
  loga = v26;
  v74 = v22 + 320 * v31;
  v120 = (v26 - 2);
  v75 = *(_DWORD *)(v22 + 4 * v31 + 1224);
  v76 = (int *)(v74 + 356);
  if ((*(_DWORD *)(v74 + 356) & 1) != (*(_DWORD *)(v23 + 60) & 1))
    goto LABEL_196;
  v77 = (_QWORD *)(v22 + 320 * v120 + 376);
  if ((*(_DWORD *)(v74 + 356) & 1) != 0)
  {
    if (*v77 != *(_QWORD *)(v23 + 80) || *(_QWORD *)(v22 + 320 * v120 + 384) != *(_QWORD *)(v23 + 88))
      goto LABEL_196;
LABEL_194:
    if (*(unsigned __int16 *)(v22 + 320 * v120 + 392) == *(unsigned __int16 *)(v23 + 96))
    {
      v28 = 0;
      v99 = v23;
      goto LABEL_239;
    }
    goto LABEL_196;
  }
  if (*(_DWORD *)v77 == *(_DWORD *)(v23 + 80))
    goto LABEL_194;
LABEL_196:
  v117 = v22 + 320 * v31;
  v118 = *(_DWORD *)(v22 + 4 * v31 + 1224);
  v127 = a3;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v100 = VRTraceErrorLogLevelToCSTR();
    v101 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v102 = IPToString();
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = v100;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "VTP_Sendto";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 2645;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = v102;
      _os_log_impl(&dword_1D8A54000, v101, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d HandoverReport: matching localIP: %s", buf, 0x26u);
    }
  }
  v99 = v16[697];
  if (!v99)
  {
LABEL_215:
    v28 = 0;
    v19 = -1;
    goto LABEL_240;
  }
  v103 = v22 + 320 * v120;
  v104 = (_QWORD *)(v103 + 376);
  v121 = (unsigned __int16 *)(v103 + 392);
  while (1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v105 = VRTraceErrorLogLevelToCSTR();
      v106 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v107 = IPToString();
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = v105;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "VTP_Sendto";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 2648;
        *(_WORD *)&buf[28] = 2080;
        *(_QWORD *)&buf[30] = v107;
        _os_log_impl(&dword_1D8A54000, v106, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d HandoverReport: matching vfd, %s", buf, 0x26u);
      }
    }
    if ((*v76 & 1) != (*(_DWORD *)(v99 + 60) & 1))
      goto LABEL_214;
    if ((*v76 & 1) != 0)
    {
      if (*v104 != *(_QWORD *)(v99 + 80) || v104[1] != *(_QWORD *)(v99 + 88))
        goto LABEL_214;
    }
    else if (*(_DWORD *)v104 != *(_DWORD *)(v99 + 80))
    {
      goto LABEL_214;
    }
    if (*v121 == *(unsigned __int16 *)(v99 + 96))
      break;
LABEL_214:
    v99 = *(_QWORD *)(v99 + 352);
    if (!v99)
      goto LABEL_215;
  }
  v28 = v99;
  a3 = v127;
  v75 = v118;
  v74 = v117;
LABEL_239:
  v19 = SendOnePacketOnVFDList(v134, (int *)v99, (uint64_t)a2, a3, v131, v22 + (v120 << 7) + 968, v75, a7, v74 + 328);
LABEL_240:
  v109 = v133;
  if (loga == 3)
  {
    v115 = *v76;
    v61 = *v76 & 1;
    v60 = (*v76 & 4) != 0;
    if ((v115 & 4) == 0)
      v61 = 0;
  }
  else
  {
    v60 = 0;
    v61 = 0;
  }
LABEL_225:
  if (v19 >= 1 && v60)
  {
    if (v61)
      v110 = 48;
    else
      v110 = 28;
    v111 = *(_DWORD *)(v23 + 28);
    if ((v111 & 0xF0) != 0)
    {
      v112 = (unsigned int *)(v22 + 2044);
LABEL_234:
      v113 = v110 + v19;
      do
        v114 = __ldxr(v112);
      while (__stxr(v114 + v113, v112));
    }
    else if ((v111 & 0xBC0E) != 0)
    {
      v112 = (unsigned int *)(v22 + 2052);
      goto LABEL_234;
    }
  }
  pthread_rwlock_unlock(v109);
  CheckOutHandleDebug();
  if (!v28)
    *__error() = 9;
  return v19;
}

uint64_t SendOnePacketOnVFDList(unint64_t *a1, int *a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, socklen_t a7, int *a8, uint64_t a9)
{
  socklen_t v9;
  uint64_t v10;
  __int128 v12;
  unsigned int v13;
  _BOOL4 v14;
  unsigned int v15;
  int *v16;
  unsigned int v17;
  int v18;
  char v19;
  char *v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  _QWORD *v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int **v29;
  uint64_t result;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  char v34;
  int v35;
  int v36;
  int v37;
  int v38;
  uint64_t v39;
  unint64_t v40;
  _BOOL4 v41;
  int v43;
  char *v44;
  unsigned int v45;
  msghdr v46;
  socklen_t v47;
  int v48;
  _DWORD v49[2];
  unint64_t v50;
  unint64_t v51;
  _OWORD v52[8];
  _OWORD v53[5];
  uint64_t v54;

  v9 = a7;
  v10 = (uint64_t)a2;
  v54 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v12 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v46.msg_iov = v12;
  *(_OWORD *)&v46.msg_control = v12;
  *(_OWORD *)&v46.msg_name = v12;
  v50 = 0xAAAAAAAAAAAAAAAALL;
  v51 = 0xAAAAAAAAAAAAAAAALL;
  v53[3] = v12;
  v53[4] = v12;
  v53[1] = v12;
  v53[2] = v12;
  v13 = a8[1];
  v45 = 0;
  memset(v49, 170, 6);
  v47 = a7;
  v48 = -1431655766;
  v52[7] = v12;
  v53[0] = v12;
  v52[5] = v12;
  v52[6] = v12;
  v52[3] = v12;
  v52[4] = v12;
  v52[1] = v12;
  v52[2] = v12;
  v14 = a9 == 0;
  v52[0] = v12;
  if (!a9)
  {
    v43 = a5;
    if ((int)a4 >= 4 && (*(_WORD *)a3 & 0xC0) == 0x40 && (_DWORD)a4 - 4 == bswap32(*(unsigned __int16 *)(a3 + 2)) >> 16)
    {
      a2[58] = *(_DWORD *)a3;
      v16 = a2 + 58;
      v15 = 4;
      goto LABEL_5;
    }
LABEL_11:
    v14 = 0;
    v15 = 0;
    v17 = 0;
    goto LABEL_12;
  }
  if (!*(_DWORD *)(a9 + 20))
  {
    v43 = a5;
    goto LABEL_11;
  }
  if (*(_WORD *)(a9 + 24) == 1)
  {
    v43 = a5;
    v15 = 0;
    *((_WORD *)a2 + 116) = bswap32(*(unsigned __int16 *)(a9 + 26)) >> 16;
    v16 = a2 + 58;
    *((_WORD *)a2 + 117) = bswap32(a4) >> 16;
LABEL_5:
    *(_QWORD *)&v53[0] = v16;
    *((_QWORD *)&v53[0] + 1) = 4;
    v17 = 1;
LABEL_12:
    v18 = *a8;
    if ((a8[37] & 2) != 0 || (v18 | 4) == 6 && *((_BYTE *)a8 + 12))
      v19 = 32;
    else
      v19 = 0;
    v20 = (char *)a1 + 21625;
    if (v18 == 6 || v18 == 2)
    {
      v44 = (char *)a1 + 21625;
    }
    else
    {
      if (!v18)
      {
        v21 = v17;
        *(_QWORD *)&v53[v17] = a3 + v15;
        v22 = v17 + 1;
        v23 = a4 - v15;
LABEL_45:
        *((_QWORD *)&v53[v21] + 1) = v23;
        __memcpy_chk();
        if (*(_BYTE *)(v10 + 368))
        {
          VTP_AddNAT64PrefixToIPv4Destination(v10, (uint64_t)v52, &v47);
          v9 = v47;
        }
        v46.msg_name = v52;
        v46.msg_namelen = v9;
        v46.msg_iov = (iovec *)v53;
        v46.msg_iovlen = v22;
        v46.msg_flags = 0;
        if (*v20)
        {
          v46.msg_control = 0;
          v46.msg_controllen = 0;
        }
        else
        {
          v46.msg_control = &v50;
          v46.msg_controllen = 16;
          v50 = 0xFFFF00000010;
          LODWORD(v51) = 4230;
          v37 = *(_DWORD *)(v20 + 3);
          if (!v37)
            v37 = v43;
          HIDWORD(v51) = v37;
        }
        LODWORD(result) = sendmsg(*(_DWORD *)(v10 + 20), &v46, 0);
        if ((int)result >= 1)
        {
          if ((*(_BYTE *)(v10 + 60) & 1) != 0)
            v38 = 48;
          else
            v38 = 28;
          v39 = v38 + (int)result;
          do
            v40 = __ldxr(a1);
          while (__stxr(v40 + v39, a1));
        }
        return (int)result;
      }
      v44 = (char *)a1 + 21625;
      v19 |= 8u;
    }
    LOBYTE(v49[0]) = v19;
    BYTE1(v49[0]) = v18;
    *(_DWORD *)((char *)v49 + 2) = bswap32(v13);
    v24 = &v53[v17];
    v25 = v17 + 1;
    *v24 = v49;
    v24[1] = 6;
    if ((v19 & 8) != 0)
    {
      v41 = v14;
      v26 = v15;
      v27 = a3;
      v28 = a4;
      if ((PrepareOFTMAC((const __CFString *)a1[*a2 + 755], (const void *)(a3 + v15), a4 - v15, &v48) & 0x80000000) != 0)
      {
        v19 ^= 8u;
        LOBYTE(v49[0]) = v19;
      }
      else
      {
        v29 = (int **)&v53[v25];
        v25 = v17 | 2;
        *v29 = &v48;
        v29[1] = (int *)4;
      }
      a3 = v27;
      a4 = v28;
      v10 = (uint64_t)a2;
      v14 = v41;
    }
    else
    {
      v26 = v15;
    }
    v31 = a3 + v26;
    v32 = &v53[v25];
    v33 = a4 - v26;
    v21 = (v25 + 1);
    *v32 = v31;
    v32[1] = v33;
    if (a9)
    {
      if (*(_DWORD *)(a9 + 20))
        v34 = 1;
      else
        v34 = v14;
      if ((v34 & 1) != 0)
        goto LABEL_38;
    }
    else if (v14)
    {
LABEL_38:
      if ((v19 & 8) != 0)
        v35 = 14;
      else
        v35 = 10;
      *(_WORD *)(v10 + 234) = bswap32(v35 + a4 - v15) >> 16;
      v36 = 1;
      goto LABEL_44;
    }
    v36 = 0;
LABEL_44:
    PrepareOFTCRC32((uint64_t)v53, v25 + 1, v36, &v45);
    *(_QWORD *)&v53[v25 + 1] = &v45;
    v22 = v25 + 2;
    v23 = 4;
    v20 = v44;
    goto LABEL_45;
  }
  *__error() = 22;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      SendOnePacketOnVFDList_cold_1();
  }
  return -1;
}

uint64_t VTP_Send(int a1, _OWORD *a2, size_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  int *v9;
  int v10;
  _BOOL4 v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  int v18;
  void *v19;
  int v20;
  _QWORD *PacketRoutingInfoList;
  uint64_t v22;
  NSObject *v23;
  NSObject *v24;
  char *v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31;
  unint64_t *v32;
  unsigned int v33;
  uint64_t v34;
  _QWORD *v35;
  int v36;
  _BOOL4 v37;
  int v39;
  BOOL v40;
  uint64_t v41;
  unint64_t v42;
  int v43;
  int v44;
  _QWORD *v46;
  pthread_rwlock_t *v47;
  int v48;
  int v49;
  unsigned int v50;
  int v51;
  int v52;
  void *v53;
  int v55;
  uint8_t buf[4];
  uint64_t v58;
  __int16 v59;
  const char *v60;
  __int16 v61;
  int v62;
  uint64_t v63;

  v63 = *MEMORY[0x1E0C80C00];
  if (!a5)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_Send_cold_1();
    }
    v9 = __error();
    v10 = 22;
    goto LABEL_14;
  }
  if (!*(_BYTE *)(a5 + 218))
  {
    v8 = 0;
    if (!a2 || !a3)
      return v8;
  }
  if (*(_BYTE *)(a5 + 313))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_Send_cold_5();
    }
    v9 = __error();
    v10 = 81;
LABEL_14:
    *v9 = v10;
    return -1;
  }
  v13 = (_DWORD)a4 == 800 || (_DWORD)a4 == 700;
  v51 = *(unsigned __int8 *)(a5 + 205);
  v52 = v13;
  v49 = *(unsigned __int8 *)(a5 + 204);
  v50 = *(unsigned __int8 *)(a5 + 200);
  v14 = CheckInHandleDebug();
  if (!v14)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_Send_cold_2();
    }
    v9 = __error();
    v10 = 13;
    goto LABEL_14;
  }
  v15 = v14;
  if ((_DWORD)a4 == 800 || (_DWORD)a4 == 700)
  {
    v16 = (unint64_t *)(v14 + 21968);
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }
  pthread_rwlock_rdlock((pthread_rwlock_t *)(v14 + 21640));
  v18 = *(_DWORD *)(a5 + 8);
  v47 = (pthread_rwlock_t *)(v15 + 21640);
  if (v18)
  {
    v19 = (void *)VTP_getConnectionManagerForCallID(v15, v18);
    v20 = *(unsigned __int8 *)(a5 + 169);
    if (objc_msgSend(v19, "isPreWarmStateEnabled"))
      v20 |= *(unsigned __int8 *)(a5 + 170);
    buf[0] = v20 != 0;
    buf[1] = 1;
    buf[2] = *(_BYTE *)(a5 + 309);
    buf[3] = *(_BYTE *)(a5 + 233);
    LOBYTE(v58) = *(_BYTE *)(a5 + 312);
    PacketRoutingInfoList = VCConnectionManager_CreatePacketRoutingInfoList((uint64_t)v19, buf, *(const __CFAllocator **)(v15 + 22040));
  }
  else
  {
    if (*(_DWORD *)(a5 + 24))
    {
      v25 = (char *)CFAllocatorAllocate(*(CFAllocatorRef *)(v15 + 22040), 136, 0);
      if (!v25)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VTP_Send_cold_4();
        }
        goto LABEL_92;
      }
      PacketRoutingInfoList = v25;
      v53 = 0;
      v26 = *(_OWORD *)(a5 + 24);
      v27 = *(_OWORD *)(a5 + 40);
      v28 = *(_OWORD *)(a5 + 56);
      *(_OWORD *)(v25 + 56) = *(_OWORD *)(a5 + 72);
      *(_OWORD *)(v25 + 40) = v28;
      *(_OWORD *)(v25 + 24) = v27;
      *(_OWORD *)(v25 + 8) = v26;
      v29 = *(_OWORD *)(a5 + 88);
      v30 = *(_OWORD *)(a5 + 104);
      v31 = *(_QWORD *)(a5 + 136);
      *(_OWORD *)(v25 + 104) = *(_OWORD *)(a5 + 120);
      *(_OWORD *)(v25 + 88) = v30;
      *(_OWORD *)(v25 + 72) = v29;
      *((_QWORD *)v25 + 15) = v31;
      *((_QWORD *)v25 + 16) = 0;
      goto LABEL_43;
    }
    PacketRoutingInfoList = _VTP_CreatePacketRoutingInfoListWithVFD(a1);
    v19 = 0;
  }
  v53 = v19;
  if (!PacketRoutingInfoList)
  {
    *__error() = 22;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v22 = VRTraceErrorLogLevelToCSTR();
      v23 = *MEMORY[0x1E0CF2758];
      v24 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          v58 = v22;
          v59 = 2080;
          v60 = "VTP_Send";
          v61 = 1024;
          v62 = 2915;
          _os_log_impl(&dword_1D8A54000, v23, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d infoList is NULL! Dropped packet!", buf, 0x1Cu);
        }
      }
      else if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
      {
        VTP_Send_cold_3();
      }
    }
LABEL_92:
    pthread_rwlock_unlock(v47);
    v8 = -1;
    goto LABEL_85;
  }
LABEL_43:
  v48 = 0;
  v55 = 0;
  v32 = (unint64_t *)(v15 + 21976);
  v33 = -1;
  v8 = -1;
  v34 = -1;
  v35 = PacketRoutingInfoList;
  do
  {
    if (!*((_DWORD *)v35 + 2))
      goto LABEL_75;
    if (v53)
    {
      v36 = *(_DWORD *)(a5 + 164);
      v37 = (v36 & 0x10) == 0 || *((_BYTE *)v35 + 30) == 0;
      if ((v36 & 0x20) == 0 || *((_BYTE *)v35 + 30) == 0)
        v39 = 0;
      else
        v39 = 500;
      if (!v37)
        v39 = 1000;
      *(_DWORD *)(a5 + 288) = v39;
    }
    if (*(_BYTE *)(a5 + 255))
      v40 = 1;
    else
      v40 = *(_BYTE *)v35 != 0;
    *(_BYTE *)(a5 + 255) = v40;
    v41 = _VTP_SendWithSourceDestinationInfo(v15, (unsigned int *)v35 + 2, a2, a3, a4, (unsigned int *)a5, *(unsigned __int8 *)(v15 + 21624));
    v34 = v41;
    if (!v53)
      goto LABEL_70;
    if (v41 > 0)
      goto LABEL_64;
    if (v41)
      goto LABEL_70;
    if (*(_BYTE *)(a5 + 218))
    {
LABEL_64:
      VCConnectionManager_UpdateTransmittedPacketsAndBytes((uint64_t)v53, (uint64_t)(v35 + 1), v41, v52, v51 != 0, v50, v49 != 0);
      if (((_DWORD)a4 == 800 || (_DWORD)a4 == 700) && !v48)
      {
        do
          v42 = __ldxr(v32);
        while (__stxr(v42 + 1, v32));
        v48 = 1;
      }
LABEL_70:
      if (*(_BYTE *)(a5 + 218))
        objc_msgSend(v53, "updateSessionStats:", *(unsigned __int16 *)(a5 + 220));
    }
    v43 = v55;
    v33 = v55 != 0;
    if (!v55)
      v43 = 1;
    v55 = v43;
LABEL_75:
    v35 = (_QWORD *)v35[16];
    _VTP_HealthPrint(v15, a3, v33, a4, 1);
    v44 = *__error();
    if (v8 < 0 || v44 != 43)
      v8 = v34;
  }
  while (v35);
  pthread_rwlock_unlock(v47);
  do
  {
    v46 = (_QWORD *)PacketRoutingInfoList[16];
    CFAllocatorDeallocate(*(CFAllocatorRef *)(v15 + 22040), PacketRoutingInfoList);
    PacketRoutingInfoList = v46;
  }
  while (v46);
LABEL_85:
  CheckOutHandleDebug();
  return v8;
}

const void *VTP_getConnectionManagerForCallID(uint64_t a1, int a2)
{
  CFNumberRef v3;
  const void *Value;
  int valuePtr;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  valuePtr = a2;
  v3 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &valuePtr);
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 21840), v3);
  CFRelease(v3);
  return Value;
}

char *_VTP_CreatePacketRoutingInfoListWithVFD(int a1)
{
  uint64_t v2;
  uint64_t v3;
  pthread_rwlock_t *v4;
  uint64_t v5;
  char *v6;
  char *v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;

  v2 = CheckInHandleDebug();
  if (v2)
  {
    v3 = v2;
    v4 = (pthread_rwlock_t *)(v2 + 5376);
    pthread_rwlock_rdlock((pthread_rwlock_t *)(v2 + 5376));
    v5 = *(_QWORD *)(v3 + 5576);
    if (v5)
    {
      while (*(_DWORD *)v5 != a1)
      {
        v5 = *(_QWORD *)(v5 + 352);
        if (!v5)
          goto LABEL_5;
      }
      v7 = (char *)CFAllocatorAllocate(*(CFAllocatorRef *)(v3 + 22040), 136, 0);
      if (v7)
      {
        v6 = v7;
        v8 = *(_OWORD *)(v5 + 392);
        v9 = *(_OWORD *)(v5 + 408);
        v10 = *(_OWORD *)(v5 + 424);
        *(_OWORD *)(v7 + 56) = *(_OWORD *)(v5 + 440);
        *(_OWORD *)(v7 + 40) = v10;
        *(_OWORD *)(v7 + 24) = v9;
        *(_OWORD *)(v7 + 8) = v8;
        v11 = *(_OWORD *)(v5 + 456);
        v12 = *(_OWORD *)(v5 + 472);
        v13 = *(_QWORD *)(v5 + 504);
        *(_OWORD *)(v7 + 104) = *(_OWORD *)(v5 + 488);
        *(_OWORD *)(v7 + 88) = v12;
        *(_OWORD *)(v7 + 72) = v11;
        *((_QWORD *)v7 + 15) = v13;
        *((_QWORD *)v7 + 16) = 0;
      }
      else
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VTP_CreatePacketRoutingInfoListWithVFD_cold_3();
        }
        v6 = 0;
      }
    }
    else
    {
LABEL_5:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VTP_CreatePacketRoutingInfoListWithVFD_cold_2();
      }
      v6 = 0;
      *__error() = 6;
    }
    pthread_rwlock_unlock(v4);
    CheckOutHandleDebug();
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VTP_CreatePacketRoutingInfoListWithVFD_cold_1();
    }
    v6 = 0;
    *__error() = 13;
  }
  return v6;
}

uint64_t _VTP_SendWithSourceDestinationInfo(uint64_t a1, unsigned int *a2, _OWORD *buffer, size_t size, uint64_t a5, unsigned int *a6, int a7)
{
  size_t v8;
  uint64_t v10;
  NSObject *v11;
  CFStringRef v12;
  int *v13;
  int v14;
  _OWORD *v17;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  pthread_rwlock_t *v22;
  int *v23;
  int v24;
  uint64_t v27;
  NSObject *v28;
  NSObject *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  NSObject *v33;
  NSObject *v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  int v38;
  unsigned int v39;
  char v40;
  uint64_t v41;
  size_t v42;
  void *v43;
  int v44;
  char v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  uint64_t v49;
  __int128 v50;
  unsigned int v51;
  unsigned int v52;
  _BOOL4 v53;
  int *v54;
  unsigned int v55;
  unsigned int v56;
  int v57;
  char v58;
  char *v59;
  uint64_t v60;
  int v61;
  uint64_t v62;
  socklen_t v63;
  __int16 **v64;
  unsigned int v65;
  uint64_t v66;
  __int128 *v67;
  signed int v68;
  char *v69;
  __int128 *v70;
  unsigned int v71;
  int v72;
  int v73;
  char v74;
  int v75;
  int v76;
  uint64_t v77;
  unint64_t v78;
  unsigned int v79;
  unsigned int v80;
  char v81;
  unsigned int v82;
  _BOOL4 v83;
  void *v84;
  unint64_t v85;
  int v86;
  __int16 v87;
  unsigned int v88;
  unsigned int v89;
  msghdr v90;
  socklen_t v91;
  _DWORD v92[5];
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  _OWORD __b[128];
  _QWORD __dst[44];

  __dst[41] = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v8 = size;
    if (size >= 0x5C1)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v10 = VRTraceErrorLogLevelToCSTR();
        v11 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v44 = *a2;
          LODWORD(__b[0]) = 136316418;
          *(_QWORD *)((char *)__b + 4) = v10;
          WORD6(__b[0]) = 2080;
          *(_QWORD *)((char *)__b + 14) = "_VTP_SendWithSourceDestinationInfo";
          WORD3(__b[1]) = 1024;
          DWORD2(__b[1]) = 4827;
          WORD6(__b[1]) = 2048;
          *(_QWORD *)((char *)&__b[1] + 14) = v8;
          WORD3(__b[2]) = 1024;
          DWORD2(__b[2]) = a5;
          WORD6(__b[2]) = 1024;
          *(_DWORD *)((char *)&__b[2] + 14) = v44;
          _os_log_error_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_ERROR, " [%s] %s:%d Packet data too big length=%zu trafficFlags=%d mode=%d", (uint8_t *)__b, 0x32u);
        }
      }
      *__error() = 40;
      v12 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("Packet data is too big. length=%zu, trafficFlags=%d, mode=%d, expectedMaxLength=%d"), v8, a5, *a2, 1472);
      VCTerminateProcess((uint64_t)v12, CFSTR("_VTP_SendWithSourceDestinationInfo"), 0);
      if (v12)
        CFRelease(v12);
      return -1;
    }
    v17 = buffer;
    switch(*a2)
    {
      case 1u:
        v19 = a6[39];
        v20 = CheckInHandleDebug();
        if (v20)
        {
          v21 = v20;
          v22 = (pthread_rwlock_t *)(v20 + 5376);
          pthread_rwlock_rdlock((pthread_rwlock_t *)(v20 + 5376));
          v23 = *(int **)(v21 + 5576);
          if (!v23)
          {
LABEL_30:
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                _VTP_SendWithSourceDestinationInfo_cold_4();
            }
            *__error() = 9;
            v8 = -1;
            goto LABEL_34;
          }
          v24 = a2[2] & 1;
          while (1)
          {
            if ((v23[15] & 1) == v24)
            {
              if (v24)
              {
                if (*((_QWORD *)v23 + 10) != *(_QWORD *)(a2 + 7) || *((_QWORD *)v23 + 11) != *(_QWORD *)(a2 + 9))
                  goto LABEL_29;
              }
              else if (v23[20] != a2[7])
              {
                goto LABEL_29;
              }
              if (*((unsigned __int16 *)v23 + 48) == *((unsigned __int16 *)a2 + 22))
              {
                memset(__dst, 0, 128);
                if ((a2[12] & 1) != 0)
                {
                  v86 = 28;
                  IPPORTToSA6();
                }
                else
                {
                  v86 = 16;
                  IPPORTToSA();
                }
                v91 = v86;
                memset(v92, 170, sizeof(v92));
                *(_QWORD *)&v50 = 0xAAAAAAAAAAAAAAAALL;
                *((_QWORD *)&v50 + 1) = 0xAAAAAAAAAAAAAAAALL;
                v96 = v50;
                v97 = v50;
                v94 = v50;
                v95 = v50;
                v93 = v50;
                v51 = a6[1];
                v89 = 0;
                v52 = a6[39];
                v53 = v52 != 0;
                if (v52)
                {
                  if ((int)v8 >= 4
                    && (*(_WORD *)v17 & 0xC0) == 0x40
                    && (_DWORD)v8 - 4 == bswap32(*((unsigned __int16 *)v17 + 1)) >> 16)
                  {
                    v23[58] = *(_DWORD *)v17;
                    v54 = v23 + 58;
                    v55 = 4;
                    goto LABEL_113;
                  }
LABEL_95:
                  v53 = 0;
                  v55 = 0;
                  v56 = 0;
                }
                else
                {
                  if (v19)
                    goto LABEL_95;
                  if (!*((_BYTE *)a2 + 88))
                    goto LABEL_95;
                  v68 = *((__int16 *)a2 + 45);
                  if (v68 < 0x4000)
                    goto LABEL_95;
                  v55 = 0;
                  *((_WORD *)v23 + 116) = bswap32(v68) >> 16;
                  v54 = v23 + 58;
                  *((_WORD *)v23 + 117) = bswap32(v8) >> 16;
LABEL_113:
                  *(_QWORD *)&v93 = v54;
                  *((_QWORD *)&v93 + 1) = 4;
                  v56 = 1;
                }
                v57 = *a6;
                if ((a6[37] & 2) != 0 || (v57 | 4) == 6 && *((_BYTE *)a6 + 12))
                  v58 = 32;
                else
                  v58 = 0;
                *(_QWORD *)&v90.msg_controllen = 0xAAAAAAAAAAAAAAAALL;
                *(_OWORD *)&v90.msg_namelen = v50;
                *(_OWORD *)&v90.msg_iovlen = v50;
                v87 = -21846;
                v88 = -1431655766;
                __b[0] = v50;
                __b[1] = v50;
                __b[2] = v50;
                __b[3] = v50;
                __b[4] = v50;
                __b[5] = v50;
                __b[6] = v50;
                __b[7] = v50;
                if (v57 != 6 && v57 != 2)
                {
                  if (!v57)
                  {
                    v59 = (char *)v17 + v55;
                    v60 = v56;
                    *((_QWORD *)&v93 + 2 * v56) = v59;
                    v61 = v56 + 1;
                    v62 = v8 - v55;
                    v63 = v86;
                    goto LABEL_127;
                  }
                  v58 |= 8u;
                }
                LOBYTE(v87) = v58;
                HIBYTE(v87) = v57;
                v88 = bswap32(v51);
                v64 = (__int16 **)(&v93 + v56);
                v65 = v56 + 1;
                *v64 = &v87;
                v64[1] = (__int16 *)6;
                if ((v58 & 8) != 0)
                {
                  v80 = v56 + 1;
                  v81 = v58;
                  v79 = v56;
                  v83 = v53;
                  v66 = v55;
                  v82 = v55;
                  if ((PrepareOFTMAC(*(const __CFString **)(v21 + 8 * *v23 + 6040), (char *)v17 + v55, v8 - v55, v92) & 0x80000000) != 0)
                  {
                    v55 = v82;
                    v58 = v81 ^ 8;
                    LOBYTE(v87) = v81 ^ 8;
                    v53 = v83;
                    v65 = v80;
                  }
                  else
                  {
                    v58 = v81;
                    v67 = &v93 + v80;
                    v65 = v79 | 2;
                    *(_QWORD *)v67 = v92;
                    *((_QWORD *)v67 + 1) = 4;
                    v53 = v83;
                    v55 = v82;
                  }
                }
                else
                {
                  v66 = v55;
                }
                v69 = (char *)v17 + v66;
                v70 = &v93 + v65;
                v60 = v65 + 1;
                *(_QWORD *)v70 = v69;
                *((_QWORD *)v70 + 1) = v8 - v66;
                if (v19)
                {
                  if (v53)
                    goto LABEL_117;
LABEL_125:
                  v71 = v65;
                  v73 = 0;
                }
                else
                {
                  if (*((_BYTE *)a2 + 88))
                    v74 = 1;
                  else
                    v74 = v53;
                  if ((v74 & 1) == 0)
                    goto LABEL_125;
LABEL_117:
                  v71 = v65;
                  if ((v58 & 8) != 0)
                    v72 = 14;
                  else
                    v72 = 10;
                  *((_WORD *)v23 + 117) = bswap32(v72 + v8 - v55) >> 16;
                  v73 = 1;
                }
                v63 = v86;
                PrepareOFTCRC32((uint64_t)&v93, v65 + 1, v73, &v89);
                *((_QWORD *)&v93 + 2 * v60) = &v89;
                v61 = v71 + 2;
                v62 = 4;
LABEL_127:
                *((_QWORD *)&v93 + 2 * v60 + 1) = v62;
                __memcpy_chk();
                if (*((_BYTE *)v23 + 368))
                {
                  VTP_AddNAT64PrefixToIPv4Destination((uint64_t)v23, (uint64_t)__b, &v91);
                  v63 = v91;
                }
                v90.msg_name = __b;
                v90.msg_namelen = v63;
                v90.msg_iov = (iovec *)&v93;
                v90.msg_iovlen = v61;
                v90.msg_flags = 0;
                if (*(_BYTE *)(v21 + 21625))
                {
                  v90.msg_control = 0;
                  v90.msg_controllen = 0;
                }
                else
                {
                  v90.msg_control = &v92[1];
                  v90.msg_controllen = 16;
                  *(_QWORD *)&v92[1] = 0xFFFF00000010;
                  v92[3] = 4230;
                  if (*(_DWORD *)(v21 + 21628))
                    v92[4] = *(_DWORD *)(v21 + 21628);
                  else
                    v92[4] = a5;
                }
                v75 = sendmsg(v23[5], &v90, 0);
                kdebug_trace();
                if (v75 >= 1)
                {
                  if ((v23[15] & 1) != 0)
                    v76 = 48;
                  else
                    v76 = 28;
                  v77 = v76 + v75;
                  do
                    v78 = __ldxr((unint64_t *)v21);
                  while (__stxr(v78 + v77, (unint64_t *)v21));
                }
                v8 = v75;
LABEL_34:
                pthread_rwlock_unlock(v22);
                CheckOutHandleDebug();
                return v8;
              }
            }
LABEL_29:
            v23 = (int *)*((_QWORD *)v23 + 44);
            if (!v23)
              goto LABEL_30;
          }
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VTP_SendWithSourceDestinationInfo_cold_3();
        }
        v13 = __error();
        v14 = 13;
        break;
      case 2u:
        return VTP_SendOnePacketWithSocket(a2[2], a2[3], (_BYTE *)a2 + 16, 0, (uint64_t)buffer, size, a5, (uint64_t)a6, a2[14]);
      case 3u:
        return VTP_SendOnePacketWithSocket(a2[2], a2[3], (_BYTE *)a2 + 16, 1, (uint64_t)buffer, size, a5, (uint64_t)a6, a2[14]);
      case 4u:
        memset(__b, 170, sizeof(__b));
        v84 = (void *)*((_QWORD *)a2 + 14);
        v85 = *(_QWORD *)(a2 + 3);
        v27 = *((unsigned __int16 *)a2 + 10);
        if (*((_BYTE *)a6 + 168) && *((_BYTE *)a6 + 233) && (a2[24] & 1) == 0)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              _VTP_SendWithSourceDestinationInfo_cold_6();
          }
          v13 = __error();
          v14 = 43;
          break;
        }
        v37 = HIDWORD(v85);
        v38 = *a6;
        if (!*a6)
        {
          v43 = v84;
          goto LABEL_68;
        }
        v39 = bswap32(a6[1]);
        LODWORD(v90.msg_name) = 0;
        if ((a6[37] & 2) != 0)
          goto LABEL_59;
        if ((v38 | 4) == 6)
        {
          v40 = *((_BYTE *)a6 + 12);
          if (v40)
LABEL_59:
            v40 = 32;
        }
        else
        {
          v40 = 0;
        }
        __dst[5] = 0xAAAAAAAAAAAAAAAALL;
        __dst[4] = 0xAAAAAAAAAAAAAAAALL;
        LOBYTE(v93) = v40;
        BYTE1(v93) = v38;
        *(_DWORD *)((char *)&v93 + 2) = v39;
        __dst[0] = &v93;
        __dst[1] = 6;
        __dst[2] = v17;
        __dst[3] = v8;
        PrepareOFTCRC32((uint64_t)__dst, 2, 0, (unsigned int *)&v90);
        v41 = 0;
        v8 = 0;
        __dst[4] = &v90;
        __dst[5] = 4;
        do
        {
          v42 = __dst[v41 + 1];
          memcpy((char *)__b + v8, (const void *)__dst[v41], v42);
          v8 += v42;
          v41 += 2;
        }
        while (v41 != 6);
        v17 = __b;
        v43 = v84;
        LOBYTE(v37) = BYTE4(v85);
LABEL_68:
        if (a7)
        {
          if ((_DWORD)a5 == 700)
          {
            LOBYTE(v37) = -120;
          }
          else if ((_DWORD)a5 == 800)
          {
            LOBYTE(v37) = -72;
          }
        }
        v45 = *((_BYTE *)a6 + 310);
        memset(__dst, 0, 120);
        v46 = *((_OWORD *)a6 + 13);
        v47 = *((_OWORD *)a6 + 15);
        v96 = *((_OWORD *)a6 + 14);
        v97 = v47;
        v48 = *((_OWORD *)a6 + 11);
        v94 = *((_OWORD *)a6 + 12);
        v95 = v46;
        v93 = v48;
        _VTP_UpdateIDSDatagramOptionWithChannelDataFormat((uint64_t)&v93, (uint64_t)__dst, 1);
        v49 = a6[72];
        if ((_DWORD)v49)
        {
          LODWORD(__dst[0]) |= 0x200u;
          __dst[9] = v49;
        }
        if (v43)
        {
          _VTP_ReportIDSOnTheWireBytesLocked(a1, a6[2], v8, (uint64_t)__dst, 1);
          objc_msgSend(v43, "writeDatagram:datagramSize:datagramInfo:options:completionHandler:", v17, v8, v85 & 0xFFFFFF0000000000 | ((unint64_t)(v45 | v37) << 32) | ((_DWORD)a5 << 16) | (unint64_t)(unsigned __int16)v85, v27, __dst, 0);
          kdebug_trace();
        }
        else
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              _VTP_SendWithSourceDestinationInfo_cold_5();
          }
          return 0;
        }
        return v8;
      case 5u:
        v28 = *((_QWORD *)a2 + 1);
        if (!v28)
          return -1;
        v29 = dispatch_data_create(buffer, size, 0, 0);
        v30 = *((_QWORD *)a6 + 32);
        v31 = *((_QWORD *)a6 + 33);
        v32 = *((_QWORD *)a6 + 34);
        v33 = nw_content_context_create("AVConferenceNWContext");
        v34 = v33;
        v35 = a6[72];
        if ((_DWORD)v35)
          nw_content_context_set_expiration_milliseconds(v33, v35);
        nw_content_context_set_packet_id();
        memcpy(__dst, a6, 0x140uLL);
        switch((_DWORD)a5)
        {
          case 0xC8:
            v36 = 22064;
            break;
          case 0x320:
            v36 = 22048;
            break;
          case 0x2BC:
            v36 = 22056;
            break;
          default:
            goto LABEL_75;
        }
        nw_content_context_set_metadata_for_protocol(v34, *(nw_protocol_metadata_t *)(a1 + v36));
LABEL_75:
        *(_QWORD *)&__b[0] = MEMORY[0x1E0C809B0];
        *((_QWORD *)&__b[0] + 1) = 3221225472;
        *(_QWORD *)&__b[1] = ___VTP_SendOnePacketWithNWConnection_block_invoke;
        *((_QWORD *)&__b[1] + 1) = &__block_descriptor_376_e31_v16__0__NSObject_OS_nw_error__8ls88l8;
        *(_QWORD *)&__b[2] = v30;
        *((_QWORD *)&__b[2] + 1) = v31;
        *(_QWORD *)&__b[3] = v32;
        memcpy((char *)&__b[3] + 8, __dst, 0x140uLL);
        nw_connection_send(v28, v29, v34, 1, __b);
        kdebug_trace();
        nw_release(v34);
        dispatch_release(v29);
        return v8;
      default:
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VTP_SendWithSourceDestinationInfo_cold_2();
        }
        return -1;
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VTP_SendWithSourceDestinationInfo_cold_1();
    }
    v13 = __error();
    v14 = 22;
  }
  *v13 = v14;
  return -1;
}

void _VTP_HealthPrint(uint64_t a1, int a2, unsigned int a3, int a4, int a5)
{
  _DWORD *v10;
  uint64_t v11;
  double v12;
  double v13;
  _DWORD *v14;
  int v15;
  _DWORD *v16;
  int v17;
  double v18;
  uint64_t v20;
  NSObject *v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  double v32;
  int v33;
  double v34;
  uint64_t v36;
  NSObject *v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  uint64_t v46;
  __int16 v47;
  const char *v48;
  __int16 v49;
  int v50;
  __int16 v51;
  int v52;
  __int16 v53;
  int v54;
  __int16 v55;
  int v56;
  __int16 v57;
  int v58;
  __int16 v59;
  double v60;
  __int16 v61;
  double v62;
  __int16 v63;
  double v64;
  __int16 v65;
  int v66;
  __int16 v67;
  int v68;
  __int16 v69;
  int v70;
  __int16 v71;
  int v72;
  __int16 v73;
  int v74;
  __int16 v75;
  int v76;
  __int16 v77;
  double v78;
  __int16 v79;
  int v80;
  uint64_t v81;

  v81 = *MEMORY[0x1E0C80C00];
  if (a3 >= 2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VTP_HealthPrint_cold_1();
    }
    return;
  }
  v10 = (_DWORD *)(a1 + 21860);
  v11 = a1 + 21872;
  v12 = micro();
  v13 = v12;
  v14 = (_DWORD *)(v11 + 16 * a3);
  if (a5)
  {
    v15 = v14[1] + a2;
    ++*v14;
    v14[1] = v15;
    if (a4)
    {
      if (a4 == 700)
      {
        v16 = v10 + 18;
      }
      else
      {
        if (a4 != 800)
          goto LABEL_21;
        v16 = v10 + 17;
      }
    }
    else
    {
      v16 = v10 + 16;
    }
    ++*v16;
LABEL_21:
    v34 = v12 - *(double *)(a1 + 21936);
    if (v34 > 0.0 && v34 > 5.0)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
      {
        v36 = VRTraceErrorLogLevelToCSTR();
        v37 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v38 = v10[3];
          v39 = v10[4];
          v40 = v10[7];
          v41 = v10[8];
          v45 = 136318210;
          v43 = v10[17];
          v42 = v10[18];
          v44 = v10[16];
          v46 = v36;
          v47 = 2080;
          v48 = "_VTP_HealthPrint";
          v49 = 1024;
          v50 = 2788;
          v51 = 1024;
          v52 = v38;
          v53 = 1024;
          v54 = v40;
          v55 = 1024;
          v56 = v39;
          v57 = 1024;
          v58 = v41;
          v59 = 2048;
          v60 = v34;
          v61 = 2048;
          v62 = (double)(8 * v39) / v34 / 1000.0;
          v63 = 2048;
          v64 = (double)(8 * v41) / v34 / 1000.0;
          v65 = 1024;
          v66 = v43;
          v67 = 1024;
          v68 = v42;
          v69 = 1024;
          v70 = v44;
          _os_log_impl(&dword_1D8A54000, v37, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d @=@ Health: VTransport Health Monitor for VTP Send packet count:[%d %d], byte count:[%d %d], interval:%.3fs, rate:[%.3f %.3fkbps], VO=%u, VI=%u, BE=%u", (uint8_t *)&v45, 0x64u);
        }
      }
      *(double *)(a1 + 21936) = v13;
      *(_QWORD *)(a1 + 21872) = 0;
      *(_QWORD *)(a1 + 21888) = 0;
      v10[18] = 0;
      *((_QWORD *)v10 + 8) = 0;
    }
    return;
  }
  v17 = v14[3] + a2;
  ++v14[2];
  v14[3] = v17;
  v18 = v12 - *(double *)(a1 + 21944);
  if (v18 > 0.0 && v18 > 5.0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      v20 = VRTraceErrorLogLevelToCSTR();
      v21 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v22 = v10[5];
        v23 = v10[6];
        v24 = v10[9];
        v25 = v10[10];
        v26 = v10[11];
        v27 = v10[12];
        v28 = v10[13];
        v29 = v10[14];
        v30 = v10[15];
        v31 = *v10;
        v45 = 136319490;
        v32 = *(double *)(a1 + 21864);
        v33 = v10[37];
        v46 = v20;
        v47 = 2080;
        v48 = "_VTP_HealthPrint";
        v49 = 1024;
        v50 = 2819;
        v51 = 1024;
        v52 = v22;
        v53 = 1024;
        v54 = v24;
        v55 = 1024;
        v56 = v23;
        v57 = 1024;
        v58 = v25;
        v59 = 2048;
        v60 = v18;
        v61 = 2048;
        v62 = (double)(8 * v23) / v18 / 1000.0;
        v63 = 2048;
        v64 = (double)(8 * v25) / v18 / 1000.0;
        v65 = 1024;
        v66 = v26;
        v67 = 1024;
        v68 = v27;
        v69 = 1024;
        v70 = v28;
        v71 = 1024;
        v72 = v29;
        v73 = 1024;
        v74 = v30;
        v75 = 1024;
        v76 = v31;
        v77 = 2048;
        v78 = v32 * 1000.0;
        v79 = 1024;
        v80 = v33;
        _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d @=@ Health: VTransport Health Monitor for VTP Recv packet count:[%d %d], byte count:[%d %d], interval:%.3fs, rate:[%.3f %.3f]kbps, demuxPackets:[%u, %u, %u, %u, %u], maxQueueLength:%d, maxQueueDelay:%.2fms statsCount:%d", (uint8_t *)&v45, 0x86u);
      }
    }
    *(double *)(a1 + 21944) = v13;
    *(_QWORD *)(a1 + 21880) = 0;
    *(_QWORD *)(a1 + 21896) = 0;
    *(_DWORD *)(a1 + 21920) = 0;
    *(_QWORD *)(a1 + 21912) = 0;
    *(_QWORD *)(a1 + 21904) = 0;
    *(_QWORD *)(a1 + 21864) = 0;
    *v10 = 0;
  }
}

uint64_t VTP_SendCompoundPacket(uint64_t a1)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  pthread_rwlock_t *v13;
  int v14;
  void *v15;
  _BYTE *PacketRoutingInfoList;
  _BYTE *v17;
  uint64_t v18;
  __int128 v19;
  const void *v20;
  _BOOL4 v22;
  unsigned int v23;
  uint64_t v24;
  BOOL v25;
  void *v26;
  uint64_t v27;
  NSObject *v28;
  uint8_t *v29;
  NSObject *v30;
  const char *v31;
  uint32_t v32;
  unint64_t v33;
  unint64_t v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  _WORD *v39;
  unint64_t v40;
  uint8_t *v41;
  uint64_t v42;
  uint64_t v43;
  __int128 v44;
  __int128 v45;
  uint64_t v46;
  uint64_t v47;
  unsigned __int16 *v48;
  uint64_t v49;
  uint64_t v50;
  NSObject *v51;
  NSObject *v52;
  int v53;
  int v54;
  uint64_t v55;
  NSObject *v56;
  uint64_t v57;
  NSObject *v58;
  int v59;
  uint64_t v60;
  NSObject *v61;
  _QWORD *v62;
  _QWORD *v63;
  int *v64;
  int v65;
  uint64_t v67;
  NSObject *v68;
  NSObject *v69;
  __int128 v70;
  _QWORD *ptr;
  pthread_rwlock_t *v72;
  unsigned __int16 *v73;
  void *v74;
  uint64_t v75;
  int v76;
  uint64_t v77;
  unsigned __int8 *v78;
  const void *v79;
  uint64_t v80;
  void *v81;
  _BYTE *v82;
  int v83;
  int v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  __int16 v89;
  uint64_t v90;
  int v91;
  unsigned __int8 v92[5];
  _BYTE v93[32];
  __int128 v94;
  __int128 v95;
  __int128 v96;
  uint8_t buf[4];
  uint64_t v98;
  __int16 v99;
  const char *v100;
  __int16 v101;
  int v102;
  __int16 v103;
  int v104;
  __int16 v105;
  int v106;
  __int16 v107;
  int v108;
  _QWORD v109[30];
  _BYTE v110[312];
  uint64_t v111;

  MEMORY[0x1E0C80A78](a1);
  v111 = *MEMORY[0x1E0C80C00];
  if (!v4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_SendCompoundPacket_cold_1();
    }
    goto LABEL_86;
  }
  v6 = v3;
  if (!v3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_SendCompoundPacket_cold_2();
    }
    goto LABEL_86;
  }
  v7 = v2;
  if (!v2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_SendCompoundPacket_cold_3();
    }
    goto LABEL_86;
  }
  v8 = v5;
  if ((int)v5 <= 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_SendCompoundPacket_cold_4();
    }
LABEL_86:
    v64 = __error();
    v65 = 22;
LABEL_87:
    *v64 = v65;
    return -1;
  }
  v9 = v4;
  v10 = v1;
  v11 = CheckInHandleDebug();
  if (!v11)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_SendCompoundPacket_cold_5();
    }
    v64 = __error();
    v65 = 13;
    goto LABEL_87;
  }
  v12 = v11;
  v75 = v7;
  v13 = (pthread_rwlock_t *)(v11 + 21640);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(v11 + 21640));
  v14 = *(_DWORD *)(v9 + 8);
  v72 = v13;
  if (!v14)
  {
    *__error() = 22;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_SendCompoundPacket_cold_6();
    }
    goto LABEL_102;
  }
  v15 = (void *)VTP_getConnectionManagerForCallID(v12, v14);
  v92[0] = *(_BYTE *)(v9 + 169);
  v92[1] = 0;
  v92[2] = *(_BYTE *)(v9 + 309);
  v92[3] = *(_BYTE *)(v9 + 233);
  v92[4] = *(_BYTE *)(v9 + 312);
  PacketRoutingInfoList = VCConnectionManager_CreatePacketRoutingInfoList((uint64_t)v15, v92, *(const __CFAllocator **)(v12 + 22040));
  if (!PacketRoutingInfoList)
  {
    *__error() = 22;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v67 = VRTraceErrorLogLevelToCSTR();
      v68 = *MEMORY[0x1E0CF2758];
      v69 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          v98 = v67;
          v99 = 2080;
          v100 = "VTP_SendCompoundPacket";
          v101 = 1024;
          v102 = 2994;
          _os_log_impl(&dword_1D8A54000, v68, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d infoList is NULL! Dropped packet!", buf, 0x1Cu);
        }
      }
      else if (os_log_type_enabled(v69, OS_LOG_TYPE_DEBUG))
      {
        VTP_SendCompoundPacket_cold_7();
      }
    }
LABEL_102:
    pthread_rwlock_unlock(v72);
    v24 = -1;
    goto LABEL_82;
  }
  v17 = PacketRoutingInfoList;
  v18 = VCConnectionManager_CopyConnectionForQuality((uint64_t)v15, 1);
  v20 = (const void *)v18;
  v78 = (unsigned __int8 *)(v12 + 21624);
  v77 = (v10 << 16);
  v85 = v8;
  v22 = v10 == 800 || v10 == 700;
  v83 = 0;
  v84 = v22;
  v87 = 320 * v8;
  v73 = (unsigned __int16 *)(v9 + 220);
  v23 = -1;
  v24 = -1;
  *(_QWORD *)&v19 = 136315650;
  v70 = v19;
  ptr = v17;
  v79 = (const void *)v18;
  v80 = v8;
  v88 = v6;
  v76 = v10;
  v90 = v12;
  v74 = v15;
  do
  {
    v86 = (uint64_t)(v17 + 8);
    if (*((_DWORD *)v17 + 2) != 4)
      goto LABEL_60;
    if (*(_BYTE *)(v9 + 255))
      v25 = 1;
    else
      v25 = *v17 != 0;
    *(_BYTE *)(v9 + 255) = v25;
    v26 = (void *)*((_QWORD *)v17 + 15);
    v91 = VCConnectionIDS_LinkID((uint64_t)v20);
    if (v8 >= 0x1F)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v27 = VRTraceErrorLogLevelToCSTR();
        v28 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136316162;
          v98 = v27;
          v99 = 2080;
          v100 = "_VTP_SendCompoundPacketWithDatagramChannel";
          v101 = 1024;
          v102 = 5117;
          v103 = 1024;
          v104 = v8;
          v105 = 1024;
          v106 = 30;
          v29 = buf;
          v30 = v28;
          v31 = " [%s] %s:%d Datagram count %d is larger than VTP max compound packet datagram count %d";
          v32 = 40;
LABEL_66:
          _os_log_error_impl(&dword_1D8A54000, v30, OS_LOG_TYPE_ERROR, v31, v29, v32);
        }
      }
      goto LABEL_56;
    }
    v33 = *(_QWORD *)(v17 + 20);
    v89 = *((_WORD *)v17 + 14);
    v34 = HIDWORD(v33);
    v35 = *v78;
    memset(v110, 0, 300);
    memset(v109, 0, sizeof(v109));
    bzero(buf, 0xE10uLL);
    v81 = v26;
    v82 = v17;
    if (v35)
    {
      if (v10 == 700)
      {
        LOBYTE(v34) = -120;
      }
      else if (v10 == 800)
      {
        LOBYTE(v34) = -72;
      }
    }
    v36 = 0;
    v37 = 0;
    LODWORD(v24) = 0;
    v38 = (char)v33;
    v39 = &v110[8];
    v40 = v33 & 0xFFFFFF000000FFFFLL | v77 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)v34 << 32);
    v41 = buf;
    do
    {
      if (*(_DWORD *)(v9 + v36))
      {
        v20 = v79;
        LODWORD(v8) = v80;
        v10 = v76;
        v12 = v90;
        v17 = v82;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v55 = VRTraceErrorLogLevelToCSTR();
          v56 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)v93 = v70;
            *(_QWORD *)&v93[4] = v55;
            *(_WORD *)&v93[12] = 2080;
            *(_QWORD *)&v93[14] = "_VTP_SendCompoundPacketWithDatagramChannel";
            *(_WORD *)&v93[22] = 1024;
            *(_DWORD *)&v93[24] = 5137;
            v29 = v93;
            v30 = v56;
            v31 = " [%s] %s:%d Cannot not handle open facetime with IDS compound packet";
LABEL_65:
            v32 = 28;
            goto LABEL_66;
          }
        }
LABEL_56:
        v24 = -1;
        v59 = v83;
        goto LABEL_57;
      }
      v42 = v9;
      v43 = v9 + v36;
      if (*(_BYTE *)(v43 + 313))
      {
        v10 = v76;
        v20 = v79;
        v17 = v82;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v57 = VRTraceErrorLogLevelToCSTR();
          v58 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)v93 = v70;
            *(_QWORD *)&v93[4] = v57;
            *(_WORD *)&v93[12] = 2080;
            *(_QWORD *)&v93[14] = "_VTP_SendCompoundPacketWithDatagramChannel";
            *(_WORD *)&v93[22] = 1024;
            *(_DWORD *)&v93[24] = 5141;
            _os_log_error_impl(&dword_1D8A54000, v58, OS_LOG_TYPE_ERROR, " [%s] %s:%d Un-encrypted/un-authenticated packet detected. Dropping...", v93, 0x1Cu);
          }
        }
        *__error() = 81;
        LODWORD(v8) = v80;
        v9 = v42;
        v12 = v90;
        goto LABEL_56;
      }
      v44 = *(_OWORD *)(v43 + 224);
      v94 = *(_OWORD *)(v43 + 208);
      v95 = v44;
      v96 = *(_OWORD *)(v43 + 240);
      v45 = *(_OWORD *)(v43 + 192);
      *(_OWORD *)v93 = *(_OWORD *)(v43 + 176);
      *(_OWORD *)&v93[16] = v45;
      _VTP_UpdateIDSDatagramOptionWithChannelDataFormat((uint64_t)v93, (uint64_t)v41, v38 == v91);
      kdebug_trace();
      *((_QWORD *)v39 - 1) = v40;
      *v39 = v89;
      v39 += 5;
      v109[v37] = v41;
      v46 = *(unsigned int *)(v88 + 4 * v37);
      v24 = (v46 + v24);
      _VTP_ReportIDSOnTheWireBytesLocked(v90, *(_DWORD *)(v43 + 8), v46, (uint64_t)v41, 1);
      ++v37;
      v36 += 320;
      v41 += 120;
      v9 = v42;
    }
    while (v87 != v36);
    if (!v81)
    {
      v20 = v79;
      LODWORD(v8) = v80;
      v10 = v76;
      v12 = v90;
      v17 = v82;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v60 = VRTraceErrorLogLevelToCSTR();
        v61 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)v93 = v70;
          *(_QWORD *)&v93[4] = v60;
          *(_WORD *)&v93[12] = 2080;
          *(_QWORD *)&v93[14] = "_VTP_SendCompoundPacketWithDatagramChannel";
          *(_WORD *)&v93[22] = 1024;
          *(_DWORD *)&v93[24] = 5161;
          v29 = v93;
          v30 = v61;
          v31 = " [%s] %s:%d nil datagramChannel passed";
          goto LABEL_65;
        }
      }
      goto LABEL_56;
    }
    LODWORD(v8) = v80;
    objc_msgSend(v81, "writeDatagrams:datagramsSize:datagramsInfo:datagramsCount:options:completionHandler:", v75, v88, v110, v80, v109, 0);
    v20 = v79;
    if ((_DWORD)v24 || *(_BYTE *)(v42 + 218))
    {
      v47 = 0;
      v48 = v73;
      do
      {
        if ((_DWORD)v24)
          v49 = *(unsigned int *)(v88 + 4 * v47);
        else
          v49 = 0;
        VCConnectionManager_UpdateTransmittedPacketsAndBytes((uint64_t)v74, v86, v49, v84, *((_BYTE *)v48 - 15) != 0, *((unsigned __int8 *)v48 - 20), *((_BYTE *)v48 - 16) != 0);
        if (*((_BYTE *)v48 - 2))
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            v50 = VRTraceErrorLogLevelToCSTR();
            v51 = *MEMORY[0x1E0CF2758];
            v52 = *MEMORY[0x1E0CF2758];
            if (*MEMORY[0x1E0CF2748])
            {
              if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
              {
                v53 = *v48;
                *(_DWORD *)buf = 136316418;
                v98 = v50;
                v99 = 2080;
                v100 = "VTP_SendCompoundPacket";
                v101 = 1024;
                v102 = 3014;
                v103 = 1024;
                v104 = 3014;
                v105 = 1024;
                v106 = v47;
                v107 = 1024;
                v108 = v53;
                _os_log_impl(&dword_1D8A54000, v51, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VTP/VTransport.m:%d: index=%d, statsID = %d", buf, 0x2Eu);
              }
            }
            else if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG))
            {
              v54 = *v48;
              *(_DWORD *)buf = 136316418;
              v98 = v50;
              v99 = 2080;
              v100 = "VTP_SendCompoundPacket";
              v101 = 1024;
              v102 = 3014;
              v103 = 1024;
              v104 = 3014;
              v105 = 1024;
              v106 = v47;
              v107 = 1024;
              v108 = v54;
              _os_log_debug_impl(&dword_1D8A54000, v51, OS_LOG_TYPE_DEBUG, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VTP/VTransport.m:%d: index=%d, statsID = %d", buf, 0x2Eu);
            }
          }
          objc_msgSend(v74, "updateSessionStats:", *v48, v70);
        }
        v48 += 160;
        ++v47;
      }
      while (v85 != v47);
    }
    else
    {
      v24 = 0;
    }
    v10 = v76;
    v12 = v90;
    v59 = v83;
    v17 = v82;
LABEL_57:
    v23 = v59 != 0;
    if (!v59)
      v59 = 1;
    v83 = v59;
LABEL_60:
    v17 = (_BYTE *)*((_QWORD *)v17 + 16);
    _VTP_HealthPrint(v12, v24, v23, v10, 1);
  }
  while (v17);
  if (v20)
    CFRelease(v20);
  pthread_rwlock_unlock(v72);
  v62 = ptr;
  do
  {
    v63 = (_QWORD *)v62[16];
    CFAllocatorDeallocate(*(CFAllocatorRef *)(v12 + 22040), v62);
    v62 = v63;
  }
  while (v63);
LABEL_82:
  CheckOutHandleDebug();
  return v24;
}

void VTP_GetReportingStats(unint64_t *a1)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t *v8;
  unint64_t v9;

  if (a1)
  {
    v2 = CheckInHandleDebug();
    if (v2)
    {
      v3 = (unint64_t *)(v2 + 21952);
      v4 = (unint64_t *)(v2 + 21976);
      do
        v5 = __ldxr(v4);
      while (__stxr(v5, v4));
      a1[3] = v5;
      do
        v6 = __ldxr(v4);
      while (__stxr(v6, v4));
      a1[2] = v6;
      do
        v7 = __ldxr(v3);
      while (__stxr(v7, v3));
      *a1 = v7;
      v8 = (unint64_t *)(v2 + 21960);
      do
        v9 = __ldxr(v8);
      while (__stxr(v9, v8));
      a1[1] = v9;
      CheckOutHandleDebug();
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_GetReportingStats_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VTP_GetReportingStats_cold_1();
  }
}

uint64_t VTP_SendWithSourceDestinationIP(uint64_t a1, uint64_t a2, _OWORD *a3, size_t a4, uint64_t a5, unsigned int *a6)
{
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  pthread_rwlock_t *v19;
  const void *v20;
  _OWORD v22[7];
  unint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v12 = CheckInHandleDebug();
  if (v12)
  {
    v13 = v12;
    v23 = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)&v14 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v22[5] = v14;
    v22[6] = v14;
    v22[3] = v14;
    v22[4] = v14;
    v22[1] = v14;
    v22[2] = v14;
    v22[0] = v14;
    VCSDInfoConstructWithIPPorts(a1, a2, 0, 0, (uint64_t)v22);
    v15 = _VTP_SendWithSourceDestinationInfo(v13, (unsigned int *)v22, a3, a4, a5, a6, 0);
    if (v15 >= 1)
    {
      v16 = a6[2];
      if (v16)
      {
        v17 = CheckInHandleDebug();
        if (v17)
        {
          v18 = v17;
          v19 = (pthread_rwlock_t *)(v17 + 21640);
          pthread_rwlock_rdlock((pthread_rwlock_t *)(v17 + 21640));
          v20 = VTP_getConnectionManagerForCallID(v18, v16);
          VCConnectionManager_UpdateTransmittedPacketsAndBytes((uint64_t)v20, (uint64_t)v22, v15, 0, 0, 0, 0);
          pthread_rwlock_unlock(v19);
          CheckOutHandleDebug();
        }
        else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VTP_SendWithSourceDestinationIP_cold_2();
        }
      }
    }
    CheckOutHandleDebug();
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_SendWithSourceDestinationIP_cold_1();
    }
    *__error() = 13;
    return -1;
  }
  return v15;
}

void VTP_ReleasePacket(void **a1)
{
  uint64_t v2;
  uint64_t v3;

  if (a1 && *a1)
  {
    v2 = CheckInHandleDebug();
    if (v2)
    {
      v3 = v2;
      VCBlockBuffer_Clear((uint64_t)*a1 + 504);
      VCMemoryPool_Free(*(OSQueueHead **)(v3 + 22032), *a1);
      *a1 = 0;
      CheckOutHandleDebug();
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_ReleasePacket_cold_1();
    }
  }
}

uint64_t VTP_Recvfrom(int a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t v6;
  pthread_rwlock_t *v7;
  int *v8;
  unint64_t v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  char *v13;
  char *v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  NSObject *v18;
  void *v20;
  unint64_t v21;
  uint8_t buf[4];
  uint64_t v23;
  __int16 v24;
  const char *v25;
  __int16 v26;
  int v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v2 = 2148991018;
  if (!a2)
    return 2148990977;
  v21 = 0xAAAAAAAAAAAAAAAALL;
  *a2 = 0;
  v5 = CheckInHandleDebug();
  if (v5)
  {
    v6 = v5;
    v7 = (pthread_rwlock_t *)(v5 + 5376);
    pthread_rwlock_rdlock((pthread_rwlock_t *)(v5 + 5376));
    v8 = *(int **)(v6 + 5576);
    if (v8)
    {
      while (*v8 != a1)
      {
        v8 = (int *)*((_QWORD *)v8 + 44);
        if (!v8)
          goto LABEL_6;
      }
      pthread_mutex_lock((pthread_mutex_t *)(v8 + 60));
      ++v8[56];
      pthread_mutex_unlock((pthread_mutex_t *)(v8 + 60));
      pthread_rwlock_unlock(v7);
      pthread_mutex_lock((pthread_mutex_t *)(v8 + 28));
      v9 = *((_QWORD *)v8 + 13);
      if (!v9)
      {
        while (!*((_BYTE *)v8 + 25))
        {
          pthread_cond_wait((pthread_cond_t *)(v8 + 44), (pthread_mutex_t *)(v8 + 28));
          v9 = *((_QWORD *)v8 + 13);
          if (v9)
            goto LABEL_17;
        }
        goto LABEL_18;
      }
LABEL_17:
      if (*((_BYTE *)v8 + 25))
      {
LABEL_18:
        if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          v10 = VRTraceErrorLogLevelToCSTR();
          v11 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315650;
            v23 = v10;
            v24 = 2080;
            v25 = "VTP_Recvfrom";
            v26 = 1024;
            v27 = 3416;
            _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VTP_Recvfrom failed due to socket already closed", buf, 0x1Cu);
          }
        }
        *__error() = 9;
        v12 = 2148991009;
        goto LABEL_34;
      }
      v21 = v9;
      v13 = (char *)VCMemoryPool_Alloc(*(OSQueueHead **)(v6 + 22032));
      v20 = v13;
      if (!v13)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          v17 = VRTraceErrorLogLevelToCSTR();
          v18 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315650;
            v23 = v17;
            v24 = 2080;
            v25 = "VTP_Recvfrom";
            v26 = 1024;
            v27 = 3423;
            _os_log_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VTP_Recvfrom failed to allocate packet info", buf, 0x1Cu);
          }
        }
        *__error() = 9;
        v12 = 2148991009;
        goto LABEL_33;
      }
      v14 = v13;
      memcpy(v13 + 8, (const void *)(v9 + 48), *(unsigned int *)(v9 + 176));
      *((_DWORD *)v14 + 34) = *(_DWORD *)(v9 + 176);
      *(_QWORD *)v14 = *(_QWORD *)(v9 + 184);
      v15 = *(_OWORD *)(v9 + 8);
      v16 = *(_OWORD *)(v9 + 24);
      *(_QWORD *)(v14 + 172) = *(_QWORD *)(v9 + 40);
      *(_OWORD *)(v14 + 156) = v16;
      *(_OWORD *)(v14 + 140) = v15;
      if (*(_BYTE *)(v9 + 223))
        *((_DWORD *)v14 + 35) |= 1u;
      memcpy(v14 + 184, (const void *)(v9 + 208), 0x140uLL);
      if (!*(_BYTE *)(v9 + 220) || (*(_DWORD *)(v9 + 208) | 4) == 6)
      {
        VCBlockBuffer_Copy(v9 + 536, (uint64_t)(v14 + 504));
        v12 = 0;
LABEL_28:
        *a2 = v14;
LABEL_33:
        *((_QWORD *)v8 + 13) = *(_QWORD *)(v9 + 528);
        _VTP_ReleasePacket(v6, (void **)&v21);
LABEL_34:
        pthread_mutex_unlock((pthread_mutex_t *)(v8 + 28));
        pthread_mutex_lock((pthread_mutex_t *)(v8 + 60));
        --v8[56];
        pthread_cond_signal((pthread_cond_t *)(v8 + 76));
        pthread_mutex_unlock((pthread_mutex_t *)(v8 + 60));
        CheckOutHandleDebug();
        return v12;
      }
      v12 = DTLS_Read(*(_QWORD *)(v6 + 8 * *v8 + 13432), *(OpaqueCMBlockBuffer **)(v9 + 536), (CMBlockBufferRef *)v14 + 63, *(const __CFAllocator **)(v6 + 22016), *(const __CFAllocator **)(v6 + 22024));
      if ((v12 & 0x80000000) == 0)
      {
        if (CMBlockBufferGetDataPointer(*(CMBlockBufferRef *)(v9 + 536), 0, 0, (size_t *)v14 + 64, (char **)v14 + 65))
        {
          goto LABEL_28;
        }
        v12 = 2148990980;
      }
      VTP_ReleasePacket(&v20);
      goto LABEL_33;
    }
LABEL_6:
    pthread_rwlock_unlock(v7);
    CheckOutHandleDebug();
    *__error() = 9;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_Recvfrom_cold_2();
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_Recvfrom_cold_1();
    }
    *__error() = 13;
    return 2148990978;
  }
  return v2;
}

uint64_t VTP_SetAFRCRecvMode(uint64_t a1, int a2)
{
  uint64_t v4;

  v4 = CheckInHandleDebug();
  if (v4)
  {
    *(_QWORD *)(v4 + 5888) = a1;
    *(_BYTE *)(v4 + 5896) = a2 != 0;
    CheckOutHandleDebug();
    return 0;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_SetAFRCRecvMode_cold_1();
    }
    *__error() = 13;
    return 0xFFFFFFFFLL;
  }
}

uint64_t VTP_SetAFRC(int a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  pthread_rwlock_t *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;

  v4 = CheckInHandleDebug();
  if (v4)
  {
    v5 = v4;
    v6 = (pthread_rwlock_t *)(v4 + 5376);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v4 + 5376));
    v7 = *(_QWORD *)(v5 + 5576);
    if (v7)
    {
      while (*(_DWORD *)v7 != a1 || (*(_BYTE *)(v7 + 28) & 0xF0) == 0)
      {
        v7 = *(_QWORD *)(v7 + 352);
        if (!v7)
          goto LABEL_6;
      }
      v9 = 0;
      v8 = 0;
      *(_QWORD *)(v7 + 360) = a2;
    }
    else
    {
LABEL_6:
      v8 = 0xFFFFFFFFLL;
      v9 = 1;
    }
    pthread_rwlock_unlock(v6);
    CheckOutHandleDebug();
    if (v9)
      *__error() = 9;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_SetAFRC_cold_1();
    }
    *__error() = 13;
    return 0xFFFFFFFFLL;
  }
  return v8;
}

uint64_t VTP_SetAFRCConnectionNumber(int a1)
{
  uint64_t v2;

  v2 = CheckInHandleDebug();
  if (v2)
  {
    AFRCSetConnectionNumber(*(_QWORD *)(v2 + 5888), a1);
    CheckOutHandleDebug();
    return 0;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_SetAFRCConnectionNumber_cold_1();
    }
    *__error() = 13;
    return 0xFFFFFFFFLL;
  }
}

uint64_t VTP_NotifyAFRCRxEstimate(uint64_t a1, char a2, unint64_t a3, int a4, int a5, double a6)
{
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v10;
  int v11;
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (a1 == 0xFFFFFFFFLL)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v7 = VRTraceErrorLogLevelToCSTR();
      v8 = *MEMORY[0x1E0CF2758];
      if (!*MEMORY[0x1E0CF2748])
      {
        v6 = 2;
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEBUG))
          VTP_NotifyAFRCRxEstimate_cold_1();
        return v6;
      }
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v11 = 136315650;
        v12 = v7;
        v13 = 2080;
        v14 = "VTP_NotifyAFRCRxEstimate";
        v15 = 1024;
        v16 = 3704;
        _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VTP_NotifyAFRCRxEstimate INVALID_HANDLE", (uint8_t *)&v11, 0x1Cu);
      }
    }
    return 2;
  }
  if ((a2 & 0x10) != 0)
  {
    v10 = 0;
  }
  else
  {
    if ((a2 & 0x20) == 0)
    {
      v6 = 2148991010;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VTP_NotifyAFRCRxEstimate_cold_2();
      }
      return v6;
    }
    v10 = 1;
  }
  return RTPNotifyAFRCRxEstimate(a1, v10, a3, a4, a5, a6);
}

uint64_t VTP_RegisterPacketCallback(_OWORD *a1, uint64_t a2, const void *a3)
{
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  pthread_rwlock_t *v13;
  uint64_t i;
  int v15;
  uint64_t v16;
  int *v17;
  int v18;
  uint64_t v20;
  NSObject *v21;
  NSObject *v22;
  unsigned int *v23;
  uint8_t buf[4];
  uint64_t v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  int v31;
  _OWORD __s1[8];
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if (!a1 || !a3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_RegisterPacketCallback_cold_1();
    }
    v17 = __error();
    v18 = 22;
    goto LABEL_23;
  }
  v6 = CheckInHandleDebug();
  if (!v6)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_RegisterPacketCallback_cold_2();
    }
    v17 = __error();
    v18 = 13;
LABEL_23:
    *v17 = v18;
    return 0xFFFFFFFFLL;
  }
  v7 = v6;
  v8 = a1[4];
  v9 = a1[6];
  v10 = a1[7];
  __s1[5] = a1[5];
  __s1[6] = v9;
  __s1[7] = v10;
  v11 = a1[1];
  __s1[0] = *a1;
  __s1[1] = v11;
  v12 = a1[3];
  v13 = (pthread_rwlock_t *)(v6 + 5376);
  __s1[2] = a1[2];
  __s1[3] = v12;
  __s1[4] = v8;
  pthread_rwlock_rdlock((pthread_rwlock_t *)(v6 + 5376));
  for (i = *(_QWORD *)(v7 + 5576); i; i = *(_QWORD *)(i + 352))
  {
    v15 = *(_DWORD *)i;
    if (__darwin_check_fd_set_overflow(*(_DWORD *)i, __s1, 0))
      *(_DWORD *)((char *)__s1 + (((unint64_t)v15 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) &= ~(1 << v15);
  }
  if (!memcmp(__s1, &VTP_RegisterPacketCallback_zeros, 0x80uLL))
  {
    v23 = 0;
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v7 + 5584));
    AddOneVFDSETList(v7, &v23, (uint64_t)a1, 0, 0, a3, a2);
    pthread_rwlock_unlock((pthread_rwlock_t *)(v7 + 5584));
    if (v23)
    {
      v16 = *v23;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v20 = VRTraceErrorLogLevelToCSTR();
        v21 = *MEMORY[0x1E0CF2758];
        v22 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315906;
            v25 = v20;
            v26 = 2080;
            v27 = "VTP_RegisterPacketCallback";
            v28 = 1024;
            v29 = 4201;
            v30 = 1024;
            v31 = v16;
            _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Successfully added new vfd set with id: %d", buf, 0x22u);
          }
        }
        else if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
        {
          VTP_RegisterPacketCallback_cold_4();
        }
      }
      goto LABEL_14;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_RegisterPacketCallback_cold_3();
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_RegisterPacketCallback_cold_5();
    }
    *__error() = 9;
  }
  v16 = 0xFFFFFFFFLL;
LABEL_14:
  pthread_rwlock_unlock(v13);
  CheckOutHandleDebug();
  return v16;
}

_DWORD *AddOneVFDSETList(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, const void *a6, uint64_t a7)
{
  char *v14;
  char *v15;
  uint64_t v16;
  _DWORD *result;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;

  v14 = (char *)malloc_type_calloc(1uLL, 0xB0uLL, 0x10A0040C283F163uLL);
  if (v14)
  {
    v15 = v14;
    pthread_mutex_init((pthread_mutex_t *)(v14 + 8), 0);
    pthread_cond_init((pthread_cond_t *)(v15 + 72), 0);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 4288));
    v16 = 0;
    while (*(_BYTE *)(a1 + 4352 + v16))
    {
      if (++v16 == 1024)
      {
        LODWORD(v16) = -1;
        goto LABEL_11;
      }
    }
    *(_BYTE *)(a1 + v16 + 4352) = 1;
LABEL_11:
    result = (_DWORD *)pthread_mutex_unlock((pthread_mutex_t *)(a1 + 4288));
    *(_DWORD *)v15 = v16;
    *((_QWORD *)v15 + 16) = a3;
    *((_QWORD *)v15 + 17) = a4;
    *((_QWORD *)v15 + 18) = a5;
    if (a6)
    {
      result = _Block_copy(a6);
      *((_QWORD *)v15 + 20) = result;
      *((_QWORD *)v15 + 21) = a7;
    }
    v18 = *(_QWORD *)(a1 + 5784);
    if (v18)
    {
      do
      {
        v19 = v18;
        v18 = *(_QWORD *)(v18 + 152);
      }
      while (v18);
      v20 = (_QWORD *)(v19 + 152);
    }
    else
    {
      v20 = (_QWORD *)(a1 + 5784);
    }
    *v20 = v15;
    *a2 = v15;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
    {
      VRTraceErrorLogLevelToCSTR();
      if ((VRTraceIsOSFaultDisabled() & 1) != 0)
      {
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          AddOneVFDSETList_cold_1();
      }
      else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_FAULT))
      {
        AddOneVFDSETList_cold_2();
      }
    }
    result = __error();
    *result = 12;
  }
  return result;
}

void VTP_UnregisterPacketCallback(int a1)
{
  uint64_t v2;
  uint64_t v3;
  pthread_rwlock_t *v4;
  pthread_rwlock_t *v5;
  uint64_t v6;
  NSObject *v7;
  int v8;
  uint64_t v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  int v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v2 = CheckInHandleDebug();
  if (v2)
  {
    v3 = v2;
    v4 = (pthread_rwlock_t *)(v2 + 5376);
    pthread_rwlock_rdlock((pthread_rwlock_t *)(v2 + 5376));
    v5 = (pthread_rwlock_t *)(v3 + 5584);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v3 + 5584));
    RemoveOneVFDSETList(v3, a1);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      v6 = VRTraceErrorLogLevelToCSTR();
      v7 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v8 = 136315906;
        v9 = v6;
        v10 = 2080;
        v11 = "VTP_UnregisterPacketCallback";
        v12 = 1024;
        v13 = 4223;
        v14 = 1024;
        v15 = a1;
        _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Successfully removed vfd set with id: %d", (uint8_t *)&v8, 0x22u);
      }
    }
    pthread_rwlock_unlock(v5);
    pthread_rwlock_unlock(v4);
    CheckOutHandleDebug();
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VTP_UnregisterPacketCallback_cold_1();
  }
}

void RemoveOneVFDSETList(uint64_t a1, int a2)
{
  _DWORD *v2;
  _QWORD *v4;
  pthread_mutex_t *v5;
  _BYTE *v6;
  const void *v7;

  v2 = *(_DWORD **)(a1 + 5784);
  if (v2)
  {
    v4 = (_QWORD *)(a1 + 5784);
    v5 = (pthread_mutex_t *)(a1 + 4288);
    v6 = (_BYTE *)(a1 + a2 + 4352);
    do
    {
      if (*v2 == a2)
      {
        pthread_mutex_lock(v5);
        *v6 = 0;
        pthread_mutex_unlock(v5);
        v7 = (const void *)*((_QWORD *)v2 + 20);
        if (v7)
          _Block_release(v7);
        *v4 = *((_QWORD *)v2 + 19);
        pthread_mutex_destroy((pthread_mutex_t *)(v2 + 2));
        pthread_cond_destroy((pthread_cond_t *)(v2 + 18));
        free(v2);
      }
      else
      {
        v4 = v2 + 38;
      }
      v2 = (_DWORD *)*v4;
    }
    while (*v4);
  }
}

uint64_t VTP_Select(uint64_t a1, __int128 *a2, __int128 *a3, __int128 *a4, uint64_t a5)
{
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  double v12;
  int *v13;
  int v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  uint64_t i;
  int v32;
  int v33;
  uint64_t v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  uint64_t v44;
  double v45;
  __darwin_time_t v46;
  uint64_t v47;
  int v48;
  int v49;
  uint64_t v50;
  int v51;
  int v52;
  pthread_rwlock_t *v53;
  timespec v54;
  uint64_t v55;
  __int128 __s1;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 __src;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  uint64_t v88;

  v88 = *MEMORY[0x1E0C80C00];
  v55 = 0;
  *(_QWORD *)&v9 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v86 = v9;
  v87 = v9;
  v84 = v9;
  v85 = v9;
  v82 = v9;
  v83 = v9;
  __src = v9;
  v81 = v9;
  v10 = CheckInHandleDebug();
  if (!v10)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_Select_cold_1();
    }
    v13 = __error();
    v14 = 13;
    goto LABEL_26;
  }
  v11 = v10;
  if (a5)
    v12 = micro() + (double)*(int *)(a5 + 8) / 1000000.0 + (double)*(uint64_t *)a5;
  else
    v12 = 0.0;
  v86 = 0u;
  v87 = 0u;
  v84 = 0u;
  v85 = 0u;
  v82 = 0u;
  v83 = 0u;
  __src = 0u;
  v81 = 0u;
  v72 = 0u;
  v73 = 0u;
  v74 = 0u;
  v75 = 0u;
  v76 = 0u;
  v77 = 0u;
  v78 = 0u;
  v79 = 0u;
  v64 = 0u;
  v65 = 0u;
  v66 = 0u;
  v67 = 0u;
  v68 = 0u;
  v69 = 0u;
  v70 = 0u;
  v71 = 0u;
  if (a2)
  {
    v15 = a2[5];
    v84 = a2[4];
    v85 = v15;
    v16 = a2[7];
    v86 = a2[6];
    v87 = v16;
    v17 = a2[1];
    __src = *a2;
    v81 = v17;
    v18 = a2[3];
    v82 = a2[2];
    v83 = v18;
  }
  if (a3)
  {
    v19 = a3[5];
    v76 = a3[4];
    v77 = v19;
    v20 = a3[7];
    v78 = a3[6];
    v79 = v20;
    v21 = a3[1];
    v72 = *a3;
    v73 = v21;
    v22 = a3[3];
    v74 = a3[2];
    v75 = v22;
  }
  if (a4)
  {
    v23 = a4[5];
    v68 = a4[4];
    v69 = v23;
    v24 = a4[7];
    v70 = a4[6];
    v71 = v24;
    v25 = a4[1];
    v64 = *a4;
    v65 = v25;
    v26 = a4[3];
    v66 = a4[2];
    v67 = v26;
  }
  v63 = 0u;
  v61 = 0u;
  v62 = 0u;
  v59 = 0u;
  v60 = 0u;
  v57 = 0u;
  v58 = 0u;
  __s1 = 0u;
  if (a2)
  {
    v27 = a2[5];
    v60 = a2[4];
    v61 = v27;
    v28 = a2[7];
    v62 = a2[6];
    v63 = v28;
    v29 = a2[1];
    __s1 = *a2;
    v57 = v29;
    v30 = a2[3];
    v58 = a2[2];
    v59 = v30;
  }
  v53 = (pthread_rwlock_t *)(v11 + 5376);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(v11 + 5376));
  pthread_rwlock_wrlock((pthread_rwlock_t *)(v11 + 5584));
  for (i = *(_QWORD *)(v11 + 5576); i; i = *(_QWORD *)(i + 352))
  {
    v32 = *(_DWORD *)i;
    if (__darwin_check_fd_set_overflow(*(_DWORD *)i, &__s1, 0))
      *(_DWORD *)((char *)&__s1 + (((unint64_t)v32 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) &= ~(1 << v32);
    if (!*(_QWORD *)(i + 104))
    {
      v33 = *(_DWORD *)i;
      if (__darwin_check_fd_set_overflow(*(_DWORD *)i, &__src, 0))
        *(_DWORD *)((char *)&__src + (((unint64_t)v33 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) &= ~(1 << v33);
    }
  }
  if (memcmp(&__s1, &VTP_Select_zeros, 0x80uLL))
  {
    pthread_rwlock_unlock((pthread_rwlock_t *)(v11 + 5584));
    pthread_rwlock_unlock(v53);
    CheckOutHandleDebug();
    v13 = __error();
    v14 = 9;
LABEL_26:
    *v13 = v14;
    return 0xFFFFFFFFLL;
  }
  if (!memcmp(&__src, &VTP_Select_zeros, 0x80uLL))
  {
    AddOneVFDSETList(v11, &v55, (uint64_t)a2, (uint64_t)a3, (uint64_t)a4, 0, 0);
    v44 = v55;
    pthread_rwlock_unlock((pthread_rwlock_t *)(v11 + 5584));
    pthread_rwlock_unlock(v53);
    if (!v44)
    {
      CheckOutHandleDebug();
      return 0xFFFFFFFFLL;
    }
    pthread_mutex_lock((pthread_mutex_t *)(v44 + 8));
    if (a5)
    {
      if (!*(_BYTE *)(v44 + 120) && !*(_BYTE *)(v44 + 121))
      {
        while (1)
        {
          v45 = v12 - micro();
          if (v45 < 0.0)
            break;
          v54.tv_sec = 0xAAAAAAAAAAAAAAAALL;
          v54.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
          convertTimeoutToRelativeTimespec(v45);
          v54.tv_sec = v46;
          v54.tv_nsec = v47;
          v48 = pthread_cond_timedwait_relative_np((pthread_cond_t *)(v44 + 72), (pthread_mutex_t *)(v44 + 8), &v54);
          if (v48 == 60 || *(_BYTE *)(v44 + 120) || *(_BYTE *)(v44 + 121))
            goto LABEL_51;
        }
        v48 = 60;
        goto LABEL_51;
      }
    }
    else if (!*(_BYTE *)(v44 + 120) && !*(_BYTE *)(v44 + 121))
    {
      do
        v48 = pthread_cond_wait((pthread_cond_t *)(v44 + 72), (pthread_mutex_t *)(v44 + 8));
      while (!*(_BYTE *)(v44 + 120) && !*(_BYTE *)(v44 + 121));
LABEL_51:
      pthread_mutex_unlock((pthread_mutex_t *)(v44 + 8));
      v49 = *(unsigned __int8 *)(v44 + 121);
      pthread_rwlock_wrlock((pthread_rwlock_t *)(v11 + 5584));
      RemoveOneVFDSETList(v11, *(_DWORD *)v44);
      pthread_rwlock_unlock((pthread_rwlock_t *)(v11 + 5584));
      if (v48)
      {
        if (v48 == 60)
        {
          v34 = 0;
        }
        else
        {
          *__error() = v48;
          v34 = 0xFFFFFFFFLL;
        }
      }
      else if (v49)
      {
        *__error() = 9;
        v34 = 0xFFFFFFFFLL;
      }
      else
      {
        pthread_rwlock_rdlock(v53);
        v50 = *(_QWORD *)(v11 + 5576);
        if (v50)
        {
          v34 = 0;
          do
          {
            if (a2)
            {
              if (*(_QWORD *)(v50 + 104))
              {
                v51 = *(_DWORD *)v50;
                if (__darwin_check_fd_set_overflow(*(_DWORD *)v50, a2, 0))
                {
                  if (((*(_DWORD *)((char *)a2 + (((unint64_t)v51 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> v51) & 1) != 0)
                  {
                    v52 = *(_DWORD *)v50;
                    if (__darwin_check_fd_set_overflow(*(_DWORD *)v50, &__src, 0))
                      *(_DWORD *)((char *)&__src + (((unint64_t)v52 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v52;
                    v34 = (v34 + 1);
                  }
                }
              }
            }
            v50 = *(_QWORD *)(v50 + 352);
          }
          while (v50);
        }
        else
        {
          v34 = 0;
        }
        pthread_rwlock_unlock(v53);
      }
      goto LABEL_30;
    }
    v48 = 0;
    goto LABEL_51;
  }
  pthread_rwlock_unlock((pthread_rwlock_t *)(v11 + 5584));
  pthread_rwlock_unlock(v53);
  v34 = 1;
LABEL_30:
  if (a2)
    memmove(a2, &__src, 0x80uLL);
  if (a3)
  {
    v35 = v77;
    a3[4] = v76;
    a3[5] = v35;
    v36 = v79;
    a3[6] = v78;
    a3[7] = v36;
    v37 = v73;
    *a3 = v72;
    a3[1] = v37;
    v38 = v75;
    a3[2] = v74;
    a3[3] = v38;
  }
  if (a4)
  {
    v39 = v69;
    a4[4] = v68;
    a4[5] = v39;
    v40 = v71;
    a4[6] = v70;
    a4[7] = v40;
    v41 = v65;
    *a4 = v64;
    a4[1] = v41;
    v42 = v67;
    a4[2] = v66;
    a4[3] = v42;
  }
  CheckOutHandleDebug();
  return v34;
}

uint64_t VTP_GetSendRecvStats(unint64_t *a1, unint64_t *a2)
{
  unint64_t *v4;
  unint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t v8;
  NSObject *v9;
  unint64_t v10;
  unint64_t v11;
  int v13;
  uint64_t v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  unint64_t v20;
  __int16 v21;
  unint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v4 = (unint64_t *)CheckInHandleDebug();
  if (v4)
  {
    do
      v5 = __ldxr(v4);
    while (__stxr(v5, v4));
    *a1 = v5;
    v6 = v4 + 1;
    do
      v7 = __ldxr(v6);
    while (__stxr(v7, v6));
    *a2 = v7;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v8 = VRTraceErrorLogLevelToCSTR();
      v9 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v10 = *a1;
        v11 = *a2;
        v13 = 136316162;
        v14 = v8;
        v15 = 2080;
        v16 = "VTP_GetSendRecvStats";
        v17 = 1024;
        v18 = 4381;
        v19 = 2048;
        v20 = v10;
        v21 = 2048;
        v22 = v11;
        _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VTP_GetSendRecvStats %lld/%lld", (uint8_t *)&v13, 0x30u);
      }
    }
    CheckOutHandleDebug();
    return 0;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_GetSendRecvStats_cold_1();
    }
    *__error() = 13;
    return 0xFFFFFFFFLL;
  }
}

uint64_t VTP_SetCellularUniqueTag(int a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  pthread_rwlock_t *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;

  v4 = CheckInHandleDebug();
  if (v4)
  {
    v5 = v4;
    v6 = (pthread_rwlock_t *)(v4 + 5376);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v4 + 5376));
    v7 = *(_QWORD *)(v5 + 5576);
    if (v7)
    {
      while (*(_DWORD *)v7 != a1 || (*(_BYTE *)(v7 + 29) & 1) == 0)
      {
        v7 = *(_QWORD *)(v7 + 352);
        if (!v7)
          goto LABEL_6;
      }
      v9 = 0;
      v8 = 0;
      *(_DWORD *)(v7 + 52) = a2;
    }
    else
    {
LABEL_6:
      v8 = 0xFFFFFFFFLL;
      v9 = 1;
    }
    pthread_rwlock_unlock(v6);
    CheckOutHandleDebug();
    if (v9)
      *__error() = 9;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_SetCellularUniqueTag_cold_1();
    }
    *__error() = 13;
    return 0xFFFFFFFFLL;
  }
  return v8;
}

void VTP_SetPktTag(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (a2 < 5)
  {
    *(_QWORD *)(a1 + 8 * a2 + 256) = a3;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VTP_SetPktTag_cold_1();
  }
}

uint64_t VTP_SetRTPSrc(int a1, uint64_t a2, _BYTE *a3)
{
  __int128 v5;
  uint64_t v6;
  int ErrorLogLevelForModule;
  uint64_t v8;
  NSObject *v9;
  pthread_rwlock_t *v10;
  uint64_t v11;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  int v17;
  uint64_t v18;
  NSObject *v19;
  const char *v20;
  uint64_t v21;
  _OWORD __n_4[10];
  _OWORD v23[4];
  _OWORD v24[2];
  uint8_t buf[4];
  uint64_t v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  int v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)((char *)v24 + 14) = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v23[3] = v5;
  v24[0] = v5;
  v23[2] = v5;
  *(_QWORD *)((char *)v23 + 14) = 0xAAAAAAAAAAAAAAAALL;
  __n_4[9] = v5;
  v23[0] = v5;
  __n_4[8] = v5;
  v6 = CheckInHandleDebug();
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (v6)
  {
    if (ErrorLogLevelForModule >= 7)
    {
      v8 = VRTraceErrorLogLevelToCSTR();
      v9 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(__n_4[0]) = 136316418;
        *(_QWORD *)((char *)__n_4 + 4) = v8;
        WORD6(__n_4[0]) = 2080;
        *(_QWORD *)((char *)__n_4 + 14) = "VTP_SetRTPSrc";
        WORD3(__n_4[1]) = 1024;
        DWORD2(__n_4[1]) = 4487;
        WORD6(__n_4[1]) = 1024;
        *(_DWORD *)((char *)&__n_4[1] + 14) = a1;
        WORD1(__n_4[2]) = 2080;
        *(_QWORD *)((char *)&__n_4[2] + 4) = IPPORTToStringWithSize();
        WORD6(__n_4[2]) = 2080;
        *(_QWORD *)((char *)&__n_4[2] + 14) = IPPORTToStringWithSize();
        _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VTP_SetRTPSrc for callID(%08X) local[%s] dst[%s].", (uint8_t *)__n_4, 0x36u);
      }
    }
    v10 = (pthread_rwlock_t *)(v6 + 5376);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v6 + 5376));
    v11 = *(_QWORD *)(v6 + 5880);
    if (!v11)
      goto LABEL_34;
    while (*(_DWORD *)v11 != a1)
    {
      v11 = *(_QWORD *)(v11 + 2056);
      if (!v11)
        goto LABEL_34;
    }
    *(_QWORD *)&v13 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __n_4[6] = v13;
    __n_4[7] = v13;
    __n_4[4] = v13;
    __n_4[5] = v13;
    __n_4[2] = v13;
    __n_4[3] = v13;
    __n_4[0] = v13;
    __n_4[1] = v13;
    if ((*a3 & 1) != 0)
      IPPORTToSA6();
    else
      IPPORTToSA();
    v14 = *(unsigned int *)(v11 + 2024);
    if ((int)v14 < 1)
    {
      LODWORD(v15) = 0;
    }
    else
    {
      v15 = 0;
      v16 = (char *)(v11 + 1232);
      while (memcmp(v16, __n_4, 0x80uLL))
      {
        ++v15;
        v16 += 128;
        if (v14 == v15)
          goto LABEL_23;
      }
    }
    if ((_DWORD)v15 == (_DWORD)v14)
    {
LABEL_23:
      if ((int)v14 >= 5)
        LODWORD(v14) = 5;
      memmove((void *)(v11 + 1360), (const void *)(v11 + 1232), (uint64_t)(int)v14 << 7);
      memmove((void *)(v11 + 2004), (const void *)(v11 + 2000), 4 * (int)v14);
      memcpy((void *)(v11 + 1232), __n_4, 0x80uLL);
      *(_DWORD *)(v11 + 2000) = 128;
      v17 = *(_DWORD *)(v11 + 2024);
      if (v17 < 6)
        *(_DWORD *)(v11 + 2024) = v17 + 1;
      if ((int)VRTraceGetErrorLogLevelForModule() <= 6)
        goto LABEL_34;
      v18 = VRTraceErrorLogLevelToCSTR();
      v19 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        goto LABEL_34;
      *(_DWORD *)buf = 136315650;
      v26 = v18;
      v27 = 2080;
      v28 = "SetVFDSASrc";
      v29 = 1024;
      v30 = 4466;
      v20 = " [%s] %s:%d VTP added VFDSASrc successfully.";
    }
    else
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 7)
        goto LABEL_34;
      v21 = VRTraceErrorLogLevelToCSTR();
      v19 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        goto LABEL_34;
      *(_DWORD *)buf = 136315650;
      v26 = v21;
      v27 = 2080;
      v28 = "SetVFDSASrc";
      v29 = 1024;
      v30 = 4468;
      v20 = " [%s] %s:%d VTP found duplicate VFDSASrc entry.";
    }
    _os_log_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_DEFAULT, v20, buf, 0x1Cu);
LABEL_34:
    pthread_rwlock_unlock(v10);
    CheckOutHandleDebug();
    return 0;
  }
  if (ErrorLogLevelForModule >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VTP_SetRTPSrc_cold_1();
  }
  *__error() = 13;
  return 0xFFFFFFFFLL;
}

uint64_t VTP_SetNetworkLogLevel(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  pthread_rwlock_t *v6;
  __int128 v7;
  int *v8;
  int v9;
  int *v11;
  int v12;
  uint64_t v13;
  uint64_t v15;
  NSObject *v16;
  int v17;
  int v18;
  uint64_t v19;
  NSObject *v20;
  uint8_t buf[4];
  uint64_t v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  int v26;
  __int16 v27;
  __int128 *v28;
  __int16 v29;
  int v30;
  __int128 v31;
  __int128 v32;
  _BYTE v33[22];
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v4 = CheckInHandleDebug();
  if (!v4)
  {
    v11 = __error();
    v12 = 13;
LABEL_24:
    *v11 = v12;
    return 0xFFFFFFFFLL;
  }
  v5 = v4;
  v6 = (pthread_rwlock_t *)(v4 + 5376);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(v4 + 5376));
  *(_QWORD *)&v33[14] = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v32 = v7;
  *(_OWORD *)v33 = v7;
  v31 = v7;
  IPPORTToStringWithSize();
  v8 = *(int **)(v5 + 5576);
  if (!v8)
  {
LABEL_15:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_SetNetworkLogLevel_cold_2();
    }
    pthread_rwlock_unlock(v6);
LABEL_19:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_SetNetworkLogLevel_cold_1();
    }
    CheckOutHandleDebug();
    v11 = __error();
    v12 = 9;
    goto LABEL_24;
  }
  v9 = *(_DWORD *)a1 & 1;
  while (1)
  {
    if ((v8[15] & 1) == v9)
    {
      if (v9)
      {
        if (*((_QWORD *)v8 + 10) != *(_QWORD *)(a1 + 20) || *((_QWORD *)v8 + 11) != *(_QWORD *)(a1 + 28))
          goto LABEL_14;
      }
      else if (v8[20] != *(_DWORD *)(a1 + 20))
      {
        goto LABEL_14;
      }
      if (*((unsigned __int16 *)v8 + 48) == *(unsigned __int16 *)(a1 + 36))
        break;
    }
LABEL_14:
    v8 = (int *)*((_QWORD *)v8 + 44);
    if (!v8)
      goto LABEL_15;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v15 = VRTraceErrorLogLevelToCSTR();
    v16 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v17 = *v8;
      *(_DWORD *)buf = 136316162;
      v22 = v15;
      v23 = 2080;
      v24 = "FindVFDByLocalIPPort";
      v25 = 1024;
      v26 = 2468;
      v27 = 2080;
      v28 = &v31;
      v29 = 1024;
      v30 = v17;
      _os_log_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Connection result with localIPPort %s uses vfd(%d) for send.", buf, 0x2Cu);
    }
  }
  v18 = v8[5];
  pthread_rwlock_unlock(v6);
  if (v18 == -1)
    goto LABEL_19;
  *__error() = 0;
  v31 = 0u;
  v32 = 0u;
  __strlcpy_chk();
  LODWORD(v32) = a2;
  *(_QWORD *)((char *)&v32 + 4) = 0x111010001;
  v13 = 0;
  if (ioctl(v18, 0xC020699BuLL, &v31) < 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v19 = VRTraceErrorLogLevelToCSTR();
      v20 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_SetNetworkLogLevel_cold_3(v19, (uint64_t)&v31, v20);
    }
    v13 = 0xFFFFFFFFLL;
  }
  CheckOutHandleDebug();
  return v13;
}

uint64_t VTP_NotifyRemoteNoRemotePacket(int a1, double a2)
{
  uint64_t v2;
  uint64_t v3;
  pthread_mutex_t *v4;
  void (*v5)(uint64_t, _QWORD, _QWORD *, int *);
  int v7;
  _QWORD v8[2];

  v8[1] = *MEMORY[0x1E0C80C00];
  *(double *)v8 = a2;
  v7 = a1;
  v2 = CheckInHandleDebug();
  if (v2)
  {
    v3 = v2;
    v4 = (pthread_mutex_t *)(v2 + 48);
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 48));
    v5 = *(void (**)(uint64_t, _QWORD, _QWORD *, int *))(v3 + 112);
    if (v5)
    {
      v5(1, *(_QWORD *)(v3 + 120), v8, &v7);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_NotifyRemoteNoRemotePacket_cold_1();
    }
    pthread_mutex_unlock(v4);
    CheckOutHandleDebug();
  }
  else
  {
    *__error() = 13;
  }
  return 0xFFFFFFFFLL;
}

uint64_t VTP_NotifySendFailed(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  pthread_mutex_t *v4;
  void (*v5)(uint64_t, _QWORD, uint64_t, _QWORD);

  v2 = CheckInHandleDebug();
  if (v2)
  {
    v3 = v2;
    v4 = (pthread_mutex_t *)(v2 + 48);
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 48));
    v5 = *(void (**)(uint64_t, _QWORD, uint64_t, _QWORD))(v3 + 112);
    if (v5)
    {
      v5(2, *(_QWORD *)(v3 + 120), a1, 0);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_NotifySendFailed_cold_2();
    }
    pthread_mutex_unlock(v4);
    CheckOutHandleDebug();
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_NotifySendFailed_cold_1();
    }
    *__error() = 13;
  }
  return 0xFFFFFFFFLL;
}

uint64_t VTP_SetClientRelayVFD(int a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  pthread_rwlock_t *v6;
  uint64_t v7;
  int *v8;
  int v9;
  uint64_t v10;
  uint64_t v12;

  v4 = CheckInHandleDebug();
  if (!v4)
  {
    v8 = __error();
    v9 = 13;
    goto LABEL_7;
  }
  v5 = v4;
  v6 = (pthread_rwlock_t *)(v4 + 5376);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(v4 + 5376));
  v7 = *(_QWORD *)(v5 + 5880);
  if (!v7)
  {
LABEL_5:
    pthread_rwlock_unlock(v6);
    CheckOutHandleDebug();
    v8 = __error();
    v9 = 22;
LABEL_7:
    *v8 = v9;
    return 0xFFFFFFFFLL;
  }
  while (*(_DWORD *)v7 != a1)
  {
    v7 = *(_QWORD *)(v7 + 2056);
    if (!v7)
      goto LABEL_5;
  }
  if (a2 == -1)
  {
    v10 = 0;
    *(_QWORD *)(v7 + 2032) = 0;
  }
  else
  {
    v12 = *(_QWORD *)(v5 + 5576);
    if (v12)
    {
      while (*(_DWORD *)v12 != a2)
      {
        v12 = *(_QWORD *)(v12 + 352);
        if (!v12)
          goto LABEL_16;
      }
      *(_QWORD *)(v7 + 2032) = v12;
    }
LABEL_16:
    if (*(_QWORD *)(v7 + 2032))
    {
      v10 = 0;
    }
    else
    {
      *__error() = 22;
      v10 = 0xFFFFFFFFLL;
    }
  }
  pthread_rwlock_unlock(v6);
  CheckOutHandleDebug();
  return v10;
}

uint64_t VTP_DetectNAT64Prefix(int a1, const char *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void (*v7)(int *, uint64_t, _DWORD *);
  int Prefix;
  uint64_t v9;
  NSObject *v10;
  int v11;
  uint64_t v12;
  NSObject *v13;
  int v14;
  void (*v15)(int *, uint64_t, _DWORD *);
  int v16;
  unsigned int v17;
  int *v18;
  int v19;
  pthread_rwlock_t *v21;
  uint8_t buf[4];
  uint64_t v23;
  __int16 v24;
  const char *v25;
  __int16 v26;
  int v27;
  __int16 v28;
  const char *v29;
  __int16 v30;
  int v31;
  __int16 v32;
  int v33;
  __int16 v34;
  int v35;
  __int16 v36;
  unsigned int v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v4 = CheckInHandleDebug();
    if (v4)
    {
      v5 = v4;
      v21 = (pthread_rwlock_t *)(v4 + 5376);
      pthread_rwlock_wrlock((pthread_rwlock_t *)(v4 + 5376));
      v6 = *(_QWORD *)(v5 + 5576);
      if (v6)
      {
        v7 = VTP_NAT64PrefixResolvedCallback;
        do
        {
          if (*(_DWORD *)v6 == a1 && (*(_BYTE *)(v6 + 60) & 1) != 0)
          {
            VCNAT64ResolverRegisterForPrefixUpdate(a2, (uint64_t)v7, v6);
            Prefix = VCNAT64ResolverGetPrefix((uint64_t)a2, (_QWORD *)(v6 + 372));
            if (Prefix < 0 || !VCNAT64ResolverIsNonzeroPrefix((_DWORD *)(v6 + 372)))
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
              {
                v12 = VRTraceErrorLogLevelToCSTR();
                v13 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                {
                  v14 = *(_DWORD *)v6;
                  v15 = v7;
                  v16 = *(_DWORD *)(v6 + 60) & 1;
                  v17 = VCNAT64ResolverIsNonzeroPrefix((_DWORD *)(v6 + 372));
                  *(_DWORD *)buf = 136316930;
                  v23 = v12;
                  v24 = 2080;
                  v25 = "VTP_DetectNAT64Prefix";
                  v26 = 1024;
                  v27 = 4679;
                  v28 = 2080;
                  v29 = a2;
                  v30 = 1024;
                  v31 = v14;
                  v32 = 1024;
                  v33 = Prefix;
                  v34 = 1024;
                  v35 = v16;
                  v7 = v15;
                  v36 = 1024;
                  v37 = v17;
                  _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Interface %s (VFD %d) ISNOT behind NAT (result %d, local is IPv6 %d, isNoneZero %d)", buf, 0x3Eu);
                }
              }
            }
            else
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
              {
                v9 = VRTraceErrorLogLevelToCSTR();
                v10 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                {
                  v11 = *(_DWORD *)v6;
                  *(_DWORD *)buf = 136316162;
                  v23 = v9;
                  v24 = 2080;
                  v25 = "VTP_DetectNAT64Prefix";
                  v26 = 1024;
                  v27 = 4676;
                  v28 = 2080;
                  v29 = a2;
                  v30 = 1024;
                  v31 = v11;
                  _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Interface %s (VFD %d) IS behind NAT", buf, 0x2Cu);
                }
              }
              *(_BYTE *)(v6 + 368) = 1;
            }
          }
          v6 = *(_QWORD *)(v6 + 352);
        }
        while (v6);
      }
      pthread_rwlock_unlock(v21);
      CheckOutHandleDebug();
      v18 = __error();
      v19 = 9;
    }
    else
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VTP_DetectNAT64Prefix_cold_1();
      }
      v18 = __error();
      v19 = 13;
    }
  }
  else
  {
    v18 = __error();
    v19 = 22;
  }
  *v18 = v19;
  return 0xFFFFFFFFLL;
}

void VTP_NAT64PrefixResolvedCallback(int *a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v6;
  NSObject *v7;
  int v8;
  const char *v9;
  NSObject *v10;
  uint32_t v11;
  uint64_t v12;
  NSObject *v13;
  unsigned int v14;
  int v15;
  uint8_t buf[4];
  uint64_t v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  _BYTE v23[10];
  int v24;
  __int16 v25;
  char *v26;
  _QWORD v27[2];
  char v28[16];
  _WORD v29[15];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)v28 = 0u;
  memset(v29, 0, sizeof(v29));
  if ((a1[15] & 1) != 0 && VCNAT64ResolverIsNonzeroPrefix(a3))
  {
    *(_OWORD *)(a1 + 93) = *(_OWORD *)a3;
    *((_BYTE *)a1 + 368) = 1;
    v27[0] = 0xAAAAAAAAAAAAAAAALL;
    v27[1] = 0xAAAAAAAAAAAAAAAALL;
    nw_nat64_synthesize_v6();
    inet_ntop(30, v27, v28, 0x2Eu);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v6 = VRTraceErrorLogLevelToCSTR();
      v7 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v8 = *a1;
        *(_DWORD *)buf = 136316418;
        v17 = v6;
        v18 = 2080;
        v19 = "VTP_NAT64PrefixResolvedCallback";
        v20 = 1024;
        v21 = 4762;
        v22 = 2080;
        *(_QWORD *)v23 = a2;
        *(_WORD *)&v23[8] = 1024;
        v24 = v8;
        v25 = 2080;
        v26 = v28;
        v9 = " [%s] %s:%d Interface %s (VFD %d) IS behind NAT 64 with prefix: %s";
        v10 = v7;
        v11 = 54;
LABEL_9:
        _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, v9, buf, v11);
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v12 = VRTraceErrorLogLevelToCSTR();
    v13 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v14 = VCNAT64ResolverIsNonzeroPrefix(a3);
      v15 = a1[15] & 1;
      *(_DWORD *)buf = 136316162;
      v17 = v12;
      v18 = 2080;
      v19 = "VTP_NAT64PrefixResolvedCallback";
      v20 = 1024;
      v21 = 4764;
      v22 = 1024;
      *(_DWORD *)v23 = v14;
      *(_WORD *)&v23[4] = 1024;
      *(_DWORD *)&v23[6] = v15;
      v9 = " [%s] %s:%d provided a all zeroed prefix (%d), local is IPv6 (%d)";
      v10 = v13;
      v11 = 40;
      goto LABEL_9;
    }
  }
}

uint64_t VTP_RegisterConnectionManagerWithCallID(const void *a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  pthread_rwlock_t *v5;
  CFNumberRef v6;
  uint64_t v7;
  NSObject *v8;
  int valuePtr;
  uint8_t buf[4];
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  const void *v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  valuePtr = a2;
  v3 = CheckInHandleDebug();
  if (v3)
  {
    v4 = v3;
    v5 = (pthread_rwlock_t *)(v3 + 21640);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v3 + 21640));
    v6 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &valuePtr);
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(v4 + 21840), v6, a1);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      v7 = VRTraceErrorLogLevelToCSTR();
      v8 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136316162;
        v12 = v7;
        v13 = 2080;
        v14 = "VTP_RegisterConnectionManagerWithCallID";
        v15 = 1024;
        v16 = 4781;
        v17 = 2048;
        v18 = a1;
        v19 = 1024;
        v20 = valuePtr;
        _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VTP registered connectionManager %p with callID %d", buf, 0x2Cu);
      }
    }
    CFRelease(v6);
    pthread_rwlock_unlock(v5);
    CheckOutHandleDebug();
    return 0;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_RegisterConnectionManagerWithCallID_cold_1();
    }
    *__error() = 13;
    return 0xFFFFFFFFLL;
  }
}

uint64_t VTP_DeregisterConnectionManagerWithCallID(int a1)
{
  uint64_t v1;
  uint64_t v2;
  pthread_rwlock_t *v3;
  CFNumberRef v4;
  uint64_t v5;
  NSObject *v6;
  int v7;
  CFIndex Count;
  int valuePtr;
  uint8_t buf[4];
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  __int16 v19;
  CFIndex v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  valuePtr = a1;
  v1 = CheckInHandleDebug();
  if (v1)
  {
    v2 = v1;
    v3 = (pthread_rwlock_t *)(v1 + 21640);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v1 + 21640));
    v4 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &valuePtr);
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v2 + 21840), v4);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v6 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v7 = valuePtr;
        Count = CFDictionaryGetCount(*(CFDictionaryRef *)(v2 + 21840));
        *(_DWORD *)buf = 136316162;
        v12 = v5;
        v13 = 2080;
        v14 = "VTP_DeregisterConnectionManagerWithCallID";
        v15 = 1024;
        v16 = 4804;
        v17 = 1024;
        v18 = v7;
        v19 = 2048;
        v20 = Count;
        _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VTP de-registered connectionManager with callID %d, remaining items number %ld", buf, 0x2Cu);
      }
    }
    CFRelease(v4);
    pthread_rwlock_unlock(v3);
    CheckOutHandleDebug();
    return 0;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_DeregisterConnectionManagerWithCallID_cold_1();
    }
    *__error() = 13;
    return 0xFFFFFFFFLL;
  }
}

uint64_t VTP_IncrementTotalBytesSent(uint64_t a1)
{
  unint64_t *v2;
  unint64_t v3;
  uint64_t v4;

  v2 = (unint64_t *)CheckInHandleDebug();
  if (v2)
  {
    do
      v3 = __ldxr(v2);
    while (__stxr(v3 + a1, v2));
    CheckOutHandleDebug();
    return 0;
  }
  else
  {
    v4 = 2148990978;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_IncrementTotalBytesSent_cold_1();
    }
  }
  return v4;
}

uint64_t VTP_ScheduleReceiveForNWConnection()
{
  nw_connection_receive_multiple();
  return 1;
}

void sub_1D8D30F34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v7;
  va_list va;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v7 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t VTP_GetPktType(int a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD v6[6];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v7 = 0;
  v8 = &v7;
  v9 = 0x2020000000;
  v10 = -1;
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = __VTP_GetPktType_block_invoke;
  v6[3] = &unk_1E9E56128;
  v6[4] = &v7;
  v6[5] = a2;
  v3 = CheckInHandleDebug();
  if (v3)
  {
    VTP_ProcessVFD(v3, a1, 1, (uint64_t)v6);
    CheckOutHandleDebug();
    if (*((_DWORD *)v8 + 6) == -1)
    {
      *__error() = 9;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VTP_GetPktType_cold_2();
      }
    }
  }
  else
  {
    *__error() = 13;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_GetPktType_cold_1();
    }
  }
  v4 = *((unsigned int *)v8 + 6);
  _Block_object_dispose(&v7, 8);
  return v4;
}

void sub_1D8D31144(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
  _Unwind_Resume(exception_object);
}

void VTP_ReleaseVFD(pthread_mutex_t *a1, int a2)
{
  pthread_mutex_t *v4;
  uint64_t v5;
  uint64_t *v6;
  const void *v7;
  _QWORD *v8;

  if ((a2 - 1024) > 0xFFFFFC63)
  {
    v4 = a1 + 66;
    pthread_mutex_lock(a1 + 66);
    v5 = (a2 - 100);
    v6 = &a1->__sig + v5;
    v7 = (const void *)v6[855];
    if (v7)
    {
      v8 = v6 + 855;
      CFRelease(v7);
      *v8 = 0;
    }
    *(_QWORD *)&a1[222].__opaque[8 * v5 + 16] = 0xFFFFFFFFLL;
    a1[92].__opaque[v5 + 16] = 0;
    pthread_mutex_unlock(v4);
  }
  else
  {
    *__error() = 22;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_ReleaseVFD_cold_1();
    }
  }
}

uint64_t PrepareOFTMAC(const __CFString *a1, const void *a2, int a3, _DWORD *a4)
{
  CFIndex Length;
  CFIndex MaximumSizeForEncoding;
  size_t v10;
  char *CStringPtr;
  size_t v12;
  uint64_t result;
  _QWORD macOut[4];

  macOut[3] = *MEMORY[0x1E0C80C00];
  memset(macOut, 170, 20);
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        PrepareOFTMAC_cold_1();
    }
    return 0xFFFFFFFFLL;
  }
  Length = CFStringGetLength(a1);
  MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  if (MaximumSizeForEncoding <= 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        PrepareOFTMAC_cold_2();
    }
    return 0xFFFFFFFFLL;
  }
  v10 = MaximumSizeForEncoding;
  CStringPtr = (char *)CFStringGetCStringPtr(a1, 0x8000100u);
  MEMORY[0x1E0C80A78](CStringPtr);
  memset((char *)macOut - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0), 170, v10);
  if (CStringPtr
    || (CStringPtr = (char *)macOut - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0),
        CFStringGetCString(a1, CStringPtr, v10, 0x8000100u)))
  {
    v12 = strlen(CStringPtr);
    CCHmac(0, CStringPtr, v12, a2, a3, macOut);
    result = 0;
    *a4 = macOut[0];
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        PrepareOFTMAC_cold_3();
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

void PrepareOFTCRC32(uint64_t a1, int a2, int a3, unsigned int *a4)
{
  unsigned int v8;
  uInt *v9;
  uint64_t v10;
  const Bytef *v11;
  uInt v12;

  v8 = crc32(0, 0, 0);
  if (a1 && a4)
  {
    if (a3 < a2)
    {
      v9 = (uInt *)(a1 + 16 * a3 + 8);
      v10 = a2 - (uint64_t)a3;
      do
      {
        v11 = (const Bytef *)*((_QWORD *)v9 - 1);
        v12 = *v9;
        v9 += 4;
        v8 = crc32(v8, v11, v12);
        --v10;
      }
      while (v10);
    }
    *a4 = v8;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      PrepareOFTCRC32_cold_1();
  }
}

double VTP_AddNAT64PrefixToIPv4Destination(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  double result;
  _BYTE v6[28];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  memset(&v6[4], 170, 24);
  if (*(_BYTE *)(a1 + 368))
  {
    if (*(_BYTE *)(a2 + 1) == 2)
    {
      *(_WORD *)v6 = 7708;
      *(_WORD *)&v6[2] = *(_WORD *)(a2 + 2);
      nw_nat64_synthesize_v6();
      *a3 = 28;
      *(_OWORD *)(a2 + 12) = *(_OWORD *)&v6[12];
      result = *(double *)v6;
      *(_OWORD *)a2 = *(_OWORD *)v6;
    }
  }
  return result;
}

void VTP_DemuxPacketsToVFDList(uint64_t a1, _BYTE *a2, _DWORD *a3)
{
  _QWORD *v4;
  _DWORD *v6;
  _QWORD *v7;
  int *v8;
  int v9;
  int v10;
  unsigned int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int *v16;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  BOOL v22;
  unint64_t v23;
  char v24;
  int v25;
  unsigned int v26;
  unsigned __int8 v29;
  uint64_t v30;
  NSObject *v31;
  int v32;
  _BOOL4 v33;
  void **v34;
  uint64_t v35;
  NSObject *v36;
  int v37;
  int v38;
  uint64_t v39;
  NSObject *v40;
  int v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  int *v45;
  int v46;
  int v47;
  int v48;
  _BYTE *v49;
  _BYTE *v50;
  _QWORD *v51;
  uint8_t buf[4];
  uint64_t v53;
  __int16 v54;
  const char *v55;
  __int16 v56;
  int v57;
  __int16 v58;
  int v59;
  __int16 v60;
  _BOOL4 v61;
  __int16 v62;
  uint64_t v63;
  __int16 v64;
  int v65;
  __int16 v66;
  int v67;
  __int16 v68;
  int v69;
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  v50 = a2;
  if (!a2)
    return;
  v4 = a2;
  v6 = (_DWORD *)(a1 + 21904);
  v49 = (_BYTE *)(a1 + 5896);
  do
  {
    v7 = v4;
    v4 = (_QWORD *)v4[66];
    v7[66] = 0;
    if (a3 && *(_DWORD *)v7 != 0x20000)
      ++*a3;
    v8 = *(int **)(a1 + 5576);
    if (!v8)
    {
LABEL_50:
      _VTP_ReleasePacket(a1, (void **)&v50);
      ++v6[4];
      goto LABEL_106;
    }
    v9 = *(_DWORD *)v7;
    while (1)
    {
      if ((v9 & v8[7]) == 0)
        goto LABEL_49;
      v10 = v8[4];
      if (v10 == 2 || (v11 = *((_DWORD *)v7 + 58), v11 < 4))
      {
        v12 = v8[5];
        v13 = *((_DWORD *)v7 + 1);
      }
      else
      {
        if (v11 != 4)
        {
          if (v11 != 5 || v7[30] != *((_QWORD *)v8 + 50))
            goto LABEL_16;
          goto LABEL_13;
        }
        v12 = *((_DWORD *)v7 + 60);
        v13 = v8[100];
      }
      if (v12 != v13)
        goto LABEL_16;
LABEL_13:
      if ((v9 & 0x1000) != 0)
      {
        v51 = v7;
        if (*((_BYTE *)v7 + 220) || *((_DWORD *)v7 + 52) != 3)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
          {
            v30 = VRTraceErrorLogLevelToCSTR();
            v31 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              v32 = *((unsigned __int8 *)v7 + 220);
              v33 = *((_DWORD *)v7 + 52) != 3;
              *(_DWORD *)buf = 136316162;
              v53 = v30;
              v54 = 2080;
              v55 = "VTP_PassHsk";
              v56 = 1024;
              v57 = 3867;
              v58 = 1024;
              v59 = v32;
              v60 = 1024;
              v61 = v33;
              _os_log_impl(&dword_1D8A54000, v31, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VTP_PassHsk bad packet. encrypted? %d type_check %d", buf, 0x28u);
            }
          }
        }
        else
        {
          DTLS_UpdateHandshake(*(_QWORD *)(a1 + 8 * *v8 + 13432), v7[69], *((int *)v7 + 136), *((_DWORD *)v7 + 53));
        }
        v34 = (void **)&v51;
        goto LABEL_92;
      }
      if ((*(_DWORD *)v7 & 0x301F0) == 0 || v10 == 1)
      {
        VTP_PassPkt(a1, (uint64_t)v8, (int *)v7);
        ++v6[3];
        goto LABEL_106;
      }
LABEL_16:
      if ((*(_DWORD *)v7 & 0x30000) != 0)
      {
        v14 = v8[14];
        if (v14)
        {
          if (v14 == *((_DWORD *)v7 + 54))
          {
            VTP_PassPkt(a1, (uint64_t)v8, (int *)v7);
            if ((*(_DWORD *)v50 & 0x10000) != 0 || (*(_DWORD *)v50 & 0x20000) != 0 && v50[426])
              ++v6[2];
            goto LABEL_106;
          }
        }
      }
      if ((v9 & 0x100) != 0 && *((_DWORD *)v7 + 50) == v8[13])
      {
        VTP_PassPkt(a1, (uint64_t)v8, (int *)v7);
        ++v6[1];
        goto LABEL_106;
      }
      if ((*(_DWORD *)v7 & 0xC0) != 0 && *((_BYTE *)v8 + 27) && v8[12] == *((_DWORD *)v7 + 49))
      {
        VTP_PassPkt(a1, (uint64_t)v8, (int *)v7);
        ++*v6;
        goto LABEL_106;
      }
      if ((*(_DWORD *)v7 & 0xF0) != 0)
      {
        if (*((_BYTE *)v8 + 26))
        {
          v15 = v8[11];
          if ((!v15 || v15 == *((_DWORD *)v7 + 48)) && (!*((_BYTE *)v7 + 376) || v8[14] == *((_DWORD *)v7 + 54)))
            break;
        }
      }
LABEL_49:
      v8 = (int *)*((_QWORD *)v8 + 44);
      if (!v8)
        goto LABEL_50;
    }
    if (v9 != 48)
      goto LABEL_52;
    v16 = (int *)*((_QWORD *)v8 + 4);
    if (!v16)
      goto LABEL_48;
    v17 = *(unsigned __int8 *)(v7[69] + 1);
    if ((v17 & 0x7D) == 0x7C)
      goto LABEL_51;
    v18 = v8[10];
    if (*(unsigned __int8 *)(v7[69] + 1) > 0xEDu)
    {
      if (v17 == 238 || v17 == 253)
        goto LABEL_51;
    }
    else if (v17 == 110 || v17 == 125)
    {
      goto LABEL_51;
    }
    if ((int)v18 < 1)
    {
LABEL_48:
      if (!v15)
        goto LABEL_49;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v35 = VRTraceErrorLogLevelToCSTR();
        v36 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v46 = *(unsigned __int8 *)(*((_QWORD *)v50 + 69) + 1);
          v47 = v8[11];
          v48 = *v8;
          *(_DWORD *)buf = 136316418;
          v53 = v35;
          v54 = 2080;
          v55 = "VTP_DemuxPacketsToVFDList";
          v56 = 1024;
          v57 = 3976;
          v58 = 1024;
          v59 = v46;
          v60 = 1024;
          v61 = v47;
          v62 = 1024;
          LODWORD(v63) = v48;
          _os_log_error_impl(&dword_1D8A54000, v36, OS_LOG_TYPE_ERROR, " [%s] %s:%d VTP received message with mismatched payload=%02X for ssrc=%04X on vfd=%d", buf, 0x2Eu);
        }
      }
      v34 = (void **)&v50;
LABEL_92:
      _VTP_ReleasePacket(a1, v34);
      goto LABEL_106;
    }
    v19 = v17 & 0x7F;
    while (1)
    {
      v20 = *v16++;
      if (v20 == v19)
        break;
      if (!--v18)
        goto LABEL_48;
    }
LABEL_51:
    LOBYTE(v9) = 48;
    *(_DWORD *)v7 = 48;
LABEL_52:
    v21 = v9 & 0x30;
    if (*v49)
      v22 = v21 == 0;
    else
      v22 = 1;
    if (!v22)
    {
      v23 = v7[69];
      v24 = *(_BYTE *)(v23 + 1);
      v25 = 16;
      if ((v24 & 0x7E) != 0x70)
      {
        v26 = v24 & 0x7F;
        if (v26 != 101
          && v26 >= 0x18
          && v26 != 119
          && (v26 - 97) >= 2u
          && (v26 - 121) >= 2u
          && v26 != 111
          && (v24 & 0x7C) != 0x68
          && v26 != 108)
        {
          v25 = 32;
          if ((v26 - 109) >= 2u
            && (v24 & 0x7E) != 0x7C
            && v26 != 100
            && v26 != 126
            && v26 != 123
            && (v26 - 24) >= 0xBu)
          {
            v29 = v24 + 64;
            if (v29 > 0xEu)
              v25 = 0;
            else
              v25 = dword_1D910D614[(char)v29];
          }
        }
      }
      v37 = VTP_NotifyAFRCRxEstimate(*((_QWORD *)v8 + 45), v25, v23, *((_DWORD *)v7 + 136), *((unsigned __int8 *)v7 + 223), *((double *)v7 + 23));
      if ((v37 & 0xFFFFFFFD) != 0)
      {
        v38 = v37;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          v39 = VRTraceErrorLogLevelToCSTR();
          v40 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v41 = *v8;
            v42 = *((_QWORD *)v8 + 45);
            v43 = *(_DWORD *)v7;
            v44 = v7[68];
            *(_DWORD *)buf = 136317186;
            v53 = v39;
            v54 = 2080;
            v55 = "VTP_BandwidthEstimationWithMediaPacket";
            v56 = 1024;
            v57 = 3884;
            v58 = 1024;
            v59 = v38;
            v60 = 1024;
            v61 = v41;
            v62 = 2048;
            v63 = v42;
            v64 = 1024;
            v65 = v25;
            v66 = 1024;
            v67 = v43;
            v68 = 1024;
            v69 = v44;
            _os_log_impl(&dword_1D8A54000, v40, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d notify AFRC failed (%08X): VFD %d AFRC handle %p  packet type %d/%d packet length: %d", buf, 0x44u);
          }
        }
      }
    }
    v45 = (int *)v50;
    if (!v8[11])
      v8[11] = *((_DWORD *)v50 + 48);
    VTP_PassPkt(a1, (uint64_t)v8, v45);
    ++*v6;
LABEL_106:
    v50 = v4;
  }
  while (v4);
}

void _VTP_LogOSChannelInfoToIDSDatagramChannel(void *a1)
{
  if (a1)
  {
    objc_msgSend(a1, "osChannelInfoLog");
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VTP_LogOSChannelInfoToIDSDatagramChannel_cold_1();
  }
}

char *_VTP_InterfaceIndexToNameCallback(uint64_t a1, unsigned int a2, char *a3)
{
  VTP_IFIndexToName(a1, a2, a3);
  return a3;
}

uint64_t VTP_SetConnectionFlagsForPacket(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  pthread_rwlock_t *v8;
  CFIndex Count;
  size_t v10;
  unint64_t v11;
  const void **v12;
  void *v13;
  _QWORD *v14;
  uint64_t v15;
  const void *v16;
  uint64_t result;
  _BYTE v18[15];
  char v19;
  void *values[2];

  values[1] = *(void **)MEMORY[0x1E0C80C00];
  v19 = 0;
  *(_DWORD *)(a3 + 224) = -1;
  v8 = (pthread_rwlock_t *)(a1 + 21640);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 21640));
  Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 21840));
  v10 = 8 * Count;
  v11 = (8 * Count + 15) & 0xFFFFFFFFFFFFFFF0;
  v12 = (const void **)&v18[-v11];
  if (MEMORY[0x1E0C80A78](Count))
  {
    v13 = memset(&v18[-v11], 170, v10);
    MEMORY[0x1E0C80A78](v13);
    v14 = &v18[-v11];
    memset(v14, 170, v10);
    CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 21840), v12, (const void **)v14);
    if (Count >= 1)
    {
      while (1)
      {
        v15 = VCConnectionManager_CopyConnection(*v14, (uint64_t)a4, (uint64_t)&v19);
        if (v15)
          break;
        ++v12;
        ++v14;
        if (!--Count)
          goto LABEL_8;
      }
      v16 = (const void *)v15;
      *(_DWORD *)(a3 + 224) = v19 == 0;
      *(_DWORD *)(a3 + 228) = VCConnection_ConnectionID(v15);
      CFNumberGetValue((CFNumberRef)*v12, kCFNumberIntType, (void *)(a3 + 216));
      *(_BYTE *)(a3 + 223) = VCConnection_IsIPv6((uint64_t)v16);
      *(_BYTE *)(a3 + 221) = VCConnection_IsRelay((uint64_t)v16);
      CFRelease(v16);
    }
  }
  else
  {
    CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 21840), (const void **)&v18[-v11], (const void **)values);
  }
LABEL_8:
  result = pthread_rwlock_unlock(v8);
  if (*(_DWORD *)(a3 + 224) == -1)
  {
    if (a2)
    {
      result = VCSDInfoIsPacketFromKnownRemote(a2 + 392, a4);
      if ((result & 1) == 0)
        return result;
    }
    else if ((*a4 & 0xFFFFFFFE) != 4)
    {
      return result;
    }
    *(_DWORD *)(a3 + 224) = 0;
  }
  return result;
}

uint64_t VTP_ProcessPacketType(uint64_t a1, _DWORD *a2, int a3, uint64_t a4)
{
  unsigned int *v5;
  unint64_t v6;
  const __CFString *v8;
  int v9;
  int v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int *v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  int v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  int v21;
  int v22;
  _BYTE *v23;
  int v24;
  uint64_t v26;
  NSObject *v27;
  NSObject *v28;
  unsigned int v30;
  unsigned int v31;
  unsigned int v32;
  unint64_t v33;
  int v34;
  uint64_t v35;
  NSObject *v36;
  const char *v37;
  uint64_t v38;
  NSObject *v39;
  int v40;
  const char *v41;
  NSObject *v42;
  CFIndex Length;
  uint64_t v46;
  unsigned int v47;
  uint64_t v48;
  NSObject *v49;
  unsigned int *v50;
  uint64_t v51;
  NSObject *v52;
  NSObject *v53;
  uint64_t v54;
  NSObject *v55;
  int ErrorLogLevelForModule;
  uint64_t v57;
  NSObject *v58;
  uint64_t v59;
  NSObject *v60;
  uint64_t v61;
  NSObject *v62;
  uint32_t v63;
  uint64_t v64;
  uint64_t v65;
  NSObject *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  unsigned int v70;
  unsigned int v71;
  int dataLength;
  int dataLength_4;
  uint64_t v75;
  __int16 v76;
  const char *v77;
  __int16 v78;
  int v79;
  __int16 v80;
  _BYTE v81[10];
  uint64_t v82;
  uint64_t v83;

  v83 = *MEMORY[0x1E0C80C00];
  v5 = *(unsigned int **)(a4 + 552);
  v6 = *(_QWORD *)(a4 + 544);
  dataLength = v6;
  if (!(_DWORD)v6)
  {
    v12 = 0;
    *(_DWORD *)a4 = 0;
    return v12;
  }
  if (!a2 || *a2 == -1)
    v8 = 0;
  else
    v8 = *(const __CFString **)(a1 + 8 * (*a2 - 100) + 6840);
  v9 = *(char *)v5;
  if (v9 < 0)
  {
    v17 = 0;
    if (v8)
    {
      v18 = v6;
      LOBYTE(v19) = 0;
      v20 = 0;
      if ((v9 & 0xC0) != 0x80)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VTP_ProcessPacketType_cold_8();
        }
        goto LABEL_45;
      }
      goto LABEL_30;
    }
LABEL_29:
    v18 = v6;
    LOBYTE(v19) = 0;
    v20 = 0;
    goto LABEL_30;
  }
  v10 = v6 - 4;
  if ((int)v6 >= 4 && (*(_WORD *)v5 & 0xC0) == 0x40)
    v11 = 4 * (v10 == bswap32(*((unsigned __int16 *)v5 + 1)) >> 16);
  else
    v11 = 0;
  v13 = &v5[v11 / 4];
  v14 = crc32(0, 0, 0);
  if (crc32(v14, (const Bytef *)v13, v6 - v11) != 558161692)
  {
    v17 = 0;
    if (v8)
    {
      v18 = v6;
      LOBYTE(v19) = 0;
      v20 = 0;
      if (v11)
      {
        if ((*(_BYTE *)v13 & 0xC0) != 0x80)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VTP_ProcessPacketType_cold_7();
          }
          goto LABEL_45;
        }
        dataLength = v6 - v11;
        memmove(v5, &v5[v11 / 4], (int)(v6 - v11));
        v17 = 0;
        LOBYTE(v19) = 0;
        v20 = 0;
        v18 = v6 - v11;
      }
LABEL_30:
      v70 = v20;
      if (v18 >= 4 && *v5 == -272716322)
      {
        *(_DWORD *)(a4 + 200) = bswap32(v5[2]);
        v21 = 256;
      }
      else
      {
        ProcessRelayData((unsigned __int16 *)v5, &dataLength);
        v22 = dataLength;
        v23 = memchr(v5, 10, dataLength);
        if (v23 && strnstr((const char *)v5, "SIP/", v23 - (_BYTE *)v5))
        {
          v21 = 2;
        }
        else
        {
          v24 = *(unsigned __int8 *)v5 >> 6;
          if (v24 == 2)
          {
            if ((*((_BYTE *)v5 + 1) & 0xFE) != 0xC0 && (*((_BYTE *)v5 + 1) + 56) >= 7u)
              v21 = 48;
            else
              v21 = 192;
          }
          else if (v24 == 1)
          {
            v21 = 0x10000;
          }
          else
          {
            if (v24)
            {
              v12 = 2148991010;
              if ((int)VRTraceGetErrorLogLevelForModule() < 5)
                return v12;
              v38 = VRTraceErrorLogLevelToCSTR();
              v39 = *MEMORY[0x1E0CF2758];
              if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                return v12;
              v40 = *((unsigned __int8 *)v5 + 1);
              dataLength_4 = 136316162;
              v75 = v38;
              v76 = 2080;
              v77 = "VTP_ProcessPacketType";
              v78 = 1024;
              v79 = 5990;
              v80 = 1024;
              *(_DWORD *)v81 = 5990;
              *(_WORD *)&v81[4] = 1024;
              *(_DWORD *)&v81[6] = v40;
              v41 = " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VTP/VTra"
                    "nsport.m:%d: VTP_RecvPkt recv bad message=0x%04X";
              v42 = v39;
              goto LABEL_85;
            }
            if (v22 == 16)
              v21 = 4;
            else
              v21 = 8;
          }
        }
      }
LABEL_55:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v26 = VRTraceErrorLogLevelToCSTR();
        v27 = *MEMORY[0x1E0CF2758];
        v28 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
          {
            dataLength_4 = 136315906;
            v75 = v26;
            v76 = 2080;
            v77 = "VTP_ProcessPacketType";
            v78 = 1024;
            v79 = 5994;
            v80 = 1024;
            *(_DWORD *)v81 = v21;
            _os_log_impl(&dword_1D8A54000, v27, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d received packet with type=%d", (uint8_t *)&dataLength_4, 0x22u);
          }
        }
        else if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
        {
          VTP_ProcessPacketType_cold_5();
        }
      }
      if (dataLength != (_DWORD)v6 && (_VTP_ShrinkPacket(a1, dataLength, a4) & 0x80000000) != 0)
        return 2148990980;
      *(_DWORD *)a4 = v21;
      *(_DWORD *)(a4 + 4) = a3;
      *(_DWORD *)(a4 + 208) = v17;
      *(_DWORD *)(a4 + 212) = v70;
      *(_BYTE *)(a4 + 220) = v19;
      *(_DWORD *)(a4 + 372) = v21;
      if ((v21 & 0x30) != 0)
      {
        *(_DWORD *)(a4 + 192) = bswap32(v5[2]);
        kdebug_trace();
        return 0;
      }
      if ((v21 & 0xC0) == 0)
        return 0;
      *(_DWORD *)a4 = v21 | 0x40;
      *(_DWORD *)(a4 + 192) = bswap32(v5[1]);
      if (v6 <= 3)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() < 5)
          return 0;
        v61 = VRTraceErrorLogLevelToCSTR();
        v36 = *MEMORY[0x1E0CF2758];
        v12 = 0;
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          return v12;
        dataLength_4 = 136315906;
        v75 = v61;
        v76 = 2080;
        v77 = "_VTP_SetRTCPFBMediaSenderSSRC";
        v78 = 1024;
        v79 = 3486;
        v80 = 2048;
        *(_QWORD *)v81 = v6;
        v37 = " [%s] %s:%d RTCP packet too small. bufferSize=%zu";
        goto LABEL_153;
      }
      v30 = *(unsigned __int16 *)v5;
      if ((v30 >> 8) - 205 > 1)
        return 0;
      v31 = *((unsigned __int16 *)v5 + 1);
      v32 = __rev16(v31);
      v33 = 4 * v32;
      if (v33 > v6)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() < 5)
          return 0;
        v64 = VRTraceErrorLogLevelToCSTR();
        v49 = *MEMORY[0x1E0CF2758];
        v12 = 0;
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          return v12;
        dataLength_4 = 136316162;
        v75 = v64;
        v76 = 2080;
        v77 = "_VTP_SetRTCPFBMediaSenderSSRC";
        v78 = 1024;
        v79 = 3490;
        v80 = 2048;
        *(_QWORD *)v81 = v6;
        *(_WORD *)&v81[8] = 2048;
        v82 = v33;
        v37 = " [%s] %s:%d RTCP packet too small. bufferSize=%zu rtcpPacketLength=%zu";
      }
      else
      {
        if (!*(_BYTE *)(a4 + 376))
          return 0;
        if (!*(_BYTE *)(a4 + 441))
        {
          if ((int)VRTraceGetErrorLogLevelForModule() < 5)
            return 0;
          v65 = VRTraceErrorLogLevelToCSTR();
          v66 = *MEMORY[0x1E0CF2758];
          v12 = 0;
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            return v12;
          dataLength_4 = 136315650;
          v75 = v65;
          v76 = 2080;
          v77 = "_VTP_SetRTCPFBMediaSenderSSRC";
          v78 = 1024;
          v79 = 3493;
          v37 = " [%s] %s:%d Packet is not Hop-by-hop encrypted";
          v62 = v66;
          v63 = 28;
LABEL_161:
          _os_log_impl(&dword_1D8A54000, v62, OS_LOG_TYPE_DEFAULT, v37, (uint8_t *)&dataLength_4, v63);
          return 0;
        }
        if ((v30 & 0xFF00) != 0xCE00)
          goto LABEL_137;
        v34 = v30 & 0x1F;
        if (v34 != 15)
        {
          if (v34 == 4)
          {
            if (v31 != 1024)
            {
              if ((int)VRTraceGetErrorLogLevelForModule() < 5)
                return 0;
              v68 = VRTraceErrorLogLevelToCSTR();
              v36 = *MEMORY[0x1E0CF2758];
              v12 = 0;
              if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                return v12;
              dataLength_4 = 136315906;
              v75 = v68;
              v76 = 2080;
              v77 = "_VTP_SetRTCPFBMediaSenderSSRC";
              v78 = 1024;
              v79 = 3500;
              v80 = 2048;
              *(_QWORD *)v81 = v33;
              v37 = " [%s] %s:%d rtcpPacketLength=%zu not equal to sizeof(RTCP_PSFB_FIR)";
              goto LABEL_153;
            }
            v50 = v5 + 3;
            goto LABEL_136;
          }
          if (v34 != 1)
            goto LABEL_137;
          if (v31 != 512)
          {
            if ((int)VRTraceGetErrorLogLevelForModule() < 5)
              return 0;
            v35 = VRTraceErrorLogLevelToCSTR();
            v36 = *MEMORY[0x1E0CF2758];
            v12 = 0;
            if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              return v12;
            dataLength_4 = 136315906;
            v75 = v35;
            v76 = 2080;
            v77 = "_VTP_SetRTCPFBMediaSenderSSRC";
            v78 = 1024;
            v79 = 3497;
            v80 = 2048;
            *(_QWORD *)v81 = v33;
            v37 = " [%s] %s:%d rtcpPacketLength=%zu not equal to sizeof(RTCP_PSFB_PLI)";
            goto LABEL_153;
          }
LABEL_135:
          v50 = v5 + 2;
LABEL_136:
          *(_DWORD *)(a4 + 196) = bswap32(*v50);
LABEL_137:
          if ((*(_WORD *)v5 & 0xFF1F) != 0xCD01)
            return 0;
          if (v32 < 0x103)
          {
            v12 = 0;
            *(_DWORD *)(a4 + 196) = bswap32(v5[2]);
            return v12;
          }
          if ((int)VRTraceGetErrorLogLevelForModule() < 5)
            return 0;
          v67 = VRTraceErrorLogLevelToCSTR();
          v36 = *MEMORY[0x1E0CF2758];
          v12 = 0;
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            return v12;
          dataLength_4 = 136315906;
          v75 = v67;
          v76 = 2080;
          v77 = "_VTP_SetRTCPFBMediaSenderSSRC";
          v78 = 1024;
          v79 = 3512;
          v80 = 2048;
          *(_QWORD *)v81 = v33;
          v37 = " [%s] %s:%d rtcpPacketLength=%zu is greater than sizeof(RTCP_FMT_RTPFB_GNACK)";
LABEL_153:
          v62 = v36;
          v63 = 38;
          goto LABEL_161;
        }
        v47 = v5[3];
        if (v47 == 83886080)
        {
          if (v31 == 1024)
            goto LABEL_135;
          if ((int)VRTraceGetErrorLogLevelForModule() < 5)
            return 0;
          v69 = VRTraceErrorLogLevelToCSTR();
          v49 = *MEMORY[0x1E0CF2758];
          v12 = 0;
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            return v12;
          dataLength_4 = 136316162;
          v75 = v69;
          v76 = 2080;
          v77 = "_VTP_SetRTCPFBMediaSenderSSRC";
          v78 = 1024;
          v79 = 3506;
          v80 = 2048;
          *(_QWORD *)v81 = v33;
          *(_WORD *)&v81[8] = 2048;
          v82 = 16;
          v37 = " [%s] %s:%d rtcpPacketLength=%zuBytes not equal to sizeof(RTCP_PSFB_LTRACK)=%zuBytes";
        }
        else
        {
          if (v47 != 100663296)
            goto LABEL_137;
          if (v31 == 1280)
            goto LABEL_135;
          if ((int)VRTraceGetErrorLogLevelForModule() < 5)
            return 0;
          v48 = VRTraceErrorLogLevelToCSTR();
          v49 = *MEMORY[0x1E0CF2758];
          v12 = 0;
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            return v12;
          dataLength_4 = 136316162;
          v75 = v48;
          v76 = 2080;
          v77 = "_VTP_SetRTCPFBMediaSenderSSRC";
          v78 = 1024;
          v79 = 3503;
          v80 = 2048;
          *(_QWORD *)v81 = v33;
          *(_WORD *)&v81[8] = 2048;
          v82 = 20;
          v37 = " [%s] %s:%d rtcpPacketLength=%zuBytes not equal to sizeof(RTCP_PSFB_LOSSFB)=%zuBytes";
        }
      }
      v62 = v49;
      v63 = 48;
      goto LABEL_161;
    }
    goto LABEL_29;
  }
  v15 = v10 - v11;
  if ((int)(v10 - v11) >= 6)
  {
    v16 = *(unsigned __int8 *)v13;
    if ((v16 & 0xD0) == 0)
    {
      v17 = *((unsigned __int8 *)v13 + 1);
      if (v15 > 9 || (v16 & 8) == 0)
      {
        v71 = *(unsigned int *)((char *)v13 + 2);
        if ((v16 & 8) != 0)
        {
          if (!IsValidOFTMAC(v8, (uint64_t)&v5[v11 / 4], v15, v17))
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                VTP_ProcessPacketType_cold_6();
            }
            goto LABEL_45;
          }
        }
        else if (((v17 & 0xFE) == 4 || (v17 & 0xFFFFFFFD) == 1) && v8 != 0)
        {
          Length = CFStringGetLength(v8);
          if (CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) >= 1)
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                VTP_ProcessPacketType_cold_3();
            }
            goto LABEL_45;
          }
        }
        LODWORD(v46) = v11 + 6;
        if ((v16 & 8) != 0)
          v46 = v11 | 0xA;
        else
          v46 = v46;
        v18 = v10 - v46;
        dataLength = v10 - v46;
        memmove(v5, (char *)v5 + v46, v10 - (int)v46);
        v20 = bswap32(v71);
        v19 = v16 >> 5;
        switch(v17)
        {
          case 0:
            goto LABEL_30;
          case 1:
            if (v16 <= 0x1F)
            {
              v70 = v20;
              LOBYTE(v19) = 0;
              *(_BYTE *)(a4 + 221) = ProcessRelayData((unsigned __int16 *)v5, &dataLength);
              v21 = 1024;
              v17 = 1;
              goto LABEL_55;
            }
            v17 = 1;
            LOBYTE(v19) = 1;
            goto LABEL_30;
          case 2:
            v70 = v20;
            *(_BYTE *)(a4 + 221) = ProcessRelayData((unsigned __int16 *)v5, &dataLength);
            v21 = 2048;
            v17 = 2;
            goto LABEL_55;
          case 3:
            if (v16 <= 0x1F)
            {
              v70 = v20;
              LOBYTE(v19) = 0;
              *(_BYTE *)(a4 + 221) = ProcessRelayData((unsigned __int16 *)v5, &dataLength);
              v21 = 4096;
              v17 = 3;
              goto LABEL_55;
            }
            LOBYTE(v19) = 1;
            v17 = 3;
            goto LABEL_30;
          case 4:
            if (v16 < 0x20)
            {
              LOBYTE(v19) = 0;
              v17 = 4;
              goto LABEL_30;
            }
            v70 = v20;
            *(_BYTE *)(a4 + 221) = ProcessRelayData((unsigned __int16 *)v5, &dataLength);
            v21 = 0x2000;
            v17 = 4;
            goto LABEL_147;
          case 5:
            v70 = v20;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v54 = VRTraceErrorLogLevelToCSTR();
              v55 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                dataLength_4 = 136315650;
                v75 = v54;
                v76 = 2080;
                v77 = "VTP_ProcessPacketType";
                v78 = 1024;
                v79 = 5906;
                _os_log_impl(&dword_1D8A54000, v55, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d ++++++++++++++++ ARPL packet detected in VTP_RecvPkt(...) ++++++++++++++++", (uint8_t *)&dataLength_4, 0x1Cu);
              }
            }
            ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
            if (v16 < 0x20)
            {
              if (ErrorLogLevelForModule >= 7)
              {
                v57 = VRTraceErrorLogLevelToCSTR();
                v58 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                {
                  dataLength_4 = 136315650;
                  v75 = v57;
                  v76 = 2080;
                  v77 = "VTP_ProcessPacketType";
                  v78 = 1024;
                  v79 = 5913;
                  _os_log_impl(&dword_1D8A54000, v58, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d >>>>> ARPL packetin VTP_RecvPkt(...) is UNENCRYPTED <<<<<", (uint8_t *)&dataLength_4, 0x1Cu);
                }
              }
              LOBYTE(v19) = 0;
              v17 = 5;
              v20 = v70;
              goto LABEL_30;
            }
            if (ErrorLogLevelForModule >= 7)
            {
              v59 = VRTraceErrorLogLevelToCSTR();
              v60 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                dataLength_4 = 136315650;
                v75 = v59;
                v76 = 2080;
                v77 = "VTP_ProcessPacketType";
                v78 = 1024;
                v79 = 5908;
                _os_log_impl(&dword_1D8A54000, v60, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d >>>>> ARPL packetin VTP_RecvPkt(...) is encrypted <<<<<", (uint8_t *)&dataLength_4, 0x1Cu);
              }
            }
            *(_BYTE *)(a4 + 221) = ProcessRelayData((unsigned __int16 *)v5, &dataLength);
            v21 = 0x2000;
            v17 = 5;
LABEL_147:
            LOBYTE(v19) = 1;
            goto LABEL_55;
          case 6:
            v70 = v20;
            *(_BYTE *)(a4 + 221) = ProcessRelayData((unsigned __int16 *)v5, &dataLength);
            v21 = 0x8000;
            v17 = 6;
            goto LABEL_55;
          default:
            v12 = 2148991010;
            if ((int)VRTraceGetErrorLogLevelForModule() < 8)
              return v12;
            v51 = VRTraceErrorLogLevelToCSTR();
            v52 = *MEMORY[0x1E0CF2758];
            v53 = *MEMORY[0x1E0CF2758];
            if (!*MEMORY[0x1E0CF2748])
            {
              if (os_log_type_enabled(v53, OS_LOG_TYPE_DEBUG))
                VTP_ProcessPacketType_cold_4();
              return v12;
            }
            if (!os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
              return v12;
            dataLength_4 = 136316162;
            v75 = v51;
            v76 = 2080;
            v77 = "VTP_ProcessPacketType";
            v78 = 1024;
            v79 = 5938;
            v80 = 1024;
            *(_DWORD *)v81 = 5938;
            *(_WORD *)&v81[4] = 1024;
            *(_DWORD *)&v81[6] = v17;
            v41 = " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VTP/VTrans"
                  "port.m:%d: unrecognized openfacetime type=%d";
            v42 = v52;
            break;
        }
LABEL_85:
        _os_log_impl(&dword_1D8A54000, v42, OS_LOG_TYPE_DEFAULT, v41, (uint8_t *)&dataLength_4, 0x28u);
        return v12;
      }
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VTP_ProcessPacketType_cold_2();
  }
LABEL_45:
  v12 = 2148991010;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VTP_ProcessPacketType_cold_1();
  }
  return v12;
}

int *VTP_UpdateReceivedBytes(int a1, uint64_t a2, int a3, int a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8)
{
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  const void *v22;
  int *result;

  v16 = CheckInHandleDebug();
  if (v16)
  {
    v17 = v16;
    if (a4)
      v18 = 48;
    else
      v18 = 28;
    v19 = v18 + (int)a2;
    v20 = (unint64_t *)(v16 + 8);
    do
      v21 = __ldxr(v20);
    while (__stxr(v21 + v19, v20));
    if (a1)
    {
      pthread_rwlock_rdlock((pthread_rwlock_t *)(v16 + 21640));
      v22 = VTP_getConnectionManagerForCallID(v17, a1);
      VCConnectionManager_UpdateReceivedPacketsAndBytes((uint64_t)v22, a5, a2, a3, a6, a7, a8);
      pthread_rwlock_unlock((pthread_rwlock_t *)(v17 + 21640));
    }
    return (int *)CheckOutHandleDebug();
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_UpdateReceivedBytes_cold_1();
    }
    result = __error();
    *result = 13;
  }
  return result;
}

uint64_t _VTP_ShrinkPacket(uint64_t a1, size_t dataLength, uint64_t a3)
{
  uint64_t v3;
  size_t v5;
  const void *v6;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  uint64_t v11;
  NSObject *v12;
  char *dataPointerOut;
  size_t totalLengthOut;
  CMBlockBufferRef blockBufferOut;
  uint8_t buf[4];
  uint64_t v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  totalLengthOut = 0;
  blockBufferOut = 0;
  v3 = 2148990977;
  dataPointerOut = 0;
  if (!a1)
    return v3;
  if (!a3)
    return v3;
  v5 = *(_QWORD *)(a3 + 544);
  if (v5 < dataLength)
    return v3;
  if (v5 == dataLength)
    return 0;
  if (CMBlockBufferCreateWithBufferReference(*(CFAllocatorRef *)(a1 + 22016), *(CMBlockBufferRef *)(a3 + 536), 0, dataLength, 0, &blockBufferOut))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v8 = VRTraceErrorLogLevelToCSTR();
      v9 = *MEMORY[0x1E0CF2758];
      v10 = *MEMORY[0x1E0CF2758];
      if (!*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
          _VTP_ShrinkPacket_cold_2();
        goto LABEL_25;
      }
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        v17 = v8;
        v18 = 2080;
        v19 = "_VTP_ShrinkPacket";
        v20 = 1024;
        v21 = 771;
LABEL_20:
        _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Failed to retrieve blockBuffer pointer and size", buf, 0x1Cu);
      }
    }
  }
  else
  {
    if (!CMBlockBufferGetDataPointer(blockBufferOut, 0, 0, &totalLengthOut, &dataPointerOut))
    {
      v6 = *(const void **)(a3 + 536);
      if (v6)
        CFRelease(v6);
      v3 = 0;
      *(_QWORD *)(a3 + 536) = blockBufferOut;
      *(_QWORD *)(a3 + 552) = dataPointerOut;
      *(_QWORD *)(a3 + 544) = totalLengthOut;
      return v3;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v11 = VRTraceErrorLogLevelToCSTR();
      v9 = *MEMORY[0x1E0CF2758];
      v12 = *MEMORY[0x1E0CF2758];
      if (!*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
          _VTP_ShrinkPacket_cold_1();
        goto LABEL_25;
      }
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        v17 = v11;
        v18 = 2080;
        v19 = "_VTP_ShrinkPacket";
        v20 = 1024;
        v21 = 774;
        goto LABEL_20;
      }
    }
  }
LABEL_25:
  v3 = 2148990980;
  if (blockBufferOut)
    CFRelease(blockBufferOut);
  return v3;
}

uint64_t _VTP_AllocatePacketWithBufferFreeCallback(uint64_t a1, void *a2, size_t a3, void (__cdecl *a4)(void *, void *, size_t), void *a5, CMBlockBufferRef **a6)
{
  CMBlockBufferRef *v12;
  CMBlockBufferRef *v13;
  uint64_t result;
  void *(__cdecl *v15)(void *, size_t);
  NSObject *v16;
  NSObject *v17;
  CMBlockBufferRef *v18;
  CMBlockBufferCustomBlockSource customBlockSource;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v12 = (CMBlockBufferRef *)VCMemoryPool_Alloc(*(OSQueueHead **)(a1 + 5872));
  v18 = v12;
  if (!v12)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v15 = (void *(__cdecl *)(void *, size_t))VRTraceErrorLogLevelToCSTR();
      v16 = *MEMORY[0x1E0CF2758];
      v17 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          customBlockSource.version = 136315650;
          customBlockSource.AllocateBlock = v15;
          LOWORD(customBlockSource.FreeBlock) = 2080;
          *(void (__cdecl **)(void *, void *, size_t))((char *)&customBlockSource.FreeBlock + 2) = (void (__cdecl *)(void *, void *, size_t))"_VTP_AllocatePacketWithBufferFreeCallback";
          WORD1(customBlockSource.refCon) = 1024;
          HIDWORD(customBlockSource.refCon) = 710;
          _os_log_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Failed to allocate VTP packet", (uint8_t *)&customBlockSource, 0x1Cu);
        }
      }
      else if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        _VTP_AllocatePacketWithBufferFreeCallback_cold_1();
      }
    }
    goto LABEL_30;
  }
  v13 = v12;
  if (a3)
  {
    if (a4)
    {
      customBlockSource.version = 0;
      customBlockSource.AllocateBlock = 0;
      customBlockSource.FreeBlock = a4;
      customBlockSource.refCon = a5;
      if (CMBlockBufferCreateWithMemoryBlock(*(CFAllocatorRef *)(a1 + 22016), a2, a3, 0, &customBlockSource, 0, a3, 1u, v12 + 67))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VTP_AllocatePacketWithBufferFreeCallback_cold_5();
        }
LABEL_30:
        _VTP_ReleasePacket(a1, (void **)&v18);
        v13 = 0;
        result = 2148990980;
        goto LABEL_14;
      }
    }
    else
    {
      if (VCBlockBufferUtlities_Create(*(const __CFAllocator **)(a1 + 22016), 0, a3, *(const __CFAllocator **)(a1 + 22024), 0, 0, a3, 1u, v12 + 67))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VTP_AllocatePacketWithBufferFreeCallback_cold_4();
        }
        goto LABEL_30;
      }
      if (a2 && CMBlockBufferReplaceDataBytes(a2, v13[67], 0, a3))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VTP_AllocatePacketWithBufferFreeCallback_cold_3();
        }
        goto LABEL_30;
      }
    }
    if (CMBlockBufferGetDataPointer(v13[67], 0, 0, (size_t *)v13 + 68, (char **)v13 + 69))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VTP_AllocatePacketWithBufferFreeCallback_cold_2();
      }
      goto LABEL_30;
    }
  }
  else
  {
    v12[69] = 0;
    v12[68] = 0;
  }
  result = 0;
  *((_BYTE *)v13 + 516) = 1;
LABEL_14:
  *a6 = v13;
  return result;
}

uint64_t VTP_IFIndexToName(uint64_t a1, unsigned int a2, char *a3)
{
  pthread_mutex_t *v6;
  int *v7;
  uint64_t v8;
  uint64_t v9;
  _OWORD *v10;
  int v11;
  int v12;
  int v13;
  char *v14;
  char *v15;
  uint64_t v16;
  NSObject *v17;
  NSObject *v18;
  uint64_t v19;
  NSObject *v20;
  int v21;
  int v23;
  uint64_t v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  unsigned int v30;
  __int16 v31;
  char *v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v6 = (pthread_mutex_t *)(a1 + 5792);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 5792));
  v7 = (int *)(a1 + 5864);
  v8 = *(unsigned int *)(a1 + 5864);
  if ((int)v8 < 1)
  {
    LODWORD(v9) = 0;
    v11 = -1;
  }
  else
  {
    v9 = 0;
    v10 = (_OWORD *)(*(_QWORD *)(a1 + 5856) + 4);
    v11 = -1;
    while (1)
    {
      v12 = *((_DWORD *)v10 - 1);
      if (v12 == a2)
        break;
      if (v12)
        v13 = -1;
      else
        v13 = v9;
      if (v11 == -1)
        v11 = v13;
      ++v9;
      v10 = (_OWORD *)((char *)v10 + 20);
      if (v8 == v9)
        goto LABEL_14;
    }
    *(_OWORD *)a3 = *v10;
    LODWORD(v8) = *v7;
  }
  if ((_DWORD)v9 == (_DWORD)v8)
  {
LABEL_14:
    if (if_indextoname(a2, a3))
    {
      if (v11 != -1)
      {
        v14 = *(char **)(a1 + 5856);
        goto LABEL_17;
      }
      v11 = *v7;
      v21 = 2 * *v7;
      *v7 = v21;
      if (v21)
      {
        v14 = (char *)malloc_type_realloc(*(void **)(a1 + 5856), 20 * v21, 0x1000040A86A77D5uLL);
        if (v14)
        {
          *(_QWORD *)(a1 + 5856) = v14;
LABEL_17:
          v15 = &v14[20 * v11];
          *(_DWORD *)v15 = a2;
          *(_OWORD *)(v15 + 4) = *(_OWORD *)a3;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            v16 = VRTraceErrorLogLevelToCSTR();
            v17 = *MEMORY[0x1E0CF2758];
            v18 = *MEMORY[0x1E0CF2758];
            if (*MEMORY[0x1E0CF2748])
            {
              if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
              {
                v23 = 136316162;
                v24 = v16;
                v25 = 2080;
                v26 = "VTP_IFIndexToName";
                v27 = 1024;
                v28 = 3630;
                v29 = 1024;
                v30 = a2;
                v31 = 2080;
                v32 = a3;
                _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VTP_IFIndexToName mapping [if_index:%d if_name:%s]\n", (uint8_t *)&v23, 0x2Cu);
              }
            }
            else if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
            {
              v23 = 136316162;
              v24 = v16;
              v25 = 2080;
              v26 = "VTP_IFIndexToName";
              v27 = 1024;
              v28 = 3630;
              v29 = 1024;
              v30 = a2;
              v31 = 2080;
              v32 = a3;
              _os_log_debug_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEBUG, " [%s] %s:%d VTP_IFIndexToName mapping [if_index:%d if_name:%s]\n", (uint8_t *)&v23, 0x2Cu);
            }
          }
          return pthread_mutex_unlock(v6);
        }
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
      {
        VRTraceErrorLogLevelToCSTR();
        if ((VRTraceIsOSFaultDisabled() & 1) != 0)
        {
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VTP_IFIndexToName_cold_2();
        }
        else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_FAULT))
        {
          VTP_IFIndexToName_cold_3();
        }
      }
    }
    else
    {
      __error();
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v19 = VRTraceErrorLogLevelToCSTR();
        v20 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VTP_IFIndexToName_cold_1(v19, a2, v20);
      }
    }
  }
  return pthread_mutex_unlock(v6);
}

uint64_t ProcessRelayData(unsigned __int16 *__dst, int *a2)
{
  int v4;
  int v5;
  uint64_t result;
  unsigned int v7;
  size_t v8;
  uint64_t STUNAttr;
  size_t v10;
  _BYTE __b[1152];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v4 = *a2;
  v5 = *__dst;
  if ((v5 & 0xC0) == 0)
  {
    if (v5 == 1792)
    {
      memset(__b, 170, sizeof(__b));
      if ((ParseSTUNMessage() & 0x80000000) == 0 && GetSTUNAttr())
      {
        STUNAttr = GetSTUNAttr();
        if (STUNAttr)
        {
          v10 = *(unsigned int *)(STUNAttr + 8);
          if ((int)v10 >= 1 && (int)v10 < v4)
          {
            *a2 = v10;
            memcpy(__dst, *(const void **)(STUNAttr + 16), v10);
          }
        }
        FreeSTUNMessage();
        return 1;
      }
      FreeSTUNMessage();
    }
    return 0;
  }
  result = 0;
  if (v4 >= 4 && (v5 & 0xC0) == 0x40)
  {
    v7 = bswap32(__dst[1]);
    if (v4 - 4 == HIWORD(v7))
    {
      v8 = HIWORD(v7);
      *a2 = v8;
      memmove(__dst, __dst + 2, v8);
      return 1;
    }
    return 0;
  }
  return result;
}

uint64_t IsValidOFTMAC(const __CFString *a1, uint64_t a2, int a3, int a4)
{
  CFIndex Length;
  CFIndex MaximumSizeForEncoding;
  size_t v9;
  const char *CStringPtr;
  uint64_t result;
  size_t v12;
  uint64_t v14;
  NSObject *v15;
  _BYTE macOut[22];
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    Length = CFStringGetLength(a1);
    MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
    if (MaximumSizeForEncoding >= 1)
    {
      v9 = MaximumSizeForEncoding;
      CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
      MEMORY[0x1E0C80A78](CStringPtr);
      memset(&macOut[-((v9 + 15) & 0xFFFFFFFFFFFFFFF0)], 170, v9);
      if (CStringPtr
        || (result = CFStringGetCString(a1, &macOut[-((v9 + 15) & 0xFFFFFFFFFFFFFFF0)], v9, 0x8000100u),
            CStringPtr = &macOut[-((v9 + 15) & 0xFFFFFFFFFFFFFFF0)],
            (_DWORD)result))
      {
        memset(macOut, 170, 20);
        v12 = strlen(CStringPtr);
        CCHmac(0, CStringPtr, v12, (const void *)(a2 + 10), a3 - 10, macOut);
        return *(_DWORD *)macOut == *(_DWORD *)(a2 + 6);
      }
      return result;
    }
    return 0;
  }
  if (a4 > 1)
    return 0;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v14 = VRTraceErrorLogLevelToCSTR();
    v15 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)macOut = 136315906;
      *(_QWORD *)&macOut[4] = v14;
      *(_WORD *)&macOut[12] = 2080;
      *(_QWORD *)&macOut[14] = "IsValidOFTMAC";
      v17 = 1024;
      v18 = 3243;
      v19 = 1024;
      v20 = a4;
      _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Skip OFT MAC validation for packet(%d), sessionID not ready.", macOut, 0x22u);
    }
  }
  return 1;
}

uint64_t VTP_PassPkt(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v6;
  int v7;
  unsigned int v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  int v14;
  int v15;
  int *v16;
  unint64_t *v17;
  uint64_t v18;
  NSObject *v19;
  NSObject *v20;
  int v21;
  int v22;
  char *v23;
  uint64_t v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  unint64_t v31;
  int v32;
  pthread_rwlock_t *v34;
  pthread_mutex_t *v35;
  _BYTE v36[104];
  __int128 v37;
  __int128 v38;
  int v39;
  __int128 v40;
  __int128 v41;
  uint64_t v42;
  _BYTE v43[320];
  _BYTE v44[24];
  _BYTE buf[12];
  __int16 v46;
  const char *v47;
  __int16 v48;
  int v49;
  __int16 v50;
  int v51;
  __int16 v52;
  int v53;
  __int16 v54;
  int v55;
  __int16 v56;
  _BYTE *v57;
  __int16 v58;
  int v59;
  uint64_t v60;

  v60 = *MEMORY[0x1E0C80C00];
  v34 = (pthread_rwlock_t *)(a1 + 5584);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 5584));
  v35 = (pthread_mutex_t *)(a2 + 112);
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 112));
  v6 = *(_QWORD *)(a2 + 104);
  if (v6)
  {
    v7 = 0;
    v8 = -1;
    do
    {
      v9 = v6;
      v6 = *(_QWORD *)(v6 + 528);
      ++v7;
      ++v8;
    }
    while (v6);
    *(_QWORD *)(v9 + 528) = a3;
    v10 = v7 - 1;
    if ((v7 - 1) >= 0x32 && ((50 * (v8 / 0x32)) | 1) == v7)
    {
      memset(v36, 0, 96);
      VCUtil_ConvertStreamIDArrayToString((size_t)(a3 + 96), *((unsigned __int8 *)a3 + 408), v36, 0x60uLL);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v11 = VRTraceErrorLogLevelToCSTR();
        v12 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v13 = *((_QWORD *)a3 + 68);
          v14 = *a3;
          v15 = *(_DWORD *)a2;
          *(_DWORD *)buf = 136316930;
          *(_QWORD *)&buf[4] = v11;
          v46 = 2080;
          v47 = "VTP_PassPkt";
          v48 = 1024;
          v49 = 3817;
          v50 = 1024;
          v51 = v10;
          v52 = 1024;
          v53 = v13;
          v54 = 1024;
          v55 = v14;
          v56 = 2080;
          v57 = v36;
          v58 = 1024;
          v59 = v15;
          _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d ###### VTP_PassPkt packet list is growing and not draining!!! count:%d (len=%d type=%04X) streamIDs:%s, vfd:%d ######", buf, 0x3Eu);
        }
      }
    }
  }
  else
  {
    *(_QWORD *)(a2 + 104) = a3;
  }
  pthread_cond_signal((pthread_cond_t *)(a2 + 176));
  pthread_mutex_unlock(v35);
  v16 = *(int **)(a1 + 5784);
  if (v16)
  {
    v17 = (unint64_t *)(a1 + 21960);
    do
    {
      if (*((_BYTE *)v16 + 121))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          v18 = VRTraceErrorLogLevelToCSTR();
          v19 = *MEMORY[0x1E0CF2758];
          v20 = *MEMORY[0x1E0CF2758];
          if (*MEMORY[0x1E0CF2748])
          {
            if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
            {
              v21 = *v16;
              *(_DWORD *)v36 = 136315906;
              *(_QWORD *)&v36[4] = v18;
              *(_WORD *)&v36[12] = 2080;
              *(_QWORD *)&v36[14] = "VTP_PassPkt";
              *(_WORD *)&v36[22] = 1024;
              *(_DWORD *)&v36[24] = 3826;
              *(_WORD *)&v36[28] = 1024;
              *(_DWORD *)&v36[30] = v21;
              _os_log_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d receiving packet on a closed handle! id[%d], ignoring....", v36, 0x22u);
            }
          }
          else if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
          {
            v32 = *v16;
            *(_DWORD *)v36 = 136315906;
            *(_QWORD *)&v36[4] = v18;
            *(_WORD *)&v36[12] = 2080;
            *(_QWORD *)&v36[14] = "VTP_PassPkt";
            *(_WORD *)&v36[22] = 1024;
            *(_DWORD *)&v36[24] = 3826;
            *(_WORD *)&v36[28] = 1024;
            *(_DWORD *)&v36[30] = v32;
            _os_log_debug_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_DEBUG, " [%s] %s:%d receiving packet on a closed handle! id[%d], ignoring....", v36, 0x22u);
          }
        }
      }
      else
      {
        v22 = *(_DWORD *)a2;
        v23 = (char *)*((_QWORD *)v16 + 16);
        if (__darwin_check_fd_set_overflow(*(_DWORD *)a2, v23, 0)
          && ((*(_DWORD *)&v23[((unint64_t)v22 >> 3) & 0x1FFFFFFFFFFFFFFCLL] >> v22) & 1) != 0)
        {
          pthread_mutex_lock((pthread_mutex_t *)(v16 + 2));
          if (*((_QWORD *)v16 + 20))
          {
            pthread_mutex_lock(v35);
            while (1)
            {
              v24 = *(_QWORD *)(a2 + 104);
              *(_QWORD *)buf = v24;
              if (!v24)
                break;
              bzero(v36, 0x210uLL);
              *(_QWORD *)v36 = *(_QWORD *)(v24 + 184);
              memcpy(v43, (const void *)(v24 + 208), sizeof(v43));
              v25 = *(_OWORD *)(v24 + 8);
              v26 = *(_OWORD *)(v24 + 24);
              v42 = *(_QWORD *)(v24 + 40);
              v40 = v25;
              v41 = v26;
              v27 = *(_OWORD *)(v24 + 64);
              *(_OWORD *)&v36[8] = *(_OWORD *)(v24 + 48);
              *(_OWORD *)&v36[24] = v27;
              v28 = *(_OWORD *)(v24 + 128);
              *(_OWORD *)&v36[72] = *(_OWORD *)(v24 + 112);
              *(_OWORD *)&v36[88] = v28;
              v29 = *(_OWORD *)(v24 + 160);
              v37 = *(_OWORD *)(v24 + 144);
              v38 = v29;
              v30 = *(_OWORD *)(v24 + 96);
              *(_OWORD *)&v36[40] = *(_OWORD *)(v24 + 80);
              *(_OWORD *)&v36[56] = v30;
              v39 = *(_DWORD *)(v24 + 176);
              VCBlockBuffer_Copy(v24 + 536, (uint64_t)v44);
              if (*(_BYTE *)(v24 + 223))
                LODWORD(v40) = v40 | 1;
              (*(void (**)(void))(*((_QWORD *)v16 + 20) + 16))();
              *(_QWORD *)(a2 + 104) = *(_QWORD *)(*(_QWORD *)buf + 528);
              VCBlockBuffer_Clear((uint64_t)v44);
              if (**(_DWORD **)buf == 48)
              {
                do
                  v31 = __ldxr(v17);
                while (__stxr(v31 + 1, v17));
              }
              _VTP_ReleasePacket(a1, (void **)buf);
            }
            pthread_mutex_unlock(v35);
          }
          else
          {
            *((_BYTE *)v16 + 120) = 1;
            pthread_cond_signal((pthread_cond_t *)(v16 + 18));
          }
          pthread_mutex_unlock((pthread_mutex_t *)(v16 + 2));
        }
      }
      v16 = (int *)*((_QWORD *)v16 + 19);
    }
    while (v16);
  }
  return pthread_rwlock_unlock(v34);
}

uint64_t VTP_SendOnePacketWithSocket(int a1, int a2, _BYTE *a3, char a4, uint64_t a5, uint64_t a6, int a7, uint64_t a8, int a9)
{
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  socklen_t v19;
  int *v20;
  int v21;
  ssize_t v22;
  __int128 v23;
  int v24;
  unsigned int v25;
  int v26;
  uint64_t v27;
  unint64_t v28;
  int v30;
  msghdr v31;
  _QWORD v32[2];
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  _BYTE v39[136];
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  if (!a3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_SendOnePacketWithSocket_cold_1();
    }
    v20 = __error();
    v21 = 22;
    goto LABEL_13;
  }
  v16 = CheckInHandleDebug();
  if (!v16)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTP_SendOnePacketWithSocket_cold_2();
    }
    v20 = __error();
    v21 = 13;
LABEL_13:
    *v20 = v21;
    return -1;
  }
  v17 = v16;
  *(_QWORD *)&v18 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v31.msg_iov = v18;
  *(_OWORD *)&v31.msg_control = v18;
  *(_OWORD *)&v31.msg_name = v18;
  memset(v39, 0, 128);
  if ((a4 & 1) != 0)
  {
    v19 = 0;
    v31.msg_name = 0;
  }
  else
  {
    if ((*a3 & 1) != 0)
    {
      v30 = 28;
      IPPORTToSA6();
    }
    else
    {
      v30 = 16;
      IPPORTToSA();
    }
    v31.msg_name = v39;
    v19 = v30;
  }
  v31.msg_namelen = v19;
  *(_QWORD *)&v23 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v23 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v37 = v23;
  v38 = v23;
  v35 = v23;
  v36 = v23;
  v33 = v23;
  v34 = v23;
  v32[0] = a5;
  v32[1] = a6;
  v31.msg_iov = (iovec *)v32;
  v31.msg_iovlen = 1;
  v31.msg_flags = 0;
  if (a2 == 1 || *(_BYTE *)(v17 + 21625))
  {
    v31.msg_control = 0;
    v31.msg_controllen = 0;
  }
  else
  {
    v31.msg_control = &v37;
    v31.msg_controllen = 32;
    *(_QWORD *)&v37 = 0xFFFF00000010;
    DWORD2(v37) = 4230;
    v24 = *(_DWORD *)(v17 + 21628);
    if (!v24)
      v24 = a7;
    v25 = (*(_DWORD *)a3 & 1) == 0;
    HIDWORD(v37) = v24;
    LODWORD(v38) = 16;
    *(int8x8_t *)((char *)&v38 + 4) = vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v25), 0x1FuLL)), (int8x8_t)0x300000000, (int8x8_t)0x2400000029);
    HIDWORD(v38) = a9;
  }
  v22 = sendmsg(a1, &v31, 0);
  kdebug_trace();
  if (v22 >= 1)
  {
    if ((*a3 & 1) != 0)
      v26 = 48;
    else
      v26 = 28;
    v27 = v26 + (int)v22;
    do
      v28 = __ldxr((unint64_t *)v17);
    while (__stxr(v28 + v27, (unint64_t *)v17));
  }
  CheckOutHandleDebug();
  return v22;
}

void _VTP_UpdateIDSDatagramOptionWithChannelDataFormat(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  _WORD *v4;
  uint64_t v5;
  __int16 *v6;
  __int16 v7;
  char v8;
  char v9;
  char v10;

  if (a2)
  {
    v3 = *(unsigned __int8 *)(a1 + 24);
    if (*(_BYTE *)(a1 + 24))
    {
      *(_DWORD *)a2 |= 2u;
      v4 = (_WORD *)(a2 + 20);
      v5 = v3;
      v6 = (__int16 *)a1;
      do
      {
        v7 = *v6++;
        *v4++ = v7;
        --v5;
      }
      while (v5);
      *(_BYTE *)(a2 + 19) = v3;
    }
    v8 = *(_BYTE *)(a1 + 28);
    if (v8)
    {
      *(_DWORD *)a2 |= 8u;
      *(_BYTE *)(a2 + 18) = v8;
    }
    if (*(_BYTE *)(a1 + 29))
      *(_DWORD *)a2 |= 4u;
    if (*(_BYTE *)(a1 + 25))
    {
      *(_DWORD *)a2 |= 0x10u;
      *(_WORD *)(a2 + 16) = *(_WORD *)(a1 + 26);
    }
    if (*(_BYTE *)(a1 + 30))
    {
      *(_DWORD *)a2 |= 1u;
      *(_QWORD *)(a2 + 8) = *(_QWORD *)(a1 + 32);
    }
    v9 = *(_BYTE *)(a1 + 76);
    if (v9)
    {
      *(_DWORD *)a2 |= 0x10000u;
      *(_BYTE *)(a2 + 112) = v9;
    }
    if (*(_BYTE *)(a1 + 58))
    {
      *(_DWORD *)a2 |= 0x8000u;
      *(_QWORD *)(a2 + 88) = *(_QWORD *)(a1 + 64);
    }
    if (*(_BYTE *)(a1 + 41))
      *(_DWORD *)a2 |= 0x80u;
    if (a3 && *(_BYTE *)(a1 + 42))
    {
      *(_DWORD *)a2 |= 0x40u;
      *(_WORD *)(a2 + 46) = *(_WORD *)(a1 + 44);
    }
    if (*(_BYTE *)(a1 + 56))
      *(_DWORD *)a2 |= 0x100u;
    if (*(_BYTE *)(a1 + 57))
    {
      *(_DWORD *)a2 |= 0x400u;
      *(_BYTE *)(a2 + 80) = 1;
    }
    v10 = *(_BYTE *)(a1 + 79);
    if (v10)
    {
      *(_DWORD *)a2 |= 0x20000u;
      *(_BYTE *)(a2 + 113) = v10;
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VTP_UpdateIDSDatagramOptionWithChannelDataFormat_cold_1();
  }
}

void _VTP_ReportIDSOnTheWireBytesLocked(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int a5)
{
  const void *v7;
  uint64_t v8;
  const void *v9;
  uint64_t v10;
  uint64_t v11;

  if (a4)
  {
    if (a2)
    {
      v7 = VTP_getConnectionManagerForCallID(a1, a2);
      if (v7)
      {
        v8 = (uint64_t)v7;
        v9 = (const void *)VCConnectionManager_CopyPrimaryConnection((uint64_t)v7);
        v10 = VCConnection_PerPacketConnectionOverhead((uint64_t)v9);
        if (v9)
          CFRelease(v9);
        v11 = v10 + a3 + IDSEstimateAdditionalOverheadForDatagramOptions();
        if (a5)
          VCConnectionManager_UpdateOnTheWireBytesSentCount(v8, v11);
        else
          VCConnectionManager_UpdateOnTheWireBytesReceivedCount(v8, v11);
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VTP_ReportIDSOnTheWireBytesLocked_cold_2();
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VTP_ReportIDSOnTheWireBytesLocked_cold_1();
  }
}

void _VTP_ProcessPacketForDirectIDSDataPath(uint64_t a1, _BYTE *a2, _DWORD *a3)
{
  int v6;
  void *v7[2];

  v7[1] = *(void **)MEMORY[0x1E0C80C00];
  v7[0] = a3;
  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3
      && (VRTraceErrorLogLevelToCSTR(), os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR)))
    {
      _VTP_ProcessPacketForDirectIDSDataPath_cold_1();
      if (!a3)
        return;
    }
    else if (!a3)
    {
      return;
    }
    _VTP_ReleasePacket(a1, v7);
    return;
  }
  pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 5376));
  v6 = 1;
  VTP_DemuxPacketsToVFDList(a1, a2, &v6);
  if (a3)
  {
    if (*a3 == 0x20000)
    {
      v6 = 1;
      VTP_DemuxPacketsToVFDList(a1, a3, &v6);
    }
  }
  pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 5376));
}

void _VTP_ProcessPacketForSharedIDSDataPath(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  _QWORD *v6;

  if (a2)
  {
    v3 = *(_QWORD *)(a1 + 21848);
    if (v3)
    {
      v4 = 0;
      do
      {
        v5 = v3;
        v3 = *(_QWORD *)(v3 + 528);
        ++v4;
      }
      while (v3);
      v6 = (_QWORD *)(v5 + 528);
    }
    else
    {
      v6 = (_QWORD *)(a1 + 21848);
      v4 = 1;
    }
    *v6 = a2;
    if (a3)
    {
      if (*a3 == 0x20000)
      {
        *(_QWORD *)(a2 + 528) = a3;
        ++v4;
      }
    }
    *(_DWORD *)(a1 + 21856) = v4;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VTP_ProcessPacketForSharedIDSDataPath_cold_1();
  }
}

void OUTLINED_FUNCTION_15_5(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0x2Cu);
}

void OUTLINED_FUNCTION_24_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, a5, 0x28u);
}

void OUTLINED_FUNCTION_33_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0x2Eu);
}

void _VCAVFoundationCapture_ConvertPixelFormat(OpaqueVTPixelTransferSession *a1, __CVPixelBufferPool *a2, CMSampleBufferRef *a3, uint64_t a4)
{
  __CVBuffer *ImageBuffer;
  CMSampleBufferRef v9;
  __int128 v10;
  uint64_t v11;
  CVPixelBufferRef pixelBufferOut[2];

  pixelBufferOut[1] = *(CVPixelBufferRef *)MEMORY[0x1E0C80C00];
  pixelBufferOut[0] = 0;
  ImageBuffer = CMSampleBufferGetImageBuffer(*a3);
  if (CVPixelBufferPoolCreatePixelBuffer((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2, pixelBufferOut))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCAVFoundationCapture_ConvertPixelFormat_cold_2();
    }
  }
  else if (VTPixelTransferSessionTransferImage(a1, ImageBuffer, pixelBufferOut[0]))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCAVFoundationCapture_ConvertPixelFormat_cold_1();
    }
  }
  else
  {
    v10 = *(_OWORD *)a4;
    v11 = *(_QWORD *)(a4 + 16);
    v9 = createSampleBufferWithPixelBuffer(pixelBufferOut[0], &v10);
    CMPropagateAttachments(*a3, v9);
    FigSampleBufferRelease();
    *a3 = v9;
  }
  CVPixelBufferRelease(pixelBufferOut[0]);
}

void sub_1D8D3AE2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1D8D3AF30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1D8D3B034(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1D8D3B138(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t VCMediaNegotiationBlobReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  int v15;
  char v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char v22;
  uint64_t result;
  char v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  char v29;
  VCMediaNegotiationBlobAudioSettings *v30;
  VCMediaNegotiationBlobVideoSettings *v31;
  VCMediaNegotiationBlobVideoSettings *v32;
  void *String;
  id v34;
  uint64_t v35;
  void *v36;
  char v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  char v42;
  VCMediaNegotiationBlobBandwidthSettings *v43;
  VCMediaNegotiationBlobCaptionsSettings *v44;
  VCMediaNegotiationBlobMultiwayAudioStream *v45;
  VCMediaNegotiationBlobMomentsSettings *v46;
  char v47;
  unsigned int v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  char v52;
  char v53;
  unsigned int v54;
  uint64_t v55;
  unint64_t v56;
  char v57;
  VCMediaNegotiationBlobMultiwayVideoStream *v58;
  char v59;
  unsigned int v60;
  uint64_t v61;
  unint64_t v62;
  char v63;
  VCMediaNegotiationFaceTimeSettings *v64;
  char v65;
  unsigned int v66;
  uint64_t v67;
  unint64_t v68;
  char v69;
  BOOL v70;
  uint64_t v71;
  uint64_t v72;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) >= *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
    return *(_BYTE *)(a2 + *v5) == 0;
  v7 = (int *)MEMORY[0x1E0D82BB8];
  while (2)
  {
    if (*(_BYTE *)(a2 + *v5))
      return *(_BYTE *)(a2 + *v5) == 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v11 = *v3;
      v12 = *(_QWORD *)(a2 + v11);
      if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
        break;
      v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
      *(_QWORD *)(a2 + v11) = v12 + 1;
      v10 |= (unint64_t)(v13 & 0x7F) << v8;
      if ((v13 & 0x80) == 0)
        goto LABEL_12;
      v8 += 7;
      v14 = v9++ >= 9;
      if (v14)
      {
        v10 = 0;
        v15 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
    v15 = *(unsigned __int8 *)(a2 + *v5);
    if (*(_BYTE *)(a2 + *v5))
      v10 = 0;
LABEL_14:
    if (v15 || (v10 & 7) == 4)
      return *(_BYTE *)(a2 + *v5) == 0;
    switch((v10 >> 3))
    {
      case 1u:
        v17 = 0;
        v18 = 0;
        v19 = 0;
        *(_BYTE *)(a1 + 132) |= 0x20u;
        while (1)
        {
          v20 = *v3;
          v21 = *(_QWORD *)(a2 + v20);
          if (v21 == -1 || v21 >= *(_QWORD *)(a2 + *v4))
            break;
          v22 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v21);
          *(_QWORD *)(a2 + v20) = v21 + 1;
          v19 |= (unint64_t)(v22 & 0x7F) << v17;
          if ((v22 & 0x80) == 0)
            goto LABEL_101;
          v17 += 7;
          v14 = v18++ >= 9;
          if (v14)
          {
            v19 = 0;
            goto LABEL_103;
          }
        }
        *(_BYTE *)(a2 + *v5) = 1;
LABEL_101:
        if (*(_BYTE *)(a2 + *v5))
          v19 = 0;
LABEL_103:
        v70 = v19 != 0;
        v71 = 128;
        goto LABEL_108;
      case 2u:
        v24 = 0;
        v25 = 0;
        v26 = 0;
        *(_BYTE *)(a1 + 132) |= 0x40u;
        while (2)
        {
          v27 = *v3;
          v28 = *(_QWORD *)(a2 + v27);
          if (v28 == -1 || v28 >= *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v29 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v28);
            *(_QWORD *)(a2 + v27) = v28 + 1;
            v26 |= (unint64_t)(v29 & 0x7F) << v24;
            if (v29 < 0)
            {
              v24 += 7;
              v14 = v25++ >= 9;
              if (v14)
              {
                v26 = 0;
                goto LABEL_107;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v26 = 0;
LABEL_107:
        v70 = v26 != 0;
        v71 = 129;
LABEL_108:
        *(_BYTE *)(a1 + v71) = v70;
        goto LABEL_130;
      case 3u:
        v30 = objc_alloc_init(VCMediaNegotiationBlobAudioSettings);

        *(_QWORD *)(a1 + 24) = v30;
        if (!PBReaderPlaceMark()
          || (VCMediaNegotiationBlobAudioSettingsReadFrom((uint64_t)v30, a2) & 1) == 0)
        {
          return 0;
        }
        goto LABEL_82;
      case 4u:
        v31 = objc_alloc_init(VCMediaNegotiationBlobVideoSettings);

        *(_QWORD *)(a1 + 120) = v31;
        if (!PBReaderPlaceMark() || (VCMediaNegotiationBlobVideoSettingsReadFrom(v31, a2) & 1) == 0)
          return 0;
        goto LABEL_82;
      case 5u:
        v32 = objc_alloc_init(VCMediaNegotiationBlobVideoSettings);

        *(_QWORD *)(a1 + 104) = v32;
        if (!PBReaderPlaceMark() || (VCMediaNegotiationBlobVideoSettingsReadFrom(v32, a2) & 1) == 0)
          return 0;
        goto LABEL_82;
      case 6u:
        String = (void *)PBReaderReadString();

        v34 = String;
        v35 = 112;
        goto LABEL_46;
      case 7u:
        v36 = (void *)PBReaderReadString();

        v34 = v36;
        v35 = 40;
LABEL_46:
        *(_QWORD *)(a1 + v35) = v34;
        goto LABEL_130;
      case 8u:
        v37 = 0;
        v38 = 0;
        v39 = 0;
        *(_BYTE *)(a1 + 132) |= 4u;
        while (2)
        {
          v40 = *v3;
          v41 = *(_QWORD *)(a2 + v40);
          if (v41 == -1 || v41 >= *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v42 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v41);
            *(_QWORD *)(a2 + v40) = v41 + 1;
            v39 |= (unint64_t)(v42 & 0x7F) << v37;
            if (v42 < 0)
            {
              v37 += 7;
              v14 = v38++ >= 9;
              if (v14)
              {
                LODWORD(v39) = 0;
                goto LABEL_112;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          LODWORD(v39) = 0;
LABEL_112:
        v72 = 48;
        goto LABEL_129;
      case 9u:
        v43 = objc_alloc_init(VCMediaNegotiationBlobBandwidthSettings);
        objc_msgSend((id)a1, "addBandwidthSettings:", v43);

        if (!PBReaderPlaceMark() || !VCMediaNegotiationBlobBandwidthSettingsReadFrom((uint64_t)v43, a2))
          return 0;
        goto LABEL_82;
      case 0xAu:
        v44 = objc_alloc_init(VCMediaNegotiationBlobCaptionsSettings);

        *(_QWORD *)(a1 + 56) = v44;
        if (!PBReaderPlaceMark()
          || (VCMediaNegotiationBlobCaptionsSettingsReadFrom((uint64_t)v44, a2) & 1) == 0)
        {
          return 0;
        }
        goto LABEL_82;
      case 0xBu:
        v45 = objc_alloc_init(VCMediaNegotiationBlobMultiwayAudioStream);
        objc_msgSend((id)a1, "addMultiwayAudioStreams:", v45);

        if (!PBReaderPlaceMark()
          || (VCMediaNegotiationBlobMultiwayAudioStreamReadFrom((uint64_t)v45, a2) & 1) == 0)
        {
          return 0;
        }
        goto LABEL_82;
      case 0xCu:
        v46 = objc_alloc_init(VCMediaNegotiationBlobMomentsSettings);

        *(_QWORD *)(a1 + 80) = v46;
        if (!PBReaderPlaceMark() || !VCMediaNegotiationBlobMomentsSettingsReadFrom((uint64_t)v46, a2))
          return 0;
        goto LABEL_82;
      case 0xDu:
        v47 = 0;
        v48 = 0;
        v49 = 0;
        *(_BYTE *)(a1 + 132) |= 1u;
        while (2)
        {
          v50 = *v3;
          v51 = *(_QWORD *)(a2 + v50);
          if (v51 == -1 || v51 >= *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v52 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v51);
            *(_QWORD *)(a2 + v50) = v51 + 1;
            v49 |= (unint64_t)(v52 & 0x7F) << v47;
            if (v52 < 0)
            {
              v47 += 7;
              v14 = v48++ >= 9;
              if (v14)
              {
                v49 = 0;
                goto LABEL_116;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v49 = 0;
LABEL_116:
        *(_QWORD *)(a1 + 8) = v49;
        goto LABEL_130;
      case 0xEu:
        v53 = 0;
        v54 = 0;
        v39 = 0;
        *(_BYTE *)(a1 + 132) |= 8u;
        while (2)
        {
          v55 = *v3;
          v56 = *(_QWORD *)(a2 + v55);
          if (v56 == -1 || v56 >= *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v57 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v56);
            *(_QWORD *)(a2 + v55) = v56 + 1;
            v39 |= (unint64_t)(v57 & 0x7F) << v53;
            if (v57 < 0)
            {
              v53 += 7;
              v14 = v54++ >= 9;
              if (v14)
              {
                LODWORD(v39) = 0;
                goto LABEL_120;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          LODWORD(v39) = 0;
LABEL_120:
        v72 = 52;
        goto LABEL_129;
      case 0xFu:
        v58 = objc_alloc_init(VCMediaNegotiationBlobMultiwayVideoStream);
        objc_msgSend((id)a1, "addMultiwayVideoStream:", v58);

        if (PBReaderPlaceMark() && VCMediaNegotiationBlobMultiwayVideoStreamReadFrom((uint64_t)v58, a2))
          goto LABEL_82;
        return 0;
      case 0x10u:
        v59 = 0;
        v60 = 0;
        v39 = 0;
        *(_BYTE *)(a1 + 132) |= 0x10u;
        while (2)
        {
          v61 = *v3;
          v62 = *(_QWORD *)(a2 + v61);
          if (v62 == -1 || v62 >= *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v63 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v62);
            *(_QWORD *)(a2 + v61) = v62 + 1;
            v39 |= (unint64_t)(v63 & 0x7F) << v59;
            if (v63 < 0)
            {
              v59 += 7;
              v14 = v60++ >= 9;
              if (v14)
              {
                LODWORD(v39) = 0;
                goto LABEL_124;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          LODWORD(v39) = 0;
LABEL_124:
        v72 = 72;
        goto LABEL_129;
      case 0x11u:
        v64 = objc_alloc_init(VCMediaNegotiationFaceTimeSettings);

        *(_QWORD *)(a1 + 64) = v64;
        if (PBReaderPlaceMark()
          && (VCMediaNegotiationFaceTimeSettingsReadFrom((uint64_t)v64, a2) & 1) != 0)
        {
LABEL_82:
          PBReaderRecallMark();
LABEL_130:
          if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
            return *(_BYTE *)(a2 + *v5) == 0;
          continue;
        }
        return 0;
      case 0x12u:
        v65 = 0;
        v66 = 0;
        v39 = 0;
        *(_BYTE *)(a1 + 132) |= 2u;
        while (2)
        {
          v67 = *v3;
          v68 = *(_QWORD *)(a2 + v67);
          if (v68 == -1 || v68 >= *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v69 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v68);
            *(_QWORD *)(a2 + v67) = v68 + 1;
            v39 |= (unint64_t)(v69 & 0x7F) << v65;
            if (v69 < 0)
            {
              v65 += 7;
              v14 = v66++ >= 9;
              if (v14)
              {
                LODWORD(v39) = 0;
                goto LABEL_128;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          LODWORD(v39) = 0;
LABEL_128:
        v72 = 16;
LABEL_129:
        *(_DWORD *)(a1 + v72) = v39;
        goto LABEL_130;
      default:
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
        goto LABEL_130;
    }
  }
}

void OUTLINED_FUNCTION_1_2(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x2Eu);
}

void _VCRateControlAlgorithmTelephony_Configure(uint64_t a1, const void *a2, int a3)
{
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  uint8_t buf[4];
  uint64_t v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  __int16 v28;
  int v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  memcpy((void *)(a1 + 40), a2, 0x3D0uLL);
  ++*(_DWORD *)(a1 + 1084);
  if (a3)
  {
    *(_DWORD *)(a1 + 1040) = 1;
    *(_DWORD *)(a1 + 1052) = *(_DWORD *)(a1 + 56);
  }
  v5 = *(_DWORD *)(a1 + 1052);
  if (v5 >= *(_DWORD *)(a1 + 60))
    v5 = *(_DWORD *)(a1 + 60);
  if (v5 <= *(_DWORD *)(a1 + 64))
    v5 = *(_DWORD *)(a1 + 64);
  *(_DWORD *)(a1 + 1052) = v5;
  *(_DWORD *)(a1 + 1072) = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * *(int *)(a1 + 1052));
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v12 = VRTraceErrorLogLevelToCSTR();
    v13 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v14 = *(_DWORD *)(a1 + 1072);
      v15 = *(_QWORD *)(a1 + 48);
      v16 = *(_DWORD *)(v15 + 4 * *(int *)(a1 + 64));
      v17 = *(_DWORD *)(v15 + 4 * *(int *)(a1 + 60));
      *(_DWORD *)buf = 136316418;
      v19 = v12;
      v20 = 2080;
      v21 = "_VCRateControlAlgorithmTelephony_Configure";
      v22 = 1024;
      v23 = 82;
      v24 = 1024;
      v25 = v14;
      v26 = 1024;
      v27 = v16;
      v28 = 1024;
      v29 = v17;
      _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Configuring VCRateControl algorithm with targetBitrate=%d, minBitrate=%d, maxBitrate=%d", buf, 0x2Eu);
    }
  }
  VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Configure with targetBitrate=%d, minBitrate=%d, maxBitrate=%d", v6, v7, v8, v9, v10, v11, *(_DWORD *)(a1 + 1072));
}

BOOL _VCRateControlAlgorithmTelephony_DoRateControl(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9;
  uint64_t v10;
  NSObject *v11;
  _BOOL8 result;
  int v13;
  double v14;
  int v15;
  double v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  NSObject *v21;
  unint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  double v26;
  unsigned int v27;
  int v28;
  int v29;
  unsigned int v30;
  int v31;
  int v32;
  uint64_t v33;
  uint8_t buf[4];
  uint64_t v35;
  __int16 v36;
  const char *v37;
  __int16 v38;
  int v39;
  __int16 v40;
  uint64_t v41;
  __int16 v42;
  int v43;
  __int16 v44;
  uint64_t v45;
  __int16 v46;
  uint64_t v47;
  __int16 v48;
  uint64_t v49;
  __int16 v50;
  uint64_t v51;
  __int16 v52;
  int v53;
  __int16 v54;
  int v55;
  __int16 v56;
  double v57;
  __int16 v58;
  double v59;
  __int16 v60;
  int v61;
  __int16 v62;
  int v63;
  __int16 v64;
  int v65;
  __int16 v66;
  unsigned int v67;
  __int16 v68;
  int v69;
  __int16 v70;
  int v71;
  __int16 v72;
  int v73;
  __int16 v74;
  unsigned int v75;
  __int16 v76;
  int v77;
  __int16 v78;
  int v79;
  __int16 v80;
  int v81;
  __int16 v82;
  int v83;
  __int16 v84;
  int v85;
  uint64_t v86;

  v86 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)a2 != 12)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      _VCRateControlAlgorithmTelephony_DoRateControl_cold_3();
    }
    return 0;
  }
  if (*(_BYTE *)(a2 + 26) != 2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      _VCRateControlAlgorithmTelephony_DoRateControl_cold_2();
    }
    return 0;
  }
  *(_WORD *)(a1 + 5186) = *(_WORD *)(a2 + 90);
  *(_BYTE *)(a1 + 5188) = *(_BYTE *)(a2 + 95);
  *(_DWORD *)(a1 + 5196) = *(_QWORD *)(a2 + 72);
  *(_DWORD *)(a1 + 5192) = *(_DWORD *)(a2 + 64);
  *(_QWORD *)(a1 + 1096) = *(_QWORD *)(a2 + 8);
  v9 = *(unsigned __int8 *)(a1 + 5188);
  if (*(_DWORD *)(a1 + 764) > v9)
  {
    *(_QWORD *)(a1 + 5200) = *(_QWORD *)(a1 + 1096);
    v9 = *(unsigned __int8 *)(a1 + 5188);
  }
  if (*(_DWORD *)(a1 + 760) < v9)
    *(_QWORD *)(a1 + 5208) = *(_QWORD *)(a1 + 1096);
  switch(*(_DWORD *)(a1 + 1040))
  {
    case 0:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v10 = VRTraceErrorLogLevelToCSTR();
        v11 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          v35 = v10;
          v36 = 2080;
          v37 = "_VCRateControlAlgorithmTelephony_RunRateControlStateTransition";
          v38 = 1024;
          v39 = 166;
          _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d VCRateControl is paused", buf, 0x1Cu);
        }
      }
      goto LABEL_39;
    case 1:
      if (*(__int16 *)(a1 + 5186) <= -95)
        *(_DWORD *)(a1 + 1052) = *(_DWORD *)(a1 + 64);
      v13 = 3;
      goto LABEL_33;
    case 2:
      v14 = *(double *)(a1 + 1096);
      if (v14 - *(double *)(a1 + 5200) > *(double *)(a1 + 776))
      {
        *(_DWORD *)(a1 + 1048) |= 1u;
        ++*(_DWORD *)(a1 + 1084);
        v15 = *(_DWORD *)(a1 + 64);
        if (v15 <= *(_DWORD *)(a1 + 1052) - 1)
          v15 = *(_DWORD *)(a1 + 1052) - 1;
LABEL_37:
        *(_DWORD *)(a1 + 1052) = v15;
        goto LABEL_39;
      }
      if (v14 - *(double *)(a1 + 5208) >= *(double *)(a1 + 768))
      {
        ++*(_DWORD *)(a1 + 1084);
        v18 = *(_DWORD *)(a1 + 1052);
        v15 = *(_DWORD *)(a1 + 60);
        if (v15 >= v18 + 1)
          v15 = v18 + 1;
        goto LABEL_37;
      }
      *(_DWORD *)(a1 + 1044) |= 2u;
LABEL_39:
      *(_DWORD *)(a1 + 1072) = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * *(int *)(a1 + 1052));
      if (*(_BYTE *)(a1 + 5128))
      {
        v19 = *(_DWORD *)(a1 + 1088);
        *(_DWORD *)(a1 + 1088) = v19 + 1;
        if ((v19 & 0xF) == 0 && (int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v20 = VRTraceErrorLogLevelToCSTR();
          v21 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v23 = *(_QWORD *)(a1 + 1096);
            v24 = *(_DWORD *)(a1 + 1044);
            if (v24)
              v25 = 88;
            else
              v25 = 79;
            LOBYTE(v22) = *(_BYTE *)(a1 + 5188);
            v26 = (double)*(__int16 *)(a1 + 5186);
            v27 = *(_DWORD *)(a1 + 1072) / 0x3E8u;
            v28 = *(unsigned __int16 *)(a1 + 1048);
            v29 = *(_DWORD *)(a1 + 1084);
            v30 = *(_DWORD *)(a1 + 5196) / 0x3E8u;
            v31 = 1000 * *(_DWORD *)(a1 + 5192);
            v32 = *(_DWORD *)(a1 + 1040);
            *(_DWORD *)buf = 136321538;
            v35 = v20;
            v36 = 2080;
            v37 = "_VCRateControlAlgorithmTelephony_PrintRateControlInfoToLogDump";
            v38 = 1024;
            v39 = 230;
            v40 = 2048;
            v41 = v23;
            v42 = 1024;
            v43 = 0;
            v44 = 2048;
            v45 = 0;
            v46 = 2048;
            v47 = 0;
            v48 = 2048;
            v49 = 0;
            v50 = 2048;
            v51 = 0;
            v52 = 1024;
            v53 = v25;
            v54 = 1024;
            v55 = 0;
            v56 = 2048;
            v57 = (double)v22;
            v58 = 2048;
            v59 = v26;
            v60 = 1024;
            v61 = 0;
            v62 = 1024;
            v63 = 0;
            v64 = 1024;
            v65 = 0;
            v66 = 1024;
            v67 = v27;
            v68 = 1024;
            v69 = (unsigned __int16)v24;
            v70 = 1024;
            v71 = v28;
            v72 = 1024;
            v73 = v29;
            v74 = 1024;
            v75 = v30;
            v76 = 1024;
            v77 = 0;
            v78 = 1024;
            v79 = v31;
            v80 = 1024;
            v81 = 0;
            v82 = 1024;
            v83 = 0;
            v84 = 1024;
            v85 = v32;
            _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d %8.3f/%04X:\t%.4f\t%.4f\t%.4f\t%.4f %c\tRTT:%-4u\tPLR:%4.2f@%.1f\tRRx:%4u\tMBL:%d\t%4u/%4u\t  CS:%04X %04X %u BB: %3u\t%4u\t%3u\t%u\t%u\t UAT \t%d", buf, 0xC2u);
          }
        }
      }
      v33 = *(_QWORD *)(a1 + 5112);
      if (v33)
        VRLogfilePrintWithTimestamp(v33, "%8.3f/%04X:\t%.4f\t%.4f\t%.4f\t%.4f %c\tRTT:%-4u\tPLR:%4.2f@%.1f\tRRx:%u\tMBL:%d %u\t%4u/%4u\t %4u:%4u/%4u  %4u:%4u/%4u  CS: %04X %04X %u BB: %3u\t%4u\t%3u\t%u\t%u\t UAT \t%d\n", a3, a4, a5, a6, a7, a8, *(_QWORD *)(a1 + 1096));
      *(_DWORD *)(a1 + 1044) = 0;
      *(_DWORD *)(a1 + 1048) = 0;
      result = 1;
      break;
    case 3:
      *(_DWORD *)(a1 + 1044) |= 1u;
      v16 = *(double *)(a1 + 1096);
      if (v16 - *(double *)(a1 + 5200) > *(double *)(a1 + 776))
      {
        *(_DWORD *)(a1 + 1048) |= 1u;
        ++*(_DWORD *)(a1 + 1084);
        v17 = *(_DWORD *)(a1 + 64);
        if (v17 <= *(_DWORD *)(a1 + 1052) - 1)
          v17 = *(_DWORD *)(a1 + 1052) - 1;
        *(_DWORD *)(a1 + 1052) = v17;
        v16 = *(double *)(a1 + 1096);
      }
      if (v16 - *(double *)(a1 + 1104) > *(double *)(a1 + 184))
      {
        v13 = 2;
LABEL_33:
        VCRateControlAlgorithmBasePriv_StateChange(a1, v13);
      }
      goto LABEL_39;
    default:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCRateControlAlgorithmTelephony_DoRateControl_cold_1();
      }
      goto LABEL_39;
  }
  return result;
}

BOOL VCVideoTransmitterDefault_EnqueueVideoFrame(_BOOL8 result, CMSampleBufferRef sbuf, CMTime *a3, unsigned int a4)
{
  uint64_t v4;
  uint64_t v8;
  double *v9;
  double v10;
  uint64_t v11;
  CMTime v12;
  Float64 v13;
  unsigned int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v4 = result;
    if (*(_QWORD *)(result + 160) == 0xFFFFFFFFLL)
    {
      return 0;
    }
    else
    {
      v14 = 0;
      v13 = 0.0;
      v8 = *(unsigned int *)(result + 100);
      if ((_DWORD)v8)
      {
        v9 = (double *)(result + 104);
      }
      else
      {
        v9 = &v13;
        VCVideoTransmitterDefault_ComputeTimestamp(result, &v14, &v13, sbuf);
        v8 = v14;
      }
      v10 = *v9;
      v12 = *a3;
      *(Float64 *)(v4 + 248) = CMTimeGetSeconds(&v12);
      v11 = *(_QWORD *)(v4 + 160);
      v12 = *a3;
      return (int)VideoTransmitter_EnqueueBuffer(v11, sbuf, v8, (__int128 *)&v12.value, 0, a4, v10) >= 0;
    }
  }
  return result;
}

uint64_t VCVideoTransmitterDefault_SetFECRatio(double a1)
{
  return VideoTransmitter_SetFECRatio(a1);
}

uint64_t VCVideoTransmitterDefault_SetMediaQueueSize(uint64_t a1, unsigned int a2)
{
  return VideoTransmitter_SetMediaQueueSize(*(_QWORD *)(a1 + 160), a2);
}

void VCVideoTransmitterDefault_ComputeTimestamp(uint64_t a1, _DWORD *a2, Float64 *a3, CMSampleBufferRef sbuf)
{
  CMTimeValue value;
  uint64_t v8;
  CMTimeEpoch epoch;
  int32_t v10;
  __int128 v11;
  CMTimeEpoch v12;
  CMTime v13;
  CMTime lhs;
  CMTime v15;
  CMTime v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  memset(&v16, 170, sizeof(v16));
  CMSampleBufferGetPresentationTimeStamp(&v16, sbuf);
  value = *(_QWORD *)(a1 + 64);
  if (value)
  {
    lhs = v16;
    v13 = *(CMTime *)(a1 + 64);
    CMTimeSubtract(&v15, &lhs, &v13);
    value = v15.value;
    v8 = *(_QWORD *)&v15.timescale;
    epoch = v15.epoch;
  }
  else
  {
    v8 = *(_QWORD *)(a1 + 72);
    epoch = *(_QWORD *)(a1 + 80);
  }
  lhs.epoch = epoch;
  memset(&v15, 170, sizeof(v15));
  v10 = *(_DWORD *)(a1 + 168);
  lhs.value = value;
  *(_QWORD *)&lhs.timescale = v8;
  CMTimeConvertScale(&v15, &lhs, v10, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
  *(_DWORD *)(a1 + 96) += LODWORD(v15.value);
  v11 = *(_OWORD *)&v16.value;
  *(_OWORD *)(a1 + 64) = *(_OWORD *)&v16.value;
  v12 = v16.epoch;
  *(_QWORD *)(a1 + 80) = v16.epoch;
  *(_OWORD *)&lhs.value = v11;
  lhs.epoch = v12;
  *a3 = CMTimeGetSeconds(&lhs);
  *a2 = *(_DWORD *)(a1 + 96);
}

uint64_t VCVideoReceiverFeedbackDelegate_sendLTRAck(uint64_t result, int a2)
{
  if (result)
    return VideoTransmitter_SendLTRACK(*(_QWORD *)(result + 160), a2);
  return result;
}

uint64_t VCVideoReceiverFeedbackDelegate_ackLTRFrame(uint64_t result, int a2)
{
  if (result)
    return VideoTransmitter_ACKLTRFrame(*(_QWORD *)(result + 160), a2);
  return result;
}

uint64_t VCCMSessionStub_AudioSessionCreateCMSession()
{
  return _cmSessionStub();
}

uint64_t VCCMSessionStub_AudioSessionDestroyCMSession()
{
  return off_1ED10CD80();
}

uint64_t VCCMSessionStub_CMSessionCopyProperty()
{
  return off_1ED10CD88();
}

uint64_t VCCMSessionStub_CMSessionSetProperty()
{
  return off_1ED10CD90();
}

uint64_t VCCMSessionStub_CMSessionBeginInterruption()
{
  return off_1ED10CD98();
}

uint64_t VCCMSessionStub_CMSessionEndInterruption()
{
  return off_1ED10CDA0();
}

uint64_t VCCMSessionStub_CMSessionNotificationBarrier()
{
  return off_1ED10CDA8();
}

uint64_t VCBlockBufferUtlities_Create(const __CFAllocator *a1, void *a2, size_t a3, const __CFAllocator *a4, const CMBlockBufferCustomBlockSource *a5, size_t a6, size_t a7, CMBlockBufferFlags a8, CMBlockBufferRef *blockBufferOut)
{
  uint64_t v17;

  if (FigMemoryPoolIsPoolAllocator())
  {
    if (FigMemoryPoolAllocatorCopyMemoryPool())
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCBlockBufferUtlities_Create_cold_3();
      }
    }
    else if (FigMemoryPoolCreateBlockBuffer())
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCBlockBufferUtlities_Create_cold_2();
      }
    }
    return 0;
  }
  else
  {
    v17 = CMBlockBufferCreateWithMemoryBlock(a1, a2, a3, a4, a5, a6, a7, a8, blockBufferOut);
    if ((_DWORD)v17)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCBlockBufferUtlities_Create_cold_1();
      }
    }
  }
  return v17;
}

char *VCBlockBufferUtilities_CreateAndGetDataPointer(const __CFAllocator *a1, void *a2, size_t a3, const __CFAllocator *a4, const CMBlockBufferCustomBlockSource *a5, size_t a6, size_t a7, CMBlockBufferFlags a8, CMBlockBufferRef *a9)
{
  char *dataPointerOut[2];

  dataPointerOut[1] = *(char **)MEMORY[0x1E0C80C00];
  dataPointerOut[0] = 0;
  if (VCBlockBufferUtlities_Create(a1, a2, a3, a4, a5, a6, a7, a8, a9))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCBlockBufferUtilities_CreateAndGetDataPointer_cold_2();
    }
  }
  else if (CMBlockBufferGetDataPointer(*a9, 0, 0, 0, dataPointerOut))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCBlockBufferUtilities_CreateAndGetDataPointer_cold_1();
    }
  }
  return dataPointerOut[0];
}

uint64_t symptomReporterCallback_0(void *a1, CFDictionaryRef theDict)
{
  const void *Value;
  const void *v5;
  const void *v6;
  uint64_t v7;
  _QWORD v9[2];

  v9[1] = *MEMORY[0x1E0C80C00];
  Value = CFDictionaryGetValue(theDict, CFSTR("SymptomReporterCallbackKeySymptomID"));
  v5 = CFDictionaryGetValue(theDict, CFSTR("SymptomReporterCallbackKeyGroupID"));
  v6 = CFDictionaryGetValue(theDict, CFSTR("SymptomReporterOptionalKeyParticipantID"));
  if (v6)
  {
    v9[0] = v6;
    v7 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v9, 1);
  }
  else
  {
    v7 = 0;
  }
  return objc_msgSend(a1, "sendSymptomsToRemoteParticipants:symptom:groupID:", v7, Value, v5);
}

void _VCSession_ReportingConfigurationCallback(uint64_t a1, char a2)
{
  int ErrorLogLevelForModule;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if ((a2 & 1) != 0)
  {
    if (ErrorLogLevelForModule >= 8)
    {
      v4 = VRTraceErrorLogLevelToCSTR();
      v5 = *MEMORY[0x1E0CF2758];
      v6 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          v9 = 136315650;
          v10 = v4;
          v11 = 2080;
          v12 = "_VCSession_ReportingConfigurationCallback";
          v13 = 1024;
          v14 = 716;
          _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, "VCSession [%s] %s:%d Reporting is enabled", (uint8_t *)&v9, 0x1Cu);
        }
      }
      else if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        _VCSession_ReportingConfigurationCallback_cold_1();
      }
    }
  }
  else
  {
    if (ErrorLogLevelForModule >= 7)
    {
      v7 = VRTraceErrorLogLevelToCSTR();
      v8 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v9 = 136315650;
        v10 = v7;
        v11 = 2080;
        v12 = "_VCSession_ReportingConfigurationCallback";
        v13 = 1024;
        v14 = 712;
        _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, "VCSession [%s] %s:%d Reporting is disabled.", (uint8_t *)&v9, 0x1Cu);
      }
    }
    reportingSetNWActivityReportingEnabled();
    VCReporting_DisableDataCollection();
  }
}

void VCSession_RemoteScreenAttributesDidChange(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  _QWORD block[7];

  block[6] = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = *(NSObject **)(a1 + 176);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = __VCSession_RemoteScreenAttributesDidChange_block_invoke;
    block[3] = &unk_1E9E52238;
    block[4] = a2;
    block[5] = a1;
    dispatch_async(v2, block);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCSession_RemoteScreenAttributesDidChange_cold_1();
  }
}

uint64_t OUTLINED_FUNCTION_14_9@<X0>(void *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  *(_QWORD *)(v2 - 24) = a2;
  return objc_msgSend(a1, "idsParticipantID");
}

void sub_1D8D647A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t VCAudioRelayIOController_PullAudioSamples(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unsigned int SampleCount;
  uint64_t v6;
  double HostTime;
  int Timestamp;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v13[3];

  v13[2] = *MEMORY[0x1E0C80C00];
  _VCAudioRelayIOController_ProcessEventQueue((uint64_t)a1);
  VCAudioBufferList_ZeroMemory(a2);
  v13[0] = 0xAAAAAAAAAAAAAAAALL;
  v13[1] = 0xAAAAAAAAAAAAAAAALL;
  VCAudioIOControllerIOState_GetControllerTimestamp(a2, (uint64_t)a1, (uint64_t)v13);
  v4 = a1[11];
  SampleCount = VCAudioBufferList_GetSampleCount(a2);
  VCAudioBufferList_SetSampleCount(v4, SampleCount);
  v6 = a1[11];
  HostTime = VCAudioBufferList_GetHostTime(a2);
  Timestamp = VCAudioBufferList_GetTimestamp(a2);
  VCAudioBufferList_SetTime(v6, Timestamp, HostTime);
  v9 = (_QWORD *)a1[5];
  if (v9)
  {
    v10 = a2;
    do
    {
      v11 = v9[1];
      VCAudioBufferList_InvalidateNetworkTimestamp(v10);
      (*(void (**)(_QWORD, _QWORD *, uint64_t))(v11 + 8))(*(_QWORD *)v11, v13, v10);
      if (v10 != a2)
        VCAudioBufferList_Mix(a2, v10);
      v10 = a1[11];
      v9 = (_QWORD *)*v9;
    }
    while (v9);
  }
  return VCAudioLimiter_Process(a1[10], a2);
}

void _VCAudioRelayIOController_ProcessEventQueue(uint64_t a1)
{
  double v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;

  v2 = 0.0;
  if (VRTraceIsInternalOSInstalled())
    v2 = micro();
  v3 = CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 72));
  if (v3)
  {
    v4 = v3;
    v11 = 0;
    do
    {
      v12 = *((_DWORD *)v4 + 4);
      if (v12 == 1)
      {
        _VCAudioRelayIOController_UnregisterClientIO(a1, v4);
      }
      else if (!v12)
      {
        _VCAudioRelayIOController_RegisterClientIO(a1, v4);
      }
      v4 = CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 72));
      ++v11;
    }
    while (v4);
  }
  LogProfileTimeOverLimit(v2, 0, (uint64_t)v4, v5, v6, v7, v8, v9, v10, (char)"_VCAudioRelayIOController_ProcessEventQueue");
}

void VCAudioRelayIOController_PushAudioSamples(uint64_t a1, uint64_t a2)
{
  _QWORD *i;
  _QWORD v5[3];

  v5[2] = *MEMORY[0x1E0C80C00];
  _VCAudioRelayIOController_ProcessEventQueue(a1);
  v5[0] = 0xAAAAAAAAAAAAAAAALL;
  v5[1] = 0xAAAAAAAAAAAAAAAALL;
  VCAudioIOControllerIOState_GetControllerTimestamp(a2, a1, (uint64_t)v5);
  for (i = *(_QWORD **)(a1 + 40); i; i = (_QWORD *)*i)
    (*(void (**)(_QWORD, _QWORD *, uint64_t))(i[1] + 8))(*(_QWORD *)i[1], v5, a2);
}

uint64_t VCAudioRelayIOController_UpdateRemoteCodecInfo(void *a1, const char *a2)
{
  return objc_msgSend(a1, "didUpdateBasebandCodec:", a2);
}

void sub_1D8D653C8(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t _VCAudioRelayIOController_CompareControllerEntries(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  BOOL v4;
  unsigned int v5;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a2 + 8);
  v4 = v2 == v3;
  v5 = 2 * (v2 >= v3);
  if (v4)
    return 1;
  else
    return v5;
}

void sub_1D8D658EC(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void _VCAudioRelayIOController_RegisterClientIO(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v6 = a2[1];
      v7 = 136315906;
      v8 = v4;
      v9 = 2080;
      v10 = "_VCAudioRelayIOController_RegisterClientIO";
      v11 = 1024;
      v12 = 67;
      v13 = 2048;
      v14 = v6;
      _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Registering clientIO[%p]", (uint8_t *)&v7, 0x26u);
    }
  }
  if ((VCSingleLinkedListPush(a1 + 40, a2) & 1) == 0)
    free(a2);
}

void _VCAudioRelayIOController_UnregisterClientIO(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  _QWORD *v7;
  int v8;
  uint64_t v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v6 = a2[1];
      v8 = 136315906;
      v9 = v4;
      v10 = 2080;
      v11 = "_VCAudioRelayIOController_UnregisterClientIO";
      v12 = 1024;
      v13 = 57;
      v14 = 2048;
      v15 = v6;
      _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Unregistering clientIO[%p]", (uint8_t *)&v8, 0x26u);
    }
  }
  v7 = VCSingleLinkedListRemove(a1 + 40, (uint64_t)a2);
  if (v7)
    free(v7);
  free(a2);
}

uint64_t VCNWConnectionMonitorUtils_GetRATFromNWNotification(uint64_t a1)
{
  uint64_t result;

  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!(_DWORD)result)
        return result;
      VCNWConnectionMonitorUtils_GetRATFromNWNotification_cold_1();
    }
    return 0;
  }
  if (*(_DWORD *)(a1 + 4) == 2)
    return *(unsigned int *)(a1 + 8);
  else
    return *(unsigned __int8 *)(a1 + 60);
}

uint64_t VCNWConnectionMonitorUtils_GetSignalLevelFromNWNotification(uint64_t a1)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 4) == 2)
      return *(__int16 *)(a1 + 14);
    else
      return *(__int16 *)(a1 + 63);
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCNWConnectionMonitorUtils_GetSignalLevelFromNWNotification_cold_1();
    }
    return 0;
  }
}

void VCNWConnectionMonitorUtils_GetCDRXCycleFromNWNotification(uint64_t a1, _WORD *a2, _BYTE *a3)
{
  char v6;
  uint64_t v7;
  NSObject *v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  uint64_t v16;
  __int16 v17;
  _WORD *v18;
  __int16 v19;
  _BYTE *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (a1 && a2 && a3)
  {
    if (*(_DWORD *)(a1 + 4) == 4)
    {
      *a2 = *(_WORD *)(a1 + 10);
      v6 = *(_BYTE *)(a1 + 8);
    }
    else
    {
      *a2 = *(_WORD *)(a1 + 70);
      v6 = *(_BYTE *)(a1 + 69);
    }
    *a3 = v6;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v7 = VRTraceErrorLogLevelToCSTR();
    v8 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      v9 = 136316418;
      v10 = v7;
      v11 = 2080;
      v12 = "VCNWConnectionMonitorUtils_GetCDRXCycleFromNWNotification";
      v13 = 1024;
      v14 = 38;
      v15 = 2048;
      v16 = a1;
      v17 = 2048;
      v18 = a2;
      v19 = 2048;
      v20 = a3;
      _os_log_error_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_ERROR, " [%s] %s:%d Invalid input parameters. notification=%p, cdrxCycle=%p, cdrxState=%p", (uint8_t *)&v9, 0x3Au);
    }
  }
}

void VCNWConnectionMonitorUtils_GetNotificationFromAdvisory(__int128 *a1, uint64_t a2)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  char v8;
  unsigned int v9;
  int v10;
  int v11;

  if (a2)
  {
    if (a1)
    {
      *(_BYTE *)(a2 + 1) = *((_BYTE *)a1 + 1);
      *(_BYTE *)a2 = *(_BYTE *)a1;
      *(_BYTE *)(a2 + 2) = *((_BYTE *)a1 + 2);
      if (*((_BYTE *)a1 + 2) == 1)
      {
LABEL_4:
        *(_DWORD *)(a2 + 4) = 0;
        v4 = *a1;
        *(_OWORD *)(a2 + 24) = a1[1];
        *(_OWORD *)(a2 + 8) = v4;
        v5 = a1[2];
        v6 = a1[3];
        v7 = a1[4];
        *(_OWORD *)(a2 + 88) = a1[5];
        *(_OWORD *)(a2 + 72) = v7;
        *(_OWORD *)(a2 + 56) = v6;
        *(_OWORD *)(a2 + 40) = v5;
      }
      else
      {
        switch(*((_BYTE *)a1 + 3))
        {
          case 0:
            goto LABEL_4;
          case 1:
            *(_DWORD *)(a2 + 4) = 1;
            *(_QWORD *)(a2 + 16) = *((_QWORD *)a1 + 1);
            *(_DWORD *)(a2 + 8) = *((unsigned __int8 *)a1 + 52);
            *(_DWORD *)(a2 + 32) = *((_DWORD *)a1 + 10);
            *(_DWORD *)(a2 + 36) = *((_DWORD *)a1 + 11);
            *(_QWORD *)(a2 + 24) = *((_QWORD *)a1 + 3);
            return;
          case 2:
            *(_DWORD *)(a2 + 4) = 2;
            *(_DWORD *)(a2 + 8) = *((unsigned __int8 *)a1 + 52);
            *(_WORD *)(a2 + 12) = *(_WORD *)((char *)a1 + 53);
            *(_WORD *)(a2 + 14) = *(_WORD *)((char *)a1 + 55);
            *(_BYTE *)(a2 + 16) = *((_BYTE *)a1 + 57);
            *(_BYTE *)(a2 + 18) = *((_BYTE *)a1 + 59);
            *(_BYTE *)(a2 + 17) = *((_BYTE *)a1 + 58);
            return;
          case 3:
            *(_DWORD *)(a2 + 4) = 3;
            v8 = *((_BYTE *)a1 + 60);
            goto LABEL_14;
          case 4:
            *(_DWORD *)(a2 + 4) = 4;
            *(_WORD *)(a2 + 10) = *((_WORD *)a1 + 31);
            v8 = *((_BYTE *)a1 + 61);
LABEL_14:
            *(_BYTE *)(a2 + 8) = v8;
            return;
          case 5:
            *(_DWORD *)(a2 + 4) = 5;
            *(_WORD *)(a2 + 12) = *((_WORD *)a1 + 32);
            *(_BYTE *)(a2 + 14) = *((_BYTE *)a1 + 66);
            v9 = *((unsigned __int8 *)a1 + 52);
            goto LABEL_24;
          case 6:
            *(_DWORD *)(a2 + 4) = 6;
            v10 = *((_DWORD *)a1 + 1);
            if (v10 == 0x7FFFFFFF)
              v11 = 0x7FFFFFFF;
            else
              v11 = 0;
            if (!v10)
              v11 = 0;
            if (v10 == 0x80000000)
              v9 = 0x80000000;
            else
              v9 = v11;
LABEL_24:
            *(_DWORD *)(a2 + 8) = v9;
            break;
          default:
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                VCNWConnectionMonitorUtils_GetNotificationFromAdvisory_cold_3();
            }
            goto LABEL_4;
        }
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCNWConnectionMonitorUtils_GetNotificationFromAdvisory_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCNWConnectionMonitorUtils_GetNotificationFromAdvisory_cold_1();
  }
}

void _VCSystemAudioCaptureSession_audioSink(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  int32_t Count;
  int32_t v8;
  const void *v9;
  const void *v10;
  unsigned int SampleCount;
  double HostTime;
  int Timestamp;
  uint64_t v14;
  NSObject *v15;
  const char *v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  int32_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    v6 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        v18 = 136315906;
        v19 = v4;
        v20 = 2080;
        v21 = "_VCSystemAudioCaptureSession_audioSink";
        v22 = 1024;
        v23 = 171;
        v24 = 2048;
        v25 = a1;
        _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d %p audio sink buffer received", (uint8_t *)&v18, 0x26u);
      }
    }
    else if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      _VCSystemAudioCaptureSession_audioSink_cold_1();
    }
  }
  Count = CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 120));
  v8 = CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 128));
  v9 = CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 120));
  if (v9)
  {
    v10 = v9;
    VCAudioBufferList_Reset((uint64_t)v9);
    SampleCount = VCAudioBufferList_GetSampleCount(a2);
    HostTime = VCAudioBufferList_GetHostTime(a2);
    Timestamp = VCAudioBufferList_GetTimestamp(a2);
    VCAudioBufferList_SetSampleCount((uint64_t)v10, SampleCount);
    VCAudioBufferList_SetTime((uint64_t)v10, Timestamp, HostTime);
    VCAudioBufferList_ZeroMemory((uint64_t)v10);
    VCAudioBufferList_MixToMono((uint64_t)v10, a2);
    if (CMSimpleQueueEnqueue(*(CMSimpleQueueRef *)(a1 + 128), v10))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v14 = VRTraceErrorLogLevelToCSTR();
        v15 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v18 = 136316162;
          v19 = v14;
          v20 = 2080;
          v21 = "_VCSystemAudioCaptureSession_audioSink";
          v22 = 1024;
          v23 = 188;
          v24 = 2048;
          v25 = a1;
          v26 = 1024;
          v27 = v8;
          v16 = " [%s] %s:%d %p output queue full with count %d";
LABEL_16:
          _os_log_error_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_ERROR, v16, (uint8_t *)&v18, 0x2Cu);
        }
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v17 = VRTraceErrorLogLevelToCSTR();
    v15 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      v18 = 136316162;
      v19 = v17;
      v20 = 2080;
      v21 = "_VCSystemAudioCaptureSession_audioSink";
      v22 = 1024;
      v23 = 191;
      v24 = 2048;
      v25 = a1;
      v26 = 1024;
      v27 = Count;
      v16 = " [%s] %s:%d %p pool queue empty with count %d";
      goto LABEL_16;
    }
  }
}

const void *VCSystemAudioCaptureSession_pullAudioSamples(uint64_t a1)
{
  const void *v2;
  int32_t Count;
  int32_t v4;
  uint64_t v5;
  NSObject *v6;
  int32_t v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  int v12;
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  uint64_t v19;
  __int16 v20;
  int32_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v2 = CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 128));
  Count = CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 120));
  v4 = CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 128));
  if (v2)
  {
    if (CMSimpleQueueEnqueue(*(CMSimpleQueueRef *)(a1 + 120), v2))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v5 = VRTraceErrorLogLevelToCSTR();
        v6 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v12 = 136316162;
          v13 = v5;
          v14 = 2080;
          v15 = "VCSystemAudioCaptureSession_pullAudioSamples";
          v16 = 1024;
          v17 = 160;
          v18 = 2048;
          v19 = a1;
          v20 = 1024;
          v21 = Count;
          _os_log_error_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_ERROR, " [%s] %s:%d %p pool queue full with count %d", (uint8_t *)&v12, 0x2Cu);
        }
      }
    }
  }
  else
  {
    v7 = v4;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v8 = VRTraceErrorLogLevelToCSTR();
      v9 = *MEMORY[0x1E0CF2758];
      v10 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          v12 = 136316162;
          v13 = v8;
          v14 = 2080;
          v15 = "VCSystemAudioCaptureSession_pullAudioSamples";
          v16 = 1024;
          v17 = 164;
          v18 = 2048;
          v19 = a1;
          v20 = 1024;
          v21 = v7;
          _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d %p output queue empty with count %d", (uint8_t *)&v12, 0x2Cu);
        }
      }
      else if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        v12 = 136316162;
        v13 = v8;
        v14 = 2080;
        v15 = "VCSystemAudioCaptureSession_pullAudioSamples";
        v16 = 1024;
        v17 = 164;
        v18 = 2048;
        v19 = a1;
        v20 = 1024;
        v21 = v7;
        _os_log_debug_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEBUG, " [%s] %s:%d %p output queue empty with count %d", (uint8_t *)&v12, 0x2Cu);
      }
    }
  }
  return v2;
}

void VCAudioIOControllerIOState_GetControllerTimestamp(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int Timestamp;
  unsigned int SampleCount;
  float v8;
  double HostTime;
  double v10;
  double v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  NSObject *v18;
  double v19;
  double v20;
  uint64_t v21;
  NSObject *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  NSObject *v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  int v34;
  __int16 v35;
  uint64_t v36;
  __int16 v37;
  _BYTE v38[10];
  __int16 v39;
  _BYTE v40[20];
  _BYTE v41[10];
  __int16 v42;
  double v43;
  __int16 v44;
  uint64_t v45;
  __int16 v46;
  unint64_t v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  Timestamp = VCAudioBufferList_GetTimestamp(a1);
  SampleCount = VCAudioBufferList_GetSampleCount(a1);
  v8 = *(double *)VCAudioBufferList_GetSampleFormat(a1);
  HostTime = VCAudioBufferList_GetHostTime(a1);
  v10 = HostTime;
  if (*(_BYTE *)a2)
  {
    v11 = HostTime - *(double *)(a2 + 8);
    v12 = *(_DWORD *)(a2 + 20);
    v13 = v12 + *(_DWORD *)(a2 + 16);
    if (Timestamp == v13)
    {
      v14 = v12 * llround(v11 * (float)(v8 / (float)v12));
      v15 = *(_QWORD *)(a2 + 32);
      if (v14 == v12)
      {
        v16 = (unint64_t)((double)v15 + *(double *)(a2 + 24) * 409600.0);
      }
      else
      {
        v20 = *(double *)(a2 + 24);
        if (v11 >= v20)
          v20 = v10 - *(double *)(a2 + 8);
        v16 = v15 + (vcvtad_u64_f64(v20 * 409600.0) | 0x4119000000000000);
        VCAudioBufferList_SetHostTimeJumpSize(a1, v10 - *(double *)(a2 + 8));
        if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          v21 = VRTraceErrorLogLevelToCSTR();
          v22 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v23 = *(_DWORD *)(a2 + 16);
            v24 = *(_QWORD *)(a2 + 8);
            v25 = *(_QWORD *)(a2 + 32);
            v29 = 136318210;
            v30 = v21;
            v31 = 2080;
            v32 = "VCAudioIOControllerIOState_GetControllerTimestamp";
            v33 = 1024;
            v34 = 42;
            v35 = 2080;
            v36 = a2 + 128;
            v37 = 1024;
            *(_DWORD *)v38 = Timestamp - v23;
            *(_WORD *)&v38[4] = 1024;
            *(_DWORD *)&v38[6] = v23;
            v39 = 1024;
            *(_DWORD *)v40 = Timestamp;
            *(_WORD *)&v40[4] = 2048;
            *(double *)&v40[6] = v11;
            *(_WORD *)&v40[14] = 1024;
            *(_DWORD *)&v40[16] = v14;
            *(_WORD *)v41 = 2048;
            *(_QWORD *)&v41[2] = v24;
            v42 = 2048;
            v43 = v10;
            v44 = 2048;
            v45 = v25;
            v46 = 2048;
            v47 = v16;
            _os_log_impl(&dword_1D8A54000, v22, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d %s Real time miss. Timestamp jumped: delta=%u (%u to %u), host time: delta=%f (sampleCount=%d) (%f to %f). lastTimestamp=%llu -> timestamp=%llu", (uint8_t *)&v29, 0x70u);
          }
        }
      }
    }
    else
    {
      if (v11 >= *(double *)(a2 + 24))
      {
        v19 = v11 * 409600.0;
      }
      else
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v17 = VRTraceErrorLogLevelToCSTR();
          v18 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            v29 = 136316162;
            v30 = v17;
            v31 = 2080;
            v32 = "VCAudioIOControllerIOState_GetControllerTimestamp";
            v33 = 1024;
            v34 = 31;
            v35 = 2080;
            v36 = a2 + 128;
            v37 = 2048;
            *(double *)v38 = v11;
            _os_log_error_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_ERROR, " [%s] %s:%d %s Audio callback called too quickly. Delta:%f", (uint8_t *)&v29, 0x30u);
          }
        }
        v19 = *(double *)(a2 + 24) * 409600.0;
      }
      v16 = *(_QWORD *)(a2 + 32) + round(v19);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v26 = VRTraceErrorLogLevelToCSTR();
        v27 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v28 = *(_QWORD *)(a2 + 32);
          v29 = 136317186;
          v30 = v26;
          v31 = 2080;
          v32 = "VCAudioIOControllerIOState_GetControllerTimestamp";
          v33 = 1024;
          v34 = 36;
          v35 = 2080;
          v36 = a2 + 128;
          v37 = 1024;
          *(_DWORD *)v38 = Timestamp;
          *(_WORD *)&v38[4] = 1024;
          *(_DWORD *)&v38[6] = v13;
          v39 = 2048;
          *(double *)v40 = v11;
          *(_WORD *)&v40[8] = 2048;
          *(_QWORD *)&v40[10] = v28;
          *(_WORD *)&v40[18] = 2048;
          *(_QWORD *)v41 = v16;
          _os_log_error_impl(&dword_1D8A54000, v27, OS_LOG_TYPE_ERROR, " [%s] %s:%d %s Unexpected timestamp received: %u, expected:%u hostTimeDelta=%f lastTimestamp=%llu -> timestamp=%llu", (uint8_t *)&v29, 0x50u);
        }
      }
    }
  }
  else
  {
    v16 = 0;
  }
  *(_DWORD *)(a2 + 16) = Timestamp;
  *(_DWORD *)(a2 + 20) = SampleCount;
  *(double *)(a2 + 24) = (double)SampleCount / v8;
  *(double *)(a2 + 8) = v10;
  *(_QWORD *)(a2 + 32) = v16;
  *(_BYTE *)a2 = 1;
  if (a3)
  {
    *(_QWORD *)(a3 + 8) = v16;
    *(_DWORD *)a3 = 409600;
  }
}

_BYTE *VCAudioIOControllerIOState_ResetControllerTime(_BYTE *result)
{
  if (result)
    *result = 0;
  return result;
}

uint64_t VCCCMessageAcknowledgmentReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  int v15;
  char v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char v22;
  char v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  char v28;
  uint64_t result;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        v14 = v9++ >= 9;
        if (v14)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      if ((v10 >> 3) == 2)
      {
        v23 = 0;
        v24 = 0;
        v25 = 0;
        *(_BYTE *)(a1 + 20) |= 1u;
        while (1)
        {
          v26 = *v3;
          v27 = *(_QWORD *)(a2 + v26);
          if (v27 == -1 || v27 >= *(_QWORD *)(a2 + *v4))
            break;
          v28 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v27);
          *(_QWORD *)(a2 + v26) = v27 + 1;
          v25 |= (unint64_t)(v28 & 0x7F) << v23;
          if ((v28 & 0x80) == 0)
            goto LABEL_41;
          v23 += 7;
          v14 = v24++ >= 9;
          if (v14)
          {
            LODWORD(v25) = 0;
            goto LABEL_43;
          }
        }
        *(_BYTE *)(a2 + *v5) = 1;
LABEL_41:
        if (*(_BYTE *)(a2 + *v5))
          LODWORD(v25) = 0;
LABEL_43:
        *(_DWORD *)(a1 + 16) = v25;
      }
      else if ((v10 >> 3) == 1)
      {
        v17 = 0;
        v18 = 0;
        v19 = 0;
        while (1)
        {
          v20 = *v3;
          v21 = *(_QWORD *)(a2 + v20);
          if (v21 == -1 || v21 >= *(_QWORD *)(a2 + *v4))
            break;
          v22 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v21);
          *(_QWORD *)(a2 + v20) = v21 + 1;
          v19 |= (unint64_t)(v22 & 0x7F) << v17;
          if ((v22 & 0x80) == 0)
            goto LABEL_37;
          v17 += 7;
          v14 = v18++ >= 9;
          if (v14)
          {
            v19 = 0;
            goto LABEL_39;
          }
        }
        *(_BYTE *)(a2 + *v5) = 1;
LABEL_37:
        if (*(_BYTE *)(a2 + *v5))
          v19 = 0;
LABEL_39:
        *(_QWORD *)(a1 + 8) = v19;
      }
      else
      {
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
      }
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

uint64_t _VCConnectionIDS_SourceDestinationInfo(uint64_t a1, uint64_t a2)
{
  unsigned __int8 v4;
  int IsRelay;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  uint64_t result;
  _OWORD v10[7];
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v4 = objc_msgSend(*(id *)(a1 + 264), "linkID");
  IsRelay = VCConnection_IsRelay(a1);
  VCSDInfoConstructWithDatagramChannel(*(_QWORD *)(a1 + 280), v4, 0, IsRelay, (uint64_t)v10);
  v6 = v10[5];
  *(_OWORD *)(a2 + 64) = v10[4];
  *(_OWORD *)(a2 + 80) = v6;
  *(_OWORD *)(a2 + 96) = v10[6];
  *(_QWORD *)(a2 + 112) = v11;
  v7 = v10[1];
  *(_OWORD *)a2 = v10[0];
  *(_OWORD *)(a2 + 16) = v7;
  v8 = v10[3];
  *(_OWORD *)(a2 + 32) = v10[2];
  *(_OWORD *)(a2 + 48) = v8;
  result = VCConnection_IsLocalOnCellular(a1);
  *(_BYTE *)(a2 + 22) = result;
  return result;
}

BOOL _VCConnectionIDS_IsLocalOnCellular(uint64_t a1)
{
  int v1;
  BOOL v2;

  v1 = objc_msgSend(*(id *)(a1 + 264), "RATType");
  if (v1)
    v2 = v1 == 9;
  else
    v2 = 1;
  return !v2;
}

BOOL _VCConnectionIDS_IsRemoteOnCellular(uint64_t a1)
{
  int v1;
  BOOL v2;

  v1 = objc_msgSend(*(id *)(a1 + 264), "remoteRATType");
  if (v1)
    v2 = v1 == 9;
  else
    v2 = 1;
  return !v2;
}

BOOL _VCConnectionIDS_IsIPv6(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 264), "networkType") == 2
      || objc_msgSend(*(id *)(a1 + 264), "remoteNetworkType") == 2;
}

BOOL _VCConnectionIDS_IsRelay(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;

  v2 = objc_msgSend(*(id *)(a1 + 264), "connectionType");
  v3 = objc_msgSend(*(id *)(a1 + 264), "remoteConnectionType") - 2;
  return (unint64_t)(v2 - 2) < 4 || v3 < 4;
}

BOOL _VCConnectionIDS_MatchesSourceDestinationInfo(uint64_t a1, uint64_t a2)
{
  int v4;

  v4 = *(_DWORD *)(a1 + 272);
  return v4 == VCDatagramChannelIDS_Token(*(_QWORD *)(a2 + 112))
      && *(unsigned __int8 *)(a2 + 12) == objc_msgSend(*(id *)(a1 + 264), "linkID");
}

BOOL _VCConnectionIDS_Equal(uint64_t a1, uint64_t a2)
{
  int v3;

  v3 = objc_msgSend(*(id *)(a1 + 264), "linkID");
  return v3 == objc_msgSend(*(id *)(a2 + 264), "linkID");
}

uint64_t _VCConnectionIDS_LocalCellTech(uint64_t a1)
{
  return *(unsigned int *)(a1 + 292);
}

uint64_t _VCConnectionIDS_SetLocalCellTech(uint64_t a1, int a2)
{
  uint64_t result;

  result = VCConnection_IsLocalOnCellular(a1);
  if ((_DWORD)result)
    *(_DWORD *)(a1 + 292) = a2;
  return result;
}

uint64_t _VCConnectionIDS_RemoteCellTech(uint64_t a1)
{
  return *(unsigned int *)(a1 + 296);
}

uint64_t _VCConnectionIDS_SetRemoteCellTech(uint64_t a1, int a2)
{
  uint64_t result;

  result = VCConnection_IsRemoteOnCellular(a1);
  if ((_DWORD)result)
    *(_DWORD *)(a1 + 296) = a2;
  return result;
}

CFStringRef _VCConnectionIDS_CopyDescription(uint64_t a1)
{
  const char *v2;
  const char *v3;
  int IsRelay;
  const char *v5;
  int IsIPv6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  _BOOL8 v18;
  unsigned int IsRemoteExpensive;
  unsigned int IsLocalExpensive;
  unsigned int IsRemoteConstrained;
  unsigned int IsLocalConstrained;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  const char *v30;
  int v31;
  uint64_t v32;
  const char *ClassName;
  const char *v34;
  const __CFAllocator *v35;
  const char *v36;

  if ((VCConnection_IsLocalOnCellular(a1) & 1) != 0)
  {
    v2 = "Cell";
  }
  else if (VCConnection_IsLocalOnWiFi(a1))
  {
    v2 = "WiFi";
  }
  else
  {
    v2 = "Wired";
  }
  v36 = v2;
  if ((VCConnection_IsRemoteOnCellular(a1) & 1) != 0)
  {
    v3 = "Cell";
  }
  else if (VCConnection_IsRemoteOnWiFi(a1))
  {
    v3 = "WiFi";
  }
  else
  {
    v3 = "Wired";
  }
  v34 = v3;
  v35 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  ClassName = object_getClassName((id)a1);
  v32 = *(unsigned int *)(a1 + 272);
  v31 = objc_msgSend(*(id *)(a1 + 264), "linkID");
  IsRelay = VCConnection_IsRelay(a1);
  v5 = "P2P";
  if (IsRelay)
    v5 = "Relay";
  v30 = v5;
  IsIPv6 = VCConnection_IsIPv6(a1);
  v7 = "IPv4";
  if (IsIPv6)
    v7 = "IPv6";
  v29 = v7;
  v28 = *(unsigned int *)(a1 + 28);
  v27 = *(unsigned int *)(a1 + 308);
  v26 = *(unsigned int *)(a1 + 312);
  v25 = *(unsigned int *)(a1 + 316);
  v24 = *(unsigned int *)(a1 + 320);
  IsLocalConstrained = VCConnection_IsLocalConstrained(a1);
  IsRemoteConstrained = VCConnection_IsRemoteConstrained(a1);
  IsLocalExpensive = VCConnection_IsLocalExpensive(a1);
  IsRemoteExpensive = VCConnection_IsRemoteExpensive(a1);
  v8 = *(unsigned __int8 *)(a1 + 324);
  v9 = *(unsigned __int8 *)(a1 + 325);
  v10 = *(unsigned __int8 *)(a1 + 326);
  v11 = VCConnection_ReportingIPVersion(a1);
  v12 = *(unsigned __int8 *)(a1 + 327);
  v13 = *(_QWORD *)(a1 + 328);
  v14 = *(_QWORD *)(a1 + 336);
  v15 = objc_msgSend(*(id *)(a1 + 264), "connectionType");
  v16 = objc_msgSend(*(id *)(a1 + 264), "remoteConnectionType") - 2;
  v18 = (unint64_t)(v15 - 2) < 4 || v16 < 4;
  return CFStringCreateWithFormat(v35, 0, CFSTR("<%s:%p> Token (%d) Link (%d): %s <-> %s (%s, %s), priority %d, uplink bitrate cap (%u), downlink bitrate cap (%u), uplink audio only bitrate cap = (%u), uplink OneToOne bitrate cap = (%u), isLocalConstrained (%d), isRemoteConstrained (%d), isLocalExpensive (%d) isRemoteExpensive (%d) isLocalDelegated (%d) isRemoteDelegated (%d) isVirtualRelayLink (%d) reportingIPVersion(%d) TransportLayerEncryption=%d relayProtocolStackDescrption(%@) channelDataBaseProtocolStackDescription(%@) _isHopByHopEncryptionSupported=%d"), ClassName, a1, v32, v31, v36, v34, v30, v29, v28, v27, v26, v25, v24, IsLocalConstrained, IsRemoteConstrained, IsLocalExpensive,
           IsRemoteExpensive,
           v8,
           v9,
           v10,
           v11,
           v12,
           v13,
           v14,
           v18);
}

BOOL _VCConnectionIDS_IsLocalOnWiFiOrWired(uint64_t a1)
{
  int v1;

  v1 = objc_msgSend(*(id *)(a1 + 264), "RATType");
  return !v1 || v1 == 9;
}

BOOL _VCConnectionIDS_IsRemoteOnWiFiOrWired(uint64_t a1)
{
  int v1;

  v1 = objc_msgSend(*(id *)(a1 + 264), "remoteRATType");
  return !v1 || v1 == 9;
}

BOOL _VCConnectionIDS_IsLocalOnWiFi(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 264), "RATType") == 0;
}

BOOL _VCConnectionIDS_IsRemoteOnWiFi(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 264), "remoteRATType") == 0;
}

BOOL _VCConnectionIDS_IsLocalOnWired(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 264), "RATType") == 9;
}

BOOL _VCConnectionIDS_IsRemoteOnWired(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 264), "remoteRATType") == 9;
}

uint64_t _VCConnectionIDS_IsOnSameInterfacesWithConnection(void *a1, void *a2)
{
  int ErrorLogLevelForModule;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  uint64_t v11;
  int IsLocalOnWiFiOrWired;
  uint64_t v13;
  NSObject *v14;
  NSObject *v15;
  const char *v16;
  int IsRemoteOnWiFiOrWired;
  int IsLocalOnWired;
  uint64_t v19;
  NSObject *v20;
  int IsRemoteOnWired;
  uint64_t v22;
  NSObject *v23;
  NSObject *v24;
  int v26;
  uint64_t v27;
  __int16 v28;
  const char *v29;
  __int16 v30;
  int v31;
  __int16 v32;
  uint64_t v33;
  __int16 v34;
  uint64_t v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (!a2)
  {
    if (ErrorLogLevelForModule >= 8)
    {
      v8 = VRTraceErrorLogLevelToCSTR();
      v9 = *MEMORY[0x1E0CF2758];
      v10 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        v11 = 0;
        if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
          return v11;
        v26 = 136315650;
        v27 = v8;
        v28 = 2080;
        v29 = "_VCConnectionIDS_IsOnSameInterfacesWithConnection";
        v30 = 1024;
        v31 = 470;
        _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCConnection: connection to check is nil", (uint8_t *)&v26, 0x1Cu);
      }
      else if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        _VCConnectionIDS_IsOnSameInterfacesWithConnection_cold_1();
      }
    }
    return 0;
  }
  if (ErrorLogLevelForModule >= 8)
  {
    v5 = VRTraceErrorLogLevelToCSTR();
    v6 = *MEMORY[0x1E0CF2758];
    v7 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        v26 = 136316162;
        v27 = v5;
        v28 = 2080;
        v29 = "_VCConnectionIDS_IsOnSameInterfacesWithConnection";
        v30 = 1024;
        v31 = 476;
        v32 = 2080;
        v33 = objc_msgSend((id)objc_msgSend(a1, "description"), "UTF8String");
        v34 = 2080;
        v35 = objc_msgSend((id)objc_msgSend(a2, "description"), "UTF8String");
        _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCConnection: isOnSameInterfacesWithConnection: %s vs. %s", (uint8_t *)&v26, 0x30u);
      }
    }
    else if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      v26 = 136316162;
      v27 = v5;
      v28 = 2080;
      v29 = "_VCConnectionIDS_IsOnSameInterfacesWithConnection";
      v30 = 1024;
      v31 = 476;
      v32 = 2080;
      v33 = objc_msgSend((id)objc_msgSend(a1, "description"), "UTF8String");
      v34 = 2080;
      v35 = objc_msgSend((id)objc_msgSend(a2, "description"), "UTF8String");
      _os_log_debug_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEBUG, " [%s] %s:%d VCConnection: isOnSameInterfacesWithConnection: %s vs. %s", (uint8_t *)&v26, 0x30u);
    }
  }
  IsLocalOnWiFiOrWired = VCConnection_IsLocalOnWiFiOrWired((uint64_t)a1);
  if (IsLocalOnWiFiOrWired == VCConnection_IsLocalOnWiFiOrWired((uint64_t)a2)
    && (IsRemoteOnWiFiOrWired = VCConnection_IsRemoteOnWiFiOrWired((uint64_t)a1),
        IsRemoteOnWiFiOrWired == VCConnection_IsRemoteOnWiFiOrWired((uint64_t)a2)))
  {
    IsLocalOnWired = VCConnection_IsLocalOnWired((uint64_t)a1);
    if (IsLocalOnWired == VCConnection_IsLocalOnWired((uint64_t)a2))
    {
      IsRemoteOnWired = VCConnection_IsRemoteOnWired((uint64_t)a1);
      if (IsRemoteOnWired == VCConnection_IsRemoteOnWired((uint64_t)a2))
      {
        v11 = 1;
        goto LABEL_34;
      }
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v19 = VRTraceErrorLogLevelToCSTR();
      v14 = *MEMORY[0x1E0CF2758];
      v20 = *MEMORY[0x1E0CF2758];
      if (!*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
          _VCConnectionIDS_IsOnSameInterfacesWithConnection_cold_4();
        goto LABEL_33;
      }
      v11 = 0;
      if (!os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        goto LABEL_34;
      v26 = 136315650;
      v27 = v19;
      v28 = 2080;
      v29 = "_VCConnectionIDS_IsOnSameInterfacesWithConnection";
      v30 = 1024;
      v31 = 481;
      v16 = " [%s] %s:%d Different wired interface type";
      goto LABEL_23;
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v13 = VRTraceErrorLogLevelToCSTR();
    v14 = *MEMORY[0x1E0CF2758];
    v15 = *MEMORY[0x1E0CF2758];
    if (!*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
        _VCConnectionIDS_IsOnSameInterfacesWithConnection_cold_3();
      goto LABEL_33;
    }
    v11 = 0;
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      goto LABEL_34;
    v26 = 136315650;
    v27 = v13;
    v28 = 2080;
    v29 = "_VCConnectionIDS_IsOnSameInterfacesWithConnection";
    v30 = 1024;
    v31 = 478;
    v16 = " [%s] %s:%d Different non-cell interface type";
LABEL_23:
    _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, v16, (uint8_t *)&v26, 0x1Cu);
  }
LABEL_33:
  v11 = 0;
LABEL_34:
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v22 = VRTraceErrorLogLevelToCSTR();
    v23 = *MEMORY[0x1E0CF2758];
    v24 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        v26 = 136315906;
        v27 = v22;
        v28 = 2080;
        v29 = "_VCConnectionIDS_IsOnSameInterfacesWithConnection";
        v30 = 1024;
        v31 = 484;
        v32 = 1024;
        LODWORD(v33) = v11;
        _os_log_impl(&dword_1D8A54000, v23, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCConnection: isOnSameInterfacesWithConnection: %{BOOL}d", (uint8_t *)&v26, 0x22u);
      }
    }
    else if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
    {
      _VCConnectionIDS_IsOnSameInterfacesWithConnection_cold_2(v22, v11, v23);
    }
  }
  return v11;
}

uint64_t _VCConnectionIDS_IsEndToEndLink(uint64_t a1)
{
  *(_BYTE *)(a1 + 326) = objc_msgSend(*(id *)(a1 + 264), "isVirtualRelayLink");
  if (*(_BYTE *)(a1 + 326))
    return 1;
  else
    return VCConnection_IsRelay(a1) ^ 1;
}

uint64_t _VCConnectionIDS_ConnectionID(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 264), "linkID");
}

uint64_t _VCConnectionIDS_IsLocalExpensive(uint64_t a1)
{
  return *(_WORD *)(a1 + 8) & 1;
}

uint64_t _VCConnectionIDS_IsLocalConstrained(uint64_t a1)
{
  return (*(unsigned __int16 *)(a1 + 8) >> 1) & 1;
}

uint64_t _VCConnectionIDS_IsRemoteExpensive(uint64_t a1)
{
  return *(_WORD *)(a1 + 10) & 1;
}

uint64_t _VCConnectionIDS_IsRemoteConstrained(uint64_t a1)
{
  return (*(unsigned __int16 *)(a1 + 10) >> 1) & 1;
}

uint64_t _VCConnectionIDS_ReportingIPVersion(uint64_t a1)
{
  char v2;
  BOOL v3;
  unsigned int v4;

  v2 = objc_msgSend(*(id *)(a1 + 264), "localLinkFlags");
  if (objc_msgSend(*(id *)(a1 + 264), "networkType") == 2
    || objc_msgSend(*(id *)(a1 + 264), "remoteNetworkType") == 2)
  {
    v3 = (v2 & 0x10) == 0;
    v4 = 3;
  }
  else
  {
    v3 = (v2 & 8) == 0;
    v4 = 1;
  }
  if (v3)
    return v4;
  else
    return v4 + 1;
}

BOOL _VCConnectionIDS_ReportingQRServerConfig(uint64_t a1, void *a2)
{
  _BOOL8 result;
  uint64_t v5;
  NSObject *v6;
  int v7;
  uint64_t v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  uint64_t v14;
  __int16 v15;
  void *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (!a1 || !a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v6 = *MEMORY[0x1E0CF2758];
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      v7 = 136316162;
      v8 = v5;
      v9 = 2080;
      v10 = "_VCConnectionIDS_ReportingQRServerConfig";
      v11 = 1024;
      v12 = 634;
      v13 = 2112;
      v14 = a1;
      v15 = 2112;
      v16 = a2;
      _os_log_error_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_ERROR, " [%s] %s:%d Argument not valid context=%@ and dictionary=%@", (uint8_t *)&v7, 0x30u);
    }
    return 0;
  }
  if (objc_msgSend(*(id *)(a1 + 264), "qrExperiments"))
  {
    objc_msgSend(a2, "addEntriesFromDictionary:", objc_msgSend(*(id *)(a1 + 264), "qrExperiments"));
    return 1;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() < 3)
    return 0;
  VRTraceErrorLogLevelToCSTR();
  result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
  if (result)
  {
    _VCConnectionIDS_ReportingQRServerConfig_cold_1();
    return 0;
  }
  return result;
}

BOOL _VCConnectionIDS_IsHopByHopEncryptionSupported(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;

  v2 = objc_msgSend(*(id *)(a1 + 264), "connectionType");
  v3 = objc_msgSend(*(id *)(a1 + 264), "remoteConnectionType") - 2;
  return (unint64_t)(v2 - 2) < 4 || v3 < 4;
}

BOOL VCConnectionIDSIsCellularRATType(int a1)
{
  BOOL v1;

  if (a1)
    v1 = a1 == 9;
  else
    v1 = 1;
  return !v1;
}

uint64_t VCConnectionIDSCellTechForRATType(uint64_t result)
{
  unsigned int v1;
  uint64_t v2;
  NSObject *v3;
  _BOOL4 v4;
  int v5;
  uint64_t v6;
  __int16 v7;
  const char *v8;
  __int16 v9;
  int v10;
  __int16 v11;
  uint64_t v12;
  uint64_t v13;

  v1 = result;
  v13 = *MEMORY[0x1E0C80C00];
  if (result >= 8)
  {
    if ((_DWORD)result == 1010)
      return 9;
    if ((_DWORD)result == 1009)
      return 8;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v2 = VRTraceErrorLogLevelToCSTR();
      v3 = *MEMORY[0x1E0CF2758];
      v4 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
      result = 0;
      if (!v4)
        return result;
      v5 = 136315906;
      v6 = v2;
      v7 = 2080;
      v8 = "VCConnectionIDSCellTechForRATType";
      v9 = 1024;
      v10 = 567;
      v11 = 2048;
      v12 = v1;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Unknown IDSDataChannelRATType %lu", (uint8_t *)&v5, 0x26u);
    }
    return 0;
  }
  return result;
}

uint64_t VCConnectionIDS_NetworkOverheadInBytes(uint64_t a1, int a2, int a3)
{
  int v5;
  int v6;
  uint64_t result;
  uint64_t v8;
  NSObject *v9;
  _BOOL4 v10;
  int v11;
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (VCConnection_IsIPv6(a1))
      v5 = 48;
    else
      v5 = 28;
    if (a3)
      v6 = 30;
    else
      v6 = 29;
    return ((a2 > 1) | (2 * a2)) + v6 + 8 * (a2 != 0) + v5;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v8 = VRTraceErrorLogLevelToCSTR();
      v9 = *MEMORY[0x1E0CF2758];
      v10 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
      result = 0;
      if (!v10)
        return result;
      v11 = 136315650;
      v12 = v8;
      v13 = 2080;
      v14 = "VCConnectionIDS_NetworkOverheadInBytes";
      v15 = 1024;
      v16 = 336;
      _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v11, 0x1Cu);
    }
    return 0;
  }
}

uint64_t VCConnection_GetWorstCaseNetworkOverhead(int a1, int a2)
{
  int v2;

  if (a2)
    v2 = 45;
  else
    v2 = 44;
  return ((a1 > 1) | (2 * a1)) + v2 + 56;
}

uint64_t VCConnection_GetFacetimeNetworkOverhead(int a1)
{
  if (a1)
    return 68;
  else
    return 48;
}

uint64_t VCConnectionIDS_LinkID(uint64_t a1)
{
  uint64_t result;
  uint64_t v2;
  NSObject *v3;
  _BOOL4 v4;
  int v5;
  uint64_t v6;
  __int16 v7;
  const char *v8;
  __int16 v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v2 = VRTraceErrorLogLevelToCSTR();
      v3 = *MEMORY[0x1E0CF2758];
      v4 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
      LOBYTE(result) = 0;
      if (!v4)
        return result;
      v5 = 136315650;
      v6 = v2;
      v7 = 2080;
      v8 = "VCConnectionIDS_LinkID";
      v9 = 1024;
      v10 = 516;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v5, 0x1Cu);
    }
    LOBYTE(result) = 0;
    return result;
  }
  LOBYTE(result) = objc_msgSend(*(id *)(a1 + 264), "linkID");
  return result;
}

BOOL VCConnectionIDS_MatchesChannelTokenWithSourceDestinationInfo(uint64_t a1, uint64_t a2)
{
  int v4;
  _BOOL8 result;
  uint64_t v6;
  NSObject *v7;
  _BOOL4 v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  uint64_t v16;
  __int16 v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (a1 && a2)
  {
    v4 = *(_DWORD *)(a1 + 272);
    return v4 == VCDatagramChannelIDS_Token(*(_QWORD *)(a2 + 112));
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v6 = VRTraceErrorLogLevelToCSTR();
    v7 = *MEMORY[0x1E0CF2758];
    v8 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v8)
      return result;
    v9 = 136316162;
    v10 = v6;
    v11 = 2080;
    v12 = "VCConnectionIDS_MatchesChannelTokenWithSourceDestinationInfo";
    v13 = 1024;
    v14 = 538;
    v15 = 2048;
    v16 = a1;
    v17 = 2048;
    v18 = a2;
    _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance=%p or sourceDestinationInfo=%p passed", (uint8_t *)&v9, 0x30u);
  }
  return 0;
}

BOOL VCConnectionIDS_IsQUICPod(uint64_t a1)
{
  _BOOL8 result;
  uint64_t v2;
  NSObject *v3;
  _BOOL4 v4;
  int v5;
  uint64_t v6;
  __int16 v7;
  const char *v8;
  __int16 v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (a1)
    return *(_BYTE *)(a1 + 327) != 0;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    v4 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v4)
      return result;
    v5 = 136315650;
    v6 = v2;
    v7 = 2080;
    v8 = "VCConnectionIDS_IsQUICPod";
    v9 = 1024;
    v10 = 623;
    _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil context passed", (uint8_t *)&v5, 0x1Cu);
  }
  return 0;
}

BOOL VCConnectionIDSIsKnownRATType(unsigned int a1)
{
  uint64_t v2;
  NSObject *v3;
  int v5;
  uint64_t v6;
  __int16 v7;
  const char *v8;
  __int16 v9;
  int v10;
  __int16 v11;
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (a1 >= 0xA && (int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v5 = 136315906;
      v6 = v2;
      v7 = 2080;
      v8 = "VCConnectionIDSIsKnownRATType";
      v9 = 1024;
      v10 = 670;
      v11 = 2048;
      v12 = a1;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Unknown IDSDataChannelRATType %lu", (uint8_t *)&v5, 0x26u);
    }
  }
  return a1 < 0xA;
}

const char *VCConnectionIDSRATTypeToStr(int a1)
{
  const char *result;

  result = "Unknown";
  switch(a1)
  {
    case 0:
      return result;
    case 1:
      result = "UMTS";
      break;
    case 2:
      result = "GSM";
      break;
    case 3:
      result = "C2K";
      break;
    case 4:
      result = "C2K1x";
      break;
    case 5:
      result = "LTE";
      break;
    case 6:
      result = "HSPA+";
      break;
    case 7:
      result = "UTRAN";
      break;
    case 8:
      goto LABEL_4;
    case 9:
      result = "Wired";
      break;
    default:
      if ((a1 - 1009) >= 2)
        result = "Invalid";
      else
LABEL_4:
        result = "5G";
      break;
  }
  return result;
}

BOOL VCVideoAttributes_IsEqual(uint64_t a1, uint64_t a2)
{
  _BOOL8 result;
  BOOL v5;

  if (a1 == a2)
    return 1;
  result = 0;
  if (a1 && a2)
  {
    v5 = *(double *)(a1 + 8) == *(double *)(a2 + 8) && *(double *)(a1 + 16) == *(double *)(a2 + 16);
    return v5
        && *(_DWORD *)(a1 + 24) == *(_DWORD *)(a2 + 24)
        && *(_DWORD *)(a1 + 28) == *(_DWORD *)(a2 + 28)
        && *(unsigned __int8 *)(a1 + 32) == *(unsigned __int8 *)(a2 + 32)
        && *(unsigned __int8 *)(a1 + 72) == *(unsigned __int8 *)(a2 + 72)
        && *(unsigned __int8 *)(a1 + 73) == *(unsigned __int8 *)(a2 + 73)
        && CGRectEqualToRect(*(CGRect *)(a1 + 40), *(CGRect *)(a2 + 40))
        && *(float *)(a1 + 100) == *(float *)(a2 + 100);
  }
  return result;
}

void VCRateControlAlgorithmStabilizedNOWRDPriv_Configure(uint64_t a1, void *__src, int a3)
{
  uint64_t v6;
  VCRateControlSmartBrake *v7;
  uint64_t v8;
  const __CFString *v9;
  const __CFString *v10;
  uint64_t v11;
  NSObject *v12;
  int v13;
  const char *v14;
  NSObject *v15;
  uint32_t v16;
  uint64_t v17;
  NSObject *v18;
  int v19;
  uint64_t v20;
  NSObject *v21;
  char v22;
  char v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  NSObject *v32;
  int v33;
  uint64_t v34;
  int v35;
  int v36;
  uint8_t buf[4];
  uint64_t v38;
  __int16 v39;
  const char *v40;
  __int16 v41;
  int v42;
  __int16 v43;
  _BYTE v44[10];
  uint64_t v45;
  __int16 v46;
  int v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (__src)
    {
      memcpy((void *)(a1 + 40), __src, 0x3D0uLL);
      VCRateControlAlgorithmStabilizedNOWRDPriv_SetBitrateUnstable(a1);
      *(_BYTE *)(a1 + 1121) = 0;
      *(_BYTE *)(a1 + 25528) = 0;
      *(_BYTE *)(a1 + 5292) = *((_BYTE *)__src + 368);
      v6 = *(_QWORD *)(a1 + 25536);
      if (*(_DWORD *)(a1 + 848))
      {
        if (!v6)
        {
          v7 = objc_alloc_init(VCRateControlSmartBrake);
          *(_QWORD *)(a1 + 25536) = v7;
          v8 = objc_opt_class();
          if (!v7)
          {
            if (v8 == a1)
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  VCRateControlAlgorithmStabilizedNOWRDPriv_Configure_cold_3();
              }
            }
            else
            {
              if ((objc_opt_respondsToSelector() & 1) != 0)
                v10 = (const __CFString *)objc_msgSend((id)a1, "performSelector:", sel_logPrefix);
              else
                v10 = &stru_1E9E58EE0;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                v20 = VRTraceErrorLogLevelToCSTR();
                v21 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136316162;
                  v38 = v20;
                  v39 = 2080;
                  v40 = "_VCRateControlAlgorithmStabilizedNOWRD_InitSmartBrake";
                  v41 = 1024;
                  v42 = 256;
                  v43 = 2112;
                  *(_QWORD *)v44 = v10;
                  *(_WORD *)&v44[8] = 2048;
                  v45 = a1;
                  _os_log_error_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_ERROR, "VCRC [%s] %s:%d %@(%p) Could not initialize smart brake in rate control algorithm.", buf, 0x30u);
                }
              }
            }
            *(_DWORD *)(a1 + 848) = 0;
            goto LABEL_30;
          }
          if (v8 == a1)
          {
            if ((int)VRTraceGetErrorLogLevelForModule() < 7)
              goto LABEL_30;
            v11 = VRTraceErrorLogLevelToCSTR();
            v12 = *MEMORY[0x1E0CF2758];
            if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              goto LABEL_30;
            v13 = *(_DWORD *)(a1 + 848);
            *(_DWORD *)buf = 136315906;
            v38 = v11;
            v39 = 2080;
            v40 = "_VCRateControlAlgorithmStabilizedNOWRD_InitSmartBrake";
            v41 = 1024;
            v42 = 259;
            v43 = 1024;
            *(_DWORD *)v44 = v13;
            v14 = "VCRC [%s] %s:%d Smart brake init with smartBrakeStrategy=%d";
            v15 = v12;
            v16 = 34;
          }
          else
          {
            if ((objc_opt_respondsToSelector() & 1) != 0)
              v9 = (const __CFString *)objc_msgSend((id)a1, "performSelector:", sel_logPrefix);
            else
              v9 = &stru_1E9E58EE0;
            if ((int)VRTraceGetErrorLogLevelForModule() < 7)
              goto LABEL_30;
            v17 = VRTraceErrorLogLevelToCSTR();
            v18 = *MEMORY[0x1E0CF2758];
            if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              goto LABEL_30;
            v19 = *(_DWORD *)(a1 + 848);
            *(_DWORD *)buf = 136316418;
            v38 = v17;
            v39 = 2080;
            v40 = "_VCRateControlAlgorithmStabilizedNOWRD_InitSmartBrake";
            v41 = 1024;
            v42 = 259;
            v43 = 2112;
            *(_QWORD *)v44 = v9;
            *(_WORD *)&v44[8] = 2048;
            v45 = a1;
            v46 = 1024;
            v47 = v19;
            v14 = "VCRC [%s] %s:%d %@(%p) Smart brake init with smartBrakeStrategy=%d";
            v15 = v18;
            v16 = 54;
          }
          _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, v14, buf, v16);
LABEL_30:
          *(_DWORD *)(a1 + 5148) = 0;
          objc_msgSend(*(id *)(a1 + 25536), "config");
          *(_BYTE *)(a1 + 5172) = v22;
          goto LABEL_31;
        }
      }
      else if (!v6)
      {
LABEL_31:
        *(_QWORD *)(a1 + 4960) = 0;
        *(_QWORD *)(a1 + 5008) = *(_QWORD *)(a1 + 728);
        VCRateControlAlgorithmBasePriv_ResetLossEventBuffer(a1);
        *(_DWORD *)(a1 + 1116) = -1;
        if (a3)
        {
          *(_DWORD *)(a1 + 1040) = 1;
          *(_DWORD *)(a1 + 1052) = *(_DWORD *)(a1 + 56);
        }
        v23 = 1;
        if (!*(_BYTE *)(a1 + 411))
        {
          *(_DWORD *)(a1 + 5256) = 0;
          *(_DWORD *)(a1 + 5260) = 0;
          *(_QWORD *)(a1 + 5264) = 0;
          v23 = *(_BYTE *)(a1 + 411);
        }
        *(_BYTE *)(a1 + 5280) = v23;
        v24 = *(_DWORD *)(a1 + 1052);
        if (v24 >= *(_DWORD *)(a1 + 60))
          v24 = *(_DWORD *)(a1 + 60);
        if (v24 <= *(_DWORD *)(a1 + 64))
          v24 = *(_DWORD *)(a1 + 64);
        *(_DWORD *)(a1 + 1052) = v24;
        *(_DWORD *)(a1 + 1072) = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * *(int *)(a1 + 1052));
        VCRateControlMediaController_SetMinTargetBitrate(*(_QWORD *)(a1 + 1016), *(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * *(int *)(a1 + 64)));
        VCRateControlAlgorithmBasePriv_ResetOWRDList(a1);
        *(_DWORD *)(a1 + 5284) = 0;
        *(_DWORD *)(a1 + 5288) = 0;
        *(_BYTE *)(a1 + 2840) = 1;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v31 = VRTraceErrorLogLevelToCSTR();
          v32 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v33 = *(_DWORD *)(a1 + 1072);
            v34 = *(_QWORD *)(a1 + 48);
            v35 = *(_DWORD *)(v34 + 4 * *(int *)(a1 + 64));
            v36 = *(_DWORD *)(v34 + 4 * *(int *)(a1 + 60));
            *(_DWORD *)buf = 136316418;
            v38 = v31;
            v39 = 2080;
            v40 = "VCRateControlAlgorithmStabilizedNOWRDPriv_Configure";
            v41 = 1024;
            v42 = 239;
            v43 = 1024;
            *(_DWORD *)v44 = v33;
            *(_WORD *)&v44[4] = 1024;
            *(_DWORD *)&v44[6] = v35;
            LOWORD(v45) = 1024;
            *(_DWORD *)((char *)&v45 + 2) = v36;
            _os_log_impl(&dword_1D8A54000, v32, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Configuring VCRateControl algorithm with targetBitrate=%d, minBitrate=%d, maxBitrate=%d", buf, 0x2Eu);
          }
        }
        VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Configure with targetBitrate=%d, minBitrate=%d, maxBitrate=%d", v25, v26, v27, v28, v29, v30, *(_DWORD *)(a1 + 1072));
        return;
      }
      VCRateControlSmartBrake_ResetState(v6);
      goto LABEL_31;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCRateControlAlgorithmStabilizedNOWRDPriv_Configure_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlAlgorithmStabilizedNOWRDPriv_Configure_cold_1();
  }
}

BOOL _VCRateControlAlgorithmStabilizedNOWRD_DoRateControl(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10)
{
  int v12;
  _BOOL8 result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int ShouldRampDown;
  int v22;
  unint64_t v23;
  double v24;
  float v25;
  float v26;
  unsigned int v27;
  unsigned int v28;
  uint64_t v30;
  NSObject *v31;
  uint64_t v32;
  double v33;
  uint64_t v34;
  int v35;
  double v36;
  int v37;
  double v38;
  int v39;
  int v40;
  float v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  double v50;
  double v51;
  unsigned int v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  int v58;
  unsigned int v59;
  int v60;
  int v61;
  uint64_t v62;
  char v63;
  char v64;
  int v65;
  uint64_t v66;
  NSObject *v67;
  int v68;
  double v69;
  double v70;
  unsigned int v71;
  int v72;
  unsigned int v73;
  unsigned int v74;
  int v75;
  const char *v76;
  const char *v77;
  int v78;
  _BOOL4 IsVideoStopped;
  BOOL v80;
  int v81;
  double v82;
  int v83;
  uint64_t v84;
  uint64_t v85;
  double v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  unint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  unint64_t v97;
  uint64_t v98;
  unsigned int v99;
  int v100;
  int v101;
  int v102;
  unsigned int v103;
  int v104;
  int v105;
  int v106;
  int v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  int v113;
  uint64_t v114;
  uint8_t buf[4];
  uint64_t v116;
  __int16 v117;
  const char *v118;
  __int16 v119;
  int v120;
  __int16 v121;
  uint64_t v122;
  __int16 v123;
  int v124;
  __int16 v125;
  uint64_t v126;
  __int16 v127;
  uint64_t v128;
  __int16 v129;
  uint64_t v130;
  __int16 v131;
  uint64_t v132;
  __int16 v133;
  int v134;
  __int16 v135;
  int v136;
  __int16 v137;
  double v138;
  __int16 v139;
  double v140;
  __int16 v141;
  int v142;
  __int16 v143;
  int v144;
  __int16 v145;
  unsigned int v146;
  __int16 v147;
  unsigned int v148;
  __int16 v149;
  int v150;
  __int16 v151;
  int v152;
  __int16 v153;
  int v154;
  __int16 v155;
  unsigned int v156;
  __int16 v157;
  int v158;
  __int16 v159;
  unsigned int v160;
  __int16 v161;
  unsigned int v162;
  __int16 v163;
  int v164;
  __int16 v165;
  const char *v166;
  __int16 v167;
  const char *v168;
  __int16 v169;
  int v170;
  __int16 v171;
  double v172;
  __int16 v173;
  int v174;
  uint64_t v175;

  v175 = *MEMORY[0x1E0C80C00];
  v12 = *(_DWORD *)a2;
  if (*(int *)a2 > 10)
  {
    if (v12 == 11)
      return VCRateControlAlgorithmStabilizedNOWRDPriv_DoRateControlWithNWStatistics(a1, a2);
    if (v12 != 14)
    {
LABEL_19:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
        if (!result)
          return result;
        _VCRateControlAlgorithmStabilizedNOWRD_DoRateControl_cold_1();
      }
      return 0;
    }
    if (!*(_DWORD *)(a1 + 1040))
    {
      result = 0;
      *(_DWORD *)(a1 + 5284) = 0;
      *(_DWORD *)(a1 + 5288) = 0;
      return result;
    }
    v23 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(a1 + 5312) = v23;
    LODWORD(v23) = *(_DWORD *)(a1 + 5284);
    LODWORD(a10) = *(_DWORD *)(a2 + 40);
    *(_DWORD *)(a1 + 5284) = ((double)*(unint64_t *)&a10 * 0.1 + (double)v23 * 0.9);
    VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateBytesInFlightThreshold(a1);
    if (!*(_BYTE *)(a1 + 5292))
    {
      result = 0;
      *(_BYTE *)(a1 + 5281) = 1;
      return result;
    }
    if (VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampDownDueToLocalRCEvent(a1))
    {
      *(_DWORD *)(a1 + 1052) = VCRateControlAlgorithmStabilizedNOWRDPriv_RampDownTierDueToLocalRCEvent((_DWORD *)a1, *(double *)(a2 + 8));
      VCRateControlAlgorithmBasePriv_StateChange(a1, 3);
    }
    else
    {
      *(_BYTE *)(a1 + 5281) = VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampUpDueToLocalRCEvent(a1, v24);
    }
    *(_DWORD *)(a1 + 1072) = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * *(int *)(a1 + 1052));
  }
  else
  {
    if (v12 != 1)
    {
      if (v12 == 2)
      {
        result = VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateInternalStatistics(a1, a2);
        if (!result)
          return result;
        VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateSmartBrakeOutputWithVCRCStatistics(a1, a2);
        ShouldRampDown = VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampDown(a1);
        v22 = *(_DWORD *)(a1 + 848);
        if (v22)
        {
          if (VCRateControlSmartBrake_IsOutputEmpty(*(_QWORD *)(a1 + 5296), *(_DWORD *)(a1 + 5304)))
          {
            v22 = 0;
          }
          else
          {
            objc_msgSend(*(id *)(a1 + 25536), "config");
            v27 = (float)((float)*(unsigned int *)(a1 + 5300)
                                      + (float)(v26 * (float)*(unsigned int *)(a1 + 5304)));
            if (*(_DWORD *)(a1 + 1080) >= *(_DWORD *)(a1 + 1072))
              v28 = *(_DWORD *)(a1 + 1072);
            else
              v28 = *(_DWORD *)(a1 + 1080);
            v25 = *(float *)(a1 + 5296);
            v22 = v25 >= COERCE_FLOAT(objc_msgSend(*(id *)(a1 + 25536), "config")) || v28 > v27;
          }
        }
        switch(*(_DWORD *)(a1 + 1040))
        {
          case 0:
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v30 = VRTraceErrorLogLevelToCSTR();
              v31 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315650;
                v116 = v30;
                v117 = 2080;
                v118 = "_VCRateControlAlgorithmStabilizedNOWRD_RunRateControlStateTransition";
                v119 = 1024;
                v120 = 615;
                _os_log_impl(&dword_1D8A54000, v31, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d VCRateControl is paused", buf, 0x1Cu);
              }
            }
            goto LABEL_98;
          case 1:
            v32 = 28;
            if (!*(_BYTE *)(a1 + 1122))
              v32 = 32;
            if (v22)
              goto LABEL_54;
            if (ShouldRampDown)
            {
              *(_DWORD *)(a1 + 1052) = _VCRateControlAlgorithmStabilizedNOWRD_RampDownTier(a1);
              goto LABEL_85;
            }
            v60 = *(_DWORD *)(a1 + 40 + v32);
            if (VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampUp(a1))
            {
              *(_DWORD *)(a1 + 1052) = _VCRateControlAlgorithmStabilizedNOWRD_RampUpTier(a1);
              v61 = *(_DWORD *)(a1 + 1052);
              if (v61 == *(_DWORD *)(a1 + 60) || *(_BYTE *)(a1 + 1122) && v61 > *(_DWORD *)(a1 + 448))
                goto LABEL_85;
              if (v61 >= v60)
                goto LABEL_85;
            }
            goto LABEL_98;
          case 2:
            if (v22)
            {
LABEL_54:
              _VCRateControlAlgorithmStabilizedNOWRD_ToggleSmartBrake(a1, v14, v15, v16, v17, v18, v19, v20);
              *(_DWORD *)(a1 + 1052) = _VCRateControlAlgorithmStabilizedNOWRD_SmartBrakeBitrateCongestionTierIndex((unsigned int *)a1, v33);
              v34 = a1;
              v35 = 5;
              goto LABEL_97;
            }
            if (ShouldRampDown)
            {
              *(_DWORD *)(a1 + 1052) = _VCRateControlAlgorithmStabilizedNOWRD_RampDownTier(a1);
              if (_VCRateControlAlgorithmStabilizedNOWRD_IsBitrateOscillating(a1, *(_DWORD *)(a1 + 1052)))
                v35 = 4;
              else
                v35 = 3;
LABEL_96:
              v34 = a1;
              goto LABEL_97;
            }
            if (VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampUp(a1))
            {
              *(_DWORD *)(a1 + 1052) = _VCRateControlAlgorithmStabilizedNOWRD_RampUpTier(a1);
              if (VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldFastRampUp(a1))
                v35 = 1;
              else
                v35 = 3;
              goto LABEL_96;
            }
            goto LABEL_98;
          case 3:
            *(_DWORD *)(a1 + 1044) |= 1u;
            if (v22)
            {
              _VCRateControlAlgorithmStabilizedNOWRD_ToggleSmartBrake(a1, v14, v15, v16, v17, v18, v19, v20);
              *(_DWORD *)(a1 + 1052) = _VCRateControlAlgorithmStabilizedNOWRD_SmartBrakeBitrateCongestionTierIndex((unsigned int *)a1, v36);
              v37 = 5;
LABEL_69:
              VCRateControlAlgorithmBasePriv_StateChange(a1, v37);
              goto LABEL_70;
            }
            if (ShouldRampDown)
            {
              *(_DWORD *)(a1 + 1052) = _VCRateControlAlgorithmStabilizedNOWRD_RampDownTier(a1);
              if (_VCRateControlAlgorithmStabilizedNOWRD_IsBitrateOscillating(a1, *(_DWORD *)(a1 + 1052)))
              {
                v37 = 4;
                goto LABEL_69;
              }
            }
LABEL_70:
            _VCRateControlAlgorithmStabilizedNOWRD_GetRampUpFrozenDuration(a1);
            *(double *)(a1 + 25384) = v51;
            if (*(double *)(a1 + 1096) - *(double *)(a1 + 1104) > v51)
            {
LABEL_76:
              v34 = a1;
              v35 = 2;
LABEL_97:
              VCRateControlAlgorithmBasePriv_StateChange(v34, v35);
            }
LABEL_98:
            *(_DWORD *)(a1 + 1072) = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * *(int *)(a1 + 1052));
            VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateVCRateControlHistory(a1);
            v62 = *(_QWORD *)(a1 + 1016);
            if (v62)
            {
              if (*(_BYTE *)(a1 + 1121))
                v63 = *(double *)(a1 + 1096) - *(double *)(a1 + 5192) > 0.5;
              else
                v63 = 0;
              if (*(_DWORD *)(a1 + 1040) == 1)
                v64 = v63 ^ 1;
              else
                v64 = 0;
              VCRateControlMediaController_SetShouldDisableLargeFrameRequestsWhenInitialRampUp(v62, v64);
              VCRateControlMediaController_SetRateLimitedMaxTimeExceeded(*(_QWORD *)(a1 + 1016), v63);
            }
            if (*(_BYTE *)(a1 + 5128))
            {
              v65 = *(_DWORD *)(a1 + 1088);
              *(_DWORD *)(a1 + 1088) = v65 + 1;
              if ((v65 & 0xF) == 0 && (int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v66 = VRTraceErrorLogLevelToCSTR();
                v67 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                {
                  v114 = *(_QWORD *)(a1 + 1096);
                  v113 = *(unsigned __int16 *)(a1 + 5186);
                  v112 = *(_QWORD *)(a1 + 2856);
                  v111 = *(_QWORD *)(a1 + 2864);
                  v110 = *(_QWORD *)(a1 + 2872);
                  v108 = *(_QWORD *)(a1 + 2880);
                  if (*(_BYTE *)(a1 + 5104))
                    v68 = 79;
                  else
                    v68 = 88;
                  v107 = v68;
                  v106 = (int)(*(double *)(a1 + 5072) * 1000.0);
                  v69 = *(double *)(a1 + 4992) * 100.0;
                  v105 = *(_DWORD *)(a1 + 1168);
                  v70 = *(double *)(a1 + 5056) * 100.0;
                  v104 = *(_DWORD *)(a1 + 4984);
                  v103 = *(_DWORD *)(a1 + 1080) / 0x3E8u;
                  v102 = *(unsigned __int16 *)(a1 + 1044);
                  v101 = *(unsigned __int16 *)(a1 + 1048);
                  v99 = *(_DWORD *)(a1 + 1072) / 0x3E8u;
                  v100 = *(_DWORD *)(a1 + 1084);
                  v71 = *(_DWORD *)(a1 + 5256) / 0x3E8u;
                  v72 = *(_DWORD *)(a1 + 5260);
                  v73 = (*(double *)(a1 + 5264) * 1000.0);
                  v74 = VCRateControlMediaController_AudioSendingBitrate(*(_QWORD *)(a1 + 1016)) / 0x3E8;
                  v75 = VCRateControlMediaController_AudioFractionTier(*(_QWORD *)(a1 + 1016));
                  if (*(_BYTE *)(a1 + 5188))
                    v76 = "S";
                  else
                    v76 = "U";
                  if (*(_BYTE *)(a1 + 1121))
                  {
                    v77 = "<";
                  }
                  else
                  {
                    v78 = v75;
                    IsVideoStopped = VCRateControlMediaController_IsVideoStopped(*(_BYTE **)(a1 + 1016));
                    v77 = "-";
                    v80 = !IsVideoStopped;
                    v75 = v78;
                    if (!v80)
                      v77 = "_";
                  }
                  v81 = *(_DWORD *)(a1 + 1040);
                  v82 = *(float *)(a1 + 5296);
                  v83 = *(_DWORD *)(a1 + 5300);
                  *(_DWORD *)buf = 136322562;
                  v116 = v66;
                  v117 = 2080;
                  v118 = "_VCRateControlAlgorithmStabilizedNOWRD_PrintRateControlInfoToLogDump";
                  v119 = 1024;
                  v120 = 1904;
                  v121 = 2048;
                  v122 = v114;
                  v123 = 1024;
                  v124 = v113;
                  v125 = 2048;
                  v126 = v112;
                  v127 = 2048;
                  v128 = v111;
                  v129 = 2048;
                  v130 = v110;
                  v131 = 2048;
                  v132 = v108;
                  v133 = 1024;
                  v134 = v107;
                  v135 = 1024;
                  v136 = v106;
                  v137 = 2048;
                  v138 = v69;
                  v139 = 2048;
                  v140 = v70;
                  v141 = 1024;
                  v142 = v105;
                  v143 = 1024;
                  v144 = v104;
                  v145 = 1024;
                  v146 = v103;
                  v147 = 1024;
                  v148 = v99;
                  v149 = 1024;
                  v150 = v102;
                  v151 = 1024;
                  v152 = v101;
                  v153 = 1024;
                  v154 = v100;
                  v155 = 1024;
                  v156 = v71;
                  v157 = 1024;
                  v158 = v72;
                  v159 = 1024;
                  v160 = v73;
                  v161 = 1024;
                  v162 = v74;
                  v163 = 1024;
                  v164 = v75;
                  v165 = 2080;
                  v166 = v76;
                  v167 = 2080;
                  v168 = v77;
                  v169 = 1024;
                  v170 = v81;
                  v171 = 2048;
                  v172 = v82;
                  v173 = 1024;
                  v174 = v83;
                  _os_log_impl(&dword_1D8A54000, v67, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d %8.3f/%04X:\t%.4f\t%.4f\t%.4f\t%.4f %c\tRTT:%-4u\tPLR:%4.2f@%.1f\tRRx:%4u\tMBL:%d\t%4u/%4u\t  CS:%04X %04X %u BB: %3u\t%4u\t%3u\t%u\t%u\t UAT %s %s\t%d\t%.3f\t%u", buf, 0xE6u);
                }
              }
            }
            v84 = *(_QWORD *)(a1 + 5112);
            if (v84)
            {
              v85 = *(_QWORD *)(a1 + 1096);
              v87 = *(unsigned int *)(a1 + 1168);
              v88 = *(unsigned int *)(a1 + 4984);
              if (*(_BYTE *)(a1 + 5104))
                v89 = 79;
              else
                v89 = 88;
              v90 = *(unsigned int *)(a1 + 1172);
              v91 = *(unsigned int *)(a1 + 1080) / 0x3E8uLL;
              v86 = *(double *)(a1 + 5216);
              v92 = ((v86 + *(double *)(a1 + 5200)) / 1000.0);
              if (!*(_BYTE *)(a1 + 1121))
              {
                v109 = *(_QWORD *)(a1 + 5112);
                v93 = v89;
                v94 = *(unsigned int *)(a1 + 1168);
                v95 = *(unsigned int *)(a1 + 4984);
                v96 = *(unsigned int *)(a1 + 1172);
                v97 = *(unsigned int *)(a1 + 1080) / 0x3E8uLL;
                v98 = ((v86 + *(double *)(a1 + 5200)) / 1000.0);
                VCRateControlMediaController_IsVideoStopped(*(_BYTE **)(a1 + 1016));
                v92 = v98;
                v91 = v97;
                v90 = v96;
                v88 = v95;
                v87 = v94;
                v89 = v93;
                v84 = v109;
              }
              VRLogfilePrintWithTimestamp(v84, "%8.3f/%04X:\t%.4f\t%.4f\t%.4f\t%.4f %c\tRTT:%-4u\tPLR:%4.2f@%.1f\tRRx:%u\tMBL:%d %u\t%4u/%4u\t %4u:%4u/%4u  %4u:%4u/%4u  CS: %05X %05X %u BB: %3u\t%4u\t%3u\t%s UAT %u\t%u\t%s\t%s\t%d\t%d\t%d\t%d\t%.3f\t%.3f\t%u\t%u\n", v89, v87, v88, v90, v91, v92, v85);
            }
            *(_DWORD *)(a1 + 1044) = 0;
            *(_DWORD *)(a1 + 1048) = 0;
            break;
          case 4:
            *(_DWORD *)(a1 + 1044) |= 1u;
            if (v22)
            {
              _VCRateControlAlgorithmStabilizedNOWRD_ToggleSmartBrake(a1, v14, v15, v16, v17, v18, v19, v20);
              v39 = _VCRateControlAlgorithmStabilizedNOWRD_SmartBrakeBitrateCongestionTierIndex((unsigned int *)a1, v38);
              v40 = 5;
            }
            else
            {
              if (!ShouldRampDown)
                goto LABEL_75;
              v39 = _VCRateControlAlgorithmStabilizedNOWRD_RampDownTier(a1);
              v40 = 3;
            }
            *(_DWORD *)(a1 + 1052) = v39;
            VCRateControlAlgorithmBasePriv_StateChange(a1, v40);
LABEL_75:
            if (*(double *)(a1 + 1096) - *(double *)(a1 + 1104) > *(double *)(a1 + 25384))
              goto LABEL_76;
            goto LABEL_98;
          case 5:
            *(_BYTE *)(a1 + 25576) = *(double *)(a1 + 1096) - *(double *)(a1 + 25568) > 6.0;
            v41 = *(float *)(a1 + 5296);
            v42 = objc_msgSend(*(id *)(a1 + 25536), "config");
            if (!*(_BYTE *)(a1 + 25576))
            {
              LODWORD(v50) = HIDWORD(v42);
              if (v41 > *((float *)&v42 + 1))
              {
                *(_DWORD *)(a1 + 1052) = _VCRateControlAlgorithmStabilizedNOWRD_SmartBrakeBitrateCongestionTierIndex((unsigned int *)a1, v50);
                goto LABEL_98;
              }
            }
            _VCRateControlAlgorithmStabilizedNOWRD_ToggleSmartBrake(a1, v43, v44, v45, v46, v47, v48, v49);
            v52 = *(_DWORD *)(a1 + 5300);
            v53 = *(_DWORD *)(a1 + 60);
            v54 = *(_QWORD *)(a1 + 48);
            if (*(_DWORD *)(v54 + 4 * v53) <= v52)
              goto LABEL_84;
            v55 = v53;
            v56 = *(int *)(a1 + 64);
            if (v53 >= (int)v56)
              v53 = *(_DWORD *)(a1 + 64);
            v57 = v54 - 4;
            while (v55 > v56)
            {
              v58 = v55 - 1;
              v59 = *(_DWORD *)(v57 + 4 * v55--);
              if (v59 <= v52)
              {
                v53 = v58;
                break;
              }
            }
LABEL_84:
            *(_DWORD *)(a1 + 1052) = v53;
LABEL_85:
            v34 = a1;
            v35 = 3;
            goto LABEL_97;
          default:
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                _VCRateControlAlgorithmStabilizedNOWRD_DoRateControl_cold_2();
            }
            goto LABEL_98;
        }
        return 1;
      }
      goto LABEL_19;
    }
    if (!*(_DWORD *)(a1 + 1040))
      return 0;
    if (!*(_QWORD *)(a1 + 1016))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
        if (!result)
          return result;
        _VCRateControlAlgorithmStabilizedNOWRD_DoRateControl_cold_3();
      }
      return 0;
    }
    VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateAlgorithmWithBasebandStatistics(a1, a2, a3, a4, a5, a6, a7, a8);
    if (VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampDownDueToBaseband(a1))
    {
      *(_DWORD *)(a1 + 1052) = VCRateControlAlgorithmStabilizedNOWRDPriv_RampDownTierDueToBaseband(a1, *(double *)(a1 + 5232));
      VCRateControlAlgorithmBasePriv_StateChange(a1, 3);
    }
    else if (VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampUpDueToBaseband((double *)a1))
    {
      *(_DWORD *)(a1 + 5276) = VCRateControlAlgorithmStabilizedNOWRDPriv_BasebandAdditionalTiersForRampUp(a1);
    }
    *(_DWORD *)(a1 + 1072) = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * *(int *)(a1 + 1052));
    if (*(_BYTE *)(a1 + 5280))
      VCRateControlMediaController_UpdateBasebandSuggestion(*(_QWORD *)(a1 + 1016), a2);
  }
  return 1;
}

uint64_t _VCRateControlAlgorithmStabilizedNOWRD_StateEnter(uint64_t result)
{
  uint64_t v1;
  int v2;
  uint64_t v3;
  double v4;
  double v5;
  double v6;

  v1 = result;
  v2 = *(_DWORD *)(result + 1040);
  switch(v2)
  {
    case 4:
      *(_QWORD *)(result + 1104) = *(_QWORD *)(result + 1096);
      v3 = 488;
      if (*(double *)(result + 1096) - *(double *)(result + 25392) > *(double *)(result + 472))
        v3 = 480;
      v4 = *(double *)(result + 40 + v3);
      result = _VCRateControlAlgorithmStabilizedNOWRD_GetRampUpFrozenDuration(result);
      v6 = v4 * v5;
      goto LABEL_9;
    case 3:
      *(_QWORD *)(result + 1104) = *(_QWORD *)(result + 1096);
      result = _VCRateControlAlgorithmStabilizedNOWRD_GetRampUpFrozenDuration(result);
LABEL_9:
      *(double *)(v1 + 25384) = v6;
      return result;
    case 1:
      *(_BYTE *)(result + 25432) = 0;
      break;
  }
  return result;
}

double _VCRateControlAlgorithmStabilizedNOWRD_StateExit(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  double result;
  char v11;

  v9 = *(_DWORD *)(a1 + 1040);
  if (v9 == 4)
  {
    result = *(double *)(a1 + 1096);
    *(double *)(a1 + 25392) = result;
  }
  else if (v9 == 1)
  {
    VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Initial Rampup done!", a3, a4, a5, a6, a7, a8, v11);
    if (!*(_BYTE *)(a1 + 1122))
      *(_BYTE *)(a1 + 1122) = 1;
  }
  return result;
}

uint64_t VCRateControlAlgorithmStabilizedNOWRDPriv_ResetBytesInFlight(uint64_t result)
{
  if (result)
  {
    *(_DWORD *)(result + 5284) = 0;
    *(_DWORD *)(result + 5288) = 0;
  }
  return result;
}

void VCRateControlAlgorithmStabilizedNOWRDPriv_SetBitrateUnstable(uint64_t a1)
{
  if (a1)
  {
    *(_BYTE *)(a1 + 5188) = 0;
    ++*(_DWORD *)(a1 + 1084);
    *(_BYTE *)(a1 + 1120) = 0;
    if (*(_DWORD *)(a1 + 1040) != 1)
    {
      *(_QWORD *)(a1 + 1104) = *(_QWORD *)(a1 + 1096);
      *(_QWORD *)(a1 + 1176) = *(_QWORD *)(a1 + 1096);
    }
    if (*(_DWORD *)(a1 + 536) == 1)
      *(double *)(a1 + 25408) = micro();
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlAlgorithmStabilizedNOWRDPriv_SetBitrateUnstable_cold_1();
  }
}

BOOL VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampDownDueToLocalRCEvent(uint64_t a1)
{
  unsigned int v2;
  unint64_t v3;
  _BOOL8 result;
  unsigned int v5;
  _DWORD *v6;

  if (a1)
  {
    v2 = *(_DWORD *)(a1 + 5288);
    if (v2)
    {
      HIDWORD(v3) = 1069128089;
      if (*(double *)(a1 + 5312) - *(double *)(a1 + 5320) > 0.1)
      {
        LODWORD(v3) = *(_DWORD *)(a1 + 5328);
        if (*(double *)(a1 + 1064) < (double)v3 * 0.5)
        {
          result = 0;
          *(_DWORD *)(a1 + 5284) = 0;
          return result;
        }
      }
      v5 = *(_DWORD *)(a1 + 5284);
      result = v5 > v2;
      if (v5 > v2)
      {
        *(_DWORD *)(a1 + 1048) |= 0x1000u;
        *(_QWORD *)(a1 + 2880) = 0;
        v6 = (_DWORD *)(a1 + 1116);
LABEL_9:
        *v6 = v5 <= v2;
        return result;
      }
      v6 = (_DWORD *)(a1 + 1116);
      if (*(_DWORD *)(a1 + 1116) != -1)
        goto LABEL_9;
      return 0;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      return 0;
    VRTraceErrorLogLevelToCSTR();
    result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
    if (result)
    {
      VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampDownDueToLocalRCEvent_cold_2();
      return 0;
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      return 0;
    VRTraceErrorLogLevelToCSTR();
    result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
    if (result)
    {
      VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampDownDueToLocalRCEvent_cold_1();
      return 0;
    }
  }
  return result;
}

BOOL VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampUpDueToLocalRCEvent(uint64_t a1, double a2)
{
  unsigned int v2;

  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampUpDueToLocalRCEvent_cold_1();
    }
    return 1;
  }
  v2 = *(_DWORD *)(a1 + 5288);
  if (!v2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampUpDueToLocalRCEvent_cold_2();
    }
    return 1;
  }
  LODWORD(a2) = *(_DWORD *)(a1 + 5284);
  return (double)v2 * 0.9 > (double)*(unint64_t *)&a2;
}

uint64_t VCRateControlAlgorithmStabilizedNOWRDPriv_RampDownTierDueToLocalRCEvent(_DWORD *a1, double a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;

  if (a1)
  {
    VCRateControlAlgorithmStabilizedNOWRDPriv_SetBitrateUnstable((uint64_t)a1);
    VCRateControlAlgorithmBasePriv_UpdateCongestionStatusWhenRampDown((uint64_t)a1, a2);
    v4 = a1[1321] / a1[1322];
    VCRateControlAlgorithmBasePriv_LogToDumpFiles((uint64_t)a1, "BytesInFlight rampDown numberOfTier=%d with bytesInFlight=%u, bytesInFlightThreshold=%u, roundTripTimeMinEnvelope=%f", v5, v6, v7, v8, v9, v10, v4);
    v11 = a1[16];
    v12 = a1[263] - v4;
    if (v11 <= v12)
      return v12;
    else
      return v11;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCRateControlAlgorithmStabilizedNOWRDPriv_RampDownTierDueToLocalRCEvent_cold_1();
    }
    return 0;
  }
}

void VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateBytesInFlightThreshold(uint64_t a1)
{
  unsigned int v2;
  double v3;
  double v4;
  double v5;
  double v6;

  if (a1)
  {
    v2 = VCRateControlCongestionLevel_BitrateRange(*(_DWORD *)(a1 + 1072));
    if (*(_BYTE *)(a1 + 5177) && (v3 = *(double *)(a1 + 40 + 8 * v2 + 896), v3 > 0.0))
    {
      v4 = *(double *)(a1 + 5080);
      v5 = v3 * v4;
      if (v5 < 0.15)
        v5 = 0.15;
      v6 = v4 + v5;
      LODWORD(v4) = *(_DWORD *)(a1 + 1168);
      *(_DWORD *)(a1 + 5288) = (v6 * (double)*(unint64_t *)&v4 * 1000.0 * 0.125);
    }
    else
    {
      *(_DWORD *)(a1 + 5288) = 0;
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateBytesInFlightThreshold_cold_1();
  }
}

double _VCRateControlAlgorithmStabilizedNOWRD_CongestionLevelThreshold(uint64_t a1, int a2, int a3)
{
  unsigned int v6;
  double result;
  uint64_t v8;
  uint64_t v9;

  v6 = VCRateControlCongestionLevel_BitrateRange(*(_DWORD *)(a1 + 1072));
  result = 0.0;
  if (a2 == 2)
  {
    if (*(_BYTE *)(a1 + 5177))
    {
      v9 = 936;
      if (a3)
        v9 = 896;
      return *(double *)(a1 + v9 + 40 + 8 * v6);
    }
  }
  else if (a2 == 1)
  {
    if (*(_BYTE *)(a1 + 5176))
    {
      v8 = 856;
      if (a3)
        v8 = 816;
      return *(double *)(a1 + 40 + v8 + 8 * v6) * *(double *)(a1 + 5080);
    }
    else
    {
      return *(double *)(a1 + 136);
    }
  }
  return result;
}

BOOL VCRateControlAlgorithmStabilizedNOWRDPriv_DoRateControlWithNWStatistics(uint64_t a1, uint64_t a2)
{
  BOOL v2;
  _BOOL8 result;

  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      VCRateControlAlgorithmStabilizedNOWRDPriv_DoRateControlWithNWStatistics_cold_1();
    }
    return 0;
  }
  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      VCRateControlAlgorithmStabilizedNOWRDPriv_DoRateControlWithNWStatistics_cold_2();
    }
    return 0;
  }
  if (!*(_DWORD *)(a1 + 1040))
    return 0;
  if (*(_DWORD *)a2 != 11)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      VCRateControlAlgorithmStabilizedNOWRDPriv_DoRateControlWithNWStatistics_cold_3();
    }
    return 0;
  }
  v2 = *(_BYTE *)(a2 + 94) == 1 && *(_BYTE *)(a2 + 88) == 1;
  *(_BYTE *)(a1 + 25528) = v2;
  return 1;
}

void VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateAlgorithmWithBasebandStatistics(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10;
  unsigned int v11;
  BOOL v12;
  char v13;
  unsigned int v14;
  char v15;

  if (a1)
  {
    if (a2)
    {
      if (*(_DWORD *)a2 == 1)
      {
        *(_QWORD *)(a1 + 5232) = *(_QWORD *)(a2 + 8);
        *(_DWORD *)(a1 + 5256) = *(_DWORD *)(a2 + 36);
        *(_DWORD *)(a1 + 5260) = *(_DWORD *)(a2 + 28) + *(_DWORD *)(a2 + 24);
        *(_QWORD *)(a1 + 5264) = *(_QWORD *)(a2 + 64);
        *(_QWORD *)(a1 + 5240) = *(_QWORD *)(a2 + 80);
        *(_QWORD *)(a1 + 5248) = *(_QWORD *)(a2 + 88);
        v10 = *(_DWORD *)(a1 + 5272);
        v11 = *(_DWORD *)(a2 + 160);
        if (*(_BYTE *)(a1 + 5280) && v11 == 8)
          VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Disabling baseband adaptation due to FR2 RATType", a3, a4, a5, a6, a7, a8, v15);
        if (*(_BYTE *)(a1 + 411))
          v12 = v11 == 8;
        else
          v12 = 1;
        v13 = !v12;
        if (v11 != v10 && v11 <= 9 && ((1 << v11) & 0x3A0) != 0 && v10 <= 9 && ((1 << v10) & 0x3A0) != 0)
          *(_QWORD *)(a1 + 25464) = *(_QWORD *)(a1 + 5232);
        if (*(double *)(a1 + 5232) - *(double *)(a1 + 25464) < *(double *)(a1 + 632))
          v13 = 0;
        v14 = *(_DWORD *)(a1 + 1080);
        if (v14 && (double)*(unsigned int *)(a2 + 40) / (double)v14 > *(double *)(a1 + 640))
        {
          v13 = *(_BYTE *)(a1 + 5280);
          if (v13)
          {
            VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Disable baseband adaptation due to cross traffic. Average baseband throughput %d is much larger than our actual bitrate %d", a3, a4, a5, a6, a7, a8, *(_DWORD *)(a2 + 40));
            v13 = 0;
          }
        }
        *(_BYTE *)(a1 + 5280) = v13;
        *(_DWORD *)(a1 + 5272) = *(_DWORD *)(a2 + 160);
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateAlgorithmWithBasebandStatistics_cold_3();
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateAlgorithmWithBasebandStatistics_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateAlgorithmWithBasebandStatistics_cold_1();
  }
}

BOOL VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateInternalStatistics(uint64_t a1, uint64_t a2)
{
  double v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  int v11;
  uint64_t v12;
  __int128 v13;
  uint64_t v14;
  double DoubleTimeFromTimestamp;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  BOOL v19;
  unsigned int v20;
  unsigned int v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  double v38;
  double v39;
  int v40;
  char v41;
  double v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  double v49;
  double v50;
  __int16 v51;
  int v52;
  uint64_t v53;
  __int16 TimestampFromMicroTime;
  int v55;
  unsigned int v56;
  unsigned int v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  unsigned int v65;
  double v66;
  double i;
  BOOL v68;
  int v69;
  unsigned __int16 v70;
  __int16 v71;
  double v72;
  double v73;
  uint64_t v74;
  int v75;
  double v76;
  double v77;
  uint64_t v78;
  double v79;
  uint64_t v80;
  uint64_t v82;
  int v83;
  _BOOL8 result;
  uint64_t v85;
  NSObject *v86;
  _BOOL4 v87;
  unsigned int v88;
  _BYTE buf[40];
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;

  v93 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateInternalStatistics_cold_1();
    }
    return 0;
  }
  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateInternalStatistics_cold_2();
    }
    return 0;
  }
  v4 = *(double *)(a2 + 8);
  v5 = *(unsigned __int16 *)(a2 + 24);
  v6 = *(_QWORD *)(a2 + 80);
  v7 = *(_QWORD *)(a2 + 52);
  v8 = *(unsigned int *)(a2 + 60);
  *(_DWORD *)(a1 + 25500) = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 4984) = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a1 + 1168) = *(_DWORD *)(a2 + 32);
  *(_BYTE *)(a1 + 5352) = *(_DWORD *)(a2 + 36) != 0;
  *(_WORD *)(a1 + 5186) = *(_DWORD *)(a2 + 68);
  *(_WORD *)(a1 + 5334) = *(_DWORD *)(a2 + 28);
  v9 = *(_DWORD *)(a1 + 5096);
  if (v9 <= *(_DWORD *)(a1 + 25500))
    v9 = *(_DWORD *)(a1 + 25500);
  *(_DWORD *)(a1 + 5096) = v9;
  *(_DWORD *)(a1 + 1080) = *(_DWORD *)(a2 + 96);
  *(_DWORD *)(a1 + 4980) = *(_DWORD *)(a2 + 184);
  *(double *)(a1 + 5320) = v4;
  *(_DWORD *)(a1 + 5328) = *(_DWORD *)(a1 + 1072);
  if (!*(_BYTE *)(a1 + 1123))
  {
    result = 0;
    *(_BYTE *)(a1 + 1123) = 1;
    *(_WORD *)(a1 + 5332) = v5;
    return result;
  }
  v10 = *(unsigned __int16 *)(a1 + 5332);
  if (v5 == v10 || (unsigned __int16)(v5 - v10) >= 0x7FFFu)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v85 = VRTraceErrorLogLevelToCSTR();
      v86 = *MEMORY[0x1E0CF2758];
      v87 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
      result = 0;
      if (!v87)
        return result;
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = v85;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateInternalStatistics";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 647;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = v5;
      _os_log_impl(&dword_1D8A54000, v86, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Duplicated feedback or out-of-order feedback messages! timestamp:0x%04X", buf, 0x22u);
    }
    return 0;
  }
  if (v10 > v5)
    ++*(_DWORD *)(a1 + 5340);
  *(_WORD *)(a1 + 5332) = v5;
  *(double *)(a1 + 1096) = VCRateControlAlgorithmBasePriv_GetDoubleTimeFromTimestamp(v5, 0x400u, *(_DWORD *)(a1 + 5340));
  *(_DWORD *)(a1 + 5336) = VCRateControlAlgorithmBasePriv_GetTimestampFromMicroTime(v4);
  *(_QWORD *)(a1 + 2856) = v6;
  *(_BYTE *)(a1 + 5104) = v4 - VCRateControlMediaController_LastVideoRefreshFrameTime(*(_QWORD *)(a1 + 1016)) < *(double *)(a1 + 472);
  if (*(double *)(a1 + 25424) == 0.0)
    *(_QWORD *)(a1 + 25424) = *(_QWORD *)(a1 + 1096);
  v11 = *(unsigned __int16 *)(a1 + 25500);
  v12 = *(_QWORD *)(a2 + 88);
  *(_QWORD *)&v13 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)buf = v13;
  *(_OWORD *)&buf[16] = v13;
  *(_WORD *)buf = *(_WORD *)(a1 + 5186);
  *(_QWORD *)&buf[4] = v7;
  *(_QWORD *)&buf[16] = v8;
  *(_DWORD *)&buf[24] = v11;
  *(_QWORD *)&buf[32] = a1 + 4984;
  v90 = a1 + 5048;
  v91 = a1 + 4992;
  v92 = a1 + 5056;
  v14 = *(_QWORD *)(a1 + 1016);
  if (v14)
    VCRateControlMediaController_ComputePacketLoss(v14, (uint64_t)buf);
  else
    *(_QWORD *)(a1 + 4992) = v12;
  if (*(double *)(a1 + 4992) > *(double *)(a1 + 720))
    *(_QWORD *)(a1 + 25520) = *(_QWORD *)(a1 + 1096);
  DoubleTimeFromTimestamp = *(double *)(a2 + 104);
  if (DoubleTimeFromTimestamp == 0.0)
  {
    v16 = *(_DWORD *)(a1 + 5336);
    if (v16 < *(unsigned __int16 *)(a1 + 5186))
      *(_DWORD *)(a1 + 5336) = v16 + 0x10000;
    v17 = *(unsigned __int16 *)(a1 + 5334);
    if (!*(_WORD *)(a1 + 5334))
    {
      *(_WORD *)(a1 + 5186) = -1;
      goto LABEL_39;
    }
    v18 = *(_DWORD *)(a1 + 5336) - *(unsigned __int16 *)(a1 + 5186);
    v19 = v18 >= v17;
    v20 = v18 - v17;
    if (v20 != 0 && v19)
      v21 = v20;
    else
      v21 = 1;
    DoubleTimeFromTimestamp = VCRateControlAlgorithmBasePriv_GetDoubleTimeFromTimestamp(v21, 0x400u, 0);
  }
  *(double *)(a1 + 5064) = DoubleTimeFromTimestamp;
  v22 = *(double *)(a1 + 5072);
  if (v22 == 0.0)
    v23 = DoubleTimeFromTimestamp;
  else
    v23 = DoubleTimeFromTimestamp * 0.1 + v22 * 0.9;
  *(double *)(a1 + 5072) = v23;
  v24 = *(double *)(a1 + 5080);
  if (v24 == 0.0)
  {
    v25 = *(double *)(a1 + 5072);
  }
  else
  {
    v26 = *(double *)(a1 + 25512);
    v27 = *(double *)(a1 + 5072);
    v28 = *(double *)(a1 + 504);
    *(double *)(a1 + 25512) = v27;
    if (v27 >= v24 && v26 - v27 <= v28)
      goto LABEL_34;
    v25 = DoubleTimeFromTimestamp * dbl_1D910D7E0[*(double *)(a1 + 5080) > DoubleTimeFromTimestamp]
        + *(double *)(a1 + 5080) * (1.0 - dbl_1D910D7E0[*(double *)(a1 + 5080) > DoubleTimeFromTimestamp]);
  }
  *(double *)(a1 + 5080) = v25;
LABEL_34:
  v29 = *(double *)(a1 + 5088);
  if (v29 <= *(double *)(a1 + 5072))
    v29 = *(double *)(a1 + 5072);
  *(double *)(a1 + 5088) = v29;
  if (*(double *)(a1 + 5072) > *(double *)(a1 + 712))
    *(_QWORD *)(a1 + 25520) = *(_QWORD *)(a1 + 1096);
LABEL_39:
  VCRateControlAlgorithmBasePriv_CalculateCongestionMetrics(a1, *(double *)(a1 + 2856), *(double *)(a1 + 1096));
  if (*(_BYTE *)(a1 + 2849))
  {
    if (*(double *)(a1 + 25376) != 0.0)
      goto LABEL_44;
    v36 = *(_QWORD *)(a1 + 1096);
  }
  else
  {
    v36 = 0;
  }
  *(_QWORD *)(a1 + 25376) = v36;
LABEL_44:
  v37 = *(_QWORD *)(a1 + 1016);
  if (v37)
  {
    VCRateControlMediaController_MediaQueueSettings(v37, (double *)(a1 + 5200), (double *)(a1 + 5208), (double *)(a1 + 5216), (double *)(a1 + 5224));
    v38 = *(double *)(a1 + 5224);
    v39 = *(double *)(a1 + 5208) + v38;
    *(_DWORD *)(a1 + 1080) = v39;
    v40 = *(_DWORD *)(a1 + 1052);
    if (v40 <= *(_DWORD *)(a1 + 64)
      || v40 < *(_DWORD *)(a1 + 116)
      || (LODWORD(v39) = *(_DWORD *)(a1 + 1080),
          LODWORD(v38) = *(_DWORD *)(a1 + 1072),
          *(double *)(a1 + 288) * (double)*(unint64_t *)&v38 <= (double)*(unint64_t *)&v39))
    {
      if (*(_BYTE *)(a1 + 1121))
      {
        v42 = *(double *)(a1 + 5192);
        if (v42 <= 0.0 || *(double *)(a1 + 1096) - v42 <= *(double *)(a1 + 296))
        {
          v41 = 0;
        }
        else
        {
          VCRateControlAlgorithmStabilizedNOWRDPriv_SetBitrateUnstable(a1);
          VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "[%u] Sending rate was limited for a long time, stabilizing the bitrate", v43, v44, v45, v46, v47, v48, *(_DWORD *)(a1 + 1084));
          v41 = 0;
        }
LABEL_58:
        *(_BYTE *)(a1 + 1121) = v41;
      }
    }
    else if (!VCRateControlMediaController_IsAudioOnly(*(_QWORD *)(a1 + 1016))
           || *(_DWORD *)(a1 + 1052) < *(_DWORD *)(a1 + 120))
    {
      if (!*(_BYTE *)(a1 + 1121))
        *(_QWORD *)(a1 + 5192) = *(_QWORD *)(a1 + 1096);
      v41 = 1;
      goto LABEL_58;
    }
  }
  v49 = *(double *)(a1 + 192);
  if (*(_BYTE *)(a1 + 415) && *(double *)(a1 + 4960) == 0.0)
  {
    v50 = *(double *)(a1 + 5072);
    if (*(double *)(a1 + 456) * v50 < v49)
      v49 = *(double *)(a1 + 456) * v50;
    if (*(double *)(a1 + 312) > v49)
      v49 = *(double *)(a1 + 312);
  }
  v51 = *(_WORD *)(a1 + 5186);
  v52 = *(unsigned __int16 *)(a1 + 5334);
  *(double *)(a1 + 25440) = v49;
  if (*(_BYTE *)(a1 + 5188))
  {
    if (*(_DWORD *)(a1 + 1040) != 1 && *(_BYTE *)(a1 + 25432) && *(double *)(a1 + 1096) - *(double *)(a1 + 25400) > v49)
      *(_BYTE *)(a1 + 25432) = 0;
  }
  else
  {
    v53 = *(_QWORD *)(a1 + 1016);
    if (v53)
    {
      *(_QWORD *)buf = -1;
      v88 = -1431655766;
      VCRateControlMediaController_MediaQueueRateChangeCounter(v53, &v88, buf);
      TimestampFromMicroTime = VCRateControlAlgorithmBasePriv_GetTimestampFromMicroTime(*(double *)buf);
      v55 = *(_DWORD *)(a1 + 536);
      if (v55 == 2)
      {
        v88 = *(_DWORD *)(a1 + 1084);
        TimestampFromMicroTime = v51;
      }
      else if (v55 == 1)
      {
        v88 = *(_DWORD *)(a1 + 1084);
        TimestampFromMicroTime = VCRateControlAlgorithmBasePriv_GetTimestampFromMicroTime(*(double *)(a1 + 25408));
      }
      v56 = *(_DWORD *)(a1 + 1084);
      if (*(_DWORD *)(a1 + 5344) != v56)
      {
        if (v88 >= v56
          && (*(_BYTE *)(a1 + 1120) = 1, v52)
          && (unsigned __int16)(v51 - TimestampFromMicroTime) <= 0x7FFEu)
        {
          *(_QWORD *)(a1 + 25400) = *(_QWORD *)(a1 + 1096);
          *(_DWORD *)(a1 + 5348) = 1;
          *(_BYTE *)(a1 + 25472) = 0;
          *(_DWORD *)(a1 + 5344) = *(_DWORD *)(a1 + 1084);
          VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "[%u] VCRC rate stabilized (TxTS %u >= %u FB). Collecting VCRC samples...", v30, v31, v32, v33, v34, v35, *(_DWORD *)(a1 + 1084));
        }
        else
        {
          *(_DWORD *)(a1 + 5348) = 0;
        }
      }
    }
    else if (!*(_DWORD *)(a1 + 5348))
    {
      *(_QWORD *)(a1 + 25400) = *(_QWORD *)(a1 + 1096);
      *(_DWORD *)(a1 + 5348) = 1;
      *(_BYTE *)(a1 + 25472) = 0;
      VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "[%u] VCRC rate stabilized since no mediaController. Collecting VCRC samples...", v30, v31, v32, v33, v34, v35, *(_DWORD *)(a1 + 1084));
    }
    if (*(_BYTE *)(a1 + 5189))
    {
      *(_BYTE *)(a1 + 5188) = 1;
      *(_DWORD *)(a1 + 5348) = 0;
    }
    v57 = *(_DWORD *)(a1 + 5348);
    if (v57)
    {
      if (*(double *)(a1 + 1096) - *(double *)(a1 + 25400) >= *(double *)(a1 + 312) && v57 >= *(_DWORD *)(a1 + 348))
      {
        VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "[%u] Collected %d VCRC samples (TxTS %u)", v30, v31, v32, v33, v34, v35, *(_DWORD *)(a1 + 1084));
        *(_BYTE *)(a1 + 5188) = 1;
        *(_DWORD *)(a1 + 5348) = 0;
      }
      else
      {
        *(_DWORD *)(a1 + 5348) = v57 + 1;
      }
    }
  }
  if (*(_BYTE *)(a1 + 1112)
    && *(_BYTE *)(a1 + 5188)
    && *(double *)(a1 + 1096) - *(double *)(a1 + 25400) > *(double *)(a1 + 304))
  {
    *(_BYTE *)(a1 + 1112) = 0;
  }
  VCRateControlAlgorithmBasePriv_CheckPaused(a1);
  if (*(_DWORD *)(a1 + 1052) <= *(_DWORD *)(a1 + 80) && *(double *)(a1 + 2856) >= *(double *)(a1 + 200))
  {
    *(_BYTE *)(a1 + 5190) = 1;
    VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Hit the abnormal bad network condition. Start the abnormal bad network adaptation with softMaxTier=%u. RTT=%f, owrd=%f", v58, v59, v60, v61, v62, v63, *(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * *(int *)(a1 + 68)));
  }
  if (*(double *)(a1 + 1096) - *(double *)(a1 + 25520) > 90.0)
  {
    if (*(_BYTE *)(a1 + 5190))
      VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "The abnormal bad network condition is gone. Remove the softMaxTier and current maxTier=%u. RTT=%f, owrd=%f", v58, v59, v60, v61, v62, v63, *(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * *(int *)(a1 + 60)));
    *(_BYTE *)(a1 + 5190) = 0;
  }
  if (*(_BYTE *)(a1 + 410))
    VCRateControlAlgorithmBasePriv_CheckBandwidthOvershoot(a1, 1000 * *(_DWORD *)(a1 + 1168));
  else
    *(_DWORD *)(a1 + 1168) = 0;
  VCRateControlAlgorithmBasePriv_UpdateLossEvent(a1);
  if (*(_BYTE *)(a1 + 428))
  {
    LODWORD(v64) = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * *(int *)(a1 + 60));
    v65 = ((double)v64 * 0.5);
    v66 = *(double *)(a1 + 5072);
    if (v66 > *(double *)(a1 + 432))
    {
      for (i = *(double *)(a1 + 5080) + *(double *)(a1 + 5080); i > 0.0; i = i + i)
      {
        if (v66 <= i)
          break;
        v65 = ((double)v65 * 0.5);
      }
    }
    *(_DWORD *)(a1 + 25452) = v65;
    v68 = *(_DWORD *)(a1 + 1072) <= *(_DWORD *)(a1 + 25452);
  }
  else
  {
    v68 = 0;
  }
  v69 = 0;
  v70 = 0;
  v71 = 0;
  *(_BYTE *)(a1 + 25448) = v68;
  v72 = *(double *)(a1 + 832);
  v73 = *(double *)(a1 + 840);
  if (v73 >= *(double *)(a1 + 824) * *(double *)(a1 + 5072))
    v73 = *(double *)(a1 + 824) * *(double *)(a1 + 5072);
  if (v72 <= v73)
    v72 = v73;
  v74 = a1 + 2896;
  v75 = *(_DWORD *)(a1 + 4944) - 1;
  v76 = 0.0;
  v77 = 0.0;
  while (1)
  {
    v78 = ((_BYTE)v75 + (_BYTE)v69) & 0x3F;
    v79 = *(double *)(v74 + 32 * v78);
    if (!v69)
    {
      v80 = v74 + 32 * v78;
      v71 = *(_WORD *)(v80 + 28);
      v70 = *(_WORD *)(v80 + 26);
      v76 = *(double *)(v74 + 32 * (((_BYTE)v75 + (_BYTE)v69) & 0x3F));
    }
    if (v79 == 0.0)
      break;
    if (v76 - v79 <= v72 && v69-- != -63)
      continue;
    v82 = v74 + 32 * v78;
    v83 = *(unsigned __int16 *)(v82 + 26);
    if (v83 != v70)
      v77 = (double)(unsigned __int16)(v71 - *(_WORD *)(v82 + 28)) / (double)(unsigned __int16)(v70 - v83);
    break;
  }
  *(double *)(a1 + 5136) = v77;
  return 1;
}

void VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateVCRateControlHistory(uint64_t a1)
{
  int v1;
  uint64_t v2;

  if (a1)
  {
    v1 = *(_DWORD *)(a1 + 25360);
    if (v1)
    {
      if (v1 <= 499)
        *(_DWORD *)(a1 + 25360) = v1 + 1;
      *(_DWORD *)(a1 + 25364) = (*(_DWORD *)(a1 + 25364) + 1) % 500;
      v2 = a1 + 5360 + 40 * *(int *)(a1 + 25364);
    }
    else
    {
      v2 = a1 + 5360;
      *(_DWORD *)(a1 + 25360) = 1;
    }
    *(_QWORD *)v2 = *(_QWORD *)(a1 + 2856);
    *(_QWORD *)(v2 + 24) = *(_QWORD *)(a1 + 4992);
    *(_QWORD *)(v2 + 8) = *(_QWORD *)(a1 + 5072);
    *(_QWORD *)(v2 + 16) = *(_QWORD *)(a1 + 5080);
    *(_DWORD *)(v2 + 32) = *(_DWORD *)(a1 + 1052);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateVCRateControlHistory_cold_1();
  }
}

BOOL VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldFastRampUp(uint64_t a1)
{
  int v1;
  unsigned int v2;
  double v3;
  double v4;
  double v5;
  _BOOL8 result;

  if (a1)
  {
    if ((!*(_BYTE *)(a1 + 5190) || *(_DWORD *)(a1 + 1052) < *(_DWORD *)(a1 + 68))
      && *(_BYTE *)(a1 + 415)
      && *(double *)(a1 + 4960) == 0.0
      && *(_BYTE *)(a1 + 5352))
    {
      v1 = *(_DWORD *)(a1 + 1052);
      v2 = *(_DWORD *)(a1 + 60);
      if ((int)v2 >= *(_DWORD *)(a1 + 464) + v1)
        v2 = *(_DWORD *)(a1 + 464) + v1;
      if (*(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * v2) < (1000 * *(_DWORD *)(a1 + 1168)))
      {
        v3 = *(double *)(a1 + 1096);
        v4 = *(double *)(a1 + 472);
        if (v3 - *(double *)(a1 + 25520) > v4 && v1 <= *(_DWORD *)(a1 + 448))
        {
          v5 = *(double *)(a1 + 304);
          if (v3 - *(double *)(a1 + 1144) > v5 && v3 - *(double *)(a1 + 1152) > v5 && v3 - *(double *)(a1 + 25392) > v4)
            return 1;
        }
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldFastRampUp_cold_1();
  }
  return 0;
}

uint64_t VCRateControlAlgorithmStabilizedNOWRDPriv_RampDownTierDueToBaseband(uint64_t a1, double a2)
{
  int IsAudioOnly;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  double v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  int v15;
  double v16;
  unsigned int v17;
  double v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;

  if (a1)
  {
    *(_BYTE *)(a1 + 25472) = 1;
    VCRateControlAlgorithmStabilizedNOWRDPriv_SetBitrateUnstable(a1);
    VCRateControlAlgorithmBasePriv_UpdateCongestionStatusWhenRampDown(a1, a2);
    IsAudioOnly = VCRateControlMediaController_IsAudioOnly(*(_QWORD *)(a1 + 1016));
    if (IsAudioOnly
      && *(_DWORD *)(a1 + 1052) < *(_DWORD *)(a1 + 76)
      && (v11 = *(double *)(a1 + 584), a2 - *(double *)(a1 + 1152) < v11)
      && *(double *)(a1 + 1096) - *(double *)(a1 + 1144) < v11)
    {
      *(_BYTE *)(a1 + 25432) = 0;
      v30 = 1052;
    }
    else
    {
      if (!*(_BYTE *)(a1 + 25432) && *(_DWORD *)(a1 + 1040) != 1 || *(_DWORD *)(a1 + 1052) <= *(_DWORD *)(a1 + 1056))
      {
        *(_BYTE *)(a1 + 25432) = 0;
        v12 = *(int *)(a1 + 1052);
        v13 = *(_QWORD *)(a1 + 48);
        v14 = *(_DWORD *)(v13 + 4 * v12);
        v15 = *(_DWORD *)(a1 + 708);
        v16 = (double)v15;
        if (v15 <= 0)
          v16 = 1.0;
        v17 = *(_DWORD *)(a1 + 5256);
        if (v14 <= v17)
          v18 = (double)v17;
        else
          v18 = (double)v14 - (double)(v14 - v17) / v16;
        v19 = *(int *)(a1 + 64);
        v20 = *(int *)(a1 + 1052);
        while (*(_DWORD *)(v13 + 4 * v20) > v18)
        {
          if (((--v20 > v19) & ~IsAudioOnly) == 0)
          {
            if ((int)v20 <= (int)v19)
              LODWORD(v20) = *(_DWORD *)(a1 + 64);
            break;
          }
        }
        if ((int)v20 <= (int)v19)
          v21 = v19;
        else
          v21 = v20;
        if ((int)v12 <= (int)v21)
        {
          if (!VCRateControlMediaController_RampDownAudioFraction(*(_QWORD *)(a1 + 1016)))
          {
LABEL_27:
            *(_DWORD *)(a1 + 1056) = *(_DWORD *)(a1 + 1052);
            return v21;
          }
          v22 = *(_DWORD *)(a1 + 1084);
          VCRateControlMediaController_AudioFractionTier(*(_QWORD *)(a1 + 1016));
          VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "[%u] Congestion due to baseband!!! New audio fraction tier down to %u. Video stopped.", v23, v24, v25, v26, v27, v28, v22);
        }
        else
        {
          VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "[%u] Congestion due to baseband!!! New bitrate down to %u [slow:%f]", v5, v6, v7, v8, v9, v10, *(_DWORD *)(a1 + 1084));
        }
        *(double *)(a1 + 1152) = a2;
        goto LABEL_27;
      }
      *(_BYTE *)(a1 + 25432) = 0;
      v30 = 1056;
    }
    return *(unsigned int *)(a1 + v30);
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlAlgorithmStabilizedNOWRDPriv_RampDownTierDueToBaseband_cold_1();
  }
  return 0;
}

uint64_t VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampUp(uint64_t a1)
{
  _BOOL4 v2;
  double v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  char v12;
  int v13;
  int v14;
  int v15;
  double *v16;
  double v18;
  double v19;
  int v20;

  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampUp_cold_1();
    }
    return 1;
  }
  v2 = *(_BYTE *)(a1 + 5188) != 0;
  if (!*(_BYTE *)(a1 + 5188))
    *(_DWORD *)(a1 + 1044) |= 2u;
  if (*(_BYTE *)(a1 + 25432))
  {
    v2 = 0;
    *(_DWORD *)(a1 + 1044) |= 4u;
  }
  if (*(_BYTE *)(a1 + 1121))
  {
    v2 = 0;
    *(_DWORD *)(a1 + 1044) |= 8u;
  }
  if (VCRateControlAlgorithmBasePriv_RecentlyGoAboveRampUpBandwidth(a1))
  {
    v2 = 0;
    *(_DWORD *)(a1 + 1044) |= 0x200u;
  }
  if (!*(_BYTE *)(a1 + 2848))
  {
    v2 = 0;
    *(_DWORD *)(a1 + 1044) |= 0x100u;
  }
  if (*(_BYTE *)(a1 + 2849))
  {
    v2 = 0;
    *(_DWORD *)(a1 + 1044) |= 0x80u;
  }
  if (*(double *)(a1 + 2856) > *(double *)(a1 + 200))
  {
    v2 = 0;
    *(_DWORD *)(a1 + 1044) |= 0x10u;
  }
  if (*(double *)(a1 + 2864) > *(double *)(a1 + 208))
  {
    v2 = 0;
    *(_DWORD *)(a1 + 1044) |= 0x20u;
  }
  v3 = *(double *)(a1 + 2880);
  if (v3 > _VCRateControlAlgorithmStabilizedNOWRD_CongestionLevelThreshold(a1, 1, 0))
  {
    v2 = 0;
    *(_DWORD *)(a1 + 1044) |= 0x40u;
  }
  if (*(_BYTE *)(a1 + 5280) && *(_DWORD *)(a1 + 1040) != 1 && !*(_DWORD *)(a1 + 5276))
  {
    v2 = 0;
    *(_DWORD *)(a1 + 1044) |= 0x400u;
  }
  v11 = *(_DWORD *)(a1 + 1052);
  if (v11 >= *(_DWORD *)(a1 + 60))
  {
    v2 = 0;
    *(_DWORD *)(a1 + 1044) |= 0x1000u;
    v11 = *(_DWORD *)(a1 + 1052);
  }
  if (v11 >= *(_DWORD *)(a1 + 448))
  {
    v12 = *(_BYTE *)(a1 + 417);
    if (v12)
      v12 = *(_BYTE *)(a1 + 25528) != 0;
    if (*(_DWORD *)(a1 + 1040) == 1)
    {
      if (*(_DWORD *)(a1 + 1168))
        goto LABEL_36;
      goto LABEL_35;
    }
    if (*(double *)(a1 + 1096) - *(double *)(a1 + 25520) < *(double *)(a1 + 648))
      v12 = 1;
    if ((v12 & 1) != 0)
    {
LABEL_35:
      v2 = 0;
      *(_DWORD *)(a1 + 1044) |= 0x4000u;
    }
  }
LABEL_36:
  if (*(_BYTE *)(a1 + 416))
  {
    v13 = _VCRateControlAlgorithmStabilizedNOWRD_CheckNetworkSaturation(a1, *(double *)(a1 + 5072), *(double *)(a1 + 5080), *(double *)(a1 + 4992), *(double *)(a1 + 2856), v4, v5, v6, v7, v8, v9, v10);
    if (*(int *)(a1 + 496) >= 1)
    {
      v14 = 0;
      v15 = 500;
      do
      {
        v16 = (double *)(a1 + 5360 + 40 * ((v15 + *(_DWORD *)(a1 + 25364)) % 500));
        v13 &= _VCRateControlAlgorithmStabilizedNOWRD_CheckNetworkSaturation(a1, v16[1], v16[2], v16[3], *v16, v4, v5, v6, v7, v8, v9, v10);
        ++v14;
        --v15;
      }
      while (v14 < *(_DWORD *)(a1 + 496));
    }
    if (v13)
    {
      v2 = 0;
      *(_DWORD *)(a1 + 1044) |= 0x2000u;
    }
  }
  if (VCRateControlAlgorithmBasePriv_ShouldBlockRampUpDueToLossEventThreshold(a1, v4, v5, v6, v7, v8, v9, v10))
  {
    v2 = 0;
    *(_DWORD *)(a1 + 1044) |= 0x4000u;
  }
  if (*(double *)(a1 + 5136) > 0.0)
  {
    v2 = 0;
    *(_DWORD *)(a1 + 1044) |= 0x8000u;
  }
  if (*(_BYTE *)(a1 + 5292) && *(_DWORD *)(a1 + 5284) && !*(_BYTE *)(a1 + 5281))
  {
    *(_DWORD *)(a1 + 1044) |= 0x10000u;
  }
  else if (v2)
  {
    *(_QWORD *)(a1 + 25424) = *(_QWORD *)(a1 + 1096);
    return 1;
  }
  v18 = *(double *)(a1 + 232);
  if (v18 != 0.0)
  {
    v19 = *(double *)(a1 + 25424);
    if (v19 != 0.0 && *(double *)(a1 + 1096) - v19 >= v18)
    {
      v20 = *(_DWORD *)(a1 + 1044);
      if (v20 == 8 || v20 == 2048 || v20 == 1024)
      {
        *(_DWORD *)(a1 + 1044) = 0;
        return 1;
      }
    }
  }
  return 0;
}

uint64_t VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampDown(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 v9;
  double v10;
  int v11;
  uint64_t v12;
  double v13;
  double v14;
  double v15;
  double v16;
  int v17;
  double v18;
  double v19;
  int v20;
  double v21;
  unsigned int v22;
  unsigned int v23;
  _BOOL4 v25;
  _BOOL4 v27;

  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampDown_cold_1();
    }
    return 0;
  }
  *(_DWORD *)(a1 + 25436) = *(_DWORD *)(a1 + 352);
  if (!*(_BYTE *)(a1 + 2848))
    return 0;
  v9 = VCRateControlAlgorithmBasePriv_KeepOvershootingRampDownBandwidth(a1);
  if (v9)
  {
    *(_DWORD *)(a1 + 1048) |= 0x10u;
    *(_DWORD *)(a1 + 25436) = 0;
    *(_QWORD *)(a1 + 2880) = 0;
  }
  if (!*(_BYTE *)(a1 + 2840))
  {
    v10 = *(double *)(a1 + 25376);
    if (v10 > 0.0 && *(double *)(a1 + 1096) - v10 > *(double *)(a1 + 160))
    {
      *(_DWORD *)(a1 + 1048) |= 1u;
      *(_QWORD *)(a1 + 25376) = 0;
      *(_QWORD *)(a1 + 2880) = 0;
      v9 = 1;
    }
  }
  if (*(_BYTE *)(a1 + 25472))
    goto LABEL_47;
  if (*(_BYTE *)(a1 + 25432) || *(_DWORD *)(a1 + 1040) == 1)
  {
    v11 = *(unsigned __int8 *)(a1 + 1121);
    v12 = 88;
    if (!*(_BYTE *)(a1 + 1121))
      v12 = 104;
    v13 = *(double *)(a1 + 40 + v12);
    v14 = *(double *)(a1 + 2864);
    if (v14 > v13 && *(double *)(a1 + 25368) > v13 && *(double *)(a1 + 2872) > 0.0)
    {
      *(double *)(a1 + 25368) = v14;
      if (!v11)
      {
        *(_DWORD *)(a1 + 1048) |= 4u;
        *(_QWORD *)(a1 + 2880) = 0;
        v9 = 1;
        if (*(_BYTE *)(a1 + 25472))
          goto LABEL_47;
      }
      goto LABEL_22;
    }
  }
  else
  {
    v14 = 0.0;
  }
  *(double *)(a1 + 25368) = v14;
LABEL_22:
  v15 = _VCRateControlAlgorithmStabilizedNOWRD_CongestionLevelThreshold(a1, 1, 1);
  if (*(double *)(a1 + 25368) > *(double *)(a1 + 2864))
    goto LABEL_37;
  if ((*(_BYTE *)(a1 + 25432) || *(_DWORD *)(a1 + 1040) == 1) && !*(_BYTE *)(a1 + 1121))
    v15 = *(double *)(a1 + 152);
  if (*(_BYTE *)(a1 + 25448) && !*(_BYTE *)(a1 + 5176))
  {
    if (*(double *)(a1 + 2880) > v15)
      VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Possible ramp down suppression with RTT:%.3f, minRTT:%.3f, bitrateThreshold:%u, suppressionFactor:%.3f, NOWRDAcc:%.3f", v3, v4, v5, v6, v7, v8, *(_QWORD *)(a1 + 5072));
    v15 = v15 * *(double *)(a1 + 440);
  }
  v16 = *(double *)(a1 + 2880);
  if (v16 <= v15 || *(_DWORD *)(a1 + 1052) <= *(_DWORD *)(a1 + 64))
  {
LABEL_37:
    v17 = 0;
  }
  else
  {
    *(double *)(a1 + 2880) = v16 - v15;
    if (*(double *)(a1 + 2880) < 0.0)
      *(_QWORD *)(a1 + 2880) = 0;
    v17 = 1;
  }
  if (*(double *)(a1 + 2856) <= 0.0)
  {
    v18 = *(double *)(a1 + 25416);
  }
  else
  {
    v18 = *(double *)(a1 + 1096);
    *(double *)(a1 + 25416) = v18;
  }
  if (v18 > 0.0)
  {
    v19 = *(double *)(a1 + 1096) - v18;
    if (v19 > 1.0)
    {
      *(_QWORD *)(a1 + 2880) = 0;
      *(_QWORD *)(a1 + 25416) = *(_QWORD *)(a1 + 1096);
      VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "OWRD has been 0 for %f seconds, reset NOWRDAcc", v3, v4, v5, v6, v7, v8, SLOBYTE(v19));
      if ((v17 & 1) == 0)
        goto LABEL_47;
      goto LABEL_46;
    }
  }
  if (v17)
  {
LABEL_46:
    *(_DWORD *)(a1 + 1048) |= 8u;
    v9 = 1;
  }
LABEL_47:
  v20 = *(_DWORD *)(a1 + 108);
  if (v20 >= 1
    && *(_DWORD *)(a1 + 4984) > v20
    && *(_DWORD *)(a1 + 25500)
    && *(_DWORD *)(a1 + 1052) >= *(_DWORD *)(a1 + 112))
  {
    *(_DWORD *)(a1 + 1048) |= 0x100u;
    *(_QWORD *)(a1 + 2880) = 0;
    VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "BurstyLossRampDown RTT=%f, avgPLR=%f, PLRThreshold=%f, threshold=%d", v3, v4, v5, v6, v7, v8, *(_QWORD *)(a1 + 5072));
    v9 = 1;
    *(_BYTE *)(a1 + 5129) = 1;
  }
  if (VCRateControlAlgorithmBasePriv_ShouldRampDownDueToLossEvent(a1, v2, v3, v4, v5, v6, v7, v8))
  {
    *(_DWORD *)(a1 + 1048) |= 0x200u;
    *(_QWORD *)(a1 + 4952) = *(_QWORD *)(a1 + 1096);
    VCRateControlAlgorithmBasePriv_ResetLossEventBuffer(a1);
    *(_QWORD *)(a1 + 2880) = 0;
    v9 = 1;
  }
  v21 = *(double *)(a1 + 5136);
  v22 = *(_DWORD *)(a1 + 1072);
  v23 = *(_DWORD *)(a1 + 816);
  if (v21 > *(double *)(a1 + 800) && v22 >= v23)
  {
    if (*(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * *(int *)(a1 + 60)) == v23)
      *(_DWORD *)(a1 + 25456) = 1;
  }
  else
  {
    v25 = v22 > *(_DWORD *)(a1 + 808);
    v27 = v21 > *(double *)(a1 + 792) && v22 > *(_DWORD *)(a1 + 812);
    if (v21 > *(double *)(a1 + 784) && !v27)
      v27 = v25;
    if (!v27)
      goto LABEL_74;
  }
  *(_DWORD *)(a1 + 1048) |= 0x800u;
  VCRateControlAlgorithmBasePriv_ResetLossEventBuffer(a1);
  *(_QWORD *)(a1 + 2880) = 0;
  v9 = 1;
LABEL_74:
  if (*(double *)(a1 + 5072) > *(double *)(a1 + 160) && *(_DWORD *)(a1 + 1052) > *(_DWORD *)(a1 + 72))
  {
    *(_DWORD *)(a1 + 1048) |= 0x400u;
    *(_QWORD *)(a1 + 2880) = 0;
    return 1;
  }
  return v9;
}

void VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateSmartBrakeOutputWithVCRCStatistics(uint64_t a1, uint64_t a2)
{
  float v2;
  float v3;
  float v4;
  float v5;
  float v6;

  if (a1)
  {
    if (a2)
    {
      v2 = *(double *)(a1 + 1096);
      *(float *)(a1 + 25544) = v2;
      *(float *)(a1 + 25548) = (float)*(unsigned int *)(a1 + 1080);
      v3 = *(double *)(a1 + 5072);
      *(float *)(a1 + 25556) = v3;
      v4 = *(double *)(a1 + 2856);
      *(float *)(a1 + 25552) = v4;
      v5 = *(double *)(a1 + 5048);
      *(float *)(a1 + 25560) = v5;
      v6 = *(double *)(a1 + 5056);
      *(float *)(a1 + 25564) = v6;
      if (*(_DWORD *)(a1 + 848))
        VCRateControlSmartBrake_Query(*(_QWORD *)(a1 + 25536), a1 + 25544, a1 + 5296);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateSmartBrakeOutputWithVCRCStatistics_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateSmartBrakeOutputWithVCRCStatistics_cold_1();
  }
}

uint64_t VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampDownDueToBaseband(uint64_t a1)
{
  double v2;
  _BYTE *v3;
  int v4;
  char v5;
  char v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  double v20;
  char v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  double *v29;
  double v30;
  double v31;
  double v32;
  double VideoKeyFrameTime;

  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampDownDueToBaseband_cold_1();
    }
    return 0;
  }
  if (!*(_BYTE *)(a1 + 5280))
    return 0;
  v2 = *(double *)(a1 + 5232);
  v3 = *(_BYTE **)(a1 + 1016);
  v4 = VCRateControlMediaController_BasebandFlushCount((uint64_t)v3);
  if (v4 > 0)
  {
    v5 = v4;
    v6 = objc_msgSend(v3, "basebandFlushCount");
    VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Still trying to flush baseband with flush counter %d. No further ramp up/down but possibly decrease audio fraction.", v7, v8, v9, v10, v11, v12, v6);
    if (v2 - VCRateControlMediaController_LastBasebandFlushCountChangeTime((uint64_t)v3) <= 3.0
      || *(double *)(a1 + 5264) >= 0.001)
    {
      goto LABEL_24;
    }
    VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Flush counter: %d stuck for more than %d seconds. And baseband shows TxRate:%d, TxDelay:%f. Reset the flush counter!", v13, v14, v15, v16, v17, v18, v5);
    VCRateControlMediaController_SetBasebandFlushCount((uint64_t)v3, 0);
LABEL_23:
    VCRateControlMediaController_SetLastBasebandFlushCountChangeTime((uint64_t)v3, v2);
LABEL_24:
    v21 = objc_msgSend(v3, "basebandFlushCount");
    VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Try to ramp down audio fraction with [flushCount:%d, BBAvgRate:%d]", v22, v23, v24, v25, v26, v27, v21);
    VCRateControlMediaController_RampDownAudioFraction((uint64_t)v3);
    v19 = 0;
    *(_DWORD *)(a1 + 1048) |= 0x80u;
    return v19;
  }
  if (!*(_DWORD *)(a1 + 5256))
    goto LABEL_23;
  if (!*(_BYTE *)(a1 + 1120) || objc_msgSend(v3, "basebandFlushCount"))
    goto LABEL_14;
  if (*(_BYTE *)(a1 + 25432) || *(_DWORD *)(a1 + 1040) == 1)
    v29 = (double *)(a1 + 552);
  else
    v29 = (double *)(a1 + 544);
  v30 = *v29;
  if (VCRateControlMediaController_IsAudioOnly((uint64_t)v3))
  {
    if (*(double *)(a1 + 5240) > v30 || *(double *)(a1 + 5248) > *(double *)(a1 + 560))
    {
      v31 = *(double *)(a1 + 5264);
      v32 = *(double *)(a1 + 568);
      goto LABEL_39;
    }
LABEL_14:
    v19 = 0;
    goto LABEL_15;
  }
  VideoKeyFrameTime = VCRateControlMediaController_LastVideoKeyFrameTime(*(_QWORD *)(a1 + 1016));
  if (*(double *)(a1 + 5240) <= v30
    && *(double *)(a1 + 5248) <= *(double *)(a1 + 560)
    && !VCRateControlMediaController_IsVideoStopped(v3))
  {
    goto LABEL_14;
  }
  v19 = 0;
  if (*(double *)(a1 + 5264) > *(double *)(a1 + 568) && VideoKeyFrameTime > 0.0)
  {
    v31 = *(double *)(a1 + 5232) - VideoKeyFrameTime;
    v32 = 0.5;
LABEL_39:
    if (v31 > v32)
    {
      *(_DWORD *)(a1 + 1048) |= 0x20u;
      *(_QWORD *)(a1 + 2880) = 0;
      v19 = 1;
      goto LABEL_15;
    }
    goto LABEL_14;
  }
LABEL_15:
  if ((objc_msgSend(v3, "isAudioOnly") & 1) == 0)
  {
    v20 = VCRateControlMediaController_LastVideoKeyFrameTime(*(_QWORD *)(a1 + 1016));
    if ((!*(_BYTE *)(a1 + 704) || v20 > 0.0 && *(double *)(a1 + 5232) - v20 > 0.5)
      && *(double *)(a1 + 5264) > *(double *)(a1 + 576))
    {
      *(_DWORD *)(a1 + 1048) |= 0x40u;
      *(_QWORD *)(a1 + 2880) = 0;
      v19 = 1;
    }
  }
  if (*(double *)(a1 + 5240) > *(double *)(a1 + 544))
    *(_QWORD *)(a1 + 25488) = *(_QWORD *)(a1 + 5232);
  return v19;
}

uint64_t VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampUpDueToBaseband(double *a1)
{
  if (a1)
  {
    if (a1[655] > a1[75] || a1[658] > a1[76] || a1[654] - a1[3186] < a1[77])
      return 0;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampUpDueToBaseband_cold_1();
  }
  return 1;
}

uint64_t VCRateControlAlgorithmStabilizedNOWRDPriv_BasebandAdditionalTiersForRampUp(uint64_t a1)
{
  _BYTE *v2;
  uint64_t v3;
  char v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCRateControlAlgorithmStabilizedNOWRDPriv_BasebandAdditionalTiersForRampUp_cold_1();
    }
    return 0;
  }
  v2 = *(_BYTE **)(a1 + 1016);
  if (VCRateControlMediaController_BasebandFlushCount((uint64_t)v2))
  {
    *(_DWORD *)(a1 + 1044) |= 0x800u;
    v3 = *(_QWORD *)(a1 + 5120);
    if (v3)
    {
      v4 = objc_msgSend(v2, "basebandFlushCount");
      VRLogfilePrintWithTimestamp(v3, "Still trying to flush baseband with flush counter: %d. Stop ramp-up!\n", v5, v6, v7, v8, v9, v10, v4);
      return 0;
    }
  }
  else if (*(_DWORD *)(a1 + 5256))
  {
    if ((objc_msgSend(v2, "isAudioOnly") & 1) != 0)
    {
      return 1;
    }
    else
    {
      v3 = 1;
      if (!VCRateControlMediaController_IsVideoStopped(v2))
      {
        if (objc_msgSend(v2, "audioFractionTier"))
          return 1;
        else
          return 2;
      }
    }
  }
  else
  {
    v3 = 0;
    *(_DWORD *)(a1 + 1044) |= 0x800u;
  }
  return v3;
}

void _VCRateControlAlgorithmStabilizedNOWRD_ToggleSmartBrake(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  const char *v10;
  int v11;
  const __CFString *v12;
  int v13;
  uint64_t v14;
  NSObject *v15;
  const char *v16;
  NSObject *v17;
  uint32_t v18;
  uint64_t v19;
  NSObject *v20;
  int v21;
  uint64_t v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  int v26;
  __int16 v27;
  const __CFString *v28;
  __int16 v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v9 = *(_DWORD *)(a1 + 1040);
  if (v9 == 5)
    v10 = "Smart brake disengaged";
  else
    v10 = "Smart brake engaged";
  VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, v10, a3, a4, a5, a6, a7, a8, v21);
  v11 = *(_DWORD *)(a1 + 848);
  if (v9 == 5)
  {
    if (v11 == 1)
      VCRateControlMediaController_ResumeVideoBySmartBrake(*(unsigned __int8 **)(a1 + 1016));
    *(double *)(a1 + 5152) = *(double *)(a1 + 1096) - *(double *)(a1 + 25568);
    *(_DWORD *)(a1 + 5160) = *(_DWORD *)(a1 + 5300);
    ++*(_DWORD *)(a1 + 5144);
    if (*(_BYTE *)(a1 + 25576))
    {
      *(_DWORD *)(a1 + 848) = 0;
      if (objc_opt_class() == a1)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v14 = VRTraceErrorLogLevelToCSTR();
          v15 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v21 = 136315650;
            v22 = v14;
            v23 = 2080;
            v24 = "_VCRateControlAlgorithmStabilizedNOWRD_ToggleSmartBrake";
            v25 = 1024;
            v26 = 1409;
            v16 = "VCRC [%s] %s:%d Smart brake disabled due to long engagement time.";
            v17 = v15;
            v18 = 28;
LABEL_22:
            _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, v16, (uint8_t *)&v21, v18);
          }
        }
      }
      else
      {
        if ((objc_opt_respondsToSelector() & 1) != 0)
          v12 = (const __CFString *)objc_msgSend((id)a1, "performSelector:", sel_logPrefix);
        else
          v12 = &stru_1E9E58EE0;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v19 = VRTraceErrorLogLevelToCSTR();
          v20 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v21 = 136316162;
            v22 = v19;
            v23 = 2080;
            v24 = "_VCRateControlAlgorithmStabilizedNOWRD_ToggleSmartBrake";
            v25 = 1024;
            v26 = 1409;
            v27 = 2112;
            v28 = v12;
            v29 = 2048;
            v30 = a1;
            v16 = "VCRC [%s] %s:%d %@(%p) Smart brake disabled due to long engagement time.";
            v17 = v20;
            v18 = 48;
            goto LABEL_22;
          }
        }
      }
    }
  }
  else
  {
    if (v11 == 1)
      VCRateControlMediaController_StopVideoBySmartBrake(*(unsigned __int8 **)(a1 + 1016));
    v13 = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * *(int *)(a1 + 1052));
    *(_QWORD *)(a1 + 25568) = *(_QWORD *)(a1 + 1096);
    *(_DWORD *)(a1 + 5168) = v13;
    *(_DWORD *)(a1 + 5164) = *(_DWORD *)(a1 + 5300);
  }
}

uint64_t _VCRateControlAlgorithmStabilizedNOWRD_SmartBrakeBitrateCongestionTierIndex(unsigned int *a1, double a2)
{
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;

  v2 = a1 + 10;
  v3 = a1[212];
  if (v3 == 2)
    return 10;
  if (v3 != 3)
    return a1[263];
  LODWORD(a2) = a1[1325];
  v4 = ((double)*(unint64_t *)&a2 * 0.5);
  result = a1[15];
  v6 = *((_QWORD *)v2 + 1);
  if (*(_DWORD *)(v6 + 4 * (int)result) > v4)
  {
    v7 = (int)result;
    v8 = (int)v2[6];
    if ((int)result >= (int)v8)
      result = v8;
    else
      result = result;
    v9 = v6 - 4;
    while (v7 > v8)
    {
      v10 = v7 - 1;
      v11 = *(_DWORD *)(v9 + 4 * v7--);
      if (v11 <= v4)
        return v10;
    }
  }
  return result;
}

uint64_t _VCRateControlAlgorithmStabilizedNOWRD_RampDownTier(uint64_t a1)
{
  uint64_t v2;
  int v3;
  int v4;
  int v5;
  unsigned int v6;
  int *v7;
  int v8;
  unsigned int v9;
  uint64_t v10;
  BOOL v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char v28;

  VCRateControlAlgorithmStabilizedNOWRDPriv_SetBitrateUnstable(a1);
  VCRateControlAlgorithmBasePriv_UpdateCongestionStatusWhenRampDown(a1, *(double *)(a1 + 1096));
  *(_BYTE *)(a1 + 25432) = 0;
  v2 = *(unsigned int *)(a1 + 1052);
  if (!*(_BYTE *)(a1 + 418)
    || (int)v2 >= *(_DWORD *)(a1 + 80)
    || *(double *)(a1 + 1096) - *(double *)(a1 + 1144) >= *(double *)(a1 + 592))
  {
    v3 = v2 - *(_DWORD *)(a1 + 96);
    if (*(_DWORD *)(a1 + 1040) == 1)
      v3 = v3 - *(_DWORD *)(a1 + 104) - ((_DWORD)v2 == *(_DWORD *)(a1 + 56));
    v4 = *(_DWORD *)(a1 + 1048);
    if ((v4 & 0x200) != 0 && (*(double *)(a1 + 4960) > 0.0 || *(_DWORD *)(a1 + 1072) > *(_DWORD *)(a1 + 25452)))
      --v3;
    if ((v4 & 0x800) != 0)
    {
      v5 = *(_DWORD *)(a1 + 25456);
      if (v5)
      {
        v3 -= v5;
        *(_DWORD *)(a1 + 25456) = 0;
        v4 = *(_DWORD *)(a1 + 1048);
      }
    }
    if ((v4 & 0x400) != 0 && v3 >= *(_DWORD *)(a1 + 72))
      v3 = *(_DWORD *)(a1 + 72);
    if (*(_BYTE *)(a1 + 418) && v3 < *(_DWORD *)(a1 + 80))
      *(_DWORD *)(a1 + 25436) = 0;
    v6 = *(_DWORD *)(a1 + 25436);
    if (v6)
    {
      v7 = (int *)(*(_QWORD *)(a1 + 48) + 4 * v3++);
      do
      {
        v8 = *v7--;
        --v3;
      }
      while (*(_DWORD *)(a1 + 1072) - v8 < v6);
    }
    if (*(_BYTE *)(a1 + 421))
    {
      v9 = *(_DWORD *)(a1 + 1080);
      v10 = *(_QWORD *)(a1 + 48);
      if (v9 > *(_DWORD *)(v10 + 4 * *(int *)(a1 + 424)) && v3 >= 1)
      {
        while (*(_DWORD *)(v10 + 4 * v3) > v9)
        {
          v12 = __OFSUB__(v3--, 1);
          if ((v3 < 0) ^ v12 | (v3 == 0))
          {
            v3 = 0;
            break;
          }
        }
      }
    }
    v13 = *(_DWORD *)(a1 + 64);
    if (v3 <= v13)
      v2 = v13;
    else
      v2 = v3;
    if (VCRateControlMediaController_IsAudioOnly(*(_QWORD *)(a1 + 1016)))
    {
      v20 = *(_DWORD *)(a1 + 76);
      if ((int)v2 <= v20)
        v2 = v20;
      else
        v2 = v2;
      if (*(_DWORD *)(a1 + 1052) <= (int)v2)
        goto LABEL_43;
    }
    else if (*(_DWORD *)(a1 + 1052) <= (int)v2)
    {
      VCRateControlMediaController_StopVideoByVCRateControl(*(unsigned __int8 **)(a1 + 1016));
      VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Congestion!!! Stop video!", v21, v22, v23, v24, v25, v26, v28);
      goto LABEL_43;
    }
    VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "[%u] Congestion!!! New bitrate down to %u", v14, v15, v16, v17, v18, v19, *(_DWORD *)(a1 + 1084));
    *(_QWORD *)(a1 + 1144) = *(_QWORD *)(a1 + 1096);
LABEL_43:
    *(_DWORD *)(a1 + 1056) = *(_DWORD *)(a1 + 1052);
  }
  return v2;
}

uint64_t _VCRateControlAlgorithmStabilizedNOWRD_RampUpTier(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  int v25;
  unsigned int v26;
  unsigned int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  int *v32;
  uint64_t v33;
  int v34;
  BOOL v35;
  int v36;
  int v37;
  uint64_t v38;
  int *v40;
  int v41;
  BOOL v42;
  unsigned int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  char v51;

  VCRateControlAlgorithmStabilizedNOWRDPriv_SetBitrateUnstable(a1);
  VCRateControlAlgorithmBasePriv_UpdateCongestionStatusWhenRampUp(a1);
  v2 = *(void **)(a1 + 1016);
  if ((objc_msgSend(v2, "isAudioOnly") & 1) == 0
    && objc_msgSend(v2, "isVideoStoppedByVCRateControl")
    && *(_DWORD *)(a1 + 1052) == *(_DWORD *)(a1 + 64))
  {
    if (objc_msgSend(v2, "audioFractionTier"))
    {
      VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Ramp Up!!! Ramp up audio fraction first. Video is still stopped!", v10, v11, v12, v13, v14, v15, v51);
      objc_msgSend(v2, "rampUpAudioFraction");
    }
    else
    {
      VCRateControlMediaController_ResumeVideo((unsigned __int8 *)v2);
      VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Ramp Up!!! Resume video first!", v44, v45, v46, v47, v48, v49, v51);
    }
    return *(unsigned int *)(a1 + 1052);
  }
  v16 = VCRateControlAlgorithmBasePriv_AllowRampUpWithContinuousTargetBitrate(a1, v3, v4, v5, v6, v7, v8, v9);
  v23 = *(unsigned int *)(a1 + 1052);
  if (!v16)
    return v23;
  v24 = *(_DWORD *)(a1 + 92) + v23;
  if (*(_DWORD *)(a1 + 1040) != 1)
  {
    *(_BYTE *)(a1 + 25432) = 1;
    v27 = *(_DWORD *)(a1 + 356);
    if (*(_BYTE *)(a1 + 410))
    {
      if (v27)
      {
        v28 = *(_DWORD *)(a1 + 1168);
        if (v28)
        {
          v29 = *(int *)(a1 + 240);
          if ((int)(v29 + v24) <= 49)
          {
            v30 = *(_QWORD *)(a1 + 48);
            v31 = 1000 * v28;
            v32 = (int *)(v30 + 4 * (int)v24);
            v33 = v29 + (int)v24;
            while (1)
            {
              v34 = *v32++;
              if (v34 - *(_DWORD *)(a1 + 1072) >= v27 || *(_DWORD *)(v30 + 4 * (int)(v29 + v24)) >= v31)
                break;
              ++v24;
              if (++v33 >= 50)
              {
                v24 = 50 - v29;
                goto LABEL_35;
              }
            }
          }
        }
      }
    }
    else
    {
      if (*(_BYTE *)(a1 + 411))
        v35 = v27 == 0;
      else
        v35 = 1;
      if (!v35)
      {
        v36 = *(_DWORD *)(a1 + 5276);
        v37 = *(_DWORD *)(a1 + 1072);
        v38 = *(_QWORD *)(a1 + 48);
        if (*(_DWORD *)(v38 + 4 * (int)v24) - v37 < v27 && v36 >= 1)
        {
          v40 = (int *)(v38 + 4 * (int)v24 + 4);
          do
          {
            v41 = *v40++;
            v42 = v41 - v37 < v27 && v36-- > 1;
            ++v24;
          }
          while (v42);
        }
      }
    }
    goto LABEL_35;
  }
  v25 = *(_DWORD *)(a1 + 1168);
  if (v25)
  {
    v26 = *(_DWORD *)(a1 + 100) + v24;
    if (*(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * (int)v26) >= (1000 * v25))
      goto LABEL_35;
  }
  else
  {
    v26 = *(_DWORD *)(a1 + 100) + v24;
  }
  v24 = v26;
LABEL_35:
  *(_DWORD *)(a1 + 5276) = 0;
  *(_DWORD *)(a1 + 4968) = 0;
  v43 = *(_DWORD *)(a1 + 60);
  if ((int)v24 >= (int)v43)
    v23 = v43;
  else
    v23 = v24;
  VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "[%u] Ramp up bitrate to %u", v17, v18, v19, v20, v21, v22, *(_DWORD *)(a1 + 1084));
  *(_DWORD *)(a1 + 1056) = *(_DWORD *)(a1 + 1052);
  return v23;
}

BOOL _VCRateControlAlgorithmStabilizedNOWRD_IsBitrateOscillating(uint64_t a1, int a2)
{
  int v2;
  int v3;
  int v4;
  int v5;
  BOOL v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  _OWORD v14[12];
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 414)
    && (v15 = 0, memset(v14, 0, sizeof(v14)), ++*((_DWORD *)v14 + a2), v2 = *(_DWORD *)(a1 + 25360), v2 >= 2))
  {
    v3 = *(_DWORD *)(a1 + 25364) + 500;
    v4 = 1;
    v5 = *(_DWORD *)(a1 + 512);
    v6 = 1;
    v7 = a2;
    v8 = 1;
    v9 = 1;
    v10 = a2;
    do
    {
      v11 = v10;
      v10 = *(_DWORD *)(a1 + 5360 + 40 * (v3 % 500) + 32);
      if (v11 != v10)
      {
        v12 = *((_DWORD *)v14 + v10);
        if (!v12)
          ++v8;
        *((_DWORD *)v14 + v10) = v12 + 1;
        ++v9;
      }
      if (v10 < v7)
        v7 = v10;
      if (v9 > v5 && v8 < *(_DWORD *)(a1 + 516) && v7 == a2)
        break;
      v6 = v4 < v2 - 1;
      --v3;
      ++v4;
    }
    while (v2 != v4);
  }
  else
  {
    return 0;
  }
  return v6;
}

uint64_t _VCRateControlAlgorithmStabilizedNOWRD_GetRampUpFrozenDuration(uint64_t result)
{
  int v1;

  v1 = *(_DWORD *)(result + 1052);
  if (v1 >= *(_DWORD *)(result + 72) || v1 < *(_DWORD *)(result + 68) || !*(_BYTE *)(result + 5190))
  {
    if (*(_BYTE *)(result + 413))
      return arc4random_uniform(0xFFFFu);
  }
  return result;
}

uint64_t _VCRateControlAlgorithmStabilizedNOWRD_CheckNetworkSaturation(uint64_t a1, double a2, double a3, double a4, double a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v12;

  v12 = 0;
  if (*(double *)(a1 + 480) * a3 < a2 && a4 > 0.0 && *(double *)(a1 + 488) * a3 < a5)
  {
    VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Possible network saturation detected with RTT:%f, minRTT:%f, PLR:%f, owrd:%f", a7, a8, a9, a10, a11, a12, SLOBYTE(a2));
    return 1;
  }
  return v12;
}

void VCVirtualAVCaptureInputPort_OnMediaSample(uint64_t a1, const void *a2, uint64_t a3)
{
  void *v6;
  uint64_t v7;
  unsigned int v8;

  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 48));
  v6 = *(void **)(a1 + 40);
  if (objc_msgSend(v6, "count"))
  {
    v7 = 0;
    v8 = 1;
    do
    {
      VCVirtualAVCaptureConnection_OnMediaSample(objc_msgSend(v6, "objectAtIndexedSubscript:", v7), a2, a3);
      v7 = v8;
    }
    while (objc_msgSend(v6, "count") > (unint64_t)v8++);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 48));
}

uint64_t VCMediaNegotiatorMediaType_StreamGroupIDFromMediaType(int a1)
{
  uint64_t result;
  uint64_t v3;
  NSObject *v4;

  if ((a1 - 1) < 6)
    return *(unsigned int *)&aRcimemacercsas[4 * (char)(a1 - 1)];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v3 = VRTraceErrorLogLevelToCSTR();
    v4 = *MEMORY[0x1E0CF2758];
    result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    VCMediaNegotiatorMediaType_StreamGroupIDFromMediaType_cold_1(v3, a1, v4);
  }
  return 0;
}

uint64_t VCMediaNegotiatorMediaType_MediaTypeFromStreamGroupID(int a1)
{
  uint64_t result;
  uint64_t v3;
  NSObject *v4;

  if (a1 > 1835623281)
  {
    switch(a1)
    {
      case 1937339233:
        return 4;
      case 1935897189:
        return 3;
      case 1835623282:
        return 1;
    }
  }
  else
  {
    switch(a1)
    {
      case 1650745716:
        return 6;
      case 1667329381:
        return 2;
      case 1718909044:
        return 5;
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v3 = VRTraceErrorLogLevelToCSTR();
    v4 = *MEMORY[0x1E0CF2758];
    result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    VCMediaNegotiatorMediaType_MediaTypeFromStreamGroupID_cold_1(v3, a1, v4);
  }
  return 0;
}

uint64_t VCMediaNegotiationBlobV2SettingsU1ReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  int v15;
  char v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char v22;
  VCMediaNegotiationBlobV2StreamGroupEncodeDecodeFeatures *v23;
  uint64_t result;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        v14 = v9++ >= 9;
        if (v14)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      if ((v10 >> 3) == 2)
      {
        v23 = objc_alloc_init(VCMediaNegotiationBlobV2StreamGroupEncodeDecodeFeatures);
        objc_msgSend((id)a1, "addEncodeDecodeFeatures:", v23);

        if (!PBReaderPlaceMark()
          || (VCMediaNegotiationBlobV2StreamGroupEncodeDecodeFeaturesReadFrom((uint64_t)v23, a2) & 1) == 0)
        {
          return 0;
        }
        PBReaderRecallMark();
      }
      else if ((v10 >> 3) == 1)
      {
        v17 = 0;
        v18 = 0;
        v19 = 0;
        *(_BYTE *)(a1 + 20) |= 1u;
        while (1)
        {
          v20 = *v3;
          v21 = *(_QWORD *)(a2 + v20);
          if (v21 == -1 || v21 >= *(_QWORD *)(a2 + *v4))
            break;
          v22 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v21);
          *(_QWORD *)(a2 + v20) = v21 + 1;
          v19 |= (unint64_t)(v22 & 0x7F) << v17;
          if ((v22 & 0x80) == 0)
            goto LABEL_33;
          v17 += 7;
          v14 = v18++ >= 9;
          if (v14)
          {
            LODWORD(v19) = 0;
            goto LABEL_35;
          }
        }
        *(_BYTE *)(a2 + *v5) = 1;
LABEL_33:
        if (*(_BYTE *)(a2 + *v5))
          LODWORD(v19) = 0;
LABEL_35:
        *(_DWORD *)(a1 + 16) = v19;
      }
      else
      {
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
      }
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void _VCMediaRecorderLocal_PushAudioSamples(uint64_t a1, uint64_t a2)
{
  double HostTime;

  HostTime = VCAudioBufferList_GetHostTime(a2);
  VCMediaRecorder_AddLocalAudioSampleBuffer(a1, a2, (HostTime * 1000.0));
}

void _VCSessionParticipantLocal_ProcessAudioSamples(uint64_t a1, unsigned int *a2)
{
  char Priority;
  int VoiceActivity;
  int v6;
  double v7;
  int v8;
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  uint64_t v12;
  double HostTime;
  uint64_t BoolValueForKeyQuiet;
  _BYTE v15[24];
  void *v16;
  uint64_t v17;
  char v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (*(_BYTE *)(a1 + 408))
    {
      if (*(_BYTE *)(a1 + 560) && *(_BYTE *)(a1 + 984))
      {
        Priority = 0;
        VoiceActivity = 0;
LABEL_27:
        if (*(_BYTE *)(a1 + 1088))
          VCAudioPowerSpectrumSource_PushAudioSamples(*(id **)(a1 + 912), (uint64_t)a2);
        v12 = *(_QWORD *)(a1 + 520);
        if (v12 && *(_BYTE *)(a1 + 408))
          VCAudioCaptionsCoordinator_PushAudioSamples(v12, *(_QWORD *)(a1 + 1104), a2);
        pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 592));
        VCMediaRecorder_AddLocalAudioSampleBuffer(*(_QWORD *)(a1 + 512), (uint64_t)a2, *(_DWORD *)(a1 + 576));
        *(_DWORD *)(a1 + 576) = VCAudioBufferList_GetTimestamp((uint64_t)a2);
        *(double *)(a1 + 584) = VCAudioBufferList_GetHostTime((uint64_t)a2);
        pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 592));
        if (!*(_BYTE *)(a1 + 408))
        {
          VCAudioBufferList_SetPriority((uint64_t)a2, Priority);
          VCAudioBufferList_SetVoiceActivity((uint64_t)a2, VoiceActivity);
        }
        HostTime = VCAudioBufferList_GetHostTime((uint64_t)a2);
        if (HostTime - *(double *)(a1 + 1032) > 0.5)
        {
          *(double *)(a1 + 1032) = HostTime;
          BoolValueForKeyQuiet = VCDefaults_GetBoolValueForKeyQuiet(CFSTR("spatialAudioDisabled"), 0);
          if ((_DWORD)BoolValueForKeyQuiet != objc_msgSend(*(id *)(a1 + 392), "spatialAudioDisabled"))
            objc_msgSend(*(id *)(a1 + 392), "setSpatialAudioDisabled:", BoolValueForKeyQuiet);
        }
        return;
      }
    }
    else if (*(_BYTE *)(a1 + 560))
    {
      Priority = VCAudioBufferList_GetPriority((uint64_t)a2);
      VoiceActivity = VCAudioBufferList_GetVoiceActivity((uint64_t)a2);
      v6 = VCAudioBufferList_GetPriority((uint64_t)a2);
      if (!*(_BYTE *)(a1 + 856))
        goto LABEL_19;
      v7 = micro();
      if (v7 - *(double *)(a1 + 848) > 1.0)
      {
        *(_BYTE *)(a1 + 840) = -[VCDefaults forceAudioPriorityValue](+[VCDefaults sharedInstance](VCDefaults, "sharedInstance"), "forceAudioPriorityValue");
        *(double *)(a1 + 848) = v7;
      }
      v8 = *(unsigned __int8 *)(a1 + 840);
      if (*(_BYTE *)(a1 + 840))
      {
        VCAudioBufferList_SetPriority((uint64_t)a2, *(_BYTE *)(a1 + 840));
        v6 = v8;
      }
      else
      {
LABEL_19:
        if (!v6)
        {
          if (*(_BYTE *)(a1 + 1072))
            v6 = VCVoiceDetector_ProcessSampleBuffer(*(_QWORD **)(a1 + 880), (uint64_t)a2, *(_BYTE *)(a1 + 372));
          else
            v6 = 0;
        }
      }
      if (v6 != *(unsigned __int8 *)(a1 + 792))
      {
        *(_BYTE *)(a1 + 792) = v6;
        *(_QWORD *)v15 = MEMORY[0x1E0C809B0];
        *(_QWORD *)&v15[8] = 3221225472;
        *(_QWORD *)&v15[16] = __VCSessionParticipantLocal_UpdateAudioPriorityWithSampleBuffer_block_invoke;
        v16 = &unk_1E9E55118;
        v17 = a1;
        v18 = v6;
        objc_msgSend((id)a1, "callDelegateWithBlock:", v15);
      }
      goto LABEL_27;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v9 = VRTraceErrorLogLevelToCSTR();
      v10 = *MEMORY[0x1E0CF2758];
      v11 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v15 = 136315650;
          *(_QWORD *)&v15[4] = v9;
          *(_WORD *)&v15[12] = 2080;
          *(_QWORD *)&v15[14] = "_VCSessionParticipantLocal_ProcessAudioSamples";
          *(_WORD *)&v15[22] = 1024;
          LODWORD(v16) = 3979;
          _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d audio no-op no MKM", v15, 0x1Cu);
        }
      }
      else if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        _VCSessionParticipantLocal_ProcessAudioSamples_cold_2();
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCSessionParticipantLocal_ProcessAudioSamples_cold_1();
  }
}

uint64_t VCSessionPartipantLocal_OnVideoFrame(uint64_t a1, opaqueCMSampleBuffer *a2, uint64_t a3, uint64_t a4)
{
  int v7;
  int v8;
  const __CFString *v9;
  uint64_t v10;
  NSObject *v11;
  NSObject *v12;
  const char *v13;
  NSObject *v14;
  uint32_t v15;
  uint64_t v16;
  NSObject *v17;
  NSObject *v18;
  int v20;
  uint64_t v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  const __CFString *v27;
  __int16 v28;
  uint64_t v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v7 = *(unsigned __int8 *)(a1 + 560);
  if (*(_BYTE *)(a1 + 408))
  {
    if (!*(_BYTE *)(a1 + 560))
      goto LABEL_6;
    v7 = *(unsigned __int8 *)(a1 + 984);
  }
  if (v7)
  {
    pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 592));
    v8 = *(_DWORD *)(a1 + 576);
    pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 592));
    VCMediaRecorder_AddLocalVideoSampleBuffer(*(_QWORD *)(a1 + 512), a2, *(_BYTE *)(a4 + 16), v8);
    return 1;
  }
LABEL_6:
  if (objc_opt_class() == a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 8)
      return 1;
    v10 = VRTraceErrorLogLevelToCSTR();
    v11 = *MEMORY[0x1E0CF2758];
    v12 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        return 1;
      v20 = 136315650;
      v21 = v10;
      v22 = 2080;
      v23 = "VCSessionPartipantLocal_OnVideoFrame";
      v24 = 1024;
      v25 = 3840;
      v13 = " [%s] %s:%d video no-op no MKM";
      v14 = v11;
      v15 = 28;
LABEL_18:
      _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, v13, (uint8_t *)&v20, v15);
      return 1;
    }
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      VCSessionPartipantLocal_OnVideoFrame_cold_1();
  }
  else
  {
    if ((objc_opt_respondsToSelector() & 1) != 0)
      v9 = (const __CFString *)objc_msgSend((id)a1, "performSelector:", sel_logPrefix);
    else
      v9 = &stru_1E9E58EE0;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v16 = VRTraceErrorLogLevelToCSTR();
      v17 = *MEMORY[0x1E0CF2758];
      v18 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
          return 1;
        v20 = 136316162;
        v21 = v16;
        v22 = 2080;
        v23 = "VCSessionPartipantLocal_OnVideoFrame";
        v24 = 1024;
        v25 = 3840;
        v26 = 2112;
        v27 = v9;
        v28 = 2048;
        v29 = a1;
        v13 = " [%s] %s:%d %@(%p) video no-op no MKM";
        v14 = v17;
        v15 = 48;
        goto LABEL_18;
      }
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        v20 = 136316162;
        v21 = v16;
        v22 = 2080;
        v23 = "VCSessionPartipantLocal_OnVideoFrame";
        v24 = 1024;
        v25 = 3840;
        v26 = 2112;
        v27 = v9;
        v28 = 2048;
        v29 = a1;
        _os_log_debug_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEBUG, " [%s] %s:%d %@(%p) video no-op no MKM", (uint8_t *)&v20, 0x30u);
      }
    }
  }
  return 1;
}

uint64_t OUTLINED_FUNCTION_18_1@<X0>(void *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  *(_QWORD *)(v2 - 24) = a2;
  return objc_msgSend(a1, "streamGroupID");
}

uint64_t OUTLINED_FUNCTION_25_1@<X0>(void *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  *(_QWORD *)(v2 - 24) = a2;
  return objc_msgSend(a1, "count");
}

uint64_t VCPerfTimingUtilsSetStartForKeyOnceWithTime(void *a1, uint64_t a2, double a3)
{
  uint64_t result;

  result = objc_msgSend(a1, "hasKey:", a2);
  if ((result & 1) == 0)
    return objc_msgSend(a1, "setStartTime:forKey:", a2, a3);
  return result;
}

uint64_t VCPerfTimingUtilsSetStopForKeyOnceWithTime(void *a1, uint64_t a2, double a3)
{
  uint64_t result;

  if ((objc_msgSend(a1, "hasKey:", a2) & 1) == 0)
    objc_msgSend(a1, "setStartTime:forKey:", a2, a3);
  result = objc_msgSend(a1, "isValidTimingForKey:", a2);
  if ((result & 1) == 0)
    return objc_msgSend(a1, "setStopTime:forKey:", a2, a3);
  return result;
}

void VCPerfTimingUtilsLog(void *a1, __n128 a2)
{
  uint64_t v3;
  os_log_t *v4;
  uint64_t v5;
  NSObject *v6;
  double v7;
  __n128 v8;
  uint8_t buf[4];
  uint64_t v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  uint64_t v19;

  v3 = 0;
  v19 = *MEMORY[0x1E0C80C00];
  v4 = (os_log_t *)MEMORY[0x1E0CF2758];
  a2.n128_u64[0] = 136316162;
  v8 = a2;
  do
  {
    if (objc_msgSend(a1, "hasKey:", v3, *(_OWORD *)&v8)
      && objc_msgSend(a1, "isValidTimingForKey:", v3)
      && (int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v6 = *v4;
      if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
      {
        objc_msgSend(a1, "timingForKey:", v3);
        *(_DWORD *)buf = v8.n128_u32[0];
        v10 = v5;
        v11 = 2080;
        v12 = "VCPerfTimingUtilsLog";
        v13 = 1024;
        v14 = 43;
        v15 = 1024;
        v16 = v3;
        v17 = 1024;
        v18 = (int)(v7 * 1000.0);
        _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d sendTimings:Key = %d, value = %d", buf, 0x28u);
      }
    }
    v3 = (v3 + 1);
  }
  while ((_DWORD)v3 != 23);
}

void VCPerfTimingUtilsReport(void *a1, uint64_t a2, __n128 a3)
{
  VCPerfTimingUtilsLog(a1, a3);
  if (a2)
    reportingPerfTimes();
}

BOOL VCSilencePredictor_Initialize(uint64_t a1)
{
  if (a1)
  {
    *(_DWORD *)(a1 + 96) = -1;
    *(_DWORD *)(a1 + 24) = -1;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCSilencePredictor_Initialize_cold_1();
  }
  return a1 != 0;
}

void VCSilencePredictor_Reset(uint64_t a1)
{
  if (a1)
  {
    *(_OWORD *)(a1 + 88) = 0u;
    *(_QWORD *)(a1 + 152) = 0;
    *(_OWORD *)(a1 + 136) = 0u;
    *(_OWORD *)(a1 + 120) = 0u;
    *(_OWORD *)(a1 + 104) = 0u;
    *(_DWORD *)(a1 + 96) = -1;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_QWORD *)(a1 + 80) = 0;
    *(_DWORD *)(a1 + 24) = -1;
    *(_BYTE *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCSilencePredictor_Reset_cold_1();
  }
}

void VCSilencePredictor_AddFrame(unsigned __int8 *a1, int a2, unsigned int a3, int a4)
{
  unsigned __int8 *v5;
  uint64_t v6;
  double v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  double v11;
  unsigned int v12;
  double v13;
  unsigned int v14;
  double v15;
  double v16;
  unint64_t v17;
  unsigned int v18;
  double v19;
  unint64_t v20;
  double v21;
  double v22;
  double v23;
  double v24;
  _BOOL4 v25;
  int v26;
  uint64_t v27;
  NSObject *v28;
  int v29;
  uint64_t v30;
  const char *v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  __int16 v38;
  const char *v39;
  __int16 v40;
  int v41;
  __int16 v42;
  const char *v43;
  __int16 v44;
  _BOOL4 v45;
  __int16 v46;
  _BOOL4 v47;
  __int16 v48;
  int v49;
  __int16 v50;
  uint64_t v51;
  __int16 v52;
  uint64_t v53;
  __int16 v54;
  int v55;
  __int16 v56;
  uint64_t v57;
  __int16 v58;
  uint64_t v59;
  uint64_t v60;

  v60 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a2 != 104 || !a3)
      goto LABEL_27;
    v5 = a1 + 16;
    v6 = 88;
    if (a4)
      v6 = 16;
    else
      v5 = a1 + 88;
    v7 = 1.85;
    if (a4)
      v7 = 1.15;
    v8 = *((_DWORD *)v5 + 2);
    v9 = *((_DWORD *)v5 + 3);
    if (v8 >= a3)
      v10 = a3;
    else
      v10 = *((_DWORD *)v5 + 2);
    v11 = (double)v10;
    if (v9 <= a3)
      v12 = a3;
    else
      v12 = *((_DWORD *)v5 + 3);
    v13 = *(double *)&a1[v6];
    if (!v8)
      v11 = (double)a3;
    v14 = v11;
    v15 = v9 ? (double)v12 : (double)a3;
    *((_DWORD *)v5 + 2) = v14;
    *((_DWORD *)v5 + 3) = v15;
    v16 = v13 == 0.0 ? (double)a3 : v13 * 0.98 + (double)a3 * 0.02;
    *(double *)&a1[v6] = v16;
    v17 = *((_QWORD *)v5 + 2) + a3;
    *((_QWORD *)v5 + 2) = v17;
    v18 = *((_DWORD *)v5 + 16) + 1;
    *((_DWORD *)v5 + 16) = v18;
    v19 = (double)v17 / (double)v18;
    v20 = *((_QWORD *)v5 + 7) + (unint64_t)(((double)a3 - v19) * ((double)a3 - v19));
    *((_QWORD *)v5 + 7) = v20;
    v21 = sqrt((double)v20 / (double)v18);
    *((double *)v5 + 3) = v19;
    *((double *)v5 + 4) = v21;
    *((double *)v5 + 5) = v19 - v7 * v21;
    *((double *)v5 + 6) = v19 + v7 * v21;
    if (*((_DWORD *)a1 + 38) < 0x32u)
      goto LABEL_27;
    if (*((_DWORD *)a1 + 20) > 0x31u)
    {
      v22 = *((double *)a1 + 11);
      v23 = *((double *)a1 + 2);
      v24 = v23 * 1.15;
      v25 = v23 <= *((double *)a1 + 16) && v22 >= *((double *)a1 + 8);
      v26 = v22 >= v24 && v25;
      if (*a1 != v26 && (int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v27 = VRTraceErrorLogLevelToCSTR();
        v28 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v29 = *((_DWORD *)a1 + 38);
          v30 = *((_QWORD *)a1 + 11);
          v31 = "OFF";
          v32 = *((_QWORD *)a1 + 16);
          v33 = *((_DWORD *)a1 + 20);
          if (v26)
            v31 = "ON";
          v34 = *((_QWORD *)a1 + 2);
          v35 = *((_QWORD *)a1 + 8);
          v36 = 136317954;
          v37 = v27;
          v38 = 2080;
          v39 = "VCSilencePredictor_AddFrame";
          v40 = 1024;
          v41 = 102;
          v42 = 2080;
          v43 = v31;
          v44 = 1024;
          v45 = v22 >= v24;
          v46 = 1024;
          v47 = v25;
          v48 = 1024;
          v49 = v29;
          v50 = 2048;
          v51 = v30;
          v52 = 2048;
          v53 = v32;
          v54 = 1024;
          v55 = v33;
          v56 = 2048;
          v57 = v34;
          v58 = 2048;
          v59 = v35;
          _os_log_impl(&dword_1D8A54000, v28, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Silence prediction=%s. sufficientDeltaBetweenAverages=%d, distributionsAreNotOverlapped=%d, audioFrameCount=%u audioAvgFrameSize=%f audioMinFrameSizeLimit=%f, silenceFrameCount=%u silenceAvgFrameSize=%f silenceMaxFrameSizeLimit=%f,", (uint8_t *)&v36, 0x66u);
        }
      }
      *a1 = v26;
    }
    else
    {
LABEL_27:
      *a1 = 0;
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCSilencePredictor_AddFrame_cold_1();
  }
}

BOOL VCSilencePredictor_PredictSilence(uint64_t a1, int a2, unsigned int a3)
{
  uint64_t v3;
  double v4;
  double v5;

  if (a1)
  {
    v3 = 0;
    if (a2 == 104 && a3 && *(_BYTE *)a1)
    {
      v4 = *(double *)(a1 + 8);
      if (v4 == 0.0)
        v5 = (double)a3;
      else
        v5 = (double)a3 * 0.3333 + v4 * 0.6667;
      *(double *)(a1 + 8) = v5;
      return v5 <= *(double *)(a1 + 64) && v5 < *(double *)(a1 + 128);
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCSilencePredictor_PredictSilence_cold_1();
    }
    return 0;
  }
  return v3;
}

uint64_t VCPacketFilterRTCPCreate(uint64_t a1, _QWORD *a2)
{
  uint64_t ClassID;

  ClassID = VCPacketFilterGetClassID();
  return VCFBOUtils_ObjectCreate(a1, a2, (uint64_t)&kVCPacketFilterRTCPVTable, ClassID, 52);
}

BOOL VCPacketFilterIsOfKindRTCP(uint64_t a1)
{
  return VCFBOUtils_IsKindOfClass(a1, (uint64_t)&kVCPacketFilterRTCPVTable);
}

void _VCPacketFilterRTCPFinalize(uint64_t a1)
{
  const void **DerivedStorage;
  const void **v2;
  const void *v3;
  const void *v4;

  if (a1)
  {
    DerivedStorage = (const void **)CMBaseObjectGetDerivedStorage();
    if (DerivedStorage)
    {
      v2 = DerivedStorage;
      v3 = *DerivedStorage;
      if (v3)
        CFRelease(v3);
      v4 = v2[1];
      if (v4)
        CFRelease(v4);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCPacketFilterRTCPFinalize_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCPacketFilterRTCPFinalize_cold_1();
  }
}

uint64_t _VCPacketFilterRTCPCopyProperty(uint64_t a1, const void *a2, uint64_t a3, _QWORD *a4)
{
  uint64_t DerivedStorage;
  const void *v7;
  uint64_t v8;
  NSObject *v9;
  const char *v10;
  CFTypeRef v11;
  uint64_t result;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  const void *v23;
  __int16 v24;
  _QWORD *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCPacketFilterRTCPCopyProperty_cold_1();
    }
    return 4294954516;
  }
  if (!a2 || !a4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v13 = VRTraceErrorLogLevelToCSTR();
      v14 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v16 = 136316162;
        v17 = v13;
        v18 = 2080;
        v19 = "_VCPacketFilterRTCPCopyProperty";
        v20 = 1024;
        v21 = 61;
        v22 = 2112;
        v23 = a2;
        v24 = 2112;
        v25 = a4;
        _os_log_error_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_ERROR, " [%s] %s:%d Property name '%@' and property value out '%@' must not be NULL", (uint8_t *)&v16, 0x30u);
      }
    }
    return 4294954516;
  }
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (CFEqual(a2, CFSTR("RTCPRemoteSSRC")))
  {
    v7 = *(const void **)DerivedStorage;
    if (!*(_QWORD *)DerivedStorage)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 6)
        return 4294954513;
      v8 = VRTraceErrorLogLevelToCSTR();
      v9 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        return 4294954513;
      v16 = 136315650;
      v17 = v8;
      v18 = 2080;
      v19 = "_VCPacketFilterRTCPCopyProperty";
      v20 = 1024;
      v21 = 66;
      v10 = " [%s] %s:%d kVCPacketFilterRTCPProperty_RemoteSSRC not set";
LABEL_26:
      _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, v10, (uint8_t *)&v16, 0x1Cu);
      return 4294954513;
    }
    goto LABEL_11;
  }
  if (CFEqual(a2, CFSTR("RTCPLocalSSRC")))
  {
    v7 = *(const void **)(DerivedStorage + 8);
    if (!v7)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 6)
        return 4294954513;
      v15 = VRTraceErrorLogLevelToCSTR();
      v9 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        return 4294954513;
      v16 = 136315650;
      v17 = v15;
      v18 = 2080;
      v19 = "_VCPacketFilterRTCPCopyProperty";
      v20 = 1024;
      v21 = 70;
      v10 = " [%s] %s:%d kVCPacketFilterRTCPProperty_LocalSSRC not set";
      goto LABEL_26;
    }
LABEL_11:
    v11 = CFRetain(v7);
    result = 0;
    *a4 = v11;
    return result;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCPacketFilterRTCPCopyProperty_cold_2();
  }
  return 4294954512;
}

uint64_t _VCPacketFilterRTCPSetProperty(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t DerivedStorage;
  const void *v6;
  uint64_t v8;
  NSObject *v9;
  int v10;
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  const void *v17;
  __int16 v18;
  const void *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCPacketFilterRTCPSetProperty_cold_1();
    }
    return 4294954516;
  }
  if (!a2 || !a3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v8 = VRTraceErrorLogLevelToCSTR();
      v9 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v10 = 136316162;
        v11 = v8;
        v12 = 2080;
        v13 = "_VCPacketFilterRTCPSetProperty";
        v14 = 1024;
        v15 = 85;
        v16 = 2112;
        v17 = a2;
        v18 = 2112;
        v19 = a3;
        _os_log_error_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_ERROR, " [%s] %s:%d Property name '%@' and property value out '%@' must not be NULL", (uint8_t *)&v10, 0x30u);
      }
    }
    return 4294954516;
  }
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (CFEqual(a2, CFSTR("RTCPRemoteSSRC")))
  {
    v6 = *(const void **)DerivedStorage;
    *(_QWORD *)DerivedStorage = a3;
LABEL_8:
    CFRetain(a3);
    if (v6)
      CFRelease(v6);
    return 0;
  }
  if (CFEqual(a2, CFSTR("RTCPLocalSSRC")))
  {
    v6 = *(const void **)(DerivedStorage + 8);
    *(_QWORD *)(DerivedStorage + 8) = a3;
    goto LABEL_8;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCPacketFilterRTCPSetProperty_cold_2();
  }
  return 4294954512;
}

uint64_t VCAudioIO_PushAudioSamples(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  id *v6;
  uint64_t result;
  int SampleCount;
  unsigned int *v9;
  double HostTime;
  int Timestamp;
  int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  void (*v17)(_QWORD, unsigned int *);
  uint64_t v18;

  v6 = (id *)(a1 + 72);
  result = memcmp(&_VCAudioIO_EmptyContext, (const void *)(a1 + 72), 0x38uLL);
  if ((_DWORD)result && (!*(_BYTE *)(a1 + 8) || *(_QWORD *)a1))
  {
    ++*(_DWORD *)(a1 + 68);
    SampleCount = VCAudioBufferList_GetSampleCount(*(_QWORD *)(a1 + 16));
    if (*(_BYTE *)(a1 + 65) || *(_BYTE *)(a1 + 8) || *(_BYTE *)(a1 + 9) || (v9 = (unsigned int *)a3, SampleCount))
      v9 = *(unsigned int **)(a1 + 16);
    HostTime = VCAudioBufferList_GetHostTime(a3);
    Timestamp = VCAudioBufferList_GetTimestamp(a3);
    VCAudioBufferList_GetSampleCount(a3);
    v12 = _VCAudioIO_ComputeTimestampForControllerTime(a1, a2, HostTime);
    VCAudioBufferList_SetTime(a3, v12, HostTime);
    kdebug_trace();
    if (*(_BYTE *)(a1 + 8))
    {
      VCAudioBufferList_ResampleAppend(a3, (uint64_t)v9, v12, *(OpaqueAudioConverter **)(*(_QWORD *)a1 + 88));
    }
    else if (v9 != (unsigned int *)a3)
    {
      VCAudioBufferList_Append((uint64_t)v9, a3, 0);
    }
    if (*(_BYTE *)(a1 + 65))
      VCAudioBufferList_ZeroMemory((uint64_t)v9);
    v13 = VCAudioBufferList_GetSampleCount((uint64_t)v9);
    v14 = *(_DWORD *)(a1 + 12);
    if (v13 >= v14)
    {
      v15 = v13;
      if (v13 > v14)
        VCAudioBufferList_SetSampleCount((uint64_t)v9, v14);
      VCAudioBufferList_GetTimestamp((uint64_t)v9);
      kdebug_trace();
      v16 = *(_QWORD *)(a1 + 120);
      if (v16)
        VCCannedAudioInjector_InjectSamples(v16, (uint64_t)v9, *(unsigned __int8 *)(a1 + 65), 0);
      v17 = *(void (**)(_QWORD, unsigned int *))(a1 + 80);
      if (v17)
        v17(*(_QWORD *)(a1 + 88), v9);
      else
        objc_msgSend(*v6, "pushAudioSamples:", v9);
      v18 = *(_QWORD *)(a1 + 104);
      if (v18)
        VCAudioCaptionsCoordinator_PushAudioSamples(v18, *(_QWORD *)(a1 + 96), v9);
      if (v15 > *(_DWORD *)(a1 + 12))
        VCAudioBufferList_SetSampleCount((uint64_t)v9, v15);
      if (v9 != (unsigned int *)a3)
        VCAudioBufferList_Shift((uint64_t)v9, *(_DWORD *)(a1 + 12));
    }
    return VCAudioBufferList_SetTime(a3, Timestamp, HostTime);
  }
  return result;
}

uint64_t _VCAudioIO_ComputeTimestampForControllerTime(uint64_t a1, unint64_t *a2, double a3)
{
  double *SampleFormat;
  unint64_t v7;
  uint64_t result;

  SampleFormat = (double *)VCAudioBufferList_GetSampleFormat(*(_QWORD *)(a1 + 16));
  v7 = (unint64_t)(*SampleFormat * (double)a2[1]) / *(unsigned int *)a2;
  if (*(_BYTE *)(a1 + 64))
  {
    if (*(_BYTE *)(a1 + 40))
      *(_DWORD *)(a1 + 60) = *(_DWORD *)(a1 + 56) - v7 + (*SampleFormat * (a3 - *(double *)(a1 + 48)));
    *(_BYTE *)(a1 + 64) = 0;
  }
  result = (*(_DWORD *)(a1 + 60) + v7);
  *(double *)(a1 + 48) = a3;
  *(_BYTE *)(a1 + 40) = 1;
  *(_DWORD *)(a1 + 56) = result;
  return result;
}

void VCAudioIO_PullAudioSamples(uint64_t a1, unint64_t *a2, unsigned int *a3)
{
  id *v6;
  double HostTime;
  int Timestamp;
  int v9;
  uint64_t v10;
  double SampleCount;
  double v12;
  uint64_t v13;
  int v14;
  int v15;
  unsigned int *v16;
  uint64_t v17;
  void (*v18)(_QWORD, unsigned int *);
  uint64_t v19;
  uint64_t v20;
  uint64_t SampleFormat;
  int SampleCapacity;
  int v23;
  uint64_t AudioBufferList;
  unsigned int *v25;
  unsigned int *v26;
  uint64_t v27;
  unint64_t v28;
  signed int v29;
  int v30;
  int v31;
  NSObject *v32;
  uint64_t v33;
  void (*v34)(_QWORD, unsigned int *);
  uint64_t v35;
  uint64_t v36;
  int v37;
  unsigned int *v38;
  uint64_t v39;
  unsigned int v40;
  int v41;
  uint8_t buf[4];
  uint64_t v43;
  __int16 v44;
  const char *v45;
  __int16 v46;
  int v47;
  __int16 v48;
  int v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  v6 = (id *)(a1 + 72);
  if (!memcmp(&_VCAudioIO_EmptyContext, (const void *)(a1 + 72), 0x38uLL) || *(_BYTE *)(a1 + 8) && !*(_QWORD *)a1)
  {
    VCAudioBufferList_ZeroMemory((uint64_t)a3);
  }
  else
  {
    ++*(_DWORD *)(a1 + 68);
    HostTime = VCAudioBufferList_GetHostTime((uint64_t)a3);
    Timestamp = VCAudioBufferList_GetTimestamp((uint64_t)a3);
    v9 = _VCAudioIO_ComputeTimestampForControllerTime(a1, a2, HostTime);
    if (*(_BYTE *)(a1 + 8)
      || *(_BYTE *)(a1 + 9)
      || VCAudioBufferList_GetSampleCount(*(_QWORD *)(a1 + 16)))
    {
      v10 = *(_QWORD *)(a1 + 16);
      SampleCount = (double)VCAudioBufferList_GetSampleCount((uint64_t)a3);
      v12 = *(double *)VCAudioBufferList_GetSampleFormat(v10) * SampleCount;
      v40 = (v12 / *(double *)VCAudioBufferList_GetSampleFormat((uint64_t)a3));
      if (VCAudioBufferList_GetSampleCount(v10) < v40)
      {
        v13 = *(_QWORD *)(a1 + 16);
        v14 = VCAudioBufferList_GetSampleCount(v13);
        v15 = v14 + v9;
        v16 = (unsigned int *)v13;
        if (v14)
          v16 = *(unsigned int **)(a1 + 24);
        VCAudioBufferList_SetSampleCount((uint64_t)v16, *(_DWORD *)(a1 + 12));
        VCAudioBufferList_SetTime((uint64_t)v16, v15, HostTime);
        VCAudioBufferList_InvalidateNetworkTimestamp((uint64_t)v16);
        kdebug_trace();
        v17 = *(_QWORD *)(a1 + 120);
        if (v17)
          VCCannedAudioInjector_InjectSamples(v17, (uint64_t)v16, *(unsigned __int8 *)(a1 + 65), 0);
        v18 = *(void (**)(_QWORD, unsigned int *))(a1 + 80);
        if (v18)
          v18(*(_QWORD *)(a1 + 88), v16);
        else
          objc_msgSend(*v6, "pullAudioSamples:", v16);
        v19 = *(_QWORD *)(a1 + 104);
        if (v19)
          VCAudioCaptionsCoordinator_PushAudioSamples(v19, *(_QWORD *)(a1 + 96), v16);
        if (v16 != (unsigned int *)v13)
          VCAudioBufferList_Append(v13, (uint64_t)v16, 0);
      }
      v37 = Timestamp;
      v38 = a3;
      v36 = v10;
      if (*(_BYTE *)(a1 + 8))
      {
        v20 = *(_QWORD *)(a1 + 16);
        SampleFormat = VCAudioBufferList_GetSampleFormat(v20);
        SampleCapacity = VCAudioBufferList_GetSampleCapacity((uint64_t)a3);
        v23 = *(_DWORD *)(VCAudioBufferList_GetSampleFormat((uint64_t)a3) + 16);
        AudioBufferList = VCAudioBufferList_GetAudioBufferList((uint64_t)a3);
        v25 = (unsigned int *)VCAudioBufferList_GetAudioBufferList(v20);
        if (*v25)
        {
          v26 = v25;
          v27 = 0;
          v28 = 0;
          v29 = v23 * SampleCapacity;
          do
          {
            v41 = v29;
            v30 = SoundDec_Decode(*(_QWORD *)a1, *(const void **)&v26[v27 + 4], *(_DWORD *)(SampleFormat + 16) * v40, *(char **)(AudioBufferList + v27 * 4 + 16), v29, &v41, 0);
            if (v30 < 0)
            {
              v31 = v30;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                v39 = VRTraceErrorLogLevelToCSTR();
                v32 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136315906;
                  v43 = v39;
                  v44 = 2080;
                  v45 = "_VCAudioIO_ConvertSourceSamples";
                  v46 = 1024;
                  v47 = 179;
                  v48 = 1024;
                  v49 = v31;
                  _os_log_error_impl(&dword_1D8A54000, v32, OS_LOG_TYPE_ERROR, " [%s] %s:%d Failed to convert buffer. result=%08x", buf, 0x22u);
                }
              }
            }
            *(_DWORD *)(AudioBufferList + v27 * 4 + 12) = v41;
            ++v28;
            v27 += 4;
          }
          while (v28 < *v26);
        }
      }
      else
      {
        VCAudioBufferList_ReplaceSamples((uint64_t)a3, v10, 0);
      }
      VCAudioBufferList_Shift(v36, v40);
      a3 = v38;
      Timestamp = v37;
    }
    else
    {
      VCAudioBufferList_SetTime((uint64_t)a3, v9, HostTime);
      kdebug_trace();
      v33 = *(_QWORD *)(a1 + 120);
      if (v33)
        VCCannedAudioInjector_InjectSamples(v33, (uint64_t)a3, *(unsigned __int8 *)(a1 + 65), 0);
      v34 = *(void (**)(_QWORD, unsigned int *))(a1 + 80);
      if (v34)
        v34(*(_QWORD *)(a1 + 88), a3);
      else
        objc_msgSend(*v6, "pullAudioSamples:", a3);
      v35 = *(_QWORD *)(a1 + 104);
      if (v35)
        VCAudioCaptionsCoordinator_PushAudioSamples(v35, *(_QWORD *)(a1 + 96), a3);
    }
    VCAudioBufferList_SetTime((uint64_t)a3, Timestamp, HostTime);
  }
}

void sub_1D8D9AB14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1D8D9E09C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  _Unwind_Resume(exception_object);
}

void sub_1D8D9EAE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  _Unwind_Resume(exception_object);
}

uint64_t VCRateControlStatisticsProc(uint64_t a1)
{
  _DWORD *v2;
  uint64_t v3;
  void (*v4)(uint64_t, timespec *);
  pthread_mutex_t *v5;
  uint64_t v6;
  _OWORD v8[5];
  __int128 v9;
  __int128 v10;
  _OWORD v11[2];
  __int128 v12;
  __int128 v13;
  _OWORD v14[2];
  timespec v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v12 = unk_1D910DA70;
    v13 = xmmword_1D910DA80;
    memset(v14, 170, 24);
    v9 = unk_1D910DA30;
    v10 = xmmword_1D910DA40;
    memset(v11, 170, sizeof(v11));
    v8[0] = xmmword_1D910D9E0;
    memset(&v8[1], 170, 64);
    if (*(_BYTE *)(a1 + 16))
    {
      v2 = (_DWORD *)(a1 + 60024);
      do
      {
        while (_VCStatisticsCollectorQueue_Dequeue(a1, (uint64_t)v8))
        {
          v3 = *(_QWORD *)(a1 + 60040);
          if (v3)
          {
            v4 = *(void (**)(uint64_t, timespec *))(v3 + 16);
            v25 = v13;
            v26 = v14[0];
            v27 = *(_QWORD *)&v14[1];
            v21 = v10;
            v22 = v11[0];
            v23 = v11[1];
            v24 = v12;
            v17 = v8[2];
            v18 = v8[3];
            v19 = v8[4];
            v20 = v9;
            v15 = (timespec)v8[0];
            v16 = v8[1];
            v4(v3, &v15);
          }
        }
        pthread_mutex_lock((pthread_mutex_t *)(a1 + 60048));
        v5 = (pthread_mutex_t *)(a1 + 60048);
        if (*(_BYTE *)(a1 + 16))
        {
          if (*(_BYTE *)(a1 + 17) || *(_BYTE *)(a1 + 60321))
          {
            v5 = (pthread_mutex_t *)(a1 + 60048);
            if (*v2 == *(_DWORD *)(a1 + 60028))
            {
              pthread_cond_wait((pthread_cond_t *)(a1 + 60160), (pthread_mutex_t *)(a1 + 60048));
              v5 = (pthread_mutex_t *)(a1 + 60048);
            }
          }
          else
          {
            pthread_mutex_unlock((pthread_mutex_t *)(a1 + 60048));
            v6 = 1000000 * *(unsigned int *)(a1 + 60324);
            v15.tv_sec = 0;
            v15.tv_nsec = v6;
            pthread_mutex_lock((pthread_mutex_t *)(a1 + 60208));
            pthread_cond_timedwait_relative_np((pthread_cond_t *)(a1 + 60272), (pthread_mutex_t *)(a1 + 60208), &v15);
            v5 = (pthread_mutex_t *)(a1 + 60208);
          }
        }
        pthread_mutex_unlock(v5);
      }
      while (*(_BYTE *)(a1 + 16));
    }
  }
  return 0;
}

uint64_t VCStatisticsCollectorQueue_AddStatisticsMessage(uint64_t a1, uint64_t a2)
{
  int *v4;
  int v5;
  int v6;
  uint64_t v7;
  int v8;
  unint64_t v9;
  uint64_t v10;
  NSObject *v11;
  int v12;
  int v13;
  uint64_t v14;
  NSObject *v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  int v33;
  uint64_t v34;
  NSObject *v35;
  int v36;
  int v37;
  uint64_t v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  int v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  NSObject *v52;
  uint64_t v54;
  NSObject *v55;
  int v56;
  int v57;
  uint8_t buf[4];
  uint64_t v59;
  __int16 v60;
  const char *v61;
  __int16 v62;
  int v63;
  __int16 v64;
  uint64_t v65;
  __int16 v66;
  _QWORD v67[3];

  v67[2] = *MEMORY[0x1E0C80C00];
  if (!a1 || !a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v51 = VRTraceErrorLogLevelToCSTR();
      v52 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136316162;
        v59 = v51;
        v60 = 2080;
        v61 = "VCStatisticsCollectorQueue_AddStatisticsMessage";
        v62 = 1024;
        v63 = 133;
        v64 = 2048;
        v65 = a1;
        v66 = 2048;
        v67[0] = a2;
        _os_log_error_impl(&dword_1D8A54000, v52, OS_LOG_TYPE_ERROR, "VCRC [%s] %s:%d Invalid parameter. Collector=%p message=%p", buf, 0x30u);
      }
    }
    return 0;
  }
  v4 = (int *)(a1 + 60024);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 60048));
  v5 = *(_DWORD *)(a1 + 60028);
  if (*v4 != (v5 + 1) % *(_DWORD *)(a1 + 60032))
  {
LABEL_33:
    v38 = a1 + 200 * v5;
    *(_OWORD *)(v38 + 24) = *(_OWORD *)a2;
    v39 = *(_OWORD *)(a2 + 16);
    v40 = *(_OWORD *)(a2 + 32);
    v41 = *(_OWORD *)(a2 + 48);
    *(_OWORD *)(v38 + 88) = *(_OWORD *)(a2 + 64);
    *(_OWORD *)(v38 + 72) = v41;
    *(_OWORD *)(v38 + 56) = v40;
    *(_OWORD *)(v38 + 40) = v39;
    v42 = *(_OWORD *)(a2 + 80);
    v43 = *(_OWORD *)(a2 + 96);
    v44 = *(_OWORD *)(a2 + 112);
    *(_OWORD *)(v38 + 152) = *(_OWORD *)(a2 + 128);
    *(_OWORD *)(v38 + 136) = v44;
    *(_OWORD *)(v38 + 120) = v43;
    *(_OWORD *)(v38 + 104) = v42;
    v45 = *(_OWORD *)(a2 + 144);
    v46 = *(_OWORD *)(a2 + 160);
    v47 = *(_OWORD *)(a2 + 176);
    *(_QWORD *)(v38 + 216) = *(_QWORD *)(a2 + 192);
    *(_OWORD *)(v38 + 200) = v47;
    *(_OWORD *)(v38 + 184) = v46;
    *(_OWORD *)(v38 + 168) = v45;
    v48 = *(_DWORD *)(a1 + 60032);
    v49 = (*(_DWORD *)(a1 + 60028) + 1) % v48;
    *(_DWORD *)(a1 + 60028) = v49;
    if (*(_BYTE *)(a1 + 17) || *(_BYTE *)(a1 + 60321))
    {
      pthread_cond_signal((pthread_cond_t *)(a1 + 60160));
    }
    else if (*(_DWORD *)a2 == 9 || *(_DWORD *)(a1 + 60036) < (v48 & ((v49 - *v4) >> 31)) + v49 - *v4)
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 60208));
      pthread_cond_signal((pthread_cond_t *)(a1 + 60272));
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 60208));
    }
    v50 = 1;
    goto LABEL_37;
  }
  v6 = 0;
  v7 = a1 + 24;
  while (1)
  {
    if (*(_BYTE *)(a1 + 17))
    {
      pthread_cond_wait((pthread_cond_t *)(a1 + 60112), (pthread_mutex_t *)(a1 + 60048));
      goto LABEL_32;
    }
    v8 = *(_DWORD *)(a1 + 60328);
    *(_DWORD *)(a1 + 60328) = v8 + 1;
    HIDWORD(v9) = -1030792151 * v8;
    LODWORD(v9) = -1030792151 * v8;
    if ((v9 >> 1) <= 0x51EB851 && (int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v10 = VRTraceErrorLogLevelToCSTR();
      v11 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v12 = *(_DWORD *)(a1 + 60028) - *v4;
        if (v12 < 0)
          v12 += *(_DWORD *)(a1 + 60032);
        v13 = *(_DWORD *)(a1 + 60328);
        *(_DWORD *)buf = 136316418;
        v59 = v10;
        v60 = 2080;
        v61 = "_VCStatisticsCollectorQueue_Enqueue";
        v62 = 1024;
        v63 = 210;
        v64 = 2048;
        v65 = a1;
        v66 = 1024;
        LODWORD(v67[0]) = v12;
        WORD2(v67[0]) = 1024;
        *(_DWORD *)((char *)v67 + 6) = v13;
        _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Message queue [%p] full with queueSize=%d, queueFullCount=%u, statistic message ignored!", buf, 0x32u);
      }
    }
    if (v6)
      break;
    if (*(_DWORD *)(a2 + 4) != 1)
      goto LABEL_51;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v14 = VRTraceErrorLogLevelToCSTR();
      v15 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v16 = *(_DWORD *)(a1 + 60028) - *v4;
        if (v16 < 0)
          v16 += *(_DWORD *)(a1 + 60032);
        v17 = *(_DWORD *)(a1 + 60328);
        *(_DWORD *)buf = 136316418;
        v59 = v14;
        v60 = 2080;
        v61 = "_VCStatisticsCollectorQueue_ShouldFlushOldMessages";
        v62 = 1024;
        v63 = 189;
        v64 = 2048;
        v65 = a1;
        v66 = 1024;
        LODWORD(v67[0]) = v16;
        WORD2(v67[0]) = 1024;
        *(_DWORD *)((char *)v67 + 6) = v17;
        _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Message queue [%p] with queueSize=%d, queueFullCount=%u should be flushed", buf, 0x32u);
      }
    }
    v18 = *v4;
    v19 = *(_DWORD *)(a1 + 60028);
    if (*v4 != v19)
    {
      v20 = *v4;
      do
      {
        v21 = v20;
        if (*(_DWORD *)(v7 + 200 * v20 + 4) == 1)
        {
          v22 = v7 + 200 * v20;
          v23 = v7 + 200 * v18;
          *(_OWORD *)v23 = *(_OWORD *)v22;
          v24 = *(_OWORD *)(v22 + 16);
          v25 = *(_OWORD *)(v22 + 32);
          v26 = *(_OWORD *)(v22 + 64);
          *(_OWORD *)(v23 + 48) = *(_OWORD *)(v22 + 48);
          *(_OWORD *)(v23 + 64) = v26;
          *(_OWORD *)(v23 + 16) = v24;
          *(_OWORD *)(v23 + 32) = v25;
          v27 = *(_OWORD *)(v22 + 80);
          v28 = *(_OWORD *)(v22 + 96);
          v29 = *(_OWORD *)(v22 + 128);
          *(_OWORD *)(v23 + 112) = *(_OWORD *)(v22 + 112);
          *(_OWORD *)(v23 + 128) = v29;
          *(_OWORD *)(v23 + 80) = v27;
          *(_OWORD *)(v23 + 96) = v28;
          v30 = *(_OWORD *)(v22 + 144);
          v31 = *(_OWORD *)(v22 + 160);
          v32 = *(_OWORD *)(v22 + 176);
          *(_QWORD *)(v23 + 192) = *(_QWORD *)(v22 + 192);
          *(_OWORD *)(v23 + 160) = v31;
          *(_OWORD *)(v23 + 176) = v32;
          *(_OWORD *)(v23 + 144) = v30;
          v19 = *(_DWORD *)(a1 + 60028);
          v33 = *(_DWORD *)(a1 + 60032);
          v18 = (v18 + 1) % v33;
        }
        else
        {
          v33 = *(_DWORD *)(a1 + 60032);
        }
        v20 = (v21 + 1) % v33;
      }
      while (v20 != v19);
    }
    *(_DWORD *)(a1 + 60028) = v18;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v34 = VRTraceErrorLogLevelToCSTR();
      v35 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v36 = *(_DWORD *)(a1 + 60028) - *v4;
        if (v36 < 0)
          v36 += *(_DWORD *)(a1 + 60032);
        v37 = *(_DWORD *)(a1 + 60328);
        *(_DWORD *)buf = 136316418;
        v59 = v34;
        v60 = 2080;
        v61 = "_VCStatisticsCollectorQueue_ShouldFlushOldMessages";
        v62 = 1024;
        v63 = 191;
        v64 = 2048;
        v65 = a1;
        v66 = 1024;
        LODWORD(v67[0]) = v36;
        WORD2(v67[0]) = 1024;
        *(_DWORD *)((char *)v67 + 6) = v37;
        _os_log_impl(&dword_1D8A54000, v35, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Message queue [%p] with queueSize=%d, queueFullCount=%u after low priority messages flushed", buf, 0x32u);
      }
    }
    v6 = 1;
LABEL_32:
    v5 = *(_DWORD *)(a1 + 60028);
    if (*v4 != (v5 + 1) % *(_DWORD *)(a1 + 60032))
      goto LABEL_33;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v54 = VRTraceErrorLogLevelToCSTR();
    v55 = *MEMORY[0x1E0CF2758];
    v50 = 0;
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      goto LABEL_37;
    v56 = *(_DWORD *)(a1 + 60028) - *v4;
    if (v56 < 0)
      v56 += *(_DWORD *)(a1 + 60032);
    v57 = *(_DWORD *)(a1 + 60328);
    *(_DWORD *)buf = 136316418;
    v59 = v54;
    v60 = 2080;
    v61 = "_VCStatisticsCollectorQueue_ShouldFlushOldMessages";
    v62 = 1024;
    v63 = 183;
    v64 = 2048;
    v65 = a1;
    v66 = 1024;
    LODWORD(v67[0]) = v56;
    WORD2(v67[0]) = 1024;
    *(_DWORD *)((char *)v67 + 6) = v57;
    _os_log_impl(&dword_1D8A54000, v55, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Message queue [%p] is still full with queueSize=%d, queueFullCount=%u after flushing the low priority messages. High priroity statistic message will be ignored!", buf, 0x32u);
  }
LABEL_51:
  v50 = 0;
LABEL_37:
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 60048));
  return v50;
}

void VCStatisticsCollectorQueue_DrainAndProcessAllStatistics(uint64_t a1)
{
  uint64_t *v2;
  uint64_t v3;
  void (*v4)(uint64_t, _OWORD *);
  _OWORD v5[5];
  __int128 v6;
  __int128 v7;
  _OWORD v8[2];
  __int128 v9;
  __int128 v10;
  _OWORD v11[2];
  _OWORD v12[12];
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = (uint64_t *)(a1 + 60040);
    if (*(_BYTE *)(a1 + 60320))
    {
      v9 = unk_1D910DA70;
      v10 = xmmword_1D910DA80;
      memset(v11, 170, 24);
      v6 = unk_1D910DA30;
      v7 = xmmword_1D910DA40;
      memset(v8, 170, sizeof(v8));
      v5[0] = xmmword_1D910D9E0;
      memset(&v5[1], 170, 64);
      while (_VCStatisticsCollectorQueue_Dequeue(a1, (uint64_t)v5))
      {
        v3 = *v2;
        if (*v2)
        {
          v4 = *(void (**)(uint64_t, _OWORD *))(v3 + 16);
          v12[10] = v10;
          v12[11] = v11[0];
          v13 = *(_QWORD *)&v11[1];
          v12[6] = v7;
          v12[7] = v8[0];
          v12[8] = v8[1];
          v12[9] = v9;
          v12[2] = v5[2];
          v12[3] = v5[3];
          v12[4] = v5[4];
          v12[5] = v6;
          v12[0] = v5[0];
          v12[1] = v5[1];
          v4(v3, v12);
        }
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCStatisticsCollectorQueue_DrainAndProcessAllStatistics_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCStatisticsCollectorQueue_DrainAndProcessAllStatistics_cold_1();
  }
}

BOOL _VCStatisticsCollectorQueue_Dequeue(uint64_t a1, uint64_t a2)
{
  int *v4;
  uint64_t v5;
  NSObject *v6;
  _BOOL8 result;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  int v18;
  uint64_t v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (!a1 || !a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v6 = *MEMORY[0x1E0CF2758];
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      v18 = 136316162;
      v19 = v5;
      v20 = 2080;
      v21 = "_VCStatisticsCollectorQueue_Dequeue";
      v22 = 1024;
      v23 = 250;
      v24 = 2048;
      v25 = a1;
      v26 = 2048;
      v27 = a2;
      _os_log_error_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_ERROR, "VCRC [%s] %s:%d Invalid parameter. queue=%p message=%p", (uint8_t *)&v18, 0x30u);
    }
    return 0;
  }
  v4 = (int *)(a1 + 60024);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 60048));
  if (*v4 == *(_DWORD *)(a1 + 60028))
  {
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 60048));
    return 0;
  }
  v8 = a1 + 200 * *v4;
  *(_OWORD *)a2 = *(_OWORD *)(v8 + 24);
  v9 = *(_OWORD *)(v8 + 40);
  v10 = *(_OWORD *)(v8 + 56);
  v11 = *(_OWORD *)(v8 + 88);
  *(_OWORD *)(a2 + 48) = *(_OWORD *)(v8 + 72);
  *(_OWORD *)(a2 + 64) = v11;
  *(_OWORD *)(a2 + 16) = v9;
  *(_OWORD *)(a2 + 32) = v10;
  v12 = *(_OWORD *)(v8 + 104);
  v13 = *(_OWORD *)(v8 + 120);
  v14 = *(_OWORD *)(v8 + 152);
  *(_OWORD *)(a2 + 112) = *(_OWORD *)(v8 + 136);
  *(_OWORD *)(a2 + 128) = v14;
  *(_OWORD *)(a2 + 80) = v12;
  *(_OWORD *)(a2 + 96) = v13;
  v15 = *(_OWORD *)(v8 + 168);
  v16 = *(_OWORD *)(v8 + 184);
  v17 = *(_OWORD *)(v8 + 200);
  *(_QWORD *)(a2 + 192) = *(_QWORD *)(v8 + 216);
  *(_OWORD *)(a2 + 160) = v16;
  *(_OWORD *)(a2 + 176) = v17;
  *(_OWORD *)(a2 + 144) = v15;
  *v4 = (*v4 + 1) % *(_DWORD *)(a1 + 60032);
  if (*(_BYTE *)(a1 + 17))
    pthread_cond_signal((pthread_cond_t *)(a1 + 60112));
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 60048));
  return 1;
}

void VCStatisticsCollectorQueue_FlushAllStatistics(uint64_t a1)
{
  _QWORD v2[26];

  v2[25] = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    *(_OWORD *)&v2[18] = unk_1D910DA70;
    *(_OWORD *)&v2[20] = xmmword_1D910DA80;
    memset(&v2[22], 170, 24);
    *(_OWORD *)&v2[10] = unk_1D910DA30;
    *(_OWORD *)&v2[12] = xmmword_1D910DA40;
    memset(&v2[14], 170, 32);
    *(_OWORD *)v2 = xmmword_1D910D9E0;
    memset(&v2[2], 170, 64);
    while (_VCStatisticsCollectorQueue_Dequeue(a1, (uint64_t)v2))
      ;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCStatisticsCollectorQueue_FlushAllStatistics_cold_1();
  }
}

uint64_t VCTimescalePSOLA_Accelerate(unsigned __int8 *a1, __int16 *a2)
{
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  int v7;
  __int16 v8;
  __int16 v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  NSObject *v15;
  int v16;
  int v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  float v22;
  __int16 *v23;
  int v24;
  float *v25;
  float *v26;
  uint64_t v28;
  NSObject *v29;
  int v30;
  uint64_t v31;
  __int16 v32;
  const char *v33;
  __int16 v34;
  int v35;
  __int16 v36;
  int v37;
  __int16 v38;
  int v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    v6 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        v7 = a2[33];
        v30 = 136315906;
        v31 = v4;
        v32 = 2080;
        v33 = "VCTimescalePSOLA_Accelerate";
        v34 = 1024;
        v35 = 113;
        v36 = 1024;
        v37 = v7;
        _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Accelerate buffer  inputBufferLength=%d", (uint8_t *)&v30, 0x22u);
      }
    }
    else if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      VCTimescalePSOLA_Accelerate_cold_2(v4, (uint64_t)a2, v5);
    }
  }
  *((_WORD *)a1 + 29) = 0;
  if (a1[92])
  {
    v8 = VCTimescalePSOLA_CalcFsMult(*((unsigned __int16 *)a1 + 1));
    v9 = 80 * v8;
    v10 = (__int16)(80 * v8);
    v11 = VCTimescalePSOLA_CheckforSignalCorrelation((__int16 *)a1, a2, v10, 0);
    if ((v11 & 0x80000000) != 0)
    {
      v19 = v11;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v28 = VRTraceErrorLogLevelToCSTR();
        v29 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCTimescalePSOLA_Accelerate_cold_1(v28, v29);
      }
    }
    else
    {
      VCTimescalePSOLA_SynchronizeChannelCorrelation(a1, (uint64_t)a2, 0, v8);
      if (*((__int16 *)a1 + 19) <= *((__int16 *)a1 + 27) && *((_WORD *)a1 + 11))
      {
        LOWORD(v12) = *((_WORD *)a1 + 3);
        LOWORD(v13) = *((_WORD *)a1 + 2);
        goto LABEL_13;
      }
      v12 = *((__int16 *)a1 + 3);
      v13 = *((__int16 *)a1 + 2);
      if (v12 > v13)
      {
LABEL_13:
        if ((__int16)v12 > (__int16)v13 && (int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          v14 = VRTraceErrorLogLevelToCSTR();
          v15 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v16 = *((__int16 *)a1 + 3);
            v17 = *((__int16 *)a1 + 2);
            v30 = 136316162;
            v31 = v14;
            v32 = 2080;
            v33 = "_VCTimescalePSOLA_CheckQualityAndAccelerate";
            v34 = 1024;
            v35 = 75;
            v36 = 1024;
            v37 = v16;
            v38 = 1024;
            v39 = v17;
            _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d REJECTED accelerate (bestIndex %d > psolaMax %d)", (uint8_t *)&v30, 0x28u);
          }
        }
        a2[34] = a2[33];
        if (*a1)
        {
          v18 = 0;
          do
          {
            memmove(*(void **)&a2[4 * v18 + 16], *(const void **)&a2[4 * v18], 4 * a2[33]);
            ++v18;
          }
          while (v18 < *a1);
        }
        return 61;
      }
      if (*a1)
      {
        v21 = 0;
        v22 = 1.0 / (float)(v12 + 1);
        do
        {
          v23 = &a2[4 * v21];
          v24 = v10 - *((__int16 *)a1 + 3);
          v25 = (float *)(*(_QWORD *)v23 + 4 * v24);
          v26 = (float *)(*(_QWORD *)v23 + 4 * v9);
          memmove(*((void **)v23 + 4), *(const void **)v23, 4 * (__int16)(v10 - *((_WORD *)a1 + 3)));
          VCTimescalePSOLA_MixVoiceUnvoiceFloatPoint((float *)(*((_QWORD *)v23 + 4) + 4 * (__int16)v24), v25, v26, *((__int16 *)a1 + 3), 1.0 - v22, v22);
          memmove((void *)(*((_QWORD *)v23 + 4) + 4 * v9), (const void *)(*(_QWORD *)v23 + 4 * (*((__int16 *)a1 + 3) + v10)), 4 * (__int16)(a2[33] - (*((_WORD *)a1 + 3) + v9)));
          ++v21;
        }
        while (v21 < *a1);
        LOWORD(v12) = *((_WORD *)a1 + 3);
      }
      v19 = 0;
      if ((__int16)v12 >= a2[33])
        LOWORD(v12) = a2[33];
      *((_WORD *)a1 + 3) = v12;
      a2[34] = a2[33] - v12;
      *((_DWORD *)a1 + 19) += *((__int16 *)a1 + 3);
    }
  }
  else
  {
    a2[34] = a2[33];
    if (*a1)
    {
      v20 = 0;
      do
      {
        memmove(*(void **)&a2[4 * v20 + 16], *(const void **)&a2[4 * v20], 4 * a2[33]);
        ++v20;
      }
      while (v20 < *a1);
    }
    return 0;
  }
  return v19;
}

uint64_t VCFramingOverheadCalculationUtils_PerPacketMediaFramingOverheadWithRTPHandle(uint64_t a1, unsigned int *a2, uint64_t *a3)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  NSObject *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;
  NSObject *v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint8_t buf[4];
  uint64_t v27;
  __int16 v28;
  const char *v29;
  __int16 v30;
  int v31;
  __int16 v32;
  uint64_t v33;
  __int16 v34;
  uint64_t v35;
  __int16 v36;
  uint64_t v37;
  __int16 v38;
  uint64_t v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v24 = 0;
  v25 = 0;
  v23 = 0;
  if (!a3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v17 = VRTraceErrorLogLevelToCSTR();
      v18 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCFramingOverheadCalculationUtils_PerPacketMediaFramingOverheadWithRTPHandle_cold_1(v17, v18);
    }
    return 1;
  }
  v6 = RTPGetFramingOverhead(a1, &v25);
  if ((v6 & 0x80000000) != 0)
  {
    v13 = v6;
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      return v13;
    v19 = VRTraceErrorLogLevelToCSTR();
    v20 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      return v13;
    *(_DWORD *)buf = 136316162;
    v27 = v19;
    v28 = 2080;
    v29 = "VCFramingOverheadCalculationUtils_PerPacketMediaFramingOverheadWithRTPHandle";
    v30 = 1024;
    v31 = 25;
    v32 = 2048;
    v33 = a1;
    v34 = 1024;
    LODWORD(v35) = v13;
    v21 = " [%s] %s:%d Failed to get RTP Framing overhead from rtpHandle=%p result=0x%x";
LABEL_22:
    _os_log_error_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_ERROR, v21, buf, 0x2Cu);
    return v13;
  }
  v7 = v25;
  v8 = SRTPGetFramingOverhead(a1, &v24);
  if ((v8 & 0x80000000) != 0)
  {
    v13 = v8;
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      return v13;
    v22 = VRTraceErrorLogLevelToCSTR();
    v20 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      return v13;
    *(_DWORD *)buf = 136316162;
    v27 = v22;
    v28 = 2080;
    v29 = "VCFramingOverheadCalculationUtils_PerPacketMediaFramingOverheadWithRTPHandle";
    v30 = 1024;
    v31 = 29;
    v32 = 2048;
    v33 = a1;
    v34 = 1024;
    LODWORD(v35) = v13;
    v21 = " [%s] %s:%d Failed to get SRTP Framing overhead from rtpHandle=%p result=0x%x";
    goto LABEL_22;
  }
  v9 = v24 + v7;
  VCMediaControlInfoGeneratorGetSerializedSizeWithConfig(a2, &v23);
  *a3 = v9 + v23;
  if ((int)VRTraceGetErrorLogLevelForModule() < 8)
    return 0;
  v10 = VRTraceErrorLogLevelToCSTR();
  v11 = *MEMORY[0x1E0CF2758];
  v12 = *MEMORY[0x1E0CF2758];
  if (!*MEMORY[0x1E0CF2748])
  {
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      v16 = *a3;
      *(_DWORD *)buf = 136316674;
      v27 = v10;
      v28 = 2080;
      v29 = "VCFramingOverheadCalculationUtils_PerPacketMediaFramingOverheadWithRTPHandle";
      v30 = 1024;
      v31 = 37;
      v32 = 2048;
      v33 = v16;
      v34 = 2048;
      v35 = v25;
      v36 = 2048;
      v37 = v24;
      v38 = 2048;
      v39 = v23;
      _os_log_debug_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEBUG, " [%s] %s:%d framingOverhead=%lu rtpFramingOverhead=%lu srtpFramingOverhead=%lu mediaControlInfoOverhead=%lu", buf, 0x44u);
    }
    return 0;
  }
  v13 = 0;
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    v14 = *a3;
    *(_DWORD *)buf = 136316674;
    v27 = v10;
    v28 = 2080;
    v29 = "VCFramingOverheadCalculationUtils_PerPacketMediaFramingOverheadWithRTPHandle";
    v30 = 1024;
    v31 = 37;
    v32 = 2048;
    v33 = v14;
    v34 = 2048;
    v35 = v25;
    v36 = 2048;
    v37 = v24;
    v38 = 2048;
    v39 = v23;
    _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d framingOverhead=%lu rtpFramingOverhead=%lu srtpFramingOverhead=%lu mediaControlInfoOverhead=%lu", buf, 0x44u);
    return 0;
  }
  return v13;
}

uint64_t VCAudioCaptionsBufferInfo_GetBuffer(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 48);
  return result;
}

BOOL VCAudioCaptionsBufferInfo_UseSecondaryThread(_BOOL8 result)
{
  if (result)
    return *(_BYTE *)(result + 64) != 0;
  return result;
}

void sub_1D8DA18F0(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 88), 8);
  _Unwind_Resume(a1);
}

uint64_t VCAudioCaptionsBufferInfoCollection_GetBufferInfo(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  uint64_t v3;
  _QWORD v5[7];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  void (*v9)(uint64_t, uint64_t);
  void (*v10)(uint64_t);
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v6 = 0;
  v7 = &v6;
  v8 = 0x3052000000;
  v9 = __Block_byref_object_copy__19;
  v10 = __Block_byref_object_dispose__19;
  v11 = 0;
  v2 = *(NSObject **)(a1 + 24);
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = __VCAudioCaptionsBufferInfoCollection_GetBufferInfo_block_invoke;
  v5[3] = &unk_1E9E55810;
  v5[5] = &v6;
  v5[6] = a2;
  v5[4] = a1;
  dispatch_sync(v2, v5);
  v3 = v7[5];
  _Block_object_dispose(&v6, 8);
  return v3;
}

BOOL VCAudioCaptionsBufferInfoCollection_AddBufferInfo(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  VCAudioCaptionsBufferInfo *v6;
  VCAudioCaptionsBufferInfo *v7;
  NSObject *v8;
  _BOOL8 v9;
  uint64_t v10;
  NSObject *v11;
  _QWORD v13[7];
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  char v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v6 = -[VCAudioCaptionsBufferInfo initWithStreamConfig:bufferLength:]([VCAudioCaptionsBufferInfo alloc], "initWithStreamConfig:bufferLength:", a2, *(double *)(a1 + 16));
  if (v6)
  {
    v7 = v6;
    v14 = 0;
    v15 = &v14;
    v16 = 0x2020000000;
    v17 = 0;
    v8 = *(NSObject **)(a1 + 24);
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __VCAudioCaptionsBufferInfoCollection_AddBufferInfo_block_invoke;
    v13[3] = &unk_1E9E527A8;
    v13[5] = v7;
    v13[6] = &v14;
    v13[4] = a1;
    dispatch_sync(v8, v13);
    if (a3 && *((_BYTE *)v15 + 24))
      *a3 = v7;

    v9 = *((_BYTE *)v15 + 24) != 0;
    _Block_object_dispose(&v14, 8);
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v10 = VRTraceErrorLogLevelToCSTR();
      v11 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioCaptionsBufferInfoCollection_AddBufferInfo_cold_1(v10, a2, v11);
    }
    return 0;
  }
  return v9;
}

void sub_1D8DA1D50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
  _Unwind_Resume(exception_object);
}

uint64_t VCAudioCaptionsBufferInfoCollection_CopyOrderedBufferInfos(uint64_t a1)
{
  NSObject *v1;
  uint64_t v2;
  _QWORD block[6];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  void (*v8)(uint64_t, uint64_t);
  void (*v9)(uint64_t);
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v5 = 0;
  v6 = &v5;
  v7 = 0x3052000000;
  v8 = __Block_byref_object_copy__19;
  v9 = __Block_byref_object_dispose__19;
  v10 = 0;
  v1 = *(NSObject **)(a1 + 24);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = __VCAudioCaptionsBufferInfoCollection_CopyOrderedBufferInfos_block_invoke;
  block[3] = &unk_1E9E52938;
  block[4] = a1;
  block[5] = &v5;
  dispatch_sync(v1, block);
  v2 = v6[5];
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t VCAudioCaptionsBufferInfoCollection_PushAudioSamples(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int SampleCount;
  uint64_t v6;
  int v7;
  int SampleCapacity;
  char Priority;
  uint64_t result;
  int v11;
  int v12;

  SampleCount = VCAudioBufferList_GetSampleCount(a3);
  v6 = *(_QWORD *)(a2 + 48);
  v7 = VCAudioBufferList_GetSampleCount(v6);
  SampleCapacity = VCAudioBufferList_GetSampleCapacity(v6);
  if (SampleCount > SampleCapacity - v7)
    VCAudioBufferList_Shift(v6, SampleCount - (SampleCapacity - v7));
  VCAudioBufferList_Append(v6, a3, 0);
  Priority = VCAudioBufferList_GetPriority(a3);
  result = VCAudioBufferList_GetSampleCount(a3);
  *(_BYTE *)(a2 + 56) = Priority;
  if (Priority < 0)
  {
    v12 = 0;
  }
  else
  {
    v11 = result;
    result = objc_msgSend((id)a2, "countOfLowPrioritySamples");
    v12 = result + v11;
  }
  *(_DWORD *)(a2 + 60) = v12;
  return result;
}

uint64_t VCPixelTransferSession_TransferPixelBuffer(uint64_t a1, CVPixelBufferRef pixelBuffer, __CVBuffer *a3)
{
  size_t Width;
  size_t Height;
  int v8;
  uint64_t v9;
  uint64_t v11;
  NSObject *v12;
  int v13;
  uint64_t v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (!pixelBuffer)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCPixelTransferSession_TransferPixelBuffer_cold_1();
    }
    return 1;
  }
  if (!a3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCPixelTransferSession_TransferPixelBuffer_cold_2();
    }
    return 1;
  }
  Width = CVPixelBufferGetWidth(pixelBuffer);
  Height = CVPixelBufferGetHeight(pixelBuffer);
  v8 = Height;
  if (!Width || !Height)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v11 = VRTraceErrorLogLevelToCSTR();
      v12 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v13 = 136316162;
        v14 = v11;
        v15 = 2080;
        v16 = "VCPixelTransferSession_TransferPixelBuffer";
        v17 = 1024;
        v18 = 46;
        v19 = 1024;
        v20 = Width;
        v21 = 1024;
        v22 = v8;
        _os_log_error_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_ERROR, " [%s] %s:%d Invalid width (%d) / height (%d)", (uint8_t *)&v13, 0x28u);
      }
    }
    return 1;
  }
  v9 = VTPixelTransferSessionTransferImage(*(VTPixelTransferSessionRef *)(a1 + 8), pixelBuffer, a3);
  if ((_DWORD)v9)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCPixelTransferSession_TransferPixelBuffer_cold_3();
    }
  }
  return v9;
}

void _VCCaptionsStream_DidReceiveSampleBuffer(uint64_t a1, opaqueCMSampleBuffer *a2, int a3)
{
  OpaqueCMBlockBuffer *DataBuffer;
  OSStatus DataPointer;
  size_t DataLength;
  void *v8;
  char *v9[2];

  v9[1] = *(char **)MEMORY[0x1E0C80C00];
  if (a1)
  {
    VCVideoStream_DidReceiveSampleBuffer(a1, a2, a3);
    DataBuffer = CMSampleBufferGetDataBuffer(a2);
    v9[0] = 0;
    DataPointer = CMBlockBufferGetDataPointer(DataBuffer, 0, 0, 0, v9);
    if (v9[0])
    {
      if (DataPointer)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VCCaptionsStream_DidReceiveSampleBuffer_cold_3();
        }
      }
      else
      {
        DataLength = CMBlockBufferGetDataLength(DataBuffer);
        v8 = (void *)objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v9[0], DataLength);
        if (v8)
        {
          VCCaptionsReceiver_ProcessCaptionsData(*(_QWORD *)(a1 + 1176), v8);
          return;
        }
      }
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCCaptionsStream_DidReceiveSampleBuffer_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCCaptionsStream_DidReceiveSampleBuffer_cold_1();
  }
}

uint64_t VCAudioEventQueue_Dequeue(int *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;

  v2 = 0;
  if (a1 && a2)
  {
    if (*a1 == a1[1])
    {
      return 0;
    }
    else
    {
      *(_DWORD *)a2 = a1[4 * *a1 + 2];
      *(_QWORD *)(a2 + 8) = *(_QWORD *)&a1[4 * *a1 + 4];
      a1[4 * *a1 + 2] = 0;
      *(_QWORD *)&a1[4 * *a1 + 4] = 0;
      v3 = *a1 + 1;
      __dmb(0xBu);
      *a1 = v3 % 100;
      return 1;
    }
  }
  return v2;
}

char *AVCStreamInputID_ConvertToCString(uint64_t a1, char *__str, size_t __size)
{
  uint64_t v5;
  char *v6;

  if (a1 > 1717854579)
  {
    if ((unint64_t)(a1 - 1986618417) < 4 || a1 == 1718909044)
      goto LABEL_8;
    v5 = 1717854580;
  }
  else
  {
    if ((unint64_t)(a1 - 1684108337) < 5)
      goto LABEL_8;
    v5 = 1650745716;
  }
  if (a1 != v5)
  {
    snprintf(__str, __size, "%ld", a1);
    return __str;
  }
LABEL_8:
  if (__size >= 6)
  {
    v6 = FourccToCStr(a1);
    strncpy(__str, v6, __size);
  }
  return __str;
}

uint64_t AVCStreamInputID_ConvertToNSString(uint64_t a1)
{
  void *v1;
  _QWORD v3[4];

  v3[3] = *MEMORY[0x1E0C80C00];
  memset(v3, 170, 20);
  v1 = (void *)MEMORY[0x1E0CB3940];
  AVCStreamInputID_ConvertToCString(a1, (char *)v3, 0x14uLL);
  return objc_msgSend(v1, "stringWithUTF8String:", v3);
}

void sub_1D8DA3374(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void _AVCStreamInput_ComputeStats(uint64_t a1, opaqueCMSampleBuffer *a2, int a3, __int128 *a4, uint64_t a5)
{
  uint64_t v8;
  OpaqueCMBlockBuffer *DataBuffer;
  float v11;
  float v12;
  __int128 v13;
  uint64_t v14;
  NSObject *v15;
  Float64 Seconds;
  CMTime v17;
  CMTime time2;
  CMTime time1;
  int v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  Float64 v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  ++*(_DWORD *)a5;
  if (a3 != 1835365473)
    return;
  if ((*((_BYTE *)a4 + 12) & 1) == 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _AVCStreamInput_ComputeStats_cold_1();
    }
    return;
  }
  v8 = a5 + 4;
  if ((*(_BYTE *)(a5 + 16) & 1) == 0)
  {
LABEL_9:
    v13 = *a4;
    *(_QWORD *)(v8 + 16) = *((_QWORD *)a4 + 2);
    *(_OWORD *)v8 = v13;
    return;
  }
  *(_OWORD *)&time1.value = *(_OWORD *)v8;
  time1.epoch = *(_QWORD *)(a5 + 20);
  time2 = *(CMTime *)a4;
  if (CMTimeCompare(&time1, &time2))
  {
    DataBuffer = CMSampleBufferGetDataBuffer(a2);
    memset(&time1, 170, sizeof(time1));
    time2 = *(CMTime *)a4;
    v17 = *(CMTime *)v8;
    CMTimeSubtract(&time1, &time2, &v17);
    v11 = (double)time1.value / (double)time1.timescale;
    v12 = (double)CMBlockBufferGetDataLength(DataBuffer) * 8.0 / v11;
    VCUtil_ExponentialMovingAverage((float *)(a5 + 28), v12, 10.0);
    goto LABEL_9;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v14 = VRTraceErrorLogLevelToCSTR();
    v15 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      time1 = *(CMTime *)a4;
      Seconds = CMTimeGetSeconds(&time1);
      LODWORD(time1.value) = 136316418;
      *(CMTimeValue *)((char *)&time1.value + 4) = v14;
      LOWORD(time1.flags) = 2080;
      *(_QWORD *)((char *)&time1.flags + 2) = "_AVCStreamInput_ComputeStats";
      HIWORD(time1.epoch) = 1024;
      v20 = 475;
      v21 = 2048;
      v22 = a1;
      v23 = 2080;
      v24 = a1 + 128;
      v25 = 2048;
      v26 = Seconds;
      _os_log_error_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_ERROR, "AVCStreamInput [%s] %s:%d streamInput=%p AVCStreamInputID=%s Buffer timestamp did not increase. time=%f", (uint8_t *)&time1, 0x3Au);
    }
  }
}

uint64_t OUTLINED_FUNCTION_17@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  *(_QWORD *)(v2 - 24) = a2;
  return AVCStreamInputID_ConvertToNSString(*(_QWORD *)(a1 + 40));
}

AudioComponent VCAudioToolboxAudioComponentMock_FindNext(OpaqueAudioComponent *a1, const AudioComponentDescription *a2)
{
  _QWORD v5[2];

  v5[1] = *MEMORY[0x1E0C80C00];
  v5[0] = 0;
  if (-[VCAudioToolboxAudioComponentMock findNextComponent:description:outComponent:](+[VCAudioToolboxAudioComponentMock sharedInstance](VCAudioToolboxAudioComponentMock, "sharedInstance"), "findNextComponent:description:outComponent:", a1, a2, v5))
  {
    return (AudioComponent)v5[0];
  }
  else
  {
    return AudioComponentFindNext(a1, a2);
  }
}

uint64_t VCAudioToolboxAudioComponentMock_InstanceNew(OpaqueAudioComponent *a1, AudioComponentInstance *a2)
{
  unsigned int v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v5 = 0;
  if (-[VCAudioToolboxAudioComponentMock instanceNew:outInstance:outStatus:](+[VCAudioToolboxAudioComponentMock sharedInstance](VCAudioToolboxAudioComponentMock, "sharedInstance"), "instanceNew:outInstance:outStatus:", a1, a2, &v5))
  {
    return v5;
  }
  else
  {
    return AudioComponentInstanceNew(a1, a2);
  }
}

uint64_t VCAudioToolboxAudioComponentMock_InstanceDispose(OpaqueAudioComponentInstance *a1)
{
  unsigned int v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v3 = 0;
  if (-[VCAudioToolboxAudioComponentMock instanceDispose:outStatus:](+[VCAudioToolboxAudioComponentMock sharedInstance](VCAudioToolboxAudioComponentMock, "sharedInstance"), "instanceDispose:outStatus:", a1, &v3))
  {
    return v3;
  }
  else
  {
    return AudioComponentInstanceDispose(a1);
  }
}

uint64_t VCAudioToolboxAudioComponentMock_GetVersion(OpaqueAudioComponent *a1, UInt32 *a2)
{
  unsigned int v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v5 = 0;
  if (-[VCAudioToolboxAudioComponentMock getVersion:outVersion:outStatus:](+[VCAudioToolboxAudioComponentMock sharedInstance](VCAudioToolboxAudioComponentMock, "sharedInstance"), "getVersion:outVersion:outStatus:", a1, a2, &v5))
  {
    return v5;
  }
  else
  {
    return AudioComponentGetVersion(a1, a2);
  }
}

uint64_t VCAudioToolboxAudioComponentMock_CopyName(OpaqueAudioComponent *a1, CFStringRef *a2)
{
  unsigned int v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v5 = 0;
  if (-[VCAudioToolboxAudioComponentMock copyName:outName:outStatus:](+[VCAudioToolboxAudioComponentMock sharedInstance](VCAudioToolboxAudioComponentMock, "sharedInstance"), "copyName:outName:outStatus:", a1, a2, &v5))
  {
    return v5;
  }
  else
  {
    return AudioComponentCopyName(a1, a2);
  }
}

void VCVideoStreamRateAdaptationFeedbackOnly_SetDidReceiveVideo(uint64_t a1, char a2)
{
  if (a1)
  {
    *(_BYTE *)(a1 + 168) = a2;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCVideoStreamRateAdaptationFeedbackOnly_SetDidReceiveVideo_cold_1();
  }
}

uint64_t VCScreenCaptureManager_SharedInstance()
{
  if (VCScreenCaptureManager_SharedInstance_onceToken != -1)
    dispatch_once(&VCScreenCaptureManager_SharedInstance_onceToken, &__block_literal_global_55);
  if (!VCScreenCaptureManager_SharedInstance__vcScreenCaptureManager && (int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCScreenCaptureManager_SharedInstance_cold_1();
  }
  return VCScreenCaptureManager_SharedInstance__vcScreenCaptureManager;
}

void VCScreenCaptureManager_ScreenShareDidClearScreen(uint64_t a1, char a2)
{
  uint64_t v4;
  NSObject *v5;
  _QWORD v6[6];
  char v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v4 = VCScreenCaptureManager_SharedInstance();
  v5 = *(NSObject **)(v4 + 8);
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = __VCScreenCaptureManager_ScreenShareDidClearScreen_block_invoke;
  v6[3] = &unk_1E9E529D8;
  v6[4] = v4;
  v6[5] = a1;
  v7 = a2;
  dispatch_async(v5, v6);
}

uint64_t OUTLINED_FUNCTION_2_7@<X0>(id *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  *(_QWORD *)(v2 - 24) = a2;
  return objc_msgSend(*a1, "currentAudioPayloadConfig");
}

uint64_t VCVideoParamaterSets_DefaultSupportedSets(int a1)
{
  unsigned int v1;

  if (a1 == 100)
    v1 = 14;
  else
    v1 = 0;
  if (a1 == 123)
    v1 = 1;
  if (a1 == 126)
    return 1;
  else
    return v1;
}

uint64_t VCVideoParameterSets_DefaultSupportedSetsForPayloadAndPixelFormat(int a1, int a2)
{
  int v2;
  int v3;
  unsigned int v4;

  if (a1 == 100)
    v2 = 14;
  else
    v2 = 0;
  if (a1 == 123)
    v2 = 1;
  if (a1 == 126)
    v3 = 1;
  else
    v3 = v2;
  if (a2 == 2016686640)
    v4 = 1;
  else
    v4 = v3;
  if (a2 == 1751411059)
    return 1;
  else
    return v4;
}

void VCStreamInput_UpdateReportingStats(uint64_t a1, CMSampleBufferRef sbuf)
{
  unsigned int *v3;
  unsigned int v4;
  double v5;
  double v6;
  double v7;
  double v8;
  CMTime v9;
  CMTime v10;
  CMTime time;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  memset(&v10, 170, sizeof(v10));
  CMSampleBufferGetPresentationTimeStamp(&v10, sbuf);
  *(CMTime *)(a1 + 220) = v10;
  v3 = (unsigned int *)(a1 + 268);
  do
    v4 = __ldaxr(v3);
  while (__stlxr(v4 + 1, v3));
  v9 = v10;
  v5 = micro();
  time = v9;
  v6 = v5 - CMTimeGetSeconds(&time);
  v7 = v6 - *(double *)(a1 + 280);
  *(double *)(a1 + 280) = v6;
  v8 = -v7;
  if (v7 >= 0.0)
    v8 = v7;
  *(double *)(a1 + 272) = *(double *)(a1 + 272) + (v8 - *(double *)(a1 + 272)) * 0.0625;
  if ((*(_BYTE *)(a1 + 256) & 1) == 0)
    *(CMTime *)(a1 + 244) = v10;
}

__n128 VCAudioHALPluginTimestamp::read@<Q0>(VCAudioHALPluginTimestamp *this@<X0>, __n128 *a2@<X8>)
{
  unint64_t v2;
  __n128 *v3;
  __n128 result;

  v2 = atomic_load(&this->timestampIndex.__a_.__a_value);
  v3 = (__n128 *)&this->timestamps.__begin_[v2];
  result = *v3;
  *a2 = *v3;
  a2[1].n128_u64[0] = v3[1].n128_u64[0];
  return result;
}

__n128 VCAudioHALPluginTimestamp::write(VCAudioHALPluginTimestamp *this, tagVCAudioHALPluginTimestampInfo *a2)
{
  unint64_t v2;
  unint64_t v3;
  __n128 result;
  __n128 *v5;

  v2 = atomic_load(&this->timestampIndex.__a_.__a_value);
  v3 = (v2 + 1) % this->numberOfSlots;
  result = *(__n128 *)&a2->sampleTime;
  v5 = (__n128 *)&this->timestamps.__begin_[v3];
  v5[1].n128_u64[0] = a2->seed;
  *v5 = result;
  atomic_store(v3, &this->timestampIndex.__a_.__a_value);
  return result;
}

double VCAudioHALPluginTimestamp::reset(VCAudioHALPluginTimestamp *this)
{
  tagVCAudioHALPluginTimestampInfo *begin;
  double result;
  __int128 v4;
  tagVCAudioHALPluginTimestampInfo *v5;
  __int128 v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v6 = 0uLL;
  v7 = 0;
  std::vector<tagVCAudioHALPluginTimestampInfo>::vector(&v4, this->numberOfSlots, &v6);
  begin = this->timestamps.__begin_;
  if (begin)
  {
    this->timestamps.__end_ = begin;
    operator delete(begin);
  }
  result = *(double *)&v4;
  *(_OWORD *)&this->timestamps.__begin_ = v4;
  this->timestamps.__end_cap_.__value_ = v5;
  atomic_store(0, &this->timestampIndex.__a_.__a_value);
  return result;
}

_QWORD *std::vector<tagVCAudioHALPluginTimestampInfo>::vector(_QWORD *a1, unint64_t a2, __int128 *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<tagVCAudioHALPluginTimestampInfo>::__vallocate[abi:ne180100](a1, a2);
    v6 = a1[1];
    v7 = v6 + 24 * a2;
    v8 = 24 * a2;
    do
    {
      v9 = *a3;
      *(_QWORD *)(v6 + 16) = *((_QWORD *)a3 + 2);
      *(_OWORD *)v6 = v9;
      v6 += 24;
      v8 -= 24;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_1D8DB643C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<tagVCAudioHALPluginTimestampInfo>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0xAAAAAAAAAAAAAABLL)
    std::vector<tagVCAudioHALPluginTimestampInfo>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<tagVCAudioHALPluginTimestampInfo>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

void std::vector<tagVCAudioHALPluginTimestampInfo>::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("vector");
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<tagVCAudioHALPluginTimestampInfo>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(24 * a2);
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_1E9E4DC40, MEMORY[0x1E0DE42D0]);
}

void sub_1D8DB653C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5020] + 16);
  return result;
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  std::bad_array_new_length *exception;
  std::bad_array_new_length *v1;

  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, MEMORY[0x1E0DE4E98], MEMORY[0x1E0DE4390]);
}

void sub_1D8DBE5FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1D8DBE778(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void _VCAllocatorFirstComeCallback_Release(CFAllocatorRef *a1)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int v3;
  CFAllocatorRef *v4[2];

  v4[1] = *(CFAllocatorRef **)MEMORY[0x1E0C80C00];
  v4[0] = a1;
  v1 = (unsigned int *)(a1 + 1);
  do
  {
    v2 = __ldxr(v1);
    v3 = v2 - 1;
  }
  while (__stxr(v3, v1));
  if (!v3)
  {
    _VCAllocatorFirstCome_FinalizeInfo((uint64_t)a1);
    _VCAllocatorMultiQueue_ReleaseInfo(v4);
  }
}

void *_VCAllocatorFirstComeCallback_Alloc(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int *v5;
  uint64_t v7;
  NSObject *v8;
  void *v9;
  unsigned int *v10;
  int v11;
  int v12;
  uint64_t v13;
  NSObject *v14;
  int v15;
  unsigned int *v16;
  unsigned int v17;
  signed int v18;
  double v19;
  double v20;
  unsigned int v22;
  int v23;
  uint64_t v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  _BYTE v30[14];
  __int16 v31;
  int v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v5 = (unsigned int *)(a3 + 20);
  while (!__ldxr(v5))
  {
    if (!__stxr(a1, v5))
      goto LABEL_6;
  }
  __clrex();
LABEL_6:
  if ((int)*v5 >= a1)
  {
    v9 = OSAtomicDequeue((OSQueueHead *)(a3 + 32), 0);
    if (v9)
      goto LABEL_21;
    v9 = CFAllocatorAllocate(*(CFAllocatorRef *)a3, *(int *)(a3 + 20), 0);
    v10 = (unsigned int *)(a3 + 12);
    do
    {
      v11 = __ldxr(v10);
      v12 = v11 + 1;
    }
    while (__stxr(v11 + 1, v10));
    if (v11 >= 2000)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v13 = VRTraceErrorLogLevelToCSTR();
        v14 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v15 = *(_DWORD *)(a3 + 20);
          v23 = 136316418;
          v24 = v13;
          v25 = 2080;
          v26 = "_VCAllocatorFirstComeCallback_Alloc";
          v27 = 1024;
          v28 = 147;
          v29 = 2080;
          *(_QWORD *)v30 = a3 + 48;
          *(_WORD *)&v30[8] = 1024;
          *(_DWORD *)&v30[10] = v15;
          v31 = 1024;
          v32 = v12;
          _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d High allocation count for %s allocator. New allocation size:%d count:%d", (uint8_t *)&v23, 0x32u);
        }
      }
      if (!*(_BYTE *)(a3 + 128))
      {
        *(_BYTE *)(a3 + 128) = 1;
        VCUtil_GenerateDiagnostics(0, 0, "Terminating due to high allocation count", 1u);
      }
    }
    if (v9)
    {
LABEL_21:
      v16 = (unsigned int *)(a3 + 16);
      do
      {
        v17 = __ldxr(v16);
        v18 = v17 + 1;
      }
      while (__stxr(v18, v16));
      v19 = (double)v18;
      v20 = *(double *)(a3 + 120);
      if (v20 > (double)v18)
        v19 = (double)v18 * 0.0196078431 + v20 * 0.980392157;
      *(double *)(a3 + 120) = v19;
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v7 = VRTraceErrorLogLevelToCSTR();
      v8 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v22 = *v5;
        v23 = 136316162;
        v24 = v7;
        v25 = 2080;
        v26 = "_VCAllocatorFirstComeCallback_Alloc";
        v27 = 1024;
        v28 = 138;
        v29 = 1024;
        *(_DWORD *)v30 = v22;
        *(_WORD *)&v30[4] = 2048;
        *(_QWORD *)&v30[6] = a1;
        _os_log_error_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_ERROR, " [%s] %s:%d First come allocator callback received allocation size request that does not match expectations. bufferSize=%d, size=%zu", (uint8_t *)&v23, 0x2Cu);
      }
    }
    return 0;
  }
  return v9;
}

void *_VCAllocatorFirstComeCallback_Realloc(void *result, int a2, uint64_t a3, uint64_t a4)
{
  if (*(_DWORD *)(a4 + 20) <= a2)
  {
    _VCAllocatorFirstComeCallback_Dealloc(result, a4);
    return 0;
  }
  return result;
}

void _VCAllocatorFirstComeCallback_Dealloc(void *__new, uint64_t a2)
{
  unsigned int *v2;
  unsigned int v3;
  unsigned int *v4;
  double v5;
  unsigned int v6;

  v2 = (unsigned int *)(a2 + 16);
  do
    v3 = __ldxr(v2);
  while (__stxr(v3 - 1, v2));
  if (*(_BYTE *)(a2 + 118)
    && (v4 = (unsigned int *)(a2 + 12), v5 = ceil(*(double *)(a2 + 120)), v5 + v5 < (double)*(int *)(a2 + 12)))
  {
    do
      v6 = __ldxr(v4);
    while (__stxr(v6 - 1, v4));
    CFAllocatorDeallocate(*(CFAllocatorRef *)a2, __new);
  }
  else
  {
    OSAtomicEnqueue((OSQueueHead *)(a2 + 32), __new, 0);
  }
}

void _VCAllocatorFirstCome_FinalizeInfo(uint64_t a1)
{
  OSQueueHead *v2;
  void *v3;
  void *v4;

  if (a1)
  {
    v2 = (OSQueueHead *)(a1 + 32);
    v3 = OSAtomicDequeue((OSQueueHead *)(a1 + 32), 0);
    if (v3)
    {
      v4 = v3;
      do
      {
        CFAllocatorDeallocate(*(CFAllocatorRef *)a1, v4);
        v4 = OSAtomicDequeue(v2, 0);
      }
      while (v4);
    }
    if (*(_QWORD *)a1)
      CFRelease(*(CFTypeRef *)a1);
    *(_QWORD *)a1 = 0;
  }
}

uint64_t _VCTransportSession_DeactivatedNotificationHandler(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend(a2, "handleTransportStreamDeactivated:", a4);
}

void sub_1D8DCAA84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  _Unwind_Resume(exception_object);
}

uint64_t VCRemoteVideoManager_DefaultManager()
{
  if (VCRemoteVideoManager_DefaultManager_onceToken != -1)
    dispatch_once(&VCRemoteVideoManager_DefaultManager_onceToken, &__block_literal_global_59);
  return _vcRemoteVideoManager;
}

void sub_1D8DCD5A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void VCRemoteVideoManager_DidReceiveFirstRemoteFrameForStreamToken(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  _QWORD block[7];

  block[6] = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = *(NSObject **)(a1 + 24);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = __VCRemoteVideoManager_DidReceiveFirstRemoteFrameForStreamToken_block_invoke;
    block[3] = &unk_1E9E52960;
    block[4] = a1;
    block[5] = a2;
    dispatch_async(v2, block);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRemoteVideoManager_DidReceiveFirstRemoteFrameForStreamToken_cold_1();
  }
}

void _VCRemoteVideoManager_DispatchedDidReceiveFirstRemoteFrameForStreamToken(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  CFNumberRef v6;
  NSObject *v7;
  _QWORD v8[5];
  uint64_t valuePtr;
  uint8_t buf[4];
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  valuePtr = a2;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
  {
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      v11 = v4;
      v12 = 2080;
      v13 = "_VCRemoteVideoManager_DispatchedDidReceiveFirstRemoteFrameForStreamToken";
      v14 = 1024;
      v15 = 258;
      v16 = 2048;
      v17 = a2;
      _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d streamToken[%ld]", buf, 0x26u);
    }
  }
  v6 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberNSIntegerType, &valuePtr);
  objc_msgSend((id)objc_msgSend(*(id *)(a1 + 16), "objectForKeyedSubscript:", v6), "setHasReceivedFirstFrame:", 1);
  v7 = *(NSObject **)(a1 + 32);
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = ___VCRemoteVideoManager_DispatchedDidReceiveFirstRemoteFrameForStreamToken_block_invoke;
  v8[3] = &unk_1E9E521C0;
  v8[4] = v6;
  dispatch_async(v7, v8);
  if (v6)
    CFRelease(v6);
}

void VCRemoteVideoManager_RemoteScreenAttributesDidChange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NSObject *v3;
  _QWORD v4[8];

  v4[7] = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v3 = *(NSObject **)(a1 + 24);
    v4[0] = MEMORY[0x1E0C809B0];
    v4[1] = 3221225472;
    v4[2] = __VCRemoteVideoManager_RemoteScreenAttributesDidChange_block_invoke;
    v4[3] = &unk_1E9E53820;
    v4[4] = a1;
    v4[5] = a2;
    v4[6] = a3;
    dispatch_async(v3, v4);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRemoteVideoManager_RemoteScreenAttributesDidChange_cold_1();
  }
}

void _VCRemoteVideoManager_DispatchedRemoteScreenAttributesDidChange(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6;
  NSObject *v7;
  const char *v8;
  CFNumberRef v9;
  void *v10;
  void *v11;
  NSObject *v12;
  _QWORD block[6];
  uint64_t valuePtr;
  uint8_t buf[4];
  uint64_t v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  const char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  valuePtr = a3;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
  {
    v6 = VRTraceErrorLogLevelToCSTR();
    v7 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      if (a2)
        v8 = (const char *)objc_msgSend((id)objc_msgSend(a2, "description"), "UTF8String");
      else
        v8 = "<nil>";
      *(_DWORD *)buf = 136316162;
      v16 = v6;
      v17 = 2080;
      v18 = "_VCRemoteVideoManager_DispatchedRemoteScreenAttributesDidChange";
      v19 = 1024;
      v20 = 287;
      v21 = 2048;
      v22 = a3;
      v23 = 2080;
      v24 = v8;
      _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d streamToken[%ld] screenAttributes[%s]", buf, 0x30u);
    }
  }
  v9 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberNSIntegerType, &valuePtr);
  objc_msgSend((id)objc_msgSend(*(id *)(a1 + 16), "objectForKeyedSubscript:", v9), "setRemoteScreenAttributes:", a2);
  v10 = (void *)objc_msgSend(a2, "copyEncodedDictionary");
  v11 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D80]), "initWithObjectsAndKeys:", v10, CFSTR("conferenceRemoteScreenAttributes"), 0);
  v12 = *(NSObject **)(a1 + 32);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___VCRemoteVideoManager_DispatchedRemoteScreenAttributesDidChange_block_invoke;
  block[3] = &unk_1E9E52238;
  block[4] = v11;
  block[5] = v9;
  dispatch_async(v12, block);

  if (v9)
    CFRelease(v9);
}

void VCRemoteVideoManager_RemoteVideoAttributesDidChange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NSObject *v3;
  _QWORD v4[8];

  v4[7] = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v3 = *(NSObject **)(a1 + 24);
    v4[0] = MEMORY[0x1E0C809B0];
    v4[1] = 3221225472;
    v4[2] = __VCRemoteVideoManager_RemoteVideoAttributesDidChange_block_invoke;
    v4[3] = &unk_1E9E53820;
    v4[4] = a1;
    v4[5] = a2;
    v4[6] = a3;
    dispatch_async(v3, v4);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRemoteVideoManager_RemoteVideoAttributesDidChange_cold_1();
  }
}

void _VCRemoteVideoManager_DispatchedRemoteVideoAttributesDidChange(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6;
  NSObject *v7;
  const char *v8;
  CFNumberRef v9;
  void *QueueForStreamToken;
  void *v11;
  void *v12;
  NSObject *v13;
  _QWORD block[6];
  uint64_t valuePtr;
  uint8_t buf[4];
  uint64_t v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  const char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  valuePtr = a3;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
  {
    v6 = VRTraceErrorLogLevelToCSTR();
    v7 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      if (a2)
        v8 = (const char *)objc_msgSend((id)objc_msgSend(a2, "description"), "UTF8String");
      else
        v8 = "<nil>";
      *(_DWORD *)buf = 136316162;
      v17 = v6;
      v18 = 2080;
      v19 = "_VCRemoteVideoManager_DispatchedRemoteVideoAttributesDidChange";
      v20 = 1024;
      v21 = 321;
      v22 = 2048;
      v23 = a3;
      v24 = 2080;
      v25 = v8;
      _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d streamToken[%ld] videoAttributes[%s]", buf, 0x30u);
    }
  }
  v9 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberNSIntegerType, &valuePtr);
  objc_msgSend((id)objc_msgSend(*(id *)(a1 + 16), "objectForKeyedSubscript:", v9), "setRemoteVideoAttributes:", a2);
  if (objc_msgSend(*(id *)(a1 + 8), "objectForKeyedSubscript:", v9))
  {
    QueueForStreamToken = (void *)_VCRemoteVideoManager_GetQueueForStreamToken(a1, valuePtr, 0);
    VCImageQueue_remoteVideoAttributesChanged(QueueForStreamToken, a2);
  }
  v11 = (void *)objc_msgSend(a2, "copyEncodedDictionary");
  v12 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D80]), "initWithObjectsAndKeys:", v11, CFSTR("conferenceRemoteVideoAttributes"), 0);
  v13 = *(NSObject **)(a1 + 32);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___VCRemoteVideoManager_DispatchedRemoteVideoAttributesDidChange_block_invoke;
  block[3] = &unk_1E9E52238;
  block[4] = v12;
  block[5] = v9;
  dispatch_async(v13, block);

  if (v9)
    CFRelease(v9);
}

uint64_t _VCRemoteVideoManager_GetQueueForStreamToken(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v4;
  uint64_t result;

  v4 = (void *)objc_msgSend(*(id *)(a1 + 8), "objectForKeyedSubscript:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", a2));
  if (!v4)
    return 0;
  result = objc_msgSend(v4, "objectForKeyedSubscript:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", a3));
  if (!result)
    return 0;
  return result;
}

uint64_t OUTLINED_FUNCTION_10_13@<X0>(void *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  *(_QWORD *)(v2 - 24) = a2;
  return objc_msgSend(a1, "unsignedIntValue");
}

void VCCellularAudioTap_ProcessAudioCallback(uint64_t a1, uint64_t a2)
{
  int Timestamp;
  int v5;

  if (a1)
  {
    VCAudioPowerSpectrumSource_ProcessAudioSamples(*(_QWORD *)(a1 + 16), a2);
    Timestamp = VCAudioBufferList_GetTimestamp(a2);
    v5 = *(_DWORD *)(a1 + 8);
    if (v5 == 1)
    {
      VCMediaRecorder_AddRemoteAudioSampleBuffer(*(_QWORD *)(a1 + 24), a2, Timestamp);
    }
    else if (!v5)
    {
      VCMediaRecorder_AddLocalAudioSampleBuffer(*(_QWORD *)(a1 + 24), a2, Timestamp);
    }
    *(float *)(a1 + 32) = VCAudioBufferList_GetAveragePower(a2);
  }
}

void sub_1D8DD5064(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void networkProc(void *a1)
{
  if (a1)
  {
    objc_msgSend(a1, "processNetwork");
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      networkProc_cold_1();
  }
}

void sub_1D8DD5254(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

BOOL VCAudioStructs_StreamDescriptionIsEqual(void *__s1, const void *a2)
{
  _BOOL8 result;

  result = 0;
  if (__s1)
  {
    if (a2)
      return memcmp(__s1, a2, 0x28uLL) == 0;
  }
  return result;
}

void VCAudioStructs_PrintFrameFormat(uint64_t a1, uint64_t *a2)
{
  int ErrorLogLevelForModule;
  os_log_t *v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  char *v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  uint64_t v28;
  __int16 v29;
  char *v30;
  __int16 v31;
  int v32;
  __int16 v33;
  int v34;
  __int16 v35;
  int v36;
  __int16 v37;
  int v38;
  __int16 v39;
  int v40;
  __int16 v41;
  int v42;
  __int16 v43;
  int v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  v5 = (os_log_t *)MEMORY[0x1E0CF2758];
  if (ErrorLogLevelForModule >= 7)
  {
    v6 = VRTraceErrorLogLevelToCSTR();
    v7 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
    {
      v19 = 136315906;
      v20 = v6;
      v21 = 2080;
      v22 = "VCAudioStructs_PrintFrameFormat";
      v23 = 1024;
      v24 = 23;
      v25 = 2080;
      v26 = a1;
      _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d %s mSampleRate : mFormatID : mFormatFlags : mBytesPerPacket : mFramesPerPacket : mBytesPerFrame : mChannelsPerFrame : mBitsPerChannel : samplesPerFrame ", (uint8_t *)&v19, 0x26u);
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v8 = VRTraceErrorLogLevelToCSTR();
    v9 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
    {
      v10 = *a2;
      v11 = FourccToCStr(*((_DWORD *)a2 + 2));
      v12 = *((_DWORD *)a2 + 3);
      v13 = *((_DWORD *)a2 + 4);
      v14 = *((_DWORD *)a2 + 5);
      v15 = *((_DWORD *)a2 + 6);
      v16 = *((_DWORD *)a2 + 7);
      v17 = *((_DWORD *)a2 + 8);
      v18 = *((_DWORD *)a2 + 10);
      v19 = 136318210;
      v20 = v8;
      v21 = 2080;
      v22 = "VCAudioStructs_PrintFrameFormat";
      v23 = 1024;
      v24 = 34;
      v25 = 2080;
      v26 = a1;
      v27 = 2048;
      v28 = v10;
      v29 = 2080;
      v30 = v11;
      v31 = 1024;
      v32 = v12;
      v33 = 1024;
      v34 = v13;
      v35 = 1024;
      v36 = v14;
      v37 = 1024;
      v38 = v15;
      v39 = 1024;
      v40 = v16;
      v41 = 1024;
      v42 = v17;
      v43 = 1024;
      v44 = v18;
      _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d %s %8.0f    : %7s   :  0x%08x  : %8u        : %9u        : %8u       : %9u         : %9u       : %9u       ", (uint8_t *)&v19, 0x64u);
    }
  }
}

uint64_t VCAudioStructs_ClientTimestampForControllerTime(unsigned int *a1, unsigned int a2, double a3)
{
  uint64_t v3;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;

  v3 = *((_QWORD *)a1 + 4);
  if (v3 - a2 < 0x7FFFFFFF && (_DWORD)v3 != a2)
    v3 += 0xFFFFFFFFLL;
  v5 = v3 & 0xFFFFFFFF00000000 | a2;
  *((_QWORD *)a1 + 4) = v5;
  v6 = *a1;
  v7 = v5 * v6 / a1[1];
  if (*((_BYTE *)a1 + 8))
  {
    if (*((_BYTE *)a1 + 9))
      a1[7] = a1[6] - v7 + ((a3 - *((double *)a1 + 2)) * (double)v6);
    *((_BYTE *)a1 + 8) = 0;
  }
  v8 = a1[7] + v7;
  *((double *)a1 + 2) = a3;
  *((_BYTE *)a1 + 9) = 1;
  a1[6] = v8;
  return v8;
}

uint64_t VCCryptor_GetCipherSuite(uint64_t a1)
{
  uint64_t result;

  if (a1)
    return *(unsigned int *)(a1 + 48);
  if ((int)VRTraceGetErrorLogLevelForModule() < 3)
    return 0;
  VRTraceErrorLogLevelToCSTR();
  result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
  if ((_DWORD)result)
  {
    VCCryptor_GetCipherSuite_cold_1();
    return 0;
  }
  return result;
}

uint64_t VCCryptor_ComposeSFrameHeaderWithCounterAndMKI(_BYTE *a1, _QWORD *a2, void *a3, unint64_t a4)
{
  unsigned int v4;
  size_t v5;
  uint64_t v9;
  unint64_t v11;
  _QWORD __src[3];

  __src[2] = *MEMORY[0x1E0C80C00];
  v4 = (71 - __clz(a4)) >> 3;
  if (a4)
    v5 = v4;
  else
    v5 = 1;
  if (a1)
  {
    if (a2)
    {
      if (*a2 < v5 + 9)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() < 3)
        {
          return 2151678015;
        }
        else
        {
          VRTraceErrorLogLevelToCSTR();
          v9 = 2151678015;
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCCryptor_ComposeSFrameHeaderWithCounterAndMKI_cold_3();
        }
      }
      else if (a3)
      {
        v11 = bswap64(a4);
        memcpy(a1 + 9, (char *)__src - v5, v5);
        *a1 = (16 * v5 + 112) & 0x70 | 0xF;
        __src[0] = 0;
        __src[1] = 0;
        VCMediaKeyIndex_FullKeyBytes(a3, (const char *)__src);
        memcpy(a1 + 1, __src, (*a1 & 7) + 1);
        v9 = 0;
        *a2 = v5 + 9;
      }
      else
      {
        v9 = 2151677953;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCCryptor_ComposeSFrameHeaderWithCounterAndMKI_cold_4();
        }
      }
    }
    else
    {
      v9 = 2151677953;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCCryptor_ComposeSFrameHeaderWithCounterAndMKI_cold_2();
      }
    }
  }
  else
  {
    v9 = 2151677953;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCCryptor_ComposeSFrameHeaderWithCounterAndMKI_cold_1();
    }
  }
  return v9;
}

uint64_t VCCryptor_ParseSFrameHeader(unsigned __int8 *a1, unint64_t a2, uint64_t a3, _QWORD *a4, _QWORD *a5, unint64_t *a6)
{
  int v10;
  size_t v11;
  unint64_t v12;
  id MKIWithBytes;
  uint64_t v14;
  unint64_t v16;
  _QWORD v17[2];

  v17[1] = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a2)
    {
      if (a4)
      {
        if (a5)
        {
          if (a6)
          {
            v10 = (char)*a1;
            if (v10 < 0)
            {
              v14 = 2151677953;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  VCCryptor_ParseSFrameHeader_cold_6();
              }
            }
            else
            {
              if ((v10 & 8) != 0)
              {
                v11 = (*a1 & 7) + 1;
                v12 = v11 + ((unint64_t)*a1 >> 4) + 2;
                if (a3 + v12 + 1 <= a2)
                {
                  v17[0] = 0;
                  memcpy((char *)&v17[1] - v11, a1 + 1, v11);
                  MKIWithBytes = VCMediaKeyIndex_CreateMKIWithBytes((uint64_t)v17, 8);
                  if (MKIWithBytes)
                  {
                    *a4 = MKIWithBytes;
                    v16 = 0;
                    memcpy((char *)&v16 - (((unint64_t)*a1 >> 4) & 7) + 7, &a1[(*a1 & 7) + 2], (((unint64_t)*a1 >> 4) & 7) + 1);
                    v14 = 0;
                    *a5 = bswap64(v16);
                    *a6 = v12;
                  }
                  else
                  {
                    v14 = 2151677953;
                    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                    {
                      VRTraceErrorLogLevelToCSTR();
                      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                        VCCryptor_ParseSFrameHeader_cold_9();
                    }
                  }
                  return v14;
                }
                if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                {
                  VRTraceErrorLogLevelToCSTR();
                  v14 = 2151678015;
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                    VCCryptor_ParseSFrameHeader_cold_8();
                  return v14;
                }
                return 2151678015;
              }
              v14 = 2151677953;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  VCCryptor_ParseSFrameHeader_cold_7();
              }
            }
          }
          else
          {
            v14 = 2151677953;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                VCCryptor_ParseSFrameHeader_cold_5();
            }
          }
        }
        else
        {
          v14 = 2151677953;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VCCryptor_ParseSFrameHeader_cold_4();
          }
        }
      }
      else
      {
        v14 = 2151677953;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCCryptor_ParseSFrameHeader_cold_3();
        }
      }
    }
    else
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 3)
        return 2151678015;
      VRTraceErrorLogLevelToCSTR();
      v14 = 2151678015;
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCCryptor_ParseSFrameHeader_cold_2();
    }
  }
  else
  {
    v14 = 2151677953;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCCryptor_ParseSFrameHeader_cold_1();
    }
  }
  return v14;
}

uint64_t _VCCryptor_ValidateAuthenticationTag(uint64_t a1, char *a2, unint64_t a3)
{
  int CipherSuite;
  uint64_t v7;
  size_t v8;
  uint64_t v9;
  _OWORD v11[2];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  CipherSuite = VCCryptor_GetCipherSuite(a1);
  v7 = 4;
  if (CipherSuite == 1)
    v7 = 10;
  if (CipherSuite)
    v8 = v7;
  else
    v8 = 0;
  if (a3 <= v8)
  {
    v9 = 2151678015;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCCryptor_ValidateAuthenticationTag_cold_1();
    }
  }
  else
  {
    memset(v11, 0, sizeof(v11));
    CCHmac(2u, (const void *)(a1 + 128), 0x20uLL, a2, a3 - v8, v11);
    if (!memcmp(&a2[a3 - v8], v11, v8))
    {
      return 0;
    }
    else
    {
      CCCryptorRelease(*(CCCryptorRef *)(a1 + 8360));
      *(_QWORD *)(a1 + 8360) = 0;
      return 2151678022;
    }
  }
  return v9;
}

uint64_t _VCCryptorClassRegister(uint64_t *a1)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

uint64_t VCCryptor_Create(uint64_t a1, int a2, const void *a3, const void *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t Instance;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  NSObject *v15;
  int v16;
  uint64_t v17;
  int v19;
  uint8_t buf[4];
  uint64_t v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  int v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (a6)
  {
    if (a4)
    {
      if ((a2 - 3) <= 0xFFFFFFFD)
      {
        v17 = 2151677953;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCCryptor_Create_cold_3();
        }
      }
      else if (a3)
      {
        if (VCCryptorGetTypeID_initOnce != -1)
          dispatch_once_f(&VCCryptorGetTypeID_initOnce, &VCCryptorGetTypeID_typeID, (dispatch_function_t)_VCCryptorClassRegister);
        Instance = _CFRuntimeCreateInstance();
        if (Instance)
        {
          v12 = Instance;
          bzero((void *)(Instance + 16), 0x20A0uLL);
          *(_DWORD *)(v12 + 48) = a2;
          *(_QWORD *)(v12 + 40) = CFRetain(a3);
          *(_QWORD *)(v12 + 16) = CFRetain(a4);
          atomic_store(0, (unsigned __int8 *)(v12 + 32));
          *(_QWORD *)(v12 + 160) = -1;
          *(_BYTE *)(v12 + 35) = 1;
          if (a5)
          {
            FigCFDictionaryGetBooleanIfPresent();
            *(_BYTE *)(v12 + 35) = 1;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
            {
              v13 = VRTraceErrorLogLevelToCSTR();
              v14 = *MEMORY[0x1E0CF2758];
              v15 = *MEMORY[0x1E0CF2758];
              if (*MEMORY[0x1E0CF2748])
              {
                if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
                {
                  v16 = *(unsigned __int8 *)(v12 + 35);
                  *(_DWORD *)buf = 136316162;
                  v21 = v13;
                  v22 = 2080;
                  v23 = "VCCryptor_Create";
                  v24 = 1024;
                  v25 = 550;
                  v26 = 2048;
                  v27 = v12;
                  v28 = 1024;
                  v29 = v16;
                  _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d [%p] isReplayProtectionEnabled=%d", buf, 0x2Cu);
                }
              }
              else if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
              {
                v19 = *(unsigned __int8 *)(v12 + 35);
                *(_DWORD *)buf = 136316162;
                v21 = v13;
                v22 = 2080;
                v23 = "VCCryptor_Create";
                v24 = 1024;
                v25 = 550;
                v26 = 2048;
                v27 = v12;
                v28 = 1024;
                v29 = v19;
                _os_log_debug_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEBUG, " [%s] %s:%d [%p] isReplayProtectionEnabled=%d", buf, 0x2Cu);
              }
            }
          }
          v17 = 0;
          *a6 = v12;
        }
        else if ((int)VRTraceGetErrorLogLevelForModule() < 3)
        {
          return 2151677955;
        }
        else
        {
          VRTraceErrorLogLevelToCSTR();
          v17 = 2151677955;
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCCryptor_Create_cold_5();
        }
      }
      else
      {
        v17 = 2151677953;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCCryptor_Create_cold_4();
        }
      }
    }
    else
    {
      v17 = 2151677953;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCCryptor_Create_cold_2();
      }
    }
  }
  else
  {
    v17 = 2151677953;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCCryptor_Create_cold_1();
    }
  }
  return v17;
}

uint64_t VCCryptor_Encrypt(uint64_t a1, OpaqueCMBlockBuffer *a2, CFTypeRef *a3)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  size_t DataLength;
  int CipherSuite;
  uint64_t v11;
  unint64_t v12;
  size_t v13;
  OpaqueCMBlockBuffer *v14;
  uint64_t v15;
  uint64_t DataPointer;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  size_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v26;
  NSObject *v27;
  size_t dataOutMoved;
  char *v29;
  unint64_t v30;
  char *dataPointerOut;
  CMBlockBufferRef theBuffer;
  _OWORD macOut[2];
  uint8_t buf[4];
  uint64_t v35;
  __int16 v36;
  const char *v37;
  __int16 v38;
  int v39;
  __int16 v40;
  size_t v41;
  __int16 v42;
  size_t v43;
  _QWORD iv[3];

  iv[2] = *MEMORY[0x1E0C80C00];
  theBuffer = 0;
  v6 = _VCCryptor_ValidateCryptographyInputParameters(a1, a2, (uint64_t)a3, 1);
  if ((_DWORD)v6)
  {
    v24 = v6;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCCryptor_Encrypt_cold_11();
    }
    goto LABEL_29;
  }
  if (_VCCryptor_EnsureCryptorIsReady(a1, 0, 0))
  {
    v24 = 2151677969;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCCryptor_Encrypt_cold_10();
    }
    goto LABEL_29;
  }
  v7 = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 56) = v7 + 1;
  iv[0] = 0xAAAAAAAAAAAAAAAALL;
  iv[1] = 0xAAAAAAAAAAAAAAAALL;
  v8 = _VCCryptor_DeriveIV(a1, v7, iv);
  if ((_DWORD)v8)
  {
    v24 = v8;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCCryptor_Encrypt_cold_9();
    }
    goto LABEL_29;
  }
  DataLength = CMBlockBufferGetDataLength(a2);
  if (!CMBlockBufferIsRangeContiguous(a2, 0, DataLength))
  {
    v24 = 2151678024;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        VCCryptor_Encrypt_cold_1();
        v24 = 2151678024;
      }
    }
    goto LABEL_29;
  }
  CipherSuite = VCCryptor_GetCipherSuite(a1);
  v11 = 13;
  if (CipherSuite == 1)
    v11 = 19;
  if (!CipherSuite)
    v11 = 9;
  v12 = (71 - __clz(v7)) >> 3;
  if (!v7)
    v12 = 1;
  v13 = DataLength + v11 + v12;
  if (*a3)
  {
    v14 = (OpaqueCMBlockBuffer *)CFRetain(*a3);
    theBuffer = v14;
  }
  else
  {
    v15 = CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v13, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, v13, 1u, &theBuffer);
    if ((_DWORD)v15)
    {
      v24 = v15;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCCryptor_Encrypt_cold_8();
      }
      goto LABEL_29;
    }
    v14 = theBuffer;
  }
  dataPointerOut = 0;
  DataPointer = CMBlockBufferGetDataPointer(v14, 0, 0, 0, &dataPointerOut);
  if ((_DWORD)DataPointer)
  {
    v24 = DataPointer;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCCryptor_Encrypt_cold_7();
    }
  }
  else
  {
    v30 = v13;
    v17 = VCCryptor_ComposeSFrameHeaderWithCounterAndMKI(dataPointerOut, &v30, *(void **)(a1 + 24), v7);
    if ((_DWORD)v17)
    {
      v24 = v17;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCCryptor_Encrypt_cold_6();
      }
    }
    else if (v30 <= 9)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      {
        v24 = 2151678015;
      }
      else
      {
        VRTraceErrorLogLevelToCSTR();
        v24 = 2151678015;
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCCryptor_Encrypt_cold_2();
      }
    }
    else
    {
      v18 = CCCryptorReset(*(CCCryptorRef *)(a1 + 8360), iv);
      if ((_DWORD)v18)
      {
        v24 = v18;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCCryptor_Encrypt_cold_5();
        }
      }
      else
      {
        v29 = 0;
        v19 = CMBlockBufferGetDataPointer(a2, 0, 0, 0, &v29);
        if ((_DWORD)v19)
        {
          v24 = v19;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VCCryptor_Encrypt_cold_4();
          }
        }
        else
        {
          dataOutMoved = 0;
          v20 = VCCryptor_GetCipherSuite(a1);
          v21 = 4;
          if (v20 == 1)
            v21 = 10;
          if (v20)
            v22 = v21;
          else
            v22 = 0;
          v23 = CCCryptorUpdate(*(CCCryptorRef *)(a1 + 8360), v29, DataLength, &dataPointerOut[v30], v13 - v22, &dataOutMoved);
          if ((_DWORD)v23)
          {
            v24 = v23;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                VCCryptor_Encrypt_cold_3();
            }
          }
          else if (dataOutMoved == DataLength)
          {
            memset(macOut, 0, sizeof(macOut));
            CCHmac(2u, (const void *)(a1 + 128), 0x20uLL, dataPointerOut, dataOutMoved + v30, macOut);
            memcpy(&dataPointerOut[v30 + dataOutMoved], macOut, v22);
            if (!*a3)
            {
              v24 = 0;
              *a3 = theBuffer;
              return v24;
            }
            v24 = 0;
          }
          else
          {
            v24 = 2151678020;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              v26 = VRTraceErrorLogLevelToCSTR();
              v27 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136316162;
                v35 = v26;
                v36 = 2080;
                v37 = "VCCryptor_Encrypt";
                v38 = 1024;
                v39 = 632;
                v40 = 2048;
                v41 = DataLength;
                v42 = 2048;
                v43 = dataOutMoved;
                _os_log_error_impl(&dword_1D8A54000, v27, OS_LOG_TYPE_ERROR, " [%s] %s:%d Encryptor should have encryped at least '%zu' bytes bu only encryped '%zu' bytes", buf, 0x30u);
                v24 = 2151678020;
              }
            }
          }
        }
      }
    }
  }
LABEL_29:
  if (theBuffer)
    CFRelease(theBuffer);
  return v24;
}

uint64_t _VCCryptor_ValidateCryptographyInputParameters(uint64_t a1, CMBlockBufferRef theBuffer, uint64_t a3, int a4)
{
  size_t DataLength;
  size_t v7;
  uint64_t v8;
  int CipherSuite;
  uint64_t v10;
  unint64_t v11;
  size_t v13;
  uint64_t v14;
  NSObject *v15;
  unint64_t v16;
  uint8_t buf[4];
  uint64_t v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  size_t v24;
  __int16 v25;
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (theBuffer)
    {
      if (a3)
      {
        DataLength = CMBlockBufferGetDataLength(theBuffer);
        v7 = DataLength;
        if (a4)
        {
          if (!DataLength)
          {
            v8 = 2151677953;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                _VCCryptor_ValidateCryptographyInputParameters_cold_4();
            }
            return v8;
          }
          return 0;
        }
        CipherSuite = VCCryptor_GetCipherSuite(a1);
        v10 = 14;
        if (CipherSuite == 1)
          v10 = 20;
        if (CipherSuite)
          v11 = v10;
        else
          v11 = 10;
        if (v7 > v11)
          return 0;
        v13 = v7;
        v8 = 2151677953;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v16 = v11;
          v14 = VRTraceErrorLogLevelToCSTR();
          v15 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136316162;
            v18 = v14;
            v19 = 2080;
            v20 = "_VCCryptor_ValidateCryptographyInputParameters";
            v21 = 1024;
            v22 = 307;
            v23 = 2048;
            v24 = v13;
            v25 = 2048;
            v26 = v16 | 1;
            _os_log_error_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_ERROR, " [%s] %s:%d inputBuffer contains incorrect data size '%zu'. Expected at least '%zu' bytes of input data", buf, 0x30u);
          }
        }
      }
      else
      {
        v8 = 2151677953;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VCCryptor_ValidateCryptographyInputParameters_cold_3();
        }
      }
    }
    else
    {
      v8 = 2151677953;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCCryptor_ValidateCryptographyInputParameters_cold_2();
      }
    }
  }
  else
  {
    v8 = 2151677953;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCCryptor_ValidateCryptographyInputParameters_cold_1();
    }
  }
  return v8;
}

uint64_t _VCCryptor_EnsureCryptorIsReady(uint64_t a1, char *a2, uint64_t a3)
{
  unsigned __int8 *v6;
  unsigned __int8 v7;
  _BOOL4 isStartingWithPrefix;
  CCCryptorRef *v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  CFIndex v14;
  const __CFDictionary *ValueAtIndex;
  const __CFBoolean *Value;
  int v17;
  BOOL v18;
  const __CFData *v19;
  const __CFData *v20;
  unint64_t Length;
  const __CFData *v22;
  const __CFData *v23;
  unint64_t v24;
  void *v25;
  void *v26;
  const __CFBoolean *v27;
  CCOperation v28;
  uint64_t v30;
  int ErrorLogLevelForModule;
  uint64_t v32;
  NSObject *v33;
  uint64_t v34;
  NSObject *v35;
  uint64_t v36;
  NSObject *v37;
  uint64_t v38;
  NSObject *v39;
  uint64_t v40;
  NSObject *v41;
  NSObject *v42;
  const __CFBoolean *BOOLean;
  _QWORD v44[5];
  CFArrayRef theArray;
  _BYTE buffer[38];
  __int16 v47;
  uint64_t v48;
  UInt8 v49[8];
  uint64_t v50;
  uint64_t v51;
  CFRange v52;
  CFRange v53;

  v51 = *MEMORY[0x1E0C80C00];
  theArray = 0;
  v6 = (unsigned __int8 *)(a1 + 32);
  do
    v7 = __ldaxr(v6);
  while (__stlxr(0, v6));
  if (!a2)
  {
    if (*(_QWORD *)(a1 + 8360))
      v10 = (v7 & 1) == 0;
    else
      v10 = 0;
    if (v10)
      goto LABEL_71;
    v9 = (CCCryptorRef *)(a1 + 8360);
    if (!*(_BYTE *)(a1 + 33))
    {
      v11 = *(_QWORD *)(a1 + 16);
      v44[0] = MEMORY[0x1E0C809B0];
      v44[1] = 0x40000000;
      v44[2] = ___VCCryptor_EnsureCryptorIsReady_block_invoke;
      v44[3] = &__block_descriptor_tmp_12;
      v44[4] = a1;
      v12 = VCSecurityKeyHolder_RegisterForKeyMaterialChangeNotification(v11, v44);
      if ((_DWORD)v12)
      {
        v30 = v12;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VCCryptor_EnsureCryptorIsReady_cold_16();
        }
        goto LABEL_53;
      }
      *(_BYTE *)(a1 + 33) = 1;
    }
LABEL_15:
    v13 = VCSecurityKeyHolder_CopyKeyMaterialForKeyIndex(*(_QWORD *)(a1 + 16), a2, (uint64_t *)&theArray);
    if ((_DWORD)v13)
    {
      v30 = v13;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v34 = VRTraceErrorLogLevelToCSTR();
        v35 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCCryptor_EnsureCryptorIsReady_cold_14(v34, a2, v35);
      }
    }
    else if (theArray)
    {
      if (CFArrayGetCount(theArray) < 1)
      {
        v30 = 2151677969;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v38 = VRTraceErrorLogLevelToCSTR();
          v39 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VCCryptor_EnsureCryptorIsReady_cold_2(v38, a2, v39);
        }
      }
      else
      {
        v14 = 0;
        while (1)
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v14);
          Value = (const __CFBoolean *)CFDictionaryGetValue(ValueAtIndex, CFSTR("SecurityLocallyGenerated"));
          v17 = CFBooleanGetValue(Value);
          if (!a2 && !v17)
            break;
          if (a3)
          {
            CFDictionaryGetValue(ValueAtIndex, CFSTR("SecurityKeyIndex"));
            if (FigCFArrayContainsValue())
              v18 = 1;
            else
              v18 = ValueAtIndex == 0;
            if (!v18)
            {
LABEL_30:
              memset(buffer, 0, 32);
              *(_QWORD *)v49 = 0;
              v50 = 0;
              CCCryptorRelease(*v9);
              *v9 = 0;
              v19 = (const __CFData *)CFDictionaryGetValue(ValueAtIndex, CFSTR("SecurityKey"));
              if (v19)
              {
                v20 = v19;
                Length = CFDataGetLength(v19);
                v22 = (const __CFData *)CFDictionaryGetValue(ValueAtIndex, CFSTR("SecuritySalt"));
                if (v22)
                {
                  v23 = v22;
                  v24 = CFDataGetLength(v22);
                  v25 = (void *)CFDictionaryGetValue(ValueAtIndex, CFSTR("SecurityKeyIndex"));
                  if (v25)
                  {
                    v26 = v25;
                    v27 = (const __CFBoolean *)CFDictionaryGetValue(ValueAtIndex, CFSTR("SecurityLocallyGenerated"));
                    if (v27)
                    {
                      BOOLean = v27;
                      if (Length >= 0x20)
                        Length = 32;
                      if (v24 >= 0x10)
                        v24 = 16;
                      v52.location = 0;
                      v52.length = Length;
                      CFDataGetBytes(v20, v52, buffer);
                      v53.location = 0;
                      v53.length = v24;
                      CFDataGetBytes(v23, v53, v49);
                      CFDataGetBytePtr(*(CFDataRef *)(a1 + 40));
                      CFDataGetLength(*(CFDataRef *)(a1 + 40));
                      if (CCKeyDerivationHMac())
                      {
                        v30 = 2151678023;
                        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                        {
                          VRTraceErrorLogLevelToCSTR();
                          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                          {
                            _VCCryptor_EnsureCryptorIsReady_cold_12();
                            goto LABEL_96;
                          }
                        }
                      }
                      else if (CCKeyDerivationHMac())
                      {
                        v30 = 2151678023;
                        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                        {
                          VRTraceErrorLogLevelToCSTR();
                          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                          {
                            _VCCryptor_EnsureCryptorIsReady_cold_11();
                            goto LABEL_96;
                          }
                        }
                      }
                      else if (CCKeyDerivationHMac())
                      {
                        v30 = 2151678023;
                        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                        {
                          VRTraceErrorLogLevelToCSTR();
                          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                          {
                            _VCCryptor_EnsureCryptorIsReady_cold_10();
                            goto LABEL_96;
                          }
                        }
                      }
                      else if (CCKeyDerivationHMac())
                      {
                        v30 = 2151678023;
                        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                        {
                          VRTraceErrorLogLevelToCSTR();
                          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                          {
                            _VCCryptor_EnsureCryptorIsReady_cold_9();
                            goto LABEL_96;
                          }
                        }
                      }
                      else
                      {
                        v28 = CFBooleanGetValue(BOOLean) == 0;
                        if (!CCCryptorCreateWithMode(v28, 4u, 0, 0, 0, (const void *)(a1 + 96), 0x10uLL, 0, 0, 0, 2u, v9))
                        {
                          VCMediaKeyIndex_ReleaseAndCopyNewValue((const void **)(a1 + 24), v26);
                          v30 = 0;
                          *(_BYTE *)(a1 + 34) = 0;
                          goto LABEL_53;
                        }
                        v30 = 2151678023;
                        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                        {
                          VRTraceErrorLogLevelToCSTR();
                          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                          {
                            _VCCryptor_EnsureCryptorIsReady_cold_8();
LABEL_96:
                            v30 = 2151678023;
                          }
                        }
                      }
                    }
                    else
                    {
                      v30 = 2151677969;
                      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                      {
                        VRTraceErrorLogLevelToCSTR();
                        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                          _VCCryptor_EnsureCryptorIsReady_cold_7();
                      }
                    }
                  }
                  else
                  {
                    v30 = 2151677969;
                    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                    {
                      VRTraceErrorLogLevelToCSTR();
                      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                        _VCCryptor_EnsureCryptorIsReady_cold_6();
                    }
                  }
                }
                else
                {
                  v30 = 2151677969;
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                  {
                    VRTraceErrorLogLevelToCSTR();
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                      _VCCryptor_EnsureCryptorIsReady_cold_5();
                  }
                }
              }
              else
              {
                v30 = 2151677969;
                if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                {
                  VRTraceErrorLogLevelToCSTR();
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                    _VCCryptor_EnsureCryptorIsReady_cold_4();
                }
              }
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  _VCCryptor_EnsureCryptorIsReady_cold_3();
              }
              goto LABEL_53;
            }
          }
          else if (ValueAtIndex)
          {
            goto LABEL_30;
          }
          if (++v14 >= CFArrayGetCount(theArray))
          {
            v30 = 2151677969;
            ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
            if (ErrorLogLevelForModule >= 3)
            {
              v32 = VRTraceErrorLogLevelToCSTR();
              v33 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buffer = 136316162;
                *(_QWORD *)&buffer[4] = v32;
                *(_WORD *)&buffer[12] = 2080;
                *(_QWORD *)&buffer[14] = "_VCCryptor_EnsureCryptorIsReady";
                *(_WORD *)&buffer[22] = 1024;
                *(_DWORD *)&buffer[24] = 458;
                *(_WORD *)&buffer[28] = 2112;
                *(_QWORD *)&buffer[30] = theArray;
                v47 = 2112;
                v48 = a3;
                _os_log_error_impl(&dword_1D8A54000, v33, OS_LOG_TYPE_ERROR, " [%s] %s:%d _VCCryptor_SetupCryptor failed to find key material from '%@' with disableMKI array '%@'", buffer, 0x30u);
              }
            }
            goto LABEL_53;
          }
        }
        v30 = 2151677969;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VCCryptor_EnsureCryptorIsReady_cold_13();
        }
      }
    }
    else
    {
      v30 = 2151677969;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v36 = VRTraceErrorLogLevelToCSTR();
        v37 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCCryptor_EnsureCryptorIsReady_cold_1(v36, a2, v37);
      }
    }
    goto LABEL_53;
  }
  isStartingWithPrefix = VCMediaKeyIndex_isStartingWithPrefix(*(_QWORD *)(a1 + 24), (uint64_t)a2);
  v9 = (CCCryptorRef *)(a1 + 8360);
  if (!*(_QWORD *)(a1 + 8360) || !isStartingWithPrefix || (v7 & 1) != 0)
    goto LABEL_15;
LABEL_71:
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v40 = VRTraceErrorLogLevelToCSTR();
    v41 = *MEMORY[0x1E0CF2758];
    v42 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      v30 = 0;
      if (!os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
        goto LABEL_53;
      *(_DWORD *)buffer = 136315650;
      *(_QWORD *)&buffer[4] = v40;
      *(_WORD *)&buffer[12] = 2080;
      *(_QWORD *)&buffer[14] = "_VCCryptor_EnsureCryptorIsReady";
      *(_WORD *)&buffer[22] = 1024;
      *(_DWORD *)&buffer[24] = 420;
      _os_log_impl(&dword_1D8A54000, v41, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Cryptor is valid, nothing to do here", buffer, 0x1Cu);
    }
    else if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
    {
      _VCCryptor_EnsureCryptorIsReady_cold_15();
    }
  }
  v30 = 0;
LABEL_53:
  if (theArray)
    CFRelease(theArray);
  return v30;
}

uint64_t _VCCryptor_DeriveIV(uint64_t a1, unint64_t a2, _QWORD *a3)
{
  uint64_t v3;
  uint64_t v4;

  if (a3)
  {
    v3 = 0;
    *a3 = bswap64(a2);
    a3[1] = 0;
    do
    {
      *((_BYTE *)a3 + v3) ^= *(_BYTE *)(a1 + 112 + v3);
      ++v3;
    }
    while (v3 != 16);
    return 0;
  }
  else
  {
    v4 = 2151677953;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCCryptor_DeriveIV_cold_1();
    }
  }
  return v4;
}

uint64_t VCCryptor_Decrypt(uint64_t a1, OpaqueCMBlockBuffer *a2, CMBlockBufferRef *a3)
{
  size_t DataLength;
  uint64_t DataPointer;
  int CipherSuite;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  size_t v12;
  uint64_t IsReady;
  __CFArray *Mutable;
  const __CFAllocator *v15;
  const CFArrayCallBacks *v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  BOOL v22;
  unint64_t v23;
  uint64_t v24;
  NSObject *v25;
  uint64_t v26;
  const char *v27;
  NSObject *v28;
  uint32_t v29;
  uint64_t v30;
  size_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v38;
  uint64_t v39;
  NSObject *v40;
  uint64_t v41;
  NSObject *v42;
  size_t dataOutMoved;
  char *v44;
  unint64_t v45;
  unint64_t v46;
  char *dataPointerOut;
  CFTypeRef cf;
  CMBlockBufferRef theBuffer;
  _QWORD iv[2];
  uint8_t buf[4];
  uint64_t v52;
  __int16 v53;
  const char *v54;
  __int16 v55;
  int v56;
  __int16 v57;
  size_t v58;
  __int16 v59;
  size_t v60;
  __int16 v61;
  uint64_t v62;
  uint64_t v63;

  v63 = *MEMORY[0x1E0C80C00];
  cf = 0;
  theBuffer = 0;
  if (_VCCryptor_ValidateCryptographyInputParameters(a1, a2, (uint64_t)a3, 0))
  {
    v18 = 2151677953;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCCryptor_Decrypt_cold_12();
    }
  }
  else
  {
    DataLength = CMBlockBufferGetDataLength(a2);
    if (CMBlockBufferIsRangeContiguous(a2, 0, DataLength))
    {
      dataPointerOut = 0;
      DataPointer = CMBlockBufferGetDataPointer(a2, 0, 0, 0, &dataPointerOut);
      if ((_DWORD)DataPointer)
      {
        v18 = DataPointer;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCCryptor_Decrypt_cold_11();
        }
      }
      else
      {
        v45 = 0;
        v46 = 0;
        CipherSuite = VCCryptor_GetCipherSuite(a1);
        v9 = 4;
        if (CipherSuite == 1)
          v9 = 10;
        if (CipherSuite)
          v10 = v9;
        else
          v10 = 0;
        v11 = VCCryptor_ParseSFrameHeader((unsigned __int8 *)dataPointerOut, DataLength, v10, &cf, &v46, &v45);
        if ((_DWORD)v11)
        {
          v18 = v11;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VCCryptor_Decrypt_cold_10();
          }
        }
        else if (cf)
        {
          v12 = v45 + v10;
          if (DataLength >= v45 + v10)
          {
            IsReady = _VCCryptor_EnsureCryptorIsReady(a1, (char *)cf, 0);
            if ((_DWORD)IsReady)
            {
              v18 = IsReady;
              goto LABEL_42;
            }
            Mutable = 0;
            v15 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
            v16 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
            while (1)
            {
              v17 = _VCCryptor_ValidateAuthenticationTag(a1, dataPointerOut, DataLength);
              if ((_DWORD)v17 != -2143289274)
                break;
              if (!Mutable)
                Mutable = CFArrayCreateMutable(v15, 0, v16);
              CFArrayAppendValue(Mutable, *(const void **)(a1 + 24));
              if (_VCCryptor_EnsureCryptorIsReady(a1, (char *)cf, (uint64_t)Mutable))
              {
                v18 = 2151678022;
                goto LABEL_40;
              }
            }
            v18 = v17;
            if ((_DWORD)v17)
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  VCCryptor_Decrypt_cold_3();
              }
              goto LABEL_40;
            }
            v19 = v46;
            if (*(_BYTE *)(a1 + 35))
            {
              v20 = v46 & 0x3FF;
              v21 = *(_QWORD *)(a1 + 8352);
              v22 = v21 >= v46;
              v23 = v21 - v46;
              if (v22)
              {
                if (v23 > 0x3FF || *(_QWORD *)(a1 + 8 * v20 + 160) == v46)
                {
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                  {
                    v24 = VRTraceErrorLogLevelToCSTR();
                    v25 = *MEMORY[0x1E0CF2758];
                    v18 = 2151678007;
                    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                      goto LABEL_40;
                    v26 = *(_QWORD *)(a1 + 8352);
                    *(_DWORD *)buf = 136316418;
                    v52 = v24;
                    v53 = 2080;
                    v54 = "VCCryptor_Decrypt";
                    v55 = 1024;
                    v56 = 707;
                    v57 = 2048;
                    v58 = a1;
                    v59 = 2048;
                    v60 = v46;
                    v61 = 2048;
                    v62 = v26;
                    v27 = " [%s] %s:%d [%p] VCCryptor_CheckReplayWindow detected replay. counter=%llu, maxReceivedCounter=%llu";
                    v28 = v25;
                    v29 = 58;
                    goto LABEL_28;
                  }
                  v38 = 54;
LABEL_48:
                  v18 = v38 | 0x80400001;
                  goto LABEL_40;
                }
              }
              else
              {
                *(_QWORD *)(a1 + 8352) = v46;
              }
              *(_QWORD *)(a1 + 8 * v20 + 160) = v19;
            }
            iv[0] = 0xAAAAAAAAAAAAAAAALL;
            iv[1] = 0xAAAAAAAAAAAAAAAALL;
            v30 = _VCCryptor_DeriveIV(a1, v19, iv);
            if ((_DWORD)v30)
            {
              v18 = v30;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  VCCryptor_Decrypt_cold_9();
              }
              goto LABEL_40;
            }
            v31 = DataLength - v10 - v45;
            v32 = CMBlockBufferCreateWithMemoryBlock(v15, 0, v31, v15, 0, 0, v31, 1u, &theBuffer);
            if ((_DWORD)v32)
            {
              v18 = v32;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  VCCryptor_Decrypt_cold_8();
              }
              goto LABEL_40;
            }
            v44 = 0;
            v33 = CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, &v44);
            if ((_DWORD)v33)
            {
              v18 = v33;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  VCCryptor_Decrypt_cold_7();
              }
              goto LABEL_40;
            }
            v34 = CCCryptorReset(*(CCCryptorRef *)(a1 + 8360), iv);
            if ((_DWORD)v34)
            {
              v18 = v34;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  VCCryptor_Decrypt_cold_6();
              }
              goto LABEL_40;
            }
            dataOutMoved = 0;
            v35 = CCCryptorUpdate(*(CCCryptorRef *)(a1 + 8360), &dataPointerOut[v45], v31, v44, v31, &dataOutMoved);
            if ((_DWORD)v35)
            {
              v18 = v35;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  VCCryptor_Decrypt_cold_5();
              }
              goto LABEL_40;
            }
            if (dataOutMoved == v31)
            {
              if (!*(_BYTE *)(a1 + 34))
              {
                v36 = VCSecurityKeyHolder_AssociateKeyIndex(*(_QWORD *)(a1 + 16), *(const char **)(a1 + 24));
                if ((_DWORD)v36)
                {
                  v18 = v36;
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                  {
                    VRTraceErrorLogLevelToCSTR();
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                      VCCryptor_Decrypt_cold_4();
                  }
                  goto LABEL_40;
                }
                *(_BYTE *)(a1 + 34) = 1;
              }
              v18 = 0;
              *a3 = theBuffer;
              theBuffer = 0;
LABEL_40:
              if (Mutable)
                CFRelease(Mutable);
              goto LABEL_42;
            }
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              v41 = VRTraceErrorLogLevelToCSTR();
              v42 = *MEMORY[0x1E0CF2758];
              v18 = 2151678021;
              if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                goto LABEL_40;
              *(_DWORD *)buf = 136316162;
              v52 = v41;
              v53 = 2080;
              v54 = "VCCryptor_Decrypt";
              v55 = 1024;
              v56 = 734;
              v57 = 2048;
              v58 = v31;
              v59 = 2048;
              v60 = dataOutMoved;
              v27 = " [%s] %s:%d Decrypor should have produced at least '%zu' bytes but only produced '%zu' bytes";
              v28 = v42;
              v29 = 48;
LABEL_28:
              _os_log_error_impl(&dword_1D8A54000, v28, OS_LOG_TYPE_ERROR, v27, buf, v29);
              goto LABEL_40;
            }
            v38 = 68;
            goto LABEL_48;
          }
          if ((int)VRTraceGetErrorLogLevelForModule() < 3)
          {
            v18 = 2151678015;
          }
          else
          {
            v39 = VRTraceErrorLogLevelToCSTR();
            v40 = *MEMORY[0x1E0CF2758];
            v18 = 2151678015;
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136316162;
              v52 = v39;
              v53 = 2080;
              v54 = "VCCryptor_Decrypt";
              v55 = 1024;
              v56 = 681;
              v57 = 2048;
              v58 = v12;
              v59 = 2048;
              v60 = DataLength;
              _os_log_error_impl(&dword_1D8A54000, v40, OS_LOG_TYPE_ERROR, " [%s] %s:%d Size of encrypted SFrame is less than its required overhead. Minimum required size '%zu', actual size '%zu'", buf, 0x30u);
            }
          }
        }
        else
        {
          v18 = 2151677953;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VCCryptor_Decrypt_cold_2();
          }
        }
      }
    }
    else
    {
      v18 = 2151678024;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          VCCryptor_Decrypt_cold_1();
          v18 = 2151678024;
        }
      }
    }
  }
LABEL_42:
  if (theBuffer)
    CFRelease(theBuffer);
  if (cf)
    CFRelease(cf);
  return v18;
}

uint64_t VCCryptor_GetEncryptedBufferSize(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  unint64_t v5;
  int CipherSuite;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;

  if (a1)
  {
    if (a3)
    {
      v5 = *(_QWORD *)(a1 + 56);
      CipherSuite = VCCryptor_GetCipherSuite(a1);
      v7 = 0;
      v8 = 13;
      if (CipherSuite == 1)
        v8 = 19;
      if (!CipherSuite)
        v8 = 9;
      v9 = (71 - __clz(v5)) >> 3;
      if (!v5)
        v9 = 1;
      *a3 = v9 + a2 + v8;
    }
    else
    {
      v7 = 2151677953;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCCryptor_GetEncryptedBufferSize_cold_2();
      }
    }
  }
  else
  {
    v7 = 2151677953;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCCryptor_GetEncryptedBufferSize_cold_1();
    }
  }
  return v7;
}

void _VCCryptor_Finalize(uint64_t a1)
{
  const void *v2;
  const void *v3;
  const void *v4;

  if (*(_BYTE *)(a1 + 33))
    VCSecurityKeyHolder_RegisterForKeyMaterialChangeNotification(*(_QWORD *)(a1 + 16), 0);
  v2 = *(const void **)(a1 + 16);
  if (v2)
    CFRelease(v2);
  v3 = *(const void **)(a1 + 24);
  if (v3)
    CFRelease(v3);
  CCCryptorRelease(*(CCCryptorRef *)(a1 + 8360));
  v4 = *(const void **)(a1 + 40);
  if (v4)
    CFRelease(v4);
}

const char *OUTLINED_FUNCTION_11_12@<X0>(void *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  *(_QWORD *)(v2 - 24) = a2;
  return VCMediaKeyIndex_Description(a1);
}

uint64_t VCMediaNegotiationBlobCaptionsSettingsReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  int v15;
  char v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char v22;
  char v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  char v28;
  uint64_t result;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        v14 = v9++ >= 9;
        if (v14)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      if ((v10 >> 3) == 2)
      {
        v23 = 0;
        v24 = 0;
        v25 = 0;
        *(_BYTE *)(a1 + 16) |= 1u;
        while (1)
        {
          v26 = *v3;
          v27 = *(_QWORD *)(a2 + v26);
          if (v27 == -1 || v27 >= *(_QWORD *)(a2 + *v4))
            break;
          v28 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v27);
          *(_QWORD *)(a2 + v26) = v27 + 1;
          v25 |= (unint64_t)(v28 & 0x7F) << v23;
          if ((v28 & 0x80) == 0)
            goto LABEL_41;
          v23 += 7;
          v14 = v24++ >= 9;
          if (v14)
          {
            LODWORD(v25) = 0;
            goto LABEL_43;
          }
        }
        *(_BYTE *)(a2 + *v5) = 1;
LABEL_41:
        if (*(_BYTE *)(a2 + *v5))
          LODWORD(v25) = 0;
LABEL_43:
        *(_DWORD *)(a1 + 8) = v25;
      }
      else if ((v10 >> 3) == 1)
      {
        v17 = 0;
        v18 = 0;
        v19 = 0;
        *(_BYTE *)(a1 + 16) |= 2u;
        while (1)
        {
          v20 = *v3;
          v21 = *(_QWORD *)(a2 + v20);
          if (v21 == -1 || v21 >= *(_QWORD *)(a2 + *v4))
            break;
          v22 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v21);
          *(_QWORD *)(a2 + v20) = v21 + 1;
          v19 |= (unint64_t)(v22 & 0x7F) << v17;
          if ((v22 & 0x80) == 0)
            goto LABEL_37;
          v17 += 7;
          v14 = v18++ >= 9;
          if (v14)
          {
            v19 = 0;
            goto LABEL_39;
          }
        }
        *(_BYTE *)(a2 + *v5) = 1;
LABEL_37:
        if (*(_BYTE *)(a2 + *v5))
          v19 = 0;
LABEL_39:
        *(_BYTE *)(a1 + 12) = v19 != 0;
      }
      else
      {
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
      }
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

uint64_t _VCMediaStream_DefaultTransport(uint64_t a1)
{
  if (objc_msgSend(*(id *)(a1 + 544), "count"))
    return objc_msgSend(*(id *)(a1 + 544), "objectAtIndexedSubscript:", 0);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCMediaStream_DefaultTransport_cold_1();
  }
  return 0;
}

uint64_t VCMediaStream_Lock(uint64_t result)
{
  if (result)
    return pthread_mutex_lock((pthread_mutex_t *)(result + 176));
  return result;
}

uint64_t VCMediaStream_Unlock(uint64_t result)
{
  if (result)
    return pthread_mutex_unlock((pthread_mutex_t *)(result + 176));
  return result;
}

uint64_t _VCMediaStream_TransportStreamCreationCallback(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend(a1, "createTransportStream:withType:options:", a4, a2, a3);
}

void sub_1D8DDA56C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  uint64_t v11;
  va_list va;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  va_list va1;

  va_start(va1, a10);
  va_start(va, a10);
  v11 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t VCMediaCallback(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v8;
  uint64_t v9;

  v8 = (void *)MEMORY[0x1DF088A10]();
  if (a2)
    v9 = objc_msgSend(a2, "handleMediaCallbackNotification:inData:outData:", a1, a3, a4);
  else
    v9 = 2148597761;
  objc_autoreleasePoolPop(v8);
  return v9;
}

void sub_1D8DDCBD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v8;
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v8 - 56), 8);
  _Unwind_Resume(a1);
}

uint64_t _VCMediaStream_WRMReportMetricsCallback(void *a1, const char *a2)
{
  return objc_msgSend(a1, "reportWRMMetrics:", a2);
}

void VCMediaStreamFillMediaControlInfoCallback(uint64_t a1, uint64_t a2, void *a3)
{
  int Type;
  int *v7;
  void *v8;
  BOOL v9;

  Type = VCMediaControlInfoGeneratorGetType(a1);
  if (*(_QWORD *)(a2 + 640) == a1)
  {
    v7 = &OBJC_IVAR___VCMediaStream__feedbackController;
  }
  else
  {
    if (*(_QWORD *)(a2 + 648) != a1)
      return;
    v7 = &OBJC_IVAR___VCMediaStream__oneToOneFeedbackController;
  }
  v8 = *(void **)(a2 + *v7);
  if (v8)
    v9 = Type == 0;
  else
    v9 = 0;
  if (v9 && (VCRateControlSetFeedbackControlInfo(v8, a3) & 1) == 0 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCMediaStreamFillMediaControlInfoCallback_cold_1();
  }
}

void VCMediaStreamProcessMediaControlInfoCallback(uint64_t a1, uint64_t a2, void *a3)
{
  int Type;
  void *v7;
  int *v8;
  uint64_t v9;
  _DWORD *v10;

  Type = VCMediaControlInfoGeneratorGetType(a1);
  v7 = (void *)objc_msgSend(*(id *)(a2 + 544), "objectAtIndexedSubscript:", 0);
  if (*(_QWORD *)(a2 + 640) == a1)
  {
    v8 = &OBJC_IVAR___VCMediaStream__feedbackController;
  }
  else
  {
    if (*(_QWORD *)(a2 + 648) != a1)
      return;
    v8 = &OBJC_IVAR___VCMediaStream__oneToOneFeedbackController;
  }
  v9 = *v8;
  v10 = *(_DWORD **)(a2 + v9);
  if (v10)
  {
    if (!Type
      && (VCRateControlProcessFeedbackControlInfo(*(_QWORD *)(a2 + v9), a3) & 1) == 0
      && (int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCMediaStreamProcessMediaControlInfoCallback_cold_3();
    }
    if ((VCRateControlProcessProbingControlInfo(v10, a3, Type == 0) & 1) == 0
      && (int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCMediaStreamProcessMediaControlInfoCallback_cold_2();
    }
    if ((RTPProcessMediaControlInfo(objc_msgSend(v7, "rtpHandle"), a3, Type == 0) & 0x80000000) != 0
      && (int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCMediaStreamProcessMediaControlInfoCallback_cold_1();
    }
  }
}

void sub_1D8DDFE70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  _Unwind_Resume(exception_object);
}

void sub_1D8DE1410(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  _Unwind_Resume(exception_object);
}

void sub_1D8DE22C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
  _Unwind_Resume(exception_object);
}

void VCMediaStream_CheckDecryptionTimeoutForMKMRecoveryAgainstTime(uint64_t a1, double a2, double a3)
{
  uint64_t v6;
  double v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  uint64_t v11;
  _QWORD block[5];
  uint8_t buf[4];
  uint64_t v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  double v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  double v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (a2 - *(double *)(a1 + 376) > 1.0)
  {
    v6 = _VCMediaStream_DefaultTransport(a1);
    v7 = a2 - *(double *)(a1 + 384);
    if (v7 > VCMediaStreamTransport_DecryptionMKMRecoveryInterval(v6))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v8 = VRTraceErrorLogLevelToCSTR();
        v9 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v11 = *(_QWORD *)(a1 + 384);
          *(_DWORD *)buf = 136316418;
          v14 = v8;
          v15 = 2080;
          v16 = "VCMediaStream_CheckDecryptionTimeoutForMKMRecoveryAgainstTime";
          v17 = 1024;
          v18 = 2246;
          v19 = 2048;
          v20 = a3;
          v21 = 2048;
          v22 = v11;
          v23 = 2048;
          v24 = a2;
          _os_log_error_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_ERROR, "VCMediaStream [%s] %s:%d DecryptionErrorStartTime:%f lastDecryptionMKMRecoveryTime:%f now:%f. Triggering MKM recovery", buf, 0x3Au);
        }
      }
      *(double *)(a1 + 376) = a2;
      *(double *)(a1 + 384) = a2;
      v10 = *(NSObject **)(a1 + 168);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = __VCMediaStream_CheckDecryptionTimeoutForMKMRecoveryAgainstTime_block_invoke;
      block[3] = &unk_1E9E521C0;
      block[4] = a1;
      dispatch_async(v10, block);
    }
  }
}

void VCMediaStream_CheckForDecryptionTimeout(uint64_t a1)
{
  uint64_t v2;
  double v3;
  uint64_t v4;
  NSObject *v5;
  int v6;
  uint64_t v7;
  __int16 v8;
  const char *v9;
  __int16 v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = _VCMediaStream_DefaultTransport(a1);
    if (VCMediaStreamTransport_DecryptionTimeoutInterval(v2) != 0.0)
    {
      v3 = micro();
      _VCMediaStream_CheckDecryptionTimeoutAgainstTime(a1, v3, *(double *)(a1 + 392));
      VCMediaStream_CheckDecryptionTimeoutForMKMRecoveryAgainstTime(a1, v3, *(double *)(a1 + 392));
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v6 = 136315650;
      v7 = v4;
      v8 = 2080;
      v9 = "VCMediaStream_CheckForDecryptionTimeout";
      v10 = 1024;
      v11 = 2262;
      _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, "VCMediaStream [%s] %s:%d media stream is nil", (uint8_t *)&v6, 0x1Cu);
    }
  }
}

void _VCMediaStream_CheckDecryptionTimeoutAgainstTime(uint64_t a1, double a2, double a3)
{
  uint64_t v6;
  double v7;
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  _QWORD block[5];
  uint8_t buf[4];
  uint64_t v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  double v20;
  __int16 v21;
  double v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v6 = _VCMediaStream_DefaultTransport(a1);
  v7 = VCMediaStreamTransport_DecryptionTimeoutInterval(v6);
  if (a2 - *(double *)(a1 + 328) > v7 && a2 - *(double *)(a1 + 376) > 1.0 && a2 - a3 > v7)
  {
    *(double *)(a1 + 376) = a2;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v9 = VRTraceErrorLogLevelToCSTR();
      v10 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136316162;
        v14 = v9;
        v15 = 2080;
        v16 = "_VCMediaStream_CheckDecryptionTimeoutAgainstTime";
        v17 = 1024;
        v18 = 2225;
        v19 = 2048;
        v20 = a3;
        v21 = 2048;
        v22 = a2;
        _os_log_error_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_ERROR, "VCMediaStream [%s] %s:%d DecryptionErrorStartTime:%f now:%f. Triggering decryption timeout", buf, 0x30u);
      }
    }
    v11 = *(NSObject **)(a1 + 168);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = ___VCMediaStream_CheckDecryptionTimeoutAgainstTime_block_invoke;
    block[3] = &unk_1E9E521C0;
    block[4] = a1;
    dispatch_async(v11, block);
  }
}

void *VCMediaStream_RTCPPacketsCallback(void *a1, const char *a2)
{
  if (a1)
    return (void *)objc_msgSend(a1, "notifyDelegateDidReceiveRTCPPackets:", a2);
  return a1;
}

uint64_t VCMediaStream_State(uint64_t result)
{
  if (result)
    return *(unsigned int *)(result + 408);
  return result;
}

uint64_t OUTLINED_FUNCTION_11_13@<X0>(uint64_t a1@<X8>)
{
  uint64_t v1;

  *(_QWORD *)(v1 - 40) = a1;
  return objc_opt_class();
}

uint64_t OUTLINED_FUNCTION_17_0()
{
  return objc_opt_class();
}

uint64_t OUTLINED_FUNCTION_21_0@<X0>(void *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  *(_QWORD *)(v2 - 40) = a2;
  return objc_msgSend(a1, "localAddress");
}

uint64_t OUTLINED_FUNCTION_23_0()
{
  void *v0;

  return objc_msgSend(v0, "remoteAddress");
}

CFArrayRef VCVideoHardwareDumpCollector_CreateHeadersFromCArray(const char **a1, CFIndex a2)
{
  CFIndex v2;
  const char **v3;
  const __CFAllocator *v4;
  CFMutableArrayRef Mutable;
  __CFArray *v6;
  CFStringRef v7;
  CFStringRef v8;
  CFArrayRef Copy;

  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCVideoHardwareDumpCollector_CreateHeadersFromCArray_cold_1();
    }
    return 0;
  }
  v2 = a2;
  v3 = a1;
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2, MEMORY[0x1E0C9B378]);
  if (!Mutable)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCVideoHardwareDumpCollector_CreateHeadersFromCArray_cold_2();
    }
    return 0;
  }
  v6 = Mutable;
  if (v2)
  {
    while (1)
    {
      v7 = CFStringCreateWithCString(v4, *v3, 0x8000100u);
      if (!v7)
        break;
      v8 = v7;
      CFArrayAppendValue(v6, v7);
      CFRelease(v8);
      ++v3;
      if (!--v2)
        goto LABEL_6;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCVideoHardwareDumpCollector_CreateHeadersFromCArray_cold_3();
    }
    Copy = 0;
  }
  else
  {
LABEL_6:
    Copy = CFArrayCreateCopy(v4, v6);
  }
  CFRelease(v6);
  return Copy;
}

void _VCVideoHardwareDumpCollector_DumpFrame(uint64_t a1, const __CFDictionary *a2, CFArrayRef theArray, const void *a4)
{
  unint64_t Count;
  const __CFAllocator *v9;
  __CFArray *Mutable;
  __CFArray *v11;
  CFIndex v12;
  unsigned int v13;
  const void *ValueAtIndex;
  const void *Value;
  CFStringRef v16;
  const __CFString *v18;

  Count = CFArrayGetCount(theArray);
  v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], Count + 1, MEMORY[0x1E0C9B378]);
  if (Mutable)
  {
    v11 = Mutable;
    CFArrayAppendValue(Mutable, a4);
    if (Count)
    {
      v12 = 0;
      v13 = 1;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(theArray, v12);
        Value = CFDictionaryGetValue(a2, ValueAtIndex);
        if (Value)
        {
          v16 = CFStringCreateWithFormat(v9, 0, CFSTR("%@"), Value);
          CFArrayAppendValue(v11, v16);
          if (v16)
            CFRelease(v16);
        }
        else
        {
          CFArrayAppendValue(v11, &stru_1E9E58EE0);
        }
        v12 = v13;
      }
      while (Count > v13++);
    }
    v18 = CFStringCreateByCombiningStrings(v9, v11, CFSTR(","));
    VCVideoHardwareDumpWriter_Write(*(_QWORD *)(a1 + 56), v18);
    if (v18)
      CFRelease(v18);
    CFRelease(v11);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCVideoHardwareDumpCollector_DumpFrame_cold_1();
  }
}

void VCVideoHardwareDumpCollector_RecordResizeForEncoder(uint64_t a1, int a2, uint64_t a3, int a4, int a5)
{
  __CFDictionary *v5;
  const __CFAllocator *v8;
  CFNumberRef v9;
  CFNumberRef v10;
  CFNumberRef v11;
  int valuePtr;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v5 = *(__CFDictionary **)(a1 + 8);
    if (v5)
    {
      valuePtr = a2;
      v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v9 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &valuePtr);
      CFDictionaryAddValue(v5, CFSTR("VideoHardwareTestDidResizeFrameForEncodingBuffer"), v9);
      CFRelease(v9);
      valuePtr = a4;
      v10 = CFNumberCreate(v8, kCFNumberIntType, &valuePtr);
      CFDictionaryAddValue(v5, CFSTR("VideoHardwareTestResizedFrameForEncodingBufferWidth"), v10);
      CFRelease(v10);
      valuePtr = a5;
      v11 = CFNumberCreate(v8, kCFNumberIntType, &valuePtr);
      CFDictionaryAddValue(v5, CFSTR("VideoHardwareTestResizedFrameForEncodingBufferHeight"), v11);
      CFRelease(v11);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCVideoHardwareDumpCollector_RecordResizeForEncoder_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCVideoHardwareDumpCollector_RecordResizeForEncoder_cold_1();
  }
}

void VCVideoHardwareDumpCollector_RecordEncoderBuffer(uint64_t a1, int a2, int a3, VTSessionRef session, int a5, int a6)
{
  __CFDictionary *v6;
  const __CFAllocator *v11;
  CFNumberRef v12;
  CFNumberRef v13;
  CFNumberRef v14;
  CFNumberRef v15;
  int valuePtr;
  const void *propertyValueOut[2];

  propertyValueOut[1] = *(const void **)MEMORY[0x1E0C80C00];
  if (a1)
  {
    v6 = *(__CFDictionary **)(a1 + 8);
    if (v6)
    {
      propertyValueOut[0] = 0;
      v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      VTSessionCopyProperty(session, (CFStringRef)*MEMORY[0x1E0CED848], (CFAllocatorRef)*MEMORY[0x1E0C9AE00], propertyValueOut);
      if (propertyValueOut[0])
      {
        CFDictionaryAddValue(v6, CFSTR("VideoHardwareTestScalingMode"), propertyValueOut[0]);
        if (propertyValueOut[0])
          CFRelease(propertyValueOut[0]);
      }
      valuePtr = a6;
      v12 = CFNumberCreate(v11, kCFNumberIntType, &valuePtr);
      CFDictionaryAddValue(v6, CFSTR("VideoHardwareTestRotationAngle"), v12);
      CFRelease(v12);
      valuePtr = a3;
      v13 = CFNumberCreate(v11, kCFNumberIntType, &valuePtr);
      CFDictionaryAddValue(v6, CFSTR("VideoHardwareTestDidResizeEncodingBuffer"), v13);
      CFRelease(v13);
      valuePtr = a5;
      v14 = CFNumberCreate(v11, kCFNumberIntType, &valuePtr);
      CFDictionaryAddValue(v6, CFSTR("VideoHardwareTestDidRotate"), v14);
      CFRelease(v14);
      valuePtr = a2;
      v15 = CFNumberCreate(v11, kCFNumberIntType, &valuePtr);
      CFDictionaryAddValue(v6, CFSTR("VideoHardwareTestFrameOrientation"), v15);
      CFRelease(v15);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCVideoHardwareDumpCollector_RecordEncoderBuffer_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCVideoHardwareDumpCollector_RecordEncoderBuffer_cold_1();
  }
}

void VCVideoHardwareDumpCollector_RecordEncodedFrame(uint64_t a1, uint64_t a2)
{
  __CFDictionary *v3;
  __CVBuffer *v5;
  const __CFAllocator *v6;
  CFNumberRef v7;
  CFNumberRef v8;
  double v9;
  double v10;
  double v11;
  float v12;
  CFNumberRef v13;
  float v14;
  CFNumberRef v15;
  float v16;
  CFNumberRef v17;
  float v18;
  CFNumberRef v19;
  float valuePtr;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v3 = *(__CFDictionary **)(a1 + 8);
    if (v3)
    {
      if (a2)
      {
        v5 = *(__CVBuffer **)(a2 + 88);
        LODWORD(valuePtr) = CVPixelBufferGetWidth(v5);
        v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        v7 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &valuePtr);
        CFDictionaryAddValue(v3, CFSTR("VideoHardwareTestEncodingBufferWidth"), v7);
        CFRelease(v7);
        LODWORD(valuePtr) = CVPixelBufferGetHeight(v5);
        v8 = CFNumberCreate(v6, kCFNumberIntType, &valuePtr);
        CFDictionaryAddValue(v3, CFSTR("VideoHardwareTestEncodingBufferHeight"), v8);
        CFRelease(v8);
        v9 = *(double *)(a2 + 256);
        v11 = *(double *)(a2 + 264);
        v10 = *(double *)(a2 + 272);
        v12 = *(double *)(a2 + 248);
        valuePtr = v12;
        v13 = CFNumberCreate(v6, kCFNumberFloat32Type, &valuePtr);
        CFDictionaryAddValue(v3, CFSTR("VideoHardwareTestVisibleRectX"), v13);
        CFRelease(v13);
        v14 = v9;
        valuePtr = v14;
        v15 = CFNumberCreate(v6, kCFNumberFloat32Type, &valuePtr);
        CFDictionaryAddValue(v3, CFSTR("VideoHardwareTestVisibleRectY"), v15);
        CFRelease(v15);
        v16 = v11;
        valuePtr = v16;
        v17 = CFNumberCreate(v6, kCFNumberFloat32Type, &valuePtr);
        CFDictionaryAddValue(v3, CFSTR("VideoHardwareTestVisibleRectWidth"), v17);
        CFRelease(v17);
        v18 = v10;
        valuePtr = v18;
        v19 = CFNumberCreate(v6, kCFNumberFloat32Type, &valuePtr);
        CFDictionaryAddValue(v3, CFSTR("VideoHardwareTestVisibleRectHeight"), v19);
        CFRelease(v19);
      }
      _VCVideoHardwareDumpCollector_DumpFrame(a1, v3, *(CFArrayRef *)(a1 + 32), CFSTR("ENCODE"));
      CFDictionaryRemoveAllValues(v3);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCVideoHardwareDumpCollector_RecordEncodedFrame_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCVideoHardwareDumpCollector_RecordEncodedFrame_cold_1();
  }
}

void VCVideoHardwareDumpCollector_RecordDecodedFrame(uint64_t a1, CVPixelBufferRef pixelBuffer, void *a3)
{
  __CFDictionary *v4;
  CFAllocatorRef *v7;
  const __CFAllocator *v8;
  CFNumberRef v9;
  CFNumberRef v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  const __CFAllocator *v18;
  CFNumberRef v19;
  float v20;
  CFNumberRef v21;
  float v22;
  CFNumberRef v23;
  float v24;
  CFNumberRef v25;
  float valuePtr;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v4 = *(__CFDictionary **)(a1 + 16);
    if (v4)
    {
      v7 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
      if (pixelBuffer)
      {
        LODWORD(valuePtr) = CVPixelBufferGetWidth(pixelBuffer);
        v8 = *v7;
        v9 = CFNumberCreate(*v7, kCFNumberIntType, &valuePtr);
        CFDictionaryAddValue(v4, CFSTR("VideoHardwareTestDecodedFrameWidth"), v9);
        CFRelease(v9);
        LODWORD(valuePtr) = CVPixelBufferGetHeight(pixelBuffer);
        v10 = CFNumberCreate(v8, kCFNumberIntType, &valuePtr);
        CFDictionaryAddValue(v4, CFSTR("VideoHardwareTestDecodedFrameHeight"), v10);
        CFRelease(v10);
      }
      if (a3)
      {
        objc_msgSend(a3, "contentsRect");
        v12 = v11;
        v14 = v13;
        v16 = v15;
        *(float *)&v17 = v17;
        valuePtr = *(float *)&v17;
        v18 = *v7;
        v19 = CFNumberCreate(*v7, kCFNumberFloat32Type, &valuePtr);
        CFDictionaryAddValue(v4, CFSTR("VideoHardwareTestContentsRectX"), v19);
        CFRelease(v19);
        v20 = v12;
        valuePtr = v20;
        v21 = CFNumberCreate(v18, kCFNumberFloat32Type, &valuePtr);
        CFDictionaryAddValue(v4, CFSTR("VideoHardwareTestContentsRectY"), v21);
        CFRelease(v21);
        v22 = v14;
        valuePtr = v22;
        v23 = CFNumberCreate(v18, kCFNumberFloat32Type, &valuePtr);
        CFDictionaryAddValue(v4, CFSTR("VideoHardwareTestContentsRectWidth"), v23);
        CFRelease(v23);
        v24 = v16;
        valuePtr = v24;
        v25 = CFNumberCreate(v18, kCFNumberFloat32Type, &valuePtr);
        CFDictionaryAddValue(v4, CFSTR("VideoHardwareTestContentsRectHeight"), v25);
        CFRelease(v25);
      }
      _VCVideoHardwareDumpCollector_DumpFrame(a1, v4, *(CFArrayRef *)(a1 + 40), CFSTR("DECODE"));
      CFDictionaryRemoveAllValues(v4);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCVideoHardwareDumpCollector_RecordDecodedFrame_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCVideoHardwareDumpCollector_RecordDecodedFrame_cold_1();
  }
}

void VCVideoHardwareDumpCollector_RecordActiveCaptureDevice(uint64_t a1, void *a2)
{
  __CFDictionary *v3;
  const __CFAllocator *v5;
  CFNumberRef v6;
  CFNumberRef v7;
  int valuePtr;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v3 = *(__CFDictionary **)(a1 + 24);
    if (v3)
    {
      valuePtr = objc_msgSend(a2, "isVideoBinned");
      v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v6 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &valuePtr);
      CFDictionaryAddValue(v3, CFSTR("VideoHardwareTestCaptureFormatIsBinned"), v6);
      CFRelease(v6);
      valuePtr = objc_msgSend(a2, "isVideoHDRSupported");
      v7 = CFNumberCreate(v5, kCFNumberIntType, &valuePtr);
      CFDictionaryAddValue(v3, CFSTR("VideoHardwareTestCaptureFormatIsHDR"), v7);
      CFRelease(v7);
      _VCVideoHardwareDumpCollector_DumpFrame(a1, v3, *(CFArrayRef *)(a1 + 48), CFSTR("CAPTURE"));
      CFDictionaryRemoveAllValues(v3);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCVideoHardwareDumpCollector_RecordActiveCaptureDevice_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCVideoHardwareDumpCollector_RecordActiveCaptureDevice_cold_1();
  }
}

void *Throttling_MediaQueue_Init(uint64_t a1)
{
  void *result;
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  double v6;
  int v7;
  uint64_t v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  int v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)a1 = 0;
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0x3F947AE147AE147BLL;
  *(_BYTE *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 52) = 28;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 64) = 0x3FF0000000000000;
  result = malloc_type_malloc(0x380uLL, 0x100004097079494uLL);
  *(_QWORD *)(a1 + 88) = result;
  if (result)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v3 = VRTraceErrorLogLevelToCSTR();
      v4 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v7 = 136315650;
        v8 = v3;
        v9 = 2080;
        v10 = "RealTimeStats_Init";
        v11 = 1024;
        v12 = 351;
        _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d  ------ MQ IN/OUT RealTime stats are ENABLED", (uint8_t *)&v7, 0x1Cu);
      }
    }
    v5 = *(_QWORD *)(a1 + 88);
    v6 = micro();
    *(_OWORD *)(v5 + 8) = 0u;
    *(_OWORD *)(v5 + 24) = 0u;
    *(_OWORD *)(v5 + 40) = 0u;
    *(_OWORD *)(v5 + 56) = 0u;
    *(_OWORD *)(v5 + 72) = 0u;
    *(_OWORD *)(v5 + 88) = 0u;
    *(_OWORD *)(v5 + 104) = 0u;
    *(_OWORD *)(v5 + 120) = 0u;
    *(_WORD *)(v5 + 144) = 0;
    *(double *)v5 = v6;
    *(double *)(v5 + 136) = v6;
    *(_QWORD *)(v5 + 148) = 0x100000000;
    *(_DWORD *)(v5 + 156) = 0;
    pthread_mutex_init((pthread_mutex_t *)(v5 + 160), 0);
    *(double *)(v5 + 224) = v6;
    v5 += 224;
    *(_OWORD *)(v5 + 8) = 0u;
    *(_OWORD *)(v5 + 24) = 0u;
    *(_OWORD *)(v5 + 40) = 0u;
    *(_OWORD *)(v5 + 56) = 0u;
    *(_OWORD *)(v5 + 72) = 0u;
    *(_OWORD *)(v5 + 88) = 0u;
    *(_OWORD *)(v5 + 104) = 0u;
    *(_OWORD *)(v5 + 120) = 0u;
    *(_DWORD *)(v5 + 148) = 0;
    *(_WORD *)(v5 + 144) = 0;
    *(double *)(v5 + 136) = v6;
    *(_QWORD *)(v5 + 152) = 0;
    pthread_mutex_init((pthread_mutex_t *)(v5 + 160), 0);
    *(_OWORD *)(v5 + 232) = 0u;
    *(_OWORD *)(v5 + 248) = 0u;
    *(_OWORD *)(v5 + 264) = 0u;
    *(_OWORD *)(v5 + 280) = 0u;
    *(_OWORD *)(v5 + 296) = 0u;
    *(_OWORD *)(v5 + 312) = 0u;
    *(_OWORD *)(v5 + 328) = 0u;
    *(_OWORD *)(v5 + 344) = 0u;
    *(_DWORD *)(v5 + 372) = 0;
    *(_WORD *)(v5 + 368) = 0;
    *(double *)(v5 + 224) = v6;
    *(double *)(v5 + 360) = v6;
    *(_QWORD *)(v5 + 376) = 1;
    pthread_mutex_init((pthread_mutex_t *)(v5 + 384), 0);
    *(_OWORD *)(v5 + 456) = 0u;
    *(_OWORD *)(v5 + 472) = 0u;
    *(_OWORD *)(v5 + 488) = 0u;
    *(_OWORD *)(v5 + 504) = 0u;
    *(_OWORD *)(v5 + 520) = 0u;
    *(_OWORD *)(v5 + 536) = 0u;
    *(_OWORD *)(v5 + 552) = 0u;
    *(_OWORD *)(v5 + 568) = 0u;
    *(_DWORD *)(v5 + 596) = 0;
    *(_WORD *)(v5 + 592) = 0;
    *(double *)(v5 + 448) = v6;
    *(double *)(v5 + 584) = v6;
    *(_QWORD *)(v5 + 600) = 0;
    return (void *)pthread_mutex_init((pthread_mutex_t *)(v5 + 608), 0);
  }
  return result;
}

void Throttling_MediaQueue_Uninit(uint64_t a1, pthread_mutex_t *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;

  pthread_mutex_lock(a2);
  v4 = *(_QWORD **)a1;
  if (*(_QWORD *)a1)
  {
    do
    {
      v5 = (_QWORD *)v4[196];
      VCMediaControlInfoDispose(v4[198]);
      free(v4);
      v4 = v5;
    }
    while (v5);
  }
  pthread_mutex_unlock(a2);
  *(_QWORD *)a1 = 0;
  v6 = *(_QWORD *)(a1 + 88);
  if (v6)
  {
    pthread_mutex_destroy((pthread_mutex_t *)(v6 + 160));
    pthread_mutex_destroy((pthread_mutex_t *)(v6 + 384));
    pthread_mutex_destroy((pthread_mutex_t *)(v6 + 608));
    pthread_mutex_destroy((pthread_mutex_t *)(v6 + 832));
    free(*(void **)(a1 + 88));
    *(_QWORD *)(a1 + 88) = 0;
  }
}

uint64_t Throttling_MediaQueue_AddPacket_ScheduleAndActiveProbing(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, double a5)
{
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  char v16;
  char v17;
  unsigned int v18;
  int v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  unsigned int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  NSObject *v31;
  NSObject *v32;
  int v33;
  unsigned int v34;
  unsigned int v35;
  int v36;
  int v37;
  double v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  NSObject *v46;
  BOOL v47;
  float v48;
  uint64_t v49;
  NSObject *v50;
  double v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  double v55;
  uint64_t v56;
  NSObject *v57;
  NSObject *v58;
  uint64_t v59;
  const char *v60;
  NSObject *v61;
  uint32_t v62;
  uint64_t v63;
  NSObject *v64;
  NSObject *v65;
  double v66;
  uint64_t v67;
  int active;
  double v69;
  int v70;
  uint64_t v71;
  NSObject *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  double v76;
  double v77;
  uint64_t *v78;
  uint64_t v79;
  int v80;
  BOOL v81;
  double v82;
  double v83;
  double v84;
  int *v85;
  double v86;
  uint64_t v87;
  NSObject *v88;
  NSObject *v89;
  int v90;
  uint64_t v91;
  uint64_t *v92;
  double v93;
  double v94;
  int v95;
  double v96;
  double v97;
  uint64_t v98;
  NSObject *v99;
  NSObject *v100;
  int v101;
  double v102;
  double v103;
  uint64_t v104;
  NSObject *v105;
  uint64_t v106;
  int v107;
  _BOOL4 v108;
  double v109;
  double v110;
  uint64_t v111;
  NSObject *v112;
  NSObject *v113;
  int v114;
  double v115;
  int v116;
  unint64_t v117;
  double v118;
  unsigned int v119;
  double v120;
  double v121;
  uint64_t v122;
  NSObject *v123;
  NSObject *v124;
  int v125;
  unsigned int v126;
  unsigned int v127;
  int v128;
  int v129;
  double v130;
  double v131;
  int v132;
  unsigned int v133;
  unsigned int v134;
  int v135;
  int v136;
  double v137;
  double v138;
  uint64_t v139;
  NSObject *v140;
  NSObject *v141;
  uint64_t v142;
  double v143;
  int v144;
  uint64_t v145;
  NSObject *v146;
  NSObject *v147;
  uint64_t v148;
  uint64_t v149;
  NSObject *v150;
  const char *v151;
  uint32_t v152;
  uint64_t v153;
  NSObject *v154;
  NSObject *v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  NSObject *v160;
  const char *v161;
  uint32_t v162;
  uint64_t v163;
  NSObject *v164;
  NSObject *v165;
  double v166;
  double v167;
  uint64_t v168;
  NSObject *v169;
  NSObject *v170;
  uint64_t v171;
  int v172;
  BOOL v173;
  int v174;
  int v175;
  _BOOL4 v176;
  uint64_t v177;
  NSObject *v178;
  uint64_t v179;
  unsigned int v180;
  int v181;
  double v182;
  uint64_t v183;
  NSObject *v184;
  NSObject *v185;
  int v186;
  int v187;
  uint64_t v188;
  uint64_t v189;
  double v190;
  int ErrorLogLevelForModule;
  uint64_t v192;
  NSObject *v193;
  NSObject *v194;
  const char *v195;
  int v196;
  int v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  NSObject *v201;
  uint64_t v202;
  NSObject *v203;
  NSObject *v204;
  int v205;
  unsigned int v206;
  unsigned int v207;
  int v208;
  int v209;
  double v210;
  double v211;
  int v212;
  uint64_t v213;
  NSObject *v214;
  NSObject *v215;
  int v216;
  unsigned int v217;
  unsigned int v218;
  int v219;
  int v220;
  double v221;
  double v222;
  int v223;
  uint64_t v224;
  int v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  int v229;
  uint64_t v230;
  uint64_t v231;
  NSObject *v232;
  NSObject *v233;
  const char *v234;
  NSObject *v235;
  uint32_t v236;
  double v237;
  uint64_t v238;
  uint64_t v239;
  int v241;
  unsigned int v242;
  unsigned int v243;
  int v244;
  int v245;
  double v246;
  int v247;
  double v248;
  double v249;
  int v250;
  int v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t *v254;
  uint8_t buf[4];
  uint64_t v256;
  __int16 v257;
  const char *v258;
  __int16 v259;
  int v260;
  __int16 v261;
  _BYTE v262[40];
  double v263;
  __int16 v264;
  _BYTE v265[20];
  __int16 v266;
  double v267;
  __int16 v268;
  _BOOL4 v269;
  __int16 v270;
  double v271;
  uint64_t v272;

  v9 = a1;
  v272 = *MEMORY[0x1E0C80C00];
  v253 = a4;
  *(double *)(a4 + 1608) = a5;
  v10 = *(_QWORD *)(a2 + 88);
  if (v10)
  {
    v11 = *(_DWORD *)a4 + *(_DWORD *)(a2 + 52);
    v12 = 224;
    if (!*(_DWORD *)(a4 + 1516))
      v12 = 0;
    v252 = v12;
    if (*(_DWORD *)(a4 + 1516))
      v13 = v10 + 224;
    else
      v13 = *(_QWORD *)(a2 + 88);
    v14 = *(_DWORD *)(v13 + 148);
    v15 = vcvtd_n_s64_f64(a5 - *(double *)(v13 + 136), 6uLL);
    if (v15)
    {
      if (v15 > 15)
      {
        v21 = a1;
        if (v15 > 0x1F)
        {
          v14 = 0;
          v18 = 0;
          *(_OWORD *)(v13 + 120) = 0u;
          *(_OWORD *)(v13 + 104) = 0u;
          *(_OWORD *)(v13 + 88) = 0u;
          *(_OWORD *)(v13 + 72) = 0u;
          *(_OWORD *)(v13 + 56) = 0u;
          *(_OWORD *)(v13 + 40) = 0u;
          *(_OWORD *)(v13 + 24) = 0u;
          *(_OWORD *)(v13 + 8) = 0u;
        }
        else
        {
          v23 = *(unsigned __int16 *)(v13 + 144);
          v250 = v23 + v15;
          v18 = (v23 + v15) & 0x1F;
          v24 = ((_BYTE)v23 + 1) & 0x1F;
          if (v18 >= v24)
          {
            v25 = (void *)(v13 + 4 * v24 + 8);
            v26 = (int)(v18 - v24 + 1);
          }
          else
          {
            v25 = (void *)(v13 + 8);
            bzero((void *)(v13 + 8 + 4 * (((_BYTE)v23 + 1) & 0x1F)), 128 - 4 * (((_BYTE)v23 + 1) & 0x1Fu));
            v26 = v18 + 1;
          }
          bzero(v25, 4 * v26);
          v27 = (v250 + 1) & 0x1F;
          if (v27 == (_DWORD)v24)
          {
            v14 = 0;
          }
          else
          {
            v14 = 0;
            do
            {
              v14 += *(_DWORD *)(v13 + 4 * v27 + 8);
              v27 = ((_BYTE)v27 + 1) & 0x1F;
            }
            while (v27 != (_DWORD)v24);
          }
        }
      }
      else
      {
        v16 = *(_WORD *)(v13 + 144);
        v17 = v16 + v15;
        v18 = v17 & 0x1F;
        v19 = (v17 + 1) & 0x1F;
        v20 = (v16 + 1) & 0x1F;
        v21 = a1;
        while (v20 != v19)
        {
          v22 = v13 + 4 * v20;
          v14 -= *(_DWORD *)(v22 + 8);
          *(_DWORD *)(v22 + 8) = 0;
          v20 = ((_BYTE)v20 + 1) & 0x1F;
        }
      }
    }
    else
    {
      v21 = a1;
      v18 = -1;
    }
    v28 = v14 + v11;
    pthread_mutex_lock((pthread_mutex_t *)(v13 + 160));
    *(_DWORD *)(v13 + 148) = v28;
    if (v18 != -1)
    {
      *(double *)(v13 + 136) = *(double *)(v10 + v252)
                             + (double)vcvtd_n_u64_f64(a5 - *(double *)(v10 + v252), 6uLL) * 0.015625;
      *(_WORD *)(v13 + 144) = v18;
    }
    pthread_mutex_unlock((pthread_mutex_t *)(v13 + 160));
    v29 = v13 + 4 * *(__int16 *)(v13 + 144);
    *(_DWORD *)(v29 + 8) += v11;
    v9 = v21;
  }
  if (_MergedGlobals && (int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v30 = VRTraceErrorLogLevelToCSTR();
    v31 = *MEMORY[0x1E0CF2758];
    v32 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
      {
        v33 = *(_DWORD *)(a4 + 1516);
        v34 = bswap32(*(_DWORD *)(a4 + 1508));
        v35 = bswap32(*(unsigned __int16 *)(a4 + 1506));
        v36 = *(_DWORD *)a4;
        v37 = *(unsigned __int8 *)(a4 + 1576);
        v38 = *(double *)a2;
        v39 = *(_DWORD *)(a2 + 32);
        *(_DWORD *)buf = 136317698;
        v256 = v30;
        v257 = 2080;
        v258 = "Throttling_MediaQueue_AddPacket_ScheduleAndActiveProbing";
        v259 = 1024;
        v260 = 1040;
        v261 = 2048;
        *(double *)v262 = a5;
        *(_WORD *)&v262[8] = 1024;
        *(_DWORD *)&v262[10] = v33;
        *(_WORD *)&v262[14] = 1024;
        *(_DWORD *)&v262[16] = v34;
        *(_WORD *)&v262[20] = 1024;
        *(_DWORD *)&v262[22] = HIWORD(v35);
        *(_WORD *)&v262[26] = 1024;
        *(_DWORD *)&v262[28] = v36;
        *(_WORD *)&v262[32] = 1024;
        *(_DWORD *)&v262[34] = v37;
        *(_WORD *)&v262[38] = 2048;
        v263 = v38;
        v264 = 1024;
        *(_DWORD *)v265 = v39;
        _os_log_impl(&dword_1D8A54000, v31, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d AddPacket: ^^^^^^ @%.3f MP %d  %d/%d/%d P: %d  pTWL: %p %d", buf, 0x54u);
      }
    }
    else if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
    {
      v241 = *(_DWORD *)(a4 + 1516);
      v242 = bswap32(*(_DWORD *)(a4 + 1508));
      v243 = bswap32(*(unsigned __int16 *)(a4 + 1506));
      v244 = *(_DWORD *)a4;
      v245 = *(unsigned __int8 *)(a4 + 1576);
      v246 = *(double *)a2;
      v247 = *(_DWORD *)(a2 + 32);
      *(_DWORD *)buf = 136317698;
      v256 = v30;
      v257 = 2080;
      v258 = "Throttling_MediaQueue_AddPacket_ScheduleAndActiveProbing";
      v259 = 1024;
      v260 = 1040;
      v261 = 2048;
      *(double *)v262 = a5;
      *(_WORD *)&v262[8] = 1024;
      *(_DWORD *)&v262[10] = v241;
      *(_WORD *)&v262[14] = 1024;
      *(_DWORD *)&v262[16] = v242;
      *(_WORD *)&v262[20] = 1024;
      *(_DWORD *)&v262[22] = HIWORD(v243);
      *(_WORD *)&v262[26] = 1024;
      *(_DWORD *)&v262[28] = v244;
      *(_WORD *)&v262[32] = 1024;
      *(_DWORD *)&v262[34] = v245;
      *(_WORD *)&v262[38] = 2048;
      v263 = v246;
      v264 = 1024;
      *(_DWORD *)v265 = v247;
      _os_log_debug_impl(&dword_1D8A54000, v31, OS_LOG_TYPE_DEBUG, " [%s] %s:%d AddPacket: ^^^^^^ @%.3f MP %d  %d/%d/%d P: %d  pTWL: %p %d", buf, 0x54u);
    }
  }
  if (!*(_DWORD *)(v253 + 1516))
  {
    v48 = *(float *)(v253 + 1616);
    if (v48 >= 0.0)
    {
      *(double *)(a2 + 24) = v48 + a5;
    }
    else
    {
      *(double *)(a2 + 24) = *(double *)(a2 + 40) + a5;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v49 = VRTraceErrorLogLevelToCSTR();
        v50 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v51 = *(float *)(v253 + 1616);
          v52 = *(_QWORD *)(a2 + 40);
          *(_DWORD *)buf = 136316162;
          v256 = v49;
          v257 = 2080;
          v258 = "Throttling_MediaQueue_AddPacket_ScheduleAndActiveProbing";
          v259 = 1024;
          v260 = 1057;
          v261 = 2048;
          *(double *)v262 = v51;
          *(_WORD *)&v262[8] = 2048;
          *(_QWORD *)&v262[10] = v52;
          _os_log_impl(&dword_1D8A54000, v50, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d  *#*#*#*#*#*#*#*# BAD AUD. pkt INTERVAL: %f (avg: %f) ", buf, 0x30u);
        }
      }
    }
    if (*(_BYTE *)(a2 + 8) && (int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v63 = VRTraceErrorLogLevelToCSTR();
      v64 = *MEMORY[0x1E0CF2758];
      v65 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
        {
          v66 = *(float *)(v253 + 1616);
          v67 = *(_QWORD *)(a2 + 40);
          *(_DWORD *)buf = 136316162;
          v256 = v63;
          v257 = 2080;
          v258 = "Throttling_MediaQueue_AddPacket_ScheduleAndActiveProbing";
          v259 = 1024;
          v260 = 1062;
          v261 = 2048;
          *(double *)v262 = v66;
          *(_WORD *)&v262[8] = 2048;
          *(_QWORD *)&v262[10] = v67;
          _os_log_impl(&dword_1D8A54000, v64, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d  AUD. pkt INTERVAL: %f (avg: %f) ", buf, 0x30u);
        }
      }
      else if (os_log_type_enabled(v65, OS_LOG_TYPE_DEBUG))
      {
        v237 = *(float *)(v253 + 1616);
        v238 = *(_QWORD *)(a2 + 40);
        *(_DWORD *)buf = 136316162;
        v256 = v63;
        v257 = 2080;
        v258 = "Throttling_MediaQueue_AddPacket_ScheduleAndActiveProbing";
        v259 = 1024;
        v260 = 1062;
        v261 = 2048;
        *(double *)v262 = v237;
        *(_WORD *)&v262[8] = 2048;
        *(_QWORD *)&v262[10] = v238;
        _os_log_debug_impl(&dword_1D8A54000, v64, OS_LOG_TYPE_DEBUG, " [%s] %s:%d  AUD. pkt INTERVAL: %f (avg: %f) ", buf, 0x30u);
      }
    }
  }
  v40 = v253;
  if (!*(_QWORD *)a2)
  {
    v44 = 0;
    v47 = *(_BYTE *)(v253 + 1596) == 0;
    goto LABEL_63;
  }
  if (*(_DWORD *)(v253 + 1516))
  {
    if (*(_BYTE *)(v253 + 1596))
    {
      v41 = *a3;
      v42 = a3;
      if (*a3)
      {
        do
        {
          v43 = v41;
          v41 = *(_QWORD *)(v41 + 1568);
        }
        while (v41);
        v42 = (uint64_t *)(v43 + 1568);
      }
      v254 = v42;
      v44 = ProcessThrottledPktsWithTime((double *)a2, &v254, 0, a5);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v45 = VRTraceErrorLogLevelToCSTR();
        v46 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315906;
          v256 = v45;
          v257 = 2080;
          v258 = "Throttling_MediaQueue_AddPacket_ScheduleAndActiveProbing";
          v259 = 1024;
          v260 = 1075;
          v261 = 1024;
          *(_DWORD *)v262 = v44;
          _os_log_impl(&dword_1D8A54000, v46, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Packet with a shouldScheduleQueuedPackets set. Empty throttling queue! iPktsAddedToPktListCount=%d", buf, 0x22u);
        }
      }
      v47 = 0;
      v40 = v253;
    }
    else
    {
      v44 = 0;
      v47 = 1;
    }
LABEL_63:
    active = ActiveProbing_ProcessIncomingPacket(v9, v40);
    v70 = active;
    if (!v47 && !active)
    {
      v70 = ActiveProbing_FlushPendingPackets(v9, &v253);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v71 = VRTraceErrorLogLevelToCSTR();
        v72 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315906;
          v256 = v71;
          v257 = 2080;
          v258 = "Throttling_MediaQueue_AddPacket_ScheduleAndActiveProbing";
          v259 = 1024;
          v260 = 1086;
          v261 = 1024;
          *(_DWORD *)v262 = v70;
          _os_log_impl(&dword_1D8A54000, v72, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Packet with a shouldScheduleQueuedPackets set. Empty waiting queue! iPktsCount=%d", buf, 0x22u);
        }
      }
    }
    if (v70 < 1)
      goto LABEL_272;
    v73 = *a3;
    if (*a3)
    {
      do
      {
        v74 = v73;
        v73 = *(_QWORD *)(v73 + 1568);
      }
      while (v73);
      a3 = (uint64_t *)(v74 + 1568);
    }
    v251 = v70;
    v75 = v253;
    v254 = a3;
    if (!*(_BYTE *)(a2 + 8))
    {
      if (!v253)
        goto LABEL_270;
      v79 = v253;
      do
      {
        while (*(_DWORD *)(v79 + 1516) != 1)
        {
          v79 = *(_QWORD *)(v79 + 1568);
          if (!v79)
            goto LABEL_270;
        }
        v80 = *(_DWORD *)(v79 + 1600);
        v79 = *(_QWORD *)(v79 + 1568);
        if (v79)
          v81 = v80 == 0;
        else
          v81 = 0;
      }
      while (v81);
      if (!v80)
      {
LABEL_270:
        *a3 = v253;
        v44 = v70;
        goto LABEL_271;
      }
    }
    if (*(_QWORD *)a2)
    {
      v44 = ProcessThrottledPktsWithTime((double *)a2, &v254, 0, a5);
      v76 = *(double *)a2;
      if (*(_QWORD *)a2)
      {
        do
        {
          v77 = v76;
          v76 = *(double *)(*(_QWORD *)&v76 + 1568);
        }
        while (v76 != 0.0);
        v78 = (uint64_t *)(*(_QWORD *)&v77 + 1568);
        if (!v75)
          goto LABEL_271;
LABEL_90:
        v82 = 8.0;
        v83 = 0.1;
        v84 = 1.0;
        while (1)
        {
          v85 = (int *)v75;
          if (!*(_BYTE *)(v75 + 1578) || *(_DWORD *)(v75 + 1516) != 1 || !*(_DWORD *)(v75 + 1600))
            goto LABEL_191;
          if (!*(_BYTE *)(a2 + 8))
          {
            v92 = (uint64_t *)(v75 + 1568);
            v75 = *(_QWORD *)(v75 + 1568);
            *((_QWORD *)v85 + 196) = 0;
LABEL_198:
            v173 = 1;
            *(_BYTE *)(a2 + 8) = 1;
            *(_QWORD *)(a2 + 16) = *((_QWORD *)v85 + 201);
            if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
            {
              v177 = VRTraceErrorLogLevelToCSTR();
              v178 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                v179 = *(_QWORD *)(a2 + 16);
                *(_DWORD *)buf = 136315906;
                v256 = v177;
                v257 = 2080;
                v258 = "SchedulePkt";
                v259 = 1024;
                v260 = 474;
                v261 = 2048;
                *(_QWORD *)v262 = v179;
                _os_log_impl(&dword_1D8A54000, v178, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d \t\t THROTTLING: disabled->enabled   dLastThrottledVideoPktTime init: %f ", buf, 0x26u);
              }
            }
LABEL_201:
            v176 = 0;
            goto LABEL_202;
          }
          v86 = *(double *)(a2 + 16);
          if (v86 >= a5)
            break;
          if (a5 - v86 > 0.0)
            *(double *)(a2 + 16) = a5;
          if ((int)VRTraceGetErrorLogLevelForModule() < 8)
            goto LABEL_117;
          v87 = VRTraceErrorLogLevelToCSTR();
          v88 = *MEMORY[0x1E0CF2758];
          v89 = *MEMORY[0x1E0CF2758];
          if (!*MEMORY[0x1E0CF2748])
          {
            if (os_log_type_enabled(v89, OS_LOG_TYPE_DEBUG))
            {
              v224 = *(_QWORD *)(a2 + 16);
              *(_DWORD *)buf = 136316674;
              v256 = v87;
              v257 = 2080;
              v258 = "CheckIfBoostNeeded";
              v259 = 1024;
              v260 = 329;
              v261 = 2048;
              *(double *)v262 = a5 - v86;
              *(_WORD *)&v262[8] = 2048;
              *(double *)&v262[10] = v86;
              *(_WORD *)&v262[18] = 2048;
              *(double *)&v262[20] = a5;
              *(_WORD *)&v262[28] = 2048;
              *(_QWORD *)&v262[30] = v224;
              _os_log_debug_impl(&dword_1D8A54000, v88, OS_LOG_TYPE_DEBUG, " [%s] %s:%d  VIDEO GAP: %f  last: %f  now: %.3f new: %f ", buf, 0x44u);
            }
            goto LABEL_117;
          }
          v90 = 0;
          if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
          {
            v91 = *(_QWORD *)(a2 + 16);
            *(_DWORD *)buf = 136316674;
            v256 = v87;
            v257 = 2080;
            v258 = "CheckIfBoostNeeded";
            v259 = 1024;
            v260 = 329;
            v261 = 2048;
            *(double *)v262 = a5 - v86;
            *(_WORD *)&v262[8] = 2048;
            *(double *)&v262[10] = v86;
            *(_WORD *)&v262[18] = 2048;
            *(double *)&v262[20] = a5;
            *(_WORD *)&v262[28] = 2048;
            *(_QWORD *)&v262[30] = v91;
            _os_log_impl(&dword_1D8A54000, v88, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d  VIDEO GAP: %f  last: %f  now: %.3f new: %f ", buf, 0x44u);
LABEL_117:
            v90 = 0;
          }
LABEL_177:
          if (*((_BYTE *)v85 + 1576) && *((_BYTE *)v85 + 1578))
          {
            v166 = *((double *)v85 + 201);
            if (v166 < v86)
              v166 = v86;
            v167 = a5 - v166;
            if (a5 - v166 > 0.0)
            {
              *(double *)(a2 + 16) = *(double *)(a2 + 16) - v167;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
              {
                v168 = VRTraceErrorLogLevelToCSTR();
                v169 = *MEMORY[0x1E0CF2758];
                v170 = *MEMORY[0x1E0CF2758];
                if (*MEMORY[0x1E0CF2748])
                {
                  if (os_log_type_enabled(v170, OS_LOG_TYPE_DEFAULT))
                  {
                    v171 = *(_QWORD *)(a2 + 16);
                    *(_DWORD *)buf = 136316162;
                    v256 = v168;
                    v257 = 2080;
                    v258 = "CheckIfBoostNeeded";
                    v259 = 1024;
                    v260 = 405;
                    v261 = 2048;
                    *(double *)v262 = v167;
                    *(_WORD *)&v262[8] = 2048;
                    *(_QWORD *)&v262[10] = v171;
                    _os_log_impl(&dword_1D8A54000, v169, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d  PROBESEQ comp: %f -> new: %f ", buf, 0x30u);
                  }
                }
                else if (os_log_type_enabled(v170, OS_LOG_TYPE_DEBUG))
                {
                  v226 = *(_QWORD *)(a2 + 16);
                  *(_DWORD *)buf = 136316162;
                  v256 = v168;
                  v257 = 2080;
                  v258 = "CheckIfBoostNeeded";
                  v259 = 1024;
                  v260 = 405;
                  v261 = 2048;
                  *(double *)v262 = v167;
                  *(_WORD *)&v262[8] = 2048;
                  *(_QWORD *)&v262[10] = v226;
                  _os_log_debug_impl(&dword_1D8A54000, v169, OS_LOG_TYPE_DEBUG, " [%s] %s:%d  PROBESEQ comp: %f -> new: %f ", buf, 0x30u);
                }
              }
            }
          }
          if (v90 >= 1)
          {
            if (!*(_QWORD *)a2)
            {
              v78 = (uint64_t *)a2;
              if (_MergedGlobals)
              {
                v78 = (uint64_t *)a2;
                if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
                {
                  v213 = VRTraceErrorLogLevelToCSTR();
                  v214 = *MEMORY[0x1E0CF2758];
                  v215 = *MEMORY[0x1E0CF2758];
                  if (*MEMORY[0x1E0CF2748])
                  {
                    v78 = (uint64_t *)a2;
                    if (os_log_type_enabled(v215, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 136315650;
                      v256 = v213;
                      v257 = 2080;
                      v258 = "ScheduleReleasedPkts";
                      v259 = 1024;
                      v260 = 792;
                      _os_log_impl(&dword_1D8A54000, v214, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d ScheduleReleasedPkts: Updating last pkt's in pThrottledPktsWaitingList == NULL", buf, 0x1Cu);
                      goto LABEL_250;
                    }
                  }
                  else
                  {
                    v78 = (uint64_t *)a2;
                    if (os_log_type_enabled(v215, OS_LOG_TYPE_DEBUG))
                    {
                      *(_DWORD *)buf = 136315650;
                      v256 = v213;
                      v257 = 2080;
                      v258 = "ScheduleReleasedPkts";
                      v259 = 1024;
                      v260 = 792;
                      _os_log_debug_impl(&dword_1D8A54000, v214, OS_LOG_TYPE_DEBUG, " [%s] %s:%d ScheduleReleasedPkts: Updating last pkt's in pThrottledPktsWaitingList == NULL", buf, 0x1Cu);
LABEL_250:
                      v78 = (uint64_t *)a2;
                    }
                  }
                }
              }
            }
            v44 = (v90 + v44);
          }
LABEL_191:
          v172 = *(unsigned __int8 *)(a2 + 8);
          v173 = *(_BYTE *)(a2 + 8) == 0;
          v174 = v85[379];
          v92 = (uint64_t *)(v85 + 392);
          v75 = *((_QWORD *)v85 + 196);
          *((_QWORD *)v85 + 196) = 0;
          if (v174 != 1)
          {
            v176 = 0;
            goto LABEL_224;
          }
          v175 = v85[400];
          if (v172)
          {
            if (v175)
            {
              if (*((_BYTE *)v85 + 1576))
              {
                v173 = 0;
                goto LABEL_201;
              }
              v173 = 0;
              *((_QWORD *)v85 + 201) = *(_QWORD *)(a2 + 16);
              v176 = 1;
LABEL_202:
              LODWORD(v69) = v85[400];
              v180 = (*(double *)(a2 + 64) * (double)*(unint64_t *)&v69);
              v181 = *(_DWORD *)(a2 + 52) + *v85;
              v85[400] = v180;
              v69 = (double)v180;
              v182 = (double)v181 * v82 / (double)v180;
              *(double *)(a2 + 16) = *(double *)(a2 + 16) + v182;
              if (_MergedGlobals && (int)VRTraceGetErrorLogLevelForModule() >= 8)
              {
                v183 = VRTraceErrorLogLevelToCSTR();
                v184 = *MEMORY[0x1E0CF2758];
                v185 = *MEMORY[0x1E0CF2758];
                if (*MEMORY[0x1E0CF2748])
                {
                  if (os_log_type_enabled(v185, OS_LOG_TYPE_DEFAULT))
                  {
                    v186 = *v85;
                    v187 = v85[400];
                    v188 = *((_QWORD *)v85 + 201);
                    v189 = *(_QWORD *)(a2 + 16);
                    *(_DWORD *)buf = 136316930;
                    v256 = v183;
                    v257 = 2080;
                    v258 = "SchedulePkt";
                    v259 = 1024;
                    v260 = 542;
                    v261 = 1024;
                    *(_DWORD *)v262 = v186;
                    *(_WORD *)&v262[4] = 1024;
                    *(_DWORD *)&v262[6] = v187;
                    *(_WORD *)&v262[10] = 2048;
                    *(double *)&v262[12] = v182;
                    *(_WORD *)&v262[20] = 2048;
                    *(_QWORD *)&v262[22] = v188;
                    *(_WORD *)&v262[30] = 2048;
                    *(_QWORD *)&v262[32] = v189;
                    _os_log_impl(&dword_1D8A54000, v184, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d \t\t SCHEDULING: len/rate: %d/%d  take: %f  me: %f  next: %f ", buf, 0x46u);
                  }
                }
                else if (os_log_type_enabled(v185, OS_LOG_TYPE_DEBUG))
                {
                  v196 = *v85;
                  v197 = v85[400];
                  v198 = *((_QWORD *)v85 + 201);
                  v199 = *(_QWORD *)(a2 + 16);
                  *(_DWORD *)buf = 136316930;
                  v256 = v183;
                  v257 = 2080;
                  v258 = "SchedulePkt";
                  v259 = 1024;
                  v260 = 542;
                  v261 = 1024;
                  *(_DWORD *)v262 = v196;
                  *(_WORD *)&v262[4] = 1024;
                  *(_DWORD *)&v262[6] = v197;
                  *(_WORD *)&v262[10] = 2048;
                  *(double *)&v262[12] = v182;
                  *(_WORD *)&v262[20] = 2048;
                  *(_QWORD *)&v262[22] = v198;
                  *(_WORD *)&v262[30] = 2048;
                  *(_QWORD *)&v262[32] = v199;
                  _os_log_debug_impl(&dword_1D8A54000, v184, OS_LOG_TYPE_DEBUG, " [%s] %s:%d \t\t SCHEDULING: len/rate: %d/%d  take: %f  me: %f  next: %f ", buf, 0x46u);
                }
              }
              goto LABEL_220;
            }
            v190 = *(double *)a2;
            *(_BYTE *)(a2 + 8) = 0;
            ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
            if (v190 == 0.0)
            {
              if (ErrorLogLevelForModule >= 5)
              {
                v200 = VRTraceErrorLogLevelToCSTR();
                v201 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 136315650;
                  v256 = v200;
                  v257 = 2080;
                  v258 = "SchedulePkt";
                  v259 = 1024;
                  v260 = 489;
                  v194 = v201;
                  v195 = " [%s] %s:%d \t\t THROTTLING: enabled->disabled  EMPTY THROT QUEUE -> DISABLED";
LABEL_218:
                  _os_log_impl(&dword_1D8A54000, v194, OS_LOG_TYPE_DEFAULT, v195, buf, 0x1Cu);
                }
              }
            }
            else if (ErrorLogLevelForModule >= 5)
            {
              v192 = VRTraceErrorLogLevelToCSTR();
              v193 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315650;
                v256 = v192;
                v257 = 2080;
                v258 = "SchedulePkt";
                v259 = 1024;
                v260 = 510;
                v194 = v193;
                v195 = " [%s] %s:%d \t\t THROTTLING: enabled->disabled  EDGE ... signalling the caller to FLUSH pending pkts in queue";
                goto LABEL_218;
              }
            }
            v173 = 0;
            v176 = 0;
            goto LABEL_220;
          }
          if (v175)
            goto LABEL_198;
          v176 = 0;
          v173 = 1;
LABEL_220:
          if (*((_BYTE *)v85 + 1576))
            *(double *)(a2 + 80) = a5;
          if (v176)
          {
            v69 = *(double *)(a2 + 24);
            v176 = *((double *)v85 + 201) > v69;
          }
LABEL_224:
          if (!_MergedGlobals || (int)VRTraceGetErrorLogLevelForModule() < 8)
          {
LABEL_234:
            if (!v173)
              goto LABEL_235;
            goto LABEL_238;
          }
          v202 = VRTraceErrorLogLevelToCSTR();
          v203 = *MEMORY[0x1E0CF2758];
          v204 = *MEMORY[0x1E0CF2758];
          if (*MEMORY[0x1E0CF2748])
          {
            if (!os_log_type_enabled(v204, OS_LOG_TYPE_DEFAULT))
              goto LABEL_234;
            v205 = v85[379];
            v206 = bswap32(v85[377]);
            v207 = bswap32(*((unsigned __int16 *)v85 + 753)) >> 16;
            v208 = *v85;
            v209 = v85[400];
            v210 = *((double *)v85 + 201);
            v211 = *(double *)(a2 + 24);
            if (v210 <= v211)
              v212 = 78;
            else
              v212 = 87;
            *(_DWORD *)buf = 136318210;
            v256 = v202;
            v257 = 2080;
            v258 = "SchedulePkt";
            v259 = 1024;
            v260 = 563;
            v261 = 1024;
            *(_DWORD *)v262 = v205;
            *(_WORD *)&v262[4] = 1024;
            *(_DWORD *)&v262[6] = v206;
            *(_WORD *)&v262[10] = 1024;
            *(_DWORD *)&v262[12] = v207;
            *(_WORD *)&v262[16] = 1024;
            *(_DWORD *)&v262[18] = v208;
            *(_WORD *)&v262[22] = 1024;
            *(_DWORD *)&v262[24] = v209;
            *(_WORD *)&v262[28] = 2048;
            *(double *)&v262[30] = v210;
            *(_WORD *)&v262[38] = 2048;
            v263 = a5;
            v264 = 2048;
            *(double *)v265 = v211;
            *(_WORD *)&v265[8] = 1024;
            *(_DWORD *)&v265[10] = v176;
            *(_WORD *)&v265[14] = 1024;
            *(_DWORD *)&v265[16] = v212;
            _os_log_impl(&dword_1D8A54000, v203, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d  SchedulePkt: %d  %d/%d/%d rate: %d  sched: %f now: %f aud: %f  b: %d mode: %c ", buf, 0x64u);
            if (!v173)
              goto LABEL_235;
          }
          else
          {
            if (!os_log_type_enabled(v204, OS_LOG_TYPE_DEBUG))
              goto LABEL_234;
            v216 = v85[379];
            v217 = bswap32(v85[377]);
            v218 = bswap32(*((unsigned __int16 *)v85 + 753)) >> 16;
            v219 = *v85;
            v220 = v85[400];
            v221 = *((double *)v85 + 201);
            v222 = *(double *)(a2 + 24);
            if (v221 <= v222)
              v223 = 78;
            else
              v223 = 87;
            *(_DWORD *)buf = 136318210;
            v256 = v202;
            v257 = 2080;
            v258 = "SchedulePkt";
            v259 = 1024;
            v260 = 563;
            v261 = 1024;
            *(_DWORD *)v262 = v216;
            *(_WORD *)&v262[4] = 1024;
            *(_DWORD *)&v262[6] = v217;
            *(_WORD *)&v262[10] = 1024;
            *(_DWORD *)&v262[12] = v218;
            *(_WORD *)&v262[16] = 1024;
            *(_DWORD *)&v262[18] = v219;
            *(_WORD *)&v262[22] = 1024;
            *(_DWORD *)&v262[24] = v220;
            *(_WORD *)&v262[28] = 2048;
            *(double *)&v262[30] = v221;
            *(_WORD *)&v262[38] = 2048;
            v263 = a5;
            v264 = 2048;
            *(double *)v265 = v222;
            *(_WORD *)&v265[8] = 1024;
            *(_DWORD *)&v265[10] = v176;
            *(_WORD *)&v265[14] = 1024;
            *(_DWORD *)&v265[16] = v223;
            _os_log_debug_impl(&dword_1D8A54000, v203, OS_LOG_TYPE_DEBUG, " [%s] %s:%d  SchedulePkt: %d  %d/%d/%d rate: %d  sched: %f now: %f aud: %f  b: %d mode: %c ", buf, 0x64u);
            if (!v173)
            {
LABEL_235:
              if (!*(_BYTE *)(a2 + 8) && *(_QWORD *)a2)
                v44 = ProcessThrottledPktsWithTime((double *)a2, &v254, 0, *(double *)(a2 + 16))
                    + v44;
            }
          }
LABEL_238:
          if (v176)
          {
            *v78 = (uint64_t)v85;
            ++*(_DWORD *)(a2 + 32);
          }
          else
          {
            *v254 = (uint64_t)v85;
            v254 = v92;
            v44 = (v44 + 1);
            if (v85[379] == 1)
            {
              *(_DWORD *)(a2 + 72) = *(_DWORD *)(a2 + 52) + *v85;
              *(_DWORD *)(a2 + 76) = v85[400];
            }
            v92 = v78;
          }
          v78 = v92;
          if (!v75)
            goto LABEL_271;
        }
        v93 = v86 - a5 + v86 - a5;
        if (v93 <= v84)
        {
          v90 = 0;
          *(_QWORD *)(a2 + 64) = 0x3FF0000000000000;
          goto LABEL_157;
        }
        v94 = *(double *)(a2 + 16);
        if (*(_QWORD *)a2)
          v94 = *(double *)(*(_QWORD *)a2 + 1608);
        v249 = *(double *)(a2 + 64);
        v95 = *(_DWORD *)(a2 + 72);
        LODWORD(v69) = *(_DWORD *)(a2 + 76);
        v96 = (double)v95 * v82 / (double)*(unint64_t *)&v69;
        if (v94 - v96 <= a5)
          v97 = v94 - v96;
        else
          v97 = a5;
        if (a5 - v97 <= 0.0 && (int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          v98 = VRTraceErrorLogLevelToCSTR();
          v99 = *MEMORY[0x1E0CF2758];
          v100 = *MEMORY[0x1E0CF2758];
          if (*MEMORY[0x1E0CF2748])
          {
            if (os_log_type_enabled(v100, OS_LOG_TYPE_DEFAULT))
            {
              v101 = *(_DWORD *)(a2 + 76);
              *(_DWORD *)buf = 136317442;
              v256 = v98;
              v257 = 2080;
              v258 = "CalcBoostIncrease";
              v259 = 1024;
              v260 = 260;
              v261 = 2048;
              *(double *)v262 = a5 - v97;
              *(_WORD *)&v262[8] = 2048;
              *(double *)&v262[10] = a5;
              *(_WORD *)&v262[18] = 2048;
              *(double *)&v262[20] = v97;
              *(_WORD *)&v262[28] = 2048;
              *(double *)&v262[30] = v94;
              *(_WORD *)&v262[38] = 2048;
              v263 = v96;
              v264 = 1024;
              *(_DWORD *)v265 = v95;
              *(_WORD *)&v265[4] = 1024;
              *(_DWORD *)&v265[6] = v101;
              _os_log_impl(&dword_1D8A54000, v99, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d  dSinceLastPktIssue %f  dNow %f    dBaseTime %f = dFirstPktScheduleTime %f - dDeliveryEstimate %f (%d %d)", buf, 0x5Au);
            }
          }
          else if (os_log_type_enabled(v100, OS_LOG_TYPE_DEBUG))
          {
            v229 = *(_DWORD *)(a2 + 76);
            *(_DWORD *)buf = 136317442;
            v256 = v98;
            v257 = 2080;
            v258 = "CalcBoostIncrease";
            v259 = 1024;
            v260 = 260;
            v261 = 2048;
            *(double *)v262 = a5 - v97;
            *(_WORD *)&v262[8] = 2048;
            *(double *)&v262[10] = a5;
            *(_WORD *)&v262[18] = 2048;
            *(double *)&v262[20] = v97;
            *(_WORD *)&v262[28] = 2048;
            *(double *)&v262[30] = v94;
            *(_WORD *)&v262[38] = 2048;
            v263 = v96;
            v264 = 1024;
            *(_DWORD *)v265 = v95;
            *(_WORD *)&v265[4] = 1024;
            *(_DWORD *)&v265[6] = v229;
            _os_log_debug_impl(&dword_1D8A54000, v99, OS_LOG_TYPE_DEBUG, " [%s] %s:%d  dSinceLastPktIssue %f  dNow %f    dBaseTime %f = dFirstPktScheduleTime %f - dDeliveryEstimate %f (%d %d)", buf, 0x5Au);
          }
        }
        v248 = v83;
        v102 = v93 * v83 + 1.0;
        v103 = (*(double *)(a2 + 16) - v97) / (a5 - v97 + 0.5);
        if (v103 <= 0.0)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
          {
            v104 = VRTraceErrorLogLevelToCSTR();
            v105 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              v106 = *(_QWORD *)(a2 + 16);
              v107 = *(_DWORD *)(a2 + 76);
              v108 = *(_QWORD *)a2 != 0;
              *(_DWORD *)buf = 136318466;
              v256 = v104;
              v257 = 2080;
              v258 = "CalcBoostIncrease";
              v259 = 1024;
              v260 = 281;
              v261 = 2048;
              *(double *)v262 = v103;
              *(_WORD *)&v262[8] = 2048;
              *(double *)&v262[10] = v102;
              *(_WORD *)&v262[18] = 2048;
              *(_QWORD *)&v262[20] = v106;
              *(_WORD *)&v262[28] = 2048;
              *(double *)&v262[30] = v97;
              *(_WORD *)&v262[38] = 2048;
              v263 = a5 - v97;
              v264 = 1024;
              *(_DWORD *)v265 = v95;
              *(_WORD *)&v265[4] = 1024;
              *(_DWORD *)&v265[6] = v107;
              *(_WORD *)&v265[10] = 2048;
              *(double *)&v265[12] = v96;
              v266 = 2048;
              v267 = v94;
              v268 = 1024;
              v269 = v108;
              v270 = 2048;
              v271 = a5;
              _os_log_impl(&dword_1D8A54000, v105, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d UNEXPECTED!!! CalcBoostIncrease:  SCHEME2: %f  SCHEME1: %f  last: %f base: %f, %f %d %d %f %f %d %f ", buf, 0x7Eu);
            }
          }
          v84 = 1.0;
          v103 = v102 + 1.0;
        }
        else
        {
          v84 = 1.0;
        }
        if (v102 > v103)
          v109 = v103;
        else
          v109 = v102;
        *(double *)(a2 + 64) = v109;
        v110 = v109 / v249;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          v111 = VRTraceErrorLogLevelToCSTR();
          v112 = *MEMORY[0x1E0CF2758];
          v113 = *MEMORY[0x1E0CF2758];
          if (*MEMORY[0x1E0CF2748])
          {
            if (os_log_type_enabled(v113, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136316674;
              if (v102 <= v103)
                v114 = 1;
              else
                v114 = 2;
              v256 = v111;
              v257 = 2080;
              v258 = "CalcBoostIncrease";
              v259 = 1024;
              v260 = 291;
              v261 = 1024;
              *(_DWORD *)v262 = v114;
              *(_WORD *)&v262[4] = 2048;
              *(double *)&v262[6] = v102;
              *(_WORD *)&v262[14] = 2048;
              *(double *)&v262[16] = v103;
              *(_WORD *)&v262[24] = 2048;
              *(double *)&v262[26] = v110;
              _os_log_impl(&dword_1D8A54000, v112, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d  SCHEME %d:   %f   %f    (INC %f)", buf, 0x40u);
            }
          }
          else if (os_log_type_enabled(v113, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136316674;
            if (v102 <= v103)
              v225 = 1;
            else
              v225 = 2;
            v256 = v111;
            v257 = 2080;
            v258 = "CalcBoostIncrease";
            v259 = 1024;
            v260 = 291;
            v261 = 1024;
            *(_DWORD *)v262 = v225;
            *(_WORD *)&v262[4] = 2048;
            *(double *)&v262[6] = v102;
            *(_WORD *)&v262[14] = 2048;
            *(double *)&v262[16] = v103;
            *(_WORD *)&v262[24] = 2048;
            *(double *)&v262[26] = v110;
            _os_log_debug_impl(&dword_1D8A54000, v112, OS_LOG_TYPE_DEBUG, " [%s] %s:%d  SCHEME %d:   %f   %f    (INC %f)", buf, 0x40u);
          }
        }
        if (v110 <= v84)
          goto LABEL_155;
        v115 = *(double *)a2;
        if (!*(_QWORD *)a2)
          goto LABEL_155;
        v116 = 0;
        *(double *)&v117 = v110 + -1.0;
        v118 = v110 / (v110 + -1.0);
        LODWORD(v117) = *(_DWORD *)(a2 + 76);
        v119 = (v118 * (double)v117);
        v120 = (double)*(int *)(a2 + 72) * -8.0 / (double)v119;
        v121 = v120;
        do
        {
          *(double *)(*(_QWORD *)&v115 + 1608) = v120 + *(double *)(*(_QWORD *)&v115 + 1608);
          if (_MergedGlobals && (int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            v122 = VRTraceErrorLogLevelToCSTR();
            v123 = *MEMORY[0x1E0CF2758];
            v124 = *MEMORY[0x1E0CF2758];
            if (*MEMORY[0x1E0CF2748])
            {
              if (os_log_type_enabled(v124, OS_LOG_TYPE_DEFAULT))
              {
                v125 = *(_DWORD *)(*(_QWORD *)&v115 + 1516);
                v126 = bswap32(*(_DWORD *)(*(_QWORD *)&v115 + 1508));
                v127 = bswap32(*(unsigned __int16 *)(*(_QWORD *)&v115 + 1506)) >> 16;
                v128 = **(_DWORD **)&v115;
                v129 = *(unsigned __int8 *)(*(_QWORD *)&v115 + 1576);
                v130 = *(double *)(*(_QWORD *)&v115 + 1608);
                *(_DWORD *)buf = 136318210;
                v256 = v122;
                v257 = 2080;
                v258 = "AccelerateThrottlingQueue";
                v259 = 1024;
                v260 = 197;
                v261 = 1024;
                *(_DWORD *)v262 = v125;
                *(_WORD *)&v262[4] = 1024;
                *(_DWORD *)&v262[6] = v126;
                *(_WORD *)&v262[10] = 1024;
                *(_DWORD *)&v262[12] = v127;
                *(_WORD *)&v262[16] = 1024;
                *(_DWORD *)&v262[18] = v128;
                *(_WORD *)&v262[22] = 1024;
                *(_DWORD *)&v262[24] = v129;
                *(_WORD *)&v262[28] = 2048;
                *(double *)&v262[30] = v120;
                *(_WORD *)&v262[38] = 2048;
                v263 = v121;
                v264 = 1024;
                *(_DWORD *)v265 = v119;
                *(_WORD *)&v265[4] = 2048;
                *(double *)&v265[6] = v130;
                *(_WORD *)&v265[14] = 1024;
                *(_DWORD *)&v265[16] = v130 <= a5;
                _os_log_impl(&dword_1D8A54000, v123, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d  Accelerating: ^^^^^^ MP %d  %d/%d/%d P: %d  by %.3fs (%.5f %d) to %.3f b: %d ", buf, 0x64u);
              }
            }
            else if (os_log_type_enabled(v124, OS_LOG_TYPE_DEBUG))
            {
              v132 = *(_DWORD *)(*(_QWORD *)&v115 + 1516);
              v133 = bswap32(*(_DWORD *)(*(_QWORD *)&v115 + 1508));
              v134 = bswap32(*(unsigned __int16 *)(*(_QWORD *)&v115 + 1506)) >> 16;
              v135 = **(_DWORD **)&v115;
              v136 = *(unsigned __int8 *)(*(_QWORD *)&v115 + 1576);
              v137 = *(double *)(*(_QWORD *)&v115 + 1608);
              *(_DWORD *)buf = 136318210;
              v256 = v122;
              v257 = 2080;
              v258 = "AccelerateThrottlingQueue";
              v259 = 1024;
              v260 = 197;
              v261 = 1024;
              *(_DWORD *)v262 = v132;
              *(_WORD *)&v262[4] = 1024;
              *(_DWORD *)&v262[6] = v133;
              *(_WORD *)&v262[10] = 1024;
              *(_DWORD *)&v262[12] = v134;
              *(_WORD *)&v262[16] = 1024;
              *(_DWORD *)&v262[18] = v135;
              *(_WORD *)&v262[22] = 1024;
              *(_DWORD *)&v262[24] = v136;
              *(_WORD *)&v262[28] = 2048;
              *(double *)&v262[30] = v120;
              *(_WORD *)&v262[38] = 2048;
              v263 = v121;
              v264 = 1024;
              *(_DWORD *)v265 = v119;
              *(_WORD *)&v265[4] = 2048;
              *(double *)&v265[6] = v137;
              *(_WORD *)&v265[14] = 1024;
              *(_DWORD *)&v265[16] = v137 <= a5;
              _os_log_debug_impl(&dword_1D8A54000, v123, OS_LOG_TYPE_DEBUG, " [%s] %s:%d  Accelerating: ^^^^^^ MP %d  %d/%d/%d P: %d  by %.3fs (%.5f %d) to %.3f b: %d ", buf, 0x64u);
            }
          }
          v131 = *(double *)(*(_QWORD *)&v115 + 1608);
          if (v131 <= a5)
            ++v116;
          LODWORD(v131) = *(_DWORD *)(*(_QWORD *)&v115 + 1600);
          v119 = (v118 * (double)*(unint64_t *)&v131);
          v121 = (double)(*(_DWORD *)(a2 + 52) + **(_DWORD **)&v115) * -8.0 / (double)v119;
          v120 = v120 + v121;
          v115 = *(double *)(*(_QWORD *)&v115 + 1568);
        }
        while (v115 != 0.0);
        v138 = *(double *)(a2 + 16);
        *(double *)(a2 + 16) = v120 + v138;
        if (_MergedGlobals && (int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          v139 = VRTraceErrorLogLevelToCSTR();
          v140 = *MEMORY[0x1E0CF2758];
          v141 = *MEMORY[0x1E0CF2758];
          if (*MEMORY[0x1E0CF2748])
          {
            if (os_log_type_enabled(v141, OS_LOG_TYPE_DEFAULT))
            {
              v142 = *(_QWORD *)(a2 + 16);
              *(_DWORD *)buf = 136316674;
              v256 = v139;
              v257 = 2080;
              v258 = "AccelerateThrottlingQueue";
              v259 = 1024;
              v260 = 218;
              v261 = 2048;
              *(double *)v262 = v120;
              *(_WORD *)&v262[8] = 2048;
              *(double *)&v262[10] = v138;
              *(_WORD *)&v262[18] = 2048;
              *(_QWORD *)&v262[20] = v142;
              *(_WORD *)&v262[28] = 1024;
              *(_DWORD *)&v262[30] = v116;
              _os_log_impl(&dword_1D8A54000, v140, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d AccelerateThrottlingQueue: %.3f from %.3f to %.3f (%d pkts) ", buf, 0x40u);
              if (!v116)
              {
LABEL_155:
                v90 = 0;
LABEL_156:
                v82 = 8.0;
                v83 = v248;
LABEL_157:
                v143 = *(double *)(a2 + 16);
                v144 = VRTraceGetErrorLogLevelForModule();
                if (v143 == v86)
                {
                  if (v144 < 8)
                    goto LABEL_170;
                  v145 = VRTraceErrorLogLevelToCSTR();
                  v146 = *MEMORY[0x1E0CF2758];
                  v147 = *MEMORY[0x1E0CF2758];
                  if (*MEMORY[0x1E0CF2748])
                  {
                    if (os_log_type_enabled(v147, OS_LOG_TYPE_DEFAULT))
                    {
                      v148 = *(_QWORD *)(a2 + 16);
                      v149 = *(_QWORD *)(a2 + 64);
                      *(_DWORD *)buf = 136316418;
                      v256 = v145;
                      v257 = 2080;
                      v258 = "CheckIfBoostNeeded";
                      v259 = 1024;
                      v260 = 370;
                      v261 = 2048;
                      *(double *)v262 = a5;
                      *(_WORD *)&v262[8] = 2048;
                      *(_QWORD *)&v262[10] = v148;
                      *(_WORD *)&v262[18] = 2048;
                      *(_QWORD *)&v262[20] = v149;
                      v150 = v146;
                      v151 = " [%s] %s:%d  TOO FAST: now: %.3f last: %f factor: %.3f ";
                      v152 = 58;
LABEL_166:
                      _os_log_impl(&dword_1D8A54000, v150, OS_LOG_TYPE_DEFAULT, v151, buf, v152);
                      goto LABEL_170;
                    }
                    goto LABEL_170;
                  }
                  if (!os_log_type_enabled(v147, OS_LOG_TYPE_DEBUG))
                    goto LABEL_170;
                  v158 = *(_QWORD *)(a2 + 16);
                  v159 = *(_QWORD *)(a2 + 64);
                  *(_DWORD *)buf = 136316418;
                  v256 = v145;
                  v257 = 2080;
                  v258 = "CheckIfBoostNeeded";
                  v259 = 1024;
                  v260 = 370;
                  v261 = 2048;
                  *(double *)v262 = a5;
                  *(_WORD *)&v262[8] = 2048;
                  *(_QWORD *)&v262[10] = v158;
                  *(_WORD *)&v262[18] = 2048;
                  *(_QWORD *)&v262[20] = v159;
                  v160 = v146;
                  v161 = " [%s] %s:%d  TOO FAST: now: %.3f last: %f factor: %.3f ";
                  v162 = 58;
                }
                else
                {
                  if (v144 < 8)
                    goto LABEL_170;
                  v153 = VRTraceErrorLogLevelToCSTR();
                  v154 = *MEMORY[0x1E0CF2758];
                  v155 = *MEMORY[0x1E0CF2758];
                  if (*MEMORY[0x1E0CF2748])
                  {
                    if (os_log_type_enabled(v155, OS_LOG_TYPE_DEFAULT))
                    {
                      v156 = *(_QWORD *)(a2 + 16);
                      v157 = *(_QWORD *)(a2 + 64);
                      *(_DWORD *)buf = 136316674;
                      v256 = v153;
                      v257 = 2080;
                      v258 = "CheckIfBoostNeeded";
                      v259 = 1024;
                      v260 = 374;
                      v261 = 2048;
                      *(double *)v262 = a5;
                      *(_WORD *)&v262[8] = 2048;
                      *(double *)&v262[10] = v86;
                      *(_WORD *)&v262[18] = 2048;
                      *(_QWORD *)&v262[20] = v156;
                      *(_WORD *)&v262[28] = 2048;
                      *(_QWORD *)&v262[30] = v157;
                      v150 = v154;
                      v151 = " [%s] %s:%d  TOO FAST: now: %.3f last: %f --> updated: %f   factor: %.3f ";
                      v152 = 68;
                      goto LABEL_166;
                    }
LABEL_170:
                    if (*(double *)(a2 + 16) < a5 && (int)VRTraceGetErrorLogLevelForModule() >= 8)
                    {
                      v163 = VRTraceErrorLogLevelToCSTR();
                      v164 = *MEMORY[0x1E0CF2758];
                      v165 = *MEMORY[0x1E0CF2758];
                      if (*MEMORY[0x1E0CF2748])
                      {
                        if (os_log_type_enabled(v165, OS_LOG_TYPE_DEFAULT))
                        {
                          *(_DWORD *)buf = 136315650;
                          v256 = v163;
                          v257 = 2080;
                          v258 = "CheckIfBoostNeeded";
                          v259 = 1024;
                          v260 = 378;
                          _os_log_impl(&dword_1D8A54000, v164, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d  TOO MUCH ACCEL!!!!!!!!!!!!!!!!!!", buf, 0x1Cu);
                        }
                      }
                      else if (os_log_type_enabled(v165, OS_LOG_TYPE_DEBUG))
                      {
                        *(_DWORD *)buf = 136315650;
                        v256 = v163;
                        v257 = 2080;
                        v258 = "CheckIfBoostNeeded";
                        v259 = 1024;
                        v260 = 378;
                        _os_log_debug_impl(&dword_1D8A54000, v164, OS_LOG_TYPE_DEBUG, " [%s] %s:%d  TOO MUCH ACCEL!!!!!!!!!!!!!!!!!!", buf, 0x1Cu);
                      }
                    }
                    goto LABEL_177;
                  }
                  if (!os_log_type_enabled(v155, OS_LOG_TYPE_DEBUG))
                    goto LABEL_170;
                  v227 = *(_QWORD *)(a2 + 16);
                  v228 = *(_QWORD *)(a2 + 64);
                  *(_DWORD *)buf = 136316674;
                  v256 = v153;
                  v257 = 2080;
                  v258 = "CheckIfBoostNeeded";
                  v259 = 1024;
                  v260 = 374;
                  v261 = 2048;
                  *(double *)v262 = a5;
                  *(_WORD *)&v262[8] = 2048;
                  *(double *)&v262[10] = v86;
                  *(_WORD *)&v262[18] = 2048;
                  *(_QWORD *)&v262[20] = v227;
                  *(_WORD *)&v262[28] = 2048;
                  *(_QWORD *)&v262[30] = v228;
                  v160 = v154;
                  v161 = " [%s] %s:%d  TOO FAST: now: %.3f last: %f --> updated: %f   factor: %.3f ";
                  v162 = 68;
                }
                _os_log_debug_impl(&dword_1D8A54000, v160, OS_LOG_TYPE_DEBUG, v161, buf, v162);
                goto LABEL_170;
              }
LABEL_260:
              v90 = ProcessThrottledPktsWithTime((double *)a2, &v254, 0, a5);
              goto LABEL_156;
            }
          }
          else if (os_log_type_enabled(v141, OS_LOG_TYPE_DEBUG))
          {
            v230 = *(_QWORD *)(a2 + 16);
            *(_DWORD *)buf = 136316674;
            v256 = v139;
            v257 = 2080;
            v258 = "AccelerateThrottlingQueue";
            v259 = 1024;
            v260 = 218;
            v261 = 2048;
            *(double *)v262 = v120;
            *(_WORD *)&v262[8] = 2048;
            *(double *)&v262[10] = v138;
            *(_WORD *)&v262[18] = 2048;
            *(_QWORD *)&v262[20] = v230;
            *(_WORD *)&v262[28] = 1024;
            *(_DWORD *)&v262[30] = v116;
            _os_log_debug_impl(&dword_1D8A54000, v140, OS_LOG_TYPE_DEBUG, " [%s] %s:%d AccelerateThrottlingQueue: %.3f from %.3f to %.3f (%d pkts) ", buf, 0x40u);
            if (!v116)
              goto LABEL_155;
            goto LABEL_260;
          }
        }
        if (!v116)
          goto LABEL_155;
        goto LABEL_260;
      }
    }
    else
    {
      v44 = 0;
    }
    v78 = (uint64_t *)a2;
    if (!v75)
    {
LABEL_271:
      v70 = v251;
LABEL_272:
      if (!_MergedGlobals || (int)VRTraceGetErrorLogLevelForModule() < 8)
        return v44;
      v231 = VRTraceErrorLogLevelToCSTR();
      v232 = *MEMORY[0x1E0CF2758];
      v233 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v233, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316162;
          v256 = v231;
          v257 = 2080;
          v258 = "Throttling_MediaQueue_AddPacket_ScheduleAndActiveProbing";
          v259 = 1024;
          v260 = 1099;
          v261 = 1024;
          *(_DWORD *)v262 = v70;
          *(_WORD *)&v262[4] = 1024;
          *(_DWORD *)&v262[6] = v44;
          v60 = " [%s] %s:%d ActiveProbing_ProcessIncomingPacket: %d  ScheduleReleasedPkts: %d ";
          v61 = v232;
          v62 = 40;
          goto LABEL_277;
        }
        return v44;
      }
      if (!os_log_type_enabled(v233, OS_LOG_TYPE_DEBUG))
        return v44;
      *(_DWORD *)buf = 136316162;
      v256 = v231;
      v257 = 2080;
      v258 = "Throttling_MediaQueue_AddPacket_ScheduleAndActiveProbing";
      v259 = 1024;
      v260 = 1099;
      v261 = 1024;
      *(_DWORD *)v262 = v70;
      *(_WORD *)&v262[4] = 1024;
      *(_DWORD *)&v262[6] = v44;
      v234 = " [%s] %s:%d ActiveProbing_ProcessIncomingPacket: %d  ScheduleReleasedPkts: %d ";
      v235 = v232;
      v236 = 40;
LABEL_284:
      _os_log_debug_impl(&dword_1D8A54000, v235, OS_LOG_TYPE_DEBUG, v234, buf, v236);
      return v44;
    }
    goto LABEL_90;
  }
  v53 = *a3;
  if (*a3)
  {
    do
    {
      v54 = v53;
      v53 = *(_QWORD *)(v53 + 1568);
    }
    while (v53);
    a3 = (uint64_t *)(v54 + 1568);
  }
  v55 = *(double *)(a2 + 24);
  *a3 = v253;
  v254 = (uint64_t *)(v40 + 1568);
  v44 = ProcessThrottledPktsWithTime((double *)a2, &v254, (int *)v40, v55) + 1;
  if (!_MergedGlobals || (int)VRTraceGetErrorLogLevelForModule() < 8)
    return v44;
  v56 = VRTraceErrorLogLevelToCSTR();
  v57 = *MEMORY[0x1E0CF2758];
  v58 = *MEMORY[0x1E0CF2758];
  if (!*MEMORY[0x1E0CF2748])
  {
    if (!os_log_type_enabled(v58, OS_LOG_TYPE_DEBUG))
      return v44;
    v239 = *(_QWORD *)(a2 + 40);
    *(_DWORD *)buf = 136316674;
    v256 = v56;
    v257 = 2080;
    v258 = "ProcessThrottledPktsWithNewAudioPkt";
    v259 = 1024;
    v260 = 724;
    v261 = 1024;
    *(_DWORD *)v262 = v44;
    *(_WORD *)&v262[4] = 2048;
    *(double *)&v262[6] = a5;
    *(_WORD *)&v262[14] = 2048;
    *(_QWORD *)&v262[16] = v239;
    *(_WORD *)&v262[24] = 2048;
    *(double *)&v262[26] = v55;
    v234 = " [%s] %s:%d ProcessThrottledPktsWithNewAudioPkt: Pkts: %d  now: %f   interval: %f  next_audio: %f ";
    v235 = v57;
    v236 = 64;
    goto LABEL_284;
  }
  if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
  {
    v59 = *(_QWORD *)(a2 + 40);
    *(_DWORD *)buf = 136316674;
    v256 = v56;
    v257 = 2080;
    v258 = "ProcessThrottledPktsWithNewAudioPkt";
    v259 = 1024;
    v260 = 724;
    v261 = 1024;
    *(_DWORD *)v262 = v44;
    *(_WORD *)&v262[4] = 2048;
    *(double *)&v262[6] = a5;
    *(_WORD *)&v262[14] = 2048;
    *(_QWORD *)&v262[16] = v59;
    *(_WORD *)&v262[24] = 2048;
    *(double *)&v262[26] = v55;
    v60 = " [%s] %s:%d ProcessThrottledPktsWithNewAudioPkt: Pkts: %d  now: %f   interval: %f  next_audio: %f ";
    v61 = v57;
    v62 = 64;
LABEL_277:
    _os_log_impl(&dword_1D8A54000, v61, OS_LOG_TYPE_DEFAULT, v60, buf, v62);
  }
  return v44;
}

uint64_t ProcessThrottledPktsWithTime(double *a1, _QWORD **a2, int *a3, double a4)
{
  _BOOL4 v6;
  _QWORD *v7;
  double v8;
  uint64_t v9;
  double v10;
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  double v19;
  int v20;
  uint64_t v21;
  unsigned int v22;
  int v23;
  int ErrorLogLevelForModule;
  uint64_t v25;
  NSObject *v26;
  NSObject *v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  int v31;
  unsigned int v32;
  double v33;
  int v34;
  uint64_t v35;
  NSObject *v36;
  uint64_t v37;
  NSObject *v38;
  unsigned int v39;
  unsigned int v40;
  unsigned int v41;
  unsigned int v42;
  unsigned int v43;
  int v44;
  unsigned int v45;
  unsigned int v46;
  unsigned int v47;
  unsigned int v48;
  unsigned int v49;
  double v50;
  int v51;
  uint64_t v52;
  unsigned int v53;
  unsigned int v54;
  unsigned int v55;
  int v56;
  unsigned int v57;
  double v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  NSObject *v62;
  unsigned int v63;
  unsigned int v64;
  unsigned int v65;
  int v66;
  unsigned int v67;
  double v68;
  int v69;
  uint64_t v70;
  uint8_t buf[4];
  uint64_t v75;
  __int16 v76;
  const char *v77;
  __int16 v78;
  int v79;
  __int16 v80;
  unsigned int v81;
  __int16 v82;
  unsigned int v83;
  __int16 v84;
  unsigned int v85;
  __int16 v86;
  unsigned int v87;
  __int16 v88;
  unsigned int v89;
  __int16 v90;
  double v91;
  __int16 v92;
  int v93;
  __int16 v94;
  uint64_t v95;
  __int16 v96;
  double v97;
  __int16 v98;
  unsigned int v99;
  uint64_t v100;

  v100 = *MEMORY[0x1E0C80C00];
  if (a3)
    v6 = a4 - a1[10] >= 0.666;
  else
    v6 = 0;
  v7 = *a2;
  v8 = *a1;
  if (*(_QWORD *)a1)
  {
    v9 = 0;
    while (1)
    {
      if (*(double *)(*(_QWORD *)&v8 + 1608) > a4)
        goto LABEL_36;
      v10 = *(double *)(*(_QWORD *)&v8 + 1568);
      *(_QWORD *)(*(_QWORD *)&v8 + 1568) = 0;
      *a1 = v10;
      --*((_DWORD *)a1 + 8);
      *(double *)v7 = v8;
      *((_DWORD *)a1 + 18) = *((_DWORD *)a1 + 13) + **(_DWORD **)&v8;
      *((_DWORD *)a1 + 19) = *(_DWORD *)(*(_QWORD *)&v8 + 1600);
      if (!_MergedGlobals || (int)VRTraceGetErrorLogLevelForModule() < 8)
        break;
      v11 = VRTraceErrorLogLevelToCSTR();
      v12 = *MEMORY[0x1E0CF2758];
      v13 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          break;
        v14 = *(_DWORD *)(*(_QWORD *)&v8 + 1516);
        v15 = bswap32(*(_DWORD *)(*(_QWORD *)&v8 + 1508));
        v16 = bswap32(*(unsigned __int16 *)(*(_QWORD *)&v8 + 1506));
        v17 = **(_DWORD **)&v8;
        v18 = *(unsigned __int8 *)(*(_QWORD *)&v8 + 1576);
        v19 = *a1;
        v20 = *((_DWORD *)a1 + 8);
        v21 = *(_QWORD *)(*(_QWORD *)&v8 + 1608);
        *(_DWORD *)buf = 136317954;
        v75 = v11;
        v76 = 2080;
        v77 = "ProcessThrottledPktsWithTime";
        v78 = 1024;
        v79 = 665;
        v80 = 1024;
        v81 = v14;
        v82 = 1024;
        v83 = v15;
        v84 = 1024;
        v85 = HIWORD(v16);
        v86 = 1024;
        v87 = v17;
        v88 = 1024;
        v89 = v18;
        v90 = 2048;
        v91 = v19;
        v92 = 1024;
        v93 = v20;
        v94 = 2048;
        v95 = v21;
        v96 = 2048;
        v97 = a4;
        _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d ProcessThrottledPktsWithTime: ^^^^^^ MP %d  %d/%d/%d P: %d  pTWL: %p %d  sched: %.3f now: %.3f", buf, 0x5Eu);
        if (!v6)
          goto LABEL_28;
      }
      else
      {
        if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
          break;
        v45 = *(_DWORD *)(*(_QWORD *)&v8 + 1516);
        v46 = bswap32(*(_DWORD *)(*(_QWORD *)&v8 + 1508));
        v47 = bswap32(*(unsigned __int16 *)(*(_QWORD *)&v8 + 1506));
        v48 = **(_DWORD **)&v8;
        v49 = *(unsigned __int8 *)(*(_QWORD *)&v8 + 1576);
        v50 = *a1;
        v51 = *((_DWORD *)a1 + 8);
        v52 = *(_QWORD *)(*(_QWORD *)&v8 + 1608);
        *(_DWORD *)buf = 136317954;
        v75 = v11;
        v76 = 2080;
        v77 = "ProcessThrottledPktsWithTime";
        v78 = 1024;
        v79 = 665;
        v80 = 1024;
        v81 = v45;
        v82 = 1024;
        v83 = v46;
        v84 = 1024;
        v85 = HIWORD(v47);
        v86 = 1024;
        v87 = v48;
        v88 = 1024;
        v89 = v49;
        v90 = 2048;
        v91 = v50;
        v92 = 1024;
        v93 = v51;
        v94 = 2048;
        v95 = v52;
        v96 = 2048;
        v97 = a4;
        _os_log_debug_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEBUG, " [%s] %s:%d ProcessThrottledPktsWithTime: ^^^^^^ MP %d  %d/%d/%d P: %d  pTWL: %p %d  sched: %.3f now: %.3f", buf, 0x5Eu);
        if (!v6)
          goto LABEL_28;
      }
LABEL_15:
      if (*(_BYTE *)(*(_QWORD *)&v8 + 1577))
      {
        v22 = bswap32(a3[377]);
        if (!RTPInsertAFRCProbeSeqId(*(int **)&v8, v22, *((unsigned __int8 *)a1 + 56)))
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            v37 = VRTraceErrorLogLevelToCSTR();
            v38 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            {
              v39 = bswap32(*(_DWORD *)(*(_QWORD *)&v8 + 1508));
              v40 = bswap32(*(unsigned __int16 *)(*(_QWORD *)&v8 + 1506));
              v41 = **(_DWORD **)&v8;
              v42 = bswap32(a3[377]);
              v43 = bswap32(*((unsigned __int16 *)a3 + 753));
              v44 = *a3;
              *(_DWORD *)buf = 136317186;
              v75 = v37;
              v76 = 2080;
              v77 = "TagMPWithOpportunisticBWEProbeSeq";
              v78 = 1024;
              v79 = 618;
              v80 = 1024;
              v81 = v39;
              v82 = 1024;
              v83 = HIWORD(v40);
              v84 = 1024;
              v85 = v41;
              v86 = 1024;
              v87 = v42;
              v88 = 1024;
              v89 = HIWORD(v43);
              v90 = 1024;
              LODWORD(v91) = v44;
              _os_log_error_impl(&dword_1D8A54000, v38, OS_LOG_TYPE_ERROR, " [%s] %s:%d OpportunisticBWEProbeSeqTagging FAILED for pkt %d/%d/%d and audio pkt %d/%d/%d ", buf, 0x40u);
            }
          }
          goto LABEL_28;
        }
        a1[10] = a4;
        v23 = *MEMORY[0x1E0CF2740];
        ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
        if (v23 >= 7)
        {
          if (ErrorLogLevelForModule < 7)
            goto LABEL_28;
          v61 = VRTraceErrorLogLevelToCSTR();
          v62 = *MEMORY[0x1E0CF2758];
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            goto LABEL_28;
          v63 = *(_DWORD *)(*(_QWORD *)&v8 + 1516);
          v64 = bswap32(*(_DWORD *)(*(_QWORD *)&v8 + 1508));
          v65 = bswap32(*(unsigned __int16 *)(*(_QWORD *)&v8 + 1506));
          v66 = **(_DWORD **)&v8;
          v67 = *(unsigned __int8 *)(*(_QWORD *)&v8 + 1576);
          v68 = *a1;
          v69 = *((_DWORD *)a1 + 8);
          v70 = *(_QWORD *)(*(_QWORD *)&v8 + 1608);
          *(_DWORD *)buf = 136318210;
          v75 = v61;
          v76 = 2080;
          v77 = "TagMPWithOpportunisticBWEProbeSeq";
          v78 = 1024;
          v79 = 606;
          v80 = 1024;
          v81 = v63;
          v82 = 1024;
          v83 = v64;
          v84 = 1024;
          v85 = HIWORD(v65);
          v86 = 1024;
          v87 = v66;
          v88 = 1024;
          v89 = v67;
          v90 = 2048;
          v91 = v68;
          v92 = 1024;
          v93 = v69;
          v94 = 2048;
          v95 = v70;
          v96 = 2048;
          v97 = a4;
          v98 = 1024;
          v99 = v22;
          v36 = v62;
          goto LABEL_22;
        }
        if (ErrorLogLevelForModule > 7)
        {
          v25 = VRTraceErrorLogLevelToCSTR();
          v26 = *MEMORY[0x1E0CF2758];
          v27 = *MEMORY[0x1E0CF2758];
          if (!*MEMORY[0x1E0CF2748])
          {
            if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
            {
              v53 = *(_DWORD *)(*(_QWORD *)&v8 + 1516);
              v54 = bswap32(*(_DWORD *)(*(_QWORD *)&v8 + 1508));
              v55 = bswap32(*(unsigned __int16 *)(*(_QWORD *)&v8 + 1506));
              v56 = **(_DWORD **)&v8;
              v57 = *(unsigned __int8 *)(*(_QWORD *)&v8 + 1576);
              v58 = *a1;
              v59 = *((_DWORD *)a1 + 8);
              v60 = *(_QWORD *)(*(_QWORD *)&v8 + 1608);
              *(_DWORD *)buf = 136318210;
              v75 = v25;
              v76 = 2080;
              v77 = "TagMPWithOpportunisticBWEProbeSeq";
              v78 = 1024;
              v79 = 612;
              v80 = 1024;
              v81 = v53;
              v82 = 1024;
              v83 = v54;
              v84 = 1024;
              v85 = HIWORD(v55);
              v86 = 1024;
              v87 = v56;
              v88 = 1024;
              v89 = v57;
              v90 = 2048;
              v91 = v58;
              v92 = 1024;
              v93 = v59;
              v94 = 2048;
              v95 = v60;
              v96 = 2048;
              v97 = a4;
              v98 = 1024;
              v99 = v22;
              _os_log_debug_impl(&dword_1D8A54000, v26, OS_LOG_TYPE_DEBUG, " [%s] %s:%d OpportunisticBWEProbeSeqTagging: ^^^^^^ MP %d  %d/%d/%d P: %d  pTWL: %p %d  sched: %.3f now: %.3f PROBE_id: %d ", buf, 0x64u);
            }
            goto LABEL_28;
          }
          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
          {
            v28 = *(_DWORD *)(*(_QWORD *)&v8 + 1516);
            v29 = bswap32(*(_DWORD *)(*(_QWORD *)&v8 + 1508));
            v30 = bswap32(*(unsigned __int16 *)(*(_QWORD *)&v8 + 1506));
            v31 = **(_DWORD **)&v8;
            v32 = *(unsigned __int8 *)(*(_QWORD *)&v8 + 1576);
            v33 = *a1;
            v34 = *((_DWORD *)a1 + 8);
            v35 = *(_QWORD *)(*(_QWORD *)&v8 + 1608);
            *(_DWORD *)buf = 136318210;
            v75 = v25;
            v76 = 2080;
            v77 = "TagMPWithOpportunisticBWEProbeSeq";
            v78 = 1024;
            v79 = 612;
            v80 = 1024;
            v81 = v28;
            v82 = 1024;
            v83 = v29;
            v84 = 1024;
            v85 = HIWORD(v30);
            v86 = 1024;
            v87 = v31;
            v88 = 1024;
            v89 = v32;
            v90 = 2048;
            v91 = v33;
            v92 = 1024;
            v93 = v34;
            v94 = 2048;
            v95 = v35;
            v96 = 2048;
            v97 = a4;
            v98 = 1024;
            v99 = v22;
            v36 = v26;
LABEL_22:
            _os_log_impl(&dword_1D8A54000, v36, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d OpportunisticBWEProbeSeqTagging: ^^^^^^ MP %d  %d/%d/%d P: %d  pTWL: %p %d  sched: %.3f now: %.3f PROBE_id: %d ", buf, 0x64u);
          }
        }
      }
LABEL_28:
      v7 = (_QWORD *)(*(_QWORD *)&v8 + 1568);
      v9 = (v9 + 1);
      v8 = v10;
      if (v10 == 0.0)
        goto LABEL_36;
    }
    if (!v6)
      goto LABEL_28;
    goto LABEL_15;
  }
  v9 = 0;
LABEL_36:
  *a2 = v7;
  return v9;
}

void Throttling_MediaQueue_SetAudioInterval(uint64_t a1, double a2)
{
  uint64_t *v2;
  uint64_t v3;
  NSObject *v4;
  NSObject *v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  *(double *)(a1 + 40) = a2;
  v2 = (uint64_t *)(a1 + 40);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v3 = VRTraceErrorLogLevelToCSTR();
    v4 = *MEMORY[0x1E0CF2758];
    v5 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        v6 = *v2;
        v7 = 136315906;
        v8 = v3;
        v9 = 2080;
        v10 = "Throttling_MediaQueue_SetAudioInterval";
        v11 = 1024;
        v12 = 1114;
        v13 = 2048;
        v14 = v6;
        _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d MediaQueue_Throttling_SetAudioInterval: %f", (uint8_t *)&v7, 0x26u);
      }
    }
    else if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      Throttling_MediaQueue_SetAudioInterval_cold_1();
    }
  }
}

void Throttling_MediaQueue_SetIsIPv6(uint64_t a1, uint64_t a2)
{
  int v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  int v7;
  uint64_t v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  *(_BYTE *)(a1 + 48) = a2;
  if ((_DWORD)a2)
    v3 = 48;
  else
    v3 = 28;
  *(_DWORD *)(a1 + 52) = v3;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    v6 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        v7 = 136315906;
        v8 = v4;
        v9 = 2080;
        v10 = "Throttling_MediaQueue_SetIsIPv6";
        v11 = 1024;
        v12 = 1121;
        v13 = 1024;
        v14 = a2;
        _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d MediaQueue_Throttling_SetIsIPv6: %d ", (uint8_t *)&v7, 0x22u);
      }
    }
    else if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      Throttling_MediaQueue_SetIsIPv6_cold_1(v4, a2, v5);
    }
  }
}

uint64_t Throttling_MediaQueue_FlushThrottlingQueue(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  int active;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  double v13;
  int v14;
  const char *v15;
  NSObject *v16;
  uint32_t v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v24;
  _BYTE buf[12];
  __int16 v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  _BYTE v31[10];
  _BYTE v32[10];
  __int16 v33;
  uint64_t v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v24 = 0;
  active = ActiveProbing_FlushPendingPackets(a1, &v24);
  if (*(_QWORD *)a2)
  {
    v6 = v24;
    if (v24)
    {
      do
      {
        v7 = v6;
        v6 = *(_QWORD *)(v6 + 1568);
      }
      while (v6);
      v8 = (uint64_t *)(v7 + 1568);
    }
    else
    {
      v8 = &v24;
    }
    *(_QWORD *)buf = v8;
    v9 = ProcessThrottledPktsWithTime((double *)a2, (_QWORD **)buf, 0, *(double *)(a2 + 16));
  }
  else
  {
    v9 = 0;
  }
  v10 = *(_QWORD *)(a2 + 16);
  *(double *)(a2 + 16) = micro();
  if (*(_QWORD *)a2 || *(_DWORD *)(a2 + 32))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v11 = VRTraceErrorLogLevelToCSTR();
      v12 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v13 = *(double *)a2;
        v14 = *(_DWORD *)(a2 + 32);
        *(_DWORD *)buf = 136316674;
        *(_QWORD *)&buf[4] = v11;
        v26 = 2080;
        v27 = "Throttling_MediaQueue_FlushThrottlingQueue";
        v28 = 1024;
        v29 = 1147;
        v30 = 2048;
        *(double *)v31 = v13;
        *(_WORD *)&v31[8] = 1024;
        *(_DWORD *)v32 = v14;
        *(_WORD *)&v32[4] = 1024;
        *(_DWORD *)&v32[6] = active;
        v33 = 1024;
        LODWORD(v34) = v9;
        v15 = " [%s] %s:%d \t\t *** Unexpected: Flushing the throttling queue left some MPs %p %d ; flushed (%d %d) AP/Th pkts ";
        v16 = v12;
        v17 = 56;
LABEL_13:
        _os_log_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEFAULT, v15, buf, v17);
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
  {
    v18 = VRTraceErrorLogLevelToCSTR();
    v19 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v20 = *(_QWORD *)(a2 + 16);
      *(_DWORD *)buf = 136316674;
      *(_QWORD *)&buf[4] = v18;
      v26 = 2080;
      v27 = "Throttling_MediaQueue_FlushThrottlingQueue";
      v28 = 1024;
      v29 = 1150;
      v30 = 1024;
      *(_DWORD *)v31 = active;
      *(_WORD *)&v31[4] = 1024;
      *(_DWORD *)&v31[6] = v9;
      *(_WORD *)v32 = 2048;
      *(_QWORD *)&v32[2] = v10;
      v33 = 2048;
      v34 = v20;
      v15 = " [%s] %s:%d \t\t *** Flushing the throttling queue removed (%d %d) AP/Th pkts; LastThrottledVideoPktTime: %.3f->%.3f ";
      v16 = v19;
      v17 = 60;
      goto LABEL_13;
    }
  }
  if (v24)
  {
    v21 = *a3;
    if (*a3)
    {
      do
      {
        v22 = v21;
        v21 = *(_QWORD *)(v21 + 1568);
      }
      while (v21);
      a3 = (uint64_t *)(v22 + 1568);
    }
    *a3 = v24;
  }
  return (v9 + active);
}

float Throttling_RTP_SendRTP_SetThrottlingParams(uint64_t a1, uint64_t a2)
{
  float result;

  *(_DWORD *)(a1 + 1600) = 0;
  if (*(_DWORD *)(a1 + 1516))
  {
    *(_WORD *)(a1 + 1576) = *(_WORD *)(a2 + 2);
    if (*(_BYTE *)a2)
      *(_DWORD *)(a1 + 1600) = *(_DWORD *)(a2 + 8);
  }
  else
  {
    *(_BYTE *)(a1 + 1576) = 0;
    result = *(float *)(a2 + 20);
    *(float *)(a1 + 1616) = result;
  }
  return result;
}

uint64_t Throttling_VideoTransmitterUtil_ForceFirstProbePktSize(int a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  int v11;
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (a1 < 207 || (int)a2 > 206)
  {
    if ((int)a2 <= 206 && (int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      v8 = VRTraceErrorLogLevelToCSTR();
      v9 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v11 = 136316162;
        v12 = v8;
        v13 = 2080;
        v14 = "Throttling_VideoTransmitterUtil_ForceFirstProbePktSize";
        v15 = 1024;
        v16 = 1220;
        v17 = 1024;
        v18 = a1;
        v19 = 1024;
        v20 = a2;
        _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d \t\t FORCE_MIN_PKT did NOT take effect: iGobBytes: %d  iPktBytes: %d ", (uint8_t *)&v11, 0x28u);
      }
    }
    return a2;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() < 8)
  {
    return 207;
  }
  else
  {
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    v6 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      v7 = 207;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        v11 = 136316418;
        v12 = v4;
        v13 = 2080;
        v14 = "Throttling_VideoTransmitterUtil_ForceFirstProbePktSize";
        v15 = 1024;
        v16 = 1217;
        v17 = 1024;
        v18 = a2;
        v19 = 1024;
        v20 = 207;
        v21 = 1024;
        v22 = a1;
        _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d \t\t FORCE_MIN_PKT org: %d new: %d gob: %d ", (uint8_t *)&v11, 0x2Eu);
      }
    }
    else
    {
      v7 = 207;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        v11 = 136316418;
        v12 = v4;
        v13 = 2080;
        v14 = "Throttling_VideoTransmitterUtil_ForceFirstProbePktSize";
        v15 = 1024;
        v16 = 1217;
        v17 = 1024;
        v18 = a2;
        v19 = 1024;
        v20 = 207;
        v21 = 1024;
        v22 = a1;
        _os_log_debug_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEBUG, " [%s] %s:%d \t\t FORCE_MIN_PKT org: %d new: %d gob: %d ", (uint8_t *)&v11, 0x2Eu);
      }
    }
  }
  return v7;
}

uint64_t Throttling_VideoTransmitter_ForceMinFirstProbePkt(int a1, unsigned int a2)
{
  return a1 & a2;
}

void Throttling_VideoTransmitter_CalcThrottlingRate(int a1, int a2, int a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v14;
  NSObject *v15;
  NSObject *v16;
  int v17;
  int v18;
  uint64_t v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (_MergedGlobals && (int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v14 = VRTraceErrorLogLevelToCSTR();
    v15 = *MEMORY[0x1E0CF2758];
    v16 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        v18 = 136316162;
        v19 = v14;
        v20 = 2080;
        v21 = "Throttling_VideoTransmitter_CalcThrottlingRate";
        v22 = 1024;
        v23 = 1236;
        v24 = 1024;
        v25 = a2;
        v26 = 1024;
        v27 = a3;
        _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d \n\t\t THROTTLING rate: Tx/Video Rate: %d/%d ", (uint8_t *)&v18, 0x28u);
      }
    }
    else if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      v18 = 136316162;
      v19 = v14;
      v20 = 2080;
      v21 = "Throttling_VideoTransmitter_CalcThrottlingRate";
      v22 = 1024;
      v23 = 1236;
      v24 = 1024;
      v25 = a2;
      v26 = 1024;
      v27 = a3;
      _os_log_debug_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEBUG, " [%s] %s:%d \n\t\t THROTTLING rate: Tx/Video Rate: %d/%d ", (uint8_t *)&v18, 0x28u);
    }
  }
  *(_BYTE *)a8 = a1;
  *(_BYTE *)(a8 + 1) = a4;
  *(_DWORD *)(a8 + 4) = a5;
  *(_DWORD *)(a8 + 8) = a3;
  if ((a1 & a4) != 0)
    v17 = 1;
  else
    v17 = a5;
  *(_WORD *)(a8 + 2) = 0;
  *(_DWORD *)(a8 + 12) = v17;
  *(_DWORD *)(a8 + 16) = 0;
}

void Throttling_VideoTransmitter_SetPerPktProbeSeqState(uint64_t a1, int a2, int a3)
{
  int v6;
  uint64_t v7;
  NSObject *v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  NSObject *v13;
  NSObject *v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  __int16 v33;
  int v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 1))
  {
    *(_BYTE *)(a1 + 2) = 0;
LABEL_22:
    *(_BYTE *)(a1 + 3) = 0;
    return;
  }
  v6 = *(_DWORD *)(a1 + 12);
  *(_BYTE *)(a1 + 2) = v6 > a2;
  if (a2)
  {
    if (*(int *)(a1 + 16) <= 206)
    {
      *(_BYTE *)(a1 + 2) = 1;
      *(_DWORD *)(a1 + 12) = v6 + 1;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v7 = VRTraceErrorLogLevelToCSTR();
        v8 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v9 = *(_DWORD *)(a1 + 12);
          v10 = *(_DWORD *)(a1 + 16);
          v19 = 136316930;
          v20 = v7;
          v21 = 2080;
          v22 = "Throttling_VideoTransmitter_SetPerPktProbeSeqState";
          v23 = 1024;
          v24 = 1306;
          v25 = 1024;
          v26 = a2;
          v27 = 1024;
          v28 = a3;
          v29 = 1024;
          v30 = v9;
          v31 = 1024;
          v32 = v10;
          v33 = 1024;
          v34 = v10 + a3;
          _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d ******** Throttling_VideoTransmitter_SetPerPktProbeSeqState: [%d]: %d  count: %d  iBweSeqLen: %d->%d ", (uint8_t *)&v19, 0x3Au);
        }
      }
    }
    if (*(_BYTE *)(a1 + 2))
    {
      v11 = 0;
      *(_DWORD *)(a1 + 16) += a3;
      goto LABEL_13;
    }
  }
  else if (v6 > 0)
  {
    v11 = 0;
    *(_DWORD *)(a1 + 16) = a3;
    goto LABEL_13;
  }
  v11 = 1;
LABEL_13:
  if (!*(_BYTE *)(a1 + 1))
    goto LABEL_22;
  if (a3 <= 206)
    v11 = 0;
  *(_BYTE *)(a1 + 3) = v11;
  if (v11 == 1 && g_iBWEstLogLevel >= 6 && (int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v12 = VRTraceErrorLogLevelToCSTR();
    v13 = *MEMORY[0x1E0CF2758];
    v14 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        v15 = *(unsigned __int8 *)(a1 + 3);
        v16 = *(unsigned __int8 *)(a1 + 2);
        v19 = 136316418;
        v20 = v12;
        v21 = 2080;
        v22 = "Throttling_VideoTransmitter_SetPerPktProbeSeqState";
        v23 = 1024;
        v24 = 1327;
        v25 = 1024;
        v26 = v15;
        v27 = 1024;
        v28 = v16;
        v29 = 1024;
        v30 = a3;
        _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d  bPotentialPktProbeSeq: %d  bPktProbeSeqEnabled: %d  iPktBytes: %d ", (uint8_t *)&v19, 0x2Eu);
      }
    }
    else if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      v17 = *(unsigned __int8 *)(a1 + 3);
      v18 = *(unsigned __int8 *)(a1 + 2);
      v19 = 136316418;
      v20 = v12;
      v21 = 2080;
      v22 = "Throttling_VideoTransmitter_SetPerPktProbeSeqState";
      v23 = 1024;
      v24 = 1327;
      v25 = 1024;
      v26 = v17;
      v27 = 1024;
      v28 = v18;
      v29 = 1024;
      v30 = a3;
      _os_log_debug_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEBUG, " [%s] %s:%d  bPotentialPktProbeSeq: %d  bPktProbeSeqEnabled: %d  iPktBytes: %d ", (uint8_t *)&v19, 0x2Eu);
    }
  }
}

void Throttling_AFRC_Init(BOOL *a1)
{
  a1[12] = 0;
  *(_QWORD *)(a1 + 4) = 0;
  *a1 = 1;
  Throttling_AFRC_GetDefaults(a1);
}

void Throttling_AFRC_GetDefaults(BOOL *a1)
{
  CFIndex AppIntegerValue;
  int ErrorLogLevelForModule;
  _BYTE *v4;
  NSObject **v5;
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  _BOOL4 v9;
  int v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  NSObject *v15;
  NSObject *v16;
  int v17;
  int v18;
  BOOL v19;
  BOOL v20;
  BOOL v21;
  BOOL v22;
  BOOL v23;
  BOOL v24;
  uint64_t v25;
  NSObject *v26;
  NSObject *v27;
  int v28;
  int v29;
  Boolean keyExistsAndHasValidFormat;
  uint8_t buf[4];
  uint64_t v32;
  __int16 v33;
  const char *v34;
  __int16 v35;
  int v36;
  __int16 v37;
  int v38;
  __int16 v39;
  int v40;
  __int16 v41;
  int v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  keyExistsAndHasValidFormat = 0;
  AppIntegerValue = CFPreferencesGetAppIntegerValue(CFSTR("Throttling"), CFSTR("com.apple.VideoConference"), &keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat)
    *a1 = AppIntegerValue != 0;
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  v4 = (_BYTE *)MEMORY[0x1E0CF2748];
  v5 = (NSObject **)MEMORY[0x1E0CF2758];
  if (ErrorLogLevelForModule >= 8)
  {
    v6 = VRTraceErrorLogLevelToCSTR();
    v7 = *v5;
    v8 = *v5;
    if (*v4)
    {
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        v9 = *a1;
        *(_DWORD *)buf = 136315906;
        v32 = v6;
        v33 = 2080;
        v34 = "Throttling_AFRC_GetDefaults";
        v35 = 1024;
        v36 = 1480;
        v37 = 1024;
        v38 = v9;
        _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Throttling: %d ", buf, 0x22u);
      }
    }
    else if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      Throttling_AFRC_GetDefaults_cold_2();
    }
  }
  v10 = CFPreferencesGetAppIntegerValue(CFSTR("HardCodeBWEstRate"), CFSTR("com.apple.VideoConference"), &keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat)
    v11 = v10;
  else
    v11 = 0;
  *((_DWORD *)a1 + 1) = v11;
  v12 = CFPreferencesGetAppIntegerValue(CFSTR("HardCodeTxRate"), CFSTR("com.apple.VideoConference"), &keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat)
    v13 = v12;
  else
    v13 = 0;
  *((_DWORD *)a1 + 2) = v13;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v14 = VRTraceErrorLogLevelToCSTR();
    v15 = *v5;
    v16 = *v5;
    if (*v4)
    {
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        v17 = *((_DWORD *)a1 + 1);
        v18 = *((_DWORD *)a1 + 2);
        *(_DWORD *)buf = 136316162;
        v32 = v14;
        v33 = 2080;
        v34 = "Throttling_AFRC_GetDefaults";
        v35 = 1024;
        v36 = 1488;
        v37 = 1024;
        v38 = v17;
        v39 = 1024;
        v40 = v18;
        _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d dwHardCodeBWEstRate: %d \t dwHardCodeTxRate: %d ", buf, 0x28u);
      }
    }
    else if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      v28 = *((_DWORD *)a1 + 1);
      v29 = *((_DWORD *)a1 + 2);
      *(_DWORD *)buf = 136316162;
      v32 = v14;
      v33 = 2080;
      v34 = "Throttling_AFRC_GetDefaults";
      v35 = 1024;
      v36 = 1488;
      v37 = 1024;
      v38 = v28;
      v39 = 1024;
      v40 = v29;
      _os_log_debug_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEBUG, " [%s] %s:%d dwHardCodeBWEstRate: %d \t dwHardCodeTxRate: %d ", buf, 0x28u);
    }
  }
  v19 = CFPreferencesGetAppIntegerValue(CFSTR("ThrottlingSendLog"), CFSTR("com.apple.VideoConference"), &keyExistsAndHasValidFormat) != 0;
  if (keyExistsAndHasValidFormat)
    v20 = v19;
  else
    v20 = _MergedGlobals != 0;
  _MergedGlobals = v20;
  v21 = CFPreferencesGetAppIntegerValue(CFSTR("ThrottlingRecvLog"), CFSTR("com.apple.VideoConference"), &keyExistsAndHasValidFormat) != 0;
  if (keyExistsAndHasValidFormat)
    v22 = v21;
  else
    v22 = byte_1ED10CDE9 != 0;
  byte_1ED10CDE9 = v22;
  v23 = CFPreferencesGetAppIntegerValue(CFSTR("ThrottlingProbeSeqLog"), CFSTR("com.apple.VideoConference"), &keyExistsAndHasValidFormat) != 0;
  if (keyExistsAndHasValidFormat)
    v24 = v23;
  else
    v24 = g_bThrottlingProbeSeqLog != 0;
  g_bThrottlingProbeSeqLog = v24;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v25 = VRTraceErrorLogLevelToCSTR();
    v26 = *v5;
    v27 = *v5;
    if (*v4)
    {
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136316418;
        v32 = v25;
        v33 = 2080;
        v34 = "Throttling_AFRC_GetDefaults";
        v35 = 1024;
        v36 = 1500;
        v37 = 1024;
        v38 = _MergedGlobals;
        v39 = 1024;
        v40 = byte_1ED10CDE9;
        v41 = 1024;
        v42 = g_bThrottlingProbeSeqLog;
        _os_log_impl(&dword_1D8A54000, v26, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d g_bThrottlingSendLog: %d  g_bThrottlingRecvLog: %d  g_bThrottlingProbeSeqLog: %d ", buf, 0x2Eu);
      }
    }
    else if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
    {
      Throttling_AFRC_GetDefaults_cold_1(v25, v26);
    }
  }
}

BOOL Throttling_AFRC_IsInThrottlingMode(_BYTE *a1, unsigned int a2)
{
  _BOOL8 v3;

  v3 = a2 >> 5 < 0xC35 && *a1 != 0;
  a1[12] = v3;
  return v3;
}

uint64_t Throttling_AFRC_OverrideRxEstimate(uint64_t result, _DWORD *a2)
{
  int v2;

  v2 = *(_DWORD *)(result + 4);
  if (v2)
    *a2 = v2;
  return result;
}

void sub_1D8DEE97C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t DTLS_SocketRead(uint64_t a1, void *a2, int64_t *a3)
{
  const __CFData *v6;
  CFIndex Length;
  int64_t v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  CFIndex v12;
  UInt8 *MutableBytePtr;
  _BYTE v15[22];
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  UInt8 __b[2048];
  uint64_t v23;
  CFRange v24;

  v23 = *MEMORY[0x1E0C80C00];
  v6 = *(const __CFData **)(a1 + 424);
  Length = CFDataGetLength(v6);
  v8 = *a3;
  if (*a3 > Length)
  {
    memset(__b, 170, sizeof(__b));
    if (*(_DWORD *)(a1 + 352) == 2)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v9 = VRTraceErrorLogLevelToCSTR();
        v10 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v15 = 136316162;
          *(_QWORD *)&v15[4] = v9;
          *(_WORD *)&v15[12] = 2080;
          *(_QWORD *)&v15[14] = "DTLS_SocketRead";
          v16 = 1024;
          v17 = 119;
          v18 = 1024;
          v19 = v8;
          v20 = 1024;
          v21 = Length;
          _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d DTLS_SocketRead something terrible happened! %d wanted %d have", v15, 0x28u);
        }
      }
    }
    else
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 448));
      v11 = *(_QWORD *)(a1 + 440);
      if ((v11
         || (*(_OWORD *)v15 = xmmword_1D910DC30,
             pthread_cond_timedwait_relative_np((pthread_cond_t *)(a1 + 512), (pthread_mutex_t *)(a1 + 448), (const timespec *)v15), (v11 = *(_QWORD *)(a1 + 440)) != 0))&& *(int *)(v11 + 2052) < 2049)
      {
        __memcpy_chk();
        v12 = *(int *)(v11 + 2052);
        *(_QWORD *)(a1 + 440) = *(_QWORD *)(v11 + 2056);
        free((void *)v11);
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 448));
        if ((_DWORD)v12)
        {
          CFDataAppendBytes(v6, __b, v12);
          Length = CFDataGetLength(v6);
        }
      }
      else
      {
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 448));
      }
    }
  }
  if (Length >= v8)
  {
    MutableBytePtr = CFDataGetMutableBytePtr(v6);
    memmove(a2, MutableBytePtr, v8);
    v24.location = 0;
    v24.length = v8;
    CFDataDeleteBytes(v6, v24);
    return 0;
  }
  else
  {
    *a3 = 0;
    return 4294957493;
  }
}

uint64_t DTLS_SocketWrite(uint64_t a1, const void *a2, size_t *a3)
{
  int v6;
  int v7;
  __int128 v8;
  int v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  NSObject *v16;
  size_t v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t result;
  size_t v21;
  socklen_t v22;
  uint8_t buf[4];
  uint64_t v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  int v33[2];
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  uint64_t v53;
  unint64_t v54;
  _DWORD v55[5];
  unint64_t v56;
  unint64_t v57;
  __int128 v58;
  __int128 v59;
  uint64_t v60;
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  v6 = *(_DWORD *)(a1 + 12);
  v7 = *(_DWORD *)(a1 + 52);
  v8 = *(_OWORD *)(a1 + 188);
  v58 = *(_OWORD *)(a1 + 172);
  v59 = v8;
  v60 = *(_QWORD *)(a1 + 204);
  v56 = 0xAAAAAAAAAAAAAAAALL;
  v57 = 0xAAAAAAAAAAAAAAAALL;
  memset(v55, 170, sizeof(v55));
  v54 = 0xAAAAAAAAAAAAAAAALL;
  if (*(_DWORD *)(a1 + 352) == 2)
    v9 = v6;
  else
    v9 = 3;
  if (*(_DWORD *)(a1 + 352) == 2)
    v10 = 3;
  else
    v10 = 0;
  if ((v7 & 1) != 0)
  {
    v22 = 28;
    v11 = IPPORTToSA6();
  }
  else
  {
    v22 = 16;
    v11 = IPPORTToSA();
  }
  v51 = 0u;
  v52 = 0u;
  v50 = 0u;
  v53 = 0;
  v49 = 0u;
  v48 = 0u;
  v47 = 0u;
  v46 = 0u;
  v45 = 0u;
  v44 = 0u;
  v43 = 0u;
  v42 = 0u;
  v41 = 0u;
  v40 = 0u;
  v39 = 0u;
  v38 = 0u;
  v37 = 0u;
  v36 = 0u;
  v35 = 0u;
  v34 = 0u;
  v12 = *(_DWORD *)(a1 + 8);
  v33[0] = v9;
  v33[1] = v12;
  HIDWORD(v42) = v10;
  BYTE1(v44) = 1;
  v13 = VTP_Sendto(*(_DWORD *)a1, a2, *a3, 0, v11, v22, v33);
  v14 = v13;
  if (v13 == -1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v18 = VRTraceErrorLogLevelToCSTR();
      v19 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        DTLS_SocketWrite_cold_1(v18, (uint64_t *)a3, v19);
    }
    v17 = 0;
  }
  else
  {
    if (v13 >= *(_DWORD *)a3)
    {
      result = 0;
      v17 = v14;
      goto LABEL_22;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v15 = VRTraceErrorLogLevelToCSTR();
      v16 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v21 = *a3;
        *(_DWORD *)buf = 136316162;
        v24 = v15;
        v25 = 2080;
        v26 = "DTLS_SocketWrite";
        v27 = 1024;
        v28 = 190;
        v29 = 1024;
        v30 = v14;
        v31 = 1024;
        v32 = v21;
        _os_log_error_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_ERROR, " [%s] %s:%d SECURETRANSPORT WRITE TOO FEW BYTES (%d of %d bytes)...", buf, 0x28u);
      }
    }
    v17 = v14;
  }
  result = 4294957493;
LABEL_22:
  *a3 = v17;
  return result;
}

uint64_t DTLS_Create(uint64_t *a1, int a2, char a3, int a4, int a5, const void *a6, const void *a7)
{
  uint64_t v14;
  char *v15;
  char *v16;
  uint64_t Handle;
  const __CFAllocator *v18;
  uint64_t v19;
  CFIndex AppIntegerValue;
  CFIndex v21;
  uint64_t v22;
  NSObject *v23;
  NSObject *v24;
  _BYTE v26[24];
  int v27;
  __int16 v28;
  int v29;
  __int16 v30;
  int v31;
  void *values;
  pthread_mutexattr_t v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v14 = 2149777411;
  v15 = (char *)malloc_type_calloc(1uLL, 0x268uLL, 0x106004055F88EB1uLL);
  if (v15)
  {
    v16 = v15;
    Handle = CreateHandle();
    *a1 = Handle;
    if (Handle == 0xFFFFFFFFLL)
    {
      return 2149777413;
    }
    else
    {
      v33.__sig = 0xAAAAAAAAAAAAAAAALL;
      *(_QWORD *)v33.__opaque = 0xAAAAAAAAAAAAAAAALL;
      if (!pthread_mutexattr_init(&v33))
      {
        pthread_mutexattr_settype(&v33, 2);
        pthread_mutex_init((pthread_mutex_t *)(v16 + 360), &v33);
        pthread_mutexattr_destroy(&v33);
      }
      pthread_mutex_init((pthread_mutex_t *)v16 + 7, 0);
      pthread_cond_init((pthread_cond_t *)(v16 + 512), 0);
      v18 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      *((_QWORD *)v16 + 53) = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
      *(_OWORD *)(v16 + 568) = 0u;
      *((_QWORD *)v16 + 73) = a6;
      if (a6)
      {
        CFRetain(a6);
        *((_QWORD *)v16 + 74) = SecCertificateCreateWithBytes();
        *((_QWORD *)v16 + 75) = SecCertificateCreateWithBytes();
        v19 = SecCertificateCreateWithBytes();
        *((_QWORD *)v16 + 76) = v19;
        values = (void *)*((_QWORD *)v16 + 74);
        *(_QWORD *)v26 = *((_QWORD *)v16 + 73);
        *(_QWORD *)&v26[8] = v19;
        *(_QWORD *)&v26[16] = *((_QWORD *)v16 + 75);
        *((_QWORD *)v16 + 72) = CFArrayCreate(v18, (const void **)&values, 1, 0);
        *((_QWORD *)v16 + 71) = CFArrayCreate(v18, (const void **)v26, 3, 0);
      }
      *(_DWORD *)v16 = a2;
      *((_DWORD *)v16 + 1) = a4;
      v16[16] = a3;
      *((_DWORD *)v16 + 2) = a5;
      *((_DWORD *)v16 + 3) = 0;
      if (a7)
        memcpy(v16 + 24, a7, 0x140uLL);
      *((_QWORD *)v16 + 54) = 20;
      LOBYTE(values) = 0;
      AppIntegerValue = CFPreferencesGetAppIntegerValue(CFSTR("dtlsHandshakeTimeout"), CFSTR("com.apple.VideoConference"), (Boolean *)&values);
      if ((_BYTE)values)
      {
        v21 = AppIntegerValue;
        if ((unint64_t)(AppIntegerValue - 61) >= 0xFFFFFFFFFFFFFFC4)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            v22 = VRTraceErrorLogLevelToCSTR();
            v23 = *MEMORY[0x1E0CF2758];
            v24 = *MEMORY[0x1E0CF2758];
            if (*MEMORY[0x1E0CF2748])
            {
              if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)v26 = 136316162;
                *(_QWORD *)&v26[4] = v22;
                *(_WORD *)&v26[12] = 2080;
                *(_QWORD *)&v26[14] = "DTLS_Create";
                *(_WORD *)&v26[22] = 1024;
                v27 = 284;
                v28 = 1024;
                v29 = v21;
                v30 = 1024;
                v31 = a4;
                _os_log_impl(&dword_1D8A54000, v23, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d DTLS timeout: set via preferences to %d seconds for call (%d)", v26, 0x28u);
              }
            }
            else if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)v26 = 136316162;
              *(_QWORD *)&v26[4] = v22;
              *(_WORD *)&v26[12] = 2080;
              *(_QWORD *)&v26[14] = "DTLS_Create";
              *(_WORD *)&v26[22] = 1024;
              v27 = 284;
              v28 = 1024;
              v29 = v21;
              v30 = 1024;
              v31 = a4;
              _os_log_debug_impl(&dword_1D8A54000, v23, OS_LOG_TYPE_DEBUG, " [%s] %s:%d DTLS timeout: set via preferences to %d seconds for call (%d)", v26, 0x28u);
            }
          }
          *((_QWORD *)v16 + 54) = v21;
        }
      }
      return 0;
    }
  }
  return v14;
}

uint64_t DTLS_Cleanup(int a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  uint64_t v13;
  NSObject *v14;
  NSObject *v15;
  _BOOL4 v16;
  uint64_t result;
  int v18;
  uint64_t v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v2 = CheckInHandleDebug();
  if (!v2)
    return 2149777410;
  v3 = v2;
  SSLClose(*(SSLContextRef *)(v2 + 344));
  CheckOutHandleDebug();
  _SSLDisposeContext();
  *(_QWORD *)(v3 + 344) = 0;
  while (1)
  {
    v4 = *(_QWORD **)(v3 + 440);
    if (!v4)
      break;
    *(_QWORD *)(v3 + 440) = v4[257];
    free(v4);
  }
  v5 = *(const void **)(v3 + 608);
  if (v5)
  {
    CFRelease(v5);
    *(_QWORD *)(v3 + 608) = 0;
  }
  v6 = *(const void **)(v3 + 600);
  if (v6)
  {
    CFRelease(v6);
    *(_QWORD *)(v3 + 600) = 0;
  }
  v7 = *(const void **)(v3 + 592);
  if (v7)
  {
    CFRelease(v7);
    *(_QWORD *)(v3 + 592) = 0;
  }
  v8 = *(const void **)(v3 + 568);
  if (v8)
  {
    CFRelease(v8);
    *(_QWORD *)(v3 + 568) = 0;
  }
  v9 = *(const void **)(v3 + 576);
  if (v9)
  {
    CFRelease(v9);
    *(_QWORD *)(v3 + 576) = 0;
  }
  v10 = *(const void **)(v3 + 584);
  if (v10)
  {
    CFRelease(v10);
    *(_QWORD *)(v3 + 584) = 0;
  }
  v11 = *(const void **)(v3 + 560);
  if (v11)
  {
    CFRelease(v11);
    *(_QWORD *)(v3 + 560) = 0;
  }
  v12 = *(const void **)(v3 + 424);
  if (v12)
  {
    CFRelease(v12);
    *(_QWORD *)(v3 + 424) = 0;
  }
  pthread_mutex_destroy((pthread_mutex_t *)(v3 + 360));
  pthread_mutex_destroy((pthread_mutex_t *)(v3 + 448));
  pthread_cond_destroy((pthread_cond_t *)(v3 + 512));
  free((void *)v3);
  if ((int)VRTraceGetErrorLogLevelForModule() < 8)
    return 0;
  v13 = VRTraceErrorLogLevelToCSTR();
  v14 = *MEMORY[0x1E0CF2758];
  v15 = *MEMORY[0x1E0CF2758];
  if (*MEMORY[0x1E0CF2748])
  {
    v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (v16)
    {
      v18 = 136315906;
      v19 = v13;
      v20 = 2080;
      v21 = "DTLS_Cleanup";
      v22 = 1024;
      v23 = 325;
      v24 = 1024;
      v25 = a1;
      _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d DTLS_Cleanup done on handle %d", (uint8_t *)&v18, 0x22u);
      return 0;
    }
  }
  else
  {
    result = os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG);
    if ((_DWORD)result)
    {
      DTLS_Cleanup_cold_1();
      return 0;
    }
  }
  return result;
}

uint64_t DTLS_Handshake(uint64_t a1, CFErrorRef *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  SSLContextRef *v8;
  CFIndex v9;
  int v10;
  const __CFArray *v11;
  int v12;
  uint64_t v13;
  NSObject *v14;
  NSObject *v15;
  const char *v16;
  const char *v17;
  NSObject *v18;
  uint32_t v19;
  uint64_t v20;
  NSObject *v21;
  NSObject *v22;
  int v24;
  SSLSessionState *v25;
  OSStatus v26;
  uint64_t v27;
  NSObject *v28;
  SSLSessionState v29;
  const void *v30;
  void *userInfoValues;
  uint8_t buf[4];
  uint64_t v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  int v37;
  __int16 v38;
  _WORD v39[9];

  *(_QWORD *)&v39[5] = *MEMORY[0x1E0C80C00];
  v5 = 2149777460;
  v6 = CheckInHandleDebug();
  if (v6)
  {
    v7 = v6;
    if (a2)
      *a2 = 0;
    userInfoValues = 0;
    v30 = (const void *)*MEMORY[0x1E0C9AFE0];
    v8 = (SSLContextRef *)(v6 + 344);
    if (_SSLNewDatagramContext())
    {
      if (a2)
      {
        userInfoValues = CFSTR("No datagram context available");
        v9 = 1;
        v10 = 1;
LABEL_14:
        *a2 = CFErrorCreateWithUserInfoKeysAndValues(0, CFSTR("DTLS"), v9, &v30, (const void *const *)&userInfoValues, 1);
        goto LABEL_35;
      }
      goto LABEL_34;
    }
    if (SSLSetIOFuncs(*v8, (SSLReadFunc)DTLS_SocketRead, (SSLWriteFunc)DTLS_SocketWrite))
    {
      if (a2)
      {
        userInfoValues = CFSTR("Could not set I/O functions");
        v10 = 1;
        v9 = 2;
        goto LABEL_14;
      }
      goto LABEL_34;
    }
    if (SSLSetConnection(*(SSLContextRef *)(v7 + 344), (SSLConnectionRef)v7))
    {
      if (a2)
      {
        userInfoValues = CFSTR("Could not set connection");
        v10 = 1;
        v9 = 3;
        goto LABEL_14;
      }
      goto LABEL_34;
    }
    if (*(_QWORD *)(v7 + 576))
    {
      if (_SSLSetTrustedRoots())
      {
        if (a2)
        {
          userInfoValues = CFSTR("Could not set root certificates");
          v10 = 1;
          v9 = 5;
          goto LABEL_14;
        }
        goto LABEL_34;
      }
      v11 = *(const __CFArray **)(v7 + 568);
      if (v11)
      {
        if (SSLSetCertificate(*v8, v11))
        {
          if (a2)
          {
            userInfoValues = CFSTR("Could not set certificate array");
            v10 = 1;
            v9 = 7;
            goto LABEL_14;
          }
          goto LABEL_34;
        }
        if (SSLSetMaxDatagramRecordSize(*v8, 0x4AAuLL))
        {
          if (a2)
          {
            userInfoValues = CFSTR("Could not set max datagram record size");
            v10 = 1;
            v9 = 8;
            goto LABEL_14;
          }
          goto LABEL_34;
        }
        if (*(_BYTE *)(v7 + 16) && SSLSetClientSideAuthenticate(*v8, kAlwaysAuthenticate))
        {
          if (a2)
          {
            userInfoValues = CFSTR("Could not enable client authentication");
            v10 = 1;
            v9 = 9;
            goto LABEL_14;
          }
LABEL_34:
          v10 = 1;
          goto LABEL_35;
        }
        v24 = 100 * *(_DWORD *)(v7 + 432);
        v25 = (SSLSessionState *)(v7 + 352);
        *(_DWORD *)(v7 + 352) = 1;
        do
        {
          v26 = SSLHandshake(*v8);
          v10 = v26;
          if (v24 < 2)
            break;
          --v24;
        }
        while (v26 == -9803);
        if (v26 || SSLGetSessionState(*v8, v25))
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
          {
            v27 = VRTraceErrorLogLevelToCSTR();
            v28 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              v29 = *v25;
              *(_DWORD *)buf = 136316162;
              v33 = v27;
              v34 = 2080;
              v35 = "DTLS_Handshake";
              v36 = 1024;
              v37 = 445;
              v38 = 1024;
              *(_DWORD *)v39 = v10;
              v39[2] = 1024;
              *(_DWORD *)&v39[3] = v29;
              _os_log_impl(&dword_1D8A54000, v28, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d SECURETRANSPORT %d %d", buf, 0x28u);
            }
          }
          *v25 = kSSLAborted;
          if (a2)
          {
            userInfoValues = CFSTR("Handshake failed");
            v9 = 10;
            goto LABEL_14;
          }
LABEL_35:
          if (a3)
          {
            v12 = (*(uint64_t (**)(uint64_t, CFErrorRef *, SSLContextRef))(a3 + 16))(a3, a2, *v8);
            if (v12)
              v5 = 0;
            else
              v5 = 2149777460;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
            {
              v13 = VRTraceErrorLogLevelToCSTR();
              v14 = *MEMORY[0x1E0CF2758];
              v15 = *MEMORY[0x1E0CF2758];
              if (!*MEMORY[0x1E0CF2748])
              {
                if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
                  DTLS_Handshake_cold_2(v13, v12 == 0, v14);
                goto LABEL_55;
              }
              if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
              {
                v16 = "OK";
                *(_DWORD *)buf = 136315906;
                v33 = v13;
                v34 = 2080;
                if (!v12)
                  v16 = "NO";
                v35 = "DTLS_Handshake";
                v36 = 1024;
                v37 = 463;
                v38 = 2080;
                *(_QWORD *)v39 = v16;
                v17 = " [%s] %s:%d SECURETRANSPORT SETUP %s...";
                v18 = v14;
                v19 = 38;
                goto LABEL_50;
              }
            }
          }
          else if (v10 && (int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            v20 = VRTraceErrorLogLevelToCSTR();
            v21 = *MEMORY[0x1E0CF2758];
            v22 = *MEMORY[0x1E0CF2758];
            if (!*MEMORY[0x1E0CF2748])
            {
              if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
                DTLS_Handshake_cold_1(v20);
              goto LABEL_55;
            }
            if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315650;
              v33 = v20;
              v34 = 2080;
              v35 = "DTLS_Handshake";
              v36 = 1024;
              v37 = 466;
              v17 = " [%s] %s:%d SECURETRANSPORT FAILED...";
              v18 = v21;
              v19 = 28;
LABEL_50:
              _os_log_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_DEFAULT, v17, buf, v19);
            }
          }
LABEL_55:
          CheckOutHandleDebug();
          return v5;
        }
      }
      else if (a2)
      {
        v10 = 0;
        userInfoValues = CFSTR("No certificate array available");
        v9 = 6;
        goto LABEL_14;
      }
    }
    else if (a2)
    {
      v10 = 0;
      userInfoValues = CFSTR("No root certificates available");
      v9 = 4;
      goto LABEL_14;
    }
    v10 = 0;
    goto LABEL_35;
  }
  return 2149777410;
}

uint64_t DTLS_UpdateHandshake(uint64_t a1, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v7;
  uint64_t v8;
  _DWORD *v9;
  _DWORD *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  NSObject *v17;
  int v19;
  uint64_t v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v4 = 2149777412;
  if (a2)
  {
    v7 = CheckInHandleDebug();
    if (v7)
    {
      v8 = v7;
      if (*(_DWORD *)(v7 + 4) == a4 && a3 <= 0x800 && *(int *)(v7 + 352) >= 1)
      {
        v9 = malloc_type_malloc(0x810uLL, 0x1020040DC7F7759uLL);
        if (v9)
        {
          v10 = v9;
          __memcpy_chk();
          v10[513] = a3;
          *((_QWORD *)v10 + 257) = 0;
          pthread_mutex_lock((pthread_mutex_t *)(v8 + 448));
          v11 = *(_QWORD *)(v8 + 440);
          if (v11)
          {
            do
            {
              v12 = v11;
              v11 = *(_QWORD *)(v11 + 2056);
            }
            while (v11);
            v13 = (_QWORD *)(v12 + 2056);
          }
          else
          {
            v13 = (_QWORD *)(v8 + 440);
          }
          *v13 = v10;
          pthread_cond_signal((pthread_cond_t *)(v8 + 512));
          pthread_mutex_unlock((pthread_mutex_t *)(v8 + 448));
          if (*(_DWORD *)(v8 + 352) == 2)
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
            {
              v16 = VRTraceErrorLogLevelToCSTR();
              v17 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                v19 = 136315650;
                v20 = v16;
                v21 = 2080;
                v22 = "DTLS_UpdateHandshake";
                v23 = 1024;
                v24 = 514;
                _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d DTLS_UpdateHandshake:: process late incoming handshake packet...", (uint8_t *)&v19, 0x1Cu);
              }
            }
            *(_DWORD *)(v8 + 352) = 1;
            SSLHandshake(*(SSLContextRef *)(v8 + 344));
            v4 = 0;
            *(_DWORD *)(v8 + 352) = 2;
          }
          else
          {
            v4 = 0;
          }
        }
        else
        {
          v4 = 2149777411;
        }
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v14 = VRTraceErrorLogLevelToCSTR();
        v15 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v19 = 136315650;
          v20 = v14;
          v21 = 2080;
          v22 = "DTLS_UpdateHandshake";
          v23 = 1024;
          v24 = 523;
          _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d DTLS_UpdateHandshake invalid incoming handshake packet", (uint8_t *)&v19, 0x1Cu);
        }
      }
      CheckOutHandleDebug();
    }
    else
    {
      return 2149777410;
    }
  }
  return v4;
}

BOOL DTLS_IsConnected()
{
  uint64_t v0;
  _BOOL8 v1;

  v0 = CheckInHandleDebug();
  if (!v0)
    return 0;
  v1 = *(_DWORD *)(v0 + 352) == 2;
  CheckOutHandleDebug();
  return v1;
}

uint64_t DTLS_Read(uint64_t a1, OpaqueCMBlockBuffer *a2, CMBlockBufferRef *a3, const __CFAllocator *a4, const __CFAllocator *a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  pthread_mutex_t *v12;
  OSStatus DataPointer;
  CFIndex Length;
  OSStatus v15;
  OSStatus v16;
  OSStatus v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  NSObject *v21;
  uint64_t v23;
  CMBlockBufferRef theBuffer;
  size_t processed;
  char *dataPointerOut;
  size_t totalLengthOut;
  uint8_t buf[4];
  uint64_t v29;
  __int16 v30;
  const char *v31;
  __int16 v32;
  int v33;
  __int16 v34;
  int v35;
  uint64_t v36;
  CFRange v37;

  v36 = *MEMORY[0x1E0C80C00];
  dataPointerOut = 0;
  totalLengthOut = 0;
  theBuffer = 0;
  processed = 0;
  if (a3)
    *a3 = 0;
  v9 = 2149777412;
  v10 = CheckInHandleDebug();
  if (!v10)
    return 2149777410;
  v11 = v10;
  if (*(_DWORD *)(v10 + 352) == 2)
  {
    v12 = (pthread_mutex_t *)(v10 + 360);
    pthread_mutex_lock((pthread_mutex_t *)(v10 + 360));
    DataPointer = CMBlockBufferGetDataPointer(a2, 0, 0, &totalLengthOut, &dataPointerOut);
    if (DataPointer)
    {
      v17 = DataPointer;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v23 = VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          DTLS_Read_cold_4(v23);
      }
    }
    else
    {
      Length = CFDataGetLength(*(CFDataRef *)(v11 + 424));
      if (Length)
      {
        v37.length = Length;
        v37.location = 0;
        CFDataDeleteBytes(*(CFMutableDataRef *)(v11 + 424), v37);
      }
      CFDataAppendBytes(*(CFMutableDataRef *)(v11 + 424), (const UInt8 *)dataPointerOut, totalLengthOut);
      v15 = CMBlockBufferCreateWithMemoryBlock(a4, 0, totalLengthOut, a5, 0, 0, totalLengthOut, 1u, &theBuffer);
      if (v15)
      {
        v17 = v15;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            DTLS_Read_cold_3();
        }
      }
      else
      {
        v16 = CMBlockBufferGetDataPointer(theBuffer, 0, 0, &totalLengthOut, &dataPointerOut);
        if (v16)
        {
          v17 = v16;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              DTLS_Read_cold_2();
          }
        }
        else
        {
          v17 = SSLRead(*(SSLContextRef *)(v11 + 344), dataPointerOut, totalLengthOut, &processed);
          if (v17)
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                DTLS_Read_cold_1();
            }
          }
        }
      }
    }
    pthread_mutex_unlock(v12);
    CheckOutHandleDebug();
    if (a3 && !v17)
    {
      if (processed == totalLengthOut)
      {
        v17 = 0;
        *a3 = (CMBlockBufferRef)CFRetain(theBuffer);
      }
      else
      {
        v17 = CMBlockBufferCreateWithBufferReference(a4, theBuffer, 0, processed, 0, a3);
      }
    }
    if (theBuffer)
    {
      CFRelease(theBuffer);
      theBuffer = 0;
    }
    if (v17 < 0 && (int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v20 = VRTraceErrorLogLevelToCSTR();
      v21 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        v29 = v20;
        v30 = 2080;
        v31 = "DTLS_Read";
        v32 = 1024;
        v33 = 606;
        v34 = 1024;
        v35 = v17;
        _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d DTLS_Read failed with %d", buf, 0x22u);
      }
    }
    if (v17)
      return 2149777412;
    else
      return 0;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v18 = VRTraceErrorLogLevelToCSTR();
      v19 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        v29 = v18;
        v30 = 2080;
        v31 = "DTLS_Read";
        v32 = 1024;
        v33 = 565;
        v34 = 1024;
        v35 = -9803;
        _os_log_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d DTLS_Read failed with %d", buf, 0x22u);
      }
    }
    CheckOutHandleDebug();
  }
  return v9;
}

uint64_t DTLS_Write(uint64_t a1, const void *a2, size_t a3, size_t *a4, int a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  OSStatus v12;
  uint64_t v13;
  NSObject *v14;
  int v16;
  uint64_t v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  OSStatus v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v9 = 2149777412;
  v10 = CheckInHandleDebug();
  if (!v10)
    return 2149777410;
  v11 = v10;
  if (*(_DWORD *)(v10 + 352) == 2)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v10 + 360));
    *(_DWORD *)(v11 + 12) = a5;
    v12 = SSLWrite(*(SSLContextRef *)(v11 + 344), a2, a3, a4);
    *(_DWORD *)(v11 + 12) = 0;
    pthread_mutex_unlock((pthread_mutex_t *)(v11 + 360));
    CheckOutHandleDebug();
    if (!v12)
      return 0;
  }
  else
  {
    CheckOutHandleDebug();
    v12 = -9803;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v13 = VRTraceErrorLogLevelToCSTR();
    v14 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v16 = 136315906;
      v17 = v13;
      v18 = 2080;
      v19 = "DTLS_Write";
      v20 = 1024;
      v21 = 635;
      v22 = 1024;
      v23 = v12;
      _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d DTLS_Write failed with %d", (uint8_t *)&v16, 0x22u);
    }
  }
  return v9;
}

void HandleWRMEvent(void *a1, void *a2)
{
  uint64_t v4;
  NSObject *v5;
  int64_t uint64;
  xpc_object_t v7;
  xpc_object_t v8;
  xpc_object_t v9;
  void *v10;
  xpc_object_t value;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  xpc_object_t v15;
  _BYTE v16[12];
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  void *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (!a2)
    return;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v16 = 136315906;
      *(_QWORD *)&v16[4] = v4;
      v17 = 2080;
      v18 = "HandleWRMEvent";
      v19 = 1024;
      v20 = 56;
      v21 = 2048;
      v22 = a2;
      _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d WRMClient(%p): Handling a WRMEvent.", v16, 0x26u);
    }
  }
  uint64 = xpc_dictionary_get_uint64(a1, "kMessageId");
  if (uint64 > 1305)
  {
    if (uint64 == 1306)
    {
      v13 = a2;
      v14 = 1;
    }
    else
    {
      if (uint64 != 1307)
      {
LABEL_15:
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            HandleWRMEvent_cold_1();
        }
        return;
      }
      v13 = a2;
      v14 = 0;
    }
    objc_msgSend(v13, "setPreWarmState:", v14);
    value = xpc_dictionary_get_value(a1, "kMessageArgs");
    v10 = a2;
    v12 = 1;
LABEL_22:
    objc_msgSend(v10, "processWRMCoexMetrics:isAlertedMode:", value, v12);
    return;
  }
  if (uint64 != 1102)
  {
    if (uint64 == 1303)
    {
      v7 = xpc_dictionary_get_value(a1, "kMessageArgs");
      v8 = v7;
      if (v7)
      {
        v9 = xpc_dictionary_get_value(v7, "kWRMApplicationTypeList");
        if (v9)
          objc_msgSend(a2, "processNotificationList:", v9);
      }
      v10 = a2;
      value = v8;
      v12 = 0;
      goto LABEL_22;
    }
    goto LABEL_15;
  }
  v15 = xpc_dictionary_get_value(a1, "kMessageArgs");
  if (xpc_dictionary_get_value(v15, "kWRMAVConferenceMetricsConfig_PeriodicReportInterval"))
  {
    *(_QWORD *)v16 = xpc_dictionary_get_uint64(v15, "kWRMAVConferenceMetricsConfig_PeriodicReportInterval");
    objc_msgSend(a2, "setConfiguration:", v16);
  }
}

uint64_t OUTLINED_FUNCTION_6_16@<X0>(const char *a1@<X1>, void *a2@<X8>)
{
  return xpc_dictionary_get_uint64(a2, a1);
}

uint64_t VCMaxUDPPayloadSize(int a1, int a2)
{
  int v2;
  int v3;

  if (a2)
    v2 = -40;
  else
    v2 = -20;
  v3 = a1 + v2 - 8;
  if (v3 < 0)
    return 0xFFFFFFFFLL;
  else
    return v3;
}

uint64_t VCGetVTPTrafficClassForVCTrafficClass(int a1)
{
  if ((a1 - 1) > 3)
    return 0xFFFFFFFFLL;
  else
    return dword_1D910E880[a1 - 1];
}

uint64_t VCGetVCTrafficClassForVTPTrafficClass(int a1)
{
  if (a1 > 699)
  {
    if (a1 != 700)
    {
      if (a1 == 800)
        return 4;
      return 0;
    }
    return 3;
  }
  else
  {
    if (a1)
      return a1 == 200;
    return 2;
  }
}

uint64_t VCCloseSocketIfValid(uint64_t result)
{
  if ((_DWORD)result != -1)
    return close(result);
  return result;
}

uint64_t VCCloseVFDIfValid(uint64_t a1)
{
  if ((_DWORD)a1 != -1)
    return VTP_Close(a1);
  return a1;
}

uint64_t VCGetVCPacketWithVTPPacket(uint64_t a1, uint64_t a2)
{
  CFTypeRef v4;
  uint64_t v5;
  uint64_t result;

  VCPacketInitialize(a2);
  v4 = *(CFTypeRef *)(a1 + 504);
  if (v4)
    v4 = CFRetain(v4);
  *(_QWORD *)a2 = v4;
  *(_BYTE *)(a2 + 9) = *(_BYTE *)(a1 + 492);
  if (*(_BYTE *)(a1 + 352))
  {
    *(_BYTE *)(a2 + 35) = *(_BYTE *)(a1 + 388);
    v5 = *(unsigned __int8 *)(a1 + 384);
    *(_BYTE *)(a2 + 34) = v5;
    memcpy((void *)(a2 + 10), (const void *)(a1 + 360), 2 * v5);
    *(_BYTE *)(a2 + 36) = *(_BYTE *)(a1 + 390);
    *(_QWORD *)(a2 + 40) = *(_QWORD *)(a1 + 392);
    *(_BYTE *)(a2 + 48) = *(_BYTE *)(a1 + 417);
    *(_BYTE *)(a2 + 137) = *(_BYTE *)(a1 + 436);
  }
  else
  {
    *(_WORD *)(a2 + 34) = 0;
  }
  *(_QWORD *)(a2 + 128) = *(_QWORD *)a1;
  *(_BYTE *)(a2 + 136) = *(_BYTE *)(a1 + 328);
  *(_BYTE *)(a2 + 138) = *(_BYTE *)(a1 + 495);
  *(_QWORD *)(a2 + 88) = *(_QWORD *)(a1 + 200);
  result = VCIDSChannelData_GetIDSAttributeSizeWithChannelDataFormat(a1 + 360);
  *(_QWORD *)(a2 + 104) = result;
  *(_BYTE *)(a2 + 96) = *(_BYTE *)(a1 + 197);
  return result;
}

uint64_t VCCreateVFDForIDS(int a1, int a2, int *a3)
{
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v10;
  NSObject *v11;

  if (a3)
  {
    v6 = VTP_SocketForIDS();
    if (v6 != -1)
    {
      v7 = v6;
      if (VTP_SetSocketMode(v6, 2) == -1)
      {
        v8 = *__error() | (a2 << 16) | 0xC0000000;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCCreateVFDForIDS_cold_3();
        }
      }
      else
      {
        if (VTP_SetPktType(v7, a1) != -1)
        {
          v8 = 0;
          *a3 = v7;
          return v8;
        }
        v8 = *__error() | (a2 << 16) | 0xC0000000;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCCreateVFDForIDS_cold_4();
        }
      }
      VTP_Close(v7);
      return v8;
    }
    v8 = *__error() | (a2 << 16) | 0xC0000000;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCCreateVFDForIDS_cold_2();
    }
  }
  else
  {
    v8 = (a2 << 16) | 0xC0000001;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v10 = VRTraceErrorLogLevelToCSTR();
      v11 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCCreateVFDForIDS_cold_1(v10, v11);
    }
  }
  return v8;
}

BOOL VCBasebandNotificationParser_ParseNotification(unint64_t a1, unsigned int a2, uint64_t a3, double a4)
{
  _BOOL8 result;
  uint64_t v6;
  uint64_t v7;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  _WORD *v14;
  int v15;
  int v16;
  int v17;
  unint64_t v18;
  _BYTE *v19;
  _BYTE *v20;
  unsigned __int16 *v21;
  char v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t v25;
  _WORD *v26;
  int v27;
  NSObject *v28;
  uint64_t v29;
  NSObject *v30;
  uint64_t v31;
  NSObject *v32;
  int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  unint64_t v38;
  _WORD *v39;
  unsigned __int16 *v40;
  BOOL v41;
  BOOL v42;
  BOOL v43;
  int v45;
  int v46;
  uint64_t v47;
  unsigned int v48;
  uint64_t v49;
  NSObject *v50;
  int v51;
  int ErrorLogLevelForModule;
  uint64_t v53;
  uint64_t v54;
  uint8_t buf[4];
  uint64_t v57;
  __int16 v58;
  const char *v59;
  __int16 v60;
  int v61;
  __int16 v62;
  int v63;
  __int16 v64;
  int v65;
  __int16 v66;
  int v67;
  uint64_t v68;

  v68 = *MEMORY[0x1E0C80C00];
  if ((int)a2 < 8)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      VCBasebandNotificationParser_ParseNotification_cold_1();
    }
    return 0;
  }
  v6 = a3;
  *(_DWORD *)a3 = 0;
  v7 = a2 & 0xFFFFFFFE;
  if (v7 == 6)
    goto LABEL_91;
  *(_WORD *)(a3 + 4) = bswap32(*(unsigned __int16 *)(a1 + 6)) >> 16;
  if (v7 == 4)
    goto LABEL_91;
  v9 = bswap32(*(unsigned __int16 *)(a1 + 4)) >> 16;
  if (v9 == 51966)
  {
    if (a2 <= 0xB)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
        if (!result)
          return result;
        VCBasebandNotificationParser_ParseNotification_cold_4();
      }
      return 0;
    }
    v47 = a2 & 0x7FFFFFFC;
    if (v47 == 8)
      goto LABEL_91;
    if (*(_DWORD *)(a1 + 8) == 1862270976)
    {
      *(_DWORD *)a3 = 3;
      if (a2 <= 0xF)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
          if (!result)
            return result;
          VCBasebandNotificationParser_ParseNotification_cold_5();
        }
        return 0;
      }
      if ((a2 & 0xFFFFFFFC | 2) != 0xE)
      {
        v48 = *(unsigned __int16 *)(a1 + 14);
        *(_WORD *)(a3 + 16) = bswap32(*(unsigned __int16 *)(a1 + 12)) >> 16;
        *(_WORD *)(a3 + 18) = bswap32(v48) >> 16;
        return 1;
      }
    }
    else
    {
      *(_DWORD *)a3 = 1;
      *(double *)(a3 + 8) = a4;
      if (a2 <= 0x23)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
          if (!result)
            return result;
          VCBasebandNotificationParser_ParseNotification_cold_6();
        }
        return 0;
      }
      *(_WORD *)(a3 + 16) = *(unsigned __int8 *)(a1 + 12);
      *(_BYTE *)(a3 + 18) = *(_BYTE *)(a1 + 13);
      if (v7 != 14)
      {
        *(_WORD *)(a3 + 20) = bswap32(*(unsigned __int16 *)(a1 + 14)) >> 16;
        *(_BYTE *)(a3 + 22) = *(_BYTE *)(a1 + 16);
        *(_BYTE *)(a3 + 23) = *(_BYTE *)(a1 + 17);
        if (v47 != 20)
        {
          *(_DWORD *)(a3 + 24) = bswap32(*(_DWORD *)(a1 + 20));
          if (v47 != 24)
          {
            *(_DWORD *)(a3 + 28) = bswap32(*(_DWORD *)(a1 + 24));
            if (v47 != 28)
            {
              *(_DWORD *)(a3 + 32) = bswap32(*(_DWORD *)(a1 + 28));
              if (v47 != 32)
              {
                *(_DWORD *)(a3 + 36) = bswap32(*(_DWORD *)(a1 + 32));
                return 1;
              }
            }
          }
        }
      }
    }
LABEL_91:
    __break(0x5519u);
  }
  if (v9 != 57005)
    return 1;
  *(_DWORD *)a3 = 2;
  *(double *)(a3 + 8) = a4;
  if (a2 <= 0xF)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      VCBasebandNotificationParser_ParseNotification_cold_2();
    }
    return 0;
  }
  if (v7 == 12)
    goto LABEL_91;
  *(_WORD *)(a3 + 16) = bswap32(*(unsigned __int16 *)(a1 + 12)) >> 16;
  if (v7 == 14)
    goto LABEL_91;
  v10 = *(unsigned __int16 *)(a1 + 14);
  *(_WORD *)(a3 + 18) = __rev16(v10);
  if (v10 == 0xFFFF)
    return 1;
  v11 = 0;
  v12 = a1 + a2;
  v13 = a3 + 22;
  v14 = (_WORD *)(a3 + 26);
  v15 = 16;
  v54 = a3 + 22;
  do
  {
    v16 = v15 + 3;
    v17 = a2 - (v15 + 3);
    if ((int)a2 < v15 + 3)
      goto LABEL_88;
    v18 = a1 + v15;
    if (v18 >= v12)
      goto LABEL_91;
    if (v18 < a1)
      goto LABEL_91;
    v19 = (_BYTE *)(v13 + 1004 * v11);
    v20 = (_BYTE *)(a1 + v15);
    v22 = *v20;
    v21 = (unsigned __int16 *)(v20 + 1);
    *v19 = v22;
    if (v12 < (unint64_t)v21 || (unint64_t)v21 < a1 || v12 - (unint64_t)v21 < 2)
      goto LABEL_91;
    v23 = bswap32(*v21);
    v24 = HIWORD(v23);
    v25 = v13 + 1004 * v11;
    *(_WORD *)(v25 + 2) = HIWORD(v23);
    v26 = (_WORD *)(v25 + 2);
    v27 = v17 >> 1;
    if (v17 >> 1 < (int)HIWORD(v23))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v53 = VRTraceErrorLogLevelToCSTR();
        v28 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v45 = (unsigned __int16)*v26;
          *(_DWORD *)buf = 136316418;
          v57 = v53;
          v58 = 2080;
          v59 = "VCBasebandNotificationParser_ParseNotification";
          v60 = 1024;
          v61 = 76;
          v62 = 1024;
          v63 = 76;
          v64 = 1024;
          v65 = v27;
          v66 = 1024;
          v67 = v45;
          _os_log_error_impl(&dword_1D8A54000, v28, OS_LOG_TYPE_ERROR, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VCBasebandNotificationParser.c:%d: Bad ACK, #dropped SN doesn't match(%d != %u).", buf, 0x2Eu);
        }
      }
      *v26 = v27;
      LOWORD(v24) = v27;
    }
    if ((unsigned __int16)v24 >= 0x1F5u)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v29 = VRTraceErrorLogLevelToCSTR();
        v30 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v46 = (unsigned __int16)*v26;
          *(_DWORD *)buf = 136316418;
          v57 = v29;
          v58 = 2080;
          v59 = "VCBasebandNotificationParser_ParseNotification";
          v60 = 1024;
          v61 = 81;
          v62 = 1024;
          v63 = 81;
          v64 = 1024;
          v65 = v46;
          v66 = 1024;
          v67 = 500;
          _os_log_error_impl(&dword_1D8A54000, v30, OS_LOG_TYPE_ERROR, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VCBasebandNotificationParser.c:%d: Bad ACK, #dropped SN exceeds limit(%d > %d).", buf, 0x2Eu);
        }
      }
      *v26 = 500;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v31 = VRTraceErrorLogLevelToCSTR();
      v32 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v33 = (unsigned __int16)*v26;
        v34 = *v19;
        *(_DWORD *)buf = 136316162;
        v57 = v31;
        v58 = 2080;
        v59 = "VCBasebandNotificationParser_ParseNotification";
        v60 = 1024;
        v61 = 85;
        v62 = 1024;
        v63 = v33;
        v64 = 1024;
        v65 = v34;
        _os_log_impl(&dword_1D8A54000, v32, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Baseband dropped %u packet(s) for PT %u.", buf, 0x28u);
      }
    }
    if (v16 + 2 * (unsigned __int16)*v26 > (int)a2)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v49 = VRTraceErrorLogLevelToCSTR();
        v50 = *MEMORY[0x1E0CF2758];
        result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
        if (!result)
          return result;
        v51 = (unsigned __int16)*v26;
        *(_DWORD *)buf = 136316162;
        v57 = v49;
        v58 = 2080;
        v59 = "VCBasebandNotificationParser_ParseNotification";
        v60 = 1024;
        v61 = 88;
        v62 = 1024;
        v63 = a2;
        v64 = 1024;
        v65 = v16 + 2 * v51;
        _os_log_error_impl(&dword_1D8A54000, v50, OS_LOG_TYPE_ERROR, " [%s] %s:%d Corrupted baseband notification ACK packet. Length[%d] < needed[%d]", buf, 0x28u);
      }
      return 0;
    }
    if (*v26)
    {
      v35 = 0;
      v13 = v54;
      v6 = a3;
      v36 = v54 + 1004 * v11;
      v37 = v36 + 4;
      v38 = v36 + 1004;
      v39 = v14;
      while (1)
      {
        v40 = (unsigned __int16 *)(a1 + v16);
        v41 = v12 >= (unint64_t)v40 && (unint64_t)v40 >= a1;
        v42 = v41 && v12 - (unint64_t)v40 >= 2;
        v43 = !v42 || (unint64_t)v39 >= v38;
        if (v43 || (unint64_t)v39 < v37)
          goto LABEL_91;
        *v39++ = bswap32(*v40) >> 16;
        v16 += 2;
        if (++v35 >= (unint64_t)(unsigned __int16)*v26)
          goto LABEL_60;
      }
    }
    v13 = v54;
    v6 = a3;
LABEL_60:
    ++v11;
    v14 += 502;
    v15 = v16;
  }
  while (v11 != 6);
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (ErrorLogLevelForModule >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCBasebandNotificationParser_ParseNotification_cold_3();
  }
  LOWORD(v11) = 6;
LABEL_88:
  *(_WORD *)(v6 + 20) = v11;
  return 1;
}

void *videoRulesForFormatList_0(uint64_t a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  os_log_t *v6;
  VCVideoRule *v7;
  double v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  uint8_t buf[4];
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v4 = (void *)objc_opt_new();
  if (v4)
  {
    v5 = 0;
    v6 = (os_log_t *)MEMORY[0x1E0CF2758];
    do
    {
      v7 = [VCVideoRule alloc];
      *(float *)&v8 = (float)*(unsigned int *)(a1 + v5 + 8);
      v9 = -[VCVideoRule initWithFrameWidth:frameHeight:frameRate:payload:](v7, "initWithFrameWidth:frameHeight:frameRate:payload:", *(unsigned int *)(a1 + v5), *(unsigned int *)(a1 + v5 + 4), a2, v8);
      if (v9)
      {
        v10 = (void *)v9;
        objc_msgSend(v4, "addObject:", v9);

      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v11 = VRTraceErrorLogLevelToCSTR();
        v12 = *v6;
        if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          v15 = v11;
          v16 = 2080;
          v17 = "videoRulesForFormatList";
          v18 = 1024;
          v19 = 37;
          _os_log_error_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_ERROR, " [%s] %s:%d Failed to create video rule for secondary screen !", buf, 0x1Cu);
        }
      }
      v5 += 12;
    }
    while (v5 != 60);
  }
  return v4;
}

void VCTimescaleWSOLAShiftBuffer::VCTimescaleWSOLAShiftBuffer(VCTimescaleWSOLAShiftBuffer *this, unsigned int a2)
{
  *(_QWORD *)this = malloc_type_malloc(4 * a2, 0x100004052888210uLL);
  *((_DWORD *)this + 2) = a2;
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 100 * a2;
}

void VCTimescaleWSOLAShiftBuffer::~VCTimescaleWSOLAShiftBuffer(void **this)
{
  free(*this);
}

uint64_t VCTimescaleWSOLAShiftBuffer::clear(uint64_t this)
{
  *(_DWORD *)(this + 12) = 0;
  return this;
}

uint64_t VCTimescaleWSOLAShiftBuffer::count(VCTimescaleWSOLAShiftBuffer *this)
{
  return *((unsigned int *)this + 3);
}

_DWORD *VCTimescaleWSOLAShiftBuffer::appendSamples(_DWORD *this, float *__src, unsigned int a3)
{
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  uint64_t v17;

  v5 = (uint64_t)this;
  v17 = *MEMORY[0x1E0C80C00];
  v6 = this[2];
  if (v6 - this[3] < a3)
  {
    v7 = 8 * v6;
    if (8 * v6 < this[4])
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v8 = VRTraceErrorLogLevelToCSTR();
        v9 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v11 = 136315650;
          v12 = v8;
          v13 = 2080;
          v14 = "appendSamples";
          v15 = 1024;
          v16 = 52;
          _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCTimescaleWSOLAClass is increasing size of extendedBuffer by 8x.\n", (uint8_t *)&v11, 0x1Cu);
        }
      }
      this = malloc_type_realloc(*(void **)v5, 4 * v7, 0x100004052888210uLL);
      if (this)
      {
        *(_QWORD *)v5 = this;
        *(_DWORD *)(v5 + 8) = v7;
        v6 = v7;
      }
      else
      {
        v6 = *(_DWORD *)(v5 + 8);
      }
    }
  }
  v10 = *(unsigned int *)(v5 + 12);
  if (v6 - v10 >= a3)
  {
    this = memcpy((void *)(*(_QWORD *)v5 + 4 * v10), __src, 4 * a3);
    *(_DWORD *)(v5 + 12) += a3;
  }
  return this;
}

void **VCTimescaleWSOLAShiftBuffer::removeSamples(void **this, unsigned int a2)
{
  void **v3;

  if (a2)
  {
    v3 = this;
    this = (void **)memmove(*this, (char *)*this + 4 * a2, 4 * (*((_DWORD *)this + 3) - a2));
    *((_DWORD *)v3 + 3) -= a2;
  }
  return this;
}

uint64_t VCVideoDecoder_NewVideoDecoder(_QWORD *a1, int *a2)
{
  id v3;

  v3 = +[VCVideoDecoder decoderForStreamToken:withConfig:](VCVideoDecoder, "decoderForStreamToken:withConfig:", *a2, a2);
  if (a1)
    *a1 = objc_msgSend(v3, "videoPlayerHandle");
  return 0;
}

uint64_t VCVideoDecoder_ReleaseVideoDecoder(int a1)
{
  +[VCVideoDecoder releaseVideoDecoderForStreamToken:](VCVideoDecoder, "releaseVideoDecoderForStreamToken:", a1);
  return 0;
}

uint64_t VCPacketFilterBasebandNotificationCreate(uint64_t a1, _QWORD *a2)
{
  uint64_t ClassID;

  ClassID = VCPacketFilterGetClassID();
  return VCFBOUtils_ObjectCreate(a1, a2, (uint64_t)&kVCPacketFilterBBNotificationVTable, ClassID, 52);
}

BOOL VCPacketFilterIsOfKindBasebandNotification(uint64_t a1)
{
  return VCFBOUtils_IsKindOfClass(a1, (uint64_t)&kVCPacketFilterBBNotificationVTable);
}

void _VCPacketFilterBBNotificationFinalize(uint64_t a1)
{
  const void **DerivedStorage;
  const void *v2;

  if (a1)
  {
    DerivedStorage = (const void **)CMBaseObjectGetDerivedStorage();
    if (DerivedStorage)
    {
      v2 = *DerivedStorage;
      if (v2)
        CFRelease(v2);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCPacketFilterBBNotificationFinalize_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCPacketFilterBBNotificationFinalize_cold_1();
  }
}

uint64_t _VCPacketFilterBBNotificationCopyProperty(uint64_t a1, const void *a2, uint64_t a3, _QWORD *a4)
{
  CFTypeRef *DerivedStorage;
  CFTypeRef v7;
  uint64_t result;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  NSObject *v12;
  int v13;
  uint64_t v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  const void *v20;
  __int16 v21;
  _QWORD *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCPacketFilterBBNotificationCopyProperty_cold_1();
    }
    return 4294954516;
  }
  if (!a2 || !a4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v11 = VRTraceErrorLogLevelToCSTR();
      v12 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v13 = 136316162;
        v14 = v11;
        v15 = 2080;
        v16 = "_VCPacketFilterBBNotificationCopyProperty";
        v17 = 1024;
        v18 = 59;
        v19 = 2112;
        v20 = a2;
        v21 = 2112;
        v22 = a4;
        _os_log_error_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_ERROR, " [%s] %s:%d Property name '%@' and property value out '%@' must not be NULL", (uint8_t *)&v13, 0x30u);
      }
    }
    return 4294954516;
  }
  DerivedStorage = (CFTypeRef *)CMBaseObjectGetDerivedStorage();
  if (CFEqual(a2, CFSTR("CellularUniqueTag")))
  {
    if (*DerivedStorage)
    {
      v7 = CFRetain(*DerivedStorage);
      result = 0;
      *a4 = v7;
    }
    else
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
      {
        v9 = VRTraceErrorLogLevelToCSTR();
        v10 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v13 = 136315906;
          v14 = v9;
          v15 = 2080;
          v16 = "_VCPacketFilterBBNotificationCopyProperty";
          v17 = 1024;
          v18 = 68;
          v19 = 2112;
          v20 = a2;
          _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Parameter '%@' is currently not set for packet filter", (uint8_t *)&v13, 0x26u);
        }
      }
      return 4294954513;
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCPacketFilterBBNotificationCopyProperty_cold_2();
    }
    return 4294954512;
  }
  return result;
}

uint64_t _VCPacketFilterBBNotificationSetProperty(uint64_t a1, const void *a2, const void *a3)
{
  const void **DerivedStorage;
  const void *v6;
  uint64_t v8;
  NSObject *v9;
  int v10;
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  const void *v17;
  __int16 v18;
  const void *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCPacketFilterBBNotificationSetProperty_cold_1();
    }
    return 4294954516;
  }
  if (!a2 || !a3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v8 = VRTraceErrorLogLevelToCSTR();
      v9 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v10 = 136316162;
        v11 = v8;
        v12 = 2080;
        v13 = "_VCPacketFilterBBNotificationSetProperty";
        v14 = 1024;
        v15 = 83;
        v16 = 2112;
        v17 = a2;
        v18 = 2112;
        v19 = a3;
        _os_log_error_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_ERROR, " [%s] %s:%d Property name '%@' and property value out '%@' must not be NULL", (uint8_t *)&v10, 0x30u);
      }
    }
    return 4294954516;
  }
  DerivedStorage = (const void **)CMBaseObjectGetDerivedStorage();
  if (CFEqual(a2, CFSTR("CellularUniqueTag")))
  {
    v6 = *DerivedStorage;
    *DerivedStorage = a3;
    CFRetain(a3);
    if (v6)
      CFRelease(v6);
    return 0;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCPacketFilterBBNotificationSetProperty_cold_2();
    }
    return 4294954512;
  }
}

CVPixelBufferRef VCImageResizingConverter_CreateResizedPixelBuffer(uint64_t a1, __CVBuffer *a2)
{
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  OSType PixelFormatType;
  __CVPixelBufferPool *v8;
  OSStatus v9;
  int ErrorLogLevelForModule;
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  CVPixelBufferRef v14;
  OSType v15;
  char *v16;
  size_t v17;
  size_t v18;
  OSType v20;
  CVPixelBufferRef v21;
  OSType v22;
  char *v23;
  size_t v24;
  size_t v25;
  CVPixelBufferRef pixelBufferOut;
  uint8_t buf[4];
  uint64_t v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  int v32;
  __int16 v33;
  uint64_t v34;
  __int16 v35;
  __CVBuffer *v36;
  __int16 v37;
  char *v38;
  __int16 v39;
  size_t Width;
  __int16 v41;
  size_t Height;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    v6 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        PixelFormatType = CVPixelBufferGetPixelFormatType(a2);
        *(_DWORD *)buf = 136316930;
        v28 = v4;
        v29 = 2080;
        v30 = "VCImageResizingConverter_CreateResizedPixelBuffer";
        v31 = 1024;
        v32 = 49;
        v33 = 2048;
        v34 = a1;
        v35 = 2048;
        v36 = a2;
        v37 = 2080;
        v38 = FourccToCStr(PixelFormatType);
        v39 = 2048;
        Width = CVPixelBufferGetWidth(a2);
        v41 = 2048;
        Height = CVPixelBufferGetHeight(a2);
        _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d pointer=%p, pixelBuffer=%p, formatType=%s, width=%lu, height=%lu", buf, 0x4Eu);
      }
    }
    else if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      v20 = CVPixelBufferGetPixelFormatType(a2);
      *(_DWORD *)buf = 136316930;
      v28 = v4;
      v29 = 2080;
      v30 = "VCImageResizingConverter_CreateResizedPixelBuffer";
      v31 = 1024;
      v32 = 49;
      v33 = 2048;
      v34 = a1;
      v35 = 2048;
      v36 = a2;
      v37 = 2080;
      v38 = FourccToCStr(v20);
      v39 = 2048;
      Width = CVPixelBufferGetWidth(a2);
      v41 = 2048;
      Height = CVPixelBufferGetHeight(a2);
      _os_log_debug_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEBUG, " [%s] %s:%d pointer=%p, pixelBuffer=%p, formatType=%s, width=%lu, height=%lu", buf, 0x4Eu);
    }
  }
  pixelBufferOut = 0;
  if (*(_QWORD *)(a1 + 48))
  {
    v8 = *(__CVPixelBufferPool **)(a1 + 8);
    if (v8)
    {
      if (CVPixelBufferPoolCreatePixelBuffer((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v8, &pixelBufferOut))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCImageResizingConverter_CreateResizedPixelBuffer_cold_4();
        }
      }
      else
      {
        v9 = VTPixelTransferSessionTransferImage(*(VTPixelTransferSessionRef *)(a1 + 48), a2, pixelBufferOut);
        ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
        if (v9)
        {
          if (ErrorLogLevelForModule >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VCImageResizingConverter_CreateResizedPixelBuffer_cold_3();
          }
        }
        else if (ErrorLogLevelForModule >= 8)
        {
          v11 = VRTraceErrorLogLevelToCSTR();
          v12 = *MEMORY[0x1E0CF2758];
          v13 = *MEMORY[0x1E0CF2758];
          if (*MEMORY[0x1E0CF2748])
          {
            if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
            {
              v14 = pixelBufferOut;
              v15 = CVPixelBufferGetPixelFormatType(pixelBufferOut);
              v16 = FourccToCStr(v15);
              v17 = CVPixelBufferGetWidth(pixelBufferOut);
              v18 = CVPixelBufferGetHeight(pixelBufferOut);
              *(_DWORD *)buf = 136316930;
              v28 = v11;
              v29 = 2080;
              v30 = "VCImageResizingConverter_CreateResizedPixelBuffer";
              v31 = 1024;
              v32 = 60;
              v33 = 2048;
              v34 = a1;
              v35 = 2048;
              v36 = v14;
              v37 = 2080;
              v38 = v16;
              v39 = 2048;
              Width = v17;
              v41 = 2048;
              Height = v18;
              _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d pointer=%p, newPixelBuffer=%p, formatType=%s, width=%lu, height=%lu", buf, 0x4Eu);
            }
          }
          else if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
          {
            v21 = pixelBufferOut;
            v22 = CVPixelBufferGetPixelFormatType(pixelBufferOut);
            v23 = FourccToCStr(v22);
            v24 = CVPixelBufferGetWidth(pixelBufferOut);
            v25 = CVPixelBufferGetHeight(pixelBufferOut);
            *(_DWORD *)buf = 136316930;
            v28 = v11;
            v29 = 2080;
            v30 = "VCImageResizingConverter_CreateResizedPixelBuffer";
            v31 = 1024;
            v32 = 60;
            v33 = 2048;
            v34 = a1;
            v35 = 2048;
            v36 = v21;
            v37 = 2080;
            v38 = v23;
            v39 = 2048;
            Width = v24;
            v41 = 2048;
            Height = v25;
            _os_log_debug_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEBUG, " [%s] %s:%d pointer=%p, newPixelBuffer=%p, formatType=%s, width=%lu, height=%lu", buf, 0x4Eu);
          }
        }
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCImageResizingConverter_CreateResizedPixelBuffer_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCImageResizingConverter_CreateResizedPixelBuffer_cold_1();
  }
  return pixelBufferOut;
}

CMSampleBufferRef _VCImageResizingConverter_CreateSampleBufferWithNewTiming(CMSampleBufferRef originalSBuf, uint64_t a2)
{
  __int128 v2;
  CMTimeEpoch v3;
  __int128 v4;
  CMTimeEpoch v5;
  CMSampleTimingInfo v7;
  CMSampleBufferRef sampleBufferOut[2];

  sampleBufferOut[1] = *(CMSampleBufferRef *)MEMORY[0x1E0C80C00];
  sampleBufferOut[0] = 0;
  if (originalSBuf)
  {
    v2 = *(_OWORD *)(MEMORY[0x1E0CA2E90] + 48);
    *(_OWORD *)&v7.presentationTimeStamp.timescale = *(_OWORD *)(MEMORY[0x1E0CA2E90] + 32);
    *(_OWORD *)&v7.decodeTimeStamp.value = v2;
    v3 = *(_QWORD *)(MEMORY[0x1E0CA2E90] + 64);
    v4 = *(_OWORD *)(MEMORY[0x1E0CA2E90] + 16);
    *(_OWORD *)&v7.duration.value = *MEMORY[0x1E0CA2E90];
    *(_OWORD *)&v7.duration.epoch = v4;
    *(_OWORD *)&v7.presentationTimeStamp.value = *(_OWORD *)a2;
    v5 = *(_QWORD *)(a2 + 16);
    v7.decodeTimeStamp.epoch = v3;
    v7.presentationTimeStamp.epoch = v5;
    if (CMSampleBufferCreateCopyWithNewTiming((CFAllocatorRef)*MEMORY[0x1E0C9AE00], originalSBuf, 1, &v7, sampleBufferOut))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCImageResizingConverter_CreateSampleBufferWithNewTiming_cold_2();
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCImageResizingConverter_CreateSampleBufferWithNewTiming_cold_1();
  }
  return sampleBufferOut[0];
}

void *VCMicrophonePreferencesAVAS_BuiltInMicPortDescriptionFromSelectableInputsArray(void *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  NSObject *v9;
  int v11;
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  uint64_t v18;
  __int16 v19;
  void *v20;
  _BYTE v21[128];
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCMicrophonePreferencesAVAS_BuiltInMicPortDescriptionFromSelectableInputsArray_cold_1();
    }
    return 0;
  }
  v2 = *MEMORY[0x1E0C897F8];
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  v3 = objc_msgSend(a1, "countByEnumeratingWithState:objects:count:", &v22, v21, 16);
  if (!v3)
  {
LABEL_10:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v8 = VRTraceErrorLogLevelToCSTR();
      v9 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v11 = 136316162;
        v12 = v8;
        v13 = 2080;
        v14 = "VCMicrophonePreferencesAVAS_BuiltInMicPortDescriptionFromSelectableInputsArray";
        v15 = 1024;
        v16 = 32;
        v17 = 2112;
        v18 = v2;
        v19 = 2112;
        v20 = a1;
        _os_log_error_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_ERROR, " [%s] %s:%d desiredPortType=%@ was not found in selectableInputs=%@", (uint8_t *)&v11, 0x30u);
      }
    }
    return 0;
  }
  v4 = v3;
  v5 = *(_QWORD *)v23;
LABEL_4:
  v6 = 0;
  while (1)
  {
    if (*(_QWORD *)v23 != v5)
      objc_enumerationMutation(a1);
    v7 = *(void **)(*((_QWORD *)&v22 + 1) + 8 * v6);
    if ((objc_msgSend((id)objc_msgSend(v7, "portType"), "isEqualToString:", v2) & 1) != 0)
      return v7;
    if (v4 == ++v6)
    {
      v4 = objc_msgSend(a1, "countByEnumeratingWithState:objects:count:", &v22, v21, 16);
      if (v4)
        goto LABEL_4;
      goto LABEL_10;
    }
  }
}

uint64_t VCMicrophonePreferencesAVAS_DataSourcesFromPortDescription(void *a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v3;
  _QWORD *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  void *v15;
  BOOL v17;
  id v18;
  uint64_t result;
  uint64_t v20;
  NSObject *v21;
  uint64_t v22;
  NSObject *v23;
  _QWORD *v24;
  _QWORD *v25;
  _BYTE v26[128];
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  uint8_t buf[4];
  uint64_t v32;
  __int16 v33;
  const char *v34;
  __int16 v35;
  int v36;
  __int16 v37;
  _QWORD *v38;
  __int16 v39;
  _QWORD *v40;
  uint64_t v41;

  v3 = a3;
  v4 = a2;
  v41 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a2 && a3)
    {
      v5 = (void *)objc_msgSend(a1, "dataSources");
      v27 = 0u;
      v28 = 0u;
      v29 = 0u;
      v30 = 0u;
      v6 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v27, v26, 16);
      if (v6)
      {
        v7 = v6;
        v24 = v4;
        v25 = v3;
        v8 = 0;
        v9 = 0;
        v10 = *(_QWORD *)v28;
        v11 = *MEMORY[0x1E0C897A0];
        v12 = *MEMORY[0x1E0C89798];
LABEL_6:
        v13 = 0;
        while (1)
        {
          if (*(_QWORD *)v28 != v10)
            objc_enumerationMutation(v5);
          v14 = *(void **)(*((_QWORD *)&v27 + 1) + 8 * v13);
          v15 = (void *)objc_msgSend(v14, "orientation", v24);
          if ((objc_msgSend(v15, "isEqualToString:", v11) & 1) != 0)
          {
            v8 = v14;
          }
          else if (objc_msgSend(v15, "isEqualToString:", v12))
          {
            v9 = v14;
          }
          if (v8 && v9 != 0)
            break;
          if (v7 == ++v13)
          {
            v7 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v27, v26, 16);
            if (v7)
              goto LABEL_6;
            break;
          }
        }
        if (v8)
          v17 = v9 == 0;
        else
          v17 = 1;
        v3 = v25;
        if (!v17)
        {
          *v24 = v8;
          v18 = v9;
          result = 1;
LABEL_33:
          *v3 = v18;
          return result;
        }
        v4 = v24;
      }
      else
      {
        v9 = 0;
        v8 = 0;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v20 = VRTraceErrorLogLevelToCSTR();
        v21 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316162;
          v32 = v20;
          v33 = 2080;
          v34 = "VCMicrophonePreferencesAVAS_DataSourcesFromPortDescription";
          v35 = 1024;
          v36 = 60;
          v37 = 2048;
          v38 = v8;
          v39 = 2048;
          v40 = v9;
          _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Did not find both orientations: front=%p, back=%p", buf, 0x30u);
        }
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v22 = VRTraceErrorLogLevelToCSTR();
      v23 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136316162;
        v32 = v22;
        v33 = 2080;
        v34 = "VCMicrophonePreferencesAVAS_DataSourcesFromPortDescription";
        v35 = 1024;
        v36 = 40;
        v37 = 2048;
        v38 = v4;
        v39 = 2048;
        v40 = v3;
        _os_log_error_impl(&dword_1D8A54000, v23, OS_LOG_TYPE_ERROR, " [%s] %s:%d frontDataSource [%p] or backDataSource [%p] == nil", buf, 0x30u);
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCMicrophonePreferencesAVAS_DataSourcesFromPortDescription_cold_1();
  }
  if (v4)
    *v4 = 0;
  result = 0;
  if (v3)
  {
    v18 = 0;
    goto LABEL_33;
  }
  return result;
}

id VCMicrophonePreferencesAVAS_InitSelectedInputDictWithPolarPattern(uint64_t a1, void *a2)
{
  void *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  id v14;
  void *v15;
  void *v16;
  uint64_t v18;
  NSObject *v19;
  _QWORD v20[2];
  _QWORD v21[2];
  _QWORD v22[3];
  _QWORD v23[3];
  uint8_t buf[4];
  uint64_t v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  void *v31;
  __int16 v32;
  void *v33;
  __int16 v34;
  void *v35;
  uint8_t v36[4];
  uint64_t v37;
  __int16 v38;
  const char *v39;
  __int16 v40;
  int v41;
  __int16 v42;
  uint64_t v43;
  __int16 v44;
  void *v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  _QWORD v50[3];

  v50[2] = *MEMORY[0x1E0C80C00];
  if (a1 && a2)
  {
    v4 = (void *)objc_msgSend(a2, "supportedPolarPatterns");
    v5 = *MEMORY[0x1E0C897B8];
    v50[0] = *MEMORY[0x1E0C897B0];
    v50[1] = v5;
    v6 = (void *)objc_msgSend(MEMORY[0x1E0C99E60], "setWithArray:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v50, 2));
    v46 = 0u;
    v47 = 0u;
    v48 = 0u;
    v49 = 0u;
    v7 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v46, v36, 16);
    if (v7)
    {
      v8 = v7;
      v9 = *(_QWORD *)v47;
LABEL_5:
      v10 = 0;
      while (1)
      {
        if (*(_QWORD *)v47 != v9)
          objc_enumerationMutation(v4);
        v11 = *(void **)(*((_QWORD *)&v46 + 1) + 8 * v10);
        if ((objc_msgSend(v6, "containsObject:", v11) & 1) != 0)
          break;
        if (v8 == ++v10)
        {
          v8 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v46, v36, 16);
          if (v8)
            goto LABEL_5;
          goto LABEL_11;
        }
      }
      v14 = v11;
      if (!v14)
        goto LABEL_16;
      v15 = v14;
      v22[0] = CFSTR("port");
      v22[1] = CFSTR("dataSource");
      v23[0] = a1;
      v23[1] = a2;
      v22[2] = CFSTR("polarPattern");
      v23[2] = v14;
      v16 = (void *)objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v23, v22, 3);
    }
    else
    {
LABEL_11:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v12 = VRTraceErrorLogLevelToCSTR();
        v13 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136316418;
          v25 = v12;
          v26 = 2080;
          v27 = "_VCMicrophonePreferencesAVAS_CopyOptimalMicPolarPatternFromDataSource";
          v28 = 1024;
          v29 = 94;
          v30 = 2112;
          v31 = v6;
          v32 = 2112;
          v33 = v4;
          v34 = 2112;
          v35 = a2;
          _os_log_error_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_ERROR, " [%s] %s:%d Did not find any desiredPolarPatterns=%@ in supportedPolarPatterns=%@ for dataSource=%@", buf, 0x3Au);
        }
      }
LABEL_16:
      v20[0] = CFSTR("port");
      v20[1] = CFSTR("dataSource");
      v21[0] = a1;
      v21[1] = a2;
      v16 = (void *)objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v21, v20, 2);
      v15 = 0;
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v18 = VRTraceErrorLogLevelToCSTR();
      v19 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v36 = 136316162;
        v37 = v18;
        v38 = 2080;
        v39 = "VCMicrophonePreferencesAVAS_InitSelectedInputDictWithPolarPattern";
        v40 = 1024;
        v41 = 101;
        v42 = 2048;
        v43 = a1;
        v44 = 2048;
        v45 = a2;
        _os_log_error_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_ERROR, " [%s] %s:%d inPort [%p] or inSource [%p] == nil", v36, 0x30u);
      }
    }
    v15 = 0;
    v16 = 0;
  }

  return v16;
}

uint64_t VCMicrophonePreferencesAVAS_ApplyMicrophonePreferences(void *a1, void *a2)
{
  void *v4;
  void *v5;
  uint64_t v6;
  _BOOL8 v7;
  uint64_t v8;
  int v9;
  void *v10;
  int ErrorLogLevelForModule;
  uint64_t v12;
  NSObject *v13;
  int v14;
  void *v15;
  int v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v20;
  NSObject *v21;
  const char *v22;
  NSObject *v23;
  uint32_t v24;
  uint64_t v25;
  NSObject *v26;
  void *v27;
  uint8_t buf[4];
  uint64_t v29;
  __int16 v30;
  const char *v31;
  __int16 v32;
  int v33;
  __int16 v34;
  uint64_t v35;
  __int16 v36;
  void *v37;
  __int16 v38;
  void *v39;
  __int16 v40;
  void *v41;
  __int16 v42;
  void *v43;
  __int16 v44;
  void *v45;
  __int16 v46;
  void *v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCMicrophonePreferencesAVAS_ApplyMicrophonePreferences_cold_1();
    }
    return 0;
  }
  v4 = (void *)objc_msgSend(a2, "objectForKeyedSubscript:", CFSTR("port"));
  v5 = (void *)objc_msgSend(a2, "objectForKeyedSubscript:", CFSTR("dataSource"));
  v6 = objc_msgSend(a2, "objectForKeyedSubscript:", CFSTR("polarPattern"));
  v27 = 0;
  v7 = v6 != 0;
  if (v6)
  {
    v8 = v6;
    v9 = objc_msgSend(v5, "setPreferredPolarPattern:error:", v6, &v27);
    v10 = v27;
    ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    if (!v9 || v10)
    {
      if (ErrorLogLevelForModule < 3)
        return 0;
      v20 = VRTraceErrorLogLevelToCSTR();
      v21 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        return 0;
      *(_DWORD *)buf = 136317186;
      v29 = v20;
      v30 = 2080;
      v31 = "VCMicrophonePreferencesAVAS_ApplyMicrophonePreferences";
      v32 = 1024;
      v33 = 134;
      v34 = 2112;
      v35 = v8;
      v36 = 2048;
      v37 = v5;
      v38 = 2112;
      v39 = v5;
      v40 = 2048;
      v41 = a1;
      v42 = 2112;
      v43 = a1;
      v44 = 2112;
      v45 = v27;
      v22 = " [%s] %s:%d Failed to set selectedPolarPattern=%@ on selectedDataSource=%p [%@] for inAVAudioSession=%p [%@] with error=%@";
      v23 = v21;
      v24 = 88;
      goto LABEL_26;
    }
    if (ErrorLogLevelForModule >= 7)
    {
      v12 = VRTraceErrorLogLevelToCSTR();
      v13 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        v29 = v12;
        v30 = 2080;
        v31 = "VCMicrophonePreferencesAVAS_ApplyMicrophonePreferences";
        v32 = 1024;
        v33 = 135;
        v34 = 2112;
        v35 = v8;
        _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d setPreferredPolarPattern=%@ completed successfully", buf, 0x26u);
      }
    }
  }
  if (!v5)
    return v7;
  v14 = objc_msgSend(v4, "setPreferredDataSource:error:", v5, &v27);
  v15 = v27;
  v16 = VRTraceGetErrorLogLevelForModule();
  if (!v14 || v15)
  {
    if (v16 < 3)
      return 0;
    v25 = VRTraceErrorLogLevelToCSTR();
    v26 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      return 0;
    *(_DWORD *)buf = 136317442;
    v29 = v25;
    v30 = 2080;
    v31 = "VCMicrophonePreferencesAVAS_ApplyMicrophonePreferences";
    v32 = 1024;
    v33 = 139;
    v34 = 2048;
    v35 = (uint64_t)v5;
    v36 = 2112;
    v37 = v5;
    v38 = 2048;
    v39 = v4;
    v40 = 2112;
    v41 = v4;
    v42 = 2048;
    v43 = a1;
    v44 = 2112;
    v45 = a1;
    v46 = 2112;
    v47 = v27;
    v22 = " [%s] %s:%d Failed to set selectedDataSource=%p [%@] on selectedPort=%p [%@] for inAVAudioSession=%p [%@] with error=%@";
    v23 = v26;
    v24 = 98;
LABEL_26:
    _os_log_error_impl(&dword_1D8A54000, v23, OS_LOG_TYPE_ERROR, v22, buf, v24);
    return 0;
  }
  if (v16 >= 7)
  {
    v17 = VRTraceErrorLogLevelToCSTR();
    v18 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      v29 = v17;
      v30 = 2080;
      v31 = "VCMicrophonePreferencesAVAS_ApplyMicrophonePreferences";
      v32 = 1024;
      v33 = 140;
      v34 = 2112;
      v35 = (uint64_t)v5;
      _os_log_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d setPreferredDataSource=%@ completed with successfully", buf, 0x26u);
    }
  }
  return 1;
}

uint64_t VCHardwareSettingsEmbedded_AACELDPacketLossConcealmentAlgorithm()
{
  return -[VCHardwareSettingsEmbedded audioPacketLossConcealmentAlgorithmAACELD](+[VCHardwareSettingsEmbedded sharedInstance](VCHardwareSettingsEmbedded, "sharedInstance"), "audioPacketLossConcealmentAlgorithmAACELD");
}

void __loadAppleCVAFaceTrackingSymbols_block_invoke()
{
  uint64_t v0;
  NSObject *v1;
  uint64_t *v2;
  int v3;
  uint64_t v4;
  __int16 v5;
  const char *v6;
  __int16 v7;
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (VCLoadAppleCVA_loadPredicate != -1)
    dispatch_once(&VCLoadAppleCVA_loadPredicate, &__block_literal_global_65);
  if (sVCAppleCVAFrameworkLibrary)
  {
    if (sVC_CVAFaceTracking_DetectedFacesArray)
      goto LABEL_5;
    v2 = (uint64_t *)dlsym((void *)sVCAppleCVAFrameworkLibrary, "kCVAFaceTracking_DetectedFacesArray");
    if (!v2)
    {
      sVC_CVAFaceTracking_DetectedFacesArray = 0;
      return;
    }
    sVC_CVAFaceTracking_DetectedFacesArray = *v2;
    if (sVC_CVAFaceTracking_DetectedFacesArray)
    {
LABEL_5:
      loadAppleCVAFaceTrackingSymbols_loaded = 1;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v0 = VRTraceErrorLogLevelToCSTR();
        v1 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v3 = 136315650;
          v4 = v0;
          v5 = 2080;
          v6 = "loadAppleCVAFaceTrackingSymbols_block_invoke";
          v7 = 1024;
          v8 = 62;
          _os_log_impl(&dword_1D8A54000, v1, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Loaded AppleCVA FaceTracking symbols", (uint8_t *)&v3, 0x1Cu);
        }
      }
    }
  }
}

uint64_t VCGetCVAFaceTracking_DetectedFacesArray()
{
  if (loadAppleCVAFaceTrackingSymbols_onceToken != -1)
    dispatch_once(&loadAppleCVAFaceTrackingSymbols_onceToken, &__block_literal_global_3);
  return sVC_CVAFaceTracking_DetectedFacesArray;
}

void __loadAppleCVAViewpointCorrectionSymbols_block_invoke()
{
  void *v0;
  uint64_t *v1;
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  NSObject *v19;
  int v20;
  uint64_t v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (VCLoadAppleCVA_loadPredicate != -1)
    dispatch_once(&VCLoadAppleCVA_loadPredicate, &__block_literal_global_65);
  v0 = (void *)sVCAppleCVAFrameworkLibrary;
  if (sVCAppleCVAFrameworkLibrary)
  {
    if (!sVC_CVAViewpointCorrection_Image)
    {
      v1 = (uint64_t *)dlsym((void *)sVCAppleCVAFrameworkLibrary, "kCVAViewpointCorrection_Image");
      if (v1)
        v2 = *v1;
      else
        v2 = 0;
      sVC_CVAViewpointCorrection_Image = v2;
      v0 = (void *)sVCAppleCVAFrameworkLibrary;
    }
    if (!sVC_CVAViewpointCorrection_Intrinsics)
    {
      v3 = (uint64_t *)dlsym(v0, "kCVAViewpointCorrection_Intrinsics");
      if (v3)
        v4 = *v3;
      else
        v4 = 0;
      sVC_CVAViewpointCorrection_Intrinsics = v4;
      v0 = (void *)sVCAppleCVAFrameworkLibrary;
    }
    if (!sVC_CVAViewpointCorrection_VirtualCameraExtrinsics)
    {
      v5 = (uint64_t *)dlsym(v0, "kCVAViewpointCorrection_VirtualCameraExtrinsics");
      if (v5)
        v6 = *v5;
      else
        v6 = 0;
      sVC_CVAViewpointCorrection_VirtualCameraExtrinsics = v6;
      v0 = (void *)sVCAppleCVAFrameworkLibrary;
    }
    if (!sVC_CVAViewpointCorrection_StereographicFisheyeStrength)
    {
      v7 = (uint64_t *)dlsym(v0, "kCVAViewpointCorrection_StereographicFisheyeStrength");
      if (v7)
        v8 = *v7;
      else
        v8 = 0;
      sVC_CVAViewpointCorrection_StereographicFisheyeStrength = v8;
      v0 = (void *)sVCAppleCVAFrameworkLibrary;
    }
    if (!sVC_CVAViewpointCorrection_Timestamp)
    {
      v9 = (uint64_t *)dlsym(v0, "kCVAViewpointCorrection_Timestamp");
      if (v9)
        v10 = *v9;
      else
        v10 = 0;
      sVC_CVAViewpointCorrection_Timestamp = v10;
      v0 = (void *)sVCAppleCVAFrameworkLibrary;
    }
    if (!sVC_CVAViewpointCorrection_Callback)
    {
      v11 = (uint64_t *)dlsym(v0, "kCVAViewpointCorrection_Callback");
      if (v11)
        v12 = *v11;
      else
        v12 = 0;
      sVC_CVAViewpointCorrection_Callback = v12;
      v0 = (void *)sVCAppleCVAFrameworkLibrary;
    }
    if (!sVC_CVAViewpointCorrection_ModificationStatus)
    {
      v13 = (uint64_t *)dlsym(v0, "kCVAViewpointCorrection_ModificationStatus");
      if (v13)
        v14 = *v13;
      else
        v14 = 0;
      sVC_CVAViewpointCorrection_ModificationStatus = v14;
      v0 = (void *)sVCAppleCVAFrameworkLibrary;
    }
    if (!sVC_CVAViewpointCorrection_EnableCorrection)
    {
      v15 = (uint64_t *)dlsym(v0, "kCVAViewpointCorrection_EnableCorrection");
      if (v15)
        v16 = *v15;
      else
        v16 = 0;
      sVC_CVAViewpointCorrection_EnableCorrection = v16;
      v0 = (void *)sVCAppleCVAFrameworkLibrary;
    }
    sVC_CVAViewpointCorrectionProcessFunc = (uint64_t (*)(_QWORD, _QWORD))dlsym(v0, "CVAViewpointCorrectionProcess");
    v17 = dlsym((void *)sVCAppleCVAFrameworkLibrary, "CVAViewpointCorrectionCreate");
    sVC_CVAViewpointCorrectionCreateFunc = (uint64_t (*)(_QWORD, _QWORD, _QWORD))v17;
    if (sVC_CVAViewpointCorrection_Image)
    {
      if (sVC_CVAViewpointCorrection_Intrinsics)
      {
        if (sVC_CVAViewpointCorrection_VirtualCameraExtrinsics)
        {
          if (sVC_CVAViewpointCorrection_Timestamp)
          {
            if (sVC_CVAViewpointCorrection_Callback)
            {
              if (sVC_CVAViewpointCorrection_EnableCorrection)
              {
                if (sVC_CVAViewpointCorrectionProcessFunc)
                {
                  if (v17)
                  {
                    loadAppleCVAViewpointCorrectionSymbols_loaded = 1;
                    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
                    {
                      v18 = VRTraceErrorLogLevelToCSTR();
                      v19 = *MEMORY[0x1E0CF2758];
                      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                      {
                        v20 = 136315650;
                        v21 = v18;
                        v22 = 2080;
                        v23 = "loadAppleCVAViewpointCorrectionSymbols_block_invoke";
                        v24 = 1024;
                        v25 = 97;
                        _os_log_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Loaded AppleCVA Viewpoint Correction symbols", (uint8_t *)&v20, 0x1Cu);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

int32x4_t *_VCViewpointCorrection_UpdateCenterStageTransform(uint64_t a1, CMAttachmentBearerRef target)
{
  int32x4_t *result;
  unsigned __int8 v4;
  int32x4_t v5;
  int32x4_t v6;
  int32x4_t v7;
  float32x2x2_t v8;
  int32x4_t v9;
  float *v10;
  float *v11;
  uint64_t i;
  unsigned int v13;
  _DWORD v14[8];
  _QWORD v15[4];
  float32x2x2_t v16;

  v15[3] = *MEMORY[0x1E0C80C00];
  if (!target)
    return 0;
  result = (int32x4_t *)CMGetAttachment(target, (CFStringRef)*MEMORY[0x1E0D040F8], 0);
  if (result)
  {
    result = (int32x4_t *)CFDataGetBytePtr((CFDataRef)result);
    if (result)
    {
      v4 = 0;
      v5 = result[1];
      v6 = result[2];
      v7 = result[3];
      v8 = (float32x2x2_t)vzip1q_s32(*result, v6);
      v16.val[0] = (float32x2_t)vzip2q_s32(*result, v6).u64[0];
      v9 = vzip1q_s32(v5, v7);
      v16.val[1] = (float32x2_t)vzip2q_s32(v5, v7).u64[0];
      v10 = (float *)v14;
      vst2_f32(v10, v8);
      v10 += 4;
      *(int32x4_t *)v10 = vzip2q_s32((int32x4_t)v8, v9);
      v11 = (float *)v15;
      vst2_f32(v11, v16);
      do
      {
        for (i = 0; i != 12; i += 4)
          *(_DWORD *)(a1 + i * 4 + 4 * v4) = v14[i + (v4 & 3)];
        v13 = v4++;
      }
      while (v13 < 2);
      return (int32x4_t *)1;
    }
  }
  return result;
}

uint64_t VCSecurityKeyHolder_CopyKeyManager(uint64_t a1)
{
  if (a1)
    JUMPOUT(0x1DF086F1CLL);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCSecurityKeyHolder_CopyKeyManager_cold_1();
  }
  return 0;
}

uint64_t VCSecurityKeyHolder_SecurityKeyMode(uint64_t a1)
{
  if (a1)
  {
    return *(char *)(a1 + 57);
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCSecurityKeyHolder_SecurityKeyMode_cold_1();
    }
    return -1;
  }
}

uint64_t _VCSecurityKeyHolderClassRegister(uint64_t *a1)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

uint64_t VCSecurityKeyHolder_Create(uint64_t a1, uint64_t a2, int a3, uint64_t a4, char a5, unsigned int a6, uint64_t *a7)
{
  char v8;
  uint64_t Instance;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  uint64_t v17;
  int v19;
  uint64_t v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (a7)
  {
    if (a2)
    {
      if ((a3 - 4) <= 0xFFFFFFFC)
      {
        v14 = 2151612417;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCSecurityKeyHolder_Create_cold_3();
        }
      }
      else
      {
        v8 = a6;
        if (a6 >= 3)
        {
          v14 = 2151612417;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VCSecurityKeyHolder_Create_cold_4();
          }
        }
        else
        {
          if (VCSecurityKeyHolderGetTypeID_initOnce != -1)
            dispatch_once_f(&VCSecurityKeyHolderGetTypeID_initOnce, &VCSecurityKeyHolderGetTypeID_typeID, (dispatch_function_t)_VCSecurityKeyHolderClassRegister);
          Instance = _CFRuntimeCreateInstance();
          if (Instance)
          {
            v13 = Instance;
            *(_OWORD *)(Instance + 16) = 0u;
            *(_OWORD *)(Instance + 32) = 0u;
            *(_OWORD *)(Instance + 48) = 0u;
            *(_DWORD *)(Instance + 40) = 0;
            *(_DWORD *)(Instance + 16) = a3;
            FigCFWeakReferenceStore();
            *(_QWORD *)(v13 + 48) = a4;
            *(_BYTE *)(v13 + 56) = a5;
            *(_BYTE *)(v13 + 57) = v8;
            *a7 = v13;
            v14 = 0;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v15 = VRTraceErrorLogLevelToCSTR();
              v16 = *MEMORY[0x1E0CF2758];
              v14 = 0;
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                v17 = *a7;
                v19 = 136315906;
                v20 = v15;
                v21 = 2080;
                v22 = "VCSecurityKeyHolder_Create";
                v23 = 1024;
                v24 = 170;
                v25 = 2048;
                v26 = v17;
                _os_log_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d keyHolder instance '%p' created", (uint8_t *)&v19, 0x26u);
                return 0;
              }
            }
          }
          else if ((int)VRTraceGetErrorLogLevelForModule() < 3)
          {
            return 2151612419;
          }
          else
          {
            VRTraceErrorLogLevelToCSTR();
            v14 = 2151612419;
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VCSecurityKeyHolder_Create_cold_5();
          }
        }
      }
    }
    else
    {
      v14 = 2151612417;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCSecurityKeyHolder_Create_cold_2();
      }
    }
  }
  else
  {
    v14 = 2151612417;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCSecurityKeyHolder_Create_cold_1();
    }
  }
  return v14;
}

uint64_t VCSecurityKeyHolder_CopyKeyMaterialForKeyIndex(uint64_t a1, const char *a2, uint64_t *a3)
{
  void *v6;
  const void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (a1)
  {
    if (a3)
    {
      v6 = (void *)MEMORY[0x1DF086F1C](a1 + 24);
      if (v6)
      {
        v7 = v6;
        if (a2)
        {
          if (*(_BYTE *)(a1 + 56))
            v8 = *(_QWORD *)(a1 + 48);
          else
            v8 = 0;
          v9 = VCSecurityKeyManager_CopyMKMWithPrefixForParticipant(v6, a2, v8);
        }
        else
        {
          v9 = (uint64_t)VCSecurityKeyManager_CopyLatestSendKeyMaterial(v6, *(char *)(a1 + 57));
        }
        *a3 = v9;
        CFRelease(v7);
        return 0;
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      {
        return 2151612477;
      }
      else
      {
        VRTraceErrorLogLevelToCSTR();
        v10 = 2151612477;
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCSecurityKeyHolder_CopyKeyMaterialForKeyIndex_cold_3();
      }
    }
    else
    {
      v10 = 2151612417;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCSecurityKeyHolder_CopyKeyMaterialForKeyIndex_cold_2();
      }
    }
  }
  else
  {
    v10 = 2151612417;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCSecurityKeyHolder_CopyKeyMaterialForKeyIndex_cold_1();
    }
  }
  return v10;
}

uint64_t VCSecurityKeyHolder_RegisterForKeyMaterialChangeNotification(uint64_t a1, const void *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  int v7;
  __CFNotificationCenter *LocalCenter;
  __CFNotificationCenter *v9;
  uint64_t v10;

  if (a1)
  {
    v4 = MEMORY[0x1DF086F1C](a1 + 24);
    if (v4)
    {
      v5 = (const void *)v4;
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 40));
      v6 = *(const void **)(a1 + 32);
      if (v6)
      {
        _Block_release(v6);
        *(_QWORD *)(a1 + 32) = 0;
        if (a2)
        {
          *(_QWORD *)(a1 + 32) = _Block_copy(a2);
LABEL_12:
          os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 40));
          CFRelease(v5);
          return 0;
        }
      }
      else if (a2)
      {
        *(_QWORD *)(a1 + 32) = _Block_copy(a2);
        v7 = *(_DWORD *)(a1 + 16);
        if ((v7 | 2) == 3)
        {
          LocalCenter = CFNotificationCenterGetLocalCenter();
          CFNotificationCenterAddObserver(LocalCenter, (const void *)a1, (CFNotificationCallback)_VCSecurityKeyHolder_KeyMaterialCallback, CFSTR("VCSecurityKeyManagerNotification_SendKeyMaterialChanged"), v5, CFNotificationSuspensionBehaviorDeliverImmediately);
          v7 = *(_DWORD *)(a1 + 16);
        }
        if ((v7 & 0xFFFFFFFE) == 2)
        {
          v9 = CFNotificationCenterGetLocalCenter();
          CFNotificationCenterAddObserver(v9, (const void *)a1, (CFNotificationCallback)_VCSecurityKeyHolder_KeyMaterialCallback, CFSTR("VCSecurityKeyManagerNotification_ReceiveKeyMaterialChanged"), v5, CFNotificationSuspensionBehaviorDeliverImmediately);
        }
        goto LABEL_12;
      }
      _VCSecurityKeyHolder_UnregisterKeyMaterialNotification(a1);
      goto LABEL_12;
    }
    v10 = 2151612432;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        VCSecurityKeyHolder_RegisterForKeyMaterialChangeNotification_cold_2();
        return 2151612432;
      }
    }
  }
  else
  {
    v10 = 2151612417;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCSecurityKeyHolder_RegisterForKeyMaterialChangeNotification_cold_1();
    }
  }
  return v10;
}

void _VCSecurityKeyHolder_KeyMaterialCallback(uint64_t a1, uint64_t a2, const __CFString *a3, const void *a4, const void *a5)
{
  uint64_t v9;
  NSObject *v10;
  const void *v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  const void *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v9 = VRTraceErrorLogLevelToCSTR();
    v10 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v15 = 136316162;
      v16 = v9;
      v17 = 2080;
      v18 = "_VCSecurityKeyHolder_KeyMaterialCallback";
      v19 = 1024;
      v20 = 95;
      v21 = 2048;
      v22 = a2;
      v23 = 2112;
      v24 = a5;
      _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Received Uplink notification for keyHolder instance '%p' with key material '%@'", (uint8_t *)&v15, 0x30u);
    }
  }
  v11 = (const void *)VCSecurityKeyHolder_CopyKeyManager(a2);
  if (v11 == a4)
  {
    if (CFStringCompare(a3, CFSTR("VCSecurityKeyManagerNotification_SendKeyMaterialChanged"), 0)
      && CFStringCompare(a3, CFSTR("VCSecurityKeyManagerNotification_ReceiveKeyMaterialChanged"), 0))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCSecurityKeyHolder_KeyMaterialCallback_cold_1();
      }
    }
    else
    {
      os_unfair_lock_lock((os_unfair_lock_t)(a2 + 40));
      v14 = *(_QWORD *)(a2 + 32);
      if (v14)
        (*(void (**)(uint64_t, const void *))(v14 + 16))(v14, a5);
      os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 40));
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v12 = VRTraceErrorLogLevelToCSTR();
    v13 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      v15 = 136316162;
      v16 = v12;
      v17 = 2080;
      v18 = "_VCSecurityKeyHolder_KeyMaterialCallback";
      v19 = 1024;
      v20 = 112;
      v21 = 2048;
      v22 = (uint64_t)v11;
      v23 = 2048;
      v24 = a4;
      _os_log_error_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_ERROR, " [%s] %s:%d Notification from wrong VCSecurityKeyManager instance received: Expected instance '%llu' but got '%llu'", (uint8_t *)&v15, 0x30u);
    }
  }
  if (v11)
    CFRelease(v11);
}

void _VCSecurityKeyHolder_UnregisterKeyMaterialNotification(uint64_t a1)
{
  const void *v2;
  int v3;
  __CFNotificationCenter *LocalCenter;
  __CFNotificationCenter *v5;
  const void *v6;

  v2 = (const void *)VCSecurityKeyHolder_CopyKeyManager(a1);
  v3 = *(_DWORD *)(a1 + 16);
  if ((v3 | 2) == 3)
  {
    LocalCenter = CFNotificationCenterGetLocalCenter();
    CFNotificationCenterRemoveObserver(LocalCenter, (const void *)a1, CFSTR("VCSecurityKeyManagerNotification_SendKeyMaterialChanged"), v2);
    v3 = *(_DWORD *)(a1 + 16);
  }
  if ((v3 & 0xFFFFFFFE) == 2)
  {
    v5 = CFNotificationCenterGetLocalCenter();
    CFNotificationCenterRemoveObserver(v5, (const void *)a1, CFSTR("VCSecurityKeyManagerNotification_ReceiveKeyMaterialChanged"), v2);
  }
  v6 = *(const void **)(a1 + 32);
  if (v6)
    _Block_release(v6);
  if (v2)
    CFRelease(v2);
}

uint64_t VCSecurityKeyHolder_AssociateKeyIndex(uint64_t a1, const char *a2)
{
  uint64_t v2;

  if (a1)
  {
    if (a2)
    {
      VCSecurityKeyManager_AssociateKeyIndex(*(void **)(a1 + 24), a2, *(_QWORD *)(a1 + 48));
      return 0;
    }
    else
    {
      v2 = 2151612417;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCSecurityKeyHolder_AssociateKeyIndex_cold_2();
      }
    }
  }
  else
  {
    v2 = 2151612417;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCSecurityKeyHolder_AssociateKeyIndex_cold_1();
    }
  }
  return v2;
}

void _VCSecurityKeyHolder_Finalize(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  __int16 v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  _VCSecurityKeyHolder_UnregisterKeyMaterialNotification(a1);
  FigCFWeakReferenceStore();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136315906;
      v5 = v2;
      v6 = 2080;
      v7 = "_VCSecurityKeyHolder_Finalize";
      v8 = 1024;
      v9 = 42;
      v10 = 2048;
      v11 = a1;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d keyHolder instance '%p' finalized", (uint8_t *)&v4, 0x26u);
    }
  }
}

void OUTLINED_FUNCTION_12_8(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x44u);
}

uint64_t OUTLINED_FUNCTION_14_11(uint64_t a1, void *a2)
{
  return objc_msgSend(a2, "groupID");
}

uint64_t OUTLINED_FUNCTION_16_4()
{
  void *v0;

  return objc_msgSend(v0, "syncGroupID");
}

uint64_t OUTLINED_FUNCTION_17_1()
{
  void *v0;

  return objc_msgSend(v0, "mediaSubtype");
}

uint64_t OUTLINED_FUNCTION_18_3()
{
  void *v0;

  return objc_msgSend(v0, "mediaType");
}

uint64_t _VCDTMFToneGenerator_GenerateNextSample(_DWORD *a1)
{
  int v1;
  int v2;
  int v3;
  unsigned int v4;
  int v5;

  v1 = a1[4];
  v2 = a1[2];
  v3 = a1[6];
  v4 = ((v3 * a1[1] + 0x2000) >> 14) - a1[5];
  v5 = (__int16)(((v1 * *a1 + 0x2000) >> 14) - a1[3]);
  a1[3] = v1;
  a1[4] = v5;
  a1[5] = v3;
  a1[6] = (__int16)v4;
  return (__int16)((((23171 * v5 + ((int)(v4 << 16) >> 1) + 0x4000) >> 15) * v2 + 0x2000) >> 14);
}

_DWORD *VCDTMFToneGenerator_Create()
{
  _DWORD *result;

  result = malloc_type_malloc(0x1CuLL, 0x100004027586B93uLL);
  if (result)
    result[2] = -1;
  return result;
}

void VCDTMFToneGenerator_Destroy(void **a1)
{
  void *v2;

  if (a1)
  {
    v2 = *a1;
    if (v2)
      free(v2);
    *a1 = 0;
  }
}

uint64_t VCDTMFToneGenerator_Reinit(uint64_t a1, unsigned int a2, unsigned int a3, int a4)
{
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  int v14;
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  unsigned int v23;
  __int16 v24;
  unsigned int v25;
  __int16 v26;
  int v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v8 = VRTraceErrorLogLevelToCSTR();
    v9 = *MEMORY[0x1E0CF2758];
    v10 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        v14 = 136316674;
        v15 = v8;
        v16 = 2080;
        v17 = "VCDTMFToneGenerator_Reinit";
        v18 = 1024;
        v19 = 199;
        v20 = 2048;
        v21 = a1;
        v22 = 1024;
        v23 = a2;
        v24 = 1024;
        v25 = a3;
        v26 = 1024;
        v27 = a4;
        _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCDTMFToneGenerator[%p] Initialize event=%d, powerLevel=%d, sampleRate=%d", (uint8_t *)&v14, 0x38u);
      }
    }
    else if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      v14 = 136316674;
      v15 = v8;
      v16 = 2080;
      v17 = "VCDTMFToneGenerator_Reinit";
      v18 = 1024;
      v19 = 199;
      v20 = 2048;
      v21 = a1;
      v22 = 1024;
      v23 = a2;
      v24 = 1024;
      v25 = a3;
      v26 = 1024;
      v27 = a4;
      _os_log_debug_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEBUG, " [%s] %s:%d VCDTMFToneGenerator[%p] Initialize event=%d, powerLevel=%d, sampleRate=%d", (uint8_t *)&v14, 0x38u);
    }
  }
  if (a2 >= 0x10)
  {
    v12 = 2147811332;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCDTMFToneGenerator_Reinit_cold_1();
    }
  }
  else if (a3 >= 0x40)
  {
    v12 = 2147811332;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCDTMFToneGenerator_Reinit_cold_2();
    }
  }
  else
  {
    if (a4 <= 23999)
    {
      if (a4 == 8000)
      {
        v11 = 0;
        goto LABEL_20;
      }
      if (a4 == 16000)
      {
        v11 = 1;
        goto LABEL_20;
      }
    }
    else
    {
      switch(a4)
      {
        case 24000:
          v11 = 2;
          goto LABEL_20;
        case 32000:
          v11 = 3;
          goto LABEL_20;
        case 48000:
          v11 = 4;
LABEL_20:
          v12 = 0;
          *(_DWORD *)a1 = VCDTMFToneGeneratorCoefficient1[16 * v11 + a2];
          *(_DWORD *)(a1 + 4) = VCDTMFToneGeneratorCoefficient2[16 * v11 + a2];
          *(_DWORD *)(a1 + 8) = VCDTMFToneGenerator_Amplitude[a3];
          *(_QWORD *)(a1 + 12) = VCDTMFToneGeneratorInitValue1[16 * v11 + a2];
          *(_QWORD *)(a1 + 20) = VCDTMFToneGeneratorInitValue2[16 * v11 + a2];
          return v12;
      }
    }
    v12 = 2147811332;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCDTMFToneGenerator_Reinit_cold_3();
    }
  }
  return v12;
}

uint64_t VCDTMFToneGenerator_GenerateSamples(_DWORD *a1, int a2, _WORD *a3)
{
  uint64_t v4;
  int v6;
  int ErrorLogLevelForModule;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  uint64_t v11;
  int v13;
  uint64_t v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  _DWORD *v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  LODWORD(v4) = a2;
  v23 = *MEMORY[0x1E0C80C00];
  v6 = a1[2];
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (v6 == -1)
  {
    v11 = 2147811332;
    if (ErrorLogLevelForModule >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCDTMFToneGenerator_GenerateSamples_cold_1();
    }
  }
  else
  {
    if (ErrorLogLevelForModule >= 8)
    {
      v8 = VRTraceErrorLogLevelToCSTR();
      v9 = *MEMORY[0x1E0CF2758];
      v10 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          v13 = 136316162;
          v14 = v8;
          v15 = 2080;
          v16 = "VCDTMFToneGenerator_GenerateSamples";
          v17 = 1024;
          v18 = 224;
          v19 = 2048;
          v20 = a1;
          v21 = 1024;
          v22 = v4;
          _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCDTMFToneGenerator[%p] Generate DTMF tone samples, sampleCount=%d", (uint8_t *)&v13, 0x2Cu);
        }
      }
      else if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        v13 = 136316162;
        v14 = v8;
        v15 = 2080;
        v16 = "VCDTMFToneGenerator_GenerateSamples";
        v17 = 1024;
        v18 = 224;
        v19 = 2048;
        v20 = a1;
        v21 = 1024;
        v22 = v4;
        _os_log_debug_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEBUG, " [%s] %s:%d VCDTMFToneGenerator[%p] Generate DTMF tone samples, sampleCount=%d", (uint8_t *)&v13, 0x2Cu);
      }
    }
    if ((int)v4 >= 1)
    {
      v4 = v4;
      do
      {
        *a3++ = _VCDTMFToneGenerator_GenerateNextSample(a1);
        --v4;
      }
      while (v4);
    }
    return 0;
  }
  return v11;
}

CFTypeRef _VCConnectionManagerIDS_CopyConnection(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  uint64_t v6;
  const void *v7;
  double v8;
  CFTypeRef v9;
  double v10;
  int v12;
  const __CFArray *v13;
  CFIndex Count;
  CFIndex v15;
  CFIndex v16;
  const void *ValueAtIndex;
  int v18;

  pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 96));
  v6 = VCConnectionManager_CopyPrimaryConnection(a1);
  if (!v6)
  {
    pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 96));
    return 0;
  }
  v7 = (const void *)v6;
  v8 = micro();
  if (!VCConnection_MatchesSourceDestinationInfo((uint64_t)v7, a2))
  {
    v13 = *(const __CFArray **)(a1 + 328);
    if (!v13 || (Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 328)), Count < 1))
    {
LABEL_13:
      v18 = 0;
      v9 = 0;
LABEL_21:
      v12 = 170;
      goto LABEL_22;
    }
    v15 = Count;
    v16 = 0;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v13, v16);
      if (VCConnection_MatchesSourceDestinationInfo((uint64_t)ValueAtIndex, a2))
        break;
      if (v15 == ++v16)
        goto LABEL_13;
    }
    *a3 = 0;
    if (ValueAtIndex)
      v9 = CFRetain(ValueAtIndex);
    else
      v9 = 0;
    VCConnection_SourceDestinationInfo((uint64_t)ValueAtIndex, a2);
    *(double *)(a1 + 3536) = v8;
    if (v8 - *(double *)(a1 + 3544) > 1.0)
    {
      v12 = VCConnection_IsRemoteOnWiFiOrWired((uint64_t)ValueAtIndex) ^ 1;
      *(double *)(a1 + 3544) = v8;
      goto LABEL_19;
    }
LABEL_20:
    v18 = 0;
    goto LABEL_21;
  }
  *a3 = 1;
  v9 = CFRetain(v7);
  VCConnection_SourceDestinationInfo((uint64_t)v7, a2);
  v10 = *(double *)(a1 + 3536);
  if (v10 == 0.0 || v8 - v10 <= 5.0)
    goto LABEL_20;
  v12 = 0;
  *(_QWORD *)(a1 + 3536) = 0;
LABEL_19:
  v18 = 1;
LABEL_22:
  CFRelease(v7);
  pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 96));
  if (v18 && !*(_BYTE *)(a1 + 702))
    _VCConnectionManagerIDS_SetPreferredRemoteInterfaceForDuplication(a1, v12);
  return v9;
}

void _VCConnectionManagerIDS_UpdateConnectionForDuplication(uint64_t a1)
{
  CFTypeRef v2;
  int v3;
  CFTypeRef v4;
  const void *v5;
  uint64_t v6;
  NSObject *v7;
  _BOOL4 IsDuplicationEnabled;
  BOOL v9;
  int IsLocalOnCellular;
  CFStringRef v11;
  char v12;
  NSObject *v13;
  _QWORD v14[7];
  char v15;
  char v16;
  uint8_t buf[4];
  uint64_t v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  const void *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v2 = VCConnectionSelector_CopyConnectionForDuplication(*(_QWORD *)(a1 + 632));
  v3 = VCDuplicationHandler_DuplicationReason(*(_QWORD *)(a1 + 624));
  VCConnectionSelector_UpdateConnectionForDuplication(*(_QWORD *)(a1 + 632), v3, *(unsigned __int8 *)(a1 + 741), *(unsigned __int8 *)(a1 + 490), *(unsigned __int8 *)(a1 + 491), *(const __CFArray **)(a1 + 328));
  v4 = (id)VCConnectionSelector_CopyConnectionForDuplication(*(_QWORD *)(a1 + 632));
  if ((VCConnection_Equal((uint64_t)v2, (uint64_t)v4) & 1) == 0)
  {
    v5 = (const void *)VCConnection_CopyDescription((uint64_t)v4);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v6 = VRTraceErrorLogLevelToCSTR();
      v7 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        v18 = v6;
        v19 = 2080;
        v20 = "_VCConnectionManagerIDS_UpdateConnectionForDuplication";
        v21 = 1024;
        v22 = 745;
        v23 = 2112;
        v24 = v5;
        _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d HandoverReport: selected connection %@ for duplication", buf, 0x26u);
      }
    }
    if (v5)
      CFRelease(v5);
    IsDuplicationEnabled = VCDuplicationHandler_IsDuplicationEnabled(*(_QWORD *)(a1 + 624));
    if (v4)
      v9 = !IsDuplicationEnabled;
    else
      v9 = 1;
    if (!v9)
    {
      IsLocalOnCellular = VCConnection_IsLocalOnCellular((uint64_t)v4);
      VCConnectionManager_UseCellPrimaryInterface(a1, IsLocalOnCellular);
      v11 = VCConnectionManager_CopySuggestedLinkTypeCombo(a1);
      v12 = VCDuplicationHandler_DuplicationReason(*(_QWORD *)(a1 + 624));
      v13 = *(NSObject **)(a1 + 440);
      v14[0] = MEMORY[0x1E0C809B0];
      v14[1] = 3221225472;
      v14[2] = ___VCConnectionManagerIDS_UpdateConnectionForDuplication_block_invoke;
      v14[3] = &unk_1E9E56870;
      v15 = 1;
      v14[4] = a1;
      v14[5] = v4;
      v16 = v12;
      v14[6] = v11;
      dispatch_async(v13, v14);
    }
  }
  if (v2)
    CFRelease(v2);
}

void _VCConnectionManagerIDS_SynchronizeParticipantGenerationCounter(uint64_t a1, char a2)
{
  NSObject *v2;
  _QWORD block[5];
  char v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  v2 = *(NSObject **)(a1 + 440);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___VCConnectionManagerIDS_SynchronizeParticipantGenerationCounter_block_invoke;
  block[3] = &unk_1E9E521E8;
  block[4] = a1;
  v4 = a2;
  dispatch_async(v2, block);
}

void _VCConnectionManagerIDS_IsSourceOnCellularIPv6(uint64_t a1, uint64_t a2, _BYTE *a3, _BYTE *a4)
{
  const __CFArray *v4;
  CFIndex Count;
  CFIndex v9;
  CFIndex v10;
  const void *ValueAtIndex;
  uint64_t v12;
  NSObject *v13;
  int v14;
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  *a3 = 0;
  *a4 = 0;
  if (*(_DWORD *)a2 == 4)
  {
    v4 = *(const __CFArray **)(a1 + 328);
    if (v4)
    {
      Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 328));
      if (Count >= 1)
      {
        v9 = Count;
        v10 = 0;
        while (1)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v4, v10);
          if (VCConnectionIDS_LinkID((uint64_t)ValueAtIndex) == *(char *)(a2 + 12))
            break;
          if (v9 == ++v10)
            return;
        }
        if (VCConnection_IsLocalOnCellular((uint64_t)ValueAtIndex))
          *a3 = 1;
        if (VCConnection_IsIPv6((uint64_t)ValueAtIndex))
          *a4 = 1;
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v12 = VRTraceErrorLogLevelToCSTR();
      v13 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v14 = 136315650;
        v15 = v12;
        v16 = 2080;
        v17 = "_VCConnectionManagerIDS_IsSourceOnCellularIPv6";
        v18 = 1024;
        v19 = 981;
        _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil _connectionArray", (uint8_t *)&v14, 0x1Cu);
      }
    }
  }
}

CFTypeRef _VCConnectionManagerIDS_CopyPrimaryConnection(uint64_t a1)
{
  return VCConnectionSelector_CopyPrimaryConnection(*(_QWORD *)(a1 + 632));
}

void _VCConnectionManagerIDS_SetPrimaryConnection(uint64_t a1, const void *a2)
{
  VCConnectionSelector_SetPrimaryConnection(*(_QWORD *)(a1 + 632), a2);
}

uint64_t _VCConnectionManagerIDS_UpdatePacketAndByteCount(uint64_t a1, unsigned int a2, int a3, int a4, int a5, int a6)
{
  const void *v12;
  int v13;
  int v14;
  int *v15;
  int *v16;

  v12 = (const void *)VCConnectionManager_CopyPrimaryConnection(a1);
  v13 = VCConnectionIDS_NetworkOverheadInBytes((uint64_t)v12, a4, a5);
  if (v12)
    CFRelease(v12);
  v14 = v13 + a3;
  pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 96));
  v15 = &OBJC_IVAR___VCConnectionManagerIDS__receivedPacketCount;
  if (a6)
    v15 = &OBJC_IVAR___VCConnectionManagerIDS__sentPacketCount;
  ++*(_DWORD *)(a1 + *v15 + 4 * a2);
  v16 = &OBJC_IVAR___VCConnectionManagerIDS__sentByteCount;
  if (!a6)
    v16 = &OBJC_IVAR___VCConnectionManagerIDS__receivedByteCount;
  *(_DWORD *)(a1 + *v16 + 4 * a2) = v14 + *(_DWORD *)(a1 + *v16 + 4 * a2) - 20;
  return pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 96));
}

uint64_t _VCConnectionManagerIDS_UpdatePersistentPacketCounts(uint64_t a1, unsigned int a2, uint64_t a3)
{
  int *v6;
  uint64_t v7;

  pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 96));
  if ((_DWORD)a3)
  {
    ++*(_DWORD *)(a1 + 848 + 4 * a2);
    v6 = &OBJC_IVAR___VCConnectionManager__isFirstPacketSentCount;
  }
  else
  {
    ++*(_DWORD *)(a1 + 1872 + 4 * a2);
    v6 = &OBJC_IVAR___VCConnectionManager__isFirstPacketReceivedCount;
  }
  v7 = *v6;
  if (!*(_BYTE *)(a1 + v7))
  {
    objc_msgSend(*(id *)(a1 + 2904), "startPeriodicUpdateHistory:", a3);
    v7 = *v6;
  }
  *(_BYTE *)(a1 + v7) = 1;
  return pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 96));
}

uint64_t _VCConnectionManagerIDS_AddLinkProbingTelemetry_0(id *a1, void *a2)
{
  uint64_t result;
  void *v5;
  uint64_t v6;
  BOOL v7;
  unsigned __int8 v8;
  double v9;
  void *v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  char v16;

  result = objc_msgSend((id)objc_msgSend(a1[79], "linkPreferenceOrder"), "count");
  if (result)
  {
    result = VCConnection_Equal(objc_msgSend(a1, "connectionForDuplication"), objc_msgSend(a1[79], "connectionForDuplicationNonProbingVersion"));
    if ((result & 1) == 0)
    {
      v5 = (void *)objc_msgSend(a1[96], "getProbingResultsForLinkID:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", VCConnection_ConnectionID(objc_msgSend(a1, "connectionForDuplication"))));
      v6 = objc_msgSend(a1[96], "getProbingResultsForLinkID:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", VCConnection_ConnectionID(objc_msgSend(a1[79], "connectionForDuplicationNonProbingVersion"))));
      if (v5)
        v7 = v6 == 0;
      else
        v7 = 1;
      if (v7)
      {
        v8 = 0;
        v9 = 0.0;
      }
      else
      {
        v10 = (void *)v6;
        v9 = 0.0;
        objc_msgSend((id)objc_msgSend(v5, "expMovMeanRTT"), "doubleValue");
        if (v11 != 0.0)
        {
          objc_msgSend((id)objc_msgSend(v10, "expMovMeanRTT"), "doubleValue");
          if (v12 != 0.0)
          {
            objc_msgSend((id)objc_msgSend(v10, "expMovMeanRTT"), "doubleValue");
            v14 = v13;
            objc_msgSend((id)objc_msgSend(v5, "expMovMeanRTT"), "doubleValue");
            v9 = v14 - v15;
          }
        }
        v16 = objc_msgSend((id)objc_msgSend(v10, "plrTier"), "unsignedIntValue");
        v8 = v16 - objc_msgSend((id)objc_msgSend(v5, "plrTier"), "unsignedIntValue");
      }
      objc_msgSend(a2, "setObject:forKeyedSubscript:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v9), CFSTR("lnkPrbRTTMeanDelta"));
      return objc_msgSend(a2, "setObject:forKeyedSubscript:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedChar:", v8), CFSTR("lnkPrbPLRTierDelta"));
    }
  }
  return result;
}

uint64_t _VCConnectionManagerIDS_SetPreferredRemoteInterfaceForDuplication(uint64_t a1, int a2)
{
  uint64_t v5;
  NSObject *v6;
  const char *v7;
  int v8;
  uint64_t v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  const char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 96));
  if (*(unsigned __int8 *)(a1 + 491) == a2)
    return pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 96));
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v5 = VRTraceErrorLogLevelToCSTR();
    v6 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v7 = "Cellular";
      v9 = v5;
      v8 = 136315906;
      v11 = "_VCConnectionManagerIDS_SetPreferredRemoteInterfaceForDuplication";
      v10 = 2080;
      if (!a2)
        v7 = "WiFi";
      v12 = 1024;
      v13 = 610;
      v14 = 2080;
      v15 = v7;
      _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d HandoverReport: updated preferred remote interface for duplication to %s", (uint8_t *)&v8, 0x26u);
    }
  }
  *(_BYTE *)(a1 + 491) = a2;
  VCConnectionManager_UpdateConnectionForDuplication(a1);
  return pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 96));
}

uint64_t _VCAudioFrameDelayClassRegister(uint64_t *a1)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

uint64_t VCAudioFrameDelay_Create(const __CFAllocator *a1, __int128 *a2, uint64_t *a3)
{
  uint64_t Instance;
  uint64_t v7;
  CFTypeRef v8;
  __int128 v9;
  __int128 v10;
  CFIndex v11;
  void *v12;
  int v13;
  uint64_t DelayFrame;
  uint64_t v15;
  NSObject *v16;
  unint64_t v17;
  uint64_t v18;
  unsigned int v19;
  double v20;
  uint64_t v21;
  double v22;
  int ErrorLogLevelForModule;
  os_log_t *v25;
  _BYTE v26[12];
  __int16 v27;
  const char *v28;
  __int16 v29;
  int v30;
  __int16 v31;
  uint64_t v32;
  __int16 v33;
  unsigned int v34;
  __int16 v35;
  double v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (a3)
    {
      if (VCAudioFrameDelay_GetTypeID_initOnce != -1)
        dispatch_once_f(&VCAudioFrameDelay_GetTypeID_initOnce, &VCAudioFrameDelay_GetTypeID_typeID, (dispatch_function_t)_VCAudioFrameDelayClassRegister);
      Instance = _CFRuntimeCreateInstance();
      if (Instance)
      {
        v7 = Instance;
        *(_QWORD *)(Instance + 96) = 0;
        *(_OWORD *)(Instance + 64) = 0u;
        *(_OWORD *)(Instance + 80) = 0u;
        *(_OWORD *)(Instance + 32) = 0u;
        *(_OWORD *)(Instance + 48) = 0u;
        *(_OWORD *)(Instance + 16) = 0u;
        v8 = (CFTypeRef)*((_QWORD *)a2 + 6);
        if (v8)
          v8 = CFRetain(v8);
        *(_QWORD *)(v7 + 16) = v8;
        v9 = *a2;
        v10 = a2[1];
        *(_OWORD *)(v7 + 56) = a2[2];
        *(_OWORD *)(v7 + 40) = v10;
        *(_OWORD *)(v7 + 24) = v9;
        v11 = *((_QWORD *)a2 + 8);
        *(_QWORD *)(v7 + 72) = v11;
        *(_DWORD *)(v7 + 88) = *((_DWORD *)a2 + 14);
        v12 = CFAllocatorAllocate(a1, v11, 0);
        *(_QWORD *)(v7 + 80) = v12;
        if (!v12)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VCAudioFrameDelay_Create_cold_4();
          }
          v18 = 0;
LABEL_23:
          CFRelease((CFTypeRef)v7);
          return v18;
        }
        v13 = *((_DWORD *)a2 + 14);
        if (v13)
        {
          while (1)
          {
            *(_QWORD *)v26 = 0;
            DelayFrame = _VCAudioFrameDelay_AllocateDelayFrame(v7, (uint64_t **)v26);
            if ((DelayFrame & 0x80000000) != 0)
              break;
            _VCAudioFrameDelay_InsertDelayFrame(v7, *(_QWORD **)v26, *(uint64_t **)(v7 + 96));
            if (!--v13)
              goto LABEL_12;
          }
          v18 = DelayFrame;
          ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
          v25 = (os_log_t *)MEMORY[0x1E0CF2758];
          if (ErrorLogLevelForModule >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled(*v25, OS_LOG_TYPE_ERROR))
              VCAudioFrameDelay_Create_cold_6();
          }
          _VCAudioFrameDelay_CleanupDelayFrames((_QWORD *)v7);
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled(*v25, OS_LOG_TYPE_ERROR))
              VCAudioFrameDelay_Create_cold_5();
          }
          goto LABEL_23;
        }
LABEL_12:
        *a3 = v7;
        if ((int)VRTraceGetErrorLogLevelForModule() < 7)
          return 0;
        v15 = VRTraceErrorLogLevelToCSTR();
        v16 = *MEMORY[0x1E0CF2758];
        v18 = 0;
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v19 = *(_DWORD *)(v7 + 92);
          LODWORD(v17) = *(_DWORD *)(v7 + 64);
          v20 = (double)v19 * (double)v17;
          v21 = *a3;
          *(_DWORD *)v26 = 136316418;
          v22 = *(double *)(v7 + 24);
          *(_QWORD *)&v26[4] = v15;
          v27 = 2080;
          v28 = "VCAudioFrameDelay_Create";
          v29 = 1024;
          v30 = 300;
          v31 = 2048;
          v32 = v21;
          v33 = 1024;
          v34 = v19;
          v35 = 2048;
          v36 = v20 / v22;
          _os_log_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d [%p] VCAudioFrameDelay created. frameDelay=%d timeDelay=%f", v26, 0x36u);
          return 0;
        }
      }
      else
      {
        v18 = 2152464386;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            VCAudioFrameDelay_Create_cold_3();
            return 2152464386;
          }
        }
      }
    }
    else
    {
      v18 = 2152464385;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCAudioFrameDelay_Create_cold_2();
      }
    }
  }
  else
  {
    v18 = 2152464385;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioFrameDelay_Create_cold_1();
    }
  }
  return v18;
}

uint64_t VCAudioFrameDelay_PullAudioSamples(uint64_t result, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t *v14;
  int v15;
  uint64_t *v16;
  uint64_t v17;
  NSObject *v18;
  NSObject *v19;
  int v20;
  uint64_t v21;
  char Priority;
  uint64_t v23;
  uint64_t v24;
  double HostTime;
  int Timestamp;
  int v27;
  _BYTE v28[12];
  __int16 v29;
  const char *v30;
  __int16 v31;
  int v32;
  __int16 v33;
  uint64_t v34;
  __int16 v35;
  int v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  if (result && a2 && a3)
  {
    v7 = result;
    v8 = *(_DWORD *)(result + 88);
    v9 = *(_DWORD *)(result + 92);
    if (v8 != v9)
    {
      if (v8 <= v9)
      {
        if (v8 < v9)
        {
          v12 = *(uint64_t **)(result + 96);
          if (v12)
          {
            *(_QWORD *)v28 = *(_QWORD *)(result + 96);
            v13 = v12;
            do
            {
              v14 = (uint64_t *)*v13;
              if (*((_BYTE *)v13 + 25))
              {
                _VCAudioFrameDelay_RemoveDelayFrame(v7, v13);
                _VCAudioFrameDelay_DeallocateDelayFrame((const void *)v7, (uint64_t **)v28);
                v15 = *(_DWORD *)(v7 + 92);
                *(_QWORD *)v28 = v14;
                if (!v15)
                  break;
                v12 = *(uint64_t **)(v7 + 96);
              }
              else
              {
                *(_QWORD *)v28 = *v13;
              }
              v13 = v14;
            }
            while (v14 != v12);
          }
          else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VCAudioFrameDelay_PullAudioSamples_cold_2();
          }
        }
      }
      else
      {
        v10 = *(_QWORD *)(result + 96);
        if (v10)
        {
          v11 = *(_QWORD *)(result + 96);
          do
          {
            if (*(_BYTE *)(v11 + 25))
              goto LABEL_21;
            v11 = *(_QWORD *)v11;
          }
          while (v11 != v10);
        }
        else
        {
          v11 = 0;
LABEL_21:
          while (1)
          {
            *(_QWORD *)v28 = 0;
            if ((_VCAudioFrameDelay_AllocateDelayFrame(v7, (uint64_t **)v28) & 0x80000000) != 0)
              break;
            v16 = (uint64_t *)v11;
            if (!v11)
              v16 = *(uint64_t **)(v7 + 96);
            _VCAudioFrameDelay_InsertDelayFrame(v7, *(_QWORD **)v28, v16);
            if (*(_DWORD *)(v7 + 92) >= *(_DWORD *)(v7 + 88))
              goto LABEL_25;
          }
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VCAudioFrameDelay_PullAudioSamples_cold_1();
          }
        }
      }
LABEL_25:
      v8 = *(_DWORD *)(v7 + 92);
      if (*(_DWORD *)(v7 + 88) == v8)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          v17 = VRTraceErrorLogLevelToCSTR();
          v18 = *MEMORY[0x1E0CF2758];
          v19 = *MEMORY[0x1E0CF2758];
          if (*MEMORY[0x1E0CF2748])
          {
            if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
            {
              v20 = *(_DWORD *)(v7 + 92);
              *(_DWORD *)v28 = 136316162;
              *(_QWORD *)&v28[4] = v17;
              v29 = 2080;
              v30 = "_VCAudioFrameDelay_PerformAdaptation";
              v31 = 1024;
              v32 = 264;
              v33 = 2048;
              v34 = v7;
              v35 = 1024;
              v36 = v20;
              _os_log_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d [%p] Successfully adapted to frame delay=%u", v28, 0x2Cu);
            }
          }
          else if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
          {
            v27 = *(_DWORD *)(v7 + 92);
            *(_DWORD *)v28 = 136316162;
            *(_QWORD *)&v28[4] = v17;
            v29 = 2080;
            v30 = "_VCAudioFrameDelay_PerformAdaptation";
            v31 = 1024;
            v32 = 264;
            v33 = 2048;
            v34 = v7;
            v35 = 1024;
            v36 = v27;
            _os_log_debug_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_DEBUG, " [%s] %s:%d [%p] Successfully adapted to frame delay=%u", v28, 0x2Cu);
          }
        }
        v8 = *(_DWORD *)(v7 + 92);
      }
    }
    if (v8)
    {
      v21 = *(_QWORD *)(v7 + 96);
      *(_QWORD *)(v7 + 96) = *(_QWORD *)v21;
      VCAudioBufferList_ReplaceSamples(a2, *(_QWORD *)(v21 + 16), 0);
      if (*(_BYTE *)(v21 + 24))
      {
        Priority = VCAudioBufferList_GetPriority(*(_QWORD *)(v21 + 16));
        VCAudioBufferList_SetPriority(a2, Priority);
        v23 = *(_QWORD *)(v21 + 32);
      }
      else
      {
        VCAudioBufferList_SetPriority(a2, 0);
        v23 = 0;
      }
      *a3 = v23;
      v24 = *(_QWORD *)(v21 + 32);
      *(_QWORD *)(v21 + 32) = *(_QWORD *)(v7 + 80);
      *(_QWORD *)(v7 + 80) = v24;
      HostTime = VCAudioBufferList_GetHostTime(a2);
      Timestamp = VCAudioBufferList_GetTimestamp(a2);
      VCAudioBufferList_SetTime(*(_QWORD *)(v21 + 16), Timestamp, HostTime);
      result = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, uint64_t))(a4 + 16))(a4, *(_QWORD *)(v21 + 16), *(_QWORD *)(v21 + 32), v21 + 25);
      *(_BYTE *)(v21 + 24) = 1;
    }
    else
    {
      v28[0] = 0;
      result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _BYTE *))(a4 + 16))(a4, a2, *(_QWORD *)(v7 + 80), v28);
      *a3 = *(_QWORD *)(v7 + 80);
    }
  }
  return result;
}

uint64_t VCAudioFrameDelay_UpdateDelay(uint64_t a1, int a2)
{
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  uint64_t v7;
  int v9;
  uint64_t v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  uint64_t v16;
  __int16 v17;
  int v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    *(_DWORD *)(a1 + 88) = a2;
    if ((int)VRTraceGetErrorLogLevelForModule() < 8)
      return 0;
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    v6 = *MEMORY[0x1E0CF2758];
    if (!*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        v9 = 136316162;
        v10 = v4;
        v11 = 2080;
        v12 = "VCAudioFrameDelay_UpdateDelay";
        v13 = 1024;
        v14 = 348;
        v15 = 2048;
        v16 = a1;
        v17 = 1024;
        v18 = a2;
        _os_log_debug_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEBUG, " [%s] %s:%d [%p] Setting audio frame delay=%d", (uint8_t *)&v9, 0x2Cu);
      }
      return 0;
    }
    v7 = 0;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136316162;
      v10 = v4;
      v11 = 2080;
      v12 = "VCAudioFrameDelay_UpdateDelay";
      v13 = 1024;
      v14 = 348;
      v15 = 2048;
      v16 = a1;
      v17 = 1024;
      v18 = a2;
      _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d [%p] Setting audio frame delay=%d", (uint8_t *)&v9, 0x2Cu);
      return 0;
    }
  }
  else
  {
    v7 = 2152464385;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioFrameDelay_UpdateDelay_cold_1();
    }
  }
  return v7;
}

double _VCAudioFrameDelayInit(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 96) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

void _VCAudioFrameDelayFinalize(uint64_t a1)
{
  const __CFAllocator *v2;

  _VCAudioFrameDelay_CleanupDelayFrames((_QWORD *)a1);
  v2 = CFGetAllocator((CFTypeRef)a1);
  CFAllocatorDeallocate(v2, *(void **)(a1 + 80));
  *(_QWORD *)(a1 + 80) = 0;
}

__CFString *_VCAudioFrameDelayCopyDescription(_QWORD *a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  const __CFString *v4;

  v2 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("[%p]"), a1);
  v4 = (const __CFString *)a1[2];
  if (v4)
    CFStringAppend(Mutable, v4);
  return Mutable;
}

void _VCAudioFrameDelay_CleanupDelayFrames(_QWORD *a1)
{
  uint64_t *i;
  uint64_t *v3[2];

  v3[1] = *(uint64_t **)MEMORY[0x1E0C80C00];
  for (i = (uint64_t *)a1[12]; i; i = (uint64_t *)a1[12])
  {
    v3[0] = i;
    _VCAudioFrameDelay_RemoveDelayFrame((uint64_t)a1, i);
    _VCAudioFrameDelay_DeallocateDelayFrame(a1, v3);
  }
}

void _VCAudioFrameDelay_RemoveDelayFrame(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;

  if (a2)
  {
    v2 = *(_QWORD **)(a1 + 96);
    if (v2)
    {
      v3 = *(_QWORD **)(a1 + 96);
      while (v3 != a2)
      {
        v3 = (_QWORD *)*v3;
        if (v3 == v2)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              _VCAudioFrameDelay_RemoveDelayFrame_cold_3();
          }
          return;
        }
      }
      v4 = (_QWORD *)*a2;
      if (v2 == a2)
      {
        if (v4 == a2)
          v5 = 0;
        else
          v5 = (_QWORD *)*a2;
        *(_QWORD *)(a1 + 96) = v5;
      }
      v6 = (_QWORD *)a2[1];
      *v6 = v4;
      *(_QWORD *)(*a2 + 8) = v6;
      *a2 = a2;
      a2[1] = a2;
      --*(_DWORD *)(a1 + 92);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCAudioFrameDelay_RemoveDelayFrame_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCAudioFrameDelay_RemoveDelayFrame_cold_1();
  }
}

void _VCAudioFrameDelay_DeallocateDelayFrame(const void *a1, uint64_t **a2)
{
  uint64_t *v2;
  const __CFAllocator *v3;
  const __CFAllocator *v4;
  void *v5;

  if (a2)
  {
    v2 = *a2;
    if (*a2)
    {
      *a2 = 0;
      v3 = CFGetAllocator(a1);
      v4 = v3;
      v5 = (void *)v2[4];
      if (v5)
      {
        CFAllocatorDeallocate(v3, v5);
        v2[4] = 0;
      }
      VCAudioBufferList_Destroy(v2 + 2);
      CFAllocatorDeallocate(v4, v2);
    }
  }
}

uint64_t _VCAudioFrameDelay_AllocateDelayFrame(uint64_t a1, uint64_t **a2)
{
  const __CFAllocator *v4;
  uint64_t *v5;
  uint64_t *v6;
  _QWORD *v7;
  void *v8;
  uint64_t result;
  uint64_t *v10[2];

  v10[1] = *(uint64_t **)MEMORY[0x1E0C80C00];
  v4 = CFGetAllocator((CFTypeRef)a1);
  v5 = (uint64_t *)CFAllocatorAllocate(v4, 40, 0);
  v10[0] = v5;
  if (v5)
  {
    v6 = v5;
    v5[2] = 0;
    v7 = v5 + 2;
    *v5 = (uint64_t)v5;
    v5[1] = (uint64_t)v5;
    *((_WORD *)v5 + 12) = 256;
    v8 = CFAllocatorAllocate(v4, *(_QWORD *)(a1 + 72), 0);
    v6[4] = (uint64_t)v8;
    if (v8)
    {
      if ((VCAudioBufferList_AllocateFrame(a1 + 24, v7) & 1) != 0)
      {
        VCAudioBufferList_SetSampleCount(v6[2], *(_DWORD *)(a1 + 64));
        result = 0;
        *a2 = v6;
        return result;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCAudioFrameDelay_AllocateDelayFrame_cold_3();
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCAudioFrameDelay_AllocateDelayFrame_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCAudioFrameDelay_AllocateDelayFrame_cold_1();
  }
  _VCAudioFrameDelay_DeallocateDelayFrame((const void *)a1, v10);
  return 2152464386;
}

void _VCAudioFrameDelay_InsertDelayFrame(uint64_t a1, _QWORD *a2, uint64_t *a3)
{
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;

  if (a2)
  {
    v3 = *(_QWORD **)(a1 + 96);
    if (v3)
    {
      v4 = *(_QWORD **)(a1 + 96);
      while (v4 != a2)
      {
        v4 = (_QWORD *)*v4;
        if (v4 == v3)
        {
          v5 = *a3;
          *(_QWORD *)(v5 + 8) = a2;
          *a2 = v5;
          *a3 = (uint64_t)a2;
          a2[1] = a3;
          goto LABEL_11;
        }
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCAudioFrameDelay_InsertDelayFrame_cold_2();
      }
    }
    else
    {
      *(_QWORD *)(a1 + 96) = a2;
LABEL_11:
      ++*(_DWORD *)(a1 + 92);
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCAudioFrameDelay_InsertDelayFrame_cold_1();
  }
}

void sub_1D8E0CC08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t VCMediaStreamSendGroup_UpdateSendSampleRTPTimestamp(uint64_t result, int a2, double a3, double a4)
{
  uint64_t v7;

  if (*(_BYTE *)(result + 492))
  {
    v7 = result;
    pthread_rwlock_wrlock((pthread_rwlock_t *)(result + 496));
    *(_DWORD *)(v7 + 696) = a2;
    *(double *)(v7 + 704) = a4;
    *(double *)(v7 + 720) = a3;
    *(_BYTE *)(v7 + 712) = 1;
    return pthread_rwlock_unlock((pthread_rwlock_t *)(v7 + 496));
  }
  return result;
}

uint64_t VCMediaStreamSendGroup_ModulateTimestampWithSourceTimestamp(uint64_t a1, double a2, double a3)
{
  unint64_t v3;
  double v7;
  double v8;

  pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 496));
  v7 = *(double *)(a1 + 720);
  v8 = *(double *)(a1 + 704);
  LODWORD(v3) = *(_DWORD *)(a1 + 696);
  pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 496));
  return ((double)((double)v3 * a2 / v7) + (a3 - v8) * a2);
}

uint64_t VCSignalErrorAt(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  char *v10;
  int ErrorLogLevelForModule;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  NSObject *v15;
  char *v17[2];

  v17[1] = *(char **)MEMORY[0x1E0C80C00];
  v17[0] = 0;
  vasprintf(v17, a2, &a9);
  v10 = v17[0];
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (v10)
  {
    if (ErrorLogLevelForModule >= 3)
    {
      v12 = VRTraceErrorLogLevelToCSTR();
      v13 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCSignalErrorAt_cold_2(v12, (uint64_t *)v17, v13);
    }
    free(v17[0]);
  }
  else if (ErrorLogLevelForModule >= 3)
  {
    v14 = VRTraceErrorLogLevelToCSTR();
    v15 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCSignalErrorAt_cold_1(v14, v15);
  }
  return a1;
}

int32x2_t **VCAudioIssueDetector_Create(unsigned int a1)
{
  int32x2_t **v2;
  int32x2_t **v3;
  CMSimpleQueueRef *v4;
  uint64_t v5;
  NSObject *v6;
  int32x2_t **v8;
  uint8_t buf[4];
  uint64_t v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  int32x2_t **v16;
  __int16 v17;
  unsigned int v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v8 = 0;
  if (a1 >= 2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioIssueDetector_Create_cold_2();
    }
  }
  else
  {
    v2 = (int32x2_t **)malloc_type_calloc(1uLL, 0x238uLL, 0x10200400ED4710AuLL);
    v8 = v2;
    if (v2)
    {
      v3 = v2;
      v4 = VCAudioIssueDetectorUtil_Create(a1 == 1);
      v3[70] = (int32x2_t *)v4;
      if (v4)
      {
        *(_DWORD *)v3 = a1;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v5 = VRTraceErrorLogLevelToCSTR();
          v6 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136316162;
            v10 = v5;
            v11 = 2080;
            v12 = "VCAudioIssueDetector_Create";
            v13 = 1024;
            v14 = 40;
            v15 = 2048;
            v16 = v3;
            v17 = 1024;
            v18 = a1;
            _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCAudioIssueDetector=%p of type=%d created", buf, 0x2Cu);
          }
        }
        return v3;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCAudioIssueDetector_Create_cold_4();
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioIssueDetector_Create_cold_3();
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioIssueDetector_Create_cold_1();
  }
  VCAudioIssueDetector_Finalize(&v8);
  return v8;
}

void VCAudioIssueDetector_Finalize(int32x2_t ***a1)
{
  int32x2_t **v2;
  uint64_t v3;
  NSObject *v4;
  int v5;
  uint64_t v6;
  __int16 v7;
  const char *v8;
  __int16 v9;
  int v10;
  __int16 v11;
  int32x2_t **v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = *a1;
    if (*a1)
    {
      if (v2[70])
        VCAudioIssueDetectorUtil_Finalize(v2 + 70);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v3 = VRTraceErrorLogLevelToCSTR();
        v4 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v5 = 136315906;
          v6 = v3;
          v7 = 2080;
          v8 = "VCAudioIssueDetector_Finalize";
          v9 = 1024;
          v10 = 57;
          v11 = 2048;
          v12 = v2;
          _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCAudioIssueDetector=%p finalized", (uint8_t *)&v5, 0x26u);
        }
      }
      free(v2);
      *a1 = 0;
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioIssueDetector_Finalize_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioIssueDetector_Finalize_cold_1();
  }
}

void VCAudioIssueDetector_Configure(uint64_t a1, unsigned __int16 *a2)
{
  int ErrorLogLevelForModule;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  int v8;
  uint64_t v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (a1)
  {
    if (ErrorLogLevelForModule >= 8)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v6 = *MEMORY[0x1E0CF2758];
      v7 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          v8 = 136315906;
          v9 = v5;
          v10 = 2080;
          v11 = "VCAudioIssueDetector_Configure";
          v12 = 1024;
          v13 = 66;
          v14 = 2048;
          v15 = a1;
          _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCAudioIssueDetector=%p configured", (uint8_t *)&v8, 0x26u);
        }
      }
      else if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        VCAudioIssueDetector_Configure_cold_2();
      }
    }
    VCAudioIssueDetectorUtil_Configure(*(_QWORD *)(a1 + 560), a2);
  }
  else if (ErrorLogLevelForModule >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioIssueDetector_Configure_cold_1();
  }
}

void VCAudioIssueDetector_UpdateConnectionType(uint64_t a1, int a2)
{
  int ErrorLogLevelForModule;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  int v8;
  uint64_t v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (a1)
  {
    if (ErrorLogLevelForModule >= 8)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v6 = *MEMORY[0x1E0CF2758];
      v7 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          v8 = 136315906;
          v9 = v5;
          v10 = 2080;
          v11 = "VCAudioIssueDetector_UpdateConnectionType";
          v12 = 1024;
          v13 = 74;
          v14 = 2048;
          v15 = a1;
          _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCAudioIssueDetector=%p link type updated", (uint8_t *)&v8, 0x26u);
        }
      }
      else if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        VCAudioIssueDetector_UpdateConnectionType_cold_2();
      }
    }
    VCAudioIssueDetectorUtil_UpdateRATType(*(_QWORD *)(a1 + 560), a2);
  }
  else if (ErrorLogLevelForModule >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioIssueDetector_UpdateConnectionType_cold_1();
  }
}

void VCAudioIssueDetector_ProcessCellularNetworkNotification(uint64_t a1, uint64_t a2)
{
  int ErrorLogLevelForModule;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  int v8;
  uint64_t v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (a1)
  {
    if (ErrorLogLevelForModule >= 8)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v6 = *MEMORY[0x1E0CF2758];
      v7 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          v8 = 136315906;
          v9 = v5;
          v10 = 2080;
          v11 = "VCAudioIssueDetector_ProcessCellularNetworkNotification";
          v12 = 1024;
          v13 = 82;
          v14 = 2048;
          v15 = a1;
          _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCAudioIssueDetector=%p NW notification received", (uint8_t *)&v8, 0x26u);
        }
      }
      else if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        VCAudioIssueDetector_ProcessCellularNetworkNotification_cold_2();
      }
    }
    VCAudioIssueDetectorUtil_ProcessCellularNetworkNotification(*(_QWORD *)(a1 + 560), a2);
  }
  else if (ErrorLogLevelForModule >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioIssueDetector_ProcessCellularNetworkNotification_cold_1();
  }
}

void VCAudioIssueDetector_Start(uint64_t a1)
{
  int ErrorLogLevelForModule;
  uint64_t v3;
  NSObject *v4;
  NSObject *v5;
  int v6;
  uint64_t v7;
  __int16 v8;
  const char *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (a1)
  {
    if (ErrorLogLevelForModule >= 8)
    {
      v3 = VRTraceErrorLogLevelToCSTR();
      v4 = *MEMORY[0x1E0CF2758];
      v5 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          v6 = 136315906;
          v7 = v3;
          v8 = 2080;
          v9 = "VCAudioIssueDetector_Start";
          v10 = 1024;
          v11 = 90;
          v12 = 2048;
          v13 = a1;
          _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCAudioIssueDetector=%p started", (uint8_t *)&v6, 0x26u);
        }
      }
      else if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        VCAudioIssueDetector_Start_cold_2();
      }
    }
    VCAudioIssueDetectorUtil_Start(*(int32x2_t **)(a1 + 560));
  }
  else if (ErrorLogLevelForModule >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioIssueDetector_Start_cold_1();
  }
}

void VCAudioIssueDetector_Stop(uint64_t a1)
{
  int ErrorLogLevelForModule;
  uint64_t v3;
  NSObject *v4;
  NSObject *v5;
  int v6;
  uint64_t v7;
  __int16 v8;
  const char *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (a1)
  {
    if (ErrorLogLevelForModule >= 8)
    {
      v3 = VRTraceErrorLogLevelToCSTR();
      v4 = *MEMORY[0x1E0CF2758];
      v5 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          v6 = 136315906;
          v7 = v3;
          v8 = 2080;
          v9 = "VCAudioIssueDetector_Stop";
          v10 = 1024;
          v11 = 98;
          v12 = 2048;
          v13 = a1;
          _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCAudioIssueDetector=%p stopped", (uint8_t *)&v6, 0x26u);
        }
      }
      else if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        VCAudioIssueDetector_Stop_cold_2();
      }
    }
    VCAudioIssueDetectorUtil_Stop(*(int32x2_t **)(a1 + 560));
  }
  else if (ErrorLogLevelForModule >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioIssueDetector_Stop_cold_1();
  }
}

void VCAudioIssueDetector_ProcessFrame(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v4;
  NSObject *v5;
  int v6;
  uint64_t v7;
  __int16 v8;
  const char *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  uint64_t v13;
  __int16 v14;
  unsigned __int16 *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (a1 && a2)
  {
    VCAudioIssueDetectorUtil_ProcessFrame(*(int32x2_t **)(a1 + 560), a2);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      v6 = 136316162;
      v7 = v4;
      v8 = 2080;
      v9 = "VCAudioIssueDetector_ProcessFrame";
      v10 = 1024;
      v11 = 121;
      v12 = 2048;
      v13 = a1;
      v14 = 2048;
      v15 = a2;
      _os_log_error_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_ERROR, " [%s] %s:%d Invalid parameter issueDetector=%p frameInfo=%p", (uint8_t *)&v6, 0x30u);
    }
  }
}

void VCAudioIssueDetector_ReportRTPTraffic(uint64_t a1)
{
  if (a1)
  {
    *(_BYTE *)(a1 + 556) = 1;
    VCAudioIssueDetectorUtil_RtpPacketIndication(*(_QWORD *)(a1 + 560));
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioIssueDetector_ReportRTPTraffic_cold_1();
  }
}

void VCAudioIssueDetector_ReportRTCPTraffic(uint64_t a1)
{
  if (a1)
  {
    *(_BYTE *)(a1 + 557) = 1;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioIssueDetector_ReportRTCPTraffic_cold_1();
  }
}

void VCAudioIssueDetector_GetReportingStats(int *a1, _BYTE *a2)
{
  uint64_t v4;
  NSObject *v5;
  int v6;
  uint64_t v7;
  NSObject *v8;
  int v9;
  uint64_t v10;
  NSObject *v11;
  int v12;
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int *v19;
  __int16 v20;
  _BYTE *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (a1 && a2)
  {
    if (!*((_BYTE *)a1 + 556))
    {
      *a2 = 1;
      VCAudioIssueDetectorUtil_RtpPacketTimeoutIndication(*((_QWORD *)a1 + 70));
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v4 = VRTraceErrorLogLevelToCSTR();
        v5 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v6 = *a1;
          v12 = 136316162;
          v13 = v4;
          v14 = 2080;
          v15 = "VCAudioIssueDetector_GetReportingStats";
          v16 = 1024;
          v17 = 147;
          v18 = 2048;
          v19 = a1;
          v20 = 1024;
          LODWORD(v21) = v6;
          _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Rtp inactivity detected in audio issue detector=%p, direction=%d", (uint8_t *)&v12, 0x2Cu);
        }
      }
    }
    *((_BYTE *)a1 + 556) = 0;
    if (!*((_BYTE *)a1 + 557))
    {
      a2[1] = 1;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v7 = VRTraceErrorLogLevelToCSTR();
        v8 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v9 = *a1;
          v12 = 136316162;
          v13 = v7;
          v14 = 2080;
          v15 = "VCAudioIssueDetector_GetReportingStats";
          v16 = 1024;
          v17 = 152;
          v18 = 2048;
          v19 = a1;
          v20 = 1024;
          LODWORD(v21) = v9;
          _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Rtcp inactivity detected in audio issue detector=%p, direction=%d", (uint8_t *)&v12, 0x2Cu);
        }
      }
    }
    *((_BYTE *)a1 + 557) = 0;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v10 = VRTraceErrorLogLevelToCSTR();
    v11 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      v12 = 136316162;
      v13 = v10;
      v14 = 2080;
      v15 = "VCAudioIssueDetector_GetReportingStats";
      v16 = 1024;
      v17 = 143;
      v18 = 2048;
      v19 = a1;
      v20 = 2048;
      v21 = a2;
      _os_log_error_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_ERROR, " [%s] %s:%d Invalid parameter issueDetector=%p reportingStats=%p", (uint8_t *)&v12, 0x30u);
    }
  }
}

void VCAudioIssueDetector_FlushLogEvents(uint64_t a1)
{
  if (a1)
  {
    VCAudioIssueDetectorUtil_FlushLogEvents(*(_QWORD *)(a1 + 560));
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioIssueDetector_FlushLogEvents_cold_1();
  }
}

uint64_t VCMediaNegotiationBlobV2CameraSettingsU1ReadFrom(_BYTE *a1, uint64_t a2)
{
  __int16 *v2;
  int *v4;
  int *v5;
  int *v6;
  int *v8;
  int *v9;
  int *v10;
  int *v11;
  char v12;
  unsigned int v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char v17;
  BOOL v18;
  int v19;
  char v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  char v26;
  __int16 *v27;
  int *v28;
  int *v29;
  int *v30;
  uint64_t result;
  int *v32;
  _BYTE *v33;
  VCMediaNegotiationBlobV2VideoPayload *v34;
  _BYTE *v35;
  char v36;
  unsigned int v37;
  uint64_t v38;
  unint64_t v39;
  char v40;
  char v41;
  unsigned int v42;
  uint64_t v43;
  unint64_t v44;
  char v45;
  char v46;
  unsigned int v47;
  uint64_t v48;
  unint64_t v49;
  char v50;
  char v51;
  unsigned int v52;
  uint64_t v53;
  unint64_t v54;
  char v55;
  char v56;
  unsigned int v57;
  uint64_t v58;
  unint64_t v59;
  char v60;
  char v61;
  unsigned int v62;
  uint64_t v63;
  unint64_t v64;
  char v65;
  char v66;
  unsigned int v67;
  uint64_t v68;
  unint64_t v69;
  char v70;
  uint64_t v71;

  v4 = (int *)MEMORY[0x1E0D82BF0];
  v5 = (int *)MEMORY[0x1E0D82BD8];
  v6 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) >= *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
    return *(_BYTE *)(a2 + *v6) == 0;
  v8 = &OBJC_IVAR___VCEmulatedNetworkAlgorithmQueueLoss__expectedProcessEndTime;
  v9 = (int *)MEMORY[0x1E0D82BB8];
  v10 = &OBJC_IVAR___VCEmulatedNetworkAlgorithmQueueLoss__expectedProcessEndTime;
  v11 = &OBJC_IVAR___VCEmulatedNetworkAlgorithmQueueLoss__expectedProcessEndTime;
  while (2)
  {
    if (*(_BYTE *)(a2 + *v6))
      return *(_BYTE *)(a2 + *v6) == 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    while (1)
    {
      v15 = *v4;
      v16 = *(_QWORD *)(a2 + v15);
      if (v16 == -1 || v16 >= *(_QWORD *)(a2 + *v5))
        break;
      v17 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v16);
      *(_QWORD *)(a2 + v15) = v16 + 1;
      v14 |= (unint64_t)(v17 & 0x7F) << v12;
      if ((v17 & 0x80) == 0)
        goto LABEL_12;
      v12 += 7;
      v18 = v13++ >= 9;
      if (v18)
      {
        v14 = 0;
        v19 = *(unsigned __int8 *)(a2 + *v6);
        goto LABEL_14;
      }
    }
    *(_BYTE *)(a2 + *v6) = 1;
LABEL_12:
    v19 = *(unsigned __int8 *)(a2 + *v6);
    if (*(_BYTE *)(a2 + *v6))
      v14 = 0;
LABEL_14:
    if (v19 || (v14 & 7) == 4)
      return *(_BYTE *)(a2 + *v6) == 0;
    switch((v14 >> 3))
    {
      case 1u:
        v21 = 0;
        v22 = 0;
        v23 = 0;
        a1[v8[419]] |= 0x80u;
        while (1)
        {
          v24 = *v4;
          v25 = *(_QWORD *)(a2 + v24);
          if (v25 == -1 || v25 >= *(_QWORD *)(a2 + *v5))
            break;
          v26 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v25);
          *(_QWORD *)(a2 + v24) = v25 + 1;
          v23 |= (unint64_t)(v26 & 0x7F) << v21;
          if ((v26 & 0x80) == 0)
            goto LABEL_81;
          v21 += 7;
          v18 = v22++ >= 9;
          if (v18)
          {
            LODWORD(v23) = 0;
            goto LABEL_83;
          }
        }
        *(_BYTE *)(a2 + *v6) = 1;
LABEL_81:
        if (*(_BYTE *)(a2 + *v6))
          LODWORD(v23) = 0;
LABEL_83:
        v71 = v10[420];
        goto LABEL_112;
      case 2u:
        v32 = v11;
        v33 = a1;
        v34 = objc_alloc_init(VCMediaNegotiationBlobV2VideoPayload);
        v35 = v33;
        objc_msgSend(v33, "addPayloads:", v34);

        if (PBReaderPlaceMark()
          && (VCMediaNegotiationBlobV2VideoPayloadReadFrom((uint64_t)v34, a2) & 1) != 0)
        {
          PBReaderRecallMark();
          v11 = v32;
          v2 = &jpt_1D8E0EB18;
          v6 = (int *)MEMORY[0x1E0D82BC8];
          a1 = v35;
LABEL_113:
          if (*(_QWORD *)(a2 + *v4) >= *(_QWORD *)(a2 + *v5))
            return *(_BYTE *)(a2 + *v6) == 0;
          continue;
        }
        return 0;
      case 3u:
        v36 = 0;
        v37 = 0;
        v23 = 0;
        a1[v8[419]] |= 2u;
        while (2)
        {
          v38 = *v4;
          v39 = *(_QWORD *)(a2 + v38);
          if (v39 == -1 || v39 >= *(_QWORD *)(a2 + *v5))
          {
            *(_BYTE *)(a2 + *v6) = 1;
          }
          else
          {
            v40 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v39);
            *(_QWORD *)(a2 + v38) = v39 + 1;
            v23 |= (unint64_t)(v40 & 0x7F) << v36;
            if (v40 < 0)
            {
              v36 += 7;
              v18 = v37++ >= 9;
              if (v18)
              {
                LODWORD(v23) = 0;
                goto LABEL_87;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v6))
          LODWORD(v23) = 0;
LABEL_87:
        v71 = v11[422];
        goto LABEL_112;
      case 4u:
        v41 = 0;
        v42 = 0;
        v23 = 0;
        a1[v8[419]] |= 4u;
        while (2)
        {
          v43 = *v4;
          v44 = *(_QWORD *)(a2 + v43);
          if (v44 == -1 || v44 >= *(_QWORD *)(a2 + *v5))
          {
            *(_BYTE *)(a2 + *v6) = 1;
          }
          else
          {
            v45 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v44);
            *(_QWORD *)(a2 + v43) = v44 + 1;
            v23 |= (unint64_t)(v45 & 0x7F) << v41;
            if (v45 < 0)
            {
              v41 += 7;
              v18 = v42++ >= 9;
              if (v18)
              {
                LODWORD(v23) = 0;
                goto LABEL_91;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v6))
          LODWORD(v23) = 0;
LABEL_91:
        v71 = 16;
        goto LABEL_112;
      case 5u:
        v46 = 0;
        v47 = 0;
        v23 = 0;
        a1[v8[419]] |= 0x20u;
        while (2)
        {
          v48 = *v4;
          v49 = *(_QWORD *)(a2 + v48);
          if (v49 == -1 || v49 >= *(_QWORD *)(a2 + *v5))
          {
            *(_BYTE *)(a2 + *v6) = 1;
          }
          else
          {
            v50 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v49);
            *(_QWORD *)(a2 + v48) = v49 + 1;
            v23 |= (unint64_t)(v50 & 0x7F) << v46;
            if (v50 < 0)
            {
              v46 += 7;
              v18 = v47++ >= 9;
              if (v18)
              {
                LODWORD(v23) = 0;
                goto LABEL_95;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v6))
          LODWORD(v23) = 0;
LABEL_95:
        v71 = 40;
        goto LABEL_112;
      case 6u:
        v51 = 0;
        v52 = 0;
        v23 = 0;
        a1[v8[419]] |= 0x40u;
        while (2)
        {
          v53 = *v4;
          v54 = *(_QWORD *)(a2 + v53);
          if (v54 == -1 || v54 >= *(_QWORD *)(a2 + *v5))
          {
            *(_BYTE *)(a2 + *v6) = 1;
          }
          else
          {
            v55 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v54);
            *(_QWORD *)(a2 + v53) = v54 + 1;
            v23 |= (unint64_t)(v55 & 0x7F) << v51;
            if (v55 < 0)
            {
              v51 += 7;
              v18 = v52++ >= 9;
              if (v18)
              {
                LODWORD(v23) = 0;
                goto LABEL_99;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v6))
          LODWORD(v23) = 0;
LABEL_99:
        v71 = 44;
        goto LABEL_112;
      case 7u:
        v56 = 0;
        v57 = 0;
        v23 = 0;
        a1[v8[419]] |= 8u;
        while (2)
        {
          v58 = *v4;
          v59 = *(_QWORD *)(a2 + v58);
          if (v59 == -1 || v59 >= *(_QWORD *)(a2 + *v5))
          {
            *(_BYTE *)(a2 + *v6) = 1;
          }
          else
          {
            v60 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v59);
            *(_QWORD *)(a2 + v58) = v59 + 1;
            v23 |= (unint64_t)(v60 & 0x7F) << v56;
            if (v60 < 0)
            {
              v56 += 7;
              v18 = v57++ >= 9;
              if (v18)
              {
                LODWORD(v23) = 0;
                goto LABEL_103;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v6))
          LODWORD(v23) = 0;
LABEL_103:
        v71 = 20;
        goto LABEL_112;
      case 8u:
        v61 = 0;
        v62 = 0;
        v23 = 0;
        a1[v8[419]] |= 0x10u;
        while (2)
        {
          v63 = *v4;
          v64 = *(_QWORD *)(a2 + v63);
          if (v64 == -1 || v64 >= *(_QWORD *)(a2 + *v5))
          {
            *(_BYTE *)(a2 + *v6) = 1;
          }
          else
          {
            v65 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v64);
            *(_QWORD *)(a2 + v63) = v64 + 1;
            v23 |= (unint64_t)(v65 & 0x7F) << v61;
            if (v65 < 0)
            {
              v61 += 7;
              v18 = v62++ >= 9;
              if (v18)
              {
                LODWORD(v23) = 0;
                goto LABEL_107;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v6))
          LODWORD(v23) = 0;
LABEL_107:
        v71 = 24;
        goto LABEL_112;
      case 9u:
        v66 = 0;
        v67 = 0;
        v23 = 0;
        a1[v8[419]] |= 1u;
        while (2)
        {
          v68 = *v4;
          v69 = *(_QWORD *)(a2 + v68);
          if (v69 == -1 || v69 >= *(_QWORD *)(a2 + *v5))
          {
            *(_BYTE *)(a2 + *v6) = 1;
          }
          else
          {
            v70 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v69);
            *(_QWORD *)(a2 + v68) = v69 + 1;
            v23 |= (unint64_t)(v70 & 0x7F) << v66;
            if (v70 < 0)
            {
              v66 += 7;
              v18 = v67++ >= 9;
              if (v18)
              {
                LODWORD(v23) = 0;
                goto LABEL_111;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v6))
          LODWORD(v23) = 0;
LABEL_111:
        v71 = 8;
LABEL_112:
        *(_DWORD *)&a1[v71] = v23;
        goto LABEL_113;
      default:
        v27 = v2;
        v28 = v8;
        v29 = v10;
        v30 = v11;
        result = PBReaderSkipValueWithTag();
        v11 = v30;
        v10 = v29;
        v8 = v28;
        v2 = v27;
        if (!(_DWORD)result)
          return result;
        goto LABEL_113;
    }
  }
}

uint64_t OUTLINED_FUNCTION_7_11@<X0>(char *a1@<X1>, uint64_t a2@<X8>)
{
  return objc_msgSend(a1, "stateStringForState:", *(unsigned int *)&a1[a2]);
}

uint64_t VCMediaNegotiationBlobVideoPayloadSettingsReadFrom(id *a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  int v15;
  char v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char v22;
  uint64_t result;
  VCMediaNegotiationBlobVideoRuleCollection *v24;
  void *String;
  char v26;
  unsigned int v27;
  uint64_t v28;
  unint64_t v29;
  char v30;
  uint64_t v31;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) >= *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
    return *(_BYTE *)(a2 + *v5) == 0;
  v7 = (int *)MEMORY[0x1E0D82BB8];
  while (2)
  {
    if (*(_BYTE *)(a2 + *v5))
      return *(_BYTE *)(a2 + *v5) == 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v11 = *v3;
      v12 = *(_QWORD *)(a2 + v11);
      if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
        break;
      v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
      *(_QWORD *)(a2 + v11) = v12 + 1;
      v10 |= (unint64_t)(v13 & 0x7F) << v8;
      if ((v13 & 0x80) == 0)
        goto LABEL_12;
      v8 += 7;
      v14 = v9++ >= 9;
      if (v14)
      {
        v10 = 0;
        v15 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
    v15 = *(unsigned __int8 *)(a2 + *v5);
    if (*(_BYTE *)(a2 + *v5))
      v10 = 0;
LABEL_14:
    if (v15 || (v10 & 7) == 4)
      return *(_BYTE *)(a2 + *v5) == 0;
    switch((v10 >> 3))
    {
      case 1u:
        v17 = 0;
        v18 = 0;
        v19 = 0;
        while (1)
        {
          v20 = *v3;
          v21 = *(_QWORD *)(a2 + v20);
          if (v21 == -1 || v21 >= *(_QWORD *)(a2 + *v4))
            break;
          v22 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v21);
          *(_QWORD *)(a2 + v20) = v21 + 1;
          v19 |= (unint64_t)(v22 & 0x7F) << v17;
          if ((v22 & 0x80) == 0)
            goto LABEL_40;
          v17 += 7;
          v14 = v18++ >= 9;
          if (v14)
          {
            LODWORD(v19) = 0;
            goto LABEL_42;
          }
        }
        *(_BYTE *)(a2 + *v5) = 1;
LABEL_40:
        if (*(_BYTE *)(a2 + *v5))
          LODWORD(v19) = 0;
LABEL_42:
        v31 = 20;
        goto LABEL_47;
      case 2u:
        v24 = objc_alloc_init(VCMediaNegotiationBlobVideoRuleCollection);
        objc_msgSend(a1, "addVideoRuleCollections:", v24);

        if (PBReaderPlaceMark() && VCMediaNegotiationBlobVideoRuleCollectionReadFrom((uint64_t)v24, a2))
        {
          PBReaderRecallMark();
LABEL_48:
          if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
            return *(_BYTE *)(a2 + *v5) == 0;
          continue;
        }
        return 0;
      case 3u:
        String = (void *)PBReaderReadString();

        a1[1] = String;
        goto LABEL_48;
      case 4u:
        v26 = 0;
        v27 = 0;
        v19 = 0;
        while (2)
        {
          v28 = *v3;
          v29 = *(_QWORD *)(a2 + v28);
          if (v29 == -1 || v29 >= *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v30 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v29);
            *(_QWORD *)(a2 + v28) = v29 + 1;
            v19 |= (unint64_t)(v30 & 0x7F) << v26;
            if (v30 < 0)
            {
              v26 += 7;
              v14 = v27++ >= 9;
              if (v14)
              {
                LODWORD(v19) = 0;
                goto LABEL_46;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          LODWORD(v19) = 0;
LABEL_46:
        v31 = 16;
LABEL_47:
        *(_DWORD *)((char *)a1 + v31) = v19;
        goto LABEL_48;
      default:
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
        goto LABEL_48;
    }
  }
}

void sub_1D8E13194(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
  objc_sync_exit(obj);
  _Unwind_Resume(a1);
}

void sub_1D8E133B4(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void OUTLINED_FUNCTION_10_14(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_fault_impl(a1, log, OS_LOG_TYPE_FAULT, a4, (uint8_t *)va, 0x26u);
}

void OUTLINED_FUNCTION_13_7(uint64_t a1@<X8>)
{
  uint64_t v1;

  *(_QWORD *)(v1 - 8) = a1;
}

void sub_1D8E15C8C(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t VCSecurityKeyManager_CopyMKMWithPrefixForParticipant(void *a1, const char *a2, uint64_t a3)
{
  return objc_msgSend(a1, "copyMKMWithPrefix:forParticipantID:", a2, a3);
}

id VCSecurityKeyManager_CopyLatestSendKeyMaterial(void *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  id v4;

  v2 = objc_msgSend(a1, "latestSendKeyMaterialWithSecurityKeyMode:", a2);
  if (!v2)
    return 0;
  v3 = v2;
  v4 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  objc_msgSend(v4, "addObject:", v3);
  return v4;
}

uint64_t VCSecurityKeyManager_AssociateKeyIndex(void *a1, const char *a2, uint64_t a3)
{
  return objc_msgSend(a1, "associateMKI:withParticipantID:", a2, a3);
}

void OUTLINED_FUNCTION_4_8(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x2Cu);
}

BOOL VCMediaNegotiationBlobV2BandwidthSettingsReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  char v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char v22;
  BOOL v23;
  int *v24;
  char v25;
  unsigned int v26;
  uint64_t v27;
  unint64_t v28;
  char v29;
  char v30;
  unsigned int v31;
  uint64_t v32;
  unint64_t v33;
  char v34;
  char v35;
  unsigned int v36;
  uint64_t v37;
  unint64_t v38;
  char v39;
  char v40;
  unsigned int v41;
  uint64_t v42;
  unint64_t v43;
  char v44;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      switch((v10 >> 3))
      {
        case 1u:
          v17 = 0;
          v18 = 0;
          v19 = 0;
          *(_BYTE *)(a1 + 28) |= 1u;
          while (1)
          {
            v20 = *v3;
            v21 = *(_QWORD *)(a2 + v20);
            if (v21 == -1 || v21 >= *(_QWORD *)(a2 + *v4))
            {
              v24 = &OBJC_IVAR___VCMediaNegotiationBlobV2BandwidthSettings__cap2G;
              goto LABEL_61;
            }
            v22 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v21);
            *(_QWORD *)(a2 + v20) = v21 + 1;
            v19 |= (unint64_t)(v22 & 0x7F) << v17;
            if ((v22 & 0x80) == 0)
              break;
            v17 += 7;
            v23 = v18++ > 8;
            if (v23)
            {
              LODWORD(v19) = 0;
              v24 = &OBJC_IVAR___VCMediaNegotiationBlobV2BandwidthSettings__cap2G;
              goto LABEL_64;
            }
          }
          v24 = &OBJC_IVAR___VCMediaNegotiationBlobV2BandwidthSettings__cap2G;
          goto LABEL_62;
        case 2u:
          v25 = 0;
          v26 = 0;
          v19 = 0;
          *(_BYTE *)(a1 + 28) |= 2u;
          while (2)
          {
            v27 = *v3;
            v28 = *(_QWORD *)(a2 + v27);
            if (v28 == -1 || v28 >= *(_QWORD *)(a2 + *v4))
            {
              v24 = &OBJC_IVAR___VCMediaNegotiationBlobV2BandwidthSettings__cap3G;
              goto LABEL_61;
            }
            v29 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v28);
            *(_QWORD *)(a2 + v27) = v28 + 1;
            v19 |= (unint64_t)(v29 & 0x7F) << v25;
            if (v29 < 0)
            {
              v25 += 7;
              v23 = v26++ > 8;
              if (v23)
              {
                LODWORD(v19) = 0;
                v24 = &OBJC_IVAR___VCMediaNegotiationBlobV2BandwidthSettings__cap3G;
                goto LABEL_64;
              }
              continue;
            }
            break;
          }
          v24 = &OBJC_IVAR___VCMediaNegotiationBlobV2BandwidthSettings__cap3G;
          goto LABEL_62;
        case 3u:
          v30 = 0;
          v31 = 0;
          v19 = 0;
          *(_BYTE *)(a1 + 28) |= 8u;
          while (2)
          {
            v32 = *v3;
            v33 = *(_QWORD *)(a2 + v32);
            if (v33 == -1 || v33 >= *(_QWORD *)(a2 + *v4))
            {
              v24 = &OBJC_IVAR___VCMediaNegotiationBlobV2BandwidthSettings__capLTE;
              goto LABEL_61;
            }
            v34 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v33);
            *(_QWORD *)(a2 + v32) = v33 + 1;
            v19 |= (unint64_t)(v34 & 0x7F) << v30;
            if (v34 < 0)
            {
              v30 += 7;
              v23 = v31++ > 8;
              if (v23)
              {
                LODWORD(v19) = 0;
                v24 = &OBJC_IVAR___VCMediaNegotiationBlobV2BandwidthSettings__capLTE;
                goto LABEL_64;
              }
              continue;
            }
            break;
          }
          v24 = &OBJC_IVAR___VCMediaNegotiationBlobV2BandwidthSettings__capLTE;
          goto LABEL_62;
        case 4u:
          v35 = 0;
          v36 = 0;
          v19 = 0;
          *(_BYTE *)(a1 + 28) |= 4u;
          while (2)
          {
            v37 = *v3;
            v38 = *(_QWORD *)(a2 + v37);
            if (v38 == -1 || v38 >= *(_QWORD *)(a2 + *v4))
            {
              v24 = &OBJC_IVAR___VCMediaNegotiationBlobV2BandwidthSettings__cap5G;
              goto LABEL_61;
            }
            v39 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v38);
            *(_QWORD *)(a2 + v37) = v38 + 1;
            v19 |= (unint64_t)(v39 & 0x7F) << v35;
            if (v39 < 0)
            {
              v35 += 7;
              v23 = v36++ > 8;
              if (v23)
              {
                LODWORD(v19) = 0;
                v24 = &OBJC_IVAR___VCMediaNegotiationBlobV2BandwidthSettings__cap5G;
                goto LABEL_64;
              }
              continue;
            }
            break;
          }
          v24 = &OBJC_IVAR___VCMediaNegotiationBlobV2BandwidthSettings__cap5G;
          goto LABEL_62;
        case 5u:
          v40 = 0;
          v41 = 0;
          v19 = 0;
          *(_BYTE *)(a1 + 28) |= 0x10u;
          break;
        default:
          if ((PBReaderSkipValueWithTag() & 1) != 0)
            continue;
          return 0;
      }
      while (1)
      {
        v42 = *v3;
        v43 = *(_QWORD *)(a2 + v42);
        if (v43 == -1 || v43 >= *(_QWORD *)(a2 + *v4))
          break;
        v44 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v43);
        *(_QWORD *)(a2 + v42) = v43 + 1;
        v19 |= (unint64_t)(v44 & 0x7F) << v40;
        if ((v44 & 0x80) == 0)
        {
          v24 = &OBJC_IVAR___VCMediaNegotiationBlobV2BandwidthSettings__capWifi;
          goto LABEL_62;
        }
        v40 += 7;
        v23 = v41++ > 8;
        if (v23)
        {
          LODWORD(v19) = 0;
          v24 = &OBJC_IVAR___VCMediaNegotiationBlobV2BandwidthSettings__capWifi;
          goto LABEL_64;
        }
      }
      v24 = &OBJC_IVAR___VCMediaNegotiationBlobV2BandwidthSettings__capWifi;
LABEL_61:
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_62:
      if (*(_BYTE *)(a2 + *v5))
        LODWORD(v19) = 0;
LABEL_64:
      *(_DWORD *)(a1 + *v24) = v19;
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void sub_1D8E2026C(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1D8E21C0C(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1D8E2917C()
{
  objc_end_catch();
  JUMPOUT(0x1D8E2918CLL);
}

uint64_t OUTLINED_FUNCTION_14_12@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  *(_QWORD *)(v2 - 24) = a2;
  return a1;
}

uint64_t OUTLINED_FUNCTION_15_7@<X0>(void *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  *(_QWORD *)(v2 - 24) = a2;
  return objc_msgSend(a1, "metadata");
}

BOOL VCVideoCaptureConverter_ProcessFrame(uint64_t a1, uint64_t a2, __int128 *a3, uint64_t a4)
{
  unsigned int v8;
  int v9;
  double v10;
  const void *v11;
  void (*v12)(const void *, uint64_t, __int128 *, uint64_t);
  __int128 v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (!*(_BYTE *)(a1 + 32)
      || (v8 = *(_DWORD *)(a1 + 24),
          v9 = *(_DWORD *)(a1 + 28),
          v10 = (double)v8 / *(double *)(a1 + 16),
          *(_DWORD *)(a1 + 24) = v8 + 1,
          *(_DWORD *)(a1 + 28) = v10,
          v9 != v10))
    {
      v11 = (const void *)MEMORY[0x1DF086F1C](a1 + 40);
      v12 = *(void (**)(const void *, uint64_t, __int128 *, uint64_t))(a1 + 48);
      v14 = *a3;
      v15 = *((_QWORD *)a3 + 2);
      v12(v11, a2, &v14, a4);
      if (v11)
        CFRelease(v11);
    }
  }
  return a1 != 0;
}

void VCConnectionHealthMonitor_UpdateReceiveStats(uint64_t a1)
{
  double v2;
  double v3;
  int v4;
  double v5;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  _BYTE v9[24];
  void *v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v2 = micro();
  if (a1)
  {
    v3 = v2;
    pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 304));
    if (v3 - *(double *)(a1 + 512) > 1.0)
    {
      _VCConnectionHealthMonitor_UpdateStatsHistory((_BYTE *)a1);
      *(_BYTE *)(a1 + 507) = *(_BYTE *)(a1 + 507)
                           + 1
                           - 120 * ((547 * (*(unsigned __int8 *)(a1 + 507) + 1)) >> 16);
      v4 = *(unsigned __int8 *)(a1 + 520);
      *(_BYTE *)(a1 + 504) = v4;
      *(_WORD *)(a1 + 505) = *(_WORD *)(a1 + 521);
      *(_BYTE *)(a1 + 520) = 0;
      *(_WORD *)(a1 + 521) = 0;
      *(double *)(a1 + 512) = v3;
      if (!*(_BYTE *)(a1 + 288))
      {
        if (*(_BYTE *)(a1 + 536))
        {
          v5 = *(double *)(a1 + 296);
          if (v4)
          {
            if (v5 != 0.0)
            {
              if (v3 - v5 >= 8.0)
              {
                v6 = *(NSObject **)(a1 + 280);
                if (v6)
                {
                  *(_QWORD *)v9 = MEMORY[0x1E0C809B0];
                  *(_QWORD *)&v9[8] = 3221225472;
                  *(_QWORD *)&v9[16] = ___VCConnectionHealthMonitor_checkAndReportSymptomOnRecoveryAfterLongMediaStall_block_invoke;
                  v10 = &unk_1E9E521C0;
                  v11 = a1;
                  dispatch_async(v6, v9);
                }
                *(_BYTE *)(a1 + 288) = 1;
              }
              else
              {
                *(_QWORD *)(a1 + 296) = 0;
              }
            }
          }
          else if (v5 == 0.0)
          {
            *(double *)(a1 + 296) = v3;
          }
        }
      }
    }
    pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 304));
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v7 = VRTraceErrorLogLevelToCSTR();
    v8 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v9 = 136315650;
      *(_QWORD *)&v9[4] = v7;
      *(_WORD *)&v9[12] = 2080;
      *(_QWORD *)&v9[14] = "VCConnectionHealthMonitor_UpdateReceiveStats";
      *(_WORD *)&v9[22] = 1024;
      LODWORD(v10) = 93;
      _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", v9, 0x1Cu);
    }
  }
}

void _VCConnectionHealthMonitor_UpdateStatsHistory(_BYTE *a1)
{
  uint64_t v1;
  unsigned int v2;
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  _BYTE *v7;
  uint64_t v8;
  NSObject *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  __int16 v28;
  int v29;
  __int16 v30;
  int v31;
  __int16 v32;
  int v33;
  __int16 v34;
  int v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v1 = (uint64_t)(a1 + 9);
  v2 = a1[507];
  if (a1[9] != v2)
  {
    a1[9] = v2;
    v4 = (v2 - 5 * ((858993460 * (unint64_t)v2) >> 32));
    v5 = a1 + 10;
    a1[v4 + 10] = a1[504];
    v6 = a1 + 15;
    a1[v4 + 15] = a1[505];
    v7 = a1 + 20;
    a1[v4 + 20] = a1[506];
    _VCConnectionHealthMonitor_UpdateRatiosForHistory((uint64_t)(a1 + 9), v2 - 5 * ((858993460 * (unint64_t)v2) >> 32));
    if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      v8 = VRTraceErrorLogLevelToCSTR();
      v9 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v10 = a1[9];
        v11 = v6[v4];
        v12 = v7[v4];
        v13 = v5[v4];
        v14 = a1[v4 + 25];
        v15 = a1[v4 + 30];
        v16 = 136317442;
        v17 = v8;
        v18 = 2080;
        v19 = "_VCConnectionHealthMonitor_UpdateStatsHistory";
        v20 = 1024;
        v21 = 238;
        v22 = 1024;
        v23 = v4;
        v24 = 1024;
        v25 = v10;
        v26 = 1024;
        v27 = v11;
        v28 = 1024;
        v29 = v12;
        v30 = 1024;
        v31 = v13;
        v32 = 1024;
        v33 = v14;
        v34 = 1024;
        v35 = v15;
        _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d HandoverReport: send - last received packet with index %d, %u, bucket [%u %u %u] ratios [%u %u]", (uint8_t *)&v16, 0x46u);
      }
    }
    VCConnectionHealthMonitor_ReportConnectionHealthWithStatsHistory((uint64_t)a1, v1, v4, 0);
  }
}

uint64_t _VCConnectionHealthMonitor_UpdateRatiosForHistory(uint64_t result, int a2)
{
  unsigned int v2;
  uint64_t i;
  uint64_t v4;
  char v5;
  uint64_t v6;
  int v7;
  char v8;
  unsigned int v9;

  v2 = 0;
  for (i = 1; i != 6; ++i)
    v2 += *(unsigned __int8 *)(result + i);
  v4 = 0;
  v5 = 1;
  do
  {
    v6 = 0;
    v7 = 0;
    v8 = v5;
    do
      v7 += *(unsigned __int8 *)(result + 6 + 5 * v4 + v6++);
    while (v6 != 5);
    if (v2)
      v9 = 100 * v7 / v2;
    else
      LOBYTE(v9) = 0;
    v5 = 0;
    *(_BYTE *)(result + a2 + 5 * v4 + 16) = v9;
    v4 = 1;
  }
  while ((v8 & 1) != 0);
  return result;
}

void VCConnectionHealthMonitor_ReportConnectionHealthWithStatsHistory(uint64_t a1, uint64_t a2, int a3, int a4)
{
  char v4;
  uint64_t v6;
  int v7;
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  const char *v11;
  uint64_t v12;
  _QWORD v13[5];
  int v14;
  char v15;
  uint8_t buf[4];
  uint64_t v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 5)
      return;
    v9 = VRTraceErrorLogLevelToCSTR();
    v10 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      return;
    *(_DWORD *)buf = 136315650;
    v17 = v9;
    v18 = 2080;
    v19 = "VCConnectionHealthMonitor_ReportConnectionHealthWithStatsHistory";
    v20 = 1024;
    v21 = 253;
    v11 = " [%s] %s:%d nil instance passed";
LABEL_22:
    _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, v11, buf, 0x1Cu);
    return;
  }
  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 5)
      return;
    v12 = VRTraceErrorLogLevelToCSTR();
    v10 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      return;
    *(_DWORD *)buf = 136315650;
    v17 = v12;
    v18 = 2080;
    v19 = "VCConnectionHealthMonitor_ReportConnectionHealthWithStatsHistory";
    v20 = 1024;
    v21 = 254;
    v11 = " [%s] %s:%d nil statsHistory passed";
    goto LABEL_22;
  }
  v4 = a4;
  if (*(_BYTE *)(a2 + a3 + 1) || !*(_BYTE *)(a1 + 536))
  {
    if (*(_BYTE *)(a2 + a3 + 6))
    {
      v6 = 240;
      if (a4)
        v6 = 9;
      if (VCConnectionHealthMonitor_IsPrimaryConnectionImprovedFromHistory(a1, a2, a3, a1 + v6))
        v7 = 3;
      else
        v7 = 0;
    }
    else
    {
      v7 = 2;
    }
  }
  else
  {
    v7 = 1;
  }
  v8 = *(NSObject **)(a1 + 280);
  if (v8)
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __VCConnectionHealthMonitor_ReportConnectionHealthWithStatsHistory_block_invoke;
    v13[3] = &unk_1E9E55ED0;
    v13[4] = a1;
    v14 = v7;
    v15 = v4;
    dispatch_async(v8, v13);
  }
}

BOOL VCConnectionHealthMonitor_IsPrimaryConnectionImprovedFromHistory(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v4;
  unsigned __int8 v5;
  int v6;
  unsigned __int8 v7;
  unsigned int v8;
  BOOL v9;
  uint64_t v10;
  _BOOL8 result;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  NSObject *v16;
  _BOOL4 v17;
  const char *v18;
  uint64_t v19;
  _BOOL4 v20;
  uint64_t v21;
  _BOOL4 v22;
  int v23;
  uint64_t v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  int v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 5)
      return 0;
    v15 = VRTraceErrorLogLevelToCSTR();
    v16 = *MEMORY[0x1E0CF2758];
    v17 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v17)
      return result;
    v23 = 136315650;
    v24 = v15;
    v25 = 2080;
    v26 = "VCConnectionHealthMonitor_IsPrimaryConnectionImprovedFromHistory";
    v27 = 1024;
    v28 = 320;
    v18 = " [%s] %s:%d nil instance passed";
LABEL_32:
    _os_log_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEFAULT, v18, (uint8_t *)&v23, 0x1Cu);
    return 0;
  }
  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 5)
      return 0;
    v19 = VRTraceErrorLogLevelToCSTR();
    v16 = *MEMORY[0x1E0CF2758];
    v20 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v20)
      return result;
    v23 = 136315650;
    v24 = v19;
    v25 = 2080;
    v26 = "VCConnectionHealthMonitor_IsPrimaryConnectionImprovedFromHistory";
    v27 = 1024;
    v28 = 321;
    v18 = " [%s] %s:%d nil statsHistory passed";
    goto LABEL_32;
  }
  if (!a4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v21 = VRTraceErrorLogLevelToCSTR();
      v16 = *MEMORY[0x1E0CF2758];
      v22 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
      result = 0;
      if (!v22)
        return result;
      v23 = 136315650;
      v24 = v21;
      v25 = 2080;
      v26 = "VCConnectionHealthMonitor_IsPrimaryConnectionImprovedFromHistory";
      v27 = 1024;
      v28 = 322;
      v18 = " [%s] %s:%d nil statsHistory passed";
      goto LABEL_32;
    }
    return 0;
  }
  v4 = a2 + 16;
  v5 = *(_BYTE *)(a2 + 16 + (a3 + 1) % 5);
  v6 = a3 + 2;
  do
  {
    v7 = *(_BYTE *)(v4 + v6 % 5);
    v8 = (v5 - 1);
    v9 = v8 < v7 && v6++ < a3 + 5;
    v5 = v7;
  }
  while (v9);
  if (v8 >= v7 || *(unsigned __int8 *)(v4 + a3) < 0x32u || !*(_BYTE *)(a2 + 6))
    return 0;
  v10 = 0;
  while (v10 != 4)
  {
    if (!*(unsigned __int8 *)(a2 + 7 + v10++))
    {
      if ((unint64_t)(v10 - 1) < 4)
        return 0;
      break;
    }
  }
  if (*(_BYTE *)(a1 + 552))
    return 1;
  if (!*(_BYTE *)(a4 + 6))
    return 0;
  v13 = 0;
  do
  {
    v14 = v13;
    if (v13 == 4)
      break;
    ++v13;
  }
  while (*(_BYTE *)(a4 + 7 + v14));
  return v14 > 3;
}

void VCConnectionHealthMonitor_ReceivePacket(uint64_t a1, int a2, int a3, int a4)
{
  double v8;
  BOOL v9;
  uint64_t v10;
  NSObject *v11;
  double v12;
  uint64_t v13;
  _BYTE *v14;
  char v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v8 = micro();
  if (!a4 || a2)
  {
    pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 304));
    if (*(_BYTE *)(a1 + 536))
      v9 = 1;
    else
      v9 = a2 == 0;
    if (!v9)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v10 = VRTraceErrorLogLevelToCSTR();
        v11 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v18 = 136315650;
          v19 = v10;
          v20 = 2080;
          v21 = "VCConnectionHealthMonitor_ReceivePacket";
          v22 = 1024;
          v23 = 381;
          _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d First packet received", (uint8_t *)&v18, 0x1Cu);
        }
      }
      *(_BYTE *)(a1 + 536) = 1;
    }
    v12 = *(double *)(a1 + 544);
    v13 = 504;
    if (v8 > *(double *)(a1 + 512) + 1.0 - v12)
      v13 = 520;
    v14 = (_BYTE *)(a1 + v13);
    if ((a4 & 1) != 0)
    {
      v15 = v14[2];
      if (v15)
      {
        v16 = a3 & 0x3FF;
        if (*(unsigned __int16 *)(a1 + 560 + 16 * v16) == a3 && v8 - *(double *)(a1 + 560 + 16 * v16 + 8) < v12)
        {
          ++v14[1];
          v14[2] = v15 - 1;
        }
      }
    }
    else
    {
      ++*v14;
      if (a2)
      {
        ++v14[1];
      }
      else
      {
        ++v14[2];
        v17 = a1 + 16 * (a3 & 0x3FF);
        *(_WORD *)(v17 + 560) = a3;
        *(_DWORD *)(v17 + 562) = 0;
        *(_WORD *)(v17 + 566) = 0;
        *(double *)(v17 + 568) = v8;
      }
    }
    pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 304));
  }
}

uint64_t VCConnectionHealthMonitor_ReceiveServerStats(uint64_t a1, int a2)
{
  pthread_rwlock_t *v4;
  BOOL v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  int v10;
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v4 = (pthread_rwlock_t *)(a1 + 304);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 304));
  if (*(_BYTE *)(a1 + 536))
    v5 = 1;
  else
    v5 = a2 == 0;
  if (!v5)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v6 = VRTraceErrorLogLevelToCSTR();
      v7 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v10 = 136315650;
        v11 = v6;
        v12 = 2080;
        v13 = "VCConnectionHealthMonitor_ReceiveServerStats";
        v14 = 1024;
        v15 = 402;
        _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d First packet received", (uint8_t *)&v10, 0x1Cu);
      }
    }
    *(_BYTE *)(a1 + 536) = 1;
  }
  ++*(_BYTE *)(a1 + 504);
  v8 = 505;
  if (!a2)
    v8 = 506;
  ++*(_BYTE *)(a1 + v8);
  return pthread_rwlock_unlock(v4);
}

char *VCPixelBufferOverlay_updateOverlayWithPixelBuffer(char *result, __CVBuffer *a2)
{
  char *v3;
  double v4;
  int Width;
  int Height;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const __CFNumber *Attachment;
  const __CFNumber *v11;
  int v12;
  CFIndex v13;
  int v14;
  int v15;
  int CharacterAtIndex;
  int v17;
  const void *v18;
  double v19;
  double v20;
  int v21;
  double v22;
  CGColorSpace *DeviceGray;
  CGColorRef v24;
  float v25;
  double v26;
  CTFontRef UIFontForLanguage;
  void *v28;
  CFDictionaryRef v29;
  double *v30;
  double v31;
  double v32;
  unsigned int v33;
  int v34;
  CGFloat *v35;
  int v36;
  int v37;
  float v38;
  float v39;
  float v40;
  float v41;
  CGFloat v42;
  CGFloat v43;
  CGFloat v44;
  CGFloat v45;
  CGFloat v46;
  CGFloat v47;
  float v48;
  CGFloat a;
  CGFloat b;
  __int128 v51;
  __int128 v52;
  char *v53;
  float v54;
  float v55;
  float v56;
  __CFString *v57;
  char v58;
  uint64_t v59;
  int *v60;
  uint64_t v61;
  CGFloat v62;
  uint64_t v63;
  uint64_t v64;
  int v65;
  uint64_t v66;
  uint64_t v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  uint64_t v77;
  uint64_t v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  int v82;
  int v83;
  int BytesPerRowOfPlane;
  void *BaseAddressOfPlane;
  void *v86;
  CGColorSpace *v87;
  CGColorSpace *v88;
  CGContext *v89;
  CGContext *v90;
  __int128 v91;
  __int128 v92;
  const __CFAttributedString *v93;
  const __CFAttributedString *v94;
  CTFramesetterRef v95;
  const __CTFramesetter *v96;
  CGColor *SRGB;
  CGPath *Mutable;
  const CGPath *v99;
  const __CTFrame *Frame;
  const __CTFrame *v101;
  uint64_t v102;
  NSObject *v103;
  const char *v104;
  uint64_t v105;
  uint64_t v106;
  NSObject *v107;
  uint64_t v108;
  NSObject *v109;
  uint64_t v110;
  NSObject *v111;
  uint64_t v112;
  NSObject *v113;
  const char *v114;
  uint64_t v115;
  float v116;
  float v117;
  double v118;
  int v119;
  char v120;
  CGAffineTransform v121;
  CGAffineTransform v122;
  int v123;
  double v124;
  double v125;
  double v126;
  double v127;
  int v128;
  void *values[2];
  __int128 v130;
  __int128 v131;
  __int128 v132;
  __int128 v133;
  void *keys[2];
  __int128 v135;
  __int128 v136;
  __int128 v137;
  __int128 v138;
  CGAffineTransform valuePtr;
  __int128 v140;
  __int128 v141;
  __int128 v142;
  __int128 v143;
  __int128 v144;
  __int128 v145;
  __int128 v146;
  __int128 v147;
  __int128 v148;
  __int128 v149;
  __int128 v150;
  __int128 v151;
  unint64_t v152;
  uint64_t v153;
  CFRange v154;
  CFRange v155;
  CGSize v156;

  v153 = *MEMORY[0x1E0C80C00];
  if (!result)
    return result;
  if (!a2)
    return result;
  v3 = result;
  result = (char *)objc_msgSend(result, "currentDetails");
  if (!v120)
    return result;
  v4 = micro();
  Width = CVPixelBufferGetWidth(a2);
  Height = CVPixelBufferGetHeight(a2);
  v7 = *((_QWORD *)v3 + 24);
  if (v7)
    VCOverlaySource_Read(v7);
  v8 = *((_QWORD *)v3 + 23);
  if (v8)
    VCOverlaySource_Read(v8);
  v9 = *((_QWORD *)v3 + 25);
  if (v9)
    VCOverlaySource_Read(v9);
  LODWORD(valuePtr.a) = Width;
  LODWORD(keys[0]) = Height;
  Attachment = (const __CFNumber *)CVBufferGetAttachment(a2, CFSTR("VraWidth"), 0);
  if (Attachment)
    CFNumberGetValue(Attachment, kCFNumberIntType, &valuePtr);
  v11 = (const __CFNumber *)CVBufferGetAttachment(a2, CFSTR("VraHeight"), 0);
  v12 = Height;
  if (v11)
  {
    CFNumberGetValue(v11, kCFNumberIntType, keys);
    v12 = (int)keys[0];
  }
  v119 = Width;
  *((double *)v3 + 40) = (double)SLODWORD(valuePtr.a);
  *((double *)v3 + 41) = (double)v12;
  if (CFStringGetLength(*((CFStringRef *)v3 + 37)) < 1)
  {
    v14 = 0;
  }
  else
  {
    v13 = 0;
    v14 = 0;
    v15 = 0;
    do
    {
      CharacterAtIndex = CFStringGetCharacterAtIndex(*((CFStringRef *)v3 + 37), v13);
      if (v14 <= v15)
        v17 = v15;
      else
        v17 = v14;
      if (CharacterAtIndex == 10)
        v15 = 0;
      else
        ++v15;
      if (CharacterAtIndex == 10)
        v14 = v17;
      ++v13;
    }
    while (CFStringGetLength(*((CFStringRef *)v3 + 37)) > v13);
  }
  if (*((_DWORD *)v3 + 84) != v14 || v4 - *((double *)v3 + 44) > 5.0)
  {
    *((double *)v3 + 44) = v4;
    v18 = (const void *)*((_QWORD *)v3 + 36);
    if (v18)
      CFRelease(v18);
    v19 = *((double *)v3 + 34);
    v20 = *((double *)v3 + 35);
    if (v14 >= 75)
      v21 = 75;
    else
      v21 = v14;
    v22 = (double)v21;
    DeviceGray = CGColorSpaceCreateDeviceGray();
    *(_OWORD *)&valuePtr.a = xmmword_1D910F1C0;
    v24 = CGColorCreate(DeviceGray, &valuePtr.a);
    v25 = v19 * v20;
    v26 = fmin(round(sqrtf(v25) / v22), 32.0);
    if (v26 < 20.0)
      v26 = 20.0;
    UIFontForLanguage = CTFontCreateUIFontForLanguage(kCTFontUIFontUserFixedPitch, v26, 0);
    v28 = (void *)*MEMORY[0x1E0CA8550];
    keys[0] = *(void **)MEMORY[0x1E0CA8188];
    keys[1] = v28;
    values[0] = UIFontForLanguage;
    values[1] = v24;
    v29 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)keys, (const void **)values, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (v24)
      CFRelease(v24);
    if (UIFontForLanguage)
      CFRelease(UIFontForLanguage);
    if (DeviceGray)
      CFRelease(DeviceGray);
    *((_QWORD *)v3 + 36) = v29;
    *((_DWORD *)v3 + 84) = v14;
  }
  v30 = (double *)(v3 + 320);
  if ((*((double *)v3 + 40) != (double)*((int *)v3 + 77) || *((double *)v3 + 41) != (double)*((int *)v3 + 78))
    && v4 - *((double *)v3 + 43) > 5.0)
  {
    *((double *)v3 + 43) = v4;
    v31 = *v30;
    v32 = *((double *)v3 + 41);
    if (*v30 >= v32)
      v32 = *v30;
    v33 = (int)v32;
    if (((int)v32 - 513) >= 0x200)
    {
      if (v33 - 101 > 0x19B)
      {
        if (v33 < 0x65)
          v34 = 1;
        else
          v34 = 4;
      }
      else
      {
        v34 = 2;
      }
    }
    else
    {
      v34 = 3;
    }
    if (v3[304] != v34)
    {
      v3[304] = v34;
      v31 = *((double *)v3 + 40);
    }
    *((_DWORD *)v3 + 77) = (int)v31;
    *((_DWORD *)v3 + 78) = (int)*((double *)v3 + 41);
  }
  objc_msgSend(v3, "currentDetails");
  v35 = (CGFloat *)MEMORY[0x1E0C9BAA8];
  if (LOBYTE(valuePtr.a))
  {
    v118 = v4;
    v136 = xmmword_1D910F048;
    v137 = unk_1D910F058;
    v138 = xmmword_1D910F068;
    *(_OWORD *)keys = xmmword_1D910F028;
    v135 = unk_1D910F038;
    objc_msgSend(v3, "currentDetails");
    LOBYTE(keys[0]) = 0;
    v131 = v136;
    v132 = v137;
    v133 = v138;
    *(_OWORD *)values = *(_OWORD *)keys;
    v130 = v135;
    objc_msgSend(v3, "setCurrentDetails:", values);
    v128 = -1431655766;
    objc_msgSend(v3, "currentDetails");
    FigCFDictionaryGetIntIfPresent();
    v36 = CVPixelBufferGetWidth(a2);
    v37 = CVPixelBufferGetHeight(a2);
    objc_msgSend(v3, "currentDetails");
    v38 = v127 * (double)v36;
    v117 = v38;
    objc_msgSend(v3, "currentDetails");
    v39 = v126 * (double)v37;
    v116 = v39;
    objc_msgSend(v3, "currentDetails");
    v40 = v125 * (double)v36;
    objc_msgSend(v3, "currentDetails");
    v41 = v124 * (double)v37;
    v43 = *v35;
    v42 = v35[1];
    v45 = v35[2];
    v44 = v35[3];
    v47 = v35[4];
    v46 = v35[5];
    objc_msgSend(v3, "currentDetails");
    if (v123)
    {
      v56 = v41 * 0.5;
      v121.a = v43;
      v121.b = v42;
      v121.c = v45;
      v121.d = v44;
      v121.tx = v47;
      v121.ty = v46;
      CGAffineTransformTranslate(&v122, &v121, v40, v56);
      a = v122.a;
      b = v122.b;
      v52 = *(_OWORD *)&v122.c;
      v51 = *(_OWORD *)&v122.tx;
      v53 = v3 + 256;
      v55 = (float)(v40 * 0.5) + v117;
      v54 = v56 + v116;
    }
    else
    {
      v48 = v40 * 0.5;
      v121.a = v43;
      v121.b = v42;
      v121.c = v45;
      v121.d = v44;
      v121.tx = v47;
      v121.ty = v46;
      CGAffineTransformTranslate(&v122, &v121, v48, (float)(v41 * 0.5));
      v121 = v122;
      CGAffineTransformRotate(&v122, &v121, 3.14159265);
      v121 = v122;
      CGAffineTransformTranslate(&v122, &v121, (float)((float)-v117 - v48), (float)((float)-v116 - (float)(v41 * 0.5)));
      a = v122.a;
      b = v122.b;
      v52 = *(_OWORD *)&v122.c;
      v51 = *(_OWORD *)&v122.tx;
      v53 = v3 + 256;
      v54 = (float)(v41 * 0.5) + v116;
      v55 = v48 + v117;
    }
    *(_QWORD *)v53 = 0;
    *((_QWORD *)v53 + 1) = 0;
    *((double *)v53 + 2) = v55;
    *((double *)v53 + 3) = v54;
    *((CGFloat *)v3 + 26) = a;
    *((CGFloat *)v3 + 27) = b;
    *((_OWORD *)v3 + 14) = v52;
    *((_OWORD *)v3 + 15) = v51;
    v4 = v118;
  }
  v57 = (__CFString *)*((_QWORD *)v3 + 37);
  v154.length = CFStringGetLength(v57);
  v154.location = 0;
  CFStringDelete(v57, v154);
  v58 = v3[304];
  if (v58)
  {
    v59 = *((_QWORD *)v3 + 24);
    v60 = &OBJC_IVAR___VCEmulatedNetworkAlgorithmQueueLoss__expectedProcessEndTime;
    if (v59)
    {
      v61 = *(_QWORD *)(v59 + 48);
      if (v61)
      {
        valuePtr.a = *((CGFloat *)v3 + 37);
        LOBYTE(valuePtr.b) = v58;
        *(_DWORD *)((char *)&valuePtr.b + 1) = 0;
        HIDWORD(valuePtr.b) = 0;
        v62 = *((double *)v3 + 22);
        valuePtr.c = *(CGFloat *)(v61 + 16);
        valuePtr.d = v62;
        valuePtr.tx = v4;
        v63 = *((_QWORD *)v3 + 25);
        if (v63)
        {
          v64 = *(_QWORD *)(v63 + 48);
          if (v64)
          {
            v65 = *(_DWORD *)(v64 + 8);
            HIDWORD(valuePtr.b) = *(_DWORD *)(v64 + 11);
            *(_DWORD *)((char *)&valuePtr.b + 1) = v65;
          }
        }
        VCOverlaySourceTextHelper_appendHeaderTextToString((uint64_t)&valuePtr);
      }
    }
  }
  else
  {
    v60 = &OBJC_IVAR___VCEmulatedNetworkAlgorithmQueueLoss__expectedProcessEndTime;
  }
  v66 = *((_QWORD *)v3 + 24);
  if (v66)
  {
    v67 = *(_QWORD *)(v66 + 48);
    if (v67)
    {
      v149 = xmmword_1D910F138;
      v150 = unk_1D910F148;
      v151 = xmmword_1D910F158;
      v152 = 0xAAAAAAAAFFFFFFFFLL;
      v145 = xmmword_1D910F0F8;
      v146 = unk_1D910F108;
      v147 = xmmword_1D910F118;
      v148 = unk_1D910F128;
      v141 = xmmword_1D910F0B8;
      v142 = unk_1D910F0C8;
      v143 = xmmword_1D910F0D8;
      v144 = unk_1D910F0E8;
      valuePtr = *(CGAffineTransform *)byte_1D910F078;
      v140 = unk_1D910F0A8;
      valuePtr.a = *((CGFloat *)v3 + 37);
      LOBYTE(valuePtr.b) = v3[304];
      v68 = *(_OWORD *)(v67 + 184);
      v69 = *(_OWORD *)(v67 + 168);
      v70 = *(_OWORD *)(v67 + 152);
      v146 = *(_OWORD *)(v67 + 136);
      v147 = v70;
      v148 = v69;
      v149 = v68;
      v71 = *(_OWORD *)(v67 + 120);
      v72 = *(_OWORD *)(v67 + 104);
      v73 = *(_OWORD *)(v67 + 88);
      v142 = *(_OWORD *)(v67 + 72);
      v143 = v73;
      v144 = v72;
      v145 = v71;
      v74 = *(_OWORD *)(v67 + 56);
      v75 = *(_OWORD *)(v67 + 40);
      v76 = *(_OWORD *)(v67 + 24);
      *(_OWORD *)&valuePtr.c = *(_OWORD *)(v67 + 8);
      *(_OWORD *)&valuePtr.tx = v76;
      v140 = v75;
      v141 = v74;
      *(double *)&v150 = (double)v119;
      *((double *)&v150 + 1) = (double)Height;
      v151 = *((_OWORD *)v3 + 20);
      LODWORD(v152) = *((_DWORD *)v3 + 92);
      VCOverlaySourceTextHelper_appendVideoTextToString((uint64_t)&valuePtr);
    }
  }
  v77 = *(_QWORD *)&v3[v60[521]];
  if (v77)
  {
    v78 = *(_QWORD *)(v77 + 48);
    if (v78)
    {
      *(_OWORD *)&valuePtr.a = xmmword_1D910F170;
      valuePtr.a = *((CGFloat *)v3 + 37);
      LOBYTE(valuePtr.b) = v3[304];
      v79 = *(_OWORD *)(v78 + 8);
      v80 = *(_OWORD *)(v78 + 24);
      v81 = *(_OWORD *)(v78 + 40);
      *(_QWORD *)&v141 = *(_QWORD *)(v78 + 56);
      *(_OWORD *)&valuePtr.tx = v80;
      v140 = v81;
      *(_OWORD *)&valuePtr.c = v79;
      VCOverlaySourceTextHelper_appendAudioTextToString((uint64_t)&valuePtr);
    }
  }
  v82 = CVPixelBufferGetWidth(a2);
  v83 = CVPixelBufferGetHeight(a2);
  BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(a2, 0);
  CVPixelBufferLockBaseAddress(a2, 0);
  BaseAddressOfPlane = CVPixelBufferGetBaseAddressOfPlane(a2, 0);
  if (!BaseAddressOfPlane)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 7)
      goto LABEL_103;
    v102 = VRTraceErrorLogLevelToCSTR();
    v103 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      goto LABEL_103;
    LODWORD(valuePtr.a) = 136315650;
    *(_QWORD *)((char *)&valuePtr.a + 4) = v102;
    WORD2(valuePtr.b) = 2080;
    *(_QWORD *)((char *)&valuePtr.b + 6) = "_VCPixelBufferOverlay_renderText";
    HIWORD(valuePtr.c) = 1024;
    LODWORD(valuePtr.d) = 225;
    v104 = " [%s] %s:%d CVPixelBufferGetBaseAddressOfPlane was NULL";
    goto LABEL_102;
  }
  v86 = BaseAddressOfPlane;
  v87 = CGColorSpaceCreateDeviceGray();
  if (!v87)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 7)
      goto LABEL_103;
    v105 = VRTraceErrorLogLevelToCSTR();
    v103 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      goto LABEL_103;
    LODWORD(valuePtr.a) = 136315650;
    *(_QWORD *)((char *)&valuePtr.a + 4) = v105;
    WORD2(valuePtr.b) = 2080;
    *(_QWORD *)((char *)&valuePtr.b + 6) = "_VCPixelBufferOverlay_renderText";
    HIWORD(valuePtr.c) = 1024;
    LODWORD(valuePtr.d) = 228;
    v104 = " [%s] %s:%d CGColorSpaceCreateDeviceGray was NULL";
LABEL_102:
    _os_log_impl(&dword_1D8A54000, v103, OS_LOG_TYPE_DEFAULT, v104, (uint8_t *)&valuePtr, 0x1Cu);
LABEL_103:
    v88 = 0;
LABEL_107:
    v90 = 0;
LABEL_108:
    v94 = 0;
LABEL_109:
    v96 = 0;
    v99 = 0;
    v101 = 0;
    goto LABEL_86;
  }
  v88 = v87;
  v89 = CGBitmapContextCreate(v86, v82, v83, 8uLL, BytesPerRowOfPlane, v87, 0);
  if (!v89)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v106 = VRTraceErrorLogLevelToCSTR();
      v107 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(valuePtr.a) = 136315650;
        *(_QWORD *)((char *)&valuePtr.a + 4) = v106;
        WORD2(valuePtr.b) = 2080;
        *(_QWORD *)((char *)&valuePtr.b + 6) = "_VCPixelBufferOverlay_renderText";
        HIWORD(valuePtr.c) = 1024;
        LODWORD(valuePtr.d) = 231;
        _os_log_impl(&dword_1D8A54000, v107, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d CGBitmatContextCreate was NULL", (uint8_t *)&valuePtr, 0x1Cu);
      }
    }
    goto LABEL_107;
  }
  v90 = v89;
  v91 = *((_OWORD *)v3 + 14);
  *(_OWORD *)&valuePtr.a = *((_OWORD *)v3 + 13);
  *(_OWORD *)&valuePtr.c = v91;
  *(_OWORD *)&valuePtr.tx = *((_OWORD *)v3 + 15);
  CGContextConcatCTM(v89, &valuePtr);
  v92 = *((_OWORD *)v35 + 1);
  *(_OWORD *)&valuePtr.a = *(_OWORD *)v35;
  *(_OWORD *)&valuePtr.c = v92;
  *(_OWORD *)&valuePtr.tx = *((_OWORD *)v35 + 2);
  CGContextSetTextMatrix(v90, &valuePtr);
  v93 = CFAttributedStringCreate(0, *((CFStringRef *)v3 + 37), *((CFDictionaryRef *)v3 + 36));
  if (!v93)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v108 = VRTraceErrorLogLevelToCSTR();
      v109 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(valuePtr.a) = 136315650;
        *(_QWORD *)((char *)&valuePtr.a + 4) = v108;
        WORD2(valuePtr.b) = 2080;
        *(_QWORD *)((char *)&valuePtr.b + 6) = "_VCPixelBufferOverlay_renderText";
        HIWORD(valuePtr.c) = 1024;
        LODWORD(valuePtr.d) = 237;
        _os_log_impl(&dword_1D8A54000, v109, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d CFAttributedStringCreate was NULL", (uint8_t *)&valuePtr, 0x1Cu);
      }
    }
    goto LABEL_108;
  }
  v94 = v93;
  v95 = CTFramesetterCreateWithAttributedString(v93);
  if (!v95)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v110 = VRTraceErrorLogLevelToCSTR();
      v111 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(valuePtr.a) = 136315650;
        *(_QWORD *)((char *)&valuePtr.a + 4) = v110;
        WORD2(valuePtr.b) = 2080;
        *(_QWORD *)((char *)&valuePtr.b + 6) = "_VCPixelBufferOverlay_renderText";
        HIWORD(valuePtr.c) = 1024;
        LODWORD(valuePtr.d) = 241;
        _os_log_impl(&dword_1D8A54000, v111, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d CTFramesetterCreateWithAttributedString was NULL", (uint8_t *)&valuePtr, 0x1Cu);
      }
    }
    goto LABEL_109;
  }
  v96 = v95;
  SRGB = CGColorCreateSRGB(0.0, 0.0, 0.0, 1.0);
  v156.width = 0.0;
  v156.height = 0.0;
  CGContextSetShadowWithColor(v90, v156, 2.0, SRGB);
  Mutable = CGPathCreateMutable();
  v99 = Mutable;
  if (!Mutable)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v112 = VRTraceErrorLogLevelToCSTR();
      v113 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(valuePtr.a) = 136315650;
        *(_QWORD *)((char *)&valuePtr.a + 4) = v112;
        WORD2(valuePtr.b) = 2080;
        *(_QWORD *)((char *)&valuePtr.b + 6) = "_VCPixelBufferOverlay_renderText";
        HIWORD(valuePtr.c) = 1024;
        LODWORD(valuePtr.d) = 249;
        v114 = " [%s] %s:%d CGPathCreateMutable was NULL";
LABEL_122:
        _os_log_impl(&dword_1D8A54000, v113, OS_LOG_TYPE_DEFAULT, v114, (uint8_t *)&valuePtr, 0x1Cu);
      }
    }
LABEL_123:
    v101 = 0;
    if (!SRGB)
      goto LABEL_86;
    goto LABEL_85;
  }
  CGPathAddRect(Mutable, 0, *((CGRect *)v3 + 8));
  v155.location = 0;
  v155.length = 0;
  Frame = CTFramesetterCreateFrame(v96, v155, v99, 0);
  if (!Frame)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v115 = VRTraceErrorLogLevelToCSTR();
      v113 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(valuePtr.a) = 136315650;
        *(_QWORD *)((char *)&valuePtr.a + 4) = v115;
        WORD2(valuePtr.b) = 2080;
        *(_QWORD *)((char *)&valuePtr.b + 6) = "_VCPixelBufferOverlay_renderText";
        HIWORD(valuePtr.c) = 1024;
        LODWORD(valuePtr.d) = 253;
        v114 = " [%s] %s:%d CTFramesetterCreateFrame was NULL";
        goto LABEL_122;
      }
    }
    goto LABEL_123;
  }
  v101 = Frame;
  CTFrameDraw(Frame, v90);
  if (SRGB)
LABEL_85:
    CFRelease(SRGB);
LABEL_86:
  CGColorSpaceRelease(v88);
  CGContextRelease(v90);
  if (v94)
    CFRelease(v94);
  if (v96)
    CFRelease(v96);
  if (v99)
    CFRelease(v99);
  if (v101)
    CFRelease(v101);
  return (char *)CVPixelBufferUnlockBaseAddress(a2, 0);
}

BOOL VCPixelBufferOverlay_updateSourceForType(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  _BOOL8 v3;
  _QWORD v5[7];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  char v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  v6 = 0;
  v7 = &v6;
  v8 = 0x2020000000;
  v9 = 1;
  v2 = *(NSObject **)(a1 + 168);
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = __VCPixelBufferOverlay_updateSourceForType_block_invoke;
  v5[3] = &unk_1E9E55810;
  v5[5] = &v6;
  v5[6] = a2;
  v5[4] = a1;
  dispatch_sync(v2, v5);
  v3 = *((_BYTE *)v7 + 24) != 0;
  _Block_object_dispose(&v6, 8);
  return v3;
}

char *VCFFTMeter_Create()
{
  char *v0;
  vDSP_DFT_Setup Setup;
  float *v2;
  uint64_t v3;
  uint64x2_t v4;
  int64x2_t v5;
  int64x2_t v6;

  v0 = (char *)malloc_type_calloc(1uLL, 0x111E0uLL, 0x10E004047CE1534uLL);
  if (v0)
  {
    if (VCAllocatorFirstCome_Create((const __CFAllocator *)*MEMORY[0x1E0C9AE00], (uint64_t)"FFTMeterLERPFilterAllocator", (CFAllocatorRef *)v0 + 8763))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCFFTMeter_Create_cold_3();
      }
    }
    else
    {
      vDSP_hann_window((float *)v0 + 9608, 0xF00uLL, 0);
      *((_QWORD *)v0 + 1) = v0 + 23072;
      *((_QWORD *)v0 + 2) = v0 + 30752;
      Setup = vDSP_DFT_zrop_CreateSetup(0, 0xF00uLL, vDSP_DFT_FORWARD);
      *(_QWORD *)v0 = Setup;
      if (Setup)
      {
        v2 = (float *)(v0 + 69828);
        *((_DWORD *)v0 + 17523) = 730643660;
        memset_pattern4(v0 + 69152, v0 + 70092, 0xD8uLL);
        v3 = 0;
        *((_DWORD *)v0 + 17522) = 965249161;
        v4 = (uint64x2_t)vdupq_n_s64(0x42uLL);
        v5 = (int64x2_t)xmmword_1D910ADF0;
        v6 = vdupq_n_s64(2uLL);
        do
        {
          if ((vmovn_s64((int64x2_t)vcgtq_u64(v4, (uint64x2_t)v5)).u8[0] & 1) != 0)
            *(v2 - 1) = (float)((float)(int)v3 * 53.0) / 65.0;
          if ((vmovn_s64((int64x2_t)vcgtq_u64((uint64x2_t)vdupq_n_s64(0x42uLL), *(uint64x2_t *)&v5)).i32[1] & 1) != 0)
            *v2 = (float)((float)(v3 + 1) * 53.0) / 65.0;
          v3 += 2;
          v5 = vaddq_s64(v5, v6);
          v2 += 2;
        }
        while (v3 != 66);
        *((_QWORD *)v0 + 8762) = 264;
        return v0;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCFFTMeter_Create_cold_2();
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCFFTMeter_Create_cold_1();
  }
  if (*(_QWORD *)v0)
    vDSP_DFT_DestroySetup(*(vDSP_DFT_Setup *)v0);
  free(v0);
  return 0;
}

void VCFFTMeter_Destroy(uint64_t *a1)
{
  uint64_t v1;
  const void *v2;

  if (a1)
  {
    v1 = *a1;
    *a1 = 0;
    if (v1)
    {
      if (*(_QWORD *)v1)
        vDSP_DFT_DestroySetup(*(vDSP_DFT_Setup *)v1);
      v2 = *(const void **)(v1 + 70104);
      if (v2)
        CFRelease(v2);
      free((void *)v1);
    }
  }
}

__CFData *VCFFTMeter_Compute(uint64_t a1, uint64_t a2)
{
  __CFData *Mutable;
  uint64_t v5;
  _DWORD *v6;
  float AveragePower;
  const void *BufferAtIndex;
  void *v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float v14;
  float *v15;
  uint64_t v16;
  float v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  float *MutableBytePtr;
  float v26;
  float __C;
  float __B;
  unsigned int v29;
  uint64_t v30;

  Mutable = 0;
  v30 = *MEMORY[0x1E0C80C00];
  if (a1 && a2)
  {
    v5 = a1 + 70096;
    v6 = (_DWORD *)(a1 + 69812);
    v29 = -1431655766;
    AveragePower = VCAudioBufferList_GetAveragePower(a2);
    BufferAtIndex = (const void *)VCAudioBufferList_GetBufferAtIndex(a2, 0, &v29);
    memmove((void *)(a1 + 32), (const void *)(a1 + 32 + 4 * v29), 4 * (3840 - v29));
    v9 = (void *)(a1 + 32 + 4 * (3840 - v29));
    if (AveragePower <= -70.0)
      bzero(v9, 4 * v29);
    else
      memcpy(v9, BufferAtIndex, 4 * v29);
    vDSP_vmul((const float *)(a1 + 32), 1, (const float *)(a1 + 38432), 1, (float *)(a1 + 53792), 1, 0xF00uLL);
    vDSP_ctoz((const DSPComplex *)(a1 + 53792), 2, (const DSPSplitComplex *)(a1 + 8), 1, 0x780uLL);
    vDSP_DFT_Execute(*(const vDSP_DFT_SetupStruct **)a1, *(const float **)(a1 + 8), *(const float **)(a1 + 16), *(float **)(a1 + 8), *(float **)(a1 + 16));
    vDSP_vsmul(*(const float **)(a1 + 8), 1, (const float *)(a1 + 70088), *(float **)(a1 + 8), 1, 0x780uLL);
    vDSP_vsmul(*(const float **)(a1 + 16), 1, (const float *)(a1 + 70088), *(float **)(a1 + 16), 1, 0x780uLL);
    vDSP_zvmags((const DSPSplitComplex *)(a1 + 8), 1, (float *)(a1 + 15392), 1, 0x780uLL);
    v10 = 0;
    v11 = 0;
    *(_DWORD *)(a1 + 15392) = 0;
    do
    {
      v12 = v11 + 1;
      v13 = _octave2IndexTable6[v11 + 1];
      v14 = 1.0e-12;
      if (v13 > v10)
      {
        v15 = (float *)(a1 + 15392 + 4 * v10);
        v14 = 1.0e-12;
        v16 = v13 - v10;
        do
        {
          v17 = *v15++;
          v14 = v14 + v17;
          --v16;
        }
        while (v16);
      }
      *(float *)(a1 + 4 * v11 + 69376) = v14 / (float)(v13 - v10);
      v10 = v13;
      ++v11;
    }
    while (v12 != 54);
    __B = 1.0;
    vDSP_vdbcon((const float *)(a1 + 69376), 1, &__B, (float *)(a1 + 69376), 1, 0x36uLL, 0);
    __C = 0.13673;
    v26 = 0.72654;
    vDSP_vasm((const float *)(a1 + 69376), 1, (const float *)(a1 + 69152), 1, &__C, (float *)(a1 + 69152), 1, 0x36uLL);
    vDSP_vsma((const float *)(a1 + 69600), 1, &v26, (const float *)(a1 + 69152), 1, (float *)(a1 + 69600), 1, 0x36uLL);
    v18 = *(_OWORD *)(a1 + 69552);
    *(_OWORD *)(a1 + 69312) = *(_OWORD *)(a1 + 69536);
    *(_OWORD *)(a1 + 69328) = v18;
    *(_OWORD *)(a1 + 69344) = *(_OWORD *)(a1 + 69568);
    *(_QWORD *)(a1 + 69360) = *(_QWORD *)(a1 + 69584);
    v19 = *(_OWORD *)(a1 + 69488);
    *(_OWORD *)(a1 + 69248) = *(_OWORD *)(a1 + 69472);
    *(_OWORD *)(a1 + 69264) = v19;
    v20 = *(_OWORD *)(a1 + 69520);
    *(_OWORD *)(a1 + 69280) = *(_OWORD *)(a1 + 69504);
    *(_OWORD *)(a1 + 69296) = v20;
    v21 = *(_OWORD *)(a1 + 69424);
    *(_OWORD *)(a1 + 69184) = *(_OWORD *)(a1 + 69408);
    *(_OWORD *)(a1 + 69200) = v21;
    v22 = *(_OWORD *)(a1 + 69456);
    *(_OWORD *)(a1 + 69216) = *(_OWORD *)(a1 + 69440);
    *(_OWORD *)(a1 + 69232) = v22;
    v23 = *(_OWORD *)(a1 + 69392);
    *(_OWORD *)(a1 + 69152) = *(_OWORD *)(a1 + 69376);
    *(_OWORD *)(a1 + 69168) = v23;
    v6[1] = *v6;
    Mutable = CFDataCreateMutable(*(CFAllocatorRef *)(v5 + 8), *(_QWORD *)v5);
    CFDataSetLength(Mutable, *(_QWORD *)v5);
    MutableBytePtr = (float *)CFDataGetMutableBytePtr(Mutable);
    vDSP_vlint((const float *)(a1 + 69600), (const float *)(a1 + 69824), 1, MutableBytePtr, 1, 0x42uLL, 0x36uLL);
  }
  return Mutable;
}

__CFString *VCSessionMediaType_Name(uint64_t a1)
{
  if (a1 >= 6)
    return (__CFString *)objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("Unknown (%d)"), a1);
  else
    return off_1E9E56F60[(int)a1];
}

uint64_t VCSessionMediaType_FromAVCSessionMediaType(uint64_t result)
{
  if (result >= 9)
    return 0xFFFFFFFFLL;
  else
    return result;
}

__CFString *_VCMediaStreamTransport_CipherSuiteAsString(uint64_t a1)
{
  if ((a1 + 1) >= 0xB)
    return (__CFString *)objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("Unknown cipher=%d"), a1);
  else
    return off_1E9E56F90[(int)a1 + 1];
}

double VCMediaStreamTransport_DecryptionTimeoutInterval(uint64_t a1)
{
  if (a1)
    return VCMediaStreamConfig_DecryptionTimeOutInterval(*(_QWORD *)(a1 + 8));
  else
    return 0.0;
}

uint64_t VCMediaStreamTransport_SetDecryptionTimeoutInterval(uint64_t result, double a2)
{
  if (result)
    return VCAudioBufferList_SetHostTimeJumpSize(*(_QWORD *)(result + 8), a2);
  return result;
}

double VCMediaStreamTransport_DecryptionMKMRecoveryInterval(uint64_t a1)
{
  if (a1)
    return VCMediaStreamConfig_DecryptionMKMRecoveryInterval(*(_QWORD *)(a1 + 8));
  else
    return 0.0;
}

uint64_t VCPacketFilterRTPCreate(uint64_t a1, _QWORD *a2)
{
  uint64_t ClassID;

  ClassID = VCPacketFilterGetClassID();
  return VCFBOUtils_ObjectCreate(a1, a2, (uint64_t)&kVCPacketFilterRTPVTable, ClassID, 52);
}

BOOL VCPacketFilterIsOfKindRTP(uint64_t a1)
{
  return VCFBOUtils_IsKindOfClass(a1, (uint64_t)&kVCPacketFilterRTPVTable);
}

void _VCPacketFilterRTPFinalize(uint64_t a1)
{
  const void **DerivedStorage;
  const void **v2;
  const void *v3;
  const void *v4;

  if (a1)
  {
    DerivedStorage = (const void **)CMBaseObjectGetDerivedStorage();
    if (DerivedStorage)
    {
      v2 = DerivedStorage;
      v3 = *DerivedStorage;
      if (v3)
        CFRelease(v3);
      v4 = v2[1];
      if (v4)
        CFRelease(v4);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCPacketFilterRTPFinalize_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCPacketFilterRTPFinalize_cold_1();
  }
}

uint64_t _VCPacketFilterRTPCopyProperty(uint64_t a1, const void *a2, uint64_t a3, _QWORD *a4)
{
  uint64_t DerivedStorage;
  const void *v7;
  uint64_t v8;
  NSObject *v9;
  CFTypeRef v10;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  int v15;
  uint64_t v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  const void *v22;
  __int16 v23;
  _QWORD *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCPacketFilterRTPCopyProperty_cold_1();
    }
    return 4294954516;
  }
  if (!a2 || !a4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v13 = VRTraceErrorLogLevelToCSTR();
      v14 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v15 = 136316162;
        v16 = v13;
        v17 = 2080;
        v18 = "_VCPacketFilterRTPCopyProperty";
        v19 = 1024;
        v20 = 61;
        v21 = 2112;
        v22 = a2;
        v23 = 2112;
        v24 = a4;
        _os_log_error_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_ERROR, " [%s] %s:%d Property name '%@' and property value out '%@' must not be NULL", (uint8_t *)&v15, 0x30u);
      }
    }
    return 4294954516;
  }
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (CFEqual(a2, CFSTR("RTPRemoteSSRC")))
  {
    v7 = *(const void **)DerivedStorage;
    if (!*(_QWORD *)DerivedStorage)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 6)
        return 4294954513;
      v8 = VRTraceErrorLogLevelToCSTR();
      v9 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        return 4294954513;
      v15 = 136315906;
      v16 = v8;
      v17 = 2080;
      v18 = "_VCPacketFilterRTPCopyProperty";
      v19 = 1024;
      v20 = 70;
      v21 = 2112;
      v22 = a2;
LABEL_19:
      _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Parameter '%@' is currently not set for packet filter", (uint8_t *)&v15, 0x26u);
      return 4294954513;
    }
    goto LABEL_11;
  }
  if (CFEqual(a2, CFSTR("RTPPayloadList")))
  {
    v7 = *(const void **)(DerivedStorage + 8);
    if (!v7)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 6)
        return 4294954513;
      v12 = VRTraceErrorLogLevelToCSTR();
      v9 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        return 4294954513;
      v15 = 136315906;
      v16 = v12;
      v17 = 2080;
      v18 = "_VCPacketFilterRTPCopyProperty";
      v19 = 1024;
      v20 = 78;
      v21 = 2112;
      v22 = a2;
      goto LABEL_19;
    }
LABEL_11:
    v10 = CFRetain(v7);
    result = 0;
    *a4 = v10;
    return result;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCPacketFilterRTPCopyProperty_cold_2();
  }
  return 4294954512;
}

uint64_t _VCPacketFilterRTPSetProperty(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t DerivedStorage;
  CFArrayRef v6;
  CFArrayRef Copy;
  const void *v9;
  uint64_t v10;
  NSObject *v11;
  int v12;
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  const void *v19;
  __int16 v20;
  const void *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCPacketFilterRTPSetProperty_cold_1();
    }
    return 4294954516;
  }
  if (!a2 || !a3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v10 = VRTraceErrorLogLevelToCSTR();
      v11 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v12 = 136316162;
        v13 = v10;
        v14 = 2080;
        v15 = "_VCPacketFilterRTPSetProperty";
        v16 = 1024;
        v17 = 93;
        v18 = 2112;
        v19 = a2;
        v20 = 2112;
        v21 = a3;
        _os_log_error_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_ERROR, " [%s] %s:%d Property name '%@' and property value out '%@' must not be NULL", (uint8_t *)&v12, 0x30u);
      }
    }
    return 4294954516;
  }
  DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (CFEqual(a2, CFSTR("RTPRemoteSSRC")))
  {
    v6 = *(CFArrayRef *)DerivedStorage;
    *(_QWORD *)DerivedStorage = a3;
    CFRetain(a3);
    if (!v6)
      return 0;
LABEL_6:
    CFRelease(v6);
    return 0;
  }
  if (CFEqual(a2, CFSTR("RTPPayloadList")))
  {
    Copy = CFArrayCreateCopy(0, (CFArrayRef)a3);
    v6 = Copy;
    v9 = *(const void **)(DerivedStorage + 8);
    *(_QWORD *)(DerivedStorage + 8) = Copy;
    if (Copy)
      CFRetain(Copy);
    if (v9)
      CFRelease(v9);
    if (!v6)
      return 0;
    goto LABEL_6;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCPacketFilterRTPSetProperty_cold_2();
  }
  return 4294954512;
}

void _VCXPCConnection_timeoutHandlerFunc(uint64_t a1)
{
  uint64_t v2;
  const void *v3;

  if ((int)VRTraceGetErrorLogLevelForModule() >= 3
    && (VRTraceErrorLogLevelToCSTR(), os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR)))
  {
    _VCXPCConnection_timeoutHandlerFunc_cold_1();
    if (!a1)
      return;
  }
  else if (!a1)
  {
    return;
  }
  v2 = FigCFWeakReferenceHolderCopyReferencedObject();
  if (v2)
  {
    v3 = (const void *)v2;
    +[VCXPCConnection selfTerminateDueToTimeout:](VCXPCConnection, "selfTerminateDueToTimeout:", v2);
    CFRelease(v3);
  }
}

void sub_1D8E36E38(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void sub_1D8E36F90(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1D8E371C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void OUTLINED_FUNCTION_3_7(uint64_t a1@<X8>)
{
  uint64_t v1;

  *(_QWORD *)(v1 - 8) = a1;
}

void OUTLINED_FUNCTION_10_15(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x3Au);
}

uint64_t VCVideoStreamConfig_StreamType(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 416);
  return result;
}

unint64_t Crossfade_Initialize(uint64_t a1, int a2, int a3, char a4)
{
  int v7;
  float *v8;
  float *v9;
  float *v10;
  char *v11;
  char *v12;
  char *v13;
  unint64_t result;
  void *v15;
  unint64_t v16;
  BOOL v17;
  unint64_t v18;
  uint64_t v19;
  long double v20;
  float v21;

  v7 = a3 * a2;
  Crossfade_Finalize(a1);
  v8 = (float *)malloc_type_malloc(4 * a2, 0x100004052888210uLL);
  v9 = v8;
  if (v8)
    v10 = &v8[a2];
  else
    v10 = 0;
  v11 = (char *)malloc_type_malloc(4 * a2, 0x100004052888210uLL);
  v12 = v11;
  if (v11)
    v13 = &v11[4 * a2];
  else
    v13 = 0;
  result = (unint64_t)malloc_type_malloc(v7, 0x7ED62481uLL);
  v15 = (void *)result;
  v16 = result + v7;
  if (!result)
    v16 = 0;
  if (v9 && v12 && result)
  {
    if (v9 > v10
      || a2 < 0
      || v10 - v9 < a2
      || v12 > v13
      || a2 > (v13 - v12) >> 2
      || (*(_QWORD *)(a1 + 8) = v9,
          *(_QWORD *)(a1 + 16) = v12,
          *(_DWORD *)(a1 + 32) = a2,
          v17 = v16 >= result,
          v18 = v16 - result,
          !v17)
      || v18 < v7)
    {
      __break(0x5519u);
    }
    else
    {
      *(_QWORD *)a1 = result;
      *(_QWORD *)(a1 + 24) = v7;
      if (a2)
      {
        v19 = 0;
        do
        {
          v20 = cos((double)(int)v19 * 3.14159265 / (double)a2);
          v21 = sqrt(v20 * -0.5 + 0.5);
          v9[v19] = v21;
          *(float *)&v20 = sqrt(v20 * 0.5 + 0.5);
          *(_DWORD *)&v12[4 * v19++] = LODWORD(v20);
        }
        while (a2 != v19);
      }
      result = 0;
      *(_BYTE *)(a1 + 36) = a4;
    }
  }
  else
  {
    free(v9);
    free(v12);
    free(v15);
    return 2147549187;
  }
  return result;
}

double Crossfade_Finalize(uint64_t a1)
{
  double result;

  free(*(void **)(a1 + 8));
  free(*(void **)(a1 + 16));
  free(*(void **)a1);
  *(_DWORD *)(a1 + 32) = 0;
  result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

uint64_t Crossfade_Apply(uint64_t result, const float *__C, unint64_t a3, float *__E, unint64_t a5)
{
  unint64_t v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float *v11;
  const float *v12;
  int v13;

  if (!result || !__C || !__E)
    return 0;
  v5 = *(_QWORD *)(result + 24);
  if (v5 > a3 || v5 > a5)
    return 0;
  if (*(_BYTE *)(result + 36))
  {
    v7 = 1;
    vDSP_vmma(__E, 1, *(const float **)(result + 8), 1, __C, 1, *(const float **)(result + 16), 1, __E, 1, *(int *)(result + 32));
    return v7;
  }
  v8 = *(unsigned int *)(result + 32);
  if ((int)v8 < 1)
    return 1;
  v9 = 0;
  v10 = 4 * v8;
  v11 = __E;
  v12 = __C;
  while (v11 < (float *)((char *)__E + a5) && v11 >= __E && v12 < (const float *)((char *)__C + a3) && v12 >= __C)
  {
    v13 = *(__int16 *)v12;
    v12 = (const float *)((char *)v12 + 2);
    *(_WORD *)v11 = (int)(float)((float)(*(float *)(*(_QWORD *)(result + 16) + v9) * (float)v13)
                               + (float)((float)*(__int16 *)v11 * *(float *)(*(_QWORD *)(result + 8) + v9)));
    v11 = (float *)((char *)v11 + 2);
    v9 += 4;
    v7 = 1;
    if (v10 == v9)
      return v7;
  }
  __break(0x5519u);
  return result;
}

uint64_t VCSpatialAudioMetadata_Create(const __CFAllocator *a1, uint64_t a2, uint64_t a3, const void *a4, uint64_t *a5)
{
  uint64_t v8;
  uint64_t Instance;
  uint64_t v11;
  void *v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;

  if (a5)
  {
    *a5 = 0;
    if ((_DWORD)a2)
    {
      v8 = a3;
      if (a3)
        goto LABEL_7;
      if (GetSpatialMetadataSPI_sSpatialMetadataSPIOnce != -1)
        dispatch_once(&GetSpatialMetadataSPI_sSpatialMetadataSPIOnce, &__block_literal_global_69);
      v8 = GetSpatialMetadataSPI_sSpatialMetadataSPI;
      if (GetSpatialMetadataSPI_sSpatialMetadataSPI)
      {
LABEL_7:
        if (VCSpatialAudioMetadata_GetTypeID_initOnce != -1)
          dispatch_once_f(&VCSpatialAudioMetadata_GetTypeID_initOnce, &VCSpatialAudioMetadata_GetTypeID_typeID, (dispatch_function_t)_VCSpatialAudioMetadataClassRegister);
        Instance = _CFRuntimeCreateInstance();
        if (Instance)
        {
          v11 = Instance;
          v12 = malloc_type_calloc(a2, 0x10uLL, 0x102004075F474C6uLL);
          *(_QWORD *)(v11 + 104) = v12;
          if (!v12)
          {
            v16 = 2151415810;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                VCSpatialAudioMetadata_Create_cold_5();
            }
            goto LABEL_58;
          }
          *(_QWORD *)(v11 + 80) = v8;
          v13 = (_QWORD *)(v11 + 88);
          if ((*(unsigned int (**)(uint64_t, uint64_t))(v8 + 8))(v11 + 88, a2))
          {
            v16 = 2151415810;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                VCSpatialAudioMetadata_Create_cold_11();
            }
            goto LABEL_58;
          }
          if (!*v13)
          {
            v16 = 2151415810;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                VCSpatialAudioMetadata_Create_cold_6();
            }
            goto LABEL_58;
          }
          if ((*(unsigned int (**)(_QWORD, uint64_t))(*(_QWORD *)(v11 + 80) + 40))(*v13, v11 + 168))
          {
            v16 = 2151415812;
            if ((int)VRTraceGetErrorLogLevelForModule() < 3)
              goto LABEL_58;
            VRTraceErrorLogLevelToCSTR();
            if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              goto LABEL_58;
            VCSpatialAudioMetadata_Create_cold_10();
          }
          else
          {
            if (*(_DWORD *)(v11 + 168))
            {
              if (VCAllocatorFirstCome_Create(a1, (uint64_t)"VCSpatialAudioMetadataAllocator", (CFAllocatorRef *)(v11 + 184)))
              {
                v16 = 2151415810;
                if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                {
                  VRTraceErrorLogLevelToCSTR();
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                    VCSpatialAudioMetadata_Create_cold_9();
                }
              }
              else
              {
                if (!VCAllocatorFirstCome_Create(a1, (uint64_t)"VCSpatialAudioMetadataAllocator", (CFAllocatorRef *)(v11 + 176)))
                {
                  pthread_mutex_init((pthread_mutex_t *)(v11 + 16), 0);
                  if (a4)
                    *(_QWORD *)(v11 + 192) = _Block_copy(a4);
                  *(_DWORD *)(v11 + 100) = a2;
                  v14 = *(_QWORD *)(v11 + 104);
                  if ((_DWORD)a2 != 1)
                  {
                    v15 = v14 + 16;
                    do
                    {
                      *(_DWORD *)(v15 + 12) = *(_DWORD *)(v15 - 4) + 1;
                      *(_QWORD *)(v15 - 16) = v15;
                      v15 += 16;
                    }
                    while (v15 <= v14 + 16 * (unint64_t)(a2 - 1));
                  }
                  v16 = 0;
                  *(_QWORD *)(v11 + 112) = v14;
                  *a5 = v11;
                  return v16;
                }
                v16 = 2151415810;
                if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                {
                  VRTraceErrorLogLevelToCSTR();
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                    VCSpatialAudioMetadata_Create_cold_8();
                }
              }
LABEL_58:
              CFRelease((CFTypeRef)v11);
              return v16;
            }
            v16 = 2151415812;
            if ((int)VRTraceGetErrorLogLevelForModule() < 3)
              goto LABEL_58;
            VRTraceErrorLogLevelToCSTR();
            if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              goto LABEL_58;
            VCSpatialAudioMetadata_Create_cold_7();
          }
          v16 = 2151415812;
          goto LABEL_58;
        }
        v16 = 2151415810;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCSpatialAudioMetadata_Create_cold_4();
        }
      }
      else
      {
        v16 = 2151415809;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCSpatialAudioMetadata_Create_cold_3();
        }
      }
    }
    else
    {
      v16 = 2151415809;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCSpatialAudioMetadata_Create_cold_2();
      }
    }
  }
  else
  {
    v16 = 2151415809;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCSpatialAudioMetadata_Create_cold_1();
    }
  }
  return v16;
}

BOOL VCSpatialAudioMetadata_HasChanged(_BOOL8 result)
{
  if (result)
    return *(_BYTE *)(result + 96) != 0;
  return result;
}

uint64_t VCSpatialAudioMetadata_CreateEntry(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  pthread_mutex_t *v7;
  _QWORD *Instance;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (a4)
  {
    *a4 = 0;
    if (a2)
    {
      v7 = (pthread_mutex_t *)(a2 + 16);
      pthread_mutex_lock((pthread_mutex_t *)(a2 + 16));
      if (*(_QWORD *)(a2 + 112))
      {
        if (VCSpatialAudioMetadataEntry_GetTypeID_initOnce != -1)
          dispatch_once_f(&VCSpatialAudioMetadataEntry_GetTypeID_initOnce, &VCSpatialAudioMetadataEntry_GetTypeID_typeID, (dispatch_function_t)_VCSpatialAudioMetadataEntryClassRegister);
        Instance = (_QWORD *)_CFRuntimeCreateInstance();
        if (Instance)
        {
          v9 = (uint64_t)Instance;
          v10 = *(_QWORD *)(a2 + 112);
          *(_QWORD *)(a2 + 112) = *(_QWORD *)v10;
          *(_QWORD *)v10 = 0;
          *(_BYTE *)(v10 + 8) = 1;
          Instance[6] = v10;
          Instance[7] = a3;
          Instance[2] = CFRetain((CFTypeRef)a2);
          _VCSpatialAudioMetadata_SetEntryPropertyUInt32(v9, 10, 1);
          v11 = 0;
          *a4 = v9;
LABEL_8:
          pthread_mutex_unlock(v7);
          return v11;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          v11 = 2151415827;
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCSpatialAudioMetadata_CreateEntry_cold_4();
          goto LABEL_8;
        }
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        v11 = 2151415827;
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCSpatialAudioMetadata_CreateEntry_cold_3();
        goto LABEL_8;
      }
      v11 = 2151415827;
      goto LABEL_8;
    }
    v11 = 2151415809;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCSpatialAudioMetadata_CreateEntry_cold_2();
    }
  }
  else
  {
    v11 = 2151415809;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCSpatialAudioMetadata_CreateEntry_cold_1();
    }
  }
  return v11;
}

void _VCSpatialAudioMetadata_SetEntryPropertyUInt32(uint64_t a1, uint64_t a2, int a3)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  int v7;
  char *v8;
  int v9;
  uint8_t buf[4];
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v3 = a2;
  v22 = *MEMORY[0x1E0C80C00];
  v9 = a3;
  v4 = *(_QWORD *)(a1 + 16);
  if ((*(unsigned int (**)(_QWORD, uint64_t, _QWORD, int *, uint64_t))(*(_QWORD *)(v4 + 80) + 32))(*(_QWORD *)(v4 + 88), a2, *(unsigned int *)(*(_QWORD *)(a1 + 48) + 12), &v9, 4))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v6 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v7 = v9;
        v8 = FourccToCStr(v3);
        *(_DWORD *)buf = 136316418;
        v11 = v5;
        v12 = 2080;
        v13 = "_VCSpatialAudioMetadata_SetEntryPropertyUInt32";
        v14 = 1024;
        v15 = 167;
        v16 = 1024;
        v17 = v3;
        v18 = 1024;
        v19 = v7;
        v20 = 2080;
        v21 = v8;
        _os_log_error_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_ERROR, " [%s] %s:%d Failed to set property %d to %u. error=%s", buf, 0x32u);
      }
    }
  }
  else
  {
    *(_BYTE *)(v4 + 96) = 1;
  }
}

uint64_t VCSpatialAudioMetadata_ChannelIndex(uint64_t a1, _DWORD *a2)
{
  uint64_t v3;
  uint64_t v5;

  if (a1)
  {
    v3 = *(_QWORD *)(a1 + 16);
    if (v3)
    {
      pthread_mutex_lock((pthread_mutex_t *)(v3 + 16));
      if (a2)
      {
        v5 = 0;
        *a2 = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 12);
      }
      else
      {
        v5 = 2151415809;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCSpatialAudioMetadata_ChannelIndex_cold_3();
        }
      }
      pthread_mutex_unlock((pthread_mutex_t *)(*(_QWORD *)(a1 + 16) + 16));
    }
    else
    {
      v5 = 2151415812;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          VCSpatialAudioMetadata_ChannelIndex_cold_2();
          return 2151415812;
        }
      }
    }
  }
  else
  {
    v5 = 2151415809;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCSpatialAudioMetadata_ChannelIndex_cold_1();
    }
  }
  return v5;
}

uint64_t VCSpatialAudioMetadata_SpatialAudioSourceID(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  uint64_t v5;

  if (a2)
  {
    if (a1)
    {
      v3 = *(_QWORD *)(a1 + 16);
      if (v3)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v3 + 16));
        *a2 = *(_QWORD *)(a1 + 56);
        pthread_mutex_unlock((pthread_mutex_t *)(*(_QWORD *)(a1 + 16) + 16));
        return 0;
      }
      else
      {
        v5 = 2151415809;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCSpatialAudioMetadata_SpatialAudioSourceID_cold_3();
        }
      }
    }
    else
    {
      v5 = 2151415809;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCSpatialAudioMetadata_SpatialAudioSourceID_cold_2();
      }
    }
  }
  else
  {
    v5 = 2151415809;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCSpatialAudioMetadata_SpatialAudioSourceID_cold_1();
    }
  }
  return v5;
}

uint64_t VCSpatialAudioMetadata_UpdateGlobalInfo(uint64_t a1, __int128 *a2)
{
  pthread_mutex_t *v4;
  float v5;
  int *v6;
  int *v7;
  int v8;
  float v9;
  uint64_t v10;
  float v11;
  float v12;
  float v13;
  float v14;
  int v15;
  int v16;
  __int128 v17;
  __int128 v18;

  if (a1)
  {
    v4 = (pthread_mutex_t *)(a1 + 16);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
    if (!a2)
    {
      v10 = 2151415809;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCSpatialAudioMetadata_UpdateGlobalInfo_cold_2();
      }
      goto LABEL_43;
    }
    v5 = *((float *)a2 + 1);
    if (v5 <= 0.0)
    {
      v10 = 2151415809;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCSpatialAudioMetadata_UpdateGlobalInfo_cold_3();
      }
      goto LABEL_43;
    }
    if (*((float *)a2 + 2) <= 0.0)
    {
      v10 = 2151415809;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCSpatialAudioMetadata_UpdateGlobalInfo_cold_4();
      }
      goto LABEL_43;
    }
    if (*((float *)a2 + 3) <= 0.0)
    {
      v10 = 2151415809;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCSpatialAudioMetadata_UpdateGlobalInfo_cold_5();
      }
      goto LABEL_43;
    }
    if (*((float *)a2 + 4) <= 0.0)
    {
      v10 = 2151415809;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCSpatialAudioMetadata_UpdateGlobalInfo_cold_6();
      }
      goto LABEL_43;
    }
    v6 = (int *)(a2 + 2);
    if (*((_DWORD *)a2 + 8) >= 2u)
    {
      v10 = 2151415809;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCSpatialAudioMetadata_UpdateGlobalInfo_cold_7();
      }
      goto LABEL_43;
    }
    v7 = (int *)a2 + 7;
    if (*((_DWORD *)a2 + 7))
    {
      v10 = 2151415809;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCSpatialAudioMetadata_UpdateGlobalInfo_cold_8();
      }
      goto LABEL_43;
    }
    v8 = *(_DWORD *)a2;
    if ((*(_BYTE *)(a1 + 120) && v8 == *(_DWORD *)(a1 + 124)
       || (_VCSpatialAudioMetadata_SetPropertyUInt32(a1, 0, v8), v5 = *((float *)a2 + 1), *(_BYTE *)(a1 + 120)))
      && v5 == *(float *)(a1 + 128))
    {
      v9 = *((float *)a2 + 2);
    }
    else
    {
      _VCSpatialAudioMetadata_SetPropertyFloat32(a1, 4, v5);
      v9 = *((float *)a2 + 2);
      if (!*(_BYTE *)(a1 + 120))
        goto LABEL_20;
    }
    if (v9 == *(float *)(a1 + 132))
    {
      v11 = *((float *)a2 + 3);
LABEL_23:
      if (v11 == *(float *)(a1 + 136))
      {
        v12 = *((float *)a2 + 4);
        goto LABEL_27;
      }
LABEL_24:
      _VCSpatialAudioMetadata_SetPropertyFloat32(a1, 6, v11);
      v12 = *((float *)a2 + 4);
      if (!*(_BYTE *)(a1 + 120))
      {
LABEL_28:
        _VCSpatialAudioMetadata_SetPropertyFloat32(a1, 7, v12);
        if (!*(_BYTE *)(a1 + 120))
        {
          v13 = *((float *)a2 + 5);
LABEL_32:
          _VCSpatialAudioMetadata_SetPropertyFloat32(a1, 8, v13);
          if (!*(_BYTE *)(a1 + 120))
          {
            v14 = *((float *)a2 + 6);
            goto LABEL_36;
          }
LABEL_33:
          v14 = *((float *)a2 + 6);
          if (v14 == *(float *)(a1 + 148))
          {
            v15 = *v7;
LABEL_37:
            if (v15 == *(_DWORD *)(a1 + 152))
            {
              v16 = *v6;
LABEL_40:
              if (v16 == *(_DWORD *)(a1 + 156))
              {
LABEL_42:
                v10 = 0;
                *(_BYTE *)(a1 + 120) = 1;
                v17 = *a2;
                v18 = a2[1];
                *(_DWORD *)(a1 + 156) = *((_DWORD *)a2 + 8);
                *(_OWORD *)(a1 + 140) = v18;
                *(_OWORD *)(a1 + 124) = v17;
LABEL_43:
                pthread_mutex_unlock(v4);
                return v10;
              }
LABEL_41:
              _VCSpatialAudioMetadata_SetPropertyUInt32(a1, 2, v16);
              goto LABEL_42;
            }
LABEL_39:
            _VCSpatialAudioMetadata_SetPropertyUInt32(a1, 1, v15);
            v16 = *v6;
            if (!*(_BYTE *)(a1 + 120))
              goto LABEL_41;
            goto LABEL_40;
          }
LABEL_36:
          _VCSpatialAudioMetadata_SetPropertyFloat32(a1, 9, v14);
          v15 = *v7;
          if (!*(_BYTE *)(a1 + 120))
            goto LABEL_39;
          goto LABEL_37;
        }
LABEL_29:
        v13 = *((float *)a2 + 5);
        if (v13 == *(float *)(a1 + 144))
          goto LABEL_33;
        goto LABEL_32;
      }
LABEL_27:
      if (v12 == *(float *)(a1 + 140))
        goto LABEL_29;
      goto LABEL_28;
    }
LABEL_20:
    _VCSpatialAudioMetadata_SetPropertyFloat32(a1, 5, v9);
    v11 = *((float *)a2 + 3);
    if (!*(_BYTE *)(a1 + 120))
      goto LABEL_24;
    goto LABEL_23;
  }
  v10 = 2151415809;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCSpatialAudioMetadata_UpdateGlobalInfo_cold_1();
  }
  return v10;
}

void _VCSpatialAudioMetadata_SetPropertyUInt32(uint64_t a1, uint64_t a2, int a3)
{
  int v3;
  uint64_t v5;
  NSObject *v6;
  int v7;
  char *v8;
  int v9;
  uint8_t buf[4];
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v3 = a2;
  v22 = *MEMORY[0x1E0C80C00];
  v9 = a3;
  if ((*(unsigned int (**)(_QWORD, uint64_t, _QWORD, int *, uint64_t))(*(_QWORD *)(a1 + 80) + 32))(*(_QWORD *)(a1 + 88), a2, 0, &v9, 4))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v6 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v7 = v9;
        v8 = FourccToCStr(v3);
        *(_DWORD *)buf = 136316418;
        v11 = v5;
        v12 = 2080;
        v13 = "_VCSpatialAudioMetadata_SetPropertyUInt32";
        v14 = 1024;
        v15 = 148;
        v16 = 1024;
        v17 = v3;
        v18 = 1024;
        v19 = v7;
        v20 = 2080;
        v21 = v8;
        _os_log_error_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_ERROR, " [%s] %s:%d Failed to set property %d to %u. error=%s", buf, 0x32u);
      }
    }
  }
  else
  {
    *(_BYTE *)(a1 + 96) = 1;
  }
}

void _VCSpatialAudioMetadata_SetPropertyFloat32(uint64_t a1, uint64_t a2, float a3)
{
  int v3;
  uint64_t v5;
  NSObject *v6;
  double v7;
  char *v8;
  float v9;
  uint8_t buf[4];
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  __int16 v18;
  double v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v3 = a2;
  v22 = *MEMORY[0x1E0C80C00];
  v9 = a3;
  if ((*(unsigned int (**)(_QWORD, uint64_t, _QWORD, float *, uint64_t))(*(_QWORD *)(a1 + 80) + 32))(*(_QWORD *)(a1 + 88), a2, 0, &v9, 4))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v6 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v7 = v9;
        v8 = FourccToCStr(v3);
        *(_DWORD *)buf = 136316418;
        v11 = v5;
        v12 = 2080;
        v13 = "_VCSpatialAudioMetadata_SetPropertyFloat32";
        v14 = 1024;
        v15 = 157;
        v16 = 1024;
        v17 = v3;
        v18 = 2048;
        v19 = v7;
        v20 = 2080;
        v21 = v8;
        _os_log_error_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_ERROR, " [%s] %s:%d Failed to set property %d to %f. error=%s", buf, 0x36u);
      }
    }
  }
  else
  {
    *(_BYTE *)(a1 + 96) = 1;
  }
}

uint64_t VCSpatialAudioMetadata_UpdateOrientation(uint64_t a1, unsigned int a2)
{
  pthread_mutex_t *v4;
  unsigned int v5;
  uint64_t v6;

  if (a1)
  {
    v4 = (pthread_mutex_t *)(a1 + 16);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
    if (a2 >= 4)
    {
      v6 = 2151415809;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCSpatialAudioMetadata_UpdateOrientation_cold_2();
      }
    }
    else
    {
      v5 = a2 + 1;
      if (!*(_BYTE *)(a1 + 160) || v5 != *(_DWORD *)(a1 + 164))
      {
        _VCSpatialAudioMetadata_SetPropertyUInt32(a1, 3, a2 + 1);
        *(_DWORD *)(a1 + 164) = v5;
      }
      v6 = 0;
      *(_BYTE *)(a1 + 160) = 1;
    }
    pthread_mutex_unlock(v4);
  }
  else
  {
    v6 = 2151415809;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCSpatialAudioMetadata_UpdateOrientation_cold_1();
    }
  }
  return v6;
}

uint64_t VCSpatialAudioMetadata_UpdatePositionalInfo(uint64_t a1, __int128 *a2)
{
  uint64_t v3;
  float v5;
  float v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  __int128 v11;

  if (a1)
  {
    v3 = *(_QWORD *)(a1 + 16);
    if (v3)
    {
      pthread_mutex_lock((pthread_mutex_t *)(v3 + 16));
      if (a2)
      {
        if (*(float *)(a1 + 24) != *(float *)a2)
          _VCSpatialAudioMetadata_SetEntryPropertyFloat32(a1, 13, *(float *)a2);
        v5 = *((float *)a2 + 1);
        if (*(float *)(a1 + 28) != v5)
          _VCSpatialAudioMetadata_SetEntryPropertyFloat32(a1, 14, v5);
        v6 = *((float *)a2 + 2);
        if (*(float *)(a1 + 32) != v6)
          _VCSpatialAudioMetadata_SetEntryPropertyFloat32(a1, 15, v6);
        v7 = *((_DWORD *)a2 + 3);
        if (*(_DWORD *)(a1 + 36) != v7)
          _VCSpatialAudioMetadata_SetEntryPropertyUInt32(a1, 16, v7);
        v8 = *((_DWORD *)a2 + 4);
        if (*(_DWORD *)(a1 + 40) != v8)
          _VCSpatialAudioMetadata_SetEntryPropertyUInt32(a1, 12, v8);
        v9 = *((_DWORD *)a2 + 5);
        if (*(_DWORD *)(a1 + 44) != v9)
          _VCSpatialAudioMetadata_SetEntryPropertyUInt32(a1, 11, v9);
        v10 = 0;
        v11 = *a2;
        *(_QWORD *)(a1 + 40) = *((_QWORD *)a2 + 2);
        *(_OWORD *)(a1 + 24) = v11;
      }
      else
      {
        v10 = 2151415809;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCSpatialAudioMetadata_UpdatePositionalInfo_cold_3();
        }
      }
      pthread_mutex_unlock((pthread_mutex_t *)(*(_QWORD *)(a1 + 16) + 16));
    }
    else
    {
      v10 = 2151415812;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          VCSpatialAudioMetadata_UpdatePositionalInfo_cold_2();
          return 2151415812;
        }
      }
    }
  }
  else
  {
    v10 = 2151415809;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCSpatialAudioMetadata_UpdatePositionalInfo_cold_1();
    }
  }
  return v10;
}

void _VCSpatialAudioMetadata_SetEntryPropertyFloat32(uint64_t a1, uint64_t a2, float a3)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  double v7;
  char *v8;
  float v9;
  uint8_t buf[4];
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  __int16 v18;
  double v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v3 = a2;
  v22 = *MEMORY[0x1E0C80C00];
  v9 = a3;
  v4 = *(_QWORD *)(a1 + 16);
  if ((*(unsigned int (**)(_QWORD, uint64_t, _QWORD, float *, uint64_t))(*(_QWORD *)(v4 + 80) + 32))(*(_QWORD *)(v4 + 88), a2, *(unsigned int *)(*(_QWORD *)(a1 + 48) + 12), &v9, 4))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v6 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v7 = v9;
        v8 = FourccToCStr(v3);
        *(_DWORD *)buf = 136316418;
        v11 = v5;
        v12 = 2080;
        v13 = "_VCSpatialAudioMetadata_SetEntryPropertyFloat32";
        v14 = 1024;
        v15 = 177;
        v16 = 1024;
        v17 = v3;
        v18 = 2048;
        v19 = v7;
        v20 = 2080;
        v21 = v8;
        _os_log_error_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_ERROR, " [%s] %s:%d Failed to set property %d to %f. error=%s", buf, 0x36u);
      }
    }
  }
  else
  {
    *(_BYTE *)(v4 + 96) = 1;
  }
}

uint64_t VCSpatialAudioMetadata_Serialize(uint64_t a1, CMBlockBufferRef *a2)
{
  void *v4;
  uint64_t v5;
  _DWORD dataLength[3];

  *(_QWORD *)&dataLength[1] = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    *a2 = 0;
    if (a1)
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
      v4 = CFAllocatorAllocate(*(CFAllocatorRef *)(a1 + 184), *(unsigned int *)(a1 + 168), 0);
      dataLength[0] = *(_DWORD *)(a1 + 168);
      if ((*(unsigned int (**)(_QWORD, void *, _DWORD *))(*(_QWORD *)(a1 + 80) + 48))(*(_QWORD *)(a1 + 88), v4, dataLength))
      {
        v5 = 2151415812;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            VCSpatialAudioMetadata_Serialize_cold_4();
            v5 = 2151415812;
          }
        }
      }
      else
      {
        if (!CMBlockBufferCreateWithMemoryBlock(*(CFAllocatorRef *)(a1 + 176), v4, *(unsigned int *)(a1 + 168), *(CFAllocatorRef *)(a1 + 184), 0, 0, dataLength[0], 0, a2))
        {
          *(_BYTE *)(a1 + 96) = 0;
          pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
          return 0;
        }
        v5 = 2151415810;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            VCSpatialAudioMetadata_Serialize_cold_3();
            v5 = 2151415810;
          }
        }
      }
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
      if (v4)
        CFAllocatorDeallocate(*(CFAllocatorRef *)(a1 + 184), v4);
    }
    else
    {
      v5 = 2151415809;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCSpatialAudioMetadata_Serialize_cold_2();
      }
    }
  }
  else
  {
    v5 = 2151415809;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCSpatialAudioMetadata_Serialize_cold_1();
    }
  }
  return v5;
}

uint64_t VCSpatialAudioMetadata_SetNeedsRefresh(uint64_t a1)
{
  pthread_mutex_t *v2;
  uint64_t v3;

  if (a1)
  {
    v2 = (pthread_mutex_t *)(a1 + 16);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
    *(_BYTE *)(a1 + 96) = 1;
    pthread_mutex_unlock(v2);
    return 0;
  }
  else
  {
    v3 = 2151415809;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCSpatialAudioMetadata_SetNeedsRefresh_cold_1();
    }
  }
  return v3;
}

uint64_t _VCSpatialAudioMetadataClassRegister(uint64_t *a1)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

uint64_t _VCSpatialAudioMetadataEntryClassRegister(uint64_t *a1)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

double _VCSpatialAudioMetadata_Init(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 192) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

void _VCSpatialAudioMetadata_Finalize(uint64_t a1)
{
  uint64_t v2;
  unsigned __int8 *v3;
  int v4;
  const void *v5;
  const void *v6;
  const void *v7;

  if (a1)
  {
    v2 = *(unsigned int *)(a1 + 100);
    if ((_DWORD)v2)
    {
      v3 = (unsigned __int8 *)(*(_QWORD *)(a1 + 104) + 8);
      while (1)
      {
        v4 = *v3;
        v3 += 16;
        if (v4)
          break;
        if (!--v2)
          goto LABEL_6;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCSpatialAudioMetadata_Finalize_cold_2();
      }
    }
    else
    {
LABEL_6:
      v5 = *(const void **)(a1 + 192);
      if (v5)
      {
        _Block_release(v5);
        *(_QWORD *)(a1 + 192) = 0;
      }
      if (*(_QWORD *)(a1 + 88))
        (*(void (**)(void))(*(_QWORD *)(a1 + 80) + 16))();
      free(*(void **)(a1 + 104));
      v6 = *(const void **)(a1 + 176);
      if (v6)
        CFRelease(v6);
      v7 = *(const void **)(a1 + 184);
      if (v7)
        CFRelease(v7);
      pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16));
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCSpatialAudioMetadata_Finalize_cold_1();
  }
}

double _VCSpatialAudioMetadataEntry_Init(_OWORD *a1)
{
  double result;

  result = 0.0;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[1] = 0u;
  return result;
}

void _VCSpatialAudioMetadataEntry_Finalize(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  if (a1)
  {
    v2 = *(_QWORD *)(a1 + 16);
    if (v2)
    {
      pthread_mutex_lock((pthread_mutex_t *)(v2 + 16));
      v3 = *(_QWORD *)(a1 + 48);
      if (v3)
      {
        _VCSpatialAudioMetadata_SetEntryPropertyUInt32(a1, 10, 0);
        *(_BYTE *)(v3 + 8) = 0;
        *(_QWORD *)v3 = *(_QWORD *)(v2 + 112);
        *(_QWORD *)(v2 + 112) = v3;
        *(_BYTE *)(v2 + 96) = 1;
        v4 = *(_QWORD *)(v2 + 192);
        if (v4)
          (*(void (**)(void))(v4 + 16))();
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCSpatialAudioMetadataEntry_Finalize_cold_3();
      }
      pthread_mutex_unlock((pthread_mutex_t *)(v2 + 16));
      CFRelease((CFTypeRef)v2);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCSpatialAudioMetadataEntry_Finalize_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCSpatialAudioMetadataEntry_Finalize_cold_1();
  }
}

uint64_t VCTimescalePSOLA_CheckforSignalCorrelation(__int16 *a1, __int16 *a2, int a3, int a4)
{
  __int16 v7;
  __int16 v8;
  uint64_t v9;
  NSObject *v10;
  int v11;
  uint64_t v12;
  unint64_t v13;
  __int16 v14;
  __int16 v15;
  uint64_t v16;
  int v17;
  int v18;
  const char *v19;
  uint64_t i;
  __int16 *v21;
  const void *v22;
  void *v23;
  int v24;
  uint64_t v25;
  int v26;
  __int128 v27;
  __int128 v28;
  int v29;
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  unsigned __int8 *v33;
  uint64_t v34;
  NSObject *v35;
  NSObject *v36;
  int v37;
  uint64_t v38;
  NSObject *v39;
  NSObject *v40;
  int v41;
  unsigned __int8 *v42;
  int v43;
  int v44;
  int v45;
  uint64_t v46;
  NSObject *v47;
  const char *v49;
  __int16 *v50;
  int v51;
  int v52;
  __int16 *v53;
  __int16 v54;
  unsigned int v55;
  __int16 v56;
  int v58;
  __int16 v59;
  _OWORD v60[5];
  _OWORD v61[2];
  _BYTE buf[48];
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  _OWORD v72[2];
  _BYTE v73[48];
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  _OWORD v82[2];
  uint64_t v83;

  v83 = *MEMORY[0x1E0C80C00];
  v7 = VCTimescalePSOLA_CalcFsMult((unsigned __int16)a1[1]);
  v58 = a4;
  if (a4 == 1)
    v8 = 240;
  else
    v8 = 160;
  if (a2[33] < ((v7 * v8) & 0xFFF0))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v9 = VRTraceErrorLogLevelToCSTR();
      v10 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v11 = a2[33];
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = v9;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "VCTimescalePSOLA_CheckforSignalCorrelation";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 380;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v11;
        _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Not Enough samples to Timescale input bufferLength=%d", buf, 0x22u);
      }
    }
    return 1;
  }
  if (!*(_BYTE *)a1)
    return 0;
  v13 = 0;
  if (a4)
    v14 = 239;
  else
    v14 = 159;
  v56 = v14;
  if (a4)
    v15 = 110;
  else
    v15 = 70;
  v54 = v15;
  if (a4)
    v16 = 60;
  else
    v16 = 40;
  v53 = (__int16 *)&buf[2 * v16];
  if (a4)
    v17 = 60;
  else
    v17 = 40;
  if (a4)
    v18 = 50;
  else
    v18 = 30;
  v51 = v17 - 10;
  v52 = v18;
  v50 = (__int16 *)&buf[2 * (v17 - 10)];
  v19 = "Compress";
  if (a4 == 1)
    v19 = "Expand";
  v49 = v19;
  for (i = 3; ; ++i)
  {
    v21 = &a2[4 * v13];
    v22 = *(const void **)v21;
    v23 = (void *)*((_QWORD *)v21 + 4);
    v24 = a2[33];
    v25 = a2[33];
    v26 = VCTimescalePSOLA_CalcFsMult((unsigned __int16)a1[1]);
    Float32ToNativeInt16_Portable();
    if (v24 >= (__int16)(v26 * v56))
      break;
    a2[34] = v24;
    memmove(v23, v22, 4 * v25);
    v12 = 1;
LABEL_38:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v38 = VRTraceErrorLogLevelToCSTR();
      v39 = *MEMORY[0x1E0CF2758];
      v40 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
        {
          v41 = a1[v13 + 3];
          *(_DWORD *)buf = 136316162;
          *(_QWORD *)&buf[4] = v38;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "VCTimescalePSOLA_CheckforSignalCorrelation";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 389;
          *(_WORD *)&buf[28] = 2080;
          *(_QWORD *)&buf[30] = v49;
          *(_WORD *)&buf[38] = 1024;
          *(_DWORD *)&buf[40] = v41;
          _os_log_impl(&dword_1D8A54000, v39, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d mode=%s: pitch period=%d", buf, 0x2Cu);
        }
      }
      else if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
      {
        v44 = a1[v13 + 3];
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)&buf[4] = v38;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "VCTimescalePSOLA_CheckforSignalCorrelation";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 389;
        *(_WORD *)&buf[28] = 2080;
        *(_QWORD *)&buf[30] = v49;
        *(_WORD *)&buf[38] = 1024;
        *(_DWORD *)&buf[40] = v44;
        _os_log_debug_impl(&dword_1D8A54000, v39, OS_LOG_TYPE_DEBUG, " [%s] %s:%d mode=%s: pitch period=%d", buf, 0x2Cu);
      }
    }
    v42 = (unsigned __int8 *)&a1[v13];
    v43 = *((__int16 *)v42 + 3);
    if (v43 >= a3)
      v43 = a3;
    *((_WORD *)v42 + 3) = v43;
    _VCTimescalePSOLA_FinalCorrelationCheck((uint64_t)a1, (int16x4_t *)&a1[a3 - (uint64_t)v43 + 50], (int16x4_t *)&a1[a3 + 50], v58, a2[33], a2[32], v13++);
    if (v13 >= *(unsigned __int8 *)a1)
      return v12;
  }
  v59 = -21846;
  *(_QWORD *)&v27 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v27 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)buf = v27;
  *(_OWORD *)&buf[16] = v27;
  *(_OWORD *)&buf[32] = v27;
  v63 = v27;
  v64 = v27;
  v65 = v27;
  v66 = v27;
  v67 = v27;
  v68 = v27;
  v69 = v27;
  v70 = v27;
  v71 = v27;
  v72[0] = v27;
  *(_OWORD *)((char *)v72 + 12) = v27;
  v60[0] = v27;
  v60[1] = v27;
  v60[2] = v27;
  v60[3] = v27;
  v60[4] = v27;
  v61[0] = v27;
  *(_QWORD *)((char *)v61 + 14) = 0xAAAAAAAAAAAAAAAALL;
  v55 = VCTimescalePSOLA_DownSampleTo4kHz((uint64_t)(a1 + 50), v24, (unsigned __int16)a1[1], buf, v54, 1);
  if ((v55 & 0x80000000) == 0)
  {
    *(_QWORD *)&v28 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v28 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)((char *)v82 + 12) = v28;
    v81 = v28;
    v82[0] = v28;
    v79 = v28;
    v80 = v28;
    v77 = v28;
    v78 = v28;
    v75 = v28;
    v76 = v28;
    *(_OWORD *)&v73[32] = v28;
    v74 = v28;
    *(_OWORD *)v73 = v28;
    *(_OWORD *)&v73[16] = v28;
    v29 = VCTimescalePSOLA_MaxAbsValueW16(a1 + 50, v24);
    v30 = VCTimescalePSOLA_Normalize((v29 * v29));
    VCTimescalePSOLA_CrossCorrelation(v73, v53, v50, v52, v51, (6 - v30) & ~((__int16)(6 - v30) >> 31), -1);
    v31 = VCTimescalePSOLA_MaxAbsValueW32((int *)v73, v52);
    v32 = VCTimescalePSOLA_Normalize(v31);
    VCTimescalePSOLA_VectorBitShiftW32ToW16((uint64_t)v60, v52, (int *)v73, (__int16)(17 - v32) & ~((__int16)(17 - v32) >> 31));
    v33 = (unsigned __int8 *)&a1[v13];
    VCTimescalePSOLA_PeakDetection((uint64_t)v60, v52, 1, v26, &a1[i], &v59);
    *((_WORD *)v33 + 3) += 20 * v26;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v34 = VRTraceErrorLogLevelToCSTR();
      v35 = *MEMORY[0x1E0CF2758];
      v36 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
        {
          v37 = *((__int16 *)v33 + 3);
          *(_DWORD *)v73 = 136316162;
          *(_QWORD *)&v73[4] = v34;
          *(_WORD *)&v73[12] = 2080;
          *(_QWORD *)&v73[14] = "_VCTimescalePSOLA_DownSampledCoarseCorrelation";
          *(_WORD *)&v73[22] = 1024;
          *(_DWORD *)&v73[24] = 296;
          *(_WORD *)&v73[28] = 1024;
          *(_DWORD *)&v73[30] = v37;
          *(_WORD *)&v73[34] = 1024;
          *(_DWORD *)&v73[36] = v13;
          _os_log_impl(&dword_1D8A54000, v35, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d PSOLA Adapt : pitch period=%d channel=%d", v73, 0x28u);
        }
      }
      else if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
      {
        v45 = *((__int16 *)v33 + 3);
        *(_DWORD *)v73 = 136316162;
        *(_QWORD *)&v73[4] = v34;
        *(_WORD *)&v73[12] = 2080;
        *(_QWORD *)&v73[14] = "_VCTimescalePSOLA_DownSampledCoarseCorrelation";
        *(_WORD *)&v73[22] = 1024;
        *(_DWORD *)&v73[24] = 296;
        *(_WORD *)&v73[28] = 1024;
        *(_DWORD *)&v73[30] = v45;
        *(_WORD *)&v73[34] = 1024;
        *(_DWORD *)&v73[36] = v13;
        _os_log_debug_impl(&dword_1D8A54000, v35, OS_LOG_TYPE_DEBUG, " [%s] %s:%d PSOLA Adapt : pitch period=%d channel=%d", v73, 0x28u);
      }
    }
    v12 = v55;
    goto LABEL_38;
  }
  a2[34] = v24;
  memmove(v23, v22, 4 * v25);
  if ((int)VRTraceGetErrorLogLevelForModule() < 3)
    return v55;
  v46 = VRTraceErrorLogLevelToCSTR();
  v47 = *MEMORY[0x1E0CF2758];
  v12 = v55;
  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    VCTimescalePSOLA_CheckforSignalCorrelation_cold_1(v46, v47);
  return v12;
}

void _VCTimescalePSOLA_FinalCorrelationCheck(uint64_t a1, int16x4_t *a2, int16x4_t *a3, int a4, int a5, int a6, unsigned int a7)
{
  uint64_t v11;
  _WORD *v12;
  int v13;
  __int16 v14;
  __int16 *v15;
  unsigned int v16;
  __int16 v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int16 v23;
  char v24;
  uint64_t v25;
  int v26;
  char v27;
  char v28;
  char v29;
  int v30;
  __int16 v31;
  int v32;
  __int16 v33;
  int v34;
  __int16 v35;
  int v36;
  int v37;
  int v38;
  uint64_t v39;
  __int16 v40;
  __int16 *v41;
  uint64_t v42;
  NSObject *v43;
  NSObject *v44;
  const char *v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  NSObject *v49;
  NSObject *v50;
  int v51;
  const char *v52;
  const char *v53;
  int v54;
  int v55;
  int v56;
  const char *v57;
  int v60;
  uint8_t buf[4];
  uint64_t v63;
  __int16 v64;
  const char *v65;
  __int16 v66;
  int v67;
  __int16 v68;
  const char *v69;
  __int16 v70;
  int v71;
  __int16 v72;
  int v73;
  uint64_t v74;

  v74 = *MEMORY[0x1E0C80C00];
  v11 = a1 + 2 * a7;
  *(_WORD *)(v11 + 22) = 1;
  v12 = (_WORD *)(v11 + 22);
  v13 = VCTimescalePSOLA_MaxAbsValueW16((__int16 *)(a1 + 100), a5);
  v14 = VCTimescalePSOLA_Normalize((v13 * v13));
  v16 = *(__int16 *)(v11 + 6);
  v15 = (__int16 *)(v11 + 6);
  v17 = VCTimescalePSOLA_Normalize(v16);
  v18 = (__int16)(31 - (v14 + v17)) & ~((__int16)(31 - (v14 + v17)) >> 31);
  v19 = VCTimescalePSOLA_DotProductWithScale(a2, a2, *v15, (31 - (v14 + v17)) & ~((__int16)(31 - (v14 + v17)) >> 31));
  v20 = VCTimescalePSOLA_DotProductWithScale(a3, a3, *v15, v18);
  v60 = VCTimescalePSOLA_DotProductWithScale(a2, a3, *v15, v18);
  if (*(_WORD *)(a1 + 64) == 1)
    v21 = *(unsigned int *)(a1 + 60);
  else
    v21 = 75000;
  v22 = a7;
  v23 = VCTimescalePSOLA_Normalize(v21);
  v24 = (16 - v23) & ~((__int16)(16 - v23) >> 31);
  v25 = (((int)v20 + (int)v19) >> 4 >> v24);
  v26 = (__int16)((int)v21 >> v24) * *v15;
  v27 = 2 * v18;
  if ((int)VCTimescalePSOLA_Normalize(v25) < 2 * v18)
  {
    v28 = VCTimescalePSOLA_Normalize(v25);
    v29 = v27 - v28;
    v27 = v28;
    v26 >>= v29;
  }
  v30 = (_DWORD)v25 << v27;
  if (v30 <= v26)
  {
    v47 = v22;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v48 = VRTraceErrorLogLevelToCSTR();
      v49 = *MEMORY[0x1E0CF2758];
      v50 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
        {
          v51 = *(__int16 *)(a1 + 2 * v47 + 38);
          v52 = "Compress";
          *(_DWORD *)buf = 136316418;
          v63 = v48;
          v64 = 2080;
          v65 = "_VCTimescalePSOLA_VadCheckForScaling";
          if (a4 == 1)
            v52 = "Expand";
          v66 = 1024;
          v67 = 210;
          v68 = 2080;
          v69 = v52;
          v70 = 1024;
          v71 = v51;
          v72 = 1024;
          v73 = v30;
          _os_log_impl(&dword_1D8A54000, v49, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d mode=%s bestCorrelation=%d VAD=0 energy_Q14=%d", buf, 0x32u);
        }
      }
      else if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG))
      {
        v56 = *(__int16 *)(a1 + 2 * v47 + 38);
        v57 = "Compress";
        *(_DWORD *)buf = 136316418;
        v63 = v48;
        v64 = 2080;
        v65 = "_VCTimescalePSOLA_VadCheckForScaling";
        if (a4 == 1)
          v57 = "Expand";
        v66 = 1024;
        v67 = 210;
        v68 = 2080;
        v69 = v57;
        v70 = 1024;
        v71 = v56;
        v72 = 1024;
        v73 = v30;
        _os_log_debug_impl(&dword_1D8A54000, v49, OS_LOG_TYPE_DEBUG, " [%s] %s:%d mode=%s bestCorrelation=%d VAD=0 energy_Q14=%d", buf, 0x32u);
      }
    }
    *v12 = 0;
    *(_WORD *)(a1 + 2 * v47 + 38) = 0;
    if (a4 == 1)
    {
      v55 = *v15;
      if (a5 - a6 <= v55)
        LOWORD(v55) = a5 - a6;
      *v15 = v55;
    }
  }
  else
  {
    *v12 = 1;
    v31 = VCTimescalePSOLA_Normalize(v19);
    v32 = (__int16)(16 - v31) & ~((__int16)(16 - v31) >> 31);
    v33 = VCTimescalePSOLA_Normalize(v20);
    v34 = (__int16)(16 - v33) & ~((__int16)(16 - v33) >> 31);
    if ((((_BYTE)v34 + (_BYTE)v32) & 1) != 0)
      v35 = v32 + 1;
    else
      v35 = v32;
    v36 = (__int16)((int)v19 >> v35) * (__int16)((int)v20 >> v34);
    v37 = VCTimescalePSOLA_ShiftW32(v60, (__int16)(14 - ((v34 + v35) >> 1)));
    v38 = VCTimescalePSOLA_DivW32W16(v37 & ~(v37 >> 31), (int)sqrt((double)v36));
    v39 = a1 + 2 * v22;
    if (v38 << 16 <= 0x40000000)
      v40 = v38;
    else
      v40 = 0x4000;
    *(_WORD *)(v39 + 38) = v40;
    v41 = (__int16 *)(v39 + 38);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v42 = VRTraceErrorLogLevelToCSTR();
      v43 = *MEMORY[0x1E0CF2758];
      v44 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
        {
          v45 = "Compress";
          v46 = *v41;
          *(_DWORD *)buf = 136316418;
          v63 = v42;
          v64 = 2080;
          if (a4 == 1)
            v45 = "Expand";
          v65 = "_VCTimescalePSOLA_VadCheckForScaling";
          v66 = 1024;
          v67 = 232;
          v68 = 2080;
          v69 = v45;
          v70 = 1024;
          v71 = v46;
          v72 = 1024;
          v73 = v36;
          _os_log_impl(&dword_1D8A54000, v43, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d mode=%s: bestCorrelation=%d VAD=1 energy_Q14=%d", buf, 0x32u);
        }
      }
      else if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
      {
        v53 = "Compress";
        v54 = *v41;
        *(_DWORD *)buf = 136316418;
        v63 = v42;
        v64 = 2080;
        if (a4 == 1)
          v53 = "Expand";
        v65 = "_VCTimescalePSOLA_VadCheckForScaling";
        v66 = 1024;
        v67 = 232;
        v68 = 2080;
        v69 = v53;
        v70 = 1024;
        v71 = v54;
        v72 = 1024;
        v73 = v36;
        _os_log_debug_impl(&dword_1D8A54000, v43, OS_LOG_TYPE_DEBUG, " [%s] %s:%d mode=%s: bestCorrelation=%d VAD=1 energy_Q14=%d", buf, 0x32u);
      }
    }
  }
}

void VCTimescalePSOLA_SynchronizeChannelCorrelation(_WORD *a1, uint64_t a2, int a3, __int16 a4)
{
  int v5;
  int v6;
  int v7;
  int v8;
  _BOOL4 v9;
  int v11;
  int v12;
  unint64_t v15;
  __int16 v16;
  uint64_t v17;
  int16x4_t *v18;
  _WORD *v19;
  int v20;
  int v21;
  int v22;
  __int16 v24;

  if (*(unsigned __int8 *)a1 >= 2u)
  {
    v5 = (unsigned __int16)a1[11];
    if (v5 == 1)
    {
      v6 = (unsigned __int16)a1[12];
      v7 = (unsigned __int16)a1[3];
      v8 = (unsigned __int16)a1[4];
      v9 = v7 == v8;
      if (v7 == v8 || v6 != 1)
      {
LABEL_7:
        if (!v9)
          return;
        goto LABEL_12;
      }
      v15 = 0;
      if (a3)
        v16 = 120;
      else
        v16 = 80;
      a1[5] = v8;
      a1[6] = v7;
      v17 = (__int16)(v16 * a4);
      v18 = (int16x4_t *)&a1[v17 + 50];
      do
      {
        Float32ToNativeInt16_Portable();
        v19 = &a1[v15];
        v20 = (__int16)v19[5];
        if (v20 >= (int)v17)
          v20 = v17;
        v19[5] = v20;
        _VCTimescalePSOLA_FinalCorrelationCheck((uint64_t)a1, (int16x4_t *)&a1[v17 - v20 + 50], v18, a3, *(__int16 *)(a2 + 66), *(__int16 *)(a2 + 64), (v15++ + 2));
      }
      while (v15 < *(unsigned __int8 *)a1);
      v21 = (__int16)a1[21];
      v22 = (__int16)a1[22];
      if (v21 >= v22)
      {
        if ((__int16)a1[20] < v21)
          LOWORD(v21) = a1[20];
        a1[3] = a1[6];
      }
      else
      {
        v21 = (__int16)a1[19];
        if (v21 >= v22)
          LOWORD(v21) = a1[22];
      }
      a1[19] = v21;
    }
    else
    {
      v11 = (unsigned __int16)a1[3];
      v12 = (unsigned __int16)a1[4];
      v9 = v11 == v12;
      if (a1[11])
      {
        if (v11 != v12)
          return;
        LOWORD(v6) = a1[12];
LABEL_12:
        a1[19] = a1[20];
        if ((__int16)v5 <= (__int16)v6)
          LOWORD(v5) = v6;
        goto LABEL_14;
      }
      v6 = (unsigned __int16)a1[12];
      if (v11 == v12 || v6 != 0)
      {
        if (v6 == 1)
        {
          a1[3] = v12;
          a1[19] = a1[20];
          LOWORD(v5) = 1;
LABEL_14:
          a1[11] = v5;
          return;
        }
        goto LABEL_7;
      }
      v24 = a1[4];
      if ((__int16)v11 > (__int16)v12)
        v24 = a1[3];
      a1[3] = v24;
    }
  }
}

uint64_t VCEffects_EffectsMode(uint64_t a1)
{
  uint64_t result;
  uint64_t v2;
  NSObject *v3;
  _BOOL4 v4;
  int v5;
  uint64_t v6;
  __int16 v7;
  const char *v8;
  __int16 v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (a1)
    return *(unsigned int *)(a1 + 8);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    v4 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v4)
      return result;
    v5 = 136315650;
    v6 = v2;
    v7 = 2080;
    v8 = "VCEffects_EffectsMode";
    v9 = 1024;
    v10 = 63;
    _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v5, 0x1Cu);
  }
  return 0;
}

BOOL VCRemoteImageQueue_CreateSenderQueue(uint64_t a1, _QWORD *a2)
{
  return VCRemoteImageQueue_CreateSenderQueueWithPoolSize(a1, a2);
}

BOOL VCRemoteImageQueue_CreateSenderQueueWithPoolSize(uint64_t a1, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _BOOL8 result;
  uint64_t v6[2];
  int v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    *a2 = 0;
    v3 = malloc_type_calloc(1uLL, 0x18uLL, 0x20040960023A9uLL);
    v6[0] = (uint64_t)v3;
    if (!v3)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCRemoteImageQueue_CreateSenderQueueWithPoolSize_cold_2();
      }
      return *a2 != 0;
    }
    v4 = v3;
    if (FigSharedMemPoolCreate())
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCRemoteImageQueue_CreateSenderQueueWithPoolSize_cold_5();
      }
    }
    else
    {
      v7 = 0;
      v6[1] = 0x6400000064;
      if (FigRemoteQueueSenderCreate() || !v4[1])
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCRemoteImageQueue_CreateSenderQueueWithPoolSize_cold_3();
        }
      }
      else
      {
        if (!FigRemoteQueueSenderSetMaximumBufferAge())
        {
          *a2 = v4;
          return *a2 != 0;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCRemoteImageQueue_CreateSenderQueueWithPoolSize_cold_4();
        }
      }
    }
    VCRemoteImageQueue_Destroy(v6);
    return *a2 != 0;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    VCRemoteImageQueue_CreateSenderQueueWithPoolSize_cold_1();
  }
  return 0;
}

void VCRemoteImageQueue_Destroy(uint64_t *a1)
{
  CFTypeRef *v2;

  if (a1)
  {
    v2 = (CFTypeRef *)*a1;
    if (*a1)
    {
      if (v2[1])
      {
        VCRemoteImageQueue_ReleaseIOSurfaces(*a1);
        CFRelease(v2[1]);
      }
      if (*v2)
        CFRelease(*v2);
      if (v2[2])
      {
        FigRemoteQueueReceiverUnsetHandler();
        CFRelease(v2[2]);
      }
      *a1 = 0;
      free(v2);
    }
  }
}

BOOL VCRemoteImageQueue_CreateReceiverQueue(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  char *v5;
  char *v6;
  _QWORD *v7;
  uint64_t MessageReceiver;
  const void *v9;
  _BOOL8 result;
  uint64_t v11[2];

  v11[1] = *MEMORY[0x1E0C80C00];
  if (a1 && a4)
  {
    *a4 = 0;
    v5 = (char *)malloc_type_calloc(1uLL, 0x18uLL, 0x20040960023A9uLL);
    v11[0] = (uint64_t)v5;
    if (!v5)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCRemoteImageQueue_CreateReceiverQueue_cold_1();
      }
      return *a4 != 0;
    }
    v6 = v5;
    v7 = v5 + 16;
    if (FigRemoteQueueReceiverCreateFromXPCObject() || !*v7)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCRemoteImageQueue_CreateReceiverQueue_cold_2();
      }
    }
    else
    {
      MessageReceiver = FigRemoteOperationReceiverCreateMessageReceiver();
      if (MessageReceiver)
      {
        v9 = (const void *)MessageReceiver;
        FigRemoteQueueReceiverSetHandler();
        _Block_release(v9);
        *a4 = v6;
        return *a4 != 0;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCRemoteImageQueue_CreateReceiverQueue_cold_3();
      }
    }
    VCRemoteImageQueue_Destroy(v11);
    return *a4 != 0;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    VCRemoteImageQueue_CreateReceiverQueue_cold_4();
  }
  return 0;
}

uint64_t VCRemoteImageQueue_SharedMemoryPoolAllocator(_QWORD *a1)
{
  if (a1 && *a1)
    return FigRemoteQueueSenderGetSharedMemPoolAllocator();
  else
    return *MEMORY[0x1E0C9AE00];
}

uint64_t VCRemoteImageQueue_ReleaseIOSurfaces(uint64_t a1)
{
  uint64_t v3;
  NSObject *v4;
  int v5;
  uint64_t v6;
  __int16 v7;
  const char *v8;
  __int16 v9;
  int v10;
  __int16 v11;
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (a1 && *(_QWORD *)(a1 + 8))
    return FigRemoteQueueSenderReleaseIOSurfaces();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v3 = VRTraceErrorLogLevelToCSTR();
    v4 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v5 = 136315906;
      v6 = v3;
      v7 = 2080;
      v8 = "VCRemoteImageQueue_ReleaseIOSurfaces";
      v9 = 1024;
      v10 = 198;
      v11 = 2048;
      v12 = a1;
      _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Invalid remoteImageQueue=%p", (uint8_t *)&v5, 0x26u);
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t VCRemoteImageQueue_EnqueueFrame(uint64_t a1, unint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  const char *v6;
  NSObject *v7;
  uint32_t v8;
  uint64_t v9;
  NSObject *v10;
  _BYTE v12[24];
  __int128 v13;
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (!a1 || !*(_QWORD *)(a1 + 8))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 5)
      return 0xFFFFFFFFLL;
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      return 0xFFFFFFFFLL;
    *(_DWORD *)v12 = 136315906;
    *(_QWORD *)&v12[4] = v4;
    *(_WORD *)&v12[12] = 2080;
    *(_QWORD *)&v12[14] = "VCRemoteImageQueue_EnqueueFrame";
    *(_WORD *)&v12[22] = 1024;
    LODWORD(v13) = 152;
    WORD2(v13) = 2048;
    *(_QWORD *)((char *)&v13 + 6) = a1;
    v6 = " [%s] %s:%d Cannot Enqueue on an invalid remoteImageQueue %p";
    v7 = v5;
    v8 = 38;
    goto LABEL_11;
  }
  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 5)
      return 0xFFFFFFFFLL;
    v9 = VRTraceErrorLogLevelToCSTR();
    v10 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      return 0xFFFFFFFFLL;
    *(_DWORD *)v12 = 136315650;
    *(_QWORD *)&v12[4] = v9;
    *(_WORD *)&v12[12] = 2080;
    *(_QWORD *)&v12[14] = "VCRemoteImageQueue_EnqueueFrame";
    *(_WORD *)&v12[22] = 1024;
    LODWORD(v13) = 157;
    v6 = " [%s] %s:%d Pixel Buffer was NULL could not enqueue";
    v7 = v10;
    v8 = 28;
LABEL_11:
    _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, v6, v12, v8);
    return 0xFFFFFFFFLL;
  }
  *(_OWORD *)&v12[8] = 0u;
  *(_QWORD *)v12 = 3;
  v14 = 0;
  v13 = a2;
  v3 = _VCRemoteImageQueue_Enqueue(a1, (int *)v12);
  if ((_DWORD)v3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCRemoteImageQueue_EnqueueFrame_cold_1();
    }
  }
  return v3;
}

uint64_t _VCRemoteImageQueue_Enqueue(uint64_t a1, int *a2)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  NSObject *v11;
  int v12;
  uint64_t v13;
  NSObject *v14;
  int v15;
  uint8_t buf[4];
  uint64_t v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v4 = FigRemoteOperationSenderResetIfFullAndEnqueueOperation();
  if ((_DWORD)v4 == -16669)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 5)
    {
      return 4294950627;
    }
    else
    {
      v10 = VRTraceErrorLogLevelToCSTR();
      v11 = *MEMORY[0x1E0CF2758];
      v8 = 4294950627;
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v12 = *a2;
        *(_DWORD *)buf = 136316418;
        v18 = v10;
        v19 = 2080;
        v20 = "_VCRemoteImageQueue_Enqueue";
        v21 = 1024;
        v22 = 140;
        v23 = 2048;
        v24 = a1;
        v25 = 1024;
        v26 = -16669;
        v27 = 1024;
        v28 = v12;
        _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d remoteImageQueue=%p err=%d opType=%d Queue is full!", buf, 0x32u);
      }
    }
  }
  else
  {
    v5 = v4;
    if ((_DWORD)v4)
    {
      if ((_DWORD)v4 != -16665)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          v13 = VRTraceErrorLogLevelToCSTR();
          v14 = *MEMORY[0x1E0CF2758];
          v8 = 0;
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            return v8;
          v15 = *a2;
          *(_DWORD *)buf = 136316418;
          v18 = v13;
          v19 = 2080;
          v20 = "_VCRemoteImageQueue_Enqueue";
          v21 = 1024;
          v22 = 143;
          v23 = 2048;
          v24 = a1;
          v25 = 1024;
          v26 = v5;
          v27 = 1024;
          v28 = v15;
          _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d remoteImageQueue=%p err=%d opType=%d Error occurred when enqueuing data", buf, 0x32u);
        }
        return 0;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      {
        return 4294950631;
      }
      else
      {
        v6 = VRTraceErrorLogLevelToCSTR();
        v7 = *MEMORY[0x1E0CF2758];
        v8 = 4294950631;
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v9 = *a2;
          *(_DWORD *)buf = 136316418;
          v18 = v6;
          v19 = 2080;
          v20 = "_VCRemoteImageQueue_Enqueue";
          v21 = 1024;
          v22 = 137;
          v23 = 2048;
          v24 = a1;
          v25 = 1024;
          v26 = -16665;
          v27 = 1024;
          v28 = v9;
          _os_log_error_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_ERROR, " [%s] %s:%d remoteImageQueue=%p err=%d opType=%d Client terminated the queue", buf, 0x32u);
        }
      }
    }
    else
    {
      return v4;
    }
  }
  return v8;
}

uint64_t VCRemoteImageQueue_EnqueueAttributes(uint64_t a1, unint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  NSObject *v7;
  const char *v8;
  NSObject *v9;
  uint32_t v10;
  uint64_t v11;
  NSObject *v12;
  int v14;
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  _BYTE buf[24];
  __int128 v23;
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (!a1 || !*(_QWORD *)(a1 + 8))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 5)
      return 4294967294;
    v6 = VRTraceErrorLogLevelToCSTR();
    v7 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      return 4294967294;
    *(_DWORD *)buf = 136315906;
    *(_QWORD *)&buf[4] = v6;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = "VCRemoteImageQueue_EnqueueAttributes";
    *(_WORD *)&buf[22] = 1024;
    LODWORD(v23) = 175;
    WORD2(v23) = 2048;
    *(_QWORD *)((char *)&v23 + 6) = a1;
    v8 = " [%s] %s:%d Cannot Enqueue on an invalid remoteImageQueue %p";
    v9 = v7;
    v10 = 38;
    goto LABEL_11;
  }
  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 5)
      return 4294967294;
    v11 = VRTraceErrorLogLevelToCSTR();
    v12 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      return 4294967294;
    *(_DWORD *)buf = 136315650;
    *(_QWORD *)&buf[4] = v11;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = "VCRemoteImageQueue_EnqueueAttributes";
    *(_WORD *)&buf[22] = 1024;
    LODWORD(v23) = 180;
    v8 = " [%s] %s:%d Attributes are NULL could not enqueue";
    v9 = v12;
    v10 = 28;
LABEL_11:
    _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, v8, buf, v10);
    return 4294967294;
  }
  *(_OWORD *)&buf[8] = 0u;
  *(_QWORD *)buf = 1;
  v24 = 0;
  v23 = a2;
  v3 = _VCRemoteImageQueue_Enqueue(a1, (int *)buf);
  if ((_DWORD)v3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v4 = VRTraceErrorLogLevelToCSTR();
      v5 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v14 = 136315906;
        v15 = v4;
        v16 = 2080;
        v17 = "VCRemoteImageQueue_EnqueueAttributes";
        v18 = 1024;
        v19 = 191;
        v20 = 1024;
        v21 = v3;
        _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Error occurred when sending the video attributes. err=%d", (uint8_t *)&v14, 0x22u);
      }
    }
  }
  return v3;
}

uint64_t VCRemoteImageQueue_CreateQueueXPCObject(uint64_t a1)
{
  uint64_t v3;
  NSObject *v4;
  _DWORD v5[3];
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  __int16 v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (a1 && *(_QWORD *)(a1 + 8))
  {
    FigRemoteQueueSenderCreateXPCObject();
    return 0;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v3 = VRTraceErrorLogLevelToCSTR();
      v4 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v5[0] = 136315906;
        *(_QWORD *)&v5[1] = v3;
        v6 = 2080;
        v7 = "VCRemoteImageQueue_CreateQueueXPCObject";
        v8 = 1024;
        v9 = 206;
        v10 = 2048;
        v11 = a1;
        _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Cannot get the XPC object on an invalid remoteImageQueue %p", (uint8_t *)v5, 0x26u);
      }
    }
    return 0;
  }
}

void VCAudioDump_LogCompressedAudio(uint64_t a1, void *a2, UInt32 a3, unsigned int *a4, unsigned __int16 *a5, double *a6)
{
  _DWORD *v8;
  unsigned int v10;
  int v11;
  BOOL v12;
  int v13;
  double v14;
  unsigned int v15;
  unsigned int v16;

  if (a1)
  {
    v8 = *(_DWORD **)(a1 + 16);
    if (v8)
    {
      if (a2 && *(_QWORD *)(a1 + 24))
      {
        if (a4)
        {
          v10 = *a4;
        }
        else
        {
          v11 = *(_DWORD *)(a1 + 4);
          v12 = v11 == 111 || v11 == 97;
          v13 = v12 ? 160 : 320;
          v10 = v13 + bswap32(v8[3]);
        }
        v8[3] = bswap32(v10);
        if (a3)
        {
          if (a6)
          {
            v14 = *(double *)(a1 + 32);
            if (v14 == 0.0)
              v15 = 0;
            else
              v15 = bswap32(((*a6 - v14) * 1000000.0));
            v8[1] = v15;
            *(double *)(a1 + 32) = *a6;
            v8 = *(_DWORD **)(a1 + 16);
          }
          if (a5)
            v16 = *a5;
          else
            v16 = (bswap32(*((unsigned __int16 *)v8 + 5)) >> 16) + 1;
          *((_WORD *)v8 + 5) = bswap32(v16) >> 16;
          *((_WORD *)v8 + 1) = bswap32(a3 + 12) >> 16;
          *(_WORD *)v8 = bswap32(a3 + 14) >> 16;
          _VCAudioDumpFileWrapper_Update(*(_QWORD *)(a1 + 24), v8, 0x14u);
          _VCAudioDumpFileWrapper_Update(*(_QWORD *)(a1 + 24), a2, a3);
        }
      }
    }
  }
}

void _VCAudioDumpFileWrapper_Update(uint64_t a1, void *a2, UInt32 a3)
{
  OSStatus v3;
  OSStatus v4;
  uint64_t v5;
  NSObject *v6;
  int v7;
  uint64_t v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  OSStatus v14;
  AudioBufferList ioData;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  *(&ioData.mNumberBuffers + 1) = -1431655766;
  ioData.mNumberBuffers = 1;
  ioData.mBuffers[0].mNumberChannels = 1;
  ioData.mBuffers[0].mDataByteSize = a3;
  ioData.mBuffers[0].mData = a2;
  v3 = ExtAudioFileWriteAsync(*(ExtAudioFileRef *)a1, a3 / *(_DWORD *)(a1 + 16), &ioData);
  if (v3)
  {
    v4 = v3;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v6 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v7 = 136315906;
        v8 = v5;
        v9 = 2080;
        v10 = "_VCAudioDumpFileWrapper_Update";
        v11 = 1024;
        v12 = 175;
        v13 = 1024;
        v14 = v4;
        _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d ExtAudioFileWriteAsync failed with error=%d", (uint8_t *)&v7, 0x22u);
      }
    }
  }
}

void VCAudioDump_LogUnCompressedAudio(uint64_t a1, void *a2, uint64_t a3, UInt32 a4)
{
  ExtAudioFileRef *v4;
  const AudioBufferList *AudioBufferList;
  UInt32 SampleCount;
  OSStatus v8;
  OSStatus v9;
  uint64_t v10;
  NSObject *v11;
  int v12;
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  OSStatus v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v4 = *(ExtAudioFileRef **)(a1 + 24);
    if (v4)
    {
      if (a2)
      {
        _VCAudioDumpFileWrapper_Update(*(_QWORD *)(a1 + 24), a2, a4);
      }
      else if (a3)
      {
        AudioBufferList = (const AudioBufferList *)VCAudioBufferList_GetAudioBufferList(a3);
        SampleCount = VCAudioBufferList_GetSampleCount(a3);
        v8 = ExtAudioFileWriteAsync(*v4, SampleCount, AudioBufferList);
        if (v8)
        {
          v9 = v8;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
          {
            v10 = VRTraceErrorLogLevelToCSTR();
            v11 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              v12 = 136315906;
              v13 = v10;
              v14 = 2080;
              v15 = "_VCAudioDumpFileWrapper_UpdateSamples";
              v16 = 1024;
              v17 = 167;
              v18 = 1024;
              v19 = v9;
              _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d ExtAudioFileWriteAsync failed with error=%d", (uint8_t *)&v12, 0x22u);
            }
          }
        }
      }
    }
  }
}

unsigned int *VCAudioDump_Create(unsigned int a1, uint64_t a2)
{
  unsigned int *v4;
  unsigned int *v5;
  void *v6;
  const char *v7;
  int v8;
  unsigned int v9;
  int v10;
  const char *v11;
  const char *v12;
  const char *v13;
  const AudioStreamBasicDescription *v14;
  BOOL v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  int v19;
  unsigned int v20;
  unsigned int v21;
  AudioStreamBasicDescription v23;
  unsigned int v24;
  __int16 v25;
  unsigned int v26;
  __int16 v27;
  int v28;
  __int16 v29;
  unsigned int v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioDump_Create_cold_1();
    }
    return 0;
  }
  if (!*(_BYTE *)a2)
    return 0;
  v4 = (unsigned int *)malloc_type_calloc(1uLL, 0x28uLL, 0x10A0040282E6EF3uLL);
  if (!v4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioDump_Create_cold_2();
    }
    return 0;
  }
  v5 = v4;
  v6 = malloc_type_calloc(1uLL, 0x14uLL, 0x1000040A86A77D5uLL);
  *((_QWORD *)v5 + 2) = v6;
  if (!v6)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioDump_Create_cold_3();
    }
    free(v5);
    return 0;
  }
  *v5 = a1;
  if (a1 > 4)
    v7 = "";
  else
    v7 = off_1E9E57120[a1];
  v8 = *(_DWORD *)(a2 + 4);
  v9 = 8000;
  if (v8 <= 106)
  {
    if (v8 == 97)
      goto LABEL_17;
    if (v8 != 98)
      goto LABEL_16;
LABEL_15:
    v9 = 16000;
    goto LABEL_17;
  }
  if (v8 == 107)
    goto LABEL_15;
  if (v8 != 111)
  {
    if (v8 == 108)
    {
      v9 = 32000;
      goto LABEL_17;
    }
LABEL_16:
    v9 = 0;
  }
LABEL_17:
  *((_WORD *)v5 + 6) = v9;
  if ((a1 & 0xFFFFFFFB) != 0 || (v14 = *(const AudioStreamBasicDescription **)(a2 + 16)) == 0)
  {
    v5[1] = v8;
    if ((v8 - 97) > 1)
    {
      v10 = 5;
      if ((v8 - 107) <= 4 && ((1 << (v8 - 107)) & 0x13) != 0)
        v10 = *(unsigned __int8 *)(a2 + 9);
    }
    else if (*(_BYTE *)(a2 + 8))
    {
      v10 = 3;
    }
    else
    {
      v10 = 2;
    }
    v5[2] = v10;
    v11 = "none";
    if (v8 <= 106)
    {
      if (v8 == 97)
      {
        v12 = "amr_nb_be";
        if (v10 != 2)
          v12 = "none";
        v13 = "amr_nb_oa";
      }
      else
      {
        if (v8 != 98)
          goto LABEL_53;
        v12 = "amr_wb_be";
        if (v10 != 2)
          v12 = "none";
        v13 = "amr_wb_oa";
      }
      v15 = v10 == 3;
    }
    else
    {
      switch(v8)
      {
        case 'k':
          v12 = "evs_wb_hf";
          if (v10 != 1)
            v12 = "none";
          v13 = "evs_wb_ch";
          break;
        case 'l':
          v12 = "evs_swb_hf";
          if (v10 != 1)
            v12 = "none";
          v13 = "evs_swb_ch";
          break;
        case 'o':
          v12 = "evs_nb_hf";
          if (v10 != 1)
            v12 = "none";
          v13 = "evs_nb_ch";
          break;
        default:
          goto LABEL_53;
      }
      v15 = v10 == 0;
    }
    if (v15)
      v11 = v13;
    else
      v11 = v12;
LABEL_53:
    v23.mSampleRate = (double)v9;
    *(_OWORD *)&v23.mFormatID = xmmword_1D910F2F0;
    *(_OWORD *)&v23.mBytesPerFrame = xmmword_1D910F300;
    _VCAudioDump_CreateFile((uint64_t)v5, (uint64_t)v7, (uint64_t)v11, (uint64_t)".rtpdump", &v23);
    v16 = *((_QWORD *)v5 + 3);
    if (v16)
      _VCAudioDumpFileWrapper_Update(v16, _rtpDumpHeader, 0x39u);
    goto LABEL_55;
  }
  _VCAudioDump_CreateFile((uint64_t)v5, (uint64_t)v7, (uint64_t)"pcm", (uint64_t)".caf", v14);
LABEL_55:
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v17 = VRTraceErrorLogLevelToCSTR();
    v18 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v19 = *((unsigned __int16 *)v5 + 6);
      v20 = v5[1];
      v21 = v5[2];
      LODWORD(v23.mSampleRate) = 136316930;
      *(_QWORD *)((char *)&v23.mSampleRate + 4) = v17;
      LOWORD(v23.mFormatFlags) = 2080;
      *(_QWORD *)((char *)&v23.mFormatFlags + 2) = "VCAudioDump_Create";
      HIWORD(v23.mFramesPerPacket) = 1024;
      v23.mBytesPerFrame = 392;
      LOWORD(v23.mChannelsPerFrame) = 2048;
      *(_QWORD *)((char *)&v23.mChannelsPerFrame + 2) = v5;
      HIWORD(v23.mReserved) = 1024;
      v24 = a1;
      v25 = 1024;
      v26 = v20;
      v27 = 1024;
      v28 = v19;
      v29 = 1024;
      v30 = v21;
      _os_log_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Audio dump file=[%p] created successfully for tap point=%d, payloadType=%d, bandwidth=%d, rtpPayloadFormat=%d", (uint8_t *)&v23, 0x3Eu);
    }
  }
  return v5;
}

void _VCAudioDump_CreateFile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const AudioStreamBasicDescription *a5)
{
  char *v7;
  ExtAudioFileRef *v8;
  const __CFAllocator *Default;
  const __CFString *v10;
  const __CFURL *v11;
  OSStatus v12;

  v7 = (char *)LogDumpUtility_CopyLogFilename(2, a2, 1, a3, a4);
  v8 = (ExtAudioFileRef *)malloc_type_calloc(1uLL, 0x18uLL, 0x1020040EDCEB4C7uLL);
  if (v8)
  {
    if (!a5)
    {
      a5 = (const AudioStreamBasicDescription *)malloc_type_calloc(1uLL, 0x28uLL, 0x10000400A747E1EuLL);
      Format_Short((uint64_t)a5, 1, 24000);
    }
    *((_DWORD *)v8 + 4) = a5->mBytesPerFrame;
    Default = CFAllocatorGetDefault();
    v10 = CFStringCreateWithCString(Default, v7, 0x8000100u);
    v11 = CFURLCreateWithFileSystemPath((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v10, kCFURLPOSIXPathStyle, 0);
    v12 = AudioFileCreateWithURL(v11, 0x63616666u, a5, 1u, v8 + 1);
    if (v10)
      CFRelease(v10);
    if (v11)
      CFRelease(v11);
    if (v12)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCAudioDump_CreateFile_cold_3();
      }
LABEL_20:
      free(v8);
      v8 = 0;
      goto LABEL_21;
    }
    if (ExtAudioFileWrapAudioFileID(v8[1], 1u, v8))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCAudioDump_CreateFile_cold_2();
      }
      goto LABEL_20;
    }
    if (ExtAudioFileWriteAsync(*v8, 0, 0))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCAudioDump_CreateFile_cold_1();
      }
      goto LABEL_20;
    }
  }
LABEL_21:
  *(_QWORD *)(a1 + 24) = v8;
  free(v7);
}

void VCAudioDump_Finalize(void **a1)
{
  int *v2;
  uint64_t v3;
  NSObject *v4;
  int v5;
  ExtAudioFileRef *v6;
  void *v7;
  int v8;
  uint64_t v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  int v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = (int *)*a1;
    if (*a1)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v3 = VRTraceErrorLogLevelToCSTR();
        v4 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v5 = *v2;
          v8 = 136315906;
          v9 = v3;
          v10 = 2080;
          v11 = "VCAudioDump_Finalize";
          v12 = 1024;
          v13 = 407;
          v14 = 1024;
          v15 = v5;
          _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Audio dump finalized for tap point=%d", (uint8_t *)&v8, 0x22u);
        }
      }
      v6 = (ExtAudioFileRef *)*((_QWORD *)v2 + 3);
      if (v6)
      {
        ExtAudioFileDispose(*v6);
        AudioFileClose(v6[1]);
        free(v6);
        *((_QWORD *)v2 + 3) = 0;
      }
      v7 = (void *)*((_QWORD *)v2 + 2);
      if (v7)
        free(v7);
      free(v2);
    }
    *a1 = 0;
  }
}

void sub_1D8E459D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  uint64_t v11;
  va_list va;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  va_list va1;

  va_start(va1, a10);
  va_start(va, a10);
  v11 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void VCAudioPlayerDTMF_Initialize(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unsigned __int8 v3;
  unsigned __int8 v4;
  unint64_t v7;
  int v8;
  int v9;
  __int128 v10;
  AudioConverterRef *v11;
  _DWORD *v12;
  int ErrorLogLevelForModule;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  int v20;
  AudioStreamBasicDescription v21;
  AudioStreamBasicDescription inSourceFormat;
  uint8_t buf[4];
  uint64_t v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  unint64_t v30;
  __int16 v31;
  int v32;
  __int16 v33;
  uint64_t v34;
  __int16 v35;
  int v36;
  __int16 v37;
  int v38;
  __int16 v39;
  int v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v2 = a1 + 53704;
  v3 = *(_BYTE *)(a2 + 48);
  *(_BYTE *)(a1 + 53704) = v3;
  v4 = *(_BYTE *)(a2 + 72);
  *(_BYTE *)(a1 + 53724) = v4;
  if (!(v4 | v3))
    return;
  v7 = a1 + 53784;
  v8 = *(_DWORD *)(a1 + 52556);
  v9 = 3 * v8;
  v8 *= 4;
  *(_DWORD *)(a1 + 53708) = v8;
  *(_DWORD *)(a1 + 53712) = v9;
  *(_DWORD *)(a1 + 53716) = v8;
  *(_DWORD *)(a1 + 53720) = *(_DWORD *)(a2 + 52);
  inSourceFormat.mSampleRate = NAN;
  *(_QWORD *)&v10 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&inSourceFormat.mFormatID = v10;
  *(_OWORD *)&inSourceFormat.mBytesPerFrame = v10;
  v21.mSampleRate = NAN;
  *(_OWORD *)&v21.mBytesPerFrame = v10;
  *(_OWORD *)&v21.mFormatID = v10;
  Format_Short((uint64_t)&inSourceFormat, *(_DWORD *)(*(_QWORD *)(a2 + 8) + 28), (int)**(double **)(a2 + 8));
  Format_Float((uint64_t)&v21, *(_DWORD *)(*(_QWORD *)(a2 + 8) + 28), (int)**(double **)(a2 + 8));
  if (v2 >= v7)
  {
    __break(0x5519u);
    return;
  }
  v11 = (AudioConverterRef *)(v2 + 64);
  AudioConverterNew(&inSourceFormat, &v21, (AudioConverterRef *)(v2 + 64));
  if (*(_QWORD *)(v2 + 64))
  {
    *(_QWORD *)(v2 + 24) = 0;
    *(_QWORD *)(a1 + 53736) = 0;
    *(_QWORD *)(a1 + 53744) = 0;
    *(_DWORD *)(a1 + 53752) = 0;
    v12 = VCDTMFToneGenerator_Create();
    *(_QWORD *)(v2 + 56) = v12;
    ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    if (v12)
    {
      if (ErrorLogLevelForModule >= 7)
      {
        v14 = VRTraceErrorLogLevelToCSTR();
        v15 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v16 = **(_QWORD **)(a2 + 8);
          v18 = *(_DWORD *)(v2 + 4);
          v17 = *(_DWORD *)(v2 + 8);
          v20 = *(_DWORD *)(v2 + 12);
          v19 = *(_DWORD *)(v2 + 16);
          *(_DWORD *)buf = 136317186;
          v24 = v14;
          v25 = 2080;
          v26 = "VCAudioPlayerDTMF_Initialize";
          v27 = 1024;
          v28 = 63;
          v29 = 2048;
          v30 = v2;
          v31 = 1024;
          v32 = v19;
          v33 = 2048;
          v34 = v16;
          v35 = 1024;
          v36 = v17;
          v37 = 1024;
          v38 = v18;
          v39 = 1024;
          v40 = v20;
          _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCAudioPlayerDTMF[%p] Successfully initialized DTMF: dtmfSampleRate=%d, audioSampleRate=%f maxTonePlaybackExtensionDuration=%d minTonePlaybackDuration=%d toneGapDuration=%d", buf, 0x48u);
        }
      }
      return;
    }
    if (ErrorLogLevelForModule >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioPlayerDTMF_Initialize_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioPlayerDTMF_Initialize_cold_1();
  }
  if (*v11)
  {
    AudioConverterDispose(*v11);
    *v11 = 0;
  }
}

uint64_t VCAudioPlayerDTMF_Finalize(uint64_t result)
{
  uint64_t v1;

  v1 = result;
  if (*(_BYTE *)result || *(_BYTE *)(result + 20))
  {
    VCDTMFToneGenerator_Destroy((void **)(result + 56));
    result = *(_QWORD *)(v1 + 64);
    if (result)
    {
      result = AudioConverterDispose((AudioConverterRef)result);
      *(_QWORD *)(v1 + 64) = 0;
    }
  }
  return result;
}

BOOL VCAudioPlayerDTMF_ShouldProcessDTMF(uint64_t a1)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  unint64_t v5;
  uint64_t v6;
  _BOOL8 result;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  const char *v11;
  const char *v12;
  uint64_t v13;
  const char *v14;
  uint64_t v15;
  const char *v16;
  int v17;
  uint64_t v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  unint64_t v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  const char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v2 = a1 + 53704;
  v3 = *(int *)(a1 + 53728);
  if (!*(_BYTE *)(a1 + 53704) && !*(_BYTE *)(a1 + 53724))
    return 0;
  v4 = (uint64_t *)(a1 + 35568);
  if (!JitterQueue_IsEmpty(*(_QWORD *)(a1 + 35568)) && !JitterQueue_IsNextFrameDTMF(*v4))
    *(_DWORD *)(v2 + 48) = 0;
  v5 = a1 + 53784;
  switch((int)v3)
  {
    case 0:
      if (!JitterQueue_IsNextFrameDTMF(*v4))
        goto LABEL_9;
      v6 = 1;
      *(_DWORD *)(v2 + 24) = 1;
      goto LABEL_19;
    case 1:
      goto LABEL_15;
    case 2:
      if (!JitterQueue_IsEmpty(*v4))
      {
        result = JitterQueue_IsNextFrameDTMF(*v4);
        if (!result && *(_DWORD *)(v2 + 40) > *(unsigned __int16 *)(v2 + 30))
          goto LABEL_17;
      }
      goto LABEL_16;
    case 3:
      if (JitterQueue_IsEmpty(*v4))
        goto LABEL_16;
LABEL_15:
      result = JitterQueue_IsNextFrameDTMF(*v4);
      if (result)
      {
LABEL_16:
        v6 = 1;
      }
      else
      {
LABEL_17:
        if (v2 >= v5)
        {
          __break(0x5519u);
          return result;
        }
        v6 = 0;
        *(_QWORD *)(v2 + 24) = 0;
        *(_DWORD *)(v2 + 32) = 0;
        *(_QWORD *)(v2 + 40) = 0;
        *(_DWORD *)(v2 + 48) = 0;
      }
LABEL_19:
      if ((_DWORD)v3 != *(_DWORD *)(v2 + 24) && (int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v8 = VRTraceErrorLogLevelToCSTR();
        v9 = *MEMORY[0x1E0CF2758];
        v10 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
          {
            if (v3 > 3)
              v11 = "Invalid";
            else
              v11 = off_1E9E57170[v3];
            v13 = *(int *)(v2 + 24);
            if (v13 > 3)
              v14 = "Invalid";
            else
              v14 = off_1E9E57170[v13];
            v17 = 136316418;
            v18 = v8;
            v19 = 2080;
            v20 = "VCAudioPlayerDTMF_ShouldProcessDTMF";
            v21 = 1024;
            v22 = 477;
            v23 = 2048;
            v24 = v2;
            v25 = 2080;
            v26 = v11;
            v27 = 2080;
            v28 = v14;
            _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCAudioPlayerDTMF[%p] Transitioning DTMF State currentState=%s ==> newState=%s", (uint8_t *)&v17, 0x3Au);
          }
        }
        else if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        {
          if (v3 > 3)
            v12 = "Invalid";
          else
            v12 = off_1E9E57170[v3];
          v15 = *(int *)(v2 + 24);
          if (v15 > 3)
            v16 = "Invalid";
          else
            v16 = off_1E9E57170[v15];
          v17 = 136316418;
          v18 = v8;
          v19 = 2080;
          v20 = "VCAudioPlayerDTMF_ShouldProcessDTMF";
          v21 = 1024;
          v22 = 477;
          v23 = 2048;
          v24 = v2;
          v25 = 2080;
          v26 = v12;
          v27 = 2080;
          v28 = v16;
          _os_log_debug_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEBUG, " [%s] %s:%d VCAudioPlayerDTMF[%p] Transitioning DTMF State currentState=%s ==> newState=%s", (uint8_t *)&v17, 0x3Au);
        }
      }
      break;
    default:
LABEL_9:
      v6 = 0;
      goto LABEL_19;
  }
  return v6;
}

void VCAudioPlayerDTMF_ProcessDTMF(_DWORD *a1, uint64_t a2)
{
  _DWORD *v3;
  _DWORD *v4;
  _DWORD *v5;
  unsigned int v6;
  _BOOL4 v7;
  _BOOL4 v8;
  int ChannelCount;
  unsigned int v10;
  size_t v11;
  unsigned int v12;
  uint64_t v13;
  NSObject *v14;
  NSObject *v15;
  int v16;
  int v17;
  int v18;
  _BOOL4 NextFrameTimestamp;
  unsigned int v20;
  uint64_t v21;
  NSObject *v22;
  NSObject *v23;
  int v24;
  int v25;
  int v26;
  unint64_t v27;
  unint64_t v28;
  unsigned int v29;
  unsigned int v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  NSObject *v34;
  NSObject *v35;
  int v36;
  int v37;
  int v38;
  _BOOL4 v39;
  int v40;
  int v41;
  uint64_t v42;
  NSObject *v43;
  NSObject *v44;
  uint64_t v45;
  NSObject *v46;
  unint64_t v47;
  int v48;
  uint64_t v49;
  NSObject *v50;
  NSObject *v51;
  unsigned int v52;
  unsigned int v53;
  uint64_t v54;
  NSObject *v55;
  NSObject *v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  uint64_t v63;
  NSObject *v64;
  NSObject *v65;
  int v66;
  int v67;
  int v68;
  void (*v69)(_QWORD, _QWORD);
  char *v70;
  int v71;
  unsigned int v72;
  unsigned int v73;
  int v74;
  unsigned int v75;
  int v76;
  uint64_t v77;
  NSObject *v78;
  NSObject *v79;
  const char *v80;
  uint64_t v81;
  const char *v82;
  const char *v83;
  const char *v84;
  uint64_t v85;
  const char *v86;
  const char *v87;
  int v88;
  uint64_t v89;
  NSObject *v90;
  int v91;
  uint64_t v92;
  NSObject *v93;
  int v94;
  NSObject *v95;
  const char *v96;
  uint64_t v97;
  NSObject *v98;
  uint64_t v99;
  NSObject *v100;
  int v101;
  uint64_t v102;
  NSObject *v103;
  int v104;
  int v105;
  int *v106;
  _DWORD *v107;
  _DWORD *v108;
  int v110;
  uint8_t buf[24];
  int v112;
  __int16 v113;
  _BYTE v114[10];
  _BYTE v115[18];
  __int16 v116;
  _QWORD v117[4];

  v3 = a1 + 13140;
  *(_QWORD *)((char *)&v117[2] + 4) = *MEMORY[0x1E0C80C00];
  v4 = a1 + 8882;
  v5 = a1 + 13426;
  v108 = a1 + 13437;
  v107 = a1 + 13446;
  v106 = a1 + 13138;
  do
  {
    while (1)
    {
      JitterQueue_Purge(*((_QWORD *)v4 + 5), (uint64_t (*)(void))_VCAudioPlayerDTMF_ShouldPurgeJitterQueue);
      v6 = v3[292];
      if (v6 == 3)
      {
        ChannelCount = VCAudioBufferList_GetChannelCount(*(_QWORD *)a2);
        if (ChannelCount)
        {
          v10 = 0;
          while (1)
          {
            memset(buf, 0, sizeof(buf));
            VCAudioBufferList_GetSizedBufferAtIndex(*(_QWORD *)a2, v10, 0, buf);
            v11 = (*v3 * *(_DWORD *)(a2 + 8));
            if (*(_QWORD *)&buf[8] < v11)
              break;
            bzero(*(void **)buf, v11);
            if (ChannelCount == ++v10)
              goto LABEL_13;
          }
LABEL_162:
          __break(0x5519u);
        }
LABEL_13:
        v12 = v3[297] + *(_DWORD *)(a2 + 8);
        v3[297] = v12;
        if (v12 >= v3[289])
        {
          v3[292] = 1;
          v3[296] = 0;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() < 8)
          goto LABEL_45;
        v13 = VRTraceErrorLogLevelToCSTR();
        v14 = *MEMORY[0x1E0CF2758];
        v15 = *MEMORY[0x1E0CF2758];
        if (!*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
          {
            v57 = *(_DWORD *)(a2 + 8);
            v58 = v3[289];
            v59 = v3[297];
            *(_DWORD *)buf = 136316674;
            *(_QWORD *)&buf[4] = v13;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VCAudioPlayerDTMF_ProcessDTMFStatePlayingGap";
            *(_WORD *)&buf[22] = 1024;
            v112 = 398;
            v113 = 2048;
            *(_QWORD *)v114 = v5;
            *(_WORD *)&v114[8] = 1024;
            *(_DWORD *)v115 = v57;
            *(_WORD *)&v115[4] = 1024;
            *(_DWORD *)&v115[6] = v58;
            *(_WORD *)&v115[10] = 1024;
            *(_DWORD *)&v115[12] = v59;
            _os_log_debug_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEBUG, " [%s] %s:%d VCAudioPlayerDTMF[%p] Playing Gap samplesCount=%d maxToneGapDuration=%d toneGapDurationCount=%d ", buf, 0x38u);
          }
          goto LABEL_45;
        }
        v8 = 0;
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          v16 = *(_DWORD *)(a2 + 8);
          v17 = v3[289];
          v18 = v3[297];
          *(_DWORD *)buf = 136316674;
          *(_QWORD *)&buf[4] = v13;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VCAudioPlayerDTMF_ProcessDTMFStatePlayingGap";
          *(_WORD *)&buf[22] = 1024;
          v112 = 398;
          v113 = 2048;
          *(_QWORD *)v114 = v5;
          *(_WORD *)&v114[8] = 1024;
          *(_DWORD *)v115 = v16;
          *(_WORD *)&v115[4] = 1024;
          *(_DWORD *)&v115[6] = v17;
          *(_WORD *)&v115[10] = 1024;
          *(_DWORD *)&v115[12] = v18;
          _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCAudioPlayerDTMF[%p] Playing Gap samplesCount=%d maxToneGapDuration=%d toneGapDurationCount=%d ", buf, 0x38u);
LABEL_45:
          v8 = 0;
          goto LABEL_122;
        }
        goto LABEL_122;
      }
      if (v6 == 2)
      {
        v110 = -1431655766;
        NextFrameTimestamp = JitterQueue_GetNextFrameTimestamp(*((_QWORD *)v4 + 5), &v110);
        v20 = v3[296];
        if (v20 < *((unsigned __int16 *)v3 + 587))
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            v21 = VRTraceErrorLogLevelToCSTR();
            v22 = *MEMORY[0x1E0CF2758];
            v23 = *MEMORY[0x1E0CF2758];
            if (*MEMORY[0x1E0CF2748])
            {
              v24 = 0;
              if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
                goto LABEL_109;
              v25 = v3[296];
              v26 = *((unsigned __int16 *)v3 + 587);
              *(_DWORD *)buf = 136316418;
              *(_QWORD *)&buf[4] = v21;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_VCAudioPlayerDTMF_GetNextDTMFFrame";
              *(_WORD *)&buf[22] = 1024;
              v112 = 260;
              v113 = 2048;
              *(_QWORD *)v114 = v5;
              *(_WORD *)&v114[8] = 1024;
              *(_DWORD *)v115 = v25;
              *(_WORD *)&v115[4] = 1024;
              *(_DWORD *)&v115[6] = v26;
              _os_log_impl(&dword_1D8A54000, v22, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCAudioPlayerDTMF[%p] Continue with last event duration, lastEventDurationCount=%d lastEventInfo.duration=%d", buf, 0x32u);
            }
            else if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
            {
              v40 = v3[296];
              v41 = *((unsigned __int16 *)v3 + 587);
              *(_DWORD *)buf = 136316418;
              *(_QWORD *)&buf[4] = v21;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_VCAudioPlayerDTMF_GetNextDTMFFrame";
              *(_WORD *)&buf[22] = 1024;
              v112 = 260;
              v113 = 2048;
              *(_QWORD *)v114 = v5;
              *(_WORD *)&v114[8] = 1024;
              *(_DWORD *)v115 = v40;
              *(_WORD *)&v115[4] = 1024;
              *(_DWORD *)&v115[6] = v41;
              _os_log_debug_impl(&dword_1D8A54000, v22, OS_LOG_TYPE_DEBUG, " [%s] %s:%d VCAudioPlayerDTMF[%p] Continue with last event duration, lastEventDurationCount=%d lastEventInfo.duration=%d", buf, 0x32u);
            }
          }
          goto LABEL_108;
        }
        if (!v20)
        {
LABEL_27:
          v27 = JitterQueue_Pop(*((_QWORD *)v4 + 5));
          if (v27)
          {
            v28 = v27;
            if (*(_DWORD *)(v27 + 1144) == 4)
            {
              v29 = *(_DWORD *)(v27 + 16);
              if ((v29 & 0xF0) == 0)
              {
                v30 = (unsigned __int16)bswap32(v29);
                if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
                {
                  v33 = VRTraceErrorLogLevelToCSTR();
                  v34 = *MEMORY[0x1E0CF2758];
                  v35 = *MEMORY[0x1E0CF2758];
                  if (*MEMORY[0x1E0CF2748])
                  {
                    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
                    {
                      v36 = *(_DWORD *)(v28 + 4);
                      v37 = *(unsigned __int16 *)(v28 + 10);
                      v38 = *(_DWORD *)(v28 + 12);
                      *(_DWORD *)buf = 136317442;
                      *(_QWORD *)&buf[4] = v33;
                      *(_WORD *)&buf[12] = 2080;
                      *(_QWORD *)&buf[14] = "_VCAudioPlayerDTMF_ParseDTMFEventPacket";
                      *(_WORD *)&buf[22] = 1024;
                      v112 = 174;
                      v113 = 1024;
                      *(_DWORD *)v114 = v29;
                      *(_WORD *)&v114[4] = 1024;
                      *(_DWORD *)&v114[6] = (v29 >> 15) & 1;
                      *(_WORD *)v115 = 1024;
                      *(_DWORD *)&v115[2] = (v29 >> 8) & 0x3F;
                      *(_WORD *)&v115[6] = 1024;
                      *(_DWORD *)&v115[8] = v30;
                      *(_WORD *)&v115[12] = 1024;
                      *(_DWORD *)&v115[14] = v36;
                      v116 = 1024;
                      LODWORD(v117[0]) = v37;
                      WORD2(v117[0]) = 1024;
                      *(_DWORD *)((char *)v117 + 6) = v38;
                      _os_log_impl(&dword_1D8A54000, v34, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Parsed DTMF EventInfo: eventType=%d isEnd=%d volume=%d duration=%d, RTP Header Info: isMarker=%d seqNumber=%d rtpTimeStamp=%d", buf, 0x46u);
                    }
                  }
                  else if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
                  {
                    v60 = *(_DWORD *)(v28 + 4);
                    v61 = *(unsigned __int16 *)(v28 + 10);
                    v62 = *(_DWORD *)(v28 + 12);
                    *(_DWORD *)buf = 136317442;
                    *(_QWORD *)&buf[4] = v33;
                    *(_WORD *)&buf[12] = 2080;
                    *(_QWORD *)&buf[14] = "_VCAudioPlayerDTMF_ParseDTMFEventPacket";
                    *(_WORD *)&buf[22] = 1024;
                    v112 = 174;
                    v113 = 1024;
                    *(_DWORD *)v114 = v29;
                    *(_WORD *)&v114[4] = 1024;
                    *(_DWORD *)&v114[6] = (v29 >> 15) & 1;
                    *(_WORD *)v115 = 1024;
                    *(_DWORD *)&v115[2] = (v29 >> 8) & 0x3F;
                    *(_WORD *)&v115[6] = 1024;
                    *(_DWORD *)&v115[8] = v30;
                    *(_WORD *)&v115[12] = 1024;
                    *(_DWORD *)&v115[14] = v60;
                    v116 = 1024;
                    LODWORD(v117[0]) = v61;
                    WORD2(v117[0]) = 1024;
                    *(_DWORD *)((char *)v117 + 6) = v62;
                    _os_log_debug_impl(&dword_1D8A54000, v34, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Parsed DTMF EventInfo: eventType=%d isEnd=%d volume=%d duration=%d, RTP Header Info: isMarker=%d seqNumber=%d rtpTimeStamp=%d", buf, 0x46u);
                  }
                }
                LODWORD(v31) = *v106;
                LODWORD(v32) = v3[290];
                v48 = (int)((double)v31 / (double)v32 * (double)v30);
                if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
                {
                  v49 = VRTraceErrorLogLevelToCSTR();
                  v50 = *MEMORY[0x1E0CF2758];
                  v51 = *MEMORY[0x1E0CF2758];
                  if (*MEMORY[0x1E0CF2748])
                  {
                    if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 136315906;
                      *(_QWORD *)&buf[4] = v49;
                      *(_WORD *)&buf[12] = 2080;
                      *(_QWORD *)&buf[14] = "_VCAudioPlayerDTMF_ProcessNextDTMFFrameForCurrentEvent";
                      *(_WORD *)&buf[22] = 1024;
                      v112 = 205;
                      v113 = 1024;
                      *(_DWORD *)v114 = (unsigned __int16)v48;
                      _os_log_impl(&dword_1D8A54000, v50, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCAudioPlayerDTMF Updated DTMF duration=%d", buf, 0x22u);
                      if ((v29 & 0x8000) != 0)
                      {
LABEL_88:
                        v53 = (unsigned __int16)v48;
                        if (v3[287] > (unsigned __int16)v48)
                        {
                          if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
                          {
                            v63 = VRTraceErrorLogLevelToCSTR();
                            v64 = *MEMORY[0x1E0CF2758];
                            v65 = *MEMORY[0x1E0CF2758];
                            if (*MEMORY[0x1E0CF2748])
                            {
                              if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
                              {
                                v66 = v3[287];
                                *(_DWORD *)buf = 136316418;
                                *(_QWORD *)&buf[4] = v63;
                                *(_WORD *)&buf[12] = 2080;
                                *(_QWORD *)&buf[14] = "_VCAudioPlayerDTMF_ProcessNextDTMFFrameForCurrentEvent";
                                *(_WORD *)&buf[22] = 1024;
                                v112 = 209;
                                v113 = 2048;
                                *(_QWORD *)v114 = v5;
                                *(_WORD *)&v114[8] = 1024;
                                *(_DWORD *)v115 = v53;
                                *(_WORD *)&v115[4] = 1024;
                                *(_DWORD *)&v115[6] = v66;
                                _os_log_impl(&dword_1D8A54000, v64, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCAudioPlayerDTMF[%p] Reset evenDuration for endFrame oldValue=%d newValue=%d", buf, 0x32u);
                              }
                            }
                            else if (os_log_type_enabled(v65, OS_LOG_TYPE_DEBUG))
                            {
                              v88 = v3[287];
                              *(_DWORD *)buf = 136316418;
                              *(_QWORD *)&buf[4] = v63;
                              *(_WORD *)&buf[12] = 2080;
                              *(_QWORD *)&buf[14] = "_VCAudioPlayerDTMF_ProcessNextDTMFFrameForCurrentEvent";
                              *(_WORD *)&buf[22] = 1024;
                              v112 = 209;
                              v113 = 2048;
                              *(_QWORD *)v114 = v5;
                              *(_WORD *)&v114[8] = 1024;
                              *(_DWORD *)v115 = v53;
                              *(_WORD *)&v115[4] = 1024;
                              *(_DWORD *)&v115[6] = v88;
                              _os_log_debug_impl(&dword_1D8A54000, v64, OS_LOG_TYPE_DEBUG, " [%s] %s:%d VCAudioPlayerDTMF[%p] Reset evenDuration for endFrame oldValue=%d newValue=%d", buf, 0x32u);
                            }
                          }
                          v53 = *((unsigned __int16 *)v3 + 574);
                        }
                        v52 = v3[296];
                        if (v52 > v53)
                        {
                          v3[292] = 3;
                          v3[297] = 0;
                          v24 = 1;
                          goto LABEL_109;
                        }
                        goto LABEL_98;
                      }
LABEL_76:
                      v52 = v3[296];
                      LOWORD(v53) = v48;
                      if (v52 > (unsigned __int16)v48)
                      {
                        v3[298] = v52 - (unsigned __int16)v48;
                        goto LABEL_106;
                      }
LABEL_98:
                      if (!v52)
                      {
                        JitterQueue_SetLastDecodedDTMFFrameTimestamp(*((_QWORD *)v4 + 5), *(_DWORD *)(v28 + 12));
                        v67 = v29;
                        v68 = VCDTMFToneGenerator_Reinit(*((_QWORD *)v3 + 150), v29, (v29 >> 8) & 0x3F, *v106);
                        if ((v68 & 0x80000000) == 0)
                        {
                          if (*((_BYTE *)v3 + 1164))
                          {
                            v69 = (void (*)(_QWORD, _QWORD))*((_QWORD *)v3 + 159);
                            if (v69)
                            {
                              v70 = &_VCAudioPlayerDTMF_KeysForEvents[v29];
                              if (v70 >= "" || v70 < "0123456789*#ABCD")
                                goto LABEL_162;
                              v69(*((_QWORD *)v3 + 158), *v70);
                            }
                          }
                          v71 = v3[304] + 1;
                          v3[304] = v71;
                          v3[81] = v71;
                          goto LABEL_106;
                        }
                        v101 = v68;
                        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                        {
                          v102 = VRTraceErrorLogLevelToCSTR();
                          v103 = *MEMORY[0x1E0CF2758];
                          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                          {
                            *(_DWORD *)buf = 136316162;
                            *(_QWORD *)&buf[4] = v102;
                            *(_WORD *)&buf[12] = 2080;
                            *(_QWORD *)&buf[14] = "_VCAudioPlayerDTMF_ProcessNextDTMFFrameForCurrentEvent";
                            *(_WORD *)&buf[22] = 1024;
                            v112 = 235;
                            v113 = 1024;
                            *(_DWORD *)v114 = v67;
                            *(_WORD *)&v114[4] = 1024;
                            *(_DWORD *)&v114[6] = v101;
                            _os_log_error_impl(&dword_1D8A54000, v103, OS_LOG_TYPE_ERROR, " [%s] %s:%d Failed to initialize DTMFToneGenerator, event=%d result=%d", buf, 0x28u);
                          }
                        }
LABEL_108:
                        v24 = 0;
LABEL_109:
                        if (_VCAudioPlayerDTMF_GenerateSamples((uint64_t)a1, a2))
                        {
                          v72 = v3[296];
                          v73 = *((unsigned __int16 *)v3 + 587);
                          v74 = *(_DWORD *)(a2 + 8);
                          if (v72 >= v73)
                            v3[298] += v74;
                          v75 = v74 + v72;
                          v3[296] = v75;
                          if (v75 >= v73)
                          {
                            if (*((char *)v3 + 1173) < 0)
                            {
                              v3[295] = v3[294];
                              if (v5 >= v107)
                                goto LABEL_162;
                              JitterQueue_Purge(*((_QWORD *)v4 + 5), (uint64_t (*)(void))_VCAudioPlayerDTMF_ShouldPurgeJitterQueue);
                              if (JitterQueue_IsNextFrameDTMF(*((_QWORD *)v4 + 5)))
                              {
                                *v108 = 0;
                                v76 = 3;
                              }
                              else
                              {
                                v76 = 1;
                              }
                              v3[292] = v76;
                            }
                          }
                          else
                          {
                            if (v5 >= v107)
                              goto LABEL_162;
                            JitterQueue_Purge(*((_QWORD *)v4 + 5), (uint64_t (*)(void))_VCAudioPlayerDTMF_ShouldPurgeJitterQueue);
                          }
                        }
                        else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                        {
                          v89 = VRTraceErrorLogLevelToCSTR();
                          v90 = *MEMORY[0x1E0CF2758];
                          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                          {
                            v91 = *((unsigned __int8 *)v3 + 1172);
                            *(_DWORD *)buf = 136315906;
                            *(_QWORD *)&buf[4] = v89;
                            *(_WORD *)&buf[12] = 2080;
                            *(_QWORD *)&buf[14] = "_VCAudioPlayerDTMF_ProcessDTMFStatePlayingTone";
                            *(_WORD *)&buf[22] = 1024;
                            v112 = 353;
                            v113 = 1024;
                            *(_DWORD *)v114 = v91;
                            _os_log_error_impl(&dword_1D8A54000, v90, OS_LOG_TYPE_ERROR, " [%s] %s:%d Failed to generate DTMF samples for event=%d", buf, 0x22u);
                          }
                        }
                        goto LABEL_121;
                      }
LABEL_106:
                      a1[6] = *(_DWORD *)(v28 + 12);
                      v3[293] = (unsigned __int16)v29 | ((unsigned __int16)v53 << 16);
                      v3[294] = *(_DWORD *)(v28 + 12);
                      if (v28 >= v28 + 1272)
                        goto LABEL_162;
                      (*(void (**)(_QWORD, unint64_t))(v28 + 1200))(*(_QWORD *)(v28 + 1208), v28);
                      goto LABEL_108;
                    }
                  }
                  else if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)buf = 136315906;
                    *(_QWORD *)&buf[4] = v49;
                    *(_WORD *)&buf[12] = 2080;
                    *(_QWORD *)&buf[14] = "_VCAudioPlayerDTMF_ProcessNextDTMFFrameForCurrentEvent";
                    *(_WORD *)&buf[22] = 1024;
                    v112 = 205;
                    v113 = 1024;
                    *(_DWORD *)v114 = (unsigned __int16)v48;
                    _os_log_debug_impl(&dword_1D8A54000, v50, OS_LOG_TYPE_DEBUG, " [%s] %s:%d VCAudioPlayerDTMF Updated DTMF duration=%d", buf, 0x22u);
                    if ((v29 & 0x8000) != 0)
                      goto LABEL_88;
                    goto LABEL_76;
                  }
                }
                if ((v29 & 0x8000) != 0)
                  goto LABEL_88;
                goto LABEL_76;
              }
              if ((int)VRTraceGetErrorLogLevelForModule() < 3)
                goto LABEL_155;
              v97 = VRTraceErrorLogLevelToCSTR();
              v98 = *MEMORY[0x1E0CF2758];
              if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                goto LABEL_155;
              *(_DWORD *)buf = 136315906;
              *(_QWORD *)&buf[4] = v97;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_VCAudioPlayerDTMF_ParseDTMFEventPacket";
              *(_WORD *)&buf[22] = 1024;
              v112 = 170;
              v113 = 1024;
              *(_DWORD *)v114 = v29;
              v95 = v98;
              v96 = " [%s] %s:%d Received Invalid DTMF eventType=%d";
            }
            else
            {
              if ((int)VRTraceGetErrorLogLevelForModule() < 3
                || (v92 = VRTraceErrorLogLevelToCSTR(),
                    v93 = *MEMORY[0x1E0CF2758],
                    !os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR)))
              {
LABEL_155:
                v3[292] = 1;
                if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                {
                  v99 = VRTraceErrorLogLevelToCSTR();
                  v100 = *MEMORY[0x1E0CF2758];
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 136315650;
                    *(_QWORD *)&buf[4] = v99;
                    *(_WORD *)&buf[12] = 2080;
                    *(_QWORD *)&buf[14] = "_VCAudioPlayerDTMF_ProcessNextDTMFFrameForCurrentEvent";
                    *(_WORD *)&buf[22] = 1024;
                    v112 = 200;
                    _os_log_error_impl(&dword_1D8A54000, v100, OS_LOG_TYPE_ERROR, " [%s] %s:%d Failed to parse DTMF payload", buf, 0x1Cu);
                  }
                }
                goto LABEL_80;
              }
              v94 = *(_DWORD *)(v28 + 1144);
              *(_DWORD *)buf = 136315906;
              *(_QWORD *)&buf[4] = v92;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_VCAudioPlayerDTMF_ParseDTMFEventPacket";
              *(_WORD *)&buf[22] = 1024;
              v112 = 155;
              v113 = 1024;
              *(_DWORD *)v114 = v94;
              v95 = v93;
              v96 = " [%s] %s:%d Invalid DTMF payloadSize=%d";
            }
            _os_log_error_impl(&dword_1D8A54000, v95, OS_LOG_TYPE_ERROR, v96, buf, 0x22u);
            goto LABEL_155;
          }
LABEL_66:
          v3[292] = 1;
LABEL_80:
          v3[295] = v3[294];
          if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            v54 = VRTraceErrorLogLevelToCSTR();
            v55 = *MEMORY[0x1E0CF2758];
            v56 = *MEMORY[0x1E0CF2758];
            if (*MEMORY[0x1E0CF2748])
            {
              if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315906;
                *(_QWORD *)&buf[4] = v54;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "_VCAudioPlayerDTMF_ProcessDTMFStatePlayingTone";
                *(_WORD *)&buf[22] = 1024;
                v112 = 350;
                v113 = 2048;
                *(_QWORD *)v114 = v5;
                _os_log_impl(&dword_1D8A54000, v55, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCAudioPlayerDTMF[%p] _VCAudioPlayerDTMF_ProcessDTMFStatePlayingTone Skipped", buf, 0x26u);
              }
            }
            else if (os_log_type_enabled(v56, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136315906;
              *(_QWORD *)&buf[4] = v54;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_VCAudioPlayerDTMF_ProcessDTMFStatePlayingTone";
              *(_WORD *)&buf[22] = 1024;
              v112 = 350;
              v113 = 2048;
              *(_QWORD *)v114 = v5;
              _os_log_debug_impl(&dword_1D8A54000, v55, OS_LOG_TYPE_DEBUG, " [%s] %s:%d VCAudioPlayerDTMF[%p] _VCAudioPlayerDTMF_ProcessDTMFStatePlayingTone Skipped", buf, 0x26u);
            }
          }
          v24 = 1;
LABEL_121:
          v8 = v24 != 0;
          goto LABEL_122;
        }
        if (NextFrameTimestamp)
        {
          if (v110 == v3[294])
            goto LABEL_27;
          if (JitterQueue_IsEmpty(*((_QWORD *)v4 + 5)) || v110 != v3[294])
            goto LABEL_52;
        }
        else if (JitterQueue_IsEmpty(*((_QWORD *)v4 + 5)))
        {
LABEL_52:
          if (v3[298] == v3[288])
          {
            v3[292] = 3;
            *(_QWORD *)v108 = 0;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
            {
              v42 = VRTraceErrorLogLevelToCSTR();
              v43 = *MEMORY[0x1E0CF2758];
              v44 = *MEMORY[0x1E0CF2758];
              if (*MEMORY[0x1E0CF2748])
              {
                if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 136315906;
                  *(_QWORD *)&buf[4] = v42;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = "_VCAudioPlayerDTMF_GetNextDTMFFrame";
                  *(_WORD *)&buf[22] = 1024;
                  v112 = 274;
                  v113 = 2048;
                  *(_QWORD *)v114 = v5;
                  _os_log_impl(&dword_1D8A54000, v43, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCAudioPlayerDTMF[%p] Exiting from Tone extension window", buf, 0x26u);
                }
              }
              else if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 136315906;
                *(_QWORD *)&buf[4] = v42;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "_VCAudioPlayerDTMF_GetNextDTMFFrame";
                *(_WORD *)&buf[22] = 1024;
                v112 = 274;
                v113 = 2048;
                *(_QWORD *)v114 = v5;
                _os_log_debug_impl(&dword_1D8A54000, v43, OS_LOG_TYPE_DEBUG, " [%s] %s:%d VCAudioPlayerDTMF[%p] Exiting from Tone extension window", buf, 0x26u);
              }
            }
            goto LABEL_80;
          }
        }
        if (v3[296] != *((unsigned __int16 *)v3 + 587)
          || JitterQueue_IsNextFrameMarkerSet(*((_QWORD *)v4 + 5))
          || *((__int16 *)v3 + 587) != -1)
        {
          goto LABEL_108;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          v45 = VRTraceErrorLogLevelToCSTR();
          v46 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315906;
            *(_QWORD *)&buf[4] = v45;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VCAudioPlayerDTMF_GetNextDTMFFrame";
            *(_WORD *)&buf[22] = 1024;
            v112 = 278;
            v113 = 2048;
            *(_QWORD *)v114 = v5;
            _os_log_impl(&dword_1D8A54000, v46, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCAudioPlayerDTMF[%p] Discard the long event", buf, 0x26u);
          }
        }
        v47 = JitterQueue_Pop(*((_QWORD *)v4 + 5));
        if (v47)
        {
          if (v47 >= v47 + 1272)
            goto LABEL_162;
          (*(void (**)(_QWORD))(v47 + 1200))(*(_QWORD *)(v47 + 1208));
        }
        goto LABEL_66;
      }
      if (v6 != 1)
        goto LABEL_8;
      *(_DWORD *)buf = -1431655766;
      v7 = JitterQueue_GetNextFrameTimestamp(*((_QWORD *)v4 + 5), buf);
      if (!*v108
        && v3[294]
        && (v39 = v7, JitterQueue_IsNextFrameDTMF(*((_QWORD *)v4 + 5)))
        && (JitterQueue_IsNextFrameMarkerSet(*((_QWORD *)v4 + 5)) || v39 && *(_DWORD *)buf > v3[294])
        || JitterQueue_IsEmpty(*((_QWORD *)v4 + 5)))
      {
        v3[292] = 3;
        v3[297] = 0;
LABEL_8:
        v8 = 1;
        goto LABEL_122;
      }
      if (!JitterQueue_IsNextFrameDTMF(*((_QWORD *)v4 + 5)))
        goto LABEL_45;
      if (v5 >= v107)
        goto LABEL_162;
      v3[294] = 0;
      *((_QWORD *)v3 + 148) = 0;
      v3[298] = 0;
      v8 = 1;
      *((_QWORD *)v3 + 146) = 2;
LABEL_122:
      if (v6 == v3[292] || (int)VRTraceGetErrorLogLevelForModule() < 8)
        goto LABEL_135;
      v77 = VRTraceErrorLogLevelToCSTR();
      v78 = *MEMORY[0x1E0CF2758];
      v79 = *MEMORY[0x1E0CF2758];
      if (!*MEMORY[0x1E0CF2748])
        break;
      if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
      {
        v80 = "Invalid";
        if (v6 <= 3)
          v80 = off_1E9E57170[v6];
        v81 = (int)v3[292];
        v82 = "Invalid";
        if (v81 <= 3)
          v82 = off_1E9E57170[v81];
        *(_DWORD *)buf = 136316674;
        v83 = "NO";
        if (v8)
          v83 = "YES";
        *(_QWORD *)&buf[4] = v77;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "VCAudioPlayerDTMF_ProcessDTMF";
        *(_WORD *)&buf[22] = 1024;
        v112 = 505;
        v113 = 2048;
        *(_QWORD *)v114 = v5;
        *(_WORD *)&v114[8] = 2080;
        *(_QWORD *)v115 = v80;
        *(_WORD *)&v115[8] = 2080;
        *(_QWORD *)&v115[10] = v82;
        v116 = 2080;
        v117[0] = v83;
        _os_log_impl(&dword_1D8A54000, v78, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCAudioPlayerDTMF[%p] Transitioning DTMF State currentState=%s ==> newState=%s shouldContinue=%s", buf, 0x44u);
        if (!v8)
          goto LABEL_161;
      }
      else
      {
LABEL_135:
        if (!v8)
          goto LABEL_161;
      }
    }
    if (!os_log_type_enabled(v79, OS_LOG_TYPE_DEBUG))
      goto LABEL_135;
    v84 = "Invalid";
    if (v6 <= 3)
      v84 = off_1E9E57170[v6];
    v85 = (int)v3[292];
    v86 = "Invalid";
    if (v85 <= 3)
      v86 = off_1E9E57170[v85];
    *(_DWORD *)buf = 136316674;
    v87 = "NO";
    if (v8)
      v87 = "YES";
    *(_QWORD *)&buf[4] = v77;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = "VCAudioPlayerDTMF_ProcessDTMF";
    *(_WORD *)&buf[22] = 1024;
    v112 = 505;
    v113 = 2048;
    *(_QWORD *)v114 = v5;
    *(_WORD *)&v114[8] = 2080;
    *(_QWORD *)v115 = v84;
    *(_WORD *)&v115[8] = 2080;
    *(_QWORD *)&v115[10] = v86;
    v116 = 2080;
    v117[0] = v87;
    _os_log_debug_impl(&dword_1D8A54000, v78, OS_LOG_TYPE_DEBUG, " [%s] %s:%d VCAudioPlayerDTMF[%p] Transitioning DTMF State currentState=%s ==> newState=%s shouldContinue=%s", buf, 0x44u);
  }
  while (v8);
LABEL_161:
  v104 = *(_DWORD *)(a2 + 8);
  a1[6] += v104;
  *v4 += v104;
  v105 = a1[43] + v104;
  a1[42] = 0;
  a1[43] = v105;
  a1[77] += v104;
  a1[76] = 0;
}

uint64_t _VCAudioPlayerDTMF_ShouldPurgeJitterQueue(uint64_t a1, uint64_t a2)
{
  int v4;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  _BOOL8 v8;
  int v9;
  const char *v10;
  NSObject *v11;
  uint32_t v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  int v16;
  uint64_t v17;
  NSObject *v18;
  NSObject *v19;
  int v20;
  int v21;
  uint64_t v22;
  NSObject *v23;
  NSObject *v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  const char *v31;
  NSObject *v32;
  uint32_t v33;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  __int16 v39;
  const char *v40;
  __int16 v41;
  int v42;
  __int16 v43;
  uint64_t v44;
  __int16 v45;
  int v46;
  __int16 v47;
  int v48;
  __int16 v49;
  _BOOL4 v50;
  __int16 v51;
  int v52;
  __int16 v53;
  _BOOL4 v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  if (*(_DWORD *)(a1 + 1196) != 117)
  {
    v13 = *(_DWORD *)(a2 + 40);
    v14 = *(unsigned __int16 *)(a2 + 30);
    if (v13 >= v14)
    {
      if (v13 != v14)
      {
        v15 = 0;
        v8 = 0;
        goto LABEL_20;
      }
      v15 = 2;
      v14 = *(_DWORD *)(a2 + 40);
    }
    else
    {
      v15 = 1;
    }
    v8 = *(_DWORD *)(a1 + 12) - (*(_DWORD *)(a2 + 32) + v14) > 0x7FFFFFFE;
LABEL_20:
    if ((int)VRTraceGetErrorLogLevelForModule() < 8)
      return v8;
    v22 = VRTraceErrorLogLevelToCSTR();
    v23 = *MEMORY[0x1E0CF2758];
    v24 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        v25 = *(_DWORD *)(a1 + 1196);
        v26 = *(_DWORD *)(a1 + 12);
        v27 = *(_DWORD *)(a2 + 32) + *(unsigned __int16 *)(a2 + 30);
        v37 = 136317186;
        v38 = v22;
        v39 = 2080;
        v40 = "_VCAudioPlayerDTMF_ShouldPurgeJitterQueue";
        v41 = 1024;
        v42 = 130;
        v43 = 2048;
        v44 = a2;
        v45 = 1024;
        v46 = v25;
        v47 = 1024;
        v48 = v26;
        v49 = 1024;
        v50 = v27;
        v51 = 1024;
        v52 = v15;
        v53 = 1024;
        v54 = v8;
        v10 = " [%s] %s:%d VCAudioPlayerDTMF[%p] Should Purge audioFrames, payloadType=%d frameTimeStamp=%d lastEventMaxT"
              "imeStamp=%d audioFrameCase=%d result=%d";
        v11 = v23;
        v12 = 68;
        goto LABEL_24;
      }
      return v8;
    }
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
      return v8;
    v28 = *(_DWORD *)(a1 + 1196);
    v29 = *(_DWORD *)(a1 + 12);
    v30 = *(_DWORD *)(a2 + 32) + *(unsigned __int16 *)(a2 + 30);
    v37 = 136317186;
    v38 = v22;
    v39 = 2080;
    v40 = "_VCAudioPlayerDTMF_ShouldPurgeJitterQueue";
    v41 = 1024;
    v42 = 130;
    v43 = 2048;
    v44 = a2;
    v45 = 1024;
    v46 = v28;
    v47 = 1024;
    v48 = v29;
    v49 = 1024;
    v50 = v30;
    v51 = 1024;
    v52 = v15;
    v53 = 1024;
    v54 = v8;
    v31 = " [%s] %s:%d VCAudioPlayerDTMF[%p] Should Purge audioFrames, payloadType=%d frameTimeStamp=%d lastEventMaxTimeS"
          "tamp=%d audioFrameCase=%d result=%d";
    v32 = v23;
    v33 = 68;
LABEL_33:
    _os_log_debug_impl(&dword_1D8A54000, v32, OS_LOG_TYPE_DEBUG, v31, (uint8_t *)&v37, v33);
    return v8;
  }
  v4 = *(_DWORD *)(a1 + 12);
  if (v4 == *(_DWORD *)(a2 + 36))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v6 = *MEMORY[0x1E0CF2758];
      v7 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        v8 = 1;
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          v9 = *(_DWORD *)(a2 + 32);
          v37 = 136316418;
          v38 = v5;
          v39 = 2080;
          v40 = "_VCAudioPlayerDTMF_ShouldPurgeJitterQueue";
          v41 = 1024;
          v42 = 114;
          v43 = 2048;
          v44 = a2;
          v45 = 1024;
          v46 = v9;
          v47 = 1024;
          v48 = 1;
          v10 = " [%s] %s:%d VCAudioPlayerDTMF[%p] Should Purge re-transmitted end events, eventTimeStamp=%d, result=%d";
          v11 = v6;
          v12 = 50;
LABEL_24:
          _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, v10, (uint8_t *)&v37, v12);
          return v8;
        }
        return v8;
      }
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
        _VCAudioPlayerDTMF_ShouldPurgeJitterQueue_cold_1(v5, a2, v6);
    }
    return 1;
  }
  if (*(_DWORD *)(a2 + 24) != 3)
    return 0;
  v16 = *(_DWORD *)(a2 + 32);
  v8 = v4 == v16;
  if ((int)VRTraceGetErrorLogLevelForModule() < 8)
    return v8;
  v17 = VRTraceErrorLogLevelToCSTR();
  v18 = *MEMORY[0x1E0CF2758];
  v19 = *MEMORY[0x1E0CF2758];
  if (!*MEMORY[0x1E0CF2748])
  {
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
      return v8;
    v35 = *(_DWORD *)(a1 + 12);
    v36 = *(_DWORD *)(a2 + 32);
    v37 = 136316674;
    v38 = v17;
    v39 = 2080;
    v40 = "_VCAudioPlayerDTMF_ShouldPurgeJitterQueue";
    v41 = 1024;
    v42 = 118;
    v43 = 2048;
    v44 = a2;
    v45 = 1024;
    v46 = v35;
    v47 = 1024;
    v48 = v36;
    v49 = 1024;
    v50 = v4 == v16;
    v31 = " [%s] %s:%d VCAudioPlayerDTMF[%p] Should Purge DTMF frame for old event, frameTimeStamp=%d eventTimeStamp=%d, result=%d";
    v32 = v18;
    v33 = 56;
    goto LABEL_33;
  }
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    v20 = *(_DWORD *)(a1 + 12);
    v21 = *(_DWORD *)(a2 + 32);
    v37 = 136316674;
    v38 = v17;
    v39 = 2080;
    v40 = "_VCAudioPlayerDTMF_ShouldPurgeJitterQueue";
    v41 = 1024;
    v42 = 118;
    v43 = 2048;
    v44 = a2;
    v45 = 1024;
    v46 = v20;
    v47 = 1024;
    v48 = v21;
    v49 = 1024;
    v50 = v4 == v16;
    v10 = " [%s] %s:%d VCAudioPlayerDTMF[%p] Should Purge DTMF frame for old event, frameTimeStamp=%d eventTimeStamp=%d, result=%d";
    v11 = v18;
    v12 = 56;
    goto LABEL_24;
  }
  return v8;
}

BOOL _VCAudioPlayerDTMF_GenerateSamples(uint64_t a1, uint64_t a2)
{
  uint64_t ChannelCount;
  unsigned int v5;
  unsigned int v6;
  BOOL v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  size_t v11;
  char *v12;
  char *v13;
  char *v14;
  BOOL v15;
  size_t v16;
  size_t v17;
  int v19;
  int v21;
  int ErrorLogLevelForModule;
  uint64_t v23;
  NSObject *v24;
  int v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  UInt32 ioOutputDataSize;
  uint64_t v31;
  __int16 v32;
  const char *v33;
  __int16 v34;
  int v35;
  __int16 v36;
  uint64_t v37;
  __int16 v38;
  int v39;
  __int16 v40;
  int v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  ChannelCount = VCAudioBufferList_GetChannelCount(*(_QWORD *)a2);
  v5 = ChannelCount;
  if (!(_BYTE)ChannelCount)
    return 1;
  v6 = 0;
  v7 = 0;
  v8 = a1 + 53704;
  v9 = (_BYTE *)(a1 + 52568);
  while (1)
  {
    v10 = *(int *)(a2 + 8);
    MEMORY[0x1E0C80A78](ChannelCount);
    v12 = (char *)&v26 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
    if ((_DWORD)v10)
      memset((char *)&v26 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0), 255, v11);
    v27 = 0;
    v28 = 0;
    v29 = 0;
    VCAudioBufferList_GetSizedBufferAtIndex(*(_QWORD *)a2, v6, 0, &v27);
    if (*v9)
    {
      v13 = &v12[4 * v10];
      v14 = v12;
    }
    else
    {
      v14 = v27;
      v13 = &v27[v28];
    }
    if (!*(_BYTE *)v8)
    {
      v16 = 2 * *(int *)(a2 + 8);
      v15 = v13 >= v14;
      v17 = v13 - v14;
      if (!v15 || v16 > v17)
LABEL_29:
        __break(0x5519u);
      bzero(v14, v16);
      goto LABEL_20;
    }
    if (v14)
      v15 = v14 >= v13;
    else
      v15 = 0;
    if (v15)
      goto LABEL_29;
    ChannelCount = VCDTMFToneGenerator_GenerateSamples(*(_DWORD **)(v8 + 56), *(_DWORD *)(a2 + 8), v14);
    if ((ChannelCount & 0x80000000) != 0)
      break;
LABEL_20:
    if (*v9)
    {
      v19 = *(_DWORD *)(a2 + 8);
      ioOutputDataSize = 4 * v19;
      ChannelCount = AudioConverterConvertBuffer(*(AudioConverterRef *)(v8 + 64), 2 * v19, v12, &ioOutputDataSize, v27);
    }
    v7 = v5 <= ++v6;
    if (v5 == v6)
      return 1;
  }
  v21 = ChannelCount;
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (ErrorLogLevelForModule >= 3)
  {
    v23 = VRTraceErrorLogLevelToCSTR();
    v24 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      v25 = *(unsigned __int8 *)(v8 + 28);
      ioOutputDataSize = 136316418;
      v31 = v23;
      v32 = 2080;
      v33 = "_VCAudioPlayerDTMF_GenerateSamples";
      v34 = 1024;
      v35 = 329;
      v36 = 2048;
      v37 = v8;
      v38 = 1024;
      v39 = v25;
      v40 = 1024;
      v41 = v21;
      _os_log_error_impl(&dword_1D8A54000, v24, OS_LOG_TYPE_ERROR, " [%s] %s:%d VCAudioPlayerDTMF[%p] Failed to generate tone samples, event=%d result=%d", (uint8_t *)&ioOutputDataSize, 0x32u);
    }
  }
  return v7;
}

void VCVideoReceiverSampleBuffer_Destroy(const __CFAllocator ***a1)
{
  const __CFAllocator **v2;
  const __CFAllocator *v3;
  const __CFAllocator *v4;
  const __CFAllocator *v5;

  if (a1)
  {
    v2 = *a1;
    if (*a1)
    {
      v3 = *v2;
      VCBlockBuffer_Clear((uint64_t)(v2 + 19));
      VCBlockBuffer_Clear((uint64_t)(v2 + 22));
      VCBlockBuffer_Clear((uint64_t)(v2 + 16));
      VCBlockBuffer_Clear((uint64_t)(v2 + 25));
      v4 = v2[15];
      if (v4)
      {
        CFRelease(v4);
        v2[15] = 0;
      }
      v5 = v2[13];
      if (v5)
      {
        CFRelease(v5);
        v2[13] = 0;
      }
      CFAllocatorDeallocate(v3, v2);
      if (v3)
        CFRelease(v3);
      *a1 = 0;
    }
  }
}

uint64_t VCVideoReceiverSampleBuffer_Create(const __CFAllocator *a1, _QWORD *a2)
{
  _OWORD *v4;
  CFTypeRef v5;

  v4 = CFAllocatorAllocate(a1, 232, 0);
  *v4 = 0u;
  v4[1] = 0u;
  v4[2] = 0u;
  v4[3] = 0u;
  v4[4] = 0u;
  v4[5] = 0u;
  v4[6] = 0u;
  v4[7] = 0u;
  v4[8] = 0u;
  v4[9] = 0u;
  v4[10] = 0u;
  v4[11] = 0u;
  v4[12] = 0u;
  v4[13] = 0u;
  *((_QWORD *)v4 + 28) = 0;
  if (a1)
    v5 = CFRetain(a1);
  else
    v5 = 0;
  *(_QWORD *)v4 = v5;
  *a2 = v4;
  return 1;
}

void VCVideoReceiverDecodedFrame_Destroy(const __CFAllocator ***a1)
{
  const __CFAllocator **v2;
  const __CFAllocator *v3;
  const __CFAllocator *v4;
  const __CFAllocator *v5;

  if (a1)
  {
    v2 = *a1;
    if (*a1)
    {
      v3 = *v2;
      v4 = v2[2];
      if (v4)
      {
        CFRelease(v4);
        v2[2] = 0;
      }
      v5 = v2[1];
      if (v5)
      {
        CFRelease(v5);
        v2[1] = 0;
      }
      CFAllocatorDeallocate(v3, v2);
      if (v3)
        CFRelease(v3);
      *a1 = 0;
    }
  }
}

BOOL VCVideoReceiverDecodedFrame_Create(const __CFAllocator *a1, _QWORD *a2, const void *a3, __CVBuffer *a4, __int128 *a5, __int128 *a6)
{
  _QWORD *v12;
  _QWORD *v13;
  CFTypeRef v14;
  CFTypeRef v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  _BOOL8 result;

  v12 = CFAllocatorAllocate(a1, 104, 0);
  v13 = v12;
  if (v12)
  {
    v12[12] = 0;
    *((_OWORD *)v12 + 4) = 0u;
    *((_OWORD *)v12 + 5) = 0u;
    *((_OWORD *)v12 + 2) = 0u;
    *((_OWORD *)v12 + 3) = 0u;
    *(_OWORD *)v12 = 0u;
    *((_OWORD *)v12 + 1) = 0u;
    if (a1)
      v14 = CFRetain(a1);
    else
      v14 = 0;
    *v13 = v14;
    v13[2] = a4;
    CVPixelBufferRetain(a4);
    if (a3)
      v15 = CFRetain(a3);
    else
      v15 = 0;
    v13[1] = v15;
    v16 = *a5;
    v17 = a5[1];
    v18 = a5[2];
    v13[9] = *((_QWORD *)a5 + 6);
    *(_OWORD *)(v13 + 7) = v18;
    *(_OWORD *)(v13 + 5) = v17;
    *(_OWORD *)(v13 + 3) = v16;
    v19 = *a6;
    v13[12] = *((_QWORD *)a6 + 2);
    *((_OWORD *)v13 + 5) = v19;
  }
  result = v13 != 0;
  *a2 = v13;
  return result;
}

void _VCStreamInputAudio_SampleBufferHandler(uint64_t a1, opaqueCMSampleBuffer *a2)
{
  void (*v4)(_QWORD, opaqueCMSampleBuffer *);

  VCStreamInput_UpdateReportingStats(a1, a2);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 312));
  v4 = *(void (**)(_QWORD, opaqueCMSampleBuffer *))(a1 + 296);
  if (v4)
    v4(*(_QWORD *)(a1 + 304), a2);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 312));
}

void VCTerminateProcess_HandleAutoBugCapture(const void *a1)
{
  __CFDictionary *Mutable;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CFDictionarySetValue(Mutable, CFSTR("SymptomReporterOptionalKeyTerminationSource"), a1);
  CFDictionarySetValue(Mutable, CFSTR("SymptomReporterOptionalIsLocalSideOnly"), (const void *)*MEMORY[0x1E0C9AE50]);
  reportingSymptom();
  if (Mutable)
    CFRelease(Mutable);
}

void VCTerminateProcess(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v6;
  void *v7;
  int Diagnostics;
  uint64_t v9;
  NSObject *v10;
  const char *v11;
  uint8_t buf[4];
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  void *v19;
  __int16 v20;
  const char *v21;
  _BYTE buffer[3];
  _BYTE v23[1029];

  *(_QWORD *)&v23[1021] = *MEMORY[0x1E0C80C00];
  v6 = getpid();
  bzero(v23, 0x3FDuLL);
  memset(buffer, 63, sizeof(buffer));
  proc_name(v6, buffer, 0x400u);
  v7 = (void *)objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("Terminating %s (PID=%d) terminateSource=%@ reason=%@"), buffer, v6, a2, a1);
  Diagnostics = VCUtil_GenerateDiagnostics(1, 1, (const char *)objc_msgSend(v7, "UTF8String"), 7u);
  if (a3)
    VCTerminateProcess_HandleAutoBugCapture(a2);
  if ((int)VRTraceGetErrorLogLevelForModule() < 3
    || (v9 = VRTraceErrorLogLevelToCSTR(),
        v10 = *MEMORY[0x1E0CF2758],
        !os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR)))
  {
    if ((Diagnostics & 1) != 0)
      return;
    goto LABEL_6;
  }
  v11 = " -- ##### Skipping terminate due to concurrent termination requests";
  *(_DWORD *)buf = 136316162;
  if (!Diagnostics)
    v11 = "";
  v13 = v9;
  v14 = 2080;
  v15 = "VCTerminateProcess";
  v16 = 1024;
  v17 = 37;
  v18 = 2112;
  v19 = v7;
  v20 = 2080;
  v21 = v11;
  _os_log_error_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_ERROR, " [%s] %s:%d ##### %@%s", buf, 0x30u);
  if ((Diagnostics & 1) == 0)
  {
LABEL_6:
    MEMORY[0x720] = 1;
    kill(v6, 11);
  }
}

void VCAudioSessionAVAS_ScheduleNetworkUplinkClockUpdate(uint64_t a1)
{
  NSObject *v1;
  _QWORD v2[6];

  v2[5] = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v1 = *(NSObject **)(a1 + 176);
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 3221225472;
    v2[2] = __VCAudioSessionAVAS_ScheduleNetworkUplinkClockUpdate_block_invoke;
    v2[3] = &unk_1E9E521C0;
    v2[4] = a1;
    dispatch_async(v1, v2);
  }
}

uint64_t OUTLINED_FUNCTION_2_9@<X0>(void *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  *(_QWORD *)(v2 - 24) = a2;
  return objc_msgSend(a1, "className");
}

uint64_t VCTimescalePSOLA_PeakDetection(uint64_t result, __int16 a2, int a3, int a4, __int16 *a5, _WORD *a6)
{
  uint64_t v9;
  __int16 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  BOOL v16;
  __int16 v17;
  int v18;
  int v19;
  int v20;
  __int16 *v21;
  __int16 v22;
  __int16 v23;
  __int16 v25;

  if (a3 >= 1)
  {
    v9 = result;
    v10 = 0;
    v11 = 0;
    v12 = (unsigned __int16)a3;
    v13 = (unsigned __int16)a3 - 1;
    v25 = a3 == 1;
    v23 = 2 * a4;
    do
    {
      a2 += v25;
      result = VCTimescalePSOLA_MaxIndexW16(v9, (__int16)(a2 - 1));
      *a5 = result;
      v14 = (((_DWORD)result << 16) + 0x20000) >> 16;
      if (v14 >= (__int16)(a2 - 1))
        LOWORD(v14) = a2 - 1;
      if (v13)
      {
        v11 = ((((_DWORD)result << 16) - 0x20000) >> 16) & ~((((_DWORD)result << 16) - 0x20000) >> 31);
        v10 = v14;
      }
      v15 = a2 - 2;
      if ((_WORD)result)
        v16 = v15 == (__int16)result;
      else
        v16 = 1;
      if (v16)
      {
        v17 = *(_WORD *)(v9 + 2 * (__int16)result);
        if (v15 != (__int16)result)
        {
          *a6 = v17;
          v22 = v23 * *a5;
          goto LABEL_21;
        }
        *(_WORD *)(v9 + 2 * (__int16)result + 2) = v17;
        v18 = *a5;
        v19 = *(__int16 *)(v9 + 2 * *a5);
        v20 = *(__int16 *)(v9 + 2 * (v18 + 1));
        if (v19 <= v20)
        {
          *a6 = (v20 + v19) >> 1;
          v22 = ((2 * *a5) | 1) * a4;
LABEL_21:
          *a5 = v22;
          if (!v13)
            goto LABEL_17;
LABEL_16:
          result = (uint64_t)VCTimescalePSOLA_MemSetW16((_WORD *)(v9 + 2 * v11), 0, v10 - (unsigned __int16)v11 + 1);
          goto LABEL_17;
        }
        v21 = (__int16 *)(v9 + 2 * (v18 - 1));
      }
      else
      {
        v21 = (__int16 *)(v9 + 2 * (__int16)result - 2);
      }
      result = (uint64_t)VCTimescalePSOLA_PrblFit(v21, a5, a6, a4);
      if (v13)
        goto LABEL_16;
LABEL_17:
      --v13;
      ++a6;
      ++a5;
      --v12;
    }
    while (v12);
  }
  return result;
}

__int16 *VCTimescalePSOLA_PrblFit(__int16 *result, _WORD *a2, _WORD *a3, int a4)
{
  char *v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  unsigned __int16 *v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  __int16 v19;
  int v20;
  __int16 *v21;
  __int16 v22;
  __int16 *v23;
  _OWORD v24[2];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  memset(v24, 170, 26);
  switch(a4)
  {
    case 4:
      v4 = (char *)&v24[1];
      v24[0] = xmmword_1D910F430;
      break;
    case 2:
      v4 = (char *)v24 + 8;
      *(_QWORD *)&v24[0] = 0xC000800040000;
      break;
    case 1:
      v4 = (char *)v24 + 4;
      LODWORD(v24[0]) = 0x80000;
      break;
    default:
      v4 = (char *)&v24[1] + 8;
      v24[0] = xmmword_1D910F440;
      *(_QWORD *)&v24[1] = 0xF000D000C000BLL;
      break;
  }
  *(_WORD *)v4 = 16;
  v5 = *result;
  v6 = result[1];
  v7 = result[2];
  v8 = -3 * v5 + 4 * v6 - v7;
  v9 = v5 - 2 * v6 + v7;
  v10 = 120 * v8;
  v11 = (unsigned __int16 *)v24 + a4;
  v12 = VCTimescalePSOLA_PrblCf[3 * *v11];
  v13 = VCTimescalePSOLA_PrblCf[3 * *(v11 - 1)];
  v14 = v12 - v13;
  v15 = v13 + v12;
  v16 = -v9;
  v17 = v15 >> 1;
  if (120 * v8 >= -(v9 * (v15 >> 1)))
  {
    if (v10 <= (v17 + (__int16)v14) * v16)
    {
      *a3 = v6;
      v22 = 2 * a4 * *a2;
    }
    else
    {
      v19 = v17 + 2 * v14;
      LOWORD(v20) = 1;
      while ((unsigned __int16)v20 != (unsigned __int16)a4 && v10 >= v19 * v16)
      {
        v20 = (unsigned __int16)v20 + 1;
        v19 += v14;
        if ((v20 & 0x10000) != 0)
          return result;
      }
      v23 = &VCTimescalePSOLA_PrblCf[3 * *((unsigned __int16 *)v24 + a4 + (__int16)v20)];
      *a3 = *result + ((v9 * v23[1] + v8 * v23[2]) >> 8);
      v22 = v20 + 2 * a4 * *a2;
    }
  }
  else
  {
    LOWORD(v18) = 1;
    while ((unsigned __int16)v18 != (unsigned __int16)a4)
    {
      v17 -= v14;
      if (v10 > (__int16)v17 * v16)
        break;
      v18 = (unsigned __int16)v18 + 1;
      if ((v18 & 0x10000) != 0)
        return result;
    }
    v21 = &VCTimescalePSOLA_PrblCf[3 * *((unsigned __int16 *)v24 + a4 - (__int16)v18)];
    *a3 = *result + ((v9 * v21[1] + v8 * v21[2]) >> 8);
    v22 = 2 * a4 * *a2 - v18;
  }
  *a2 = v22;
  return result;
}

uint64_t VCAudioSession_InterruptionListenerCallback(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  NSObject *v9;
  int v11;
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v8 = VRTraceErrorLogLevelToCSTR();
    v9 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v11 = 136315650;
      v12 = v8;
      v13 = 2080;
      v14 = "VCAudioSession_InterruptionListenerCallback";
      v15 = 1024;
      v16 = 447;
      _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Received notification that interruption information has changed", (uint8_t *)&v11, 0x1Cu);
    }
  }
  return objc_msgSend(a2, "handleAudioInterruption:interruptionInfo:", a4, a5);
}

uint64_t VCAudioSession_AvailableSampleRateChangeListenerCallback(uint64_t a1, void *a2)
{
  uint64_t v3;
  NSObject *v4;
  int v6;
  uint64_t v7;
  __int16 v8;
  const char *v9;
  __int16 v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v3 = VRTraceErrorLogLevelToCSTR();
    v4 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v6 = 136315650;
      v7 = v3;
      v8 = 2080;
      v9 = "VCAudioSession_AvailableSampleRateChangeListenerCallback";
      v10 = 1024;
      v11 = 455;
      _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Received notification that Sample Rate has changed", (uint8_t *)&v6, 0x1Cu);
    }
  }
  objc_msgSend(a2, "didAvailableSampleRateChange");
  return objc_msgSend(a2, "setBlockSizeOnSampleRateChange");
}

uint64_t VCAudioSession_ActiveAudioRouteDidChange(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;
  NSObject *v8;
  int v10;
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v7 = VRTraceErrorLogLevelToCSTR();
    v8 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v10 = 136315650;
      v11 = v7;
      v12 = 2080;
      v13 = "VCAudioSession_ActiveAudioRouteDidChange";
      v14 = 1024;
      v15 = 462;
      _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Received route notification change", (uint8_t *)&v10, 0x1Cu);
    }
  }
  return objc_msgSend(a2, "didAudioRouteChangeWithUserInfo:", a5);
}

uint64_t VCAudioSessionCMS_SessionReference()
{
  id v0;

  v0 = +[VCAudioSession sharedVoiceChatInstance](VCAudioSession, "sharedVoiceChatInstance");
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    return objc_msgSend(v0, "cmSession");
  else
    return 0;
}

void *receiveProc(void *a1)
{
  void *v2;
  void *v3;
  unsigned int v4;
  int ErrorLogLevelForModule;
  os_log_t *v6;
  uint64_t v7;
  NSObject *v8;
  int v9;
  double v10;
  void *v11;
  void *v12;
  __int128 v13;
  double v14;
  __objc2_class_ro **p_info;
  int v16;
  int v17;
  int v18;
  double v19;
  int v20;
  uint64_t v21;
  NSObject *v22;
  NSObject *v23;
  unsigned int v24;
  unsigned int v25;
  void *v26;
  void *v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  NSObject *v31;
  NSObject *v32;
  uint64_t v33;
  NSObject *v34;
  uint64_t v35;
  NSObject *v36;
  void *v37;
  uint64_t v38;
  NSObject *v39;
  uint64_t v41;
  NSObject *v42;
  const char *v43;
  uint64_t v44;
  int v45;
  int v46;
  uint64_t v47;
  os_log_t v48;
  const char *v49;
  NSObject *v50;
  uint32_t v51;
  uint64_t v52;
  os_log_t v53;
  unsigned int v54;
  __int128 v55;
  uint64_t v56;
  _QWORD *v57;
  unint64_t v58;
  unint64_t v59;
  uint8_t v60[4];
  uint64_t v61;
  __int16 v62;
  const char *v63;
  __int16 v64;
  int v65;
  __int16 v66;
  unsigned int v67;
  __int16 v68;
  unsigned int v69;
  __int16 v70;
  unsigned int v71;
  uint8_t buf[48];
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  uint64_t v78;

  v78 = *MEMORY[0x1E0C80C00];
  v58 = 0xAAAAAAAAAAAAAAAALL;
  v59 = 0xAAAAAAAAAAAAAAAALL;
  v2 = (void *)MEMORY[0x1DF088A10]();
  v3 = (void *)objc_msgSend(a1, "strong");
  v4 = objc_msgSend(v3, "transportSessionID");
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  v6 = (os_log_t *)MEMORY[0x1E0CF2758];
  if (ErrorLogLevelForModule >= 6)
  {
    v7 = VRTraceErrorLogLevelToCSTR();
    v8 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = v7;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "receiveProc";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 70;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = v4;
      _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d control channel starts listening for sessionID='%d'", buf, 0x22u);
    }
  }
  v9 = objc_msgSend(v3, "isRunning");
  objc_autoreleasePoolPop(v2);
  if (!v9)
    return a1;
  pthread_setname_np("com.apple.vccontrolchannel.receiveproc");
  v10 = micro();
  memset(buf, 0, sizeof(buf));
  v73 = 0u;
  v74 = 0u;
  v75 = 0u;
  v76 = 0u;
  v77 = 0u;
  v11 = (void *)MEMORY[0x1DF088A10]();
  v12 = (void *)objc_msgSend(a1, "strong");
  if (!objc_msgSend(v12, "isRunning"))
  {
LABEL_51:
    v37 = v11;
LABEL_52:
    objc_autoreleasePoolPop(v37);
    goto LABEL_53;
  }
  v14 = v10 + 30.0;
  p_info = VCCaptionsReceiver.info;
  *(_QWORD *)&v13 = 136315650;
  v55 = v13;
  while (1)
  {
    v16 = objc_msgSend(v12, "vfdMessage", v55);
    v17 = objc_msgSend(v12, "vfdCancel");
    objc_autoreleasePoolPop(v11);
    if (v16 == -1)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 6)
        goto LABEL_53;
      v41 = VRTraceErrorLogLevelToCSTR();
      v42 = *v6;
      if (!os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
        goto LABEL_53;
      *(_DWORD *)v60 = 136316162;
      v61 = v41;
      v62 = 2080;
      v63 = "receiveProc";
      v64 = 1024;
      v65 = 93;
      v66 = 1024;
      v67 = -1;
      v68 = 1024;
      v69 = v4;
      v43 = " [%s] %s:%d receiveProc: vfdMessage='%d', exiting receiveProc for sessionID='%d'";
      goto LABEL_63;
    }
    if (v17 == -1)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 6)
        goto LABEL_53;
      v44 = VRTraceErrorLogLevelToCSTR();
      v42 = *v6;
      if (!os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
        goto LABEL_53;
      *(_DWORD *)v60 = 136316162;
      v61 = v44;
      v62 = 2080;
      v63 = "receiveProc";
      v64 = 1024;
      v65 = 97;
      v66 = 1024;
      v67 = -1;
      v68 = 1024;
      v69 = v4;
      v43 = " [%s] %s:%d receiveProc: vfdCancel='%d', exiting receiveProc for sessionID='%d'";
LABEL_63:
      _os_log_impl(&dword_1D8A54000, v42, OS_LOG_TYPE_DEFAULT, v43, v60, 0x28u);
      goto LABEL_53;
    }
    if (__darwin_check_fd_set_overflow(v17, buf, 0))
      *(_DWORD *)&buf[((unint64_t)v17 >> 3) & 0x1FFFFFFFFFFFFFFCLL] |= 1 << v17;
    if (__darwin_check_fd_set_overflow(v16, buf, 0))
      *(_DWORD *)&buf[((unint64_t)v16 >> 3) & 0x1FFFFFFFFFFFFFFCLL] |= 1 << v16;
    if (v16 <= v17)
      v18 = v17;
    else
      v18 = v16;
    v19 = v14 - micro();
    if (v19 <= 0.0)
      v14 = micro() + 30.0;
    v58 = (int)v19;
    LODWORD(v59) = (int)((v19 - (double)(int)v19) * 1000000.0);
    v20 = VTP_Select((v18 + 1), (__int128 *)buf, 0, 0, (uint64_t)&v58);
    if (!v20)
    {
      v14 = micro() + 30.0;
      goto LABEL_46;
    }
    if (v20 == -1)
    {
      if (*__error() != 9)
      {
        v45 = *__error();
        v46 = VRTraceGetErrorLogLevelForModule();
        if (v46 >= 3)
        {
          v47 = VRTraceErrorLogLevelToCSTR();
          v48 = *v6;
          if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)v60 = 136316162;
            v61 = v47;
            v62 = 2080;
            v63 = "receiveProc";
            v64 = 1024;
            v65 = 123;
            v66 = 1024;
            v67 = v45 | 0xC00F0000;
            v68 = 1024;
            v69 = v4;
            v49 = " [%s] %s:%d select failed(%08X) for sessionID='%d'";
            v50 = v48;
            v51 = 40;
            goto LABEL_70;
          }
        }
        goto LABEL_53;
      }
      goto LABEL_46;
    }
    if (!__darwin_check_fd_set_overflow(v16, buf, 0)
      || ((*(_DWORD *)&buf[((unint64_t)v16 >> 3) & 0x1FFFFFFFFFFFFFFCLL] >> v16) & 1) == 0)
    {
      goto LABEL_46;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v21 = VRTraceErrorLogLevelToCSTR();
      v22 = *v6;
      v23 = *v6;
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v60 = 136315906;
          v61 = v21;
          v62 = 2080;
          v63 = "receiveProc";
          v64 = 1024;
          v65 = 132;
          v66 = 1024;
          v67 = v4;
          _os_log_impl(&dword_1D8A54000, v22, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d from sessionID='%d'", v60, 0x22u);
        }
      }
      else if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)v60 = 136315906;
        v61 = v21;
        v62 = 2080;
        v63 = "receiveProc";
        v64 = 1024;
        v65 = 132;
        v66 = 1024;
        v67 = v4;
        _os_log_debug_impl(&dword_1D8A54000, v22, OS_LOG_TYPE_DEBUG, " [%s] %s:%d from sessionID='%d'", v60, 0x22u);
      }
    }
    v57 = 0;
    v24 = VTP_Recvfrom(v16, &v57);
    if ((v24 & 0x80000000) != 0)
      break;
    if (!v57[64])
    {
      VTP_ReleasePacket((void **)&v57);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v33 = VRTraceErrorLogLevelToCSTR();
        v34 = *v6;
        if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)v60 = 136316162;
          v61 = v33;
          v62 = 2080;
          v63 = "receiveProc";
          v64 = 1024;
          v65 = 142;
          v66 = 1024;
          v67 = v16;
          v68 = 1024;
          v69 = v4;
          _os_log_error_impl(&dword_1D8A54000, v34, OS_LOG_TYPE_ERROR, " [%s] %s:%d VTP_Recvfrom(%d) returned 0: empty message for sessionID='%d'", v60, 0x28u);
        }
      }
      goto LABEL_46;
    }
    v25 = v24;
    v26 = (void *)MEMORY[0x1DF088A10]();
    v27 = (void *)objc_msgSend(a1, "strong");
    if (!objc_msgSend(v27, "isRunning"))
    {
      VTP_ReleasePacket((void **)&v57);
      v37 = v26;
      goto LABEL_52;
    }
    objc_msgSend(v27, "addToReceivedStats:", *((unsigned int *)v57 + 128));
    v56 = 0;
    v28 = objc_msgSend(p_info + 131, "allocPayoadDataFromVTPPacket:vpktFlags:channelDataFormat:", v57 + 63, v57 + 23, &v56);
    if (v28)
    {
      v29 = (void *)v28;
      objc_msgSend(v27, "messageReceived:participantInfo:", v28, v56);

    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v35 = VRTraceErrorLogLevelToCSTR();
      v36 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v60 = v55;
        v61 = v35;
        v62 = 2080;
        v63 = "receiveProc";
        v64 = 1024;
        v65 = 157;
        _os_log_error_impl(&dword_1D8A54000, v36, OS_LOG_TYPE_ERROR, " [%s] %s:%d Could not parse raw input data", v60, 0x1Cu);
      }
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v30 = VRTraceErrorLogLevelToCSTR();
      v31 = *v6;
      v32 = *v6;
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v60 = 136316162;
          v61 = v30;
          v62 = 2080;
          v63 = "receiveProc";
          v64 = 1024;
          v65 = 161;
          v66 = 1024;
          v67 = v4;
          v68 = 1024;
          v69 = v25;
          _os_log_impl(&dword_1D8A54000, v31, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCControlChannelMultiWay: receiveProc for MW control channel parsed message for sessionID='%d', status='%d", v60, 0x28u);
        }
      }
      else if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)v60 = 136316162;
        v61 = v30;
        v62 = 2080;
        v63 = "receiveProc";
        v64 = 1024;
        v65 = 161;
        v66 = 1024;
        v67 = v4;
        v68 = 1024;
        v69 = v25;
        _os_log_debug_impl(&dword_1D8A54000, v31, OS_LOG_TYPE_DEBUG, " [%s] %s:%d VCControlChannelMultiWay: receiveProc for MW control channel parsed message for sessionID='%d', status='%d", v60, 0x28u);
      }
    }
    objc_autoreleasePoolPop(v26);
    VTP_ReleasePacket((void **)&v57);
    p_info = (__objc2_class_ro **)(VCCaptionsReceiver + 32);
LABEL_46:
    v76 = 0u;
    v77 = 0u;
    v74 = 0u;
    v75 = 0u;
    v73 = 0u;
    memset(buf, 0, sizeof(buf));
    v11 = (void *)MEMORY[0x1DF088A10]();
    v12 = (void *)objc_msgSend(a1, "strong");
    if ((objc_msgSend(v12, "isRunning") & 1) == 0)
      goto LABEL_51;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v52 = VRTraceErrorLogLevelToCSTR();
    v53 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
    {
      v54 = *__error() | 0xC00F0000;
      *(_DWORD *)v60 = 136316418;
      v61 = v52;
      v62 = 2080;
      v63 = "receiveProc";
      v64 = 1024;
      v65 = 137;
      v66 = 1024;
      v67 = v16;
      v68 = 1024;
      v69 = v54;
      v70 = 1024;
      v71 = v4;
      v49 = " [%s] %s:%d VTP_Recvfrom(%d) failed(%08X) for sessionID='%d'";
      v50 = v53;
      v51 = 46;
LABEL_70:
      _os_log_error_impl(&dword_1D8A54000, v50, OS_LOG_TYPE_ERROR, v49, v60, v51);
    }
  }
LABEL_53:
  if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
  {
    v38 = VRTraceErrorLogLevelToCSTR();
    v39 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v60 = 136315906;
      v61 = v38;
      v62 = 2080;
      v63 = "receiveProc";
      v64 = 1024;
      v65 = 167;
      v66 = 1024;
      v67 = v4;
      _os_log_impl(&dword_1D8A54000, v39, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d control channel receiveProc ended for sessionID='%d'", v60, 0x22u);
    }
  }
  return a1;
}

void sub_1D8E5DA30(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1D8E5DBD4(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1D8E5E6F8(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void sub_1D8E5EDA4(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1D8E600FC(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void sub_1D8E60460(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1D8E607A0(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1D8E60F84(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1D8E611C4(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t VCTransportStreamGetClassID()
{
  if (VCTransportStreamGetClassID_onceToken != -1)
    dispatch_once(&VCTransportStreamGetClassID_onceToken, &__block_literal_global_72);
  return VCTransportStreamGetClassID_classID;
}

CFStringRef _VCTransportStreamCopyFormattingDescription(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[VCTransportStream %p]"), a1);
}

uint64_t VCTransportStreamCommonInitialize(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)a1 = a3;
  *(_DWORD *)(a1 + 8) = 1;
  *(_BYTE *)(a1 + 12) = 0;
  if (a2)
  {
    FigCFDictionaryGetBooleanIfPresent();
    *(_BYTE *)(a1 + 12) = 0;
  }
  return 0;
}

void VCTransportStreamCommonFinalize(uint64_t *a1)
{
  uint64_t v2;
  void (*v3)(uint64_t);
  const void *v4;
  const void *v5;
  NSObject *v6;
  const void *v7;

  if (*((_DWORD *)a1 + 2) == 2)
  {
    v2 = *a1;
    v3 = *(void (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 64);
    if (v3)
      v3(v2);
  }
  v4 = (const void *)a1[4];
  if (v4)
    _Block_release(v4);
  v5 = (const void *)a1[2];
  if (v5)
    _Block_release(v5);
  v6 = a1[3];
  if (v6)
    dispatch_release(v6);
  v7 = (const void *)a1[5];
  if (v7)
    CFRelease(v7);
}

uint64_t VCTransportStreamCommonCopyProperty(uint64_t a1, CFTypeRef cf1, uint64_t a3, const void **a4)
{
  const void **v6;
  const void *v7;
  uint64_t v8;

  if (CFEqual(cf1, CFSTR("IsReceiveExternallyScheduled")))
  {
    if (*(_BYTE *)(a1 + 12))
      v6 = (const void **)MEMORY[0x1E0C9AE50];
    else
      v6 = (const void **)MEMORY[0x1E0C9AE40];
    v7 = *v6;
    *a4 = *v6;
    CFRetain(v7);
    return 0;
  }
  else
  {
    v8 = 2150760464;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCTransportStreamCommonCopyProperty_cold_1();
    }
  }
  return v8;
}

uint64_t VCTransportStreamCommonSetSendFailedHandler(uint64_t a1, void *aBlock, dispatch_object_t object)
{
  NSObject *v6;
  const void *v7;
  void *v8;
  uint64_t v9;

  if (aBlock)
  {
    if (*(_DWORD *)(a1 + 8) == 1)
    {
      v6 = *(NSObject **)(a1 + 24);
      if (v6)
      {
        dispatch_release(v6);
        *(_QWORD *)(a1 + 24) = 0;
      }
      if (object)
      {
        dispatch_retain(object);
        *(_QWORD *)(a1 + 24) = object;
      }
      v7 = *(const void **)(a1 + 16);
      if (v7)
        _Block_release(v7);
      v8 = _Block_copy(aBlock);
      v9 = 0;
      *(_QWORD *)(a1 + 16) = v8;
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() < 3)
    {
      return 2150760509;
    }
    else
    {
      VRTraceErrorLogLevelToCSTR();
      v9 = 2150760509;
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCTransportStreamCommonSetSendFailedHandler_cold_2();
    }
  }
  else
  {
    v9 = 2150760449;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCTransportStreamCommonSetSendFailedHandler_cold_1();
    }
  }
  return v9;
}

uint64_t VCTransportStreamCommonSetReceivedHandler(uint64_t a1, void *aBlock)
{
  const void *v4;
  void *v5;
  uint64_t v6;

  if (aBlock)
  {
    if (*(_DWORD *)(a1 + 8) == 1)
    {
      v4 = *(const void **)(a1 + 32);
      if (v4)
        _Block_release(v4);
      v5 = _Block_copy(aBlock);
      v6 = 0;
      *(_QWORD *)(a1 + 32) = v5;
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() < 3)
    {
      return 2150760509;
    }
    else
    {
      VRTraceErrorLogLevelToCSTR();
      v6 = 2150760509;
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCTransportStreamCommonSetReceivedHandler_cold_2();
    }
  }
  else
  {
    v6 = 2150760449;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCTransportStreamCommonSetReceivedHandler_cold_1();
    }
  }
  return v6;
}

void VCBlockBuffer_Copy(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;

  if (a2)
  {
    if (*(_QWORD *)a2)
    {
      CFRelease(*(CFTypeRef *)a2);
      *(_QWORD *)a2 = 0;
    }
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    if (a1)
    {
      v4 = *(_QWORD *)(a1 + 16);
      *(_OWORD *)a2 = *(_OWORD *)a1;
      *(_QWORD *)(a2 + 16) = v4;
      if (*(_QWORD *)a2)
        CFRetain(*(CFTypeRef *)a2);
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v5 = VRTraceErrorLogLevelToCSTR();
    v6 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCBlockBuffer_Copy_cold_1(v5, v6);
  }
}

void VCBlockBuffer_Clear(uint64_t a1)
{
  const void *v2;

  if (a1)
  {
    v2 = *(const void **)a1;
    if (v2)
    {
      CFRelease(v2);
      *(_QWORD *)a1 = 0;
    }
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
  }
}

uint64_t _VCCannedVideoCaptureSource_ProducerThread(uint64_t a1)
{
  uint64_t v2;
  pthread_mutex_t *v3;
  int v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  NSObject *v14;
  uint8_t buf[4];
  uint64_t v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v2 = a1 + 168;
  v3 = (pthread_mutex_t *)(a1 + 264);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 264));
  while (!*(_BYTE *)(v2 + 88))
  {
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 336));
    v5 = 0;
    v6 = *(_DWORD *)(v2 + 408);
    v7 = *(_QWORD *)(v2 + 400);
    while (1)
    {
      v8 = v6 + v5 <= 0 ? -(-(v6 + v5) & 0xF) : (v6 + v5) & 0xF;
      if (!*(_QWORD *)(v7 + 16 * v8 + 8))
      {
        v9 = *(unsigned int *)(v7 + 16 * v8);
        if ((_DWORD)v9 != -1)
          break;
      }
      if (++v5 == 16)
      {
        pthread_mutex_unlock((pthread_mutex_t *)(v2 + 336));
        pthread_cond_wait((pthread_cond_t *)(v2 + 160), v3);
        goto LABEL_11;
      }
    }
    pthread_mutex_unlock((pthread_mutex_t *)(v2 + 336));
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 336));
    v10 = 0;
    v11 = *(_DWORD *)(v2 + 408);
    do
    {
      if (v11 + v10 <= 0)
        v12 = -(-(v11 + v10) & 0xF);
      else
        v12 = (v11 + v10) & 0xF;
      if (*(_DWORD *)(*(_QWORD *)(v2 + 400) + 16 * v12) == (_DWORD)v9)
      {
        *(_QWORD *)(*(_QWORD *)(v2 + 400) + 16 * v12 + 8) = objc_msgSend(*(id *)(a1 + 592), "createPixelBufferForFrameIndex:", v9);
        pthread_mutex_unlock((pthread_mutex_t *)(v2 + 336));
        goto LABEL_11;
      }
      ++v10;
    }
    while (v10 != 16);
    pthread_mutex_unlock((pthread_mutex_t *)(v2 + 336));
    if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      v13 = VRTraceErrorLogLevelToCSTR();
      v14 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        v16 = v13;
        v17 = 2080;
        v18 = "_VCCannedVideoCaptureSource_WriteToRingBuffer";
        v19 = 1024;
        v20 = 298;
        v21 = 1024;
        v22 = v9;
        _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d PixelBuffer became obsolete - frame index %d changed?", buf, 0x22u);
      }
    }
LABEL_11:
    ;
  }
  pthread_mutex_unlock(v3);
  return 0;
}

uint64_t _VCCannedVideoCaptureSource_ConsumerThread(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  pthread_mutex_t *v3;
  id v4;
  int v6;
  pthread_cond_t *v7;
  int v8;
  int v9;
  int tv_usec;
  __darwin_time_t tv_sec;
  __darwin_time_t v13;
  unsigned int v14;
  int v15;
  unsigned int v16;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  BOOL v23;
  int v24;
  int v25;
  pthread_mutex_t *v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  uint64_t v35;
  __CVBuffer *v36;
  uint64_t v37;
  NSObject *v38;
  uint64_t v39;
  NSObject *queue;
  pthread_mutex_t *v41;
  int v42;
  _QWORD block[6];
  CMTime v44;
  unsigned int v45;
  CMTime v46;
  int v47;
  double v48;
  CMTime v49;
  timeval v50;
  _BYTE v51[22];
  __int16 v52;
  int v53;
  __int16 v54;
  unsigned int v55;
  uint64_t v56;

  v1 = a1;
  v56 = *MEMORY[0x1E0C80C00];
  v2 = a1 + 168;
  queue = *(NSObject **)(a1 + 584);
  v3 = (pthread_mutex_t *)(a1 + 392);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 392));
  v50.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v50.tv_usec = 0xAAAAAAAAAAAAAAAALL;
  gettimeofday(&v50, 0);
  memset(&v49, 170, sizeof(v49));
  CMClockGetTime(&v49, *(CMClockRef *)(v2 + 72));
  v4 = +[VCCannedAVSync sharedCannedAVSync](VCCannedAVSync, "sharedCannedAVSync");
  VCCannedAVSync_SetBase((uint64_t)v4, (double)v49.value / (double)v49.timescale);
  if (!*(_BYTE *)(v2 + 216))
  {
    v6 = 0;
    v7 = (pthread_cond_t *)(v2 + 288);
    v41 = (pthread_mutex_t *)(v2 + 336);
    v8 = -1;
    v39 = v1;
    while (1)
    {
      v9 = atomic_load((unsigned int *)(v2 + 64));
      if (v9 && v9 != v6)
        break;
      if (v9)
        goto LABEL_10;
LABEL_44:
      if (*(_BYTE *)(v2 + 216))
        goto LABEL_2;
    }
    setRealTimeConstraints(1.0 / (double)v9);
    v6 = v9;
LABEL_10:
    memset(v51, 170, 16);
    gettimeofday((timeval *)v51, 0);
    tv_usec = v50.tv_usec;
    tv_sec = v50.tv_sec;
    v13 = v50.tv_sec;
    do
    {
      while (1)
      {
        tv_usec += 0xF4240uLL / v9;
        if (tv_usec > 999999)
        {
          tv_sec = ++v13;
          tv_usec -= 1000000;
        }
        if (v13 == *(_QWORD *)v51)
          break;
        if (v13 >= *(uint64_t *)v51)
          goto LABEL_17;
      }
    }
    while (tv_usec < *(int *)&v51[8]);
    v13 = *(_QWORD *)v51;
LABEL_17:
    v50.tv_sec = tv_sec;
    v50.tv_usec = tv_usec;
    v46.value = v13;
    *(_QWORD *)&v46.timescale = 1000 * tv_usec;
    if (pthread_cond_timedwait(v7, v3, (const timespec *)&v46) == 60)
    {
      v42 = v6;
      v48 = NAN;
      v47 = -1431655766;
      objc_msgSend(*(id *)(v1 + 592), "getFrameRate:frameCount:", &v48, &v47);
      memset(&v46, 170, sizeof(v46));
      CMClockGetTime(&v46, *(CMClockRef *)(v2 + 72));
      v14 = vcvtmd_s64_f64(VCCannedAVSync_ClampForTime((uint64_t)+[VCCannedAVSync sharedCannedAVSync](VCCannedAVSync, "sharedCannedAVSync"), (double)v46.value / (double)v46.timescale)* (double)(int)v48);
      if (v8 != v14)
      {
        v15 = v47;
        pthread_mutex_lock(v41);
        v16 = 0;
        v17 = *(_QWORD *)(v2 + 400);
        v18 = *(_DWORD *)(v2 + 408);
        do
        {
          v19 = v18;
          if (*(_DWORD *)(v17 + 16 * v18) == v14)
          {
            v20 = v17 + 16 * v18;
            v21 = *(_QWORD *)(v20 + 8);
            *(_QWORD *)(v20 + 8) = 0;
          }
          else
          {
            v21 = 0;
          }
          v22 = v19 + 1;
          v24 = -(v19 + 1);
          v23 = v24 < 0;
          v25 = v24 & 0xF;
          v18 = v22 & 0xF;
          if (!v23)
            v18 = -v25;
          if (v21)
            break;
        }
        while (v16++ < 0xF);
        v27 = v3;
        v28 = 0;
        *(_DWORD *)(v2 + 408) = v18;
        do
        {
          v29 = v28 + *(_DWORD *)(v2 + 408);
          v30 = v29 & 0xF;
          v31 = -v29;
          v23 = v31 < 0;
          v32 = v31 & 0xF;
          if (v23)
            v33 = v30;
          else
            v33 = -v32;
          v34 = (int)(v14 + v28 + 1) % v15;
          if (*(_DWORD *)(v17 + 16 * v33) != v34)
          {
            v35 = v33;
            v36 = *(__CVBuffer **)(v17 + 16 * v33 + 8);
            if (v36)
            {
              CVPixelBufferRelease(v36);
              v17 = *(_QWORD *)(v2 + 400);
              *(_QWORD *)(v17 + 16 * v35 + 8) = 0;
            }
            *(_DWORD *)(v17 + 16 * v35) = v34;
          }
          ++v28;
        }
        while (v28 != 16);
        pthread_mutex_unlock(v41);
        pthread_cond_signal((pthread_cond_t *)(v2 + 160));
        v3 = v27;
        if (v21)
        {
          block[0] = MEMORY[0x1E0C809B0];
          block[1] = 3221225472;
          block[2] = ___VCCannedVideoCaptureSource_ConsumerThread_block_invoke;
          block[3] = &unk_1E9E57378;
          v1 = v39;
          block[4] = v39;
          block[5] = v21;
          v44 = v46;
          v45 = v14;
          dispatch_async(queue, block);
          v8 = v14;
        }
        else
        {
          v1 = v39;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            v37 = VRTraceErrorLogLevelToCSTR();
            v38 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)v51 = 136315906;
              *(_QWORD *)&v51[4] = v37;
              *(_WORD *)&v51[12] = 2080;
              *(_QWORD *)&v51[14] = "_VCCannedVideoCaptureSource_ConsumerThread";
              v52 = 1024;
              v53 = 454;
              v54 = 1024;
              v55 = v14;
              _os_log_error_impl(&dword_1D8A54000, v38, OS_LOG_TYPE_ERROR, " [%s] %s:%d Pixel buffer for frame %d not available", v51, 0x22u);
            }
          }
          v8 = v14;
        }
      }
      v7 = (pthread_cond_t *)(v2 + 288);
      v6 = v42;
    }
    goto LABEL_44;
  }
LABEL_2:
  pthread_mutex_unlock(v3);
  dispatch_sync(queue, &__block_literal_global_73);
  dispatch_release(queue);
  return 0;
}

VTSessionRef VCMediaRecorderUtil_AllocTransferSession()
{
  VTSessionRef session[2];

  session[1] = *(VTSessionRef *)MEMORY[0x1E0C80C00];
  session[0] = (VTSessionRef)0xAAAAAAAAAAAAAAAALL;
  VTPixelTransferSessionCreate(0, (VTPixelTransferSessionRef *)session);
  VTSessionSetProperty(session[0], (CFStringRef)*MEMORY[0x1E0CED848], (CFTypeRef)*MEMORY[0x1E0CEDB48]);
  return session[0];
}

CVPixelBufferRef VCMediaRecorderUtil_CreateResizeFrame(__CVBuffer *a1, OpaqueVTPixelTransferSession *a2, CVPixelBufferPoolRef pixelBufferPool)
{
  CVPixelBufferRef v5;
  CVPixelBufferRef destinationBuffer[2];

  destinationBuffer[1] = *(CVPixelBufferRef *)MEMORY[0x1E0C80C00];
  destinationBuffer[0] = 0;
  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCMediaRecorderUtil_CreateResizeFrame_cold_1();
    }
    goto LABEL_19;
  }
  if (!pixelBufferPool)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCMediaRecorderUtil_CreateResizeFrame_cold_2();
    }
    goto LABEL_19;
  }
  if (CVPixelBufferPoolCreatePixelBuffer((CFAllocatorRef)*MEMORY[0x1E0C9AE00], pixelBufferPool, destinationBuffer))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCMediaRecorderUtil_CreateResizeFrame_cold_4();
    }
    goto LABEL_19;
  }
  if (VTPixelTransferSessionTransferImage(a2, a1, destinationBuffer[0]))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCMediaRecorderUtil_CreateResizeFrame_cold_3();
    }
LABEL_19:
    v5 = 0;
    goto LABEL_6;
  }
  v5 = destinationBuffer[0];
  destinationBuffer[0] = 0;
LABEL_6:
  CVPixelBufferRelease(destinationBuffer[0]);
  return v5;
}

uint64_t VCMediaRecorderUtil_SetupBufferPool(const __CFString *a1, CVPixelBufferPoolRef *a2, double a3, double a4)
{
  uint64_t v7;
  const __CFString *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const __CFDictionary *v12;
  _QWORD v14[4];
  _QWORD v15[4];
  _QWORD v16[2];
  _QWORD v17[3];

  v17[2] = *MEMORY[0x1E0C80C00];
  v7 = *MEMORY[0x1E0CBC048];
  v16[0] = *MEMORY[0x1E0CBC018];
  v16[1] = v7;
  v8 = CFSTR("AVConference:MediaRecorderUtil");
  if (a1)
    v8 = a1;
  v17[0] = MEMORY[0x1E0C9AAB0];
  v17[1] = v8;
  v9 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v17, v16, 2);
  v10 = VCVideoUtil_DefaultCameraCapturePixelFormat();
  v14[0] = *MEMORY[0x1E0CA90E0];
  v15[0] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", a3);
  v14[1] = *MEMORY[0x1E0CA8FD8];
  v15[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", a4);
  v14[2] = *MEMORY[0x1E0CA9040];
  v11 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", v10);
  v14[3] = *MEMORY[0x1E0CA8FF0];
  v15[2] = v11;
  v15[3] = v9;
  v12 = (const __CFDictionary *)objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v15, v14, 4);
  return CVPixelBufferPoolCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v12, a2);
}

__CVPixelBufferPool *VCMediaRecorderUtil_PixelBufferPoolMatchDimensions(__CVPixelBufferPool *result, int a2, int a3)
{
  CFDictionaryRef PixelBufferAttributes;
  void *v6;
  void *v7;

  if (result)
  {
    PixelBufferAttributes = CVPixelBufferPoolGetPixelBufferAttributes(result);
    v6 = (void *)-[__CFDictionary objectForKeyedSubscript:](PixelBufferAttributes, "objectForKeyedSubscript:", *MEMORY[0x1E0CA90E0]);
    v7 = (void *)-[__CFDictionary objectForKeyedSubscript:](PixelBufferAttributes, "objectForKeyedSubscript:", *MEMORY[0x1E0CA8FD8]);
    if (objc_msgSend(v6, "intValue") == a2)
      return (__CVPixelBufferPool *)(objc_msgSend(v7, "intValue") == a3);
    else
      return 0;
  }
  return result;
}

const char *VCMediaRecorderUtil_FilePrefixForMediaType(int a1)
{
  if ((a1 - 1) > 4)
    return "media";
  else
    return off_1E9E57398[(char)(a1 - 1)];
}

CFStringRef VCMediaRecorderUtil_CopyDescriptionForMediaType(const __CFAllocator *a1, unsigned int a2)
{
  const char *v2;

  if (a2 - 1 > 4)
    v2 = "Unknown";
  else
    v2 = off_1E9E573C0[(char)(a2 - 1)];
  return CFStringCreateWithFormat(a1, 0, CFSTR("%s(%hhu)"), v2, a2);
}

CFStringRef VCMediaRecorderUtil_DescriptionForMediaType(unsigned int a1)
{
  CFStringRef v1;
  CFStringRef v2;

  v1 = VCMediaRecorderUtil_CopyDescriptionForMediaType((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a1);
  v2 = v1;
  if (v1)
    CFAutorelease(v1);
  return v2;
}

uint64_t VCMediaRecorderUtil_PrintMediaURL(uint64_t a1, int a2)
{
  int v4;
  void *v5;
  void *v6;
  Float64 Seconds;
  void *v8;
  int ErrorLogLevelForModule;
  uint64_t v10;
  char IsOSFaultDisabled;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  os_log_t *v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  CMTimeValue v24;
  CMTimeEpoch v25;
  uint64_t v26;
  Float64 v27;
  int v28;
  uint64_t v29;
  char v30;
  NSObject *v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  int v35;
  NSObject *v36;
  NSObject *v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  __int128 v43;
  __int128 v44;
  CMTime v45;
  uint64_t v46;
  _BYTE v47[128];
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  CMTime time;
  int v53;
  __int16 v54;
  uint64_t v55;
  __int16 v56;
  _BYTE v57[18];
  __int16 v58;
  int v59;
  __int16 v60;
  Float64 v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  v46 = 0;
  v4 = VCUtil_BinaryPrefix(+[VCFileUtil sizeOfFile:](VCFileUtil, "sizeOfFile:", a1), (double *)&v46);
  v5 = (void *)objc_msgSend(MEMORY[0x1E0C8B3C0], "URLAssetWithURL:options:", a1, 0);
  v6 = v5;
  memset(&v45, 170, sizeof(v45));
  if (v5)
    objc_msgSend(v5, "duration");
  else
    memset(&v45, 0, sizeof(v45));
  time = v45;
  Seconds = CMTimeGetSeconds(&time);
  v8 = (void *)objc_msgSend(v6, "tracks");
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (a2 < 1 || ErrorLogLevelForModule < a2)
    goto LABEL_24;
  v10 = VRTraceErrorLogLevelToCSTR();
  if (a2 > 2)
  {
    if (a2 > 4)
    {
      if (a2 > 7)
      {
        if (a2 != 8)
          goto LABEL_24;
        v15 = *MEMORY[0x1E0CF2758];
        v16 = *MEMORY[0x1E0CF2758];
        if (!*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
          {
            v42 = objc_msgSend(v8, "count");
            LODWORD(time.value) = 136316930;
            *(CMTimeValue *)((char *)&time.value + 4) = v10;
            LOWORD(time.flags) = 2080;
            *(_QWORD *)((char *)&time.flags + 2) = "VCMediaRecorderUtil_PrintMediaURL";
            HIWORD(time.epoch) = 1024;
            v53 = 142;
            v54 = 2112;
            v55 = a1;
            v56 = 2048;
            *(_QWORD *)v57 = v42;
            *(_WORD *)&v57[8] = 2048;
            *(_QWORD *)&v57[10] = v46;
            v58 = 1024;
            v59 = v4;
            v60 = 2048;
            v61 = Seconds;
            _os_log_debug_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEBUG, " [%s] %s:%d mediaURL=%@ trackCount=%lu fileSize=%.2f%cB fileLength=%f", (uint8_t *)&time, 0x4Au);
          }
          goto LABEL_24;
        }
        if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          goto LABEL_24;
      }
      else
      {
        v15 = *MEMORY[0x1E0CF2758];
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          goto LABEL_24;
      }
      v17 = objc_msgSend(v8, "count");
      LODWORD(time.value) = 136316930;
      *(CMTimeValue *)((char *)&time.value + 4) = v10;
      LOWORD(time.flags) = 2080;
      *(_QWORD *)((char *)&time.flags + 2) = "VCMediaRecorderUtil_PrintMediaURL";
      HIWORD(time.epoch) = 1024;
      v53 = 142;
      v54 = 2112;
      v55 = a1;
      v56 = 2048;
      *(_QWORD *)v57 = v17;
      *(_WORD *)&v57[8] = 2048;
      *(_QWORD *)&v57[10] = v46;
      v58 = 1024;
      v59 = v4;
      v60 = 2048;
      v61 = Seconds;
      _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d mediaURL=%@ trackCount=%lu fileSize=%.2f%cB fileLength=%f", (uint8_t *)&time, 0x4Au);
      goto LABEL_24;
    }
    v12 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
LABEL_12:
      v13 = objc_msgSend(v8, "count");
      LODWORD(time.value) = 136316930;
      *(CMTimeValue *)((char *)&time.value + 4) = v10;
      LOWORD(time.flags) = 2080;
      *(_QWORD *)((char *)&time.flags + 2) = "VCMediaRecorderUtil_PrintMediaURL";
      HIWORD(time.epoch) = 1024;
      v53 = 142;
      v54 = 2112;
      v55 = a1;
      v56 = 2048;
      *(_QWORD *)v57 = v13;
      *(_WORD *)&v57[8] = 2048;
      *(_QWORD *)&v57[10] = v46;
      v58 = 1024;
      v59 = v4;
      v60 = 2048;
      v61 = Seconds;
      _os_log_error_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_ERROR, " [%s] %s:%d mediaURL=%@ trackCount=%lu fileSize=%.2f%cB fileLength=%f", (uint8_t *)&time, 0x4Au);
    }
  }
  else
  {
    IsOSFaultDisabled = VRTraceIsOSFaultDisabled();
    v12 = *MEMORY[0x1E0CF2758];
    if ((IsOSFaultDisabled & 1) == 0)
    {
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_FAULT))
      {
        v14 = objc_msgSend(v8, "count");
        LODWORD(time.value) = 136316930;
        *(CMTimeValue *)((char *)&time.value + 4) = v10;
        LOWORD(time.flags) = 2080;
        *(_QWORD *)((char *)&time.flags + 2) = "VCMediaRecorderUtil_PrintMediaURL";
        HIWORD(time.epoch) = 1024;
        v53 = 142;
        v54 = 2112;
        v55 = a1;
        v56 = 2048;
        *(_QWORD *)v57 = v14;
        *(_WORD *)&v57[8] = 2048;
        *(_QWORD *)&v57[10] = v46;
        v58 = 1024;
        v59 = v4;
        v60 = 2048;
        v61 = Seconds;
        _os_log_fault_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_FAULT, " [%s] %s:%d mediaURL=%@ trackCount=%lu fileSize=%.2f%cB fileLength=%f", (uint8_t *)&time, 0x4Au);
      }
      goto LABEL_24;
    }
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      goto LABEL_12;
  }
LABEL_24:
  v50 = 0u;
  v51 = 0u;
  v48 = 0u;
  v49 = 0u;
  result = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v48, v47, 16);
  if (!result)
    return result;
  v19 = result;
  v20 = (os_log_t *)MEMORY[0x1E0CF2758];
  v21 = *(_QWORD *)v49;
  do
  {
    v22 = 0;
    do
    {
      if (*(_QWORD *)v49 != v21)
        objc_enumerationMutation(v8);
      v23 = *(void **)(*((_QWORD *)&v48 + 1) + 8 * v22);
      if (v23)
      {
        objc_msgSend(*(id *)(*((_QWORD *)&v48 + 1) + 8 * v22), "timeRange");
        v24 = *((_QWORD *)&v43 + 1);
        v25 = *((_QWORD *)&v44 + 1);
        v26 = v44;
      }
      else
      {
        v25 = 0;
        v24 = 0;
        v43 = 0u;
        v44 = 0u;
        v26 = 0;
      }
      time.value = v24;
      *(_QWORD *)&time.timescale = v26;
      time.epoch = v25;
      v27 = CMTimeGetSeconds(&time);
      v28 = VRTraceGetErrorLogLevelForModule();
      if (a2 >= 1 && v28 >= a2)
      {
        v29 = VRTraceErrorLogLevelToCSTR();
        if (a2 > 2)
        {
          if (a2 <= 4)
          {
            v31 = *v20;
            if (!os_log_type_enabled(*v20, OS_LOG_TYPE_ERROR))
              goto LABEL_52;
            goto LABEL_40;
          }
          if (a2 <= 7)
          {
            v36 = *v20;
            if (!os_log_type_enabled(*v20, OS_LOG_TYPE_DEFAULT))
              goto LABEL_52;
LABEL_49:
            v38 = objc_msgSend(v23, "mediaType");
            v39 = objc_msgSend(v23, "trackID");
            LODWORD(time.value) = 136316418;
            *(CMTimeValue *)((char *)&time.value + 4) = v29;
            LOWORD(time.flags) = 2080;
            *(_QWORD *)((char *)&time.flags + 2) = "VCMediaRecorderUtil_PrintMediaURL";
            HIWORD(time.epoch) = 1024;
            v53 = 147;
            v54 = 2112;
            v55 = v38;
            v20 = (os_log_t *)MEMORY[0x1E0CF2758];
            v56 = 1024;
            *(_DWORD *)v57 = v39;
            *(_WORD *)&v57[4] = 2048;
            *(Float64 *)&v57[6] = v27;
            _os_log_impl(&dword_1D8A54000, v36, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d mediaType=%@ trackID=%d trackLength=%f", (uint8_t *)&time, 0x36u);
            goto LABEL_52;
          }
          if (a2 != 8)
            goto LABEL_52;
          v36 = *v20;
          v37 = *v20;
          if (*MEMORY[0x1E0CF2748])
          {
            if (!os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
              goto LABEL_52;
            goto LABEL_49;
          }
          if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
          {
            v40 = objc_msgSend(v23, "mediaType");
            v41 = objc_msgSend(v23, "trackID");
            LODWORD(time.value) = 136316418;
            *(CMTimeValue *)((char *)&time.value + 4) = v29;
            LOWORD(time.flags) = 2080;
            *(_QWORD *)((char *)&time.flags + 2) = "VCMediaRecorderUtil_PrintMediaURL";
            HIWORD(time.epoch) = 1024;
            v53 = 147;
            v54 = 2112;
            v55 = v40;
            v20 = (os_log_t *)MEMORY[0x1E0CF2758];
            v56 = 1024;
            *(_DWORD *)v57 = v41;
            *(_WORD *)&v57[4] = 2048;
            *(Float64 *)&v57[6] = v27;
            _os_log_debug_impl(&dword_1D8A54000, v36, OS_LOG_TYPE_DEBUG, " [%s] %s:%d mediaType=%@ trackID=%d trackLength=%f", (uint8_t *)&time, 0x36u);
          }
        }
        else
        {
          v30 = VRTraceIsOSFaultDisabled();
          v31 = *v20;
          if ((v30 & 1) != 0)
          {
            if (!os_log_type_enabled(*v20, OS_LOG_TYPE_ERROR))
              goto LABEL_52;
LABEL_40:
            v32 = objc_msgSend(v23, "mediaType");
            v33 = objc_msgSend(v23, "trackID");
            LODWORD(time.value) = 136316418;
            *(CMTimeValue *)((char *)&time.value + 4) = v29;
            LOWORD(time.flags) = 2080;
            *(_QWORD *)((char *)&time.flags + 2) = "VCMediaRecorderUtil_PrintMediaURL";
            HIWORD(time.epoch) = 1024;
            v53 = 147;
            v54 = 2112;
            v55 = v32;
            v20 = (os_log_t *)MEMORY[0x1E0CF2758];
            v56 = 1024;
            *(_DWORD *)v57 = v33;
            *(_WORD *)&v57[4] = 2048;
            *(Float64 *)&v57[6] = v27;
            _os_log_error_impl(&dword_1D8A54000, v31, OS_LOG_TYPE_ERROR, " [%s] %s:%d mediaType=%@ trackID=%d trackLength=%f", (uint8_t *)&time, 0x36u);
            goto LABEL_52;
          }
          if (os_log_type_enabled(*v20, OS_LOG_TYPE_FAULT))
          {
            v34 = objc_msgSend(v23, "mediaType");
            v35 = objc_msgSend(v23, "trackID");
            LODWORD(time.value) = 136316418;
            *(CMTimeValue *)((char *)&time.value + 4) = v29;
            LOWORD(time.flags) = 2080;
            *(_QWORD *)((char *)&time.flags + 2) = "VCMediaRecorderUtil_PrintMediaURL";
            HIWORD(time.epoch) = 1024;
            v53 = 147;
            v54 = 2112;
            v55 = v34;
            v20 = (os_log_t *)MEMORY[0x1E0CF2758];
            v56 = 1024;
            *(_DWORD *)v57 = v35;
            *(_WORD *)&v57[4] = 2048;
            *(Float64 *)&v57[6] = v27;
            _os_log_fault_impl(&dword_1D8A54000, v31, OS_LOG_TYPE_FAULT, " [%s] %s:%d mediaType=%@ trackID=%d trackLength=%f", (uint8_t *)&time, 0x36u);
          }
        }
      }
LABEL_52:
      ++v22;
    }
    while (v19 != v22);
    result = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v48, v47, 16);
    v19 = result;
  }
  while (result);
  return result;
}

void VCVideoStreamReceiveGroup_UpdateSourcePlayoutTime(uint64_t a1, _OWORD *a2)
{
  __int128 v4;
  int32_t v5;
  const __CFString *v6;
  uint64_t v7;
  NSObject *v8;
  CMTime v9;
  _BYTE v10[38];
  __int16 v11;
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a2)
    {
      if (objc_msgSend((id)a1, "isVideoExpected") && (*(_QWORD *)(a1 + 432) || *(_BYTE *)(a1 + 448)))
      {
        v4 = a2[1];
        *(_OWORD *)v10 = *a2;
        *(_OWORD *)&v10[16] = v4;
        ++*(_QWORD *)(a1 + 600);
        if (*(_BYTE *)(a1 + 592))
        {
          v5 = *(_DWORD *)(a1 + 328);
          v9 = *(CMTime *)a2;
          CMTimeConvertScale((CMTime *)v10, &v9, v5, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
        }
        objc_msgSend((id)objc_msgSend(*(id *)(a1 + 176), "firstObject"), "updateSourcePlayoutTime:", v10);
      }
    }
    else if (objc_opt_class() == a1)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCVideoStreamReceiveGroup_UpdateSourcePlayoutTime_cold_2();
      }
    }
    else
    {
      if ((objc_opt_respondsToSelector() & 1) != 0)
        v6 = (const __CFString *)objc_msgSend((id)a1, "performSelector:", sel_logPrefix);
      else
        v6 = &stru_1E9E58EE0;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v7 = VRTraceErrorLogLevelToCSTR();
        v8 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)v10 = 136316162;
          *(_QWORD *)&v10[4] = v7;
          *(_WORD *)&v10[12] = 2080;
          *(_QWORD *)&v10[14] = "VCVideoStreamReceiveGroup_UpdateSourcePlayoutTime";
          *(_WORD *)&v10[22] = 1024;
          *(_DWORD *)&v10[24] = 721;
          *(_WORD *)&v10[28] = 2112;
          *(_QWORD *)&v10[30] = v6;
          v11 = 2048;
          v12 = a1;
          _os_log_error_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_ERROR, " [%s] %s:%d %@(%p) Playout time is NULL", v10, 0x30u);
        }
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCVideoStreamReceiveGroup_UpdateSourcePlayoutTime_cold_1();
  }
}

void _VCPacketBundler_CleanupCDRXInfo(void ***a1)
{
  void **v2;

  if (a1 && (v2 = *a1) != 0)
  {
    if (v2[10])
    {
      free(v2[10]);
      (*a1)[10] = 0;
      v2 = *a1;
    }
    free(v2);
    *a1 = 0;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCPacketBundler_CleanupCDRXInfo_cold_1();
  }
}

uint64_t VCPacketBundler_BundleAudio(uint64_t a1, _QWORD *a2)
{
  int v4;
  uint64_t result;
  uint64_t v6;
  _WORD *v7;
  os_log_t *v8;
  int v9;
  uint64_t v10;
  NSObject *v11;
  int v12;
  uint64_t v13;
  size_t v14;
  void *v15;
  int v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  char v22;
  BOOL v23;
  unsigned int v24;
  BOOL v25;
  BOOL v26;
  uint64_t v27;
  NSObject *v28;
  const char *v29;
  uint64_t v30;
  NSObject *v31;
  int v32;
  NSObject *v33;
  uint32_t v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD *v37;
  uint64_t v38;
  NSObject *v39;
  int v40;
  int v41;
  int v42;
  int v43;
  uint8_t buf[4];
  uint64_t v45;
  __int16 v46;
  const char *v47;
  __int16 v48;
  int v49;
  __int16 v50;
  _BYTE v51[10];
  _QWORD *v52;
  int v53;
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  if (!a1 || !a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      return 0;
    v27 = VRTraceErrorLogLevelToCSTR();
    v28 = *MEMORY[0x1E0CF2758];
    result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    *(_DWORD *)buf = 136316162;
    v45 = v27;
    v46 = 2080;
    v47 = "VCPacketBundler_BundleAudio";
    v48 = 1024;
    v49 = 325;
    v50 = 2048;
    *(_QWORD *)v51 = a1;
    *(_WORD *)&v51[8] = 2048;
    v52 = a2;
    v29 = " [%s] %s:%d NULL access: bundler=%p, audioBundleInfo=%p";
    goto LABEL_53;
  }
  if (*(_BYTE *)(a1 + 129))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      return 0;
    v30 = VRTraceErrorLogLevelToCSTR();
    v31 = *MEMORY[0x1E0CF2758];
    result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    v32 = *(unsigned __int8 *)(a1 + 129);
    *(_DWORD *)buf = 136316162;
    v45 = v30;
    v46 = 2080;
    v47 = "VCPacketBundler_BundleAudio";
    v48 = 1024;
    v49 = 326;
    v50 = 2048;
    *(_QWORD *)v51 = a1;
    *(_WORD *)&v51[8] = 1024;
    LODWORD(v52) = v32;
    v29 = " [%s] %s:%d :bundler=%p buffer is full=%d";
    v33 = v31;
    v34 = 44;
    goto LABEL_54;
  }
  if (*(_DWORD *)(a1 + 108) && *((_DWORD *)a2 + 3) != *(_DWORD *)(a1 + 92))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!(_DWORD)result)
        return result;
      VCPacketBundler_BundleAudio_cold_1();
    }
    return 0;
  }
  v4 = *(_DWORD *)(a1 + 124);
  switch(v4)
  {
    case 1:
      result = objc_msgSend((id)a1, "bundleAudioLegacy:numInputBytes:payloadType:timestamp:", *a2, *((unsigned int *)a2 + 2), *((unsigned int *)a2 + 3), *((unsigned int *)a2 + 4));
      if (!(_DWORD)result)
        return result;
      goto LABEL_36;
    case 3:
      v6 = *(_QWORD *)(a1 + 144);
      if (v6 && *a2)
      {
        v7 = CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(v6 + 80));
        if (v7)
        {
          v8 = (os_log_t *)MEMORY[0x1E0CF2758];
          do
          {
            if (*(_BYTE *)v7 == 1)
            {
              if (v7[1] == 40)
                v9 = 2;
              else
                v9 = 1;
            }
            else
            {
              v9 = 1;
            }
            *(_DWORD *)(a1 + 88) = v9;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v10 = VRTraceErrorLogLevelToCSTR();
              v11 = *v8;
              if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
              {
                v12 = *(_DWORD *)(a1 + 88);
                *(_DWORD *)buf = 136315906;
                v45 = v10;
                v46 = 2080;
                v47 = "_VCPacketBundler_UpdatePacketsPerBundle";
                v48 = 1024;
                v49 = 291;
                v50 = 1024;
                *(_DWORD *)v51 = v12;
                _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d After processing CDRX event, packets per bundle=%d", buf, 0x22u);
              }
            }
            v7 = CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(*(_QWORD *)(a1 + 144) + 80));
          }
          while (v7);
        }
        v13 = *(unsigned int *)(a1 + 100);
        v14 = *((unsigned int *)a2 + 2);
        if ((v14 + v13) <= *(_DWORD *)(a1 + 16))
        {
          v15 = (void *)(*(_QWORD *)(a1 + 8) + v13);
          memcpy(v15, (const void *)*a2, v14);
          v16 = (_DWORD)v15 + *((_DWORD *)a2 + 2);
          v17 = *(_QWORD *)(a1 + 144);
          v18 = *(_DWORD *)(a1 + 108);
          v19 = v17 + 20 * v18;
          v20 = *(_DWORD *)(a1 + 8);
          *(_DWORD *)(v19 + 8) = v16 - (v20 + *(_DWORD *)(a1 + 100));
          *(_DWORD *)(a1 + 100) = v16 - v20;
          v21 = *(_QWORD *)((char *)a2 + 12);
          *(_QWORD *)v19 = v21;
          *(_DWORD *)(v19 + 12) = *((_DWORD *)a2 + 6);
          v22 = *((_BYTE *)a2 + 20);
          if (v22)
            v23 = *(_BYTE *)(v17 + 40) == 0;
          else
            v23 = 0;
          *(_BYTE *)(v17 + 20 * v18 + 16) = v23;
          *(_BYTE *)(v17 + 40) = v22;
          v24 = *(_DWORD *)(a1 + 108) + 1;
          *(_DWORD *)(a1 + 108) = v24;
          *(_DWORD *)(a1 + 92) = v21;
          v25 = v24 >= *(_DWORD *)(a1 + 88) || *((_BYTE *)a2 + 29) != 0;
          *(_BYTE *)(a1 + 129) = v25;
          goto LABEL_36;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() < 3)
          return 0;
        v38 = VRTraceErrorLogLevelToCSTR();
        v39 = *MEMORY[0x1E0CF2758];
        result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
        if (!(_DWORD)result)
          return result;
        v40 = *((_DWORD *)a2 + 2);
        v41 = *(_DWORD *)(a1 + 16);
        v42 = *(_DWORD *)(a1 + 100);
        v43 = *(_DWORD *)(a1 + 108);
        *(_DWORD *)buf = 136316674;
        v45 = v38;
        v46 = 2080;
        v47 = "_VCPacketBundler_BundleAudioCDRX";
        v48 = 1024;
        v49 = 301;
        v50 = 1024;
        *(_DWORD *)v51 = v40;
        *(_WORD *)&v51[4] = 1024;
        *(_DWORD *)&v51[6] = v41;
        LOWORD(v52) = 1024;
        *(_DWORD *)((char *)&v52 + 2) = v42;
        HIWORD(v52) = 1024;
        v53 = v43;
        v29 = " [%s] %s:%d Bundling encountered an error: inputBytes=%u bufferSize=%u encodedBufferSize=%u bundledCount=%u";
        v33 = v39;
        v34 = 52;
LABEL_54:
        _os_log_error_impl(&dword_1D8A54000, v33, OS_LOG_TYPE_ERROR, v29, buf, v34);
        return 0;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() < 3)
        return 0;
      v35 = VRTraceErrorLogLevelToCSTR();
      v28 = *MEMORY[0x1E0CF2758];
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!(_DWORD)result)
        return result;
      v36 = *(_QWORD *)(a1 + 144);
      v37 = (_QWORD *)*a2;
      *(_DWORD *)buf = 136316162;
      v45 = v35;
      v46 = 2080;
      v47 = "_VCPacketBundler_BundleAudioCDRX";
      v48 = 1024;
      v49 = 297;
      v50 = 2048;
      *(_QWORD *)v51 = v36;
      *(_WORD *)&v51[8] = 2048;
      v52 = v37;
      v29 = " [%s] %s:%d NULL access: bundler->_cdrxBundleInfoRef=[%p], inputBytes=[%p]";
LABEL_53:
      v33 = v28;
      v34 = 48;
      goto LABEL_54;
    case 2:
      if ((objc_msgSend((id)a1, "bundleAudioRFC3640:numInputBytes:payloadType:timestamp:", *a2, *((unsigned int *)a2 + 2), *((unsigned int *)a2 + 3), *((unsigned int *)a2 + 4)) & 1) != 0)goto LABEL_36;
      return 0;
  }
  if ((objc_msgSend((id)a1, "_copyInputBytes:numInputBytes:payloadType:timestamp:", *a2, *((unsigned int *)a2 + 2), *((unsigned int *)a2 + 3), *((unsigned int *)a2 + 4)) & 1) == 0)return 0;
LABEL_36:
  if (*((_BYTE *)a2 + 20))
    v26 = 1;
  else
    v26 = *(_BYTE *)(a1 + 112) != 0;
  *(_BYTE *)(a1 + 112) = v26;
  VCAudioPacketBundler_UpdatePriority(a1, *((unsigned __int8 *)a2 + 21));
  *(_DWORD *)(a1 + 156) = *((_DWORD *)a2 + 6);
  return 1;
}

void VCAudioPacketBundler_UpdatePriority(uint64_t a1, unsigned int a2)
{
  unsigned int v2;

  if (a1)
  {
    v2 = *(unsigned __int8 *)(a1 + 136);
    if (v2 <= a2)
      LOBYTE(v2) = a2;
    *(_BYTE *)(a1 + 136) = v2;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioPacketBundler_UpdatePriority_cold_1();
  }
}

uint64_t VCPacketBundler_ExtractBundledPackets(uint64_t a1, unsigned int a2, uint64_t a3)
{
  BOOL v5;
  uint64_t v6;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  _DWORD *v14;
  uint64_t v15;
  _DWORD *v16;
  uint64_t v18;
  NSObject *v19;
  int v20;
  uint64_t v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  uint64_t v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (a1)
    v5 = a3 == 0;
  else
    v5 = 1;
  v6 = !v5;
  if (!v5)
  {
    v8 = *(_DWORD *)(a1 + 124);
    if (v8 == 3)
    {
      v10 = *(_QWORD *)(a1 + 144);
      if (!v10)
      {
        v9 = 0;
LABEL_16:
        *(_QWORD *)a3 = v9;
        v11 = *(_DWORD *)(a1 + 124);
        if (v11 == 3)
        {
          v13 = *(_QWORD *)(a1 + 144);
          if (v13)
            v12 = *(_DWORD *)(v13 + 20 * a2 + 8);
          else
            v12 = 0;
        }
        else if (v11 == 2)
        {
          v12 = objc_msgSend((id)a1, "encodedBufferSizeForRFC3640");
        }
        else
        {
          v12 = *(_DWORD *)(a1 + 100);
        }
        *(_DWORD *)(a3 + 8) = v12;
        if (*(_DWORD *)(a1 + 124) == 3)
        {
          v14 = *(_DWORD **)(a1 + 144);
          if (!v14)
            goto LABEL_28;
          v14 += 5 * a2 + 1;
        }
        else
        {
          v14 = (_DWORD *)(a1 + 96);
        }
        LODWORD(v14) = *v14;
LABEL_28:
        *(_DWORD *)(a3 + 16) = (_DWORD)v14;
        if (*(_DWORD *)(a1 + 124) == 3)
        {
          v15 = *(_QWORD *)(a1 + 144);
          if (!v15)
            goto LABEL_35;
          LODWORD(v15) = *(unsigned __int8 *)(v15 + 20 * a2 + 16);
        }
        else
        {
          if (*(_BYTE *)(a1 + 113))
          {
            LOBYTE(v15) = 0;
            goto LABEL_35;
          }
          LODWORD(v15) = *(unsigned __int8 *)(a1 + 112);
        }
        LOBYTE(v15) = (_DWORD)v15 != 0;
LABEL_35:
        *(_BYTE *)(a3 + 28) = v15;
        *(_DWORD *)(a3 + 12) = *(_DWORD *)(a1 + 92);
        if (*(_DWORD *)(a1 + 124) == 3)
        {
          v16 = *(_DWORD **)(a1 + 144);
          if (!v16)
          {
LABEL_40:
            *(_DWORD *)(a3 + 24) = (_DWORD)v16;
            *(_BYTE *)(a3 + 21) = *(_BYTE *)(a1 + 136);
            return v6;
          }
          v16 += 5 * a2 + 3;
        }
        else
        {
          v16 = (_DWORD *)(a1 + 156);
        }
        LODWORD(v16) = *v16;
        goto LABEL_40;
      }
      if (a2)
      {
        v9 = *(_QWORD *)(a1 + 8) + *(unsigned int *)(v10 + 20 * (a2 - 1) + 8);
        goto LABEL_16;
      }
    }
    else if (v8 == 2)
    {
      v9 = objc_msgSend((id)a1, "encodedBufferForRFC3640");
      goto LABEL_16;
    }
    v9 = *(_QWORD *)(a1 + 8);
    goto LABEL_16;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v18 = VRTraceErrorLogLevelToCSTR();
    v19 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      v20 = 136316162;
      v21 = v18;
      v22 = 2080;
      v23 = "VCPacketBundler_ExtractBundledPackets";
      v24 = 1024;
      v25 = 515;
      v26 = 2048;
      v27 = a1;
      v28 = 2048;
      v29 = a3;
      _os_log_error_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_ERROR, " [%s] %s:%d NULL access: packetBundler=[%p] rtpPacketInfo=[%p]", (uint8_t *)&v20, 0x30u);
    }
  }
  return v6;
}

void VCPacketBundler_StoreAndEnqueueCdrxInfo(uint64_t a1, int a2, int a3)
{
  uint64_t v4;
  uint64_t v7;
  os_log_t *v8;
  opaqueCMSimpleQueue *v9;
  uint64_t v10;
  OSStatus v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  NSObject *v15;
  int32_t Count;
  uint64_t v17;
  NSObject *v18;
  uint8_t buf[4];
  uint64_t v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int32_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (a1 && (v4 = *(_QWORD *)(a1 + 144)) != 0)
  {
    v7 = v4 + 4 * *(unsigned __int8 *)(v4 + 74);
    *(_BYTE *)(v7 + 42) = a2;
    *(_WORD *)(v7 + 44) = a3;
    v8 = (os_log_t *)MEMORY[0x1E0CF2758];
    while (1)
    {
      v9 = *(opaqueCMSimpleQueue **)(v4 + 80);
      while (!v9)
        ;
      v10 = *(unsigned __int8 *)(v4 + 74);
      v11 = CMSimpleQueueEnqueue(v9, (const void *)(v4 + 4 * v10 + 42));
      if (v11 != -12773)
        break;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v12 = VRTraceErrorLogLevelToCSTR();
        v13 = *v8;
        if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          v20 = v12;
          v21 = 2080;
          v22 = "VCPacketBundler_StoreAndEnqueueCdrxInfo";
          v23 = 1024;
          v24 = 546;
          _os_log_error_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_ERROR, " [%s] %s:%d Cdrx event queue is Full. Reset Queue and enqueue", buf, 0x1Cu);
        }
      }
      CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(*(_QWORD *)(a1 + 144) + 80));
      v4 = *(_QWORD *)(a1 + 144);
    }
    if (v11)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
          VCPacketBundler_StoreAndEnqueueCdrxInfo_cold_2();
      }
    }
    else
    {
      *(_BYTE *)(*(_QWORD *)(a1 + 144) + 74) = (v10 + 1) & 7;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v14 = VRTraceErrorLogLevelToCSTR();
        v15 = *v8;
        if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
        {
          Count = CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(*(_QWORD *)(a1 + 144) + 80));
          *(_DWORD *)buf = 136316418;
          v20 = v14;
          v21 = 2080;
          v22 = "VCPacketBundler_StoreAndEnqueueCdrxInfo";
          v23 = 1024;
          v24 = 543;
          v25 = 1024;
          v26 = a2;
          v27 = 1024;
          v28 = a3;
          v29 = 1024;
          v30 = Count;
          _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Cdrx event enqueued: cdrx state=%d, cdrx cycle=%d, enqueued event count=%d", buf, 0x2Eu);
        }
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v17 = VRTraceErrorLogLevelToCSTR();
    v18 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCPacketBundler_StoreAndEnqueueCdrxInfo_cold_1(v17, a1, v18);
  }
}

uint64_t _AVCAudioStream_UpdateFrequencyLevel(void *a1, const char *a2, int a3)
{
  uint64_t v4;

  v4 = *((_QWORD *)a1 + 6);
  if (a3)
    return objc_msgSend(a1, "vcMediaStream:updateInputFrequencyLevel:", v4, a2);
  else
    return objc_msgSend(a1, "vcMediaStream:updateOutputFrequencyLevel:", v4, a2);
}

void sub_1D8E77DBC(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1D8E7C714(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1D8E7D824(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_list va;

  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1D8E7F4B8(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 176), 8);
  _Unwind_Resume(a1);
}

void sub_1D8E81158(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 56), 8);
  _Unwind_Resume(a1);
}

uint64_t VCVideoCaptureServer_CopyLocalVideoAttributes(uint64_t a1)
{
  NSObject *v1;
  uint64_t v2;
  _QWORD block[6];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  void (*v8)(uint64_t, uint64_t);
  void (*v9)(uint64_t);
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v5 = 0;
  v6 = &v5;
  v7 = 0x3052000000;
  v8 = __Block_byref_object_copy__30;
  v9 = __Block_byref_object_dispose__30;
  v10 = 0;
  if (a1)
  {
    v1 = *(NSObject **)(a1 + 256);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = __VCVideoCaptureServer_CopyLocalVideoAttributes_block_invoke;
    block[3] = &unk_1E9E52938;
    block[4] = a1;
    block[5] = &v5;
    dispatch_sync(v1, block);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCVideoCaptureServer_CopyLocalVideoAttributes_cold_1();
  }
  v2 = v6[5];
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_1D8E82EC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
  _Unwind_Resume(exception_object);
}

void sub_1D8E85028(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  _Unwind_Resume(exception_object);
}

uint64_t OUTLINED_FUNCTION_19_2@<X0>(void *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  *(_QWORD *)(v2 - 24) = a2;
  return objc_msgSend(a1, "streamInputID");
}

void sub_1D8E89D34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

uint64_t _VCMockIDSDatagramChannel_ComparePacket(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  BOOL v4;
  unsigned int v5;

  v2 = *(_QWORD *)(a1 + 1648);
  v3 = *(_QWORD *)(a2 + 1648);
  v4 = v2 == v3;
  v5 = 2 * (v2 >= v3);
  if (v4)
    return 1;
  else
    return v5;
}

uint64_t VCMockIDSDatagramChannelReceiveThread(uint64_t result, uint64_t a2, _BYTE *a3)
{
  unsigned __int8 v4;
  unsigned __int8 *v5;
  unsigned __int8 v6;

  v4 = atomic_load((unsigned __int8 *)(result + 3322352));
  if ((v4 & 1) == 0)
  {
    v5 = (unsigned __int8 *)result;
    do
    {
      result = objc_msgSend(v5, "readyToRead");
      v6 = atomic_load(v5 + 3322352);
    }
    while ((v6 & 1) == 0);
  }
  *a3 = 1;
  return result;
}

uint64_t _VCMediaQueueClassRegister(uint64_t *a1)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

void _VCMediaQueue_ReportingEvent(_DWORD *a1, int a2, int a3)
{
  const __CFAllocator *v6;
  __CFDictionary *Mutable;
  CFNumberRef v8;
  const __CFString *v9;
  unsigned int v10;
  unsigned int v11;
  int valuePtr;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (a2 <= 192)
  {
    if (a2 == 191)
    {
      valuePtr = -1431655766;
      v11 = atomic_load(a1 + 71);
      valuePtr = v11;
      v8 = CFNumberCreate(v6, kCFNumberIntType, &valuePtr);
      v9 = CFSTR("VCMQPeakBR");
      goto LABEL_10;
    }
    if (a2 == 192)
    {
      valuePtr = -1431655766;
      v10 = atomic_load(a1 + 72);
      valuePtr = v10;
      v8 = CFNumberCreate(v6, kCFNumberIntType, &valuePtr);
      v9 = CFSTR("VCMQMTU");
      goto LABEL_10;
    }
  }
  else
  {
    if ((a2 - 193) < 2)
    {
      valuePtr = a3;
      v8 = CFNumberCreate(v6, kCFNumberIntType, &valuePtr);
      v9 = CFSTR("VCMQStreamID");
LABEL_10:
      CFDictionaryAddValue(Mutable, v9, v8);
      CFRelease(v8);
      goto LABEL_11;
    }
    if (a2 == 321)
    {
      valuePtr = a1[22];
      v8 = CFNumberCreate(v6, kCFNumberIntType, &valuePtr);
      v9 = CFSTR("MQSchP");
      goto LABEL_10;
    }
  }
LABEL_11:
  reportingEventWithAllowedClientType();
  CFRelease(Mutable);
}

uint64_t _VCMediaQueue_GetInternalQueueIndexFromStreamId(uint64_t result, int a2, int a3, int *a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  _DWORD *v7;
  uint64_t v8;

  if (!a4)
  {
    v5 = 2149580801;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCMediaQueue_GetInternalQueueIndexFromStreamId_cold_1();
    }
    return v5;
  }
  v4 = *(unsigned __int8 *)(result + 128);
  if (a3)
  {
    if (*(_BYTE *)(result + 128))
    {
      v5 = 0;
      *a4 = 0;
    }
    else
    {
      v5 = 2149580801;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCMediaQueue_GetInternalQueueIndexFromStreamId_cold_2();
      }
    }
    return v5;
  }
  v6 = atomic_load((unsigned int *)(result + 760));
  if ((int)v6 <= v4)
    return 0;
  v7 = (_DWORD *)(result + 632 + 4 * *(unsigned __int8 *)(result + 128));
  v8 = v6 - *(unsigned __int8 *)(result + 128);
  while ((unint64_t)v7 < result + 760 && (unint64_t)v7 >= result + 632)
  {
    if (*v7 == a2)
    {
      v5 = 0;
      *a4 = v4;
      return v5;
    }
    ++v4;
    ++v7;
    if (!--v8)
      return 0;
  }
  __break(0x5519u);
  return result;
}

void VCMediaQueue_FreeMediaPacket(uint64_t a1, uint64_t a2)
{
  int v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v9;
  opaqueCMSimpleQueue **v10;
  opaqueCMSimpleQueue *v11;
  const void *v12;
  OSStatus v13;
  uint64_t v14;
  NSObject *v15;
  const char *v16;
  NSObject *v17;
  uint32_t v18;
  OSStatus v19;
  uint64_t v20;
  NSObject *v21;
  unsigned int v22;
  uint8_t buf[4];
  uint64_t v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  OSStatus v30;
  __int16 v31;
  int v32;
  __int16 v33;
  int v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (!a2)
      return;
    v4 = *(_DWORD *)(a2 + 176);
    v5 = *(_DWORD *)(a2 + 228);
    *(_QWORD *)(a2 + 8) = 0;
    v22 = -1;
    if (_VCMediaQueue_GetInternalQueueIndexFromStreamId(a1, v5, *(unsigned __int8 *)(a2 + 295), (int *)&v22)|| (v22 & 0x80000000) != 0)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 3)
        return;
      v14 = VRTraceErrorLogLevelToCSTR();
      v15 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        return;
      *(_DWORD *)buf = 136316162;
      v24 = v14;
      v25 = 2080;
      v26 = "VCMediaQueue_FreeMediaPacket";
      v27 = 1024;
      v28 = 778;
      v29 = 1024;
      v30 = v4;
      v31 = 1024;
      v32 = v5;
      v16 = "VCMediaQueue [%s] %s:%d Cannot get internal queue index for packet type=%d, mediaQueueStreamId=%u";
      v17 = v15;
      v18 = 40;
LABEL_27:
      _os_log_error_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_ERROR, v16, buf, v18);
      return;
    }
    v6 = *(_QWORD *)(a1 + 624);
    v7 = v6 + 176 * v22;
    if (v7 >= v6 + 176 * *(unsigned int *)(a1 + 348) || v7 < v6)
LABEL_28:
      __break(0x5519u);
    if (CMSimpleQueueGetHead(*(CMSimpleQueueRef *)(v6 + 176 * v22 + 8)) != (const void *)a2)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCMediaQueue_FreeMediaPacket_cold_2();
      }
      return;
    }
    v9 = *(_QWORD *)(a1 + 624);
    v10 = (opaqueCMSimpleQueue **)(v9 + 176 * (int)v22);
    if ((unint64_t)v10 >= v9 + 176 * *(unsigned int *)(a1 + 348) || (unint64_t)v10 < v9)
      goto LABEL_28;
    v11 = *v10;
    v12 = CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(v9 + 176 * (int)v22 + 8));
    v13 = CMSimpleQueueEnqueue(v11, v12);
    if (v13)
    {
      v19 = v13;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v20 = VRTraceErrorLogLevelToCSTR();
        v21 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136316418;
          v24 = v20;
          v25 = 2080;
          v26 = "VCMediaQueue_FreeMediaPacket";
          v27 = 1024;
          v28 = 787;
          v29 = 1024;
          v30 = v19;
          v31 = 1024;
          v32 = v4;
          v33 = 1024;
          v34 = v5;
          v16 = "VCMediaQueue [%s] %s:%d Internal queue has error %d when free media packet for packet type=%d, mediaQueueStreamId=%u";
          v17 = v21;
          v18 = 46;
          goto LABEL_27;
        }
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCMediaQueue_FreeMediaPacket_cold_1();
  }
}

void _VCMediaQueue_FreeMediaPacketList(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;

  if (a2)
  {
    v2 = a2;
    do
    {
      v4 = *(_QWORD *)(v2 + 304);
      _VCMediaQueue_ReleaseExternalDataBuffer(a1, v2);
      v5 = *(_QWORD *)(v2 + 184);
      if (v5)
      {
        VCMediaControlInfoDispose(v5);
        *(_QWORD *)(v2 + 184) = 0;
      }
      VCMediaQueue_FreeMediaPacket(a1, v2);
      v2 = v4;
    }
    while (v4);
  }
}

void _VCMediaQueue_ReleaseExternalDataBuffer(uint64_t a1, uint64_t a2)
{
  const void *v4;
  int v5;
  BOOL v6;

  if (a2)
  {
    v4 = *(const void **)(a2 + 8);
    if (v4)
    {
      v5 = *(unsigned __int8 *)(a1 + 96);
      if (*(_BYTE *)(a2 + 294))
        v6 = v5 == 0;
      else
        v6 = 1;
      if (!v6)
      {
        CFRelease(v4);
        *(_QWORD *)(a2 + 8) = 0;
        *(_BYTE *)(a2 + 294) = 0;
      }
    }
  }
}

uint64_t _VCMediaQueue_RegisterStream(uint64_t a1, unsigned int a2, signed int *a3)
{
  uint64_t result;
  unsigned int *v6;
  signed int v7;
  signed int v8;
  unsigned int *v9;
  BOOL v10;
  unint64_t v11;
  unint64_t v12;
  BOOL v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  NSObject *v21;
  uint8_t buf[4];
  uint64_t v23;
  __int16 v24;
  const char *v25;
  __int16 v26;
  int v27;
  __int16 v28;
  unsigned int v29;
  __int16 v30;
  signed int v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  result = 2149580801;
  if (a3)
  {
    v6 = (unsigned int *)(a1 + 760);
    v7 = atomic_load((unsigned int *)(a1 + 760));
LABEL_3:
    v8 = v7;
    if (v7 >= *(_DWORD *)(a1 + 348))
    {
      return 2149580805;
    }
    else
    {
      do
      {
        v7 = __ldaxr(v6);
        if (v7 != v8)
        {
          __clrex();
          goto LABEL_3;
        }
      }
      while (__stlxr(v8 + 1, v6));
      v9 = (unsigned int *)(a1 + 632 + 4 * v8);
      v10 = v9 < v6 && (unint64_t)v9 >= a1 + 632;
      if (v10
        && ((*v9 = a2,
             v11 = *(_QWORD *)(a1 + 624),
             v12 = v11 + 176 * v8,
             v12 < v11 + 176 * *(unsigned int *)(a1 + 348))
          ? (v13 = v12 >= v11)
          : (v13 = 0),
            v13))
      {
        *(_DWORD *)(v11 + 176 * v8 + 124) = a2;
        *a3 = v8;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v20 = VRTraceErrorLogLevelToCSTR();
          v21 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136316162;
            v23 = v20;
            v24 = 2080;
            v25 = "_VCMediaQueue_RegisterStream";
            v26 = 1024;
            v27 = 820;
            v28 = 1024;
            v29 = a2;
            v30 = 1024;
            v31 = v8;
            _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d VCMediaQueue register mediaQueueStreamId=%u with internal queue index=%d", buf, 0x28u);
          }
        }
        result = *(_QWORD *)(a1 + 168);
        if (result)
        {
          VRLogfilePrintWithTimestamp(result, "Stream registration with index=%d, mediaQueueStreamId=%u\n", v14, v15, v16, v17, v18, v19, v8);
          return 0;
        }
      }
      else
      {
        __break(0x5519u);
      }
    }
  }
  return result;
}

void _VCMediaQueue_SchedulePackets(uint64_t a1)
{
  double v2;
  unsigned __int8 *v3;
  double v4;
  int v5;

  v2 = micro();
  *(double *)(a1 + 312) = v2 + *(double *)(a1 + 24);
  v3 = (unsigned __int8 *)(a1 + 280);
  do
    __ldaxr(v3);
  while (__stlxr(0, v3));
  v4 = *(double *)(a1 + 320);
  if (v4 != 0.0)
    *(double *)(a1 + 352) = v2 - v4;
  v5 = *(_DWORD *)(a1 + 88);
  *(double *)(a1 + 320) = v2;
  if ((v5 - 1) >= 2)
  {
    if (v5)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCMediaQueue_SchedulePackets_cold_1();
      }
    }
    else
    {
      _VCMediaQueue_SchedulePacketsWithPolicyNone(a1);
    }
  }
  else
  {
    _VCMediaQueue_SchedulePacketsWithLimitedBudget(a1);
  }
}

uint64_t _VCMediaQueue_SchedulePacketsWithPolicyNone(uint64_t result)
{
  uint64_t v1;
  unint64_t v2;
  uint64_t v3;
  opaqueCMSimpleQueue *v4;
  _QWORD *Head;

  if (*(_DWORD *)(result + 348))
  {
    v1 = result;
    v2 = 0;
    do
    {
      v3 = *(_QWORD *)(v1 + 624);
      if (*(_DWORD *)(v3 + 176 * v2 + 24))
      {
        v4 = *(opaqueCMSimpleQueue **)(v3 + 176 * v2 + 16);
        result = CMSimpleQueueGetCount(v4);
        if ((int)result >= 1)
        {
          do
          {
            Head = CMSimpleQueueGetHead(v4);
            result = VCMediaQueuePacketBundler_AddPacket(*(_QWORD *)(v1 + 136), Head);
            if ((_DWORD)result)
              break;
            CMSimpleQueueDequeue(v4);
            result = CMSimpleQueueGetCount(v4);
          }
          while ((int)result > 0);
        }
      }
      ++v2;
    }
    while (v2 < *(unsigned int *)(v1 + 348));
  }
  return result;
}

void _VCMediaQueue_SchedulePacketsWithLimitedBudget(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  NSObject *v4;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  _VCMediaQueue_UpdateTotalBudgetForThisInterval(a1);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    v4 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        v5 = *(_DWORD *)(a1 + 340);
        v14 = 136315906;
        v15 = v2;
        v16 = 2080;
        v17 = "_VCMediaQueue_SchedulePacketsWithLimitedBudget";
        v18 = 1024;
        v19 = 875;
        v20 = 1024;
        v21 = v5;
        _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d Starting budget in this interval: %d", (uint8_t *)&v14, 0x22u);
      }
    }
    else if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      _VCMediaQueue_SchedulePacketsWithLimitedBudget_cold_1();
    }
  }
  v6 = _VCMediaQueue_ScheduleDirectSendQueuesAndReduceRemainingBudget(a1);
  v7 = _VCMediaQueue_ScheduleWaitingQueuesAndReduceRemainingBudget(a1) + v6;
  *(_BYTE *)(a1 + 308) = v7 != 0;
  v8 = _VCMediaQueue_ScheduleThrottlingQueuesAndReduceRemainingBudget(a1) + v7;
  if (v8 && (int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v9 = VRTraceErrorLogLevelToCSTR();
    v10 = *MEMORY[0x1E0CF2758];
    v11 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        v12 = *(_DWORD *)(a1 + 340);
        v14 = 136316162;
        v15 = v9;
        v16 = 2080;
        v17 = "_VCMediaQueue_SchedulePacketsWithLimitedBudget";
        v18 = 1024;
        v19 = 884;
        v20 = 1024;
        v21 = v8;
        v22 = 1024;
        v23 = v12;
        _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d Total byte count scheduled in this interval: %d, remaining budget: %d", (uint8_t *)&v14, 0x28u);
      }
    }
    else if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      v13 = *(_DWORD *)(a1 + 340);
      v14 = 136316162;
      v15 = v9;
      v16 = 2080;
      v17 = "_VCMediaQueue_SchedulePacketsWithLimitedBudget";
      v18 = 1024;
      v19 = 884;
      v20 = 1024;
      v21 = v8;
      v22 = 1024;
      v23 = v13;
      _os_log_debug_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEBUG, "VCMediaQueue [%s] %s:%d Total byte count scheduled in this interval: %d, remaining budget: %d", (uint8_t *)&v14, 0x28u);
    }
  }
  *(_DWORD *)(a1 + 412) += v8;
}

uint64_t _VCMediaQueue_UpdateTotalBudgetForThisInterval(uint64_t result)
{
  unsigned __int8 v1;
  unsigned int v2;
  unsigned __int8 v3;
  unint64_t v4;
  char v5;
  unsigned __int8 *v6;
  unsigned __int8 v7;
  unint64_t v8;
  double v9;
  unsigned int v10;
  unsigned int v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;

  v1 = atomic_load((unsigned __int8 *)(result + 888));
  if ((v1 & 1) != 0)
  {
    v10 = (*(double *)(result + 24) * 50000000.0);
    goto LABEL_22;
  }
  *(double *)(result + 360) = *(double *)(result + 352) * 0.9 + *(double *)(result + 360) * 0.1;
  v2 = atomic_load((unsigned int *)(result + 284));
  *(_DWORD *)(result + 392) = v2;
  v3 = atomic_load((unsigned __int8 *)(result + 300));
  if (*(_BYTE *)(result + 129) && (v3 & 1) != 0)
  {
    if (!*(_DWORD *)(result + 348))
      goto LABEL_13;
    v4 = 0;
    v5 = 0;
    do
    {
      v6 = (unsigned __int8 *)(*(_QWORD *)(result + 624) + 176 * v4 + 93);
      do
        v7 = __ldaxr(v6);
      while (__stlxr(0, v6));
      v5 |= v7;
      ++v4;
    }
    while (v4 < *(unsigned int *)(result + 348));
    if ((v5 & 1) != 0)
    {
      v8 = *(_QWORD *)(result + 320);
      v9 = fmax(*(double *)(result + 376) * 0.5, 1.0);
      *(_QWORD *)(result + 384) = v8;
    }
    else
    {
LABEL_13:
      v12 = *(double *)(result + 384);
      if (v12 != 0.0)
      {
        HIDWORD(v8) = 1078853632;
        if (*(double *)(result + 320) - v12 <= 60.0)
        {
          v9 = *(double *)(result + 376);
          goto LABEL_17;
        }
      }
      v8 = 10.0;
      v9 = fmin(*(double *)(result + 376) + 0.01, 10.0);
    }
    *(double *)(result + 376) = v9;
LABEL_17:
    LODWORD(v8) = *(_DWORD *)(result + 392);
    v11 = (v9 * (double)v8);
    *(_DWORD *)(result + 392) = v11;
    goto LABEL_18;
  }
  v11 = *(_DWORD *)(result + 392);
LABEL_18:
  v13 = *(double *)(result + 360);
  v14 = *(double *)(result + 368) * v13;
  v15 = (double)v11;
  if (v14 >= *(double *)(result + 24))
    v14 = *(double *)(result + 24);
  v10 = (v14 * v15 * 0.125);
  *(_DWORD *)(result + 332) = v10;
  v16 = v13 * v15 * 0.125;
  LODWORD(v13) = *(_DWORD *)(result + 340);
  if (v10 >= (v16 + (double)*(unint64_t *)&v13))
    v10 = (v16 + (double)*(unint64_t *)&v13);
LABEL_22:
  *(_DWORD *)(result + 340) = v10;
  *(_DWORD *)(result + 336) = v10;
  return result;
}

uint64_t _VCMediaQueue_ScheduleDirectSendQueuesAndReduceRemainingBudget(uint64_t a1)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  CMSimpleQueueRef *v7;
  opaqueCMSimpleQueue *v8;
  uint64_t v9;
  _DWORD *v10;
  _DWORD *v11;
  _DWORD *Head;
  OSStatus v13;
  int v14;
  int v15;
  int v16;
  int v17;
  OSStatus v18;
  uint64_t v19;
  NSObject *v20;
  unsigned int v21;
  BOOL v22;
  int v23;
  uint8_t buf[4];
  uint64_t v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  int v30;
  __int16 v31;
  OSStatus v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v2 = *(unsigned int *)(a1 + 348);
  if ((_DWORD)v2)
  {
    v3 = 0;
    v4 = 0;
    do
    {
      v5 = *(_QWORD *)(a1 + 624);
      if (*(_DWORD *)(v5 + 176 * v3 + 24) == 1)
      {
        v6 = v5 + 176 * v3;
        v8 = *(opaqueCMSimpleQueue **)(v6 + 16);
        v7 = (CMSimpleQueueRef *)(v6 + 16);
        if (CMSimpleQueueGetCount(v8) >= 1)
        {
          v9 = v5 + 176 * v3;
          v10 = (_DWORD *)(v9 + 80);
          v11 = (_DWORD *)(v9 + 84);
          while (1)
          {
            Head = CMSimpleQueueGetHead(*v7);
            v13 = CMSimpleQueueEnqueue(*(CMSimpleQueueRef *)(a1 + 616), Head);
            if (v13)
              break;
            CMSimpleQueueDequeue(*v7);
            v14 = Head[67];
            if (*((_BYTE *)Head + 293))
              v15 = 48;
            else
              v15 = 28;
            v16 = v15 + *Head;
            v17 = *((unsigned __int16 *)Head + 2);
            *(_DWORD *)(a1 + 420) += v14;
            *(_DWORD *)(a1 + 416) += v16 * v14;
            *v10 += v14;
            *v11 = Head[59];
            v4 = (v4 + (v16 + v17) * v14);
            if (CMSimpleQueueGetCount(*v7) <= 0)
              goto LABEL_15;
          }
          v18 = v13;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            v19 = VRTraceErrorLogLevelToCSTR();
            v20 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136315906;
              v26 = v19;
              v27 = 2080;
              v28 = "_VCMediaQueue_ScheduleDirectSendQueuesAndReduceRemainingBudget";
              v29 = 1024;
              v30 = 991;
              v31 = 1024;
              v32 = v18;
              _os_log_error_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_ERROR, "VCMediaQueue [%s] %s:%d Failed to enqueue! status: %d", buf, 0x22u);
            }
          }
        }
LABEL_15:
        *(_WORD *)(a1 + 600) |= 1 << v3;
        v2 = *(unsigned int *)(a1 + 348);
      }
      ++v3;
    }
    while (v3 < v2);
  }
  else
  {
    v4 = 0;
  }
  v21 = *(_DWORD *)(a1 + 340);
  v22 = v21 >= v4;
  v23 = v21 - v4;
  if (v23 == 0 || !v22)
  {
    v23 = 0;
    *(_DWORD *)(a1 + 344) += v4;
  }
  *(_DWORD *)(a1 + 340) = v23;
  return v4;
}

uint64_t _VCMediaQueue_ScheduleWaitingQueuesAndReduceRemainingBudget(uint64_t a1)
{
  uint64_t v2;
  unsigned int v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  int v8;
  unint64_t v9;
  CMSimpleQueueRef *v10;
  opaqueCMSimpleQueue *v11;
  BOOL v12;
  int v13;
  unint64_t v14;
  _DWORD *v15;
  _DWORD *v16;
  _DWORD *Head;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  uint64_t v24;
  NSObject *v25;
  unsigned int v26;
  int v27;
  uint8_t buf[4];
  uint64_t v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  int v34;
  __int16 v35;
  int v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v2 = 0;
  v3 = *(_DWORD *)(a1 + 348) - 1;
  if ((v3 & 0x80000000) == 0)
  {
    do
    {
      v4 = *(_QWORD *)(a1 + 624);
      v5 = v4 + 176 * *(unsigned int *)(a1 + 348);
      v6 = v4 + 176 * v3;
      if (v4 > v6 || v6 + 176 > v5)
LABEL_30:
        __break(0x5519u);
      v8 = v3;
      if (*(_DWORD *)(v4 + 176 * v3 + 24) == 2)
      {
        v9 = v4 + 176 * v3;
        v11 = *(opaqueCMSimpleQueue **)(v9 + 16);
        v10 = (CMSimpleQueueRef *)(v9 + 16);
        if (CMSimpleQueueGetCount(v11) >= 1)
        {
          if (v6)
            v12 = v6 >= v5;
          else
            v12 = 0;
          v13 = !v12;
          v14 = v4 + 176 * v8;
          v15 = (_DWORD *)(v14 + 80);
          v16 = (_DWORD *)(v14 + 84);
          while (1)
          {
            Head = CMSimpleQueueGetHead(*v10);
            v18 = VCMediaQueuePacketBundler_AddPacket(*(_QWORD *)(a1 + 136), Head);
            if (v18)
              break;
            CMSimpleQueueDequeue(*v10);
            if (!v13)
              goto LABEL_30;
            v19 = Head[67];
            if (*((_BYTE *)Head + 293))
              v20 = 48;
            else
              v20 = 28;
            v21 = v20 + *Head;
            v22 = *((unsigned __int16 *)Head + 2);
            *(_DWORD *)(a1 + 420) += v19;
            *(_DWORD *)(a1 + 416) += v21 * v19;
            *v15 += v19;
            *v16 = Head[59];
            v2 = (v2 + (v21 + v22) * v19);
            if (CMSimpleQueueGetCount(*v10) <= 0)
              goto LABEL_25;
          }
          v23 = v18;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            v24 = VRTraceErrorLogLevelToCSTR();
            v25 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136315906;
              v30 = v24;
              v31 = 2080;
              v32 = "_VCMediaQueue_ScheduleWaitingQueuesAndReduceRemainingBudget";
              v33 = 1024;
              v34 = 1014;
              v35 = 1024;
              v36 = v23;
              _os_log_error_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_ERROR, "VCMediaQueue [%s] %s:%d Failed to add packet to bundler! status=%d", buf, 0x22u);
            }
          }
        }
LABEL_25:
        *(_WORD *)(a1 + 600) |= 1 << v8;
      }
      v3 = v8 - 1;
    }
    while (v8 > 0);
  }
  v26 = *(_DWORD *)(a1 + 340);
  v12 = v26 >= v2;
  v27 = v26 - v2;
  if (v27 == 0 || !v12)
  {
    v27 = 0;
    *(_DWORD *)(a1 + 344) += v2;
  }
  *(_DWORD *)(a1 + 340) = v27;
  return v2;
}

uint64_t _VCMediaQueue_ScheduleThrottlingQueuesAndReduceRemainingBudget(uint64_t a1)
{
  int v1;

  v1 = *(_DWORD *)(a1 + 88);
  if (v1 == 2)
    return _VCMediaQueue_ScheduleThrottlingQueuesWithoutWait(a1);
  if (v1 == 1)
    return _VCMediaQueue_ScheduleThrottlingQueuesWithIDRAndLongestIdleTimeFirst(a1);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCMediaQueue_ScheduleThrottlingQueuesAndReduceRemainingBudget_cold_1();
  }
  return 0;
}

uint64_t _VCMediaQueue_ScheduleThrottlingQueuesWithIDRAndLongestIdleTimeFirst(uint64_t a1)
{
  unint64_t v2;
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;
  unsigned __int8 *v6;
  unsigned __int8 v7;
  unsigned int *v8;
  uint64_t v10;
  uint64_t v11;
  unsigned int *i;
  unsigned int v13;
  _OWORD v15[32];
  unsigned int v16[4];

  *(_QWORD *)v16 = *MEMORY[0x1E0C80C00];
  memset(v15, 0, sizeof(v15));
  if (*(_DWORD *)(a1 + 348))
  {
    v2 = 0;
    v3 = 0;
    v4 = 0;
    do
    {
      v5 = *(_QWORD *)(a1 + 624);
      if (*(_DWORD *)(v5 + 176 * v2 + 24) == 3 && CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(v5 + 176 * v2 + 16)) >= 1)
      {
        v6 = (unsigned __int8 *)(v5 + 176 * v2 + 92);
        do
          v7 = __ldaxr(v6);
        while (__stlxr(0, v6));
        if ((v7 & 1) != 0)
        {
          v3 = _VCMediaQueue_ScheduleFramesFromThrottlingQueue(a1, v2) + v3;
          *(_WORD *)(a1 + 600) |= 1 << v2;
          *(_WORD *)(a1 + 602) |= 1 << v2;
        }
        else
        {
          v8 = (unsigned int *)&v15[v4];
          if (v8 >= v16 || v8 < (unsigned int *)v15)
            goto LABEL_23;
          v10 = *(_QWORD *)(v5 + 176 * v2 + 32);
          ++v4;
          *v8 = v2;
          v8[1] = -1431655766;
          *((_QWORD *)v8 + 1) = v10;
        }
      }
      ++v2;
    }
    while (v2 < *(unsigned int *)(a1 + 348));
    v11 = v4;
    qsort(v15, v4, 0x10uLL, (int (__cdecl *)(const void *, const void *))_VCMediaQueue_CompareScheduleOrderElementWithScheduleTime);
    if (v4)
    {
      for (i = (unsigned int *)v15; i < v16 && i >= (unsigned int *)v15; i += 4)
      {
        v13 = *i;
        v3 = _VCMediaQueue_ScheduleFramesFromThrottlingQueue(a1, v13) + v3;
        if (!--v11)
          return v3;
      }
LABEL_23:
      __break(0x5519u);
    }
  }
  else
  {
    qsort(v15, 0, 0x10uLL, (int (__cdecl *)(const void *, const void *))_VCMediaQueue_CompareScheduleOrderElementWithScheduleTime);
    return 0;
  }
  return v3;
}

uint64_t _VCMediaQueue_ScheduleThrottlingQueuesWithoutWait(uint64_t result)
{
  uint64_t v1;
  unsigned __int8 v2;
  unsigned int v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;

  v1 = result;
  v2 = atomic_load((unsigned __int8 *)(result + 888));
  if ((v2 & 1) == 0)
    return _VCMediaQueue_ScheduleThrottlingQueuesWithIDRAndLongestIdleTimeFirst(result);
  v3 = *(_DWORD *)(result + 348);
  if (v3)
  {
    v4 = 0;
    v5 = 0;
    v6 = 0;
    v7 = 176 * v3;
    while (1)
    {
      v8 = *(_QWORD *)(v1 + 624);
      if (v8 > v8 + v4 || v8 + v4 + 176 > v8 + 176 * *(unsigned int *)(v1 + 348))
        break;
      if (*(_DWORD *)(v8 + v4 + 24) == 3)
      {
        result = CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(v8 + v4 + 16));
        if ((int)result >= 1)
        {
          result = _VCMediaQueue_ScheduleFramesFromThrottlingQueue(v1, v5);
          v6 = (result + v6);
        }
      }
      ++v5;
      v4 += 176;
      if (v7 == v4)
        return v6;
    }
    __break(0x5519u);
  }
  else
  {
    return 0;
  }
  return result;
}

uint64_t _VCMediaQueue_ScheduleFramesFromThrottlingQueue(uint64_t a1, unsigned int a2)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  CMSimpleQueueRef *v11;
  opaqueCMSimpleQueue *v12;
  uint64_t v13;
  BOOL v14;
  int v15;
  unint64_t v16;
  _DWORD *v17;
  BOOL v18;
  _BYTE *Head;
  _BYTE *v20;
  unsigned __int8 v21;
  BOOL v22;
  char v23;
  int v24;
  uint64_t v25;
  int v26;
  int v27;
  unint64_t v28;
  unint64_t v29;
  int v30;
  NSObject *v31;
  _BOOL4 v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  unsigned int v39;
  unsigned int v40;
  unsigned int v41;
  uint64_t v43;
  int *v44;
  unint64_t v46;
  char v47;
  int *v48;
  unint64_t v49;
  char *v50;
  _DWORD *v51;
  uint8_t buf[4];
  uint64_t v53;
  __int16 v54;
  const char *v55;
  __int16 v56;
  int v57;
  __int16 v58;
  int v59;
  __int16 v60;
  int v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  if (!*(_DWORD *)(a1 + 340))
    return 0;
  v3 = *(_QWORD *)(a1 + 624);
  v4 = v3 + 176 * *(unsigned int *)(a1 + 348);
  v47 = a2;
  v5 = v3 + 176 * a2;
  v46 = v3;
  if (v3 > v5 || v5 + 176 > v4)
LABEL_66:
    __break(0x5519u);
  v8 = v3 + 176 * a2;
  v9 = (unint64_t *)(v8 + 104);
  v10 = atomic_load((unint64_t *)(v8 + 104));
  v49 = v10;
  v12 = *(opaqueCMSimpleQueue **)(v8 + 16);
  v11 = (CMSimpleQueueRef *)(v8 + 16);
  v13 = 0;
  if (CMSimpleQueueGetCount(v12) >= 1)
  {
    if (v5)
      v14 = v5 >= v4;
    else
      v14 = 0;
    v15 = !v14;
    v16 = v46 + 176 * a2;
    v48 = (int *)(v16 + 160);
    v44 = (int *)(v16 + 124);
    v17 = (_DWORD *)(v16 + 80);
    v50 = (char *)(v16 + 168);
    v51 = (_DWORD *)(v16 + 84);
    v18 = 1;
    do
    {
      Head = CMSimpleQueueGetHead(*v11);
      if (!v15)
        goto LABEL_66;
      v20 = Head;
      v21 = atomic_load((unsigned __int8 *)(a1 + 300));
      if ((v21 & 1) == 0)
      {
        v22 = 0;
        goto LABEL_24;
      }
      if (Head[94])
      {
        if (Head[291])
        {
          v23 = 1;
LABEL_22:
          *v50 = v23;
          goto LABEL_23;
        }
        if (Head[292])
        {
          v23 = 0;
          goto LABEL_22;
        }
      }
LABEL_23:
      v22 = *v50 != 0;
LABEL_24:
      if (!*(_BYTE *)(a1 + 308))
      {
        if (*(_BYTE *)(a1 + 309))
          v22 = 0;
        if (v22)
          break;
      }
      if ((!v18 || Head[225] == 0) && !*(_DWORD *)(a1 + 340))
        break;
      if (v18)
        v24 = Head[292] == 0;
      else
        v24 = Head[291];
      v18 = v24 != 0;
      if (Head && Head >= Head + 312)
        goto LABEL_66;
      if (VCMediaQueuePacketBundler_AddPacket(*(_QWORD *)(a1 + 136), Head))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VCMediaQueue_ScheduleFramesFromThrottlingQueue_cold_1();
        }
        break;
      }
      CMSimpleQueueDequeue(*v11);
      if (v20[289])
      {
        v25 = *((unsigned int *)v20 + 59);
        if (v49 == v25)
        {
          if (v20[291])
          {
            v26 = 1;
LABEL_52:
            *v48 = v26;
            goto LABEL_53;
          }
          v27 = v20[292];
          ++*v48;
          if (v27)
          {
            v28 = atomic_load(v9);
            while ((v25 - v28) <= 0x7FFFFFFE)
            {
              while (1)
              {
                v29 = __ldaxr(v9);
                if (v29 != v28)
                  break;
                if (!__stlxr(0xFFFFFFFFFFFFFFFFLL, v9))
                {
                  v30 = 1;
                  goto LABEL_47;
                }
              }
              v30 = 0;
              __clrex();
LABEL_47:
              v28 = v29;
              if (v30)
              {
                if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
                {
                  v43 = VRTraceErrorLogLevelToCSTR();
                  v31 = *MEMORY[0x1E0CF2758];
                  v32 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
                  v26 = 0;
                  if (!v32)
                    goto LABEL_52;
                  v33 = *v44;
                  v34 = *v48;
                  *(_DWORD *)buf = 136316162;
                  v53 = v43;
                  v54 = 2080;
                  v55 = "_VCMediaQueue_ResetLastIDRTimestamp";
                  v56 = 1024;
                  v57 = 1185;
                  v58 = 1024;
                  v59 = v33;
                  v60 = 1024;
                  v61 = v34;
                  _os_log_impl(&dword_1D8A54000, v31, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d IDR frame sent out. Reset lastIDRTimestamp for mediaQueueStreamId=%u, frameSizeInPackets=%u", buf, 0x28u);
                }
                break;
              }
            }
            v26 = 0;
            goto LABEL_52;
          }
        }
      }
LABEL_53:
      v35 = *((_DWORD *)v20 + 67);
      if (v20[293])
        v36 = 48;
      else
        v36 = 28;
      v37 = v36 + *(_DWORD *)v20;
      v38 = *((unsigned __int16 *)v20 + 2);
      *(_DWORD *)(a1 + 420) += v35;
      *(_DWORD *)(a1 + 416) += v37 * v35;
      *v17 += v35;
      *v51 = *((_DWORD *)v20 + 59);
      v39 = (v37 + v38) * v35;
      v40 = *(_DWORD *)(a1 + 340);
      v14 = v40 >= v39;
      v41 = v40 - v39;
      if (v41 == 0 || !v14)
      {
        v41 = 0;
        *(_DWORD *)(a1 + 344) += v39;
      }
      *(_DWORD *)(a1 + 340) = v41;
      v13 = v39 + v13;
    }
    while (CMSimpleQueueGetCount(*v11) > 0);
  }
  *(_WORD *)(a1 + 600) |= 1 << v47;
  *(_QWORD *)(v46 + 176 * a2 + 32) = *(_QWORD *)(a1 + 320);
  return v13;
}

uint64_t _VCMediaQueue_CompareScheduleOrderElementWithScheduleTime(uint64_t a1, uint64_t a2)
{
  return (int)(*(double *)(a1 + 8) - *(double *)(a2 + 8));
}

void _VCMediaQueue_SendAndFreePackets(uint64_t a1)
{
  unint64_t v1;
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned __int8 v7;
  double v8;
  int v9;
  _OWORD *v10;
  int v11;
  unint64_t v12;
  uint64_t v13;
  unsigned int v14;
  OSStatus DataPointer;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  void *v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  uint64_t v26;
  double v27;
  unsigned int v28;
  unint64_t v29;
  int v30;
  uint64_t v31;
  int v32;
  uint64_t (*v33)(uint64_t, char *);
  uint64_t v34;
  _OWORD *v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  NSObject *v39;
  int v40;
  int v41;
  int v42;
  __int16 v43;
  _OWORD **v44;
  uint64_t *v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  _QWORD *v53;
  int v54;
  unsigned int *v55;
  __int128 v56;
  __int128 v57;
  uint64_t v58;
  NSObject *v59;
  unsigned __int8 v60;
  int v61;
  unsigned int v62;
  unsigned int v63;
  unsigned int v64;
  int v65;
  uint64_t v66;
  int v67;
  int v68;
  pthread_mutex_t *v69;
  _DWORD *v70;
  unsigned int v71;
  unsigned int v72;
  unsigned __int8 v73;
  char *dataPointerOut;
  size_t lengthAtOffsetOut;
  uint8_t buf[64];
  _OWORD v77[10];
  int v78;
  __int128 v79;
  _OWORD v80[7];
  char v81;
  uint64_t v82[14];
  uint64_t v83;
  uint64_t v84;
  _OWORD *v85[30];
  _QWORD v86[4];

  v3 = MEMORY[0x1E0C80A78](a1);
  v5 = v4;
  v6 = v3;
  v86[1] = *MEMORY[0x1E0C80C00];
  v70 = (_DWORD *)(v3 + 25616);
  v67 = *(_DWORD *)(v4 + 268);
  v7 = atomic_load((unsigned __int8 *)(v3 + 300));
  v73 = v7;
  v8 = micro();
  v68 = *(_DWORD *)(v5 + 176);
  if (v68 == 1)
    v9 = 700;
  else
    v9 = 800;
  v71 = v9;
  v72 = *(_DWORD *)(v5 + 264);
  memset(v85, 0, sizeof(v85));
  memset(v82, 0, sizeof(v82));
  v10 = v77;
  v83 = 0;
  bzero(v77, 0x2580uLL);
  v11 = 0;
  v69 = (pthread_mutex_t *)(v6 + 216);
  v12 = 1;
  v13 = v5;
  while (1)
  {
    while (1)
    {
      v14 = *(_DWORD *)(v13 + 268);
      if (v14 >= 2 && *(_QWORD *)(v13 + 304))
      {
        v50 = 0;
        goto LABEL_97;
      }
      if (!*(_BYTE *)(v13 + 58))
        break;
      if (*(_WORD *)(v13 + 4))
        break;
      v19 = *(_QWORD *)(v13 + 304);
      if (!v19)
        break;
      *(_BYTE *)(v19 + 58) = 1;
      *(_WORD *)(v19 + 60) = *(_WORD *)(v13 + 60);
      v12 = 1;
      *(_BYTE *)(v6 + 499) = 1;
      v13 = v19;
    }
    dataPointerOut = 0;
    lengthAtOffsetOut = 0;
    DataPointer = CMBlockBufferGetDataPointer(*(CMBlockBufferRef *)(v13 + 8), 0, &lengthAtOffsetOut, 0, &dataPointerOut);
    if (DataPointer)
    {
      LODWORD(v1) = DataPointer;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v16 = VRTraceErrorLogLevelToCSTR();
        v2 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v21 = *(unsigned __int8 *)(v13 + 58);
          if (*(_BYTE *)(v13 + 58))
            v22 = *(unsigned __int16 *)(v13 + 60);
          else
            v22 = 0;
          v23 = *(_DWORD *)(v13 + 228);
          *(_DWORD *)buf = 136316674;
          *(_QWORD *)&buf[4] = v16;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VCMediaQueue_SendAndFreePackets";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 1433;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = v1;
          *(_WORD *)&buf[34] = 1024;
          *(_DWORD *)&buf[36] = v23;
          *(_WORD *)&buf[40] = 1024;
          *(_DWORD *)&buf[42] = v21;
          *(_WORD *)&buf[46] = 1024;
          *(_DWORD *)&buf[48] = v22;
          _os_log_error_impl(&dword_1D8A54000, v2, OS_LOG_TYPE_ERROR, "VCMediaQueue [%s] %s:%d CMBlock error %d when send/free media packet for mediaQueueStreamId=%u, isServerStats=%u, id=%u", buf, 0x34u);
        }
        v10 = v77;
      }
      goto LABEL_94;
    }
    if (v11 >= 30)
      break;
    if ((v73 & 1) != 0)
    {
      v17 = *(_DWORD *)(v13 + 176);
      if (v17 == 1)
      {
        if (*(_BYTE *)(v13 + 94))
        {
          v20 = *(void **)(v13 + 184);
          if (v20)
          {
            if (!*(_BYTE *)(v6 + 309))
            {
              *(_DWORD *)buf = bswap32(v70[3]);
              VCMediaControlInfoSetInfo(v20, (const char *)8, (uint64_t)buf, 4);
              *(_BYTE *)(v13 + 296) = 1;
              v17 = *(_DWORD *)(v13 + 176);
              goto LABEL_29;
            }
          }
        }
        v18 = *(_DWORD *)(v13 + 268);
      }
      else
      {
        if (!v17)
        {
          v70[3] = *(_DWORD *)(v13 + 236);
          v18 = *(_DWORD *)(v13 + 268);
LABEL_31:
          if (*(_BYTE *)(v13 + 227))
            *v70 += v18;
LABEL_35:
          v24 = *(unsigned __int16 *)(v13 + 4);
          if (*(_BYTE *)(v13 + 293))
            v25 = 48;
          else
            v25 = 28;
          v70[2] += (v25 + v24) * v18;
          v26 = *(unsigned int *)(v13 + 244);
          v2 = &dataPointerOut[v26];
          if (dataPointerOut > &dataPointerOut[v26])
            goto LABEL_147;
          if (v2 > &dataPointerOut[lengthAtOffsetOut])
            goto LABEL_147;
          v1 = (v24 - v26);
          if (lengthAtOffsetOut - v26 < v1)
            goto LABEL_147;
          v10 = *(_OWORD **)(v13 + 184);
          if (v10)
          {
            if (VCMediaControlInfoHasInfo(*(void **)(v13 + 184), 0) && *(_BYTE *)(v6 + 130))
            {
              memset(buf, 0, 40);
              *(_DWORD *)&buf[28] = RTPPackDouble(*(double *)(v13 + 208));
              v27 = *(double *)(v13 + 216);
              if (v27 == 0.0)
              {
                v28 = 0;
              }
              else if (v27 == v8)
              {
                v28 = 1;
              }
              else
              {
                v28 = vcvtd_n_u64_f64(v8 - v27, 0xAuLL);
              }
              *(_DWORD *)&buf[20] = v28;
              v29 = MicroToNTP(v8);
              v12 = NTPToMiddle32(v29);
              *(_WORD *)&buf[24] = v12 >> 6;
              VCMediaControlInfoSetInfoUnserialized(v10, (const char *)buf, 1);
              _VCMediaQueue_AddInfoToOneToOneTxHistory(v6, v12 >> 6, v8);
              pthread_mutex_lock(v69);
              if (*(_BYTE *)(v6 + 176))
              {
                *(_BYTE *)(v6 + 176) = 0;
                *(double *)(v6 + 200) = v8;
                *(_DWORD *)(v6 + 180) = *(_DWORD *)(v6 + 188);
              }
              if (*(_BYTE *)(v6 + 177))
              {
                *(_BYTE *)(v6 + 177) = 0;
                *(double *)(v6 + 208) = v8;
                *(_DWORD *)(v6 + 184) = *(_DWORD *)(v6 + 192);
                if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
                {
                  v66 = VRTraceErrorLogLevelToCSTR();
                  v12 = *MEMORY[0x1E0CF2758];
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                  {
                    v30 = *(_DWORD *)(v6 + 184);
                    v31 = *(_QWORD *)(v6 + 208);
                    *(_DWORD *)buf = 136316162;
                    *(_QWORD *)&buf[4] = v66;
                    *(_WORD *)&buf[12] = 2080;
                    *(_QWORD *)&buf[14] = "_VCMediaQueue_UpdateStabilizationCounters";
                    *(_WORD *)&buf[22] = 1024;
                    *(_DWORD *)&buf[24] = 1334;
                    *(_WORD *)&buf[28] = 1024;
                    *(_DWORD *)&buf[30] = v30;
                    *(_WORD *)&buf[34] = 2048;
                    *(_QWORD *)&buf[36] = v31;
                    _os_log_impl(&dword_1D8A54000, (os_log_t)v12, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d Refresh frame counter=%d, time=%.4f", buf, 0x2Cu);
                  }
                }
              }
              pthread_mutex_unlock(v69);
            }
            if (v2 && v24 == (_DWORD)v26)
            {
LABEL_147:
              __break(0x5519u);
              goto LABEL_148;
            }
            v32 = VCMediaControlInfoSerialize((uint64_t)v10);
            if (v32 < 0)
            {
              LODWORD(v1) = v32;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                v2 = VRTraceErrorLogLevelToCSTR();
                v12 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                {
LABEL_148:
                  v65 = *(unsigned __int16 *)(v13 + 248);
                  *(_DWORD *)buf = 136316418;
                  *(_QWORD *)&buf[4] = v2;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = "_VCMediaQueue_SerializeMediaControlInfoInOneToOneMediaPacket";
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&buf[24] = 1352;
                  *(_WORD *)&buf[28] = 1024;
                  *(_DWORD *)&buf[30] = v1;
                  *(_WORD *)&buf[34] = 1024;
                  *(_DWORD *)&buf[36] = v65;
                  *(_WORD *)&buf[40] = 2048;
                  *(_QWORD *)&buf[42] = v10;
                  _os_log_error_impl(&dword_1D8A54000, (os_log_t)v12, OS_LOG_TYPE_ERROR, "VCMediaQueue [%s] %s:%d Adding extension failed with result=%08X for packet sequenceNum=%u controlInfo=%p", buf, 0x32u);
                }
              }
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  _VCMediaQueue_SendAndFreePackets_cold_7();
              }
              goto LABEL_146;
            }
          }
          else if (!*(_BYTE *)(v6 + 130))
          {
            _VCMediaQueue_AddInfoToOneToOneTxHistory(v6, *(_DWORD *)(v13 + 236) / 0x3E8u, v8);
          }
          v10 = v77;
          if (*(_BYTE *)(v13 + 297))
          {
            if (lengthAtOffsetOut < *(unsigned __int16 *)(v13 + 4))
              goto LABEL_147;
            if (!*(_DWORD *)(v13 + 244))
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  _VCMediaQueue_SendAndFreePackets_cold_3();
              }
LABEL_143:
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  _VCMediaQueue_SendAndFreePackets_cold_2();
              }
LABEL_146:
              v50 = 0;
              v14 = *(_DWORD *)(v13 + 268);
LABEL_97:
              *(_DWORD *)(v6 + 492) += v14;
              v51 = v68;
              goto LABEL_102;
            }
            v33 = *(uint64_t (**)(uint64_t, char *))(v13 + 192);
            if (!v33)
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  _VCMediaQueue_SendAndFreePackets_cold_4();
              }
              goto LABEL_143;
            }
            v34 = *(_QWORD *)(v13 + 200);
            if (v34 == 0xFFFFFFFFLL)
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  _VCMediaQueue_SendAndFreePackets_cold_5();
              }
              goto LABEL_143;
            }
            if ((v33(v34, dataPointerOut) & 0x80000000) != 0)
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  _VCMediaQueue_SendAndFreePackets_cold_6();
              }
              goto LABEL_143;
            }
            *(_BYTE *)(v13 + 297) = 0;
          }
          goto LABEL_68;
        }
LABEL_29:
        v18 = *(_DWORD *)(v13 + 268);
        if (v17 != 1)
        {
          if (!v17)
            goto LABEL_31;
          goto LABEL_35;
        }
      }
      if (!*(_BYTE *)(v13 + 226))
        v70[1] += v18;
      goto LABEL_35;
    }
LABEL_68:
    v1 = (unint64_t)&v77[20 * v11];
    if (v1 >= (unint64_t)v82 || v1 < (unint64_t)v77)
      goto LABEL_147;
    v35 = &v77[20 * v11];
    *((_DWORD *)v35 + 2) = *(_DWORD *)(v13 + 232);
    *((_BYTE *)v35 + 168) = 1;
    v37 = *(_OWORD *)(v13 + 64);
    v36 = *(_OWORD *)(v13 + 80);
    v38 = *(_OWORD *)(v13 + 48);
    v35[12] = *(_OWORD *)(v13 + 32);
    v35[13] = v38;
    v35[14] = v37;
    v35[15] = v36;
    v35[11] = *(_OWORD *)(v13 + 16);
    v12 = 1;
    *((_BYTE *)v35 + 205) = 1;
    *((_BYTE *)v35 + 313) = *(_BYTE *)(v13 + 297);
    VTP_SetPktTag((uint64_t)v35, 0, *(unsigned __int16 *)(v13 + 248));
    VTP_SetPktTag((uint64_t)v35, 1u, *(unsigned int *)(v13 + 252));
    VTP_SetPktTag((uint64_t)v35, 2u, *(unsigned int *)(v13 + 236));
    if (*((_BYTE *)v35 + 201))
    {
      *(_BYTE *)(v13 + 296) = 1;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v2 = VRTraceErrorLogLevelToCSTR();
        v1 = *MEMORY[0x1E0CF2758];
        v39 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
          {
            v40 = *(unsigned __int16 *)(v6 + 604);
            v41 = *(_DWORD *)(v13 + 228);
            v42 = *(unsigned __int16 *)(v13 + 4);
            *(_DWORD *)buf = 136316418;
            *(_QWORD *)&buf[4] = v2;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VCMediaQueue_SendAndFreePackets";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 1481;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = v40;
            *(_WORD *)&buf[34] = 1024;
            *(_DWORD *)&buf[36] = v41;
            *(_WORD *)&buf[40] = 1024;
            *(_DWORD *)&buf[42] = v42;
            _os_log_impl(&dword_1D8A54000, (os_log_t)v1, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d Sending out probingGroupID=%d, mediaQueueStreamId=%u, size=%d", buf, 0x2Eu);
          }
        }
        else if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
        {
          v47 = *(unsigned __int16 *)(v6 + 604);
          v48 = *(_DWORD *)(v13 + 228);
          v49 = *(unsigned __int16 *)(v13 + 4);
          *(_DWORD *)buf = 136316418;
          *(_QWORD *)&buf[4] = v2;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VCMediaQueue_SendAndFreePackets";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 1481;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = v47;
          *(_WORD *)&buf[34] = 1024;
          *(_DWORD *)&buf[36] = v48;
          *(_WORD *)&buf[40] = 1024;
          *(_DWORD *)&buf[42] = v49;
          _os_log_debug_impl(&dword_1D8A54000, (os_log_t)v1, OS_LOG_TYPE_DEBUG, "VCMediaQueue [%s] %s:%d Sending out probingGroupID=%d, mediaQueueStreamId=%u, size=%d", buf, 0x2Eu);
        }
      }
      v43 = *(_WORD *)(v6 + 604);
      WORD5(v80[20 * v11]) = v43;
      if (*(_BYTE *)(v13 + 292))
        *(_WORD *)(v6 + 604) = v43 + 1;
    }
    if (dataPointerOut && !lengthAtOffsetOut)
      goto LABEL_147;
    v44 = &v85[v11];
    if (v44 >= v86)
      goto LABEL_147;
    if (v44 < v85)
      goto LABEL_147;
    v85[v11] = dataPointerOut;
    v45 = (uint64_t *)((char *)v82 + 4 * v11);
    if (v45 >= &v84 || v45 < v82)
      goto LABEL_147;
    *(_DWORD *)v45 = *(unsigned __int16 *)(v13 + 4);
    v46 = *(_DWORD *)(v13 + 268);
    if (*(_BYTE *)(v13 + 227))
    {
      *(_DWORD *)(v6 + 476) += v46;
      *(_WORD *)(v6 + 496) = *(_WORD *)(v13 + 248);
    }
    else
    {
      *(_DWORD *)(v6 + 480) += v46;
    }
    if (*(_BYTE *)(v13 + 226))
      *(_DWORD *)(v6 + 488) += v46;
    if (*(_BYTE *)(v13 + 296))
      *(_DWORD *)(v6 + 484) += v46;
    ++v11;
    if (*(_BYTE *)(v13 + 289))
      *(_BYTE *)(v6 + 498) = 1;
LABEL_94:
    v13 = *(_QWORD *)(v13 + 304);
    if (!v13)
      goto LABEL_101;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCMediaQueue_SendAndFreePackets_cold_1();
  }
LABEL_101:
  v51 = v68;
  v50 = v67;
LABEL_102:
  v52 = v50;
  if (v51 == 1)
  {
    *(_QWORD *)(v6 + 544) += v50;
    v53 = (_QWORD *)(v6 + 576);
  }
  else
  {
    *(_QWORD *)(v6 + 552) += v50;
    v53 = (_QWORD *)(v6 + 568);
  }
  ++*v53;
  *(_QWORD *)(v6 + 560) += v50;
  ++*(_QWORD *)(v6 + 584);
  if (v50 >= 1)
  {
    v54 = 0;
    v55 = (unsigned int *)(v6 + 296);
    do
    {
      if ((v73 & 1) != 0)
      {
        if (v11 >= 2 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v58 = VRTraceErrorLogLevelToCSTR();
          v59 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = v58;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VCMediaQueue_SendAndFreePackets";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 1498;
            _os_log_error_impl(&dword_1D8A54000, v59, OS_LOG_TYPE_ERROR, "VCMediaQueue [%s] %s:%d One to one should not have compound packets", buf, 0x1Cu);
          }
        }
        _VCMediaQueue_RateStats_TrackMediaPacket(*(_QWORD *)(v6 + 160), v5, 0, v8);
        v60 = atomic_load((unsigned __int8 *)(v6 + 302));
        v81 = v60 & 1;
        if (*(_BYTE *)(v5 + 227))
          v61 = 16;
        else
          v61 = 32;
        v78 = v61;
        VTP_Send(v72, v85[0], LODWORD(v82[0]), v71, (uint64_t)v77);
        v62 = *(_DWORD *)(v5 + 256);
        if (v62 > *(_DWORD *)(v6 + 188))
        {
          *(_BYTE *)(v6 + 176) = 1;
          *(_DWORD *)(v6 + 188) = v62;
        }
        v63 = *(_DWORD *)(v5 + 260);
        if (v63 > *(_DWORD *)(v6 + 192))
        {
          *(_BYTE *)(v6 + 177) = 1;
          *(_DWORD *)(v6 + 192) = v63;
        }
      }
      else
      {
        if (v54 && v11 == 1)
        {
          v56 = *(_OWORD *)(v5 + 144);
          v80[1] = *(_OWORD *)(v5 + 128);
          v80[2] = v56;
          v80[3] = *(_OWORD *)(v5 + 160);
          v57 = *(_OWORD *)(v5 + 112);
          v79 = *(_OWORD *)(v5 + 96);
          v80[0] = v57;
        }
        VTP_SendCompoundPacket(v72);
      }
      do
        v64 = __ldaxr(v55);
      while (__stlxr(v64 + v11, v55));
      ++v54;
    }
    while (v54 != v52);
  }
  _VCMediaQueue_FreeMediaPacketList(v6, v5);
}

void _VCMediaQueue_RateStats_TrackMediaPacket(uint64_t a1, uint64_t a2, int a3, double a4)
{
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  int v11;
  int v12;
  char v13;
  char v14;
  unsigned int v15;
  int v16;
  unsigned int v17;
  unint64_t v18;
  _DWORD *v19;
  int v21;
  int v22;
  uint64_t v23;
  void *v24;
  size_t v25;
  size_t v26;
  void *v27;
  unsigned int v30;
  unint64_t v31;
  _DWORD *v32;
  int v34;
  int v35;
  _DWORD *v36;

  if (a1 && a2)
  {
    v5 = *(unsigned __int16 *)(a2 + 4);
    if (*(_BYTE *)(a2 + 293))
      v6 = 48;
    else
      v6 = 28;
    v7 = a1 + 672;
    if (a3)
      v7 = a1 + 224;
    v8 = a1 + 448;
    if (a3)
      v8 = a1;
    if (*(_BYTE *)(a2 + 227))
      v9 = v8;
    else
      v9 = v7;
    v10 = v9 + 136;
    v11 = *(_DWORD *)(v9 + 148);
    v12 = vcvtd_n_s64_f64(a4 - *(double *)(v9 + 136), 6uLL);
    if (v12)
    {
      if (v12 > 15)
      {
        if (v12 > 0x1F)
        {
          v11 = 0;
          v15 = 0;
          *(_OWORD *)(v9 + 120) = 0u;
          *(_OWORD *)(v9 + 104) = 0u;
          *(_OWORD *)(v9 + 88) = 0u;
          *(_OWORD *)(v9 + 72) = 0u;
          *(_OWORD *)(v9 + 56) = 0u;
          *(_OWORD *)(v9 + 40) = 0u;
          *(_OWORD *)(v9 + 24) = 0u;
          *(_OWORD *)(v9 + 8) = 0u;
        }
        else
        {
          v21 = *(unsigned __int16 *)(v9 + 144);
          v22 = v21 + v12;
          v15 = (v21 + v12) & 0x1F;
          v23 = ((_BYTE)v21 + 1) & 0x1F;
          if (v15 >= v23)
          {
            v27 = (void *)(v9 + 8 + 4 * v23);
            v26 = 4 * (int)(v15 - v23 + 1);
            if (v10 < (unint64_t)v27 || v9 + 8 > (unint64_t)v27 || v26 > v10 - (unint64_t)v27)
              goto LABEL_57;
          }
          else
          {
            v24 = (void *)(v9 + 8 + 4 * (((_BYTE)v21 + 1) & 0x1F));
            if (v10 < (unint64_t)v24)
              goto LABEL_57;
            if (v9 + 8 > (unint64_t)v24)
              goto LABEL_57;
            v25 = (128 - 4 * v23);
            if (v10 - (unint64_t)v24 < v25)
              goto LABEL_57;
            bzero(v24, v25);
            v26 = 4 * v15 + 4;
            v27 = (void *)(v9 + 8);
          }
          bzero(v27, v26);
          v30 = (v22 + 1) & 0x1F;
          if (v30 != (_DWORD)v23)
          {
            v11 = 0;
            v31 = v9 + 8;
            while (1)
            {
              v32 = (_DWORD *)(v31 + 4 * v30);
              if ((unint64_t)v32 >= v10 || (unint64_t)v32 < v31)
                goto LABEL_57;
              v11 += *v32;
              v30 = ((_BYTE)v30 + 1) & 0x1F;
              if (v30 == (_DWORD)v23)
                goto LABEL_51;
            }
          }
          v11 = 0;
        }
      }
      else
      {
        v13 = *(_WORD *)(v9 + 144);
        v14 = v13 + v12;
        v15 = v14 & 0x1F;
        v16 = (v14 + 1) & 0x1F;
        v17 = (v13 + 1) & 0x1F;
        if (v17 != v16)
        {
          v18 = v9 + 8;
          do
          {
            v19 = (_DWORD *)(v18 + 4 * v17);
            if ((unint64_t)v19 >= v10 || (unint64_t)v19 < v18)
              goto LABEL_57;
            v11 -= *v19;
            *v19 = 0;
            v17 = ((_BYTE)v17 + 1) & 0x1F;
          }
          while (v17 != v16);
        }
      }
    }
    else
    {
      v15 = -1;
    }
LABEL_51:
    v34 = v6 + v5;
    v35 = v11 + v34;
    pthread_mutex_lock((pthread_mutex_t *)(v9 + 160));
    *(_DWORD *)(v9 + 148) = v35;
    if (v15 != -1)
    {
      *(double *)(v9 + 136) = *(double *)v9 + (double)vcvtd_n_u64_f64(a4 - *(double *)v9, 6uLL) * 0.015625;
      *(_WORD *)(v9 + 144) = v15;
    }
    pthread_mutex_unlock((pthread_mutex_t *)(v9 + 160));
    v36 = (_DWORD *)(v9 + 8 + 4 * *(__int16 *)(v9 + 144));
    if ((unint64_t)v36 < v10 && (unint64_t)v36 >= v9 + 8)
    {
      *v36 += v34;
      return;
    }
LABEL_57:
    __break(0x5519u);
    return;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCMediaQueue_RateStats_TrackMediaPacket_cold_1();
  }
}

uint64_t _VCMediaQueue_PreAllocVCMediaPacketsInFreePool(uint64_t a1, opaqueCMSimpleQueue *a2)
{
  uint64_t v4;
  void *v5;
  _QWORD *v6;
  const void *v7;

  v4 = 2149580803;
  v5 = malloc_type_calloc(1uLL, 0x138uLL, 0x10A0040637F5F0DuLL);
  if (v5)
  {
    v6 = v5;
    if (*(_BYTE *)(a1 + 96)
      || (CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0x5DCuLL, 0, 0, 0, 0x5DCuLL, 1u, (CMBlockBufferRef *)v5 + 1), v6[1]))
    {
      if (!CMSimpleQueueEnqueue(a2, v6))
        return 0;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCMediaQueue_PreAllocVCMediaPacketsInFreePool_cold_2();
      }
      v7 = (const void *)v6[1];
      v4 = 2149580829;
      if (v7)
        CFRelease(v7);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCMediaQueue_PreAllocVCMediaPacketsInFreePool_cold_1();
    }
    free(v6);
  }
  return v4;
}

uint64_t VCMediaQueue_CleanupTxHistory(uint64_t a1)
{
  pthread_mutex_t *v2;

  v2 = (pthread_mutex_t *)(a1 + 25552);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 25552));
  bzero((void *)(a1 + 976), 0x6000uLL);
  *(_QWORD *)(a1 + 968) = 0;
  pthread_mutex_unlock(v2);
  return 0;
}

uint64_t _VCMediaQueue_CreateInternalQueue(uint64_t a1, uint64_t a2, int32_t a3)
{
  uint64_t v4;
  void *v6;
  uint64_t v7;
  const __CFAllocator *v8;
  uint64_t result;
  unint64_t v10;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  int32_t v24;
  unint64_t v25;
  opaqueCMSimpleQueue **v26;
  unint64_t v28;
  unint64_t v29;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;

  v4 = a2;
  v6 = malloc_type_calloc((int)a2, 0xB0uLL, 0x1020040A2190033uLL);
  if (!v6)
  {
    v4 = 2149580803;
LABEL_47:
    if (*(_QWORD *)(a1 + 624))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCMediaQueue_CreateInternalQueue_cold_1();
      }
      _VCMediaQueue_DestroyInternalQueues(a1);
      *(_QWORD *)(a1 + 624) = 0;
      *(_DWORD *)(a1 + 348) = 0;
    }
    return v4;
  }
  *(_QWORD *)(a1 + 624) = v6;
  *(_DWORD *)(a1 + 348) = v4;
  if (!(_DWORD)v4)
    return v4;
  v7 = 0;
  v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  while (1)
  {
    CMSimpleQueueCreate(v8, a3, (CMSimpleQueueRef *)(*(_QWORD *)(a1 + 624) + 176 * v7));
    CMSimpleQueueCreate(v8, a3, (CMSimpleQueueRef *)(*(_QWORD *)(a1 + 624) + 176 * v7 + 8));
    result = CMSimpleQueueCreate(v8, a3, (CMSimpleQueueRef *)(*(_QWORD *)(a1 + 624) + 176 * v7 + 16));
    v10 = *(_QWORD *)(a1 + 624);
    if (v10 + 176 * v7 >= v10 + 176 * *(unsigned int *)(a1 + 348) || v10 + 176 * v7 < v10)
      break;
    v12 = v10 + 176 * v7;
    *(_DWORD *)(v12 + 24) = 0;
    *(_QWORD *)(v12 + 136) = 0;
    *(_QWORD *)(v12 + 144) = 0;
    *(_QWORD *)(v12 + 128) = 0;
    v13 = *(_QWORD *)(a1 + 624);
    v14 = v13 + 176 * v7;
    if (v14 >= v13 + 176 * *(unsigned int *)(a1 + 348) || v14 < v13)
      break;
    v16 = v13 + 176 * v7;
    *(_DWORD *)(v16 + 152) = 0;
    *(_BYTE *)(v16 + 92) = 0;
    v17 = *(_QWORD *)(a1 + 624);
    v18 = v17 + 176 * v7;
    if (v18 >= v17 + 176 * *(unsigned int *)(a1 + 348) || v18 < v17)
      break;
    *(_BYTE *)(v17 + 176 * v7 + 93) = 0;
    v20 = *(_QWORD *)(a1 + 624);
    v21 = v20 + 176 * v7;
    if (v21 >= v20 + 176 * *(unsigned int *)(a1 + 348))
      break;
    if (v21 < v20)
      break;
    *(_BYTE *)(v20 + 176 * v7 + 96) = 0;
    v22 = *(_QWORD *)(a1 + 624);
    v23 = v22 + 176 * v7;
    if (v23 >= v22 + 176 * *(unsigned int *)(a1 + 348) || v23 < v22)
      break;
    *(_BYTE *)(v22 + 176 * v7 + 97) = 0;
    v24 = a3;
    if (a3 >= 1)
    {
      do
      {
        v25 = *(_QWORD *)(a1 + 624);
        v26 = (opaqueCMSimpleQueue **)(v25 + 176 * v7);
        if ((unint64_t)v26 >= v25 + 176 * *(unsigned int *)(a1 + 348) || (unint64_t)v26 < v25)
          goto LABEL_56;
        result = _VCMediaQueue_PreAllocVCMediaPacketsInFreePool(a1, *v26);
        if ((_DWORD)result)
        {
          v4 = result;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              _VCMediaQueue_CreateInternalQueue_cold_2();
          }
          goto LABEL_47;
        }
      }
      while (--v24);
    }
    v28 = *(_QWORD *)(a1 + 624);
    v29 = v28 + 176 * v7;
    if (v29 >= v28 + 176 * *(unsigned int *)(a1 + 348) || v29 < v28)
      break;
    *(_BYTE *)(v28 + 176 * v7 + 94) = 0;
    v31 = *(_QWORD *)(a1 + 624);
    v32 = v31 + 176 * v7;
    if (v32 >= v31 + 176 * *(unsigned int *)(a1 + 348))
      break;
    if (v32 < v31)
      break;
    *(_BYTE *)(v31 + 176 * v7 + 95) = 0;
    v33 = *(_QWORD *)(a1 + 624);
    v34 = v33 + 176 * v7;
    if (v34 >= v33 + 176 * *(unsigned int *)(a1 + 348))
      break;
    if (v34 < v33)
      break;
    *(_QWORD *)(v33 + 176 * v7 + 104) = -1;
    v35 = *(_QWORD *)(a1 + 624);
    v36 = v35 + 176 * v7;
    if (v36 >= v35 + 176 * *(unsigned int *)(a1 + 348))
      break;
    if (v36 < v35)
      break;
    *(_QWORD *)(v35 + 176 * v7 + 112) = -1;
    v37 = *(_QWORD *)(a1 + 624);
    v38 = v37 + 176 * v7;
    if (v38 >= v37 + 176 * *(unsigned int *)(a1 + 348) || v38 < v37)
      break;
    *(_DWORD *)(v37 + 176 * v7++ + 120) = 0;
    if (v7 == v4)
      return 0;
  }
LABEL_56:
  __break(0x5519u);
  return result;
}

void _VCMediaQueue_DestroyInternalQueues(uint64_t a1)
{
  opaqueCMSimpleQueue **v2;
  double v3;
  uint64_t v4;
  NSObject *v5;
  int v6;
  uint64_t i;
  opaqueCMSimpleQueue **v8;
  opaqueCMSimpleQueue **v9;
  CMSimpleQueueRef *v10;
  opaqueCMSimpleQueue *v11;
  CMSimpleQueueRef *v12;
  _QWORD *Head;
  uint64_t v14;
  NSObject *v15;
  OSStatus v16;
  NSObject *v17;
  const char *v18;
  uint32_t v19;
  uint64_t v20;
  opaqueCMSimpleQueue *v21;
  const void *v22;
  OSStatus v23;
  OSStatus v24;
  NSObject *v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint8_t buf[4];
  uint64_t v38;
  __int16 v39;
  const char *v40;
  __int16 v41;
  int v42;
  __int16 v43;
  OSStatus v44;
  __int16 v45;
  int v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  v36 = *(unsigned int *)(a1 + 348);
  v2 = *(opaqueCMSimpleQueue ***)(a1 + 624);
  v3 = 0.0;
  if (VRTraceIsInternalOSInstalled())
    v3 = micro();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(unsigned __int8 *)(a1 + 96);
      *(_DWORD *)buf = 136316162;
      v38 = v4;
      v39 = 2080;
      v40 = "_VCMediaQueue_DestroyInternalQueues";
      v41 = 1024;
      v42 = 1616;
      v43 = 1024;
      v44 = v36;
      v45 = 1024;
      v46 = v6;
      _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d numberOfInternalQueues=%d mediaQueue->config.useExternalDataBuffer=%d", buf, 0x28u);
    }
  }
  if ((int)v36 >= 1)
  {
    for (i = 0; i != v36; ++i)
    {
      v8 = &v2[22 * i];
      if (v8)
      {
        v9 = &v2[22 * i];
        v11 = v9[2];
        v10 = v9 + 2;
        if (CMSimpleQueueGetCount(v11) >= 1)
        {
          v12 = &v2[22 * i + 1];
          do
          {
            Head = CMSimpleQueueGetHead(*v10);
            CMSimpleQueueDequeue(*v10);
            if (Head == CMSimpleQueueGetHead(*v12))
            {
              v20 = Head[23];
              if (v20)
              {
                VCMediaControlInfoDispose(v20);
                Head[23] = 0;
              }
              _VCMediaQueue_ReleaseExternalDataBuffer(a1, (uint64_t)Head);
              v21 = *v8;
              v22 = CMSimpleQueueDequeue(*v12);
              v23 = CMSimpleQueueEnqueue(v21, v22);
              if (!v23)
                continue;
              v24 = v23;
              if ((int)VRTraceGetErrorLogLevelForModule() < 3)
                continue;
              v35 = VRTraceErrorLogLevelToCSTR();
              v25 = *MEMORY[0x1E0CF2758];
              if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                continue;
              v26 = *((_DWORD *)Head + 57);
              *(_DWORD *)buf = 136316162;
              v38 = v35;
              v39 = 2080;
              v40 = "_VCMediaQueue_FreeInternalQueueMediaPackets";
              v41 = 1024;
              v42 = 1654;
              v43 = 1024;
              v44 = v24;
              v45 = 1024;
              v46 = v26;
              v17 = v25;
              v18 = "VCMediaQueue [%s] %s:%d Internal queue has error=%d when free media packet for mediaQueueStreamId=%u"
                    " in _VCMediaQueue_FreeInternalQueueMediaPackets";
              v19 = 40;
            }
            else
            {
              if ((int)VRTraceGetErrorLogLevelForModule() < 3)
                continue;
              v14 = VRTraceErrorLogLevelToCSTR();
              v15 = *MEMORY[0x1E0CF2758];
              if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                continue;
              v16 = *((_DWORD *)Head + 57);
              *(_DWORD *)buf = 136315906;
              v38 = v14;
              v39 = 2080;
              v40 = "_VCMediaQueue_FreeInternalQueueMediaPackets";
              v41 = 1024;
              v42 = 1656;
              v43 = 1024;
              v44 = v16;
              v17 = v15;
              v18 = "VCMediaQueue [%s] %s:%d Media packets are drained from the busy pool of stream=%u out of order! in _"
                    "VCMediaQueue_FreeInternalQueueMediaPackets";
              v19 = 34;
            }
            _os_log_error_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_ERROR, v18, buf, v19);
          }
          while (CMSimpleQueueGetCount(*v10) > 0);
        }
        _VCMediaQueue_DestroyInternalQueuePool(a1, v2[22 * i + 1]);
        _VCMediaQueue_DestroyInternalQueuePool(a1, *v8);
        if (*v10)
          CFRelease(*v10);
      }
    }
  }
  free(v2);
  LogProfileTimeOverLimit_2(v3, v27, v28, v29, v30, v31, v32, v33, v34, (char)"_VCMediaQueue_DestroyInternalQueues");
}

void _VCMediaQueue_DestroyInternalQueuePool(uint64_t a1, opaqueCMSimpleQueue *a2)
{
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  char *v7;
  char *v8;
  const void *v9;
  int v10;
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int32_t Count;
  __int16 v18;
  opaqueCMSimpleQueue *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v4 = VRTraceErrorLogLevelToCSTR();
      v5 = *MEMORY[0x1E0CF2758];
      v6 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          v10 = 136316162;
          v11 = v4;
          v12 = 2080;
          v13 = "_VCMediaQueue_DestroyInternalQueuePool";
          v14 = 1024;
          v15 = 1597;
          v16 = 1024;
          Count = CMSimpleQueueGetCount(a2);
          v18 = 2048;
          v19 = a2;
          _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d count=%d in pool=%p", (uint8_t *)&v10, 0x2Cu);
        }
      }
      else if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        _VCMediaQueue_DestroyInternalQueuePool_cold_1(v4, a2, v5);
      }
    }
    if (CMSimpleQueueGetCount(a2) >= 1)
    {
      do
      {
        v7 = (char *)CMSimpleQueueDequeue(a2);
        if (v7)
        {
          v8 = v7;
          if (!*(_BYTE *)(a1 + 96))
          {
            v9 = (const void *)*((_QWORD *)v7 + 1);
            if (v9)
            {
              if (v8 >= v8 + 312)
                __break(0x5519u);
              CFRelease(v9);
            }
          }
          free(v8);
        }
      }
      while (CMSimpleQueueGetCount(a2) > 0);
    }
    CFRelease(a2);
  }
}

void LogProfileTimeOverLimit_2(double a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10)
{
  double v11;
  __int128 v12;
  uint64_t v13;
  NSObject *v14;
  uint8_t buf[4];
  uint64_t v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  char *v22;
  __int16 v23;
  double v24;
  char __str[16];
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  if (VRTraceIsInternalOSInstalled())
  {
    v11 = micro() - a1;
    if (v11 > 3.0)
    {
      *(_QWORD *)&v12 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v39 = v12;
      v40 = v12;
      v37 = v12;
      v38 = v12;
      v35 = v12;
      v36 = v12;
      v33 = v12;
      v34 = v12;
      v31 = v12;
      v32 = v12;
      v30 = v12;
      v28 = v12;
      v29 = v12;
      v26 = v12;
      v27 = v12;
      *(_OWORD *)__str = v12;
      vsnprintf(__str, 0x100uLL, "%s: done destroying numberOfInternalQueues=%d", &a10);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v13 = VRTraceErrorLogLevelToCSTR();
        v14 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316162;
          v16 = v13;
          v17 = 2080;
          v18 = "_LogProfileTimeLimitHelper";
          v19 = 1024;
          v20 = 36;
          v21 = 2080;
          v22 = __str;
          v23 = 2048;
          v24 = v11;
          _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d %s: Took a long time %fs", buf, 0x30u);
        }
      }
    }
  }
}

void _VCMediaQueue_CheckAndReportSymptomForInternalQueue(uint64_t a1)
{
  double v2;
  unsigned int v3;
  unint64_t v4;
  double *v5;
  unsigned int v7;
  int v8;
  double *v9;

  v2 = micro();
  v3 = *(_DWORD *)(a1 + 152);
  v4 = a1 + 128;
  v5 = (double *)(a1 + 128 + 8 * (v3 % 3));
  if ((unint64_t)v5 >= a1 + 152 || (unint64_t)v5 < v4)
  {
LABEL_15:
    __break(0x5519u);
    return;
  }
  *v5 = v2;
  v7 = v3 + 1;
  v8 = *(_DWORD *)(a1 + 156) + 1;
  *(_DWORD *)(a1 + 152) = v7;
  *(_DWORD *)(a1 + 156) = v8;
  if (v7 >= 3)
  {
    v9 = (double *)(v4 + 8 * (v7 % 3));
    if ((unint64_t)v9 >= a1 + 152 || (unint64_t)v9 < v4)
      goto LABEL_15;
    if (v2 - *v9 <= 5.0)
      reportingSymptom();
  }
}

uint64_t _VCMediaQueue_GetGeneralQueueInfo(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  double v5;

  if (*(_DWORD *)(result + 348))
  {
    v1 = result;
    v2 = 0;
    v3 = 0;
    do
    {
      v4 = *(_QWORD *)(v1 + 624) + v2;
      result = CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(v4 + 16));
      *(_DWORD *)(v1 + 440) += result;
      v5 = *(double *)(v1 + 592);
      if (v5 <= *(double *)(v4 + 48))
        v5 = *(double *)(v4 + 48);
      *(double *)(v1 + 592) = v5;
      ++v3;
      v2 += 176;
    }
    while (v3 < *(unsigned int *)(v1 + 348));
  }
  return result;
}

void _VCMediaQueue_ResetStatistics(uint64_t a1)
{
  __int128 v1;
  uint64_t v3;
  unint64_t v4;
  os_log_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  uint8_t buf[4];
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)(a1 + 484) = 0;
  *(_QWORD *)(a1 + 476) = 0;
  *(_QWORD *)(a1 + 492) = 0;
  *(_DWORD *)(a1 + 336) = 0;
  *(_DWORD *)(a1 + 344) = 0;
  *(_DWORD *)(a1 + 600) = 0;
  v1 = *(_OWORD *)(a1 + 428);
  *(_OWORD *)(a1 + 444) = *(_OWORD *)(a1 + 412);
  *(_OWORD *)(a1 + 460) = v1;
  *(_QWORD *)(a1 + 592) = 0;
  if (*(_DWORD *)(a1 + 348))
  {
    v3 = 0;
    v4 = 0;
    v5 = (os_log_t *)MEMORY[0x1E0CF2758];
    do
    {
      v6 = *(_QWORD *)(a1 + 624);
      if (v6 + v3)
      {
        v7 = v6 + v3;
        *(_DWORD *)(v7 + 76) = 0;
        *(_DWORD *)(v7 + 80) = 0;
        *(_QWORD *)(v7 + 48) = 0;
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v8 = VRTraceErrorLogLevelToCSTR();
        v9 = *v5;
        if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315906;
          v11 = v8;
          v12 = 2080;
          v13 = "_VCMediaQueue_ResetStatistics";
          v14 = 1024;
          v15 = 1868;
          v16 = 1024;
          v17 = v4;
          _os_log_error_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_ERROR, "VCMediaQueue [%s] %s:%d Internal queue with index %d is NULL", buf, 0x22u);
        }
      }
      ++v4;
      v3 += 176;
    }
    while (v4 < *(unsigned int *)(a1 + 348));
  }
}

void _VCMediaQueue_DumpStatisticsToFile(uint64_t a1)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  if (!*(_QWORD *)(a1 + 168)
    || (_VCMediaQueue_GetGeneralQueueInfo(a1),
        VRLogfilePrintWithTimestamp(*(_QWORD *)(a1 + 168), "%1u\t%4.3f\t%u\t%u\t%u/%u/%u/%u\t%08X\t%08X\t%u\t%.3f\t%1u\t%u/%u\t%u/%u\t%5u/%5u\t%.2f\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n", *(unsigned __int8 *)(a1 + 498), *(unsigned __int8 *)(a1 + 499), *(unsigned __int16 *)(a1 + 496), *(unsigned int *)(a1 + 336), *(unsigned int *)(a1 + 340), *(unsigned int *)(a1 + 344), *(_DWORD *)(a1 + 88)), v2 = *(unsigned int *)(a1 + 348), !(_DWORD)v2))
  {
LABEL_10:
    _VCMediaQueue_ResetStatistics(a1);
    return;
  }
  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = a1 + 632;
  while (1)
  {
    v7 = *(_QWORD *)(a1 + 624);
    if (!(v7 + v4) || *(double *)(v7 + v4 + 48) <= 0.1)
      goto LABEL_9;
    CMSimpleQueueGetHead(*(CMSimpleQueueRef *)(v7 + v4 + 16));
    if (v6 + v3 >= a1 + 760 || v6 + v3 < v6)
      break;
    VRLogfilePrint(*(_QWORD *)(a1 + 168), "[InternalQueue]\t%2u\t%1u\t%d\t%u/%u\t%u\t%u\t%u\t%u\n", v8, v9, v10, v11, v12, v13, v5);
    v2 = *(unsigned int *)(a1 + 348);
LABEL_9:
    ++v5;
    v4 += 176;
    v3 += 4;
    if (v5 >= v2)
      goto LABEL_10;
  }
  __break(0x5519u);
}

void _VCMediaQueue_ReleaseLogDumpFile(uint64_t a1)
{
  FILE ***v1;
  __int128 v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _OWORD v9[8];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v1 = (FILE ***)(a1 + 168);
  if (*(_QWORD *)(a1 + 168))
  {
    *(_QWORD *)&v2 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v9[6] = v2;
    v9[7] = v2;
    v9[4] = v2;
    v9[5] = v2;
    v9[2] = v2;
    v9[3] = v2;
    v9[0] = v2;
    v9[1] = v2;
    micro();
    VRLogfileGetTimestamp((char *)v9, 0x80u);
    VRLogfilePrintSync(*v1, "%s\t%8.3f\tEndOfFile\n", v3, v4, v5, v6, v7, v8, (char)v9);
    VRLogfileFree((uint64_t *)v1);
    *v1 = 0;
  }
}

FILE **_VCMediaQueue_CreateLogDumpFile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  FILE **v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char v24;

  v10 = VRLogfileAlloc(0, a2, (uint64_t)"VCMediaQueue", (uint64_t)".mqdump", "com.apple.VideoConference.VCMediaQueuelog", 9);
  *(_QWORD *)(a1 + 168) = v10;
  VRLogfilePrintSync(v10, "STime\t\tSchedulePolicy\tExpInterval\tPBR\tIBR\tBudgetTuple\tIDRBitmap\tSendBitmap\tPktLeft\tWQSize\tBundlePolicy\tPktCount\tNetworkOverhead\tTotalSize\tPBAFactor\thasIDR\thasServerStats\tAudioSeq\tAudioPkt\tVideoPkt\tProbPkt\tScreenPkt\tFailedPkt\n", v11, v12, v13, v14, v15, v16, v24);
  return VRLogfilePrintSync(*(FILE ***)(a1 + 168), "[InternalQueue]\tIndex\tType\tStreamId\tQSizeTuple\tOldTS\tIDR\tPktSch\tLastSchTS\tProbingSeq\n", v17, v18, v19, v20, v21, v22, a9);
}

double VCMediaQueue_GetPreSetConfiguration@<D0>(uint64_t a1@<X8>)
{
  double result;

  *(_OWORD *)(a1 + 64) = xmmword_1E9E576C8;
  *(_OWORD *)(a1 + 80) = unk_1E9E576D8;
  *(_OWORD *)(a1 + 96) = xmmword_1E9E576E8;
  *(_QWORD *)(a1 + 112) = 0;
  *(_OWORD *)a1 = xmmword_1E9E57688;
  *(_OWORD *)(a1 + 16) = unk_1E9E57698;
  result = 0.5;
  *(_OWORD *)(a1 + 32) = xmmword_1E9E576A8;
  *(_OWORD *)(a1 + 48) = unk_1E9E576B8;
  return result;
}

unint64_t VCMediaQueue_Create(unint64_t *a1, unsigned int *a2)
{
  uint64_t v2;
  unint64_t result;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  uint64_t InternalQueue;
  int AppBooleanValue;
  uint64_t v19;
  NSObject *v20;
  int v21;
  unint64_t v22;
  uint64_t v23;
  double v24;
  double v25;
  double v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  void *v34;
  int ErrorLogLevelForModule;
  uint64_t v36;
  NSObject *v37;
  double v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  NSObject *v44;
  int v45;
  int v46;
  unsigned int v47;
  char v48;
  Boolean keyExistsAndHasValidFormat;
  uint8_t buf[4];
  uint64_t v51;
  __int16 v52;
  const char *v53;
  __int16 v54;
  int v55;
  __int16 v56;
  int v57;
  __int16 v58;
  int v59;
  __int16 v60;
  unsigned int v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  if (*a2 > 0x20)
  {
    v2 = 2149580801;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCMediaQueue_Create_cold_1();
    }
    return v2;
  }
  if (_VCMediaQueueGetTypeID_initOnce != -1)
    dispatch_once_f(&_VCMediaQueueGetTypeID_initOnce, &_VCMediaQueueGetTypeID_typeID, (dispatch_function_t)_VCMediaQueueClassRegister);
  result = _CFRuntimeCreateInstance();
  if (!result)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      return 2149580803;
    VRTraceErrorLogLevelToCSTR();
    v2 = 2149580803;
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCMediaQueue_Create_cold_2();
    return v2;
  }
  v6 = result;
  v7 = result + 25736;
  v8 = result + 16;
  if (result + 16 <= result + 25736 && result < v8)
  {
    bzero((void *)(result + 16), 0x6478uLL);
    v10 = *((_OWORD *)a2 + 4);
    v11 = *((_OWORD *)a2 + 5);
    v12 = *((_OWORD *)a2 + 6);
    *(_QWORD *)(v8 + 112) = *((_QWORD *)a2 + 14);
    *(_OWORD *)(v8 + 96) = v12;
    v13 = *(_OWORD *)a2;
    v14 = *((_OWORD *)a2 + 1);
    v15 = *((_OWORD *)a2 + 3);
    *(_OWORD *)(v8 + 32) = *((_OWORD *)a2 + 2);
    *(_OWORD *)(v8 + 48) = v15;
    *(_OWORD *)v8 = v13;
    *(_OWORD *)(v8 + 16) = v14;
    *(_OWORD *)(v8 + 64) = v10;
    *(_OWORD *)(v8 + 80) = v11;
    result = *(_QWORD *)(v6 + 120);
    if (result)
      result = (unint64_t)CFRetain((CFTypeRef)result);
    if (v6 < v7)
    {
      v16 = *MEMORY[0x1E0C9AE00];
      if (CMSimpleQueueCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 900, (CMSimpleQueueRef *)(v6 + 616)))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() < 3)
        {
          v2 = 2149580803;
        }
        else
        {
          VRTraceErrorLogLevelToCSTR();
          v2 = 2149580803;
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCMediaQueue_Create_cold_8();
        }
      }
      else
      {
        InternalQueue = _VCMediaQueue_CreateInternalQueue(v6, *a2, 3000);
        if ((_DWORD)InternalQueue)
        {
          v2 = InternalQueue;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VCMediaQueue_Create_cold_7();
          }
        }
        else
        {
          keyExistsAndHasValidFormat = 0;
          AppBooleanValue = CFPreferencesGetAppBooleanValue(CFSTR("disableMQPacketBundling"), CFSTR("com.apple.VideoConference"), &keyExistsAndHasValidFormat);
          if (keyExistsAndHasValidFormat && AppBooleanValue)
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v19 = VRTraceErrorLogLevelToCSTR();
              v20 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315650;
                v51 = v19;
                v52 = 2080;
                v53 = "VCMediaQueue_Create";
                v54 = 1024;
                v55 = 2011;
                _os_log_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d VCMediaQueue: Force Disabling Packet Bundling", buf, 0x1Cu);
              }
            }
            v21 = 0;
            *(_DWORD *)(v6 + 92) = 0;
          }
          else
          {
            v21 = *(_DWORD *)(v6 + 92);
          }
          v22 = VCMediaQueuePacketBundler_Create(v16, (_QWORD *)(v6 + 136), v21, 1500);
          if ((_DWORD)v22)
          {
            v2 = v22;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                VCMediaQueue_Create_cold_6();
            }
          }
          else
          {
            v23 = VCRealTimeThread_Initialize(19, (uint64_t)VCMediaQueueSendProc, v6, "com.apple.AVConference.VCMediaQueueSendProc", 3);
            *(_QWORD *)(v6 + 768) = v23;
            if (v23)
            {
              *(_BYTE *)(v6 + 280) = 0;
              *(_QWORD *)(v6 + 284) = 1000000;
              *(_DWORD *)(v6 + 296) = 0;
              *(_WORD *)(v6 + 300) = 0;
              *(_DWORD *)(v6 + 760) = 0;
              *(_BYTE *)(v6 + 292) = 0;
              *(_BYTE *)(v6 + 764) = 1;
              *(_BYTE *)(v6 + 888) = 0;
              *(_DWORD *)(v6 + 304) = a2[17];
              *(_BYTE *)(v6 + 302) = 0;
              *(_QWORD *)(v6 + 376) = 0x3FF0000000000000;
              v24 = *((double *)a2 + 6);
              if (v24 <= 0.0)
                v24 = 2.0;
              *(double *)(v6 + 368) = v24;
              FigCFWeakReferenceStore();
              v25 = micro();
              v26 = *((double *)a2 + 1);
              *(double *)(v6 + 312) = v25 + v26;
              *(double *)(v6 + 352) = v26;
              pthread_mutex_init((pthread_mutex_t *)(v6 + 216), 0);
              pthread_mutex_init((pthread_mutex_t *)(v6 + 776), 0);
              pthread_cond_init((pthread_cond_t *)(v6 + 840), 0);
              pthread_cond_init((pthread_cond_t *)(v6 + 896), 0);
              pthread_mutex_init((pthread_mutex_t *)(v6 + 25552), 0);
              pthread_mutex_init((pthread_mutex_t *)(v6 + 25632), 0);
              if (!*((_BYTE *)a2 + 112)
                || (*(_DWORD *)buf = -1,
                    v33 = _VCMediaQueue_RegisterStream(v6, 0, (signed int *)buf),
                    !(v33 | *(_DWORD *)buf)))
              {
                if (*((_BYTE *)a2 + 96))
                  _VCMediaQueue_CreateLogDumpFile(v6, *((_QWORD *)a2 + 11), v27, v28, v29, v30, v31, v32, v48);
                v34 = malloc_type_malloc(0x380uLL, 0x100004097079494uLL);
                *(_QWORD *)(v6 + 160) = v34;
                ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
                if (v34)
                {
                  if (ErrorLogLevelForModule >= 7)
                  {
                    v36 = VRTraceErrorLogLevelToCSTR();
                    v37 = *MEMORY[0x1E0CF2758];
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 136315650;
                      v51 = v36;
                      v52 = 2080;
                      v53 = "_VCMediaQueue_RateStats_Init";
                      v54 = 1024;
                      v55 = 2429;
                      _os_log_impl(&dword_1D8A54000, v37, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d VCMediaQueue IN/OUT RealTime stats are ENABLED", buf, 0x1Cu);
                    }
                  }
                  v38 = micro();
                  v39 = *(_QWORD *)(v6 + 160);
                  *(_OWORD *)(v39 + 8) = 0u;
                  *(_OWORD *)(v39 + 24) = 0u;
                  *(_OWORD *)(v39 + 40) = 0u;
                  *(_OWORD *)(v39 + 56) = 0u;
                  *(_OWORD *)(v39 + 72) = 0u;
                  *(_OWORD *)(v39 + 88) = 0u;
                  *(_OWORD *)(v39 + 104) = 0u;
                  *(_OWORD *)(v39 + 120) = 0u;
                  *(_WORD *)(v39 + 144) = 0;
                  *(double *)v39 = v38;
                  *(double *)(v39 + 136) = v38;
                  *(_QWORD *)(v39 + 148) = 0x100000000;
                  *(_DWORD *)(v39 + 156) = 0;
                  pthread_mutex_init((pthread_mutex_t *)(v39 + 160), 0);
                  v40 = *(_QWORD *)(v6 + 160);
                  *(double *)(v40 + 224) = v38;
                  v40 += 224;
                  *(_OWORD *)(v40 + 8) = 0u;
                  *(_OWORD *)(v40 + 24) = 0u;
                  *(_OWORD *)(v40 + 40) = 0u;
                  *(_OWORD *)(v40 + 56) = 0u;
                  *(_OWORD *)(v40 + 72) = 0u;
                  *(_OWORD *)(v40 + 88) = 0u;
                  *(_OWORD *)(v40 + 104) = 0u;
                  *(_OWORD *)(v40 + 120) = 0u;
                  *(_DWORD *)(v40 + 148) = 0;
                  *(_WORD *)(v40 + 144) = 0;
                  *(double *)(v40 + 136) = v38;
                  *(_QWORD *)(v40 + 152) = 0;
                  pthread_mutex_init((pthread_mutex_t *)(v40 + 160), 0);
                  v41 = *(_QWORD *)(v6 + 160);
                  *(_OWORD *)(v41 + 456) = 0u;
                  *(_OWORD *)(v41 + 472) = 0u;
                  *(_OWORD *)(v41 + 488) = 0u;
                  *(_OWORD *)(v41 + 504) = 0u;
                  *(_OWORD *)(v41 + 520) = 0u;
                  *(_OWORD *)(v41 + 536) = 0u;
                  *(_OWORD *)(v41 + 552) = 0u;
                  *(_OWORD *)(v41 + 568) = 0u;
                  *(_DWORD *)(v41 + 596) = 0;
                  *(_WORD *)(v41 + 592) = 0;
                  *(double *)(v41 + 448) = v38;
                  *(double *)(v41 + 584) = v38;
                  *(_QWORD *)(v41 + 600) = 1;
                  pthread_mutex_init((pthread_mutex_t *)(v41 + 608), 0);
                  v42 = *(_QWORD *)(v6 + 160);
                  *(_OWORD *)(v42 + 680) = 0u;
                  *(_OWORD *)(v42 + 696) = 0u;
                  *(_OWORD *)(v42 + 712) = 0u;
                  *(_OWORD *)(v42 + 728) = 0u;
                  *(_OWORD *)(v42 + 744) = 0u;
                  *(_OWORD *)(v42 + 760) = 0u;
                  *(_OWORD *)(v42 + 776) = 0u;
                  *(_OWORD *)(v42 + 792) = 0u;
                  *(_DWORD *)(v42 + 820) = 0;
                  *(_WORD *)(v42 + 816) = 0;
                  *(double *)(v42 + 672) = v38;
                  *(double *)(v42 + 808) = v38;
                  *(_QWORD *)(v42 + 824) = 0;
                  pthread_mutex_init((pthread_mutex_t *)(v42 + 832), 0);
                }
                else if (ErrorLogLevelForModule >= 3)
                {
                  VRTraceErrorLogLevelToCSTR();
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                    VCMediaQueue_Create_cold_4();
                }
                reportingRegisterPeriodicTaskWeak();
                if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
                {
                  v43 = VRTraceErrorLogLevelToCSTR();
                  v44 = *MEMORY[0x1E0CF2758];
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                  {
                    v45 = *a2;
                    v46 = *((unsigned __int8 *)a2 + 112);
                    v47 = a2[18];
                    *(_DWORD *)buf = 136316418;
                    v51 = v43;
                    v52 = 2080;
                    v53 = "VCMediaQueue_Create";
                    v54 = 1024;
                    v55 = 2061;
                    v56 = 1024;
                    v57 = v45;
                    v58 = 1024;
                    v59 = v46;
                    v60 = 1024;
                    v61 = v47;
                    _os_log_impl(&dword_1D8A54000, v44, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d VCMediaQueue created successfully with 1 main queue, %d internal queues isRTXEnabled=%d schedulePolicy=%d", buf, 0x2Eu);
                  }
                }
                v2 = 0;
                *a1 = v6;
                return v2;
              }
              v2 = v33;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  VCMediaQueue_Create_cold_5();
              }
            }
            else
            {
              v2 = 2149580801;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  VCMediaQueue_Create_cold_3();
              }
            }
          }
        }
      }
      CFRelease((CFTypeRef)v6);
      return v2;
    }
  }
  __break(0x5519u);
  return result;
}

void VCMediaQueueSendProc(unint64_t a1, uint64_t a2, _BYTE *a3)
{
  unint64_t v4;
  unsigned __int8 v5;
  int32_t Count;
  unsigned __int8 v7;
  int32_t v8;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  pthread_mutex_t *v14;
  int v15;
  double v16;
  double v17;
  uint64_t v18;
  uint64_t v19;
  unsigned __int8 *v20;
  unsigned __int8 v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unsigned __int8 *v28;
  unsigned __int8 v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t *v36;
  uint64_t v37;
  double v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v45;
  unint64_t v46;
  opaqueCMSimpleQueue *v47;
  unsigned int v48;
  unsigned int v49;
  _DWORD *Head;
  unint64_t v52;
  unsigned __int8 v53;
  unsigned int v54;
  unsigned int v55;
  double v56;
  int v57;
  uint64_t v58;
  double v59;
  int v60;
  unsigned int v61;
  unsigned int v62;
  unint64_t v63;
  unsigned int *v64;
  int v65;
  unsigned int v66;
  uint64_t v67;
  NSObject *v68;
  unsigned int v69;
  const void *v70;
  double *v71;
  double v72;
  double v73;
  double v74;
  unint64_t v75;
  unsigned __int8 v76;
  uint64_t v77;
  double v78;
  unsigned int v79;
  uint64_t v80;
  unsigned int v81;
  BOOL v82;
  uint64_t v83;
  int v84;
  unint64_t v85;
  unint64_t v86;
  unsigned int v87;
  unsigned int v88;
  unsigned int *v89;
  uint64_t v90;
  uint64_t v91;
  int v92;
  _DWORD *v93;
  unint64_t v94;
  unint64_t v95;
  unsigned __int8 v96;
  double v97;
  double v98;
  uint64_t v99;
  NSObject *v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  NSObject *v104;
  uint64_t v105;
  uint64_t v106;
  int v107;
  unint64_t v108;
  unsigned int v109;
  _QWORD v110[9];
  _QWORD v111[4];
  uint64_t v112;
  uint64_t *v113;
  uint64_t v114;
  uint64_t v115;
  _BYTE v116[22];
  __int16 v117;
  int v118;
  __int16 v119;
  _BYTE v120[10];
  _BYTE v121[10];
  unsigned int v122;
  __int16 v123;
  int v124;
  uint64_t v125;

  v125 = *MEMORY[0x1E0C80C00];
  v4 = a1 + 25736;
  v5 = atomic_load((unsigned __int8 *)(a1 + 764));
  if ((v5 & 1) != 0)
  {
    _VCMediaQueue_FlushPacketsFromQueue(a1);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 776));
    *a3 = 1;
    *(_BYTE *)(a1 + 944) = 1;
    if (v4 <= a1)
      goto LABEL_131;
    pthread_cond_signal((pthread_cond_t *)(a1 + 896));
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 776));
    return;
  }
  if (v4 <= a1)
    goto LABEL_131;
  Count = CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 616));
  v7 = atomic_load((unsigned __int8 *)(a1 + 888));
  if ((v7 & 1) != 0)
  {
    v10 = *(unsigned int *)(a1 + 348);
    if (!(_DWORD)v10)
    {
      v14 = (pthread_mutex_t *)(a1 + 776);
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 776));
LABEL_15:
      v16 = *(double *)(a1 + 312);
      v17 = v16 - micro();
      if (v17 <= 0.0)
      {
        v15 = 60;
      }
      else
      {
        convertTimeoutToRelativeTimespec(v17);
        *(_QWORD *)v116 = v18;
        *(_QWORD *)&v116[8] = v19;
        v15 = pthread_cond_timedwait_relative_np((pthread_cond_t *)(a1 + 840), v14, (const timespec *)v116);
      }
      goto LABEL_18;
    }
    v11 = 0;
    v12 = 0;
    v8 = 0;
    do
    {
      v13 = *(_QWORD *)(a1 + 624) + v11;
      if (!*(_BYTE *)(v13 + 168))
      {
        v8 += CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(v13 + 16));
        v10 = *(unsigned int *)(a1 + 348);
      }
      ++v12;
      v11 += 176;
    }
    while (v12 < v10);
  }
  else
  {
    v8 = Count;
  }
  v14 = (pthread_mutex_t *)(a1 + 776);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 776));
  if (!v8)
    goto LABEL_15;
  v15 = 0;
LABEL_18:
  pthread_mutex_unlock(v14);
  v20 = (unsigned __int8 *)(a1 + 292);
  do
    v21 = __ldaxr(v20);
  while (__stlxr(0, v20));
  if ((v21 & 1) != 0)
  {
    ++*(_DWORD *)(a1 + 328);
    _VCMediaQueue_FlushPacketsFromQueue(a1);
  }
  v22 = atomic_load((unsigned int *)(a1 + 760));
  if ((int)v22 >= 1)
  {
    v23 = 0;
    while (1)
    {
      v24 = *(_QWORD *)(a1 + 624);
      v25 = v24 + 176 * *(unsigned int *)(a1 + 348);
      v26 = v24 + 176 * v23;
      if (v24 > v26 || v26 + 176 > v25)
        break;
      v28 = (unsigned __int8 *)(v24 + 176 * v23 + 94);
      do
        v29 = __ldaxr(v28);
      while (__stlxr(0, v28));
      if ((v29 & 1) != 0)
      {
        if (v26 && v26 >= v25)
          break;
        _VCMediaQueue_FlushInternalQueueBeforeTimestamp(v26, a1, -1);
      }
      if (++v23 == v22)
        goto LABEL_35;
    }
LABEL_131:
    __break(0x5519u);
  }
LABEL_35:
  v30 = atomic_load((unsigned int *)(a1 + 760));
  if ((_DWORD)v30)
  {
    v31 = 0;
    do
    {
      v32 = *(_QWORD *)(a1 + 624);
      v33 = v32 + 176 * *(unsigned int *)(a1 + 348);
      v34 = v32 + 176 * v31;
      if (v32 > v34 || v34 + 176 > v33)
        goto LABEL_131;
      v36 = (unint64_t *)(v32 + 176 * v31 + 112);
      do
        v37 = __ldaxr(v36);
      while (__stlxr(0xFFFFFFFFFFFFFFFFLL, v36));
      if (v37 != -1)
      {
        if (v34 && v34 >= v33)
          goto LABEL_131;
        _VCMediaQueue_FlushInternalQueueBeforeTimestamp(v34, a1, v37);
      }
    }
    while (++v31 != v30);
  }
  v107 = v15;
  v108 = v4;
  v38 = micro();
  if (v38 - *(double *)(a1 + 608) > *(double *)(a1 + 56))
  {
    v39 = *(unsigned int *)(a1 + 348);
    if ((_DWORD)v39)
    {
      v40 = 0;
      while (1)
      {
        v41 = *(_QWORD *)(a1 + 624);
        v42 = v41 + 176 * *(unsigned int *)(a1 + 348);
        v43 = v41 + 176 * v40;
        if (v41 > v43 || v43 + 176 > v42)
          goto LABEL_131;
        v45 = v41 + 176 * v40;
        v47 = *(opaqueCMSimpleQueue **)(v45 + 16);
        v46 = v45 + 16;
        v48 = CMSimpleQueueGetCount(v47);
        v49 = v48;
        if (*(_DWORD *)(v46 + 8) && v48 >= 2)
          break;
LABEL_87:
        v75 = v41 + 176 * v40;
        ++*(_DWORD *)(v75 + 72);
        *(_DWORD *)(v75 + 76) = v49;
        if (++v40 == v39)
          goto LABEL_88;
      }
      Head = CMSimpleQueueGetHead(*(CMSimpleQueueRef *)v46);
      v52 = v41 + 176 * v40;
      v53 = atomic_load((unsigned __int8 *)(v52 + 96));
      v54 = atomic_load((unsigned int *)(v52 + 120));
      v55 = *(_DWORD *)(v52 + 88);
      if (v55)
      {
        v56 = (double)(v54 - Head[59]) / (double)v55;
        if (!v43)
          goto LABEL_65;
      }
      else
      {
        v56 = 0.0;
        if (!v43)
          goto LABEL_65;
      }
      if (v43 >= v42)
        goto LABEL_131;
LABEL_65:
      v57 = *(_DWORD *)(v41 + 176 * v40 + 124);
      v58 = 40;
      if ((v53 & 1) == 0)
        v58 = 32;
      v59 = *(double *)(a1 + v58);
      v60 = v59 <= v56;
      if ((v53 & 1) != 0 && v59 > v56)
      {
        if (!*(_BYTE *)(a1 + 129))
          goto LABEL_83;
        v61 = (*(double *)(a1 + 48) * 1000.0);
        v62 = 1;
        do
          v62 += v61;
        while (v62 < (v56 * 1000.0));
        v63 = v41 + 176 * v40;
        v65 = *(_DWORD *)(v63 + 164);
        v64 = (unsigned int *)(v63 + 164);
        v66 = v62 - v61;
        if (v66 == v65)
        {
LABEL_83:
          v71 = (double *)(v41 + 176 * v40);
          v72 = v71[8];
          v73 = v56 + v71[7];
          v71[6] = v56;
          v71[7] = v73;
          if (v72 <= v56)
            v74 = v56;
          else
            v74 = v72;
          v71[8] = v74;
          goto LABEL_87;
        }
        *v64 = v66;
        if ((int)VRTraceGetErrorLogLevelForModule() < 7)
        {
          v60 = 2;
        }
        else
        {
          v67 = VRTraceErrorLogLevelToCSTR();
          v68 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v69 = *v64;
            *(_DWORD *)v116 = 136316418;
            *(_QWORD *)&v116[4] = v67;
            *(_WORD *)&v116[12] = 2080;
            *(_QWORD *)&v116[14] = "_VCMediaQueue_CheckQueueThresholdExceededForInternalQueue";
            v117 = 1024;
            v118 = 1789;
            v119 = 1024;
            *(_DWORD *)v120 = v57;
            *(_WORD *)&v120[4] = 1024;
            *(_DWORD *)&v120[6] = v69;
            *(_WORD *)v121 = 2048;
            *(double *)&v121[2] = v56;
            _os_log_impl(&dword_1D8A54000, v68, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d VCMediaQueue size changes step with mediaQueueStreamId=%u quantizedQueueSize=%dms queueSizeInSecond=%f", v116, 0x32u);
          }
          v60 = 2;
        }
      }
      if (*(_QWORD *)(a1 + 152) && (v60 - 1) <= 1)
      {
        v70 = (const void *)MEMORY[0x1DF086F1C](a1 + 144);
        (*(void (**)(double))(*(_QWORD *)(a1 + 152) + 16))(v56);
        if (v70)
          CFRelease(v70);
        *(double *)(a1 + 608) = v38;
        _VCMediaQueue_ReportingEvent((_DWORD *)a1, 193, v57);
      }
      goto LABEL_83;
    }
  }
LABEL_88:
  v76 = atomic_load((unsigned __int8 *)(a1 + 280));
  if ((v76 & 1) != 0 || v107 == 60)
  {
    *(_BYTE *)(a1 + 309) = v107 == 60;
    _VCMediaQueue_SchedulePackets(a1);
  }
  v112 = 0;
  v113 = &v112;
  v114 = 0x2000000000;
  v115 = 0;
  v111[0] = 0;
  v111[1] = v111;
  v111[2] = 0x2000000000;
  v111[3] = &v115;
  v77 = *(_QWORD *)(a1 + 136);
  v110[0] = MEMORY[0x1E0C809B0];
  v110[1] = 0x40000000;
  v110[2] = __VCMediaQueueSendProc_block_invoke;
  v110[3] = &unk_1E9E57708;
  v110[6] = a1;
  v110[7] = v108;
  v110[8] = a1;
  v110[4] = &v112;
  v110[5] = v111;
  VCMediaQueuePacketBundler_BundlePackets(v77, (uint64_t)v110);
  if (CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 616)) >= 1)
  {
    v78 = *(double *)(a1 + 72);
    if (v78 == 0.0)
    {
      _VCMediaQueue_DrainAllPacketsFromMainQueue(a1);
    }
    else
    {
      v79 = CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 616));
      v80 = fmin((*(double *)(a1 + 360) + 1.0) / v78, 4.0);
      v109 = v79;
      if (v79 / v80 + 1 > *(_DWORD *)(a1 + 80))
        v81 = v79 / v80 + 1;
      else
        v81 = *(_DWORD *)(a1 + 80);
      if (v81)
        v82 = (_DWORD)v80 == 0;
      else
        v82 = 1;
      if (v82)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v99 = VRTraceErrorLogLevelToCSTR();
          v100 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            v101 = *(_QWORD *)(a1 + 72);
            v102 = *(_QWORD *)(a1 + 360);
            *(_DWORD *)v116 = 136316162;
            *(_QWORD *)&v116[4] = v99;
            *(_WORD *)&v116[12] = 2080;
            *(_QWORD *)&v116[14] = "_VCMediaQueue_PacePacketSendFromMainQueue";
            v117 = 1024;
            v118 = 469;
            v119 = 2048;
            *(_QWORD *)v120 = v101;
            *(_WORD *)&v120[8] = 2048;
            *(_QWORD *)v121 = v102;
            _os_log_error_impl(&dword_1D8A54000, v100, OS_LOG_TYPE_ERROR, "VCMediaQueue [%s] %s:%d packetSendPacingInterval=%f is set too big compared to the expectedScheduleInterval=%f", v116, 0x30u);
          }
        }
      }
      else
      {
        v83 = 0;
        v84 = 0;
        v85 = a1 + 396;
        v86 = a1 + 412;
        *(_QWORD *)(a1 + 404) = 0;
        *(_QWORD *)(a1 + 396) = 0;
        while (1)
        {
          v87 = CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 616));
          v88 = v81;
          if (v87 < v81)
            break;
          do
          {
            CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 616));
            _VCMediaQueue_SendAndFreePackets(a1);
            ++*(_DWORD *)(a1 + 436);
            --v88;
          }
          while (v88);
          v89 = (unsigned int *)(v85 + 4 * v83);
          if ((unint64_t)v89 >= v86 || (unint64_t)v89 < v85)
            goto LABEL_131;
          *v89 = v81;
          pthread_mutex_lock((pthread_mutex_t *)(a1 + 776));
          if (CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 616)) >= 1)
          {
            memset(v116, 170, 16);
            convertTimeoutToRelativeTimespec(v78);
            *(_QWORD *)v116 = v90;
            *(_QWORD *)&v116[8] = v91;
            pthread_cond_timedwait_relative_np((pthread_cond_t *)(a1 + 840), (pthread_mutex_t *)(a1 + 776), (const timespec *)v116);
          }
          v84 += v81;
          pthread_mutex_unlock((pthread_mutex_t *)(a1 + 776));
          if (++v83 == v80)
            goto LABEL_114;
        }
        if (v87)
        {
          v92 = _VCMediaQueue_DrainAllPacketsFromMainQueue(a1);
          v93 = (_DWORD *)(v85 + 4 * v83);
          if ((unint64_t)v93 >= v86 || (unint64_t)v93 < v85)
            goto LABEL_131;
          v84 += v92;
          *v93 = v92;
        }
LABEL_114:
        if (v109 != v84 && (int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          v103 = VRTraceErrorLogLevelToCSTR();
          v104 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v105 = *(_QWORD *)(a1 + 360);
            v106 = *(_QWORD *)(a1 + 72);
            *(_DWORD *)v116 = 136316674;
            *(_QWORD *)&v116[4] = v103;
            *(_WORD *)&v116[12] = 2080;
            *(_QWORD *)&v116[14] = "_VCMediaQueue_PacePacketSendFromMainQueue";
            v117 = 1024;
            v118 = 499;
            v119 = 2048;
            *(_QWORD *)v120 = v105;
            *(_WORD *)&v120[8] = 2048;
            *(_QWORD *)v121 = v106;
            *(_WORD *)&v121[8] = 1024;
            v122 = v109;
            v123 = 1024;
            v124 = v84;
            _os_log_impl(&dword_1D8A54000, v104, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d Not able to finish sending all packets in expectedScheduleInterval=%f, packetSendPacingInterval=%f, totalPacketCount=%u, packetSent=%u", v116, 0x3Cu);
          }
        }
      }
    }
  }
  _VCMediaQueue_FreeMediaPacketList(a1, v113[3]);
  v96 = atomic_load((unsigned __int8 *)(a1 + 888));
  if ((v96 & 1) == 0 || *(_BYTE *)(a1 + 308))
  {
    LODWORD(v94) = *(_DWORD *)(a1 + 344);
    LODWORD(v95) = *(_DWORD *)(a1 + 332);
    if ((double)v95 * 0.1 >= (double)v94)
    {
      *(_QWORD *)(a1 + 960) = 0;
    }
    else
    {
      v97 = *(double *)(a1 + 960);
      v98 = micro();
      if (v97 == 0.0)
      {
        *(double *)(a1 + 960) = v98;
      }
      else if (v98 - *(double *)(a1 + 960) >= 0.5)
      {
        reportingSymptom();
      }
    }
    _VCMediaQueue_DumpStatisticsToFile(a1);
  }
  _Block_object_dispose(v111, 8);
  _Block_object_dispose(&v112, 8);
}

uint64_t VCMediaQueue_Start(uint64_t a1)
{
  unsigned __int8 *v2;
  int v3;
  int ErrorLogLevelForModule;
  uint64_t result;
  uint64_t v6;
  NSObject *v7;
  _BOOL4 v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 2149580801;
  v2 = (unsigned __int8 *)(a1 + 764);
  do
  {
    v3 = __ldaxr(v2);
    if (v3 != 1)
    {
      result = 0;
      __clrex();
      return result;
    }
  }
  while (__stlxr(0, v2));
  _VCMediaQueue_ReportingEvent((_DWORD *)a1, 321, -1);
  *(_OWORD *)(a1 + 412) = 0u;
  *(_OWORD *)(a1 + 428) = 0u;
  *(_OWORD *)(a1 + 444) = 0u;
  *(_OWORD *)(a1 + 460) = 0u;
  VCRealTimeThread_Start(*(_QWORD *)(a1 + 768));
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 776));
  *(_BYTE *)(a1 + 944) = 0;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 776));
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  result = 0;
  if (ErrorLogLevelForModule >= 7)
  {
    v6 = VRTraceErrorLogLevelToCSTR();
    v7 = *MEMORY[0x1E0CF2758];
    v8 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (v8)
    {
      v9 = 136315650;
      v10 = v6;
      v11 = 2080;
      v12 = "VCMediaQueue_Start";
      v13 = 1024;
      v14 = 2089;
      _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d VCMediaQueueSendProc thread started", (uint8_t *)&v9, 0x1Cu);
      return 0;
    }
  }
  return result;
}

uint64_t VCMediaQueue_Stop(uint64_t a1)
{
  unsigned __int8 *v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  _BOOL4 v8;
  uint64_t result;
  uint64_t v10;
  NSObject *v11;
  _BYTE v12[22];
  __int16 v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 2149580801;
  v2 = (unsigned __int8 *)(a1 + 764);
  do
  {
    if (__ldaxr(v2))
    {
      result = 0;
      __clrex();
      return result;
    }
  }
  while (__stlxr(1u, v2));
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 776));
  pthread_cond_signal((pthread_cond_t *)(a1 + 840));
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 776));
  VCMediaQueue_SetAudioStallBasebandFlushState(a1, 0, *(_QWORD *)(a1 + 25728));
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 776));
  if (*(_BYTE *)(a1 + 944))
  {
LABEL_8:
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 776));
  }
  else
  {
    while (1)
    {
      memset(v12, 170, 16);
      convertTimeoutToRelativeTimespec(5.0);
      *(_QWORD *)v12 = v4;
      *(_QWORD *)&v12[8] = v5;
      if (pthread_cond_timedwait_relative_np((pthread_cond_t *)(a1 + 896), (pthread_mutex_t *)(a1 + 776), (const timespec *)v12) == 60)break;
      if (*(_BYTE *)(a1 + 944))
        goto LABEL_8;
    }
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 776));
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v10 = VRTraceErrorLogLevelToCSTR();
      v11 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v12 = 136315650;
        *(_QWORD *)&v12[4] = v10;
        *(_WORD *)&v12[12] = 2080;
        *(_QWORD *)&v12[14] = "VCMediaQueue_Stop";
        v13 = 1024;
        v14 = 2114;
        _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d Sendproc thread might not have cleaned residual packets in internal Queues", v12, 0x1Cu);
      }
    }
  }
  VCRealTimeThread_Stop(*(_QWORD *)(a1 + 768));
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v6 = VRTraceErrorLogLevelToCSTR();
    v7 = *MEMORY[0x1E0CF2758];
    v8 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v8)
      return result;
    *(_DWORD *)v12 = 136315650;
    *(_QWORD *)&v12[4] = v6;
    *(_WORD *)&v12[12] = 2080;
    *(_QWORD *)&v12[14] = "VCMediaQueue_Stop";
    v13 = 1024;
    v14 = 2118;
    _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d VCMediaQueueSendProc thread ended", v12, 0x1Cu);
  }
  return 0;
}

uint64_t VCMediaQueue_SetAudioStallBasebandFlushState(uint64_t a1, int a2, uint64_t a3)
{
  unsigned __int8 v4;
  uint64_t v5;
  _BYTE *v8;
  uint64_t v9;
  NSObject *v10;
  int v11;
  int v13;
  uint64_t v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  __int16 v23;
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v4 = atomic_load((unsigned __int8 *)(a1 + 300));
    if ((v4 & 1) != 0)
    {
      v8 = (_BYTE *)(a1 + 25696);
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 25632));
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v9 = VRTraceErrorLogLevelToCSTR();
        v10 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v11 = *v8;
          v13 = 136316418;
          v14 = v9;
          v15 = 2080;
          v16 = "VCMediaQueue_SetAudioStallBasebandFlushState";
          v17 = 1024;
          v18 = 2689;
          v19 = 1024;
          v20 = v11;
          v21 = 1024;
          v22 = a2;
          v23 = 2048;
          v24 = a3;
          _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d VCMediaQueue set audioStallFlushState old=%d to new=%d on rtpHandle=%p", (uint8_t *)&v13, 0x32u);
        }
      }
      *(_QWORD *)(a1 + 25728) = a3;
      if (*v8 != a2)
      {
        if (a2)
        {
          *(_QWORD *)(a1 + 25712) = 0;
          *(_BYTE *)(a1 + 25697) = 1;
        }
        *v8 = a2;
      }
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 25632));
      return 0;
    }
    else
    {
      v5 = 2149580801;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCMediaQueue_SetAudioStallBasebandFlushState_cold_2();
      }
    }
  }
  else
  {
    v5 = 2149580801;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCMediaQueue_SetAudioStallBasebandFlushState_cold_1();
    }
  }
  return v5;
}

uint64_t VCMediaQueue_AllocMediaPacket(uint64_t a1, unsigned int a2, int a3, uint64_t a4)
{
  uint64_t v4;
  unsigned int v8;
  uint64_t v9;
  unint64_t v10;
  CMSimpleQueueRef *v11;
  _QWORD *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  const void *v17;
  unint64_t v18;
  double v19;
  double v20;
  unsigned int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v4 = 2149580801;
  if (!a1)
    return v4;
  v22 = -1;
  if (_VCMediaQueue_GetInternalQueueIndexFromStreamId(a1, a2, a3 == 2, (int *)&v22))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCMediaQueue_AllocMediaPacket_cold_4();
    }
    return v4;
  }
  v8 = v22;
  if (v22 == -1)
  {
    v9 = _VCMediaQueue_RegisterStream(a1, a2, (signed int *)&v22);
    v8 = v22;
    if ((_DWORD)v9)
      goto LABEL_31;
  }
  else
  {
    v9 = 0;
  }
  if ((v8 & 0x80000000) != 0)
  {
LABEL_31:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCMediaQueue_AllocMediaPacket_cold_1();
    }
    return v9;
  }
  v10 = *(_QWORD *)(a1 + 624);
  v11 = (CMSimpleQueueRef *)(v10 + 176 * v8);
  if ((unint64_t)v11 >= v10 + 176 * *(unsigned int *)(a1 + 348) || (unint64_t)v11 < v10)
LABEL_35:
    __break(0x5519u);
  v13 = CMSimpleQueueDequeue(*v11);
  *(_QWORD *)a4 = v13;
  if (v13)
  {
    *(_QWORD *)(a1 + 952) = 0;
    v14 = v13[1];
    *((_OWORD *)v13 + 2) = 0u;
    *((_OWORD *)v13 + 3) = 0u;
    *((_OWORD *)v13 + 4) = 0u;
    *((_OWORD *)v13 + 5) = 0u;
    *((_OWORD *)v13 + 6) = 0u;
    *((_OWORD *)v13 + 7) = 0u;
    *((_OWORD *)v13 + 8) = 0u;
    *((_OWORD *)v13 + 9) = 0u;
    *((_OWORD *)v13 + 10) = 0u;
    *((_OWORD *)v13 + 11) = 0u;
    *((_OWORD *)v13 + 12) = 0u;
    *((_OWORD *)v13 + 13) = 0u;
    *((_OWORD *)v13 + 14) = 0u;
    *((_OWORD *)v13 + 15) = 0u;
    *((_OWORD *)v13 + 16) = 0u;
    *((_OWORD *)v13 + 17) = 0u;
    *((_OWORD *)v13 + 18) = 0u;
    v13[38] = 0;
    *(_OWORD *)v13 = 0u;
    *((_OWORD *)v13 + 1) = 0u;
    *(_QWORD *)(*(_QWORD *)a4 + 8) = v14;
    v15 = *(_QWORD *)(a1 + 624);
    v16 = v15 + 176 * *(unsigned int *)(a1 + 348);
    v17 = *(const void **)a4;
    *(_DWORD *)(*(_QWORD *)a4 + 228) = a2;
    v18 = v15 + 176 * (int)v22;
    if (v18 >= v16 || v18 < v15)
      goto LABEL_35;
    v4 = CMSimpleQueueEnqueue(*(CMSimpleQueueRef *)(v15 + 176 * (int)v22 + 8), v17);
    if ((_DWORD)v4)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCMediaQueue_AllocMediaPacket_cold_3();
      }
      return 0;
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCMediaQueue_AllocMediaPacket_cold_2();
    }
    v19 = *(double *)(a1 + 952);
    v20 = micro();
    if (v19 == 0.0)
    {
      *(double *)(a1 + 952) = v20;
      return 2149580803;
    }
    else
    {
      v4 = 2149580803;
      if (v20 - *(double *)(a1 + 952) >= 5.0)
        reportingSymptom();
    }
  }
  return v4;
}

void VCMediaQueue_AddPacket(uint64_t a1, uint64_t a2)
{
  unint64_t *v4;
  unint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  unsigned __int8 v8;
  int v9;
  int v10;
  unsigned int v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v16;
  int *v17;
  int v18;
  int v19;
  unint64_t v20;
  _DWORD *v21;
  int v22;
  BOOL v23;
  uint64_t v24;
  NSObject *v25;
  unsigned __int8 *v26;
  unsigned __int8 v27;
  unsigned __int8 *v28;
  unsigned __int8 v29;
  unsigned __int8 *v30;
  unsigned __int8 v31;
  double v32;
  unsigned __int8 v33;
  double v34;
  int v35;
  double v36;
  NSObject *v37;
  uint64_t v38;
  int v39;
  int v40;
  NSObject *v41;
  int v42;
  int v43;
  unint64_t v44;
  _QWORD *v45;
  double v46;
  double v47;
  unsigned __int8 v48;
  unsigned __int8 v49;
  unsigned int v50;
  unsigned int v51;
  BOOL v52;
  const void *v53;
  unsigned int v54;
  OSStatus v55;
  OSStatus v56;
  uint64_t v57;
  uint64_t v58;
  NSObject *v59;
  const void *v60;
  unint64_t *v61;
  unint64_t v62;
  uint64_t v63;
  NSObject *v64;
  uint64_t v65;
  uint64_t v66;
  int v67;
  int v68;
  unsigned __int8 v69;
  unsigned int v70;
  unsigned __int16 v71;
  uint8_t buf[4];
  uint64_t v73;
  __int16 v74;
  const char *v75;
  __int16 v76;
  int v77;
  __int16 v78;
  _BYTE v79[10];
  _BYTE v80[10];
  __int16 v81;
  int v82;
  __int16 v83;
  int v84;
  uint64_t v85;

  v85 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return;
  if (a2)
  {
    if (*(_BYTE *)(a2 + 227))
      v4 = (unint64_t *)(a1 + 512);
    else
      v4 = (unint64_t *)(a1 + 504);
    do
      v5 = __ldaxr(v4);
    while (__stlxr(v5 + 1, v4));
    v6 = (unint64_t *)(a1 + 520);
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 + 1, v6));
  }
  v8 = atomic_load((unsigned __int8 *)(a1 + 300));
  v68 = *(_DWORD *)(a2 + 176);
  v9 = *(_DWORD *)(a2 + 228);
  v10 = *(_DWORD *)(a2 + 240);
  v70 = -1;
  v67 = v9;
  if (!_VCMediaQueue_GetInternalQueueIndexFromStreamId(a1, v9, *(unsigned __int8 *)(a2 + 295), (int *)&v70))
  {
    v11 = v70;
    if ((v70 & 0x80000000) == 0)
    {
      v69 = v8;
      v12 = *(_QWORD *)(a1 + 624);
      v13 = v12 + 176 * *(unsigned int *)(a1 + 348);
      v14 = v12 + 176 * v70;
      if (v12 <= v14 && v14 + 176 <= v13)
      {
        v16 = v12 + 176 * v70;
        v18 = *(_DWORD *)(v16 + 24);
        v17 = (int *)(v16 + 24);
        if (!v18)
        {
          switch(v68)
          {
            case 0:
            case 3:
              v19 = 2;
              goto LABEL_20;
            case 1:
              v19 = 3;
LABEL_20:
              *v17 = v19;
              break;
            case 2:
              *v17 = 1;
              goto LABEL_22;
            default:
LABEL_22:
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  VCMediaQueue_AddPacket_cold_2();
              }
              break;
          }
        }
        if (!*(_DWORD *)(a2 + 268))
          *(_DWORD *)(a2 + 268) = 1;
        v20 = v12 + 176 * v11;
        v22 = *(_DWORD *)(v20 + 88);
        v21 = (_DWORD *)(v20 + 88);
        if (v22)
          v23 = 1;
        else
          v23 = v10 == 0;
        if (!v23)
        {
          *v21 = v10;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v24 = VRTraceErrorLogLevelToCSTR();
            v25 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136316418;
              v73 = v24;
              v74 = 2080;
              v75 = "VCMediaQueue_AddPacket";
              v76 = 1024;
              v77 = 2218;
              v78 = 1024;
              *(_DWORD *)v79 = v10;
              *(_WORD *)&v79[4] = 1024;
              *(_DWORD *)&v79[6] = v68;
              *(_WORD *)v80 = 1024;
              *(_DWORD *)&v80[2] = v67;
              _os_log_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d Set internalQueue timestampRateHz=%u for packetType=%d, mediaQueueStreamId=%u", buf, 0x2Eu);
            }
          }
        }
        if (*(_BYTE *)(a2 + 289) && *(_BYTE *)(a2 + 292))
        {
          v26 = (unsigned __int8 *)(v12 + 176 * v11 + 92);
          do
            v27 = __ldaxr(v26);
          while (__stlxr(v27 | 1, v26));
        }
        if (*(_BYTE *)(a2 + 226))
        {
          v28 = (unsigned __int8 *)(v12 + 176 * v11 + 96);
          do
            v29 = __ldaxr(v28);
          while (__stlxr(v29 | 1, v28));
        }
        if (*(_BYTE *)(a2 + 227))
        {
          v30 = (unsigned __int8 *)(v12 + 176 * v11 + 97);
          do
            v31 = __ldaxr(v30);
          while (__stlxr(v31 | 1, v30));
          v32 = *(double *)(a2 + 272);
          v33 = atomic_load((unsigned __int8 *)(a1 + 300));
          if ((v33 & 1) != 0)
          {
            pthread_mutex_lock((pthread_mutex_t *)(a1 + 25632));
            if (*(_BYTE *)(a1 + 25696))
            {
              if (*(_BYTE *)(a1 + 25697))
              {
                *(_BYTE *)(a1 + 25697) = 0;
                *(double *)(a1 + 25704) = v32;
                *(_DWORD *)(a1 + 25716) = *(_DWORD *)(a2 + 236);
                v34 = v32;
              }
              else
              {
                v34 = *(double *)(a1 + 25704);
              }
              v35 = *(_BYTE *)(a2 + 293) ? 48 : 28;
              *(_DWORD *)(a1 + 25712) += *(unsigned __int16 *)(a2 + 4) + v35;
              v36 = v32 - v34;
              if (v32 - v34 > 1.0)
              {
                if (*(_BYTE *)(a1 + 25698))
                {
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
                  {
                    v65 = VRTraceErrorLogLevelToCSTR();
                    v37 = *MEMORY[0x1E0CF2758];
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                    {
                      v38 = *(_QWORD *)(a1 + 25704);
                      *(_DWORD *)buf = 136316162;
                      v73 = v65;
                      v74 = 2080;
                      v75 = "_VCMediaQueue_ProcessAudioPacketsForBasebandQueuing";
                      v76 = 1024;
                      v77 = 2656;
                      v78 = 2048;
                      *(double *)v79 = v32;
                      *(_WORD *)&v79[8] = 2048;
                      *(_QWORD *)v80 = v38;
                      _os_log_impl(&dword_1D8A54000, v37, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d UNEXPECTED pending flush not acked yet at time=%f lastFlushTime=%f!", buf, 0x30u);
                    }
                  }
                }
                v39 = *(_DWORD *)(a1 + 25716);
                v40 = ((double)(8 * *(_DWORD *)(a1 + 25712)) / v36);
                *(_DWORD *)(a1 + 25712) = 0;
                v71 = 0;
                if (RTPFlushBaseband_SpecialMQAudioTS(*(_QWORD *)(a1 + 25728), v39 + 1, v40, &v71))
                {
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                  {
                    VRTraceErrorLogLevelToCSTR();
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                      VCMediaQueue_AddPacket_cold_1();
                  }
                }
                else
                {
                  *(_DWORD *)(a1 + 25720) = v71;
                  *(double *)(a1 + 25704) = v32;
                  *(_BYTE *)(a1 + 25698) = 1;
                  *(_DWORD *)(a1 + 25716) = *(_DWORD *)(a2 + 236);
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
                  {
                    v66 = VRTraceErrorLogLevelToCSTR();
                    v41 = *MEMORY[0x1E0CF2758];
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                    {
                      v42 = *(_DWORD *)(a2 + 236);
                      v43 = *(unsigned __int16 *)(a2 + 248);
                      *(_DWORD *)buf = 136316930;
                      v73 = v66;
                      v74 = 2080;
                      v75 = "_VCMediaQueue_ProcessAudioPacketsForBasebandQueuing";
                      v76 = 1024;
                      v77 = 2671;
                      v78 = 2048;
                      *(double *)v79 = v32;
                      *(_WORD *)&v79[8] = 1024;
                      *(_DWORD *)v80 = v42;
                      *(_WORD *)&v80[4] = 1024;
                      *(_DWORD *)&v80[6] = v43;
                      v81 = 1024;
                      v82 = v40;
                      v83 = 1024;
                      v84 = v71;
                      _os_log_impl(&dword_1D8A54000, v41, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d Issued audio flush at time=%f with packet timestamp=%u sequenceNumber=%u with rate=%u transactionID=%u!", buf, 0x3Eu);
                    }
                  }
                }
              }
            }
            pthread_mutex_unlock((pthread_mutex_t *)(a1 + 25632));
          }
        }
        if (!*(_BYTE *)(a2 + 289) || !*(_BYTE *)(a2 + 291))
          goto LABEL_72;
        atomic_store(*(unsigned int *)(a2 + 236), (unint64_t *)(v12 + 176 * v11 + 104));
        if (!v14 || v14 < v13)
        {
          v44 = v12 + 176 * v11;
          v46 = *(double *)(v44 + 40);
          v45 = (_QWORD *)(v44 + 40);
          v47 = v46;
          if (v46 > 0.0)
            atomic_store(*(double *)(a2 + 272) - v47 < 1.1, (unsigned __int8 *)(v12 + 176 * v11 + 93));
          *v45 = *(_QWORD *)(a2 + 272);
LABEL_72:
          if ((v69 & 1) != 0)
            _VCMediaQueue_RateStats_TrackMediaPacket(*(_QWORD *)(a1 + 160), a2, 1, *(double *)(a2 + 272));
          v48 = atomic_load((unsigned __int8 *)(a1 + 301));
          v49 = atomic_load((unsigned __int8 *)(a1 + 300));
          v50 = atomic_load((unsigned int *)(a1 + 304));
          if (*(_DWORD *)(a1 + 88) == 2
            && (v49 & 1) != 0
            && (v48 & 1) == 0
            && (v51 = atomic_load((unsigned int *)(a1 + 284)), v51 > v50))
          {
            v52 = 0;
            atomic_store(1u, (unsigned __int8 *)(a1 + 888));
            *(_BYTE *)(a2 + 224) = 1;
          }
          else
          {
            atomic_store(0, (unsigned __int8 *)(a1 + 888));
            v52 = *(_BYTE *)(a2 + 224) == 0;
          }
          if (*(_BYTE *)(a1 + 96))
          {
            if (*(_BYTE *)(a2 + 294))
            {
              v53 = *(const void **)(a2 + 8);
              if (v53)
                CFRetain(v53);
            }
          }
          v54 = *(_DWORD *)(a2 + 236);
          v55 = CMSimpleQueueEnqueue(*(CMSimpleQueueRef *)(v12 + 176 * v11 + 16), (const void *)a2);
          if (v55)
          {
            v56 = v55;
            v57 = *(_QWORD *)(a2 + 184);
            if (v57)
            {
              VCMediaControlInfoDispose(v57);
              *(_QWORD *)(a2 + 184) = 0;
            }
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              v58 = VRTraceErrorLogLevelToCSTR();
              v59 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136316418;
                v73 = v58;
                v74 = 2080;
                v75 = "VCMediaQueue_AddPacket";
                v76 = 1024;
                v77 = 2257;
                v78 = 1024;
                *(_DWORD *)v79 = v56;
                *(_WORD *)&v79[4] = 1024;
                *(_DWORD *)&v79[6] = v68;
                *(_WORD *)v80 = 1024;
                *(_DWORD *)&v80[2] = v67;
                _os_log_error_impl(&dword_1D8A54000, v59, OS_LOG_TYPE_ERROR, "VCMediaQueue [%s] %s:%d Internal queue has error %d when adding media packet for packet type=%d, mediaQueueStreamId=%u", buf, 0x2Eu);
              }
            }
            if (*(_BYTE *)(a2 + 294))
            {
              v60 = *(const void **)(a2 + 8);
              if (v60)
              {
                CFRelease(v60);
                *(_QWORD *)(a2 + 8) = 0;
              }
              *(_BYTE *)(a2 + 294) = 0;
            }
          }
          else
          {
            v61 = (unint64_t *)(a1 + 528);
            do
              v62 = __ldaxr(v61);
            while (__stlxr(v62 + 1, v61));
            atomic_store(v54, (unsigned int *)(v12 + 176 * v11 + 120));
            if (!v52)
              VCMediaQueue_SchedulePackets(a1);
          }
          return;
        }
      }
      __break(0x5519u);
      return;
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v63 = VRTraceErrorLogLevelToCSTR();
    v64 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136316162;
      v73 = v63;
      v74 = 2080;
      v75 = "VCMediaQueue_AddPacket";
      v76 = 1024;
      v77 = 2195;
      v78 = 1024;
      *(_DWORD *)v79 = v68;
      *(_WORD *)&v79[4] = 1024;
      *(_DWORD *)&v79[6] = v67;
      _os_log_error_impl(&dword_1D8A54000, v64, OS_LOG_TYPE_ERROR, "VCMediaQueue [%s] %s:%d Cannot get internal queue index for packet type=%d, mediaQueueStreamId=%u", buf, 0x28u);
    }
  }
}

uint64_t VCMediaQueue_SchedulePackets(uint64_t a1)
{
  unsigned __int8 *v2;
  unsigned __int8 v3;

  if (!a1)
    return 2149580801;
  v2 = (unsigned __int8 *)(a1 + 280);
  do
    v3 = __ldaxr(v2);
  while (__stlxr(v3 | 1, v2));
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 776));
  pthread_cond_signal((pthread_cond_t *)(a1 + 840));
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 776));
  return 0;
}

uint64_t VCMediaQueue_FlushAllPackets(uint64_t a1)
{
  unsigned __int8 *v2;
  unsigned __int8 v3;

  if (!a1)
    return 2149580801;
  v2 = (unsigned __int8 *)(a1 + 292);
  do
    v3 = __ldaxr(v2);
  while (__stlxr(v3 | 1, v2));
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 776));
  pthread_cond_signal((pthread_cond_t *)(a1 + 840));
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 776));
  return 0;
}

uint64_t VCMediaQueue_FlushPacketsInStream(uint64_t result, int a2, char a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _DWORD *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unsigned __int8 *v14;
  unsigned __int8 v15;
  unsigned __int8 *v16;
  unsigned __int8 v17;

  v3 = 2149580822;
  if (!result)
    return 2149580801;
  v4 = result;
  v5 = *(unsigned __int8 *)(result + 128);
  v6 = atomic_load((unsigned int *)(result + 760));
  if ((int)v6 <= (int)v5)
  {
LABEL_8:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCMediaQueue_FlushPacketsInStream_cold_1();
    }
  }
  else
  {
    v7 = -v5;
    v8 = -v6;
    v9 = (_DWORD *)(result + 632 + 4 * v5);
    while (1)
    {
      if ((unint64_t)v9 >= result + 760 || (unint64_t)v9 < result + 632)
        goto LABEL_23;
      if (*v9 == a2)
        break;
      --v7;
      ++v9;
      if (v8 == v7)
        goto LABEL_8;
    }
    v10 = -v7;
    if ((v10 & 0x80000000) != 0)
      goto LABEL_8;
    v11 = *(_QWORD *)(result + 624);
    v12 = v11 + 176 * v10;
    if (v11 > v12 || v12 + 176 > v11 + 176 * *(unsigned int *)(result + 348))
    {
LABEL_23:
      __break(0x5519u);
      return result;
    }
    v14 = (unsigned __int8 *)(v11 + 176 * v10 + 95);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 | a3, v14));
    v16 = (unsigned __int8 *)(v11 + 176 * v10 + 94);
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 | 1, v16));
    pthread_mutex_lock((pthread_mutex_t *)(result + 776));
    pthread_cond_signal((pthread_cond_t *)(v4 + 840));
    pthread_mutex_unlock((pthread_mutex_t *)(v4 + 776));
    return 0;
  }
  return v3;
}

uint64_t VCMediaQueue_GetTimeRateChanged(uint64_t a1, _QWORD *a2, _DWORD *a3)
{
  pthread_mutex_t *v6;

  if (!a1)
    return 2149580801;
  v6 = (pthread_mutex_t *)(a1 + 216);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 216));
  if (a2)
    *a2 = *(_QWORD *)(a1 + 200);
  if (a3)
    *a3 = *(_DWORD *)(a1 + 180);
  pthread_mutex_unlock(v6);
  return 0;
}

uint64_t VCMediaQueue_GetTimeRefreshFrame(uint64_t a1, _QWORD *a2, _DWORD *a3)
{
  pthread_mutex_t *v6;

  if (!a1)
    return 2149580801;
  v6 = (pthread_mutex_t *)(a1 + 216);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 216));
  if (a2)
    *a2 = *(_QWORD *)(a1 + 208);
  if (a3)
    *a3 = *(_DWORD *)(a1 + 184);
  pthread_mutex_unlock(v6);
  return 0;
}

uint64_t VCMediaQueue_UpdateAudioOnlyRateChange(uint64_t a1, unsigned int a2)
{
  pthread_mutex_t *v4;

  if (!a1)
    return 2149580801;
  v4 = (pthread_mutex_t *)(a1 + 216);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 216));
  if (*(_DWORD *)(a1 + 188) < a2)
  {
    *(_BYTE *)(a1 + 176) = 1;
    *(_DWORD *)(a1 + 188) = a2;
  }
  pthread_mutex_unlock(v4);
  return 0;
}

uint64_t VCMediaQueue_SetPeakBitrate(_DWORD *a1, unsigned int a2)
{
  uint64_t v4;
  NSObject *v5;
  int v7;
  uint64_t v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  unsigned int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 2149580801;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v7 = 136315906;
      v8 = v4;
      v9 = 2080;
      v10 = "VCMediaQueue_SetPeakBitrate";
      v11 = 1024;
      v12 = 2388;
      v13 = 1024;
      v14 = a2;
      _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d VCMediaQueue set with peak bitrate = %u", (uint8_t *)&v7, 0x22u);
    }
  }
  atomic_store(a2, a1 + 71);
  _VCMediaQueue_ReportingEvent(a1, 191, -1);
  return 0;
}

uint64_t VCMediaQueue_SetMTUBytes(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  NSObject *v5;
  unsigned int *v6;
  unsigned __int16 v7;
  int v9;
  uint64_t v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  unsigned int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 2149580801;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315906;
      v10 = v4;
      v11 = 2080;
      v12 = "VCMediaQueue_SetMTUBytes";
      v13 = 1024;
      v14 = 2398;
      v15 = 1024;
      v16 = a2;
      _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d VCMediaQueue set with MTU bytes = %u", (uint8_t *)&v9, 0x22u);
    }
  }
  atomic_store(a2, (unsigned int *)(a1 + 288));
  v6 = *(unsigned int **)(a1 + 136);
  v7 = atomic_load((unsigned int *)(a1 + 288));
  VCMediaQueuePacketBundler_SetMTU(v6, v7);
  _VCMediaQueue_ReportingEvent((_DWORD *)a1, 192, -1);
  return 0;
}

uint64_t VCMediaQueue_RetrieveAudioVideoRates(uint64_t a1, double *a2, double *a3, double *a4, double *a5)
{
  double v10;
  uint64_t v11;
  pthread_mutex_t *v12;
  double v13;
  int v14;
  double v15;
  double v16;
  double v17;
  uint64_t v18;
  pthread_mutex_t *v19;
  double v20;
  int v21;
  uint64_t v22;
  pthread_mutex_t *v23;
  double v24;
  int v25;
  double v26;
  double v27;
  double v28;
  uint64_t v29;
  pthread_mutex_t *v30;
  double v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  NSObject *v35;
  uint64_t v37;
  int v38;
  uint64_t v39;
  __int16 v40;
  const char *v41;
  __int16 v42;
  int v43;
  __int16 v44;
  uint64_t v45;
  __int16 v46;
  uint64_t v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  if (a1 && *(_QWORD *)(a1 + 160))
  {
    v10 = micro();
    v11 = *(_QWORD *)(a1 + 160);
    v12 = (pthread_mutex_t *)(v11 + 160);
    pthread_mutex_lock((pthread_mutex_t *)(v11 + 160));
    v13 = *(double *)(v11 + 136);
    v14 = *(_DWORD *)(v11 + 148);
    pthread_mutex_unlock(v12);
    v15 = v10 - v13;
    v16 = 0.0;
    v17 = 0.0;
    if (v15 <= 0.5)
      v17 = (double)(8 * v14) / (v15 + 0.484375);
    *a2 = v17;
    v18 = *(_QWORD *)(a1 + 160);
    v19 = (pthread_mutex_t *)(v18 + 384);
    pthread_mutex_lock((pthread_mutex_t *)(v18 + 384));
    v20 = *(double *)(v18 + 360);
    v21 = *(_DWORD *)(v18 + 372);
    pthread_mutex_unlock(v19);
    if (v10 - v20 <= 0.5)
      v16 = (double)(8 * v21) / (v10 - v20 + 0.484375);
    *a3 = v16;
    v22 = *(_QWORD *)(a1 + 160);
    v23 = (pthread_mutex_t *)(v22 + 608);
    pthread_mutex_lock((pthread_mutex_t *)(v22 + 608));
    v24 = *(double *)(v22 + 584);
    v25 = *(_DWORD *)(v22 + 596);
    pthread_mutex_unlock(v23);
    v26 = v10 - v24;
    v27 = 0.0;
    v28 = 0.0;
    if (v26 <= 0.5)
      v28 = (double)(8 * v25) / (v26 + 0.484375);
    *a4 = v28;
    v29 = *(_QWORD *)(a1 + 160);
    v30 = (pthread_mutex_t *)(v29 + 832);
    pthread_mutex_lock((pthread_mutex_t *)(v29 + 832));
    v31 = *(double *)(v29 + 808);
    v32 = *(_DWORD *)(v29 + 820);
    pthread_mutex_unlock(v30);
    if (v10 - v31 <= 0.5)
      v27 = (double)(8 * v32) / (v10 - v31 + 0.484375);
    v33 = 0;
    *a5 = v27;
  }
  else
  {
    v33 = 2149580801;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v34 = VRTraceErrorLogLevelToCSTR();
      v35 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        if (a1)
          v37 = *(_QWORD *)(a1 + 160);
        else
          v37 = 0;
        v38 = 136316162;
        v39 = v34;
        v40 = 2080;
        v41 = "VCMediaQueue_RetrieveAudioVideoRates";
        v42 = 1024;
        v43 = 2461;
        v44 = 2048;
        v45 = a1;
        v46 = 2048;
        v47 = v37;
        _os_log_error_impl(&dword_1D8A54000, v35, OS_LOG_TYPE_ERROR, "VCMediaQueue [%s] %s:%d mediaQueue or its rateStats cannot be NULL mediaQueue=%p mediaQueue->rateStats=%p", (uint8_t *)&v38, 0x30u);
      }
    }
  }
  return v33;
}

uint64_t VCMediaQueue_SetHighlyBurstyTrafficMode(uint64_t a1, int a2)
{
  uint64_t v4;
  NSObject *v5;
  uint64_t result;
  int v7;
  uint64_t v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 2149580801;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v7 = 136315906;
      v8 = v4;
      v9 = 2080;
      v10 = "VCMediaQueue_SetHighlyBurstyTrafficMode";
      v11 = 1024;
      v12 = 2477;
      v13 = 1024;
      v14 = a2;
      _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d VCMediaQueue set highlyBurstyTrafficMode=%u", (uint8_t *)&v7, 0x22u);
    }
  }
  result = 0;
  atomic_store(a2, (unsigned __int8 *)(a1 + 301));
  return result;
}

uint64_t VCMediaQueue_SetOneToOne(uint64_t a1, int a2)
{
  unsigned __int8 v3;
  uint64_t v4;
  NSObject *v5;
  _BOOL4 v6;
  uint64_t result;
  int v8;
  uint64_t v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  int v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 2149580801;
  v3 = atomic_load((unsigned __int8 *)(a1 + 300));
  if ((v3 & 1) == 0)
  {
    atomic_store(0, (unint64_t *)(a1 + 512));
    atomic_store(0, (unint64_t *)(a1 + 504));
    atomic_store(0, (unint64_t *)(a1 + 520));
    atomic_store(0, (unint64_t *)(a1 + 528));
    *(_OWORD *)(a1 + 560) = 0u;
    *(_OWORD *)(a1 + 576) = 0u;
    *(_OWORD *)(a1 + 544) = 0u;
  }
  atomic_store(a2, (unsigned __int8 *)(a1 + 300));
  VCMediaQueuePacketBundler_SetOneToOne(*(_QWORD *)(a1 + 136), a2);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    v6 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v6)
      return result;
    v8 = 136315906;
    v9 = v4;
    v10 = 2080;
    v11 = "VCMediaQueue_SetOneToOne";
    v12 = 1024;
    v13 = 2491;
    v14 = 1024;
    v15 = a2;
    _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d VCMediaQueue set oneToOne=%u", (uint8_t *)&v8, 0x22u);
  }
  return 0;
}

uint64_t VCMediaQueue_SetMinBitrateWithoutThrottling(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  NSObject *v5;
  uint64_t result;
  int v7;
  uint64_t v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  unsigned int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 2149580801;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v7 = 136315906;
      v8 = v4;
      v9 = 2080;
      v10 = "VCMediaQueue_SetMinBitrateWithoutThrottling";
      v11 = 1024;
      v12 = 2499;
      v13 = 1024;
      v14 = a2;
      _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d VCMediaQueue set minBitrateWithoutThrottling=%u", (uint8_t *)&v7, 0x22u);
    }
  }
  result = 0;
  atomic_store(a2, (unsigned int *)(a1 + 304));
  return result;
}

uint64_t VCMediaQueue_SetECNEnabled(uint64_t a1, int a2)
{
  uint64_t v4;
  NSObject *v5;
  uint64_t result;
  int v7;
  uint64_t v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 2149580801;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v7 = 136315906;
      v8 = v4;
      v9 = 2080;
      v10 = "VCMediaQueue_SetECNEnabled";
      v11 = 1024;
      v12 = 2515;
      v13 = 1024;
      v14 = a2;
      _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d VCMediaQueue set ECNEnabled=%u", (uint8_t *)&v7, 0x22u);
    }
  }
  result = 0;
  atomic_store(a2, (unsigned __int8 *)(a1 + 302));
  return result;
}

uint64_t VCMediaQueue_SetMediaQueueSizeThresholdExceededBlock(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t v3;
  const void *v6;

  v3 = 2149580801;
  if (a1)
  {
    if (a3)
    {
      v6 = *(const void **)(a1 + 152);
      if (v6)
      {
        _Block_release(v6);
        *(_QWORD *)(a1 + 152) = 0;
      }
      if (*(_QWORD *)(a1 + 144))
        FigCFWeakReferenceStore();
      FigCFWeakReferenceStore();
      v3 = 0;
      *(_QWORD *)(a1 + 152) = _Block_copy(a3);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCMediaQueue_SetMediaQueueSizeThresholdExceededBlock_cold_1();
    }
  }
  return v3;
}

uint64_t VCMediaQueue_ComputeOneToOneStatsWithPacketInfo(uint64_t a1, unsigned __int16 *a2)
{
  unsigned __int8 v2;
  uint64_t v3;
  uint64_t v5[3];

  v5[2] = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = atomic_load((unsigned __int8 *)(a1 + 300));
    if ((v2 & 1) != 0)
    {
      v5[0] = a1 + 976;
      v5[1] = *(_QWORD *)(a1 + 968);
      VCMediaQueueUtil_FindPacketInTxHistory(a2, v5, (pthread_mutex_t *)(a1 + 25552), 1, 1.0, 5.0);
      return 0;
    }
    else
    {
      v3 = 2149580830;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          VCMediaQueue_ComputeOneToOneStatsWithPacketInfo_cold_2();
          return 2149580830;
        }
      }
    }
  }
  else
  {
    v3 = 2149580801;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCMediaQueue_ComputeOneToOneStatsWithPacketInfo_cold_1();
    }
  }
  return v3;
}

uint64_t VCMediaQueue_TrafficMetricFromMediaQueueTxHistory(uint64_t a1, int a2)
{
  pthread_mutex_t *v4;
  uint64_t result;
  int v6;
  int v7;
  unsigned int v8;
  unint64_t v9;
  __int16 v10;
  unint64_t v11;
  uint64_t v13;
  unint64_t v14;

  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCMediaQueue_TrafficMetricFromMediaQueueTxHistory_cold_1();
    }
    return 0;
  }
  v4 = (pthread_mutex_t *)(a1 + 25552);
  result = pthread_mutex_lock((pthread_mutex_t *)(a1 + 25552));
  v6 = *(_DWORD *)(a1 + 968);
  if (!v6 || (v7 = *(_DWORD *)(a1 + 972), v7 < 1))
  {
LABEL_13:
    v13 = 0;
LABEL_14:
    pthread_mutex_unlock(v4);
    return v13;
  }
  v8 = v6 - 1;
  v9 = a1 + 976;
  v10 = v8;
  while (1)
  {
    v11 = v9 + 48 * (v10 & 0x1FF);
    if (v11 >= (unint64_t)v4 || v11 < v9)
      break;
    if (a2 == 1 && *(_DWORD *)(v9 + 48 * (v10 & 0x1FF) + 12))
    {
      v14 = v9 + 48 * v8;
      if (v14 < (unint64_t)v4 && v14 >= v9)
      {
        v13 = *(_QWORD *)(v9 + 48 * v8 + 24) - *(_QWORD *)(v9 + 48 * (v10 & 0x1FF) + 24);
        goto LABEL_14;
      }
      break;
    }
    --v10;
    if (!--v7)
      goto LABEL_13;
  }
  __break(0x5519u);
  return result;
}

uint64_t VCMediaQueue_BasebandFlushAcked(uint64_t a1, int a2, unsigned __int16 *a3, int a4)
{
  unsigned __int8 *v7;
  pthread_mutex_t *v8;
  int v9;
  uint64_t v10;
  NSObject *v11;
  int v12;
  int v13;
  const char *v14;
  NSObject *v15;
  uint32_t v16;
  uint64_t v17;
  NSObject *v18;
  int v19;
  int v20;
  uint64_t v21;
  int v23;
  uint64_t v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  __int16 v33;
  int v34;
  __int16 v35;
  int v36;
  __int16 v37;
  int v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v7 = (unsigned __int8 *)(a1 + 25698);
    v8 = (pthread_mutex_t *)(a1 + 25632);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 25632));
    if (a2 && a3)
    {
      v9 = *a3;
      if ((int)VRTraceGetErrorLogLevelForModule() < 5)
        goto LABEL_11;
      v10 = VRTraceErrorLogLevelToCSTR();
      v11 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        goto LABEL_11;
      v12 = *v7;
      v13 = *(_DWORD *)(v7 + 22);
      v23 = 136316930;
      v24 = v10;
      v25 = 2080;
      v26 = "VCMediaQueue_BasebandFlushAcked";
      v27 = 1024;
      v28 = 2732;
      v29 = 1024;
      v30 = v9;
      v31 = 1024;
      v32 = a2;
      v33 = 1024;
      v34 = v12;
      v35 = 1024;
      v36 = a4;
      v37 = 1024;
      v38 = v13;
      v14 = "VCMediaQueue [%s] %s:%d Receive baseband flush ack for audio pkts starting with seq=%u, numOfPacketDropped=%"
            "u, pendingBasebandFlush=%d, with transactionID=%u, currentTransactionID=%u";
      v15 = v11;
      v16 = 58;
    }
    else
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 5)
        goto LABEL_11;
      v17 = VRTraceErrorLogLevelToCSTR();
      v18 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        goto LABEL_11;
      v19 = *v7;
      v20 = *(_DWORD *)(v7 + 22);
      v23 = 136316674;
      v24 = v17;
      v25 = 2080;
      v26 = "VCMediaQueue_BasebandFlushAcked";
      v27 = 1024;
      v28 = 2734;
      v29 = 1024;
      v30 = a2;
      v31 = 1024;
      v32 = v19;
      v33 = 1024;
      v34 = a4;
      v35 = 1024;
      v36 = v20;
      v14 = "VCMediaQueue [%s] %s:%d Receive baseband flush ack without dropping audio pkts numOfPacketDropped=%u, pendin"
            "gBasebandFlush=%d, with transactionID=%u, currentTransactionID=%u";
      v15 = v18;
      v16 = 52;
    }
    _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, v14, (uint8_t *)&v23, v16);
LABEL_11:
    if (*(_DWORD *)(v7 + 22) == a4)
      *v7 = 0;
    pthread_mutex_unlock(v8);
    return 0;
  }
  v21 = 2149580801;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCMediaQueue_BasebandFlushAcked_cold_1();
  }
  return v21;
}

uint64_t _VCMediaQueueFinalize(unint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  unint64_t v7;
  const void *v8;
  uint64_t v9;
  int v11;
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  unint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  reportingUnregisterPeriodicTask();
  VCRealTimeThread_Finalize(*(_QWORD *)(a1 + 768));
  if ((int)VRTraceGetErrorLogLevelForModule() > 6)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v11 = 136315906;
      v12 = v2;
      v13 = 2080;
      v14 = "_VCMediaQueueFinalize";
      v15 = 1024;
      v16 = 348;
      v17 = 2048;
      v18 = a1;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d Finalize the media queue:%p", (uint8_t *)&v11, 0x26u);
    }
  }
  v4 = *(const void **)(a1 + 136);
  if (v4)
    CFRelease(v4);
  v5 = *(const void **)(a1 + 120);
  if (v5)
    CFRelease(v5);
  v6 = *(const void **)(a1 + 616);
  if (v6)
    CFRelease(v6);
  v7 = a1 + 25736;
  if (a1 && v7 <= a1)
    goto LABEL_18;
  _VCMediaQueue_DestroyInternalQueues(a1);
  v8 = *(const void **)(a1 + 152);
  if (v8)
    _Block_release(v8);
  v9 = *(_QWORD *)(a1 + 160);
  if (v9)
  {
    pthread_mutex_destroy((pthread_mutex_t *)(v9 + 160));
    pthread_mutex_destroy((pthread_mutex_t *)(*(_QWORD *)(a1 + 160) + 384));
    pthread_mutex_destroy((pthread_mutex_t *)(*(_QWORD *)(a1 + 160) + 608));
    pthread_mutex_destroy((pthread_mutex_t *)(*(_QWORD *)(a1 + 160) + 832));
    free(*(void **)(a1 + 160));
    *(_QWORD *)(a1 + 160) = 0;
  }
  _VCMediaQueue_ReleaseLogDumpFile(a1);
  if (v7 <= a1)
LABEL_18:
    __break(0x5519u);
  FigCFWeakReferenceStore();
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 216));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 776));
  pthread_cond_destroy((pthread_cond_t *)(a1 + 840));
  pthread_cond_destroy((pthread_cond_t *)(a1 + 896));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 25552));
  return pthread_mutex_destroy((pthread_mutex_t *)(a1 + 25632));
}

uint64_t _VCMediaQueue_AddInfoToOneToOneTxHistory(uint64_t a1, __int16 a2, double a3)
{
  pthread_mutex_t *v6;
  uint64_t result;
  unsigned int v8;
  _WORD *v9;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;

  v6 = (pthread_mutex_t *)(a1 + 25552);
  result = pthread_mutex_lock((pthread_mutex_t *)(a1 + 25552));
  v8 = *(_DWORD *)(a1 + 968);
  v9 = (_WORD *)(a1 + 976 + 48 * v8);
  if (a1 + 976 > (unint64_t)v9 || v9 + 24 > (_WORD *)v6)
  {
    __break(0x5519u);
  }
  else
  {
    v11 = a1 + 976 + 48 * v8;
    *(_WORD *)(v11 + 2) = a2;
    *(double *)(v11 + 40) = a3;
    *(_QWORD *)(v11 + 4) = *(_QWORD *)(a1 + 25616);
    v12 = *(unsigned int *)(a1 + 25624);
    *v9 = 0;
    *(_DWORD *)(v11 + 12) = 0;
    *(_DWORD *)(v11 + 16) = 0;
    *(_QWORD *)(v11 + 24) = v12;
    *(_QWORD *)(v11 + 32) = 0;
    *(_DWORD *)(a1 + 968) = ((_WORD)v8 + 1) & 0x1FF;
    v13 = *(_DWORD *)(a1 + 972);
    if (v13 <= 0x1FF)
      *(_DWORD *)(a1 + 972) = v13 + 1;
    return pthread_mutex_unlock(v6);
  }
  return result;
}

void _VCMediaQueue_FlushPacketsFromQueue(uint64_t a1)
{
  unsigned int v1;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;

  v1 = *(_DWORD *)(a1 + 348);
  if (v1)
  {
    v3 = 0;
    v4 = 176 * v1;
    while (1)
    {
      v5 = *(_QWORD *)(a1 + 624);
      v6 = v5 + v3;
      if (v5 + v3)
      {
        if (v6 < v5 || v6 >= v5 + 176 * *(unsigned int *)(a1 + 348))
          break;
      }
      _VCMediaQueue_FlushInternalQueueBeforeTimestamp(v6, a1, -1);
      v3 += 176;
      if (v4 == v3)
        return;
    }
    __break(0x5519u);
  }
}

void _VCMediaQueue_FlushInternalQueueBeforeTimestamp(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned __int8 *v6;
  unsigned __int8 v7;
  unint64_t v8;
  unsigned int v9;
  _BYTE *Head;
  uint64_t v11;
  BOOL v12;
  unsigned __int8 v13;
  OSStatus DataPointer;
  char *v15;
  OSStatus v17;
  uint64_t v18;
  NSObject *v19;
  OSStatus v20;
  NSObject *v21;
  const char *v22;
  uint32_t v23;
  opaqueCMSimpleQueue *v24;
  const void *v25;
  OSStatus v26;
  uint64_t v27;
  OSStatus v28;
  NSObject *v29;
  NSObject *v30;
  int v31;
  int v32;
  OSStatus v33;
  NSObject *v34;
  int32_t v35;
  uint64_t v36;
  const char *v37;
  uint32_t v38;
  OSStatus v39;
  NSObject *v40;
  int32_t v41;
  int32_t v42;
  uint64_t v43;
  NSObject *v44;
  int32_t Count;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  char *dataPointerOut;
  size_t lengthAtOffsetOut;
  uint8_t buf[4];
  uint64_t v52;
  __int16 v53;
  const char *v54;
  __int16 v55;
  int v56;
  __int16 v57;
  OSStatus v58;
  __int16 v59;
  int32_t v60;
  __int16 v61;
  _QWORD v62[4];

  *(_QWORD *)((char *)&v62[2] + 6) = *MEMORY[0x1E0C80C00];
  if (!a1)
    return;
  v6 = (unsigned __int8 *)(a1 + 95);
  do
    v7 = __ldaxr(v6);
  while (__stlxr(0, v6));
  v8 = atomic_load((unint64_t *)(a1 + 104));
  if (CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 16)) < 1)
    return;
  v9 = 0;
  do
  {
    Head = CMSimpleQueueGetHead(*(CMSimpleQueueRef *)(a1 + 16));
    v11 = (uint64_t)Head;
    if (a3 != -1 && *((unsigned int *)Head + 59) > a3)
      break;
    if ((v7 & 1) != 0)
    {
      v12 = !Head[289] || v8 == -1;
      if (!v12 && (*((_DWORD *)Head + 59) - v8) < 0x7FFFFFFF)
        break;
    }
    CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 16));
    if (*(_QWORD *)(v11 + 184))
    {
      v13 = atomic_load((unsigned __int8 *)(a2 + 300));
      if ((v13 & 1) != 0)
      {
        dataPointerOut = 0;
        lengthAtOffsetOut = 0;
        DataPointer = CMBlockBufferGetDataPointer(*(CMBlockBufferRef *)(v11 + 8), 0, &lengthAtOffsetOut, 0, &dataPointerOut);
        if (DataPointer)
        {
          v28 = DataPointer;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            v46 = VRTraceErrorLogLevelToCSTR();
            v29 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            {
              v30 = v29;
              v31 = *(unsigned __int8 *)(v11 + 58);
              if (*(_BYTE *)(v11 + 58))
                v32 = *(unsigned __int16 *)(v11 + 60);
              else
                v32 = 0;
              v42 = *(_DWORD *)(v11 + 228);
              *(_DWORD *)buf = 136316674;
              v52 = v46;
              v53 = 2080;
              v54 = "_VCMediaQueue_SerializeControlInfoIntoBufferForOneToOne";
              v55 = 1024;
              v56 = 1669;
              v57 = 1024;
              v58 = v28;
              v59 = 1024;
              v60 = v42;
              v61 = 1024;
              LODWORD(v62[0]) = v31;
              WORD2(v62[0]) = 1024;
              *(_DWORD *)((char *)v62 + 6) = v32;
              v37 = "VCMediaQueue [%s] %s:%d CMBlock error=%d when serializing control info, for packet mediaQueueStreamI"
                    "d=%u, isServerStats=%u, statsID=%u";
              v38 = 52;
              goto LABEL_45;
            }
          }
        }
        else
        {
          v15 = &dataPointerOut[*(unsigned int *)(v11 + 244)];
          if (v15)
          {
            if (v15 < dataPointerOut || v15 >= &dataPointerOut[lengthAtOffsetOut])
              __break(0x5519u);
          }
          v17 = VCMediaControlInfoSerialize(*(_QWORD *)(v11 + 184));
          if (v17 < 0)
          {
            v33 = v17;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              v47 = VRTraceErrorLogLevelToCSTR();
              v34 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              {
                v35 = *(unsigned __int16 *)(v11 + 248);
                v36 = *(_QWORD *)(v11 + 184);
                *(_DWORD *)buf = 136316418;
                v52 = v47;
                v53 = 2080;
                v54 = "_VCMediaQueue_SerializeControlInfoIntoBufferForOneToOne";
                v55 = 1024;
                v56 = 1673;
                v57 = 1024;
                v58 = v33;
                v59 = 1024;
                v60 = v35;
                v61 = 2048;
                v62[0] = v36;
                v30 = v34;
                v37 = "VCMediaQueue [%s] %s:%d Adding extension failed when serializing control info, with result=%08X fo"
                      "r packet sequenceNum=%u controlInfo=%p";
                v38 = 50;
LABEL_45:
                _os_log_error_impl(&dword_1D8A54000, v30, OS_LOG_TYPE_ERROR, v37, buf, v38);
              }
            }
          }
        }
      }
    }
    if ((const void *)v11 == CMSimpleQueueGetHead(*(CMSimpleQueueRef *)(a1 + 8)))
    {
      v24 = *(opaqueCMSimpleQueue **)a1;
      v25 = CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 8));
      v26 = CMSimpleQueueEnqueue(v24, v25);
      if (!v26)
        goto LABEL_29;
      v39 = v26;
      if ((int)VRTraceGetErrorLogLevelForModule() < 3)
        goto LABEL_29;
      v48 = VRTraceErrorLogLevelToCSTR();
      v40 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        goto LABEL_29;
      v41 = *(_DWORD *)(v11 + 228);
      *(_DWORD *)buf = 136316162;
      v52 = v48;
      v53 = 2080;
      v54 = "_VCMediaQueue_FlushInternalQueueBeforeTimestamp";
      v55 = 1024;
      v56 = 1703;
      v57 = 1024;
      v58 = v39;
      v59 = 1024;
      v60 = v41;
      v21 = v40;
      v22 = "VCMediaQueue [%s] %s:%d Internal queue has error %d when free media packet for mediaQueueStreamId=%u";
      v23 = 40;
    }
    else
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 3)
        goto LABEL_29;
      v18 = VRTraceErrorLogLevelToCSTR();
      v19 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        goto LABEL_29;
      v20 = *(_DWORD *)(v11 + 228);
      *(_DWORD *)buf = 136315906;
      v52 = v18;
      v53 = 2080;
      v54 = "_VCMediaQueue_FlushInternalQueueBeforeTimestamp";
      v55 = 1024;
      v56 = 1705;
      v57 = 1024;
      v58 = v20;
      v21 = v19;
      v22 = "VCMediaQueue [%s] %s:%d Media packets are drained from the busy pool of stream=%u out of order!";
      v23 = 34;
    }
    _os_log_error_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_ERROR, v22, buf, v23);
LABEL_29:
    v27 = *(_QWORD *)(v11 + 184);
    if (v27)
    {
      VCMediaControlInfoDispose(v27);
      *(_QWORD *)(v11 + 184) = 0;
    }
    _VCMediaQueue_ReleaseExternalDataBuffer(a2, v11);
    ++v9;
  }
  while (CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 16)) > 0);
  *(_QWORD *)(a2 + 536) += v9;
  if (v9)
  {
    _VCMediaQueue_ReportingEvent((_DWORD *)a2, 194, *(_DWORD *)(a1 + 124));
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v43 = VRTraceErrorLogLevelToCSTR();
      v44 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        Count = CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 16));
        *(_DWORD *)buf = 136316162;
        v52 = v43;
        v53 = 2080;
        v54 = "_VCMediaQueue_FlushInternalQueueBeforeTimestamp";
        v55 = 1024;
        v56 = 1715;
        v57 = 1024;
        v58 = v9;
        v59 = 1024;
        v60 = Count;
        _os_log_impl(&dword_1D8A54000, v44, OS_LOG_TYPE_DEFAULT, "VCMediaQueue [%s] %s:%d VCMediaQueue internal queue flushed with %u packets, %d remaining", buf, 0x28u);
      }
    }
    _VCMediaQueue_CheckAndReportSymptomForInternalQueue(a1);
  }
}

uint64_t _VCMediaQueue_DrainAllPacketsFromMainQueue(uint64_t a1)
{
  uint64_t v2;

  if (CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 616)) < 1)
    return 0;
  LODWORD(v2) = 0;
  do
  {
    CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 616));
    _VCMediaQueue_SendAndFreePackets(a1);
    ++*(_DWORD *)(a1 + 436);
    v2 = (v2 + 1);
  }
  while (CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 616)) > 0);
  return v2;
}

void sub_1D8E9AE84(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1D8E9B110(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1D8E9B26C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t VCVirtualHardwareConfigurations_EmbeddedConfigurationForDevice(void *a1, __int128 *a2)
{
  uint64_t result;
  uint64_t v5;
  __int128 *i;
  __int128 v7;
  __int128 v8;

  result = 0;
  if (a1 && VCVirtualHardwareConfiguration_iOSConfigurationsCount)
  {
    v5 = 0;
    for (i = &VCVirtualHardwareConfiguration_iOSConfigurations;
          !objc_msgSend(a1, "isEqualToString:", *(_QWORD *)i);
          i += 3)
    {
      if (++v5 >= (unint64_t)VCVirtualHardwareConfiguration_iOSConfigurationsCount)
        return 0;
    }
    if (a2)
    {
      v7 = *i;
      v8 = i[2];
      a2[1] = i[1];
      a2[2] = v8;
      *a2 = v7;
    }
    return 1;
  }
  return result;
}

uint64_t VCVirtualHardwareConfigurations_OSXConfigurationForDevice(void *a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  __CFString **i;
  __int128 v7;
  __int128 v8;
  __int128 v9;

  result = 0;
  if (a1 && VCVirtualHardwareConfiguration_OSXConfigurationsCount)
  {
    v5 = 0;
    for (i = &off_1F01BC030; !objc_msgSend(a1, "isEqualToString:", *i); i += 9)
    {
      if (++v5 >= (unint64_t)VCVirtualHardwareConfiguration_OSXConfigurationsCount)
        return 0;
    }
    if (a2)
    {
      *(_OWORD *)a2 = *(_OWORD *)(i - 1);
      v7 = *(_OWORD *)(i + 1);
      v8 = *(_OWORD *)(i + 3);
      v9 = *(_OWORD *)(i + 5);
      *(_QWORD *)(a2 + 64) = i[7];
      *(_OWORD *)(a2 + 32) = v8;
      *(_OWORD *)(a2 + 48) = v9;
      *(_OWORD *)(a2 + 16) = v7;
    }
    return 1;
  }
  return result;
}

uint64_t VCVirtualHardwareConfigurations_DevicePlatform(void *a1)
{
  int v2;
  unint64_t v3;
  __int128 *v4;
  unint64_t v5;
  __CFString **v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v10;
  NSObject *v11;

  v2 = 0;
  if (a1 && VCVirtualHardwareConfiguration_iOSConfigurationsCount)
  {
    v3 = 0;
    v4 = &VCVirtualHardwareConfiguration_iOSConfigurations;
    do
    {
      v2 = objc_msgSend(a1, "isEqualToString:", *(_QWORD *)v4);
      if (v2)
        break;
      ++v3;
      v4 += 3;
    }
    while (v3 < VCVirtualHardwareConfiguration_iOSConfigurationsCount);
  }
  if (a1 && VCVirtualHardwareConfiguration_OSXConfigurationsCount)
  {
    v5 = 0;
    v6 = &off_1F01BC030;
    while ((objc_msgSend(a1, "isEqualToString:", *v6) & 1) == 0)
    {
      ++v5;
      v6 += 9;
      if (v5 >= VCVirtualHardwareConfiguration_OSXConfigurationsCount)
        goto LABEL_11;
    }
    if (!v2)
      return v2 ^ 1u;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v10 = VRTraceErrorLogLevelToCSTR();
      v11 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCVirtualHardwareConfigurations_DevicePlatform_cold_2(v10, v11);
    }
  }
  else
  {
LABEL_11:
    if ((v2 & 1) != 0)
      return v2 ^ 1u;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v7 = VRTraceErrorLogLevelToCSTR();
      v8 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCVirtualHardwareConfigurations_DevicePlatform_cold_1(v7, (uint64_t)a1, v8);
    }
  }
  return 2;
}

void sub_1D8E9BD3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1D8E9F304(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  _Unwind_Resume(exception_object);
}

void sub_1D8E9F4D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  _Unwind_Resume(exception_object);
}

void sub_1D8E9F6B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  _Unwind_Resume(exception_object);
}

void sub_1D8E9F88C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  _Unwind_Resume(exception_object);
}

void sub_1D8EA29FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1D8EA3F40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  uint64_t v13;
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v13 - 112), 8);
  _Unwind_Resume(a1);
}

uint64_t init_WiFiCopyCurrentNetworkInfoEx(uint64_t a1, uint64_t a2)
{
  if (LoadCoreUtils_loadPredicate != -1)
    dispatch_once(&LoadCoreUtils_loadPredicate, &__block_literal_global_78);
  softLink_WiFiCopyCurrentNetworkInfoEx = (uint64_t (*)())dlsym((void *)LoadCoreUtils_frameworkLibrary, "WiFiCopyCurrentNetworkInfoEx");
  return ((uint64_t (*)(uint64_t, uint64_t))softLink_WiFiCopyCurrentNetworkInfoEx)(a1, a2);
}

uint64_t init_WiFiManagerCreate(uint64_t a1, uint64_t a2)
{
  if (LoadCoreUtils_loadPredicate != -1)
    dispatch_once(&LoadCoreUtils_loadPredicate, &__block_literal_global_78);
  softLink_WiFiManagerCreate = (uint64_t (*)())dlsym((void *)LoadCoreUtils_frameworkLibrary, "WiFiManagerCreate");
  return ((uint64_t (*)(uint64_t, uint64_t))softLink_WiFiManagerCreate)(a1, a2);
}

uint64_t init_WiFiManagerSetProperty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (LoadCoreUtils_loadPredicate != -1)
    dispatch_once(&LoadCoreUtils_loadPredicate, &__block_literal_global_78);
  softLink_WiFiManagerSetProperty = (uint64_t (*)())dlsym((void *)LoadCoreUtils_frameworkLibrary, "WiFiManagerSetProperty");
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))softLink_WiFiManagerSetProperty)(a1, a2, a3, a4);
}

uint64_t init_WiFiManagerDoApple80211(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (LoadCoreUtils_loadPredicate != -1)
    dispatch_once(&LoadCoreUtils_loadPredicate, &__block_literal_global_78);
  softLink_WiFiManagerDoApple80211 = (uint64_t (*)())dlsym((void *)LoadCoreUtils_frameworkLibrary, "WiFiManagerDoApple80211");
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))softLink_WiFiManagerDoApple80211)(a1, a2, a3, a4, a5);
}

uint64_t initkWiFiManagerPropertyInterfaceName()
{
  uint64_t result;

  if (LoadCoreUtils_loadPredicate != -1)
    dispatch_once(&LoadCoreUtils_loadPredicate, &__block_literal_global_78);
  result = *(_QWORD *)dlsym((void *)LoadCoreUtils_frameworkLibrary, "kWiFiManagerPropertyInterfaceName");
  constantkWiFiManagerPropertyInterfaceName = result;
  getkWiFiManagerPropertyInterfaceName = kWiFiManagerPropertyInterfaceNameFunction;
  return result;
}

uint64_t kWiFiManagerPropertyInterfaceNameFunction()
{
  return constantkWiFiManagerPropertyInterfaceName;
}

uint64_t OUTLINED_FUNCTION_13_8@<X0>(void *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  *(_QWORD *)(v2 - 24) = a2;
  return objc_msgSend(a1, "codecType");
}

uint64_t OUTLINED_FUNCTION_14_13@<X0>(void *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  *(_QWORD *)(v2 - 24) = a2;
  return objc_msgSend(a1, "cipherSuite");
}

BOOL VCDuplicationHandler_IsDuplicationEnabled(_BOOL8 result)
{
  if (result)
    return *(unsigned __int8 *)(result + 8) == 2;
  return result;
}

uint64_t VCDuplicationHandler_HandleDuplicationStateUpdateEvent(_BYTE *a1, uint64_t a2, uint64_t a3)
{
  char v5;
  char v6;
  int v7;
  uint64_t v8;
  NSObject *v9;
  const char *v10;
  int v11;
  uint64_t v12;
  int v13;
  unsigned int v14;
  BOOL v15;
  int v16;
  uint64_t v18;
  NSObject *v19;
  const char *v20;
  NSObject *v21;
  uint32_t v22;
  int v23;
  uint64_t v24;
  NSObject *v25;
  const char *v26;
  uint64_t v27;
  NSObject *v28;
  uint64_t v29;
  uint64_t v30;
  _BYTE *v31;
  char v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char v44;
  char updated;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v50;
  uint64_t v51;
  uint8_t buf[4];
  uint64_t v53;
  __int16 v54;
  const char *v55;
  __int16 v56;
  int v57;
  __int16 v58;
  const char *v59;
  uint64_t v60;

  v60 = *MEMORY[0x1E0C80C00];
  v51 = 0;
  if (a1)
  {
    switch((char)a2)
    {
      case 0:
      case 2:
        if (a1[9])
          return v51;
        v5 = a2;
        if ((_BYTE)a2)
        {
          if (a2 != 2)
            return v51;
        }
        else
        {
          v5 = 1;
        }
        a1[9] = v5;
        VCDuplicationHandler_EnableDuplication(a1);
        LOBYTE(v51) = 1;
        return v51;
      case 1:
      case 3:
        if (a1[9] - 1 <= 1)
        {
          a1[9] = 0;
          VCDuplicationHandler_DisableDuplication((uint64_t)a1);
          v6 = 1;
          goto LABEL_110;
        }
        return v51;
      case 4:
        HIDWORD(v51) = 0;
        if (a1[23])
        {
          v7 = a1[9];
          if ((a2 & 0x100) != 0)
          {
            if (v7 != 4)
              return v51;
          }
          else if (v7 != 4)
          {
            if (a1[9])
              goto LABEL_106;
            a1[9] = 3;
            VCDuplicationHandler_EnableDuplication(a1);
            LOWORD(v51) = 257;
            HIDWORD(v51) = 2;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v8 = VRTraceErrorLogLevelToCSTR();
              v9 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315650;
                v53 = v8;
                v54 = 2080;
                v55 = "_VCDuplicationHandler_UpdateDuplicationStateForLocalWRMSuggestingCellularEvent";
                v56 = 1024;
                v57 = 179;
                v10 = " [%s] %s:%d HandoverReport: start dupe by local media degraded.";
                goto LABEL_122;
              }
            }
            return v51;
          }
          a1[9] = 5;
          VCDuplicationHandler_EnableDuplication(a1);
          BYTE1(v51) = 1;
          HIDWORD(v51) = 2;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v43 = VRTraceErrorLogLevelToCSTR();
            v9 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315650;
              v53 = v43;
              v54 = 2080;
              v55 = "_VCDuplicationHandler_UpdateDuplicationStateForLocalWRMSuggestingCellularEvent";
              v56 = 1024;
              v57 = 186;
              v10 = " [%s] %s:%d HandoverReport: start dupe by both local media degraded and remote duplication.";
              goto LABEL_122;
            }
          }
        }
        else if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v36 = VRTraceErrorLogLevelToCSTR();
          v9 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315650;
            v53 = v36;
            v54 = 2080;
            v55 = "_VCDuplicationHandler_UpdateDuplicationStateForLocalWRMSuggestingCellularEvent";
            v56 = 1024;
            v57 = 166;
            v10 = " [%s] %s:%d HandoverReport: Ignoring iRAT suggestion as directed by storebag settings";
            goto LABEL_122;
          }
        }
        return v51;
      case 5:
        if (a1[23])
        {
          v11 = a1[9];
          if ((a2 & 0x100) != 0 || a1[9])
          {
            if (v11 == 5)
            {
              a1[9] = 4;
              VCDuplicationHandler_EnableDuplication(a1);
              BYTE1(v51) = 1;
              HIDWORD(v51) = 3;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v48 = VRTraceErrorLogLevelToCSTR();
                v9 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 136315650;
                  v53 = v48;
                  v54 = 2080;
                  v55 = "_VCDuplicationHandler_UpdateDuplicationStateForLocalWRMSuggestingWiFiEvent";
                  v56 = 1024;
                  v57 = 214;
                  v10 = " [%s] %s:%d HandoverReport: stop dupe by local media degraded but remain dupe by remote duplication.";
                  goto LABEL_122;
                }
              }
            }
            else if (v11 == 3)
            {
              a1[9] = 0;
              VCDuplicationHandler_DisableDuplication((uint64_t)a1);
              LOWORD(v51) = 257;
              HIDWORD(v51) = 3;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v12 = VRTraceErrorLogLevelToCSTR();
                v9 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 136315650;
                  v53 = v12;
                  v54 = 2080;
                  v55 = "_VCDuplicationHandler_UpdateDuplicationStateForLocalWRMSuggestingWiFiEvent";
                  v56 = 1024;
                  v57 = 207;
                  v10 = " [%s] %s:%d HandoverReport: stop dupe by local media degraded.";
                  goto LABEL_122;
                }
              }
            }
            else
            {
LABEL_106:
              _VCDuplicationHandler_ShareLocalInterfacePreferenceWithPeerDuringActiveDuplicationForEvent(a1, a2, a3, (uint64_t)&v51);
            }
          }
        }
        else if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v37 = VRTraceErrorLogLevelToCSTR();
          v9 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315650;
            v53 = v37;
            v54 = 2080;
            v55 = "_VCDuplicationHandler_UpdateDuplicationStateForLocalWRMSuggestingWiFiEvent";
            v56 = 1024;
            v57 = 194;
            v10 = " [%s] %s:%d HandoverReport: Ignoring iRAT suggestion as directed by storebag settings";
            goto LABEL_122;
          }
        }
        return v51;
      case 6:
        v13 = 1;
        goto LABEL_72;
      case 7:
        _VCDuplicationHandler_StopRemoteDuplicationAndUpdateResult(a1, &v51, 1);
        v14 = a1[9];
        v15 = v14 > 6;
        v16 = (1 << v14) & 0x46;
        if (v15 || v16 == 0)
          return v51;
        if ((int)VRTraceGetErrorLogLevelForModule() < 7)
          return v51;
        v18 = VRTraceErrorLogLevelToCSTR();
        v19 = *MEMORY[0x1E0CF2758];
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          return v51;
        v20 = "WiFi";
        *(_DWORD *)buf = 136315906;
        v53 = v18;
        v54 = 2080;
        v55 = "_VCDuplicationHandler_UpdateDuplicationStateForRemoteWRMSuggestingWiFiEvent";
        if ((a2 & 0x10000000000) == 0)
          v20 = "Cellular";
        v56 = 1024;
        v57 = 224;
        v58 = 2080;
        v59 = v20;
        v10 = " [%s] %s:%d HandoverReport: remote duplication suggests %s during other type of duplication.";
        v21 = v19;
        v22 = 38;
        goto LABEL_123;
      case 8:
        a1[10] = 1;
        return v51;
      case 9:
        a1[10] = 0;
        return v51;
      case 10:
        HIDWORD(v51) = 0;
        v23 = a1[9];
        if ((v23 - 3) > 2)
          return v51;
        switch(v23)
        {
          case 5:
            BYTE1(v51) = 1;
            HIDWORD(v51) = 3;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v46 = VRTraceErrorLogLevelToCSTR();
              v25 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315650;
                v53 = v46;
                v54 = 2080;
                v55 = "_VCDuplicationHandler_UpdateDuplicationStateForTurnOffDuplicationForHandoverEvent";
                v56 = 1024;
                v57 = 270;
                v26 = " [%s] %s:%d HandoverReport: stop dupe by both local media degraded and remote duplication in handover.";
                goto LABEL_117;
              }
            }
            break;
          case 4:
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v47 = VRTraceErrorLogLevelToCSTR();
              v25 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315650;
                v53 = v47;
                v54 = 2080;
                v55 = "_VCDuplicationHandler_UpdateDuplicationStateForTurnOffDuplicationForHandoverEvent";
                v56 = 1024;
                v57 = 272;
                v26 = " [%s] %s:%d HandoverReport: stop dupe by remote media degraded in handover.";
                goto LABEL_117;
              }
            }
            break;
          case 3:
            BYTE1(v51) = 1;
            HIDWORD(v51) = 3;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v24 = VRTraceErrorLogLevelToCSTR();
              v25 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315650;
                v53 = v24;
                v54 = 2080;
                v55 = "_VCDuplicationHandler_UpdateDuplicationStateForTurnOffDuplicationForHandoverEvent";
                v56 = 1024;
                v57 = 266;
                v26 = " [%s] %s:%d HandoverReport: stop dupe by local media degraded in handover.";
LABEL_117:
                _os_log_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_DEFAULT, v26, buf, 0x1Cu);
              }
            }
            break;
        }
        LOBYTE(v51) = 1;
        a1[9] = 0;
        VCDuplicationHandler_DisableDuplication((uint64_t)a1);
        return v51;
      case 11:
        if (a1[23])
        {
          HIDWORD(v51) = 0;
          if ((a2 & 0x1000000) == 0 && !a1[9])
          {
            if ((a2 & 0x100000000) == 0)
            {
              a1[9] = 3;
              VCDuplicationHandler_EnableDuplication(a1);
              LOWORD(v51) = 257;
              HIDWORD(v51) = 2;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v27 = VRTraceErrorLogLevelToCSTR();
                v28 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 136315650;
                  v53 = v27;
                  v54 = 2080;
                  v55 = "_VCDuplicationHandler_UpdateDuplicationStateForTurnOnDuplicationForHandoverEvent";
                  v56 = 1024;
                  v57 = 294;
                  _os_log_impl(&dword_1D8A54000, v28, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d HandoverReport: start dupe by local media degraded in handover.", buf, 0x1Cu);
                }
              }
            }
            if ((a2 & 0x10000000000) == 0)
            {
              a1[9] = 4;
              VCDuplicationHandler_EnableDuplication(a1);
              LOBYTE(v51) = 1;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v29 = VRTraceErrorLogLevelToCSTR();
                v9 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 136315650;
                  v53 = v29;
                  v54 = 2080;
                  v55 = "_VCDuplicationHandler_UpdateDuplicationStateForTurnOnDuplicationForHandoverEvent";
                  v56 = 1024;
                  v57 = 300;
                  v10 = " [%s] %s:%d HandoverReport: start dupe by remote media degraded in handover.";
                  goto LABEL_122;
                }
              }
            }
          }
        }
        else if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v38 = VRTraceErrorLogLevelToCSTR();
          v9 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315650;
            v53 = v38;
            v54 = 2080;
            v55 = "_VCDuplicationHandler_UpdateDuplicationStateForTurnOnDuplicationForHandoverEvent";
            v56 = 1024;
            v57 = 282;
            v10 = " [%s] %s:%d HandoverReport: Ignoring iRAT suggestion as directed by storebag settings";
            goto LABEL_122;
          }
        }
        return v51;
      case 12:
        v30 = 15;
        if ((a2 & 0x1000000000000) != 0)
          v30 = 11;
        a1[v30] = HIBYTE(a2) & 1;
        LOBYTE(v51) = _VCDuplicationHandler_UpdateDuplicationStateWithAlertInfo(a1, (a2 & 0x1000000000000uLL) >> 48);
        return v51;
      case 13:
        if (!(_DWORD)a3)
        {
          v39 = 12;
          if ((a3 & 0x100000000) == 0)
            v39 = 13;
          ++a1[v39];
          if ((a3 & 0x10000000000) == 0)
          {
            v40 = a1[17] + 1;
LABEL_101:
            a1[17] = v40;
            goto LABEL_109;
          }
          v44 = a1[16] + 1;
          goto LABEL_108;
        }
        if ((a3 & 0x100000000) != 0)
        {
          v31 = a1 + 12;
          v32 = a1[12];
          if (!v32)
            goto LABEL_98;
        }
        else
        {
          v31 = a1 + 13;
          v32 = a1[13];
          if (!v32)
            goto LABEL_98;
        }
        *v31 = v32 - 1;
LABEL_98:
        if ((a3 & 0x10000000000) == 0)
        {
          if (!a1[17])
            goto LABEL_109;
          v40 = a1[17] - 1;
          goto LABEL_101;
        }
        if (a1[16])
        {
          v44 = a1[16] - 1;
LABEL_108:
          a1[16] = v44;
        }
LABEL_109:
        updated = _VCDuplicationHandler_UpdateDuplicationStateWithAlertInfo(a1, 1);
        v6 = updated | _VCDuplicationHandler_UpdateDuplicationStateWithAlertInfo(a1, 0);
LABEL_110:
        LOBYTE(v51) = v6;
        break;
      case 14:
        if (a1[9] == 4)
        {
          a1[9] = 7;
          VCDuplicationHandler_EnableDuplication(a1);
          LOWORD(v51) = 256;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v41 = VRTraceErrorLogLevelToCSTR();
            v9 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315650;
              v53 = v41;
              v54 = 2080;
              v55 = "_VCDuplicationHandler_UpdateDuplicationStateForMediaHealthUnrecoverable";
              v56 = 1024;
              v57 = 366;
              v10 = " [%s] %s:%d HandoverReport: start dupe by both local media health unrecoverable and remote duplication.";
              goto LABEL_122;
            }
          }
        }
        else if (!a1[9])
        {
          a1[9] = 6;
          VCDuplicationHandler_EnableDuplication(a1);
          LOWORD(v51) = 257;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v33 = VRTraceErrorLogLevelToCSTR();
            v9 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315650;
              v53 = v33;
              v54 = 2080;
              v55 = "_VCDuplicationHandler_UpdateDuplicationStateForMediaHealthUnrecoverable";
              v56 = 1024;
              v57 = 359;
              v10 = " [%s] %s:%d HandoverReport: start dupe by media health unrecoverable.";
              goto LABEL_122;
            }
          }
        }
        return v51;
      case 15:
        v34 = a1[9];
        if (v34 == 7)
        {
          a1[9] = 4;
          VCDuplicationHandler_EnableDuplication(a1);
          LOWORD(v51) = 256;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v42 = VRTraceErrorLogLevelToCSTR();
            v9 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315650;
              v53 = v42;
              v54 = 2080;
              v55 = "_VCDuplicationHandler_UpdateDuplicationStateForMediaHealthRecovered";
              v56 = 1024;
              v57 = 384;
              v10 = " [%s] %s:%d HandoverReport: stop dupe by media health recovered but remain dupe by remote duplication.";
              goto LABEL_122;
            }
          }
        }
        else if (v34 == 6)
        {
          a1[9] = 0;
          VCDuplicationHandler_DisableDuplication((uint64_t)a1);
          LOWORD(v51) = 257;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v35 = VRTraceErrorLogLevelToCSTR();
            v9 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315650;
              v53 = v35;
              v54 = 2080;
              v55 = "_VCDuplicationHandler_UpdateDuplicationStateForMediaHealthRecovered";
              v56 = 1024;
              v57 = 377;
              v10 = " [%s] %s:%d HandoverReport: stop dupe by media health recovered.";
              goto LABEL_122;
            }
          }
        }
        return v51;
      case 16:
        v13 = 0;
LABEL_72:
        _VCDuplicationHandler_UpdateDuplicationStateForRemoteDuplicationChanged(a1, a2, a3, &v51, v13);
        return v51;
      default:
        return v51;
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v50 = VRTraceErrorLogLevelToCSTR();
    v9 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      v53 = v50;
      v54 = 2080;
      v55 = "VCDuplicationHandler_HandleDuplicationStateUpdateEvent";
      v56 = 1024;
      v57 = 53;
      v10 = " [%s] %s:%d nil instance passed";
LABEL_122:
      v21 = v9;
      v22 = 28;
LABEL_123:
      _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, v10, buf, v22);
    }
  }
  return v51;
}

void _VCDuplicationHandler_UpdateDuplicationStateForRemoteDuplicationChanged(_BYTE *a1, uint64_t a2, uint64_t a3, _WORD *a4, int a5)
{
  unsigned int v8;
  BOOL v9;
  int v10;
  uint64_t v12;
  NSObject *v13;
  const char *v14;
  int v15;
  uint64_t v16;
  NSObject *v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  int v26;
  __int16 v27;
  const char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  if ((a2 & 0x10000) == 0)
  {
    _VCDuplicationHandler_StopRemoteDuplicationAndUpdateResult(a1, a4, a5);
    goto LABEL_3;
  }
  v15 = a1[9];
  if (v15 == 6)
  {
    a1[9] = 7;
    VCDuplicationHandler_EnableDuplication(a1);
    *a4 = 0;
    if ((int)VRTraceGetErrorLogLevelForModule() < 7)
      goto LABEL_3;
    v19 = VRTraceErrorLogLevelToCSTR();
    v17 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      goto LABEL_3;
    v21 = 136315650;
    v22 = v19;
    v23 = 2080;
    v24 = "_VCDuplicationHandler_UpdateDuplicationStateForRemoteDuplicationChanged";
    v25 = 1024;
    v26 = 420;
    v18 = " [%s] %s:%d HandoverReport: start dupe by both local media health unrecoverable and remote duplication.";
    goto LABEL_29;
  }
  if (v15 == 3)
  {
    a1[9] = 5;
    if (a5)
    {
      a1[15] = 1;
      *(_BYTE *)a4 = _VCDuplicationHandler_UpdateDuplicationStateWithAlertInfo(a1, 0);
    }
    VCDuplicationHandler_EnableDuplication(a1);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v20 = VRTraceErrorLogLevelToCSTR();
      v17 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v21 = 136315650;
        v22 = v20;
        v23 = 2080;
        v24 = "_VCDuplicationHandler_UpdateDuplicationStateForRemoteDuplicationChanged";
        v25 = 1024;
        v26 = 413;
        v18 = " [%s] %s:%d HandoverReport: start dupe by both remote and local media degraded.";
        goto LABEL_29;
      }
    }
  }
  else if (!a1[9])
  {
    a1[9] = 4;
    if (a5)
    {
      a1[15] = 1;
      _VCDuplicationHandler_UpdateDuplicationStateWithAlertInfo(a1, 0);
    }
    VCDuplicationHandler_EnableDuplication(a1);
    *a4 = 1;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v16 = VRTraceErrorLogLevelToCSTR();
      v17 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v21 = 136315650;
        v22 = v16;
        v23 = 2080;
        v24 = "_VCDuplicationHandler_UpdateDuplicationStateForRemoteDuplicationChanged";
        v25 = 1024;
        v26 = 403;
        v18 = " [%s] %s:%d HandoverReport: start dupe by remote duplication.";
LABEL_29:
        _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, v18, (uint8_t *)&v21, 0x1Cu);
      }
    }
  }
LABEL_3:
  v8 = a1[9];
  v9 = v8 > 6;
  v10 = (1 << v8) & 0x46;
  if (!v9 && v10 != 0 && (int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v12 = VRTraceErrorLogLevelToCSTR();
    v13 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v14 = "WiFi";
      v21 = 136315906;
      v22 = v12;
      v23 = 2080;
      v24 = "_VCDuplicationHandler_UpdateDuplicationStateForRemoteDuplicationChanged";
      if ((a2 & 0x10000000000) == 0)
        v14 = "Cellular";
      v25 = 1024;
      v26 = 425;
      v27 = 2080;
      v28 = v14;
      _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d HandoverReport: remote duplication suggests %s during other type of duplication.", (uint8_t *)&v21, 0x26u);
    }
  }
}

void VCDuplicationHandler_EnableDuplication(_BYTE *a1)
{
  uint64_t v1;
  NSObject *v2;
  const char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  int v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a1[21])
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v1 = VRTraceErrorLogLevelToCSTR();
        v2 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v8 = 136315650;
          v9 = v1;
          v10 = 2080;
          v11 = "VCDuplicationHandler_EnableDuplication";
          v12 = 1024;
          v13 = 112;
          v3 = " [%s] %s:%d HandoverReport: Duplication is forcibly disabled using user defaults";
LABEL_15:
          _os_log_impl(&dword_1D8A54000, v2, OS_LOG_TYPE_DEFAULT, v3, (uint8_t *)&v8, 0x1Cu);
        }
      }
    }
    else if (a1[20])
    {
      if (a1[14] || a1[18])
      {
        a1[8] = 1;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v4 = VRTraceErrorLogLevelToCSTR();
          v2 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v8 = 136315650;
            v9 = v4;
            v10 = 2080;
            v11 = "VCDuplicationHandler_EnableDuplication";
            v12 = 1024;
            v13 = 121;
            v3 = " [%s] %s:%d HandoverReport: Duplication state changed to PENDING";
            goto LABEL_15;
          }
        }
      }
      else
      {
        a1[8] = 2;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v6 = VRTraceErrorLogLevelToCSTR();
          v2 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v8 = 136315650;
            v9 = v6;
            v10 = 2080;
            v11 = "VCDuplicationHandler_EnableDuplication";
            v12 = 1024;
            v13 = 124;
            v3 = " [%s] %s:%d HandoverReport: Duplication state changed to ON";
            goto LABEL_15;
          }
        }
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v2 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v8 = 136315650;
        v9 = v5;
        v10 = 2080;
        v11 = "VCDuplicationHandler_EnableDuplication";
        v12 = 1024;
        v13 = 116;
        v3 = " [%s] %s:%d HandoverReport: Duplication cannot be enabled due to WiFi off-channel activity";
        goto LABEL_15;
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v7 = VRTraceErrorLogLevelToCSTR();
    v2 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v8 = 136315650;
      v9 = v7;
      v10 = 2080;
      v11 = "VCDuplicationHandler_EnableDuplication";
      v12 = 1024;
      v13 = 110;
      v3 = " [%s] %s:%d nil instance passed";
      goto LABEL_15;
    }
  }
}

void VCDuplicationHandler_DisableDuplication(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  int v3;
  uint64_t v4;
  __int16 v5;
  const char *v6;
  __int16 v7;
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    *(_BYTE *)(a1 + 8) = 0;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v1 = VRTraceErrorLogLevelToCSTR();
      v2 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v3 = 136315650;
        v4 = v1;
        v5 = 2080;
        v6 = "VCDuplicationHandler_DisableDuplication";
        v7 = 1024;
        v8 = 133;
        _os_log_impl(&dword_1D8A54000, v2, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d HandoverReport: Duplication state changed to OFF", (uint8_t *)&v3, 0x1Cu);
      }
    }
  }
}

uint64_t VCDuplicationHandler_DuplicationReason(uint64_t a1)
{
  uint64_t result;
  uint64_t v2;
  NSObject *v3;
  _BOOL4 v4;
  int v5;
  uint64_t v6;
  __int16 v7;
  const char *v8;
  __int16 v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (a1)
    return *(unsigned __int8 *)(a1 + 9);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    v4 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v4)
      return result;
    v5 = 136315650;
    v6 = v2;
    v7 = 2080;
    v8 = "VCDuplicationHandler_DuplicationReason";
    v9 = 1024;
    v10 = 451;
    _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v5, 0x1Cu);
  }
  return 0;
}

uint64_t VCDuplicationHandler_DuplicationReasonForReporting(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  NSObject *v4;
  _BOOL4 v5;
  int v6;
  uint64_t v7;
  __int16 v8;
  const char *v9;
  __int16 v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (*(_BYTE *)(a1 + 9) != 3 || *(_BYTE *)(a1 + 19) == 0)
      return *(unsigned __int8 *)(a1 + 9);
    else
      return 8;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v3 = VRTraceErrorLogLevelToCSTR();
      v4 = *MEMORY[0x1E0CF2758];
      v5 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
      result = 0;
      if (!v5)
        return result;
      v6 = 136315650;
      v7 = v3;
      v8 = 2080;
      v9 = "VCDuplicationHandler_DuplicationReasonForReporting";
      v10 = 1024;
      v11 = 459;
      _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v6, 0x1Cu);
    }
    return 0;
  }
}

void _VCDuplicationHandler_ShareLocalInterfacePreferenceWithPeerDuringActiveDuplicationForEvent(_BYTE *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int v4;
  BOOL v5;
  int v6;
  uint64_t v10;
  NSObject *v11;
  const char *v12;
  int v13;
  uint64_t v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  const char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v4 = a1[9];
  v5 = v4 > 6;
  v6 = (1 << v4) & 0x46;
  if (!v5 && v6 != 0)
  {
    VCDuplicationHandler_EnableDuplication(a1);
    *(_BYTE *)(a4 + 1) = 1;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v10 = VRTraceErrorLogLevelToCSTR();
      v11 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v12 = "WiFi";
        v13 = 136315906;
        v14 = v10;
        v15 = 2080;
        v16 = "_VCDuplicationHandler_ShareLocalInterfacePreferenceWithPeerDuringActiveDuplicationForEvent";
        if ((a2 & 0x100000000) == 0)
          v12 = "Cellular";
        v17 = 1024;
        v18 = 436;
        v19 = 2080;
        v20 = v12;
        _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d HandoverReport: local media degraded suggests %s during other type of duplication.", (uint8_t *)&v13, 0x26u);
      }
    }
  }
}

void _VCDuplicationHandler_StopRemoteDuplicationAndUpdateResult(_BYTE *a1, _WORD *a2, int a3)
{
  int v5;
  uint64_t v7;
  NSObject *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v5 = a1[9];
  switch(v5)
  {
    case 7:
      a1[9] = 6;
      VCDuplicationHandler_EnableDuplication(a1);
      *a2 = 0;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v10 = VRTraceErrorLogLevelToCSTR();
        v8 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v12 = 136315650;
          v13 = v10;
          v14 = 2080;
          v15 = "_VCDuplicationHandler_StopRemoteDuplicationAndUpdateResult";
          v16 = 1024;
          v17 = 255;
          v9 = " [%s] %s:%d HandoverReport: stop dupe by remote duplication but remain dupe by local media health unrecoverable.";
          goto LABEL_19;
        }
      }
      break;
    case 5:
      a1[9] = 3;
      if (a3 && a1[22])
      {
        a1[15] = 0;
        *(_BYTE *)a2 = _VCDuplicationHandler_UpdateDuplicationStateWithAlertInfo(a1, 0);
      }
      VCDuplicationHandler_EnableDuplication(a1);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v11 = VRTraceErrorLogLevelToCSTR();
        v8 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v12 = 136315650;
          v13 = v11;
          v14 = 2080;
          v15 = "_VCDuplicationHandler_StopRemoteDuplicationAndUpdateResult";
          v16 = 1024;
          v17 = 248;
          v9 = " [%s] %s:%d HandoverReport: stop dupe by remote duplication but remain dupe by local media degraded.";
          goto LABEL_19;
        }
      }
      break;
    case 4:
      a1[9] = 0;
      *a2 = 1;
      VCDuplicationHandler_DisableDuplication((uint64_t)a1);
      if (a3 && a1[22])
      {
        a1[15] = 0;
        _VCDuplicationHandler_UpdateDuplicationStateWithAlertInfo(a1, 0);
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v7 = VRTraceErrorLogLevelToCSTR();
        v8 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v12 = 136315650;
          v13 = v7;
          v14 = 2080;
          v15 = "_VCDuplicationHandler_StopRemoteDuplicationAndUpdateResult";
          v16 = 1024;
          v17 = 239;
          v9 = " [%s] %s:%d HandoverReport: stop dupe by remote duplication.";
LABEL_19:
          _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v12, 0x1Cu);
        }
      }
      break;
  }
}

uint64_t _VCDuplicationHandler_UpdateDuplicationStateWithAlertInfo(_BYTE *a1, int a2)
{
  uint64_t v3;
  unsigned __int8 *v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v17;
  uint64_t v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  int v24;
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v3 = 15;
  if (a2)
    v3 = 11;
  v4 = &a1[v3];
  if (!a1[v3] || v4[1] && v4[2])
  {
    if (v4[3])
    {
      v5 = 0;
      v4[3] = 0;
      if (a1[8] == 1)
      {
        VCDuplicationHandler_EnableDuplication(a1);
        if ((int)VRTraceGetErrorLogLevelForModule() < 7)
          goto LABEL_17;
        v6 = VRTraceErrorLogLevelToCSTR();
        v7 = *MEMORY[0x1E0CF2758];
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          goto LABEL_17;
        v17 = 136315650;
        v18 = v6;
        v19 = 2080;
        v20 = "_VCDuplicationHandler_UpdateDuplicationStateWithAlertInfo";
        v21 = 1024;
        v22 = 344;
        v8 = " [%s] %s:%d HandoverReport: Enable duplication if it is pending, due to interface alert update";
        goto LABEL_16;
      }
      goto LABEL_19;
    }
LABEL_18:
    v5 = 0;
    goto LABEL_19;
  }
  if (v4[3])
    goto LABEL_18;
  v5 = 1;
  v4[3] = 1;
  if (a1[8] != 2)
    goto LABEL_18;
  a1[8] = 1;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v9 = VRTraceErrorLogLevelToCSTR();
    v7 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
LABEL_17:
      v5 = 1;
      goto LABEL_19;
    }
    v17 = 136315650;
    v18 = v9;
    v19 = 2080;
    v20 = "_VCDuplicationHandler_UpdateDuplicationStateWithAlertInfo";
    v21 = 1024;
    v22 = 336;
    v8 = " [%s] %s:%d HandoverReport: Make duplication pending due to interface alert update";
LABEL_16:
    _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&v17, 0x1Cu);
    goto LABEL_17;
  }
LABEL_19:
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v10 = VRTraceErrorLogLevelToCSTR();
    v11 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v12 = *v4;
      v13 = v4[1];
      v14 = v4[2];
      v15 = v4[3];
      v17 = 136316930;
      v18 = v10;
      v19 = 2080;
      v20 = "_VCDuplicationHandler_UpdateDuplicationStateWithAlertInfo";
      v21 = 1024;
      v22 = 348;
      v23 = 1024;
      v24 = a2;
      v25 = 1024;
      v26 = v12;
      v27 = 1024;
      v28 = v13;
      v29 = 1024;
      v30 = v14;
      v31 = 1024;
      v32 = v15;
      _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d HandoverReport: updateDuplicationStateWithAlertInfo - isOnLocal: %d isAlertEnabled: %d connectionWiFiCount: %d connectionCellCount: %d isDuplicationDisabledDueToAlert: %d", (uint8_t *)&v17, 0x3Au);
    }
  }
  return v5;
}

void statsReceiveProc(uint64_t a1)
{
  double v2;
  double v3;
  unsigned __int8 v4[1576];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    bzero(v4, 0x628uLL);
    if ((objc_msgSend(*(id *)(a1 + 88), "receivePacket:", v4) & 0x80000000) != 0)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          statsReceiveProc_cold_2();
      }
      v2 = *(double *)(a1 + 216);
      v3 = micro();
      if (v2 == 0.0)
      {
        *(double *)(a1 + 216) = v3;
      }
      else if (v3 - *(double *)(a1 + 216) >= 5.0)
      {
        objc_msgSend((id)a1, "reportingAgent");
        reportingSymptom();
      }
      usleep(0x2710u);
    }
    else
    {
      _VCSessionStatsController_HandleRemoteSessionStats(a1, v4);
      *(_QWORD *)(a1 + 216) = 0;
    }
    _VCSessionStatsController_HealthPrintForServerStats(a1);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      statsReceiveProc_cold_1();
  }
}

void _VCSessionStatsController_TriggerRateControl(uint64_t a1, uint64_t a2, int a3, char a4, double a5, double a6, double a7)
{
  int v9;
  int v10;
  uint64_t v11;
  NSObject *v12;
  const char *v13;
  _QWORD v14[2];
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;
  uint8_t buf[4];
  uint64_t v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  int v32;
  __int16 v33;
  int v34;
  __int16 v35;
  int v36;
  __int16 v37;
  const char *v38;
  __int16 v39;
  const char *v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  LODWORD(a6) = *(_DWORD *)(a1 + 144);
  LODWORD(a7) = *(_DWORD *)(a1 + 148);
  v9 = (int)((double)*(unint64_t *)&a6 + 45.5);
  v10 = (int)((double)*(unint64_t *)&a7 + 45.5);
  v15 = 0u;
  v26 = 0;
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  v14[0] = 5;
  *(double *)&v14[1] = a5;
  BYTE2(v15) = a4;
  BYTE8(v15) = *(_BYTE *)(a2 + 8);
  HIDWORD(v15) = v9;
  AVCStatisticsCollector_SetVCStatistics(*(_QWORD *)(a1 + 16), (uint64_t)v14);
  *(_DWORD *)(a1 + 144) = v9;
  ++*(_DWORD *)(a1 + 248);
  if (a3)
  {
    HIDWORD(v15) = v10;
    AVCStatisticsCollector_SetVCStatistics(*(_QWORD *)(a1 + 24), (uint64_t)v14);
    *(_DWORD *)(a1 + 148) = v10;
    ++*(_DWORD *)(a1 + 252);
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v11 = VRTraceErrorLogLevelToCSTR();
    v12 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136316674;
      v13 = "NO";
      v28 = v11;
      v29 = 2080;
      v30 = "_VCSessionStatsController_TriggerRateControl";
      v31 = 1024;
      if (a3)
        v13 = "YES";
      v32 = 330;
      v33 = 1024;
      v34 = v9;
      v35 = 1024;
      v36 = v10;
      v37 = 2080;
      v38 = "YES";
      v39 = 2080;
      v40 = v13;
      _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Trigger rate control without serverStats response with uplinkSendTimestamp:0x%04X, downlinkSendTimestamp:0x%04X [uplink:%s, downlink:%s]", buf, 0x3Cu);
    }
  }
}

void _VCSessionStatsController_UpdateRemoteSessionStats(uint64_t a1, uint64_t a2)
{
  double v4;
  int v5;
  double v6;
  unsigned int v7;
  int v8;
  double v9;
  uint64_t v10;
  NSObject *v11;
  double v12;
  uint64_t v13;
  NSObject *v14;
  double v15;
  int v16;
  uint64_t v17;
  int v18;
  int v19;
  int v20;
  unsigned int v21;
  int v22;
  BOOL v23;
  unsigned int v24;
  int v25;
  int v26;
  uint64_t v27;
  NSObject *v28;
  NSObject *v29;
  uint64_t v30;
  NSObject *v31;
  int v32;
  const void *v33;
  int v34;
  int v35;
  int v36;
  int v37;
  unsigned int v38;
  int v39;
  BOOL v40;
  unsigned int v41;
  int v42;
  int v43;
  double v44;
  uint64_t v45;
  uint64_t v46;
  uint8_t v47[64];
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  uint64_t v56;
  uint8_t buf[80];
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  uint64_t v65;
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  v4 = micro();
  v5 = *(unsigned __int16 *)(a2 + 10);
  v6 = *(double *)a2;
  v7 = (unsigned __int16)(*(_WORD *)(a1 + 72) - v5);
  if (v4 - *(double *)a2 > 10.0 || v7 >= 0x80)
  {
    ++*(_DWORD *)(a1 + 240);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v30 = VRTraceErrorLogLevelToCSTR();
      v31 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v32 = *(_DWORD *)(a1 + 72);
        *(_DWORD *)buf = 136316930;
        *(_QWORD *)&buf[4] = v30;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VCSessionStatsController_IsRemoteSessionStatsTooLate";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 297;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v5;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = v32;
        *(_WORD *)&buf[40] = 1024;
        *(_DWORD *)&buf[42] = v7;
        *(_WORD *)&buf[46] = 2048;
        *(double *)&buf[48] = v4;
        *(_WORD *)&buf[56] = 2048;
        *(double *)&buf[58] = v6;
        _os_log_impl(&dword_1D8A54000, v31, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Dropping late server stats with Id=%u, currentId=%u, diff=%u, now=%f, responseTime=%f", buf, 0x42u);
      }
    }
  }
  else
  {
    v8 = v5 & 0x7F;
    v44 = 0.0;
    v45 = 0;
    v46 = 0;
    objc_msgSend((id)objc_msgSend(*(id *)(a1 + 80), "statsRecorder"), "getLocalStats:localSessionStats:", v5 & 0x7F, &v44);
    v9 = *(double *)a2 - v44;
    if (v9 > 10.0 && (int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v10 = VRTraceErrorLogLevelToCSTR();
      v11 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = v10;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VCSessionStatsController_UpdateRemoteSessionStats";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 216;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = (v9 * 1000.0);
        _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Round trip time is greater than 10 seconds [RTT:%dms]", buf, 0x22u);
      }
    }
    v12 = v4 - *(double *)a2;
    if (v12 > 1.0 && (int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v13 = VRTraceErrorLogLevelToCSTR();
      v14 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = v13;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VCSessionStatsController_UpdateRemoteSessionStats";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 220;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = (v12 * 1000.0);
        _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Local VTP queue time is greater than 1 seconds [qTime:%dms]", buf, 0x22u);
      }
    }
    ++*(_DWORD *)(a1 + 244);
    v15 = *(double *)(a1 + 280);
    if (v15 < v12)
      v15 = v12;
    *(double *)(a1 + 272) = v12 + *(double *)(a1 + 272);
    *(double *)(a1 + 280) = v15;
    v16 = v45;
    v17 = *(unsigned __int8 *)(a2 + 8);
    v18 = objc_msgSend(*(id *)(a1 + 80), "getByteCountWithIndex:isOutgoing:", v45, 1);
    memset(buf, 0, sizeof(buf));
    v65 = 0;
    v63 = 0u;
    v64 = 0u;
    v61 = 0u;
    v62 = 0u;
    v59 = 0u;
    v60 = 0u;
    v58 = 0u;
    *(_DWORD *)buf = 5;
    *(_QWORD *)&buf[8] = *(_QWORD *)a2;
    buf[18] = 1;
    buf[24] = v16;
    v19 = objc_msgSend((id)a1, "translateTimestampFromMicro:", v44);
    v20 = *(unsigned __int16 *)(a2 + 12) - *(unsigned __int16 *)(a2 + 14);
    *(_DWORD *)&buf[28] = v19;
    *(_DWORD *)&buf[32] = v20;
    v21 = *(unsigned __int16 *)(a2 + 20);
    v22 = *(_DWORD *)(a1 + 140);
    v23 = (unsigned __int16)(v21 - v22) >= 0x7FFFu || v21 >= (unsigned __int16)*(_DWORD *)(a1 + 140);
    v24 = v22 & 0xFFFF0000 | v21;
    if (v23)
      v25 = 0;
    else
      v25 = 0x10000;
    v26 = HIDWORD(v46);
    *(_DWORD *)&buf[36] = HIDWORD(v45);
    *(_DWORD *)&buf[40] = v25 + v24;
    *(_DWORD *)(a1 + 140) = v25 + v24;
    *(_DWORD *)&buf[56] = *(unsigned __int16 *)(a2 + 16);
    *(double *)&buf[64] = v9;
    *(_DWORD *)&buf[44] = v18;
    *(_DWORD *)&buf[52] = v26;
    *(_DWORD *)(a1 + 112) = v26;
    *(_DWORD *)(a1 + 144) = v19;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v27 = VRTraceErrorLogLevelToCSTR();
      v28 = *MEMORY[0x1E0CF2758];
      v29 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v47 = 136316930;
          *(_QWORD *)&v47[4] = v27;
          *(_WORD *)&v47[12] = 2080;
          *(_QWORD *)&v47[14] = "_VCSessionStatsController_UpdateRemoteSessionStats";
          *(_WORD *)&v47[22] = 1024;
          *(_DWORD *)&v47[24] = 252;
          *(_WORD *)&v47[28] = 1024;
          *(_DWORD *)&v47[30] = v8;
          *(_WORD *)&v47[34] = 1024;
          *(_DWORD *)&v47[36] = v16;
          *(_WORD *)&v47[40] = 2048;
          *(double *)&v47[42] = v44;
          *(_WORD *)&v47[50] = 1024;
          *(_DWORD *)&v47[52] = HIDWORD(v45);
          *(_WORD *)&v47[56] = 1024;
          *(_DWORD *)&v47[58] = HIDWORD(v46);
          _os_log_impl(&dword_1D8A54000, v28, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d index = %d, sessionStatsLocal: uplinkID = %d, request time = %f, totalLocalMediaPacketSent = %d, totalServerStatsByteUsed = %d", v47, 0x3Eu);
        }
      }
      else if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)v47 = 136316930;
        *(_QWORD *)&v47[4] = v27;
        *(_WORD *)&v47[12] = 2080;
        *(_QWORD *)&v47[14] = "_VCSessionStatsController_UpdateRemoteSessionStats";
        *(_WORD *)&v47[22] = 1024;
        *(_DWORD *)&v47[24] = 252;
        *(_WORD *)&v47[28] = 1024;
        *(_DWORD *)&v47[30] = v8;
        *(_WORD *)&v47[34] = 1024;
        *(_DWORD *)&v47[36] = v16;
        *(_WORD *)&v47[40] = 2048;
        *(double *)&v47[42] = v44;
        *(_WORD *)&v47[50] = 1024;
        *(_DWORD *)&v47[52] = HIDWORD(v45);
        *(_WORD *)&v47[56] = 1024;
        *(_DWORD *)&v47[58] = HIDWORD(v46);
        _os_log_debug_impl(&dword_1D8A54000, v28, OS_LOG_TYPE_DEBUG, " [%s] %s:%d index = %d, sessionStatsLocal: uplinkID = %d, request time = %f, totalLocalMediaPacketSent = %d, totalServerStatsByteUsed = %d", v47, 0x3Eu);
      }
    }
    AVCStatisticsCollector_SetVCStatistics(*(_QWORD *)(a1 + 16), (uint64_t)buf);
    v33 = (const void *)VCConnectionManager_CopyConnectionForQuality(*(_QWORD *)(a1 + 80), 1);
    v34 = objc_msgSend(*(id *)(a1 + 80), "getPacketCountWithIndex:isOutgoing:", v17, 0);
    v35 = objc_msgSend(*(id *)(a1 + 80), "getByteCountWithIndex:isOutgoing:", v17, 0);
    *(_DWORD *)(a1 + 116) += objc_msgSend((id)objc_msgSend(*(id *)(a1 + 80), "statsRecorder"), "serverStatsSizeInByteForUplink:connection:", 0, v33);
    if (v33)
      CFRelease(v33);
    memset(v47, 0, sizeof(v47));
    v56 = 0;
    v54 = 0u;
    v55 = 0u;
    v52 = 0u;
    v53 = 0u;
    v51 = 0u;
    v49 = 0u;
    v50 = 0u;
    v48 = 0u;
    *(_DWORD *)v47 = 5;
    *(_QWORD *)&v47[8] = *(_QWORD *)a2;
    v47[18] = 1;
    v47[24] = v17;
    v36 = *(unsigned __int16 *)(a2 + 12);
    *(_DWORD *)&v47[28] = v36;
    v37 = objc_msgSend((id)a1, "translateTimestampFromMicro:");
    v38 = *(unsigned __int16 *)(a2 + 18);
    v39 = *(_DWORD *)(a1 + 136);
    v40 = (unsigned __int16)(v38 - v39) >= 0x7FFFu || v38 >= (unsigned __int16)*(_DWORD *)(a1 + 136);
    v41 = v39 & 0xFFFF0000 | v38;
    if (v40)
      v42 = 0;
    else
      v42 = 0x10000;
    *(_DWORD *)&v47[32] = v37;
    *(_DWORD *)&v47[36] = v42 + v41;
    *(_DWORD *)(a1 + 136) = v42 + v41;
    *(_DWORD *)&v47[40] = v34;
    *(double *)&v48 = v9;
    v43 = *(_DWORD *)(a1 + 116);
    *(_DWORD *)&v47[48] = v35;
    *(_DWORD *)&v47[52] = v43;
    *(_DWORD *)(a1 + 148) = v36;
    AVCStatisticsCollector_SetVCStatistics(*(_QWORD *)(a1 + 24), (uint64_t)v47);
    *(_QWORD *)(a1 + 96) = *(_QWORD *)a2;
    *(_BYTE *)(a1 + 152) = 1;
  }
}

void _VCSessionStatsController_HandleRemoteSessionStats(uint64_t a1, unsigned __int8 *a2)
{
  double v4;
  const void *v5;
  int v6;
  int v7;
  unsigned __int16 *v8;
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  int v12;
  const char *v13;
  NSObject *v14;
  uint32_t v15;
  double v16;
  uint64_t v17;
  const void *v18;
  void *v19;
  double v20;
  double v21;
  uint64_t v22;
  NSObject *v23;
  NSObject *v24;
  int v25;
  uint64_t v26;
  int v27;
  double v28;
  void *v29;
  int v30;
  __int128 v31;
  uint64_t v32;
  uint8_t buf[24];
  int v34;
  __int16 v35;
  int v36;
  __int16 v37;
  int v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v4 = *((double *)a2 + 1);
    *(double *)(a1 + 256) = (v4 - *(double *)(a1 + 264)) * 0.1 + *(double *)(a1 + 256) * 0.9;
    *(double *)(a1 + 264) = v4;
    if (!a2[1538])
    {
      ++*(_DWORD *)(a1 + 224);
      v16 = *((double *)a2 + 1);
      v17 = VCConnectionManager_CopyPrimaryConnection(*(_QWORD *)(a1 + 80));
      v18 = (const void *)v17;
      if (*(_BYTE *)(a1 + 152) && v17)
      {
        if (v16 - *(double *)(a1 + 96) > 0.455 && *(double *)(a1 + 256) < 0.25)
        {
          *(_QWORD *)&buf[16] = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)buf = xmmword_1D910F800;
          v19 = (void *)objc_msgSend(*(id *)(a1 + 80), "statsRecorder");
          if (v19)
            objc_msgSend(v19, "getMostRecentLocalStats");
          else
            memset(buf, 0, sizeof(buf));
          v31 = *(_OWORD *)buf;
          v32 = *(_QWORD *)&buf[16];
          _VCSessionStatsController_TriggerRateControl(a1, (uint64_t)&v31, 0, 1, v16, v20, v21);
          *(double *)(a1 + 96) = v16;
        }
      }
      else if (!v17)
      {
        return;
      }
      CFRelease(v18);
      return;
    }
    ++*(_DWORD *)(a1 + 228);
    v5 = (const void *)VCConnectionManager_CopyConnectionForQuality(*(_QWORD *)(a1 + 80), 1);
    v6 = VCConnectionIDS_LinkID((uint64_t)v5);
    if (v5)
      CFRelease(v5);
    if (*a2 == v6)
    {
      v7 = *((unsigned __int16 *)a2 + 770);
      if (v7 == *(unsigned __int16 *)(a1 + 130))
      {
        ++*(_DWORD *)(a1 + 232);
        if ((int)VRTraceGetErrorLogLevelForModule() < 8)
          return;
        v8 = (unsigned __int16 *)(a2 + 1540);
        v9 = VRTraceErrorLogLevelToCSTR();
        v10 = *MEMORY[0x1E0CF2758];
        v11 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
            return;
          v12 = *v8;
          *(_DWORD *)buf = 136315906;
          *(_QWORD *)&buf[4] = v9;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VCSessionStatsController_HandleRemoteSessionStats";
          *(_WORD *)&buf[22] = 1024;
          v34 = 418;
          v35 = 1024;
          v36 = v12;
          v13 = " [%s] %s:%d statsID is same as the previous one %u";
          v14 = v10;
          v15 = 34;
LABEL_24:
          _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, v13, buf, v15);
          return;
        }
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
          _VCSessionStatsController_HandleRemoteSessionStats_cold_2(v9, v8, v10);
      }
      else
      {
        v26 = *((_QWORD *)a2 + 1);
        *(_WORD *)(a1 + 130) = v7;
        v27 = *((_DWORD *)a2 + 385);
        *(_QWORD *)buf = v26;
        buf[8] = v6;
        buf[9] = 0;
        *(_DWORD *)&buf[10] = v27;
        *(int16x4_t *)&buf[14] = vtrn1_s16(*(int16x4_t *)(a2 + 1544), (int16x4_t)vext_s8(*(int8x8_t *)(a2 + 1544), *(int8x8_t *)(a2 + 1544), 6uLL));
        *(_WORD *)&buf[22] = 0;
        _VCSessionStatsController_UpdateRemoteSessionStats(a1, (uint64_t)buf);
        if (*(_BYTE *)(a1 + 153))
        {
          v28 = *((double *)a2 + 1);
          if (v28 - *(double *)(a1 + 168) > *(double *)(a1 + 160))
          {
            v29 = (void *)MEMORY[0x1DF086F1C](a1 + 8);
            objc_msgSend(v29, "didReceivedSessionStatsAtTime:", v28);
            if (v29)
              CFRelease(v29);
            *(double *)(a1 + 168) = v28;
          }
        }
      }
    }
    else
    {
      ++*(_DWORD *)(a1 + 236);
      if ((int)VRTraceGetErrorLogLevelForModule() < 8)
        return;
      v22 = VRTraceErrorLogLevelToCSTR();
      v23 = *MEMORY[0x1E0CF2758];
      v24 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
          return;
        v25 = *a2;
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)&buf[4] = v22;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VCSessionStatsController_HandleRemoteSessionStats";
        *(_WORD *)&buf[22] = 1024;
        v34 = 408;
        v35 = 1024;
        v36 = v25;
        v37 = 1024;
        v38 = v6;
        v13 = " [%s] %s:%d Do not update session stats since linkID does not match %d, %d";
        v14 = v23;
        v15 = 40;
        goto LABEL_24;
      }
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
      {
        v30 = *a2;
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)&buf[4] = v22;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VCSessionStatsController_HandleRemoteSessionStats";
        *(_WORD *)&buf[22] = 1024;
        v34 = 408;
        v35 = 1024;
        v36 = v30;
        v37 = 1024;
        v38 = v6;
        _os_log_debug_impl(&dword_1D8A54000, v23, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Do not update session stats since linkID does not match %d, %d", buf, 0x28u);
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCSessionStatsController_HandleRemoteSessionStats_cold_1();
  }
}

double _VCSessionStatsController_HealthPrintForServerStats(uint64_t a1)
{
  double result;
  uint64_t v3;
  NSObject *v4;
  int v5;
  int v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  unsigned int v12;
  int v13;
  int v14;
  double v15;
  double v16;
  int v17;
  uint64_t v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  int v24;
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;
  __int16 v29;
  uint64_t v30;
  __int16 v31;
  unsigned int v32;
  __int16 v33;
  int v34;
  __int16 v35;
  int v36;
  __int16 v37;
  int v38;
  __int16 v39;
  int v40;
  __int16 v41;
  int v42;
  __int16 v43;
  double v44;
  __int16 v45;
  double v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  result = micro();
  if (result - *(double *)(a1 + 288) > 5.0)
  {
    *(double *)(a1 + 288) = result;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      v3 = VRTraceErrorLogLevelToCSTR();
      v4 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v5 = *(_DWORD *)(a1 + 72);
        v6 = *(_DWORD *)(a1 + 228);
        v7 = *(_DWORD *)(a1 + 224) + v6;
        v8 = *(_QWORD *)(a1 + 256);
        v9 = *(_DWORD *)(a1 + 232);
        v10 = *(_DWORD *)(a1 + 236);
        v11 = *(_DWORD *)(a1 + 240);
        v12 = *(_DWORD *)(a1 + 244);
        v14 = *(_DWORD *)(a1 + 248);
        v13 = *(_DWORD *)(a1 + 252);
        if (v12)
          v15 = *(double *)(a1 + 272) * 1000.0 / (double)v12;
        else
          v15 = 0.0;
        v16 = *(double *)(a1 + 280) * 1000.0;
        v17 = 136318722;
        v18 = v3;
        v19 = 2080;
        v20 = "_VCSessionStatsController_HealthPrintForServerStats";
        v21 = 1024;
        v22 = 455;
        v23 = 1024;
        v24 = v5;
        v25 = 1024;
        v26 = v6;
        v27 = 1024;
        v28 = v7;
        v29 = 2048;
        v30 = v8;
        v31 = 1024;
        v32 = v12;
        v33 = 1024;
        v34 = v10;
        v35 = 1024;
        v36 = v9;
        v37 = 1024;
        v38 = v11;
        v39 = 1024;
        v40 = v14;
        v41 = 1024;
        v42 = v13;
        v43 = 2048;
        v44 = v15;
        v45 = 2048;
        v46 = v16;
        _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d @=@ Health: VCSessionStatsController Health Monitor for serverStats: total stats request count:%u, total response count:%u, total callback count:%u, avgInterCallbackDuration:%.3f [this interval processed:%u, dropped:%u,%u,%u, triggered:%u,%u, average queue time:%.2fms, max queue time:%.2fms]", (uint8_t *)&v17, 0x70u);
      }
    }
    result = 0.0;
    *(_QWORD *)(a1 + 244) = 0;
    *(_DWORD *)(a1 + 252) = 0;
    *(_QWORD *)(a1 + 232) = 0;
    *(_QWORD *)(a1 + 272) = 0;
    *(_QWORD *)(a1 + 280) = 0;
  }
  return result;
}

uint64_t readSPSAndGetDecoderParams(unsigned int *BytePtr, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7, _DWORD *a8, _DWORD *a9, _DWORD *a10)
{
  _DWORD *v10;
  _DWORD *v11;
  _DWORD *v12;
  int Length;
  __int128 v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v19;
  uint64_t v20;
  __CFData *Mutable;
  int v22;
  CFIndex v23;
  const UInt8 *v24;
  __CFData *v25;
  CFIndex v26;
  const UInt8 *v27;
  __CFData *v28;
  const __CFData *v29;
  const __CFData *v30;
  uint64_t v31;
  int v32;
  int v33;
  int v34;
  unsigned int v35;
  unint64_t v36;
  uint64_t v37;
  char v38;
  char *v39;
  BOOL *v40;
  unsigned int v41;
  uint64_t v42;
  int v43;
  int v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  _DWORD *v48;
  BOOL v49;
  uint64_t v50;
  _DWORD *v51;
  int v52;
  int v53;
  unsigned __int8 *v54;
  char v61;
  __int128 v62;
  __int128 v63;
  _DWORD __b[487];
  uint64_t v65;

  v10 = a8;
  v11 = a7;
  v12 = a6;
  Length = a2;
  v65 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v15 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v62 = v15;
  v63 = v15;
  v16 = a2;
  v17 = a2 - 3;
  if (a2 == 3)
    goto LABEL_16;
  v19 = 0;
  v20 = 0;
  Mutable = 0;
  v22 = 0;
  while (1)
  {
    if (*((_BYTE *)BytePtr + v20) || *(_WORD *)((char *)BytePtr + v20 + 1) != 768)
      goto LABEL_9;
    if (!v22)
      break;
LABEL_8:
    v23 = v20 + 2 - v19;
    v24 = (const UInt8 *)BytePtr + v19;
    v25 = Mutable;
    CFDataAppendBytes(Mutable, v24, v23);
    Mutable = v25;
    v19 = v20 + 3;
    v20 += 2;
LABEL_9:
    if (++v20 >= v17)
    {
      if (v22)
      {
        v26 = v16 - v19;
        if (v16 != v19)
        {
          v27 = (const UInt8 *)BytePtr + v19;
          v28 = Mutable;
          CFDataAppendBytes(Mutable, v27, v26);
          Mutable = v28;
        }
      }
      v10 = a8;
      v12 = a6;
      v11 = a7;
      if (Mutable)
      {
        v29 = Mutable;
        BytePtr = (unsigned int *)CFDataGetBytePtr(Mutable);
        *(_QWORD *)&v62 = BytePtr;
        v30 = v29;
        v61 = 0;
        Length = CFDataGetLength(v29);
        goto LABEL_17;
      }
      goto LABEL_16;
    }
  }
  Mutable = CFDataCreateMutable(0, v16 - 1);
  if (Mutable)
  {
    v22 = 1;
    goto LABEL_8;
  }
  v31 = FigSignalErrorAt3();
  v10 = a8;
  v12 = a6;
  v11 = a7;
  if ((_DWORD)v31)
    return v31;
LABEL_16:
  v30 = 0;
  *(_QWORD *)&v62 = BytePtr;
  v61 = 1;
LABEL_17:
  DWORD2(v62) = Length;
  memset(__b, 170, sizeof(__b));
  *(_QWORD *)&v63 = BytePtr;
  DWORD2(v63) = bswap32(*BytePtr);
  BYTE12(v63) = 0;
  bzero(__b, 0x79CuLL);
  v32 = h264bridge_u_pull((uint64_t)&v62, 1u);
  v33 = h264bridge_u_pull((uint64_t)&v62, 2u);
  v34 = h264bridge_u_pull((uint64_t)&v62, 5u);
  if (v32 || v33 <= 0 || v34 != 7)
    goto LABEL_106;
  __b[0] = h264bridge_u_pull((uint64_t)&v62, 8u);
  __b[2] = h264bridge_u_pull((uint64_t)&v62, 1u);
  __b[3] = h264bridge_u_pull((uint64_t)&v62, 1u);
  __b[4] = h264bridge_u_pull((uint64_t)&v62, 1u);
  __b[5] = h264bridge_u_pull((uint64_t)&v62, 1u);
  h264bridge_u_pull((uint64_t)&v62, 4u);
  __b[1] = h264bridge_u_pull((uint64_t)&v62, 8u);
  __b[9] = h264bridge_ue_pull((uint64_t)&v62);
  v35 = LOBYTE(__b[0]) - 100;
  if (v35 > 0x2C || ((1 << v35) & 0x100000400401) == 0)
  {
    LOBYTE(__b[10]) = 1;
    goto LABEL_37;
  }
  LOBYTE(__b[10]) = h264bridge_ue_pull((uint64_t)&v62);
  if ((__b[10] & 0xFE) != 0)
    goto LABEL_106;
  BYTE2(__b[10]) = h264bridge_ue_pull((uint64_t)&v62);
  if (BYTE2(__b[10]))
    goto LABEL_106;
  HIBYTE(__b[10]) = h264bridge_ue_pull((uint64_t)&v62);
  if (HIBYTE(__b[10]))
    goto LABEL_106;
  LOBYTE(__b[11]) = h264bridge_u_pull((uint64_t)&v62, 1u);
  if (LOBYTE(__b[11]))
    goto LABEL_106;
  BYTE1(__b[11]) = h264bridge_u_pull((uint64_t)&v62, 1u);
  if (BYTE1(__b[11]))
  {
    v36 = 0;
    v37 = 62;
    do
    {
      v38 = h264bridge_u_pull((uint64_t)&v62, 1u);
      *((_BYTE *)&__b[11] + v36 + 2) = v38;
      if (v38)
      {
        if (v36 > 5)
        {
          v42 = (v36 - 6);
          v39 = (char *)&__b[16 * v42 + 39] + 2;
          v40 = (BOOL *)&__b[15] + v42;
          v41 = 64;
        }
        else
        {
          if (SDWORD2(v62) < (int)v63 - (int)v62)
            goto LABEL_106;
          v39 = (char *)__b + v37;
          v40 = (BOOL *)&__b[13] + v36 + 2;
          v41 = 16;
        }
        scaling_list((uint64_t)&v62, (uint64_t)v39, v41, v40);
      }
      ++v36;
      v37 += 16;
    }
    while (v36 != 8);
  }
LABEL_37:
  if (__b[9] >= 32)
    goto LABEL_106;
  __b[74] = h264bridge_ue_pull((uint64_t)&v62);
  v43 = h264bridge_ue_pull((uint64_t)&v62);
  __b[75] = v43;
  if (v43 != 1)
  {
    if (!v43)
    {
      __b[76] = h264bridge_ue_pull((uint64_t)&v62);
      __b[485] = 1 << (LOBYTE(__b[76]) + 4);
      *(_QWORD *)&__b[79] = 0;
      *(_QWORD *)&__b[77] = 0;
    }
    goto LABEL_45;
  }
  __b[77] = h264bridge_u_pull((uint64_t)&v62, 1u);
  __b[78] = h264bridge_se_pull((uint64_t)&v62);
  __b[79] = h264bridge_se_pull((uint64_t)&v62);
  v44 = h264bridge_ue_pull((uint64_t)&v62);
  __b[80] = v44;
  __b[485] = 0;
  if (v44 > 255)
  {
LABEL_106:
    v31 = 4294954582;
    FigSignalErrorAt3();
    goto LABEL_89;
  }
  if (v44 >= 1)
  {
    v45 = 0;
    do
      __b[v45++ + 81] = h264bridge_se_pull((uint64_t)&v62);
    while (v45 < __b[80]);
  }
LABEL_45:
  __b[336] = h264bridge_ue_pull((uint64_t)&v62);
  __b[337] = h264bridge_u_pull((uint64_t)&v62, 1u);
  __b[338] = h264bridge_ue_pull((uint64_t)&v62);
  __b[339] = h264bridge_ue_pull((uint64_t)&v62);
  __b[340] = h264bridge_u_pull((uint64_t)&v62, 1u);
  if (__b[340])
    v46 = 0;
  else
    v46 = h264bridge_u_pull((uint64_t)&v62, 1u);
  __b[341] = v46;
  __b[342] = h264bridge_u_pull((uint64_t)&v62, 1u);
  __b[343] = h264bridge_u_pull((uint64_t)&v62, 1u);
  if (__b[343])
  {
    __b[344] = h264bridge_ue_pull((uint64_t)&v62);
    __b[345] = h264bridge_ue_pull((uint64_t)&v62);
    __b[346] = h264bridge_ue_pull((uint64_t)&v62);
    __b[347] = h264bridge_ue_pull((uint64_t)&v62);
  }
  __b[348] = h264bridge_u_pull((uint64_t)&v62, 1u);
  if (!__b[348])
  {
LABEL_88:
    v31 = 0;
    goto LABEL_89;
  }
  if (SDWORD2(v62) < (int)v63 - (int)v62)
    goto LABEL_106;
  __b[349] = h264bridge_u_pull((uint64_t)&v62, 1u);
  if (__b[349])
  {
    __b[350] = h264bridge_u_pull((uint64_t)&v62, 8u);
    if (__b[350] == 255)
    {
      __b[351] = h264bridge_u_pull((uint64_t)&v62, 0x10u);
      __b[352] = h264bridge_u_pull((uint64_t)&v62, 0x10u);
    }
  }
  if (SDWORD2(v62) < (int)v63 - (int)v62)
    goto LABEL_106;
  __b[353] = h264bridge_u_pull((uint64_t)&v62, 1u);
  if (__b[353])
    __b[354] = h264bridge_u_pull((uint64_t)&v62, 1u);
  __b[355] = h264bridge_u_pull((uint64_t)&v62, 1u);
  if (__b[355])
  {
    __b[356] = h264bridge_u_pull((uint64_t)&v62, 3u);
    __b[357] = h264bridge_u_pull((uint64_t)&v62, 1u);
    __b[358] = h264bridge_u_pull((uint64_t)&v62, 1u);
    if (__b[358])
    {
      __b[359] = h264bridge_u_pull((uint64_t)&v62, 8u);
      __b[360] = h264bridge_u_pull((uint64_t)&v62, 8u);
      __b[361] = h264bridge_u_pull((uint64_t)&v62, 8u);
    }
  }
  if (SDWORD2(v62) < (int)v63 - (int)v62)
    goto LABEL_106;
  __b[362] = h264bridge_u_pull((uint64_t)&v62, 1u);
  if (__b[362])
  {
    __b[363] = h264bridge_ue_pull((uint64_t)&v62);
    __b[364] = h264bridge_ue_pull((uint64_t)&v62);
  }
  if (SDWORD2(v62) < (int)v63 - (int)v62)
    goto LABEL_106;
  __b[365] = h264bridge_u_pull((uint64_t)&v62, 1u);
  if (__b[365])
  {
    __b[366] = h264bridge_u_pulllong((uint64_t)&v62);
    __b[367] = h264bridge_u_pulllong((uint64_t)&v62);
    __b[368] = h264bridge_u_pull((uint64_t)&v62, 1u);
  }
  if (SDWORD2(v62) < (int)v63 - (int)v62)
    goto LABEL_106;
  __b[369] = h264bridge_u_pull((uint64_t)&v62, 1u);
  if (!__b[369])
    goto LABEL_75;
  __b[381] = h264bridge_ue_pull((uint64_t)&v62);
  if (__b[381] >= 32)
    goto LABEL_122;
  __b[382] = h264bridge_u_pull((uint64_t)&v62, 4u);
  __b[383] = h264bridge_u_pull((uint64_t)&v62, 4u);
  if ((__b[381] & 0x80000000) == 0)
  {
    v47 = 0;
    do
    {
      v48 = &__b[v47];
      v48[384] = h264bridge_ue_pulllong((uint64_t)&v62);
      v48[416] = h264bridge_ue_pulllong((uint64_t)&v62);
      v48[448] = h264bridge_u_pull((uint64_t)&v62, 1u);
      if (SDWORD2(v62) < (int)v63 - (int)v62)
        goto LABEL_106;
      v49 = v47++ < __b[381];
    }
    while (v49);
  }
  __b[480] = h264bridge_u_pull((uint64_t)&v62, 5u);
  __b[481] = h264bridge_u_pull((uint64_t)&v62, 5u);
  __b[482] = h264bridge_u_pull((uint64_t)&v62, 5u);
  __b[483] = h264bridge_u_pull((uint64_t)&v62, 5u);
LABEL_75:
  __b[370] = h264bridge_u_pull((uint64_t)&v62, 1u);
  if (!__b[370])
  {
LABEL_82:
    if (SDWORD2(v62) < (int)v63 - (int)v62)
      goto LABEL_106;
    if (*(_QWORD *)&__b[369])
      __b[371] = h264bridge_u_pull((uint64_t)&v62, 1u);
    __b[372] = h264bridge_u_pull((uint64_t)&v62, 1u);
    __b[373] = h264bridge_u_pull((uint64_t)&v62, 1u);
    if (__b[373])
    {
      __b[374] = h264bridge_u_pull((uint64_t)&v62, 1u);
      __b[375] = h264bridge_ue_pull((uint64_t)&v62);
      __b[376] = h264bridge_ue_pull((uint64_t)&v62);
      __b[377] = h264bridge_ue_pull((uint64_t)&v62);
      __b[378] = h264bridge_ue_pull((uint64_t)&v62);
      __b[379] = h264bridge_ue_pull((uint64_t)&v62);
      h264bridge_ue_pull((uint64_t)&v62);
    }
    if (SDWORD2(v62) < (int)v63 - (int)v62)
      goto LABEL_106;
    goto LABEL_88;
  }
  __b[381] = h264bridge_ue_pull((uint64_t)&v62);
  if (__b[381] < 32)
  {
    __b[382] = h264bridge_u_pull((uint64_t)&v62, 4u);
    __b[383] = h264bridge_u_pull((uint64_t)&v62, 4u);
    if ((__b[381] & 0x80000000) == 0)
    {
      v50 = 0;
      do
      {
        v51 = &__b[v50];
        v51[384] = h264bridge_ue_pulllong((uint64_t)&v62);
        v51[416] = h264bridge_ue_pulllong((uint64_t)&v62);
        v51[448] = h264bridge_u_pull((uint64_t)&v62, 1u);
        if (SDWORD2(v62) < (int)v63 - (int)v62)
          goto LABEL_106;
        v49 = v50++ < __b[381];
      }
      while (v49);
    }
    __b[480] = h264bridge_u_pull((uint64_t)&v62, 5u);
    __b[481] = h264bridge_u_pull((uint64_t)&v62, 5u);
    __b[482] = h264bridge_u_pull((uint64_t)&v62, 5u);
    __b[483] = h264bridge_u_pull((uint64_t)&v62, 5u);
    goto LABEL_82;
  }
LABEL_122:
  v31 = FigSignalErrorAt3();
LABEL_89:
  if ((v61 & 1) == 0)
    CFRelease(v30);
  if (!(_DWORD)v31)
  {
    *a3 = __b[338] + 1;
    *a4 = __b[339] + 1;
    v52 = __b[348];
    if (__b[348] && __b[349])
    {
      if (__b[350] == 255)
      {
        *a5 = __b[351];
        v53 = __b[352];
        goto LABEL_98;
      }
      if ((__b[350] - 1) <= 0xC)
      {
        v54 = (unsigned __int8 *)&kH264SampleAspectRatioIndicators + 2 * __b[350];
        *a5 = *v54;
        v53 = v54[1];
LABEL_98:
        *v12 = v53;
      }
    }
    if (v52 && __b[358])
    {
      *v11 = __b[359];
      *v10 = __b[360];
      *a9 = __b[361];
    }
    v31 = 0;
    if (v52 && __b[355])
    {
      v31 = 0;
      *a10 = __b[356];
    }
  }
  return v31;
}

uint64_t readAVCCAndGetDecoderParams(uint64_t a1, unint64_t a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7, _DWORD *a8, _DWORD *a9, _DWORD *a10)
{
  BOOL v10;
  BOOL v11;
  unsigned int v12;
  unsigned int v13;
  BOOL v14;
  BOOL v15;

  if (a2 < 7)
    return 4294954582;
  if ((*(_BYTE *)(a1 + 5) & 0x1F) != 0)
  {
    v11 = __OFSUB__((_DWORD)a2, 8);
    v10 = (int)a2 - 8 < 0;
  }
  else
  {
    v11 = 0;
    v10 = 1;
  }
  if (v10 != v11)
    return 4294954582;
  v12 = __rev16(*(unsigned __int16 *)(a1 + 6));
  v13 = v12 + 8;
  if (v12 >= 2)
  {
    v14 = v13 >= a2;
    v15 = v13 == (_DWORD)a2;
  }
  else
  {
    v14 = 1;
    v15 = 0;
  }
  if (!v15 && v14)
    return 4294954582;
  else
    return readSPSAndGetDecoderParams((unsigned int *)(a1 + 8), v12, a3, a4, a5, a6, a7, a8, a9, a10);
}

uint64_t h264bridge_u_pull(uint64_t a1, unsigned int a2)
{
  int v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  char v8;
  unint64_t v9;
  char v10;
  BOOL v11;
  uint64_t v12;
  unsigned int v13;

  v2 = *(unsigned __int8 *)(a1 + 28);
  if (32 - v2 < a2)
  {
    FigSignalErrorAt3();
    return 0;
  }
  else
  {
    v3 = *(_QWORD *)(a1 + 16);
    v4 = *(_QWORD *)a1 + *(unsigned int *)(a1 + 8);
    v5 = (*(_DWORD *)(a1 + 24) >> -(char)a2);
    v6 = v2 + a2;
    v7 = v6 >> 3;
    v8 = v6 & 7;
    v9 = v3 + v7 + 4;
    v10 = v8 | (8 * (v7 - (v4 - v3 - 4)));
    v11 = v9 > v4;
    if (v9 > v4)
      v12 = (v4 - v3 - 4);
    else
      v12 = v7;
    if (v11)
      v8 = v10;
    v13 = *(_DWORD *)(v3 + v12);
    *(_QWORD *)(a1 + 16) = v3 + v12;
    *(_DWORD *)(a1 + 24) = bswap32(v13) << v8;
    *(_BYTE *)(a1 + 28) = v8;
  }
  return v5;
}

uint64_t h264bridge_ue_pull(uint64_t a1)
{
  unsigned int v1;
  uint64_t v2;
  unint64_t v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  char v9;
  unint64_t v10;
  char v11;
  BOOL v12;
  uint64_t v13;
  unsigned int v14;

  v1 = *(_DWORD *)(a1 + 24);
  if (v1 < 0x80000)
  {
    FigSignalErrorAt3();
    return 0;
  }
  else
  {
    v2 = *(_QWORD *)(a1 + 16);
    v3 = *(_QWORD *)a1 + *(unsigned int *)(a1 + 8);
    v4 = __clz(v1);
    v5 = v1 << (v4 + 1) >> -(char)v4;
    if (!v4)
      v5 = 0;
    v6 = v5 + ~(-1 << v4);
    v7 = *(unsigned __int8 *)(a1 + 28) + 2 * v4 + 1;
    v8 = v7 >> 3;
    v9 = v7 & 7;
    v10 = v2 + v8 + 4;
    v11 = v9 | (8 * (v8 - (v3 - v2 - 4)));
    v12 = v10 > v3;
    if (v10 > v3)
      v13 = (v3 - v2 - 4);
    else
      v13 = v8;
    if (v12)
      v9 = v11;
    v14 = *(_DWORD *)(v2 + v13);
    *(_QWORD *)(a1 + 16) = v2 + v13;
    *(_DWORD *)(a1 + 24) = bswap32(v14) << v9;
    *(_BYTE *)(a1 + 28) = v9;
  }
  return v6;
}

uint64_t scaling_list(uint64_t result, uint64_t a2, unsigned int a3, BOOL *a4)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;
  unsigned __int8 v11;

  if (a3)
  {
    v6 = result;
    v7 = 0;
    v8 = 8;
    v9 = 8;
    v10 = a3;
    do
    {
      if (!v8
        || ((result = h264bridge_se_pull(v6), (int)result + v9 + 256 <= 0)
          ? (v8 = --(char)(result + v9))
          : (v8 = (result + v9)),
            *a4 = (v8 | v7) == 0,
            v11 = v8,
            !v8))
      {
        v8 = 0;
        v11 = v9;
      }
      *(_BYTE *)(a2 + v7) = v11;
      v9 = v11;
      ++v7;
    }
    while (v10 != v7);
  }
  return result;
}

uint64_t h264bridge_se_pull(uint64_t a1)
{
  unsigned int v1;
  uint64_t v2;
  unint64_t v3;
  unsigned int v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  uint64_t v8;
  char v9;
  unint64_t v10;
  char v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;

  v1 = *(_DWORD *)(a1 + 24);
  if (v1 < 0x80000)
  {
    FigSignalErrorAt3();
    return 0;
  }
  else
  {
    v2 = *(_QWORD *)(a1 + 16);
    v3 = *(_QWORD *)a1 + *(unsigned int *)(a1 + 8);
    v4 = __clz(v1);
    v5 = v1 << (v4 + 1) >> -(char)v4;
    if (!v4)
      v5 = 0;
    v6 = 1 << v4;
    v7 = *(unsigned __int8 *)(a1 + 28) + 2 * v4 + 1;
    v8 = v7 >> 3;
    v9 = v7 & 7;
    v10 = v2 + v8 + 4;
    v11 = v9 | (8 * (v8 - (v3 - v2 - 4)));
    v12 = v10 > v3;
    if (v10 > v3)
      v13 = (v3 - v2 - 4);
    else
      v13 = v8;
    if (v12)
      v9 = v11;
    v14 = v2 + v13;
    v15 = bswap32(*(_DWORD *)(v2 + v13)) << v9;
    *(_QWORD *)(a1 + 16) = v14;
    v16 = ((v5 + v6) >> 1) - ((v5 + v6) >> 1) * 2 * ((v5 + v6) & 1);
    *(_DWORD *)(a1 + 24) = v15;
    *(_BYTE *)(a1 + 28) = v9;
  }
  return v16;
}

uint64_t h264bridge_u_pulllong(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  int v6;
  unint64_t v7;
  BOOL v8;
  unint64_t v9;
  int v10;
  unsigned int *v11;
  unsigned int v12;
  uint64_t v13;
  char v14;
  unint64_t v15;
  char v16;
  BOOL v17;
  uint64_t v18;
  char *v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;

  v1 = *(unsigned __int8 *)(a1 + 28);
  if ((v1 - 33) > 0xFFFFFFEF)
    goto LABEL_17;
  v2 = *(_QWORD *)(a1 + 16);
  v3 = *(_QWORD *)a1 + *(unsigned int *)(a1 + 8);
  v4 = v1 + 16;
  v5 = (unint64_t)(v1 + 16) >> 3;
  v6 = v1 & 7;
  v7 = v2 + (v4 >> 3) + 4;
  v8 = v7 > v3;
  if (v7 > v3)
    v9 = (v3 - v2 - 4);
  else
    v9 = v5;
  if (v8)
    v6 |= 8 * (v5 - (v3 - v2 - 4));
  if ((v6 - 33) >= 0xFFFFFFF0)
  {
LABEL_17:
    FigSignalErrorAt3();
    return 0;
  }
  else
  {
    v10 = *(unsigned __int16 *)(a1 + 26) << 16;
    v11 = (unsigned int *)(v2 + v9);
    v12 = bswap32(*v11) << v6 >> 16;
    v13 = (v6 + 16) >> 3;
    v14 = v6 & 7;
    v15 = (unint64_t)v11 + v13 + 4;
    v16 = v14 | (8 * (v13 - (v3 - (_BYTE)v11 - 4)));
    v17 = v15 > v3;
    if (v15 > v3)
      v18 = (v3 - (_DWORD)v11 - 4);
    else
      v18 = v13;
    if (v17)
      v14 = v16;
    v19 = (char *)v11 + v18;
    v20 = bswap32(*(unsigned int *)((char *)v11 + v18));
    *(_QWORD *)(a1 + 16) = v19;
    v21 = v20 << v14;
    v22 = v12 | v10;
    *(_DWORD *)(a1 + 24) = v21;
    *(_BYTE *)(a1 + 28) = v14;
  }
  return v22;
}

uint64_t h264bridge_ue_pulllong(uint64_t a1)
{
  uint64_t v1;
  unint64_t v2;
  unsigned int v3;
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  char v10;
  char v11;
  char v12;
  unsigned int *v13;
  unsigned int v14;
  int v15;
  unint64_t v16;
  unint64_t v17;
  int v18;
  BOOL v19;
  int v20;
  unsigned int *v21;
  unsigned int v22;
  unsigned int v23;
  char v24;
  uint64_t v25;
  int v26;
  unint64_t v27;
  BOOL v28;
  uint64_t v29;
  unsigned int v30;
  int v31;
  unsigned int v32;
  uint64_t v33;
  char v34;
  char v35;
  unsigned int v36;
  uint64_t v37;
  int v38;
  int v39;
  unsigned int v40;
  unsigned int *v41;
  unsigned int v42;
  uint64_t v43;
  char v44;
  char v45;

  v1 = *(_QWORD *)(a1 + 16);
  v2 = *(_QWORD *)a1 + *(unsigned int *)(a1 + 8);
  v3 = *(_DWORD *)(a1 + 24);
  v4 = *(unsigned __int8 *)(a1 + 28);
  if (v3 < 0x80000)
  {
    if ((_DWORD)v4 != 32)
    {
      v15 = 0;
      v16 = v4 + 1;
      v17 = (unint64_t)(v4 + 1) >> 3;
      v18 = v16 & 7;
      v19 = v1 + (v16 >> 3) + 4 > v2;
      v20 = v18 | (8 * (v17 - (v2 - v1 - 4)));
      if (v19)
        v17 = (v2 - v1 - 4);
      if (v19)
        v18 = v20;
      v21 = (unsigned int *)(v1 + v17);
      v22 = bswap32(*(_DWORD *)(v1 + v17)) << v18;
      do
      {
        if (v18 == 32)
          goto LABEL_42;
        v23 = v22;
        v24 = v18 + 1;
        v25 = (v18 + 1) >> 3;
        v26 = v24 & 7;
        v27 = (unint64_t)v21 + v25 + 4;
        v28 = v27 > v2;
        if (v27 > v2)
          v29 = (v2 - (_DWORD)v21 - 4);
        else
          v29 = v25;
        if (v28)
          v18 = v26 | (8 * (v25 - (v2 - (_DWORD)v21 - 4)));
        else
          v18 = v26;
        v21 = (unsigned int *)((char *)v21 + v29);
        v22 = bswap32(*v21) << v18;
        --v15;
      }
      while ((v23 & 0x80000000) == 0);
      v30 = -v15;
      if (-v15 >= 0x20)
        goto LABEL_42;
      if (v30 <= 0x18)
      {
        if (v30 > 32 - v18)
          goto LABEL_42;
        v31 = v22 >> v15;
        v32 = v18 - v15;
        v33 = v32 >> 3;
        v34 = v32 & 7;
        v35 = v34 | (8 * (v33 - (v2 - (_BYTE)v21 - 4)));
        if ((unint64_t)v21 + v33 + 4 <= v2)
        {
          v12 = v34;
        }
        else
        {
          v33 = (v2 - (_DWORD)v21 - 4);
          v12 = v35;
        }
        v13 = (unsigned int *)((char *)v21 + v33);
        v14 = bswap32(*(unsigned int *)((char *)v21 + v33)) << v12;
        goto LABEL_39;
      }
      if (-16 - v15 <= (32 - v18))
      {
        v36 = v18 - v15 - 16;
        v37 = v36 >> 3;
        v38 = v36 & 7;
        v39 = v38 | (8 * (v37 - (v2 - (_DWORD)v21 - 4)));
        if ((unint64_t)v21 + v37 + 4 > v2)
        {
          v37 = (v2 - (_DWORD)v21 - 4);
          v38 = v39;
        }
        if ((v38 - 33) < 0xFFFFFFF0)
        {
          v40 = v22 >> (v15 + 48);
          v41 = (unsigned int *)((char *)v21 + v37);
          v42 = bswap32(*v41) << v38;
          v43 = (v38 + 16) >> 3;
          v44 = v38 & 7;
          v45 = v44 | (8 * (v43 - (v2 - (_BYTE)v41 - 4)));
          if ((unint64_t)v41 + v43 + 4 <= v2)
          {
            v12 = v44;
          }
          else
          {
            v43 = (v2 - (_DWORD)v41 - 4);
            v12 = v45;
          }
          v13 = (unsigned int *)((char *)v41 + v43);
          v14 = bswap32(*v13) << v12;
          v31 = __PAIR64__(v40, v42) >> 16;
LABEL_39:
          v7 = (v31 + ~(-1 << v30));
          goto LABEL_40;
        }
      }
    }
LABEL_42:
    FigSignalErrorAt3();
    return 0;
  }
  v5 = __clz(v3);
  v6 = v3 << (v5 + 1) >> -(char)v5;
  if (!v5)
    v6 = 0;
  v7 = v6 + ~(-1 << v5);
  v8 = v4 + 2 * v5 + 1;
  v9 = v8 >> 3;
  v10 = v8 & 7;
  v11 = v10 | (8 * (v9 - (v2 - v1 - 4)));
  if (v1 + v9 + 4 <= v2)
  {
    v12 = v10;
  }
  else
  {
    v9 = (v2 - v1 - 4);
    v12 = v11;
  }
  v13 = (unsigned int *)(v1 + v9);
  v14 = bswap32(*(_DWORD *)(v1 + v9)) << v12;
LABEL_40:
  *(_QWORD *)(a1 + 16) = v13;
  *(_DWORD *)(a1 + 24) = v14;
  *(_BYTE *)(a1 + 28) = v12;
  return v7;
}

uint64_t _VCCannedAudioInjector_AudioConverterInput(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  CFTypeRef v8;
  CFTypeRef v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;

  if (a2)
  {
    *a2 = 0;
    if (a1)
    {
      if (a3)
      {
        if (a5)
        {
          v8 = *(CFTypeRef *)a5;
          if (*(_QWORD *)a5)
          {
            v9 = *(CFTypeRef *)(a5 + 32);
            if (v9 != v8)
            {
              *(_QWORD *)(a5 + 32) = v8;
              CFRetain(v8);
              if (v9)
                CFRelease(v9);
            }
            if (*(_QWORD *)a5)
            {
              CFRelease(*(CFTypeRef *)a5);
              *(_QWORD *)a5 = 0;
            }
            v10 = 0;
            v11 = *(_DWORD *)(a5 + 56);
            *(_QWORD *)(a3 + 16) = *(_QWORD *)(a5 + 24);
            v12 = *(_DWORD *)(a5 + 20);
            *(_DWORD *)(a3 + 8) = *(_DWORD *)(a5 + 16);
            *(_DWORD *)(a3 + 12) = v12;
            *a2 = v12 / v11;
          }
          else
          {
            return 0;
          }
        }
        else
        {
          v10 = 2003329396;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              _VCCannedAudioInjector_AudioConverterInput_cold_4();
          }
        }
      }
      else
      {
        v10 = 2003329396;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VCCannedAudioInjector_AudioConverterInput_cold_3();
        }
      }
    }
    else
    {
      v10 = 2003329396;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCCannedAudioInjector_AudioConverterInput_cold_2();
      }
    }
  }
  else
  {
    v10 = 2003329396;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCCannedAudioInjector_AudioConverterInput_cold_1();
    }
  }
  return v10;
}

void VCCannedAudioInjector_InjectSamples(uint64_t a1, uint64_t a2, int a3, BOOL *a4)
{
  signed int SampleCount;
  int Timestamp;
  double HostTime;
  char Priority;
  int *v12;
  uint64_t v13;
  NSObject *v14;
  int v15;
  double v16;
  int v17;
  int v18;
  int v19;
  double v20;
  signed int v21;
  uint64_t v22;
  NSObject *v23;
  int v24;
  unsigned int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int appended;
  int v31;
  unsigned int v32;
  unsigned int v33;
  BOOL v34;
  uint64_t v35;
  NSObject *v36;
  BOOL *v37;
  unsigned int VoiceProbability;
  int VoiceActivity;
  int v40;
  uint8_t buf[4];
  uint64_t v42;
  __int16 v43;
  const char *v44;
  __int16 v45;
  int v46;
  __int16 v47;
  _WORD v48[9];

  *(_QWORD *)&v48[5] = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    SampleCount = VCAudioBufferList_GetSampleCount(a2);
    Timestamp = VCAudioBufferList_GetTimestamp(a2);
    HostTime = VCAudioBufferList_GetHostTime(a2);
    if (a3)
      Priority = 1;
    else
      Priority = -1;
    if (*(_BYTE *)(a1 + 416))
    {
      VoiceProbability = a3 ^ 1;
      VoiceActivity = a3 ^ 1;
    }
    else
    {
      VoiceActivity = VCAudioBufferList_GetVoiceActivity(a2);
      Priority = VCAudioBufferList_GetPriority(a2);
      VoiceProbability = VCAudioBufferList_GetVoiceProbability(a2);
    }
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 192));
    if (a2 && SampleCount && HostTime >= 0.0 && *(_DWORD *)(a1 + 168))
    {
      v37 = a4;
      VCAudioBufferList_SetSampleCount(a2, 0);
      v12 = &OBJC_IVAR___AVCPreviewCALayerHost__preview;
      if (*(_BYTE *)(a1 + 188))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v13 = VRTraceErrorLogLevelToCSTR();
          v14 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315906;
            v42 = v13;
            v43 = 2080;
            v44 = "VCCannedAudioInjector_InjectSamples";
            v45 = 1024;
            v46 = 667;
            v47 = 2048;
            *(_QWORD *)v48 = a1;
            _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d instance=%p playback starting, resetting base now!", buf, 0x26u);
          }
        }
        v12 = &OBJC_IVAR___AVCPreviewCALayerHost__preview;
        VCCannedAVSync_SetBase(*(_QWORD *)(a1 + 288), HostTime);
        *(_BYTE *)(a1 + 188) = 0;
      }
      v15 = *(_DWORD *)(a1 + 400);
      v16 = *(double *)(a1 + 248);
      v17 = vcvtmd_s64_f64(v16 * VCCannedAVSync_ClampForTime(*(_QWORD *)(a1 + v12[174]), HostTime));
      v18 = *(_DWORD *)(a1 + 184);
      v19 = v17 - v18;
      if (v17 - v18 < 0)
        v19 = v18 - v17;
      if (v19 <= (int)v16 / 10)
      {
        if (*(_BYTE *)(a1 + 296))
          VCCannedAVSync_AddDrift(*(_QWORD *)(a1 + v12[174]), ((double)v17 - (double)v18) / *(double *)(a1 + 248));
      }
      else
      {
        *(_DWORD *)(a1 + 184) = v17 % v15;
      }
      v20 = *(double *)(a1 + 248);
      v40 = *(_DWORD *)(a1 + 168);
      while (*(_DWORD *)(a1 + 396) < *(_DWORD *)(a1 + 392))
      {
        if (v15 - *(_DWORD *)(a1 + 184) >= SampleCount)
          v21 = SampleCount;
        else
          v21 = v15 - *(_DWORD *)(a1 + 184);
        if (v21 < 0 && (int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          v22 = VRTraceErrorLogLevelToCSTR();
          v23 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v24 = *(_DWORD *)(a1 + 184);
            *(_DWORD *)buf = 136316162;
            v42 = v22;
            v43 = 2080;
            v44 = "VCCannedAudioInjector_InjectSamples";
            v45 = 1024;
            v46 = 689;
            v47 = 1024;
            *(_DWORD *)v48 = v15;
            v48[2] = 1024;
            *(_DWORD *)&v48[3] = v24;
            _os_log_impl(&dword_1D8A54000, v23, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d samplesInLoop=%d, injector->_position=%d", buf, 0x28u);
          }
        }
        v25 = *(_DWORD *)(a1 + 184);
        v26 = v40 - v25;
        if ((int)(v40 - v25) >= v21)
          v26 = v21;
        v27 = v26 & ~(v26 >> 31);
        if (v21 <= v27)
          v28 = 0;
        else
          v28 = v21 - v27;
        if (a3)
          v29 = v26 & ~(v26 >> 31);
        else
          v29 = 0;
        if ((a3 & 1) == 0 && v26 >= 1)
        {
          appended = VCAudioBufferList_AppendSamples(a2, *(_QWORD *)(a1 + 384), v25, v27);
          Timestamp += appended;
          HostTime = HostTime + (double)appended / v20;
        }
        if (v28 + v29)
        {
          v31 = VCAudioBufferList_AppendSilence(a2, Timestamp, v28 + v29, HostTime);
          Timestamp += v31;
          HostTime = HostTime + (double)v31 / v20;
        }
        *(_DWORD *)(a1 + 184) = (*(_DWORD *)(a1 + 184) + v21) % v15;
        if (!*(_DWORD *)(a1 + 184))
          ++*(_DWORD *)(a1 + 396);
        SampleCount -= v21;
        if (!SampleCount)
          goto LABEL_51;
      }
      VCAudioBufferList_AppendSilence(a2, Timestamp, SampleCount, HostTime);
LABEL_51:
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 192));
      VCAudioBufferList_SetTime(a2, Timestamp, HostTime);
      VCAudioBufferList_SetVoiceActivity(a2, VoiceActivity);
      VCAudioBufferList_SetVoiceProbability(a2, (double)VoiceProbability);
      VCAudioBufferList_SetPriority(a2, Priority);
      v32 = *(_DWORD *)(a1 + 396);
      v33 = *(_DWORD *)(a1 + 392);
      if (v37)
        *v37 = v32 >= v33;
      if (*(_BYTE *)(a1 + 189))
        v34 = 0;
      else
        v34 = v32 >= v33;
      if (v34)
      {
        *(_BYTE *)(a1 + 189) = 1;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v35 = VRTraceErrorLogLevelToCSTR();
          v36 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315906;
            v42 = v35;
            v43 = 2080;
            v44 = "VCCannedAudioInjector_InjectSamples";
            v45 = 1024;
            v46 = 731;
            v47 = 2048;
            *(_QWORD *)v48 = a1;
            _os_log_impl(&dword_1D8A54000, v36, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d instance=%p playback complete", buf, 0x26u);
          }
        }
      }
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 192));
    }
  }
}

BOOL VCAudioUnit_NewInstance(AudioComponentInstance *a1, OSType a2)
{
  OpaqueAudioComponent *Next;
  OSStatus v4;
  int v5;
  uint64_t v6;
  NSObject *v7;
  _BOOL8 result;
  uint64_t v9;
  NSObject *v10;
  AudioComponentDescription inDesc;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  inDesc.componentType = 1635083896;
  inDesc.componentSubType = a2;
  inDesc.componentFlagsMask = 0;
  *(_QWORD *)&inDesc.componentManufacturer = 1634758764;
  Next = AudioComponentFindNext(0, &inDesc);
  if (!Next)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v9 = VRTraceErrorLogLevelToCSTR();
      v10 = *MEMORY[0x1E0CF2758];
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      VCAudioUnit_NewInstance_cold_1(v9, v10);
    }
    return 0;
  }
  v4 = AudioComponentInstanceNew(Next, a1);
  if (v4)
  {
    v5 = v4;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v6 = VRTraceErrorLogLevelToCSTR();
      v7 = *MEMORY[0x1E0CF2758];
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      VCAudioUnit_NewInstance_cold_2(v6, v5, v7);
    }
    return 0;
  }
  return 1;
}

int *OUTLINED_FUNCTION_22_1()
{
  return __error();
}

double VCCannedAVSync_SetBase(uint64_t a1, double a2)
{
  double result;

  result = a2 - *(double *)(a1 + 16) * floor(*(double *)(a1 + 8) / *(double *)(a1 + 16));
  *(double *)(a1 + 8) = result;
  return result;
}

double VCCannedAVSync_AddDrift(uint64_t a1, double a2)
{
  double result;

  result = *(double *)(a1 + 8) + a2 - *(double *)(a1 + 16) * floor((*(double *)(a1 + 8) + a2) / *(double *)(a1 + 16));
  *(double *)(a1 + 8) = result;
  return result;
}

double VCCannedAVSync_ClampForTime(uint64_t a1, double a2)
{
  return a2 - *(double *)(a1 + 8) - *(double *)(a1 + 16) * floor((a2 - *(double *)(a1 + 8)) / *(double *)(a1 + 16));
}

void VCSignalHandler_Initialize()
{
  const dispatch_source_type_s *v0;

  if (InitializeSignalHandlerBlockRegistry_sInitSignalHandlerBlockRegistryOnce != -1)
    dispatch_once(&InitializeSignalHandlerBlockRegistry_sInitSignalHandlerBlockRegistryOnce, &__block_literal_global_84);
  if (AVConferenceServer_ProcessIsAvconferenced())
  {
    signal(30, (void (__cdecl *)(int))1);
    v0 = (const dispatch_source_type_s *)MEMORY[0x1E0C80DC0];
    gSignalHandlerBlockRegistry1_1 = (uint64_t)dispatch_source_create(MEMORY[0x1E0C80DC0], 0x1EuLL, 0, (dispatch_queue_t)gSignalHandlerBlockRegistry1_0);
    dispatch_source_set_event_handler_f((dispatch_source_t)gSignalHandlerBlockRegistry1_1, (dispatch_function_t)VCExecuteSignalHandlerBlocks1);
    dispatch_resume((dispatch_object_t)gSignalHandlerBlockRegistry1_1);
    signal(31, (void (__cdecl *)(int))1);
    gSignalHandlerBlockRegistry2_1 = (uint64_t)dispatch_source_create(v0, 0x1FuLL, 0, (dispatch_queue_t)gSignalHandlerBlockRegistry2_0);
    dispatch_source_set_event_handler_f((dispatch_source_t)gSignalHandlerBlockRegistry2_1, (dispatch_function_t)VCExecuteSignalHandlerBlocks2);
    dispatch_resume((dispatch_object_t)gSignalHandlerBlockRegistry2_1);
    signal(15, (void (__cdecl *)(int))1);
    gSignalHandlerBlockRegistry3_1 = (uint64_t)dispatch_source_create(v0, 0xFuLL, 0, (dispatch_queue_t)gSignalHandlerBlockRegistry3_0);
    dispatch_source_set_event_handler_f((dispatch_source_t)gSignalHandlerBlockRegistry3_1, (dispatch_function_t)VCExecuteSignalHandlerBlocks3);
    dispatch_resume((dispatch_object_t)gSignalHandlerBlockRegistry3_1);
  }
}

uint64_t VCExecuteSignalHandlerBlocks1()
{
  uint64_t v0;
  NSObject *v1;
  int v3;
  uint64_t v4;
  __int16 v5;
  const char *v6;
  __int16 v7;
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v0 = VRTraceErrorLogLevelToCSTR();
    v1 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v3 = 136315650;
      v4 = v0;
      v5 = 2080;
      v6 = "VCExecuteSignalHandlerBlocks1";
      v7 = 1024;
      v8 = 31;
      _os_log_impl(&dword_1D8A54000, v1, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCExecuteSignalHandlerBlocks1 USR1", (uint8_t *)&v3, 0x1Cu);
    }
  }
  return VRTraceReset();
}

void VCExecuteSignalHandlerBlocks2()
{
  uint64_t v0;
  NSObject *v1;
  void *v2;
  uint64_t v3;
  NSObject *v4;
  void *v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t i;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  void *v15;
  uint8_t buf[4];
  uint64_t v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  _BYTE v28[128];
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v0 = VRTraceErrorLogLevelToCSTR();
    v1 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      v17 = v0;
      v18 = 2080;
      v19 = "VCExecuteSignalHandlerBlocks2";
      v20 = 1024;
      v21 = 36;
      _os_log_impl(&dword_1D8A54000, v1, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCExecuteSignalHandlerBlocks2 USR2", buf, 0x1Cu);
    }
  }
  v2 = (void *)CFPreferencesCopyAppValue(CFSTR("SignalHandlerCodes"), CFSTR("com.apple.VideoConference"));
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v3 = VRTraceErrorLogLevelToCSTR();
    v4 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      v17 = v3;
      v18 = 2080;
      v19 = "VCExecuteSignalHandlerBlocks2";
      v20 = 1024;
      v21 = 39;
      v22 = 2112;
      v23 = (uint64_t)v2;
      _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d signalHandlerCodes=%@", buf, 0x26u);
    }
  }
  v15 = v2;
  if (v2)
    v5 = (void *)objc_msgSend(v2, "componentsSeparatedByString:", CFSTR(";"));
  else
    v5 = (void *)objc_msgSend((id)gSignalHandlerBocks, "allKeys");
  v6 = v5;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v7 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v29, v28, 16);
  if (v7)
  {
    v8 = v7;
    v9 = *(_QWORD *)v30;
    do
    {
      for (i = 0; i != v8; ++i)
      {
        if (*(_QWORD *)v30 != v9)
          objc_enumerationMutation(v6);
        v11 = *(_QWORD *)(*((_QWORD *)&v29 + 1) + 8 * i);
        v12 = objc_msgSend((id)gSignalHandlerBocks, "objectForKeyedSubscript:", v11);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v13 = VRTraceErrorLogLevelToCSTR();
          v14 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136316418;
            v17 = v13;
            v18 = 2080;
            v19 = "VCExecuteSignalHandlerBlocks2";
            v20 = 1024;
            v21 = 43;
            v22 = 2048;
            v23 = gSignalHandlerBocks;
            v24 = 2112;
            v25 = v11;
            v26 = 2048;
            v27 = v12;
            _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d gSignalHandlerBocks=%p, code=%@, block=%p", buf, 0x3Au);
          }
        }
        if (v12)
          (*(void (**)(uint64_t))(v12 + 16))(v12);
      }
      v8 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v29, v28, 16);
    }
    while (v8);
  }

}

uint64_t VCExecuteSignalHandlerBlocks3()
{
  uint64_t v0;
  NSObject *v1;
  pid_t v2;
  int v4;
  uint64_t v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v0 = VRTraceErrorLogLevelToCSTR();
    v1 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136315650;
      v5 = v0;
      v6 = 2080;
      v7 = "VCExecuteSignalHandlerBlocks3";
      v8 = 1024;
      v9 = 52;
      _os_log_impl(&dword_1D8A54000, v1, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d avconferenced received SIGTERM, exiting", (uint8_t *)&v4, 0x1Cu);
    }
  }
  v2 = getpid();
  return kill(v2, 9);
}

uint64_t VCRegisterSignalHandler(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  int v7;
  uint64_t v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  uint64_t v16;
  __int16 v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v7 = 136316418;
      v8 = v4;
      v9 = 2080;
      v10 = "VCRegisterSignalHandler";
      v11 = 1024;
      v12 = 88;
      v13 = 2080;
      v14 = "VCRegisterSignalHandler";
      v15 = 2112;
      v16 = objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a1);
      v17 = 2048;
      v18 = a2;
      _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d %s: code=%@, block=%p", (uint8_t *)&v7, 0x3Au);
    }
  }
  return objc_msgSend((id)gSignalHandlerBocks, "setObject:forKeyedSubscript:", a2, objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a1));
}

void sub_1D8EBF5D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
  _Unwind_Resume(exception_object);
}

uint64_t OUTLINED_FUNCTION_5_13@<X0>(id *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  *(_QWORD *)(v2 - 24) = a2;
  return objc_msgSend(*a1, "UTF8String");
}

BOOL VCMathUtils_DoubleEqualWithAccuracy(double a1, double a2, double a3)
{
  return vabdd_f64(a1, a2) < a3;
}

uint64_t _VCRateControlSmartBrake_BindEspressoBuffer(void *a1, uint64_t a2, const __CFString *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10;
  uint64_t v11;
  const __CFString *v13;
  const __CFString *v14;
  uint64_t v15;
  NSObject *v16;
  const char *v17;
  uint64_t v18;
  NSObject *v19;
  uint32_t v20;
  uint64_t v21;
  NSObject *v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  const __CFString *v31;
  __int16 v32;
  void *v33;
  __int16 v34;
  const __CFString *v35;
  __int16 v36;
  int v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)(a2 + 160) = 0;
  *(_OWORD *)(a2 + 128) = 0u;
  *(_OWORD *)(a2 + 144) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  v10 = espresso_buffer_pack_tensor_shape();
  if (!(_DWORD)v10)
  {
    *(_QWORD *)a2 = a6;
    *(_DWORD *)(a2 + 160) = 65568;
    v11 = espresso_network_bind_buffer();
    if (!(_DWORD)v11)
      return v11;
    if ((void *)objc_opt_class() != a1)
    {
      if ((objc_opt_respondsToSelector() & 1) != 0)
        v14 = (const __CFString *)objc_msgSend(a1, "performSelector:", sel_logPrefix);
      else
        v14 = &stru_1E9E58EE0;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v23 = VRTraceErrorLogLevelToCSTR();
        v22 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v24 = 136316674;
          v25 = v23;
          v26 = 2080;
          v27 = "_VCRateControlSmartBrake_BindEspressoBuffer";
          v28 = 1024;
          v29 = 390;
          v30 = 2112;
          v31 = v14;
          v32 = 2048;
          v33 = a1;
          v34 = 2080;
          v35 = a3;
          v36 = 1024;
          v37 = v11;
          v17 = " [%s] %s:%d %@(%p) Unable to bind %s espresso buffer returnStatus=%d";
          goto LABEL_25;
        }
      }
      return v11;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      return v11;
    v18 = VRTraceErrorLogLevelToCSTR();
    v16 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      return v11;
    v24 = 136316162;
    v25 = v18;
    v26 = 2080;
    v27 = "_VCRateControlSmartBrake_BindEspressoBuffer";
    v28 = 1024;
    v29 = 390;
    v30 = 2080;
    v31 = a3;
    v32 = 1024;
    LODWORD(v33) = v11;
    v17 = " [%s] %s:%d Unable to bind %s espresso buffer returnStatus=%d";
LABEL_16:
    v19 = v16;
    v20 = 44;
LABEL_26:
    _os_log_error_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_ERROR, v17, (uint8_t *)&v24, v20);
    return v11;
  }
  v11 = v10;
  if ((void *)objc_opt_class() == a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      return v11;
    v15 = VRTraceErrorLogLevelToCSTR();
    v16 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      return v11;
    v24 = 136316162;
    v25 = v15;
    v26 = 2080;
    v27 = "_VCRateControlSmartBrake_BindEspressoBuffer";
    v28 = 1024;
    v29 = 384;
    v30 = 2080;
    v31 = a3;
    v32 = 1024;
    LODWORD(v33) = v11;
    v17 = " [%s] %s:%d Unable to pack espresso tensor shape for %s espresso buffer returnStatus=%d";
    goto LABEL_16;
  }
  if ((objc_opt_respondsToSelector() & 1) != 0)
    v13 = (const __CFString *)objc_msgSend(a1, "performSelector:", sel_logPrefix);
  else
    v13 = &stru_1E9E58EE0;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v21 = VRTraceErrorLogLevelToCSTR();
    v22 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      v24 = 136316674;
      v25 = v21;
      v26 = 2080;
      v27 = "_VCRateControlSmartBrake_BindEspressoBuffer";
      v28 = 1024;
      v29 = 384;
      v30 = 2112;
      v31 = v13;
      v32 = 2048;
      v33 = a1;
      v34 = 2080;
      v35 = a3;
      v36 = 1024;
      v37 = v11;
      v17 = " [%s] %s:%d %@(%p) Unable to pack espresso tensor shape for %s espresso buffer returnStatus=%d";
LABEL_25:
      v19 = v22;
      v20 = 64;
      goto LABEL_26;
    }
  }
  return v11;
}

void VCRateControlSmartBrake_Query(uint64_t a1, uint64_t a2, uint64_t a3)
{
  float v6;
  uint64_t error_info;
  uint64_t v8;
  uint64_t v9;
  const __CFString *v10;
  uint64_t v11;
  NSObject *v12;
  const char *v13;
  NSObject *v14;
  uint32_t v15;
  uint64_t v16;
  NSObject *v17;
  int v18;
  uint64_t v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  _BYTE v25[10];
  _BYTE v26[10];
  int v27;
  __int16 v28;
  int v29;
  __int16 v30;
  uint64_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  kdebug_trace();
  *(_DWORD *)(a3 + 8) = 0;
  *(_QWORD *)a3 = 0;
  if (!a1 || *(_DWORD *)(a1 + 2112) != 1)
    return;
  v6 = *(float *)a2;
  if (*(float *)(a1 + 172) == 0.0)
  {
    *(float *)(a1 + 168) = v6;
    *(_DWORD *)(a1 + 172) = 1065353216;
    return;
  }
  *(float *)(a1 + 176) = v6 - *(float *)(a1 + 168);
  *(float *)(a1 + 168) = v6;
  *(_DWORD *)(a1 + 180) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a1 + 188) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a1 + 184) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 192) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 196) = *(_DWORD *)(a2 + 20);
  if (!espresso_plan_execute_sync())
  {
    *(_DWORD *)a3 = *(_DWORD *)(a1 + 200);
    *(uint32x2_t *)(a3 + 4) = vcvt_u32_f32(*(float32x2_t *)(a1 + 204));
    kdebug_trace();
    return;
  }
  error_info = espresso_plan_get_error_info();
  v9 = v8;
  if (objc_opt_class() == a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      return;
    v11 = VRTraceErrorLogLevelToCSTR();
    v12 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      return;
    v18 = 136316418;
    v19 = v11;
    v20 = 2080;
    v21 = "VCRateControlSmartBrake_Query";
    v22 = 1024;
    v23 = 426;
    v24 = 1024;
    *(_DWORD *)v25 = error_info;
    *(_WORD *)&v25[4] = 1024;
    *(_DWORD *)&v25[6] = HIDWORD(error_info);
    *(_WORD *)v26 = 2080;
    *(_QWORD *)&v26[2] = v9;
    v13 = " [%s] %s:%d Error while executing neural network planStatus=%d, returnStatus=%d, description=%s";
    v14 = v12;
    v15 = 50;
LABEL_18:
    _os_log_error_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_ERROR, v13, (uint8_t *)&v18, v15);
    return;
  }
  if ((objc_opt_respondsToSelector() & 1) != 0)
    v10 = (const __CFString *)objc_msgSend((id)a1, "performSelector:", sel_logPrefix);
  else
    v10 = &stru_1E9E58EE0;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v16 = VRTraceErrorLogLevelToCSTR();
    v17 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      v18 = 136316930;
      v19 = v16;
      v20 = 2080;
      v21 = "VCRateControlSmartBrake_Query";
      v22 = 1024;
      v23 = 426;
      v24 = 2112;
      *(_QWORD *)v25 = v10;
      *(_WORD *)&v25[8] = 2048;
      *(_QWORD *)v26 = a1;
      *(_WORD *)&v26[8] = 1024;
      v27 = error_info;
      v28 = 1024;
      v29 = HIDWORD(error_info);
      v30 = 2080;
      v31 = v9;
      v13 = " [%s] %s:%d %@(%p) Error while executing neural network planStatus=%d, returnStatus=%d, description=%s";
      v14 = v17;
      v15 = 70;
      goto LABEL_18;
    }
  }
}

BOOL VCRateControlSmartBrake_IsOutputEmpty(uint64_t a1, unsigned int a2)
{
  return (a1 & 0xFFFFFFFF7FFFFFFFLL | a2) == 0;
}

void VCRateControlSmartBrake_ResetState(uint64_t a1)
{
  unint64_t v1;

  if (a1)
  {
    if (*(_QWORD *)(a1 + 1736))
    {
      v1 = 0;
      do
        *(_DWORD *)(*(_QWORD *)(a1 + 1728) + 4 * v1++) = 0;
      while (v1 < *(_QWORD *)(a1 + 1736));
    }
    *(_DWORD *)(a1 + 172) = 0;
  }
  else if (objc_opt_class())
  {
    if ((objc_opt_respondsToSelector() & 1) != 0)
      objc_msgSend(0, "performSelector:", sel_logPrefix);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCRateControlSmartBrake_ResetState_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlSmartBrake_ResetState_cold_1();
  }
}

int64_t _VCMediaStreamSynchronizer_differenceBetweenRtpTimestamp(int a1, unsigned int a2)
{
  uint64_t v2;
  int64_t v3;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  int v10;
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  uint64_t v19;
  __int16 v20;
  int64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v2 = a1;
  v3 = a1 - (unint64_t)a2;
  if (v3 <= (uint64_t)0xFFFFFFFF80000000)
  {
    v3 += 0x100000000;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v5 = a2;
      v6 = VRTraceErrorLogLevelToCSTR();
      v7 = *MEMORY[0x1E0CF2758];
      v8 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          v10 = 136316418;
          v11 = v6;
          v12 = 2080;
          v13 = "_VCMediaStreamSynchronizer_differenceBetweenRtpTimestamp";
          v14 = 1024;
          v15 = 260;
          v16 = 2048;
          v17 = v2;
          v18 = 2048;
          v19 = v5;
          v20 = 2048;
          v21 = v3;
          _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, "VCMediaStreamSynchronizer [%s] %s:%d VCMediaStreamSynchronizer: wrap around playoutSampleRTP(%lld)-destRTPOfNTP(%lld)=%lld", (uint8_t *)&v10, 0x3Au);
        }
      }
      else if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        v10 = 136316418;
        v11 = v6;
        v12 = 2080;
        v13 = "_VCMediaStreamSynchronizer_differenceBetweenRtpTimestamp";
        v14 = 1024;
        v15 = 260;
        v16 = 2048;
        v17 = v2;
        v18 = 2048;
        v19 = v5;
        v20 = 2048;
        v21 = v3;
        _os_log_debug_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEBUG, "VCMediaStreamSynchronizer [%s] %s:%d VCMediaStreamSynchronizer: wrap around playoutSampleRTP(%lld)-destRTPOfNTP(%lld)=%lld", (uint8_t *)&v10, 0x3Au);
      }
    }
  }
  return v3;
}

void VCMediaStreamSynchronizer_updateDestinationNTPTime(uint64_t a1, int a2, double a3)
{
  int ErrorLogLevelForModule;
  uint64_t v7;
  NSObject *v8;
  NSObject *v9;
  NSObject *v10;
  _QWORD block[6];
  int v12;
  uint8_t buf[4];
  uint64_t v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  uint64_t v20;
  __int16 v21;
  double v22;
  __int16 v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (a1)
  {
    if (ErrorLogLevelForModule >= 8)
    {
      v7 = VRTraceErrorLogLevelToCSTR();
      v8 = *MEMORY[0x1E0CF2758];
      v9 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316418;
          v14 = v7;
          v15 = 2080;
          v16 = "VCMediaStreamSynchronizer_updateDestinationNTPTime";
          v17 = 1024;
          v18 = 120;
          v19 = 2048;
          v20 = a1;
          v21 = 2048;
          v22 = a3;
          v23 = 1024;
          v24 = a2;
          _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, "VCMediaStreamSynchronizer [%s] %s:%d VCMediaStreamSynchronizer[%p] Received dest (video) ntpTime=%.6f rtpTimeStamp=%u", buf, 0x36u);
        }
      }
      else if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136316418;
        v14 = v7;
        v15 = 2080;
        v16 = "VCMediaStreamSynchronizer_updateDestinationNTPTime";
        v17 = 1024;
        v18 = 120;
        v19 = 2048;
        v20 = a1;
        v21 = 2048;
        v22 = a3;
        v23 = 1024;
        v24 = a2;
        _os_log_debug_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEBUG, "VCMediaStreamSynchronizer [%s] %s:%d VCMediaStreamSynchronizer[%p] Received dest (video) ntpTime=%.6f rtpTimeStamp=%u", buf, 0x36u);
      }
    }
    v10 = *(NSObject **)(a1 + 24);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = __VCMediaStreamSynchronizer_updateDestinationNTPTime_block_invoke;
    block[3] = &unk_1E9E52350;
    block[4] = a1;
    *(double *)&block[5] = a3;
    v12 = a2;
    dispatch_async(v10, block);
  }
  else if (ErrorLogLevelForModule >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCMediaStreamSynchronizer_updateDestinationNTPTime_cold_1();
  }
}

void VCMediaStreamSynchronizer_scheduleDestinationPlaybackWithRTPTimestamp(uint64_t a1, int a2)
{
  double v4;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  int v8;
  uint64_t v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  int v17;
  __int16 v18;
  double v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v4 = VCMediaStreamSynchronizer_scheduleTimeForDestinationRTPTimestamp(a1, a2);
    VCVideoPlayer_QueueAlarmForDecode(*(_QWORD *)(a1 + 32), (uint64_t)_VCMediaStreamSynchronizerAlarmCallback, a1, a2, 0, 0, v4);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v6 = *MEMORY[0x1E0CF2758];
      v7 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          v8 = 136316418;
          v9 = v5;
          v10 = 2080;
          v11 = "VCMediaStreamSynchronizer_scheduleDestinationPlaybackWithRTPTimestamp";
          v12 = 1024;
          v13 = 138;
          v14 = 2048;
          v15 = a1;
          v16 = 1024;
          v17 = a2;
          v18 = 2048;
          v19 = v4;
          _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, "VCMediaStreamSynchronizer [%s] %s:%d VCMediaStreamSynchronizer[%p]: Scheduled playout for dest (video) RTPTimestamp=%u scheduleTime=%.6f", (uint8_t *)&v8, 0x36u);
        }
      }
      else if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        v8 = 136316418;
        v9 = v5;
        v10 = 2080;
        v11 = "VCMediaStreamSynchronizer_scheduleDestinationPlaybackWithRTPTimestamp";
        v12 = 1024;
        v13 = 138;
        v14 = 2048;
        v15 = a1;
        v16 = 1024;
        v17 = a2;
        v18 = 2048;
        v19 = v4;
        _os_log_debug_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEBUG, "VCMediaStreamSynchronizer [%s] %s:%d VCMediaStreamSynchronizer[%p]: Scheduled playout for dest (video) RTPTimestamp=%u scheduleTime=%.6f", (uint8_t *)&v8, 0x36u);
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCMediaStreamSynchronizer_scheduleDestinationPlaybackWithRTPTimestamp_cold_1();
  }
}

double VCMediaStreamSynchronizer_scheduleTimeForDestinationRTPTimestamp(uint64_t a1, int a2)
{
  NSObject *v2;
  double v3;
  _QWORD v5[6];
  int v6;
  uint64_t v7;
  double *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v7 = 0;
  v8 = (double *)&v7;
  v9 = 0x2020000000;
  v10 = 0;
  v2 = *(NSObject **)(a1 + 24);
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = __VCMediaStreamSynchronizer_scheduleTimeForDestinationRTPTimestamp_block_invoke;
  v5[3] = &unk_1E9E54D70;
  v6 = a2;
  v5[4] = a1;
  v5[5] = &v7;
  dispatch_sync(v2, v5);
  v3 = v8[3];
  _Block_object_dispose(&v7, 8);
  return v3;
}

void _VCMediaStreamSynchronizerAlarmCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  os_unfair_lock_s *v7;
  uint64_t v8;

  if (a1)
  {
    v7 = (os_unfair_lock_s *)(a1 + 116);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 116));
    v8 = *(_QWORD *)(a1 + 40);
    if (v8)
      (*(void (**)(uint64_t, _QWORD, uint64_t))(v8 + 16))(v8, *(unsigned int *)(a2 + 8), a4);
    os_unfair_lock_unlock(v7);
  }
}

void VCMediaStreamSynchronizer_resetDestinationState(uint64_t a1)
{
  NSObject *v1;
  _QWORD v2[6];

  v2[5] = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v1 = *(NSObject **)(a1 + 24);
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 3221225472;
    v2[2] = __VCMediaStreamSynchronizer_resetDestinationState_block_invoke;
    v2[3] = &unk_1E9E521C0;
    v2[4] = a1;
    dispatch_async(v1, v2);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCMediaStreamSynchronizer_resetDestinationState_cold_1();
  }
}

void VCMediaStreamSynchronizer_setDestinationAlarmHandler(uint64_t a1, const void *a2)
{
  os_unfair_lock_s *v4;

  if (a1)
  {
    v4 = (os_unfair_lock_s *)(a1 + 116);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 116));
    _Block_release(*(const void **)(a1 + 40));
    *(_QWORD *)(a1 + 40) = _Block_copy(a2);
    os_unfair_lock_unlock(v4);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCMediaStreamSynchronizer_setDestinationAlarmHandler_cold_1();
  }
}

BOOL _VCMediaStreamSynchronizer_sourceRTPTimestampFromDestinationRTPTimestampInternal(uint64_t a1, int a2, int *a3)
{
  _BOOL8 result;
  int v7;
  int ErrorLogLevelForModule;
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  NSObject *v20;
  NSObject *v21;
  _BOOL4 v22;
  const char *v23;
  uint64_t v24;
  NSObject *v25;
  _BOOL4 v26;
  int v27;
  uint64_t v28;
  NSObject *v29;
  NSObject *v30;
  int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  __int16 v40;
  const char *v41;
  __int16 v42;
  int v43;
  __int16 v44;
  uint64_t v45;
  __int16 v46;
  int v47;
  __int16 v48;
  int v49;
  __int16 v50;
  uint64_t v51;
  __int16 v52;
  int v53;
  __int16 v54;
  int v55;
  __int16 v56;
  int v57;
  __int16 v58;
  uint64_t v59;
  __int16 v60;
  int v61;
  uint64_t v62;

  result = 0;
  v62 = *MEMORY[0x1E0C80C00];
  if (!a1 || !a3)
    return result;
  if (*(_DWORD *)(a1 + 100) == 1 || !*(_DWORD *)(a1 + 64) || !*(_DWORD *)(a1 + 96))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 8)
      return 0;
    v19 = VRTraceErrorLogLevelToCSTR();
    v20 = *MEMORY[0x1E0CF2758];
    v21 = *MEMORY[0x1E0CF2758];
    if (!*MEMORY[0x1E0CF2748])
    {
      result = os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG);
      if (!result)
        return result;
      _VCMediaStreamSynchronizer_sourceRTPTimestampFromDestinationRTPTimestampInternal_cold_1();
      return 0;
    }
    v22 = os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v22)
      return result;
    v38 = 136315906;
    v39 = v19;
    v40 = 2080;
    v41 = "_VCMediaStreamSynchronizer_sourceRTPTimestampFromDestinationRTPTimestampInternal";
    v42 = 1024;
    v43 = 283;
    v44 = 2048;
    v45 = a1;
    v23 = "VCMediaStreamSynchronizer [%s] %s:%d VCMediaStreamSynchronizer[%p]: source info not ready";
LABEL_15:
    _os_log_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_DEFAULT, v23, (uint8_t *)&v38, 0x26u);
    return 0;
  }
  v7 = *(_DWORD *)(a1 + 88);
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (!v7)
  {
    if (ErrorLogLevelForModule < 8)
      return 0;
    v24 = VRTraceErrorLogLevelToCSTR();
    v20 = *MEMORY[0x1E0CF2758];
    v25 = *MEMORY[0x1E0CF2758];
    if (!*MEMORY[0x1E0CF2748])
    {
      result = os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG);
      if (!result)
        return result;
      _VCMediaStreamSynchronizer_sourceRTPTimestampFromDestinationRTPTimestampInternal_cold_2();
      return 0;
    }
    v26 = os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v26)
      return result;
    v38 = 136315906;
    v39 = v24;
    v40 = 2080;
    v41 = "_VCMediaStreamSynchronizer_sourceRTPTimestampFromDestinationRTPTimestampInternal";
    v42 = 1024;
    v43 = 288;
    v44 = 2048;
    v45 = a1;
    v23 = "VCMediaStreamSynchronizer [%s] %s:%d VCMediaStreamSynchronizer[%p]: destination info not ready";
    goto LABEL_15;
  }
  if (ErrorLogLevelForModule >= 8)
  {
    v9 = VRTraceErrorLogLevelToCSTR();
    v10 = *MEMORY[0x1E0CF2758];
    v11 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        v12 = *(_DWORD *)(a1 + 96);
        v13 = *(_DWORD *)(a1 + 64);
        v14 = *(_QWORD *)(a1 + 48);
        v15 = *(_QWORD *)(a1 + 56);
        v16 = *(_DWORD *)(a1 + 88);
        v17 = *(_QWORD *)(a1 + 72);
        v18 = *(_QWORD *)(a1 + 80);
        v38 = 136317954;
        v39 = v9;
        v40 = 2080;
        v41 = "_VCMediaStreamSynchronizer_sourceRTPTimestampFromDestinationRTPTimestampInternal";
        v42 = 1024;
        v43 = 292;
        v44 = 2048;
        v45 = a1;
        v46 = 1024;
        v47 = v12;
        v48 = 1024;
        v49 = v13;
        v50 = 2048;
        v51 = v14;
        v52 = 1024;
        v53 = v15;
        v54 = 1024;
        v55 = a2;
        v56 = 1024;
        v57 = v16;
        v58 = 2048;
        v59 = v17;
        v60 = 1024;
        v61 = v18;
        _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, "VCMediaStreamSynchronizer [%s] %s:%d VCMediaStreamSynchronizer[%p]: lastSrcRTP=%u srcSRRTP=%u srcSRNPT=%.9f srcRate=%d dstRTP=%u dstSrRTP=%u dstSRNTP=%.9f dstRate=%d", (uint8_t *)&v38, 0x5Eu);
      }
    }
    else if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      v31 = *(_DWORD *)(a1 + 96);
      v32 = *(_DWORD *)(a1 + 64);
      v33 = *(_QWORD *)(a1 + 48);
      v34 = *(_QWORD *)(a1 + 56);
      v35 = *(_DWORD *)(a1 + 88);
      v36 = *(_QWORD *)(a1 + 72);
      v37 = *(_QWORD *)(a1 + 80);
      v38 = 136317954;
      v39 = v9;
      v40 = 2080;
      v41 = "_VCMediaStreamSynchronizer_sourceRTPTimestampFromDestinationRTPTimestampInternal";
      v42 = 1024;
      v43 = 292;
      v44 = 2048;
      v45 = a1;
      v46 = 1024;
      v47 = v31;
      v48 = 1024;
      v49 = v32;
      v50 = 2048;
      v51 = v33;
      v52 = 1024;
      v53 = v34;
      v54 = 1024;
      v55 = a2;
      v56 = 1024;
      v57 = v35;
      v58 = 2048;
      v59 = v36;
      v60 = 1024;
      v61 = v37;
      _os_log_debug_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEBUG, "VCMediaStreamSynchronizer [%s] %s:%d VCMediaStreamSynchronizer[%p]: lastSrcRTP=%u srcSRRTP=%u srcSRNPT=%.9f srcRate=%d dstRTP=%u dstSrRTP=%u dstSRNTP=%.9f dstRate=%d", (uint8_t *)&v38, 0x5Eu);
    }
  }
  v27 = *(_DWORD *)(a1 + 64)
      + (int)((*(double *)(a1 + 72)
             + (double)_VCMediaStreamSynchronizer_differenceBetweenRtpTimestamp(a2, *(_DWORD *)(a1 + 88))
             / (double)*(uint64_t *)(a1 + 80)
             - *(double *)(a1 + 48))
            * (double)*(uint64_t *)(a1 + 56));
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v28 = VRTraceErrorLogLevelToCSTR();
    v29 = *MEMORY[0x1E0CF2758];
    v30 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        v38 = 136316418;
        v39 = v28;
        v40 = 2080;
        v41 = "_VCMediaStreamSynchronizer_sourceRTPTimestampFromDestinationRTPTimestampInternal";
        v42 = 1024;
        v43 = 297;
        v44 = 2048;
        v45 = a1;
        v46 = 1024;
        v47 = a2;
        v48 = 1024;
        v49 = v27;
        _os_log_impl(&dword_1D8A54000, v29, OS_LOG_TYPE_DEFAULT, "VCMediaStreamSynchronizer [%s] %s:%d VCMediaStreamSynchronizer[%p]: DToS: %u->%u", (uint8_t *)&v38, 0x32u);
      }
    }
    else if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
    {
      v38 = 136316418;
      v39 = v28;
      v40 = 2080;
      v41 = "_VCMediaStreamSynchronizer_sourceRTPTimestampFromDestinationRTPTimestampInternal";
      v42 = 1024;
      v43 = 297;
      v44 = 2048;
      v45 = a1;
      v46 = 1024;
      v47 = a2;
      v48 = 1024;
      v49 = v27;
      _os_log_debug_impl(&dword_1D8A54000, v29, OS_LOG_TYPE_DEBUG, "VCMediaStreamSynchronizer [%s] %s:%d VCMediaStreamSynchronizer[%p]: DToS: %u->%u", (uint8_t *)&v38, 0x32u);
    }
  }
  *a3 = v27;
  return 1;
}

BOOL VCMediaStreamSynchronizer_sourceRTPTimestampFromDestinationRTPTimestamp(uint64_t a1, int a2, _DWORD *a3)
{
  _BOOL8 v3;
  NSObject *v5;
  int v6;
  _QWORD block[7];
  int v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  char v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  int v17;
  uint64_t v18;

  v3 = 0;
  v18 = *MEMORY[0x1E0C80C00];
  if (a1 && a3)
  {
    v14 = 0;
    v15 = &v14;
    v16 = 0x2020000000;
    v17 = 0;
    v10 = 0;
    v11 = &v10;
    v12 = 0x2020000000;
    v13 = 0;
    v5 = *(NSObject **)(a1 + 24);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = __VCMediaStreamSynchronizer_sourceRTPTimestampFromDestinationRTPTimestamp_block_invoke;
    block[3] = &unk_1E9E579C8;
    block[4] = a1;
    block[5] = &v10;
    v9 = a2;
    block[6] = &v14;
    dispatch_sync(v5, block);
    v6 = *((unsigned __int8 *)v11 + 24);
    if (*((_BYTE *)v11 + 24))
      *a3 = *((_DWORD *)v15 + 6);
    v3 = v6 != 0;
    _Block_object_dispose(&v10, 8);
    _Block_object_dispose(&v14, 8);
  }
  return v3;
}

BOOL VCMediaStreamSynchronizer_destRTPTimestampFromSourceRTPTimestamp(uint64_t a1, int a2, uint64_t a3)
{
  _BOOL8 v3;
  NSObject *v4;
  _QWORD block[7];
  int v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  char v11;
  uint64_t v12;

  v3 = 0;
  v12 = *MEMORY[0x1E0C80C00];
  if (a1 && a3)
  {
    v8 = 0;
    v9 = &v8;
    v10 = 0x2020000000;
    v11 = 0;
    v4 = *(NSObject **)(a1 + 24);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = __VCMediaStreamSynchronizer_destRTPTimestampFromSourceRTPTimestamp_block_invoke;
    block[3] = &unk_1E9E535E0;
    block[5] = &v8;
    block[6] = a3;
    v7 = a2;
    block[4] = a1;
    dispatch_sync(v4, block);
    v3 = *((_BYTE *)v9 + 24) != 0;
    _Block_object_dispose(&v8, 8);
  }
  return v3;
}

void VCMediaStreamSynchronizer_setSourcePlayoutTimeUpdatedHandler(uint64_t a1, const void *a2)
{
  os_unfair_lock_s *v4;

  if (a1)
  {
    v4 = (os_unfair_lock_s *)(a1 + 112);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
    _Block_release(*(const void **)(a1 + 104));
    *(_QWORD *)(a1 + 104) = _Block_copy(a2);
    os_unfair_lock_unlock(v4);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCMediaStreamSynchronizer_setSourcePlayoutTimeUpdatedHandler_cold_1();
  }
}

void VCMediaStreamSyncSourceDelegate_updateSourceState(uint64_t a1, int a2)
{
  NSObject *v2;
  _QWORD block[5];
  int v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = *(NSObject **)(a1 + 24);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = __VCMediaStreamSyncSourceDelegate_updateSourceState_block_invoke;
    block[3] = &unk_1E9E52300;
    v4 = a2;
    block[4] = a1;
    dispatch_async(v2, block);
  }
}

void VCMediaStreamSyncSourceDelegate_resetSourceState(uint64_t a1)
{
  NSObject *v1;
  _QWORD v2[6];

  v2[5] = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (!*(_DWORD *)(a1 + 100))
    {
      v1 = *(NSObject **)(a1 + 24);
      v2[0] = MEMORY[0x1E0C809B0];
      v2[1] = 3221225472;
      v2[2] = __VCMediaStreamSyncSourceDelegate_resetSourceState_block_invoke;
      v2[3] = &unk_1E9E521C0;
      v2[4] = a1;
      dispatch_async(v1, v2);
    }
  }
}

void VCMediaStreamSyncSourceDelegate_updateSourcePlayoutSampleRTPTimestamp(uint64_t a1, int a2, double a3)
{
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  NSObject *v13;
  _QWORD v14[6];
  int v15;
  __int128 v16;
  uint64_t v17;
  double v18;
  _QWORD block[7];
  int v20;
  _BYTE buf[24];
  _BYTE v22[24];
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v6 = VRTraceErrorLogLevelToCSTR();
      v7 = *MEMORY[0x1E0CF2758];
      v8 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316418;
          *(_QWORD *)&buf[4] = v6;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "VCMediaStreamSyncSourceDelegate_updateSourcePlayoutSampleRTPTimestamp";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)v22 = 362;
          *(_WORD *)&v22[4] = 2048;
          *(_QWORD *)&v22[6] = a1;
          *(_WORD *)&v22[14] = 2048;
          *(double *)&v22[16] = a3;
          LOWORD(v23) = 1024;
          *(_DWORD *)((char *)&v23 + 2) = a2;
          _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, "VCMediaStreamSynchronizer [%s] %s:%d VCMediaStreamSynchronizer[%p]: Received source (audio) frame. systemTime=%.6f playoutSampleRTPTimestamp=%u", buf, 0x36u);
        }
      }
      else if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136316418;
        *(_QWORD *)&buf[4] = v6;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "VCMediaStreamSyncSourceDelegate_updateSourcePlayoutSampleRTPTimestamp";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)v22 = 362;
        *(_WORD *)&v22[4] = 2048;
        *(_QWORD *)&v22[6] = a1;
        *(_WORD *)&v22[14] = 2048;
        *(double *)&v22[16] = a3;
        LOWORD(v23) = 1024;
        *(_DWORD *)((char *)&v23 + 2) = a2;
        _os_log_debug_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEBUG, "VCMediaStreamSynchronizer [%s] %s:%d VCMediaStreamSynchronizer[%p]: Received source (audio) frame. systemTime=%.6f playoutSampleRTPTimestamp=%u", buf, 0x36u);
      }
    }
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
    v9 = *(_QWORD *)(a1 + 104);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 112));
    if (v9)
    {
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = buf;
      *(_QWORD *)&buf[16] = 0x3810000000;
      *(_OWORD *)&v22[8] = *MEMORY[0x1E0CA2E18];
      v10 = *(_QWORD *)(MEMORY[0x1E0CA2E18] + 16);
      *(_QWORD *)v22 = "";
      v23 = v10;
      v11 = *(NSObject **)(a1 + 24);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = __VCMediaStreamSyncSourceDelegate_updateSourcePlayoutSampleRTPTimestamp_block_invoke;
      block[3] = &unk_1E9E579F0;
      block[4] = a1;
      block[5] = buf;
      v20 = a2;
      *(double *)&block[6] = a3;
      dispatch_sync(v11, block);
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
      v12 = *(_QWORD *)(a1 + 104);
      if (v12)
      {
        v17 = *(_QWORD *)(*(_QWORD *)&buf[8] + 48);
        v16 = *(_OWORD *)(*(_QWORD *)&buf[8] + 32);
        v18 = a3;
        (*(void (**)(uint64_t, __int128 *))(v12 + 16))(v12, &v16);
      }
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 112));
      _Block_object_dispose(buf, 8);
    }
    else
    {
      v13 = *(NSObject **)(a1 + 24);
      v14[0] = MEMORY[0x1E0C809B0];
      v14[1] = 3221225472;
      v14[2] = __VCMediaStreamSyncSourceDelegate_updateSourcePlayoutSampleRTPTimestamp_block_invoke_2;
      v14[3] = &unk_1E9E52350;
      v14[4] = a1;
      v15 = a2;
      *(double *)&v14[5] = a3;
      dispatch_async(v13, v14);
    }
  }
}

void sub_1D8EC9A40(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 128), 8);
  _Unwind_Resume(a1);
}

CMTime *_VCMediaStreamSynchronizer_updateSourcePlayoutSampleRTPTimestampInternal@<X0>(uint64_t a1@<X0>, unsigned int a2@<W1>, CMTime *a3@<X8>, double a4@<D0>)
{
  unsigned int v7;
  BOOL v8;
  unsigned int v9;
  int v10;

  v7 = *(_DWORD *)(a1 + 96);
  v8 = a2 >= v7;
  v9 = a2 - v7;
  v10 = *(_DWORD *)(a1 + 16);
  if (!v8 && v9 <= 0x7FFFFFFE)
    *(_DWORD *)(a1 + 16) = ++v10;
  *(_DWORD *)(a1 + 96) = a2;
  *(double *)(a1 + 8) = a4;
  VCVideoPlayer_CallAlarms(*(_QWORD *)(a1 + 32), a4, ((double)a2 + (double)v10 * 4294967300.0) / (double)*(uint64_t *)(a1 + 56));
  return CMTimeMake(a3, a2 | ((unint64_t)*(unsigned int *)(a1 + 16) << 32), objc_msgSend((id)a1, "sourceSampleRate"));
}

void VCMediaStreamSyncSourceDelegate_updateSourceNTPTimeWithRTPTimeStamp(uint64_t a1, int a2, double a3)
{
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  _QWORD block[6];
  int v11;
  uint8_t buf[4];
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  uint64_t v19;
  __int16 v20;
  double v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v6 = VRTraceErrorLogLevelToCSTR();
      v7 = *MEMORY[0x1E0CF2758];
      v8 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316418;
          v13 = v6;
          v14 = 2080;
          v15 = "VCMediaStreamSyncSourceDelegate_updateSourceNTPTimeWithRTPTimeStamp";
          v16 = 1024;
          v17 = 392;
          v18 = 2048;
          v19 = a1;
          v20 = 2048;
          v21 = a3;
          v22 = 1024;
          v23 = a2;
          _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, "VCMediaStreamSynchronizer [%s] %s:%d VCMediaStreamSynchronizer[%p] Received source (audio) ntpTime=%.6f rtpTimeStamp=%u", buf, 0x36u);
        }
      }
      else if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136316418;
        v13 = v6;
        v14 = 2080;
        v15 = "VCMediaStreamSyncSourceDelegate_updateSourceNTPTimeWithRTPTimeStamp";
        v16 = 1024;
        v17 = 392;
        v18 = 2048;
        v19 = a1;
        v20 = 2048;
        v21 = a3;
        v22 = 1024;
        v23 = a2;
        _os_log_debug_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEBUG, "VCMediaStreamSynchronizer [%s] %s:%d VCMediaStreamSynchronizer[%p] Received source (audio) ntpTime=%.6f rtpTimeStamp=%u", buf, 0x36u);
      }
    }
    v9 = *(NSObject **)(a1 + 24);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = __VCMediaStreamSyncSourceDelegate_updateSourceNTPTimeWithRTPTimeStamp_block_invoke;
    block[3] = &unk_1E9E52350;
    block[4] = a1;
    *(double *)&block[5] = a3;
    v11 = a2;
    dispatch_async(v9, block);
  }
}

size_t VCBoundsSafety_IndexableToNulTerminated(char *__s1, size_t a2)
{
  char *v2;
  size_t result;
  char *v5;

  v2 = __s1;
  if (!__s1)
    return (size_t)v2;
  result = strnlen(__s1, a2);
  if (result == a2)
    return 0;
  v5 = &v2[result];
  if (&v2[result] >= v2 && v5 + 1 >= v5 && v5 + 1 <= &v2[a2] && !*v5)
    return (size_t)v2;
  __break(0x5519u);
  return result;
}

void _VCBoundsSafety_ReleaseAssignAndRetain(const void **a1, CFTypeRef cf)
{
  const void *v4;

  if (a1)
  {
    v4 = *a1;
    if (v4)
      CFRelease(v4);
    if (cf)
      CFRetain(cf);
    *a1 = cf;
  }
}

void *VCBoundsSafety_AllocatorAllocate(const __CFAllocator *a1, CFIndex a2, CFOptionFlags a3)
{
  return CFAllocatorAllocate(a1, a2, a3);
}

uint64_t VCPacketInitialize(uint64_t a1)
{
  uint64_t result;

  if (!a1)
    return 2150957057;
  result = 0;
  *(_QWORD *)(a1 + 160) = 0;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

uint64_t VCPacketInvalidate(uint64_t *a1)
{
  uint64_t result;

  result = 2150957057;
  if (a1)
  {
    if (a1[20])
    {
      return 2150957118;
    }
    else
    {
      result = *a1;
      if (*a1)
      {
        CFRelease((CFTypeRef)result);
        result = 0;
        *a1 = 0;
      }
    }
  }
  return result;
}

uint64_t VCRealTimeThread_Initialize(int a1, uint64_t a2, uint64_t a3, const char *a4, int a5)
{
  void *v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  int v15;
  uint64_t v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  const char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (!a2 || !a3 || !a4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v12 = VRTraceErrorLogLevelToCSTR();
      v13 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v15 = 136316418;
        v16 = v12;
        v17 = 2080;
        v18 = "VCRealTimeThread_Initialize";
        v19 = 1024;
        v20 = 63;
        v21 = 2048;
        v22 = a2;
        v23 = 2048;
        v24 = a3;
        v25 = 2048;
        v26 = a4;
        _os_log_error_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_ERROR, " [%s] %s:%d called with invalid parameter: routine=%p context=%p identifier=%p", (uint8_t *)&v15, 0x3Au);
      }
    }
    return 0;
  }
  v10 = malloc_type_calloc(1uLL, 0xB0uLL, 0x10A0040640140D7uLL);
  if (!v10)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCRealTimeThread_Initialize_cold_1();
    }
    return 0;
  }
  v11 = (uint64_t)v10;
  *(_QWORD *)v10 = 0;
  *((_QWORD *)v10 + 10) = a2;
  *((_QWORD *)v10 + 11) = a3;
  *((_DWORD *)v10 + 42) = a1;
  *((_DWORD *)v10 + 43) = a5;
  *((_DWORD *)v10 + 26) = -1;
  strncpy((char *)v10 + 108, a4, 0x3CuLL);
  pthread_mutex_init((pthread_mutex_t *)(v11 + 8), 0);
  *(_QWORD *)(v11 + 72) = dispatch_semaphore_create(0);
  if ((VCRealTimeThread_ChangeState(v11, 1) & 1) == 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCRealTimeThread_Initialize_cold_2();
    }
    dispatch_release(*(dispatch_object_t *)(v11 + 72));
    pthread_mutex_destroy((pthread_mutex_t *)(v11 + 8));
    free((void *)v11);
    return 0;
  }
  return v11;
}

uint64_t VCRealTimeThread_ChangeState(uint64_t a1, int a2)
{
  pthread_mutex_t *v4;
  CFStringRef v5;
  uint64_t v6;
  void *v7;
  CFIndex v8;
  CFDictionaryRef v9;
  int v10;
  int v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  NSObject *v17;
  int v18;
  int v20;
  _BYTE keys[22];
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  void *values[3];

  values[2] = *(void **)MEMORY[0x1E0C80C00];
  v4 = (pthread_mutex_t *)(a1 + 8);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  switch(*(_DWORD *)a1)
  {
    case 0:
      if (!a2 || a2 == 3)
        goto LABEL_38;
      if (a2 != 1)
        goto LABEL_27;
      v5 = CFStringCreateWithFormat(0, 0, CFSTR("%s"), a1 + 108);
      v6 = *MEMORY[0x1E0CA52D0];
      *(_QWORD *)keys = *MEMORY[0x1E0CA52C8];
      *(_QWORD *)&keys[8] = v6;
      v7 = (void *)*MEMORY[0x1E0C9AE40];
      values[0] = (void *)v5;
      values[1] = v7;
      if ((*(_DWORD *)(a1 + 172) & 1) != 0)
        v8 = 2;
      else
        v8 = 1;
      v9 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)keys, (const void **)values, v8, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      v10 = FigThreadCreate();
      if (v10
        && (int)VRTraceGetErrorLogLevelForModule() >= 3
        && (VRTraceErrorLogLevelToCSTR(), os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR)))
      {
        VCRealTimeThread_ChangeState_cold_1();
        if (!v9)
        {
LABEL_13:
          if (v5)
            CFRelease(v5);
          if (v10)
            goto LABEL_27;
          goto LABEL_38;
        }
      }
      else if (!v9)
      {
        goto LABEL_13;
      }
      CFRelease(v9);
      goto LABEL_13;
    case 1:
      switch(a2)
      {
        case 1:
          goto LABEL_38;
        case 2:
          v15 = VTP_Socket(2, 1, 0);
          *(_DWORD *)(a1 + 104) = v15;
          if (v15 != -1)
            goto LABEL_37;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VCRealTimeThread_ChangeState_cold_2();
          }
          if (*(_DWORD *)(a1 + 104) != -1)
          {
LABEL_37:
            *(_DWORD *)(a1 + 4) |= 2u;
            dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 72));
LABEL_38:
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v16 = VRTraceErrorLogLevelToCSTR();
              v17 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                v18 = *(_DWORD *)a1;
                *(_DWORD *)keys = 136316162;
                *(_QWORD *)&keys[4] = v16;
                *(_WORD *)&keys[12] = 2080;
                *(_QWORD *)&keys[14] = "VCRealTimeThread_ChangeState";
                v22 = 1024;
                v23 = 313;
                v24 = 1024;
                v25 = v18;
                v26 = 1024;
                v27 = a2;
                _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Successful thread state transition: %d -> %d", keys, 0x28u);
              }
            }
            *(_DWORD *)a1 = a2;
            v14 = 1;
            goto LABEL_42;
          }
          break;
        case 3:
LABEL_31:
          VCRealTimeThread_InternalStop(a1);
          goto LABEL_38;
      }
LABEL_27:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v12 = VRTraceErrorLogLevelToCSTR();
        v13 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v20 = *(_DWORD *)a1;
          *(_DWORD *)keys = 136316162;
          *(_QWORD *)&keys[4] = v12;
          *(_WORD *)&keys[12] = 2080;
          *(_QWORD *)&keys[14] = "VCRealTimeThread_ChangeState";
          v22 = 1024;
          v23 = 316;
          v24 = 1024;
          v25 = v20;
          v26 = 1024;
          v27 = a2;
          _os_log_error_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_ERROR, " [%s] %s:%d Thread state transition failed: %d -> %d", keys, 0x28u);
        }
      }
      v14 = 0;
LABEL_42:
      pthread_mutex_unlock(v4);
      return v14;
    case 2:
      if (a2 == 3)
        goto LABEL_31;
      if (a2 == 2)
        goto LABEL_38;
      if (a2 != 1)
        goto LABEL_27;
      *(_DWORD *)(a1 + 4) |= 1u;
      v11 = *(_DWORD *)(a1 + 104);
      if (v11 != -1)
      {
        VTP_Close(v11);
        *(_DWORD *)(a1 + 104) = -1;
      }
      goto LABEL_38;
    case 3:
      if (a2 != 3)
        goto LABEL_27;
      goto LABEL_38;
    default:
      goto LABEL_27;
  }
}

void VCRealTimeThread_Finalize(uint64_t a1)
{
  if (a1)
  {
    VCRealTimeThread_ChangeState(a1, 3);
    if (*(_QWORD *)(a1 + 96))
    {
      FigThreadJoin();
      *(_QWORD *)(a1 + 96) = 0;
    }
    dispatch_release(*(dispatch_object_t *)(a1 + 72));
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 8));
    free((void *)a1);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRealTimeThread_Finalize_cold_1();
  }
}

uint64_t VCRealTimeThread_Start(uint64_t a1)
{
  int ErrorLogLevelForModule;
  uint64_t v3;
  NSObject *v4;
  uint64_t result;
  int v6;
  uint64_t v7;
  __int16 v8;
  const char *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (a1)
  {
    if (ErrorLogLevelForModule >= 7)
    {
      v3 = VRTraceErrorLogLevelToCSTR();
      v4 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v6 = 136315906;
        v7 = v3;
        v8 = 2080;
        v9 = "VCRealTimeThread_Start";
        v10 = 1024;
        v11 = 120;
        v12 = 2080;
        v13 = a1 + 108;
        _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d ### VCRealTimeThread_Start(%s) called!", (uint8_t *)&v6, 0x26u);
      }
    }
    return VCRealTimeThread_ChangeState(a1, 2);
  }
  else
  {
    if (ErrorLogLevelForModule >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!(_DWORD)result)
        return result;
      VCRealTimeThread_Start_cold_1();
    }
    return 0;
  }
}

uint64_t VCRealTimeThread_Stop(uint64_t a1)
{
  int ErrorLogLevelForModule;
  uint64_t v3;
  NSObject *v4;
  uint64_t result;
  int v6;
  uint64_t v7;
  __int16 v8;
  const char *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (a1)
  {
    if (ErrorLogLevelForModule >= 7)
    {
      v3 = VRTraceErrorLogLevelToCSTR();
      v4 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v6 = 136315906;
        v7 = v3;
        v8 = 2080;
        v9 = "VCRealTimeThread_Stop";
        v10 = 1024;
        v11 = 130;
        v12 = 2080;
        v13 = a1 + 108;
        _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d ### VCRealTimeThread_Stop(%s) called!", (uint8_t *)&v6, 0x26u);
      }
    }
    return VCRealTimeThread_ChangeState(a1, 1);
  }
  else
  {
    if (ErrorLogLevelForModule >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!(_DWORD)result)
        return result;
      VCRealTimeThread_Stop_cold_1();
    }
    return 0;
  }
}

uint64_t VCRealTimeThread_InternalStop(uint64_t a1)
{
  uint64_t result;

  *(_DWORD *)(a1 + 4) |= 4u;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 72));
  result = *(unsigned int *)(a1 + 104);
  if ((_DWORD)result != -1)
  {
    result = VTP_Close(result);
    *(_DWORD *)(a1 + 104) = -1;
  }
  return result;
}

uint64_t VCRealTimeThread_ThreadProc(uint64_t a1)
{
  pthread_mutex_t *v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  os_log_t *v7;
  int v8;
  unsigned int v9;
  uint64_t v10;
  NSObject *v11;
  int v12;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  NSObject *v17;
  char v19;
  int v20;
  uint8_t buf[4];
  uint64_t v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  int v26;
  __int16 v27;
  uint64_t v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v2 = (pthread_mutex_t *)(a1 + 8);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  v3 = *(_DWORD *)(a1 + 4);
  pthread_mutex_unlock(v2);
  v4 = a1 + 108;
  pthread_setname_np((const char *)(a1 + 108));
  if ((*(_BYTE *)(a1 + 172) & 2) != 0)
  {
    if (proc_setthread_cpupercent())
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCRealTimeThread_ThreadProc_cold_1();
      }
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v5 = VRTraceErrorLogLevelToCSTR();
    v6 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      v22 = v5;
      v23 = 2080;
      v24 = "VCRealTimeThread_ThreadProc";
      v25 = 1024;
      v26 = 178;
      v27 = 2080;
      v28 = a1 + 108;
      _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d ### VCRealTimeThread_ThreadProc(%s) start!", buf, 0x26u);
    }
  }
  v20 = -1;
  if ((v3 & 4) == 0)
  {
    v7 = (os_log_t *)MEMORY[0x1E0CF2758];
    do
    {
      while ((*(_BYTE *)(a1 + 4) & 6) == 0)
        dispatch_semaphore_wait(*(dispatch_semaphore_t *)(a1 + 72), 0xFFFFFFFFFFFFFFFFLL);
      v20 = *(_DWORD *)(a1 + 104);
      pthread_mutex_lock(v2);
      v8 = *(_DWORD *)(a1 + 4);
      LOBYTE(v9) = v8 & 0xFD;
      *(_DWORD *)(a1 + 4) = v8 & 0xFFFFFFFD;
      pthread_mutex_unlock(v2);
      if (v20 == -1)
      {
        pthread_mutex_lock(v2);
        *(_DWORD *)(a1 + 4) &= ~1u;
      }
      else
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v10 = VRTraceErrorLogLevelToCSTR();
          v11 = *v7;
          if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315906;
            v22 = v10;
            v23 = 2080;
            v24 = "VCRealTimeThread_ThreadProc";
            v25 = 1024;
            v26 = 194;
            v27 = 2080;
            v28 = a1 + 108;
            _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d ### VCRealTimeThread_ThreadProc(%s) running!", buf, 0x26u);
          }
        }
        v19 = 0;
        if ((v8 & 5) == 0)
        {
          do
          {
            (*(void (**)(_QWORD, int *, char *))(a1 + 80))(*(_QWORD *)(a1 + 88), &v20, &v19);
            pthread_mutex_lock(v2);
            v12 = *(_DWORD *)(a1 + 4);
            pthread_mutex_unlock(v2);
          }
          while ((v12 & 5) == 0 && v19 == 0);
          if (v19)
            VCRealTimeThread_ChangeState(a1, 1);
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v14 = VRTraceErrorLogLevelToCSTR();
          v15 = *v7;
          if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315906;
            v22 = v14;
            v23 = 2080;
            v24 = "VCRealTimeThread_ThreadProc";
            v25 = 1024;
            v26 = 205;
            v27 = 2080;
            v28 = a1 + 108;
            _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d ### VCRealTimeThread_ThreadProc(%s) pausing!", buf, 0x26u);
          }
        }
        pthread_mutex_lock(v2);
        v9 = *(_DWORD *)(a1 + 4) & 0xFFFFFFFE;
        *(_DWORD *)(a1 + 4) = v9;
      }
      pthread_mutex_unlock(v2);
    }
    while ((v9 & 4) == 0);
  }
  pthread_mutex_lock(v2);
  *(_DWORD *)(a1 + 4) &= ~4u;
  pthread_mutex_unlock(v2);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v16 = VRTraceErrorLogLevelToCSTR();
    v17 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      v22 = v16;
      v23 = 2080;
      v24 = "VCRealTimeThread_ThreadProc";
      v25 = 1024;
      v26 = 210;
      v27 = 2080;
      v28 = v4;
      _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d ### VCRealTimeThread_ThreadProc(%s) stop!", buf, 0x26u);
    }
  }
  return 0;
}

uint64_t VCCCMessageWrapperReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  unint64_t v17;
  unsigned int v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  int v22;
  VCCCMessageAcknowledgment *v24;
  VCCCMessage *v25;
  uint64_t result;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        return *(_BYTE *)(a2 + *v5) == 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        return *(_BYTE *)(a2 + *v5) == 0;
      v17 = v10 >> 3;
      if ((v10 >> 3) == 2)
      {
        objc_msgSend((id)a1, "clearOneofValuesForContent");
        *(_BYTE *)(a1 + 32) |= 1u;
        *(_DWORD *)(a1 + 16) = 2;
        v24 = objc_alloc_init(VCCCMessageAcknowledgment);

        *(_QWORD *)(a1 + 8) = v24;
        if (!PBReaderPlaceMark() || (VCCCMessageAcknowledgmentReadFrom((uint64_t)v24, a2) & 1) == 0)
          return 0;
      }
      else
      {
        if ((_DWORD)v17 != 1)
        {
          if ((_DWORD)v17)
          {
            result = PBReaderSkipValueWithTag();
            if (!(_DWORD)result)
              return result;
          }
          else
          {
            v18 = 0;
            while (1)
            {
              v19 = *v3;
              v20 = *(_QWORD *)(a2 + v19);
              if (v20 == -1 || v20 >= *(_QWORD *)(a2 + *v4))
                break;
              v21 = v20 + 1;
              v22 = *(char *)(*(_QWORD *)(a2 + *v7) + v20);
              *(_QWORD *)(a2 + v19) = v21;
              if (v22 < 0 && v18++ <= 8)
                continue;
              goto LABEL_37;
            }
            *(_BYTE *)(a2 + *v5) = 1;
          }
          continue;
        }
        objc_msgSend((id)a1, "clearOneofValuesForContent");
        *(_BYTE *)(a1 + 32) |= 1u;
        *(_DWORD *)(a1 + 16) = 1;
        v25 = objc_alloc_init(VCCCMessage);

        *(_QWORD *)(a1 + 24) = v25;
        if (!PBReaderPlaceMark() || (VCCCMessageReadFrom((uint64_t)v25, a2) & 1) == 0)
          return 0;
      }
      PBReaderRecallMark();
LABEL_37:
      ;
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void *VCStreamInputUtil_EncodeFormatDescription(const opaqueCMFormatDescription *a1)
{
  xpc_object_t v2;
  void *v3;

  v2 = xpc_dictionary_create(0, 0, 0);
  if (!v2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCStreamInputUtil_EncodeFormatDescription_cold_1();
    }
    return 0;
  }
  v3 = v2;
  if (!_VCStreamInputUtil_AddFormatDescription(v2, a1))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCStreamInputUtil_EncodeFormatDescription_cold_2();
    }
    xpc_release(v3);
    return 0;
  }
  return v3;
}

BOOL _VCStreamInputUtil_AddFormatDescription(void *a1, CMFormatDescriptionRef desc)
{
  CMMediaType MediaType;
  FourCharCode MediaSubType;
  CMVideoDimensions Dimensions;
  int32_t height;
  uint64_t v8;
  void *v9;
  const char *v10;
  const AudioStreamBasicDescription *StreamBasicDescription;
  xpc_object_t v12;
  _BOOL8 result;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  NSObject *v17;
  uint64_t v18;
  NSObject *v19;

  MediaType = CMFormatDescriptionGetMediaType(desc);
  if (!_VCStreamInputUtil_AddUint32Value(a1, "VCStreamInputMediaType", MediaType))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v16 = VRTraceErrorLogLevelToCSTR();
      v17 = *MEMORY[0x1E0CF2758];
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      _VCStreamInputUtil_AddFormatDescription_cold_8(v16, MediaType, v17);
    }
    return 0;
  }
  MediaSubType = CMFormatDescriptionGetMediaSubType(desc);
  if (!_VCStreamInputUtil_AddUint32Value(a1, "VCStreamInputMediaSubtype", MediaSubType))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v18 = VRTraceErrorLogLevelToCSTR();
      v19 = *MEMORY[0x1E0CF2758];
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      _VCStreamInputUtil_AddFormatDescription_cold_7(v18, MediaType, v19);
    }
    return 0;
  }
  if (MediaType == 1835365473)
    return 1;
  if (MediaType == 1936684398)
  {
    StreamBasicDescription = CMAudioFormatDescriptionGetStreamBasicDescription(desc);
    if (StreamBasicDescription)
    {
      v12 = xpc_data_create(StreamBasicDescription, 0x28uLL);
      if (v12)
      {
        v9 = v12;
        v10 = "VCStreamInputFormatASBD";
        goto LABEL_14;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
        if (!result)
          return result;
        _VCStreamInputUtil_AddFormatDescription_cold_6();
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      _VCStreamInputUtil_AddFormatDescription_cold_5();
    }
    return 0;
  }
  if (MediaType != 1986618469)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v14 = VRTraceErrorLogLevelToCSTR();
      v15 = *MEMORY[0x1E0CF2758];
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      _VCStreamInputUtil_AddFormatDescription_cold_1(v14, MediaType, v15);
    }
    return 0;
  }
  Dimensions = CMVideoFormatDescriptionGetDimensions(desc);
  height = Dimensions.height;
  if (!_VCStreamInputUtil_AddUint32Value(a1, "VCStreamInputPixelBufferWidth", Dimensions.width))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      _VCStreamInputUtil_AddFormatDescription_cold_4();
    }
    return 0;
  }
  if (!_VCStreamInputUtil_AddUint32Value(a1, "VCStreamInputPixelBufferHeight", height))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      _VCStreamInputUtil_AddFormatDescription_cold_3();
    }
    return 0;
  }
  if (!CMFormatDescriptionGetExtensions(desc))
    return 1;
  v8 = _CFXPCCreateXPCObjectFromCFObject();
  if (v8)
  {
    v9 = (void *)v8;
    v10 = "VCStreamInputFormatExtensions";
LABEL_14:
    xpc_dictionary_set_value(a1, v10, v9);
    xpc_release(v9);
    return 1;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() < 3)
    return 0;
  VRTraceErrorLogLevelToCSTR();
  result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
  if (result)
  {
    _VCStreamInputUtil_AddFormatDescription_cold_2();
    return 0;
  }
  return result;
}

void *VCStreamInputUtil_EncodeSampleBuffer(opaqueCMSampleBuffer *a1)
{
  const opaqueCMFormatDescription *FormatDescription;
  signed int MediaType;
  void *v4;
  int NumSamples;
  __CVBuffer *ImageBuffer;
  __int128 v7;
  CMFormatDescriptionRef v8;
  const opaqueCMFormatDescription *v9;
  xpc_object_t v10;
  __IOSurface *IOSurface;
  xpc_object_t XPCObject;
  const void *v13;
  BOOL v14;
  CMTime presentationTimeStamp;
  CMSampleTimingInfo timingInfoOut;
  CMTime v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  FormatDescription = CMSampleBufferGetFormatDescription(a1);
  MediaType = CMFormatDescriptionGetMediaType(FormatDescription);
  v4 = 0;
  if (MediaType > 1952807027)
  {
    if (MediaType == 1952807028)
      return _VCStreamInputUtil_EncodeDataSampleBuffer(a1);
    if (MediaType != 1986618469)
      return v4;
    ImageBuffer = CMSampleBufferGetImageBuffer(a1);
    timingInfoOut.decodeTimeStamp.epoch = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&timingInfoOut.presentationTimeStamp.timescale = v7;
    *(_OWORD *)&timingInfoOut.decodeTimeStamp.value = v7;
    *(_OWORD *)&timingInfoOut.duration.value = v7;
    *(_OWORD *)&timingInfoOut.duration.epoch = v7;
    CMSampleBufferGetSampleTimingInfo(a1, 0, &timingInfoOut);
    v8 = CMSampleBufferGetFormatDescription(a1);
    presentationTimeStamp = timingInfoOut.presentationTimeStamp;
    if (ImageBuffer)
    {
      v9 = v8;
      v10 = xpc_dictionary_create(0, 0, 0);
      if (v10)
      {
        v4 = v10;
        IOSurface = CVPixelBufferGetIOSurface(ImageBuffer);
        if (IOSurface)
        {
          XPCObject = IOSurfaceCreateXPCObject(IOSurface);
          if (XPCObject)
          {
            v13 = XPCObject;
            xpc_dictionary_set_value(v4, "VCStreamInputPixelBuffer", XPCObject);
            v18 = presentationTimeStamp;
            if (_VCStreamInputUtil_AddTime(v4, &v18))
            {
              if (_VCStreamInputUtil_AddFormatDescription(v4, v9))
              {
LABEL_17:
                CFRelease(v13);
                v14 = _VCStreamInputUtil_EncodeSampleBufferAttachments(a1, v4);
                if (!v4 || v14)
                  return v4;
                goto LABEL_19;
              }
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  VCStreamInputUtil_EncodeSampleBuffer_cold_5();
              }
            }
            else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                VCStreamInputUtil_EncodeSampleBuffer_cold_6();
            }
            CFRelease(v4);
            v4 = 0;
            goto LABEL_17;
          }
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VCStreamInputUtil_EncodeSampleBuffer_cold_4();
          }
        }
        else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCStreamInputUtil_EncodeSampleBuffer_cold_3();
        }
        CFRelease(v4);
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCStreamInputUtil_EncodeSampleBuffer_cold_2();
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCStreamInputUtil_EncodeSampleBuffer_cold_1();
    }
    _VCStreamInputUtil_EncodeSampleBufferAttachments(a1, 0);
    return 0;
  }
  if (MediaType != 1835365473)
  {
    if (MediaType == 1936684398)
    {
      v4 = _VCStreamInputUtil_EncodeDataSampleBuffer(a1);
      if (!v4)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCStreamInputUtil_EncodeSampleBuffer_cold_7();
        }
        goto LABEL_19;
      }
      NumSamples = CMSampleBufferGetNumSamples(a1);
      if (!_VCStreamInputUtil_AddUint32Value(v4, "VCStreamInputFormatSampleCount", NumSamples))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCStreamInputUtil_EncodeSampleBuffer_cold_8();
        }
LABEL_19:
        xpc_release(v4);
        return 0;
      }
    }
    return v4;
  }
  return _VCStreamInputUtil_EncodeDataSampleBuffer(a1);
}

void *_VCStreamInputUtil_EncodeDataSampleBuffer(opaqueCMSampleBuffer *a1)
{
  OpaqueCMBlockBuffer *DataBuffer;
  OpaqueCMBlockBuffer *v3;
  size_t DataLength;
  size_t v5;
  const __CFAllocator *v6;
  UInt8 *v7;
  const UInt8 *v8;
  CFDataRef v9;
  CFDataRef v10;
  CMFormatDescriptionRef FormatDescription;
  const opaqueCMFormatDescription *v12;
  xpc_object_t v13;
  void *v14;
  void *v15;
  void *v16;
  _BOOL4 v17;
  CMTime v19;
  CMTime v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  DataBuffer = CMSampleBufferGetDataBuffer(a1);
  if (!DataBuffer)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCStreamInputUtil_EncodeDataSampleBuffer_cold_1();
    }
    return 0;
  }
  v3 = DataBuffer;
  DataLength = CMBlockBufferGetDataLength(DataBuffer);
  if (!DataLength)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCStreamInputUtil_EncodeDataSampleBuffer_cold_2();
    }
    return 0;
  }
  v5 = DataLength;
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v7 = (UInt8 *)CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], DataLength, 0);
  if (!v7)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCStreamInputUtil_EncodeDataSampleBuffer_cold_3();
    }
    return 0;
  }
  v8 = v7;
  if (CMBlockBufferCopyDataBytes(v3, 0, v5, v7))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCStreamInputUtil_EncodeDataSampleBuffer_cold_10();
    }
    return 0;
  }
  v9 = CFDataCreateWithBytesNoCopy(v6, v8, v5, v6);
  if (!v9)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCStreamInputUtil_EncodeDataSampleBuffer_cold_4();
    }
    return 0;
  }
  v10 = v9;
  FormatDescription = CMSampleBufferGetFormatDescription(a1);
  if (!FormatDescription)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCStreamInputUtil_EncodeDataSampleBuffer_cold_5();
    }
    goto LABEL_37;
  }
  v12 = FormatDescription;
  v13 = xpc_dictionary_create(0, 0, 0);
  if (!v13)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCStreamInputUtil_EncodeDataSampleBuffer_cold_6();
    }
LABEL_37:
    v14 = 0;
    goto LABEL_38;
  }
  v14 = v13;
  memset(&v20, 170, sizeof(v20));
  CMSampleBufferGetPresentationTimeStamp(&v20, a1);
  v19 = v20;
  if (_VCStreamInputUtil_AddTime(v14, &v19))
  {
    if (_VCStreamInputUtil_AddFormatDescription(v14, v12))
    {
      v15 = (void *)_CFXPCCreateXPCObjectFromCFObject();
      if (v15)
      {
        v16 = v15;
        xpc_dictionary_set_value(v14, "VCStreamInputBufferData", v15);
        v17 = !_VCStreamInputUtil_EncodeSampleBufferAttachments(a1, v14);
        CFRelease(v10);
        xpc_release(v16);
        if (!v17)
          return v14;
        goto LABEL_12;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCStreamInputUtil_EncodeDataSampleBuffer_cold_7();
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCStreamInputUtil_EncodeDataSampleBuffer_cold_8();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCStreamInputUtil_EncodeDataSampleBuffer_cold_9();
  }
LABEL_38:
  CFRelease(v10);
LABEL_12:
  if (v14)
  {
    xpc_release(v14);
    return 0;
  }
  return v14;
}

CMAudioFormatDescriptionRef VCStreamInputUtil_DecodeFormatDescription(void *a1)
{
  const __CFDictionary *v2;
  xpc_object_t value;
  __int128 v4;
  OSStatus v5;
  OSStatus v7;
  uint64_t v8;
  NSObject *v9;
  int v10;
  CMVideoCodecType codecType;
  AudioStreamBasicDescription buffer;
  CMAudioFormatDescriptionRef formatDescriptionOut;
  FourCharCode mediaSubType;
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  OSStatus v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v10 = -1431655766;
  if (!_VCStreamInputUtil_ReadUint32Value(a1, "VCStreamInputMediaType", &v10))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCStreamInputUtil_DecodeFormatDescription_cold_10();
    }
    return 0;
  }
  if (v10 == 1835365473)
  {
    mediaSubType = -1431655766;
    buffer.mSampleRate = 0.0;
    if (!_VCStreamInputUtil_ReadUint32Value(a1, "VCStreamInputMediaSubtype", &mediaSubType))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCStreamInputUtil_DecodeFormatDescription_cold_8();
      }
      return *(CMAudioFormatDescriptionRef *)&buffer.mSampleRate;
    }
    if (xpc_dictionary_get_value(a1, "VCStreamInputFormatExtensions"))
    {
      v2 = (const __CFDictionary *)_CFXPCCreateCFObjectFromXPCObject();
      if (!v2)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCStreamInputUtil_DecodeFormatDescription_cold_7();
        }
        return *(CMAudioFormatDescriptionRef *)&buffer.mSampleRate;
      }
    }
    else
    {
      v2 = 0;
    }
    if (CMFormatDescriptionCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0x6D657461u, mediaSubType, v2, (CMFormatDescriptionRef *)&buffer))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCStreamInputUtil_DecodeFormatDescription_cold_6();
      }
    }
    goto LABEL_30;
  }
  if (v10 != 1936684398)
  {
    if (v10 == 1986618469)
    {
      mediaSubType = -1431655766;
      LODWORD(formatDescriptionOut) = -1431655766;
      codecType = -1431655766;
      buffer.mSampleRate = 0.0;
      if (!_VCStreamInputUtil_ReadUint32Value(a1, "VCStreamInputMediaSubtype", &codecType))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCStreamInputUtil_DecodeFormatDescription_cold_5();
        }
        return *(CMAudioFormatDescriptionRef *)&buffer.mSampleRate;
      }
      if (!_VCStreamInputUtil_ReadUint32Value(a1, "VCStreamInputPixelBufferWidth", &mediaSubType))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCStreamInputUtil_DecodeFormatDescription_cold_4();
        }
        return *(CMAudioFormatDescriptionRef *)&buffer.mSampleRate;
      }
      if (!_VCStreamInputUtil_ReadUint32Value(a1, "VCStreamInputPixelBufferHeight", &formatDescriptionOut))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCStreamInputUtil_DecodeFormatDescription_cold_3();
        }
        return *(CMAudioFormatDescriptionRef *)&buffer.mSampleRate;
      }
      if (xpc_dictionary_get_value(a1, "VCStreamInputFormatExtensions"))
      {
        v2 = (const __CFDictionary *)_CFXPCCreateCFObjectFromXPCObject();
        if (!v2)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VCStreamInputUtil_DecodeFormatDescription_cold_2();
          }
          return *(CMAudioFormatDescriptionRef *)&buffer.mSampleRate;
        }
      }
      else
      {
        v2 = 0;
      }
      if (CMVideoFormatDescriptionCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], codecType, mediaSubType, (int32_t)formatDescriptionOut, v2, (CMVideoFormatDescriptionRef *)&buffer))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCStreamInputUtil_DecodeFormatDescription_cold_1();
        }
      }
LABEL_30:
      if (v2)
        CFRelease(v2);
      return *(CMAudioFormatDescriptionRef *)&buffer.mSampleRate;
    }
    return 0;
  }
  formatDescriptionOut = 0;
  value = xpc_dictionary_get_value(a1, "VCStreamInputFormatASBD");
  if (value)
  {
    buffer.mSampleRate = NAN;
    *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&buffer.mFormatID = v4;
    *(_OWORD *)&buffer.mBytesPerFrame = v4;
    if (xpc_data_get_bytes(value, &buffer, 0, 0x28uLL) == 40)
    {
      v5 = CMAudioFormatDescriptionCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], &buffer, 0, 0, 0, 0, 0, &formatDescriptionOut);
      if (v5)
      {
        v7 = v5;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v8 = VRTraceErrorLogLevelToCSTR();
          v9 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            mediaSubType = 136315906;
            v15 = v8;
            v16 = 2080;
            v17 = "_VCStreamInputUtil_DecodeAudioFormat";
            v18 = 1024;
            v19 = 397;
            v20 = 1024;
            v21 = v7;
            _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Failed to create format description from XPC dictionary. status=%d", (uint8_t *)&mediaSubType, 0x22u);
          }
        }
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCStreamInputUtil_DecodeFormatDescription_cold_9();
    }
  }
  return formatDescriptionOut;
}

BOOL _VCStreamInputUtil_ReadUint32Value(void *a1, const char *a2, void *a3)
{
  const __CFNumber *v4;
  const __CFNumber *v5;
  _BOOL8 result;

  if (!xpc_dictionary_get_value(a1, a2))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      _VCStreamInputUtil_ReadUint32Value_cold_1();
    }
    return 0;
  }
  v4 = (const __CFNumber *)_CFXPCCreateCFObjectFromXPCObject();
  if (v4)
  {
    v5 = v4;
    CFNumberGetValue(v4, kCFNumberSInt32Type, a3);
    CFRelease(v5);
    return 1;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() < 3)
    return 0;
  VRTraceErrorLogLevelToCSTR();
  result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
  if (result)
  {
    _VCStreamInputUtil_ReadUint32Value_cold_2();
    return 0;
  }
  return result;
}

CMSampleBufferRef VCStreamInputUtil_DecodeSampleBuffer(void *a1)
{
  CMSampleBufferRef result;
  xpc_object_t value;
  __IOSurface *v4;
  __IOSurface *v5;
  const __CFAllocator *v6;
  CVReturn v7;
  CVReturn v8;
  uint64_t v9;
  NSObject *v10;
  __CVBuffer *v11;
  CMAudioFormatDescriptionRef v12;
  const opaqueCMFormatDescription *v13;
  __int128 v14;
  OSStatus v15;
  const __CFDictionary *v16;
  uint64_t v17;
  NSObject *v18;
  const char *v19;
  NSObject *v20;
  uint32_t v21;
  OSStatus v22;
  uint64_t v23;
  NSObject *v24;
  int v25;
  CMTime v26;
  CMSampleBufferRef sampleBufferOut;
  _BYTE pixelBufferOut[12];
  __int16 v29;
  const char *v30;
  __int16 v31;
  int v32;
  __int16 v33;
  OSStatus v34;
  CMSampleTimingInfo buf;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v25 = 0;
  if (!_VCStreamInputUtil_ReadUint32Value(a1, "VCStreamInputMediaType", &v25))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCStreamInputUtil_DecodeSampleBuffer_cold_6();
    }
    return 0;
  }
  if (v25 > 1952807027)
  {
    if (v25 == 1952807028)
      return (CMSampleBufferRef)_VCStreamInputUtil_DecodeDataSampleBuffer(a1, 1);
    if (v25 != 1986618469)
      goto LABEL_26;
    sampleBufferOut = 0;
    *(_QWORD *)pixelBufferOut = 0;
    value = xpc_dictionary_get_value(a1, "VCStreamInputPixelBuffer");
    v4 = IOSurfaceLookupFromXPCObject(value);
    if (!v4)
      goto LABEL_56;
    v5 = v4;
    v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v7 = CVPixelBufferCreateWithIOSurface((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v4, 0, (CVPixelBufferRef *)pixelBufferOut);
    if (v7)
    {
      v8 = v7;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v9 = VRTraceErrorLogLevelToCSTR();
        v10 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf.duration.value) = 136315906;
          *(CMTimeValue *)((char *)&buf.duration.value + 4) = v9;
          LOWORD(buf.duration.flags) = 2080;
          *(_QWORD *)((char *)&buf.duration.flags + 2) = "_VCStreamInputUtil_DecodePixelBuffer";
          HIWORD(buf.duration.epoch) = 1024;
          LODWORD(buf.presentationTimeStamp.value) = 321;
          WORD2(buf.presentationTimeStamp.value) = 1024;
          *(_DWORD *)((char *)&buf.presentationTimeStamp.value + 6) = v8;
          _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Could not recreate pixel buffer from surface: %d", (uint8_t *)&buf, 0x22u);
        }
      }
    }
    CFRelease(v5);
    v11 = *(__CVBuffer **)pixelBufferOut;
    if (*(_QWORD *)pixelBufferOut)
    {
      v12 = VCStreamInputUtil_DecodeFormatDescription(a1);
      if (v12)
      {
        v13 = v12;
        buf.decodeTimeStamp.epoch = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v14 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)&buf.decodeTimeStamp.value = v14;
        *(_OWORD *)&buf.duration.epoch = v14;
        *(_OWORD *)&buf.presentationTimeStamp.timescale = v14;
        *(_OWORD *)&buf.duration.value = v14;
        memset(&v26, 170, sizeof(v26));
        if (_VCStreamInputUtil_DecodeTime(a1, &v26))
        {
          buf.presentationTimeStamp = v26;
          v15 = CMSampleBufferCreateForImageBuffer(v6, v11, 1u, 0, 0, v13, &buf, &sampleBufferOut);
          if (!v15)
          {
            v16 = (const __CFDictionary *)_VCStreamInputUtil_DecodeSampleBufferAttachments(a1);
            if (v16)
              CMSetAttachments(sampleBufferOut, v16, 1u);
            goto LABEL_23;
          }
          v22 = v15;
          if ((int)VRTraceGetErrorLogLevelForModule() < 7
            || (v23 = VRTraceErrorLogLevelToCSTR(),
                v24 = *MEMORY[0x1E0CF2758],
                !os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT)))
          {
LABEL_53:
            v16 = 0;
LABEL_23:
            CVPixelBufferRelease(v11);
            CFRelease(v13);
            if (v16)
              CFRelease(v16);
            return sampleBufferOut;
          }
          *(_DWORD *)pixelBufferOut = 136315906;
          *(_QWORD *)&pixelBufferOut[4] = v23;
          v29 = 2080;
          v30 = "_VCStreamInputUtil_DecodeVideoSampleBuffer";
          v31 = 1024;
          v32 = 469;
          v33 = 1024;
          v34 = v22;
          v19 = " [%s] %s:%d Could not recreate sample buffer from xpcDictionary. status=%d";
          v20 = v24;
          v21 = 34;
        }
        else
        {
          if ((int)VRTraceGetErrorLogLevelForModule() < 7)
            goto LABEL_53;
          v17 = VRTraceErrorLogLevelToCSTR();
          v18 = *MEMORY[0x1E0CF2758];
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            goto LABEL_53;
          *(_DWORD *)pixelBufferOut = 136315650;
          *(_QWORD *)&pixelBufferOut[4] = v17;
          v29 = 2080;
          v30 = "_VCStreamInputUtil_DecodeVideoSampleBuffer";
          v31 = 1024;
          v32 = 465;
          v19 = " [%s] %s:%d Failed to retrieve the time";
          v20 = v18;
          v21 = 28;
        }
        _os_log_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_DEFAULT, v19, pixelBufferOut, v21);
        goto LABEL_53;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCStreamInputUtil_DecodeSampleBuffer_cold_3();
      }
    }
    else
    {
LABEL_56:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCStreamInputUtil_DecodeSampleBuffer_cold_2();
      }
      v11 = 0;
    }
    CVPixelBufferRelease(v11);
    return sampleBufferOut;
  }
  if (v25 == 1835365473)
    return (CMSampleBufferRef)_VCStreamInputUtil_DecodeDataSampleBuffer(a1, 1);
  if (v25 != 1936684398)
  {
LABEL_26:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCStreamInputUtil_DecodeSampleBuffer_cold_1();
    }
    return 0;
  }
  LODWORD(buf.duration.value) = -1431655766;
  if (!_VCStreamInputUtil_ReadUint32Value(a1, "VCStreamInputFormatSampleCount", &buf))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCStreamInputUtil_DecodeSampleBuffer_cold_5();
    }
    return 0;
  }
  result = (CMSampleBufferRef)_VCStreamInputUtil_DecodeDataSampleBuffer(a1, LODWORD(buf.duration.value));
  if (!result)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCStreamInputUtil_DecodeSampleBuffer_cold_4();
    }
    return 0;
  }
  return result;
}

CMAttachmentBearerRef _VCStreamInputUtil_DecodeDataSampleBuffer(void *a1, CMItemCount a2)
{
  const __CFData *v4;
  const __CFData *v5;
  CFIndex Length;
  CFAllocatorRef *v7;
  const __CFAllocator *v8;
  UInt8 *v9;
  UInt8 *v10;
  OpaqueCMBlockBuffer *v11;
  CMAudioFormatDescriptionRef v12;
  const opaqueCMFormatDescription *v13;
  __int128 v14;
  OSStatus v15;
  const __CFDictionary *v16;
  OpaqueCMBlockBuffer *v17;
  OSStatus v19;
  uint64_t v20;
  NSObject *v21;
  CMSampleTimingInfo sampleTimingArray;
  CMTime v23;
  CMAttachmentBearerRef target;
  _BYTE blockBufferOut[12];
  __int16 v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  OSStatus v31;
  uint64_t v32;
  CFRange v33;

  v32 = *MEMORY[0x1E0C80C00];
  target = 0;
  *(_QWORD *)blockBufferOut = 0;
  if (!xpc_dictionary_get_value(a1, "VCStreamInputBufferData"))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCStreamInputUtil_DecodeDataSampleBuffer_cold_2();
    }
    goto LABEL_22;
  }
  v4 = (const __CFData *)_CFXPCCreateCFObjectFromXPCObject();
  if (!v4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCStreamInputUtil_DecodeDataSampleBuffer_cold_3();
    }
    goto LABEL_22;
  }
  v5 = v4;
  Length = CFDataGetLength(v4);
  v7 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  if (Length <= 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCStreamInputUtil_DecodeDataSampleBuffer_cold_6();
    }
  }
  else
  {
    v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v9 = (UInt8 *)CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], Length, 0);
    if (v9)
    {
      v10 = v9;
      v33.length = CFDataGetLength(v5);
      v33.location = 0;
      CFDataGetBytes(v5, v33, v10);
      if (CMBlockBufferCreateWithMemoryBlock(v8, v10, Length, v8, 0, 0, Length, 0, (CMBlockBufferRef *)blockBufferOut))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VCStreamInputUtil_DecodeDataSampleBuffer_cold_8();
        }
        CFAllocatorDeallocate(v8, v10);
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCStreamInputUtil_DecodeDataSampleBuffer_cold_7();
    }
  }
  CFRelease(v5);
  v11 = *(OpaqueCMBlockBuffer **)blockBufferOut;
  if (!*(_QWORD *)blockBufferOut)
  {
LABEL_22:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCStreamInputUtil_DecodeDataSampleBuffer_cold_1();
    }
    return target;
  }
  v12 = VCStreamInputUtil_DecodeFormatDescription(a1);
  if (!v12)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCStreamInputUtil_DecodeDataSampleBuffer_cold_4();
    }
    v17 = v11;
    goto LABEL_14;
  }
  v13 = v12;
  memset(&v23, 170, sizeof(v23));
  if (!_VCStreamInputUtil_DecodeTime(a1, &v23))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCStreamInputUtil_DecodeDataSampleBuffer_cold_5();
    }
    goto LABEL_45;
  }
  *(_QWORD *)&v14 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&sampleTimingArray.decodeTimeStamp.value = v14;
  *(_OWORD *)&sampleTimingArray.duration.value = v14;
  sampleTimingArray.duration.epoch = 0xAAAAAAAAAAAAAAAALL;
  sampleTimingArray.presentationTimeStamp = v23;
  sampleTimingArray.decodeTimeStamp.epoch = 0xAAAAAAAAAAAAAAAALL;
  v15 = CMSampleBufferCreate(*v7, v11, 1u, 0, 0, v13, a2, 1, &sampleTimingArray, 0, 0, (CMSampleBufferRef *)&target);
  if (v15)
  {
    v19 = v15;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v20 = VRTraceErrorLogLevelToCSTR();
      v21 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)blockBufferOut = 136315906;
        *(_QWORD *)&blockBufferOut[4] = v20;
        v26 = 2080;
        v27 = "_VCStreamInputUtil_DecodeDataSampleBuffer";
        v28 = 1024;
        v29 = 502;
        v30 = 1024;
        v31 = v19;
        _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Could not recreate sample buffer from xpcDictionary: %d", blockBufferOut, 0x22u);
      }
    }
LABEL_45:
    v16 = 0;
    goto LABEL_12;
  }
  v16 = (const __CFDictionary *)_VCStreamInputUtil_DecodeSampleBufferAttachments(a1);
  if (v16)
    CMSetAttachments(target, v16, 1u);
LABEL_12:
  CFRelease(v11);
  CFRelease(v13);
  if (v16)
  {
    v17 = v16;
LABEL_14:
    CFRelease(v17);
  }
  return target;
}

BOOL _VCStreamInputUtil_AddUint32Value(void *a1, const char *a2, int a3)
{
  CFNumberRef v5;
  CFNumberRef v6;
  void *v7;
  _BOOL8 v8;
  void *v9;
  int valuePtr;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  valuePtr = a3;
  v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &valuePtr);
  if (v5)
  {
    v6 = v5;
    v7 = (void *)_CFXPCCreateXPCObjectFromCFObject();
    v8 = v7 != 0;
    if (v7)
    {
      v9 = v7;
      xpc_dictionary_set_value(a1, a2, v7);
      xpc_release(v9);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCStreamInputUtil_AddUint32Value_cold_2();
    }
    CFRelease(v6);
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCStreamInputUtil_AddUint32Value_cold_1();
    }
    return 0;
  }
  return v8;
}

BOOL _VCStreamInputUtil_EncodeSampleBufferAttachments(CMAttachmentBearerRef target, void *a2)
{
  _BOOL8 v3;
  CFDictionaryRef v4;
  CFDictionaryRef v5;
  void *v6;
  void *v7;

  v3 = 1;
  v4 = CMCopyDictionaryOfAttachments((CFAllocatorRef)*MEMORY[0x1E0C9AE00], target, 1u);
  if (v4)
  {
    v5 = v4;
    v6 = (void *)_CFXPCCreateXPCObjectFromCFObject();
    v3 = v6 != 0;
    if (v6)
    {
      v7 = v6;
      xpc_dictionary_set_value(a2, "VCStreamInputSampleBufferAttachments", v6);
      xpc_release(v7);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCStreamInputUtil_EncodeSampleBufferAttachments_cold_1();
    }
    CFRelease(v5);
  }
  return v3;
}

BOOL _VCStreamInputUtil_AddTime(void *a1, CMTime *a2)
{
  const __CFAllocator *v3;
  CFDictionaryRef v4;
  CFDictionaryRef v5;
  void *v6;
  _BOOL8 v7;
  void *v8;
  CMTime v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v10 = *a2;
  v4 = CMTimeCopyAsDictionary(&v10, v3);
  if (v4)
  {
    v5 = v4;
    v6 = (void *)_CFXPCCreateXPCObjectFromCFObject();
    v7 = v6 != 0;
    if (v6)
    {
      v8 = v6;
      xpc_dictionary_set_value(a1, "VCStreamInputPresentationTime", v6);
      xpc_release(v8);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCStreamInputUtil_AddTime_cold_2();
    }
    CFRelease(v5);
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCStreamInputUtil_AddTime_cold_1();
    }
    return 0;
  }
  return v7;
}

BOOL _VCStreamInputUtil_DecodeTime(void *a1, CMTime *a2)
{
  const __CFDictionary *v3;
  const __CFDictionary *v4;
  uint64_t v5;
  NSObject *v6;
  CMTime v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  xpc_dictionary_get_value(a1, "VCStreamInputPresentationTime");
  v3 = (const __CFDictionary *)_CFXPCCreateCFObjectFromXPCObject();
  v4 = v3;
  if (v3)
  {
    CMTimeMakeFromDictionary(&v8, v3);
    *a2 = v8;
    CFRelease(v4);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v5 = VRTraceErrorLogLevelToCSTR();
    v6 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v8.value) = 136315650;
      *(CMTimeValue *)((char *)&v8.value + 4) = v5;
      LOWORD(v8.flags) = 2080;
      *(_QWORD *)((char *)&v8.flags + 2) = "_VCStreamInputUtil_DecodeTime";
      HIWORD(v8.epoch) = 1024;
      v9 = 333;
      _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Could not retrieve the time information", (uint8_t *)&v8, 0x1Cu);
    }
  }
  return v4 != 0;
}

uint64_t _VCStreamInputUtil_DecodeSampleBufferAttachments(void *a1)
{
  uint64_t result;

  result = (uint64_t)xpc_dictionary_get_value(a1, "VCStreamInputSampleBufferAttachments");
  if (result)
  {
    result = _CFXPCCreateCFObjectFromXPCObject();
    if (!result)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCStreamInputUtil_DecodeSampleBufferAttachments_cold_1();
      }
      return 0;
    }
  }
  return result;
}

void _VCRateControlBandwidthEstimator_UpdateQualificationParameters(uint64_t a1)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  int v29;
  __int16 v30;
  int v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v2 = *(_DWORD *)(a1 + 396);
  if ((*(_DWORD *)(a1 + 392) - 5) > 1)
  {
    if ((v2 - 3) > 6)
      v5 = 0x4158CBA800000000;
    else
      v5 = qword_1D910F888[v2 - 3];
    *(_QWORD *)(a1 + 360) = v5;
    *(_QWORD *)(a1 + 352) = 0x3F80624DD2F1A9FCLL;
    if (*(_BYTE *)(a1 + 404))
      v3 = 0;
    else
      v3 = 3;
  }
  else
  {
    v3 = 0;
    if (v2 == 3)
      v4 = 800000;
    else
      v4 = 400000;
    *(double *)(a1 + 360) = (double)v4;
    *(_QWORD *)(a1 + 352) = 0x3F60624DD2F1A9FCLL;
  }
  *(_DWORD *)(a1 + 368) = v3;
  *(_DWORD *)(a1 + 344) = 1;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v6 = VRTraceErrorLogLevelToCSTR();
    v7 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v8 = *(_DWORD *)(a1 + 392);
      v9 = *(_DWORD *)(a1 + 396);
      v11 = *(_QWORD *)(a1 + 352);
      v10 = *(_QWORD *)(a1 + 360);
      v12 = *(_DWORD *)(a1 + 368);
      v13 = *(_DWORD *)(a1 + 344);
      v14 = 136317186;
      v15 = v6;
      v16 = 2080;
      v17 = "_VCRateControlBandwidthEstimator_UpdateQualificationParameters";
      v18 = 1024;
      v19 = 308;
      v20 = 1024;
      v21 = v8;
      v22 = 1024;
      v23 = v9;
      v24 = 2048;
      v25 = v10;
      v26 = 2048;
      v27 = v11;
      v28 = 1024;
      v29 = v12;
      v30 = 1024;
      v31 = v13;
      _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Bandwidth Estimation: Update bandwidth estimator qualification parameters with RAT=%d, mode=%d. [maxBW:%f, minWin:%f, maxOverRange:%d, minPacketCount:%d]", (uint8_t *)&v14, 0x48u);
    }
  }
}

void VCRateControlBandwidthEstimator_SetRadioAccessTechnology(uint64_t a1, int a2)
{
  if (a1)
  {
    *(_DWORD *)(a1 + 392) = a2;
    _VCRateControlBandwidthEstimator_UpdateQualificationParameters(a1);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlBandwidthEstimator_SetRadioAccessTechnology_cold_1();
  }
}

void VCRateControlBandwidthEstimator_SetEstimatedBandwidth(uint64_t a1, double a2)
{
  if (a1)
  {
    *(double *)(a1 + 376) = a2;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlBandwidthEstimator_SetEstimatedBandwidth_cold_1();
  }
}

void VCRateControlBandwidthEstimator_SetFastSuddenBandwidthDetectionEnabled(uint64_t a1, char a2)
{
  if (a1)
  {
    *(_BYTE *)(a1 + 404) = a2;
    _VCRateControlBandwidthEstimator_UpdateQualificationParameters(a1);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlBandwidthEstimator_SetFastSuddenBandwidthDetectionEnabled_cold_1();
  }
}

void VCRateControlBandwidthEstimator_CalculateBandwidthEstimation(uint64_t a1, int a2, unsigned int a3, int a4, int a5, double a6)
{
  int v11;
  double v12;
  int32x2_t v13;
  unsigned int v14;
  unsigned int v15;
  double v16;
  double v17;
  int v18;
  double v19;
  BOOL v20;
  int32x2_t v21;
  int ErrorLogLevelForModule;
  uint64_t v23;
  NSObject *v24;
  int v25;
  int v26;
  double v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  uint8_t buf[4];
  uint64_t v36;
  __int16 v37;
  const char *v38;
  __int16 v39;
  int v40;
  __int16 v41;
  int v42;
  __int16 v43;
  int v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (*(_BYTE *)(a1 + 52))
    {
      if (!a4)
        goto LABEL_18;
    }
    else
    {
      *(_WORD *)(a1 + 52) = 1;
      v11 = a5 - 1;
      if (!a4)
        v11 = a2;
      *(_DWORD *)(a1 + 60) = v11;
      *(double *)(a1 + 64) = a6;
      *(_QWORD *)(a1 + 72) = 0;
      if (!a4)
        goto LABEL_18;
    }
    if (*(_DWORD *)(a1 + 60) == a5)
    {
      if (*(double *)(a1 + 16) <= a6)
        v12 = a6;
      else
        v12 = *(double *)(a1 + 16);
      v13 = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)(a3 | 0x100000000));
      *(int32x2_t *)(a1 + 8) = v13;
      *(double *)(a1 + 16) = v12;
      if (!a5)
      {
        v14 = 0;
        v15 = 0;
        v16 = 0.0;
        v17 = 0.0;
        goto LABEL_36;
      }
      if (v13.i32[0])
        goto LABEL_43;
      v14 = 0;
      v15 = 0;
      v16 = 0.0;
      v17 = 0.0;
      goto LABEL_29;
    }
LABEL_18:
    v14 = *(_DWORD *)(a1 + 8);
    if (v14 <= *(_DWORD *)(a1 + 416))
    {
      v15 = 0;
      v14 = 0;
      v17 = 0.0;
      v16 = 0.0;
    }
    else
    {
      v15 = *(_DWORD *)(a1 + 12);
      v16 = *(double *)(a1 + 16) - *(double *)(a1 + 24);
      v17 = (double)(8 * v14) / v16;
    }
    v18 = a5;
    if ((a4 & 1) == 0)
    {
      v19 = *(double *)(a1 + 32);
      v20 = v19 <= 0.0 || v19 <= a6;
      v18 = a2;
      if (!v20)
      {
        ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
        if (ErrorLogLevelForModule >= 7)
        {
          v23 = VRTraceErrorLogLevelToCSTR();
          v24 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v26 = *(_DWORD *)(a1 + 40);
            v25 = *(_DWORD *)(a1 + 44);
            *(_DWORD *)buf = 136316162;
            v36 = v23;
            v37 = 2080;
            v38 = "VCRateControlBandwidthEstimator_CalculateBandwidthEstimation";
            v39 = 1024;
            v40 = 222;
            v41 = 1024;
            v42 = v25;
            v43 = 1024;
            v44 = v26;
            _os_log_impl(&dword_1D8A54000, v24, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Probing sequence head is late, early probing sequence packet number: %d, bytes:%d", buf, 0x28u);
          }
        }
        *(_QWORD *)(a1 + 8) = *(_QWORD *)(a1 + 40);
        *(_DWORD *)(a1 + 60) = a2;
        *(double *)(a1 + 24) = a6;
        *(_DWORD *)(a1 + 48) = a3;
        *(_QWORD *)(a1 + 16) = 0;
        if (a5)
        {
LABEL_37:
          if (v17 > 0.0)
          {
            *(double *)(a1 + 384) = v17;
            if (*(double *)(a1 + 376) != 0.0)
            {
              v27 = 0.0;
              if (*(_DWORD *)(a1 + 344) > v15 || *(_DWORD *)(a1 + 416) > v14)
                goto LABEL_42;
              if (*(double *)(a1 + 352) <= v16)
              {
                *(_DWORD *)(a1 + 320) = 0;
              }
              else
              {
                v34 = *(_DWORD *)(a1 + 320) + 1;
                *(_DWORD *)(a1 + 320) = v34;
                if (v34 < *(_DWORD *)(a1 + 368))
                  goto LABEL_42;
              }
            }
            v27 = v17;
LABEL_42:
            _VCRateControlBandwidthEstimator_UpdateBandwidthEstimation(a1, v27, a6);
            VRLogfilePrintWithTimestamp(*(_QWORD *)(a1 + 424), "Bandwidth Estimation: ArrivalTime:%.4f, timestamp:%u, BWD:%.2f, state:%d, divergeCount:%d, prob_seq:[duration:%.4f, size:%d, count:%d], EstimatedBandwidth:%.2f\n", v28, v29, v30, v31, v32, v33, SLOBYTE(a6));
          }
LABEL_43:
          *(_DWORD *)(a1 + 56) = a2;
          return;
        }
LABEL_36:
        *(_QWORD *)(a1 + 32) = 0;
        *(_QWORD *)(a1 + 40) = 0;
        goto LABEL_37;
      }
    }
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 60) = v18;
    *(double *)(a1 + 24) = a6;
    *(_DWORD *)(a1 + 48) = a3;
    if (!a5)
      goto LABEL_36;
    if ((a4 & 1) == 0)
      goto LABEL_37;
LABEL_29:
    v21 = vadd_s32(*(int32x2_t *)(a1 + 40), (int32x2_t)(a3 | 0x100000000));
    *(double *)(a1 + 32) = a6;
    *(int32x2_t *)(a1 + 40) = v21;
    goto LABEL_37;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlBandwidthEstimator_CalculateBandwidthEstimation_cold_1();
  }
}

double _VCRateControlBandwidthEstimator_UpdateBandwidthEstimation(uint64_t a1, double a2, double a3)
{
  double v3;
  double v6;
  unsigned int v7;
  int v8;
  double v9;
  double v10;
  int v11;
  double v13;
  double v14;
  double v15;
  _BOOL4 v16;
  double v17;
  double v18;
  double v19;
  _BOOL4 v20;
  _BOOL4 v21;
  double v22;
  unsigned int IntValueForKey;
  unsigned int v24;
  uint64_t v25;
  NSObject *v26;
  uint64_t v27;
  _BOOL4 v28;
  unsigned int v29;
  double v30;
  void *v31;
  double v32;
  double v33;
  int v34;
  double v35;
  uint64_t v36;
  double *v37;
  double v38;
  double v39;
  double v40;
  int v41;
  int v42;
  int v43;
  int v44;
  double v45;
  int v46;
  uint64_t v47;
  __int16 v48;
  const char *v49;
  __int16 v50;
  int v51;
  __int16 v52;
  unsigned int v53;
  uint64_t v54;

  v3 = a2;
  v54 = *MEMORY[0x1E0C80C00];
  if (a2 <= 0.0)
  {
    v11 = 6;
    goto LABEL_9;
  }
  v6 = *(double *)(a1 + 360);
  if (v6 <= v3)
    v3 = *(double *)(a1 + 360);
  v7 = *(_DWORD *)(a1 + 392) - 5;
  if (v7 > 1 || *(_BYTE *)(a1 + 53))
  {
    objc_msgSend(*(id *)(a1 + 336), "setMargin:", 200000);
    objc_msgSend(*(id *)(a1 + 336), "setMinSamplesCount:", 3);
    objc_msgSend(*(id *)(a1 + 336), "setMinMarginRequired:", 0);
    objc_msgSend(*(id *)(a1 + 336), "setDurationThresholdUpward:", 0.0);
    objc_msgSend(*(id *)(a1 + 336), "setDurationThresholdDownward:", 0.0);
    v8 = *(_DWORD *)(a1 + 392);
    if ((v8 - 5) >= 2)
    {
      if (v8 != 1)
        goto LABEL_14;
      objc_msgSend(*(id *)(a1 + 336), "setMinSamplesCount:", 4);
      v10 = 4.0;
      v9 = 4.0;
    }
    else
    {
      objc_msgSend(*(id *)(a1 + 336), "setMinSamplesCount:", 6);
      objc_msgSend(*(id *)(a1 + 336), "setMinMarginRequired:", 100000);
      v9 = 7.0;
      v10 = 10.0;
    }
    objc_msgSend(*(id *)(a1 + 336), "setDurationThresholdUpward:", v10);
    objc_msgSend(*(id *)(a1 + 336), "setDurationThresholdDownward:", v9);
LABEL_14:
    objc_msgSend(*(id *)(a1 + 336), "percentage");
    v14 = 1.0 - v13;
    v15 = *(double *)(a1 + 376);
    v16 = v14 * v15 >= v3 || v15 - v3 > (double)(int)objc_msgSend(*(id *)(a1 + 336), "margin");
    objc_msgSend(*(id *)(a1 + 336), "percentage");
    v18 = v17 + 1.0;
    v19 = *(double *)(a1 + 376);
    if (v18 * v19 <= v3)
    {
      v20 = 1;
      if (!v16)
        goto LABEL_22;
    }
    else
    {
      v20 = v3 - v19 > (double)(int)objc_msgSend(*(id *)(a1 + 336), "margin");
      v19 = *(double *)(a1 + 376);
      if (!v16)
      {
LABEL_22:
        if (v20)
        {
          v21 = v3 - v19 > (double)(int)objc_msgSend(*(id *)(a1 + 336), "minMarginRequired");
          v19 = *(double *)(a1 + 376);
        }
        else
        {
          v21 = 0;
        }
        if (v19 == 0.0)
        {
          v22 = 100000.0;
          if (v3 >= 100000.0)
            v22 = v3;
          *(double *)(a1 + 376) = v22;
          *(_DWORD *)(a1 + 400) = 0;
          IntValueForKey = VCDefaults_GetIntValueForKey(CFSTR("forcedInitialBandwidthEstimation"), 0);
          if (IntValueForKey)
          {
            v24 = IntValueForKey;
            *(double *)(a1 + 376) = (double)IntValueForKey;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v25 = VRTraceErrorLogLevelToCSTR();
              v26 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                v46 = 136315906;
                v47 = v25;
                v48 = 2080;
                v49 = "_VCRateControlBandwidthEstimator_UpdateBandwidthEstimation";
                v50 = 1024;
                v51 = 357;
                v52 = 1024;
                v53 = v24;
                _os_log_impl(&dword_1D8A54000, v26, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Forced initial bandwidth estimation:%d by default", (uint8_t *)&v46, 0x22u);
              }
            }
          }
          return v3;
        }
        if (!v21 && !v16)
        {
          if (v7 > 1)
          {
            v39 = v3 * 0.1;
            v40 = 0.9;
          }
          else
          {
            v36 = *(unsigned int *)(a1 + 76);
            if ((int)v36 >= 1)
            {
              v37 = (double *)(a1 + 80);
              do
              {
                v38 = *v37++;
                v19 = v38 * 0.05 + v19 * 0.95;
                *(double *)(a1 + 376) = v19;
                --v36;
              }
              while (v36);
            }
            *(_DWORD *)(a1 + 76) = 0;
            v39 = v3 * 0.075;
            v40 = 0.925;
          }
          *(double *)(a1 + 376) = v39 + v19 * v40;
          *(_DWORD *)(a1 + 72) = 0;
          *(_QWORD *)(a1 + 328) = 0;
          v11 = 1;
          goto LABEL_9;
        }
        if (v7 <= 1)
        {
          v27 = *(int *)(a1 + 76);
          if ((int)v27 <= 29)
          {
            *(double *)(a1 + 8 * v27 + 80) = v3;
            *(_DWORD *)(a1 + 76) = v27 + 1;
          }
        }
        v28 = 0;
        v29 = *(_DWORD *)(a1 + 392);
        if (v29 <= 6 && ((1 << v29) & 0x62) != 0)
        {
          v30 = a3 - *(double *)(a1 + 64);
          v31 = *(void **)(a1 + 336);
          if ((*(_DWORD *)(a1 + 72) & 0x80000000) != 0)
            objc_msgSend(v31, "durationThresholdDownward");
          else
            objc_msgSend(v31, "durationThresholdUpward");
          v28 = v30 < v32;
        }
        v41 = *(_DWORD *)(a1 + 72);
        if (v16)
        {
          if (v41 < 0)
          {
            --v41;
            v42 = 3;
          }
          else
          {
            *(_QWORD *)(a1 + 328) = 0;
            *(double *)(a1 + 64) = a3;
            v42 = 3;
            v41 = -1;
          }
        }
        else
        {
          if (!v21)
          {
LABEL_64:
            *(double *)(a1 + 328) = v3 + *(double *)(a1 + 328);
            if (v41 >= 0)
              v43 = v41;
            else
              v43 = -v41;
            v44 = v43 < (int)objc_msgSend(*(id *)(a1 + 336), "minSamplesCount") || v28;
            if (v44 == 1
              && (!*(_BYTE *)(a1 + 404)
               || v43 < (int)objc_msgSend(*(id *)(a1 + 336), "minSamplesCountFastBandwidthEstimation")))
            {
              return v3;
            }
            v45 = *(double *)(a1 + 328) / (double)v43;
            if (v7 <= 1 && (*(_DWORD *)(a1 + 72) & 0x80000000) == 0)
              v45 = v45 * 0.9 + *(double *)(a1 + 376) * 0.1;
            *(double *)(a1 + 376) = v45;
            *(_DWORD *)(a1 + 72) = 0;
            *(_QWORD *)(a1 + 328) = 0;
            v11 = 4;
LABEL_9:
            *(_DWORD *)(a1 + 400) = v11;
            return v3;
          }
          if (v41 <= 0)
          {
            *(_QWORD *)(a1 + 328) = 0;
            *(double *)(a1 + 64) = a3;
            v42 = 2;
            v41 = 1;
          }
          else
          {
            ++v41;
            v42 = 2;
          }
        }
        *(_DWORD *)(a1 + 72) = v41;
        *(_DWORD *)(a1 + 400) = v42;
        goto LABEL_64;
      }
    }
    v16 = v19 - v3 > (double)(int)objc_msgSend(*(id *)(a1 + 336), "minMarginRequired");
    v19 = *(double *)(a1 + 376);
    goto LABEL_22;
  }
  v33 = v6 * 0.5;
  if (v33 > v3)
    v33 = v3;
  v34 = *(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 72) = v34 + 1;
  v35 = v33 + *(double *)(a1 + 328);
  *(double *)(a1 + 328) = v35;
  if (v34 > 8 || a3 - *(double *)(a1 + 64) >= 7.0)
  {
    *(_BYTE *)(a1 + 53) = 1;
    *(double *)(a1 + 376) = v35 / (double)(v34 + 1);
    *(_QWORD *)(a1 + 64) = 0;
    *(_DWORD *)(a1 + 72) = 0;
  }
  *(_DWORD *)(a1 + 400) = 0;
  return v3;
}

void VCRateControlBandwidthEstimator_CalculateBandwidthEstimationForBandwidthSample(uint64_t a1, double a2, double a3)
{
  double updated;
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  int v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  double v22;
  __int16 v23;
  double v24;
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;
  __int16 v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a2 > 0.0)
    {
      *(double *)(a1 + 384) = a2;
      updated = _VCRateControlBandwidthEstimator_UpdateBandwidthEstimation(a1, a2, a3);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v6 = VRTraceErrorLogLevelToCSTR();
        v7 = *MEMORY[0x1E0CF2758];
        v8 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
          {
            v9 = *(_DWORD *)(a1 + 400);
            v10 = *(_DWORD *)(a1 + 72);
            v11 = *(_QWORD *)(a1 + 376);
            v15 = 136316930;
            v16 = v6;
            v17 = 2080;
            v18 = "VCRateControlBandwidthEstimator_CalculateBandwidthEstimationForBandwidthSample";
            v19 = 1024;
            v20 = 271;
            v21 = 2048;
            v22 = updated;
            v23 = 2048;
            v24 = a3;
            v25 = 1024;
            v26 = v9;
            v27 = 1024;
            v28 = v10;
            v29 = 2048;
            v30 = v11;
            _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Bandwidth Estimation(BWD:%.2f): ArrivalTime:%.4f, state:%d, divergeCount:%d, EstimatedBandwidth:%.2f", (uint8_t *)&v15, 0x46u);
          }
        }
        else if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        {
          v12 = *(_DWORD *)(a1 + 400);
          v13 = *(_DWORD *)(a1 + 72);
          v14 = *(_QWORD *)(a1 + 376);
          v15 = 136316930;
          v16 = v6;
          v17 = 2080;
          v18 = "VCRateControlBandwidthEstimator_CalculateBandwidthEstimationForBandwidthSample";
          v19 = 1024;
          v20 = 271;
          v21 = 2048;
          v22 = updated;
          v23 = 2048;
          v24 = a3;
          v25 = 1024;
          v26 = v12;
          v27 = 1024;
          v28 = v13;
          v29 = 2048;
          v30 = v14;
          _os_log_debug_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEBUG, "VCRC [%s] %s:%d Bandwidth Estimation(BWD:%.2f): ArrivalTime:%.4f, state:%d, divergeCount:%d, EstimatedBandwidth:%.2f", (uint8_t *)&v15, 0x46u);
        }
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlBandwidthEstimator_CalculateBandwidthEstimationForBandwidthSample_cold_1();
  }
}

uint64_t VCRateControlBandwidthEstimatorMap_BandwidthEstimator(uint64_t a1, uint64_t a2, int a3, int a4)
{
  VCRateControlBandwidthEstimator *v5;
  BOOL v6;
  int v7;
  int v8;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  int v13;
  uint64_t v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCRateControlBandwidthEstimatorMap_BandwidthEstimator_cold_1();
    }
    return 0;
  }
  v5 = *(VCRateControlBandwidthEstimator **)(a1 + 56);
  if (v5)
    v6 = (*(_DWORD *)(a1 + 12) - 6) >= 0xFFFFFFFE;
  else
    v6 = 1;
  if (!v6)
    return (uint64_t)v5;
  v7 = a2;
  v8 = *(_DWORD *)(a1 + 8);
  if (v8 == 2)
  {
    v5 = 0;
    if ((a3 ^ 1 | a4) != 1 || *(_DWORD *)(a1 + 48) != (_DWORD)a2)
      return (uint64_t)v5;
    goto LABEL_23;
  }
  if (v8 != 1)
  {
    if (!v8 && a3)
    {
      *(_DWORD *)(a1 + 8) = 1;
      *(_DWORD *)(a1 + 48) = a2;
    }
    goto LABEL_24;
  }
  if (*(_DWORD *)(a1 + 48) != (_DWORD)a2)
  {
    v5 = 0;
    *(_DWORD *)(a1 + 8) = 2;
    return (uint64_t)v5;
  }
  if (!a3 || a4)
LABEL_23:
    *(_DWORD *)(a1 + 8) = 0;
LABEL_24:
  v10 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", a2);
  if (!objc_msgSend(*(id *)(a1 + 40), "objectForKeyedSubscript:", v10))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v11 = VRTraceErrorLogLevelToCSTR();
      v12 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v13 = 136315906;
        v14 = v11;
        v15 = 2080;
        v16 = "VCRateControlBandwidthEstimatorMap_BandwidthEstimator";
        v17 = 1024;
        v18 = 586;
        v19 = 1024;
        v20 = v7;
        _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Create bandwidth estimator for estimator id: %d", (uint8_t *)&v13, 0x22u);
      }
    }
    v5 = objc_alloc_init(VCRateControlBandwidthEstimator);
    -[VCRateControlBandwidthEstimator setMode:](v5, "setMode:", *(unsigned int *)(a1 + 12));
    VCRateControlBandwidthEstimator_SetRadioAccessTechnology((uint64_t)v5, *(_DWORD *)(a1 + 16));
    VCRateControlBandwidthEstimator_SetFastSuddenBandwidthDetectionEnabled((uint64_t)v5, *(_BYTE *)(a1 + 68));
    -[VCRateControlBandwidthEstimator setServerBag:](v5, "setServerBag:", *(_QWORD *)(a1 + 72));
    if (*(_QWORD *)(a1 + 80))
      -[VCRateControlBandwidthEstimator enableBWELogDump:](v5, "enableBWELogDump:");
    objc_msgSend(*(id *)(a1 + 40), "setObject:forKeyedSubscript:", v5, v10);
    if (!*(_QWORD *)(a1 + 56))
      *(_QWORD *)(a1 + 56) = v5;

    return (uint64_t)v5;
  }
  return objc_msgSend(*(id *)(a1 + 40), "objectForKeyedSubscript:", v10);
}

void VCRateControlBandwidthEstimatorMap_DeregisterBandwidthEstimator(uint64_t a1, uint64_t a2)
{
  int ErrorLogLevelForModule;
  uint64_t v5;
  NSObject *v6;
  int v7;
  uint64_t v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (a1)
  {
    if (ErrorLogLevelForModule >= 7)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v6 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v7 = 136315906;
        v8 = v5;
        v9 = 2080;
        v10 = "VCRateControlBandwidthEstimatorMap_DeregisterBandwidthEstimator";
        v11 = 1024;
        v12 = 608;
        v13 = 1024;
        v14 = a2;
        _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Remove bandwidth estimator for estimator id: %d", (uint8_t *)&v7, 0x22u);
      }
    }
    if (*(_DWORD *)(a1 + 48) == (_DWORD)a2)
      *(_DWORD *)(a1 + 8) = 0;
    objc_msgSend(*(id *)(a1 + 40), "removeObjectForKey:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", a2));
  }
  else if (ErrorLogLevelForModule >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlBandwidthEstimatorMap_DeregisterBandwidthEstimator_cold_1();
  }
}

void VCRateControlBandwidthEstimatorMap_EstimatedBandwidthWithArrivalTime(uint64_t a1, double a2)
{
  void *v3;
  BOOL v4;
  void *v5;
  _QWORD v6[7];

  v6[6] = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v3 = *(void **)(a1 + 56);
    if (v3)
      v4 = (*(_DWORD *)(a1 + 12) - 6) > 0xFFFFFFFD;
    else
      v4 = 1;
    if (v4)
    {
      *(_QWORD *)(a1 + 24) = 0;
      v5 = *(void **)(a1 + 40);
      v6[0] = MEMORY[0x1E0C809B0];
      v6[1] = 3221225472;
      v6[2] = __VCRateControlBandwidthEstimatorMap_EstimatedBandwidthWithArrivalTime_block_invoke;
      v6[3] = &unk_1E9E57A58;
      *(double *)&v6[5] = a2;
      v6[4] = a1;
      objc_msgSend(v5, "enumerateKeysAndObjectsUsingBlock:", v6);
    }
    else
    {
      objc_msgSend(v3, "estimatedBandwidth");
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlBandwidthEstimatorMap_EstimatedBandwidthWithArrivalTime_cold_1();
  }
}

void VCRateControlBandwidthEstimatorMap_EstimatedBandwidthUncappedWithArrivalTime(uint64_t a1, double a2)
{
  void *v3;
  BOOL v4;
  void *v5;
  _QWORD v6[7];

  v6[6] = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v3 = *(void **)(a1 + 56);
    if (v3)
      v4 = (*(_DWORD *)(a1 + 12) - 6) > 0xFFFFFFFD;
    else
      v4 = 1;
    if (v4)
    {
      *(_QWORD *)(a1 + 32) = 0;
      v5 = *(void **)(a1 + 40);
      v6[0] = MEMORY[0x1E0C809B0];
      v6[1] = 3221225472;
      v6[2] = __VCRateControlBandwidthEstimatorMap_EstimatedBandwidthUncappedWithArrivalTime_block_invoke;
      v6[3] = &unk_1E9E57A58;
      *(double *)&v6[5] = a2;
      v6[4] = a1;
      objc_msgSend(v5, "enumerateKeysAndObjectsUsingBlock:", v6);
    }
    else
    {
      objc_msgSend(v3, "estimatedBandwidthUncapped");
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlBandwidthEstimatorMap_EstimatedBandwidthUncappedWithArrivalTime_cold_1();
  }
}

void VCRateControlBandwidthEstimatorMap_SetEstimatedBandwidth(uint64_t a1, double a2)
{
  BOOL v2;
  void *v3;
  _QWORD v4[6];

  v4[5] = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    *(double *)(a1 + 24) = a2;
    if (*(_QWORD *)(a1 + 56))
      v2 = (*(_DWORD *)(a1 + 12) - 6) > 0xFFFFFFFD;
    else
      v2 = 1;
    if (v2)
    {
      v3 = *(void **)(a1 + 40);
      v4[0] = MEMORY[0x1E0C809B0];
      v4[1] = 3221225472;
      v4[2] = __VCRateControlBandwidthEstimatorMap_SetEstimatedBandwidth_block_invoke;
      v4[3] = &__block_descriptor_40_e58_v32__0__NSNumber_8__VCRateControlBandwidthEstimator_16_B24l;
      *(double *)&v4[4] = a2;
      objc_msgSend(v3, "enumerateKeysAndObjectsUsingBlock:", v4);
    }
    else
    {
      objc_msgSend(*(id *)(a1 + 56), "setEstimatedBandwidth:");
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlBandwidthEstimatorMap_SetEstimatedBandwidth_cold_1();
  }
}

void VCRateControlBandwidthEstimatorMap_SetRadioAccessTechnology(uint64_t a1, uint64_t a2)
{
  BOOL v2;
  void *v3;
  _QWORD v4[4];
  int v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    *(_DWORD *)(a1 + 16) = a2;
    if (*(_QWORD *)(a1 + 56))
      v2 = (*(_DWORD *)(a1 + 12) - 6) > 0xFFFFFFFD;
    else
      v2 = 1;
    if (v2)
    {
      v3 = *(void **)(a1 + 40);
      v4[0] = MEMORY[0x1E0C809B0];
      v4[1] = 3221225472;
      v4[2] = __VCRateControlBandwidthEstimatorMap_SetRadioAccessTechnology_block_invoke;
      v4[3] = &__block_descriptor_36_e58_v32__0__NSNumber_8__VCRateControlBandwidthEstimator_16_B24l;
      v5 = a2;
      objc_msgSend(v3, "enumerateKeysAndObjectsUsingBlock:", v4);
    }
    else
    {
      objc_msgSend(*(id *)(a1 + 56), "setRadioAccessTechnology:", a2);
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlBandwidthEstimatorMap_SetRadioAccessTechnology_cold_1();
  }
}

void VCRateControlBandwidthEstimatorMap_SetFastSuddenBandwidthDetectionEnabled(uint64_t a1, char a2)
{
  BOOL v2;
  void *v3;
  _QWORD v4[4];
  char v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    *(_BYTE *)(a1 + 68) = a2;
    if (*(_QWORD *)(a1 + 56))
      v2 = (*(_DWORD *)(a1 + 12) - 6) > 0xFFFFFFFD;
    else
      v2 = 1;
    if (v2)
    {
      v3 = *(void **)(a1 + 40);
      v4[0] = MEMORY[0x1E0C809B0];
      v4[1] = 3221225472;
      v4[2] = __VCRateControlBandwidthEstimatorMap_SetFastSuddenBandwidthDetectionEnabled_block_invoke;
      v4[3] = &__block_descriptor_33_e58_v32__0__NSNumber_8__VCRateControlBandwidthEstimator_16_B24l;
      v5 = a2;
      objc_msgSend(v3, "enumerateKeysAndObjectsUsingBlock:", v4);
    }
    else
    {
      VCRateControlBandwidthEstimator_SetFastSuddenBandwidthDetectionEnabled(*(_QWORD *)(a1 + 56), a2);
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlBandwidthEstimatorMap_SetFastSuddenBandwidthDetectionEnabled_cold_1();
  }
}

void VCRateControlBandwidthEstimatorMap_EnableBWELogDump(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    *(_QWORD *)(a1 + 80) = a2;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlBandwidthEstimatorMap_EnableBWELogDump_cold_1();
  }
}

void sub_1D8ED6F20(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t VCMediaNegotiationBlobV2StreamGroupPayloadReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  int v15;
  char v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char v22;
  uint64_t result;
  char v24;
  unsigned int v25;
  uint64_t v26;
  unint64_t v27;
  char v28;
  char v29;
  unsigned int v30;
  uint64_t v31;
  unint64_t v32;
  char v33;
  char v34;
  unsigned int v35;
  uint64_t v36;
  unint64_t v37;
  char v38;
  char v39;
  unsigned int v40;
  uint64_t v41;
  unint64_t v42;
  char v43;
  char v44;
  unsigned int v45;
  uint64_t v46;
  unint64_t v47;
  char v48;
  char v49;
  unsigned int v50;
  uint64_t v51;
  unint64_t v52;
  char v53;
  char v54;
  unsigned int v55;
  uint64_t v56;
  unint64_t v57;
  char v58;
  void *Data;
  char v60;
  unsigned int v61;
  uint64_t v62;
  unint64_t v63;
  char v64;
  uint64_t v65;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        v14 = v9++ >= 9;
        if (v14)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      switch((v10 >> 3))
      {
        case 1u:
          v17 = 0;
          v18 = 0;
          v19 = 0;
          *(_WORD *)(a1 + 56) |= 2u;
          while (1)
          {
            v20 = *v3;
            v21 = *(_QWORD *)(a2 + v20);
            if (v21 == -1 || v21 >= *(_QWORD *)(a2 + *v4))
              break;
            v22 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v21);
            *(_QWORD *)(a2 + v20) = v21 + 1;
            v19 |= (unint64_t)(v22 & 0x7F) << v17;
            if ((v22 & 0x80) == 0)
              goto LABEL_86;
            v17 += 7;
            v14 = v18++ >= 9;
            if (v14)
            {
              LODWORD(v19) = 0;
              goto LABEL_88;
            }
          }
          *(_BYTE *)(a2 + *v5) = 1;
LABEL_86:
          if (*(_BYTE *)(a2 + *v5))
            LODWORD(v19) = 0;
LABEL_88:
          v65 = 12;
          goto LABEL_121;
        case 2u:
          v24 = 0;
          v25 = 0;
          v19 = 0;
          *(_WORD *)(a1 + 56) |= 0x80u;
          while (2)
          {
            v26 = *v3;
            v27 = *(_QWORD *)(a2 + v26);
            if (v27 == -1 || v27 >= *(_QWORD *)(a2 + *v4))
            {
              *(_BYTE *)(a2 + *v5) = 1;
            }
            else
            {
              v28 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v27);
              *(_QWORD *)(a2 + v26) = v27 + 1;
              v19 |= (unint64_t)(v28 & 0x7F) << v24;
              if (v28 < 0)
              {
                v24 += 7;
                v14 = v25++ >= 9;
                if (v14)
                {
                  LODWORD(v19) = 0;
                  goto LABEL_92;
                }
                continue;
              }
            }
            break;
          }
          if (*(_BYTE *)(a2 + *v5))
            LODWORD(v19) = 0;
LABEL_92:
          v65 = 48;
          goto LABEL_121;
        case 3u:
          v29 = 0;
          v30 = 0;
          v19 = 0;
          *(_WORD *)(a1 + 56) |= 0x10u;
          while (2)
          {
            v31 = *v3;
            v32 = *(_QWORD *)(a2 + v31);
            if (v32 == -1 || v32 >= *(_QWORD *)(a2 + *v4))
            {
              *(_BYTE *)(a2 + *v5) = 1;
            }
            else
            {
              v33 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v32);
              *(_QWORD *)(a2 + v31) = v32 + 1;
              v19 |= (unint64_t)(v33 & 0x7F) << v29;
              if (v33 < 0)
              {
                v29 += 7;
                v14 = v30++ >= 9;
                if (v14)
                {
                  LODWORD(v19) = 0;
                  goto LABEL_96;
                }
                continue;
              }
            }
            break;
          }
          if (*(_BYTE *)(a2 + *v5))
            LODWORD(v19) = 0;
LABEL_96:
          v65 = 24;
          goto LABEL_121;
        case 4u:
          v34 = 0;
          v35 = 0;
          v19 = 0;
          *(_WORD *)(a1 + 56) |= 0x40u;
          while (2)
          {
            v36 = *v3;
            v37 = *(_QWORD *)(a2 + v36);
            if (v37 == -1 || v37 >= *(_QWORD *)(a2 + *v4))
            {
              *(_BYTE *)(a2 + *v5) = 1;
            }
            else
            {
              v38 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v37);
              *(_QWORD *)(a2 + v36) = v37 + 1;
              v19 |= (unint64_t)(v38 & 0x7F) << v34;
              if (v38 < 0)
              {
                v34 += 7;
                v14 = v35++ >= 9;
                if (v14)
                {
                  LODWORD(v19) = 0;
                  goto LABEL_100;
                }
                continue;
              }
            }
            break;
          }
          if (*(_BYTE *)(a2 + *v5))
            LODWORD(v19) = 0;
LABEL_100:
          v65 = 44;
          goto LABEL_121;
        case 5u:
          v39 = 0;
          v40 = 0;
          v19 = 0;
          *(_WORD *)(a1 + 56) |= 8u;
          while (2)
          {
            v41 = *v3;
            v42 = *(_QWORD *)(a2 + v41);
            if (v42 == -1 || v42 >= *(_QWORD *)(a2 + *v4))
            {
              *(_BYTE *)(a2 + *v5) = 1;
            }
            else
            {
              v43 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v42);
              *(_QWORD *)(a2 + v41) = v42 + 1;
              v19 |= (unint64_t)(v43 & 0x7F) << v39;
              if (v43 < 0)
              {
                v39 += 7;
                v14 = v40++ >= 9;
                if (v14)
                {
                  LODWORD(v19) = 0;
                  goto LABEL_104;
                }
                continue;
              }
            }
            break;
          }
          if (*(_BYTE *)(a2 + *v5))
            LODWORD(v19) = 0;
LABEL_104:
          v65 = 20;
          goto LABEL_121;
        case 6u:
          v44 = 0;
          v45 = 0;
          v19 = 0;
          *(_WORD *)(a1 + 56) |= 0x20u;
          while (2)
          {
            v46 = *v3;
            v47 = *(_QWORD *)(a2 + v46);
            if (v47 == -1 || v47 >= *(_QWORD *)(a2 + *v4))
            {
              *(_BYTE *)(a2 + *v5) = 1;
            }
            else
            {
              v48 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v47);
              *(_QWORD *)(a2 + v46) = v47 + 1;
              v19 |= (unint64_t)(v48 & 0x7F) << v44;
              if (v48 < 0)
              {
                v44 += 7;
                v14 = v45++ >= 9;
                if (v14)
                {
                  LODWORD(v19) = 0;
                  goto LABEL_108;
                }
                continue;
              }
            }
            break;
          }
          if (*(_BYTE *)(a2 + *v5))
            LODWORD(v19) = 0;
LABEL_108:
          v65 = 40;
          goto LABEL_121;
        case 7u:
          v49 = 0;
          v50 = 0;
          v19 = 0;
          *(_WORD *)(a1 + 56) |= 0x100u;
          while (2)
          {
            v51 = *v3;
            v52 = *(_QWORD *)(a2 + v51);
            if (v52 == -1 || v52 >= *(_QWORD *)(a2 + *v4))
            {
              *(_BYTE *)(a2 + *v5) = 1;
            }
            else
            {
              v53 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v52);
              *(_QWORD *)(a2 + v51) = v52 + 1;
              v19 |= (unint64_t)(v53 & 0x7F) << v49;
              if (v53 < 0)
              {
                v49 += 7;
                v14 = v50++ >= 9;
                if (v14)
                {
                  LODWORD(v19) = 0;
                  goto LABEL_112;
                }
                continue;
              }
            }
            break;
          }
          if (*(_BYTE *)(a2 + *v5))
            LODWORD(v19) = 0;
LABEL_112:
          v65 = 52;
          goto LABEL_121;
        case 8u:
          v54 = 0;
          v55 = 0;
          v19 = 0;
          *(_WORD *)(a1 + 56) |= 1u;
          while (2)
          {
            v56 = *v3;
            v57 = *(_QWORD *)(a2 + v56);
            if (v57 == -1 || v57 >= *(_QWORD *)(a2 + *v4))
            {
              *(_BYTE *)(a2 + *v5) = 1;
            }
            else
            {
              v58 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v57);
              *(_QWORD *)(a2 + v56) = v57 + 1;
              v19 |= (unint64_t)(v58 & 0x7F) << v54;
              if (v58 < 0)
              {
                v54 += 7;
                v14 = v55++ >= 9;
                if (v14)
                {
                  LODWORD(v19) = 0;
                  goto LABEL_116;
                }
                continue;
              }
            }
            break;
          }
          if (*(_BYTE *)(a2 + *v5))
            LODWORD(v19) = 0;
LABEL_116:
          v65 = 8;
          goto LABEL_121;
        case 9u:
          Data = (void *)PBReaderReadData();

          *(_QWORD *)(a1 + 32) = Data;
          continue;
        case 0xAu:
          v60 = 0;
          v61 = 0;
          v19 = 0;
          *(_WORD *)(a1 + 56) |= 4u;
          break;
        default:
          result = PBReaderSkipValueWithTag();
          if (!(_DWORD)result)
            return result;
          continue;
      }
      while (1)
      {
        v62 = *v3;
        v63 = *(_QWORD *)(a2 + v62);
        if (v63 == -1 || v63 >= *(_QWORD *)(a2 + *v4))
          break;
        v64 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v63);
        *(_QWORD *)(a2 + v62) = v63 + 1;
        v19 |= (unint64_t)(v64 & 0x7F) << v60;
        if ((v64 & 0x80) == 0)
          goto LABEL_118;
        v60 += 7;
        v14 = v61++ >= 9;
        if (v14)
        {
          LODWORD(v19) = 0;
          goto LABEL_120;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_118:
      if (*(_BYTE *)(a2 + *v5))
        LODWORD(v19) = 0;
LABEL_120:
      v65 = 16;
LABEL_121:
      *(_DWORD *)(a1 + v65) = v19;
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

uint64_t _VCFECHeader_WriteToBuffer_V0(uint64_t a1, _BYTE *a2, unint64_t a3, uint64_t *a4)
{
  char v5;
  char v6;
  char v7;
  char v8;
  char v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  _BYTE *v14;
  uint64_t v15;
  uint64_t v16;

  if ((*(_BYTE *)a1 & 3) != 0)
  {
    v15 = 2150825985;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCFECHeader_WriteToBuffer_V0_cold_4();
    }
    goto LABEL_17;
  }
  if (a3 <= 3)
  {
    v15 = 2150825985;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCFECHeader_WriteToBuffer_V0_cold_1();
    }
    goto LABEL_17;
  }
  v5 = *a2 | (*(_BYTE *)a1 << 6);
  *a2 = v5;
  v6 = (2 * *(_BYTE *)a1) & 0x38 | v5;
  *a2 = v6;
  *a2 = v6 | *(_BYTE *)(a1 + 1) & 7;
  v7 = ~(*(unsigned __int16 *)(a1 + 2) >> 5) & 0x80 | a2[1];
  a2[1] = v7;
  a2[1] = v7 | *(_BYTE *)(a1 + 2) & 0x7F;
  v8 = *(_BYTE *)(a1 + 2) & 0x80 | a2[2];
  a2[2] = v8;
  v9 = (*(unsigned __int16 *)(a1 + 2) >> 5) & 0x38 | v8;
  a2[2] = v9;
  a2[2] = *(_BYTE *)(a1 + 5) & 7 | v9;
  a2[3] = *(_BYTE *)(a1 + 4);
  if ((*(_WORD *)(a1 + 2) & 0x1000) != 0)
  {
    if (a3 <= 4)
    {
      v15 = 2150825985;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCFECHeader_WriteToBuffer_V0_cold_2();
      }
    }
    else
    {
      a2[4] = *(_BYTE *)(a1 + 7);
      a2[5] = *(_BYTE *)(a1 + 6);
      if (!*(_WORD *)(a1 + 6))
      {
        v10 = 6;
        goto LABEL_12;
      }
      v11 = 0;
      v12 = 0;
      v13 = a1 + 8;
      while (v11 + 8 <= a3)
      {
        v14 = &a2[v11];
        v14[6] = *(_BYTE *)(v13 + v11 + 1);
        v14[7] = *(_BYTE *)(v13 + v11);
        ++v12;
        v11 += 2;
        if (v12 >= *(unsigned __int16 *)(a1 + 6))
        {
          v10 = v11 + 6;
          goto LABEL_12;
        }
      }
      v15 = 2150825985;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCFECHeader_WriteToBuffer_V0_cold_3();
      }
    }
LABEL_17:
    v16 = 0;
    goto LABEL_13;
  }
  v10 = 4;
LABEL_12:
  v15 = 0;
  v16 = (v10 & 2) + v10;
LABEL_13:
  *a4 = v16;
  return v15;
}

uint64_t _VCFECHeader_WriteToBuffer_V1(uint64_t a1, _BYTE *a2, unint64_t a3, uint64_t *a4)
{
  char v5;
  char v6;
  char v7;
  char v8;
  char v9;
  char v10;
  char v11;
  uint64_t v12;
  uint64_t v13;

  if ((*(_BYTE *)a1 & 3) != 1)
  {
    v12 = 2150825985;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCFECHeader_WriteToBuffer_V1_cold_3();
    }
    goto LABEL_18;
  }
  if (a3 <= 3)
  {
    v12 = 2150825985;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCFECHeader_WriteToBuffer_V1_cold_1();
    }
    goto LABEL_18;
  }
  v5 = *a2 | (*(_BYTE *)a1 << 6);
  *a2 = v5;
  v6 = (2 * *(_BYTE *)a1) & 0x38 | v5;
  *a2 = v6;
  *a2 = (*(_BYTE *)(a1 + 1) >> 1) & 7 | v6;
  v7 = a2[1] | (*(_BYTE *)(a1 + 1) << 7);
  a2[1] = v7;
  v8 = ~(*(unsigned __int16 *)(a1 + 2) >> 6) & 0x40 | v7;
  a2[1] = v8;
  a2[1] = v8 | (*(_BYTE *)(a1 + 2) >> 1) & 0x3F;
  v9 = a2[2] | (*(_BYTE *)(a1 + 2) << 7);
  a2[2] = v9;
  v10 = (*(_BYTE *)(a1 + 2) >> 1) & 0x40 | v9;
  a2[2] = v10;
  v11 = (*(unsigned __int16 *)(a1 + 2) >> 6) & 0x3C | v10;
  a2[2] = v11;
  a2[2] = *(_BYTE *)(a1 + 5) & 3 | v11;
  a2[3] |= *(_BYTE *)(a1 + 4);
  if ((*(_WORD *)(a1 + 2) & 0x1000) == 0)
  {
    v12 = 0;
    v13 = 4;
    goto LABEL_8;
  }
  if (a3 <= 7)
  {
    v12 = 2150825985;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCFECHeader_WriteToBuffer_V1_cold_2();
    }
LABEL_18:
    v13 = 0;
    goto LABEL_8;
  }
  v12 = 0;
  a2[4] = BYTE1(*(_DWORD *)(a1 + 6));
  a2[5] = *(_DWORD *)(a1 + 6);
  a2[6] = *(_BYTE *)(a1 + 9);
  a2[7] = *(_WORD *)(a1 + 8);
  v13 = 8;
  if ((*(_WORD *)(a1 + 2) & 0x1000) == 0)
    v13 = 4;
LABEL_8:
  *a4 = v13;
  return v12;
}

uint64_t VCFECHeader_WriteToBuffer(unsigned __int8 *a1, _BYTE *a2, size_t a3, uint64_t *a4)
{
  int v8;
  int v9;
  uint64_t result;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCFECHeader_WriteToBuffer_cold_1();
    }
    goto LABEL_23;
  }
  if (!a4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCFECHeader_WriteToBuffer_cold_2();
    }
LABEL_23:
    *a4 = 0;
    return 2150825985;
  }
  bzero(a2, a3);
  v8 = *a1;
  if ((v8 & 3) == 1)
  {
    v11 = *(_OWORD *)a1;
    v12 = *((_QWORD *)a1 + 2);
    v9 = _VCFECHeader_WriteToBuffer_V1((uint64_t)&v11, a2, a3, a4);
  }
  else
  {
    if (v8 << 30 >> 30)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
        if (!(_DWORD)result)
          return result;
        VCFECHeader_WriteToBuffer_cold_3();
      }
      return 0;
    }
    v11 = *(_OWORD *)a1;
    v12 = *((_QWORD *)a1 + 2);
    v9 = _VCFECHeader_WriteToBuffer_V0((uint64_t)&v11, a2, a3, a4);
  }
  if ((v9 & 0x80000000) == 0)
    return 0;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCFECHeader_WriteToBuffer_cold_4();
  }
  return 21;
}

BOOL VCMediaNegotiationBlobV2MicrophoneSettingsU1ReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  unint64_t v17;
  char v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char v23;
  BOOL v24;
  int *v25;
  char v26;
  unsigned int v27;
  uint64_t v28;
  unint64_t v29;
  char v30;
  char v31;
  unsigned int v32;
  uint64_t v33;
  unint64_t v34;
  char v35;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    while (1)
    {
      if (*(_BYTE *)(a2 + *v5))
        return *(_BYTE *)(a2 + *v5) == 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        return *(_BYTE *)(a2 + *v5) == 0;
      v17 = v10 >> 3;
      if ((v10 >> 3) == 3)
      {
        v26 = 0;
        v27 = 0;
        v20 = 0;
        *(_BYTE *)(a1 + 20) |= 1u;
        while (1)
        {
          v28 = *v3;
          v29 = *(_QWORD *)(a2 + v28);
          if (v29 == -1 || v29 >= *(_QWORD *)(a2 + *v4))
            break;
          v30 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v29);
          *(_QWORD *)(a2 + v28) = v29 + 1;
          v20 |= (unint64_t)(v30 & 0x7F) << v26;
          if ((v30 & 0x80) == 0)
          {
            v25 = &OBJC_IVAR___VCMediaNegotiationBlobV2MicrophoneSettingsU1__cipherSuites;
            goto LABEL_48;
          }
          v26 += 7;
          v24 = v27++ > 8;
          if (v24)
          {
            LODWORD(v20) = 0;
            v25 = &OBJC_IVAR___VCMediaNegotiationBlobV2MicrophoneSettingsU1__cipherSuites;
            goto LABEL_50;
          }
        }
        v25 = &OBJC_IVAR___VCMediaNegotiationBlobV2MicrophoneSettingsU1__cipherSuites;
LABEL_47:
        *(_BYTE *)(a2 + *v5) = 1;
        goto LABEL_48;
      }
      if ((_DWORD)v17 == 2)
        break;
      if ((_DWORD)v17 == 1)
      {
        v18 = 0;
        v19 = 0;
        v20 = 0;
        *(_BYTE *)(a1 + 20) |= 4u;
        while (1)
        {
          v21 = *v3;
          v22 = *(_QWORD *)(a2 + v21);
          if (v22 == -1 || v22 >= *(_QWORD *)(a2 + *v4))
          {
            v25 = &OBJC_IVAR___VCMediaNegotiationBlobV2MicrophoneSettingsU1__rtpSSRC;
            goto LABEL_47;
          }
          v23 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v22);
          *(_QWORD *)(a2 + v21) = v22 + 1;
          v20 |= (unint64_t)(v23 & 0x7F) << v18;
          if ((v23 & 0x80) == 0)
            break;
          v18 += 7;
          v24 = v19++ > 8;
          if (v24)
          {
            LODWORD(v20) = 0;
            v25 = &OBJC_IVAR___VCMediaNegotiationBlobV2MicrophoneSettingsU1__rtpSSRC;
            goto LABEL_50;
          }
        }
        v25 = &OBJC_IVAR___VCMediaNegotiationBlobV2MicrophoneSettingsU1__rtpSSRC;
        goto LABEL_48;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0)
        return 0;
LABEL_51:
      if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
        return *(_BYTE *)(a2 + *v5) == 0;
    }
    v31 = 0;
    v32 = 0;
    v20 = 0;
    *(_BYTE *)(a1 + 20) |= 2u;
    while (1)
    {
      v33 = *v3;
      v34 = *(_QWORD *)(a2 + v33);
      if (v34 == -1 || v34 >= *(_QWORD *)(a2 + *v4))
      {
        v25 = &OBJC_IVAR___VCMediaNegotiationBlobV2MicrophoneSettingsU1__payloads;
        goto LABEL_47;
      }
      v35 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v34);
      *(_QWORD *)(a2 + v33) = v34 + 1;
      v20 |= (unint64_t)(v35 & 0x7F) << v31;
      if ((v35 & 0x80) == 0)
        break;
      v31 += 7;
      v24 = v32++ > 8;
      if (v24)
      {
        LODWORD(v20) = 0;
        v25 = &OBJC_IVAR___VCMediaNegotiationBlobV2MicrophoneSettingsU1__payloads;
        goto LABEL_50;
      }
    }
    v25 = &OBJC_IVAR___VCMediaNegotiationBlobV2MicrophoneSettingsU1__payloads;
LABEL_48:
    if (*(_BYTE *)(a2 + *v5))
      LODWORD(v20) = 0;
LABEL_50:
    *(_DWORD *)(a1 + *v25) = v20;
    goto LABEL_51;
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

uint64_t VCTimescalePSOLA_PreEmptiveExpand(unsigned __int8 *a1, __int16 *a2)
{
  __int16 v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  int v9;
  int v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  __int16 v14;
  int v15;
  unint64_t v16;
  float v17;
  __int16 *v18;
  float *v19;
  float *v20;
  uint64_t v22;
  NSObject *v23;
  int v24;
  uint64_t v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  int v31;
  __int16 v32;
  int v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if (a1[92])
  {
    v4 = VCTimescalePSOLA_CalcFsMult(*((unsigned __int16 *)a1 + 1));
    v5 = (__int16)(120 * v4);
    *((_WORD *)a1 + 29) = 0;
    v6 = VCTimescalePSOLA_CheckforSignalCorrelation((__int16 *)a1, a2, v5, 1);
    if ((v6 & 0x80000000) != 0)
    {
      v12 = v6;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v22 = VRTraceErrorLogLevelToCSTR();
        v23 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCTimescalePSOLA_PreEmptiveExpand_cold_1(v22, v23);
      }
    }
    else
    {
      if (a2[32] > v5 && (int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v7 = VRTraceErrorLogLevelToCSTR();
        v8 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v9 = a2[32];
          v24 = 136316162;
          v25 = v7;
          v26 = 2080;
          v27 = "VCTimescalePSOLA_PreEmptiveExpand";
          v28 = 1024;
          v29 = 150;
          v30 = 1024;
          v31 = v9;
          v32 = 1024;
          v33 = (__int16)(120 * v4);
          _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Expand: WARN TOO MANY PLAYED OUT DATA %d > 15 ms %d", (uint8_t *)&v24, 0x28u);
        }
      }
      VCTimescalePSOLA_SynchronizeChannelCorrelation(a1, (uint64_t)a2, 1, v4);
      if (*((__int16 *)a1 + 19) <= *((__int16 *)a1 + 27) || (v10 = a2[32], v10 > v5))
      {
        if (*((_WORD *)a1 + 11))
        {
          a2[34] = a2[33];
          if (*a1)
          {
            v11 = 0;
            do
            {
              memmove(*(void **)&a2[4 * v11 + 16], *(const void **)&a2[4 * v11], 4 * a2[33]);
              ++v11;
            }
            while (v11 < *a1);
          }
          return 61;
        }
        LOWORD(v10) = a2[32];
      }
      if ((__int16)v10 <= v5)
        v14 = 120 * v4;
      else
        v14 = v10;
      v15 = *((__int16 *)a1 + 3);
      if (*a1)
      {
        v16 = 0;
        v17 = 1.0 / (float)(v15 + 1);
        do
        {
          v18 = &a2[4 * v16];
          v19 = (float *)(*(_QWORD *)v18 + 4 * (v14 - *((__int16 *)a1 + 3)));
          v20 = (float *)(*(_QWORD *)v18 + 4 * v14);
          memmove(*((void **)v18 + 4), *(const void **)v18, 4 * v14);
          VCTimescalePSOLA_MixVoiceUnvoiceFloatPoint((float *)(*((_QWORD *)v18 + 4) + 4 * v14), v20, v19, *((__int16 *)a1 + 3), 1.0 - v17, v17);
          memmove((void *)(*((_QWORD *)v18 + 4) + 4 * (*((__int16 *)a1 + 3) + v14)), (const void *)(*(_QWORD *)v18 + 4 * v14), 4 * (__int16)(a2[33] - v14));
          ++v16;
        }
        while (v16 < *a1);
        LOWORD(v15) = *((_WORD *)a1 + 3);
      }
      v12 = 0;
      a2[34] = a2[33] + v15;
      *((_DWORD *)a1 + 18) += *((__int16 *)a1 + 3);
    }
  }
  else
  {
    a2[34] = a2[33];
    if (*a1)
    {
      v13 = 0;
      do
      {
        memmove(*(void **)&a2[4 * v13 + 16], *(const void **)&a2[4 * v13], 4 * a2[33]);
        ++v13;
      }
      while (v13 < *a1);
    }
    return 0;
  }
  return v12;
}

CFAllocatorRef VCAudioBufferAllocatorCreate(const __CFAllocator *a1, size_t a2, unsigned int a3)
{
  size_t v5;
  _DWORD *v7;
  _DWORD *v8;
  CFAllocatorRef Default;
  uint64_t v11;
  NSObject *v12;
  CFAllocatorContext v13;
  uint8_t buf[4];
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  size_t v21;
  __int16 v22;
  size_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioBufferAllocatorCreate_cold_1();
    }
    return 0;
  }
  if (!a3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioBufferAllocatorCreate_cold_2();
    }
    return 0;
  }
  *(_OWORD *)&v13.copyDescription = xmmword_1E9E57BC0;
  *(_OWORD *)&v13.reallocate = *(_OWORD *)&off_1E9E57BD0;
  v13.preferredSize = 0;
  *(_OWORD *)&v13.version = xmmword_1E9E57BA0;
  *(_OWORD *)&v13.retain = unk_1E9E57BB0;
  v5 = (a2 + 8) * a3 + 40;
  if (v5 <= a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v11 = VRTraceErrorLogLevelToCSTR();
      v12 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136316162;
        v15 = v11;
        v16 = 2080;
        v17 = "VCAudioBufferAllocatorCreateContext";
        v18 = 1024;
        v19 = 35;
        v20 = 2048;
        v21 = a2;
        v22 = 2048;
        v23 = v5;
        _os_log_error_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_ERROR, " [%s] %s:%d Failed to compute the size. Requested buffer size=%zu allocator size=%zu!", buf, 0x30u);
      }
    }
    goto LABEL_21;
  }
  v7 = CFAllocatorAllocate(a1, (a2 + 8) * a3 + 40, 0);
  if (!v7)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioBufferAllocatorCreate_cold_4();
    }
LABEL_21:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioBufferAllocatorCreate_cold_3();
    }
    return 0;
  }
  v8 = v7;
  bzero(v7, v5);
  v8[4] = a3;
  *((_QWORD *)v8 + 1) = a2;
  if (a1)
    Default = a1;
  else
    Default = CFAllocatorGetDefault();
  *(_QWORD *)v8 = CFRetain(Default);
  *((_QWORD *)v8 + 3) = v5;
  v13.info = v8;
  return CFAllocatorCreate(a1, &v13);
}

void VCAudioBufferAllocatorFreeContext(CFAllocatorRef *ptr)
{
  CFAllocatorRef v1;

  if (ptr)
  {
    v1 = *ptr;
    CFAllocatorDeallocate(*ptr, ptr);
    CFRelease(v1);
  }
}

void *VCAudioBufferAllocatorAlloc(CFIndex a1, CFOptionFlags a2, uint64_t a3)
{
  uint64_t v6;
  NSObject *v7;
  void *result;
  int v9;
  unsigned int *v10;
  char v12;
  _DWORD *v13;
  int v14;
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(a3 + 8) == a1 && !*(_BYTE *)(a3 + 32) && *(_DWORD *)(a3 + 16))
  {
    v9 = 0;
    v10 = (unsigned int *)(a3 + 40);
    while (1)
    {
      if (__ldxr(v10))
      {
        v12 = 0;
        __clrex();
LABEL_14:
        result = v10 + 1;
        v13 = (unsigned int *)((char *)v10 + *(_QWORD *)(a3 + 8) + 4);
        *v13 = -524416118;
        if ((v12 & 1) != 0)
          return result;
        v10 = v13 + 1;
        if (++v9 >= *(_DWORD *)(a3 + 16))
          break;
      }
      else
      {
        v12 = 1;
        if (!__stxr(1u, v10))
          goto LABEL_14;
      }
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v6 = VRTraceErrorLogLevelToCSTR();
    v7 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v14 = 136315650;
      v15 = v6;
      v16 = 2080;
      v17 = "VCAudioBufferAllocatorAlloc";
      v18 = 1024;
      v19 = 103;
      _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Insufficient number of audio buffer!", (uint8_t *)&v14, 0x1Cu);
    }
  }
  return CFAllocatorAllocate(*(CFAllocatorRef *)a3, a1, a2);
}

void *VCAudioBufferAllocatorRealloc(void *ptr, CFIndex newsize, CFOptionFlags hint, unint64_t a4)
{
  const void *v5;
  void *v6;

  v5 = ptr;
  if ((unint64_t)ptr <= a4 || a4 + *(_QWORD *)(a4 + 24) <= (unint64_t)ptr)
    return CFAllocatorReallocate(*(CFAllocatorRef *)a4, ptr, newsize, hint);
  if (*(_QWORD *)(a4 + 8) < newsize)
  {
    v6 = CFAllocatorAllocate(*(CFAllocatorRef *)a4, newsize, hint);
    memcpy(v6, v5, *(_QWORD *)(a4 + 8));
    VCAudioBufferAllocatorCleanupBuffer(a4, (uint64_t)v5);
    return v6;
  }
  return (void *)v5;
}

void VCAudioBufferAllocatorDealloc(void *ptr, unint64_t a2)
{
  if ((unint64_t)ptr <= a2 || a2 + *(_QWORD *)(a2 + 24) <= (unint64_t)ptr)
    CFAllocatorDeallocate(*(CFAllocatorRef *)a2, ptr);
  else
    VCAudioBufferAllocatorCleanupBuffer(a2, (uint64_t)ptr);
}

void VCAudioBufferAllocatorCleanupBuffer(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unsigned int *v5;

  v3 = *(_QWORD *)(a1 + 8);
  if (*(_DWORD *)(a2 + v3) != -524416118)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioBufferAllocatorCleanupBuffer_cold_1();
    }
    *(_BYTE *)(a1 + 32) = 1;
  }
  v5 = (unsigned int *)(a2 - 4);
  *(_DWORD *)(a2 + v3) = -524416118;
  do
    __ldxr(v5);
  while (__stxr(0, v5));
}

uint64_t _VCFECFeedbackAnalyzerClassRegister(uint64_t *a1)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

uint64_t _VCFECFeedbackAnalyzer_Configure(uint64_t a1, __int128 *a2)
{
  __int128 v2;
  int v3;
  int *v4;
  uint64_t v6;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  NSObject *v12;

  v2 = *a2;
  *(_OWORD *)(a1 + 16) = *a2;
  v4 = (int *)(a2 + 1);
  v3 = *((_DWORD *)a2 + 4);
  *(_DWORD *)(a1 + 32) = v3;
  *(_OWORD *)(a1 + 40) = *(__int128 *)((char *)a2 + 24);
  if (*(double *)&v2 <= 0.0 || *(double *)&v2 > 1.0)
  {
    v6 = 2150825985;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v9 = VRTraceErrorLogLevelToCSTR();
      v10 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCFECFeedbackAnalyzer_Configure_cold_1(v9, (double *)a2, v10);
    }
  }
  else if ((v3 - 15001) <= 0xFFFFC567)
  {
    v6 = 2150825985;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v11 = VRTraceErrorLogLevelToCSTR();
      v12 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCFECFeedbackAnalyzer_Configure_cold_2(v11, v4, v12);
    }
  }
  else
  {
    return 0;
  }
  return v6;
}

uint64_t VCFECFeedbackAnalyzer_Create(uint64_t a1, uint64_t *a2, __int128 *a3)
{
  uint64_t Instance;
  uint64_t v6;
  _BOOL4 BoolValueForKey;
  uint32_t v8;
  FILE **v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  void *v19;
  char v20;
  char v21[16];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (a3)
    {
      if (VCFECFeedbackAnalyzerGetTypeID_initOnce != -1)
        dispatch_once_f(&VCFECFeedbackAnalyzerGetTypeID_initOnce, &VCFECFeedbackAnalyzerGetTypeID_typeID, (dispatch_function_t)_VCFECFeedbackAnalyzerClassRegister);
      Instance = _CFRuntimeCreateInstance();
      if (Instance)
      {
        v6 = Instance;
        bzero((void *)(Instance + 200), 0x1180uLL);
        BoolValueForKey = VCDefaults_GetBoolValueForKey(CFSTR("isFECFeedbackAnalyzerDumpEnabled"), 1);
        *(_BYTE *)(v6 + 56) = BoolValueForKey;
        if (BoolValueForKey)
        {
          v8 = arc4random();
          *(_DWORD *)(v6 + 60) = v8;
          memset(v21, 170, 12);
          __sprintf_chk(v21, 0, 0xCuLL, "%010u", v8);
          v9 = LogDump_OpenLog((uint64_t)v21, (uint64_t)"com.apple.VideoConference.VCFECFeedbackAnalyzer", (uint64_t)".fecdump", (char)"", 9, (char)"");
          *(_QWORD *)(v6 + 64) = v9;
          VRLogfilePrintSync(v9, "Time\tTimeMicro\tFrameSizeInPackets\tlostPackets\n", v10, v11, v12, v13, v14, v15, v20);
        }
        if (_VCFECFeedbackAnalyzer_Configure(v6, a3))
        {
          v17 = 2150825985;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VCFECFeedbackAnalyzer_Create_cold_5();
          }
        }
        else
        {
          v16 = malloc_type_calloc(*(int *)(v6 + 32), 0x10uLL, 0x1000040D9A13B51uLL);
          *(_QWORD *)(v6 + 88) = v16;
          if (v16)
          {
            v17 = 0;
            *a2 = v6;
            return v17;
          }
          if ((int)VRTraceGetErrorLogLevelForModule() < 3)
          {
            v17 = 2150825987;
          }
          else
          {
            VRTraceErrorLogLevelToCSTR();
            v17 = 2150825987;
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VCFECFeedbackAnalyzer_Create_cold_4();
          }
        }
        v19 = *(void **)(v6 + 88);
        if (v19)
          free(v19);
        CFRelease((CFTypeRef)v6);
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      {
        return 2150825987;
      }
      else
      {
        VRTraceErrorLogLevelToCSTR();
        v17 = 2150825987;
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCFECFeedbackAnalyzer_Create_cold_3();
      }
    }
    else
    {
      v17 = 2150825985;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCFECFeedbackAnalyzer_Create_cold_2();
      }
    }
  }
  else
  {
    v17 = 2150825985;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCFECFeedbackAnalyzer_Create_cold_1();
    }
  }
  return v17;
}

uint64_t VCFECFeedbackAnalyzer_ProcessFeedback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  NSObject *v17;
  float v18;
  int v19;
  float v20;
  __int16 v21;
  __int16 v22;
  uint64_t v23;
  int v24;
  int v25;
  __int16 v26;
  double v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t i;
  const char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  float v38;
  double v39;
  uint64_t v40;
  float v42;
  int v43;
  float v44;
  uint8_t buf[512];
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v6 = WORD1(a3);
    if (WORD1(a3) >= 0x1Fu)
      v7 = 31;
    else
      v7 = WORD1(a3);
    v8 = (unsigned __int16)a3;
    if ((unsigned __int16)a3 >= 0x20u)
      v7 = (int)(float)((float)(32.0 / (float)(unsigned __int16)a3) * (float)WORD1(a3));
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v15 = VRTraceErrorLogLevelToCSTR();
      v16 = *MEMORY[0x1E0CF2758];
      v17 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          v18 = *(double *)&a2;
          v19 = *(__int16 *)(a1 + 84);
          v20 = *(double *)&a2 - *(double *)(a1 + 96);
          *(_DWORD *)buf = 136316930;
          *(_QWORD *)&buf[4] = v15;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VCFECFeedbackAnalyzer_RegisterFeedback";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 195;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = v8;
          *(_WORD *)&buf[34] = 1024;
          *(_DWORD *)&buf[36] = v6;
          *(_WORD *)&buf[40] = 2048;
          *(double *)&buf[42] = v18;
          *(_WORD *)&buf[50] = 2048;
          *(double *)&buf[52] = v20;
          *(_WORD *)&buf[60] = 1024;
          *(_DWORD *)&buf[62] = v19;
          _os_log_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d New feedback arrived fecFeedback.sizeInPackets=%d fecFeedback.lostPackets=%d time=%f timeDelta=%f bufferIndex=%d", buf, 0x42u);
        }
      }
      else if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        v42 = *(double *)&a2;
        v43 = *(__int16 *)(a1 + 84);
        v44 = *(double *)&a2 - *(double *)(a1 + 96);
        *(_DWORD *)buf = 136316930;
        *(_QWORD *)&buf[4] = v15;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VCFECFeedbackAnalyzer_RegisterFeedback";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 195;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v8;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = v6;
        *(_WORD *)&buf[40] = 2048;
        *(double *)&buf[42] = v42;
        *(_WORD *)&buf[50] = 2048;
        *(double *)&buf[52] = v44;
        *(_WORD *)&buf[60] = 1024;
        *(_DWORD *)&buf[62] = v43;
        _os_log_debug_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEBUG, " [%s] %s:%d New feedback arrived fecFeedback.sizeInPackets=%d fecFeedback.lostPackets=%d time=%f timeDelta=%f bufferIndex=%d", buf, 0x42u);
      }
    }
    if (v7 >= 0x1F)
      v21 = 31;
    else
      v21 = v7;
    if (v8 >= 0x1F)
      v22 = 31;
    else
      v22 = v8;
    v23 = *(_QWORD *)(a1 + 88) + 16 * *(__int16 *)(a1 + 84);
    *(double *)v23 = *(double *)&a2;
    *(_WORD *)(v23 + 8) = v22;
    *(_WORD *)(v23 + 10) = v21;
    v24 = *(_DWORD *)(a1 + 32);
    *(_WORD *)(a1 + 84) = (*(__int16 *)(a1 + 84) + 1) % v24;
    v25 = *(__int16 *)(a1 + 82);
    if (v25 + 1 < v24)
      v26 = v25 + 1;
    else
      v26 = v24;
    *(_WORD *)(a1 + 82) = v26;
    *(double *)(a1 + 96) = *(double *)&a2;
    *(_QWORD *)(a1 + 104) = a3;
    if (*(_BYTE *)(a1 + 56))
    {
      if (*(_BYTE *)(a1 + 80))
      {
        v27 = micro();
        if (v27 - *(double *)(a1 + 72) >= 1.0)
        {
          *(double *)(a1 + 72) = v27;
          memcpy(buf, "histogram", 0x1F4uLL);
          v28 = 0;
          v29 = a1 + 200;
          do
          {
            __sprintf_chk((char *)buf, 0, 0x1F4uLL, "{\"histogram\":\t{\"size\": %2d,\t\"bins\":{", v28);
            for (i = 0; i != 32; ++i)
            {
              if (i)
                v31 = ",";
              else
                v31 = "";
              __sprintf_chk((char *)buf, 0, 0x1F4uLL, "%s%s\t\"%d\":%2.3f", (const char *)buf, v31, i, *(float *)(v29 + 4 * i));
            }
            VRLogfilePrintWithTimestamp(*(_QWORD *)(a1 + 64), "%s}}}\n", v32, v33, v34, v35, v36, v37, (char)buf);
            ++v28;
            v29 += 140;
          }
          while (v28 != 32);
        }
      }
      else
      {
        v38 = *(double *)&a2;
        v39 = v38;
        VRLogfilePrintWithTimestamp(*(_QWORD *)(a1 + 64), "%5.6f\t%d\t%d\n", v9, v10, v11, v12, v13, v14, SLOBYTE(v39));
      }
    }
    return 0;
  }
  else
  {
    v40 = 2150825985;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCFECFeedbackAnalyzer_ProcessFeedback_cold_1();
    }
  }
  return v40;
}

uint64_t VCFECFeedbackAnalyzer_GetFECLevelVector(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _OWORD *v5;
  int v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  int v10;
  uint64_t v11;
  double v12;
  int v13;
  int v14;
  int v15;
  double v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  unsigned int v20;
  double v21;
  double v22;
  uint64_t v24;
  NSObject *v25;
  NSObject *v26;
  float v27;
  float v28;
  uint64_t v29;
  float v30;
  uint64_t i;
  uint64_t v32;
  uint64_t v33;
  float v34;
  uint64_t v35;
  uint64_t v36;
  float v37;
  uint64_t v38;
  _WORD *v39;
  _WORD *v40;
  float v41;
  float v42;
  __int16 v43;
  unsigned __int16 v44;
  float *v45;
  unsigned __int16 v46;
  uint64_t j;
  unsigned int v48;
  unsigned int v49;
  unsigned __int16 v50;
  uint64_t v51;
  unsigned __int16 v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  char v56;
  uint64_t v57;
  uint64_t v58;
  _WORD *v59;
  uint64_t k;
  __int16 v61;
  _BYTE *v62;
  unsigned __int16 *v63;
  unint64_t m;
  const char *v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unsigned int RedundancyLevelFromPLR;
  uint64_t v74;
  int v75;
  _BYTE *v76;
  uint64_t n;
  char RealNumParity;
  unsigned __int16 *v79;
  unint64_t ii;
  int v81;
  int v82;
  const char *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  unsigned __int8 *v90;
  unint64_t jj;
  const char *v92;
  int v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  float v112;
  float v113;
  uint64_t v114;
  NSObject *v115;
  NSObject *v116;
  uint8_t buf[504];
  uint64_t v118;

  v118 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a2)
    {
      v4 = -4480;
      do
      {
        v5 = (_OWORD *)(a1 + 200 + v4);
        v5[287] = 0uLL;
        v5[286] = 0uLL;
        v5[285] = 0uLL;
        v5[284] = 0uLL;
        v5[283] = 0uLL;
        v5[282] = 0uLL;
        v5[281] = 0uLL;
        v5[280] = 0uLL;
        v4 += 140;
      }
      while (v4);
      v6 = *(__int16 *)(a1 + 82);
      if (v6 < 1)
      {
        v9 = 0;
        v16 = 0.0;
        v22 = 0.0;
      }
      else
      {
        v7 = 0;
        v8 = 0;
        v9 = 0;
        v10 = *(_DWORD *)(a1 + 32);
        v11 = *(_QWORD *)(a1 + 88);
        v12 = *(double *)(a1 + 24);
        v13 = v10 + *(__int16 *)(a1 + 84);
        LOWORD(v14) = 1;
        do
        {
          v15 = (v13 - (__int16)v14) % v10;
          v16 = NAN - *(double *)(v11 + 16 * (__int16)v15);
          if (v16 > v12)
            break;
          v17 = v11 + 16 * (__int16)v15;
          v18 = *(unsigned __int16 *)(v17 + 8);
          v19 = a1 + 140 * *(unsigned __int16 *)(v17 + 8);
          v20 = *(unsigned __int16 *)(v17 + 10);
          *(float *)(v19 + 4 * v20 + 200) = *(float *)(v19 + 4 * v20 + 200) + 1.0;
          v21 = *(double *)(a1 + 40);
          if (v16 > v21)
            v18 = 0;
          v8 += v18;
          if (v16 > v21)
            v20 = 0;
          v7 += v20;
          v14 = (__int16)(v14 + 1);
          ++v9;
        }
        while (v14 <= v6);
        v22 = 0.0;
        if (v16 > 2.0 && v8 != 0)
          v22 = (float)((float)((float)v7 * 100.0) / (float)v8);
      }
      *(double *)(a1 + 112) = v22;
      _VCRedundancyControlAlgorithmVideo_ApplyEnveloppe((double *)(a1 + 120), v22);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v24 = VRTraceErrorLogLevelToCSTR();
        v25 = *MEMORY[0x1E0CF2758];
        v26 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
          {
            v27 = v16;
            v28 = *(double *)(a1 + 112);
            *(_DWORD *)buf = 136316418;
            *(_QWORD *)&buf[4] = v24;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VCFECFeedbackAnalyzer_PopulateHistogram";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 247;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = v9;
            *(_WORD *)&buf[34] = 2048;
            *(double *)&buf[36] = v27;
            *(_WORD *)&buf[44] = 2048;
            *(double *)&buf[46] = v28;
            _os_log_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Histogram has been populated countItems=%d currentTimeDelta=%f _lastComputedVPLR=%2.2f", buf, 0x36u);
          }
        }
        else if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
        {
          v112 = v16;
          v113 = *(double *)(a1 + 112);
          *(_DWORD *)buf = 136316418;
          *(_QWORD *)&buf[4] = v24;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VCFECFeedbackAnalyzer_PopulateHistogram";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 247;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = v9;
          *(_WORD *)&buf[34] = 2048;
          *(double *)&buf[36] = v112;
          *(_WORD *)&buf[44] = 2048;
          *(double *)&buf[46] = v113;
          _os_log_debug_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Histogram has been populated countItems=%d currentTimeDelta=%f _lastComputedVPLR=%2.2f", buf, 0x36u);
        }
      }
      *(_DWORD *)(a1 + 196) = 0;
      v29 = a1 + 344;
      v30 = 0.0;
      for (i = 1; i != 32; ++i)
      {
        v32 = 0;
        v33 = a1 + 140 * i;
        *(_DWORD *)(v33 + 328) = 0;
        v34 = 0.0;
        do
        {
          v34 = v34 + *(float *)(v29 + v32);
          *(float *)(v33 + 328) = v34;
          v30 = v30 + *(float *)(v29 + v32);
          v32 += 4;
        }
        while (v32 != 124);
        if (v34 == 0.0)
        {
          v35 = a1 + 140 * i;
          *(_WORD *)(v35 + 336) = 0;
          *(_WORD *)(v35 + 332) = 0;
        }
        else
        {
          v36 = 0;
          v37 = *(double *)(a1 + 16) * v34;
          v38 = a1 + 140 * i;
          v39 = (_WORD *)(v38 + 336);
          v40 = (_WORD *)(v38 + 332);
          v41 = 0.0;
          do
          {
            if (v36 == 31)
              break;
            v42 = *(float *)(v29 + 4 * v36);
            v43 = v36++ + 2;
            v41 = v41 + v42;
            *v39 = v36;
            *v40 = v43;
          }
          while (v41 < v37);
        }
        v29 += 140;
      }
      v44 = 0;
      *(float *)(a1 + 196) = v30;
      v45 = (float *)(a1 + 892);
      v46 = 1;
      for (j = 4; j != 32; ++j)
      {
        v48 = *(unsigned __int16 *)v45;
        if (v48 <= v44)
        {
          if (v48 == 1 || v48 < v44 || *(double *)(a1 + 48) > (float)(*(v45 - 1) / v30))
          {
            v49 = vcvtps_s32_f32((float)((float)v44 / (float)v46) * (float)(unsigned __int16)j);
            if (v48 <= v49)
              LOWORD(v48) = v49;
            *(_WORD *)v45 = v48;
          }
        }
        else
        {
          v46 = j;
          v44 = *(_WORD *)v45;
        }
        v45 += 35;
      }
      v50 = 0;
      v51 = -4340;
      do
      {
        v52 = v50;
        if (v50 >= *(unsigned __int16 *)(a1 + 472 + v51 + 4340))
          v52 = *(_WORD *)(a1 + 472 + v51 + 4340);
        if (!v50)
          v52 = *(_WORD *)(a1 + 472 + v51 + 4340);
        if (*(_WORD *)(a1 + 472 + v51 + 4340))
          v50 = v52;
        v51 += 140;
      }
      while (v51);
      v53 = a1 + 472;
      v54 = -4340;
      do
      {
        if (*(unsigned __int16 *)(v53 + v54 + 4340) >= v50)
          break;
        *(_WORD *)(v53 + v54 + 4340) = v50;
        v54 += 140;
      }
      while (v54);
      v55 = 0;
      v56 = 1;
      v57 = -4340;
      do
      {
        if (*(_WORD *)(a1 + v57 + 4812))
          ++v55;
        v56 &= *(unsigned __int16 *)(a1 + v57 + 4814) == *(unsigned __int16 *)(a1 + v57 + 4812);
        v57 += 140;
      }
      while (v57);
      if ((v56 & 1) == 0)
      {
        v58 = 0;
        v59 = (_WORD *)(a1 + 474);
        for (k = 1; k != 32; ++k)
        {
          v61 = *(v59 - 1);
          if (!v55 || *(v59 - 1))
          {
            v62 = (_BYTE *)(a1 + 2 * v58 + 4682);
            *v62 = k;
            v62[1] = v61;
            ++v58;
          }
          *v59 = v61;
          v59 += 70;
        }
        *(_WORD *)(a1 + 4680) = v58;
        *(_BYTE *)(a1 + 81) = 1;
      }
      if (*(_BYTE *)(a1 + 56))
      {
        if (*(_BYTE *)(a1 + 80))
        {
          memset(buf, 0, 500);
          __sprintf_chk((char *)buf, 0, 0x1F4uLL, "{\"measuredLoss\"\t:{");
          v63 = (unsigned __int16 *)(a1 + 476);
          for (m = 1; m != 32; ++m)
          {
            if (m <= 1)
              v65 = "";
            else
              v65 = ",";
            v66 = *v63;
            v63 += 70;
            __sprintf_chk((char *)buf, 0, 0x1F4uLL, "%s%s\"%d\":%2d\t", (const char *)buf, v65, m, v66);
          }
          VRLogfilePrintWithTimestamp(*(_QWORD *)(a1 + 64), "%s}}\n", v67, v68, v69, v70, v71, v72, (char)buf);
          RedundancyLevelFromPLR = _VCRedundancyControlAlgorithmVideo_GetRedundancyLevelFromPLR(*(double *)(a1 + 120));
          v74 = FECUtil_FECPercentageToLevelofProtection(RedundancyLevelFromPLR);
          v75 = FECUtil_ParityGroupTransmissionCountForFECLevel(v74);
          *(_WORD *)(a1 + 128) = 32;
          v76 = (_BYTE *)(a1 + 133);
          for (n = 1; n != 32; ++n)
          {
            RealNumParity = FECUtil_GetRealNumParity(n, v74);
            *(v76 - 1) = n;
            *v76 = RealNumParity * v75;
            v76 += 2;
          }
          __sprintf_chk((char *)buf, 0, 0x1F4uLL, "{\"vector\"\t:{");
          v79 = (unsigned __int16 *)(a1 + 472);
          for (ii = 1; ii != 32; ++ii)
          {
            v81 = *v79;
            v79 += 70;
            v82 = v75 * v81;
            if (ii <= 1)
              v83 = "";
            else
              v83 = ",";
            __sprintf_chk((char *)buf, 0, 0x1F4uLL, "%s%s\"%d\":%2d\t", (const char *)buf, v83, ii, v82);
          }
          VRLogfilePrintWithTimestamp(*(_QWORD *)(a1 + 64), "%s}}\n", v84, v85, v86, v87, v88, v89, (char)buf);
          __sprintf_chk((char *)buf, 0, 0x1F4uLL, "{\"vectorPLR\"\t:{");
          v90 = (unsigned __int8 *)(a1 + 133);
          for (jj = 1; jj != 32; ++jj)
          {
            if (jj <= 1)
              v92 = "";
            else
              v92 = ",";
            v93 = *v90;
            v90 += 2;
            __sprintf_chk((char *)buf, 0, 0x1F4uLL, "%s%s\"%d\":%2d\t", (const char *)buf, v92, jj, v93);
          }
          VRLogfilePrintWithTimestamp(*(_QWORD *)(a1 + 64), "%s}}\n", v94, v95, v96, v97, v98, v99, (char)buf);
        }
        else if (*(_BYTE *)(a1 + 81))
        {
          memset(&buf[6], 0, 494);
          v100 = -4340;
          qmemcpy(buf, "-\t-\t-\t", 6);
          do
          {
            __sprintf_chk((char *)buf, 0, 0x1F4uLL, "%s%d\t", (const char *)buf, *(unsigned __int16 *)(a1 + 474 + v100 + 4340));
            v100 += 140;
          }
          while (v100);
          __sprintf_chk((char *)buf, 0, 0x1F4uLL, "%s\t", (const char *)buf);
          VRLogfilePrintWithTimestamp(*(_QWORD *)(a1 + 64), "%s\n", v101, v102, v103, v104, v105, v106, (char)buf);
        }
      }
      if (*(_BYTE *)(a1 + 81))
      {
        v107 = 0;
        *(_OWORD *)a2 = *(_OWORD *)(a1 + 4680);
        v108 = *(_OWORD *)(a1 + 4696);
        v109 = *(_OWORD *)(a1 + 4712);
        v110 = *(_OWORD *)(a1 + 4728);
        *(_WORD *)(a2 + 64) = *(_WORD *)(a1 + 4744);
        *(_OWORD *)(a2 + 32) = v109;
        *(_OWORD *)(a2 + 48) = v110;
        *(_OWORD *)(a2 + 16) = v108;
        *(_BYTE *)(a1 + 81) = 0;
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() < 8)
      {
        return 2150826001;
      }
      else
      {
        v114 = VRTraceErrorLogLevelToCSTR();
        v115 = *MEMORY[0x1E0CF2758];
        v116 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          v107 = 2150826001;
          if (os_log_type_enabled(v116, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = v114;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "VCFECFeedbackAnalyzer_GetFECLevelVector";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 478;
            _os_log_impl(&dword_1D8A54000, v115, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d output not ready", buf, 0x1Cu);
          }
        }
        else
        {
          v107 = 2150826001;
          if (os_log_type_enabled(v116, OS_LOG_TYPE_DEBUG))
            VCFECFeedbackAnalyzer_GetFECLevelVector_cold_3();
        }
      }
    }
    else
    {
      v107 = 2150825985;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCFECFeedbackAnalyzer_GetFECLevelVector_cold_2();
      }
    }
  }
  else
  {
    v107 = 2150825985;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCFECFeedbackAnalyzer_GetFECLevelVector_cold_1();
    }
  }
  return v107;
}

double VCFECFeedbackAnalyzer_GetVPLR(uint64_t a1)
{
  if (a1)
    return *(double *)(a1 + 112);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCFECFeedbackAnalyzer_GetVPLR_cold_1();
  }
  return NAN;
}

uint64_t VCFECFeedbackAnalyzer_CleanHistory(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  if (a1)
  {
    bzero(*(void **)(a1 + 88), 16 * *(int *)(a1 + 32));
    *(_DWORD *)(a1 + 82) = 0;
    v2 = -4340;
    do
    {
      *(_WORD *)(a1 + 472 + v2 + 4340) = 0;
      v2 += 140;
    }
    while (v2);
    return 0;
  }
  else
  {
    v3 = 2150825985;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCFECFeedbackAnalyzer_CleanHistory_cold_1();
    }
  }
  return v3;
}

void _VCFECFeedbackAnalyzer_Init(uint64_t a1)
{
  bzero((void *)(a1 + 16), 0x1280uLL);
}

void _VCFECFeedbackAnalyzer_Finalize(uint64_t a1)
{
  uint64_t v2;
  void *v3;

  v2 = *(_QWORD *)(a1 + 64);
  if (v2)
  {
    LogDump_CloseLog(v2);
    *(_QWORD *)(a1 + 64) = 0;
  }
  v3 = *(void **)(a1 + 88);
  if (v3)
    free(v3);
}

uint64_t CannedVideoCapture_OnVideoFrame(uint64_t a1, __CVBuffer *a2, uint64_t a3)
{
  pthread_mutex_t *v6;
  CMSampleBufferRef v7;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v6 = *(pthread_mutex_t **)(a1 + 144);
  pthread_mutex_lock(v6);
  if (v6[1].__opaque[0])
  {
    v9 = *(_OWORD *)a3;
    v10 = *(_QWORD *)(a3 + 16);
    v7 = createSampleBufferWithPixelBuffer(a2, &v9);
    v9 = *(_OWORD *)a3;
    v10 = *(_QWORD *)(a3 + 16);
    VCVideoCapture_DistributeVideoFrame(a1, (uint64_t)v7, &v9, (uint64_t)&v6[1].__opaque[4]);
    FigSampleBufferRelease();
  }
  return pthread_mutex_unlock(v6);
}

uint64_t VCVideoTransmitter_SetAudioSampleTime(uint64_t result, int a2, double a3)
{
  if (result)
  {
    *(double *)(result + 104) = a3;
    *(_DWORD *)(result + 100) = a2;
  }
  return result;
}

uint64_t VCVideoTransmitter_SetMediaQueueSize(uint64_t result)
{
  uint64_t (*v1)(void);

  if (result)
  {
    v1 = *(uint64_t (**)(void))(result + 144);
    if (v1)
      return v1();
  }
  return result;
}

uint64_t VCVideoTransmitter_SetFECRatio(uint64_t result)
{
  uint64_t (*v1)(void);

  if (result)
  {
    v1 = *(uint64_t (**)(void))(result + 128);
    if (v1)
      return v1();
  }
  return result;
}

uint64_t VCVideoTransmitter_EnqueueVideoFrame(uint64_t result, uint64_t a2, __int128 *a3, uint64_t a4)
{
  uint64_t (*v4)(uint64_t, uint64_t, __int128 *, uint64_t);
  __int128 v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v4 = *(uint64_t (**)(uint64_t, uint64_t, __int128 *, uint64_t))(result + 136);
    if (v4)
    {
      v5 = *a3;
      v6 = *((_QWORD *)a3 + 2);
      return v4(result, a2, &v5, a4);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t VCClientRelayVTPReceiveProc(void *a1)
{
  uint64_t v2;
  NSObject *v3;
  int v5;
  uint64_t v6;
  __int16 v7;
  const char *v8;
  __int16 v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  while ((objc_msgSend(a1, "stopVTPReceiveThread") & 1) == 0 && (objc_msgSend(a1, "relayVTPPacket") & 1) != 0)
    ;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v5 = 136315650;
      v6 = v2;
      v7 = 2080;
      v8 = "VCClientRelayVTPReceiveProc";
      v9 = 1024;
      v10 = 315;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCCR - VCClientRelayVTPReceiveProc stop!", (uint8_t *)&v5, 0x1Cu);
    }
  }
  return 0;
}

void OUTLINED_FUNCTION_2_10(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x2Eu);
}

uint64_t RTPProcessHEVCFragmentationHeader(unsigned __int8 *a1, int a2, unsigned int *a3, int *a4, _WORD *a5, _BYTE *a6, int a7, int *a8)
{
  int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  NSObject *v15;
  NSObject *v16;
  int v17;
  int v19;
  uint64_t v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  int v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (a2 > 0)
  {
    v9 = (*a1 >> 1) & 0x3F;
    if (a8)
      *a8 = v9;
    if (v9 == 49)
    {
      if (a7)
        v10 = 5;
      else
        v10 = 3;
      if (v10 > a2)
      {
        v11 = 2147549199;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            RTPProcessHEVCFragmentationHeader_cold_2();
        }
        return v11;
      }
      v13 = a1[2];
      if (a3)
        *a3 = v13 >> 7;
      if (a4)
        *a4 = (v13 >> 6) & 1;
      if ((a7 & 1) != 0)
      {
        v12 = 3;
        goto LABEL_28;
      }
    }
    else
    {
      if (a3)
        *a3 = 1;
      if (a4)
        *a4 = 1;
      if (a7 && v9 != 38)
      {
        v12 = 2;
LABEL_28:
        *a5 = bswap32(*(unsigned __int16 *)&a1[v12]) >> 16;
        *a6 = 1;
      }
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v14 = VRTraceErrorLogLevelToCSTR();
      v15 = *MEMORY[0x1E0CF2758];
      v16 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        v11 = 0;
        if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          return v11;
        v17 = (unsigned __int16)*a5;
        v19 = 136315906;
        v20 = v14;
        v21 = 2080;
        v22 = "RTPProcessHEVCFragmentationHeader";
        v23 = 1024;
        v24 = 103;
        v25 = 1024;
        v26 = v17;
        _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Received decoding order is %hu", (uint8_t *)&v19, 0x22u);
      }
      else if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
      {
        RTPProcessHEVCFragmentationHeader_cold_3();
      }
    }
    return 0;
  }
  v11 = 2147549199;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      RTPProcessHEVCFragmentationHeader_cold_1();
  }
  return v11;
}

uint64_t RTPProcessHEVCPacket(int a1, _BYTE *a2, BOOL *a3, _WORD *a4, _BYTE *a5, int a6, const __CFAllocator *a7, const __CFAllocator *a8, uint64_t a9, CMBlockBufferRef theBuffer)
{
  uint64_t v10;
  unint64_t v11;
  unsigned __int8 *v15;
  int v16;
  int v17;
  unsigned __int8 *v18;
  uint64_t v19;
  char v20;
  unsigned __int8 *v21;
  unsigned int v22;
  unsigned int v23;
  size_t v24;
  int v25;
  char *DataPointer;
  unint64_t v27;
  uint64_t v28;
  NSObject *v29;
  NSObject *v30;
  int v31;
  unsigned __int8 v32;
  char *v33;
  uint64_t v34;
  NSObject *v35;
  NSObject *v36;
  int v37;
  size_t v38;
  size_t v39;
  char *v40;
  int v41;
  uint64_t v42;
  NSObject *v43;
  NSObject *v44;
  _BOOL4 v45;
  int v46;
  _BOOL4 v47;
  int v48;
  int v50;
  _WORD *v51;
  CMBlockBufferRef targetBBuf;
  uint8_t buf[4];
  uint64_t v56;
  __int16 v57;
  const char *v58;
  __int16 v59;
  int v60;
  __int16 v61;
  int v62;
  __int16 v63;
  int v64;
  __int16 v65;
  int v66;
  uint64_t v67;

  v67 = *MEMORY[0x1E0C80C00];
  v10 = 2147549199;
  targetBBuf = 0;
  v11 = *(_QWORD *)(a9 + 8);
  if ((int)v11 < 1)
    return v10;
  v15 = *(unsigned __int8 **)(a9 + 16);
  v16 = (*v15 >> 1) & 0x3F;
  if (v16 != 49)
  {
    v50 = (*v15 >> 1) & 0x3F;
    v51 = a4;
    if (v16 == 48)
    {
      if (v11 > 1)
      {
        *a2 = 1;
        *a3 = 1;
        v17 = v11 - 2;
        if (v17)
        {
          v18 = (unsigned __int8 *)(*(_QWORD *)(a9 + 16) + 2);
          v19 = 2;
          v20 = 1;
          while (1)
          {
            if ((v20 & 1) != 0)
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
                VideoUtil_PrintBuffer(v18, (uint64_t)"Rx Aggregation Packet", v17);
              if (a6)
              {
                if (v17 <= 1)
                {
                  if ((int)VRTraceGetErrorLogLevelForModule() < 3)
                    goto LABEL_93;
                  VRTraceErrorLogLevelToCSTR();
                  v10 = 2147549199;
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                    RTPProcessHEVCPacket_cold_8();
                  goto LABEL_69;
                }
                *v51 = bswap32(*(unsigned __int16 *)(*(_QWORD *)(a9 + 16) + 2)) >> 16;
                *a5 = 1;
                v18 += 2;
                v19 += 2;
                v17 -= 2;
              }
            }
            if (v17 <= 1)
              break;
            v22 = *(unsigned __int16 *)v18;
            v21 = v18 + 2;
            v23 = bswap32(v22);
            v24 = HIWORD(v23);
            v25 = v17 - 2;
            if ((v17 - 2) < HIWORD(v23))
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                v10 = 2147549199;
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  RTPProcessHEVCPacket_cold_10();
                goto LABEL_69;
              }
LABEL_93:
              v10 = 2147549199;
              goto LABEL_69;
            }
            targetBBuf = 0;
            DataPointer = VCBlockBufferUtilities_CreateAndGetDataPointer(a7, 0, 4uLL, a8, 0, 0, 4uLL, 1u, &targetBBuf);
            if (!DataPointer)
            {
              v10 = 2147549187;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  RTPProcessHEVCPacket_cold_11();
              }
              goto LABEL_69;
            }
            *(_DWORD *)DataPointer = bswap32(v24);
            if (CMBlockBufferAppendBufferReference(theBuffer, targetBBuf, 0, 4uLL, 0))
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  RTPProcessHEVCPacket_cold_13();
              }
              goto LABEL_68;
            }
            if (CMBlockBufferAppendBufferReference(theBuffer, *(CMBlockBufferRef *)a9, v19 + 2, v24, 0))
            {
              v10 = 2147549187;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  RTPProcessHEVCPacket_cold_12();
              }
              goto LABEL_69;
            }
            if (targetBBuf)
            {
              CFRelease(targetBBuf);
              targetBBuf = 0;
            }
            v20 = 0;
            v19 += 2 + v24;
            v18 = &v21[v24];
            v17 = v25 - v24;
            if (v25 <= (int)v24)
              goto LABEL_61;
          }
          if ((int)VRTraceGetErrorLogLevelForModule() < 3)
            goto LABEL_93;
          VRTraceErrorLogLevelToCSTR();
          v10 = 2147549199;
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            RTPProcessHEVCPacket_cold_9();
          goto LABEL_69;
        }
LABEL_61:
        if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          v42 = VRTraceErrorLogLevelToCSTR();
          v43 = *MEMORY[0x1E0CF2758];
          v44 = *MEMORY[0x1E0CF2758];
          if (*MEMORY[0x1E0CF2748])
          {
            v45 = os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT);
            v10 = 0;
            v46 = (int)v51;
            if (!v45)
              goto LABEL_69;
            if (v51)
              v46 = (unsigned __int16)*v51;
            *(_DWORD *)buf = 136316418;
            v56 = v42;
            v57 = 2080;
            v58 = "RTPProcessHEVCPacket";
            v59 = 1024;
            v60 = 326;
            v61 = 1024;
            v62 = v50;
            v63 = 1024;
            v64 = v46;
            v65 = 1024;
            v66 = a6;
            _os_log_impl(&dword_1D8A54000, v43, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Received packet with NAL unit type %d, decoding order %u, shouldProcessDecodingOrder %d", buf, 0x2Eu);
          }
          else
          {
            v47 = os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG);
            v48 = (int)v51;
            if (v47)
            {
              if (v51)
                v48 = (unsigned __int16)*v51;
              *(_DWORD *)buf = 136316418;
              v56 = v42;
              v57 = 2080;
              v58 = "RTPProcessHEVCPacket";
              v59 = 1024;
              v60 = 326;
              v61 = 1024;
              v62 = v50;
              v63 = 1024;
              v64 = v48;
              v65 = 1024;
              v66 = a6;
              _os_log_debug_impl(&dword_1D8A54000, v43, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Received packet with NAL unit type %d, decoding order %u, shouldProcessDecodingOrder %d", buf, 0x2Eu);
            }
          }
        }
LABEL_68:
        v10 = 0;
        goto LABEL_69;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          RTPProcessHEVCPacket_cold_7();
      }
    }
    else
    {
      if (v11 <= 1)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            RTPProcessHEVCPacket_cold_1();
        }
        goto LABEL_69;
      }
      *a2 = 1;
      *a3 = 1;
      if (a6)
      {
        if (v11 <= 3)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              RTPProcessHEVCPacket_cold_2();
          }
          goto LABEL_69;
        }
        *a4 = bswap32(*(unsigned __int16 *)(*(_QWORD *)(a9 + 16) + 2)) >> 16;
        *a5 = 1;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          v28 = VRTraceErrorLogLevelToCSTR();
          v29 = *MEMORY[0x1E0CF2758];
          v30 = *MEMORY[0x1E0CF2758];
          if (*MEMORY[0x1E0CF2748])
          {
            if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
            {
              v31 = (unsigned __int16)*a4;
              *(_DWORD *)buf = 136315906;
              v56 = v28;
              v57 = 2080;
              v58 = "RTPProcessHEVCPacket";
              v59 = 1024;
              v60 = 304;
              v61 = 1024;
              v62 = v31;
              _os_log_impl(&dword_1D8A54000, v29, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Received decoding order is %hu", buf, 0x22u);
            }
          }
          else if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
          {
            RTPProcessHEVCPacket_cold_6();
          }
        }
        v38 = 4;
      }
      else
      {
        v38 = 2;
      }
      v40 = VCBlockBufferUtilities_CreateAndGetDataPointer(a7, 0, 6uLL, a8, 0, 0, 6uLL, 1u, &targetBBuf);
      if (v40)
      {
        if (a6)
          v41 = -2;
        else
          v41 = 0;
        *(_DWORD *)v40 = bswap32(*(_DWORD *)(a9 + 8) + v41);
        v40[4] = **(_BYTE **)(a9 + 16);
        v40[5] = *(_BYTE *)(*(_QWORD *)(a9 + 16) + 1);
        if (CMBlockBufferAppendBufferReference(theBuffer, targetBBuf, 0, 6uLL, 0))
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              RTPProcessHEVCPacket_cold_5();
          }
          goto LABEL_68;
        }
        if (!CMBlockBufferAppendBufferReference(theBuffer, *(CMBlockBufferRef *)a9, v38, *(_QWORD *)(a9 + 8) - v38, 0))
          goto LABEL_61;
        v10 = 2147549187;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            RTPProcessHEVCPacket_cold_4();
        }
      }
      else
      {
        v10 = 2147549187;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            RTPProcessHEVCPacket_cold_3();
        }
      }
    }
LABEL_69:
    if (targetBBuf)
      CFRelease(targetBBuf);
    return v10;
  }
  v27 = 3;
  if (a6)
    v27 = 5;
  if (v11 >= v27)
  {
    v50 = 49;
    v32 = v15[2];
    *a2 = v32 >> 7;
    *a3 = (v32 & 0x40) != 0;
    if (*a2)
    {
      v33 = VCBlockBufferUtilities_CreateAndGetDataPointer(a7, 0, 6uLL, a8, 0, 0, 6uLL, 1u, &targetBBuf);
      if (!v33)
      {
        v10 = 2147549187;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            RTPProcessHEVCPacket_cold_17();
        }
        goto LABEL_69;
      }
      *(_DWORD *)v33 = bswap32(*(_DWORD *)(a9 + 8) - 1);
      v33[4] = **(_BYTE **)(a9 + 16) & 0x81 | (2 * (v32 & 0x3F));
      v33[5] = *(_BYTE *)(*(_QWORD *)(a9 + 16) + 1);
      if (CMBlockBufferAppendBufferReference(theBuffer, targetBBuf, 0, 6uLL, 0))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            RTPProcessHEVCPacket_cold_18();
        }
        goto LABEL_68;
      }
    }
    v51 = a4;
    if (a6)
    {
      *a4 = bswap32(*(unsigned __int16 *)(*(_QWORD *)(a9 + 16) + 3)) >> 16;
      *a5 = 1;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v34 = VRTraceErrorLogLevelToCSTR();
        v35 = *MEMORY[0x1E0CF2758];
        v36 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
          {
            v37 = (unsigned __int16)*a4;
            *(_DWORD *)buf = 136315906;
            v56 = v34;
            v57 = 2080;
            v58 = "RTPProcessHEVCPacket";
            v59 = 1024;
            v60 = 273;
            v61 = 1024;
            v62 = v37;
            _os_log_impl(&dword_1D8A54000, v35, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Received decoding order is %hu", buf, 0x22u);
          }
        }
        else if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
        {
          RTPProcessHEVCPacket_cold_16();
        }
      }
      v39 = 5;
    }
    else
    {
      v39 = 3;
    }
    if (!CMBlockBufferAppendBufferReference(theBuffer, *(CMBlockBufferRef *)a9, v39, *(_QWORD *)(a9 + 8) - v39, 0))
      goto LABEL_61;
    v10 = 2147549187;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RTPProcessHEVCPacket_cold_15();
    }
    goto LABEL_69;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      RTPProcessHEVCPacket_cold_14();
  }
  return v10;
}

uint64_t VCAudioToolbox_AudioComponentFindNext()
{
  return _audioComponentStub();
}

uint64_t VCAudioToolbox_AudioComponentInstanceNew()
{
  return off_1ED10CCE0();
}

uint64_t VCAudioToolbox_AudioComponentInstanceDispose()
{
  return off_1ED10CCE8();
}

uint64_t VCAudioToolbox_AudioComponentCopyName()
{
  return off_1ED10CCF8();
}

uint64_t VCAudioBufferList_Allocate(__int128 *a1, int a2, _QWORD *a3)
{
  unsigned int v6;
  int v7;
  int v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  char *v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  int v17;
  uint64_t result;
  char *v19;
  int v20;
  char **v21;

  if (!a2 || !a3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!(_DWORD)result)
        return result;
      VCAudioBufferList_Allocate_cold_1();
    }
    return 0;
  }
  *a3 = 0;
  v6 = *((_DWORD *)a1 + 7);
  v7 = *((_DWORD *)a1 + 3);
  v8 = *((_DWORD *)a1 + 4);
  if ((v7 & 0x20) != 0)
    v9 = v6;
  else
    v9 = 1;
  if ((v7 & 0x20) != 0)
    v10 = 1;
  else
    v10 = *((_DWORD *)a1 + 7);
  v11 = 16 * (v9 - 1) + 184;
  v12 = v11 + v6 * a2 * v8;
  v13 = (char *)malloc_type_calloc(1uLL, v11 + v6 * a2 * v8, 0xEC3E06ACuLL);
  if (v13)
  {
    *(_DWORD *)v13 = v12;
    v14 = *a1;
    v15 = a1[1];
    *((_QWORD *)v13 + 5) = *((_QWORD *)a1 + 4);
    *(_OWORD *)(v13 + 24) = v15;
    *(_OWORD *)(v13 + 8) = v14;
    v16 = (*((_DWORD *)a1 + 4) * a2);
    *((_DWORD *)v13 + 22) = a2;
    *((_DWORD *)v13 + 23) = v16;
    if ((*((_BYTE *)a1 + 12) & 0x20) != 0)
      v17 = *((_DWORD *)a1 + 7);
    else
      v17 = 1;
    *((_DWORD *)v13 + 21) = v17;
    v13[96] = 0;
    *((int64x2_t *)v13 + 8) = vdupq_n_s64(0x7FF8000000000000uLL);
    v13[73] = 0;
    if ((_DWORD)v9)
    {
      v19 = &v13[v11];
      v20 = *((_DWORD *)v13 + 40);
      v21 = (char **)(v13 + 176);
      do
      {
        *v21 = v19;
        ++v20;
        v19 += v16;
        *((_DWORD *)v21 - 2) = v10;
        *((_DWORD *)v21 - 1) = v16;
        v21 += 2;
        --v9;
      }
      while (v9);
      *((_DWORD *)v13 + 40) = v20;
    }
    *a3 = v13;
    return 1;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioBufferList_Allocate_cold_2();
    }
    return *a3 != 0;
  }
}

void VCAudioBufferList_Destroy(uint64_t *a1)
{
  uint64_t v1;
  const __CFAllocator *v2;
  uint64_t v3;
  NSObject *v4;
  int v5;
  uint64_t v6;
  __int16 v7;
  const char *v8;
  __int16 v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (a1 && (v1 = *a1) != 0)
  {
    *a1 = 0;
    if (*(_BYTE *)(v1 + 144))
    {
      v2 = *(const __CFAllocator **)(v1 + 152);
      CFAllocatorDeallocate(v2, (void *)v1);
      if (v2)
        CFRelease(v2);
    }
    else
    {
      free((void *)v1);
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v3 = VRTraceErrorLogLevelToCSTR();
    v4 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v5 = 136315650;
      v6 = v3;
      v7 = 2080;
      v8 = "VCAudioBufferList_Destroy";
      v9 = 1024;
      v10 = 178;
      _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Nothing to do. The audio buffer list is already NULL", (uint8_t *)&v5, 0x1Cu);
    }
  }
}

uint64_t VCAudioBufferList_AllocateFrame(uint64_t a1, _QWORD *a2)
{
  int v3;
  __int128 v4;
  __int128 v6[2];
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v3 = *(_DWORD *)(a1 + 40);
  v4 = *(_OWORD *)(a1 + 16);
  v6[0] = *(_OWORD *)a1;
  v6[1] = v4;
  v7 = *(_QWORD *)(a1 + 32);
  return VCAudioBufferList_Allocate(v6, v3, a2);
}

void VCAudioBufferList_ZeroMemory(uint64_t a1)
{
  unint64_t v2;
  void **v3;

  if (a1)
  {
    if (*(_DWORD *)(a1 + 160))
    {
      v2 = 0;
      v3 = (void **)(a1 + 176);
      do
      {
        bzero(*v3, *((unsigned int *)v3 - 1));
        ++v2;
        v3 += 2;
      }
      while (v2 < *(unsigned int *)(a1 + 160));
    }
    *(_BYTE *)(a1 + 72) = 0;
    *(_DWORD *)(a1 + 76) = 0;
    *(_BYTE *)(a1 + 64) = 1;
    *(_DWORD *)(a1 + 68) = -1024458752;
    *(_QWORD *)(a1 + 128) = 0;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioBufferList_ZeroMemory_cold_1();
  }
}

void VCAudioBufferList_InvalidateStats(uint64_t a1)
{
  if (a1)
  {
    *(_BYTE *)(a1 + 72) = 0;
    *(_DWORD *)(a1 + 76) = 0;
    *(_BYTE *)(a1 + 64) = 1;
    *(_DWORD *)(a1 + 68) = -1024458752;
    *(_QWORD *)(a1 + 128) = 0;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioBufferList_InvalidateStats_cold_1();
  }
}

BOOL VCAudioBufferList_ApplyGain(uint64_t a1, float a2)
{
  _BOOL8 result;
  unint64_t v4;
  float **v5;
  float *v6;
  float v7;
  int v8;
  float __B;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  __B = a2;
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      VCAudioBufferList_ApplyGain_cold_1();
    }
    return 0;
  }
  if ((*(_BYTE *)(a1 + 20) & 0x20) == 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      VCAudioBufferList_ApplyGain_cold_2();
    }
    return 0;
  }
  if (*(_DWORD *)(a1 + 160))
  {
    v4 = 0;
    v5 = (float **)(a1 + 176);
    do
    {
      v6 = *v5;
      if ((*(_BYTE *)(a1 + 20) & 1) != 0)
      {
        vDSP_vsmul(v6, 1, &__B, *v5, 1, *(unsigned int *)(a1 + 80));
      }
      else
      {
        v7 = __B * 32768.0;
        if (__B <= 0.0)
        {
          v8 = (int)(float)((float)(__B * 32768.0) + -0.5);
          if (v7 < -32768.0)
            LOWORD(v8) = 0x8000;
        }
        else
        {
          v8 = (int)(float)((float)(__B * 32768.0) + 0.5);
          if (v7 > 32767.0)
            LOWORD(v8) = 0x7FFF;
        }
        VSMUL_Q15_Portable((__int16 *)v6, (__int16)v8, *v5, *(_DWORD *)(a1 + 80));
      }
      ++v4;
      v5 += 2;
    }
    while (v4 < *(unsigned int *)(a1 + 160));
  }
  return 1;
}

BOOL VCAudioBufferList_Mix(uint64_t a1, uint64_t a2)
{
  _BOOL8 result;
  int v5;
  int v6;
  int v7;
  unint64_t v8;
  _QWORD *v9;
  __int16 **v10;
  int v11;
  __int16 *v12;
  __int16 *v13;
  __int16 *v14;
  uint64_t v15;
  NSObject *v16;
  int v17;
  int v18;
  unint64_t v19;
  float **v20;
  const float **v21;
  vDSP_Length v22;
  float *v23;
  float *v24;
  const float *v25;
  unsigned int v26;
  unsigned int v27;
  char v28;
  BOOL v29;
  double v30;
  char v31;
  unsigned int v32;
  unsigned int v33;
  int v34;
  unsigned int v35;
  BOOL v36;
  char v37;
  char v38;
  int v39;
  char v40;
  int v41;
  uint64_t v42;
  __int16 v43;
  const char *v44;
  __int16 v45;
  int v46;
  __int16 v47;
  int v48;
  __int16 v49;
  int v50;
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  if (!a1 || !a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      VCAudioBufferList_Mix_cold_3();
    }
    return 0;
  }
  if (memcmp((const void *)(a1 + 8), (const void *)(a2 + 8), 0x28uLL))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      VCAudioBufferList_Mix_cold_2();
    }
    return 0;
  }
  v5 = *(_DWORD *)(a1 + 20);
  if ((v5 & 0x20) == 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      VCAudioBufferList_Mix_cold_1();
    }
    return 0;
  }
  v6 = *(_DWORD *)(a1 + 80);
  if (v6 == *(_DWORD *)(a2 + 80))
  {
    if (v6)
    {
      v7 = *(_DWORD *)(a1 + 160);
      if ((v5 & 1) != 0)
      {
        if (v7)
        {
          v19 = 0;
          v20 = (float **)(a1 + 176);
          v21 = (const float **)(a2 + 176);
          do
          {
            v22 = (unint64_t)*((unsigned int *)v20 - 1) >> 2;
            v24 = *v20;
            v20 += 2;
            v23 = v24;
            v25 = *v21;
            v21 += 2;
            vDSP_vadd(v23, 1, v25, 1, v23, 1, v22);
            ++v19;
          }
          while (v19 < *(unsigned int *)(a1 + 160));
        }
      }
      else if (v7)
      {
        v8 = 0;
        v9 = (_QWORD *)(a1 + 176);
        v10 = (__int16 **)(a2 + 176);
        do
        {
          v11 = *((_DWORD *)v9 - 1) >> 1;
          v13 = (__int16 *)*v9;
          v9 += 2;
          v12 = v13;
          v14 = *v10;
          v10 += 2;
          VADD_Q15_Portable(v12, v14, v12, v11);
          ++v8;
        }
        while (v8 < *(unsigned int *)(a1 + 160));
      }
      v26 = *(unsigned __int8 *)(a1 + 96);
      if (v26 != 255)
      {
        v27 = *(unsigned __int8 *)(a2 + 96);
        v28 = v26 <= v27 ? *(_BYTE *)(a2 + 96) : *(_BYTE *)(a1 + 96);
        v29 = !*(_BYTE *)(a2 + 96) || v26 == 0;
        LOBYTE(v26) = v29 ? 0 : v28;
        if (v27 == 255)
          LOBYTE(v26) = -1;
      }
      *(_BYTE *)(a1 + 96) = v26;
      v30 = *(double *)(a1 + 128);
      if (v30 <= *(double *)(a2 + 128))
        v30 = *(double *)(a2 + 128);
      *(double *)(a1 + 128) = v30;
      v31 = *(_BYTE *)(a2 + 73);
      if (v31)
        v31 = *(_BYTE *)(a1 + 73) != 0;
      *(_BYTE *)(a1 + 73) = v31;
      *(_BYTE *)(a1 + 64) = 0;
      v32 = *(_DWORD *)(a2 + 76);
      if (v32)
      {
        v33 = *(_DWORD *)(a1 + 76);
        v34 = *(unsigned __int8 *)(a1 + 72);
        if (v33)
        {
          if (v32 >= v33)
            v35 = *(_DWORD *)(a1 + 76);
          else
            v35 = *(_DWORD *)(a2 + 76);
          if (!*(_BYTE *)(a2 + 72))
            v35 = 0;
          if (v32 <= v33)
            v32 = *(_DWORD *)(a1 + 76);
          if (*(_BYTE *)(a2 + 72))
            v32 = 0;
          v36 = v34 == 0;
          if (*(_BYTE *)(a1 + 72))
            v37 = 1;
          else
            v37 = *(_BYTE *)(a2 + 72);
          if (!v36)
            v32 = v35;
          *(_BYTE *)(a1 + 72) = v37;
          *(_DWORD *)(a1 + 76) = v32;
          return 1;
        }
        if (*(_BYTE *)(a1 + 72))
          v32 = 0;
        *(_DWORD *)(a1 + 76) = v32;
        if (v34)
          v40 = 1;
        else
          v40 = *(_BYTE *)(a2 + 72) != 0;
      }
      else
      {
        v38 = *(_BYTE *)(a2 + 72);
        if (v38)
          v39 = 0;
        else
          v39 = *(_DWORD *)(a1 + 76);
        *(_DWORD *)(a1 + 76) = v39;
        v40 = *(_BYTE *)(a1 + 72) | v38;
      }
      *(_BYTE *)(a1 + 72) = v40;
    }
    return 1;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v15 = VRTraceErrorLogLevelToCSTR();
    v16 = *MEMORY[0x1E0CF2758];
    result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    v17 = *(_DWORD *)(a2 + 80);
    v18 = *(_DWORD *)(a1 + 80);
    v41 = 136316162;
    v42 = v15;
    v43 = 2080;
    v44 = "VCAudioBufferList_Mix";
    v45 = 1024;
    v46 = 274;
    v47 = 1024;
    v48 = v17;
    v49 = 1024;
    v50 = v18;
    _os_log_error_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_ERROR, " [%s] %s:%d Sample count mismatch: source=%u dest=%u don't match", (uint8_t *)&v41, 0x28u);
  }
  return 0;
}

BOOL VCAudioBufferList_MixToMono(uint64_t a1, uint64_t a2)
{
  _BOOL8 result;
  vDSP_Length v5;
  unsigned int v6;
  unsigned int *v7;
  unint64_t v8;
  const float **v9;
  const float *v10;
  char v11;
  uint64_t v12;
  NSObject *v13;
  int v14;
  int v15;
  uint64_t v16;
  NSObject *v17;
  float v18;
  uint64_t v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (!a1 || !a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      VCAudioBufferList_MixToMono_cold_4();
    }
    return 0;
  }
  if ((*(_BYTE *)(a2 + 20) & 0x20) == 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      VCAudioBufferList_MixToMono_cold_1();
    }
    return 0;
  }
  if ((*(_BYTE *)(a1 + 20) & 1) == 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      VCAudioBufferList_MixToMono_cold_2();
    }
    return 0;
  }
  v5 = *(int *)(a1 + 80);
  if ((_DWORD)v5 != *(_DWORD *)(a2 + 80))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v12 = VRTraceErrorLogLevelToCSTR();
      v13 = *MEMORY[0x1E0CF2758];
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      v14 = *(_DWORD *)(a2 + 80);
      v15 = *(_DWORD *)(a1 + 80);
      v18 = 4.8154e-34;
      v19 = v12;
      v20 = 2080;
      v21 = "VCAudioBufferList_MixToMono";
      v22 = 1024;
      v23 = 319;
      v24 = 1024;
      v25 = v14;
      v26 = 1024;
      v27 = v15;
      _os_log_error_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_ERROR, " [%s] %s:%d Sample count sourceMultiChannelBufferList=%u and destMonoBufferList=%u don't match", (uint8_t *)&v18, 0x28u);
    }
    return 0;
  }
  v7 = (unsigned int *)(a2 + 160);
  v6 = *(_DWORD *)(a2 + 160);
  if (!v6)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v16 = VRTraceErrorLogLevelToCSTR();
      v17 = *MEMORY[0x1E0CF2758];
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      VCAudioBufferList_MixToMono_cold_3(v16, (uint64_t)v7, v17);
    }
    return 0;
  }
  v8 = 0;
  v18 = 1.0 / (float)v6;
  v9 = (const float **)(a2 + 176);
  do
  {
    v10 = *v9;
    v9 += 2;
    vDSP_vadd(*(const float **)(a1 + 176), 1, v10, 1, *(float **)(a1 + 176), 1, v5);
    ++v8;
  }
  while (v8 < *v7);
  vDSP_vsmul(*(const float **)(a1 + 176), 1, &v18, *(float **)(a1 + 176), 1, v5);
  v11 = *(_BYTE *)(a1 + 73);
  if (v11)
    v11 = *(_BYTE *)(a2 + 73) != 0;
  *(_BYTE *)(a1 + 73) = v11;
  return 1;
}

uint64_t VCAudioBufferList_AppendSamples(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  uint64_t v5;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v15;
  unsigned int v16;
  unint64_t v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t v20;
  int v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  NSObject *v25;
  NSObject *v26;
  int v27;
  uint64_t v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  int v32;
  __int16 v33;
  uint64_t v34;
  __int16 v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  if (!a1 || !a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioBufferList_AppendSamples_cold_2();
    }
    return 0;
  }
  LODWORD(v5) = a4;
  v8 = (uint64_t *)(a1 + 8);
  v9 = (uint64_t *)(a2 + 8);
  if (memcmp((const void *)(a1 + 8), (const void *)(a2 + 8), 0x28uLL))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v10 = VRTraceErrorLogLevelToCSTR();
      v11 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v12 = *v9;
        v13 = *v8;
        v27 = 136316162;
        v28 = v10;
        v29 = 2080;
        v30 = "VCAudioBufferList_AppendSamples";
        v31 = 1024;
        v32 = 346;
        v33 = 2048;
        v34 = v12;
        v35 = 2048;
        v36 = v13;
        _os_log_error_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_ERROR, " [%s] %s:%d Formats don't match: source=%f dest=%f", (uint8_t *)&v27, 0x30u);
      }
    }
    return 0;
  }
  v15 = *(_DWORD *)(a2 + 80) - a3;
  v16 = *(_DWORD *)(a1 + 80);
  if (v15 >= *(_DWORD *)(a1 + 88) - v16)
    v15 = *(_DWORD *)(a1 + 88) - v16;
  if (v15 >= v5)
    v5 = v5;
  else
    v5 = v15;
  if ((_DWORD)v5)
  {
    *(double *)(a1 + 56) = (double)a3 / *(double *)(a2 + 8) + *(double *)(a2 + 56) - (double)v16 / *(double *)(a1 + 8);
    *(_DWORD *)(a1 + 48) = a3 - v16 + *(_DWORD *)(a2 + 48);
    if (*(_DWORD *)(a1 + 160))
    {
      v17 = 0;
      v18 = (uint64_t *)(a1 + 176);
      v19 = (uint64_t *)(a2 + 176);
      do
      {
        v20 = *v18;
        v18 += 2;
        v21 = *(_DWORD *)(a1 + 24);
        v22 = (void *)(v20 + (v21 * *(_DWORD *)(a1 + 80)));
        v23 = *v19;
        v19 += 2;
        memcpy(v22, (const void *)(v23 + *(_DWORD *)(a2 + 24) * a3), (v21 * v5));
        ++v17;
      }
      while (v17 < *(unsigned int *)(a1 + 160));
    }
    _VCAudioBufferList_ComputeVoiceActivityAppend(a1, a2, a3);
    VCAudioBufferList_SetSampleCount(a1, *(_DWORD *)(a1 + 80) + v5);
    *(_BYTE *)(a1 + 64) = 0;
    *(_BYTE *)(a1 + 96) = *(_BYTE *)(a2 + 96);
    *(_QWORD *)(a1 + 128) = *(_QWORD *)(a2 + 128);
    *(_BYTE *)(a1 + 73) = *(_BYTE *)(a2 + 73);
    if (v5 < *(_DWORD *)(a2 + 80) && (int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v24 = VRTraceErrorLogLevelToCSTR();
      v25 = *MEMORY[0x1E0CF2758];
      v26 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          v27 = 136315650;
          v28 = v24;
          v29 = 2080;
          v30 = "VCAudioBufferList_AppendSamples";
          v31 = 1024;
          v32 = 378;
          _os_log_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Unable to append all the source samples!", (uint8_t *)&v27, 0x1Cu);
        }
      }
      else if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
      {
        VCAudioBufferList_AppendSamples_cold_1();
      }
    }
  }
  return v5;
}

uint64_t _VCAudioBufferList_ComputeVoiceActivityAppend(uint64_t result, uint64_t a2, unsigned int a3)
{
  unsigned int v3;
  int v4;
  unsigned int v5;
  unsigned int v6;
  int v7;
  int v9;
  int v10;
  BOOL v11;

  v3 = *(_DWORD *)(a2 + 76);
  v4 = *(_DWORD *)(result + 80);
  if (*(_DWORD *)(a2 + 80) - a3 >= *(_DWORD *)(result + 88) - v4)
    v5 = *(_DWORD *)(result + 88) - v4;
  else
    v5 = *(_DWORD *)(a2 + 80) - a3;
  if (v3 >= a3)
    v6 = v3 - a3;
  else
    v6 = 0;
  v7 = *(unsigned __int8 *)(a2 + 72);
  if (v3 > a3 && v6 < v5)
  {
    if (*(_BYTE *)(a2 + 72))
    {
      if (*(_DWORD *)(result + 76))
      {
        if (*(_BYTE *)(result + 72))
          v4 = *(_DWORD *)(result + 76);
        else
          v4 = 0;
      }
      else
      {
        v4 += v6;
        if (*(_BYTE *)(result + 72))
          v4 = 0;
      }
    }
    else
    {
      v4 += v6;
    }
LABEL_32:
    *(_DWORD *)(result + 76) = v4;
    *(_BYTE *)(result + 72) = v7;
    return result;
  }
  v11 = v7 == 0;
  v7 = v7 != 0;
  v9 = v11;
  if (v3 > a3)
    v7 = v9;
  v10 = *(unsigned __int8 *)(result + 72);
  if (v10 != v7)
  {
    if (*(_DWORD *)(result + 76))
      v11 = v10 == 0;
    else
      v11 = 0;
    if (v11)
      v4 = 0;
    goto LABEL_32;
  }
  return result;
}

uint64_t VCAudioBufferList_SetSampleCount(uint64_t result, unsigned int a2)
{
  unsigned int v2;
  char v3;
  uint64_t v4;
  int v5;
  int *v6;

  if (result)
  {
    v2 = *(_DWORD *)(result + 88);
    if (v2 >= a2)
      v2 = a2;
    v3 = *(_BYTE *)(result + 64);
    if (v3)
      v3 = *(_DWORD *)(result + 80) == v2;
    *(_BYTE *)(result + 64) = v3;
    *(_DWORD *)(result + 80) = v2;
    v4 = *(unsigned int *)(result + 160);
    if ((_DWORD)v4)
    {
      v5 = *(_DWORD *)(result + 24) * v2;
      v6 = (int *)(result + 172);
      do
      {
        *v6 = v5;
        v6 += 4;
        --v4;
      }
      while (v4);
    }
  }
  return result;
}

uint64_t VCAudioBufferList_Append(uint64_t a1, uint64_t a2, unsigned int a3)
{
  return VCAudioBufferList_AppendSamples(a1, a2, a3, -1);
}

uint64_t VCAudioBufferList_AppendSilence(uint64_t a1, int a2, unsigned int a3, double a4)
{
  int v6;
  unsigned int v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  NSObject *v14;
  int v16;
  uint64_t v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v6 = *(_DWORD *)(a1 + 80);
    v7 = *(_DWORD *)(a1 + 88) - v6;
    if (v7 >= a3)
      v8 = a3;
    else
      v8 = v7;
    if ((_DWORD)v8)
    {
      if (!v6)
      {
        *(double *)(a1 + 56) = a4;
        *(_DWORD *)(a1 + 48) = a2;
        *(_WORD *)(a1 + 72) = 0;
        *(_DWORD *)(a1 + 76) = 0;
        *(_BYTE *)(a1 + 96) = 1;
        *(_QWORD *)(a1 + 128) = 0;
      }
      if (*(_DWORD *)(a1 + 160))
      {
        v9 = 0;
        v10 = (uint64_t *)(a1 + 176);
        do
        {
          v11 = *v10;
          v10 += 2;
          bzero((void *)(v11 + (*(_DWORD *)(a1 + 24) * *(_DWORD *)(a1 + 80))), (*(_DWORD *)(a1 + 24) * v8));
          ++v9;
        }
        while (v9 < *(unsigned int *)(a1 + 160));
        v6 = *(_DWORD *)(a1 + 80);
      }
      VCAudioBufferList_SetSampleCount(a1, v6 + v8);
      *(_BYTE *)(a1 + 64) = 0;
      if (v7 < a3 && (int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v12 = VRTraceErrorLogLevelToCSTR();
        v13 = *MEMORY[0x1E0CF2758];
        v14 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            v16 = 136315650;
            v17 = v12;
            v18 = 2080;
            v19 = "VCAudioBufferList_AppendSilence";
            v20 = 1024;
            v21 = 418;
            _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Unable to append all the source samples!", (uint8_t *)&v16, 0x1Cu);
          }
        }
        else if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
        {
          VCAudioBufferList_AppendSilence_cold_2();
        }
      }
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioBufferList_AppendSilence_cold_1();
    }
    return 0;
  }
  return v8;
}

BOOL VCAudioBufferList_ReplaceSamples(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  NSObject *v9;
  _BOOL8 result;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  BOOL v14;
  unsigned int v15;
  unint64_t v16;
  void **v17;
  uint64_t *v18;
  void *v19;
  void *v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  __int16 v24;
  const char *v25;
  __int16 v26;
  int v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  uint64_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if (!a1 || !a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      VCAudioBufferList_ReplaceSamples_cold_1();
    }
    return 0;
  }
  v6 = (uint64_t *)(a1 + 8);
  v7 = (uint64_t *)(a2 + 8);
  if (memcmp((const void *)(a1 + 8), (const void *)(a2 + 8), 0x28uLL))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v8 = VRTraceErrorLogLevelToCSTR();
      v9 = *MEMORY[0x1E0CF2758];
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      v11 = *v7;
      v12 = *v6;
      v22 = 136316162;
      v23 = v8;
      v24 = 2080;
      v25 = "VCAudioBufferList_ReplaceSamples";
      v26 = 1024;
      v27 = 430;
      v28 = 2048;
      v29 = v11;
      v30 = 2048;
      v31 = v12;
      _os_log_error_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_ERROR, " [%s] %s:%d Formats don't match: source=%f dest=%f", (uint8_t *)&v22, 0x30u);
    }
    return 0;
  }
  v13 = *(_DWORD *)(a2 + 80);
  v14 = v13 >= a3;
  v15 = v13 - a3;
  if (!v14 || *(_DWORD *)(a1 + 80) > v15)
    return 0;
  if (*(_DWORD *)(a1 + 160))
  {
    v16 = 0;
    v17 = (void **)(a1 + 176);
    v18 = (uint64_t *)(a2 + 176);
    do
    {
      v20 = *v17;
      v17 += 2;
      v19 = v20;
      v21 = *v18;
      v18 += 2;
      memcpy(v19, (const void *)(v21 + *(_DWORD *)(a2 + 24) * a3), (*(_DWORD *)(a1 + 24) * *(_DWORD *)(a1 + 80)));
      ++v16;
    }
    while (v16 < *(unsigned int *)(a1 + 160));
  }
  _VCAudioBufferList_ComputeVoiceActivityAppend(a1, a2, a3);
  *(_BYTE *)(a1 + 64) = 0;
  *(_BYTE *)(a1 + 96) = *(_BYTE *)(a2 + 96);
  *(_QWORD *)(a1 + 128) = *(_QWORD *)(a2 + 128);
  *(_BYTE *)(a1 + 73) = *(_BYTE *)(a2 + 73);
  return 1;
}

uint64_t VCAudioBufferList_Shift(uint64_t a1, unsigned int a2)
{
  unsigned int v3;
  uint64_t v4;
  unsigned int v5;
  unint64_t v6;
  void **v7;
  char *v8;
  unsigned int v9;
  int v10;
  BOOL v11;
  int v12;

  if (a1)
  {
    v3 = *(_DWORD *)(a1 + 80);
    if (v3 >= a2)
      v4 = a2;
    else
      v4 = v3;
    v5 = v3 - v4;
    if (v3 > a2 && *(_DWORD *)(a1 + 160))
    {
      v6 = 0;
      v7 = (void **)(a1 + 176);
      do
      {
        v8 = (char *)*v7;
        v7 += 2;
        memmove(v8, &v8[(*(_DWORD *)(a1 + 24) * v4)], *(_DWORD *)(a1 + 24) * v5);
        ++v6;
      }
      while (v6 < *(unsigned int *)(a1 + 160));
      v5 = *(_DWORD *)(a1 + 80) - v4;
    }
    *(_DWORD *)(a1 + 48) += v4;
    *(double *)(a1 + 56) = *(double *)(a1 + 56) + (double)v4 / *(double *)(a1 + 8);
    VCAudioBufferList_SetSampleCount(a1, v5);
    *(_BYTE *)(a1 + 64) = 0;
    v9 = *(_DWORD *)(a1 + 76);
    v10 = *(_DWORD *)(a1 + 80);
    v11 = v9 >= v4;
    v12 = v9 - v4;
    if (!v11)
      v12 = 0;
    *(_DWORD *)(a1 + 76) = v12;
    if (!v10)
      *(_WORD *)(a1 + 72) = 0;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioBufferList_Shift_cold_1();
    }
    return 0;
  }
  return v4;
}

BOOL VCAudioBufferList_Convert(uint64_t a1, uint64_t a2, AudioConverterRef inAudioConverter)
{
  char v5;
  OSStatus v6;
  unint64_t v7;
  _BOOL8 v8;
  unint64_t v9;
  unint64_t v10;
  double v11;
  double v12;
  unint64_t v13;
  void **v14;
  size_t v15;
  void *v16;
  char v17;
  _QWORD v19[2];

  v19[1] = *MEMORY[0x1E0C80C00];
  v19[0] = a1;
  if (a1 && a2)
  {
    v5 = *(_BYTE *)(a1 + 96);
    *(_DWORD *)(a2 + 80) = *(_DWORD *)(a2 + 88);
    *(_BYTE *)(a2 + 96) = v5;
    *(_QWORD *)(a2 + 128) = *(_QWORD *)(a1 + 128);
    v6 = AudioConverterFillComplexBuffer(inAudioConverter, (AudioConverterComplexInputDataProc)VCAudioBufferListConverterCallback, v19, (UInt32 *)(a2 + 80), (AudioBufferList *)(a2 + 160), 0);
    v8 = v6 == 0;
    if (v6)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCAudioBufferList_Convert_cold_1();
      }
      LODWORD(v9) = *(_DWORD *)(a2 + 88);
      v11 = (double)v9;
      LODWORD(v10) = *(_DWORD *)(a1 + 80);
      v12 = *(double *)(a2 + 8) * (double)v10 / *(double *)(a1 + 8);
      if (v12 <= v11)
        v11 = v12;
      *(_DWORD *)(a2 + 80) = v11;
      if (*(_DWORD *)(a2 + 160))
      {
        v13 = 0;
        v14 = (void **)(a2 + 176);
        do
        {
          v15 = (*(_DWORD *)(a2 + 24) * *(_DWORD *)(a2 + 80));
          *((_DWORD *)v14 - 1) = v15;
          v16 = *v14;
          v14 += 2;
          bzero(v16, v15);
          ++v13;
        }
        while (v13 < *(unsigned int *)(a2 + 160));
      }
      *(_DWORD *)(a2 + 76) = 0;
      *(_BYTE *)(a2 + 72) = 0;
      v17 = 1;
    }
    else
    {
      *(_DWORD *)(a2 + 68) = *(_DWORD *)(a1 + 68);
      LODWORD(v7) = *(_DWORD *)(a1 + 76);
      *(_DWORD *)(a2 + 76) = (*(double *)(a2 + 8) * (double)v7 / *(double *)(a1 + 8));
      *(_BYTE *)(a2 + 72) = *(_BYTE *)(a1 + 72);
      v17 = *(_BYTE *)(a1 + 96);
    }
    *(_BYTE *)(a2 + 96) = v17;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioBufferList_Convert_cold_2();
    }
    return 0;
  }
  return v8;
}

uint64_t VCAudioBufferListConverterCallback(uint64_t a1, int *a2, unsigned int *a3, uint64_t a4, _QWORD *a5)
{
  _DWORD *v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  NSObject *v17;
  int v19;
  int v20;
  int v21;
  int v22;
  uint64_t v23;
  __int16 v24;
  const char *v25;
  __int16 v26;
  int v27;
  __int16 v28;
  int v29;
  __int16 v30;
  uint64_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if (a1 && a2 && a3 && a5)
  {
    v8 = (_DWORD *)*a5;
    if (*a5)
    {
      if (v8[40] == *a3)
      {
        v9 = (v8[43] / v8[6]);
        if (v9 < *a2 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v10 = VRTraceErrorLogLevelToCSTR();
          v11 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            v21 = *a2;
            v22 = 136316162;
            v23 = v10;
            v24 = 2080;
            v25 = "VCAudioBufferListConverterCallback";
            v26 = 1024;
            v27 = 517;
            v28 = 1024;
            v29 = v21;
            v30 = 2048;
            v31 = v9;
            _os_log_error_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_ERROR, " [%s] %s:%d Insufficent input samples: needed = %d, available = %lu", (uint8_t *)&v22, 0x2Cu);
          }
        }
        *a2 = v9;
        v12 = *a3;
        if ((_DWORD)v12)
        {
          v13 = v8 + 44;
          v14 = a3 + 4;
          do
          {
            *v14 = *v13;
            *(v14 - 1) = *(v13 - 1);
            v13 += 2;
            v14 += 2;
            --v12;
          }
          while (v12);
        }
        v15 = 0;
        *a5 = 0;
      }
      else
      {
        v15 = 2003329396;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v16 = VRTraceErrorLogLevelToCSTR();
          v17 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            v19 = v8[40];
            v20 = *a3;
            v22 = 136316162;
            v23 = v16;
            v24 = 2080;
            v25 = "VCAudioBufferListConverterCallback";
            v26 = 1024;
            v27 = 510;
            v28 = 1024;
            v29 = v19;
            v30 = 1024;
            LODWORD(v31) = v20;
            _os_log_error_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_ERROR, " [%s] %s:%d Number of buffers in sample buffer and io data do not match. inAudioBuffer=%d, ioData=%d.", (uint8_t *)&v22, 0x28u);
          }
        }
      }
    }
    else
    {
      *a2 = 0;
      return 4294967201;
    }
  }
  else
  {
    v15 = 2003329396;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioBufferListConverterCallback_cold_1();
    }
  }
  return v15;
}

uint64_t VCAudioBufferList_GetSampleFormat(uint64_t a1)
{
  if (a1)
    return a1 + 8;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioBufferList_GetSampleFormat_cold_1();
  }
  return 0;
}

uint64_t VCAudioBufferList_GetAudioBufferList(uint64_t a1)
{
  if (a1)
    return a1 + 160;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioBufferList_GetAudioBufferList_cold_1();
  }
  return 0;
}

uint64_t VCAudioBufferList_GetBufferAtIndex(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  _QWORD v4[4];

  v4[3] = *MEMORY[0x1E0C80C00];
  memset(v4, 0, 24);
  if (VCAudioBufferList_GetSizedBufferAtIndex(a1, a2, a3, v4))
    return v4[0];
  else
    return 0;
}

BOOL VCAudioBufferList_GetSizedBufferAtIndex(uint64_t a1, unsigned int a2, _DWORD *a3, _QWORD *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _BOOL8 result;

  if (a1 && *(_DWORD *)(a1 + 160) > a2)
  {
    if (a3)
      *a3 = *(_DWORD *)(a1 + 80);
    v4 = a1 + 16 * a2;
    v5 = *(_QWORD *)(v4 + 176);
    v6 = *(unsigned int *)(v4 + 172);
    *a4 = v5;
    a4[1] = v6;
    a4[2] = v6;
    return 1;
  }
  else
  {
    if (a3)
      *a3 = 0;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      VCAudioBufferList_GetSizedBufferAtIndex_cold_1();
    }
    return 0;
  }
}

void VCAudioBufferList_Reset(uint64_t a1)
{
  int v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;

  if (a1)
  {
    if ((*(_BYTE *)(a1 + 20) & 0x20) != 0)
      v2 = 1;
    else
      v2 = *(_DWORD *)(a1 + 36);
    v3 = *(_DWORD *)(a1 + 160);
    *(_BYTE *)(a1 + 64) = 0;
    VCAudioBufferList_SetSampleCount(a1, 0);
    *(_WORD *)(a1 + 72) = 0;
    *(_DWORD *)(a1 + 76) = 0;
    *(_BYTE *)(a1 + 96) = 0;
    v4 = MEMORY[0x1E0CA2E18];
    *(_OWORD *)(a1 + 100) = *MEMORY[0x1E0CA2E18];
    *(_QWORD *)(a1 + 116) = *(_QWORD *)(v4 + 16);
    *(int64x2_t *)(a1 + 128) = vdupq_n_s64(0x7FF8000000000000uLL);
    v5 = *(unsigned int *)(a1 + 160);
    if ((_DWORD)v5)
    {
      v6 = a1 + 16 * (v3 - 1) + 184;
      v7 = *(unsigned int *)(a1 + 92);
      v8 = (uint64_t *)(a1 + 176);
      do
      {
        *v8 = v6;
        v6 += v7;
        *((_DWORD *)v8 - 2) = v2;
        *((_DWORD *)v8 - 1) = v7;
        v8 += 2;
        --v5;
      }
      while (v5);
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioBufferList_Reset_cold_1();
  }
}

void VCAudioBufferList_ResetDataPointers(uint64_t a1)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  int v11;
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if ((*(_BYTE *)(a1 + 20) & 0x20) != 0)
      v2 = *(_DWORD *)(a1 + 36);
    else
      v2 = 1;
    LODWORD(v3) = *(_DWORD *)(a1 + 160);
    if ((_DWORD)v3 != v2)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v4 = VRTraceErrorLogLevelToCSTR();
        v5 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v6 = *(_DWORD *)(a1 + 160);
          v7 = *(_DWORD *)(a1 + 36);
          v11 = 136316162;
          v12 = v4;
          v13 = 2080;
          v14 = "VCAudioBufferList_ResetDataPointers";
          v15 = 1024;
          v16 = 651;
          v17 = 1024;
          v18 = v6;
          v19 = 1024;
          v20 = v7;
          _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Number of buffers is incorrect. mNumberBuffers=%u mChannelsPerFrame=%u.", (uint8_t *)&v11, 0x28u);
        }
      }
      LODWORD(v3) = *(_DWORD *)(a1 + 160);
    }
    if ((_DWORD)v3)
    {
      v8 = a1 + 16 * (v3 - 1) + 184;
      v9 = *(unsigned int *)(a1 + 92);
      v3 = v3;
      v10 = (uint64_t *)(a1 + 176);
      do
      {
        *v10 = v8;
        v10 += 2;
        v8 += v9;
        --v3;
      }
      while (v3);
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioBufferList_ResetDataPointers_cold_1();
  }
}

uint64_t VCAudioBufferList_ResampleAppend(uint64_t a1, uint64_t a2, int a3, OpaqueAudioConverter *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint8_t *v10;
  unint64_t v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  _QWORD *v20;
  uint8_t *v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  unsigned int v26;
  unsigned int v27;
  char v28;
  BOOL v29;
  double v30;
  char v31;
  uint64_t v32;
  NSObject *v33;
  uint64_t v34;
  int v36;
  int v37;
  uint64_t v38;
  NSObject *v39;
  const char *v40;
  NSObject *v41;
  uint32_t v42;
  uint64_t v43;
  NSObject *v44;
  int v45;
  uint64_t v46;
  uint8_t buf[4];
  uint64_t v48;
  __int16 v49;
  const char *v50;
  __int16 v51;
  int v52;
  __int16 v53;
  _BYTE v54[10];
  uint64_t v55;
  __int16 v56;
  OpaqueAudioConverter *v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    MEMORY[0x1E0C80A78](a1);
    v10 = (uint8_t *)&v46;
    v8 = 1;
    goto LABEL_5;
  }
  v8 = *(unsigned int *)(a2 + 160);
  MEMORY[0x1E0C80A78](a1);
  v10 = &buf[-((v9 + 15) & 0xFFFFFFFF0)];
  if ((_DWORD)v8)
  {
LABEL_5:
    memset(v10, 170, 8 * v8);
    goto LABEL_6;
  }
  v8 = 0;
LABEL_6:
  bzero(v10, 8 * v8);
  if (!a1 || !a2 || !a4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      goto LABEL_53;
    v38 = VRTraceErrorLogLevelToCSTR();
    v39 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      goto LABEL_53;
    *(_DWORD *)buf = 136316418;
    v48 = v38;
    v49 = 2080;
    v50 = "VCAudioBufferList_ResampleAppend";
    v51 = 1024;
    v52 = 695;
    v53 = 2048;
    *(_QWORD *)v54 = a2;
    *(_WORD *)&v54[8] = 2048;
    v55 = a1;
    v56 = 2048;
    v57 = a4;
    v40 = " [%s] %s:%d Invalid input parameter. inSampleBuffer=%p outSampleBuffer=%p converter=%p";
    v41 = v39;
    v42 = 58;
LABEL_49:
    _os_log_error_impl(&dword_1D8A54000, v41, OS_LOG_TYPE_ERROR, v40, buf, v42);
    goto LABEL_53;
  }
  v12 = *(_DWORD *)(a2 + 80);
  LODWORD(v11) = *(_DWORD *)(a1 + 80);
  v13 = (*(double *)(a2 + 8) * (double)v11 / *(double *)(a1 + 8));
  v14 = v12 + v13;
  v15 = *(_DWORD *)(a2 + 88);
  if (v12 + v13 > v15)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      goto LABEL_53;
    v43 = VRTraceErrorLogLevelToCSTR();
    v44 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      goto LABEL_53;
    v45 = *(_DWORD *)(a2 + 88);
    *(_DWORD *)buf = 136316162;
    v48 = v43;
    v49 = 2080;
    v50 = "VCAudioBufferList_ResampleAppend";
    v51 = 1024;
    v52 = 700;
    v53 = 1024;
    *(_DWORD *)v54 = v14;
    *(_WORD *)&v54[4] = 1024;
    *(_DWORD *)&v54[6] = v45;
    v40 = " [%s] %s:%d Unable to resample. Needed capacity=%d capacity=%d";
    v41 = v44;
    v42 = 40;
    goto LABEL_49;
  }
  if (*(_DWORD *)(a1 + 84) == *(_DWORD *)(a2 + 84))
  {
    *(_DWORD *)(a2 + 88) = v15 - v12;
    v16 = *(unsigned int *)(a2 + 160);
    if ((_DWORD)v16)
    {
      v17 = *(_DWORD *)(a2 + 24);
      v18 = (v17 * v12);
      v19 = v17 * v13;
      v20 = (_QWORD *)(a2 + 176);
      v21 = v10;
      do
      {
        v22 = *v20;
        *(_QWORD *)v21 = *v20;
        v21 += 8;
        *v20 = v22 + v18;
        *((_DWORD *)v20 - 1) = v19;
        v20 += 2;
        --v16;
      }
      while (v16);
    }
    if (VCAudioBufferList_Convert(a1, a2, a4))
    {
      *(_DWORD *)(a2 + 88) = v15;
      v23 = *(unsigned int *)(a2 + 160);
      if ((_DWORD)v23)
      {
        v24 = (_QWORD *)(a2 + 176);
        do
        {
          v25 = *(_QWORD *)v10;
          v10 += 8;
          *v24 = v25;
          v24 += 2;
          --v23;
        }
        while (v23);
      }
      if (v12)
      {
        *(_BYTE *)(a2 + 64) = 0;
        v26 = *(unsigned __int8 *)(a2 + 96);
        if (v26 != 255)
        {
          v27 = *(unsigned __int8 *)(a1 + 96);
          v28 = v26 <= v27 ? *(_BYTE *)(a1 + 96) : *(_BYTE *)(a2 + 96);
          v29 = !*(_BYTE *)(a1 + 96) || v26 == 0;
          LOBYTE(v26) = v29 ? 0 : v28;
          if (v27 == 255)
            LOBYTE(v26) = -1;
        }
        *(_BYTE *)(a2 + 96) = v26;
        v30 = *(double *)(a2 + 128);
        if (v30 <= *(double *)(a1 + 128))
          v30 = *(double *)(a1 + 128);
        *(double *)(a2 + 128) = v30;
        v31 = *(_BYTE *)(a1 + 73);
        if (v31)
          v31 = *(_BYTE *)(a2 + 73) != 0;
      }
      else
      {
        *(_BYTE *)(a2 + 64) = *(_BYTE *)(a1 + 64);
        *(_DWORD *)(a2 + 68) = *(_DWORD *)(a1 + 68);
        *(_QWORD *)(a2 + 56) = *(_QWORD *)(a1 + 56);
        *(_DWORD *)(a2 + 48) = a3;
        *(_BYTE *)(a2 + 96) = *(_BYTE *)(a1 + 96);
        *(_QWORD *)(a2 + 128) = *(_QWORD *)(a1 + 128);
        v31 = *(_BYTE *)(a1 + 73);
      }
      *(_BYTE *)(a2 + 73) = v31;
      v34 = 1;
      goto LABEL_41;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioBufferList_ResampleAppend_cold_1();
    }
LABEL_53:
    v34 = 0;
    v14 = 0;
LABEL_41:
    VCAudioBufferList_SetSampleCount(a2, v14);
    return v34;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v32 = VRTraceErrorLogLevelToCSTR();
    v33 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      v36 = *(_DWORD *)(a1 + 84);
      v37 = *(_DWORD *)(a2 + 84);
      *(_DWORD *)buf = 136316162;
      v48 = v32;
      v49 = 2080;
      v50 = "VCAudioBufferList_ResampleAppend";
      v51 = 1024;
      v52 = 703;
      v53 = 1024;
      *(_DWORD *)v54 = v36;
      *(_WORD *)&v54[4] = 1024;
      *(_DWORD *)&v54[6] = v37;
      _os_log_error_impl(&dword_1D8A54000, v33, OS_LOG_TYPE_ERROR, " [%s] %s:%d Invalid channel count. inSampleBuffer=%d outSampleBuffer=%d", buf, 0x28u);
    }
  }
  return 0;
}

void VCAudioBufferList_InvalidateAveragePower(uint64_t a1)
{
  if (a1)
  {
    *(_BYTE *)(a1 + 64) = 0;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioBufferList_InvalidateAveragePower_cold_1();
  }
}

uint64_t VCAudioBufferList_SetTime(uint64_t result, int a2, double a3)
{
  if (result)
  {
    *(double *)(result + 56) = a3;
    *(_DWORD *)(result + 48) = a2;
  }
  return result;
}

uint64_t VCAudioBufferList_GetTimestamp(uint64_t a1)
{
  if (a1)
    return *(unsigned int *)(a1 + 48);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioBufferList_GetTimestamp_cold_1();
  }
  return 0xFFFFFFFFLL;
}

uint64_t VCAudioBufferList_SetTimestamp(uint64_t result, int a2)
{
  if (result)
    *(_DWORD *)(result + 48) = a2;
  return result;
}

void VCAudioBufferList_GetAudioTimestamp(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  double v2;

  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  if (a1)
  {
    v2 = *(double *)(a1 + 56);
    *(_QWORD *)(a2 + 8) = (unint64_t)v2;
    LODWORD(v2) = *(_DWORD *)(a1 + 48);
    *(double *)a2 = (double)*(unint64_t *)&v2;
    *(_DWORD *)(a2 + 56) = 3;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioBufferList_GetAudioTimestamp_cold_1();
  }
}

uint64_t VCAudioBufferList_SetHostTimeJumpSize(uint64_t result, double a2)
{
  if (result)
    *(double *)(result + 136) = a2;
  return result;
}

double VCAudioBufferList_GetHostTimeJumpSize(uint64_t a1)
{
  double v1;

  if (a1)
    return *(double *)(a1 + 136);
  v1 = 0.0;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioBufferList_GetHostTimeJumpSize_cold_1();
  }
  return v1;
}

double VCAudioBufferList_GetHostTime(uint64_t a1)
{
  if (a1)
    return *(double *)(a1 + 56);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioBufferList_GetHostTime_cold_1();
  }
  return NAN;
}

uint64_t VCAudioBufferList_GetVoiceActivity(uint64_t a1)
{
  if (a1)
  {
    return *(_BYTE *)(a1 + 72) || *(_DWORD *)(a1 + 76) != 0;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioBufferList_GetVoiceActivity_cold_1();
    }
    return 0xFFFFFFFFLL;
  }
}

void VCAudioBufferList_SetVoiceActivity(uint64_t a1, int a2)
{
  if (a1)
  {
    *(_BYTE *)(a1 + 72) = a2 != 0;
    *(_DWORD *)(a1 + 76) = 0;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioBufferList_SetVoiceActivity_cold_1();
  }
}

uint64_t VCAudioBufferList_GetSampleCount(uint64_t a1)
{
  uint64_t result;

  if (a1)
    return *(unsigned int *)(a1 + 80);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    VCAudioBufferList_GetSampleCount_cold_1();
  }
  return 0;
}

uint64_t VCAudioBufferList_GetSampleCapacity(uint64_t a1)
{
  uint64_t result;

  if (a1)
    return *(unsigned int *)(a1 + 88);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    VCAudioBufferList_GetSampleCapacity_cold_1();
  }
  return 0;
}

uint64_t VCAudioBufferList_GetChannelCount(uint64_t a1)
{
  uint64_t result;

  if (a1)
    return *(unsigned int *)(a1 + 84);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    VCAudioBufferList_GetChannelCount_cold_1();
  }
  return 0;
}

void VCAudioBufferList_SetSilenceInQueue(uint64_t a1, char a2)
{
  if (a1)
  {
    *(_BYTE *)(a1 + 73) = a2;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioBufferList_SetSilenceInQueue_cold_1();
  }
}

BOOL VCAudioBufferList_IsSilenceInQueue(uint64_t a1)
{
  _BOOL8 result;

  if (a1)
    return *(_BYTE *)(a1 + 73) != 0;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    VCAudioBufferList_IsSilenceInQueue_cold_1();
  }
  return 0;
}

float VCAudioBufferList_GetAveragePower(uint64_t a1)
{
  double v2;
  float v3;
  float __C;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (*(_BYTE *)(a1 + 64))
      return *(float *)(a1 + 68);
    if ((*(_BYTE *)(a1 + 20) & 1) != 0)
    {
      __C = NAN;
      vDSP_rmsqv(*(const float **)(a1 + 176), 1, &__C, (*(_DWORD *)(a1 + 172) / *(_DWORD *)(a1 + 24)));
      v2 = log10(__C) * 20.0;
      if (v2 <= -120.0)
        v2 = -120.0;
      v3 = v2;
      *(float *)(a1 + 68) = v3;
      *(_BYTE *)(a1 + 64) = 1;
      return *(float *)(a1 + 68);
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioBufferList_GetAveragePower_cold_1();
  }
  return NAN;
}

void VCAudioBufferList_SetAveragePower(uint64_t a1, float a2)
{
  if (a1)
  {
    *(_BYTE *)(a1 + 64) = 1;
    *(float *)(a1 + 68) = a2;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioBufferList_SetAveragePower_cold_1();
  }
}

uint64_t VCAudioBufferList_GetSerializedSize(unsigned int *a1)
{
  if (a1)
    return *a1;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioBufferList_GetSerializedSize_cold_1();
  }
  return 0;
}

CFAllocatorRef VCAudioBufferList_CreateSampleBufferAllocator()
{
  CFAllocatorRef v1;
  _OWORD v2[5];
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  v1 = 0;
  v2[2] = xmmword_1D910FAF8;
  v2[3] = unk_1D910FB08;
  v2[4] = xmmword_1D910FB18;
  v2[0] = xmmword_1D910FAD8;
  v2[1] = unk_1D910FAE8;
  VCAllocatorMultiQueue_Create((const __CFAllocator *)*MEMORY[0x1E0C9AE00], (uint64_t)"VCAudioBufferListSampleBufferAllocator", 0xAu, (unint64_t *)v2, &v1);
  return v1;
}

CMSampleBufferRef VCAudioBufferList_CreateSampleBufferWithFormat(uint64_t a1, const opaqueCMFormatDescription *a2, const __CFAllocator *a3)
{
  return VCAudioBufferList_CreateSampleBufferWithFormatWithAllocator(a1, a2, a3, a3);
}

CMSampleBufferRef VCAudioBufferList_CreateSampleBufferWithFormatWithAllocator(uint64_t a1, const opaqueCMFormatDescription *a2, const __CFAllocator *a3, const __CFAllocator *a4)
{
  CMItemCount v8;
  OSStatus v9;
  OSStatus v10;
  CMSampleBufferRef v11;
  OSStatus v13;
  uint64_t v14;
  NSObject *v15;
  const char *v16;
  NSObject *v17;
  OSStatus v18;
  uint64_t v19;
  NSObject *v20;
  CMTime v21;
  CMSampleBufferRef sbuf;
  CMTime presentationTimeStamp;
  int v24;
  __int16 v25;
  OSStatus v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  sbuf = 0;
  memset(&v21, 170, sizeof(v21));
  CMTimeMakeWithSeconds(&v21, *(Float64 *)(a1 + 56), (int)*(double *)(a1 + 8));
  v8 = *(unsigned int *)(a1 + 80);
  presentationTimeStamp = v21;
  v9 = CMAudioSampleBufferCreateWithPacketDescriptions(a3, 0, 0, 0, 0, a2, v8, &presentationTimeStamp, 0, &sbuf);
  if (v9)
  {
    v13 = v9;
    if ((int)VRTraceGetErrorLogLevelForModule() < 7)
      goto LABEL_12;
    v14 = VRTraceErrorLogLevelToCSTR();
    v15 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      goto LABEL_12;
    LODWORD(presentationTimeStamp.value) = 136315906;
    *(CMTimeValue *)((char *)&presentationTimeStamp.value + 4) = v14;
    LOWORD(presentationTimeStamp.flags) = 2080;
    *(_QWORD *)((char *)&presentationTimeStamp.flags + 2) = "VCAudioBufferList_CreateSampleBufferWithFormatWithAllocator";
    HIWORD(presentationTimeStamp.epoch) = 1024;
    v24 = 922;
    v25 = 1024;
    v26 = v13;
    v16 = " [%s] %s:%d Failed to create the CMSampleBuffer description: %d";
    v17 = v15;
    goto LABEL_11;
  }
  v10 = CMSampleBufferSetDataBufferFromAudioBufferList(sbuf, a3, a4, 0, (const AudioBufferList *)(a1 + 160));
  if (!v10)
  {
    v11 = sbuf;
    presentationTimeStamp = v21;
    CMSampleBufferSetOutputPresentationTimeStamp(sbuf, &presentationTimeStamp);
    return v11;
  }
  v18 = v10;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v19 = VRTraceErrorLogLevelToCSTR();
    v20 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(presentationTimeStamp.value) = 136315906;
      *(CMTimeValue *)((char *)&presentationTimeStamp.value + 4) = v19;
      LOWORD(presentationTimeStamp.flags) = 2080;
      *(_QWORD *)((char *)&presentationTimeStamp.flags + 2) = "VCAudioBufferList_CreateSampleBufferWithFormatWithAllocator";
      HIWORD(presentationTimeStamp.epoch) = 1024;
      v24 = 925;
      v25 = 1024;
      v26 = v18;
      v16 = " [%s] %s:%d Failed to create the CMSampleBuffer: %d";
      v17 = v20;
LABEL_11:
      _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, v16, (uint8_t *)&presentationTimeStamp, 0x22u);
    }
  }
LABEL_12:
  if (sbuf)
    CFRelease(sbuf);
  return 0;
}

CMSampleBufferRef VCAudioBufferList_CreateSampleBufferAllocateWithAllocator(uint64_t a1, CFAllocatorRef allocator, const __CFAllocator *a3)
{
  CMSampleBufferRef SampleBufferWithFormatWithAllocator;
  uint64_t v8;
  NSObject *v9;
  CMAudioFormatDescriptionRef formatDescriptionOut;
  uint8_t buf[4];
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  formatDescriptionOut = 0;
  if (CMAudioFormatDescriptionCreate(allocator, (const AudioStreamBasicDescription *)(a1 + 8), 0, 0, 0, 0, 0, &formatDescriptionOut))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v8 = VRTraceErrorLogLevelToCSTR();
      v9 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        v12 = v8;
        v13 = 2080;
        v14 = "VCAudioBufferList_CreateSampleBufferAllocateWithAllocator";
        v15 = 1024;
        v16 = 946;
        _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Failed to create format description for audio buffer", buf, 0x1Cu);
      }
    }
    SampleBufferWithFormatWithAllocator = 0;
  }
  else
  {
    SampleBufferWithFormatWithAllocator = VCAudioBufferList_CreateSampleBufferWithFormatWithAllocator(a1, formatDescriptionOut, allocator, a3);
  }
  if (formatDescriptionOut)
    CFRelease(formatDescriptionOut);
  return SampleBufferWithFormatWithAllocator;
}

uint64_t VCAudioBufferList_GetPriority(uint64_t a1)
{
  if (a1)
    return *(unsigned __int8 *)(a1 + 96);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioBufferList_GetPriority_cold_1();
  }
  return 1;
}

void VCAudioBufferList_SetPriority(uint64_t a1, char a2)
{
  if (a1)
  {
    *(_BYTE *)(a1 + 96) = a2;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioBufferList_SetPriority_cold_1();
  }
}

void VCAudioBufferList_InvalidateNetworkTimestamp(uint64_t a1)
{
  uint64_t v1;

  if (a1)
  {
    v1 = MEMORY[0x1E0CA2E18];
    *(_OWORD *)(a1 + 100) = *MEMORY[0x1E0CA2E18];
    *(_QWORD *)(a1 + 116) = *(_QWORD *)(v1 + 16);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioBufferList_InvalidateNetworkTimestamp_cold_1();
  }
}

void VCAudioBufferList_SetNetworkTimestamp(uint64_t a1, __int128 *a2)
{
  __int128 v2;

  if (a1 && a2)
  {
    v2 = *a2;
    *(_QWORD *)(a1 + 116) = *((_QWORD *)a2 + 2);
    *(_OWORD *)(a1 + 100) = v2;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioBufferList_SetNetworkTimestamp_cold_1();
  }
}

void VCAudioBufferList_GetNetworkTimestamp(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;

  if (a1)
  {
    *(_OWORD *)a2 = *(_OWORD *)(a1 + 100);
    v3 = *(_QWORD *)(a1 + 116);
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioBufferList_GetNetworkTimestamp_cold_1();
    }
    v4 = MEMORY[0x1E0CA2E18];
    *(_OWORD *)a2 = *MEMORY[0x1E0CA2E18];
    v3 = *(_QWORD *)(v4 + 16);
  }
  *(_QWORD *)(a2 + 16) = v3;
}

double VCAudioBufferList_GetVoiceProbability(uint64_t a1)
{
  if (a1)
    return *(double *)(a1 + 128);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioBufferList_GetVoiceProbability_cold_1();
  }
  return NAN;
}

void VCAudioBufferList_SetVoiceProbability(uint64_t a1, double a2)
{
  if (a1)
  {
    *(double *)(a1 + 128) = a2;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioBufferList_SetVoiceProbability_cold_1();
  }
}

BOOL VCAudioBufferList_CopySampleBuffer(unsigned int *a1, CFAllocatorRef allocator, _QWORD *a3)
{
  uint64_t v6;
  size_t v7;
  CFIndex v8;
  unsigned int *v9;
  unsigned int v10;
  char *v11;
  char *v12;
  unint64_t v13;
  char *v14;
  _QWORD *v15;
  unsigned int *v16;
  unsigned int v17;
  CFTypeRef v18;
  _BOOL8 result;
  uint64_t v20;
  NSObject *v21;
  NSObject *v22;
  _BOOL4 v23;
  const char *v24;
  uint64_t v25;
  NSObject *v26;
  _BOOL4 v27;
  uint64_t v28;
  NSObject *v29;
  _BOOL4 v30;
  int v31;
  uint64_t v32;
  __int16 v33;
  const char *v34;
  __int16 v35;
  int v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 8)
      return 0;
    v20 = VRTraceErrorLogLevelToCSTR();
    v21 = *MEMORY[0x1E0CF2758];
    v22 = *MEMORY[0x1E0CF2758];
    if (!*MEMORY[0x1E0CF2748])
    {
      result = os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG);
      if (!result)
        return result;
      VCAudioBufferList_CopySampleBuffer_cold_1();
      return 0;
    }
    v23 = os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v23)
      return result;
    v31 = 136315650;
    v32 = v20;
    v33 = 2080;
    v34 = "VCAudioBufferList_CopySampleBuffer";
    v35 = 1024;
    v36 = 1090;
    v24 = " [%s] %s:%d Invalid sample buffer";
    goto LABEL_27;
  }
  if (!a3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 8)
      return 0;
    v25 = VRTraceErrorLogLevelToCSTR();
    v21 = *MEMORY[0x1E0CF2758];
    v26 = *MEMORY[0x1E0CF2758];
    if (!*MEMORY[0x1E0CF2748])
    {
      result = os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG);
      if (!result)
        return result;
      VCAudioBufferList_CopySampleBuffer_cold_2();
      return 0;
    }
    v27 = os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v27)
      return result;
    v31 = 136315650;
    v32 = v25;
    v33 = 2080;
    v34 = "VCAudioBufferList_CopySampleBuffer";
    v35 = 1024;
    v36 = 1091;
    v24 = " [%s] %s:%d Invalid output sample buffer";
LABEL_27:
    _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, v24, (uint8_t *)&v31, 0x1Cu);
    return 0;
  }
  *a3 = 0;
  v6 = a1[40];
  v7 = 16 * (v6 - 1) + 184;
  v8 = v7;
  if ((_DWORD)v6)
  {
    v9 = a1 + 43;
    v8 = 16 * (v6 - 1) + 184;
    do
    {
      v10 = *v9;
      v9 += 4;
      v8 += v10;
      --v6;
    }
    while (v6);
  }
  v11 = (char *)CFAllocatorAllocate(allocator, v8, 0);
  if (!v11)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v28 = VRTraceErrorLogLevelToCSTR();
      v21 = *MEMORY[0x1E0CF2758];
      v29 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        v30 = os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT);
        result = 0;
        if (!v30)
          return result;
        v31 = 136315650;
        v32 = v28;
        v33 = 2080;
        v34 = "VCAudioBufferList_CopySampleBuffer";
        v35 = 1024;
        v36 = 1103;
        v24 = " [%s] %s:%d Failed to allocate the output sample buffer";
        goto LABEL_27;
      }
      result = os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG);
      if (!result)
        return result;
      VCAudioBufferList_CopySampleBuffer_cold_3();
    }
    return 0;
  }
  v12 = v11;
  memcpy(v11, a1, v7);
  if (a1[40])
  {
    v13 = 0;
    v14 = &v12[v7];
    v15 = v12 + 176;
    v16 = a1 + 43;
    do
    {
      *v15 = v14;
      v15 += 2;
      memcpy(v14, *(const void **)(v16 + 1), *v16);
      v17 = *v16;
      v16 += 4;
      v14 += v17;
      ++v13;
    }
    while (v13 < a1[40]);
  }
  v12[144] = 1;
  if (allocator)
    v18 = CFRetain(allocator);
  else
    v18 = 0;
  *((_QWORD *)v12 + 19) = v18;
  *a3 = v12;
  return 1;
}

uint64_t VCNetworkAgentCell_AddCellularAssertion()
{
  uint64_t v0;
  uint64_t v1;
  NSObject *v2;
  int v3;
  const char *v4;
  int v6;
  uint64_t v7;
  __int16 v8;
  const char *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (_VCNetworkAgentCell_SharedInstance_onceToken != -1)
    dispatch_once(&_VCNetworkAgentCell_SharedInstance_onceToken, &__block_literal_global_86);
  v0 = _VCNetworkAgentCell_SharedInstance_sharedInstance;
  VCObject_Lock(_VCNetworkAgentCell_SharedInstance_sharedInstance);
  if (!*(_DWORD *)(v0 + 188)
    && (objc_msgSend(*(id *)(v0 + 192), "addNetworkAgentToInterfaceNamed:", *(_QWORD *)(v0 + 200)) & 1) == 0
    && (int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCNetworkAgentCell_AddCellularAssertion_cold_1();
  }
  ++*(_DWORD *)(v0 + 188);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
  {
    v1 = VRTraceErrorLogLevelToCSTR();
    v2 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v3 = *(_DWORD *)(v0 + 188);
      v4 = "Overwrite cellular as network status bar icon";
      if (v3 != 1)
        v4 = "";
      v6 = 136316418;
      v7 = v1;
      v8 = 2080;
      v9 = "VCNetworkAgentCell_AddCellularAssertion";
      v10 = 1024;
      v11 = 130;
      v12 = 2048;
      v13 = v0;
      v14 = 2080;
      v15 = v4;
      v16 = 1024;
      v17 = v3;
      _os_log_impl(&dword_1D8A54000, v2, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d instance=%p %s refcount = %d", (uint8_t *)&v6, 0x36u);
    }
  }
  return VCObject_Unlock(v0);
}

uint64_t VCNetworkAgentCell_RemoveCellularAssertion()
{
  uint64_t v0;
  int v1;
  BOOL v2;
  int v3;
  uint64_t v4;
  NSObject *v5;
  int v6;
  uint64_t v7;
  NSObject *v8;
  int v9;
  const char *v10;
  int v12;
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  uint64_t v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (_VCNetworkAgentCell_SharedInstance_onceToken != -1)
    dispatch_once(&_VCNetworkAgentCell_SharedInstance_onceToken, &__block_literal_global_86);
  v0 = _VCNetworkAgentCell_SharedInstance_sharedInstance;
  VCObject_Lock(_VCNetworkAgentCell_SharedInstance_sharedInstance);
  v1 = *(_DWORD *)(v0 + 188);
  v2 = __OFSUB__(v1, 1);
  v3 = v1 - 1;
  if (v3 < 0 == v2)
  {
    *(_DWORD *)(v0 + 188) = v3;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v4 = VRTraceErrorLogLevelToCSTR();
      v5 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v6 = *(_DWORD *)(v0 + 188);
        v12 = 136315906;
        v13 = v4;
        v14 = 2080;
        v15 = "VCNetworkAgentCell_RemoveCellularAssertion";
        v16 = 1024;
        v17 = 142;
        v18 = 1024;
        LODWORD(v19) = v6;
        _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCNetworkAgentCell network status refcount is '%d'", (uint8_t *)&v12, 0x22u);
      }
    }
    if (!*(_DWORD *)(v0 + 188)
      && (objc_msgSend(*(id *)(v0 + 192), "removeNetworkAgentFromInterfaceNamed:", *(_QWORD *)(v0 + 200)) & 1) == 0
      && (int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCNetworkAgentCell_RemoveCellularAssertion_cold_1();
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
  {
    v7 = VRTraceErrorLogLevelToCSTR();
    v8 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v9 = *(_DWORD *)(v0 + 188);
      v10 = "Remove overwrite cellular as network status bar icon";
      if (v9)
        v10 = "";
      v12 = 136316418;
      v13 = v7;
      v14 = 2080;
      v15 = "VCNetworkAgentCell_RemoveCellularAssertion";
      v16 = 1024;
      v17 = 151;
      v18 = 2048;
      v19 = v0;
      v20 = 2080;
      v21 = v10;
      v22 = 1024;
      v23 = v9;
      _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d instance=%p %s refcount = %d", (uint8_t *)&v12, 0x36u);
    }
  }
  return VCObject_Unlock(v0);
}

BOOL VCNetworkAgentCell_CellularAssertionActive()
{
  if (_VCNetworkAgentCell_SharedInstance_onceToken != -1)
    dispatch_once(&_VCNetworkAgentCell_SharedInstance_onceToken, &__block_literal_global_86);
  return *(_DWORD *)(_VCNetworkAgentCell_SharedInstance_sharedInstance + 188) > 0;
}

BOOL VCMediaNegotiationBlobVideoRuleCollectionReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  char v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char v22;
  BOOL v23;
  int *v24;
  char v25;
  unsigned int v26;
  uint64_t v27;
  unint64_t v28;
  char v29;
  char v30;
  unsigned int v31;
  uint64_t v32;
  unint64_t v33;
  char v34;
  char v35;
  unsigned int v36;
  uint64_t v37;
  unint64_t v38;
  char v39;
  char v40;
  unsigned int v41;
  uint64_t v42;
  unint64_t v43;
  char v44;
  char v45;
  unsigned int v46;
  uint64_t v47;
  unint64_t v48;
  char v49;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      switch((v10 >> 3))
      {
        case 1u:
          v17 = 0;
          v18 = 0;
          v19 = 0;
          while (1)
          {
            v20 = *v3;
            v21 = *(_QWORD *)(a2 + v20);
            if (v21 == -1 || v21 >= *(_QWORD *)(a2 + *v4))
            {
              v24 = &OBJC_IVAR___VCMediaNegotiationBlobVideoRuleCollection__transport;
              goto LABEL_69;
            }
            v22 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v21);
            *(_QWORD *)(a2 + v20) = v21 + 1;
            v19 |= (unint64_t)(v22 & 0x7F) << v17;
            if ((v22 & 0x80) == 0)
              break;
            v17 += 7;
            v23 = v18++ > 8;
            if (v23)
            {
              LODWORD(v19) = 0;
              v24 = &OBJC_IVAR___VCMediaNegotiationBlobVideoRuleCollection__transport;
              goto LABEL_72;
            }
          }
          v24 = &OBJC_IVAR___VCMediaNegotiationBlobVideoRuleCollection__transport;
          goto LABEL_70;
        case 2u:
          v25 = 0;
          v26 = 0;
          v19 = 0;
          while (2)
          {
            v27 = *v3;
            v28 = *(_QWORD *)(a2 + v27);
            if (v28 == -1 || v28 >= *(_QWORD *)(a2 + *v4))
            {
              v24 = &OBJC_IVAR___VCMediaNegotiationBlobVideoRuleCollection__operation;
              goto LABEL_69;
            }
            v29 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v28);
            *(_QWORD *)(a2 + v27) = v28 + 1;
            v19 |= (unint64_t)(v29 & 0x7F) << v25;
            if (v29 < 0)
            {
              v25 += 7;
              v23 = v26++ > 8;
              if (v23)
              {
                LODWORD(v19) = 0;
                v24 = &OBJC_IVAR___VCMediaNegotiationBlobVideoRuleCollection__operation;
                goto LABEL_72;
              }
              continue;
            }
            break;
          }
          v24 = &OBJC_IVAR___VCMediaNegotiationBlobVideoRuleCollection__operation;
          goto LABEL_70;
        case 3u:
          v30 = 0;
          v31 = 0;
          v19 = 0;
          while (2)
          {
            v32 = *v3;
            v33 = *(_QWORD *)(a2 + v32);
            if (v33 == -1 || v33 >= *(_QWORD *)(a2 + *v4))
            {
              v24 = &OBJC_IVAR___VCMediaNegotiationBlobVideoRuleCollection__formats;
              goto LABEL_69;
            }
            v34 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v33);
            *(_QWORD *)(a2 + v32) = v33 + 1;
            v19 |= (unint64_t)(v34 & 0x7F) << v30;
            if (v34 < 0)
            {
              v30 += 7;
              v23 = v31++ > 8;
              if (v23)
              {
                LODWORD(v19) = 0;
                v24 = &OBJC_IVAR___VCMediaNegotiationBlobVideoRuleCollection__formats;
                goto LABEL_72;
              }
              continue;
            }
            break;
          }
          v24 = &OBJC_IVAR___VCMediaNegotiationBlobVideoRuleCollection__formats;
          goto LABEL_70;
        case 4u:
          v35 = 0;
          v36 = 0;
          v19 = 0;
          *(_BYTE *)(a1 + 32) |= 2u;
          while (2)
          {
            v37 = *v3;
            v38 = *(_QWORD *)(a2 + v37);
            if (v38 == -1 || v38 >= *(_QWORD *)(a2 + *v4))
            {
              v24 = &OBJC_IVAR___VCMediaNegotiationBlobVideoRuleCollection__preferredFormat;
              goto LABEL_69;
            }
            v39 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v38);
            *(_QWORD *)(a2 + v37) = v38 + 1;
            v19 |= (unint64_t)(v39 & 0x7F) << v35;
            if (v39 < 0)
            {
              v35 += 7;
              v23 = v36++ > 8;
              if (v23)
              {
                LODWORD(v19) = 0;
                v24 = &OBJC_IVAR___VCMediaNegotiationBlobVideoRuleCollection__preferredFormat;
                goto LABEL_72;
              }
              continue;
            }
            break;
          }
          v24 = &OBJC_IVAR___VCMediaNegotiationBlobVideoRuleCollection__preferredFormat;
          goto LABEL_70;
        case 5u:
          v40 = 0;
          v41 = 0;
          v19 = 0;
          *(_BYTE *)(a1 + 32) |= 1u;
          while (2)
          {
            v42 = *v3;
            v43 = *(_QWORD *)(a2 + v42);
            if (v43 == -1 || v43 >= *(_QWORD *)(a2 + *v4))
            {
              v24 = &OBJC_IVAR___VCMediaNegotiationBlobVideoRuleCollection__formatsExt1;
              goto LABEL_69;
            }
            v44 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v43);
            *(_QWORD *)(a2 + v42) = v43 + 1;
            v19 |= (unint64_t)(v44 & 0x7F) << v40;
            if (v44 < 0)
            {
              v40 += 7;
              v23 = v41++ > 8;
              if (v23)
              {
                LODWORD(v19) = 0;
                v24 = &OBJC_IVAR___VCMediaNegotiationBlobVideoRuleCollection__formatsExt1;
                goto LABEL_72;
              }
              continue;
            }
            break;
          }
          v24 = &OBJC_IVAR___VCMediaNegotiationBlobVideoRuleCollection__formatsExt1;
          goto LABEL_70;
        case 6u:
          v45 = 0;
          v46 = 0;
          v19 = 0;
          *(_BYTE *)(a1 + 32) |= 4u;
          break;
        default:
          if ((PBReaderSkipValueWithTag() & 1) != 0)
            continue;
          return 0;
      }
      while (1)
      {
        v47 = *v3;
        v48 = *(_QWORD *)(a2 + v47);
        if (v48 == -1 || v48 >= *(_QWORD *)(a2 + *v4))
          break;
        v49 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v48);
        *(_QWORD *)(a2 + v47) = v48 + 1;
        v19 |= (unint64_t)(v49 & 0x7F) << v45;
        if ((v49 & 0x80) == 0)
        {
          v24 = &OBJC_IVAR___VCMediaNegotiationBlobVideoRuleCollection__preferredFormatExt1;
          goto LABEL_70;
        }
        v45 += 7;
        v23 = v46++ > 8;
        if (v23)
        {
          LODWORD(v19) = 0;
          v24 = &OBJC_IVAR___VCMediaNegotiationBlobVideoRuleCollection__preferredFormatExt1;
          goto LABEL_72;
        }
      }
      v24 = &OBJC_IVAR___VCMediaNegotiationBlobVideoRuleCollection__preferredFormatExt1;
LABEL_69:
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_70:
      if (*(_BYTE *)(a2 + *v5))
        LODWORD(v19) = 0;
LABEL_72:
      *(_DWORD *)(a1 + *v24) = v19;
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void *iPhoneWiFiScreenEncodingRules(uint64_t a1, uint64_t a2, double a3, double a4)
{
  unsigned int v5;
  void *v6;

  if (a1 == 1)
  {
    v5 = 1;
    v6 = &g_AirplayWifiEncodingFormat1136x640VXE;
  }
  else if (a3 == 1136.0 && a4 == 640.0)
  {
    v5 = 1;
    v6 = &g_AirplayWifiEncodingFormat1136x640AVE;
  }
  else if (a3 == 1334.0 && a4 == 750.0)
  {
    v5 = 2;
    v6 = &g_AirplayWifiEncodingFormat1334x750AVE;
  }
  else
  {
    v6 = &g_AirplayWifiEncodingFormat1920x1080AVE;
    if (a3 == 1920.0 && a4 == 1080.0)
    {
      v5 = 3;
    }
    else if (a3 == 2436.0 && a4 == 1125.0)
    {
      v5 = 4;
      v6 = &g_AirplayWifiEncodingFormat2436x1125AVE;
    }
    else if (a3 == 2688.0 && a4 == 1242.0)
    {
      v5 = 4;
      v6 = &g_AirplayWifiEncodingFormat2436x1125AVE;
    }
    else if (a3 == 1792.0 && a4 == 828.0)
    {
      v6 = &g_AirplayWifiEncodingFormat2436x1125AVE;
      v5 = 4;
    }
    else
    {
      v5 = 3;
    }
  }
  return videoRulesForFormatList_1((uint64_t)v6, v5, a2);
}

void *iPhoneWiFiScreenDecodingRules(uint64_t a1, double a2, double a3)
{
  unsigned int v5;
  void *v6;

  if (a2 == 1136.0 && a3 == 640.0)
  {
    v5 = 4;
    v6 = &g_AirplayWifiDecodingFormat1136x640;
  }
  else if (a2 == 1334.0 && a3 == 750.0)
  {
    v5 = 6;
    v6 = &g_AirplayWifiDecodingFormat1334x750;
  }
  else
  {
    v6 = &g_AirplayWifiDecodingFormat1920x1080;
    if (a2 == 1920.0 && a3 == 1080.0)
    {
      v5 = 8;
    }
    else if (a2 == 2436.0 && a3 == 1125.0)
    {
      v5 = 10;
      v6 = &g_AirplayWifiDecodingFormat2436x1125;
    }
    else
    {
      v5 = 10;
      if (a2 == 2688.0 && a3 == 1242.0)
      {
        v6 = &g_AirplayWifiDecodingFormat2436x1125;
      }
      else if (a2 == 1792.0 && a3 == 828.0)
      {
        v6 = &g_AirplayWifiDecodingFormat2436x1125;
        v5 = 10;
      }
      else
      {
        v5 = 8;
      }
    }
  }
  return videoRulesForFormatList_1((uint64_t)v6, v5, a1);
}

void *videoRulesForFormatList_1(uint64_t a1, unsigned int a2, uint64_t a3)
{
  void *v6;
  uint64_t v7;
  unsigned int *v8;
  os_log_t *v9;
  VCVideoRule *v10;
  double v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  NSObject *v15;
  uint8_t buf[4];
  uint64_t v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (!a2)
    return 0;
  v6 = (void *)objc_opt_new();
  if (v6)
  {
    v7 = a2;
    v8 = (unsigned int *)(a1 + 8);
    v9 = (os_log_t *)MEMORY[0x1E0CF2758];
    do
    {
      v10 = [VCVideoRule alloc];
      *(float *)&v11 = (float)*v8;
      v12 = -[VCVideoRule initWithFrameWidth:frameHeight:frameRate:payload:](v10, "initWithFrameWidth:frameHeight:frameRate:payload:", *(v8 - 2), *(v8 - 1), a3, v11);
      if (v12)
      {
        v13 = (void *)v12;
        objc_msgSend(v6, "addObject:", v12);

      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v14 = VRTraceErrorLogLevelToCSTR();
        v15 = *v9;
        if (os_log_type_enabled(*v9, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          v18 = v14;
          v19 = 2080;
          v20 = "videoRulesForFormatList";
          v21 = 1024;
          v22 = 90;
          _os_log_error_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_ERROR, " [%s] %s:%d Failed to create video rule for Airplay screen !", buf, 0x1Cu);
        }
      }
      v8 += 3;
      --v7;
    }
    while (v7);
  }
  return v6;
}

uint64_t VCCoreAudio_AudioUnitMock_SetProperty(OpaqueAudioComponentInstance *a1, uint64_t a2, uint64_t a3, uint64_t a4, const void *a5, uint64_t a6)
{
  UInt32 v6;
  AudioUnitElement v8;
  AudioUnitScope v9;
  AudioUnitPropertyID v10;
  unsigned int v13;
  uint64_t v14;

  v6 = a6;
  v8 = a4;
  v9 = a3;
  v10 = a2;
  v14 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  if (-[VCCoreAudio_AudioUnitMock setProperty:inID:inScope:inElement:inData:inDataSize:outStatus:](+[VCCoreAudio_AudioUnitMock sharedInstance](VCCoreAudio_AudioUnitMock, "sharedInstance"), "setProperty:inID:inScope:inElement:inData:inDataSize:outStatus:", a1, a2, a3, a4, a5, a6, &v13))
  {
    return v13;
  }
  else
  {
    return AudioUnitSetProperty(a1, v10, v9, v8, a5, v6);
  }
}

uint64_t VCCoreAudio_AudioUnitMock_GetProperty(OpaqueAudioComponentInstance *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, UInt32 *a6)
{
  AudioUnitElement v8;
  AudioUnitScope v9;
  AudioUnitPropertyID v10;
  unsigned int v13;
  uint64_t v14;

  v8 = a4;
  v9 = a3;
  v10 = a2;
  v14 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  if (-[VCCoreAudio_AudioUnitMock getProperty:inID:inScope:inElement:outData:ioDataSize:outStatus:](+[VCCoreAudio_AudioUnitMock sharedInstance](VCCoreAudio_AudioUnitMock, "sharedInstance"), "getProperty:inID:inScope:inElement:outData:ioDataSize:outStatus:", a1, a2, a3, a4, a5, a6, &v13))
  {
    return v13;
  }
  else
  {
    return AudioUnitGetProperty(a1, v10, v9, v8, a5, a6);
  }
}

uint64_t VCCoreAudio_AudioUnitMock_Render(OpaqueAudioComponentInstance *a1, AudioUnitRenderActionFlags *a2, const AudioTimeStamp *a3, uint64_t a4, uint64_t a5, AudioBufferList *a6)
{
  UInt32 v7;
  UInt32 v8;
  unsigned int v13;
  uint64_t v14;

  v7 = a5;
  v8 = a4;
  v14 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  if (-[VCCoreAudio_AudioUnitMock render:ioActionFlags:inTimeStamp:inOutputBusNumber:inNumberFrames:ioData:outStatus:](+[VCCoreAudio_AudioUnitMock sharedInstance](VCCoreAudio_AudioUnitMock, "sharedInstance"), "render:ioActionFlags:inTimeStamp:inOutputBusNumber:inNumberFrames:ioData:outStatus:", a1, a2, a3, a4, a5, a6, &v13))
  {
    return v13;
  }
  else
  {
    return AudioUnitRender(a1, a2, a3, v8, v7, a6);
  }
}

uint64_t VCCoreAudio_AudioUnitMock_ComplexRender(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  unsigned int v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v11 = 0;
  if (-[VCCoreAudio_AudioUnitMock complexRender:ioActionFlags:inTimeStamp:inOutputBusNumber:inNumberOfPackets:outNumberOfPackets:outPacketDescriptions:ioData:outMetadata:outMetadataByteSize:outStatus:](+[VCCoreAudio_AudioUnitMock sharedInstance](VCCoreAudio_AudioUnitMock, "sharedInstance"), "complexRender:ioActionFlags:inTimeStamp:inOutputBusNumber:inNumberOfPackets:outNumberOfPackets:outPacketDescriptions:ioData:outMetadata:outMetadataByteSize:outStatus:", a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, &v11))
  {
    return v11;
  }
  else
  {
    return AudioUnitComplexRender();
  }
}

uint64_t VCCoreAudio_AudioUnitMock_Initialize(OpaqueAudioComponentInstance *a1)
{
  unsigned int v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v3 = 0;
  if (-[VCCoreAudio_AudioUnitMock initialize:outStatus:](+[VCCoreAudio_AudioUnitMock sharedInstance](VCCoreAudio_AudioUnitMock, "sharedInstance"), "initialize:outStatus:", a1, &v3))
  {
    return v3;
  }
  else
  {
    return AudioUnitInitialize(a1);
  }
}

uint64_t VCCoreAudio_AudioUnitMock_Uninitialize(OpaqueAudioComponentInstance *a1)
{
  unsigned int v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v3 = 0;
  if (-[VCCoreAudio_AudioUnitMock uninitialize:outStatus:](+[VCCoreAudio_AudioUnitMock sharedInstance](VCCoreAudio_AudioUnitMock, "sharedInstance"), "uninitialize:outStatus:", a1, &v3))
  {
    return v3;
  }
  else
  {
    return AudioUnitUninitialize(a1);
  }
}

uint64_t VCCoreAudio_AudioUnitMock_OutputUnitStart(OpaqueAudioComponentInstance *a1)
{
  unsigned int v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v3 = 0;
  if (-[VCCoreAudio_AudioUnitMock outputUnitStart:outStatus:](+[VCCoreAudio_AudioUnitMock sharedInstance](VCCoreAudio_AudioUnitMock, "sharedInstance"), "outputUnitStart:outStatus:", a1, &v3))
  {
    return v3;
  }
  else
  {
    return AudioOutputUnitStart(a1);
  }
}

uint64_t VCCoreAudio_AudioUnitMock_OutputUnitStop(OpaqueAudioComponentInstance *a1)
{
  unsigned int v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v3 = 0;
  if (-[VCCoreAudio_AudioUnitMock outputUnitStop:outStatus:](+[VCCoreAudio_AudioUnitMock sharedInstance](VCCoreAudio_AudioUnitMock, "sharedInstance"), "outputUnitStop:outStatus:", a1, &v3))
  {
    return v3;
  }
  else
  {
    return AudioOutputUnitStop(a1);
  }
}

uint64_t VCCoreAudio_AudioUnitMock_SetParameter(OpaqueAudioComponentInstance *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, AudioUnitParameterValue a6)
{
  VCCoreAudio_AudioUnitMock *v12;
  double v13;
  unsigned int v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v15 = 0;
  v12 = +[VCCoreAudio_AudioUnitMock sharedInstance](VCCoreAudio_AudioUnitMock, "sharedInstance");
  *(AudioUnitParameterValue *)&v13 = a6;
  if (-[VCCoreAudio_AudioUnitMock audioUnit:setParameter:scope:element:value:bufferOffsetInFrames:outStatus:](v12, "audioUnit:setParameter:scope:element:value:bufferOffsetInFrames:outStatus:", a1, a2, a3, a4, a5, &v15, v13))
  {
    return v15;
  }
  else
  {
    return AudioUnitSetParameter(a1, a2, a3, a4, a6, a5);
  }
}

void VCAudioUnitMockMicThreadProc(_BYTE *a1, uint64_t a2, _BYTE *a3)
{
  if (a1[192])
  {
    a1[192] = 0;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioUnitMockMicThreadProc_cold_1();
    }
    *a3 = 1;
  }
  else
  {
    objc_msgSend(a1, "runAudioCallback");
    usleep(0x4E20u);
  }
}

uint64_t AUIOCreateHandle(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  BOOL v4;
  BOOL v6;
  _QWORD *v8;
  uint64_t v9;
  id v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  int v15;
  uint64_t v16;
  NSObject *v17;
  uint64_t Next;
  int ErrorLogLevelForModule;
  uint64_t v20;
  NSObject *v21;
  uint64_t v22;
  int v23;
  int v24;
  uint64_t v25;
  NSObject *v26;
  uint64_t v27;
  uint64_t v28;
  NSObject *v29;
  int v30;
  uint64_t v32;
  NSObject *v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  NSObject *v37;
  uint64_t Handle;
  uint64_t v39;
  int v40;
  int v41;
  uint64_t v42;
  NSObject *v43;
  uint64_t v44;
  NSObject *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  NSObject *v49;
  mach_timebase_info info;
  _QWORD v51[3];
  uint64_t (*v52)(unsigned int *, unsigned int *, const AudioTimeStamp *, unsigned int, unsigned int, AudioBufferList *);
  unint64_t v53;
  int v54;
  uint8_t v55[4];
  uint64_t v56;
  __int16 v57;
  const char *v58;
  __int16 v59;
  int v60;
  __int16 v61;
  _BYTE v62[10];
  uint64_t v63;
  uint8_t buf[48];
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  uint64_t v78;

  v78 = *MEMORY[0x1E0C80C00];
  v2 = 2149253121;
  v52 = (uint64_t (*)(unsigned int *, unsigned int *, const AudioTimeStamp *, unsigned int, unsigned int, AudioBufferList *))0xAAAAAAAAAAAAAAAALL;
  v53 = 0xAAAAAAAAAAAAAAAALL;
  memset(v51, 170, 20);
  v3 = *(unsigned __int8 *)(a2 + 138);
  v4 = v3 == 1;
  if (a1)
  {
    v6 = *(_QWORD *)(a2 + 56) || v3 == 1;
    if (v6 && *(_QWORD *)(a2 + 128))
    {
      v8 = malloc_type_calloc(1uLL, 0x290uLL, 0x10B0040920F3ACEuLL);
      if (v8)
      {
        v9 = (uint64_t)v8;
        v8[76] = *(_QWORD *)(a2 + 144);
        if (+[VCHardwareSettings deviceClass](VCHardwareSettings, "deviceClass") != 4
          || +[VCHardwareSettings builtinMicCount](VCHardwareSettings, "builtinMicCount"))
        {
          v4 = *(_QWORD *)(a2 + 120) != 0;
        }
        *(_BYTE *)(v9 + 235) = v4;
        if (VCDefaults_GetBoolValueForKey(CFSTR("forceEnableAudioMockInputPathForAppleTV"), 0))
        {
          *(_BYTE *)(v9 + 235) = *(_QWORD *)(a2 + 120) != 0;
          -[VCAudioToolboxAudioComponentMock start](+[VCAudioToolboxAudioComponentMock sharedInstance](VCAudioToolboxAudioComponentMock, "sharedInstance"), "start");
          -[VCCoreAudio_AudioUnitMock start](+[VCCoreAudio_AudioUnitMock sharedInstance](VCCoreAudio_AudioUnitMock, "sharedInstance"), "start");
        }
        *(_OWORD *)v9 = *(_OWORD *)(a2 + 48);
        *(_OWORD *)(v9 + 16) = *(_OWORD *)(a2 + 112);
        *(_QWORD *)(v9 + 32) = *(_QWORD *)(a2 + 128);
        *(_BYTE *)(v9 + 464) = *(_BYTE *)(a2 + 136);
        *(_WORD *)(v9 + 576) = *(_WORD *)(a2 + 137);
        *(_BYTE *)(v9 + 578) = objc_msgSend(+[VCTestMonitorManager sharedManager](VCTestMonitorManager, "sharedManager"), "toneInjectionEnabled");
        v10 = +[VCDefaults copyStringValueForKey:](VCDefaults, "copyStringValueForKey:", CFSTR("audioCannedReplay"));
        *(_QWORD *)(v9 + 584) = v10;
        if (!v10)
          *(_QWORD *)(v9 + 584) = +[VCDefaults copyStringValueForKey:](VCDefaults, "copyStringValueForKey:", CFSTR("cannedReplay"));
        v54 = -1431655766;
        +[VCDefaults getDoubleValueForKey:defaultValue:](VCDefaults, "getDoubleValueForKey:defaultValue:", CFSTR("audioCannedReplayLoopLength"), 0.0);
        *(_QWORD *)(v9 + 592) = v11;
        +[VCDefaults getDoubleValueForKey:defaultValue:](VCDefaults, "getDoubleValueForKey:defaultValue:", CFSTR("audioCannedReplayStartTime"), -1.0);
        *(_QWORD *)(v9 + 600) = v12;
        *(_QWORD *)(v9 + 632) = *(_QWORD *)(a2 + 168);
        *(_OWORD *)(v9 + 616) = *(_OWORD *)(a2 + 152);
        info = (mach_timebase_info)0xAAAAAAAAAAAAAAAALL;
        mach_timebase_info(&info);
        LODWORD(v14) = info.denom;
        LODWORD(v13) = info.numer;
        *(double *)(v9 + 440) = (double)v13 * 0.000000001 / (double)v14;
        LODWORD(v51[0]) = 1635086197;
        if ((*(_BYTE *)(a2 + 138) - 1) > 3u)
          v15 = 0;
        else
          v15 = dword_1D910FD30[(char)(*(_BYTE *)(a2 + 138) - 1)];
        HIDWORD(v51[0]) = v15;
        v51[1] = 1634758764;
        LODWORD(v51[2]) = 0;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v16 = VRTraceErrorLogLevelToCSTR();
          v17 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136316162;
            *(_QWORD *)&buf[4] = v16;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "AUIOCreateHandle";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 989;
            *(_WORD *)&buf[28] = 2048;
            *(_QWORD *)&buf[30] = v9;
            *(_WORD *)&buf[38] = 1024;
            *(_DWORD *)&buf[40] = HIDWORD(v51[0]);
            _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p finding next audio component with subtype=%u", buf, 0x2Cu);
          }
        }
        Next = VCAudioToolbox_AudioComponentFindNext();
        *(_QWORD *)(v9 + 40) = Next;
        ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
        if (!Next)
        {
          v27 = 2149253142;
          if (ErrorLogLevelForModule >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            {
              AUIOCreateHandle_cold_1();
              v27 = 2149253142;
            }
          }
          goto LABEL_42;
        }
        if (ErrorLogLevelForModule >= 7)
        {
          v20 = VRTraceErrorLogLevelToCSTR();
          v21 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v22 = *(_QWORD *)(v9 + 40);
            *(_DWORD *)buf = 136315906;
            *(_QWORD *)&buf[4] = v20;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "AUIOCreateHandle";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 991;
            *(_WORD *)&buf[28] = 2048;
            *(_QWORD *)&buf[30] = v22;
            _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d Found component=%p", buf, 0x26u);
          }
        }
        v76 = 0u;
        v77 = 0u;
        v74 = 0u;
        v75 = 0u;
        v72 = 0u;
        v73 = 0u;
        v70 = 0u;
        v71 = 0u;
        v68 = 0u;
        v69 = 0u;
        v66 = 0u;
        v67 = 0u;
        v65 = 0u;
        memset(buf, 0, sizeof(buf));
        v23 = VCAudioToolbox_AudioComponentCopyName();
        if (v23)
        {
          v24 = v23;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
          {
            v25 = VRTraceErrorLogLevelToCSTR();
            v26 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)v55 = 136316162;
              v56 = v25;
              v57 = 2080;
              v58 = "AUIOCreateHandle";
              v59 = 1024;
              v60 = 998;
              v61 = 1024;
              *(_DWORD *)v62 = 998;
              *(_WORD *)&v62[4] = 1024;
              *(_DWORD *)&v62[6] = v24;
              _os_log_impl(&dword_1D8A54000, v26, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/AUIO/AUIO.mm:%d: AudioComponentCopyName() returned error %d", v55, 0x28u);
            }
          }
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          v28 = VRTraceErrorLogLevelToCSTR();
          v29 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)v55 = 136315906;
            v56 = v28;
            v57 = 2080;
            v58 = "AUIOCreateHandle";
            v59 = 1024;
            v60 = 1001;
            v61 = 1024;
            *(_DWORD *)v62 = 1001;
            _os_log_impl(&dword_1D8A54000, v29, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/AUIO/AUIO.mm:%d: AudioComponentCopyName() gave a NULL name!", v55, 0x22u);
          }
        }
        v30 = VCAudioToolbox_AudioComponentInstanceNew();
        if (v30)
        {
          v27 = v30 | 0xA01B0000;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              AUIOCreateHandle_cold_5();
          }
          goto LABEL_42;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v32 = VRTraceErrorLogLevelToCSTR();
          v33 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v34 = *(_QWORD *)(v9 + 48);
            *(_DWORD *)v55 = 136316162;
            v56 = v32;
            v57 = 2080;
            v58 = "AUIOCreateHandle";
            v59 = 1024;
            v60 = 1016;
            v61 = 2048;
            *(_QWORD *)v62 = v9;
            *(_WORD *)&v62[8] = 2048;
            v63 = v34;
            _os_log_impl(&dword_1D8A54000, v33, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p AudioComponentInstanceNew succeeded, unit=%p", v55, 0x30u);
          }
        }
        if (*(_BYTE *)(v9 + 235))
        {
          v54 = 1;
          v35 = VCAudioUnit_AudioUnitSetProperty();
          if (v35)
          {
            v27 = v35 | 0xA01B0000;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                AUIOCreateHandle_cold_4();
            }
            goto LABEL_42;
          }
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v36 = VRTraceErrorLogLevelToCSTR();
            v37 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315906;
              *(_QWORD *)&buf[4] = v36;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "AUIOCreateHandle";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 1034;
              *(_WORD *)&buf[28] = 2048;
              *(_QWORD *)&buf[30] = v9;
              _os_log_impl(&dword_1D8A54000, v37, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p kAudioOutputUnitProperty_EnableIO kAudioUnitScope_Input succeeded", buf, 0x26u);
            }
          }
        }
        if (*(_BYTE *)(v9 + 577) != 1)
        {
          v54 = 1;
          v41 = VCAudioUnit_AudioUnitSetProperty();
          if (v41)
          {
            v27 = v41 | 0xA01B0000;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                AUIOCreateHandle_cold_3();
            }
            goto LABEL_42;
          }
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v42 = VRTraceErrorLogLevelToCSTR();
            v43 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315906;
              *(_QWORD *)&buf[4] = v42;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "AUIOCreateHandle";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 1047;
              *(_WORD *)&buf[28] = 2048;
              *(_QWORD *)&buf[30] = v9;
              _os_log_impl(&dword_1D8A54000, v43, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p kAudioOutputUnitProperty_EnableIO kAudioUnitScope_Output succeeded", buf, 0x26u);
            }
          }
        }
        _AUIOLoadDynamicDuckerVolumeOverride(v9);
        _AUIOLoadDynamicDuckerHALLevelOverride(v9);
        Handle = CreateHandle();
        if (Handle == 0xFFFFFFFFLL)
        {
          v27 = 2149253125;
LABEL_42:
          if (*(_QWORD *)(v9 + 48))
            VCAudioToolbox_AudioComponentInstanceDispose();
          free((void *)v9);
          return v27;
        }
        v39 = Handle;
        if (*(_BYTE *)(v9 + 235))
        {
          v52 = _AUIOMicProc;
          v53 = v9;
          v40 = VCAudioUnit_AudioUnitSetProperty();
          if (v40)
          {
            v27 = v40 | 0xA01B0000;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                AUIOCreateHandle_cold_2();
            }
            goto LABEL_85;
          }
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v44 = VRTraceErrorLogLevelToCSTR();
            v45 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315906;
              *(_QWORD *)&buf[4] = v44;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "AUIOCreateHandle";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 1072;
              *(_WORD *)&buf[28] = 2048;
              *(_QWORD *)&buf[30] = v9;
              _os_log_impl(&dword_1D8A54000, v45, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p kAudioOutputUnitProperty_SetInputCallback kAudioUnitScope_Global succeeded", buf, 0x26u);
            }
          }
        }
        if (*(_BYTE *)(v9 + 577) == 1)
        {
          v46 = AUIOSetupSystemAudioTap(v9, *(unsigned int *)(a2 + 92), *(double *)(a2 + 64));
          if ((v46 & 0x80000000) != 0)
          {
            v27 = v46;
LABEL_85:
            CheckOutHandleDebug();
            goto LABEL_42;
          }
        }
        else
        {
          v47 = AUIOSetupRendererCallback(v9, &v52);
          if ((v47 & 0x80000000) != 0)
          {
            v27 = v47;
            goto LABEL_85;
          }
        }
        pthread_mutex_init((pthread_mutex_t *)(v9 + 264), 0);
        *(_DWORD *)(v9 + 392) = 0;
        *(_QWORD *)(v9 + 328) = 0;
        *(_WORD *)(v9 + 232) = 0;
        *(_DWORD *)(v9 + 352) = 0;
        *(_BYTE *)(v9 + 528) = 0;
        *(_QWORD *)(v9 + 456) = 0x7FEFFFFFFFFFFFFFLL;
        *a1 = v39;
        v27 = 0;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v48 = VRTraceErrorLogLevelToCSTR();
          v49 = *MEMORY[0x1E0CF2758];
          v27 = 0;
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = v48;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "AUIOCreateHandle";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 1113;
            _os_log_impl(&dword_1D8A54000, v49, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d Successfully created the AUIO", buf, 0x1Cu);
            return 0;
          }
        }
        return v27;
      }
      return 2149253123;
    }
  }
  return v2;
}

void _AUIOLoadDynamicDuckerVolumeOverride(uint64_t a1)
{
  float DoubleValueForKey;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  NSObject *v7;
  int v8;
  uint64_t v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  double v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  *(_DWORD *)(a1 + 648) = 2143289344;
  DoubleValueForKey = VCDefaults_GetDoubleValueForKey(CFSTR("forcedDynamicDuckerVolume"), NAN);
  if (DoubleValueForKey >= 0.0 && DoubleValueForKey <= 1.0)
  {
    *(float *)(a1 + 648) = DoubleValueForKey;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v6 = VRTraceErrorLogLevelToCSTR();
      v7 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v8 = 136316162;
        v9 = v6;
        v10 = 2080;
        v11 = "_AUIOLoadDynamicDuckerVolumeOverride";
        v12 = 1024;
        v13 = 2316;
        v14 = 2048;
        v15 = a1;
        v16 = 2048;
        v17 = DoubleValueForKey;
        _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p Found dynamic ducker volume override. Volume=%f", (uint8_t *)&v8, 0x30u);
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      v8 = 136316162;
      v9 = v4;
      v10 = 2080;
      v11 = "_AUIOLoadDynamicDuckerVolumeOverride";
      v12 = 1024;
      v13 = 2312;
      v14 = 2048;
      v15 = a1;
      v16 = 2048;
      v17 = DoubleValueForKey;
      _os_log_error_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_ERROR, "AUIO [%s] %s:%d AUIO=%p Invalid dynamic ducker volume provided. Volume=%f", (uint8_t *)&v8, 0x30u);
    }
  }
}

void _AUIOLoadDynamicDuckerHALLevelOverride(uint64_t a1)
{
  int v2;
  int ErrorLogLevelForModule;
  uint64_t v4;
  NSObject *v5;
  const char *v6;
  NSObject *v7;
  uint32_t v8;
  uint64_t v9;
  NSObject *v10;
  int IntValueForKey;
  uint8_t buf[4];
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  uint64_t v19;
  __int16 v20;
  char *v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 577) == 4)
  {
    IntValueForKey = VCDefaults_GetIntValueForKey(CFSTR("forcedDynamicDuckerHALLevel"), 0);
    if (IntValueForKey)
    {
      v2 = VCAudioUnit_AudioUnitSetProperty();
      ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
      if (v2)
      {
        if (ErrorLogLevelForModule >= 5)
        {
          v4 = VRTraceErrorLogLevelToCSTR();
          v5 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136316418;
            v13 = v4;
            v14 = 2080;
            v15 = "_AUIOLoadDynamicDuckerHALLevelOverride";
            v16 = 1024;
            v17 = 2335;
            v18 = 2048;
            v19 = a1;
            v20 = 2080;
            v21 = FourccToCStr(v2);
            v22 = 1024;
            v23 = v2;
            v6 = "AUIO [%s] %s:%d AUIO=%p Failed to set dynamic ducker level. err='%s' (%d)";
            v7 = v5;
            v8 = 54;
LABEL_10:
            _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, v6, buf, v8);
          }
        }
      }
      else if (ErrorLogLevelForModule >= 7)
      {
        v9 = VRTraceErrorLogLevelToCSTR();
        v10 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316162;
          v13 = v9;
          v14 = 2080;
          v15 = "_AUIOLoadDynamicDuckerHALLevelOverride";
          v16 = 1024;
          v17 = 2333;
          v18 = 2048;
          v19 = a1;
          v20 = 1024;
          LODWORD(v21) = IntValueForKey;
          v6 = "AUIO [%s] %s:%d AUIO=%p Successfully set dynamic ducker level=%d";
          v7 = v10;
          v8 = 44;
          goto LABEL_10;
        }
      }
    }
  }
}

uint64_t _AUIOMicProc(unsigned int *a1, unsigned int *a2, const AudioTimeStamp *a3, unsigned int a4, unsigned int a5, AudioBufferList *a6)
{
  double v9;
  uint64_t AudioBufferList;
  size_t v11;
  _DWORD *v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  int v16;
  unsigned int v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  _BOOL4 v21;
  float v22;
  float AveragePower;
  float *v24;
  unint64_t v25;
  uint64_t v26;
  _DWORD *v27;
  float v29;
  int v30;
  double v31;
  const char *IsInternalOSInstalled;
  double v33;
  uint64_t v34;
  NSObject *v35;
  uint64_t v36;
  NSObject *v37;
  uint64_t mSampleTime;
  uint64_t v39;
  NSObject *v40;
  int v41;
  Float64 v42;
  uint64_t v43;
  UInt64 mHostTime;
  unsigned int v45;
  int v46;
  uint64_t v47;
  NSObject *v48;
  const void *v49;
  int v50;
  unsigned int v51;
  int SampleCapacity;
  unsigned int v54;
  unsigned int v55;
  unsigned int v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  unsigned int v60;
  unsigned int v61;
  uint8_t buf[4];
  uint64_t v63;
  __int16 v64;
  const char *v65;
  __int16 v66;
  int v67;
  __int16 v68;
  _BYTE v69[14];
  __int16 v70;
  _BYTE v71[10];
  _BYTE v72[24];
  uint64_t v73;

  v73 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _AUIOMicProc();
    }
    return 0;
  }
  v9 = *((double *)a1 + 55) * (double)a3->mHostTime;
  kdebug_trace();
  ++*((_QWORD *)a1 + 62);
  VCAudioBufferList_Reset(*((_QWORD *)a1 + 30));
  AudioBufferList = VCAudioBufferList_GetAudioBufferList(*((_QWORD *)a1 + 30));
  v59 = (uint64_t)&v59;
  v11 = a1[112];
  MEMORY[0x1E0C80A78](AudioBufferList);
  v12 = (_DWORD *)((char *)&v59 - ((v11 + 15) & 0x1FFFFFFF0));
  if ((_DWORD)v11)
    memset((char *)&v59 - ((v11 + 15) & 0x1FFFFFFF0), 170, v11);
  v61 = v11;
  if (VCAudioBufferList_GetSampleCapacity(*((_QWORD *)a1 + 30)) < a5
    && (int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v13 = VRTraceErrorLogLevelToCSTR();
    v14 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      SampleCapacity = VCAudioBufferList_GetSampleCapacity(*((_QWORD *)a1 + 30));
      *(_DWORD *)buf = 136316162;
      v63 = v13;
      v64 = 2080;
      v65 = "_AUIOMicProc";
      v66 = 1024;
      v67 = 463;
      v68 = 1024;
      *(_DWORD *)v69 = a5;
      *(_WORD *)&v69[4] = 1024;
      *(_DWORD *)&v69[6] = SampleCapacity;
      _os_log_error_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_ERROR, "AUIO [%s] %s:%d Frame size changed with inNumberFrames=%d being greater than sample buffer size=%d", buf, 0x28u);
    }
  }
  if (VCAudioBufferList_GetSampleCapacity(*((_QWORD *)a1 + 30)) <= a5)
    a5 = VCAudioBufferList_GetSampleCapacity(*((_QWORD *)a1 + 30));
  v60 = a5;
  VCAudioBufferList_SetSampleCount(*((_QWORD *)a1 + 30), a5);
  if (*((_BYTE *)a1 + 576))
    goto LABEL_11;
  v16 = *((unsigned __int8 *)a1 + 577);
  if (v16 == 2)
    goto LABEL_100;
  if (v16 == 1)
    goto LABEL_11;
  if (!*((_BYTE *)a1 + 577))
  {
LABEL_100:
    if (*((_BYTE *)a1 + 235))
      goto LABEL_20;
LABEL_11:
    v15 = VCAudioUnit_AudioUnitRender();
    v61 = 0;
    goto LABEL_21;
  }
LABEL_20:
  v15 = VCAudioUnit_AudioUnitComplexRender();
LABEL_21:
  kdebug_trace();
  if ((_DWORD)v15)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _AUIOMicProc();
    }
    ++*((_QWORD *)a1 + 63);
    (*((void (**)(_QWORD, uint64_t))a1 + 4))(*((_QWORD *)a1 + 2), 2149253127);
  }
  else
  {
    v17 = v61;
    if (v61 > a1[112])
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v18 = VRTraceErrorLogLevelToCSTR();
        v19 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v54 = a1[112];
          *(_DWORD *)buf = 136316162;
          v63 = v18;
          v64 = 2080;
          v65 = "_AUIOMicProc";
          v66 = 1024;
          v67 = 492;
          v68 = 1024;
          *(_DWORD *)v69 = v54;
          *(_WORD *)&v69[4] = 1024;
          *(_DWORD *)&v69[6] = v61;
          _os_log_error_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_ERROR, "AUIO [%s] %s:%d STACK OVERFLOW: Please file a radar. MetaData buffer is too small (%d). Required:%d", buf, 0x28u);
        }
      }
      v17 = v61;
    }
    v20 = *((_QWORD *)a1 + 30);
    if (v17)
    {
      if (v17 >= 8)
      {
        v21 = 0;
        v24 = (float *)(v12 + 2);
        v22 = 0.0;
        v25 = (unint64_t)v12 + v17;
        while (1)
        {
          v26 = v12[1];
          v27 = (_DWORD *)((char *)v24 + v26);
          if ((unint64_t)v24 + v26 > v25)
            break;
          if (*v12 == 1886348386)
          {
            if ((_DWORD)v26 == 4)
              v22 = *v24;
          }
          else if (*v12 == 1935762482 && (_DWORD)v26 == 4)
          {
            v21 = *(_DWORD *)v24 == 0;
          }
          v24 = (float *)(v27 + 2);
          v12 = v27;
          if ((unint64_t)(v27 + 2) > v25)
            goto LABEL_51;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _AUIOMicProc();
        }
      }
      else
      {
        v21 = 0;
        v22 = 0.0;
      }
LABEL_51:
      a1[98] = v21;
      *((float *)a1 + 87) = v22;
      *((_QWORD *)a1 + 64) += v21;
      VCAudioBufferList_SetAveragePower(v20, v22);
      AveragePower = *((float *)a1 + 87);
    }
    else
    {
      AveragePower = VCAudioBufferList_GetAveragePower(*((_QWORD *)a1 + 30));
      *((float *)a1 + 87) = AveragePower;
    }
    v29 = *((float *)a1 + 88) * 0.9 + AveragePower * 0.1;
    *((float *)a1 + 88) = v29;
    if (a1[83])
      a1[87] = -1024458752;
    if (*((_QWORD *)a1 + 64))
    {
      v30 = a1[98];
    }
    else
    {
      v30 = 1;
      a1[98] = 1;
    }
    VCAudioBufferList_SetVoiceActivity(v20, v30);
    v31 = 0.0;
    IsInternalOSInstalled = (const char *)VRTraceIsInternalOSInstalled();
    if ((_DWORD)IsInternalOSInstalled)
      v31 = micro();
    if (*((_BYTE *)a1 + 234))
    {
      if (LogProfileTimeOverLimitCompare(*((double *)a1 + 65), v31, v33, IsInternalOSInstalled, *(_QWORD *)&v31, *((_QWORD *)a1 + 65), v31 - *((double *)a1 + 65)))
      {
        if (a1[98])
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v34 = VRTraceErrorLogLevelToCSTR();
            v35 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315906;
              v63 = v34;
              v64 = 2080;
              v65 = "_AUIOMicProcDetectDelayedSamples";
              v66 = 1024;
              v67 = 432;
              v68 = 2048;
              *(_QWORD *)v69 = a1;
              _os_log_impl(&dword_1D8A54000, v35, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p received first non-silence audio frame", buf, 0x26u);
            }
          }
        }
        else
        {
          *((_BYTE *)a1 + 528) = 0;
        }
      }
      else if (!*((_BYTE *)a1 + 528) && a1[98])
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v36 = VRTraceErrorLogLevelToCSTR();
          v37 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315906;
            v63 = v36;
            v64 = 2080;
            v65 = "_AUIOMicProcDetectDelayedSamples";
            v66 = 1024;
            v67 = 435;
            v68 = 2048;
            *(_QWORD *)v69 = a1;
            _os_log_impl(&dword_1D8A54000, v37, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p received first non-silence audio frame", buf, 0x26u);
          }
        }
        *((_BYTE *)a1 + 528) = 1;
      }
      *((double *)a1 + 65) = v31;
      mSampleTime = (uint64_t)a3->mSampleTime;
      VCAudioBufferList_SetTime(*((_QWORD *)a1 + 30), mSampleTime, v9);
      if ((a3->mSampleTime == 0.0 || a1[104] == (_DWORD)mSampleTime || a1[103] > mSampleTime)
        && (int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v39 = VRTraceErrorLogLevelToCSTR();
        v40 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v41 = mSampleTime - a1[103];
          v42 = a3->mSampleTime;
          v43 = (uint64_t)a3->mSampleTime;
          mHostTime = a3->mHostTime;
          *(_DWORD *)buf = 136317186;
          v63 = v39;
          v64 = 2080;
          v65 = "_AUIOLogAbnormalTimestamps";
          v66 = 1024;
          v67 = 254;
          v68 = 1024;
          *(_DWORD *)v69 = v41;
          *(_WORD *)&v69[4] = 2048;
          *(Float64 *)&v69[6] = v42;
          v70 = 2048;
          *(_QWORD *)v71 = v43;
          *(_WORD *)&v71[8] = 1024;
          *(_DWORD *)v72 = mSampleTime;
          *(_WORD *)&v72[4] = 2048;
          *(_QWORD *)&v72[6] = mHostTime;
          *(_WORD *)&v72[14] = 2048;
          *(double *)&v72[16] = v9;
          _os_log_impl(&dword_1D8A54000, v40, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d inSampleTime - pAUIO->numBufferedMicSamples = %d, inTimeStamp = %f, converted %lld, inSampleTime %u, HostTime %lld %f", buf, 0x50u);
        }
      }
      v45 = a1[104];
      if (v45)
      {
        v46 = a1[108];
        if (v46)
        {
          if (vabdd_f64(a3->mSampleTime, (double)v45) > 2 * a5)
          {
            a1[108] = (int)((double)v46 - (a3->mSampleTime - (double)v45));
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              v47 = VRTraceErrorLogLevelToCSTR();
              v48 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              {
                v55 = a1[108];
                v56 = a1[104];
                v57 = (int)a3->mSampleTime;
                v58 = *((_QWORD *)a1 + 53);
                *(_DWORD *)buf = 136317186;
                v63 = v47;
                v64 = 2080;
                v65 = "_AUIOMicProc";
                v66 = 1024;
                v67 = 524;
                v68 = 2048;
                *(_QWORD *)v69 = a1;
                *(_WORD *)&v69[8] = 1024;
                *(_DWORD *)&v69[10] = v55;
                v70 = 1024;
                *(_DWORD *)v71 = v56;
                *(_WORD *)&v71[4] = 1024;
                *(_DWORD *)&v71[6] = v57;
                *(_WORD *)v72 = 2048;
                *(_QWORD *)&v72[2] = v58;
                *(_WORD *)&v72[10] = 2048;
                *(double *)&v72[12] = v9;
                _os_log_error_impl(&dword_1D8A54000, v48, OS_LOG_TYPE_ERROR, "AUIO [%s] %s:%d AUIO=%p Modifying timestamp delta to timeStampDelta=%d because mic also jumped latestMicTimeStamp=%d to latestMicTimeStamp=%d, hostTime jumped latestMicHostTime=%f to inHostTime=%f", buf, 0x4Cu);
              }
            }
          }
        }
      }
      a1[104] = mSampleTime;
      *((double *)a1 + 53) = v9;
      if (a1[134] + a1[133] != a1[135]
        && vabdd_f64(a3->mSampleTime, (double)mSampleTime) > (double)(int)(4 * a5))
      {
        ++a1[136];
      }
      kdebug_trace();
      v49 = (const void *)*((_QWORD *)a1 + 30);
      if (*((_BYTE *)a1 + 464))
      {
        if (!PacketThread_SendSampleBuffer(*((_QWORD *)a1 + 59), v49))
          (*((void (**)(_QWORD, uint64_t))a1 + 4))(*((_QWORD *)a1 + 2), 2149253137);
      }
      else
      {
        _AUIOSendMicSamples((uint64_t)a1, (uint64_t)v49);
      }
      ++*((_QWORD *)a1 + 63);
      v50 = LogProfileTimeOverLimit(v31, 0.00600000005, "IOProc: shenanigans mic proc");
      v51 = a1[133];
      if (v50)
        a1[133] = ++v51;
      v15 = 0;
      a1[135] = a1[134] + v51;
    }
    else
    {
      ++*((_QWORD *)a1 + 63);
      if (LogProfileTimeOverLimit(v31, 0.00600000005, "IOProc: shenanigans mic proc"))
        ++a1[133];
      (*((void (**)(_QWORD, uint64_t))a1 + 4))(*((_QWORD *)a1 + 2), 2149253137);
      return 0;
    }
  }
  return v15;
}

uint64_t AUIOSetupSystemAudioTap(uint64_t a1, uint64_t a2, double a3)
{
  void *v4;
  void *v5;
  uint64_t v6;
  void *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v4 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C89AA8]), "initWithCommonFormat:sampleRate:channels:interleaved:", 1, a2, 0, a3);
  v5 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C924E8]), "initSystemTapWithFormat:", v4);
  if (!v5)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 7)
      goto LABEL_20;
    v13 = VRTraceErrorLogLevelToCSTR();
    v14 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      goto LABEL_20;
    v16 = 136315906;
    v17 = v13;
    v18 = 2080;
    v19 = "AUIOSetupSystemAudioTap";
    v20 = 1024;
    v21 = 876;
    v22 = 2048;
    v23 = a1;
    goto LABEL_19;
  }
  v6 = objc_msgSend(objc_alloc(MEMORY[0x1E0C924E0]), "initWithTapDescription:", v5);
  if (!v6)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 7)
      goto LABEL_20;
    v15 = VRTraceErrorLogLevelToCSTR();
    v14 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      goto LABEL_20;
    v16 = 136315906;
    v17 = v15;
    v18 = 2080;
    v19 = "AUIOSetupSystemAudioTap";
    v20 = 1024;
    v21 = 878;
    v22 = 2048;
    v23 = a1;
LABEL_19:
    _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p failed to allocate the audio tap", (uint8_t *)&v16, 0x26u);
LABEL_20:

    v9 = 2149253123;
    goto LABEL_12;
  }
  v7 = (void *)v6;
  v8 = VCAudioUnit_AudioUnitSetProperty();
  if (v8)
  {
    v9 = v8 | 0xA01B0000;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        AUIOSetupSystemAudioTap();
    }
    goto LABEL_11;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() < 7)
    goto LABEL_10;
  v10 = VRTraceErrorLogLevelToCSTR();
  v11 = *MEMORY[0x1E0CF2758];
  v9 = 0;
  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
  {
    v16 = 136315906;
    v17 = v10;
    v18 = 2080;
    v19 = "AUIOSetupSystemAudioTap";
    v20 = 1024;
    v21 = 886;
    v22 = 2048;
    v23 = a1;
    _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p kAudioOutputUnitProperty_AudioTapObject kAudioUnitScope_Global succeeded", (uint8_t *)&v16, 0x26u);
LABEL_10:
    v9 = 0;
  }
LABEL_11:

LABEL_12:
  return v9;
}

uint64_t AUIOSetupRendererCallback(uint64_t a1, _QWORD *a2)
{
  uint64_t (*v3)(_QWORD *, unsigned int *, const AudioTimeStamp *, unsigned int, unsigned int, AudioBufferList *);
  int v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  int v9;
  uint64_t v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v3 = _AUIOSpkrProc;
  if (!*(_BYTE *)(a1 + 464))
    v3 = _AUIOSpkrProcGKS;
  *a2 = v3;
  a2[1] = a1;
  v4 = VCAudioUnit_AudioUnitSetProperty();
  if (!v4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v6 = VRTraceErrorLogLevelToCSTR();
      v7 = *MEMORY[0x1E0CF2758];
      v5 = 0;
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        return v5;
      v9 = 136315906;
      v10 = v6;
      v11 = 2080;
      v12 = "AUIOSetupRendererCallback";
      v13 = 1024;
      v14 = 914;
      v15 = 2048;
      v16 = a1;
      _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p kAudioUnitProperty_SetRenderCallback kAudioUnitScope_Global succeeded", (uint8_t *)&v9, 0x26u);
    }
    return 0;
  }
  v5 = v4 | 0xA01B0000;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      AUIOSetupRendererCallback();
  }
  return v5;
}

uint64_t AUIOCloseHandle()
{
  uint64_t v0;
  int ErrorLogLevelForModule;
  os_log_t *v2;
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  int *v11;
  NSObject *v12;
  NSObject *v13;
  uint64_t v14;
  NSObject *v15;
  _BOOL4 v16;
  uint64_t result;
  int v18;
  uint64_t v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v0 = CheckInHandleDebug();
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  v2 = (os_log_t *)MEMORY[0x1E0CF2758];
  if (ErrorLogLevelForModule >= 7)
  {
    v3 = VRTraceErrorLogLevelToCSTR();
    v4 = *v2;
    if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
    {
      v18 = 136315906;
      v19 = v3;
      v20 = 2080;
      v21 = "AUIOCloseHandle";
      v22 = 1024;
      v23 = 1131;
      v24 = 2048;
      v25 = v0;
      _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d Destroying AUIO=%p", (uint8_t *)&v18, 0x26u);
    }
  }
  if (!v0)
    return 2149253122;
  CheckOutHandleDebug();
  VCAudioToolbox_AudioComponentInstanceDispose();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v5 = VRTraceErrorLogLevelToCSTR();
    v6 = *v2;
    if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
    {
      v7 = *(_QWORD *)(v0 + 48);
      v18 = 136316162;
      v19 = v5;
      v20 = 2080;
      v21 = "AUIOCloseHandle";
      v22 = 1024;
      v23 = 1161;
      v24 = 2048;
      v25 = v0;
      v26 = 2048;
      v27 = v7;
      _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d Disposed AUIO=%p unit=%p", (uint8_t *)&v18, 0x30u);
    }
  }
  pthread_mutex_destroy((pthread_mutex_t *)(v0 + 264));
  v8 = *(void **)(v0 + 400);
  if (v8)
    free(v8);
  VCAudioBufferList_Destroy((uint64_t *)(v0 + 248));
  VCAudioBufferList_Destroy((uint64_t *)(v0 + 240));
  v9 = *(_QWORD *)(v0 + 336);
  if (v9)
    MEMORY[0x1DF087DC8](v9, 0x1000C407AA769CALL);
  v10 = *(_QWORD *)(v0 + 360);
  if (v10)
    MEMORY[0x1DF087DC8](v10, 0x1000C407AA769CALL);
  v11 = *(int **)(v0 + 472);
  if (v11)
    PacketThread_Destroy(v11);
  v12 = *(NSObject **)(v0 + 568);
  if (v12)
  {
    dispatch_source_cancel(v12);
    v13 = *(NSObject **)(v0 + 568);
    if (v13)
    {
      dispatch_release(v13);
      *(_QWORD *)(v0 + 568) = 0;
    }
  }

  *(_QWORD *)(v0 + 480) = 0;
  if (VCDefaults_GetBoolValueForKey(CFSTR("forceEnableAudioMockInputPathForAppleTV"), 0))
  {
    -[VCAudioToolboxAudioComponentMock stop](+[VCAudioToolboxAudioComponentMock sharedInstance](VCAudioToolboxAudioComponentMock, "sharedInstance"), "stop");
    -[VCCoreAudio_AudioUnitMock stop](+[VCCoreAudio_AudioUnitMock sharedInstance](VCCoreAudio_AudioUnitMock, "sharedInstance"), "stop");
  }

  free((void *)v0);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v14 = VRTraceErrorLogLevelToCSTR();
    v15 = *v2;
    v16 = os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v16)
      return result;
    v18 = 136315650;
    v19 = v14;
    v20 = 2080;
    v21 = "AUIOCloseHandle";
    v22 = 1024;
    v23 = 1200;
    _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO Closed Handle.", (uint8_t *)&v18, 0x1Cu);
  }
  return 0;
}

uint64_t AUIOSuspend(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  pthread_mutex_t *v6;
  uint64_t v7;
  NSObject *v8;
  int v9;
  int v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  int *v14;
  int v15;
  int v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;
  int v21;
  uint64_t v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  int v26;
  __int16 v27;
  uint64_t v28;
  __int16 v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v3 = 2149253142;
  v4 = CheckInHandleDebug();
  if (v4)
  {
    v5 = v4;
    v6 = (pthread_mutex_t *)(v4 + 264);
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 264));
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v7 = VRTraceErrorLogLevelToCSTR();
      v8 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v21 = 136315906;
        v22 = v7;
        v23 = 2080;
        v24 = "AUIOSuspend";
        v25 = 1024;
        v26 = 1671;
        v27 = 2048;
        v28 = v5;
        _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p Stopping the audio unit.", (uint8_t *)&v21, 0x26u);
      }
    }
    if (!*(_QWORD *)(v5 + 48))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          AUIOSuspend_cold_1();
      }
      goto LABEL_34;
    }
    if (*(_BYTE *)(v5 + 233))
    {
      v9 = VCAudioUnit_AudioOutputUnitStop();
      if (v9)
      {
        v10 = v9;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            AUIOSuspend_cold_3();
        }
        v3 = v10 | 0xA01B0000;
        goto LABEL_34;
      }
      v14 = *(int **)(v5 + 472);
      if (v14)
      {
        PacketThread_Destroy(v14);
        *(_QWORD *)(v5 + 472) = 0;
      }
      *(_BYTE *)(v5 + 233) = 0;
      if (!a2)
      {
LABEL_30:
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v17 = VRTraceErrorLogLevelToCSTR();
          v18 = *MEMORY[0x1E0CF2758];
          v3 = 0;
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
LABEL_34:
            pthread_mutex_unlock(v6);
            CheckOutHandleDebug();
            return v3;
          }
          v19 = *(_QWORD *)(v5 + 48);
          v21 = 136316162;
          v22 = v17;
          v23 = 2080;
          v24 = "AUIOSuspend";
          v25 = 1024;
          v26 = 1700;
          v27 = 2048;
          v28 = v5;
          v29 = 2048;
          v30 = v19;
          _os_log_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p unit=%p uninitialized", (uint8_t *)&v21, 0x30u);
        }
        v3 = 0;
        goto LABEL_34;
      }
    }
    else
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v11 = VRTraceErrorLogLevelToCSTR();
        v12 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v13 = *(_QWORD *)(v5 + 48);
          v21 = 136316162;
          v22 = v11;
          v23 = 2080;
          v24 = "AUIOSuspend";
          v25 = 1024;
          v26 = 1688;
          v27 = 2048;
          v28 = v5;
          v29 = 2048;
          v30 = v13;
          _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p unit=%p stopped", (uint8_t *)&v21, 0x30u);
        }
      }
      if (!a2)
        goto LABEL_30;
    }
    if (*(_BYTE *)(v5 + 232))
    {
      v15 = VCAudioUnit_AudioUnitUninitialize();
      if (v15)
      {
        v16 = v15;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            AUIOSuspend_cold_2();
        }
        v3 = v16 | 0xA01B0000;
      }
      else
      {
        v3 = 0;
        *(_BYTE *)(v5 + 232) = 0;
      }
      goto LABEL_34;
    }
    goto LABEL_30;
  }
  return 2149253122;
}

uint64_t AUIOResume()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  pthread_mutex_t *v3;
  uint64_t v4;
  NSObject *v5;
  int v6;
  uint64_t v8;
  int v9;
  int ErrorLogLevelForModule;
  int *v11;
  uint64_t v12;
  NSObject *v13;
  int v14;
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v0 = 2149253122;
  v1 = CheckInHandleDebug();
  if (v1)
  {
    v2 = v1;
    v3 = (pthread_mutex_t *)(v1 + 264);
    pthread_mutex_lock((pthread_mutex_t *)(v1 + 264));
    if (*(_BYTE *)(v2 + 232))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v4 = VRTraceErrorLogLevelToCSTR();
        v5 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v6 = *(unsigned __int8 *)(v2 + 233);
          v14 = 136316162;
          v15 = v4;
          v16 = 2080;
          v17 = "AUIOResume";
          v18 = 1024;
          v19 = 1721;
          v20 = 2048;
          v21 = v2;
          v22 = 1024;
          v23 = v6;
          _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p AUIO resume pAUIO->audioUnitIsStarted=%d", (uint8_t *)&v14, 0x2Cu);
        }
      }
      if (*(_BYTE *)(v2 + 233))
      {
        v0 = 0;
      }
      else
      {
        v8 = _AUIOStartPacketThread(v2);
        if ((v8 & 0x80000000) != 0)
        {
          v0 = v8;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              AUIOResume_cold_1();
          }
        }
        else
        {
          *(_QWORD *)(v2 + 456) = 0x7FEFFFFFFFFFFFFFLL;
          v9 = VCAudioUnit_AudioOutputUnitStart();
          ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
          if (v9)
          {
            if (ErrorLogLevelForModule >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                AUIOResume_cold_2();
            }
            v0 = v9 | 0xA01B0000;
            v11 = *(int **)(v2 + 472);
            if (v11)
            {
              PacketThread_Destroy(v11);
              *(_QWORD *)(v2 + 472) = 0;
            }
          }
          else
          {
            if (ErrorLogLevelForModule >= 7)
            {
              v12 = VRTraceErrorLogLevelToCSTR();
              v13 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                v14 = 136315906;
                v15 = v12;
                v16 = 2080;
                v17 = "AUIOResume";
                v18 = 1024;
                v19 = 1735;
                v20 = 1024;
                LODWORD(v21) = 1735;
                _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/AUIO/AUIO.mm:%d: AudioOutputUnitStart completed", (uint8_t *)&v14, 0x22u);
              }
            }
            v0 = 0;
            *(_BYTE *)(v2 + 233) = 1;
          }
        }
      }
    }
    else
    {
      v0 = 2149253176;
    }
    pthread_mutex_unlock(v3);
    CheckOutHandleDebug();
  }
  return v0;
}

uint64_t _AUIOStartPacketThread(uint64_t a1)
{
  uint64_t v2;
  int SerializedSize;
  uint64_t v4;
  _QWORD v6[6];

  v6[5] = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 464))
    return 0;
  if (*(_QWORD *)(a1 + 472))
  {
    v2 = 2149253121;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _AUIOStartPacketThread();
    }
  }
  else
  {
    SerializedSize = VCAudioBufferList_GetSerializedSize(*(unsigned int **)(a1 + 240));
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 3221225472;
    v6[2] = ___ZL22_AUIOStartPacketThreadP7tagAUIO_block_invoke;
    v6[3] = &__block_descriptor_40_e15_v28__0_v8_16I24l;
    v6[4] = a1;
    v4 = PacketThread_Create(SerializedSize, 0, 0x10u, 19, (uint64_t)"com.apple.AVConference.auio", v6);
    v2 = 0;
    *(_QWORD *)(a1 + 472) = v4;
    if (!v4)
    {
      v2 = 2149253121;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _AUIOStartPacketThread();
      }
    }
  }
  return v2;
}

uint64_t AUIOSetupFormats(double a1, uint64_t a2, uint64_t a3, __int128 *a4, uint64_t a5, int a6, int a7, int a8, unsigned int a9)
{
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  pthread_mutex_t *v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  NSObject *v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  int v30;
  int v31;
  void *v32;
  int v33;
  size_t v34;
  uint64_t v35;
  NSObject *v36;
  int v37;
  int v38;
  uint64_t v39;
  int v40;
  int v41;
  int ErrorLogLevelForModule;
  uint64_t v43;
  NSObject *v44;
  uint64_t v45;
  NSObject *v46;
  int v47;
  uint64_t v48;
  NSObject *v49;
  const char *v50;
  NSObject *v51;
  uint32_t v52;
  uint64_t v53;
  NSObject *v54;
  uint64_t v55;
  __int128 v56;
  __int128 v57;
  int v58;
  int v59;
  uint64_t v60;
  NSObject *v61;
  uint64_t v62;
  NSObject *v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  NSObject *v67;
  float v68;
  int v69;
  int v70;
  uint64_t v71;
  NSObject *v72;
  int v73;
  int v74;
  uint64_t v75;
  NSObject *v76;
  const char *v77;
  _BOOL4 v78;
  int v79;
  int v80;
  uint64_t v81;
  NSObject *v82;
  const char *v83;
  NSObject *v84;
  uint32_t v85;
  uint64_t v86;
  NSObject *v87;
  uint64_t v88;
  NSObject *v89;
  int v90;
  int v91;
  uint64_t v92;
  NSObject *v93;
  int v94;
  char *v95;
  uint64_t v96;
  NSObject *v97;
  uint64_t v98;
  NSObject *v99;
  int Property;
  int v101;
  int v102;
  uint64_t v103;
  NSObject *v104;
  uint64_t v105;
  NSObject *v106;
  uint64_t v107;
  NSObject *v108;
  int v109;
  int v110;
  int v111;
  uint64_t v112;
  NSObject *v113;
  const char *v114;
  NSObject *v115;
  uint32_t v116;
  uint64_t v117;
  NSObject *v118;
  int v119;
  int v120;
  uint64_t v121;
  NSObject *v122;
  uint64_t v123;
  NSObject *v124;
  int v125;
  uint64_t v126;
  NSObject *v127;
  int AppBooleanValue;
  int v129;
  uint64_t v130;
  NSObject *v131;
  uint64_t v132;
  NSObject *v133;
  void *v134;
  _BOOL8 v135;
  VCCannedAudioInjectorConfig *v136;
  VCCannedAudioInjectorConfig *v137;
  __int128 v138;
  _BOOL8 v139;
  double v140;
  int v141;
  BOOL v142;
  uint64_t v143;
  VCCannedAudioInjector *v144;
  uint64_t v145;
  NSObject *v146;
  uint64_t v148;
  const char *v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  unsigned int v153;
  int v154;
  int v155;
  Boolean keyExistsAndHasValidFormat;
  int v157;
  int v158;
  int v159;
  Boolean v160[16];
  __int128 v161;
  uint64_t v162;
  _BYTE buf[56];
  __int16 v164;
  int v165;
  __int16 v166;
  void *v167;
  __int16 v168;
  uint64_t v169;
  __int16 v170;
  int v171;
  uint64_t v172;

  v172 = *MEMORY[0x1E0C80C00];
  v17 = 2149253123;
  v18 = CheckInHandleDebug();
  if (v18)
  {
    v19 = v18;
    v153 = a9;
    v154 = a6;
    v20 = (pthread_mutex_t *)(v18 + 264);
    pthread_mutex_lock((pthread_mutex_t *)(v18 + 264));
    v158 = a8;
    v159 = a7;
    keyExistsAndHasValidFormat = 0;
    v155 = objc_msgSend(*(id *)(v19 + 608), "audioSessionId");
    v22 = *(_OWORD *)(a3 + 16);
    v21 = *(_OWORD *)(a3 + 32);
    *(_OWORD *)(v19 + 136) = *(_OWORD *)a3;
    *(_OWORD *)(v19 + 152) = v22;
    *(_OWORD *)(v19 + 168) = v21;
    if (a4)
    {
      v23 = *a4;
      v24 = a4[1];
      *(_OWORD *)(v19 + 216) = a4[2];
      *(_OWORD *)(v19 + 200) = v24;
      *(_OWORD *)(v19 + 184) = v23;
    }
    v157 = -1431655766;
    if (*(_BYTE *)(v19 + 235))
    {
      v152 = a5;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v25 = VRTraceErrorLogLevelToCSTR();
        v26 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316162;
          *(_QWORD *)&buf[4] = v25;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "AUIOSetupMic";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 1227;
          *(_WORD *)&buf[28] = 2048;
          *(_QWORD *)&buf[30] = v19;
          *(_WORD *)&buf[38] = 1024;
          *(_DWORD *)&buf[40] = 0;
          _os_log_impl(&dword_1D8A54000, v26, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p Setting up mic reinitialize=%d", buf, 0x2Cu);
        }
      }
      v27 = *(_QWORD *)(v19 + 240);
      v28 = *(_OWORD *)(v19 + 152);
      *(_OWORD *)(v19 + 96) = *(_OWORD *)(v19 + 136);
      *(_OWORD *)(v19 + 112) = v28;
      *(_QWORD *)(v19 + 128) = *(_QWORD *)(v19 + 168);
      if (v27)
        VCAudioBufferList_Destroy((uint64_t *)(v19 + 240));
      v29 = *(_OWORD *)(v19 + 112);
      *(_OWORD *)v160 = *(_OWORD *)(v19 + 96);
      v161 = v29;
      v162 = *(_QWORD *)(v19 + 128);
      if ((VCAudioBufferList_Allocate((__int128 *)v160, 5 * *(_DWORD *)(v19 + 176), (_QWORD *)(v19 + 240)) & 1) == 0)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            AUIOSetupFormats_cold_11();
        }
        goto LABEL_189;
      }
      v151 = a3;
      v30 = *(_DWORD *)(v19 + 256);
      v31 = *(_DWORD *)(v19 + 408);
      v32 = *(void **)(v19 + 400);
      v33 = 5 * *(_DWORD *)(v19 + 176);
      *(_DWORD *)(v19 + 256) = v33;
      v34 = (*(_DWORD *)(v19 + 120) * v33);
      *(_DWORD *)(v19 + 408) = v34;
      *(_QWORD *)(v19 + 400) = malloc_type_realloc(v32, v34, 0x8F1BCF97uLL);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v35 = VRTraceErrorLogLevelToCSTR();
        v36 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v37 = *(_DWORD *)(v19 + 256);
          v38 = *(_DWORD *)(v19 + 408);
          v39 = *(_QWORD *)(v19 + 400);
          v40 = *(_DWORD *)(v19 + 412);
          *(_DWORD *)buf = 136317698;
          *(_QWORD *)&buf[4] = v35;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_AUIOReallocBufferedMicSamples";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 1214;
          *(_WORD *)&buf[28] = 2048;
          *(_QWORD *)&buf[30] = v19;
          *(_WORD *)&buf[38] = 1024;
          *(_DWORD *)&buf[40] = v30;
          *(_WORD *)&buf[44] = 1024;
          *(_DWORD *)&buf[46] = v37;
          *(_WORD *)&buf[50] = 1024;
          *(_DWORD *)&buf[52] = v31;
          v164 = 1024;
          v165 = v38;
          v166 = 2048;
          v167 = v32;
          v168 = 2048;
          v169 = v39;
          v170 = 1024;
          v171 = v40;
          _os_log_impl(&dword_1D8A54000, v36, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p Reallocated the buffered mic sample buffer. prevMaxSampleSize=%d maxSampleSize=%d prevMaxByteSize=%u maxByteSize=%u prevBufferedMicSamples=0x%lx bufferedMicSamples=%p sampleCount=%d", buf, 0x58u);
        }
      }
      if (!*(_QWORD *)(v19 + 400))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            AUIOSetupFormats_cold_10();
        }
        goto LABEL_189;
      }
      FileUtil_PrintBasicDesc((uint64_t)"MicOutFmt:", (uint64_t *)(v19 + 96));
      v41 = VCAudioUnit_AudioUnitSetProperty();
      ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
      if (v41)
      {
        if (ErrorLogLevelForModule >= 3)
        {
          v43 = VRTraceErrorLogLevelToCSTR();
          v44 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136316162;
            *(_QWORD *)&buf[4] = v43;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "AUIOSetupMic";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 1272;
            *(_WORD *)&buf[28] = 2048;
            *(_QWORD *)&buf[30] = v19;
            *(_WORD *)&buf[38] = 1024;
            *(_DWORD *)&buf[40] = v41;
            _os_log_error_impl(&dword_1D8A54000, v44, OS_LOG_TYPE_ERROR, "AUIO [%s] %s:%d AUIO=%p AudioUnitSetProperty(MicOut) StreamFormat failed(%d)", buf, 0x2Cu);
          }
        }
        v17 = v41 | 0xA01B0000;
        goto LABEL_189;
      }
      if (ErrorLogLevelForModule >= 7)
      {
        v45 = VRTraceErrorLogLevelToCSTR();
        v46 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315906;
          *(_QWORD *)&buf[4] = v45;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "AUIOSetupMic";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 1275;
          *(_WORD *)&buf[28] = 2048;
          *(_QWORD *)&buf[30] = v19;
          _os_log_impl(&dword_1D8A54000, v46, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p kAudioUnitProperty_StreamFormat kAudioUnitScope_Output set succeeded", buf, 0x26u);
        }
      }
      a5 = v152;
    }
    if (*(_BYTE *)(v19 + 577) != 1)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v53 = VRTraceErrorLogLevelToCSTR();
        v54 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316162;
          *(_QWORD *)&buf[4] = v53;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "AUIOSetupSpeaker";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 1291;
          *(_WORD *)&buf[28] = 2048;
          *(_QWORD *)&buf[30] = v19;
          *(_WORD *)&buf[38] = 1024;
          *(_DWORD *)&buf[40] = 0;
          _os_log_impl(&dword_1D8A54000, v54, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p Setting up speaker reinitialize=%d", buf, 0x2Cu);
        }
      }
      v55 = *(_QWORD *)(v19 + 248);
      v56 = *(_OWORD *)(v19 + 200);
      *(_OWORD *)(v19 + 56) = *(_OWORD *)(v19 + 184);
      *(_OWORD *)(v19 + 72) = v56;
      *(_QWORD *)(v19 + 88) = *(_QWORD *)(v19 + 216);
      if (v55)
        VCAudioBufferList_Destroy((uint64_t *)(v19 + 248));
      v57 = *(_OWORD *)(v19 + 72);
      *(_OWORD *)v160 = *(_OWORD *)(v19 + 56);
      v161 = v57;
      v162 = *(_QWORD *)(v19 + 88);
      if ((VCAudioBufferList_Allocate((__int128 *)v160, *(_DWORD *)(v19 + 224), (_QWORD *)(v19 + 248)) & 1) == 0)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            AUIOSetupFormats_cold_9();
        }
        goto LABEL_189;
      }
      FileUtil_PrintBasicDesc((uint64_t)"SpkrIn:", (uint64_t *)(v19 + 56));
      v58 = VCAudioUnit_AudioUnitSetProperty();
      v59 = VRTraceGetErrorLogLevelForModule();
      if (v58)
      {
        if (v59 >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            AUIOSetupFormats_cold_8();
        }
        goto LABEL_140;
      }
      if (v59 >= 7)
      {
        v60 = VRTraceErrorLogLevelToCSTR();
        v61 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315906;
          *(_QWORD *)&buf[4] = v60;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "AUIOSetupSpeaker";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 1339;
          *(_WORD *)&buf[28] = 2048;
          *(_QWORD *)&buf[30] = v19;
          _os_log_impl(&dword_1D8A54000, v61, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p kAudioUnitProperty_StreamFormat kAudioUnitScope_Input set succeeded", buf, 0x26u);
        }
      }
    }
    if (!*(_BYTE *)(v19 + 576) && *(_BYTE *)(v19 + 577) != 1)
    {
      v157 = VCAudioUnit_AudioUnitSetProperty();
      v47 = VRTraceGetErrorLogLevelForModule();
      if (v157)
      {
        if (v47 >= 5)
        {
          v48 = VRTraceErrorLogLevelToCSTR();
          v49 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136316674;
            *(_QWORD *)&buf[4] = v48;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 1492;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = v155;
            *(_WORD *)&buf[34] = 1024;
            *(_DWORD *)&buf[36] = v157;
            *(_WORD *)&buf[40] = 1040;
            *(_DWORD *)&buf[42] = 4;
            *(_WORD *)&buf[46] = 2080;
            *(_QWORD *)&buf[48] = &v157;
            v50 = "AUIO [%s] %s:%d AudioUnitSetProperty failed to set property kAudioOutputUnitProperty_AudioSessionID %d %d %.4s";
            v51 = v49;
            v52 = 56;
LABEL_57:
            _os_log_impl(&dword_1D8A54000, v51, OS_LOG_TYPE_DEFAULT, v50, buf, v52);
          }
        }
      }
      else if (v47 >= 7)
      {
        v62 = VRTraceErrorLogLevelToCSTR();
        v63 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v64 = *(_QWORD *)(v19 + 48);
          *(_DWORD *)buf = 136316162;
          *(_QWORD *)&buf[4] = v62;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 1494;
          *(_WORD *)&buf[28] = 2048;
          *(_QWORD *)&buf[30] = v64;
          *(_WORD *)&buf[38] = 1024;
          *(_DWORD *)&buf[40] = v155;
          v50 = "AUIO [%s] %s:%d Setting id of audio unit %p to %d";
          v51 = v63;
          v52 = 44;
          goto LABEL_57;
        }
      }
    }
    if (!*(_BYTE *)(v19 + 235))
      goto LABEL_79;
    if (*(_BYTE *)(v19 + 576))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v66 = VRTraceErrorLogLevelToCSTR();
        v67 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315906;
          *(_QWORD *)&buf[4] = v66;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 1547;
          *(_WORD *)&buf[28] = 2048;
          *(_QWORD *)&buf[30] = v19;
          _os_log_impl(&dword_1D8A54000, v67, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p setting up AudioInput and using BasebandIO", buf, 0x26u);
        }
      }
      LODWORD(v65) = *(_DWORD *)(a3 + 40);
      v68 = (double)v65 / *(double *)a3;
      *(float *)v160 = v68;
      v69 = VCAudioUnit_AudioUnitSetProperty();
      v157 = v69;
      v70 = VRTraceGetErrorLogLevelForModule();
      if (v69)
      {
        if (v70 >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            AUIOSetupFormats_cold_7();
        }
LABEL_102:
        v17 = v157 | 0xA01B0000;
LABEL_189:
        pthread_mutex_unlock(v20);
        CheckOutHandleDebug();
        return v17;
      }
      if (v70 >= 7)
      {
        v75 = VRTraceErrorLogLevelToCSTR();
        v76 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315906;
          *(_QWORD *)&buf[4] = v75;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 1554;
          *(_WORD *)&buf[28] = 2048;
          *(_QWORD *)&buf[30] = v19;
          v77 = "AUIO [%s] %s:%d AUIO=%p kAudioOutputUnitProperty_IOBufferDuration kAudioUnitScope_Global succeeded";
LABEL_78:
          _os_log_impl(&dword_1D8A54000, v76, OS_LOG_TYPE_DEFAULT, v77, buf, 0x26u);
          goto LABEL_79;
        }
      }
      goto LABEL_79;
    }
    if (*(_BYTE *)(v19 + 577) == 1)
      goto LABEL_79;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v71 = VRTraceErrorLogLevelToCSTR();
      v72 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = v71;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 1500;
        *(_WORD *)&buf[28] = 2048;
        *(_QWORD *)&buf[30] = v19;
        _os_log_impl(&dword_1D8A54000, v72, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p setting up AudioInput but not using BasebandIO", buf, 0x26u);
      }
    }
    *(_DWORD *)v160 = 1;
    v73 = VCAudioUnit_AudioUnitSetProperty();
    v157 = v73;
    v74 = VRTraceGetErrorLogLevelForModule();
    if (v73)
    {
      if (v74 >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          AUIOSetupFormats_cold_6();
      }
      goto LABEL_139;
    }
    if (v74 >= 7)
    {
      v117 = VRTraceErrorLogLevelToCSTR();
      v118 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = v117;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 1509;
        *(_WORD *)&buf[28] = 2048;
        *(_QWORD *)&buf[30] = v19;
        _os_log_impl(&dword_1D8A54000, v118, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p kAUVoiceIOProperty_RequestMetadata kAudioUnitScope_Global succeeded", buf, 0x26u);
      }
    }
    v119 = VCAudioUnit_AudioUnitSetProperty();
    v157 = v119;
    v120 = VRTraceGetErrorLogLevelForModule();
    if (v119)
    {
      if (v120 < 3)
        goto LABEL_139;
      v121 = VRTraceErrorLogLevelToCSTR();
      v122 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        goto LABEL_139;
      *(_DWORD *)buf = 136316674;
      *(_QWORD *)&buf[4] = v121;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 1515;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = v159;
      *(_WORD *)&buf[34] = 1024;
      *(_DWORD *)&buf[36] = v157;
      *(_WORD *)&buf[40] = 1040;
      *(_DWORD *)&buf[42] = 4;
      *(_WORD *)&buf[46] = 2080;
      *(_QWORD *)&buf[48] = &v157;
      v149 = "AUIO [%s] %s:%d AudioUnitSetProperty failed to set property kAUVoiceIOProperty_OperationMode %d %d %.4s";
    }
    else
    {
      if (v120 >= 7)
      {
        v123 = VRTraceErrorLogLevelToCSTR();
        v124 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315906;
          *(_QWORD *)&buf[4] = v123;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 1518;
          *(_WORD *)&buf[28] = 2048;
          *(_QWORD *)&buf[30] = v19;
          _os_log_impl(&dword_1D8A54000, v124, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p kAUVoiceIOProperty_OperationMode kAudioUnitScope_Global succeeded", buf, 0x26u);
        }
      }
      v125 = VCAudioUnit_AudioUnitSetProperty();
      v157 = v125;
      if (v125 == -10876 || !v125 || v125 == 561406316)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v126 = VRTraceErrorLogLevelToCSTR();
          v127 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315906;
            *(_QWORD *)&buf[4] = v126;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 1526;
            *(_WORD *)&buf[28] = 2048;
            *(_QWORD *)&buf[30] = v19;
            _os_log_impl(&dword_1D8A54000, v127, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p kAUVoiceIOProperty_EnableSpatialChat kAudioUnitScope_Global succeeded", buf, 0x26u);
          }
        }
        AppBooleanValue = CFPreferencesGetAppBooleanValue(CFSTR("forceMute"), CFSTR("com.apple.VideoConference"), &keyExistsAndHasValidFormat);
        if (!keyExistsAndHasValidFormat || !AppBooleanValue)
          goto LABEL_79;
        *(_QWORD *)(v19 + 328) = 0x100000001;
        v58 = VCAudioUnit_AudioUnitSetProperty();
        v129 = VRTraceGetErrorLogLevelForModule();
        if (!v58)
        {
          if (v129 >= 7)
          {
            v150 = VRTraceErrorLogLevelToCSTR();
            v76 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315906;
              *(_QWORD *)&buf[4] = v150;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 1540;
              *(_WORD *)&buf[28] = 2048;
              *(_QWORD *)&buf[30] = v19;
              v77 = "AUIO [%s] %s:%d AUIO=%p kAUVoiceIOProperty_MuteOutput kAudioUnitScope_Global succeeded";
              goto LABEL_78;
            }
          }
LABEL_79:
          v78 = -[VCDefaults audioRecordingEnabled](+[VCDefaults sharedInstance](VCDefaults, "sharedInstance", v151), "audioRecordingEnabled");
          if (v154 && v78)
          {
            if (!*(_BYTE *)(v19 + 235))
            {
LABEL_92:
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v88 = VRTraceErrorLogLevelToCSTR();
                v89 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 136315906;
                  *(_QWORD *)&buf[4] = v88;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&buf[24] = 1614;
                  *(_WORD *)&buf[28] = 2048;
                  *(_QWORD *)&buf[30] = v19;
                  _os_log_impl(&dword_1D8A54000, v89, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p Trying to setup AUIO", buf, 0x26u);
                }
              }
              v90 = VCAudioUnit_AudioUnitInitialize();
              v157 = v90;
              v91 = VRTraceGetErrorLogLevelForModule();
              if (v90)
              {
                if (v91 >= 5)
                {
                  v92 = VRTraceErrorLogLevelToCSTR();
                  v93 = *MEMORY[0x1E0CF2758];
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                  {
                    v94 = v157;
                    v95 = FourccToCStr(v157);
                    *(_DWORD *)buf = 136316418;
                    *(_QWORD *)&buf[4] = v92;
                    *(_WORD *)&buf[12] = 2080;
                    *(_QWORD *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
                    *(_WORD *)&buf[22] = 1024;
                    *(_DWORD *)&buf[24] = 1617;
                    *(_WORD *)&buf[28] = 1024;
                    *(_DWORD *)&buf[30] = v94;
                    *(_WORD *)&buf[34] = 2080;
                    *(_QWORD *)&buf[36] = v95;
                    *(_WORD *)&buf[44] = 1024;
                    *(_DWORD *)&buf[46] = 0;
                    _os_log_impl(&dword_1D8A54000, v93, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AudioUnitInitialize failed. err=%d (%s) attempt %d", buf, 0x32u);
                  }
                }
                if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                {
                  v96 = VRTraceErrorLogLevelToCSTR();
                  v97 = *MEMORY[0x1E0CF2758];
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                    AUIOSetupFormats_cold_4(v96, &v157, v97);
                }
                goto LABEL_102;
              }
              if (v91 >= 7)
              {
                v98 = VRTraceErrorLogLevelToCSTR();
                v99 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 136315650;
                  *(_QWORD *)&buf[4] = v98;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&buf[24] = 1625;
                  _os_log_impl(&dword_1D8A54000, v99, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AudioUnitInitialize succeeded", buf, 0x1Cu);
                }
              }
              *(_BYTE *)(v19 + 232) = 1;
              if (!a5 || *(_BYTE *)(v19 + 576))
                goto LABEL_108;
              v102 = *(unsigned __int8 *)(v19 + 577);
              if (v102 == 2)
                goto LABEL_119;
              if (v102 == 1)
                goto LABEL_108;
              if (!*(_BYTE *)(v19 + 577))
              {
LABEL_119:
                if (!*(_BYTE *)(v19 + 235))
                  goto LABEL_163;
              }
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v103 = VRTraceErrorLogLevelToCSTR();
                v104 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 136316162;
                  *(_QWORD *)&buf[4] = v103;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&buf[24] = 1633;
                  *(_WORD *)&buf[28] = 2048;
                  *(_QWORD *)&buf[30] = v19;
                  *(_WORD *)&buf[38] = 2080;
                  *(_QWORD *)&buf[40] = a5 + 64;
                  _os_log_impl(&dword_1D8A54000, v104, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p VoiceIO Remote OS Version = %s", buf, 0x30u);
                }
              }
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v105 = VRTraceErrorLogLevelToCSTR();
                v106 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 136316162;
                  *(_QWORD *)&buf[4] = v105;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&buf[24] = 1634;
                  *(_WORD *)&buf[28] = 2048;
                  *(_QWORD *)&buf[30] = v19;
                  *(_WORD *)&buf[38] = 2080;
                  *(_QWORD *)&buf[40] = a5;
                  _os_log_impl(&dword_1D8A54000, v106, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p VoiceIO Remote HW Model = %s", buf, 0x30u);
                }
              }
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v107 = VRTraceErrorLogLevelToCSTR();
                v108 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                {
                  v109 = *(_DWORD *)(a5 + 128);
                  *(_DWORD *)buf = 136316162;
                  *(_QWORD *)&buf[4] = v107;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&buf[24] = 1635;
                  *(_WORD *)&buf[28] = 2048;
                  *(_QWORD *)&buf[30] = v19;
                  *(_WORD *)&buf[38] = 1024;
                  *(_DWORD *)&buf[40] = v109;
                  _os_log_impl(&dword_1D8A54000, v108, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p VoiceIO Remote AU Version = %u", buf, 0x2Cu);
                }
              }
              v110 = VCAudioUnit_AudioUnitSetProperty();
              v157 = v110;
              v111 = VRTraceGetErrorLogLevelForModule();
              if (v110)
              {
                if (v111 >= 5)
                {
                  v112 = VRTraceErrorLogLevelToCSTR();
                  v113 = *MEMORY[0x1E0CF2758];
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 136316162;
                    *(_QWORD *)&buf[4] = v112;
                    *(_WORD *)&buf[12] = 2080;
                    *(_QWORD *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
                    *(_WORD *)&buf[22] = 1024;
                    *(_DWORD *)&buf[24] = 1643;
                    *(_WORD *)&buf[28] = 1024;
                    *(_DWORD *)&buf[30] = v157;
                    *(_WORD *)&buf[34] = 1024;
                    *(_DWORD *)&buf[36] = v157;
                    v114 = "AUIO [%s] %s:%d AudioUnitSetProperty failed to set property FarEndVersionInfo with error %08x %d";
                    v115 = v113;
                    v116 = 40;
LABEL_159:
                    _os_log_impl(&dword_1D8A54000, v115, OS_LOG_TYPE_DEFAULT, v114, buf, v116);
                  }
                }
              }
              else if (v111 >= 7)
              {
                v130 = VRTraceErrorLogLevelToCSTR();
                v131 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 136315906;
                  *(_QWORD *)&buf[4] = v130;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&buf[24] = 1645;
                  *(_WORD *)&buf[28] = 2048;
                  *(_QWORD *)&buf[30] = v19;
                  v114 = "AUIO [%s] %s:%d AUIO=%p kAUVoiceIOProperty_FarEndVersionInfo kAudioUnitScope_Global succeeded";
                  v115 = v131;
                  v116 = 38;
                  goto LABEL_159;
                }
              }
LABEL_108:
              if (*(_BYTE *)(v19 + 235) && !*(_BYTE *)(v19 + 576) && *(_BYTE *)(v19 + 577) != 1)
              {
                *(_DWORD *)v160 = 4;
                Property = VCAudioUnit_AudioUnitGetProperty();
                v101 = VRTraceGetErrorLogLevelForModule();
                if (Property)
                {
                  if (v101 >= 3)
                  {
                    VRTraceErrorLogLevelToCSTR();
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                      AUIOSetupFormats_cold_3();
                  }
                  *(_DWORD *)(v19 + 448) = 128;
                }
                else if (v101 >= 7)
                {
                  v132 = VRTraceErrorLogLevelToCSTR();
                  v133 = *MEMORY[0x1E0CF2758];
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 136315906;
                    *(_QWORD *)&buf[4] = v132;
                    *(_WORD *)&buf[12] = 2080;
                    *(_QWORD *)&buf[14] = "_AUIOPostinitialization";
                    *(_WORD *)&buf[22] = 1024;
                    *(_DWORD *)&buf[24] = 1824;
                    *(_WORD *)&buf[28] = 2048;
                    *(_QWORD *)&buf[30] = v19;
                    _os_log_impl(&dword_1D8A54000, v133, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p kAUVoiceIOProperty_MaximumMetadataByteSize kAudioUnitScope_Output get succeeded", buf, 0x26u);
                  }
                }
              }
LABEL_163:

              *(_QWORD *)(v19 + 480) = 0;
              v134 = *(void **)(v19 + 584);
              if (v134 && objc_msgSend(v134, "length"))
              {
                v135 = 1;
              }
              else
              {
                if (!*(_BYTE *)(v19 + 578))
                  goto LABEL_203;
                v135 = 0;
              }
              *(_BYTE *)(v19 + 488) = VCDefaults_GetBoolValueForKey(CFSTR("forceCannedAudioVoiceActive"), v135);
              v136 = objc_alloc_init(VCCannedAudioInjectorConfig);
              if (v136)
              {
                v137 = v136;
                v138 = *(_OWORD *)(a3 + 16);
                *(_OWORD *)buf = *(_OWORD *)a3;
                *(_OWORD *)&buf[16] = v138;
                *(_QWORD *)&buf[32] = *(_QWORD *)(a3 + 32);
                -[VCCannedAudioInjectorConfig setAudioFormat:](v136, "setAudioFormat:", buf);
                if (*(_BYTE *)(v19 + 578))
                  v139 = 1;
                else
                  v139 = *(_BYTE *)(v19 + 488) != 0;
                -[VCCannedAudioInjectorConfig setForceVoiceActive:](v137, "setForceVoiceActive:", v139);
                if (*(_BYTE *)(v19 + 578))
                {
                  -[VCCannedAudioInjectorConfig setSineWaveFrequencyHz:](v137, "setSineWaveFrequencyHz:", 2000);
                  -[VCCannedAudioInjectorConfig setSineWaveAmplitude:](v137, "setSineWaveAmplitude:", 0.05);
                  -[VCCannedAudioInjectorConfig setStartHostTime:](v137, "setStartHostTime:", 0.0);
                  v140 = 1.0;
                }
                else
                {
                  v160[0] = 0;
                  v141 = CFPreferencesGetAppBooleanValue(CFSTR("cannedReplayFromBeginning"), CFSTR("com.apple.VideoConference"), v160);
                  -[VCCannedAudioInjectorConfig setPath:](v137, "setPath:", *(_QWORD *)(v19 + 584));
                  if (v141 || *(double *)(v19 + 600) < 0.0)
                  {
                    if (v141)
                      v142 = v160[0] == 0;
                    else
                      v142 = 1;
                    v143 = !v142;
                    -[VCCannedAudioInjectorConfig setFromBeginning:](v137, "setFromBeginning:", v143);
LABEL_184:
                    v144 = -[VCCannedAudioInjector initWithConfig:]([VCCannedAudioInjector alloc], "initWithConfig:", v137);
                    *(_QWORD *)(v19 + 480) = v144;
                    if (!v144 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
                    {
                      VRTraceErrorLogLevelToCSTR();
                      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                        AUIOSetupFormats_cold_2();
                    }
LABEL_185:

                    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
                    {
                      v145 = VRTraceErrorLogLevelToCSTR();
                      v146 = *MEMORY[0x1E0CF2758];
                      v17 = 0;
                      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                        goto LABEL_189;
                      *(_DWORD *)buf = 136315906;
                      *(_QWORD *)&buf[4] = v145;
                      *(_WORD *)&buf[12] = 2080;
                      *(_QWORD *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
                      *(_WORD *)&buf[22] = 1024;
                      *(_DWORD *)&buf[24] = 1655;
                      *(_WORD *)&buf[28] = 2048;
                      *(_QWORD *)&buf[30] = v19;
                      _os_log_impl(&dword_1D8A54000, v146, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d succeeded AUIO=%p", buf, 0x26u);
                    }
                    v17 = 0;
                    goto LABEL_189;
                  }
                  -[VCCannedAudioInjectorConfig setStartHostTime:](v137, "setStartHostTime:");
                  v140 = *(double *)(v19 + 592);
                }
                -[VCCannedAudioInjectorConfig setLoopLength:](v137, "setLoopLength:", v140);
                goto LABEL_184;
              }
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  AUIOSetupFormats_cold_1();
              }
LABEL_203:
              v137 = 0;
              goto LABEL_185;
            }
            *(_DWORD *)v160 = v154;
            v79 = VCAudioUnit_AudioUnitSetProperty();
            v157 = v79;
            v80 = VRTraceGetErrorLogLevelForModule();
            if (v79)
            {
              if (v80 >= 5)
              {
                v81 = VRTraceErrorLogLevelToCSTR();
                v82 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 136316162;
                  *(_QWORD *)&buf[4] = v81;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&buf[24] = 1596;
                  *(_WORD *)&buf[28] = 1024;
                  *(_DWORD *)&buf[30] = v157;
                  *(_WORD *)&buf[34] = 1024;
                  *(_DWORD *)&buf[36] = v157;
                  v83 = "AUIO [%s] %s:%d AudioUnitSetProperty failed to set property kAUVoiceIOProperty_EnableRecording w"
                        "ith error %08x %d";
                  v84 = v82;
                  v85 = 40;
LABEL_89:
                  _os_log_impl(&dword_1D8A54000, v84, OS_LOG_TYPE_DEFAULT, v83, buf, v85);
                }
              }
            }
            else if (v80 >= 5)
            {
              v86 = VRTraceErrorLogLevelToCSTR();
              v87 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315650;
                *(_QWORD *)&buf[4] = v86;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&buf[24] = 1598;
                v83 = "AUIO [%s] %s:%d allowAudioRecording and kAUVoiceIOProperty_EnableRecording set to YES";
                v84 = v87;
                v85 = 28;
                goto LABEL_89;
              }
            }
          }
          if (*(_BYTE *)(v19 + 235))
            _AUIOSetRemoteCodecProperties(v19, v153, a1);
          goto LABEL_92;
        }
        if (v129 >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            AUIOSetupFormats_cold_5();
        }
LABEL_140:
        v17 = v58 | 0xA01B0000;
        goto LABEL_189;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() < 3
        || (v148 = VRTraceErrorLogLevelToCSTR(),
            v122 = *MEMORY[0x1E0CF2758],
            !os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR)))
      {
LABEL_139:
        v58 = v157;
        goto LABEL_140;
      }
      *(_DWORD *)buf = 136316674;
      *(_QWORD *)&buf[4] = v148;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "_AUIOSetPropertiesAndInitialize";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 1523;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = v158;
      *(_WORD *)&buf[34] = 1024;
      *(_DWORD *)&buf[36] = v157;
      *(_WORD *)&buf[40] = 1040;
      *(_DWORD *)&buf[42] = 4;
      *(_WORD *)&buf[46] = 2080;
      *(_QWORD *)&buf[48] = &v157;
      v149 = "AUIO [%s] %s:%d AudioUnitSetProperty failed to set property kAUVoiceIOProperty_EnableSpatialChat %d %d %.4s";
    }
    _os_log_error_impl(&dword_1D8A54000, v122, OS_LOG_TYPE_ERROR, v149, buf, 0x38u);
    goto LABEL_139;
  }
  return 2149253122;
}

uint64_t AUIOReceiverIsReady()
{
  uint64_t v0;

  v0 = CheckInHandleDebug();
  if (!v0)
    return 2149253122;
  *(_BYTE *)(v0 + 234) = 1;
  PacketThread_ReceiverIsReady(*(_QWORD *)(v0 + 472));
  CheckOutHandleDebug();
  return 0;
}

void _AUIOHealthPrintCallback(tagHANDLE *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  double v11;
  double v12;
  double v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  NSObject *v21;
  __n128 v22;
  uint64_t v23;
  uint8_t buf[4];
  uint64_t v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  __int16 v34;
  int v35;
  __int16 v36;
  uint64_t v37;
  __int16 v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  __int16 v42;
  uint64_t v43;
  __int16 v44;
  uint64_t v45;
  __int16 v46;
  double v47;
  __int16 v48;
  double v49;
  __int16 v50;
  double v51;
  __int16 v52;
  int v53;
  __int16 v54;
  uint64_t v55;
  __int16 v56;
  int v57;
  __int16 v58;
  int v59;
  __int16 v60;
  int v61;
  __int16 v62;
  uint64_t v63;
  __int16 v64;
  uint64_t v65;
  __int16 v66;
  uint64_t v67;
  __int16 v68;
  uint64_t v69;
  __int16 v70;
  uint64_t v71;
  __int16 v72;
  int v73;
  uint64_t v74;

  v74 = *MEMORY[0x1E0C80C00];
  v1 = CheckInHandleDebug();
  if (v1)
  {
    v2 = v1;
    v22 = 0uLL;
    v23 = 0;
    if (*(_BYTE *)(v1 + 464))
    {
      pthread_mutex_lock((pthread_mutex_t *)(v1 + 264));
      PacketThread_Statistics(*(__n128 **)(v2 + 472), &v22);
      pthread_mutex_unlock((pthread_mutex_t *)(v2 + 264));
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      v3 = VRTraceErrorLogLevelToCSTR();
      v4 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v5 = *(unsigned __int8 *)(v2 + 234);
        v6 = *(_QWORD *)(v2 + 496);
        v7 = *(_QWORD *)(v2 + 504);
        v8 = *(_QWORD *)(v2 + 512);
        v9 = *(_QWORD *)(v2 + 552);
        v10 = *(_QWORD *)(v2 + 560);
        v11 = *(float *)(v2 + 348);
        v12 = *(float *)(v2 + 352);
        v13 = *(float *)(v2 + 372);
        v14 = *(_DWORD *)(v2 + 416);
        v15 = *(_QWORD *)(v2 + 424);
        v16 = *(_DWORD *)(v2 + 532);
        v17 = *(_DWORD *)(v2 + 536);
        v18 = *(_DWORD *)(v2 + 544);
        v19 = *(unsigned __int8 *)(v2 + 464);
        *(_DWORD *)buf = 136321282;
        v25 = v3;
        v26 = 2080;
        v27 = "_AUIOHealthPrintCallback";
        v28 = 1024;
        v29 = 1925;
        v30 = 2048;
        v31 = v2;
        v32 = 2048;
        v33 = v6;
        v34 = 1024;
        v35 = v5;
        v36 = 2048;
        v37 = v7;
        v38 = 2048;
        v39 = v22.n128_u32[0];
        v40 = 2048;
        v41 = v8;
        v42 = 2048;
        v43 = v9;
        v44 = 2048;
        v45 = v10;
        v46 = 2048;
        v47 = v11;
        v48 = 2048;
        v49 = v12;
        v50 = 2048;
        v51 = v13;
        v52 = 1024;
        v53 = v14;
        v54 = 2048;
        v55 = v15;
        v56 = 1024;
        v57 = v16;
        v58 = 1024;
        v59 = v17;
        v60 = 1024;
        v61 = v18;
        v62 = 2048;
        v63 = v22.n128_u32[1];
        v64 = 2048;
        v65 = v23;
        v66 = 2048;
        v67 = v22.n128_u32[2];
        v68 = 2048;
        v69 = v22.n128_u32[3];
        v70 = 2048;
        v71 = HIDWORD(v23);
        v72 = 1024;
        v73 = v19;
        _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d @=@ Health: AudioIO (%p) micProcsCalled=%ld, ready=%d, micProcsReturned=%ld, packetsSent=%ld, voiceActivityCount=%ld, speakerProcsCalled=%ld, speakerProcsReturned=%ld, averageInputPower=%f, inputPowerMovingAverage=%f, averageOutputPower=%f, latestMicTimeStamp=%u, latestMicHostTime=%f, micShenanigans=%d, speakerShenanigans=%d, swapCount=%d packetsStored=%ld packetsDropped=[%ld, %ld, %ld, %ld] internalThreading=%d", buf, 0xE0u);
      }
    }
    CheckOutHandleDebug();
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v20 = VRTraceErrorLogLevelToCSTR();
    v21 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      v25 = v20;
      v26 = 2080;
      v27 = "_AUIOHealthPrintCallback";
      v28 = 1024;
      v29 = 1893;
      _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d IO Proc health monitor called with invalid HANDLE", buf, 0x1Cu);
    }
  }
}

uint64_t AUIOStart(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  pthread_mutex_t *v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  NSObject *v11;
  NSObject *global_queue;
  dispatch_source_t v13;
  NSObject *v14;
  dispatch_time_t v15;
  uint64_t v17;
  NSObject *v18;
  int v19;
  uint64_t v20;
  NSObject *v21;
  int *v22;
  _QWORD handler[5];
  uint8_t buf[4];
  uint64_t v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  _BYTE v31[14];
  __int16 v32;
  int v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v2 = 2149253122;
  v3 = CheckInHandleDebug();
  if (v3)
  {
    v4 = v3;
    v5 = (pthread_mutex_t *)(v3 + 264);
    pthread_mutex_lock((pthread_mutex_t *)(v3 + 264));
    if (*(_BYTE *)(v4 + 232))
    {
      if (!*(_BYTE *)(v4 + 233))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v6 = VRTraceErrorLogLevelToCSTR();
          v7 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315906;
            v25 = v6;
            v26 = 2080;
            v27 = "AUIOStart";
            v28 = 1024;
            v29 = 1944;
            v30 = 2048;
            *(_QWORD *)v31 = v4;
            _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p AUIO Starting...", buf, 0x26u);
          }
        }
        *(_DWORD *)(v4 + 416) = 0;
        *(_QWORD *)(v4 + 424) = 0;
        *(_QWORD *)(v4 + 520) = 0x7FF8000000000000;
        *(_BYTE *)(v4 + 528) = 0;
        *(_QWORD *)(v4 + 456) = 0x7FEFFFFFFFFFFFFFLL;
        v8 = _AUIOStartPacketThread(v4);
        if ((v8 & 0x80000000) != 0)
        {
          v2 = v8;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            v17 = VRTraceErrorLogLevelToCSTR();
            v18 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136316418;
              v25 = v17;
              v26 = 2080;
              v27 = "AUIOStart";
              v28 = 1024;
              v29 = 1954;
              v30 = 1024;
              *(_DWORD *)v31 = 1954;
              *(_WORD *)&v31[4] = 2048;
              *(_QWORD *)&v31[6] = v4;
              v32 = 1024;
              v33 = v2;
              _os_log_error_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_ERROR, "AUIO [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/AUIO/AUIO.mm:%d: AUIO=%p Failed to start the packet thread result=%x", buf, 0x32u);
            }
          }
          goto LABEL_15;
        }
        v9 = VCAudioUnit_AudioOutputUnitStart();
        if (v9)
        {
          v19 = v9;
          v2 = v9 | 0xA01B0000;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            v20 = VRTraceErrorLogLevelToCSTR();
            v21 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136316418;
              v25 = v20;
              v26 = 2080;
              v27 = "AUIOStart";
              v28 = 1024;
              v29 = 1957;
              v30 = 1024;
              *(_DWORD *)v31 = 1957;
              *(_WORD *)&v31[4] = 2048;
              *(_QWORD *)&v31[6] = v4;
              v32 = 1024;
              v33 = v19;
              _os_log_error_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_ERROR, "AUIO [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/AUIO/AUIO.mm:%d: AUIO=%p ERROR AudioOutputUnitStart returned %d", buf, 0x32u);
            }
          }
          v22 = *(int **)(v4 + 472);
          if (v22)
          {
            PacketThread_Destroy(v22);
            *(_QWORD *)(v4 + 472) = 0;
          }
          goto LABEL_15;
        }
        *(_BYTE *)(v4 + 233) = 1;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v10 = VRTraceErrorLogLevelToCSTR();
          v11 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136316162;
            v25 = v10;
            v26 = 2080;
            v27 = "AUIOStart";
            v28 = 1024;
            v29 = 1960;
            v30 = 1024;
            *(_DWORD *)v31 = 1960;
            *(_WORD *)&v31[4] = 2048;
            *(_QWORD *)&v31[6] = v4;
            _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/AUIO/AUIO.mm:%d: AUIO=%p AudioOutputUnitStart() completed", buf, 0x2Cu);
          }
        }
        global_queue = dispatch_get_global_queue(0, 0);
        v13 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, global_queue);
        *(_QWORD *)(v4 + 568) = v13;
        if (v13)
        {
          v14 = v13;
          v15 = dispatch_walltime(0, 0);
          dispatch_source_set_timer(v14, v15, 0x12A05F200uLL, 0x23C34600uLL);
          handler[0] = MEMORY[0x1E0C809B0];
          handler[1] = 3221225472;
          handler[2] = __AUIOStart_block_invoke;
          handler[3] = &__block_descriptor_40_e5_v8__0l;
          handler[4] = a1;
          dispatch_source_set_event_handler(*(dispatch_source_t *)(v4 + 568), handler);
          dispatch_source_set_cancel_handler(*(dispatch_source_t *)(v4 + 568), handler);
          dispatch_resume(*(dispatch_object_t *)(v4 + 568));
        }
      }
      v2 = 0;
    }
    else
    {
      v2 = 2149253176;
    }
LABEL_15:
    pthread_mutex_unlock(v5);
    CheckOutHandleDebug();
  }
  return v2;
}

uint64_t AUIOStop()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  pthread_mutex_t *v3;
  int ErrorLogLevelForModule;
  os_log_t *v5;
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  int *v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  NSObject *v14;
  int v16;
  uint64_t v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v0 = 2149253122;
  v1 = CheckInHandleDebug();
  if (v1)
  {
    v2 = v1;
    v3 = (pthread_mutex_t *)(v1 + 264);
    pthread_mutex_lock((pthread_mutex_t *)(v1 + 264));
    ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    v5 = (os_log_t *)MEMORY[0x1E0CF2758];
    if (ErrorLogLevelForModule >= 7)
    {
      v6 = VRTraceErrorLogLevelToCSTR();
      v7 = *v5;
      if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
      {
        v16 = 136315906;
        v17 = v6;
        v18 = 2080;
        v19 = "AUIOStop";
        v20 = 1024;
        v21 = 1998;
        v22 = 2048;
        v23 = v2;
        _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p Stopping the audio unit.", (uint8_t *)&v16, 0x26u);
      }
    }
    if (*(_BYTE *)(v2 + 232))
    {
      if (*(_QWORD *)(v2 + 48) && *(_BYTE *)(v2 + 233))
      {
        VCAudioUnit_AudioOutputUnitStop();
        *(_BYTE *)(v2 + 233) = 0;
      }
      v8 = *(NSObject **)(v2 + 568);
      if (v8)
      {
        dispatch_source_cancel(v8);
        v9 = *(NSObject **)(v2 + 568);
        if (v9)
        {
          dispatch_release(v9);
          *(_QWORD *)(v2 + 568) = 0;
        }
      }
      v10 = *(int **)(v2 + 472);
      if (v10)
      {
        PacketThread_Destroy(v10);
        v0 = 0;
        *(_QWORD *)(v2 + 472) = 0;
      }
      else
      {
        v0 = 0;
      }
    }
    else
    {
      v0 = 2149253176;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() > 6)
    {
      v11 = VRTraceErrorLogLevelToCSTR();
      v12 = *v5;
      if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
      {
        v16 = 136315906;
        v17 = v11;
        v18 = 2080;
        v19 = "AUIOStop";
        v20 = 1024;
        v21 = 2017;
        v22 = 2048;
        v23 = v2;
        _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p Stopped the audio unit.", (uint8_t *)&v16, 0x26u);
      }
    }
    pthread_mutex_unlock(v3);
    CheckOutHandleDebug();
    if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      v13 = VRTraceErrorLogLevelToCSTR();
      v14 = *v5;
      if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
      {
        v16 = 136315650;
        v17 = v13;
        v18 = 2080;
        v19 = "AUIOStop";
        v20 = 1024;
        v21 = 2021;
        _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO Stop!", (uint8_t *)&v16, 0x1Cu);
      }
    }
  }
  return v0;
}

uint64_t AUIOSetInputMeterEnabled(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  pthread_mutex_t *v5;
  PowerMeter *v6;
  double v7;
  uint64_t v9;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149253122;
  v4 = v3;
  v5 = (pthread_mutex_t *)(v3 + 264);
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 264));
  if (a2)
  {
    if (!*(_DWORD *)(v4 + 344))
    {
      *(_DWORD *)(v4 + 344) = a2;
      v6 = (PowerMeter *)operator new();
      PowerMeter::PowerMeter(v6);
      *(_QWORD *)(v4 + 336) = v6;
      v7 = *(double *)(v4 + 96);
      if (v7 == 0.0)
        v7 = 8000.0;
      PowerMeter::SetSampleRate(v6, v7);
    }
  }
  else
  {
    v9 = *(_QWORD *)(v4 + 336);
    if (v9)
    {
      *(_DWORD *)(v4 + 344) = 0;
      MEMORY[0x1DF087DC8](v9, 0x1000C407AA769CALL);
      *(_QWORD *)(v4 + 336) = 0;
    }
  }
  pthread_mutex_unlock(v5);
  CheckOutHandleDebug();
  return 0;
}

void sub_1D8F018EC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1DF087DC8](v1, 0x1000C407AA769CALL);
  _Unwind_Resume(a1);
}

uint64_t AUIOSetOutputMeterEnabled(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  pthread_mutex_t *v5;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149253122;
  v4 = v3;
  v5 = (pthread_mutex_t *)(v3 + 264);
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 264));
  *(_DWORD *)(v4 + 368) = a2;
  pthread_mutex_unlock(v5);
  CheckOutHandleDebug();
  return 0;
}

uint64_t AUIOSetMute(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  pthread_mutex_t *v5;
  uint64_t v6;
  int v8;
  int v9;
  int ErrorLogLevelForModule;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  NSObject *v14;
  int v15;
  uint8_t buf[4];
  uint64_t v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149253122;
  v4 = v3;
  v5 = (pthread_mutex_t *)(v3 + 264);
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 264));
  if (*(_DWORD *)(v4 + 328) || *(_BYTE *)(v4 + 576))
    goto LABEL_4;
  v8 = *(unsigned __int8 *)(v4 + 577);
  if (v8 == 2)
    goto LABEL_11;
  if (v8 == 1)
    goto LABEL_4;
  if (!*(_BYTE *)(v4 + 577))
  {
LABEL_11:
    if (!*(_BYTE *)(v4 + 235))
      goto LABEL_4;
  }
  *(_DWORD *)(v4 + 332) = a2;
  v15 = a2;
  v9 = VCAudioUnit_AudioUnitSetProperty();
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (v9)
  {
    if (ErrorLogLevelForModule >= 3)
    {
      v11 = VRTraceErrorLogLevelToCSTR();
      v12 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136316418;
        v17 = v11;
        v18 = 2080;
        v19 = "AUIOSetMute";
        v20 = 1024;
        v21 = 2119;
        v22 = 1024;
        v23 = v15;
        v24 = 1024;
        v25 = v9;
        v26 = 1024;
        v27 = v9;
        _os_log_error_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_ERROR, "AUIO [%s] %s:%d AudioUnitSetProperty failed to set property kAUVoiceIOProperty_MuteOutput to %u with error %08x %d", buf, 0x2Eu);
      }
    }
    v6 = v9 | 0xA01B0000;
    goto LABEL_5;
  }
  if (ErrorLogLevelForModule >= 5)
  {
    v13 = VRTraceErrorLogLevelToCSTR();
    v14 = *MEMORY[0x1E0CF2758];
    v6 = 0;
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      goto LABEL_5;
    *(_DWORD *)buf = 136315906;
    v17 = v13;
    v18 = 2080;
    v19 = "AUIOSetMute";
    v20 = 1024;
    v21 = 2122;
    v22 = 1024;
    v23 = v15;
    _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d Changed mute to %u", buf, 0x22u);
  }
LABEL_4:
  v6 = 0;
LABEL_5:
  pthread_mutex_unlock(v5);
  CheckOutHandleDebug();
  return v6;
}

uint64_t AUIOSetVoiceMixingMedia(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  pthread_mutex_t *v5;
  uint64_t v6;
  int v8;
  int ErrorLogLevelForModule;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  NSObject *v13;
  int v14;
  uint8_t buf[4];
  uint64_t v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  __int16 v23;
  int v24;
  __int16 v25;
  int v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149253122;
  v4 = v3;
  v5 = (pthread_mutex_t *)(v3 + 264);
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 264));
  if (!*(_BYTE *)(v4 + 576) && *(_BYTE *)(v4 + 577) != 1)
  {
    v14 = a2;
    v8 = VCAudioUnit_AudioUnitSetProperty();
    ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    if (v8)
    {
      if (ErrorLogLevelForModule >= 3)
      {
        v10 = VRTraceErrorLogLevelToCSTR();
        v11 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136316418;
          v16 = v10;
          v17 = 2080;
          v18 = "AUIOSetVoiceMixingMedia";
          v19 = 1024;
          v20 = 2152;
          v21 = 1024;
          v22 = v14;
          v23 = 1024;
          v24 = v8;
          v25 = 1024;
          v26 = v8;
          _os_log_error_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_ERROR, "AUIO [%s] %s:%d AudioUnitSetProperty failed to set property kAUVoiceIOProperty_EnableMediaChat to %u with error %08x %d", buf, 0x2Eu);
        }
      }
      v6 = v8 | 0xA01B0000;
      goto LABEL_5;
    }
    if (ErrorLogLevelForModule >= 7)
    {
      v12 = VRTraceErrorLogLevelToCSTR();
      v13 = *MEMORY[0x1E0CF2758];
      v6 = 0;
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        goto LABEL_5;
      *(_DWORD *)buf = 136315906;
      v16 = v12;
      v17 = 2080;
      v18 = "AUIOSetVoiceMixingMedia";
      v19 = 1024;
      v20 = 2155;
      v21 = 1024;
      v22 = v14;
      _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d Changed kAUVoiceIOProperty_EnableMediaChat to %u", buf, 0x22u);
    }
  }
  v6 = 0;
LABEL_5:
  pthread_mutex_unlock(v5);
  CheckOutHandleDebug();
  return v6;
}

uint64_t AUIOSetMediaPlaybackOnExternalDevice(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  pthread_mutex_t *v5;
  uint64_t v6;
  int v8;
  int ErrorLogLevelForModule;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  NSObject *v13;
  int v14;
  uint8_t buf[4];
  uint64_t v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  __int16 v23;
  int v24;
  __int16 v25;
  char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149253122;
  v4 = v3;
  v5 = (pthread_mutex_t *)(v3 + 264);
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 264));
  if (!*(_BYTE *)(v4 + 576) && *(_BYTE *)(v4 + 577) != 1)
  {
    v14 = a2;
    v8 = VCAudioUnit_AudioUnitSetProperty();
    ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    if (v8)
    {
      if (ErrorLogLevelForModule >= 3)
      {
        v10 = VRTraceErrorLogLevelToCSTR();
        v11 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136316418;
          v16 = v10;
          v17 = 2080;
          v18 = "AUIOSetMediaPlaybackOnExternalDevice";
          v19 = 1024;
          v20 = 2179;
          v21 = 1024;
          v22 = v14;
          v23 = 1024;
          v24 = v8;
          v25 = 2080;
          v26 = FourccToCStr(v8);
          _os_log_error_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_ERROR, "AUIO [%s] %s:%d AudioUnitSetProperty failed to set property kAUVoiceIOProperty_MediaPlaybackOnExternalDevice to value=%u with error=%08x (fourcc=%s)", buf, 0x32u);
        }
      }
      v6 = v8 | 0xA01B0000;
      goto LABEL_5;
    }
    if (ErrorLogLevelForModule >= 7)
    {
      v12 = VRTraceErrorLogLevelToCSTR();
      v13 = *MEMORY[0x1E0CF2758];
      v6 = 0;
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        goto LABEL_5;
      *(_DWORD *)buf = 136315906;
      v16 = v12;
      v17 = 2080;
      v18 = "AUIOSetMediaPlaybackOnExternalDevice";
      v19 = 1024;
      v20 = 2177;
      v21 = 1024;
      v22 = v14;
      _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d Changed kAUVoiceIOProperty_MediaPlaybackOnExternalDevice to value=%u", buf, 0x22u);
    }
  }
  v6 = 0;
LABEL_5:
  pthread_mutex_unlock(v5);
  CheckOutHandleDebug();
  return v6;
}

uint64_t AUIOGetAUNumber(UInt32 *a1)
{
  uint64_t v1;
  OpaqueAudioComponent *Next;
  AudioComponentDescription v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v1 = 2149253121;
  if (a1)
  {
    *(_OWORD *)&v5.componentType = xmmword_1D910FD20;
    v5.componentFlagsMask = 0;
    Next = AudioComponentFindNext(0, &v5);
    if (Next)
      return AudioComponentGetVersion(Next, a1);
    else
      return 2149253142;
  }
  return v1;
}

uint64_t AUIOSetRemoteCodecInfo(double a1, uint64_t a2, unsigned int a3)
{
  uint64_t v5;
  uint64_t v6;
  pthread_mutex_t *v7;

  v5 = CheckInHandleDebug();
  if (!v5)
    return 2149253122;
  v6 = v5;
  v7 = (pthread_mutex_t *)(v5 + 264);
  pthread_mutex_lock((pthread_mutex_t *)(v5 + 264));
  _AUIOSetRemoteCodecProperties(v6, a3, a1);
  pthread_mutex_unlock(v7);
  CheckOutHandleDebug();
  return 0;
}

void _AUIOSetRemoteCodecProperties(uint64_t a1, unsigned int a2, double a3)
{
  unsigned int v3;
  int ErrorLogLevelForModule;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  unsigned int v9;
  int v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  NSObject *v14;
  uint8_t buf[4];
  uint64_t v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  unsigned int v24;
  __int16 v25;
  unsigned int v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 576) && *(_BYTE *)(a1 + 577) != 1)
  {
    v3 = VCAudioUnit_AudioUnitSetProperty();
    ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    if (v3)
    {
      if (ErrorLogLevelForModule >= 3)
      {
        v5 = VRTraceErrorLogLevelToCSTR();
        v6 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136316162;
          v18 = v5;
          v19 = 2080;
          v20 = "_AUIOSetRemoteCodecProperties";
          v21 = 1024;
          v22 = 2231;
          v23 = 1024;
          v24 = v3;
          v25 = 1024;
          v26 = a2;
          _os_log_error_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_ERROR, "AUIO [%s] %s:%d kAUVoiceIOProperty_PrimaryCodecType failed(%d) codecType(%d)", buf, 0x28u);
        }
      }
    }
    else if (ErrorLogLevelForModule >= 7)
    {
      v7 = VRTraceErrorLogLevelToCSTR();
      v8 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        v18 = v7;
        v19 = 2080;
        v20 = "_AUIOSetRemoteCodecProperties";
        v21 = 1024;
        v22 = 2234;
        v23 = 1024;
        v24 = a2;
        _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d kAUVoiceIOProperty_PrimaryCodecType succeeded codecType(%d)", buf, 0x22u);
      }
    }
    v9 = VCAudioUnit_AudioUnitSetProperty();
    v10 = VRTraceGetErrorLogLevelForModule();
    if (v9)
    {
      if (v10 >= 3)
      {
        v11 = VRTraceErrorLogLevelToCSTR();
        v12 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136316162;
          v18 = v11;
          v19 = 2080;
          v20 = "_AUIOSetRemoteCodecProperties";
          v21 = 1024;
          v22 = 2239;
          v23 = 1024;
          v24 = v9;
          v25 = 1024;
          v26 = a3;
          _os_log_error_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_ERROR, "AUIO [%s] %s:%d kAUVoiceIOProperty_PrimaryCodecSampleRate failed(%d) sampleRate(%d)", buf, 0x28u);
        }
      }
    }
    else if (v10 >= 7)
    {
      v13 = VRTraceErrorLogLevelToCSTR();
      v14 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        v18 = v13;
        v19 = 2080;
        v20 = "_AUIOSetRemoteCodecProperties";
        v21 = 1024;
        v22 = 2242;
        v23 = 1024;
        v24 = a3;
        _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d kAUVoiceIOProperty_PrimaryCodecSampleRate succeded: sampleRate(%d)", buf, 0x22u);
      }
    }
  }
}

uint64_t AUIOSetSpatialMetadata()
{
  uint64_t v0;
  pthread_mutex_t *v1;
  int v2;
  uint64_t v3;

  v0 = CheckInHandleDebug();
  if (!v0)
    return 2149253122;
  v1 = (pthread_mutex_t *)(v0 + 264);
  pthread_mutex_lock((pthread_mutex_t *)(v0 + 264));
  v2 = VCAudioUnit_AudioUnitSetProperty();
  if (v2)
  {
    v3 = v2 | 0xA01B0000;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        AUIOSetSpatialMetadata_cold_1();
    }
  }
  else
  {
    v3 = 0;
  }
  pthread_mutex_unlock(v1);
  CheckOutHandleDebug();
  return v3;
}

uint64_t AUIORegisterMutedTalkerNotificationEventListener(uint64_t a1, uint64_t a2)
{
  char v3;
  int ErrorLogLevelForModule;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  pthread_mutex_t *v8;
  int v9;
  uint64_t v10;
  NSObject *v11;
  const char *v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint8_t buf[4];
  uint64_t v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v3 = _os_feature_enabled_impl();
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if ((v3 & 1) == 0)
  {
    if (ErrorLogLevelForModule >= 7)
    {
      v13 = VRTraceErrorLogLevelToCSTR();
      v14 = *MEMORY[0x1E0CF2758];
      v15 = 0;
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        return v15;
      *(_DWORD *)buf = 136315650;
      v20 = v13;
      v21 = 2080;
      v22 = "AUIORegisterMutedTalkerNotificationEventListener";
      v23 = 1024;
      v24 = 2275;
      _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d MutedTalker feature disabled", buf, 0x1Cu);
    }
    return 0;
  }
  if (ErrorLogLevelForModule >= 6)
  {
    v5 = VRTraceErrorLogLevelToCSTR();
    v6 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      v20 = v5;
      v21 = 2080;
      v22 = "AUIORegisterMutedTalkerNotificationEventListener";
      v23 = 1024;
      v24 = 2278;
      _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d MutedTalker feature enabled", buf, 0x1Cu);
    }
  }
  v7 = CheckInHandleDebug();
  if (!v7)
    return 2149253122;
  v8 = (pthread_mutex_t *)(v7 + 264);
  pthread_mutex_lock((pthread_mutex_t *)(v7 + 264));
  v9 = VRTraceGetErrorLogLevelForModule();
  if (a2)
  {
    if (v9 < 7)
      goto LABEL_19;
    v10 = VRTraceErrorLogLevelToCSTR();
    v11 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      goto LABEL_19;
    *(_DWORD *)buf = 136315650;
    v20 = v10;
    v21 = 2080;
    v22 = "AUIORegisterMutedTalkerNotificationEventListener";
    v23 = 1024;
    v24 = 2287;
    v12 = "AUIO [%s] %s:%d Registering mutedTalker feature";
  }
  else
  {
    if (v9 < 7)
      goto LABEL_19;
    v16 = VRTraceErrorLogLevelToCSTR();
    v11 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      goto LABEL_19;
    *(_DWORD *)buf = 136315650;
    v20 = v16;
    v21 = 2080;
    v22 = "AUIORegisterMutedTalkerNotificationEventListener";
    v23 = 1024;
    v24 = 2289;
    v12 = "AUIO [%s] %s:%d Unregistering mutedTalker feature";
  }
  _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, v12, buf, 0x1Cu);
LABEL_19:
  v17 = VCAudioUnit_AudioUnitSetProperty();
  if (v17)
  {
    v15 = v17 | 0xA01B0000;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        AUIORegisterMutedTalkerNotificationEventListener_cold_1();
    }
  }
  else
  {
    v15 = 0;
  }
  pthread_mutex_unlock(v8);
  CheckOutHandleDebug();
  return v15;
}

uint64_t AUIOSetDynamicDuckerVolume()
{
  uint64_t v0;
  pthread_mutex_t *v1;
  int v2;
  uint64_t v3;

  v0 = CheckInHandleDebug();
  if (!v0)
    return 2149253122;
  v1 = (pthread_mutex_t *)(v0 + 264);
  pthread_mutex_lock((pthread_mutex_t *)(v0 + 264));
  v2 = VCAudioUnit_AudioUnitSetParameter();
  if (v2)
  {
    v3 = v2 | 0xA01B0000;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        AUIOSetDynamicDuckerVolume_cold_1();
    }
  }
  else
  {
    v3 = 0;
  }
  pthread_mutex_unlock(v1);
  CheckOutHandleDebug();
  return v3;
}

uint64_t LogProfileTimeOverLimit(double a1, double a2, const char *a3, ...)
{
  uint64_t result;
  double v7;
  __int128 v8;
  uint64_t v9;
  NSObject *v10;
  uint8_t buf[4];
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  char *v18;
  __int16 v19;
  double v20;
  char __str[16];
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;
  va_list va;

  va_start(va, a3);
  v37 = *MEMORY[0x1E0C80C00];
  result = VRTraceIsInternalOSInstalled();
  if ((_DWORD)result)
  {
    v7 = micro() - a1;
    if (v7 <= a2)
    {
      return 0;
    }
    else
    {
      *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v35 = v8;
      v36 = v8;
      v33 = v8;
      v34 = v8;
      v31 = v8;
      v32 = v8;
      v29 = v8;
      v30 = v8;
      v27 = v8;
      v28 = v8;
      v26 = v8;
      v24 = v8;
      v25 = v8;
      v22 = v8;
      v23 = v8;
      *(_OWORD *)__str = v8;
      vsnprintf(__str, 0x100uLL, a3, va);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v9 = VRTraceErrorLogLevelToCSTR();
        v10 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316162;
          v12 = v9;
          v13 = 2080;
          v14 = "_LogProfileTimeLimitHelper";
          v15 = 1024;
          v16 = 36;
          v17 = 2080;
          v18 = __str;
          v19 = 2048;
          v20 = v7;
          _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d %s: Took a long time %fs", buf, 0x30u);
        }
      }
      return 1;
    }
  }
  return result;
}

void _AUIOSendMicSamples(uint64_t a1, uint64_t a2)
{
  int Timestamp;
  int SampleCount;
  uint64_t SampleFormat;
  const void *v7;
  int v8;
  int v9;
  uint64_t v10;
  size_t v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  NSObject *v15;
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  NSObject *v23;
  signed int v24;
  int v25;
  int v26;
  double HostTime;
  double v28;
  int v29;
  uint64_t v30;
  uint64_t AudioBufferList;
  uint64_t v32;
  signed int v33;
  uint64_t v34;
  uint64_t v35;
  uint8_t buf[4];
  uint64_t v37;
  __int16 v38;
  const char *v39;
  __int16 v40;
  int v41;
  __int16 v42;
  uint64_t v43;
  __int16 v44;
  uint64_t v45;
  __int16 v46;
  _BYTE v47[10];
  uint64_t v48;
  int v49;
  __int16 v50;
  int v51;
  __int16 v52;
  unsigned int v53;
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  Timestamp = VCAudioBufferList_GetTimestamp(a2);
  SampleCount = VCAudioBufferList_GetSampleCount(a2);
  SampleFormat = VCAudioBufferList_GetSampleFormat(a2);
  v7 = *(const void **)(VCAudioBufferList_GetAudioBufferList(a2) + 16);
  v8 = *(_DWORD *)(a1 + 412);
  v9 = Timestamp - v8;
  if (v7 && (v10 = *(_QWORD *)(a1 + 400)) != 0)
  {
    v11 = (*(_DWORD *)(SampleFormat + 24) * SampleCount);
    v12 = *(_DWORD *)(a1 + 160) * v8;
    v13 = *(_DWORD *)(a1 + 408);
    v14 = v12 + v11 - v13;
    if (v12 + v11 > v13)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v35 = VRTraceErrorLogLevelToCSTR();
        v15 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v16 = *(_QWORD *)(a1 + 400);
          v17 = *(_DWORD *)(a1 + 256);
          v18 = *(_DWORD *)(a1 + 408);
          v19 = *(_DWORD *)(a1 + 412);
          *(_DWORD *)buf = 136317698;
          v37 = v35;
          v38 = 2080;
          v39 = "_AUIOBufferMicSamples";
          v40 = 1024;
          v41 = 288;
          v42 = 2048;
          v43 = a1;
          v44 = 2048;
          v45 = v16;
          v46 = 1024;
          *(_DWORD *)v47 = v17;
          *(_WORD *)&v47[4] = 1024;
          *(_DWORD *)&v47[6] = v18;
          LOWORD(v48) = 1024;
          *(_DWORD *)((char *)&v48 + 2) = v19;
          HIWORD(v48) = 1024;
          v49 = SampleCount;
          v50 = 1024;
          v51 = v11;
          v52 = 1024;
          v53 = v14;
          _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d AUIO=%p bufferedMicSamples=%p is too full, dropping older samples to fit this. maxSampleSize=%d maxByteSize=%u curSampleCount=%u appendSampleCount=%u appendBytes=%u sizeNeeded=%u", buf, 0x54u);
        }
      }
      memmove(*(void **)(a1 + 400), (const void *)(*(_QWORD *)(a1 + 400) + v14), *(_DWORD *)(a1 + 408) - v14);
      v12 -= v14;
      v20 = v14 / *(_DWORD *)(SampleFormat + 24);
      *(_DWORD *)(a1 + 412) -= v20;
      v9 += v20;
      v10 = *(_QWORD *)(a1 + 400);
    }
    memcpy((void *)(v10 + v12), v7, v11);
    v21 = *(_DWORD *)(a1 + 412) + SampleCount;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v22 = VRTraceErrorLogLevelToCSTR();
      v23 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v34 = *(_QWORD *)(a1 + 400);
        *(_DWORD *)buf = 136316674;
        v37 = v22;
        v38 = 2080;
        v39 = "_AUIOBufferMicSamples";
        v40 = 1024;
        v41 = 268;
        v42 = 2048;
        v43 = a1;
        v44 = 2048;
        v45 = a2;
        v46 = 2048;
        *(_QWORD *)v47 = v7;
        *(_WORD *)&v47[8] = 2048;
        v48 = v34;
        _os_log_error_impl(&dword_1D8A54000, v23, OS_LOG_TYPE_ERROR, "AUIO [%s] %s:%d AUIO=%p sampleBuffer=%p buffer=%p bufferedMicSamples=%p", buf, 0x44u);
      }
    }
    v21 = 0;
  }
  *(_DWORD *)(a1 + 412) = v21;
  v24 = *(_DWORD *)(a1 + 176);
  v25 = *(_DWORD *)(a1 + 160);
  v26 = *(_DWORD *)(a1 + 164);
  HostTime = VCAudioBufferList_GetHostTime(a2);
  if (*(_DWORD *)(a1 + 412) >= v24)
  {
    v28 = HostTime;
    v29 = v26 * v25;
    v30 = (v29 * v24);
    do
    {
      AudioBufferList = VCAudioBufferList_GetAudioBufferList(a2);
      *(_QWORD *)(AudioBufferList + 16) = *(_QWORD *)(a1 + 400);
      *(_DWORD *)(AudioBufferList + 12) = v30;
      VCAudioBufferList_InvalidateAveragePower(a2);
      VCAudioBufferList_SetTime(a2, v9, v28);
      VCAudioBufferList_SetSampleCount(a2, v24);
      v32 = *(_QWORD *)(a1 + 480);
      if (v32)
        VCCannedAudioInjector_InjectSamples(v32, a2, *(_DWORD *)(a1 + 332) != 0, 0);
      else
        VCAudioBufferList_SetVoiceActivity(a2, *(_DWORD *)(a1 + 392));
      (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(a1 + 16), a2);
      VCAudioBufferList_Reset(a2);
      memmove(*(void **)(a1 + 400), (const void *)(*(_QWORD *)(a1 + 400) + v30), (v29 * (*(_DWORD *)(a1 + 412) - v24)));
      v33 = *(_DWORD *)(a1 + 412) - v24;
      *(_DWORD *)(a1 + 412) = v33;
      v9 += v24;
      v28 = v28 + (double)v24 / *(double *)(a1 + 136);
    }
    while (v33 >= v24);
  }
}

uint64_t LogProfileTimeOverLimitCompare(double a1, double a2, double a3, const char *a4, ...)
{
  uint64_t result;
  double v7;
  __int128 v8;
  uint64_t v9;
  NSObject *v10;
  uint8_t buf[4];
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  char *v18;
  __int16 v19;
  double v20;
  char __str[16];
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;
  va_list va;

  va_start(va, a4);
  v37 = *MEMORY[0x1E0C80C00];
  result = VRTraceIsInternalOSInstalled();
  if ((_DWORD)result)
  {
    v7 = a2 - a1;
    if (v7 <= 0.1)
    {
      return 0;
    }
    else
    {
      *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v35 = v8;
      v36 = v8;
      v33 = v8;
      v34 = v8;
      v31 = v8;
      v32 = v8;
      v29 = v8;
      v30 = v8;
      v27 = v8;
      v28 = v8;
      v26 = v8;
      v24 = v8;
      v25 = v8;
      v22 = v8;
      v23 = v8;
      *(_OWORD *)__str = v8;
      vsnprintf(__str, 0x100uLL, "AUIO last mic sample delayed. currentTime=%f previousTime=%f delta=%f", va);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v9 = VRTraceErrorLogLevelToCSTR();
        v10 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316162;
          v12 = v9;
          v13 = 2080;
          v14 = "_LogProfileTimeLimitHelper";
          v15 = 1024;
          v16 = 36;
          v17 = 2080;
          v18 = __str;
          v19 = 2048;
          v20 = v7;
          _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d %s: Took a long time %fs", buf, 0x30u);
        }
      }
      return 1;
    }
  }
  return result;
}

uint64_t _AUIOSpkrProc(_QWORD *a1, unsigned int *a2, const AudioTimeStamp *a3, unsigned int a4, unsigned int a5, AudioBufferList *a6)
{
  uint64_t mSampleTime;
  uint64_t v10;
  size_t v11;
  _DWORD *AudioBufferList;
  _DWORD *v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t result;
  double v17;
  double mHostTime;
  int v19;
  uint64_t v20;
  NSObject *v21;
  NSObject *v22;
  int v23;
  int v24;
  void **p_mData;
  void *v26;
  double v27;
  double v28;
  double *SampleFormat;
  double v30;
  uint64_t v31;
  NSObject *v32;
  uint64_t v33;
  double v34;
  unsigned int *v35;
  unint64_t v36;
  unint64_t v37;
  AudioBuffer *mBuffers;
  _OWORD *v39;
  __int128 v40;
  int v41;
  uint64_t v42;
  _BOOL4 IsSilenceInQueue;
  int v44;
  float v45;
  _BOOL4 v47;
  char v48;
  int v49;
  int v50;
  int v51;
  UInt32 mNumberBuffers;
  UInt32 mDataByteSize;
  int v54;
  int v55;
  uint8_t buf[4];
  uint64_t v58;
  __int16 v59;
  const char *v60;
  __int16 v61;
  int v62;
  __int16 v63;
  _BYTE v64[10];
  uint64_t v65;
  _BYTE v66[10];
  __int16 v67;
  unsigned int v68;
  __int16 v69;
  double v70;
  __int16 v71;
  double v72;
  uint64_t v73;

  v73 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!(_DWORD)result)
        return result;
      _AUIOSpkrProc();
    }
    return 0;
  }
  mSampleTime = (uint64_t)a3->mSampleTime;
  kdebug_trace();
  v10 = *((unsigned int *)a1 + 21);
  v11 = *((_DWORD *)a1 + 20) * a5;
  ++a1[69];
  VCAudioBufferList_Reset(a1[31]);
  AudioBufferList = (_DWORD *)VCAudioBufferList_GetAudioBufferList(a1[31]);
  if (AudioBufferList[3] * *AudioBufferList >= (v11 * v10))
  {
    if (*((_BYTE *)a1 + 234))
    {
      v17 = *((double *)a1 + 55);
      mHostTime = (double)a3->mHostTime;
      v19 = *((_DWORD *)a1 + 104);
      if (v19)
      {
        if ((int)mSampleTime - (v19 + *((_DWORD *)a1 + 108)) > 2 * a5)
        {
          *((_DWORD *)a1 + 108) = mSampleTime - v19;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            v20 = VRTraceErrorLogLevelToCSTR();
            v21 = *MEMORY[0x1E0CF2758];
            v22 = *MEMORY[0x1E0CF2758];
            if (*MEMORY[0x1E0CF2748])
            {
              if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
              {
                v23 = *((_DWORD *)a1 + 108);
                v24 = *((_DWORD *)a1 + 104);
                *(_DWORD *)buf = 136316418;
                v58 = v20;
                v59 = 2080;
                v60 = "_AUIOSpkrProc";
                v61 = 1024;
                v62 = 669;
                v63 = 1024;
                *(_DWORD *)v64 = v23;
                *(_WORD *)&v64[4] = 1024;
                *(_DWORD *)&v64[6] = mSampleTime;
                LOWORD(v65) = 1024;
                *(_DWORD *)((char *)&v65 + 2) = v24;
                _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d Setting timestamp delta to %d: speaker %d - mic %d", buf, 0x2Eu);
              }
            }
            else if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
            {
              v54 = *((_DWORD *)a1 + 108);
              v55 = *((_DWORD *)a1 + 104);
              *(_DWORD *)buf = 136316418;
              v58 = v20;
              v59 = 2080;
              v60 = "_AUIOSpkrProc";
              v61 = 1024;
              v62 = 669;
              v63 = 1024;
              *(_DWORD *)v64 = v54;
              *(_WORD *)&v64[4] = 1024;
              *(_DWORD *)&v64[6] = mSampleTime;
              LOWORD(v65) = 1024;
              *(_DWORD *)((char *)&v65 + 2) = v55;
              _os_log_debug_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEBUG, "AUIO [%s] %s:%d Setting timestamp delta to %d: speaker %d - mic %d", buf, 0x2Eu);
            }
          }
        }
      }
      v27 = v17 * mHostTime;
      v28 = 0.0;
      if (VRTraceIsInternalOSInstalled())
        v28 = micro();
      SampleFormat = (double *)VCAudioBufferList_GetSampleFormat(a1[31]);
      v30 = (double)a5 / *SampleFormat + (double)a5 / *SampleFormat;
      if (v27 - *((double *)a1 + 57) > v30 && (int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v31 = VRTraceErrorLogLevelToCSTR();
        v32 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v33 = a1[57];
          v34 = *SampleFormat;
          *(_DWORD *)buf = 136317186;
          v58 = v31;
          v59 = 2080;
          v60 = "_AUIOSpkrProc";
          v61 = 1024;
          v62 = 677;
          v63 = 2048;
          *(_QWORD *)v64 = a1;
          *(_WORD *)&v64[8] = 2048;
          v65 = v33;
          *(_WORD *)v66 = 2048;
          *(double *)&v66[2] = v27;
          v67 = 1024;
          v68 = a5;
          v69 = 2048;
          v70 = v34;
          v71 = 2048;
          v72 = v30;
          _os_log_impl(&dword_1D8A54000, v32, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d [AUIO=%p] Observing hostTime Jump previousHostTime=%f currentHostTime=%f inNumberFrames=%d format->mSampleRate=%f allowedHostTimeJump=%f", buf, 0x54u);
        }
      }
      *((double *)a1 + 57) = v27;
      VCAudioBufferList_SetTime(a1[31], mSampleTime, v27);
      VCAudioBufferList_SetSampleCount(a1[31], (*SampleFormat * (double)a5 / *((double *)a1 + 7)));
      v35 = (unsigned int *)VCAudioBufferList_GetAudioBufferList(a1[31]);
      v36 = *v35;
      if ((_DWORD)v36)
      {
        v37 = 0;
        mBuffers = a6->mBuffers;
        v39 = v35 + 2;
        do
        {
          v40 = (__int128)*mBuffers++;
          *v39++ = v40;
          ++v37;
        }
        while (v37 < v36);
      }
      ((void (*)(_QWORD, _QWORD))a1[1])(*a1, a1[31]);
      if (LogProfileTimeOverLimit(v28, 0.00800000038, "IOProc: shenanigans spkr proc"))
        ++*((_DWORD *)a1 + 134);
      *((float *)a1 + 93) = VCAudioBufferList_GetAveragePower(a1[31]);
      ++a1[70];
      kdebug_trace();
      v41 = *((unsigned __int8 *)a1 + 388);
      v42 = a1[76];
      if (v42 && VCAudioSession_IsDeferredNetworkUplinkClockUpdateSupported(v42))
      {
        IsSilenceInQueue = VCAudioBufferList_IsSilenceInQueue(a1[31]);
        *((_BYTE *)a1 + 376) = IsSilenceInQueue;
        if (IsSilenceInQueue)
          v44 = *((_DWORD *)a1 + 95) + 1;
        else
          v44 = 0;
        *((_DWORD *)a1 + 95) = v44;
        v45 = *((float *)a1 + 96) * 0.67 + *((float *)a1 + 93) * 0.33;
        *((float *)a1 + 96) = v45;
        if (IsSilenceInQueue)
        {
          v47 = v45 <= -80.0 && v44 > 14;
          if (!v41 && v47)
          {
            VCAudioSession_ScheduleNetworkUplinkClockUpdate(a1[76]);
            v48 = 1;
LABEL_53:
            result = 0;
            *((_BYTE *)a1 + 388) = v48;
            return result;
          }
        }
        else
        {
          LOBYTE(v47) = 0;
        }
        if (v41)
        {
          v48 = 0;
          result = 0;
          if (v47)
            return result;
          goto LABEL_53;
        }
      }
      else
      {
        v48 = 0;
        if (v41)
          goto LABEL_53;
      }
    }
    else
    {
      ++a1[70];
      if ((_DWORD)v10)
      {
        p_mData = &a6->mBuffers[0].mData;
        do
        {
          *((_DWORD *)p_mData - 1) = v11;
          v26 = *p_mData;
          p_mData += 2;
          bzero(v26, v11);
          --v10;
        }
        while (v10);
      }
      ((void (*)(_QWORD, uint64_t))a1[4])(*a1, 2149253137);
    }
    return 0;
  }
  v13 = AudioBufferList;
  ++a1[70];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v14 = VRTraceErrorLogLevelToCSTR();
    v15 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      v49 = v13[3];
      v50 = *((_DWORD *)a1 + 20);
      v51 = *((_DWORD *)a1 + 21);
      mNumberBuffers = a6->mNumberBuffers;
      mDataByteSize = a6->mBuffers[0].mDataByteSize;
      *(_DWORD *)buf = 136317442;
      v58 = v14;
      v59 = 2080;
      v60 = "_AUIOSpkrProc";
      v61 = 1024;
      v62 = 649;
      v63 = 1024;
      *(_DWORD *)v64 = v49;
      *(_WORD *)&v64[4] = 1024;
      *(_DWORD *)&v64[6] = v11 * v10;
      LOWORD(v65) = 1024;
      *(_DWORD *)((char *)&v65 + 2) = a5;
      HIWORD(v65) = 1024;
      *(_DWORD *)v66 = v50;
      *(_WORD *)&v66[4] = 1024;
      *(_DWORD *)&v66[6] = v51;
      v67 = 1024;
      v68 = mNumberBuffers;
      v69 = 1024;
      LODWORD(v70) = mDataByteSize;
      _os_log_error_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_ERROR, "AUIO [%s] %s:%d speaker sample buffer is too small (%d). Expected=%d frames=%d bytesPerFrame=%d channels=%d! BufferCount=%d size=%d", buf, 0x46u);
    }
  }
  ((void (*)(_QWORD, uint64_t))a1[4])(*a1, 2149253134);
  return 14;
}

uint64_t _AUIOSpkrProcGKS(_QWORD *a1, unsigned int *a2, const AudioTimeStamp *a3, unsigned int a4, unsigned int a5, AudioBufferList *a6)
{
  int v10;
  uint64_t v11;
  double v12;
  UInt64 mHostTime;
  int v14;
  uint64_t v15;
  NSObject *v16;
  NSObject *v17;
  int v18;
  int v19;
  size_t v20;
  void **v21;
  void *v22;
  double v23;
  double v24;
  double v25;
  uint64_t SampleFormat;
  uint64_t v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int SampleCount;
  unsigned int v31;
  int v32;
  unsigned int *AudioBufferList;
  unsigned int *v34;
  unint64_t v35;
  size_t v36;
  uint64_t v37;
  unsigned int v38;
  unsigned int v39;
  unsigned int *v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD *v43;
  void **p_mData;
  char *v45;
  unsigned int v46;
  int v48;
  int v49;
  uint64_t mSampleTime;
  unsigned int v51;
  uint8_t buf[4];
  uint64_t v53;
  __int16 v54;
  const char *v55;
  __int16 v56;
  int v57;
  __int16 v58;
  int v59;
  __int16 v60;
  int v61;
  __int16 v62;
  int v63;
  uint64_t v64;

  v64 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    mSampleTime = (uint64_t)a3->mSampleTime;
    kdebug_trace();
    v10 = *((_DWORD *)a1 + 20);
    v11 = *((unsigned int *)a1 + 21);
    ++a1[69];
    if (*((_BYTE *)a1 + 234))
    {
      v12 = *((double *)a1 + 55);
      mHostTime = a3->mHostTime;
      v14 = *((_DWORD *)a1 + 104);
      if (v14)
      {
        if ((int)mSampleTime - (v14 + *((_DWORD *)a1 + 108)) > 2 * a5)
        {
          *((_DWORD *)a1 + 108) = mSampleTime - v14;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            v15 = VRTraceErrorLogLevelToCSTR();
            v16 = *MEMORY[0x1E0CF2758];
            v17 = *MEMORY[0x1E0CF2758];
            if (*MEMORY[0x1E0CF2748])
            {
              if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
              {
                v18 = *((_DWORD *)a1 + 108);
                v19 = *((_DWORD *)a1 + 104);
                *(_DWORD *)buf = 136316418;
                v53 = v15;
                v54 = 2080;
                v55 = "_AUIOSpkrProcGKS";
                v56 = 1024;
                v57 = 742;
                v58 = 1024;
                v59 = v18;
                v60 = 1024;
                v61 = mSampleTime;
                v62 = 1024;
                v63 = v19;
                _os_log_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEFAULT, "AUIO [%s] %s:%d Setting timestamp delta to %d: speaker %d - mic %d", buf, 0x2Eu);
              }
            }
            else if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
            {
              v48 = *((_DWORD *)a1 + 108);
              v49 = *((_DWORD *)a1 + 104);
              *(_DWORD *)buf = 136316418;
              v53 = v15;
              v54 = 2080;
              v55 = "_AUIOSpkrProcGKS";
              v56 = 1024;
              v57 = 742;
              v58 = 1024;
              v59 = v48;
              v60 = 1024;
              v61 = mSampleTime;
              v62 = 1024;
              v63 = v49;
              _os_log_debug_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEBUG, "AUIO [%s] %s:%d Setting timestamp delta to %d: speaker %d - mic %d", buf, 0x2Eu);
            }
          }
        }
      }
      v23 = (double)mHostTime;
      v24 = 0.0;
      if (VRTraceIsInternalOSInstalled())
        v24 = micro();
      v25 = v12 * v23;
      SampleFormat = VCAudioBufferList_GetSampleFormat(a1[31]);
      if (a5)
      {
        v27 = SampleFormat;
        v28 = 0;
        v29 = 0;
        v51 = a5;
        do
        {
          SampleCount = VCAudioBufferList_GetSampleCount(a1[31]);
          if (SampleCount)
          {
            if (SampleCount >= a5 - v29)
              v31 = a5 - v29;
            else
              v31 = SampleCount;
            v32 = *(_DWORD *)(v27 + 16);
            AudioBufferList = (unsigned int *)VCAudioBufferList_GetAudioBufferList(a1[31]);
            if (*AudioBufferList)
            {
              v34 = AudioBufferList;
              v35 = 0;
              v36 = v32 * v31;
              v37 = 4;
              do
              {
                memcpy((void *)(*(_QWORD *)((char *)&a6->mNumberBuffers + v37 * 4) + *(_DWORD *)(v27 + 16) * v29), *(const void **)&v34[v37], v36);
                ++v35;
                v37 += 4;
              }
              while (v35 < *v34);
            }
            VCAudioBufferList_Shift(a1[31], v31);
            v28 = (*(double *)v27 * (double)v31 / *((double *)a1 + 7) + (double)v28);
            v29 += v31;
            a5 = v51;
          }
          v38 = a5 - v29;
          if (a5 > v29)
          {
            VCAudioBufferList_Reset(a1[31]);
            VCAudioBufferList_SetTime(a1[31], v28 + mSampleTime, v25);
            VCAudioBufferList_SetSampleCount(a1[31], *((_DWORD *)a1 + 56));
            v39 = *((_DWORD *)a1 + 56);
            if (v38 >= v39)
            {
              v40 = (unsigned int *)VCAudioBufferList_GetAudioBufferList(a1[31]);
              v41 = *v40;
              if ((_DWORD)v41)
              {
                v42 = *(_DWORD *)(v27 + 16) * v29;
                v43 = v40 + 4;
                p_mData = &a6->mBuffers[0].mData;
                do
                {
                  v45 = (char *)*p_mData;
                  p_mData += 2;
                  *v43 = &v45[v42];
                  v43 += 2;
                  --v41;
                }
                while (v41);
              }
            }
            ((void (*)(_QWORD, _QWORD))a1[1])(*a1, a1[31]);
            if (LogProfileTimeOverLimit(v24, 0.00800000038, "IOProc: shenanigans spkr proc"))
              ++*((_DWORD *)a1 + 134);
            *((float *)a1 + 93) = VCAudioBufferList_GetAveragePower(a1[31]);
            if (v38 >= v39)
            {
              v46 = *((_DWORD *)a1 + 56);
              v29 += v46;
              v28 = (*(double *)v27 * (double)v46 / *((double *)a1 + 7) + (double)v28);
              VCAudioBufferList_SetSampleCount(a1[31], 0);
            }
          }
        }
        while (v29 < a5);
      }
      ++a1[70];
      kdebug_trace();
    }
    else
    {
      ++a1[70];
      if ((_DWORD)v11)
      {
        v20 = v10 * a5;
        v21 = &a6->mBuffers[0].mData;
        do
        {
          *((_DWORD *)v21 - 1) = v20;
          v22 = *v21;
          v21 += 2;
          bzero(v22, v20);
          --v11;
        }
        while (v11);
      }
      ((void (*)(_QWORD, uint64_t))a1[4])(*a1, 2149253137);
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _AUIOSpkrProcGKS();
  }
  return 0;
}

void ___ZL22_AUIOStartPacketThreadP7tagAUIO_block_invoke(uint64_t a1, uint64_t a2)
{
  VCAudioBufferList_GetTimestamp(a2);
  VCAudioBufferList_GetSampleCount(a2);
  kdebug_trace();
  _AUIOSendMicSamples(*(_QWORD *)(a1 + 32), a2);
}

void sub_1D8F03E70(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void *newVideoRulesForFormatList(uint64_t a1, int a2)
{
  uint64_t v2;
  void *v4;
  BOOL v5;
  unsigned int *v6;
  VCVideoRule *v7;
  double v8;
  uint64_t v9;
  void *v10;

  LODWORD(v2) = a2;
  v4 = (void *)objc_opt_new();
  if (v4)
    v5 = (_DWORD)v2 == 0;
  else
    v5 = 1;
  if (!v5)
  {
    v2 = v2;
    v6 = (unsigned int *)(a1 + 8);
    do
    {
      v7 = [VCVideoRule alloc];
      *(float *)&v8 = (float)*v6;
      v9 = -[VCVideoRule initWithFrameWidth:frameHeight:frameRate:payload:](v7, "initWithFrameWidth:frameHeight:frameRate:payload:", *(v6 - 2), *(v6 - 1), 123, v8);
      if (v9)
      {
        v10 = (void *)v9;
        objc_msgSend(v4, "addObject:", v9);

      }
      v6 += 3;
      --v2;
    }
    while (v2);
  }
  return v4;
}

void sub_1D8F05074(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t NetworkUtils_IsLTEOrNewer(unsigned int a1)
{
  return (a1 < 0xA) & (0x320u >> a1);
}

uint64_t VCNetworkUtils_AdditionalOverheadForIDSOptions(int a1, int a2, int a3)
{
  _OWORD v4[7];
  uint64_t v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v5 = 0;
  memset(v4, 0, sizeof(v4));
  _VCNetworkUtils_ComposeMaxedOutIDSOverheadOptions(a1, a2, a3, (uint64_t)v4);
  return IDSEstimateAdditionalOverheadForDatagramOptions();
}

void _VCNetworkUtils_ComposeMaxedOutIDSOverheadOptions(int a1, int a2, int a3, uint64_t a4)
{
  int v4;
  int v5;
  int v6;

  if (a4)
  {
    *(_QWORD *)(a4 + 112) = 0;
    *(_OWORD *)(a4 + 80) = 0u;
    *(_OWORD *)(a4 + 96) = 0u;
    *(_OWORD *)(a4 + 48) = 0u;
    *(_OWORD *)(a4 + 64) = 0u;
    *(_OWORD *)(a4 + 16) = 0u;
    *(_OWORD *)(a4 + 32) = 0u;
    *(_OWORD *)a4 = 0u;
    if (a1)
    {
      *(_BYTE *)(a4 + 19) = a1;
      v4 = 3;
    }
    else
    {
      v4 = 1;
    }
    if (a3)
      v5 = 16;
    else
      v5 = 0;
    if (a2)
      v6 = 231404;
    else
      v6 = 231396;
    *(_DWORD *)a4 = v6 | v5 | v4;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCNetworkUtils_ComposeMaxedOutIDSOverheadOptions_cold_1();
  }
}

uint64_t VCNetworkUtils_WorstCaseIDSOverheadForOptions(int a1, int a2, int a3)
{
  _OWORD v4[7];
  uint64_t v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v5 = 0;
  memset(v4, 0, sizeof(v4));
  _VCNetworkUtils_ComposeMaxedOutIDSOverheadOptions(a1, a2, a3, (uint64_t)v4);
  return IDSWorstCaseOverheadForDatagramOptions();
}

void VCVirtualAVCaptureVideoDataOutput_OnMediaSample(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  id v7;
  NSObject *v8;
  _QWORD block[9];

  block[8] = *MEMORY[0x1E0C80C00];
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 48));
  if (a2)
    CFRetain(a2);
  v7 = *(id *)(a1 + 40);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = __VCVirtualAVCaptureVideoDataOutput_OnMediaSample_block_invoke;
  block[3] = &unk_1E9E54B40;
  block[4] = v7;
  block[5] = a1;
  block[6] = a4;
  block[7] = a2;
  v8 = *(NSObject **)(a1 + 32);
  if (v8)
  {
    dispatch_async(v8, block);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 48));
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 48));
    __VCVirtualAVCaptureVideoDataOutput_OnMediaSample_block_invoke((uint64_t)block);
  }
}

uint64_t VCVideoCapture_CompareSinkEntries(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  BOOL v4;
  unsigned int v5;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a2 + 8);
  v4 = v2 == v3;
  v5 = 2 * (v2 >= v3);
  if (v4)
    return 1;
  else
    return v5;
}

uint64_t VCVideoCapture_DistributeVideoFrame(uint64_t a1, uint64_t a2, __int128 *a3, uint64_t a4)
{
  pthread_mutex_t *v8;
  _QWORD v10[6];
  __int128 v11;
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v8 = (pthread_mutex_t *)(a1 + 40);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 40));
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 3221225472;
  v10[2] = __VCVideoCapture_DistributeVideoFrame_block_invoke;
  v10[3] = &__block_descriptor_72_e66_v24__0___VCSingleLinkedListEntry____VCSingleLinkedListEntry__8_B16l;
  v11 = *a3;
  v12 = *((_QWORD *)a3 + 2);
  v10[4] = a2;
  v10[5] = a4;
  VCSingleLinkedListEnumerate(a1 + 112, (uint64_t)v10);
  return pthread_mutex_unlock(v8);
}

_DWORD *RateMonitorCreateWithHistoryLength(int a1)
{
  _DWORD *v2;

  v2 = malloc_type_calloc(1uLL, 0x50uLL, 0x10100407B5C152EuLL);
  v2[8] = a1;
  *((_QWORD *)v2 + 5) = malloc_type_malloc(a1, 0x100004077774924uLL);
  return v2;
}

void RateMonitorDestroy(void **a1)
{
  free(a1[5]);
  free(a1);
}

double *RateMonitorConfigureWithThresholds(double *result, double a2, double a3, double a4, double a5)
{
  if (result)
  {
    result[8] = a5;
    result[2] = a3;
    result[3] = a4;
    result[1] = a2;
  }
  return result;
}

_BYTE *RateMonitorStart(_BYTE *result)
{
  *result = 1;
  return result;
}

uint64_t RateMonitorUpdateDataSamples(uint64_t a1, double a2, double a3)
{
  uint64_t result;
  uint64_t v6;
  double v8;
  double v9;
  double v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  _BOOL4 v16;
  int v17;
  double v18;
  double v19;
  BOOL v20;
  uint64_t v21;
  NSObject *v22;
  NSObject *v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  uint64_t v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  int v37;
  __int16 v38;
  int v39;
  __int16 v40;
  int v41;
  __int16 v42;
  double v43;
  __int16 v44;
  double v45;
  __int16 v46;
  double v47;
  __int16 v48;
  _BOOL4 v49;
  __int16 v50;
  int v51;
  __int16 v52;
  int v53;
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)a1)
    return 0;
  result = 0;
  v6 = 16;
  if (*(double *)(a1 + 8) < a2)
    v6 = 24;
  if (a2 != 0.0 && a3 != 0.0)
  {
    v8 = *(double *)(a1 + v6);
    v9 = vabdd_f64(a2, a3);
    v10 = v8 * a2;
    v11 = *(int *)(a1 + 52);
    v12 = *(_DWORD *)(a1 + 32);
    v13 = ((int)v11 + 1) % v12;
    v14 = *(_QWORD *)(a1 + 40);
    if (v13 == *(_DWORD *)(a1 + 48))
    {
      v15 = *(_DWORD *)(a1 + 56) - *(unsigned __int8 *)(v14 + v13);
      *(_DWORD *)(a1 + 48) = (v13 + 1) % v12;
    }
    else
    {
      v15 = *(_DWORD *)(a1 + 56);
    }
    v16 = v9 > v10;
    *(_BYTE *)(v14 + v11) = v9 > v8 * a2;
    if (v9 <= v10)
      v17 = v15;
    else
      v17 = v15 + 1;
    *(_DWORD *)(a1 + 52) = v13;
    *(_DWORD *)(a1 + 56) = v17;
    v18 = (double)v17 / (double)v12;
    v19 = *(double *)(a1 + 64);
    v20 = v18 > v19 || *(_BYTE *)(a1 + 72) != 0;
    *(_BYTE *)(a1 + 72) = v20;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v21 = VRTraceErrorLogLevelToCSTR();
      v22 = *MEMORY[0x1E0CF2758];
      v23 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          v25 = *(_DWORD *)(a1 + 48);
          v24 = *(_DWORD *)(a1 + 52);
          v26 = *(_DWORD *)(a1 + 56);
          v27 = *(unsigned __int8 *)(a1 + 72);
          v32 = 136317698;
          v33 = v21;
          v34 = 2080;
          v35 = "RateMonitorUpdateDataSamples";
          v36 = 1024;
          v37 = 71;
          v38 = 1024;
          v39 = v24;
          v40 = 1024;
          v41 = v25;
          v42 = 2048;
          v43 = a2;
          v44 = 2048;
          v45 = a3;
          v46 = 2048;
          v47 = v8;
          v48 = 1024;
          v49 = v16;
          v50 = 1024;
          v51 = v26;
          v52 = 1024;
          v53 = v27;
          _os_log_impl(&dword_1D8A54000, v22, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Rate Monitor: head index %d, tail index %d, dataSample1 %f, dataSample2 %f, tierTolerance %f, isAbnormalData %d, _abnormalCounter %d, isExceedingThreshold %d", (uint8_t *)&v32, 0x58u);
        }
      }
      else if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
      {
        v29 = *(_DWORD *)(a1 + 48);
        v28 = *(_DWORD *)(a1 + 52);
        v30 = *(_DWORD *)(a1 + 56);
        v31 = *(unsigned __int8 *)(a1 + 72);
        v32 = 136317698;
        v33 = v21;
        v34 = 2080;
        v35 = "RateMonitorUpdateDataSamples";
        v36 = 1024;
        v37 = 71;
        v38 = 1024;
        v39 = v28;
        v40 = 1024;
        v41 = v29;
        v42 = 2048;
        v43 = a2;
        v44 = 2048;
        v45 = a3;
        v46 = 2048;
        v47 = v8;
        v48 = 1024;
        v49 = v16;
        v50 = 1024;
        v51 = v30;
        v52 = 1024;
        v53 = v31;
        _os_log_debug_impl(&dword_1D8A54000, v22, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Rate Monitor: head index %d, tail index %d, dataSample1 %f, dataSample2 %f, tierTolerance %f, isAbnormalData %d, _abnormalCounter %d, isExceedingThreshold %d", (uint8_t *)&v32, 0x58u);
      }
    }
    if (v18 > v19)
    {
      *(_QWORD *)(a1 + 48) = 0;
      result = 1;
      *(_DWORD *)(a1 + 56) = 0;
      return result;
    }
    return 0;
  }
  return result;
}

uint64_t VCCVOExtensionUtils_FillCVOExtension(char a1, char a2, uint64_t a3)
{
  uint64_t result;

  *(_DWORD *)a3 = 16834238;
  *(_BYTE *)(a3 + 4) = 16 * a2;
  result = videoOrientationForCameraStatusBits(a1);
  *(_BYTE *)(a3 + 5) = result;
  *(_WORD *)(a3 + 6) = 0;
  return result;
}

uint64_t VCCVOExtensionUtils_CameraStatusBitsFromCVOExtension(unsigned int a1, unsigned __int16 *a2, unsigned int a3, _BYTE *a4)
{
  uint64_t result;
  unsigned int v6;
  unint64_t v7;
  unsigned int v8;
  unint64_t v9;
  uint64_t v10;
  NSObject *v11;
  _BOOL4 v12;
  const char *v13;
  NSObject *v14;
  uint32_t v15;
  uint64_t v16;
  NSObject *v17;
  _BOOL4 v18;
  int v19;
  uint64_t v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  unsigned int v26;
  __int16 v27;
  int v28;
  uint64_t v29;

  result = 0;
  v29 = *MEMORY[0x1E0C80C00];
  if (a2 && a3 >= 4)
  {
    v6 = *a2;
    if (v6 == 57022)
    {
      if (a3 >= 5)
      {
        v7 = 4;
        do
        {
          v8 = *((unsigned __int8 *)a2 + v7);
          if (v8 >> 4 == 15)
            break;
          v9 = v7 + 1;
          if (v8 >= 0x10)
          {
            v7 = (v8 & 0xF) + v9 + 1;
            if (v7 > a3)
              break;
            if (v8 >> 4 == a1)
            {
              *a4 = *((_BYTE *)a2 + v9) & 8 | (0x81828083 >> (8 * (*((_BYTE *)a2 + v9) & 3)));
              return 1;
            }
          }
          else
          {
            ++v7;
          }
        }
        while (v7 < a3);
      }
      if ((int)VRTraceGetErrorLogLevelForModule() < 5)
        return 0;
      v10 = VRTraceErrorLogLevelToCSTR();
      v11 = *MEMORY[0x1E0CF2758];
      v12 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
      result = 0;
      if (!v12)
        return result;
      v19 = 136315906;
      v20 = v10;
      v21 = 2080;
      v22 = "VCCVOExtensionUtils_CameraStatusBitsFromCVOExtension";
      v23 = 1024;
      v24 = 118;
      v25 = 1024;
      v26 = a1;
      v13 = " [%s] %s:%d CVO extension ID not found %d";
      v14 = v11;
      v15 = 34;
    }
    else
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 5)
        return 0;
      v16 = VRTraceErrorLogLevelToCSTR();
      v17 = *MEMORY[0x1E0CF2758];
      v18 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
      result = 0;
      if (!v18)
        return result;
      v19 = 136316162;
      v20 = v16;
      v21 = 2080;
      v22 = "VCCVOExtensionUtils_CameraStatusBitsFromCVOExtension";
      v23 = 1024;
      v24 = 115;
      v25 = 1024;
      v26 = __rev16(v6);
      v27 = 1024;
      v28 = 48862;
      v13 = " [%s] %s:%d Invalid header extension profile 0x%x (should be 0x%x)";
      v14 = v17;
      v15 = 40;
    }
    _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, v13, (uint8_t *)&v19, v15);
    return 0;
  }
  return result;
}

void VCAudioStreamTransport_SubmitWRMReportWithJitterBufferMetrics(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  NSObject *global_queue;
  _QWORD v6[5];
  _BYTE v7[304];
  uint64_t v8;
  _OWORD __src[19];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  memset(__src, 0, sizeof(__src));
  WRMIncrementTime(a1);
  v8 = 0;
  RTPGetJitter(*(_QWORD *)(a1 + 264), (_DWORD *)(a1 + 52), (_DWORD *)&v8 + 1, &v8);
  RTPGetPacketSent(*(_QWORD *)(a1 + 264), (_DWORD *)(a1 + 196));
  *(_DWORD *)(a1 + 60) = *(_DWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)a2;
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 16);
  v4 = *(_DWORD *)(a2 + 36);
  *(_QWORD *)(a1 + 80) = (unint64_t)((double)*(unint64_t *)(a2 + 24) * 1000.0 / (double)v4);
  *(_DWORD *)(a1 + 192) = v4;
  if (WRMGenerateReport((unsigned __int8 *)a1, (uint64_t)__src))
  {
    global_queue = dispatch_get_global_queue(2, 0);
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 3221225472;
    v6[2] = __VCAudioStreamTransport_SubmitWRMReportWithJitterBufferMetrics_block_invoke;
    v6[3] = &__block_descriptor_344_e5_v8__0l;
    v6[4] = a1;
    memcpy(v7, __src, sizeof(v7));
    dispatch_async(global_queue, v6);
  }
}

void WRMReportMetricsCallback_0(void *a1, uint64_t a2)
{
  void *v4;

  v4 = (void *)MEMORY[0x1DF088A10]();
  objc_msgSend(a1, "reportWRMMetrics:", a2);
  objc_autoreleasePoolPop(v4);
}

double AudioPacket_initNewPacket(uint64_t a1, uint64_t a2)
{
  double result;

  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a1 + 40);
  *(_BYTE *)(a2 + 12) = *(_BYTE *)(a1 + 12);
  *(_QWORD *)a2 = *(_QWORD *)a1;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 8);
  *(_WORD *)(a2 + 14) = *(_WORD *)(a1 + 14);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 16);
  *(_QWORD *)(a2 + 32) = *(_QWORD *)(a1 + 32);
  *(_DWORD *)(a2 + 1816) = *(_DWORD *)(a1 + 1816);
  *(_QWORD *)(a2 + 1824) = *(_QWORD *)(a1 + 1824);
  *(_DWORD *)(a2 + 1832) = *(_DWORD *)(a1 + 1832);
  *(_QWORD *)(a2 + 1840) = *(_QWORD *)(a1 + 1840);
  result = *(double *)(a1 + 24);
  *(double *)(a2 + 24) = result;
  *(_BYTE *)(a2 + 1856) = *(_BYTE *)(a1 + 1856);
  *(_WORD *)(a2 + 1858) = *(_WORD *)(a1 + 1858);
  *(_DWORD *)(a2 + 20) = *(_DWORD *)(a1 + 16);
  return result;
}

void _VCSystemAudioCapture_destroyAudioQueueBuffers(AudioQueueRef *a1)
{
  os_log_t *v2;
  uint64_t i;
  OSStatus v4;
  OSStatus v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t buf[4];
  uint64_t v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  OSStatus v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v2 = (os_log_t *)MEMORY[0x1E0CF2758];
  for (i = 6; i != 16; ++i)
  {
    v4 = AudioQueueFreeBuffer(*a1, (AudioQueueBufferRef)a1[i]);
    if (v4)
    {
      v5 = v4;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v6 = VRTraceErrorLogLevelToCSTR();
        v7 = *v2;
        if (os_log_type_enabled(*v2, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315906;
          v9 = v6;
          v10 = 2080;
          v11 = "_VCSystemAudioCapture_destroyAudioQueueBuffers";
          v12 = 1024;
          v13 = 576;
          v14 = 1024;
          v15 = v5;
          _os_log_error_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_ERROR, " [%s] %s:%d AudioQueueFreeBuffer error: %i", buf, 0x22u);
        }
      }
    }
  }
}

void _VCSystemAudioCapture_handleInputBufferFromAudioHALPlugin(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  _VCSystemAudioCapture_handleInputBuffer(a1, 0, 0, a2, a3, a4);
}

void _VCSystemAudioCapture_handleInputBuffer(uint64_t a1, OpaqueAudioQueue *a2, AudioQueueBuffer *a3, uint64_t a4, uint64_t a5, unsigned int a6)
{
  uint64_t v12;
  NSObject *v13;
  NSObject *v14;
  uint64_t v15;
  NSObject *v16;
  NSObject *v17;
  int v18;
  uint64_t v19;
  NSObject *v20;
  NSObject *v21;
  double v22;
  uint64_t v23;
  NSObject *v24;
  NSObject *v25;
  int v26;
  double v27;
  double v28;
  unsigned int v29;
  uint64_t v30;
  NSObject *v31;
  uint64_t v32;
  uint64_t v33;
  NSObject *v34;
  NSObject *v35;
  const char *v36;
  uint64_t v37;
  NSObject *v38;
  uint64_t v39;
  uint64_t v40;
  NSObject *v41;
  float v42;
  uint64_t v43;
  NSObject *v44;
  uint64_t v45;
  NSObject *v46;
  uint64_t v47;
  NSObject *v48;
  uint64_t v49;
  NSObject *v50;
  uint64_t v51;
  NSObject *v52;
  uint64_t v53;
  NSObject *v54;
  uint64_t v55;
  NSObject *v56;
  uint64_t v57;
  NSObject *v58;
  uint64_t v59;
  NSObject *v60;
  float v61;
  uint64_t v62;
  int v63;
  double v64;
  uint64_t v65;
  uint64_t v66;
  int SampleCount;
  unsigned int v68;
  uint64_t v69;
  NSObject *v70;
  NSObject *v71;
  _DWORD *AudioBufferList;
  unint64_t v73;
  _QWORD *v74;
  uint64_t v75;
  uint64_t v76;
  char IsOSFaultDisabled;
  NSObject *v78;
  int ErrorLogLevelForModule;
  uint64_t v80;
  NSObject *v81;
  NSObject *v82;
  int Timestamp;
  unsigned int v84;
  unsigned int v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  unsigned int v89;
  double v90;
  int v91;
  int v92;
  uint64_t v93;
  uint64_t v94;
  size_t v95;
  double v96;
  _DWORD *v97;
  unint64_t v98;
  int v99;
  unint64_t v100;
  _DWORD *v101;
  uint64_t v102;
  uint64_t v103;
  int v104;
  int v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  NSObject *v110;
  NSObject *v111;
  unsigned int v112;
  int v113;
  uint64_t v114;
  size_t v115;
  int v116;
  uint64_t v117;
  char v118;
  NSObject *v119;
  uint64_t v120;
  int v121;
  int v122;
  double HostTime;
  uint64_t v124;
  NSObject *v125;
  NSObject *v126;
  uint64_t v127;
  uint64_t v128;
  OpaqueAudioQueue *v129;
  AudioQueueBuffer *v130;
  unsigned int v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  int v135;
  UInt32 ioDataSize;
  double outData;
  uint8_t buf[64];
  uint8_t v139[4];
  uint64_t v140;
  __int16 v141;
  const char *v142;
  __int16 v143;
  int v144;
  __int16 v145;
  double v146;
  uint64_t v147;

  v147 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v12 = VRTraceErrorLogLevelToCSTR();
    v13 = *MEMORY[0x1E0CF2758];
    v14 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = v12;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VCSystemAudioCapture_handleInputBuffer";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 422;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = a6;
        _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d input sample count = %d", buf, 0x22u);
      }
    }
    else if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      _VCSystemAudioCapture_handleInputBuffer_cold_13();
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v15 = VRTraceErrorLogLevelToCSTR();
    v16 = *MEMORY[0x1E0CF2758];
    v17 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        v18 = (int)*(double *)a5;
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = v15;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VCSystemAudioCapture_handleInputBuffer";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 423;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v18;
        _os_log_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d input timestamp %d", buf, 0x22u);
      }
    }
    else if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
    {
      _VCSystemAudioCapture_handleInputBuffer_cold_12();
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v19 = VRTraceErrorLogLevelToCSTR();
    v20 = *MEMORY[0x1E0CF2758];
    v21 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        v22 = *(double *)(a1 + 392) * (double)*(unint64_t *)(a5 + 8);
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = v19;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VCSystemAudioCapture_handleInputBuffer";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 424;
        *(_WORD *)&buf[28] = 2048;
        *(double *)&buf[30] = v22;
        _os_log_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d input hostTime %f", buf, 0x26u);
      }
    }
    else if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
    {
      v96 = *(double *)(a1 + 392) * (double)*(unint64_t *)(a5 + 8);
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = v19;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "_VCSystemAudioCapture_handleInputBuffer";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 424;
      *(_WORD *)&buf[28] = 2048;
      *(double *)&buf[30] = v96;
      _os_log_debug_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_DEBUG, " [%s] %s:%d input hostTime %f", buf, 0x26u);
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() < 8)
    goto LABEL_25;
  v23 = VRTraceErrorLogLevelToCSTR();
  v24 = *MEMORY[0x1E0CF2758];
  v25 = *MEMORY[0x1E0CF2758];
  if (!*MEMORY[0x1E0CF2748])
  {
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
    {
      _VCSystemAudioCapture_handleInputBuffer_cold_11();
      if (!a1)
        goto LABEL_116;
      goto LABEL_26;
    }
LABEL_25:
    if (!a1)
      goto LABEL_116;
    goto LABEL_26;
  }
  if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    goto LABEL_25;
  v26 = *(_DWORD *)(a4 + 8);
  *(_DWORD *)buf = 136315906;
  *(_QWORD *)&buf[4] = v23;
  *(_WORD *)&buf[12] = 2080;
  *(_QWORD *)&buf[14] = "_VCSystemAudioCapture_handleInputBuffer";
  *(_WORD *)&buf[22] = 1024;
  *(_DWORD *)&buf[24] = 425;
  *(_WORD *)&buf[28] = 1024;
  *(_DWORD *)&buf[30] = v26;
  _os_log_impl(&dword_1D8A54000, v24, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d input audio bytes %d", buf, 0x22u);
  if (!a1)
  {
LABEL_116:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
    {
      VRTraceErrorLogLevelToCSTR();
      if ((VRTraceIsOSFaultDisabled() & 1) != 0)
      {
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCSystemAudioCapture_handleInputBuffer_cold_1();
      }
      else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_FAULT))
      {
        _VCSystemAudioCapture_handleInputBuffer_cold_2();
      }
    }
    return;
  }
LABEL_26:
  if (*(_DWORD *)(*(_QWORD *)(a1 + 232) + 132))
  {
    v134 = a4;
    v27 = *(double *)(a1 + 264);
    v28 = *(double *)(a1 + 392) * (double)*(unint64_t *)(a5 + 8);
    v29 = vcvtpd_u64_f64(v27 * (v28 - *(double *)(a1 + 416)));
    v133 = a1;
    if (*(_DWORD *)(a1 + 344) >= a6)
    {
      if (*(_BYTE *)(a1 + 368))
      {
        if (v28 > ((double)a6 / v27 + *(double *)(a1 + 408)) * 1.2 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v37 = VRTraceErrorLogLevelToCSTR();
          v38 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            v128 = *(_QWORD *)(a1 + 408);
            *(_DWORD *)buf = 136316418;
            *(_QWORD *)&buf[4] = v37;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VCSystemAudioCapture_handleInputBuffer";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 452;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = a6;
            *(_WORD *)&buf[34] = 2048;
            *(_QWORD *)&buf[36] = v128;
            *(_WORD *)&buf[44] = 2048;
            *(double *)&buf[46] = v28;
            _os_log_error_impl(&dword_1D8A54000, v38, OS_LOG_TYPE_ERROR, " [%s] %s:%d inputSamples=%d for host time jump from time=%f to time=%f seconds", buf, 0x36u);
          }
        }
        *(_DWORD *)(a1 + 400) = v29;
        v39 = a1;
      }
      else
      {
        *(_BYTE *)(a1 + 368) = 1;
        v39 = a1;
        if (a2)
        {
          memset(buf, 0, 40);
          outData = 0.0;
          ioDataSize = 40;
          if (!AudioQueueGetProperty(a2, 0x61716674u, buf, &ioDataSize))
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v40 = VRTraceErrorLogLevelToCSTR();
              v41 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                v42 = *(double *)buf;
                *(_DWORD *)v139 = 136315906;
                v140 = v40;
                v141 = 2080;
                v142 = "_VCSystemAudioCapture_logInfoForFirstAudioBufferReceived";
                v143 = 1024;
                v144 = 590;
                v145 = 2048;
                v146 = v42;
                _os_log_impl(&dword_1D8A54000, v41, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Audio Queue config: %.1f mSampleRate", v139, 0x26u);
              }
            }
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v43 = VRTraceErrorLogLevelToCSTR();
              v44 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)v139 = 136315906;
                v140 = v43;
                v141 = 2080;
                v142 = "_VCSystemAudioCapture_logInfoForFirstAudioBufferReceived";
                v143 = 1024;
                v144 = 591;
                v145 = 1024;
                LODWORD(v146) = *(_DWORD *)&buf[8];
                _os_log_impl(&dword_1D8A54000, v44, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Audio Queue config: %d mFormatID", v139, 0x22u);
              }
            }
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v45 = VRTraceErrorLogLevelToCSTR();
              v46 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)v139 = 136315906;
                v140 = v45;
                v141 = 2080;
                v142 = "_VCSystemAudioCapture_logInfoForFirstAudioBufferReceived";
                v143 = 1024;
                v144 = 592;
                v145 = 1024;
                LODWORD(v146) = *(_DWORD *)&buf[12];
                _os_log_impl(&dword_1D8A54000, v46, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Audio Queue config: 0x%x mFormatFlags", v139, 0x22u);
              }
            }
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v47 = VRTraceErrorLogLevelToCSTR();
              v48 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)v139 = 136315906;
                v140 = v47;
                v141 = 2080;
                v142 = "_VCSystemAudioCapture_logInfoForFirstAudioBufferReceived";
                v143 = 1024;
                v144 = 593;
                v145 = 1024;
                LODWORD(v146) = *(_DWORD *)&buf[16];
                _os_log_impl(&dword_1D8A54000, v48, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Audio Queue config: %d mBytesPerPacket", v139, 0x22u);
              }
            }
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v49 = VRTraceErrorLogLevelToCSTR();
              v50 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)v139 = 136315906;
                v140 = v49;
                v141 = 2080;
                v142 = "_VCSystemAudioCapture_logInfoForFirstAudioBufferReceived";
                v143 = 1024;
                v144 = 594;
                v145 = 1024;
                LODWORD(v146) = *(_DWORD *)&buf[20];
                _os_log_impl(&dword_1D8A54000, v50, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Audio Queue config: %d mFramesPerPacket", v139, 0x22u);
              }
            }
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v51 = VRTraceErrorLogLevelToCSTR();
              v52 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)v139 = 136315906;
                v140 = v51;
                v141 = 2080;
                v142 = "_VCSystemAudioCapture_logInfoForFirstAudioBufferReceived";
                v143 = 1024;
                v144 = 595;
                v145 = 1024;
                LODWORD(v146) = *(_DWORD *)&buf[24];
                _os_log_impl(&dword_1D8A54000, v52, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Audio Queue config: %d mBytesPerFrame", v139, 0x22u);
              }
            }
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v53 = VRTraceErrorLogLevelToCSTR();
              v54 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)v139 = 136315906;
                v140 = v53;
                v141 = 2080;
                v142 = "_VCSystemAudioCapture_logInfoForFirstAudioBufferReceived";
                v143 = 1024;
                v144 = 596;
                v145 = 1024;
                LODWORD(v146) = *(_DWORD *)&buf[28];
                _os_log_impl(&dword_1D8A54000, v54, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Audio Queue config: %d mChannelsPerFrame", v139, 0x22u);
              }
            }
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v55 = VRTraceErrorLogLevelToCSTR();
              v56 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)v139 = 136315906;
                v140 = v55;
                v141 = 2080;
                v142 = "_VCSystemAudioCapture_logInfoForFirstAudioBufferReceived";
                v143 = 1024;
                v144 = 597;
                v145 = 1024;
                LODWORD(v146) = *(_DWORD *)&buf[32];
                _os_log_impl(&dword_1D8A54000, v56, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Audio Queue config: %d mBitsPerChannel", v139, 0x22u);
              }
            }
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v57 = VRTraceErrorLogLevelToCSTR();
              v58 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)v139 = 136315906;
                v140 = v57;
                v141 = 2080;
                v142 = "_VCSystemAudioCapture_logInfoForFirstAudioBufferReceived";
                v143 = 1024;
                v144 = 598;
                v145 = 1024;
                LODWORD(v146) = *(_DWORD *)&buf[36];
                _os_log_impl(&dword_1D8A54000, v58, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Audio Queue config: 0x%x mReserved", v139, 0x22u);
              }
            }
          }
          ioDataSize = 8;
          if (!AudioQueueGetProperty(a2, 0x61717372u, &outData, &ioDataSize)
            && (int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v59 = VRTraceErrorLogLevelToCSTR();
            v60 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              v61 = outData;
              *(_DWORD *)v139 = 136315906;
              v140 = v59;
              v141 = 2080;
              v142 = "_VCSystemAudioCapture_logInfoForFirstAudioBufferReceived";
              v143 = 1024;
              v144 = 605;
              v145 = 2048;
              v146 = v61;
              _os_log_impl(&dword_1D8A54000, v60, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Audio Queue config: %.1f sample rate", v139, 0x26u);
            }
          }
        }
        *(_DWORD *)(a1 + 400) = 0;
        *(double *)(a1 + 416) = v28;
      }
      v62 = v134;
      v130 = a3;
      *(double *)(v39 + 408) = v28;
      kdebug_trace();
      v63 = *(_DWORD *)(v39 + 400);
      v64 = *(double *)(v39 + 408);
      v65 = *(_QWORD *)(v39 + 376);
      v66 = v39 + 264;
      SampleCount = VCAudioBufferList_GetSampleCount(v65);
      v68 = SampleCount + a6;
      VCAudioBufferList_SetTime(v65, v63, v64);
      VCAudioBufferList_SetSampleCount(v65, v68);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v69 = VRTraceErrorLogLevelToCSTR();
        v70 = *MEMORY[0x1E0CF2758];
        v71 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315906;
            *(_QWORD *)&buf[4] = v69;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VCSystemAudioCapture_appendInputBuffer";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 520;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = v68;
            _os_log_impl(&dword_1D8A54000, v70, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d append sample count %d", buf, 0x22u);
          }
        }
        else if (os_log_type_enabled(v71, OS_LOG_TYPE_DEBUG))
        {
          _VCSystemAudioCapture_handleInputBuffer_cold_10();
        }
      }
      v129 = a2;
      AudioBufferList = (_DWORD *)VCAudioBufferList_GetAudioBufferList(v65);
      v73 = 0;
      *AudioBufferList = 1;
      v74 = AudioBufferList + 4;
      v75 = (*(_DWORD *)(v66 + 24) * SampleCount);
      do
      {
        *((_DWORD *)v74 - 2) = *(_DWORD *)(v66 + 28);
        *((_DWORD *)v74 - 1) = *(_DWORD *)(v62 + 8) + v75;
        if (v68 <= VCAudioBufferList_GetSampleCapacity(v65))
        {
          memcpy((void *)(*v74 + v75), *(const void **)v62, *(unsigned int *)(v62 + 8));
        }
        else if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
        {
          v76 = VRTraceErrorLogLevelToCSTR();
          IsOSFaultDisabled = VRTraceIsOSFaultDisabled();
          v78 = *MEMORY[0x1E0CF2758];
          if ((IsOSFaultDisabled & 1) != 0)
          {
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136315906;
              *(_QWORD *)&buf[4] = v76;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_VCSystemAudioCapture_appendInputBuffer";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 530;
              *(_WORD *)&buf[28] = 1024;
              *(_DWORD *)&buf[30] = v68;
              _os_log_error_impl(&dword_1D8A54000, v78, OS_LOG_TYPE_ERROR, " [%s] %s:%d can not copy %d audio samples", buf, 0x22u);
            }
          }
          else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 136315906;
            *(_QWORD *)&buf[4] = v76;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VCSystemAudioCapture_appendInputBuffer";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 530;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = v68;
            _os_log_fault_impl(&dword_1D8A54000, v78, OS_LOG_TYPE_FAULT, " [%s] %s:%d can not copy %d audio samples", buf, 0x22u);
          }
        }
        ++v73;
        v74 += 2;
        v62 = v134;
      }
      while (v73 < *AudioBufferList);
      ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
      a2 = v129;
      a3 = v130;
      if (ErrorLogLevelForModule >= 8)
      {
        v80 = VRTraceErrorLogLevelToCSTR();
        v81 = *MEMORY[0x1E0CF2758];
        v82 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
          {
            Timestamp = VCAudioBufferList_GetTimestamp(*(_QWORD *)(v133 + 376));
            *(_DWORD *)buf = 136315906;
            *(_QWORD *)&buf[4] = v80;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VCSystemAudioCapture_processInputBuffer";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 475;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = Timestamp;
            _os_log_impl(&dword_1D8A54000, v81, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d append timestamp %d", buf, 0x22u);
          }
        }
        else if (os_log_type_enabled(v82, OS_LOG_TYPE_DEBUG))
        {
          _VCSystemAudioCapture_handleInputBuffer_cold_9(v80, v133, v81);
        }
      }
      v84 = VCAudioBufferList_GetSampleCount(*(_QWORD *)(v133 + 376));
      v85 = *(_DWORD *)(v133 + 344);
      if (v85 <= v84)
      {
        v86 = *(_QWORD *)(v133 + 384);
        v87 = *(_QWORD *)(v133 + 376);
        v88 = v133 + 264;
        VCAudioBufferList_Reset(v86);
        v89 = VCAudioBufferList_GetSampleCount(v87) - v85;
        v90 = VCAudioBufferList_GetHostTime(v87) - (double)v89 / *(double *)(v133 + 264);
        v91 = VCAudioBufferList_GetTimestamp(v87);
        VCAudioBufferList_SetTime(v86, v91 - v89, v90);
        VCAudioBufferList_SetSampleCount(v86, v85);
        v92 = *(_DWORD *)(v133 + 332);
        if ((*(_BYTE *)(v133 + 316) & 0x20) != 0 && v92 == 2)
        {
          if (VCAudioBufferList_GetSampleCapacity(v86) < v85
            && (int)VRTraceGetErrorLogLevelForModule() >= 2)
          {
            VRTraceErrorLogLevelToCSTR();
            if ((VRTraceIsOSFaultDisabled() & 1) != 0)
            {
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                _VCSystemAudioCapture_handleInputBuffer_cold_5();
            }
            else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_FAULT))
            {
              _VCSystemAudioCapture_handleInputBuffer_cold_6();
            }
          }
          v97 = (_DWORD *)VCAudioBufferList_GetAudioBufferList(v86);
          v132 = VCAudioBufferList_GetAudioBufferList(v87);
          v99 = *(_DWORD *)(v133 + 328);
          v98 = *(unsigned int *)(v133 + 332);
          *v97 = v98;
          if ((_DWORD)v98)
          {
            v100 = 0;
            v135 = v99 * v85;
            v131 = v89;
            do
            {
              v101 = &v97[4 * v100];
              v101[2] = 1;
              v101[3] = v135;
              if (v85)
              {
                v102 = v87;
                v103 = v88;
                v104 = 0;
                v105 = 0;
                v106 = *(_QWORD *)(v132 + 16) + (*(_DWORD *)(v133 + 328) * v100);
                v107 = *((_QWORD *)v101 + 2);
                do
                {
                  memcpy((void *)(v107 + (*(_DWORD *)(v133 + 328) * v105++)), (const void *)(v106 + (v104 * *(_DWORD *)(v133 + 328))), *(unsigned int *)(v133 + 328));
                  v104 += 2;
                }
                while (v85 != v105);
                v98 = *v97;
                v88 = v103;
                v87 = v102;
                v89 = v131;
              }
              ++v100;
            }
            while (v100 < v98);
          }
        }
        else
        {
          v93 = VCAudioBufferList_GetAudioBufferList(v86);
          v94 = VCAudioBufferList_GetAudioBufferList(v87);
          v95 = *(_DWORD *)(v133 + 328) * v85;
          *(_DWORD *)v93 = 1;
          *(_DWORD *)(v93 + 8) = v92;
          *(_DWORD *)(v93 + 12) = v95;
          if (VCAudioBufferList_GetSampleCapacity(v86) >= v85)
          {
            memcpy(*(void **)(v93 + 16), *(const void **)(v94 + 16), v95);
          }
          else if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
          {
            VRTraceErrorLogLevelToCSTR();
            if ((VRTraceIsOSFaultDisabled() & 1) != 0)
            {
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                _VCSystemAudioCapture_handleInputBuffer_cold_7();
            }
            else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_FAULT))
            {
              _VCSystemAudioCapture_handleInputBuffer_cold_8();
            }
          }
        }
        v108 = VCAudioBufferList_GetAudioBufferList(v87);
        VCAudioBufferList_SetSampleCount(v87, v89);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          v109 = VRTraceErrorLogLevelToCSTR();
          v110 = *MEMORY[0x1E0CF2758];
          v111 = *MEMORY[0x1E0CF2758];
          if (*MEMORY[0x1E0CF2748])
          {
            if (os_log_type_enabled(v111, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315906;
              *(_QWORD *)&buf[4] = v109;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_VCSystemAudioCapture_UpdateAppendBuffer";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 540;
              *(_WORD *)&buf[28] = 1024;
              *(_DWORD *)&buf[30] = v89;
              _os_log_impl(&dword_1D8A54000, v110, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d append sample count %d", buf, 0x22u);
            }
          }
          else if (os_log_type_enabled(v111, OS_LOG_TYPE_DEBUG))
          {
            _VCSystemAudioCapture_handleInputBuffer_cold_4();
          }
        }
        v112 = 0;
        v113 = *(_DWORD *)(v88 + 24);
        *(_DWORD *)v108 = 1;
        v114 = v113 * v85;
        v115 = v113 * v89;
        do
        {
          v116 = *(_DWORD *)(v108 + 12) - v114;
          *(_DWORD *)(v108 + 8) = *(_DWORD *)(v88 + 28);
          *(_DWORD *)(v108 + 12) = v116;
          if (VCAudioBufferList_GetSampleCapacity(v87) >= v89)
          {
            memcpy(*(void **)(v108 + 16), (const void *)(*(_QWORD *)(v108 + 16) + v114), v115);
          }
          else if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
          {
            v117 = VRTraceErrorLogLevelToCSTR();
            v118 = VRTraceIsOSFaultDisabled();
            v119 = *MEMORY[0x1E0CF2758];
            if ((v118 & 1) != 0)
            {
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136315906;
                *(_QWORD *)&buf[4] = v117;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "_VCSystemAudioCapture_UpdateAppendBuffer";
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&buf[24] = 550;
                *(_WORD *)&buf[28] = 1024;
                *(_DWORD *)&buf[30] = v89;
                _os_log_error_impl(&dword_1D8A54000, v119, OS_LOG_TYPE_ERROR, " [%s] %s:%d can not copy %d audio samples", buf, 0x22u);
              }
            }
            else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 136315906;
              *(_QWORD *)&buf[4] = v117;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_VCSystemAudioCapture_UpdateAppendBuffer";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 550;
              *(_WORD *)&buf[28] = 1024;
              *(_DWORD *)&buf[30] = v89;
              _os_log_fault_impl(&dword_1D8A54000, v119, OS_LOG_TYPE_FAULT, " [%s] %s:%d can not copy %d audio samples", buf, 0x22u);
            }
          }
          ++v112;
        }
        while (v112 < *(_DWORD *)v108);
        v120 = *(_QWORD *)(v133 + 432);
        if (v120)
          VCCannedAudioInjector_InjectSamples(v120, *(_QWORD *)(v133 + 384), 0, 0);
        v121 = VCAudioBufferList_GetTimestamp(*(_QWORD *)(v133 + 384));
        v122 = VCAudioBufferList_GetSampleCount(*(_QWORD *)(v133 + 384));
        HostTime = VCAudioBufferList_GetHostTime(*(_QWORD *)(v133 + 384));
        a3 = v130;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          v124 = VRTraceErrorLogLevelToCSTR();
          v125 = *MEMORY[0x1E0CF2758];
          v126 = *MEMORY[0x1E0CF2758];
          if (*MEMORY[0x1E0CF2748])
          {
            if (os_log_type_enabled(v126, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136316418;
              *(_QWORD *)&buf[4] = v124;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_VCSystemAudioCapture_processInputBuffer";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 490;
              *(_WORD *)&buf[28] = 1024;
              *(_DWORD *)&buf[30] = v121;
              *(_WORD *)&buf[34] = 1024;
              *(_DWORD *)&buf[36] = v122;
              *(_WORD *)&buf[40] = 2048;
              *(double *)&buf[42] = HostTime;
              _os_log_impl(&dword_1D8A54000, v125, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d outputTimestamp=%d, outputSampleCount=%d, outputHostTime=%f", buf, 0x32u);
            }
          }
          else if (os_log_type_enabled(v126, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136316418;
            *(_QWORD *)&buf[4] = v124;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VCSystemAudioCapture_processInputBuffer";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 490;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = v121;
            *(_WORD *)&buf[34] = 1024;
            *(_DWORD *)&buf[36] = v122;
            *(_WORD *)&buf[40] = 2048;
            *(double *)&buf[42] = HostTime;
            _os_log_debug_impl(&dword_1D8A54000, v125, OS_LOG_TYPE_DEBUG, " [%s] %s:%d outputTimestamp=%d, outputSampleCount=%d, outputHostTime=%f", buf, 0x32u);
          }
        }
        kdebug_trace();
        (*(void (**)(_QWORD, _QWORD))(v133 + 360))(*(_QWORD *)(v133 + 352), *(_QWORD *)(v133 + 384));
        a2 = v129;
      }
    }
    else
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v30 = VRTraceErrorLogLevelToCSTR();
        v31 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v32 = *(_QWORD *)(a1 + 408);
          *(_DWORD *)buf = 136316418;
          *(_QWORD *)&buf[4] = v30;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VCSystemAudioCapture_handleInputBuffer";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 462;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = a6;
          *(_WORD *)&buf[34] = 2048;
          *(_QWORD *)&buf[36] = v32;
          *(_WORD *)&buf[44] = 2048;
          *(double *)&buf[46] = v28;
          _os_log_impl(&dword_1D8A54000, v31, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d discarding inputSamples=%d between time=%f and time=%f seconds", buf, 0x36u);
        }
      }
      *(_DWORD *)(a1 + 400) = v29;
      *(double *)(a1 + 408) = v28;
    }
    if (a2)
    {
      if (AudioQueueEnqueueBuffer(a2, a3, 0, 0))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v127 = VRTraceErrorLogLevelToCSTR();
          v34 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = v127;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VCSystemAudioCapture_handleInputBuffer";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 468;
            v36 = " [%s] %s:%d Could not enqueue audio buffer";
LABEL_164:
            _os_log_impl(&dword_1D8A54000, v34, OS_LOG_TYPE_DEFAULT, v36, buf, 0x1Cu);
          }
        }
      }
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 8)
      return;
    v33 = VRTraceErrorLogLevelToCSTR();
    v34 = *MEMORY[0x1E0CF2758];
    v35 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (!os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
        return;
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = v33;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "_VCSystemAudioCapture_handleInputBuffer";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 433;
      v36 = " [%s] %s:%d stopped processing audio packets";
      goto LABEL_164;
    }
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
      _VCSystemAudioCapture_handleInputBuffer_cold_3();
  }
}

void VCVideoStream_DidReceiveSampleBuffer(uint64_t a1, opaqueCMSampleBuffer *a2, int a3)
{
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  _QWORD v11[5];
  CMTime v12;
  CMTime buf;
  int v14;
  __int16 v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    VCMediaStream_Lock(a1);
    *(double *)(a1 + 1024) = micro();
    if (a3)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
      {
        v6 = VRTraceErrorLogLevelToCSTR();
        v7 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf.value) = 136315906;
          *(CMTimeValue *)((char *)&buf.value + 4) = v6;
          LOWORD(buf.flags) = 2080;
          *(_QWORD *)((char *)&buf.flags + 2) = "VCVideoStream_DidReceiveSampleBuffer";
          HIWORD(buf.epoch) = 1024;
          v14 = 3300;
          v15 = 2048;
          v16 = a1;
          _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, "VCVideoStream [%s] %s:%d VCVideoStream[%p] received first remote frame", (uint8_t *)&buf, 0x26u);
        }
      }
      _VCVideoStream_ReportingVideoStreamEventWithVideoAttributesAndStreamID(a1, 212, 0, 0);
      _VCVideoStream_ReportingAlgosVideoStreamEvent((void *)a1);
      kdebug_trace();
      v8 = VCRemoteVideoManager_DefaultManager();
      VCRemoteVideoManager_DidReceiveFirstRemoteFrameForStreamToken(v8, *(_QWORD *)(a1 + 616));
    }
    if (!*(_BYTE *)(a1 + 938))
    {
      *(_BYTE *)(a1 + 938) = 1;
      memset(&buf, 170, sizeof(buf));
      CMSampleBufferGetPresentationTimeStamp(&buf, a2);
      v9 = *(NSObject **)(a1 + 168);
      v11[0] = MEMORY[0x1E0C809B0];
      v11[1] = 3221225472;
      v11[2] = __VCVideoStream_DidReceiveSampleBuffer_block_invoke;
      v11[3] = &unk_1E9E556E0;
      v11[4] = a1;
      v12 = buf;
      dispatch_async(v9, v11);
    }
    v10 = *(_QWORD *)(a1 + 840);
    if (v10)
    {
      if ((VCImageQueue_EnqueueSampleBuffer(v10, a2) & 1) == 0 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCVideoStream_DidReceiveSampleBuffer_cold_3();
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCVideoStream_DidReceiveSampleBuffer_cold_2();
    }
    VCMediaStream_Unlock(a1);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCVideoStream_DidReceiveSampleBuffer_cold_1();
  }
}

BOOL _VCVideoStream_DidReceiveRemoteFrame(uint64_t a1, __CVBuffer *a2, __int128 *a3, void *a4, uint64_t a5, int a6)
{
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  NSObject *v15;
  CFNumberRef v16;
  uint64_t v17;
  NSObject *v18;
  CFMutableDictionaryRef EncodedCFDictionary;
  uint64_t v20;
  uint64_t v21;
  NSObject *v22;
  double v23;
  NSObject *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  NSObject *v28;
  Float64 Seconds;
  uint64_t v30;
  const __CFNumber *Attachment;
  char value;
  NSObject *v33;
  CMSampleBufferRef SampleBufferWithPixelBuffer;
  uint64_t v35;
  NSObject *v36;
  _QWORD v38[5];
  __int128 v39;
  uint64_t v40;
  _QWORD v41[5];
  char v42;
  _QWORD block[6];
  __int128 v44;
  uint64_t v45;
  double valuePtr;
  CMTime buf;
  int v48;
  __int16 v49;
  uint64_t v50;
  __int16 v51;
  Float64 v52;
  __int16 v53;
  double v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    VCMediaStream_Lock(a1);
    *(double *)(a1 + 1024) = micro();
    if (!*(_QWORD *)(a1 + 840) && (int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCVideoStream_DidReceiveRemoteFrame_cold_2();
    }
    if (CVBufferGetAttachment(a2, CFSTR("HIDTimeStamp"), 0))
    {
      *(double *)&v12 = COERCE_DOUBLE(FigCFNumberGetUInt64());
      valuePtr = (double)FigHostTimeToNanoseconds() / 1000000000.0;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v13 = VRTraceErrorLogLevelToCSTR();
        v14 = *MEMORY[0x1E0CF2758];
        v15 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf.value) = 136316418;
            *(CMTimeValue *)((char *)&buf.value + 4) = v13;
            LOWORD(buf.flags) = 2080;
            *(_QWORD *)((char *)&buf.flags + 2) = "_VCVideoStream_DidReceiveRemoteFrame";
            HIWORD(buf.epoch) = 1024;
            v48 = 3350;
            v49 = 2048;
            v50 = v12;
            v51 = 2048;
            v52 = *(double *)&v12;
            v53 = 2048;
            v54 = valuePtr;
            _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, "VCVideoStream [%s] %s:%d Attaching origin HID event timestamp=0x%llx %lld %fs", (uint8_t *)&buf, 0x3Au);
          }
        }
        else if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
        {
          LODWORD(buf.value) = 136316418;
          *(CMTimeValue *)((char *)&buf.value + 4) = v13;
          LOWORD(buf.flags) = 2080;
          *(_QWORD *)((char *)&buf.flags + 2) = "_VCVideoStream_DidReceiveRemoteFrame";
          HIWORD(buf.epoch) = 1024;
          v48 = 3350;
          v49 = 2048;
          v50 = v12;
          v51 = 2048;
          v52 = *(double *)&v12;
          v53 = 2048;
          v54 = valuePtr;
          _os_log_debug_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEBUG, "VCVideoStream [%s] %s:%d Attaching origin HID event timestamp=0x%llx %lld %fs", (uint8_t *)&buf, 0x3Au);
        }
      }
      v16 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberDoubleType, &valuePtr);
      CVBufferSetAttachment(a2, (CFStringRef)*MEMORY[0x1E0CC46A8], v16, kCVAttachmentMode_ShouldPropagate);
      if (v16)
        CFRelease(v16);
    }
    if (*(double *)&a4 != 0.0)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
      {
        v17 = VRTraceErrorLogLevelToCSTR();
        v18 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf.value) = 136316162;
          *(CMTimeValue *)((char *)&buf.value + 4) = v17;
          LOWORD(buf.flags) = 2080;
          *(_QWORD *)((char *)&buf.flags + 2) = "_VCVideoStream_DidReceiveRemoteFrame";
          HIWORD(buf.epoch) = 1024;
          v48 = 3358;
          v49 = 2048;
          v50 = a1;
          v51 = 2112;
          v52 = *(double *)&a4;
          _os_log_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_DEFAULT, "VCVideoStream [%s] %s:%d VCVideoStream[%p] remoteVideoAttributes:%@", (uint8_t *)&buf, 0x30u);
        }
      }
      if (*(_QWORD *)(a1 + 840))
      {
        EncodedCFDictionary = VideoAttributes_CreateEncodedCFDictionary(a4);
        VCImageQueue_EnqueueAttributes(*(_QWORD *)(a1 + 840), EncodedCFDictionary);
        if (EncodedCFDictionary)
          CFRelease(EncodedCFDictionary);
      }
      v44 = *a3;
      v45 = *((_QWORD *)a3 + 2);
      objc_msgSend(a4, "setFramePresentationTime:", &v44);
      v20 = VCRemoteVideoManager_DefaultManager();
      VCRemoteVideoManager_RemoteVideoAttributesDidChange(v20, (uint64_t)a4, *(_QWORD *)(a1 + 616));
      _VCVideoStream_ReportingVideoStreamEventWithVideoAttributesAndStreamID(a1, 211, a4, 0);
    }
    if (*(double *)&a5 != 0.0)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
      {
        v21 = VRTraceErrorLogLevelToCSTR();
        v22 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v23 = *(double *)(a1 + 1112);
          LODWORD(buf.value) = 136316418;
          *(CMTimeValue *)((char *)&buf.value + 4) = v21;
          LOWORD(buf.flags) = 2080;
          *(_QWORD *)((char *)&buf.flags + 2) = "_VCVideoStream_DidReceiveRemoteFrame";
          HIWORD(buf.epoch) = 1024;
          v48 = 3372;
          v49 = 2048;
          v50 = a1;
          v51 = 2112;
          v52 = *(double *)&a5;
          v53 = 2048;
          v54 = v23;
          _os_log_impl(&dword_1D8A54000, v22, OS_LOG_TYPE_DEFAULT, "VCVideoStream [%s] %s:%d VCVideoStream[%p] remoteScreenAttributes:%@, self.videoStreamDelegate=%p", (uint8_t *)&buf, 0x3Au);
        }
      }
      v24 = *(NSObject **)(a1 + 168);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = ___VCVideoStream_DidReceiveRemoteFrame_block_invoke;
      block[3] = &unk_1E9E52238;
      block[4] = a1;
      block[5] = a5;
      dispatch_async(v24, block);
      v25 = VCRemoteVideoManager_DefaultManager();
      VCRemoteVideoManager_RemoteScreenAttributesDidChange(v25, a5, *(_QWORD *)(a1 + 616));
    }
    v26 = *(_QWORD *)(a1 + 840);
    buf = *(CMTime *)a3;
    if ((VCImageQueue_EnqueueFrame(v26, a2, &buf) & 1) == 0
      && (int)VRTraceGetErrorLogLevelForModule() >= 3
      && (VRTraceErrorLogLevelToCSTR(), os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR)))
    {
      _VCVideoStream_DidReceiveRemoteFrame_cold_1();
      if (a6)
      {
LABEL_32:
        if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
        {
          v27 = VRTraceErrorLogLevelToCSTR();
          v28 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            buf = *(CMTime *)a3;
            Seconds = CMTimeGetSeconds(&buf);
            LODWORD(buf.value) = 136316162;
            *(CMTimeValue *)((char *)&buf.value + 4) = v27;
            LOWORD(buf.flags) = 2080;
            *(_QWORD *)((char *)&buf.flags + 2) = "_VCVideoStream_DidReceiveRemoteFrame";
            HIWORD(buf.epoch) = 1024;
            v48 = 3387;
            v49 = 2048;
            v50 = a1;
            v51 = 2048;
            v52 = Seconds;
            _os_log_impl(&dword_1D8A54000, v28, OS_LOG_TYPE_DEFAULT, "VCVideoStream [%s] %s:%d VCVideoStream[%p] received first remote frame frameTime=%f", (uint8_t *)&buf, 0x30u);
          }
        }
        _VCVideoStream_ReportingVideoStreamEventWithVideoAttributesAndStreamID(a1, 212, 0, 0);
        _VCVideoStream_ReportingAlgosVideoStreamEvent((void *)a1);
        kdebug_trace();
        v30 = VCRemoteVideoManager_DefaultManager();
        VCRemoteVideoManager_DidReceiveFirstRemoteFrameForStreamToken(v30, *(_QWORD *)(a1 + 616));
      }
    }
    else if (a6)
    {
      goto LABEL_32;
    }
    Attachment = (const __CFNumber *)CVBufferGetAttachment(a2, CFSTR("FramePriority"), 0);
    if (Attachment)
    {
      LOBYTE(buf.value) = -86;
      CFNumberGetValue(Attachment, kCFNumberCharType, &buf);
      value = buf.value;
      if (*(unsigned __int8 *)(a1 + 906) != LOBYTE(buf.value))
      {
        *(_BYTE *)(a1 + 906) = buf.value;
        v33 = *(NSObject **)(a1 + 168);
        v41[0] = MEMORY[0x1E0C809B0];
        v41[1] = 3221225472;
        v41[2] = ___VCVideoStream_DidReceiveRemoteFrame_block_invoke_717;
        v41[3] = &unk_1E9E521E8;
        v41[4] = a1;
        v42 = value;
        dispatch_async(v33, v41);
      }
    }
    if (*(_QWORD *)(a1 + 272))
    {
      buf = *(CMTime *)a3;
      SampleBufferWithPixelBuffer = createSampleBufferWithPixelBuffer(a2, (__int128 *)&buf.value);
      v35 = (micro() * 1000.0);
      objc_msgSend(*(id *)(a1 + 272), "stream:addVideoSampleBuffer:cameraStatusBits:timestamp:", a1, SampleBufferWithPixelBuffer, VCCameraStatusBitsFromVideoAttributes(a4), v35);
      FigSampleBufferRelease();
    }
    _VCVideoStream_CacheRemoteVideoFrame(a1, a2);
    if (!*(_BYTE *)(a1 + 938))
    {
      *(_BYTE *)(a1 + 938) = 1;
      v36 = *(NSObject **)(a1 + 168);
      v38[0] = MEMORY[0x1E0C809B0];
      v38[1] = 3221225472;
      v38[2] = ___VCVideoStream_DidReceiveRemoteFrame_block_invoke_2;
      v38[3] = &unk_1E9E556E0;
      v38[4] = a1;
      v39 = *a3;
      v40 = *((_QWORD *)a3 + 2);
      dispatch_async(v36, v38);
      objc_msgSend(*(id *)(a1 + 744), "stopTimingForKey:", 19);
      objc_msgSend((id)a1, "reportStreamPerfTimings");
    }
    VCMediaStream_Unlock(a1);
    return a1 != 0;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCVideoStream_DidReceiveRemoteFrame_cold_3();
  }
  return a1 != 0;
}

void VCVideoStream_ProcessConvertedFrame(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned __int8 v8;
  uint64_t v9;
  uint64_t v10;
  const __CFString *v11;
  uint64_t v12;
  NSObject *v13;
  const char *v14;
  NSObject *v15;
  uint32_t v16;
  uint64_t v17;
  NSObject *v18;
  _BYTE v19[24];
  int v20;
  __int16 v21;
  const __CFString *v22;
  __int16 v23;
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (objc_msgSend((id)a1, "state") == 2 || *(_QWORD *)(a1 + 808) == 2)
  {
    v8 = atomic_load((unsigned __int8 *)(a1 + 940));
    if ((v8 & 1) != 0)
    {
      v9 = *(_QWORD *)(a1 + 848);
      v10 = *(unsigned __int8 *)(a4 + 16);
      *(_OWORD *)v19 = *(_OWORD *)a3;
      *(_QWORD *)&v19[16] = *(_QWORD *)(a3 + 16);
      VCVideoTransmitter_EnqueueVideoFrame(v9, a2, (__int128 *)v19, v10);
    }
    return;
  }
  if (objc_opt_class() == a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v12 = VRTraceErrorLogLevelToCSTR();
      v13 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v19 = 136315650;
        *(_QWORD *)&v19[4] = v12;
        *(_WORD *)&v19[12] = 2080;
        *(_QWORD *)&v19[14] = "VCVideoStream_ProcessConvertedFrame";
        *(_WORD *)&v19[22] = 1024;
        v20 = 3579;
        v14 = "VCVideoStream [%s] %s:%d Can't enqueue, VideoStream is not running yet";
        v15 = v13;
        v16 = 28;
LABEL_16:
        _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, v14, v19, v16);
      }
    }
  }
  else
  {
    if ((objc_opt_respondsToSelector() & 1) != 0)
      v11 = (const __CFString *)objc_msgSend((id)a1, "performSelector:", sel_logPrefix);
    else
      v11 = &stru_1E9E58EE0;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v17 = VRTraceErrorLogLevelToCSTR();
      v18 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v19 = 136316162;
        *(_QWORD *)&v19[4] = v17;
        *(_WORD *)&v19[12] = 2080;
        *(_QWORD *)&v19[14] = "VCVideoStream_ProcessConvertedFrame";
        *(_WORD *)&v19[22] = 1024;
        v20 = 3579;
        v21 = 2112;
        v22 = v11;
        v23 = 2048;
        v24 = a1;
        v14 = "VCVideoStream [%s] %s:%d %@(%p) Can't enqueue, VideoStream is not running yet";
        v15 = v18;
        v16 = 48;
        goto LABEL_16;
      }
    }
  }
}

void _VCVideoStreamNWConnectionNotificationCallback(void *a1, uint64_t a2)
{
  if (a1)
  {
    objc_msgSend(a1, "handleNWConnectionNotification:", a2);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCVideoStreamNWConnectionNotificationCallback_cold_1();
  }
}

void _VCVideoStreamNWConnectionPacketEventCallback(void *a1, uint64_t a2)
{
  if (a1)
  {
    objc_msgSend(a1, "handleNWConnectionPacketEvent:eventType:", a2, 1);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCVideoStreamNWConnectionPacketEventCallback_cold_1();
  }
}

uint64_t _VCVideoStreamVTPNotificationCallback(int a1, uint64_t a2, uint64_t a3)
{
  void *v5;
  const void *v6;
  uint64_t v7;
  _QWORD v9[2];

  v9[1] = *MEMORY[0x1E0C80C00];
  v9[0] = a2;
  v5 = (void *)MEMORY[0x1DF086F1C](v9);
  v6 = v5;
  if (a1 != 1)
  {
    if (a1 == 2)
    {
      objc_msgSend(v5, "handleVTPSendFailedWithData:", a3);
      v7 = 0;
      if (!v6)
        return v7;
      goto LABEL_9;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCVideoStreamVTPNotificationCallback_cold_1();
    }
  }
  v7 = 0xFFFFFFFFLL;
  if (v6)
LABEL_9:
    CFRelease(v6);
  return v7;
}

uint64_t VCVideoStream_SetFECRatio(uint64_t a1, double a2)
{
  *(double *)(a1 + 944) = a2;
  return VCVideoTransmitter_SetFECRatio(*(_QWORD *)(a1 + 848));
}

uint64_t VCVideoStream_SetMediaQueueSize(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 968) = a2;
  return VCVideoTransmitter_SetMediaQueueSize(*(_QWORD *)(a1 + 848));
}

uint64_t _VCVideoStream_GetReportingClientType(void *a1)
{
  uint64_t result;

  switch(objc_msgSend((id)objc_msgSend(a1, "defaultStreamConfig"), "type"))
  {
    case 0:
      result = 3;
      break;
    case 1:
      result = 8;
      break;
    case 2:
      result = 9;
      break;
    case 3:
      result = 6;
      break;
    case 4:
      result = objc_msgSend(a1, "remoteCameraReportingClientType");
      break;
    case 5:
    case 6:
      result = objc_msgSend(a1, "screenSharingReportingClientType");
      break;
    default:
      result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

void _VCVideoStream_CacheRemoteVideoFrame(uint64_t a1, CVPixelBufferRef texture)
{
  NSObject *v4;
  _QWORD block[7];

  block[6] = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 939))
  {
    CVPixelBufferRetain(texture);
    v4 = *(NSObject **)(a1 + 816);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = ___VCVideoStream_CacheRemoteVideoFrame_block_invoke;
    block[3] = &unk_1E9E52960;
    block[4] = a1;
    block[5] = texture;
    dispatch_async(v4, block);
  }
}

void _VCVideoStream_ReportingAlgosVideoStreamEvent(void *a1)
{
  int ReportingClientType;
  void *v3;
  void *v4;
  __CFDictionary *Mutable;

  ReportingClientType = _VCVideoStream_GetReportingClientType(a1);
  v3 = (void *)objc_msgSend(a1, "defaultStreamConfig");
  if (ReportingClientType == 6)
  {
    v4 = v3;
    if (objc_msgSend(v3, "direction") == 2)
    {
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      CFDictionaryAddValue(Mutable, CFSTR("VCSPUUID"), (const void *)objc_msgSend((id)objc_msgSend(v4, "multiwayConfig"), "participantId"));
      reportingGenericEvent();
      if (Mutable)
        CFRelease(Mutable);
    }
  }
}

uint64_t VCVideoStream_SetAudioSampleTime(uint64_t a1, int a2, double a3)
{
  return VCVideoTransmitter_SetAudioSampleTime(*(_QWORD *)(a1 + 848), a2, a3);
}

void _VCVideoStream_ReportingVideoStreamEventWithVideoAttributesAndStreamID(uint64_t a1, int a2, void *a3, const void *a4)
{
  const __CFAllocator *v8;
  __CFDictionary *Mutable;
  __CFDictionary *v10;
  void *v11;
  const void *v12;
  const __CFString *v13;
  const void *v14;
  void *v15;
  CFStringRef v16;
  CFStringRef v17;
  uint64_t v18;
  void *v19;
  void *v20;
  double v21;
  CFStringRef v22;
  const void *v23;
  void *v24;
  CFStringRef v25;
  CFStringRef v26;
  CFStringRef v27;
  void *v28;
  CFStringRef v29;
  CFStringRef v30;
  CFStringRef v31;
  void *v32;
  id v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t i;
  void *v39;
  CFStringRef v40;
  void *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t j;
  void *v46;
  uint64_t v47;
  void *v48;
  const __CFAllocator *alloc;
  void *v50;
  _BYTE v51[128];
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  _BYTE v56[128];
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v10 = Mutable;
  switch(a2)
  {
    case 201:
      v11 = (void *)objc_msgSend((id)a1, "defaultStreamConfig");
      v12 = *(const void **)(a1 + 280);
      if (v12)
      {
        CFDictionaryAddValue(v10, CFSTR("CallID"), v12);
      }
      else if (*(_QWORD *)(a1 + 808) != 3 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCVideoStream_ReportingVideoStreamEventWithVideoAttributesAndStreamID_cold_1();
      }
      v23 = (const void *)objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLong:", time(0));
      CFDictionaryAddValue(v10, CFSTR("Time"), v23);
      v24 = *(void **)(a1 + 280);
      if (v24)
      {
        v25 = CFStringCreateWithFormat(v8, 0, CFSTR("%s"), objc_msgSend((id)objc_msgSend(v24, "description"), "UTF8String"));
        CFDictionaryAddValue(v10, CFSTR("VCVSUUID"), v25);
        CFRelease(v25);
        v26 = CFStringCreateWithFormat(v8, 0, CFSTR("%@:%d"), objc_msgSend((id)objc_msgSend(v11, "localAddress"), "ip"), objc_msgSend((id)objc_msgSend(v11, "localAddress"), "port"));
        CFDictionaryAddValue(v10, CFSTR("VCVSLocalIPPort"), v26);
        CFRelease(v26);
        v27 = CFStringCreateWithFormat(v8, 0, CFSTR("%@:%d"), objc_msgSend((id)objc_msgSend(v11, "remoteAddress"), "ip"), objc_msgSend((id)objc_msgSend(v11, "remoteAddress"), "port"));
        CFDictionaryAddValue(v10, CFSTR("VCVSRemoteIPPort"), v27);
        CFRelease(v27);
      }
      v28 = *(void **)(a1 + 248);
      if (v28)
      {
        v29 = CFStringCreateWithFormat(v8, 0, CFSTR("%s"), objc_msgSend((id)objc_msgSend(v28, "description"), "UTF8String"));
        CFDictionaryAddValue(v10, CFSTR("VCVSIDSDestination"), v29);
        CFRelease(v29);
      }
      v30 = CFStringCreateWithFormat(v8, 0, CFSTR("%ld"), *(_QWORD *)(a1 + 616));
      CFDictionaryAddValue(v10, CFSTR("VCVSStreamToken"), v30);
      CFRelease(v30);
      CFDictionaryAddValue(v10, CFSTR("VCMSDirection"), (const void *)objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInteger:", objc_msgSend(v11, "direction")));
      alloc = v8;
      v31 = CFStringCreateWithFormat(v8, 0, CFSTR("%u"), objc_msgSend(v11, "isRateAdaptationEnabled"));
      CFDictionaryAddValue(v10, CFSTR("VCVSRateAdaptationEnabled"), v31);
      CFRelease(v31);
      v32 = (void *)MEMORY[0x1E0CB37E8];
      v50 = v11;
      objc_msgSend(v11, "rtcpSendInterval");
      CFDictionaryAddValue(v10, CFSTR("VCVSRtcpSendInterval"), (const void *)objc_msgSend(v32, "numberWithDouble:"));
      v33 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
      v57 = 0u;
      v58 = 0u;
      v59 = 0u;
      v60 = 0u;
      v34 = *(void **)(a1 + 544);
      v35 = objc_msgSend(v34, "countByEnumeratingWithState:objects:count:", &v57, v56, 16);
      if (v35)
      {
        v36 = v35;
        v37 = *(_QWORD *)v58;
        do
        {
          for (i = 0; i != v36; ++i)
          {
            if (*(_QWORD *)v58 != v37)
              objc_enumerationMutation(v34);
            v39 = *(void **)(*((_QWORD *)&v57 + 1) + 8 * i);
            if (objc_msgSend((id)objc_msgSend((id)objc_msgSend(v39, "streamConfig"), "multiwayConfig"), "repairedStreamID"))objc_msgSend(v33, "addObject:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedShort:", objc_msgSend((id)objc_msgSend((id)objc_msgSend(v39, "streamConfig"), "multiwayConfig"), "repairedStreamID")));
          }
          v36 = objc_msgSend(v34, "countByEnumeratingWithState:objects:count:", &v57, v56, 16);
        }
        while (v36);
      }
      if (objc_msgSend(v33, "count"))
      {
        v40 = CFStringCreateWithFormat(alloc, 0, CFSTR("%s"), objc_msgSend((id)objc_msgSend(v33, "componentsJoinedByString:", CFSTR(",")), "UTF8String"));
        CFDictionaryAddValue(v10, CFSTR("VCVSRepairIDs"), v40);
        CFRelease(v40);
      }

      v52 = 0u;
      v53 = 0u;
      v54 = 0u;
      v55 = 0u;
      v41 = (void *)objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)a1, "defaultStreamConfig"), "multiwayConfig"), "subStreamConfigs");
      v42 = objc_msgSend(v41, "countByEnumeratingWithState:objects:count:", &v52, v51, 16);
      if (v42)
      {
        v43 = v42;
        v44 = *(_QWORD *)v53;
        do
        {
          for (j = 0; j != v43; ++j)
          {
            if (*(_QWORD *)v53 != v44)
              objc_enumerationMutation(v41);
            v46 = *(void **)(*((_QWORD *)&v52 + 1) + 8 * j);
            v47 = objc_msgSend(v46, "keyFrameInterval");
            if (v47 == objc_msgSend(v46, "framerate"))
              CFDictionaryAddValue(v10, CFSTR("VCVSSubStreamIDs"), (const void *)objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedShort:", objc_msgSend(v46, "idsStreamID")));
          }
          v43 = objc_msgSend(v41, "countByEnumeratingWithState:objects:count:", &v52, v51, 16);
        }
        while (v43);
      }
      v48 = *(void **)(a1 + 576);
      if (v48)
      {
        CFDictionaryAddValue(v10, CFSTR("VCVSRemoteDeviceModel"), (const void *)objc_msgSend(v48, "deviceType"));
        CFDictionaryAddValue(v10, CFSTR("VCVSRemoteOSBuildVersion"), (const void *)objc_msgSend(*(id *)(a1 + 576), "osVersion"));
        CFDictionaryAddValue(v10, CFSTR("VCVSRemoteFrameworkVersion"), (const void *)objc_msgSend(*(id *)(a1 + 576), "frameworkVersion"));
      }
      CFDictionaryAddValue(v10, CFSTR("VCVSConfigHDRMode"), (const void *)objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", objc_msgSend(v50, "hdrMode")));
      _VCVideoStream_CollectVideoConfigMetrics((id *)a1, v10);
      goto LABEL_47;
    case 202:
      v15 = *(void **)(a1 + 280);
      if (v15)
      {
        v16 = CFStringCreateWithFormat(v8, 0, CFSTR("%s"), objc_msgSend((id)objc_msgSend(v15, "description"), "UTF8String"));
        CFDictionaryAddValue(v10, CFSTR("VCVSUUID"), v16);
        CFRelease(v16);
      }
      v17 = CFStringCreateWithFormat(v8, 0, CFSTR("%ld"), *(_QWORD *)(a1 + 616));
      CFDictionaryAddValue(v10, CFSTR("VCVSStreamToken"), v17);
      CFRelease(v17);
      v18 = objc_msgSend((id)a1, "endReason");
      v14 = (const void *)objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", v18);
      v13 = CFSTR("VCMSEndReason");
      goto LABEL_13;
    case 203:
    case 204:
    case 206:
    case 207:
    case 208:
    case 209:
    case 210:
      goto LABEL_47;
    case 205:
      _VCVideoStream_CollectVideoConfigMetrics((id *)a1, Mutable);
      goto LABEL_47;
    case 211:
      v19 = (void *)MEMORY[0x1E0CB37E8];
      objc_msgSend(a3, "ratio");
      CFDictionaryAddValue(v10, CFSTR("VCVSRxVideoWidth"), (const void *)objc_msgSend(v19, "numberWithDouble:"));
      v20 = (void *)MEMORY[0x1E0CB37E8];
      objc_msgSend(a3, "ratio");
      CFDictionaryAddValue(v10, CFSTR("VCVSRxVideoHeight"), (const void *)objc_msgSend(v20, "numberWithDouble:", v21));
      v14 = (const void *)objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", objc_msgSend(a3, "orientation"));
      v13 = CFSTR("VCVSRxVideoOrientation");
      goto LABEL_13;
    case 212:
      v14 = (const void *)objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLong:", time(0));
      v13 = CFSTR("Time");
LABEL_13:
      Mutable = v10;
      goto LABEL_14;
    default:
      if (a2 == 225)
      {
        v22 = CFStringCreateWithFormat(v8, 0, CFSTR("%d"), *(unsigned int *)(a1 + 824));
        CFDictionaryAddValue(v10, CFSTR("VCVSTMMB"), v22);
        CFRelease(v22);
      }
      else if (a2 == 230)
      {
        v13 = CFSTR("VCVSActiveStreamID");
        v14 = a4;
LABEL_14:
        CFDictionaryAddValue(Mutable, v13, v14);
      }
LABEL_47:
      reportingVideoStreamEvent();
      if (v10)
        CFRelease(v10);
      return;
  }
}

void _VCVideoStream_CollectVideoConfigMetrics(id *a1, __CFDictionary *a2)
{
  void *v4;
  int v5;
  void *v6;
  int64_t v7;
  int64_t v8;

  v4 = (void *)objc_msgSend(a1, "defaultStreamConfig");
  v5 = objc_msgSend(v4, "temporalScalingEnabled");
  v6 = v4;
  if (v5)
    v6 = (void *)objc_msgSend((id)objc_msgSend(a1[68], "lastObject"), "streamConfig");
  CFDictionaryAddValue(a2, CFSTR("VCVSConfigTxMaxBitrate"), (const void *)objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInteger:", objc_msgSend(v6, "txMaxBitrate")));
  CFDictionaryAddValue(a2, CFSTR("VCVSConfigTxMinBitrate"), (const void *)objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInteger:", objc_msgSend(v4, "txMinBitrate")));
  CFDictionaryAddValue(a2, CFSTR("VCVSConfigRxMaxBitrate"), (const void *)objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInteger:", objc_msgSend(v4, "rxMaxBitrate")));
  CFDictionaryAddValue(a2, CFSTR("VCVSConfigRxMinBitrate"), (const void *)objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInteger:", objc_msgSend(v4, "rxMinBitrate")));
  CFDictionaryAddValue(a2, CFSTR("VCVSKeyFrameInterval"), (const void *)objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInteger:", objc_msgSend(v4, "keyFrameInterval")));
  CFDictionaryAddValue(a2, CFSTR("VCVSRemoteVInitialOrientation"), (const void *)objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", objc_msgSend(v4, "remoteVideoInitialOrientation")));
  v7 = +[VCPayloadUtils codecTypeForPayload:](VCPayloadUtils, "codecTypeForPayload:", objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(v4, "txPayloadMap"), "allKeys"), "firstObject"), "integerValue"));
  CFDictionaryAddValue(a2, CFSTR("VCVSConfigTxCodecType"), (const void *)objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInteger:", v7));
  v8 = +[VCPayloadUtils codecTypeForPayload:](VCPayloadUtils, "codecTypeForPayload:", objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(v4, "rxPayloadMap"), "allKeys"), "firstObject"), "integerValue"));
  CFDictionaryAddValue(a2, CFSTR("VCVSConfigRxCodecType"), (const void *)objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInteger:", v8));
  CFDictionaryAddValue(a2, CFSTR("VCVSConfigTxFramerate"), (const void *)objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInteger:", objc_msgSend(v4, "framerate")));
  CFDictionaryAddValue(a2, CFSTR("VCVSConfigTxResolution"), (const void *)objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInteger:", objc_msgSend(v4, "videoResolution")));
  if (objc_msgSend(v4, "videoResolution") == 27)
  {
    CFDictionaryAddValue(a2, CFSTR("VCVSConfigWidth"), (const void *)objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInteger:", objc_msgSend(v4, "customWidth")));
    CFDictionaryAddValue(a2, CFSTR("VCVSConfigHeight"), (const void *)objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInteger:", objc_msgSend(v4, "customHeight")));
  }
  CFDictionaryAddValue(a2, CFSTR("VCVSConfigTransportProtocol"), (const void *)objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", objc_msgSend(v4, "transportProtocolType")));
  CFDictionaryAddValue(a2, CFSTR("VCVSConfigAccessNetworkType"), (const void *)objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", objc_msgSend((id)objc_msgSend(a1, "defaultStreamConfig"), "accessNetworkType")));
}

uint64_t VCVideoStream_OnVideoFrame(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  __int128 v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 896);
  v6 = *(_OWORD *)a3;
  v7 = *(_QWORD *)(a3 + 16);
  if (v4)
    VCVideoCaptureConverter_ProcessFrame(v4, a2, &v6, a4);
  else
    VCVideoStream_ProcessConvertedFrame(a1, a2, (uint64_t)&v6, a4);
  return 1;
}

uint64_t VCVideoStream_GetBaseQualityIndex(uint64_t a1)
{
  return *(unsigned int *)(a1 + 1136);
}

void VCVideoStream_SetExternalOutputVideoLatency(uint64_t a1, double a2)
{
  if (a1)
  {
    *(double *)(a1 + 1152) = a2;
    VCVideoReceiver_SetExternalOutputVideoLatency(*(_QWORD *)(a1 + 856));
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCVideoStream_SetExternalOutputVideoLatency_cold_1();
  }
}

void _VCMediaStream_SubmitStatisticsCollectorVideoStallUpdate(uint64_t a1, unint64_t a2, double a3, double a4)
{
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  _BYTE v7[32];
  __int128 v8;
  uint64_t v9;
  double v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 1000);
  if (v4)
  {
    *(_OWORD *)&v7[16] = 0u;
    v19 = 0;
    v17 = 0u;
    v18 = 0u;
    v15 = 0u;
    v16 = 0u;
    v13 = 0u;
    v14 = 0u;
    v11 = 0u;
    v8 = 0u;
    v9 = 0;
    *(double *)&v7[8] = a3;
    *(_QWORD *)v7 = 10;
    *(_DWORD *)&v7[24] = 8;
    v12 = a2;
    v10 = a4;
    AVCStatisticsCollector_SetVCStatistics(v4, (uint64_t)v7);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v5 = VRTraceErrorLogLevelToCSTR();
    v6 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v7 = 136315650;
      *(_QWORD *)&v7[4] = v5;
      *(_WORD *)&v7[12] = 2080;
      *(_QWORD *)&v7[14] = "_VCMediaStream_SubmitStatisticsCollectorVideoStallUpdate";
      *(_WORD *)&v7[22] = 1024;
      *(_DWORD *)&v7[24] = 1583;
      _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, "VCVideoStream [%s] %s:%d Statistics collector is nil", v7, 0x1Cu);
    }
  }
}

uint64_t VCMediaNegotiationBlobV2CodecFeaturesReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  int v15;
  char v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char v22;
  void *Data;
  uint64_t result;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        v14 = v9++ >= 9;
        if (v14)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      if ((v10 >> 3) == 2)
      {
        Data = (void *)PBReaderReadData();

        *(_QWORD *)(a1 + 16) = Data;
      }
      else if ((v10 >> 3) == 1)
      {
        v17 = 0;
        v18 = 0;
        v19 = 0;
        *(_BYTE *)(a1 + 24) |= 1u;
        while (1)
        {
          v20 = *v3;
          v21 = *(_QWORD *)(a2 + v20);
          if (v21 == -1 || v21 >= *(_QWORD *)(a2 + *v4))
            break;
          v22 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v21);
          *(_QWORD *)(a2 + v20) = v21 + 1;
          v19 |= (unint64_t)(v22 & 0x7F) << v17;
          if ((v22 & 0x80) == 0)
            goto LABEL_31;
          v17 += 7;
          v14 = v18++ >= 9;
          if (v14)
          {
            LODWORD(v19) = 0;
            goto LABEL_33;
          }
        }
        *(_BYTE *)(a2 + *v5) = 1;
LABEL_31:
        if (*(_BYTE *)(a2 + *v5))
          LODWORD(v19) = 0;
LABEL_33:
        *(_DWORD *)(a1 + 8) = v19;
      }
      else
      {
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
      }
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void sub_1D8F2F074(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1D8F2F400(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1D8F2F718(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1D8F2F94C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

double VCMediaStreamGroup_ExternalRenderLatency(uint64_t a1)
{
  double v1;

  if (a1)
    return *(double *)(a1 + 400);
  v1 = 0.0;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCMediaStreamGroup_ExternalRenderLatency_cold_1();
  }
  return v1;
}

uint64_t OUTLINED_FUNCTION_10_16@<X0>(void *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  *(_QWORD *)(v2 - 24) = a2;
  return objc_msgSend(a1, "streamToken");
}

void VCNACKGenerator_GetStatistics(uint64_t a1, __CFDictionary *a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  float v17;
  float v18;
  float v19;
  uint64_t v21;
  unint64_t v26;
  double v27;
  double v28;
  uint64_t v29;
  uint64_t v30;
  double v31;
  int v32;
  double v33;
  uint64_t v36;
  unsigned int v38;
  uint64_t v40;
  unsigned int v41;
  CFNumberRef v43;
  CFNumberRef v44;
  CFNumberRef v45;
  CFNumberRef v46;
  float v47;
  float v48;
  CFNumberRef v49;
  CFNumberRef v50;
  CFNumberRef v51;
  CFNumberRef v52;
  CFNumberRef v53;
  CFNumberRef v54;
  double v55;
  double v56;
  double v57;
  double v58;
  double v59;
  double v60;
  double v61;
  double v62;
  CFNumberRef v63;
  double v64;
  CFNumberRef v65;
  CFNumberRef v66;
  CFNumberRef v67;
  uint64_t v68;
  NSObject *v69;
  const char *CStringPtr;
  char *v71;
  float v72;
  float v73;
  uint64_t v74;
  uint64_t v75;
  const __CFAllocator *allocator;
  double v77;
  double v78;
  int valuePtr;
  uint64_t v80;
  __int16 v81;
  const char *v82;
  __int16 v83;
  int v84;
  __int16 v85;
  uint64_t v86;
  __int16 v87;
  const char *v88;
  __int16 v89;
  char *v90;
  __int16 v91;
  unint64_t v92;
  __int16 v93;
  uint64_t v94;
  __int16 v95;
  uint64_t v96;
  __int16 v97;
  uint64_t v98;
  __int16 v99;
  double v100;
  __int16 v101;
  double v102;
  __int16 v103;
  double v104;
  __int16 v105;
  double v106;
  __int16 v107;
  unsigned int v108;
  __int16 v109;
  unsigned int v110;
  __int16 v111;
  double v112;
  __int16 v113;
  double v114;
  __int16 v115;
  uint64_t v116;
  uint64_t v117;

  v117 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v4 = 0;
    v5 = 0;
    v6 = 0;
    v7 = 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = 0.0;
    v75 = a1 + 305200;
    v14 = 14324;
    v15 = 4672;
    v16 = 64;
    v17 = 0.0;
    v18 = 0.0;
    v19 = 0.0;
    do
    {
      _X4 = a1 + v4;
      v21 = a1 + v15;
      __asm { PRFM            #0, [X4,#0x4A20] }
      v26 = *(_QWORD *)(a1 + v4 + 4680);
      v27 = *(double *)(a1 + v15 + 48);
      v28 = v18;
      if (v26)
      {
        if (v27 / (double)v26 >= v28)
          v28 = v27 / (double)v26;
      }
      else if (v18 <= 0.0)
      {
        v28 = 0.0;
      }
      v29 = *(_QWORD *)(_X4 + 4688);
      v30 = *(_QWORD *)(_X4 + 4696);
      v31 = *(double *)(_X4 + 4728);
      v32 = *(_DWORD *)(_X4 + 4704);
      v33 = v19;
      if (v26 == v29)
      {
        if (v19 <= 0.0)
          v33 = 0.0;
      }
      else if (v31 / (double)(v26 - v29) >= v33)
      {
        v33 = v31 / (double)(v26 - v29);
      }
      _X6 = _X4 + 19040;
      _X5 = a1 + v14;
      v36 = a1 + v4;
      __asm { PRFM            #0, [X5] }
      v38 = *(unsigned __int16 *)(a1 + v4 + 20);
      __asm { PRFM            #0, [X6] }
      v40 = *(_QWORD *)(a1 + v4 + 4736);
      if (v40)
      {
        v41 = *(unsigned __int16 *)(v36 + 4752);
        if ((unsigned __int16)(v38 - v41) < 0x7FFFu && v38 < v41)
          v41 |= 0xFFFF0000;
        v9 = v9 + v38 - v41 + 1;
        v10 += v40;
        v11 += *(_DWORD *)(v36 + 4744);
      }
      v5 += *(_QWORD *)v21;
      v6 += v26;
      v7 += v29;
      v8 += v30;
      v13 = v27 + v13;
      v17 = v31 + v17;
      v12 += v32;
      v18 = v28;
      *(_DWORD *)(v21 + 32) = 0;
      v19 = v33;
      *(_OWORD *)v21 = 0uLL;
      *(_OWORD *)(v21 + 16) = 0uLL;
      *(_OWORD *)(a1 + v15 + 48) = 0uLL;
      *(_OWORD *)(a1 + v15 + 64) = 0uLL;
      *(_WORD *)(v36 + 4752) = v38;
      v4 += 4768;
      v14 += 4768;
      v15 += 4768;
      --v16;
    }
    while (v16);
    *(float *)(v75 + 352) = v18;
    *(float *)(v75 + 356) = v19;
    if (v10)
    {
      valuePtr = v8;
      allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v43 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &valuePtr);
      CFDictionaryAddValue(a2, CFSTR("UniqueNacksSent"), v43);
      CFRelease(v43);
      valuePtr = v5;
      v44 = CFNumberCreate(allocator, kCFNumberIntType, &valuePtr);
      CFDictionaryAddValue(a2, CFSTR("NacksSent"), v44);
      CFRelease(v44);
      valuePtr = v6;
      v45 = CFNumberCreate(allocator, kCFNumberIntType, &valuePtr);
      CFDictionaryAddValue(a2, CFSTR("NacksFulfilled"), v45);
      CFRelease(v45);
      valuePtr = v7;
      v46 = CFNumberCreate(allocator, kCFNumberIntType, &valuePtr);
      CFDictionaryAddValue(a2, CFSTR("NacksFulfilledOnTime"), v46);
      CFRelease(v46);
      v47 = 0.0;
      v48 = 0.0;
      if (v5)
        v48 = v13 / (float)v5;
      valuePtr = LODWORD(v48);
      v49 = CFNumberCreate(allocator, kCFNumberFloat32Type, &valuePtr);
      CFDictionaryAddValue(a2, CFSTR("NacksAvgResponseTime"), v49);
      CFRelease(v49);
      valuePtr = *(_DWORD *)(v75 + 352);
      v50 = CFNumberCreate(allocator, kCFNumberFloat32Type, &valuePtr);
      CFDictionaryAddValue(a2, CFSTR("NacksMaxResponseTime"), v50);
      CFRelease(v50);
      if (v6 != v7)
        v47 = v17 / (float)(unint64_t)(v6 - v7);
      valuePtr = LODWORD(v47);
      v51 = CFNumberCreate(allocator, kCFNumberFloat32Type, &valuePtr);
      CFDictionaryAddValue(a2, CFSTR("NacksLateTime"), v51);
      CFRelease(v51);
      valuePtr = *(_DWORD *)(v75 + 356);
      v52 = CFNumberCreate(allocator, kCFNumberFloat32Type, &valuePtr);
      CFDictionaryAddValue(a2, CFSTR("NacksMaxLateTime"), v52);
      CFRelease(v52);
      v77 = 0.0;
      v78 = 0.0;
      if ((_VCNACKGenerator_GetBitrate(a1, &v78, &v77, (float)*(unsigned int *)(v75 + 388)) & 0x80000000) == 0)
      {
        valuePtr = (v78 / 1000.0 + 0.5);
        v53 = CFNumberCreate(allocator, kCFNumberIntType, &valuePtr);
        CFDictionaryAddValue(a2, CFSTR("NacksMediaBitRate"), v53);
        CFRelease(v53);
        valuePtr = (v77 / 1000.0 + 0.5);
        v54 = CFNumberCreate(allocator, kCFNumberIntType, &valuePtr);
        CFDictionaryAddValue(a2, CFSTR("NacksRTXMediaBitRate"), v54);
        CFRelease(v54);
      }
      v55 = (double)v9;
      v56 = 1.0 - (double)v10 / (double)v9;
      if (v56 < 0.0)
        v56 = 0.0;
      v57 = 1.0 - (double)(v10 + v11) / v55;
      if (v57 < 0.0)
        v57 = 0.0;
      v58 = (double)v12 / v55;
      if (v9)
        v59 = v57;
      else
        v59 = 0.0;
      if (v9)
        v60 = v56;
      else
        v60 = 0.0;
      if (v9)
        v61 = v58;
      else
        v61 = 0.0;
      *(double *)(v75 + 272) = v61;
      *(double *)(v75 + 248) = v60;
      v62 = v60 * 10000.0;
      if (v60 >= 1.0)
        v62 = 10000.0;
      valuePtr = (int)v62;
      v63 = CFNumberCreate(allocator, kCFNumberIntType, &valuePtr);
      CFDictionaryAddValue(a2, CFSTR("NacksPLRWithoutRTX"), v63);
      CFRelease(v63);
      v64 = v59 * 10000.0;
      if (v59 >= 1.0)
        v64 = 10000.0;
      valuePtr = (int)v64;
      v65 = CFNumberCreate(allocator, kCFNumberIntType, &valuePtr);
      CFDictionaryAddValue(a2, CFSTR("NacksPLRWithRTX"), v65);
      CFRelease(v65);
      valuePtr = (int)(*(double *)(v75 + 256) * 100.0);
      v66 = CFNumberCreate(allocator, kCFNumberIntType, &valuePtr);
      CFDictionaryAddValue(a2, CFSTR("NacksThrottleFactor"), v66);
      CFRelease(v66);
      valuePtr = (int)(*(double *)(v75 + 272) * 10000.0);
      v67 = CFNumberCreate(allocator, kCFNumberIntType, &valuePtr);
      CFDictionaryAddValue(a2, CFSTR("OutOfOrderRTX"), v67);
      CFRelease(v67);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
      {
        v68 = VRTraceErrorLogLevelToCSTR();
        v69 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          CStringPtr = CFStringGetCStringPtr(*(CFStringRef *)(v75 + 368), 0x8000100u);
          v71 = FourccToCStr(*(_DWORD *)(v75 + 376));
          v72 = *(float *)(v75 + 352);
          v73 = *(float *)(v75 + 356);
          v74 = *(_QWORD *)v75;
          valuePtr = 136319746;
          v80 = v68;
          v81 = 2080;
          v82 = "VCNACKGenerator_GetStatistics";
          v83 = 1024;
          v84 = 298;
          v85 = 2048;
          v86 = a1;
          v87 = 2080;
          v88 = CStringPtr;
          v89 = 2080;
          v90 = v71;
          v91 = 2048;
          v92 = v5;
          v93 = 2048;
          v94 = v8;
          v95 = 2048;
          v96 = v6;
          v97 = 2048;
          v98 = v7;
          v99 = 2048;
          v100 = v48;
          v101 = 2048;
          v102 = v72;
          v103 = 2048;
          v104 = v47;
          v105 = 2048;
          v106 = v73;
          v107 = 1024;
          v108 = (v78 / 1000.0 + 0.5);
          v109 = 1024;
          v110 = (v77 / 1000.0 + 0.5);
          v111 = 2048;
          v112 = v60 * 100.0;
          v113 = 2048;
          v114 = v59 * 100.0;
          v115 = 2048;
          v116 = v74;
          _os_log_impl(&dword_1D8A54000, v69, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d @=@ Health: VCNACKGenerator [%p] NACK health report participantID=%s streamGroupId=%s packetsNACKed=%lld uniquePacketsNACKed=%lld packetsFulfilled=%lld packetsFulfilledOnTime=%lld averageResponseTime=%2.4fs maxAvgResponseTime=%2.4fs averageLateTime=%2.4fs maxAvgLateTime=%2.4fs mediaBitRate=%ukbps retransmittedMediaBitRate=%ukbps plrWithoutRTX=%3.2f%% plrWithRTX=%3.2f%% rtt=%2.3fs", (uint8_t *)&valuePtr, 0xB4u);
        }
      }
    }
  }
}

