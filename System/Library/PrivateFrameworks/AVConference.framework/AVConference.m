void __Block_byref_object_dispose_(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__0(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__1(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__2(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__3(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__4(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__5(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__6(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__7(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__8(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__9(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__10(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__11(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__12(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__13(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__14(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__15(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__16(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__17(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__18(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__19(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__20(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__21(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__22(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__23(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__24(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__25(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__26(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__27(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__28(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__29(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__30(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__31(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__32(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__33(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__34(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__35(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__36(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__37(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__38(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__39(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__40(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__41(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_copy_(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__0(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__1(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__2(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__3(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__4(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__5(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__6(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__7(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__8(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__9(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__10(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__11(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__12(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__13(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__14(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__15(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__16(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__17(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__18(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__19(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__20(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__21(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__22(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__23(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__24(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__25(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__26(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__27(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__28(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__29(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__30(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__31(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__32(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__33(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__34(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__35(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__36(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__37(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__38(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__39(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__40(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__41(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

BOOL VCMU_CompareWithAccuracy(float a1, float a2, double a3)
{
  return vabds_f32(a1, a2) < a3;
}

void sub_1D8A59488(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id obj, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36)
{
  uint64_t v36;

  _Block_object_dispose(&a36, 8);
  _Block_object_dispose((const void *)(v36 - 176), 8);
  _Unwind_Resume(a1);
}

void sub_1D8A59740(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t _VCAllocatorMultiQueueCallback_Retain(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = (unsigned int *)(result + 8);
  do
    v2 = __ldxr(v1);
  while (__stxr(v2 + 1, v1));
  return result;
}

void sub_1D8A5B380(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1D8A5B57C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1D8A5B78C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t VCDispatchQueue_GetCustomRootQueue(uint64_t a1)
{
  return objc_msgSend(+[VCDispatchQueue defaultManager](VCDispatchQueue, "defaultManager"), "getCustomRootQueueWithPriority:isFixedPriority:", a1, 1);
}

void sub_1D8A5D2BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1D8A5DA44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t VCCameraStatusBitsFromVideoAttributes(void *a1)
{
  char v2;
  int v3;
  char v4;
  char v5;
  char v6;
  char v7;

  v2 = objc_msgSend(a1, "orientation");
  v3 = objc_msgSend(a1, "cameraSwitching");
  v4 = objc_msgSend(a1, "camera");
  if (objc_msgSend(a1, "videoSourceScreen"))
    v5 = 16;
  else
    v5 = 0;
  if (objc_msgSend(a1, "videoMirrored"))
    v6 = 4;
  else
    v6 = 0;
  if (v3)
    v7 = -64;
  else
    v7 = 0x80;
  return v7 & 0xF4 | v2 & 3 | v5 & 0xF7u | (8 * (v4 & 1)) | v6;
}

void _VCVideoCaptureServer_ProcessPreviewSampleBuffer(uint64_t a1, CMSampleBufferRef sbuf, uint64_t a3, int a4, uint64_t a5)
{
  __CVBuffer *ImageBuffer;
  unsigned int *v9;
  uint64_t v10;
  NSObject *v11;
  unsigned int v12;
  NSObject *v13;
  unsigned int v14;
  int Width;
  int Height;
  double v17;
  double v18;
  _BYTE *v19;
  VTSessionRef *v20;
  CFAllocatorRef *v21;
  id v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  id v27;
  const __CFDictionary *v28;
  uint64_t v29;
  NSObject *v30;
  int v31;
  int v32;
  OpaqueVTPixelTransferSession *v33;
  const void *v34;
  __CVPixelBufferPool *v35;
  uint64_t v36;
  const char *v37;
  uint64_t v38;
  int ErrorLogLevelForModule;
  uint64_t v40;
  NSObject *v41;
  NSObject *v42;
  OpaqueCMClock *HostTimeClock;
  double v44;
  double v45;
  uint64_t v46;
  NSObject *v47;
  int v48;
  double v49;
  _BOOL4 v50;
  uint64_t v51;
  NSObject *v52;
  double v53;
  FILE *v54;
  double v55;
  double v56;
  __int128 v57;
  char *Timestamp;
  uint64_t v59;
  uint64_t v60;
  int v61;
  uint64_t v62;
  NSObject *v63;
  NSObject *v64;
  uint64_t v65;
  NSObject *v66;
  id v67;
  void *v68;
  NSObject *v69;
  int v70;
  int v71;
  double v72;
  int v73;
  double v74;
  int v75;
  uint64_t v76;
  NSObject *v77;
  VideoAttributes *v78;
  double v79;
  double v80;
  double v81;
  double v82;
  double v83;
  double v84;
  double v85;
  VideoAttributes *v86;
  uint64_t v87;
  int v88;
  uint64_t v89;
  NSObject *v90;
  NSObject *v91;
  uint64_t v92;
  NSObject *v93;
  NSObject *v94;
  NSObject *v95;
  id v96;
  void *v97;
  NSObject *v98;
  uint64_t v99;
  NSObject *v100;
  void *v101;
  const char *v102;
  uint64_t v103;
  NSObject *v104;
  __CVBuffer *texture;
  _BYTE buf[48];
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  CMTime v112;
  int v113;
  __int16 v114;
  const char *v115;
  uint64_t v116;

  v116 = *MEMORY[0x1E0C80C00];
  ++*(_DWORD *)(a1 + 44);
  ImageBuffer = CMSampleBufferGetImageBuffer(sbuf);
  v9 = (unsigned int *)(a1 + 112);
  if (*(int *)(a1 + 112) >= 1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v10 = VRTraceErrorLogLevelToCSTR();
      v11 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v12 = *v9;
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = v10;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VCVideoCaptureServer_ProcessPreviewSampleBuffer";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 1691;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v12;
        _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, "VCVideoCaptureServer [%s] %s:%d snapshotRequestCount=%d", buf, 0x22u);
      }
    }
    CVPixelBufferRetain(ImageBuffer);
    v13 = *(NSObject **)(a1 + 312);
    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
    *(_QWORD *)&buf[8] = 3221225472;
    *(_QWORD *)&buf[16] = ___VCVideoCaptureServer_SendSnapshotFromFrame_block_invoke;
    *(_QWORD *)&buf[24] = &unk_1E9E52960;
    *(_QWORD *)&buf[32] = a1;
    *(_QWORD *)&buf[40] = ImageBuffer;
    dispatch_async(v13, buf);
    do
      v14 = __ldaxr(v9);
    while (__stlxr(v14 - 1, v9));
  }
  texture = CVPixelBufferRetain(ImageBuffer);
  Width = CVPixelBufferGetWidth(ImageBuffer);
  Height = CVPixelBufferGetHeight(ImageBuffer);
  objc_msgSend(*(id *)(a1 + 152), "ratio");
  if (v17 == 768.0)
  {
    objc_msgSend(*(id *)(a1 + 152), "ratio");
    if (v18 == 1024.0 && Width == 720 && Height == 1280)
    {
      v19 = (_BYTE *)(a1 + 376);
LABEL_24:
      *v19 = 0;
LABEL_25:
      v33 = *(OpaqueVTPixelTransferSession **)(a1 + 360);
      if (v33)
      {
        VTPixelTransferSessionInvalidate(v33);
        v34 = *(const void **)(a1 + 360);
        if (v34)
        {
          CFRelease(v34);
          *(_QWORD *)(a1 + 360) = 0;
        }
      }
      v35 = *(__CVPixelBufferPool **)(a1 + 368);
      if (v35)
      {
        CVPixelBufferPoolRelease(v35);
        *(_QWORD *)(a1 + 368) = 0;
      }
      goto LABEL_30;
    }
  }
  v19 = (_BYTE *)(a1 + 376);
  if (Width < 720 || Height < 1024)
    goto LABEL_24;
  if (!*v19)
    goto LABEL_25;
  v20 = (VTSessionRef *)(a1 + 360);
  if (!*(_QWORD *)(a1 + 360))
  {
    VTPixelTransferSessionCreate(0, (VTPixelTransferSessionRef *)(a1 + 360));
    VTSessionSetProperty(*v20, (CFStringRef)*MEMORY[0x1E0CED848], (CFTypeRef)*MEMORY[0x1E0CEDB48]);
  }
  v21 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  if (!*(_QWORD *)(a1 + 368))
  {
    v22 = objc_alloc(MEMORY[0x1E0C99D80]);
    v23 = (void *)objc_msgSend(v22, "initWithObjectsAndKeys:", MEMORY[0x1E0C9AAB0], *MEMORY[0x1E0CBC018], CFSTR("AVConference:CaptureServer"), *MEMORY[0x1E0CBC048], 0);
    v24 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB37E8]), "initWithInt:", 576);
    v25 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB37E8]), "initWithInt:", 1024);
    v26 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB37E8]), "initWithUnsignedInt:", *(unsigned int *)(a1 + 40));
    v27 = objc_alloc(MEMORY[0x1E0C99D80]);
    v28 = (const __CFDictionary *)objc_msgSend(v27, "initWithObjectsAndKeys:", v24, *MEMORY[0x1E0CA90E0], v25, *MEMORY[0x1E0CA8FD8], v26, *MEMORY[0x1E0CA9040], v23, *MEMORY[0x1E0CA8FF0], 0);
    CVPixelBufferPoolCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v28, (CVPixelBufferPoolRef *)(a1 + 368));

    v21 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
    v20 = (VTSessionRef *)(a1 + 360);
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v29 = VRTraceErrorLogLevelToCSTR();
    v30 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v31 = CVPixelBufferGetWidth(ImageBuffer);
      v32 = CVPixelBufferGetHeight(ImageBuffer);
      *(_DWORD *)buf = 136316162;
      *(_QWORD *)&buf[4] = v29;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "_VCVideoCaptureServer_CreateResizedFrame";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 2134;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = v31;
      *(_WORD *)&buf[34] = 1024;
      *(_DWORD *)&buf[36] = v32;
      _os_log_impl(&dword_1D8A54000, v30, OS_LOG_TYPE_DEFAULT, "VCVideoCaptureServer [%s] %s:%d Frame Transform resize, preview frame from %dx%d to 576x1024", buf, 0x28u);
    }
  }
  *(_QWORD *)buf = 0;
  CVPixelBufferPoolCreatePixelBuffer(*v21, *(CVPixelBufferPoolRef *)(a1 + 368), (CVPixelBufferRef *)buf);
  if (*(_QWORD *)buf)
  {
    VTPixelTransferSessionTransferImage((VTPixelTransferSessionRef)*v20, ImageBuffer, *(CVPixelBufferRef *)buf);
    CVPixelBufferRelease(ImageBuffer);
    texture = *(__CVBuffer **)buf;
  }
LABEL_30:
  v36 = 416;
  if (a4)
  {
    v37 = "back";
  }
  else
  {
    v36 = 408;
    v37 = "front";
  }
  v38 = *(_QWORD *)(a1 + v36);
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (v38)
  {
    if (ErrorLogLevelForModule >= 8)
    {
      v40 = VRTraceErrorLogLevelToCSTR();
      v41 = *MEMORY[0x1E0CF2758];
      v42 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316162;
          *(_QWORD *)&buf[4] = v40;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VCVideoCaptureServer_EnqueueFrameToQueueFront";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 1535;
          *(_WORD *)&buf[28] = 2080;
          *(_QWORD *)&buf[30] = v37;
          *(_WORD *)&buf[38] = 2048;
          *(_QWORD *)&buf[40] = v38;
          _os_log_impl(&dword_1D8A54000, v41, OS_LOG_TYPE_DEFAULT, "VCVideoCaptureServer [%s] %s:%d FigImageQueueEnqueueImage [local] %sCameraQueue, imgQ %p", buf, 0x30u);
        }
      }
      else if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)&buf[4] = v40;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VCVideoCaptureServer_EnqueueFrameToQueueFront";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 1535;
        *(_WORD *)&buf[28] = 2080;
        *(_QWORD *)&buf[30] = v37;
        *(_WORD *)&buf[38] = 2048;
        *(_QWORD *)&buf[40] = v38;
        _os_log_debug_impl(&dword_1D8A54000, v41, OS_LOG_TYPE_DEBUG, "VCVideoCaptureServer [%s] %s:%d FigImageQueueEnqueueImage [local] %sCameraQueue, imgQ %p", buf, 0x30u);
      }
    }
    memset(&v112, 170, sizeof(v112));
    HostTimeClock = CMClockGetHostTimeClock();
    CMClockGetTime(&v112, HostTimeClock);
    *(CMTime *)buf = v112;
    v44 = CMTimeGetSeconds((CMTime *)buf) - *(double *)(a1 + 624);
    v45 = floor(1.0 / (double)*(int *)(a1 + 16) / 0.2) * 0.2 + 0.2;
    if (v44 > v45 && (int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v46 = VRTraceErrorLogLevelToCSTR();
      v47 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)&buf[4] = v46;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VCVideoCaptureServer_EnqueueFrameToQueueFront";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 1546;
        *(_WORD *)&buf[28] = 2048;
        *(double *)&buf[30] = v45;
        *(_WORD *)&buf[38] = 2048;
        *(double *)&buf[40] = v44;
        _os_log_impl(&dword_1D8A54000, v47, OS_LOG_TYPE_DEFAULT, "VCVideoCaptureServer [%s] %s:%d Unexpected capture frame duration expectedFrameDurationWithThreshold=%f and currentFrameDuration=%f", buf, 0x30u);
      }
    }
    if (*(_BYTE *)(a1 + 714) != ((a5 >> 2) & 1))
    {
      VCImageQueue_EffectsEnabledForPreview(v38, (a5 & 4) != 0);
      *(_BYTE *)(a1 + 714) = (a5 & 4) != 0;
    }
    *(CMTime *)buf = v112;
    v48 = VCImageQueue_EnqueueFrame(v38, texture, (CMTime *)buf);
    v49 = micro();
    if (v48)
    {
      v50 = 0;
      *(_QWORD *)(a1 + 400) = 0;
    }
    else
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v51 = VRTraceErrorLogLevelToCSTR();
        v52 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316162;
          *(_QWORD *)&buf[4] = v51;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VCVideoCaptureServer_EnqueueFrameToQueueFront";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 1559;
          *(_WORD *)&buf[28] = 2080;
          *(_QWORD *)&buf[30] = v37;
          *(_WORD *)&buf[38] = 2048;
          *(_QWORD *)&buf[40] = v38;
          _os_log_impl(&dword_1D8A54000, v52, OS_LOG_TYPE_DEFAULT, "VCVideoCaptureServer [%s] %s:%d FigImageQueueEnqueueImage skipped [local -%s], imgQ %p!", buf, 0x30u);
        }
      }
      v53 = *(double *)(a1 + 400);
      if (v53 == 0.0)
      {
        *(double *)(a1 + 400) = v49;
        v53 = v49;
      }
      v50 = v49 - v53 >= 10.0;
    }
    if (*(_BYTE *)(a1 + 696))
    {
      *(CMTime *)buf = v112;
      *(Float64 *)(a1 + 656) = CMTimeGetSeconds((CMTime *)buf);
      *(double *)(a1 + 688) = v49;
      v54 = *(FILE **)(a1 + 632);
      v55 = *(double *)(a1 + 704);
      v56 = *(double *)(a1 + 624);
      *(_QWORD *)&v57 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v57 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v110 = v57;
      v111 = v57;
      v108 = v57;
      v109 = v57;
      *(_OWORD *)&buf[32] = v57;
      v107 = v57;
      *(_OWORD *)buf = v57;
      *(_OWORD *)&buf[16] = v57;
      Timestamp = VRLogfileGetTimestamp(buf, 0x80u);
      fprintf(v54, "%s\t%d\t%d\t%d\t%f\t%f\t%f\t%f\t%f\t%f\t%f\n", Timestamp, *(_DWORD *)(a1 + 640), *(_DWORD *)(a1 + 644), *(unsigned __int8 *)(a1 + 648), *(double *)(a1 + 664), *(double *)(a1 + 672), *(double *)(a1 + 680), *(double *)(a1 + 656), *(double *)(a1 + 656) - v56, *(double *)(a1 + 688), *(double *)(a1 + 688) - v55);
      *(_QWORD *)(a1 + 704) = *(_QWORD *)(a1 + 688);
    }
    *(CMTime *)buf = v112;
    *(Float64 *)(a1 + 624) = CMTimeGetSeconds((CMTime *)buf);
    if (v50)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCVideoCaptureServer_ProcessPreviewSampleBuffer_cold_3();
      }
      objc_msgSend((id)a1, "stopPreview");
      if ((v48 & 1) == 0)
        goto LABEL_109;
    }
    else if (!v48)
    {
      goto LABEL_109;
    }
    if (!*(_BYTE *)(a1 + 108))
    {
      v59 = objc_msgSend(*(id *)(a1 + 96), "deviceNameForToken:", *(unsigned int *)(a1 + 104));
      v60 = *(_QWORD *)(a1 + 384);
      v61 = VRTraceGetErrorLogLevelForModule();
      if (v60)
      {
        if (v61 >= 7)
        {
          v62 = VRTraceErrorLogLevelToCSTR();
          v63 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = v62;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VCVideoCaptureServer_DidReceiveFirstPreviewFrame";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 1721;
            _os_log_impl(&dword_1D8A54000, v63, OS_LOG_TYPE_DEFAULT, "VCVideoCaptureServer [%s] %s:%d notifying app of first preview frame", buf, 0x1Cu);
          }
        }
        v64 = *(NSObject **)(a1 + 296);
        *(_QWORD *)buf = MEMORY[0x1E0C809B0];
        *(_QWORD *)&buf[8] = 3221225472;
        *(_QWORD *)&buf[16] = ___VCVideoCaptureServer_DidReceiveFirstPreviewFrame_block_invoke;
        *(_QWORD *)&buf[24] = &unk_1E9E52238;
        *(_QWORD *)&buf[32] = a1;
        *(_QWORD *)&buf[40] = v59;
        dispatch_async(v64, buf);
      }
      else
      {
        if (v61 >= 7)
        {
          v65 = VRTraceErrorLogLevelToCSTR();
          v66 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = v65;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VCVideoCaptureServer_DidReceiveFirstPreviewFrame";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 1728;
            _os_log_impl(&dword_1D8A54000, v66, OS_LOG_TYPE_DEFAULT, "VCVideoCaptureServer [%s] %s:%d notifying clients of first preview frame", buf, 0x1Cu);
          }
        }
        v67 = objc_alloc_init(MEMORY[0x1E0C99E08]);
        v68 = v67;
        if (v59)
        {
          objc_msgSend(v67, "setObject:forKeyedSubscript:", v59, CFSTR("localCameraUIDString"));
        }
        else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VCVideoCaptureServer_ProcessPreviewSampleBuffer_cold_2();
        }
        v69 = *(NSObject **)(a1 + 296);
        *(_QWORD *)buf = MEMORY[0x1E0C809B0];
        *(_QWORD *)&buf[8] = 3221225472;
        *(_QWORD *)&buf[16] = ___VCVideoCaptureServer_DidReceiveFirstPreviewFrame_block_invoke_716;
        *(_QWORD *)&buf[24] = &unk_1E9E521C0;
        *(_QWORD *)&buf[32] = v68;
        dispatch_async(v69, buf);

      }
      *(_BYTE *)(a1 + 108) = 1;
    }
    v70 = CVPixelBufferGetWidth(ImageBuffer);
    v71 = CVPixelBufferGetHeight(ImageBuffer);
    objc_msgSend(*(id *)(a1 + 152), "ratio");
    v73 = (int)v72;
    objc_msgSend(*(id *)(a1 + 152), "ratio");
    v75 = (int)v74;
    if (v70 != v73 || v71 != v75)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v76 = VRTraceErrorLogLevelToCSTR();
        v77 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316674;
          *(_QWORD *)&buf[4] = v76;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VCVideoCaptureServer_ProcessFrameSizeChange";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 1751;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = v73;
          *(_WORD *)&buf[34] = 1024;
          *(_DWORD *)&buf[36] = v75;
          *(_WORD *)&buf[40] = 1024;
          *(_DWORD *)&buf[42] = v70;
          *(_WORD *)&buf[46] = 1024;
          LODWORD(v107) = v71;
          _os_log_impl(&dword_1D8A54000, v77, OS_LOG_TYPE_DEFAULT, "VCVideoCaptureServer [%s] %s:%d frame size changed from %dx%d to %dx%d", buf, 0x34u);
        }
      }
      v78 = [VideoAttributes alloc];
      v79 = (double)v70;
      v80 = (double)v71;
      objc_msgSend(*(id *)(a1 + 152), "contentsRect");
      LODWORD(v81) = 1.0;
      v86 = -[VideoAttributes initWithCameraStatusBits:aspectRatio:contentsRect:scaleFactor:](v78, "initWithCameraStatusBits:aspectRatio:contentsRect:scaleFactor:", a5, (double)v70, (double)v71, v82, v83, v84, v85, v81);
      if ((objc_msgSend((id)a1, "shouldSendVideoAttributeCallback:", v86) & 1) != 0)
      {
        v87 = *(_QWORD *)(a1 + 384);
        v88 = VRTraceGetErrorLogLevelForModule();
        if (v87)
        {
          if (v88 >= 8)
          {
            v89 = VRTraceErrorLogLevelToCSTR();
            v90 = *MEMORY[0x1E0CF2758];
            v91 = *MEMORY[0x1E0CF2758];
            if (*MEMORY[0x1E0CF2748])
            {
              if (os_log_type_enabled(v91, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136316674;
                *(_QWORD *)&buf[4] = v89;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "_VCVideoCaptureServer_ProcessFrameSizeChange";
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&buf[24] = 1762;
                *(_WORD *)&buf[28] = 1024;
                *(_DWORD *)&buf[30] = v73;
                *(_WORD *)&buf[34] = 1024;
                *(_DWORD *)&buf[36] = v75;
                *(_WORD *)&buf[40] = 1024;
                *(_DWORD *)&buf[42] = v70;
                *(_WORD *)&buf[46] = 1024;
                LODWORD(v107) = v71;
                _os_log_impl(&dword_1D8A54000, v90, OS_LOG_TYPE_DEFAULT, "VCVideoCaptureServer [%s] %s:%d notifying app of frame size change from %dx%d to %dx%d", buf, 0x34u);
              }
            }
            else if (os_log_type_enabled(v91, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136316674;
              *(_QWORD *)&buf[4] = v89;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_VCVideoCaptureServer_ProcessFrameSizeChange";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 1762;
              *(_WORD *)&buf[28] = 1024;
              *(_DWORD *)&buf[30] = v73;
              *(_WORD *)&buf[34] = 1024;
              *(_DWORD *)&buf[36] = v75;
              *(_WORD *)&buf[40] = 1024;
              *(_DWORD *)&buf[42] = v70;
              *(_WORD *)&buf[46] = 1024;
              LODWORD(v107) = v71;
              _os_log_debug_impl(&dword_1D8A54000, v90, OS_LOG_TYPE_DEBUG, "VCVideoCaptureServer [%s] %s:%d notifying app of frame size change from %dx%d to %dx%d", buf, 0x34u);
            }
          }
          v95 = *(NSObject **)(a1 + 296);
          *(_QWORD *)buf = MEMORY[0x1E0C809B0];
          *(_QWORD *)&buf[8] = 3221225472;
          *(_QWORD *)&buf[16] = ___VCVideoCaptureServer_ProcessFrameSizeChange_block_invoke;
          *(_QWORD *)&buf[24] = &unk_1E9E52238;
          *(_QWORD *)&buf[32] = a1;
          *(_QWORD *)&buf[40] = v86;
          dispatch_async(v95, buf);
        }
        else
        {
          if (v88 >= 8)
          {
            v92 = VRTraceErrorLogLevelToCSTR();
            v93 = *MEMORY[0x1E0CF2758];
            v94 = *MEMORY[0x1E0CF2758];
            if (*MEMORY[0x1E0CF2748])
            {
              if (os_log_type_enabled(v94, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136316674;
                *(_QWORD *)&buf[4] = v92;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "_VCVideoCaptureServer_ProcessFrameSizeChange";
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&buf[24] = 1771;
                *(_WORD *)&buf[28] = 1024;
                *(_DWORD *)&buf[30] = v73;
                *(_WORD *)&buf[34] = 1024;
                *(_DWORD *)&buf[36] = v75;
                *(_WORD *)&buf[40] = 1024;
                *(_DWORD *)&buf[42] = v70;
                *(_WORD *)&buf[46] = 1024;
                LODWORD(v107) = v71;
                _os_log_impl(&dword_1D8A54000, v93, OS_LOG_TYPE_DEFAULT, "VCVideoCaptureServer [%s] %s:%d notifying clients of frame size change from %dx%d to %dx%d", buf, 0x34u);
              }
            }
            else if (os_log_type_enabled(v94, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136316674;
              *(_QWORD *)&buf[4] = v92;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_VCVideoCaptureServer_ProcessFrameSizeChange";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 1771;
              *(_WORD *)&buf[28] = 1024;
              *(_DWORD *)&buf[30] = v73;
              *(_WORD *)&buf[34] = 1024;
              *(_DWORD *)&buf[36] = v75;
              *(_WORD *)&buf[40] = 1024;
              *(_DWORD *)&buf[42] = v70;
              *(_WORD *)&buf[46] = 1024;
              LODWORD(v107) = v71;
              _os_log_debug_impl(&dword_1D8A54000, v93, OS_LOG_TYPE_DEBUG, "VCVideoCaptureServer [%s] %s:%d notifying clients of frame size change from %dx%d to %dx%d", buf, 0x34u);
            }
          }
          v96 = -[VideoAttributes copyEncodedDictionary](v86, "copyEncodedDictionary");
          v97 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D80]), "initWithObjectsAndKeys:", v96, CFSTR("localVideoAttributes"), 0);
          v98 = *(NSObject **)(a1 + 296);
          *(_QWORD *)buf = MEMORY[0x1E0C809B0];
          *(_QWORD *)&buf[8] = 3221225472;
          *(_QWORD *)&buf[16] = ___VCVideoCaptureServer_ProcessFrameSizeChange_block_invoke_718;
          *(_QWORD *)&buf[24] = &unk_1E9E521C0;
          *(_QWORD *)&buf[32] = v97;
          dispatch_async(v98, buf);

        }
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v103 = VRTraceErrorLogLevelToCSTR();
        v104 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = v103;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VCVideoCaptureServer_ProcessFrameSizeChange";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 1758;
          _os_log_impl(&dword_1D8A54000, v104, OS_LOG_TYPE_DEFAULT, "VCVideoCaptureServer [%s] %s:%d Skip sending", buf, 0x1Cu);
        }
      }
      objc_msgSend(*(id *)(a1 + 152), "setRatio:", v79, v80);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v99 = VRTraceErrorLogLevelToCSTR();
        v100 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v101 = *(void **)(a1 + 152);
          if (v101)
            v102 = (const char *)objc_msgSend((id)objc_msgSend(v101, "description"), "UTF8String");
          else
            v102 = "<nil>";
          LODWORD(v112.value) = 136315906;
          *(CMTimeValue *)((char *)&v112.value + 4) = v99;
          LOWORD(v112.flags) = 2080;
          *(_QWORD *)((char *)&v112.flags + 2) = "_VCVideoCaptureServer_ProcessFrameSizeChange";
          HIWORD(v112.epoch) = 1024;
          v113 = 1784;
          v114 = 2080;
          v115 = v102;
          _os_log_impl(&dword_1D8A54000, v100, OS_LOG_TYPE_DEFAULT, "VCVideoCaptureServer [%s] %s:%d localVideoAttributes changed to %s", (uint8_t *)&v112, 0x26u);
        }
      }

    }
    if (!*(_BYTE *)(a1 + 456))
      VCVideoCaptureServer_ApplyPressureLevelChanges(a1);
    goto LABEL_109;
  }
  if (ErrorLogLevelForModule >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCVideoCaptureServer_ProcessPreviewSampleBuffer_cold_1();
  }
LABEL_109:
  CVPixelBufferRelease(texture);
}

double micro()
{
  double v0;

  v0 = machTimeScale();
  return v0 * (double)(uint64_t)mach_absolute_time();
}

double machTimeScale()
{
  unint64_t v1;
  unint64_t v2;
  mach_timebase_info v3[2];

  v3[1] = *(mach_timebase_info *)MEMORY[0x1E0C80C00];
  if ((machTimeScale_did_init & 1) == 0)
  {
    v3[0] = (mach_timebase_info)0xAAAAAAAAAAAAAAAALL;
    mach_timebase_info(v3);
    LODWORD(v2) = v3[0].denom;
    LODWORD(v1) = v3[0].numer;
    *(double *)&machTimeScale_timeScale = (double)v1 / (double)v2 / 1000000000.0;
    __dmb(0xBu);
    machTimeScale_did_init = 1;
  }
  return *(double *)&machTimeScale_timeScale;
}

void VCVideoCaptureServer_ApplyPressureLevelChanges(uint64_t a1)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  int v6;
  int v7;
  uint64_t v8;
  int v9;
  NSObject *v10;
  uint64_t v11;
  NSObject *v12;
  int v13;
  int v14;
  NSObject *v15;
  uint64_t v16;
  NSObject *v17;
  uint64_t v18;
  NSObject *v19;
  int v20;
  uint64_t v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  const __CFString *v25;
  const __CFString *v26;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  const __CFString *v33;
  uint64_t v34;
  const __CFString *v35;
  uint64_t v36;
  NSObject *v37;
  __int128 v38;
  int v39;
  int v40;
  int v41;
  int v42;
  uint64_t v43;
  id obj;
  _QWORD v45[5];
  _QWORD block[5];
  uint64_t v47;
  _BYTE v48[128];
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  uint8_t buf[4];
  uint64_t v54;
  __int16 v55;
  const char *v56;
  __int16 v57;
  int v58;
  __int16 v59;
  int v60;
  __int16 v61;
  int v62;
  __int16 v63;
  _BOOL4 v64;
  __int16 v65;
  _BOOL4 v66;
  uint64_t v67;

  v67 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v41 = *(_DWORD *)(a1 + 444);
    v42 = *(_DWORD *)(a1 + 448);
    v2 = *(_DWORD *)(a1 + 16);
    v3 = *(unsigned int *)(a1 + 24);
    v39 = *(_DWORD *)(a1 + 432);
    v40 = *(_DWORD *)(a1 + 436);
    if (v40 == v39)
    {
      v8 = *(unsigned int *)(a1 + 16);
    }
    else
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
      {
        v4 = VRTraceErrorLogLevelToCSTR();
        v5 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v6 = *(_DWORD *)(a1 + 432);
          v7 = *(_DWORD *)(a1 + 436);
          *(_DWORD *)buf = 136316162;
          v54 = v4;
          v55 = 2080;
          v56 = "VCVideoCaptureServer_ApplyPressureLevelChanges";
          v57 = 1024;
          v58 = 1853;
          v59 = 1024;
          v60 = v6;
          v61 = 1024;
          v62 = v7;
          _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, "VCVideoCaptureServer [%s] %s:%d Notifying clients change in thermal level %d -> %d", buf, 0x28u);
        }
      }
      v8 = objc_msgSend((id)a1, "getFrameRateForThermalLevel:peakPowerPressure:", *(unsigned int *)(a1 + 436), *(unsigned int *)(a1 + 448));
      if (*(_QWORD *)(a1 + 336))
      {
        LODWORD(v3) = *(_DWORD *)(a1 + 20);
        v9 = objc_msgSend((id)a1, "getScreenFrameRateForThermalLevel:", *(unsigned int *)(a1 + 436));
        if ((int)v3 >= v9)
          v3 = v9;
        else
          v3 = v3;
      }
      v10 = *(NSObject **)(a1 + 256);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = __VCVideoCaptureServer_ApplyPressureLevelChanges_block_invoke;
      block[3] = &unk_1E9E521C0;
      block[4] = a1;
      dispatch_async(v10, block);
    }
    if (v42 != v41)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
      {
        v11 = VRTraceErrorLogLevelToCSTR();
        v12 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v13 = *(_DWORD *)(a1 + 444);
          v14 = *(_DWORD *)(a1 + 448);
          *(_DWORD *)buf = 136316162;
          v54 = v11;
          v55 = 2080;
          v56 = "VCVideoCaptureServer_ApplyPressureLevelChanges";
          v57 = 1024;
          v58 = 1874;
          v59 = 1024;
          v60 = v13;
          v61 = 1024;
          v62 = v14;
          _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, "VCVideoCaptureServer [%s] %s:%d Change in peak power level %d -> %d", buf, 0x28u);
        }
      }
      v8 = objc_msgSend((id)a1, "getFrameRateForThermalLevel:peakPowerPressure:", *(unsigned int *)(a1 + 436), *(unsigned int *)(a1 + 448));
      v15 = *(NSObject **)(a1 + 256);
      v45[0] = MEMORY[0x1E0C809B0];
      v45[1] = 3221225472;
      v45[2] = __VCVideoCaptureServer_ApplyPressureLevelChanges_block_invoke_208;
      v45[3] = &unk_1E9E521C0;
      v45[4] = a1;
      dispatch_async(v15, v45);
    }
    if (v2 != (_DWORD)v8)
    {
      objc_msgSend((id)a1, "setCaptureFrameRate:", v8);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v16 = VRTraceErrorLogLevelToCSTR();
        v17 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316674;
          v54 = v16;
          v55 = 2080;
          v56 = "VCVideoCaptureServer_ApplyPressureLevelChanges";
          v57 = 1024;
          v58 = 1883;
          v59 = 1024;
          v60 = v2;
          v61 = 1024;
          v62 = v8;
          v63 = 1024;
          v64 = v40 != v39;
          v65 = 1024;
          v66 = v42 != v41;
          _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, "VCVideoCaptureServer [%s] %s:%d Throttling framerate:(%d -> %d) because of changes in levels thermalLevelDidChange:%d powerLevelDidChange:%d", buf, 0x34u);
        }
      }
      objc_msgSend((id)a1, "notifyFrameRateBeingThrottledForClients:newFrameRate:thermalLevelDidChange:powerLevelDidChange:", *(_QWORD *)(a1 + 120), v8, v40 != v39, v42 != v41);
    }
    if (*(_QWORD *)(a1 + 336) && *(_DWORD *)(a1 + 24) != (_DWORD)v3)
    {
      objc_msgSend((id)a1, "setScreenCaptureFrameRate:", v3);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v18 = VRTraceErrorLogLevelToCSTR();
        v19 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v20 = *(_DWORD *)(a1 + 24);
          *(_DWORD *)buf = 136316674;
          v54 = v18;
          v55 = 2080;
          v56 = "VCVideoCaptureServer_ApplyPressureLevelChanges";
          v57 = 1024;
          v58 = 1889;
          v59 = 1024;
          v60 = v20;
          v61 = 1024;
          v62 = v3;
          v63 = 1024;
          v64 = v40 != v39;
          v65 = 1024;
          v66 = v42 != v41;
          _os_log_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_DEFAULT, "VCVideoCaptureServer [%s] %s:%d Throttling screen framerate (old=%d -> new=%d) because of changes in levels thermalLevelDidChange=%d powerLevelDidChange=%d", buf, 0x34u);
        }
      }
      objc_msgSend((id)a1, "notifyFrameRateBeingThrottledForClients:newFrameRate:thermalLevelDidChange:powerLevelDidChange:", *(_QWORD *)(a1 + 128), v3, v40 != v39, v42 != v41);
    }
    v51 = 0u;
    v52 = 0u;
    v49 = 0u;
    v50 = 0u;
    obj = *(id *)(a1 + 560);
    v21 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v49, v48, 16);
    if (v21)
    {
      v23 = v21;
      v24 = *(_QWORD *)v50;
      v25 = CFSTR("FrameRate");
      v26 = CFSTR("CurrentFrameRate");
      *(_QWORD *)&v22 = 136316674;
      v38 = v22;
      do
      {
        v27 = 0;
        v43 = v23;
        do
        {
          if (*(_QWORD *)v50 != v24)
            objc_enumerationMutation(obj);
          v28 = *(_QWORD *)(*((_QWORD *)&v49 + 1) + 8 * v27);
          v29 = (void *)objc_msgSend(*(id *)(a1 + 568), "objectForKeyedSubscript:", v28, v38);
          v30 = objc_msgSend((id)objc_msgSend(v29, "objectForKeyedSubscript:", v26), "intValue");
          v31 = objc_msgSend((id)a1, "screenFrameRateForThermalLevel:configuredFrameRate:captureSourceID:", *(unsigned int *)(a1 + 436), objc_msgSend((id)objc_msgSend(v29, "objectForKeyedSubscript:", v25), "intValue"), v28);
          if ((_DWORD)v31 != v30)
          {
            v32 = v31;
            v33 = v25;
            v34 = v24;
            v35 = v26;
            objc_msgSend((id)a1, "setScreenCaptureFrameRate:captureSourceID:", v31, v28);
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v36 = VRTraceErrorLogLevelToCSTR();
              v37 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = v38;
                v54 = v36;
                v55 = 2080;
                v56 = "VCVideoCaptureServer_ApplyPressureLevelChanges";
                v57 = 1024;
                v58 = 1900;
                v59 = 1024;
                v60 = v30;
                v61 = 1024;
                v62 = v32;
                v63 = 1024;
                v64 = v40 != v39;
                v65 = 1024;
                v66 = v42 != v41;
                _os_log_impl(&dword_1D8A54000, v37, OS_LOG_TYPE_DEFAULT, "VCVideoCaptureServer [%s] %s:%d Throttling screen framerate (old=%d -> new=%d) because of changes in levels thermalLevelDidChange=%d powerLevelDidChange=%d", buf, 0x34u);
              }
            }
            v47 = objc_msgSend((id)objc_msgSend(*(id *)(a1 + 568), "objectForKeyedSubscript:", v28), "objectForKeyedSubscript:", CFSTR("Client"));
            objc_msgSend((id)a1, "notifyFrameRateBeingThrottledForClients:newFrameRate:thermalLevelDidChange:powerLevelDidChange:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v47, 1), v32, v40 != v39, v42 != v41);
            v26 = v35;
            v24 = v34;
            v25 = v33;
            v23 = v43;
          }
          ++v27;
        }
        while (v23 != v27);
        v23 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v49, v48, 16);
      }
      while (v23);
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCVideoCaptureServer_ApplyPressureLevelChanges_cold_1();
  }
}

uint64_t VCImageQueue_EnqueueFrame(uint64_t a1, __CVBuffer *a2, CMTime *a3)
{
  const __CFString *v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  NSObject *v12;
  uint64_t v13;
  Float64 Seconds;
  const char *v15;
  NSObject *v16;
  uint32_t v17;
  uint64_t v18;
  NSObject *v19;
  NSObject *v20;
  uint64_t v21;
  Float64 v22;
  uint64_t v23;
  Float64 v24;
  const char *v25;
  NSObject *v26;
  uint32_t v27;
  const __CFAllocator *v28;
  opaqueCMSampleBuffer *SampleBufferWithPixelBuffer;
  opaqueCMSampleBuffer *v30;
  char v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v35;
  Float64 v36;
  CMTime v37;
  CMTime time;
  int v39;
  __int16 v40;
  uint64_t v41;
  __int16 v42;
  Float64 v43;
  __int16 v44;
  uint64_t v45;
  __int16 v46;
  Float64 v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v37 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68];
  if (a1 && a2)
  {
    if (objc_opt_class() == a1)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 8)
        goto LABEL_23;
      v10 = VRTraceErrorLogLevelToCSTR();
      v11 = *MEMORY[0x1E0CF2758];
      v12 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          goto LABEL_23;
        v13 = *(_QWORD *)(a1 + 16);
        time = *a3;
        Seconds = CMTimeGetSeconds(&time);
        LODWORD(time.value) = 136316162;
        *(CMTimeValue *)((char *)&time.value + 4) = v10;
        LOWORD(time.flags) = 2080;
        *(_QWORD *)((char *)&time.flags + 2) = "VCImageQueue_EnqueueFrame";
        HIWORD(time.epoch) = 1024;
        v39 = 1117;
        v40 = 2048;
        v41 = v13;
        v42 = 2048;
        v43 = Seconds;
        v15 = " [%s] %s:%d _figQueue=%p，frameTime=%f";
        v16 = v11;
        v17 = 48;
LABEL_19:
        _os_log_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEFAULT, v15, (uint8_t *)&time, v17);
        goto LABEL_23;
      }
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        v35 = *(_QWORD *)(a1 + 16);
        time = *a3;
        v36 = CMTimeGetSeconds(&time);
        LODWORD(time.value) = 136316162;
        *(CMTimeValue *)((char *)&time.value + 4) = v10;
        LOWORD(time.flags) = 2080;
        *(_QWORD *)((char *)&time.flags + 2) = "VCImageQueue_EnqueueFrame";
        HIWORD(time.epoch) = 1024;
        v39 = 1117;
        v40 = 2048;
        v41 = v35;
        v42 = 2048;
        v43 = v36;
        v25 = " [%s] %s:%d _figQueue=%p，frameTime=%f";
        v26 = v11;
        v27 = 48;
        goto LABEL_41;
      }
    }
    else
    {
      if ((objc_opt_respondsToSelector() & 1) != 0)
        v6 = (const __CFString *)objc_msgSend((id)a1, "performSelector:", sel_logPrefix);
      else
        v6 = &stru_1E9E58EE0;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v18 = VRTraceErrorLogLevelToCSTR();
        v19 = *MEMORY[0x1E0CF2758];
        v20 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (!os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
            goto LABEL_23;
          v21 = *(_QWORD *)(a1 + 16);
          time = *a3;
          v22 = CMTimeGetSeconds(&time);
          LODWORD(time.value) = 136316674;
          *(CMTimeValue *)((char *)&time.value + 4) = v18;
          LOWORD(time.flags) = 2080;
          *(_QWORD *)((char *)&time.flags + 2) = "VCImageQueue_EnqueueFrame";
          HIWORD(time.epoch) = 1024;
          v39 = 1117;
          v40 = 2112;
          v41 = (uint64_t)v6;
          v42 = 2048;
          v43 = *(double *)&a1;
          v44 = 2048;
          v45 = v21;
          v46 = 2048;
          v47 = v22;
          v15 = " [%s] %s:%d %@(%p) _figQueue=%p，frameTime=%f";
          v16 = v19;
          v17 = 68;
          goto LABEL_19;
        }
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
        {
          v23 = *(_QWORD *)(a1 + 16);
          time = *a3;
          v24 = CMTimeGetSeconds(&time);
          LODWORD(time.value) = 136316674;
          *(CMTimeValue *)((char *)&time.value + 4) = v18;
          LOWORD(time.flags) = 2080;
          *(_QWORD *)((char *)&time.flags + 2) = "VCImageQueue_EnqueueFrame";
          HIWORD(time.epoch) = 1024;
          v39 = 1117;
          v40 = 2112;
          v41 = (uint64_t)v6;
          v42 = 2048;
          v43 = *(double *)&a1;
          v44 = 2048;
          v45 = v23;
          v46 = 2048;
          v47 = v24;
          v25 = " [%s] %s:%d %@(%p) _figQueue=%p，frameTime=%f";
          v26 = v19;
          v27 = 68;
LABEL_41:
          _os_log_debug_impl(&dword_1D8A54000, v26, OS_LOG_TYPE_DEBUG, v25, (uint8_t *)&time, v27);
        }
      }
    }
LABEL_23:
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
    _VCImageQueue_DrawOverlayMessage(a1, a2);
    if (*(_QWORD *)(a1 + 152))
    {
      v28 = *(const __CFAllocator **)(a1 + 160);
      time = *a3;
      SampleBufferWithPixelBuffer = VideoUtil_CreateSampleBufferWithPixelBuffer(a2, (uint64_t)&time, v28, v28);
      if (SampleBufferWithPixelBuffer)
      {
        v30 = SampleBufferWithPixelBuffer;
        v31 = VCStreamOutput_EnqueueSampleBuffer(*(_QWORD *)(a1 + 152), SampleBufferWithPixelBuffer);
        if ((v31 & 1) == 0)
          VCImageQueue_CleanupStreamOutput(a1);
        CFRelease(v30);
      }
      else
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCImageQueue_EnqueueFrame_cold_1();
        }
        v31 = 0;
      }
      if (*(_QWORD *)(a1 + 152))
      {
        v9 = 1;
LABEL_37:
        time = *a3;
        *(double *)&v33 = CMTimeGetSeconds(&time);
        time = v37;
        _VCImageQueue_EmitFrameEnqueuedSignposts(a1, v33, &time, a2);
LABEL_38:
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 32));
        return v9;
      }
    }
    else
    {
      v31 = 0;
    }
    time = *a3;
    v32 = _VCImageQueue_EnqueuePixelBuffer(a1, (uint64_t)a2, &time, (uint64_t)&v37);
    v9 = v32;
    if ((v31 & 1) == 0 && !(_DWORD)v32)
      goto LABEL_38;
    goto LABEL_37;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v7 = VRTraceErrorLogLevelToCSTR();
    v8 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      LODWORD(time.value) = 136316162;
      *(CMTimeValue *)((char *)&time.value + 4) = v7;
      LOWORD(time.flags) = 2080;
      *(_QWORD *)((char *)&time.flags + 2) = "VCImageQueue_EnqueueFrame";
      HIWORD(time.epoch) = 1024;
      v39 = 1114;
      v40 = 2048;
      v41 = a1;
      v42 = 2048;
      v43 = *(double *)&a2;
      _os_log_error_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_ERROR, " [%s] %s:%d Invalid parameter. imageQueue=%p pixelBuffer=%p", (uint8_t *)&time, 0x30u);
    }
  }
  return 0;
}

uint64_t _VCImageQueue_EnqueuePixelBuffer(uint64_t a1, uint64_t a2, CMTime *a3, uint64_t a4)
{
  CMTimeValue value;
  CMTimeFlags flags;
  CMTimeScale timescale;
  CMTimeEpoch epoch;
  CMTimeValue v12;
  uint64_t v13;
  int v14;
  int32_t v15;
  int32_t v16;
  uint64_t *v17;
  uint64_t v18;
  void (*v19)(uint64_t, CMTime *, CMTime *, CMTime *);
  uint64_t v20;
  unsigned int (*v21)(uint64_t);
  int v22;
  uint64_t v23;
  NSObject *v24;
  uint64_t v25;
  uint64_t (*v26)(uint64_t);
  int v27;
  uint64_t v28;
  NSObject *v29;
  uint64_t v30;
  int v32;
  int v33;
  unsigned int *v34;
  unsigned int v35;
  uint64_t v36;
  void (*v37)(uint64_t, uint64_t, _QWORD, CMTime *, uint64_t);
  uint64_t v38;
  int v39;
  int ErrorLogLevelForModule;
  uint64_t v41;
  NSObject *v42;
  Float64 v43;
  int v44;
  Float64 v45;
  Float64 v46;
  const char *v47;
  uint64_t v48;
  NSObject *v49;
  Float64 v50;
  int v51;
  Float64 v52;
  Float64 v53;
  uint64_t v54;
  Float64 v55;
  int v56;
  Float64 v57;
  Float64 v58;
  const char *v59;
  NSObject *v60;
  uint32_t v61;
  Float64 v62;
  int v63;
  Float64 v64;
  Float64 v65;
  uint64_t v66;
  NSObject *v67;
  Float64 Seconds;
  Float64 v69;
  int v70;
  uint64_t v71;
  CMTime rhs;
  CMTime lhs;
  CMTime v74;
  CMTime v75;
  int v76;
  __int16 v77;
  _BYTE v78[40];
  __int16 v79;
  Float64 v80;
  uint64_t v81;

  v81 = *MEMORY[0x1E0C80C00];
  value = a3->value;
  timescale = a3->timescale;
  flags = a3->flags;
  epoch = a3->epoch;
  if (*(_BYTE *)(a1 + 352) && *(_QWORD *)(a1 + 184))
  {
    convertTimeoutToRelativeTimespec(0.033);
    v75.value = v12;
    *(_QWORD *)&v75.timescale = v13;
    if (pthread_cond_timedwait_relative_np((pthread_cond_t *)(a1 + 360), (pthread_mutex_t *)(a1 + 32), (const timespec *)&v75) == 60)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCImageQueue_EnqueuePixelBuffer_cold_2();
      }
      _VCImageQueue_applyLayerTransforms(a1, 0);
    }
    *(_BYTE *)(a1 + 352) = 0;
    v14 = 1;
  }
  else
  {
    v14 = 0;
  }
  v15 = *(_DWORD *)(a1 + 108);
  if ((v15 - 1) <= 0x1D)
  {
    memset(&v75, 170, sizeof(v75));
    CMTimeMake(&v75, 1, v15);
    lhs.value = value;
    lhs.timescale = timescale;
    lhs.flags = flags;
    lhs.epoch = epoch;
    rhs = v75;
    CMTimeAdd(&v74, &lhs, &rhs);
    v16 = *(_DWORD *)(a1 + 108);
    lhs = v74;
    CMTimeConvertScale(&v74, &lhs, v16, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
    value = v74.value;
    timescale = v74.timescale;
    flags = v74.flags;
    epoch = v74.epoch;
  }
  if ((flags & 0x1D) != 1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      return 0;
    v66 = VRTraceErrorLogLevelToCSTR();
    v67 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      return 0;
    v75 = *a3;
    Seconds = CMTimeGetSeconds(&v75);
    v75.value = value;
    v75.timescale = timescale;
    v75.flags = flags;
    v75.epoch = epoch;
    v69 = CMTimeGetSeconds(&v75);
    LODWORD(v75.value) = 136316418;
    *(CMTimeValue *)((char *)&v75.value + 4) = v66;
    LOWORD(v75.flags) = 2080;
    *(_QWORD *)((char *)&v75.flags + 2) = "_VCImageQueue_EnqueuePixelBuffer";
    HIWORD(v75.epoch) = 1024;
    v76 = 1048;
    v77 = 2048;
    *(Float64 *)v78 = Seconds;
    *(_WORD *)&v78[8] = 2048;
    *(Float64 *)&v78[10] = v69;
    *(_WORD *)&v78[18] = 2112;
    *(_QWORD *)&v78[20] = a1;
    v59 = " [%s] %s:%d Cannot enqueue, frameTime is invalid. inFrameTime=%f frameTime=%f VCImageQueue=(%@)";
    v60 = v67;
    v61 = 58;
    goto LABEL_50;
  }
  v17 = (uint64_t *)(a1 + 16);
  v18 = *(_QWORD *)(a1 + 16);
  if (!v18)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v28 = VRTraceErrorLogLevelToCSTR();
      v29 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCImageQueue_EnqueuePixelBuffer_cold_1(v28, v17, v29);
    }
    return 0;
  }
  LODWORD(rhs.value) = 0;
  v74 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E18];
  lhs = v74;
  v19 = *(void (**)(uint64_t, CMTime *, CMTime *, CMTime *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 64);
  if (v19)
    v19(v18, &rhs, &v74, &lhs);
  v20 = *v17;
  v21 = *(unsigned int (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 24);
  if (!v21 || !v21(v20))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      return 0;
    v23 = VRTraceErrorLogLevelToCSTR();
    v24 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      return 0;
    v25 = *v17;
    v26 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 24);
    if (v26)
      v27 = v26(v25);
    else
      v27 = 0;
    v54 = *v17;
    v75.value = value;
    v75.timescale = timescale;
    v75.flags = flags;
    v75.epoch = epoch;
    v55 = CMTimeGetSeconds(&v75);
    v56 = rhs.value;
    v75 = v74;
    v57 = CMTimeGetSeconds(&v75);
    v75 = lhs;
    v58 = CMTimeGetSeconds(&v75);
    LODWORD(v75.value) = 136317186;
    *(CMTimeValue *)((char *)&v75.value + 4) = v23;
    LOWORD(v75.flags) = 2080;
    *(_QWORD *)((char *)&v75.flags + 2) = "_VCImageQueue_EnqueuePixelBuffer";
    HIWORD(v75.epoch) = 1024;
    v76 = 1092;
    v77 = 1024;
    *(_DWORD *)v78 = v27;
    *(_WORD *)&v78[4] = 2048;
    *(_QWORD *)&v78[6] = v54;
    *(_WORD *)&v78[14] = 2048;
    *(Float64 *)&v78[16] = v55;
    *(_WORD *)&v78[24] = 1024;
    *(_DWORD *)&v78[26] = v56;
    *(_WORD *)&v78[30] = 2048;
    *(Float64 *)&v78[32] = v57;
    v79 = 2048;
    v80 = v58;
    v59 = " [%s] %s:%d Cannot enqueue. FigImageQueueCanEnqueueImage=%d for queue=%p frameTime=%f Unconsumed image count=%"
          "d minTime=%f maxTime=%f";
    v60 = v24;
    v61 = 80;
LABEL_50:
    _os_log_error_impl(&dword_1D8A54000, v60, OS_LOG_TYPE_ERROR, v59, (uint8_t *)&v75, v61);
    return 0;
  }
  v71 = a2;
  v70 = v14;
  if (*(_BYTE *)(a1 + 113))
  {
    value = *MEMORY[0x1E0CA2E68];
    timescale = *(_DWORD *)(MEMORY[0x1E0CA2E68] + 8);
    flags = *(_DWORD *)(MEMORY[0x1E0CA2E68] + 12);
    epoch = *(_QWORD *)(MEMORY[0x1E0CA2E68] + 16);
    v22 = 3;
  }
  else
  {
    v22 = 0;
  }
  v32 = *(unsigned __int8 *)(a1 + 409);
  v33 = *(unsigned __int8 *)(a1 + 410);
  v34 = (unsigned int *)(a1 + 132);
  do
    v35 = __ldaxr(v34);
  while (__stlxr(v35 + 1, v34));
  v36 = *v17;
  v37 = *(void (**)(uint64_t, uint64_t, _QWORD, CMTime *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                           + 32);
  if (v37)
  {
    v75.value = value;
    if (v32 == v33)
      v38 = v22 | v70;
    else
      v38 = v22 | v70 | 4u;
    v75.timescale = timescale;
    v75.flags = flags;
    v75.epoch = epoch;
    v37(v36, v71, 0, &v75, v38);
  }
  if (a4)
  {
    *(_QWORD *)a4 = value;
    *(_DWORD *)(a4 + 8) = timescale;
    *(_DWORD *)(a4 + 12) = flags;
    *(_QWORD *)(a4 + 16) = epoch;
  }
  v39 = rhs.value;
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (v39 < 16)
  {
    if (ErrorLogLevelForModule >= 8)
    {
      v48 = VRTraceErrorLogLevelToCSTR();
      v42 = *MEMORY[0x1E0CF2758];
      v49 = *MEMORY[0x1E0CF2758];
      if (!*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
        {
          v75.value = value;
          v75.timescale = timescale;
          v75.flags = flags;
          v75.epoch = epoch;
          v62 = CMTimeGetSeconds(&v75);
          v63 = rhs.value;
          v75 = v74;
          v64 = CMTimeGetSeconds(&v75);
          v75 = lhs;
          v65 = CMTimeGetSeconds(&v75);
          LODWORD(v75.value) = 136316674;
          *(CMTimeValue *)((char *)&v75.value + 4) = v48;
          LOWORD(v75.flags) = 2080;
          *(_QWORD *)((char *)&v75.flags + 2) = "_VCImageQueue_EnqueuePixelBuffer";
          HIWORD(v75.epoch) = 1024;
          v76 = 1082;
          v77 = 2048;
          *(Float64 *)v78 = v62;
          *(_WORD *)&v78[8] = 1024;
          *(_DWORD *)&v78[10] = v63;
          *(_WORD *)&v78[14] = 2048;
          *(Float64 *)&v78[16] = v64;
          *(_WORD *)&v78[24] = 2048;
          *(Float64 *)&v78[26] = v65;
          _os_log_debug_impl(&dword_1D8A54000, v42, OS_LOG_TYPE_DEBUG, " [%s] %s:%d frameTime=%f Unconsumed image count=%d minTime=%f maxTime=%f", (uint8_t *)&v75, 0x40u);
        }
        goto LABEL_46;
      }
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
      {
        v75.value = value;
        v75.timescale = timescale;
        v75.flags = flags;
        v75.epoch = epoch;
        v50 = CMTimeGetSeconds(&v75);
        v51 = rhs.value;
        v75 = v74;
        v52 = CMTimeGetSeconds(&v75);
        v75 = lhs;
        v53 = CMTimeGetSeconds(&v75);
        LODWORD(v75.value) = 136316674;
        *(CMTimeValue *)((char *)&v75.value + 4) = v48;
        LOWORD(v75.flags) = 2080;
        *(_QWORD *)((char *)&v75.flags + 2) = "_VCImageQueue_EnqueuePixelBuffer";
        HIWORD(v75.epoch) = 1024;
        v76 = 1082;
        v77 = 2048;
        *(Float64 *)v78 = v50;
        *(_WORD *)&v78[8] = 1024;
        *(_DWORD *)&v78[10] = v51;
        *(_WORD *)&v78[14] = 2048;
        *(Float64 *)&v78[16] = v52;
        *(_WORD *)&v78[24] = 2048;
        *(Float64 *)&v78[26] = v53;
        v47 = " [%s] %s:%d frameTime=%f Unconsumed image count=%d minTime=%f maxTime=%f";
        goto LABEL_43;
      }
    }
  }
  else if (ErrorLogLevelForModule >= 5)
  {
    v41 = VRTraceErrorLogLevelToCSTR();
    v42 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v75.value = value;
      v75.timescale = timescale;
      v75.flags = flags;
      v75.epoch = epoch;
      v43 = CMTimeGetSeconds(&v75);
      v44 = rhs.value;
      v75 = v74;
      v45 = CMTimeGetSeconds(&v75);
      v75 = lhs;
      v46 = CMTimeGetSeconds(&v75);
      LODWORD(v75.value) = 136316674;
      *(CMTimeValue *)((char *)&v75.value + 4) = v41;
      LOWORD(v75.flags) = 2080;
      *(_QWORD *)((char *)&v75.flags + 2) = "_VCImageQueue_EnqueuePixelBuffer";
      HIWORD(v75.epoch) = 1024;
      v76 = 1080;
      v77 = 2048;
      *(Float64 *)v78 = v43;
      *(_WORD *)&v78[8] = 1024;
      *(_DWORD *)&v78[10] = v44;
      *(_WORD *)&v78[14] = 2048;
      *(Float64 *)&v78[16] = v45;
      *(_WORD *)&v78[24] = 2048;
      *(Float64 *)&v78[26] = v46;
      v47 = " [%s] %s:%d Image queue at full capacity! frameTime=%f Unconsumed image count=%d minTime=%f maxTime=%f";
LABEL_43:
      _os_log_impl(&dword_1D8A54000, v42, OS_LOG_TYPE_DEFAULT, v47, (uint8_t *)&v75, 0x40u);
    }
  }
LABEL_46:
  v30 = 1;
  if (*(unsigned __int8 *)(a1 + 409) != *(unsigned __int8 *)(a1 + 410))
  {
    _VCImageQueue_ApplyPreviewLayerTransforms(a1, 1);
    *(_BYTE *)(a1 + 410) = *(_BYTE *)(a1 + 409);
  }
  return v30;
}

uint64_t _VCImageQueue_EmitFrameEnqueuedSignposts(uint64_t a1, uint64_t a2, CMTime *a3, __CVBuffer *a4)
{
  const void *v7;
  double v8;
  CFIndex Count;
  const __CFArray *ValueAtIndex;
  const __CFNumber *v11;
  const __CFAllocator *v12;
  CFArrayRef v13;
  CFArrayRef v14;
  __IOSurface *IOSurface;
  const __CFNumber *Attachment;
  double v18;
  CMTime valuePtr;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v7 = (const void *)(a1 + 128);
  ++*(_DWORD *)(a1 + 128);
  if (*(_QWORD *)(a1 + 144))
  {
    v8 = micro();
    v18 = v8;
    Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 136));
    if (Count < 1)
    {
      if (Count)
      {
LABEL_17:
        _VCImageQueue_RemoveExpiredFrameCounts(a1, v8);
        goto LABEL_18;
      }
    }
    else
    {
      ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 136), Count - 1);
      v11 = (const __CFNumber *)CFArrayGetValueAtIndex(ValueAtIndex, 0);
      valuePtr.value = 0;
      CFNumberGetValue(v11, kCFNumberDoubleType, &valuePtr);
      if (*(double *)&valuePtr.value + 1.0 > v8)
        goto LABEL_17;
    }
    *(_QWORD *)&valuePtr.timescale = 0;
    v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    valuePtr.value = (CMTimeValue)CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberDoubleType, &v18);
    if (valuePtr.value)
    {
      *(_QWORD *)&valuePtr.timescale = CFNumberCreate(v12, kCFNumberSInt32Type, v7);
      if (*(_QWORD *)&valuePtr.timescale)
      {
        v13 = CFArrayCreate(v12, (const void **)&valuePtr, 2, MEMORY[0x1E0C9B378]);
        if (v13)
        {
          v14 = v13;
          CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 136), v13);
LABEL_10:
          if (valuePtr.value)
            CFRelease((CFTypeRef)valuePtr.value);
          if (*(_QWORD *)&valuePtr.timescale)
            CFRelease(*(CFTypeRef *)&valuePtr.timescale);
          if (v14)
            CFRelease(v14);
          v8 = v18;
          goto LABEL_17;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VCImageQueue_EmitFrameEnqueuedSignposts_cold_3();
        }
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCImageQueue_EmitFrameEnqueuedSignposts_cold_2();
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCImageQueue_EmitFrameEnqueuedSignposts_cold_1();
    }
    v14 = 0;
    goto LABEL_10;
  }
LABEL_18:
  valuePtr = *a3;
  CMTimeGetSeconds(&valuePtr);
  IOSurface = CVPixelBufferGetIOSurface(a4);
  IOSurfaceGetID(IOSurface);
  if (*(_BYTE *)(a1 + 113))
  {
    LODWORD(valuePtr.value) = -1431655766;
    Attachment = (const __CFNumber *)CVBufferGetAttachment(a4, CFSTR("FrameSequenceNumber"), (CVAttachmentMode *)&valuePtr);
    if (Attachment)
    {
      LOWORD(v18) = 0;
      CFNumberGetValue(Attachment, kCFNumberSInt16Type, &v18);
      kdebug_trace();
    }
  }
  return kdebug_trace();
}

char *_VCImageQueue_DrawOverlayMessage(uint64_t a1, __CVBuffer *a2)
{
  char *result;
  float v5;
  double Width;
  size_t Height;
  _OWORD v8[5];
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  result = *(char **)(a1 + 144);
  if (result)
  {
    v11 = xmmword_1D910CF80;
    v12 = unk_1D910CF90;
    v13 = xmmword_1D910CFA0;
    v9 = xmmword_1D910CF60;
    v10 = unk_1D910CF70;
    objc_msgSend(result, "currentDetails");
    _VCImageQueue_AverageFrameRate(a1);
    if (v5 <= 0.0)
      v5 = *((float *)&v9 + 1);
    *(_QWORD *)((char *)&v9 + 4) = __PAIR64__((float)*(unsigned int *)(a1 + 108), LODWORD(v5));
    Width = (float)CVPixelBufferGetWidth(a2);
    Height = CVPixelBufferGetHeight(a2);
    *(double *)&v12 = Width;
    *((double *)&v12 + 1) = (float)Height;
    v8[0] = v9;
    v8[1] = v10;
    v8[2] = v11;
    v8[3] = v12;
    v8[4] = v13;
    objc_msgSend(*(id *)(a1 + 144), "setCurrentDetails:", v8);
    return VCPixelBufferOverlay_updateOverlayWithPixelBuffer(*(char **)(a1 + 144), a2);
  }
  return result;
}

CFMutableDictionaryRef VideoAttributes_CreateEncodedCFDictionary(void *a1)
{
  CFMutableDictionaryRef Mutable;

  if (!a1)
    return 0;
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  VCCameraStatusBitsFromVideoAttributes(a1);
  FigCFDictionarySetInt16();
  FigCFDictionarySetCGRect();
  FigCFDictionarySetCGSize();
  return Mutable;
}

void VCImageQueue_EnqueueAttributes(uint64_t a1, const void *a2)
{
  int v4;
  char v5;
  const void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  _OWORD v11[5];
  int v12;
  float v13;
  _BYTE buf[48];
  __int128 v15;
  __int128 v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (a1 && a2)
  {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
    if (*(_QWORD *)(a1 + 184))
    {
      if (!*(_BYTE *)(a1 + 408))
      {
        v12 = 0;
        if (FigCFDictionaryGetInt16IfPresent())
        {
          if (FigCFDictionaryGetInt16IfPresent())
          {
            if (*(_BYTE *)(a1 + 419) && (v12 & 3u) > 1
              || (v13 = 0.0,
                  *(_DWORD *)buf = 0,
                  _VCImageQueue_computeVisibleFrameRatio(*(_QWORD *)(a1 + 24), (float *)buf),
                  v4)
              && (_VCImageQueue_computeVisibleFrameRatio((uint64_t)a2, &v13), (v5 & 1) != 0)
              && !VCMU_CompareWithAccuracy(v13, *(float *)buf, 0.01))
            {
              *(_BYTE *)(a1 + 352) = 1;
            }
          }
        }
      }
    }
    v6 = *(const void **)(a1 + 24);
    if (v6)
    {
      CFRelease(v6);
      *(_QWORD *)(a1 + 24) = 0;
    }
    *(_QWORD *)(a1 + 24) = CFRetain(a2);
    v7 = *(void **)(a1 + 144);
    if (v7)
    {
      v15 = unk_1D910CF90;
      v16 = xmmword_1D910CFA0;
      *(_OWORD *)buf = xmmword_1D910CF60;
      memset(&buf[16], 255, 32);
      objc_msgSend(v7, "currentDetails");
      *(_QWORD *)&v16 = *(_QWORD *)(a1 + 24);
      buf[2] = *(_BYTE *)(a1 + 408);
      v11[2] = *(_OWORD *)&buf[32];
      v11[3] = v15;
      v11[4] = v16;
      v11[0] = *(_OWORD *)buf;
      v11[1] = *(_OWORD *)&buf[16];
      objc_msgSend(*(id *)(a1 + 144), "setCurrentDetails:", v11);
    }
    v8 = *(_QWORD *)(a1 + 152);
    if (v8)
    {
      if ((VCStreamOutput_EnqueueAttributes(v8, *(_QWORD *)(a1 + 24)) & 1) == 0)
        VCImageQueue_CleanupStreamOutput(a1);
    }
    _VCImageQueue_ApplyPreviewLayerTransforms(a1, 0);
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 32));
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v9 = VRTraceErrorLogLevelToCSTR();
    v10 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136316162;
      *(_QWORD *)&buf[4] = v9;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "VCImageQueue_EnqueueAttributes";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 993;
      *(_WORD *)&buf[28] = 2048;
      *(_QWORD *)&buf[30] = a1;
      *(_WORD *)&buf[38] = 2048;
      *(_QWORD *)&buf[40] = a2;
      _os_log_error_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_ERROR, " [%s] %s:%d Invalid parameter. imageQueue=%p attributes=%p", buf, 0x30u);
    }
  }
}

uint64_t VCSingleLinkedListInitialize(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  if (result)
  {
    v2 = result;
    result = 0;
    if (a2)
    {
      if (!*(_BYTE *)(v2 + 8))
      {
        *(_QWORD *)v2 = 0;
        result = 1;
        *(_BYTE *)(v2 + 8) = 1;
        *(_QWORD *)(v2 + 16) = a2;
        *(_QWORD *)(v2 + 24) = 0;
      }
    }
  }
  return result;
}

uint64_t _VCAVFoundationCapture_compare(void *a1, void *a2, double *a3)
{
  double v6;
  float v7;
  unint64_t v8;
  float v9;
  unint64_t v10;
  unint64_t Dimensions;
  int32_t v13;
  unint64_t v14;
  CMVideoDimensions v15;
  float v16;
  float v17;
  float v18;
  float v19;

  v6 = a3[1];
  v7 = v6;
  v8 = _VCAVFoundationCapture_effectiveResolution(a1, v7);
  v9 = v6;
  v10 = _VCAVFoundationCapture_effectiveResolution(a2, v9);
  if (v8 > v10)
    return 1;
  if (v8 < v10)
    return -1;
  Dimensions = (unint64_t)CMVideoFormatDescriptionGetDimensions((CMVideoFormatDescriptionRef)objc_msgSend(a1, "formatDescription"));
  v13 = Dimensions;
  v14 = HIDWORD(Dimensions);
  v15 = CMVideoFormatDescriptionGetDimensions((CMVideoFormatDescriptionRef)objc_msgSend(a2, "formatDescription"));
  v16 = v6 - (float)((float)v13 / (float)(int)v14);
  v17 = fabsf(v16);
  v18 = v6 - (float)((float)v15.width / (float)v15.height);
  v19 = fabsf(v18);
  if (VCMU_CompareWithAccuracy(v17, v19, 0.01))
  {
    if (a2)
    {
      if (!a1)
        return 1;
      if (*(_BYTE *)(*(_QWORD *)a3 + 229) && !*(_DWORD *)(*(_QWORD *)a3 + 232))
      {
        if (objc_msgSend(a1, "isVideoHDRSupported")
          && !objc_msgSend(a2, "isVideoHDRSupported"))
        {
          return -1;
        }
        if ((objc_msgSend(a1, "isVideoHDRSupported") & 1) == 0 && (objc_msgSend(a2, "isVideoHDRSupported") & 1) != 0)
          return 1;
      }
      if (!objc_msgSend(a1, "isVideoBinned") || objc_msgSend(a2, "isVideoBinned"))
        return (objc_msgSend(a1, "isVideoBinned") & 1) == 0 && (objc_msgSend(a2, "isVideoBinned") & 1) != 0;
    }
    return -1;
  }
  if (v17 > v19)
    return 1;
  if (v17 >= v19)
    return 0;
  else
    return -1;
}

unint64_t _VCAVFoundationCapture_effectiveResolution(void *a1, float a2)
{
  unint64_t Dimensions;
  int32_t v4;
  unint64_t v5;
  double v6;
  double v7;
  double v8;
  double v9;
  unint64_t v10;
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  int v15;
  uint64_t v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int32_t v22;
  __int16 v23;
  int v24;
  __int16 v25;
  double v26;
  __int16 v27;
  unint64_t v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  Dimensions = (unint64_t)CMVideoFormatDescriptionGetDimensions((CMVideoFormatDescriptionRef)objc_msgSend(a1, "formatDescription"));
  v4 = Dimensions;
  v5 = HIDWORD(Dimensions);
  v6 = a2;
  v7 = round((double)Dimensions / v6);
  v8 = v7 * (double)Dimensions;
  v9 = round(v6 * (double)HIDWORD(Dimensions)) * (double)HIDWORD(Dimensions);
  if (v7 > (double)HIDWORD(Dimensions))
    v8 = v9;
  v10 = (unint64_t)v8;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v11 = VRTraceErrorLogLevelToCSTR();
    v12 = *MEMORY[0x1E0CF2758];
    v13 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        v15 = 136316674;
        v16 = v11;
        v17 = 2080;
        v18 = "_VCAVFoundationCapture_effectiveResolution";
        v19 = 1024;
        v20 = 2709;
        v21 = 1024;
        v22 = v4;
        v23 = 1024;
        v24 = v5;
        v25 = 2048;
        v26 = v6;
        v27 = 2048;
        v28 = v10;
        _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d %ux%u,AR:%f, res=%llu", (uint8_t *)&v15, 0x3Cu);
      }
    }
    else if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      v15 = 136316674;
      v16 = v11;
      v17 = 2080;
      v18 = "_VCAVFoundationCapture_effectiveResolution";
      v19 = 1024;
      v20 = 2709;
      v21 = 1024;
      v22 = v4;
      v23 = 1024;
      v24 = v5;
      v25 = 2048;
      v26 = v6;
      v27 = 2048;
      v28 = v10;
      _os_log_debug_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEBUG, " [%s] %s:%d %ux%u,AR:%f, res=%llu", (uint8_t *)&v15, 0x3Cu);
    }
  }
  return v10;
}

uint64_t _VCAllocatorFirstComeCallback_Retain(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = (unsigned int *)(result + 8);
  do
    v2 = __ldxr(v1);
  while (__stxr(v2 + 1, v1));
  return result;
}

void _VCAVFoundationCapture_PushFrameToCaptureServer(_DWORD *a1, CFTypeRef cf, __int128 *a3, uint64_t a4, uint64_t a5)
{
  CFTypeRef v10;
  void (*v11)(uint64_t, CFTypeRef, __int128 *, BOOL, uint64_t, uint64_t);
  uint64_t v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (cf)
    v10 = CFRetain(cf);
  else
    v10 = 0;
  v11 = *(void (**)(uint64_t, CFTypeRef, __int128 *, BOOL, uint64_t, uint64_t))objc_msgSend(a1, "protocolFunctions");
  v12 = objc_msgSend(a1, "captureServer");
  v13 = *a3;
  v14 = *((_QWORD *)a3 + 2);
  v11(v12, v10, &v13, cf == 0, a4, a5);
  ++a1[86];
  if (v10)
    CFRelease(v10);
}

void VCVideoCaptureServer_OnCaptureVideoFrame(uint64_t a1, CMSampleBufferRef sbuf, CMTime *a3, uint64_t a4, uint64_t a5, int a6)
{
  __CVBuffer *ImageBuffer;
  int Width;
  int Height;
  uint64_t v15;
  NSObject *v16;
  NSObject *v17;
  Float64 Seconds;
  uint64_t v19;
  NSObject *v20;
  int v21;
  char v22;
  char v23;
  char v24;
  char v25;
  opaqueCMSampleBuffer *RotatedSampleBuffer;
  char v27;
  uint64_t v28;
  opaqueCMSampleBuffer *v29;
  unsigned __int8 v30;
  char v31;
  char v32;
  uint64_t v33;
  NSObject *v34;
  Float64 v35;
  __int128 v36;
  CMTimeEpoch epoch;
  CMTime time;
  __int128 v39;
  _BYTE v40[24];
  CMTimeEpoch v41;
  unsigned __int8 v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    ImageBuffer = CMSampleBufferGetImageBuffer(sbuf);
    Width = CVPixelBufferGetWidth(ImageBuffer);
    Height = CVPixelBufferGetHeight(ImageBuffer);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v15 = VRTraceErrorLogLevelToCSTR();
      v16 = *MEMORY[0x1E0CF2758];
      v17 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          time = *a3;
          Seconds = CMTimeGetSeconds(&time);
          LODWORD(time.value) = 136316418;
          *(CMTimeValue *)((char *)&time.value + 4) = v15;
          LOWORD(time.flags) = 2080;
          *(_QWORD *)((char *)&time.flags + 2) = "VCVideoCaptureServer_OnCaptureVideoFrame";
          HIWORD(time.epoch) = 1024;
          LODWORD(v39) = 1600;
          WORD2(v39) = 1024;
          *(_DWORD *)((char *)&v39 + 6) = Width;
          WORD5(v39) = 1024;
          HIDWORD(v39) = Height;
          *(_WORD *)v40 = 2048;
          *(Float64 *)&v40[2] = Seconds;
          _os_log_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEFAULT, "VCVideoCaptureServer [%s] %s:%d width=%d, height=%d, frameTime=%f", (uint8_t *)&time, 0x32u);
        }
      }
      else if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        time = *a3;
        v35 = CMTimeGetSeconds(&time);
        LODWORD(time.value) = 136316418;
        *(CMTimeValue *)((char *)&time.value + 4) = v15;
        LOWORD(time.flags) = 2080;
        *(_QWORD *)((char *)&time.flags + 2) = "VCVideoCaptureServer_OnCaptureVideoFrame";
        HIWORD(time.epoch) = 1024;
        LODWORD(v39) = 1600;
        WORD2(v39) = 1024;
        *(_DWORD *)((char *)&v39 + 6) = Width;
        WORD5(v39) = 1024;
        HIDWORD(v39) = Height;
        *(_WORD *)v40 = 2048;
        *(Float64 *)&v40[2] = v35;
        _os_log_debug_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEBUG, "VCVideoCaptureServer [%s] %s:%d width=%d, height=%d, frameTime=%f", (uint8_t *)&time, 0x32u);
      }
    }
    if (objc_msgSend(*(id *)(a1 + 152), "camera") != (_DWORD)a5)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v19 = VRTraceErrorLogLevelToCSTR();
        v20 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v21 = objc_msgSend(*(id *)(a1 + 152), "camera");
          LODWORD(time.value) = 136316162;
          *(CMTimeValue *)((char *)&time.value + 4) = v19;
          LOWORD(time.flags) = 2080;
          *(_QWORD *)((char *)&time.flags + 2) = "VCVideoCaptureServer_OnCaptureVideoFrame";
          HIWORD(time.epoch) = 1024;
          LODWORD(v39) = 1603;
          WORD2(v39) = 1024;
          *(_DWORD *)((char *)&v39 + 6) = v21;
          WORD5(v39) = 1024;
          HIDWORD(v39) = a5;
          _os_log_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_DEFAULT, "VCVideoCaptureServer [%s] %s:%d camera changing from %d -->> %d", (uint8_t *)&time, 0x28u);
        }
      }
      *(_BYTE *)(a1 + 108) = 0;
      objc_msgSend(*(id *)(a1 + 152), "setCamera:", a5);
      objc_msgSend(+[VCAudioSession sharedVoiceChatInstance](VCAudioSession, "sharedVoiceChatInstance"), "selectMicrophoneWithType:", (_DWORD)a5 != 0);
    }
    objc_msgSend(*(id *)(a1 + 152), "setCameraSwitching:", a4);
    v22 = VCCameraStatusBitsFromVideoAttributes(*(void **)(a1 + 152));
    v23 = v22;
    if (a6)
      v24 = 4;
    else
      v24 = 0;
    v25 = v22 & 0xFB;
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 472));
    if (*(_BYTE *)(a1 + 713))
    {
      RotatedSampleBuffer = (opaqueCMSampleBuffer *)FigSampleBufferRetain();
    }
    else
    {
      if ((_DWORD)a5)
        v27 = 0;
      else
        v27 = a6 ^ 1;
      v28 = *(_QWORD *)(a1 + 464);
      time = *a3;
      RotatedSampleBuffer = VCImageRotationConverter_CreateRotatedSampleBuffer(v28, sbuf, (__int128 *)&time.value, v27);
    }
    v29 = RotatedSampleBuffer;
    v30 = v25 | v24;
    if (RotatedSampleBuffer)
    {
      time = *a3;
      _classVTable_0(a1, RotatedSampleBuffer, (uint64_t)&time, a5, v30);
      CFRelease(v29);
    }
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 472));
    if (*(_BYTE *)(a1 + 457))
    {
      v36 = *(_OWORD *)&a3->value;
      epoch = a3->epoch;
      if (a6)
      {
        if ((v23 & 3) == 3)
          v31 = 2;
        else
          v31 = v23 & 3;
        if ((v23 & 3) == 2)
          v32 = 3;
        else
          v32 = v31;
        v30 = v32 | v30 & 0xFC;
      }
      ++*(_DWORD *)(a1 + 48);
      v33 = FigSampleBufferRetain();
      v34 = *(NSObject **)(a1 + 264);
      time.value = MEMORY[0x1E0C809B0];
      *(_QWORD *)&time.timescale = 3221225472;
      time.epoch = (CMTimeEpoch)___VCVideoCaptureServer_ProcessCaptureSampleBuffer_block_invoke;
      *(_QWORD *)&v39 = &unk_1E9E57568;
      *((_QWORD *)&v39 + 1) = a1;
      *(_QWORD *)v40 = v33;
      v42 = v30;
      *(_OWORD *)&v40[8] = v36;
      v41 = epoch;
      dispatch_async(v34, &time);
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCVideoCaptureServer_OnCaptureVideoFrame_cold_1();
  }
}

CMSampleBufferRef VCImageRotationConverter_CreateRotatedSampleBuffer(uint64_t a1, opaqueCMSampleBuffer *a2, __int128 *a3, char a4)
{
  __int128 v5;
  uint64_t v6;
  _QWORD v7[5];
  char v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v7[1] = 3221225472;
  v7[2] = __VCImageRotationConverter_CreateRotatedSampleBuffer_block_invoke;
  v7[3] = &unk_1E9E54A50;
  v7[4] = a1;
  v8 = a4;
  v5 = *a3;
  v6 = *((_QWORD *)a3 + 2);
  v7[0] = MEMORY[0x1E0C809B0];
  return VCImageConverterBase_CreateConvertedSampleBuffer(a1, a2, (uint64_t)&v5, (uint64_t)v7);
}

CMSampleBufferRef VCImageConverterBase_CreateConvertedSampleBuffer(int a1, CMSampleBufferRef sbuf, uint64_t a3, uint64_t a4)
{
  CVImageBufferRef ImageBuffer;
  __CVBuffer *v7;
  __CVBuffer *v8;
  CMSampleBufferRef v9;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (!sbuf)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCImageConverterBase_CreateConvertedSampleBuffer_cold_1();
    }
    return 0;
  }
  ImageBuffer = CMSampleBufferGetImageBuffer(sbuf);
  if (!ImageBuffer)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCImageConverterBase_CreateConvertedSampleBuffer_cold_2();
    }
    return 0;
  }
  v7 = (__CVBuffer *)(*(uint64_t (**)(uint64_t, CVImageBufferRef))(a4 + 16))(a4, ImageBuffer);
  if (!v7)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCImageConverterBase_CreateConvertedSampleBuffer_cold_3();
    }
    return 0;
  }
  v8 = v7;
  v11 = *(_OWORD *)a3;
  v12 = *(_QWORD *)(a3 + 16);
  v9 = createSampleBufferWithPixelBuffer(v7, &v11);
  if (!v9 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCImageConverterBase_CreateConvertedSampleBuffer_cold_4();
  }
  CVPixelBufferRelease(v8);
  return v9;
}

CMSampleBufferRef createSampleBufferWithPixelBuffer(__CVBuffer *a1, __int128 *a2)
{
  const __CFAllocator *v2;
  __int128 v4;
  uint64_t v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v4 = *a2;
  v5 = *((_QWORD *)a2 + 2);
  return VideoUtil_CreateSampleBufferWithPixelBuffer(a1, (uint64_t)&v4, v2, v2);
}

CMSampleBufferRef VideoUtil_CreateSampleBufferWithPixelBuffer(CVImageBufferRef imageBuffer, uint64_t a2, CFAllocatorRef allocator, const __CFAllocator *a4)
{
  __int128 v6;
  CMTimeEpoch v7;
  __int128 v8;
  CMTimeEpoch v9;
  CFTypeRef v10;
  CMVideoFormatDescriptionRef formatDescriptionOut;
  CMSampleTimingInfo sampleTiming;
  CMSampleBufferRef sampleBufferOut[2];

  sampleBufferOut[1] = *(CMSampleBufferRef *)MEMORY[0x1E0C80C00];
  sampleBufferOut[0] = 0;
  if (imageBuffer)
  {
    v6 = *(_OWORD *)(MEMORY[0x1E0CA2E90] + 48);
    *(_OWORD *)&sampleTiming.presentationTimeStamp.timescale = *(_OWORD *)(MEMORY[0x1E0CA2E90] + 32);
    *(_OWORD *)&sampleTiming.decodeTimeStamp.value = v6;
    v7 = *(_QWORD *)(MEMORY[0x1E0CA2E90] + 64);
    v8 = *(_OWORD *)(MEMORY[0x1E0CA2E90] + 16);
    *(_OWORD *)&sampleTiming.duration.value = *MEMORY[0x1E0CA2E90];
    *(_OWORD *)&sampleTiming.duration.epoch = v8;
    *(_OWORD *)&sampleTiming.presentationTimeStamp.value = *(_OWORD *)a2;
    v9 = *(_QWORD *)(a2 + 16);
    sampleTiming.decodeTimeStamp.epoch = v7;
    sampleTiming.presentationTimeStamp.epoch = v9;
    formatDescriptionOut = 0;
    if (CMVideoFormatDescriptionCreateForImageBuffer(allocator, imageBuffer, &formatDescriptionOut))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VideoUtil_CreateSampleBufferWithPixelBuffer_cold_3();
      }
    }
    else if (CMSampleBufferCreateReadyWithImageBuffer(a4, imageBuffer, formatDescriptionOut, &sampleTiming, sampleBufferOut))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VideoUtil_CreateSampleBufferWithPixelBuffer_cold_2();
      }
    }
    else
    {
      v10 = CMGetAttachment(imageBuffer, CFSTR("PropagatableAttachments"), 0);
      if (v10)
        CMSetAttachment(sampleBufferOut[0], CFSTR("TransportLayer"), v10, 1u);
    }
    if (formatDescriptionOut)
      CFRelease(formatDescriptionOut);
    return sampleBufferOut[0];
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoUtil_CreateSampleBufferWithPixelBuffer_cold_1();
    }
    return 0;
  }
}

CVPixelBufferRef VCImageRotationConverter_CreateRotatedPixelBuffer(uint64_t a1, __CVBuffer *a2, int a3)
{
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  OSType PixelFormatType;
  OSType v11;
  int v12;
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  uint64_t v19;
  __int16 v20;
  __CVBuffer *v21;
  __int16 v22;
  char *v23;
  __int16 v24;
  size_t Width;
  __int16 v26;
  size_t Height;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v6 = VRTraceErrorLogLevelToCSTR();
    v7 = *MEMORY[0x1E0CF2758];
    v8 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        PixelFormatType = CVPixelBufferGetPixelFormatType(a2);
        v12 = 136316930;
        v13 = v6;
        v14 = 2080;
        v15 = "VCImageRotationConverter_CreateRotatedPixelBuffer";
        v16 = 1024;
        v17 = 32;
        v18 = 2048;
        v19 = a1;
        v20 = 2048;
        v21 = a2;
        v22 = 2080;
        v23 = FourccToCStr(PixelFormatType);
        v24 = 2048;
        Width = CVPixelBufferGetWidth(a2);
        v26 = 2048;
        Height = CVPixelBufferGetHeight(a2);
        _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d pointer=%p, pixelBuffer=%p, formatType=%s, width=%lu, height=%lu", (uint8_t *)&v12, 0x4Eu);
      }
    }
    else if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      v11 = CVPixelBufferGetPixelFormatType(a2);
      v12 = 136316930;
      v13 = v6;
      v14 = 2080;
      v15 = "VCImageRotationConverter_CreateRotatedPixelBuffer";
      v16 = 1024;
      v17 = 32;
      v18 = 2048;
      v19 = a1;
      v20 = 2048;
      v21 = a2;
      v22 = 2080;
      v23 = FourccToCStr(v11);
      v24 = 2048;
      Width = CVPixelBufferGetWidth(a2);
      v26 = 2048;
      Height = CVPixelBufferGetHeight(a2);
      _os_log_debug_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEBUG, " [%s] %s:%d pointer=%p, pixelBuffer=%p, formatType=%s, width=%lu, height=%lu", (uint8_t *)&v12, 0x4Eu);
    }
  }
  return VCImageRotationConverterBase_CreateRotatedPixelBuffer(a1, a2, a3);
}

CVImageBufferRef _VCAVFoundationCapture_ProcessSampleBufferWithCaptureOutput(CVImageBufferRef result, opaqueCMSampleBuffer *a2, void *a3)
{
  __CVBuffer *v4;
  void *v5;
  void *v6;

  if (a2)
  {
    v4 = result;
    v5 = (void *)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a3, "connectionWithMediaType:", *MEMORY[0x1E0C8A808]), "inputPorts"), "firstObject");
    v6 = (void *)objc_msgSend((id)objc_msgSend(v5, "input"), "device");
    objc_msgSend(v5, "clock");
    return _VCAVFoundationCapture_ProcessSampleBuffer(v4, a2, 0, 0, v6);
  }
  return result;
}

CVImageBufferRef _VCAVFoundationCapture_ProcessSampleBuffer(CVImageBufferRef result, CMSampleBufferRef sbuf, void *a3, void *a4, void *a5)
{
  uint64_t v9;
  __CVBuffer *ImageBuffer;
  int Height;
  uint64_t v12;
  NSObject *v13;
  NSObject *v14;
  const __CFArray *v15;
  CFIndex Count;
  int ErrorLogLevelForModule;
  uint64_t v18;
  NSObject *v19;
  NSObject *v20;
  uint64_t v21;
  NSObject *v22;
  NSObject *v23;
  const __CFArray *ValueAtIndex;
  CFNumberRef v25;
  __CVBuffer *v26;
  CVPixelBufferRef ResizedPixelBuffer;
  __CVBuffer *v28;
  size_t v29;
  size_t v30;
  CMSampleBufferRef SampleBufferWithPixelBuffer;
  opaqueCMSampleBuffer *v32;
  const __CFString *v33;
  uint64_t v34;
  NSObject *v35;
  uint64_t v36;
  uint64_t v37;
  int IsEffectsOn;
  _BOOL4 v39;
  int v40;
  OpaqueCMClock *HostTimeClock;
  OpaqueCMClock *v42;
  double Seconds;
  float v44;
  uint64_t v45;
  NSObject *v46;
  __CVBuffer *v47;
  int v48;
  int v49;
  double v50;
  uint64_t v51;
  uint64_t v52;
  NSObject *v53;
  void *v54;
  void *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  const __CFAllocator *v59;
  OpaqueVTPixelTransferSession *v60;
  __CVPixelBufferPool *v61;
  void *v62;
  void *v63;
  uint64_t v64;
  _BOOL8 v65;
  void *v66;
  void *v67;
  CVImageBufferRef v68;
  __CVBuffer *v69;
  double v70;
  double v71;
  double v72;
  double v73;
  void *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  BOOL v80;
  uint64_t v81;
  void *v82;
  void *v83;
  int v84;
  double v85;
  double v86;
  CGFloat v87;
  CGFloat v88;
  CGFloat v89;
  void *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  id v94;
  __CVBuffer *v95;
  void *v96;
  __CVBuffer *v97;
  int Width;
  void *v99;
  void *v100;
  unint64_t v101;
  void *v102;
  CMSampleBufferRef v103;
  CMTime v104;
  CMTime v105;
  CMTime rhs;
  CMTime time;
  CMTime v108;
  uint64_t v109;
  CMTime buf;
  int v111;
  __int16 v112;
  double v113;
  __int16 v114;
  uint64_t v115;
  _BYTE v116[32];
  __int128 v117;
  __int128 v118;
  uint64_t v119;

  v119 = *MEMORY[0x1E0C80C00];
  if (sbuf)
  {
    v9 = (uint64_t)result;
    result = CMSampleBufferGetImageBuffer(sbuf);
    if (result)
    {
      v99 = a3;
      ImageBuffer = CMSampleBufferGetImageBuffer(sbuf);
      Width = CVPixelBufferGetWidth(ImageBuffer);
      Height = CVPixelBufferGetHeight(ImageBuffer);
      v101 = Height;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v12 = VRTraceErrorLogLevelToCSTR();
        v13 = *MEMORY[0x1E0CF2758];
        v14 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf.value) = 136316162;
            *(CMTimeValue *)((char *)&buf.value + 4) = v12;
            LOWORD(buf.flags) = 2080;
            *(_QWORD *)((char *)&buf.flags + 2) = "_VCAVFoundationCapture_ProcessSampleBuffer";
            HIWORD(buf.epoch) = 1024;
            v111 = 1062;
            v112 = 2048;
            *(_QWORD *)&v113 = Width;
            v114 = 2048;
            v115 = Height;
            _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d width=%lu, height=%lu", (uint8_t *)&buf, 0x30u);
          }
        }
        else if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
        {
          LODWORD(buf.value) = 136316162;
          *(CMTimeValue *)((char *)&buf.value + 4) = v12;
          LOWORD(buf.flags) = 2080;
          *(_QWORD *)((char *)&buf.flags + 2) = "_VCAVFoundationCapture_ProcessSampleBuffer";
          HIWORD(buf.epoch) = 1024;
          v111 = 1062;
          v112 = 2048;
          *(_QWORD *)&v113 = Width;
          v114 = 2048;
          v115 = Height;
          _os_log_debug_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEBUG, " [%s] %s:%d width=%lu, height=%lu", (uint8_t *)&buf, 0x30u);
        }
      }
      ++*(_DWORD *)(v9 + 280);
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        VCVideoUtil_AttachMetadata((const __CFArray *)objc_msgSend(a4, "metadataObjects"), ImageBuffer);
      }
      else
      {
        v15 = *(const __CFArray **)(v9 + 368);
        Count = CFArrayGetCount(v15);
        ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
        if (Count < 1)
        {
          if (ErrorLogLevelForModule >= 8)
          {
            v21 = VRTraceErrorLogLevelToCSTR();
            v22 = *MEMORY[0x1E0CF2758];
            v23 = *MEMORY[0x1E0CF2758];
            if (*MEMORY[0x1E0CF2748])
            {
              if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
              {
                LODWORD(buf.value) = 136315650;
                *(CMTimeValue *)((char *)&buf.value + 4) = v21;
                LOWORD(buf.flags) = 2080;
                *(_QWORD *)((char *)&buf.flags + 2) = "_VCAVFoundationCapture_ProcessSampleBuffer";
                HIWORD(buf.epoch) = 1024;
                v111 = 1083;
                _os_log_impl(&dword_1D8A54000, v22, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d No synchronizer available, No cached meta data, not attaching any meta data to pixel buffer", (uint8_t *)&buf, 0x1Cu);
              }
            }
            else if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
            {
              _VCAVFoundationCapture_ProcessSampleBuffer_cold_5();
            }
          }
        }
        else
        {
          if (ErrorLogLevelForModule >= 8)
          {
            v18 = VRTraceErrorLogLevelToCSTR();
            v19 = *MEMORY[0x1E0CF2758];
            v20 = *MEMORY[0x1E0CF2758];
            if (*MEMORY[0x1E0CF2748])
            {
              if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
              {
                LODWORD(buf.value) = 136315650;
                *(CMTimeValue *)((char *)&buf.value + 4) = v18;
                LOWORD(buf.flags) = 2080;
                *(_QWORD *)((char *)&buf.flags + 2) = "_VCAVFoundationCapture_ProcessSampleBuffer";
                HIWORD(buf.epoch) = 1024;
                v111 = 1074;
                _os_log_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d No synchronizer available, attempting to attach meta data to pixel buffer for face rec", (uint8_t *)&buf, 0x1Cu);
              }
            }
            else if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
            {
              _VCAVFoundationCapture_ProcessSampleBuffer_cold_4();
            }
          }
          ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(v15, 0);
          VCVideoUtil_AttachMetadata(ValueAtIndex, ImageBuffer);
          CFArrayRemoveValueAtIndex(v15, 0);
        }
      }
      if (*(_BYTE *)(v9 + 241))
      {
        LOWORD(buf.value) = 255;
        v25 = CFNumberCreate(*(CFAllocatorRef *)(v9 + 432), kCFNumberSInt16Type, &buf);
        CVBufferSetAttachment(ImageBuffer, CFSTR("CaptureMediaPriorirty"), v25, kCVAttachmentMode_ShouldPropagate);
        if (v25)
          CFRelease(v25);
      }
      memset(&v104, 170, sizeof(v104));
      CMSampleBufferGetPresentationTimeStamp(&v104, sbuf);
      if (*(_BYTE *)(v9 + 336))
      {
        *(CMTime *)v116 = v104;
        v26 = CMSampleBufferGetImageBuffer(sbuf);
        ResizedPixelBuffer = VCImageResizingConverter_CreateResizedPixelBuffer(*(_QWORD *)(v9 + 384), v26);
        if (ResizedPixelBuffer)
        {
          v28 = ResizedPixelBuffer;
          v29 = CVPixelBufferGetWidth(v26);
          v30 = CVPixelBufferGetHeight(v26);
          VCVideoUtil_AdjustFaceMetadata(v28, v29, v30);
          buf = *(CMTime *)v116;
          SampleBufferWithPixelBuffer = createSampleBufferWithPixelBuffer(v28, (__int128 *)&buf.value);
          CMPropagateAttachments(sbuf, SampleBufferWithPixelBuffer);
          CVPixelBufferRelease(v28);
          if (SampleBufferWithPixelBuffer)
          {
            v32 = (opaqueCMSampleBuffer *)CFRetain(SampleBufferWithPixelBuffer);
            goto LABEL_43;
          }
        }
        else if (objc_opt_class() == v9)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              _VCAVFoundationCapture_ProcessSampleBuffer_cold_3();
          }
        }
        else
        {
          if ((objc_opt_respondsToSelector() & 1) != 0)
            *(double *)&v33 = COERCE_DOUBLE(objc_msgSend((id)v9, "performSelector:", sel_logPrefix));
          else
            *(double *)&v33 = COERCE_DOUBLE(&stru_1E9E58EE0);
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            v34 = VRTraceErrorLogLevelToCSTR();
            v35 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            {
              LODWORD(buf.value) = 136316162;
              *(CMTimeValue *)((char *)&buf.value + 4) = v34;
              LOWORD(buf.flags) = 2080;
              *(_QWORD *)((char *)&buf.flags + 2) = "VCAVFoundationCapture_CopyResizedFrame";
              HIWORD(buf.epoch) = 1024;
              v111 = 742;
              v112 = 2112;
              v113 = *(double *)&v33;
              v114 = 2048;
              v115 = v9;
              _os_log_error_impl(&dword_1D8A54000, v35, OS_LOG_TYPE_ERROR, " [%s] %s:%d %@(%p) newResizedPixelBuffer failed", (uint8_t *)&buf, 0x30u);
            }
          }
        }
      }
      objc_msgSend(*(id *)(v9 + 376), "ensureBufferPoolSupportsOutputWidth:outputHeight:", Width, Height);
      v36 = *(_QWORD *)(v9 + 376);
      buf = v104;
      v32 = VCImageResizingConverter_CreateResizedSampleBuffer(v36, sbuf, &buf);
LABEL_43:
      v103 = v32;
      if (v32)
      {
        v37 = VCEffectsManager_SharedManager();
        IsEffectsOn = VCEffectsManager_IsEffectsOn(v37);
        if (*(_QWORD *)(v9 + 408) && a5 && *(_BYTE *)(v9 + 225) && objc_msgSend(a5, "position") == 2)
        {
          v39 = !VCDefaults_GetBoolValueForKey(CFSTR("VPCDisableDuringCenterStage"), 0);
          if (((IsEffectsOn | v39) & 1) != 0)
            v40 = v39 & ~IsEffectsOn;
          else
            v40 = *(_BYTE *)(v9 + 228) == 0;
          ++*(_DWORD *)(v9 + 272);
          LOBYTE(v105.value) = 0;
          memset(v116, 170, 24);
          HostTimeClock = CMClockGetHostTimeClock();
          CMClockGetTime((CMTime *)v116, HostTimeClock);
          VCViewpointCorrection_CorrectViewpoint(*(_QWORD *)(v9 + 408), v32, (void *)objc_msgSend(*(id *)(v9 + 216), "activeFormat"), v40, (uint64_t)&v105);
          memset(&v108, 170, sizeof(v108));
          v42 = CMClockGetHostTimeClock();
          CMClockGetTime(&v108, v42);
          if (LOBYTE(v105.value))
            ++*(_DWORD *)(v9 + 276);
          buf = v108;
          rhs = *(CMTime *)v116;
          CMTimeSubtract(&time, &buf, &rhs);
          Seconds = CMTimeGetSeconds(&time);
          v44 = Seconds + *(float *)(v9 + 356);
          *(float *)(v9 + 356) = v44;
          if (Seconds > 0.0167 && (int)VRTraceGetErrorLogLevelForModule() >= 5)
          {
            v45 = VRTraceErrorLogLevelToCSTR();
            v46 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(buf.value) = 136315906;
              *(CMTimeValue *)((char *)&buf.value + 4) = v45;
              LOWORD(buf.flags) = 2080;
              *(_QWORD *)((char *)&buf.flags + 2) = "_VCAVFoundationCapture_ProcessViewPointCorrection";
              HIWORD(buf.epoch) = 1024;
              v111 = 1186;
              v112 = 2048;
              v113 = Seconds;
              _os_log_impl(&dword_1D8A54000, v46, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Viewpoint frame took longer than real time: %f", (uint8_t *)&buf, 0x26u);
            }
          }
        }
        if (IsEffectsOn)
        {
          if (*(_BYTE *)(v9 + 448))
          {
            if (!*(_QWORD *)(v9 + 456))
            {
              VTPixelTransferSessionCreate(0, (VTPixelTransferSessionRef *)(v9 + 456));
              VTPixelTransferSessionCreate(0, (VTPixelTransferSessionRef *)(v9 + 472));
            }
            v47 = CMSampleBufferGetImageBuffer(v32);
            v48 = CVPixelBufferGetWidth(v47);
            v49 = CVPixelBufferGetHeight(v47);
            if (!VCMediaRecorderUtil_PixelBufferPoolMatchDimensions(*(__CVPixelBufferPool **)(v9 + 464), v48, v49)|| (VCMediaRecorderUtil_PixelBufferPoolMatchDimensions(*(__CVPixelBufferPool **)(v9 + 480), v48, v49) & 1) == 0)
            {
              *(_QWORD *)&v50 = v48;
              v51 = v49;
              CVPixelBufferPoolRelease(*(CVPixelBufferPoolRef *)(v9 + 464));
              CVPixelBufferPoolRelease(*(CVPixelBufferPoolRef *)(v9 + 480));
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v52 = VRTraceErrorLogLevelToCSTR();
                v53 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                {
                  LODWORD(buf.value) = 136316162;
                  *(CMTimeValue *)((char *)&buf.value + 4) = v52;
                  LOWORD(buf.flags) = 2080;
                  *(_QWORD *)((char *)&buf.flags + 2) = "_VCAVFoundationCapture_CreateBufferPools";
                  HIWORD(buf.epoch) = 1024;
                  v111 = 830;
                  v112 = 2048;
                  v113 = v50;
                  v114 = 2048;
                  v115 = v51;
                  _os_log_impl(&dword_1D8A54000, v53, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d width=%zu height=%zu", (uint8_t *)&buf, 0x30u);
                }
              }
              v54 = (void *)objc_opt_new();
              objc_msgSend(v54, "setObject:forKeyedSubscript:", MEMORY[0x1E0C9AAB0], *MEMORY[0x1E0CBC018]);
              objc_msgSend(v54, "setObject:forKeyedSubscript:", CFSTR("AVConference:FoundationCapture"), *MEMORY[0x1E0CBC048]);
              v55 = (void *)objc_opt_new();
              v56 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLong:", *(_QWORD *)&v50);
              objc_msgSend(v55, "setObject:forKeyedSubscript:", v56, *MEMORY[0x1E0CA90E0]);
              v57 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLong:", v51);
              objc_msgSend(v55, "setObject:forKeyedSubscript:", v57, *MEMORY[0x1E0CA8FD8]);
              objc_msgSend(v55, "setObject:forKeyedSubscript:", v54, *MEMORY[0x1E0CA8FF0]);
              v58 = *MEMORY[0x1E0CA9040];
              objc_msgSend(v55, "setObject:forKeyedSubscript:", &unk_1E9EF5330, *MEMORY[0x1E0CA9040]);
              v59 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
              CVPixelBufferPoolCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, (CFDictionaryRef)v55, (CVPixelBufferPoolRef *)(v9 + 464));
              objc_msgSend(v55, "setObject:forKeyedSubscript:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", *(unsigned int *)(v9 + 444)), v58);
              CVPixelBufferPoolCreate(v59, 0, (CFDictionaryRef)v55, (CVPixelBufferPoolRef *)(v9 + 480));

            }
            v60 = *(OpaqueVTPixelTransferSession **)(v9 + 456);
            v61 = *(__CVPixelBufferPool **)(v9 + 464);
            buf = v104;
            _VCAVFoundationCapture_ConvertPixelFormat(v60, v61, &v103, (uint64_t)&buf);
            v32 = v103;
          }
          if (VCAVFoundationGetARImageData_onceToken != -1)
            dispatch_once(&VCAVFoundationGetARImageData_onceToken, &__block_literal_global_4);
          v62 = (void *)objc_msgSend(objc_alloc((Class)VCAVFoundationGetARImageData_cls), "initWithSampleBuffer:captureFramePerSecond:captureDevice:captureSession:", v32, *(int *)(v9 + 260), a5, *(_QWORD *)(v9 + 176));
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) != 0)
          {
            v63 = (void *)objc_msgSend(v99, "depthData");
            if (v63)
              objc_msgSend(v62, "setDepthData:", v63);
          }
          else
          {
            v63 = 0;
          }
          if (VCAVFoundationGetARFaceData_onceToken != -1)
            dispatch_once(&VCAVFoundationGetARFaceData_onceToken, &__block_literal_global_6);
          v66 = (void *)objc_opt_new();
          v67 = (void *)objc_opt_new();
          objc_msgSend(v66, "setDetectedFaces:", v67);
          objc_msgSend(v62, "setFaceData:", v66);
          v68 = CMSampleBufferGetImageBuffer(v32);
          if (v68)
          {
            v69 = v68;
            v70 = (double)(unint64_t)Width;
            v71 = (double)v101;
            CFRetain(v68);
            memset(&v108, 170, sizeof(v108));
            CMSampleBufferGetPresentationTimeStamp(&v108, v32);
            v72 = (double)CVPixelBufferGetWidth(v69);
            v73 = (double)CVPixelBufferGetHeight(v69);
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) != 0)
            {
              v97 = v69;
              v100 = v63;
              v102 = v62;
              v117 = 0u;
              v118 = 0u;
              memset(v116, 0, sizeof(v116));
              v74 = (void *)objc_msgSend(a4, "metadataObjects");
              v75 = objc_msgSend(v74, "countByEnumeratingWithState:objects:count:", v116, &buf, 16);
              if (v75)
              {
                v76 = v75;
                v77 = **(_QWORD **)&v116[16];
                v78 = *MEMORY[0x1E0C8AA68];
                v79 = *MEMORY[0x1E0C8AA38];
                v80 = v71 == v73 && v70 == v72;
                v96 = v66;
                while (2)
                {
                  v81 = 0;
                  do
                  {
                    if (**(_QWORD **)&v116[16] != v77)
                      objc_enumerationMutation(v74);
                    v82 = *(void **)(*(_QWORD *)&v116[8] + 8 * v81);
                    if (objc_msgSend((id)objc_msgSend(v82, "type"), "isEqual:", v78))
                    {
                      v66 = v96;
                      objc_msgSend(v96, "setFaceMeshPayload:", objc_msgSend(v82, "payload"));
                      goto LABEL_108;
                    }
                    if (objc_msgSend((id)objc_msgSend(v82, "type"), "isEqual:", v79))
                    {
                      if (VCGetARHWFaceDetection_onceToken != -1)
                        dispatch_once(&VCGetARHWFaceDetection_onceToken, &__block_literal_global_8);
                      v83 = (void *)objc_opt_new();
                      objc_msgSend(v83, "setID:", objc_msgSend(v82, "faceID"));
                      v84 = objc_msgSend(v82, "hasRollAngle");
                      v85 = 0.0;
                      if (v84)
                        objc_msgSend(v82, "rollAngle", 0.0);
                      objc_msgSend(v83, "setRollAngleInDegrees:", v85);
                      objc_msgSend(v82, "bounds");
                      if (!v80)
                        v86 = VCVideoUtil_AdjustFaceBounds(v86, v87, v88, v89, v70, v71, v72, v73);
                      objc_msgSend(v83, "setBoundingBox:", v86);
                      objc_msgSend(v83, "setDetectionOrientation:", 4);
                      if (v82)
                        objc_msgSend(v82, "time");
                      else
                        memset(&time, 0, sizeof(time));
                      rhs = time;
                      objc_msgSend(v83, "setTime:", &rhs);
                      objc_msgSend(v67, "addObject:", v83);

                    }
                    ++v81;
                  }
                  while (v76 != v81);
                  v76 = objc_msgSend(v74, "countByEnumeratingWithState:objects:count:", v116, &buf, 16);
                  v66 = v96;
                  if (v76)
                    continue;
                  break;
                }
              }
LABEL_108:
              v62 = v102;
              v63 = v100;
              v69 = v97;
              if (!objc_msgSend((id)objc_msgSend((id)objc_msgSend(v102, "faceData"), "detectedFaces"), "count"))
              {
                v90 = (void *)objc_msgSend((id)objc_msgSend((id)objc_msgSend(v102, "faceData"), "faceMeshPayload"), "objectForKeyedSubscript:", VCGetCVAFaceTracking_DetectedFacesArray());
                if (VCGetARHWFaceDetection_onceToken != -1)
                  dispatch_once(&VCGetARHWFaceDetection_onceToken, &__block_literal_global_8);
                v91 = objc_msgSend((id)VCGetARHWFaceDetection_cls, "faceDetectionFromDictionary:", objc_msgSend(v90, "firstObject"));
                if (v91)
                {
                  v109 = v91;
                  v92 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v109, 1);
                }
                else
                {
                  v92 = 0;
                }
                objc_msgSend((id)objc_msgSend(v102, "faceData"), "setDetectedFaces:", v92);
              }
            }
            if (v70 != v72 || v71 != v73)
            {
              ((void (*)(uint64_t))sVC_ARAdjustIntrinsicsForViewportSize)(objc_msgSend(v62, "cameraIntrinsics"));
              objc_msgSend(v62, "setCameraIntrinsics:");
            }
            v93 = objc_msgSend(MEMORY[0x1E0CB36F8], "archivedDataWithRootObject:requiringSecureCoding:error:", v62, 1, 0);
            v94 = +[VCEffectsManager sharedManager](VCEffectsManager, "sharedManager");
            v95 = (__CVBuffer *)objc_msgSend(v63, "depthDataMap");
            v105 = v108;
            VCEffectsManager_CapturedPixelBuffer((uint64_t)v94, v69, v95, (__int128 *)&v105.value, v93);
            CVPixelBufferRelease(v69);
          }
          else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              _VCAVFoundationCapture_ProcessSampleBuffer_cold_2();
          }

          v32 = v103;
          if (!v103)
            return (CVImageBufferRef)FigSampleBufferRelease();
        }
        else
        {
          memset(&buf, 170, sizeof(buf));
          CMSampleBufferGetPresentationTimeStamp(&buf, v32);
          if (*(_BYTE *)(v9 + 418))
          {
            v64 = *(_QWORD *)(v9 + 424);
            *(_DWORD *)v64 = Width;
            *(_DWORD *)(v64 + 4) = Height;
            *(CMTime *)v116 = buf;
            *(Float64 *)(v64 + 32) = CMTimeGetSeconds((CMTime *)v116);
            *(_BYTE *)(v64 + 8) = 0;
          }
          v65 = (objc_msgSend((id)v9, "captureDevicePosition") & 0xFFFFFFFFFFFFFFFDLL) != 0;
          *(CMTime *)v116 = buf;
          _VCAVFoundationCapture_PushFrameToCaptureServer((_DWORD *)v9, v32, (__int128 *)v116, v65, 0);
        }
        CFRelease(v32);
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCAVFoundationCapture_ProcessSampleBuffer_cold_1();
      }
      return (CVImageBufferRef)FigSampleBufferRelease();
    }
  }
  return result;
}

BOOL VCEffectsManager_IsEffectsOn(uint64_t a1)
{
  NSObject *v1;
  _BOOL8 v2;
  _QWORD block[6];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  char v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v8 = 0;
  if (a1)
  {
    v1 = *(NSObject **)(a1 + 24);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = __VCEffectsManager_IsEffectsOn_block_invoke;
    block[3] = &unk_1E9E522B0;
    block[4] = a1;
    block[5] = &v5;
    dispatch_sync(v1, block);
    v2 = *((_BYTE *)v6 + 24) != 0;
  }
  else
  {
    v2 = 0;
  }
  _Block_object_dispose(&v5, 8);
  return v2;
}

CMSampleBufferRef VCImageResizingConverter_CreateResizedSampleBuffer(uint64_t a1, CMSampleBufferRef sbuf, CMTime *a3)
{
  opaqueCMSampleBuffer *v4;
  __CVBuffer *ImageBuffer;
  uint64_t v7;
  NSObject *v8;
  NSObject *v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD v18[5];
  CMTime time2;
  CMTime buf;
  int v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  __CVBuffer *v25;
  __int16 v26;
  char *v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  uint64_t v31;
  uint64_t v32;

  v4 = sbuf;
  v32 = *MEMORY[0x1E0C80C00];
  ImageBuffer = CMSampleBufferGetImageBuffer(sbuf);
  if (CVPixelBufferGetPixelFormatType(ImageBuffer) != *(_DWORD *)(a1 + 16)
    || CVPixelBufferGetWidth(ImageBuffer) != *(_QWORD *)(a1 + 24)
    || CVPixelBufferGetHeight(ImageBuffer) != *(_QWORD *)(a1 + 32))
  {
    v18[0] = MEMORY[0x1E0C809B0];
    v18[1] = 3221225472;
    v18[2] = __VCImageResizingConverter_CreateResizedSampleBuffer_block_invoke;
    v18[3] = &unk_1E9E55560;
    v18[4] = a1;
    buf = *a3;
    return VCImageConverterBase_CreateConvertedSampleBuffer(a1, v4, (uint64_t)&buf, (uint64_t)v18);
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v7 = VRTraceErrorLogLevelToCSTR();
    v8 = *MEMORY[0x1E0CF2758];
    v9 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        v10 = FourccToCStr(*(_DWORD *)(a1 + 16));
        v11 = *(_QWORD *)(a1 + 24);
        v12 = *(_QWORD *)(a1 + 32);
        LODWORD(buf.value) = 136316930;
        *(CMTimeValue *)((char *)&buf.value + 4) = v7;
        LOWORD(buf.flags) = 2080;
        *(_QWORD *)((char *)&buf.flags + 2) = "VCImageResizingConverter_CreateResizedSampleBuffer";
        HIWORD(buf.epoch) = 1024;
        v21 = 91;
        v22 = 2048;
        v23 = a1;
        v24 = 2048;
        v25 = ImageBuffer;
        v26 = 2080;
        v27 = v10;
        v28 = 2048;
        v29 = v11;
        v30 = 2048;
        v31 = v12;
        _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Skipping resizing -- input/output sizes are the same; pointer=%p, pixelBuffer=%p, formatType=%s, w"
          "idth=%lu, height=%lu",
          (uint8_t *)&buf,
          0x4Eu);
      }
    }
    else if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      v15 = FourccToCStr(*(_DWORD *)(a1 + 16));
      v16 = *(_QWORD *)(a1 + 24);
      v17 = *(_QWORD *)(a1 + 32);
      LODWORD(buf.value) = 136316930;
      *(CMTimeValue *)((char *)&buf.value + 4) = v7;
      LOWORD(buf.flags) = 2080;
      *(_QWORD *)((char *)&buf.flags + 2) = "VCImageResizingConverter_CreateResizedSampleBuffer";
      HIWORD(buf.epoch) = 1024;
      v21 = 91;
      v22 = 2048;
      v23 = a1;
      v24 = 2048;
      v25 = ImageBuffer;
      v26 = 2080;
      v27 = v15;
      v28 = 2048;
      v29 = v16;
      v30 = 2048;
      v31 = v17;
      _os_log_debug_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Skipping resizing -- input/output sizes are the same; pointer=%p, pixelBuffer=%p, formatType=%s, wid"
        "th=%lu, height=%lu",
        (uint8_t *)&buf,
        0x4Eu);
    }
  }
  CMSampleBufferGetPresentationTimeStamp(&time2, v4);
  buf = *a3;
  if (CMTimeCompare(&buf, &time2))
  {
    buf = *a3;
    return _VCImageResizingConverter_CreateSampleBufferWithNewTiming(v4, (uint64_t)&buf);
  }
  if (v4)
    CFRetain(v4);
  return v4;
}

uint64_t VCEffectsManager_SharedManager()
{
  if (VCEffectsManager_SharedManager_onceToken != -1)
    dispatch_once(&VCEffectsManager_SharedManager_onceToken, &__block_literal_global_104);
  return VCEffectsManager_SharedManager__vcEffectsManager;
}

uint64_t VCViewpointCorrection_CorrectViewpoint(uint64_t a1, opaqueCMSampleBuffer *a2, void *a3, int a4, uint64_t a5)
{
  const __CFAllocator *v10;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v12;
  CVImageBufferRef ImageBuffer;
  CFNumberRef v14;
  CFNumberRef v15;
  const __CFData *v16;
  __int128 v17;
  const __CFData *v18;
  float v19;
  long double v20;
  uint64_t v21;
  CFNumberRef v22;
  CFNumberRef v23;
  CFNumberRef v24;
  CFNumberRef v25;
  CFNumberRef v26;
  CFNumberRef v27;
  CFNumberRef v28;
  CFNumberRef v29;
  CFNumberRef v30;
  CFNumberRef v31;
  CFArrayRef v32;
  CFArrayRef v33;
  CFArrayRef v34;
  CFArrayRef v35;
  CFArrayRef v36;
  CFArrayRef v37;
  CFArrayRef v38;
  CFArrayRef CameraExtrinsicsArray;
  CFArrayRef v40;
  const __CFNumber *v41;
  CFNumberRef v42;
  CFDictionaryRef v43;
  CFDictionaryRef v44;
  NSObject *v45;
  uint64_t v46;
  NSObject *v47;
  NSObject *v48;
  Float64 Seconds;
  uint64_t v50;
  Float64 v52;
  CFNumberRef v53;
  CMVideoDimensions cfa;
  CFNumberRef cf;
  opaqueCMSampleBuffer *v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD value[6];
  CMTime v60;
  int v61;
  double v62;
  void *v63[3];
  void *v64[3];
  void *v65[3];
  void *values[3];
  _BYTE valuePtr[48];
  uint64_t v68;
  CFRange v69;

  v68 = *MEMORY[0x1E0C80C00];
  v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    v12 = Mutable;
    ImageBuffer = CMSampleBufferGetImageBuffer(a2);
    CFDictionarySetValue(v12, (const void *)sVC_CVAViewpointCorrection_Image, ImageBuffer);
    *(_DWORD *)valuePtr = a4;
    v14 = CFNumberCreate(v10, kCFNumberIntType, valuePtr);
    if (v14)
    {
      v15 = v14;
      CFDictionarySetValue(v12, (const void *)sVC_CVAViewpointCorrection_EnableCorrection, v14);
      CFRelease(v15);
    }
    v16 = (const __CFData *)CMGetAttachment(a2, (CFStringRef)*MEMORY[0x1E0CA2638], 0);
    v17 = *(_OWORD *)(MEMORY[0x1E0C83FE8] + 16);
    *(_OWORD *)valuePtr = *MEMORY[0x1E0C83FE8];
    *(_OWORD *)&valuePtr[16] = v17;
    *(_OWORD *)&valuePtr[32] = *(_OWORD *)(MEMORY[0x1E0C83FE8] + 32);
    if (v16 && (v18 = v16, CFDataGetLength(v16) >= 48))
    {
      v69.location = 0;
      v69.length = 48;
      CFDataGetBytes(v18, v69, valuePtr);
    }
    else
    {
      if ((void *)_VCViewpointCorrection_CreateCameraIntrinsicsArray_format != a3)
      {
        _VCViewpointCorrection_CreateCameraIntrinsicsArray_format = (uint64_t)a3;
        cfa = CMVideoFormatDescriptionGetDimensions((CMVideoFormatDescriptionRef)objc_msgSend(a3, "formatDescription"));
        objc_msgSend(a3, "videoFieldOfView");
        v20 = tan(v19 * 3.14159265 / 180.0 * 0.5);
        *(float *)&v20 = (double)cfa.width / (v20 + v20);
        LODWORD(v21) = 0;
        HIDWORD(v21) = LODWORD(v20);
        DWORD2(_VCViewpointCorrection_CreateCameraIntrinsicsArray_fallbackIntrinsics) = 0;
        *(_QWORD *)&_VCViewpointCorrection_CreateCameraIntrinsicsArray_fallbackIntrinsics = LODWORD(v20);
        dword_1F01BD958 = 0;
        qword_1F01BD950 = v21;
        DWORD2(xmmword_1F01BD960) = 1065353216;
        *(float32x2_t *)&xmmword_1F01BD960 = vadd_f32(vmul_f32(vcvt_f32_s32((int32x2_t)cfa), (float32x2_t)0x3F0000003F000000), (float32x2_t)0xBF000000BF000000);
      }
      *(_OWORD *)valuePtr = _VCViewpointCorrection_CreateCameraIntrinsicsArray_fallbackIntrinsics;
      *(_OWORD *)&valuePtr[16] = *(_OWORD *)&qword_1F01BD950;
      *(_OWORD *)&valuePtr[32] = xmmword_1F01BD960;
    }
    v62 = *(float *)valuePtr;
    v22 = CFNumberCreate(v10, kCFNumberCGFloatType, &v62);
    if (!v22)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCViewpointCorrection_CorrectViewpoint_cold_3();
      }
      goto LABEL_37;
    }
    v23 = v22;
    v62 = *(float *)&valuePtr[20];
    v24 = CFNumberCreate(v10, kCFNumberCGFloatType, &v62);
    if (v24)
    {
      v25 = v24;
      v62 = *(float *)&valuePtr[32];
      v26 = CFNumberCreate(v10, kCFNumberCGFloatType, &v62);
      v57 = a5;
      v58 = a1;
      v56 = a2;
      v53 = v25;
      cf = v23;
      if (v26)
      {
        v62 = *(float *)&valuePtr[36];
        v27 = CFNumberCreate(v10, kCFNumberCGFloatType, &v62);
        v62 = 0.0;
        v28 = CFNumberCreate(v10, kCFNumberCGFloatType, &v62);
        if (v28)
        {
          v29 = v28;
          v62 = 1.0;
          v30 = CFNumberCreate(v10, kCFNumberCGFloatType, &v62);
          if (v30)
          {
            v31 = v30;
            values[0] = v23;
            values[1] = v29;
            values[2] = v26;
            v65[0] = v29;
            v65[1] = v25;
            v65[2] = v27;
            v64[0] = v29;
            v64[1] = v29;
            v64[2] = v30;
            v32 = CFArrayCreate(v10, (const void **)values, 3, MEMORY[0x1E0C9B378]);
            if (v32)
            {
              v33 = v32;
              v34 = CFArrayCreate(v10, (const void **)v65, 3, MEMORY[0x1E0C9B378]);
              if (v34)
              {
                v35 = v34;
                v36 = CFArrayCreate(v10, (const void **)v64, 3, MEMORY[0x1E0C9B378]);
                if (v36)
                {
                  v37 = v36;
                  v63[0] = v33;
                  v63[1] = v35;
                  v63[2] = v36;
                  v38 = CFArrayCreate(v10, (const void **)v63, 3, MEMORY[0x1E0C9B378]);
                  if (v38)
                  {
                    v23 = v38;
                  }
                  else
                  {
                    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                    {
                      VRTraceErrorLogLevelToCSTR();
                      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                        VCViewpointCorrection_CorrectViewpoint_cold_11();
                    }
                    v23 = 0;
                  }
                }
                else
                {
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                  {
                    VRTraceErrorLogLevelToCSTR();
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                      VCViewpointCorrection_CorrectViewpoint_cold_10();
                  }
                  v23 = 0;
                  v37 = 0;
                }
              }
              else
              {
                if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                {
                  VRTraceErrorLogLevelToCSTR();
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                    VCViewpointCorrection_CorrectViewpoint_cold_9();
                }
                v23 = 0;
                v37 = 0;
                v35 = 0;
              }
            }
            else
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  VCViewpointCorrection_CorrectViewpoint_cold_8();
              }
              v23 = 0;
              v37 = 0;
              v35 = 0;
              v33 = 0;
            }
          }
          else
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                VCViewpointCorrection_CorrectViewpoint_cold_7();
            }
            v23 = 0;
            v37 = 0;
            v35 = 0;
            v33 = 0;
            v31 = 0;
          }
        }
        else
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VCViewpointCorrection_CorrectViewpoint_cold_6();
          }
          v23 = 0;
          v37 = 0;
          v35 = 0;
          v33 = 0;
          v31 = 0;
          v29 = 0;
        }
      }
      else
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCViewpointCorrection_CorrectViewpoint_cold_5();
        }
        v23 = 0;
        v37 = 0;
        v35 = 0;
        v33 = 0;
        v31 = 0;
        v29 = 0;
        v27 = 0;
      }
      CFRelease(cf);
      CFRelease(v53);
      if (v26)
        CFRelease(v26);
      if (v27)
        CFRelease(v27);
      if (v33)
        CFRelease(v33);
      a2 = v56;
      if (v35)
        CFRelease(v35);
      if (v37)
        CFRelease(v37);
      a5 = v57;
      if (v29)
        CFRelease(v29);
      a1 = v58;
      if (v31)
        CFRelease(v31);
      if (!v23)
        goto LABEL_37;
      CFDictionarySetValue(v12, (const void *)sVC_CVAViewpointCorrection_Intrinsics, v23);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCViewpointCorrection_CorrectViewpoint_cold_4();
    }
    CFRelease(v23);
LABEL_37:
    CameraExtrinsicsArray = _VCViewpointCorrection_CreateCameraExtrinsicsArray(a2);
    if (CameraExtrinsicsArray)
    {
      v40 = CameraExtrinsicsArray;
      CFDictionarySetValue(v12, (const void *)sVC_CVAViewpointCorrection_VirtualCameraExtrinsics, CameraExtrinsicsArray);
      CFRelease(v40);
    }
    v61 = 0;
    v41 = (const __CFNumber *)CMGetAttachment(a2, (CFStringRef)*MEMORY[0x1E0D04100], 0);
    if (v41)
    {
      CFNumberGetValue(v41, kCFNumberFloatType, &v61);
      v42 = CFNumberCreate(v10, kCFNumberFloatType, &v61);
      CFDictionarySetValue(v12, (const void *)sVC_CVAViewpointCorrection_StereographicFisheyeStrength, v42);
      CFRelease(v42);
    }
    memset(&v60, 170, sizeof(v60));
    CMSampleBufferGetPresentationTimeStamp(&v60, a2);
    *(CMTime *)valuePtr = v60;
    v43 = CMTimeCopyAsDictionary((CMTime *)valuePtr, 0);
    if (v43)
    {
      v44 = v43;
      CFDictionarySetValue(v12, (const void *)sVC_CVAViewpointCorrection_Timestamp, v43);
      CFRelease(v44);
    }
    v45 = dispatch_semaphore_create(0);
    value[0] = MEMORY[0x1E0C809B0];
    value[1] = 3221225472;
    value[2] = __VCViewpointCorrection_CorrectViewpoint_block_invoke;
    value[3] = &unk_1E9E56D70;
    value[4] = v45;
    value[5] = a5;
    CFDictionarySetValue(v12, (const void *)sVC_CVAViewpointCorrection_Callback, value);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v46 = VRTraceErrorLogLevelToCSTR();
      v47 = *MEMORY[0x1E0CF2758];
      v48 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
        {
          *(CMTime *)valuePtr = v60;
          Seconds = CMTimeGetSeconds((CMTime *)valuePtr);
          *(_DWORD *)valuePtr = 136315906;
          *(_QWORD *)&valuePtr[4] = v46;
          *(_WORD *)&valuePtr[12] = 2080;
          *(_QWORD *)&valuePtr[14] = "VCViewpointCorrection_CorrectViewpoint";
          *(_WORD *)&valuePtr[22] = 1024;
          *(_DWORD *)&valuePtr[24] = 314;
          *(_WORD *)&valuePtr[28] = 2048;
          *(Float64 *)&valuePtr[30] = Seconds;
          _os_log_impl(&dword_1D8A54000, v47, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Viewpoint Correction for timestamp: %f", valuePtr, 0x26u);
        }
      }
      else if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
      {
        *(CMTime *)valuePtr = v60;
        v52 = CMTimeGetSeconds((CMTime *)valuePtr);
        *(_DWORD *)valuePtr = 136315906;
        *(_QWORD *)&valuePtr[4] = v46;
        *(_WORD *)&valuePtr[12] = 2080;
        *(_QWORD *)&valuePtr[14] = "VCViewpointCorrection_CorrectViewpoint";
        *(_WORD *)&valuePtr[22] = 1024;
        *(_DWORD *)&valuePtr[24] = 314;
        *(_WORD *)&valuePtr[28] = 2048;
        *(Float64 *)&valuePtr[30] = v52;
        _os_log_debug_impl(&dword_1D8A54000, v47, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Viewpoint Correction for timestamp: %f", valuePtr, 0x26u);
      }
    }
    v50 = sVC_CVAViewpointCorrectionProcessFunc(*(_QWORD *)(a1 + 8), v12);
    if ((_DWORD)v50)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCViewpointCorrection_CorrectViewpoint_cold_2();
      }
    }
    else
    {
      dispatch_semaphore_wait(v45, 0xFFFFFFFFFFFFFFFFLL);
    }
    CFRelease(v12);
    goto LABEL_55;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCViewpointCorrection_CorrectViewpoint_cold_1();
  }
  v50 = 0;
  v45 = 0;
LABEL_55:
  dispatch_release(v45);
  return v50;
}

CFArrayRef _VCViewpointCorrection_CreateCameraExtrinsicsArray(const void *a1)
{
  float v2;
  __int128 v3;
  __int128 v4;
  float v5;
  double v6;
  double v7;
  double v8;
  const __CFArray *v9;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  _QWORD v14[4];
  _QWORD v15[4];
  _QWORD v16[4];
  _QWORD v17[3];
  __int128 v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v2 = VCHardwareSettings_FrontCameraOffsetFromDisplayCenter();
  *(_QWORD *)&v3 = COERCE_UNSIGNED_INT(1.0);
  DWORD2(v3) = 0;
  *((float *)&v3 + 3) = v2;
  v18 = v3;
  v5 = *(double *)&v4;
  LODWORD(v4) = 0;
  DWORD1(v4) = 1.0;
  DWORD2(v4) = 0;
  *((float *)&v4 + 3) = v5;
  v19 = v4;
  v20 = xmmword_1D910E930;
  _VCViewpointCorrection_UpdateCenterStageTransform((uint64_t)&v18, a1);
  v11 = v18;
  v16[0] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:");
  HIDWORD(v6) = DWORD1(v11);
  LODWORD(v6) = DWORD1(v11);
  v16[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v6);
  v16[2] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(DWORD1(v11), DWORD2(v11))));
  v16[3] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(DWORD1(v11), HIDWORD(v11))));
  v17[0] = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v16, 4);
  v12 = v19;
  v15[0] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:");
  HIDWORD(v7) = DWORD1(v12);
  LODWORD(v7) = DWORD1(v12);
  v15[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v7);
  v15[2] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(DWORD1(v12), DWORD2(v12))));
  v15[3] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(DWORD1(v12), HIDWORD(v12))));
  v17[1] = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v15, 4);
  v13 = v20;
  v14[0] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:");
  HIDWORD(v8) = DWORD1(v13);
  LODWORD(v8) = DWORD1(v13);
  v14[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v8);
  v14[2] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(DWORD1(v13), DWORD2(v13))));
  v14[3] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(DWORD1(v13), HIDWORD(v13))));
  v17[2] = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v14, 4);
  v9 = (const __CFArray *)objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v17, 3);
  return CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v9);
}

CVPixelBufferRef VCImageRotationConverterBase_CreateRotatedPixelBuffer(uint64_t a1, CVPixelBufferRef pixelBuffer, int a3)
{
  size_t Width;
  size_t Height;
  size_t v8;
  int v9;
  size_t v10;
  size_t v11;
  __CVPixelBufferPool *v12;
  _QWORD *v13;
  int v14;
  int ErrorLogLevelForModule;
  uint64_t v16;
  NSObject *v17;
  NSObject *v18;
  CVPixelBufferRef v19;
  OSType PixelFormatType;
  char *v21;
  size_t v22;
  size_t v23;
  CVPixelBufferRef v25;
  OSType v26;
  char *v27;
  size_t v28;
  size_t v29;
  uint64_t v30;
  NSObject *v31;
  size_t v32;
  size_t v33;
  CVPixelBufferRef pixelBufferOut;
  uint8_t buf[4];
  uint64_t v36;
  __int16 v37;
  const char *v38;
  __int16 v39;
  int v40;
  __int16 v41;
  _BYTE v42[48];
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  pixelBufferOut = 0;
  if (pixelBuffer)
  {
    if (a1)
    {
      Width = CVPixelBufferGetWidth(pixelBuffer);
      Height = CVPixelBufferGetHeight(pixelBuffer);
      v8 = Height;
      v9 = *(_DWORD *)(a1 + 56);
      if (v9)
        v10 = Height;
      else
        v10 = Width;
      if (v9)
        v11 = Width;
      else
        v11 = Height;
      objc_msgSend((id)a1, "ensureBufferPoolSupportsOutputWidth:outputHeight:", v10, v11);
      v12 = *(__CVPixelBufferPool **)(a1 + 8);
      if (v12)
      {
        if (*(_QWORD *)(a1 + 48))
        {
          if (CVPixelBufferPoolCreatePixelBuffer((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v12, &pixelBufferOut))
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                VCImageRotationConverterBase_CreateRotatedPixelBuffer_cold_5();
            }
          }
          else
          {
            v13 = (_QWORD *)MEMORY[0x1E0C9AE40];
            if (a3)
              v13 = (_QWORD *)MEMORY[0x1E0C9AE50];
            MEMORY[0x1DF087BF4](*(_QWORD *)(a1 + 48), *MEMORY[0x1E0CED6D8], *v13);
            v14 = MEMORY[0x1DF087C00](*(_QWORD *)(a1 + 48), pixelBuffer, pixelBufferOut);
            ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
            if (v14)
            {
              if (ErrorLogLevelForModule >= 3)
              {
                v30 = VRTraceErrorLogLevelToCSTR();
                v31 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                {
                  v32 = CVPixelBufferGetWidth(pixelBufferOut);
                  v33 = CVPixelBufferGetHeight(pixelBufferOut);
                  *(_DWORD *)buf = 136316930;
                  v36 = v30;
                  v37 = 2080;
                  v38 = "VCImageRotationConverterBase_CreateRotatedPixelBuffer";
                  v39 = 1024;
                  v40 = 62;
                  v41 = 1024;
                  *(_DWORD *)v42 = v14;
                  *(_WORD *)&v42[4] = 2048;
                  *(_QWORD *)&v42[6] = Width;
                  *(_WORD *)&v42[14] = 2048;
                  *(_QWORD *)&v42[16] = v8;
                  *(_WORD *)&v42[24] = 2048;
                  *(_QWORD *)&v42[26] = v32;
                  *(_WORD *)&v42[34] = 2048;
                  *(_QWORD *)&v42[36] = v33;
                  _os_log_error_impl(&dword_1D8A54000, v31, OS_LOG_TYPE_ERROR, " [%s] %s:%d Rotation session error %d. input size (%ldx%ld) output size (%ldx%ld)", buf, 0x4Au);
                }
              }
            }
            else if (ErrorLogLevelForModule >= 8)
            {
              v16 = VRTraceErrorLogLevelToCSTR();
              v17 = *MEMORY[0x1E0CF2758];
              v18 = *MEMORY[0x1E0CF2758];
              if (*MEMORY[0x1E0CF2748])
              {
                if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
                {
                  v19 = pixelBufferOut;
                  PixelFormatType = CVPixelBufferGetPixelFormatType(pixelBufferOut);
                  v21 = FourccToCStr(PixelFormatType);
                  v22 = CVPixelBufferGetWidth(pixelBufferOut);
                  v23 = CVPixelBufferGetHeight(pixelBufferOut);
                  *(_DWORD *)buf = 136316930;
                  v36 = v16;
                  v37 = 2080;
                  v38 = "VCImageRotationConverterBase_CreateRotatedPixelBuffer";
                  v39 = 1024;
                  v40 = 63;
                  v41 = 2048;
                  *(_QWORD *)v42 = a1;
                  *(_WORD *)&v42[8] = 2048;
                  *(_QWORD *)&v42[10] = v19;
                  *(_WORD *)&v42[18] = 2080;
                  *(_QWORD *)&v42[20] = v21;
                  *(_WORD *)&v42[28] = 2048;
                  *(_QWORD *)&v42[30] = v22;
                  *(_WORD *)&v42[38] = 2048;
                  *(_QWORD *)&v42[40] = v23;
                  _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d pointer=%p, newPixelBuffer=%p, formatType=%s, width=%lu, height=%lu", buf, 0x4Eu);
                }
              }
              else if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
              {
                v25 = pixelBufferOut;
                v26 = CVPixelBufferGetPixelFormatType(pixelBufferOut);
                v27 = FourccToCStr(v26);
                v28 = CVPixelBufferGetWidth(pixelBufferOut);
                v29 = CVPixelBufferGetHeight(pixelBufferOut);
                *(_DWORD *)buf = 136316930;
                v36 = v16;
                v37 = 2080;
                v38 = "VCImageRotationConverterBase_CreateRotatedPixelBuffer";
                v39 = 1024;
                v40 = 63;
                v41 = 2048;
                *(_QWORD *)v42 = a1;
                *(_WORD *)&v42[8] = 2048;
                *(_QWORD *)&v42[10] = v25;
                *(_WORD *)&v42[18] = 2080;
                *(_QWORD *)&v42[20] = v27;
                *(_WORD *)&v42[28] = 2048;
                *(_QWORD *)&v42[30] = v28;
                *(_WORD *)&v42[38] = 2048;
                *(_QWORD *)&v42[40] = v29;
                _os_log_debug_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEBUG, " [%s] %s:%d pointer=%p, newPixelBuffer=%p, formatType=%s, width=%lu, height=%lu", buf, 0x4Eu);
              }
            }
          }
        }
        else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCImageRotationConverterBase_CreateRotatedPixelBuffer_cold_4();
        }
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCImageRotationConverterBase_CreateRotatedPixelBuffer_cold_3();
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCImageRotationConverterBase_CreateRotatedPixelBuffer_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCImageRotationConverterBase_CreateRotatedPixelBuffer_cold_1();
  }
  return pixelBufferOut;
}

double VCHardwareSettings_FrontCameraOffsetFromDisplayCenter()
{
  if (VCHardwareSettings_FrontCameraOffsetFromDisplayCenter_sOnceToken != -1)
    dispatch_once(&VCHardwareSettings_FrontCameraOffsetFromDisplayCenter_sOnceToken, &__block_literal_global_106);
  return *(double *)&VCHardwareSettings_FrontCameraOffsetFromDisplayCenter_offset_0;
}

void VCVideoUtil_AttachMetadata(const __CFArray *a1, __CVBuffer *a2)
{
  const __CFAllocator *v4;
  CFMutableDictionaryRef Mutable;
  CFIndex Count;
  CFIndex v7;
  __CFArray *v8;
  CFIndex v9;
  uint64_t v10;
  uint64_t v11;
  void *ValueAtIndex;
  CFMutableArrayRef v13;
  __CFDictionary *v14;
  CFNumberRef v15;
  CFNumberRef v16;
  uint64_t v17;
  CFNumberRef v18;
  CFNumberRef v19;
  uint64_t v20;
  CFNumberRef v21;
  CFNumberRef v22;
  CFDictionaryRef DictionaryRepresentation;
  CFDictionaryRef v24;
  CFMutableDictionaryRef v25;
  CFMutableDictionaryRef v26;
  __CVBuffer *buffer;
  void *v28;
  void *v29;
  void *key;
  void *v31;
  void *v32;
  CFMutableDictionaryRef theDict;
  _QWORD valuePtr[2];
  CGRect v35;

  valuePtr[1] = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCVideoUtil_AttachMetadata_cold_1();
    }
    return;
  }
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCVideoUtil_AttachMetadata_cold_2();
    }
    return;
  }
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCVideoUtil_AttachMetadata_cold_3();
    }
    return;
  }
  buffer = a2;
  theDict = Mutable;
  Count = CFArrayGetCount(a1);
  if (Count < 1)
  {
    v8 = 0;
LABEL_28:
    v25 = theDict;
    CVBufferSetAttachment(buffer, (CFStringRef)*MEMORY[0x1E0D04138], theDict, kCVAttachmentMode_ShouldPropagate);
    goto LABEL_29;
  }
  v7 = Count;
  v8 = 0;
  v9 = 0;
  v10 = *MEMORY[0x1E0C8AA38];
  v11 = *MEMORY[0x1E0C8AA68];
  key = (void *)*MEMORY[0x1E0D05350];
  v32 = (void *)*MEMORY[0x1E0D05358];
  v29 = (void *)*MEMORY[0x1E0D05368];
  v28 = (void *)*MEMORY[0x1E0D05370];
  v31 = (void *)*MEMORY[0x1E0D05360];
  while (1)
  {
    ValueAtIndex = (void *)CFArrayGetValueAtIndex(a1, v9);
    if (!objc_msgSend((id)objc_msgSend(ValueAtIndex, "type"), "isEqual:", v10))
      break;
    if (!v8)
    {
      v13 = CFArrayCreateMutable(v4, 0, MEMORY[0x1E0C9B378]);
      if (!v13)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCVideoUtil_AttachMetadata_cold_4();
        }
        v26 = theDict;
        goto LABEL_31;
      }
      v8 = v13;
      CFDictionarySetValue(theDict, key, v13);
    }
    v14 = CFDictionaryCreateMutable(v4, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    valuePtr[0] = objc_msgSend(ValueAtIndex, "faceID");
    v15 = CFNumberCreate(v4, kCFNumberNSIntegerType, valuePtr);
    if (v15)
    {
      v16 = v15;
      CFDictionarySetValue(v14, v32, v15);
      CFRelease(v16);
    }
    if (objc_msgSend(ValueAtIndex, "hasRollAngle"))
    {
      objc_msgSend(ValueAtIndex, "rollAngle");
      valuePtr[0] = v17;
      v18 = CFNumberCreate(v4, kCFNumberCGFloatType, valuePtr);
      if (v18)
      {
        v19 = v18;
        CFDictionarySetValue(v14, v29, v18);
        CFRelease(v19);
      }
    }
    if (objc_msgSend(ValueAtIndex, "hasYawAngle"))
    {
      objc_msgSend(ValueAtIndex, "yawAngle");
      valuePtr[0] = v20;
      v21 = CFNumberCreate(v4, kCFNumberCGFloatType, valuePtr);
      if (v21)
      {
        v22 = v21;
        CFDictionarySetValue(v14, v28, v21);
        CFRelease(v22);
      }
    }
    objc_msgSend(ValueAtIndex, "bounds");
    DictionaryRepresentation = CGRectCreateDictionaryRepresentation(v35);
    if (DictionaryRepresentation)
    {
      v24 = DictionaryRepresentation;
      CFDictionaryAddValue(v14, v31, DictionaryRepresentation);
      CFRelease(v24);
    }
    if (v14)
    {
      CFArrayAppendValue(v8, v14);
      CFRelease(v14);
    }
LABEL_25:
    if (v7 == ++v9)
      goto LABEL_28;
  }
  if (!objc_msgSend((id)objc_msgSend(ValueAtIndex, "type"), "isEqual:", v11))
    goto LABEL_25;
  if (objc_msgSend(ValueAtIndex, "payload"))
  {
    CFDictionarySetValue(theDict, CFSTR("MetadataCVA"), (const void *)objc_msgSend(ValueAtIndex, "payload"));
    goto LABEL_25;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() < 3)
  {
    v25 = theDict;
  }
  else
  {
    VRTraceErrorLogLevelToCSTR();
    v25 = theDict;
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCVideoUtil_AttachMetadata_cold_5();
  }
LABEL_29:
  CFRelease(v25);
  if (v8)
  {
    v26 = v8;
LABEL_31:
    CFRelease(v26);
  }
}

BOOL _VCDefaults_GetBoolValueForKey(const __CFString *a1, _BOOL8 a2, int a3)
{
  int AppBooleanValue;
  int v7;
  uint64_t v8;
  NSObject *v9;
  Boolean keyExistsAndHasValidFormat;
  uint8_t buf[4];
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  const __CFString *v19;
  __int16 v20;
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  keyExistsAndHasValidFormat = -86;
  AppBooleanValue = CFPreferencesGetAppBooleanValue(a1, CFSTR("com.apple.VideoConference"), &keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat)
  {
    v7 = AppBooleanValue;
    a2 = AppBooleanValue != 0;
    if (a3)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v8 = VRTraceErrorLogLevelToCSTR();
        v9 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316162;
          v13 = v8;
          v14 = 2080;
          v15 = "_VCDefaults_GetBoolValueForKey";
          v16 = 1024;
          v17 = 1055;
          v18 = 2112;
          v19 = a1;
          v20 = 1024;
          v21 = v7;
          _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d %@=%d", buf, 0x2Cu);
        }
      }
    }
  }
  return a2;
}

uint64_t VCDefaults_GetIntValueForKey(const __CFString *a1, uint64_t IntValue)
{
  const __CFString *v4;
  const __CFString *v5;
  CFTypeID v6;
  uint64_t v7;
  NSObject *v8;
  int v10;
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  const char *CStringPtr;
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v4 = (const __CFString *)CFPreferencesCopyAppValue(a1, CFSTR("com.apple.VideoConference"));
  if (v4)
  {
    v5 = v4;
    v6 = CFGetTypeID(v4);
    if (v6 == CFStringGetTypeID())
    {
      IntValue = CFStringGetIntValue(v5);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v7 = VRTraceErrorLogLevelToCSTR();
        v8 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v10 = 136316162;
          v11 = v7;
          v12 = 2080;
          v13 = "VCDefaults_GetIntValueForKey";
          v14 = 1024;
          v15 = 1067;
          v16 = 2080;
          CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
          v18 = 1024;
          v19 = IntValue;
          _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Key %s: Value %d", (uint8_t *)&v10, 0x2Cu);
        }
      }
    }
    CFRelease(v5);
  }
  return IntValue;
}

BOOL VCFeatureFlagManager_UseAvconferenced()
{
  _BOOL8 BoolValueForKey;
  _DWORD v2[2];
  __int16 v3;
  int v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  if (VCFeatureFlagManager_UseAvconferenced_onceToken != -1)
    dispatch_once(&VCFeatureFlagManager_UseAvconferenced_onceToken, &__block_literal_global_9);
  BoolValueForKey = VCDefaults_GetBoolValueForKey(CFSTR("useAvconferenced"), VCFeatureFlagManager_UseAvconferenced_flag);
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    v2[0] = 67109376;
    v2[1] = BoolValueForKey;
    v3 = 1024;
    v4 = VCFeatureFlagManager_UseAvconferenced_flag;
    _os_log_impl(&dword_1D8A54000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "VCFeatureFlagManager: UseAvconferenced=%d, featureFlag=%d", (uint8_t *)v2, 0xEu);
  }
  return BoolValueForKey;
}

uint64_t VCAllocatorFirstCome_Create(const __CFAllocator *a1, uint64_t a2, CFAllocatorRef *a3)
{
  _DWORD *v5;
  _DWORD *v6;
  CFAllocatorRef Default;
  CFAllocatorRef v8;
  uint64_t v9;
  CFAllocatorContext v11;
  CFAllocatorRef *v12;
  __int128 v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v12 = 0;
  if (!a3)
  {
    v9 = 1768846960;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAllocatorFirstCome_Create_cold_1();
    }
    goto LABEL_18;
  }
  *(_OWORD *)&v11.copyDescription = xmmword_1E9E56910;
  *(_OWORD *)&v11.reallocate = *(_OWORD *)&off_1E9E56920;
  v11.preferredSize = 0;
  *(_OWORD *)&v11.version = xmmword_1E9E568F0;
  *(_OWORD *)&v11.retain = *(_OWORD *)&off_1E9E56900;
  v5 = CFAllocatorAllocate(a1, 144, 0);
  if (!v5)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAllocatorFirstCome_Create_cold_3();
    }
    v9 = 1852663149;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAllocatorFirstCome_Create_cold_2();
    }
LABEL_18:
    _VCAllocatorFirstCome_FinalizeInfo(0);
    _VCAllocatorMultiQueue_ReleaseInfo(&v12);
    return v9;
  }
  v6 = v5;
  v13 = 0uLL;
  *((_OWORD *)v5 + 2) = 0uLL;
  *((_BYTE *)v5 + 24) = 1;
  v5[3] = 0;
  v5[4] = 0;
  v5[5] = 0;
  if (a1)
    Default = a1;
  else
    Default = CFAllocatorGetDefault();
  *(_QWORD *)v6 = CFRetain(Default);
  v6[2] = 0;
  *((_QWORD *)v6 + 15) = 0;
  *((_BYTE *)v6 + 118) = 0;
  __strlcpy_chk();
  v11.info = v6;
  v8 = CFAllocatorCreate(a1, &v11);
  if (v8)
  {
    v9 = 0;
    *a3 = v8;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAllocatorFirstCome_Create_cold_4();
    }
    return 0;
  }
  return v9;
}

double VCDefaults_GetDoubleValueForKey(const __CFString *a1, double DoubleValue)
{
  const __CFString *v4;
  const __CFString *v5;
  CFTypeID v6;
  uint64_t v7;
  NSObject *v8;
  int v10;
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  const char *CStringPtr;
  __int16 v18;
  double v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v4 = (const __CFString *)CFPreferencesCopyAppValue(a1, CFSTR("com.apple.VideoConference"));
  if (v4)
  {
    v5 = v4;
    v6 = CFGetTypeID(v4);
    if (v6 == CFStringGetTypeID())
    {
      DoubleValue = CFStringGetDoubleValue(v5);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v7 = VRTraceErrorLogLevelToCSTR();
        v8 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v10 = 136316162;
          v11 = v7;
          v12 = 2080;
          v13 = "VCDefaults_GetDoubleValueForKey";
          v14 = 1024;
          v15 = 1037;
          v16 = 2080;
          CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
          v18 = 2048;
          v19 = DoubleValue;
          _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d key=%s Value=%.3f", (uint8_t *)&v10, 0x30u);
        }
      }
    }
    CFRelease(v5);
  }
  return DoubleValue;
}

BOOL VCDefaults_GetBoolValueForKey(const __CFString *a1, _BOOL8 a2)
{
  if (VRTraceIsInternalOSInstalled())
    return _VCDefaults_GetBoolValueForKey(a1, a2, 1);
  else
    return a2;
}

BOOL VCDefaults_GetEyeContactEnabledBoolValue(_BOOL8 a1)
{
  return _VCDefaults_GetBoolValueForKey(CFSTR("VPCEnabled"), a1, 1);
}

void sub_1D8A6BA60(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

const void *VCDefaults_CopyValueForKey(const __CFString *a1, uint64_t a2)
{
  CFPropertyListRef v4;
  const void *v5;
  uint64_t v6;
  NSObject *v7;
  int v9;
  uint64_t v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  const __CFString *v16;
  __int16 v17;
  const void *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (!VRTraceIsInternalOSInstalled())
    return 0;
  v4 = CFPreferencesCopyAppValue(a1, CFSTR("com.apple.VideoConference"));
  v5 = v4;
  if (!v4)
    return v5;
  if (CFGetTypeID(v4) != a2)
  {
    CFRelease(v5);
    return 0;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v6 = VRTraceErrorLogLevelToCSTR();
    v7 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136316162;
      v10 = v6;
      v11 = 2080;
      v12 = "VCDefaults_CopyValueForKey";
      v13 = 1024;
      v14 = 1091;
      v15 = 2112;
      v16 = a1;
      v17 = 2112;
      v18 = v5;
      _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d %@=%@", (uint8_t *)&v9, 0x30u);
    }
  }
  return v5;
}

const void *VCDefaults_CopyStringValueForKey(const __CFString *a1)
{
  CFTypeID TypeID;

  TypeID = CFStringGetTypeID();
  return VCDefaults_CopyValueForKey(a1, TypeID);
}

void sub_1D8A6D7B0(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 128), 8);
  _Unwind_Resume(a1);
}

uint64_t VCAllocatorMultiQueue_Create(const __CFAllocator *a1, uint64_t a2, unsigned int a3, unint64_t *a4, CFAllocatorRef *a5)
{
  unint64_t *v5;
  uint64_t v7;
  void *v9;
  uint64_t v10;
  CFAllocatorRef Default;
  CFTypeRef v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  CFAllocatorRef v17;
  uint64_t v18;
  int ErrorLogLevelForModule;
  os_log_t *v21;
  CFAllocatorContext v22;
  CFAllocatorRef *v23;
  __int128 v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v23 = 0;
  if (!a3)
  {
    v18 = 1768846960;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAllocatorMultiQueue_Create_cold_1();
    }
    goto LABEL_38;
  }
  v5 = a4;
  if (!a4)
  {
    v18 = 1768846960;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAllocatorMultiQueue_Create_cold_2();
    }
    goto LABEL_38;
  }
  if (!a5)
  {
    v18 = 1768846960;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAllocatorMultiQueue_Create_cold_3();
    }
    goto LABEL_38;
  }
  LODWORD(v7) = a3;
  *(_OWORD *)&v22.copyDescription = xmmword_1E9E55298;
  *(_OWORD *)&v22.reallocate = *(_OWORD *)&off_1E9E552A8;
  v22.preferredSize = 0;
  *(_OWORD *)&v22.version = xmmword_1E9E55278;
  *(_OWORD *)&v22.retain = *(_OWORD *)&off_1E9E55288;
  v9 = CFAllocatorAllocate(a1, 48 * a3 + 112, 0);
  if (!v9)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAllocatorMultiQueue_Create_cold_5();
    }
    v18 = 1852663149;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAllocatorMultiQueue_Create_cold_4();
    }
LABEL_38:
    v10 = 0;
    goto LABEL_39;
  }
  v10 = (uint64_t)v9;
  v7 = v7;
  __strlcpy_chk();
  v23 = (CFAllocatorRef *)v10;
  *(_QWORD *)(v10 + 16) = v7;
  if (a1)
    Default = a1;
  else
    Default = CFAllocatorGetDefault();
  v12 = CFRetain(Default);
  v13 = 0;
  v14 = 0;
  *(_QWORD *)v10 = v12;
  *(_DWORD *)(v10 + 8) = 0;
  *(_BYTE *)(v10 + 104) = 0;
  *(_DWORD *)(v10 + 96) = 0;
  *(_DWORD *)(v10 + 100) = 0;
  while (1)
  {
    v15 = *v5;
    if (v14 >= *v5)
      break;
    v16 = v10 + v13;
    v24 = 0uLL;
    *(_OWORD *)(v16 + 144) = 0uLL;
    *(_DWORD *)(v16 + 120) = 0;
    *(_DWORD *)(v16 + 124) = 0;
    *(_QWORD *)(v16 + 112) = v15;
    *(_QWORD *)(v16 + 128) = 0;
    *(_BYTE *)(v16 + 136) = 1;
    ++v5;
    v13 += 48;
    v14 = v15;
    if (!--v7)
    {
      v22.info = (void *)v10;
      v17 = CFAllocatorCreate(a1, &v22);
      if (v17)
      {
        v18 = 0;
        *a5 = v17;
      }
      else
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCAllocatorMultiQueue_Create_cold_6();
        }
        return 0;
      }
      return v18;
    }
  }
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  v21 = (os_log_t *)MEMORY[0x1E0CF2758];
  if (ErrorLogLevelForModule >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled(*v21, OS_LOG_TYPE_ERROR))
      VCAllocatorMultiQueue_Create_cold_9();
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled(*v21, OS_LOG_TYPE_ERROR))
      VCAllocatorMultiQueue_Create_cold_8();
  }
  v18 = 1936683620;
  _VCAllocatorMultiQueue_FinalizeInfo(v10);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled(*v21, OS_LOG_TYPE_ERROR))
      VCAllocatorMultiQueue_Create_cold_7();
  }
LABEL_39:
  _VCAllocatorMultiQueue_FinalizeInfo(v10);
  _VCAllocatorMultiQueue_ReleaseInfo(&v23);
  return v18;
}

void sub_1D8A71384(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t VCSingleLinkedListPush(uint64_t result, _QWORD *a2)
{
  uint64_t v3;
  uint64_t *v4;
  uint64_t *v5;
  int v6;
  uint64_t v7;

  if (result)
  {
    v3 = result;
    result = 0;
    if (a2)
    {
      if (*(_BYTE *)(v3 + 8))
      {
        v4 = (uint64_t *)v3;
        while (1)
        {
          v5 = v4;
          v4 = (uint64_t *)*v4;
          if (!v4)
          {
            v7 = 0;
            goto LABEL_10;
          }
          v6 = (*(uint64_t (**)(uint64_t *, _QWORD *))(v3 + 16))(v4, a2);
          if (v6 == 1)
            return 0;
          if (v6 == 2)
          {
            v7 = *v5;
LABEL_10:
            ++*(_QWORD *)(v3 + 24);
            *a2 = v7;
            *v5 = (uint64_t)a2;
            return 1;
          }
        }
      }
    }
  }
  return result;
}

uint64_t AVConferenceServer_ProcessIsAVConferenceServer()
{
  return processIsAVConferenceServer;
}

uint64_t RTCPGetSummaryReportBlock(uint64_t a1, int32x2_t *a2, int a3)
{
  uint64_t v5;
  _DWORD *v6;
  int32x2_t v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  unsigned __int16 v12;
  unsigned int v13;
  int v14;
  int v15;
  unsigned int v16;
  int v17;
  int v18;
  unsigned int v19;
  BOOL v20;
  uint64_t v21;
  unsigned int v22;
  BOOL v23;
  __int32 v24;
  _DWORD *v25;
  unsigned int v26;
  BOOL v27;
  int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  int v32;
  unsigned int v33;
  double v34;
  int v35;
  int v36;
  uint64_t v37;
  unsigned int v38;
  _BYTE *v39;
  unsigned int v40;
  unsigned int v41;
  double v42;
  unsigned int v43;
  _BYTE *v44;
  double v45;
  uint64_t v46;
  NSObject *v47;
  int v48;
  int v49;
  __int32 v50;
  __int32 v51;
  __int32 v52;
  __int32 v53;
  int v54;
  int v55;
  int v56;
  int v57;
  __int32 v58;
  __int32 v59;
  int v60;
  int v61;
  size_t v62;
  void *v63;
  uint64_t v65;
  NSObject *v66;
  uint64_t v67;
  NSObject *v68;
  int v69;
  uint64_t v70;
  __int16 v71;
  const char *v72;
  __int16 v73;
  int v74;
  __int16 v75;
  int v76;
  __int16 v77;
  int v78;
  __int16 v79;
  __int32 v80;
  __int16 v81;
  __int32 v82;
  __int16 v83;
  __int32 v84;
  __int16 v85;
  __int32 v86;
  __int16 v87;
  int v88;
  __int16 v89;
  int v90;
  __int16 v91;
  int v92;
  __int16 v93;
  int v94;
  __int16 v95;
  __int32 v96;
  __int16 v97;
  __int32 v98;
  __int16 v99;
  int v100;
  uint64_t v101;

  v101 = *MEMORY[0x1E0C80C00];
  v5 = 2147549201;
  v6 = (_DWORD *)CheckInHandleDebug();
  if (!v6)
    return 2147549186;
  v8 = (uint64_t)v6;
  if (v6[47])
  {
    if (v6[1751])
    {
      v9 = v6[1214];
      v10 = (v9 - a3) & ~((v9 - a3) >> 31);
      v6[1215] = v10;
      v11 = v6[1212];
      a2[1].i16[2] = v11;
      v12 = v11 + v10 + 1;
      a2[1].i16[3] = v12;
      v13 = (unsigned __int16)v11;
      if (~(unsigned __int16)v11 + v12 >= 320)
        v14 = 320;
      else
        v14 = ~(unsigned __int16)v11 + v12;
      if ((_WORD)v11)
      {
        v15 = 0;
      }
      else if (v6[179] == 1)
      {
        v15 = 1;
      }
      else
      {
        v15 = -1;
      }
      v16 = v12;
      v17 = 0;
      if ((v14 & 0x80000000) == 0)
      {
        v18 = v14 + 1;
        do
        {
          v11 &= 0x3FFu;
          v19 = v6[v11 + 179];
          if (v19)
            v20 = v19 >= v13;
          else
            v20 = 0;
          if (!v20)
            ++v17;
          LOWORD(v11) = v11 + 1;
          --v18;
        }
        while (v18);
      }
      v21 = v6[1749];
      v22 = v6[v21 + 1698];
      if (v22)
        v23 = v22 >= v16;
      else
        v23 = 1;
      if (v23)
      {
        v24 = 0;
      }
      else
      {
        v24 = 0;
        v25 = v6 + 1698;
        do
        {
          v25[v21] = 0;
          ++v24;
          LODWORD(v21) = (*(_DWORD *)(v8 + 6996) + 1) % 0x32u;
          *(_DWORD *)(v8 + 6996) = v21;
          v26 = v25[v21];
          if (v26)
            v27 = v26 >= v16;
          else
            v27 = 1;
        }
        while (!v27);
      }
      a2->i16[0] = 257;
      a2[2].i32[0] = v17 + v15;
      a2[2].i32[1] = v24;
      a2[1].i32[0] = *(_DWORD *)(v8 + 4832);
      a2->i8[2] = 1;
      if (*(_DWORD *)(v8 + 12))
        v28 = 2;
      else
        v28 = 1;
      a2->i32[1] = v28;
      v29 = *(_DWORD *)(v8 + 4852);
      if ((v9 + 1) % 0x140u == v29)
      {
        _RTCPGetMeanAndStandardDeviationOfJitter(v8, a2, 0, v7);
        v30 = 0;
      }
      else
      {
        _RTCPGetMeanAndStandardDeviationOfJitter(v8, a2, v29, v7);
        v30 = *(_DWORD *)(v8 + 4852);
      }
      v31 = *(_DWORD *)(v8 + 4860);
      if (v31 > 0x13F || (LOBYTE(v32) = -2, v31 - v30 > 0x7FFFFFFE))
      {
        a2[5].i16[1] = 0;
      }
      else
      {
        v20 = v31 >= v30;
        v33 = v31 - v30;
        if (v20)
        {
          v35 = 0;
          v36 = 0;
          v37 = v30;
          v38 = v33 + 1;
          v39 = (_BYTE *)(v8 + v30 + 6152);
          do
          {
            v40 = *v39;
            if (*v39)
            {
              ++v35;
              v36 += v40;
              if (*(unsigned __int8 *)(v8 + 6480) < v40)
                LOBYTE(v40) = *(_BYTE *)(v8 + 6480);
              *(_BYTE *)(v8 + 6480) = v40;
              v41 = *(unsigned __int8 *)(v8 + 6481);
              if (v41 <= *v39)
                LOBYTE(v41) = *v39;
              *(_BYTE *)(v8 + 6481) = v41;
            }
            ++v39;
            --v38;
          }
          while (v38);
          v42 = (double)v35;
          v32 = (int)((double)v36 / (double)v35);
          v43 = v33 + 1;
          v44 = (_BYTE *)(v37 + v8 + 6152);
          v45 = 0.0;
          do
          {
            if (*v44)
            {
              v45 = v45 + (double)(*v44 - v32) * (double)(*v44 - v32);
              *v44 = 0;
            }
            ++v44;
            --v43;
          }
          while (v43);
          v34 = v45 / v42;
        }
        else
        {
          v34 = NAN;
        }
        a2[5].i8[3] = llround(sqrt(v34));
        a2[5].i8[2] = v32;
        a2[5].i16[0] = *(_WORD *)(v8 + 6480);
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v46 = VRTraceErrorLogLevelToCSTR();
        v47 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v48 = a2[1].u16[2];
          v49 = a2[1].u16[3];
          v50 = a2[3].i32[0];
          v51 = a2[3].i32[1];
          v52 = a2[4].i32[0];
          v53 = a2[4].i32[1];
          v54 = a2[5].u8[2];
          v55 = a2[5].u8[3];
          v56 = a2[5].u8[0];
          v57 = a2[5].u8[1];
          v58 = a2[2].i32[0];
          v59 = a2[2].i32[1];
          v60 = *(_DWORD *)(v8 + 704);
          v69 = 136318978;
          v70 = v46;
          v71 = 2080;
          v72 = "_RTCPGetSummaryReportBlock";
          v73 = 1024;
          v74 = 143;
          v75 = 1024;
          v76 = v48;
          v77 = 1024;
          v78 = v49;
          v79 = 1024;
          v80 = v50;
          v81 = 1024;
          v82 = v51;
          v83 = 1024;
          v84 = v52;
          v85 = 1024;
          v86 = v53;
          v87 = 1024;
          v88 = v54;
          v89 = 1024;
          v90 = v55;
          v91 = 1024;
          v92 = v56;
          v93 = 1024;
          v94 = v57;
          v95 = 1024;
          v96 = v58;
          v97 = 1024;
          v98 = v59;
          v99 = 1024;
          v100 = v60;
          _os_log_impl(&dword_1D8A54000, v47, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTCP XR Summary report Start sequence=%d End sequence=%d minJitter=%d maxJitter=%d meanJitter=%d stdevJitter=%d meanHopLimt=%d devHopLimit=%d minHopLimt=%d maxHopLimit=%d lostPackets=%d duplicatePackets=%d dwPacketsRecv=%d", (uint8_t *)&v69, 0x6Au);
        }
      }
      v61 = *(_DWORD *)(v8 + 4860);
      *(_DWORD *)(v8 + 4848) += v61 + 1;
      *(_DWORD *)(v8 + 4844) = *(_DWORD *)(v8 + 4840);
      v62 = (*(_DWORD *)(v8 + 4856) - v61) & ~((*(_DWORD *)(v8 + 4856) - v61) >> 31);
      memmove((void *)(v8 + 4872), (const void *)(v8 + 4872 + 4 * (v61 + 1)), 4 * v62);
      v63 = (void *)(v8 + 6152 + (*(_DWORD *)(v8 + 4860) + 1));
      memcpy((void *)(v8 + 6152), v63, v62);
      bzero(v63, v62);
      v5 = 0;
      *(_QWORD *)(v8 + 4852) = 0;
      *(_QWORD *)(v8 + 6472) = 0x800000007FFFFFFFLL;
      *(_WORD *)(v8 + 6480) = 255;
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v67 = VRTraceErrorLogLevelToCSTR();
      v68 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v69 = 136315650;
        v70 = v67;
        v71 = 2080;
        v72 = "RTCPGetSummaryReportBlock";
        v73 = 1024;
        v74 = 154;
        _os_log_impl(&dword_1D8A54000, v68, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Haven't received any RTP packet yet", (uint8_t *)&v69, 0x1Cu);
      }
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v65 = VRTraceErrorLogLevelToCSTR();
      v66 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v69 = 136315650;
        v70 = v65;
        v71 = 2080;
        v72 = "RTCPGetSummaryReportBlock";
        v73 = 1024;
        v74 = 153;
        _os_log_impl(&dword_1D8A54000, v66, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTCP XR is not enabled", (uint8_t *)&v69, 0x1Cu);
      }
    }
    v5 = 67;
  }
  CheckOutHandleDebug();
  return v5;
}

int32x2_t _RTCPGetMeanAndStandardDeviationOfJitter(uint64_t a1, int32x2_t *a2, unsigned int a3, int32x2_t result)
{
  unsigned int v4;
  unsigned int v5;
  uint64_t v7;
  double v8;
  double v9;
  BOOL v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  int v14;
  int *v15;
  unsigned int v16;
  uint64_t v17;
  int v18;
  int v19;
  int *v20;
  unsigned int v21;
  uint64_t v22;
  int v23;
  double v24;
  uint64_t v25;
  int64x2_t v26;

  v4 = *(_DWORD *)(a1 + 4860);
  v5 = v4 - a3;
  if (v4 > 0x13F || v5 > 0x7FFFFFFE)
  {
    a2[4] = 0;
  }
  else
  {
    v7 = v5 + 1;
    v8 = 0.0;
    v9 = 0.0;
    v10 = v4 >= a3;
    v11 = v4 - a3;
    if (v10)
    {
      v12 = 0;
      v13 = *(_DWORD *)(a1 + 6472);
      v14 = *(_DWORD *)(a1 + 6476);
      v15 = (int *)(a1 + 4 * a3 + 4872);
      v16 = v11 + 1;
      do
      {
        v17 = *v15;
        v12 += v17;
        if (v13 >= (int)v17)
          v13 = *v15;
        *(_DWORD *)(a1 + 6472) = v13;
        v19 = *v15++;
        v18 = v19;
        if (v14 <= v19)
          v14 = v18;
        *(_DWORD *)(a1 + 6476) = v14;
        --v16;
      }
      while (v16);
      v20 = (int *)(a1 + 4 * a3 + 4872);
      v21 = v11 + 1;
      v9 = 0.0;
      v22 = v12 / v7;
      do
      {
        v23 = *v20++;
        v9 = v9 + (double)(v23 - (int)v22) * (double)(v23 - (int)v22);
        --v21;
      }
      while (v21);
      v8 = (double)(int)v22;
    }
    v24 = *(double *)(a1 + 27608);
    a2[4].i32[0] = llround(v24 * v8);
    a2[4].i32[1] = llround(sqrt(v9 / (double)(int)v7) * v24);
    v25 = *(_QWORD *)(a1 + 6472);
    v26.i64[0] = (int)v25;
    v26.i64[1] = SHIDWORD(v25);
    result = vmovn_s64(vcvtq_s64_f64(vrndaq_f64(vmulq_n_f64(vcvtq_f64_s64(v26), v24))));
    a2[3] = result;
  }
  return result;
}

double convertTimeoutToRelativeTimespec(double a1)
{
  return (a1 - (double)(int)a1) * 1000000000.0;
}

uint64_t VCUniqueIDGenerator_GenerateID()
{
  uint64_t result;

  result = _VCUniqueIDGenerator_GenerateIDInternal();
  if (!(_DWORD)result)
    return _VCUniqueIDGenerator_GenerateIDInternal();
  return result;
}

uint64_t _VCUniqueIDGenerator_GenerateIDInternal()
{
  uint64_t v0;

  if (_VCUniqueIDGenerator_GenerateIDInternal_onceToken != -1)
    dispatch_once(&_VCUniqueIDGenerator_GenerateIDInternal_onceToken, &__block_literal_global);
  pthread_mutex_lock(&generateIDLock);
  currentID += 1 + (((currentID + 1) / 0x7FFFFFFFu) | (((currentID + 1) / 0x7FFFFFFFu) << 31));
  v0 = currentID;
  pthread_mutex_unlock(&generateIDLock);
  return v0;
}

uint64_t WRMInitialize(uint64_t a1, uint64_t a2)
{
  pthread_mutex_t *v3;
  __darwin_time_t tv_sec;
  uint64_t result;
  timeval v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)(a1 + 256) = 0;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  v3 = (pthread_mutex_t *)(a1 + 128);
  *(_DWORD *)(a1 + 16) = 50;
  *(_QWORD *)(a1 + 8) = a2;
  v6.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v6.tv_usec = 0xAAAAAAAAAAAAAAAALL;
  gettimeofday(&v6, 0);
  tv_sec = v6.tv_sec;
  srand(v6.tv_sec);
  *(_QWORD *)(a1 + 64) = arc4random() | (unint64_t)(tv_sec << 32);
  result = pthread_mutex_init(v3, 0);
  *(_BYTE *)a1 = 1;
  return result;
}

uint64_t WRMUninitialize(uint64_t result)
{
  _BYTE *v1;

  if (*(_BYTE *)result)
  {
    v1 = (_BYTE *)result;
    result = pthread_mutex_destroy((pthread_mutex_t *)(result + 128));
    *v1 = 0;
  }
  return result;
}

uint64_t WRMSetReportingCallback(uint64_t result, uint64_t a2, __int128 *a3)
{
  uint64_t v3;
  __int128 v6;

  if (result)
  {
    v3 = result;
    if (*(_BYTE *)result)
    {
      pthread_mutex_lock((pthread_mutex_t *)(result + 128));
      *(_QWORD *)(v3 + 96) = a2;
      if (a3)
      {
        v6 = *a3;
        *(_QWORD *)(v3 + 120) = *((_QWORD *)a3 + 2);
        *(_OWORD *)(v3 + 104) = v6;
      }
      return pthread_mutex_unlock((pthread_mutex_t *)(v3 + 128));
    }
  }
  return result;
}

uint64_t WRMSetCallId(uint64_t result, uint64_t a2)
{
  if (result && a2)
  {
    if (*(_BYTE *)result)
      *(_QWORD *)(result + 64) = a2;
  }
  return result;
}

uint64_t WRMIncrementTime(uint64_t result)
{
  if (result)
    ++*(_DWORD *)(result + 20);
  return result;
}

uint64_t WRMGenerateReport(unsigned __int8 *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;

  if (!a1)
    return 0;
  v2 = *a1;
  if (*a1)
  {
    v3 = *((unsigned int *)a1 + 5);
    if (v3 % *((_DWORD *)a1 + 4))
      return 0;
    *(_QWORD *)(a2 + 168) = *((_QWORD *)a1 + 8);
    *(_QWORD *)a2 = v3;
    v4 = *((_QWORD *)a1 + 32);
    *(_QWORD *)&v5 = v4;
    *((_QWORD *)&v5 + 1) = HIDWORD(v4);
    *(_OWORD *)(a2 + 264) = v5;
    v6 = *((unsigned int *)a1 + 14);
    v7 = *((unsigned int *)a1 + 15);
    *(_QWORD *)(a2 + 24) = v6;
    *(_QWORD *)(a2 + 32) = v7;
    v8 = v6 - v7;
    v9 = *((unsigned int *)a1 + 8);
    v10 = *((unsigned int *)a1 + 9);
    *(_QWORD *)(a2 + 40) = v8;
    *(_QWORD *)(a2 + 48) = v9;
    *(_QWORD *)(a2 + 56) = v10;
    *(_QWORD *)(a2 + 64) = v9 - v10;
    v11 = *((unsigned int *)a1 + 12);
    LODWORD(v8) = *((_DWORD *)a1 + 13);
    LODWORD(v10) = *((_DWORD *)a1 + 48);
    v12 = *((unsigned int *)a1 + 49);
    v13 = *((unsigned int *)a1 + 11);
    *(_QWORD *)(a2 + 72) = *((unsigned int *)a1 + 10);
    *(_QWORD *)(a2 + 80) = (unint64_t)((double)v8 * 1000.0 / (double)v10);
    v14 = v3 - v13;
    v15 = 100 * *((_DWORD *)a1 + 22);
    v16 = *((_QWORD *)a1 + 3);
    *(_QWORD *)&v5 = v16;
    *((_QWORD *)&v5 + 1) = HIDWORD(v16);
    *(_OWORD *)(a2 + 8) = v5;
    v17 = *((_QWORD *)a1 + 30);
    v18 = *((_QWORD *)a1 + 31);
    *(_QWORD *)&v5 = v17;
    *((_QWORD *)&v5 + 1) = HIDWORD(v17);
    *(_OWORD *)(a2 + 232) = v5;
    *(_QWORD *)&v5 = v18;
    *((_QWORD *)&v5 + 1) = HIDWORD(v18);
    *(_OWORD *)(a2 + 248) = v5;
    *(_QWORD *)(a2 + 96) = (uint64_t)v15 >> 8;
    *(_QWORD *)(a2 + 104) = v14;
    *(_QWORD *)(a2 + 128) = v14;
    *(_QWORD *)(a2 + 136) = v11;
    *(_QWORD *)(a2 + 144) = v14;
    *(_QWORD *)(a2 + 112) = v12;
    *(_QWORD *)(a2 + 120) = ((1000 * v8) >> 4) / v10;
    *(_OWORD *)(a2 + 152) = *(_OWORD *)(a1 + 72);
    v2 = 1;
    if (*((_DWORD *)a1 + 50))
      v19 = 1;
    else
      v19 = 2;
    *(_QWORD *)(a2 + 176) = v19;
    v20 = *(_QWORD *)(a1 + 204);
    *(_QWORD *)&v21 = v20;
    *((_QWORD *)&v21 + 1) = HIDWORD(v20);
    *(_OWORD *)(a2 + 184) = v21;
    v22 = *(_QWORD *)(a1 + 212);
    *(_QWORD *)&v21 = v22;
    *((_QWORD *)&v21 + 1) = HIDWORD(v22);
    *(_OWORD *)(a2 + 200) = v21;
    v23 = *((unsigned int *)a1 + 56);
    *(_QWORD *)(a2 + 216) = *((_DWORD *)a1 + 55) == 0;
    *(_QWORD *)(a2 + 224) = v23;
  }
  return v2;
}

uint64_t WRMSubmitReport(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t (*v4)(uint64_t, uint64_t);
  void (*v5)(uint64_t);
  uint64_t v6;
  uint64_t (*v7)(uint64_t);

  if (result)
  {
    v2 = result;
    if (*(_BYTE *)result)
    {
      pthread_mutex_lock((pthread_mutex_t *)(result + 128));
      v4 = *(uint64_t (**)(uint64_t, uint64_t))(v2 + 96);
      if (v4)
      {
        v6 = *(_QWORD *)(v2 + 104);
        v5 = *(void (**)(uint64_t))(v2 + 112);
        v7 = *(uint64_t (**)(uint64_t))(v2 + 120);
        if (v5 && v6)
          v5(v6);
        pthread_mutex_unlock((pthread_mutex_t *)(v2 + 128));
        result = v4(v6, a2);
        if (v7)
        {
          if (v6)
            return v7(v6);
        }
      }
      else
      {
        return pthread_mutex_unlock((pthread_mutex_t *)(v2 + 128));
      }
    }
  }
  return result;
}

void OUTLINED_FUNCTION_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x1Cu);
}

void OUTLINED_FUNCTION_5(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x22u);
}

void OUTLINED_FUNCTION_11(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0x26u);
}

void PowerMeter::PowerMeter(PowerMeter *this)
{
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 2) = 0x3F789374BC6A7EFALL;
  *((_QWORD *)this + 4) = 0x3F90624DD2F1A9FCLL;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 5) = 0xFFFFFFFFLL;
  *((_DWORD *)this + 12) = 0;
}

void PowerMeter::SetSampleRate(PowerMeter *this, double a2)
{
  *(double *)this = a2;
  *((long double *)this + 1) = CalcDecayConstant(2.5, a2);
  *((long double *)this + 3) = CalcDecayConstant(1.24, a2);
}

BOOL VCMediaNegotiationBlobMultiwayVideoStreamReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int *v4;
  int *v5;
  int *v6;
  int *v8;
  int *v9;
  unint64_t v10;
  int *v11;
  int *v12;
  char v13;
  unsigned int v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char v18;
  int v20;
  char v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  char v27;
  int v28;
  int *v29;
  BOOL v30;
  int *v31;
  unint64_t v32;
  int *v33;
  uint64_t v34;
  int *v35;
  int *v36;
  char v37;
  char v38;
  unsigned int v39;
  uint64_t v40;
  unint64_t v41;
  char v42;
  char v43;
  unsigned int v44;
  uint64_t v45;
  unint64_t v46;
  char v47;
  char v48;
  unsigned int v49;
  uint64_t v50;
  unint64_t v51;
  char v52;
  char v53;
  unsigned int v54;
  uint64_t v55;
  unint64_t v56;
  char v57;
  char v58;
  unsigned int v59;
  uint64_t v60;
  unint64_t v61;
  char v62;
  char v63;
  unsigned int v64;
  uint64_t v65;
  unint64_t v66;
  char v67;
  char v68;
  unsigned int v69;
  uint64_t v70;
  unint64_t v71;
  char v72;
  char v73;
  unsigned int v74;
  uint64_t v75;
  unint64_t v76;
  char v77;
  char v78;
  unsigned int v79;
  uint64_t v80;
  unint64_t v81;
  char v82;
  char v83;
  unsigned int v84;
  uint64_t v85;
  unint64_t v86;
  char v87;
  char v88;
  unsigned int v89;
  uint64_t v90;
  unint64_t v91;
  char v92;
  char v93;
  unsigned int v94;
  uint64_t v95;
  unint64_t v96;
  char v97;
  uint64_t v99;

  v4 = (int *)MEMORY[0x1E0D82BF0];
  v5 = (int *)MEMORY[0x1E0D82BD8];
  v6 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v8 = &OBJC_IVAR___VCMediaNegotiationBlobMultiwayVideoStream__ssrc;
    v9 = (int *)MEMORY[0x1E0D82BB8];
    v10 = 0x1F01AF000uLL;
    v11 = &OBJC_IVAR___VCMediaNegotiationBlobMultiwayVideoStream__maxNetworkBitrate;
    v12 = &OBJC_IVAR___VCMediaNegotiationBlobMultiwayVideoStream__payload;
    do
    {
      if (*(_BYTE *)(a2 + *v6))
        break;
      v13 = 0;
      v14 = 0;
      v15 = 0;
      while (1)
      {
        v16 = *v4;
        v17 = *(_QWORD *)(a2 + v16);
        if (v17 == -1 || v17 >= *(_QWORD *)(a2 + *v5))
          break;
        v18 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v17);
        *(_QWORD *)(a2 + v16) = v17 + 1;
        v15 |= (unint64_t)(v18 & 0x7F) << v13;
        if ((v18 & 0x80) == 0)
          goto LABEL_12;
        v13 += 7;
        if (v14++ >= 9)
        {
          v15 = 0;
          v20 = *(unsigned __int8 *)(a2 + *v6);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v6) = 1;
LABEL_12:
      v20 = *(unsigned __int8 *)(a2 + *v6);
      if (*(_BYTE *)(a2 + *v6))
        v15 = 0;
LABEL_14:
      if (v20 || (v15 & 7) == 4)
        break;
      switch((v15 >> 3))
      {
        case 1u:
          v22 = 0;
          v23 = 0;
          v24 = 0;
          while (1)
          {
            v25 = *v4;
            v26 = *(_QWORD *)(a2 + v25);
            if (v26 == -1 || v26 >= *(_QWORD *)(a2 + *v5))
            {
              v29 = v8;
              goto LABEL_125;
            }
            v27 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v26);
            *(_QWORD *)(a2 + v25) = v26 + 1;
            v24 |= (unint64_t)(v27 & 0x7F) << v22;
            if ((v27 & 0x80) == 0)
              break;
            v28 = 0;
            v22 += 7;
            v29 = v8;
            v30 = v23++ > 8;
            if (v30)
              goto LABEL_129;
          }
          v29 = v8;
          goto LABEL_126;
        case 2u:
          v38 = 0;
          v39 = 0;
          v24 = 0;
          *(_BYTE *)(a1 + *(int *)(v10 + 2336)) |= 2u;
          while (2)
          {
            v40 = *v4;
            v41 = *(_QWORD *)(a2 + v40);
            if (v41 == -1 || v41 >= *(_QWORD *)(a2 + *v5))
            {
              v29 = v11;
              goto LABEL_125;
            }
            v42 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v41);
            *(_QWORD *)(a2 + v40) = v41 + 1;
            v24 |= (unint64_t)(v42 & 0x7F) << v38;
            if (v42 < 0)
            {
              v28 = 0;
              v38 += 7;
              v29 = v11;
              v30 = v39++ > 8;
              if (v30)
                goto LABEL_129;
              continue;
            }
            break;
          }
          v29 = v11;
          goto LABEL_126;
        case 3u:
          v43 = 0;
          v44 = 0;
          v24 = 0;
          while (2)
          {
            v45 = *v4;
            v46 = *(_QWORD *)(a2 + v45);
            if (v46 == -1 || v46 >= *(_QWORD *)(a2 + *v5))
            {
              v29 = v12;
              goto LABEL_125;
            }
            v47 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v46);
            *(_QWORD *)(a2 + v45) = v46 + 1;
            v24 |= (unint64_t)(v47 & 0x7F) << v43;
            if (v47 < 0)
            {
              v28 = 0;
              v43 += 7;
              v29 = v12;
              v30 = v44++ > 8;
              if (v30)
                goto LABEL_129;
              continue;
            }
            break;
          }
          v29 = v12;
          goto LABEL_126;
        case 4u:
          v48 = 0;
          v49 = 0;
          v24 = 0;
          while (2)
          {
            v50 = *v4;
            v51 = *(_QWORD *)(a2 + v50);
            if (v51 == -1 || v51 >= *(_QWORD *)(a2 + *v5))
            {
              v29 = &OBJC_IVAR___VCMediaNegotiationBlobMultiwayVideoStream__streamID;
              goto LABEL_125;
            }
            v52 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v51);
            *(_QWORD *)(a2 + v50) = v51 + 1;
            v24 |= (unint64_t)(v52 & 0x7F) << v48;
            if (v52 < 0)
            {
              v28 = 0;
              v48 += 7;
              v29 = &OBJC_IVAR___VCMediaNegotiationBlobMultiwayVideoStream__streamID;
              v30 = v49++ > 8;
              if (v30)
                goto LABEL_129;
              continue;
            }
            break;
          }
          v29 = &OBJC_IVAR___VCMediaNegotiationBlobMultiwayVideoStream__streamID;
          goto LABEL_126;
        case 5u:
          v53 = 0;
          v54 = 0;
          v24 = 0;
          *(_BYTE *)(a1 + *(int *)(v10 + 2336)) |= 8u;
          while (2)
          {
            v55 = *v4;
            v56 = *(_QWORD *)(a2 + v55);
            if (v56 == -1 || v56 >= *(_QWORD *)(a2 + *v5))
            {
              v29 = &OBJC_IVAR___VCMediaNegotiationBlobMultiwayVideoStream__metadata;
              goto LABEL_125;
            }
            v57 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v56);
            *(_QWORD *)(a2 + v55) = v56 + 1;
            v24 |= (unint64_t)(v57 & 0x7F) << v53;
            if (v57 < 0)
            {
              v28 = 0;
              v53 += 7;
              v29 = &OBJC_IVAR___VCMediaNegotiationBlobMultiwayVideoStream__metadata;
              v30 = v54++ > 8;
              if (v30)
                goto LABEL_129;
              continue;
            }
            break;
          }
          v29 = &OBJC_IVAR___VCMediaNegotiationBlobMultiwayVideoStream__metadata;
          goto LABEL_126;
        case 6u:
          v58 = 0;
          v59 = 0;
          v24 = 0;
          while (2)
          {
            v60 = *v4;
            v61 = *(_QWORD *)(a2 + v60);
            if (v61 == -1 || v61 >= *(_QWORD *)(a2 + *v5))
            {
              v29 = &OBJC_IVAR___VCMediaNegotiationBlobMultiwayVideoStream__qualityIndex;
              goto LABEL_125;
            }
            v62 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v61);
            *(_QWORD *)(a2 + v60) = v61 + 1;
            v24 |= (unint64_t)(v62 & 0x7F) << v58;
            if (v62 < 0)
            {
              v28 = 0;
              v58 += 7;
              v29 = &OBJC_IVAR___VCMediaNegotiationBlobMultiwayVideoStream__qualityIndex;
              v30 = v59++ > 8;
              if (v30)
                goto LABEL_129;
              continue;
            }
            break;
          }
          v29 = &OBJC_IVAR___VCMediaNegotiationBlobMultiwayVideoStream__qualityIndex;
          goto LABEL_126;
        case 7u:
          v63 = 0;
          v64 = 0;
          v24 = 0;
          while (2)
          {
            v65 = *v4;
            v66 = *(_QWORD *)(a2 + v65);
            if (v66 == -1 || v66 >= *(_QWORD *)(a2 + *v5))
            {
              v29 = &OBJC_IVAR___VCMediaNegotiationBlobMultiwayVideoStream__supportedVideoFormats;
              goto LABEL_125;
            }
            v67 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v66);
            *(_QWORD *)(a2 + v65) = v66 + 1;
            v24 |= (unint64_t)(v67 & 0x7F) << v63;
            if (v67 < 0)
            {
              v28 = 0;
              v63 += 7;
              v29 = &OBJC_IVAR___VCMediaNegotiationBlobMultiwayVideoStream__supportedVideoFormats;
              v30 = v64++ > 8;
              if (v30)
                goto LABEL_129;
              continue;
            }
            break;
          }
          v29 = &OBJC_IVAR___VCMediaNegotiationBlobMultiwayVideoStream__supportedVideoFormats;
          goto LABEL_126;
        case 8u:
          v68 = 0;
          v69 = 0;
          v24 = 0;
          while (2)
          {
            v70 = *v4;
            v71 = *(_QWORD *)(a2 + v70);
            if (v71 == -1 || v71 >= *(_QWORD *)(a2 + *v5))
            {
              v29 = &OBJC_IVAR___VCMediaNegotiationBlobMultiwayVideoStream__frameRate;
              goto LABEL_125;
            }
            v72 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v71);
            *(_QWORD *)(a2 + v70) = v71 + 1;
            v24 |= (unint64_t)(v72 & 0x7F) << v68;
            if (v72 < 0)
            {
              v28 = 0;
              v68 += 7;
              v29 = &OBJC_IVAR___VCMediaNegotiationBlobMultiwayVideoStream__frameRate;
              v30 = v69++ > 8;
              if (v30)
                goto LABEL_129;
              continue;
            }
            break;
          }
          v29 = &OBJC_IVAR___VCMediaNegotiationBlobMultiwayVideoStream__frameRate;
          goto LABEL_126;
        case 9u:
          v73 = 0;
          v74 = 0;
          v24 = 0;
          while (2)
          {
            v75 = *v4;
            v76 = *(_QWORD *)(a2 + v75);
            if (v76 == -1 || v76 >= *(_QWORD *)(a2 + *v5))
            {
              v29 = &OBJC_IVAR___VCMediaNegotiationBlobMultiwayVideoStream__keyFrameInterval;
              goto LABEL_125;
            }
            v77 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v76);
            *(_QWORD *)(a2 + v75) = v76 + 1;
            v24 |= (unint64_t)(v77 & 0x7F) << v73;
            if (v77 < 0)
            {
              v28 = 0;
              v73 += 7;
              v29 = &OBJC_IVAR___VCMediaNegotiationBlobMultiwayVideoStream__keyFrameInterval;
              v30 = v74++ > 8;
              if (v30)
                goto LABEL_129;
              continue;
            }
            break;
          }
          v29 = &OBJC_IVAR___VCMediaNegotiationBlobMultiwayVideoStream__keyFrameInterval;
          goto LABEL_126;
        case 0xAu:
          v78 = 0;
          v79 = 0;
          v24 = 0;
          *(_BYTE *)(a1 + *(int *)(v10 + 2336)) |= 1u;
          while (2)
          {
            v80 = *v4;
            v81 = *(_QWORD *)(a2 + v80);
            if (v81 == -1 || v81 >= *(_QWORD *)(a2 + *v5))
            {
              v29 = &OBJC_IVAR___VCMediaNegotiationBlobMultiwayVideoStream__maxMediaBitrate;
              goto LABEL_125;
            }
            v82 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v81);
            *(_QWORD *)(a2 + v80) = v81 + 1;
            v24 |= (unint64_t)(v82 & 0x7F) << v78;
            if (v82 < 0)
            {
              v28 = 0;
              v78 += 7;
              v29 = &OBJC_IVAR___VCMediaNegotiationBlobMultiwayVideoStream__maxMediaBitrate;
              v30 = v79++ > 8;
              if (v30)
                goto LABEL_129;
              continue;
            }
            break;
          }
          v29 = &OBJC_IVAR___VCMediaNegotiationBlobMultiwayVideoStream__maxMediaBitrate;
          goto LABEL_126;
        case 0xBu:
          v83 = 0;
          v84 = 0;
          v24 = 0;
          *(_BYTE *)(a1 + *(int *)(v10 + 2336)) |= 4u;
          while (2)
          {
            v85 = *v4;
            v86 = *(_QWORD *)(a2 + v85);
            if (v86 == -1 || v86 >= *(_QWORD *)(a2 + *v5))
            {
              v29 = &OBJC_IVAR___VCMediaNegotiationBlobMultiwayVideoStream__maxPacketsPerSecond;
              goto LABEL_125;
            }
            v87 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v86);
            *(_QWORD *)(a2 + v85) = v86 + 1;
            v24 |= (unint64_t)(v87 & 0x7F) << v83;
            if (v87 < 0)
            {
              v28 = 0;
              v83 += 7;
              v29 = &OBJC_IVAR___VCMediaNegotiationBlobMultiwayVideoStream__maxPacketsPerSecond;
              v30 = v84++ > 8;
              if (v30)
                goto LABEL_129;
              continue;
            }
            break;
          }
          v29 = &OBJC_IVAR___VCMediaNegotiationBlobMultiwayVideoStream__maxPacketsPerSecond;
          goto LABEL_126;
        case 0xCu:
          v88 = 0;
          v89 = 0;
          v24 = 0;
          *(_BYTE *)(a1 + *(int *)(v10 + 2336)) |= 0x20u;
          while (2)
          {
            v90 = *v4;
            v91 = *(_QWORD *)(a2 + v90);
            if (v91 == -1 || v91 >= *(_QWORD *)(a2 + *v5))
            {
              v29 = &OBJC_IVAR___VCMediaNegotiationBlobMultiwayVideoStream__repairedStreamID;
              goto LABEL_125;
            }
            v92 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v91);
            *(_QWORD *)(a2 + v90) = v91 + 1;
            v24 |= (unint64_t)(v92 & 0x7F) << v88;
            if (v92 < 0)
            {
              v28 = 0;
              v88 += 7;
              v29 = &OBJC_IVAR___VCMediaNegotiationBlobMultiwayVideoStream__repairedStreamID;
              v30 = v89++ > 8;
              if (v30)
                goto LABEL_129;
              continue;
            }
            break;
          }
          v29 = &OBJC_IVAR___VCMediaNegotiationBlobMultiwayVideoStream__repairedStreamID;
          goto LABEL_126;
        case 0xDu:
          v93 = 0;
          v94 = 0;
          v24 = 0;
          *(_BYTE *)(a1 + *(int *)(v10 + 2336)) |= 0x10u;
          break;
        default:
          v31 = v8;
          v32 = v10;
          v33 = v11;
          v34 = v2;
          v35 = v12;
          v99 = a1;
          v36 = v6;
          v37 = PBReaderSkipValueWithTag();
          v6 = v36;
          a1 = v99;
          v12 = v35;
          v2 = v34;
          v11 = v33;
          v10 = v32;
          v8 = v31;
          if ((v37 & 1) != 0)
            continue;
          return 0;
      }
      while (1)
      {
        v95 = *v4;
        v96 = *(_QWORD *)(a2 + v95);
        if (v96 == -1 || v96 >= *(_QWORD *)(a2 + *v5))
          break;
        v97 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v96);
        *(_QWORD *)(a2 + v95) = v96 + 1;
        v24 |= (unint64_t)(v97 & 0x7F) << v93;
        if ((v97 & 0x80) == 0)
        {
          v29 = &OBJC_IVAR___VCMediaNegotiationBlobMultiwayVideoStream__repairedMaxNetworkBitrate;
          goto LABEL_126;
        }
        v28 = 0;
        v93 += 7;
        v29 = &OBJC_IVAR___VCMediaNegotiationBlobMultiwayVideoStream__repairedMaxNetworkBitrate;
        v30 = v94++ > 8;
        if (v30)
          goto LABEL_129;
      }
      v29 = &OBJC_IVAR___VCMediaNegotiationBlobMultiwayVideoStream__repairedMaxNetworkBitrate;
LABEL_125:
      *(_BYTE *)(a2 + *v6) = 1;
LABEL_126:
      v28 = *(_BYTE *)(a2 + *v6) ? 0 : v24;
LABEL_129:
      *(_DWORD *)(a1 + *v29) = v28;
    }
    while (*(_QWORD *)(a2 + *v4) < *(_QWORD *)(a2 + *v5));
  }
  return *(_BYTE *)(a2 + *v6) == 0;
}

void VCAudioManager_PullAudioSamples(uint64_t a1, uint64_t a2)
{
  unsigned int *AudioBufferList;
  int ChannelCount;
  double HostTime;
  int v7;
  _QWORD *v8;
  BOOL v9;
  uint64_t *v10;
  float v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int v15;
  _BOOL4 v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  void **v29;
  uint64_t v30;
  uint64_t v31;
  BOOL v32;
  float v33;
  BOOL v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t *v38;
  int Timestamp;
  unsigned int SampleCount;
  int v41;
  unsigned int v42;
  _QWORD v43[3];

  v43[2] = *MEMORY[0x1E0C80C00];
  v41 = *(_DWORD *)(a1 + 104);
  *(_QWORD *)(a1 + 112) = 0;
  _VCAudioManager_ProcessEventQueue(a1);
  VCAudioBufferList_InvalidateStats(a2);
  v43[0] = 0xAAAAAAAAAAAAAAAALL;
  v43[1] = 0xAAAAAAAAAAAAAAAALL;
  AudioBufferList = (unsigned int *)VCAudioBufferList_GetAudioBufferList(a2);
  VCAudioIOControllerIOState_GetControllerTimestamp(a2, a1, (uint64_t)v43);
  ChannelCount = VCAudioBufferList_GetChannelCount(a2);
  HostTime = VCAudioBufferList_GetHostTime(a2);
  SampleCount = VCAudioBufferList_GetSampleCount(a2);
  Timestamp = VCAudioBufferList_GetTimestamp(a2);
  v7 = VCAudioBufferList_GetChannelCount(*(_QWORD *)(a1 + 88));
  v8 = *(_QWORD **)(a1 + 40);
  v38 = (uint64_t *)a1;
  v35 = a2;
  if (v8)
  {
    v34 = 0;
    v9 = 0;
    v42 = 0;
    v10 = (uint64_t *)(a1 + 96);
    if (v7 == ChannelCount)
      v10 = (uint64_t *)(a1 + 88);
    v36 = a2;
    v37 = v10;
    v11 = 0.0;
    v12 = a2;
    while (1)
    {
      v13 = v8[1];
      v14 = VCAudioBufferList_GetChannelCount(*(_QWORD *)(v13 + 40));
      v15 = v14;
      v17 = *(_DWORD *)(v13 + 24) == v41 || ChannelCount == v14;
      VCAudioBufferList_Reset(*(_QWORD *)(v13 + 40));
      v18 = *(_QWORD *)(v13 + 40);
      if (!v17)
        goto LABEL_23;
      v19 = *(_DWORD *)(v13 + 28);
      v20 = 1 << v19;
      if (ChannelCount == v15)
      {
        v9 = v12 != v35;
        v21 = *v37;
        v34 = v12 != v35;
      }
      else
      {
        if (!(v19 + v15))
          goto LABEL_21;
        v22 = VCAudioBufferList_GetAudioBufferList(*(_QWORD *)(v13 + 40));
        if (v15)
        {
          v23 = *(_DWORD *)(v13 + 28);
          v24 = v15;
          v25 = (_QWORD *)(v22 + 16);
          do
          {
            *v25 = *(_QWORD *)&AudioBufferList[4 * v23 + 4];
            v25 += 2;
            ++v23;
            --v24;
          }
          while (v24);
        }
        if ((v38[14] & v20) == 0)
        {
          v9 = 0;
LABEL_21:
          v21 = v12;
          v12 = v18;
          goto LABEL_22;
        }
        v21 = v12;
        v12 = *v37;
        v36 = *(_QWORD *)(v13 + 40);
        v9 = 1;
      }
LABEL_22:
      v18 = v12;
      v38[14] |= v20;
      ++v42;
      v12 = v21;
LABEL_23:
      VCAudioBufferList_SetTime(v18, Timestamp, HostTime);
      VCAudioBufferList_SetSampleCount(v18, SampleCount);
      VCAudioBufferList_InvalidateNetworkTimestamp(v18);
      (*(void (**)(_QWORD, _QWORD *, uint64_t))(v13 + 8))(*(_QWORD *)v13, v43, v18);
      if (v17)
      {
        v11 = v11 + VCAudioBufferList_GetAveragePower(v18);
        if (v9)
          VCAudioBufferList_Mix(v36, v18);
      }
      v8 = (_QWORD *)*v8;
      if (!v8)
        goto LABEL_29;
    }
  }
  v42 = 0;
  v34 = 0;
  v11 = 0.0;
LABEL_29:
  v26 = v38[14];
  v27 = v38[15];
  v28 = v27 & ~v26;
  if (v28)
  {
    v29 = (void **)(AudioBufferList + 4);
    v30 = -1;
    v31 = v35;
    do
    {
      if (++v30 >= (unint64_t)*AudioBufferList)
        break;
      if ((v28 & 1) != 0)
        bzero(*v29, *((unsigned int *)v29 - 1));
      v29 += 2;
      v32 = v28 >= 2;
      v28 >>= 1;
    }
    while (v32);
    v26 = v38[14];
    v27 = v38[15];
  }
  else
  {
    v31 = v35;
  }
  v38[15] = v26 | v27;
  if (v34)
    VCAudioLimiter_Process(v38[10], v31);
  if (v42)
    v33 = v11 / (float)v42;
  else
    v33 = -120.0;
  VCAudioBufferList_SetAveragePower(v31, v33);
}

void _VCAudioManager_ProcessEventQueue(uint64_t a1)
{
  double v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  int v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  int v16;
  int v17;
  uint8_t buf[4];
  uint64_t v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  int v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v2 = 0.0;
  if (VRTraceIsInternalOSInstalled())
    v2 = micro();
  v3 = CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 72));
  if (v3)
  {
    v11 = v3;
    v12 = 0;
    while (1)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v13 = VRTraceErrorLogLevelToCSTR();
        v14 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v15 = v11[1];
          v16 = *((_DWORD *)v11 + 4);
          *(_DWORD *)buf = 136316674;
          v19 = v13;
          v20 = 2080;
          v21 = "_VCAudioManager_ProcessEventQueue";
          v22 = 1024;
          v23 = 144;
          v24 = 2080;
          v25 = a1 + 128;
          v26 = 2048;
          v27 = a1;
          v28 = 2048;
          v29 = v15;
          v30 = 1024;
          v31 = v16;
          _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d %sProcess event: controllerIO=%p clientIO=%p type=%d", buf, 0x40u);
        }
      }
      v17 = *((_DWORD *)v11 + 4);
      if (v17 == 2)
        goto LABEL_13;
      if (v17 == 1)
        break;
      if (!v17)
      {
        _VCAudioManager_RegisterClientIO(a1, v11);
LABEL_13:
        _VCAudioManager_CheckVoiceDetectorEnabled(a1);
      }
      v11 = CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 72));
      ++v12;
      if (!v11)
        goto LABEL_15;
    }
    _VCAudioManager_UnregisterClientIO(a1, (uint64_t)v11);
    goto LABEL_13;
  }
LABEL_15:
  LogProfileTimeOverLimit(v2, 0, v4, v5, v6, v7, v8, v9, v10, (char)"_VCAudioManager_ProcessEventQueue");
}

void VCAudioManager_PushAudioSamples(uint64_t a1, uint64_t a2)
{
  double HostTime;
  double v5;
  unsigned int v6;
  _BOOL4 v7;
  unint64_t v8;
  _QWORD *i;
  char v10;
  _QWORD v11[3];

  v11[2] = *MEMORY[0x1E0C80C00];
  _VCAudioManager_ProcessEventQueue(a1);
  v11[0] = 0xAAAAAAAAAAAAAAAALL;
  v11[1] = 0xAAAAAAAAAAAAAAAALL;
  VCAudioIOControllerIOState_GetControllerTimestamp(a2, a1, (uint64_t)v11);
  if (!*(_QWORD *)(a1 + 192))
    goto LABEL_10;
  HostTime = VCAudioBufferList_GetHostTime(a2);
  if (*(_BYTE *)(a1 + 184))
  {
    v5 = HostTime;
    if (HostTime - *(double *)(a1 + 176) <= 1.0)
    {
      v6 = *(unsigned __int8 *)(a1 + 185);
    }
    else
    {
      v6 = -[VCDefaults forceAudioPriorityValue](+[VCDefaults sharedInstance](VCDefaults, "sharedInstance"), "forceAudioPriorityValue");
      *(_BYTE *)(a1 + 185) = v6;
      *(double *)(a1 + 176) = v5;
      if (!*(_BYTE *)(a1 + 184))
        goto LABEL_5;
    }
    v7 = v6 > 1;
    VCAudioBufferList_SetPriority(a2, v6);
    VCAudioBufferList_SetVoiceActivity(a2, v7);
    LOBYTE(v8) = *(_BYTE *)(a1 + 185);
    VCAudioBufferList_SetVoiceProbability(a2, (double)v8 / 255.0);
    goto LABEL_10;
  }
LABEL_5:
  if (!VCAudioBufferList_GetPriority(a2))
  {
    if (*(_BYTE *)(a1 + 170))
    {
      VCVoiceDetector_ProcessSampleBuffer(*(_QWORD **)(a1 + 192), a2, *(_BYTE *)(a1 + 168));
    }
    else
    {
      if (VCAudioBufferList_GetVoiceActivity(a2))
        v10 = 0x80;
      else
        v10 = 1;
      VCAudioBufferList_SetPriority(a2, v10);
    }
  }
LABEL_10:
  for (i = *(_QWORD **)(a1 + 40); i; i = (_QWORD *)*i)
    (*(void (**)(_QWORD, _QWORD *, uint64_t))(i[1] + 8))(*(_QWORD *)i[1], v11, a2);
}

void VCAudioManager_InputDeviceSelectionCallback(void *a1, uint64_t a2)
{
  id v3;
  id v4;

  v4 = +[AVAudioDeviceList deviceForDeviceID:](AVAudioDeviceList, "deviceForDeviceID:", a2);
  v3 = v4;
  objc_msgSend(a1, "updateCurrentInputDevice:", v4);

}

void VCAudioManager_OutputDeviceSelectionCallback(void *a1, uint64_t a2)
{
  id v3;
  id v4;

  v4 = +[AVAudioDeviceList deviceForDeviceID:](AVAudioDeviceList, "deviceForDeviceID:", a2);
  v3 = v4;
  objc_msgSend(a1, "updateCurrentOutputDevice:", v4);

}

uint64_t _VCAudioManger_CompareControllerEntries(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  BOOL v4;
  unsigned int v5;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a2 + 8);
  v4 = v2 == v3;
  v5 = 2 * (v2 >= v3);
  if (v4)
    return 1;
  else
    return v5;
}

void VCAudioManager_ReleaseAudioEvent(uint64_t *a1, int a2)
{
  uint64_t v2;

  if (a1)
  {
    v2 = *a1;
    if (*a1)
    {
      *a1 = 0;
      if (*(_QWORD *)(v2 + 8))
      {
        if (a2)
          dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v2 + 24));
        dispatch_release(*(dispatch_object_t *)(v2 + 24));
      }
      free((void *)v2);
    }
  }
}

void LogProfileTimeOverLimit(double a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10)
{
  double v11;
  __int128 v12;
  uint64_t v13;
  NSObject *v14;
  uint8_t buf[4];
  uint64_t v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  char *v22;
  __int16 v23;
  double v24;
  char __str[16];
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  if (VRTraceIsInternalOSInstalled())
  {
    v11 = micro() - a1;
    if (v11 > 0.00300000003)
    {
      *(_QWORD *)&v12 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v39 = v12;
      v40 = v12;
      v37 = v12;
      v38 = v12;
      v35 = v12;
      v36 = v12;
      v33 = v12;
      v34 = v12;
      v31 = v12;
      v32 = v12;
      v30 = v12;
      v28 = v12;
      v29 = v12;
      v26 = v12;
      v27 = v12;
      *(_OWORD *)__str = v12;
      vsnprintf(__str, 0x100uLL, "%s: Iterations=%d", &a10);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v13 = VRTraceErrorLogLevelToCSTR();
        v14 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316162;
          v16 = v13;
          v17 = 2080;
          v18 = "_LogProfileTimeLimitHelper";
          v19 = 1024;
          v20 = 36;
          v21 = 2080;
          v22 = __str;
          v23 = 2048;
          v24 = v11;
          _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d %s: Took a long time %fs", buf, 0x30u);
        }
      }
    }
  }
}

_DWORD *VCAudioManager_NewAudioEvent(int a1, uint64_t a2)
{
  _DWORD *v4;
  _DWORD *v5;
  NSObject *v6;

  v4 = malloc_type_calloc(1uLL, 0x20uLL, 0x10A00405C5CD52DuLL);
  v5 = v4;
  v4[4] = a1;
  if (a2)
  {
    *((_QWORD *)v4 + 1) = a2;
    v6 = *(NSObject **)(a2 + 16);
    *((_QWORD *)v5 + 3) = v6;
    dispatch_retain(v6);
  }
  return v5;
}

void _VCAudioManager_RegisterClientIO(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  _QWORD *v7;
  uint8_t buf[4];
  uint64_t v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v7 = a2;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v6 = a2[1];
      *(_DWORD *)buf = 136316162;
      v9 = v4;
      v10 = 2080;
      v11 = "_VCAudioManager_RegisterClientIO";
      v12 = 1024;
      v13 = 131;
      v14 = 2080;
      v15 = a1 + 128;
      v16 = 2048;
      v17 = v6;
      _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d %sRegistering clientIO[%p]", buf, 0x30u);
    }
  }
  if ((VCSingleLinkedListPush(a1 + 40, a2) & 1) == 0)
    VCAudioManager_ReleaseAudioEvent((uint64_t *)&v7, 0);
}

void _VCAudioManager_UnregisterClientIO(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  _BYTE buf[12];
  __int16 v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  uint64_t v14;
  __int16 v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v7 = a2;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_QWORD *)(a2 + 8);
      *(_DWORD *)buf = 136316162;
      *(_QWORD *)&buf[4] = v4;
      v9 = 2080;
      v10 = "_VCAudioManager_UnregisterClientIO";
      v11 = 1024;
      v12 = 121;
      v13 = 2080;
      v14 = a1 + 128;
      v15 = 2048;
      v16 = v6;
      _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d %sUnregistering clientIO[%p]", buf, 0x30u);
    }
  }
  *(_QWORD *)buf = VCSingleLinkedListRemove(a1 + 40, a2);
  if (*(_QWORD *)buf)
    VCAudioManager_ReleaseAudioEvent((uint64_t *)buf, 0);
  VCAudioManager_ReleaseAudioEvent(&v7, 1);
}

uint64_t _VCAudioManager_CheckVoiceDetectorEnabled(uint64_t result)
{
  _QWORD *v1;
  BOOL v2;
  BOOL v3;
  uint64_t v4;

  v1 = *(_QWORD **)(result + 40);
  if (v1)
  {
    v2 = 0;
    v3 = 0;
    while (1)
    {
      v4 = v1[1];
      if (v2)
      {
        v2 = 1;
        if (v3)
          goto LABEL_7;
      }
      else
      {
        v2 = *(_BYTE *)(v4 + 48) != 0;
        if (v3)
        {
LABEL_7:
          v3 = 1;
          goto LABEL_8;
        }
      }
      v3 = *(_BYTE *)(v4 + 49) != 0;
LABEL_8:
      v1 = (_QWORD *)*v1;
      if (!v1)
        goto LABEL_11;
    }
  }
  v3 = 0;
  v2 = 0;
LABEL_11:
  *(_BYTE *)(result + 169) = v2;
  *(_BYTE *)(result + 170) = v3;
  return result;
}

void OUTLINED_FUNCTION_7_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0x22u);
}

void OUTLINED_FUNCTION_10_0(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x26u);
}

uint64_t _AVCRateController_ConfigureInternal(uint64_t a1, int *a2)
{
  int v4;
  int *v5;
  void *v6;
  int v7;
  uint64_t v8;
  int v9;
  const char *v10;
  const char *v11;
  FILE **v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  FILE **v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  FILE **v27;
  uint64_t v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  unsigned int v32;
  _BOOL4 v33;
  unsigned int v34;
  uint64_t v35;
  char v36;
  uint64_t v37;
  unsigned int v38;
  unsigned int v40;
  unsigned int v41;
  unsigned int v42;
  int v43;
  int v44;
  int v45;
  _BYTE *v46;
  int v47;
  int v48;
  uint64_t v49;
  unsigned int v50;
  unsigned int v51;
  int v52;
  int *v53;
  unsigned int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  uint64_t v59;
  int v60;
  id v61;
  const __CFString *v62;
  uint64_t v63;
  NSObject *v64;
  NSObject *v65;
  const __CFString *v66;
  void *v67;
  unsigned int v68;
  uint64_t v69;
  unsigned int v70;
  uint64_t v71;
  NSObject *v72;
  NSObject *v73;
  int v74;
  int v75;
  __int128 v76;
  char v77;
  double v78;
  int v83;
  int v84;
  _BOOL4 v85;
  int v86;
  int v87;
  double v88;
  uint64_t v89;
  int v90;
  unsigned int v91;
  int v92;
  int v93;
  int *v94;
  unsigned int v95;
  uint64_t v96;
  unsigned int v97;
  int v98;
  unsigned int v99;
  int v100;
  _BOOL4 IsAudioOnly;
  unsigned int v102;
  uint64_t v103;
  int v104;
  int *v105;
  unsigned int v106;
  int v107;
  unsigned int v108;
  uint64_t v109;
  unsigned int v110;
  uint64_t v111;
  int v112;
  unsigned int v113;
  unsigned int v114;
  int v115;
  uint64_t v116;
  int v117;
  unsigned int v118;
  int v119;
  int *v120;
  unsigned int v121;
  BOOL v122;
  uint64_t v123;
  unsigned int v124;
  unsigned int v125;
  int v126;
  int *v127;
  unsigned int v128;
  int v129;
  int v130;
  int v131;
  int v132;
  int *v133;
  unsigned int v134;
  int v135;
  unsigned int v136;
  uint64_t v137;
  unsigned int v138;
  void *v141;
  int v142;
  uint64_t v143;
  NSObject *v144;
  uint64_t v145;
  void *v146;
  int v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  NSObject *v151;
  uint64_t v152;
  void *v153;
  int v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  NSObject *v158;
  uint64_t v159;
  void *v160;
  int v161;
  uint64_t v162;
  uint64_t v163;
  NSObject *v164;
  uint64_t v165;
  void *v166;
  int v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  NSObject *v172;
  uint64_t v173;
  void *v174;
  int v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  NSObject *v180;
  uint64_t v181;
  int v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  NSObject *v186;
  uint64_t v187;
  int v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  NSObject *v193;
  uint64_t v194;
  int v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  NSObject *v199;
  uint64_t v200;
  int v201;
  uint64_t v202;
  uint64_t v203;
  NSObject *v204;
  uint64_t v205;
  void *v206;
  int v207;
  float64_t v208;
  float64_t v209;
  float64_t v210;
  float64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  NSObject *v216;
  uint64_t v217;
  int v218;
  uint64_t v219;
  uint64_t v220;
  NSObject *v221;
  uint64_t v222;
  int v223;
  double v224;
  uint64_t v225;
  uint64_t v226;
  NSObject *v227;
  uint64_t v228;
  void *v229;
  int v230;
  double v231;
  uint64_t v232;
  NSObject *v233;
  uint64_t v234;
  int v235;
  const __CFString *v236;
  void *v237;
  int v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  NSObject *v243;
  uint64_t v244;
  int v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  NSObject *v252;
  uint64_t v253;
  const __CFString *v254;
  const __CFString *v255;
  uint64_t v256;
  NSObject *v257;
  const char *v258;
  NSObject *v259;
  uint32_t v260;
  uint64_t v261;
  NSObject *v262;
  const char *v263;
  NSObject *v264;
  uint32_t v265;
  uint64_t v266;
  NSObject *v267;
  uint64_t v268;
  NSObject *v269;
  uint64_t v270;
  NSObject *v271;
  unsigned int v272;
  int v273;
  int v274;
  int *v275;
  unsigned int v276;
  const __CFString *v277;
  uint64_t v278;
  NSObject *v279;
  int v280;
  const char *v281;
  NSObject *v282;
  uint32_t v283;
  uint64_t v284;
  NSObject *v285;
  const __CFString *v286;
  uint64_t v287;
  NSObject *v288;
  int v289;
  const char *v290;
  NSObject *v291;
  uint32_t v292;
  uint64_t v293;
  NSObject *v294;
  _BOOL8 v295;
  uint64_t v296;
  uint64_t v297;
  uint64_t v298;
  _BOOL4 v299;
  VCRateControlAlgorithmLayeredContinuousTier *v300;
  int v302;
  __objc2_class *v303;
  void *v304;
  void *v305;
  int v306;
  void *v307;
  void *v308;
  uint64_t v309;
  uint64_t v310;
  unsigned int v311;
  unsigned int v312;
  int32x2_t v313;
  double v314;
  unsigned int v315;
  __int128 v316;
  int v318;
  int v319;
  int v320;
  char v321;
  char v322;
  void *v323;
  int *v324;
  uint64_t v325;
  uint64_t v326;
  int *v327;
  uint64_t v328;
  int v329;
  int IntValueForKey;
  int v331;
  int v332;
  int v333;
  uint64_t v334;
  __int128 v335;
  int v336;
  int v337;
  int v338;
  int v339;
  float64x2_t v340;
  float64x2_t v341;
  uint64_t v342;
  double v343;
  _BYTE v344[32];
  __int128 v345;
  __int128 v346;
  int v347;
  uint64_t v348;
  double v349;
  __int128 v350;
  uint64_t v351;
  __int128 v352;
  _BYTE v353[24];
  __int128 v354;
  __int128 v355;
  int v356;
  _QWORD v357[5];
  BOOL BoolValueForKey;
  BOOL v359;
  BOOL v360;
  __int16 v361;
  BOOL v362;
  unsigned __int8 v363;
  unsigned __int8 v364;
  unsigned __int8 v365;
  BOOL v366;
  unsigned __int8 v367;
  char v368;
  char v369;
  BOOL v370;
  int v371;
  char v372;
  __int128 v373;
  int v374;
  uint64_t v375;
  int v376;
  __int128 v377;
  uint64_t v378;
  int v379;
  uint64_t v380;
  uint64_t v381;
  __int128 v382;
  int v383;
  uint64_t v384;
  __int128 v385;
  __int128 v386;
  uint64_t v387;
  uint64_t v388;
  __int128 v389;
  __int128 v390;
  __int128 v391;
  __int128 v392;
  __int128 v393;
  char v394;
  uint64_t v395;
  uint64_t v396;
  char v397;
  int v398;
  __int128 v399;
  __int128 v400;
  __int128 v401;
  uint64_t v402;
  __int128 v403;
  uint64_t v404;
  __int128 v405;
  uint64_t v406;
  int v407;
  __int128 v408;
  uint64_t v409;
  unsigned int v410;
  __int128 v411;
  __int128 v412;
  __int128 v413;
  __int128 v414;
  __int128 v415;
  __int128 v416;
  __int128 v417;
  __int128 v418;
  __int128 v419;
  __int128 v420;
  __int128 v421;
  __int128 v422;
  const __CFString *v423;
  uint64_t v424;
  _OWORD v425[2];
  _OWORD buf[50];
  int v427;
  uint64_t v428;

  v428 = *MEMORY[0x1E0C80C00];
  v5 = (int *)(a1 + 64);
  v4 = *(_DWORD *)(a1 + 64);
  v6 = *(void **)(a1 + 24);
  v7 = *a2;
  if (v4 != *a2)
  {
    *(_DWORD *)(a1 + 64) = v7;
    v8 = *(_QWORD *)(a1 + 56);
    if (v8 && (v7 - 1) <= 2)
      VCRateControlMediaController_SetAudioOnly(v8, (v7 - 1) & 1);
    if ((!*(_QWORD *)(a1 + 1264) || !*(_QWORD *)(a1 + 1272)) && *(_BYTE *)(a1 + 1304))
    {
      v9 = *(_DWORD *)(a1 + 64);
      v10 = "VCRateControl";
      if (v9 == 5)
        v10 = "VCRC-DL";
      if (v9 == 4)
        v11 = "VCRC-UL";
      else
        v11 = v10;
      v12 = VRLogfileAlloc(0, objc_msgSend(*(id *)(a1 + 1312), "UTF8String"), (uint64_t)v11, (uint64_t)".afrcdump", "com.apple.VideoConference.VCRClog", 9);
      *(_QWORD *)(a1 + 1264) = v12;
      VRLogfilePrintSync(v12, "STime\t\tdTime/ETxTS\tOWRD\tNOWRD\tNOWRDS\tNOWRDA\tUp\tRTT\tPLR/FEC\tRRx\tMBL\tLRx\tBR/TR\tMQIn: A/V\tMQOut: A/V\tABRL\tQD\tBDL\tTxAT\tMODE\tTxSTATE\tLBAWall\tWallConf\tBadTrend\tECNRate\tSBProb\tSBBW\tSBBWE\n", v13, v14, v15, v16, v17, v18, v321);
      v19 = VRLogfileAlloc(0, objc_msgSend(*(id *)(a1 + 1312), "UTF8String"), (uint64_t)v11, (uint64_t)".fbdump", "com.apple.VideoConference.VCRClogFB", 9);
      *(_QWORD *)(a1 + 1272) = v19;
      v26 = *(_DWORD *)(a1 + 64) - 1;
      if (v26 <= 8 && ((0x1DFu >> v26) & 1) != 0)
        VRLogfilePrintSync(v19, off_1E9E52458[v26], v20, v21, v22, v23, v24, v25, v322);
    }
    if (!*(_QWORD *)(a1 + 1296))
    {
      if (*(_BYTE *)(a1 + 1305) && (*v5 | 2) == 3)
      {
        v27 = VRLogfileAlloc(0, objc_msgSend(*(id *)(a1 + 1312), "UTF8String"), (uint64_t)"VCRateControl", (uint64_t)".bwedump", "com.apple.VideoConference.VCRClog", 9);
        *(_QWORD *)(a1 + 1296) = v27;
      }
      else
      {
        v27 = 0;
      }
      VCRateControlMediaController_EnableBWELogDump(*(_QWORD *)(a1 + 56), (uint64_t)v27);
      VCStatisticsCollector_EnableBWELogDump(*(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 1296));
    }
    VCStatisticsCollector_SetMode((uint64_t)v6, *(unsigned int *)(a1 + 64));
    VCRateControlFeedbackController_SetMode(*(_QWORD *)(a1 + 1792), *(_DWORD *)(a1 + 64));
    v28 = *(_QWORD *)(a1 + 40);
    if (v28)
      VCBasebandCongestionDetector_SetMode(v28, *v5);
  }
  v29 = a2[1];
  v30 = a2[2];
  v31 = (v29 < 7) & (0x1Eu >> v29);
  v32 = (v30 < 7) & (0x1Eu >> v30);
  v33 = v4 != v7;
  if (*(_DWORD *)(a1 + 68) != v29)
  {
    *(_DWORD *)(a1 + 68) = v29;
    v34 = (v29 < 7) & (0x7Cu >> v29);
    if (*(unsigned __int8 *)(a1 + 1321) != v34)
    {
      *(_BYTE *)(a1 + 1321) = v34;
      VCRateControlMediaController_SetAudioFractionTier(*(_QWORD *)(a1 + 56), 0);
      if (*(_DWORD *)(a1 + 64) != 2)
        VCRateControlMediaController_ResumeVideo(*(unsigned __int8 **)(a1 + 56));
    }
    objc_msgSend(*(id *)(a1 + 40), "setRadioAccessTechnology:", *(unsigned int *)(a1 + 68));
    if (v31 | v32)
      v35 = 1;
    else
      v35 = 5;
    VCStatisticsCollector_SetRadioAccessTechnology(*(_QWORD *)(a1 + 24), v35);
    if (v31)
      v36 = a2[1] != 3;
    else
      v36 = 0;
    VCRateControlMediaController_SetSenderProbingEnabled(*(_QWORD *)(a1 + 56), v36);
    v30 = a2[2];
    v33 = 1;
  }
  if (*(_DWORD *)(a1 + 72) != v30)
  {
    *(_DWORD *)(a1 + 72) = v30;
    if (v31 | v32)
      v37 = 1;
    else
      v37 = 5;
    VCStatisticsCollector_SetRadioAccessTechnology(*(_QWORD *)(a1 + 24), v37);
    v33 = 1;
  }
  v38 = *(_DWORD *)(a1 + 1340);
  if (a2[3] <= v38 || (int)v38 <= 0)
    v40 = a2[3];
  else
    v40 = *(_DWORD *)(a1 + 1340);
  if (*(_DWORD *)(a1 + 76) != v40)
  {
    *(_DWORD *)(a1 + 76) = v40;
    v33 = 1;
  }
  v41 = *(_DWORD *)(a1 + 80);
  v42 = a2[4];
  if (v41 != v42)
  {
    *(_DWORD *)(a1 + 80) = v42;
    v33 = 1;
    v41 = v42;
  }
  v43 = a2[5];
  if (*(_DWORD *)(a1 + 84) != v43)
  {
    *(_DWORD *)(a1 + 84) = v43;
    v33 = 1;
  }
  v44 = *(_DWORD *)(a1 + 104);
  v45 = a2[10];
  if (v44 == v45)
  {
    v46 = (_BYTE *)(a1 + 88);
    v47 = *((unsigned __int8 *)a2 + 24);
    if (*(unsigned __int8 *)(a1 + 88) == v47)
    {
      if (!v33)
        goto LABEL_370;
      goto LABEL_58;
    }
    goto LABEL_57;
  }
  v48 = *(unsigned __int8 *)(a1 + 88);
  v46 = (_BYTE *)(a1 + 88);
  *(_DWORD *)(a1 + 104) = v45;
  v47 = *((unsigned __int8 *)a2 + 24);
  if (v48 != v47)
LABEL_57:
    *v46 = v47;
LABEL_58:
  bzero(&v326, 0x3D0uLL);
  v327 = vcRateControlTierBitrates;
  v49 = 34;
  if (!*v46)
    v49 = 31;
  do
    v50 = vcRateControlTierBitrates[v49--];
  while (v50 > v40);
  v324 = v5;
  v51 = (v49 + 1) & ~(((int)v49 + 1) >> 31);
  HIDWORD(v328) = v51;
  v52 = -1;
  v53 = vcRateControlTierBitrates;
  do
  {
    v54 = *v53++;
    ++v52;
  }
  while (v54 < v41);
  if (v52 >= 31)
    v52 = 31;
  v329 = v52;
  v56 = *(_DWORD *)(a1 + 68);
  v55 = *(_DWORD *)(a1 + 72);
  if (v51 <= 0x11)
    v57 = 10;
  else
    v57 = 13;
  if (v51 <= 0x19)
    v58 = v57;
  else
    v58 = 17;
  v59 = vcRateControlTierBitrates[v58];
  v60 = *(_DWORD *)(a1 + 64);
  if ((v60 == 7 || v60 == 1) && (objc_opt_respondsToSelector() & 1) != 0)
  {
    v61 = objc_alloc(MEMORY[0x1E0CB3940]);
    if ((v56 - 1) > 3)
      v62 = CFSTR("S");
    else
      v62 = off_1E9E524A0[v56 - 1];
    if ((v55 - 1) > 3)
      v66 = CFSTR("S");
    else
      v66 = off_1E9E524A0[v55 - 1];
    v67 = (void *)objc_msgSend(v61, "initWithFormat:", CFSTR("%@:%@"), v62, v66);
    v68 = objc_msgSend(*(id *)(a1 + 16), "learntBitrateForSegment:defaultValue:", v67, v59);

    v69 = 26;
    do
      v70 = vcRateControlTierBitrates[v69--];
    while (v70 > v68);
    v58 = (v69 + 1) & ~(((int)v69 + 1) >> 31);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v323 = v6;
      v71 = VRTraceErrorLogLevelToCSTR();
      v72 = *MEMORY[0x1E0CF2758];
      v73 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf[0]) = 136316674;
          *(_QWORD *)((char *)buf + 4) = v71;
          WORD6(buf[0]) = 2080;
          *(_QWORD *)((char *)buf + 14) = "_AVCRateController_InitialBitrateTierFromLearntBitrate";
          WORD3(buf[1]) = 1024;
          DWORD2(buf[1]) = 1201;
          WORD6(buf[1]) = 2112;
          *(_QWORD *)((char *)&buf[1] + 14) = v67;
          WORD3(buf[2]) = 1024;
          DWORD2(buf[2]) = v68;
          WORD6(buf[2]) = 1024;
          *(_DWORD *)((char *)&buf[2] + 14) = v58;
          WORD1(buf[3]) = 1024;
          DWORD1(buf[3]) = v59;
          _os_log_impl(&dword_1D8A54000, v72, OS_LOG_TYPE_DEFAULT, "AVCRC [%s] %s:%d AdaptiveLearning(AVCRateController): Setting up initial bitrate for segment %@ - learnt target bitrate %d, selected tier %d, default bitrate %d", (uint8_t *)buf, 0x38u);
        }
      }
      else if (os_log_type_enabled(v73, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(buf[0]) = 136316674;
        *(_QWORD *)((char *)buf + 4) = v71;
        WORD6(buf[0]) = 2080;
        *(_QWORD *)((char *)buf + 14) = "_AVCRateController_InitialBitrateTierFromLearntBitrate";
        WORD3(buf[1]) = 1024;
        DWORD2(buf[1]) = 1201;
        WORD6(buf[1]) = 2112;
        *(_QWORD *)((char *)&buf[1] + 14) = v67;
        WORD3(buf[2]) = 1024;
        DWORD2(buf[2]) = v68;
        WORD6(buf[2]) = 1024;
        *(_DWORD *)((char *)&buf[2] + 14) = v58;
        WORD1(buf[3]) = 1024;
        DWORD1(buf[3]) = v59;
        _os_log_debug_impl(&dword_1D8A54000, v72, OS_LOG_TYPE_DEBUG, "AVCRC [%s] %s:%d AdaptiveLearning(AVCRateController): Setting up initial bitrate for segment %@ - learnt target bitrate %d, selected tier %d, default bitrate %d", (uint8_t *)buf, 0x38u);
      }
      v6 = v323;
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v63 = VRTraceErrorLogLevelToCSTR();
    v64 = *MEMORY[0x1E0CF2758];
    v65 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf[0]) = 136315906;
        *(_QWORD *)((char *)buf + 4) = v63;
        WORD6(buf[0]) = 2080;
        *(_QWORD *)((char *)buf + 14) = "_AVCRateController_InitialBitrateTierFromLearntBitrate";
        WORD3(buf[1]) = 1024;
        DWORD2(buf[1]) = 1203;
        WORD6(buf[1]) = 1024;
        *(_DWORD *)((char *)&buf[1] + 14) = v59;
        _os_log_impl(&dword_1D8A54000, v64, OS_LOG_TYPE_DEFAULT, "AVCRC [%s] %s:%d AdaptiveLearning(AVCRateController): Initial bitrate defaulted to %d", (uint8_t *)buf, 0x22u);
      }
    }
    else if (os_log_type_enabled(v65, OS_LOG_TYPE_DEBUG))
    {
      _AVCRateController_ConfigureInternal_cold_2();
    }
  }
  v74 = v329;
  if (v58 > v329)
    v74 = v58;
  if (v74 >= SHIDWORD(v328))
    v74 = HIDWORD(v328);
  LODWORD(v328) = v74;
  IntValueForKey = VCDefaults_GetIntValueForKey(CFSTR("forcedSoftMaxTierLowIndex"), 18);
  v75 = VCDefaults_GetIntValueForKey(CFSTR("forcedSoftMaxTierMediumIndex"), 26);
  *(_QWORD *)&v76 = 0x100000001;
  *((_QWORD *)&v76 + 1) = 0x100000001;
  v335 = v76;
  v340 = (float64x2_t)xmmword_1D9108D70;
  v341 = (float64x2_t)xmmword_1D9108D80;
  v342 = 0x4000000000000000;
  v77 = *(_BYTE *)(a1 + 88);
  v78 = 6.0;
  if (!v77)
    v78 = 2.0;
  v343 = v78;
  v345 = xmmword_1D9108D90;
  *(_OWORD *)v344 = xmmword_1D9108DA0;
  __asm { FMOV            V0.2D, #2.0 }
  *(_OWORD *)&v344[16] = _Q0;
  v347 = 1;
  v346 = xmmword_1D9108DB0;
  v352 = xmmword_1D9108DC0;
  *(_OWORD *)v353 = xmmword_1D9108DD0;
  *(_QWORD *)&v353[16] = 0x3FD0000000000000;
  v354 = xmmword_1D9108DE0;
  v355 = xmmword_1D9108DF0;
  if (_ZF)
    v83 = 4;
  else
    v83 = 7;
  v356 = v83;
  v84 = *(_DWORD *)(a1 + 104);
  v360 = (v84 & 2) == 0;
  v367 = BYTE1(v84) & 1;
  v331 = v75;
  v333 = 3;
  v388 = 0x4008000000000000;
  v368 = v77;
  v383 = 1;
  BoolValueForKey = 1;
  v361 = 256;
  v397 = 0;
  v362 = (v84 & 0x40) != 0;
  v363 = (v84 & 0x80) != 0;
  v381 = 0x300000004;
  v382 = xmmword_1D9108E10;
  v364 = (v84 & 8) != 0;
  v374 = 26;
  v376 = 3;
  v375 = 0x4034000000000000;
  v392 = xmmword_1D9108E20;
  v393 = xmmword_1D9108E00;
  v399 = xmmword_1D9108E30;
  v372 = (v84 & 0x400) != 0;
  v373 = xmmword_1D9108E40;
  v370 = (v84 & 0x1000) != 0;
  v371 = 17;
  v365 = (v84 & 0x20) != 0;
  v366 = (v84 & 0x800) != 0;
  v377 = xmmword_1D9108E50;
  v378 = 0x4008000000000000;
  v379 = 5;
  v380 = 0x3F60624DD2F1A9FCLL;
  v85 = -[VCDefaults rateControlAllowBurstyLossRampDown](+[VCDefaults sharedInstance](VCDefaults, "sharedInstance"), "rateControlAllowBurstyLossRampDown");
  v86 = *(_DWORD *)(a1 + 104);
  if (v85)
  {
    v336 = 0;
    if (*v46)
      v87 = 18;
    else
      v87 = 13;
    v337 = v87;
    v88 = 0.9;
    if ((v86 & 0x2000) == 0)
      v88 = 0.0;
    v349 = v88;
    v348 = 0x300000004;
    v350 = xmmword_1D9108E60;
  }
  v89 = 0;
  v400 = xmmword_1D9108E70;
  v401 = xmmword_1D9108E80;
  v338 = ((__int16)v86 >> 15) & 0x11;
  BoolValueForKey = (v86 & 0x4000) != 0;
  v359 = BoolValueForKey;
  do
  {
    *(double *)&v357[v89] = VCRateControlCongestionLevel_RampUpTimeFactor(v89);
    ++v89;
  }
  while (v89 != 5);
  v404 = 0x3F847AE147AE147BLL;
  v405 = xmmword_1D9108E90;
  v407 = 228000;
  v406 = 2576980378800000;
  v409 = 0x3FE0000000000000;
  v408 = xmmword_1D9108EA0;
  v90 = *v324;
  switch(*v324)
  {
    case 1:
    case 3:
      goto LABEL_165;
    case 2:
      *(int32x2_t *)&v355 = vadd_s32(*(int32x2_t *)&v355, *(int32x2_t *)&v355);
      *(float64x2_t *)&v353[8] = vaddq_f64(*(float64x2_t *)&v353[8], *(float64x2_t *)&v353[8]);
      v340 = vaddq_f64(v340, v340);
      v341 = vaddq_f64(v341, v341);
      v360 = 0;
      LODWORD(v328) = 3;
      v123 = 12;
      do
        v124 = vcRateControlTierBitrates[v123--];
      while (v124 > *(_DWORD *)(a1 + 76));
      HIDWORD(v328) = (v123 + 1) & ~(((int)v123 + 1) >> 31);
      v125 = *(_DWORD *)(a1 + 80);
      if ((*(_DWORD *)(a1 + 68) - 2) >= 5)
      {
        v132 = -1;
        v133 = vcRateControlTierBitrates;
        do
        {
          v134 = *v133++;
          ++v132;
        }
        while (v134 < v125);
        if (v132 >= 12)
          v135 = 12;
        else
          v135 = v132;
        v329 = v135;
      }
      else
      {
        v126 = -1;
        v127 = vcRateControlTierBitrates;
        do
        {
          v128 = *v127++;
          ++v126;
        }
        while (v128 < v125);
        if (v126 >= 12)
          v129 = 12;
        else
          v129 = v126;
        LOBYTE(v361) = (*(_DWORD *)(a1 + 104) & 0x200) == 0;
        v384 = 0x3FC999999999999ALL;
        v385 = xmmword_1D9108ED0;
        v386 = xmmword_1D9108EB0;
        v389 = xmmword_1D9108EC0;
        *(_QWORD *)&v390 = 0x3FE0000000000000;
        v329 = v129;
        v332 = 2;
        v387 = 0x4008000000000000;
      }
      *((_QWORD *)&v335 + 1) = 0;
      *((_QWORD *)&v355 + 1) = 0;
      v339 = 7;
      BoolValueForKey = 0;
      goto LABEL_194;
    case 4:
    case 5:
      v91 = *(_DWORD *)(a1 + 76);
      v92 = _AVCRateController_MultiwayMaxTierFromServerBag(a1);
      v93 = v92 + 1;
      v94 = &vcRateControlTierBitrates[v92];
      do
      {
        v95 = *v94--;
        --v93;
      }
      while (v95 > v91);
      v96 = 7;
      if (v93 <= 7)
        v93 = 7;
      HIDWORD(v328) = v93;
      v97 = *(_DWORD *)(a1 + 80);
      v98 = _AVCRateController_MultiwayMaxTierFromServerBag(a1);
      do
        v99 = vcRateControlTierBitrates[v96++];
      while (v99 < v97);
      v100 = v96 - 1;
      if ((int)v96 - 1 >= v98)
        v100 = v98;
      v329 = v100;
      IntValueForKey = VCDefaults_GetIntValueForKey(CFSTR("forcedSoftMaxTierLowIndex"), 22);
      IsAudioOnly = VCRateControlMediaController_IsAudioOnly(*(_QWORD *)(a1 + 56));
      v102 = *(_DWORD *)(a1 + 84);
      if (!v102)
      {
        v103 = 12;
        if (IsAudioOnly)
          v103 = 6;
        v102 = vcRateControlTierBitrates[v103];
      }
      v104 = v329 - 1;
      v105 = &vcRateControlTierBitrates[v329];
      do
      {
        v106 = *v105++;
        ++v104;
      }
      while (v106 < v102);
      if (v104 >= SHIDWORD(v328))
        v107 = HIDWORD(v328);
      else
        v107 = v104;
      LODWORD(v328) = v107;
      *(_QWORD *)&v344[24] = 0x4000000000000000;
      LODWORD(v348) = 4;
      v351 = 0x3FE0000000000000;
      HIDWORD(v355) = 64000;
      HIBYTE(v361) = 0;
      *((_QWORD *)&v392 + 1) = 0x4000000000000000;
      v334 = 0xE00000009;
      v394 = 1;
      v395 = 0x4024000000000000;
      v396 = 0x200000002;
      if (*v324 == 4 && (*(_DWORD *)(a1 + 68) - 2) <= 4)
      {
        LOBYTE(v361) = (*(_DWORD *)(a1 + 104) & 0x200) == 0;
        v384 = 0x3FC999999999999ALL;
        *((_QWORD *)&v385 + 1) = 0x3FD999999999999ALL;
        v386 = xmmword_1D9108EB0;
        v389 = xmmword_1D9108EC0;
        *(_QWORD *)&v390 = 0x3FE0000000000000;
        v332 = 7;
        v387 = 0x4008000000000000;
      }
      goto LABEL_194;
    case 7:
      v383 = 2;
LABEL_165:
      v130 = *(_DWORD *)(a1 + 68);
      if ((v130 - 2) > 4)
      {
        if ((*(_DWORD *)(a1 + 72) - 2) > 4)
          goto LABEL_169;
      }
      else
      {
        LOBYTE(v361) = (*(_DWORD *)(a1 + 104) & 0x200) == 0;
        v384 = 0x3FC999999999999ALL;
        v385 = xmmword_1D9108ED0;
        v386 = xmmword_1D9108EB0;
        v389 = xmmword_1D9108EC0;
        v390 = xmmword_1D9108EE0;
        v391 = xmmword_1D9108EE0;
      }
      v337 = 9;
      HIDWORD(v348) = 8;
LABEL_169:
      if ((v130 & 0xFFFFFFFE) == 2)
        goto LABEL_173;
      switch(v130)
      {
        case 6:
          goto LABEL_192;
        case 5:
          __asm { FMOV            V1.2D, #0.5 }
          *(float64x2_t *)&v344[8] = vmulq_f64(*(float64x2_t *)&v344[8], _Q1);
          v360 = 0;
          HIDWORD(v355) = 64000;
          LODWORD(v328) = 5;
          DWORD2(v335) = 0;
LABEL_193:
          v336 = 0;
          goto LABEL_194;
        case 4:
LABEL_173:
          v397 = 1;
          v336 = 0;
          v398 = -[VCDefaults rateControlBasebandSlowDownFactor](+[VCDefaults sharedInstance](VCDefaults, "sharedInstance"), "rateControlBasebandSlowDownFactor");
          goto LABEL_194;
      }
      if (*(_DWORD *)(a1 + 72) == 6)
      {
LABEL_192:
        __asm { FMOV            V0.2D, #0.5 }
        *(float64x2_t *)&v344[8] = vmulq_f64(*(float64x2_t *)&v344[8], _Q0);
        *(int32x2_t *)&v355 = vadd_s32(*(int32x2_t *)&v355, *(int32x2_t *)&v355);
        *(float64x2_t *)&v353[8] = vaddq_f64(*(float64x2_t *)&v353[8], *(float64x2_t *)&v353[8]);
        v340 = vaddq_f64(v340, v340);
        v341 = vaddq_f64(v341, v341);
        v360 = 0;
        HIDWORD(v355) = 0;
        LODWORD(v328) = 3;
        DWORD2(v335) = 0;
        *((_QWORD *)&v345 + 1) = 0x3FB999999999999ALL;
        goto LABEL_193;
      }
LABEL_194:
      v141 = *(void **)(a1 + 1472);
      v142 = objc_msgSend(v141, "containsAllSecondaryKeysWithPrimaryKey:", CFSTR("profile"));
      if (v142)
        LODWORD(v326) = objc_msgSend((id)objc_msgSend(v141, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("profile"), CFSTR("profileNumber"), 0), "unsignedIntValue");
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v143 = VRTraceErrorLogLevelToCSTR();
        v144 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v145 = objc_msgSend(CFSTR("profile"), "UTF8String");
          LODWORD(buf[0]) = 136316674;
          *(_QWORD *)((char *)buf + 4) = v143;
          WORD6(buf[0]) = 2080;
          *(_QWORD *)((char *)buf + 14) = "_AVCRateController_ApplyServerBagProfileConfig";
          WORD3(buf[1]) = 1024;
          DWORD2(buf[1]) = 1536;
          WORD6(buf[1]) = 2048;
          *(_QWORD *)((char *)&buf[1] + 14) = a1;
          WORD3(buf[2]) = 2080;
          *((_QWORD *)&buf[2] + 1) = v145;
          LOWORD(buf[3]) = 1024;
          *(_DWORD *)((char *)&buf[3] + 2) = v142;
          WORD3(buf[3]) = 1024;
          DWORD2(buf[3]) = v326;
          _os_log_impl(&dword_1D8A54000, v144, OS_LOG_TYPE_DEFAULT, "AVCRC [%s] %s:%d [%p] config for key=%s serverBagContainsGroup=%d serverBagProfileNumber=%d", (uint8_t *)buf, 0x3Cu);
        }
      }
      v146 = *(void **)(a1 + 1472);
      v147 = objc_msgSend(v146, "containsAllSecondaryKeysWithPrimaryKey:", CFSTR("fastRampUp"));
      if (v147)
      {
        v364 = objc_msgSend((id)objc_msgSend(v146, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("fastRampUp"), CFSTR("enabled"), 0), "BOOLValue");
        objc_msgSend((id)objc_msgSend(*(id *)(a1 + 1472), "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("fastRampUp"), CFSTR("networkStableDuration"), 1), "doubleValue");
        *(_QWORD *)&v377 = v148;
        v376 = objc_msgSend((id)objc_msgSend(v146, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("fastRampUp"), CFSTR("minTierGap"), 0), "integerValue");
        objc_msgSend((id)objc_msgSend(v146, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("fastRampUp"), CFSTR("RTTRatio"), 0), "doubleValue");
        v375 = v149;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v150 = VRTraceErrorLogLevelToCSTR();
        v151 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v152 = objc_msgSend(CFSTR("fastRampUp"), "UTF8String");
          LODWORD(buf[0]) = 136317442;
          *(_QWORD *)((char *)buf + 4) = v150;
          WORD6(buf[0]) = 2080;
          *(_QWORD *)((char *)buf + 14) = "_AVCRateController_ApplyServerBagFastRampUpConfig";
          WORD3(buf[1]) = 1024;
          DWORD2(buf[1]) = 1548;
          WORD6(buf[1]) = 2048;
          *(_QWORD *)((char *)&buf[1] + 14) = a1;
          WORD3(buf[2]) = 2080;
          *((_QWORD *)&buf[2] + 1) = v152;
          LOWORD(buf[3]) = 1024;
          *(_DWORD *)((char *)&buf[3] + 2) = v147;
          WORD3(buf[3]) = 1024;
          DWORD2(buf[3]) = v364;
          WORD6(buf[3]) = 2048;
          *(_QWORD *)((char *)&buf[3] + 14) = v377;
          WORD3(buf[4]) = 1024;
          DWORD2(buf[4]) = v376;
          WORD6(buf[4]) = 2048;
          *(_QWORD *)((char *)&buf[4] + 14) = v375;
          _os_log_impl(&dword_1D8A54000, v151, OS_LOG_TYPE_DEFAULT, "AVCRC [%s] %s:%d [%p] config for key=%s serverBagContainsGroup=%d fastRampUpEnabled=%d fastRampUpNetworkStableDuration=%f fastRampUpTierGap=%d fastRampUpRTTRatio=%F", (uint8_t *)buf, 0x56u);
        }
      }
      v153 = *(void **)(a1 + 1472);
      v154 = objc_msgSend(v153, "containsAllSecondaryKeysWithPrimaryKey:", CFSTR("oscillationAvoidance"));
      if (v154)
      {
        v363 = objc_msgSend((id)objc_msgSend(v153, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("oscillationAvoidance"), CFSTR("enabled"), 0), "BOOLValue");
        HIDWORD(v381) = objc_msgSend((id)objc_msgSend(v153, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("oscillationAvoidance"), CFSTR("tiersHit"), 0), "intValue");
        LODWORD(v381) = objc_msgSend((id)objc_msgSend(v153, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("oscillationAvoidance"), CFSTR("tierChange"), 0), "intValue");
        objc_msgSend((id)objc_msgSend(v153, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("oscillationAvoidance"), CFSTR("durationRatio"), 0), "doubleValue");
        *(_QWORD *)&v382 = v155;
        objc_msgSend((id)objc_msgSend(v153, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("oscillationAvoidance"), CFSTR("aggDurationRatio"), 0), "doubleValue");
        *((_QWORD *)&v382 + 1) = v156;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v157 = VRTraceErrorLogLevelToCSTR();
        v158 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v159 = objc_msgSend(CFSTR("oscillationAvoidance"), "UTF8String");
          LODWORD(buf[0]) = 136317698;
          *(_QWORD *)((char *)buf + 4) = v157;
          WORD6(buf[0]) = 2080;
          *(_QWORD *)((char *)buf + 14) = "_AVCRateController_ApplyServerBagOscillationAvoidanceConfig";
          WORD3(buf[1]) = 1024;
          DWORD2(buf[1]) = 1561;
          WORD6(buf[1]) = 2048;
          *(_QWORD *)((char *)&buf[1] + 14) = a1;
          WORD3(buf[2]) = 2080;
          *((_QWORD *)&buf[2] + 1) = v159;
          LOWORD(buf[3]) = 1024;
          *(_DWORD *)((char *)&buf[3] + 2) = v154;
          WORD3(buf[3]) = 1024;
          DWORD2(buf[3]) = v363;
          WORD6(buf[3]) = 1024;
          *(_DWORD *)((char *)&buf[3] + 14) = HIDWORD(v381);
          WORD1(buf[4]) = 1024;
          DWORD1(buf[4]) = v381;
          WORD4(buf[4]) = 2048;
          *(_QWORD *)((char *)&buf[4] + 10) = v382;
          WORD1(buf[5]) = 2048;
          *(_QWORD *)((char *)&buf[5] + 4) = *((_QWORD *)&v382 + 1);
          _os_log_impl(&dword_1D8A54000, v158, OS_LOG_TYPE_DEFAULT, "AVCRC [%s] %s:%d [%p] config for key=%s serverBagContainsGroup=%d oscillationAvoidanceEnabled=%d oscillationAvoidanceTiersHitThreshold=%d oscillationAvoidanceTierChangeThreshold=%d oscillationAvoidanceDurationRatio=%f oscillationAvoidanceDurationRatioAggressive=%f", (uint8_t *)buf, 0x5Cu);
        }
      }
      v160 = *(void **)(a1 + 1472);
      v161 = objc_msgSend(v160, "containsAllSecondaryKeysWithPrimaryKey:", CFSTR("emergencyTier"));
      if (v161)
      {
        v367 = objc_msgSend((id)objc_msgSend(v160, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("emergencyTier"), CFSTR("enabled"), 0), "BOOLValue");
        objc_msgSend((id)objc_msgSend(v160, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("emergencyTier"), CFSTR("coolDownTimeWiFi"), 1), "doubleValue");
        v388 = v162;
        v333 = objc_msgSend((id)objc_msgSend(v160, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("emergencyTier"), CFSTR("minNonEmergTierWiFi"), 0), "integerValue");
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v163 = VRTraceErrorLogLevelToCSTR();
        v164 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v165 = objc_msgSend(CFSTR("emergencyTier"), "UTF8String");
          LODWORD(buf[0]) = 136317186;
          *(_QWORD *)((char *)buf + 4) = v163;
          WORD6(buf[0]) = 2080;
          *(_QWORD *)((char *)buf + 14) = "_AVCRateController_ApplyServerBagEmergencyTierConfig";
          WORD3(buf[1]) = 1024;
          DWORD2(buf[1]) = 1572;
          WORD6(buf[1]) = 2048;
          *(_QWORD *)((char *)&buf[1] + 14) = a1;
          WORD3(buf[2]) = 2080;
          *((_QWORD *)&buf[2] + 1) = v165;
          LOWORD(buf[3]) = 1024;
          *(_DWORD *)((char *)&buf[3] + 2) = v161;
          WORD3(buf[3]) = 1024;
          DWORD2(buf[3]) = v367;
          WORD6(buf[3]) = 2048;
          *(_QWORD *)((char *)&buf[3] + 14) = v388;
          WORD3(buf[4]) = 1024;
          DWORD2(buf[4]) = v333;
          _os_log_impl(&dword_1D8A54000, v164, OS_LOG_TYPE_DEFAULT, "AVCRC [%s] %s:%d [%p] config for key=%s serverBagContainsGroup=%d wifiEmergencyTierEnabled=%d rampDownWiFiEmergencyTierCoolDownTime=%f lowestNonEmergencyTierIndexWiFi=%d", (uint8_t *)buf, 0x4Cu);
        }
      }
      v166 = *(void **)(a1 + 1472);
      v167 = objc_msgSend(v166, "containsAllSecondaryKeysWithPrimaryKey:", CFSTR("pauseResume"));
      if (v167)
      {
        objc_msgSend((id)objc_msgSend(v166, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("pauseResume"), CFSTR("offChannelHighRatio"), 2), "doubleValue");
        *(_QWORD *)&v393 = v168;
        objc_msgSend((id)objc_msgSend(v166, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("pauseResume"), CFSTR("offChannelLowRatio"), 2), "doubleValue");
        *((_QWORD *)&v393 + 1) = v169;
        objc_msgSend((id)objc_msgSend(v166, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("pauseResume"), CFSTR("autoResumeTime"), 1), "doubleValue");
        *((_QWORD *)&v392 + 1) = v170;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v171 = VRTraceErrorLogLevelToCSTR();
        v172 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v173 = objc_msgSend(CFSTR("pauseResume"), "UTF8String");
          LODWORD(buf[0]) = 136317186;
          *(_QWORD *)((char *)buf + 4) = v171;
          WORD6(buf[0]) = 2080;
          *(_QWORD *)((char *)buf + 14) = "_AVCRateController_ApplyServerBagPauseResumeConfig";
          WORD3(buf[1]) = 1024;
          DWORD2(buf[1]) = 1583;
          WORD6(buf[1]) = 2048;
          *(_QWORD *)((char *)&buf[1] + 14) = a1;
          WORD3(buf[2]) = 2080;
          *((_QWORD *)&buf[2] + 1) = v173;
          LOWORD(buf[3]) = 1024;
          *(_DWORD *)((char *)&buf[3] + 2) = v167;
          WORD3(buf[3]) = 2048;
          *((_QWORD *)&buf[3] + 1) = v393;
          LOWORD(buf[4]) = 2048;
          *(_QWORD *)((char *)&buf[4] + 2) = *((_QWORD *)&v393 + 1);
          WORD5(buf[4]) = 2048;
          *(_QWORD *)((char *)&buf[4] + 12) = *((_QWORD *)&v392 + 1);
          _os_log_impl(&dword_1D8A54000, v172, OS_LOG_TYPE_DEFAULT, "AVCRC [%s] %s:%d [%p] config for key=%s serverBagContainsGroup=%d offChannelHighRatio=%f offChannelLowRatio=%f autoResumeTime=%f", (uint8_t *)buf, 0x54u);
        }
      }
      v174 = *(void **)(a1 + 1472);
      v175 = objc_msgSend(v174, "containsAllSecondaryKeysWithPrimaryKey:", CFSTR("noRampUp-networkSaturation"));
      if (v175)
      {
        v365 = objc_msgSend((id)objc_msgSend(v174, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("noRampUp-networkSaturation"), CFSTR("enabled"), 0), "BOOLValue");
        objc_msgSend((id)objc_msgSend(v174, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("noRampUp-networkSaturation"), CFSTR("RTTtoMinRTTRatio"), 0), "doubleValue");
        *((_QWORD *)&v377 + 1) = v176;
        objc_msgSend((id)objc_msgSend(v174, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("noRampUp-networkSaturation"), CFSTR("OWRDtoMinRTTRatio"), 0), "doubleValue");
        v378 = v177;
        v379 = objc_msgSend((id)objc_msgSend(v174, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("noRampUp-networkSaturation"), CFSTR("saturationPersistFeedbackNum"), 0), "integerValue");
        objc_msgSend((id)objc_msgSend(v174, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("noRampUp-networkSaturation"), CFSTR("RTTDecreasingThreshold"), 1), "doubleValue");
        v380 = v178;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v179 = VRTraceErrorLogLevelToCSTR();
        v180 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v181 = objc_msgSend(CFSTR("noRampUp-networkSaturation"), "UTF8String");
          LODWORD(buf[0]) = 136317698;
          *(_QWORD *)((char *)buf + 4) = v179;
          WORD6(buf[0]) = 2080;
          *(_QWORD *)((char *)buf + 14) = "_AVCRateController_ApplyServerBagNoRampUpGroupConfig";
          WORD3(buf[1]) = 1024;
          DWORD2(buf[1]) = 1445;
          WORD6(buf[1]) = 2048;
          *(_QWORD *)((char *)&buf[1] + 14) = a1;
          WORD3(buf[2]) = 2080;
          *((_QWORD *)&buf[2] + 1) = v181;
          LOWORD(buf[3]) = 1024;
          *(_DWORD *)((char *)&buf[3] + 2) = v175;
          WORD3(buf[3]) = 1024;
          DWORD2(buf[3]) = v365;
          WORD6(buf[3]) = 2048;
          *(_QWORD *)((char *)&buf[3] + 14) = *((_QWORD *)&v377 + 1);
          WORD3(buf[4]) = 2048;
          *((_QWORD *)&buf[4] + 1) = v378;
          LOWORD(buf[5]) = 1024;
          *(_DWORD *)((char *)&buf[5] + 2) = v379;
          WORD3(buf[5]) = 2048;
          *((_QWORD *)&buf[5] + 1) = v380;
          _os_log_impl(&dword_1D8A54000, v180, OS_LOG_TYPE_DEFAULT, "AVCRC [%s] %s:%d [%p] config for key=%s config serverBagContainsGroup=%d blockRampUpInSaturatedNetworkEnabled=%d networkSaturatedRTTToMinRTTRatio=%f networkSaturatedOWRDToMinRTTRatio=%f networkSaturatedPersistFeedbackNumber=%d networkSaturatedRTTDecreasingThreshold=%f", (uint8_t *)buf, 0x60u);
        }
      }
      v182 = objc_msgSend(v174, "containsAllSecondaryKeysWithPrimaryKey:", CFSTR("noRampUp-source"));
      if (v182)
      {
        objc_msgSend((id)objc_msgSend(v174, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("noRampUp-source"), CFSTR("rateLimitedPercentage"), 2), "doubleValue");
        *(_QWORD *)&v352 = v183;
        objc_msgSend((id)objc_msgSend(v174, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("noRampUp-source"), CFSTR("blockedTimeout"), 1), "doubleValue");
        *((_QWORD *)&v346 + 1) = v184;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v185 = VRTraceErrorLogLevelToCSTR();
        v186 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v187 = objc_msgSend(CFSTR("noRampUp-source"), "UTF8String");
          LODWORD(buf[0]) = 136316930;
          *(_QWORD *)((char *)buf + 4) = v185;
          WORD6(buf[0]) = 2080;
          *(_QWORD *)((char *)buf + 14) = "_AVCRateController_ApplyServerBagNoRampUpGroupConfig";
          WORD3(buf[1]) = 1024;
          DWORD2(buf[1]) = 1452;
          WORD6(buf[1]) = 2048;
          *(_QWORD *)((char *)&buf[1] + 14) = a1;
          WORD3(buf[2]) = 2080;
          *((_QWORD *)&buf[2] + 1) = v187;
          LOWORD(buf[3]) = 1024;
          *(_DWORD *)((char *)&buf[3] + 2) = v182;
          WORD3(buf[3]) = 2048;
          *((_QWORD *)&buf[3] + 1) = v352;
          LOWORD(buf[4]) = 2048;
          *(_QWORD *)((char *)&buf[4] + 2) = *((_QWORD *)&v346 + 1);
          _os_log_impl(&dword_1D8A54000, v186, OS_LOG_TYPE_DEFAULT, "AVCRC [%s] %s:%d [%p] config for key=%s config serverBagContainsGroup=%d rateLimitedPercentage=%f blockedTimeout=%f", (uint8_t *)buf, 0x4Au);
        }
      }
      v188 = objc_msgSend(v174, "containsAllSecondaryKeysWithPrimaryKey:", CFSTR("noRampUp-network"));
      if (v188)
      {
        objc_msgSend((id)objc_msgSend(v174, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("noRampUp-network"), CFSTR("networkUnstableCoolDownTime"), 1), "doubleValue");
        *(_QWORD *)&v392 = v189;
        objc_msgSend((id)objc_msgSend(v174, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("noRampUp-network"), CFSTR("RTTThreshold"), 1), "doubleValue");
        *(_QWORD *)&v399 = v190;
        objc_msgSend((id)objc_msgSend(v174, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("noRampUp-network"), CFSTR("PLRThreshold"), 2), "doubleValue");
        *((_QWORD *)&v399 + 1) = v191;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v192 = VRTraceErrorLogLevelToCSTR();
        v193 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v194 = objc_msgSend(CFSTR("noRampUp-source"), "UTF8String");
          LODWORD(buf[0]) = 136317186;
          *(_QWORD *)((char *)buf + 4) = v192;
          WORD6(buf[0]) = 2080;
          *(_QWORD *)((char *)buf + 14) = "_AVCRateController_ApplyServerBagNoRampUpGroupConfig";
          WORD3(buf[1]) = 1024;
          DWORD2(buf[1]) = 1460;
          WORD6(buf[1]) = 2048;
          *(_QWORD *)((char *)&buf[1] + 14) = a1;
          WORD3(buf[2]) = 2080;
          *((_QWORD *)&buf[2] + 1) = v194;
          LOWORD(buf[3]) = 1024;
          *(_DWORD *)((char *)&buf[3] + 2) = v188;
          WORD3(buf[3]) = 2048;
          *((_QWORD *)&buf[3] + 1) = v392;
          LOWORD(buf[4]) = 2048;
          *(_QWORD *)((char *)&buf[4] + 2) = v399;
          WORD5(buf[4]) = 2048;
          *(_QWORD *)((char *)&buf[4] + 12) = *((_QWORD *)&v399 + 1);
          _os_log_impl(&dword_1D8A54000, v193, OS_LOG_TYPE_DEFAULT, "AVCRC [%s] %s:%d [%p] config for key=%s config serverBagContainsGroup=%d networkUnstableCoolDownTime=%f RTTThreshold=%f PLRThreshold=%f", (uint8_t *)buf, 0x54u);
        }
      }
      v195 = objc_msgSend(v174, "containsAllSecondaryKeysWithPrimaryKey:", CFSTR("noRampUp-delay"));
      if (v195)
      {
        objc_msgSend((id)objc_msgSend(v174, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("noRampUp-delay"), CFSTR("OWRD"), 1), "doubleValue");
        *(_QWORD *)&v344[24] = v196;
        objc_msgSend((id)objc_msgSend(v174, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("noRampUp-delay"), CFSTR("NOWRD"), 1), "doubleValue");
        *(_QWORD *)&v345 = v197;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v198 = VRTraceErrorLogLevelToCSTR();
        v199 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v200 = objc_msgSend(CFSTR("noRampUp-delay"), "UTF8String");
          LODWORD(buf[0]) = 136316930;
          *(_QWORD *)((char *)buf + 4) = v198;
          WORD6(buf[0]) = 2080;
          *(_QWORD *)((char *)buf + 14) = "_AVCRateController_ApplyServerBagNoRampUpGroupConfig";
          WORD3(buf[1]) = 1024;
          DWORD2(buf[1]) = 1467;
          WORD6(buf[1]) = 2048;
          *(_QWORD *)((char *)&buf[1] + 14) = a1;
          WORD3(buf[2]) = 2080;
          *((_QWORD *)&buf[2] + 1) = v200;
          LOWORD(buf[3]) = 1024;
          *(_DWORD *)((char *)&buf[3] + 2) = v195;
          WORD3(buf[3]) = 2048;
          *((_QWORD *)&buf[3] + 1) = *(_QWORD *)&v344[24];
          LOWORD(buf[4]) = 2048;
          *(_QWORD *)((char *)&buf[4] + 2) = v345;
          _os_log_impl(&dword_1D8A54000, v199, OS_LOG_TYPE_DEFAULT, "AVCRC [%s] %s:%d [%p] config for key=%s serverBagContainsGroup=%d rampUpOWRDThreshold=%f rampUpNOWRDThreshold=%f", (uint8_t *)buf, 0x4Au);
        }
      }
      v201 = objc_msgSend(v174, "containsAllSecondaryKeysWithPrimaryKey:", CFSTR("noRampUp-bw"));
      if (v201)
      {
        objc_msgSend((id)objc_msgSend(v174, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("noRampUp-bw"), CFSTR("overGuardTierCalmDuration"), 1), "doubleValue");
        *(_QWORD *)&v346 = v202;
        v347 = objc_msgSend((id)objc_msgSend(v174, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("noRampUp-bw"), CFSTR("guardTierDiff"), 0), "integerValue");
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v203 = VRTraceErrorLogLevelToCSTR();
        v204 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v205 = objc_msgSend(CFSTR("noRampUp-bw"), "UTF8String");
          LODWORD(buf[0]) = 136316930;
          *(_QWORD *)((char *)buf + 4) = v203;
          WORD6(buf[0]) = 2080;
          *(_QWORD *)((char *)buf + 14) = "_AVCRateController_ApplyServerBagNoRampUpGroupConfig";
          WORD3(buf[1]) = 1024;
          DWORD2(buf[1]) = 1474;
          WORD6(buf[1]) = 2048;
          *(_QWORD *)((char *)&buf[1] + 14) = a1;
          WORD3(buf[2]) = 2080;
          *((_QWORD *)&buf[2] + 1) = v205;
          LOWORD(buf[3]) = 1024;
          *(_DWORD *)((char *)&buf[3] + 2) = v201;
          WORD3(buf[3]) = 2048;
          *((_QWORD *)&buf[3] + 1) = v346;
          LOWORD(buf[4]) = 1024;
          *(_DWORD *)((char *)&buf[4] + 2) = v347;
          _os_log_impl(&dword_1D8A54000, v204, OS_LOG_TYPE_DEFAULT, "AVCRC [%s] %s:%d [%p] config for key=%s serverBagContainsGroup=%d rampUpOverBandwidthCalmDuration=%f rampUpOverBandwidthTierNumber=%d", (uint8_t *)buf, 0x46u);
        }
      }
      v206 = *(void **)(a1 + 1472);
      v207 = objc_msgSend(v206, "containsAllSecondaryKeysWithPrimaryKey:", CFSTR("rampDown-delay"));
      if (v207)
      {
        objc_msgSend((id)objc_msgSend(v206, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("rampDown-delay"), CFSTR("NOWRD"), 1), "doubleValue");
        v340.f64[0] = v208;
        objc_msgSend((id)objc_msgSend(v206, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("rampDown-delay"), CFSTR("NOWRDAcc"), 1), "doubleValue");
        v340.f64[1] = v209;
        objc_msgSend((id)objc_msgSend(v206, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("rampDown-delay"), CFSTR("aggNOWRD"), 1), "doubleValue");
        v341.f64[0] = v210;
        objc_msgSend((id)objc_msgSend(v206, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("rampDown-delay"), CFSTR("aggNOWRDAcc"), 1), "doubleValue");
        v341.f64[1] = v211;
        objc_msgSend((id)objc_msgSend(v206, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("rampDown-delay"), CFSTR("constantOWRDDuration"), 1), "doubleValue");
        v342 = v212;
        v372 = objc_msgSend((id)objc_msgSend(v206, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("rampDown-delay"), CFSTR("suppressionEnabled"), 0), "BOOLValue");
        objc_msgSend((id)objc_msgSend(v206, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("rampDown-delay"), CFSTR("suppressionMinRTT"), 1), "doubleValue");
        *(_QWORD *)&v373 = v213;
        objc_msgSend((id)objc_msgSend(v206, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("rampDown-delay"), CFSTR("suppressionFactor"), 2), "doubleValue");
        *((_QWORD *)&v373 + 1) = v214;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v215 = VRTraceErrorLogLevelToCSTR();
        v216 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v217 = objc_msgSend(CFSTR("rampDown-delay"), "UTF8String");
          LODWORD(buf[0]) = 136317698;
          *(_QWORD *)((char *)buf + 4) = v215;
          WORD6(buf[0]) = 2080;
          *(_QWORD *)((char *)buf + 14) = "_AVCRateController_ApplyServerBagRampDownGroupConfig";
          WORD3(buf[1]) = 1024;
          DWORD2(buf[1]) = 1490;
          WORD6(buf[1]) = 2048;
          *(_QWORD *)((char *)&buf[1] + 14) = a1;
          WORD3(buf[2]) = 2080;
          *((_QWORD *)&buf[2] + 1) = v217;
          LOWORD(buf[3]) = 1024;
          *(_DWORD *)((char *)&buf[3] + 2) = v207;
          WORD3(buf[3]) = 2048;
          *((_QWORD *)&buf[3] + 1) = *(_QWORD *)&v340.f64[0];
          LOWORD(buf[4]) = 2048;
          *(float64_t *)((char *)&buf[4] + 2) = v340.f64[1];
          WORD5(buf[4]) = 2048;
          *(float64_t *)((char *)&buf[4] + 12) = v341.f64[0];
          WORD2(buf[5]) = 2048;
          *(float64_t *)((char *)&buf[5] + 6) = v341.f64[1];
          HIWORD(buf[5]) = 2048;
          *(_QWORD *)&buf[6] = v342;
          _os_log_impl(&dword_1D8A54000, v216, OS_LOG_TYPE_DEFAULT, "AVCRC [%s] %s:%d [%p] config for key=%s serverBagContainsGroup=%d rampDownNOWRDThreshold=%f rampDownNOWRDAccThreshold=%f rampDownAggressiveNOWRDThreshold=%f rampDownAggressiveNOWRDAccThreshold=%f rampDownConstantOWRDDuration=%f", (uint8_t *)buf, 0x68u);
        }
      }
      v218 = objc_msgSend(v206, "containsAllSecondaryKeysWithPrimaryKey:", CFSTR("rampDown-loss"));
      if (v218)
      {
        v336 = objc_msgSend((id)objc_msgSend(v206, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("rampDown-loss"), CFSTR("MBL"), 0), "integerValue");
        v337 = objc_msgSend((id)objc_msgSend(v206, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("rampDown-loss"), CFSTR("lowestTier"), 0), "integerValue");
        LODWORD(v348) = objc_msgSend((id)objc_msgSend(v206, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("rampDown-loss"), CFSTR("lossEvent"), 0), "integerValue");
        objc_msgSend((id)objc_msgSend(v206, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("rampDown-loss"), CFSTR("lossEventNOWRD"), 1), "doubleValue");
        *((_QWORD *)&v350 + 1) = v219;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v220 = VRTraceErrorLogLevelToCSTR();
        v221 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v222 = objc_msgSend(CFSTR("rampDown-loss"), "UTF8String");
          LODWORD(buf[0]) = 136317442;
          *(_QWORD *)((char *)buf + 4) = v220;
          WORD6(buf[0]) = 2080;
          *(_QWORD *)((char *)buf + 14) = "_AVCRateController_ApplyServerBagRampDownGroupConfig";
          WORD3(buf[1]) = 1024;
          DWORD2(buf[1]) = 1499;
          WORD6(buf[1]) = 2048;
          *(_QWORD *)((char *)&buf[1] + 14) = a1;
          WORD3(buf[2]) = 2080;
          *((_QWORD *)&buf[2] + 1) = v222;
          LOWORD(buf[3]) = 1024;
          *(_DWORD *)((char *)&buf[3] + 2) = v218;
          WORD3(buf[3]) = 1024;
          DWORD2(buf[3]) = v336;
          WORD6(buf[3]) = 1024;
          *(_DWORD *)((char *)&buf[3] + 14) = v337;
          WORD1(buf[4]) = 1024;
          DWORD1(buf[4]) = v348;
          WORD4(buf[4]) = 2048;
          *(_QWORD *)((char *)&buf[4] + 10) = *((_QWORD *)&v350 + 1);
          _os_log_impl(&dword_1D8A54000, v221, OS_LOG_TYPE_DEFAULT, "AVCRC [%s] %s:%d [%p] config for key=%s serverBagContainsGroup=%d rampDownBurstyLossThreshold=%d lowestTierForBurstyLossRampDown=%d rampDownLossEventThreshold=%d rampDownLossEventNOWRDThreshold=%f", (uint8_t *)buf, 0x52u);
        }
      }
      v223 = objc_msgSend(v206, "containsAllSecondaryKeysWithPrimaryKey:", CFSTR("rampDown-bw"));
      if (v223)
      {
        objc_msgSend((id)objc_msgSend(v206, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("rampDown-bw"), CFSTR("keepOvershootDuration"), 1), "doubleValue");
        v343 = v224;
        objc_msgSend((id)objc_msgSend(v206, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("rampDown-bw"), CFSTR("nextTierPercentage"), 2), "doubleValue");
        *(_QWORD *)v344 = v225;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v226 = VRTraceErrorLogLevelToCSTR();
        v227 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v228 = objc_msgSend(CFSTR("rampDown-bw"), "UTF8String");
          LODWORD(buf[0]) = 136316930;
          *(_QWORD *)((char *)buf + 4) = v226;
          WORD6(buf[0]) = 2080;
          *(_QWORD *)((char *)buf + 14) = "_AVCRateController_ApplyServerBagRampDownGroupConfig";
          WORD3(buf[1]) = 1024;
          DWORD2(buf[1]) = 1506;
          WORD6(buf[1]) = 2048;
          *(_QWORD *)((char *)&buf[1] + 14) = a1;
          WORD3(buf[2]) = 2080;
          *((_QWORD *)&buf[2] + 1) = v228;
          LOWORD(buf[3]) = 1024;
          *(_DWORD *)((char *)&buf[3] + 2) = v223;
          WORD3(buf[3]) = 2048;
          *((double *)&buf[3] + 1) = v343;
          LOWORD(buf[4]) = 2048;
          *(_QWORD *)((char *)&buf[4] + 2) = *(_QWORD *)v344;
          _os_log_impl(&dword_1D8A54000, v227, OS_LOG_TYPE_DEFAULT, "AVCRC [%s] %s:%d [%p] config for key=%s serverBagContainsGroup=%d rampDownOvershootDuration=%f rampDownOvershootNextTierRatio=%f", (uint8_t *)buf, 0x4Au);
        }
      }
      AVCRateController_ApplyServerBagLossBasedAdaptationConfig(a1, &v326);
      _AVCRateController_ApplyServerBagBasebandConfig(a1, (uint64_t)&v326);
      v229 = *(void **)(a1 + 1472);
      v230 = objc_msgSend(v229, "containsAllSecondaryKeysWithPrimaryKey:", CFSTR("mainControl"));
      if (v230)
      {
        objc_msgSend((id)objc_msgSend(v229, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("mainControl"), CFSTR("rampDown-loss-ratio"), 0), "doubleValue");
        v349 = v231;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v232 = VRTraceErrorLogLevelToCSTR();
        v233 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v234 = objc_msgSend(CFSTR("mainControl"), "UTF8String");
          LODWORD(buf[0]) = 136316674;
          *(_QWORD *)((char *)buf + 4) = v232;
          WORD6(buf[0]) = 2080;
          *(_QWORD *)((char *)buf + 14) = "_AVCRateController_ApplyServerBagMainControlConfig";
          WORD3(buf[1]) = 1024;
          DWORD2(buf[1]) = 1616;
          WORD6(buf[1]) = 2048;
          *(_QWORD *)((char *)&buf[1] + 14) = a1;
          WORD3(buf[2]) = 2080;
          *((_QWORD *)&buf[2] + 1) = v234;
          LOWORD(buf[3]) = 1024;
          *(_DWORD *)((char *)&buf[3] + 2) = v230;
          WORD3(buf[3]) = 2048;
          *((double *)&buf[3] + 1) = v349;
          _os_log_impl(&dword_1D8A54000, v233, OS_LOG_TYPE_DEFAULT, "AVCRC [%s] %s:%d [%p] config for key=%s serverBagContainsGroup=%d rampDownLossEventThresholdRatio=%f", (uint8_t *)buf, 0x40u);
        }
      }
      _AVCRateController_ApplyServerBagECNConfig((_QWORD *)a1, (uint64_t)&v326);
      _AVCRateController_ApplyServerBagBIFConfig((_QWORD *)a1, (uint64_t)&v326);
      _AVCRateController_ApplyServerBagContinuousAdaptationConfig((_QWORD *)a1, (uint64_t)&v326);
      if (!-[VCHardwareSettingsEmbedded isSmartBrakeSupported](+[VCHardwareSettingsEmbedded sharedInstance](VCHardwareSettingsEmbedded, "sharedInstance"), "isSmartBrakeSupported"))
      {
        v410 = 0;
        goto LABEL_273;
      }
      if (_os_feature_enabled_impl())
        v235 = 2;
      else
        v235 = 0;
      v410 = v235;
      _AVCRateController_ApplyServerBagSmartBrakeConfig((_QWORD *)a1, (uint64_t)&v326);
      v410 = VCDefaults_GetIntValueForKey(CFSTR("smartBrakeRateControlStrategy"), v410);
      if (!*(_BYTE *)(a1 + 88))
        goto LABEL_273;
      v410 = 0;
      if (objc_opt_class() == a1)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v256 = VRTraceErrorLogLevelToCSTR();
          v257 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf[0]) = 136315906;
            *(_QWORD *)((char *)buf + 4) = v256;
            WORD6(buf[0]) = 2080;
            *(_QWORD *)((char *)buf + 14) = "_AVCRateController_ApplySmartBrakeConfig";
            WORD3(buf[1]) = 1024;
            DWORD2(buf[1]) = 1871;
            WORD6(buf[1]) = 1024;
            *(_DWORD *)((char *)&buf[1] + 14) = v410;
            v258 = "AVCRC [%s] %s:%d Forced smart brake off with smartBrakeStrategy=%u when bursty traffic is sent";
            v259 = v257;
            v260 = 34;
LABEL_305:
            _os_log_impl(&dword_1D8A54000, v259, OS_LOG_TYPE_DEFAULT, v258, (uint8_t *)buf, v260);
          }
        }
      }
      else
      {
        if ((objc_opt_respondsToSelector() & 1) != 0)
          v236 = (const __CFString *)objc_msgSend((id)a1, "performSelector:", sel_logPrefix);
        else
          v236 = &stru_1E9E58EE0;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v266 = VRTraceErrorLogLevelToCSTR();
          v267 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf[0]) = 136316418;
            *(_QWORD *)((char *)buf + 4) = v266;
            WORD6(buf[0]) = 2080;
            *(_QWORD *)((char *)buf + 14) = "_AVCRateController_ApplySmartBrakeConfig";
            WORD3(buf[1]) = 1024;
            DWORD2(buf[1]) = 1871;
            WORD6(buf[1]) = 2112;
            *(_QWORD *)((char *)&buf[1] + 14) = v236;
            WORD3(buf[2]) = 2048;
            *((_QWORD *)&buf[2] + 1) = a1;
            LOWORD(buf[3]) = 1024;
            *(_DWORD *)((char *)&buf[3] + 2) = v410;
            v258 = "AVCRC [%s] %s:%d %@(%p) Forced smart brake off with smartBrakeStrategy=%u when bursty traffic is sent";
            v259 = v267;
            v260 = 54;
            goto LABEL_305;
          }
        }
      }
LABEL_273:
      if ((*(_DWORD *)(a1 + 68) - 2) <= 4)
      {
        v237 = *(void **)(a1 + 1472);
        v238 = objc_msgSend(v237, "containsAllSecondaryKeysWithPrimaryKey:", CFSTR("noRampUp-notification"));
        if (v238)
        {
          objc_msgSend((id)objc_msgSend(v237, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("noRampUp-notification"), CFSTR("BBDelay"), 1), "doubleValue");
          *((_QWORD *)&v389 + 1) = v239;
          objc_msgSend((id)objc_msgSend(v237, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("noRampUp-notification"), CFSTR("NBDCD"), 1), "doubleValue");
          *(_QWORD *)&v389 = v240;
          objc_msgSend((id)objc_msgSend(v237, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("noRampUp-notification"), CFSTR("highNBDCDCoolDuration"), 1), "doubleValue");
          *(_QWORD *)&v390 = v241;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v242 = VRTraceErrorLogLevelToCSTR();
          v243 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v244 = objc_msgSend(CFSTR("noRampUp-notification"), "UTF8String");
            LODWORD(buf[0]) = 136317186;
            *(_QWORD *)((char *)buf + 4) = v242;
            WORD6(buf[0]) = 2080;
            *(_QWORD *)((char *)buf + 14) = "_AVCRateController_ApplyServerBagNotificationGroupConfig";
            WORD3(buf[1]) = 1024;
            DWORD2(buf[1]) = 1517;
            WORD6(buf[1]) = 2048;
            *(_QWORD *)((char *)&buf[1] + 14) = a1;
            WORD3(buf[2]) = 2080;
            *((_QWORD *)&buf[2] + 1) = v244;
            LOWORD(buf[3]) = 1024;
            *(_DWORD *)((char *)&buf[3] + 2) = v238;
            WORD3(buf[3]) = 2048;
            *((_QWORD *)&buf[3] + 1) = *((_QWORD *)&v389 + 1);
            LOWORD(buf[4]) = 2048;
            *(_QWORD *)((char *)&buf[4] + 2) = v389;
            WORD5(buf[4]) = 2048;
            *(_QWORD *)((char *)&buf[4] + 12) = v390;
            _os_log_impl(&dword_1D8A54000, v243, OS_LOG_TYPE_DEFAULT, "AVCRC [%s] %s:%d [%p] config for key=%s serverBagContainsGroup=%d rampUpQueuingDelayThreshold=%f rampUpNBDCDThreshold=%f rampUpNBDCDCoolDownTime=%f", (uint8_t *)buf, 0x54u);
          }
        }
        v245 = objc_msgSend(v237, "containsAllSecondaryKeysWithPrimaryKey:", CFSTR("rampDown-notification"));
        if (v245)
        {
          objc_msgSend((id)objc_msgSend(v237, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("rampDown-notification"), CFSTR("highBBDelay"), 1), "doubleValue");
          *((_QWORD *)&v386 + 1) = v246;
          objc_msgSend((id)objc_msgSend(v237, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("rampDown-notification"), CFSTR("mediumBBDelay"), 1), "doubleValue");
          *(_QWORD *)&v386 = v247;
          objc_msgSend((id)objc_msgSend(v237, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("rampDown-notification"), CFSTR("normalizedBBDelay"), 1), "doubleValue");
          *((_QWORD *)&v385 + 1) = v248;
          objc_msgSend((id)objc_msgSend(v237, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("rampDown-notification"), CFSTR("NBDCD"), 1), "doubleValue");
          v384 = v249;
          objc_msgSend((id)objc_msgSend(v237, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("rampDown-notification"), CFSTR("aggNBDCD"), 1), "doubleValue");
          *(_QWORD *)&v385 = v250;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v251 = VRTraceErrorLogLevelToCSTR();
          v252 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v253 = objc_msgSend(CFSTR("rampDown-notification"), "UTF8String");
            LODWORD(buf[0]) = 136317698;
            *(_QWORD *)((char *)buf + 4) = v251;
            WORD6(buf[0]) = 2080;
            *(_QWORD *)((char *)buf + 14) = "_AVCRateController_ApplyServerBagNotificationGroupConfig";
            WORD3(buf[1]) = 1024;
            DWORD2(buf[1]) = 1527;
            WORD6(buf[1]) = 2048;
            *(_QWORD *)((char *)&buf[1] + 14) = a1;
            WORD3(buf[2]) = 2080;
            *((_QWORD *)&buf[2] + 1) = v253;
            LOWORD(buf[3]) = 1024;
            *(_DWORD *)((char *)&buf[3] + 2) = v245;
            WORD3(buf[3]) = 2048;
            *((_QWORD *)&buf[3] + 1) = *((_QWORD *)&v386 + 1);
            LOWORD(buf[4]) = 2048;
            *(_QWORD *)((char *)&buf[4] + 2) = v386;
            WORD5(buf[4]) = 2048;
            *(_QWORD *)((char *)&buf[4] + 12) = *((_QWORD *)&v385 + 1);
            WORD2(buf[5]) = 2048;
            *(_QWORD *)((char *)&buf[5] + 6) = v384;
            HIWORD(buf[5]) = 2048;
            *(_QWORD *)&buf[6] = v385;
            _os_log_impl(&dword_1D8A54000, v252, OS_LOG_TYPE_DEFAULT, "AVCRC [%s] %s:%d [%p] config for key=%s serverBagContainsGroup=%d rampDownHighQueuingDelayThreshold=%f rampDownMediumQueuingDelayThreshold=%f rampDownNormalizedQueuingDelayThreshold=%f rampDownNBDCDThreshold=%f rampDownAggressiveNBDCDThreshold=%f", (uint8_t *)buf, 0x68u);
          }
        }
      }
      if (!*(_BYTE *)(a1 + 1088))
        goto LABEL_315;
      if (*v324 == 10)
      {
        v402 = *(_QWORD *)(a1 + 832);
        v403 = *(_OWORD *)(a1 + 840);
        if (objc_opt_class() == a1)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v261 = VRTraceErrorLogLevelToCSTR();
            v262 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(buf[0]) = 136316674;
              *(_QWORD *)((char *)buf + 4) = v261;
              WORD6(buf[0]) = 2080;
              *(_QWORD *)((char *)buf + 14) = "_AVCRateController_ApplyCachedAlgorithmConfig";
              WORD3(buf[1]) = 1024;
              DWORD2(buf[1]) = 1796;
              WORD6(buf[1]) = 1024;
              *(_DWORD *)((char *)&buf[1] + 14) = v402;
              WORD1(buf[2]) = 1024;
              DWORD1(buf[2]) = HIDWORD(v402);
              WORD4(buf[2]) = 2048;
              *(_QWORD *)((char *)&buf[2] + 10) = v403;
              WORD1(buf[3]) = 2048;
              *(_QWORD *)((char *)&buf[3] + 4) = *((_QWORD *)&v403 + 1);
              v263 = "AVCRC [%s] %s:%d Apply algorithm config rampUpUplinkBLERThreshold=%u, rampDownUplinkBLERThreshold=%"
                     "u, rampUpUplinkBLERDuration=%f, rampDownUplinkBLERDuration=%f";
              v264 = v262;
              v265 = 60;
LABEL_310:
              _os_log_impl(&dword_1D8A54000, v264, OS_LOG_TYPE_DEFAULT, v263, (uint8_t *)buf, v265);
            }
          }
        }
        else
        {
          if ((objc_opt_respondsToSelector() & 1) != 0)
            v254 = (const __CFString *)objc_msgSend((id)a1, "performSelector:", sel_logPrefix);
          else
            v254 = &stru_1E9E58EE0;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v268 = VRTraceErrorLogLevelToCSTR();
            v269 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(buf[0]) = 136317186;
              *(_QWORD *)((char *)buf + 4) = v268;
              WORD6(buf[0]) = 2080;
              *(_QWORD *)((char *)buf + 14) = "_AVCRateController_ApplyCachedAlgorithmConfig";
              WORD3(buf[1]) = 1024;
              DWORD2(buf[1]) = 1796;
              WORD6(buf[1]) = 2112;
              *(_QWORD *)((char *)&buf[1] + 14) = v254;
              WORD3(buf[2]) = 2048;
              *((_QWORD *)&buf[2] + 1) = a1;
              LOWORD(buf[3]) = 1024;
              *(_DWORD *)((char *)&buf[3] + 2) = v402;
              WORD3(buf[3]) = 1024;
              DWORD2(buf[3]) = HIDWORD(v402);
              WORD6(buf[3]) = 2048;
              *(_QWORD *)((char *)&buf[3] + 14) = v403;
              WORD3(buf[4]) = 2048;
              *((_QWORD *)&buf[4] + 1) = *((_QWORD *)&v403 + 1);
              v263 = "AVCRC [%s] %s:%d %@(%p) Apply algorithm config rampUpUplinkBLERThreshold=%u, rampDownUplinkBLERThre"
                     "shold=%u, rampUpUplinkBLERDuration=%f, rampDownUplinkBLERDuration=%f";
              v264 = v269;
              v265 = 80;
              goto LABEL_310;
            }
          }
        }
      }
      else if (objc_opt_class() == a1)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _AVCRateController_ConfigureInternal_cold_1();
        }
      }
      else
      {
        if ((objc_opt_respondsToSelector() & 1) != 0)
          v255 = (const __CFString *)objc_msgSend((id)a1, "performSelector:", sel_logPrefix);
        else
          v255 = &stru_1E9E58EE0;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v270 = VRTraceErrorLogLevelToCSTR();
          v271 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            v320 = *(_DWORD *)(a1 + 64);
            LODWORD(buf[0]) = 136316418;
            *(_QWORD *)((char *)buf + 4) = v270;
            WORD6(buf[0]) = 2080;
            *(_QWORD *)((char *)buf + 14) = "_AVCRateController_ApplyCachedAlgorithmConfig";
            WORD3(buf[1]) = 1024;
            DWORD2(buf[1]) = 1800;
            WORD6(buf[1]) = 2112;
            *(_QWORD *)((char *)&buf[1] + 14) = v255;
            WORD3(buf[2]) = 2048;
            *((_QWORD *)&buf[2] + 1) = a1;
            LOWORD(buf[3]) = 1024;
            *(_DWORD *)((char *)&buf[3] + 2) = v320;
            _os_log_error_impl(&dword_1D8A54000, v271, OS_LOG_TYPE_ERROR, "AVCRC [%s] %s:%d %@(%p) Not allowed to force algorithm config for mode=%d yet!", (uint8_t *)buf, 0x36u);
          }
        }
      }
LABEL_315:
      *(_DWORD *)(a1 + 1116) = v327[(int)v328];
      *(double *)(a1 + 1128) = micro();
      v272 = VCDefaults_GetIntValueForKey(CFSTR("forcedInitialBitrate"), *(unsigned int *)(a1 + 1116));
      if (v272 == *(_DWORD *)(a1 + 1116))
        goto LABEL_329;
      v273 = v329;
      v274 = HIDWORD(v328) + 1;
      v275 = &vcRateControlTierBitrates[SHIDWORD(v328)];
      do
      {
        v276 = *v275--;
        --v274;
      }
      while (v276 > v272);
      if (v274 > v329)
        v273 = v274;
      LODWORD(v328) = v273;
      *(_DWORD *)(a1 + 1116) = v327[v273];
      if (objc_opt_class() == a1)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() < 3)
          goto LABEL_329;
        v278 = VRTraceErrorLogLevelToCSTR();
        v279 = *MEMORY[0x1E0CF2758];
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          goto LABEL_329;
        v280 = *(_DWORD *)(a1 + 1116);
        LODWORD(buf[0]) = 136316162;
        *(_QWORD *)((char *)buf + 4) = v278;
        WORD6(buf[0]) = 2080;
        *(_QWORD *)((char *)buf + 14) = "_AVCRateController_UpdateInitialBitrateFromDefault";
        WORD3(buf[1]) = 1024;
        DWORD2(buf[1]) = 1841;
        WORD6(buf[1]) = 1024;
        *(_DWORD *)((char *)&buf[1] + 14) = v280;
        WORD1(buf[2]) = 1024;
        DWORD1(buf[2]) = v328;
        v281 = "AVCRC [%s] %s:%d Forced the initialBitrate=%u, initialTierIndex=%d";
        v282 = v279;
        v283 = 40;
LABEL_374:
        _os_log_error_impl(&dword_1D8A54000, v282, OS_LOG_TYPE_ERROR, v281, (uint8_t *)buf, v283);
        goto LABEL_329;
      }
      if ((objc_opt_respondsToSelector() & 1) != 0)
        v277 = (const __CFString *)objc_msgSend((id)a1, "performSelector:", sel_logPrefix);
      else
        v277 = &stru_1E9E58EE0;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v284 = VRTraceErrorLogLevelToCSTR();
        v285 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v319 = *(_DWORD *)(a1 + 1116);
          LODWORD(buf[0]) = 136316674;
          *(_QWORD *)((char *)buf + 4) = v284;
          WORD6(buf[0]) = 2080;
          *(_QWORD *)((char *)buf + 14) = "_AVCRateController_UpdateInitialBitrateFromDefault";
          WORD3(buf[1]) = 1024;
          DWORD2(buf[1]) = 1841;
          WORD6(buf[1]) = 2112;
          *(_QWORD *)((char *)&buf[1] + 14) = v277;
          WORD3(buf[2]) = 2048;
          *((_QWORD *)&buf[2] + 1) = a1;
          LOWORD(buf[3]) = 1024;
          *(_DWORD *)((char *)&buf[3] + 2) = v319;
          WORD3(buf[3]) = 1024;
          DWORD2(buf[3]) = v328;
          v281 = "AVCRC [%s] %s:%d %@(%p) Forced the initialBitrate=%u, initialTierIndex=%d";
          v282 = v285;
          v283 = 60;
          goto LABEL_374;
        }
      }
LABEL_329:
      if (*(double *)&v408 >= 0.01)
        goto LABEL_339;
      _AVCRateController_ChangeECNSupport(a1, 0, 0);
      if (objc_opt_class() == a1)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() < 3)
          goto LABEL_339;
        v287 = VRTraceErrorLogLevelToCSTR();
        v288 = *MEMORY[0x1E0CF2758];
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          goto LABEL_339;
        v289 = *(unsigned __int8 *)(a1 + 1592);
        LODWORD(buf[0]) = 136316930;
        *(_QWORD *)((char *)buf + 4) = v287;
        WORD6(buf[0]) = 2080;
        *(_QWORD *)((char *)buf + 14) = "_AVCRateController_ForceECNSupportToAlgorithmConfig";
        WORD3(buf[1]) = 1024;
        DWORD2(buf[1]) = 1811;
        WORD6(buf[1]) = 1024;
        *(_DWORD *)((char *)&buf[1] + 14) = v289;
        WORD1(buf[2]) = 2048;
        *(_QWORD *)((char *)&buf[2] + 4) = v408;
        WORD6(buf[2]) = 1024;
        *(_DWORD *)((char *)&buf[2] + 14) = v407;
        WORD1(buf[3]) = 1024;
        DWORD1(buf[3]) = HIDWORD(v406);
        WORD4(buf[3]) = 1024;
        *(_DWORD *)((char *)&buf[3] + 10) = v406;
        v290 = "AVCRC [%s] %s:%d Forced the default ECN settings to=%d with ceRatioDurationToRTTFactor=%f, rampDownECNBit"
               "rateLow=%u, rampDownECNBitrateMedium=%u, rampDownECNBitrateHigh=%u";
        v291 = v288;
        v292 = 62;
LABEL_372:
        _os_log_error_impl(&dword_1D8A54000, v291, OS_LOG_TYPE_ERROR, v290, (uint8_t *)buf, v292);
        goto LABEL_339;
      }
      if ((objc_opt_respondsToSelector() & 1) != 0)
        v286 = (const __CFString *)objc_msgSend((id)a1, "performSelector:", sel_logPrefix);
      else
        v286 = &stru_1E9E58EE0;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v293 = VRTraceErrorLogLevelToCSTR();
        v294 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v318 = *(unsigned __int8 *)(a1 + 1592);
          LODWORD(buf[0]) = 136317442;
          *(_QWORD *)((char *)buf + 4) = v293;
          WORD6(buf[0]) = 2080;
          *(_QWORD *)((char *)buf + 14) = "_AVCRateController_ForceECNSupportToAlgorithmConfig";
          WORD3(buf[1]) = 1024;
          DWORD2(buf[1]) = 1811;
          WORD6(buf[1]) = 2112;
          *(_QWORD *)((char *)&buf[1] + 14) = v286;
          WORD3(buf[2]) = 2048;
          *((_QWORD *)&buf[2] + 1) = a1;
          LOWORD(buf[3]) = 1024;
          *(_DWORD *)((char *)&buf[3] + 2) = v318;
          WORD3(buf[3]) = 2048;
          *((_QWORD *)&buf[3] + 1) = v408;
          LOWORD(buf[4]) = 1024;
          *(_DWORD *)((char *)&buf[4] + 2) = v407;
          WORD3(buf[4]) = 1024;
          DWORD2(buf[4]) = HIDWORD(v406);
          WORD6(buf[4]) = 1024;
          *(_DWORD *)((char *)&buf[4] + 14) = v406;
          v290 = "AVCRC [%s] %s:%d %@(%p) Forced the default ECN settings to=%d with ceRatioDurationToRTTFactor=%f, rampD"
                 "ownECNBitrateLow=%u, rampDownECNBitrateMedium=%u, rampDownECNBitrateHigh=%u";
          v291 = v294;
          v292 = 82;
          goto LABEL_372;
        }
      }
LABEL_339:
      v295 = v359;
      BoolValueForKey = VCDefaults_GetBoolValueForKey(CFSTR("enableBytesInFlightAdaptation"), BoolValueForKey);
      v359 = VCDefaults_GetBoolValueForKey(CFSTR("rateControlContinuousTierAlgorithm"), v295);
      VCRateControlCongestionLevel_PopulateCongestionLevelThresholds(buf);
      v417 = buf[6];
      v418 = buf[7];
      v419 = buf[8];
      v420 = buf[9];
      v413 = buf[2];
      v414 = buf[3];
      v415 = buf[4];
      v416 = buf[5];
      v411 = buf[0];
      v412 = buf[1];
      v296 = *(_QWORD *)(a1 + 1776);
      if (v296)
      {
        VCRateControlAlgorithm_Configure(v296, (uint64_t)&v326);
        v297 = *(_QWORD *)(a1 + 1776);
        if (v297)
        {
          v298 = *(_QWORD *)(a1 + 1280);
          if (v298)
            VCRateControlAlgorithm_EnableBasebandDump(v297, v298);
        }
      }
      else
      {
        switch(*v324)
        {
          case 1:
          case 3:
          case 7:
            v299 = BoolValueForKey;
            if (v359)
            {
              v300 = objc_alloc_init(VCRateControlAlgorithmLayeredContinuousTier);
              *(_QWORD *)(a1 + 1776) = v300;
              _ZF = !v299;
              v302 = 3;
            }
            else
            {
              v300 = objc_alloc_init(VCRateControlAlgorithmStabilizedNOWRD);
              *(_QWORD *)(a1 + 1776) = v300;
              _ZF = !v299;
              v302 = 1;
            }
            if (_ZF)
              ++v302;
            *(_DWORD *)(a1 + 1768) = v302;
            if (v300)
              goto LABEL_356;
            break;
          case 2:
            v303 = VCRateControlAlgorithmStabilizedNOWRD;
            goto LABEL_355;
          case 4:
          case 5:
            v303 = VCRateControlAlgorithmSparseNOWRD;
            goto LABEL_355;
          case 8:
          case 9:
            v303 = VCRateControlAlgorithmLowLatencyNOWRD;
            goto LABEL_355;
          case 10:
            v303 = VCRateControlAlgorithmTelephony;
LABEL_355:
            v300 = (VCRateControlAlgorithmLayeredContinuousTier *)objc_alloc_init(v303);
            *(_QWORD *)(a1 + 1776) = v300;
            if (v300)
            {
LABEL_356:
              VCRateControlAlgorithm_Configure((uint64_t)v300, (uint64_t)&v326);
              VCRateControlAlgorithm_EnableLogDump(*(_QWORD *)(a1 + 1776), *(_QWORD *)(a1 + 1264), *(_BYTE *)(a1 + 1320));
              if (*(_QWORD *)(a1 + 56))
                objc_msgSend(*(id *)(a1 + 1776), "setMediaController:");
              _AVCRateController_RegisterStatisticsChangeHandlers(a1);
            }
            break;
          default:
            break;
        }
      }
      _AVCRateController_NotifyTargetBitrateChange(a1);
      v304 = *(void **)(a1 + 1776);
      if (!v304)
        goto LABEL_369;
      objc_msgSend(v304, "config");
      v305 = *(void **)(a1 + 1776);
      v306 = v427;
      if (v305)
      {
        objc_msgSend(v305, "reportStatistics");
        if (!v306 || DWORD1(v425[0]))
          goto LABEL_369;
        v307 = *(void **)(a1 + 1776);
        v423 = CFSTR("SBVERS");
        v308 = (void *)MEMORY[0x1E0CB37E8];
        if (v307)
        {
          objc_msgSend(v307, "reportStatistics");
          v309 = BYTE12(v422);
LABEL_368:
          v424 = objc_msgSend(v308, "numberWithUnsignedChar:", v309);
          objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v424, &v423, 1);
          reportingGenericEvent();
          goto LABEL_369;
        }
LABEL_367:
        v309 = 0;
        v422 = 0u;
        v421 = 0u;
        goto LABEL_368;
      }
      memset(v425, 0, sizeof(v425));
      if (v427)
      {
        v423 = CFSTR("SBVERS");
        v308 = (void *)MEMORY[0x1E0CB37E8];
        goto LABEL_367;
      }
LABEL_369:
      v310 = v329;
      *(_DWORD *)(a1 + 1120) = vcRateControlTierBitrates[SHIDWORD(v328)];
      *(_DWORD *)(a1 + 1124) = vcRateControlTierBitrates[v310];
      *(_QWORD *)&v421 = CFSTR("maxTargetBitrate");
      *(_QWORD *)&v425[0] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", (double)(*(_DWORD *)(a1 + 76) / 0x3E8u));
      objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v425, &v421, 1);
      reportingGenericEvent();
      v311 = *(_DWORD *)(a1 + 1768);
      v312 = *(_DWORD *)(a1 + 64);
      v325 = *(_QWORD *)(a1 + 68);
      v313 = *(int32x2_t *)(a1 + 1120);
      v314 = micro();
      v315 = *(_DWORD *)(a1 + 1116);
      memset((char *)&buf[4] + 8, 0, 72);
      *(_QWORD *)&buf[0] = 0xAAAAAAAA00000004;
      BYTE8(buf[0]) = 0;
      *(_DWORD *)((char *)buf + 9) = -1431655766;
      HIDWORD(buf[0]) = -1431655766;
      buf[1] = *(unint64_t *)&v314;
      *(_QWORD *)&buf[2] = v315;
      BYTE8(buf[2]) = 0;
      *(_DWORD *)((char *)&buf[2] + 9) = -1431655766;
      HIDWORD(buf[2]) = -1431655766;
      *(_QWORD *)&buf[3] = __PAIR64__(v312, v311);
      *(_QWORD *)&v316 = v325;
      *((int32x2_t *)&v316 + 1) = vrev64_s32(v313);
      *(_OWORD *)((char *)&buf[3] + 8) = v316;
      VCReporting_DumpIntoDataStore();
      v44 = *(_DWORD *)(a1 + 104);
LABEL_370:
      VCStatisticsCollector_SetFastSuddenBandwidthDetectionEnabled((uint64_t)v6, (v44 & 0x10) != 0);
      return objc_msgSend(v6, "setServerBag:", *(_QWORD *)(a1 + 1472));
    case 8:
    case 9:
      v108 = *(_DWORD *)(a1 + 76);
      v109 = 49;
      do
        v110 = vcRateControlTierBitrates[v109--];
      while (v110 > v108);
      v111 = 3;
      if ((int)v109 + 1 > 3)
        v112 = v109 + 1;
      else
        v112 = 3;
      HIDWORD(v328) = v112;
      v113 = *(_DWORD *)(a1 + 80);
      do
        v114 = vcRateControlTierBitrates[v111++];
      while (v114 < v113);
      v115 = v111 - 1;
      v116 = 49;
      if ((int)v111 - 1 >= 49)
        v117 = 49;
      else
        v117 = v111 - 1;
      v329 = v117;
      v118 = *(_DWORD *)(a1 + 84);
      if (!v118)
        v118 = 11500000;
      if (v115 < 49)
        v116 = v115;
      v119 = v116 - 1;
      v120 = &vcRateControlTierBitrates[v116];
      do
      {
        v121 = *v120++;
        ++v119;
      }
      while (v121 < v118);
      if (v119 < v112)
        v112 = v119;
      v336 = 4;
      LODWORD(v328) = v112;
      DWORD2(v335) = 0;
      *(_QWORD *)&v352 = 0x3FE8000000000000;
      if (v90 == 8)
      {
        if (v113)
          v122 = v108 / v113 > 4;
        else
          v122 = 1;
        HIBYTE(v361) = v122;
        v136 = v108 >> 1;
        v137 = 49;
        do
          v138 = vcRateControlTierBitrates[v137--];
        while (v138 > v136);
        if ((int)v137 + 1 > 3)
          v131 = v137 + 1;
        else
          v131 = 3;
      }
      else
      {
        v369 = 1;
        HIBYTE(v361) = 1;
        v131 = 23;
      }
      v338 = v131;
      goto LABEL_194;
    case 10:
      v327 = (int *)&vcTelephonyTierBitrates;
      v329 = 0;
      v328 = 0x100000001;
      *(_QWORD *)&v403 = 0x4024000000000000;
      v402 = 0xA00000000;
      *((_QWORD *)&v403 + 1) = 0x4014000000000000;
      goto LABEL_194;
    default:
      goto LABEL_194;
  }
}

uint64_t _AVCRateController_RegisterStatisticsChangeHandlers(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  void *v12;
  _QWORD v13[5];
  _QWORD v14[5];
  _QWORD v15[5];
  _QWORD v16[5];
  _QWORD v17[5];
  _QWORD v18[5];
  _QWORD v19[5];
  _QWORD v20[5];
  _QWORD v21[5];
  _QWORD v22[6];

  v22[5] = *MEMORY[0x1E0C80C00];
  v1 = result;
  switch(*(_DWORD *)(result + 64))
  {
    case 1:
    case 2:
    case 3:
    case 7:
      v2 = MEMORY[0x1E0C809B0];
      v3 = *(void **)(result + 24);
      v22[0] = MEMORY[0x1E0C809B0];
      v22[1] = 3221225472;
      v22[2] = ___AVCRateController_RegisterStatisticsChangeHandlers_block_invoke;
      v22[3] = &unk_1E9E523A0;
      v22[4] = v1;
      objc_msgSend(v3, "registerStatisticsChangeHandlerWithType:handler:", 2, v22);
      v4 = *(void **)(v1 + 24);
      v21[0] = v2;
      v21[1] = 3221225472;
      v21[2] = ___AVCRateController_RegisterStatisticsChangeHandlers_block_invoke_2;
      v21[3] = &unk_1E9E523A0;
      v21[4] = v1;
      objc_msgSend(v4, "registerStatisticsChangeHandlerWithType:handler:", 1, v21);
      v5 = *(void **)(v1 + 24);
      v20[0] = v2;
      v20[1] = 3221225472;
      v20[2] = ___AVCRateController_RegisterStatisticsChangeHandlers_block_invoke_3;
      v20[3] = &unk_1E9E523A0;
      v20[4] = v1;
      objc_msgSend(v5, "registerStatisticsChangeHandlerWithType:handler:", 11, v20);
      v6 = *(void **)(v1 + 24);
      v19[0] = v2;
      v19[1] = 3221225472;
      v19[2] = ___AVCRateController_RegisterStatisticsChangeHandlers_block_invoke_4;
      v19[3] = &unk_1E9E523A0;
      v19[4] = v1;
      v7 = v19;
      v8 = 14;
      goto LABEL_7;
    case 4:
      v11 = MEMORY[0x1E0C809B0];
      v12 = *(void **)(result + 24);
      v16[0] = MEMORY[0x1E0C809B0];
      v16[1] = 3221225472;
      v16[2] = ___AVCRateController_RegisterStatisticsChangeHandlers_block_invoke_7;
      v16[3] = &unk_1E9E523A0;
      v16[4] = v1;
      objc_msgSend(v12, "registerStatisticsChangeHandlerWithType:handler:", 5, v16);
      v6 = *(void **)(v1 + 24);
      v15[0] = v11;
      v15[1] = 3221225472;
      v15[2] = ___AVCRateController_RegisterStatisticsChangeHandlers_block_invoke_8;
      v15[3] = &unk_1E9E523A0;
      v15[4] = v1;
      v7 = v15;
      v8 = 1;
      goto LABEL_7;
    case 5:
      v6 = *(void **)(result + 24);
      v14[0] = MEMORY[0x1E0C809B0];
      v14[1] = 3221225472;
      v14[2] = ___AVCRateController_RegisterStatisticsChangeHandlers_block_invoke_9;
      v14[3] = &unk_1E9E523A0;
      v14[4] = v1;
      v7 = v14;
      v8 = 5;
      goto LABEL_7;
    case 8:
    case 9:
      v9 = MEMORY[0x1E0C809B0];
      v10 = *(void **)(result + 24);
      v18[0] = MEMORY[0x1E0C809B0];
      v18[1] = 3221225472;
      v18[2] = ___AVCRateController_RegisterStatisticsChangeHandlers_block_invoke_5;
      v18[3] = &unk_1E9E523A0;
      v18[4] = v1;
      objc_msgSend(v10, "registerStatisticsChangeHandlerWithType:handler:", 2, v18);
      v6 = *(void **)(v1 + 24);
      v17[0] = v9;
      v17[1] = 3221225472;
      v17[2] = ___AVCRateController_RegisterStatisticsChangeHandlers_block_invoke_6;
      v17[3] = &unk_1E9E523A0;
      v17[4] = v1;
      v7 = v17;
      v8 = 11;
      goto LABEL_7;
    case 0xA:
      v6 = *(void **)(result + 24);
      v13[0] = MEMORY[0x1E0C809B0];
      v13[1] = 3221225472;
      v13[2] = ___AVCRateController_RegisterStatisticsChangeHandlers_block_invoke_10;
      v13[3] = &unk_1E9E523A0;
      v13[4] = v1;
      v7 = v13;
      v8 = 12;
LABEL_7:
      result = objc_msgSend(v6, "registerStatisticsChangeHandlerWithType:handler:", v8, v7);
      break;
    default:
      return result;
  }
  return result;
}

void sub_1D8A99EA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void AVCRateController_ApplyServerBagLossBasedAdaptationConfig(uint64_t a1, _QWORD *a2)
{
  void *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  int v28;
  __int16 v29;
  uint64_t v30;
  __int16 v31;
  uint64_t v32;
  __int16 v33;
  uint64_t v34;
  __int16 v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v4 = *(void **)(a1 + 1472);
  v5 = objc_msgSend(v4, "containsAllSecondaryKeysWithPrimaryKey:", CFSTR("lossBasedAdaptation"));
  if (v5)
  {
    objc_msgSend((id)objc_msgSend(v4, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("lossBasedAdaptation"), CFSTR("packetLossRateThresholdInitial"), 0), "doubleValue");
    a2[86] = v6;
    objc_msgSend((id)objc_msgSend(v4, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("lossBasedAdaptation"), CFSTR("packetLossRateThresholdMin"), 0), "doubleValue");
    a2[87] = v7;
    objc_msgSend((id)objc_msgSend(v4, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("lossBasedAdaptation"), CFSTR("packetLossRateThresholdMax"), 0), "doubleValue");
    a2[88] = v8;
    objc_msgSend((id)objc_msgSend(v4, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("lossBasedAdaptation"), CFSTR("packetLossRateThresholdTarget"), 0), "doubleValue");
    a2[89] = v9;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v10 = VRTraceErrorLogLevelToCSTR();
    v11 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v12 = objc_msgSend(CFSTR("lossBasedAdaptation"), "UTF8String");
      v13 = a2[86];
      v14 = a2[87];
      v15 = a2[88];
      v16 = a2[89];
      v17 = 136317442;
      v18 = v10;
      v19 = 2080;
      v20 = "AVCRateController_ApplyServerBagLossBasedAdaptationConfig";
      v21 = 1024;
      v22 = 1596;
      v23 = 2048;
      v24 = a1;
      v25 = 2080;
      v26 = v12;
      v27 = 1024;
      v28 = v5;
      v29 = 2048;
      v30 = v13;
      v31 = 2048;
      v32 = v14;
      v33 = 2048;
      v34 = v15;
      v35 = 2048;
      v36 = v16;
      _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, "AVCRC [%s] %s:%d [%p] config for key=%s serverBagContainsGroup=%d packetLossRateThresholdInitial=%f packetLossRateThresholdMin=%f packetLossRateThresholdMax=%f packetLossRateThresholdTarget=%f", (uint8_t *)&v17, 0x5Eu);
    }
  }
}

void _AVCRateController_ApplyServerBagBasebandConfig(uint64_t a1, uint64_t a2)
{
  void *v4;
  int v5;
  int v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  uint64_t v18;
  __int16 v19;
  uint64_t v20;
  __int16 v21;
  int v22;
  __int16 v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v4 = *(void **)(a1 + 1472);
  v5 = objc_msgSend(v4, "containsAllSecondaryKeysWithPrimaryKey:", CFSTR("baseband"));
  if (v5)
  {
    v6 = objc_msgSend((id)objc_msgSend(v4, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("baseband"), CFSTR("disableBBAdaptation"), 0), "BOOLValue") ^ 1;
    if (!*(_BYTE *)(a2 + 371))
      LOBYTE(v6) = 0;
    *(_BYTE *)(a2 + 371) = v6;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v7 = VRTraceErrorLogLevelToCSTR();
    v8 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v9 = objc_msgSend(CFSTR("baseband"), "UTF8String");
      v10 = *(unsigned __int8 *)(a2 + 371);
      v11 = 136316674;
      v12 = v7;
      v13 = 2080;
      v14 = "_AVCRateController_ApplyServerBagBasebandConfig";
      v15 = 1024;
      v16 = 1606;
      v17 = 2048;
      v18 = a1;
      v19 = 2080;
      v20 = v9;
      v21 = 1024;
      v22 = v5;
      v23 = 1024;
      v24 = v10;
      _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, "AVCRC [%s] %s:%d [%p] config for key=%s serverBagContainsGroup=%d basebandAdaptationEnabled=%d", (uint8_t *)&v11, 0x3Cu);
    }
  }
}

void _AVCRateController_ApplyServerBagSmartBrakeConfig(_QWORD *a1, uint64_t a2)
{
  void *v4;
  int v5;
  const __CFString *v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  int v10;
  const char *v11;
  NSObject *v12;
  uint32_t v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  _BYTE v27[10];
  uint64_t v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v4 = (void *)a1[184];
  v5 = objc_msgSend(v4, "containsAllSecondaryKeysWithPrimaryKey:", CFSTR("smartBrake"));
  if (v5)
    *(_DWORD *)(a2 + 808) = objc_msgSend((id)objc_msgSend(v4, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("smartBrake"), CFSTR("strategyNum"), 0), "intValue");
  if ((_QWORD *)objc_opt_class() == a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v7 = VRTraceErrorLogLevelToCSTR();
      v8 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v9 = objc_msgSend(CFSTR("smartBrake"), "UTF8String");
        v10 = *(_DWORD *)(a2 + 808);
        v18 = 136316418;
        v19 = v7;
        v20 = 2080;
        v21 = "_AVCRateController_ApplyServerBagSmartBrakeConfig";
        v22 = 1024;
        v23 = 1626;
        v24 = 2080;
        v25 = v9;
        v26 = 1024;
        *(_DWORD *)v27 = v5;
        *(_WORD *)&v27[4] = 1024;
        *(_DWORD *)&v27[6] = v10;
        v11 = "AVCRC [%s] %s:%d Config for key=%s serverBagContainsGroup=%d smartBrakeStrategy=%u";
        v12 = v8;
        v13 = 50;
LABEL_13:
        _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, v11, (uint8_t *)&v18, v13);
      }
    }
  }
  else
  {
    if ((objc_opt_respondsToSelector() & 1) != 0)
      v6 = (const __CFString *)objc_msgSend(a1, "performSelector:", sel_logPrefix);
    else
      v6 = &stru_1E9E58EE0;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v14 = VRTraceErrorLogLevelToCSTR();
      v15 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v16 = objc_msgSend(CFSTR("smartBrake"), "UTF8String");
        v17 = *(_DWORD *)(a2 + 808);
        v18 = 136316930;
        v19 = v14;
        v20 = 2080;
        v21 = "_AVCRateController_ApplyServerBagSmartBrakeConfig";
        v22 = 1024;
        v23 = 1626;
        v24 = 2112;
        v25 = (uint64_t)v6;
        v26 = 2048;
        *(_QWORD *)v27 = a1;
        *(_WORD *)&v27[8] = 2080;
        v28 = v16;
        v29 = 1024;
        v30 = v5;
        v31 = 1024;
        v32 = v17;
        v11 = "AVCRC [%s] %s:%d %@(%p) Config for key=%s serverBagContainsGroup=%d smartBrakeStrategy=%u";
        v12 = v15;
        v13 = 70;
        goto LABEL_13;
      }
    }
  }
}

void _AVCRateController_ApplyServerBagECNConfig(_QWORD *a1, uint64_t a2)
{
  void *v4;
  int v5;
  const __CFString *v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  const char *v14;
  NSObject *v15;
  uint32_t v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  _BYTE v33[20];
  _BYTE v34[6];
  uint64_t v35;
  __int16 v36;
  int v37;
  __int16 v38;
  int v39;
  __int16 v40;
  int v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v4 = (void *)a1[184];
  v5 = objc_msgSend(v4, "containsAllSecondaryKeysWithPrimaryKey:", CFSTR("l4secn"));
  if (v5)
  {
    *(_DWORD *)(a2 + 776) = 1000
                          * objc_msgSend((id)objc_msgSend(v4, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("l4secn"), CFSTR("ecnBitrateLow"), 0), "intValue");
    *(_DWORD *)(a2 + 772) = 1000
                          * objc_msgSend((id)objc_msgSend(v4, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("l4secn"), CFSTR("ecnBitrateMedium"), 0), "intValue");
    *(_DWORD *)(a2 + 768) = 1000
                          * objc_msgSend((id)objc_msgSend(v4, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("l4secn"), CFSTR("ecnBitrateHigh"), 0), "intValue");
    *(double *)(a2 + 784) = (double)(int)objc_msgSend((id)objc_msgSend(v4, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("l4secn"), CFSTR("ecnCEDurationToRTT"), 0), "intValue");
  }
  if ((_QWORD *)objc_opt_class() == a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v7 = VRTraceErrorLogLevelToCSTR();
      v8 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v9 = objc_msgSend(CFSTR("l4secn"), "UTF8String");
        v10 = *(_QWORD *)(a2 + 784);
        v11 = *(_DWORD *)(a2 + 776);
        v12 = *(_DWORD *)(a2 + 772);
        v13 = *(_DWORD *)(a2 + 768);
        v24 = 136317186;
        v25 = v7;
        v26 = 2080;
        v27 = "_AVCRateController_ApplyServerBagECNConfig";
        v28 = 1024;
        v29 = 1638;
        v30 = 2080;
        v31 = v9;
        v32 = 1024;
        *(_DWORD *)v33 = v5;
        *(_WORD *)&v33[4] = 2048;
        *(_QWORD *)&v33[6] = v10;
        *(_WORD *)&v33[14] = 1024;
        *(_DWORD *)&v33[16] = v11;
        *(_WORD *)v34 = 1024;
        *(_DWORD *)&v34[2] = v12;
        LOWORD(v35) = 1024;
        *(_DWORD *)((char *)&v35 + 2) = v13;
        v14 = "AVCRC [%s] %s:%d Config for key=%s serverBagContainsGroup=%d ceRatioDurationToRTTFactor=%f, rampDownECNBit"
              "rateLow=%u, rampDownECNBitrateMedium=%u, rampDownECNBitrateHigh=%u";
        v15 = v8;
        v16 = 72;
LABEL_13:
        _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, v14, (uint8_t *)&v24, v16);
      }
    }
  }
  else
  {
    if ((objc_opt_respondsToSelector() & 1) != 0)
      v6 = (const __CFString *)objc_msgSend(a1, "performSelector:", sel_logPrefix);
    else
      v6 = &stru_1E9E58EE0;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v17 = VRTraceErrorLogLevelToCSTR();
      v18 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v19 = objc_msgSend(CFSTR("l4secn"), "UTF8String");
        v20 = *(_QWORD *)(a2 + 784);
        v21 = *(_DWORD *)(a2 + 776);
        v22 = *(_DWORD *)(a2 + 772);
        v23 = *(_DWORD *)(a2 + 768);
        v24 = 136317698;
        v25 = v17;
        v26 = 2080;
        v27 = "_AVCRateController_ApplyServerBagECNConfig";
        v28 = 1024;
        v29 = 1638;
        v30 = 2112;
        v31 = (uint64_t)v6;
        v32 = 2048;
        *(_QWORD *)v33 = a1;
        *(_WORD *)&v33[8] = 2080;
        *(_QWORD *)&v33[10] = v19;
        *(_WORD *)&v33[18] = 1024;
        *(_DWORD *)v34 = v5;
        *(_WORD *)&v34[4] = 2048;
        v35 = v20;
        v36 = 1024;
        v37 = v21;
        v38 = 1024;
        v39 = v22;
        v40 = 1024;
        v41 = v23;
        v14 = "AVCRC [%s] %s:%d %@(%p) Config for key=%s serverBagContainsGroup=%d ceRatioDurationToRTTFactor=%f, rampDow"
              "nECNBitrateLow=%u, rampDownECNBitrateMedium=%u, rampDownECNBitrateHigh=%u";
        v15 = v18;
        v16 = 92;
        goto LABEL_13;
      }
    }
  }
}

void _AVCRateController_ApplyServerBagBIFConfig(_QWORD *a1, uint64_t a2)
{
  void *v4;
  int v5;
  const __CFString *v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  int v10;
  const char *v11;
  NSObject *v12;
  uint32_t v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  _BYTE v27[10];
  uint64_t v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v4 = (void *)a1[184];
  v5 = objc_msgSend(v4, "containsAllSecondaryKeysWithPrimaryKey:", CFSTR("bif"));
  if (v5)
    *(_BYTE *)(a2 + 368) &= objc_msgSend((id)objc_msgSend(v4, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("bif"), CFSTR("enabled"), 0), "intValue");
  if ((_QWORD *)objc_opt_class() == a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v7 = VRTraceErrorLogLevelToCSTR();
      v8 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v9 = objc_msgSend(CFSTR("bif"), "UTF8String");
        v10 = *(unsigned __int8 *)(a2 + 368);
        v18 = 136316418;
        v19 = v7;
        v20 = 2080;
        v21 = "_AVCRateController_ApplyServerBagBIFConfig";
        v22 = 1024;
        v23 = 1647;
        v24 = 2080;
        v25 = v9;
        v26 = 1024;
        *(_DWORD *)v27 = v5;
        *(_WORD *)&v27[4] = 1024;
        *(_DWORD *)&v27[6] = v10;
        v11 = "AVCRC [%s] %s:%d Config for key=%s serverBagContainsGroup=%d bytesInFlightAdaptationEnabled=%d";
        v12 = v8;
        v13 = 50;
LABEL_13:
        _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, v11, (uint8_t *)&v18, v13);
      }
    }
  }
  else
  {
    if ((objc_opt_respondsToSelector() & 1) != 0)
      v6 = (const __CFString *)objc_msgSend(a1, "performSelector:", sel_logPrefix);
    else
      v6 = &stru_1E9E58EE0;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v14 = VRTraceErrorLogLevelToCSTR();
      v15 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v16 = objc_msgSend(CFSTR("bif"), "UTF8String");
        v17 = *(unsigned __int8 *)(a2 + 368);
        v18 = 136316930;
        v19 = v14;
        v20 = 2080;
        v21 = "_AVCRateController_ApplyServerBagBIFConfig";
        v22 = 1024;
        v23 = 1647;
        v24 = 2112;
        v25 = (uint64_t)v6;
        v26 = 2048;
        *(_QWORD *)v27 = a1;
        *(_WORD *)&v27[8] = 2080;
        v28 = v16;
        v29 = 1024;
        v30 = v5;
        v31 = 1024;
        v32 = v17;
        v11 = "AVCRC [%s] %s:%d %@(%p) Config for key=%s serverBagContainsGroup=%d bytesInFlightAdaptationEnabled=%d";
        v12 = v15;
        v13 = 70;
        goto LABEL_13;
      }
    }
  }
}

void _AVCRateController_ApplyServerBagContinuousAdaptationConfig(_QWORD *a1, uint64_t a2)
{
  void *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const __CFString *v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  int v13;
  const char *v14;
  NSObject *v15;
  uint32_t v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  int v26;
  __int16 v27;
  uint64_t v28;
  __int16 v29;
  _BYTE v30[10];
  uint64_t v31;
  __int16 v32;
  int v33;
  __int16 v34;
  int v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v4 = (void *)a1[184];
  v5 = objc_msgSend(v4, "containsAllSecondaryKeysWithPrimaryKey:", CFSTR("continuous"));
  if (v5)
  {
    objc_msgSend((id)objc_msgSend(v4, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("continuous"), CFSTR("timeFactorMedium"), 0), "doubleValue");
    *(_QWORD *)(a2 + 344) = v6;
    objc_msgSend((id)objc_msgSend(v4, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("continuous"), CFSTR("timeFactorHigh"), 0), "doubleValue");
    *(_QWORD *)(a2 + 352) = v7;
    objc_msgSend((id)objc_msgSend(v4, "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("continuous"), CFSTR("timeFactorExcellent"), 0), "doubleValue");
    *(_QWORD *)(a2 + 360) = v8;
    *(_BYTE *)(a2 + 369) = *(double *)(a2 + 344) > 0.5;
  }
  if ((_QWORD *)objc_opt_class() == a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v10 = VRTraceErrorLogLevelToCSTR();
      v11 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v12 = objc_msgSend(CFSTR("continuous"), "UTF8String");
        v13 = *(unsigned __int8 *)(a2 + 369);
        v21 = 136316418;
        v22 = v10;
        v23 = 2080;
        v24 = "_AVCRateController_ApplyServerBagContinuousAdaptationConfig";
        v25 = 1024;
        v26 = 1660;
        v27 = 2080;
        v28 = v12;
        v29 = 1024;
        *(_DWORD *)v30 = v5;
        *(_WORD *)&v30[4] = 1024;
        *(_DWORD *)&v30[6] = v13;
        v14 = "AVCRC [%s] %s:%d Config for key=%s serverBagContainsGroup=%d useContinuousAdaptationAlgorithm=%d";
        v15 = v11;
        v16 = 50;
LABEL_13:
        _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, v14, (uint8_t *)&v21, v16);
      }
    }
  }
  else
  {
    if ((objc_opt_respondsToSelector() & 1) != 0)
      v9 = (const __CFString *)objc_msgSend(a1, "performSelector:", sel_logPrefix);
    else
      v9 = &stru_1E9E58EE0;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v17 = VRTraceErrorLogLevelToCSTR();
      v18 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v19 = objc_msgSend(CFSTR("continuous"), "UTF8String");
        v20 = *(unsigned __int8 *)(a2 + 369);
        v21 = 136316930;
        v22 = v17;
        v23 = 2080;
        v24 = "_AVCRateController_ApplyServerBagContinuousAdaptationConfig";
        v25 = 1024;
        v26 = 1660;
        v27 = 2112;
        v28 = (uint64_t)v9;
        v29 = 2048;
        *(_QWORD *)v30 = a1;
        *(_WORD *)&v30[8] = 2080;
        v31 = v19;
        v32 = 1024;
        v33 = v5;
        v34 = 1024;
        v35 = v20;
        v14 = "AVCRC [%s] %s:%d %@(%p) Config for key=%s serverBagContainsGroup=%d useContinuousAdaptationAlgorithm=%d";
        v15 = v18;
        v16 = 70;
        goto LABEL_13;
      }
    }
  }
}

void _AVCRateController_NotifyTargetBitrateChange(uint64_t a1)
{
  double v2;
  int v3;
  int v4;
  uint64_t v5;
  NSObject *v6;
  int v7;
  __int128 v8;
  uint64_t v9;
  NSObject *v10;
  int v11;
  uint64_t v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  _BOOL4 v19;
  const __CFString *v20;
  uint64_t v21;
  NSObject *v22;
  int v23;
  int v24;
  int v25;
  const char *v26;
  NSObject *v27;
  uint32_t v28;
  uint64_t v29;
  NSObject *v30;
  int v31;
  int v32;
  int v33;
  _BYTE v34[48];
  _BYTE v35[24];
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v2 = micro();
  if (v2 - *(double *)(a1 + 1328) > 3.0)
  {
    v3 = *(_DWORD *)(a1 + 64);
    *(double *)(a1 + 1328) = v2;
    if (v3 == 5)
    {
      *(_DWORD *)(a1 + 1340) = -[VCDefaults rateControlForceRxCap](+[VCDefaults sharedInstance](VCDefaults, "sharedInstance"), "rateControlForceRxCap");
      v4 = -[VCDefaults rateControlForceRxRate](+[VCDefaults sharedInstance](VCDefaults, "sharedInstance"), "rateControlForceRxRate");
    }
    else
    {
      *(_DWORD *)(a1 + 1340) = -[VCDefaults rateControlForceTxCap](+[VCDefaults sharedInstance](VCDefaults, "sharedInstance"), "rateControlForceTxCap");
      v4 = -[VCDefaults rateControlForceTxRate](+[VCDefaults sharedInstance](VCDefaults, "sharedInstance"), "rateControlForceTxRate");
    }
    *(_DWORD *)(a1 + 1336) = v4;
    if (*(int *)(a1 + 1340) >= 10000)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v5 = VRTraceErrorLogLevelToCSTR();
        v6 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v7 = *(_DWORD *)(a1 + 1340);
          *(_DWORD *)v34 = 136316162;
          *(_QWORD *)&v34[4] = v5;
          *(_WORD *)&v34[12] = 2080;
          *(_QWORD *)&v34[14] = "AVCRateController_LoadDefaultSettings";
          *(_WORD *)&v34[22] = 1024;
          *(_DWORD *)&v34[24] = 2725;
          *(_WORD *)&v34[28] = 2048;
          *(_QWORD *)&v34[30] = a1;
          *(_WORD *)&v34[38] = 1024;
          *(_DWORD *)&v34[40] = v7;
          _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, "AVCRC [%s] %s:%d (%p) Forcing VCRateControl TxCap to %u from defaults", v34, 0x2Cu);
        }
      }
      v8 = *(_OWORD *)(a1 + 80);
      *(_OWORD *)v34 = *(_OWORD *)(a1 + 64);
      *(_OWORD *)&v34[16] = v8;
      *(_OWORD *)&v34[32] = *(_OWORD *)(a1 + 96);
      *(_DWORD *)&v34[12] = *(_DWORD *)(a1 + 1340);
      _AVCRateController_ConfigureInternal(a1, v34);
      v4 = *(_DWORD *)(a1 + 1336);
    }
    if ((v4 & 0x80000000) == 0 && (int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v9 = VRTraceErrorLogLevelToCSTR();
      v10 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v11 = *(_DWORD *)(a1 + 1336);
        *(_DWORD *)v34 = 136316162;
        *(_QWORD *)&v34[4] = v9;
        *(_WORD *)&v34[12] = 2080;
        *(_QWORD *)&v34[14] = "AVCRateController_LoadDefaultSettings";
        *(_WORD *)&v34[22] = 1024;
        *(_DWORD *)&v34[24] = 2731;
        *(_WORD *)&v34[28] = 2048;
        *(_QWORD *)&v34[30] = a1;
        *(_WORD *)&v34[38] = 1024;
        *(_DWORD *)&v34[40] = v11;
        _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, "AVCRC [%s] %s:%d (%p) Forcing VCRateControl TxRate to %u from defaults", v34, 0x2Cu);
      }
    }
    v12 = *(_QWORD *)(a1 + 56);
    if (*(_DWORD *)(a1 + 68) == 6)
      v13 = 1;
    else
      v13 = -[VCDefaults rateControlAllowVideoStop](+[VCDefaults sharedInstance](VCDefaults, "sharedInstance"), "rateControlAllowVideoStop");
    VCRateControlMediaController_SetAllowVideoStop(v12, v13);
  }
  if (*(_QWORD *)(a1 + 16))
  {
    LODWORD(v14) = objc_msgSend(*(id *)(a1 + 1776), "targetBitrate");
    v15 = objc_msgSend(*(id *)(a1 + 1776), "rateChangeCounter");
    v16 = objc_msgSend(*(id *)(a1 + 1776), "targetBitrateTier");
    v17 = v16;
    v18 = *(_DWORD *)(a1 + 1336);
    if (v18 >= 0)
      v14 = v18;
    else
      v14 = v14;
    v19 = !v16
       || (objc_msgSend(*(id *)(a1 + 1776), "isRampingDown") & 1) != 0
       || *(_DWORD *)(a1 + 1148) != v17
       || (v15 - *(_DWORD *)(a1 + 1152)) > 9;
    if (*(_DWORD *)(a1 + 1140) == (_DWORD)v14)
    {
      if (*(_DWORD *)(a1 + 1152) == (_DWORD)v15)
        LOBYTE(v19) = 0;
      if (!v19)
        return;
    }
    else if (!v19)
    {
      return;
    }
    if (objc_opt_class() == a1)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 7)
        goto LABEL_47;
      v21 = VRTraceErrorLogLevelToCSTR();
      v22 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        goto LABEL_47;
      v23 = *(_DWORD *)(a1 + 64);
      v24 = *(_DWORD *)(a1 + 1140);
      v25 = *(_DWORD *)(a1 + 1152);
      *(_DWORD *)v34 = 136317186;
      *(_QWORD *)&v34[4] = v21;
      *(_WORD *)&v34[12] = 2080;
      *(_QWORD *)&v34[14] = "_AVCRateController_NotifyTargetBitrateChange";
      *(_WORD *)&v34[22] = 1024;
      *(_DWORD *)&v34[24] = 2697;
      *(_WORD *)&v34[28] = 1024;
      *(_DWORD *)&v34[30] = v23;
      *(_WORD *)&v34[34] = 1024;
      *(_DWORD *)&v34[36] = v24;
      *(_WORD *)&v34[40] = 1024;
      *(_DWORD *)&v34[42] = v14;
      *(_WORD *)&v34[46] = 1024;
      *(_DWORD *)v35 = v25;
      *(_WORD *)&v35[4] = 1024;
      *(_DWORD *)&v35[6] = v15;
      *(_WORD *)&v35[10] = 1024;
      *(_DWORD *)&v35[12] = v17;
      v26 = "AVCRC [%s] %s:%d Notify target bitrate change for mode=%d oldTargetBitrate=%u to newTargetBitrate=%u, oldRat"
            "eChangeCounter=%u to newRateChangeCounter=%u, targetBitrateTier=%u";
      v27 = v22;
      v28 = 64;
    }
    else
    {
      if ((objc_opt_respondsToSelector() & 1) != 0)
        v20 = (const __CFString *)objc_msgSend((id)a1, "performSelector:", sel_logPrefix);
      else
        v20 = &stru_1E9E58EE0;
      if ((int)VRTraceGetErrorLogLevelForModule() < 7)
        goto LABEL_47;
      v29 = VRTraceErrorLogLevelToCSTR();
      v30 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        goto LABEL_47;
      v31 = *(_DWORD *)(a1 + 64);
      v32 = *(_DWORD *)(a1 + 1140);
      v33 = *(_DWORD *)(a1 + 1152);
      *(_DWORD *)v34 = 136317698;
      *(_QWORD *)&v34[4] = v29;
      *(_WORD *)&v34[12] = 2080;
      *(_QWORD *)&v34[14] = "_AVCRateController_NotifyTargetBitrateChange";
      *(_WORD *)&v34[22] = 1024;
      *(_DWORD *)&v34[24] = 2697;
      *(_WORD *)&v34[28] = 2112;
      *(_QWORD *)&v34[30] = v20;
      *(_WORD *)&v34[38] = 2048;
      *(_QWORD *)&v34[40] = a1;
      *(_WORD *)v35 = 1024;
      *(_DWORD *)&v35[2] = v31;
      *(_WORD *)&v35[6] = 1024;
      *(_DWORD *)&v35[8] = v32;
      *(_WORD *)&v35[12] = 1024;
      *(_DWORD *)&v35[14] = v14;
      *(_WORD *)&v35[18] = 1024;
      *(_DWORD *)&v35[20] = v33;
      LOWORD(v36) = 1024;
      *(_DWORD *)((char *)&v36 + 2) = v15;
      HIWORD(v36) = 1024;
      LODWORD(v37) = v17;
      v26 = "AVCRC [%s] %s:%d %@(%p) Notify target bitrate change for mode=%d oldTargetBitrate=%u to newTargetBitrate=%u,"
            " oldRateChangeCounter=%u to newRateChangeCounter=%u, targetBitrateTier=%u";
      v27 = v30;
      v28 = 84;
    }
    _os_log_impl(&dword_1D8A54000, v27, OS_LOG_TYPE_DEFAULT, v26, v34, v28);
LABEL_47:
    *(_DWORD *)(a1 + 1140) = v14;
    *(_DWORD *)(a1 + 1144) = v17;
    objc_msgSend(*(id *)(a1 + 40), "setTargetBitrate:", v14, *(_OWORD *)v34, *(_QWORD *)&v34[16], *(_OWORD *)&v34[24], *(_QWORD *)&v34[40], *(_OWORD *)v35, *(_QWORD *)&v35[16], v36, v37, v38);
    VCRateControlMediaController_SetTargetBitrate(*(_QWORD *)(a1 + 56), *(_DWORD *)(a1 + 1140));
    *(_DWORD *)(a1 + 1152) = v15;
    objc_msgSend(*(id *)(a1 + 16), "rateController:targetBitrateDidChange:rateChangeCounter:", a1, v14, v15);
    *(_DWORD *)(a1 + 1148) = *(_DWORD *)(a1 + 1144);
    return;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _AVCRateController_NotifyTargetBitrateChange_cold_1();
  }
}

uint64_t _AVCRateController_MultiwayMaxTierFromServerBag(uint64_t a1)
{
  int v2;
  unsigned int v3;
  unsigned int v4;
  uint64_t v6;
  NSObject *v7;
  int v8;
  uint64_t v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  int v19;
  __int16 v20;
  unsigned int v21;
  __int16 v22;
  unsigned int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 88))
    return 31;
  v2 = objc_msgSend(*(id *)(a1 + 1472), "containsAllSecondaryKeysWithPrimaryKey:", CFSTR("maxBitrate"));
  if (v2)
  {
    v3 = objc_msgSend((id)objc_msgSend(*(id *)(a1 + 1472), "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("maxBitrate"), CFSTR("burstyTrafficUplink"), 0), "integerValue");
    v4 = objc_msgSend((id)objc_msgSend(*(id *)(a1 + 1472), "valueForSecondaryKeyWithPrimaryKey:secondaryKey:type:", CFSTR("maxBitrate"), CFSTR("burstyTrafficDownlink"), 0), "integerValue");
  }
  else
  {
    v4 = 37;
    v3 = 34;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v6 = VRTraceErrorLogLevelToCSTR();
    v7 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v8 = 136316930;
      v9 = v6;
      v10 = 2080;
      v11 = "_AVCRateController_MultiwayMaxTierFromServerBag";
      v12 = 1024;
      v13 = 1783;
      v14 = 2048;
      v15 = a1;
      v16 = 2080;
      v17 = objc_msgSend(CFSTR("maxBitrate"), "UTF8String");
      v18 = 1024;
      v19 = v2;
      v20 = 1024;
      v21 = v3;
      v22 = 1024;
      v23 = v4;
      _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, "AVCRC [%s] %s:%d [%p] config for key=%s serverBagContainsGroup=%d burstyTrafficUplink=%d burstyTrafficDownlink=%d", (uint8_t *)&v8, 0x42u);
    }
  }
  if (*(_DWORD *)(a1 + 64) == 4)
    return v3;
  else
    return v4;
}

uint64_t _AVCRateController_ChangeECNSupport(uint64_t a1, char a2, uint64_t a3)
{
  uint64_t result;

  *(_BYTE *)(a1 + 1592) = a2;
  result = objc_opt_respondsToSelector();
  if ((result & 1) != 0)
    return objc_msgSend(*(id *)(a1 + 16), "rateController:isECNEnabled:isECNCapable:", a1, *(unsigned __int8 *)(a1 + 1592), a3);
  return result;
}

void _AVCRateController_DoRateControlWithStatistics(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  unsigned int v11;
  __int16 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  int v27;
  void *v28;
  int v29;
  void *v30;
  __CFDictionary *Mutable;
  void *v32;
  void *v33;
  uint64_t v34;
  void *v35;
  void *v36;
  double v37;
  void *v38;
  void *v39;
  double v40;
  void *v41;
  void *v42;
  double v43;
  void *v44;
  void *v45;
  double v46;
  void *v47;
  unsigned int v48;
  unsigned int v49;
  uint64_t v50;
  dispatch_time_t v51;
  NSObject *v52;
  uint64_t v53;
  dispatch_time_t v54;
  NSObject *v55;
  dispatch_time_t v56;
  NSObject *v57;
  double v58;
  void *v59;
  BOOL v60;
  unsigned int v61;
  double v62;
  double v63;
  double v64;
  double v65;
  double v66;
  double v67;
  double v68;
  unsigned int v69;
  unsigned int v70;
  double v71;
  double v72;
  unsigned int v73;
  void *v74;
  int v75;
  double v76;
  double v77;
  uint64_t v78;
  NSObject *v79;
  int v80;
  double v81;
  double v82;
  double v83;
  __CFDictionary *v84;
  uint64_t v85;
  void **v86;
  _BOOL4 v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  const __CFString *v91;
  uint64_t v92;
  NSObject *v93;
  uint64_t v94;
  void *v95;
  double v96;
  double v97;
  double v98;
  double v99;
  double v100;
  double v101;
  unsigned int v102;
  double v103;
  double v104;
  double v105;
  double v106;
  int v107;
  int v108;
  char v109;
  double v110;
  double v111;
  double v112;
  unsigned int v113;
  int v114;
  int v115;
  __int16 v116;
  unsigned int v117;
  int v118;
  int v119;
  int v120;
  double v121;
  unsigned int v122;
  int v123;
  int v124;
  _QWORD v125[6];
  unsigned int v126;
  _QWORD block[6];
  unsigned int v128;
  __int128 v129;
  __int128 v130;
  _QWORD v131[3];
  int v132;
  _QWORD v133[3];
  int v134;
  _QWORD v135[3];
  int v136;
  _BYTE buf[24];
  __int128 v138;
  double v139;
  __int128 v140;
  __int128 v141;
  __int128 v142;
  __int128 v143;
  __int128 v144;
  __int128 v145;
  __int128 v146;
  __int128 v147;
  __int128 v148;
  uint64_t v149;
  uint64_t v150;

  v150 = *MEMORY[0x1E0C80C00];
  v10 = *(_QWORD *)(a1 + 1272);
  if (v10)
  {
    v11 = *(_DWORD *)(a1 + 64);
    if (v11 <= 9)
    {
      if (((1 << v11) & 0x8E) != 0)
      {
        v116 = *(_WORD *)(a2 + 68);
        RTPPackDouble(*(double *)(a2 + 80));
        VRLogfilePrint(v10, "%04X\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%04X\t%u\n", v19, v20, v21, v22, v23, v24, v116);
        goto LABEL_9;
      }
      if (((1 << v11) & 0x30) != 0)
      {
        VRLogfilePrint(v10, "%04X\t%04X\t%u\t%u\t%u\t%u\t%u\t%.2f\t%u\t%u\t%.3f\t%u\t%f\n", a3, a4, a5, a6, a7, a8, *(_WORD *)(a2 + 28));
        goto LABEL_9;
      }
      if (((1 << v11) & 0x300) != 0)
      {
        v12 = *(_WORD *)(a2 + 68);
        RTPPackDouble(*(double *)(a2 + 80));
        VRLogfilePrint(v10, "%04X\t%u\t%u\t%u\t%u\t%u\t%04X\t%u\n", v13, v14, v15, v16, v17, v18, v12);
        goto LABEL_9;
      }
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v78 = VRTraceErrorLogLevelToCSTR();
      v79 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v80 = *(_DWORD *)(a1 + 64);
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)&buf[4] = v78;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_AVCRateController_PrintFeedbackMessage";
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v138) = 2901;
        WORD2(v138) = 2048;
        *(_QWORD *)((char *)&v138 + 6) = a1;
        HIWORD(v138) = 1024;
        LODWORD(v139) = v80;
        _os_log_error_impl(&dword_1D8A54000, v79, OS_LOG_TYPE_ERROR, "AVCRC [%s] %s:%d (%p) Configuration mode %d not supported", buf, 0x2Cu);
      }
    }
  }
LABEL_9:
  if (!_AVCRateController_DoRateControl(a1, a2))
    goto LABEL_17;
  *(_DWORD *)(a1 + 1104) = objc_msgSend(*(id *)(a1 + 1776), "actualBitrate");
  if (*(_DWORD *)a2 == 2)
  {
    *(_DWORD *)(a1 + 1452) = *(_DWORD *)(a2 + 52);
    *(_DWORD *)(a1 + 1456) = *(_DWORD *)(a2 + 56);
    *(_DWORD *)(a1 + 1460) = *(unsigned __int16 *)(a2 + 184);
    v25 = *(unsigned __int16 *)(a2 + 186);
    v26 = 1464;
  }
  else
  {
    if (*(_DWORD *)a2 != 5)
      goto LABEL_15;
    *(_DWORD *)(a1 + 1240) = *(_DWORD *)(a2 + 44);
    *(_DWORD *)(a1 + 1244) = *(_DWORD *)(a2 + 48);
    *(_DWORD *)(a1 + 1236) = *(_DWORD *)(a2 + 36);
    v25 = *(_DWORD *)(a2 + 40);
    v26 = 1232;
  }
  *(_DWORD *)(a1 + v26) = v25;
LABEL_15:
  v27 = *(unsigned __int8 *)(a2 + 192);
  if (v27 != *(unsigned __int8 *)(a1 + 1592))
    _AVCRateController_ChangeECNSupport(a1, v27 != 0, 1);
LABEL_17:
  v28 = *(void **)(a1 + 1776);
  if (v28)
  {
    objc_msgSend(v28, "reportStatistics");
    v29 = v124;
  }
  else
  {
    v29 = 0;
  }
  if (v29 != *(_DWORD *)(a1 + 1596))
  {
    *(_DWORD *)(a1 + 1596) = v29;
    v30 = *(void **)(a1 + 1776);
    if (!v30 || (objc_msgSend(v30, "reportStatistics"), !v123))
    {
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (Mutable)
      {
        v32 = (void *)MEMORY[0x1E0CB37E8];
        v33 = *(void **)(a1 + 1776);
        if (v33)
        {
          objc_msgSend(v33, "reportStatistics");
          v34 = v122;
        }
        else
        {
          v34 = 0;
        }
        CFDictionaryAddValue(Mutable, CFSTR("CongestionIndex"), (const void *)objc_msgSend(v32, "numberWithUnsignedInt:", v34));
        v35 = (void *)MEMORY[0x1E0CB37E8];
        v36 = *(void **)(a1 + 1776);
        if (v36)
        {
          objc_msgSend(v36, "reportStatistics");
          v37 = v121 * 1000.0;
        }
        else
        {
          v37 = 0.0;
        }
        CFDictionaryAddValue(Mutable, CFSTR("CongestionDuration"), (const void *)objc_msgSend(v35, "numberWithDouble:", ceil(v37)));
        v38 = (void *)MEMORY[0x1E0CB37E8];
        v39 = *(void **)(a1 + 1776);
        if (v39)
        {
          objc_msgSend(v39, "reportStatistics");
          v40 = (double)(v120 / 1000);
        }
        else
        {
          v40 = 0.0;
        }
        CFDictionaryAddValue(Mutable, CFSTR("StartTargetTxR"), (const void *)objc_msgSend(v38, "numberWithDouble:", v40));
        v41 = (void *)MEMORY[0x1E0CB37E8];
        v42 = *(void **)(a1 + 1776);
        if (v42)
        {
          objc_msgSend(v42, "reportStatistics");
          v43 = (double)(v119 / 1000);
        }
        else
        {
          v43 = 0.0;
        }
        CFDictionaryAddValue(Mutable, CFSTR("StartBWE"), (const void *)objc_msgSend(v41, "numberWithDouble:", v43));
        v44 = (void *)MEMORY[0x1E0CB37E8];
        v45 = *(void **)(a1 + 1776);
        if (v45)
        {
          objc_msgSend(v45, "reportStatistics");
          v46 = (double)(v118 / 1000);
        }
        else
        {
          v46 = 0.0;
        }
        CFDictionaryAddValue(Mutable, CFSTR("EndBWE"), (const void *)objc_msgSend(v44, "numberWithDouble:", v46));
        reportingGenericEvent();
        CFRelease(Mutable);
        v47 = *(void **)(a1 + 1776);
        if (v47)
        {
          objc_msgSend(v47, "reportStatistics");
          v48 = v117;
          v47 = *(void **)(a1 + 1776);
        }
        else
        {
          v48 = 0;
        }
        v135[0] = 0;
        v135[1] = v135;
        v135[2] = 0x2020000000;
        v136 = 0;
        v133[0] = 0;
        v133[1] = v133;
        v133[2] = 0x2020000000;
        v134 = 0;
        v131[0] = 0;
        v131[1] = v131;
        v131[2] = 0x2020000000;
        v132 = 0;
        if (v47)
        {
          objc_msgSend(v47, "reportStatistics");
          v49 = v129;
        }
        else
        {
          v49 = 0;
          v129 = 0u;
          v130 = 0u;
        }
        v50 = *(_QWORD *)(a1 + 1608);
        v51 = dispatch_time(0, 5000000000);
        v52 = *(NSObject **)(a1 + 1600);
        v53 = MEMORY[0x1E0C809B0];
        block[0] = MEMORY[0x1E0C809B0];
        block[1] = 3221225472;
        block[2] = ___AVCRateController_SetupDelayedReportingSmartBrake_block_invoke;
        block[3] = &unk_1E9E52410;
        block[4] = v50;
        block[5] = v135;
        v128 = v48;
        dispatch_after(v51, v52, block);
        v54 = dispatch_time(0, 15000000000);
        v55 = *(NSObject **)(a1 + 1600);
        v125[0] = v53;
        v125[1] = 3221225472;
        v125[2] = ___AVCRateController_SetupDelayedReportingSmartBrake_block_invoke_2;
        v125[3] = &unk_1E9E52410;
        v125[4] = v50;
        v125[5] = v133;
        v126 = v48;
        dispatch_after(v54, v55, v125);
        v56 = dispatch_time(0, 30000000000);
        v57 = *(NSObject **)(a1 + 1600);
        *(_QWORD *)buf = v53;
        *(_QWORD *)&buf[8] = 3221225472;
        *(_QWORD *)&buf[16] = ___AVCRateController_SetupDelayedReportingSmartBrake_block_invoke_3;
        *(_QWORD *)&v138 = &unk_1E9E52438;
        *((_QWORD *)&v138 + 1) = v50;
        v139 = COERCE_DOUBLE(v131);
        *(_QWORD *)&v141 = __PAIR64__(v49, v48);
        *(_QWORD *)&v140 = v135;
        *((_QWORD *)&v140 + 1) = v133;
        dispatch_after(v56, v57, buf);
        _Block_object_dispose(v131, 8);
        _Block_object_dispose(v133, 8);
        _Block_object_dispose(v135, 8);
      }
    }
  }
  _AVCRateController_ReportInitialRampUpDeltas(a1);
  if (*(int *)(a1 + 1340) > 0 || *(int *)(a1 + 1336) > 0)
    goto LABEL_137;
  v58 = micro();
  v59 = *(void **)(a1 + 1776);
  v60 = *(double *)(a1 + 1616) > (double)objc_msgSend(v59, "targetBitrate");
  *(double *)(a1 + 1616) = (double)objc_msgSend(*(id *)(a1 + 1776), "targetBitrate");
  if (v60
    || objc_msgSend(v59, "targetBitrate") < 0x8CA1
    || (v61 = objc_msgSend(v59, "actualBitrate"),
        (double)objc_msgSend(*(id *)(a1 + 1776), "targetBitrate") * 1.05 >= (double)v61))
  {
    *(_QWORD *)(a1 + 1384) = 0;
    goto LABEL_56;
  }
  v62 = *(double *)(a1 + 1384);
  if (v62 == 0.0)
    goto LABEL_54;
  if (v58 - v62 >= 2.0)
  {
    reportingSymptom();
LABEL_54:
    *(double *)(a1 + 1384) = v58;
  }
LABEL_56:
  objc_msgSend(v59, "roundTripTime");
  if (v63 <= 0.001
    || (objc_msgSend(v59, "roundTripTime"), v64 >= 0.02)
    || (objc_msgSend(v59, "packetLossRate"), v65 >= 0.01)
    || (objc_msgSend(v59, "isSendBitrateLimited") & 1) != 0
    || objc_msgSend(v59, "targetBitrate") >= 0x2BF20
    || *(_DWORD *)(a1 + 76) < 0x37AA1u)
  {
    *(_QWORD *)(a1 + 1392) = 0;
    goto LABEL_67;
  }
  v66 = *(double *)(a1 + 1392);
  if (v66 == 0.0)
    goto LABEL_65;
  if (v58 - v66 >= 10.0)
  {
    reportingSymptom();
LABEL_65:
    *(double *)(a1 + 1392) = v58;
  }
LABEL_67:
  objc_msgSend(v59, "roundTripTime");
  if (v67 >= 0.02
    || (objc_msgSend(v59, "packetLossRate"), v68 >= 0.01)
    || (objc_msgSend(v59, "isSendBitrateLimited") & 1) != 0
    || objc_msgSend(v59, "targetBitrate") != *(_DWORD *)(a1 + 1408)
    || (v69 = objc_msgSend(v59, "targetBitrate"), v70 = *(_DWORD *)(a1 + 76), v70 <= 0x2BF20)
    || (double)v70 * 0.7 <= (double)v69)
  {
    *(_QWORD *)(a1 + 1400) = 0;
  }
  else
  {
    v71 = *(double *)(a1 + 1400);
    if (v71 == 0.0)
    {
      *(double *)(a1 + 1400) = v58;
      *(_DWORD *)(a1 + 1408) = objc_msgSend(v59, "targetBitrate");
      v71 = *(double *)(a1 + 1400);
    }
    if (v58 - v71 > 30.0)
      reportingSymptom();
  }
  objc_msgSend(*(id *)(a1 + 1776), "roundTripTime");
  if (v72 > 30.0)
  {
    v73 = *(_DWORD *)(a1 + 1772);
    if (!v73 || v58 - (double)v73 > 30.0)
    {
      reportingSymptom();
      *(_DWORD *)(a1 + 1772) = v58;
    }
  }
  v74 = *(void **)(a1 + 1776);
  v75 = *(_DWORD *)(a1 + 64);
  if (v75 == 4)
  {
    objc_msgSend(*(id *)(a1 + 1776), "packetLossRate");
    if (v76 <= 0.5)
    {
      *(_QWORD *)(a1 + 1424) = 0;
    }
    else
    {
      v77 = *(double *)(a1 + 1424);
      if (v77 == 0.0)
      {
        *(double *)(a1 + 1424) = v58;
        v77 = v58;
      }
      if (v58 - v77 > 5.0)
        reportingSymptom();
    }
    v75 = *(_DWORD *)(a1 + 64);
  }
  if (v75 == 5)
  {
    objc_msgSend(v74, "packetLossRate");
    if (v81 <= 0.5)
    {
      *(_QWORD *)(a1 + 1432) = 0;
    }
    else
    {
      v82 = *(double *)(a1 + 1432);
      if (v82 == 0.0)
      {
        *(double *)(a1 + 1432) = v58;
        v82 = v58;
      }
      if (v58 - v82 > 5.0)
        reportingSymptom();
    }
  }
  if ((*(_DWORD *)(a1 + 64) & 0xFFFFFFFE) != 4)
    goto LABEL_137;
  if (VCRateControlAlgorithmSparseNOWRD_NoServerStatsActivityDetected(*(_QWORD *)(a1 + 1776)))
  {
    v83 = *(double *)(a1 + 1440);
    if (v83 == 0.0)
    {
      *(double *)(a1 + 1440) = v58;
      v83 = v58;
    }
    if (v58 - v83 > 5.0)
      reportingSymptom();
    if (*(_BYTE *)(a1 + 1448))
    {
LABEL_109:
      v85 = 1496;
      if (!*(_BYTE *)(a1 + 1323))
        v85 = 1504;
      v86 = (void **)(a1 + v85);
      if (!*(_QWORD *)(a1 + v85))
        goto LABEL_120;
      goto LABEL_137;
    }
    if (v58 - *(double *)(a1 + 1440) > 30.0)
    {
      v84 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      CFDictionaryAddValue(v84, CFSTR("VCSErrorDetected"), &unk_1E9EF35C0);
      reportingGenericEvent();
      *(_BYTE *)(a1 + 1448) = 1;
      goto LABEL_109;
    }
    v87 = 0;
  }
  else
  {
    *(_QWORD *)(a1 + 1440) = 0;
    v87 = *(_BYTE *)(a1 + 1448) != 0;
  }
  v88 = 1496;
  if (!*(_BYTE *)(a1 + 1323))
    v88 = 1504;
  v86 = (void **)(a1 + v88);
  v89 = *(_QWORD *)(a1 + v88);
  if (v87 || v89)
  {
    if (!v89 && v87)
    {
LABEL_120:
      v90 = nw_activity_create();
      *v86 = (void *)v90;
      if (v90)
      {
        if (*(_QWORD *)(a1 + 1488))
          nw_activity_set_parent_activity();
        nw_activity_activate();
      }
      else if (objc_opt_class() == a1)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _AVCRateController_DoRateControlWithStatistics_cold_1();
        }
      }
      else
      {
        if ((objc_opt_respondsToSelector() & 1) != 0)
          v91 = (const __CFString *)objc_msgSend((id)a1, "performSelector:", sel_logPrefix);
        else
          v91 = &stru_1E9E58EE0;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v92 = VRTraceErrorLogLevelToCSTR();
          v93 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136316162;
            *(_QWORD *)&buf[4] = v92;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_AVCRateController_PushNoServerStatsToNwActivity";
            *(_WORD *)&buf[22] = 1024;
            LODWORD(v138) = 2484;
            WORD2(v138) = 2112;
            *(_QWORD *)((char *)&v138 + 6) = v91;
            HIWORD(v138) = 2048;
            v139 = *(double *)&a1;
            _os_log_error_impl(&dword_1D8A54000, v93, OS_LOG_TYPE_ERROR, "AVCRC [%s] %s:%d %@(%p) Failed to create nwActivity", buf, 0x30u);
          }
        }
      }
      goto LABEL_137;
    }
    if (!v87)
    {
      nw_activity_complete_with_reason();
      nw_release(*v86);
      *v86 = 0;
    }
  }
LABEL_137:
  _AVCRateController_NotifyTargetBitrateChange(a1);
  objc_msgSend(*(id *)(a1 + 40), "setIsTargetBitrateStabilized:", objc_msgSend(*(id *)(a1 + 1776), "isNewRateSentOut"));
  objc_msgSend(*(id *)(a1 + 1776), "setLocalBandwidthEstimation:", VCStatisticsCollector_SharedEstimatedBandwidth(*(_QWORD *)(a1 + 24)));
  if (!*(_BYTE *)(a1 + 1322))
  {
    v94 = *(_QWORD *)(a2 + 8);
    v95 = *(void **)(a1 + 1776);
    objc_msgSend(v95, "packetLossRate");
    v97 = v96;
    objc_msgSend(v95, "packetLossRateAudio");
    v99 = v98;
    objc_msgSend(v95, "packetLossRateVideo");
    v101 = v100;
    v102 = objc_msgSend(v95, "mostBurstLoss");
    objc_msgSend(v95, "roundTripTime");
    v104 = v103;
    objc_msgSend(v95, "owrd");
    v106 = v105;
    v107 = objc_msgSend(v95, "isCongested");
    v108 = v107;
    if (*(_BYTE *)(a1 + 1593))
      v109 = 1;
    else
      v109 = v107;
    *(_BYTE *)(a1 + 1593) = v109;
    *(_DWORD *)(a1 + 1156) = (v104 * 1000.0);
    objc_msgSend(v95, "roundTripTime");
    if (v110 > 0.0)
    {
      v111 = v99 * 100.0;
      v112 = v101 * 100.0;
      v113 = (v106 * 1000.0);
      if (v97 * 100.0 != *(double *)(a1 + 1160)
        || v111 != *(double *)(a1 + 1176)
        || v112 != *(double *)(a1 + 1168)
        || v102 != *(_DWORD *)(a1 + 1248)
        || *(unsigned __int8 *)(a1 + 1256) != v108
        || *(_DWORD *)(a1 + 1252) != v113)
      {
        *(double *)(a1 + 1160) = v97 * 100.0;
        *(double *)(a1 + 1176) = v111;
        *(double *)(a1 + 1168) = v112;
        *(_DWORD *)(a1 + 1248) = v102;
        *(_BYTE *)(a1 + 1256) = v108;
        *(_DWORD *)(a1 + 1252) = v113;
        *(_DWORD *)&buf[4] = 0;
        *(_QWORD *)&buf[16] = 1;
        v140 = 0u;
        v149 = 0;
        v147 = 0u;
        v148 = 0u;
        v145 = 0u;
        v146 = 0u;
        v143 = 0u;
        v144 = 0u;
        v141 = 0u;
        v142 = 0u;
        *(_DWORD *)buf = 3;
        *(_QWORD *)&buf[8] = v94;
        *(double *)&v138 = v97 * 100.0;
        *((double *)&v138 + 1) = v99 * 100.0;
        v139 = v101 * 100.0;
        *(_QWORD *)&v140 = __PAIR64__(*(_DWORD *)(a1 + 1156), v102);
        v114 = *(_DWORD *)(a1 + 1140);
        DWORD2(v140) = v108;
        HIDWORD(v140) = (v106 * 1000.0);
        v115 = *(_DWORD *)(a1 + 1456);
        LODWORD(v141) = v114;
        LODWORD(v142) = v115;
        AVCStatisticsCollector_SetVCStatistics(*(_QWORD *)(a1 + 24), (uint64_t)buf);
      }
    }
  }
}

void sub_1D8A9CAE8(_Unwind_Exception *a1)
{
  _Block_object_dispose(&STACK[0x210], 8);
  _Block_object_dispose(&STACK[0x230], 8);
  _Block_object_dispose(&STACK[0x250], 8);
  _Unwind_Resume(a1);
}

void _AVCRateController_DoRateControlWithBasebandStatistics(uint64_t a1, _DWORD *a2)
{
  char v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (*(_BYTE *)(a1 + 1321))
  {
    if (*(_QWORD *)(a1 + 40))
    {
      v3 = (char)a2;
      if (*a2 == 1)
      {
        v4 = *(void **)(a1 + 1776);
        _AVCRateController_DoRateControl(a1, (uint64_t)a2);
        _AVCRateController_ReportInitialRampUpDeltas(a1);
        _AVCRateController_NotifyTargetBitrateChange(a1);
        objc_msgSend(*(id *)(a1 + 40), "setIsTargetBitrateStabilized:", objc_msgSend(v4, "isNewRateSentOut"));
        v5 = *(_QWORD *)(a1 + 1280);
        if (v5)
        {
          VCRateControlMediaController_AudioFractionTier(*(_QWORD *)(a1 + 56));
          VCRateControlMediaController_IsAudioOnly(*(_QWORD *)(a1 + 56));
          VCRateControlMediaController_IsVideoStopped(*(_BYTE **)(a1 + 56));
          VCRateControlMediaController_IsVideoStoppedByVCRateControl(*(_QWORD *)(a1 + 56));
          VCRateControlMediaController_BasebandFlushCount(*(_QWORD *)(a1 + 56));
          VRLogfilePrintWithTimestamp(v5, "%s %4u\t%4u\t%4u\t%4u\t%4u\t%4d\t%.4f\t%.4f\t%4u %d %c(%1d,%1d) FC:%d\t%.1f\n", v6, v7, v8, v9, v10, v11, v3 + 96);
        }
      }
    }
  }
}

void _AVCRateController_DoRateControlWithNWConnectionStatistics(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  unsigned int v5;
  BOOL v6;
  unsigned int v7;
  double v9;
  void *v10;
  double v11;
  const __CFString *v12;
  const __CFString *v13;
  uint64_t v14;
  NSObject *v15;
  const char *v16;
  NSObject *v17;
  uint32_t v18;
  uint64_t v19;
  NSObject *v20;
  int v21;
  double v22;
  void *v23;
  double v24;
  char v25;
  uint64_t v26;
  double v27;
  uint8_t buf[4];
  uint64_t v29;
  __int16 v30;
  const char *v31;
  __int16 v32;
  int v33;
  __int16 v34;
  const __CFString *v35;
  __int16 v36;
  uint64_t v37;
  __int16 v38;
  int v39;
  double v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 1512))
  {
    if ((*(_DWORD *)a2 - 11) < 2)
    {
      if (*(_DWORD *)a2 != 11)
      {
LABEL_43:
        _AVCRateController_DoRateControl(a1, a2);
        _AVCRateController_NotifyTargetBitrateChange(a1);
        v26 = *(_QWORD *)(a1 + 1288);
        if (v26)
          VRLogfilePrintWithTimestamp(v26, "%f\t%llu\t%u\t%u\t%llu\t%llu\t%u\t%u\t%u\t%llu\t%u\t%d\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%2.4f\t%d\n", *(unsigned __int16 *)(a2 + 92), *(unsigned __int8 *)(a2 + 94), *(unsigned __int8 *)(a2 + 97), *(unsigned __int8 *)(a2 + 96), *(unsigned __int8 *)(a2 + 99), *(unsigned __int8 *)(a2 + 98), *(_QWORD *)(a2 + 8));
        ++*(_DWORD *)(a1 + 1784);
        return;
      }
      v4 = *(_DWORD *)(a2 + 120) + *(_DWORD *)(a2 + 124);
      *(_DWORD *)(a1 + 1108) = v4;
      v5 = *(_DWORD *)(a1 + 1104);
      v6 = v4 >= v5;
      v7 = v4 - v5;
      if (v7 == 0 || !v6 || v5 == 0)
        v7 = 0;
      *(_DWORD *)(a1 + 1112) = v7;
      if (!*(_BYTE *)(a1 + 1324))
      {
        v22 = *(float *)(a2 + 104);
        v23 = *(void **)(a1 + 1776);
        if (v23)
        {
          objc_msgSend(v23, "config");
          v24 = v40;
        }
        else
        {
          bzero(buf, 0x3D0uLL);
          v24 = 0.0;
        }
        if (v24 < v22)
        {
          v25 = 1;
LABEL_42:
          *(_BYTE *)(a1 + 1324) = v25;
          goto LABEL_43;
        }
        if (!*(_BYTE *)(a1 + 1324))
          goto LABEL_43;
      }
      v9 = *(float *)(a2 + 104);
      v10 = *(void **)(a1 + 1776);
      if (v10)
      {
        objc_msgSend(v10, "config");
        v11 = v27;
      }
      else
      {
        v11 = 0.0;
      }
      if (v11 <= v9)
        goto LABEL_43;
      v25 = 0;
      goto LABEL_42;
    }
    if (objc_opt_class() == a1)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _AVCRateController_DoRateControlWithNWConnectionStatistics_cold_2();
      }
    }
    else
    {
      if ((objc_opt_respondsToSelector() & 1) != 0)
        v13 = (const __CFString *)objc_msgSend((id)a1, "performSelector:", sel_logPrefix);
      else
        v13 = &stru_1E9E58EE0;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v19 = VRTraceErrorLogLevelToCSTR();
        v20 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v21 = *(_DWORD *)a2;
          *(_DWORD *)buf = 136316418;
          v29 = v19;
          v30 = 2080;
          v31 = "_AVCRateController_DoRateControlWithNWConnectionStatistics";
          v32 = 1024;
          v33 = 2556;
          v34 = 2112;
          v35 = v13;
          v36 = 2048;
          v37 = a1;
          v38 = 1024;
          v39 = v21;
          v16 = "AVCRC [%s] %s:%d %@(%p) Wrong statistics type=%d";
          v17 = v20;
          v18 = 54;
          goto LABEL_33;
        }
      }
    }
  }
  else if (objc_opt_class() == a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _AVCRateController_DoRateControlWithNWConnectionStatistics_cold_1();
    }
  }
  else
  {
    if ((objc_opt_respondsToSelector() & 1) != 0)
      v12 = (const __CFString *)objc_msgSend((id)a1, "performSelector:", sel_logPrefix);
    else
      v12 = &stru_1E9E58EE0;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v14 = VRTraceErrorLogLevelToCSTR();
      v15 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136316162;
        v29 = v14;
        v30 = 2080;
        v31 = "_AVCRateController_DoRateControlWithNWConnectionStatistics";
        v32 = 1024;
        v33 = 2552;
        v34 = 2112;
        v35 = v12;
        v36 = 2048;
        v37 = a1;
        v16 = "AVCRC [%s] %s:%d %@(%p) Not using nwConnectionNotification";
        v17 = v15;
        v18 = 48;
LABEL_33:
        _os_log_error_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_ERROR, v16, buf, v18);
      }
    }
  }
}

BOOL _AVCRateController_DoRateControl(uint64_t a1, uint64_t a2)
{
  int v4;
  const __CFString *v5;
  _BOOL8 result;
  __int128 v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  BOOL v12;
  __int128 *v13;
  uint64_t v14;
  int v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  NSObject *v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  double v33;
  uint64_t v34;
  double v35;
  uint64_t v36;
  uint8_t buf[4];
  _BYTE v38[20];
  __int128 v39;
  _BYTE v40[32];
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  uint64_t v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    *(double *)(a1 + 1640) = micro();
    *(_QWORD *)(a1 + 1648) = *(_QWORD *)(a2 + 8);
    *(_BYTE *)(a1 + 1632) = objc_msgSend(*(id *)(a1 + 1776), "isFirstInitialRampUpDone");
    v4 = *(_DWORD *)a2;
    if (*(int *)a2 > 10)
    {
      if (v4 == 11)
      {
        *(_QWORD *)(a1 + 1672) = *(_QWORD *)(a2 + 32);
        *(_BYTE *)(a1 + 1680) = *(_BYTE *)(a2 + 88);
        *(_BYTE *)(a1 + 1681) = *(_BYTE *)(a2 + 89);
        *(_WORD *)(a1 + 1682) = *(_WORD *)(a2 + 90);
        *(_WORD *)(a1 + 1684) = *(_WORD *)(a2 + 92);
        *(_BYTE *)(a1 + 1686) = *(_BYTE *)(a2 + 94);
        *(_BYTE *)(a1 + 1687) = *(_BYTE *)(a2 + 95);
        *(_BYTE *)(a1 + 1688) = *(_BYTE *)(a2 + 96);
        *(_BYTE *)(a1 + 1689) = *(_BYTE *)(a2 + 97);
        *(_BYTE *)(a1 + 1690) = *(_BYTE *)(a2 + 98);
        *(_BYTE *)(a1 + 1691) = *(_BYTE *)(a2 + 99);
        *(_BYTE *)(a1 + 1692) = *(_BYTE *)(a2 + 100);
        *(_DWORD *)(a1 + 1696) = *(_DWORD *)(a2 + 104);
        *(_WORD *)(a1 + 1700) = *(_WORD *)(a2 + 110);
        v7 = *(_OWORD *)(a2 + 112);
        *(_QWORD *)(a1 + 1720) = *(_QWORD *)(a2 + 128);
        *(_OWORD *)(a1 + 1704) = v7;
      }
      else if (v4 == 14)
      {
        *(_DWORD *)(a1 + 1672) = *(_DWORD *)(a2 + 40);
      }
    }
    else if (v4 == 1)
    {
      *(_DWORD *)(a1 + 1672) = *(_DWORD *)(a2 + 160);
      *(_DWORD *)(a1 + 1676) = *(_DWORD *)(a2 + 24);
      *(_DWORD *)(a1 + 1680) = *(_DWORD *)(a2 + 28);
      *(_DWORD *)(a1 + 1684) = *(_DWORD *)(a2 + 36);
      *(_DWORD *)(a1 + 1688) = *(_DWORD *)(a2 + 40);
      *(_DWORD *)(a1 + 1692) = *(_DWORD *)(a2 + 44);
      *(_DWORD *)(a1 + 1696) = *(_DWORD *)(a2 + 32);
      *(_QWORD *)(a1 + 1704) = *(_QWORD *)(a2 + 56);
      *(_QWORD *)(a1 + 1712) = *(_QWORD *)(a2 + 64);
      *(_QWORD *)(a1 + 1720) = *(_QWORD *)(a2 + 72);
      *(_QWORD *)(a1 + 1728) = *(_QWORD *)(a2 + 80);
      *(_QWORD *)(a1 + 1736) = *(_QWORD *)(a2 + 88);
    }
    else if (v4 == 2)
    {
      *(_QWORD *)(a1 + 1680) = *(_QWORD *)(a2 + 80);
      *(_DWORD *)(a1 + 1760) = *(_DWORD *)(a2 + 32);
    }
    v8 = *(_QWORD *)(a1 + 56);
    if (v8)
      v9 = VCRateControlMediaController_BasebandFlushCount(v8);
    else
      v9 = 0;
    v10 = VCRateControlAlgorithm_DoRateControl(*(_QWORD *)(a1 + 1776), a2);
    v11 = *(_QWORD *)(a1 + 56);
    if (v11)
      v12 = (int)VCRateControlMediaController_BasebandFlushCount(v11) > v9;
    else
      v12 = 0;
    v13 = (__int128 *)(a1 + 1632);
    *(_BYTE *)(a1 + 1624) = v12;
    if (!v10)
    {
      result = 0;
      *(_QWORD *)(a1 + 1760) = 0;
      *(_OWORD *)(a1 + 1728) = 0u;
      *(_OWORD *)(a1 + 1744) = 0u;
      *(_OWORD *)(a1 + 1696) = 0u;
      *(_OWORD *)(a1 + 1712) = 0u;
      *(_OWORD *)(a1 + 1664) = 0u;
      *(_OWORD *)(a1 + 1680) = 0u;
      *v13 = 0u;
      *(_OWORD *)(a1 + 1648) = 0u;
      return result;
    }
    v35 = NAN;
    v36 = -1;
    v33 = NAN;
    v34 = -1;
    v14 = *(_QWORD *)(a1 + 56);
    if (v14)
    {
      VCRateControlMediaController_MediaQueueSettings(v14, (double *)&v36, &v35, (double *)&v34, &v33);
      *(_DWORD *)(a1 + 1660) = (v33 + v35);
      *(_BYTE *)(a1 + 1664) = *(_BYTE *)(a1 + 1624);
    }
    *(_DWORD *)(a1 + 1656) = objc_msgSend(*(id *)(a1 + 1776), "targetBitrate", *(_QWORD *)&v33, v34);
    v15 = *(_DWORD *)a2;
    if (*(int *)a2 > 10)
    {
      if (v15 == 11)
      {
        v15 = 2;
        goto LABEL_41;
      }
      if (v15 == 14)
      {
        *(_DWORD *)(a1 + 1676) = objc_msgSend(*(id *)(a1 + 1776), "bytesInFlight");
        v15 = 3;
        goto LABEL_41;
      }
    }
    else
    {
      if (v15 == 1)
      {
LABEL_41:
        v29 = *(_OWORD *)(a1 + 1696);
        v42 = *(_OWORD *)(a1 + 1712);
        v30 = *(_OWORD *)(a1 + 1744);
        v43 = *(_OWORD *)(a1 + 1728);
        v44 = v30;
        v31 = *v13;
        v39 = *(_OWORD *)(a1 + 1648);
        v32 = *(_OWORD *)(a1 + 1680);
        *(_OWORD *)v40 = *(_OWORD *)(a1 + 1664);
        *(_OWORD *)&v40[16] = v32;
        v41 = v29;
        v45 = *(_QWORD *)(a1 + 1760);
        *(_OWORD *)&v38[4] = v31;
        *(_DWORD *)buf = v15;
        *(_DWORD *)v38 = -1431655766;
        VCReporting_DumpIntoDataStore();
        return 1;
      }
      if (v15 == 2)
      {
        v16 = *(void **)(a1 + 1776);
        objc_msgSend(v16, "rateControlTime");
        *(_QWORD *)(a1 + 1672) = v17;
        objc_msgSend(v16, "nowrd");
        *(_QWORD *)(a1 + 1688) = v18;
        objc_msgSend(v16, "nowrdAcc");
        *(_QWORD *)(a1 + 1696) = v19;
        objc_msgSend(v16, "mostRecentRoundTripTime");
        *(_QWORD *)(a1 + 1704) = v20;
        objc_msgSend(v16, "roundTripTimeMinEnvelope");
        *(_QWORD *)(a1 + 1720) = v21;
        objc_msgSend(v16, "packetLossRate");
        *(_QWORD *)(a1 + 1728) = v22;
        objc_msgSend(v16, "packetLossRateAudio");
        *(_QWORD *)(a1 + 1736) = v23;
        objc_msgSend(v16, "packetLossRateVideo");
        *(_QWORD *)(a1 + 1744) = v24;
        objc_msgSend(v16, "roundTripTime");
        *(_QWORD *)(a1 + 1712) = v25;
        objc_msgSend(v16, "ecnCERatio");
        v15 = 0;
        *(_QWORD *)(a1 + 1752) = v26;
        goto LABEL_41;
      }
    }
    *(_QWORD *)(a1 + 1760) = 0;
    *(_OWORD *)(a1 + 1728) = 0u;
    *(_OWORD *)(a1 + 1744) = 0u;
    *(_OWORD *)(a1 + 1696) = 0u;
    *(_OWORD *)(a1 + 1712) = 0u;
    *(_OWORD *)(a1 + 1664) = 0u;
    *(_OWORD *)(a1 + 1680) = 0u;
    *v13 = 0u;
    *(_OWORD *)(a1 + 1648) = 0u;
    return 1;
  }
  if (objc_opt_class() == a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      _AVCRateController_DoRateControl_cold_1();
    }
  }
  else
  {
    if ((objc_opt_respondsToSelector() & 1) != 0)
      v5 = (const __CFString *)objc_msgSend((id)a1, "performSelector:", sel_logPrefix);
    else
      v5 = &stru_1E9E58EE0;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v27 = VRTraceErrorLogLevelToCSTR();
      v28 = *MEMORY[0x1E0CF2758];
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      *(_DWORD *)buf = 136316418;
      *(_QWORD *)v38 = v27;
      *(_WORD *)&v38[8] = 2080;
      *(_QWORD *)&v38[10] = "_AVCRateController_DoRateControl";
      *(_WORD *)&v38[18] = 1024;
      LODWORD(v39) = 2582;
      WORD2(v39) = 2112;
      *(_QWORD *)((char *)&v39 + 6) = v5;
      HIWORD(v39) = 2048;
      *(_QWORD *)v40 = a1;
      *(_WORD *)&v40[8] = 2048;
      *(_QWORD *)&v40[10] = 0;
      _os_log_error_impl(&dword_1D8A54000, v28, OS_LOG_TYPE_ERROR, "AVCRC [%s] %s:%d %@(%p) Invalid statistics=%p", buf, 0x3Au);
    }
  }
  return 0;
}

void _AVCRateController_ReportInitialRampUpDeltas(uint64_t a1)
{
  double v2;
  int v3;
  uint64_t v4;
  NSObject *v5;
  int v6;
  int v7;
  uint64_t v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  uint64_t v14;
  __int16 v15;
  int v16;
  __int16 v17;
  double v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if ((*(_DWORD *)(a1 + 64) - 1) <= 2 && !*(_BYTE *)(a1 + 1136))
  {
    if (objc_msgSend(*(id *)(a1 + 1776), "isFirstInitialRampUpDone"))
    {
      v2 = micro() - *(double *)(a1 + 1128);
      v3 = objc_msgSend(*(id *)(a1 + 1776), "targetBitrate") - *(_DWORD *)(a1 + 1116);
      reportingAdaptiveLearningStats();
      *(_BYTE *)(a1 + 1136) = 1;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v4 = VRTraceErrorLogLevelToCSTR();
        v5 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v6 = *(_DWORD *)(a1 + 1116);
          v7 = 136316674;
          v8 = v4;
          v9 = 2080;
          v10 = "_AVCRateController_ReportInitialRampUpDeltas";
          v11 = 1024;
          v12 = 2627;
          v13 = 2048;
          v14 = a1;
          v15 = 1024;
          v16 = v3;
          v17 = 2048;
          v18 = v2;
          v19 = 1024;
          v20 = v6;
          _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, "AVCRC [%s] %s:%d (%p) Report initial ramp up done with bitrateDelta:%d, timeDelta:%f, initialBitrate:%d", (uint8_t *)&v7, 0x3Cu);
        }
      }
    }
  }
}

uint64_t _AVCRateControlFeedbackController_ProcessRateControlFeedbackMessage(uint64_t a1, uint64_t a2, int a3, double a4)
{
  int v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 v13;
  int v14;
  unsigned int v15;
  uint64_t v16;
  NSObject *v17;
  int v18;
  int v19;
  unint64_t v20;
  int v21;
  _OWORD v23[13];
  uint8_t buf[4];
  uint64_t v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  int v31;
  __int16 v32;
  uint64_t v33;
  __int16 v34;
  uint64_t v35;
  __int16 v36;
  int v37;
  __int16 v38;
  const char *v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  *(double *)(a1 + 72) = a4;
  memset(v23, 0, 200);
  v5 = *(_DWORD *)(a1 + 24) + 1;
  *(_DWORD *)(a1 + 24) = v5;
  if (a3 != 3)
  {
    if (a3 != 1)
      return 0;
    v6 = *(_OWORD *)(a2 + 96);
    *(_OWORD *)((char *)&v23[8] + 8) = *(_OWORD *)(a2 + 112);
    v7 = *(_OWORD *)(a2 + 144);
    *(_OWORD *)((char *)&v23[9] + 8) = *(_OWORD *)(a2 + 128);
    *(_OWORD *)((char *)&v23[10] + 8) = v7;
    *(_OWORD *)((char *)&v23[11] + 8) = *(_OWORD *)(a2 + 160);
    v8 = *(_OWORD *)(a2 + 32);
    *(_OWORD *)((char *)&v23[4] + 8) = *(_OWORD *)(a2 + 48);
    v9 = *(_OWORD *)(a2 + 80);
    *(_OWORD *)((char *)&v23[5] + 8) = *(_OWORD *)(a2 + 64);
    *(_OWORD *)((char *)&v23[6] + 8) = v9;
    *(_OWORD *)((char *)&v23[7] + 8) = v6;
    v10 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)((char *)&v23[1] + 8) = *(_OWORD *)a2;
    *(_OWORD *)((char *)&v23[2] + 8) = v10;
    LODWORD(v23[0]) = 2;
    BYTE2(v23[1]) = 1;
    *((double *)v23 + 1) = a4;
    *(_OWORD *)((char *)&v23[3] + 8) = v8;
    v11 = *(unsigned int *)(a1 + 52);
    v12 = *(unsigned int *)(a1 + 40);
    if (BYTE1(v23[12]))
      v13 = 2;
    else
      v13 = 1;
    v14 = *(unsigned __int8 *)(a1 + 89);
    if (v14 == 4 || v14 == v13)
    {
      if (v11 > *(_DWORD *)(a1 + 56) && *(_BYTE *)(a1 + 90))
      {
        if (*(_DWORD *)(a1 + 44) == (_DWORD)v12)
        {
          if (a4 - *(double *)(a1 + 80) >= 1800.0)
          {
            *(_BYTE *)(a1 + 64) = 0;
          }
          else
          {
            v15 = ++*(_BYTE *)(a1 + 64);
            if (v15 >= 0x64)
            {
              *(_BYTE *)(a1 + 90) = 0;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v16 = VRTraceErrorLogLevelToCSTR();
                v17 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                {
                  v18 = *(unsigned __int8 *)(a1 + 90);
                  v19 = *(unsigned __int8 *)(a1 + 64);
                  *(_DWORD *)buf = 136317186;
                  v25 = v16;
                  v26 = 2080;
                  v27 = "_AVCRateControlFeedbackController_VerifyECNStatus";
                  v28 = 1024;
                  v29 = 396;
                  v30 = 1024;
                  v31 = v18;
                  v32 = 2048;
                  v33 = v12;
                  v34 = 2048;
                  v35 = v11;
                  v36 = 1024;
                  v37 = v19;
                  v38 = 2080;
                  v39 = "YES";
                  v40 = 2048;
                  v41 = a1;
                  _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Set isECNEnabled=%d with totalECT1Count=%ld, totalReceivedPackets=%ld, numBadECNEvents=%d, isECNBleached=%s for controller [%p]", buf, 0x50u);
                }
              }
            }
          }
          *(_QWORD *)(a1 + 80) = *(_QWORD *)(a1 + 72);
          LODWORD(v11) = *(_DWORD *)(a1 + 52);
        }
        else
        {
          *(_DWORD *)(a1 + 44) = v12;
        }
      }
      *(_DWORD *)(a1 + 56) = v11;
      LOBYTE(v23[12]) = *(_BYTE *)(a1 + 90);
    }
    goto LABEL_23;
  }
  HIDWORD(v20) = -858993459 * v5;
  LODWORD(v20) = -858993459 * v5;
  if ((v20 >> 1) <= 0x19999999)
  {
    LODWORD(v23[0]) = 5;
    *((double *)v23 + 1) = a4;
    v21 = *(_DWORD *)(a2 + 28);
    HIDWORD(v23[1]) = *(_DWORD *)a2;
    DWORD1(v23[2]) = v21;
LABEL_23:
    AVCStatisticsCollector_SetVCStatistics(*(_QWORD *)(a1 + 16), (uint64_t)v23);
  }
  return 1;
}

void VCRateControlFeedbackController_SetMode(uint64_t a1, int a2)
{
  if (a1)
  {
    *(_DWORD *)(a1 + 8) = a2;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlFeedbackController_SetMode_cold_1();
  }
}

void VCRateControlFeedbackController_UpdateTxLinkType(unsigned __int8 *a1, int a2)
{
  int v4;
  int v5;
  BOOL v7;
  uint64_t v8;
  NSObject *v9;
  int v10;
  int v11;
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  unsigned __int8 *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a1[88] != a2)
    {
      _AVCRateControlFeedbackController_SetTxLink((uint64_t)a1, a2, 0);
      v4 = a1[90];
      v5 = a1[89];
      v7 = v5 == 4 || v5 == a2;
      a1[90] = v7;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v8 = VRTraceErrorLogLevelToCSTR();
        v9 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v10 = a1[90];
          v11 = 136316418;
          v12 = v8;
          v13 = 2080;
          v14 = "_AVCRateControlFeedbackController_SetECNEnabled";
          v15 = 1024;
          v16 = 373;
          v17 = 2048;
          v18 = a1;
          v19 = 1024;
          v20 = v4;
          v21 = 1024;
          v22 = v10;
          _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d [%p] _isECNEnabled changed from=%d to=%d", (uint8_t *)&v11, 0x32u);
        }
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlFeedbackController_UpdateTxLinkType_cold_1();
  }
}

void _AVCRateControlFeedbackController_SetTxLink(uint64_t a1, char a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  uint64_t v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  __int16 v23;
  int v24;
  __int16 v25;
  int v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  *(_BYTE *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  v5 = 88;
  if (a3)
    v5 = 89;
  *(_BYTE *)(a1 + v5) = a2;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v6 = VRTraceErrorLogLevelToCSTR();
    v7 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v8 = *(unsigned __int8 *)(a1 + 88);
      v9 = *(unsigned __int8 *)(a1 + 89);
      v10 = *(unsigned __int8 *)(a1 + 90);
      v11 = 136316930;
      v12 = v6;
      v13 = 2080;
      v14 = "_AVCRateControlFeedbackController_SetTxLink";
      v15 = 1024;
      v16 = 366;
      v17 = 2048;
      v18 = a1;
      v19 = 1024;
      v20 = v8;
      v21 = 1024;
      v22 = v9;
      v23 = 1024;
      v24 = v10;
      v25 = 1024;
      v26 = a3;
      _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d [%p] _txLinkType changed to=%d ecnLinkType=%d with isECNEnabled=%d, isECNLinkType=%d", (uint8_t *)&v11, 0x3Eu);
    }
  }
}

void VCRateControlFeedbackController_SetLinkTypeToSupportECN(uint64_t a1, char a2)
{
  char v4;

  if (a1)
  {
    if (VCDefaults_GetBoolValueForKey(CFSTR("ecnEnabled"), 0))
      v4 = 4;
    else
      v4 = a2;
    _AVCRateControlFeedbackController_SetTxLink(a1, v4, 1);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlFeedbackController_SetLinkTypeToSupportECN_cold_1();
  }
}

uint64_t VCRateControlProcessFeedbackControlInfo(uint64_t result, void *a2)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  int v6;
  unint64_t v7;
  uint64_t v8;
  NSObject *v9;
  _BOOL4 v10;
  int v11;
  int v12;
  int v13;
  double v14;
  char v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  _OWORD buf[3];
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  if (!result)
    return result;
  v25 = 0u;
  v26 = 0u;
  v24 = 0u;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  if (!a2)
    return 0;
  v3 = result;
  if (VCMediaControlInfoHasInfo(a2, 0))
  {
    memset(buf, 0, 40);
    VCMediaControlInfoGetInfoUnserialized(a2, (const char *)buf, 0);
    DWORD2(v16) = WORD1(buf[0]);
    HIDWORD(v18) = LOWORD(buf[0]);
    HIDWORD(v17) = WORD5(buf[0]);
    LODWORD(v18) = WORD3(buf[0]);
    LODWORD(v17) = WORD2(buf[0]);
    DWORD1(v17) = WORD4(buf[0]);
    DWORD2(v21) = buf[1];
    LODWORD(v26) = DWORD1(buf[2]);
  }
  if (VCMediaControlInfoHasInfo(a2, (const char *)1))
  {
    memset(buf, 0, 40);
    VCMediaControlInfoGetInfoUnserialized(a2, (const char *)buf, 1);
    LODWORD(v16) = WORD4(buf[1]);
    DWORD1(v16) = DWORD1(buf[1]);
    *((_QWORD *)&v19 + 1) = RTPUnpackDouble(HIDWORD(buf[1]));
  }
  VCMediaControlInfoGetInfo(a2, (const char *)0x11, (uint64_t)&v19, 4, 0);
  if (*(_BYTE *)(v3 + 36))
  {
    if ((v19 - *(_DWORD *)(v3 + 28)) <= 0x7FFFFFFE)
    {
      v4 = 0;
      *(_DWORD *)(v3 + 28) = v19;
      v5 = 32;
      goto LABEL_11;
    }
    v6 = *(_DWORD *)(v3 + 32);
    *(_DWORD *)(v3 + 32) = v6 + 1;
    HIDWORD(v7) = -858993459 * v6;
    LODWORD(v7) = -858993459 * v6;
    if ((v7 >> 2) <= 0xCCCCCCC && (int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v8 = VRTraceErrorLogLevelToCSTR();
      v9 = *MEMORY[0x1E0CF2758];
      v10 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
      result = 0;
      if (!v10)
        return result;
      v11 = *(_DWORD *)(v3 + 28);
      LODWORD(buf[0]) = 136316162;
      *(_QWORD *)((char *)buf + 4) = v8;
      WORD6(buf[0]) = 2080;
      *(_QWORD *)((char *)buf + 14) = "_AVCRateControlFeedbackController_DetectOutOfOrderFeedbackMessage";
      WORD3(buf[1]) = 1024;
      DWORD2(buf[1]) = 597;
      WORD6(buf[1]) = 1024;
      *(_DWORD *)((char *)&buf[1] + 14) = v19;
      WORD1(buf[2]) = 1024;
      DWORD1(buf[2]) = v11;
      _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Out of order feedback message detected with timestamp=%u, controller mediaTimestamp=%u", (uint8_t *)buf, 0x28u);
    }
    return 0;
  }
  *(_BYTE *)(v3 + 36) = 1;
  v4 = v19;
  v5 = 28;
LABEL_11:
  *(_DWORD *)(v3 + v5) = v4;
  LOBYTE(buf[0]) = 0;
  if (!VCMediaControlInfoGetInfo(a2, (const char *)0x12, (uint64_t)buf, 1, 0))
  {
    if (LOBYTE(buf[0]) == 3)
    {
      ++*(_DWORD *)(v3 + 48);
LABEL_20:
      ++*(_DWORD *)(v3 + 40);
      goto LABEL_21;
    }
    if ((buf[0] & 1) != 0)
      goto LABEL_20;
  }
LABEL_21:
  WORD2(v26) = *(_DWORD *)(v3 + 40);
  WORD3(v26) = *(_DWORD *)(v3 + 48);
  v12 = *(_DWORD *)(v3 + 8);
  if ((v12 - 1) <= 2)
  {
    *(_QWORD *)&v28 = 0;
    memset(buf, 0, sizeof(buf));
    DWORD1(buf[0]) = v19;
    VCMediaControlInfoGetInfo(a2, (const char *)0xA, (uint64_t)&buf[1] + 8, 8, 0);
    VCMediaControlInfoGetInfo(a2, (const char *)0xC, (uint64_t)&buf[1], 4, 0);
    VCMediaControlInfoGetInfo(a2, (const char *)0xB, (unint64_t)buf | 0xC, 4, 0);
    VCMediaControlInfoGetInfo(a2, (const char *)0xD, (uint64_t)&v25 + 8, 2, 0);
    VCMediaControlInfoGetInfo(a2, (const char *)0xE, (uint64_t)&v25 + 10, 1, 0);
    VCMediaControlInfoGetInfo(a2, (const char *)0xF, (uint64_t)&v25 + 11, 1, 0);
    if (VCMediaControlInfoHasInfo(a2, (const char *)2))
      VCMediaControlInfoGetInfo(a2, (const char *)2, (uint64_t)&v25 + 12, 4, 0);
    if (VCMediaControlInfoHasInfo(a2, (const char *)0x15))
    {
      v15 = 0;
      VCMediaControlInfoGetInfo(a2, (const char *)0x15, (uint64_t)&v15, 1, 0);
      BYTE9(v26) = v15;
    }
    LODWORD(buf[0]) = 3;
    BYTE12(v21) = 1;
    v24 = buf[2];
    *(_QWORD *)&v25 = v28;
    v22 = buf[0];
    v23 = buf[1];
    *(_DWORD *)(v3 + 52) = HIDWORD(buf[0]);
  }
  if ((v12 & 0xFFFFFFFE) == 4)
    v13 = 3;
  else
    v13 = 1;
  v14 = micro();
  v33 = v24;
  v34 = v25;
  v35 = v26;
  v29 = v20;
  v30 = v21;
  v31 = v22;
  v32 = v23;
  buf[0] = v16;
  buf[1] = v17;
  buf[2] = v18;
  v28 = v19;
  _AVCRateControlFeedbackController_ProcessRateControlFeedbackMessage(v3, (uint64_t)buf, v13, v14);
  return 1;
}

uint64_t VCRateControlProcessProbingControlInfo(_DWORD *a1, void *a2, char a3)
{
  BOOL v3;
  uint64_t v4;
  int v8;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (a1)
    v3 = a2 == 0;
  else
    v3 = 1;
  v4 = !v3;
  if (!v3)
  {
    v21 = 0;
    v19 = 0u;
    v20 = 0u;
    v17 = 0u;
    v18 = 0u;
    v16 = 0u;
    VCMediaControlInfoGetInfo(a2, (const char *)0x10, (unint64_t)&v16 | 0xC, 4, 0);
    VCMediaControlInfoGetInfo(a2, (const char *)0xA, (uint64_t)&v17, 8, 0);
    VCMediaControlInfoGetInfo(a2, (const char *)0x11, (uint64_t)&v17 + 8, 4, 0);
    if ((a3 & 1) == 0)
    {
      VCMediaControlInfoGetInfo(a2, (const char *)8, (uint64_t)&v16 + 8, 4, 0);
      v8 = DWORD2(v16);
      DWORD2(v16) = bswap32(DWORD2(v16));
      BYTE5(v16) = v8 != 0;
      if (objc_msgSend(a1, "mode") == 1
        || objc_msgSend(a1, "mode") == 2
        || objc_msgSend(a1, "mode") == 3)
      {
        *(_QWORD *)&v13 = 0;
        v11 = 0u;
        v12 = 0u;
        v10 = 0u;
        VCMediaControlInfoGetInfo(a2, (const char *)0xB, (unint64_t)&v10 | 0xC, 4, 0);
        VCMediaControlInfoGetInfo(a2, (const char *)0xC, (uint64_t)&v11, 4, 0);
        LODWORD(v10) = 4;
        BYTE12(v17) = 1;
        v19 = v11;
        v20 = v12;
        v21 = v13;
        v18 = v10;
        a1[15] = HIDWORD(v10);
      }
    }
    v12 = v18;
    v13 = v19;
    v14 = v20;
    v15 = v21;
    v10 = v16;
    v11 = v17;
    objc_msgSend(a1, "processRateControlProbingMessage:type:error:", &v10, 2, 0);
  }
  return v4;
}

uint64_t VCRateControlSetFeedbackControlInfo(void *a1, void *a2)
{
  BOOL v2;
  uint64_t v3;
  int v7;
  _WORD v8[6];
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  _OWORD v14[2];
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (a1)
    v2 = a2 == 0;
  else
    v2 = 1;
  v3 = !v2;
  if (!v2)
  {
    v25 = 0;
    v23 = 0u;
    v24 = 0u;
    v21 = 0u;
    v22 = 0u;
    v19 = 0u;
    v20 = 0u;
    v17 = 0u;
    v18 = 0u;
    v15 = 0u;
    v16 = 0u;
    memset(v14, 0, sizeof(v14));
    objc_msgSend(a1, "getVCStatisticsFeedbackMessage:time:", v14, micro());
    v8[0] = WORD2(v17);
    v8[1] = v15;
    v8[2] = WORD4(v15);
    v8[4] = WORD6(v15);
    v8[5] = WORD2(v16);
    v8[3] = WORD4(v16);
    v12 = 0;
    v11 = 0;
    v9 = HIDWORD(v16);
    v10 = v20;
    v13 = HIDWORD(v24);
    v7 = objc_msgSend(a1, "getConnectionStatsBlob");
    if (v7)
      VCMediaControlInfoSetInfo(a2, (const char *)2, (uint64_t)&v7, 4);
    objc_msgSend(a1, "resetBurstyLossStatistics");
    VCMediaControlInfoSetInfoUnserialized(a2, (const char *)v8, 0);
  }
  return v3;
}

uint64_t VCMediaNegotiationBlobV2VideoPayloadReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  int v15;
  char v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char v22;
  uint64_t result;
  char v24;
  unsigned int v25;
  uint64_t v26;
  unint64_t v27;
  char v28;
  char v29;
  unsigned int v30;
  uint64_t v31;
  unint64_t v32;
  char v33;
  char v34;
  unsigned int v35;
  uint64_t v36;
  unint64_t v37;
  char v38;
  void *Data;
  char v40;
  unsigned int v41;
  uint64_t v42;
  unint64_t v43;
  char v44;
  uint64_t v45;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        v14 = v9++ >= 9;
        if (v14)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      switch((v10 >> 3))
      {
        case 1u:
          v17 = 0;
          v18 = 0;
          v19 = 0;
          *(_BYTE *)(a1 + 40) |= 0x10u;
          while (1)
          {
            v20 = *v3;
            v21 = *(_QWORD *)(a2 + v20);
            if (v21 == -1 || v21 >= *(_QWORD *)(a2 + *v4))
              break;
            v22 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v21);
            *(_QWORD *)(a2 + v20) = v21 + 1;
            v19 |= (unint64_t)(v22 & 0x7F) << v17;
            if ((v22 & 0x80) == 0)
              goto LABEL_58;
            v17 += 7;
            v14 = v18++ >= 9;
            if (v14)
            {
              LODWORD(v19) = 0;
              goto LABEL_60;
            }
          }
          *(_BYTE *)(a2 + *v5) = 1;
LABEL_58:
          if (*(_BYTE *)(a2 + *v5))
            LODWORD(v19) = 0;
LABEL_60:
          v45 = 36;
          goto LABEL_77;
        case 2u:
          v24 = 0;
          v25 = 0;
          v19 = 0;
          *(_BYTE *)(a1 + 40) |= 4u;
          while (2)
          {
            v26 = *v3;
            v27 = *(_QWORD *)(a2 + v26);
            if (v27 == -1 || v27 >= *(_QWORD *)(a2 + *v4))
            {
              *(_BYTE *)(a2 + *v5) = 1;
            }
            else
            {
              v28 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v27);
              *(_QWORD *)(a2 + v26) = v27 + 1;
              v19 |= (unint64_t)(v28 & 0x7F) << v24;
              if (v28 < 0)
              {
                v24 += 7;
                v14 = v25++ >= 9;
                if (v14)
                {
                  LODWORD(v19) = 0;
                  goto LABEL_64;
                }
                continue;
              }
            }
            break;
          }
          if (*(_BYTE *)(a2 + *v5))
            LODWORD(v19) = 0;
LABEL_64:
          v45 = 28;
          goto LABEL_77;
        case 3u:
          v29 = 0;
          v30 = 0;
          v19 = 0;
          *(_BYTE *)(a1 + 40) |= 2u;
          while (2)
          {
            v31 = *v3;
            v32 = *(_QWORD *)(a2 + v31);
            if (v32 == -1 || v32 >= *(_QWORD *)(a2 + *v4))
            {
              *(_BYTE *)(a2 + *v5) = 1;
            }
            else
            {
              v33 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v32);
              *(_QWORD *)(a2 + v31) = v32 + 1;
              v19 |= (unint64_t)(v33 & 0x7F) << v29;
              if (v33 < 0)
              {
                v29 += 7;
                v14 = v30++ >= 9;
                if (v14)
                {
                  LODWORD(v19) = 0;
                  goto LABEL_68;
                }
                continue;
              }
            }
            break;
          }
          if (*(_BYTE *)(a2 + *v5))
            LODWORD(v19) = 0;
LABEL_68:
          v45 = 24;
          goto LABEL_77;
        case 4u:
          v34 = 0;
          v35 = 0;
          v19 = 0;
          *(_BYTE *)(a1 + 40) |= 1u;
          while (2)
          {
            v36 = *v3;
            v37 = *(_QWORD *)(a2 + v36);
            if (v37 == -1 || v37 >= *(_QWORD *)(a2 + *v4))
            {
              *(_BYTE *)(a2 + *v5) = 1;
            }
            else
            {
              v38 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v37);
              *(_QWORD *)(a2 + v36) = v37 + 1;
              v19 |= (unint64_t)(v38 & 0x7F) << v34;
              if (v38 < 0)
              {
                v34 += 7;
                v14 = v35++ >= 9;
                if (v14)
                {
                  LODWORD(v19) = 0;
                  goto LABEL_72;
                }
                continue;
              }
            }
            break;
          }
          if (*(_BYTE *)(a2 + *v5))
            LODWORD(v19) = 0;
LABEL_72:
          v45 = 8;
          goto LABEL_77;
        case 5u:
          Data = (void *)PBReaderReadData();

          *(_QWORD *)(a1 + 16) = Data;
          continue;
        case 6u:
          v40 = 0;
          v41 = 0;
          v19 = 0;
          *(_BYTE *)(a1 + 40) |= 8u;
          break;
        default:
          result = PBReaderSkipValueWithTag();
          if (!(_DWORD)result)
            return result;
          continue;
      }
      while (1)
      {
        v42 = *v3;
        v43 = *(_QWORD *)(a2 + v42);
        if (v43 == -1 || v43 >= *(_QWORD *)(a2 + *v4))
          break;
        v44 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v43);
        *(_QWORD *)(a2 + v42) = v43 + 1;
        v19 |= (unint64_t)(v44 & 0x7F) << v40;
        if ((v44 & 0x80) == 0)
          goto LABEL_74;
        v40 += 7;
        v14 = v41++ >= 9;
        if (v14)
        {
          LODWORD(v19) = 0;
          goto LABEL_76;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_74:
      if (*(_BYTE *)(a2 + *v5))
        LODWORD(v19) = 0;
LABEL_76:
      v45 = 32;
LABEL_77:
      *(_DWORD *)(a1 + v45) = v19;
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

BOOL VCVideoHardwareDumpWriter_OpenDumpFile(uint64_t a1)
{
  FILE **v2;

  v2 = VRLogfileAlloc(0, 0, (uint64_t)"VCVideoHardwareTests_DumpFile", 0, "com.apple.AVConference.VCVideoHardwareDumpWriter", 44);
  *(_QWORD *)(a1 + 8) = v2;
  if (!v2 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCVideoHardwareDumpWriter_OpenDumpFile_cold_1();
  }
  return v2 != 0;
}

void VCVideoHardwareDumpWriter_CloseDumpFile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t *v9;
  char v10;

  v9 = (uint64_t *)(a1 + 8);
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    VRLogfilePrint(v8, "-- EOF --", a3, a4, a5, a6, a7, a8, v10);
    VRLogfileFree(v9);
  }
}

BOOL VCVideoHardwareDumpWriter_RegisterSource(uint64_t a1, const void *a2)
{
  os_unfair_lock_s *v4;
  __CFSet *v5;
  _BOOL8 result;

  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      VCVideoHardwareDumpWriter_RegisterSource_cold_1();
    }
    return 0;
  }
  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      VCVideoHardwareDumpWriter_RegisterSource_cold_2();
    }
    return 0;
  }
  v4 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  v5 = *(__CFSet **)(a1 + 16);
  if (CFSetGetCount(v5) || *(_QWORD *)(a1 + 8) || VCVideoHardwareDumpWriter_OpenDumpFile(a1))
  {
    CFSetAddValue(v5, a2);
    os_unfair_lock_unlock(v4);
    return 1;
  }
  os_unfair_lock_unlock(v4);
  if ((int)VRTraceGetErrorLogLevelForModule() < 3)
    return 0;
  VRTraceErrorLogLevelToCSTR();
  result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
  if (result)
  {
    VCVideoHardwareDumpWriter_RegisterSource_cold_3();
    return 0;
  }
  return result;
}

void VCVideoHardwareDumpWriter_UnregisterSource(uint64_t a1, const void *a2)
{
  os_unfair_lock_s *v4;
  __CFSet *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  if (a2)
  {
    v4 = (os_unfair_lock_s *)(a1 + 24);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
    v5 = *(__CFSet **)(a1 + 16);
    if (CFSetGetCountOfValue(v5, a2) >= 1)
      CFSetRemoveValue(v5, a2);
    if (!CFSetGetCount(v5))
    {
      if (*(_QWORD *)(a1 + 8))
        VCVideoHardwareDumpWriter_CloseDumpFile(a1, v6, v7, v8, v9, v10, v11, v12);
    }
    os_unfair_lock_unlock(v4);
  }
}

void VCVideoHardwareDumpWriter_Write(uint64_t a1, CFStringRef theString)
{
  CFIndex Length;
  size_t v5;
  char v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD v13[2];

  v13[1] = *MEMORY[0x1E0C80C00];
  Length = CFStringGetLength(theString);
  v5 = Length + 1;
  MEMORY[0x1E0C80A78](Length);
  if ((v6 & 1) == 0)
    memset((char *)v13 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0), 170, v5);
  if (a1)
  {
    if (CFStringGetCString(theString, (char *)v13 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0), v5, 0x8000100u))
    {
      VRLogfilePrint(*(_QWORD *)(a1 + 8), "%s\n", v7, v8, v9, v10, v11, v12, (char)v13 - ((v5 + 15) & 0xF0));
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCVideoHardwareDumpWriter_Write_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCVideoHardwareDumpWriter_Write_cold_1();
  }
}

uint64_t AVConferenceServer_ProcessIsAvconferenced()
{
  return processIsAvconferenced;
}

uint64_t AVConferenceServerStartInternal(char a1)
{
  _BOOL8 v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int ErrorLogLevelForModule;
  os_log_t *v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  NSObject *global_queue;
  _BOOL8 v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char v26[1024];
  _DWORD __b[258];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  processIsAvconferenced = a1;
  processIsAVConferenceServer = 1;
  if (!VCFeatureFlagManager_UseAvconferenced())
    goto LABEL_9;
  if ((_set_user_dir_suffix() & 1) == 0)
  {
    v1 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
    if (v1)
      AVConferenceServerStartInternal_cold_5(v1, v2, v3, v4, v5, v6, v7, v8);
  }
  memset(__b, 170, 0x400uLL);
  if (!confstr(65537, (char *)__b, 0x400uLL))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      AVConferenceServerStartInternal_cold_2();
LABEL_20:
    v18 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
    if (v18)
      AVConferenceServerStartInternal_cold_1(v18, v19, v20, v21, v22, v23, v24, v25);
    exit(78);
  }
  memset(v26, 170, sizeof(v26));
  if (!realpath_DARWIN_EXTSN((const char *)__b, v26))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      AVConferenceServerStartInternal_cold_3();
    goto LABEL_20;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
    AVConferenceServerStartInternal_cold_4();
LABEL_9:
  VRTraceReset();
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  v10 = (os_log_t *)MEMORY[0x1E0CF2758];
  if (ErrorLogLevelForModule >= 7)
  {
    v11 = VRTraceErrorLogLevelToCSTR();
    v12 = *v10;
    if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
    {
      __b[0] = 136316162;
      *(_QWORD *)&__b[1] = v11;
      LOWORD(__b[3]) = 2080;
      *(_QWORD *)((char *)&__b[3] + 2) = "AVConferenceServerStartInternal";
      HIWORD(__b[5]) = 1024;
      __b[6] = 190;
      LOWORD(__b[7]) = 1024;
      *(_DWORD *)((char *)&__b[7] + 2) = processIsAvconferenced;
      HIWORD(__b[8]) = 1024;
      __b[9] = 1;
      _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Started: processIsAvconferenced=%d, processIsAVConferenceServer=%d", (uint8_t *)__b, 0x28u);
    }
  }
  v13 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(MEMORY[0x1E0CB34D0], "mainBundle"), "infoDictionary"), "objectForKey:", CFSTR("CFBundleIdentifier"));
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v14 = VRTraceErrorLogLevelToCSTR();
    v15 = *v10;
    if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
    {
      __b[0] = 136315906;
      *(_QWORD *)&__b[1] = v14;
      LOWORD(__b[3]) = 2080;
      *(_QWORD *)((char *)&__b[3] + 2) = "AVConferenceServerStartInternal";
      HIWORD(__b[5]) = 1024;
      __b[6] = 192;
      LOWORD(__b[7]) = 2112;
      *(_QWORD *)((char *)&__b[7] + 2) = v13;
      _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d CFBundleIdentifier=%@", (uint8_t *)__b, 0x26u);
    }
  }
  VCFeatureFlagManager_DaemonCrashRecovery();
  VCSignalHandler_Initialize();
  VCRegisterSignalHandler((uint64_t)"daemoninfo", (uint64_t)&__block_literal_global_4);
  global_queue = dispatch_get_global_queue(0, 0);
  dispatch_async(global_queue, &__block_literal_global_13);
  +[VCVideoCaptureServer VCVideoCaptureServerSingleton](VCVideoCaptureServer, "VCVideoCaptureServerSingleton");
  objc_msgSend(+[VideoConferenceManager defaultVideoConferenceManager](VideoConferenceManager, "defaultVideoConferenceManager"), "registerBlocksForConference");
  -[VCSessionManager registerBlocksForService](+[VCSessionManager sharedInstance](VCSessionManager, "sharedInstance"), "registerBlocksForService");
  objc_msgSend(+[VCMediaStreamManager defaultManager](VCMediaStreamManager, "defaultManager"), "registerBlocksForService");
  objc_msgSend((id)VCRemoteVideoManager_DefaultManager(), "registerBlocksForService");
  -[VCStreamOutputManager registerBlocksForService](+[VCStreamOutputManager sharedInstance](VCStreamOutputManager, "sharedInstance"), "registerBlocksForService");
  objc_msgSend(+[VCCaptionsManager defaultManager](VCCaptionsManager, "defaultManager"), "registerBlocksForService");
  -[VCAudioClientManager registerBlocksForService](+[VCAudioClientManager sharedInstance](VCAudioClientManager, "sharedInstance"), "registerBlocksForService");
  objc_msgSend(+[VCAudioManager sharedVoiceChatInstance](VCAudioManager, "sharedVoiceChatInstance"), "setIsInDaemon:", 1);
  objc_msgSend(+[VCAudioManager sharedSystemAudioOutputInstance](VCAudioManager, "sharedSystemAudioOutputInstance"), "setIsInDaemon:", 1);
  objc_msgSend(+[VCScreenCaptureManager sharedManager](VCScreenCaptureManager, "sharedManager"), "registerBlocksForService");
  -[VCMediaRecorderManager registerBlocksForService](+[VCMediaRecorderManager sharedInstance](VCMediaRecorderManager, "sharedInstance"), "registerBlocksForService");
  -[VCAudioPowerSpectrumManager registerBlocksForService](+[VCAudioPowerSpectrumManager sharedInstance](VCAudioPowerSpectrumManager, "sharedInstance"), "registerBlocksForService");
  objc_msgSend(+[VCEffectsManager sharedManager](VCEffectsManager, "sharedManager"), "registerBlocksForService");
  objc_msgSend(+[VCTestMonitorManager sharedManager](VCTestMonitorManager, "sharedManager"), "registerBlocksForService");
  objc_msgSend(+[VCDaemonProcessInfoManager sharedManager](VCDaemonProcessInfoManager, "sharedManager"), "registerBlocksForService");
  -[VCStreamInputManager registerBlocksForService](+[VCStreamInputManager sharedInstance](VCStreamInputManager, "sharedInstance"), "registerBlocksForService");
  +[VCQoSMonitorManager sharedInstance](VCQoSMonitorManager, "sharedInstance");
  +[VCAnsweringMachineManager registerBlocksForService](VCAnsweringMachineManager, "registerBlocksForService");
  objc_msgSend(+[VCAudioHALPluginDevice sharedAudioHALPluginNullDevice](VCAudioHALPluginDevice, "sharedAudioHALPluginNullDevice"), "start");
  +[VCAirPlayAudioHALPlugin sharedAirPlayAudioHALPluginNullDevice](VCAirPlayAudioHALPlugin, "sharedAirPlayAudioHALPluginNullDevice");
  objc_msgSend(+[AVConferenceXPCServer AVConferenceXPCServerSingleton](AVConferenceXPCServer, "AVConferenceXPCServerSingleton"), "_xpc_start_listening_for_connections");
  SoundDec_PrepareAudioConverter();
  return 0;
}

uint64_t AVConferenceServerStart()
{
  uint8_t v1[8];
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  if (VCFeatureFlagManager_UseAvconferenced())
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v1 = 0;
      _os_log_impl(&dword_1D8A54000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "AVConferenceServerStart called within mediaserverd.  UseAvconferenced is ON.", v1, 2u);
    }
    VRTraceReset();
    objc_msgSend(+[AVConferenceXPCServer AVConferenceXPCServerSingleton](AVConferenceXPCServer, "AVConferenceXPCServerSingleton"), "_xpc_start_listening_for_connections");
    objc_msgSend(+[VCDaemonProcessInfoManager sharedManager](VCDaemonProcessInfoManager, "sharedManager"), "registerBlocksForService");
  }
  else
  {
    AVConferenceServerStartInternal(0);
  }
  return 0;
}

void OUTLINED_FUNCTION_1_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 8u);
}

void OUTLINED_FUNCTION_2_1(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 2u);
}

uint64_t VCHardwareSettingsMac_CompareCPUFamilies(uint64_t a1, uint64_t a2)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  NSObject *v10;
  int v12;
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  uint64_t v28;

  v3 = a1;
  v28 = *MEMORY[0x1E0C80C00];
  v4 = objc_msgSend(&unk_1E9EF9A88, "indexOfObject:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", a1));
  v5 = objc_msgSend(&unk_1E9EF9A88, "indexOfObject:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", a2));
  v6 = v5;
  if (v4 == 0x7FFFFFFFFFFFFFFFLL)
  {
    v7 = 1;
  }
  else if (v5 == 0x7FFFFFFFFFFFFFFFLL)
  {
    v7 = -1;
  }
  else
  {
    v8 = (void *)objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInteger:", v4);
    v7 = objc_msgSend(v8, "compare:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInteger:", v6));
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v9 = VRTraceErrorLogLevelToCSTR();
    v10 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v12 = 136316930;
      v13 = v9;
      v14 = 2080;
      v15 = "VCHardwareSettingsMac_CompareCPUFamilies";
      v16 = 1024;
      v17 = 394;
      v18 = 1024;
      v19 = v4;
      v20 = 1024;
      v21 = v3;
      v22 = 1024;
      v23 = v6;
      v24 = 1024;
      v25 = a2;
      v26 = 1024;
      v27 = v7;
      _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Comparing %d (0x%x) and %d (0x%x), result=%d", (uint8_t *)&v12, 0x3Au);
    }
  }
  return v7;
}

void sub_1D8AB040C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void _VCAudioPowerSpectrum_CleanUp(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  uint64_t v6;
  unint64_t v7;

  v2 = *(void **)(a1 + 64);
  if (v2)
  {
    free(v2);
    *(_QWORD *)(a1 + 64) = 0;
  }
  v3 = *(void **)(a1 + 88);
  if (v3)
  {
    free(v3);
    *(_QWORD *)(a1 + 88) = 0;
  }
  v4 = *(void **)(a1 + 72);
  if (v4)
  {
    free(v4);
    *(_QWORD *)(a1 + 72) = 0;
  }
  v5 = *(void **)(a1 + 128);
  if (v5)
  {
    if (*(_DWORD *)(a1 + 36))
    {
      v6 = 0;
      v7 = 0;
      do
      {
        _VCAudioPowerSpectrum_CleanupChannel((_QWORD *)(*(_QWORD *)(a1 + 128) + v6));
        ++v7;
        v6 += 112;
      }
      while (v7 < *(unsigned int *)(a1 + 36));
      v5 = *(void **)(a1 + 128);
    }
    free(v5);
  }
  VCAudioBufferList_Destroy((uint64_t *)(a1 + 120));
}

uint64_t VCAudioPowerSpectrum_ChannelCount(uint64_t result)
{
  if (result)
    return *(unsigned int *)(result + 36);
  return result;
}

uint64_t VCAudioPowerSpectrum_GetFrequencyBins(uint64_t result, _QWORD *a2, _DWORD *a3, unsigned int a4)
{
  uint64_t v4;
  int v5;

  if (a2 && a3)
  {
    if (result && *(_BYTE *)result && *(_DWORD *)(result + 36) > a4)
    {
      v4 = *(_QWORD *)(result + 128) + 112 * a4;
      *a2 = *(_QWORD *)(v4 + 104);
      v5 = *(_DWORD *)(v4 + 96);
    }
    else
    {
      v5 = 0;
      *a2 = 0;
    }
    *a3 = v5;
  }
  return result;
}

double VCAudioPowerSpectrum_LogHealth(uint64_t a1)
{
  double result;
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  double v6;
  int v7;
  uint64_t v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  int v14;
  __int16 v15;
  double v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
  {
    v3 = VRTraceErrorLogLevelToCSTR();
    v4 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v5 = *(_QWORD *)(a1 + 104);
      v6 = *(float *)(a1 + 112);
      v7 = 136316162;
      v8 = v3;
      v9 = 2080;
      v10 = "VCAudioPowerSpectrum_LogHealth";
      v11 = 1024;
      v12 = 479;
      v13 = 1024;
      v14 = v5;
      v15 = 2048;
      v16 = v6;
      _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d @=@ Health: VCAudioPowerSpectrum Power spectrum for streamToken=%u averageLevel=%.02f", (uint8_t *)&v7, 0x2Cu);
    }
  }
  return result;
}

void VCAudioPowerSpectrum_PushAudioSamples(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t SampleFormat;
  uint64_t v5;
  NSObject *v6;
  int v7;
  __int128 v8;
  __int128 v9;
  int v10;
  double v11;
  float v12;
  unsigned int v13;
  float v14;
  __int128 v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  BOOL v19;
  uint64_t v20;
  NSObject *v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  float v28;
  unsigned int v29;
  size_t v30;
  _DWORD *v31;
  _DWORD *v32;
  unint64_t v33;
  _DWORD *v34;
  float v35;
  unsigned int v36;
  unint64_t v37;
  unsigned int v38;
  unsigned int v39;
  size_t v40;
  int v41;
  void *v42;
  unint64_t v43;
  unint64_t v44;
  os_log_t *v45;
  uint64_t v46;
  NSObject *v47;
  double v48;
  float *v49;
  void *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v58;
  _QWORD *v59;
  size_t v60;
  void *v61;
  void **v62;
  void *v63;
  uint64_t v64;
  _DWORD **v65;
  void *v66;
  uint64_t v67;
  _DWORD **v68;
  void *v69;
  uint64_t v70;
  _DWORD *v71;
  _DWORD *v72;
  uint64_t v73;
  _DWORD *v74;
  uint64_t v75;
  uint64_t v76;
  void *v77;
  void *v78;
  uint64_t v79;
  uint64_t *v80;
  void *v81;
  uint64_t v82;
  _QWORD *v83;
  uint64_t v84;
  size_t v85;
  uint64_t v86;
  int *v87;
  int v88;
  float *v89;
  unint64_t v90;
  double v91;
  double v92;
  uint64_t v93;
  uint64_t v94;
  int v95;
  uint64_t v96;
  float *v97;
  float v98;
  unsigned int v99;
  float v100;
  uint64_t *v101;
  int v102;
  uint64_t i;
  uint64_t v104;
  uint64x2_t v105;
  float v106;
  unsigned int SampleCount;
  unint64_t v108;
  vDSP_Length v109;
  uint64_t v110;
  unsigned int *v111;
  const float *BufferAtIndex;
  _DWORD *v113;
  uint64_t v114;
  uint64_t v115;
  int *v116;
  float *v117;
  int v118;
  uint64_t v119;
  int v120;
  float v121;
  uint64_t v122;
  float *v123;
  float v124;
  const float **v125;
  const float *v126;
  vDSP_Length v127;
  const float *v128;
  uint64_t v129;
  unsigned int v130;
  _DWORD *v131;
  const float *v132;
  uint64_t v133;
  int v134;
  int v135;
  void *v136;
  float64x2_t v137;
  _DWORD *v139;
  _DWORD *v140;
  float v141;
  float __C;
  float __B;
  _BYTE buf[48];
  __int16 v145;
  uint64_t v146;
  uint64_t v147;

  v147 = *MEMORY[0x1E0C80C00];
  if (a1 && *(_QWORD *)(a1 + 144) && *(_QWORD *)(a1 + 136))
  {
    v3 = a2;
    if (*(_BYTE *)a1)
      goto LABEL_83;
    SampleFormat = VCAudioBufferList_GetSampleFormat(a2);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v6 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v7 = *(_DWORD *)(a1 + 84);
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = v5;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VCAudioPowerSpectrum_SetupAudioPowerSpectrumWithBinCount";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 348;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v7;
        _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d binCount:%d", buf, 0x22u);
      }
    }
    v8 = *(_OWORD *)SampleFormat;
    v9 = *(_OWORD *)(SampleFormat + 16);
    *(_QWORD *)(a1 + 40) = *(_QWORD *)(SampleFormat + 32);
    *(_OWORD *)(a1 + 24) = v9;
    *(_OWORD *)(a1 + 8) = v8;
    if (*(_DWORD *)(SampleFormat + 8) != 1819304813)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCAudioPowerSpectrum_PushAudioSamples_cold_23();
      }
      goto LABEL_121;
    }
    v10 = *(_DWORD *)(SampleFormat + 12);
    if ((v10 & 9) == 0 || (v10 & 0x20) == 0)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCAudioPowerSpectrum_PushAudioSamples_cold_22();
      }
      goto LABEL_121;
    }
    *(_DWORD *)(a1 + 48) = 0;
    v11 = *(double *)SampleFormat;
    v12 = *(double *)SampleFormat * 0.5;
    *(float *)(a1 + 52) = v12;
    v13 = (v12 / 6.25);
    v14 = 1.0 / (double)(2 * v13);
    *(float *)(a1 + 96) = v14;
    *(_DWORD *)(a1 + 56) = v11;
    *(_DWORD *)(a1 + 60) = v13;
    v15 = *(_OWORD *)(a1 + 24);
    *(_OWORD *)buf = *(_OWORD *)(a1 + 8);
    *(_OWORD *)&buf[16] = v15;
    *(_QWORD *)&buf[32] = *(_QWORD *)(a1 + 40);
    if ((VCAudioBufferList_Allocate((__int128 *)buf, 2 * v13, (_QWORD *)(a1 + 120)) & 1) == 0)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCAudioPowerSpectrum_PushAudioSamples_cold_21();
      }
      goto LABEL_121;
    }
    VCAudioBufferList_SetSampleCount(*(_QWORD *)(a1 + 120), 2 * *(_DWORD *)(a1 + 60));
    v16 = *(_DWORD *)(a1 + 60);
    if (v16 < 7)
    {
      v17 = 0;
    }
    else
    {
      v17 = 0;
      v18 = *(_DWORD *)(a1 + 60);
      do
      {
        v17 += 6;
        v19 = v18 > 0xD;
        v18 >>= 1;
      }
      while (v19);
    }
    v27 = *(_DWORD *)(a1 + 84);
    v140 = (_DWORD *)(a1 + 84);
    v28 = expf((float)v17 * 0.11552);
    if (v17 >= v27)
      v29 = v27;
    else
      v29 = v17;
    if (!v27)
      v29 = v17;
    v30 = v29 + 1;
    *(_DWORD *)(a1 + 80) = v30;
    v31 = (_DWORD *)(a1 + 80);
    v32 = malloc_type_calloc(v30, 4uLL, 0x100004052888210uLL);
    *(_QWORD *)(a1 + 72) = v32;
    if (!v32)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCAudioPowerSpectrum_PushAudioSamples_cold_3();
      }
      v136 = *(void **)(a1 + 72);
      if (v136)
      {
        free(v136);
        *(_QWORD *)(a1 + 72) = 0;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCAudioPowerSpectrum_PushAudioSamples_cold_2();
      }
      goto LABEL_121;
    }
    LODWORD(v33) = *v31;
    if (*v31 >= 2u)
    {
      v34 = v32;
      v35 = (float)v16 / v28;
      v36 = *v32;
      v37 = 1;
      v38 = v17;
      do
      {
        v39 = (float)(v35 * expf((float)((float)v38 * 0.11552) / (float)(v33 - 1)));
        if (v36 >= v39)
          ++v36;
        else
          v36 = v39;
        v34[v37++] = v36;
        v33 = *v31;
        v38 += v17;
      }
      while (v37 < v33);
    }
    v139 = (_DWORD *)(a1 + 80);
    v40 = *v140;
    v41 = v33 - 1;
    if ((_DWORD)v40)
    {
      if (v41 == (_DWORD)v40)
        goto LABEL_50;
      v42 = malloc_type_calloc(v40, 4uLL, 0x100004052888210uLL);
      *(_QWORD *)(a1 + 88) = v42;
      if (v42)
      {
        LODWORD(v43) = *v140;
        if (*v140)
        {
          v44 = 0;
          v45 = (os_log_t *)MEMORY[0x1E0CF2758];
          do
          {
            *(float *)(*(_QWORD *)(a1 + 88) + 4 * v44) = (float)((float)v44
                                                               * (float)(*(_DWORD *)(a1 + 80) - 2))
                                                       / (float)(v43 - 1);
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              v46 = VRTraceErrorLogLevelToCSTR();
              v47 = *v45;
              if (os_log_type_enabled(*v45, OS_LOG_TYPE_ERROR))
              {
                v48 = *(float *)(*(_QWORD *)(a1 + 88) + 4 * v44);
                *(_DWORD *)buf = 136316162;
                *(_QWORD *)&buf[4] = v46;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "_VCAudioPowerSpectrum_SetupBinInterpolationWithBinCount";
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&buf[24] = 145;
                *(_WORD *)&buf[28] = 1024;
                *(_DWORD *)&buf[30] = v44;
                *(_WORD *)&buf[34] = 2048;
                *(double *)&buf[36] = v48;
                _os_log_error_impl(&dword_1D8A54000, v47, OS_LOG_TYPE_ERROR, " [%s] %s:%d lerp[%d] : %f", buf, 0x2Cu);
              }
            }
            ++v44;
            v43 = *v140;
          }
          while (v44 < v43);
        }
LABEL_50:
        v49 = (float *)malloc_type_calloc((2 * *(_DWORD *)(a1 + 60)), 4uLL, 0x100004052888210uLL);
        *(_QWORD *)(a1 + 64) = v49;
        if (v49 && (vDSP_hann_window(v49, (2 * *(_DWORD *)(a1 + 60)), 0), *(_QWORD *)(a1 + 64)))
        {
          v50 = malloc_type_calloc(*(unsigned int *)(SampleFormat + 28), 0x70uLL, 0x10A0040938ACEBEuLL);
          *(_QWORD *)(a1 + 128) = v50;
          if (v50)
          {
            if (*(_DWORD *)(SampleFormat + 28))
            {
              v51 = 0;
              LODWORD(v52) = *(_DWORD *)(a1 + 80);
              __asm { FMOV            V1.2D, #6.25 }
              v137 = _Q1;
              while (1)
              {
                v58 = *(_QWORD *)(a1 + 128);
                v59 = (_QWORD *)(v58 + 112 * v51);
                v60 = (v52 - 1);
                *(_DWORD *)v59 = v60;
                v61 = malloc_type_calloc(v60, 4uLL, 0x100004052888210uLL);
                v59[2] = v61;
                v62 = (void **)(v59 + 2);
                if (!v61)
                  break;
                v63 = malloc_type_calloc(*(unsigned int *)v59, 4uLL, 0x100004052888210uLL);
                v64 = v58 + 112 * v51;
                *(_QWORD *)(v64 + 8) = v63;
                v65 = (_DWORD **)(v64 + 8);
                if (!v63)
                {
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                  {
                    VRTraceErrorLogLevelToCSTR();
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                      VCAudioPowerSpectrum_PushAudioSamples_cold_11();
                  }
                  goto LABEL_138;
                }
                v66 = malloc_type_calloc((*(_DWORD *)v59 + 1), 4uLL, 0x100004052888210uLL);
                v67 = v58 + 112 * v51;
                *(_QWORD *)(v67 + 24) = v66;
                v68 = (_DWORD **)(v67 + 24);
                if (!v66)
                {
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                  {
                    VRTraceErrorLogLevelToCSTR();
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                      VCAudioPowerSpectrum_PushAudioSamples_cold_12();
                  }
                  goto LABEL_138;
                }
                v69 = malloc_type_calloc(*v140, 4uLL, 0x100004052888210uLL);
                *(_QWORD *)(v58 + 112 * v51 + 32) = v69;
                if (!v69)
                {
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                  {
                    VRTraceErrorLogLevelToCSTR();
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                      VCAudioPowerSpectrum_PushAudioSamples_cold_13();
                  }
                  goto LABEL_138;
                }
                v70 = *(unsigned int *)v59;
                if ((_DWORD)v70)
                {
                  v71 = *v62;
                  v72 = *v65;
                  v73 = *(unsigned int *)v59;
                  v74 = *v68;
                  do
                  {
                    *v71++ = -1024458752;
                    *v72++ = -1024458752;
                    *v74++ = -1024458752;
                    --v73;
                  }
                  while (v73);
                }
                v75 = *v140;
                if ((_DWORD)v75)
                  memset_pattern16(v69, &unk_1D91090E0, 4 * v75);
                v76 = v58 + 112 * v51;
                *(_DWORD *)(v76 + 72) = 730643660;
                v76 += 72;
                memset_pattern4(*v62, (const void *)v76, 4 * v70);
                v77 = malloc_type_calloc((2 * *(_DWORD *)(a1 + 60)), 4uLL, 0x100004052888210uLL);
                *(_QWORD *)(v76 + 16) = v77;
                if (!v77)
                {
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                  {
                    VRTraceErrorLogLevelToCSTR();
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                      VCAudioPowerSpectrum_PushAudioSamples_cold_15();
                  }
                  goto LABEL_150;
                }
                v78 = malloc_type_calloc((2 * *(_DWORD *)(a1 + 60)), 4uLL, 0x100004052888210uLL);
                v79 = v58 + 112 * v51;
                *(_QWORD *)(v79 + 64) = v78;
                v80 = (uint64_t *)(v79 + 64);
                if (!v78)
                {
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                  {
                    VRTraceErrorLogLevelToCSTR();
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                      VCAudioPowerSpectrum_PushAudioSamples_cold_16();
                  }
LABEL_150:
                  _VCAudioPowerSpectrum_CleanupFFTForChannel(v59);
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                  {
                    VRTraceErrorLogLevelToCSTR();
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                      VCAudioPowerSpectrum_PushAudioSamples_cold_14();
                  }
                  goto LABEL_112;
                }
                v81 = malloc_type_calloc(*(unsigned int *)(a1 + 60), 4uLL, 0x100004052888210uLL);
                *(_QWORD *)(v58 + 112 * v51 + 80) = v81;
                if (!v81)
                {
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                  {
                    VRTraceErrorLogLevelToCSTR();
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                      VCAudioPowerSpectrum_PushAudioSamples_cold_17();
                  }
                  goto LABEL_150;
                }
                v82 = *v80;
                v83 = (_QWORD *)(v58 + 112 * v51);
                v83[6] = v82;
                v84 = *(unsigned int *)(a1 + 60);
                v83[7] = v82 + 4 * v84;
                v83[5] = vDSP_DFT_zrop_CreateSetup(0, (2 * v84), vDSP_DFT_FORWARD);
                v85 = *(unsigned int *)(a1 + 84);
                if (!(_DWORD)v85)
                {
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                  {
                    VRTraceErrorLogLevelToCSTR();
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                      VCAudioPowerSpectrum_PushAudioSamples_cold_19();
                  }
                  goto LABEL_109;
                }
                v86 = v58 + 112 * v51;
                v88 = *(_DWORD *)(v86 + 96);
                v87 = (int *)(v86 + 96);
                if (v88)
                {
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                  {
                    VRTraceErrorLogLevelToCSTR();
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                      VCAudioPowerSpectrum_PushAudioSamples_cold_20();
                  }
LABEL_109:
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                  {
                    VRTraceErrorLogLevelToCSTR();
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                      VCAudioPowerSpectrum_PushAudioSamples_cold_18();
                  }
                  goto LABEL_112;
                }
                v89 = (float *)malloc_type_calloc(v85, 0xCuLL, 0x10000403E1C8BA9uLL);
                *(_QWORD *)(v58 + 112 * v51 + 104) = v89;
                if (!v89)
                  goto LABEL_109;
                v93 = *(_QWORD *)(a1 + 88);
                if (v93)
                {
                  v94 = *(_QWORD *)(a1 + 72);
                  v95 = *v87;
                  v96 = (*(_DWORD *)(a1 + 84) - 1);
                  if (*(_DWORD *)(a1 + 84) == 1)
                  {
                    LODWORD(v90) = 0;
                  }
                  else
                  {
                    v97 = (float *)(v93 + 4);
                    LODWORD(v90) = 0;
                    do
                    {
                      v98 = *v97++;
                      v99 = vcvtms_u32_f32(v98);
                      v100 = v98 - (float)floorf(v98);
                      LODWORD(v91) = *(_DWORD *)(v94 + 4 * v99);
                      v91 = (double)*(unint64_t *)&v91 * 6.25;
                      *(float *)&v91 = v91;
                      LODWORD(v92) = *(_DWORD *)(v94 + 4 * (v99 + 1));
                      v92 = (double)*(unint64_t *)&v92 * 6.25;
                      *(float *)&v92 = v92;
                      *(_DWORD *)v89 = v90;
                      *(float *)&v90 = (float)(v100 * *(float *)&v92) + (float)((float)(1.0 - v100) * *(float *)&v91);
                      *((_DWORD *)v89 + 1) = v90;
                      v89 += 3;
                      *v87 = ++v95;
                      --v96;
                    }
                    while (v96);
                  }
                  *(_DWORD *)v89 = v90;
                  LODWORD(v52) = *v139;
                  LODWORD(v90) = *(_DWORD *)(v94 + 4 * (*v139 - 1));
                  v106 = (double)v90 * 6.25;
                  v89[1] = v106;
                  *v87 = v95 + 1;
                }
                else
                {
                  v52 = *v139;
                  if (v52 > 1)
                  {
                    v101 = *(uint64_t **)(a1 + 72);
                    v102 = *v87;
                    for (i = 1; i != v52; ++i)
                    {
                      v104 = *v101;
                      v101 = (uint64_t *)((char *)v101 + 4);
                      v105.i64[0] = v104;
                      v105.i64[1] = HIDWORD(v104);
                      *(float32x2_t *)v89 = vcvt_f32_f64(vmulq_f64(vcvtq_f64_u64(v105), v137));
                      v89 += 3;
                      *v87 = v102 + i;
                    }
                  }
                }
                if (++v51 >= (unint64_t)*(unsigned int *)(SampleFormat + 28))
                  goto LABEL_82;
              }
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  VCAudioPowerSpectrum_PushAudioSamples_cold_10();
              }
LABEL_138:
              _VCAudioPowerSpectrum_CleanupOctave2IndexTableForChannel(v59);
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  VCAudioPowerSpectrum_PushAudioSamples_cold_9();
              }
LABEL_112:
              _VCAudioPowerSpectrum_CleanupChannel(v59);
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  VCAudioPowerSpectrum_PushAudioSamples_cold_8();
              }
              goto LABEL_121;
            }
LABEL_82:
            *(_BYTE *)a1 = 1;
            v3 = a2;
LABEL_83:
            SampleCount = VCAudioBufferList_GetSampleCount(v3);
            VCAudioBufferList_Shift(*(_QWORD *)(a1 + 120), SampleCount);
            VCAudioBufferList_Append(*(_QWORD *)(a1 + 120), v3, 0);
            if (VCAudioBufferList_GetChannelCount(*(_QWORD *)(a1 + 120)))
            {
              v108 = 0;
              do
              {
                if (v108 < *(unsigned int *)(a1 + 36))
                {
                  *(_DWORD *)buf = -1431655766;
                  v109 = *(unsigned int *)(a1 + 60);
                  v110 = *(_QWORD *)(a1 + 128);
                  v111 = (unsigned int *)(v110 + 112 * v108);
                  BufferAtIndex = (const float *)VCAudioBufferList_GetBufferAtIndex(*(_QWORD *)(a1 + 120), v108, buf);
                  vDSP_vmul(BufferAtIndex, 1, *(const float **)(a1 + 64), 1, *((float **)v111 + 11), 1, (2 * v109));
                  vDSP_ctoz(*((const DSPComplex **)v111 + 11), 2, (const DSPSplitComplex *)v111 + 3, 1, v109);
                  vDSP_DFT_Execute(*((const vDSP_DFT_SetupStruct **)v111 + 5), *((const float **)v111 + 6), *((const float **)v111 + 7), *((float **)v111 + 6), *((float **)v111 + 7));
                  vDSP_vsmul(*((const float **)v111 + 6), 1, (const float *)(a1 + 96), *((float **)v111 + 6), 1, v109);
                  vDSP_vsmul(*((const float **)v111 + 7), 1, (const float *)(a1 + 96), *((float **)v111 + 7), 1, v109);
                  vDSP_zvmags((const DSPSplitComplex *)v111 + 3, 1, *((float **)v111 + 10), 1, v109);
                  v113 = (_DWORD *)*((_QWORD *)v111 + 10);
                  *v113 = 0;
                  v114 = (*(_DWORD *)(a1 + 80) - 1);
                  if (*(_DWORD *)(a1 + 80) == 1)
                  {
                    v117 = *(float **)(v110 + 112 * v108 + 8);
                  }
                  else
                  {
                    v115 = 0;
                    v116 = *(int **)(a1 + 72);
                    v117 = *(float **)(v110 + 112 * v108 + 8);
                    v118 = *v116;
                    do
                    {
                      v119 = v115 + 1;
                      v120 = v116[v115 + 1];
                      v121 = 1.0e-12;
                      if (v120 > v118)
                      {
                        v122 = v120 - (uint64_t)v118;
                        v121 = 1.0e-12;
                        v123 = (float *)&v113[v118];
                        do
                        {
                          v124 = *v123++;
                          v121 = v121 + v124;
                          --v122;
                        }
                        while (v122);
                      }
                      v117[v115] = v121 / (float)(v120 - v118);
                      v118 = v120;
                      ++v115;
                    }
                    while (v119 != v114);
                  }
                  __B = 1.0;
                  v125 = (const float **)(v110 + 112 * v108);
                  vDSP_vdbcon(v117, 1, &__B, v117, 1, *v111, 0);
                  v141 = 0.72654;
                  __C = 0.13673;
                  vDSP_vasm(v125[1], 1, v125[2], 1, &__C, (float *)v125[2], 1, *v111);
                  vDSP_vsma(v125[3], 1, &v141, v125[2], 1, (float *)v125[3], 1, *v111);
                  memcpy((void *)v125[2], v125[1], 4 * *v111);
                  v126 = v125[3];
                  v127 = *v111;
                  v126[v127] = v126[(v127 - 1)];
                  v128 = *(const float **)(a1 + 88);
                  if (v128)
                  {
                    v129 = v110 + 112 * v108;
                    vDSP_vlint(v126, v128, 1, *(float **)(v129 + 32), 1, *(unsigned int *)(a1 + 84), v127);
                    v126 = *(const float **)(v129 + 32);
                  }
                  v130 = *(_DWORD *)(v110 + 112 * v108 + 96);
                  if (v130)
                  {
                    v131 = (_DWORD *)(*(_QWORD *)(v110 + 112 * v108 + 104) + 8);
                    v132 = v126;
                    v133 = *(unsigned int *)(v110 + 112 * v108 + 96);
                    do
                    {
                      v134 = *(_DWORD *)v132++;
                      *v131 = v134;
                      v131 += 3;
                      --v133;
                    }
                    while (v133);
                  }
                  VCUtil_ExponentialMovingAverage((float *)(a1 + 112), v126[v130 >> 1], 1.0);
                  *(_DWORD *)(a1 + 112) = v135;
                }
                ++v108;
              }
              while (v108 < VCAudioBufferList_GetChannelCount(*(_QWORD *)(a1 + 120)));
            }
            (*(void (**)(_QWORD, uint64_t))(a1 + 144))(*(_QWORD *)(a1 + 136), a2);
            return;
          }
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VCAudioPowerSpectrum_PushAudioSamples_cold_7();
          }
        }
        else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCAudioPowerSpectrum_PushAudioSamples_cold_6();
        }
LABEL_121:
        _VCAudioPowerSpectrum_CleanUp(a1);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCAudioPowerSpectrum_PushAudioSamples_cold_1();
        }
        return;
      }
    }
    else
    {
      *v140 = v41;
      if (v41)
        goto LABEL_50;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCAudioPowerSpectrum_PushAudioSamples_cold_5();
      }
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioPowerSpectrum_PushAudioSamples_cold_4();
    }
    goto LABEL_121;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v20 = VRTraceErrorLogLevelToCSTR();
    v21 = *MEMORY[0x1E0CF2758];
    v22 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        if (a1)
        {
          v24 = *(_QWORD *)(a1 + 136);
          v23 = *(_QWORD *)(a1 + 144);
        }
        else
        {
          v23 = 0;
          v24 = 0;
        }
        *(_DWORD *)buf = 136316418;
        *(_QWORD *)&buf[4] = v20;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "VCAudioPowerSpectrum_PushAudioSamples";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 485;
        *(_WORD *)&buf[28] = 2048;
        *(_QWORD *)&buf[30] = a1;
        *(_WORD *)&buf[38] = 2048;
        *(_QWORD *)&buf[40] = v23;
        v145 = 2048;
        v146 = v24;
        _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Power spectrum is not correctly configured: context[%p] sincCallback[%p] sinkContext[%p]", buf, 0x3Au);
      }
    }
    else if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
    {
      if (a1)
      {
        v26 = *(_QWORD *)(a1 + 136);
        v25 = *(_QWORD *)(a1 + 144);
      }
      else
      {
        v25 = 0;
        v26 = 0;
      }
      *(_DWORD *)buf = 136316418;
      *(_QWORD *)&buf[4] = v20;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "VCAudioPowerSpectrum_PushAudioSamples";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 485;
      *(_WORD *)&buf[28] = 2048;
      *(_QWORD *)&buf[30] = a1;
      *(_WORD *)&buf[38] = 2048;
      *(_QWORD *)&buf[40] = v25;
      v145 = 2048;
      v146 = v26;
      _os_log_debug_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Power spectrum is not correctly configured: context[%p] sincCallback[%p] sinkContext[%p]", buf, 0x3Au);
    }
  }
}

void _VCAudioPowerSpectrum_CleanupChannel(_QWORD *a1)
{
  void *v2;

  if (a1)
  {
    v2 = (void *)a1[13];
    if (v2)
    {
      free(v2);
      a1[13] = 0;
    }
  }
  _VCAudioPowerSpectrum_CleanupFFTForChannel(a1);
  _VCAudioPowerSpectrum_CleanupOctave2IndexTableForChannel(a1);
}

void _VCAudioPowerSpectrum_CleanupFFTForChannel(_QWORD *a1)
{
  void *v2;
  void *v3;
  void *v4;
  vDSP_DFT_SetupStruct *v5;

  if (a1)
  {
    v2 = (void *)a1[11];
    if (v2)
    {
      free(v2);
      a1[11] = 0;
    }
    v3 = (void *)a1[8];
    if (v3)
    {
      free(v3);
      a1[8] = 0;
    }
    v4 = (void *)a1[10];
    if (v4)
    {
      free(v4);
      a1[10] = 0;
    }
    v5 = (vDSP_DFT_SetupStruct *)a1[5];
    if (v5)
    {
      vDSP_DFT_DestroySetup(v5);
      a1[5] = 0;
    }
  }
}

void _VCAudioPowerSpectrum_CleanupOctave2IndexTableForChannel(_QWORD *a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  if (a1)
  {
    v2 = (void *)a1[1];
    if (v2)
    {
      free(v2);
      a1[1] = 0;
    }
    v3 = (void *)a1[2];
    if (v3)
    {
      free(v3);
      a1[2] = 0;
    }
    v4 = (void *)a1[3];
    if (v4)
    {
      free(v4);
      a1[3] = 0;
    }
    v5 = (void *)a1[4];
    if (v5)
    {
      free(v5);
      a1[4] = 0;
    }
  }
}

void OUTLINED_FUNCTION_8_1(uint64_t a1@<X8>)
{
  uint64_t v1;

  *(_QWORD *)(v1 - 8) = a1;
}

void CARingBuffer::CARingBuffer(CARingBuffer *this)
{
  *(_QWORD *)this = 0;
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 6) = 0;
}

void CARingBuffer::Deallocate(CARingBuffer *this)
{
  void *v2;

  v2 = *(void **)this;
  if (v2)
  {
    free(v2);
    *(_QWORD *)this = 0;
  }
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 6) = 0;
  *((_DWORD *)this + 4) = 0;
}

void CARingBuffer::~CARingBuffer(CARingBuffer *this)
{
  void *v2;

  v2 = *(void **)this;
  if (v2)
  {
    free(v2);
    *(_QWORD *)this = 0;
  }
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 6) = 0;
  *((_DWORD *)this + 4) = 0;
}

void CARingBuffer::Allocate(CARingBuffer *this, int a2, int a3, int a4)
{
  void *v8;
  uint64_t v9;
  size_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t i;
  char *v16;

  v8 = *(void **)this;
  if (v8)
  {
    free(v8);
    *(_QWORD *)this = 0;
  }
  v9 = 1 << (32 - __clz(a4 - 1));
  *((_DWORD *)this + 2) = a2;
  *((_DWORD *)this + 3) = a3;
  *((_DWORD *)this + 4) = v9;
  *((_DWORD *)this + 5) = v9 - 1;
  LODWORD(v9) = v9 * a3;
  *((_DWORD *)this + 6) = v9;
  v10 = ((v9 + 8) * a2);
  v11 = (char *)malloc_type_malloc(v10, 0x119EDC6DuLL);
  bzero(v11, v10);
  *(_QWORD *)this = v11;
  if (a2 > 0)
  {
    v12 = 0;
    v13 = *((unsigned int *)this + 6);
    v14 = &v11[8 * a2];
    do
    {
      *(_QWORD *)(*(_QWORD *)this + 8 * v12) = v14;
      v14 += v13;
      ++v12;
    }
    while (a2 != v12);
  }
  for (i = 0; i != 768; i += 24)
  {
    v16 = (char *)this + i;
    *((_QWORD *)v16 + 4) = 0;
    *((_QWORD *)v16 + 5) = 0;
    *((_DWORD *)v16 + 12) = 0;
  }
  *((_DWORD *)this + 200) = 0;
}

uint64_t CARingBuffer::Store(CARingBuffer *this, const AudioBufferList *a2, unsigned int a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t result;
  uint64_t v8;
  unsigned int *v9;
  int v10;
  char *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  unsigned int v17;
  void **v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  size_t v26;
  unsigned int v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t v30;
  size_t v31;
  unsigned int v32;
  uint64_t *v33;
  uint64_t v34;
  unsigned int v35;
  void **v36;
  void *v37;
  int v38;
  signed int mNumberBuffers;
  size_t v40;
  void **v41;
  unsigned int v42;
  uint64_t v43;
  void *v44;
  void *v45;
  size_t v46;
  unsigned int v47;
  uint64_t v48;
  void **v49;
  uint64_t v50;
  UInt32 v51;
  size_t v52;
  void **p_mData;
  unsigned int v54;
  void *v55;
  void *v56;
  char *v57;
  int v58;
  char *v59;
  unsigned int v60;
  uint64_t v61;
  uint64_t v62;

  v4 = *((unsigned int *)this + 4);
  if (v4 < a3)
    return 3;
  v8 = a4 + a3;
  v9 = (unsigned int *)((char *)this + 800);
  v10 = *((_DWORD *)this + 200);
  v11 = (char *)this + 24 * (v10 & 0x1F);
  v13 = *((_QWORD *)v11 + 5);
  v12 = (uint64_t *)(v11 + 40);
  v14 = a4;
  v15 = a4;
  if (v13 > a4)
    goto LABEL_8;
  if (v8 - *((_QWORD *)this + 3 * (v10 & 0x1F) + 4) > v4)
  {
    v14 = v8 - v4;
    if (v8 - v4 <= *v12)
      v15 = *v12;
    else
      v15 = v8 - v4;
LABEL_8:
    v16 = (char *)this + 24 * ((v10 + 1) & 0x1F);
    *((_QWORD *)v16 + 4) = v14;
    *((_QWORD *)v16 + 5) = v15;
    *((_DWORD *)v16 + 12) = v10 + 1;
    while (1)
    {
      v17 = __ldaxr(v9);
      if (v17 != v10)
        break;
      if (!__stlxr(v10 + 1, v9))
        goto LABEL_13;
    }
    __clrex();
  }
LABEL_13:
  v18 = *(void ***)this;
  v19 = *((_QWORD *)this + 3 * (*((_DWORD *)this + 200) & 0x1F) + 5);
  v20 = *((_DWORD *)this + 5);
  v22 = *((_DWORD *)this + 2);
  v21 = *((_DWORD *)this + 3);
  if (v19 >= a4)
  {
    v24 = (v20 & a4) * v21;
  }
  else
  {
    v23 = (v20 & v19) * v21;
    v24 = (v20 & a4) * v21;
    if (v24 <= v23)
    {
      if (v22 >= 1)
      {
        v61 = a4 + a3;
        v30 = v23;
        v31 = *((_DWORD *)this + 6) - v23;
        v32 = v22 + 1;
        v33 = *(uint64_t **)this;
        do
        {
          v34 = *v33++;
          bzero((void *)(v34 + v30), v31);
          --v32;
        }
        while (v32 > 1);
        v35 = v22 + 1;
        v36 = v18;
        v8 = v61;
        do
        {
          v37 = *v36++;
          bzero(v37, v24);
          --v35;
        }
        while (v35 > 1);
      }
    }
    else if (v22 >= 1)
    {
      v25 = v23;
      v26 = v24 - v23;
      v27 = v22 + 1;
      v28 = *(uint64_t **)this;
      do
      {
        v29 = *v28++;
        bzero((void *)(v29 + v25), v26);
        --v27;
      }
      while (v27 > 1);
    }
  }
  v38 = (*((_DWORD *)this + 5) & v8) * *((_DWORD *)this + 3);
  mNumberBuffers = a2->mNumberBuffers;
  if (v38 <= v24)
  {
    if (mNumberBuffers >= 1)
    {
      v62 = v8;
      v46 = *((_DWORD *)this + 6) - v24;
      v47 = mNumberBuffers + 1;
      v48 = 16;
      v49 = v18;
      do
      {
        v50 = (uint64_t)*v49++;
        memcpy((void *)(v50 + v24), *(const void **)((char *)&a2->mNumberBuffers + v48), v46);
        v48 += 16;
        --v47;
      }
      while (v47 > 1);
      v51 = a2->mNumberBuffers;
      v8 = v62;
      if ((int)a2->mNumberBuffers >= 1)
      {
        v52 = v38;
        p_mData = &a2->mBuffers[0].mData;
        v54 = v51 + 1;
        do
        {
          v56 = *v18++;
          v55 = v56;
          v57 = (char *)*p_mData;
          p_mData += 2;
          memcpy(v55, &v57[v46], v52);
          --v54;
        }
        while (v54 > 1);
      }
    }
  }
  else if (mNumberBuffers >= 1)
  {
    v40 = v38 - v24;
    v41 = &a2->mBuffers[0].mData;
    v42 = mNumberBuffers + 1;
    do
    {
      v43 = (uint64_t)*v18++;
      v44 = (void *)(v43 + v24);
      v45 = *v41;
      v41 += 2;
      memcpy(v44, v45, v40);
      --v42;
    }
    while (v42 > 1);
  }
  v58 = *((_DWORD *)this + 200);
  v59 = (char *)this + 24 * ((v58 + 1) & 0x1F) + 32;
  *(_QWORD *)v59 = *((_QWORD *)this + 3 * (v58 & 0x1F) + 4);
  *((_QWORD *)v59 + 1) = v8;
  *((_DWORD *)v59 + 4) = v58 + 1;
  while (1)
  {
    v60 = __ldaxr(v9);
    if (v60 != v58)
      break;
    if (!__stlxr(v58 + 1, v9))
      return 0;
  }
  result = 0;
  __clrex();
  return result;
}

uint64_t CARingBuffer::Fetch(CARingBuffer *this, AudioBufferList *a2, unsigned int a3, uint64_t a4)
{
  AudioBufferList *v4;
  uint64_t v6;
  int v7;
  char *v8;
  uint64_t *v9;
  uint64_t *v10;
  _DWORD *v11;
  int v12;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  size_t v20;
  void **p_mData;
  UInt32 v22;
  void *v23;
  int v24;
  int v25;
  uint64_t v26;
  size_t v27;
  void **v28;
  unsigned int v29;
  char *v30;
  const void **v31;
  int v32;
  int v33;
  int v34;
  int v35;
  signed int v36;
  uint64_t v37;
  uint64_t v38;
  void **v39;
  unsigned int v40;
  char *v41;
  char *v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  size_t v47;
  AudioBufferList *v48;
  unsigned int v49;
  uint64_t v50;
  uint64_t *v51;
  uint64_t v52;
  int mNumberBuffers;
  uint64_t v54;
  void **v55;
  unsigned int v56;
  char *v57;
  char *v58;
  const void *v59;
  UInt32 *p_mDataByteSize;
  unsigned int v61;
  int v62;
  int v63;

  v4 = a2;
  v6 = a4 + a3;
  v7 = *((_DWORD *)this + 200);
  v8 = (char *)this + 24 * (v7 & 0x1F);
  v9 = (uint64_t *)(v8 + 32);
  v10 = (uint64_t *)(v8 + 40);
  v11 = v8 + 48;
  v12 = 8;
  while (*v11 != v7)
  {
    if (!--v12)
      return 4;
  }
  if (a4 <= *v9)
    v14 = *v9;
  else
    v14 = a4;
  if (*v10 >= v6)
    v15 = a4 + a3;
  else
    v15 = *v10;
  if (v15 <= v14)
    v16 = v14;
  else
    v16 = v15;
  v17 = v14 - a4;
  if ((int)v14 - (int)a4 > (int)a3)
    return 5;
  v18 = v6 - v16;
  v19 = v16 - v14 + v17;
  if (v19 + (int)v6 - (int)v16 > a3)
    return 5;
  if (v17 >= 1 && (int)a2->mNumberBuffers >= 1)
  {
    v20 = *((_DWORD *)this + 3) * v17;
    p_mData = &a2->mBuffers[0].mData;
    v22 = a2->mNumberBuffers + 1;
    do
    {
      v23 = *p_mData;
      p_mData += 2;
      bzero(v23, v20);
      --v22;
    }
    while (v22 > 1);
  }
  if (v18 >= 1 && (int)v4->mNumberBuffers >= 1)
  {
    v24 = *((_DWORD *)this + 3);
    v25 = v24 * v18;
    v26 = v24 * (int)v19;
    v27 = v25;
    v28 = &v4->mBuffers[0].mData;
    v29 = v4->mNumberBuffers + 1;
    do
    {
      v30 = (char *)*v28;
      v28 += 2;
      bzero(&v30[v26], v27);
      --v29;
    }
    while (v29 > 1);
  }
  v31 = *(const void ***)this;
  v32 = *((_DWORD *)this + 5);
  v33 = *((_DWORD *)this + 3);
  v34 = (v32 & v14) * v33;
  v35 = (v32 & v16) * v33;
  v36 = v35 - v34;
  if (v35 <= v34)
  {
    v44 = *((_DWORD *)this + 6) - v34;
    if ((int)v4->mNumberBuffers >= 1)
    {
      v62 = *((_DWORD *)this + 6) - v34;
      v63 = (v32 & v16) * v33;
      v45 = v33 * v17;
      v46 = v34;
      v47 = v44;
      v48 = v4;
      v49 = v4->mNumberBuffers + 1;
      v50 = 16;
      v51 = *(uint64_t **)this;
      do
      {
        v52 = *v51++;
        memcpy((void *)(*(_QWORD *)((char *)&v48->mNumberBuffers + v50) + v45), (const void *)(v52 + v46), v47);
        v50 += 16;
        --v49;
      }
      while (v49 > 1);
      mNumberBuffers = v48->mNumberBuffers;
      v4 = v48;
      v44 = v62;
      v35 = v63;
      if (mNumberBuffers >= 1)
      {
        v54 = v62 + *((_DWORD *)this + 3) * v17;
        v55 = &v4->mBuffers[0].mData;
        v56 = mNumberBuffers + 1;
        do
        {
          v57 = (char *)*v55;
          v55 += 2;
          v58 = &v57[v54];
          v59 = *v31++;
          memcpy(v58, v59, v63);
          --v56;
        }
        while (v56 > 1);
      }
    }
    v36 = v44 + v35;
    goto LABEL_37;
  }
  if ((int)v4->mNumberBuffers >= 1)
  {
    v37 = v33 * v17;
    v38 = v34;
    v39 = &v4->mBuffers[0].mData;
    v40 = v4->mNumberBuffers + 1;
    do
    {
      v41 = (char *)*v39;
      v39 += 2;
      v42 = &v41[v37];
      v43 = (uint64_t)*v31++;
      memcpy(v42, (const void *)(v43 + v38), v36);
      --v40;
    }
    while (v40 > 1);
LABEL_37:
    if ((int)v4->mNumberBuffers >= 1)
    {
      p_mDataByteSize = &v4->mBuffers[0].mDataByteSize;
      v61 = v4->mNumberBuffers + 1;
      do
      {
        *p_mDataByteSize = v36;
        p_mDataByteSize += 4;
        --v61;
      }
      while (v61 > 1);
    }
  }
  return 0;
}

uint64_t _AVCStatisticsCollectorHandlerList_CompareListEntries(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;
  BOOL v4;
  unsigned int v5;

  v2 = *(_DWORD *)(a1 + 8);
  v3 = *(_DWORD *)(a2 + 8);
  v4 = v2 == v3;
  v5 = 2 * (v2 >= v3);
  if (v4)
    return 1;
  else
    return v5;
}

uint64_t _AVCStatisticsCollector_CleanupChangeHandlers(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  _QWORD v5[6];

  v5[5] = *MEMORY[0x1E0C80C00];
  v2 = 360;
  v3 = MEMORY[0x1E0C809B0];
  do
  {
    v5[0] = v3;
    v5[1] = 3221225472;
    v5[2] = ___AVCStatisticsCollector_CleanupChangeHandlers_block_invoke;
    v5[3] = &unk_1E9E52868;
    v5[4] = a1;
    result = VCSingleLinkedListClear(a1 + v2, (uint64_t)v5);
    v2 += 32;
  }
  while (v2 != 840);
  return result;
}

void _AVCStatisticsCollector_ProcessVCStatisticsInternal(uint64_t a1, unsigned int *a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  double v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t SendHistoryElement;
  unsigned int v13;
  double *v14;
  unsigned int v15;
  int v16;
  unsigned int v17;
  unsigned int *v18;
  int v19;
  unsigned int v20;
  unsigned int v21;
  double v22;
  double v23;
  unsigned int v24;
  unsigned int v26;
  double v27;
  unsigned int *v28;
  int v29;
  unsigned int v30;
  unsigned int *v31;
  int v32;
  unsigned int v33;
  uint64_t v35;
  uint64_t v36;
  double v37;
  double v38;
  double v39;
  uint64_t v40;
  double v41;
  double v42;
  double v43;
  uint64_t v44;
  uint64_t v45;
  double v46;
  double v47;
  int v48;
  double v49;
  int v50;
  double v51;
  double v52;
  unsigned int BurstyLoss;
  unsigned int v54;
  uint64_t v55;
  pthread_rwlock_t *v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  unsigned int *v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  unsigned int v73;
  uint64_t v74;
  int v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  uint64_t v82;
  _QWORD v83[5];
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  uint64_t v88;

  v88 = *MEMORY[0x1E0C80C00];
  v4 = *(_DWORD *)(a1 + 68);
  v5 = *(_QWORD *)(a1 + 32);
  if ((v4 & 0xFFFFFFFE) == 8)
  {
    if (*a2 == 2)
    {
      _AVCStatisticsCollector_UpdatePacketReceivedCount(a1, (uint64_t)a2);
      SendHistoryElement = VCStatisticsHistory_GetSendHistoryElement(v5, a2[17]);
      if (SendHistoryElement)
      {
        v84 = 0u;
        v85 = 0u;
        v86 = 0u;
        v87 = 0u;
        *((_QWORD *)&v84 + 1) = *((_QWORD *)a2 + 1);
        LODWORD(v85) = a2[6];
        v13 = *(_DWORD *)(SendHistoryElement + 16);
        *(_QWORD *)&v86 = *(_QWORD *)(SendHistoryElement + 24);
        *(_QWORD *)((char *)&v85 + 4) = __PAIR64__(*(_DWORD *)(a1 + 100), v13);
        DWORD2(v87) = a2[10];
        VCStatisticsHistory_AddStatsHistory(v5, (unsigned __int8 *)&v84);
        a2[16] = DWORD1(v85);
      }
      goto LABEL_20;
    }
    if (*a2 != 6 || !a2[6])
      goto LABEL_20;
    v8 = *((double *)a2 + 1);
LABEL_19:
    v14 = (double *)malloc_type_calloc(1uLL, 0x38uLL, 0x102004094C8A1BEuLL);
    *(_DWORD *)v14 = a2[6];
    v14[1] = v8;
    *((_DWORD *)v14 + 4) = a2[7];
    *((_QWORD *)v14 + 3) = a2[8];
    VCStatisticsHistory_AddAndPruneSendHistory(v5, (int *)v14, v8 + -5.0);
    goto LABEL_20;
  }
  if ((v4 & 0xFFFFFFFE) == 4)
  {
    if (*a2 == 5 && a2[8])
    {
      v84 = 0u;
      v85 = 0u;
      LOBYTE(v84) = *((_BYTE *)a2 + 24);
      *((_QWORD *)&v84 + 1) = *((_QWORD *)a2 + 1);
      LODWORD(v85) = a2[7];
      *(_QWORD *)((char *)&v85 + 4) = *(_QWORD *)(a2 + 9);
      v6 = *(_QWORD *)(a2 + 11);
      *(_QWORD *)&v7 = v6;
      *((_QWORD *)&v7 + 1) = HIDWORD(v6);
      v86 = v7;
      v87 = 0u;
      *(_QWORD *)&v87 = a2[13];
LABEL_15:
      VCStatisticsHistory_AddStatsHistory(v5, (unsigned __int8 *)&v84);
      goto LABEL_20;
    }
    goto LABEL_20;
  }
  if (v4 != 7)
    goto LABEL_20;
  if (*a2 == 6)
  {
    v8 = *((double *)a2 + 5);
    goto LABEL_19;
  }
  if (*a2 == 2)
  {
    _AVCStatisticsCollector_UpdatePacketReceivedCount(a1, (uint64_t)a2);
    v9 = VCStatisticsHistory_GetSendHistoryElement(v5, a2[17]);
    if (v9)
    {
      v86 = 0u;
      v87 = 0u;
      v84 = 0u;
      v85 = 0u;
      *((_QWORD *)&v84 + 1) = *((_QWORD *)a2 + 1);
      v10 = *(_DWORD *)(v9 + 16);
      v11 = a2[13];
      LODWORD(v85) = a2[6];
      *(_QWORD *)((char *)&v85 + 4) = __PAIR64__(v11, v10);
      DWORD2(v87) = a2[10];
      goto LABEL_15;
    }
  }
LABEL_20:
  v15 = *(_DWORD *)(a1 + 68);
  if (v15 <= 9)
  {
    if (((1 << v15) & 0x38A) != 0)
    {
      if (*a2 == 2)
      {
        v17 = 1000 * a2[8];
        v18 = (unsigned int *)(a1 + 84);
        v19 = *(_DWORD *)(a1 + 84);
        while (1)
        {
          v20 = __ldxr(v18);
          if (v20 != v19)
            break;
          if (!__stxr(v17, v18))
            goto LABEL_37;
        }
        __clrex();
LABEL_37:
        a2[9] = a2[8] & 7;
        goto LABEL_60;
      }
      if (*a2 != 4)
      {
LABEL_60:
        v15 = *(_DWORD *)(a1 + 68);
        goto LABEL_61;
      }
LABEL_24:
      _AVCStatisticsCollector_ComputeBWEstimation(a1, (double *)a2);
      goto LABEL_60;
    }
    if (v15 == 4)
    {
      v16 = *a2;
      if (*a2 != 5)
      {
        v15 = 4;
        goto LABEL_66;
      }
      _AVCStatisticsCollector_ComputeBWEstimation(a1, (double *)a2);
      v21 = *(_DWORD *)(a1 + 76);
      goto LABEL_58;
    }
    if (v15 == 5)
    {
      v16 = *a2;
      if (*a2 != 5)
      {
        if (v16 != 4)
        {
          v15 = 5;
          goto LABEL_66;
        }
        a2[12] = a2[8];
        goto LABEL_24;
      }
      v22 = *((double *)a2 + 1);
      VCRateControlBandwidthEstimatorMap_EstimatedBandwidthWithArrivalTime(*(_QWORD *)(a1 + 16), v22);
      v24 = *(_DWORD *)(a1 + 104);
      if (v24 >= v23 || v24 == 0)
        v26 = v23;
      else
        v26 = *(_DWORD *)(a1 + 104);
      VCRateControlBandwidthEstimatorMap_EstimatedBandwidthUncappedWithArrivalTime(*(_QWORD *)(a1 + 16), v22);
      v28 = (unsigned int *)(a1 + 76);
      v29 = *(_DWORD *)(a1 + 76);
      while (1)
      {
        v30 = __ldxr(v28);
        if (v30 != v29)
          break;
        if (!__stxr(v26, v28))
          goto LABEL_51;
      }
      __clrex();
LABEL_51:
      v31 = (unsigned int *)(a1 + 80);
      v32 = *(_DWORD *)(a1 + 80);
      while (1)
      {
        v33 = __ldxr(v31);
        if (v33 != v32)
          break;
        if (!__stxr(v27, v31))
          goto LABEL_56;
      }
      __clrex();
LABEL_56:
      if (a2[15])
      {
LABEL_59:
        a2[27] = *(_DWORD *)(a1 + 108);
        goto LABEL_60;
      }
      v21 = *v28;
LABEL_58:
      a2[15] = v21;
      goto LABEL_59;
    }
  }
LABEL_61:
  if (v15 > 9 || ((1 << v15) & 0x3B0) == 0)
    goto LABEL_95;
  v16 = *a2;
LABEL_66:
  if (v16 == 7)
  {
    if (a2[6] != 4)
      goto LABEL_95;
    objc_msgSend(*(id *)(a1 + 24), "relativeSendTimeWithTimestamp:timestampRate:", a2[7], a2[8]);
    v42 = v41;
    objc_msgSend(*(id *)(a1 + 24), "relativeReceiveTimeWithTimestamp:timestampRate:", (*((double *)a2 + 6) * 1000.0), 1000);
    objc_msgSend(*(id *)(a1 + 24), "calculateOWRDWithSendTime:receiveTime:roundTripTime:", v42, v43, 0.0);
    objc_msgSend(*(id *)(a1 + 24), "owrd");
    *((_QWORD *)a2 + 7) = v44;
  }
  else
  {
    if (v16 != 5)
      goto LABEL_80;
    if (a2[8])
    {
      if (v15 == 5)
        v35 = 1000;
      else
        v35 = 1024;
      if (v15 == 5)
        v36 = 1024;
      else
        v36 = 1000;
      objc_msgSend(*(id *)(a1 + 24), "relativeSendTimeWithTimestamp:timestampRate:", a2[7], v35);
      v38 = v37;
      objc_msgSend(*(id *)(a1 + 24), "relativeReceiveTimeWithTimestamp:timestampRate:", a2[8], v36);
      objc_msgSend(*(id *)(a1 + 24), "calculateOWRDWithSendTime:receiveTime:roundTripTime:", v38, v39, *((double *)a2 + 8));
    }
    objc_msgSend(*(id *)(a1 + 24), "owrd");
    *((_QWORD *)a2 + 9) = v40;
  }
  v16 = *a2;
LABEL_80:
  if (v16 == 2)
  {
    v45 = *(_QWORD *)(a1 + 32);
    v46 = *((double *)a2 + 1);
    v47 = 5.0;
  }
  else
  {
    if (v16 != 5)
      goto LABEL_85;
    *((double *)a2 + 10) = VCStatisticsHistory_PacketLossRate(*(_QWORD *)(a1 + 32), *((double *)a2 + 1), 5.0);
    v45 = *(_QWORD *)(a1 + 32);
    v46 = *((double *)a2 + 1);
    v47 = 1.0;
  }
  *((double *)a2 + 11) = VCStatisticsHistory_PacketLossRate(v45, v46, v47);
  v16 = *a2;
LABEL_85:
  if (v16 == 2)
  {
    a2[24] = VCStatisticsHistory_SendingBitrate(*(_QWORD *)(a1 + 32), *((double *)a2 + 1), 5.0);
    a2[25] = VCStatisticsHistory_SendingBitrate(*(_QWORD *)(a1 + 32), *((double *)a2 + 1), 0.5);
    goto LABEL_95;
  }
  if (v16 == 5 && !a2[24])
  {
    v48 = *(_DWORD *)(a1 + 68);
    if (v48 == 4)
    {
      a2[24] = VCStatisticsHistory_SendingBitrate(*(_QWORD *)(a1 + 32), *((double *)a2 + 1), 5.0);
      v49 = VCStatisticsHistory_SendingBitrate(*(_QWORD *)(a1 + 32), *((double *)a2 + 1), 0.5);
    }
    else
    {
      if (v48 != 5)
      {
LABEL_94:
        a2[26] = VCStatisticsHistory_ServerStatsBitrate(*(_QWORD *)(a1 + 32), *((double *)a2 + 1), 5.0);
        goto LABEL_95;
      }
      a2[24] = VCStatisticsHistory_ReceivingBitrate(*(_QWORD *)(a1 + 32), *((double *)a2 + 1), 5.0);
      v49 = VCStatisticsHistory_ReceivingBitrate(*(_QWORD *)(a1 + 32), *((double *)a2 + 1), 0.5);
    }
    a2[25] = v49;
    goto LABEL_94;
  }
LABEL_95:
  v50 = *a2;
  if ((*(_DWORD *)(a1 + 68) - 7) > 2)
  {
    if (v50 == 2)
    {
      _AVCStatisticsCollector_UpdatePacketReceivedCount(a1, (uint64_t)a2);
LABEL_104:
      v50 = *a2;
    }
  }
  else if (v50 == 2)
  {
    v51 = VCStatisticsHistory_RoundTripTimeWithPacketId(*(_QWORD *)(a1 + 32), a2[17], *((double *)a2 + 1));
    v52 = 0.0;
    if (v51 <= 65.535)
    {
      LODWORD(v52) = a2[7];
      v52 = fmax(v51 + (double)*(unint64_t *)&v52 / -1000.0, 0.0);
    }
    *((double *)a2 + 13) = v52;
    v50 = *a2;
    if (*a2 == 2)
    {
      BurstyLoss = VCStatisticsHistory_GetBurstyLoss(*(_QWORD *)(a1 + 32), *((double *)a2 + 1), 5.0, 0.9);
      if (BurstyLoss != -1)
        a2[12] = BurstyLoss;
      goto LABEL_104;
    }
  }
  if (*(_DWORD *)(a1 + 68) == 7 && v50 == 14)
  {
    VCStatisticsHistory_BytesInFlight(*(_QWORD *)(a1 + 32), (double *)a2 + 4, (double *)a2 + 3);
    a2[10] = v54;
    v50 = *a2;
  }
  v55 = *(_QWORD *)(a1 + 8);
  switch(v50)
  {
    case 2:
      v56 = (pthread_rwlock_t *)(a1 + 144);
      pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 144));
      v57 = *(_OWORD *)(a2 + 14);
      v58 = *(_OWORD *)(a2 + 10);
      *(_OWORD *)v55 = *(_OWORD *)(a2 + 6);
      *(_OWORD *)(v55 + 16) = v58;
      *(_OWORD *)(v55 + 32) = v57;
      v59 = *(_OWORD *)(a2 + 22);
      v60 = *(_OWORD *)(a2 + 30);
      v61 = *(_OWORD *)(a2 + 18);
      *(_OWORD *)(v55 + 80) = *(_OWORD *)(a2 + 26);
      *(_OWORD *)(v55 + 96) = v60;
      *(_OWORD *)(v55 + 48) = v61;
      *(_OWORD *)(v55 + 64) = v59;
      v62 = *(_OWORD *)(a2 + 38);
      v63 = *(_OWORD *)(a2 + 46);
      v64 = *(_OWORD *)(a2 + 34);
      *(_OWORD *)(v55 + 144) = *(_OWORD *)(a2 + 42);
      *(_OWORD *)(v55 + 160) = v63;
      *(_OWORD *)(v55 + 112) = v64;
      *(_OWORD *)(v55 + 128) = v62;
      if (*((_BYTE *)a2 + 116))
      {
        v65 = a2 + 30;
        if (a2[30] == 3)
        {
LABEL_122:
          v76 = *(_OWORD *)v65;
          v77 = *((_OWORD *)v65 + 1);
          v78 = *((_OWORD *)v65 + 2);
          *(_QWORD *)(v55 + 400) = *((_QWORD *)v65 + 6);
          *(_OWORD *)(v55 + 368) = v77;
          *(_OWORD *)(v55 + 384) = v78;
          *(_OWORD *)(v55 + 352) = v76;
        }
      }
      goto LABEL_131;
    case 3:
      v56 = (pthread_rwlock_t *)(a1 + 144);
      pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 144));
      v66 = *(_OWORD *)(a2 + 10);
      v67 = *(_OWORD *)(a2 + 18);
      v68 = *(_OWORD *)(a2 + 6);
      *(_OWORD *)(v55 + 208) = *(_OWORD *)(a2 + 14);
      *(_OWORD *)(v55 + 224) = v67;
      *(_OWORD *)(v55 + 176) = v68;
      *(_OWORD *)(v55 + 192) = v66;
      goto LABEL_131;
    case 4:
      v56 = (pthread_rwlock_t *)(a1 + 144);
      pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 144));
      if (*((_BYTE *)a2 + 52))
      {
        v65 = a2 + 14;
        if (a2[14] == 4)
        {
LABEL_123:
          v79 = *(_OWORD *)v65;
          v80 = *((_OWORD *)v65 + 1);
          v81 = *((_OWORD *)v65 + 2);
          *(_QWORD *)(v55 + 456) = *((_QWORD *)v65 + 6);
          *(_OWORD *)(v55 + 424) = v80;
          *(_OWORD *)(v55 + 440) = v81;
          *(_OWORD *)(v55 + 408) = v79;
        }
      }
      goto LABEL_131;
    case 5:
      v56 = (pthread_rwlock_t *)(a1 + 144);
      pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 144));
      v69 = *(_OWORD *)(a2 + 10);
      *(_OWORD *)(v55 + 240) = *(_OWORD *)(a2 + 6);
      *(_OWORD *)(v55 + 256) = v69;
      v70 = *(_OWORD *)(a2 + 18);
      v71 = *(_OWORD *)(a2 + 22);
      v72 = *(_OWORD *)(a2 + 14);
      *(_QWORD *)(v55 + 320) = *((_QWORD *)a2 + 13);
      *(_OWORD *)(v55 + 288) = v70;
      *(_OWORD *)(v55 + 304) = v71;
      *(_OWORD *)(v55 + 272) = v72;
      goto LABEL_131;
    case 7:
      v56 = (pthread_rwlock_t *)(a1 + 144);
      pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 144));
      v65 = a2 + 6;
      switch(a2[6])
      {
        case 1u:
          v73 = a2[19];
          v74 = a1;
          v75 = 1;
          goto LABEL_128;
        case 2u:
          v73 = a2[19];
          v74 = a1;
          v75 = 0;
LABEL_128:
          _AVCStatisticsCollector_UpdateMaxLocalBurstyLoss(v74, v73, v75);
          break;
        case 3u:
          goto LABEL_122;
        case 4u:
          goto LABEL_123;
        case 5u:
          *(_QWORD *)(a1 + 128) = *((_QWORD *)a2 + 7);
          break;
        case 6u:
          *(_BYTE *)(a1 + 140) = 1;
          break;
        default:
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              _AVCStatisticsCollector_ProcessVCStatisticsInternal_cold_1();
          }
          break;
      }
      goto LABEL_131;
    case 10:
      if (a2[6] != 4)
        goto LABEL_132;
      v56 = (pthread_rwlock_t *)(a1 + 144);
      pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 144));
      *(_DWORD *)(v55 + 464) = a2[6];
      *(_DWORD *)(v55 + 504) = a2[16];
LABEL_131:
      pthread_rwlock_unlock(v56);
LABEL_132:
      if (!*((_BYTE *)a2 + 19))
      {
        if (!*((_BYTE *)a2 + 16))
          _AVCStatisticsCollector_UpdateStatisticChangeHandlerDictionaryCache(a1);
        pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 840));
        v82 = a1 + 32 * *a2 + 360;
        v83[0] = MEMORY[0x1E0C809B0];
        v83[1] = 3221225472;
        v83[2] = ___AVCStatisticsCollector_ProcessVCStatisticsInternal_block_invoke;
        v83[3] = &__block_descriptor_40_e66_v24__0___VCSingleLinkedListEntry____VCSingleLinkedListEntry__8_B16l;
        v83[4] = a2;
        VCSingleLinkedListEnumerate(v82, (uint64_t)v83);
        pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 840));
      }
      return;
    case 13:
      v56 = (pthread_rwlock_t *)(a1 + 144);
      pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 144));
      *(_QWORD *)(v55 + 528) = *((_QWORD *)a2 + 3);
      goto LABEL_131;
    default:
      goto LABEL_132;
  }
}

uint64_t _AVCStatisticsCollector_UpdateStatisticChangeHandlerDictionaryCache(uint64_t a1)
{
  pthread_rwlock_t *v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  _QWORD *v9;
  void *v10[2];

  v10[1] = *(void **)MEMORY[0x1E0C80C00];
  v10[0] = 0;
  v2 = (pthread_rwlock_t *)(a1 + 840);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 840));
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 1080));
  v3 = (_QWORD *)(a1 + 1048);
  v4 = *(_QWORD **)(a1 + 1048);
  if (v4 != (_QWORD *)(a1 + 1048))
  {
    v5 = a1 + 360;
    do
    {
      *v3 = *v4;
      *(_QWORD *)(*v4 + 8) = v4[1];
      *v4 = v4;
      v4[1] = v4;
      v10[0] = v4;
      v6 = *((_DWORD *)v4 + 4);
      if (v6 == 2)
      {
        _AVCStatisticsCollector_CleanupChangeHandlers(a1);
      }
      else if (v6 == 1)
      {
        v7 = v5 + 32 * *((unsigned int *)v4 + 5);
        v9 = (_QWORD *)0xAAAAAAAAAAAAAAAALL;
        v9 = VCSingleLinkedListRemove(v7, v4[3]);
        _AVCStatisticsCollector_DestroyChangeHandlerEntry(a1, &v9);
      }
      else if (!v6 && VCSingleLinkedListPush(v5 + 32 * *((unsigned int *)v4 + 5), (_QWORD *)v4[3]))
      {
        *((_QWORD *)v10[0] + 3) = 0;
      }
      _AVCStatisticsCollector_DestroyChangeHandlerRequest(a1, v10);
      v4 = *(_QWORD **)(a1 + 1048);
    }
    while (v4 != v3);
  }
  v10[0] = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 1080));
  return pthread_rwlock_unlock(v2);
}

BOOL _AVCStatisticsCollector_PushChangeHandlerRequest(uint64_t a1, int a2, int a3, int a4, const void *a5)
{
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  _BOOL8 result;
  uint64_t v16;
  NSObject *v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  NSObject *v21;
  _QWORD *v22;
  uint8_t buf[4];
  uint64_t v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  uint64_t v30;
  __int16 v31;
  int v32;
  __int16 v33;
  int v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v10 = CFAllocatorAllocate(*(CFAllocatorRef *)(a1 + 344), 24, 0);
  if (v10)
  {
    v11 = v10;
    *v10 = 0;
    if (a5)
      v12 = _Block_copy(a5);
    else
      v12 = 0;
    v11[2] = v12;
    *((_DWORD *)v11 + 2) = a4;
    v22 = v11;
    v13 = CFAllocatorAllocate(*(CFAllocatorRef *)(a1 + 1040), 32, 0);
    if (v13)
    {
      *v13 = v13;
      v13[1] = v13;
      *((_DWORD *)v13 + 4) = a2;
      *((_DWORD *)v13 + 5) = a3;
      v13[3] = v11;
      v14 = *(_QWORD **)(a1 + 1056);
      v13[1] = v14;
      *v13 = *v14;
      *v14 = v13;
      *(_QWORD *)(a1 + 1056) = v13;
      return 1;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v20 = VRTraceErrorLogLevelToCSTR();
      v21 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136316418;
        v24 = v20;
        v25 = 2080;
        v26 = "_AVCStatisticsCollector_PushChangeHandlerRequest";
        v27 = 1024;
        v28 = 307;
        v29 = 2048;
        v30 = a1;
        v31 = 1024;
        v32 = a2;
        v33 = 1024;
        v34 = a3;
        _os_log_error_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_ERROR, "VCRC [%s] %s:%d statisticsCollector[%p] Failed to create the request. requestType=%d handlerType=%d", buf, 0x32u);
      }
    }
    _AVCStatisticsCollector_DestroyChangeHandlerEntry(a1, &v22);
    return 0;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v16 = VRTraceErrorLogLevelToCSTR();
    v17 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136316162;
      v24 = v16;
      v25 = 2080;
      v26 = "_AVCStatisticsCollector_NewChangeHandlerEntry";
      v27 = 1024;
      v28 = 265;
      v29 = 2048;
      v30 = a1;
      v31 = 1024;
      v32 = a4;
      _os_log_error_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_ERROR, "VCRC [%s] %s:%d statisticsCollector[%p] Failed to create the entry. identifier=%d", buf, 0x2Cu);
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() < 3)
    return 0;
  v18 = VRTraceErrorLogLevelToCSTR();
  v19 = *MEMORY[0x1E0CF2758];
  result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_DWORD *)buf = 136316418;
    v24 = v18;
    v25 = 2080;
    v26 = "_AVCStatisticsCollector_PushChangeHandlerRequest";
    v27 = 1024;
    v28 = 304;
    v29 = 2048;
    v30 = a1;
    v31 = 1024;
    v32 = a2;
    v33 = 1024;
    v34 = a3;
    _os_log_error_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_ERROR, "VCRC [%s] %s:%d statisticsCollector[%p] Failed to create the entry. requestType=%d handlerType=%d", buf, 0x32u);
    return 0;
  }
  return result;
}

void AVCStatisticsCollector_SetVCStatistics(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  NSObject *v7;
  int v8;
  uint64_t v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a1 && a2)
  {
    if (*(_BYTE *)(a2 + 17))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v4 = VRTraceErrorLogLevelToCSTR();
        v5 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v8 = 136315906;
          v9 = v4;
          v10 = 2080;
          v11 = "AVCStatisticsCollector_SetVCStatistics";
          v12 = 1024;
          v13 = 420;
          v14 = 2048;
          v15 = a1;
          _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d statisticsCollector=%p should flush all message", (uint8_t *)&v8, 0x26u);
        }
      }
      VCStatisticsCollectorQueue_FlushAllStatistics(*(_QWORD *)(a1 + 40));
    }
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 1088));
    if (*(_BYTE *)(a1 + 73))
    {
      if (*(_BYTE *)(a2 + 16))
      {
LABEL_10:
        _AVCStatisticsCollector_ProcessVCStatisticsInternal(a1, (unsigned int *)a2);
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1088));
        return;
      }
      if (*(_BYTE *)(a2 + 18)
        && *(_BYTE *)(a1 + 72)
        && objc_msgSend((id)a1, "shouldProcessAtTime:", *(double *)(a2 + 8)))
      {
        VCStatisticsCollectorQueue_DrainAndProcessAllStatistics(*(_QWORD *)(a1 + 40));
        goto LABEL_10;
      }
    }
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1088));
    VCStatisticsCollectorQueue_AddStatisticsMessage(*(_QWORD *)(a1 + 40), a2);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v6 = VRTraceErrorLogLevelToCSTR();
    v7 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      v8 = 136316162;
      v9 = v6;
      v10 = 2080;
      v11 = "AVCStatisticsCollector_SetVCStatistics";
      v12 = 1024;
      v13 = 416;
      v14 = 2048;
      v15 = a1;
      v16 = 2048;
      v17 = a2;
      _os_log_error_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_ERROR, "VCRC [%s] %s:%d Invalid parameter. statisticsCollector=%p message=%p", (uint8_t *)&v8, 0x30u);
    }
  }
}

void _AVCStatisticsCollector_GetVCStatisticsWithType(uint64_t a1, int a2, uint64_t a3, double a4)
{
  int *v4;
  uint64_t v8;
  pthread_rwlock_t *v9;
  int v10;
  pthread_rwlock_t *v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  NSObject *v17;
  unint64_t v18;
  pthread_rwlock_t *v19;

  v4 = (int *)(a1 + 68);
  v8 = *(_QWORD *)(a1 + 8);
  switch(*(_DWORD *)(a1 + 68))
  {
    case 1:
    case 2:
    case 3:
      switch(a2)
      {
        case 10:
          v11 = (pthread_rwlock_t *)(a1 + 144);
          pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 144));
          *(_DWORD *)a3 = 10;
          *(_DWORD *)(a3 + 24) = *(_DWORD *)(v8 + 464);
          *(_DWORD *)(a3 + 64) = *(_DWORD *)(v8 + 504);
          goto LABEL_20;
        case 3:
          v11 = (pthread_rwlock_t *)(a1 + 144);
          pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 144));
          *(_DWORD *)a3 = 3;
          *(double *)(a3 + 8) = a4;
          *(_DWORD *)(a3 + 56) = *(_DWORD *)(v8 + 208);
          *(_DWORD *)(a3 + 48) = *(_DWORD *)(v8 + 200);
          *(_QWORD *)(a3 + 24) = *(_QWORD *)(v8 + 176);
          *(_DWORD *)(a3 + 52) = *(_DWORD *)(v8 + 204);
          *(_DWORD *)(a3 + 64) = *(_DWORD *)(v8 + 216);
          *(_DWORD *)(a3 + 60) = *(_DWORD *)(v8 + 212);
          goto LABEL_20;
        case 2:
          v9 = (pthread_rwlock_t *)(a1 + 144);
          pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 144));
          *(_DWORD *)a3 = 2;
          *(_QWORD *)(a3 + 8) = *(_QWORD *)(v8 + 376);
          *(_DWORD *)(a3 + 68) = *(_DWORD *)v8;
          *(_DWORD *)(a3 + 32) = *(_DWORD *)(a1 + 76) / 0x3E8u;
          *(_DWORD *)(a3 + 52) = *(_DWORD *)(v8 + 364);
          *(_DWORD *)(a3 + 56) = *(_DWORD *)(v8 + 420);
          *(_DWORD *)(a3 + 60) = *(_DWORD *)(v8 + 424) + *(_DWORD *)(v8 + 368);
          *(_DWORD *)(a3 + 44) = *(_DWORD *)(a1 + 92);
          *(_DWORD *)(a3 + 40) = *(_DWORD *)(a1 + 88);
          *(_QWORD *)(a3 + 80) = *(_QWORD *)(a1 + 128);
          if (*(_DWORD *)(v8 + 4))
            v10 = *(_DWORD *)(v8 + 44);
          else
            v10 = -1;
          *(_DWORD *)(a3 + 24) = v10;
          *(_WORD *)(a3 + 188) = *(_WORD *)(v8 + 164);
          *(_WORD *)(a3 + 190) = *(_WORD *)(v8 + 166);
          goto LABEL_23;
      }
      break;
    case 4:
    case 5:
      if (a2 == 5)
      {
        v11 = (pthread_rwlock_t *)(a1 + 144);
        pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 144));
        *(_DWORD *)a3 = 5;
        v12 = *(_OWORD *)(v8 + 256);
        *(_OWORD *)(a3 + 24) = *(_OWORD *)(v8 + 240);
        *(_OWORD *)(a3 + 40) = v12;
        v14 = *(_OWORD *)(v8 + 288);
        v13 = *(_OWORD *)(v8 + 304);
        v15 = *(_QWORD *)(v8 + 320);
        *(_OWORD *)(a3 + 56) = *(_OWORD *)(v8 + 272);
        *(_QWORD *)(a3 + 104) = v15;
        *(_OWORD *)(a3 + 88) = v13;
        *(_OWORD *)(a3 + 72) = v14;
LABEL_20:
        v19 = v11;
        goto LABEL_24;
      }
      break;
    case 7:
      if (a2 == 2)
      {
        v9 = (pthread_rwlock_t *)(a1 + 144);
        pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 144));
        *(_DWORD *)a3 = 2;
        *(_DWORD *)(a3 + 68) = *(_DWORD *)(v8 + 244);
        *(_QWORD *)(a3 + 80) = *(_QWORD *)(v8 + 288);
        *(_DWORD *)(a3 + 32) = *(_DWORD *)(a1 + 76) / 0x3E8u;
        v18 = MicroToNTP(a4);
        *(_DWORD *)(a3 + 24) = (unsigned __int16)(NTPToMiddle32(v18) >> 6);
        *(_DWORD *)(a3 + 52) = *(_DWORD *)(v8 + 256);
        *(_DWORD *)(a3 + 40) = *(_DWORD *)(a1 + 88);
        goto LABEL_16;
      }
      break;
    case 8:
    case 9:
      if (a2 == 7)
      {
        v9 = (pthread_rwlock_t *)(a1 + 144);
        pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 144));
        *(_DWORD *)a3 = 7;
        *(_DWORD *)(a3 + 28) = *(_DWORD *)(v8 + 412);
        *(_QWORD *)(a3 + 48) = *(_QWORD *)(v8 + 432);
        *(_DWORD *)(a3 + 36) = *(_DWORD *)(v8 + 420);
        *(_QWORD *)(a3 + 56) = *(_QWORD *)(v8 + 440);
        *(_DWORD *)(a3 + 72) = *(_DWORD *)(a1 + 76) / 0x3E8u;
        *(_DWORD *)(a3 + 76) = *(_DWORD *)(a1 + 88);
LABEL_16:
        *(_DWORD *)(a1 + 88) = 0;
LABEL_23:
        v19 = v9;
LABEL_24:
        pthread_rwlock_unlock(v19);
      }
      break;
    default:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v16 = VRTraceErrorLogLevelToCSTR();
        v17 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _AVCStatisticsCollector_GetVCStatisticsWithType_cold_1(v16, v4, v17);
      }
      break;
  }
}

void VCStatisticsCollector_EnableBWELogDump(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    VCRateControlBandwidthEstimatorMap_EnableBWELogDump(*(_QWORD *)(a1 + 16), a2);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCStatisticsCollector_EnableBWELogDump_cold_1();
  }
}

uint64_t VCStatisticsCollector_Mode(uint64_t a1)
{
  uint64_t result;

  if (a1)
    return *(unsigned int *)(a1 + 68);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    VCStatisticsCollector_Mode_cold_1();
  }
  return 0;
}

void VCStatisticsCollector_SetMode(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    *(_DWORD *)(a1 + 68) = a2;
    objc_msgSend(*(id *)(a1 + 16), "setMode:", a2);
    objc_msgSend(*(id *)(a1 + 24), "setMode:", a2);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCStatisticsCollector_SetMode_cold_1();
  }
}

void VCStatisticsCollector_SetFastSuddenBandwidthDetectionEnabled(uint64_t a1, char a2)
{
  if (a1)
  {
    *(_BYTE *)(a1 + 113) = a2;
    VCRateControlBandwidthEstimatorMap_SetFastSuddenBandwidthDetectionEnabled(*(_QWORD *)(a1 + 16), a2);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCStatisticsCollector_SetFastSuddenBandwidthDetectionEnabled_cold_1();
  }
}

void VCStatisticsCollector_SetRadioAccessTechnology(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    *(_DWORD *)(a1 + 64) = a2;
    VCRateControlBandwidthEstimatorMap_SetRadioAccessTechnology(*(_QWORD *)(a1 + 16), a2);
    VCRateControlBandwidthEstimatorMap_SetEstimatedBandwidth(*(_QWORD *)(a1 + 16), 0.0);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCStatisticsCollector_SetRadioAccessTechnology_cold_1();
  }
}

uint64_t VCStatisticsCollector_SharedEstimatedBandwidth(uint64_t a1)
{
  uint64_t result;

  if (a1)
    return *(unsigned int *)(a1 + 76);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    VCStatisticsCollector_SharedEstimatedBandwidth_cold_1();
  }
  return 0;
}

void *VCRateControlGetBWEstimation(void *result, _DWORD *a2)
{
  if (a2)
  {
    result = (void *)objc_msgSend(result, "sharedEstimatedBandwidth");
    *a2 = (_DWORD)result;
  }
  return result;
}

void VCRateControlGetStatistics(uint64_t a1, int a2, uint64_t a3)
{
  double v6;

  if (a1)
  {
    if (a3)
    {
      v6 = micro();
      _AVCStatisticsCollector_GetVCStatisticsWithType(a1, a2, a3, v6);
    }
  }
}

uint64_t VCRateControlRegisterStatisticsChangeHandler(void *a1, uint64_t a2, uint64_t a3)
{
  if ((_DWORD)a2 && a1 && a3)
    return objc_msgSend(a1, "registerStatisticsChangeHandlerWithType:handler:", a2, a3);
  else
    return 0xFFFFFFFFLL;
}

uint64_t VCRateControlUnregisterStatisticsChangeHandler(void *a1, uint64_t a2, uint64_t a3)
{
  if (!a1 || (a3 & 0x80000000) != 0)
    return 0;
  else
    return objc_msgSend(a1, "unregisterStatisticsChangeHandlerWithType:handlerIndex:", a2, a3);
}

void _AVCStatisticsCollector_DestroyChangeHandlerEntry(uint64_t a1, _QWORD **a2)
{
  _QWORD *v2;
  const void *v4;

  if (a2)
  {
    v2 = *a2;
    *a2 = 0;
    if (v2)
    {
      v4 = (const void *)v2[2];
      if (v4)
        _Block_release(v4);
      CFAllocatorDeallocate(*(CFAllocatorRef *)(a1 + 344), v2);
    }
  }
}

void _AVCStatisticsCollector_DestroyChangeHandlerRequest(uint64_t a1, void **a2)
{
  _QWORD *v3;
  _QWORD *v5;

  if (a2)
  {
    v3 = *a2;
    if (*a2)
    {
      v5 = (_QWORD *)v3[1];
      *v5 = *v3;
      *(_QWORD *)(*v3 + 8) = v5;
      *v3 = v3;
      v3[1] = v3;
      _AVCStatisticsCollector_DestroyChangeHandlerEntry(a1, (_QWORD **)v3 + 3);
      CFAllocatorDeallocate(*(CFAllocatorRef *)(a1 + 1040), v3);
      *a2 = 0;
    }
  }
}

void _AVCStatisticsCollector_UpdateMaxLocalBurstyLoss(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  unsigned int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (a3)
  {
    if (!a2 && !*(_DWORD *)(a1 + 92))
    {
      v12 = 0;
      v11 = 92;
      goto LABEL_23;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v6 = *MEMORY[0x1E0CF2758];
      v7 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          v13 = 136315906;
          v14 = v5;
          v15 = 2080;
          v16 = "_AVCStatisticsCollector_UpdateMaxLocalBurstyLoss";
          v17 = 1024;
          v18 = 861;
          v19 = 1024;
          v20 = a2;
          _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d update audio loss: %d", (uint8_t *)&v13, 0x22u);
        }
      }
      else if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        _AVCStatisticsCollector_UpdateMaxLocalBurstyLoss_cold_1();
      }
    }
    v11 = 92;
    if (!a2)
      goto LABEL_17;
  }
  else
  {
    if (!a2 && !*(_DWORD *)(a1 + 88))
    {
      v12 = 0;
      v11 = 88;
      goto LABEL_23;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v8 = VRTraceErrorLogLevelToCSTR();
      v9 = *MEMORY[0x1E0CF2758];
      v10 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          v13 = 136315906;
          v14 = v8;
          v15 = 2080;
          v16 = "_AVCStatisticsCollector_UpdateMaxLocalBurstyLoss";
          v17 = 1024;
          v18 = 866;
          v19 = 1024;
          v20 = a2;
          _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d update video loss: %d", (uint8_t *)&v13, 0x22u);
        }
      }
      else if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        _AVCStatisticsCollector_UpdateMaxLocalBurstyLoss_cold_2();
      }
    }
    v11 = 88;
    if (!a2)
    {
LABEL_17:
      v12 = 0;
      goto LABEL_23;
    }
  }
  v12 = *(_DWORD *)(a1 + v11);
  if (v12 <= a2)
    v12 = a2;
LABEL_23:
  *(_DWORD *)(a1 + v11) = v12;
}

void _AVCStatisticsCollector_UpdatePacketReceivedCount(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  int v6;
  int v7;
  int v8;
  int v9;
  __int16 v10;
  unsigned int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  unint64_t v16;
  uint64_t v17;
  NSObject *v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  int v31;
  __int16 v32;
  int v33;
  __int16 v34;
  int v35;
  __int16 v36;
  int v37;
  __int16 v38;
  int v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 140))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v4 = VRTraceErrorLogLevelToCSTR();
      v5 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v6 = *(_DWORD *)(a1 + 96);
        v7 = *(_DWORD *)(a2 + 52);
        v24 = 136316162;
        v25 = v4;
        v26 = 2080;
        v27 = "_AVCStatisticsCollector_UpdatePacketReceivedCount";
        v28 = 1024;
        v29 = 837;
        v30 = 1024;
        v31 = v6;
        v32 = 1024;
        v33 = v7;
        _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Reset remotePAcketReceivedAudio from current=%d to feedback=%d", (uint8_t *)&v24, 0x28u);
      }
    }
    v8 = *(_DWORD *)(a2 + 52);
    *(_DWORD *)(a1 + 96) = v8;
    *(_BYTE *)(a1 + 140) = 0;
  }
  else
  {
    v8 = *(_DWORD *)(a1 + 96);
  }
  v9 = *(_DWORD *)(a2 + 52);
  v10 = v9 - v8;
  if ((((_WORD)v9 - (_WORD)v8) & 0x800) == 0)
  {
    if ((v8 & 0xFFFu) > (unsigned __int16)v9)
      v8 += 4096;
    *(_DWORD *)(a1 + 96) = v8 & 0xFFFFF000 | (unsigned __int16)*(_DWORD *)(a2 + 52);
  }
  if (VCMediaControlInfo_IsLossStatsEnabled(*(unsigned __int8 *)(a1 + 112)))
  {
    v11 = *(_DWORD *)(a2 + 56);
LABEL_18:
    *(_DWORD *)(a1 + 100) = v11;
    goto LABEL_19;
  }
  v12 = *(_DWORD *)(a2 + 56);
  v13 = *(_DWORD *)(a1 + 100);
  if (((v12 - v13) & 0x800) == 0)
  {
    if ((*(_DWORD *)(a1 + 100) & 0xFFFu) <= (unsigned __int16)v12)
      v14 = *(_DWORD *)(a1 + 100);
    else
      v14 = v13 + 4096;
    v11 = v14 & 0xFFFFF000 | (unsigned __int16)*(_DWORD *)(a2 + 56);
    goto LABEL_18;
  }
LABEL_19:
  if ((v10 & 0x800) != 0)
  {
    v15 = *(_DWORD *)(a1 + 136);
    *(_DWORD *)(a1 + 136) = v15 + 1;
    HIDWORD(v16) = -1030792151 * v15;
    LODWORD(v16) = -1030792151 * v15;
    if ((v16 >> 1) <= 0x51EB851 && (int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v17 = VRTraceErrorLogLevelToCSTR();
      v18 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v19 = *(_DWORD *)(a1 + 136);
        v21 = *(_DWORD *)(a1 + 96);
        v20 = *(_DWORD *)(a1 + 100);
        v23 = *(_DWORD *)(a2 + 52);
        v22 = *(_DWORD *)(a2 + 56);
        v24 = 136316930;
        v25 = v17;
        v26 = 2080;
        v27 = "_AVCStatisticsCollector_UpdatePacketReceivedCount";
        v28 = 1024;
        v29 = 851;
        v30 = 1024;
        v31 = v19;
        v32 = 1024;
        v33 = v20;
        v34 = 1024;
        v35 = v22;
        v36 = 1024;
        v37 = v21;
        v38 = 1024;
        v39 = v23;
        _os_log_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Feedback out of order count=%d with packet receive count video:[current=%d, feedback=%d], audio:[current=%d, feedback=%d]", (uint8_t *)&v24, 0x3Au);
      }
    }
  }
  *(_DWORD *)(a2 + 52) = *(_DWORD *)(a1 + 96);
  *(_DWORD *)(a2 + 56) = *(_DWORD *)(a1 + 100);
}

void _AVCStatisticsCollector_ComputeBWEstimation(uint64_t a1, double *a2)
{
  double v4;
  int v5;
  uint64_t v7;
  uint64_t v8;
  double v9;
  unsigned int v10;
  unsigned int v12;
  int v13;
  double v14;
  unsigned int *v15;
  int v16;
  unsigned int v17;
  int v18;
  unsigned int *v19;
  int v20;
  unsigned int v21;
  int v22;
  int v23;
  int v24;
  unsigned int v25;
  int v26;
  uint64_t v27;

  v4 = a2[1];
  v5 = *(_DWORD *)a2;
  if (*(_DWORD *)(a1 + 68) == 4 && v5 == 5)
  {
    v8 = VCRateControlBandwidthEstimatorMap_BandwidthEstimator(*(_QWORD *)(a1 + 16), 1, 1, 0);
    VCRateControlBandwidthEstimator_CalculateBandwidthEstimationForBandwidthSample(v8, (double)(1000 * *((_DWORD *)a2 + 14)), v4);
  }
  else if (v5 == 4)
  {
    v7 = *((unsigned int *)a2 + 6);
    if (*((_BYTE *)a2 + 28))
    {
      VCRateControlBandwidthEstimatorMap_DeregisterBandwidthEstimator(*(_QWORD *)(a1 + 16), v7);
      return;
    }
    v22 = *((unsigned __int8 *)a2 + 30);
    v23 = *((unsigned __int8 *)a2 + 29);
    v24 = *((_DWORD *)a2 + 8);
    v25 = *((_DWORD *)a2 + 9);
    v26 = *((_DWORD *)a2 + 12);
    v27 = VCRateControlBandwidthEstimatorMap_BandwidthEstimator(*(_QWORD *)(a1 + 16), v7, v23, v22);
    VCRateControlBandwidthEstimator_CalculateBandwidthEstimation(v27, v26, v25, v23, v24, v4);
  }
  if (*(_DWORD *)(a1 + 68) != 5)
  {
    objc_msgSend(*(id *)(a1 + 16), "estimatedBandwidth");
    v10 = *(_DWORD *)(a1 + 104);
    if (v10 >= v9 || v10 == 0)
      v12 = v9;
    else
      v12 = *(_DWORD *)(a1 + 104);
    v13 = objc_msgSend(*(id *)(a1 + 16), "bandwidthEstimationState");
    if (v12)
      v12 = 1000 * ((v12 / 0x3E8) & 0x7FFFF8 | (v13 == 1));
    objc_msgSend(*(id *)(a1 + 16), "estimatedBandwidthUncapped");
    v15 = (unsigned int *)(a1 + 76);
    v16 = *(_DWORD *)(a1 + 76);
    while (1)
    {
      v17 = __ldxr(v15);
      if (v17 != v16)
        break;
      if (!__stxr(v12, v15))
        goto LABEL_23;
    }
    __clrex();
LABEL_23:
    v20 = *(_DWORD *)(a1 + 80);
    v19 = (unsigned int *)(a1 + 80);
    v18 = v20;
    while (1)
    {
      v21 = __ldxr(v19);
      if (v21 != v18)
        break;
      if (!__stxr(v14, v19))
        return;
    }
    __clrex();
  }
}

void OUTLINED_FUNCTION_4_1(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_debug_impl(a1, log, OS_LOG_TYPE_DEBUG, a4, (uint8_t *)va, 0x22u);
}

_BYTE *fuzz_packet(_BYTE *result, int a2)
{
  uint64_t i;

  if ((a2 & 1) != 0)
    *result = ~*result;
  for (i = 0; i != 15; ++i)
  {
    if ((a2 & 2) != 0)
      result[i + 1] ^= result[i];
    a2 >>= 1;
  }
  return result;
}

ssize_t comm_send(int a1, const sockaddr *a2, __int128 *a3)
{
  signed int v5;
  __int128 v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v7 = *a3;
  LOWORD(v7) = bswap32((unsigned __int16)v7) >> 16;
  WORD1(v7) = bswap32(WORD1(v7)) >> 16;
  DWORD2(v7) = bswap32(~DWORD2(v7));
  WORD6(v7) = bswap32(~WORD6(v7)) >> 16;
  HIWORD(v7) = bswap32(~HIWORD(v7)) >> 16;
  v5 = arc4random();
  if (v5 % 100 < 0)
    fuzz_packet(&v7, v5 >> 4);
  return sendto(a1, &v7, 0x10uLL, 0, a2, a2->sa_len);
}

uint64_t CommTest(uint64_t a1, double a2)
{
  sockaddr v4;
  double v5;
  char v6;
  uint32_t v7;
  int v8;
  int v9;
  int v10;
  int v11;
  double v12;
  char v13;
  char v14;
  double v15;
  int v16;
  int v17;
  int v18;
  int v19;
  __int128 v20;
  unsigned int v21;
  int v22;
  int v23;
  int v24;
  NSObject *v25;
  int v26;
  int v27;
  int v28;
  char v29;
  uint64_t v30;
  NSObject *v31;
  const char *v32;
  NSObject *v33;
  uint32_t v34;
  uint64_t v35;
  NSObject *v36;
  int v37;
  uint64_t v39;
  int v40;
  uint64_t v41;
  unsigned int v42;
  unint64_t v43;
  unint64_t v44;
  __int128 v45;
  socklen_t v46[5];
  _BYTE buf[48];
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  sockaddr v53;
  sockaddr v54;
  sockaddr v55;
  sockaddr v56;
  sockaddr v57;
  sockaddr v58;
  sockaddr v59;
  sockaddr v60;
  fd_set v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v4.sa_len = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v4.sa_data[6] = 0xAAAAAAAAAAAAAAAALL;
  *(sockaddr *)&v61.fds_bits[24] = v4;
  *(sockaddr *)&v61.fds_bits[28] = v4;
  *(sockaddr *)&v61.fds_bits[16] = v4;
  *(sockaddr *)&v61.fds_bits[20] = v4;
  *(sockaddr *)&v61.fds_bits[8] = v4;
  *(sockaddr *)&v61.fds_bits[12] = v4;
  *(sockaddr *)v61.fds_bits = v4;
  *(sockaddr *)&v61.fds_bits[4] = v4;
  memset(v46, 170, sizeof(v46));
  v59 = v4;
  v60 = v4;
  v57 = v4;
  v58 = v4;
  v55 = v4;
  v56 = v4;
  v53 = v4;
  v54 = v4;
  v43 = 0xAAAAAAAAAAAAAAAALL;
  v44 = 0xAAAAAAAAAAAAAAAALL;
  v5 = micro();
  if (a2 <= 0.0)
    a2 = 6.0;
  v6 = 0;
  v7 = arc4random() & 0xFFFFF000;
  v8 = v7 ^ 0x55555000;
  v42 = v7 ^ 0xAAAAA000;
  v45 = 0x10001uLL;
  v9 = 1;
  v10 = 1;
  v11 = 1;
  while (1)
  {
    if (micro() - v5 >= a2)
      return 0;
    if (!*(_DWORD *)(a1 + 136) || !*(_DWORD *)(a1 + 436))
    {
      DWORD1(v45) = v7;
      comm_send(*(_DWORD *)a1, (const sockaddr *)(a1 + 8), &v45);
    }
    if (!*(_DWORD *)(a1 + 280) || !*(_DWORD *)(a1 + 448))
    {
      DWORD1(v45) = v7 ^ 0x55555000;
      comm_send(*(_DWORD *)a1, (const sockaddr *)(a1 + 152), &v45);
    }
    if (!*(_DWORD *)(a1 + 424) || !*(_DWORD *)(a1 + 460))
    {
      DWORD1(v45) = v7 ^ 0xAAAAA000;
      comm_send(*(_DWORD *)a1, (const sockaddr *)(a1 + 296), &v45);
    }
    v6 += (v11 & v10 & v9 & 1) == 0;
    v12 = micro() - v5;
    if (v12 < a2)
      break;
    LOBYTE(v10) = 0;
    v14 = 0;
    v13 = 0;
LABEL_70:
    v29 = 1;
LABEL_71:
    v11 = v10;
    v10 = v14 & 1;
    v9 = v13 & 1;
    if ((v29 & 1) == 0)
      return 0;
  }
  v13 = 0;
  v14 = 0;
  LOBYTE(v10) = 0;
  while (1)
  {
    v15 = a2 - v12;
    if (v15 >= (double)(2 << v6))
      v15 = (double)(2 << v6);
    *(_QWORD *)&v46[1] = (uint64_t)v15;
    v46[3] = (int)((v15 - (double)(uint64_t)v15) * 1000000.0);
    memset(&v61, 0, sizeof(v61));
    v16 = *(_DWORD *)a1;
    if (__darwin_check_fd_set_overflow(*(_DWORD *)a1, &v61, 0))
      *(__int32_t *)((char *)v61.fds_bits + (((unint64_t)v16 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v16;
    v17 = select(*(_DWORD *)a1 + 1, &v61, 0, 0, (timeval *)&v46[1]);
    if (v17 < 0)
    {
      if (*__error() == 4)
      {
        if (a2 > micro() - v5)
          goto LABEL_70;
        goto LABEL_67;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() < 7)
        return 1;
      v39 = VRTraceErrorLogLevelToCSTR();
      v36 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        return 1;
      v40 = *__error();
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = v39;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "CommTest";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 269;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = v40;
      v32 = " [%s] %s:%d CommTest: select() failed (%d)";
LABEL_84:
      v33 = v36;
      v34 = 34;
      goto LABEL_85;
    }
    if (!v17)
      goto LABEL_70;
    v46[0] = 128;
    v18 = recvfrom(*(_DWORD *)a1, &v43, 0x10uLL, 0, &v53, v46);
    if (!v18)
      break;
    if (v18 == -1)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 7)
        return 1;
      v35 = VRTraceErrorLogLevelToCSTR();
      v36 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        return 1;
      v37 = *__error();
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = v35;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "CommTest";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 280;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = v37;
      v32 = " [%s] %s:%d CommTest: recvfrom() failed (%d)";
      goto LABEL_84;
    }
    WORD1(v43) = bswap32(WORD1(v43)) >> 16;
    LOWORD(v43) = bswap32((unsigned __int16)v43) >> 16;
    v19 = HIDWORD(v43);
    LODWORD(v44) = bswap32(~(_DWORD)v44);
    WORD2(v44) = bswap32(~WORD2(v44)) >> 16;
    if (!*(_DWORD *)(a1 + 472) && (HIDWORD(v43) == v42 || HIDWORD(v43) == v7 || HIDWORD(v43) == v8))
    {
      *(_QWORD *)&v20 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v51 = v20;
      v52 = v20;
      v50 = v20;
      v48 = v20;
      v49 = v20;
      *(_OWORD *)&buf[16] = v20;
      *(_OWORD *)&buf[32] = v20;
      *(_OWORD *)buf = v20;
      DWORD1(v45) = v7 ^ 0xFFFFF000;
      FillSockAddrStorage();
      comm_send(*(_DWORD *)a1, (const sockaddr *)buf, &v45);
      v19 = HIDWORD(v43);
    }
    v21 = v19 & 0xFFFFF000;
    if (v21 == v7)
    {
      v22 = IsSameAddressAndPort();
      v23 = v44;
      if (v22)
      {
        *(_WORD *)(a1 + 144) = WORD2(v44);
        v24 = *(_DWORD *)(a1 + 136) + 1;
        *(_DWORD *)(a1 + 136) = v24;
        *(_DWORD *)(a1 + 140) = v23;
        LOBYTE(v10) = 1;
        if (!v24)
          goto LABEL_67;
        goto LABEL_51;
      }
      *(_DWORD *)(a1 + 440) = v44;
      *(_WORD *)(a1 + 444) = WORD2(v44);
      ++*(_DWORD *)(a1 + 436);
    }
    else if (v21 == v8)
    {
      if (IsSameAddressAndPort())
      {
        *(_DWORD *)(a1 + 284) = v44;
        *(_WORD *)(a1 + 288) = WORD2(v44);
        ++*(_DWORD *)(a1 + 280);
        v14 = 1;
      }
      else
      {
        *(_DWORD *)(a1 + 452) = v44;
        *(_WORD *)(a1 + 456) = WORD2(v44);
        ++*(_DWORD *)(a1 + 448);
      }
    }
    else if (v21 == v42)
    {
      if (IsSameAddressAndPort())
      {
        *(_DWORD *)(a1 + 428) = v44;
        *(_WORD *)(a1 + 432) = WORD2(v44);
        ++*(_DWORD *)(a1 + 424);
        v13 = 1;
      }
      else
      {
        *(_DWORD *)(a1 + 464) = v44;
        *(_WORD *)(a1 + 468) = WORD2(v44);
        ++*(_DWORD *)(a1 + 460);
      }
    }
    else if (v21 == (v7 ^ 0xFFFFF000))
    {
      ++*(_DWORD *)(a1 + 472);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v41 = VRTraceErrorLogLevelToCSTR();
      v25 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = v41;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "CommTest";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 366;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = HIDWORD(v43);
        _os_log_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d CommTest: bad seq# %08X.", buf, 0x22u);
      }
    }
    v24 = *(_DWORD *)(a1 + 136);
    if (!v24)
      goto LABEL_67;
LABEL_51:
    v26 = *(_DWORD *)(a1 + 436);
    if (v26
      && *(_DWORD *)(a1 + 280)
      && *(_DWORD *)(a1 + 448)
      && *(_DWORD *)(a1 + 424)
      && *(_DWORD *)(a1 + 460)
      && *(_DWORD *)(a1 + 472))
    {
LABEL_73:
      v29 = 0;
      goto LABEL_71;
    }
    if (v24 < 4)
    {
      if (v24 != 3)
        goto LABEL_67;
      v27 = *(_DWORD *)(a1 + 280);
LABEL_63:
      if (v27 < 3)
        goto LABEL_67;
      v28 = *(_DWORD *)(a1 + 424);
      goto LABEL_65;
    }
    v27 = *(_DWORD *)(a1 + 280);
    if (v27 <= 3)
      goto LABEL_63;
    v28 = *(_DWORD *)(a1 + 424);
    if (v28 > 3)
      goto LABEL_73;
LABEL_65:
    if (v28 >= 3 && v28 + v24 + v27 + v26 + *(_DWORD *)(a1 + 448) + *(_DWORD *)(a1 + 460) > 15)
      goto LABEL_73;
LABEL_67:
    v12 = micro() - v5;
    if (v12 >= a2)
      goto LABEL_70;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v30 = VRTraceErrorLogLevelToCSTR();
    v31 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = v30;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "CommTest";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 283;
      v32 = " [%s] %s:%d CommTest: recvfrom() returns 0";
      v33 = v31;
      v34 = 28;
LABEL_85:
      _os_log_impl(&dword_1D8A54000, v33, OS_LOG_TYPE_DEFAULT, v32, buf, v34);
    }
  }
  return 1;
}

uint64_t CommReport(int *a1, unsigned int a2, double a3)
{
  sockaddr v6;
  double v7;
  double v8;
  uint64_t result;
  int v10;
  const sockaddr *v11;
  unsigned int v12;
  const sockaddr *v13;
  double v14;
  int v15;
  double v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  NSObject *v21;
  const char *v22;
  NSObject *v23;
  uint32_t v24;
  uint64_t v25;
  NSObject *v26;
  int v27;
  uint64_t v28;
  int v29;
  unint64_t v30;
  unint64_t v31;
  __int128 v32;
  socklen_t v33[5];
  uint8_t buf[4];
  uint64_t v35;
  __int16 v36;
  const char *v37;
  __int16 v38;
  int v39;
  __int16 v40;
  int v41;
  sockaddr v42;
  sockaddr v43;
  sockaddr v44;
  sockaddr v45;
  sockaddr v46;
  sockaddr v47;
  sockaddr v48;
  sockaddr v49;
  fd_set v50;
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v6.sa_len = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v6.sa_data[6] = 0xAAAAAAAAAAAAAAAALL;
  *(sockaddr *)&v50.fds_bits[24] = v6;
  *(sockaddr *)&v50.fds_bits[28] = v6;
  *(sockaddr *)&v50.fds_bits[16] = v6;
  *(sockaddr *)&v50.fds_bits[20] = v6;
  *(sockaddr *)&v50.fds_bits[8] = v6;
  *(sockaddr *)&v50.fds_bits[12] = v6;
  *(sockaddr *)v50.fds_bits = v6;
  *(sockaddr *)&v50.fds_bits[4] = v6;
  memset(v33, 170, sizeof(v33));
  v48 = v6;
  v49 = v6;
  v46 = v6;
  v47 = v6;
  v44 = v6;
  v45 = v6;
  v42 = v6;
  v43 = v6;
  v30 = 0xAAAAAAAAAAAAAAAALL;
  v31 = 0xAAAAAAAAAAAAAAAALL;
  v7 = micro();
  if (a3 <= 0.0)
    a3 = 1.0;
  LODWORD(v32) = 65538;
  DWORD1(v32) = arc4random();
  *((_QWORD *)&v32 + 1) = a2;
  v8 = micro();
  result = 0;
  if (v8 - v7 >= a3)
    return result;
  v10 = 0;
  v11 = (const sockaddr *)(a1 + 2);
  while (1)
  {
    v12 = (DWORD1(v32) + v10) % 3u;
    if (v12 == 2)
    {
      v11 = (const sockaddr *)(a1 + 74);
    }
    else
    {
      v13 = v11;
      v11 = (const sockaddr *)(a1 + 38);
      if (v12 != 1)
      {
        v11 = v13;
        if (!v12)
          v11 = (const sockaddr *)(a1 + 2);
      }
    }
    comm_send(*a1, v11, &v32);
    v14 = micro() - v7;
    if (v14 < a3)
      break;
LABEL_25:
    ++v10;
    if (micro() - v7 >= a3)
      return 0;
  }
  v15 = DWORD1(v32);
  while (1)
  {
    v16 = a3 - v14;
    if (v16 > 1.0)
      v16 = 1.0;
    *(_QWORD *)&v33[1] = (uint64_t)v16;
    v33[3] = (int)((v16 - (double)(uint64_t)v16) * 1000000.0);
    memset(&v50, 0, sizeof(v50));
    v17 = *a1;
    if (__darwin_check_fd_set_overflow(*a1, &v50, 0))
      *(__int32_t *)((char *)v50.fds_bits + (((unint64_t)v17 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v17;
    v18 = select(*a1 + 1, &v50, 0, 0, (timeval *)&v33[1]);
    if (v18 < 0)
    {
      if (*__error() == 4)
      {
        if (a3 > micro() - v7)
          goto LABEL_25;
        goto LABEL_24;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() < 7)
        return 1;
      v28 = VRTraceErrorLogLevelToCSTR();
      v26 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        return 1;
      v29 = *__error();
      *(_DWORD *)buf = 136315906;
      v35 = v28;
      v36 = 2080;
      v37 = "CommReport";
      v38 = 1024;
      v39 = 472;
      v40 = 1024;
      v41 = v29;
      v22 = " [%s] %s:%d CommTest: select() failed (%d)";
LABEL_36:
      v23 = v26;
      v24 = 34;
      goto LABEL_37;
    }
    if (!v18)
      goto LABEL_25;
    v33[0] = 128;
    v19 = recvfrom(*a1, &v30, 0x10uLL, 0, &v42, v33);
    if (!v19)
      break;
    if (v19 == -1)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 7)
        return 1;
      v25 = VRTraceErrorLogLevelToCSTR();
      v26 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        return 1;
      v27 = *__error();
      *(_DWORD *)buf = 136315906;
      v35 = v25;
      v36 = 2080;
      v37 = "CommReport";
      v38 = 1024;
      v39 = 483;
      v40 = 1024;
      v41 = v27;
      v22 = " [%s] %s:%d CommTest: recvfrom() failed (%d)";
      goto LABEL_36;
    }
    WORD1(v30) = bswap32(WORD1(v30)) >> 16;
    LOWORD(v30) = bswap32((unsigned __int16)v30) >> 16;
    LODWORD(v31) = bswap32(~(_DWORD)v31);
    WORD2(v31) = bswap32(~WORD2(v31)) >> 16;
    if (HIDWORD(v30) == v15)
      return 0;
LABEL_24:
    v14 = micro() - v7;
    if (v14 >= a3)
      goto LABEL_25;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v20 = VRTraceErrorLogLevelToCSTR();
    v21 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      v35 = v20;
      v36 = 2080;
      v37 = "CommReport";
      v38 = 1024;
      v39 = 486;
      v22 = " [%s] %s:%d CommTest: recvfrom() returns 0";
      v23 = v21;
      v24 = 28;
LABEL_37:
      _os_log_impl(&dword_1D8A54000, v23, OS_LOG_TYPE_DEFAULT, v22, buf, v24);
    }
  }
  return 1;
}

int *CommNAT_Test(int *a1, unsigned int a2, socklen_t a3, double a4, uint64_t a5, uint64_t a6, socklen_t a7)
{
  double v10;
  int v11;
  int *v12;
  int *v13;
  sockaddr v14;
  int v15;
  int v16;
  int v17;
  int *v18;
  sockaddr v19;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  int v31;
  int v32;
  BOOL v33;
  char v38;
  char v39;
  int v40;
  BOOL v42;
  char v43;
  char v44;
  int v45;
  unsigned int v46;
  unsigned int v47;
  BOOL v48;
  unsigned int v49;
  unsigned int v50;
  unsigned int v51;
  _BOOL4 v52;
  int v53;
  int v54;
  double v55;
  unsigned int v56;
  double v57;
  socklen_t v58[3];
  sockaddr v59;
  sockaddr v60;
  sockaddr v61;
  sockaddr v62;
  sockaddr v63;
  sockaddr v64;
  sockaddr v65;
  sockaddr v66;
  sockaddr v67;
  sockaddr v68;
  sockaddr v69;
  sockaddr v70;
  sockaddr v71;
  sockaddr v72;
  sockaddr v73;
  sockaddr v74;
  _OWORD v75[8];
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  uint64_t v98;

  v98 = *MEMORY[0x1E0C80C00];
  v58[1] = a7;
  v58[2] = a3;
  v10 = micro();
  v11 = *a1;
  v12 = (int *)malloc_type_malloc(0x14uLL, 0x1000040C36A4E17uLL);
  v13 = v12;
  if (!v12)
    return v13;
  *(_QWORD *)&v14.sa_len = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v14.sa_data[6] = 0xAAAAAAAAAAAAAAAALL;
  v73 = v14;
  v74 = v14;
  v71 = v14;
  v72 = v14;
  v69 = v14;
  v70 = v14;
  v67 = v14;
  v68 = v14;
  *(_QWORD *)v12 = 0;
  *((_QWORD *)v12 + 1) = 0;
  v12[4] = 0;
  v96 = 0u;
  v97 = 0u;
  v94 = 0u;
  v95 = 0u;
  v92 = 0u;
  v93 = 0u;
  v90 = 0u;
  v91 = 0u;
  v88 = 0u;
  v89 = 0u;
  v86 = 0u;
  v87 = 0u;
  v84 = 0u;
  v85 = 0u;
  v82 = 0u;
  v83 = 0u;
  v80 = 0u;
  v81 = 0u;
  v78 = 0u;
  v79 = 0u;
  v76 = 0u;
  v77 = 0u;
  memset(v75, 0, sizeof(v75));
  if ((v11 & 1) != 0)
    v15 = 30;
  else
    v15 = 2;
  FillSockAddrStorage();
  FillSockAddrStorage();
  FillSockAddrStorage();
  v16 = socket(v15, 2, 17);
  LODWORD(v75[0]) = v16;
  if (v16 == -1)
  {
    free(v13);
    v18 = __error();
    printf("socket() failed (%d)\n", *v18);
    return 0;
  }
  *(_DWORD *)&v59.sa_len = 1;
  setsockopt(v16, 0xFFFF, 4130, &v59, 4u);
  FillSockAddrStorage();
  v17 = bind(v75[0], &v67, v67.sa_len);
  if (a2 && v17)
  {
    FillSockAddrStorage();
    if (!bind(v75[0], &v67, v67.sa_len))
      goto LABEL_14;
LABEL_12:
    free(v13);
    __error();
    printf("socket() failed (%d)\n");
LABEL_16:
    close(v75[0]);
    return 0;
  }
  if (v17)
    goto LABEL_12;
  if (!a2)
  {
LABEL_14:
    *(_QWORD *)&v19.sa_len = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)&v19.sa_data[6] = 0xAAAAAAAAAAAAAAAALL;
    v65 = v19;
    v66 = v19;
    v63 = v19;
    v64 = v19;
    v61 = v19;
    v62 = v19;
    v59 = v19;
    v60 = v19;
    v58[0] = 128;
    if (getsockname(v75[0], &v59, v58))
    {
      free(v13);
      __error();
      printf("getsockname() failed (%d)\n");
      goto LABEL_16;
    }
    a2 = bswap32(*(unsigned __int16 *)v59.sa_data) >> 16;
  }
  CommTest((uint64_t)v75, a4);
  v21 = DWORD1(v95);
  v22 = DWORD2(v76);
  v23 = DWORD2(v85);
  v24 = v96;
  v25 = DWORD2(v94);
  v26 = HIDWORD(v96);
  if (!DWORD2(v76) && !DWORD1(v95) && !DWORD2(v85) && !(_DWORD)v96 && !DWORD2(v94) && !HIDWORD(v96))
  {
    free(v13);
    goto LABEL_16;
  }
  v13[1] = HIDWORD(v76);
  v27 = (unsigned __int16)v77;
  *((_WORD *)v13 + 4) = v77;
  v28 = (unsigned __int16)v86;
  *((_WORD *)v13 + 5) = v86;
  v29 = (unsigned __int16)v95;
  *((_WORD *)v13 + 6) = v95;
  v30 = *v13;
  if (!v22 || !v23 || !v25)
  {
    v30 |= 1u;
    *v13 = v30;
  }
  if (v27 == v28 && v27 == v29)
  {
    v31 = v30;
  }
  else
  {
    v31 = v30 | 4;
    *v13 = v30 | 4;
    if (v27 != v28)
    {
      v31 = v30 | 0xC;
      *v13 = v30 | 0xC;
    }
  }
  v32 = v31 | 0x100;
  if (!DWORD2(v97))
    v32 = v31;
  if (v22)
    v33 = v21 == 0;
  else
    v33 = 1;
  v38 = !v33 && v23 != 0 && v24 != 0 && v25 != 0 && v26 != 0;
  v39 = v38 & ((v32 & 4) == 0);
  if (v39)
    v40 = v32 | 2;
  else
    v40 = v32;
  v42 = a2 == v27 || a2 == v28 || a2 == v29;
  v43 = v42;
  if (v42)
    v40 |= 0x10u;
  v44 = v39 | v43;
  if (DWORD2(v97) || (v44 & 1) != 0)
  {
    if ((v44 & 1) != 0)
      v45 = v40;
    else
      v45 = v32;
    *v13 = v45;
  }
  if ((v40 & 4) != 0)
  {
    v46 = v28 - v27;
    if (v27 > v28)
      v46 = v27 - v28;
    v47 = v29 - v28;
    v48 = v28 >= v29;
    v49 = v28 - v29;
    if (v49 == 0 || !v48)
      v49 = v47;
    v50 = v27 - v29;
    v48 = v29 >= v27;
    v51 = v29 - v27;
    if (v51 == 0 || !v48)
      v51 = v50;
    if (v46 == 1 || v49 == 1 || v51 == 1)
    {
      v40 |= 0x20u;
      *v13 = v40;
    }
  }
  v52 = (v21 | v24) != 0;
  if (!v26 || !v52)
  {
    if (v52)
      v53 = v40;
    else
      v53 = v40 | 0x40;
    if (v26)
      v54 = v53;
    else
      v54 = v53 | 0x80;
    *v13 = v54;
  }
  v55 = micro() - v10;
  if (v55 <= a4)
  {
    v57 = a4 - v55;
    v56 = *v13;
    if (v57 > 1.0)
      v57 = 1.0;
  }
  else
  {
    v56 = *v13;
    v57 = 0.1;
  }
  CommReport((int *)v75, v56, v57);
  close(v75[0]);
  return v13;
}

uint64_t VCMediaNegotiationBlobMultiwayAudioStreamReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char v14;
  BOOL v15;
  int v16;
  char v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char v24;
  uint64_t result;
  char v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  char v31;
  char v32;
  unsigned int v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  char v37;
  char v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  char v43;
  char v44;
  unsigned int v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  char v49;
  char v50;
  unsigned int v51;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;
  char v55;
  uint64_t v56;
  unint64_t v57;
  int v58;
  char v59;
  unsigned int v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  char v64;
  char v65;
  unsigned int v66;
  uint64_t v67;
  uint64_t v68;
  unint64_t v69;
  char v70;
  uint64_t v71;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        v13 = v12 + 1;
        if (v12 == -1 || v13 > *(_QWORD *)(a2 + *v4))
          break;
        v14 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v13;
        v10 |= (unint64_t)(v14 & 0x7F) << v8;
        if ((v14 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        v15 = v9++ >= 9;
        if (v15)
        {
          v10 = 0;
          v16 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v16 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v16 || (v10 & 7) == 4)
        break;
      switch((v10 >> 3))
      {
        case 1u:
          v18 = 0;
          v19 = 0;
          v20 = 0;
          while (1)
          {
            v21 = *v3;
            v22 = *(_QWORD *)(a2 + v21);
            v23 = v22 + 1;
            if (v22 == -1 || v23 > *(_QWORD *)(a2 + *v4))
              break;
            v24 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v22);
            *(_QWORD *)(a2 + v21) = v23;
            v20 |= (unint64_t)(v24 & 0x7F) << v18;
            if ((v24 & 0x80) == 0)
              goto LABEL_81;
            v18 += 7;
            v15 = v19++ >= 9;
            if (v15)
            {
              LODWORD(v20) = 0;
              goto LABEL_83;
            }
          }
          *(_BYTE *)(a2 + *v5) = 1;
LABEL_81:
          if (*(_BYTE *)(a2 + *v5))
            LODWORD(v20) = 0;
LABEL_83:
          v71 = 32;
          goto LABEL_112;
        case 2u:
          v26 = 0;
          v27 = 0;
          v20 = 0;
          *(_BYTE *)(a1 + 44) |= 2u;
          while (2)
          {
            v28 = *v3;
            v29 = *(_QWORD *)(a2 + v28);
            v30 = v29 + 1;
            if (v29 == -1 || v30 > *(_QWORD *)(a2 + *v4))
            {
              *(_BYTE *)(a2 + *v5) = 1;
            }
            else
            {
              v31 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v29);
              *(_QWORD *)(a2 + v28) = v30;
              v20 |= (unint64_t)(v31 & 0x7F) << v26;
              if (v31 < 0)
              {
                v26 += 7;
                v15 = v27++ >= 9;
                if (v15)
                {
                  LODWORD(v20) = 0;
                  goto LABEL_87;
                }
                continue;
              }
            }
            break;
          }
          if (*(_BYTE *)(a2 + *v5))
            LODWORD(v20) = 0;
LABEL_87:
          v71 = 12;
          goto LABEL_112;
        case 3u:
          v32 = 0;
          v33 = 0;
          v20 = 0;
          *(_BYTE *)(a1 + 44) |= 0x20u;
          while (2)
          {
            v34 = *v3;
            v35 = *(_QWORD *)(a2 + v34);
            v36 = v35 + 1;
            if (v35 == -1 || v36 > *(_QWORD *)(a2 + *v4))
            {
              *(_BYTE *)(a2 + *v5) = 1;
            }
            else
            {
              v37 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v35);
              *(_QWORD *)(a2 + v34) = v36;
              v20 |= (unint64_t)(v37 & 0x7F) << v32;
              if (v37 < 0)
              {
                v32 += 7;
                v15 = v33++ >= 9;
                if (v15)
                {
                  LODWORD(v20) = 0;
                  goto LABEL_91;
                }
                continue;
              }
            }
            break;
          }
          if (*(_BYTE *)(a2 + *v5))
            LODWORD(v20) = 0;
LABEL_91:
          v71 = 40;
          goto LABEL_112;
        case 4u:
          v38 = 0;
          v39 = 0;
          v20 = 0;
          while (2)
          {
            v40 = *v3;
            v41 = *(_QWORD *)(a2 + v40);
            v42 = v41 + 1;
            if (v41 == -1 || v42 > *(_QWORD *)(a2 + *v4))
            {
              *(_BYTE *)(a2 + *v5) = 1;
            }
            else
            {
              v43 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v41);
              *(_QWORD *)(a2 + v40) = v42;
              v20 |= (unint64_t)(v43 & 0x7F) << v38;
              if (v43 < 0)
              {
                v38 += 7;
                v15 = v39++ >= 9;
                if (v15)
                {
                  LODWORD(v20) = 0;
                  goto LABEL_95;
                }
                continue;
              }
            }
            break;
          }
          if (*(_BYTE *)(a2 + *v5))
            LODWORD(v20) = 0;
LABEL_95:
          v71 = 36;
          goto LABEL_112;
        case 5u:
          v44 = 0;
          v45 = 0;
          v20 = 0;
          while (2)
          {
            v46 = *v3;
            v47 = *(_QWORD *)(a2 + v46);
            v48 = v47 + 1;
            if (v47 == -1 || v48 > *(_QWORD *)(a2 + *v4))
            {
              *(_BYTE *)(a2 + *v5) = 1;
            }
            else
            {
              v49 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v47);
              *(_QWORD *)(a2 + v46) = v48;
              v20 |= (unint64_t)(v49 & 0x7F) << v44;
              if (v49 < 0)
              {
                v44 += 7;
                v15 = v45++ >= 9;
                if (v15)
                {
                  LODWORD(v20) = 0;
                  goto LABEL_99;
                }
                continue;
              }
            }
            break;
          }
          if (*(_BYTE *)(a2 + *v5))
            LODWORD(v20) = 0;
LABEL_99:
          v71 = 20;
          goto LABEL_112;
        case 6u:
          v50 = 0;
          v51 = 0;
          v20 = 0;
          *(_BYTE *)(a1 + 44) |= 1u;
          while (2)
          {
            v52 = *v3;
            v53 = *(_QWORD *)(a2 + v52);
            v54 = v53 + 1;
            if (v53 == -1 || v54 > *(_QWORD *)(a2 + *v4))
            {
              *(_BYTE *)(a2 + *v5) = 1;
            }
            else
            {
              v55 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v53);
              *(_QWORD *)(a2 + v52) = v54;
              v20 |= (unint64_t)(v55 & 0x7F) << v50;
              if (v55 < 0)
              {
                v50 += 7;
                v15 = v51++ >= 9;
                if (v15)
                {
                  LODWORD(v20) = 0;
                  goto LABEL_103;
                }
                continue;
              }
            }
            break;
          }
          if (*(_BYTE *)(a2 + *v5))
            LODWORD(v20) = 0;
LABEL_103:
          v71 = 8;
          goto LABEL_112;
        case 7u:
          *(_BYTE *)(a1 + 44) |= 4u;
          v56 = *v3;
          v57 = *(_QWORD *)(a2 + v56);
          if (v57 <= 0xFFFFFFFFFFFFFFFBLL && v57 + 4 <= *(_QWORD *)(a2 + *v4))
          {
            v58 = *(_DWORD *)(*(_QWORD *)(a2 + *v7) + v57);
            *(_QWORD *)(a2 + v56) = v57 + 4;
          }
          else
          {
            *(_BYTE *)(a2 + *v5) = 1;
            v58 = 0;
          }
          *(_DWORD *)(a1 + 16) = v58;
          continue;
        case 8u:
          v59 = 0;
          v60 = 0;
          v20 = 0;
          *(_BYTE *)(a1 + 44) |= 0x10u;
          while (2)
          {
            v61 = *v3;
            v62 = *(_QWORD *)(a2 + v61);
            v63 = v62 + 1;
            if (v62 == -1 || v63 > *(_QWORD *)(a2 + *v4))
            {
              *(_BYTE *)(a2 + *v5) = 1;
            }
            else
            {
              v64 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v62);
              *(_QWORD *)(a2 + v61) = v63;
              v20 |= (unint64_t)(v64 & 0x7F) << v59;
              if (v64 < 0)
              {
                v59 += 7;
                v15 = v60++ >= 9;
                if (v15)
                {
                  LODWORD(v20) = 0;
                  goto LABEL_107;
                }
                continue;
              }
            }
            break;
          }
          if (*(_BYTE *)(a2 + *v5))
            LODWORD(v20) = 0;
LABEL_107:
          v71 = 28;
          goto LABEL_112;
        case 9u:
          v65 = 0;
          v66 = 0;
          v20 = 0;
          *(_BYTE *)(a1 + 44) |= 8u;
          break;
        default:
          result = PBReaderSkipValueWithTag();
          if (!(_DWORD)result)
            return result;
          continue;
      }
      while (1)
      {
        v67 = *v3;
        v68 = *(_QWORD *)(a2 + v67);
        v69 = v68 + 1;
        if (v68 == -1 || v69 > *(_QWORD *)(a2 + *v4))
          break;
        v70 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v68);
        *(_QWORD *)(a2 + v67) = v69;
        v20 |= (unint64_t)(v70 & 0x7F) << v65;
        if ((v70 & 0x80) == 0)
          goto LABEL_109;
        v65 += 7;
        v15 = v66++ >= 9;
        if (v15)
        {
          LODWORD(v20) = 0;
          goto LABEL_111;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_109:
      if (*(_BYTE *)(a2 + *v5))
        LODWORD(v20) = 0;
LABEL_111:
      v71 = 24;
LABEL_112:
      *(_DWORD *)(a1 + v71) = v20;
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

uint64_t GKNATObserverDynamicStoreCallback(int a1, void *a2, id obj)
{
  id v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  int v12;
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  objc_sync_enter(obj);
  v5 = objc_alloc_init(MEMORY[0x1E0CB34A8]);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v6 = VRTraceErrorLogLevelToCSTR();
    v7 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v12 = 136315906;
      v13 = v6;
      v14 = 2080;
      v15 = "GKNATObserverDynamicStoreCallback";
      v16 = 1024;
      v17 = 179;
      v18 = 2080;
      v19 = objc_msgSend((id)objc_msgSend(a2, "description"), "UTF8String");
      _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d GKNATObserver_SCContext: GKNATObserverDynamicStoreCallback(): changedKeys = %s", (uint8_t *)&v12, 0x26u);
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v8 = VRTraceErrorLogLevelToCSTR();
    v9 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v10 = objc_msgSend((id)objc_msgSend(obj, "description"), "UTF8String");
      v12 = 136315906;
      v13 = v8;
      v14 = 2080;
      v15 = "GKNATObserverDynamicStoreCallback";
      v16 = 1024;
      v17 = 180;
      v18 = 2080;
      v19 = v10;
      _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d GKNATObserver_SCContext: GKNATObserverDynamicStoreCallback(): self.observer = %s", (uint8_t *)&v12, 0x26u);
    }
  }
  objc_msgSend((id)objc_msgSend(obj, "observer"), "clearRetries");
  objc_msgSend((id)objc_msgSend(obj, "observer"), "tryNATCheckWithDelay:", 0.25);
  objc_msgSend(v5, "drain");
  return objc_sync_exit(obj);
}

void sub_1D8AB9E8C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1D8ABA5FC(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1D8ABA6A8(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1D8ABB808(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1D8ABB8E8(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t NAT64ResolverCallBack(void *a1, uint64_t a2)
{
  id v4;
  uint64_t v5;
  NSObject *v6;
  int v8;
  uint64_t v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v4 = objc_alloc_init(MEMORY[0x1E0CB34A8]);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v5 = VRTraceErrorLogLevelToCSTR();
    v6 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v8 = 136315906;
      v9 = v5;
      v10 = 2080;
      v11 = "NAT64ResolverCallBack";
      v12 = 1024;
      v13 = 1323;
      v14 = 2080;
      v15 = a2;
      _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d NAT64ResolverCallBack: got prefix for %s", (uint8_t *)&v8, 0x26u);
    }
  }
  objc_msgSend(a1, "clearRetries");
  objc_msgSend(a1, "tryNATCheckWithDelay:", 0.0);
  return objc_msgSend(v4, "drain");
}

void sub_1D8ABF994(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void OUTLINED_FUNCTION_4_2(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x28u);
}

void OUTLINED_FUNCTION_9_0(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_debug_impl(a1, v9, OS_LOG_TYPE_DEBUG, a4, &a9, 0x26u);
}

uint64_t OUTLINED_FUNCTION_10_1@<X0>(void *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  *(_QWORD *)(v2 - 24) = a2;
  return objc_msgSend(a1, "description");
}

int *OUTLINED_FUNCTION_11_0@<X0>(uint64_t a1@<X8>)
{
  uint64_t v1;

  *(_QWORD *)(v1 - 24) = a1;
  return __error();
}

uint64_t VCAudioStreamReceiveGroup_PullAudioSamples(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  double HostTime;
  int Timestamp;
  uint64_t v7;
  unsigned int SampleCount;
  uint64_t **v9;
  uint64_t v10;
  unsigned int Priority;
  uint64_t v12;
  uint64_t *i;
  void (*v14)(uint64_t, _QWORD, uint64_t);
  int v15;
  unint64_t v16;
  _BYTE *v17;
  unsigned int v18;
  unsigned int v19;
  int v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  NSObject *v24;
  NSObject *v25;
  int v26;
  int v27;
  char v28;
  int v29;
  uint64_t v30;
  NSObject *v31;
  NSObject *v32;
  uint64_t v33;
  NSObject *v34;
  int v36;
  int v37;
  _BYTE v38[24];
  _BYTE buf[24];
  __int128 v40;
  uint64_t v41;
  int v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 316) == 2)
  {
    VCAudioBufferList_ZeroMemory(a2);
    v4 = 1;
  }
  else
  {
    HostTime = VCAudioBufferList_GetHostTime(a2);
    Timestamp = VCAudioBufferList_GetTimestamp(a2);
    v7 = *(_QWORD *)(*(_QWORD *)(a1 + 472) + 184);
    SampleCount = VCAudioBufferList_GetSampleCount(a2);
    VCAudioBufferList_SetSampleCount(v7, SampleCount);
    VCAudioBufferList_SetTime(*(_QWORD *)(*(_QWORD *)(a1 + 472) + 184), Timestamp, HostTime);
    v9 = *(uint64_t ***)(*(_QWORD *)(a1 + 472) + 176);
    if (v9)
    {
      LOBYTE(v4) = 0;
      v10 = a2;
      do
      {
        ((void (*)(uint64_t *, uint64_t))v9[3])(v9[2], v10);
        Priority = VCAudioBufferList_GetPriority(v10);
        if (v4 <= Priority)
          v4 = Priority;
        else
          v4 = v4;
        if (v10 != a2)
          VCAudioBufferList_Mix(a2, v10);
        v10 = *(_QWORD *)(*(_QWORD *)(a1 + 472) + 184);
        v9 = (uint64_t **)*v9;
      }
      while (v9);
    }
    else
    {
      v4 = 0;
    }
    *(float *)(a1 + 532) = VCAudioBufferList_GetAveragePower(a2);
    ++*(_QWORD *)(a1 + 536);
    memset(v38, 170, sizeof(v38));
    VCAudioBufferList_GetNetworkTimestamp(a2, (uint64_t)v38);
    if ((v38[12] & 1) != 0)
    {
      *(_QWORD *)&buf[16] = *(_QWORD *)&v38[16];
      *(_OWORD *)buf = *(_OWORD *)v38;
      v12 = *(_QWORD *)(a1 + 472);
      *(double *)&v40 = HostTime;
      for (i = *(uint64_t **)(v12 + 192); i; i = (uint64_t *)i[2])
      {
        ++*(_QWORD *)(a1 + 544);
        VCVideoStreamReceiveGroup_UpdateSourcePlayoutTime(*i, buf);
      }
    }
    v14 = *(void (**)(uint64_t, _QWORD, uint64_t))(a1 + 512);
    if (v14)
      v14(a1, *(_QWORD *)(a1 + 520), a2);
    if (*(_BYTE *)(a1 + 528))
      VCMediaRecorder_AddRemoteAudioSampleBuffer(*(_QWORD *)(a1 + 336), a2, Timestamp);
  }
  v15 = *(_DWORD *)(a1 + 508);
  HIDWORD(v16) = -1030792151 * v15;
  LODWORD(v16) = -1030792151 * v15;
  if ((v16 >> 3) <= 0x147AE14)
  {
    *(_DWORD *)(a1 + 492) = -[VCDefaults prominenceActiveAccumulationThreshold](+[VCDefaults sharedInstance](VCDefaults, "sharedInstance"), "prominenceActiveAccumulationThreshold");
    *(_DWORD *)(a1 + 484) = -[VCDefaults prominenceActiveProbabilityThreshold](+[VCDefaults sharedInstance](VCDefaults, "sharedInstance"), "prominenceActiveProbabilityThreshold");
    *(_DWORD *)(a1 + 496) = -[VCDefaults prominenceInactiveAccumulationThreshold](+[VCDefaults sharedInstance](VCDefaults, "sharedInstance"), "prominenceInactiveAccumulationThreshold");
    *(_DWORD *)(a1 + 488) = -[VCDefaults prominenceInactiveProbabilityThreshold](+[VCDefaults sharedInstance](VCDefaults, "sharedInstance"), "prominenceInactiveProbabilityThreshold");
    v15 = *(_DWORD *)(a1 + 508);
  }
  *(_DWORD *)(a1 + 508) = v15 + 1;
  if (v4 <= 1)
    v4 = 1;
  v17 = (_BYTE *)(a1 + 480);
  v18 = *(_DWORD *)(a1 + 500);
  if (*(_BYTE *)(a1 + 480))
  {
    if (*(_DWORD *)(a1 + 488) > v4)
    {
      if (!v18 || (v19 = v18 - 1, (*(_DWORD *)(a1 + 500) = v19) == 0))
        *v17 = 0;
      goto LABEL_38;
    }
    if (v18 >= *(_DWORD *)(a1 + 496))
      goto LABEL_38;
    v21 = v18 + 1;
LABEL_37:
    *(_DWORD *)(a1 + 500) = v21;
    goto LABEL_38;
  }
  if (*(_DWORD *)(a1 + 484) >= v4)
  {
    if (!v18)
      goto LABEL_38;
    v20 = -1;
  }
  else
  {
    v20 = 1;
  }
  v22 = v20 + v18;
  *(_DWORD *)(a1 + 500) = v22;
  if (v22 > *(_DWORD *)(a1 + 492))
  {
    *v17 = 1;
    v21 = *(_DWORD *)(a1 + 496);
    goto LABEL_37;
  }
LABEL_38:
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v23 = VRTraceErrorLogLevelToCSTR();
    v24 = *MEMORY[0x1E0CF2758];
    v25 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        v26 = *(_DWORD *)(a1 + 500);
        v27 = *v17;
        *(_DWORD *)buf = 136316674;
        *(_QWORD *)&buf[4] = v23;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "VCAudioStreamReceiveGroup_DebounceAudioPriority";
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v40) = 384;
        WORD2(v40) = 1024;
        *(_DWORD *)((char *)&v40 + 6) = 384;
        WORD5(v40) = 1024;
        HIDWORD(v40) = v26;
        LOWORD(v41) = 1024;
        *(_DWORD *)((char *)&v41 + 2) = v4;
        HIWORD(v41) = 1024;
        v42 = v27;
        _os_log_impl(&dword_1D8A54000, v24, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VCAudioStreamReceiveGroup.m:%d: ActiveCount:%d audioPriority:%d audioActive:%d", buf, 0x34u);
      }
    }
    else if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
    {
      v36 = *(_DWORD *)(a1 + 500);
      v37 = *v17;
      *(_DWORD *)buf = 136316674;
      *(_QWORD *)&buf[4] = v23;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "VCAudioStreamReceiveGroup_DebounceAudioPriority";
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v40) = 384;
      WORD2(v40) = 1024;
      *(_DWORD *)((char *)&v40 + 6) = 384;
      WORD5(v40) = 1024;
      HIDWORD(v40) = v36;
      LOWORD(v41) = 1024;
      *(_DWORD *)((char *)&v41 + 2) = v4;
      HIWORD(v41) = 1024;
      v42 = v37;
      _os_log_debug_impl(&dword_1D8A54000, v24, OS_LOG_TYPE_DEBUG, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VCAudioStreamReceiveGroup.m:%d: ActiveCount:%d audioPriority:%d audioActive:%d", buf, 0x34u);
    }
  }
  if (*(_BYTE *)(a1 + 480))
    v28 = -1;
  else
    v28 = 1;
  if (*(_BYTE *)(a1 + 480))
    v29 = 255;
  else
    v29 = 1;
  if (*(_DWORD *)(a1 + 504) != v29)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v30 = VRTraceErrorLogLevelToCSTR();
      v31 = *MEMORY[0x1E0CF2758];
      v32 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316162;
          *(_QWORD *)&buf[4] = v30;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "VCAudioStreamReceiveGroup_UpdateAudioPriority";
          *(_WORD *)&buf[22] = 1024;
          LODWORD(v40) = 397;
          WORD2(v40) = 1024;
          *(_DWORD *)((char *)&v40 + 6) = 397;
          WORD5(v40) = 1024;
          HIDWORD(v40) = v29;
          _os_log_impl(&dword_1D8A54000, v31, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VCAudioStreamReceiveGroup.m:%d: Updating audio priority %d", buf, 0x28u);
        }
      }
      else if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
      {
        VCAudioStreamReceiveGroup_PullAudioSamples_cold_1();
      }
    }
    v33 = MEMORY[0x1DF086F1C](a1 + 296);
    if (v33)
    {
      v34 = *(NSObject **)(a1 + 304);
      *(_QWORD *)buf = MEMORY[0x1E0C809B0];
      *(_QWORD *)&buf[8] = 3221225472;
      *(_QWORD *)&buf[16] = __VCAudioStreamReceiveGroup_UpdateAudioPriority_block_invoke;
      *(_QWORD *)&v40 = &unk_1E9E52210;
      *((_QWORD *)&v40 + 1) = v33;
      v41 = a1;
      LOBYTE(v42) = v28;
      dispatch_async(v34, buf);
    }
    *(_DWORD *)(a1 + 504) = v29;
  }
  VCAudioBufferList_GetVoiceActivity(a2);
  return kdebug_trace();
}

uint64_t VCAudioRelayThread(void *a1)
{
  objc_msgSend(a1, "relayCallback");
  return 0;
}

void _VCAudioRelay_UpdateWakeupInterval(uint64_t a1)
{
  uint64_t v2;
  double v3;
  uint64_t HostTimeAndGrandmasterIdentityLocalPortForClockTime;
  unint64_t v5;
  uint64_t v6;
  NSObject *v7;
  int v8;
  uint64_t v9;
  double v10;
  double v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  double v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  NSObject *v27;
  NSObject *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  _BYTE buf[22];
  __int16 v38;
  int v39;
  __int16 v40;
  _BYTE v41[10];
  _BYTE v42[10];
  _BYTE v43[10];
  uint64_t v44;
  __int16 v45;
  uint64_t v46;
  __int16 v47;
  double v48;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 464);
  if (v2 || *(_QWORD *)(a1 + 472))
  {
    v3 = *(double *)(a1 + 136);
    if (*(_QWORD *)(a1 + 440))
    {
      *(_QWORD *)(a1 + 496) = (unint64_t)((double)*(unint64_t *)(a1 + 496) + v3 * 1000000000.0);
      HostTimeAndGrandmasterIdentityLocalPortForClockTime = TimeSyncClockGetHostTimeAndGrandmasterIdentityLocalPortForClockTime();
      if (*(unsigned __int16 *)(a1 + 456) != 43690
        || (v5 = HostTimeAndGrandmasterIdentityLocalPortForClockTime, *(_QWORD *)(a1 + 448) != 0xAAAAAAAAAAAAAAAALL))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
        {
          v6 = VRTraceErrorLogLevelToCSTR();
          v7 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v8 = *(unsigned __int16 *)(a1 + 456);
            v9 = *(_QWORD *)(a1 + 448);
            *(_DWORD *)buf = 136316674;
            *(_QWORD *)&buf[4] = v6;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VCAudioRelay_UpdateWakeupIntervalWithPTPClock";
            v38 = 1024;
            v39 = 904;
            v40 = 1024;
            *(_DWORD *)v41 = v8;
            *(_WORD *)&v41[4] = 1024;
            *(_DWORD *)&v41[6] = 43690;
            *(_WORD *)v42 = 2048;
            *(_QWORD *)&v42[2] = v9;
            *(_WORD *)v43 = 2048;
            *(_QWORD *)&v43[2] = 0xAAAAAAAAAAAAAAAALL;
            _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Reinitializing PTP time. old local port=%u, new local port=%u, old GM identity=%llu, new GM identity=%llu", buf, 0x3Cu);
          }
        }
        _VCAudioRelay_InitializePTPClockTime(a1, *(_QWORD *)(a1 + 504));
        *(_QWORD *)(a1 + 496) = (unint64_t)((double)*(unint64_t *)(a1 + 496)
                                                 + *(double *)(a1 + 136) * 1000000000.0);
        v5 = TimeSyncClockGetHostTimeAndGrandmasterIdentityLocalPortForClockTime();
      }
      if (v5 == *MEMORY[0x1E0DBF0E8])
      {
        v10 = (double)*(unint64_t *)(a1 + 504);
        v11 = *(double *)(a1 + 136);
        v5 = (unint64_t)(v11 / machTimeScale() + v10);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
        {
          v12 = VRTraceErrorLogLevelToCSTR();
          v13 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v14 = *(_QWORD *)(a1 + 504);
            *(_DWORD *)buf = 136316162;
            *(_QWORD *)&buf[4] = v12;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VCAudioRelay_UpdateWakeupIntervalWithPTPClock";
            v38 = 1024;
            v39 = 913;
            v40 = 2048;
            *(_QWORD *)v41 = v5;
            *(_WORD *)&v41[8] = 2048;
            *(_QWORD *)v42 = v14;
            _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Invalid wakeUpHostTime computed from PTP clock, following local clock instead. newWakeUpHostMachTime=%llu, oldWakeUpHostMachTime=%llu", buf, 0x30u);
          }
        }
      }
      *(_QWORD *)(a1 + 504) = v5;
      v15 = mach_absolute_time();
      if (v5 >= v15)
      {
        v16 = machTimeScale() * (double)(v5 - v15);
      }
      else
      {
        v16 = 0.0;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          v17 = VRTraceErrorLogLevelToCSTR();
          v18 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v19 = *(_QWORD *)(a1 + 496);
            *(_DWORD *)buf = 136316418;
            *(_QWORD *)&buf[4] = v17;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VCAudioRelay_UpdateWakeupIntervalWithPTPClock";
            v38 = 1024;
            v39 = 921;
            v40 = 2048;
            *(_QWORD *)v41 = v5;
            *(_WORD *)&v41[8] = 2048;
            *(_QWORD *)v42 = v15;
            *(_WORD *)&v42[8] = 2048;
            *(_QWORD *)v43 = v19;
            _os_log_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Realtime miss: wakeUpHostMachTime=%llu, currentMachHostTime=%llu, ptpWakeUpTime=%llu", buf, 0x3Au);
          }
        }
      }
      *(_QWORD *)(a1 + 480) = (int)v16;
      *(_QWORD *)(a1 + 488) = (uint64_t)((v16 - (double)(int)v16) * 1000000000.0);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v26 = VRTraceErrorLogLevelToCSTR();
        v27 = *MEMORY[0x1E0CF2758];
        v28 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
          {
            v29 = *(_QWORD *)(a1 + 480);
            v30 = *(_QWORD *)(a1 + 488);
            v31 = *(_QWORD *)(a1 + 496);
            *(_DWORD *)buf = 136317186;
            *(_QWORD *)&buf[4] = v26;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VCAudioRelay_UpdateWakeupIntervalWithPTPClock";
            v38 = 1024;
            v39 = 929;
            v40 = 2048;
            *(_QWORD *)v41 = v29;
            *(_WORD *)&v41[8] = 2048;
            *(_QWORD *)v42 = v30;
            *(_WORD *)&v42[8] = 2048;
            *(_QWORD *)v43 = v5;
            *(_WORD *)&v43[8] = 2048;
            v44 = v15;
            v45 = 2048;
            v46 = v31;
            v47 = 2048;
            v48 = v16;
            _os_log_impl(&dword_1D8A54000, v27, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d _nextWakeUpInterval.sec=%ld, _nextWakeUpInterval.nsec=%ld, wakeUpHostMachTime=%llu, currentMachHostTime=%llu, ptpWakeUpTime=%llu, timeInSeconds=%f", buf, 0x58u);
          }
        }
        else if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
        {
          v34 = *(_QWORD *)(a1 + 480);
          v35 = *(_QWORD *)(a1 + 488);
          v36 = *(_QWORD *)(a1 + 496);
          *(_DWORD *)buf = 136317186;
          *(_QWORD *)&buf[4] = v26;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VCAudioRelay_UpdateWakeupIntervalWithPTPClock";
          v38 = 1024;
          v39 = 929;
          v40 = 2048;
          *(_QWORD *)v41 = v34;
          *(_WORD *)&v41[8] = 2048;
          *(_QWORD *)v42 = v35;
          *(_WORD *)&v42[8] = 2048;
          *(_QWORD *)v43 = v5;
          *(_WORD *)&v43[8] = 2048;
          v44 = v15;
          v45 = 2048;
          v46 = v36;
          v47 = 2048;
          v48 = v16;
          _os_log_debug_impl(&dword_1D8A54000, v27, OS_LOG_TYPE_DEBUG, " [%s] %s:%d _nextWakeUpInterval.sec=%ld, _nextWakeUpInterval.nsec=%ld, wakeUpHostMachTime=%llu, currentMachHostTime=%llu, ptpWakeUpTime=%llu, timeInSeconds=%f", buf, 0x58u);
        }
      }
    }
    else
    {
      v20 = *(_QWORD *)(a1 + 472) + 1000000000 * v2 + (unint64_t)(v3 * 1000000000.0);
      v21 = v20 / 0x3B9ACA00;
      v22 = v20 % 0x3B9ACA00;
      *(_QWORD *)(a1 + 464) = v20 / 0x3B9ACA00;
      *(_QWORD *)(a1 + 472) = v20 % 0x3B9ACA00;
      memset(buf, 170, 16);
      gettimeofday((timeval *)buf, 0);
      v23 = v22 + 1000000000 * (v21 - *(_QWORD *)buf) - 1000 * *(int *)&buf[8];
      if (v23 < 1)
      {
        v24 = 0;
        v25 = 0;
      }
      else
      {
        v24 = v23 / 0x3B9ACA00uLL;
        v25 = v23 % 0x3B9ACA00uLL;
      }
      *(_QWORD *)(a1 + 480) = v24;
      *(_QWORD *)(a1 + 488) = v25;
    }
  }
  else
  {
    memset(buf, 170, 16);
    gettimeofday((timeval *)buf, 0);
    v32 = 1000 * *(int *)&buf[8];
    *(_QWORD *)(a1 + 464) = *(_QWORD *)buf;
    *(_QWORD *)(a1 + 472) = v32;
    v33 = mach_absolute_time();
    _VCAudioRelay_InitializePTPClockTime(a1, v33);
  }
}

void _VCAudioRelay_InitializePTPClockTime(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  uint64_t v19;
  __int16 v20;
  int v21;
  __int16 v22;
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(a1 + 440))
  {
    *(_QWORD *)(a1 + 496) = TimeSyncClockGetClockTimeAndGrandmasterIdentityLocalPortForHostTime();
    *(_QWORD *)(a1 + 504) = a2;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      v4 = VRTraceErrorLogLevelToCSTR();
      v5 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v7 = *(_QWORD *)(a1 + 496);
        v6 = *(_QWORD *)(a1 + 504);
        v8 = *(unsigned __int16 *)(a1 + 456);
        v9 = *(_QWORD *)(a1 + 448);
        v10 = 136316674;
        v11 = v4;
        v12 = 2080;
        v13 = "_VCAudioRelay_InitializePTPClockTime";
        v14 = 1024;
        v15 = 889;
        v16 = 2048;
        v17 = v6;
        v18 = 2048;
        v19 = v7;
        v20 = 1024;
        v21 = v8;
        v22 = 2048;
        v23 = v9;
        _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d hostMachTime=%llu, ptpTime=%llu, port=%u, GMidentity=%llu", (uint8_t *)&v10, 0x40u);
      }
    }
  }
}

void VCCaptionsStreamSendGroup_PushAudioSamples(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  NSObject *v3;
  NSObject *v4;
  int v5;
  uint64_t v6;
  __int16 v7;
  const char *v8;
  __int16 v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 312))
  {
    objc_msgSend(*(id *)(a1 + 744), "pushAudioSamples:", a2);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    v4 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        v5 = 136315650;
        v6 = v2;
        v7 = 2080;
        v8 = "VCCaptionsStreamSendGroup_PushAudioSamples";
        v9 = 1024;
        v10 = 308;
        _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d audio no-op no MKM", (uint8_t *)&v5, 0x1Cu);
      }
    }
    else if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      VCCaptionsStreamSendGroup_PushAudioSamples_cold_1(v2);
    }
  }
}

void sub_1D8AC79F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t VCCaptionsStream_CreateSampleBuffer(void *memoryBlock, size_t blockLength, const CMSampleTimingInfo *a3, CMSampleBufferRef *a4)
{
  const __CFAllocator *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CMFormatDescriptionRef formatDescriptionOut;
  CMBlockBufferRef blockBufferOut[2];

  blockBufferOut[1] = *(CMBlockBufferRef *)MEMORY[0x1E0C80C00];
  formatDescriptionOut = 0;
  blockBufferOut[0] = 0;
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v7 = CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E0C9AE00], memoryBlock, blockLength, (CFAllocatorRef)*MEMORY[0x1E0C9AE20], 0, 0, blockLength, 0, blockBufferOut);
  if ((_DWORD)v7)
  {
    v9 = v7;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCCaptionsStream_CreateSampleBuffer_cold_2();
    }
  }
  else
  {
    v8 = CMFormatDescriptionCreate(v6, 0x6D657461u, 0x63617074u, 0, &formatDescriptionOut);
    if ((_DWORD)v8)
    {
      v9 = v8;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCCaptionsStream_CreateSampleBuffer_cold_1();
      }
    }
    else
    {
      v9 = CMSampleBufferCreate(v6, blockBufferOut[0], 1u, 0, 0, formatDescriptionOut, 1, 1, a3, 0, 0, a4);
    }
  }
  if (formatDescriptionOut)
    CFRelease(formatDescriptionOut);
  if (blockBufferOut[0])
    CFRelease(blockBufferOut[0]);
  return v9;
}

double VCMediaChannelMetrics_Reset(uint64_t a1)
{
  double result;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_DWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  return result;
}

uint64_t VCMediaChannelMetrics_Sum(uint64_t result, uint64_t a2)
{
  uint64_t i;
  double v3;
  double v4;
  int v5;
  int v6;
  int v7;

  *(_DWORD *)result += *(_DWORD *)a2;
  *(_DWORD *)(result + 24) += *(_DWORD *)(a2 + 24);
  *(double *)(result + 32) = *(double *)(a2 + 32) + *(double *)(result + 32);
  for (i = 4; i != 24; i += 4)
    *(_DWORD *)(result + i) += *(_DWORD *)(a2 + i);
  *(_OWORD *)(result + 40) = *(_OWORD *)(a2 + 40);
  v3 = *(double *)(a2 + 56);
  if (v3 == 0.0)
    v3 = *(double *)(result + 56);
  *(double *)(result + 56) = v3;
  v4 = *(double *)(a2 + 72);
  if (v4 == 0.0)
    v4 = *(double *)(result + 72);
  *(double *)(result + 72) = v4;
  v5 = *(_DWORD *)(a2 + 64);
  if (!v5)
    v5 = *(_DWORD *)(result + 64);
  *(_DWORD *)(result + 64) = v5;
  v6 = *(_DWORD *)(a2 + 80);
  if (!v6)
    v6 = *(_DWORD *)(result + 80);
  v7 = *(_DWORD *)(result + 84) + *(_DWORD *)(a2 + 84);
  *(_DWORD *)(result + 80) = v6;
  *(_DWORD *)(result + 84) = v7;
  return result;
}

char *VCVideoJitterBuffer_Create(uint64_t a1)
{
  char *v2;
  char *v3;
  _DWORD *v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  unint64_t v17;
  int v18;
  double v19;
  double v20;
  double v21;
  uint64_t v22;
  int v23;
  double v24;
  double v25;
  double v26;
  double DoubleValueForKey;
  double v28;
  double v29;
  int v30;
  int IntValueForKey;
  double v32;
  int v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  CFTypeRef v40;
  int v41;
  uint64_t v42;
  NSObject *v43;
  uint64_t v44;
  char *v45;
  BOOL v46;
  int ErrorLogLevelForModule;
  uint64_t v48;
  NSObject *v49;
  uint64_t v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  uint8_t buf[4];
  uint64_t v63;
  __int16 v64;
  const char *v65;
  __int16 v66;
  int v67;
  __int16 v68;
  char *v69;
  __int16 v70;
  uint64_t v71;
  __int16 v72;
  double v73;
  __int16 v74;
  double v75;
  __int16 v76;
  int v77;
  __int16 v78;
  double v79;
  __int16 v80;
  double v81;
  __int16 v82;
  double v83;
  __int16 v84;
  double v85;
  __int16 v86;
  uint64_t v87;
  __int16 v88;
  char *v89;
  uint64_t v90;

  v90 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCVideoJitterBuffer_Create_cold_1();
    }
    return 0;
  }
  v2 = (char *)malloc_type_calloc(1uLL, 0x14070uLL, 0x10B00403E9CE963uLL);
  v3 = v2;
  if (!v2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCVideoJitterBuffer_Create_cold_3();
    }
    goto LABEL_64;
  }
  if (!*(_DWORD *)(a1 + 216))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCVideoJitterBuffer_Create_cold_4();
    }
    goto LABEL_64;
  }
  v4 = v2 + 81880;
  v5 = *(_OWORD *)a1;
  v6 = *(_OWORD *)(a1 + 16);
  v7 = *(_OWORD *)(a1 + 48);
  *((_OWORD *)v2 + 2) = *(_OWORD *)(a1 + 32);
  *((_OWORD *)v2 + 3) = v7;
  *(_OWORD *)v2 = v5;
  *((_OWORD *)v2 + 1) = v6;
  v8 = *(_OWORD *)(a1 + 64);
  v9 = *(_OWORD *)(a1 + 80);
  v10 = *(_OWORD *)(a1 + 112);
  *((_OWORD *)v2 + 6) = *(_OWORD *)(a1 + 96);
  *((_OWORD *)v2 + 7) = v10;
  *((_OWORD *)v2 + 4) = v8;
  *((_OWORD *)v2 + 5) = v9;
  v11 = *(_OWORD *)(a1 + 128);
  v12 = *(_OWORD *)(a1 + 144);
  v13 = *(_OWORD *)(a1 + 176);
  *((_OWORD *)v2 + 10) = *(_OWORD *)(a1 + 160);
  *((_OWORD *)v2 + 11) = v13;
  *((_OWORD *)v2 + 8) = v11;
  *((_OWORD *)v2 + 9) = v12;
  v14 = *(_OWORD *)(a1 + 192);
  v15 = *(_OWORD *)(a1 + 208);
  v16 = *(_OWORD *)(a1 + 224);
  *((_QWORD *)v2 + 30) = *(_QWORD *)(a1 + 240);
  *((_OWORD *)v2 + 13) = v15;
  *((_OWORD *)v2 + 14) = v16;
  *((_OWORD *)v2 + 12) = v14;
  *((_QWORD *)v2 + 10241) = LogDump_OpenLog(a1, (uint64_t)"JitterBuffer", (uint64_t)".vjbdump", (char)"STime\tTimestamp\tSPF\tBundling\tDTX\tNetworkType\tFirstTimestamp\tWraps\tIsRed\tLag\tAvgLag\tMaxLag\tMinLag\tJumpThresh\tSlopeThresh\tFlat\tClippedLag\tMinLagAdjustment\tMinClipThreshold\tJB\tJBMin\tJBMax\tTargetJ\tRedOverheadInTargetJ\tTargetJQSize\tJQSize\tAvgJQSize\tERASURE\tMODE\tPayload Type\tSeq Number\tDON\tOUTTS\tLeftOverSamples\tProminence\tStreamID\tTargetSizeIndependent\tAVSyncOffset\tEncodedBufferLength\n", 9, (char)"2.7");
  *((_QWORD *)v3 + 10246) = 0x7FEFFFFFFFFFFFFFLL;
  *v4 = 0;
  *((_QWORD *)v3 + 10251) = 0x3FF0000000000000;
  v18 = *(_DWORD *)(a1 + 200);
  switch(v18)
  {
    case 0:
      LODWORD(v17) = *(_DWORD *)(a1 + 216);
      v19 = (double)v17;
      v20 = 3.0;
      goto LABEL_13;
    case 3:
      v21 = *(double *)(a1 + 240);
      break;
    case 1:
      LODWORD(v17) = *(_DWORD *)(a1 + 216);
      v19 = (double)v17;
      v20 = 0.0;
LABEL_13:
      v21 = v20 / v19;
      break;
    default:
      v21 = 0.1;
      break;
  }
  *((double *)v3 + 10253) = VCDefaults_GetDoubleValueForKey(CFSTR("videoJitterBufferMinQueueSize"), v21);
  *((_QWORD *)&v61 + 1) = *((_QWORD *)v3 + 10241);
  *(_QWORD *)&v61 = 1;
  if ((JLagProcessor_Initialize((uint64_t)(v3 + 248), &v61) & 1) == 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCVideoJitterBuffer_Create_cold_7();
    }
    goto LABEL_64;
  }
  v60 = 0u;
  v58 = 0u;
  v59 = 0u;
  v56 = 0u;
  v57 = 0u;
  v54 = 0u;
  v55 = 0u;
  v52 = 0u;
  v53 = 0u;
  v22 = *((_QWORD *)v3 + 10253);
  v51 = v22;
  v23 = *(_DWORD *)(a1 + 200);
  if (!v23)
  {
    v25 = (double)*(unsigned int *)(a1 + 216);
    v26 = 6.0;
LABEL_22:
    v24 = v26 / v25;
    goto LABEL_24;
  }
  if (v23 != 3)
  {
    v24 = 0.5;
    if (v23 != 1)
      goto LABEL_24;
    LODWORD(v24) = *(_DWORD *)(a1 + 216);
    v25 = (double)*(unint64_t *)&v24;
    v26 = 5.0;
    goto LABEL_22;
  }
  v24 = *(double *)(a1 + 240);
LABEL_24:
  DoubleValueForKey = VCDefaults_GetDoubleValueForKey(CFSTR("maxVideoJitterBufferSize"), v24);
  v28 = DoubleValueForKey;
  *((double *)&v52 + 1) = DoubleValueForKey;
  v29 = 0.25;
  if (*((_DWORD *)v3 + 50) != 2)
  {
    LODWORD(DoubleValueForKey) = *(_DWORD *)(a1 + 216);
    v29 = 3.0 / (double)*(unint64_t *)&DoubleValueForKey;
  }
  *(double *)&v53 = v29;
  v30 = *(unsigned __int8 *)(a1 + 204);
  DWORD2(v53) = v30;
  IntValueForKey = VCDefaults_GetIntValueForKey(CFSTR("numberOfBinsPerFrameJitterBufferCdf"), 4);
  if (!IntValueForKey)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCVideoJitterBuffer_Create_cold_6();
    }
    IntValueForKey = 4;
  }
  v32 = 1000.0 / (double)(*(_DWORD *)(a1 + 216) * IntValueForKey);
  *(double *)&v54 = v32;
  BYTE1(v55) = 1;
  *((_QWORD *)&v55 + 1) = *((_QWORD *)v3 + 10241);
  v33 = *(_DWORD *)(a1 + 200);
  if (v33 == 3)
  {
    v34 = 0.95;
    if (*(double *)(a1 + 240) == 0.0)
      v34 = 0.0;
  }
  else if (v33 == 1)
  {
    v34 = 0.95;
  }
  else
  {
    v34 = 0.98;
  }
  v35 = VCDefaults_GetDoubleValueForKey(CFSTR("percentToCoverInJitterBufferCdf"), v34);
  *((double *)&v54 + 1) = v35;
  LOBYTE(v55) = 1;
  BYTE8(v57) = 1;
  BYTE9(v57) = *((_DWORD *)v3 + 50) == 2;
  BYTE11(v57) = 1;
  LOBYTE(v56) = VCDefaults_GetBoolValueForKey(CFSTR("jitterBufferHistoryUseShortTermWindowForTargetExpansion"), *(unsigned __int8 *)(a1 + 224));
  v36 = 2.0;
  if (*((_DWORD *)v3 + 50) == 2)
    v36 = 5.0;
  v37 = VCDefaults_GetDoubleValueForKey(CFSTR("jitterBufferHistoryShortTermWindowSize"), v36);
  *((double *)&v56 + 1) = v37;
  v38 = 10.0;
  if (*((_DWORD *)v3 + 50) != 2)
    v38 = 5.0;
  v39 = VCDefaults_GetDoubleValueForKey(CFSTR("jitterBufferHistoryLongTermWindowSize"), v38);
  *(double *)&v57 = v39;
  BYTE10(v57) = 0;
  v40 = (CFTypeRef)*((_QWORD *)v3 + 29);
  if (v40)
    v40 = CFRetain(v40);
  *(_QWORD *)&v58 = v40;
  v41 = *((_DWORD *)v3 + 57);
  LODWORD(v59) = v41;
  BYTE8(v60) = 0;
  *((_QWORD *)&v59 + 1) = _VCVideoJitterBuffer_GetJBTargetFromEstimatedTarget;
  *(_QWORD *)&v60 = v3;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v42 = VRTraceErrorLogLevelToCSTR();
    v43 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v44 = *((_QWORD *)v3 + 29);
      v45 = FourccToCStr(v41);
      *(_DWORD *)buf = 136318466;
      v63 = v42;
      v64 = 2080;
      v65 = "VCVideoJitterBuffer_Create";
      v66 = 1024;
      v67 = 228;
      v68 = 2048;
      v69 = v3;
      v70 = 2048;
      v71 = v22;
      v72 = 2048;
      v73 = v28;
      v74 = 2048;
      v75 = v29;
      v76 = 1024;
      v77 = v30;
      v78 = 2048;
      v79 = v32;
      v80 = 2048;
      v81 = v35;
      v82 = 2048;
      v83 = v37;
      v84 = 2048;
      v85 = v39;
      v86 = 2048;
      v87 = v44;
      v88 = 2080;
      v89 = v45;
      _os_log_impl(&dword_1D8A54000, v43, OS_LOG_TYPE_DEFAULT, "VCVideoJitterBuffer [%s] %s:%d VCVideoJitterBuffer[%p] Video jitter buffer configured with minQ size %f maxQ size %f highStartQ size %f highstart %d jitterDistributionBucketSize %f targetPercentileToCover %f shortTermWindowSize %f longTermWindowSize %f jbTargetEstimatorSynchronizer=%p streamGroupID=%s", buf, 0x86u);
    }
  }
  v46 = JTargetJBEstimator_Initialize((uint64_t)(v3 + 704), (__int128 *)&v51);
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (!v46)
  {
    if (ErrorLogLevelForModule >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCVideoJitterBuffer_Create_cold_5();
    }
LABEL_64:
    VCVideoJitterBuffer_Finalize(v3);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCVideoJitterBuffer_Create_cold_2();
    }
    return 0;
  }
  if (ErrorLogLevelForModule >= 7)
  {
    v48 = VRTraceErrorLogLevelToCSTR();
    v49 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      v63 = v48;
      v64 = 2080;
      v65 = "VCVideoJitterBuffer_Create";
      v66 = 1024;
      v67 = 233;
      _os_log_impl(&dword_1D8A54000, v49, OS_LOG_TYPE_DEFAULT, "VCVideoJitterBuffer [%s] %s:%d Video Jitter Buffer Created Successfully", buf, 0x1Cu);
    }
  }
  return v3;
}

uint64_t _VCVideoJitterBuffer_GetJBTargetFromEstimatedTarget(uint64_t a1, float *a2)
{
  double *v4;
  float v5;
  uint64_t result;
  double v7;
  float v8;
  float v9;
  double v10;
  float v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (a1 && a2)
  {
    v4 = (double *)(a1 + 82008);
    if (*(_DWORD *)(a1 + 200) == 3)
    {
      result = 0;
      v10 = v4[2];
    }
    else
    {
      v13 = 0u;
      v14 = 0u;
      v12 = 0u;
      v5 = *a2;
      JTargetJBEstimator_GetSharedSettings(a1 + 704, (uint64_t)&v12);
      result = 0;
      v7 = v4[2];
      v8 = fmax(v7, (double)(int)(ceil(fmax(v5 + 0.000005, 0.0) * (double)*(unsigned int *)(a1 + 216)) - *v4)/ (double)*(unsigned int *)(a1 + 216));
      v9 = fmax(v8, fmax(*(double *)&v13, v7));
      v10 = fmin(v9, *((double *)&v13 + 1));
    }
    v11 = v10;
    *a2 = v11;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCVideoJitterBuffer_GetJBTargetFromEstimatedTarget_cold_1();
    }
    return 4;
  }
  return result;
}

void VCVideoJitterBuffer_Finalize(_QWORD *a1)
{
  int ErrorLogLevelForModule;
  uint64_t v3;
  NSObject *v4;
  const void *v5;
  int v6;
  uint64_t v7;
  __int16 v8;
  const char *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (a1)
  {
    if (ErrorLogLevelForModule >= 7)
    {
      v3 = VRTraceErrorLogLevelToCSTR();
      v4 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v6 = 136315906;
        v7 = v3;
        v8 = 2080;
        v9 = "VCVideoJitterBuffer_Finalize";
        v10 = 1024;
        v11 = 293;
        v12 = 2048;
        v13 = a1;
        _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, "VCVideoJitterBuffer [%s] %s:%d Cleaning up Video JitterBuffer (0x%p)", (uint8_t *)&v6, 0x26u);
      }
    }
    JTargetJBEstimator_Finalize((uint64_t)(a1 + 88));
    LogDump_CloseLog(a1[10241]);
    v5 = (const void *)a1[29];
    if (v5)
      CFRelease(v5);
    free(a1);
  }
  else if (ErrorLogLevelForModule >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCVideoJitterBuffer_Finalize_cold_1();
  }
}

void VCVideoJitterBuffer_UpdateMode(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  double v5;
  double v6;
  double DoubleValueForKey;
  int v8;
  double v9;
  double v10;
  unint64_t v11;
  int v12;
  double v13;
  double v14;
  double v15;
  double v16;
  int v17;
  double v18;
  int ErrorLogLevelForModule;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  os_log_t *v26;
  uint64_t v27;
  NSObject *v28;
  uint64_t v29;
  NSObject *v30;
  unint64_t v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  uint8_t buf[4];
  uint64_t v42;
  __int16 v43;
  const char *v44;
  __int16 v45;
  int v46;
  __int16 v47;
  _BYTE v48[14];
  __int16 v49;
  uint64_t v50;
  __int16 v51;
  uint64_t v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v4 = a1 + 81880;
    v40 = 0u;
    v38 = 0u;
    v39 = 0u;
    v36 = 0u;
    v37 = 0u;
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    *(_DWORD *)(a1 + 200) = a2;
    v5 = 0.1;
    v6 = 0.1;
    if (a2 <= 3)
      v6 = dbl_1D91091C8[a2];
    DoubleValueForKey = VCDefaults_GetDoubleValueForKey(CFSTR("videoJitterBufferMinQueueSize"), v6);
    *(double *)(v4 + 144) = DoubleValueForKey;
    v8 = *(_DWORD *)(a1 + 200);
    if (v8)
    {
      if (v8 == 3)
      {
        v5 = *(double *)(a1 + 240);
LABEL_14:
        *(double *)&v11 = VCDefaults_GetDoubleValueForKey(CFSTR("videoJitterBufferMinQueueSize"), v5);
        v31 = v11;
        v12 = *(_DWORD *)(a1 + 200);
        if (v12)
        {
          if (v12 == 3)
          {
            v13 = *(double *)(a1 + 240);
LABEL_21:
            v16 = VCDefaults_GetDoubleValueForKey(CFSTR("maxVideoJitterBufferSize"), v13);
            *((double *)&v32 + 1) = v16;
            v17 = *(_DWORD *)(a1 + 200);
            if (v17 == 2)
            {
              *(_QWORD *)&v33 = 0x3FD0000000000000;
            }
            else
            {
              LODWORD(v16) = *(_DWORD *)(a1 + 216);
              *(double *)&v33 = 3.0 / (double)*(unint64_t *)&v16;
              if (v17 == 3)
              {
                v18 = 0.95;
                if (*(double *)(a1 + 240) == 0.0)
                  v18 = 0.0;
                goto LABEL_29;
              }
              if (v17 == 1)
              {
                v18 = 0.95;
                goto LABEL_29;
              }
            }
            v18 = 0.98;
LABEL_29:
            *((_QWORD *)&v34 + 1) = VCDefaults_GetDoubleValueForKey(CFSTR("percentToCoverInJitterBufferCdf"), v18);
            JTargetJBEstimator_UpdateJitterBufferParams(a1 + 704, (uint64_t *)&v31);
            *(_DWORD *)v4 = 1;
            JTargetJBEstimator_NewStream(a1 + 704, *(_DWORD *)(a1 + 220), *(_WORD *)(v4 + 12));
            ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
            v26 = (os_log_t *)MEMORY[0x1E0CF2758];
            if (ErrorLogLevelForModule >= 7)
            {
              v27 = VRTraceErrorLogLevelToCSTR();
              v28 = *v26;
              if (os_log_type_enabled(*v26, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315906;
                v42 = v27;
                v43 = 2080;
                v44 = "VCVideoJitterBuffer_UpdateMode";
                v45 = 1024;
                v46 = 284;
                v47 = 2048;
                *(_QWORD *)v48 = a1;
                _os_log_impl(&dword_1D8A54000, v28, OS_LOG_TYPE_DEFAULT, "VCVideoJitterBuffer [%s] %s:%d [%p] JBState NEWSTREAM -> SETTLE", buf, 0x26u);
              }
            }
            VRLogfilePrint(*(_QWORD *)(v4 + 48), "State = STATE_NEWSTREAM, iSampleRate = %d\nState = SETTLE\n", v20, v21, v22, v23, v24, v25, *(_DWORD *)(a1 + 220));
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v29 = VRTraceErrorLogLevelToCSTR();
              v30 = *v26;
              if (os_log_type_enabled(*v26, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136316674;
                v42 = v29;
                v43 = 2080;
                v44 = "VCVideoJitterBuffer_UpdateMode";
                v45 = 1024;
                v46 = 287;
                v47 = 1024;
                *(_DWORD *)v48 = a2;
                *(_WORD *)&v48[4] = 2048;
                *(_QWORD *)&v48[6] = v31;
                v49 = 2048;
                v50 = *((_QWORD *)&v32 + 1);
                v51 = 2048;
                v52 = *((_QWORD *)&v34 + 1);
                _os_log_impl(&dword_1D8A54000, v30, OS_LOG_TYPE_DEFAULT, "VCVideoJitterBuffer [%s] %s:%d Video jitter buffer reconfigured with new mode %d. minQ size %f maxQ size %f targetPercentileToCover %f", buf, 0x40u);
              }
            }
            return;
          }
          v13 = 0.5;
          if (v12 != 1)
            goto LABEL_21;
          LODWORD(v13) = *(_DWORD *)(a1 + 216);
          v14 = (double)*(unint64_t *)&v13;
          v15 = 5.0;
        }
        else
        {
          LODWORD(v11) = *(_DWORD *)(a1 + 216);
          v14 = (double)v11;
          v15 = 6.0;
        }
        v13 = v15 / v14;
        goto LABEL_21;
      }
      if (v8 != 1)
        goto LABEL_14;
      LODWORD(DoubleValueForKey) = *(_DWORD *)(a1 + 216);
      v9 = (double)*(unint64_t *)&DoubleValueForKey;
      v10 = 0.0;
    }
    else
    {
      LODWORD(DoubleValueForKey) = *(_DWORD *)(a1 + 216);
      v9 = (double)*(unint64_t *)&DoubleValueForKey;
      v10 = 3.0;
    }
    v5 = v10 / v9;
    goto LABEL_14;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCVideoJitterBuffer_UpdateMode_cold_1();
  }
}

double VCVideoJitterBuffer_GetTargetJitterQueueSize(uint64_t a1)
{
  double v1;

  if (a1)
    return *(double *)(a1 + 81912);
  v1 = 0.0;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCVideoJitterBuffer_GetTargetJitterQueueSize_cold_1();
  }
  return v1;
}

double VCVideoJitterBuffer_GetJitterBufferMaxQueueSize(uint64_t a1)
{
  double v1;

  if (a1)
    return *(double *)(a1 + 736);
  v1 = 0.0;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCVideoJitterBuffer_GetJitterBufferMaxQueueSize_cold_1();
  }
  return v1;
}

double VCVideoJitterBuffer_GetReferenceFrame@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  __int128 v3;
  __int128 v4;

  if (a1)
  {
    v3 = *(_OWORD *)(a1 + 81936);
    v4 = *(_OWORD *)(a1 + 81952);
    *a2 = v3;
    a2[1] = v4;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCVideoJitterBuffer_GetReferenceFrame_cold_1();
    }
    *(_QWORD *)&v3 = 0;
    *a2 = 0u;
    a2[1] = 0u;
  }
  return *(double *)&v3;
}

void VCVideoJitterBuffer_EnqueueFrame(uint64_t a1, uint64_t a2, __int128 *a3)
{
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  int v10;
  unsigned int v11;
  int v12;
  int v13;
  __int16 v14;
  unsigned int v15;
  unsigned int v16;
  BOOL v18;
  int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  NSObject *v28;
  double v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  NSObject *v37;
  NSObject *v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  double v48;
  double v49;
  double v50;
  double v51;
  uint64_t v52;
  int v53;
  uint64_t v54;
  double v55;
  BOOL v56;
  BOOL v57;
  uint64_t v58;
  NSObject *v59;
  uint64_t v60;
  int v61;
  double v62;
  double v63;
  uint64_t v64;
  char v65;
  __int128 v66;
  __int128 v67;
  uint64_t v68;
  _BYTE v69[22];
  __int16 v70;
  int v71;
  __int16 v72;
  uint64_t v73;
  __int16 v74;
  int v75;
  _QWORD buf[8];

  buf[7] = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a2)
    {
      v6 = a1 + 81880;
      if (!*(_BYTE *)(a2 + 75) || *(_DWORD *)v6 >= 4u && *(_BYTE *)(a1 + 81920))
      {
        v68 = 0;
        v66 = 0u;
        v67 = 0u;
        v8 = *(_DWORD *)(a1 + 216);
        v7 = *(_DWORD *)(a1 + 220);
        v9 = *(_DWORD *)(a2 + 8);
        v10 = *(_DWORD *)(a1 + 81888);
        v11 = *(unsigned __int16 *)(a2 + 40);
        v12 = *(unsigned __int16 *)(a1 + 81892);
        v13 = *(unsigned __int8 *)(a2 + 38);
        BYTE12(v67) = *(_BYTE *)(a2 + 38);
        v14 = v11;
        if (!*(_BYTE *)(a2 + 39))
        {
          v14 = *(_WORD *)(a1 + 82016);
          *(_WORD *)(a1 + 82016) = v14 + 1;
        }
        v15 = v12 + 1;
        v16 = v9 - v10;
        v18 = (v15 < v11 || v16 <= 0x960) && v15 >= v11;
        LOWORD(v66) = v14;
        *(_QWORD *)&v67 = *(_QWORD *)(a2 + 48);
        DWORD1(v66) = v9;
        v19 = v7 / v8;
        if (v18)
          v20 = v16;
        else
          v20 = v19;
        DWORD2(v67) = v20;
        LODWORD(v68) = 1;
        *(_DWORD *)(a1 + 81888) = v9;
        *(_WORD *)(a1 + 81892) = v14;
        if (v13 || !*(_DWORD *)v6)
        {
          JLagProcessor_NewStream(a1 + 248, (__int16 *)&v66, v7, v20);
          JTargetJBEstimator_NewStream(a1 + 704, *(_DWORD *)(a1 + 220), v66);
          *(_DWORD *)v6 = 1;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v27 = VRTraceErrorLogLevelToCSTR();
            v28 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(buf[0]) = 136315906;
              *(_QWORD *)((char *)buf + 4) = v27;
              WORD2(buf[1]) = 2080;
              *(_QWORD *)((char *)&buf[1] + 6) = "VCVideoJitterBuffer_EnqueueFrame";
              HIWORD(buf[2]) = 1024;
              LODWORD(buf[3]) = 471;
              WORD2(buf[3]) = 2048;
              *(_QWORD *)((char *)&buf[3] + 6) = a1;
              _os_log_impl(&dword_1D8A54000, v28, OS_LOG_TYPE_DEFAULT, "VCVideoJitterBuffer [%s] %s:%d [%p] JBState NEWSTREAM -> SETTLE", (uint8_t *)buf, 0x26u);
            }
          }
          VRLogfilePrint(*(_QWORD *)(v6 + 48), "State = STATE_NEWSTREAM, iSampleRate = %d\nState = SETTLE\n", v21, v22, v23, v24, v25, v26, *(_DWORD *)(a1 + 220));
        }
        else
        {
          v29 = JLagProcessor_Process(a1 + 248, (unsigned __int16 *)&v66, v20, 0, *(_DWORD *)v6);
          if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            v36 = VRTraceErrorLogLevelToCSTR();
            v37 = *MEMORY[0x1E0CF2758];
            v38 = *MEMORY[0x1E0CF2758];
            if (*MEMORY[0x1E0CF2748])
            {
              if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
              {
                LODWORD(buf[0]) = 136316162;
                *(_QWORD *)((char *)buf + 4) = v36;
                WORD2(buf[1]) = 2080;
                *(_QWORD *)((char *)&buf[1] + 6) = "VCVideoJitterBuffer_EnqueueFrame";
                HIWORD(buf[2]) = 1024;
                LODWORD(buf[3]) = 478;
                WORD2(buf[3]) = 2048;
                *(double *)((char *)&buf[3] + 6) = v29;
                HIWORD(buf[4]) = 1024;
                LODWORD(buf[5]) = DWORD1(v66);
                _os_log_impl(&dword_1D8A54000, v37, OS_LOG_TYPE_DEFAULT, "VCVideoJitterBuffer [%s] %s:%d video lag is %f for RTPTimestamp=%u", (uint8_t *)buf, 0x2Cu);
              }
            }
            else if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
            {
              LODWORD(buf[0]) = 136316162;
              *(_QWORD *)((char *)buf + 4) = v36;
              WORD2(buf[1]) = 2080;
              *(_QWORD *)((char *)&buf[1] + 6) = "VCVideoJitterBuffer_EnqueueFrame";
              HIWORD(buf[2]) = 1024;
              LODWORD(buf[3]) = 478;
              WORD2(buf[3]) = 2048;
              *(double *)((char *)&buf[3] + 6) = v29;
              HIWORD(buf[4]) = 1024;
              LODWORD(buf[5]) = DWORD1(v66);
              _os_log_debug_impl(&dword_1D8A54000, v37, OS_LOG_TYPE_DEBUG, "VCVideoJitterBuffer [%s] %s:%d video lag is %f for RTPTimestamp=%u", (uint8_t *)buf, 0x2Cu);
            }
          }
          v39 = *a3;
          v40 = a3[1];
          *(_OWORD *)(v6 + 96) = *a3;
          *(_OWORD *)(v6 + 112) = v40;
          if (*(_DWORD *)v6 == 1)
          {
            LODWORD(v39) = *(_DWORD *)(a1 + 216);
            if (fabs(v29) >= 1.0 / (double)(unint64_t)v39)
              return;
            *(_DWORD *)v6 = 2;
            VRLogfilePrint(*(_QWORD *)(v6 + 48), "State = FILL\n", v30, v31, v32, v33, v34, v35, v65);
          }
          if (*(_DWORD *)v6 <= 3u)
            *(_DWORD *)(v6 + 4) += DWORD2(v67);
          if (*(_DWORD *)v6 == 2)
          {
            JTargetJBEstimator_GetMinJBSize(a1 + 704);
            LODWORD(v47) = *(_DWORD *)(v6 + 4);
            if ((double)v47 / (double)*(int *)(a1 + 220) > v48)
            {
              *(_DWORD *)v6 = 4;
              VRLogfilePrint(*(_QWORD *)(v6 + 48), "State = RUN\n", v41, v42, v43, v44, v45, v46, v65);
            }
          }
          memset(&buf[2], 0, 32);
          buf[0] = (unsigned __int16)v66;
          buf[1] = v67;
          buf[2] = DWORD2(v67) | 0x100000000;
          LODWORD(buf[3]) = DWORD1(v66);
          buf[4] = *(_QWORD *)(a2 + 64);
          JTargetJBEstimator_Process(a1 + 704, (double *)buf, v29);
          if (!*(_BYTE *)(a1 + 80360))
          {
            v51 = *(double *)(a1 + 66776);
            if (v51 != *(double *)(v6 + 88))
            {
              v52 = *(int *)(a1 + 66828);
              v53 = *(_DWORD *)(a1 + 760 + 4 * v52 + 36000);
              *(_DWORD *)(v6 + 64) = v53;
              v54 = a1 + 760 + 8 * v52;
              *(_QWORD *)(v6 + 56) = *(_QWORD *)(v54 + 42000);
              v55 = *(double *)(v54 + 54000);
              *(double *)(v6 + 72) = v55;
              v56 = v55 != 0.0 || v53 == 0;
              v57 = v56;
              *(_BYTE *)(v6 + 80) = v57;
              *(double *)(v6 + 88) = v51;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v58 = VRTraceErrorLogLevelToCSTR();
                v59 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                {
                  v60 = *(_QWORD *)(v6 + 88);
                  v61 = *(_DWORD *)(v6 + 64);
                  *(_DWORD *)v69 = 136316162;
                  *(_QWORD *)&v69[4] = v58;
                  *(_WORD *)&v69[12] = 2080;
                  *(_QWORD *)&v69[14] = "VCVideoJitterBuffer_EnqueueFrame";
                  v70 = 1024;
                  v71 = 523;
                  v72 = 2048;
                  v73 = v60;
                  v74 = 1024;
                  v75 = v61;
                  _os_log_impl(&dword_1D8A54000, v59, OS_LOG_TYPE_DEFAULT, "VCVideoJitterBuffer [%s] %s:%d Found new lowest minLag of %f for RTPTimestamp=%u", v69, 0x2Cu);
                }
              }
            }
          }
          v49 = *(double *)(a1 + 81288);
          if (*(_DWORD *)(a1 + 200) == 3)
            v49 = *(double *)(v6 + 144);
          v50 = fmax(*(double *)(v6 + 144), (double)(int)(ceil(fmax(v49 + 0.000005, 0.0) * (double)*(unsigned int *)(a1 + 216))- *(double *)(v6 + 128))/ (double)*(unsigned int *)(a1 + 216));
          *(double *)(v6 + 24) = v50;
          *(double *)(v6 + 32) = v50;
          *(double *)(v6 + 16) = v49;
          memset(v69, 170, 20);
          if (*(_QWORD *)(v6 + 48))
          {
            LogDump_GetTimestampString(*(double *)&v67);
            JTargetJBEstimator_GetStatistics(a1 + 704);
            JLagProcessor_GetStatistics(a1 + 248);
            v63 = *(double *)(v6 + 24);
            v62 = *(double *)(v6 + 32);
            if (v62 == v63)
            {
              v64 = 0;
            }
            else if (v62 <= v63)
            {
              if (v62 >= v63)
                v64 = 3;
              else
                v64 = 1;
            }
            else
            {
              v64 = 2;
            }
            VRLogfilePrint(*(_QWORD *)(v6 + 48), "%s\t%u\t%u\t%d\t%d\t%d\t%u\t%u\t%d\t%02.6f\t%02.6f\t%02.6f\t%02.6f\t%02.4f\t%02.4f\t%d\t%02.6f\t%02.6f\t%02.6f\t%02.4f\t%02.4f\t%02.4f\t%02.4f\t%02.4f\t%6d\t%6d\t%d\t%d\t%s\t%d\t%u\t%u\t%u\t%d\t%d\t%d\t%02.4f\t%02.4f\t%zu\n", (uint64_t)jitterBufferPlaybackMode[v64], (unsigned __int16)v66, *(unsigned __int16 *)(a2 + 16), *(unsigned __int8 *)(a2 + 14), *(unsigned __int16 *)(a2 + 12), *(_QWORD *)(a2 + 80), (char)v69);
          }
          if (!*(_BYTE *)(v6 + 40) && *(_BYTE *)(a2 + 15))
            *(_BYTE *)(v6 + 40) = 1;
        }
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCVideoJitterBuffer_EnqueueFrame_cold_1();
  }
}

void VCVideoJitterBuffer_HealthPrint(uint64_t a1)
{
  uint64_t Statistics;
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  int v28;
  __int16 v29;
  uint64_t v30;
  __int16 v31;
  uint64_t v32;
  __int16 v33;
  uint64_t v34;
  __int16 v35;
  uint64_t v36;
  __int16 v37;
  uint64_t v38;
  __int16 v39;
  uint64_t v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    Statistics = JTargetJBEstimator_GetStatistics(a1 + 704);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      v3 = VRTraceErrorLogLevelToCSTR();
      v4 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v6 = *(_QWORD *)(Statistics + 16);
        v5 = *(_QWORD *)(Statistics + 24);
        v7 = *(_QWORD *)(Statistics + 8);
        v8 = *(_DWORD *)(Statistics + 48);
        v9 = *(_QWORD *)(Statistics + 56);
        v10 = *(_QWORD *)(Statistics + 64);
        v11 = *(_QWORD *)(a1 + 81912);
        v12 = *(_QWORD *)(Statistics + 72);
        v13 = *(_QWORD *)(Statistics + 80);
        v14 = *(_QWORD *)(Statistics + 88);
        v15 = 136318210;
        v16 = v3;
        v17 = 2080;
        v18 = "VCVideoJitterBuffer_HealthPrint";
        v19 = 1024;
        v20 = 547;
        v21 = 2048;
        v22 = v7;
        v23 = 2048;
        v24 = v5;
        v25 = 2048;
        v26 = v6;
        v27 = 1024;
        v28 = v8;
        v29 = 2048;
        v30 = v9;
        v31 = 2048;
        v32 = v10;
        v33 = 2048;
        v34 = v12;
        v35 = 2048;
        v36 = v13;
        v37 = 2048;
        v38 = v11;
        v39 = 2048;
        v40 = v14;
        _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, "VCVideoJitterBuffer [%s] %s:%d @=@ Health: VideoJitterBuffer avgLag=%f maxLag=%f minLag=%f flat=%d clippedLag=%f minLagAdj=%f minClipThresh=%f targetSize=%f quantizedTargetQueueSizeInSeconds=%f targetSizeIndependent=%f", (uint8_t *)&v15, 0x7Cu);
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCVideoJitterBuffer_HealthPrint_cold_1();
  }
}

uint64_t _VCAudioPowerSpectrumSource_CompareListEntries(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  BOOL v4;
  unsigned int v5;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a2 + 8);
  v4 = v2 == v3;
  v5 = 2 * (v2 >= v3);
  if (v4)
    return 1;
  else
    return v5;
}

void VCAudioPowerSpectrumSource_FreeClient(id **a1)
{
  id *v1;

  v1 = *a1;
  *a1 = 0;
  if (v1)
  {

    free(v1);
  }
}

id *VCAudioPowerSpectrumSource_PushAudioSamples(id *result, uint64_t a2)
{
  if (result)
    return VCAudioPowerSpectrumSource_ProcessAudioSamples((uint64_t)(result + 22), a2);
  return result;
}

id *VCAudioPowerSpectrumSource_ProcessAudioSamples(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  id *result;
  uint64_t v5;
  os_log_t *v6;
  int v7;
  uint64_t v8;
  NSObject *v9;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  int v13;
  uint64_t v14;
  id *v15;
  id *v16;
  _BYTE buf[12];
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  uint64_t v23;
  uint64_t v24;

  v3 = a1;
  v24 = *MEMORY[0x1E0C80C00];
  result = (id *)CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 32));
  v15 = result;
  if (result)
  {
    v5 = (uint64_t)result;
    v6 = (os_log_t *)MEMORY[0x1E0CF2758];
    while (1)
    {
      v7 = *(_DWORD *)(v5 + 32);
      if (v7 == 2)
        break;
      if (v7 != 1)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v11 = VRTraceErrorLogLevelToCSTR();
          v12 = *v6;
          if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
          {
            v13 = *(_DWORD *)(v5 + 32);
            *(_DWORD *)buf = 136315906;
            *(_QWORD *)&buf[4] = v11;
            v18 = 2080;
            v19 = "_VCAudioPowerSpectrumSource_ProcessEventQueue";
            v20 = 1024;
            v21 = 146;
            v22 = 1024;
            LODWORD(v23) = v13;
            _os_log_error_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_ERROR, " [%s] %s:%d Invalid operation: %d", buf, 0x22u);
          }
        }
        VCAudioPowerSpectrumSource_FreeClient(&v15);
        goto LABEL_20;
      }
      v16 = (id *)v5;
      if ((VCSingleLinkedListPush(v3, (_QWORD *)v5) & 1) == 0)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v8 = VRTraceErrorLogLevelToCSTR();
          v9 = *v6;
          if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
          {
            v14 = *(_QWORD *)(v5 + 8);
            *(_DWORD *)buf = 136315906;
            *(_QWORD *)&buf[4] = v8;
            v18 = 2080;
            v19 = "_VCAudioPowerSpectrumSource_ProcessAddEvent";
            v20 = 1024;
            v21 = 113;
            v22 = 2048;
            v23 = v14;
            _os_log_error_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_ERROR, " [%s] %s:%d error powerSpectrum[%p] already registered", buf, 0x26u);
          }
        }
        VCAudioPowerSpectrumSource_FreeClient(&v16);
      }
      v10 = (void *)MEMORY[0x1DF086F1C](v3 + 40);
      objc_msgSend(v10, "audioPowerSpectrumSinkDidRegister");
      if (v10)
        goto LABEL_15;
LABEL_20:
      result = (id *)CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(v3 + 32));
      v5 = (uint64_t)result;
      v15 = result;
      if (!result)
        goto LABEL_23;
    }
    *(_QWORD *)buf = v5;
    v16 = (id *)VCSingleLinkedListRemove(v3, v5);
    if (v16)
      VCAudioPowerSpectrumSource_FreeClient(&v16);
    VCAudioPowerSpectrumSource_FreeClient((id **)buf);
    v10 = (void *)MEMORY[0x1DF086F1C](v3 + 40);
    objc_msgSend(v10, "audioPowerSpectrumSinkDidUnregister");
    if (!v10)
      goto LABEL_20;
LABEL_15:
    CFRelease(v10);
    goto LABEL_20;
  }
LABEL_23:
  while (1)
  {
    v3 = *(_QWORD *)v3;
    if (!v3)
      break;
    result = (id *)(*(uint64_t (**)(_QWORD, uint64_t))(v3 + 16))(*(_QWORD *)(v3 + 8), a2);
  }
  return result;
}

void VCAudioPowerSpectrumSource_RegisterAudioPowerSpectrumSink(CMSimpleQueueRef *a1, void *a2, void *a3, void *a4, void *a5)
{
  id *v10;
  OSStatus v11;
  OSStatus v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  NSObject *v16;
  CMSimpleQueueRef v17;
  id *v18;
  uint8_t buf[4];
  uint64_t v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  id *v26;
  __int16 v27;
  CMSimpleQueueRef *v28;
  __int16 v29;
  void *v30;
  __int16 v31;
  CMSimpleQueueRef v32;
  __int16 v33;
  OSStatus v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  if (a2 && a1 && a3 && a5)
  {
    v10 = (id *)malloc_type_calloc(1uLL, 0x30uLL, 0x10A00401D15B2DDuLL);
    v18 = v10;
    v10[1] = a2;
    v10[2] = a5;
    v10[3] = a3;
    *((_DWORD *)v10 + 8) = 1;
    v10[5] = a4;
    v11 = CMSimpleQueueEnqueue(a1[4], v10);
    if (v11)
    {
      v12 = v11;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v13 = VRTraceErrorLogLevelToCSTR();
        v14 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v17 = a1[4];
          *(_DWORD *)buf = 136316930;
          v20 = v13;
          v21 = 2080;
          v22 = "VCAudioPowerSpectrumSource_RegisterAudioPowerSpectrumSink";
          v23 = 1024;
          v24 = 170;
          v25 = 2048;
          v26 = v10;
          v27 = 2048;
          v28 = a1;
          v29 = 2048;
          v30 = a2;
          v31 = 2048;
          v32 = v17;
          v33 = 1024;
          v34 = v12;
          _os_log_error_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_ERROR, " [%s] %s:%d Failed to enqueue cient=%p realtimeContext=%p clientContext=%p queue=%p status=%d", buf, 0x4Au);
        }
      }
      VCAudioPowerSpectrumSource_FreeClient(&v18);
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v15 = VRTraceErrorLogLevelToCSTR();
    v16 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136316674;
      v20 = v15;
      v21 = 2080;
      v22 = "VCAudioPowerSpectrumSource_RegisterAudioPowerSpectrumSink";
      v23 = 1024;
      v24 = 156;
      v25 = 2048;
      v26 = (id *)a1;
      v27 = 2048;
      v28 = (CMSimpleQueueRef *)a2;
      v29 = 2048;
      v30 = a5;
      v31 = 2048;
      v32 = (CMSimpleQueueRef)a3;
      _os_log_error_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_ERROR, " [%s] %s:%d Invalid client registration. RealtimeContext[%p] clientContext[%p] callback[%p] sinkObject[%p]", buf, 0x44u);
    }
  }
}

void VCAudioPowerSpectrumSource_UnregisterAudioPowerSpectrumSink(CMSimpleQueueRef *a1, void *a2)
{
  id *v4;
  OSStatus v5;
  OSStatus v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  CMSimpleQueueRef v11;
  id *v12;
  uint8_t buf[4];
  uint64_t v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  id *v20;
  __int16 v21;
  CMSimpleQueueRef *v22;
  __int16 v23;
  void *v24;
  __int16 v25;
  CMSimpleQueueRef v26;
  __int16 v27;
  OSStatus v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  if (a1 && a2)
  {
    v4 = (id *)malloc_type_calloc(1uLL, 0x30uLL, 0x10A00401D15B2DDuLL);
    v12 = v4;
    v4[1] = a2;
    v4[3] = 0;
    *((_DWORD *)v4 + 8) = 2;
    v5 = CMSimpleQueueEnqueue(a1[4], v4);
    if (v5)
    {
      v6 = v5;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v7 = VRTraceErrorLogLevelToCSTR();
        v8 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v11 = a1[4];
          *(_DWORD *)buf = 136316930;
          v14 = v7;
          v15 = 2080;
          v16 = "VCAudioPowerSpectrumSource_UnregisterAudioPowerSpectrumSink";
          v17 = 1024;
          v18 = 188;
          v19 = 2048;
          v20 = v4;
          v21 = 2048;
          v22 = a1;
          v23 = 2048;
          v24 = a2;
          v25 = 2048;
          v26 = v11;
          v27 = 1024;
          v28 = v6;
          _os_log_error_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_ERROR, " [%s] %s:%d Failed to enqueue client=%p realtimeContext=%p clientContext=%p queue=%p status=%d", buf, 0x4Au);
        }
      }
      VCAudioPowerSpectrumSource_FreeClient(&v12);
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v9 = VRTraceErrorLogLevelToCSTR();
    v10 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136316162;
      v14 = v9;
      v15 = 2080;
      v16 = "VCAudioPowerSpectrumSource_UnregisterAudioPowerSpectrumSink";
      v17 = 1024;
      v18 = 178;
      v19 = 2048;
      v20 = (id *)a1;
      v21 = 2048;
      v22 = (CMSimpleQueueRef *)a2;
      _os_log_error_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_ERROR, " [%s] %s:%d Invalid client unregistration: RealtimeContext[%p] clientContext[%p]", buf, 0x30u);
    }
  }
}

void sub_1D8ACCA1C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1DF087DC8](v1, 0x1080C400355024FLL);
  _Unwind_Resume(a1);
}

void sub_1D8ACCAF0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1DF087DC8](v1, 0x1080C400355024FLL);
  _Unwind_Resume(a1);
}

const __CFDictionary *VCMicrophonePreferencesCMS_GetBuiltInMicPortDictionaryFromSelectableInputsArray(const void *a1)
{
  CFTypeID TypeID;
  CFIndex Count;
  CFIndex v4;
  CFIndex v5;
  const void *v6;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v8;
  CFTypeID v9;

  if (!a1 || (TypeID = CFArrayGetTypeID(), TypeID != CFGetTypeID(a1)))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCMicrophonePreferencesCMS_GetBuiltInMicPortDictionaryFromSelectableInputsArray_cold_1();
    }
    return 0;
  }
  Count = CFArrayGetCount((CFArrayRef)a1);
  if (Count < 1)
  {
LABEL_9:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCMicrophonePreferencesCMS_GetBuiltInMicPortDictionaryFromSelectableInputsArray_cold_2();
    }
    return 0;
  }
  v4 = Count;
  v5 = 0;
  v6 = (const void *)*MEMORY[0x1E0D49EB8];
  while (1)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)a1, v5);
    if (ValueAtIndex)
    {
      v8 = ValueAtIndex;
      v9 = CFDictionaryGetTypeID();
      if (v9 == CFGetTypeID(v8))
      {
        CFDictionaryGetValue(v8, v6);
        if (FigCFEqual())
          return v8;
      }
    }
    if (v4 == ++v5)
      goto LABEL_9;
  }
}

BOOL VCMicrophonePreferencesCMS_GetDataSourcesFromPortDictionary(const void *a1, _QWORD *a2, _QWORD *a3)
{
  CFTypeID TypeID;
  const void *Value;
  CFTypeID v8;
  CFIndex Count;
  CFIndex v10;
  CFIndex v11;
  _QWORD *v12;
  const void *v13;
  const void *ValueAtIndex;
  const void *v15;
  CFTypeID v16;
  const __CFNumber *v17;
  const __CFNumber *v18;
  CFTypeID v19;
  _BOOL8 result;
  uint64_t v21;
  NSObject *v22;
  uint64_t v23;
  NSObject *v24;
  _BOOL4 v25;
  const void *v26;
  int valuePtr;
  uint64_t v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  int v32;
  __int16 v33;
  _QWORD *v34;
  __int16 v35;
  _QWORD *v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  if (!a1 || (TypeID = CFDictionaryGetTypeID(), TypeID != CFGetTypeID(a1)))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      return 0;
    VRTraceErrorLogLevelToCSTR();
    result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
    if (result)
    {
      VCMicrophonePreferencesCMS_GetDataSourcesFromPortDictionary_cold_1();
      return 0;
    }
    return result;
  }
  if (!a2 || !a3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      return 0;
    v21 = VRTraceErrorLogLevelToCSTR();
    v22 = *MEMORY[0x1E0CF2758];
    result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
    if (result)
    {
      valuePtr = 136316162;
      v28 = v21;
      v29 = 2080;
      v30 = "VCMicrophonePreferencesCMS_GetDataSourcesFromPortDictionary";
      v31 = 1024;
      v32 = 48;
      v33 = 2048;
      v34 = a2;
      v35 = 2048;
      v36 = a3;
      _os_log_error_impl(&dword_1D8A54000, v22, OS_LOG_TYPE_ERROR, " [%s] %s:%d frontDataSource(%p) or backDataSource(%p) == NULL", (uint8_t *)&valuePtr, 0x30u);
      return 0;
    }
    return result;
  }
  Value = CFDictionaryGetValue((CFDictionaryRef)a1, (const void *)*MEMORY[0x1E0D49E70]);
  if (!Value)
  {
    v12 = 0;
    goto LABEL_32;
  }
  v8 = CFArrayGetTypeID();
  if (v8 != CFGetTypeID(Value) || (Count = CFArrayGetCount((CFArrayRef)Value), Count < 1))
  {
    v12 = 0;
    Value = 0;
    goto LABEL_32;
  }
  v10 = Count;
  v11 = 0;
  v12 = 0;
  v26 = 0;
  v13 = (const void *)*MEMORY[0x1E0D49DC8];
  do
  {
    ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)Value, v11);
    if (!ValueAtIndex)
      goto LABEL_20;
    v15 = ValueAtIndex;
    v16 = CFDictionaryGetTypeID();
    if (v16 != CFGetTypeID(v15))
      goto LABEL_20;
    v17 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v15, v13);
    if (!v17)
      goto LABEL_20;
    v18 = v17;
    v19 = CFGetTypeID(v17);
    if (v19 != CFNumberGetTypeID())
      goto LABEL_20;
    valuePtr = 0;
    CFNumberGetValue(v18, kCFNumberSInt32Type, &valuePtr);
    if (valuePtr == 1718775412)
    {
      v26 = v15;
      if (!v12)
        goto LABEL_20;
    }
    else
    {
      if (valuePtr == 1650549611)
        v12 = v15;
      if (!v12)
        goto LABEL_20;
    }
    if (v26)
      break;
LABEL_20:
    ++v11;
  }
  while (v10 != v11);
  Value = v26;
  if (v26 && v12)
  {
    *a2 = v26;
    *a3 = v12;
    return 1;
  }
LABEL_32:
  if ((int)VRTraceGetErrorLogLevelForModule() < 7)
    return 0;
  v23 = VRTraceErrorLogLevelToCSTR();
  v24 = *MEMORY[0x1E0CF2758];
  v25 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
  result = 0;
  if (v25)
  {
    valuePtr = 136316162;
    v28 = v23;
    v29 = 2080;
    v30 = "VCMicrophonePreferencesCMS_GetDataSourcesFromPortDictionary";
    v31 = 1024;
    v32 = 79;
    v33 = 2048;
    v34 = Value;
    v35 = 2048;
    v36 = v12;
    _os_log_impl(&dword_1D8A54000, v24, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Did not find both orientations: front = %p, back = %p", (uint8_t *)&valuePtr, 0x30u);
    return 0;
  }
  return result;
}

__CFDictionary *VCMicrophonePreferencesCMS_CreateSelectedInputDictWithPolarPattern(const __CFDictionary *a1, CFTypeRef cf)
{
  CFTypeID v4;
  const __CFArray *Value;
  const __CFArray *v6;
  CFTypeID v7;
  CFIndex Count;
  CFIndex v9;
  CFIndex v10;
  const __CFNumber *ValueAtIndex;
  const void *v12;
  const void *v13;
  __CFDictionary *Mutable;
  __CFDictionary *v15;
  uint64_t v16;
  NSObject *v17;
  int v19;
  uint64_t v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  const __CFDictionary *v26;
  __int16 v27;
  CFTypeRef v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  if (a1 && cf)
  {
    v19 = 0;
    v4 = CFGetTypeID(cf);
    if (v4 == CFDictionaryGetTypeID()
      && (Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)cf, (const void *)*MEMORY[0x1E0D49DD0])) != 0
      && (v6 = Value, v7 = CFGetTypeID(Value), v7 == CFArrayGetTypeID())
      && (Count = CFArrayGetCount(v6), Count >= 1))
    {
      v9 = Count;
      v10 = 0;
      while (1)
      {
        ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(v6, v10);
        CFNumberGetValue(ValueAtIndex, kCFNumberSInt32Type, &v19);
        if (v19 != 1869442665)
          break;
        if (v9 == ++v10)
          goto LABEL_10;
      }
    }
    else
    {
LABEL_10:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCMicrophonePreferencesCMS_CreateSelectedInputDictWithPolarPattern_cold_1();
      }
      ValueAtIndex = 0;
    }
    v12 = CFDictionaryGetValue(a1, (const void *)*MEMORY[0x1E0D49E88]);
    v13 = CFDictionaryGetValue((CFDictionaryRef)cf, (const void *)*MEMORY[0x1E0D49DC0]);
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v15 = Mutable;
    if (v12)
      CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0D49F08], v12);
    if (v13)
      CFDictionaryAddValue(v15, (const void *)*MEMORY[0x1E0D49EF8], v13);
    if (ValueAtIndex)
      CFDictionaryAddValue(v15, (const void *)*MEMORY[0x1E0D49F00], ValueAtIndex);
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v16 = VRTraceErrorLogLevelToCSTR();
      v17 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v19 = 136316162;
        v20 = v16;
        v21 = 2080;
        v22 = "VCMicrophonePreferencesCMS_CreateSelectedInputDictWithPolarPattern";
        v23 = 1024;
        v24 = 112;
        v25 = 2048;
        v26 = a1;
        v27 = 2048;
        v28 = cf;
        _os_log_error_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_ERROR, " [%s] %s:%d inPortDictionary(%p) or inSourceDict(%p) == NULL", (uint8_t *)&v19, 0x30u);
      }
    }
    return 0;
  }
  return v15;
}

void VCMicrophonePreferencesCMS_ApplyMicrophonePreferences(int a1, CFDictionaryRef theDict)
{
  const __CFAllocator *v2;
  CFMutableDictionaryRef MutableCopy;
  __CFArray *Mutable;
  const void *v5;

  if (theDict)
  {
    v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3, theDict);
    Mutable = CFArrayCreateMutable(v2, 1, MEMORY[0x1E0C9B378]);
    CFArrayAppendValue(Mutable, MutableCopy);
    v5 = (const void *)*MEMORY[0x1E0D49F00];
    if (CFDictionaryContainsKey(MutableCopy, (const void *)*MEMORY[0x1E0D49F00]))
    {
      if (CMSessionSetProperty())
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCMicrophonePreferencesCMS_ApplyMicrophonePreferences_cold_3();
        }
      }
      CFDictionaryRemoveValue(MutableCopy, v5);
    }
    if (CMSessionSetProperty() && (int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCMicrophonePreferencesCMS_ApplyMicrophonePreferences_cold_2();
    }
    CFRelease(MutableCopy);
    CFRelease(Mutable);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCMicrophonePreferencesCMS_ApplyMicrophonePreferences_cold_1();
  }
}

void OUTLINED_FUNCTION_5_0(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x2Cu);
}

double GKSConnectivitySettings_GetICETimeout()
{
  id v0;
  double v1;
  double v2;

  v0 = objc_alloc_init(MEMORY[0x1E0CB34A8]);
  objc_msgSend(+[GKSConnectivitySettings getClientOption:](GKSConnectivitySettings, "getClientOption:", CFSTR("gk-p2p-ice-timeout")), "doubleValue");
  v2 = v1;
  objc_msgSend(v0, "drain");
  return v2;
}

double GKSConnectivitySettings_GetNoRemotePacketsTimeout()
{
  id v0;
  double v1;
  double v2;

  v0 = objc_alloc_init(MEMORY[0x1E0CB34A8]);
  objc_msgSend(+[GKSConnectivitySettings getClientOption:](GKSConnectivitySettings, "getClientOption:", CFSTR("gk-p2p-remote-packets-timeout")), "doubleValue");
  v2 = v1;
  objc_msgSend(v0, "drain");
  return v2;
}

double GKSConnectivitySettings_GetNetworkConditionsTimeout()
{
  id v0;
  double v1;
  double v2;

  v0 = objc_alloc_init(MEMORY[0x1E0CB34A8]);
  objc_msgSend(+[GKSConnectivitySettings getClientOption:](GKSConnectivitySettings, "getClientOption:", CFSTR("gk-p2p-network-conditions-timeout")), "doubleValue");
  v2 = v1;
  objc_msgSend(v0, "drain");
  return v2;
}

double GKSConnectivitySettings_GetMinQueueSizeOverride5G()
{
  id v0;
  double v1;
  double v2;

  v0 = objc_alloc_init(MEMORY[0x1E0CB34A8]);
  objc_msgSend(+[GKSConnectivitySettings getClientOption:](GKSConnectivitySettings, "getClientOption:", CFSTR("gk-min-jitter-queue-size-5g")), "doubleValue");
  v2 = v1;
  objc_msgSend(v0, "drain");
  return v2;
}

double _VCRedundancyControlAlgorithmVideo_ApplyEnveloppe(double *a1, double a2)
{
  double result;

  result = *a1 * (1.0 - dbl_1D9109210[*a1 < a2]) + a2 * dbl_1D9109210[*a1 < a2];
  *a1 = result;
  return result;
}

uint64_t _VCRedundancyControlAlgorithmVideo_GetRedundancyLevelFromPLR(double a1)
{
  unsigned int v2;

  if (a1 < 0.05)
    return 0;
  if (a1 < 2.0)
    return 25;
  if (a1 < 5.0)
    return 50;
  if (a1 >= 30.0)
    v2 = 300;
  else
    v2 = 200;
  if (a1 >= 20.0)
    return v2;
  else
    return 100;
}

uint64_t _VCScreenCaptureVirtualDisplay_conduitPushFrame(uint64_t result)
{
  uint64_t (*v1)(_QWORD);

  v1 = *(uint64_t (**)(_QWORD))(result + 192);
  if (v1)
    return v1(*(_QWORD *)(result + 184));
  return result;
}

uint64_t _VCScreenCaptureVirtualDisplay_conduitClearScreen(void *a1, const char *a2)
{
  return objc_msgSend(a1, "shouldClearScreen:", 1);
}

void _VCAudioStreamGroup_ApplyAudioPlayoutDelay(uint64_t a1)
{
  _QWORD *v2;
  double v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  char *v7;
  int v8;
  uint64_t v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  char *v19;
  __int16 v20;
  _BOOL4 v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD **)(a1 + 176);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_QWORD *)(a1 + 384);
      v7 = FourccToCStr(*(_DWORD *)(a1 + 312));
      v8 = 136316674;
      v9 = v4;
      v10 = 2080;
      v11 = "_VCAudioStreamGroup_ApplyAudioPlayoutDelay";
      v12 = 1024;
      v13 = 707;
      v14 = 2048;
      v15 = v6;
      v16 = 2048;
      v17 = a1;
      v18 = 2080;
      v19 = v7;
      v20 = 1024;
      v21 = v2 != 0;
      _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Apply audioPlayoutDelay=%f on streamGroup=%p streamGroupID=%s streamsConfigured=%d", (uint8_t *)&v8, 0x40u);
    }
  }
  for (; v2; v2 = (_QWORD *)*v2)
    VCAudioStream_SetAudioPlayoutDelay(v2[5], *(double *)(a1 + 384), v3);
}

id *VCAudioStreamGroup_ProcessAudioSamples(uint64_t a1, uint64_t a2)
{
  const void **v4;
  const void **v5;
  int v6;
  id *result;

  v4 = (const void **)CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 344));
  if (v4)
  {
    v5 = v4;
    do
    {
      v6 = *(_DWORD *)v5;
      if (*(_DWORD *)v5 == 1)
      {
        _VCAudioStreamGroup_AddSyncDestination(a1, v5[1]);
        v6 = *(_DWORD *)v5;
      }
      if (v6 == 2)
        _VCAudioStreamGroup_RemoveSyncDestination(a1, (uint64_t)v5[1]);
      VCMemoryPool_Free(*(OSQueueHead **)(a1 + 352), v5);
      v5 = (const void **)CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 344));
    }
    while (v5);
  }
  ++*(_DWORD *)(a1 + 340);
  result = (id *)(*(uint64_t (**)(_QWORD, uint64_t))(a1 + 320))(*(_QWORD *)(a1 + 304), a2);
  if (*(_BYTE *)(a1 + 336))
    return VCAudioPowerSpectrumSource_PushAudioSamples(*(id **)(a1 + 328), a2);
  return result;
}

BOOL _VCAudioStreamGroup_AddSyncDestination(uint64_t a1, const void *a2)
{
  const void **v4;
  const void **v5;
  const void **v6;
  CFTypeRef v7;
  uint64_t v8;
  NSObject *v9;
  const void *v10;
  const void *v11;
  const char *v12;
  NSObject *v13;
  uint32_t v14;
  _BOOL8 result;
  uint64_t v16;
  NSObject *v17;
  int v18;
  uint64_t v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  const void *v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  const void *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v4 = *(const void ***)(a1 + 192);
  if (v4)
  {
    while (*v4 != a2)
    {
      v4 = (const void **)v4[2];
      if (!v4)
        goto LABEL_4;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() < 7)
      return 1;
    v16 = VRTraceErrorLogLevelToCSTR();
    v17 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      return 1;
    v18 = 136316162;
    v19 = v16;
    v20 = 2080;
    v21 = "_VCAudioStreamGroup_AddSyncDestination";
    v22 = 1024;
    v23 = 732;
    v24 = 2048;
    v25 = a2;
    v26 = 2048;
    v27 = a1;
    v12 = " [%s] %s:%d syncDestination[%p] is already in the list for streamGroup[%p]";
    v13 = v17;
    v14 = 48;
    goto LABEL_11;
  }
LABEL_4:
  v5 = (const void **)malloc_type_calloc(1uLL, 0x18uLL, 0x10A0040319E9F20uLL);
  if (v5)
  {
    v6 = v5;
    *((double *)v5 + 1) = VCMediaStreamGroup_ExternalRenderLatency((uint64_t)a2);
    if (a2)
      v7 = CFRetain(a2);
    else
      v7 = 0;
    *v6 = v7;
    v6[2] = *(const void **)(a1 + 192);
    *(_QWORD *)(a1 + 192) = v6;
    _VCAudioStreamGroup_ComputeAndApplyAudioPlayoutDelay(a1);
    if ((int)VRTraceGetErrorLogLevelForModule() < 7)
      return 1;
    v8 = VRTraceErrorLogLevelToCSTR();
    v9 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      return 1;
    v10 = *v6;
    v11 = v6[1];
    v18 = 136316418;
    v19 = v8;
    v20 = 2080;
    v21 = "_VCAudioStreamGroup_AddSyncDestination";
    v22 = 1024;
    v23 = 742;
    v24 = 2048;
    v25 = v10;
    v26 = 2048;
    v27 = a1;
    v28 = 2048;
    v29 = v11;
    v12 = " [%s] %s:%d Added syncDestination[%p] from list, on streamGroup[%p]. externalRenderLatency=%f";
    v13 = v9;
    v14 = 58;
LABEL_11:
    _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, v12, (uint8_t *)&v18, v14);
    return 1;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() < 3)
    return 0;
  VRTraceErrorLogLevelToCSTR();
  result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
  if (result)
  {
    _VCAudioStreamGroup_AddSyncDestination_cold_1();
    return 0;
  }
  return result;
}

uint64_t _VCAudioStreamGroup_RemoveSyncDestination(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  uint64_t *v3;
  uint64_t *v5;
  uint64_t *v7;
  uint64_t v8;
  NSObject *v9;
  CFTypeRef v10;
  int v11;
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  CFTypeRef v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v2 = (_QWORD *)(a1 + 192);
  v3 = *(uint64_t **)(a1 + 192);
  if (!v3)
    return 0;
  v5 = *(uint64_t **)(a1 + 192);
  while (*v5 != a2)
  {
    v5 = (uint64_t *)v5[2];
    if (!v5)
      return 0;
  }
  if (v3 != v5)
  {
    do
    {
      v7 = v3;
      v3 = (uint64_t *)v3[2];
    }
    while (v3 != v5);
    v2 = v7 + 2;
    v3 = v5;
  }
  *v2 = v3[2];
  _VCAudioStreamGroup_ComputeAndApplyAudioPlayoutDelay(a1);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v8 = VRTraceErrorLogLevelToCSTR();
    v9 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v10 = (CFTypeRef)*v5;
      v11 = 136316162;
      v12 = v8;
      v13 = 2080;
      v14 = "_VCAudioStreamGroup_RemoveSyncDestination";
      v15 = 1024;
      v16 = 756;
      v17 = 2048;
      v18 = v10;
      v19 = 2048;
      v20 = a1;
      _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Removed syncDestination[%p] from list, on streamGroup[%p]", (uint8_t *)&v11, 0x30u);
    }
  }
  if (*v5)
  {
    CFRelease((CFTypeRef)*v5);
    *v5 = 0;
  }
  free(v5);
  return 1;
}

uint64_t VCAudioStreamGroup_OverlayToken(uint64_t a1)
{
  uint64_t v1;
  unsigned int v3;
  uint64_t v4;
  id v5;
  int v6;

  v1 = *(_QWORD *)(a1 + 192);
  if (v1)
  {
    v3 = 0;
    while (1)
    {
      v4 = *(_QWORD *)(v1 + 16);
      v5 = *(id *)v1;
      v6 = *(_DWORD *)(a1 + 312);
      if (v6 == 1835623282)
      {
        if (objc_msgSend(*(id *)v1, "streamGroupID") == 1667329381)
          return objc_msgSend(*(id *)v1, "streamToken");
        v6 = *(_DWORD *)(a1 + 312);
      }
      if (v6 == 1835623287)
      {
        if (objc_msgSend(v5, "streamGroupID") == 1667329399)
          return objc_msgSend(*(id *)v1, "streamToken");
        v6 = *(_DWORD *)(a1 + 312);
      }
      if (v6 == 1937339233 && objc_msgSend(v5, "streamGroupID") == 1935897189)
        break;
      if (!v3)
        v3 = objc_msgSend(*(id *)v1, "streamToken");
      v1 = v4;
      if (!v4)
        return v3;
    }
    return objc_msgSend(*(id *)v1, "streamToken");
  }
  else
  {
    return 0;
  }
}

void _VCAudioStreamGroup_ComputeAndApplyAudioPlayoutDelay(uint64_t a1)
{
  uint64_t v1;
  double v2;

  v1 = *(_QWORD *)(a1 + 192);
  if (v1)
  {
    v2 = 0.0;
    do
    {
      if (v2 < *(double *)(v1 + 8))
        v2 = *(double *)(v1 + 8);
      v1 = *(_QWORD *)(v1 + 16);
    }
    while (v1);
  }
  else
  {
    v2 = 0.0;
  }
  if (*(double *)(a1 + 384) != v2)
  {
    *(double *)(a1 + 384) = v2;
    _VCAudioStreamGroup_ApplyAudioPlayoutDelay(a1);
  }
}

void OUTLINED_FUNCTION_6_1(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x30u);
}

void DynamicStoreCallbackForWifiChanges(const __SCDynamicStore *a1, CFArrayRef theArray, void *a3)
{
  void *v3;
  CFIndex v6;
  __CFString *ValueAtIndex;
  uint64_t v8;
  NSObject *v9;
  const char *CStringPtr;
  CFPropertyListRef v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  char v20;
  const char *v21;
  const char *v22;
  const char *v23;
  const char *v24;
  const char *v25;
  void *v26;
  void *v27;
  void *v28;
  char v29;
  uint8_t buf[4];
  uint64_t v31;
  __int16 v32;
  const char *v33;
  __int16 v34;
  int v35;
  __int16 v36;
  _BYTE v37[18];
  __int16 v38;
  const char *v39;
  __int16 v40;
  const char *v41;
  __int16 v42;
  const char *v43;
  __int16 v44;
  const char *v45;
  __int16 v46;
  const char *v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v3 = a3;
    if (a3)
    {
      if (CFArrayGetCount(theArray) < 1)
        return;
      v6 = 0;
      v29 = 0;
      v28 = v3;
      while (1)
      {
        ValueAtIndex = (__CFString *)CFArrayGetValueAtIndex(theArray, v6);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v8 = VRTraceErrorLogLevelToCSTR();
          v9 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            CStringPtr = CFStringGetCStringPtr(ValueAtIndex, 0x8000100u);
            *(_DWORD *)buf = 136316162;
            v31 = v8;
            v32 = 2080;
            v33 = "DynamicStoreCallbackForWifiChanges";
            v34 = 1024;
            v35 = 98;
            v36 = 1024;
            *(_DWORD *)v37 = v6;
            *(_WORD *)&v37[4] = 2080;
            *(_QWORD *)&v37[6] = CStringPtr;
            _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d DynamicStoreCallbackForWifiChanges: key[%d]=%s", buf, 0x2Cu);
          }
        }
        v11 = SCDynamicStoreCopyValue(a1, ValueAtIndex);
        v12 = (void *)v11;
        if (!ValueAtIndex)
          break;
        v13 = (void *)MEMORY[0x1DF088A10]();
        v14 = (void *)-[__CFString componentsSeparatedByString:](ValueAtIndex, "componentsSeparatedByString:", CFSTR("/"));
        if ((unint64_t)objc_msgSend(v14, "count") >= 2
          && objc_msgSend((id)objc_msgSend(v14, "lastObject"), "isEqualToString:", CFSTR("LinkIssues")))
        {
          v15 = (void *)objc_msgSend(v14, "objectAtIndexedSubscript:", objc_msgSend(v14, "count") - 2);
          v16 = (void *)objc_msgSend(v12, "objectForKeyedSubscript:", CFSTR("TimeStamp"));
          v27 = (void *)objc_msgSend(v12, "objectForKeyedSubscript:", CFSTR("ModuleID"));
          v17 = objc_msgSend(v12, "objectForKeyedSubscript:", CFSTR("Info"));
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            v26 = (void *)v17;
            v18 = VRTraceErrorLogLevelToCSTR();
            v19 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            {
              v21 = "<nil>";
              if (v15)
                v21 = (const char *)objc_msgSend((id)objc_msgSend(v15, "description"), "UTF8String");
              v25 = v21;
              v22 = "<nil>";
              if (v16)
                v22 = (const char *)objc_msgSend((id)objc_msgSend(v16, "description"), "UTF8String");
              v23 = "<nil>";
              if (v27)
                v23 = (const char *)objc_msgSend((id)objc_msgSend(v27, "description"), "UTF8String");
              v24 = "<nil>";
              if (v26)
                v24 = (const char *)objc_msgSend((id)objc_msgSend(v26, "description"), "UTF8String");
              *(_DWORD *)buf = 136317442;
              v31 = v18;
              v32 = 2080;
              v33 = "checkForLinkIssues";
              v34 = 1024;
              v35 = 63;
              v36 = 2080;
              *(_QWORD *)v37 = v25;
              *(_WORD *)&v37[8] = 2080;
              *(_QWORD *)&v37[10] = "TimeStamp";
              v38 = 2080;
              v39 = v22;
              v40 = 2080;
              v41 = "ModuleID";
              v42 = 2080;
              v43 = v23;
              v44 = 2080;
              v45 = "Info";
              v46 = 2080;
              v47 = v24;
              _os_log_error_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_ERROR, " [%s] %s:%d Link issues with interface %s \n %s=%s \n %s=%s \n %s=%s", buf, 0x62u);
            }
          }
          v20 = 1;
          v3 = v28;
        }
        else
        {
          v20 = 0;
        }
        objc_autoreleasePoolPop(v13);
        if (v12)
          goto LABEL_16;
LABEL_17:
        if ((v20 & 1) != 0
          || !CFStringHasSuffix(ValueAtIndex, CFSTR("/IPv4")) && !CFStringHasSuffix(ValueAtIndex, CFSTR("/IPv6")))
        {
          goto LABEL_27;
        }
        if (CFStringHasPrefix(ValueAtIndex, CFSTR("State:/Network/Interface/pdp_ip")))
        {
          objc_msgSend(v3, "set_isCellUp:", v12 != 0);
LABEL_26:
          v29 = 1;
          goto LABEL_27;
        }
        if (CFStringHasPrefix(ValueAtIndex, CFSTR("State:/Network/Interface/")))
        {
          objc_msgSend(v3, "set_isWifiUp:", v12 != 0);
          goto LABEL_26;
        }
LABEL_27:
        if (CFArrayGetCount(theArray) <= ++v6)
        {
          if ((v29 & 1) != 0)
            objc_msgSend((id)objc_msgSend(v3, "interfaceListenerDelegate"), "interfaceStateDidChangeWithWifiUp:cellUp:", objc_msgSend(v3, "_isWifiUp"), objc_msgSend(v3, "_isCellUp"));
          return;
        }
      }
      v20 = 0;
      if (!v11)
        goto LABEL_17;
LABEL_16:
      CFRelease(v12);
      goto LABEL_17;
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      DynamicStoreCallbackForWifiChanges_cold_1();
  }
}

BOOL VCMediaNegotiationBlobBandwidthSettingsReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  unint64_t v17;
  char v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char v23;
  BOOL v24;
  int *v25;
  char v26;
  unsigned int v27;
  uint64_t v28;
  unint64_t v29;
  char v30;
  char v31;
  unsigned int v32;
  uint64_t v33;
  unint64_t v34;
  char v35;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    while (1)
    {
      if (*(_BYTE *)(a2 + *v5))
        return *(_BYTE *)(a2 + *v5) == 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        return *(_BYTE *)(a2 + *v5) == 0;
      v17 = v10 >> 3;
      if ((v10 >> 3) == 1)
      {
        v26 = 0;
        v27 = 0;
        v20 = 0;
        while (1)
        {
          v28 = *v3;
          v29 = *(_QWORD *)(a2 + v28);
          if (v29 == -1 || v29 >= *(_QWORD *)(a2 + *v4))
            break;
          v30 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v29);
          *(_QWORD *)(a2 + v28) = v29 + 1;
          v20 |= (unint64_t)(v30 & 0x7F) << v26;
          if ((v30 & 0x80) == 0)
          {
            v25 = &OBJC_IVAR___VCMediaNegotiationBlobBandwidthSettings__configuration;
            goto LABEL_48;
          }
          v26 += 7;
          v24 = v27++ > 8;
          if (v24)
          {
            LODWORD(v20) = 0;
            v25 = &OBJC_IVAR___VCMediaNegotiationBlobBandwidthSettings__configuration;
            goto LABEL_50;
          }
        }
        v25 = &OBJC_IVAR___VCMediaNegotiationBlobBandwidthSettings__configuration;
LABEL_47:
        *(_BYTE *)(a2 + *v5) = 1;
        goto LABEL_48;
      }
      if ((_DWORD)v17 == 3)
        break;
      if ((_DWORD)v17 == 2)
      {
        v18 = 0;
        v19 = 0;
        v20 = 0;
        while (1)
        {
          v21 = *v3;
          v22 = *(_QWORD *)(a2 + v21);
          if (v22 == -1 || v22 >= *(_QWORD *)(a2 + *v4))
          {
            v25 = &OBJC_IVAR___VCMediaNegotiationBlobBandwidthSettings__maxBandwidth;
            goto LABEL_47;
          }
          v23 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v22);
          *(_QWORD *)(a2 + v21) = v22 + 1;
          v20 |= (unint64_t)(v23 & 0x7F) << v18;
          if ((v23 & 0x80) == 0)
            break;
          v18 += 7;
          v24 = v19++ > 8;
          if (v24)
          {
            LODWORD(v20) = 0;
            v25 = &OBJC_IVAR___VCMediaNegotiationBlobBandwidthSettings__maxBandwidth;
            goto LABEL_50;
          }
        }
        v25 = &OBJC_IVAR___VCMediaNegotiationBlobBandwidthSettings__maxBandwidth;
        goto LABEL_48;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0)
        return 0;
LABEL_51:
      if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
        return *(_BYTE *)(a2 + *v5) == 0;
    }
    v31 = 0;
    v32 = 0;
    v20 = 0;
    *(_BYTE *)(a1 + 20) |= 1u;
    while (1)
    {
      v33 = *v3;
      v34 = *(_QWORD *)(a2 + v33);
      if (v34 == -1 || v34 >= *(_QWORD *)(a2 + *v4))
      {
        v25 = &OBJC_IVAR___VCMediaNegotiationBlobBandwidthSettings__configurationExtension;
        goto LABEL_47;
      }
      v35 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v34);
      *(_QWORD *)(a2 + v33) = v34 + 1;
      v20 |= (unint64_t)(v35 & 0x7F) << v31;
      if ((v35 & 0x80) == 0)
        break;
      v31 += 7;
      v24 = v32++ > 8;
      if (v24)
      {
        LODWORD(v20) = 0;
        v25 = &OBJC_IVAR___VCMediaNegotiationBlobBandwidthSettings__configurationExtension;
        goto LABEL_50;
      }
    }
    v25 = &OBJC_IVAR___VCMediaNegotiationBlobBandwidthSettings__configurationExtension;
LABEL_48:
    if (*(_BYTE *)(a2 + *v5))
      LODWORD(v20) = 0;
LABEL_50:
    *(_DWORD *)(a1 + *v25) = v20;
    goto LABEL_51;
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

BOOL VCRateControlUtil_CalculateCongestionMetrics(uint64_t a1, uint64_t a2, int a3, double a4, double a5)
{
  signed int v8;
  unsigned int v9;
  unsigned int v10;
  double *v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  double v15;
  _BOOL8 result;
  uint64_t v17;
  NSObject *v18;
  int v19;
  uint64_t v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  uint64_t v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  if (!a1 || !a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v17 = VRTraceErrorLogLevelToCSTR();
      v18 = *MEMORY[0x1E0CF2758];
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      v19 = 136316162;
      v20 = v17;
      v21 = 2080;
      v22 = "VCRateControlUtil_CalculateCongestionMetrics";
      v23 = 1024;
      v24 = 19;
      v25 = 2048;
      v26 = a1;
      v27 = 2048;
      v28 = a2;
      _os_log_error_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_ERROR, " [%s] %s:%d Invalid parameter. owrdList=%p config=%p", (uint8_t *)&v19, 0x30u);
    }
    return 0;
  }
  if (a4 >= 8.0)
    return 0;
  v8 = *(_DWORD *)(a1 + 1604);
  if (a4 > 0.0 && a5 - *(double *)(a1 + 8 * v8) < *(double *)(a2 + 288))
    return 0;
  v9 = *(_DWORD *)(a2 + 304);
  v10 = *(_DWORD *)(a1 + 1608);
  if (v10)
  {
    v8 = (v8 + 1) % v9;
    *(_DWORD *)(a1 + 1604) = v8;
  }
  v11 = (double *)(a1 + 8 * v8);
  v11[100] = a4;
  *v11 = a5;
  if (v10 < v9)
    ++v10;
  *(_DWORD *)(a1 + 1608) = v10;
  if (v8 == *(_DWORD *)(a1 + 1600) && v10 != 1)
    *(_DWORD *)(a1 + 1600) = (v8 + 1) % v9;
  v12 = *(_DWORD *)(a2 + 308);
  if (v10 < v12)
    return 0;
  _VCRateControlUtil_CalculateNOWRDDetailed(a1, v9, v12, a3, *(double *)(a2 + 272), *(double *)(a2 + 296));
  *(_QWORD *)(a1 + 1616) = v13;
  _VCRateControlUtil_CalculateNOWRDDetailed(a1, *(_DWORD *)(a2 + 304), *(_DWORD *)(a2 + 308), a3, *(double *)(a2 + 280), *(double *)(a2 + 296));
  *(_QWORD *)(a1 + 1624) = v14;
  v15 = *(double *)(a1 + 1632)
      + *(double *)(a1 + 1616)
      * (*(double *)(a1 + 8 * *(int *)(a1 + 1604))
       - *(double *)(a1
                   + 8
                   * (int)((*(_DWORD *)(a1 + 1604) + *(_DWORD *)(a2 + 304) - 1) % *(_DWORD *)(a2 + 304))))
      / *(double *)(a2 + 272);
  if (v15 < 0.0)
    v15 = 0.0;
  *(double *)(a1 + 1632) = v15;
  return 1;
}

void _VCRateControlUtil_CalculateNOWRDDetailed(uint64_t a1, unsigned int a2, int a3, int a4, double a5, double a6)
{
  int v11;
  unsigned int v12;
  signed int v13;
  int v14;
  int v15;
  uint64_t v16;
  NSObject *v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  int v27;
  int v28;
  unsigned int v29;
  unsigned int v30;
  double v31;
  double v32;
  double v33;
  double v34;
  unsigned int v35;
  int v36;
  uint64_t v37;
  __int16 v38;
  const char *v39;
  __int16 v40;
  int v41;
  __int16 v42;
  int v43;
  __int16 v44;
  signed int v45;
  __int16 v46;
  int v47;
  __int16 v48;
  int v49;
  __int16 v50;
  uint64_t v51;
  __int16 v52;
  uint64_t v53;
  __int16 v54;
  double v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v11 = *(_DWORD *)(a1 + 1604);
  v12 = *(_DWORD *)(a1 + 1600);
  v13 = (v11 - a3 + a2 + 1) % a2;
  if (v13 == v12)
  {
LABEL_8:
    if (!a4)
      goto LABEL_15;
  }
  else
  {
    v14 = 0;
    while (1)
    {
      if (*(double *)(a1 + 8 * v11) - *(double *)(a1 + 8 * v13) > a5)
      {
        v12 = v13;
        goto LABEL_8;
      }
      v15 = (unsigned __int16)++v14;
      if ((unsigned __int16)v14 > a2)
        break;
      v13 = (v13 + a2 - 1) % a2;
      if (v13 == v12)
        goto LABEL_8;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v16 = VRTraceErrorLogLevelToCSTR();
      v17 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v18 = *(_DWORD *)(a1 + 1600);
        v19 = *(int *)(a1 + 1604);
        v20 = *(_QWORD *)(a1 + 8 * v13);
        v21 = *(_QWORD *)(a1 + 8 * v19);
        v36 = 136317442;
        v37 = v16;
        v38 = 2080;
        v39 = "_VCRateControlUtil_CalculateNOWRDDetailed";
        v40 = 1024;
        v41 = 86;
        v42 = 1024;
        v43 = v15;
        v44 = 1024;
        v45 = v13;
        v46 = 1024;
        v47 = v18;
        v48 = 1024;
        v49 = v19;
        v50 = 2048;
        v51 = v20;
        v52 = 2048;
        v53 = v21;
        v54 = 2048;
        v55 = a5;
        _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d calculateNOWRDWithDuration exceeded max possible iterations iterationCount=%d first=%d frontIndex=%d rearIndex=%d time@first=%f time@rearIndex=%f  duration=%f", (uint8_t *)&v36, 0x52u);
      }
    }
    v12 = *(_DWORD *)(a1 + 1600);
    v11 = *(_DWORD *)(a1 + 1604);
    if (!a4)
      goto LABEL_15;
  }
  if (*(double *)(a1 + 8 * v11) - *(double *)(a1 + 8 * (int)v12) < a6)
  {
    *(_BYTE *)(a1 + 1640) = 1;
    return;
  }
LABEL_15:
  v22 = __OFSUB__(v11, v12);
  v23 = v11 - v12;
  if ((v23 < 0) ^ v22 | (v23 == 0))
    v24 = a2;
  else
    v24 = 0;
  v25 = v23 + v24;
  v26 = v25 + 2;
  if ((int)(v25 + 1) >= 0)
    v27 = v25 + 1;
  else
    v27 = v25 + 2;
  if (v25 <= 0x7FFFFFFD)
  {
    v28 = 0;
    v29 = (v12 + (v27 >> 1)) % a2;
    v30 = v26 >> 1;
    v31 = 0.0;
    v32 = 0.0;
    v33 = 0.0;
    v34 = 0.0;
    do
    {
      v34 = v34 + *(double *)(a1 + 800 + 8 * (v12 % a2));
      v35 = (v28 + v29) % a2;
      v33 = v33 + *(double *)(a1 + 800 + 8 * v35);
      v32 = v32 + *(double *)(a1 + 8 * (v12 % a2));
      v31 = v31 + *(double *)(a1 + 8 * v35);
      ++v28;
      ++v12;
      --v30;
    }
    while (v30);
  }
  *(_BYTE *)(a1 + 1640) = 0;
}

const void *VCMediaRecorderHistory_GetFigFormat(uint64_t a1, uint64_t a2, int a3)
{
  _OWORD *SampleFormat;
  _OWORD *v6;
  uint64_t v7;
  uint64_t v8;
  const void *v9;
  __int128 v10;
  __int128 v11;

  SampleFormat = (_OWORD *)VCAudioBufferList_GetSampleFormat(a2);
  v6 = SampleFormat;
  v7 = 224;
  if (a3)
    v7 = 176;
  v8 = a1 + v7;
  v9 = *(const void **)(a1 + v7);
  if (!v9)
    goto LABEL_6;
  if (memcmp(SampleFormat, (const void *)(v8 + 8), 0x28uLL))
  {
    CFRelease(v9);
    *(_QWORD *)v8 = 0;
LABEL_6:
    v10 = *v6;
    v11 = v6[1];
    *(_QWORD *)(v8 + 40) = *((_QWORD *)v6 + 4);
    *(_OWORD *)(v8 + 24) = v11;
    *(_OWORD *)(v8 + 8) = v10;
    CMAudioFormatDescriptionCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const AudioStreamBasicDescription *)v6, 0, 0, 0, 0, 0, (CMAudioFormatDescriptionRef *)v8);
    return *(const void **)v8;
  }
  return v9;
}

void VCMediaRecorderHistory_AddAudioSampleBuffer(uint64_t a1, uint64_t a2, int a3, int a4)
{
  char v5;
  const opaqueCMFormatDescription *FigFormat;
  CMSampleBufferRef SampleBufferWithFormat;
  NSObject *v10;
  _QWORD v11[6];
  int v12;
  char v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a2)
    {
      v5 = a4;
      FigFormat = (const opaqueCMFormatDescription *)VCMediaRecorderHistory_GetFigFormat(a1, a2, a4);
      if (FigFormat)
      {
        SampleBufferWithFormat = VCAudioBufferList_CreateSampleBufferWithFormat(a2, FigFormat, *(const __CFAllocator **)(a1 + 168));
        if (SampleBufferWithFormat)
        {
          v10 = *(NSObject **)(a1 + 8);
          v11[0] = MEMORY[0x1E0C809B0];
          v11[1] = 3221225472;
          v11[2] = __VCMediaRecorderHistory_AddAudioSampleBuffer_block_invoke;
          v11[3] = &unk_1E9E532E0;
          v13 = v5;
          v11[4] = a1;
          v11[5] = SampleBufferWithFormat;
          v12 = a3;
          dispatch_async(v10, v11);
        }
        else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCMediaRecorderHistory_AddAudioSampleBuffer_cold_4();
        }
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCMediaRecorderHistory_AddAudioSampleBuffer_cold_3();
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCMediaRecorderHistory_AddAudioSampleBuffer_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCMediaRecorderHistory_AddAudioSampleBuffer_cold_1();
  }
}

void VCMediaRecorderHistory_AddLocalVideoSampleBuffer(uint64_t a1, CMSampleBufferRef sbuf, char a3, int a4)
{
  __CVBuffer *ImageBuffer;
  uint64_t v9;
  NSObject *v10;
  int v11;
  int v12;
  OSStatus v13;
  CMTimeValue value;
  uint64_t v15;
  CMTimeEpoch epoch;
  __CVBuffer *v17;
  CVPixelBufferRef ResizeFrame;
  CMSampleBufferRef v19;
  __CVBuffer *v20;
  int Width;
  int Height;
  NSObject *v23;
  OSStatus v24;
  uint64_t v25;
  NSObject *v26;
  _QWORD v27[10];
  int v28;
  char v29;
  CMSampleBufferRef sampleBufferOut;
  CMTime buf;
  int v32;
  __int16 v33;
  _BYTE v34[10];
  OSStatus v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  if (a1 && sbuf)
  {
    if (*(_BYTE *)(a1 + 161))
    {
      ImageBuffer = CMSampleBufferGetImageBuffer(sbuf);
      *(_DWORD *)(a1 + 156) = CVPixelBufferGetWidth(ImageBuffer);
      *(_DWORD *)(a1 + 152) = CVPixelBufferGetHeight(ImageBuffer);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v9 = VRTraceErrorLogLevelToCSTR();
        v10 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v12 = *(_DWORD *)(a1 + 152);
          v11 = *(_DWORD *)(a1 + 156);
          LODWORD(buf.value) = 136316162;
          *(CMTimeValue *)((char *)&buf.value + 4) = v9;
          LOWORD(buf.flags) = 2080;
          *(_QWORD *)((char *)&buf.flags + 2) = "_VCMediaRecorderHistory_UpdateCaptureSizesWithFirstFrame";
          HIWORD(buf.epoch) = 1024;
          v32 = 1225;
          v33 = 1024;
          *(_DWORD *)v34 = v11;
          *(_WORD *)&v34[4] = 1024;
          *(_DWORD *)&v34[6] = v12;
          _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d captureWidth=%d, captureHeight=%d", (uint8_t *)&buf, 0x28u);
        }
      }
      VCMediaRecorderHistory_UpdateResizeFlag(a1);
    }
    sampleBufferOut = 0;
    if (*(_BYTE *)(a1 + 280))
    {
      v13 = CMSampleBufferCreateCopy(*(CFAllocatorRef *)(a1 + 272), sbuf, &sampleBufferOut);
      if (!v13)
      {
        value = *MEMORY[0x1E0CA2E18];
        v15 = *(_QWORD *)(MEMORY[0x1E0CA2E18] + 8);
        epoch = *(_QWORD *)(MEMORY[0x1E0CA2E18] + 16);
        v17 = CMSampleBufferGetImageBuffer(sampleBufferOut);
        _VCMediaRecorderHistory_SetVisibleRect(a1, v17);
        _VCMediaRecorderHistory_EmitSetVisibleRectSignpost(sampleBufferOut);
        ResizeFrame = 0;
        v19 = sampleBufferOut;
LABEL_15:
        v23 = *(NSObject **)(a1 + 8);
        v27[0] = MEMORY[0x1E0C809B0];
        v27[1] = 3221225472;
        v27[2] = __VCMediaRecorderHistory_AddLocalVideoSampleBuffer_block_invoke;
        v27[3] = &unk_1E9E53308;
        v27[4] = a1;
        v27[5] = ResizeFrame;
        v27[8] = v15;
        v27[9] = epoch;
        v27[6] = v19;
        v27[7] = value;
        v29 = a3;
        v28 = a4;
        dispatch_async(v23, v27);
        return;
      }
      v24 = v13;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v25 = VRTraceErrorLogLevelToCSTR();
        v26 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          LODWORD(buf.value) = 136316162;
          *(CMTimeValue *)((char *)&buf.value + 4) = v25;
          LOWORD(buf.flags) = 2080;
          *(_QWORD *)((char *)&buf.flags + 2) = "VCMediaRecorderHistory_AddLocalVideoSampleBuffer";
          HIWORD(buf.epoch) = 1024;
          v32 = 275;
          v33 = 2048;
          *(_QWORD *)v34 = sbuf;
          *(_WORD *)&v34[8] = 1024;
          v35 = v24;
          _os_log_error_impl(&dword_1D8A54000, v26, OS_LOG_TYPE_ERROR, " [%s] %s:%d Failed to CMSampleBufferCreateCopy for sampleBuffer=%p status=%d", (uint8_t *)&buf, 0x2Cu);
        }
      }
      FigSampleBufferRelease();
    }
    else
    {
      v20 = CMSampleBufferGetImageBuffer(sbuf);
      Width = CVPixelBufferGetWidth(v20);
      Height = CVPixelBufferGetHeight(v20);
      if ((VCMediaRecorderUtil_PixelBufferPoolMatchDimensions(*(__CVPixelBufferPool **)(a1 + 128), Width, Height) & 1) == 0)
      {
        CVPixelBufferPoolRelease(*(CVPixelBufferPoolRef *)(a1 + 128));
        VCMediaRecorderUtil_SetupBufferPool(CFSTR("AVConference:MediaRecorderCopy"), (CVPixelBufferPoolRef *)(a1 + 128), (double)Width, (double)Height);
      }
      ResizeFrame = VCMediaRecorderUtil_CreateResizeFrame(v20, *(OpaqueVTPixelTransferSession **)(a1 + 144), *(CVPixelBufferPoolRef *)(a1 + 128));
      CMSampleBufferGetPresentationTimeStamp(&buf, sbuf);
      if (ResizeFrame)
      {
        v19 = 0;
        value = buf.value;
        epoch = buf.epoch;
        v15 = *(_QWORD *)&buf.timescale;
        goto LABEL_15;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCMediaRecorderHistory_AddLocalVideoSampleBuffer_cold_1();
      }
    }
  }
}

void _VCMediaRecorderHistory_SetVisibleRect(uint64_t a1, __CVBuffer *a2)
{
  os_unfair_lock_s *v4;
  double v5;
  int v6;
  double v7;
  int v8;
  BOOL v9;

  v4 = (os_unfair_lock_s *)(a1 + 284);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 284));
  objc_msgSend(*(id *)(a1 + 96), "ratio");
  v6 = (int)v5;
  objc_msgSend(*(id *)(a1 + 96), "ratio");
  v8 = (int)v7;
  os_unfair_lock_unlock(v4);
  if (v6)
    v9 = v8 == 0;
  else
    v9 = 1;
  if (!v9)
    VideoUtil_SetVisibleRectAttachment(a2, 2, v6, v8);
}

void _VCMediaRecorderHistory_EmitSetVisibleRectSignpost(opaqueCMSampleBuffer *a1)
{
  os_signpost_id_t value;
  NSObject *v2;
  CMTime v3;
  uint8_t buf[8];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  memset(&v3, 170, sizeof(v3));
  CMSampleBufferGetPresentationTimeStamp(&v3, a1);
  if (*MEMORY[0x1E0CF2760])
  {
    value = v3.value;
    if ((unint64_t)(v3.value - 1) <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v2 = *MEMORY[0x1E0CF2758];
      if (os_signpost_enabled((os_log_t)*MEMORY[0x1E0CF2758]))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl(&dword_1D8A54000, v2, OS_SIGNPOST_EVENT, value, "VCMediaRecorderHistory_SetVisibleRect", (const char *)&unk_1D91A2482, buf, 2u);
      }
    }
  }
}

void VCMediaRecorderHistory_PrepareVideoSampleBuffer(uint64_t a1, CMSampleBufferRef sbuf)
{
  __CVBuffer *ImageBuffer;
  uint64_t v5;
  NSObject *v6;
  int v7;
  uint64_t v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  uint64_t v14;
  __int16 v15;
  CMSampleBufferRef v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (a1 && sbuf)
  {
    if (*(_BYTE *)(a1 + 280))
    {
      ImageBuffer = CMSampleBufferGetImageBuffer(sbuf);
      _VCMediaRecorderHistory_SetVisibleRect(a1, ImageBuffer);
      _VCMediaRecorderHistory_EmitSetVisibleRectSignpost(sbuf);
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v5 = VRTraceErrorLogLevelToCSTR();
    v6 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      v7 = 136316162;
      v8 = v5;
      v9 = 2080;
      v10 = "VCMediaRecorderHistory_PrepareVideoSampleBuffer";
      v11 = 1024;
      v12 = 297;
      v13 = 2048;
      v14 = a1;
      v15 = 2048;
      v16 = sbuf;
      _os_log_error_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_ERROR, " [%s] %s:%d Invalid parameter(s): history=%p, sampleBuffer=%p", (uint8_t *)&v7, 0x30u);
    }
  }
}

void VCMediaRecorderHistory_UpdateTargetScreenAttributes(uint64_t a1, void *a2)
{
  os_unfair_lock_s *v4;
  const void *v5;
  CFTypeRef v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  uint64_t v19;
  __int16 v20;
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v4 = (os_unfair_lock_s *)(a1 + 284);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 284));
    v5 = *(const void **)(a1 + 96);
    if (v5)
      CFRelease(v5);
    if (a2)
      v6 = CFRetain(a2);
    else
      v6 = 0;
    *(_QWORD *)(a1 + 96) = v6;
    os_unfair_lock_unlock(v4);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      v7 = VRTraceErrorLogLevelToCSTR();
      v8 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        objc_msgSend(a2, "ratio");
        v10 = v9;
        objc_msgSend(a2, "ratio");
        v12 = 136316162;
        v13 = v7;
        v14 = 2080;
        v15 = "VCMediaRecorderHistory_UpdateTargetScreenAttributes";
        v16 = 1024;
        v17 = 318;
        v18 = 2048;
        v19 = v10;
        v20 = 2048;
        v21 = v11;
        _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d targetScreenAttributes ratio=%fx%f", (uint8_t *)&v12, 0x30u);
      }
    }
    VCMediaRecorderHistory_UpdateResizeFlag(a1);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCMediaRecorderHistory_UpdateTargetScreenAttributes_cold_1();
  }
}

void VCMediaRecorderHistory_UpdateResizeFlag(uint64_t a1)
{
  os_unfair_lock_s *v2;
  double v3;
  double v4;
  double v5;
  float v6;
  int v7;
  int v8;
  float v9;
  float v10;
  uint64_t v11;
  NSObject *v12;
  int v13;
  int v14;
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v2 = (os_unfair_lock_s *)(a1 + 284);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 284));
  objc_msgSend(*(id *)(a1 + 96), "ratio");
  v4 = v3;
  objc_msgSend(*(id *)(a1 + 96), "ratio");
  v6 = v5;
  os_unfair_lock_unlock(v2);
  if (v6 == 0.0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCMediaRecorderHistory_UpdateResizeFlag_cold_1();
    }
  }
  else
  {
    v7 = *(_DWORD *)(a1 + 156);
    if (v7)
    {
      v8 = *(_DWORD *)(a1 + 152);
      if (v8)
      {
        v9 = v4;
        v10 = v9 / v6;
        *(_BYTE *)(a1 + 160) = vabds_f32(v10, (float)v7 / (float)v8) >= 0.0001
                            && vabds_f32(v10, (float)v8 / (float)v7) >= 0.0001;
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCMediaRecorderHistory_UpdateResizeFlag_cold_3();
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCMediaRecorderHistory_UpdateResizeFlag_cold_2();
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
  {
    v11 = VRTraceErrorLogLevelToCSTR();
    v12 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v13 = *(unsigned __int8 *)(a1 + 160);
      v14 = 136315906;
      v15 = v11;
      v16 = 2080;
      v17 = "VCMediaRecorderHistory_UpdateResizeFlag";
      v18 = 1024;
      v19 = 349;
      v20 = 1024;
      v21 = v13;
      _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Should resize frames for media recording:%d", (uint8_t *)&v14, 0x22u);
    }
  }
}

void VCMediaRecorderHistory_ClearHistoryBuffer(uint64_t a1)
{
  NSObject *v1;
  uint64_t v2;
  NSObject *v3;
  _QWORD block[5];
  uint8_t buf[4];
  uint64_t v6;
  __int16 v7;
  const char *v8;
  __int16 v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v1 = *(NSObject **)(a1 + 8);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = __VCMediaRecorderHistory_ClearHistoryBuffer_block_invoke;
    block[3] = &unk_1E9E521C0;
    block[4] = a1;
    dispatch_async(v1, block);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      v6 = v2;
      v7 = 2080;
      v8 = "VCMediaRecorderHistory_ClearHistoryBuffer";
      v9 = 1024;
      v10 = 691;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", buf, 0x1Cu);
    }
  }
}

void VCMediaRecorderHistory_StopProcessingAllRequests(uint64_t a1)
{
  NSObject *v1;
  _QWORD v2[6];

  v2[5] = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v1 = *(NSObject **)(a1 + 8);
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 3221225472;
    v2[2] = __VCMediaRecorderHistory_StopProcessingAllRequests_block_invoke;
    v2[3] = &unk_1E9E521C0;
    v2[4] = a1;
    dispatch_async(v1, v2);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCMediaRecorderHistory_StopProcessingAllRequests_cold_1();
  }
}

CFStringRef OUTLINED_FUNCTION_13@<X0>(unsigned __int8 a1@<W1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  *(_QWORD *)(v2 - 24) = a2;
  return VCMediaRecorderUtil_DescriptionForMediaType(a1);
}

void VCEmulatedNetworkAlgorithm_UpdateIndexWithIntervalArray(void *a1, int *a2, double *a3, int a4, double a5)
{
  int v10;
  uint64_t v11;
  NSObject *v12;
  double v13;
  double v14;

  if (a1 && a2 && a3 && (v10 = *a2, v10 < (int)objc_msgSend(a1, "count")))
  {
    if (*a3 == 0.0)
    {
      *a2 = 0;
    }
    else
    {
      v13 = a5 - *a3;
      objc_msgSend((id)objc_msgSend(a1, "objectAtIndexedSubscript:", *a2), "doubleValue");
      if (v13 <= v14)
        return;
      *a2 = (*a2 + 1) % a4;
    }
    *a3 = a5;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v11 = VRTraceErrorLogLevelToCSTR();
    v12 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCEmulatedNetworkAlgorithm_UpdateIndexWithIntervalArray_cold_1(v11, v12);
  }
}

BOOL VCMediaNegotiationBlobMomentsSettingsReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  char v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char v22;
  BOOL v23;
  int *v24;
  char v25;
  unsigned int v26;
  uint64_t v27;
  unint64_t v28;
  char v29;
  char v30;
  unsigned int v31;
  uint64_t v32;
  unint64_t v33;
  char v34;
  char v35;
  unsigned int v36;
  uint64_t v37;
  unint64_t v38;
  char v39;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      switch((v10 >> 3))
      {
        case 1u:
          v17 = 0;
          v18 = 0;
          v19 = 0;
          while (1)
          {
            v20 = *v3;
            v21 = *(_QWORD *)(a2 + v20);
            if (v21 == -1 || v21 >= *(_QWORD *)(a2 + *v4))
            {
              v24 = &OBJC_IVAR___VCMediaNegotiationBlobMomentsSettings__capabilities;
              goto LABEL_53;
            }
            v22 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v21);
            *(_QWORD *)(a2 + v20) = v21 + 1;
            v19 |= (unint64_t)(v22 & 0x7F) << v17;
            if ((v22 & 0x80) == 0)
              break;
            v17 += 7;
            v23 = v18++ > 8;
            if (v23)
            {
              LODWORD(v19) = 0;
              v24 = &OBJC_IVAR___VCMediaNegotiationBlobMomentsSettings__capabilities;
              goto LABEL_56;
            }
          }
          v24 = &OBJC_IVAR___VCMediaNegotiationBlobMomentsSettings__capabilities;
          goto LABEL_54;
        case 2u:
          v25 = 0;
          v26 = 0;
          v19 = 0;
          *(_BYTE *)(a1 + 24) |= 4u;
          while (2)
          {
            v27 = *v3;
            v28 = *(_QWORD *)(a2 + v27);
            if (v28 == -1 || v28 >= *(_QWORD *)(a2 + *v4))
            {
              v24 = &OBJC_IVAR___VCMediaNegotiationBlobMomentsSettings__supportedVideoCodecs;
              goto LABEL_53;
            }
            v29 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v28);
            *(_QWORD *)(a2 + v27) = v28 + 1;
            v19 |= (unint64_t)(v29 & 0x7F) << v25;
            if (v29 < 0)
            {
              v25 += 7;
              v23 = v26++ > 8;
              if (v23)
              {
                LODWORD(v19) = 0;
                v24 = &OBJC_IVAR___VCMediaNegotiationBlobMomentsSettings__supportedVideoCodecs;
                goto LABEL_56;
              }
              continue;
            }
            break;
          }
          v24 = &OBJC_IVAR___VCMediaNegotiationBlobMomentsSettings__supportedVideoCodecs;
          goto LABEL_54;
        case 3u:
          v30 = 0;
          v31 = 0;
          v19 = 0;
          *(_BYTE *)(a1 + 24) |= 2u;
          while (2)
          {
            v32 = *v3;
            v33 = *(_QWORD *)(a2 + v32);
            if (v33 == -1 || v33 >= *(_QWORD *)(a2 + *v4))
            {
              v24 = &OBJC_IVAR___VCMediaNegotiationBlobMomentsSettings__supportedImageTypes;
              goto LABEL_53;
            }
            v34 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v33);
            *(_QWORD *)(a2 + v32) = v33 + 1;
            v19 |= (unint64_t)(v34 & 0x7F) << v30;
            if (v34 < 0)
            {
              v30 += 7;
              v23 = v31++ > 8;
              if (v23)
              {
                LODWORD(v19) = 0;
                v24 = &OBJC_IVAR___VCMediaNegotiationBlobMomentsSettings__supportedImageTypes;
                goto LABEL_56;
              }
              continue;
            }
            break;
          }
          v24 = &OBJC_IVAR___VCMediaNegotiationBlobMomentsSettings__supportedImageTypes;
          goto LABEL_54;
        case 4u:
          v35 = 0;
          v36 = 0;
          v19 = 0;
          *(_BYTE *)(a1 + 24) |= 1u;
          break;
        default:
          if ((PBReaderSkipValueWithTag() & 1) != 0)
            continue;
          return 0;
      }
      while (1)
      {
        v37 = *v3;
        v38 = *(_QWORD *)(a2 + v37);
        if (v38 == -1 || v38 >= *(_QWORD *)(a2 + *v4))
          break;
        v39 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v38);
        *(_QWORD *)(a2 + v37) = v38 + 1;
        v19 |= (unint64_t)(v39 & 0x7F) << v35;
        if ((v39 & 0x80) == 0)
        {
          v24 = &OBJC_IVAR___VCMediaNegotiationBlobMomentsSettings__multiwayCapabilities;
          goto LABEL_54;
        }
        v35 += 7;
        v23 = v36++ > 8;
        if (v23)
        {
          LODWORD(v19) = 0;
          v24 = &OBJC_IVAR___VCMediaNegotiationBlobMomentsSettings__multiwayCapabilities;
          goto LABEL_56;
        }
      }
      v24 = &OBJC_IVAR___VCMediaNegotiationBlobMomentsSettings__multiwayCapabilities;
LABEL_53:
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_54:
      if (*(_BYTE *)(a2 + *v5))
        LODWORD(v19) = 0;
LABEL_56:
      *(_DWORD *)(a1 + *v24) = v19;
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

uint64_t _VCOverlaySourceClassRegister(uint64_t *a1)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

uint64_t VCOverlaySource_Create(uint64_t a1, uint64_t *a2)
{
  uint64_t Instance;
  uint64_t v4;
  void *v5;
  void *v6;
  void *v7;
  uint64_t v8;

  if (a2)
  {
    if (VCOverlaySource_GetTypeID_initOnce != -1)
      dispatch_once_f(&VCOverlaySource_GetTypeID_initOnce, &VCOverlaySource_GetTypeID_typeID, (dispatch_function_t)_VCOverlaySourceClassRegister);
    Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      v4 = Instance;
      v5 = malloc_type_calloc(1uLL, 0xC8uLL, 0x10620403D7EC478uLL);
      if (v5)
      {
        *(_QWORD *)(v4 + 48) = v5;
        v6 = malloc_type_calloc(1uLL, 0xC8uLL, 0x10620403D7EC478uLL);
        if (v6)
        {
          *(_QWORD *)(v4 + 40) = v6;
          v7 = malloc_type_calloc(1uLL, 0xC8uLL, 0x10620403D7EC478uLL);
          if (v7)
          {
            v8 = 0;
            *(_QWORD *)(v4 + 56) = v7;
            *(_QWORD *)(v4 + 32) = 0;
            *a2 = v4;
            return v8;
          }
          free(*(void **)(v4 + 48));
          free(*(void **)(v4 + 40));
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VCOverlaySource_Create_cold_5();
          }
        }
        else
        {
          free(*(void **)(v4 + 48));
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VCOverlaySource_Create_cold_4();
          }
        }
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCOverlaySource_Create_cold_3();
      }
      CFRelease((CFTypeRef)v4);
      return 2;
    }
    v8 = 3;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCOverlaySource_Create_cold_2();
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCOverlaySource_Create_cold_1();
    }
    return 1;
  }
  return v8;
}

uint64_t VCOverlaySource_Write(uint64_t result)
{
  int v1;
  int *v2;
  unint64_t *v3;
  unint64_t v4;
  unint64_t v5;

  v1 = *(_DWORD *)(result + 32) + 1;
  *(_DWORD *)(result + 32) = v1;
  v2 = *(int **)(result + 40);
  *v2 = v1;
  v3 = (unint64_t *)(result + 56);
LABEL_2:
  v4 = *v3;
  do
  {
    v5 = __ldxr(v3);
    if (v5 != v4)
    {
      __clrex();
      goto LABEL_2;
    }
  }
  while (__stxr((unint64_t)v2, v3));
  *(_QWORD *)(result + 40) = v4;
  return result;
}

uint64_t VCOverlaySource_Read(uint64_t result)
{
  unsigned int v1;
  BOOL v2;
  unint64_t *v3;
  unint64_t v4;
  _DWORD *v5;
  unint64_t v6;

  v1 = *(_DWORD *)(result + 32) - *(_DWORD *)(result + 36);
  if (v1)
    v2 = v1 > 0x7FFFFFFE;
  else
    v2 = 1;
  if (!v2)
  {
    v3 = (unint64_t *)(result + 56);
    v4 = *(_QWORD *)(result + 48);
LABEL_6:
    v5 = (_DWORD *)*v3;
    do
    {
      v6 = __ldxr(v3);
      if ((_DWORD *)v6 != v5)
      {
        __clrex();
        goto LABEL_6;
      }
    }
    while (__stxr(v4, v3));
    *(_QWORD *)(result + 48) = v5;
    *(_DWORD *)(result + 36) = *v5;
  }
  return result;
}

double _VCOverlaySource_Init(_OWORD *a1)
{
  double result;

  result = 0.0;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[1] = 0u;
  return result;
}

void _VCOverlaySource_Finalize(void **a1)
{
  free(a1[5]);
  free(a1[6]);
  free(a1[7]);
}

void _VCRateControlAlgorithmSparseNOWRD_Configure(uint64_t a1, const void *a2, int a3)
{
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  int v15;
  uint64_t v16;
  int v17;
  int v18;
  uint8_t buf[4];
  uint64_t v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  memcpy((void *)(a1 + 40), a2, 0x3D0uLL);
  *(_BYTE *)(a1 + 1121) = 0;
  *(_BYTE *)(a1 + 5104) = 0;
  *(_QWORD *)(a1 + 4960) = 0;
  *(_QWORD *)(a1 + 5008) = *(_QWORD *)(a1 + 728);
  VCRateControlAlgorithmBasePriv_ResetLossEventBuffer(a1);
  *(_DWORD *)(a1 + 6276) = 0;
  *(_DWORD *)(a1 + 6280) = 0;
  *(_DWORD *)(a1 + 6284) = 0;
  *(_QWORD *)(a1 + 6296) = *(_QWORD *)(a1 + 1096);
  if (a3)
  {
    *(_DWORD *)(a1 + 1040) = 1;
    *(_DWORD *)(a1 + 1052) = *(_DWORD *)(a1 + 56);
  }
  *(_BYTE *)(a1 + 6404) = *(_BYTE *)(a1 + 411);
  v5 = *(_DWORD *)(a1 + 1052);
  if (v5 >= *(_DWORD *)(a1 + 60))
    v5 = *(_DWORD *)(a1 + 60);
  if (v5 <= *(_DWORD *)(a1 + 64))
    v5 = *(_DWORD *)(a1 + 64);
  *(_DWORD *)(a1 + 1052) = v5;
  v6 = *(_QWORD *)(a1 + 48);
  if (v6)
  {
    *(_DWORD *)(a1 + 1072) = *(_DWORD *)(v6 + 4 * *(int *)(a1 + 1052));
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v13 = VRTraceErrorLogLevelToCSTR();
      v14 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v15 = *(_DWORD *)(a1 + 1072);
        v16 = *(_QWORD *)(a1 + 48);
        v17 = *(_DWORD *)(v16 + 4 * *(int *)(a1 + 64));
        LODWORD(v16) = *(_DWORD *)(v16 + 4 * *(int *)(a1 + 60));
        v18 = *(unsigned __int8 *)(a1 + 419);
        *(_DWORD *)buf = 136316674;
        v20 = v13;
        v21 = 2080;
        v22 = "_VCRateControlAlgorithmSparseNOWRD_Configure";
        v23 = 1024;
        v24 = 163;
        v25 = 1024;
        v26 = v15;
        v27 = 1024;
        v28 = v17;
        v29 = 1024;
        v30 = v16;
        v31 = 1024;
        v32 = v18;
        _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Configuring VCRateControl algorithm with targetBitrate=%d, minBitrate=%d, maxBitrate=%d, burstyTraffic=%d", buf, 0x34u);
      }
    }
    VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Configure with targetBitrate=%d, minBitrate=%d, maxBitrate=%d, burstyTraffic=%d", v7, v8, v9, v10, v11, v12, *(_DWORD *)(a1 + 1072));
  }
  *(_BYTE *)(a1 + 1120) = 1;
  VCRateControlAlgorithmBasePriv_ResetOWRDList(a1);
}

BOOL _VCRateControlAlgorithmSparseNOWRD_DoRateControl(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  unsigned int v11;
  double v12;
  double v13;
  unsigned int v14;
  double v15;
  unint64_t v16;
  char v17;
  int v18;
  _BOOL8 result;
  uint64_t v20;
  NSObject *v21;
  _BOOL4 v22;
  int v23;
  uint64_t v24;
  NSObject *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  double v35;
  int v36;
  uint64_t v37;
  int v38;
  int v39;
  unsigned int v40;
  int v41;
  int v42;
  int v43;
  unsigned int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  double v51;
  uint64_t v52;
  uint64_t v53;
  unsigned int v54;
  uint64_t v55;
  int v56;
  int v57;
  unsigned int v58;
  int v59;
  NSObject *v60;
  uint64_t v61;
  int v62;
  int v63;
  int v64;
  double v65;
  double v66;
  int v67;
  unsigned int v68;
  unsigned int v69;
  unsigned int v70;
  int v71;
  int v72;
  int v73;
  int v74;
  double v75;
  unsigned int v76;
  unsigned __int8 v77;
  const char *v78;
  int v79;
  uint64_t v80;
  char v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint8_t buf[4];
  uint64_t v88;
  __int16 v89;
  const char *v90;
  __int16 v91;
  int v92;
  __int16 v93;
  _BYTE v94[10];
  int v95;
  __int16 v96;
  uint64_t v97;
  __int16 v98;
  uint64_t v99;
  __int16 v100;
  uint64_t v101;
  __int16 v102;
  uint64_t v103;
  __int16 v104;
  int v105;
  __int16 v106;
  int v107;
  __int16 v108;
  double v109;
  __int16 v110;
  double v111;
  __int16 v112;
  unsigned int v113;
  __int16 v114;
  int v115;
  __int16 v116;
  unsigned int v117;
  __int16 v118;
  unsigned int v119;
  __int16 v120;
  int v121;
  __int16 v122;
  int v123;
  __int16 v124;
  int v125;
  __int16 v126;
  unsigned int v127;
  __int16 v128;
  int v129;
  __int16 v130;
  unsigned int v131;
  __int16 v132;
  const char *v133;
  __int16 v134;
  int v135;
  uint64_t v136;
  uint64_t v137;

  v136 = *MEMORY[0x1E0C80C00];
  v10 = *(_DWORD *)a2;
  if (*(_DWORD *)a2 == 1)
  {
    *(_QWORD *)(a1 + 6328) = *(_QWORD *)(a2 + 8);
    *(_DWORD *)(a1 + 6336) = *(_DWORD *)(a2 + 36);
    *(_DWORD *)(a1 + 6340) = *(_DWORD *)(a2 + 28) + *(_DWORD *)(a2 + 24);
    *(_QWORD *)(a1 + 6344) = *(_QWORD *)(a2 + 64);
    *(_QWORD *)(a1 + 6352) = *(_QWORD *)(a2 + 80);
    *(_QWORD *)(a1 + 6360) = *(_QWORD *)(a2 + 88);
    if (*(_BYTE *)(a1 + 6404) && *(_DWORD *)(a2 + 160) == 8)
      VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Disable baseband adaptation due to FR2 RATType", a3, a4, a5, a6, a7, a8, v81);
    v17 = *(_BYTE *)(a1 + 411);
    if (v17)
      v17 = *(_DWORD *)(a2 + 160) != 8;
    *(_BYTE *)(a1 + 6404) = v17;
    VCRateControlAlgorithmBasePriv_CheckPaused(a1);
    if (*(_BYTE *)(a1 + 6404))
    {
      if (*(double *)(a1 + 6352) <= *(double *)(a1 + 544) && *(double *)(a1 + 6360) <= *(double *)(a1 + 560)
        || *(double *)(a1 + 6344) <= *(double *)(a1 + 568))
      {
        v18 = 0;
      }
      else
      {
        *(_DWORD *)(a1 + 1048) |= 0x40u;
        *(_QWORD *)(a1 + 2880) = 0;
        v18 = 1;
      }
      if (*(double *)(a1 + 6344) > *(double *)(a1 + 576))
      {
        *(_DWORD *)(a1 + 1048) |= 0x80u;
        *(_QWORD *)(a1 + 2880) = 0;
        if (*(double *)(a1 + 6352) > *(double *)(a1 + 544))
          *(_QWORD *)(a1 + 6384) = *(_QWORD *)(a1 + 6328);
LABEL_52:
        if (*(_DWORD *)(a1 + 1040) && *(double *)(a1 + 1096) > 0.0)
        {
          *(_BYTE *)(a1 + 6368) = 1;
          VCRateControlAlgorithmBasePriv_UpdateCongestionStatusWhenRampDown(a1, *(double *)(a1 + 1096));
          v32 = 0;
          v33 = *(_DWORD *)(a1 + 1052);
          while (*(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * v33 + 4 * v32) > *(_DWORD *)(a1 + 6336))
          {
            v34 = *(int *)(a1 + 64);
            --v32;
            if (v33 + v32 <= v34)
              goto LABEL_63;
          }
          LODWORD(v34) = v33 + v32;
LABEL_63:
          if ((int)v34 < *(_DWORD *)(a1 + 76))
          {
            v35 = *(double *)(a1 + 1096);
            if (v35 - *(double *)(a1 + 6392) <= *(double *)(a1 + 584))
            {
              LODWORD(v34) = *(_DWORD *)(a1 + 1052);
            }
            else
            {
              LODWORD(v34) = v33 - 1;
              *(double *)(a1 + 6392) = v35;
              v33 = *(_DWORD *)(a1 + 1052);
            }
          }
          if ((int)v34 <= *(_DWORD *)(a1 + 64))
            v39 = *(_DWORD *)(a1 + 64);
          else
            v39 = v34;
          if (v33 > v39)
          {
            VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "[%u] Congestion due to baseband!!! New bitrate down to %u", v26, v27, v28, v29, v30, v31, *(_DWORD *)(a1 + 1084));
            v33 = *(_DWORD *)(a1 + 1052);
          }
          *(_DWORD *)(a1 + 1056) = v33;
          *(_DWORD *)(a1 + 1052) = v39;
          VCRateControlAlgorithmBasePriv_StateChange(a1, 3);
        }
        goto LABEL_86;
      }
      if (*(double *)(a1 + 6352) <= *(double *)(a1 + 544))
      {
        if (v18)
          goto LABEL_52;
      }
      else
      {
        *(_QWORD *)(a1 + 6384) = *(_QWORD *)(a1 + 6328);
        if ((v18 & 1) != 0)
          goto LABEL_52;
      }
    }
    if (*(double *)(a1 + 6352) <= *(double *)(a1 + 600)
      && *(double *)(a1 + 6344) <= *(double *)(a1 + 608)
      && *(double *)(a1 + 6328) - *(double *)(a1 + 6384) >= *(double *)(a1 + 616))
    {
      *(_DWORD *)(a1 + 6400) = *(_DWORD *)(a1 + 92);
    }
LABEL_86:
    *(_DWORD *)(a1 + 1072) = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * *(int *)(a1 + 1052));
    if (*(_BYTE *)(a1 + 6404))
      VCRateControlMediaController_UpdateBasebandSuggestion(*(_QWORD *)(a1 + 1016), a2);
    return 1;
  }
  if (v10 != 11)
  {
    if (v10 == 5)
    {
      v11 = *(unsigned __int16 *)(a2 + 28);
      *(_QWORD *)(a1 + 2856) = *(_QWORD *)(a2 + 72);
      *(_DWORD *)(a1 + 5100) = *(_DWORD *)(a2 + 40);
      *(_DWORD *)(a1 + 6312) = *(_DWORD *)(a2 + 36);
      *(_QWORD *)(a1 + 5072) = *(_QWORD *)(a2 + 64);
      *(_QWORD *)(a1 + 4992) = *(_QWORD *)(a2 + 80);
      *(_QWORD *)(a1 + 5048) = *(_QWORD *)(a2 + 80);
      *(_QWORD *)(a1 + 5056) = *(_QWORD *)(a2 + 88);
      *(_DWORD *)(a1 + 5240) = *(_DWORD *)(a2 + 96);
      *(_DWORD *)(a1 + 5244) = *(_DWORD *)(a2 + 100);
      *(_DWORD *)(a1 + 1168) = *(_DWORD *)(a2 + 60);
      *(_DWORD *)(a1 + 1172) = *(_DWORD *)(a1 + 1168);
      *(_DWORD *)(a1 + 5248) = *(_DWORD *)(a2 + 108);
      *(_DWORD *)(a1 + 1080) = *(_DWORD *)(a1 + 5240);
      *(_QWORD *)(a1 + 5200) = *(_QWORD *)(a2 + 8);
      v12 = *(double *)(a1 + 6320);
      if (v12 == 0.0)
        v13 = *(double *)(a1 + 5072);
      else
        v13 = *(double *)(a1 + 5072) * 0.1 + v12 * 0.9;
      *(double *)(a1 + 6320) = v13;
      if (*(_DWORD *)(a1 + 1168) < *(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * *(int *)(a1 + 84)))
        *(_DWORD *)(a1 + 1168) = 0;
      if (!*(_BYTE *)(a1 + 1123))
      {
        result = 0;
        *(_BYTE *)(a1 + 1123) = 1;
        *(_WORD *)(a1 + 5192) = v11;
        return result;
      }
      v14 = *(unsigned __int16 *)(a1 + 5192);
      if (v11 != v14 && (unsigned __int16)(v11 - v14) < 0x7FFFu)
      {
        if (v14 > v11)
          ++*(_DWORD *)(a1 + 5196);
        *(_WORD *)(a1 + 5192) = v11;
        *(double *)(a1 + 1096) = VCRateControlAlgorithmBasePriv_GetDoubleTimeFromTimestamp(v11, 0x400u, *(_DWORD *)(a1 + 5196));
        v15 = VCRateControlAlgorithmBasePriv_CalculateCongestionMetrics(a1, *(double *)(a1 + 2856), *(double *)(a1 + 1096));
        LODWORD(v15) = *(_DWORD *)(a1 + 5240);
        LODWORD(v16) = *(_DWORD *)(a1 + 1072);
        if (*(double *)(a1 + 288) * (double)v16 <= (double)*(unint64_t *)&v15
          || *(_DWORD *)(a1 + 1052) <= *(_DWORD *)(a1 + 64))
        {
          if (*(_BYTE *)(a1 + 1121))
            *(_BYTE *)(a1 + 1121) = 0;
        }
        else
        {
          *(_BYTE *)(a1 + 1121) = 1;
        }
        VCRateControlAlgorithmBasePriv_CheckBandwidthOvershoot(a1, *(_DWORD *)(a1 + 1168));
        VCRateControlAlgorithmBasePriv_UpdateLossEvent(a1);
        VCRateControlAlgorithmBasePriv_CheckPaused(a1);
        if (*(_BYTE *)(a1 + 1112) && *(double *)(a1 + 1096) - *(double *)(a1 + 5216) > *(double *)(a1 + 304))
        {
          *(_BYTE *)(a1 + 1112) = 0;
          *(_BYTE *)(a1 + 6368) = 0;
        }
        switch(*(_DWORD *)(a1 + 1040))
        {
          case 0:
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v24 = VRTraceErrorLogLevelToCSTR();
              v25 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315650;
                v88 = v24;
                v89 = 2080;
                v90 = "_VCRateControlAlgorithmSparseNOWRD_DoRateControlWithVCRCStatistics";
                v91 = 1024;
                v92 = 278;
                _os_log_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Rate controller is paused", buf, 0x1Cu);
              }
            }
            goto LABEL_93;
          case 1:
            if (_VCRateControlAlgorithmSparseNOWRD_ShouldRampDown(a1))
              goto LABEL_71;
            if (_VCRateControlAlgorithmSparseNOWRD_ShouldRampUp(a1))
            {
              *(_DWORD *)(a1 + 1052) = _VCRateControlAlgorithmSparseNOWRD_RrampUpTier(a1);
              if (*(_DWORD *)(a1 + 1052) == *(_DWORD *)(a1 + 60))
                goto LABEL_91;
            }
            goto LABEL_93;
          case 2:
            if (_VCRateControlAlgorithmSparseNOWRD_ShouldRampDown(a1))
            {
LABEL_71:
              v36 = _VCRateControlAlgorithmSparseNOWRD_RampDownTier(a1);
              goto LABEL_90;
            }
            if (_VCRateControlAlgorithmSparseNOWRD_ShouldRampUp(a1))
            {
              v36 = _VCRateControlAlgorithmSparseNOWRD_RrampUpTier(a1);
LABEL_90:
              *(_DWORD *)(a1 + 1052) = v36;
LABEL_91:
              v37 = a1;
              v38 = 3;
              goto LABEL_92;
            }
LABEL_93:
            *(_DWORD *)(a1 + 1072) = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * *(int *)(a1 + 1052));
            if (*(_BYTE *)(a1 + 680))
            {
              v40 = *(_DWORD *)(a1 + 6276);
              if (v40 > 0xFF)
                *(_DWORD *)(a1 + 6284) -= *(_DWORD *)(a1 + 5252 + 4 * *(unsigned int *)(a1 + 6280));
              else
                *(_DWORD *)(a1 + 6276) = v40 + 1;
              *(_DWORD *)(a1 + 6284) += *(_DWORD *)(a1 + 1052);
              *(_DWORD *)(a1 + 5252 + 4 * *(unsigned int *)(a1 + 6280)) = *(_DWORD *)(a1 + 1052);
              *(_DWORD *)(a1 + 6280) = (*(_DWORD *)(a1 + 6280) + 1);
              if (*(_DWORD *)(a1 + 6276) == 256)
              {
                v41 = 0;
                v42 = 0;
                v43 = 0;
                v44 = *(_DWORD *)(a1 + 6284) >> 8;
                *(double *)(a1 + 6288) = (double)v44;
                v45 = *(_DWORD *)(a1 + 696);
                v46 = v45 + v44;
                if ((signed int)(v45 + v44) >= *(_DWORD *)(a1 + 60))
                  v46 = *(_DWORD *)(a1 + 60);
                v47 = v44 - v45;
                if (v47 <= *(_DWORD *)(a1 + 64))
                  v47 = *(_DWORD *)(a1 + 64);
                do
                {
                  v48 = *(_DWORD *)(a1 + 5252 + 4 * (*(_DWORD *)(a1 + 6280) + v41));
                  if (v42 == 1)
                    v49 = v43 + 1;
                  else
                    v49 = v43;
                  if (v48 < v47)
                  {
                    v50 = -1;
                  }
                  else
                  {
                    v49 = v43;
                    v50 = v42;
                  }
                  if (v42 == -1)
                    ++v43;
                  if (v48 > v46)
                  {
                    v42 = 1;
                  }
                  else
                  {
                    v43 = v49;
                    v42 = v50;
                  }
                  ++v41;
                }
                while (v41 != 256);
                *(_DWORD *)(a1 + 6308) = v43;
                if (*(_DWORD *)(a1 + 6308) >= *(_DWORD *)(a1 + 700))
                {
                  *(_BYTE *)(a1 + 6304) = 1;
                }
                else
                {
                  *(_BYTE *)(a1 + 6304) = 0;
                  *(_QWORD *)(a1 + 6296) = *(_QWORD *)(a1 + 1096);
                }
              }
              if (*(_BYTE *)(a1 + 6304))
              {
                v51 = *(double *)(a1 + 6296);
                if (v51 != 0.0 && *(double *)(a1 + 1096) - v51 > *(double *)(a1 + 688))
                  *(_DWORD *)(a1 + 1052) = (int)*(double *)(a1 + 6288);
              }
            }
            v52 = *(_QWORD *)(a1 + 48);
            v53 = *(int *)(a1 + 1052);
            v54 = *(_DWORD *)(v52 + 4 * v53) - *(_DWORD *)(a2 + 104);
            v55 = *(int *)(a1 + 64);
            if ((int)v55 >= (int)v53)
              v56 = *(_DWORD *)(a1 + 1052);
            else
              v56 = *(_DWORD *)(a1 + 64);
            v57 = v53 + 1;
            while (v53 > v55)
            {
              v58 = *(_DWORD *)(v52 - 4 + 4 * v53--);
              --v57;
              if (v58 <= v54)
                goto LABEL_129;
            }
            v57 = v56;
LABEL_129:
            *(_DWORD *)(a1 + 1072) = *(_DWORD *)(v52 + 4 * v57);
            if (*(_BYTE *)(a1 + 5128))
            {
              v59 = *(_DWORD *)(a1 + 1088);
              *(_DWORD *)(a1 + 1088) = v59 + 1;
              if ((v59 & 0xF) == 0 && (int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v86 = VRTraceErrorLogLevelToCSTR();
                v60 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                {
                  v61 = *(_QWORD *)(a1 + 1096);
                  v62 = *(unsigned __int16 *)(a1 + 5192);
                  v85 = *(_QWORD *)(a1 + 2856);
                  v84 = *(_QWORD *)(a1 + 2864);
                  v83 = *(_QWORD *)(a1 + 2872);
                  v82 = *(_QWORD *)(a1 + 2880);
                  v63 = (int)(*(double *)(a1 + 5072) * 1000.0);
                  if (*(_DWORD *)(a1 + 1044))
                    v64 = 88;
                  else
                    v64 = 79;
                  v65 = *(double *)(a1 + 5056);
                  v66 = *(double *)(a1 + 4992) * 100.0;
                  v67 = *(_DWORD *)(a1 + 4984);
                  v68 = *(_DWORD *)(a1 + 1168) / 0x3E8u;
                  v69 = *(_DWORD *)(a1 + 5240) / 0x3E8u;
                  v70 = *(_DWORD *)(a1 + 1072) / 0x3E8u;
                  v71 = (unsigned __int16)*(_DWORD *)(a1 + 1044);
                  v72 = *(unsigned __int16 *)(a1 + 1048);
                  v73 = *(_DWORD *)(a1 + 1084);
                  v74 = *(_DWORD *)(a1 + 6340);
                  v75 = *(double *)(a1 + 6344);
                  v76 = *(_DWORD *)(a1 + 6336) / 0x3E8u;
                  v77 = atomic_load((unsigned __int8 *)(a1 + 1024));
                  if ((v77 & 1) != 0)
                  {
                    v78 = "_";
                  }
                  else
                  {
                    v78 = "<";
                    if (!*(_BYTE *)(a1 + 1121))
                      v78 = "-";
                  }
                  v79 = *(_DWORD *)(a1 + 1040);
                  *(_DWORD *)buf = 136321282;
                  v137 = a1;
                  v88 = v86;
                  v89 = 2080;
                  v90 = "_VCRateControlAlgorithmSparseNOWRD_PrintRateControlInfoToLogDump";
                  v91 = 1024;
                  v92 = 770;
                  v93 = 2048;
                  *(_QWORD *)v94 = v61;
                  *(_WORD *)&v94[8] = 1024;
                  v95 = v62;
                  v96 = 2048;
                  v97 = v85;
                  v98 = 2048;
                  v99 = v84;
                  v100 = 2048;
                  v101 = v83;
                  v102 = 2048;
                  v103 = v82;
                  v104 = 1024;
                  v105 = v64;
                  v106 = 1024;
                  v107 = v63;
                  v108 = 2048;
                  v109 = v66;
                  v110 = 2048;
                  v111 = v65 * 100.0;
                  v112 = 1024;
                  v113 = v68;
                  v114 = 1024;
                  v115 = v67;
                  v116 = 1024;
                  v117 = v69;
                  v118 = 1024;
                  v119 = v70;
                  v120 = 1024;
                  v121 = v71;
                  v122 = 1024;
                  v123 = v72;
                  v124 = 1024;
                  v125 = v73;
                  v126 = 1024;
                  v127 = v76;
                  v128 = 1024;
                  v129 = v74;
                  v130 = 1024;
                  v131 = (v75 * 1000.0);
                  v132 = 2080;
                  v133 = v78;
                  v134 = 1024;
                  v135 = v79;
                  _os_log_impl(&dword_1D8A54000, v60, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d %8.3f/%04X:\t%.4f\t%.4f\t%.4f\t%.4f %c\tRTT:%-4u\tPLR:%4.2f@%.1f\tRRx:%4u\tMBL:%d\t%4u/%4u\t  CS:%04X %04X %u BB: %3u\t%4u\t%3u\t UAT %s _\t%d", buf, 0xC0u);
                }
              }
            }
            v80 = *(_QWORD *)(a1 + 5112);
            if (v80)
            {
              atomic_load((unsigned __int8 *)(a1 + 1024));
              VRLogfilePrintWithTimestamp(v80, "%8.3f/%04X:\t%.4f\t%.4f\t%.4f\t%.4f %c\tRTT:%-4u\tPLR:%4.2f@%.1f\tRRx:%u\tMBL:%d %u\t%4u/%4u\t %4u:%4u/%4u  %4u:%4u/%4u  CS: %04X %04X %u BB: %3u\t%4u\t%3u\t%s UAT %s\t%d\t%d\t%d\t%d\t%.3f\t%.3f\t%u\t%u\n", *(unsigned int *)(a1 + 5244) / 0x3E8uLL, (unsigned __int16)*(_DWORD *)(a1 + 1044), *(unsigned int *)(a1 + 5248) / 0x3E8uLL, *(unsigned __int16 *)(a1 + 1048), *(unsigned int *)(a1 + 4972) / 0x3E8uLL, *(unsigned int *)(a1 + 1084), *(_QWORD *)(a1 + 1096));
            }
            *(_DWORD *)(a1 + 1044) = 0;
            *(_DWORD *)(a1 + 1048) = 0;
            break;
          case 3:
            *(_DWORD *)(a1 + 1044) |= 1u;
            if (_VCRateControlAlgorithmSparseNOWRD_ShouldRampDown(a1))
              *(_DWORD *)(a1 + 1052) = _VCRateControlAlgorithmSparseNOWRD_RampDownTier(a1);
            if (*(double *)(a1 + 1096) - *(double *)(a1 + 1104) > *(double *)(a1 + 184))
            {
              v37 = a1;
              v38 = 2;
LABEL_92:
              VCRateControlAlgorithmBasePriv_StateChange(v37, v38);
            }
            goto LABEL_93;
          default:
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                _VCRateControlAlgorithmSparseNOWRD_DoRateControl_cold_2();
            }
            goto LABEL_93;
        }
        return 1;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v20 = VRTraceErrorLogLevelToCSTR();
        v21 = *MEMORY[0x1E0CF2758];
        v22 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
        result = 0;
        if (!v22)
          return result;
        v23 = *(unsigned __int16 *)(a1 + 5192);
        *(_DWORD *)buf = 136316162;
        v88 = v20;
        v89 = 2080;
        v90 = "_VCRateControlAlgorithmSparseNOWRD_DoRateControlWithVCRCStatistics";
        v91 = 1024;
        v92 = 230;
        v93 = 1024;
        *(_DWORD *)v94 = v11;
        *(_WORD *)&v94[4] = 1024;
        *(_DWORD *)&v94[6] = v23;
        _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Duplicated feedback or out-of-order feedback messages! timestamp:0x%04X, previousTimestamp:0x%04X", buf, 0x28u);
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      _VCRateControlAlgorithmSparseNOWRD_DoRateControl_cold_1();
    }
    return 0;
  }
  return 1;
}

BOOL VCRateControlAlgorithmSparseNOWRD_NoServerStatsActivityDetected(uint64_t a1)
{
  _BOOL8 result;
  uint64_t v2;
  NSObject *v3;

  if (a1)
  {
    if (*(double *)(a1 + 5072) == 0.0 && *(double *)(a1 + 2856) > 0.0 && *(_DWORD *)(a1 + 1040) != 1)
      return *(_DWORD *)(a1 + 1052) >= *(_DWORD *)(a1 + 88);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    VCRateControlAlgorithmSparseNOWRD_NoServerStatsActivityDetected_cold_1(v2, v3);
  }
  return 0;
}

uint64_t _VCRateControlAlgorithmSparseNOWRD_ShouldRampDown(uint64_t a1)
{
  double v1;
  _BOOL8 v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v1 = *(double *)(a1 + 5200);
  if (v1 - *(double *)(a1 + 5208) < 0.05)
    return 0;
  *(double *)(a1 + 5208) = v1;
  if (!*(_BYTE *)(a1 + 2848) || *(_BYTE *)(a1 + 6368))
    return 0;
  v3 = VCRateControlAlgorithmBasePriv_KeepOvershootingRampDownBandwidth(a1);
  if (v3)
  {
    *(_QWORD *)(a1 + 1176) = *(_QWORD *)(a1 + 1096);
    *(_DWORD *)(a1 + 1048) |= 0x10u;
    *(_QWORD *)(a1 + 2880) = 0;
  }
  if (*(double *)(a1 + 2864) > *(double *)(a1 + 128))
  {
    *(_DWORD *)(a1 + 1048) |= 4u;
    *(_QWORD *)(a1 + 2880) = 0;
    v3 = 1;
  }
  if (*(double *)(a1 + 2880) > *(double *)(a1 + 136) && *(_DWORD *)(a1 + 1052) > *(_DWORD *)(a1 + 64))
  {
    *(_DWORD *)(a1 + 1048) |= 8u;
    *(double *)(a1 + 2880) = *(double *)(a1 + 2880) - *(double *)(a1 + 136);
    if (*(double *)(a1 + 2880) < 0.0)
      *(_QWORD *)(a1 + 2880) = 0;
    v3 = 1;
  }
  if (*(_DWORD *)(a1 + 1040) != 1 && *(double *)(a1 + 1096) - *(double *)(a1 + 2888) > *(double *)(a1 + 160))
  {
    *(_DWORD *)(a1 + 1048) |= 1u;
    *(_QWORD *)(a1 + 2888) = *(_QWORD *)(a1 + 1096);
    *(_QWORD *)(a1 + 2880) = 0;
    v3 = 1;
  }
  if (VCRateControlAlgorithmBasePriv_ShouldRampDownDueToLossEvent(a1, v5, v6, v7, v8, v9, v10, v11))
  {
    *(_DWORD *)(a1 + 1048) |= 0x20u;
    *(_QWORD *)(a1 + 4952) = *(_QWORD *)(a1 + 1096);
    VCRateControlAlgorithmBasePriv_ResetLossEventBuffer(a1);
    *(_QWORD *)(a1 + 2880) = 0;
    v3 = 1;
  }
  if (VCRateControlAlgorithmSparseNOWRD_NoServerStatsActivityDetected(a1))
  {
    *(_DWORD *)(a1 + 1048) |= 0x100u;
    *(_QWORD *)(a1 + 2880) = 0;
    return 1;
  }
  return v3;
}

uint64_t _VCRateControlAlgorithmSparseNOWRD_RampDownTier(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;

  VCRateControlAlgorithmBasePriv_UpdateCongestionStatusWhenRampDown(a1, *(double *)(a1 + 1096));
  v8 = *(_DWORD *)(a1 + 1052);
  v9 = v8 - *(_DWORD *)(a1 + 96);
  if ((*(_BYTE *)(a1 + 1048) & 0x20) != 0 && *(double *)(a1 + 4960) > 0.0)
    --v9;
  v10 = *(_DWORD *)(a1 + 64);
  if (v9 <= v10)
    v11 = v10;
  else
    v11 = v9;
  if (v8 > (int)v11)
    VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "[%u] Congestion!!! New bitrate down to %u", v2, v3, v4, v5, v6, v7, *(_DWORD *)(a1 + 1084));
  if (*(_DWORD *)(a1 + 76) > (int)v11)
    *(_QWORD *)(a1 + 6392) = *(_QWORD *)(a1 + 1096);
  *(_DWORD *)(a1 + 1056) = *(_DWORD *)(a1 + 1052);
  return v11;
}

uint64_t _VCRateControlAlgorithmSparseNOWRD_ShouldRampUp(uint64_t a1)
{
  _BOOL4 v2;
  double v3;
  double v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  _BOOL4 v13;
  _BOOL4 v14;
  double v15;
  double v16;
  double v17;
  int v18;

  v2 = *(_BYTE *)(a1 + 2848) != 0;
  if (!*(_BYTE *)(a1 + 2848))
    *(_DWORD *)(a1 + 1044) |= 0x40u;
  v3 = *(double *)(a1 + 312);
  if (v3 >= *(double *)(a1 + 6320))
    v3 = *(double *)(a1 + 6320);
  if (*(_DWORD *)(a1 + 1040) == 1)
  {
    v4 = *(double *)(a1 + 5224);
    if (v4 == 0.0
      || *(double *)(a1 + 1096) - v4 >= v3
      || (v2 = 0, *(_DWORD *)(a1 + 1044) |= 0x40u, *(_DWORD *)(a1 + 1040) == 1))
    {
      if (*(_DWORD *)(a1 + 1052) >= *(_DWORD *)(a1 + 68) && !*(_DWORD *)(a1 + 5240))
      {
        v2 = 0;
        *(_DWORD *)(a1 + 1044) |= 0x1000u;
      }
    }
  }
  if (VCRateControlAlgorithmBasePriv_RecentlyGoAboveRampUpBandwidth(a1))
  {
    v2 = 0;
    *(_DWORD *)(a1 + 1044) |= 0x80u;
  }
  if (*(_BYTE *)(a1 + 2849))
  {
    v2 = 0;
    *(_DWORD *)(a1 + 1044) |= 0x20u;
  }
  if (*(_BYTE *)(a1 + 412) && *(_BYTE *)(a1 + 1121))
  {
    v2 = 0;
    *(_DWORD *)(a1 + 1044) |= 2u;
  }
  if (*(double *)(a1 + 2856) > *(double *)(a1 + 200))
  {
    v2 = 0;
    *(_DWORD *)(a1 + 1044) |= 4u;
  }
  if (*(double *)(a1 + 2864) > *(double *)(a1 + 208))
  {
    v2 = 0;
    *(_DWORD *)(a1 + 1044) |= 8u;
  }
  if (*(double *)(a1 + 2880) > *(double *)(a1 + 216))
  {
    v2 = 0;
    *(_DWORD *)(a1 + 1044) |= 0x10u;
  }
  v12 = *(_DWORD *)(a1 + 1052);
  if (v12 >= *(_DWORD *)(a1 + 60))
  {
    v2 = 0;
    *(_DWORD *)(a1 + 1044) |= 0x100u;
    v12 = *(_DWORD *)(a1 + 1052);
  }
  if (v12 >= *(_DWORD *)(a1 + 448) && *(_DWORD *)(a1 + 1040) == 1 && !*(_DWORD *)(a1 + 1168))
  {
    v2 = 0;
    *(_DWORD *)(a1 + 1044) |= 0x1000u;
  }
  v13 = *(double *)(a1 + 1096) - *(double *)(a1 + 4952) < *(double *)(a1 + 184) && *(_DWORD *)(a1 + 1040) != 1;
  v14 = !*(_DWORD *)(a1 + 1168) && (v15 = *(double *)(a1 + 280), v15 != 0.0) && *(double *)(a1 + 4992) > v15;
  if (v13
    || v14
    || VCRateControlAlgorithmBasePriv_ShouldBlockRampUpDueToLossEventThreshold(a1, v5, v6, v7, v8, v9, v10, v11))
  {
    v2 = 0;
    *(_DWORD *)(a1 + 1044) |= 0x200u;
  }
  if (*(_BYTE *)(a1 + 6404) && *(_DWORD *)(a1 + 1040) != 1 && !*(_DWORD *)(a1 + 6400))
  {
    *(_DWORD *)(a1 + 1044) |= 0x400u;
    if (*(double *)(a1 + 5072) != 0.0)
      goto LABEL_49;
    goto LABEL_45;
  }
  if (*(double *)(a1 + 5072) == 0.0)
  {
LABEL_45:
    *(_DWORD *)(a1 + 1044) |= 0x800u;
    goto LABEL_49;
  }
  if (v2)
  {
    *(_QWORD *)(a1 + 5232) = *(_QWORD *)(a1 + 1096);
    return 1;
  }
LABEL_49:
  v16 = *(double *)(a1 + 232);
  if (v16 != 0.0)
  {
    v17 = *(double *)(a1 + 5232);
    if (v17 != 0.0 && *(double *)(a1 + 1096) - v17 >= v16)
    {
      v18 = *(_DWORD *)(a1 + 1044);
      if (v18 == 1024 || v18 == 2)
      {
        *(_DWORD *)(a1 + 1044) = 0;
        return 1;
      }
    }
  }
  return 0;
}

uint64_t _VCRateControlAlgorithmSparseNOWRD_RrampUpTier(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  unsigned int v18;
  int v19;
  int v20;
  uint64_t v21;
  int *v23;
  int v24;
  BOOL v25;
  unsigned int v26;

  VCRateControlAlgorithmBasePriv_UpdateCongestionStatusWhenRampUp(a1);
  v9 = VCRateControlAlgorithmBasePriv_AllowRampUpWithContinuousTargetBitrate(a1, v2, v3, v4, v5, v6, v7, v8);
  v16 = *(unsigned int *)(a1 + 1052);
  if (v9)
  {
    v17 = *(_DWORD *)(a1 + 92) + v16;
    if (*(_DWORD *)(a1 + 1040) == 1)
    {
      v17 += *(_DWORD *)(a1 + 100);
    }
    else if (*(_BYTE *)(a1 + 411))
    {
      v18 = *(_DWORD *)(a1 + 356);
      if (v18)
      {
        v19 = *(_DWORD *)(a1 + 6400);
        v20 = *(_DWORD *)(a1 + 1072);
        v21 = *(_QWORD *)(a1 + 48);
        if (*(_DWORD *)(v21 + 4 * (int)v17) - v20 < v18 && v19 >= 1)
        {
          v23 = (int *)(v21 + 4 * (int)v17 + 4);
          do
          {
            v24 = *v23++;
            v25 = v24 - v20 < v18 && v19-- > 1;
            ++v17;
          }
          while (v25);
        }
      }
    }
    v26 = *(_DWORD *)(a1 + 60);
    if ((int)v17 >= (int)v26)
      v16 = v26;
    else
      v16 = v17;
    *(_QWORD *)(a1 + 5224) = *(_QWORD *)(a1 + 1096);
    *(_DWORD *)(a1 + 6400) = 0;
    *(_DWORD *)(a1 + 4968) = 0;
    VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "[%u] Ramp up bitrate to %u", v10, v11, v12, v13, v14, v15, *(_DWORD *)(a1 + 1084));
    if (*(_DWORD *)(a1 + 76) > (int)v16)
      *(_QWORD *)(a1 + 6392) = *(_QWORD *)(a1 + 1096);
    *(_DWORD *)(a1 + 1056) = *(_DWORD *)(a1 + 1052);
  }
  return v16;
}

uint64_t LoopbackTunnelReceiveProc(void *a1)
{
  uint64_t v1;
  NSObject *v2;
  int v4;
  uint64_t v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  objc_msgSend(a1, "serverLoopProc");
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v1 = VRTraceErrorLogLevelToCSTR();
    v2 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136315650;
      v5 = v1;
      v6 = 2080;
      v7 = "LoopbackTunnelReceiveProc";
      v8 = 1024;
      v9 = 157;
      _os_log_impl(&dword_1D8A54000, v2, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d LoopbackTunnelReceiveProc stopped", (uint8_t *)&v4, 0x1Cu);
    }
  }
  return 0;
}

uint64_t VCMediaNegotiationBlobAudioSettingsReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  int v15;
  char v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char v22;
  uint64_t result;
  char v24;
  unsigned int v25;
  uint64_t v26;
  unint64_t v27;
  char v28;
  char v29;
  unsigned int v30;
  uint64_t v31;
  unint64_t v32;
  char v33;
  char v34;
  unsigned int v35;
  uint64_t v36;
  unint64_t v37;
  char v38;
  char v39;
  unsigned int v40;
  uint64_t v41;
  unint64_t v42;
  char v43;
  char v44;
  unsigned int v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  char v49;
  uint64_t v50;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        v14 = v9++ >= 9;
        if (v14)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      switch((v10 >> 3))
      {
        case 1u:
          v17 = 0;
          v18 = 0;
          v19 = 0;
          while (1)
          {
            v20 = *v3;
            v21 = *(_QWORD *)(a2 + v20);
            if (v21 == -1 || v21 >= *(_QWORD *)(a2 + *v4))
              break;
            v22 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v21);
            *(_QWORD *)(a2 + v20) = v21 + 1;
            v19 |= (unint64_t)(v22 & 0x7F) << v17;
            if ((v22 & 0x80) == 0)
              goto LABEL_64;
            v17 += 7;
            v14 = v18++ >= 9;
            if (v14)
            {
              LODWORD(v19) = 0;
              goto LABEL_66;
            }
          }
          *(_BYTE *)(a2 + *v5) = 1;
LABEL_64:
          if (*(_BYTE *)(a2 + *v5))
            LODWORD(v19) = 0;
LABEL_66:
          v50 = 16;
          goto LABEL_83;
        case 2u:
          v24 = 0;
          v25 = 0;
          v19 = 0;
          *(_BYTE *)(a1 + 32) |= 1u;
          while (2)
          {
            v26 = *v3;
            v27 = *(_QWORD *)(a2 + v26);
            if (v27 == -1 || v27 >= *(_QWORD *)(a2 + *v4))
            {
              *(_BYTE *)(a2 + *v5) = 1;
            }
            else
            {
              v28 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v27);
              *(_QWORD *)(a2 + v26) = v27 + 1;
              v19 |= (unint64_t)(v28 & 0x7F) << v24;
              if (v28 < 0)
              {
                v24 += 7;
                v14 = v25++ >= 9;
                if (v14)
                {
                  LODWORD(v19) = 0;
                  goto LABEL_70;
                }
                continue;
              }
            }
            break;
          }
          if (*(_BYTE *)(a2 + *v5))
            LODWORD(v19) = 0;
LABEL_70:
          v50 = 8;
          goto LABEL_83;
        case 3u:
          v29 = 0;
          v30 = 0;
          v19 = 0;
          while (2)
          {
            v31 = *v3;
            v32 = *(_QWORD *)(a2 + v31);
            if (v32 == -1 || v32 >= *(_QWORD *)(a2 + *v4))
            {
              *(_BYTE *)(a2 + *v5) = 1;
            }
            else
            {
              v33 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v32);
              *(_QWORD *)(a2 + v31) = v32 + 1;
              v19 |= (unint64_t)(v33 & 0x7F) << v29;
              if (v33 < 0)
              {
                v29 += 7;
                v14 = v30++ >= 9;
                if (v14)
                {
                  LODWORD(v19) = 0;
                  goto LABEL_74;
                }
                continue;
              }
            }
            break;
          }
          if (*(_BYTE *)(a2 + *v5))
            LODWORD(v19) = 0;
LABEL_74:
          v50 = 24;
          goto LABEL_83;
        case 4u:
          v34 = 0;
          v35 = 0;
          v19 = 0;
          while (2)
          {
            v36 = *v3;
            v37 = *(_QWORD *)(a2 + v36);
            if (v37 == -1 || v37 >= *(_QWORD *)(a2 + *v4))
            {
              *(_BYTE *)(a2 + *v5) = 1;
            }
            else
            {
              v38 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v37);
              *(_QWORD *)(a2 + v36) = v37 + 1;
              v19 |= (unint64_t)(v38 & 0x7F) << v34;
              if (v38 < 0)
              {
                v34 += 7;
                v14 = v35++ >= 9;
                if (v14)
                {
                  LODWORD(v19) = 0;
                  goto LABEL_78;
                }
                continue;
              }
            }
            break;
          }
          if (*(_BYTE *)(a2 + *v5))
            LODWORD(v19) = 0;
LABEL_78:
          v50 = 12;
          goto LABEL_83;
        case 5u:
          v39 = 0;
          v40 = 0;
          v19 = 0;
          while (2)
          {
            v41 = *v3;
            v42 = *(_QWORD *)(a2 + v41);
            if (v42 == -1 || v42 >= *(_QWORD *)(a2 + *v4))
            {
              *(_BYTE *)(a2 + *v5) = 1;
            }
            else
            {
              v43 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v42);
              *(_QWORD *)(a2 + v41) = v42 + 1;
              v19 |= (unint64_t)(v43 & 0x7F) << v39;
              if (v43 < 0)
              {
                v39 += 7;
                v14 = v40++ >= 9;
                if (v14)
                {
                  LODWORD(v19) = 0;
                  goto LABEL_82;
                }
                continue;
              }
            }
            break;
          }
          if (*(_BYTE *)(a2 + *v5))
            LODWORD(v19) = 0;
LABEL_82:
          v50 = 20;
LABEL_83:
          *(_DWORD *)(a1 + v50) = v19;
          continue;
        case 6u:
          v44 = 0;
          v45 = 0;
          v46 = 0;
          break;
        default:
          result = PBReaderSkipValueWithTag();
          if (!(_DWORD)result)
            return result;
          continue;
      }
      while (1)
      {
        v47 = *v3;
        v48 = *(_QWORD *)(a2 + v47);
        if (v48 == -1 || v48 >= *(_QWORD *)(a2 + *v4))
          break;
        v49 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v48);
        *(_QWORD *)(a2 + v47) = v48 + 1;
        v46 |= (unint64_t)(v49 & 0x7F) << v44;
        if ((v49 & 0x80) == 0)
          goto LABEL_87;
        v44 += 7;
        v14 = v45++ >= 9;
        if (v14)
        {
          v46 = 0;
          goto LABEL_89;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_87:
      if (*(_BYTE *)(a2 + *v5))
        v46 = 0;
LABEL_89:
      *(_BYTE *)(a1 + 28) = v46 != 0;
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void _VCAudioCaptions_DestroyCopyBufferAllocator(uint64_t a1)
{
  OpaqueAudioConverter *v2;
  const void *v3;

  v2 = *(OpaqueAudioConverter **)(a1 + 336);
  if (v2)
  {
    AudioConverterDispose(v2);
    *(_QWORD *)(a1 + 336) = 0;
  }
  CFAllocatorDeallocate(*(CFAllocatorRef *)(a1 + 160), *(void **)(a1 + 328));
  *(_QWORD *)(a1 + 328) = 0;
  v3 = *(const void **)(a1 + 160);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 160) = 0;
  }
}

uint64_t captionsAudioConverterCallback(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  int v14;
  int v15;
  uint64_t v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  __int16 v23;
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (a1 && a2 && a3 && a5)
  {
    v8 = *a5;
    if (*a5)
    {
      v9 = (*(_DWORD *)(v8 + 12) / *((_DWORD *)a5 + 6));
      if (v9 < *a2 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v10 = VRTraceErrorLogLevelToCSTR();
        v11 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v14 = *a2;
          v15 = 136316162;
          v16 = v10;
          v17 = 2080;
          v18 = "captionsAudioConverterCallback";
          v19 = 1024;
          v20 = 378;
          v21 = 1024;
          v22 = v14;
          v23 = 2048;
          v24 = v9;
          _os_log_error_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_ERROR, " [%s] %s:%d Insufficent input samples: needed = %d, available = %lu", (uint8_t *)&v15, 0x2Cu);
        }
      }
      v12 = 0;
      *a2 = v9;
      *(_QWORD *)(a3 + 16) = *(_QWORD *)(v8 + 16);
      *(_QWORD *)(a3 + 8) = *(_QWORD *)(v8 + 8);
      *a5 = 0;
    }
    else
    {
      *a2 = 0;
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    v12 = 2003329396;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        captionsAudioConverterCallback_cold_1();
    }
  }
  return v12;
}

void sub_1D8AF6974(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1D8AF6DB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_list va;

  va_start(va, a12);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1D8AF73D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t _VCNetworkConditionMonitorClassRegister(uint64_t *a1)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

uint64_t VCNetworkConditionMonitor_Create(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t Instance;
  uint64_t v6;
  NSObject *CustomRootQueue;
  dispatch_queue_t v8;
  uint64_t v9;
  NSObject *v10;
  const void *v11;
  const void *v12;
  uint64_t v13;
  int v15;
  uint64_t v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  uint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (*(_QWORD *)a3)
    {
      if (*(_QWORD *)(a3 + 8))
      {
        if (VCNetworkConditionMonitorGetTypeID_initOnce != -1)
          dispatch_once_f(&VCNetworkConditionMonitorGetTypeID_initOnce, &VCNetworkConditionMonitorGetTypeID_typeID, (dispatch_function_t)_VCNetworkConditionMonitorClassRegister);
        Instance = _CFRuntimeCreateInstance();
        if (Instance)
        {
          v6 = Instance;
          CustomRootQueue = VCDispatchQueue_GetCustomRootQueue(37);
          v8 = dispatch_queue_create_with_target_V2("com.apple.AVConference.VCNetworkConditionMonitor.stateQueue", 0, CustomRootQueue);
          *(_QWORD *)(v6 + 32) = v8;
          if (v8)
          {
            *(_OWORD *)(v6 + 104) = xmmword_1D9108E50;
            *(_QWORD *)(v6 + 56) = 0x4010000000000000;
            *(_OWORD *)(v6 + 16) = *(_OWORD *)a3;
            *(_OWORD *)(v6 + 40) = *(_OWORD *)(a3 + 16);
            *(_OWORD *)(v6 + 64) = *(_OWORD *)(a3 + 32);
            *(_OWORD *)(v6 + 80) = *(_OWORD *)(a3 + 48);
            *(_QWORD *)(v6 + 96) = *(_QWORD *)(a3 + 64);
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v9 = VRTraceErrorLogLevelToCSTR();
              v10 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                v15 = 136315906;
                v16 = v9;
                v17 = 2080;
                v18 = "VCNetworkConditionMonitor_Create";
                v19 = 1024;
                v20 = 172;
                v21 = 2048;
                v22 = v6;
                _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d NetworkConditionMonitor: New instance created=%p", (uint8_t *)&v15, 0x26u);
              }
            }
            v11 = *(const void **)(v6 + 128);
            v12 = *(const void **)(a3 + 72);
            *(_QWORD *)(v6 + 128) = v12;
            if (v12)
              CFRetain(v12);
            if (v11)
              CFRelease(v11);
            v13 = 0;
            *a2 = v6;
          }
          else
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                VCNetworkConditionMonitor_Create_cold_5();
            }
            CFRelease((CFTypeRef)v6);
            return 2150170627;
          }
        }
        else if ((int)VRTraceGetErrorLogLevelForModule() < 3)
        {
          return 2150170627;
        }
        else
        {
          VRTraceErrorLogLevelToCSTR();
          v13 = 2150170627;
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCNetworkConditionMonitor_Create_cold_4();
        }
      }
      else
      {
        v13 = 2150170625;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCNetworkConditionMonitor_Create_cold_3();
        }
      }
    }
    else
    {
      v13 = 2150170625;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCNetworkConditionMonitor_Create_cold_2();
      }
    }
  }
  else
  {
    v13 = 2150170625;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCNetworkConditionMonitor_Create_cold_1();
    }
  }
  return v13;
}

void VCNetworkConditionMonitor_Invalidate(uint64_t a1)
{
  NSObject *v1;
  _QWORD v2[6];

  v2[5] = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v1 = *(NSObject **)(a1 + 32);
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __VCNetworkConditionMonitor_Invalidate_block_invoke;
    v2[3] = &__block_descriptor_tmp_0;
    v2[4] = a1;
    dispatch_sync(v1, v2);
  }
}

uint64_t VCNetworkConditionMonitor_SetBrokenNetworkStatus(uint64_t a1, char a2, char a3)
{
  NSObject *v3;
  uint64_t v4;
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  _QWORD v9[5];
  char v10;
  char v11;
  uint8_t buf[4];
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v3 = *(NSObject **)(a1 + 32);
    v9[0] = MEMORY[0x1E0C809B0];
    v9[1] = 0x40000000;
    v9[2] = __VCNetworkConditionMonitor_SetBrokenNetworkStatus_block_invoke;
    v9[3] = &__block_descriptor_tmp_3;
    v10 = a2;
    v9[4] = a1;
    v11 = a3;
    dispatch_async(v3, v9);
    return 0;
  }
  else
  {
    v4 = 2150170625;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v6 = VRTraceErrorLogLevelToCSTR();
      v7 = *MEMORY[0x1E0CF2758];
      v8 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          v13 = v6;
          v14 = 2080;
          v15 = "VCNetworkConditionMonitor_SetBrokenNetworkStatus";
          v16 = 1024;
          v17 = 195;
          _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d NetworkConditionMonitor: NULL networkConditionMonitor", buf, 0x1Cu);
        }
      }
      else if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        VCNetworkConditionMonitor_SetBrokenNetworkStatus_cold_1();
      }
    }
  }
  return v4;
}

void _VCNetworkConditionMonitor_RunLocalNetworkDetectionAlgorithm(_BYTE *a1)
{
  int v2;
  int v3;
  uint64_t v4;
  NSObject *v5;
  const char *v6;
  int v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v2 = a1[124];
  if (a1[122] || a1[120])
  {
    v3 = 1;
  }
  else
  {
    v3 = a1[121];
    if (a1[121])
      v3 = a1[126] != 0;
  }
  a1[124] = v3;
  if (v2 != v3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v4 = VRTraceErrorLogLevelToCSTR();
      v5 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v6 = "yes";
        v7 = a1[122];
        v8 = a1[120];
        if (!a1[124])
          v6 = "no";
        v9 = a1[121];
        v10 = 136316674;
        v11 = v4;
        v12 = 2080;
        v13 = "_VCNetworkConditionMonitor_RunLocalNetworkDetectionAlgorithm";
        v14 = 1024;
        v15 = 132;
        v16 = 2080;
        v17 = v6;
        v18 = 1024;
        v19 = v7;
        v20 = 1024;
        v21 = v8;
        v22 = 1024;
        v23 = v9;
        _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d NetworkConditionMonitor: isLocalNetworkQualityBadOrBroken=%s. isLocalNetworkBroken=%d isLocalWiFiQualityBad=%d isLocalCellQualityBad=%d", (uint8_t *)&v10, 0x38u);
      }
    }
    _VCNetworkConditionMonitor_triggerNetworkConditionCallback((uint64_t)a1, 1);
  }
}

void _VCNetworkConditionMonitor_triggerNetworkConditionCallback(uint64_t a1, uint64_t a2)
{
  _BOOL8 v4;
  int v5;
  const __CFAllocator *v6;
  __CFDictionary *Mutable;
  CFNumberRef v8;
  int valuePtr;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(_BYTE *)(a1 + 125))
    v4 = 1;
  else
    v4 = *(_BYTE *)(a1 + 123) != 0;
  (*(void (**)(_QWORD, BOOL, _BOOL8, uint64_t))(a1 + 16))(*(_QWORD *)(a1 + 24), *(_BYTE *)(a1 + 124) != 0, v4, a2);
  valuePtr = 0;
  if (*(_BYTE *)(a1 + 122))
  {
    v5 = 1;
LABEL_8:
    valuePtr = v5;
    goto LABEL_9;
  }
  if (*(_BYTE *)(a1 + 123))
  {
    v5 = 2;
    goto LABEL_8;
  }
  if (*(_BYTE *)(a1 + 121) && *(_BYTE *)(a1 + 126))
  {
    v5 = 4;
    goto LABEL_8;
  }
  if (*(_BYTE *)(a1 + 120))
  {
    v5 = 3;
    goto LABEL_8;
  }
  if (*(_BYTE *)(a1 + 125))
  {
    v5 = 5;
    goto LABEL_8;
  }
LABEL_9:
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v8 = CFNumberCreate(v6, kCFNumberIntType, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("NetworkQualityStatus"), v8);
  reportingGenericEvent();
  if (v8)
    CFRelease(v8);
  if (Mutable)
    CFRelease(Mutable);
}

uint64_t VCNetworkConditionMonitor_SetWiFiChannelQualityScore(uint64_t a1, char a2)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  _QWORD v8[5];
  char v9;
  uint8_t buf[4];
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = *(NSObject **)(a1 + 32);
    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 0x40000000;
    v8[2] = __VCNetworkConditionMonitor_SetWiFiChannelQualityScore_block_invoke;
    v8[3] = &__block_descriptor_tmp_6;
    v9 = a2;
    v8[4] = a1;
    dispatch_async(v2, v8);
    return 0;
  }
  else
  {
    v3 = 2150170625;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v6 = *MEMORY[0x1E0CF2758];
      v7 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          v11 = v5;
          v12 = 2080;
          v13 = "VCNetworkConditionMonitor_SetWiFiChannelQualityScore";
          v14 = 1024;
          v15 = 213;
          _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d NetworkConditionMonitor: NULL networkConditionMonitor", buf, 0x1Cu);
        }
      }
      else if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        VCNetworkConditionMonitor_SetWiFiChannelQualityScore_cold_1();
      }
    }
  }
  return v3;
}

uint64_t VCNetworkConditionMonitor_SetCellSignalStrengthBars(uint64_t a1, char a2, char a3)
{
  NSObject *v3;
  uint64_t v4;
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  _QWORD v9[5];
  char v10;
  char v11;
  uint8_t buf[4];
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v3 = *(NSObject **)(a1 + 32);
    v9[0] = MEMORY[0x1E0C809B0];
    v9[1] = 0x40000000;
    v9[2] = __VCNetworkConditionMonitor_SetCellSignalStrengthBars_block_invoke;
    v9[3] = &__block_descriptor_tmp_7;
    v10 = a2;
    v9[4] = a1;
    v11 = a3;
    dispatch_async(v3, v9);
    return 0;
  }
  else
  {
    v4 = 2150170625;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v6 = VRTraceErrorLogLevelToCSTR();
      v7 = *MEMORY[0x1E0CF2758];
      v8 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          v13 = v6;
          v14 = 2080;
          v15 = "VCNetworkConditionMonitor_SetCellSignalStrengthBars";
          v16 = 1024;
          v17 = 235;
          _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d NetworkConditionMonitor: NULL networkConditionMonitor", buf, 0x1Cu);
        }
      }
      else if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        VCNetworkConditionMonitor_SetCellSignalStrengthBars_cold_1();
      }
    }
  }
  return v4;
}

uint64_t VCNetworkConditionMonitor_SetRemoteNetworkQuality(uint64_t a1, char a2)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  _QWORD v8[5];
  char v9;
  uint8_t buf[4];
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = *(NSObject **)(a1 + 32);
    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 0x40000000;
    v8[2] = __VCNetworkConditionMonitor_SetRemoteNetworkQuality_block_invoke;
    v8[3] = &__block_descriptor_tmp_8;
    v8[4] = a1;
    v9 = a2;
    dispatch_async(v2, v8);
    return 0;
  }
  else
  {
    v3 = 2150170625;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v6 = *MEMORY[0x1E0CF2758];
      v7 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          v11 = v5;
          v12 = 2080;
          v13 = "VCNetworkConditionMonitor_SetRemoteNetworkQuality";
          v14 = 1024;
          v15 = 258;
          _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d NetworkConditionMonitor: NULL networkConditionMonitor", buf, 0x1Cu);
        }
      }
      else if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        VCNetworkConditionMonitor_SetRemoteNetworkQuality_cold_1();
      }
    }
  }
  return v3;
}

uint64_t VCNetworkConditionMonitor_SetIsLocalActiveOnCellular(uint64_t a1, char a2)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  _QWORD v8[5];
  char v9;
  uint8_t buf[4];
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = *(NSObject **)(a1 + 32);
    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 0x40000000;
    v8[2] = __VCNetworkConditionMonitor_SetIsLocalActiveOnCellular_block_invoke;
    v8[3] = &__block_descriptor_tmp_9;
    v8[4] = a1;
    v9 = a2;
    dispatch_async(v2, v8);
    return 0;
  }
  else
  {
    v3 = 2150170625;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v6 = *MEMORY[0x1E0CF2758];
      v7 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          v11 = v5;
          v12 = 2080;
          v13 = "VCNetworkConditionMonitor_SetIsLocalActiveOnCellular";
          v14 = 1024;
          v15 = 273;
          _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d NetworkConditionMonitor: NULL networkConditionMonitor", buf, 0x1Cu);
        }
      }
      else if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        VCNetworkConditionMonitor_SetIsLocalActiveOnCellular_cold_1();
      }
    }
  }
  return v3;
}

double _VCNetworkConditionMonitor_Init(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 128) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

void _VCNetworkConditionMonitor_Finalize(uint64_t a1)
{
  const void *v2;
  NSObject *v3;

  v2 = *(const void **)(a1 + 128);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 128) = 0;
  }
  v3 = *(NSObject **)(a1 + 32);
  if (v3)
  {
    dispatch_sync(v3, &__block_literal_global_10);
    dispatch_release(*(dispatch_object_t *)(a1 + 32));
  }
}

void OUTLINED_FUNCTION_2_3(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 0x1Cu);
}

double VCRedundancyControllerVideo_ConvertRedundancyPercentageToRatio(unsigned int a1)
{
  double result;

  result = 3.0;
  if (a1 <= 0x12C)
    return (double)a1 / 100.0;
  return result;
}

void sub_1D8AFC534(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1D8AFCBA8(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

BOOL VCMediaKeyIndex_isValid(_QWORD *a1)
{
  _BOOL8 v2;

  if (!a1)
    return 0;
  objc_sync_enter(a1);
  v2 = (a1[1] & a1[2]) != -1;
  objc_sync_exit(a1);
  return v2;
}

BOOL VCMediaKeyIndex_isEqual(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  size_t v3;

  if (a1 == a2)
    return 1;
  v2 = 0;
  if (a1 && a2)
  {
    v3 = *(unsigned int *)(a1 + 24);
    return (_DWORD)v3 == *(_DWORD *)(a2 + 24)
        && *(_QWORD *)(a1 + 32) == *(_QWORD *)(a2 + 32)
        && memcmp((const void *)(a1 + 8), (const void *)(a2 + 8), v3) == 0;
  }
  return v2;
}

BOOL VCMediaKeyIndex_isStartingWithPrefix(uint64_t a1, uint64_t a2)
{
  _BOOL8 result;
  size_t v4;

  if (a1 == a2)
    return 1;
  result = 0;
  if (a1 && a2)
  {
    v4 = *(unsigned int *)(a2 + 24);
    return *(_DWORD *)(a1 + 24) >= v4 && memcmp((const void *)(a1 + 8), (const void *)(a2 + 8), v4) == 0;
  }
  return result;
}

void sub_1D8AFCF30(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id VCMediaKeyIndex_CreateMKIWithBytes(uint64_t a1, uint64_t a2)
{
  return +[VCMediaKeyIndex newMKIWithBytes:bufferSize:](VCMediaKeyIndex, "newMKIWithBytes:bufferSize:", a1, a2);
}

void VCMediaKeyIndex_Release(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  *a1 = 0;
}

uint64_t VCMediaKeyIndex_ReleaseAndCopyNewValue(const void **a1, void *a2)
{
  const void *v4;
  uint64_t result;

  v4 = *a1;
  if (v4)
    CFRelease(v4);
  result = objc_msgSend(a2, "copy");
  *a1 = (const void *)result;
  return result;
}

uint64_t VCMediaKeyIndex_FullKeyBytes(void *a1, const char *a2)
{
  return objc_msgSend(a1, "fullKeyBytes:", a2);
}

uint64_t VCMediaKeyIndex_UniquePrefixBytes(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v4;

  if (a1 && a2 && (v4 = a3, (_DWORD)a3))
  {
    bzero(a2, a3);
    objc_sync_enter((id)a1);
    memcpy(a2, (const void *)(a1 + 8), v4);
    objc_sync_exit((id)a1);
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCMediaKeyIndex_UniquePrefixBytes_cold_1();
    }
    return 0;
  }
  return v4;
}

uint64_t VCMediaKeyIndex_UniquePrefixSize(uint64_t a1)
{
  uint64_t v2;

  if (!a1)
    return 0;
  objc_sync_enter((id)a1);
  v2 = *(_QWORD *)(a1 + 32);
  if (!v2)
    v2 = *(unsigned int *)(a1 + 24);
  objc_sync_exit((id)a1);
  return v2;
}

const char *VCMediaKeyIndex_Description(void *a1)
{
  return CFStringGetCStringPtr((CFStringRef)objc_msgSend(a1, "description"), 0x8000100u);
}

void StallModeTracePrint_(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  __int128 v10;
  uint64_t v11;
  char tm_hour;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  tm v19;
  _BYTE v20[24];
  char *v21[2];

  v21[1] = *(char **)MEMORY[0x1E0C80C00];
  if (g_fpStallModeDump)
  {
    v21[0] = 0;
    memset(v20, 170, sizeof(v20));
    gettimeofday((timeval *)v20, 0);
    *(_QWORD *)&v20[16] = &a9;
    vasprintf(v21, a5, &a9);
    if (v21[0])
    {
      v19.tm_zone = (char *)0xAAAAAAAAAAAAAAAALL;
      *(_QWORD *)&v10 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)&v19.tm_mon = v10;
      *(_OWORD *)&v19.tm_isdst = v10;
      *(_OWORD *)&v19.tm_sec = v10;
      localtime_r((const time_t *)v20, &v19);
      v11 = g_fpStallModeDump;
      tm_hour = v19.tm_hour;
      VRTraceErrorLogLevelToCSTR();
      VRLogfilePrint(v11, "%02d:%02d:%02d.%06d <%s> %s: %s\n", v13, v14, v15, v16, v17, v18, tm_hour);
      free(v21[0]);
    }
  }
}

uint64_t initialBitrateTierFromLearntBitrateWithCellTech(uint64_t a1, int a2, int a3, int a4, int a5, int a6)
{
  const __CFString *v6;
  int v7;
  const __CFString *v8;
  CFStringRef v9;
  unsigned int LearntBitrateForSegment;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  NSObject *v14;
  uint8_t buf[4];
  uint64_t v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  CFStringRef v23;
  __int16 v24;
  unsigned int v25;
  __int16 v26;
  int v27;
  __int16 v28;
  int v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if ((a3 - 5) > 4)
      v6 = CFSTR("S");
    else
      v6 = (const __CFString *)*((_QWORD *)&off_1E9E53780 + a3 - 5);
  }
  else
  {
    v6 = CFSTR("W");
  }
  v7 = g_adwTxRateTiers[a6];
  if (a4)
  {
    if ((a5 - 5) > 4)
      v8 = CFSTR("S");
    else
      v8 = (const __CFString *)*((_QWORD *)&off_1E9E53780 + a5 - 5);
  }
  else
  {
    v8 = CFSTR("W");
  }
  v9 = CFStringCreateWithFormat(0, 0, CFSTR("%@:%@"), v6, v8);
  LearntBitrateForSegment = reportingGetLearntBitrateForSegment();
  CFRelease(v9);
  LODWORD(v11) = 38;
  while (1)
  {
    v11 = (v11 - 1);
    if (g_adwTxRateTiers[v11] <= LearntBitrateForSegment)
      break;
    if (v11 <= 1)
    {
      v11 = 0;
      break;
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v12 = VRTraceErrorLogLevelToCSTR();
    v13 = *MEMORY[0x1E0CF2758];
    v14 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136316674;
        v17 = v12;
        v18 = 2080;
        v19 = "initialBitrateTierFromLearntBitrateWithCellTech";
        v20 = 1024;
        v21 = 1160;
        v22 = 2112;
        v23 = v9;
        v24 = 1024;
        v25 = LearntBitrateForSegment;
        v26 = 1024;
        v27 = v11;
        v28 = 1024;
        v29 = v7;
        _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d AdaptiveLearning(AFRC): Setting up initial bitrate for segment %@ - learnt target bitrate %d, selected tier %d, default bitrate %d", buf, 0x38u);
      }
    }
    else if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136316674;
      v17 = v12;
      v18 = 2080;
      v19 = "initialBitrateTierFromLearntBitrateWithCellTech";
      v20 = 1024;
      v21 = 1160;
      v22 = 2112;
      v23 = v9;
      v24 = 1024;
      v25 = LearntBitrateForSegment;
      v26 = 1024;
      v27 = v11;
      v28 = 1024;
      v29 = v7;
      _os_log_debug_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEBUG, "VCRC [%s] %s:%d AdaptiveLearning(AFRC): Setting up initial bitrate for segment %@ - learnt target bitrate %d, selected tier %d, default bitrate %d", buf, 0x38u);
    }
  }
  return v11;
}

uint64_t AFRCCreateHandle(uint64_t *a1, uint64_t a2, const void *a3, int *a4)
{
  _QWORD *v8;
  uint64_t v9;
  char *v10;
  uint64_t v15;
  uint64_t v16;
  NSObject *v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  double v24;
  int v25;
  int v26;
  int v27;
  double v28;
  int v29;
  double v30;
  double *v31;
  double *v32;
  uint64_t Handle;
  int ErrorLogLevelForModule;
  os_log_t *v35;
  uint64_t v36;
  NSObject *v37;
  const char *v38;
  int v39;
  const char *v40;
  int v41;
  int v42;
  int v43;
  int v44;
  uint64_t v45;
  NSObject *v46;
  const char *v47;
  FILE **v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  FILE **v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  int v74;
  uint64_t v75;
  NSObject *v76;
  const char *v77;
  CFIndex AppIntegerValue;
  char v80;
  CFIndex v81;
  BOOL v82;
  char v83;
  double v84;
  int v85;
  int v86;
  int v87;
  int v88;
  int v89;
  int v90;
  CFIndex v91;
  BOOL v92;
  char v93;
  CFIndex v94;
  BOOL v95;
  char v96;
  int v97;
  _BYTE *v98;
  uint64_t v99;
  NSObject *v100;
  NSObject *v101;
  int v102;
  int v103;
  uint64_t v104;
  NSObject *v105;
  NSObject *v106;
  int v107;
  int v108;
  uint64_t v109;
  int v110;
  int v111;
  uint64_t v112;
  NSObject *v113;
  NSObject *v114;
  int v116;
  int v117;
  int v118;
  int v119;
  uint64_t v120;
  int v121;
  int v122;
  char v123;
  char v124;
  Boolean keyExistsAndHasValidFormat;
  uint8_t buf[12];
  __int16 v127;
  const char *v128;
  __int16 v129;
  int v130;
  __int16 v131;
  _BYTE v132[10];
  __int128 v133;
  _BYTE v134[6];
  __int16 v135;
  int v136;
  uint64_t v137;

  v137 = *MEMORY[0x1E0C80C00];
  v8 = malloc_type_calloc(1uLL, 0x2680uLL, 0x10E00404730A826uLL);
  if (v8)
  {
    v9 = (uint64_t)v8;
    v10 = (char *)(v8 + 1203);
    v8[351] = a2;
    MediaQueue_SetAudioFECLevel(1.0);
    *(_QWORD *)(v9 + 2736) = 0x3FF0000000000000;
    __asm { FMOV            V0.2D, #1.0 }
    *(_OWORD *)(v9 + 2720) = _Q0;
    *(_OWORD *)(v9 + 2700) = 0u;
    if (!*((_BYTE *)a4 + 54))
    {
      *(_QWORD *)v9 = a3;
      if (a3)
      {
        CFRetain(a3);
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v16 = VRTraceErrorLogLevelToCSTR();
        v17 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = v16;
          v127 = 2080;
          v128 = "AFRCCreateHandle";
          v129 = 1024;
          v130 = 1189;
          _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d AFRCCreateHandle: RTCReportingAgent is nil", buf, 0x1Cu);
        }
      }
    }
    v18 = *a4;
    *(_DWORD *)(v9 + 2928) = *a4;
    v19 = a4[1];
    *(_DWORD *)(v9 + 2932) = v19;
    v20 = a4[2];
    *(_DWORD *)(v9 + 2936) = v20;
    v21 = a4[3];
    *(_DWORD *)(v9 + 2940) = v21;
    v22 = a4[4];
    *(_DWORD *)(v9 + 9696) = v22;
    v23 = a4[5];
    *(_DWORD *)(v9 + 2944) = v23;
    *(_DWORD *)(v9 + 2632) = a4[8];
    v10[77] = a4[10] != 0;
    *(_BYTE *)(v9 + 2696) = a4[11] != 0;
    *(_DWORD *)(v9 + 2824) = a4[12];
    *((_WORD *)v10 + 107) = *((_WORD *)a4 + 26);
    v10[228] = *((_BYTE *)a4 + 55);
    v24 = 0.5;
    if (v23)
      v24 = 1.0;
    *(double *)(v9 + 2456) = v24;
    if (v18)
    {
      if (v20 == 2)
      {
LABEL_20:
        *(_DWORD *)(v9 + 2948) = 1;
        goto LABEL_22;
      }
      if (v20 != 7)
      {
        if (v20 != 4)
          goto LABEL_22;
        goto LABEL_20;
      }
      *(_DWORD *)(v9 + 2952) = 1;
    }
LABEL_22:
    v10[76] = 0;
    if (v22)
    {
      v25 = 0;
      v26 = 3;
      *(_DWORD *)(v9 + 28) = 3;
      *(_QWORD *)(v9 + 36) = 3;
      *(_QWORD *)(v9 + 2464) = 0x4000000000000000;
      *(_QWORD *)(v9 + 2456) = 0x3FF0000000000000;
      goto LABEL_33;
    }
    if (!*(_DWORD *)(v9 + 2948))
    {
      if (*(_DWORD *)(v9 + 2952))
      {
        v27 = 5;
        *(_DWORD *)(v9 + 28) = 5;
        v28 = 1.0;
        v26 = 5;
        goto LABEL_32;
      }
      if (!v19 || v21 != 4 && v21 != 2)
      {
        v27 = 10;
        v26 = initialBitrateTierFromLearntBitrateWithCellTech((uint64_t)a3, v18 != 0, v20, v19 != 0, v21, 10);
        *(_DWORD *)(v9 + 28) = v26;
        *(_DWORD *)(v9 + 32) = v26;
        v28 = 1.0;
        goto LABEL_32;
      }
    }
    v27 = 3;
    *(_DWORD *)(v9 + 28) = 3;
    v28 = 2.0;
    v26 = 3;
LABEL_32:
    *(double *)(v9 + 2464) = v28;
    v25 = 1;
    *(_DWORD *)(v9 + 36) = v27;
    *(_DWORD *)(v9 + 40) = 0;
LABEL_33:
    *(_DWORD *)(v9 + 2480) = v25;
    v29 = g_adwTxRateTiers[v26];
    *(_DWORD *)(v9 + 44) = v29;
    *(_DWORD *)(v9 + 9816) = v29;
    *(double *)(v9 + 9808) = micro();
    v10[176] = 0;
    *(int32x2_t *)(v9 + 20) = vdup_n_s32(0x927C0u);
    *(_QWORD *)(v9 + 1400) = 0x100000001;
    *(_DWORD *)(v9 + 1396) = 5;
    *(_OWORD *)(v9 + 80) = xmmword_1D9109420;
    *(_QWORD *)(v9 + 96) = 0x3FC3333333333333;
    *(double *)(v9 + 104) = micro();
    *(_QWORD *)(v9 + 68) = -1;
    ConfigureAFRCDefaults(v9);
    *(_QWORD *)(v9 + 9576) = 0x3FF0000000000000;
    *v10 = -1;
    *(_QWORD *)(v9 + 152) = 0;
    *(_QWORD *)(v9 + 2504) = 0;
    *(_QWORD *)(v9 + 2520) = 0;
    *(_QWORD *)(v9 + 2512) = 0;
    *(_DWORD *)(v9 + 2632) = 2;
    *(_DWORD *)(v9 + 9704) = 0;
    *(_QWORD *)(v9 + 9712) = 0;
    *(_DWORD *)(v9 + 140) = 0;
    v30 = micro();
    *(double *)(v9 + 9672) = v30;
    *(double *)(v9 + 9680) = v30;
    v31 = (double *)RateMonitorCreateWithHistoryLength(300);
    *(_QWORD *)(v9 + 9768) = v31;
    RateMonitorConfigureWithThresholds(v31, 228000.0, 0.1, 0.15, 0.5);
    RateMonitorStart(*(_BYTE **)(v9 + 9768));
    *(_DWORD *)(v9 + 9796) = 0;
    v32 = (double *)RateMonitorCreateWithHistoryLength(300);
    *(_QWORD *)(v9 + 9784) = v32;
    RateMonitorConfigureWithThresholds(v32, 0.0, 0.1, 0.1, 0.5);
    RateMonitorStart(*(_BYTE **)(v9 + 9784));
    *(_DWORD *)(v9 + 688) = 0;
    pthread_mutex_init((pthread_mutex_t *)(v9 + 280), 0);
    pthread_mutex_init((pthread_mutex_t *)(v9 + 2560), 0);
    pthread_mutex_init((pthread_mutex_t *)(v9 + 2744), 0);
    pthread_mutex_init((pthread_mutex_t *)(v9 + 2864), 0);
    Handle = CreateHandle();
    *a1 = Handle;
    if (Handle == 0xFFFFFFFFLL)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          AFRCCreateHandle_cold_3();
      }
      pthread_mutex_destroy((pthread_mutex_t *)(v9 + 280));
      pthread_mutex_destroy((pthread_mutex_t *)(v9 + 2560));
      pthread_mutex_destroy((pthread_mutex_t *)(v9 + 2744));
      pthread_mutex_destroy((pthread_mutex_t *)(v9 + 2864));
      free((void *)v9);
      return 2149646341;
    }
    else
    {
      reportingRegisterPeriodicTask();
      ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
      v35 = (os_log_t *)MEMORY[0x1E0CF2758];
      if (ErrorLogLevelForModule >= 7)
      {
        v36 = VRTraceErrorLogLevelToCSTR();
        v37 = *v35;
        if (os_log_type_enabled(*v35, OS_LOG_TYPE_DEFAULT))
        {
          v38 = "YES";
          v39 = *(_DWORD *)(v9 + 2936);
          if (*(_DWORD *)(v9 + 2928))
            v40 = "YES";
          else
            v40 = "NO";
          v41 = *(_DWORD *)(v9 + 2940);
          if (!*(_DWORD *)(v9 + 2932))
            v38 = "NO";
          *(_DWORD *)buf = 136316674;
          *(_QWORD *)&buf[4] = v36;
          v127 = 2080;
          v128 = "AFRCCreateHandle";
          v129 = 1024;
          v130 = 1503;
          v131 = 2080;
          *(_QWORD *)v132 = v40;
          *(_WORD *)&v132[8] = 1024;
          LODWORD(v133) = v39;
          WORD2(v133) = 2080;
          *(_QWORD *)((char *)&v133 + 6) = v38;
          HIWORD(v133) = 1024;
          *(_DWORD *)v134 = v41;
          _os_log_impl(&dword_1D8A54000, v37, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d AFRCCreateHandle (CellTech local[%s:%d] remote[%s:%d]).", buf, 0x3Cu);
        }
      }
      v43 = a4[6];
      v42 = a4[7];
      v44 = a4[9];
      *(_DWORD *)(v9 + 2816) = v43;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v45 = VRTraceErrorLogLevelToCSTR();
        v46 = *v35;
        if (os_log_type_enabled(*v35, OS_LOG_TYPE_DEFAULT))
        {
          v47 = "enabled";
          *(_DWORD *)buf = 136315906;
          *(_QWORD *)&buf[4] = v45;
          v127 = 2080;
          v128 = "AFRCLog_OpenLogs";
          if (!v43)
            v47 = "disabled";
          v129 = 1024;
          v130 = 823;
          v131 = 2080;
          *(_QWORD *)v132 = v47;
          _os_log_impl(&dword_1D8A54000, v46, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d ### AFRC log %s", buf, 0x26u);
        }
      }
      if (v42
        && (memset(buf, 170, sizeof(buf)),
            __sprintf_chk((char *)buf, 0, 0xCuLL, "%010u", *(_DWORD *)(v9 + 2824)),
            v48 = VRLogfileAlloc(0, (uint64_t)buf, (uint64_t)"AFRC", (uint64_t)".afrcdump", "com.apple.VideoConference.AFRClog", 9), *(_QWORD *)(v9 + 2832) = v48, VRLogfilePrintSync(v48, "STime\t\tdTime/ETxTS\tOWRD\tNOWRD\tNOWRDS\tNOWRDA\tUp\tRTT\tPLR/FEC\tRRx\tMBL\tLRx\tBR/TR\tMQIn: A/V\tMQOut: A/V\tABRL\tQD\tBDL\tTxAT\tMODE\tTxSTATE\tAudio:PL/Rate\n", v49, v50, v51, v52, v53, v54, v123), VRLogfilePrintSync(
              *(FILE ***)(v9 + 2832),
              "connection #: %d.\n",
              v55,
              v56,
              v57,
              v58,
              v59,
              v60,
              *(_DWORD *)(v9 + 2632)),
            *(_QWORD *)(v9 + 2832)))
      {
        v61 = *(_DWORD *)(v9 + 2824);
        if (AFRCLog_OpenStallModeLog_once != -1)
          dispatch_once(&AFRCLog_OpenStallModeLog_once, &__block_literal_global_11);
        pthread_mutex_lock(&g_fpStallModeDumpOpenCloseLock);
        VRLogfileFree(&g_fpStallModeDump);
        memset(buf, 170, sizeof(buf));
        __sprintf_chk((char *)buf, 0, 0xCuLL, "%010u", v61);
        g_fpStallModeDump = (uint64_t)VRLogfileAlloc(0, (uint64_t)buf, (uint64_t)"AFRC", (uint64_t)".stalldump", "com.apple.VideoConference.StallModeDump", 32);
        pthread_mutex_unlock(&g_fpStallModeDumpOpenCloseLock);
        memset(buf, 170, sizeof(buf));
        __sprintf_chk((char *)buf, 0, 0xCuLL, "%010u", *(_DWORD *)(v9 + 2824));
        v62 = VRLogfileAlloc(0, (uint64_t)buf, (uint64_t)"AFRC", (uint64_t)".fbdump", "com.apple.VideoConference.AFRClogFB", 32);
        *(_QWORD *)(v9 + 2840) = v62;
        VRLogfilePrintSync(v62, "MyTxTS\tDelay\tRecvKb\tBLoss\tAudioRecvPkt\tVideoRecvPkt\tYrTxTS\tOWRD\n", v63, v64, v65, v66, v67, v68, v124);
        AFRCLog_OpenBBLog((FILE **)v9, v44, 0, v69, v70, v71, v72, v73);
        v74 = 1;
      }
      else
      {
        v74 = 0;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v75 = VRTraceErrorLogLevelToCSTR();
        v76 = *v35;
        if (os_log_type_enabled(*v35, OS_LOG_TYPE_DEFAULT))
        {
          v77 = "disabled";
          *(_DWORD *)buf = 136315906;
          *(_QWORD *)&buf[4] = v75;
          v127 = 2080;
          v128 = "AFRCLog_OpenLogs";
          if (v74)
            v77 = "enabled";
          v129 = 1024;
          v130 = 834;
          v131 = 2080;
          *(_QWORD *)v132 = v77;
          _os_log_impl(&dword_1D8A54000, v76, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d ### AFRC dump %s", buf, 0x26u);
        }
      }
      *(_QWORD *)(v9 + 672) = 0;
      *(_QWORD *)(v9 + 968) = 0;
      *(_BYTE *)(v9 + 980) = 0;
      *(_QWORD *)(v9 + 984) = 0;
      *(_DWORD *)(v9 + 992) = 0;
      *(_DWORD *)(v9 + 976) = 0;
      *(_QWORD *)(v9 + 1120) = 0;
      *(_QWORD *)(v9 + 920) = 0;
      *(_QWORD *)(v9 + 912) = 0;
      *(_DWORD *)(v9 + 928) = 0;
      *(_QWORD *)(v9 + 936) = 0;
      *(_QWORD *)(v9 + 952) = 0;
      *(_QWORD *)(v9 + 944) = 0;
      *(_DWORD *)(v9 + 960) = 0;
      *(_DWORD *)(v9 + 1040) = 0;
      *(_BYTE *)(v9 + 1104) = 1;
      *(_DWORD *)(v9 + 1128) = 0;
      *(_WORD *)(v9 + 1132) = 0;
      *(_QWORD *)(v9 + 1136) = 0;
      *(_WORD *)(v9 + 1144) = 0;
      *(_QWORD *)(v9 + 1156) = 0;
      *(_QWORD *)(v9 + 1148) = 0;
      *(_OWORD *)(v9 + 1196) = 0u;
      *(_OWORD *)(v9 + 1184) = 0u;
      *(_OWORD *)(v9 + 1168) = 0u;
      *(_OWORD *)(v9 + 1216) = 0u;
      *(_OWORD *)(v9 + 1232) = 0u;
      keyExistsAndHasValidFormat = 0;
      AppIntegerValue = CFPreferencesGetAppIntegerValue(CFSTR("BWEstEnableNewEstSenderSide"), CFSTR("com.apple.VideoConference"), &keyExistsAndHasValidFormat);
      if (keyExistsAndHasValidFormat)
        _ZF = AppIntegerValue == 0;
      else
        _ZF = 0;
      v80 = !_ZF;
      *(_BYTE *)(v9 + 724) = v80;
      v81 = CFPreferencesGetAppIntegerValue(CFSTR("BWEstEnableNewEstRecvrSide"), CFSTR("com.apple.VideoConference"), &keyExistsAndHasValidFormat);
      if (keyExistsAndHasValidFormat)
        v82 = v81 == 0;
      else
        v82 = 0;
      v83 = !v82;
      *(_BYTE *)(v9 + 725) = v83;
      v84 = (double)(int)CFPreferencesGetAppIntegerValue(CFSTR("BWEstProbeInterval"), CFSTR("com.apple.VideoConference"), &keyExistsAndHasValidFormat)/ 1000000.0;
      if (!keyExistsAndHasValidFormat)
        v84 = 0.666;
      *(double *)(v9 + 864) = v84;
      v85 = CFPreferencesGetAppIntegerValue(CFSTR("BWEstLogType"), CFSTR("com.apple.VideoConference"), &keyExistsAndHasValidFormat);
      if (keyExistsAndHasValidFormat)
        v86 = v85;
      else
        v86 = 0;
      *(_DWORD *)(v9 + 1112) = v86;
      v87 = CFPreferencesGetAppIntegerValue(CFSTR("BWEstLogLevel"), CFSTR("com.apple.VideoConference"), &keyExistsAndHasValidFormat);
      if (keyExistsAndHasValidFormat)
        v88 = v87;
      else
        v88 = 0;
      g_iBWEstLogLevel = v88;
      v89 = CFPreferencesGetAppIntegerValue(CFSTR("BWEstDemoLogInterval"), CFSTR("com.apple.VideoConference"), &keyExistsAndHasValidFormat);
      if (keyExistsAndHasValidFormat)
        v90 = v89;
      else
        v90 = 1000000;
      *(_DWORD *)(v9 + 1116) = v90;
      v91 = CFPreferencesGetAppIntegerValue(CFSTR("HackUploadBW"), CFSTR("com.apple.VideoConference"), &keyExistsAndHasValidFormat);
      if (keyExistsAndHasValidFormat)
        v92 = v91 == 0;
      else
        v92 = 1;
      v93 = !v92;
      *(_BYTE *)(v9 + 1037) = v93;
      v94 = CFPreferencesGetAppIntegerValue(CFSTR("V1BWE"), CFSTR("com.apple.VideoConference"), &keyExistsAndHasValidFormat);
      if (keyExistsAndHasValidFormat)
        v95 = v94 == 0;
      else
        v95 = 1;
      v96 = !v95;
      *(_BYTE *)(v9 + 1036) = v96;
      v97 = VRTraceGetErrorLogLevelForModule();
      v98 = (_BYTE *)MEMORY[0x1E0CF2748];
      if (v97 > 7)
      {
        v99 = VRTraceErrorLogLevelToCSTR();
        v100 = *v35;
        v101 = *v35;
        if (*v98)
        {
          if (os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT))
          {
            v102 = *(unsigned __int8 *)(v9 + 1037);
            v103 = *(unsigned __int8 *)(v9 + 1036);
            *(_DWORD *)buf = 136316162;
            *(_QWORD *)&buf[4] = v99;
            v127 = 2080;
            v128 = "BWEstConfigureDefaults";
            v129 = 1024;
            v130 = 5830;
            v131 = 1024;
            *(_DWORD *)v132 = v102;
            *(_WORD *)&v132[4] = 1024;
            *(_DWORD *)&v132[6] = v103;
            _os_log_impl(&dword_1D8A54000, v100, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d HackUploadBW: %d  V1BWE: %d ", buf, 0x28u);
          }
        }
        else if (os_log_type_enabled(v101, OS_LOG_TYPE_DEBUG))
        {
          v116 = *(unsigned __int8 *)(v9 + 1037);
          v117 = *(unsigned __int8 *)(v9 + 1036);
          *(_DWORD *)buf = 136316162;
          *(_QWORD *)&buf[4] = v99;
          v127 = 2080;
          v128 = "BWEstConfigureDefaults";
          v129 = 1024;
          v130 = 5830;
          v131 = 1024;
          *(_DWORD *)v132 = v116;
          *(_WORD *)&v132[4] = 1024;
          *(_DWORD *)&v132[6] = v117;
          _os_log_debug_impl(&dword_1D8A54000, v100, OS_LOG_TYPE_DEBUG, "VCRC [%s] %s:%d HackUploadBW: %d  V1BWE: %d ", buf, 0x28u);
        }
      }
      *(_DWORD *)(v9 + 720) = 0;
      *(_BYTE *)(v9 + 1248) = (*MEMORY[0x1E0CF2740] | g_iBWEstLogLevel) != 0;
      Throttling_AFRC_Init((BOOL *)(v9 + 872));
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v104 = VRTraceErrorLogLevelToCSTR();
        v105 = *v35;
        v106 = *v35;
        if (*v98)
        {
          if (os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT))
          {
            v107 = *(unsigned __int8 *)(v9 + 725);
            v108 = *(unsigned __int8 *)(v9 + 724);
            v109 = *(_QWORD *)(v9 + 864);
            v110 = *(_DWORD *)(v9 + 1116);
            v111 = *(_DWORD *)(v9 + 1112);
            *(_DWORD *)buf = 136317186;
            *(_QWORD *)&buf[4] = v104;
            v127 = 2080;
            v128 = "BWEstInit";
            v129 = 1024;
            v130 = 5939;
            v131 = 1024;
            *(_DWORD *)v132 = v107;
            *(_WORD *)&v132[4] = 1024;
            *(_DWORD *)&v132[6] = v108;
            LOWORD(v133) = 2048;
            *(_QWORD *)((char *)&v133 + 2) = v109;
            WORD5(v133) = 1024;
            HIDWORD(v133) = v110;
            *(_WORD *)v134 = 1024;
            *(_DWORD *)&v134[2] = v111;
            v135 = 1024;
            v136 = g_iBWEstLogLevel;
            _os_log_impl(&dword_1D8A54000, v105, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d ////^^^^ Initial BWEstEnableNewst_Recvr/_Sender %d/%d  \t BWEstProbeInterval: %f  BWEstDemoLogInterval: %d  BWEstLogType: %d  BWEstLogLevel: %x \n", buf, 0x44u);
          }
        }
        else if (os_log_type_enabled(v106, OS_LOG_TYPE_DEBUG))
        {
          v118 = *(unsigned __int8 *)(v9 + 725);
          v119 = *(unsigned __int8 *)(v9 + 724);
          v120 = *(_QWORD *)(v9 + 864);
          v121 = *(_DWORD *)(v9 + 1116);
          v122 = *(_DWORD *)(v9 + 1112);
          *(_DWORD *)buf = 136317186;
          *(_QWORD *)&buf[4] = v104;
          v127 = 2080;
          v128 = "BWEstInit";
          v129 = 1024;
          v130 = 5939;
          v131 = 1024;
          *(_DWORD *)v132 = v118;
          *(_WORD *)&v132[4] = 1024;
          *(_DWORD *)&v132[6] = v119;
          LOWORD(v133) = 2048;
          *(_QWORD *)((char *)&v133 + 2) = v120;
          WORD5(v133) = 1024;
          HIDWORD(v133) = v121;
          *(_WORD *)v134 = 1024;
          *(_DWORD *)&v134[2] = v122;
          v135 = 1024;
          v136 = g_iBWEstLogLevel;
          _os_log_debug_impl(&dword_1D8A54000, v105, OS_LOG_TYPE_DEBUG, "VCRC [%s] %s:%d ////^^^^ Initial BWEstEnableNewst_Recvr/_Sender %d/%d  \t BWEstProbeInterval: %f  BWEstDemoLogInterval: %d  BWEstLogType: %d  BWEstLogLevel: %x \n", buf, 0x44u);
        }
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v112 = VRTraceErrorLogLevelToCSTR();
        v113 = *v35;
        v114 = *v35;
        if (*v98)
        {
          if (os_log_type_enabled(v114, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315906;
            *(_QWORD *)&buf[4] = v112;
            v127 = 2080;
            v128 = "BWEstInit";
            v129 = 1024;
            v130 = 5940;
            v131 = 2048;
            *(_QWORD *)v132 = v9;
            _os_log_impl(&dword_1D8A54000, v113, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d ///////////////////////AFRCCreateHandle startAFRC//////////////////////// %p", buf, 0x26u);
          }
        }
        else if (os_log_type_enabled(v114, OS_LOG_TYPE_DEBUG))
        {
          AFRCCreateHandle_cold_4();
        }
      }
      if (*(_BYTE *)(v9 + 1037) || *(_BYTE *)(v9 + 1036))
      {
        v15 = 0;
        *(_QWORD *)(v9 + 1024) = 0;
        *(_DWORD *)(v9 + 1032) = 0;
        *(_QWORD *)(v9 + 1008) = 0;
        *(_QWORD *)(v9 + 1000) = 0;
        *(_DWORD *)(v9 + 1016) = 0;
      }
      else
      {
        return 0;
      }
    }
    return v15;
  }
  v15 = 2149646339;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
  {
    VRTraceErrorLogLevelToCSTR();
    if ((VRTraceIsOSFaultDisabled() & 1) != 0)
    {
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        AFRCCreateHandle_cold_1();
    }
    else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_FAULT))
    {
      AFRCCreateHandle_cold_2();
    }
  }
  return v15;
}

BOOL ConfigureAFRCDefaults(uint64_t a1)
{
  uint64_t ForcedCapBitrate;
  uint64_t ForcedTargetBitrate;
  unsigned int AppIntegerValue;
  double v5;
  double v6;
  unsigned int v7;
  unsigned int v8;
  double v9;
  uint64_t v10;
  NSObject *v11;
  int v12;
  uint64_t v13;
  NSObject *v14;
  int v15;
  int v16;
  uint64_t v17;
  NSObject *v18;
  int v19;
  int AppBooleanValue;
  _BOOL8 result;
  Boolean keyExistsAndHasValidFormat;
  uint8_t buf[4];
  uint64_t v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  double v30;
  __int16 v31;
  double v32;
  __int16 v33;
  double v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  keyExistsAndHasValidFormat = 0;
  ForcedCapBitrate = VCTestMonitorManager_GetForcedCapBitrate();
  *(_DWORD *)(a1 + 72) = VCDefaults_GetIntValueForKey(CFSTR("forcedTxCap"), ForcedCapBitrate);
  ForcedTargetBitrate = VCTestMonitorManager_GetForcedTargetBitrate();
  *(_DWORD *)(a1 + 68) = VCDefaults_GetIntValueForKey(CFSTR("forcedTxRate"), ForcedTargetBitrate);
  AppIntegerValue = CFPreferencesGetAppIntegerValue(CFSTR("forcedPLRForAudioFEC100"), CFSTR("com.apple.VideoConference"), &keyExistsAndHasValidFormat);
  v5 = -1.0;
  v6 = -1.0;
  if (keyExistsAndHasValidFormat)
    v6 = (double)AppIntegerValue / 100.0;
  v7 = CFPreferencesGetAppIntegerValue(CFSTR("forcedPLRForAudioFEC150"), CFSTR("com.apple.VideoConference"), &keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat)
    v5 = (double)v7 / 100.0;
  v8 = CFPreferencesGetAppIntegerValue(CFSTR("forcedPLRForAudioFEC200"), CFSTR("com.apple.VideoConference"), &keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat)
    v9 = (double)v8 / 100.0;
  else
    v9 = -1.0;
  if (v6 > 0.0 && v5 > 0.0 && v9 > 0.0 && v5 >= v6 && v9 >= v5 && v9 <= 1.0)
  {
    *(double *)(a1 + 80) = v6;
    *(double *)(a1 + 88) = v5;
    *(double *)(a1 + 96) = v9;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v10 = VRTraceErrorLogLevelToCSTR();
      v11 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136316418;
        v24 = v10;
        v25 = 2080;
        v26 = "ConfigureAFRCDefaults";
        v27 = 1024;
        v28 = 5771;
        v29 = 2048;
        v30 = v6;
        v31 = 2048;
        v32 = v5;
        v33 = 2048;
        v34 = v9;
        _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Forcing Audio FEC Level 100,150,200 at PLR:(%.2f, %.2f, %.2f) from defaults", buf, 0x3Au);
      }
    }
  }
  v12 = *(_DWORD *)(a1 + 72);
  if (v12 >= 10000)
  {
    *(_DWORD *)(a1 + 20) = v12;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v13 = VRTraceErrorLogLevelToCSTR();
      v14 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v15 = *(_DWORD *)(a1 + 20);
        *(_DWORD *)buf = 136315906;
        v24 = v13;
        v25 = 2080;
        v26 = "ConfigureAFRCDefaults";
        v27 = 1024;
        v28 = 5775;
        v29 = 1024;
        LODWORD(v30) = v15;
        _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Forcing AFRC TxCap to %u from defaults", buf, 0x22u);
      }
    }
  }
  v16 = *(_DWORD *)(a1 + 68);
  if ((v16 & 0x80000000) == 0)
  {
    *(_DWORD *)(a1 + 44) = v16;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v17 = VRTraceErrorLogLevelToCSTR();
      v18 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v19 = *(_DWORD *)(a1 + 44);
        *(_DWORD *)buf = 136315906;
        v24 = v17;
        v25 = 2080;
        v26 = "ConfigureAFRCDefaults";
        v27 = 1024;
        v28 = 5779;
        v29 = 1024;
        LODWORD(v30) = v19;
        _os_log_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Forcing AFRC TxRate to %u from defaults", buf, 0x22u);
      }
    }
  }
  AppBooleanValue = CFPreferencesGetAppBooleanValue(CFSTR("rateControlAllowVideoStop"), CFSTR("com.apple.VideoConference"), &keyExistsAndHasValidFormat);
  if (!keyExistsAndHasValidFormat)
    AppBooleanValue = *(unsigned __int8 *)(a1 + 9839);
  *(_BYTE *)(a1 + 9836) = (*(_DWORD *)(a1 + 2948) | AppBooleanValue) != 0;
  result = VCDefaults_GetBoolValueForKey(CFSTR("rateControlAllowBurstyLossRampDown"), *(unsigned __int8 *)(a1 + 9838));
  *(_BYTE *)(a1 + 9837) = result;
  return result;
}

uint64_t AFRCUpdateOperatingMode(uint64_t a1, int a2, int a3, char a4)
{
  uint64_t v7;
  double v9;

  v7 = CheckInHandleDebug();
  if (!v7)
    return 2149646338;
  *(_DWORD *)(v7 + 2944) = a3;
  *(_DWORD *)(v7 + 9696) = a2;
  *(_BYTE *)(v7 + 9701) = a4;
  if (a2)
  {
    *(_DWORD *)(v7 + 40) = 0;
    *(_QWORD *)(v7 + 2464) = 0x4000000000000000;
    *(_QWORD *)(v7 + 2456) = 0x3FF0000000000000;
    *(_DWORD *)(v7 + 2480) = 0;
  }
  else
  {
    v9 = 2.0;
    if (!*(_DWORD *)(v7 + 2948))
    {
      v9 = 1.0;
      if (!*(_DWORD *)(v7 + 2952) && *(_DWORD *)(v7 + 2932) && ((*(_DWORD *)(v7 + 2940) - 2) & 0xFFFFFFFD) == 0)
        v9 = 2.0;
    }
    *(double *)(v7 + 2464) = v9;
    *(_DWORD *)(v7 + 40) = 0;
    *(_DWORD *)(v7 + 2480) = 1;
    if (*(_DWORD *)(v7 + 1400) != 1 && (*(_BYTE *)(v7 + 1396) & 2) == 0)
      *(_QWORD *)(v7 + 1396) = 0x100000005;
  }
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCCloseHandle()
{
  uint64_t v0;
  uint64_t v1;
  __int128 v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  FILE *v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  CFStringRef v23;
  uint64_t v24;
  int ErrorLogLevelForModule;
  _BYTE *v26;
  NSObject **v27;
  uint64_t v28;
  NSObject *v29;
  NSObject *v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  double v37;
  int v38;
  double v39;
  double v40;
  double v41;
  uint64_t v42;
  NSObject *v43;
  NSObject *v44;
  uint64_t v45;
  int v46;
  int v47;
  double v48;
  double v49;
  uint64_t v50;
  int v51;
  double v52;
  double v53;
  double v54;
  uint64_t v55;
  NSObject *v56;
  NSObject *v57;
  int v58;
  double v59;
  int v60;
  double v61;
  int v62;
  int v63;
  double v64;
  int v65;
  int v66;
  uint64_t v67;
  int v68;
  int v69;
  double v70;
  double v71;
  uint64_t v72;
  int v73;
  int v74;
  double v75;
  int v76;
  double v77;
  int v78;
  int v79;
  double v80;
  int v81;
  int v82;
  char *cStr;
  char v84[16];
  _BYTE buf[96];
  __int128 v86;
  __int128 v87;
  __int16 v88;
  double v89;
  uint64_t v90;

  v90 = *MEMORY[0x1E0C80C00];
  v0 = CheckInHandleDebug();
  if (!v0)
    return 2149646338;
  v1 = v0;
  CheckOutHandleDebug();
  reportingUnregisterPeriodicTask();
  if (*(_QWORD *)(v1 + 2832) || *(_QWORD *)(v1 + 2840) || *(_QWORD *)(v1 + 2848))
  {
    *(_QWORD *)&v2 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v87 = v2;
    *(_OWORD *)&buf[80] = v2;
    v86 = v2;
    *(_OWORD *)&buf[48] = v2;
    *(_OWORD *)&buf[64] = v2;
    *(_OWORD *)&buf[16] = v2;
    *(_OWORD *)&buf[32] = v2;
    *(_OWORD *)buf = v2;
    micro();
    cStr = (char *)0xAAAAAAAAAAAAAAAALL;
    VRLogfileGetTimestamp(buf, 0x80u);
    memset(v84, 170, 12);
    __sprintf_chk(v84, 0, 0xCuLL, "%010u", *(_DWORD *)(v1 + 2824));
    v9 = reportingGetUploadFlag()
       ? openLogDump(0, (uint64_t)v84, 0, (uint64_t)"AFRC-DashBoard.dump", 0, &cStr)
       : 0;
    VRLogfilePrintSync(*(FILE ***)(v1 + 2832), "%s\t%8.3f\tEndOfFile\n", v3, v4, v5, v6, v7, v8, (char)buf);
    VRLogfileGetFilePointer(*(_QWORD *)(v1 + 2832));
    AFRCLog_TailFile((uint64_t)v9);
    VRLogfileFree((uint64_t *)(v1 + 2832));
    VRLogfilePrintSync(*(FILE ***)(v1 + 2840), "%s\t%8.3f\tEndOfFile\n", v11, v12, v13, v14, v15, v16, (char)buf);
    VRLogfileGetFilePointer(*(_QWORD *)(v1 + 2840));
    AFRCLog_TailFile((uint64_t)v9);
    VRLogfileFree((uint64_t *)(v1 + 2840));
    VRLogfilePrintSync(*(FILE ***)(v1 + 2848), "%s\t%8.3f\tEndOfFile\n", v17, v18, v19, v20, v21, v22, (char)buf);
    VRLogfileGetFilePointer(*(_QWORD *)(v1 + 2848));
    AFRCLog_TailFile((uint64_t)v9);
    VRLogfileFree((uint64_t *)(v1 + 2848));
    pthread_mutex_lock(&g_fpStallModeDumpOpenCloseLock);
    VRLogfileFree(&g_fpStallModeDump);
    pthread_mutex_unlock(&g_fpStallModeDumpOpenCloseLock);
    if (v9)
    {
      fclose(v9);
      v23 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], cStr, 0x8000100u);
      reportingUploadFileWithName();
      if (v23)
        CFRelease(v23);
      free(cStr);
    }
  }
  RateMonitorDestroy(*(void ***)(v1 + 9768));
  RateMonitorDestroy(*(void ***)(v1 + 9784));
  if (*(_QWORD *)v1)
    CFRelease(*(CFTypeRef *)v1);
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 2864));
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 2560));
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 2744));
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 280));
  if (g_iBWEstLogLevel)
  {
    ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    v26 = (_BYTE *)MEMORY[0x1E0CF2748];
    v27 = (NSObject **)MEMORY[0x1E0CF2758];
    if (ErrorLogLevelForModule >= 8)
    {
      v28 = VRTraceErrorLogLevelToCSTR();
      v29 = *v27;
      v30 = *v27;
      if (*v26)
      {
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
        {
          v31 = *(_DWORD *)(v1 + 1128);
          v32 = *(_DWORD *)(v1 + 1136);
          v33 = *(unsigned __int16 *)(v1 + 1132);
          v34 = *(_DWORD *)(v1 + 1140);
          v35 = *(_DWORD *)(v1 + 1148);
          v36 = *(unsigned __int16 *)(v1 + 1144);
          v37 = *(double *)(v1 + 1152);
          v38 = *(_DWORD *)(v1 + 1160);
          *(_DWORD *)buf = 136317698;
          *(_QWORD *)&buf[4] = v28;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "BWEstUninit";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 5966;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = v31;
          *(_WORD *)&buf[34] = 1024;
          *(_DWORD *)&buf[36] = v32;
          *(_WORD *)&buf[40] = 1024;
          *(_DWORD *)&buf[42] = v33;
          *(_WORD *)&buf[46] = 1024;
          *(_DWORD *)&buf[48] = v34;
          *(_WORD *)&buf[52] = 1024;
          *(_DWORD *)&buf[54] = v35;
          *(_WORD *)&buf[58] = 1024;
          *(_DWORD *)&buf[60] = v36;
          *(_WORD *)&buf[64] = 2048;
          *(double *)&buf[66] = v37 / (double)v38;
          *(_WORD *)&buf[74] = 1024;
          *(_DWORD *)&buf[76] = v38;
          _os_log_impl(&dword_1D8A54000, v29, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d ////////////////// Loss event reports //////////////////////////\n///// Video: %d/%d\tlast seq#: %d \t\t Audio: %d/%d last seq#: %d\n///// Avg. BW: %f  \t  with %d reports\n///////////////////////////////////////////////////////\n", buf, 0x50u);
        }
      }
      else if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
      {
        AFRCCloseHandle_cold_1();
      }
    }
    v39 = *(double *)(v1 + 1192);
    v40 = *(double *)(v1 + 1184);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v41 = v39 - v40;
      v42 = VRTraceErrorLogLevelToCSTR();
      v43 = *v27;
      v44 = *v27;
      if (*v26)
      {
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
        {
          v45 = *(_QWORD *)(v1 + 1168);
          v46 = *(_DWORD *)(v1 + 1136);
          v47 = (int)((double)v45 / (double)v46);
          v48 = (double)v45 * 0.0009765625;
          v49 = (double)(8 * v45) / v41;
          v50 = *(_QWORD *)(v1 + 1176);
          v51 = *(_DWORD *)(v1 + 1148);
          *(_DWORD *)buf = 136318466;
          *(_QWORD *)&buf[4] = v42;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "BWEstUninit";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 5975;
          *(_WORD *)&buf[28] = 2048;
          *(double *)&buf[30] = v41;
          *(_WORD *)&buf[38] = 2048;
          *(double *)&buf[40] = v48;
          *(_WORD *)&buf[48] = 1024;
          *(_DWORD *)&buf[50] = v46;
          *(_WORD *)&buf[54] = 1024;
          *(_DWORD *)&buf[56] = v47;
          *(_WORD *)&buf[60] = 2048;
          *(double *)&buf[62] = v49;
          *(_WORD *)&buf[70] = 2048;
          *(double *)&buf[72] = (double)v46 / v41;
          *(_WORD *)&buf[80] = 2048;
          *(double *)&buf[82] = (double)v50 * 0.0009765625;
          *(_WORD *)&buf[90] = 1024;
          *(_DWORD *)&buf[92] = v51;
          LOWORD(v86) = 1024;
          *(_DWORD *)((char *)&v86 + 2) = (int)((double)v50 / (double)v51);
          WORD3(v86) = 2048;
          *((double *)&v86 + 1) = (double)(8 * v50) / v41;
          LOWORD(v87) = 2048;
          *(double *)((char *)&v87 + 2) = (double)v51 / v41;
          _os_log_impl(&dword_1D8A54000, v43, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d //////\n////// In %.1f seconds: Video: %f KB/%d = %d B  avg. %.1f kbits/s  %.1f pkts/s \n//////                  Audio: %f KB/%d = %d B  avg. %.1f kbits/s  %.1f pkts/s \n", buf, 0x7Au);
        }
      }
      else if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
      {
        v67 = *(_QWORD *)(v1 + 1168);
        v68 = *(_DWORD *)(v1 + 1136);
        v69 = (int)((double)v67 / (double)v68);
        v70 = (double)v67 * 0.0009765625;
        v71 = (double)(8 * v67) / v41;
        v72 = *(_QWORD *)(v1 + 1176);
        v73 = *(_DWORD *)(v1 + 1148);
        *(_DWORD *)buf = 136318466;
        *(_QWORD *)&buf[4] = v42;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "BWEstUninit";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 5975;
        *(_WORD *)&buf[28] = 2048;
        *(double *)&buf[30] = v41;
        *(_WORD *)&buf[38] = 2048;
        *(double *)&buf[40] = v70;
        *(_WORD *)&buf[48] = 1024;
        *(_DWORD *)&buf[50] = v68;
        *(_WORD *)&buf[54] = 1024;
        *(_DWORD *)&buf[56] = v69;
        *(_WORD *)&buf[60] = 2048;
        *(double *)&buf[62] = v71;
        *(_WORD *)&buf[70] = 2048;
        *(double *)&buf[72] = (double)v68 / v41;
        *(_WORD *)&buf[80] = 2048;
        *(double *)&buf[82] = (double)v72 * 0.0009765625;
        *(_WORD *)&buf[90] = 1024;
        *(_DWORD *)&buf[92] = v73;
        LOWORD(v86) = 1024;
        *(_DWORD *)((char *)&v86 + 2) = (int)((double)v72 / (double)v73);
        WORD3(v86) = 2048;
        *((double *)&v86 + 1) = (double)(8 * v72) / v41;
        LOWORD(v87) = 2048;
        *(double *)((char *)&v87 + 2) = (double)v73 / v41;
        _os_log_debug_impl(&dword_1D8A54000, v43, OS_LOG_TYPE_DEBUG, "VCRC [%s] %s:%d //////\n////// In %.1f seconds: Video: %f KB/%d = %d B  avg. %.1f kbits/s  %.1f pkts/s \n//////                  Audio: %f KB/%d = %d B  avg. %.1f kbits/s  %.1f pkts/s \n", buf, 0x7Au);
      }
    }
    v52 = *(double *)(v1 + 1224);
    v53 = *(double *)(v1 + 1216);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v54 = v52 - v53;
      v55 = VRTraceErrorLogLevelToCSTR();
      v56 = *v27;
      v57 = *v27;
      if (*v26)
      {
        if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
        {
          v58 = *(_DWORD *)(v1 + 1208);
          v59 = *(double *)(v1 + 1200) / (double)v58;
          v60 = *(_DWORD *)(v1 + 1232);
          v61 = (double)v60 * 0.0009765625;
          v62 = *(_DWORD *)(v1 + 1236);
          v63 = (int)((double)v60 / (double)v62);
          v64 = (double)(8 * v60) / v54;
          v65 = *(_DWORD *)(v1 + 1240);
          v66 = *(_DWORD *)(v1 + 1244);
          *(_DWORD *)buf = 136318978;
          *(_QWORD *)&buf[4] = v55;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "BWEstUninit";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 5987;
          *(_WORD *)&buf[28] = 2048;
          *(double *)&buf[30] = v59;
          *(_WORD *)&buf[38] = 1024;
          *(_DWORD *)&buf[40] = v58;
          *(_WORD *)&buf[44] = 2048;
          *(double *)&buf[46] = v54;
          *(_WORD *)&buf[54] = 2048;
          *(double *)&buf[56] = v61;
          *(_WORD *)&buf[64] = 1024;
          *(_DWORD *)&buf[66] = v62;
          *(_WORD *)&buf[70] = 1024;
          *(_DWORD *)&buf[72] = v63;
          *(_WORD *)&buf[76] = 2048;
          *(double *)&buf[78] = v64;
          *(_WORD *)&buf[86] = 2048;
          *(double *)&buf[88] = (double)v62 / v54;
          LOWORD(v86) = 2048;
          *(double *)((char *)&v86 + 2) = (double)v65 * 0.0009765625;
          WORD5(v86) = 1024;
          HIDWORD(v86) = v66;
          LOWORD(v87) = 1024;
          *(_DWORD *)((char *)&v87 + 2) = (int)((double)v65 / (double)v66);
          WORD3(v87) = 2048;
          *((double *)&v87 + 1) = (double)(8 * v65) / v54;
          v88 = 2048;
          v89 = (double)v66 / v54;
          _os_log_impl(&dword_1D8A54000, v56, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d \n///// Avg. BW (ORG Scheme): %f  \t  with %d reports\n////// In %.1f seconds: Video: %f KB/%d = %d B  avg. %.1f kbits/s  %.1f pkts/s \n//////                  Audio: %f KB/%d = %d B  avg. %.1f kbits/s  %.1f pkts/s \n///////////////////////////////////////////////////////\n", buf, 0x8Au);
        }
      }
      else if (os_log_type_enabled(v57, OS_LOG_TYPE_DEBUG))
      {
        v74 = *(_DWORD *)(v1 + 1208);
        v75 = *(double *)(v1 + 1200) / (double)v74;
        v76 = *(_DWORD *)(v1 + 1232);
        v77 = (double)v76 * 0.0009765625;
        v78 = *(_DWORD *)(v1 + 1236);
        v79 = (int)((double)v76 / (double)v78);
        v80 = (double)(8 * v76) / v54;
        v81 = *(_DWORD *)(v1 + 1240);
        v82 = *(_DWORD *)(v1 + 1244);
        *(_DWORD *)buf = 136318978;
        *(_QWORD *)&buf[4] = v55;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "BWEstUninit";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 5987;
        *(_WORD *)&buf[28] = 2048;
        *(double *)&buf[30] = v75;
        *(_WORD *)&buf[38] = 1024;
        *(_DWORD *)&buf[40] = v74;
        *(_WORD *)&buf[44] = 2048;
        *(double *)&buf[46] = v54;
        *(_WORD *)&buf[54] = 2048;
        *(double *)&buf[56] = v77;
        *(_WORD *)&buf[64] = 1024;
        *(_DWORD *)&buf[66] = v78;
        *(_WORD *)&buf[70] = 1024;
        *(_DWORD *)&buf[72] = v79;
        *(_WORD *)&buf[76] = 2048;
        *(double *)&buf[78] = v80;
        *(_WORD *)&buf[86] = 2048;
        *(double *)&buf[88] = (double)v78 / v54;
        LOWORD(v86) = 2048;
        *(double *)((char *)&v86 + 2) = (double)v81 * 0.0009765625;
        WORD5(v86) = 1024;
        HIDWORD(v86) = v82;
        LOWORD(v87) = 1024;
        *(_DWORD *)((char *)&v87 + 2) = (int)((double)v81 / (double)v82);
        WORD3(v87) = 2048;
        *((double *)&v87 + 1) = (double)(8 * v81) / v54;
        v88 = 2048;
        v89 = (double)v82 / v54;
        _os_log_debug_impl(&dword_1D8A54000, v56, OS_LOG_TYPE_DEBUG, "VCRC [%s] %s:%d \n///// Avg. BW (ORG Scheme): %f  \t  with %d reports\n////// In %.1f seconds: Video: %f KB/%d = %d B  avg. %.1f kbits/s  %.1f pkts/s \n//////                  Audio: %f KB/%d = %d B  avg. %.1f kbits/s  %.1f pkts/s \n///////////////////////////////////////////////////////\n", buf, 0x8Au);
      }
    }
  }
  VCPacketFilterGetCMBaseObject(v1 + 872, v24);
  free((void *)v1);
  return 0;
}

uint64_t AFRCSetTxCap(uint64_t a1, unsigned int a2)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  NSObject *v9;
  int v10;
  int v11;
  unsigned int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  int v18;
  uint64_t v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  __int16 v26;
  unsigned int v27;
  uint64_t v28;

  v2 = a2;
  v28 = *MEMORY[0x1E0C80C00];
  if (!a2 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      AFRCSetTxCap_cold_1();
  }
  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149646338;
  v4 = v3;
  v5 = *(_DWORD *)(v3 + 72);
  if (v5 >= 10000)
  {
    if (*(_DWORD *)(v3 + 2816))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v6 = VRTraceErrorLogLevelToCSTR();
        v7 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v18 = 136315906;
          v19 = v6;
          v20 = 2080;
          v21 = "AFRCSetTxCap";
          v22 = 1024;
          v23 = 1594;
          v24 = 1024;
          v25 = v5;
          _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d AFRC: Forcing AFRC TxCap to %u from defaults", (uint8_t *)&v18, 0x22u);
        }
      }
    }
    v2 = v5;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v8 = VRTraceErrorLogLevelToCSTR();
    v9 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v10 = *(_DWORD *)(v4 + 20);
      v18 = 136316162;
      v19 = v8;
      v20 = 2080;
      v21 = "AFRCSetTxCap";
      v22 = 1024;
      v23 = 1597;
      v24 = 1024;
      v25 = v10;
      v26 = 1024;
      v27 = v2;
      _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d ### AFRCSetTxCap: (%u->%u)", (uint8_t *)&v18, 0x28u);
    }
  }
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 2560));
  *(_DWORD *)(v4 + 20) = v2;
  *(_DWORD *)(v4 + 24) = v2;
  v11 = *(_DWORD *)(v4 + 28);
  v12 = g_adwTxRateTiers[v11];
  if (v12 <= v2)
  {
    v14 = *(_DWORD *)(v4 + 28);
  }
  else
  {
    v13 = *(int *)(v4 + 40);
    if (v11 >= (int)v13)
      v14 = *(_DWORD *)(v4 + 40);
    else
      v14 = *(_DWORD *)(v4 + 28);
    if (v11 > (int)v13)
    {
      v15 = v11;
      v16 = v11 - 1;
      while (1)
      {
        *(_DWORD *)(v4 + 28) = v16;
        v12 = g_adwTxRateTiers[v15 - 1];
        if (v12 <= v2)
          break;
        --v15;
        --v16;
        if (v15 <= v13)
          goto LABEL_27;
      }
      v14 = v16;
    }
  }
LABEL_27:
  *(_DWORD *)(v4 + 36) = v14;
  *(_DWORD *)(v4 + 44) = v12;
  pthread_mutex_unlock((pthread_mutex_t *)(v4 + 2560));
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCGetLastEchoedMyTxTS(uint64_t a1, _DWORD *a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149646338;
  if (a2)
    *a2 = *(_DWORD *)(v3 + 260);
  CheckOutHandleDebug();
  return 0;
}

void UpdateRxEstimate(uint64_t a1, int a2, int a3, int *a4, int a5, double a6, double a7, double a8)
{
  int v16;
  int v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  unsigned int v23;
  double v24;
  int v25;
  _BOOL4 v26;
  _BOOL4 v27;
  _BOOL4 v28;
  _BOOL4 v29;
  double v30;
  uint64_t v31;
  NSObject *v32;
  NSObject *v33;
  BOOL v34;
  double v35;
  double v36;
  int v37;
  uint64_t v38;
  int *v39;
  int v40;
  double v41;
  double v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  double v49;
  int v50;
  uint64_t v51;
  char v52;
  double v53;
  char v54;
  int v55;
  int v56;
  uint64_t v57;
  __int16 v58;
  const char *v59;
  __int16 v60;
  int v61;
  __int16 v62;
  int v63;
  __int16 v64;
  double v65;
  __int16 v66;
  int v67;
  uint64_t v68;

  v68 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 316))
  {
    UpdateRxEstimate_v1(a1, a2, a3, a4, a6, a7, a8);
    *(_QWORD *)(a1 + 224) = *(_QWORD *)(a1 + 280);
    return;
  }
  if (*(_BYTE *)(a1 + 317))
  {
    v56 = -1;
    UpdateRxEstimate_v1(a1, a2, a3, &v56, a6, a7, a8);
  }
  v16 = *(_DWORD *)(a1 + 8);
  if (v16 == 2)
    v17 = 0;
  else
    v17 = 3;
  v18 = *(double *)(a1 + 224);
  if (v18 != 0.0)
  {
    if (!a2 || a3 <= 249)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v31 = VRTraceErrorLogLevelToCSTR();
        v32 = *MEMORY[0x1E0CF2758];
        v33 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
          {
            v56 = 136316418;
            v57 = v31;
            v58 = 2080;
            v59 = "UpdateRxEstimate";
            v60 = 1024;
            v61 = 1909;
            v62 = 1024;
            v63 = a3;
            v64 = 2048;
            v65 = a7;
            v66 = 1024;
            v67 = a2;
            _os_log_impl(&dword_1D8A54000, v32, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d *!*!*!* UpdateRxEstimate: too short Seq; ------ dBWD: 0 (%d/%f/%d) ",
              (uint8_t *)&v56,
              0x32u);
          }
        }
        else if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
        {
          v56 = 136316418;
          v57 = v31;
          v58 = 2080;
          v59 = "UpdateRxEstimate";
          v60 = 1024;
          v61 = 1909;
          v62 = 1024;
          v63 = a3;
          v64 = 2048;
          v65 = a7;
          v66 = 1024;
          v67 = a2;
          _os_log_debug_impl(&dword_1D8A54000, v32, OS_LOG_TYPE_DEBUG, "VCRC [%s] %s:%d *!*!*!* UpdateRxEstimate: too short Seq; ------ dBWD: 0 (%d/%f/%d) ",
            (uint8_t *)&v56,
            0x32u);
        }
      }
      return;
    }
    if (dbl_1D9109430[v16 == 2] <= a7)
    {
      *(_DWORD *)(a1 + 256) = 0;
    }
    else
    {
      v25 = *(_DWORD *)(a1 + 256);
      if (v25 < v17)
        *(_DWORD *)(a1 + 256) = ++v25;
      if (v25 < v17)
        return;
    }
  }
  if (a6 <= 0.0)
    return;
  v19 = 400000.0;
  if (a5)
    v19 = 800000.0;
  if (v16 != 2)
    v19 = 5000000.0;
  if (v19 >= a6)
    v20 = a6;
  else
    v20 = v19;
  *(double *)(a1 + 432) = *(double *)(a1 + 432) + a6;
  ++*(_DWORD *)(a1 + 440);
  if (v16 == 2)
  {
    if (!*(_BYTE *)(a1 + 13))
    {
      v35 = v19 * 0.5;
      if (v20 <= v19 * 0.5)
        v35 = v20;
      v36 = v35 + *(double *)(a1 + 232);
      *(double *)(a1 + 232) = v36;
      v37 = *(_DWORD *)(a1 + 240);
      *(_DWORD *)(a1 + 240) = v37 + 1;
      if (v37 > 8 || a8 - *(double *)(a1 + 248) >= 7.0)
      {
        *(_BYTE *)(a1 + 13) = 1;
        *(double *)(a1 + 224) = v36 / (double)(v37 + 1);
        *(_QWORD *)(a1 + 248) = 0;
        *(_DWORD *)(a1 + 240) = 0;
      }
      return;
    }
    v21 = 7.0;
    v22 = 10.0;
    v23 = 6;
    v24 = 100000.0;
  }
  else
  {
    if (v16 == 1)
      v23 = 4;
    else
      v23 = 3;
    v24 = 0.0;
    v22 = 4.0;
    if (v16 != 1)
      v22 = 0.0;
    v21 = v22;
  }
  v26 = v20 <= v18 * 0.5;
  if (v18 - v20 > 200000.0)
    v26 = 1;
  v27 = v20 - v18 > 200000.0 || v20 >= v18 * 1.5;
  v28 = v18 - v20 > v24 && v26;
  v29 = v20 - v18 > v24 && v27;
  if (v18 == 0.0)
  {
    v30 = 100000.0;
    if (v20 >= 100000.0)
      v30 = v20;
    *(double *)(a1 + 224) = v30;
    *a4 = 0;
    return;
  }
  if (!v28 && !v29)
  {
    if (v16 == 2)
    {
      v38 = *(unsigned int *)(a1 + 136);
      if ((int)v38 >= 1)
      {
        v39 = (int *)(a1 + 16);
        do
        {
          v40 = *v39++;
          v18 = (double)v40 * 0.05 + v18 * 0.95;
          --v38;
        }
        while (v38);
        *(_DWORD *)(a1 + 136) = 0;
      }
      v41 = v20 * 0.075;
      v42 = 0.925;
    }
    else
    {
      v41 = v20 * 0.1;
      v42 = 0.9;
    }
    *(double *)(a1 + 224) = v41 + v18 * v42;
    *(_DWORD *)(a1 + 240) = 0;
    *(_QWORD *)(a1 + 232) = 0;
    v45 = 1;
    goto LABEL_108;
  }
  if ((v16 - 1) > 1)
  {
    v34 = 0;
  }
  else
  {
    if (*(int *)(a1 + 240) < 0)
      v22 = v21;
    v34 = a8 - *(double *)(a1 + 248) < v22;
  }
  if (v28)
  {
    v43 = *(_DWORD *)(a1 + 240);
    if (v43 < 0)
    {
      v44 = v43 - 1;
    }
    else
    {
      *(_QWORD *)(a1 + 232) = 0;
      *(double *)(a1 + 248) = a8;
      v44 = -1;
    }
    *(_DWORD *)(a1 + 240) = v44;
    v48 = -10;
  }
  else
  {
    if (!v29)
      goto LABEL_86;
    v46 = *(_DWORD *)(a1 + 240);
    if (v46 <= 0)
    {
      *(_QWORD *)(a1 + 232) = 0;
      *(double *)(a1 + 248) = a8;
      v47 = 1;
    }
    else
    {
      v47 = v46 + 1;
    }
    *(_DWORD *)(a1 + 240) = v47;
    v48 = 10;
  }
  *a4 = v48;
LABEL_86:
  v49 = v20 + *(double *)(a1 + 232);
  *(double *)(a1 + 232) = v49;
  v50 = *(_DWORD *)(a1 + 240);
  if (v50 < 0)
    v50 = -v50;
  if (v16 == 2)
  {
    v51 = *(int *)(a1 + 136);
    if ((int)v51 <= 29)
    {
      *(_DWORD *)(a1 + 4 * v51 + 16) = (int)v20;
      ++*(_DWORD *)(a1 + 136);
    }
    v52 = v50 < v23 || v34;
    if ((v52 & 1) == 0)
    {
      v53 = v49 / (double)v50;
      if ((*(_DWORD *)(a1 + 240) & 0x80000000) == 0)
        v53 = v53 * 0.9 + v18 * 0.1;
      goto LABEL_102;
    }
  }
  else
  {
    v54 = v50 < v23 || v34;
    if ((v54 & 1) == 0)
    {
      v53 = v49 / (double)v50;
LABEL_102:
      *(double *)(a1 + 224) = v53;
      *(_DWORD *)(a1 + 240) = 0;
      *(_QWORD *)(a1 + 232) = 0;
      if (*a4 == -10)
        v55 = -100;
      else
        v55 = 200;
      if (*a4 == 10)
        v45 = 100;
      else
        v45 = v55;
LABEL_108:
      *a4 = v45;
    }
  }
}

uint64_t UpdateRxEstimate_v1(uint64_t result, int a2, int a3, int *a4, double a5, double a6, double a7)
{
  double v8;
  double v9;
  _BOOL4 v10;
  _BOOL4 v11;
  int v12;
  double v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  double v20;
  int v21;
  int v22;

  v8 = *(double *)(result + 280);
  if (v8 != 0.0)
  {
    if (!a2 || a3 < 250)
      return result;
    if (a6 >= 0.008)
    {
      *(_DWORD *)(result + 312) = 0;
    }
    else
    {
      v14 = *(_DWORD *)(result + 312);
      if (v14 <= 2)
      {
        *(_DWORD *)(result + 312) = v14 + 1;
        if (v14 != 2)
          return result;
      }
    }
  }
  if (a5 <= 0.0)
    return result;
  v9 = 2300000.0;
  if (a5 <= 2300000.0)
    v9 = a5;
  v10 = v9 <= v8 * 0.5;
  if (v8 - v9 > 200000.0)
    v10 = 1;
  v11 = v9 >= v8 * 1.5;
  if (v9 - v8 > 200000.0)
    v11 = 1;
  if (v8 == 0.0)
  {
    v12 = 0;
    v13 = 100000.0;
    if (v9 >= 100000.0)
      v13 = v9;
    *(double *)(result + 280) = v13;
    goto LABEL_43;
  }
  if (!v10 && !v11)
  {
    *(double *)(result + 280) = v9 * 0.1 + v8 * 0.9;
    *(_DWORD *)(result + 296) = 0;
    *(_QWORD *)(result + 288) = 0;
    v12 = 1;
LABEL_43:
    *a4 = v12;
    return result;
  }
  if (v10)
  {
    v15 = *(_DWORD *)(result + 296);
    if (v15 < 0)
    {
      v16 = v15 - 1;
    }
    else
    {
      *(_QWORD *)(result + 288) = 0;
      *(double *)(result + 304) = a7;
      v16 = -1;
    }
    *(_DWORD *)(result + 296) = v16;
    v19 = -10;
  }
  else
  {
    if (!v11)
      goto LABEL_34;
    v17 = *(_DWORD *)(result + 296);
    if (v17 <= 0)
    {
      *(_QWORD *)(result + 288) = 0;
      *(double *)(result + 304) = a7;
      v18 = 1;
    }
    else
    {
      v18 = v17 + 1;
    }
    *(_DWORD *)(result + 296) = v18;
    v19 = 10;
  }
  *a4 = v19;
LABEL_34:
  v20 = v9 + *(double *)(result + 288);
  *(double *)(result + 288) = v20;
  v21 = *(_DWORD *)(result + 296);
  if (v21 < 0)
    v21 = -v21;
  if (v21 >= 3)
  {
    *(double *)(result + 280) = v20 / (double)v21;
    *(_DWORD *)(result + 296) = 0;
    *(_QWORD *)(result + 288) = 0;
    if (*a4 == -10)
      v22 = -100;
    else
      v22 = 200;
    if (*a4 == 10)
      v12 = 100;
    else
      v12 = v22;
    goto LABEL_43;
  }
  return result;
}

uint64_t AFRCCalcRxEstimate(double a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, int a8)
{
  uint64_t v14;
  uint64_t v15;
  pthread_mutex_t *v16;
  int v17;
  char **p_name;
  int v19;
  double v20;
  double v21;
  double v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  int v32;
  uint64_t v33;
  int v34;
  int ErrorLogLevelForModule;
  uint64_t v36;
  NSObject *v37;
  NSObject *v38;
  int v39;
  int v40;
  NSObject *v41;
  BOOL v43;
  uint64_t v44;
  NSObject *v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  double v51;
  double v52;
  double v53;
  double v54;
  double v55;
  pthread_mutex_t *v56;
  uint64_t v57;
  NSObject *v58;
  int v59;
  uint64_t v60;
  int v61;
  uint64_t v62;
  int v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  uint64_t v67;
  __int128 v68;
  _QWORD *v69;
  double *v70;
  double v71;
  double v72;
  int v73;
  double *v74;
  uint64_t v75;
  double v76;
  int v77;
  double v78;
  int v79;
  double v80;
  double v81;
  pthread_mutex_t *v82;
  int v83;
  double v84;
  double v85;
  int v87;
  int v88;
  int v89;
  int v90;
  double v91;
  double v92;
  double v93;
  int v94;
  _DWORD *v95;
  int v96;
  uint64_t v97;
  NSObject *v98;
  NSObject *v99;
  const char *v100;
  int v101;
  uint64_t v102;
  NSObject *v103;
  NSObject *v104;
  int v105;
  const char *v106;
  NSObject *v107;
  uint32_t v108;
  uint64_t v109;
  NSObject *v110;
  int v111;
  uint64_t v112;
  NSObject *v113;
  NSObject *v114;
  int v115;
  uint64_t v116;
  NSObject *v117;
  NSObject *v118;
  const char *v119;
  uint64_t v120;
  NSObject *v121;
  int v122;
  const char *v123;
  NSObject *v124;
  uint32_t v125;
  const char *v126;
  const char *v127;
  int v128;
  unsigned int v129;
  double v130;
  int v131;
  int v132;
  int v133;
  pthread_mutex_t *v134;
  int v135;
  int v136;
  char v138[1024];
  uint8_t buf[4];
  uint64_t v140;
  __int16 v141;
  const char *v142;
  __int16 v143;
  int v144;
  __int16 v145;
  double v146;
  __int16 v147;
  int v148;
  __int16 v149;
  int v150;
  __int16 v151;
  _BYTE *v152;
  _BYTE v153[257];
  _BYTE v154[31];
  char v155[24];
  uint64_t v156;

  v156 = *MEMORY[0x1E0C80C00];
  v14 = CheckInHandleDebug();
  if (!v14)
    return 2149646338;
  v15 = v14;
  v16 = (pthread_mutex_t *)(v14 + 280);
  pthread_mutex_lock((pthread_mutex_t *)(v14 + 280));
  bzero(v138, 0x400uLL);
  if (!*(_BYTE *)(v15 + 721))
  {
    v43 = 1;
    goto LABEL_94;
  }
  if (!*(_BYTE *)(v15 + 980))
  {
    v17 = a8 - 1;
    if (!a7)
      v17 = a4;
    *(_DWORD *)(v15 + 984) = v17;
    *(_DWORD *)(v15 + 1256) = a4 - 1;
    *(_DWORD *)(v15 + 1260) = a4 - 1;
    *(double *)(v15 + 1264) = a1;
    *(_DWORD *)(v15 + 1356) = 0;
    *(_QWORD *)(v15 + 1272) = 0;
    *(_BYTE *)(v15 + 733) = 0;
    *(double *)(v15 + 968) = a1;
    *(_DWORD *)(v15 + 960) = 0;
    *(_DWORD *)(v15 + 856) = 0;
    *(_BYTE *)(v15 + 980) = 1;
  }
  p_name = (char **)(&OBJC_PROTOCOL___VCMediaStreamGroupDelegate + 8);
  if (*(_BYTE *)(v15 + 1248))
  {
    v19 = *(_DWORD *)(v15 + 1256);
    if (v19 == (_DWORD)a4 || v19 == *(_DWORD *)(v15 + 1260))
    {
LABEL_44:
      if ((_DWORD)a3 == 1)
      {
        v48 = *(_DWORD *)(v15 + 1356);
        if (!v48)
          *(double *)(v15 + 1360) = a1;
        *(double *)(v15 + 1368) = a1;
        *(_DWORD *)(v15 + 1356) = v48 + a6;
        *(_BYTE *)(v15 + 1376) = a7;
        *(_DWORD *)(v15 + 1256) = a4;
      }
      goto LABEL_48;
    }
    v20 = *(double *)(v15 + 944);
    v21 = *(double *)(v15 + 1368) - *(double *)(v15 + 1360);
    v22 = 0.0;
    if (v20 > 0.0)
      v22 = (double)(8 * *(_DWORD *)(v15 + 1356)) / v20;
    if (v22 > v21)
      v21 = v22;
    if (v21 >= 0.1)
    {
      v23 = *(int *)(v15 + 1272);
      if ((int)v23 <= 14)
      {
        v24 = v15 + 1256 + 2 * v23;
        *(_WORD *)(v24 + 24) = *(_DWORD *)(v15 + 1356);
        *(_WORD *)(v24 + 54) = (int)(v21 * 1000.0);
        *(_BYTE *)(v15 + 1256 + v23 + 84) = *(_BYTE *)(v15 + 1376);
        p_name = (char **)(&OBJC_PROTOCOL___VCMediaStreamGroupDelegate + 8);
      }
      *(_DWORD *)(v15 + 1272) = v23 + 1;
    }
    ++*(_DWORD *)(v15 + 1276);
    if (a1 - *(double *)(v15 + 1264) <= 5.0)
    {
LABEL_43:
      *(_DWORD *)(v15 + 1260) = v19;
      *(_DWORD *)(v15 + 1356) = 0;
      goto LABEL_44;
    }
    v25 = *(_DWORD *)(v15 + 1272);
    if (v25 < 1)
    {
LABEL_42:
      *(_DWORD *)(v15 + 1276) = 0;
      *(double *)(v15 + 1264) = a1;
      goto LABEL_43;
    }
    v134 = v16;
    v135 = a6;
    v26 = 0;
    memset(v155, 170, 18);
    *(_QWORD *)&v27 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v27 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)v154 = v27;
    *(_OWORD *)&v154[15] = v27;
    *(_OWORD *)&v153[241] = v27;
    *(_OWORD *)&v153[225] = v27;
    *(_OWORD *)&v153[209] = v27;
    *(_OWORD *)&v153[193] = v27;
    *(_OWORD *)&v153[177] = v27;
    *(_OWORD *)&v153[161] = v27;
    *(_OWORD *)&v153[145] = v27;
    *(_OWORD *)&v153[129] = v27;
    *(_OWORD *)&v153[113] = v27;
    *(_OWORD *)&v153[97] = v27;
    *(_OWORD *)&v153[81] = v27;
    *(_OWORD *)&v153[65] = v27;
    *(_OWORD *)&v153[49] = v27;
    *(_OWORD *)&v153[33] = v27;
    *(_OWORD *)&v153[17] = v27;
    if (v25 >= 0xF)
      v28 = 15;
    else
      v28 = v25;
    v29 = v15 + 1340;
    *(_OWORD *)&v153[1] = v27;
    v153[0] = 0;
    do
    {
      v30 = v29 + 2 * v26;
      v31 = *(unsigned __int16 *)(v30 - 30);
      v32 = *(unsigned __int16 *)(v30 - 60);
      if (*(_BYTE *)(v29 + v26))
        v33 = 33;
      else
        v33 = 32;
      __sprintf_chk(v155, 0, 0x12uLL, "%ums(%u)%c ", v31, v32, v33);
      __strlcat_chk();
      ++v26;
    }
    while (v28 != v26);
    v34 = g_iBWEstLogLevel;
    ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    if (v34)
    {
      v16 = v134;
      if (ErrorLogLevelForModule < 8)
        goto LABEL_41;
      v36 = VRTraceErrorLogLevelToCSTR();
      v37 = *MEMORY[0x1E0CF2758];
      v38 = *MEMORY[0x1E0CF2758];
      if (!*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
        {
          v132 = *(_DWORD *)(v15 + 1272);
          v133 = *(_DWORD *)(v15 + 1276);
          *(_DWORD *)buf = 136316674;
          v140 = v36;
          v141 = 2080;
          v142 = "UpdateBigFrameReporter";
          v143 = 1024;
          v144 = 1670;
          v145 = 2048;
          v146 = a1;
          v147 = 1024;
          v148 = v132;
          v149 = 1024;
          v150 = v133;
          v151 = 2080;
          v152 = v153;
          _os_log_debug_impl(&dword_1D8A54000, v37, OS_LOG_TYPE_DEBUG, "VCRC [%s] %s:%d \t\tBIG FRAME report at %.3f, %d/%d frames: %s", buf, 0x3Cu);
        }
        goto LABEL_41;
      }
      if (!os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
      {
LABEL_41:
        *(_DWORD *)(v15 + 1272) = 0;
        v19 = *(_DWORD *)(v15 + 1256);
        a6 = v135;
        p_name = &OBJC_PROTOCOL___VCMediaStreamGroupDelegate.name;
        goto LABEL_42;
      }
      v39 = *(_DWORD *)(v15 + 1272);
      v40 = *(_DWORD *)(v15 + 1276);
      *(_DWORD *)buf = 136316674;
      v140 = v36;
      v141 = 2080;
      v142 = "UpdateBigFrameReporter";
      v143 = 1024;
      v144 = 1670;
      v145 = 2048;
      v146 = a1;
      v147 = 1024;
      v148 = v39;
      v149 = 1024;
      v150 = v40;
      v151 = 2080;
      v152 = v153;
      v41 = v37;
    }
    else
    {
      v16 = v134;
      if (ErrorLogLevelForModule < 7)
        goto LABEL_41;
      v44 = VRTraceErrorLogLevelToCSTR();
      v45 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        goto LABEL_41;
      v46 = *(_DWORD *)(v15 + 1272);
      v47 = *(_DWORD *)(v15 + 1276);
      *(_DWORD *)buf = 136316674;
      v140 = v44;
      v141 = 2080;
      v142 = "UpdateBigFrameReporter";
      v143 = 1024;
      v144 = 1673;
      v145 = 2048;
      v146 = a1;
      v147 = 1024;
      v148 = v46;
      v149 = 1024;
      v150 = v47;
      v151 = 2080;
      v152 = v153;
      v41 = v45;
    }
    _os_log_impl(&dword_1D8A54000, v41, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d \t\tBIG FRAME report at %.3f, %d/%d frames: %s", buf, 0x3Cu);
    goto LABEL_41;
  }
LABEL_48:
  v49 = *(_DWORD *)(v15 + 988);
  v50 = *(_DWORD *)(v15 + 992);
  if (a7 && *(_DWORD *)(v15 + 984) == a8)
  {
    v51 = *(double *)(v15 + 920);
    if (v51 < a1)
      v51 = a1;
    *(double *)(v15 + 920) = v51;
    *(_DWORD *)(v15 + 988) = v49 + a6;
    *(_DWORD *)(v15 + 992) = v50 + 1;
    *(_DWORD *)buf = -1;
    v52 = 0.0;
  }
  else
  {
    v53 = 0.0;
    if (v49)
    {
      v54 = *(double *)(v15 + 920) - *(double *)(v15 + 912);
      if (v49 >= 251)
        v53 = (double)(8 * v49) / v54;
    }
    else
    {
      v54 = 0.0;
    }
    *(_DWORD *)(v15 + 984) = a4;
    *(_QWORD *)(v15 + 988) = 0;
    *(double *)(v15 + 912) = a1;
    *(_DWORD *)(v15 + 928) = a6;
    *(_QWORD *)(v15 + 920) = 0;
    *(_DWORD *)buf = -1;
    if (v53 <= 0.0)
    {
      v52 = v53;
    }
    else
    {
      *(double *)(v15 + 680) = v53;
      UpdateRxEstimate(v15 + 720, v50, v49, (int *)buf, *(unsigned __int8 *)(v15 + 9701), v53, v54, a1);
      v52 = v55;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v136 = a6;
        v56 = v16;
        v57 = VRTraceErrorLogLevelToCSTR();
        v58 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v59 = *(_DWORD *)(v15 + 960);
          v60 = *(_QWORD *)(v15 + 944);
          *(_DWORD *)v153 = 136317698;
          *(_QWORD *)&v153[4] = v57;
          *(_WORD *)&v153[12] = 2080;
          *(_QWORD *)&v153[14] = "AFRCCalcRxEstimate_New";
          *(_WORD *)&v153[22] = 1024;
          *(_DWORD *)&v153[24] = 2309;
          *(_WORD *)&v153[28] = 2048;
          *(double *)&v153[30] = a1;
          *(_WORD *)&v153[38] = 2048;
          *(double *)&v153[40] = v52;
          *(_WORD *)&v153[48] = 1024;
          *(_DWORD *)&v153[50] = *(_DWORD *)buf;
          *(_WORD *)&v153[54] = 1024;
          *(_DWORD *)&v153[56] = v59;
          *(_WORD *)&v153[60] = 2048;
          *(double *)&v153[62] = v54;
          *(_WORD *)&v153[70] = 1024;
          *(_DWORD *)&v153[72] = v49;
          *(_WORD *)&v153[76] = 1024;
          *(_DWORD *)&v153[78] = v50;
          *(_WORD *)&v153[82] = 2048;
          *(_QWORD *)&v153[84] = v60;
          _os_log_impl(&dword_1D8A54000, v58, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d ArrivalTime:%.4f, BWD:%.2f, state:%d, divergeCount:%d prob_seq:[duration:%.4f, size:%d, count:%d], EstimatedBandwidth:%.2f", v153, 0x5Cu);
        }
        v16 = v56;
        a6 = v136;
      }
      p_name = (char **)(&OBJC_PROTOCOL___VCMediaStreamGroupDelegate + 8);
    }
  }
  if (!*((_DWORD *)p_name + 768))
    goto LABEL_92;
  v61 = *(_DWORD *)(v15 + 1116);
  if (!v61)
  {
LABEL_68:
    v62 = *(unsigned int *)(v15 + 1384);
    *(_DWORD *)(v15 + 1384) = v62 + 1;
    v63 = a6;
    __sprintf_chk(v138, 0, 0x400uLL, "NEW AFRCCalcRxEstimate [%d]: [%f] //////\n/////tp: %d  ts/arr: %d/%f \t seq: %d sz: %d \t Probe: %d/%d \t path: %d (%d)  BWD: %f/%f  Est: %f\n///// \t TS: %d  \t arrival: %f/%f \t total: %d/%d (%.1f ms) ref_size: %d\n", v62, *(_QWORD *)&a1, a3, a4, *(_QWORD *)&a1);
    goto LABEL_72;
  }
  if (v61 != -2)
  {
    if (v61 != -3)
    {
      v63 = a6;
      __sprintf_chk(v138, 0, 0x400uLL, "NEW AFRCCalcRxEstimate: [%d]  //////\n");
      goto LABEL_72;
    }
    goto LABEL_68;
  }
  v63 = a6;
  if (v52 == 0.0)
    v138[0] = 0;
  else
    __sprintf_chk(v138, 0, 0x400uLL, "NEW AFRCCalcRxEstimate: [%d]  (%d %d)  //////\n");
LABEL_72:
  if ((_DWORD)a3 == 1)
    v64 = 1128;
  else
    v64 = 1140;
  v65 = 1148;
  if ((_DWORD)a3 == 1)
    v65 = 1136;
  v66 = *(_DWORD *)(v15 + v65);
  if ((_DWORD)a3 == 1)
    v67 = 1132;
  else
    v67 = 1144;
  *(_DWORD *)(v15 + v65) = v66 + 1;
  if (*(_WORD *)(v15 + v67) && a5 - *(unsigned __int16 *)(v15 + v67) >= 2)
  {
    if (*(int *)(v15 + 1116) <= 0)
    {
      *(_QWORD *)&v68 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v68 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)&v153[240] = v68;
      *(_OWORD *)&v153[224] = v68;
      *(_OWORD *)&v153[208] = v68;
      *(_OWORD *)&v153[192] = v68;
      *(_OWORD *)&v153[176] = v68;
      *(_OWORD *)&v153[160] = v68;
      *(_OWORD *)&v153[144] = v68;
      *(_OWORD *)&v153[128] = v68;
      *(_OWORD *)&v153[112] = v68;
      *(_OWORD *)&v153[96] = v68;
      *(_OWORD *)&v153[80] = v68;
      *(_OWORD *)&v153[64] = v68;
      *(_OWORD *)&v153[48] = v68;
      *(_OWORD *)&v153[32] = v68;
      *(_OWORD *)&v153[16] = v68;
      *(_OWORD *)v153 = v68;
      __sprintf_chk(v153, 0, 0x100uLL, "///// \t LOSS [%d/%d] @ %d: //////\n", *(_DWORD *)(v15 + v64), v66 + 1, a5);
      __strlcat_chk();
    }
    ++*(_DWORD *)(v15 + v64);
  }
  *(_WORD *)(v15 + v67) = a5;
  if (*(double *)(v15 + 1184) == 0.0)
    *(double *)(v15 + 1184) = a1;
  *(double *)(v15 + 1192) = a1;
  a6 = v63;
  p_name = &OBJC_PROTOCOL___VCMediaStreamGroupDelegate.name;
  if ((_DWORD)a3 == 1)
  {
    v69 = (_QWORD *)(v15 + 1168);
LABEL_91:
    *v69 += v63;
    goto LABEL_92;
  }
  if (!(_DWORD)a3)
  {
    v69 = (_QWORD *)(v15 + 1176);
    goto LABEL_91;
  }
LABEL_92:
  v43 = *(_BYTE *)(v15 + 721) == 0;
  if (*(_BYTE *)(v15 + 721) && !*((_DWORD *)p_name + 768))
    goto LABEL_224;
LABEL_94:
  v70 = (double *)(v15 + 352);
  v71 = *(double *)(v15 + 936);
  if ((_DWORD)a3 == 1 && *(_DWORD *)(v15 + 704) == (_DWORD)a4)
  {
    v72 = 0.0;
    v73 = 0;
    if ((unsigned __int16)(a5 - *(_WORD *)(v15 + 344)) <= 0x13u)
    {
      v74 = &v70[2 * (unsigned __int16)(a5 - *(_WORD *)(v15 + 344))];
      *v74 = a1;
      *((_DWORD *)v74 + 2) += a6;
    }
    goto LABEL_110;
  }
  v72 = 0.0;
  if (*(int *)(v15 + 360) < 1)
  {
    v73 = 0;
  }
  else
  {
    v75 = 0;
    v73 = 0;
    v76 = *v70;
    do
    {
      v77 = *(_DWORD *)(v15 + v75 + 376);
      if (v77 < 1)
        break;
      v73 += v77;
      if (*(double *)(v15 + v75 + 368) > v76)
        v76 = *(double *)(v15 + v75 + 368);
      v75 += 16;
    }
    while (v75 != 304);
    v78 = v76 - *v70;
    if (v78 > 0.0 && v73 >= 251)
      v72 = (double)(8 * v73) / v78;
  }
  *(_OWORD *)(v15 + 640) = 0u;
  *(_OWORD *)(v15 + 656) = 0u;
  *(_OWORD *)(v15 + 608) = 0u;
  *(_OWORD *)(v15 + 624) = 0u;
  *(_OWORD *)(v15 + 576) = 0u;
  *(_OWORD *)(v15 + 592) = 0u;
  *(_OWORD *)(v15 + 544) = 0u;
  *(_OWORD *)(v15 + 560) = 0u;
  *(_OWORD *)(v15 + 512) = 0u;
  *(_OWORD *)(v15 + 528) = 0u;
  *(_OWORD *)(v15 + 480) = 0u;
  *(_OWORD *)(v15 + 496) = 0u;
  *(_OWORD *)(v15 + 448) = 0u;
  *(_OWORD *)(v15 + 464) = 0u;
  *(_OWORD *)(v15 + 416) = 0u;
  *(_OWORD *)(v15 + 432) = 0u;
  *(_OWORD *)(v15 + 384) = 0u;
  *(_OWORD *)(v15 + 400) = 0u;
  *(_OWORD *)v70 = 0u;
  *(_OWORD *)(v15 + 368) = 0u;
  if ((_DWORD)a3 == 1)
  {
    *(double *)(v15 + 352) = a1;
    *(_DWORD *)(v15 + 360) = a6;
    *(_DWORD *)(v15 + 348) = 1;
    *(_WORD *)(v15 + 344) = a5;
LABEL_110:
    *(_DWORD *)(v15 + 704) = a4;
  }
  if (v72 <= 0.0)
  {
    if (!g_iBWEstLogLevel)
      goto LABEL_223;
    v82 = v16;
    v83 = *(_DWORD *)(v15 + 708);
    v79 = -1;
    v81 = v72;
  }
  else
  {
    if (v71 == 0.0)
    {
      v79 = 0;
      v80 = 100000.0;
      if (v72 >= 100000.0)
        v80 = v72;
      if (v72 <= 1000000.0)
        v71 = v80;
      else
        v71 = 1000000.0;
      v81 = v72;
    }
    else
    {
      v84 = v71 * 0.5;
      v85 = v71 * 1.5;
      if (v72 > v71 * 0.5 && v72 < v85)
      {
        if (v71 <= 300000.0)
        {
          v90 = (int)(v71 * 0.02 * 0.125);
          if (v90 <= 250)
            v90 = 250;
        }
        else
        {
          v90 = 750;
        }
        v91 = 1000000.0;
        if (v72 <= 1000000.0)
          v91 = v72;
        if (v73 <= v90)
        {
          v81 = v72;
        }
        else
        {
          v71 = v91 * 0.05 + v71 * 0.95;
          v81 = v91;
        }
        *(_DWORD *)(v15 + 708) = 0;
        *(_QWORD *)(v15 + 696) = 0;
        v79 = 1;
      }
      else
      {
        if (v72 > v84)
        {
          v89 = *(_DWORD *)(v15 + 708);
          if (v72 >= v85)
          {
            if (v89 <= 0)
            {
              *(_QWORD *)(v15 + 696) = 0;
              v89 = 1;
              *(_DWORD *)(v15 + 708) = 1;
              *(double *)(v15 + 712) = a1;
            }
            else
            {
              *(_DWORD *)(v15 + 708) = ++v89;
            }
            v79 = 10;
            v88 = 1;
          }
          else
          {
            v88 = 0;
            v79 = -1;
          }
        }
        else
        {
          v87 = *(_DWORD *)(v15 + 708);
          v88 = 0;
          if (v87 < 0)
          {
            v89 = v87 - 1;
            *(_DWORD *)(v15 + 708) = v89;
          }
          else
          {
            *(_QWORD *)(v15 + 696) = 0;
            v89 = -1;
            *(_DWORD *)(v15 + 708) = -1;
            *(double *)(v15 + 712) = a1;
          }
          v79 = -10;
        }
        if (v72 <= 1000000.0)
          v81 = v72;
        else
          v81 = 1000000.0;
        v92 = v81 + *(double *)(v15 + 696);
        *(double *)(v15 + 696) = v92;
        if (v89 < 0)
          v89 = -v89;
        v93 = a1 - *(double *)(v15 + 712);
        if (v93 <= 5.0)
        {
          if (v89 > 9 || v89 >= 5 && v93 > 3.0)
          {
            v71 = v92 / (double)v89;
            *(_DWORD *)(v15 + 708) = 0;
            *(_QWORD *)(v15 + 696) = 0;
            if (v72 > v84)
              v94 = 200;
            else
              v94 = -100;
            if (v88)
              v79 = 100;
            else
              v79 = v94;
          }
        }
        else
        {
          *(_DWORD *)(v15 + 708) = 0;
          *(_QWORD *)(v15 + 696) = 0;
        }
      }
    }
    if (!g_iBWEstLogLevel)
      goto LABEL_223;
    v82 = v16;
    v83 = *(_DWORD *)(v15 + 708);
    *(double *)(v15 + 1200) = v72 + *(double *)(v15 + 1200);
    ++*(_DWORD *)(v15 + 1208);
  }
  if (*(double *)(v15 + 1216) == 0.0)
    *(double *)(v15 + 1216) = a1;
  *(double *)(v15 + 1224) = a1;
  if ((_DWORD)a3)
  {
    if ((_DWORD)a3 != 1)
      goto LABEL_172;
    *(_DWORD *)(v15 + 1232) += a6;
    v95 = (_DWORD *)(v15 + 1236);
  }
  else
  {
    *(_DWORD *)(v15 + 1240) += a6;
    v95 = (_DWORD *)(v15 + 1244);
  }
  ++*v95;
LABEL_172:
  v96 = *(_DWORD *)(v15 + 1116);
  if (v43)
  {
    if (v96)
    {
      if (v96 == -2 && v138[0])
      {
        v16 = v82;
        if ((int)VRTraceGetErrorLogLevelForModule() < 8)
          goto LABEL_223;
        v97 = VRTraceErrorLogLevelToCSTR();
        v98 = *MEMORY[0x1E0CF2758];
        v99 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (!os_log_type_enabled(v99, OS_LOG_TYPE_DEFAULT))
            goto LABEL_223;
          *(_DWORD *)v153 = 136316162;
          *(_QWORD *)&v153[4] = v97;
          *(_WORD *)&v153[12] = 2080;
          *(_QWORD *)&v153[14] = "AFRCCalcRxEstimate";
          *(_WORD *)&v153[22] = 1024;
          *(_DWORD *)&v153[24] = 2638;
          *(_WORD *)&v153[28] = 1024;
          *(_DWORD *)&v153[30] = (int)v71;
          *(_WORD *)&v153[34] = 2080;
          *(_QWORD *)&v153[36] = v138;
          v100 = "VCRC [%s] %s:%d \t\t\t\t AFRCCalcRxEstimate [%d]: //////\t\t%s\n";
LABEL_192:
          _os_log_impl(&dword_1D8A54000, v98, OS_LOG_TYPE_DEFAULT, v100, v153, 0x2Cu);
          goto LABEL_223;
        }
        if (os_log_type_enabled(v99, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)v153 = 136316162;
          *(_QWORD *)&v153[4] = v97;
          *(_WORD *)&v153[12] = 2080;
          *(_QWORD *)&v153[14] = "AFRCCalcRxEstimate";
          *(_WORD *)&v153[22] = 1024;
          *(_DWORD *)&v153[24] = 2638;
          *(_WORD *)&v153[28] = 1024;
          *(_DWORD *)&v153[30] = (int)v71;
          *(_WORD *)&v153[34] = 2080;
          *(_QWORD *)&v153[36] = v138;
          v126 = "VCRC [%s] %s:%d \t\t\t\t AFRCCalcRxEstimate [%d]: //////\t\t%s\n";
LABEL_218:
          _os_log_debug_impl(&dword_1D8A54000, v98, OS_LOG_TYPE_DEBUG, v126, v153, 0x2Cu);
          goto LABEL_223;
        }
        goto LABEL_223;
      }
      v16 = v82;
      if (v96 != -1 && a1 - *(double *)(v15 + 1120) <= (double)v96 / 1000000.0)
        goto LABEL_223;
      if ((int)VRTraceGetErrorLogLevelForModule() < 8)
        goto LABEL_220;
      v116 = VRTraceErrorLogLevelToCSTR();
      v117 = *MEMORY[0x1E0CF2758];
      v118 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v118, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v153 = 136316162;
          *(_QWORD *)&v153[4] = v116;
          *(_WORD *)&v153[12] = 2080;
          *(_QWORD *)&v153[14] = "AFRCCalcRxEstimate";
          *(_WORD *)&v153[22] = 1024;
          *(_DWORD *)&v153[24] = 2644;
          *(_WORD *)&v153[28] = 1024;
          *(_DWORD *)&v153[30] = (int)v71;
          *(_WORD *)&v153[34] = 2080;
          *(_QWORD *)&v153[36] = v138;
          v119 = "VCRC [%s] %s:%d \t\t\t\t AFRCCalcRxEstimate [%d]: //////\t\t%s\n";
LABEL_209:
          _os_log_impl(&dword_1D8A54000, v117, OS_LOG_TYPE_DEFAULT, v119, v153, 0x2Cu);
          goto LABEL_220;
        }
        goto LABEL_220;
      }
      if (!os_log_type_enabled(v118, OS_LOG_TYPE_DEBUG))
        goto LABEL_220;
      *(_DWORD *)v153 = 136316162;
      *(_QWORD *)&v153[4] = v116;
      *(_WORD *)&v153[12] = 2080;
      *(_QWORD *)&v153[14] = "AFRCCalcRxEstimate";
      *(_WORD *)&v153[22] = 1024;
      *(_DWORD *)&v153[24] = 2644;
      *(_WORD *)&v153[28] = 1024;
      *(_DWORD *)&v153[30] = (int)v71;
      *(_WORD *)&v153[34] = 2080;
      *(_QWORD *)&v153[36] = v138;
      v127 = "VCRC [%s] %s:%d \t\t\t\t AFRCCalcRxEstimate [%d]: //////\t\t%s\n";
      goto LABEL_231;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() < 8)
      goto LABEL_222;
    v111 = a6;
    v112 = VRTraceErrorLogLevelToCSTR();
    v113 = *MEMORY[0x1E0CF2758];
    v114 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v114, OS_LOG_TYPE_DEFAULT))
      {
        v115 = *(_DWORD *)(v15 + 1384);
        *(_DWORD *)(v15 + 1384) = v115 + 1;
        *(_DWORD *)v153 = 136318466;
        *(_QWORD *)&v153[4] = v112;
        *(_WORD *)&v153[12] = 2080;
        *(_QWORD *)&v153[14] = "AFRCCalcRxEstimate";
        *(_WORD *)&v153[22] = 1024;
        *(_DWORD *)&v153[24] = 2630;
        *(_WORD *)&v153[28] = 1024;
        *(_DWORD *)&v153[30] = v115;
        *(_WORD *)&v153[34] = 1024;
        *(_DWORD *)&v153[36] = a3;
        *(_WORD *)&v153[40] = 1024;
        *(_DWORD *)&v153[42] = a4;
        *(_WORD *)&v153[46] = 2048;
        *(double *)&v153[48] = a1;
        *(_WORD *)&v153[56] = 1024;
        *(_DWORD *)&v153[58] = a5;
        *(_WORD *)&v153[62] = 1024;
        *(_DWORD *)&v153[64] = v111;
        *(_WORD *)&v153[68] = 1024;
        *(_DWORD *)&v153[70] = v79;
        *(_WORD *)&v153[74] = 1024;
        *(_DWORD *)&v153[76] = v83;
        *(_WORD *)&v153[80] = 2048;
        *(double *)&v153[82] = v72;
        *(_WORD *)&v153[90] = 2048;
        *(double *)&v153[92] = v81;
        *(_WORD *)&v153[100] = 2048;
        *(double *)&v153[102] = v71;
        v106 = "VCRC [%s] %s:%d AFRCCalcRxEstimate [%d]: //////\n"
               "/////tp: %d  ts/arr: %d/%f \t seq: %d sz: %d \t path: %d (%d)  BWD: %f/%f  Est: %f\n";
        v107 = v113;
        v108 = 110;
        goto LABEL_197;
      }
      goto LABEL_222;
    }
    if (!os_log_type_enabled(v114, OS_LOG_TYPE_DEBUG))
      goto LABEL_222;
    v122 = *(_DWORD *)(v15 + 1384);
    *(_DWORD *)(v15 + 1384) = v122 + 1;
    *(_DWORD *)v153 = 136318466;
    *(_QWORD *)&v153[4] = v112;
    *(_WORD *)&v153[12] = 2080;
    *(_QWORD *)&v153[14] = "AFRCCalcRxEstimate";
    *(_WORD *)&v153[22] = 1024;
    *(_DWORD *)&v153[24] = 2630;
    *(_WORD *)&v153[28] = 1024;
    *(_DWORD *)&v153[30] = v122;
    *(_WORD *)&v153[34] = 1024;
    *(_DWORD *)&v153[36] = a3;
    *(_WORD *)&v153[40] = 1024;
    *(_DWORD *)&v153[42] = a4;
    *(_WORD *)&v153[46] = 2048;
    *(double *)&v153[48] = a1;
    *(_WORD *)&v153[56] = 1024;
    *(_DWORD *)&v153[58] = a5;
    *(_WORD *)&v153[62] = 1024;
    *(_DWORD *)&v153[64] = v111;
    *(_WORD *)&v153[68] = 1024;
    *(_DWORD *)&v153[70] = v79;
    *(_WORD *)&v153[74] = 1024;
    *(_DWORD *)&v153[76] = v83;
    *(_WORD *)&v153[80] = 2048;
    *(double *)&v153[82] = v72;
    *(_WORD *)&v153[90] = 2048;
    *(double *)&v153[92] = v81;
    *(_WORD *)&v153[100] = 2048;
    *(double *)&v153[102] = v71;
    v123 = "VCRC [%s] %s:%d AFRCCalcRxEstimate [%d]: //////\n"
           "/////tp: %d  ts/arr: %d/%f \t seq: %d sz: %d \t path: %d (%d)  BWD: %f/%f  Est: %f\n";
    v124 = v113;
    v125 = 110;
    goto LABEL_233;
  }
  if ((v96 + 3) >= 2)
  {
    if (v96 != -1)
    {
      if (!v96)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() < 8)
          goto LABEL_222;
        v101 = a6;
        v102 = VRTraceErrorLogLevelToCSTR();
        v103 = *MEMORY[0x1E0CF2758];
        v104 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v104, OS_LOG_TYPE_DEFAULT))
          {
            v105 = *(_DWORD *)(v15 + 1384);
            *(_DWORD *)(v15 + 1384) = v105 + 1;
            *(_DWORD *)v153 = 136318722;
            *(_QWORD *)&v153[4] = v102;
            *(_WORD *)&v153[12] = 2080;
            *(_QWORD *)&v153[14] = "AFRCCalcRxEstimate";
            *(_WORD *)&v153[22] = 1024;
            *(_DWORD *)&v153[24] = 2598;
            *(_WORD *)&v153[28] = 1024;
            *(_DWORD *)&v153[30] = v105;
            *(_WORD *)&v153[34] = 1024;
            *(_DWORD *)&v153[36] = a3;
            *(_WORD *)&v153[40] = 1024;
            *(_DWORD *)&v153[42] = a4;
            *(_WORD *)&v153[46] = 2048;
            *(double *)&v153[48] = a1;
            *(_WORD *)&v153[56] = 1024;
            *(_DWORD *)&v153[58] = a5;
            *(_WORD *)&v153[62] = 1024;
            *(_DWORD *)&v153[64] = v101;
            *(_WORD *)&v153[68] = 1024;
            *(_DWORD *)&v153[70] = v79;
            *(_WORD *)&v153[74] = 1024;
            *(_DWORD *)&v153[76] = v83;
            *(_WORD *)&v153[80] = 2048;
            *(double *)&v153[82] = v72;
            *(_WORD *)&v153[90] = 2048;
            *(double *)&v153[92] = v81;
            *(_WORD *)&v153[100] = 2048;
            *(double *)&v153[102] = v71;
            *(_WORD *)&v153[110] = 2080;
            *(_QWORD *)&v153[112] = v138;
            v106 = "VCRC [%s] %s:%d AFRCCalcRxEstimate [%d]: //////\n"
                   "/////tp: %d  ts/arr: %d/%f \t seq: %d sz: %d \t path: %d (%d)  BWD: %f/%f  Est: %f\n"
                   "%s";
            v107 = v103;
            v108 = 120;
LABEL_197:
            _os_log_impl(&dword_1D8A54000, v107, OS_LOG_TYPE_DEFAULT, v106, v153, v108);
          }
LABEL_222:
          v16 = v82;
          goto LABEL_223;
        }
        if (!os_log_type_enabled(v104, OS_LOG_TYPE_DEBUG))
          goto LABEL_222;
        v131 = *(_DWORD *)(v15 + 1384);
        *(_DWORD *)(v15 + 1384) = v131 + 1;
        *(_DWORD *)v153 = 136318722;
        *(_QWORD *)&v153[4] = v102;
        *(_WORD *)&v153[12] = 2080;
        *(_QWORD *)&v153[14] = "AFRCCalcRxEstimate";
        *(_WORD *)&v153[22] = 1024;
        *(_DWORD *)&v153[24] = 2598;
        *(_WORD *)&v153[28] = 1024;
        *(_DWORD *)&v153[30] = v131;
        *(_WORD *)&v153[34] = 1024;
        *(_DWORD *)&v153[36] = a3;
        *(_WORD *)&v153[40] = 1024;
        *(_DWORD *)&v153[42] = a4;
        *(_WORD *)&v153[46] = 2048;
        *(double *)&v153[48] = a1;
        *(_WORD *)&v153[56] = 1024;
        *(_DWORD *)&v153[58] = a5;
        *(_WORD *)&v153[62] = 1024;
        *(_DWORD *)&v153[64] = v101;
        *(_WORD *)&v153[68] = 1024;
        *(_DWORD *)&v153[70] = v79;
        *(_WORD *)&v153[74] = 1024;
        *(_DWORD *)&v153[76] = v83;
        *(_WORD *)&v153[80] = 2048;
        *(double *)&v153[82] = v72;
        *(_WORD *)&v153[90] = 2048;
        *(double *)&v153[92] = v81;
        *(_WORD *)&v153[100] = 2048;
        *(double *)&v153[102] = v71;
        *(_WORD *)&v153[110] = 2080;
        *(_QWORD *)&v153[112] = v138;
        v123 = "VCRC [%s] %s:%d AFRCCalcRxEstimate [%d]: //////\n"
               "/////tp: %d  ts/arr: %d/%f \t seq: %d sz: %d \t path: %d (%d)  BWD: %f/%f  Est: %f\n"
               "%s";
        v124 = v103;
        v125 = 120;
LABEL_233:
        _os_log_debug_impl(&dword_1D8A54000, v124, OS_LOG_TYPE_DEBUG, v123, v153, v125);
        goto LABEL_222;
      }
      if (a1 - *(double *)(v15 + 1120) <= (double)v96 / 1000000.0)
        goto LABEL_222;
    }
    v16 = v82;
    if ((int)VRTraceGetErrorLogLevelForModule() < 8)
      goto LABEL_220;
    v120 = VRTraceErrorLogLevelToCSTR();
    v117 = *MEMORY[0x1E0CF2758];
    v121 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v121, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v153 = 136316162;
        *(_QWORD *)&v153[4] = v120;
        *(_WORD *)&v153[12] = 2080;
        *(_QWORD *)&v153[14] = "AFRCCalcRxEstimate";
        *(_WORD *)&v153[22] = 1024;
        *(_DWORD *)&v153[24] = 2613;
        *(_WORD *)&v153[28] = 1024;
        *(_DWORD *)&v153[30] = (int)v71;
        *(_WORD *)&v153[34] = 2080;
        *(_QWORD *)&v153[36] = v138;
        v119 = "VCRC [%s] %s:%d AFRCCalcRxEstimate [%d]: //////\t\t%s";
        goto LABEL_209;
      }
LABEL_220:
      *(double *)(v15 + 1120) = a1;
      goto LABEL_223;
    }
    if (!os_log_type_enabled(v121, OS_LOG_TYPE_DEBUG))
      goto LABEL_220;
    *(_DWORD *)v153 = 136316162;
    *(_QWORD *)&v153[4] = v120;
    *(_WORD *)&v153[12] = 2080;
    *(_QWORD *)&v153[14] = "AFRCCalcRxEstimate";
    *(_WORD *)&v153[22] = 1024;
    *(_DWORD *)&v153[24] = 2613;
    *(_WORD *)&v153[28] = 1024;
    *(_DWORD *)&v153[30] = (int)v71;
    *(_WORD *)&v153[34] = 2080;
    *(_QWORD *)&v153[36] = v138;
    v127 = "VCRC [%s] %s:%d AFRCCalcRxEstimate [%d]: //////\t\t%s";
LABEL_231:
    _os_log_debug_impl(&dword_1D8A54000, v117, OS_LOG_TYPE_DEBUG, v127, v153, 0x2Cu);
    goto LABEL_220;
  }
  if (!v138[0])
    goto LABEL_222;
  v16 = v82;
  if ((int)VRTraceGetErrorLogLevelForModule() < 8)
    goto LABEL_223;
  v109 = VRTraceErrorLogLevelToCSTR();
  v98 = *MEMORY[0x1E0CF2758];
  v110 = *MEMORY[0x1E0CF2758];
  if (*MEMORY[0x1E0CF2748])
  {
    if (!os_log_type_enabled(v110, OS_LOG_TYPE_DEFAULT))
      goto LABEL_223;
    *(_DWORD *)v153 = 136316162;
    *(_QWORD *)&v153[4] = v109;
    *(_WORD *)&v153[12] = 2080;
    *(_QWORD *)&v153[14] = "AFRCCalcRxEstimate";
    *(_WORD *)&v153[22] = 1024;
    *(_DWORD *)&v153[24] = 2606;
    *(_WORD *)&v153[28] = 1024;
    *(_DWORD *)&v153[30] = (int)v71;
    *(_WORD *)&v153[34] = 2080;
    *(_QWORD *)&v153[36] = v138;
    v100 = "VCRC [%s] %s:%d AFRCCalcRxEstimate [%d]: //////\t\t%s\n";
    goto LABEL_192;
  }
  if (os_log_type_enabled(v110, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)v153 = 136316162;
    *(_QWORD *)&v153[4] = v109;
    *(_WORD *)&v153[12] = 2080;
    *(_QWORD *)&v153[14] = "AFRCCalcRxEstimate";
    *(_WORD *)&v153[22] = 1024;
    *(_DWORD *)&v153[24] = 2606;
    *(_WORD *)&v153[28] = 1024;
    *(_DWORD *)&v153[30] = (int)v71;
    *(_WORD *)&v153[34] = 2080;
    *(_QWORD *)&v153[36] = v138;
    v126 = "VCRC [%s] %s:%d AFRCCalcRxEstimate [%d]: //////\t\t%s\n";
    goto LABEL_218;
  }
LABEL_223:
  v128 = *(unsigned __int8 *)(v15 + 721);
  *(double *)(v15 + 936) = v71;
  if (v128)
LABEL_224:
    v71 = *(double *)(v15 + 944);
  *(double *)(v15 + 672) = v71;
  v129 = *(_DWORD *)(v15 + 1040);
  if (v129)
  {
    v130 = (double)v129;
    if (v71 < (double)v129)
      v130 = v71;
    *(double *)(v15 + 672) = v130;
  }
  pthread_mutex_unlock(v16);
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCSetAudioBitRate(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  pthread_mutex_t *v6;
  double v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149646338;
  v4 = v3;
  v5 = (_QWORD *)(v3 + 2700);
  v6 = (pthread_mutex_t *)(v3 + 2744);
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 2744));
  v7 = *(double *)(v4 + 2728);
  if (*(double *)(v4 + 2720) != v7)
  {
    *(double *)(v4 + 2720) = v7;
    MediaQueue_SetAudioFECLevel(v7);
  }
  *v5 = v5[1];
  pthread_mutex_unlock(v6);
  VRLogfilePrintWithTimestamp(*(_QWORD *)(v4 + 2848), "New audio rate [%ukbps], fraction [%.2f], FEC [%.2f], RED[%u %u]\n", v8, v9, v10, v11, v12, v13, a2 / 1000);
  if (a2 >= 1)
    *(_DWORD *)(v4 + 8) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCSetAudioPayload(uint64_t a1, int a2, int a3)
{
  uint64_t v5;

  v5 = CheckInHandleDebug();
  if (!v5)
    return 2149646338;
  *(_DWORD *)(v5 + 12) = a2;
  *(_DWORD *)(v5 + 16) = a3;
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCGetAudioPauseTime(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149646338;
  if (a2)
    *a2 = *(_QWORD *)(v3 + 2664);
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCGetAudioMaxPauseTimes(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149646338;
  if (a2)
    *a2 = *(_QWORD *)(v3 + 2688);
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCMarkSpecialAudioFlush(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  double v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149646338;
  v4 = v3;
  if (a2)
  {
    v5 = micro();
    *(double *)(v4 + 9840) = v5;
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 2560));
    v6 = *(_DWORD *)(v4 + 2988) + 1;
    *(_DWORD *)(v4 + 2988) = v6;
    *(double *)(v4 + 2992) = v5;
    VRLogfilePrintWithTimestamp(*(_QWORD *)(v4 + 2848), "Add special audio flush(%u).\n", v7, v8, v9, v10, v11, v12, v6);
    pthread_mutex_unlock((pthread_mutex_t *)(v4 + 2560));
  }
  *(_DWORD *)(v4 + 9848) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCGetKeyFrameTimestamp(uint64_t a1, _DWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149646338;
  *a2 = *(_DWORD *)(v3 + 2496);
  if ((int)*MEMORY[0x1E0CF2740] >= 5)
    StallModeTracePrint_(5, (uint64_t)"VCRC", v4, v5, " RTPSetCellularAudioStallState -> AFRCGetKeyFrameTimestamp: %d (seq: %x) ", v6, v7, v8, *(_DWORD *)(v3 + 2496));
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCMarkSpecialVideoFlush(uint64_t a1, uint64_t a2, __int16 a3)
{
  pthread_mutex_t *v4;
  pthread_mutex_t *v5;
  pthread_mutex_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v4 = (pthread_mutex_t *)CheckInHandleDebug();
  if (!v4)
    return 2149646338;
  v5 = v4;
  v6 = v4 + 40;
  pthread_mutex_lock(v4 + 40);
  ++*(_DWORD *)&v5[46].__opaque[36];
  *(_WORD *)&v5[46].__opaque[54] = a3;
  *(double *)&v5[46].__opaque[40] = micro();
  VRLogfilePrintWithTimestamp(*(_QWORD *)&v5[44].__opaque[24], "Add special video flush(%u)%s.\n", v7, v8, v9, v10, v11, v12, *(_DWORD *)&v5[46].__opaque[36]);
  pthread_mutex_unlock(v6);
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCLogMQFlushedPackets(uint64_t a1, char a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149646338;
  VRLogfilePrintWithTimestamp(*(_QWORD *)(v3 + 2848), "MQ flushed %d video packets. [%.512s]\n", v4, v5, v6, v7, v8, v9, a2);
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCGetQualityIndication(uint64_t a1, _DWORD *a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149646338;
  if (a2)
    *a2 = *(double *)(v3 + 9576) >= 1.0;
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCGetAudioTxInfo(uint64_t a1, _DWORD *a2, int *a3, _QWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7, _DWORD *a8, _DWORD *a9, uint64_t a10)
{
  uint64_t v17;
  uint64_t v18;
  int v19;
  unsigned int v20;
  int v21;
  int v22;

  v17 = CheckInHandleDebug();
  if (!v17)
    return 2149646338;
  v18 = v17;
  if (a2)
  {
    if (!*(_DWORD *)(v17 + 2928) || (v19 = *(_DWORD *)(v17 + 48)) == 0)
      v19 = *(_DWORD *)(v17 + 44);
    *a2 = v19;
  }
  if (a3)
  {
    v20 = (*(double *)(v17 + 2728) * 100.0);
    if (v20 == 150)
      v21 = 150;
    else
      v21 = 200;
    if (v20 == 100)
      v22 = 100;
    else
      v22 = v21;
    *a3 = v22;
  }
  if (a4)
    *a4 = *(_QWORD *)(v17 + 9576);
  if (a5)
    *a5 = *(_DWORD *)(v17 + 2708);
  if (a6)
    *a6 = *(_DWORD *)(v17 + 2712);
  if (a7)
    *a7 = *(_DWORD *)(v17 + 2680);
  if (a8)
    *a8 = *(_DWORD *)(v17 + 1404);
  if (a9)
    *a9 = *(_DWORD *)(v17 + 2656);
  if (a10)
  {
    *(_DWORD *)a10 = 3;
    *(double *)(a10 + 24) = *(double *)(v17 + 176) * 100.0;
    *(double *)(a10 + 40) = *(double *)(v17 + 184) * 100.0;
    *(_DWORD *)(a10 + 48) = *(_DWORD *)(v17 + 256);
    *(_DWORD *)(a10 + 64) = *(_DWORD *)(v17 + 44);
    *(_DWORD *)(a10 + 56) = *(_DWORD *)(v17 + 2408);
    if (VCMediaControlInfo_IsLossStatsEnabled(*(unsigned __int8 *)(v17 + 9852)))
      *(_DWORD *)(a10 + 80) = *(_DWORD *)(v18 + 272);
  }
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCGetTxInfo(uint64_t a1, _DWORD *a2, _QWORD *a3, _DWORD *a4, _DWORD *a5, _QWORD *a6, _DWORD *a7, _DWORD *a8, _DWORD *a9, _DWORD *a10, BOOL *a11, _DWORD *a12)
{
  uint64_t v17;
  uint64_t v18;
  _DWORD *v19;
  double v20;
  double v21;
  BOOL v22;
  _BOOL4 v24;
  double v25;
  NSObject *v27;
  NSObject *v28;
  int v29;
  double v30;
  NSObject *v32;
  NSObject *v33;
  int v34;
  int v35;
  double v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  int v44;
  int v45;
  int v47;
  unsigned int v48;
  double v49;
  BOOL v50;
  _BOOL4 v51;
  int v52;
  int v53;
  unsigned int v54;
  double *v55;
  int v56;
  uint64_t v57;
  double v58;
  uint64_t v59;
  NSObject *v60;
  const char *v61;
  uint64_t v62;
  int v63;
  uint64_t v64;
  NSObject *v65;
  uint64_t v66;
  const char *v67;
  uint64_t v68;
  int v69;
  int v70;
  const char *v71;
  int v72;
  uint64_t v73;
  uint64_t v74;
  int v75;
  uint64_t v76;
  NSObject *v77;
  int v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  int v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  NSObject *v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  unsigned int v100;
  double v101;
  int v102;
  int v103;
  int v104;
  int v105;
  const char *v106;
  uint64_t v107;
  NSObject *v108;
  const char *v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  BOOL v116;
  NSObject *v117;
  int v118;
  int v119;
  _DWORD *v120;
  _DWORD *v121;
  _QWORD *v122;
  _DWORD *v123;
  unsigned int v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  NSObject *v128;
  uint8_t buf[4];
  uint64_t v132;
  __int16 v133;
  const char *v134;
  __int16 v135;
  int v136;
  __int16 v137;
  const char *v138;
  __int16 v139;
  _BYTE v140[14];
  __int16 v141;
  uint64_t v142;
  __int16 v143;
  int v144;
  __int16 v145;
  int v146;
  __int16 v147;
  int v148;
  __int16 v149;
  int v150;
  uint64_t v151;

  v151 = *MEMORY[0x1E0C80C00];
  v17 = CheckInHandleDebug();
  if (!v17)
    return 2149646338;
  v18 = v17;
  v19 = a10;
  if (a9)
  {
    *a9 = 0;
    if (*(_BYTE *)(v17 + 720))
    {
      v20 = *(double *)(v17 + 864);
      v21 = micro();
      if (*(double *)(v18 + 1048) == 0.0)
      {
        *(double *)(v18 + 1048) = v21;
        *(double *)(v18 + 1056) = v21;
        *(double *)(v18 + 1088) = v21;
      }
      if (*(_BYTE *)(v18 + 1104))
      {
        if (*(_DWORD *)(v18 + 2404))
          v22 = v21 - *(double *)(v18 + 2416) > 0.5;
        else
          v22 = 0;
        v24 = 0;
        if ((*(_BYTE *)(v18 + 1396) & 1) != 0 && !v22)
          v24 = g_adwTxRateTiers[*(int *)(v18 + 28) + 1] <= *(_DWORD *)(v18 + 20);
        v25 = v21 - *(double *)(v18 + 1088);
        if (v25 < 3.0)
          v24 = 1;
        if (!v24 || v25 >= 10.0)
        {
          *(_BYTE *)(v18 + 1104) = 0;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            v126 = VRTraceErrorLogLevelToCSTR();
            v27 = *MEMORY[0x1E0CF2758];
            v28 = *MEMORY[0x1E0CF2758];
            if (*MEMORY[0x1E0CF2748])
            {
              if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315650;
                v132 = v126;
                v133 = 2080;
                v134 = "BWEstCheckIfLargeFrameNeeded";
                v135 = 1024;
                v136 = 6160;
                _os_log_impl(&dword_1D8A54000, v27, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Enabling LF", buf, 0x1Cu);
              }
            }
            else if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
            {
              AFRCGetTxInfo_cold_2();
            }
          }
        }
      }
      v29 = 0;
      *(_DWORD *)(v18 + 1068) = BWEstCalcLargeFrameSize(v18, 0);
      if (*(_BYTE *)(v18 + 1104))
        goto LABEL_39;
      v30 = v21 - *(double *)(v18 + 1056);
      if (v21 - *(double *)(v18 + 1048) >= v20 && v30 >= v20 * 0.5)
      {
        if (*(_DWORD *)(v18 + 2404) && v21 - *(double *)(v18 + 2416) > 0.5)
        {
LABEL_224:
          v29 = *(_DWORD *)(v18 + 1068);
          if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            v125 = VRTraceErrorLogLevelToCSTR();
            v117 = *MEMORY[0x1E0CF2758];
            v128 = *MEMORY[0x1E0CF2758];
            if (*MEMORY[0x1E0CF2748])
            {
              if (os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315906;
                v132 = v125;
                v133 = 2080;
                v134 = "BWEstCheckIfLargeFrameNeeded";
                v135 = 1024;
                v136 = 6199;
                v137 = 1024;
                LODWORD(v138) = v29;
                _os_log_impl(&dword_1D8A54000, v128, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d ^^^^^ LARGE frame req'd of %d ", buf, 0x22u);
              }
            }
            else if (os_log_type_enabled(v117, OS_LOG_TYPE_DEBUG))
            {
              AFRCGetTxInfo_cold_1();
            }
          }
          goto LABEL_39;
        }
        if (v30 > v20 * 3.0)
        {
          *(_DWORD *)(v18 + 1068) = BWEstCalcLargeFrameSize(v18, 1);
          if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            v127 = VRTraceErrorLogLevelToCSTR();
            v32 = *MEMORY[0x1E0CF2758];
            v33 = *MEMORY[0x1E0CF2758];
            if (*MEMORY[0x1E0CF2748])
            {
              if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
              {
                v34 = *(_DWORD *)(v18 + 1068);
                *(_DWORD *)buf = 136316162;
                v132 = v127;
                v133 = 2080;
                v134 = "BWEstCheckIfLargeFrameNeeded";
                v135 = 1024;
                v136 = 6189;
                v137 = 2048;
                v138 = *(const char **)&v30;
                v139 = 1024;
                *(_DWORD *)v140 = v34;
                _os_log_impl(&dword_1D8A54000, v32, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d ^ %.3f since last LF; CRITICAL: letting it go; size is %d ",
                  buf,
                  0x2Cu);
              }
            }
            else if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
            {
              v118 = *(_DWORD *)(v18 + 1068);
              *(_DWORD *)buf = 136316162;
              v132 = v127;
              v133 = 2080;
              v134 = "BWEstCheckIfLargeFrameNeeded";
              v135 = 1024;
              v136 = 6189;
              v137 = 2048;
              v138 = *(const char **)&v30;
              v139 = 1024;
              *(_DWORD *)v140 = v118;
              _os_log_debug_impl(&dword_1D8A54000, v32, OS_LOG_TYPE_DEBUG, "VCRC [%s] %s:%d ^ %.3f since last LF; CRITICAL: letting it go; size is %d ",
                buf,
                0x2Cu);
            }
          }
          goto LABEL_224;
        }
      }
      v29 = 0;
LABEL_39:
      *(_DWORD *)(v18 + 1064) = v29;
      *a9 = v29;
    }
  }
  if (a10 && *(_DWORD *)(v18 + 2928))
  {
    v120 = a4;
    v35 = *(_DWORD *)(v18 + 2960);
    v36 = micro();
    pthread_mutex_lock((pthread_mutex_t *)(v18 + 2560));
    v124 = *(_DWORD *)(v18 + 1392);
    v43 = *(unsigned __int8 *)(v18 + 3026);
    v44 = *(unsigned __int8 *)(v18 + 9624);
    v45 = v44 != 255 && v43 != v44;
    if (v44 == 255 || v43 != v44)
    {
      reportingLog();
      LOBYTE(v43) = *(_BYTE *)(v18 + 3026);
    }
    *(_BYTE *)(v18 + 9624) = v43;
    v122 = a6;
    v123 = a7;
    v121 = a5;
    if (v45 && *(_BYTE *)(v18 + 9664))
    {
      *(_BYTE *)(v18 + 9664) = 0;
      *(_DWORD *)(v18 + 9688) = 0;
      *(double *)(v18 + 9680) = v36;
      if ((v35 & 1) != 0)
      {
        if (*(_DWORD *)(v18 + 9692) && *(double *)(v18 + 9656) >= 1.0)
          v47 = 8;
        else
          v47 = 9;
      }
      else
      {
        if (*(_DWORD *)(v18 + 28) >= *(_DWORD *)(v18 + 9648) || *(_DWORD *)(v18 + 9572))
        {
          v47 = 0;
LABEL_102:
          *(_QWORD *)(v18 + 2968) = *(_QWORD *)(v18 + 9632);
          *(_QWORD *)(v18 + 2980) = *(_QWORD *)(v18 + 9640);
          *(_DWORD *)(v18 + 2480) = *(_DWORD *)(v18 + 9692);
          if ((v47 & v35 & 1) == 0)
          {
            *(_DWORD *)(v18 + 1400) = 6;
            v56 = *(_DWORD *)(v18 + 1404) + 1;
            *(_DWORD *)(v18 + 1404) = v56;
            *(_DWORD *)(v18 + 9568) = v56;
          }
          *(_DWORD *)(v18 + 36) = *(_DWORD *)(v18 + 28);
          v57 = *(int *)(v18 + 9648);
          *(_DWORD *)(v18 + 28) = v57;
          *(_DWORD *)(v18 + 44) = g_adwTxRateTiers[v57];
          *(_DWORD *)(v18 + 2956) = 0;
          v58 = *(double *)(v18 + 9656);
          if (*(double *)(v18 + 9576) >= v58
            || (*(double *)(v18 + 9576) = v58,
                *(double *)(v18 + 9584) = v36,
                MediaQueue_SetAudioFraction(v58),
                (int)VRTraceGetErrorLogLevelForModule() < 7))
          {
            v52 = 0;
            v53 = 0;
            v51 = 1;
          }
          else
          {
            v119 = v35;
            v59 = VRTraceErrorLogLevelToCSTR();
            v60 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              v61 = *(const char **)(v18 + 9656);
              v62 = *(_QWORD *)(v18 + 9576);
              *(_DWORD *)buf = 136316162;
              v132 = v59;
              v133 = 2080;
              v134 = "UpdateBBAction";
              v135 = 1024;
              v136 = 3261;
              v137 = 2048;
              v138 = v61;
              v139 = 2048;
              *(_QWORD *)v140 = v62;
              _os_log_impl(&dword_1D8A54000, v60, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Audio fraction change [%.2f->%.2f].", buf, 0x30u);
            }
            v52 = 0;
            v53 = 0;
            v51 = 1;
            v35 = v119;
          }
LABEL_110:
          if (*(_DWORD *)(v18 + 2472))
          {
            if ((v47 & 8) == 0)
              goto LABEL_118;
          }
          else if ((v47 & 8) == 0 || !*(_DWORD *)(v18 + 2476))
          {
            goto LABEL_118;
          }
          if ((v47 & 2) == 0 && v36 - *(double *)(v18 + 9592) > 0.1)
          {
            v47 |= 2u;
            *(double *)(v18 + 9592) = v36;
            v51 = 1;
          }
LABEL_118:
          if ((v47 & 8) != 0)
          {
            if (!*(_DWORD *)(v18 + 3032))
            {
              v47 &= 7u;
              if ((v47 & 2) == 0)
              {
LABEL_122:
                if (*(_DWORD *)(v18 + 3000))
                {
                  v47 |= 0x10u;
                  *(_DWORD *)(v18 + 3000) = 0;
                }
LABEL_128:
                if ((v52 | v53) == 1)
                {
                  v63 = v35;
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
                  {
                    v64 = VRTraceErrorLogLevelToCSTR();
                    v65 = *MEMORY[0x1E0CF2758];
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                    {
                      v66 = *(_QWORD *)(v18 + 9576);
                      v67 = "";
                      v68 = *(_QWORD *)(v18 + 2720);
                      v69 = *(_DWORD *)(v18 + 2700);
                      v70 = *(_DWORD *)(v18 + 2704);
                      if (v52)
                        v67 = "AWM";
                      if (v53)
                        v67 = "HWM";
                      *(_DWORD *)buf = 136317698;
                      v132 = v64;
                      v133 = 2080;
                      v134 = "UpdateBBAction";
                      v135 = 1024;
                      v136 = 3379;
                      v137 = 2080;
                      v138 = v67;
                      v139 = 1024;
                      *(_DWORD *)v140 = v124 / 0x3E8;
                      *(_WORD *)&v140[4] = 2048;
                      *(_QWORD *)&v140[6] = v66;
                      v141 = 2048;
                      v142 = v68;
                      v143 = 1024;
                      v144 = v69;
                      v145 = 1024;
                      v146 = v70;
                      v147 = 1024;
                      v148 = v63;
                      v149 = 1024;
                      v150 = v47;
                      _os_log_impl(&dword_1D8A54000, v65, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d %s is hit, [audio:%u, factor:%.2f, FEC:%.2f, RED:%u, %u, %02X->%02X]", buf, 0x58u);
                    }
                  }
                }
                else if ((!v51 & ~v45) != 0)
                {
                  goto LABEL_142;
                }
                v71 = "AWM is hit! ";
                if (!v52)
                  v71 = "";
                if (v53)
                  v71 = "HWM is hit! ";
                VRLogfilePrintWithTimestamp(*(_QWORD *)(v18 + 2848), "%s%sAudio[%u %.2f %.2f %u %u], Action[%02X->%02X(%u)]%s.\n", v37, v38, v39, v40, v41, v42, (char)v71);
LABEL_142:
                v19 = a10;
                a5 = v121;
                if (*(_DWORD *)(v18 + 2956))
                {
                  v72 = *(_DWORD *)(v18 + 28);
                  v73 = *(int *)(v18 + 40);
                  v74 = v72;
                  while (g_adwTxRateTiers[v74] > *(_DWORD *)(v18 + 2968))
                  {
                    --v74;
                    if (*(_DWORD *)(v18 + 9696) || v74 <= v73)
                    {
                      if ((int)v74 <= (int)v73)
                        LODWORD(v74) = *(_DWORD *)(v18 + 40);
                      break;
                    }
                  }
                  if (v72 != (_DWORD)v74)
                  {
                    *(_DWORD *)(v18 + 1400) = 3;
                    v75 = *(_DWORD *)(v18 + 1404) + 1;
                    *(_DWORD *)(v18 + 1404) = v75;
                    *(_DWORD *)(v18 + 36) = v72;
                    *(_DWORD *)(v18 + 28) = v74;
                    *(_DWORD *)(v18 + 44) = g_adwTxRateTiers[(int)v74];
                    *(_DWORD *)(v18 + 9568) = v75;
                    *(_DWORD *)(v18 + 2484) = 1;
                    if (*(_DWORD *)(v18 + 2816))
                    {
                      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
                      {
                        v76 = VRTraceErrorLogLevelToCSTR();
                        v77 = *MEMORY[0x1E0CF2758];
                        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                        {
                          v78 = *(_DWORD *)(v18 + 44);
                          *(_DWORD *)buf = 136315906;
                          v132 = v76;
                          v133 = 2080;
                          v134 = "RampDownTxRate";
                          v135 = 1024;
                          v136 = 3170;
                          v137 = 1024;
                          LODWORD(v138) = v78;
                          _os_log_impl(&dword_1D8A54000, v77, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d AFRC: Congestion!!! TxRate v %u, Baseband.", buf, 0x22u);
                        }
                      }
                    }
                    VRLogfilePrint(*(_QWORD *)(v18 + 2832), "Congestion!!! TxRate v %u, Baseband.\n", v37, v38, v39, v40, v41, v42, *(_DWORD *)(v18 + 44));
                    VRLogfilePrintWithTimestamp(*(_QWORD *)(v18 + 2848), "Rate change [%u] (Ramp Down to %u, Baseband).\n", v79, v80, v81, v82, v83, v84, *(_DWORD *)(v18 + 9568));
                  }
                  v85 = *(_DWORD *)(v18 + 1396);
                  if ((v85 & 1) != 0)
                  {
                    *(_DWORD *)(v18 + 1396) = v85 & 0xFFFFFFFE;
                    calculateInitialRampUpDeltas(v18);
                    if (*(_DWORD *)(v18 + 2816))
                    {
                      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
                      {
                        v92 = VRTraceErrorLogLevelToCSTR();
                        v93 = *MEMORY[0x1E0CF2758];
                        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                        {
                          *(_DWORD *)buf = 136315906;
                          v132 = v92;
                          v133 = 2080;
                          v134 = "RampDownTxRate";
                          v135 = 1024;
                          v136 = 3179;
                          v137 = 2080;
                          v138 = "Initial Rampup done!";
                          _os_log_impl(&dword_1D8A54000, v93, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d AFRC: %s", buf, 0x26u);
                        }
                      }
                    }
                    VRLogfilePrint(*(_QWORD *)(v18 + 2832), "%s", v86, v87, v88, v89, v90, v91, (char)"Initial Rampup done!\n");
                    VRLogfilePrintWithTimestamp(*(_QWORD *)(v18 + 2848), "%s", v94, v95, v96, v97, v98, v99, (char)"Initial Rampup done!\n");
                    v85 = *(_DWORD *)(v18 + 1396);
                  }
                  if ((v85 & 4) != 0)
                    *(_DWORD *)(v18 + 1396) = v85 & 0xFFFFFFFB;
                  if (*(_DWORD *)(v18 + 1400) == 3)
                  {
                    v100 = *(_DWORD *)(v18 + 2552) + 1;
                    *(_DWORD *)(v18 + 2552) = v100;
                    v101 = *(double *)(v18 + 2544);
                    if (v101 == 0.0)
                    {
                      *(double *)(v18 + 2544) = v36;
                    }
                    else if (v36 - v101 >= 2.0)
                    {
                      *(_DWORD *)(v18 + 2552) = 0;
                      *(_QWORD *)(v18 + 2544) = 0;
                    }
                    else if (v100 >= 4)
                    {
                      *(_DWORD *)(v18 + 2408) = 1;
                    }
                  }
                  *(double *)(v18 + 2520) = v36;
                }
                if ((v47 & 1) != 0)
                {
                  if (*(_BYTE *)(v18 + 9836))
                  {
                    if (*(_DWORD *)(v18 + 2480))
                    {
                      *(_DWORD *)(v18 + 2480) = 0;
                      v102 = 1;
                      goto LABEL_181;
                    }
                    v103 = 1;
                    v102 = 1;
                    goto LABEL_180;
                  }
                  v47 &= ~1u;
                }
                if (*(_DWORD *)(v18 + 2480))
                {
                  v102 = 0;
                  goto LABEL_181;
                }
                v102 = 0;
                v103 = *(unsigned __int8 *)(v18 + 9836);
LABEL_180:
                v47 |= v103;
LABEL_181:
                v104 = *(_DWORD *)(v18 + 2960);
                if (!*(_DWORD *)(v18 + 2472) && (v47 & 1) == 0 && (v104 & 1) != 0)
                {
                  *(_DWORD *)(v18 + 1400) = 5;
                  v105 = *(_DWORD *)(v18 + 1404) + 1;
                  *(_DWORD *)(v18 + 1404) = v105;
                  *(_DWORD *)(v18 + 9568) = v105;
                }
                if (((v104 ^ v47) & 1) != 0 && *(_BYTE *)(v18 + 9836))
                {
                  if ((v47 & 1) != 0)
                    *(_DWORD *)(v18 + 1388) = 0;
                  v106 = "Resumed";
                  if (*(_DWORD *)(v18 + 2816))
                  {
                    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
                    {
                      v107 = VRTraceErrorLogLevelToCSTR();
                      v108 = *MEMORY[0x1E0CF2758];
                      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                      {
                        if ((v47 & 1) != 0)
                          v109 = "Stopped";
                        else
                          v109 = "Resumed";
                        *(_DWORD *)buf = 136315906;
                        v132 = v107;
                        v133 = 2080;
                        v134 = "UpdateBBAction";
                        v135 = 1024;
                        v136 = 3435;
                        v137 = 2080;
                        v138 = v109;
                        _os_log_impl(&dword_1D8A54000, v108, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d AFRC: Video %s...", buf, 0x26u);
                      }
                    }
                  }
                  if ((v47 & 1) != 0)
                    v106 = "Stopped";
                  VRLogfilePrint(*(_QWORD *)(v18 + 2832), "Video %s...\n", v37, v38, v39, v40, v41, v42, (char)v106);
                  VRLogfilePrintWithTimestamp(*(_QWORD *)(v18 + 2848), "Video %s...\n", v110, v111, v112, v113, v114, v115, (char)v106);
                }
                *(_DWORD *)(v18 + 2476) = v102;
                *(_DWORD *)(v18 + 2960) = v47;
                pthread_mutex_unlock((pthread_mutex_t *)(v18 + 2560));
                a6 = v122;
                a7 = v123;
                a4 = v120;
                goto LABEL_200;
              }
LABEL_125:
              if (*(_DWORD *)(v18 + 3032))
              {
                ++*(_DWORD *)(v18 + 2988);
                *(double *)(v18 + 2992) = v36;
              }
              else
              {
                v47 &= ~2u;
              }
              goto LABEL_128;
            }
            ++*(_DWORD *)(v18 + 2988);
            *(double *)(v18 + 2992) = v36;
          }
          if ((v47 & 2) == 0)
            goto LABEL_122;
          goto LABEL_125;
        }
        *(double *)(v18 + 9592) = v36;
        v47 = 10;
      }
      *(double *)(v18 + 9600) = v36;
      goto LABEL_102;
    }
    v48 = *(_DWORD *)(v18 + 2980);
    if (v48 < 0x7D1 || ((v49 = *(double *)(v18 + 2504), v49 != 0.0) ? (v50 = v36 - v49 <= 0.5) : (v50 = 1), v50))
    {
      if (!*(_DWORD *)(v18 + 2956))
      {
        if ((v35 & 1) != 0
          && (*(double *)(v18 + 9576) < 1.0
           || v36 - *(double *)(v18 + 9584) <= 2.0
           || v36 - *(double *)(v18 + 9552) <= 2.0))
        {
          v51 = 0;
          v52 = 0;
          v53 = 0;
          v47 = 1;
        }
        else
        {
          v51 = 0;
          v52 = 0;
          v53 = 0;
          v47 = 0;
        }
        goto LABEL_110;
      }
      v47 = v35 & 1;
      if (v48 <= 0x1F3)
      {
        v51 = (v35 & 1) != 0
           && (*(double *)(v18 + 9576) < 1.0
            || v36 - *(double *)(v18 + 9584) <= 2.0
            || v36 - *(double *)(v18 + 9552) <= 2.0);
        v53 = 0;
        *(_DWORD *)(v18 + 2956) = 0;
        v52 = 1;
        v47 = v51;
        goto LABEL_110;
      }
      v51 = 0;
LABEL_98:
      v52 = 0;
      v53 = 0;
      goto LABEL_110;
    }
    v54 = *(_DWORD *)(v18 + 2968);
    if (v54 >= v124)
    {
      if (v54 >= g_adwTxRateTiers[*(int *)(v18 + 40)])
      {
        if ((v35 & 1) == 0)
        {
          if (*(_DWORD *)(v18 + 3036) + *(_DWORD *)(v18 + 3032) > 2 * (v54 >> 3) && v36 - *(double *)(v18 + 9592) > 0.1)
          {
            v55 = (double *)(v18 + 9592);
            v47 = 2;
            goto LABEL_95;
          }
          v51 = 0;
          v47 = 0;
LABEL_97:
          if (!*(_DWORD *)(v18 + 2956))
          {
            v52 = 0;
            v53 = 1;
            *(_DWORD *)(v18 + 2956) = 1;
            goto LABEL_110;
          }
          goto LABEL_98;
        }
      }
      else if ((v35 & 1) == 0)
      {
        v55 = (double *)(v18 + 9592);
        v47 = 3;
        goto LABEL_95;
      }
    }
    else
    {
      if ((v35 & 1) == 0)
      {
        *(double *)(v18 + 9592) = v36;
        v55 = (double *)(v18 + 9600);
        v47 = 11;
LABEL_95:
        *v55 = v36;
        v51 = 1;
        goto LABEL_97;
      }
      if (*(_DWORD *)(v18 + 3036) + *(_DWORD *)(v18 + 3032) > ((v124 >> 2) & 0x1FFFFFFF)
        && v36 - *(double *)(v18 + 9600) > 0.1)
      {
        v55 = (double *)(v18 + 9600);
        v47 = 9;
        goto LABEL_95;
      }
    }
    v51 = 0;
    v47 = 1;
    goto LABEL_97;
  }
LABEL_200:
  if (a2)
    *a2 = *(_DWORD *)(v18 + 44);
  if (a8)
    *a8 = *(_DWORD *)(v18 + 1392);
  if (a3)
    *a3 = *(_QWORD *)(v18 + 2720);
  if (a4)
    *a4 = *(_DWORD *)(v18 + 2700);
  if (a5)
    *a5 = *(_DWORD *)(v18 + 2704);
  if (a6)
    *a6 = *(_QWORD *)(v18 + 2736);
  if (a7)
    *a7 = *(_DWORD *)(v18 + 1404);
  if (v19)
    *v19 = *(_DWORD *)(v18 + 2960);
  v116 = Throttling_AFRC_IsInThrottlingMode((_BYTE *)(v18 + 872), *(_DWORD *)(v18 + 44));
  *(_BYTE *)(v18 + 884) = v116;
  if (a11)
    *a11 = v116;
  if (a12)
    *a12 = *(_DWORD *)(v18 + 252);
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCRecordMaxBurstyLoss(uint64_t a1, unsigned int a2)
{
  uint64_t v3;
  uint64_t v4;
  pthread_mutex_t *v5;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149646338;
  v4 = v3;
  v5 = (pthread_mutex_t *)(v3 + 2864);
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 2864));
  if (*(_DWORD *)(v4 + 140) < a2)
    *(_DWORD *)(v4 + 140) = a2;
  pthread_mutex_unlock(v5);
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCRecordMaxAudioConsecutiveLoss(uint64_t a1, unsigned int a2)
{
  uint64_t v3;
  uint64_t v4;
  pthread_mutex_t *v5;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149646338;
  v4 = v3;
  v5 = (pthread_mutex_t *)(v3 + 2864);
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 2864));
  if (*(_DWORD *)(v4 + 144) < a2)
    *(_DWORD *)(v4 + 144) = a2;
  pthread_mutex_unlock(v5);
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCUpdateVideoSendingBitrate(uint64_t a1, int a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149646338;
  *(_DWORD *)(v3 + 1388) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCUpdateAudioSendingBitrate(uint64_t a1, int a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149646338;
  *(_DWORD *)(v3 + 1392) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCSetFeedbackControlInfo(uint64_t a1, void *a2)
{
  uint64_t v3;
  uint64_t v4;
  pthread_mutex_t *v5;
  double v6;
  int v7;
  int v8;
  int v9;
  _BYTE *v11;
  unint64_t v12;
  uint64_t v13;
  NSObject *v14;
  NSObject *v15;
  unsigned int v16;
  double v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  double v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  uint8_t buf[4];
  uint64_t v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  int v30;
  __int16 v31;
  unsigned int v32;
  __int16 v33;
  unsigned int v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149646338;
  v4 = v3;
  v24 = 0;
  v22 = 0u;
  v23 = 0u;
  v5 = (pthread_mutex_t *)(v3 + 2864);
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 2864));
  if (a2)
  {
    v6 = *(double *)(v4 + 672) / 1000.0;
    v7 = *(_DWORD *)(v4 + 116);
    LOWORD(v22) = *(_DWORD *)(v4 + 112);
    WORD1(v22) = (int)v6;
    v8 = *(_DWORD *)(v4 + 136);
    WORD2(v22) = *(_DWORD *)(v4 + 140);
    WORD5(v22) = *(_DWORD *)(v4 + 128);
    WORD3(v22) = v8;
    v9 = *(_DWORD *)(v4 + 164);
    HIDWORD(v22) = (*(_DWORD *)(v4 + 120) + v7) >> 3;
    LODWORD(v23) = v9;
    WORD4(v22) = *(_DWORD *)(v4 + 144);
    *(_DWORD *)(v4 + 140) = 0;
    *(_DWORD *)(v4 + 144) = 0;
    pthread_mutex_unlock(v5);
    VCMediaControlInfoSetInfoUnserialized(a2, (const char *)&v22, 0);
  }
  else
  {
    *(_DWORD *)(v4 + 140) = 0;
    *(_DWORD *)(v4 + 144) = 0;
    pthread_mutex_unlock(v5);
  }
  v11 = (_BYTE *)(v4 + 9776);
  VCRateControlGetBWEstimation(*(void **)(v4 + 9760), (_DWORD *)(v4 + 688));
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v13 = VRTraceErrorLogLevelToCSTR();
    v14 = *MEMORY[0x1E0CF2758];
    v15 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        v16 = *(_DWORD *)(v4 + 688);
        v17 = *(double *)(v4 + 672) / 1000.0;
        *(_DWORD *)buf = 136316162;
        v26 = v13;
        v27 = 2080;
        v28 = "AFRCSetFeedbackControlInfo";
        v29 = 1024;
        v30 = 3621;
        v31 = 1024;
        v32 = v16 / 0x3E8;
        v33 = 1024;
        v34 = v17;
        _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Bandwidth estimation new: %d, afrc:%d", buf, 0x28u);
      }
    }
    else if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      v20 = *(_DWORD *)(v4 + 688);
      v21 = *(double *)(v4 + 672) / 1000.0;
      *(_DWORD *)buf = 136316162;
      v26 = v13;
      v27 = 2080;
      v28 = "AFRCSetFeedbackControlInfo";
      v29 = 1024;
      v30 = 3621;
      v31 = 1024;
      v32 = v20 / 0x3E8;
      v33 = 1024;
      v34 = v21;
      _os_log_debug_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEBUG, "VCRC [%s] %s:%d Bandwidth estimation new: %d, afrc:%d", buf, 0x28u);
    }
  }
  v18 = *(_DWORD *)(v4 + 9796);
  if (v18)
  {
    LODWORD(v12) = *(_DWORD *)(v4 + 44);
    if (RateMonitorUpdateDataSamples(*(_QWORD *)(v4 + 9768), (double)v12, (double)v18))
    {
      if (!*v11)
      {
        reportingSymptom();
        *v11 = 1;
      }
    }
  }
  v19 = *(_DWORD *)(v4 + 688);
  if (v19
    && RateMonitorUpdateDataSamples(*(_QWORD *)(v4 + 9784), *(double *)(v4 + 672), (double)v19)
    && !*(_BYTE *)(v4 + 9792))
  {
    reportingSymptom();
    *(_BYTE *)(v4 + 9792) = 1;
  }
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCGetPeerArrivalTime(uint64_t a1, int a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  pthread_mutex_t *v7;

  v5 = CheckInHandleDebug();
  if (!v5)
    return 2149646338;
  if (!a2)
  {
    v6 = v5;
    v7 = (pthread_mutex_t *)(v5 + 2864);
    pthread_mutex_lock((pthread_mutex_t *)(v5 + 2864));
    *a3 = *(_QWORD *)(v6 + 152);
    pthread_mutex_unlock(v7);
  }
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCGenerateFeedbackWithControlInfo(void *a1, int32x4_t *a2)
{
  int32x4_t v4;
  __int32 v5;
  uint64_t result;
  unsigned int v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (!a2)
    return 2149580801;
  if (!a1)
    return 0;
  if (VCMediaControlInfoHasInfo(a1, 0))
  {
    v10 = 0;
    v8 = 0u;
    v9 = 0u;
    VCMediaControlInfoGetInfoUnserialized(a1, (const char *)&v8, 0);
    a2->i32[0] = (unsigned __int16)v8;
    a2->i32[2] = WORD1(v8);
    v4 = (int32x4_t)vmovl_u16(*(uint16x4_t *)((char *)&v8 + 4));
    a2[1] = vuzp1q_s32(v4, (int32x4_t)vextq_s8((int8x16_t)v4, (int8x16_t)v4, 0xCuLL));
    a2[2].i32[0] = v9;
  }
  if (VCMediaControlInfoHasInfo(a1, (const char *)1))
  {
    v10 = 0;
    v8 = 0u;
    v9 = 0u;
    VCMediaControlInfoGetInfoUnserialized(a1, (const char *)&v8, 1);
    a2->i32[1] = DWORD1(v9);
    v5 = HIDWORD(v9);
    a2[2].i32[1] = WORD4(v9);
    a2[2].i32[2] = v5;
  }
  result = VCMediaControlInfoHasInfo(a1, (const char *)2);
  if ((_DWORD)result)
  {
    LODWORD(v8) = -1431655766;
    VCMediaControlInfoGetInfo(a1, (const char *)2, (uint64_t)&v8, 4, 0);
    result = 0;
    v7 = bswap32(v8);
  }
  else
  {
    v7 = -1;
  }
  a2[2].i32[3] = v7;
  return result;
}

uint64_t AFRCProcessVideoReceiveMetric(uint64_t a1, int a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  pthread_mutex_t *v7;

  v5 = CheckInHandleDebug();
  if (!v5)
    return 2149646338;
  v6 = v5;
  v7 = (pthread_mutex_t *)(v5 + 2864);
  pthread_mutex_lock((pthread_mutex_t *)(v5 + 2864));
  *(_DWORD *)(v6 + 132) = a2;
  *(_DWORD *)(v6 + 120) = a3;
  pthread_mutex_unlock(v7);
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCProcessFeedbackPacket(double a1, double a2, double a3, uint64_t a4, uint64_t a5, int a6, int a7, int a8, int a9, int a10)
{
  unint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  pthread_mutex_t *v24;
  int v25;
  _DWORD *v26;
  unsigned int v27;
  int v28;
  unsigned int v30;
  unsigned int v31;
  int v32;
  unsigned int v33;
  BOOL v34;
  unsigned int v35;
  int v36;
  double v37;
  double v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  double v46;
  double v47;
  _BOOL4 v48;
  double v49;
  int v50;
  _BOOL4 v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  int v58;
  uint64_t v59;
  int *v60;
  int v61;
  int v62;
  int v63;
  int v64;
  uint64_t v65;
  NSObject *v66;
  int v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  NSObject *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  int v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  NSObject *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  unsigned int v97;
  double v98;
  double v99;
  double v100;
  uint64_t v101;
  NSObject *v102;
  uint64_t v103;
  int v104;
  int v105;
  int v106;
  int v107;
  uint64_t v108;
  NSObject *v109;
  int v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  int v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  NSObject *v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  int v132;
  int v133;
  uint64_t v134;
  unsigned int v135;
  int v137;
  int v138;
  uint8_t buf[4];
  uint64_t v140;
  __int16 v141;
  const char *v142;
  __int16 v143;
  int v144;
  __int16 v145;
  const char *v146;
  __int16 v147;
  uint64_t v148;
  uint64_t v149;

  v149 = *MEMORY[0x1E0C80C00];
  v19 = MicroToNTP(a1);
  v20 = NTPToMiddle32(v19);
  v21 = CheckInHandleDebug();
  if (!v21)
    return 2149646338;
  v22 = v21;
  v137 = a9;
  v23 = (_QWORD *)(v21 + 268);
  v24 = (pthread_mutex_t *)(v21 + 2864);
  pthread_mutex_lock((pthread_mutex_t *)(v21 + 2864));
  v25 = *(_DWORD *)(a5 + 36);
  *(_DWORD *)(v22 + 252) = *(_DWORD *)(a5 + 8);
  v26 = (_DWORD *)(v22 + 252);
  *(_DWORD *)(v22 + 128) = a7;
  *(_DWORD *)(v22 + 112) = v25;
  *(_DWORD *)(v22 + 116) = a8;
  *(_DWORD *)(v22 + 160) = a6;
  *(_DWORD *)(v22 + 136) = *(_DWORD *)(v22 + 132);
  *v23 = *(_QWORD *)(a5 + 24);
  *(_DWORD *)(v22 + 264) = *(_DWORD *)(a5 + 12);
  *(_DWORD *)(v22 + 276) = *(_DWORD *)(a5 + 16);
  pthread_mutex_unlock(v24);
  pthread_mutex_lock((pthread_mutex_t *)(v22 + 2560));
  *(double *)(v22 + 152) = a1;
  pthread_mutex_unlock((pthread_mutex_t *)(v22 + 2560));
  Throttling_AFRC_OverrideRxEstimate(v22 + 872, (_DWORD *)(v22 + 252));
  v27 = *(_DWORD *)(a5 + 36);
  if (*(_DWORD *)(v22 + 168))
  {
    v28 = *(_DWORD *)(v22 + 172);
    if (v27 == (unsigned __int16)v28 || (unsigned __int16)(v27 - v28) >= 0x7FFFu)
      goto LABEL_139;
    if ((unsigned __int16)*(_DWORD *)(a5 + 36) < (unsigned __int16)v28)
      v28 += 0x10000;
    v27 |= v28 & 0xFFFF0000;
    *(_DWORD *)(v22 + 172) = v27;
  }
  else
  {
    *(_DWORD *)(v22 + 168) = 1;
    *(_DWORD *)(v22 + 172) = v27;
  }
  v30 = *(_DWORD *)(a5 + 4);
  if (v30)
  {
    v31 = (unsigned __int16)(v20 >> 6);
    v32 = *(_DWORD *)a5;
    if (v31 < *(_DWORD *)a5)
      v31 |= 0x10000u;
    v33 = v31 - v32;
    v34 = v33 >= v30;
    v35 = v33 - v30;
    if (v35 == 0 || !v34)
      v35 = 1;
    v36 = *(_DWORD *)(v22 + 52);
    if (v36)
      v35 = (9 * v36 + v35) / 0xA;
    *(_DWORD *)(v22 + 52) = v35;
  }
  else
  {
    v35 = *(_DWORD *)(v22 + 52);
    v32 = -1;
  }
  *(_DWORD *)(v22 + 260) = v32;
  v37 = (double)v35 * 0.0009765625;
  v38 = *(double *)(v22 + 56);
  if (v38 <= v37)
    v38 = (double)v35 * 0.0009765625;
  *(double *)(v22 + 56) = v38;
  v39 = *(_DWORD *)(v22 + 64);
  if (v39 <= *(_DWORD *)(a5 + 16))
    v39 = *(_DWORD *)(a5 + 16);
  *(_DWORD *)(v22 + 64) = v39;
  v46 = RTPUnpackDouble(*(_DWORD *)(a5 + 40));
  if (a2 >= 0.0)
    *(double *)(v22 + 176) = a2;
  if (a3 >= 0.0)
    *(double *)(v22 + 184) = a3;
  if (v137 != -1)
    *(_DWORD *)(v22 + 248) = v137;
  if (a10 != -1)
    *(_DWORD *)(v22 + 256) = a10;
  v47 = (double)v27 * 0.0009765625;
  VRLogfilePrint(*(_QWORD *)(v22 + 2840), "%04X\t%u\t%u\t%u\t%u\t%u\t%04X\t%u\n", v40, v41, v42, v43, v44, v45, *(_WORD *)a5);
  UpdateFECLevel(v22);
  v48 = *(_DWORD *)(a5 + 40) != 0xFFFF;
  v138 = -1431655766;
  v49 = micro();
  pthread_mutex_lock((pthread_mutex_t *)(v22 + 2560));
  if (!*(_DWORD *)(v22 + 2472))
  {
    if ((*(_BYTE *)(v22 + 1396) & 1) == 0
      || *(_DWORD *)(v22 + 2948)
      || *(_DWORD *)(v22 + 2952)
      || *(_DWORD *)(v22 + 9696))
    {
      v50 = *(_DWORD *)(v22 + 28) + 1;
    }
    else
    {
      v105 = *(_DWORD *)(v22 + 28);
      if (g_adwTxRateTiers[v105 + 2] > *(_DWORD *)(v22 + 20))
        v50 = v105 + 1;
      else
        v50 = v105 + 2;
    }
    v51 = v50 <= 36 && g_adwTxRateTiers[v50] <= *(_DWORD *)(v22 + 20);
    v138 = v51;
    DetectCongestion(v22, v32, &v138, v48, v47, v46, v37);
    v58 = *(_DWORD *)(v22 + 1396);
    if ((v58 & 2) == 0)
    {
      if ((v58 & 9) != 0 && v138)
      {
        if ((*(_BYTE *)(v22 + 2960) & 1) != 0)
        {
          v99 = *(double *)(v22 + 9576);
          if (v99 >= 1.0)
          {
            *(_DWORD *)(v22 + 2480) = 1;
          }
          else if (*(int *)(v22 + 9572) >= 1 && v49 - *(double *)(v22 + 9584) > 2.0)
          {
            v100 = fmin(v99 + v99, 1.0);
            *(double *)(v22 + 9576) = v100;
            *(double *)(v22 + 9584) = v49;
            MediaQueue_SetAudioFraction(v100);
            *(_DWORD *)(v22 + 9572) = 0;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v101 = VRTraceErrorLogLevelToCSTR();
              v102 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                v103 = *(_QWORD *)(v22 + 9576);
                *(_DWORD *)buf = 136316162;
                v140 = v101;
                v141 = 2080;
                v142 = "DoRateControl";
                v143 = 1024;
                v144 = 4282;
                v145 = 2048;
                v146 = *(const char **)&v99;
                v147 = 2048;
                v148 = v103;
                _os_log_impl(&dword_1D8A54000, v102, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Audio fraction change [%.2f->%.2f].", buf, 0x30u);
              }
            }
          }
          v104 = *(_DWORD *)(v22 + 1396);
          if ((v104 & 1) != 0)
          {
            *(_DWORD *)(v22 + 1396) = v104 & 0xFFFFFFFE;
            calculateInitialRampUpDeltas(v22);
            v104 = *(_DWORD *)(v22 + 1396);
          }
          if ((v104 & 8) == 0)
            goto LABEL_134;
        }
        else
        {
          if ((v58 & 1) == 0)
          {
            if (*(_DWORD *)(v22 + 2944))
            {
              if (v50 <= 35 && *v26)
              {
                v59 = v50 - 36;
                v60 = &g_adwTxRateTiers[v50 + 1];
                while (*v60 < *(_DWORD *)(v22 + 20)
                     && (*(v60 - 1) - *(_DWORD *)(v22 + 44)) >> 8 <= 0x7C
                     && 1000 * *v26 > v60[1])
                {
                  ++v50;
                  ++v60;
                  v34 = __CFADD__(v59++, 1);
                  if (v34)
                  {
                    v50 = 36;
                    break;
                  }
                }
              }
            }
            else
            {
              if (!*(_DWORD *)(v22 + 2948)
                && !*(_DWORD *)(v22 + 2952)
                && !*(_DWORD *)(v22 + 9696)
                && v50 <= 35
                && *(double *)(v22 + 2512) <= *(double *)(v22 + 2520))
              {
                v133 = *(_DWORD *)(v22 + 9572);
                v134 = v50 + 1;
                while (1)
                {
                  v135 = g_adwTxRateTiers[v134];
                  if (v135 >= *(_DWORD *)(v22 + 20))
                    break;
                  if (v135 - *(_DWORD *)(v22 + 44) > 0xFA00 || v133 <= 0)
                    break;
                  --v133;
                  ++v50;
                  ++v134;
                  v106 = 36;
                  if (v134 == 37)
                    goto LABEL_119;
                }
              }
              v106 = v50;
LABEL_119:
              *(_DWORD *)(v22 + 9572) = 0;
              v50 = v106;
            }
          }
          *(_DWORD *)(v22 + 36) = *(_DWORD *)(v22 + 28);
          *(_DWORD *)(v22 + 28) = v50;
          *(_DWORD *)(v22 + 44) = g_adwTxRateTiers[v50];
          *(_DWORD *)(v22 + 1400) = 2;
          v107 = *(_DWORD *)(v22 + 1404) + 1;
          *(_DWORD *)(v22 + 1404) = v107;
          *(_DWORD *)(v22 + 9568) = v107;
          *(_DWORD *)(v22 + 2552) = 0;
          *(_QWORD *)(v22 + 2544) = 0;
          if (*(_DWORD *)(v22 + 2816))
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v108 = VRTraceErrorLogLevelToCSTR();
              v109 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                v110 = *(_DWORD *)(v22 + 44);
                *(_DWORD *)buf = 136315906;
                v140 = v108;
                v141 = 2080;
                v142 = "DoRateControl";
                v143 = 1024;
                v144 = 4250;
                v145 = 1024;
                LODWORD(v146) = v110;
                _os_log_impl(&dword_1D8A54000, v109, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d AFRC: TxRate ^ %u", buf, 0x22u);
              }
            }
          }
          VRLogfilePrint(*(_QWORD *)(v22 + 2832), "TxRate ^ %u\n", v52, v53, v54, v55, v56, v57, *(_DWORD *)(v22 + 44));
          VRLogfilePrintWithTimestamp(*(_QWORD *)(v22 + 2848), "Rate change [%u] (Ramp Up to %u).\n", v111, v112, v113, v114, v115, v116, *(_DWORD *)(v22 + 9568));
          if (v50 > 35 || g_adwTxRateTiers[v50 + 1] >= *(_DWORD *)(v22 + 20))
          {
            v117 = *(_DWORD *)(v22 + 1396);
            if ((v117 & 1) != 0)
            {
              *(_DWORD *)(v22 + 1396) = v117 & 0xFFFFFFFE;
              calculateInitialRampUpDeltas(v22);
              if (*(_DWORD *)(v22 + 2816))
              {
                if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
                {
                  v124 = VRTraceErrorLogLevelToCSTR();
                  v125 = *MEMORY[0x1E0CF2758];
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 136315906;
                    v140 = v124;
                    v141 = 2080;
                    v142 = "DoRateControl";
                    v143 = 1024;
                    v144 = 4260;
                    v145 = 2080;
                    v146 = "Initial Rampup Done!";
                    _os_log_impl(&dword_1D8A54000, v125, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d AFRC: %s", buf, 0x26u);
                  }
                }
              }
              VRLogfilePrint(*(_QWORD *)(v22 + 2832), "%s", v118, v119, v120, v121, v122, v123, (char)"Initial Rampup Done!\n");
              VRLogfilePrintWithTimestamp(*(_QWORD *)(v22 + 2848), "%s", v126, v127, v128, v129, v130, v131, (char)"Initial Rampup Done!\n");
            }
          }
          v104 = *(_DWORD *)(v22 + 1396);
        }
        *(_DWORD *)(v22 + 1396) = v104 & 0xFFFFFFF7;
      }
LABEL_134:
      if (v49 - *(double *)(v22 + 104) > 3.0)
      {
        ConfigureAFRCDefaults(v22);
        *(double *)(v22 + 104) = v49;
      }
      v132 = *(_DWORD *)(v22 + 68);
      if ((v132 & 0x80000000) == 0)
        *(_DWORD *)(v22 + 44) = v132;
      pthread_mutex_unlock((pthread_mutex_t *)(v22 + 2560));
      goto LABEL_139;
    }
    v61 = *(_DWORD *)(v22 + 28);
    if (v61 <= 0)
    {
      *(_DWORD *)(v22 + 1396) = v58 & 0xFFFFFFED;
    }
    else
    {
      if ((v58 & 1) != 0 && !*(_DWORD *)(v22 + 9696))
      {
        if (v61 == *(_DWORD *)(v22 + 32))
          v62 = -3;
        else
          v62 = -2;
      }
      else
      {
        v62 = -1;
      }
      v63 = v62 + v61;
      if ((v58 & 0x10) == 0 && !*(_DWORD *)(v22 + 9696))
        v63 = (__PAIR64__(v63, (*(_DWORD *)(v22 + 44) - g_adwTxRateTiers[v63]) >> 8) - 125) >> 32;
      if (v63 <= *(_DWORD *)(v22 + 40))
        v63 = *(_DWORD *)(v22 + 40);
      *(_DWORD *)(v22 + 1396) = v58 & 0xFFFFFFED;
      if (v61 > v63)
      {
        *(_DWORD *)(v22 + 1400) = 3;
        v64 = *(_DWORD *)(v22 + 1404) + 1;
        *(_DWORD *)(v22 + 1404) = v64;
        *(_DWORD *)(v22 + 36) = v61;
        *(_DWORD *)(v22 + 28) = v63;
        *(_DWORD *)(v22 + 44) = g_adwTxRateTiers[v63];
        *(_DWORD *)(v22 + 9568) = v64;
        if (!v63 && *(_DWORD *)(v22 + 9696))
          *(double *)(v22 + 2520) = v49;
        if (*(_DWORD *)(v22 + 2816))
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v65 = VRTraceErrorLogLevelToCSTR();
            v66 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              v67 = *(_DWORD *)(v22 + 44);
              *(_DWORD *)buf = 136315906;
              v140 = v65;
              v141 = 2080;
              v142 = "DoRateControl";
              v143 = 1024;
              v144 = 4177;
              v145 = 1024;
              LODWORD(v146) = v67;
              _os_log_impl(&dword_1D8A54000, v66, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d AFRC: Congestion!!! TxRate v %u", buf, 0x22u);
            }
          }
        }
        VRLogfilePrint(*(_QWORD *)(v22 + 2832), "Congestion!!! TxRate v %u\n", v52, v53, v54, v55, v56, v57, *(_DWORD *)(v22 + 44));
        VRLogfilePrintWithTimestamp(*(_QWORD *)(v22 + 2848), "Rate change [%u] (Ramp Down to %u, AFRC).\n", v68, v69, v70, v71, v72, v73, *(_DWORD *)(v22 + 9568));
LABEL_83:
        *(double *)(v22 + 2512) = v49;
        v82 = *(_DWORD *)(v22 + 1396);
        if ((v82 & 1) != 0)
        {
          *(_DWORD *)(v22 + 1396) = v82 & 0xFFFFFFFE;
          calculateInitialRampUpDeltas(v22);
          if (*(_DWORD *)(v22 + 2816))
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v89 = VRTraceErrorLogLevelToCSTR();
              v90 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315906;
                v140 = v89;
                v141 = 2080;
                v142 = "DoRateControl";
                v143 = 1024;
                v144 = 4197;
                v145 = 2080;
                v146 = "Initial Rampup done!";
                _os_log_impl(&dword_1D8A54000, v90, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d AFRC: %s", buf, 0x26u);
              }
            }
          }
          VRLogfilePrint(*(_QWORD *)(v22 + 2832), "%s", v83, v84, v85, v86, v87, v88, (char)"Initial Rampup done!\n");
          VRLogfilePrintWithTimestamp(*(_QWORD *)(v22 + 2848), "%s", v91, v92, v93, v94, v95, v96, (char)"Initial Rampup Done!\n");
          v82 = *(_DWORD *)(v22 + 1396);
        }
        if ((v82 & 4) != 0)
          *(_DWORD *)(v22 + 1396) = v82 & 0xFFFFFFFB;
        if (*(_DWORD *)(v22 + 1400) == 3)
        {
          v97 = *(_DWORD *)(v22 + 2552) + 1;
          *(_DWORD *)(v22 + 2552) = v97;
          v98 = *(double *)(v22 + 2544);
          if (v98 == 0.0)
          {
            *(double *)(v22 + 2544) = v49;
          }
          else if (v49 - v98 >= 2.0)
          {
            *(_DWORD *)(v22 + 2552) = 0;
            *(_QWORD *)(v22 + 2544) = 0;
          }
          else if (v97 >= 4)
          {
            *(_DWORD *)(v22 + 2408) = 1;
          }
        }
        goto LABEL_134;
      }
    }
    if (*(_DWORD *)(v22 + 2480) && *(_BYTE *)(v22 + 9836))
    {
      *(_DWORD *)(v22 + 2480) = 0;
      if (*(_DWORD *)(v22 + 2816))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v74 = VRTraceErrorLogLevelToCSTR();
          v75 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315906;
            v140 = v74;
            v141 = 2080;
            v142 = "DoRateControl";
            v143 = 1024;
            v144 = 4185;
            v145 = 2080;
            v146 = "Congestion!!! Pause video.";
            _os_log_impl(&dword_1D8A54000, v75, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d AFRC: %s", buf, 0x26u);
          }
        }
      }
      VRLogfilePrint(*(_QWORD *)(v22 + 2832), "%s", v52, v53, v54, v55, v56, v57, (char)"Congestion!!! Pause video.\n");
      VRLogfilePrintWithTimestamp(*(_QWORD *)(v22 + 2848), "%s", v76, v77, v78, v79, v80, v81, (char)"AFRC: Congestion!!! Pause video.\n");
    }
    goto LABEL_83;
  }
  DetectCongestion(v22, v32, &v138, 0, v47, v46, v37);
  pthread_mutex_unlock((pthread_mutex_t *)(v22 + 2560));
LABEL_139:
  CheckOutHandleDebug();
  return 0;
}

uint64_t UpdateFECLevel(uint64_t a1)
{
  pthread_mutex_t *v2;
  int v3;
  double v4;
  int v5;
  unsigned int v7;
  unsigned int v8;
  int v9;
  int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  double v14;
  double v15;

  v2 = (pthread_mutex_t *)(a1 + 2744);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 2744));
  v3 = *(_DWORD *)(a1 + 2408);
  v4 = *(double *)(a1 + 176);
  v5 = *(_DWORD *)(a1 + 28);
  if (*(_DWORD *)(a1 + 9696))
  {
    if (v5 > 2)
      goto LABEL_10;
  }
  else if (v5 >= 8 && *(double *)(a1 + 9576) >= 1.0)
  {
LABEL_10:
    if (*(_BYTE *)(a1 + 2696))
    {
      v7 = *(_DWORD *)(a1 + 2700);
      v8 = fmin(v4 * 10.0, 10.0);
      v9 = *(_DWORD *)(a1 + 2704);
      v10 = *(_DWORD *)(a1 + 256);
      if (v10 + 1 > v8)
        v11 = v10 + 1;
      else
        v11 = v8;
      if (v11 <= v7)
        v11 = *(_DWORD *)(a1 + 2700);
      if (v7 >= v8)
        v12 = v8;
      else
        v12 = *(_DWORD *)(a1 + 2700);
      if (v3)
        v13 = v12;
      else
        v13 = v8;
      if (v13 != v7)
        *(_DWORD *)(a1 + 2708) = v13;
      if (v11 != v9)
        *(_DWORD *)(a1 + 2712) = v11;
    }
    else
    {
      v14 = *(double *)(a1 + 2720);
      v15 = 1.0;
      if (v14 == 1.0)
      {
        if (!v3)
        {
          v15 = 1.5;
          if (v4 <= *(double *)(a1 + 88))
          {
            v15 = 2.0;
            if (v4 <= *(double *)(a1 + 96))
              v15 = 1.0;
          }
        }
      }
      else if (v14 == 1.5)
      {
        if (v4 <= *(double *)(a1 + 96))
        {
          v15 = 1.0;
          if (v4 >= *(double *)(a1 + 80))
            v15 = 1.5;
        }
        else
        {
          v15 = 2.0;
          if (v3)
            v15 = 1.5;
        }
      }
      else
      {
        v15 = 1.0;
        if (v4 >= *(double *)(a1 + 80))
        {
          if (v4 >= *(double *)(a1 + 88))
            v15 = *(double *)(a1 + 2720);
          else
            v15 = 1.5;
        }
      }
      if (v15 != v14)
        *(double *)(a1 + 2728) = v15;
    }
    return pthread_mutex_unlock(v2);
  }
  if (*(double *)(a1 + 2720) != 1.0)
    MediaQueue_SetAudioFECLevel(1.0);
  *(_QWORD *)(a1 + 2720) = 0x3FF0000000000000;
  *(_QWORD *)(a1 + 2700) = 0;
  return pthread_mutex_unlock(v2);
}

uint64_t AFRCGetStat(uint64_t a1, double *a2, _DWORD *a3, _DWORD *a4, int *a5, uint64_t a6, uint64_t a7, _DWORD *a8)
{
  uint64_t v13;
  double v14;
  int v15;
  int v16;
  BOOL v17;
  int v18;
  double v19;
  unsigned int v20;

  v13 = CheckInHandleDebug();
  if (!v13)
    return 2149646338;
  if (a2)
  {
    v14 = *(double *)(v13 + 176);
    if (!*(_BYTE *)(v13 + 244))
      v14 = v14 * *(double *)(v13 + 2720);
    *a2 = v14;
  }
  if (a3)
    *a3 = *(_DWORD *)(v13 + 256);
  if (a4)
    *a4 = *(_DWORD *)(v13 + 52);
  if (a5)
  {
    v15 = *(_DWORD *)(v13 + 1412);
    v16 = 0xFFFF;
    v17 = __OFSUB__(v15, 1);
    v18 = v15 - 1;
    if (v18 < 0 == v17)
    {
      v19 = *(double *)(v13 + 8 * v18 + 1896);
      v20 = vcvtd_n_s64_f64(v19, 0xDuLL);
      if (v19 == 0.0)
        v16 = 0xFFFF;
      else
        v16 = v20;
    }
    *a5 = v16;
  }
  if (a8)
    *a8 = *(_DWORD *)(v13 + 1400) == 3;
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCRecordKeyFrame(uint64_t a1, char a2, int a3, int a4, int a5, int a6)
{
  pthread_mutex_t *v11;
  pthread_mutex_t *v12;
  pthread_mutex_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  char *v22;
  const char *v23;
  char v25[16];
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  v11 = (pthread_mutex_t *)CheckInHandleDebug();
  if (!v11)
    return 2149646338;
  v12 = v11;
  v13 = v11 + 40;
  pthread_mutex_lock(v11 + 40);
  *(_WORD *)&v12[38].__opaque[48] = a3;
  *(_DWORD *)&v12[38].__opaque[52] = a4;
  LODWORD(v12[39].__sig) = a5;
  if (a6)
  {
    *(double *)v12[39].__opaque = micro();
    v12[46].__opaque[52] = a2;
  }
  *(_DWORD *)&v12[46].__opaque[20] = *(_DWORD *)&v12->__opaque[36];
  pthread_mutex_unlock(v13);
  v20 = *(_QWORD *)&v12[44].__opaque[24];
  if (v20)
  {
    v55 = 0u;
    v56 = 0u;
    v53 = 0u;
    v54 = 0u;
    v51 = 0u;
    v52 = 0u;
    v49 = 0u;
    v50 = 0u;
    v47 = 0u;
    v48 = 0u;
    v45 = 0u;
    v46 = 0u;
    v43 = 0u;
    v44 = 0u;
    v41 = 0u;
    v42 = 0u;
    v39 = 0u;
    v40 = 0u;
    v37 = 0u;
    v38 = 0u;
    v35 = 0u;
    v36 = 0u;
    v33 = 0u;
    v34 = 0u;
    v31 = 0u;
    v32 = 0u;
    v29 = 0u;
    v30 = 0u;
    v27 = 0u;
    v28 = 0u;
    *(_OWORD *)v25 = 0u;
    v26 = 0u;
    if (a4 >= 1)
    {
      if (a4 >= 102)
        v21 = 102;
      else
        v21 = a4;
      v22 = v25;
      do
      {
        sprintf(v22, "%04X ", a3);
        v22 += 5;
        ++a3;
        --v21;
      }
      while (v21);
      v20 = *(_QWORD *)&v12[44].__opaque[24];
    }
    v23 = "Key";
    if (!a6)
      v23 = "Refresh";
    VRLogfilePrintWithTimestamp(v20, "%s frame (%08X) is generated PT (%u), %d packets. [%s]\n", v14, v15, v16, v17, v18, v19, (char)v23);
  }
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCMarkAdditionalFlushes(uint64_t a1, int a2)
{
  pthread_mutex_t *v3;
  pthread_mutex_t *v4;
  pthread_mutex_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v3 = (pthread_mutex_t *)CheckInHandleDebug();
  if (!v3)
    return 2149646338;
  v4 = v3;
  v5 = v3 + 40;
  pthread_mutex_lock(v3 + 40);
  *(_DWORD *)&v4[46].__opaque[36] += a2;
  *(double *)&v4[46].__opaque[40] = micro();
  VRLogfilePrintWithTimestamp(*(_QWORD *)&v4[44].__opaque[24], "Add additional flush(%u).\n", v6, v7, v8, v9, v10, v11, *(_DWORD *)&v4[46].__opaque[36]);
  pthread_mutex_unlock(v5);
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCCancelFlush()
{
  pthread_mutex_t *v0;
  pthread_mutex_t *v1;
  pthread_mutex_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  double v9;
  int v10;

  v0 = (pthread_mutex_t *)CheckInHandleDebug();
  if (!v0)
    return 2149646338;
  v1 = v0;
  v2 = v0 + 40;
  pthread_mutex_lock(v0 + 40);
  v9 = micro();
  v10 = *(_DWORD *)&v1[46].__opaque[36] - 1;
  *(_DWORD *)&v1[46].__opaque[36] = v10;
  if (v10)
  {
    *(_DWORD *)v1[149].__opaque = 0;
    *(double *)&v1[149].__opaque[8] = v9;
    *(_DWORD *)&v1[149].__opaque[28] = 0;
  }
  *(double *)&v1[46].__opaque[40] = v9;
  VRLogfilePrintWithTimestamp(*(_QWORD *)&v1[44].__opaque[24], "Pending baseband flush (%u) is cancelled%s.\n", v3, v4, v5, v6, v7, v8, v10);
  pthread_mutex_unlock(v2);
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCProcessBasebandNotification(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  char *v13;
  int v14;
  int v15;
  signed int v16;
  unsigned __int8 *v17;
  unsigned __int8 *v18;
  unsigned int v19;
  unsigned int v20;
  _WORD *v21;
  signed int v22;
  int v23;
  uint64_t v24;
  NSObject *v25;
  uint64_t v26;
  NSObject *v27;
  uint64_t v28;
  NSObject *v29;
  int v30;
  int v31;
  unint64_t v32;
  unint64_t v33;
  int v34;
  int ErrorLogLevelForModule;
  uint64_t v37;
  uint8_t buf[4];
  uint64_t v39;
  __int16 v40;
  const char *v41;
  __int16 v42;
  int v43;
  __int16 v44;
  int v45;
  __int16 v46;
  int v47;
  __int16 v48;
  int v49;
  _QWORD __dst[758];

  v1 = MEMORY[0x1E0C80A78](a1);
  __dst[756] = *MEMORY[0x1E0C80C00];
  v5 = 2149646370;
  if (v3 >= 8)
  {
    v6 = v4;
    v7 = v3;
    v8 = v2;
    v9 = v1;
    memcpy(__dst, &unk_1D91094D8, 0x17A0uLL);
    WORD2(__dst[0]) = bswap32(*(unsigned __int16 *)(v8 + 6)) >> 16;
    v10 = bswap32(*(unsigned __int16 *)(v8 + 4)) >> 16;
    if (v10 == 51966)
    {
      if (v7 >= 0x24)
      {
        LODWORD(__dst[0]) = 1;
        __dst[1] = v6;
        LOWORD(__dst[2]) = *(unsigned __int8 *)(v8 + 12);
        BYTE2(__dst[2]) = *(_BYTE *)(v8 + 13);
        WORD2(__dst[2]) = bswap32(*(unsigned __int16 *)(v8 + 14)) >> 16;
        HIWORD(__dst[2]) = *(_WORD *)(v8 + 16);
        *(int8x16_t *)&__dst[3] = vrev32q_s8(*(int8x16_t *)(v8 + 20));
        return AFRCUpdateBBNote(v9, (uint64_t)__dst);
      }
    }
    else if (v10 == 57005)
    {
      if (v7 >= 0x10)
      {
        LODWORD(__dst[0]) = 2;
        __dst[1] = v6;
        LOWORD(__dst[2]) = bswap32(*(unsigned __int16 *)(v8 + 12)) >> 16;
        v11 = *(unsigned __int16 *)(v8 + 14);
        WORD1(__dst[2]) = __rev16(v11);
        if (v11 != 0xFFFF)
        {
          v37 = v9;
          v12 = 0;
          v13 = (char *)&__dst[3] + 2;
          v14 = 16;
          do
          {
            v15 = v14 + 3;
            v16 = v7 - (v14 + 3);
            if ((int)v7 < v14 + 3)
              goto LABEL_34;
            v17 = (unsigned __int8 *)(v8 + v14);
            v18 = (unsigned __int8 *)&__dst[2] + 1004 * v12 + 6;
            *v18 = *v17;
            v19 = bswap32(*(unsigned __int16 *)(v17 + 1));
            v20 = HIWORD(v19);
            *((_WORD *)v18 + 1) = HIWORD(v19);
            v21 = v18 + 2;
            v22 = v16;
            v23 = v16 / 2;
            if (v16 / 2 < (int)HIWORD(v19))
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                v24 = VRTraceErrorLogLevelToCSTR();
                v25 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                {
                  v34 = (unsigned __int16)*v21;
                  *(_DWORD *)buf = 136316418;
                  v39 = v24;
                  v40 = 2080;
                  v41 = "AFRCProcessBasebandNotification";
                  v42 = 1024;
                  v43 = 4988;
                  v44 = 1024;
                  v45 = 4988;
                  v46 = 1024;
                  v47 = v22 / 2;
                  v48 = 1024;
                  v49 = v34;
                  _os_log_error_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_ERROR, "VCRC [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/MediaQueue/AFRC.c:%d: Bad ACK, #dropped SN doesn't match(%d != %u).", buf, 0x2Eu);
                }
              }
              *v21 = v23;
              LOWORD(v20) = v23;
            }
            if ((unsigned __int16)v20 >= 0x1F5u)
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                v26 = VRTraceErrorLogLevelToCSTR();
                v27 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136316418;
                  v39 = v26;
                  v40 = 2080;
                  v41 = "AFRCProcessBasebandNotification";
                  v42 = 1024;
                  v43 = 4993;
                  v44 = 1024;
                  v45 = 4993;
                  v46 = 1024;
                  v47 = 57005;
                  v48 = 1024;
                  v49 = 500;
                  _os_log_error_impl(&dword_1D8A54000, v27, OS_LOG_TYPE_ERROR, "VCRC [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/MediaQueue/AFRC.c:%d: Bad ACK, #dropped SN exceeds limit(%d > %d).", buf, 0x2Eu);
                }
              }
              *v21 = 500;
            }
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v28 = VRTraceErrorLogLevelToCSTR();
              v29 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                v30 = (unsigned __int16)*v21;
                v31 = *v18;
                *(_DWORD *)buf = 136316162;
                v39 = v28;
                v40 = 2080;
                v41 = "AFRCProcessBasebandNotification";
                v42 = 1024;
                v43 = 4997;
                v44 = 1024;
                v45 = v30;
                v46 = 1024;
                v47 = v31;
                _os_log_impl(&dword_1D8A54000, v29, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Baseband dropped %u packet(s) for PT %u.", buf, 0x28u);
              }
            }
            v32 = (unsigned __int16)*v21;
            if (*v21)
            {
              v33 = 0;
              do
              {
                *(_WORD *)&v13[2 * v33] = bswap32(*(unsigned __int16 *)(v8 + v15)) >> 16;
                v15 += 2;
                ++v33;
              }
              while (v33 < v32);
            }
            ++v12;
            v13 += 1004;
            v14 = v15;
          }
          while (v12 != 6);
          ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
          if (ErrorLogLevelForModule < 3)
          {
            LOWORD(v12) = 6;
LABEL_34:
            v9 = v37;
            goto LABEL_35;
          }
          VRTraceErrorLogLevelToCSTR();
          v9 = v37;
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            AFRCProcessBasebandNotification_cold_1();
          LOWORD(v12) = 6;
LABEL_35:
          WORD2(__dst[2]) = v12;
        }
        return AFRCUpdateBBNote(v9, (uint64_t)__dst);
      }
    }
    else
    {
      return 0;
    }
  }
  return v5;
}

uint64_t AFRCUpdateBBNote(uint64_t a1, uint64_t a2)
{
  double v3;
  pthread_mutex_t *v4;
  uint64_t v5;
  pthread_mutex_t *v6;
  int v7;
  unint64_t v8;
  unsigned int v9;
  int v10;
  unsigned __int16 *v11;
  int v12;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  unsigned int v21;
  char v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  double *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  __int128 v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  unsigned __int16 *v56;
  unsigned int v57;
  unsigned int v58;
  uint64_t v59;
  uint64_t v60;
  unsigned __int16 *v61;
  int v62;
  unint64_t v63;
  int v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  unsigned int v74;
  uint64_t v75;
  __int128 v76;
  __int128 v77;
  uint64_t v78;
  int v79;
  int v80;
  unsigned int v81;
  double *v82;
  _DWORD *v83;
  _DWORD *v84;
  double *v85;
  double v86;
  double v87;
  double v88;
  double v89;
  double v90;
  double v91;
  uint64_t v92;
  double v93;
  double v94;
  unint64_t v95;
  double v96;
  double v97;
  double v98;
  double v99;
  double v100;
  uint64_t v101;
  unsigned int v102;
  int v103;
  uint64_t v104;
  int v105;
  double v106;
  _BOOL4 v107;
  double v108;
  BOOL v109;
  int v110;
  int v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  int v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  NSObject *v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  unsigned int v133;
  double v134;
  double v135;
  int v136;
  unsigned int v137;
  double v138;
  pthread_mutex_t *v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint8_t buf[48];
  __int128 v145;
  __int128 v146;
  __int128 v147;
  __int128 v148;
  __int128 v149;
  __int128 v150;
  __int128 v151;
  __int128 v152;
  __int128 v153;
  __int128 v154;
  __int128 v155;
  __int128 v156;
  __int128 v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  __int128 v161;
  __int128 v162;
  __int128 v163;
  __int128 v164;
  __int128 v165;
  __int128 v166;
  __int128 v167;
  __int128 v168;
  __int128 v169;
  __int128 v170;
  __int128 v171;
  __int128 v172;
  __int128 v173;
  _OWORD v174[8];
  uint64_t v175;

  v175 = *MEMORY[0x1E0C80C00];
  v143 = 0;
  v3 = micro();
  v4 = (pthread_mutex_t *)CheckInHandleDebug();
  if (!v4)
    return 2149646338;
  v5 = (uint64_t)v4;
  v6 = v4 + 40;
  pthread_mutex_lock(v4 + 40);
  if (!*(_DWORD *)(v5 + 2928))
    goto LABEL_168;
  v142 = v5;
  if (*(_DWORD *)a2 == 2)
  {
    v7 = *(_DWORD *)(v5 + 2988) - 1;
    *(_DWORD *)(v5 + 2988) = v7;
    if (v7)
    {
      *(_DWORD *)(v5 + 9544) = 0;
      *(double *)(v5 + 9552) = v3;
      *(_DWORD *)(v5 + 9572) = 0;
    }
    *(double *)(v5 + 2992) = v3;
    if (*(__int16 *)(a2 + 18) >= 1 && *(_WORD *)(a2 + 20))
    {
      v8 = 0;
      v9 = *(unsigned __int16 *)(a2 + 16);
      v10 = *(unsigned __int8 *)(v5 + 3004);
      v11 = (unsigned __int16 *)(a2 + 24);
      do
      {
        v12 = *v11;
        if (*((unsigned __int8 *)v11 - 2) == v10)
        {
          *(_DWORD *)(v5 + 9616) += v12;
          if (v9 > *(unsigned __int16 *)(v5 + 3006))
          {
            if (v12)
              *(_DWORD *)(v5 + 3000) = 1;
            break;
          }
        }
        else
        {
          *(_DWORD *)(v5 + 9620) += v12;
        }
        v11 += 502;
        ++v8;
      }
      while (v8 < *(unsigned __int16 *)(a2 + 20));
    }
    if (!*(_QWORD *)(v5 + 2848))
      goto LABEL_61;
    v139 = v6;
    *(_QWORD *)&v48 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v48 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v174[6] = v48;
    v174[7] = v48;
    v174[4] = v48;
    v174[5] = v48;
    v174[2] = v48;
    v174[3] = v48;
    v174[0] = v48;
    v174[1] = v48;
    VRLogfileGetTimestamp((char *)v174, 0x80u);
    if (*(__int16 *)(a2 + 18) <= 0)
    {
      *(_WORD *)(a2 + 20) = 1;
      *(_BYTE *)(a2 + 22) = 0;
      *(_WORD *)(a2 + 24) = 0;
    }
    else if (!*(_WORD *)(a2 + 20))
    {
LABEL_58:
      if (*(_DWORD *)(v5 + 3000))
        VRLogfilePrint(*(_QWORD *)(v5 + 2848), "%s Request video refresh for PT (%u).\n", v49, v50, v51, v52, v53, v54, (char)v174);
      v6 = v139;
LABEL_61:
      pthread_mutex_unlock(v6);
      if (*(_DWORD *)(v5 + 2680) && *(_WORD *)(a2 + 20))
      {
        v63 = 0;
        v64 = *(unsigned __int16 *)(a2 + 16);
        v65 = a2 + 26;
        do
        {
          MediaQueue_BBFlushAcked(*(_QWORD *)(v5 + 2808), *(unsigned __int16 *)(v65 - 2), v65, v64);
          ++v63;
          v65 += 1004;
        }
        while (v63 < *(unsigned __int16 *)(a2 + 20));
      }
      goto LABEL_77;
    }
    v55 = 0;
    v140 = a2 + 22;
    v141 = a2;
    v56 = (unsigned __int16 *)(a2 + 26);
    do
    {
      if (*(_WORD *)(a2 + 18))
      {
        if (*(unsigned __int16 *)(a2 + 18) == 0xFFFF)
        {
          VRLogfilePrint(*(_QWORD *)(v5 + 2848), "%s TID[%04X] Drop ACK reported a failure%s\n", v49, v50, v51, v52, v53, v54, (char)v174);
        }
        else
        {
          v57 = *(unsigned __int16 *)(v140 + 1004 * v55 + 2);
          v172 = 0u;
          v173 = 0u;
          v170 = 0u;
          v171 = 0u;
          v168 = 0u;
          v169 = 0u;
          v166 = 0u;
          v167 = 0u;
          v164 = 0u;
          v165 = 0u;
          v162 = 0u;
          v163 = 0u;
          v160 = 0u;
          v161 = 0u;
          v158 = 0u;
          v159 = 0u;
          v156 = 0u;
          v157 = 0u;
          v154 = 0u;
          v155 = 0u;
          v152 = 0u;
          v153 = 0u;
          v150 = 0u;
          v151 = 0u;
          v148 = 0u;
          v149 = 0u;
          v146 = 0u;
          v147 = 0u;
          *(_OWORD *)&buf[32] = 0u;
          v145 = 0u;
          if (v57 >= 0x66)
            v58 = 102;
          else
            v58 = v57;
          memset(buf, 0, 32);
          if (v58)
          {
            v59 = 0;
            v60 = 5 * v58;
            v61 = v56;
            do
            {
              v62 = *v61++;
              sprintf((char *)&buf[v59], "%04X ", v62);
              v59 += 5;
            }
            while (v60 != v59);
            if (v59)
              buf[v59 - 1] = 0;
          }
          a2 = v141;
          v5 = v142;
          VRLogfilePrint(*(_QWORD *)(v142 + 2848), "%s TID[%04X] Drop ACK for PT %u: %2u packets dropped [%s]%s\n", v49, v50, v51, v52, v53, v54, (char)v174);
        }
      }
      else
      {
        VRLogfilePrint(*(_QWORD *)(v5 + 2848), "%s TID[%04X] Drop ACK, no packet dropped%s\n", v49, v50, v51, v52, v53, v54, (char)v174);
      }
      ++v55;
      v56 += 502;
    }
    while (v55 < *(unsigned __int16 *)(a2 + 20));
    goto LABEL_58;
  }
  if (!*(_DWORD *)(v5 + 9568))
  {
    v23 = 0;
    goto LABEL_24;
  }
  *(_QWORD *)buf = -1;
  LODWORD(v174[0]) = -1431655766;
  MediaQueue_GetTimeRateChanged(*(_QWORD *)(v5 + 2808), buf, v174);
  if (*(_DWORD *)(v5 + 2476))
  {
    v20 = v174[0];
    v21 = *(_DWORD *)(v5 + 9568);
    goto LABEL_19;
  }
  v20 = v174[0];
  v21 = *(_DWORD *)(v5 + 9568);
  if (!*(_DWORD *)(v5 + 2472) && LODWORD(v174[0]) < v21)
  {
LABEL_168:
    if (CalculateBasebandRate(v5, a2, (unsigned int *)&v143 + 1, (unsigned int *)&v143, 0))
      goto LABEL_69;
    goto LABEL_32;
  }
LABEL_19:
  if (v20 >= v21)
  {
    v22 = buf[0];
  }
  else
  {
    LODWORD(v174[0]) = v21;
    *(double *)buf = v3;
    v22 = LOBYTE(v3);
  }
  VRLogfilePrintWithTimestamp(*(_QWORD *)(v5 + 2848), "Rate change done, [%.6f %u>=%d %u%s], taking new samples.\n", v14, v15, v16, v17, v18, v19, v22);
  v24 = *(_QWORD *)buf;
  *(_QWORD *)(v5 + 9560) = *(_QWORD *)buf;
  *(_QWORD *)(v5 + 9552) = v24;
  *(_QWORD *)(v5 + 9568) = 0;
  *(_DWORD *)(v5 + 9544) = 0;
  v23 = 1;
LABEL_24:
  if (CalculateBasebandRate(v5, a2, (unsigned int *)&v143 + 1, (unsigned int *)&v143, v23))
  {
    v32 = (*(_DWORD *)(v5 + 2980) - *(_DWORD *)(v5 + 2984)) & ~((*(_DWORD *)(v5 + 2980) - *(_DWORD *)(v5 + 2984)) >> 31);
    if (*(_DWORD *)(v5 + 2988))
    {
      VRLogfilePrintWithTimestamp(*(_QWORD *)(v5 + 2848), "Still trying to flush baseband with flush counter: %d. Stop ramp-up and possibly decrease audio fraction based on BBAvgTxRate: %d\n", v26, v27, v28, v29, v30, v31, *(_DWORD *)(v5 + 2988));
      if (v3 - *(double *)(v5 + 2992) <= 3.0 || *(_DWORD *)(v5 + 2980))
        goto LABEL_68;
      v39 = (double *)(v5 + 2992);
      VRLogfilePrintWithTimestamp(*(_QWORD *)(v5 + 2848), "Flush counter: %d stuck for more than %d seconds. And baseband shows TxRate:%d, TxDelay:%d. Reset the flush counter.\n", v33, v34, v35, v36, v37, v38, *(_DWORD *)(v5 + 2988));
      *(_DWORD *)(v5 + 2988) = 0;
LABEL_67:
      *v39 = v3;
LABEL_68:
      RampDownAudio(v5, v3);
      *(_DWORD *)(v5 + 9544) = 0;
      goto LABEL_69;
    }
    if (!*(_DWORD *)(v5 + 2968))
    {
      v39 = (double *)(v5 + 2992);
      goto LABEL_67;
    }
    v46 = *(int *)(v5 + 9544);
    if ((int)v46 > 14)
    {
      memmove((void *)(v5 + 9304), (const void *)(v5 + 9312), 0x70uLL);
      v76 = *(_OWORD *)(v5 + 9428);
      *(_OWORD *)(v5 + 9440) = *(_OWORD *)(v5 + 9444);
      *(_OWORD *)(v5 + 9424) = v76;
      *(_OWORD *)(v5 + 9456) = *(_OWORD *)(v5 + 9460);
      *(_QWORD *)(v5 + 9472) = *(_QWORD *)(v5 + 9476);
      v77 = *(_OWORD *)(v5 + 9504);
      *(_OWORD *)(v5 + 9484) = *(_OWORD *)(v5 + 9488);
      *(_OWORD *)(v5 + 9500) = v77;
      *(_OWORD *)(v5 + 9516) = *(_OWORD *)(v5 + 9520);
      *(_QWORD *)(v5 + 9532) = *(_QWORD *)(v5 + 9536);
      *(_QWORD *)(v5 + 9416) = *(_QWORD *)(a2 + 8);
      *(_DWORD *)(v5 + 9480) = v32;
      *(_DWORD *)(v5 + 9540) = *(_DWORD *)(v5 + 2980);
      v47 = *(_DWORD *)(v5 + 9544);
    }
    else
    {
      *(_QWORD *)(v5 + 8 * v46 + 9304) = *(_QWORD *)(a2 + 8);
      *(_DWORD *)(v5 + 4 * v46 + 9424) = v32;
      *(_DWORD *)(v5 + 4 * *(int *)(v5 + 9544) + 9484) = *(_DWORD *)(v5 + 2980);
      v47 = *(_DWORD *)(v5 + 9544) + 1;
      *(_DWORD *)(v5 + 9544) = v47;
    }
    v78 = (v47 - 4);
    if (v47 < 4)
      goto LABEL_69;
    if (v47 == 4)
    {
LABEL_84:
      LODWORD(v78) = 0;
    }
    else
    {
      while (*(double *)(v5 + 9304 + 8 * (v47 - 1)) - *(double *)(v5 + 9304 + 8 * v78) < 0.5)
      {
        v109 = v78-- <= 1;
        if (v109)
          goto LABEL_84;
      }
    }
    v79 = v47 - v78;
    if (v79 < 1)
    {
      v96 = 0.0;
      v97 = 0.0;
      v98 = 0.0;
    }
    else
    {
      v80 = v78 + (v79 >> 1);
      v81 = v79 + 1;
      v82 = (double *)(v5 + 8 * v80 + 9304);
      v83 = (_DWORD *)(v5 + 4 * v80 + 9484);
      v84 = (_DWORD *)(v5 + 4 * (int)v78 + 9484);
      v85 = (double *)(v5 + 8 * (int)v78 + 9304);
      v86 = 0.0;
      v87 = 0.0;
      v88 = 0.0;
      v89 = 0.0;
      v90 = 0.0;
      v91 = 0.0;
      v92 = v81 >> 1;
      do
      {
        v91 = v91 + (double)(int)*(v84 - 15);
        v90 = v90 + (double)(int)*(v83 - 15);
        v93 = *v85++;
        v89 = v89 + v93;
        v94 = *v82++;
        v88 = v88 + v94;
        LODWORD(v94) = *v84++;
        *(double *)&v95 = (double)*(unint64_t *)&v94;
        v87 = v87 + (double)*(unint64_t *)&v94;
        LODWORD(v94) = *v83++;
        LODWORD(v95) = LODWORD(v94);
        v86 = v86 + (double)v95;
        --v92;
      }
      while (v92);
      v96 = v90 - v91;
      v97 = v88 - v89;
      v98 = v86 - v87;
    }
    v99 = v96 * 0.001 / v97 * 0.5;
    v100 = v98 * 0.001 / v97 * 0.5;
    if ((*(_BYTE *)(v5 + 1396) & 4) != 0)
    {
      v103 = *(_DWORD *)(v5 + 28);
      LODWORD(v104) = *(_DWORD *)(v5 + 36);
      if (v103 <= (int)v104)
      {
        v104 = v103;
        v101 = *(int *)(v5 + 40);
        v105 = *(_DWORD *)(v5 + 9696);
        v106 = 0.12;
        while (g_adwTxRateTiers[v104] > *(_DWORD *)(v5 + 2968))
        {
          --v104;
          if (v105 || v104 <= v101)
          {
LABEL_106:
            if ((int)v104 <= (int)v101)
              LODWORD(v104) = v101;
            break;
          }
        }
      }
      else
      {
        v105 = *(_DWORD *)(v5 + 9696);
        v106 = 0.12;
      }
    }
    else
    {
      v101 = *(int *)(v5 + 40);
      if (*(_DWORD *)(v5 + 2968) >= *(_DWORD *)(v5 + 44))
        v102 = *(_DWORD *)(v5 + 44);
      else
        v102 = *(_DWORD *)(v5 + 2968);
      v103 = *(_DWORD *)(v5 + 28);
      v104 = v103;
      v105 = *(_DWORD *)(v5 + 9696);
      v106 = 0.2;
      while (g_adwTxRateTiers[v104] > v102)
      {
        --v104;
        if (v105 || v104 <= v101)
          goto LABEL_106;
      }
    }
    v107 = v99 > v106;
    if (v100 > 0.4)
      v107 = 1;
    if (v105)
    {
      if (!v107 || *(_DWORD *)(v5 + 2980) <= 0x320u)
        goto LABEL_144;
      if (v103 == (_DWORD)v104)
        goto LABEL_129;
    }
    else
    {
      if (!v107 && !*(_DWORD *)(v5 + 2472) && (*(_BYTE *)(v5 + 2960) & 1) == 0)
        goto LABEL_144;
      if (*(_DWORD *)(v5 + 2980) < 0x321u)
        goto LABEL_144;
      v108 = *(double *)(v5 + 2504);
      v109 = v108 == 0.0 || v3 - v108 <= 0.5;
      if (v109)
        goto LABEL_144;
      if (v103 == (_DWORD)v104)
      {
        RampDownAudio(v5, v3);
        *(double *)(v5 + 2520) = v3;
LABEL_129:
        v118 = *(_DWORD *)(v5 + 1396);
        if ((v118 & 1) != 0)
        {
          *(_DWORD *)(v5 + 1396) = v118 & 0xFFFFFFFE;
          calculateInitialRampUpDeltas(v5);
          if (*(_DWORD *)(v5 + 2816))
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v125 = VRTraceErrorLogLevelToCSTR();
              v126 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315906;
                *(_QWORD *)&buf[4] = v125;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "AFRCUpdateBBNote";
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&buf[24] = 5308;
                *(_WORD *)&buf[28] = 2080;
                *(_QWORD *)&buf[30] = "Initial Rampup done!";
                _os_log_impl(&dword_1D8A54000, v126, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d AFRC: %s", buf, 0x26u);
              }
            }
          }
          v5 = v142;
          VRLogfilePrint(*(_QWORD *)(v142 + 2832), "%s", v119, v120, v121, v122, v123, v124, (char)"Initial Rampup done!\n");
          VRLogfilePrintWithTimestamp(*(_QWORD *)(v142 + 2848), "%s", v127, v128, v129, v130, v131, v132, (char)"Initial Rampup done!\n");
          v118 = *(_DWORD *)(v142 + 1396);
        }
        if ((v118 & 4) != 0)
          *(_DWORD *)(v5 + 1396) = v118 & 0xFFFFFFFB;
        if (*(_DWORD *)(v5 + 1400) == 3)
        {
          v133 = *(_DWORD *)(v5 + 2552) + 1;
          *(_DWORD *)(v5 + 2552) = v133;
          v134 = *(double *)(v5 + 2544);
          if (v134 == 0.0)
          {
            *(double *)(v5 + 2544) = v3;
          }
          else if (v3 - v134 >= 2.0)
          {
            *(_DWORD *)(v5 + 2552) = 0;
            *(_QWORD *)(v5 + 2544) = 0;
          }
          else if (v133 >= 4)
          {
            *(_DWORD *)(v5 + 2408) = 1;
          }
        }
LABEL_144:
        if (v99 >= 0.2)
          *(_QWORD *)(v5 + 9552) = *(_QWORD *)(a2 + 8);
        *(_DWORD *)(v5 + 9572) = 0;
        if (*(double *)(v5 + 9576) >= 1.0)
        {
          if (v99 < 0.1 && *(_DWORD *)(v5 + 2980) <= 0x1F3u)
          {
            v137 = *(_DWORD *)(v5 + 20);
            if (*(_DWORD *)(v5 + 44) < v137)
            {
              v138 = *(double *)(a2 + 8);
              if (v138 - *(double *)(v5 + 9552) > 0.5
                && v138 - *(double *)(v5 + 9560) > 0.5
                && v138 - *(double *)(v5 + 9584) > 0.5)
              {
                if (!*(_DWORD *)(v5 + 9696))
                {
                  if ((*(_BYTE *)(v5 + 2960) & 1) != 0)
                    v136 = 1;
                  else
                    v136 = 2;
                  v5 = v142;
                  goto LABEL_152;
                }
                if (v137 < g_adwTxRateTiers[*(int *)(v5 + 28) + 1])
                  goto LABEL_69;
LABEL_151:
                v136 = 1;
LABEL_152:
                *(_DWORD *)(v5 + 9572) = v136;
              }
            }
          }
        }
        else if (v99 < 0.1 && *(_DWORD *)(v5 + 2980) <= 0x1F3u)
        {
          v135 = *(double *)(a2 + 8);
          if (v135 - *(double *)(v5 + 9584) > 2.0 && v135 - *(double *)(v5 + 9552) > 2.0)
            goto LABEL_151;
        }
LABEL_69:
        memcpy((void *)(v5 + 3008), (const void *)a2, 0x17A0uLL);
        UpdateAudioTxInfo(v5, v66, v67, v68, v69, v70, v71, v72);
        v73 = *(unsigned int *)(v5 + 2480);
        if (*(_DWORD *)(v5 + 2476))
          v74 = 65;
        else
          v74 = 86;
        if ((_DWORD)v73)
          v75 = v74;
        else
          v75 = 65;
        VRLogfilePrintWithTimestamp(*(_QWORD *)(v5 + 2848), "%2u%2u%2u%2u%2u %6u\t%6u\t%u\t%u %4u\t%4u\t%4u\t%4u\t%4u\t%4d\t%.4f\t%.4f\t%4u %.2f %c(%1d,%1d) %1d %4d\n", v73, v75, *(char *)(a2 + 23), *(unsigned int *)(a2 + 24), *(unsigned int *)(a2 + 28), *(unsigned int *)(a2 + 32), *(_WORD *)(a2 + 4));
        goto LABEL_76;
      }
    }
    if ((v104 & 0x80000000) == 0 || v3 - *(double *)(v5 + 2520) > 3.0)
    {
      *(_DWORD *)(v5 + 1400) = 3;
      v110 = *(_DWORD *)(v5 + 1404) + 1;
      *(_DWORD *)(v5 + 1404) = v110;
      *(_DWORD *)(v5 + 36) = v103;
      *(_DWORD *)(v5 + 28) = v104;
      v111 = g_adwTxRateTiers[(int)v104];
      *(_DWORD *)(v5 + 44) = v111;
      *(_DWORD *)(v5 + 9568) = v110;
      *(_DWORD *)(v5 + 2484) = 1;
      *(double *)(v5 + 2520) = v3;
      VRLogfilePrint(*(_QWORD *)(v5 + 2832), "Congestion!!! TxRate v %u, BaseBand.\n", v26, v27, v28, v29, v30, v31, v111);
      VRLogfilePrintWithTimestamp(*(_QWORD *)(v5 + 2848), "Rate change [%u] (Ramp Down to %u, Baseband).\n", v112, v113, v114, v115, v116, v117, *(_DWORD *)(v5 + 9568));
    }
    UpdateFECLevel(v5);
    goto LABEL_129;
  }
LABEL_32:
  UpdateAudioTxInfo(v5, v25, v26, v27, v28, v29, v30, v31);
  VRLogfilePrintWithTimestamp(*(_QWORD *)(v5 + 2848), "%2u%2u%2u%2u%2u %6u\t%6u\t%u\t%u [Bogus notification, discard]\n", v40, v41, v42, v43, v44, v45, *(_WORD *)(a2 + 4));
LABEL_76:
  pthread_mutex_unlock(v6);
LABEL_77:
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCSetReceiveQueueSize(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  pthread_mutex_t *v5;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149646338;
  v4 = v3;
  v5 = (pthread_mutex_t *)(v3 + 2864);
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 2864));
  *(_DWORD *)(v4 + 164) = a2;
  pthread_mutex_unlock(v5);
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCSetVideoPaused(uint64_t a1, int a2)
{
  pthread_mutex_t *v3;
  pthread_mutex_t *v4;
  pthread_mutex_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  NSObject *v15;
  const char *v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint8_t buf[4];
  uint64_t v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  int v30;
  __int16 v31;
  const char *v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v3 = (pthread_mutex_t *)CheckInHandleDebug();
  if (!v3)
    return 2149646338;
  v4 = v3;
  v5 = v3 + 40;
  pthread_mutex_lock(v3 + 40);
  v12 = *(_DWORD *)&v4[38].__opaque[32];
  if (!a2 && v12 && (v4[46].__opaque[8] & 1) == 0)
  {
    *(_DWORD *)&v4[21].__opaque[48] = 5;
    v13 = *(_DWORD *)&v4[21].__opaque[52] + 1;
    *(_DWORD *)&v4[21].__opaque[52] = v13;
    *(_DWORD *)&v4[149].__opaque[24] = v13;
  }
  if (v12 != a2)
  {
    if (a2)
      *(_DWORD *)&v4[21].__opaque[36] = 0;
    if (LODWORD(v4[44].__sig))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v14 = VRTraceErrorLogLevelToCSTR();
        v15 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          if (a2)
            v16 = "Paused";
          else
            v16 = "Unpaused";
          *(_DWORD *)buf = 136315906;
          v26 = v14;
          v27 = 2080;
          v28 = "AFRCSetVideoPaused";
          v29 = 1024;
          v30 = 5455;
          v31 = 2080;
          v32 = v16;
          _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d AFRC: Video %s...", buf, 0x26u);
        }
      }
    }
    if (a2)
      v17 = "Paused";
    else
      v17 = "Unpaused";
    VRLogfilePrint(*(_QWORD *)&v4[44].__opaque[8], "Video %s...\n", v6, v7, v8, v9, v10, v11, (char)v17);
    VRLogfilePrintWithTimestamp(*(_QWORD *)&v4[44].__opaque[24], "Rate change [%u] (%s), new rate %ukbps...\n", v18, v19, v20, v21, v22, v23, *(_DWORD *)&v4[149].__opaque[24]);
  }
  *(_DWORD *)&v4[38].__opaque[32] = a2;
  pthread_mutex_unlock(v5);
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCSetAudioPaused(uint64_t a1, int a2, int a3)
{
  pthread_mutex_t *v5;
  pthread_mutex_t *v6;
  pthread_mutex_t *v7;
  uint64_t v9;
  NSObject *v10;
  int v11;
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v5 = (pthread_mutex_t *)CheckInHandleDebug();
  if (!v5)
    return 2149646338;
  v6 = v5;
  v7 = v5 + 40;
  pthread_mutex_lock(v5 + 40);
  if (a3)
  {
    LODWORD(v6[41].__sig) = a2;
  }
  else
  {
    if (!a2 && HIDWORD(v6[41].__sig))
      *(double *)&v6[2].__opaque[16] = micro();
    HIDWORD(v6[41].__sig) = a2;
  }
  pthread_mutex_unlock(v7);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v9 = VRTraceErrorLogLevelToCSTR();
    v10 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v11 = 136316162;
      v12 = v9;
      v13 = 2080;
      v14 = "AFRCSetAudioPaused";
      v15 = 1024;
      v16 = 5488;
      v17 = 1024;
      v18 = a3;
      v19 = 1024;
      v20 = a2;
      _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d AFRCSetAudioPaused: local? %d, audio paused? %d", (uint8_t *)&v11, 0x28u);
    }
  }
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCSetAudioSilent(uint64_t a1, char a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149646338;
  *(_BYTE *)(v3 + 9700) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCSetPLCalc(uint64_t a1, char a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149646338;
  *(_BYTE *)(v3 + 244) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCUpdateCellTech(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  int v16;
  _BOOL4 v18;
  double v19;
  double v21;
  uint64_t v22;
  uint8_t buf[4];
  uint64_t v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  uint64_t v30;
  __int16 v31;
  uint64_t v32;
  __int16 v33;
  uint64_t v34;
  __int16 v35;
  uint64_t v36;
  __int16 v37;
  int v38;
  __int16 v39;
  int v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v13 = CheckInHandleDebug();
  if (!v13)
    return 2149646338;
  v14 = v13;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v22 = VRTraceErrorLogLevelToCSTR();
    v15 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136317186;
      v24 = v22;
      v25 = 2080;
      v26 = "AFRCUpdateCellTech";
      v27 = 1024;
      v28 = 5532;
      v29 = 2080;
      v30 = CelltechToStr();
      v31 = 2080;
      v32 = CelltechToStr();
      v33 = 2080;
      v34 = CelltechToStr();
      v35 = 2080;
      v36 = CelltechToStr();
      v37 = 1024;
      v38 = a6;
      v39 = 1024;
      v40 = a7;
      _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d AFRCUpdateCellTech: iLocalCellTech: %s -> %s  iRemoteCellTech: %s -> %s  fEnableRRx: %d  didHandover: %d", buf, 0x50u);
    }
  }
  *(_DWORD *)(v14 + 2936) = a3;
  *(_DWORD *)(v14 + 2940) = a5;
  pthread_mutex_lock((pthread_mutex_t *)(v14 + 2560));
  *(_QWORD *)(v14 + 2688) = 0;
  if (*(_DWORD *)(v14 + 2928) != a2)
  {
    *(_DWORD *)(v14 + 2960) = 0;
    *(_DWORD *)(v14 + 2476) = 0;
    *(_QWORD *)(v14 + 9576) = 0x3FF0000000000000;
    *(_DWORD *)(v14 + 9056) = 0;
    if (!*(_DWORD *)(v14 + 9696))
      *(_DWORD *)(v14 + 2480) = 1;
  }
  *(_DWORD *)(v14 + 2928) = a2;
  *(_DWORD *)(v14 + 2932) = a4;
  if (a2)
  {
    v16 = *(_DWORD *)(v14 + 2936);
    v18 = a3 == 4 || v16 == 2;
    *(_DWORD *)(v14 + 2948) = v18;
    *(_DWORD *)(v14 + 2952) = v16 == 7;
  }
  if (*(_DWORD *)(v14 + 9696))
  {
    *(_QWORD *)(v14 + 2464) = 0x4000000000000000;
    *(_DWORD *)(v14 + 2944) = a6;
    v19 = 1.0;
  }
  else
  {
    v21 = 2.0;
    if (!*(_DWORD *)(v14 + 2948))
      v21 = 1.0;
    *(double *)(v14 + 2464) = v21;
    *(_DWORD *)(v14 + 2944) = a6;
    v19 = 0.5;
    if (a6)
      v19 = 1.0;
  }
  *(double *)(v14 + 2456) = v19;
  pthread_mutex_unlock((pthread_mutex_t *)(v14 + 2560));
  if (!*(_DWORD *)(v14 + 9696))
  {
    BWEUpdateSenderRecvrEnabledStates(v14);
    BWEUpdateFilterType(v14);
  }
  CheckOutHandleDebug();
  return 0;
}

void BWEUpdateSenderRecvrEnabledStates(uint64_t a1)
{
  char IsLTEOrNewer;
  char v3;
  char v4;
  int v5;
  uint64_t v6;
  NSObject *v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 2928))
    IsLTEOrNewer = NetworkUtils_IsLTEOrNewer(*(_DWORD *)(a1 + 2936));
  else
    IsLTEOrNewer = 1;
  if (*(_BYTE *)(a1 + 722))
    v3 = IsLTEOrNewer;
  else
    v3 = 0;
  *(_BYTE *)(a1 + 720) = v3;
  if (*(_DWORD *)(a1 + 2932))
  {
    v4 = NetworkUtils_IsLTEOrNewer(*(_DWORD *)(a1 + 2940));
    v5 = *(unsigned __int8 *)(a1 + 723);
    *(_BYTE *)(a1 + 721) = v5;
    if (v5 && (v4 & 1) == 0)
      BWEstResetRecvrBWState(a1, 0);
  }
  else
  {
    *(_BYTE *)(a1 + 721) = *(_BYTE *)(a1 + 723);
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
  {
    v6 = VRTraceErrorLogLevelToCSTR();
    v7 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v8 = *(unsigned __int8 *)(a1 + 720);
      v9 = *(unsigned __int8 *)(a1 + 721);
      v10 = 136316674;
      v11 = v6;
      v12 = 2080;
      v13 = "BWEUpdateSenderRecvrEnabledStates";
      v14 = 1024;
      v15 = 6316;
      v16 = 1024;
      v17 = v8;
      v18 = 1024;
      v19 = v9;
      v20 = 2080;
      v21 = CelltechToStr();
      v22 = 2080;
      v23 = CelltechToStr();
      _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d ////^^^^ BWEUpdateSenderRecvrEnabledStates: Sender/Recvr %d/%d iLocalCellTech: %s  iRemoteCellTech: %s", (uint8_t *)&v10, 0x3Cu);
    }
  }
}

void BWEUpdateFilterType(uint64_t a1)
{
  int v2;
  uint64_t v3;
  NSObject *v4;
  unsigned int v5;
  const char *v6;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  unsigned int v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  int v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  int v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 2928) && !NetworkUtils_IsLTEOrNewer(*(_DWORD *)(a1 + 2936))
    || *(_DWORD *)(a1 + 2932) && !NetworkUtils_IsLTEOrNewer(*(_DWORD *)(a1 + 2940)))
  {
    v2 = 2;
  }
  else
  {
    if ((!*(_DWORD *)(a1 + 2928) || (NetworkUtils_IsLTEOrNewer(*(_DWORD *)(a1 + 2936)) & 1) == 0)
      && *(_DWORD *)(a1 + 2932))
    {
      NetworkUtils_IsLTEOrNewer(*(_DWORD *)(a1 + 2940));
    }
    v2 = 1;
  }
  *(_DWORD *)(a1 + 728) = v2;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v3 = VRTraceErrorLogLevelToCSTR();
    v4 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v5 = *(_DWORD *)(a1 + 728);
      if (v5 > 3)
        v6 = "UNEXPECTED";
      else
        v6 = off_1E9E537A8[v5];
      v7 = *(_DWORD *)(a1 + 2928);
      v8 = CelltechToStr();
      v9 = *(_DWORD *)(a1 + 2932);
      v10 = CelltechToStr();
      v11 = *(unsigned __int8 *)(a1 + 732);
      v12 = 136317442;
      v13 = v3;
      v14 = 2080;
      v15 = "BWEUpdateFilterType";
      v16 = 1024;
      v17 = 6281;
      v18 = 1024;
      v19 = v5;
      v20 = 2080;
      v21 = v6;
      v22 = 1024;
      v23 = v7;
      v24 = 2080;
      v25 = v8;
      v26 = 1024;
      v27 = v9;
      v28 = 2080;
      v29 = v10;
      v30 = 1024;
      v31 = v11;
      _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d BWEst FilterType: %d/%s <-- ImOnCellular: %d/%s  RemoteOnCellular: %d/%s  PeerIsOnIOS: %d ", (uint8_t *)&v12, 0x52u);
    }
  }
}

uint64_t AFRCUpdateRateTier(uint64_t a1, int a2)
{
  pthread_mutex_t *v3;
  pthread_mutex_t *v4;
  pthread_mutex_t *v5;

  v3 = (pthread_mutex_t *)CheckInHandleDebug();
  if (!v3)
    return 2149646338;
  v4 = v3;
  v5 = v3 + 40;
  pthread_mutex_lock(v3 + 40);
  HIDWORD(v4[153].__sig) = a2;
  pthread_mutex_unlock(v5);
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCProcessWCMSetCallConfig(uint64_t a1, unsigned int a2, int a3)
{
  pthread_mutex_t *v5;
  pthread_mutex_t *v6;
  pthread_mutex_t *v7;
  uint64_t v8;
  NSObject *v9;
  int v10;
  int v11;
  int v12;
  unsigned int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  int v19;
  uint64_t v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  int v26;
  __int16 v27;
  unsigned int v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v5 = (pthread_mutex_t *)CheckInHandleDebug();
  if (!v5)
    return 2149646338;
  v6 = v5;
  v7 = v5 + 40;
  pthread_mutex_lock(v5 + 40);
  if (!a2)
    a2 = *(_DWORD *)&v6->__opaque[16];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v8 = VRTraceErrorLogLevelToCSTR();
    v9 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v10 = *(_DWORD *)&v6->__opaque[12];
      v11 = *(_DWORD *)&v6->__opaque[16];
      v19 = 136316674;
      v20 = v8;
      v21 = 2080;
      v22 = "AFRCProcessWCMSetCallConfig";
      v23 = 1024;
      v24 = 5637;
      v25 = 1024;
      v26 = v10;
      v27 = 1024;
      v28 = a2;
      v29 = 1024;
      v30 = a3;
      v31 = 1024;
      v32 = v11;
      _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d ProcessWCMSetCallConfig: (%u->%u), interference: (%u), clientTxCap: %u", (uint8_t *)&v19, 0x34u);
    }
  }
  *(_DWORD *)&v6->__opaque[12] = a2;
  v12 = *(_DWORD *)&v6->__opaque[20];
  v13 = g_adwTxRateTiers[v12];
  if (v13 <= a2)
  {
    v15 = *(_DWORD *)&v6->__opaque[20];
  }
  else
  {
    v14 = *(int *)&v6->__opaque[32];
    if (v12 >= (int)v14)
      v15 = *(_DWORD *)&v6->__opaque[32];
    else
      v15 = *(_DWORD *)&v6->__opaque[20];
    if (v12 > (int)v14)
    {
      v16 = v12;
      v17 = v12 - 1;
      while (1)
      {
        *(_DWORD *)&v6->__opaque[20] = v17;
        v13 = g_adwTxRateTiers[v16 - 1];
        if (v13 <= a2)
          break;
        --v16;
        --v17;
        if (v16 <= v14)
          goto LABEL_19;
      }
      v15 = v17;
    }
  }
LABEL_19:
  *(_DWORD *)&v6->__opaque[28] = v15;
  *(_DWORD *)&v6->__opaque[36] = v13;
  pthread_mutex_unlock(v7);
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCProcessWCMGetCallConfig(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  int v9;
  int v10;
  int v12;
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v5 = CheckInHandleDebug();
  if (!v5)
    return 2149646338;
  v6 = v5;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v7 = VRTraceErrorLogLevelToCSTR();
    v8 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v9 = *(_DWORD *)(v6 + 20);
      v10 = *(_DWORD *)(v6 + 44);
      v12 = 136316162;
      v13 = v7;
      v14 = 2080;
      v15 = "AFRCProcessWCMGetCallConfig";
      v16 = 1024;
      v17 = 5660;
      v18 = 1024;
      v19 = v9;
      v20 = 1024;
      v21 = v10;
      _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d ProcessWCMGetCallConfig: (TxCap %u, TxRate %u).", (uint8_t *)&v12, 0x28u);
    }
  }
  if (a2)
    *a2 = *(_DWORD *)(v6 + 20);
  if (a3)
    *a3 = *(_DWORD *)(v6 + 44);
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCMarkNetworkChange()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v0 = CheckInHandleDebug();
  if (!v0)
    return 2149646338;
  VRLogfilePrintWithTimestamp(*(_QWORD *)(v0 + 2832), "%s", v1, v2, v3, v4, v5, v6, (char)"network state changed.\n");
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCAddBBDump()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  int v10;
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v0 = CheckInHandleDebug();
  if (!v0)
    return 2149646338;
  v6 = v0;
  AFRCLog_OpenBBLog((FILE **)v0, *(_QWORD *)(v0 + 2832) != 0, 1, v1, v2, v3, v4, v5);
  if (*(_QWORD *)(v6 + 2848) && (int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v7 = VRTraceErrorLogLevelToCSTR();
    v8 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v10 = 136315650;
      v11 = v7;
      v12 = 2080;
      v13 = "AFRCAddBBDump";
      v14 = 1024;
      v15 = 5699;
      _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d ### Add BB dump for AFRC", (uint8_t *)&v10, 0x1Cu);
    }
  }
  CheckOutHandleDebug();
  return 0;
}

FILE **AFRCLog_OpenBBLog(FILE **result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  FILE **v9;
  FILE **v10;
  const char *v11;
  char v12;
  char v13[16];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v8 = a3;
    v9 = result;
    v10 = (FILE **)result[356];
    if (!v10)
    {
      memset(v13, 170, 12);
      __sprintf_chk(v13, 0, 0xCuLL, "%010u", *((_DWORD *)v9 + 706));
      v10 = VRLogfileAlloc(0, (uint64_t)v13, (uint64_t)"AFRC", (uint64_t)".bbdump", "com.apple.VideoConference.AFRClogBB", 32);
      v9[356] = (FILE *)v10;
    }
    if (v8)
      v11 = "STime\t\tATime\t\tV-R-A-F-T\tQD\tQD2\tXmitB\tLTxTS\tIBR\tABRS\tABRL\tBDS\tBDL\tBDCD\tNBDCD\tND\tHT\tTR\tAF\n";
    else
      v11 = "STime\t\tV-R-A-F-T\tQD\tQD2\tXmitB\tLTxTS\tIBR\tIBR_OLD\tABRS\tABRL\tBDS\tBDCD\tNBDCD\tND\tTR\tAF\n";
    return VRLogfilePrintSync(v10, v11, a3, a4, a5, a6, a7, a8, v12);
  }
  return result;
}

uint64_t AFRCMarkResetCS()
{
  pthread_mutex_t *v0;
  pthread_mutex_t *v1;
  pthread_mutex_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v0 = (pthread_mutex_t *)CheckInHandleDebug();
  if (!v0)
    return 2149646338;
  v1 = v0;
  v2 = v0 + 40;
  pthread_mutex_lock(v0 + 40);
  *(_DWORD *)&v1[41].__opaque[24] = 0;
  pthread_mutex_unlock(v2);
  VRLogfilePrintWithTimestamp(*(_QWORD *)&v1[44].__opaque[8], "%s", v3, v4, v5, v6, v7, v8, (char)"reset connection stats.\n");
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCSetConnectionNumber(uint64_t a1, int a2)
{
  pthread_mutex_t *v3;
  pthread_mutex_t *v4;
  pthread_mutex_t *v5;
  int v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint8_t buf[4];
  uint64_t v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v3 = (pthread_mutex_t *)CheckInHandleDebug();
  if (!v3)
    return 2149646338;
  v4 = v3;
  v5 = v3 + 40;
  pthread_mutex_lock(v3 + 40);
  v6 = *(_DWORD *)v4[41].__opaque;
  if (v6 != a2)
  {
    *(_DWORD *)v4[41].__opaque = a2;
    *(_DWORD *)&v4[41].__opaque[24] = 1;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v7 = VRTraceErrorLogLevelToCSTR();
      v8 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136316162;
        v17 = v7;
        v18 = 2080;
        v19 = "AFRCSetConnectionNumber";
        v20 = 1024;
        v21 = 5739;
        v22 = 1024;
        v23 = v6;
        v24 = 1024;
        v25 = a2;
        _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d AFRCSetConnectionNumber (%d->%d)", buf, 0x28u);
      }
    }
  }
  pthread_mutex_unlock(v5);
  VRLogfilePrintWithTimestamp(*(_QWORD *)&v4[44].__opaque[8], "connection #: (%d->%d).\n", v9, v10, v11, v12, v13, v14, v6);
  CheckOutHandleDebug();
  return 0;
}

void BWEstResetRecvrBWState(uint64_t a1, int a2)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)(a1 + 672) = 0;
  *(_QWORD *)(a1 + 968) = 0;
  *(_BYTE *)(a1 + 980) = 0;
  *(_QWORD *)(a1 + 984) = 0;
  *(_DWORD *)(a1 + 992) = 0;
  *(_DWORD *)(a1 + 976) = 0;
  *(_QWORD *)(a1 + 1120) = 0;
  *(_QWORD *)(a1 + 920) = 0;
  *(_QWORD *)(a1 + 912) = 0;
  *(_DWORD *)(a1 + 928) = 0;
  *(_QWORD *)(a1 + 936) = 0;
  *(_QWORD *)(a1 + 952) = 0;
  *(_QWORD *)(a1 + 944) = 0;
  *(_DWORD *)(a1 + 960) = 0;
  if (a2)
  {
    *(_DWORD *)(a1 + 1040) = 0;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136315650;
      v5 = v2;
      v6 = 2080;
      v7 = "BWEstResetRecvrBWState";
      v8 = 1024;
      v9 = 5870;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d BWEstResetRecvrBWState", (uint8_t *)&v4, 0x1Cu);
    }
  }
}

uint64_t AFRCSetBWEstMode(uint64_t a1, int a2, unsigned __int8 a3)
{
  uint64_t v5;
  unsigned __int8 *v6;
  uint64_t v7;
  NSObject *v8;
  NSObject *v9;
  int v10;
  int v11;
  const char *v12;
  NSObject *v13;
  uint32_t v14;
  uint64_t v16;
  NSObject *v17;
  NSObject *v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v5 = CheckInHandleDebug();
  if (!v5)
    return 2149646338;
  v6 = (unsigned __int8 *)v5;
  if (a2)
  {
    *(_WORD *)(v5 + 722) = *(_WORD *)(v5 + 724);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v7 = VRTraceErrorLogLevelToCSTR();
      v8 = *MEMORY[0x1E0CF2758];
      v9 = *MEMORY[0x1E0CF2758];
      if (!*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
        {
          v19 = v6[722];
          v20 = v6[723];
          v21 = 136316162;
          v22 = v7;
          v23 = 2080;
          v24 = "AFRCSetBWEstMode";
          v25 = 1024;
          v26 = 6522;
          v27 = 1024;
          v28 = v19;
          v29 = 1024;
          v30 = v20;
          _os_log_debug_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEBUG, "VCRC [%s] %s:%d ////^^^^ AFRCSetBWEstMode: Sender/Recvr (master) %d/%d ", (uint8_t *)&v21, 0x28u);
        }
        goto LABEL_17;
      }
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        v10 = v6[722];
        v11 = v6[723];
        v21 = 136316162;
        v22 = v7;
        v23 = 2080;
        v24 = "AFRCSetBWEstMode";
        v25 = 1024;
        v26 = 6522;
        v27 = 1024;
        v28 = v10;
        v29 = 1024;
        v30 = v11;
        v12 = "VCRC [%s] %s:%d ////^^^^ AFRCSetBWEstMode: Sender/Recvr (master) %d/%d ";
        v13 = v8;
        v14 = 40;
LABEL_12:
        _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, v12, (uint8_t *)&v21, v14);
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v16 = VRTraceErrorLogLevelToCSTR();
    v17 = *MEMORY[0x1E0CF2758];
    v18 = *MEMORY[0x1E0CF2758];
    if (!*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        AFRCSetBWEstMode_cold_1();
      goto LABEL_17;
    }
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      v21 = 136315650;
      v22 = v16;
      v23 = 2080;
      v24 = "AFRCSetBWEstMode";
      v25 = 1024;
      v26 = 6525;
      v12 = "VCRC [%s] %s:%d ////^^^^ AFRCSetBWEstMode: FALLING TO BW-EST BACKWARD COMPATIBLITY MODE";
      v13 = v17;
      v14 = 28;
      goto LABEL_12;
    }
  }
LABEL_17:
  BWEUpdateSenderRecvrEnabledStates((uint64_t)v6);
  v6[732] = a3;
  BWEUpdateFilterType((uint64_t)v6);
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCGetSendersLogState(uint64_t a1, BOOL *a2, BOOL *a3)
{
  if (!CheckInHandleDebug())
    return 2149646338;
  *a2 = g_iBWEstLogLevel > 6;
  *a3 = g_iBWEstLogLevel > 0;
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCGetSenderRecvrModes(uint64_t a1, _BYTE *a2, _BYTE *a3)
{
  uint64_t v5;

  v5 = CheckInHandleDebug();
  if (!v5)
    return 2149646338;
  *a2 = *(_BYTE *)(v5 + 720);
  *a3 = *(_BYTE *)(v5 + 721);
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCSetBWECap(uint64_t a1, unsigned int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t i;
  int v6;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  unsigned int v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149646338;
  v4 = v3;
  if (a2)
  {
    for (i = 0; i != 38; ++i)
    {
      if (g_adwTxRateTiers[i] >= a2)
        break;
    }
    if (i >= 0x24)
      LODWORD(i) = 36;
    v6 = g_adwTxRateTiers[(i + 1)];
  }
  else
  {
    v6 = 0;
  }
  *(_DWORD *)(v3 + 1040) = v6;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v8 = VRTraceErrorLogLevelToCSTR();
    v9 = *MEMORY[0x1E0CF2758];
    v10 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        v11 = *(_DWORD *)(v4 + 1040);
        v13 = 136316162;
        v14 = v8;
        v15 = 2080;
        v16 = "AFRCSetBWECap";
        v17 = 1024;
        v18 = 6597;
        v19 = 1024;
        v20 = a2;
        v21 = 1024;
        v22 = v11;
        _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d AFRCSetBWECap newBitrateCap: %d -> dwFakeBitrateCap: %d  ", (uint8_t *)&v13, 0x28u);
      }
    }
    else if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      v12 = *(_DWORD *)(v4 + 1040);
      v13 = 136316162;
      v14 = v8;
      v15 = 2080;
      v16 = "AFRCSetBWECap";
      v17 = 1024;
      v18 = 6597;
      v19 = 1024;
      v20 = a2;
      v21 = 1024;
      v22 = v12;
      _os_log_debug_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEBUG, "VCRC [%s] %s:%d AFRCSetBWECap newBitrateCap: %d -> dwFakeBitrateCap: %d  ", (uint8_t *)&v13, 0x28u);
    }
  }
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCSetWrmMetrics(uint64_t a1, _DWORD *a2)
{
  uint64_t v3;
  int v4;
  int v5;
  _BOOL4 v6;

  if (!a2)
    return 2149580801;
  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149646338;
  v4 = *(_DWORD *)(v3 + 252);
  a2[50] = *(_DWORD *)(v3 + 9696);
  a2[51] = v4;
  a2[52] = *(_DWORD *)(v3 + 44) / 0x3E8u;
  v5 = *(_DWORD *)(v3 + 2928);
  a2[54] = (*(double *)(v3 + 176) * 100.0);
  a2[55] = v5;
  if (*(_DWORD *)(v3 + 2472))
    v6 = 1;
  else
    v6 = *(_DWORD *)(v3 + 2476) != 0;
  a2[56] = v6;
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCSetStatisticsCollector(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  if (!a2)
    return 2149580801;
  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149646338;
  *(_QWORD *)(v3 + 9760) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t AFRCLog_TailFile(uint64_t a1)
{
  uint64_t result;
  FILE *v2;
  int v3;
  int v4;
  FILE *v5;
  int v6;
  FILE *v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE __b[4096];
  uint64_t v14;

  result = MEMORY[0x1E0C80A78](a1);
  v14 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v5 = v2;
    if (v2)
    {
      v6 = v4;
      v7 = (FILE *)result;
      fprintf((FILE *)result, "========== Start logging from File %d ==========\n", v3);
      memset(__b, 170, sizeof(__b));
      v8 = (1500 * v6);
      v9 = MEMORY[0x1DF088398](v5);
      if (v9 <= v8)
      {
        v11 = v9;
        result = fseek(v5, 0, 0);
        v8 = v11;
LABEL_9:
        if (v8 >= 1)
        {
          do
          {
            result = fread(__b, 1uLL, 0x1000uLL, v5);
            if (!result)
              break;
            v12 = result;
            result = fwrite(__b, 1uLL, result, v7);
            v10 = v8 <= v12;
            v8 -= v12;
          }
          while (!v10);
        }
      }
      else
      {
        result = fseek(v5, -v8, 2);
        while (1)
        {
          v10 = v8-- < 1;
          if (v10)
            break;
          result = fgetc(v5);
          if ((_DWORD)result == 10)
            goto LABEL_9;
        }
      }
    }
  }
  return result;
}

uint64_t calculateInitialRampUpDeltas(uint64_t result)
{
  _BYTE *v1;

  v1 = (_BYTE *)(result + 9800);
  if (!*(_BYTE *)(result + 9800))
  {
    micro();
    result = reportingAdaptiveLearningStats();
    *v1 = 1;
  }
  return result;
}

void DetectCongestion(uint64_t a1, int a2, int *a3, int a4, double a5, double a6, double a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  double v20;
  unsigned int v21;
  double v22;
  uint64_t v23;
  double v24;
  double v25;
  double v26;
  int v27;
  int v28;
  uint64_t v29;
  NSObject *v30;
  double v31;
  int v32;
  double v33;
  double v34;
  int v35;
  int v36;
  int v37;
  int v38;
  unsigned int v39;
  uint64_t v40;
  unsigned int v41;
  int v42;
  int v43;
  const char *v44;
  const char *v45;
  double v46;
  int v47;
  uint64_t v48;
  int v49;
  double v50;
  int v51;
  uint64_t v52;
  NSObject *v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  unint64_t v62;
  unsigned int v63;
  double v64;
  int v65;
  uint64_t v66;
  NSObject *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  int v74;
  double v75;
  signed int v76;
  uint64_t v78;
  NSObject *v79;
  int v80;
  int v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  int v88;
  double v89;
  signed int v90;
  int v91;
  uint64_t v92;
  NSObject *v93;
  double v94;
  int v95;
  uint64_t v96;
  uint64_t v97;
  int v98;
  int v99;
  int v100;
  int v101;
  uint64_t v102;
  const char *v103;
  int v104;
  double *v105;
  BOOL v106;
  int v107;
  unsigned int v108;
  int v109;
  uint64_t v110;
  double *v111;
  double *v112;
  double v113;
  double v114;
  double v115;
  double v116;
  double v117;
  double v118;
  double v119;
  double *v120;
  unsigned int v121;
  int v122;
  uint64_t v123;
  double *v124;
  double *v125;
  double v126;
  double v127;
  double v128;
  double v129;
  double v130;
  double v131;
  double v132;
  double v133;
  double v134;
  int v135;
  double v136;
  int v137;
  double v138;
  int v140;
  double v141;
  double v142;
  int v143;
  int v144;
  double v145;
  double v146;
  double v147;
  int v148;
  int v149;
  int v150;
  unsigned int *v151;
  int v152;
  int v153;
  int v154;
  double v155;
  double v156;
  double v157;
  _BYTE buf[12];
  __int16 v159;
  const char *v160;
  __int16 v161;
  int v162;
  __int16 v163;
  _BYTE v164[10];
  _BYTE v165[14];
  __int16 v166;
  double v167;
  __int16 v168;
  _BYTE v169[10];
  _BYTE v170[10];
  _BYTE v171[10];
  __int16 v172;
  _BYTE v173[10];
  double v174;
  _BYTE v175[6];
  uint64_t v176;
  int v177;
  __int16 v178;
  int v179;
  __int16 v180;
  unsigned int v181;
  __int16 v182;
  unsigned int v183;
  __int16 v184;
  uint64_t v185;
  __int16 v186;
  unsigned int v187;
  __int16 v188;
  int v189;
  __int16 v190;
  int v191;
  __int16 v192;
  const char *v193;
  __int16 v194;
  const char *v195;
  uint64_t v196;

  v196 = *MEMORY[0x1E0C80C00];
  v20 = micro();
  v21 = *(_DWORD *)(a1 + 1392) + *(_DWORD *)(a1 + 1388);
  if (!a4
    || (v22 = v20, v23 = *(int *)(a1 + 1412), (int)v23 >= 1)
    && a5 - *(double *)(a1 + 8 * (v23 - 1) + 1416) < 0.01)
  {
    *a3 = 0;
    v24 = 0.0;
    v25 = -1.0;
    v26 = 0.0;
LABEL_5:
    v27 = *a3;
    if (*(_DWORD *)(a1 + 2816))
    {
      v28 = *(_DWORD *)(a1 + 2820);
      *(_DWORD *)(a1 + 2820) = v28 + 1;
      if ((v28 & 0xF) == 0 && (int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v29 = VRTraceErrorLogLevelToCSTR();
        v30 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v31 = v25;
          if (v25 == -1.0)
            v31 = *(double *)(a1 + 2448);
          if (v27)
            v32 = 79;
          else
            v32 = 88;
          v33 = *(double *)(a1 + 176) * 100.0;
          v34 = *(double *)(a1 + 184) * 100.0;
          v35 = *(_DWORD *)(a1 + 2700);
          v36 = *(_DWORD *)(a1 + 2704);
          v38 = *(_DWORD *)(a1 + 252);
          v37 = *(_DWORD *)(a1 + 256);
          v39 = *(_DWORD *)(a1 + 44) / 0x3E8u;
          v40 = *((_QWORD *)&g_apszStMode + *(int *)(a1 + 1400));
          v41 = *(_DWORD *)(a1 + 2968) / 0x3E8u;
          v42 = *(_DWORD *)(a1 + 3036) + *(_DWORD *)(a1 + 3032);
          v43 = *(_DWORD *)(a1 + 2980);
          v44 = " UAT";
          if (!*(_BYTE *)(a1 + 3026))
            v44 = " LAT";
          if (*(_DWORD *)(a1 + 2472))
          {
            v45 = " _";
          }
          else if (*(_DWORD *)(a1 + 2476))
          {
            v45 = " -";
          }
          else if (*(_DWORD *)(a1 + 2404))
          {
            v45 = " <";
          }
          else if (*(_DWORD *)(a1 + 2400))
          {
            v45 = " >";
          }
          else
          {
            v45 = "";
          }
          *(_DWORD *)buf = 136321282;
          *(_QWORD *)&buf[4] = v29;
          v159 = 2080;
          v160 = "AFRCLog_PrintCongestionFullInfo";
          v161 = 1024;
          v162 = 1018;
          v163 = 2048;
          *(double *)v164 = a5;
          *(_WORD *)&v164[8] = 1024;
          *(_DWORD *)v165 = (unsigned __int16)a2;
          *(_WORD *)&v165[4] = 2048;
          *(double *)&v165[6] = a6;
          v166 = 2048;
          v167 = v26;
          v168 = 2048;
          *(double *)v169 = v24;
          *(_WORD *)&v169[8] = 2048;
          *(double *)v170 = v31;
          *(_WORD *)&v170[8] = 1024;
          *(_DWORD *)v171 = v32;
          *(_WORD *)&v171[4] = 1024;
          *(_DWORD *)&v171[6] = (a7 * 1000.0);
          v172 = 2048;
          *(double *)v173 = v33;
          *(_WORD *)&v173[8] = 2048;
          v174 = v34;
          *(_WORD *)v175 = 1024;
          *(_DWORD *)&v175[2] = v35;
          LOWORD(v176) = 1024;
          *(_DWORD *)((char *)&v176 + 2) = v36;
          HIWORD(v176) = 1024;
          v177 = v38;
          v178 = 1024;
          v179 = v37;
          v180 = 1024;
          v181 = v21 / 0x3E8;
          v182 = 1024;
          v183 = v39;
          v184 = 2080;
          v185 = v40;
          v186 = 1024;
          v187 = v41;
          v188 = 1024;
          v189 = v42;
          v190 = 1024;
          v191 = v43;
          v192 = 2080;
          v193 = v44;
          v194 = 2080;
          v195 = v45;
          _os_log_impl(&dword_1D8A54000, v30, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d AFRC: %8.3f/%04X: %.4f %.4f %.4f %.4f %c RTT:%u PLR:%4.1f@%.1f %u %u RRx:%u MBL:%d %3u/%3u%s\tBB: %u\t%u\t%u\t%s%s", buf, 0xC8u);
        }
      }
    }
    if (*(_QWORD *)(a1 + 2832))
    {
      v157 = 0.0;
      *(_QWORD *)buf = 0;
      v155 = 0.0;
      v156 = 0.0;
      MediaQueue_RetrieveAudioVideoRates(*(_QWORD *)(a1 + 2808), (double *)buf, &v157, &v156, &v155);
      VRLogfilePrintWithTimestamp(*(_QWORD *)(a1 + 2832), "%8.3f/%04X:\t%.4f\t%.4f\t%.4f\t%.4f %c\tRTT:%-4u\tPLR:%4.1f@%.1f\tRRx:%u\tMBL:%d %u\t%3u/%3u\t %3u:%3u/%3u  %3u:%3u/%3u CS: %1d %3u %3u BB: %u\t%u\t%u\t%s%s%s\t%d\t%d/%d\n", ((v156 + v155) / 1000.0), (v156 / 1000.0), (v155 / 1000.0), *(unsigned int *)(a1 + 2968) / 0x3E8uLL, (*(_DWORD *)(a1 + 3036) + *(_DWORD *)(a1 + 3032)), *(unsigned int *)(a1 + 2980), SLOBYTE(a5));
    }
    return;
  }
  v46 = *(double *)(a1 + 2464) * 30.0;
  v47 = (int)v46;
  if ((int)v23 >= (int)v46)
  {
    if ((int)v23 <= v47)
    {
      memmove((void *)(a1 + 1416), (const void *)(a1 + 1424), 8 * (v47 - 1));
      memmove((void *)(a1 + 1896), (const void *)(a1 + 1904), 8 * ((int)(*(double *)(a1 + 2464) * 30.0) - 1));
      *(double *)(a1 + 1416 + 8 * (int)(*(double *)(a1 + 2464) * 30.0) - 8) = a5;
      v46 = *(double *)(a1 + 2464) * 30.0;
      *(double *)(a1 + 1896 + 8 * (int)v46 - 8) = a6;
    }
    else
    {
      v49 = v23 - v47 + 1;
      memmove((void *)(a1 + 1416), (const void *)(a1 + 1416 + 8 * v49), 8 * (v47 - 1));
      memmove((void *)(a1 + 1896), (const void *)(a1 + 1896 + 8 * v49), 8 * ((int)(*(double *)(a1 + 2464) * 30.0) - 1));
      *(double *)(a1 + 1416 + 8 * (int)(*(double *)(a1 + 2464) * 30.0) - 8) = a5;
      *(double *)(a1 + 1896 + 8 * (int)(*(double *)(a1 + 2464) * 30.0) - 8) = a6;
      v46 = *(double *)(a1 + 2464) * 30.0;
      *(_DWORD *)(a1 + 1412) = (int)v46;
    }
  }
  else
  {
    v48 = a1 + 8 * v23;
    *(double *)(v48 + 1416) = a5;
    *(double *)(v48 + 1896) = a6;
    *(_DWORD *)(a1 + 1412) = v23 + 1;
    *(double *)(a1 + 2384) = a5;
    *(double *)(a1 + 2392) = a5;
  }
  LODWORD(v46) = *(_DWORD *)(a1 + 44);
  v50 = (double)*(unint64_t *)&v46 * 0.75;
  if (v50 <= (double)v21 || (v51 = *(_DWORD *)(a1 + 28), v51 <= *(_DWORD *)(a1 + 40)))
  {
    if (*(_DWORD *)(a1 + 2404))
    {
      v50 = v22 - *(double *)(a1 + 2416);
      if (v50 > 1.0 && (*(_BYTE *)(a1 + 2960) & 1) == 0)
      {
        if (*(_DWORD *)(a1 + 1400) != 3)
        {
          *(_DWORD *)(a1 + 1400) = 4;
          ++*(_DWORD *)(a1 + 1404);
          if (*(_DWORD *)(a1 + 2816))
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v52 = VRTraceErrorLogLevelToCSTR();
              v53 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                v54 = *(_DWORD *)(a1 + 1404);
                *(_DWORD *)buf = 136315906;
                *(_QWORD *)&buf[4] = v52;
                v159 = 2080;
                v160 = "DetectCongestion";
                v161 = 1024;
                v162 = 3720;
                v163 = 1024;
                *(_DWORD *)v164 = v54;
                _os_log_impl(&dword_1D8A54000, v53, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d AFRC: [%u] Rate was limited", buf, 0x22u);
              }
            }
          }
          VRLogfilePrint(*(_QWORD *)(a1 + 2832), "[%u] Rate was limited\n", v14, v15, v16, v17, v18, v19, *(_DWORD *)(a1 + 1404));
          VRLogfilePrintWithTimestamp(*(_QWORD *)(a1 + 2848), "Rate is limited(%ukbps).\n", v55, v56, v57, v58, v59, v60, *(_DWORD *)(a1 + 44) / 0x3E8u);
        }
        *(double *)(a1 + 2384) = a5;
        *(double *)(a1 + 2392) = a5;
      }
      *(_DWORD *)(a1 + 2404) = 0;
    }
  }
  else if (v51 < 7 || !*(_DWORD *)(a1 + 9696))
  {
    *a3 = 0;
    if (!*(_DWORD *)(a1 + 2404))
      *(double *)(a1 + 2416) = v22;
    *(_DWORD *)(a1 + 2404) = 1;
  }
  LODWORD(v50) = *(_DWORD *)(a1 + 44);
  if ((double)*(unint64_t *)&v50 * 1.25 >= (double)v21)
  {
    if (!*(_DWORD *)(a1 + 2400))
      goto LABEL_46;
    v61 = 0;
  }
  else
  {
    v61 = 1;
  }
  *(_DWORD *)(a1 + 2400) = v61;
LABEL_46:
  if (!*(_DWORD *)(a1 + 1400))
    goto LABEL_73;
  v157 = NAN;
  LODWORD(v156) = -1431655766;
  if (*(_DWORD *)(a1 + 1408) != *(_DWORD *)(a1 + 1404))
  {
    MediaQueue_GetTimeRateChanged(*(_QWORD *)(a1 + 2808), &v157, &v156);
    if (LODWORD(v156) < *(_DWORD *)(a1 + 1404)
      || (v62 = MicroToNTP(v157), v63 = NTPToMiddle32(v62), a2 == -1)
      || (unsigned __int16)(a2 - (v63 >> 6)) > 0x7FFEu)
    {
      *(_DWORD *)(a1 + 2424) = 0;
    }
    else
    {
      v64 = a5 + 1.0;
      if (!*(_DWORD *)(a1 + 2948))
        v64 = a5;
      *(double *)(a1 + 2432) = v64;
      *(_DWORD *)(a1 + 2424) = 1;
      *(_DWORD *)(a1 + 1408) = *(_DWORD *)(a1 + 1404);
      *(_DWORD *)(a1 + 2484) = 0;
      v65 = (unsigned __int16)(v63 >> 6);
      if (*(_DWORD *)(a1 + 2816))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v66 = VRTraceErrorLogLevelToCSTR();
          v67 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136316418;
            *(_QWORD *)&buf[4] = v66;
            v159 = 2080;
            v160 = "DetectCongestion";
            v161 = 1024;
            v162 = 3776;
            v163 = 1024;
            *(_DWORD *)v164 = LODWORD(v156);
            *(_WORD *)&v164[4] = 1024;
            *(_DWORD *)&v164[6] = a2;
            *(_WORD *)v165 = 1024;
            *(_DWORD *)&v165[2] = v65;
            _os_log_impl(&dword_1D8A54000, v67, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d AFRC: [%u] Stabilized (TxTS %u >= %u FB). now collecting samples...", buf, 0x2Eu);
          }
        }
      }
      VRLogfilePrint(*(_QWORD *)(a1 + 2832), "[%u] Stabilized (TxTS %u >= %u FB). now collecting samples...\n", v14, v15, v16, v17, v18, v19, SLOBYTE(v156));
      VRLogfilePrintWithTimestamp(*(_QWORD *)(a1 + 2848), "Rate(%ukbps) stabilized.\n", v68, v69, v70, v71, v72, v73, *(_DWORD *)(a1 + 44) / 0x3E8u);
    }
  }
  v74 = *(_DWORD *)(a1 + 2424);
  if (v74 >= 1)
  {
    v75 = *(double *)(a1 + 2464);
    v76 = vcvtd_n_s64_f64(v75, 2uLL);
    if (a5 - *(double *)(a1 + 2432) >= v75 * 0.5 && v74 >= v76)
    {
      if (*(_DWORD *)(a1 + 2816))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v78 = VRTraceErrorLogLevelToCSTR();
          v79 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v80 = *(_DWORD *)(a1 + 1404);
            v81 = *(_DWORD *)(a1 + 2424);
            *(_DWORD *)buf = 136316418;
            *(_QWORD *)&buf[4] = v78;
            v159 = 2080;
            v160 = "DetectCongestion";
            v161 = 1024;
            v162 = 3797;
            v163 = 1024;
            *(_DWORD *)v164 = v80;
            *(_WORD *)&v164[4] = 1024;
            *(_DWORD *)&v164[6] = v81;
            *(_WORD *)v165 = 1024;
            *(_DWORD *)&v165[2] = a2;
            _os_log_impl(&dword_1D8A54000, v79, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d AFRC: [%u] Collected %d samples (TxTS %u)", buf, 0x2Eu);
          }
        }
      }
      VRLogfilePrint(*(_QWORD *)(a1 + 2832), "[%u] Collected %d samples (TxTS %u)\n", v14, v15, v16, v17, v18, v19, *(_DWORD *)(a1 + 1404));
      VRLogfilePrintWithTimestamp(*(_QWORD *)(a1 + 2848), "AFRC collected %d samples.\n", v82, v83, v84, v85, v86, v87, *(_DWORD *)(a1 + 2424));
      *(_DWORD *)(a1 + 2424) = 0;
      *(_DWORD *)(a1 + 1400) = 0;
      goto LABEL_73;
    }
    *(_DWORD *)(a1 + 2424) = v74 + 1;
  }
  if (*(_DWORD *)(a1 + 1400))
    *a3 = 0;
LABEL_73:
  if (*(_DWORD *)(a1 + 2408) && *(_DWORD *)(a1 + 1400) != 3 && a5 - *(double *)(a1 + 2432) > 2.0)
    *(_DWORD *)(a1 + 2408) = 0;
  v88 = *(_DWORD *)(a1 + 1412);
  v89 = *(double *)(a1 + 2464);
  v90 = vcvtd_n_s64_f64(v89, 2uLL);
  v91 = v88 - v90;
  if (v88 >= v90)
  {
    v104 = v88 - v90;
    if (v91 >= 1)
    {
      v105 = (double *)(a1 + 1416 + 8 * v91);
      v104 = v91;
      while (*(double *)(a1 + 1416 + 8 * (v88 - 1)) - *v105 <= v89 * 0.5)
      {
        --v105;
        v106 = __OFSUB__(v104--, 1);
        if ((v104 < 0) ^ v106 | (v104 == 0))
        {
          v104 = 0;
          break;
        }
      }
    }
    v107 = *(_DWORD *)(a1 + 1396);
    if ((v107 & 1) == 0
      || (v26 = 0.0, *(double *)(a1 + 1416 + 8 * (v88 - 1)) - *(double *)(a1 + 1416 + 8 * v104) >= 0.2))
    {
      v108 = v88 - v104;
      if (v88 - v104 < 1)
      {
        v119 = NAN;
      }
      else
      {
        v109 = v104 + (v108 >> 1);
        v110 = (v108 + 1) >> 1;
        v111 = (double *)(a1 + 8 * v109 + 1416);
        v112 = (double *)(a1 + 8 * v104 + 1416);
        v113 = 0.0;
        v114 = 0.0;
        v115 = 0.0;
        v116 = 0.0;
        do
        {
          v116 = v116 + v112[60];
          v115 = v115 + v111[60];
          v117 = *v112++;
          v114 = v114 + v117;
          v118 = *v111++;
          v113 = v113 + v118;
          --v110;
        }
        while (v110);
        v119 = (v115 - v116) / (v113 - v114);
      }
      v26 = v89 * 0.5 * v119;
    }
    if (v91 >= 1)
    {
      v120 = (double *)(a1 + 1416 + 8 * v91);
      while (*(double *)(a1 + 1416 + 8 * (v88 - 1)) - *v120 <= v89 * 0.25)
      {
        --v120;
        v106 = __OFSUB__(v91--, 1);
        if ((v91 < 0) ^ v106 | (v91 == 0))
        {
          v91 = 0;
          break;
        }
      }
    }
    if ((v107 & 1) == 0
      || (v24 = 0.0, *(double *)(a1 + 1416 + 8 * (v88 - 1)) - *(double *)(a1 + 1416 + 8 * v91) >= 0.2))
    {
      v121 = v88 - v91;
      if (v88 - v91 < 1)
      {
        v132 = NAN;
      }
      else
      {
        v122 = v91 + (v121 >> 1);
        v123 = (v121 + 1) >> 1;
        v124 = (double *)(a1 + 8 * v122 + 1416);
        v125 = (double *)(a1 + 8 * v91 + 1416);
        v126 = 0.0;
        v127 = 0.0;
        v128 = 0.0;
        v129 = 0.0;
        do
        {
          v129 = v129 + v125[60];
          v128 = v128 + v124[60];
          v130 = *v125++;
          v127 = v127 + v130;
          v131 = *v124++;
          v126 = v126 + v131;
          --v123;
        }
        while (v123);
        v132 = (v128 - v129) / (v126 - v127);
      }
      v24 = v89 * 0.25 * v132;
      if (a6 > 0.0 && v24 == 0.0)
      {
        v133 = *(double *)(a1 + 2376);
        if (v133 == 0.0)
        {
          *(double *)(a1 + 2376) = a5;
        }
        else if (a5 - v133 > 2.0)
        {
          *(_DWORD *)(a1 + 1396) = v107 | 2;
          *(double *)(a1 + 2384) = a5;
          *(double *)(a1 + 2392) = a5;
          *(_QWORD *)(a1 + 2448) = 0;
          *(_QWORD *)(a1 + 2376) = 0;
          *a3 = 0;
          v88 = *(_DWORD *)(a1 + 1412);
        }
      }
      else
      {
        *(_QWORD *)(a1 + 2376) = 0;
      }
    }
    v134 = *(double *)(a1 + 2448)
         + v26 * (*(double *)(a1 + 8 * v88 + 1408) - *(double *)(a1 + 8 * v88 + 1400)) / (v89 * 0.5);
    if (v134 < 0.0)
      v134 = 0.0;
    *(double *)(a1 + 2448) = v134;
    if (a6 > 2.0 || v26 > 0.001 || a6 > 0.0 && v24 == 0.0)
      *a3 = 0;
    v135 = *(_DWORD *)(a1 + 1396);
    v136 = 0.0;
    if ((v135 & 4) != 0)
    {
      v137 = *(_DWORD *)(a1 + 2404);
      if (v24 <= 0.0)
        goto LABEL_136;
      v138 = v89 * *((double *)&xmmword_1D9108D80 + (v137 != 0));
      if (v26 <= v138)
        goto LABEL_136;
      if (*(double *)(a1 + 2440) <= v138 || v137 != 0)
        goto LABEL_136;
      v136 = v26;
      if (!*(_DWORD *)(a1 + 2484))
      {
        v135 |= 2u;
        *(_DWORD *)(a1 + 1396) = v135;
        *(double *)(a1 + 2384) = a5;
        *(double *)(a1 + 2392) = a5;
        *(_QWORD *)(a1 + 2448) = 0;
        v134 = 0.0;
LABEL_136:
        v136 = v26;
      }
    }
    *(double *)(a1 + 2440) = v136;
    v140 = *(_DWORD *)(a1 + 1400);
    if (v140 && v140 != 3)
    {
      v25 = -1.0;
      if (!*(_DWORD *)(a1 + 2424))
      {
LABEL_153:
        if (a6 <= 0.0)
        {
          v146 = *(double *)(a1 + 2536);
        }
        else
        {
          *(double *)(a1 + 2536) = a5;
          v146 = a5;
        }
        if (v146 > 0.0)
        {
          v147 = a5 - v146;
          if (v147 > 1.0)
          {
            *(_QWORD *)(a1 + 2448) = 0;
            *(double *)(a1 + 2536) = a5;
            VRLogfilePrint(*(_QWORD *)(a1 + 2832), "OWRD has been 0 for %f seconds, reset NOWRDAcc\n", v14, v15, v16, v17, v18, v19, SLOBYTE(v147));
          }
        }
        if (*(_DWORD *)(a1 + 2948) && *(double *)(a1 + 2448) > *(double *)(a1 + 2464) * 0.1 * 0.5)
          *a3 = 0;
        if (*(_DWORD *)(a1 + 9696) && *(_BYTE *)(a1 + 9700) && (*(_BYTE *)(a1 + 1396) & 1) == 0)
          *a3 = 0;
        v148 = *(_DWORD *)(a1 + 252);
        v149 = *(_DWORD *)(a1 + 28);
        if (!v148
          || (v149 >= 35 ? (v150 = 35) : (v150 = *(_DWORD *)(a1 + 28)),
              v151 = (unsigned int *)&g_adwTxRateTiers[v150 + 1],
              1000 * v148 < ((double)*v151 + (double)(v151[1] - *v151) * 0.25)))
        {
          *(double *)(a1 + 2384) = a5;
        }
        if (v149 >= 36)
          v152 = 36;
        else
          v152 = v149;
        v153 = *(_DWORD *)(a1 + 2944);
        if (!v153
          || *(_DWORD *)(a1 + 2928)
          || !v148
          || 1000 * v148 > ((double)*(unsigned int *)(a1 + 44)
                                        + (double)(g_adwTxRateTiers[v152 + 1] - *(_DWORD *)(a1 + 44))
                                        * 0.25))
        {
          *(double *)(a1 + 2392) = a5;
        }
        v154 = *(_DWORD *)(a1 + 1396);
        if ((v154 & 2) == 0 && a5 - *(double *)(a1 + 2392) > 2.0)
        {
          v154 |= 0x12u;
          *(_DWORD *)(a1 + 1396) = v154;
          *(double *)(a1 + 2384) = a5;
          *(double *)(a1 + 2392) = a5;
          *(_QWORD *)(a1 + 2448) = 0;
        }
        if (*(_BYTE *)(a1 + 9837) && *(_DWORD *)(a1 + 256) >= 7u && *(_DWORD *)(a1 + 276) && v149 >= 13)
        {
          v154 |= 2u;
          *(_DWORD *)(a1 + 1396) = v154;
          *(double *)(a1 + 2384) = a5;
          *(double *)(a1 + 2392) = a5;
          *(_QWORD *)(a1 + 2448) = 0;
          *(_BYTE *)(a1 + 9820) = 1;
        }
        if ((v154 & 3) == 0 && (!*(_DWORD *)(a1 + 2928) || *(int *)(a1 + 9572) >= 1))
        {
          if ((v154 & 4) != 0)
          {
            if (!*(_DWORD *)(a1 + 1400)
              && a5 - *(double *)(a1 + 2432) > *(double *)(a1 + 2456) + *(double *)(a1 + 2456))
            {
              *(_DWORD *)(a1 + 1396) = v154 & 0xFFFFFFFB;
            }
          }
          else if (*a3
                 && (!v153
                  || (*(_BYTE *)(a1 + 2960) & 1) != 0
                  || a5 - *(double *)(a1 + 2384) > (*(double *)(a1 + 2464) + *(double *)(a1 + 2464))
                                                 * *(double *)(a1 + 2456)))
          {
            *(_DWORD *)(a1 + 1396) = v154 | 0xC;
            *(double *)(a1 + 2384) = a5;
            *(double *)(a1 + 2392) = a5;
          }
        }
        goto LABEL_5;
      }
    }
    else
    {
      v25 = -1.0;
    }
    if (v136 <= v26 && !*(_DWORD *)(a1 + 2484))
    {
      v141 = (v135 & 4) != 0 && !*(_DWORD *)(a1 + 2404) ? 0.1 : 0.15;
      v142 = v89 * v141;
      if (v134 > v142)
      {
        v143 = *(_DWORD *)(a1 + 28);
        v144 = *(_DWORD *)(a1 + 40);
        if (v143 > v144)
        {
          *(_DWORD *)(a1 + 1396) = v135 | 2;
          *(double *)(a1 + 2384) = a5;
          *(double *)(a1 + 2392) = a5;
          if (!*(_DWORD *)(a1 + 2948) || v143 > v144 + 1)
          {
            v145 = v134 - v142;
            *(double *)(a1 + 2448) = v145;
            if (v145 < 0.0)
              *(_QWORD *)(a1 + 2448) = 0;
          }
          v25 = v134;
        }
      }
    }
    goto LABEL_153;
  }
  *a3 = 0;
  if (*(_DWORD *)(a1 + 2816))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v92 = VRTraceErrorLogLevelToCSTR();
      v93 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v94 = micro();
        v95 = *(_DWORD *)(a1 + 1412);
        v96 = *(_QWORD *)(a1 + 176);
        v97 = *(_QWORD *)(a1 + 184);
        v98 = *(_DWORD *)(a1 + 2700);
        v99 = *(_DWORD *)(a1 + 2704);
        v100 = *(_DWORD *)(a1 + 252);
        v101 = *(_DWORD *)(a1 + 256);
        v102 = *((_QWORD *)&g_apszStMode + *(int *)(a1 + 1400));
        *(_DWORD *)buf = 136318978;
        *(_QWORD *)&buf[4] = v92;
        v159 = 2080;
        v160 = "AFRCLog_PrintCongestionInfo";
        v161 = 1024;
        v162 = 938;
        v163 = 2048;
        *(double *)v164 = v94;
        *(_WORD *)&v164[8] = 2048;
        *(double *)v165 = a5;
        *(_WORD *)&v165[8] = 1024;
        *(_DWORD *)&v165[10] = (unsigned __int16)a2;
        v166 = 2048;
        v167 = a6;
        v168 = 1024;
        *(_DWORD *)v169 = v95;
        *(_WORD *)&v169[4] = 1024;
        *(_DWORD *)&v169[6] = v21;
        *(_WORD *)v170 = 2048;
        *(_QWORD *)&v170[2] = v96;
        *(_WORD *)v171 = 2048;
        *(_QWORD *)&v171[2] = v97;
        v172 = 1024;
        *(_DWORD *)v173 = v98;
        *(_WORD *)&v173[4] = 1024;
        *(_DWORD *)&v173[6] = v99;
        LOWORD(v174) = 1024;
        *(_DWORD *)((char *)&v174 + 2) = v100;
        HIWORD(v174) = 1024;
        *(_DWORD *)v175 = v101;
        *(_WORD *)&v175[4] = 2080;
        v176 = v102;
        _os_log_impl(&dword_1D8A54000, v93, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d AFRC: %8.3f %.3f/%04X %.4f(%d) %u %.4f %.4f %u %u %u %u%s", buf, 0x82u);
      }
    }
  }
  if (*(_QWORD *)(a1 + 2832))
  {
    v157 = 0.0;
    *(_QWORD *)buf = 0;
    v155 = 0.0;
    v156 = 0.0;
    MediaQueue_RetrieveAudioVideoRates(*(_QWORD *)(a1 + 2808), (double *)buf, &v157, &v156, &v155);
    if (*(_BYTE *)(a1 + 3026))
      v103 = " UAT";
    else
      v103 = " LAT";
    VRLogfilePrintWithTimestamp(*(_QWORD *)(a1 + 2832), "%8.3f\t%8.3f/%04X:\t%.4f(%d)\t\t\t\tRTT:%-4u\tPLR:%4.1f@%.1f\t%2u\t%2u\tRRx:%u\tMBL:%u\t%3u/%3u\t %3u:%3u/%3u  %3u:%3u/%3u\tBB: %u\t%u\t%u\t%s%s\n", (*(_DWORD *)(a1 + 3036) + *(_DWORD *)(a1 + 3032)), (uint64_t)v103, *((_QWORD *)&g_apszStMode + *(int *)(a1 + 1400)), *(unsigned int *)(a1 + 1412), *(unsigned int *)(a1 + 2700), *(unsigned int *)(a1 + 2704), SLOBYTE(v22));
  }
}

uint64_t CalculateBasebandRate(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned int *a4, int a5)
{
  double v10;
  int v11;
  int v12;
  unsigned int v13;
  int v14;
  unsigned int v15;
  _BYTE *v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  double v24;
  uint64_t v25;
  const char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  __int128 v33;
  uint64_t v35;
  uint64_t v36;
  __int128 v37;
  __int128 v38;
  uint64_t v39;
  double v40;
  double v42;
  unsigned int v43;
  int v44;
  int v45;
  unint64_t v46;
  unsigned int v47;
  int v48;
  unsigned int v49;
  unsigned int v50;
  unsigned int v51;

  v10 = (double)(*(_DWORD *)(a2 + 36) - *(_DWORD *)(a1 + 3044)) * 0.001;
  v11 = *(_DWORD *)(a2 + 32) - *(_DWORD *)(a1 + 3040);
  v12 = v11 & ~(v11 >> 31);
  if (v11 < 1)
  {
    v13 = 0;
  }
  else
  {
    if (v10 == 0.0)
      return 0;
    v13 = ((double)(8 * v12) / v10);
  }
  v14 = v12
      - ((*(_DWORD *)(a2 + 28) - *(_DWORD *)(a1 + 3036)) & ~((*(_DWORD *)(a2 + 28) - *(_DWORD *)(a1 + 3036)) >> 31));
  if (v14 >= 1)
  {
    if (v10 != 0.0)
    {
      v15 = ((double)(8 * (v14 & ~(v14 >> 31))) / v10);
      goto LABEL_9;
    }
    return 0;
  }
  v15 = 0;
LABEL_9:
  if (!*(_DWORD *)(a1 + 2928))
    goto LABEL_17;
  v16 = (_BYTE *)(a1 + 9664);
  v17 = (_QWORD *)(a1 + 2980);
  v24 = micro();
  if ((*(_BYTE *)(a1 + 1396) & 1) != 0)
  {
    *v16 = 0;
    goto LABEL_16;
  }
  if (*v16)
  {
    if (v24 - *(double *)(a1 + 9672) > 3.0)
    {
      *v16 = 0;
      *(_DWORD *)(a1 + 9688) = 0;
      v25 = *(_QWORD *)(a1 + 2832);
      v26 = "Get Out of Antenna Imbalance Mode!\n";
LABEL_14:
      VRLogfilePrint(v25, "%s", v18, v19, v20, v21, v22, v23, (char)v26);
      VRLogfilePrintWithTimestamp(*(_QWORD *)(a1 + 2848), "%s", v27, v28, v29, v30, v31, v32, (char)v26);
      goto LABEL_17;
    }
    goto LABEL_17;
  }
  if (v15 >= 0x3E8)
  {
LABEL_16:
    *(_QWORD *)&v33 = *(_QWORD *)(a1 + 2968);
    *(_DWORD *)(a1 + 9648) = *(_DWORD *)(a1 + 28);
    *((_QWORD *)&v33 + 1) = *v17;
    *(_OWORD *)(a1 + 9632) = v33;
    *(_QWORD *)(a1 + 9656) = *(_QWORD *)(a1 + 9576);
    *(_DWORD *)(a1 + 9688) = 0;
    *(_DWORD *)(a1 + 9692) = *(_DWORD *)(a1 + 2480);
    goto LABEL_17;
  }
  v50 = *(_DWORD *)(a1 + 9688) + 1;
  *(_DWORD *)(a1 + 9688) = v50;
  if (v50 >= 5 && v24 - *(double *)(a1 + 9680) > 3.0)
  {
    *v16 = 1;
    *(double *)(a1 + 9672) = v24;
    v25 = *(_QWORD *)(a1 + 2832);
    v26 = "Get Into of Antenna Imbalance Mode!\n";
    goto LABEL_14;
  }
LABEL_17:
  if (v10 <= 0.005 && v10 != 0.0)
    return 0;
  *a3 = v15;
  *a4 = v13;
  *(_DWORD *)(a1 + 2964) = v15;
  *(_DWORD *)(a1 + 2976) = *(_DWORD *)(a1 + 2968);
  v35 = *(int *)(a1 + 9056);
  if ((int)v35 > 14)
  {
    memmove((void *)(a1 + 9064), (const void *)(a1 + 9072), 0x70uLL);
    v37 = *(_OWORD *)(a1 + 9188);
    *(_OWORD *)(a1 + 9200) = *(_OWORD *)(a1 + 9204);
    *(_OWORD *)(a1 + 9184) = v37;
    *(_OWORD *)(a1 + 9216) = *(_OWORD *)(a1 + 9220);
    *(_QWORD *)(a1 + 9232) = *(_QWORD *)(a1 + 9236);
    v38 = *(_OWORD *)(a1 + 9264);
    *(_OWORD *)(a1 + 9244) = *(_OWORD *)(a1 + 9248);
    *(_OWORD *)(a1 + 9260) = v38;
    *(_OWORD *)(a1 + 9276) = *(_OWORD *)(a1 + 9280);
    *(_QWORD *)(a1 + 9292) = *(_QWORD *)(a1 + 9296);
    *(_QWORD *)(a1 + 9176) = *(_QWORD *)(a2 + 8);
    *(_DWORD *)(a1 + 9240) = *(_DWORD *)(a2 + 32);
    *(_DWORD *)(a1 + 9300) = *(_DWORD *)(a2 + 28);
    LODWORD(v36) = *(_DWORD *)(a1 + 9056);
  }
  else
  {
    *(_QWORD *)(a1 + 8 * v35 + 9064) = *(_QWORD *)(a2 + 8);
    *(_DWORD *)(a1 + 4 * v35 + 9184) = *(_DWORD *)(a2 + 32);
    *(_DWORD *)(a1 + 4 * *(int *)(a1 + 9056) + 9244) = *(_DWORD *)(a2 + 28);
    LODWORD(v36) = *(_DWORD *)(a1 + 9056) + 1;
    *(_DWORD *)(a1 + 9056) = v36;
  }
  if ((int)v36 >= 2)
  {
    v39 = (v36 - 1);
    v36 = v36;
    v40 = *(double *)(a1 + 8 * v39 + 9064);
    while (v36-- > 1)
    {
      v42 = v40 - *(double *)(a1 + 8 * v36 + 9064);
      if (v42 >= 0.5)
      {
        v36 = v36;
        goto LABEL_30;
      }
    }
    v36 = 0;
    v42 = v40 - *(double *)(a1 + 9064);
LABEL_30:
    v44 = *(_DWORD *)(a1 + 9184 + 4 * v39) - *(_DWORD *)(a1 + 9184 + 4 * v36);
    v45 = *(_DWORD *)(a1 + 9244 + 4 * v39) - *(_DWORD *)(a1 + 9244 + 4 * v36);
    v43 = ((double)(8
                                * (((v44 & ~(v44 >> 31)) - (v45 & ~(v45 >> 31))) & ~(((v44 & ~(v44 >> 31))
                                                                                    - (v45 & ~(v45 >> 31))) >> 31)))
                       / v42);
    HIDWORD(v46) = 1069757235;
    if (v42 < 0.15 && v43 - 1 >= *(_DWORD *)(a1 + 44))
      v43 = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a1 + 2968) = v43;
    if (a5 && v43)
    {
      v47 = *(_DWORD *)(a1 + 44);
      if (v47 >= v43)
        v47 = v43;
      *(_DWORD *)(a1 + 2972) = v47;
    }
    else
    {
      LODWORD(v46) = *(_DWORD *)(a1 + 2972);
      v47 = ((double)v43 * 0.025 + (double)v46 * 0.975);
      *(_DWORD *)(a1 + 2972) = v47;
      if (!v43)
      {
        if (!(*(_DWORD *)(a2 + 24) + *(_DWORD *)(a2 + 28)))
        {
          v43 = 0;
          goto LABEL_44;
        }
        if (v42 >= 0.5 && *(double *)(a1 + 2504) > 0.0)
        {
          v51 = *(_DWORD *)(a1 + 2980);
          if (v51 <= 0x7D1)
            v51 = 2001;
          *(_DWORD *)(a1 + 2980) = v51;
        }
        v43 = 0;
        if (!v47)
        {
          v49 = *(_DWORD *)(a1 + 2980);
          if (v49 <= 0x7D1)
            v49 = 2001;
          goto LABEL_43;
        }
        v48 = *(_DWORD *)(a2 + 28) + *(_DWORD *)(a2 + 24);
LABEL_42:
        v49 = ((double)(8000 * v48) / (double)v47);
LABEL_43:
        *(_DWORD *)(a1 + 2984) = v49;
        goto LABEL_44;
      }
    }
    if (!*(_DWORD *)(a1 + 2976))
    {
      *(_DWORD *)(a1 + 2972) = v43;
      v47 = v43;
    }
    *(_DWORD *)(a1 + 2980) = ((double)(8000 * (*(_DWORD *)(a2 + 28) + *(_DWORD *)(a2 + 24)))
                                          / (double)v43);
    v48 = *(_DWORD *)(a2 + 28) + *(_DWORD *)(a2 + 24);
    goto LABEL_42;
  }
  v43 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 2968) = v43;
  *(_DWORD *)(a1 + 2972) = v43;
LABEL_44:
  if (v43 >= *(_DWORD *)(a1 + 8)
    || !(*(_DWORD *)(a2 + 24) + *(_DWORD *)(a2 + 28)) && !(*(_DWORD *)(a1 + 3032) + *(_DWORD *)(a1 + 3036))
    || (*(_BYTE *)(a1 + 2960) & 1) == 0)
  {
    *(double *)(a1 + 2528) = micro();
  }
  return 1;
}

uint64_t RampDownAudio(uint64_t result, double a2)
{
  uint64_t v2;
  double v3;
  unsigned int v4;
  double v5;

  v2 = result;
  if ((*(_DWORD *)(result + 2472) || (*(_BYTE *)(result + 2960) & 1) != 0) && a2 - *(double *)(result + 2528) >= 2.0)
  {
    v3 = 0.333333333;
    if (*(double *)(result + 9576) > 0.333333333)
    {
      v4 = *(_DWORD *)(result + 2968);
      v5 = 0.666666667;
      if (v4 >> 5 >= 0x271)
        v5 = 1.0;
      if (v4 >> 3 >= 0x753)
        v3 = v5;
      *(double *)(result + 9576) = v3;
      *(double *)(result + 2528) = a2;
      *(double *)(result + 9584) = a2;
      MediaQueue_SetAudioFraction(v3);
      return UpdateFECLevel(v2);
    }
  }
  return result;
}

void UpdateAudioTxInfo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  double v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  unsigned int v16;
  double v17;
  BOOL v18;
  BOOL v19;
  double v20;
  int v22;
  uint64_t v23;
  NSObject *v24;
  int v25;
  int v26;
  uint8_t buf[4];
  uint64_t v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  int v32;
  __int16 v33;
  int v34;
  __int16 v35;
  int v36;
  __int16 v37;
  unsigned int v38;
  __int16 v39;
  unsigned int v40;
  __int16 v41;
  unsigned int v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v9 = *(double *)(a1 + 9576);
  if (v9 >= 1.0)
  {
    v10 = *(_DWORD *)(a1 + 44);
  }
  else if (v9 == 0.333333333)
  {
    v10 = 12000;
  }
  else
  {
    v10 = 16000;
  }
  *(_DWORD *)(a1 + 48) = v10;
  v11 = *(_DWORD *)(a1 + 1392);
  v12 = *(_DWORD *)(a1 + 2968);
  v13 = *(_DWORD *)(a1 + 3036) + *(_DWORD *)(a1 + 3032);
  v14 = 8 * v13;
  v15 = *(_DWORD *)(a1 + 2680);
  if (v15)
  {
    if (*(_DWORD *)(a1 + 9848))
      v16 = *(_DWORD *)(a1 + 9848);
    else
      v16 = *(_DWORD *)(a1 + 1392);
    v17 = micro();
    if ((double)v16 * 1.5 <= (double)v12
      || (v17 - *(double *)(a1 + 9840) >= 0.25 ? (v18 = v12 >= v16) : (v18 = 0),
          v18 ? (v19 = v14 > 2 * v12) : (v19 = 1),
          !v19))
    {
      *(_DWORD *)(a1 + 2680) = 0;
      v20 = micro() - *(double *)(a1 + 2672);
      *(double *)(a1 + 2664) = *(double *)(a1 + 2664) + v20;
      if (v20 <= *(double *)(a1 + 2688))
        v20 = *(double *)(a1 + 2688);
      *(double *)(a1 + 2688) = v20;
    }
  }
  else
  {
    if (v10 >= v11)
      v16 = *(_DWORD *)(a1 + 1392);
    else
      v16 = v10;
    if (v12 < v16 && v13 > ((v11 >> 2) & 0x1FFFFFFF))
    {
      *(double *)(a1 + 2672) = micro();
      *(_DWORD *)(a1 + 2680) = 1;
    }
  }
  v22 = *(_DWORD *)(a1 + 2680);
  if (v22 | v15 && (int)*MEMORY[0x1E0CF2740] >= 5)
  {
    StallModeTracePrint_(5, (uint64_t)"VCRC", a3, a4, " fAudioPaused: %d BBAvgTxRate: %10d txTarget: %10d (%d)   QDepth_bits: %10d ", a6, a7, a8, v22);
    v22 = *(_DWORD *)(a1 + 2680);
  }
  if ((v15 != 0) == (v22 == 0) && (int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v23 = VRTraceErrorLogLevelToCSTR();
    v24 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v25 = *(_DWORD *)(a1 + 2680);
      v26 = *(_DWORD *)(a1 + 2968);
      *(_DWORD *)buf = 136316930;
      v28 = v23;
      v29 = 2080;
      v30 = "UpdateAudioTxInfo";
      v31 = 1024;
      v32 = 3033;
      v33 = 1024;
      v34 = v25;
      v35 = 1024;
      v36 = v26;
      v37 = 1024;
      v38 = v16;
      v39 = 1024;
      v40 = v11;
      v41 = 1024;
      v42 = v14;
      _os_log_impl(&dword_1D8A54000, v24, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d  fAudioPaused: %d BBAvgTxRate: %10d txTarget: %10d (%d)   QDepth_bits: %10d ", buf, 0x3Au);
    }
  }
}

uint64_t BWEstCalcLargeFrameSize(uint64_t a1, int a2)
{
  unsigned int v3;
  double v5;
  unsigned int v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  NSObject *v11;
  NSObject *v12;
  int v13;
  unsigned int v14;
  int v15;
  int v16;
  int v18;
  int v19;
  uint64_t v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  unsigned int v26;
  __int16 v27;
  int v28;
  __int16 v29;
  unsigned int v30;
  __int16 v31;
  int v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 1104))
    a2 = 1;
  v5 = 0.1;
  if (a2)
    v5 = 0.05;
  v6 = (v5 * (double)((*(_DWORD *)(a1 + 44) - *(_DWORD *)(a1 + 1392)) >> 3));
  v3 = 5 * *(_DWORD *)(a1 + 252);
  v7 = (v3 >> 1) & 0x1FFFFFFF;
  if (v6 >= (20 * *(_DWORD *)(a1 + 252)) >> 3)
    v8 = (v3 >> 1) & 0x1FFFFFFF;
  else
    v8 = (v5 * (double)((*(_DWORD *)(a1 + 44) - *(_DWORD *)(a1 + 1392)) >> 3));
  if (v8 <= 0x101)
    v9 = 257;
  else
    v9 = v8;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v10 = VRTraceErrorLogLevelToCSTR();
    v11 = *MEMORY[0x1E0CF2758];
    v12 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        v13 = *(_DWORD *)(a1 + 252);
        v19 = 136316674;
        v20 = v10;
        v21 = 2080;
        v22 = "setCapOnLF";
        v23 = 1024;
        v24 = 6011;
        v25 = 1024;
        v26 = v9;
        v27 = 1024;
        v28 = v7;
        v29 = 1024;
        v30 = v6;
        v31 = 1024;
        v32 = v13;
        _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d ^^^^^ LARGE frame req'd of %d (%d, %d, R %d)", (uint8_t *)&v19, 0x34u);
      }
    }
    else if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      v18 = *(_DWORD *)(a1 + 252);
      v19 = 136316674;
      v20 = v10;
      v21 = 2080;
      v22 = "setCapOnLF";
      v23 = 1024;
      v24 = 6011;
      v25 = 1024;
      v26 = v9;
      v27 = 1024;
      v28 = v7;
      v29 = 1024;
      v30 = v6;
      v31 = 1024;
      v32 = v18;
      _os_log_debug_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEBUG, "VCRC [%s] %s:%d ^^^^^ LARGE frame req'd of %d (%d, %d, R %d)", (uint8_t *)&v19, 0x34u);
    }
  }
  if (v9 < 0xABE)
  {
    if (v9 < 0x6D6)
    {
      if (v9 < 0x1F4)
      {
        if (v9 <= 0x112)
          v15 = 257;
        else
          v15 = v9;
        v14 = 1;
      }
      else
      {
        v16 = v9 >> 1;
        if (v9 >> 1 <= 0x100)
          v16 = 256;
        v15 = v16 + 1;
        v14 = 2;
      }
    }
    else
    {
      v15 = (unsigned __int16)v9 / 3u + 1;
      v14 = 3;
    }
  }
  else
  {
    v14 = 2;
    do
      ++v14;
    while (v9 / v14 > 0x564);
    v15 = v9 / v14 + 1;
  }
  *(_DWORD *)(a1 + 1076) = v15;
  *(_DWORD *)(a1 + 1080) = v14;
  return v15 * v14;
}

void OUTLINED_FUNCTION_7_2(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x28u);
}

void OUTLINED_FUNCTION_8_4(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x22u);
}

uint64_t MediaQueue_CreateHandle(uint64_t *a1, uint64_t a2)
{
  char *v4;
  uint64_t v5;
  uint64_t Handle;
  uint64_t v7;
  pthread_mutex_t *v9;

  v4 = (char *)malloc_type_calloc(1uLL, 0x6400uLL, 0x102004011FBE5E6uLL);
  if (v4)
  {
    v5 = (uint64_t)v4;
    *((_DWORD *)v4 + 2) = 1;
    *((_DWORD *)v4 + 186) = 1;
    *((_WORD *)v4 + 432) = 257;
    *((_QWORD *)v4 + 109) = 0x3FF0000000000000;
    *((_DWORD *)v4 + 220) = 1;
    *((_QWORD *)v4 + 111) = 0x3FF0000000000000;
    *((_QWORD *)v4 + 112) = 0x3FF0000000000000;
    *((_QWORD *)v4 + 117) = a2;
    v4[208] = 0;
    *(_OWORD *)(v4 + 920) = 0u;
    *((_QWORD *)v4 + 3193) = 0x7FF8000000000000;
    *((_QWORD *)v4 + 91) = 0;
    v9 = (pthread_mutex_t *)(v4 + 24);
    pthread_mutex_init((pthread_mutex_t *)(v4 + 24), 0);
    pthread_mutex_init((pthread_mutex_t *)(v5 + 144), 0);
    pthread_mutex_init((pthread_mutex_t *)(v5 + 248), 0);
    pthread_mutex_init((pthread_mutex_t *)(v5 + 312), 0);
    pthread_mutex_init((pthread_mutex_t *)(v5 + 392), 0);
    pthread_cond_init((pthread_cond_t *)(v5 + 456), 0);
    pthread_mutex_init((pthread_mutex_t *)(v5 + 512), 0);
    pthread_mutex_init((pthread_mutex_t *)(v5 + 752), 0);
    pthread_cond_init((pthread_cond_t *)(v5 + 816), 0);
    *(_QWORD *)(v5 + 592) = 0;
    *(_BYTE *)(v5 + 584) = 0;
    *(_BYTE *)(v5 + 600) = 0;
    *(_QWORD *)(v5 + 604) = 0;
    *(_WORD *)(v5 + 612) = 0;
    *(_QWORD *)(v5 + 624) = 0;
    *(_QWORD *)(v5 + 616) = 0;
    Throttling_MediaQueue_Init(v5 + 632);
    Handle = CreateHandle();
    v7 = 0;
    *a1 = Handle;
    if (Handle == 0xFFFFFFFFLL)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          MediaQueue_CreateHandle_cold_2();
      }
      pthread_mutex_destroy(v9);
      pthread_mutex_destroy((pthread_mutex_t *)(v5 + 144));
      pthread_mutex_destroy((pthread_mutex_t *)(v5 + 248));
      pthread_mutex_destroy((pthread_mutex_t *)(v5 + 312));
      pthread_mutex_destroy((pthread_mutex_t *)(v5 + 392));
      pthread_cond_destroy((pthread_cond_t *)(v5 + 456));
      pthread_mutex_destroy((pthread_mutex_t *)(v5 + 512));
      pthread_mutex_destroy((pthread_mutex_t *)(v5 + 752));
      pthread_cond_destroy((pthread_cond_t *)(v5 + 816));
      ActiveProbing_Uninit(v5);
      free((void *)v5);
      return 2149580802;
    }
  }
  else
  {
    v7 = 2149580803;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        MediaQueue_CreateHandle_cold_1();
    }
  }
  return v7;
}

void ActiveProbing_Uninit(uint64_t a1)
{
  pthread_mutex_t *v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v2 = (pthread_mutex_t *)(a1 + 392);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 392));
  v3 = *(_QWORD **)(a1 + 592);
  if (v3)
  {
    do
    {
      v4 = (_QWORD *)v3[196];
      VCMediaControlInfoDispose(v3[198]);
      free(v3);
      v3 = v4;
    }
    while (v4);
  }
  *(_QWORD *)(a1 + 592) = 0;
  pthread_mutex_unlock(v2);
  if (*(_BYTE *)(a1 + 613) && (int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v5 = VRTraceErrorLogLevelToCSTR();
    v6 = *MEMORY[0x1E0CF2758];
    v7 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        v8 = *(_DWORD *)(a1 + 616);
        v9 = *(_DWORD *)(a1 + 620);
        v10 = 136316162;
        v11 = v5;
        v12 = 2080;
        v13 = "ActiveProbing_Uninit";
        v14 = 1024;
        v15 = 1435;
        v16 = 1024;
        v17 = v8;
        v18 = 1024;
        v19 = v9;
        _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d ^^^^^^ \t\tActiveProbing_Uninit  V/A packets sent: %d/%d", (uint8_t *)&v10, 0x28u);
      }
    }
    else if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      ActiveProbing_Uninit_cold_1();
    }
  }
  Throttling_MediaQueue_Uninit(a1 + 632, v2);
}

uint64_t MediaQueue_CloseHandle()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  io_object_t v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;

  v0 = CheckInHandleDebug();
  if (!v0)
    return 2149580802;
  v1 = v0;
  _MediaQueue_Stop(v0);
  CheckOutHandleDebug();
  SetCellularAudioStallState_Internal(v1, 0, 1, v2, v3, v4, v5, v6);
  v7 = *(_DWORD *)(v1 + 728);
  if (v7)
  {
    IOObjectRelease(v7);
    *(_DWORD *)(v1 + 728) = 0;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v1 + 312));
  v8 = *(_QWORD **)(v1 + 376);
  if (v8)
  {
    do
    {
      v9 = (_QWORD *)v8[196];
      free(v8);
      v8 = v9;
    }
    while (v9);
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v1 + 312));
  pthread_mutex_lock((pthread_mutex_t *)(v1 + 392));
  v10 = *(_QWORD **)(v1 + 504);
  if (v10)
  {
    do
    {
      v11 = (_QWORD *)v10[196];
      VCMediaControlInfoDispose(v10[198]);
      free(v10);
      v10 = v11;
    }
    while (v11);
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v1 + 392));
  pthread_mutex_lock((pthread_mutex_t *)(v1 + 512));
  v12 = *(_QWORD **)(v1 + 576);
  if (v12)
  {
    do
    {
      v13 = (_QWORD *)v12[2];
      free(v12);
      v12 = v13;
    }
    while (v13);
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v1 + 512));
  ActiveProbing_Uninit(v1);
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 24));
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 144));
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 248));
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 312));
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 392));
  pthread_cond_destroy((pthread_cond_t *)(v1 + 456));
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 512));
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 752));
  pthread_cond_destroy((pthread_cond_t *)(v1 + 816));
  free((void *)v1);
  return 0;
}

uint64_t _MediaQueue_Stop(uint64_t a1)
{
  pthread_mutex_t *v2;
  uint64_t result;

  v2 = (pthread_mutex_t *)(a1 + 752);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 752));
  if (*(_DWORD *)(a1 + 732))
  {
    *(_DWORD *)(a1 + 732) = 0;
    *(_DWORD *)(a1 + 744) = 0;
    pthread_cond_signal((pthread_cond_t *)(a1 + 816));
  }
  pthread_mutex_unlock(v2);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 392));
  *(_DWORD *)(a1 + 8) = 0;
  pthread_cond_broadcast((pthread_cond_t *)(a1 + 456));
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 392));
  result = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    result = FigThreadJoin();
    *(_QWORD *)a1 = 0;
  }
  return result;
}

uint64_t SetCellularAudioStallState_Internal(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned __int8 *v10;
  int *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  double v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char v30;

  v10 = (unsigned __int8 *)(a1 + 25552);
  v11 = (int *)MEMORY[0x1E0CF2740];
  if ((int)*MEMORY[0x1E0CF2740] >= 5)
    StallModeTracePrint_(5, (uint64_t)"", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/MediaQueue/MediaQueue.c", 2245, "MediaQueue_ThrottlingSetCellularAudioStallState stalled: %d (old: %d close: %d) pMediaQueue: %p %d/%p ", a6, a7, a8, a2);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 392));
  if (*v10 != a2)
  {
    v19 = micro();
    if (a2)
    {
      *(_OWORD *)(a1 + 25568) = 0u;
      *(double *)(a1 + 25560) = v19;
      *((_DWORD *)v10 + 8) = 0;
      v10[36] = 1;
      *((_DWORD *)v10 + 10) = 0;
    }
    else
    {
      if (v10[1])
      {
        if (*v10)
          drainOldPackets(a1, v19 + -1.0, v12, v13, v14, v15, v16, v17, v18);
        dropWaitingPkts(a1, *(_QWORD *)(a1 + 25576), v13, v14, v15, v16, v17, v18);
        *(_QWORD *)(a1 + 25576) = 0;
        pushOutQueuedAudioPkts(a1, 1, v20, v21, v22, v23, v24, v25);
        v10[1] = 0;
      }
      else
      {
        drainOldPackets(a1, v19, v12, v13, v14, v15, v16, v17, v18);
      }
      *(_QWORD *)(a1 + 25568) = 0;
      v10[36] = 0;
      *((_DWORD *)v10 + 10) = 0;
      if (*v11 >= 5)
        StallModeTracePrint_(5, (uint64_t)"", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/MediaQueue/MediaQueue.c", 2308, " ------------------", v26, v27, v28, v30);
    }
    *v10 = a2;
  }
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 392));
}

uint64_t MediaQueue_Start()
{
  uint64_t v0;
  _QWORD *v1;
  uint64_t v2;
  void *v3;
  void *v4;
  CFDictionaryRef v5;
  int v6;
  void *values[2];
  void *keys[3];

  keys[2] = *(void **)MEMORY[0x1E0C80C00];
  v0 = 2149580820;
  v1 = (_QWORD *)CheckInHandleDebug();
  if (!v1)
    return 2149580802;
  if (*v1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v2 = VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        MediaQueue_Start_cold_2(v2);
    }
  }
  else
  {
    v3 = (void *)*MEMORY[0x1E0CA52D0];
    keys[0] = *(void **)MEMORY[0x1E0CA52C8];
    keys[1] = v3;
    v4 = (void *)*MEMORY[0x1E0C9AE40];
    values[0] = CFSTR("com.apple.avconference.mediaqueue.sendproc");
    values[1] = v4;
    v5 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)keys, (const void **)values, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v6 = FigThreadCreate();
    if (v5)
      CFRelease(v5);
    if (v6)
    {
      v0 = v6 | 0xA0200000;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          MediaQueue_Start_cold_1();
      }
    }
    else
    {
      v0 = 0;
    }
    CheckOutHandleDebug();
  }
  return v0;
}

uint64_t MediaQueueSendProc()
{
  int ErrorLogLevelForModule;
  NSObject **v1;
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  pthread_mutex_t *v6;
  uint64_t *v7;
  pthread_cond_t *v8;
  pthread_mutex_t *v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  NSObject *v15;
  double v16;
  int v17;
  unsigned int v18;
  unsigned int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  uint64_t v24;
  double v25;
  int v26;
  unsigned int v27;
  unsigned int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  uint64_t v33;
  NSObject *v34;
  uint8_t buf[4];
  uint64_t v37;
  __int16 v38;
  const char *v39;
  __int16 v40;
  int v41;
  __int16 v42;
  double v43;
  __int16 v44;
  int v45;
  __int16 v46;
  unsigned int v47;
  __int16 v48;
  unsigned int v49;
  __int16 v50;
  int v51;
  __int16 v52;
  int v53;
  __int16 v54;
  int v55;
  __int16 v56;
  int v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  v1 = (NSObject **)MEMORY[0x1E0CF2758];
  if (ErrorLogLevelForModule >= 7)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *v1;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      v37 = v2;
      v38 = 2080;
      v39 = "MediaQueueSendProc";
      v40 = 1024;
      v41 = 381;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d MediaQueueSendProc Thread start...", buf, 0x1Cu);
    }
  }
  v4 = CheckInHandleDebug();
  if (!v4)
    return -2145386494;
  v5 = v4;
  v6 = (pthread_mutex_t *)(v4 + 392);
  v7 = (uint64_t *)(v4 + 504);
  v8 = (pthread_cond_t *)(v4 + 456);
  v9 = (pthread_mutex_t *)(v4 + 752);
  while (1)
  {
    pthread_mutex_lock(v6);
    while (1)
    {
      v10 = *v7;
      if (*v7)
        break;
      if (!*(_DWORD *)(v5 + 8))
        goto LABEL_28;
      pthread_cond_wait(v8, v6);
    }
    if (!*(_DWORD *)(v5 + 8))
      break;
    v11 = v7;
    v12 = *v7;
    if (*(_BYTE *)(v10 + 1576))
    {
LABEL_12:
      v11 = v7;
    }
    else
    {
      while (*(_DWORD *)(v12 + 1516))
      {
        v24 = *(_QWORD *)(v12 + 1568);
        if (v24)
        {
          v11 = (uint64_t *)(v12 + 1568);
          v12 = *(_QWORD *)(v12 + 1568);
          if (!*(_BYTE *)(v24 + 1576))
            continue;
        }
        goto LABEL_12;
      }
      v10 = v12;
    }
    *v11 = *(_QWORD *)(v10 + 1568);
    *(_QWORD *)(v10 + 1568) = 0;
    --*(_DWORD *)(v5 + 624);
    pthread_mutex_unlock(v6);
    if (*(_BYTE *)(v5 + 613) && (int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v13 = VRTraceErrorLogLevelToCSTR();
      v14 = *MEMORY[0x1E0CF2758];
      v15 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          v16 = micro();
          v17 = *(_DWORD *)(v10 + 1516);
          v18 = bswap32(*(_DWORD *)(v10 + 1508));
          v19 = bswap32(*(unsigned __int16 *)(v10 + 1506));
          v20 = *(_DWORD *)v10;
          v21 = *(_DWORD *)(v5 + 624);
          v22 = *(_DWORD *)(v5 + 628);
          v23 = *(unsigned __int8 *)(v10 + 1576);
          *(_DWORD *)buf = 136317698;
          v37 = v13;
          v38 = 2080;
          v39 = "MediaQueueSendProc";
          v40 = 1024;
          v41 = 446;
          v42 = 2048;
          v43 = v16;
          v44 = 1024;
          v45 = v17;
          v46 = 1024;
          v47 = v18;
          v48 = 1024;
          v49 = HIWORD(v19);
          v50 = 1024;
          v51 = v20;
          v52 = 1024;
          v53 = v21;
          v54 = 1024;
          v55 = v22;
          v56 = 1024;
          v57 = v23;
          _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d SENDPROC: ^^^^^^ @%.3f\t\tMP %d  %d/%d/%d  QLen: %d/%d  Probe: %d\n", buf, 0x50u);
        }
      }
      else if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        v25 = micro();
        v26 = *(_DWORD *)(v10 + 1516);
        v27 = bswap32(*(_DWORD *)(v10 + 1508));
        v28 = bswap32(*(unsigned __int16 *)(v10 + 1506));
        v29 = *(_DWORD *)v10;
        v30 = *(_DWORD *)(v5 + 624);
        v31 = *(_DWORD *)(v5 + 628);
        v32 = *(unsigned __int8 *)(v10 + 1576);
        *(_DWORD *)buf = 136317698;
        v37 = v13;
        v38 = 2080;
        v39 = "MediaQueueSendProc";
        v40 = 1024;
        v41 = 446;
        v42 = 2048;
        v43 = v25;
        v44 = 1024;
        v45 = v26;
        v46 = 1024;
        v47 = v27;
        v48 = 1024;
        v49 = HIWORD(v28);
        v50 = 1024;
        v51 = v29;
        v52 = 1024;
        v53 = v30;
        v54 = 1024;
        v55 = v31;
        v56 = 1024;
        v57 = v32;
        _os_log_debug_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEBUG, " [%s] %s:%d SENDPROC: ^^^^^^ @%.3f\t\tMP %d  %d/%d/%d  QLen: %d/%d  Probe: %d\n", buf, 0x50u);
      }
    }
    pthread_mutex_lock(v9);
    if (*(_DWORD *)(v10 + 1516) <= 1u)
      MediaQueue_SendPacket(v5, (int *)v10);
    pthread_mutex_unlock(v9);
    MediaQueue_Free(v5, v10);
  }
LABEL_28:
  pthread_mutex_unlock(v6);
  if ((int)VRTraceGetErrorLogLevelForModule() > 6)
  {
    v33 = VRTraceErrorLogLevelToCSTR();
    v34 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      v37 = v33;
      v38 = 2080;
      v39 = "MediaQueueSendProc";
      v40 = 1024;
      v41 = 491;
      _os_log_impl(&dword_1D8A54000, v34, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d MediaQueueSendProc Thread end...", buf, 0x1Cu);
    }
  }
  CheckOutHandleDebug();
  return 0;
}

uint64_t MediaQueue_Stop()
{
  uint64_t v0;

  v0 = CheckInHandleDebug();
  if (!v0)
    return 2149580802;
  _MediaQueue_Stop(v0);
  CheckOutHandleDebug();
  return 0;
}

uint64_t MediaQueue_Malloc(double a1, uint64_t a2, int a3, double **a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  double *v10;

  v7 = 2149580803;
  v8 = CheckInHandleDebug();
  if (v8)
  {
    v9 = v8;
    if (a3 < 1501)
    {
      pthread_mutex_lock((pthread_mutex_t *)(v8 + 312));
      v10 = *(double **)(v9 + 376);
      if (v10 && a1 - v10[192] >= 1.0)
      {
        *(double *)(v9 + 376) = v10[196];
      }
      else
      {
        v10 = (double *)malloc_type_calloc(1uLL, 0x6A8uLL, 0x10A0040768C7CCBuLL);
        if (!v10)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              MediaQueue_Malloc_cold_2();
          }
          goto LABEL_14;
        }
        ++*(_DWORD *)(v9 + 12);
      }
      v7 = 0;
      *a4 = v10;
    }
    else
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          MediaQueue_Malloc_cold_1();
      }
      v7 = 1;
    }
LABEL_14:
    pthread_mutex_unlock((pthread_mutex_t *)(v9 + 312));
    CheckOutHandleDebug();
    return v7;
  }
  return 2149580802;
}

uint64_t MediaQueue_Free(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;

  if (a2)
  {
    if (*(_DWORD *)(a1 + 8))
    {
      *(_QWORD *)(a2 + 1568) = 0;
      VCMediaControlInfoDispose(*(_QWORD *)(a2 + 1584));
      *(_QWORD *)(a2 + 1584) = 0;
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 312));
      if (*(_DWORD *)(a2 + 1544))
      {
        *(_QWORD *)(a2 + 1536) = 0;
        v4 = (_QWORD *)(a1 + 376);
        v5 = *(_QWORD *)(a1 + 376);
        *(_QWORD *)(a2 + 1568) = v5;
        if (v5)
        {
LABEL_11:
          *v4 = a2;
          pthread_mutex_unlock((pthread_mutex_t *)(a1 + 312));
          return 0;
        }
        v6 = (_QWORD *)(a1 + 384);
      }
      else
      {
        v4 = (_QWORD *)(a1 + 384);
        if (*(_QWORD *)(a1 + 376))
        {
          v6 = (_QWORD *)(*v4 + 1568);
        }
        else
        {
          v6 = (_QWORD *)(a1 + 384);
          v4 = (_QWORD *)(a1 + 376);
        }
      }
      *v6 = a2;
      goto LABEL_11;
    }
    VCMediaControlInfoDispose(*(_QWORD *)(a2 + 1584));
    free((void *)a2);
  }
  return 0;
}

uint64_t MediaQueue_FreePacket(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149580802;
  MediaQueue_Free(v3, a2);
  CheckOutHandleDebug();
  return 0;
}

uint64_t MediaQueue_AddPacket(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  pthread_mutex_t *v6;
  double v7;
  double v8;
  BOOL v9;
  int active;
  int v11;
  unsigned int v12;
  unsigned int v13;
  pthread_mutex_t *v14;
  pthread_mutex_t *v15;
  unsigned int v16;
  unsigned int v17;
  pthread_mutex_t *v18;
  uint64_t sig;
  _DWORD *v20;
  _DWORD *v21;
  uint64_t v22;
  NSObject *v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  uint64_t v29;
  NSObject *v30;
  int v31;
  int v33;
  uint64_t v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  int v38;
  __int16 v39;
  unsigned int v40;
  __int16 v41;
  int v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v3 = 2149580802;
  v4 = CheckInHandleDebug();
  if (v4)
  {
    v5 = v4;
    v6 = (pthread_mutex_t *)(v4 + 392);
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 392));
    if (!*(_DWORD *)(v5 + 8))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          MediaQueue_AddPacket_cold_1();
      }
      pthread_mutex_unlock(v6);
      v3 = 2149580818;
      goto LABEL_37;
    }
    *(_QWORD *)(a2 + 1568) = 0;
    if (!*(_DWORD *)(a2 + 1516) && *(_BYTE *)(v5 + 25552))
      processAudioPktForCellularQueuing_new(v5, a2);
    v7 = micro();
    v9 = *(_DWORD *)(a2 + 1516) == 1 && (v8 = *(double *)(v5 + 25536), v8 > 0.0) && v7 - v8 > 0.07;
    *(_BYTE *)(a2 + 1596) = v9;
    active = Throttling_MediaQueue_AddPacket_ScheduleAndActiveProbing(v5 + 584, v5 + 632, (uint64_t *)(v5 + 504), a2, v7);
    if (active >= 1)
    {
      v11 = *(_DWORD *)(v5 + 624) + active;
      *(_DWORD *)(v5 + 624) = v11;
      _MediaQueue_CheckActiveProbingQueueLength(v11);
      pthread_cond_signal((pthread_cond_t *)(v5 + 456));
    }
    pthread_mutex_unlock(v6);
    v12 = *(_DWORD *)(a2 + 1512);
    v13 = *(unsigned __int16 *)(a2 + 1506);
    v14 = (pthread_mutex_t *)CheckInHandleDebug();
    if (!v14)
    {
LABEL_36:
      v3 = 0;
LABEL_37:
      CheckOutHandleDebug();
      return v3;
    }
    v15 = v14;
    v16 = bswap32(v12);
    v17 = __rev16(v13);
    v18 = v14 + 8;
    pthread_mutex_lock(v14 + 8);
    sig = v15[9].__sig;
    if (sig)
    {
      while (*(_DWORD *)sig != v16)
      {
        sig = *(_QWORD *)(sig + 16);
        if (!sig)
          goto LABEL_16;
      }
      v27 = *(_DWORD *)(sig + 8);
      v28 = v17 | (v27 << 16);
      *(_DWORD *)(a2 + 1532) = v28;
      *(_DWORD *)(sig + 4) = v28;
      if (v13 == 0xFFFF)
      {
        *(_DWORD *)(sig + 8) = v27 + 1;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v29 = VRTraceErrorLogLevelToCSTR();
          v30 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v31 = *(_DWORD *)(sig + 8);
            v33 = 136316162;
            v34 = v29;
            v35 = 2080;
            v36 = "MediaQueue_UpdateSeqNumber";
            v37 = 1024;
            v38 = 810;
            v39 = 1024;
            v40 = v16;
            v41 = 1024;
            v42 = v31;
            _os_log_impl(&dword_1D8A54000, v30, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTP(%08X): seq number wc %d", (uint8_t *)&v33, 0x28u);
          }
        }
      }
    }
    else
    {
LABEL_16:
      v20 = malloc_type_calloc(1uLL, 0x18uLL, 0x10200406E52F545uLL);
      if (!v20)
      {
        pthread_mutex_unlock(v18);
LABEL_35:
        CheckOutHandleDebug();
        goto LABEL_36;
      }
      v21 = v20;
      *v20 = v16;
      *(_DWORD *)(a2 + 1532) = v17;
      v20[1] = v17;
      if (v13 == 0xFFFF)
      {
        ++v20[2];
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v22 = VRTraceErrorLogLevelToCSTR();
          v23 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v24 = v21[2];
            v33 = 136316162;
            v34 = v22;
            v35 = 2080;
            v36 = "MediaQueue_UpdateSeqNumber";
            v37 = 1024;
            v38 = 830;
            v39 = 1024;
            v40 = v16;
            v41 = 1024;
            v42 = v24;
            _os_log_impl(&dword_1D8A54000, v23, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTP(%08X): seq number wc %d", (uint8_t *)&v33, 0x28u);
          }
        }
      }
      v25 = v15[9].__sig;
      if (v25)
      {
        do
        {
          v26 = v25;
          v25 = *(_QWORD *)(v25 + 16);
        }
        while (v25);
        *(_QWORD *)(v26 + 16) = v21;
      }
      else
      {
        v15[9].__sig = (uint64_t)v21;
      }
    }
    pthread_mutex_unlock(v18);
    goto LABEL_35;
  }
  return v3;
}

uint64_t processAudioPktForCellularQueuing_new(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  double v6;
  double v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  int v14;
  int v15;
  uint8_t buf[4];
  uint64_t v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  double v24;
  __int16 v25;
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v4 = a1 + 25553;
  if (*(_BYTE *)(a1 + 25588))
  {
    *(_BYTE *)(a1 + 25588) = 0;
    *(_DWORD *)(a1 + 25592) = bswap32(*(_DWORD *)(a2 + 1508));
  }
  if (*(_BYTE *)(a2 + 1528))
    v5 = 48;
  else
    v5 = 28;
  *(_DWORD *)(a1 + 25584) += *(_DWORD *)a2 + v5;
  v6 = micro();
  v7 = v6 - *(double *)(a1 + 25560);
  if (v7 > 1.0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v11 = VRTraceErrorLogLevelToCSTR();
      v12 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v13 = *(_QWORD *)(a1 + 25560);
        *(_DWORD *)buf = 136316162;
        v18 = v11;
        v19 = 2080;
        v20 = "processAudioPktForCellularQueuing_new";
        v21 = 1024;
        v22 = 2516;
        v23 = 2048;
        v24 = v6;
        v25 = 2048;
        v26 = v13;
        _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d processAudioPktForCellularQueuing_new: UNEXPECTED pending flush not acked yet: dNow: %f lastFlush: %f ", buf, 0x30u);
      }
    }
    v14 = ((double)(8 * *(_DWORD *)(v4 + 31)) / v7);
    *(_DWORD *)(v4 + 31) = 0;
    if ((int)*MEMORY[0x1E0CF2740] >= 5)
      StallModeTracePrint_(5, (uint64_t)"", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/MediaQueue/MediaQueue.c", 2523, "processAudioPktForCellularQueuing: issuing AUDIO FLUSH @%f cur: TS/sq: %d/%d  rate: %d ", v8, v9, v10, SLOBYTE(v6));
    v15 = *(_DWORD *)(v4 + 39) + 1;
    *(_WORD *)buf = 0;
    RTPFlushBaseband_SpecialMQAudioTS(*(_QWORD *)(a1 + 936), v15, v14, buf);
    *(_WORD *)(v4 + 43) = *(_WORD *)buf;
    *(double *)(a1 + 25560) = v6;
    *(_BYTE *)v4 = 1;
    *(_QWORD *)(a1 + 25576) = *(_QWORD *)(a1 + 25568);
    *(_QWORD *)(a1 + 25568) = 0;
    *(_DWORD *)(v4 + 39) = bswap32(*(_DWORD *)(a2 + 1508));
  }
  return 0;
}

void _MediaQueue_CheckActiveProbingQueueLength(int a1)
{
  if (a1 >= 200 && !(a1 % 0x14u) && (int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _MediaQueue_CheckActiveProbingQueueLength_cold_1();
  }
}

uint64_t MediaQueue_RexmitPacket(uint64_t a1, int a2, int a3, _DWORD *a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  pthread_mutex_t *v10;
  pthread_mutex_t *v11;
  pthread_mutex_t *v12;
  uint64_t sig;
  int v14;
  int v15;
  int v16;
  NSObject *v17;
  uint64_t v18;
  unsigned int v19;
  int v20;
  BOOL v21;
  uint64_t v23;
  unsigned int v24;
  _QWORD *v26;
  uint64_t v27;
  NSObject *v28;
  _QWORD *v29;
  uint64_t v30;
  double v31;
  uint64_t v32;
  uint64_t v34;
  uint8_t buf[4];
  uint64_t v36;
  __int16 v37;
  const char *v38;
  __int16 v39;
  int v40;
  __int16 v41;
  int v42;
  __int16 v43;
  int v44;
  __int16 v45;
  int v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  v7 = 2149580802;
  v8 = CheckInHandleDebug();
  if (v8)
  {
    v9 = v8;
    if (*(_DWORD *)(v8 + 8))
    {
      v10 = (pthread_mutex_t *)CheckInHandleDebug();
      if (!v10)
        goto LABEL_53;
      v11 = v10;
      v12 = v10 + 8;
      pthread_mutex_lock(v10 + 8);
      sig = v11[9].__sig;
      if (sig)
      {
        while (*(_DWORD *)sig != a2)
        {
          sig = *(_QWORD *)(sig + 16);
          if (!sig)
            goto LABEL_7;
        }
        v15 = 0;
        v7 = 0;
        v14 = *(_DWORD *)(sig + 4);
      }
      else
      {
LABEL_7:
        v14 = 0;
        v7 = 2149580822;
        v15 = 1;
      }
      pthread_mutex_unlock(v12);
      CheckOutHandleDebug();
      if (!v15)
      {
        v16 = a3 - (unsigned __int16)v14 + v14;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v34 = VRTraceErrorLogLevelToCSTR();
          v17 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136316418;
            v36 = v34;
            v37 = 2080;
            v38 = "MediaQueue_RexmitPacket";
            v39 = 1024;
            v40 = 1004;
            v41 = 1024;
            v42 = v14;
            v43 = 1024;
            v44 = a3;
            v45 = 1024;
            v46 = a3 - (unsigned __int16)v14 + v14;
            _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d MQ_Rexmit iLastSN(%08X) wSN(%04X) iSN(%08X)", buf, 0x2Eu);
          }
        }
        pthread_mutex_lock((pthread_mutex_t *)(v9 + 312));
        v18 = *(_QWORD *)(v9 + 376);
        if (v18)
        {
          v19 = bswap32(*(_DWORD *)(v18 + 1512));
          v20 = *(_DWORD *)(v18 + 1532);
          v21 = v19 == a2;
          if (v16 == v20 && v19 == a2)
          {
            v23 = 0;
            v26 = (_QWORD *)(v9 + 376);
LABEL_39:
            if (*(_QWORD *)(v9 + 384) == v18)
              *(_QWORD *)(v9 + 384) = v23;
            *v26 = *(_QWORD *)(v18 + 1568);
            *a4 = *(_DWORD *)v18;
            *(_DWORD *)(v18 + 1544) = 1;
            *(_QWORD *)(v18 + 1568) = 0;
            pthread_mutex_unlock((pthread_mutex_t *)(v9 + 312));
            pthread_mutex_lock((pthread_mutex_t *)(v9 + 392));
            v29 = (_QWORD *)(v9 + 504);
            v30 = *(_QWORD *)(v9 + 504);
            if (v30)
            {
              v31 = *(double *)(v18 + 1536);
              if (*(double *)(v30 + 1536) > v31)
              {
LABEL_46:
                *v29 = v18;
                *(_QWORD *)(v18 + 1568) = v30;
              }
              else
              {
                while (1)
                {
                  v32 = v30;
                  v30 = *(_QWORD *)(v30 + 1568);
                  if (!v30)
                    break;
                  if (*(double *)(v30 + 1536) > v31)
                  {
                    v29 = (_QWORD *)(v32 + 1568);
                    goto LABEL_46;
                  }
                }
              }
            }
            else
            {
              *v29 = v18;
            }
            pthread_mutex_unlock((pthread_mutex_t *)(v9 + 392));
            goto LABEL_49;
          }
          while (1)
          {
            v23 = v18;
            if (v16 < v20 && v21)
              break;
            v18 = *(_QWORD *)(v18 + 1568);
            if (!v18)
              break;
            v24 = bswap32(*(_DWORD *)(v18 + 1512));
            v20 = *(_DWORD *)(v18 + 1532);
            v21 = v24 == a2;
            if (v16 == v20 && v24 == a2)
            {
              v26 = (_QWORD *)(v23 + 1568);
              goto LABEL_39;
            }
          }
        }
        pthread_mutex_unlock((pthread_mutex_t *)(v9 + 312));
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v27 = VRTraceErrorLogLevelToCSTR();
          v28 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136316418;
            v36 = v27;
            v37 = 2080;
            v38 = "MediaQueue_RexmitPacket";
            v39 = 1024;
            v40 = 1049;
            v41 = 1024;
            v42 = 1049;
            v43 = 1024;
            v44 = a3;
            v45 = 1024;
            v46 = v16;
            _os_log_error_impl(&dword_1D8A54000, v28, OS_LOG_TYPE_ERROR, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/MediaQueue/MediaQueue.c:%d: MQ_Rexmit: missing packet wSN(%04X) iSN(%08X)\n", buf, 0x2Eu);
          }
        }
      }
      else
      {
LABEL_53:
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            MediaQueue_RexmitPacket_cold_2();
        }
      }
    }
    else
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          MediaQueue_RexmitPacket_cold_1();
      }
      v7 = 18;
    }
LABEL_49:
    CheckOutHandleDebug();
  }
  return v7;
}

uint64_t MediaQueue_SetRedundantAudio(uint64_t a1, int a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  int v9;
  uint64_t v10;
  NSObject *v11;
  int v12;
  int v14;
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v5 = CheckInHandleDebug();
  if (!v5)
    return 2149580802;
  v6 = v5;
  if (*(unsigned __int8 *)(v5 + 864) != a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v7 = VRTraceErrorLogLevelToCSTR();
      v8 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v9 = *(unsigned __int8 *)(v6 + 864);
        v14 = 136316162;
        v15 = v7;
        v16 = 2080;
        v17 = "MediaQueue_SetRedundantAudio";
        v18 = 1024;
        v19 = 1067;
        v20 = 1024;
        v21 = v9;
        v22 = 1024;
        v23 = a2;
        _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d MediaQueue_SetRedundantAudio fRedundantAudio (%d->%d)", (uint8_t *)&v14, 0x28u);
      }
    }
    *(_BYTE *)(v6 + 864) = a2;
  }
  if (*(unsigned __int8 *)(v6 + 865) != a3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v10 = VRTraceErrorLogLevelToCSTR();
      v11 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v12 = *(unsigned __int8 *)(v6 + 865);
        v14 = 136316162;
        v15 = v10;
        v16 = 2080;
        v17 = "MediaQueue_SetRedundantAudio";
        v18 = 1024;
        v19 = 1073;
        v20 = 1024;
        v21 = v12;
        v22 = 1024;
        v23 = a3;
        _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d MediaQueue_SetRedundantAudio isRedEnabled (%d->%d)", (uint8_t *)&v14, 0x28u);
      }
    }
    *(_BYTE *)(v6 + 865) = a3;
  }
  CheckOutHandleDebug();
  return 0;
}

uint64_t MediaQueue_SetAudioFraction(double a1)
{
  uint64_t v2;
  double *v3;
  pthread_mutex_t *v4;
  double v5;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  double v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v2 = CheckInHandleDebug();
  if (!v2)
    return 2149580802;
  v3 = (double *)v2;
  v4 = (pthread_mutex_t *)(v2 + 752);
  pthread_mutex_lock((pthread_mutex_t *)(v2 + 752));
  if (v3[112] != a1)
  {
    v5 = micro();
    if (a1 < 1.0 && v3[112] == 1.0)
    {
      v3[114] = v5;
    }
    else if (a1 == 1.0 && v3[112] < 1.0)
    {
      v3[113] = v3[113] + v5 - v3[114];
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v7 = VRTraceErrorLogLevelToCSTR();
      v8 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v9 = *((_QWORD *)v3 + 112);
        v10 = 136316162;
        v11 = v7;
        v12 = 2080;
        v13 = "MediaQueue_SetAudioFraction";
        v14 = 1024;
        v15 = 1102;
        v16 = 2048;
        v17 = v9;
        v18 = 2048;
        v19 = a1;
        _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d MediaQueue_SetdAudioFraction (%.2f->%.2f)", (uint8_t *)&v10, 0x30u);
      }
    }
    v3[112] = a1;
  }
  pthread_mutex_unlock(v4);
  CheckOutHandleDebug();
  return 0;
}

uint64_t MediaQueue_SetAudioFECLevel(double a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  int v8;
  uint64_t v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  double v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v2 = CheckInHandleDebug();
  if (!v2)
    return 2149580802;
  v3 = v2;
  if (*(double *)(v2 + 872) != a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v4 = VRTraceErrorLogLevelToCSTR();
      v5 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v6 = *(_QWORD *)(v3 + 872);
        v8 = 136316162;
        v9 = v4;
        v10 = 2080;
        v11 = "MediaQueue_SetAudioFECLevel";
        v12 = 1024;
        v13 = 1122;
        v14 = 2048;
        v15 = v6;
        v16 = 2048;
        v17 = a1;
        _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d MediaQueue_SetAudioFECLevel (%.3f->%.3f)", (uint8_t *)&v8, 0x30u);
      }
    }
    *(double *)(v3 + 872) = a1;
    *(_QWORD *)(v3 + 920) = 0;
  }
  CheckOutHandleDebug();
  return 0;
}

uint64_t MediaQueue_GetTimeRateChanged(uint64_t a1, _QWORD *a2, _DWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  pthread_mutex_t *v7;

  v5 = CheckInHandleDebug();
  if (!v5)
    return 2149580802;
  v6 = v5;
  v7 = (pthread_mutex_t *)(v5 + 24);
  pthread_mutex_lock((pthread_mutex_t *)(v5 + 24));
  *a2 = *(_QWORD *)(v6 + 88);
  *a3 = *(_DWORD *)(v6 + 96);
  pthread_mutex_unlock(v7);
  CheckOutHandleDebug();
  return 0;
}

uint64_t MediaQueue_GetTimeRefreshFrame(uint64_t a1, _QWORD *a2, _DWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  pthread_mutex_t *v7;

  v5 = CheckInHandleDebug();
  if (!v5)
    return 2149580802;
  v6 = v5;
  v7 = (pthread_mutex_t *)(v5 + 24);
  pthread_mutex_lock((pthread_mutex_t *)(v5 + 24));
  if (a2)
    *a2 = *(_QWORD *)(v6 + 112);
  if (a3)
    *a3 = *(_DWORD *)(v6 + 120);
  pthread_mutex_unlock(v7);
  CheckOutHandleDebug();
  return 0;
}

uint64_t MediaQueue_UpdateAudioOnlyRateChange(uint64_t a1, unsigned int a2)
{
  uint64_t v3;
  uint64_t v4;
  pthread_mutex_t *v5;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149580802;
  v4 = v3;
  v5 = (pthread_mutex_t *)(v3 + 24);
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 24));
  if (*(_DWORD *)(v4 + 100) < a2)
  {
    *(_DWORD *)(v4 + 16) = 1;
    *(_DWORD *)(v4 + 100) = a2;
  }
  pthread_mutex_unlock(v5);
  CheckOutHandleDebug();
  return 0;
}

uint64_t MediaQueue_RecordNewPacketWithSize(uint64_t a1, int a2, int a3, _DWORD *a4, unsigned int *a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  pthread_mutex_t *v13;
  int v14;
  unint64_t v15;

  v9 = CheckInHandleDebug();
  if (!v9)
    return 2149580802;
  v10 = v9;
  if (a3)
    v11 = 224;
  else
    v11 = 212;
  if (a3)
    v12 = 232;
  else
    v12 = 216;
  v13 = (pthread_mutex_t *)(v9 + 248);
  pthread_mutex_lock((pthread_mutex_t *)(v9 + 248));
  if (*(_BYTE *)(v10 + 208))
  {
    v14 = *(_DWORD *)(v10 + v11) + 1;
    *(_DWORD *)(v10 + v11) = v14;
    v15 = *(_QWORD *)(v10 + v12);
    if (a2 <= 0)
      goto LABEL_15;
    goto LABEL_14;
  }
  v14 = *(_DWORD *)(v10 + v11);
  v15 = *(_QWORD *)(v10 + v12);
  if (a2 >= 1)
  {
    *(_DWORD *)(v10 + v11) = ++v14;
LABEL_14:
    v15 += a2;
    *(_QWORD *)(v10 + v12) = v15;
  }
LABEL_15:
  pthread_mutex_unlock(v13);
  if (a4)
    *a4 = (unsigned __int16)v14;
  if (a5)
    *a5 = ((((v15 >> 3) * (unsigned __int128)0x20C49BA5E353F7CFuLL) >> 64) >> 1) & 0xFFF8;
  CheckOutHandleDebug();
  return 0;
}

uint64_t MediaQueue_FindPacketInTxHistory(uint64_t a1, unsigned __int16 a2, int a3, unint64_t a4, int a5, uint64_t a6, uint64_t a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v18;
  uint64_t v19;
  _BOOL4 IsLossStatsEnabled;
  double v21;
  uint64_t v23[2];
  _DWORD v24[4];
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v18 = CheckInHandleDebug();
  if (!v18)
    return 2149580802;
  v19 = v18;
  IsLossStatsEnabled = VCMediaControlInfo_IsLossStatsEnabled(*(unsigned __int8 *)(v18 + 25528));
  if (*(_BYTE *)(v19 + 864))
  {
    v21 = 1.0;
    if (!*(_BYTE *)(v19 + 865))
      v21 = 5.0;
  }
  else
  {
    v21 = 5.0;
  }
  v24[0] = a2;
  v24[1] = a3;
  v24[2] = a8;
  v24[3] = a5;
  v25 = a4 / 0x3E8;
  v26 = a7;
  v27 = a6;
  v28 = a10;
  v29 = a11;
  v30 = a9;
  v23[0] = v19 + 952;
  v23[1] = *(_QWORD *)(v19 + 944);
  VCMediaQueueUtil_FindPacketInTxHistory((unsigned __int16 *)v24, v23, (pthread_mutex_t *)(v19 + 144), IsLossStatsEnabled, v21, 5.0);
  CheckOutHandleDebug();
  return 0;
}

uint64_t MediaQueue_CleanupTxHistory()
{
  uint64_t v0;
  uint64_t v1;
  pthread_mutex_t *v2;

  v0 = CheckInHandleDebug();
  if (!v0)
    return 2149580802;
  v1 = v0;
  v2 = (pthread_mutex_t *)(v0 + 144);
  pthread_mutex_lock((pthread_mutex_t *)(v0 + 144));
  bzero((void *)(v1 + 952), 0x6000uLL);
  *(_QWORD *)(v1 + 944) = 0;
  pthread_mutex_unlock(v2);
  CheckOutHandleDebug();
  return 0;
}

uint64_t MediaQueue_SetPLCalc(uint64_t a1, char a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149580802;
  *(_BYTE *)(v3 + 208) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t MediaQueue_SetActiveProbingLog(uint64_t a1, char a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149580802;
  *(_BYTE *)(v3 + 613) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t MediaQueue_SetAFRCSendMode(uint64_t a1, char a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149580802;
  *(_BYTE *)(v3 + 612) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t MediaQueue_ResetRefreshFrameState()
{
  uint64_t v0;
  uint64_t v1;
  pthread_mutex_t *v2;

  v0 = CheckInHandleDebug();
  if (!v0)
    return 2149580802;
  v1 = v0;
  v2 = (pthread_mutex_t *)(v0 + 24);
  pthread_mutex_lock((pthread_mutex_t *)(v0 + 24));
  *(_DWORD *)(v1 + 104) = 0;
  *(_QWORD *)(v1 + 112) = 0;
  *(_QWORD *)(v1 + 120) = 0;
  pthread_mutex_unlock(v2);
  CheckOutHandleDebug();
  return 0;
}

uint64_t MediaQueue_SetRTPHandle(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149580802;
  *(_QWORD *)(v3 + 936) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t ActiveProbing_ProcessIncomingPacket(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  NSObject *v15;
  NSObject *v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  NSObject *v20;
  NSObject *v21;
  unsigned int v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  NSObject *v29;
  NSObject *v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int v33;
  int v34;
  unsigned int v35;
  unsigned int v36;
  int v37;
  unsigned int v38;
  unsigned int v39;
  unsigned int v40;
  int v41;
  unsigned int v42;
  unsigned int v43;
  int v44;
  unsigned int v45;
  unsigned int v46;
  uint64_t v47;
  NSObject *v48;
  NSObject *v49;
  uint64_t *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  NSObject *v54;
  NSObject *v55;
  unsigned int v56;
  unsigned int v57;
  unsigned int v59;
  unsigned int v60;
  int v61;
  uint64_t v62;
  __int16 v63;
  const char *v64;
  __int16 v65;
  int v66;
  __int16 v67;
  unsigned int v68;
  __int16 v69;
  unsigned int v70;
  __int16 v71;
  unsigned int v72;
  __int16 v73;
  unsigned int v74;
  __int16 v75;
  int v76;
  __int16 v77;
  unsigned int v78;
  __int16 v79;
  unsigned int v80;
  __int16 v81;
  int v82;
  uint64_t v83;

  v83 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 29) && (int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    v6 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        v7 = *(_DWORD *)(a2 + 1516);
        v8 = bswap32(*(_DWORD *)(a2 + 1508));
        v9 = bswap32(*(unsigned __int16 *)(a2 + 1506));
        v10 = *(_DWORD *)a2;
        v61 = 136316674;
        v62 = v4;
        v63 = 2080;
        v64 = "ActiveProbing_ProcessIncomingPacket";
        v65 = 1024;
        v66 = 1469;
        v67 = 1024;
        v68 = v7;
        v69 = 1024;
        v70 = v8;
        v71 = 1024;
        v72 = HIWORD(v9);
        v73 = 1024;
        v74 = v10;
        _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d AddPacket: ^^^^^^\t\t incoming %d %d/%d/%d ", (uint8_t *)&v61, 0x34u);
      }
    }
    else if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      ActiveProbing_ProcessIncomingPacket_cold_3();
    }
  }
  if (!*(_BYTE *)(a1 + 16) && *(_DWORD *)(a2 + 1516) == 1)
  {
    *(_DWORD *)(a1 + 20) = bswap32(*(_DWORD *)(a2 + 1508)) - 1;
    *(_BYTE *)(a1 + 16) = 1;
  }
  if (*(_BYTE *)(a2 + 1576))
  {
    v11 = *(unsigned __int8 *)(a2 + 1578);
    v12 = bswap32(*(_DWORD *)(a2 + 1508));
    v13 = *(_DWORD *)(a1 + 20);
    if (*(_BYTE *)(a1 + 29) && (int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v14 = VRTraceErrorLogLevelToCSTR();
      v15 = *MEMORY[0x1E0CF2758];
      v16 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          v17 = *(_DWORD *)(a2 + 1508);
          v18 = bswap32(*(unsigned __int16 *)(a2 + 1506));
          v61 = 136316674;
          v62 = v14;
          v63 = 2080;
          v64 = "ActiveProbing_ProcessIncomingPacket";
          v65 = 1024;
          v66 = 1526;
          v67 = 1024;
          v68 = bswap32(v17);
          v69 = 1024;
          v70 = HIWORD(v18);
          v71 = 1024;
          v72 = v11;
          v73 = 1024;
          v74 = v12 == v13;
          _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d AddPacket: ^^^^^^\t\t ProbeSeq %d/%d bNewProbeSeq %d bVideoPacketPartOfActiveProbeSeq %d ", (uint8_t *)&v61, 0x34u);
          if (!v11)
          {
LABEL_49:
            if (v12 == v13)
            {
              ActiveProbing_UpdateRTPProbeSeqId(a2, *(_DWORD *)(a1 + 24), *(unsigned __int8 *)(a1 + 29));
              if (*(_BYTE *)(a1 + 29) && (int)VRTraceGetErrorLogLevelForModule() >= 8)
              {
                v47 = VRTraceErrorLogLevelToCSTR();
                v48 = *MEMORY[0x1E0CF2758];
                v49 = *MEMORY[0x1E0CF2758];
                if (*MEMORY[0x1E0CF2748])
                {
                  if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
                  {
                    v61 = 136315650;
                    v62 = v47;
                    v63 = 2080;
                    v64 = "ActiveProbing_ProcessIncomingPacket";
                    v65 = 1024;
                    v66 = 1641;
                    _os_log_impl(&dword_1D8A54000, v48, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d AddPacket: ^^^^^^\t\t MP belonging to an active Probe. Going to the main list", (uint8_t *)&v61, 0x1Cu);
                  }
                }
                else if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
                {
                  ActiveProbing_ProcessIncomingPacket_cold_2(v47);
                }
              }
              return 1;
            }
            goto LABEL_55;
          }
          goto LABEL_42;
        }
      }
      else if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
      {
        v45 = *(_DWORD *)(a2 + 1508);
        v46 = bswap32(*(unsigned __int16 *)(a2 + 1506));
        v61 = 136316674;
        v62 = v14;
        v63 = 2080;
        v64 = "ActiveProbing_ProcessIncomingPacket";
        v65 = 1024;
        v66 = 1526;
        v67 = 1024;
        v68 = bswap32(v45);
        v69 = 1024;
        v70 = HIWORD(v46);
        v71 = 1024;
        v72 = v11;
        v73 = 1024;
        v74 = v12 == v13;
        _os_log_debug_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEBUG, " [%s] %s:%d AddPacket: ^^^^^^\t\t ProbeSeq %d/%d bNewProbeSeq %d bVideoPacketPartOfActiveProbeSeq %d ", (uint8_t *)&v61, 0x34u);
        if (!v11)
          goto LABEL_49;
        goto LABEL_42;
      }
    }
    if (!v11)
      goto LABEL_49;
LABEL_42:
    if (!*(_BYTE *)a1)
      *(_BYTE *)a1 = 1;
    goto LABEL_55;
  }
  if (!*(_BYTE *)a1)
    return 1;
  if (!*(_DWORD *)(a2 + 1516))
  {
    v23 = *(_QWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 24) = bswap32(*(_DWORD *)(a2 + 1508));
    *(_DWORD *)(a1 + 20) = bswap32(*(_DWORD *)(v23 + 1508));
    v24 = 1;
    v25 = v23;
    while (1)
    {
      v26 = v25;
      if (*(_BYTE *)(v25 + 1576))
        ActiveProbing_UpdateRTPProbeSeqId(v25, *(_DWORD *)(a1 + 24), *(unsigned __int8 *)(a1 + 29));
      v25 = *(_QWORD *)(v26 + 1568);
      if (!v25)
        break;
      ++v24;
      if (bswap32(*(_DWORD *)(v25 + 1508)) != *(_DWORD *)(a1 + 20))
      {
        if (*(_BYTE *)(v25 + 1576))
        {
LABEL_31:
          --v24;
          *(_QWORD *)(a1 + 8) = v25;
          goto LABEL_35;
        }
        while (1)
        {
          v26 = v25;
          v25 = *(_QWORD *)(v25 + 1568);
          if (!v25)
            goto LABEL_34;
          ++v24;
          if (*(_BYTE *)(v25 + 1576))
            goto LABEL_31;
        }
      }
    }
LABEL_34:
    *(_QWORD *)(a1 + 8) = 0;
    *(_BYTE *)a1 = 0;
LABEL_35:
    *(_DWORD *)(a1 + 44) -= v24;
    *(_QWORD *)(a2 + 1568) = v23;
    v27 = (v24 + 1);
    *(_QWORD *)(v26 + 1568) = 0;
    *(_BYTE *)(a2 + 1576) = 1;
    if (*(_BYTE *)(a1 + 29) && (int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v28 = VRTraceErrorLogLevelToCSTR();
      v29 = *MEMORY[0x1E0CF2758];
      v30 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
        {
          v31 = *(_DWORD *)(a1 + 24);
          v32 = bswap32(*(_DWORD *)(v23 + 1508));
          v33 = bswap32(*(unsigned __int16 *)(v23 + 1506));
          v34 = *(unsigned __int8 *)(v23 + 1576);
          v35 = bswap32(*(_DWORD *)(v26 + 1508));
          v36 = bswap32(*(unsigned __int16 *)(v26 + 1506));
          v37 = *(unsigned __int8 *)(v26 + 1576);
          v61 = 136317698;
          v62 = v28;
          v63 = 2080;
          v64 = "ActiveProbing_ProcessIncomingPacket";
          v65 = 1024;
          v66 = 1795;
          v67 = 1024;
          v68 = v31;
          v69 = 1024;
          v70 = v27;
          v71 = 1024;
          v72 = v32;
          v73 = 1024;
          v74 = HIWORD(v33);
          v75 = 1024;
          v76 = v34;
          v77 = 1024;
          v78 = v35;
          v79 = 1024;
          v80 = HIWORD(v36);
          v81 = 1024;
          v82 = v37;
          _os_log_impl(&dword_1D8A54000, v29, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d AddPacket: ^^^^^^\t\t Audio %d CAME. KICKING ProbeSeq (%d) from %d/%d/%d to %d/%d/%d ", (uint8_t *)&v61, 0x4Cu);
        }
      }
      else if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
      {
        v38 = *(_DWORD *)(a1 + 24);
        v39 = bswap32(*(_DWORD *)(v23 + 1508));
        v40 = bswap32(*(unsigned __int16 *)(v23 + 1506));
        v41 = *(unsigned __int8 *)(v23 + 1576);
        v42 = bswap32(*(_DWORD *)(v26 + 1508));
        v43 = bswap32(*(unsigned __int16 *)(v26 + 1506));
        v44 = *(unsigned __int8 *)(v26 + 1576);
        v61 = 136317698;
        v62 = v28;
        v63 = 2080;
        v64 = "ActiveProbing_ProcessIncomingPacket";
        v65 = 1024;
        v66 = 1795;
        v67 = 1024;
        v68 = v38;
        v69 = 1024;
        v70 = v27;
        v71 = 1024;
        v72 = v39;
        v73 = 1024;
        v74 = HIWORD(v40);
        v75 = 1024;
        v76 = v41;
        v77 = 1024;
        v78 = v42;
        v79 = 1024;
        v80 = HIWORD(v43);
        v81 = 1024;
        v82 = v44;
        _os_log_debug_impl(&dword_1D8A54000, v29, OS_LOG_TYPE_DEBUG, " [%s] %s:%d AddPacket: ^^^^^^\t\t Audio %d CAME. KICKING ProbeSeq (%d) from %d/%d/%d to %d/%d/%d ", (uint8_t *)&v61, 0x4Cu);
      }
    }
    return v27;
  }
  if (*(_BYTE *)(a1 + 29) && (int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v19 = VRTraceErrorLogLevelToCSTR();
    v20 = *MEMORY[0x1E0CF2758];
    v21 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        v22 = bswap32(*(_DWORD *)(a2 + 1508));
        v61 = 136315906;
        v62 = v19;
        v63 = 2080;
        v64 = "ActiveProbing_ProcessIncomingPacket";
        v65 = 1024;
        v66 = 1809;
        v67 = 1024;
        v68 = v22;
        _os_log_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d AddPacket: ^^^^^^\t\t Regular frame %d is blocked in the waiting list...", (uint8_t *)&v61, 0x22u);
      }
    }
    else if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
    {
      ActiveProbing_ProcessIncomingPacket_cold_1();
    }
  }
LABEL_55:
  v50 = (uint64_t *)(a1 + 8);
  v51 = *(_QWORD *)(a1 + 8);
  if (v51)
  {
    do
    {
      v52 = v51;
      v51 = *(_QWORD *)(v51 + 1568);
    }
    while (v51);
    v50 = (uint64_t *)(v52 + 1568);
  }
  *v50 = a2;
  ++*(_DWORD *)(a1 + 44);
  if (!*(_BYTE *)(a1 + 29) || (int)VRTraceGetErrorLogLevelForModule() < 8)
    return 0;
  v53 = VRTraceErrorLogLevelToCSTR();
  v54 = *MEMORY[0x1E0CF2758];
  v55 = *MEMORY[0x1E0CF2758];
  if (!*MEMORY[0x1E0CF2748])
  {
    if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
    {
      v59 = bswap32(*(_DWORD *)(a2 + 1508));
      v60 = *(unsigned __int8 *)(a2 + 1576);
      v61 = 136316162;
      v62 = v53;
      v63 = 2080;
      v64 = "ActiveProbing_ProcessIncomingPacket";
      v65 = 1024;
      v66 = 1837;
      v67 = 1024;
      v68 = v59;
      v69 = 1024;
      v70 = v60;
      _os_log_debug_impl(&dword_1D8A54000, v54, OS_LOG_TYPE_DEBUG, " [%s] %s:%d AddPacket: ^^^^^^\t\t ProbeSeq/Regular frame %d (%d) waiting for the next Audio", (uint8_t *)&v61, 0x28u);
    }
    return 0;
  }
  v27 = 0;
  if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
  {
    v56 = bswap32(*(_DWORD *)(a2 + 1508));
    v57 = *(unsigned __int8 *)(a2 + 1576);
    v61 = 136316162;
    v62 = v53;
    v63 = 2080;
    v64 = "ActiveProbing_ProcessIncomingPacket";
    v65 = 1024;
    v66 = 1837;
    v67 = 1024;
    v68 = v56;
    v69 = 1024;
    v70 = v57;
    _os_log_impl(&dword_1D8A54000, v54, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d AddPacket: ^^^^^^\t\t ProbeSeq/Regular frame %d (%d) waiting for the next Audio", (uint8_t *)&v61, 0x28u);
    return 0;
  }
  return v27;
}

void ActiveProbing_UpdateRTPProbeSeqId(uint64_t a1, unsigned int a2, int a3)
{
  void *v4;
  uint64_t v7;
  NSObject *v8;
  NSObject *v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  uint8_t buf[4];
  uint64_t v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  unsigned int v22;
  __int16 v23;
  unsigned int v24;
  __int16 v25;
  unsigned int v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v4 = *(void **)(a1 + 1584);
  if (v4)
  {
    v14 = bswap32(a2);
    VCMediaControlInfoSetInfo(v4, (const char *)8, (uint64_t)&v14, 4);
    if (a3)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v7 = VRTraceErrorLogLevelToCSTR();
        v8 = *MEMORY[0x1E0CF2758];
        v9 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            v10 = bswap32(*(_DWORD *)(a1 + 1508));
            v11 = bswap32(*(unsigned __int16 *)(a1 + 1506));
            *(_DWORD *)buf = 136316418;
            v16 = v7;
            v17 = 2080;
            v18 = "ActiveProbing_UpdateRTPProbeSeqId";
            v19 = 1024;
            v20 = 1453;
            v21 = 1024;
            v22 = v10;
            v23 = 1024;
            v24 = HIWORD(v11);
            v25 = 1024;
            v26 = a2;
            _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d ^^^^ SeqId for VMP TS/seq %d/%d to %d", buf, 0x2Eu);
          }
        }
        else if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
        {
          v12 = bswap32(*(_DWORD *)(a1 + 1508));
          v13 = bswap32(*(unsigned __int16 *)(a1 + 1506));
          *(_DWORD *)buf = 136316418;
          v16 = v7;
          v17 = 2080;
          v18 = "ActiveProbing_UpdateRTPProbeSeqId";
          v19 = 1024;
          v20 = 1453;
          v21 = 1024;
          v22 = v12;
          v23 = 1024;
          v24 = HIWORD(v13);
          v25 = 1024;
          v26 = a2;
          _os_log_debug_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEBUG, " [%s] %s:%d ^^^^ SeqId for VMP TS/seq %d/%d to %d", buf, 0x2Eu);
        }
      }
    }
  }
}

uint64_t ActiveProbing_FlushPendingPackets(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  int v11;
  int v12;
  uint64_t v13;
  NSObject *v14;
  int v15;
  uint64_t v16;
  NSObject *v17;
  int v19;
  uint64_t v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  __int16 v33;
  int v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  *a2 = 0;
  v2 = *(_QWORD *)(a1 + 8);
  if (!v2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      v16 = VRTraceErrorLogLevelToCSTR();
      v17 = *MEMORY[0x1E0CF2758];
      v5 = 0;
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        return v5;
      v19 = 136315650;
      v20 = v16;
      v21 = 2080;
      v22 = "ActiveProbing_FlushPendingPackets";
      v23 = 1024;
      v24 = 1904;
      _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d \t\t *** ActiveProbing_FlushPendingPackets: flushed 0 pkts; alraedy empty",
        (uint8_t *)&v19,
        0x1Cu);
    }
    return 0;
  }
  LODWORD(v5) = 0;
  v6 = *(_DWORD *)(a1 + 20);
  v7 = *(_DWORD *)(a1 + 24);
  do
  {
    v8 = v2;
    v5 = (v5 + 1);
    v2 = *(_QWORD *)(v2 + 1568);
  }
  while (v2);
  *(_DWORD *)(a1 + 20) = bswap32(*(_DWORD *)(v8 + 1508));
  *(_DWORD *)(a1 + 24) = v7 - 1;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
  {
    v9 = VRTraceErrorLogLevelToCSTR();
    v10 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v12 = *(_DWORD *)(a1 + 20);
      v11 = *(_DWORD *)(a1 + 24);
      v19 = 136316930;
      v20 = v9;
      v21 = 2080;
      v22 = "ActiveProbing_FlushPendingPackets";
      v23 = 1024;
      v24 = 1888;
      v25 = 1024;
      v26 = v5;
      v27 = 1024;
      v28 = v7;
      v29 = 1024;
      v30 = v11;
      v31 = 1024;
      v32 = v6;
      v33 = 1024;
      v34 = v12;
      _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d \t\t *** ActiveProbing_FlushPendingPackets: flushed %d pkts; ProbeSeqId: %d->%d, VideoFrameTS: %d->%d ",
        (uint8_t *)&v19,
        0x3Au);
    }
  }
  if (*(_DWORD *)(a1 + 44) != (_DWORD)v5 && (int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v13 = VRTraceErrorLogLevelToCSTR();
    v14 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v15 = *(_DWORD *)(a1 + 44);
      v19 = 136316162;
      v20 = v13;
      v21 = 2080;
      v22 = "ActiveProbing_FlushPendingPackets";
      v23 = 1024;
      v24 = 1895;
      v25 = 1024;
      v26 = v5;
      v27 = 1024;
      v28 = v15;
      _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d \t\t *** ActiveProbing_FlushPendingPackets: Unexpected: flushed %d pkts vs. %d queue length ", (uint8_t *)&v19, 0x28u);
    }
  }
  *a2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = 0;
  *(_BYTE *)a1 = 0;
  *(_DWORD *)(a1 + 44) = 0;
  return v5;
}

uint64_t MediaQueue_SetThrottlingAudioInterval(double a1)
{
  uint64_t v2;

  v2 = CheckInHandleDebug();
  if (!v2)
    return 2149580802;
  Throttling_MediaQueue_SetAudioInterval(v2 + 632, a1);
  CheckOutHandleDebug();
  return 0;
}

uint64_t MediaQueue_SetThrottlingIsIPv6(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149580802;
  Throttling_MediaQueue_SetIsIPv6(v3 + 632, a2);
  CheckOutHandleDebug();
  return 0;
}

uint64_t MediaQueue_RetrieveAudioVideoRates(uint64_t a1, double *a2, double *a3, double *a4, double *a5)
{
  uint64_t v9;
  uint64_t v10;
  double v11;
  double v12;
  int v13;
  double v14;
  double v15;
  double v16;
  double v17;
  int v18;
  double v19;
  int v20;
  double v21;
  double v22;
  double v23;
  double v24;
  int v25;

  v9 = CheckInHandleDebug();
  if (!v9)
    return 2149580802;
  v10 = *(_QWORD *)(v9 + 720);
  if (v10)
  {
    v11 = micro();
    pthread_mutex_lock((pthread_mutex_t *)(v10 + 160));
    v12 = *(double *)(v10 + 136);
    v13 = *(_DWORD *)(v10 + 148);
    pthread_mutex_unlock((pthread_mutex_t *)(v10 + 160));
    v14 = v11 - v12;
    v15 = 0.0;
    v16 = 0.0;
    if (v14 <= 0.5)
      v16 = (double)(8 * v13) / (v14 + 0.484375);
    *a2 = v16;
    pthread_mutex_lock((pthread_mutex_t *)(v10 + 384));
    v17 = *(double *)(v10 + 360);
    v18 = *(_DWORD *)(v10 + 372);
    pthread_mutex_unlock((pthread_mutex_t *)(v10 + 384));
    if (v11 - v17 <= 0.5)
      v15 = (double)(8 * v18) / (v11 - v17 + 0.484375);
    *a3 = v15;
    pthread_mutex_lock((pthread_mutex_t *)(v10 + 608));
    v19 = *(double *)(v10 + 584);
    v20 = *(_DWORD *)(v10 + 596);
    pthread_mutex_unlock((pthread_mutex_t *)(v10 + 608));
    v21 = v11 - v19;
    v22 = 0.0;
    v23 = 0.0;
    if (v21 <= 0.5)
      v23 = (double)(8 * v20) / (v21 + 0.484375);
    *a4 = v23;
    pthread_mutex_lock((pthread_mutex_t *)(v10 + 832));
    v24 = *(double *)(v10 + 808);
    v25 = *(_DWORD *)(v10 + 820);
    pthread_mutex_unlock((pthread_mutex_t *)(v10 + 832));
    if (v11 - v24 <= 0.5)
      v22 = (double)(8 * v25) / (v11 - v24 + 0.484375);
    *a5 = v22;
  }
  CheckOutHandleDebug();
  return 0;
}

uint64_t MediaQueue_ThrottlingFlushThrottlingQueue()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  pthread_mutex_t *v3;
  uint64_t *v4;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  unint64_t v15;
  __int128 v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  NSObject *v20;
  int v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  int v25;
  int v26;
  uint64_t v27;
  NSObject *v28;
  int v29;
  int v30;
  uint64_t v31;
  NSObject *v32;
  uint64_t v33;
  NSObject *v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  uint64_t v41;
  uint8_t v42[4];
  uint64_t v43;
  __int16 v44;
  const char *v45;
  __int16 v46;
  int v47;
  __int16 v48;
  int v49;
  __int16 v50;
  unsigned int v51;
  __int16 v52;
  unsigned int v53;
  __int16 v54;
  int v55;
  _BYTE buf[48];
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  uint64_t v86;

  v86 = *MEMORY[0x1E0C80C00];
  v0 = CheckInHandleDebug();
  if (!v0)
    return 2149580802;
  v1 = v0;
  v2 = v0 + 584;
  v3 = (pthread_mutex_t *)(v0 + 392);
  pthread_mutex_lock((pthread_mutex_t *)(v0 + 392));
  v37 = *(_DWORD *)(v1 + 628);
  v38 = *(_DWORD *)(v1 + 624);
  v4 = (uint64_t *)(v1 + 504);
  v36 = *(_DWORD *)(v1 + 664);
  v5 = Throttling_MediaQueue_FlushThrottlingQueue(v2, v1 + 632, (uint64_t *)(v1 + 504));
  v6 = *(_QWORD *)(v1 + 504);
  *(_QWORD *)(v1 + 504) = 0;
  v41 = 0;
  if (v6)
  {
    v7 = 0;
    v8 = 0;
    v9 = &v41;
    do
    {
      v10 = *(_QWORD *)(v6 + 1568);
      *(_QWORD *)(v6 + 1568) = 0;
      if (*(_DWORD *)(v6 + 1516) == 1)
      {
        *v9 = v6;
        ++v8;
        v9 = (uint64_t *)(v6 + 1568);
      }
      else
      {
        *v4 = v6;
        ++v7;
        v4 = (uint64_t *)(v6 + 1568);
      }
      v6 = v10;
    }
    while (v10);
  }
  else
  {
    v8 = 0;
    v7 = 0;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
  {
    v12 = VRTraceErrorLogLevelToCSTR();
    v13 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136316162;
      *(_QWORD *)&buf[4] = v12;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "FlushVideoPktsFromPktList";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 2066;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = v7;
      *(_WORD *)&buf[34] = 1024;
      *(_DWORD *)&buf[36] = v8;
      _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d \t\t *** MediaQueue_FlushVideoPktsFromPktList  iPktsInMainList/iPktsToBeFlushed %d/%d pkts ", buf, 0x28u);
    }
  }
  *(_DWORD *)(v1 + 624) = v7;
  v14 = v41;
  if (v5 >= 1 && !v41 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      MediaQueue_ThrottlingFlushThrottlingQueue_cold_1();
  }
  v35 = *(_DWORD *)(v1 + 624);
  v39 = *(_DWORD *)(v1 + 664);
  v40 = *(_DWORD *)(v1 + 628);
  pthread_mutex_unlock(v3);
  if (v14)
  {
    v15 = 0;
    *(_QWORD *)&v16 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v84 = v16;
    v85 = v16;
    v82 = v16;
    v83 = v16;
    v80 = v16;
    v81 = v16;
    v78 = v16;
    v79 = v16;
    v76 = v16;
    v77 = v16;
    v74 = v16;
    v75 = v16;
    v72 = v16;
    v73 = v16;
    v70 = v16;
    v71 = v16;
    v68 = v16;
    v69 = v16;
    v66 = v16;
    v67 = v16;
    v64 = v16;
    v65 = v16;
    v62 = v16;
    v63 = v16;
    v60 = v16;
    v61 = v16;
    v58 = v16;
    v59 = v16;
    v17 = buf;
    *(_OWORD *)&buf[32] = v16;
    v57 = v16;
    *(_OWORD *)buf = v16;
    *(_OWORD *)&buf[16] = v16;
    do
    {
      v18 = v14;
      v14 = *(_QWORD *)(v14 + 1568);
      if (*(_DWORD *)(v18 + 1516) == 1)
      {
        if (v15 <= 0x63)
          sprintf(v17, "%04X ", bswap32(*(unsigned __int16 *)(v18 + 1506)) >> 16);
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v19 = VRTraceErrorLogLevelToCSTR();
        v20 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v21 = *(_DWORD *)(v18 + 1516);
          v22 = bswap32(*(_DWORD *)(v18 + 1508));
          v23 = bswap32(*(unsigned __int16 *)(v18 + 1506));
          v24 = *(_DWORD *)v18;
          *(_DWORD *)v42 = 136316674;
          v43 = v19;
          v44 = 2080;
          v45 = "RecycleFlushedPkts";
          v46 = 1024;
          v47 = 2095;
          v48 = 1024;
          v49 = v21;
          v50 = 1024;
          v51 = v22;
          v52 = 1024;
          v53 = HIWORD(v23);
          v54 = 1024;
          v55 = v24;
          _os_log_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d \t\t *** MediaQueue_RecycleFlushedPkts: Unexpected: flushing non-video pkt %d %d/%d/%d ", v42, 0x34u);
        }
      }
      MediaQueue_Free(v1, v18);
      ++v15;
      v17 += 5;
    }
    while (v14);
    if ((_DWORD)v15)
      RTPLogMQFlushedPackets(*(_QWORD *)(v1 + 936), v15);
    v26 = v35;
    v25 = v36;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      v27 = VRTraceErrorLogLevelToCSTR();
      v28 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v42 = 136315906;
        v43 = v27;
        v44 = 2080;
        v45 = "RecycleFlushedPkts";
        v46 = 1024;
        v47 = 2118;
        v48 = 1024;
        v49 = v15;
        _os_log_impl(&dword_1D8A54000, v28, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d \t\t *** MediaQueue_RecycleFlushedPkts %d pkts ", v42, 0x22u);
      }
    }
    v30 = v37;
    v29 = v38;
  }
  else
  {
    LODWORD(v15) = 0;
    v30 = v37;
    v29 = v38;
    v26 = v35;
    v25 = v36;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
  {
    v31 = VRTraceErrorLogLevelToCSTR();
    v32 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136317442;
      *(_QWORD *)&buf[4] = v31;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "MediaQueue_ThrottlingFlushThrottlingQueue";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 2016;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = v5;
      *(_WORD *)&buf[34] = 1024;
      *(_DWORD *)&buf[36] = v30;
      *(_WORD *)&buf[40] = 1024;
      *(_DWORD *)&buf[42] = v25;
      *(_WORD *)&buf[46] = 1024;
      LODWORD(v57) = v29;
      WORD2(v57) = 1024;
      *(_DWORD *)((char *)&v57 + 6) = v40;
      WORD5(v57) = 1024;
      HIDWORD(v57) = v39;
      LOWORD(v58) = 1024;
      *(_DWORD *)((char *)&v58 + 2) = v26;
      _os_log_impl(&dword_1D8A54000, v32, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d ***### MediaQueue_SetThrottlingFlushThrottlingQueue: Flushed Ap/Th %d pkts; QLen: %d/%d/%d -> %d/%d/%d ",
        buf,
        0x46u);
    }
  }
  if (v30 + v29 + v25 != v40 + v26 + v39 + (_DWORD)v15 && (int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v33 = VRTraceErrorLogLevelToCSTR();
    v34 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = v33;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "MediaQueue_ThrottlingFlushThrottlingQueue";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 2022;
      _os_log_impl(&dword_1D8A54000, v34, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d *** MediaQueue_SetThrottlingFlushThrottlingQueue: UNEXPECTED QUEUE LENGTHS", buf, 0x1Cu);
    }
  }
  CheckOutHandleDebug();
  return 0;
}

uint64_t dropWaitingPkts(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  int *v10;
  uint64_t v11;

  if (a2)
  {
    v8 = a2;
    v9 = result;
    v10 = (int *)MEMORY[0x1E0CF2740];
    do
    {
      if (*v10 >= 5)
        StallModeTracePrint_(5, (uint64_t)"", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/MediaQueue/MediaQueue.c", 2133, "\t\t\t dropWaitingPkts pMP: %p %d", a6, a7, a8, v8);
      v11 = *(_QWORD *)(v8 + 1568);
      result = MediaQueue_Free(v9, v8);
      v8 = v11;
    }
    while (v11);
  }
  return result;
}

uint64_t drainOldPackets(uint64_t a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;
  int *v12;
  uint64_t v13;
  uint64_t v14;

  v9 = *(_QWORD *)(a1 + 25568);
  if (!v9 || *(double *)(v9 + 1608) >= a2)
    return 0;
  v12 = (int *)MEMORY[0x1E0CF2740];
  if ((int)*MEMORY[0x1E0CF2740] >= 5)
    StallModeTracePrint_(5, (uint64_t)"", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/MediaQueue/MediaQueue.c", 2152, "drainOldPackets: releasing OLD pHead: %d/%d/%d/%d/%f ", a7, a8, a9, *(_DWORD *)(v9 + 1516));
  v13 = *(_QWORD *)(v9 + 1568);
  if (v13 && *(double *)(v13 + 1608) < a2)
  {
    do
    {
      v14 = v13;
      if (*v12 >= 5)
        StallModeTracePrint_(5, (uint64_t)"", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/MediaQueue/MediaQueue.c", 2158, "drainOldPackets: releasing OLD pMP: %d/%d/%d/%d/%f ", a7, a8, a9, *(_DWORD *)(v13 + 1516));
      v13 = *(_QWORD *)(v13 + 1568);
    }
    while (v13 && *(double *)(v13 + 1608) < a2);
  }
  else
  {
    v14 = v9;
  }
  *(_QWORD *)(v14 + 1568) = 0;
  dropWaitingPkts(a1, v9, a4, a5, a6, a7, a8, a9);
  *(_QWORD *)(a1 + 25568) = v13;
  return 1;
}

void pushOutQueuedAudioPkts(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  int *v10;
  int v11;
  uint64_t v12;
  double v13;
  int v14;

  v9 = *(_QWORD *)(a1 + 25568);
  if (a2)
    *(_QWORD *)(a1 + 25568) = 0;
  v10 = (int *)MEMORY[0x1E0CF2740];
  v11 = 0;
  if (v9)
  {
    do
    {
      v12 = *(_QWORD *)(v9 + 1568);
      *(_QWORD *)(v9 + 1568) = 0;
      if (*v10 >= 5)
        StallModeTracePrint_(5, (uint64_t)"", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/MediaQueue/MediaQueue.c", 2189, "pushOutQueuedAudioPkts: AddPacket pMP: %d/%d/%d/%d/%f ", a6, a7, a8, *(_DWORD *)(v9 + 1516));
      v13 = micro();
      v11 += Throttling_MediaQueue_AddPacket_ScheduleAndActiveProbing(a1 + 584, a1 + 632, (uint64_t *)(a1 + 504), v9, v13);
      v9 = v12;
    }
    while (v12);
  }
  if (*v10 >= 5)
    StallModeTracePrint_(5, (uint64_t)"", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/MediaQueue/MediaQueue.c", 2204, "pushOutQueuedAudioPkts iPktsCount: %d ", a6, a7, a8, v11);
  if (v11 >= 1)
  {
    v14 = *(_DWORD *)(a1 + 624) + v11;
    *(_DWORD *)(a1 + 624) = v14;
    _MediaQueue_CheckActiveProbingQueueLength(v14);
    pthread_cond_signal((pthread_cond_t *)(a1 + 456));
  }
}

uint64_t MediaQueue_SetCellularAudioStallState(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149580802;
  SetCellularAudioStallState_Internal(v3, a2, 0, v4, v5, v6, v7, v8);
  CheckOutHandleDebug();
  return 0;
}

uint64_t MediaQueue_BBFlushAcked(uint64_t a1, int a2, uint64_t a3, int a4)
{
  uint64_t v6;
  uint64_t v7;
  pthread_mutex_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int *v14;
  uint64_t v15;
  int v16;

  v6 = CheckInHandleDebug();
  if (!v6)
    return 2149580802;
  v7 = v6 + 25553;
  v9 = (pthread_mutex_t *)(v6 + 392);
  pthread_mutex_lock((pthread_mutex_t *)(v6 + 392));
  v13 = *(unsigned __int16 *)(v7 + 43);
  v14 = (int *)MEMORY[0x1E0CF2740];
  if ((int)*MEMORY[0x1E0CF2740] >= 5)
    StallModeTracePrint_(5, (uint64_t)"", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/MediaQueue/MediaQueue.c", 2468, "AFRCUpdateBBNote calling MediaQueue_BBFlushAcked: flushed pkts: %d/%d bPendingCellularFlush: %d/%p  Trans: %d/%d/%d ", v10, v11, v12, a2);
  if (v13 == a4)
  {
    if (*v14 >= 5)
    {
      StallModeTracePrint_(5, (uint64_t)"", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/MediaQueue/MediaQueue.c", 2474, "MediaQueue_BBFlushAcked: wNumDropped: %d", v10, v11, v12, a2);
      if (a2)
      {
LABEL_9:
        v15 = 0;
        v16 = *v14;
        do
        {
          if (v16 >= 5)
          {
            StallModeTracePrint_(5, (uint64_t)"", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/MediaQueue/MediaQueue.c", 2476, "\t\t\t %d: %d  ", v10, v11, v12, v15);
            v16 = *v14;
          }
          ++v15;
        }
        while (a2 != v15);
      }
    }
    else if (a2)
    {
      goto LABEL_9;
    }
    *(_BYTE *)v7 = 0;
  }
  pthread_mutex_unlock(v9);
  CheckOutHandleDebug();
  return 0;
}

uint64_t MediaQueue_SetFECFeedbackVersion(uint64_t a1, char a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149580802;
  *(_BYTE *)(v3 + 25528) = a2;
  CheckOutHandleDebug();
  return 0;
}

void MediaQueue_SendPacket(uint64_t a1, int *a2)
{
  int v4;
  double v5;
  int v6;
  double v7;
  double v8;
  double v9;
  int v10;
  double v11;
  double v12;
  int v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  int v18;
  int *v19;
  double v20;
  void *v21;
  uint64_t v22;
  NSObject *v23;
  int v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  char v32;
  __int128 v33;
  __int128 v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  int v50;
  unsigned int v51;
  char v52;
  unsigned int v53;
  int v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  void *v58;
  uint64_t v59;
  unsigned int v60;
  int v61;
  int v62;
  uint64_t v63;
  unsigned int v64;
  unsigned int v65;
  uint64_t v66;
  int v67;
  pthread_mutex_t *v68;
  pthread_mutex_t *v69;
  __int128 *v70;
  int *v71;
  int v72;
  uint64_t v73;
  _BYTE *v74;
  unsigned int v75;
  __int16 v76;
  uint8_t buf[48];
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  uint64_t v95;

  v95 = *MEMORY[0x1E0C80C00];
  v4 = a2[379];
  if (v4 == 1)
  {
    if (*(_DWORD *)(a1 + 880))
    {
      v9 = *(double *)(a1 + 888);
      v10 = (int)v9;
      v11 = v9 - (double)(int)v9;
      if (v11 > 0.0)
      {
        v12 = v11 + *(double *)(a1 + 928);
        *(double *)(a1 + 928) = v12;
        if (v12 >= 1.0)
        {
          ++v10;
          *(double *)(a1 + 928) = v12 + -1.0;
        }
      }
    }
    else
    {
      v10 = 1;
    }
    if (a2[387] <= v10)
      v13 = v10;
    else
      v13 = a2[387];
    if (*(_BYTE *)(a1 + 208))
      v16 = v13;
    else
      v16 = 1;
    *(_DWORD *)(a1 + 132) += v16;
    v15 = 700;
  }
  else
  {
    if (v4)
    {
      v75 = 0;
      if (a2[387] <= 1)
        v13 = 1;
      else
        v13 = a2[387];
      goto LABEL_31;
    }
    if (*(_BYTE *)(a1 + 864))
    {
      v5 = *(double *)(a1 + 872);
      v6 = (int)v5;
      v7 = v5 - (double)(int)v5;
      if (v7 > 0.0)
      {
        v8 = v7 + *(double *)(a1 + 920);
        *(double *)(a1 + 920) = v8;
        if (v8 >= 1.0)
        {
          ++v6;
          *(double *)(a1 + 920) = v8 + -1.0;
        }
      }
    }
    else
    {
      v6 = 1;
    }
    if (a2[387] <= v6)
      v13 = v6;
    else
      v13 = a2[387];
    if (*(_BYTE *)(a1 + 208))
      v14 = v13;
    else
      v14 = 1;
    *(_DWORD *)(a1 + 128) += v14;
    v15 = 800;
  }
  v75 = v15;
LABEL_31:
  if (*((_BYTE *)a2 + 1528))
    v17 = 48;
  else
    v17 = 28;
  *(_QWORD *)(a1 + 136) += *a2 + v17;
  if (v13 >= 1)
  {
    v18 = 0;
    v66 = a1 + 952;
    v68 = (pthread_mutex_t *)(a1 + 144);
    v69 = (pthread_mutex_t *)(a1 + 24);
    v19 = a2 + 1;
    v70 = (__int128 *)(a2 + 406);
    v74 = (_BYTE *)(a1 + 25552);
    v72 = v13;
    v71 = a2 + 1;
    while (1)
    {
      v20 = micro();
      v76 = -21846;
      v21 = (void *)*((_QWORD *)a2 + 198);
      if (v21)
      {
        if (VCMediaControlInfoHasInfo(v21, 0))
        {
          if ((RTPSetAFRCProcessingDelay(*(_QWORD *)(a1 + 936), &v76, *((void **)a2 + 198), *((double *)a2 + 194), v20) & 0x80000000) != 0)
            goto LABEL_89;
          if (*(_DWORD *)(a1 + 16))
          {
            *(_DWORD *)(a1 + 16) = 0;
            pthread_mutex_lock(v69);
            *(double *)(a1 + 88) = v20;
            *(_DWORD *)(a1 + 96) = *(_DWORD *)(a1 + 100);
            pthread_mutex_unlock(v69);
          }
          if (*(_DWORD *)(a1 + 104))
          {
            *(_DWORD *)(a1 + 104) = 0;
            pthread_mutex_lock(v69);
            *(double *)(a1 + 112) = v20;
            *(_DWORD *)(a1 + 120) = *(_DWORD *)(a1 + 124);
            pthread_mutex_unlock(v69);
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v22 = VRTraceErrorLogLevelToCSTR();
              v23 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                v24 = *(_DWORD *)(a1 + 120);
                v25 = *(_QWORD *)(a1 + 112);
                *(_DWORD *)buf = 136316162;
                *(_QWORD *)&buf[4] = v22;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "MediaQueue_SendPacket";
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&buf[24] = 274;
                *(_WORD *)&buf[28] = 1024;
                *(_DWORD *)&buf[30] = v24;
                *(_WORD *)&buf[34] = 2048;
                *(_QWORD *)&buf[36] = v25;
                _os_log_impl(&dword_1D8A54000, v23, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Refresh frame counter[%d], time[%.4f].", buf, 0x2Cu);
              }
            }
          }
          if (!v18)
          {
            v26 = *(_DWORD *)(a1 + 944);
            pthread_mutex_lock(v68);
            v27 = v66 + 48 * v26;
            *(_WORD *)(v27 + 2) = v76;
            *(double *)(v27 + 40) = v20;
            *(_QWORD *)(v27 + 4) = *(_QWORD *)(a1 + 128);
            v28 = *(_QWORD *)(a1 + 136);
            *(_WORD *)v27 = 0;
            *(_DWORD *)(v27 + 12) = 0;
            *(_DWORD *)(v27 + 16) = 0;
            *(_QWORD *)(v27 + 24) = v28;
            *(_QWORD *)(v27 + 32) = 0;
            *(_DWORD *)(a1 + 944) = ((_WORD)v26 + 1) & 0x1FF;
            v29 = *(_DWORD *)(a1 + 948);
            if (v29 <= 511)
              *(_DWORD *)(a1 + 948) = v29 + 1;
            pthread_mutex_unlock(v68);
          }
        }
        v30 = *((_QWORD *)a2 + 198);
        if (v30)
        {
          *(_QWORD *)buf = 0xAAAAAAAAAAAAAAAALL;
          if ((VCMediaControlInfoSerialize(v30) & 0x80000000) != 0)
            break;
        }
      }
      v93 = 0u;
      v94 = 0u;
      v91 = 0u;
      v92 = 0u;
      v89 = 0u;
      v90 = 0u;
      v87 = 0u;
      v88 = 0u;
      v85 = 0u;
      v86 = 0u;
      v83 = 0u;
      v84 = 0u;
      v81 = 0u;
      v82 = 0u;
      v79 = 0u;
      v80 = 0u;
      memset(buf, 0, sizeof(buf));
      *(_DWORD *)&buf[8] = a2[380];
      v31 = bswap32(*((unsigned __int16 *)a2 + 753)) >> 16;
      v78 = 0u;
      VTP_SetPktTag((uint64_t)buf, 0, v31);
      VTP_SetPktTag((uint64_t)buf, 1u, bswap32(a2[378]));
      VTP_SetPktTag((uint64_t)buf, 2u, bswap32(a2[377]));
      v32 = *((_BYTE *)a2 + 1621);
      if (v32)
      {
        v33 = v70[3];
        v88 = v70[2];
        v89 = v33;
        v90 = v70[4];
        v34 = v70[1];
        v86 = *v70;
        v87 = v34;
        BYTE8(v85) = v32;
      }
      if (a2[379])
        v35 = 32;
      else
        v35 = 16;
      DWORD1(v85) = v35;
      VTP_Send(a2[381], v19, *a2, v75, (uint64_t)buf);
      v36 = kdebug_trace();
      *(double *)(a1 + 25536) = v20;
      if (!a2[379])
      {
        LogProfileTimeOverLimitCompare(*(double *)(a1 + 25544), v20, v36, v37, v38, v39, v40, v41, v42, v43, *(_QWORD *)(a1 + 25544));
        *(double *)(a1 + 25544) = v20;
      }
      v44 = *(_QWORD *)(a1 + 720);
      if (v44)
      {
        v45 = *(_DWORD *)(a1 + 684);
        v46 = *a2;
        v47 = 448;
        if (a2[379])
        {
          v47 = 672;
          v48 = v44 + 672;
        }
        else
        {
          v48 = v44 + 448;
        }
        v49 = *(_DWORD *)(v48 + 148);
        v50 = vcvtd_n_s64_f64(v20 - *(double *)(v48 + 136), 6uLL);
        v73 = v47;
        if (v50)
        {
          if (v50 > 15)
          {
            if (v50 > 0x1F)
            {
              v49 = 0;
              v53 = 0;
              *(_OWORD *)(v48 + 120) = 0u;
              *(_OWORD *)(v48 + 104) = 0u;
              *(_OWORD *)(v48 + 88) = 0u;
              *(_OWORD *)(v48 + 72) = 0u;
              *(_OWORD *)(v48 + 56) = 0u;
              *(_OWORD *)(v48 + 40) = 0u;
              *(_OWORD *)(v48 + 24) = 0u;
              *(_OWORD *)(v48 + 8) = 0u;
            }
            else
            {
              v56 = *(unsigned __int16 *)(v48 + 144);
              v67 = v56 + v50;
              v53 = (v56 + v50) & 0x1F;
              v57 = ((_BYTE)v56 + 1) & 0x1F;
              if (v53 >= v57)
              {
                v58 = (void *)(v48 + 4 * v57 + 8);
                v59 = (int)(v53 - v57 + 1);
              }
              else
              {
                bzero((void *)(v48 + 8 + 4 * (((_BYTE)v56 + 1) & 0x1F)), 128 - 4 * (((_BYTE)v56 + 1) & 0x1Fu));
                v58 = (void *)(v48 + 8);
                v59 = v53 + 1;
              }
              bzero(v58, 4 * v59);
              v60 = (v67 + 1) & 0x1F;
              if (v60 == (_DWORD)v57)
              {
                v49 = 0;
              }
              else
              {
                v49 = 0;
                do
                {
                  v49 += *(_DWORD *)(v48 + 4 * v60 + 8);
                  v60 = ((_BYTE)v60 + 1) & 0x1F;
                }
                while (v60 != (_DWORD)v57);
              }
            }
          }
          else
          {
            LOWORD(v51) = *(_WORD *)(v48 + 144);
            v52 = v51 + v50;
            v53 = v52 & 0x1F;
            v54 = (v52 + 1) & 0x1F;
            while (1)
            {
              v51 = ((_BYTE)v51 + 1) & 0x1F;
              if (v51 == v54)
                break;
              v55 = v48 + 4 * v51;
              v49 -= *(_DWORD *)(v55 + 8);
              *(_DWORD *)(v55 + 8) = 0;
            }
          }
        }
        else
        {
          v53 = -1;
        }
        v61 = v46 + v45;
        v62 = v49 + v46 + v45;
        pthread_mutex_lock((pthread_mutex_t *)(v48 + 160));
        *(_DWORD *)(v48 + 148) = v62;
        if (v53 != -1)
        {
          *(double *)(v48 + 136) = *(double *)(v44 + v73)
                                 + (double)vcvtd_n_u64_f64(v20 - *(double *)(v44 + v73), 6uLL) * 0.015625;
          *(_WORD *)(v48 + 144) = v53;
        }
        pthread_mutex_unlock((pthread_mutex_t *)(v48 + 160));
        v63 = v48 + 4 * *(__int16 *)(v48 + 144);
        *(_DWORD *)(v63 + 8) += v61;
        v13 = v72;
        v19 = v71;
      }
      if (*v74 && !a2[379] && (int)*MEMORY[0x1E0CF2740] >= 5)
        StallModeTracePrint_(5, (uint64_t)"", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/MediaQueue/MediaQueue.c", 347, "\t\t\t\t\t\t\t\t\t\t\t Sending: %d/%d ", v41, v42, v43, bswap32(a2[377]));
      if (++v18 == v13)
        goto LABEL_89;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        MediaQueue_SendPacket_cold_1();
    }
  }
LABEL_89:
  v64 = a2[390];
  if (v64 > *(_DWORD *)(a1 + 100))
  {
    *(_DWORD *)(a1 + 16) = 1;
    *(_DWORD *)(a1 + 100) = v64;
  }
  v65 = a2[391];
  if (v65 > *(_DWORD *)(a1 + 124))
  {
    *(_DWORD *)(a1 + 104) = 1;
    *(_DWORD *)(a1 + 124) = v65;
  }
}

void LogProfileTimeOverLimitCompare(double a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  double v13;
  __int128 v14;
  uint64_t v15;
  NSObject *v16;
  uint8_t buf[4];
  uint64_t v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  char *v24;
  __int16 v25;
  double v26;
  char __str[16];
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  if (VRTraceIsInternalOSInstalled())
  {
    v13 = a2 - a1;
    if (v13 > 0.100000001)
    {
      *(_QWORD *)&v14 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v41 = v14;
      v42 = v14;
      v39 = v14;
      v40 = v14;
      v37 = v14;
      v38 = v14;
      v35 = v14;
      v36 = v14;
      v33 = v14;
      v34 = v14;
      v32 = v14;
      v30 = v14;
      v31 = v14;
      v28 = v14;
      v29 = v14;
      *(_OWORD *)__str = v14;
      vsnprintf(__str, 0x100uLL, "MediaQueue - Last sent audio delayed. lastSentAudioPacketTime=%f currentTime=%f delta=%f", &a11);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v15 = VRTraceErrorLogLevelToCSTR();
        v16 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316162;
          v18 = v15;
          v19 = 2080;
          v20 = "_LogProfileTimeLimitHelper";
          v21 = 1024;
          v22 = 36;
          v23 = 2080;
          v24 = __str;
          v25 = 2048;
          v26 = v13;
          _os_log_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d %s: Took a long time %fs", buf, 0x30u);
        }
      }
    }
  }
}

void OUTLINED_FUNCTION_3_2(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x28u);
}

void OUTLINED_FUNCTION_4_4(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0x28u);
}

uint64_t _VCSFrameCryptorH264_FindAndExtractSPSPPSFromEncodedBuffer(uint64_t a1, unint64_t a2, char *a3, size_t *a4)
{
  uint64_t v4;
  void *v6;
  unint64_t v7;
  const void *v8;
  uint64_t v9;
  size_t v10;
  unint64_t v11;
  int FrameSliceHeader;
  uint64_t v13;
  NSObject *v14;
  NSObject *v15;
  uint64_t v16;
  NSObject *v17;
  NSObject *v18;
  NSObject *v19;
  const char *v20;
  uint64_t v21;
  NSObject *v22;
  NSObject *v23;
  uint64_t v24;
  NSObject *v25;
  NSObject *v26;
  uint64_t v27;
  NSObject *v28;
  NSObject *v29;
  NSObject *v30;
  const char *v31;
  void *v32;
  void *v33;
  size_t v34;
  uint64_t v36;
  NSObject *v37;
  const char *v38;
  NSObject *v39;
  uint32_t v40;
  uint64_t v41;
  NSObject *v42;
  uint64_t v43;
  NSObject *v44;
  size_t v45;
  size_t v48;
  size_t v49;
  unsigned int v51;
  void *__src;
  CFTypeRef cf;
  uint8_t buf[4];
  uint64_t v55;
  __int16 v56;
  const char *v57;
  __int16 v58;
  int v59;
  __int16 v60;
  _BYTE v61[34];
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  v4 = 2151809055;
  cf = 0;
  if (!a2)
    return v4;
  v48 = 0;
  v49 = 0;
  v6 = 0;
  __src = 0;
  v7 = 0;
  while (1)
  {
    v8 = (const void *)(a1 + v7);
    v9 = bswap32(*(_DWORD *)(a1 + v7));
    v10 = v9 + 4;
    v11 = v9 + 4 + v7;
    if (v11 > a2)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 3)
        goto LABEL_63;
      v36 = VRTraceErrorLogLevelToCSTR();
      v37 = *MEMORY[0x1E0CF2758];
      v4 = 2151809055;
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        goto LABEL_64;
      *(_DWORD *)buf = 136316418;
      v55 = v36;
      v56 = 2080;
      v57 = "_VCSFrameCryptorH264_FindAndExtractSPSPPSFromEncodedBuffer";
      v58 = 1024;
      v59 = 107;
      v60 = 2048;
      *(_QWORD *)v61 = v10;
      *(_WORD *)&v61[8] = 2048;
      *(_QWORD *)&v61[10] = v7;
      *(_WORD *)&v61[18] = 2048;
      *(_QWORD *)&v61[20] = a2;
      v38 = " [%s] %s:%d _VCSFrameCryptorH264_FindAndExtractSPSPPSFromEncodedBuffer: Failed to parse, next nalu offset in"
            "valid:%zu offset:%zu total length:%zu";
      v39 = v37;
      v40 = 58;
      goto LABEL_77;
    }
    if (v7 + 4 > a2)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 3)
        goto LABEL_63;
      v41 = VRTraceErrorLogLevelToCSTR();
      v42 = *MEMORY[0x1E0CF2758];
      v4 = 2151809055;
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
LABEL_64:
        if (!v6)
          goto LABEL_66;
        goto LABEL_65;
      }
      *(_DWORD *)buf = 136316162;
      v55 = v41;
      v56 = 2080;
      v57 = "_VCSFrameCryptorH264_FindAndExtractSPSPPSFromEncodedBuffer";
      v58 = 1024;
      v59 = 111;
      v60 = 2048;
      *(_QWORD *)v61 = v7 + 4;
      *(_WORD *)&v61[8] = 2048;
      *(_QWORD *)&v61[10] = a2;
      v38 = " [%s] %s:%d _VCSFrameCryptorH264_FindAndExtractSPSPPSFromEncodedBuffer: Failed to parse nalu header, offset "
            "invalid:%zu total length:%zu";
      v39 = v42;
      v40 = 48;
LABEL_77:
      _os_log_error_impl(&dword_1D8A54000, v39, OS_LOG_TYPE_ERROR, v38, buf, v40);
      goto LABEL_64;
    }
    FrameSliceHeader = ReadFrameSliceHeader(123, (uint64_t)v8 + 4, v9, (CFDictionaryRef *)&cf);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v13 = VRTraceErrorLogLevelToCSTR();
      v14 = *MEMORY[0x1E0CF2758];
      v15 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316674;
          v55 = v13;
          v56 = 2080;
          v57 = "_VCSFrameCryptorH264_FindAndExtractSPSPPSFromEncodedBuffer";
          v58 = 1024;
          v59 = 118;
          v60 = 1024;
          *(_DWORD *)v61 = FrameSliceHeader;
          *(_WORD *)&v61[4] = 2048;
          *(_QWORD *)&v61[6] = v7;
          *(_WORD *)&v61[14] = 2048;
          *(_QWORD *)&v61[16] = v9 + 4;
          *(_WORD *)&v61[24] = 2048;
          *(_QWORD *)&v61[26] = v9;
          _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Frame type %d offset %zu nextNaluOffset %zu dataPointerLength %zu", buf, 0x40u);
        }
      }
      else if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136316674;
        v55 = v13;
        v56 = 2080;
        v57 = "_VCSFrameCryptorH264_FindAndExtractSPSPPSFromEncodedBuffer";
        v58 = 1024;
        v59 = 118;
        v60 = 1024;
        *(_DWORD *)v61 = FrameSliceHeader;
        *(_WORD *)&v61[4] = 2048;
        *(_QWORD *)&v61[6] = v7;
        *(_WORD *)&v61[14] = 2048;
        *(_QWORD *)&v61[16] = v9 + 4;
        *(_WORD *)&v61[24] = 2048;
        *(_QWORD *)&v61[26] = v9;
        _os_log_debug_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Frame type %d offset %zu nextNaluOffset %zu dataPointerLength %zu", buf, 0x40u);
      }
    }
    if (FrameSliceHeader == 4)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v21 = VRTraceErrorLogLevelToCSTR();
        v22 = *MEMORY[0x1E0CF2758];
        v23 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315906;
            v55 = v21;
            v56 = 2080;
            v57 = "_VCSFrameCryptorH264_FindAndExtractSPSPPSFromEncodedBuffer";
            v58 = 1024;
            v59 = 137;
            v60 = 1024;
            *(_DWORD *)v61 = 4;
            _os_log_impl(&dword_1D8A54000, v22, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d PPS NALU found: %d", buf, 0x22u);
          }
        }
        else if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136315906;
          v55 = v21;
          v56 = 2080;
          v57 = "_VCSFrameCryptorH264_FindAndExtractSPSPPSFromEncodedBuffer";
          v58 = 1024;
          v59 = 137;
          v60 = 1024;
          *(_DWORD *)v61 = 4;
          _os_log_debug_impl(&dword_1D8A54000, v22, OS_LOG_TYPE_DEBUG, " [%s] %s:%d PPS NALU found: %d", buf, 0x22u);
        }
      }
      if (__src)
        free(__src);
      v32 = malloc_type_malloc(v10, 0x100004077774924uLL);
      if (!v32)
      {
        v4 = 2151809027;
        if ((int)VRTraceGetErrorLogLevelForModule() < 3)
        {
          __src = 0;
        }
        else
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VCSFrameCryptorH264_FindAndExtractSPSPPSFromEncodedBuffer_cold_2();
          __src = 0;
          v4 = 2151809027;
        }
        goto LABEL_64;
      }
      __src = v32;
      memcpy(v32, v8, v10);
      if (v6)
      {
        v49 = v10;
LABEL_57:
        if (v6)
        {
LABEL_58:
          if (__src)
          {
            v34 = v49 + v48;
            if (*a4 < v49 + v48)
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3
                && (v43 = VRTraceErrorLogLevelToCSTR(),
                    v44 = *MEMORY[0x1E0CF2758],
                    os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR)))
              {
                v45 = *a4;
                *(_DWORD *)buf = 136316162;
                v55 = v43;
                v56 = 2080;
                v57 = "_VCSFrameCryptorH264_FindAndExtractSPSPPSFromEncodedBuffer";
                v58 = 1024;
                v59 = 156;
                v60 = 2048;
                *(_QWORD *)v61 = v45;
                *(_WORD *)&v61[8] = 2048;
                *(_QWORD *)&v61[10] = v49 + v48;
                _os_log_error_impl(&dword_1D8A54000, v44, OS_LOG_TYPE_ERROR, " [%s] %s:%d Output SPSPPS buffer size:%zu is less than the SPSPPS size:%zu", buf, 0x30u);
                v34 = 0;
                v51 = -2143158209;
              }
              else
              {
                v34 = 0;
                v51 = -2143158209;
              }
            }
            else
            {
              memcpy(a3, v6, v48);
              memcpy(&a3[v48], __src, v49);
              v51 = 0;
            }
            *a4 = v34;
            v4 = v51;
LABEL_65:
            free(v6);
            goto LABEL_66;
          }
        }
LABEL_63:
        v4 = 2151809055;
        goto LABEL_64;
      }
      v49 = v10;
      goto LABEL_47;
    }
    if (FrameSliceHeader == 3)
      break;
    if (FrameSliceHeader == 1)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v16 = VRTraceErrorLogLevelToCSTR();
        v17 = *MEMORY[0x1E0CF2758];
        v18 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315906;
            v55 = v16;
            v56 = 2080;
            v57 = "_VCSFrameCryptorH264_FindAndExtractSPSPPSFromEncodedBuffer";
            v58 = 1024;
            v59 = 121;
            v60 = 1024;
            *(_DWORD *)v61 = 1;
            v19 = v17;
            v20 = " [%s] %s:%d Slice NALU: %d, ignoring";
LABEL_31:
            _os_log_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_DEFAULT, v20, buf, 0x22u);
          }
        }
        else if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136315906;
          v55 = v16;
          v56 = 2080;
          v57 = "_VCSFrameCryptorH264_FindAndExtractSPSPPSFromEncodedBuffer";
          v58 = 1024;
          v59 = 121;
          v60 = 1024;
          *(_DWORD *)v61 = 1;
          v30 = v17;
          v31 = " [%s] %s:%d Slice NALU: %d, ignoring";
LABEL_53:
          _os_log_debug_impl(&dword_1D8A54000, v30, OS_LOG_TYPE_DEBUG, v31, buf, 0x22u);
        }
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v27 = VRTraceErrorLogLevelToCSTR();
      v28 = *MEMORY[0x1E0CF2758];
      v29 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315906;
          v55 = v27;
          v56 = 2080;
          v57 = "_VCSFrameCryptorH264_FindAndExtractSPSPPSFromEncodedBuffer";
          v58 = 1024;
          v59 = 151;
          v60 = 1024;
          *(_DWORD *)v61 = FrameSliceHeader;
          v19 = v28;
          v20 = " [%s] %s:%d Unknown NALU Type: %d, ignoring";
          goto LABEL_31;
        }
      }
      else if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136315906;
        v55 = v27;
        v56 = 2080;
        v57 = "_VCSFrameCryptorH264_FindAndExtractSPSPPSFromEncodedBuffer";
        v58 = 1024;
        v59 = 151;
        v60 = 1024;
        *(_DWORD *)v61 = FrameSliceHeader;
        v30 = v28;
        v31 = " [%s] %s:%d Unknown NALU Type: %d, ignoring";
        goto LABEL_53;
      }
    }
LABEL_47:
    if (cf)
      CFRelease(cf);
    v7 = v11;
    if (v11 >= a2)
      goto LABEL_57;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() < 8)
    goto LABEL_42;
  v24 = VRTraceErrorLogLevelToCSTR();
  v25 = *MEMORY[0x1E0CF2758];
  v26 = *MEMORY[0x1E0CF2758];
  if (*MEMORY[0x1E0CF2748])
  {
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      v55 = v24;
      v56 = 2080;
      v57 = "_VCSFrameCryptorH264_FindAndExtractSPSPPSFromEncodedBuffer";
      v58 = 1024;
      v59 = 123;
      v60 = 1024;
      *(_DWORD *)v61 = 3;
      _os_log_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d SPS NALU found: %d", buf, 0x22u);
      if (!v6)
        goto LABEL_44;
LABEL_43:
      free(v6);
      goto LABEL_44;
    }
LABEL_42:
    if (!v6)
      goto LABEL_44;
    goto LABEL_43;
  }
  if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
    goto LABEL_42;
  *(_DWORD *)buf = 136315906;
  v55 = v24;
  v56 = 2080;
  v57 = "_VCSFrameCryptorH264_FindAndExtractSPSPPSFromEncodedBuffer";
  v58 = 1024;
  v59 = 123;
  v60 = 1024;
  *(_DWORD *)v61 = 3;
  _os_log_debug_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_DEBUG, " [%s] %s:%d SPS NALU found: %d", buf, 0x22u);
  if (v6)
    goto LABEL_43;
LABEL_44:
  v33 = malloc_type_malloc(v10, 0x100004077774924uLL);
  if (v33)
  {
    v6 = v33;
    memcpy(v33, v8, v10);
    if (__src)
    {
      v48 = v10;
      goto LABEL_58;
    }
    __src = 0;
    v48 = v10;
    goto LABEL_47;
  }
  v4 = 2151809027;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCSFrameCryptorH264_FindAndExtractSPSPPSFromEncodedBuffer_cold_1();
  }
LABEL_66:
  if (__src)
    free(__src);
  if (cf)
    CFRelease(cf);
  return v4;
}

uint64_t _VCSFrameCryptorH264_CreateAndGetBlockBufferPtr(uint64_t a1, CMBlockBufferRef *blockBufferOut, size_t dataLength, char **a4)
{
  uint64_t v6;
  uint64_t DataPointer;

  v6 = CMBlockBufferCreateWithMemoryBlock(*(CFAllocatorRef *)(a1 + 8), 0, dataLength, *(CFAllocatorRef *)(a1 + 16), 0, 0, dataLength, 1u, blockBufferOut);
  if ((_DWORD)v6)
  {
    DataPointer = v6;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCSFrameCryptorH264_CreateAndGetBlockBufferPtr_cold_2();
    }
  }
  else
  {
    DataPointer = CMBlockBufferGetDataPointer(*blockBufferOut, 0, 0, 0, a4);
    if ((_DWORD)DataPointer)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCSFrameCryptorH264_CreateAndGetBlockBufferPtr_cold_1();
      }
    }
  }
  return DataPointer;
}

uint64_t _VCSFrameCryptorH264_ExtractSFramePayloadFromSlice(uint64_t a1, unsigned int *a2, CMBlockBufferRef sourceBuffer, CMBlockBufferRef *blockBufferOut, _QWORD *a5, uint64_t a6, uint64_t a7)
{
  unsigned int v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  int v20;
  uint64_t v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  _BYTE v27[10];
  uint64_t v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v8 = bswap32(*a2);
  v9 = HIBYTE(v8) & 0x1F;
  v10 = BYTE2(v8);
  if (v9 == 5 && BYTE2(v8) == 184 || v9 == 1 && BYTE2(v8) == 224)
  {
    v11 = a6 + 6;
    v12 = a7 - 6;
    if (a7 != 6)
    {
      if (CMBlockBufferCreateContiguous(*(CFAllocatorRef *)(a1 + 8), sourceBuffer, *(CFAllocatorRef *)(a1 + 16), 0, a6 + 6, a7 - 6, 0, blockBufferOut))
      {
        v16 = 2151809027;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VCSFrameCryptorH264_ExtractSFramePayloadFromSlice_cold_1();
        }
        return v16;
      }
      *a5 = v12;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() < 8)
      return 0;
    v13 = VRTraceErrorLogLevelToCSTR();
    v14 = *MEMORY[0x1E0CF2758];
    v15 = *MEMORY[0x1E0CF2758];
    if (!*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        v20 = 136316162;
        v21 = v13;
        v22 = 2080;
        v23 = "_VCSFrameCryptorH264_ExtractSFramePayloadFromSlice";
        v24 = 1024;
        v25 = 209;
        v26 = 2048;
        *(_QWORD *)v27 = v11;
        *(_WORD *)&v27[8] = 2048;
        v28 = v12;
        _os_log_debug_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEBUG, " [%s] %s:%d _VideoReceiver_FindAndCopySliceNalu: Found SFrame slice offset %zu length %zu", (uint8_t *)&v20, 0x30u);
      }
      return 0;
    }
    v16 = 0;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      v20 = 136316162;
      v21 = v13;
      v22 = 2080;
      v23 = "_VCSFrameCryptorH264_ExtractSFramePayloadFromSlice";
      v24 = 1024;
      v25 = 209;
      v26 = 2048;
      *(_QWORD *)v27 = v11;
      *(_WORD *)&v27[8] = 2048;
      v28 = v12;
      _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d _VideoReceiver_FindAndCopySliceNalu: Found SFrame slice offset %zu length %zu", (uint8_t *)&v20, 0x30u);
      return 0;
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() < 3)
  {
    return 2151809055;
  }
  else
  {
    v17 = VRTraceErrorLogLevelToCSTR();
    v18 = *MEMORY[0x1E0CF2758];
    v16 = 2151809055;
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      v20 = 136316162;
      v21 = v17;
      v22 = 2080;
      v23 = "_VCSFrameCryptorH264_ExtractSFramePayloadFromSlice";
      v24 = 1024;
      v25 = 211;
      v26 = 1024;
      *(_DWORD *)v27 = v9;
      *(_WORD *)&v27[4] = 1024;
      *(_DWORD *)&v27[6] = v10;
      _os_log_error_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_ERROR, " [%s] %s:%d _VideoReceiver_FindAndCopySliceNalu failed as fake nalu and slice header missing in SFrame, nalu hdr %d slice hdr %d", (uint8_t *)&v20, 0x28u);
    }
  }
  return v16;
}

uint64_t _VCSFrameCryptorH264_FindAndExtractSliceNalu(uint64_t a1, CMBlockBufferRef theBuffer, unint64_t a3, CMBlockBufferRef *a4, _QWORD *a5)
{
  uint64_t SFramePayloadFromSlice;
  size_t v8;
  size_t v9;
  uint64_t v10;
  size_t v11;
  int v12;
  void *v13;
  void *v14;
  int FrameSliceHeader;
  uint64_t v16;
  NSObject *v17;
  NSObject *v18;
  int ErrorLogLevelForModule;
  uint64_t v20;
  NSObject *v21;
  NSObject *v22;
  NSObject *v23;
  const char *v24;
  uint64_t v25;
  NSObject *v26;
  uint64_t v27;
  NSObject *v28;
  const char *v29;
  NSObject *v30;
  uint32_t v31;
  uint64_t v32;
  NSObject *v33;
  size_t totalLengthOut;
  size_t lengthAtOffsetOut;
  char *dataPointerOut;
  CFTypeRef cf;
  uint8_t buf[4];
  uint64_t v43;
  __int16 v44;
  const char *v45;
  __int16 v46;
  int v47;
  __int16 v48;
  _BYTE v49[34];
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  SFramePayloadFromSlice = 2151809055;
  cf = 0;
  if (!a3)
    return SFramePayloadFromSlice;
  v8 = 0;
  while (1)
  {
    lengthAtOffsetOut = 0xAAAAAAAAAAAAAAAALL;
    dataPointerOut = 0;
    totalLengthOut = 0xAAAAAAAAAAAAAAAALL;
    if (CMBlockBufferGetDataPointer(theBuffer, v8, &lengthAtOffsetOut, 0, &dataPointerOut))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v27 = VRTraceErrorLogLevelToCSTR();
        v28 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136316162;
          v43 = v27;
          v44 = 2080;
          v45 = "_VCSFrameCryptorH264_FindAndExtractSliceNalu";
          v46 = 1024;
          v47 = 232;
          v48 = 2048;
          *(_QWORD *)v49 = v8;
          *(_WORD *)&v49[8] = 2048;
          *(_QWORD *)&v49[10] = a3;
          v29 = " [%s] %s:%d _VideoReceiver_FindAndCopySliceNalu: Failed to access block buffer data at offset %zu, bufferLength is %zu";
          v30 = v28;
          v31 = 48;
          goto LABEL_51;
        }
      }
LABEL_58:
      SFramePayloadFromSlice = 2151809055;
      goto LABEL_59;
    }
    if (v8 + 4 > a3 || lengthAtOffsetOut <= 3)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCSFrameCryptorH264_FindAndExtractSliceNalu_cold_1();
      }
      goto LABEL_58;
    }
    v9 = bswap32(*(_DWORD *)dataPointerOut);
    v10 = v9 + 4;
    v11 = v9 + 4 + v8;
    if (v11 > a3)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v32 = VRTraceErrorLogLevelToCSTR();
        v33 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136316418;
          v43 = v32;
          v44 = 2080;
          v45 = "_VCSFrameCryptorH264_FindAndExtractSliceNalu";
          v46 = 1024;
          v47 = 237;
          v48 = 2048;
          *(_QWORD *)v49 = v10;
          *(_WORD *)&v49[8] = 2048;
          *(_QWORD *)&v49[10] = v8;
          *(_WORD *)&v49[18] = 2048;
          *(_QWORD *)&v49[20] = a3;
          v29 = " [%s] %s:%d _VideoReceiver_FindAndCopySliceNalu: Failed to parse, next nalu offset invalid:%zu offset:%z"
                "u total buffer length:%zu";
          v30 = v33;
          v31 = 58;
LABEL_51:
          _os_log_error_impl(&dword_1D8A54000, v30, OS_LOG_TYPE_ERROR, v29, buf, v31);
        }
      }
      goto LABEL_58;
    }
    if (CMBlockBufferGetDataPointer(theBuffer, v8 + 4, &lengthAtOffsetOut, &totalLengthOut, &dataPointerOut))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCSFrameCryptorH264_FindAndExtractSliceNalu_cold_5();
      }
      goto LABEL_58;
    }
    v12 = lengthAtOffsetOut;
    if (lengthAtOffsetOut >= v9)
    {
      v14 = 0;
      goto LABEL_13;
    }
    lengthAtOffsetOut = v9;
    v13 = malloc_type_malloc(v9, 0x100004077774924uLL);
    if (!v13)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCSFrameCryptorH264_FindAndExtractSliceNalu_cold_2();
      }
      goto LABEL_58;
    }
    v14 = v13;
    if (CMBlockBufferAccessDataBytes(theBuffer, v8 + 4, lengthAtOffsetOut, v13, &dataPointerOut))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCSFrameCryptorH264_FindAndExtractSliceNalu_cold_4();
      }
      SFramePayloadFromSlice = 2151809055;
      goto LABEL_41;
    }
    v12 = lengthAtOffsetOut;
LABEL_13:
    FrameSliceHeader = ReadFrameSliceHeader(123, (uint64_t)dataPointerOut, v12, (CFDictionaryRef *)&cf);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v16 = VRTraceErrorLogLevelToCSTR();
      v17 = *MEMORY[0x1E0CF2758];
      v18 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316674;
          v43 = v16;
          v44 = 2080;
          v45 = "_VCSFrameCryptorH264_FindAndExtractSliceNalu";
          v46 = 1024;
          v47 = 256;
          v48 = 1024;
          *(_DWORD *)v49 = FrameSliceHeader;
          *(_WORD *)&v49[4] = 2048;
          *(_QWORD *)&v49[6] = v8;
          *(_WORD *)&v49[14] = 2048;
          *(_QWORD *)&v49[16] = v10;
          *(_WORD *)&v49[24] = 2048;
          *(_QWORD *)&v49[26] = lengthAtOffsetOut;
          _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Frame type %d offset %zu nextNaluOffset %zu dataPointerLength %zu", buf, 0x40u);
        }
      }
      else if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136316674;
        v43 = v16;
        v44 = 2080;
        v45 = "_VCSFrameCryptorH264_FindAndExtractSliceNalu";
        v46 = 1024;
        v47 = 256;
        v48 = 1024;
        *(_DWORD *)v49 = FrameSliceHeader;
        *(_WORD *)&v49[4] = 2048;
        *(_QWORD *)&v49[6] = v8;
        *(_WORD *)&v49[14] = 2048;
        *(_QWORD *)&v49[16] = v10;
        *(_WORD *)&v49[24] = 2048;
        *(_QWORD *)&v49[26] = lengthAtOffsetOut;
        _os_log_debug_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Frame type %d offset %zu nextNaluOffset %zu dataPointerLength %zu", buf, 0x40u);
      }
    }
    if (FrameSliceHeader == 1)
      break;
    ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    if ((FrameSliceHeader - 3) > 1)
    {
      if (ErrorLogLevelForModule >= 5)
      {
        v25 = VRTraceErrorLogLevelToCSTR();
        v26 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315906;
          v43 = v25;
          v44 = 2080;
          v45 = "_VCSFrameCryptorH264_FindAndExtractSliceNalu";
          v46 = 1024;
          v47 = 265;
          v48 = 1024;
          *(_DWORD *)v49 = FrameSliceHeader;
          v23 = v26;
          v24 = " [%s] %s:%d Unknown NALU Type: %d, drop it";
LABEL_28:
          _os_log_impl(&dword_1D8A54000, v23, OS_LOG_TYPE_DEFAULT, v24, buf, 0x22u);
          if (!v14)
            goto LABEL_33;
          goto LABEL_32;
        }
      }
    }
    else if (ErrorLogLevelForModule >= 8)
    {
      v20 = VRTraceErrorLogLevelToCSTR();
      v21 = *MEMORY[0x1E0CF2758];
      v22 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315906;
          v43 = v20;
          v44 = 2080;
          v45 = "_VCSFrameCryptorH264_FindAndExtractSliceNalu";
          v46 = 1024;
          v47 = 263;
          v48 = 1024;
          *(_DWORD *)v49 = FrameSliceHeader;
          v23 = v21;
          v24 = " [%s] %s:%d SPS/PPS NALU Type in clear: %d, drop it";
          goto LABEL_28;
        }
      }
      else if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136315906;
        v43 = v20;
        v44 = 2080;
        v45 = "_VCSFrameCryptorH264_FindAndExtractSliceNalu";
        v46 = 1024;
        v47 = 263;
        v48 = 1024;
        *(_DWORD *)v49 = FrameSliceHeader;
        _os_log_debug_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEBUG, " [%s] %s:%d SPS/PPS NALU Type in clear: %d, drop it", buf, 0x22u);
        if (!v14)
          goto LABEL_33;
LABEL_32:
        free(v14);
        goto LABEL_33;
      }
    }
    if (v14)
      goto LABEL_32;
LABEL_33:
    if (cf)
      CFRelease(cf);
    v8 = v11;
    if (v11 >= a3)
      goto LABEL_58;
  }
  SFramePayloadFromSlice = _VCSFrameCryptorH264_ExtractSFramePayloadFromSlice(a1, (unsigned int *)dataPointerOut, theBuffer, a4, a5, v8, v10);
  if ((_DWORD)SFramePayloadFromSlice)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCSFrameCryptorH264_FindAndExtractSliceNalu_cold_3();
    }
  }
  if (v14)
LABEL_41:
    free(v14);
LABEL_59:
  if (cf)
    CFRelease(cf);
  return SFramePayloadFromSlice;
}

uint64_t _VCSFrameCryptroH264_EscapeEncryptedBuffer(uint64_t a1, uint64_t a2, unint64_t a3, CMBlockBufferRef *blockBufferOut, size_t dataLength, uint64_t a6, char **a7)
{
  uint64_t BlockBufferPtr;
  uint64_t v13;

  BlockBufferPtr = _VCSFrameCryptorH264_CreateAndGetBlockBufferPtr(a1, blockBufferOut, dataLength, a7);
  if ((_DWORD)BlockBufferPtr)
  {
    v13 = BlockBufferPtr;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCSFrameCryptroH264_EscapeEncryptedBuffer_cold_2();
    }
  }
  else
  {
    v13 = VideoUtil_PerformEscapingForBuffer(a2, a3, (uint64_t)&(*a7)[a6], dataLength - a6);
    if ((_DWORD)v13)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCSFrameCryptroH264_EscapeEncryptedBuffer_cold_1();
      }
    }
  }
  return v13;
}

uint64_t _VCSFrameCryptorH264_RemoveEmulationBytesFromPayloadBuffer(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, CMBlockBufferRef *a5)
{
  size_t v8;
  uint64_t v9;
  uint64_t DataPointer;
  uint64_t v11;
  char *dataPointerOut;
  CMBlockBufferRef theBuffer[2];

  theBuffer[1] = *(CMBlockBufferRef *)MEMORY[0x1E0C80C00];
  theBuffer[0] = 0;
  v8 = a3 - a4;
  v9 = CMBlockBufferCreateWithMemoryBlock(*(CFAllocatorRef *)(a1 + 8), 0, v8, *(CFAllocatorRef *)(a1 + 16), 0, 0, v8, 1u, theBuffer);
  if ((_DWORD)v9)
  {
    v11 = v9;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCSFrameCryptorH264_RemoveEmulationBytesFromPayloadBuffer_cold_3();
    }
  }
  else
  {
    dataPointerOut = 0;
    DataPointer = CMBlockBufferGetDataPointer(theBuffer[0], 0, 0, 0, &dataPointerOut);
    if ((_DWORD)DataPointer)
    {
      v11 = DataPointer;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCSFrameCryptorH264_RemoveEmulationBytesFromPayloadBuffer_cold_2();
      }
    }
    else
    {
      v11 = VideoUtil_RemoveEmulationBytesFromBuffer(a2, a3, (uint64_t)dataPointerOut, v8);
      if (!(_DWORD)v11)
      {
        *a5 = theBuffer[0];
        return v11;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCSFrameCryptorH264_RemoveEmulationBytesFromPayloadBuffer_cold_1();
      }
    }
  }
  if (theBuffer[0])
    CFRelease(theBuffer[0]);
  return v11;
}

uint64_t VCSFrameCryptorH264_Create(const void *a1, CFAllocatorRef **a2)
{
  CFAllocatorRef *v4;
  CFAllocatorRef *v5;
  const __CFAllocator *v6;
  const __CFAllocator *v7;
  uint64_t v8;
  _OWORD v10[2];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v4 = (CFAllocatorRef *)malloc_type_calloc(1uLL, 0x18uLL, 0x6004082687C62uLL);
    if (v4)
    {
      v5 = v4;
      v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      if (VCAllocatorFirstCome_Create((const __CFAllocator *)*MEMORY[0x1E0C9AE00], (uint64_t)"VCSFrameCryptorH264BlockBufferHeaderAllocator", v4 + 1))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCSFrameCryptorH264_Create_cold_4();
        }
      }
      else
      {
        v10[0] = xmmword_1D910AC88;
        v10[1] = unk_1D910AC98;
        if (!VCAllocatorMultiQueue_Create(v6, (uint64_t)"VCSFrameCryptorH264BlockBufferDataAllocator", 4u, (unint64_t *)v10, v5 + 2))
        {
          v7 = (const __CFAllocator *)CFRetain(a1);
          v8 = 0;
          *v5 = v7;
          *a2 = v5;
          return v8;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCSFrameCryptorH264_Create_cold_3();
        }
      }
      free(v5);
      return 0;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
    {
      return 2151809027;
    }
    else
    {
      VRTraceErrorLogLevelToCSTR();
      v8 = 2151809027;
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCSFrameCryptorH264_Create_cold_2();
    }
  }
  else
  {
    v8 = 2151809025;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCSFrameCryptorH264_Create_cold_1();
    }
  }
  return v8;
}

void VCSFrameCryptorH264_Destroy(CFTypeRef **a1)
{
  CFTypeRef *v2;

  v2 = *a1;
  if (v2)
  {
    if (v2[1])
    {
      CFRelease(v2[1]);
      v2 = *a1;
    }
    if (v2[2])
    {
      CFRelease(v2[2]);
      v2 = *a1;
    }
    if (*v2)
    {
      CFRelease(*v2);
      v2 = *a1;
    }
    free(v2);
    *a1 = 0;
  }
}

uint64_t VCSFrameCryptorH264_Encrypt(uint64_t a1, int a2, CMBlockBufferRef theBuffer, CMBlockBufferRef *a4)
{
  uint64_t v8;
  __int128 v9;
  uint64_t v10;
  size_t v11;
  uint64_t v12;
  uint64_t started;
  uint64_t EncryptedBufferSize;
  size_t v15;
  uint64_t BlockBufferPtr;
  uint64_t v17;
  uint64_t EscapeCountForBuffer;
  int v19;
  uint64_t v20;
  char *v21;
  unsigned int v22;
  char v23;
  char v24;
  uint64_t v25;
  uint64_t v27;
  NSObject *v28;
  char *v29;
  char *v30;
  void *__dst;
  size_t dataLength;
  size_t v33;
  char *dataPointerOut;
  size_t totalLengthOut;
  CFTypeRef cf;
  CMBlockBufferRef blockBufferOut;
  CMBlockBufferRef bufferReference;
  _OWORD __src[25];
  uint8_t buf[4];
  uint64_t v41;
  __int16 v42;
  const char *v43;
  __int16 v44;
  int v45;
  __int16 v46;
  size_t v47;
  __int16 v48;
  size_t v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  blockBufferOut = 0;
  bufferReference = 0;
  cf = 0;
  totalLengthOut = CMBlockBufferGetDataLength(theBuffer);
  v8 = _VCSFrameCryptorH264_ValidateInputParameters(a1, (uint64_t)theBuffer, totalLengthOut, (uint64_t)a4);
  if ((_DWORD)v8)
  {
    v25 = v8;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCSFrameCryptorH264_Encrypt_cold_13();
    }
    goto LABEL_81;
  }
  dataPointerOut = 0;
  if (CMBlockBufferGetDataPointer(theBuffer, 0, &totalLengthOut, &totalLengthOut, &dataPointerOut))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCSFrameCryptorH264_Encrypt_cold_12();
    }
  }
  else
  {
    v33 = 400;
    *(_QWORD *)&v9 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __src[0] = v9;
    __src[1] = v9;
    __src[2] = v9;
    __src[3] = v9;
    __src[4] = v9;
    __src[5] = v9;
    __src[6] = v9;
    __src[7] = v9;
    __src[8] = v9;
    __src[9] = v9;
    __src[10] = v9;
    __src[11] = v9;
    __src[12] = v9;
    __src[13] = v9;
    __src[14] = v9;
    __src[15] = v9;
    __src[16] = v9;
    __src[17] = v9;
    __src[18] = v9;
    __src[19] = v9;
    __src[20] = v9;
    __src[21] = v9;
    __src[22] = v9;
    __src[23] = v9;
    __src[24] = v9;
    if (a2)
    {
      v10 = _VCSFrameCryptorH264_FindAndExtractSPSPPSFromEncodedBuffer((uint64_t)dataPointerOut, totalLengthOut, (char *)__src, &v33);
      if ((_DWORD)v10)
      {
        v25 = v10;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCSFrameCryptorH264_Encrypt_cold_11();
        }
        goto LABEL_81;
      }
      v11 = v33;
      v12 = v33 + 6;
    }
    else
    {
      v11 = 0;
      v33 = 0;
      v12 = 6;
    }
    started = VideoUtil_ReplaceNALLengthWithStartCode((uint64_t)dataPointerOut, totalLengthOut);
    if ((_DWORD)started)
    {
      v25 = started;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCSFrameCryptorH264_Encrypt_cold_10();
      }
      goto LABEL_81;
    }
    dataLength = 0;
    EncryptedBufferSize = VCCryptor_GetEncryptedBufferSize(*(_QWORD *)a1, totalLengthOut, &dataLength);
    if ((_DWORD)EncryptedBufferSize)
    {
      v25 = EncryptedBufferSize;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCSFrameCryptorH264_Encrypt_cold_9();
      }
      goto LABEL_81;
    }
    v15 = dataLength + v12;
    __dst = 0;
    BlockBufferPtr = _VCSFrameCryptorH264_CreateAndGetBlockBufferPtr(a1, &bufferReference, dataLength + v12, (char **)&__dst);
    if ((_DWORD)BlockBufferPtr)
    {
      v25 = BlockBufferPtr;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCSFrameCryptorH264_Encrypt_cold_8();
      }
      goto LABEL_81;
    }
    if (CMBlockBufferCreateWithBufferReference(*(CFAllocatorRef *)(a1 + 8), bufferReference, v12, dataLength, 0, &blockBufferOut))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      {
        v25 = 2151809027;
      }
      else
      {
        VRTraceErrorLogLevelToCSTR();
        v25 = 2151809027;
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCSFrameCryptorH264_Encrypt_cold_7();
      }
      goto LABEL_81;
    }
    v17 = VCCryptor_Encrypt(*(_QWORD *)a1, theBuffer, (CFTypeRef *)&blockBufferOut);
    if ((_DWORD)v17)
    {
      v25 = v17;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCSFrameCryptorH264_Encrypt_cold_6();
      }
      goto LABEL_81;
    }
    v30 = 0;
    if (!CMBlockBufferGetDataPointer(blockBufferOut, 0, 0, 0, &v30))
    {
      EscapeCountForBuffer = VideoUtil_GetEscapeCountForBuffer((unsigned __int8 *)v30, dataLength);
      v19 = EscapeCountForBuffer;
      v29 = 0;
      if (EscapeCountForBuffer)
      {
        v15 += EscapeCountForBuffer;
        v20 = _VCSFrameCryptroH264_EscapeEncryptedBuffer(a1, (uint64_t)v30, dataLength, (CMBlockBufferRef *)&cf, v15, v12, &v29);
        if ((_DWORD)v20)
        {
          v25 = v20;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VCSFrameCryptorH264_Encrypt_cold_4();
          }
          goto LABEL_81;
        }
        __dst = v29;
        if (bufferReference)
          CFRelease(bufferReference);
        bufferReference = (CMBlockBufferRef)cf;
        cf = 0;
      }
      if (v11 + 6 > v15)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() < 3)
        {
          v25 = 2151809087;
        }
        else
        {
          v27 = VRTraceErrorLogLevelToCSTR();
          v28 = *MEMORY[0x1E0CF2758];
          v25 = 2151809087;
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136316162;
            v41 = v27;
            v42 = 2080;
            v43 = "_VCSFrameCryptorH264_AppendPrefixNalusForSFramePacketization";
            v44 = 1024;
            v45 = 67;
            v46 = 2048;
            v47 = v15;
            v48 = 2048;
            v49 = v11 + 6;
            _os_log_error_impl(&dword_1D8A54000, v28, OS_LOG_TYPE_ERROR, " [%s] %s:%d _VCSFrameCryptorH264_AppendPrefixNalusForSFramePacketization failed due to invalid block buffer size:%zu, minimum required size:%zu", buf, 0x30u);
          }
        }
      }
      else
      {
        v21 = (char *)__dst;
        if (__dst)
        {
          v22 = v19 + dataLength + 2;
          if (v11 && a2)
          {
            memcpy(__dst, __src, v11);
            v21 += v11;
          }
          *(_DWORD *)v21 = bswap32(v22);
          if (a2)
            v23 = 37;
          else
            v23 = 33;
          if (a2)
            v24 = -72;
          else
            v24 = -32;
          v21[4] = v23;
          v21[5] = v24;
          if (CMBlockBufferIsRangeContiguous(bufferReference, 0, v15))
          {
            v25 = 0;
            *a4 = bufferReference;
            bufferReference = 0;
            goto LABEL_31;
          }
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VCSFrameCryptorH264_Encrypt_cold_3();
          }
          goto LABEL_69;
        }
        v25 = 2151809025;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCSFrameCryptorH264_Encrypt_cold_2();
        }
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCSFrameCryptorH264_Encrypt_cold_1();
      }
      goto LABEL_81;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCSFrameCryptorH264_Encrypt_cold_5();
    }
  }
LABEL_69:
  v25 = 0;
LABEL_81:
  if (bufferReference)
    CFRelease(bufferReference);
LABEL_31:
  if (blockBufferOut)
    CFRelease(blockBufferOut);
  if (cf)
    CFRelease(cf);
  return v25;
}

uint64_t _VCSFrameCryptorH264_ValidateInputParameters(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;

  if (a1)
  {
    if (a2)
    {
      if (a4)
      {
        if (a3)
        {
          return 0;
        }
        else
        {
          v4 = 2151677953;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              _VCSFrameCryptorH264_ValidateInputParameters_cold_4();
          }
        }
      }
      else
      {
        v4 = 2151677953;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VCSFrameCryptorH264_ValidateInputParameters_cold_3();
        }
      }
    }
    else
    {
      v4 = 2151677953;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCSFrameCryptorH264_ValidateInputParameters_cold_2();
      }
    }
  }
  else
  {
    v4 = 2151677953;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCSFrameCryptorH264_ValidateInputParameters_cold_1();
    }
  }
  return v4;
}

uint64_t VCSFrameCryptorH264_Decrypt(uint64_t *a1, CMBlockBufferRef theBuffer, CMBlockBufferRef *a3)
{
  size_t DataLength;
  uint64_t v7;
  uint64_t v8;
  uint64_t EmulationByteCountForBuffer;
  uint64_t v10;
  OpaqueCMBlockBuffer *v11;
  uint64_t v12;
  size_t v13;
  uint64_t started;
  uint64_t v16;
  NSObject *v17;
  char *v18;
  char *dataPointerOut;
  size_t totalLengthOut;
  CFTypeRef cf;
  CMBlockBufferRef v22;
  CMBlockBufferRef theBuffera;
  uint8_t buf[4];
  uint64_t v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  size_t v31;
  __int16 v32;
  size_t v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v22 = 0;
  theBuffera = 0;
  cf = 0;
  DataLength = CMBlockBufferGetDataLength(theBuffer);
  v7 = _VCSFrameCryptorH264_ValidateInputParameters((uint64_t)a1, (uint64_t)theBuffer, DataLength, (uint64_t)a3);
  if ((_DWORD)v7)
  {
    started = v7;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCSFrameCryptorH264_Decrypt_cold_7();
    }
  }
  else
  {
    totalLengthOut = 0;
    v8 = _VCSFrameCryptorH264_FindAndExtractSliceNalu((uint64_t)a1, theBuffer, DataLength, &theBuffera, &totalLengthOut);
    if ((_DWORD)v8)
    {
      started = v8;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCSFrameCryptorH264_Decrypt_cold_6();
      }
    }
    else
    {
      dataPointerOut = 0;
      if (CMBlockBufferGetDataPointer(theBuffera, 0, &totalLengthOut, &totalLengthOut, &dataPointerOut))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCSFrameCryptorH264_Decrypt_cold_5();
        }
        goto LABEL_40;
      }
      EmulationByteCountForBuffer = VideoUtil_GetEmulationByteCountForBuffer((uint64_t)dataPointerOut, totalLengthOut);
      if (EmulationByteCountForBuffer)
      {
        v10 = _VCSFrameCryptorH264_RemoveEmulationBytesFromPayloadBuffer((uint64_t)a1, (uint64_t)dataPointerOut, totalLengthOut, EmulationByteCountForBuffer, (CMBlockBufferRef *)&cf);
        if ((_DWORD)v10)
        {
          started = v10;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VCSFrameCryptorH264_Decrypt_cold_4();
          }
          goto LABEL_15;
        }
        if (theBuffera)
          CFRelease(theBuffera);
        v11 = (OpaqueCMBlockBuffer *)cf;
        theBuffera = (CMBlockBufferRef)cf;
        cf = 0;
      }
      else
      {
        v11 = theBuffera;
      }
      v12 = VCCryptor_Decrypt(*a1, v11, &v22);
      if (!(_DWORD)v12)
      {
        v18 = 0;
        if (CMBlockBufferGetDataPointer(v22, 0, 0, 0, &v18))
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VCSFrameCryptorH264_Decrypt_cold_2();
          }
        }
        else
        {
          v13 = CMBlockBufferGetDataLength(v22);
          if (v13 <= totalLengthOut)
          {
            started = VideoUtil_ReplaceStartCodeWithNALLength((uint64_t)v18, v13);
            if ((_DWORD)started)
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  VCSFrameCryptorH264_Decrypt_cold_1();
              }
            }
            else
            {
              *a3 = v22;
              v22 = 0;
            }
            goto LABEL_15;
          }
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            v16 = VRTraceErrorLogLevelToCSTR();
            v17 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136316162;
              v25 = v16;
              v26 = 2080;
              v27 = "VCSFrameCryptorH264_Decrypt";
              v28 = 1024;
              v29 = 502;
              v30 = 2048;
              v31 = v13;
              v32 = 2048;
              v33 = totalLengthOut;
              _os_log_error_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_ERROR, " [%s] %s:%d Decrypted buffer size(%zu) cannot be larger than payload size(%zu)", buf, 0x30u);
            }
          }
        }
LABEL_40:
        started = 0;
        goto LABEL_15;
      }
      started = v12;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCSFrameCryptorH264_Decrypt_cold_3();
      }
    }
  }
LABEL_15:
  if (cf)
    CFRelease(cf);
  if (v22)
    CFRelease(v22);
  if (theBuffera)
    CFRelease(theBuffera);
  return started;
}

uint64_t RS_SetOptimizationEnabled(uint64_t result)
{
  _RS_isOptimizationEnabled = result;
  return result;
}

void RSEncode(unsigned __int8 *a1, _BYTE *a2, int a3)
{
  int8x16_t v3;
  uint64_t v4;
  unsigned __int8 v5;
  uint64_t v6;
  uint64_t i;
  int8x16_t v9;

  if (_RS_isOptimizationEnabled)
  {
    v3 = 0uLL;
    if (gGenPolyDegree <= 0xEuLL)
    {
      v4 = gGenPolyDegree - 15;
      do
      {
        v5 = *a1++;
        v6 = gIndexTable[(v5 ^ v3.i8[0]) & 0xF];
        v3 = (int8x16_t)vshrq_n_u64((uint64x2_t)v3, 8uLL);
        if (v6 != 15)
          v3 = veorq_s8(vqtbl1q_s8(*(int8x16_t *)&gAlphaTable[v6], (int8x16_t)xmmword_1D910ACB0), v3);
      }
      while (!__CFADD__(v4++, 1));
    }
    if (a3 >= 1)
    {
      for (i = 0; i != a3; ++i)
      {
        v9 = v3;
        a2[i] = *(_BYTE *)((unint64_t)&v9 | i & 0xF);
      }
    }
  }
  else
  {
    _RS_Encode_Original((uint64_t)a1, a2, a3);
  }
}

void _RS_Encode_Original(uint64_t a1, _BYTE *a2, int a3)
{
  size_t v6;
  uint64_t v7;
  unsigned __int8 *v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  unsigned __int8 v16;
  uint64_t v17;
  uint64_t v18;
  unsigned __int8 *v19;
  char v20;
  _QWORD v21[2];

  v21[1] = *MEMORY[0x1E0C80C00];
  v6 = gGenPolyDegree;
  MEMORY[0x1E0C80A78](a1);
  v8 = (unsigned __int8 *)v21 - v7;
  v9 = (char *)v21 - v7;
  if ((_DWORD)v6)
  {
    memset(v9, 170, v6);
    bzero(v8, v6);
    if (v6 > 0xE)
      goto LABEL_16;
  }
  else
  {
    bzero(v9, v6);
  }
  v10 = 0;
  v11 = gGenPoly[v6];
  v12 = gGenPoly[0];
  do
  {
    v13 = gIndexTable[v8[v6 - 1] ^ *(_BYTE *)(a1 + v10)] - v11;
    if ((_DWORD)v13 == 15)
    {
      v14 = (v6 - 1);
      if (v6 >= 2)
      {
        do
        {
          v15 = v14 <= 1;
          v8[v14] = v8[(v14 - 1)];
          --v14;
        }
        while (!v15);
      }
      v16 = 0;
    }
    else
    {
      v17 = (v6 - 1);
      if (v6 >= 2)
      {
        do
        {
          v15 = v17 <= 1;
          v8[v17] = gAlphaTable[v13 + gGenPoly[v17]] ^ v8[(v17 - 1)];
          --v17;
        }
        while (!v15);
      }
      v16 = gAlphaTable[v12 + (int)v13];
    }
    *v8 = v16;
    ++v10;
  }
  while (v10 != 15 - (_DWORD)v6);
LABEL_16:
  if (a3 >= 1)
  {
    v18 = a3;
    v19 = &v8[v6 - 1];
    do
    {
      v20 = *v19--;
      *a2++ = v20;
      --v18;
    }
    while (v18);
  }
}

unsigned __int8 *RSEncode2Nibbles(unsigned __int8 *result, uint64_t a2, int a3)
{
  int8x16_t v3;
  uint64_t v4;
  unsigned __int8 v5;
  unsigned __int8 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t i;
  int8x16_t v10;

  v3 = 0uLL;
  if (gGenPolyDegree <= 0xEuLL)
  {
    v4 = 15 - gGenPolyDegree;
    do
    {
      v5 = *result++;
      v6 = v5 ^ v3.i8[0];
      v7 = gIndexTable[(v5 ^ v3.i8[0]) & 0xF];
      v3 = (int8x16_t)vshrq_n_u64((uint64x2_t)v3, 8uLL);
      if (v7 != 15)
        v3 = veorq_s8(vqtbl1q_s8(*(int8x16_t *)((char *)&gAlphaTable + v7), (int8x16_t)xmmword_1D910ACB0), v3);
      v8 = gIndexTable[v6 >> 4];
      if ((_DWORD)v8 != 15)
        v3 = veorq_s8(vshlq_n_s8(vqtbl1q_s8(*(int8x16_t *)((char *)&gAlphaTable + v8), (int8x16_t)xmmword_1D910ACB0), 4uLL), v3);
      --v4;
    }
    while (v4);
  }
  if (a3 >= 1)
  {
    for (i = 0; i != a3; ++i)
    {
      v10 = v3;
      *(_BYTE *)(a2 + i) = *(_BYTE *)((unint64_t)&v10 | i & 0xF);
    }
  }
  return result;
}

int8x16_t RSEncodeSimd(uint64_t a1, int a2, int8x16_t result)
{
  uint64_t v3;
  int8x16_t v4;
  uint64_t v5;
  int8x16_t *v6;

  result.i16[0] = 0;
  result.i8[2] = 0;
  result.i8[3] = 0;
  result.i8[4] = 0;
  result.i8[5] = 0;
  result.i8[6] = 0;
  result.i8[7] = 0;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  if (a2 >= 1)
  {
    v3 = 8 - a2;
    do
    {
      v4 = veorq_s8(*(int8x16_t *)(a1 + 128), *(int8x16_t *)(a1 + 16 * v3));
      v5 = 6u;
      v6 = (int8x16_t *)(a1 + 144);
      do
      {
        v6[-1] = veorq_s8(vqtbl1q_s8((int8x16_t)gPolyMulTable[v5], v4), *v6);
        ++v6;
        --v5;
      }
      while (v5 * 16);
      result = vqtbl1q_s8((int8x16_t)gPolyMulTable[0], v4);
      *(int8x16_t *)(a1 + 224) = result;
      ++v3;
    }
    while ((_DWORD)v3 != 8);
  }
  return result;
}

uint64_t RSEncodeSimd2Nibbles(uint64_t result, int a2)
{
  uint64_t v2;
  int8x16_t v3;
  int8x16_t v4;
  int8x16_t v5;
  int8x16_t v6;
  uint64_t v7;
  int8x16_t *v8;
  int8x16_t *v9;
  int8x16_t v10;
  int8x16_t v11;

  *(_OWORD *)(result + 208) = 0u;
  *(_OWORD *)(result + 224) = 0u;
  *(_OWORD *)(result + 176) = 0u;
  *(_OWORD *)(result + 192) = 0u;
  *(_OWORD *)(result + 144) = 0u;
  *(_OWORD *)(result + 160) = 0u;
  *(_OWORD *)(result + 128) = 0u;
  if (a2 >= 1)
  {
    v2 = 8 - a2;
    v3.i64[0] = 0xF0F0F0F0F0F0F0FLL;
    v3.i64[1] = 0xF0F0F0F0F0F0F0FLL;
    do
    {
      v4 = veorq_s8(*(int8x16_t *)(result + 128), *(int8x16_t *)(result + 16 * v2));
      v5 = vandq_s8(v4, v3);
      v6 = (int8x16_t)vshrq_n_u8((uint8x16_t)v4, 4uLL);
      v7 = 6u;
      v8 = (int8x16_t *)(result + 128);
      v9 = (int8x16_t *)(result + 128);
      do
      {
        v10 = v9[1];
        ++v9;
        v11 = veorq_s8(vqtbl1q_s8((int8x16_t)gPolyMulTable[v7], v5), v10);
        *v8 = v11;
        *v8 = veorq_s8(vshlq_n_s8(vqtbl1q_s8((int8x16_t)gPolyMulTable[v7], v6), 4uLL), v11);
        v8 = v9;
        --v7;
      }
      while (v7 * 16);
      *(int8x16_t *)(result + 224) = vsliq_n_s8(vqtbl1q_s8((int8x16_t)gPolyMulTable[0], v5), vqtbl1q_s8((int8x16_t)gPolyMulTable[0], v6), 4uLL);
      ++v2;
    }
    while ((_DWORD)v2 != 8);
  }
  return result;
}

uint64_t Decode(int8x16_t *a1, uint64_t a2, int a3, unsigned __int8 *a4, uint64_t a5, int8x16_t *a6)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  int8x16_t v9;
  int8x16_t v10;
  int8x16_t v11;
  uint8x16_t v12;
  _QWORD *v13;
  int v14;
  int8x16_t v15;
  int8x16_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _BYTE *v20;
  unsigned __int8 *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  int v27;
  char *v28;
  unsigned __int8 *v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  unsigned __int8 *v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  int v43;
  uint64_t v44;
  unsigned __int8 *v45;
  unsigned __int8 *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  int v52;
  char *v53;
  unsigned __int8 *v54;
  uint64_t v55;
  uint64_t v56;
  unsigned int v57;
  unsigned __int8 v59[8];
  _QWORD v60[3];

  v60[2] = *MEMORY[0x1E0C80C00];
  if (_RS_isOptimizationEnabled)
  {
    *(_DWORD *)((char *)v60 + 3) = 0;
    LODWORD(v60[0]) = 0;
    v6 = gGenPolyDegree;
    if (gGenPolyDegree)
    {
      v7 = 0;
      v8 = 0;
      v9 = vqtbl1q_s8((int8x16_t)xmmword_1D910ACC0, *a1);
      v10.i64[0] = 0xF0F0F0F0F0F0F0FLL;
      v10.i64[1] = 0xF0F0F0F0F0F0F0FLL;
      v11 = vbicq_s8(vtstq_s8(*a6, *a6), vceqq_s8(v9, v10));
      v12.i64[0] = 0x8989898989898989;
      v12.i64[1] = 0x8989898989898989;
      v13 = v60;
      do
      {
        if ((int)v8 <= (int)v6)
          v14 = v6;
        else
          v14 = v8;
        v15 = vaddq_s8(v9, (int8x16_t)xmmword_1D910ACD0);
        v9 = vmlsq_s8(v15, (int8x16_t)vshrq_n_u8((uint8x16_t)vuzp2q_s8((int8x16_t)vmull_u8(*(uint8x8_t *)v15.i8, *(uint8x8_t *)v12.i8), (int8x16_t)vmull_high_u8((uint8x16_t)v15, v12)), 3uLL), v10);
        if ((a3 & 0x80000000) == 0)
        {
          v16 = vandq_s8(vqtbl1q_s8((int8x16_t)xmmword_1D910ACE0, v9), v11);
          v17 = v16.i64[1] & 0xFFFFFFFFFFFFFFLL ^ v16.i64[0] ^ ((v16.i64[1] & 0xFFFFFFFFFFFFFFuLL ^ v16.i64[0]) >> 32);
          v18 = gIndexTable[(BYTE2(v17) ^ v17 ^ ((unsigned __int16)(WORD1(v17) ^ v17) >> 8))];
          if ((_DWORD)v18 != 15)
          {
            v19 = (v14 + v7);
            v20 = v13;
            v21 = a4;
            v22 = (a3 + 1);
            do
            {
              if (!v19)
                break;
              v23 = *v21;
              if (v23 != 15)
                *v20 ^= gAlphaTable[v23 + v18];
              ++v21;
              --v19;
              ++v20;
              --v22;
            }
            while (v22);
          }
        }
        if (v8)
          *((_BYTE *)v60 + v8) = gIndexTable[*((unsigned __int8 *)v60 + v8)];
        ++v8;
        --v7;
        v13 = (_QWORD *)((char *)v13 + 1);
      }
      while (v8 != v6);
    }
    if (a3 >= 1)
    {
      v24 = 0;
      v25 = LOBYTE(v60[0]);
      do
      {
        v26 = *(unsigned __int8 *)(a2 + v24);
        if (v26 > 7)
          break;
        v27 = v25;
        if (v6 >= 2)
        {
          v28 = (char *)&gAlphaTable[v26 + 1];
          v29 = (unsigned __int8 *)v60 + 1;
          v30 = v6 - 1;
          v27 = v25;
          do
          {
            v32 = *v29++;
            v31 = v32;
            if (v32 != 15)
              v27 ^= v28[v31];
            v28 += v26 + 1;
            --v30;
          }
          while (v30);
        }
        if (v27)
          LOBYTE(v27) = gAlphaTable[gIndexTable[v27] - *(unsigned __int8 *)(a5 + v24) + 15];
        a1->i8[v26] = v27;
        ++v24;
      }
      while (v24 != a3);
    }
  }
  else
  {
    v33 = 0;
    memset(v59, 0, 7);
    memset(v60, 170, 15);
    do
    {
      *((_BYTE *)v60 + v33) = gIndexTable[a1->u8[v33]];
      ++v33;
    }
    while (v33 != 15);
    v34 = gGenPolyDegree;
    if (gGenPolyDegree)
    {
      v35 = 0;
      v36 = 0;
      v37 = v59;
      do
      {
        v38 = 0;
        v39 = 0;
        v40 = v36;
        if ((int)v36 <= (int)v34)
          LODWORD(v36) = v34;
        v41 = (v36 + v35);
        v36 = v40 + 1;
        v42 = 14 * (v40 + 1);
        do
        {
          if (a6->i8[v38])
          {
            v43 = *((unsigned __int8 *)v60 + v38);
            if (v43 != 15)
              v39 ^= gAlphaTable[v42 + v43];
          }
          v42 -= v36;
          ++v38;
        }
        while (v38 != 15);
        if ((a3 & 0x80000000) == 0)
        {
          v44 = gIndexTable[v39];
          if ((_DWORD)v44 != 15)
          {
            v45 = v37;
            v46 = a4;
            v47 = (a3 + 1);
            do
            {
              if (!v41)
                break;
              v48 = *v46;
              if (v48 != 15)
                *v45 ^= gAlphaTable[v48 + v44];
              ++v46;
              --v41;
              ++v45;
              --v47;
            }
            while (v47);
          }
        }
        if (v40)
          v59[v40] = gIndexTable[v59[v40]];
        --v35;
        ++v37;
      }
      while (v36 != v34);
    }
    if (a3 >= 1)
    {
      v49 = 0;
      v50 = v59[0];
      do
      {
        v51 = *(unsigned __int8 *)(a2 + v49);
        if (v51 > 7)
          break;
        v52 = v50;
        if (v34 >= 2)
        {
          v53 = (char *)&gAlphaTable[v51 + 1];
          v54 = &v59[1];
          v55 = v34 - 1;
          v52 = v50;
          do
          {
            v57 = *v54++;
            v56 = v57;
            if (v57 != 15)
              v52 ^= v53[v56];
            v53 += v51 + 1;
            --v55;
          }
          while (v55);
        }
        if (v52)
          LOBYTE(v52) = gAlphaTable[gIndexTable[v52] - *(unsigned __int8 *)(a5 + v49) + 15];
        a1->i8[v51] = v52;
        ++v49;
      }
      while (v49 != a3);
    }
  }
  return 0;
}

_BYTE *RSCalculateGammaPoly(_BYTE *result, int a2, uint64_t a3)
{
  uint64_t i;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  *result = 1;
  if (a2 >= 1)
  {
    for (i = 0; i != a2; ++i)
    {
      v4 = (14 - *(_BYTE *)(a3 + i));
      v5 = i;
      do
      {
        if (result[v5])
          result[v5 + 1] ^= gAlphaTable[gIndexTable[result[v5]] + v4];
        v6 = v5-- + 1;
      }
      while (v6 > 1);
    }
  }
  return result;
}

uint64_t RSCalculateGammaDerEvalAtErasures(uint64_t result, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t i;
  unint64_t v5;
  int v6;
  unint64_t j;

  if (a3 >= 1)
  {
    for (i = 0; i != a3; *(_BYTE *)(result + i++) = gIndexTable[v5])
    {
      v5 = *(unsigned __int8 *)(a2 + 1);
      if (a3 >= 3)
      {
        v6 = 2 * *(unsigned __int8 *)(a4 + i) + 2;
        for (j = 3; j <= a3; j += 2)
        {
          if (*(_BYTE *)(a2 + j))
            v5 ^= gAlphaTable[v6 + gIndexTable[*(unsigned __int8 *)(a2 + j)]];
          v6 += 2 * *(unsigned __int8 *)(a4 + i) + 2;
        }
      }
    }
  }
  return result;
}

_BYTE *RSConvertToAlphaPow(_BYTE *result, unsigned __int8 *a2, int a3)
{
  uint64_t v3;
  int v4;

  if ((a3 & 0x80000000) == 0)
  {
    v3 = (a3 + 1);
    do
    {
      v4 = *a2++;
      *result++ = gIndexTable[v4];
      --v3;
    }
    while (v3);
  }
  return result;
}

uint64_t RSDecodeSimd(uint64_t result, uint64_t a2, int a3, unsigned __int8 *a4, uint64_t a5)
{
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  int8x16_t *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int8x16_t v14;
  unsigned __int8 *v15;
  int8x16_t *v16;
  unsigned __int8 *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int8x16_t v22;
  uint64_t v23;
  int8x16_t v24;
  unsigned __int8 *v25;
  int8x16_t *v26;
  uint64_t v27;
  int8x16_t v28;
  int8x16_t v29;
  _OWORD v30[6];
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  memset(v30, 0, sizeof(v30));
  v29 = 0u;
  v5 = gGenPolyDegree;
  if (gGenPolyDegree)
  {
    v6 = 0;
    v7 = 0;
    v8 = -1;
    v9 = &v29;
    v10 = 14;
    do
    {
      v11 = 0;
      if ((int)v7 <= (int)v5)
        v12 = v5;
      else
        v12 = v7;
      v13 = (v12 + v6);
      v14 = 0uLL;
      v15 = gAlphaTable;
      do
      {
        v14 = veorq_s8(vqtbl1q_s8(gGFMulTable[v15[v10]], *(int8x16_t *)(result + v11)), v14);
        v15 += v8;
        v11 += 16;
      }
      while (v11 != 240);
      if ((a3 & 0x80000000) == 0)
      {
        v16 = v9;
        v17 = a4;
        v18 = (a3 + 1);
        do
        {
          if (!v13)
            break;
          v19 = *v17;
          if (v19 != 15)
            *v16 = veorq_s8(*v16, vqtbl1q_s8(gGFMulTable[gAlphaTable[v19]], v14));
          ++v17;
          --v13;
          ++v16;
          --v18;
        }
        while (v18);
      }
      ++v7;
      v10 += 14;
      --v8;
      --v6;
      ++v9;
    }
    while (v7 != v5);
  }
  if (a3 >= 1)
  {
    v20 = 0;
    v21 = a3;
    v22 = v29;
    do
    {
      v23 = *(unsigned __int8 *)(a2 + v20);
      if (v23 > 7)
        break;
      v24 = v22;
      if (v5 >= 2)
      {
        v25 = &gAlphaTable[v23 + 1];
        v26 = (int8x16_t *)v30;
        v27 = v5 - 1;
        v24 = v22;
        do
        {
          v28 = *v26++;
          v24 = veorq_s8(vqtbl1q_s8(gGFMulTable[*v25], v28), v24);
          v25 += v23 + 1;
          --v27;
        }
        while (v27);
      }
      *(int8x16_t *)(result + 16 * v23) = vqtbl1q_s8(gGFMulTable[gInverseTable[gAlphaTable[*(unsigned __int8 *)(a5 + v20++)]]], v24);
    }
    while (v20 != v21);
  }
  return result;
}

void OUTLINED_FUNCTION_12_1(uint64_t a1@<X8>)
{
  uint64_t v1;

  *(_QWORD *)(v1 - 8) = a1;
}

uint64_t RSUtil_SetOptimizationModeForFECUnit(int a1, unsigned int a2)
{
  uint64_t v4;
  char v5;
  uint64_t v6;
  char v7;
  char v8;
  uint64_t v9;
  NSObject *v10;
  int v12;
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  unsigned int v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  uint64_t v26;

  v4 = 0;
  v5 = 0;
  v26 = *MEMORY[0x1E0C80C00];
  v6 = a2;
  _RSU_FECOptimizationMode[a2] = a1;
  v7 = 1;
  do
  {
    v8 = v7;
    v5 |= _RSU_FECOptimizationMode[v4] != 0;
    v4 = 1;
    v7 = 0;
  }
  while ((v8 & 1) != 0);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v9 = VRTraceErrorLogLevelToCSTR();
    v10 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v12 = 136316674;
      v13 = v9;
      v14 = 2080;
      v15 = "RSUtil_SetOptimizationModeForFECUnit";
      v16 = 1024;
      v17 = 83;
      v18 = 1024;
      v19 = a2;
      v20 = 1024;
      v21 = a1;
      v22 = 1024;
      v23 = v5 & 1;
      v24 = 1024;
      v25 = 1;
      _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Selected FEC Optimization: unit %d, finalFECMode: %d, RSOptimization: %d, interleaved SIMD load/store instr available: %d", (uint8_t *)&v12, 0x34u);
    }
  }
  _RSU_FECOptimizationMode[v6] = a1;
  return RS_SetOptimizationEnabled(v5 & 1);
}

uint64_t RSUtil_SetOptimizationMode(int a1)
{
  RSUtil_SetOptimizationModeForFECUnit(a1, 0);
  return RSUtil_SetOptimizationModeForFECUnit(a1, 1u);
}

uint64_t RSU_Encode(uint64_t a1, __int16 *a2, int a3, _QWORD *a4, _DWORD *a5, _DWORD *a6, int *a7, int *a8, _WORD *a9, char a10)
{
  _WORD *v18;
  int v19;
  __int128 v20;
  int v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  _QWORD *v25;
  _DWORD *v26;
  _OWORD *v27;
  __int16 *v28;
  _WORD *v29;
  __int16 v30;
  uint64_t v31;
  __int128 v32;
  _OWORD *v33;
  uint64_t v34;
  uint64_t i;
  uint64_t v36;
  int *v38;
  int *v39;
  _OWORD v40[3];
  unint64_t v41;
  _OWORD v42[14];
  _OWORD v43[4];
  _OWORD v44[2];
  _OWORD v45[16];
  _OWORD v46[2];
  _BYTE v47[28];
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  kdebug_trace();
  if (a3 >= 9)
  {
    v36 = 2150825985;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RSU_Encode_cold_1();
    }
  }
  else
  {
    v38 = a7;
    v39 = a8;
    v18 = a9;
    v19 = 8 / a3;
    *(_QWORD *)&v20 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&v47[12] = v20;
    v46[1] = v20;
    *(_OWORD *)v47 = v20;
    v21 = 8 % a3;
    v46[0] = v20;
    if (8 / a3 * a3 >= 1)
    {
      v22 = 0;
      do
      {
        *((_DWORD *)v46 + v21 + v22) = (int)v22 / v19;
        v23 = v21 + 1 + v22++;
      }
      while (v23 != 8);
    }
    if (!a9 || !a10)
      goto LABEL_15;
    memset(v45, 0, sizeof(v45));
    memset(v44, 0, sizeof(v44));
    memset(v43, 0, sizeof(v43));
    if (a3 >= 1)
    {
      v24 = a3;
      v25 = v43;
      v26 = v44;
      v27 = v45;
      v28 = a2;
      v29 = v45;
      do
      {
        v30 = *v28;
        v28 += 2;
        *v29 = v30;
        v29 += 16;
        *v26++ = 2;
        *v25++ = v27;
        v27 = v29;
        --v24;
      }
      while (v24);
    }
    v31 = 0;
    memset(v42, 0, sizeof(v42));
    v41 = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)&v32 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v32 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v40[1] = v32;
    v40[2] = v32;
    v33 = v42;
    v40[0] = v32;
    do
    {
      *(_QWORD *)((char *)v40 + v31) = v33;
      v31 += 8;
      v33 += 2;
    }
    while (v31 != 56);
    v34 = _RSU_EncodeByteBuffer((uint64_t)v43, v44, a3, v40, 0, 0, 8 / a3, v21, (uint64_t)v46);
    if (!(_DWORD)v34)
    {
      for (i = 0; i != 14; i += 2)
        *v18++ = v42[i];
LABEL_15:
      v36 = _RSU_EncodeByteBuffer(a1, a2, a3, a4, a5, a6, 8 / a3, v21, (uint64_t)v46);
      if ((_DWORD)v36)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            RSU_Encode_cold_2();
        }
      }
      else
      {
        *v38 = v19;
        *v39 = v21;
      }
      goto LABEL_17;
    }
    v36 = v34;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RSU_Encode_cold_3();
    }
  }
LABEL_17:
  kdebug_trace();
  return v36;
}

uint64_t _RSU_EncodeByteBuffer(uint64_t a1, _DWORD *a2, int a3, _QWORD *a4, _DWORD *a5, _DWORD *a6, int a7, int a8, uint64_t a9)
{
  _DWORD *v9;
  uint64_t v14;
  int *v15;
  uint64_t v16;
  int v17;
  int v18;
  int8x16_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  __int128 v29;
  uint64_t v30;
  __int128 v31;
  int v32;
  BOOL v33;
  char v34;
  int v35;
  uint64_t v36;
  int v37;
  uint64_t i;
  uint64_t v39;
  int8x16_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  char v47;
  char *v48;
  uint64_t v49;
  char v50;
  int8x16_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  char v56;
  uint64_t v57;
  int8x16_t v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  int v63;
  uint64_t v64;
  uint64_t v65;
  __int128 v66;
  uint64_t v67;
  uint64_t v68;
  char v69;
  uint64_t v70;
  char v71;
  const char *v72;
  __int8 *v73;
  __int8 *v74;
  int v75;
  uint64_t v76;
  uint64_t v77;
  char *v78;
  BOOL v79;
  int v80;
  uint64_t v81;
  int8x16_t v82;
  int v83;
  int v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  int v88;
  uint64_t v89;
  uint64_t v90;
  char v91;
  uint64_t v92;
  int v93;
  uint64_t v94;
  int v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  char v105;
  uint64_t j;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  int v110;
  uint64_t k;
  uint64_t v112;
  uint64_t v113;
  char v114;
  uint64_t m;
  uint64_t v116;
  NSObject *v117;
  _DWORD *v119;
  _DWORD *v121;
  int v122;
  int v123;
  int v124;
  int v125;
  int v126;
  __int128 v128;
  __int128 v129;
  __int128 v130;
  int8x16_t v131;
  int8x16_t v132;
  int8x16_t v133;
  int8x16_t v134;
  int8x16_t v135;
  int8x16_t v136;
  __int128 v137;
  int8x16_t v138;
  int8x16_t v139;
  int8x16_t v140;
  int8x16_t v141;
  int8x16_t v142;
  int8x16_t v143;
  int8x16_t v144;
  int8x16_t v145;
  int8x16_t v146;
  int8x16_t v147;
  int8x16_t v148;
  int8x16_t v149;
  int8x16_t v150;
  int8x16_t v151;
  int8x16_t v152;
  int8x16_t v153;
  _QWORD v154[2];
  uint8_t buf[4];
  uint64_t v156;
  __int16 v157;
  const char *v158;
  __int16 v159;
  int v160;
  __int16 v161;
  int v162;
  __int16 v163;
  int v164;
  __int16 v165;
  int v166;
  uint64_t v167;
  int8x16x2_t v168;
  int8x16x2_t v169;

  v9 = a6;
  v167 = *MEMORY[0x1E0C80C00];
  LODWORD(v14) = *a2;
  if (a3 >= 2)
  {
    v15 = a2 + 1;
    v16 = a3 - 1;
    do
    {
      v18 = *v15++;
      v17 = v18;
      if (v18 > (int)v14)
        LODWORD(v14) = v17;
      --v16;
    }
    while (v16);
  }
  switch(a7)
  {
    case 4:
      v14 = (v14 & 1) + v14;
      memset(v154, 0, 15);
      v40.i64[0] = 0xAAAAAAAAAAAAAAAALL;
      v40.i64[1] = 0xAAAAAAAAAAAAAAAALL;
      v152 = v40;
      v153 = v40;
      v150 = v40;
      v151 = v40;
      v148 = v40;
      v149 = v40;
      v146 = v40;
      v147 = v40;
      v144 = v40;
      v145 = v40;
      v142 = v40;
      v143 = v40;
      v140 = v40;
      v141 = v40;
      v139 = v40;
      if (_RSU_FECOptimizationMode[0] < 2u)
      {
        if ((int)v14 >= 1)
        {
          v41 = 0;
          do
          {
            v42 = v41 | 1;
            if (a8 <= 7)
            {
              v43 = a8;
              do
              {
                v44 = *(int *)(a9 + 4 * v43);
                v45 = (int)a2[v44];
                if (v41 >= v45)
                {
                  v47 = 0;
                  *((_BYTE *)v154 + v43) = 0;
                }
                else
                {
                  v46 = *(_QWORD *)(a1 + 8 * v44);
                  *((_BYTE *)v154 + v43) = *(_BYTE *)(v46 + v41) >> 4;
                  v47 = *(_BYTE *)(v46 + v41) & 0xF;
                }
                v48 = (char *)v154 + v43 + 3;
                *((_BYTE *)v154 + v43 + 1) = v47;
                if (v42 >= v45)
                {
                  v50 = 0;
                  *(v48 - 1) = 0;
                }
                else
                {
                  v49 = *(_QWORD *)(a1 + 8 * v44);
                  *(v48 - 1) = *(_BYTE *)(v49 + v42) >> 4;
                  v50 = *(_BYTE *)(v49 + v42) & 0xF;
                }
                *((_BYTE *)v154 + v43 + 3) = v50;
                v43 += 4;
              }
              while (v43 < 8);
            }
            RSEncode((unsigned __int8 *)v154, &v154[1], 7);
            *(_BYTE *)(*a4 + v41) = 16 * LOBYTE(v154[1]);
            *(_BYTE *)(*a4 + v41) |= BYTE1(v154[1]) & 0xF;
            *(_BYTE *)(*a4 + v42) = 16 * BYTE2(v154[1]);
            *(_BYTE *)(*a4 + v42) |= BYTE3(v154[1]) & 0xF;
            v41 += 2;
          }
          while ((int)v14 > (int)v41);
        }
        goto LABEL_105;
      }
      if (_RSU_FECOptimizationMode[0] != 2)
      {
LABEL_178:
        v20 = 2150825985;
LABEL_179:
        LODWORD(v101) = 1;
        v9 = a6;
        if (!a6)
          goto LABEL_181;
        goto LABEL_180;
      }
      if ((int)v14 < 1)
      {
LABEL_105:
        v20 = 0;
        goto LABEL_179;
      }
      v57 = 0;
      v125 = 4 * a3;
      v58.i64[0] = 0xF0F0F0F0F0F0F0FLL;
      v58.i64[1] = 0xF0F0F0F0F0F0F0FLL;
      while (1)
      {
        v59 = v57 + 32;
        if (a8 <= 7)
          break;
LABEL_95:
        v40 = RSEncodeSimd((uint64_t)&v139, v125, v40);
        if ((int)v14 >= v59)
        {
          v169.val[0] = vsliq_n_s8(v148, v147, 4uLL);
          v40 = v149;
          v169.val[1] = vsliq_n_s8(v150, v149, 4uLL);
          v78 = (char *)(*a4 + v57);
          vst2q_s8(v78, v169);
          v58.i64[0] = 0xF0F0F0F0F0F0F0FLL;
          v58.i64[1] = 0xF0F0F0F0F0F0F0FLL;
        }
        else
        {
          v75 = 0;
          v76 = 0;
          v58.i64[0] = 0xF0F0F0F0F0F0F0FLL;
          v58.i64[1] = 0xF0F0F0F0F0F0F0FLL;
          do
          {
            v77 = v57 + v76;
            if (v57 + v76 >= v14)
              break;
            v135 = v147;
            *(_BYTE *)(v77 + *a4) = 16 * *(_BYTE *)((unint64_t)&v135 | v75 & 0xF);
            v136 = v148;
            *(_BYTE *)(v77 + *a4) |= *(_BYTE *)((unint64_t)&v136 | v75 & 0xF) & 0xF;
            if (v77 + 1 >= v14)
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                v116 = VRTraceErrorLogLevelToCSTR();
                v117 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136316418;
                  v156 = v116;
                  v157 = 2080;
                  v158 = "_RSU_GatherToParityFourSymbols";
                  v159 = 1024;
                  v160 = 369;
                  v161 = 1024;
                  v162 = v14;
                  v163 = 1024;
                  v164 = v57;
                  v165 = 1024;
                  v166 = v75;
                  _os_log_error_impl(&dword_1D8A54000, v117, OS_LOG_TYPE_ERROR, " [%s] %s:%d Cannot fit all parity into packet. Size=%d, offset=%d, codewordIdx=%d", buf, 0x2Eu);
                }
              }
              goto LABEL_178;
            }
            v133 = v149;
            *(_BYTE *)(*a4 + v57 + v76 + 1) = 16 * *(_BYTE *)((unint64_t)&v133 | v75 & 0xF);
            v40 = v150;
            v134 = v150;
            *(_BYTE *)(*a4 + v57 + v76 + 1) |= *(_BYTE *)((unint64_t)&v134 | v75 & 0xF) & 0xF;
            v76 += 2;
            ++v75;
          }
          while (v76 != 32);
        }
        v57 += 32;
        v79 = (int)v14 <= v59;
        v20 = 0;
        if (v79)
          goto LABEL_179;
      }
      v60 = a8;
      while (1)
      {
        v61 = *(int *)(a9 + 4 * v60);
        v62 = (int)a2[v61];
        if (v57 >= v62)
          v63 = 2;
        else
          v63 = (int)v62 < v59;
        if (v63)
        {
          if (v63 != 2)
          {
            v64 = 0;
            v65 = v60 + 2;
            v40 = *(&v139 + v60 + 1);
            v66 = *((_OWORD *)&v139 + v60 + 3);
            v67 = v57;
            do
            {
              if (v67 >= v62)
              {
                v69 = 0;
                v139.i8[16 * v60 + v64] = 0;
              }
              else
              {
                v68 = *(_QWORD *)(a1 + 8 * v61);
                v139.i8[16 * v60 + v64] = *(_BYTE *)(v68 + v67) >> 4;
                v69 = *(_BYTE *)(v68 + v67) & 0xF;
              }
              v138 = v40;
              *(_BYTE *)((unint64_t)&v138 | v64 & 0xF) = v69;
              v40 = v138;
              *(&v139 + v60 + 1) = v138;
              if (v67 + 1 >= v62)
              {
                v71 = 0;
                v139.i8[16 * v65 + v64] = 0;
              }
              else
              {
                v70 = *(_QWORD *)(a1 + 8 * v61) + v67;
                v139.i8[16 * v65 + v64] = *(_BYTE *)(v70 + 1) >> 4;
                v71 = *(_BYTE *)(v70 + 1) & 0xF;
              }
              v137 = v66;
              *(_BYTE *)((unint64_t)&v137 | v64 & 0xF) = v71;
              v66 = v137;
              *((_OWORD *)&v139 + v60 + 3) = v137;
              ++v64;
              v67 += 2;
            }
            while (v64 != 16);
            goto LABEL_94;
          }
          v74 = &v139.i8[16 * v60];
          v40 = 0uLL;
          *(_OWORD *)v74 = 0u;
          *((_OWORD *)v74 + 1) = 0u;
          *((_OWORD *)v74 + 2) = 0u;
        }
        else
        {
          v72 = (const char *)(*(_QWORD *)(a1 + 8 * v61) + v57);
          v168 = vld2q_s8(v72);
          v73 = &v139.i8[16 * v60];
          *(uint8x16_t *)v73 = vshrq_n_u8((uint8x16_t)v168.val[0], 4uLL);
          *((int8x16_t *)v73 + 1) = vandq_s8(v168.val[0], v58);
          *((uint8x16_t *)v73 + 2) = vshrq_n_u8((uint8x16_t)v168.val[1], 4uLL);
          v40 = vandq_s8(v168.val[1], v58);
        }
        *(&v142 + v60) = v40;
LABEL_94:
        v60 += 4;
        if (v60 >= 8)
          goto LABEL_95;
      }
    case 2:
      memset(v154, 0, 15);
      v51.i64[0] = 0xAAAAAAAAAAAAAAAALL;
      v51.i64[1] = 0xAAAAAAAAAAAAAAAALL;
      v152 = v51;
      v153 = v51;
      v150 = v51;
      v151 = v51;
      v148 = v51;
      v149 = v51;
      v146 = v51;
      v147 = v51;
      v144 = v51;
      v145 = v51;
      v142 = v51;
      v143 = v51;
      v140 = v51;
      v141 = v51;
      v139 = v51;
      if (_RSU_FECOptimizationMode[0] < 2u)
      {
        if ((int)v14 >= 1)
        {
          v121 = a6;
          v52 = 0;
          do
          {
            if (a8 <= 7)
            {
              v53 = a8;
              do
              {
                v54 = *(int *)(a9 + 4 * v53);
                if (v52 >= (int)a2[v54])
                {
                  v56 = 0;
                  *((_BYTE *)v154 + v53) = 0;
                }
                else
                {
                  v55 = *(_QWORD *)(a1 + 8 * v54);
                  *((_BYTE *)v154 + v53) = *(_BYTE *)(v55 + v52) >> 4;
                  v56 = *(_BYTE *)(v55 + v52) & 0xF;
                }
                *((_BYTE *)v154 + v53 + 1) = v56;
                v53 += 2;
              }
              while (v53 < 8);
            }
            RSEncode((unsigned __int8 *)v154, &v154[1], 7);
            *(_BYTE *)(*a4 + v52) = 16 * LOBYTE(v154[1]);
            *(_BYTE *)(*a4 + v52) |= BYTE1(v154[1]) & 0xF;
            *(_BYTE *)(a4[1] + v52) = 16 * BYTE2(v154[1]);
            *(_BYTE *)(a4[1] + v52) |= BYTE3(v154[1]) & 0xF;
            *(_BYTE *)(a4[2] + v52) = 16 * BYTE4(v154[1]);
            *(_BYTE *)(a4[2] + v52++) |= BYTE5(v154[1]) & 0xF;
          }
          while (v52 != v14);
LABEL_68:
          v20 = 0;
          v9 = v121;
LABEL_140:
          LODWORD(v101) = 3;
          if (!v9)
            goto LABEL_181;
          goto LABEL_180;
        }
LABEL_139:
        v20 = 0;
        goto LABEL_140;
      }
      v20 = 2150825985;
      if (_RSU_FECOptimizationMode[0] != 2)
        goto LABEL_140;
      if ((int)v14 < 1)
        goto LABEL_139;
      v80 = 0;
      v81 = 0;
      v123 = 2 * a3;
      v121 = a6;
      v82.i64[0] = 0xF0F0F0F0F0F0F0FLL;
      v82.i64[1] = 0xF0F0F0F0F0F0F0FLL;
      while (1)
      {
        v83 = v81 + 16;
        v84 = (int)v14 <= (int)v81 ? v81 : v14;
        if (a8 <= 7)
          break;
LABEL_129:
        v93 = v84;
        v126 = v80;
        v51 = RSEncodeSimd((uint64_t)&v139, v123, v51);
        if ((int)v14 >= v83)
        {
          *(int8x16_t *)(*a4 + v81) = vshlq_n_s8(v147, 4uLL);
          v82.i64[0] = 0xF0F0F0F0F0F0F0FLL;
          v82.i64[1] = 0xF0F0F0F0F0F0F0FLL;
          *(int8x16_t *)(*a4 + v81) = vorrq_s8(*(int8x16_t *)(*a4 + v81), vandq_s8(v148, v82));
          *(int8x16_t *)(a4[1] + v81) = vshlq_n_s8(v149, 4uLL);
          *(int8x16_t *)(a4[1] + v81) = vorrq_s8(*(int8x16_t *)(a4[1] + v81), vandq_s8(v150, v82));
          *(int8x16_t *)(a4[2] + v81) = vshlq_n_s8(v151, 4uLL);
          v100 = a4[2];
          v51 = vorrq_s8(*(int8x16_t *)(v100 + v81), vandq_s8(v152, v82));
          *(int8x16_t *)(v100 + v81) = v51;
          v95 = v126;
        }
        else
        {
          v94 = 0;
          v95 = v126;
          v82.i64[0] = 0xF0F0F0F0F0F0F0FLL;
          v82.i64[1] = 0xF0F0F0F0F0F0F0FLL;
          do
          {
            v96 = 0;
            v97 = 2 * (int)v94;
            v98 = (int)v97 + 8;
            v99 = v97 + 9;
            do
            {
              if (v93 + v126 == v96)
                break;
              v130 = *((_OWORD *)&v139 + v98);
              *(_BYTE *)(a4[v94] + v81 + v96) = 16 * *(_BYTE *)((unint64_t)&v130 | v96 & 0xF);
              v51 = *(&v139 + v99);
              v131 = v51;
              *(_BYTE *)(a4[v94] + v81 + v96) |= *(_BYTE *)((unint64_t)&v131 | v96 & 0xF) & 0xF;
              ++v96;
            }
            while (v96 != 16);
            ++v94;
          }
          while (v94 != 3);
        }
        v80 = v95 - 16;
        v81 += 16;
        if ((int)v14 <= v83)
          goto LABEL_68;
      }
      v85 = a8;
      while (1)
      {
        v86 = *(int *)(a9 + 4 * v85);
        v87 = (int)a2[v86];
        if (v81 >= v87)
          v88 = 2;
        else
          v88 = (int)v87 < v83;
        if (v88)
        {
          if (v88 != 2)
          {
            v89 = 0;
            v51 = *(&v139 + v85 + 1);
            do
            {
              if (v81 + v89 >= v87)
              {
                v91 = 0;
                v139.i8[16 * v85 + v89] = 0;
              }
              else
              {
                v90 = *(_QWORD *)(a1 + 8 * v86) + v81;
                v139.i8[16 * v85 + v89] = *(_BYTE *)(v90 + v89) >> 4;
                v91 = *(_BYTE *)(v90 + v89) & 0xF;
              }
              v132 = v51;
              *(_BYTE *)((unint64_t)&v132 | v89 & 0xF) = v91;
              v51 = v132;
              *(&v139 + v85 + 1) = v132;
              ++v89;
            }
            while (v89 != 16);
            goto LABEL_128;
          }
          v51 = 0uLL;
          *((_OWORD *)&v139 + v85) = 0u;
        }
        else
        {
          v92 = *(_QWORD *)(a1 + 8 * v86);
          *((uint8x16_t *)&v139 + v85) = vshrq_n_u8(*(uint8x16_t *)(v92 + v81), 4uLL);
          v51 = vandq_s8(*(int8x16_t *)(v92 + v81), v82);
        }
        *(&v139 + v85 + 1) = v51;
LABEL_128:
        v85 += 2;
        if (v85 >= 8)
          goto LABEL_129;
      }
    case 1:
      memset(v154, 0, 15);
      v19.i64[0] = 0xAAAAAAAAAAAAAAAALL;
      v19.i64[1] = 0xAAAAAAAAAAAAAAAALL;
      v152 = v19;
      v153 = v19;
      v150 = v19;
      v151 = v19;
      v148 = v19;
      v149 = v19;
      v146 = v19;
      v147 = v19;
      v144 = v19;
      v145 = v19;
      v142 = v19;
      v143 = v19;
      v140 = v19;
      v141 = v19;
      v139 = v19;
      if (_RSU_FECOptimizationMode[0])
      {
        if (_RSU_FECOptimizationMode[0] != 1)
        {
          v20 = 2150825985;
          if (_RSU_FECOptimizationMode[0] != 2)
            goto LABEL_185;
          if ((int)v14 >= 1)
          {
            v21 = 0;
            v22 = 0;
            v119 = a6;
            v122 = a3;
            while (1)
            {
              v23 = (int)v14 <= (int)v22 ? v22 : v14;
              v24 = v22 + 16;
              if (a8 <= 7)
                break;
LABEL_33:
              v124 = v23;
              v35 = v21;
              RSEncodeSimd2Nibbles((uint64_t)&v139, a3);
              if ((int)v14 >= v24)
              {
                v39 = 0;
                a3 = v122;
                v37 = v35;
                do
                {
                  *(int8x16_t *)(a4[v39] + v22) = *(&v147 + v39);
                  ++v39;
                }
                while (v39 != 7);
              }
              else
              {
                v36 = 0;
                v37 = v35;
                a3 = v122;
                do
                {
                  for (i = 0; i != 16; ++i)
                  {
                    if (v124 + v35 == i)
                      break;
                    v128 = *((_OWORD *)&v139 + v36 + 8);
                    *(_BYTE *)(a4[v36] + v22 + i) = *(_BYTE *)((unint64_t)&v128 | i & 0xF);
                  }
                  ++v36;
                }
                while (v36 != 7);
              }
              v21 = v37 - 16;
              v22 += 16;
              if ((int)v14 <= v24)
                goto LABEL_173;
            }
            v25 = a8;
            while (1)
            {
              v26 = *(int *)(a9 + 4 * v25);
              v27 = (int)a2[v26];
              if (v22 >= v27)
                v28 = 2;
              else
                v28 = (int)v27 < v24;
              if (v28)
              {
                v29 = 0uLL;
                if (v28 != 2)
                {
                  v30 = 0;
                  v31 = *((_OWORD *)&v139 + v25);
                  v32 = v21 + v27;
                  do
                  {
                    v33 = __OFSUB__(v32--, 1);
                    if (v32 < 0 != v33)
                      v34 = 0;
                    else
                      v34 = *(_BYTE *)(*(_QWORD *)(a1 + 8 * v26) + (int)v22 + v30);
                    v129 = v31;
                    *(_BYTE *)((unint64_t)&v129 | v30 & 0xF) = v34;
                    v31 = v129;
                    *((_OWORD *)&v139 + v25) = v129;
                    ++v30;
                  }
                  while (v30 != 16);
                  goto LABEL_32;
                }
              }
              else
              {
                v29 = *(_OWORD *)(*(_QWORD *)(a1 + 8 * v26) + v22);
              }
              *((_OWORD *)&v139 + v25) = v29;
LABEL_32:
              if ((_DWORD)++v25 == 8)
                goto LABEL_33;
            }
          }
          goto LABEL_174;
        }
        if ((int)v14 >= 1)
        {
          v119 = a6;
          v102 = 0;
          do
          {
            if (a8 <= 7)
            {
              v103 = a8;
              do
              {
                v104 = *(int *)(a9 + 4 * v103);
                if (v102 >= (int)a2[v104])
                  v105 = 0;
                else
                  v105 = *(_BYTE *)(*(_QWORD *)(a1 + 8 * v104) + v102);
                *((_BYTE *)v154 + v103++) = v105;
              }
              while ((_DWORD)v103 != 8);
            }
            RSEncode2Nibbles((unsigned __int8 *)v154, (uint64_t)&v154[1], 7);
            for (j = 0; j != 7; ++j)
              *(_BYTE *)(a4[j] + v102) = *((_BYTE *)&v154[1] + j);
            ++v102;
          }
          while (v102 != v14);
LABEL_173:
          v20 = 0;
          v9 = v119;
          goto LABEL_185;
        }
      }
      else if ((int)v14 >= 1)
      {
        v119 = a6;
        v107 = 0;
        do
        {
          if (a8 <= 7)
          {
            v108 = a8;
            do
            {
              v109 = *(int *)(a9 + 4 * v108);
              if (v107 >= (int)a2[v109])
                LOBYTE(v110) = 0;
              else
                v110 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 8 * v109) + v107) >> 4;
              *((_BYTE *)v154 + v108++) = v110;
            }
            while ((_DWORD)v108 != 8);
          }
          RSEncode((unsigned __int8 *)v154, &v154[1], 7);
          for (k = 0; k != 7; ++k)
            *(_BYTE *)(a4[k] + v107) = 16 * *((_BYTE *)&v154[1] + k);
          if (a8 <= 7)
          {
            v112 = a8;
            do
            {
              v113 = *(int *)(a9 + 4 * v112);
              if (v107 >= (int)a2[v113])
                v114 = 0;
              else
                v114 = *(_BYTE *)(*(_QWORD *)(a1 + 8 * v113) + v107) & 0xF;
              *((_BYTE *)v154 + v112++) = v114;
            }
            while ((_DWORD)v112 != 8);
          }
          RSEncode((unsigned __int8 *)v154, &v154[1], 7);
          for (m = 0; m != 7; ++m)
            *(_BYTE *)(a4[m] + v107) |= *((_BYTE *)&v154[1] + m) & 0xF;
          ++v107;
        }
        while (v107 != v14);
        goto LABEL_173;
      }
LABEL_174:
      v20 = 0;
LABEL_185:
      LODWORD(v101) = 7;
      if (!v9)
      {
LABEL_181:
        if (a5)
        {
          v101 = v101;
          do
          {
            *a5++ = v14;
            --v101;
          }
          while (v101);
        }
        return v20;
      }
LABEL_180:
      *v9 = v101;
      goto LABEL_181;
  }
  v20 = 2150825985;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _RSU_EncodeByteBuffer_cold_1();
  }
  return v20;
}

uint64_t _RSU_DecodeByteBuffer(uint64_t a1, int *a2, int a3, int a4, int a5, int a6, uint64_t a7, uint64_t a8, unsigned __int8 *a9, uint64_t a10, int8x16_t *a11)
{
  uint64_t v13;
  int v17;
  uint64_t v18;
  int *v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  unsigned __int8 *v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  char v32;
  uint64_t v33;
  unsigned __int8 *v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t v37;
  NSObject *v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  char v45;
  BOOL v46;
  uint64_t j;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  char v55;
  uint64_t v56;
  uint64_t v57;
  char v58;
  uint64_t i;
  uint64_t v60;
  uint64_t v61;
  int v65;
  uint64_t v66;
  _BYTE buf[22];
  __int16 v68;
  int v69;
  __int16 v70;
  uint64_t v71;
  __int16 v72;
  int *v73;
  uint64_t v74;

  v74 = *MEMORY[0x1E0C80C00];
  v13 = 2150825985;
  if (a1 && a2)
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = 0;
    v17 = *a2;
    if (a5 >= 1)
    {
      v18 = a5;
      v19 = a2;
      do
      {
        v21 = *v19++;
        v20 = v21;
        if (v21 > v17)
          v17 = v20;
        --v18;
      }
      while (v18);
    }
    v65 = a6 / a3 * a3;
    switch(a3)
    {
      case 4:
        if (!a4)
        {
          if (v17 >= 1)
          {
            v48 = 0;
            do
            {
              v49 = 0;
              v50 = v48 | 1;
              do
              {
                v51 = *(int *)(a7 + 4 * v49);
                v52 = a2[v51];
                if (v48 >= v52)
                {
                  v55 = 0;
                  buf[v49 + 1] = 0;
                  v54 = v49;
                }
                else
                {
                  v53 = *(_QWORD *)(a1 + 8 * v51);
                  buf[v49] = a11->i8[v49] & (*(_BYTE *)(v53 + v48) >> 4);
                  v54 = v49 | 1;
                  v55 = *(_BYTE *)(v53 + v48) & a11->i8[v49 + 1] & 0xF;
                }
                buf[v54] = v55;
                if (v50 >= v52)
                {
                  v58 = 0;
                  buf[v49 + 3] = 0;
                  v57 = v49 | 2;
                }
                else
                {
                  v56 = *(_QWORD *)(a1 + 8 * v51);
                  buf[v49 + 2] = a11->i8[v49 + 2] & (*(_BYTE *)(v56 + v50) >> 4);
                  v57 = v49 + 3;
                  v58 = *(_BYTE *)(v56 + v50) & a11->i8[v49 + 3] & 0xF;
                }
                buf[v57] = v58;
                v46 = v49 >= 0xB;
                v49 += 4;
              }
              while (!v46);
              Decode((int8x16_t *)buf, a8, a6, a9, a10, a11);
              if (v65 >= 1)
              {
                for (i = 0; i < v65; i += 4)
                {
                  v60 = *(unsigned __int8 *)(a8 + i);
                  v61 = *(int *)(a7 + 4 * v60);
                  *(_BYTE *)(*(_QWORD *)(a1 + 8 * v61) + v48) = buf[*(unsigned __int8 *)(a8 + i + 1)] | (16 * buf[v60]);
                  *(_BYTE *)(*(_QWORD *)(a1 + 8 * v61) + v50) = buf[*(unsigned __int8 *)(a8 + i + 3)] | (16 * buf[*(unsigned __int8 *)(a8 + i + 2)]);
                }
              }
              v48 += 2;
            }
            while (v17 > (int)v48);
          }
          return 0;
        }
        break;
      case 2:
        if ((a4 & 0xFFFFFFFD) == 0)
        {
          if (v17 >= 1)
          {
            v39 = 0;
            v40 = a4;
            do
            {
              v41 = v40;
              do
              {
                v42 = *(int *)(a7 + 4 * v41);
                if (v39 >= a2[v42])
                {
                  v45 = 0;
                  buf[v41 + 1] = 0;
                  v44 = v41;
                }
                else
                {
                  v43 = *(_QWORD *)(a1 + 8 * v42);
                  buf[v41] = a11->i8[v41] & (*(_BYTE *)(v43 + v39) >> 4);
                  v44 = v41 + 1;
                  v45 = *(_BYTE *)(v43 + v39) & a11->i8[v41 + 1] & 0xF;
                }
                buf[v44] = v45;
                v46 = v41 >= 0xD;
                v41 += 2;
              }
              while (!v46);
              Decode((int8x16_t *)buf, a8, a6, a9, a10, a11);
              if (v65 >= 1)
              {
                for (j = 0; j < v65; j += 2)
                  *(_BYTE *)(*(_QWORD *)(a1 + 8 * *(int *)(a7 + 4 * *(unsigned __int8 *)(a8 + j))) + v39) = buf[*(unsigned __int8 *)(a8 + j + 1)] | (16 * buf[*(unsigned __int8 *)(a8 + j)]);
              }
              ++v39;
            }
            while (v39 != v17);
          }
          return 0;
        }
        break;
      case 1:
        if (a4 <= 3)
        {
          if (v17 >= 1)
          {
            v22 = 0;
            v23 = a4;
            v66 = a6;
            do
            {
              v24 = v23;
              do
              {
                v25 = *(int *)(a7 + 4 * v24);
                if (v22 >= a2[v25])
                  LOBYTE(v26) = 0;
                else
                  v26 = a11->u8[v24] & (*(unsigned __int8 *)(*(_QWORD *)(a1 + 8 * v25) + v22) >> 4);
                buf[v24++] = v26;
              }
              while ((_DWORD)v24 != 15);
              Decode((int8x16_t *)buf, a8, a6, a9, a10, a11);
              if (a6 >= 1)
              {
                v27 = v66;
                v28 = (unsigned __int8 *)a8;
                do
                {
                  v29 = *v28++;
                  *(_BYTE *)(*(_QWORD *)(a1 + 8 * *(int *)(a7 + 4 * v29)) + v22) = 16 * buf[v29];
                  --v27;
                }
                while (v27);
              }
              v30 = v23;
              do
              {
                v31 = *(int *)(a7 + 4 * v30);
                if (v22 >= a2[v31])
                  v32 = 0;
                else
                  v32 = *(_BYTE *)(*(_QWORD *)(a1 + 8 * v31) + v22) & a11->i8[v30] & 0xF;
                buf[v30++] = v32;
              }
              while ((_DWORD)v30 != 15);
              Decode((int8x16_t *)buf, a8, a6, a9, a10, a11);
              if (a6 >= 1)
              {
                v33 = v66;
                v34 = (unsigned __int8 *)a8;
                do
                {
                  v35 = *v34++;
                  v36 = *(_QWORD *)(a1 + 8 * *(int *)(a7 + 4 * v35));
                  *(_BYTE *)(v36 + v22) |= buf[v35];
                  --v33;
                }
                while (v33);
              }
              ++v22;
            }
            while (v22 != v17);
          }
          return 0;
        }
        break;
      default:
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _RSU_DecodeByteBuffer_cold_1();
        }
        break;
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v37 = VRTraceErrorLogLevelToCSTR();
    v38 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136316162;
      *(_QWORD *)&buf[4] = v37;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "_RSU_DecodeByteBuffer";
      v68 = 1024;
      v69 = 698;
      v70 = 2048;
      v71 = a1;
      v72 = 2048;
      v73 = a2;
      _os_log_error_impl(&dword_1D8A54000, v38, OS_LOG_TYPE_ERROR, " [%s] %s:%d Invalid input argument recoveryPacketBuffers[%p] recoveryPacketSizes[%p]", buf, 0x30u);
    }
  }
  return v13;
}

uint64_t RSU_Decode(uint64_t a1, int *a2, int *a3, int a4, int a5, int a6, uint64_t a7, int a8)
{
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _WORD *v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  unsigned __int16 *v34;
  int *v35;
  int v36;
  int v37;
  int v38;
  int v39;
  uint64_t v40;
  int *v41;
  int v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  int8x16_t v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  __int128 v53;
  __int128 v54;
  uint64_t v55;
  uint64_t v56;
  char v57;
  uint64_t v58;
  char v59;
  int8x16_t v60;
  const char *v61;
  BOOL v62;
  uint64_t v63;
  int v64;
  unint64_t v65;
  unint64_t v66;
  uint64_t v67;
  int v68;
  int v69;
  int v70;
  uint64_t i;
  uint64_t v72;
  uint64_t v73;
  char *v74;
  uint64_t v75;
  uint64_t v76;
  NSObject *v77;
  uint64_t v78;
  uint64_t v79;
  __int128 v80;
  int8x16_t v81;
  int v82;
  char v83;
  char v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  int v88;
  uint64_t v89;
  __int128 v90;
  unsigned int v91;
  int8x16_t v92;
  int8x16_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  unint64_t v97;
  uint64_t v98;
  int v99;
  int v100;
  uint64_t v101;
  int v102;
  uint64_t v103;
  char v104;
  uint64_t v105;
  char v106;
  int8x16_t v107;
  uint64_t v108;
  int8x16_t v109;
  int v111;
  uint64_t v112;
  int8x16_t v113;
  unint64_t v114;
  uint64_t v115;
  uint64_t v116;
  int v117;
  uint64_t v118;
  __int128 v119;
  uint64_t v120;
  int8x16_t v121;
  uint64_t v122;
  int v123;
  uint64_t v124;
  int v125;
  int v126;
  uint64_t v127;
  unint64_t v128;
  uint64_t v129;
  int v130;
  int v131;
  uint64_t v132;
  int v133;
  uint64_t v134;
  uint64_t v135;
  NSObject *v136;
  uint64_t v137;
  unint64_t v138;
  __int128 v139;
  __int128 v140;
  __int128 v141;
  __int128 v142;
  __int128 v143;
  __int128 v144;
  __int128 v145;
  __int128 v146;
  __int128 v147;
  __int128 v148;
  __int128 v149;
  __int128 v150;
  __int128 v151;
  __int128 v152;
  _DWORD v153[2];
  unsigned __int8 v154[8];
  _DWORD v155[16];
  _QWORD v156[2];
  _QWORD v157[2];
  uint64_t v158;
  uint64_t v159;
  int8x16_t v160;
  _OWORD v161[2];
  _OWORD v162[2];
  uint8_t buf[48];
  __int128 v164;
  __int128 v165;
  __int128 v166;
  __int128 v167;
  __int128 v168;
  __int128 v169;
  __int128 v170;
  __int128 v171;
  __int128 v172;
  __int128 v173;
  __int128 v174;
  __int128 v175;
  uint64_t v176;
  int8x16x2_t v177;
  int8x16x2_t v178;

  v176 = *MEMORY[0x1E0C80C00];
  kdebug_trace();
  *(_QWORD *)&v16 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)((char *)v162 + 12) = v16;
  v161[1] = v16;
  v162[0] = v16;
  v161[0] = v16;
  memset(v154, 170, 7);
  v17 = (7 % a5) ^ 0xFu;
  v160.i64[0] = -1;
  v160.i64[1] = -1;
  if (a6 <= 14)
  {
    v18 = 0;
    do
    {
      *((_DWORD *)v161 + a6 + v18) = (int)v18 / a5;
      v19 = a6 + 1 + v18++;
    }
    while (v19 != 15);
  }
  v20 = 0;
  v21 = v17 - a6;
  if ((int)v17 > a6)
  {
    v22 = a6;
    do
    {
      if (!a2[*((int *)v161 + v22)])
      {
        if (v20 >= 7)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              RSU_Decode_cold_2();
          }
          goto LABEL_100;
        }
        v154[v20++] = v22;
        v160.i8[v22] = 0;
      }
      ++v22;
      --v21;
    }
    while (v21);
  }
  if (7 % a5)
  {
    if (v20 <= 7)
      v23 = 7;
    else
      v23 = v20;
    if (v17 <= 0xE)
      v24 = 14;
    else
      v24 = (7 % a5) ^ 0xF;
    v25 = (v24 + 1);
    v26 = (char *)&v154[v20];
    v27 = v23 - v20;
    while (v27)
    {
      *v26++ = v17;
      v160.i8[v17++] = 0;
      ++v20;
      --v27;
      if (v25 == v17)
        goto LABEL_20;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RSU_Decode_cold_6();
    }
LABEL_100:
    v75 = 2150825985;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RSU_Decode_cold_1();
    }
    goto LABEL_159;
  }
LABEL_20:
  v159 = 0;
  RSCalculateGammaPoly(&v159, v20, (uint64_t)v154);
  *(_DWORD *)((char *)v153 + 3) = -1431655766;
  v153[0] = -1431655766;
  RSCalculateGammaDerEvalAtErasures((uint64_t)v153, (uint64_t)&v159, v20, (uint64_t)v154);
  v158 = 0;
  RSConvertToAlphaPow(&v158, (unsigned __int8 *)&v159, 7);
  if (a7 && a8)
  {
    v156[0] = 0;
    v156[1] = 0;
    *(_QWORD *)((char *)v157 + 6) = 0;
    v157[0] = 0;
    memset(v155, 0, 60);
    *(_QWORD *)&v168 = 0;
    v166 = 0u;
    v167 = 0u;
    v164 = 0u;
    v165 = 0u;
    v28 = (a4 - 7 / a5);
    memset(buf, 0, sizeof(buf));
    if (a4 >= 1)
    {
      v29 = 0;
      v30 = v156;
      v31 = a7 - 2 * (int)v28;
      while (v29 >= (int)v28)
      {
        v32 = *(unsigned __int16 *)(v31 + 2 * v29);
        if (*(_WORD *)(v31 + 2 * v29))
          goto LABEL_28;
LABEL_29:
        v155[v29] = v32;
        *(_QWORD *)&buf[8 * v29++] = v30++;
        if (a4 == v29)
          goto LABEL_30;
      }
      v32 = a2[v29];
      if (!v32)
        goto LABEL_29;
LABEL_28:
      *v30 = v32;
      v32 = 2;
      goto LABEL_29;
    }
LABEL_30:
    v33 = _RSU_DecodeByteBuffer((uint64_t)buf, v155, a5, a6, a4, v20, (uint64_t)v161, (uint64_t)v154, (unsigned __int8 *)&v158, (uint64_t)v153, &v160);
    if ((_DWORD)v33)
    {
      v75 = v33;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          RSU_Decode_cold_5();
      }
      goto LABEL_159;
    }
    if ((int)v28 >= 1)
    {
      v34 = (unsigned __int16 *)v156;
      v35 = a2;
      do
      {
        v37 = *v34++;
        v36 = v37;
        v38 = *a3++;
        if (v38 < v36)
        {
          v75 = 2150825985;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              RSU_Decode_cold_3();
          }
          goto LABEL_159;
        }
        *v35++ = v36;
        --v28;
      }
      while (v28);
    }
  }
  if (dword_1F01B6B44 != 2)
  {
    v75 = _RSU_DecodeByteBuffer(a1, a2, a5, a6, a4, v20, (uint64_t)v161, (uint64_t)v154, (unsigned __int8 *)&v158, (uint64_t)v153, &v160);
    goto LABEL_159;
  }
  if (!a1 || !a2)
  {
    v75 = 2150825985;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v76 = VRTraceErrorLogLevelToCSTR();
      v77 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)&buf[4] = v76;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_RSU_DecodeByteBufferSimd";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 1139;
        *(_WORD *)&buf[28] = 2048;
        *(_QWORD *)&buf[30] = a1;
        *(_WORD *)&buf[38] = 2048;
        *(_QWORD *)&buf[40] = a2;
        _os_log_error_impl(&dword_1D8A54000, v77, OS_LOG_TYPE_ERROR, " [%s] %s:%d Invalid input argument recoveryPacketBuffers[%p] recoveryPacketSizes[%p]", buf, 0x30u);
      }
    }
    goto LABEL_159;
  }
  v174 = 0u;
  v175 = 0u;
  v172 = 0u;
  v173 = 0u;
  v170 = 0u;
  v171 = 0u;
  v168 = 0u;
  v169 = 0u;
  v166 = 0u;
  v167 = 0u;
  v164 = 0u;
  v165 = 0u;
  memset(buf, 0, sizeof(buf));
  v39 = *a2;
  if (a4 >= 1)
  {
    v40 = a4;
    v41 = a2;
    do
    {
      v43 = *v41++;
      v42 = v43;
      if (v43 > v39)
        v39 = v42;
      --v40;
    }
    while (v40);
  }
  v44 = (v20 / a5 * a5);
  if (a5 == 1)
  {
    if (a6 > 3)
      goto LABEL_158;
    if (v39 < 1)
      goto LABEL_205;
    v78 = 0;
    v79 = 0;
    v137 = a6;
    v80 = 0uLL;
    v81.i64[0] = 0xF0F0F0F0F0F0F0FLL;
    v81.i64[1] = 0xF0F0F0F0F0F0F0FLL;
LABEL_106:
    v82 = v79 + 16;
    v83 = 1;
LABEL_107:
    v84 = v83;
    v85 = v137;
    while (1)
    {
      if (v160.i8[v85])
      {
        v86 = *((int *)v161 + v85);
        v87 = a2[v86];
        if (v79 >= v87)
          v88 = 2;
        else
          v88 = (int)v87 < v82;
        if (!v88)
        {
          v92 = *(int8x16_t *)(*(_QWORD *)(a1 + 8 * v86) + v79);
          if ((v84 & 1) != 0)
            v93 = (int8x16_t)vshrq_n_u8((uint8x16_t)v92, 4uLL);
          else
            v93 = vandq_s8(v92, v81);
          *(int8x16_t *)&buf[16 * v85] = v93;
          goto LABEL_127;
        }
        if (v88 != 2)
        {
          v89 = 0;
          v90 = *(_OWORD *)&buf[16 * v85];
          do
          {
            if (v79 + v89 >= v87)
            {
              v142 = v90;
              *(_BYTE *)((unint64_t)&v142 | v89 & 0xF) = 0;
              v90 = v142;
            }
            else
            {
              v91 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 8 * v86) + v79 + v89);
              if ((v84 & 1) != 0)
              {
                v140 = v90;
                *(_BYTE *)((unint64_t)&v140 | v89 & 0xF) = v91 >> 4;
                v90 = v140;
              }
              else
              {
                v141 = v90;
                *(_BYTE *)((unint64_t)&v141 | v89 & 0xF) = v91 & 0xF;
                v90 = v141;
              }
            }
            *(_OWORD *)&buf[16 * v85] = v90;
            ++v89;
          }
          while (v89 != 16);
          goto LABEL_127;
        }
      }
      *(_OWORD *)&buf[16 * v85] = v80;
LABEL_127:
      if ((_DWORD)++v85 == 15)
      {
        v94 = v44;
        v95 = v78;
        RSDecodeSimd((uint64_t)buf, (uint64_t)v154, v20, (unsigned __int8 *)&v158, (uint64_t)v153);
        v81.i64[0] = 0xF0F0F0F0F0F0F0FLL;
        v81.i64[1] = 0xF0F0F0F0F0F0F0FLL;
        v78 = v95;
        v44 = v94;
        if ((int)v94 >= 1)
        {
          v96 = 0;
          do
          {
            v97 = v154[v96];
            if (v97 <= 7)
            {
              v98 = *((int *)v161 + v97);
              if (a2[v98])
                v99 = a2[v98];
              else
                v99 = v39;
              if (v79 >= v99)
                v100 = 2;
              else
                v100 = v99 < v82;
              if (v100)
              {
                if (v100 != 2)
                {
                  v101 = 0;
                  if (v99 <= (int)v79)
                    v102 = v79;
                  else
                    v102 = v99;
                  v103 = (v78 + v102);
                  do
                  {
                    if (v103 == v101)
                      break;
                    v139 = *(_OWORD *)&buf[16 * v154[v96]];
                    v104 = *(_BYTE *)((unint64_t)&v139 | v101 & 0xF);
                    v105 = *(_QWORD *)(a1 + 8 * v98) + v79;
                    v106 = (v84 & 1) != 0 ? 16 * v104 : *(_BYTE *)(v105 + v101) | v104 & 0xF;
                    *(_BYTE *)(v105 + v101++) = v106;
                  }
                  while (v101 != 16);
                }
              }
              else
              {
                v107 = *(int8x16_t *)&buf[16 * v97];
                v108 = *(_QWORD *)(a1 + 8 * v98);
                if ((v84 & 1) != 0)
                  v109 = vshlq_n_s8(v107, 4uLL);
                else
                  v109 = vorrq_s8(*(int8x16_t *)(v108 + v79), vandq_s8(v107, v81));
                *(int8x16_t *)(v108 + v79) = v109;
              }
            }
            ++v96;
          }
          while (v96 != v44);
        }
        v83 = 0;
        v80 = 0uLL;
        if ((v84 & 1) == 0)
        {
          v75 = 0;
          v78 = (v78 - 16);
          v79 += 16;
          if (v39 <= v82)
            goto LABEL_159;
          goto LABEL_106;
        }
        goto LABEL_107;
      }
    }
  }
  if (a5 == 2)
  {
    if ((a6 & 0xFFFFFFFD) != 0)
      goto LABEL_158;
    if (v39 < 1)
      goto LABEL_205;
    v111 = 0;
    v112 = 0;
    v113.i64[0] = 0xF0F0F0F0F0F0F0FLL;
    v113.i64[1] = 0xF0F0F0F0F0F0F0FLL;
    v138 = a6;
LABEL_165:
    v114 = v138;
    while (1)
    {
      if (v160.i8[v114])
      {
        v115 = *((int *)v161 + v114);
        v116 = a2[v115];
        if (v112 >= v116)
          v117 = 2;
        else
          v117 = (int)v112 + 16 > (int)v116;
        if (!v117)
        {
          v122 = *(_QWORD *)(a1 + 8 * v115);
          *(uint8x16_t *)&buf[16 * v114] = vshrq_n_u8(*(uint8x16_t *)(v122 + v112), 4uLL);
          v121 = vandq_s8(*(int8x16_t *)(v122 + v112), v113);
          goto LABEL_180;
        }
        if (v117 != 2)
        {
          v118 = 0;
          v119 = *(_OWORD *)&buf[16 * v114 + 16];
          do
          {
            if (v112 + v118 >= v116)
            {
              buf[16 * v114 + v118] = 0;
              v146 = v119;
              *(_BYTE *)((unint64_t)&v146 | v118 & 0xF) = 0;
              v119 = v146;
            }
            else
            {
              v120 = *(_QWORD *)(a1 + 8 * v115) + v112;
              buf[16 * v114 + v118] = *(_BYTE *)(v120 + v118) >> 4;
              LOBYTE(v120) = *(_BYTE *)(v120 + v118) & 0xF;
              v145 = v119;
              *(_BYTE *)((unint64_t)&v145 | v118 & 0xF) = v120;
              v119 = v145;
            }
            *(_OWORD *)&buf[16 * v114 + 16] = v119;
            ++v118;
          }
          while (v118 != 16);
          goto LABEL_181;
        }
      }
      v121 = 0uLL;
      *(_OWORD *)&buf[16 * v114] = 0u;
LABEL_180:
      *(int8x16_t *)&buf[16 * v114 + 16] = v121;
LABEL_181:
      v62 = v114 >= 0xC;
      v114 += 2;
      if (v62)
      {
        v123 = v111;
        v124 = v44;
        RSDecodeSimd((uint64_t)buf, (uint64_t)v154, v20, (unsigned __int8 *)&v158, (uint64_t)v153);
        v113.i64[0] = 0xF0F0F0F0F0F0F0FLL;
        v113.i64[1] = 0xF0F0F0F0F0F0F0FLL;
        v125 = v123;
        v44 = v124;
        v126 = v112 + 16;
        if ((int)v124 >= 1)
        {
          v127 = 0;
          do
          {
            v128 = v154[v127];
            if (v128 <= 7)
            {
              v129 = *((int *)v161 + v128);
              if (a2[v129])
                v130 = a2[v129];
              else
                v130 = v39;
              if (v112 >= v130)
                v131 = 2;
              else
                v131 = v130 < v126;
              if (v131)
              {
                if (v131 != 2)
                {
                  v132 = 0;
                  if (v130 <= (int)v112)
                    v133 = v112;
                  else
                    v133 = v130;
                  v134 = (v125 + v133);
                  do
                  {
                    if (v134 == v132)
                      break;
                    v143 = *(_OWORD *)&buf[16 * v154[v127]];
                    *(_BYTE *)(*(_QWORD *)(a1 + 8 * v129) + v112 + v132) = 16
                                                                         * *(_BYTE *)((unint64_t)&v143 | v132 & 0xF);
                    v144 = *(_OWORD *)&buf[16 * v154[v127 | 1]];
                    *(_BYTE *)(*(_QWORD *)(a1 + 8 * v129) + v112 + v132) |= *(_BYTE *)((unint64_t)&v144 | v132 & 0xF) & 0xF;
                    ++v132;
                  }
                  while (v132 != 16);
                }
              }
              else
              {
                *(int8x16_t *)(*(_QWORD *)(a1 + 8 * v129) + v112) = vshlq_n_s8(*(int8x16_t *)&buf[16 * v128], 4uLL);
                *(int8x16_t *)(*(_QWORD *)(a1 + 8 * v129) + v112) = vorrq_s8(*(int8x16_t *)(*(_QWORD *)(a1 + 8 * v129) + v112), vandq_s8(*(int8x16_t *)&buf[16 * v154[v127 | 1]], v113));
              }
            }
            v127 += 2;
          }
          while ((int)v44 > (int)v127);
        }
        v75 = 0;
        v111 = v125 - 16;
        v112 += 16;
        if (v39 <= v126)
          goto LABEL_159;
        goto LABEL_165;
      }
    }
  }
  if (a5 != 4)
  {
    v75 = 2150825985;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RSU_Decode_cold_4();
    }
    goto LABEL_159;
  }
  if (a6)
  {
LABEL_158:
    v75 = 2150825985;
    goto LABEL_159;
  }
  if (v39 < 1)
  {
LABEL_205:
    v75 = 0;
    goto LABEL_159;
  }
  v45 = 0;
  v46.i64[0] = 0xF0F0F0F0F0F0F0FLL;
  v46.i64[1] = 0xF0F0F0F0F0F0F0FLL;
  do
  {
    v47 = 0;
    do
    {
      if (!v160.i8[v47 * 4])
      {
LABEL_65:
        v60 = 0uLL;
        *(_OWORD *)&buf[4 * v47] = 0u;
        *(_OWORD *)&buf[(4 * v47) | 0x10] = 0u;
        *(_OWORD *)&buf[(4 * v47) | 0x20] = 0u;
LABEL_67:
        *(int8x16_t *)&buf[(4 * v47) | 0x30] = v60;
        goto LABEL_68;
      }
      v48 = SLODWORD(v161[v47]);
      v49 = a2[v48];
      if (v45 >= v49)
        v50 = 2;
      else
        v50 = (int)v45 + 32 > (int)v49;
      if (!v50)
      {
        v61 = (const char *)(*(_QWORD *)(a1 + 8 * v48) + v45);
        v177 = vld2q_s8(v61);
        *(uint8x16_t *)&buf[4 * v47] = vshrq_n_u8((uint8x16_t)v177.val[0], 4uLL);
        *(int8x16_t *)&buf[(4 * v47) | 0x10] = vandq_s8(v177.val[0], v46);
        *(uint8x16_t *)&buf[(4 * v47) | 0x20] = vshrq_n_u8((uint8x16_t)v177.val[1], 4uLL);
        v60 = vandq_s8(v177.val[1], v46);
        goto LABEL_67;
      }
      if (v50 == 2)
        goto LABEL_65;
      v51 = 0;
      v52 = (v47 * 4) | 2;
      v53 = *(_OWORD *)&buf[16 * ((v47 * 4) | 1)];
      v54 = *(_OWORD *)&buf[16 * ((v47 * 4) | 3)];
      v55 = v45;
      do
      {
        if (v55 >= v49)
        {
          v57 = 0;
          buf[4 * v47 + v51] = 0;
        }
        else
        {
          v56 = *(_QWORD *)(a1 + 8 * v48);
          buf[4 * v47 + v51] = *(_BYTE *)(v56 + v55) >> 4;
          v57 = *(_BYTE *)(v56 + v55) & 0xF;
        }
        v152 = v53;
        *(_BYTE *)((unint64_t)&v152 | v51 & 0xF) = v57;
        v53 = v152;
        *(_OWORD *)&buf[16 * ((v47 * 4) | 1)] = v152;
        if (v55 + 1 >= v49)
        {
          v59 = 0;
          buf[16 * v52 + v51] = 0;
        }
        else
        {
          v58 = *(_QWORD *)(a1 + 8 * v48) + v55;
          buf[16 * v52 + v51] = *(_BYTE *)(v58 + 1) >> 4;
          v59 = *(_BYTE *)(v58 + 1) & 0xF;
        }
        v151 = v54;
        *(_BYTE *)((unint64_t)&v151 | v51 & 0xF) = v59;
        v54 = v151;
        *(_OWORD *)&buf[16 * ((v47 * 4) | 3)] = v151;
        ++v51;
        v55 += 2;
      }
      while (v51 != 16);
LABEL_68:
      v62 = v47++ >= 2;
    }
    while (!v62);
    v63 = v44;
    RSDecodeSimd((uint64_t)buf, (uint64_t)v154, v20, (unsigned __int8 *)&v158, (uint64_t)v153);
    v46.i64[0] = 0xF0F0F0F0F0F0F0FLL;
    v46.i64[1] = 0xF0F0F0F0F0F0F0FLL;
    v44 = v63;
    v64 = v45 + 32;
    if ((int)v63 >= 1)
    {
      v65 = 0;
      do
      {
        v66 = v154[v65];
        if (v66 <= 7)
        {
          v67 = *((int *)v161 + v66);
          if (a2[v67])
            v68 = a2[v67];
          else
            v68 = v39;
          if (v45 >= v68)
            v69 = 2;
          else
            v69 = v68 < v64;
          if (v69)
          {
            if (v69 != 2)
            {
              v70 = 0;
              for (i = 0; i != 32; i += 2)
              {
                v72 = v45 + i;
                if (v45 + i >= v68)
                  break;
                v149 = *(_OWORD *)&buf[16 * v154[v65]];
                *(_BYTE *)(v72 + *(_QWORD *)(a1 + 8 * v67)) = 16 * *(_BYTE *)((unint64_t)&v149 | v70 & 0xF);
                v150 = *(_OWORD *)&buf[16 * v154[v65 | 1]];
                *(_BYTE *)(v72 + *(_QWORD *)(a1 + 8 * v67)) |= *(_BYTE *)((unint64_t)&v150 | v70 & 0xF) & 0xF;
                if (v72 + 1 >= v68)
                {
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                  {
                    v135 = VRTraceErrorLogLevelToCSTR();
                    v136 = *MEMORY[0x1E0CF2758];
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                    {
                      v155[0] = 136316418;
                      *(_QWORD *)&v155[1] = v135;
                      LOWORD(v155[3]) = 2080;
                      *(_QWORD *)((char *)&v155[3] + 2) = "_RSU_GatherDecodedDataFourSymbols";
                      HIWORD(v155[5]) = 1024;
                      v155[6] = 1088;
                      LOWORD(v155[7]) = 1024;
                      *(_DWORD *)((char *)&v155[7] + 2) = v68;
                      HIWORD(v155[8]) = 1024;
                      v155[9] = v45 + i + 1;
                      LOWORD(v155[10]) = 1024;
                      *(_DWORD *)((char *)&v155[10] + 2) = v70;
                      _os_log_error_impl(&dword_1D8A54000, v136, OS_LOG_TYPE_ERROR, " [%s] %s:%d Cannot gather all parity from packet. Size=%d, offset=%d, codewordIdx=%d", (uint8_t *)v155, 0x2Eu);
                    }
                  }
                  goto LABEL_158;
                }
                v147 = *(_OWORD *)&buf[16 * v154[v65 | 2]];
                *(_BYTE *)(*(_QWORD *)(a1 + 8 * v67) + v45 + i + 1) = 16
                                                                    * *(_BYTE *)((unint64_t)&v147 | v70 & 0xF);
                v148 = *(_OWORD *)&buf[16 * v154[v65 | 3]];
                v73 = *(_QWORD *)(a1 + 8 * v67) + v45 + i;
                *(_BYTE *)(v73 + 1) |= *(_BYTE *)((unint64_t)&v148 | v70++ & 0xF) & 0xF;
              }
            }
          }
          else
          {
            v178.val[0] = vsliq_n_s8(*(int8x16_t *)&buf[16 * v154[v65 | 1]], *(int8x16_t *)&buf[16 * v66], 4uLL);
            v178.val[1] = vsliq_n_s8(*(int8x16_t *)&buf[16 * v154[v65 | 3]], *(int8x16_t *)&buf[16 * v154[v65 | 2]], 4uLL);
            v74 = (char *)(*(_QWORD *)(a1 + 8 * v67) + v45);
            vst2q_s8(v74, v178);
          }
        }
        v65 += 4;
      }
      while ((int)v44 > (int)v65);
    }
    v75 = 0;
    v45 += 32;
  }
  while (v39 > v64);
LABEL_159:
  kdebug_trace();
  return v75;
}

uint64_t RSU_GetPacketLayout(uint64_t result, int a2, int *a3, int *a4)
{
  *a3 = (8 - a2) / (int)result;
  *a4 = 7 / (int)result;
  return result;
}

BOOL RSU_IsRecoverable(int a1)
{
  return a1 < 8;
}

uint64_t EncCreateHandle(uint64_t *a1, _DWORD *a2)
{
  uint64_t v3;
  char *v5;
  char *v6;
  int v7;
  int v8;
  uint64_t v9;
  NSObject *v10;
  int v11;
  int v12;
  const char *v13;
  int v14;
  int v15;
  __int128 v16;
  tm *v17;
  FILE *v18;
  FILE *v19;
  size_t v20;
  int v21;
  const __CFDictionary *v22;
  uint64_t v23;
  unsigned int v24;
  int v25;
  int32x2_t v26;
  int64x2_t v27;
  int v28;
  int v29;
  __CFDictionary *Mutable;
  int v31;
  const void **v32;
  int ErrorLogLevelForModule;
  const void **v34;
  uint64_t v35;
  NSObject *v36;
  _BOOL4 v37;
  const void *v38;
  const void *v39;
  uint64_t v40;
  NSObject *v41;
  int v42;
  CFNumberRef v43;
  const void *v44;
  int v45;
  int v46;
  int v47;
  __CFDictionary *v48;
  CFNumberRef v49;
  CFNumberRef v50;
  CFNumberRef v51;
  CFTypeRef *v52;
  __int16 v53;
  int v54;
  uint64_t v55;
  NSObject *v56;
  char *v57;
  char *v58;
  uint64_t v59;
  CFNumberRef v60;
  int v61;
  uint64_t v62;
  NSObject *v63;
  int v64;
  int v65;
  CFNumberRef v66;
  uint64_t v67;
  NSObject *v68;
  CFTypeRef v69;
  uint64_t v70;
  CFStringRef v71;
  CFNumberRef v72;
  CFNumberRef v73;
  CFNumberRef v74;
  CFNumberRef v75;
  CFNumberRef v76;
  __CFDictionary *v77;
  CFNumberRef v78;
  int v79;
  int v80;
  uint64_t v81;
  NSObject *v82;
  int v83;
  int v84;
  int v85;
  uint64_t v86;
  NSObject *v87;
  CFNumberRef v88;
  CFNumberRef v89;
  uint64_t v90;
  NSObject *v91;
  uint64_t v92;
  NSObject *v93;
  __CFArray *v94;
  unint64_t v95;
  char *v96;
  CFNumberRef v97;
  __CFArray *v98;
  CFNumberRef v99;
  CFNumberRef v100;
  CFNumberRef v101;
  CFNumberRef v102;
  uint64_t v103;
  NSObject *v104;
  int v105;
  uint64_t Handle;
  const void *v107;
  char *v109;
  uint64_t v110;
  int v111;
  int v112;
  uint64_t v113;
  int v114;
  const __CFAllocator *allocator;
  uint64_t *v116;
  __CFDictionary *cf;
  time_t v118;
  int __ptr;
  _BYTE __str[96];
  __int128 v121;
  __int128 v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  __int128 v126;
  __int128 v127;
  __int128 v128;
  __int128 v129;
  __int128 v130;
  char valuePtr[24];
  uint64_t v132;

  v132 = *MEMORY[0x1E0C80C00];
  v3 = 2148007937;
  if (*a2 && a2[1])
  {
    v5 = (char *)malloc_type_calloc(1uLL, 0x188uLL, 0x10E00402095C4D0uLL);
    if (v5)
    {
      v6 = v5;
      *(_QWORD *)v5 = *((_QWORD *)a2 + 12);
      *((_QWORD *)v5 + 1) = *((_QWORD *)a2 + 14);
      *((_DWORD *)v5 + 62) = a2[30];
      if (!*((_DWORD *)v5 + 4))
      {
        if (a2[16])
          v7 = 1;
        else
          v7 = 2;
        *((_DWORD *)v5 + 4) = v7;
      }
      v8 = a2[31];
      if ((v8 - 10) <= 0xFFFFFFF6)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            EncCreateHandle_cold_2();
        }
LABEL_115:
        free(v6);
        return v3;
      }
      v116 = a1;
      *((_DWORD *)v5 + 94) = v8;
      *((_DWORD *)v5 + 96) = a2[50];
      v11 = *((unsigned __int8 *)a2 + 84);
      v12 = a2[20];
      if (*((_BYTE *)a2 + 84) || (v12 - 1) <= 1)
      {
        v13 = (const char *)*((_QWORD *)a2 + 7);
        v14 = *a2;
        v15 = a2[1];
        memset(valuePtr, 170, 20);
        *(_QWORD *)&v16 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v129 = v16;
        v130 = v16;
        v127 = v16;
        v128 = v16;
        v125 = v16;
        v126 = v16;
        v123 = v16;
        v124 = v16;
        v121 = v16;
        v122 = v16;
        *(_OWORD *)&__str[64] = v16;
        *(_OWORD *)&__str[80] = v16;
        *(_OWORD *)&__str[32] = v16;
        *(_OWORD *)&__str[48] = v16;
        *(_OWORD *)__str = v16;
        *(_OWORD *)&__str[16] = v16;
        v118 = 0xAAAAAAAAAAAAAAAALL;
        setlocale(0, "");
        time(&v118);
        v17 = localtime(&v118);
        strftime(valuePtr, 0x14uLL, "%m%d%g_%H%M%S", v17);
        *((_DWORD *)v6 + 11) = v12;
        VCDiskUtils_CreateDirectory();
        if (v12 == 1)
        {
          snprintf(__str, 0x100uLL, "%s%s-txSourceYuv.%dx%d.%s.yuv", "/tmp/vcp/", valuePtr, v14, v15, "420v");
          v18 = fopen(__str, "wb");
          *((_QWORD *)v6 + 43) = 0;
          *((_QWORD *)v6 + 44) = 0;
          *((_QWORD *)v6 + 42) = v18;
        }
        if (v11)
        {
          snprintf(__str, 0x100uLL, "%s%s-txBitstream.26l", "/tmp/vcp/", valuePtr);
          v19 = fopen(__str, "wb");
          *((_QWORD *)v6 + 45) = v19;
          __ptr = 50331648;
          fwrite(&__ptr, 1uLL, 4uLL, v19);
          if (v13)
          {
            v20 = strlen(v13);
            fwrite(v13, 1uLL, v20 + 1, *((FILE **)v6 + 45));
          }
        }
      }
      *((_QWORD *)v6 + 14) = 0xC024000000000000;
      pthread_mutex_init((pthread_mutex_t *)(v6 + 120), 0);
      pthread_mutex_init((pthread_mutex_t *)(v6 + 184), 0);
      *((_DWORD *)v6 + 82) = 0;
      v21 = a2[10];
      *((_DWORD *)v6 + 8) = v21;
      *((_DWORD *)v6 + 9) = v21;
      *((_DWORD *)v6 + 10) = 1;
      v22 = (const __CFDictionary *)*((_QWORD *)a2 + 6);
      if (v22)
      {
        *((_QWORD *)v6 + 32) = CFDictionaryGetValue(v22, (const void *)*MEMORY[0x1E0CECF48]);
        *((_QWORD *)v6 + 33) = CFDictionaryGetValue(*((CFDictionaryRef *)a2 + 6), (const void *)*MEMORY[0x1E0CED238]);
        *((_QWORD *)v6 + 34) = CFDictionaryGetValue(*((CFDictionaryRef *)a2 + 6), (const void *)*MEMORY[0x1E0CED290]);
      }
      v23 = MEMORY[0x1E0CA2E68];
      *(_OWORD *)(v6 + 280) = *MEMORY[0x1E0CA2E68];
      *((_QWORD *)v6 + 37) = *(_QWORD *)(v23 + 16);
      *((_DWORD *)v6 + 92) = 1;
      v24 = a2[3];
      *((_QWORD *)v6 + 6) = v24;
      v25 = *a2;
      *((_WORD *)v6 + 29) = *a2;
      *((_WORD *)v6 + 28) = a2[1];
      if (v24 == 1752589105 || v24 == 1635148593)
      {
        v26 = vdup_n_s32(v25 == 176);
        v27.i64[0] = v26.u32[0];
        v27.i64[1] = v26.u32[1];
        *((int8x16_t *)a2 + 1) = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v27, 0x3FuLL)), (int8x16_t)vdupq_n_s64(0x2BCuLL), (int8x16_t)xmmword_1D910AD10);
      }
      v28 = a2[8];
      *((_DWORD *)v6 + 15) = v28;
      *((_WORD *)v6 + 126) = 2 * (v28 < 2200001);
      *((_DWORD *)v6 + 16) = 0;
      v29 = a2[9];
      if (v29)
        v29 = 1000 / v29;
      *((_DWORD *)v6 + 18) = 0x7FFFFFFF;
      *((_DWORD *)v6 + 17) = v29;
      *(int32x2_t *)(v6 + 76) = vmovn_s64(*((int64x2_t *)a2 + 1));
      allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      v31 = VCFeatureFlagManager_UseAvconferencedOniOSSpecficFeatures();
      v32 = (const void **)MEMORY[0x1E0C9AE50];
      if (v31)
      {
        ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
        v34 = (const void **)MEMORY[0x1E0CED2B0];
        if (ErrorLogLevelForModule <= 6)
        {
          v38 = (const void *)*MEMORY[0x1E0CED2B0];
        }
        else
        {
          v35 = VRTraceErrorLogLevelToCSTR();
          v36 = *MEMORY[0x1E0CF2758];
          v37 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
          v38 = *v34;
          if (v37)
          {
            *(_DWORD *)__str = 136315906;
            *(_QWORD *)&__str[4] = v35;
            *(_WORD *)&__str[12] = 2080;
            *(_QWORD *)&__str[14] = "VCVideoEncoder_SetEncoderSpecification";
            *(_WORD *)&__str[22] = 1024;
            *(_DWORD *)&__str[24] = 354;
            *(_WORD *)&__str[28] = 2112;
            *(_QWORD *)&__str[30] = v38;
            _os_log_impl(&dword_1D8A54000, v36, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Adding kVTCompressionSessionOption_AllowClientProcessEncode=%@ to encoderSpecification", __str, 0x26u);
          }
        }
        CFDictionaryAddValue(Mutable, v38, *v32);
      }
      else
      {
        v39 = (const void *)VCAudioSessionCMS_SessionReference();
        if (v39)
          CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CEDD18], v39);
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v40 = VRTraceErrorLogLevelToCSTR();
        v41 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v42 = a2[18];
          *(_DWORD *)__str = 136316162;
          *(_QWORD *)&__str[4] = v40;
          *(_WORD *)&__str[12] = 2080;
          *(_QWORD *)&__str[14] = "VCVideoEncoder_SetEncoderSpecification";
          *(_WORD *)&__str[22] = 1024;
          *(_DWORD *)&__str[24] = 363;
          *(_WORD *)&__str[28] = 1024;
          *(_DWORD *)&__str[30] = 363;
          *(_WORD *)&__str[34] = 1024;
          *(_DWORD *)&__str[36] = v42;
          _os_log_impl(&dword_1D8A54000, v41, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/VCVideoEncoder_VCP.c:%d: HandoverReport: fUsingCellular=%d", __str, 0x28u);
        }
      }
      v43 = CFNumberCreate(0, kCFNumberIntType, a2 + 18);
      CFDictionaryAddValue(Mutable, CFSTR("UsingCellular"), v43);
      CFRelease(v43);
      CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CED1A0], *v32);
      FigCFDictionarySetInt64();
      FigCFDictionarySetInt64();
      v44 = (const void *)*((_QWORD *)a2 + 17);
      if (v44)
        CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CED180], v44);
      v45 = *((__int16 *)v6 + 29);
      v46 = *((__int16 *)v6 + 28);
      v47 = a2[32];
      v48 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      *(_DWORD *)__str = v45;
      v49 = CFNumberCreate(0, kCFNumberIntType, __str);
      CFDictionaryAddValue(v48, (const void *)*MEMORY[0x1E0CA90E0], v49);
      CFRelease(v49);
      *(_DWORD *)__str = v46;
      v50 = CFNumberCreate(0, kCFNumberIntType, __str);
      CFDictionaryAddValue(v48, (const void *)*MEMORY[0x1E0CA8FD8], v50);
      CFRelease(v50);
      *(_DWORD *)__str = v47;
      v51 = CFNumberCreate(0, kCFNumberIntType, __str);
      CFDictionaryAddValue(v48, (const void *)*MEMORY[0x1E0CA9040], v51);
      CFRelease(v51);
      v52 = (CFTypeRef *)(v6 + 304);
      cf = v48;
      v53 = VCPCompressionSessionCreate();
      v54 = VRTraceGetErrorLogLevelForModule();
      if (v53)
      {
        if (v54 >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            EncCreateHandle_cold_3();
        }
        v3 = -v53 | 0xA0080000;
      }
      else
      {
        if (v54 >= 7)
        {
          v55 = VRTraceErrorLogLevelToCSTR();
          v56 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v113 = *((_QWORD *)v6 + 38);
            v114 = a2[31];
            v57 = FourccToCStr(a2[32]);
            v111 = *a2;
            v112 = a2[1];
            v58 = FourccToCStr(*((_DWORD *)v6 + 12));
            v59 = *((_QWORD *)a2 + 14);
            *(_DWORD *)__str = 136317698;
            *(_QWORD *)&__str[4] = v55;
            *(_WORD *)&__str[12] = 2080;
            *(_QWORD *)&__str[14] = "EncCreateHandle";
            *(_WORD *)&__str[22] = 1024;
            *(_DWORD *)&__str[24] = 680;
            *(_WORD *)&__str[28] = 1024;
            *(_DWORD *)&__str[30] = 680;
            *(_WORD *)&__str[34] = 2048;
            *(_QWORD *)&__str[36] = v113;
            *(_WORD *)&__str[44] = 1024;
            *(_DWORD *)&__str[46] = v114;
            *(_WORD *)&__str[50] = 2080;
            *(_QWORD *)&__str[52] = v57;
            *(_WORD *)&__str[60] = 1024;
            *(_DWORD *)&__str[62] = v111;
            *(_WORD *)&__str[66] = 1024;
            *(_DWORD *)&__str[68] = v112;
            *(_WORD *)&__str[72] = 2080;
            *(_QWORD *)&__str[74] = v58;
            *(_WORD *)&__str[82] = 1024;
            *(_DWORD *)&__str[84] = v59;
            _os_log_impl(&dword_1D8A54000, v56, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/VCVideoEncoder_VCP.c:%d: Created encoder session=%p with tilesPerframe=%d, pixelFormat=%s, width=%d, height=%d codec=%s videoTransmitterHandle=0x%x", __str, 0x58u);
          }
        }
        v60 = CFNumberCreate(0, kCFNumberIntType, a2 + 22);
        VCPCompressionSessionSetProperty();
        CFRelease(v60);
        if (a2[32] == 2016686640)
          VCPCompressionSessionSetProperty();
        if (*((_QWORD *)v6 + 32))
          VCPCompressionSessionSetProperty();
        if (*((_QWORD *)v6 + 33))
          VCPCompressionSessionSetProperty();
        if (*((_QWORD *)v6 + 34))
          VCPCompressionSessionSetProperty();
        v61 = *((_DWORD *)v6 + 62);
        *(_DWORD *)valuePtr = v61;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v62 = VRTraceErrorLogLevelToCSTR();
          v63 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v64 = *a2;
            v65 = a2[1];
            *(_DWORD *)__str = 136316418;
            *(_QWORD *)&__str[4] = v62;
            *(_WORD *)&__str[12] = 2080;
            *(_QWORD *)&__str[14] = "_Enc_SetCompressionSessionProperties";
            *(_WORD *)&__str[22] = 1024;
            *(_DWORD *)&__str[24] = 462;
            *(_WORD *)&__str[28] = 1024;
            *(_DWORD *)&__str[30] = v64;
            *(_WORD *)&__str[34] = 1024;
            *(_DWORD *)&__str[36] = v65;
            *(_WORD *)&__str[40] = 1024;
            *(_DWORD *)&__str[42] = v61;
            _os_log_impl(&dword_1D8A54000, v63, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d width=%d, height=%d, encodingMode=%d", __str, 0x2Eu);
          }
        }
        v66 = CFNumberCreate(allocator, kCFNumberSInt32Type, valuePtr);
        VCPCompressionSessionSetProperty();
        CFRelease(v66);
        VCPCompressionSessionSetProperty();
        if (*((_QWORD *)a2 + 7))
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v67 = VRTraceErrorLogLevelToCSTR();
            v68 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              v69 = *v52;
              v70 = *((_QWORD *)a2 + 7);
              *(_DWORD *)__str = 136316162;
              *(_QWORD *)&__str[4] = v67;
              *(_WORD *)&__str[12] = 2080;
              *(_QWORD *)&__str[14] = "_Enc_SetCompressionSessionProperties";
              *(_WORD *)&__str[22] = 1024;
              *(_DWORD *)&__str[24] = 474;
              *(_WORD *)&__str[28] = 2048;
              *(_QWORD *)&__str[30] = v69;
              *(_WORD *)&__str[38] = 2080;
              *(_QWORD *)&__str[40] = v70;
              _os_log_impl(&dword_1D8A54000, v68, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d [FLS] Encoder[%p] featureListString=[%s]", __str, 0x30u);
            }
          }
          v71 = CFStringCreateWithCString(0, *((const char **)a2 + 7), 0);
          VCPCompressionSessionSetProperty();
          if (v71)
            CFRelease(v71);
        }
        v72 = CFNumberCreate(0, kCFNumberIntType, v6 + 60);
        VCPCompressionSessionSetProperty();
        CFRelease(v72);
        v73 = CFNumberCreate(0, kCFNumberIntType, v6 + 72);
        VCPCompressionSessionSetProperty();
        CFRelease(v73);
        v74 = CFNumberCreate(0, kCFNumberIntType, a2 + 23);
        VCPCompressionSessionSetProperty();
        CFRelease(v74);
        v75 = CFNumberCreate(0, kCFNumberIntType, a2 + 2);
        VCPCompressionSessionSetProperty();
        CFRelease(v75);
        v76 = CFNumberCreate(0, kCFNumberIntType, a2 + 9);
        VCPCompressionSessionSetProperty();
        CFRelease(v76);
        v77 = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        CFDictionaryAddValue(v77, (const void *)*MEMORY[0x1E0CED848], (const void *)*MEMORY[0x1E0CEDB48]);
        VCPCompressionSessionSetProperty();
        CFRelease(v77);
        v78 = CFNumberCreate(0, kCFNumberIntType, a2 + 19);
        VCPCompressionSessionSetProperty();
        CFRelease(v78);
        if (*((_QWORD *)a2 + 17))
        {
          v79 = VCPCompressionSessionSetProperty();
          if (v79)
          {
            v80 = v79;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              v81 = VRTraceErrorLogLevelToCSTR();
              v82 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              {
                v110 = *((_QWORD *)a2 + 17);
                *(_DWORD *)__str = 136316162;
                *(_QWORD *)&__str[4] = v81;
                *(_WORD *)&__str[12] = 2080;
                *(_QWORD *)&__str[14] = "_Enc_SetCompressionSessionProperties";
                *(_WORD *)&__str[22] = 1024;
                *(_DWORD *)&__str[24] = 515;
                *(_WORD *)&__str[28] = 2112;
                *(_QWORD *)&__str[30] = v110;
                *(_WORD *)&__str[38] = 1024;
                *(_DWORD *)&__str[40] = v80;
                _os_log_error_impl(&dword_1D8A54000, v82, OS_LOG_TYPE_ERROR, " [%s] %s:%d Failed to set profile level property to %@ with error status=%d", __str, 0x2Cu);
              }
            }
          }
        }
        v83 = a2[32];
        if (v83 == 875836518 || v83 == 875836534 || v83 == 2019963956)
        {
          v84 = VCPCompressionSessionSetProperty();
          if (v84)
          {
            v85 = v84;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              v86 = VRTraceErrorLogLevelToCSTR();
              v87 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              {
                v109 = FourccToCStr(a2[32]);
                *(_DWORD *)__str = 136316162;
                *(_QWORD *)&__str[4] = v86;
                *(_WORD *)&__str[12] = 2080;
                *(_QWORD *)&__str[14] = "_Enc_SetCompressionSessionProperties";
                *(_WORD *)&__str[22] = 1024;
                *(_DWORD *)&__str[24] = 526;
                *(_WORD *)&__str[28] = 2080;
                *(_QWORD *)&__str[30] = v109;
                *(_WORD *)&__str[38] = 1024;
                *(_DWORD *)&__str[40] = v85;
                _os_log_error_impl(&dword_1D8A54000, v87, OS_LOG_TYPE_ERROR, " [%s] %s:%d Failed to set profile level property for pixelFormat=%s with error status=%d", __str, 0x2Cu);
              }
            }
          }
        }
        LODWORD(v118) = 60;
        v88 = CFNumberCreate(allocator, kCFNumberIntType, &v118);
        if (v88)
        {
          v89 = v88;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v90 = VRTraceErrorLogLevelToCSTR();
            v91 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__str = 136315906;
              *(_QWORD *)&__str[4] = v90;
              *(_WORD *)&__str[12] = 2080;
              *(_QWORD *)&__str[14] = "_Enc_SetCompressionSessionProperties";
              *(_WORD *)&__str[22] = 1024;
              *(_DWORD *)&__str[24] = 537;
              *(_WORD *)&__str[28] = 1024;
              *(_DWORD *)&__str[30] = v118;
              _os_log_impl(&dword_1D8A54000, v91, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Setting priority %d on encoder", __str, 0x22u);
            }
          }
          VCPCompressionSessionSetProperty();
          CFRelease(v89);
        }
        if (*((_BYTE *)a2 + 144))
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v92 = VRTraceErrorLogLevelToCSTR();
            v93 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__str = 136315650;
              *(_QWORD *)&__str[4] = v92;
              *(_WORD *)&__str[12] = 2080;
              *(_QWORD *)&__str[14] = "_Enc_SetCompressionSessionProperties";
              *(_WORD *)&__str[22] = 1024;
              *(_DWORD *)&__str[24] = 543;
              _os_log_impl(&dword_1D8A54000, v93, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Setting temporal scaling properties on the encoder", __str, 0x1Cu);
            }
          }
          v94 = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E0C9B378]);
          if (a2[37])
          {
            v95 = 0;
            v96 = (char *)(a2 + 38);
            do
            {
              v97 = CFNumberCreate(0, kCFNumberSInt32Type, v96);
              CFArrayAppendValue(v94, v97);
              CFRelease(v97);
              ++v95;
              v96 += 4;
            }
            while (v95 < a2[37]);
          }
          v98 = _Enc_CopyTemporalArray(v94, *((_DWORD *)v6 + 96));
          VCPCompressionSessionSetProperty();
          *(_QWORD *)__str = CFArrayGetCount(v98);
          CFRelease(v98);
          CFRelease(v94);
          v99 = CFNumberCreate(allocator, kCFNumberCFIndexType, __str);
          if (v99)
          {
            v100 = v99;
            VCPCompressionSessionSetProperty();
            CFRelease(v100);
          }
        }
        if (a2[51])
        {
          v101 = CFNumberCreate(0, kCFNumberSInt32Type, a2 + 51);
          if (v101)
          {
            v102 = v101;
            VCPCompressionSessionSetProperty();
            CFRelease(v102);
          }
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v103 = VRTraceErrorLogLevelToCSTR();
            v104 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              v105 = a2[51];
              *(_DWORD *)__str = 136315906;
              *(_QWORD *)&__str[4] = v103;
              *(_WORD *)&__str[12] = 2080;
              *(_QWORD *)&__str[14] = "_Enc_SetCompressionSessionProperties";
              *(_WORD *)&__str[22] = 1024;
              *(_DWORD *)&__str[24] = 570;
              *(_WORD *)&__str[28] = 1024;
              *(_DWORD *)&__str[30] = v105;
              _os_log_impl(&dword_1D8A54000, v104, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Set bitrateAveragingInterval=%u", __str, 0x22u);
            }
          }
        }
        Handle = CreateHandle();
        *v116 = Handle;
        if (Handle == 0xFFFFFFFFLL)
        {
          v3 = 2148007941;
        }
        else
        {
          v3 = 0;
          *((_DWORD *)v6 + 93) = *((unsigned __int8 *)a2 + 68);
          v6[380] = *((_BYTE *)a2 + 144);
          *((_DWORD *)v6 + 96) = a2[50];
        }
      }
      v107 = (const void *)*((_QWORD *)v6 + 40);
      if (v107)
        CFRelease(v107);
      if (Mutable)
        CFRelease(Mutable);
      if (cf)
        CFRelease(cf);
      if ((v3 & 0x80000000) != 0)
      {
        if (*v52)
        {
          CFRelease(*v52);
          *v52 = 0;
        }
        pthread_mutex_destroy((pthread_mutex_t *)(v6 + 120));
        pthread_mutex_destroy((pthread_mutex_t *)(v6 + 184));
        goto LABEL_115;
      }
      return 0;
    }
    else
    {
      return 2148007939;
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v9 = VRTraceErrorLogLevelToCSTR();
    v10 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      EncCreateHandle_cold_1(v9, a2, v10);
  }
  return v3;
}

uint64_t EncCloseHandle()
{
  uint64_t v0;
  uint64_t v1;
  const void *v2;
  const void *v3;
  FILE *v4;
  FILE *v5;

  v0 = CheckInHandleDebug();
  if (!v0)
    return 2148007938;
  v1 = v0;
  CheckOutHandleDebug();
  v2 = *(const void **)(v1 + 320);
  if (v2)
    CFRelease(v2);
  if (*(_QWORD *)(v1 + 304))
  {
    pthread_mutex_lock((pthread_mutex_t *)(v1 + 184));
    v3 = *(const void **)(v1 + 304);
    if (v3)
    {
      CFRelease(v3);
      *(_QWORD *)(v1 + 304) = 0;
    }
    pthread_mutex_unlock((pthread_mutex_t *)(v1 + 184));
  }
  v4 = *(FILE **)(v1 + 336);
  if (v4)
    fclose(v4);
  v5 = *(FILE **)(v1 + 360);
  if (v5)
    fclose(v5);
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 120));
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 184));
  free((void *)v1);
  return 0;
}

uint64_t EncSetThermalLevel(uint64_t a1, int a2)
{
  CFNumberRef v2;
  int valuePtr;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  valuePtr = a2;
  if (!CheckInHandleDebug())
    return 2148007938;
  v2 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  VCPCompressionSessionSetProperty();
  CFRelease(v2);
  CheckOutHandleDebug();
  return 0;
}

uint64_t EncSetBitRate(uint64_t a1, const __CFArray *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  const __CFNumber *ValueAtIndex;
  __CFArray *v7;
  uint64_t v8;
  NSObject *v9;
  int v10;
  int v11;
  int valuePtr;
  uint8_t buf[4];
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v3 = 2148007937;
  valuePtr = 0;
  v4 = CheckInHandleDebug();
  if (v4)
  {
    if (a2)
    {
      v5 = v4;
      if (CFArrayGetCount(a2) != 1)
      {
        if (*(_BYTE *)(v5 + 380))
        {
          v7 = _Enc_CopyTemporalArray(a2, *(_DWORD *)(v5 + 384));
          VCPCompressionSessionSetProperty();
          CFRelease(v7);
        }
        v3 = 0;
        goto LABEL_10;
      }
      ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(a2, 0);
      if (ValueAtIndex)
      {
        CFNumberGetValue(ValueAtIndex, kCFNumberIntType, &valuePtr);
        v3 = _Enc_SetAverageBitRate(v5, valuePtr);
LABEL_10:
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v8 = VRTraceErrorLogLevelToCSTR();
          v9 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v10 = *(unsigned __int16 *)(v5 + 252);
            v11 = *(_DWORD *)(v5 + 60);
            *(_DWORD *)buf = 136316418;
            v15 = v8;
            v16 = 2080;
            v17 = "EncSetBitRate";
            v18 = 1024;
            v19 = 1188;
            v20 = 1024;
            v21 = valuePtr;
            v22 = 1024;
            v23 = v10;
            v24 = 1024;
            v25 = v11;
            _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Done Set encoder bitrate: %d limitFrameSize: %d dataRate: %d", buf, 0x2Eu);
          }
        }
      }
    }
    CheckOutHandleDebug();
    return v3;
  }
  return 2148007938;
}

uint64_t EncEncodeFrame(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  pthread_mutex_t *v6;
  __CFDictionary *Mutable;
  int v8;
  __int16 v9;
  int v10;
  const __CFAllocator *v11;
  CFNumberRef v12;
  int v13;
  CFNumberRef v14;
  CFNumberRef v15;
  __CFArray *v16;
  uint64_t v17;
  _BYTE *v18;
  NSObject **v19;
  uint64_t v20;
  NSObject *v21;
  NSObject *v22;
  CFNumberRef v23;
  int v24;
  CFNumberRef v25;
  int v26;
  CFNumberRef v27;
  int v28;
  CFNumberRef v29;
  CFNumberRef v30;
  CFNumberRef v31;
  CFNumberRef v32;
  CFNumberRef v33;
  CFNumberRef v34;
  CFNumberRef v35;
  CFNumberRef v36;
  CFNumberRef v37;
  CFNumberRef v38;
  CFNumberRef v39;
  CFNumberRef v40;
  CFNumberRef v41;
  CFNumberRef v42;
  CFNumberRef v43;
  CFNumberRef v44;
  CFNumberRef v45;
  CFNumberRef v46;
  CFNumberRef v47;
  CFNumberRef v48;
  CFNumberRef v49;
  CFNumberRef v50;
  CFNumberRef v51;
  CFNumberRef v52;
  CFNumberRef v53;
  CFNumberRef v54;
  CFNumberRef v55;
  CFNumberRef v56;
  int v57;
  uint64_t v58;
  NSObject *v59;
  CFDataRef v60;
  CFDataRef v61;
  uint64_t v62;
  CFDataRef v63;
  CFDataRef v64;
  uint64_t v65;
  CFDataRef v66;
  CFDataRef v67;
  CFNumberRef v68;
  CFNumberRef v69;
  const __CFArray *Attachment;
  const __CFArray *v71;
  const __CFDictionary *ValueAtIndex;
  uint64_t v73;
  float64x2_t *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  double v78;
  int32x2_t v79;
  int64x2_t v80;
  uint64_t v81;
  NSObject *v82;
  NSObject *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  __CFDictionary *VisibleRectDictionary;
  uint64_t v89;
  NSObject *v90;
  NSObject *v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  const void *v96;
  CFTypeRef v97;
  CFNumberRef v98;
  CFNumberRef v99;
  CFTypeRef v100;
  CFTypeRef v101;
  _OWORD *v102;
  CMTimeValue value;
  uint64_t v104;
  CMTimeEpoch epoch;
  __int128 v106;
  int v107;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  const __CFAllocator *v117;
  double v118;
  CMTime valuePtr;
  CMTime time2;
  CMTime buf;
  int v122;
  __int16 v123;
  uint64_t v124;
  __int16 v125;
  uint64_t v126;
  __int16 v127;
  uint64_t v128;
  __int16 v129;
  uint64_t v130;
  __int16 v131;
  uint64_t v132;
  __int16 v133;
  uint64_t v134;
  __int16 v135;
  uint64_t v136;
  __int16 v137;
  uint64_t v138;
  __int16 v139;
  double v140;
  uint64_t v141;

  v141 = *MEMORY[0x1E0C80C00];
  v3 = 2148007957;
  v4 = CheckInHandleDebug();
  if (v4)
  {
    v5 = v4;
    if (!*(_QWORD *)v4)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          EncEncodeFrame_cold_1();
      }
      goto LABEL_142;
    }
    if (*(_DWORD *)a2 != *(__int16 *)(v4 + 58) || *(_DWORD *)(a2 + 4) != *(__int16 *)(v4 + 56))
    {
LABEL_142:
      CheckOutHandleDebug();
      return v3;
    }
    v6 = (pthread_mutex_t *)(v4 + 120);
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 120));
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v8 = *(_DWORD *)(v5 + 32);
    if (v8 < 1)
    {
      if (v8)
        goto LABEL_9;
    }
    else
    {
      *(_DWORD *)(v5 + 32) = v8 - 1;
      if (v8 <= *(_DWORD *)(v5 + 40))
      {
        *(_DWORD *)(v5 + 104) = 0;
        *(_DWORD *)(v5 + 28) = 1;
      }
      if (v8 != 1)
      {
LABEL_9:
        v9 = *(_WORD *)(v5 + 252);
        if (*(_DWORD *)a2 > *(_DWORD *)(a2 + 4)
          && *(_WORD *)(v5 + 252)
          && ((v10 = *(_DWORD *)(a2 + 8), v10 > 0) || *(int *)(v5 + 84) >= 1))
        {
          v9 *= 2;
        }
        else
        {
          v10 = *(_DWORD *)(a2 + 8);
        }
        LOWORD(valuePtr.value) = v9;
        *(_DWORD *)(v5 + 84) = v10;
        v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        v12 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberShortType, &valuePtr);
        CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0CED5D8], v12);
        CFRelease(v12);
        if (*(_DWORD *)(a2 + 236))
        {
          LODWORD(buf.value) = 2;
          v13 = 4;
        }
        else
        {
          LODWORD(buf.value) = 13;
          v13 = 9;
        }
        LODWORD(time2.value) = v13;
        v14 = CFNumberCreate(v11, kCFNumberSInt32Type, &buf);
        v15 = CFNumberCreate(v11, kCFNumberSInt32Type, &time2);
        CFDictionaryAddValue(Mutable, CFSTR("RemoteDisplayWidth"), v14);
        CFDictionaryAddValue(Mutable, CFSTR("RemoteDisplayHeight"), v15);
        CFRelease(v14);
        CFRelease(v15);
        if (*(int *)(a2 + 120) >= 1 && *(_QWORD *)(a2 + 112))
        {
          v117 = v11;
          LODWORD(time2.value) = -1431655766;
          v16 = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
          if (*(int *)(a2 + 120) >= 1)
          {
            v17 = 0;
            v18 = (_BYTE *)MEMORY[0x1E0CF2748];
            v19 = (NSObject **)MEMORY[0x1E0CF2758];
            do
            {
              LODWORD(time2.value) = *(_DWORD *)(*(_QWORD *)(a2 + 112) + 4 * v17);
              if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
              {
                v20 = VRTraceErrorLogLevelToCSTR();
                v21 = *v19;
                v22 = *v19;
                if (*v18)
                {
                  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
                  {
                    LODWORD(buf.value) = 136315906;
                    *(CMTimeValue *)((char *)&buf.value + 4) = v20;
                    LOWORD(buf.flags) = 2080;
                    *(_QWORD *)((char *)&buf.flags + 2) = "_Enc_SetupFrameProperties";
                    HIWORD(buf.epoch) = 1024;
                    v122 = 813;
                    v123 = 1024;
                    LODWORD(v124) = time2.value;
                    _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Updating encoder LTR ACK token=%d", (uint8_t *)&buf, 0x22u);
                  }
                }
                else if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
                {
                  LODWORD(buf.value) = 136315906;
                  *(CMTimeValue *)((char *)&buf.value + 4) = v20;
                  LOWORD(buf.flags) = 2080;
                  *(_QWORD *)((char *)&buf.flags + 2) = "_Enc_SetupFrameProperties";
                  HIWORD(buf.epoch) = 1024;
                  v122 = 813;
                  v123 = 1024;
                  LODWORD(v124) = time2.value;
                  _os_log_debug_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Updating encoder LTR ACK token=%d", (uint8_t *)&buf, 0x22u);
                }
              }
              v23 = CFNumberCreate(0, kCFNumberSInt32Type, &time2);
              CFArrayAppendValue(v16, v23);
              CFRelease(v23);
              ++v17;
            }
            while (v17 < *(int *)(a2 + 120));
          }
          CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0CED4A0], v16);
          CFRelease(v16);
          v6 = (pthread_mutex_t *)(v5 + 120);
          v11 = v117;
        }
        v24 = *(_DWORD *)(a2 + 128);
        if (v24 >= 1)
        {
          LODWORD(buf.value) = 8 * v24;
          v25 = CFNumberCreate(0, kCFNumberSInt32Type, &buf);
          CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0CED5F0], v25);
          CFRelease(v25);
        }
        v26 = *(_DWORD *)(a2 + 124);
        if (v26 >= 1)
        {
          LODWORD(buf.value) = 8 * v26;
          v27 = CFNumberCreate(0, kCFNumberSInt32Type, &buf);
          CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0CED590], v27);
          CFRelease(v27);
        }
        v28 = *(_DWORD *)(a2 + 280);
        if (v28)
        {
          LODWORD(buf.value) = 8 * v28;
          v29 = CFNumberCreate(0, kCFNumberSInt32Type, &buf);
          if (v29)
          {
            v30 = v29;
            CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0CED608], v29);
            CFRelease(v30);
          }
        }
        if (*(_DWORD *)(a2 + 288))
        {
          v31 = CFNumberCreate(0, kCFNumberSInt32Type, (const void *)(a2 + 288));
          if (v31)
          {
            v32 = v31;
            CFDictionaryAddValue(Mutable, CFSTR("MediaQueueDelayLimit"), v31);
            CFRelease(v32);
          }
        }
        if (*(_DWORD *)(a2 + 284))
        {
          v33 = CFNumberCreate(0, kCFNumberSInt32Type, (const void *)(a2 + 284));
          if (v33)
          {
            v34 = v33;
            CFDictionaryAddValue(Mutable, CFSTR("MediaQueueDelay"), v33);
            CFRelease(v34);
          }
        }
        if (*(double *)(a2 + 136) > 0.0)
        {
          v35 = CFNumberCreate(0, kCFNumberDoubleType, (const void *)(a2 + 136));
          if (v35)
          {
            v36 = v35;
            CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0CEDB18], v35);
            CFRelease(v36);
          }
        }
        if (*(double *)(a2 + 144) > 0.0)
        {
          v37 = CFNumberCreate(0, kCFNumberDoubleType, (const void *)(a2 + 144));
          if (v37)
          {
            v38 = v37;
            CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0CEDAD8], v37);
            CFRelease(v38);
          }
        }
        if (*(double *)(a2 + 152) > 0.0)
        {
          v39 = CFNumberCreate(0, kCFNumberDoubleType, (const void *)(a2 + 152));
          if (v39)
          {
            v40 = v39;
            CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0CEDAB8], v39);
            CFRelease(v40);
          }
        }
        v41 = CFNumberCreate(0, kCFNumberSInt32Type, (const void *)(a2 + 168));
        CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0CED630], v41);
        if (v41)
          CFRelease(v41);
        v42 = CFNumberCreate(0, kCFNumberSInt32Type, (const void *)(a2 + 160));
        CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0CED5E8], v42);
        if (v42)
          CFRelease(v42);
        v43 = CFNumberCreate(0, kCFNumberSInt32Type, (const void *)(a2 + 164));
        CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0CED4B8], v43);
        if (v43)
          CFRelease(v43);
        v44 = CFNumberCreate(0, kCFNumberSInt32Type, (const void *)(a2 + 192));
        CFDictionaryAddValue(Mutable, CFSTR("CaptureFrameDrop"), v44);
        CFRelease(v44);
        v45 = CFNumberCreate(0, kCFNumberIntType, (const void *)(a2 + 196));
        if (v45)
        {
          v46 = v45;
          CFDictionaryAddValue(Mutable, CFSTR("LocalPIPStatus"), v45);
          CFRelease(v46);
        }
        v47 = CFNumberCreate(0, kCFNumberIntType, (const void *)(a2 + 200));
        if (v47)
        {
          v48 = v47;
          CFDictionaryAddValue(Mutable, CFSTR("RemotePIPStatus"), v47);
          CFRelease(v48);
        }
        if (!*(_DWORD *)(a2 + 204) || !*(_DWORD *)(a2 + 208))
        {
LABEL_74:
          if (!*(_DWORD *)(a2 + 212) || !*(_DWORD *)(a2 + 216))
          {
LABEL_83:
            v55 = CFNumberCreate(0, kCFNumberSInt32Type, (const void *)(a2 + 188));
            CFDictionaryAddValue(Mutable, CFSTR("Use2GNetwork"), v55);
            CFRelease(v55);
            if (!*(_DWORD *)(v5 + 372))
            {
              v56 = CFNumberCreate(0, kCFNumberSInt32Type, (const void *)(a2 + 172));
              CFDictionaryAddValue(Mutable, CFSTR("PadFrameToMinimumSize"), v56);
              CFRelease(v56);
            }
            v57 = *(_DWORD *)(v5 + 28);
            if (v57)
            {
              *(_DWORD *)(a2 + 8) = 0;
              if (*(_DWORD *)(v5 + 24))
              {
                if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
                {
                  v58 = VRTraceErrorLogLevelToCSTR();
                  v59 = *MEMORY[0x1E0CF2758];
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                  {
                    LODWORD(buf.value) = 136315650;
                    *(CMTimeValue *)((char *)&buf.value + 4) = v58;
                    LOWORD(buf.flags) = 2080;
                    *(_QWORD *)((char *)&buf.flags + 2) = "_Enc_SetupFrameProperties";
                    HIWORD(buf.epoch) = 1024;
                    v122 = 960;
                    _os_log_impl(&dword_1D8A54000, v59, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Requesting kVTEncodeFrameOptionKey_ForceKeyFrame", (uint8_t *)&buf, 0x1Cu);
                  }
                }
                CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0CED5B8], (const void *)*MEMORY[0x1E0C9AE50]);
              }
              else
              {
                v60 = CFDataCreate(v11, (const UInt8 *)(v5 + 88), 2 * *(int *)(v5 + 104));
                if (v60)
                {
                  v61 = v60;
                  CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0CED5A8], v60);
                  CFRelease(v61);
                }
              }
            }
            v62 = *(unsigned int *)(a2 + 8);
            if ((int)v62 >= 1)
            {
              v63 = CFDataCreate(v11, *(const UInt8 **)(a2 + 16), 2 * v62);
              if (v63)
              {
                v64 = v63;
                CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0CED5B0], v63);
                CFRelease(v64);
              }
            }
            v65 = *(unsigned int *)(a2 + 24);
            if ((int)v65 >= 1)
            {
              v66 = CFDataCreate(v11, *(const UInt8 **)(a2 + 32), 2 * v65);
              if (v66)
              {
                v67 = v66;
                CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0CED5A0], v66);
                CFRelease(v67);
              }
            }
            v68 = CFNumberCreate(0, kCFNumberIntType, (const void *)(v5 + 368));
            if (v68)
            {
              v69 = v68;
              CFDictionaryAddValue(Mutable, CFSTR("AutoExposureState"), v68);
              CFRelease(v69);
            }
            Attachment = (const __CFArray *)CVBufferGetAttachment(*(CVBufferRef *)(a2 + 88), CFSTR("FVDWindowRectangles"), 0);
            if (Attachment)
            {
              v71 = Attachment;
              if (CFArrayGetCount(Attachment))
              {
                ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v71, 0);
                v73 = *(_QWORD *)(a2 + 248);
                v74 = (float64x2_t *)(a2 + 264);
                v76 = *(_QWORD *)(a2 + 256);
                v75 = *(_QWORD *)(a2 + 264);
                v77 = *(_QWORD *)(a2 + 272);
                CGRectMakeWithDictionaryRepresentation(ValueAtIndex, (CGRect *)(a2 + 248));
                v78 = CVBufferGetAttachment(*(CVBufferRef *)(a2 + 88), CFSTR("FVDWindowScaleFactor"), 0)
                    ? (float)(int)FigCFNumberGetSInt32()
                    : 2.0;
                v118 = v78;
                v79 = vmovn_s64(vcvtq_s64_f64(vmulq_n_f64(*v74, v78)));
                v80.i64[0] = v79.i32[0];
                v80.i64[1] = v79.i32[1];
                *v74 = vcvtq_f64_s64(v80);
                if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
                {
                  v81 = VRTraceErrorLogLevelToCSTR();
                  v82 = *MEMORY[0x1E0CF2758];
                  v83 = *MEMORY[0x1E0CF2758];
                  if (*MEMORY[0x1E0CF2748])
                  {
                    if (os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT))
                    {
                      v84 = *(_QWORD *)(a2 + 248);
                      v85 = *(_QWORD *)(a2 + 256);
                      v86 = *(_QWORD *)(a2 + 264);
                      v87 = *(_QWORD *)(a2 + 272);
                      LODWORD(buf.value) = 136317954;
                      *(CMTimeValue *)((char *)&buf.value + 4) = v81;
                      LOWORD(buf.flags) = 2080;
                      *(_QWORD *)((char *)&buf.flags + 2) = "_Enc_SetupFrameProperties";
                      HIWORD(buf.epoch) = 1024;
                      v122 = 1023;
                      v123 = 2048;
                      v124 = v73;
                      v125 = 2048;
                      v126 = v76;
                      v127 = 2048;
                      v128 = v75;
                      v129 = 2048;
                      v130 = v77;
                      v131 = 2048;
                      v132 = v84;
                      v133 = 2048;
                      v134 = v85;
                      v135 = 2048;
                      v136 = v86;
                      v137 = 2048;
                      v138 = v87;
                      v139 = 2048;
                      v140 = v118;
                      _os_log_impl(&dword_1D8A54000, v82, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Replacing visibleRect from (%f, %f, %f, %f) to update window (%f, %f, %f, %f) resolutionScale=%f", (uint8_t *)&buf, 0x76u);
                    }
                  }
                  else if (os_log_type_enabled(v83, OS_LOG_TYPE_DEBUG))
                  {
                    v113 = *(_QWORD *)(a2 + 248);
                    v114 = *(_QWORD *)(a2 + 256);
                    v115 = *(_QWORD *)(a2 + 264);
                    v116 = *(_QWORD *)(a2 + 272);
                    LODWORD(buf.value) = 136317954;
                    *(CMTimeValue *)((char *)&buf.value + 4) = v81;
                    LOWORD(buf.flags) = 2080;
                    *(_QWORD *)((char *)&buf.flags + 2) = "_Enc_SetupFrameProperties";
                    HIWORD(buf.epoch) = 1024;
                    v122 = 1023;
                    v123 = 2048;
                    v124 = v73;
                    v125 = 2048;
                    v126 = v76;
                    v127 = 2048;
                    v128 = v75;
                    v129 = 2048;
                    v130 = v77;
                    v131 = 2048;
                    v132 = v113;
                    v133 = 2048;
                    v134 = v114;
                    v135 = 2048;
                    v136 = v115;
                    v137 = 2048;
                    v138 = v116;
                    v139 = 2048;
                    v140 = v118;
                    _os_log_debug_impl(&dword_1D8A54000, v82, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Replacing visibleRect from (%f, %f, %f, %f) to update window (%f, %f, %f, %f) resolutionScale=%f", (uint8_t *)&buf, 0x76u);
                  }
                }
              }
            }
            if (!CGRectIsNull(*(CGRect *)(a2 + 248)))
            {
              VisibleRectDictionary = VideoUtil_CreateVisibleRectDictionary(*(double *)(a2 + 248), *(double *)(a2 + 256), *(double *)(a2 + 264), *(double *)(a2 + 272));
              if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
              {
                v89 = VRTraceErrorLogLevelToCSTR();
                v90 = *MEMORY[0x1E0CF2758];
                v91 = *MEMORY[0x1E0CF2758];
                if (*MEMORY[0x1E0CF2748])
                {
                  if (os_log_type_enabled(v91, OS_LOG_TYPE_DEFAULT))
                  {
                    v92 = *(_QWORD *)(a2 + 248);
                    v93 = *(_QWORD *)(a2 + 256);
                    v94 = *(_QWORD *)(a2 + 264);
                    v95 = *(_QWORD *)(a2 + 272);
                    LODWORD(buf.value) = 136316674;
                    *(CMTimeValue *)((char *)&buf.value + 4) = v89;
                    LOWORD(buf.flags) = 2080;
                    *(_QWORD *)((char *)&buf.flags + 2) = "_Enc_SetupFrameProperties";
                    HIWORD(buf.epoch) = 1024;
                    v122 = 1027;
                    v123 = 2048;
                    v124 = v92;
                    v125 = 2048;
                    v126 = v93;
                    v127 = 2048;
                    v128 = v94;
                    v129 = 2048;
                    v130 = v95;
                    _os_log_impl(&dword_1D8A54000, v90, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Setting kVTEncodeFrameOptionKey_VisibleRectangle to (%f, %f, %f, %f)", (uint8_t *)&buf, 0x44u);
                  }
                }
                else if (os_log_type_enabled(v91, OS_LOG_TYPE_DEBUG))
                {
                  v109 = *(_QWORD *)(a2 + 248);
                  v110 = *(_QWORD *)(a2 + 256);
                  v111 = *(_QWORD *)(a2 + 264);
                  v112 = *(_QWORD *)(a2 + 272);
                  LODWORD(buf.value) = 136316674;
                  *(CMTimeValue *)((char *)&buf.value + 4) = v89;
                  LOWORD(buf.flags) = 2080;
                  *(_QWORD *)((char *)&buf.flags + 2) = "_Enc_SetupFrameProperties";
                  HIWORD(buf.epoch) = 1024;
                  v122 = 1027;
                  v123 = 2048;
                  v124 = v109;
                  v125 = 2048;
                  v126 = v110;
                  v127 = 2048;
                  v128 = v111;
                  v129 = 2048;
                  v130 = v112;
                  _os_log_debug_impl(&dword_1D8A54000, v90, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Setting kVTEncodeFrameOptionKey_VisibleRectangle to (%f, %f, %f, %f)", (uint8_t *)&buf, 0x44u);
                }
              }
              CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0CED670], VisibleRectDictionary);
              CFRelease(VisibleRectDictionary);
            }
            v96 = (const void *)*MEMORY[0x1E0CED620];
            v97 = CVBufferGetAttachment(*(CVBufferRef *)(a2 + 88), (CFStringRef)*MEMORY[0x1E0CED620], 0);
            if (v97)
              CFDictionaryAddValue(Mutable, v96, v97);
            v98 = CFNumberCreate(0, kCFNumberIntType, (const void *)(a2 + 232));
            if (v98)
            {
              v99 = v98;
              CFDictionaryAddValue(Mutable, CFSTR("CameraFacingType"), v98);
              CFRelease(v99);
            }
            v100 = CVBufferGetAttachment(*(CVBufferRef *)(a2 + 88), CFSTR("DirtyRegion"), 0);
            if (v100)
              CFDictionaryAddValue(Mutable, CFSTR("DirtyRegionArray"), v100);
            v101 = CVBufferGetAttachment(*(CVBufferRef *)(a2 + 88), CFSTR("HIDEventTimestamp"), 0);
            if (v101)
              CFDictionaryAddValue(Mutable, CFSTR("HIDTimeStamp"), v101);
            pthread_mutex_unlock(v6);
            v102 = (_OWORD *)(v5 + 280);
            buf = *(CMTime *)(v5 + 280);
            time2 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68];
            if (CMTimeCompare(&buf, &time2))
            {
              time2 = *(CMTime *)(a2 + 40);
              *(_OWORD *)&valuePtr.value = *v102;
              valuePtr.epoch = *(_QWORD *)(v5 + 296);
              CMTimeSubtract(&buf, &time2, &valuePtr);
            }
            else
            {
              CMTimeMakeWithSeconds(&buf, (double)(*(_DWORD *)(v5 + 68) / 1000), *(_DWORD *)(a2 + 48));
            }
            value = buf.value;
            v104 = *(_QWORD *)&buf.timescale;
            epoch = buf.epoch;
            v106 = *(_OWORD *)(a2 + 40);
            *(_QWORD *)(v5 + 296) = *(_QWORD *)(a2 + 56);
            *v102 = v106;
            if (*(_QWORD *)(v5 + 336))
              DumpFrameYuv((size_t *)(v5 + 352), (size_t *)(v5 + 344), (FILE **)(v5 + 336), 0, *(CVPixelBufferRef *)(a2 + 88));
            if (*(_DWORD *)(v5 + 44) == 2)
              DumpFrameYuvWithTimestamp(0, *(__CVBuffer **)(a2 + 88), *(_DWORD *)(a2 + 180));
            pthread_mutex_lock((pthread_mutex_t *)(v5 + 184));
            buf = *(CMTime *)(a2 + 40);
            time2.value = value;
            *(_QWORD *)&time2.timescale = v104;
            time2.epoch = epoch;
            v107 = VCPCompressionSessionEncodeFrame();
            pthread_mutex_unlock((pthread_mutex_t *)(v5 + 184));
            if (v57)
            {
              *(_QWORD *)(v5 + 24) = 0;
              *(_DWORD *)(v5 + 104) = 0;
              *(double *)(v5 + 112) = micro();
            }
            ++*(_DWORD *)(v5 + 328);
            CFRelease(Mutable);
            if (v107 << 16)
            {
              v3 = -(__int16)v107 | 0xA0080000;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  EncEncodeFrame_cold_2();
              }
            }
            else
            {
              v3 = 0;
            }
            goto LABEL_142;
          }
          v52 = CFNumberCreate(0, kCFNumberIntType, (const void *)(a2 + 212));
          v53 = CFNumberCreate(0, kCFNumberIntType, (const void *)(a2 + 216));
          v54 = v53;
          if (v52 && v53)
          {
            CFDictionaryAddValue(Mutable, CFSTR("RemotePIPWidth"), v52);
            CFDictionaryAddValue(Mutable, CFSTR("RemotePIPHeight"), v54);
          }
          else if (!v52)
          {
            goto LABEL_81;
          }
          CFRelease(v52);
LABEL_81:
          if (v54)
            CFRelease(v54);
          goto LABEL_83;
        }
        v49 = CFNumberCreate(0, kCFNumberIntType, (const void *)(a2 + 204));
        v50 = CFNumberCreate(0, kCFNumberIntType, (const void *)(a2 + 208));
        v51 = v50;
        if (v49 && v50)
        {
          CFDictionaryAddValue(Mutable, CFSTR("LocalPIPWidth"), v49);
          CFDictionaryAddValue(Mutable, CFSTR("LocalPIPHeight"), v51);
        }
        else if (!v49)
        {
          goto LABEL_72;
        }
        CFRelease(v49);
LABEL_72:
        if (v51)
          CFRelease(v51);
        goto LABEL_74;
      }
    }
    *(_DWORD *)(v5 + 32) = *(_DWORD *)(v5 + 36);
    goto LABEL_9;
  }
  return 2148007938;
}

uint64_t EncGenerateKeyFrameNow(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  _WORD *v11;
  int v12;
  uint64_t v13;
  _WORD *v14;
  __int16 v15;
  int v16;
  __int16 *v17;
  int v18;
  __int16 v19;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;
  NSObject *v24;
  char v25[16];
  _BYTE buf[49];
  _BYTE v27[31];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v5 = CheckInHandleDebug();
  if (!v5)
    return 2148007938;
  v6 = v5;
  if (*(int *)(v5 + 36) <= 0)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v5 + 120));
    if (!*(_DWORD *)(v6 + 24))
    {
      v7 = *(unsigned int *)(v6 + 104);
      if ((int)v7 < 1)
      {
        if (a3 > 1)
        {
          *(_DWORD *)(v6 + 104) = a3 - 2;
          memcpy((void *)(v6 + 88), (const void *)(a2 + 4), 2 * (a3 - 2));
          goto LABEL_28;
        }
        *(_DWORD *)(v6 + 104) = 0;
      }
      else
      {
        if (a3 >= 3)
        {
          v8 = 2;
          do
          {
            v9 = *(unsigned __int16 *)(a2 + 2 * v8);
            v10 = v7;
            v11 = (_WORD *)(v6 + 88);
            while (v9 != (unsigned __int16)*v11)
            {
              ++v11;
              if (!--v10)
                goto LABEL_12;
            }
            *v11 = v9 | 0x8000;
LABEL_12:
            ++v8;
          }
          while (v8 != a3);
        }
        v12 = 0;
        do
        {
          v13 = v6 + 2 * v12;
          v16 = *(__int16 *)(v13 + 88);
          v14 = (_WORD *)(v13 + 88);
          v15 = v16;
          if (v16 < 0)
          {
            *v14 = v15 & 0x7FFF;
          }
          else
          {
            if (v12 + 1 < (int)v7)
            {
              v17 = (__int16 *)(v6 + 88 + 2 * (v12 + 1));
              v18 = v12;
              do
              {
                v19 = *v17++;
                *(_WORD *)(v6 + 2 * v18++ + 88) = v19;
              }
              while ((_DWORD)v7 - 1 != v18);
            }
            LODWORD(v7) = v7 - 1;
            *(_DWORD *)(v6 + 104) = v7;
            --v12;
          }
          ++v12;
        }
        while (v12 < (int)v7);
        if (a3 > 1)
          goto LABEL_28;
      }
      *(_QWORD *)(v6 + 24) = 0x100000001;
LABEL_28:
      if (!*(_DWORD *)(v6 + 20))
      {
        *(_QWORD *)&v21 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v21 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)&v27[15] = v21;
        *(_OWORD *)v27 = v21;
        *(_OWORD *)&buf[33] = v21;
        *(_OWORD *)&buf[17] = v21;
        *(_OWORD *)&buf[1] = v21;
        memset(v25, 170, 10);
        *(_DWORD *)(v6 + 28) = 1;
        buf[0] = 0;
        if (*(int *)(v6 + 104) >= 1)
        {
          v22 = 0;
          do
          {
            __sprintf_chk(v25, 0, 0xAuLL, " %d", *(unsigned __int16 *)(v6 + 88 + 2 * v22));
            __strlcat_chk();
            ++v22;
          }
          while (v22 < *(int *)(v6 + 104));
        }
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v23 = VRTraceErrorLogLevelToCSTR();
        v24 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315906;
          *(_QWORD *)&buf[4] = v23;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "EncGenerateKeyFrameNow";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 1337;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = a3;
          _os_log_impl(&dword_1D8A54000, v24, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Generated a key frame for FIR(%d)", buf, 0x22u);
        }
      }
    }
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v6 + 120));
  CheckOutHandleDebug();
  return 0;
}

uint64_t EncSendImgDesc()
{
  uint64_t v0;
  uint64_t v1;
  pthread_mutex_t *v2;

  v0 = CheckInHandleDebug();
  if (!v0)
    return 2148007938;
  v1 = v0;
  v2 = (pthread_mutex_t *)(v0 + 120);
  pthread_mutex_lock((pthread_mutex_t *)(v0 + 120));
  *(_DWORD *)(v1 + 104) = 0;
  *(_QWORD *)(v1 + 24) = 0x100000001;
  pthread_mutex_unlock(v2);
  CheckOutHandleDebug();
  return 0;
}

uint64_t EncPixelBufferFromPool(uint64_t a1, CVPixelBufferRef *a2)
{
  __CVPixelBufferPool *PixelBufferPool;
  CVReturn PixelBuffer;
  uint64_t v5;

  if (!CheckInHandleDebug())
    return 2148007938;
  PixelBufferPool = (__CVPixelBufferPool *)VCPCompressionSessionGetPixelBufferPool();
  PixelBuffer = CVPixelBufferPoolCreatePixelBuffer(0, PixelBufferPool, a2);
  if (PixelBuffer << 16)
    v5 = -(__int16)PixelBuffer | 0xA0080000;
  else
    v5 = 0;
  CheckOutHandleDebug();
  return v5;
}

uint64_t EncSetEncodingMode(uint64_t a1, int a2)
{
  uint64_t v3;
  CFNumberRef v4;
  int valuePtr;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  valuePtr = a2;
  v3 = CheckInHandleDebug();
  if (!v3)
    return 2148007938;
  *(_DWORD *)(v3 + 248) = a2;
  v4 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &valuePtr);
  VCPCompressionSessionSetProperty();
  CFRelease(v4);
  CheckOutHandleDebug();
  return 0;
}

uint64_t VCVideoEncoderVCPInitialize(uint64_t result)
{
  *(_QWORD *)result = EncoderVCP_VTable;
  *(_DWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 16) = 0xFFFFFFFFLL;
  return result;
}

void _DumpParameterSetsBitstream(opaqueCMSampleBuffer *a1, uint64_t a2)
{
  const opaqueCMFormatDescription *FormatDescription;
  const __CFData *AvcCFromFormatDescriptionForLog;
  const __CFData *v5;
  const UInt8 *BytePtr;
  CFIndex Length;
  size_t v8;
  size_t v9[2];

  v9[1] = *MEMORY[0x1E0C80C00];
  v9[0] = 0;
  FormatDescription = CMSampleBufferGetFormatDescription(a1);
  if (FormatDescription)
  {
    AvcCFromFormatDescriptionForLog = extractAvcCFromFormatDescriptionForLog(FormatDescription);
    if (AvcCFromFormatDescriptionForLog)
    {
      v5 = AvcCFromFormatDescriptionForLog;
      BytePtr = CFDataGetBytePtr(AvcCFromFormatDescriptionForLog);
      Length = CFDataGetLength(v5);
      if (BytePtr && (int)Length >= 1)
      {
        v8 = Length;
        MEMORY[0x1E0C80A78](Length);
        memset((char *)v9 - ((v8 + 15) & 0x1FFFFFFF0), 170, v8);
        if ((unsigned __int16)readAVCCAndEncodeH264SPSPPS((uint64_t)BytePtr, v8, (uint64_t)v9 - ((v8 + 15) & 0x1FFFFFFF0), v9))
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              _DumpParameterSetsBitstream_cold_3();
          }
        }
        else
        {
          fwrite((char *)v9 - ((v8 + 15) & 0x1FFFFFFF0), 1uLL, v9[0], *(FILE **)(a2 + 360));
        }
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _DumpParameterSetsBitstream_cold_4();
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _DumpParameterSetsBitstream_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _DumpParameterSetsBitstream_cold_1();
  }
}

void _DumpFrameBitstream(opaqueCMSampleBuffer *a1, uint64_t a2)
{
  int SampleSize;
  OpaqueCMBlockBuffer *DataBuffer;
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  const char *v9;
  uint64_t v10;
  NSObject *v11;
  int i;
  signed int v13;
  char *v14;
  int __ptr;
  uint8_t buf[4];
  uint64_t v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  __ptr = 0x1000000;
  v14 = 0;
  if (a1)
  {
    SampleSize = CMSampleBufferGetSampleSize(a1, 0);
    if (SampleSize >= 1)
    {
      DataBuffer = CMSampleBufferGetDataBuffer(a1);
      if (DataBuffer)
      {
        if (CMBlockBufferGetDataPointer(DataBuffer, 0, 0, 0, &v14))
        {
          if ((int)VRTraceGetErrorLogLevelForModule() < 8)
            return;
          v6 = VRTraceErrorLogLevelToCSTR();
          v7 = *MEMORY[0x1E0CF2758];
          v8 = *MEMORY[0x1E0CF2758];
          if (*MEMORY[0x1E0CF2748])
          {
            if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
              return;
            *(_DWORD *)buf = 136315650;
            v17 = v6;
            v18 = 2080;
            v19 = "_DumpFrameBitstream";
            v20 = 1024;
            v21 = 215;
            v9 = " [%s] %s:%d VCPCompressionSession Error: Error getting data buffer";
LABEL_13:
            _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, v9, buf, 0x1Cu);
            return;
          }
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
            _DumpFrameBitstream_cold_2();
        }
        else
        {
          for (i = 0; i < SampleSize; i += v13 + 4)
          {
            v13 = bswap32(*(_DWORD *)&v14[i]);
            fwrite(&__ptr, 1uLL, 4uLL, *(FILE **)(a2 + 360));
            fwrite(&v14[i + 4], 1uLL, v13, *(FILE **)(a2 + 360));
            fflush(*(FILE **)(a2 + 360));
          }
        }
      }
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 8)
      return;
    v10 = VRTraceErrorLogLevelToCSTR();
    v7 = *MEMORY[0x1E0CF2758];
    v11 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        return;
      *(_DWORD *)buf = 136315650;
      v17 = v10;
      v18 = 2080;
      v19 = "_DumpFrameBitstream";
      v20 = 1024;
      v21 = 233;
      v9 = " [%s] %s:%d VCPCompressionSession Error: Encoder returned a NULL frame";
      goto LABEL_13;
    }
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      _DumpFrameBitstream_cold_1();
  }
}

void _EncDumpBitStream(CMSampleBufferRef sbuf, uint64_t a2, uint64_t a3)
{
  int v5;
  const __CFArray *SampleAttachmentsArray;
  const __CFDictionary *ValueAtIndex;

  v5 = *(_DWORD *)(a3 + 48);
  if ((v5 == 1752589105 || v5 == 1635148593) && sbuf != 0)
  {
    SampleAttachmentsArray = CMSampleBufferGetSampleAttachmentsArray(sbuf, 0);
    if (SampleAttachmentsArray)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(SampleAttachmentsArray, 0);
      if (CFDictionaryGetValue(ValueAtIndex, (const void *)*MEMORY[0x1E0CA25C8]) == (const void *)*MEMORY[0x1E0C9AE40])
        _DumpParameterSetsBitstream(sbuf, a3);
    }
  }
  _DumpFrameBitstream(sbuf, a3);
}

uint64_t vtEncCallback(uint64_t a1, uint64_t a2, uint64_t a3, int a4, CMSampleBufferRef sbuf)
{
  if ((_DWORD)a3 == -12912 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      vtEncCallback_cold_2();
  }
  if (*(_QWORD *)(a1 + 360))
    _EncDumpBitStream(sbuf, a2, a1);
  if (*(_QWORD *)a1)
  {
    (*(void (**)(_QWORD, uint64_t, uint64_t, CMSampleBufferRef))a1)(*(_QWORD *)(a1 + 8), a2, a3, sbuf);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      vtEncCallback_cold_1();
  }
  return 0;
}

uint64_t _Enc_SetAverageBitRate(uint64_t a1, int a2)
{
  const void *v4;
  uint64_t v5;
  NSObject *v6;
  int v7;
  int v8;
  CFNumberRef v9;
  int v10;
  int v12;
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  *(_DWORD *)(a1 + 60) = a2;
  v4 = (const void *)(a1 + 60);
  *(_WORD *)(a1 + 252) = 2 * (a2 < 2200001);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v5 = VRTraceErrorLogLevelToCSTR();
    v6 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v7 = *(unsigned __int16 *)(a1 + 252);
      v8 = *(_DWORD *)(a1 + 60);
      v12 = 136316418;
      v13 = v5;
      v14 = 2080;
      v15 = "_Enc_SetAverageBitRate";
      v16 = 1024;
      v17 = 1146;
      v18 = 1024;
      v19 = a2;
      v20 = 1024;
      v21 = v7;
      v22 = 1024;
      v23 = v8;
      _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Set encoder bitrate: %d limitFrameSize: %d dataRate: %d", (uint8_t *)&v12, 0x2Eu);
    }
  }
  v9 = CFNumberCreate(0, kCFNumberIntType, v4);
  v10 = VCPCompressionSessionSetProperty();
  CFRelease(v9);
  if (v10)
    return -v10 | 0xA0080000;
  else
    return 0;
}

__CFArray *_Enc_CopyTemporalArray(const __CFArray *a1, int Count)
{
  __CFArray *Mutable;
  CFIndex v5;
  const void *ValueAtIndex;

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  if (CFArrayGetCount(a1) < Count)
    Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    v5 = 0;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a1, v5);
      CFArrayAppendValue(Mutable, ValueAtIndex);
      ++v5;
    }
    while (Count != v5);
  }
  return Mutable;
}

void OUTLINED_FUNCTION_11_1(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x2Cu);
}

void VCVideoStreamEncoderProc(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  uint64_t v5;
  NSObject *v6;
  opaqueCMSampleBuffer *v7;
  os_signpost_id_t value;
  NSObject *v9;
  uint8_t v10[16];
  CMTime buf;
  int v12;
  __int16 v13;
  const char *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (!dispatch_semaphore_wait(*(dispatch_semaphore_t *)(a1 + 192), 0xFFFFFFFFFFFFFFFFLL))
  {
    if (*(_BYTE *)(a1 + 184))
    {
      *(_BYTE *)(a1 + 184) = 0;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v5 = VRTraceErrorLogLevelToCSTR();
        v6 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf.value) = 136315906;
          *(CMTimeValue *)((char *)&buf.value + 4) = v5;
          LOWORD(buf.flags) = 2080;
          *(_QWORD *)((char *)&buf.flags + 2) = "VCVideoStreamEncoderProc";
          HIWORD(buf.epoch) = 1024;
          v12 = 97;
          v13 = 2080;
          v14 = "com.apple.AVConference.VCVideoStreamTransmitter.encoderThread";
          _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Encoder thread \"%s\" terminated", (uint8_t *)&buf, 0x26u);
        }
      }
      *a3 = 1;
    }
    else if (CMBufferQueueGetBufferCount(*(CMBufferQueueRef *)(a1 + 200)) >= 1)
    {
      v7 = (opaqueCMSampleBuffer *)CMBufferQueueDequeueAndRetain(*(CMBufferQueueRef *)(a1 + 200));
      memset(&buf, 170, sizeof(buf));
      CMSampleBufferGetPresentationTimeStamp(&buf, v7);
      if (*MEMORY[0x1E0CF2760])
      {
        value = buf.value;
        if ((unint64_t)(buf.value - 1) <= 0xFFFFFFFFFFFFFFFDLL)
        {
          v9 = *MEMORY[0x1E0CF2758];
          if (os_signpost_enabled((os_log_t)*MEMORY[0x1E0CF2758]))
          {
            *(_WORD *)v10 = 0;
            _os_signpost_emit_with_name_impl(&dword_1D8A54000, v9, OS_SIGNPOST_EVENT, value, "VideoTransmitter_FrameDequeue", (const char *)&unk_1D91A2482, v10, 2u);
          }
        }
      }
      if (v7)
      {
        objc_msgSend((id)a1, "encodeVideoFrame:", v7);
        CFRelease(v7);
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCVideoStreamEncoderProc_cold_1();
      }
    }
  }
}

uint64_t VCVideoStreamTransmitter_EnqueueVideoFrame(uint64_t a1, const void *a2)
{
  uint64_t result;
  uint64_t v5;
  NSObject *v6;
  _BOOL4 v7;
  const __CFDictionary *Mutable;
  OSStatus v9;
  int v10;
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  uint64_t v16;

  result = 0;
  v16 = *MEMORY[0x1E0C80C00];
  if (a1 && a2)
  {
    if ((int)CMBufferQueueGetBufferCount(*(CMBufferQueueRef *)(a1 + 200)) < 1)
    {
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      FigCFDictionarySetInt32();
      CMSetAttachments(a2, Mutable, 0);
      CFRelease(Mutable);
      v9 = CMBufferQueueEnqueue(*(CMBufferQueueRef *)(a1 + 200), a2);
      result = 0;
      if (!v9)
      {
        dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 192));
        return 1;
      }
    }
    else
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v5 = VRTraceErrorLogLevelToCSTR();
        v6 = *MEMORY[0x1E0CF2758];
        v7 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
        result = 0;
        if (!v7)
          return result;
        v10 = 136315650;
        v11 = v5;
        v12 = 2080;
        v13 = "VCVideoStreamTransmitter_EnqueueVideoFrame";
        v14 = 1024;
        v15 = 262;
        _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Drop a pending frame (encoder). Already has a frame for encoder", (uint8_t *)&v10, 0x1Cu);
      }
      return 0;
    }
  }
  return result;
}

void VCVideoStreamTransmitter_SetFECRatio()
{
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCVideoStreamTransmitter_SetFECRatio_cold_1();
  }
}

void VCVideoStreamTransmitter_SetMediaQueueSize()
{
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCVideoStreamTransmitter_SetMediaQueueSize_cold_1();
  }
}

void encoderFrameCallback(OSQueueHead **a1, unsigned __int8 *a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;

  if (a2)
  {
    v8 = a2[328];
    VCMemoryPool_Free(a1[55], a2);
    if (a3)
      goto LABEL_3;
  }
  else
  {
    v8 = 0;
    if (a3)
    {
LABEL_3:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          encoderFrameCallback_cold_1();
      }
      return;
    }
  }
  if (a5)
    objc_msgSend(a1, "transmitEncodedVideoFrame:cameraStatusBits:", a5, v8);
}

double JitterQueue_Create()
{
  _DWORD *v0;
  double result;

  v0 = malloc_type_malloc(0x48uLL, 0x1020040320C0723uLL);
  if (v0)
  {
    v0[16] = 0;
    result = 0.0;
    *((_OWORD *)v0 + 2) = 0u;
    *((_OWORD *)v0 + 3) = 0u;
    *(_OWORD *)v0 = 0u;
    *((_OWORD *)v0 + 1) = 0u;
  }
  return result;
}

uint64_t *JitterQueue_SetMaxPacketTimeDelta(uint64_t *result, unsigned int a2, double a3)
{
  unsigned int v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  int v10;

  v3 = ((double)a2 * a3);
  *((_DWORD *)result + 4) = v3;
  v4 = *result;
  if (*result)
  {
    v5 = *(_DWORD *)(v4 + 1172);
    v6 = *(_QWORD *)(v4 + 1248);
    if (v6)
    {
      v7 = *(_DWORD *)(v4 + 12);
      do
      {
        v8 = *(_DWORD *)(v6 + 12);
        if (v7 - v8 - *(_DWORD *)(v6 + 1172) > v3 || v7 == v8)
          v10 = *(_DWORD *)(v6 + 1172);
        else
          v10 = v7 - v8;
        v5 += v10;
        v6 = *(_QWORD *)(v6 + 1248);
        v7 = v8;
      }
      while (v6);
    }
    *((_DWORD *)result + 5) = v5;
  }
  else
  {
    *((_DWORD *)result + 5) = 0;
    *((_DWORD *)result + 13) = 0;
    *((_DWORD *)result + 14) = 0;
  }
  return result;
}

uint64_t JitterQueue_SetLastDecodedFrameTimestamp(uint64_t result, int a2)
{
  *(_DWORD *)(result + 24) = a2;
  *(_DWORD *)(result + 32) = 1;
  return result;
}

uint64_t JitterQueue_SetLastDecodedDTMFFrameTimestamp(uint64_t result, int a2)
{
  *(_DWORD *)(result + 28) = a2;
  *(_DWORD *)(result + 36) = 1;
  return result;
}

void JitterQueue_Destroy(uint64_t *a1)
{
  JitterQueue_Reset(a1);
  free(a1);
}

void JitterQueue_Reset(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  int v5;
  uint64_t v6;
  __int16 v7;
  const char *v8;
  __int16 v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v1 = *a1;
  *a1 = 0;
  a1[1] = 0;
  *(uint64_t *)((char *)a1 + 20) = 0;
  *(uint64_t *)((char *)a1 + 36) = 0;
  *(uint64_t *)((char *)a1 + 28) = 0;
  a1[6] = 0;
  a1[7] = 0;
  *((_DWORD *)a1 + 16) = 0;
  if (v1)
  {
    do
    {
      v2 = *(_QWORD *)(v1 + 1248);
      (*(void (**)(_QWORD))(v1 + 1200))(*(_QWORD *)(v1 + 1208));
      v1 = v2;
    }
    while (v2);
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v3 = VRTraceErrorLogLevelToCSTR();
    v4 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v5 = 136315650;
      v6 = v3;
      v7 = 2080;
      v8 = "JitterQueue_Reset";
      v9 = 1024;
      v10 = 386;
      _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Jitter Queue was reset", (uint8_t *)&v5, 0x1Cu);
    }
  }
}

uint64_t JitterQueue_Insert(uint64_t a1, unint64_t a2, _DWORD *a3)
{
  int v5;
  unsigned int v6;
  BOOL v7;
  int v8;
  BOOL v9;
  uint64_t v10;
  int v11;
  int v12;
  int ErrorLogLevelForModule;
  uint64_t v14;
  NSObject *v15;
  NSObject *v16;
  int v17;
  int v18;
  unint64_t *v19;
  unint64_t *i;
  unint64_t v21;
  unint64_t v22;
  unsigned int v23;
  unsigned int v24;
  BOOL v25;
  uint64_t v26;
  uint64_t v27;
  NSObject *v28;
  int v29;
  int v30;
  int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  int v36;
  int v37;
  unsigned int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  uint64_t v45;
  NSObject *v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  uint64_t result;
  unint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  NSObject *v58;
  NSObject *v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  uint64_t v65;
  __int16 v66;
  const char *v67;
  __int16 v68;
  int v69;
  __int16 v70;
  int v71;
  __int16 v72;
  int v73;
  __int16 v74;
  int v75;
  uint64_t v76;

  v76 = *MEMORY[0x1E0C80C00];
  if (a3)
    *a3 = 0;
  ++*(_DWORD *)(a1 + 48);
  v5 = *(_DWORD *)(a1 + 32);
  if (v5)
  {
    if (*(_DWORD *)(a2 + 1196) == 117)
    {
      v5 = 0;
    }
    else
    {
      v6 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a1 + 24);
      if (v6)
        v7 = v6 > 0x7FFFFFFE;
      else
        v7 = 1;
      v5 = v7;
    }
  }
  v8 = *(_DWORD *)(a1 + 36);
  if (v8)
    v8 = *(_DWORD *)(a2 + 1196) == 117 && (*(_DWORD *)(a2 + 12) - *(_DWORD *)(a1 + 28)) > 0x7FFFFFFE;
  if ((v5 | v8) != 1)
  {
    v19 = (unint64_t *)(a1 + 8);
    for (i = (unint64_t *)a1; ; i = (unint64_t *)(v21 + 1248))
    {
      v21 = *i;
      if (!*i)
        break;
      v22 = v21 + 1272;
      v23 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(v21 + 12);
      if (v23)
      {
        if (v23 < 0x7FFFFFFF)
          break;
      }
      else
      {
        if (*(_DWORD *)(v21 + 1196) != 117)
        {
          if (a3)
            *a3 = 1;
          if (*(_BYTE *)(a2 + 8) || !*(_BYTE *)(v21 + 8))
          {
            v21 = a2;
          }
          else
          {
            v54 = a2 + 1272;
            *i = a2;
            v55 = *(_QWORD *)(v21 + 1248);
            *(_QWORD *)(a2 + 1248) = v55;
            v56 = *(_QWORD *)(v21 + 1240);
            *(_QWORD *)(a2 + 1240) = v56;
            if (!v55)
              goto LABEL_88;
            if (v54 <= a2)
              goto LABEL_106;
            *(_QWORD *)(v55 + 1240) = a2;
            v56 = *(_QWORD *)(a2 + 1240);
LABEL_88:
            if (v56)
            {
              if (v54 > a2)
              {
                *(_QWORD *)(v56 + 1248) = a2;
                goto LABEL_91;
              }
              goto LABEL_106;
            }
LABEL_91:
            if (*(_QWORD *)a1 == v21)
            {
              if (v54 <= a2)
                goto LABEL_106;
              *(_QWORD *)a1 = a2;
            }
            if (*v19 == v21)
            {
              if (v54 <= a2)
                goto LABEL_106;
              *v19 = a2;
            }
            if (v21 >= v22)
LABEL_106:
              __break(0x5519u);
            *(_DWORD *)(v21 + 1264) = 0;
          }
          if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            v57 = VRTraceErrorLogLevelToCSTR();
            v58 = *MEMORY[0x1E0CF2758];
            v59 = *MEMORY[0x1E0CF2758];
            if (*MEMORY[0x1E0CF2748])
            {
              if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
              {
                v60 = *(unsigned __int8 *)(v21 + 8);
                v61 = *(_DWORD *)(v21 + 12);
                v64 = 136316162;
                v65 = v57;
                v66 = 2080;
                v67 = "JitterQueue_Insert";
                v68 = 1024;
                v69 = 212;
                v70 = 1024;
                v71 = v60;
                v72 = 1024;
                v73 = v61;
                _os_log_impl(&dword_1D8A54000, v58, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Discarding duplicate audio frame isRedAudio:%d timestamp:%u", (uint8_t *)&v64, 0x28u);
              }
            }
            else if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG))
            {
              JitterQueue_Insert_cold_2(v57, v21, v58);
            }
          }
          (*(void (**)(_QWORD, unint64_t))(v21 + 1200))(*(_QWORD *)(v21 + 1208), v21);
          return 0;
        }
        v24 = *(unsigned __int16 *)(a2 + 10) - *(unsigned __int16 *)(v21 + 10);
        if (v24)
          v25 = v24 >= 0x7FFFFFFF;
        else
          v25 = 1;
        if (!v25)
          break;
      }
      if (v21 >= v22)
        goto LABEL_106;
    }
    *(_QWORD *)(a2 + 1248) = *i;
    *i = a2;
    v26 = *(_QWORD *)(a2 + 1248);
    if (v26)
      v19 = (unint64_t *)(v26 + 1240);
    *(_QWORD *)(a2 + 1240) = *v19;
    *v19 = a2;
    if (!*(_DWORD *)(a1 + 16) && (int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v27 = VRTraceErrorLogLevelToCSTR();
      v28 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        JitterQueue_Insert_cold_1(v27, v28);
    }
    if (*(_BYTE *)(a2 + 8))
      *(_DWORD *)(a2 + 1264) = *(_DWORD *)(a2 + 1260) - *(_DWORD *)(a2 + 12);
    v29 = *(_DWORD *)(a2 + 1172);
    v30 = *(_DWORD *)(a1 + 20);
    v31 = v30 + v29;
    *(_DWORD *)(a1 + 20) = v30 + v29;
    v32 = *(_DWORD *)(a1 + 56) + 1;
    *(_DWORD *)(a1 + 56) = v32;
    v33 = *(_QWORD *)(a2 + 1240);
    v34 = *(_QWORD *)(a2 + 1248);
    if (v33)
    {
      v35 = *(_DWORD *)(v33 + 12);
      if (v34)
      {
        v36 = *(_DWORD *)(v34 + 12);
        v37 = *(_DWORD *)(v34 + 1172);
        v38 = *(_DWORD *)(a1 + 16);
        if (v35 == v36 || v35 - (v36 + v37) > v38)
        {
          v39 = *(_DWORD *)(a2 + 12);
          v40 = v35 - v39;
          if (v40 - v29 > v38)
            v40 = 0;
          v41 = v39 - v36;
          if (v41 - v37 > v38)
            v41 = 0;
          if (v40)
            v42 = (v40 - v29) & ~((v40 - v29) >> 31);
          else
            v42 = 0;
          v43 = (v41 - v37) & ~((v41 - v37) >> 31);
          if (v41)
            v44 = v43;
          else
            v44 = 0;
          v30 = v44 + v31 + v42;
        }
        goto LABEL_75;
      }
      v52 = *(_DWORD *)(a2 + 12);
      if (v35 == v52)
      {
LABEL_76:
        result = 1;
        if (v31 >= 1 && v29 >= 1)
          *(_DWORD *)(a1 + 52) = (v31 - v32 * v29) / v29;
        return result;
      }
      v51 = v35 - (v29 + v52);
    }
    else
    {
      if (!v34)
        goto LABEL_76;
      v49 = *(_DWORD *)(a2 + 12);
      v50 = *(_DWORD *)(v34 + 12);
      if (v49 == v50)
        goto LABEL_76;
      v51 = v49 - (v50 + *(_DWORD *)(v34 + 1172));
    }
    if (v51 <= *(_DWORD *)(a1 + 16))
    {
      v30 = (v51 & ~(v51 >> 31)) + v31;
LABEL_75:
      *(_DWORD *)(a1 + 20) = v30;
      v31 = v30;
      goto LABEL_76;
    }
    goto LABEL_76;
  }
  v9 = v5 == 0;
  v10 = 28;
  if (!v9)
    v10 = 24;
  v11 = *(_DWORD *)(a1 + v10);
  v12 = *(unsigned __int8 *)(a2 + 8);
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (v12)
  {
    if (ErrorLogLevelForModule >= 8)
    {
      v14 = VRTraceErrorLogLevelToCSTR();
      v15 = *MEMORY[0x1E0CF2758];
      v16 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          v17 = *(_DWORD *)(a2 + 12);
          v18 = *(unsigned __int16 *)(a2 + 10);
          v64 = 136316418;
          v65 = v14;
          v66 = 2080;
          v67 = "JitterQueue_Insert";
          v68 = 1024;
          v69 = 189;
          v70 = 1024;
          v71 = v17;
          v72 = 1024;
          v73 = v11;
          v74 = 1024;
          v75 = v18;
          _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Discarding an old redundant frame, timestamp %u, last Decoded %u sequence number %d", (uint8_t *)&v64, 0x2Eu);
        }
      }
      else if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
      {
        v62 = *(_DWORD *)(a2 + 12);
        v63 = *(unsigned __int16 *)(a2 + 10);
        v64 = 136316418;
        v65 = v14;
        v66 = 2080;
        v67 = "JitterQueue_Insert";
        v68 = 1024;
        v69 = 189;
        v70 = 1024;
        v71 = v62;
        v72 = 1024;
        v73 = v11;
        v74 = 1024;
        v75 = v63;
        _os_log_debug_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Discarding an old redundant frame, timestamp %u, last Decoded %u sequence number %d", (uint8_t *)&v64, 0x2Eu);
      }
    }
  }
  else
  {
    if (ErrorLogLevelForModule >= 5)
    {
      v45 = VRTraceErrorLogLevelToCSTR();
      v46 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v47 = *(_DWORD *)(a2 + 1196);
        v48 = *(_DWORD *)(a2 + 12);
        v64 = 136316418;
        v65 = v45;
        v66 = 2080;
        v67 = "JitterQueue_Insert";
        v68 = 1024;
        v69 = 183;
        v70 = 1024;
        v71 = v47;
        v72 = 1024;
        v73 = v48;
        v74 = 1024;
        v75 = v11;
        _os_log_impl(&dword_1D8A54000, v46, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Discarding an old primary frame, payloadType=%d, timestamp=%u, lastDecoded=%u", (uint8_t *)&v64, 0x2Eu);
      }
    }
    ++*(_DWORD *)(a1 + 40);
    if (!*(_DWORD *)(a2 + 1176))
      ++*(_DWORD *)(a1 + 44);
  }
  (*(void (**)(_QWORD, unint64_t))(a2 + 1200))(*(_QWORD *)(a2 + 1208), a2);
  return 0;
}

unint64_t JitterQueue_Pop(uint64_t a1)
{
  unint64_t result;
  unint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  unsigned int v8;
  int v9;
  int v10;
  int v12;
  int v13;
  int v14;

  result = *(_QWORD *)(a1 + 8);
  if (result)
  {
    v3 = result + 1272;
    v4 = *(_QWORD *)(result + 1240);
    if (v4)
    {
      *(_QWORD *)(v4 + 1248) = 0;
      *(_QWORD *)(a1 + 8) = v4;
      if (result >= v3)
        goto LABEL_16;
      v5 = *(_DWORD *)(v4 + 12);
      v6 = *(_DWORD *)(result + 12);
      v7 = *(_DWORD *)(result + 1172);
      v8 = *(_DWORD *)(a1 + 16);
      v9 = *(_DWORD *)(a1 + 20);
      v10 = *(_DWORD *)(a1 + 56) - 1;
      *(_DWORD *)(a1 + 56) = v10;
      if (v5 - v6 - v7 > v8 || v5 == v6)
        v12 = v7;
      else
        v12 = v5 - v6;
      v13 = v9 - v12;
      *(_DWORD *)(a1 + 20) = v13;
      if (v13 >= 1)
      {
        v14 = *(_DWORD *)(result + 1172);
        if (v14 >= 1)
          *(_DWORD *)(a1 + 52) = (v13 - v10 * v14) / v14;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 20) = 0;
      *(_DWORD *)(a1 + 52) = 0;
      *(_DWORD *)(a1 + 56) = 0;
      *(_QWORD *)a1 = 0;
      *(_QWORD *)(a1 + 8) = 0;
    }
    if (result < v3)
      return result;
LABEL_16:
    __break(0x5519u);
  }
  return result;
}

unint64_t JitterQueue_Purge(unint64_t result, uint64_t (*a2)(void))
{
  uint64_t v2;

  if (a2)
  {
    v2 = result;
    for (result = *(_QWORD *)(result + 8); result; result = *(_QWORD *)(v2 + 8))
    {
      result = a2();
      if (!(_DWORD)result)
        break;
      result = JitterQueue_Pop(v2);
      if (result && result >= result + 1272)
      {
        __break(0x5519u);
        return result;
      }
      (*(void (**)(_QWORD))(result + 1200))(*(_QWORD *)(result + 1208));
    }
  }
  return result;
}

uint64_t JitterQueue_CheckQSizeBeforePop(uint64_t result)
{
  unint64_t v1;
  uint64_t v2;
  int v3;
  int v4;
  int v5;
  unsigned int v6;
  int v7;
  int v8;
  BOOL v9;

  v1 = *(_QWORD *)(result + 8);
  if (!v1)
    return 0;
  v2 = *(_QWORD *)(v1 + 1240);
  if (!v2)
    return 0;
  if (v1 >= v1 + 1272)
  {
    __break(0x5519u);
  }
  else
  {
    v3 = *(_DWORD *)(v2 + 12);
    v4 = *(_DWORD *)(v1 + 12);
    v5 = *(_DWORD *)(v1 + 1172);
    v6 = v3 - v4 - v5;
    v7 = v3 - v4;
    v8 = *(_DWORD *)(result + 20);
    if (v7)
      v9 = v6 > *(_DWORD *)(result + 16);
    else
      v9 = 1;
    if (v9)
      return (v8 - v5);
    else
      return (v8 - v7);
  }
  return result;
}

BOOL JitterQueue_IsEmpty(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8) == 0;
}

uint64_t JitterQueue_GetSizeOfNextFrame(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 8);
  if (v1)
    return *(unsigned int *)(v1 + 1172);
  else
    return 0;
}

BOOL JitterQueue_GetOldestArrivalTimeStamp(uint64_t a1, _DWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  if (v2)
    *a2 = *(_DWORD *)(v2 + 1192);
  return v2 != 0;
}

BOOL JitterQueue_HasDTXPacket(uint64_t a1)
{
  uint64_t v1;
  int v2;
  _BOOL8 result;

  v1 = *(_QWORD *)(a1 + 8);
  if (!v1)
    return 0;
  do
  {
    v2 = *(_DWORD *)(v1 + 1176);
    result = v2 != 0;
    if (v2)
      break;
    v1 = *(_QWORD *)(v1 + 1240);
  }
  while (v1);
  return result;
}

uint64_t JitterQueue_QueueEmptyOrAllDTX(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    v1 = *(_QWORD *)(result + 8);
    if (v1)
    {
      do
        v1 = *(_QWORD *)(v1 + 1240);
      while (v1);
      return 0;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

BOOL JitterQueue_IsNextFrameDTX(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 8);
  return !v1 || *(_DWORD *)(v1 + 1176);
}

BOOL JitterQueue_IsNextFrameDTMF(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 8);
  return v1 && *(_DWORD *)(v1 + 1196) == 117;
}

BOOL JitterQueue_IsNextFrameMarkerSet(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 8);
  return v1 && *(_DWORD *)(v1 + 4) == 1;
}

uint64_t JitterQueue_QueuedSamples(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

void JitterQueue_DiscardExcess(uint64_t *a1, int a2)
{
  uint64_t v3;
  int v5;
  int v6;
  unint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t i;
  int v11;
  int v13;
  uint64_t v14;
  NSObject *v15;
  int v16;
  int v17;
  uint64_t v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v3 = *a1;
  if (*a1)
  {
    while (1)
    {
      v5 = *(_DWORD *)(v3 + 1172);
      v6 = *(_DWORD *)(v3 + 12);
      v7 = a1[1];
      if (v6 + v5 - *(_DWORD *)(v7 + 12) <= (*(_DWORD *)(v7 + 1172) + a2))
        break;
      v8 = *(_QWORD *)(v7 + 1240);
      v9 = (_QWORD *)(v8 + 1248);
      if (!v8)
        v9 = a1;
      *v9 = 0;
      a1[1] = v8;
      if (v7 >= v7 + 1272)
        __break(0x5519u);
      (*(void (**)(_QWORD))(v7 + 1200))(*(_QWORD *)(v7 + 1208));
      v3 = *a1;
      if (!*a1)
        goto LABEL_7;
    }
    for (i = *(_QWORD *)(v3 + 1248); i; v6 = v11)
    {
      v11 = *(_DWORD *)(i + 12);
      if ((v6 - v11 - *(_DWORD *)(i + 1172)) > *((_DWORD *)a1 + 4) || v6 == v11)
        v13 = *(_DWORD *)(i + 1172);
      else
        v13 = v6 - v11;
      v5 += v13;
      i = *(_QWORD *)(i + 1248);
    }
    *((_DWORD *)a1 + 5) = v5;
  }
  else
  {
LABEL_7:
    *((_DWORD *)a1 + 5) = 0;
    *((_DWORD *)a1 + 13) = 0;
    *((_DWORD *)a1 + 14) = 0;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v14 = VRTraceErrorLogLevelToCSTR();
    v15 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v16 = *((_DWORD *)a1 + 5);
      v17 = 136315906;
      v18 = v14;
      v19 = 2080;
      v20 = "JitterQueue_DiscardExcess";
      v21 = 1024;
      v22 = 408;
      v23 = 1024;
      v24 = v16;
      _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Discard excess performed. New size=%d", (uint8_t *)&v17, 0x22u);
    }
  }
}

_DWORD *JitterQueue_GetUnderflowRateForInterval(_DWORD *result)
{
  int v1;

  v1 = result[10];
  result[15] = result[12];
  result[16] = v1;
  return result;
}

float JitterQueue_GetUnderflowRate(uint64_t a1)
{
  int v1;

  v1 = *(_DWORD *)(a1 + 48);
  if (v1)
    return (float)*(int *)(a1 + 40) / (float)v1;
  else
    return 0.0;
}

_DWORD *JitterQueue_ResetUnderflowRate(_DWORD *result)
{
  result[10] = 0;
  result[12] = 0;
  result[15] = 0;
  result[16] = 0;
  return result;
}

uint64_t JitterQueue_GetSpeechUnderflowCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 44);
}

BOOL JitterQueue_GetNextFrameTimestamp(uint64_t a1, _DWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  if (v2)
    *a2 = *(_DWORD *)(v2 + 12);
  return v2 != 0;
}

uint64_t JitterQueue_GetLastFramePriority(uint64_t result, _BYTE *a2, BOOL *a3)
{
  uint64_t v3;

  if (result)
  {
    v3 = *(_QWORD *)(result + 8);
    if (v3)
    {
      if (a2)
        *a2 = *(_BYTE *)(v3 + 1232);
      if (a3)
        *a3 = *(_QWORD *)(*(_QWORD *)(result + 8) + 1240) == 0;
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t JitterQueue_GetTimestampDeltaToNextDTXPacket(uint64_t a1, _DWORD *a2)
{
  uint64_t result;
  uint64_t v4;
  int v5;

  result = 0;
  if (a1 && a2)
  {
    v4 = *(_QWORD *)(a1 + 8);
    if (v4)
    {
      v5 = *(_DWORD *)(v4 + 12);
      while (!*(_DWORD *)(v4 + 1176))
      {
        v4 = *(_QWORD *)(v4 + 1240);
        if (!v4)
          goto LABEL_7;
      }
      LODWORD(v4) = *(_DWORD *)(v4 + 12) - v5;
      result = 1;
    }
    else
    {
LABEL_7:
      result = 0;
    }
    *a2 = v4;
  }
  return result;
}

uint64_t VCNWConnectionMonitor_Create(_QWORD *a1)
{
  NSObject *v2;
  uint64_t v3;
  _QWORD block[6];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a1 && *a1)
  {
    v6 = 0;
    v7 = &v6;
    v8 = 0x2000000000;
    v9 = 0;
    v2 = VTP_NWConnectionQueue();
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __VCNWConnectionMonitor_Create_block_invoke;
    block[3] = &unk_1E9E53898;
    block[4] = &v6;
    block[5] = a1;
    dispatch_sync(v2, block);
    v3 = v7[3];
    _Block_object_dispose(&v6, 8);
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCNWConnectionMonitor_Create_cold_1();
    }
    return 0;
  }
  return v3;
}

uint64_t VCNWConnectionMonitor_CreateWithInterfaceName(uint64_t a1, int a2, char a3, uint64_t a4, uint64_t a5)
{
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  _QWORD block[8];
  char v15;
  _BYTE buf[24];
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a1 && a2)
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2000000000;
    v17 = 0;
    v9 = VTP_NWConnectionQueue();
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __VCNWConnectionMonitor_CreateWithInterfaceName_block_invoke;
    block[3] = &unk_1E9E538C0;
    v15 = a3;
    block[4] = a5;
    block[5] = buf;
    block[6] = a1;
    block[7] = a4;
    dispatch_sync(v9, block);
    v10 = *(_QWORD *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v11 = VRTraceErrorLogLevelToCSTR();
      v12 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = v11;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "VCNWConnectionMonitor_CreateWithInterfaceName";
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v17) = 174;
        _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Monitor cannot be created with an invalid interfaceName", buf, 0x1Cu);
      }
    }
    return 0;
  }
  return v10;
}

void VCNWConnectionMonitor_Destroy(uint64_t a1)
{
  int ErrorLogLevelForModule;
  uint64_t v3;
  NSObject *v4;
  NSObject *v5;
  uint64_t v6;
  NSObject *v7;
  _QWORD block[5];
  uint8_t buf[4];
  uint64_t v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (a1)
  {
    if (ErrorLogLevelForModule >= 7)
    {
      v3 = VRTraceErrorLogLevelToCSTR();
      v4 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        v10 = v3;
        v11 = 2080;
        v12 = "VCNWConnectionMonitor_Destroy";
        v13 = 1024;
        v14 = 205;
        v15 = 2048;
        v16 = a1;
        _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Destroying monitor=%p", buf, 0x26u);
      }
    }
    v5 = VTP_NWConnectionQueue();
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __VCNWConnectionMonitor_Destroy_block_invoke;
    block[3] = &__block_descriptor_tmp_3_0;
    block[4] = a1;
    dispatch_sync(v5, block);
  }
  else if (ErrorLogLevelForModule >= 7)
  {
    v6 = VRTraceErrorLogLevelToCSTR();
    v7 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      v10 = v6;
      v11 = 2080;
      v12 = "VCNWConnectionMonitor_Destroy";
      v13 = 1024;
      v14 = 210;
      _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d monitor is null!", buf, 0x1Cu);
    }
  }
}

void _VCNWConnectionMonitor_DispatchedProcessInterfaceAdvisoryNotification(uint64_t a1, void (*a2)(uint64_t, void *), __int128 *a3)
{
  NSObject *v6;
  void *v7;
  void *v8;

  v6 = VTP_NWConnectionQueue();
  dispatch_assert_queue_V2(v6);
  if (a2)
  {
    v7 = malloc_type_calloc(1uLL, 0x68uLL, 0x10000405DD82A02uLL);
    if (v7)
    {
      v8 = v7;
      VCNWConnectionMonitorUtils_GetNotificationFromAdvisory(a3, (uint64_t)v7);
      a2(a1, v8);
      free(v8);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCNWConnectionMonitor_DispatchedProcessInterfaceAdvisoryNotification_cold_1();
    }
  }
}

void VCNWConnectionMonitor_SetNotificationHandler(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  _QWORD v12[8];
  uint8_t buf[4];
  uint64_t v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  _QWORD *v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (a1 && a3 && a4 && *a1)
  {
    v8 = VTP_NWConnectionQueue();
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 0x40000000;
    v12[2] = __VCNWConnectionMonitor_SetNotificationHandler_block_invoke;
    v12[3] = &__block_descriptor_tmp_4;
    v12[4] = a1;
    v12[5] = a2;
    v12[6] = a3;
    v12[7] = a4;
    dispatch_async(v8, v12);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v9 = VRTraceErrorLogLevelToCSTR();
    v10 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      if (a1)
        v11 = *a1;
      else
        v11 = 0;
      *(_DWORD *)buf = 136316674;
      v14 = v9;
      v15 = 2080;
      v16 = "VCNWConnectionMonitor_SetNotificationHandler";
      v17 = 1024;
      v18 = 271;
      v19 = 2048;
      v20 = a1;
      v21 = 2048;
      v22 = a4;
      v23 = 2048;
      v24 = a3;
      v25 = 2048;
      v26 = v11;
      _os_log_error_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_ERROR, " [%s] %s:%d Monitor, handler or context cannot be NULL, monitor=%p, handler=%p, context=%p, monitor->nwMonitor=%p", buf, 0x44u);
    }
  }
}

void VCNWConnectionMonitor_SetPacketEventHandler(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  _QWORD v12[8];
  uint8_t buf[4];
  uint64_t v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  _QWORD *v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (a1 && a3 && a4 && *a1)
  {
    v8 = VTP_NWConnectionQueue();
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 0x40000000;
    v12[2] = __VCNWConnectionMonitor_SetPacketEventHandler_block_invoke;
    v12[3] = &__block_descriptor_tmp_5;
    v12[4] = a1;
    v12[5] = a2;
    v12[6] = a3;
    v12[7] = a4;
    dispatch_async(v8, v12);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v9 = VRTraceErrorLogLevelToCSTR();
    v10 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      if (a1)
        v11 = *a1;
      else
        v11 = 0;
      *(_DWORD *)buf = 136316674;
      v14 = v9;
      v15 = 2080;
      v16 = "VCNWConnectionMonitor_SetPacketEventHandler";
      v17 = 1024;
      v18 = 315;
      v19 = 2048;
      v20 = a1;
      v21 = 2048;
      v22 = a4;
      v23 = 2048;
      v24 = a3;
      v25 = 2048;
      v26 = v11;
      _os_log_error_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_ERROR, " [%s] %s:%d monitor, handler or context cannot be NULL, monitor=%p, handler=%p, context=%p monitor->nwMonitor=%p", buf, 0x44u);
    }
  }
}

void _VCNWConnectionMonitor_AddNotification(uint64_t a1, __int128 *a2)
{
  __int128 v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  _OWORD *v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  int v11;
  __int16 v12;

  if (a1)
  {
    v2 = *a2;
    *(_OWORD *)(a1 + 24048) = a2[1];
    *(_OWORD *)(a1 + 24032) = v2;
    v3 = a2[2];
    v4 = a2[3];
    v5 = a2[4];
    *(_OWORD *)(a1 + 24112) = a2[5];
    *(_OWORD *)(a1 + 24096) = v5;
    *(_OWORD *)(a1 + 24080) = v4;
    *(_OWORD *)(a1 + 24064) = v3;
    v6 = (_OWORD *)(a1 + 96 * *(__int16 *)(a1 + 26));
    v7 = a2[1];
    v6[2] = *a2;
    v6[3] = v7;
    v9 = a2[4];
    v8 = a2[5];
    v10 = a2[3];
    v6[4] = a2[2];
    v6[5] = v10;
    v6[6] = v9;
    v6[7] = v8;
    *(_WORD *)(a1 + 26) = (*(__int16 *)(a1 + 26) + 1) % 250;
    v11 = *(__int16 *)(a1 + 24);
    if (v11 < 249)
      v12 = v11 + 1;
    else
      v12 = 250;
    *(_WORD *)(a1 + 24) = v12;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCNWConnectionMonitor_AddNotification_cold_1();
  }
}

void _VCNWConnectionMonitor_LogSignalsAndMetrics(uint64_t a1, uint64_t a2)
{
  VRLogfilePrintWithTimestamp(*(_QWORD *)(a1 + 16), "%llu\t%u\t%u\t%llu\t%llu\t%u\t%u\t%u\t%llu\t%u\t%d\t%u\t%u\t%u\t%u\t0x%x\t%u\t%u\t%u\t%u\t%u\t%2.4f\t%u\t%u\t%u\t%u\t%u\t%u\t%u\n", *(unsigned __int8 *)(a2 + 70), *(unsigned __int8 *)(a2 + 71), *(unsigned __int8 *)(a2 + 73), *(unsigned __int8 *)(a2 + 72), *(unsigned __int8 *)(a2 + 75), *(unsigned __int8 *)(a2 + 74), *(_QWORD *)(a2 + 8));
}

__n128 _VCNWConnectionMonitor_CopyNetworkSignals(uint64_t a1, uint64_t a2)
{
  int v2;
  unsigned int v3;
  unsigned int v4;
  __n128 result;

  *(_BYTE *)a2 = *(_BYTE *)(a1 + 24032);
  *(_BYTE *)(a2 + 1) = *(_BYTE *)(a1 + 24033);
  *(_QWORD *)(a2 + 8) = *(_QWORD *)(a1 + 24040);
  *(_QWORD *)(a2 + 16) = *(_QWORD *)(a1 + 24048);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24056);
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(a1 + 24072);
  *(_DWORD *)(a2 + 36) = *(_DWORD *)(a1 + 24076);
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a1 + 24080);
  *(_QWORD *)(a2 + 48) = *(_QWORD *)(a1 + 24064);
  *(_DWORD *)(a2 + 56) = *(_DWORD *)(a1 + 24036);
  *(_BYTE *)(a2 + 64) = *(_BYTE *)(a1 + 24084);
  *(_BYTE *)(a2 + 65) = *(_BYTE *)(a1 + 24085);
  *(_WORD *)(a2 + 66) = *(_WORD *)(a1 + 24086);
  v2 = *(unsigned __int16 *)(a1 + 24088);
  if (v2 == 0xFFFF)
    LOWORD(v2) = 0;
  *(_WORD *)(a2 + 68) = v2;
  *(_BYTE *)(a2 + 70) = *(_BYTE *)(a1 + 24090);
  *(_BYTE *)(a2 + 73) = *(_BYTE *)(a1 + 24091) & 0xF;
  *(_BYTE *)(a2 + 72) = *(_BYTE *)(a1 + 24091) >> 4;
  *(_BYTE *)(a2 + 75) = *(_BYTE *)(a1 + 24092) & 0xF;
  *(_BYTE *)(a2 + 74) = *(_BYTE *)(a1 + 24092) >> 4;
  *(_BYTE *)(a2 + 76) = *(_BYTE *)(a1 + 24093);
  v3 = *(unsigned __int8 *)(a1 + 24094);
  *(_BYTE *)(a2 + 71) = v3;
  if (*(_DWORD *)(a1 + 24144) > v3)
    v3 = *(_DWORD *)(a1 + 24144);
  *(_DWORD *)(a1 + 24144) = v3;
  *(_BYTE *)(a2 + 112) = v3;
  v4 = *(unsigned __int16 *)(a2 + 68);
  if (*(unsigned __int16 *)(a1 + 24160) > v4)
    LOWORD(v4) = *(_WORD *)(a1 + 24160);
  *(_WORD *)(a1 + 24160) = v4;
  *(_WORD *)(a2 + 128) = v4;
  *(_WORD *)(a2 + 86) = *(_WORD *)(a1 + 24095);
  result = *(__n128 *)(a1 + 24097);
  *(_QWORD *)(a2 + 104) = *(_QWORD *)(a1 + 24113);
  *(__n128 *)(a2 + 88) = result;
  return result;
}

double _VCNWConnectionMonitor_ComputeMetrics(uint64_t a1, uint64_t a2, double a3, double a4, float32x4_t a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  unsigned __int8 v10;
  float32x4_t v11;
  float v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint32x4_t v18;
  uint64_t v19;
  BOOL v20;
  BOOL v21;
  char v22;
  float64x2_t v23;
  float32x4_t v24;
  float v25;
  float v26;
  int v27;
  BOOL v29;
  uint64_t v30;
  double result;
  uint64_t v32;
  NSObject *v33;
  NSObject *v34;
  double v35;
  int v36;
  double v37;
  int v38;
  int v39;
  uint64_t v40;
  __int16 v41;
  const char *v42;
  __int16 v43;
  int v44;
  __int16 v45;
  uint64_t v46;
  __int16 v47;
  uint64_t v48;
  __int16 v49;
  double v50;
  __int16 v51;
  int v52;
  __int16 v53;
  int v54;
  uint64_t v55;

  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v55 = *MEMORY[0x1E0C80C00];
  v11 = 0uLL;
  v12 = 0.0;
  v13 = 250;
  while (1)
  {
    v14 = a1
        + 96
        * (__int16)(*(_WORD *)(a1 + 26)
                  + 249
                  + v6
                  - 250
                  * (((unint64_t)(274877907 * (*(__int16 *)(a1 + 26) + 249 + (int)v6)) >> 36)
                   + ((unint64_t)(274877907 * (*(__int16 *)(a1 + 26) + 249 + (int)v6)) >> 63)));
    v15 = *(_QWORD *)(v14 + 40);
    if (!v7)
      v7 = *(_QWORD *)(v14 + 40);
    v16 = v7 - v15;
    if (v7 - v15 > *(unsigned int *)(a1 + 24164))
      break;
    v17 = v14 + 32;
    a5.i32[0] = *(unsigned __int8 *)(v17 + 59);
    a5.i32[1] = *(unsigned __int8 *)(v17 + 60);
    v18 = (uint32x4_t)vzip1q_s32((int32x4_t)a5, (int32x4_t)a5);
    a5 = vcvtq_f32_s32(vtrn2q_s32(vrev64q_s32((int32x4_t)vshrq_n_u32(v18, 4uLL)), (int32x4_t)(*(_OWORD *)&v18 & __PAIR128__(0xFFFFFF0FFFFFFF0FLL, 0xFFFFFF0FFFFFFF0FLL))));
    v11 = vaddq_f32(v11, a5);
    a5.i8[0] = *(_BYTE *)(v17 + 61);
    v12 = v12 + (float)a5.u32[0];
    v20 = v9 == 1;
    v9 = *(unsigned __int8 *)(v17 + 53);
    v19 = *(unsigned __int16 *)(v17 + 54);
    v20 = !v20 && v9 == 1;
    v21 = !v20 || v19 == 0xFFFF;
    v22 = v21;
    v10 += v22 ^ 1;
    if (v21)
      v19 = 0;
    v8 += v19;
    if (--v6 == -250)
      goto LABEL_20;
  }
  if (v6)
  {
    v13 = -v6;
LABEL_20:
    v23 = (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)v13), 0);
    v24 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(*(float32x2_t *)v11.f32), v23)), vdivq_f64(vcvt_hight_f64_f32(v11), v23));
    v25 = v12 / (double)v13;
    goto LABEL_21;
  }
  v24 = 0uLL;
  v25 = 0.0;
LABEL_21:
  *(float32x4_t *)(a2 + 132) = v24;
  *(float *)(a2 + 148) = v25;
  v26 = 0.0;
  if (v7 != v15)
    v26 = (float)v8 / (float)v16;
  *(float *)(a2 + 80) = v26;
  v27 = v10;
  v29 = v10 > 2u || v8 > 4999;
  *(_BYTE *)(a2 + 84) = v29;
  v30 = *(_QWORD *)(a1 + 24152) + v8;
  *(_QWORD *)(a1 + 24152) = v30;
  *(_QWORD *)(a2 + 120) = v30;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v32 = VRTraceErrorLogLevelToCSTR();
    v33 = *MEMORY[0x1E0CF2758];
    v34 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        v35 = *(float *)(a2 + 80);
        v36 = *(unsigned __int8 *)(a2 + 84);
        v39 = 136316930;
        v40 = v32;
        v41 = 2080;
        v42 = "_VCNWConnectionMonitor_ComputeMetrics";
        v43 = 1024;
        v44 = 469;
        v45 = 2048;
        v46 = v16;
        v47 = 2048;
        v48 = v8;
        v49 = 2048;
        v50 = v35;
        v51 = 1024;
        v52 = v27;
        v53 = 1024;
        v54 = v36;
        _os_log_impl(&dword_1D8A54000, v33, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Off Channel Metrics currentTimeDelta=%llu accumulatedOffChannelTime=%llu statistics->offChannelTimeRatio=%4.4f offChannelSwitchCount=%u statistics->detectedFrequentOffChannelActivity=%d", (uint8_t *)&v39, 0x46u);
      }
    }
    else if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
    {
      v37 = *(float *)(a2 + 80);
      v38 = *(unsigned __int8 *)(a2 + 84);
      v39 = 136316930;
      v40 = v32;
      v41 = 2080;
      v42 = "_VCNWConnectionMonitor_ComputeMetrics";
      v43 = 1024;
      v44 = 469;
      v45 = 2048;
      v46 = v16;
      v47 = 2048;
      v48 = v8;
      v49 = 2048;
      v50 = v37;
      v51 = 1024;
      v52 = v27;
      v53 = 1024;
      v54 = v38;
      _os_log_debug_impl(&dword_1D8A54000, v33, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Off Channel Metrics currentTimeDelta=%llu accumulatedOffChannelTime=%llu statistics->offChannelTimeRatio=%4.4f offChannelSwitchCount=%u statistics->detectedFrequentOffChannelActivity=%d", (uint8_t *)&v39, 0x46u);
    }
  }
  return result;
}

void _VCNWConnectionMonitor_ProcessNotification(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int ErrorLogLevelForModule;
  uint64_t v7;
  NSObject *v8;
  NSObject *v9;
  uint64_t v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  double v14;
  double v15;
  float32x4_t v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  _BYTE v21[48];
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)(a3 + 144) = 0;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 128) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (a2)
  {
    if (ErrorLogLevelForModule >= 8)
    {
      v7 = VRTraceErrorLogLevelToCSTR();
      v8 = *MEMORY[0x1E0CF2758];
      v9 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          v10 = *(_QWORD *)(a2 + 8);
          *(_DWORD *)v21 = 136315906;
          *(_QWORD *)&v21[4] = v7;
          *(_WORD *)&v21[12] = 2080;
          *(_QWORD *)&v21[14] = "_VCNWConnectionMonitor_ProcessNotification";
          *(_WORD *)&v21[22] = 1024;
          *(_DWORD *)&v21[24] = 478;
          *(_WORD *)&v21[28] = 2048;
          *(_QWORD *)&v21[30] = v10;
          _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d  timestamp%llu", v21, 0x26u);
        }
      }
      else if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        _VCNWConnectionMonitor_ProcessNotification_cold_3();
      }
    }
    if (*(_BYTE *)a2 == 2)
    {
      v11 = *(_OWORD *)(a2 + 48);
      *(_OWORD *)&v21[32] = *(_OWORD *)(a2 + 32);
      v22 = v11;
      v12 = *(_OWORD *)(a2 + 80);
      v23 = *(_OWORD *)(a2 + 64);
      v24 = v12;
      v13 = *(_OWORD *)(a2 + 16);
      *(_OWORD *)v21 = *(_OWORD *)a2;
      *(_OWORD *)&v21[16] = v13;
      _VCNWConnectionMonitor_AddNotification(a1, (__int128 *)v21);
      *(_QWORD *)&v14 = _VCNWConnectionMonitor_CopyNetworkSignals(a1, a3).n128_u64[0];
      _VCNWConnectionMonitor_ComputeMetrics(a1, a3, v14, v15, v16);
      v17 = *(_OWORD *)(a3 + 112);
      v25 = *(_OWORD *)(a3 + 96);
      v26 = v17;
      v27 = *(_OWORD *)(a3 + 128);
      v28 = *(_QWORD *)(a3 + 144);
      v18 = *(_OWORD *)(a3 + 48);
      *(_OWORD *)&v21[32] = *(_OWORD *)(a3 + 32);
      v22 = v18;
      v19 = *(_OWORD *)(a3 + 80);
      v23 = *(_OWORD *)(a3 + 64);
      v24 = v19;
      v20 = *(_OWORD *)(a3 + 16);
      *(_OWORD *)v21 = *(_OWORD *)a3;
      *(_OWORD *)&v21[16] = v20;
      _VCNWConnectionMonitor_LogSignalsAndMetrics(a1, (uint64_t)v21);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCNWConnectionMonitor_ProcessNotification_cold_2();
    }
  }
  else if (ErrorLogLevelForModule >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCNWConnectionMonitor_ProcessNotification_cold_1();
  }
}

void VCNWConnectionMonitor_SetStatisticsHandler(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  _QWORD v14[8];
  uint8_t buf[4];
  uint64_t v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  _QWORD *v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  uint64_t v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  if (a1 && a3 && a4 && *a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v8 = VRTraceErrorLogLevelToCSTR();
      v9 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        v16 = v8;
        v17 = 2080;
        v18 = "VCNWConnectionMonitor_SetStatisticsHandler";
        v19 = 1024;
        v20 = 538;
        v21 = 2048;
        v22 = a1;
        _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d monitor=%p", buf, 0x26u);
      }
    }
    v10 = VTP_NWConnectionQueue();
    v14[0] = MEMORY[0x1E0C809B0];
    v14[1] = 0x40000000;
    v14[2] = __VCNWConnectionMonitor_SetStatisticsHandler_block_invoke;
    v14[3] = &__block_descriptor_tmp_7_0;
    v14[4] = a1;
    v14[5] = a2;
    v14[6] = a3;
    v14[7] = a4;
    dispatch_async(v10, v14);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v11 = VRTraceErrorLogLevelToCSTR();
    v12 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      if (a1)
        v13 = *a1;
      else
        v13 = 0;
      *(_DWORD *)buf = 136316674;
      v16 = v11;
      v17 = 2080;
      v18 = "VCNWConnectionMonitor_SetStatisticsHandler";
      v19 = 1024;
      v20 = 535;
      v21 = 2048;
      v22 = a1;
      v23 = 2048;
      v24 = a4;
      v25 = 2048;
      v26 = a3;
      v27 = 2048;
      v28 = v13;
      _os_log_error_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_ERROR, " [%s] %s:%d Monitor, handler or context cannot be NULL, monitor=%p, handler=%p, context=%p, monitor->nwMonitor=%p", buf, 0x44u);
    }
  }
}

void VCNWConnectionMonitor_ResetWlanStats(uint64_t a1)
{
  if (a1)
  {
    *(_QWORD *)(a1 + 24152) = 0;
    *(_DWORD *)(a1 + 24144) = 0;
    *(_WORD *)(a1 + 24160) = 0;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCNWConnectionMonitor_ResetWlanStats_cold_1();
  }
}

void _VCNWConnectionMonitor_CheckAndReleaseNWMonitor(_QWORD **a1)
{
  NSObject *v2;
  _QWORD *v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  int v7;
  uint64_t v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  _QWORD *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v2 = VTP_NWConnectionQueue();
  dispatch_assert_queue_V2(v2);
  v3 = *a1;
  if (*a1 && !v3[1] && !*v3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v4 = VRTraceErrorLogLevelToCSTR();
      v5 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v7 = 136315906;
        v8 = v4;
        v9 = 2080;
        v10 = "_VCNWConnectionMonitor_CheckAndReleaseNWMonitor";
        v11 = 1024;
        v12 = 52;
        v13 = 2048;
        v14 = v3;
        _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d monitor=%p is released", (uint8_t *)&v7, 0x26u);
      }
    }
    v6 = v3[3017];
    if (v6)
      dispatch_release(v6);
    free(v3);
    *a1 = 0;
  }
}

uint64_t videoOrientationForCameraStatusBits(char a1)
{
  if (a1 < 0)
    return ((uint64_t (*)(uint64_t))((char *)sub_1D8B24158 + 4 * byte_1D910ADC8[a1 & 3]))(1);
  else
    return 0;
}

uint64_t sub_1D8B24158()
{
  return 3;
}

uint64_t sub_1D8B24160()
{
  unsigned int v0;

  return (v0 >> 2) ^ 2;
}

uint64_t sub_1D8B2416C()
{
  unsigned int v0;

  return v0 >> 2;
}

uint64_t videoOrientationInRadiansForCameraStatusBits@<X0>(uint64_t result@<X0>, _OWORD *a2@<X8>)
{
  uint64_t v2;
  __int128 v3;

  v2 = MEMORY[0x1E0C9BAA8];
  v3 = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 16);
  *a2 = *MEMORY[0x1E0C9BAA8];
  a2[1] = v3;
  a2[2] = *(_OWORD *)(v2 + 32);
  if ((result & 0x80) != 0)
    return ((uint64_t (*)(double))((char *)sub_1D8B241B8 + 4 * byte_1D910ADCC[result & 3]))(1.57079633);
  return result;
}

CGAffineTransform *sub_1D8B241B8@<X0>(CGAffineTransform *a1@<X8>)
{
  return CGAffineTransformMakeRotation(a1, 4.71238898);
}

CGAffineTransform *sub_1D8B241C4@<X0>(char a1@<W0>, CGAffineTransform *a2@<X8>)
{
  double v2;

  v2 = 3.14159265;
  if ((a1 & 8) != 0)
    v2 = 0.0;
  return CGAffineTransformMakeRotation(a2, v2);
}

CGAffineTransform *sub_1D8B241DC@<X0>(char a1@<W0>, CGAffineTransform *a2@<X8>)
{
  double v2;

  v2 = 3.14159265;
  if ((a1 & 8) == 0)
    v2 = 0.0;
  return CGAffineTransformMakeRotation(a2, v2);
}

void OUTLINED_FUNCTION_6_4(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x26u);
}

void OUTLINED_FUNCTION_7_4(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_debug_impl(a1, log, OS_LOG_TYPE_DEBUG, a4, (uint8_t *)va, 0x26u);
}

uint64_t _VCFECGenerator_Encode_GetParityPacketsCount(uint64_t a1, int a2, float *a3)
{
  _BOOL4 IsLossStatsEnabled;
  uint64_t ParityPacketCount_BasedOnPLR;
  int v8;
  pthread_mutex_t *v9;
  unint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  NSObject *v19;
  NSObject *v20;
  double v21;
  double v23;
  int v24;
  uint64_t v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  int v31;
  __int16 v32;
  int v33;
  __int16 v34;
  int v35;
  __int16 v36;
  int v37;
  __int16 v38;
  double v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  IsLossStatsEnabled = VCMediaControlInfo_IsLossStatsEnabled(*(unsigned __int8 *)(a1 + 140));
  ParityPacketCount_BasedOnPLR = _VCFECGenerator_GetParityPacketCount_BasedOnPLR(a1, a2, a3);
  v8 = ParityPacketCount_BasedOnPLR;
  if (a2 < 2 || !IsLossStatsEnabled)
    return ParityPacketCount_BasedOnPLR;
  v9 = (pthread_mutex_t *)(a1 + 96592);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 96592));
  v10 = *(_QWORD *)(a1 + 96520);
  if (v10)
  {
    v11 = 0;
    v12 = 0;
    while (1)
    {
      v13 = v11;
      v14 = a1 + 2 * v11;
      if (*(unsigned __int8 *)(v14 + 96528) >= a2)
        break;
      v11 = (unsigned __int16)++v12;
      if (v10 <= (unsigned __int16)v12)
      {
        v15 = *(unsigned __int8 *)(a1 + 2 * v13 + 96529);
        goto LABEL_10;
      }
    }
    v17 = *(unsigned __int8 *)(v14 + 96529);
    pthread_mutex_unlock(v9);
    if (v17 >= 7)
      v15 = 7;
    else
      v15 = v17;
  }
  else
  {
    v15 = 0;
LABEL_10:
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 96592));
  }
  if (v15 >= a2)
    v16 = a2;
  else
    v16 = v15;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v18 = VRTraceErrorLogLevelToCSTR();
    v19 = *MEMORY[0x1E0CF2758];
    v20 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        v21 = *a3;
        v24 = 136316930;
        v25 = v18;
        v26 = 2080;
        v27 = "_VCFECGenerator_GetParityPacketCount_BasedOnFECFeedback";
        v28 = 1024;
        v29 = 248;
        v30 = 1024;
        v31 = a2;
        v32 = 1024;
        v33 = v15;
        v34 = 1024;
        v35 = v16;
        v36 = 1024;
        v37 = v8;
        v38 = 2048;
        v39 = v21;
        _os_log_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Parity Packet Count Based on FEC Feedback inputPacketCount=%d foundFECLevel=%d parityPacketsCount=%d parityPacketsCountPlrBased=%d transmissionFactor=%2.2f ", (uint8_t *)&v24, 0x3Eu);
      }
    }
    else if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      v23 = *a3;
      v24 = 136316930;
      v25 = v18;
      v26 = 2080;
      v27 = "_VCFECGenerator_GetParityPacketCount_BasedOnFECFeedback";
      v28 = 1024;
      v29 = 248;
      v30 = 1024;
      v31 = a2;
      v32 = 1024;
      v33 = v15;
      v34 = 1024;
      v35 = v16;
      v36 = 1024;
      v37 = v8;
      v38 = 2048;
      v39 = v23;
      _os_log_debug_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Parity Packet Count Based on FEC Feedback inputPacketCount=%d foundFECLevel=%d parityPacketsCount=%d parityPacketsCountPlrBased=%d transmissionFactor=%2.2f ", (uint8_t *)&v24, 0x3Eu);
    }
  }
  return v16;
}

uint64_t _VCFECGenerator_GetParityPacketCount_BasedOnPLR(uint64_t a1, int a2, float *a3)
{
  unsigned int v6;
  uint64_t v7;
  uint64_t RealNumParity;
  int v9;
  float v10;
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  double v14;
  double v16;
  int v17;
  uint64_t v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  int v24;
  __int16 v25;
  int v26;
  __int16 v27;
  double v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  if (*(int *)(a1 + 132) >= 100)
    v6 = 100;
  else
    v6 = *(_DWORD *)(a1 + 132);
  v7 = FECUtil_FECPercentageToLevelofProtection(v6);
  RealNumParity = FECUtil_GetRealNumParity(a2, v7);
  if (a3)
  {
    v9 = *(_DWORD *)(a1 + 132);
    v10 = 1.0;
    if (v9 >= 101)
    {
      v10 = (float)v9 / 100.0;
      if (v10 < 1.0)
        v10 = 1.0;
    }
    *a3 = v10;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v11 = VRTraceErrorLogLevelToCSTR();
      v12 = *MEMORY[0x1E0CF2758];
      v13 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          v14 = *a3;
          v17 = 136316418;
          v18 = v11;
          v19 = 2080;
          v20 = "_VCFECGenerator_GetParityPacketCount_BasedOnPLR";
          v21 = 1024;
          v22 = 217;
          v23 = 1024;
          v24 = a2;
          v25 = 1024;
          v26 = RealNumParity;
          v27 = 2048;
          v28 = v14;
          _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Parity Packet Count Based on PLR inputPacketCount=%d parityPacketsCount=%d transmissionFactor=%2.2f", (uint8_t *)&v17, 0x32u);
        }
      }
      else if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        v16 = *a3;
        v17 = 136316418;
        v18 = v11;
        v19 = 2080;
        v20 = "_VCFECGenerator_GetParityPacketCount_BasedOnPLR";
        v21 = 1024;
        v22 = 217;
        v23 = 1024;
        v24 = a2;
        v25 = 1024;
        v26 = RealNumParity;
        v27 = 2048;
        v28 = v16;
        _os_log_debug_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Parity Packet Count Based on PLR inputPacketCount=%d parityPacketsCount=%d transmissionFactor=%2.2f", (uint8_t *)&v17, 0x32u);
      }
    }
  }
  return RealNumParity;
}

uint64_t _VCFECGeneratorClassRegister(uint64_t *a1)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

uint64_t VCFECGenerator_Create(uint64_t a1, uint64_t *a2, unsigned int a3, unsigned int a4, const void *a5, const void *a6, const void *a7)
{
  uint64_t Instance;
  uint64_t v14;
  _QWORD *v15;
  const void *v16;
  const void **v17;
  const void *v18;
  const void *v19;
  uint64_t v20;

  if (a2)
  {
    if (VCFECGeneratorGetTypeID_initOnce != -1)
      dispatch_once_f(&VCFECGeneratorGetTypeID_initOnce, &VCFECGeneratorGetTypeID_typeID, (dispatch_function_t)_VCFECGeneratorClassRegister);
    Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      v14 = Instance;
      if (a3 >= 2)
      {
        v20 = 2150825985;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCFECGenerator_Create_cold_3();
        }
      }
      else
      {
        *(_DWORD *)(Instance + 136) = a3;
        if (a4 >= 3)
        {
          v20 = 2150825985;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VCFECGenerator_Create_cold_4();
          }
        }
        else
        {
          *(_BYTE *)(Instance + 140) = a4;
          v15 = VCMemoryPool_Create(0x30uLL);
          *(_QWORD *)(v14 + 16) = v15;
          if (v15)
          {
            if ((VCSingleLinkedListInitialize(v14 + 24, (uint64_t)VCFECPacketList_CompareEntries) & 1) != 0)
            {
              if ((VCSingleLinkedListInitialize(v14 + 56, (uint64_t)VCFECPacketList_CompareEntries) & 1) != 0)
              {
                if ((VCSingleLinkedListInitialize(v14 + 88, (uint64_t)VCFECPacketList_CompareEntries) & 1) != 0)
                {
                  v16 = *(const void **)(v14 + 160);
                  *(_QWORD *)(v14 + 160) = a5;
                  if (a5)
                    CFRetain(a5);
                  if (v16)
                    CFRelease(v16);
                  v17 = (const void **)(v14 + 96656);
                  v18 = *(const void **)(v14 + 152);
                  *(_QWORD *)(v14 + 152) = a6;
                  if (a6)
                    CFRetain(a6);
                  if (v18)
                    CFRelease(v18);
                  *(_DWORD *)(v14 + 132) = -1;
                  *(_QWORD *)(v14 + 168) = 0;
                  *(_DWORD *)(v14 + 176) = 0;
                  pthread_mutex_init((pthread_mutex_t *)(v14 + 96592), 0);
                  v19 = *v17;
                  *v17 = a7;
                  if (a7)
                    CFRetain(a7);
                  if (v19)
                    CFRelease(v19);
                  if (a7)
                  {
                    *(_DWORD *)(v14 + 96664) = VCReporting_GetDynamicReportingModuleID();
                    reportingRegisterPeriodicTaskWeak();
                  }
                  v20 = 0;
                  *a2 = v14;
                  return v20;
                }
                v20 = 2150825987;
                if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                {
                  VRTraceErrorLogLevelToCSTR();
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                    VCFECGenerator_Create_cold_6();
                }
              }
              else
              {
                v20 = 2150825987;
                if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                {
                  VRTraceErrorLogLevelToCSTR();
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                    VCFECGenerator_Create_cold_7();
                }
              }
            }
            else
            {
              v20 = 2150825987;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  VCFECGenerator_Create_cold_8();
              }
            }
          }
          else
          {
            v20 = 2150825987;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                VCFECGenerator_Create_cold_5();
            }
          }
        }
      }
      CFRelease((CFTypeRef)v14);
      return v20;
    }
    v20 = 2150825987;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCFECGenerator_Create_cold_2();
    }
  }
  else
  {
    v20 = 2150825985;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCFECGenerator_Create_cold_1();
    }
  }
  return v20;
}

uint64_t VCFECGenerator_PushPacket(uint64_t a1, const void *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  int v6;
  uint64_t v7;

  if (a1)
  {
    if (a2)
    {
      v4 = VCMemoryPool_Alloc(*(OSQueueHead **)(a1 + 16));
      if (v4)
      {
        v5 = v4;
        v6 = *(_DWORD *)(a1 + 120);
        *(_DWORD *)(a1 + 120) = v6 + 1;
        *((_DWORD *)v4 + 2) = v6;
        v4[4] = 0;
        v4[5] = 0;
        v4[3] = 0;
        CFRetain(a2);
        v5[2] = a2;
        VCSingleLinkedListPush(a1 + 24, v5);
        return 0;
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      {
        return 2150825987;
      }
      else
      {
        VRTraceErrorLogLevelToCSTR();
        v7 = 2150825987;
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCFECGenerator_PushPacket_cold_3();
      }
    }
    else
    {
      v7 = 2150825985;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCFECGenerator_PushPacket_cold_2();
      }
    }
  }
  else
  {
    v7 = 2150825985;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCFECGenerator_PushPacket_cold_1();
    }
  }
  return v7;
}

uint64_t VCFECGenerator_PopPacket(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t *v6;
  __int128 v7;
  uint64_t v8;

  if (a1)
  {
    if (a2)
    {
      *a2 = 0;
      v6 = VCSingleLinkedListPop((uint64_t *)(a1 + 56));
      if (v6)
      {
        *a2 = v6[2];
        if (a3)
        {
          v7 = *(_OWORD *)(v6 + 3);
          *(_QWORD *)(a3 + 16) = v6[5];
          *(_OWORD *)a3 = v7;
        }
        *(_DWORD *)(a1 + 144) = ((*((unsigned __int16 *)v6 + 13) >> 12) & 1) + *(_DWORD *)(a1 + 144) - 1;
        VCMemoryPool_Free(*(OSQueueHead **)(a1 + 16), v6);
        return 0;
      }
      else
      {
        v8 = 2150826006;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            VCFECGenerator_PopPacket_cold_3();
            return 2150826006;
          }
        }
      }
    }
    else
    {
      v8 = 2150825985;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCFECGenerator_PopPacket_cold_2();
      }
    }
  }
  else
  {
    v8 = 2150825985;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCFECGenerator_PopPacket_cold_1();
    }
  }
  return v8;
}

uint64_t VCFECGenerator_GetNumberOutputPackets(uint64_t a1)
{
  if (a1)
    return VCSingleLinkedGetNumberEntries(a1 + 56);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCFECGenerator_GetNumberOutputPackets_cold_1();
  }
  return 0;
}

uint64_t VCFECGenerator_GetNumberOutputMediaPackets(uint64_t a1)
{
  if (a1)
    return *(int *)(a1 + 144);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCFECGenerator_GetNumberOutputMediaPackets_cold_1();
  }
  return 0;
}

uint64_t VCFECGenerator_PerformAction(unint64_t a1, int a2)
{
  uint64_t v4;
  double v5;
  double v6;
  uint64_t v7;
  uint64_t *v8;
  unint64_t NumberEntries;
  uint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t *v16;
  unsigned __int16 v17;
  OpaqueCMBlockBuffer *v18;
  unint64_t v19;
  uint64_t v20;
  int64x2_t v21;
  int64x2_t v22;
  int v23;
  int v24;
  OSQueueHead *v25;
  const void *v26;
  int v27;
  int ParityPacketsCount;
  char v29;
  char v30;
  float v31;
  int v32;
  char v33;
  int v34;
  char v35;
  unsigned __int16 v36;
  OSQueueHead *v37;
  const void *v38;
  int v39;
  int v40;
  int v41;
  int v42;
  unsigned __int16 v43;
  unsigned __int16 v44;
  int v45;
  uint64_t v46;
  unint64_t v47;
  __int16 v48;
  int *v49;
  int v50;
  int v51;
  OpaqueCMBlockBuffer **v52;
  _WORD *v53;
  uint64_t v54;
  OpaqueCMBlockBuffer *v55;
  int v56;
  int v57;
  uint64_t v58;
  NSObject *v59;
  unint64_t v60;
  CMBlockBufferRef *v61;
  OSStatus v62;
  int v63;
  OSQueueHead *v64;
  CMBlockBufferRef v65;
  int v66;
  int v67;
  int v68;
  uint64_t v69;
  uint64_t v70;
  const void *v71;
  const void *v72;
  int v73;
  uint64_t v74;
  NSObject *v75;
  uint64_t v76;
  NSObject *v77;
  NSObject *v78;
  const char *v79;
  int v80;
  uint64_t v81;
  NSObject *v82;
  NSObject *v83;
  const char *v84;
  OSStatus v85;
  uint64_t v86;
  NSObject *v87;
  int v88;
  uint32_t v89;
  uint64_t v90;
  NSObject *v91;
  uint64_t v92;
  NSObject *v93;
  uint64_t v94;
  NSObject *v95;
  uint64_t v96;
  NSObject *v97;
  uint64_t *v98;
  uint64_t *v99;
  int v100;
  unint64_t v101;
  unint64_t *v102;
  unint64_t v103;
  unsigned int *v104;
  unsigned int v105;
  int ErrorLogLevelForModule;
  int64x2_t v108;
  int64x2_t v109;
  _DWORD *v110;
  unint64_t v111;
  uint64_t v112;
  int v113;
  int v114;
  int v115;
  int v116;
  uint64_t v117;
  uint8_t buf[4];
  uint64_t v119;
  __int16 v120;
  const char *v121;
  __int16 v122;
  int v123;
  __int16 v124;
  int v125;
  __int16 v126;
  int v127;
  __int16 v128;
  int v129;
  __int16 v130;
  int v131;
  __int16 v132;
  int v133;
  __int128 v134;
  uint64_t v135;
  uint64_t v136;

  v136 = *MEMORY[0x1E0C80C00];
  v4 = 2150825985;
  v5 = micro();
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCFECGenerator_PerformAction_cold_1();
    }
    return v4;
  }
  v6 = v5;
  switch(a2)
  {
    case -1:
    case 0:
    case 3:
      v7 = 2150826005;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          VCFECGenerator_PerformAction_cold_2();
          goto LABEL_6;
        }
      }
      goto LABEL_110;
    case 1:
      VCFECPacketList_Flush(*(OSQueueHead **)(a1 + 16), (uint64_t *)(a1 + 24));
      VCFECPacketList_Flush(*(OSQueueHead **)(a1 + 16), (uint64_t *)(a1 + 56));
      v7 = 0;
      *(_DWORD *)(a1 + 144) = 0;
      goto LABEL_110;
    case 2:
      v8 = (uint64_t *)(a1 + 24);
      NumberEntries = VCSingleLinkedGetNumberEntries(a1 + 24);
      v10 = (uint64_t *)(a1 + 88);
      *(_BYTE *)(a1 + 128) = 0;
      v110 = (_DWORD *)(a1 + 212);
      v108 = vdupq_n_s64(2uLL);
      v109 = vaddq_s64(vdupq_n_s64(a1), vdupq_n_s64(0x1F8uLL));
      break;
    case 4:
      v98 = VCSingleLinkedListPop((uint64_t *)(a1 + 24));
      if (v98)
      {
        v99 = v98;
        do
        {
          *((_BYTE *)v99 + 24) = 3;
          *(uint64_t *)((char *)v99 + 33) = 0;
          *(uint64_t *)((char *)v99 + 25) = 0;
          v99[5] = 0;
          VCSingleLinkedListPush(a1 + 56, v99);
          v100 = *(_DWORD *)(a1 + 144);
          if ((*((_WORD *)v99 + 13) & 0x1000) == 0)
            ++v100;
          *(_DWORD *)(a1 + 144) = v100;
          v99 = VCSingleLinkedListPop((uint64_t *)(a1 + 24));
        }
        while (v99);
      }
LABEL_109:
      v7 = 0;
      goto LABEL_110;
    default:
LABEL_6:
      v7 = 2150826005;
      goto LABEL_110;
  }
  while (1)
  {
    if (!NumberEntries)
      goto LABEL_109;
    v11 = 8;
    if (NumberEntries - 9 < 4)
      v11 = (unint64_t)(double)(NumberEntries >> 1);
    v12 = v11 >= NumberEntries ? NumberEntries : v11;
    if (v12)
      break;
LABEL_19:
    v14 = VCSingleLinkedGetNumberEntries((uint64_t)v8);
    v113 = VCSingleLinkedGetNumberEntries((uint64_t)v10);
    v117 = 0;
    v116 = 0;
    v15 = VCSingleLinkedListPop(v10);
    if (v15)
    {
      v16 = v15;
      v17 = 0;
      do
      {
        v18 = (OpaqueCMBlockBuffer *)v16[2];
        v19 = a1 + 8 * v17;
        *(_QWORD *)(v19 + 248) = v18;
        *(_DWORD *)(a1 + 4 * v17 + 180) = CMBlockBufferGetDataLength(v18);
        CMBlockBufferGetDataPointer(*(CMBlockBufferRef *)(v19 + 248), 0, 0, 0, (char **)(v19 + 376));
        VCMemoryPool_Free(*(OSQueueHead **)(a1 + 16), v16);
        ++v17;
        v16 = VCSingleLinkedListPop(v10);
      }
      while (v16);
    }
    else
    {
      v17 = 0;
    }
    *(_OWORD *)v110 = 0u;
    *(_OWORD *)(a1 + 228) = 0u;
    v20 = 440;
    v21 = (int64x2_t)xmmword_1D910ADF0;
    do
    {
      v22.i64[0] = 12000 * v21.i64[0];
      v22.i64[1] = 12000 * v21.i64[1];
      *(int64x2_t *)(a1 + v20) = vaddq_s64(v109, v22);
      v21 = vaddq_s64(v21, v108);
      v20 += 16;
    }
    while (v20 != 504);
    v111 = v14;
    if (v17 == 1)
    {
      v135 = 0;
      v134 = xmmword_1D910AE0C;
      if (VCMediaControlInfo_IsLossStatsEnabled(*(unsigned __int8 *)(a1 + 140)))
      {
        v23 = *(_DWORD *)(a1 + 132);
        if (v23 >= 1)
        {
          v24 = *(_DWORD *)(a1 + 136);
          LOBYTE(v134) = v24 & 3;
          WORD1(v134) = 0;
          if (v24 == 1)
            WORD2(v134) = v23 & 0x3FF;
        }
      }
      v25 = *(OSQueueHead **)(a1 + 16);
      v26 = *(const void **)(a1 + 248);
      v27 = *(_DWORD *)(a1 + 124);
      *(_DWORD *)(a1 + 124) = v27 + 1;
      if ((VCFECPacketList_AllocateAndPush(v25, v26, v27, a1 + 56, &v134) & 0x80000000) == 0)
      {
        v7 = 0;
        ++*(_DWORD *)(a1 + 144);
        goto LABEL_69;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v90 = VRTraceErrorLogLevelToCSTR();
        v91 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          v119 = v90;
          v120 = 2080;
          v121 = "_VCFECGenerator_Encode_PrepareOutputSinglePacketFrame";
          v122 = 1024;
          v123 = 332;
          _os_log_error_impl(&dword_1D8A54000, v91, OS_LOG_TYPE_ERROR, " [%s] %s:%d Failure in allocating an entry list", buf, 0x1Cu);
        }
      }
      v7 = 2150825985;
      if ((int)VRTraceGetErrorLogLevelForModule() < 3)
        goto LABEL_69;
      v92 = VRTraceErrorLogLevelToCSTR();
      v93 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        goto LABEL_69;
      *(_DWORD *)buf = 136315650;
      v119 = v92;
      v120 = 2080;
      v121 = "_VCFECGenerator_EncodeCurrentGroup";
      v122 = 1024;
      v123 = 357;
      v78 = v93;
      v79 = " [%s] %s:%d Error in preparing single packet frame output";
      goto LABEL_82;
    }
    v115 = 1065353216;
    ParityPacketsCount = _VCFECGenerator_Encode_GetParityPacketsCount(a1, v113, (float *)&v115);
    v114 = ParityPacketsCount;
    if (ParityPacketsCount > v113)
    {
      v7 = 2150825998;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v94 = VRTraceErrorLogLevelToCSTR();
        v95 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136316162;
          v119 = v94;
          v120 = 2080;
          v121 = "_VCFECGenerator_EncodeCurrentGroup";
          v122 = 1024;
          v123 = 362;
          v124 = 1024;
          v125 = v114;
          v126 = 1024;
          v127 = v113;
          _os_log_error_impl(&dword_1D8A54000, v95, OS_LOG_TYPE_ERROR, " [%s] %s:%d Number of parity can't be larger than input packets parityPacketsNeeded=%d numPacketsInGroup=%d", buf, 0x28u);
          v7 = 2150825998;
        }
      }
      goto LABEL_69;
    }
    if (ParityPacketsCount < 1)
    {
      v29 = v116;
      v30 = v117;
      v31 = *(float *)&v115;
      v134 = xmmword_1D910AE0C;
      v135 = 0;
      goto LABEL_42;
    }
    if ((RSU_Encode(a1 + 376, (__int16 *)(a1 + 180), v113, (_QWORD *)(a1 + 440), v110, (_DWORD *)&v117 + 1, (int *)&v117, &v116, (_WORD *)(a1 + 96504), 1) & 0x80000000) == 0)
    {
      v29 = v116;
      v30 = v117;
      v31 = *(float *)&v115;
      v134 = xmmword_1D910AE0C;
      v135 = 0;
      v32 = *(_DWORD *)(a1 + 136);
      LOBYTE(v134) = v32 & 3 | (4 * (v117 & 7));
      v33 = *(_BYTE *)(a1 + 128);
      *(_BYTE *)(a1 + 128) = v33 + 1;
      WORD1(v134) = ((v14 == 0) << 7) | ((v29 & 0xF) << 8) | v33 & 0x7F;
      if (v32 == 1)
      {
        if (*(_BYTE *)(a1 + 140))
          v34 = (int)(float)((float)(v31 * (float)v114) * 100.0) / v113;
        else
          v34 = *(_DWORD *)(a1 + 132);
        WORD2(v134) = v34 & 0x3FF;
      }
LABEL_42:
      if (v113 < 1)
      {
LABEL_46:
        v41 = v114;
        if (v114 < 1)
        {
LABEL_68:
          v7 = 0;
          v10 = (uint64_t *)(a1 + 88);
          v8 = (uint64_t *)(a1 + 24);
          goto LABEL_69;
        }
        v42 = 0;
        v43 = 0;
        if (v113 >= 8)
          v44 = 8;
        else
          v44 = v113;
        v112 = v44;
        v45 = (int)v31;
        while (1)
        {
          v46 = v43;
          v47 = a1 + 4 * v43;
          v50 = *(_DWORD *)(v47 + 212);
          v49 = (int *)(v47 + 212);
          v48 = v50;
          if (v50 >= 1)
          {
            WORD1(v134) |= 0x1000u;
            BYTE1(v134) = BYTE1(v134) & 0xF0 | (v42 * v30) & 0xF;
            v51 = *(_DWORD *)(a1 + 136);
            if (v51 == 1)
            {
              v56 = *(unsigned __int16 *)(a1 + 2 * v46 + 96504);
              v57 = *(unsigned __int16 *)(a1 + 130);
              *(_WORD *)(a1 + 130) = v57 + 1;
              *(_DWORD *)((char *)&v134 + 6) = v56 | (v57 << 16);
            }
            else if (v51)
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                v58 = VRTraceErrorLogLevelToCSTR();
                v59 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                {
                  v68 = *(_DWORD *)(a1 + 136);
                  *(_DWORD *)buf = 136315906;
                  v119 = v58;
                  v120 = 2080;
                  v121 = "_VCFECGenerator_FillHeaderVersionSpecific";
                  v122 = 1024;
                  v123 = 196;
                  v124 = 1024;
                  v125 = v68;
                  _os_log_error_impl(&dword_1D8A54000, v59, OS_LOG_TYPE_ERROR, " [%s] %s:%d Invalid FEC Header Version=%d", buf, 0x22u);
                }
              }
            }
            else
            {
              WORD3(v134) = v113;
              WORD2(v134) = WORD2(v134) & 0xF800 | v48 & 0x7FF;
              if ((_DWORD)v112)
              {
                v52 = (OpaqueCMBlockBuffer **)(a1 + 248);
                v53 = (_WORD *)&v134 + 4;
                v54 = v112;
                do
                {
                  v55 = *v52++;
                  *v53++ = CMBlockBufferGetDataLength(v55);
                  --v54;
                }
                while (v54);
              }
            }
            v60 = a1 + 8 * v46;
            v61 = (CMBlockBufferRef *)(v60 + 312);
            v62 = CMBlockBufferCreateWithMemoryBlock(*(CFAllocatorRef *)(a1 + 160), 0, 0x5DCuLL, *(CFAllocatorRef *)(a1 + 152), 0, 0, *v49, 1u, (CMBlockBufferRef *)(v60 + 312));
            if (v62)
            {
              v85 = v62;
              v10 = (uint64_t *)(a1 + 88);
              v8 = (uint64_t *)(a1 + 24);
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                v86 = VRTraceErrorLogLevelToCSTR();
                v87 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                {
                  v88 = *v49;
                  *(_DWORD *)buf = 136316930;
                  v119 = v86;
                  v120 = 2080;
                  v121 = "_VCFECGenerator_Encode_PrepareOutput";
                  v122 = 1024;
                  v123 = 306;
                  v124 = 1024;
                  v125 = v85;
                  v126 = 1024;
                  v127 = v42;
                  v128 = 1024;
                  v129 = v88;
                  v130 = 1024;
                  v131 = v113;
                  v132 = 1024;
                  v133 = v114;
                  v83 = v87;
                  v84 = " [%s] %s:%d Failure allocating output buffer status=%d parityPacketSize[%d]=%d inputPacketCount="
                        "%d parityPacketsCount=%d";
                  v89 = 58;
                  goto LABEL_91;
                }
              }
              goto LABEL_79;
            }
            CMBlockBufferReplaceDataBytes(*(const void **)(v60 + 440), *v61, 0, *v49);
            v41 = v114;
            if (v45 >= 1)
              break;
          }
LABEL_67:
          v43 = v46 + 1;
          v42 = (unsigned __int16)(v46 + 1);
          if (v41 <= v42)
            goto LABEL_68;
        }
        v63 = 0;
        while (1)
        {
          v64 = *(OSQueueHead **)(a1 + 16);
          v65 = *v61;
          v66 = *(_DWORD *)(a1 + 124);
          *(_DWORD *)(a1 + 124) = v66 + 1;
          v67 = VCFECPacketList_AllocateAndPush(v64, v65, v66, a1 + 56, &v134);
          if (v67)
            break;
          if (v45 <= (unsigned __int16)++v63)
            goto LABEL_67;
        }
        v73 = v67;
        v10 = (uint64_t *)(a1 + 88);
        v8 = (uint64_t *)(a1 + 24);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v74 = VRTraceErrorLogLevelToCSTR();
          v75 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315906;
            v119 = v74;
            v120 = 2080;
            v121 = "_VCFECGenerator_Encode_PrepareOutput";
            v122 = 1024;
            v123 = 311;
            v124 = 1024;
            v125 = v73;
            v83 = v75;
            v84 = " [%s] %s:%d Failure in allocating an entry list result=%d";
            goto LABEL_90;
          }
        }
      }
      else
      {
        v35 = 0;
        v36 = 0;
        while (1)
        {
          WORD1(v134) &= ~0x1000u;
          BYTE1(v134) = BYTE1(v134) & 0xF0 | (v29 + v35 * v30) & 0xF;
          v37 = *(OSQueueHead **)(a1 + 16);
          v38 = *(const void **)(a1 + 8 * v36 + 248);
          v39 = *(_DWORD *)(a1 + 124);
          *(_DWORD *)(a1 + 124) = v39 + 1;
          v40 = VCFECPacketList_AllocateAndPush(v37, v38, v39, a1 + 56, &v134);
          if (v40)
            break;
          ++*(_DWORD *)(a1 + 144);
          v35 = ++v36;
          if (v36 >= v113)
            goto LABEL_46;
        }
        v80 = v40;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v81 = VRTraceErrorLogLevelToCSTR();
          v82 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315906;
            v119 = v81;
            v120 = 2080;
            v121 = "_VCFECGenerator_Encode_PrepareOutput";
            v122 = 1024;
            v123 = 293;
            v124 = 1024;
            v125 = v80;
            v83 = v82;
            v84 = " [%s] %s:%d Failure in allocating an entry list result=%d";
LABEL_90:
            v89 = 34;
LABEL_91:
            _os_log_error_impl(&dword_1D8A54000, v83, OS_LOG_TYPE_ERROR, v84, buf, v89);
          }
        }
      }
LABEL_79:
      v7 = 2150825985;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v76 = VRTraceErrorLogLevelToCSTR();
        v77 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          v119 = v76;
          v120 = 2080;
          v121 = "_VCFECGenerator_EncodeCurrentGroup";
          v122 = 1024;
          v123 = 368;
          v78 = v77;
          v79 = " [%s] %s:%d Error in preparing output";
LABEL_82:
          _os_log_error_impl(&dword_1D8A54000, v78, OS_LOG_TYPE_ERROR, v79, buf, 0x1Cu);
          goto LABEL_69;
        }
      }
      goto LABEL_69;
    }
    v7 = 2150825985;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v96 = VRTraceErrorLogLevelToCSTR();
      v97 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315650;
        v119 = v96;
        v120 = 2080;
        v121 = "_VCFECGenerator_EncodeCurrentGroup";
        v122 = 1024;
        v123 = 365;
        v78 = v97;
        v79 = " [%s] %s:%d Failure RSU Encode";
        goto LABEL_82;
      }
    }
LABEL_69:
    v69 = 0;
    NumberEntries = v111;
    do
    {
      v70 = a1 + v69;
      v71 = *(const void **)(a1 + v69 + 248);
      if (v71)
      {
        CFRelease(v71);
        *(_QWORD *)(v70 + 248) = 0;
      }
      v72 = *(const void **)(v70 + 312);
      if (v72)
      {
        CFRelease(v72);
        *(_QWORD *)(v70 + 312) = 0;
      }
      v69 += 8;
    }
    while (v69 != 64);
    if ((_DWORD)v7)
    {
      ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
      if (ErrorLogLevelForModule >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCFECGenerator_PerformAction_cold_3();
      }
      goto LABEL_110;
    }
  }
  while (1)
  {
    v13 = VCSingleLinkedListPop(v8);
    if (!v13)
      break;
    if ((VCSingleLinkedListPush((uint64_t)v10, v13) & 1) == 0)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCFECGenerator_PerformAction_cold_5();
      }
      goto LABEL_122;
    }
    if (!--v12)
      goto LABEL_19;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCFECGenerator_PerformAction_cold_4();
  }
LABEL_122:
  v7 = 2150825985;
LABEL_110:
  v101 = vcvtd_n_s64_f64(micro() - v6, 0x20uLL);
  v102 = (unint64_t *)(a1 + 168);
  do
    v103 = __ldaxr(v102);
  while (__stlxr(v103 + v101, v102));
  v104 = (unsigned int *)(a1 + 176);
  do
    v105 = __ldaxr(v104);
  while (__stlxr(v105 + 1, v104));
  return v7;
}

uint64_t VCFECGenerator_SetFixedFECLevel(uint64_t a1, unsigned int a2)
{
  uint64_t v2;

  if (a1)
  {
    if (a2 >= 0x12D)
    {
      v2 = 2150825985;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCFECGenerator_SetFixedFECLevel_cold_2();
      }
    }
    else
    {
      v2 = 0;
      *(_DWORD *)(a1 + 132) = a2;
    }
  }
  else
  {
    v2 = 2150825985;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCFECGenerator_SetFixedFECLevel_cold_1();
    }
  }
  return v2;
}

uint64_t VCFECGenerator_SetFECLevelPerGroupSizeVector(uint64_t a1, unint64_t a2, const void *a3)
{
  pthread_mutex_t *v6;
  uint64_t v7;
  int v8;
  char *v9;
  os_log_t *v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  pthread_mutex_t *v15;
  char *__lasts;
  char *__str;
  uint8_t buf[4];
  uint64_t v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  const char *v25;
  __int16 v26;
  char *v27;
  char v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  _BYTE v52[31];
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a2 >= 0x21)
    {
      v13 = 2150825985;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCFECGenerator_SetFECLevelPerGroupSizeVector_cold_2();
      }
    }
    else
    {
      v6 = (pthread_mutex_t *)(a1 + 96592);
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 96592));
      *(_QWORD *)(a1 + 96520) = a2;
      memcpy((void *)(a1 + 96528), a3, 2 * a2);
      v51 = 0u;
      memset(v52, 0, sizeof(v52));
      v49 = 0u;
      v50 = 0u;
      v47 = 0u;
      v48 = 0u;
      v45 = 0u;
      v46 = 0u;
      v44 = 0u;
      v43 = 0u;
      v42 = 0u;
      v41 = 0u;
      v40 = 0u;
      v39 = 0u;
      v38 = 0u;
      v37 = 0u;
      v36 = 0u;
      v35 = 0u;
      v34 = 0u;
      v33 = 0u;
      v32 = 0u;
      v31 = 0u;
      v30 = 0u;
      v29 = 0u;
      v28 = 10;
      if (a2)
      {
        v7 = 0;
        v8 = 0;
        do
        {
          __sprintf_chk(&v28, 0, 0x190uLL, "%s(%02d,%02d)\t", &v28, *(unsigned __int8 *)(a1 + 2 * v7 + 96528), *(unsigned __int8 *)(a1 + 2 * v7 + 96529));
          v7 = (unsigned __int16)++v8;
        }
        while (*(_QWORD *)(a1 + 96520) > (unint64_t)(unsigned __int16)v8);
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        __str = 0;
        asprintf(&__str, " _fecLevelPerGroupSizeVector=\n%s\n", &v28);
        if (__str)
        {
          v15 = v6;
          __lasts = 0;
          v9 = strtok_r(__str, "\n", &__lasts);
          v10 = (os_log_t *)MEMORY[0x1E0CF2758];
          do
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v11 = VRTraceErrorLogLevelToCSTR();
              v12 = *v10;
              if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136316162;
                v19 = v11;
                v20 = 2080;
                v21 = "_VCFECGenerator_PrintFECLevelVector";
                v22 = 1024;
                v23 = 641;
                v24 = 2080;
                v25 = "histogram";
                v26 = 2080;
                v27 = v9;
                _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d %s %s", buf, 0x30u);
              }
            }
            v9 = strtok_r(0, "\n", &__lasts);
          }
          while (v9);
          free(__str);
          v6 = v15;
        }
      }
      pthread_mutex_unlock(v6);
      return 0;
    }
  }
  else
  {
    v13 = 2150825985;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCFECGenerator_SetFECLevelPerGroupSizeVector_cold_1();
    }
  }
  return v13;
}

double VCFECGenerator_GetProcessingAverageTime(uint64_t a1)
{
  unsigned int *v1;
  unsigned __int16 v2;
  unint64_t *v3;
  uint64_t v4;

  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCFECGenerator_GetProcessingAverageTime_cold_1();
    }
    return NAN;
  }
  v1 = (unsigned int *)(a1 + 176);
  do
    v2 = __ldaxr(v1);
  while (__stlxr(0, v1));
  if (!v2)
    return NAN;
  v3 = (unint64_t *)(a1 + 168);
  do
    v4 = __ldaxr(v3);
  while (__stlxr(0, v3));
  return (double)v4 / (double)((unint64_t)v2 << 32);
}

void _VCFECGenerator_Init(uint64_t a1)
{
  bzero((void *)(a1 + 16), 0x17990uLL);
}

void _VCFECGenerator_Finalize(uint64_t a1)
{
  CFTypeRef *v2;
  const void *v3;
  const void *v4;
  uint64_t v5;
  NSObject *v6;
  int v7;
  uint64_t v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  int v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v2 = (CFTypeRef *)(a1 + 96656);
  VCFECPacketList_Flush(*(OSQueueHead **)(a1 + 16), (uint64_t *)(a1 + 24));
  VCFECPacketList_Flush(*(OSQueueHead **)(a1 + 16), (uint64_t *)(a1 + 56));
  *(_DWORD *)(a1 + 144) = 0;
  VCMemoryPool_Destroy(*(OSQueueHead **)(a1 + 16));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 96592));
  v3 = *(const void **)(a1 + 152);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 152) = 0;
  }
  v4 = *(const void **)(a1 + 160);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 160) = 0;
  }
  if (*v2)
  {
    reportingUnregisterPeriodicTask();
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v5 = VRTraceErrorLogLevelToCSTR();
    v6 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v7 = 136315650;
      v8 = v5;
      v9 = 2080;
      v10 = "_VCFECGenerator_DeregisterPeriodicReportingTask";
      v11 = 1024;
      v12 = 441;
      _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d fecGenerator->_reportingAgent is NULL!", (uint8_t *)&v7, 0x1Cu);
    }
  }
  if (*v2)
  {
    CFRelease(*v2);
    *v2 = 0;
  }
}

void sub_1D8B2E154(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

AudioComponent RegisterCodec(OSType a1, const char *__symbol, int a3)
{
  OSType v4;
  AudioComponent result;
  AudioComponentDescription inDesc;
  AudioComponentFactoryFunction inFactory[2];

  inFactory[1] = *(AudioComponentFactoryFunction *)MEMORY[0x1E0C80C00];
  if (a3)
    v4 = 1634037347;
  else
    v4 = 1633969507;
  inDesc.componentType = v4;
  inDesc.componentSubType = a1;
  *(_QWORD *)&inDesc.componentManufacturer = 1634758764;
  inDesc.componentFlagsMask = 0;
  result = (AudioComponent)GetAudioCodecFactory(AudioComponentDescription const*,char const*)::libHandle;
  if (GetAudioCodecFactory(AudioComponentDescription const*,char const*)::libHandle
    || (result = (AudioComponent)dlopen("/System/Library/Frameworks/AudioToolbox.framework/AudioCodecs", 1),
        (GetAudioCodecFactory(AudioComponentDescription const*,char const*)::libHandle = (uint64_t)result) != 0))
  {
    result = (AudioComponent)dlsym(result, __symbol);
    if (result)
    {
      inFactory[0] = (AudioComponentFactoryFunction)&inDesc;
      ((void (*)(AudioComponentFactoryFunction *))result)(inFactory);
      if (inFactory[0])
        return AudioComponentRegister(&inDesc, &stru_1E9E58EE0, 0, inFactory[0]);
      else
        return 0;
    }
  }
  return result;
}

BOOL RegisterG722Encoder()
{
  AudioComponent v0;

  v0 = (AudioComponent)RegisterG722Encoder::gG722Encoder;
  if (!RegisterG722Encoder::gG722Encoder)
  {
    v0 = RegisterCodec(0x676B6363u, "RegisterExternalAudioCodecs", 1);
    RegisterG722Encoder::gG722Encoder = (uint64_t)v0;
  }
  return v0 != 0;
}

BOOL RegisterG722Decoder()
{
  AudioComponent v0;

  v0 = (AudioComponent)RegisterG722Decoder::gG722Decoder;
  if (!RegisterG722Decoder::gG722Decoder)
  {
    v0 = RegisterCodec(0x676B6363u, "RegisterExternalAudioCodecs", 0);
    RegisterG722Decoder::gG722Decoder = (uint64_t)v0;
  }
  return v0 != 0;
}

void VCMediaQueueUtil_FindPacketInTxHistory(unsigned __int16 *a1, uint64_t *a2, pthread_mutex_t *a3, int a4, double a5, double a6)
{
  pthread_mutex_t *v9;
  double v11;
  double v12;
  double v13;
  double v14;
  int v15;
  uint64_t v16;
  int v17;
  int v18;
  __int16 v19;
  __int16 v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  unsigned int v26;
  unsigned int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  uint64_t v32;
  uint64_t i;
  unsigned int v34;
  double *v35;
  unsigned int v36;
  unsigned int v37;
  double *v39;
  unsigned int v40;
  unsigned int v41;
  double v43;
  double v44;
  double v45;
  double *v46;
  double v47;
  uint64_t v48;
  NSObject *v49;
  char v50;
  int v51;
  unsigned int v52;
  int v53;
  double v54;
  unsigned int v55;
  BOOL v56;
  uint64_t v57;
  double v58;
  unsigned int v59;
  _QWORD *v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  unsigned __int16 *v68;
  int v69;
  unsigned int v71;
  unint64_t v72;
  _QWORD *v73;
  __int16 v74;
  pthread_mutex_t *v75;
  int v76;
  int v77;
  int v78;
  int v79;
  int v80;
  int v81;
  int v82;
  unsigned int v83;
  int v85;
  int v86;
  _OWORD v87[4];
  uint64_t v88;

  v88 = *MEMORY[0x1E0C80C00];
  if (*((_QWORD *)a1 + 3) && *((_QWORD *)a1 + 4) && *((_QWORD *)a1 + 5) && *((_QWORD *)a1 + 6) && *((_QWORD *)a1 + 7))
  {
    v9 = a3;
    memset(v87, 0, sizeof(v87));
    pthread_mutex_lock(a3);
    v15 = *((_DWORD *)a2 + 3);
    v16 = *a2;
    if (v15 >= 1)
    {
      v17 = 0;
      v18 = *((_DWORD *)a2 + 2);
      v19 = v18 - 1;
      v20 = v18 - 2;
      v21 = *a1;
      do
      {
        v22 = (v20 + 1) & 0x1FF;
        v23 = *(unsigned __int16 *)(v16 + 48 * ((v20 + 1) & 0x1FF) + 2);
        v24 = (unsigned __int16)(v23 - v21) >= 0x7FFFu ? 2 : 4;
        v25 = v23 == v21 ? 1 : v24;
        if (v25 == 2)
          break;
        if (v25 == 1)
        {
          v57 = v16 + 48 * ((v20 + 1) & 0x1FF);
          v58 = *(double *)(v57 + 40);
          v59 = *((_DWORD *)a1 + 3);
          if (v59 >= 0xF)
            LOWORD(v59) = 15;
          *(_WORD *)v57 = v59;
          v11 = *(double *)(a1 + 2);
          *(double *)(v57 + 12) = v11;
          *(_QWORD *)(v57 + 32) = *((_QWORD *)a1 + 2);
          v60 = (_QWORD *)(v57 + 32);
          v61 = v17 + 1;
          if (v17 + 1 >= v15)
          {
            v26 = 0;
            v27 = 0;
            v28 = -1;
            v29 = -1;
            v30 = -1;
            goto LABEL_18;
          }
          v74 = v19;
          v73 = v60;
          v75 = v9;
          v62 = 0;
          v63 = 0;
          v64 = 0;
          v65 = 0;
          v66 = 0;
          v27 = 0;
          v26 = 0;
          v67 = -1;
          v30 = -1;
          v29 = -1;
          v28 = -1;
          v31 = a4;
          do
          {
            if (*(_DWORD *)(v16 + 48 * (v20 & 0x1FF) + 12))
            {
              v68 = (unsigned __int16 *)(v16 + 48 * (v20 & 0x1FF));
              if (v31)
              {
                v69 = *((_DWORD *)v68 + 4);
                v85 = -1431655766;
                v86 = -1431655766;
                if (!(v65 & 1 | (v69 == 0)))
                {
                  v78 = v62;
                  v79 = v66;
                  v76 = v64;
                  v77 = v63;
                  v82 = v29;
                  v83 = v26;
                  v80 = v65;
                  v81 = v28;
                  FECUtil_UnpackFrameLoss((unsigned __int16)v69, &v86, &v85);
                  v64 = v76;
                  v63 = v77;
                  v62 = v78;
                  v66 = v79;
                  v65 = v80;
                  v28 = v81;
                  v29 = v82;
                  v26 = v86 + v83;
                  v31 = a4;
                  v27 += v85;
                }
              }
              ++*((_DWORD *)v87 + *v68);
              v11 = v58 - *(double *)(v16 + 48 * (v20 & 0x1FF) + 40);
              if (!(v63 & 1 | (v11 <= 1.0)))
              {
                v12 = (double)(unint64_t)(*((_QWORD *)a1 + 2) - *(_QWORD *)(v16 + 48 * (v20 & 0x1FF) + 32))
                    / v11;
                **((_DWORD **)a1 + 4) = vcvtd_n_u64_f64(v12, 3uLL);
                v63 = 1;
              }
              if (!(v62 & 1 | (v11 <= a5)))
                v28 = v20 & 0x1FF;
              v62 |= (v62 | (v11 <= a5)) ^ 1;
              if (!(v66 & 1 | (v11 <= a6)))
                v29 = v20 & 0x1FF;
              v66 |= (v66 | (v11 <= a6)) ^ 1;
              if (!(v65 & 1 | (v11 < 1.0)))
                v30 = v20 & 0x1FF;
              v65 |= (v65 | (v11 < 1.0)) ^ 1;
              if (v11 > 5.0 && (v64 & 1) == 0)
                v64 = 1;
              if ((v62 & 1) != 0 && (v66 & 1) != 0 && (v65 & 1) != 0 && (v64 & 1) != 0)
              {
                v67 = v61;
                if ((v63 & 1) != 0)
                {
                  v67 = v61;
                  goto LABEL_107;
                }
              }
              else
              {
                v67 = v61;
              }
            }
            ++v61;
            --v20;
          }
          while (v15 != v61);
          v61 = v15;
LABEL_107:
          v9 = v75;
          if (v15 >= 128 && v61 == v15)
          {
            if (v67 == -1)
              goto LABEL_19;
            v71 = (v74 - (_WORD)v67) & 0x1FF;
            if ((v63 & 1) == 0)
            {
              v11 = v58 - *(double *)(v16 + 48 * v71 + 40);
              if (v11 > 0.0)
              {
                v12 = (double)(unint64_t)(*((_QWORD *)a1 + 2) - *(_QWORD *)(v16 + 48 * v71 + 32));
                v11 = v12 / v11;
                **((_DWORD **)a1 + 4) = vcvtd_n_u64_f64(v11, 3uLL);
              }
            }
            if ((v62 & 1) == 0)
              v28 = v71;
            if ((v66 & 1) == 0)
              v29 = v71;
            if ((v65 & 1) == 0)
              v30 = v71;
          }
          else
          {
            if (v67 == -1)
              goto LABEL_19;
            v71 = (v74 - (_WORD)v67) & 0x1FF;
          }
          v72 = *(_QWORD *)(v16 + 48 * v71 + 32) / 0x3E8uLL;
          if ((unsigned __int16)(*((_QWORD *)a1 + 2) / 0x3E8uLL) < (unsigned __int16)v72
            && (unsigned __int16)(*((_QWORD *)a1 + 2) / 0x3E8uLL - v72) <= 0x7FFEu)
          {
            *v73 = 1000 * (v72 & 0x7FFFFFFFFF0000 | (unsigned __int16)(*((_QWORD *)a1 + 2) / 0x3E8uLL)) + 65536000;
          }
          goto LABEL_19;
        }
        ++v17;
        --v20;
      }
      while (v15 != v17);
    }
    v26 = 0;
    v27 = 0;
    v28 = -1;
    v29 = -1;
    v30 = -1;
    v22 = -1;
LABEL_18:
    v31 = a4;
LABEL_19:
    LODWORD(v32) = 0;
    for (i = 4; i != 64; i += 4)
      LODWORD(v32) = *(_DWORD *)((char *)v87 + i) + v32;
    if ((_DWORD)v32)
    {
      v34 = 0;
      v11 = (double)v32;
      v32 = 1;
      HIDWORD(v12) = 1072483532;
      do
      {
        v34 += *((_DWORD *)v87 + v32);
        if ((double)v34 / v11 > 0.9)
          break;
        ++v32;
      }
      while (v32 != 16);
    }
    **((_DWORD **)a1 + 3) = v32;
    if (((v22 | v28) & 0x80000000) == 0)
    {
      v35 = (double *)*((_QWORD *)a1 + 5);
      if (v35)
      {
        v36 = *(_DWORD *)(v16 + 48 * (v22 & 0x1FF) + 12);
        if (v36)
        {
          v37 = *(_DWORD *)(v16 + 48 * (v28 & 0x1FF) + 12);
          if (v37 && (v22 & 0x1FF) != (v28 & 0x1FF))
          {
            LODWORD(v11) = *(_DWORD *)(v16 + 48 * (v22 & 0x1FF) + 4);
            LODWORD(v12) = *(_DWORD *)(v16 + 48 * (v28 & 0x1FF) + 4);
            v12 = (double)*(unint64_t *)&v12;
            v11 = (double)*(unint64_t *)&v11 - v12;
            if (v11 > 0.0)
            {
              v12 = (double)v36 - (double)v37;
              if (v12 >= 0.0)
              {
                v11 = 1.0 - v12 / v11;
                HIDWORD(v12) = 0;
                if (v11 < 0.0)
                  v11 = 0.0;
                *v35 = v11;
              }
            }
          }
        }
      }
    }
    if (((v22 | v29) & 0x80000000) == 0)
    {
      v39 = (double *)*((_QWORD *)a1 + 6);
      if (v39)
      {
        v40 = *(_DWORD *)(v16 + 48 * (v22 & 0x1FF) + 12);
        if (v40)
        {
          v41 = *(_DWORD *)(v16 + 48 * (v29 & 0x1FF) + 12);
          if (v41 && (v22 & 0x1FF) != (v29 & 0x1FF))
          {
            LODWORD(v11) = *(_DWORD *)(v16 + 48 * (v22 & 0x1FF) + 4);
            LODWORD(v12) = *(_DWORD *)(v16 + 48 * (v29 & 0x1FF) + 4);
            v43 = (double)*(unint64_t *)&v11 - (double)*(unint64_t *)&v12;
            if (v43 > 0.0)
            {
              v44 = (double)v40 - (double)v41;
              if (v44 >= 0.0)
              {
                v45 = 1.0 - v44 / v43;
                if (v45 < 0.0)
                  v45 = 0.0;
                *v39 = v45;
              }
            }
          }
        }
      }
    }
    v46 = (double *)*((_QWORD *)a1 + 7);
    if (v31)
    {
      *v46 = 0.0;
      if (!v26)
      {
LABEL_74:
        pthread_mutex_unlock(v9);
        return;
      }
      v47 = (double)v27 / (double)v26;
    }
    else
    {
      if ((v22 | v30) < 0 || !v46)
        goto LABEL_74;
      v50 = 0;
      v51 = 0;
      v47 = NAN;
      do
      {
        v52 = *(_DWORD *)(v16 + 48 * (((_WORD)v22 - (_WORD)v51) & 0x1FF) + 16);
        if (v52)
        {
          v53 = 0;
          v54 = (double)v52;
          do
          {
            v55 = *(_DWORD *)(v16 + 48 * (((_WORD)v30 + (_WORD)v53) & 0x1FF) + 16);
            if (v55)
            {
              if ((((_WORD)v22 - (_WORD)v51) & 0x1FF) == (((_WORD)v30 + (_WORD)v53) & 0x1FF))
                break;
              LODWORD(v13) = *(_DWORD *)(v16 + 48 * (((_WORD)v22 - (_WORD)v51) & 0x1FF) + 8);
              LODWORD(v14) = *(_DWORD *)(v16 + 48 * (((_WORD)v30 + (_WORD)v53) & 0x1FF) + 8);
              v14 = (double)*(unint64_t *)&v14;
              v13 = (double)*(unint64_t *)&v13 - v14;
              if (v13 > 0.0)
              {
                v14 = v54 - (double)v55;
                if (v14 >= 0.0)
                {
                  v13 = 1.0 - v14 / v13;
                  if (v13 < 0.0)
                    v13 = 0.0;
                  v56 = v47 > v13;
                  if (v47 > v13)
                    v47 = v13;
                  v50 |= v56;
                }
              }
            }
            ++v53;
          }
          while (v53 != 3);
        }
        ++v51;
      }
      while (v51 != 3);
      if ((v50 & 1) == 0)
        goto LABEL_74;
    }
    *v46 = v47;
    goto LABEL_74;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v48 = VRTraceErrorLogLevelToCSTR();
    v49 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCMediaQueueUtil_FindPacketInTxHistory_cold_1(v48, v49);
  }
}

uint64_t VCPayloadUtils_AudioCodecRateModeForBitrate(int a1, int a2)
{
  uint64_t v4;
  NSObject *v5;
  int v6;
  uint64_t v7;
  __int16 v8;
  const char *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  int v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (a1 <= 106)
  {
    if (a1 == 97)
    {
      if (a2 > 7399)
      {
        if (a2 > 10199)
        {
          if (a2 == 10200)
            return 6;
          if (a2 == 12200)
            return 7;
        }
        else
        {
          if (a2 == 7400)
            return 4;
          if (a2 == 7950)
            return 5;
        }
      }
      else if (a2 > 5899)
      {
        if (a2 == 5900)
          return 2;
        if (a2 == 6700)
          return 3;
      }
      else
      {
        if (a2 == 4750)
          return 0;
        if (a2 == 5150)
          return 1;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v4 = VRTraceErrorLogLevelToCSTR();
        v5 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v6 = 136315906;
          v7 = v4;
          v8 = 2080;
          v9 = "_VCPayloadUtils_AudioCodecRateModeForAMRBitrate";
          v10 = 1024;
          v11 = 938;
          v12 = 1024;
          v13 = a2;
          _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Unsupported bitrate %d", (uint8_t *)&v6, 0x22u);
        }
      }
      return 0xFFFFFFFFLL;
    }
    if (a1 == 98)
      return _VCPayloadUtils_AudioCodecRateModeForAMRWBBitrate(a2);
LABEL_23:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCPayloadUtils_AudioCodecRateModeForBitrate_cold_1();
    }
    return 0xFFFFFFFFLL;
  }
  if ((a1 - 107) >= 2 && a1 != 111)
    goto LABEL_23;
  if (a2 > 24399)
  {
    if (a2 > 63999)
    {
      switch(a2)
      {
        case 64000:
          return 19;
        case 96000:
          return 20;
        case 128000:
          return 21;
      }
    }
    else
    {
      switch(a2)
      {
        case 24400:
          return 16;
        case 32000:
          return 17;
        case 48000:
          return 18;
      }
    }
    return _VCPayloadUtils_AudioCodecRateModeForAMRWBBitrate(a2);
  }
  if (a2 > 9599)
  {
    switch(a2)
    {
      case 9600:
        return 13;
      case 13200:
        return 14;
      case 16400:
        return 15;
    }
    return _VCPayloadUtils_AudioCodecRateModeForAMRWBBitrate(a2);
  }
  if (a2 == 5900)
    return 10;
  if (a2 != 7200)
  {
    if (a2 == 8000)
      return 12;
    return _VCPayloadUtils_AudioCodecRateModeForAMRWBBitrate(a2);
  }
  return 11;
}

uint64_t VCPayloadUtils_CodecTypeForPayload(int a1)
{
  uint64_t result;
  uint64_t v3;
  NSObject *v4;
  int v5;
  uint64_t v6;
  __int16 v7;
  const char *v8;
  __int16 v9;
  int v10;
  __int16 v11;
  int v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (a1 <= 96)
  {
    if (a1)
    {
      if (a1 == 8)
      {
        return 6;
      }
      else if (a1 == 13)
      {
        return 9;
      }
      else
      {
LABEL_30:
        if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          v3 = VRTraceErrorLogLevelToCSTR();
          v4 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v5 = 136315906;
            v6 = v3;
            v7 = 2080;
            v8 = "VCPayloadUtils_CodecTypeForPayload";
            v9 = 1024;
            v10 = 1275;
            v11 = 1024;
            v12 = a1;
            _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Unsupported payload %d", (uint8_t *)&v5, 0x22u);
          }
        }
        return 0;
      }
    }
    else
    {
      return 5;
    }
  }
  else
  {
    switch(a1)
    {
      case 'a':
        result = 1;
        break;
      case 'b':
        result = 2;
        break;
      case 'c':
        result = 13;
        break;
      case 'd':
        result = 102;
        break;
      case 'e':
        result = 16;
        break;
      case 'h':
        result = 8;
        break;
      case 'j':
        result = 7;
        break;
      case 'k':
        result = 3;
        break;
      case 'l':
        result = 4;
        break;
      case 'n':
        result = 300;
        break;
      case 'o':
        result = 17;
        break;
      case 'p':
        result = 18;
        break;
      case 'q':
        result = 20;
        break;
      case 'u':
        result = 10;
        break;
      case 'w':
        result = 11;
        break;
      case 'y':
        result = 15;
        break;
      case 'z':
        result = 14;
        break;
      case '{':
        result = 100;
        break;
      case '|':
        result = 301;
        break;
      case '}':
        result = 302;
        break;
      case '~':
        result = 101;
        break;
      default:
        goto LABEL_30;
    }
  }
  return result;
}

uint64_t VCPayloadUtils_supportsInternalDTXForPayload(int a1)
{
  return ((a1 - 97) < 0xF) & (0x4C03u >> (a1 - 97));
}

uint64_t _VCPayloadUtils_AudioCodecRateModeForAMRWBBitrate(int a1)
{
  uint64_t v3;
  NSObject *v4;
  int v5;
  uint64_t v6;
  __int16 v7;
  const char *v8;
  __int16 v9;
  int v10;
  __int16 v11;
  int v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (a1 <= 15849)
  {
    if (a1 > 12649)
    {
      if (a1 == 12650)
        return 2;
      if (a1 == 14250)
        return 3;
    }
    else
    {
      if (a1 == 6600)
        return 0;
      if (a1 == 8850)
        return 1;
    }
  }
  else if (a1 <= 19849)
  {
    if (a1 == 15850)
      return 4;
    if (a1 == 18250)
      return 5;
  }
  else
  {
    switch(a1)
    {
      case 19850:
        return 6;
      case 23050:
        return 7;
      case 23850:
        return 8;
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v3 = VRTraceErrorLogLevelToCSTR();
    v4 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v5 = 136315906;
      v6 = v3;
      v7 = 2080;
      v8 = "_VCPayloadUtils_AudioCodecRateModeForAMRWBBitrate";
      v9 = 1024;
      v10 = 964;
      v11 = 1024;
      v12 = a1;
      _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Unsupported bitrate %d", (uint8_t *)&v5, 0x22u);
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t VCPayloadUtils_DefaultAudioCodecBandwidthCodecForSampleRate(int a1)
{
  unsigned int v1;

  if (a1 == 16000)
    v1 = 1;
  else
    v1 = 2;
  if (a1 == 8000)
    return 0;
  else
    return v1;
}

uint64_t VCPayloadUtils_BitrateForAudioCodecRateMode(uint64_t a1, uint64_t a2)
{
  return +[VCPayloadUtils bitrateForCodecType:mode:](VCPayloadUtils, "bitrateForCodecType:mode:", +[VCPayloadUtils codecTypeForPayload:](VCPayloadUtils, "codecTypeForPayload:", a1), a2);
}

float VCPayloadUtils_BlockSizeForPayload(uint64_t a1, uint64_t a2)
{
  double v2;

  +[VCPayloadUtils blockSizeForPayload:sampleRate:](VCPayloadUtils, "blockSizeForPayload:sampleRate:", a1, a2);
  return v2;
}

uint64_t VCPayloadUtils_CodecSamplesPerFrameWithSampleRate(uint64_t a1, uint64_t a2)
{
  return +[VCPayloadUtils codecSamplesPerFrameForPayload:blockSize:sampleRate:](VCPayloadUtils, "codecSamplesPerFrameForPayload:blockSize:sampleRate:", a1, a2);
}

uint64_t VCPayloadUtils_AudioCodecBandwidthForBandwidth(uint64_t a1)
{
  return +[VCPayloadUtils vcAudioCodecBandwidthForAudioCodecBandwidth:](VCPayloadUtils, "vcAudioCodecBandwidthForAudioCodecBandwidth:", a1);
}

uint64_t VCPayloadUtils_AudioCodecBandwidthForVCAudioCodecBandwidth(uint64_t a1)
{
  return +[VCPayloadUtils audioCodecBandwidthForVCAudioCodecBandwidth:](VCPayloadUtils, "audioCodecBandwidthForVCAudioCodecBandwidth:", a1);
}

const char *VCPayloadUtils_AmrNbBitRateStringForBitRate(int a1)
{
  if (a1 > 7399)
  {
    if (a1 > 10199)
    {
      if (a1 == 10200)
        return "AMR-NB 10.2";
      if (a1 == 12200)
        return "AMR-NB 12.2";
    }
    else
    {
      if (a1 == 7400)
        return "AMR-NB 7.4";
      if (a1 == 7950)
        return "AMR-NB 7.95";
    }
  }
  else if (a1 > 5899)
  {
    if (a1 == 5900)
      return "AMR-NB 5.9";
    if (a1 == 6700)
      return "AMR-NB 6.7";
  }
  else
  {
    if (a1 == 4750)
      return "AMR-NB 4.75";
    if (a1 == 5150)
      return "AMR-NB 5.15";
  }
  return "";
}

const char *VCPayloadUtils_AmrWbBitRateStringForBitRate(int a1)
{
  if (a1 <= 15849)
  {
    if (a1 > 12649)
    {
      if (a1 == 12650)
        return "AMR-WB 12.65";
      if (a1 == 14250)
        return "AMR-WB 14.25";
    }
    else
    {
      if (a1 == 6600)
        return "AMR-WB 6.6";
      if (a1 == 8850)
        return "AMR-WB 8.85";
    }
  }
  else if (a1 <= 19849)
  {
    if (a1 == 15850)
      return "AMR-WB 15.85";
    if (a1 == 18250)
      return "AMR-WB 18.25";
  }
  else
  {
    switch(a1)
    {
      case 19850:
        return "AMR-WB 19.85";
      case 23050:
        return "AMR-WB 23.05";
      case 23850:
        return "AMR-WB 23.85";
    }
  }
  return "";
}

const char *VCPayloadUtils_EvsBitRateStringForBitRate(int a1)
{
  if (a1 <= 16399)
  {
    if (a1 > 9599)
    {
      if (a1 <= 13199)
      {
        if (a1 == 9600)
          return "EVS PRI 9.6";
        if (a1 == 12650)
          return "EVS IO 12.65";
      }
      else
      {
        switch(a1)
        {
          case 13200:
            return "EVS PRI 13.2";
          case 14250:
            return "EVS IO 14.25";
          case 15850:
            return "EVS IO 15.85";
        }
      }
    }
    else if (a1 <= 7199)
    {
      if (a1 == 5900)
        return "EVS PRI 5.9";
      if (a1 == 6600)
        return "EVS IO 6.6";
    }
    else
    {
      switch(a1)
      {
        case 7200:
          return "EVS PRI 7.2";
        case 8000:
          return "EVS PRI 8";
        case 8850:
          return "EVS IO 8.85";
      }
    }
  }
  else if (a1 <= 24399)
  {
    if (a1 <= 19849)
    {
      if (a1 == 16400)
        return "EVS PRI 16.4";
      if (a1 == 18250)
        return "EVS IO 18.25";
    }
    else
    {
      switch(a1)
      {
        case 19850:
          return "EVS IO 19.85";
        case 23050:
          return "EVS IO 23.05";
        case 23850:
          return "EVS IO 23.85";
      }
    }
  }
  else if (a1 > 63999)
  {
    switch(a1)
    {
      case 64000:
        return "EVS PRI 64";
      case 96000:
        return "EVS PRI 96";
      case 128000:
        return "EVS PRI 128";
    }
  }
  else
  {
    switch(a1)
    {
      case 24400:
        return "EVS PRI 24.4";
      case 32000:
        return "EVS PRI 32";
      case 48000:
        return "EVS PRI 48";
    }
  }
  return "";
}

uint64_t VCPayloadUtils_SupportsShortREDForPayload()
{
  return 0;
}

uint64_t VCPayloadUtils_ShortREDBitrateForPayload(int a1, int a2)
{
  uint64_t result;

  if (!a2)
    return 0;
  if (a1 == 113)
    return 4800;
  if (a1 == 112)
    return 2000;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    VCPayloadUtils_ShortREDBitrateForPayload_cold_1();
  }
  return 0;
}

uint64_t RTCPCopySendControlParameters(__int128 *a1, uint64_t a2, OSQueueHead *a3, char **a4)
{
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  _QWORD *v16;
  char *v17;
  char *v18;
  unint64_t opaque1;
  char *v20;
  size_t v21;
  const void *v22;
  unint64_t *v23;
  unint64_t v24;
  unint64_t v25;
  const void *v26;
  uint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  int v30;
  const void *v31;
  unint64_t *v32;
  unint64_t v33;
  int64_t v34;
  const void *v35;
  unint64_t *v36;
  unint64_t v37;
  const void *v38;
  unint64_t *v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t v43[4];

  v43[3] = *MEMORY[0x1E0C80C00];
  if (!a1 || !a2 || !a3 || !a4)
  {
    v41 = 2147549185;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RTCPCopySendControlParameters_cold_2();
    }
    goto LABEL_50;
  }
  v8 = *a1;
  v9 = a1[2];
  *(_OWORD *)(a2 + 16) = a1[1];
  *(_OWORD *)(a2 + 32) = v9;
  *(_OWORD *)a2 = v8;
  v10 = a1[3];
  v11 = a1[4];
  v12 = a1[6];
  *(_OWORD *)(a2 + 80) = a1[5];
  *(_OWORD *)(a2 + 96) = v12;
  *(_OWORD *)(a2 + 48) = v10;
  *(_OWORD *)(a2 + 64) = v11;
  v13 = a1[7];
  v14 = a1[8];
  v15 = a1[9];
  *(_QWORD *)(a2 + 160) = *((_QWORD *)a1 + 20);
  *(_OWORD *)(a2 + 128) = v14;
  *(_OWORD *)(a2 + 144) = v15;
  *(_OWORD *)(a2 + 112) = v13;
  v16 = (_QWORD *)(a2 + 8);
  if (!*(_QWORD *)(a2 + 8)
    && !*((_QWORD *)a1 + 4)
    && !*((_QWORD *)a1 + 7)
    && !*((_QWORD *)a1 + 9)
    && !*((_QWORD *)a1 + 19))
  {
    v18 = 0;
    goto LABEL_40;
  }
  v17 = (char *)VCMemoryPool_Alloc(a3);
  if (!v17)
  {
    v41 = 2147549187;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RTCPCopySendControlParameters_cold_1();
    }
LABEL_50:
    v18 = 0;
    goto LABEL_41;
  }
  v18 = v17;
  opaque1 = (unint64_t)a3[1].opaque1;
  v20 = &v17[opaque1];
  memset(v43, 170, 24);
  if (v17 > &v17[opaque1])
    goto LABEL_52;
  v43[0] = (unint64_t)v17;
  v43[1] = opaque1;
  v43[2] = 0;
  v21 = *((_QWORD *)a1 + 2);
  if (v21)
  {
    v22 = (const void *)*((_QWORD *)a1 + 1);
    if (v22)
    {
      v23 = RTCPPackSendControlParameter(v43, v22, v21);
      if (!v23)
        goto LABEL_42;
      if (v24 < (unint64_t)v23)
        goto LABEL_52;
      v25 = *((_QWORD *)a1 + 2);
      if (v25 > v24 - (unint64_t)v23)
        goto LABEL_52;
      *(_QWORD *)(a2 + 8) = v23;
      *(_QWORD *)(a2 + 16) = v25;
    }
  }
  v26 = (const void *)*((_QWORD *)a1 + 4);
  if (v26)
  {
    v27 = *((unsigned int *)a1 + 10);
    if ((int)v27 >= 1)
    {
      v28 = RTCPPackSendControlParameter(v43, v26, 2 * v27);
      if (!v28)
        goto LABEL_42;
      if ((unint64_t)v28 > v29)
        goto LABEL_52;
      v30 = *((_DWORD *)a1 + 10);
      if (v30 < 0 || (uint64_t)(v29 - (_QWORD)v28) >> 1 < v30)
        goto LABEL_52;
      *(_QWORD *)(a2 + 32) = v28;
      *(_DWORD *)(a2 + 40) = v30;
    }
  }
  v31 = (const void *)*((_QWORD *)a1 + 7);
  if (v31 && *((_BYTE *)a1 + 64))
  {
    v32 = RTCPPackSendControlParameter(v43, v31, 36 * *((unsigned __int8 *)a1 + 64));
    if (!v32)
      goto LABEL_42;
    if ((unint64_t)v32 > v33)
      goto LABEL_52;
    v34 = *((unsigned __int8 *)a1 + 64);
    if ((uint64_t)(0x8E38E38E38E38E39 * ((uint64_t)(v33 - (_QWORD)v32) >> 2)) < v34)
      goto LABEL_52;
    *(_QWORD *)(a2 + 56) = v32;
    *(_BYTE *)(a2 + 64) = v34;
  }
  v35 = (const void *)*((_QWORD *)a1 + 9);
  if (!v35)
    goto LABEL_35;
  v36 = RTCPPackSendControlParameter(v43, v35, 0x14uLL);
  if (!v36)
  {
LABEL_42:
    if (v18 < v20)
    {
      v41 = 2147549187;
      VCMemoryPool_Free(a3, v18);
      v18 = 0;
      *(_QWORD *)(a2 + 32) = 0;
      *(_DWORD *)(a2 + 40) = 0;
      *(_QWORD *)(a2 + 56) = 0;
      *(_BYTE *)(a2 + 64) = 0;
      *(_QWORD *)(a2 + 72) = 0;
      *(_QWORD *)(a2 + 152) = 0;
      *v16 = 0;
      *(_QWORD *)(a2 + 16) = 0;
      goto LABEL_41;
    }
LABEL_52:
    __break(0x5519u);
  }
  if ((unint64_t)v36 >= v37)
    goto LABEL_52;
  *(_QWORD *)(a2 + 72) = v36;
LABEL_35:
  v38 = (const void *)*((_QWORD *)a1 + 19);
  if (!v38)
    goto LABEL_39;
  v39 = RTCPPackSendControlParameter(v43, v38, 8uLL);
  if (!v39)
    goto LABEL_42;
  if ((unint64_t)v39 >= v40)
    goto LABEL_52;
  *(_QWORD *)(a2 + 152) = v39;
LABEL_39:
  if (v18 >= v20)
    goto LABEL_52;
LABEL_40:
  v41 = 0;
LABEL_41:
  *a4 = v18;
  return v41;
}

unint64_t *RTCPPackSendControlParameter(unint64_t *result, const void *a2, size_t __n)
{
  uint64_t *v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  int v16;
  uint64_t v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  size_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if (!result)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RTCPPackSendControlParameter_cold_1();
    }
    return 0;
  }
  v4 = (uint64_t *)result;
  v5 = result[1];
  v6 = result[2];
  if (v5 - v6 < __n)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v7 = VRTraceErrorLogLevelToCSTR();
      v8 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v10 = *v4;
        v9 = v4[1];
        v11 = v4[2];
        v16 = 136316930;
        v17 = v7;
        v18 = 2080;
        v19 = "RTCPPackSendControlParameter";
        v20 = 1024;
        v21 = 100;
        v22 = 2048;
        v23 = v10;
        v24 = 2048;
        v25 = v9;
        v26 = 2048;
        v27 = v11;
        v28 = 2048;
        v29 = v9 - v11;
        v30 = 2048;
        v31 = __n;
        _os_log_error_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_ERROR, " [%s] %s:%d Insufficient space in buffer {base=%p count=%zu offset=%zu size=%zu}, requesting %zu bytes ", (uint8_t *)&v16, 0x4Eu);
      }
    }
    return 0;
  }
  v13 = *result + v5;
  v12 = *result + v6;
  if (v13 < v12 || *result > v12 || v13 - v12 < __n)
  {
    __break(0x5519u);
    return result;
  }
  memcpy((void *)(*result + v6), a2, __n);
  v4[2] += __n;
  return (unint64_t *)v12;
}

CFTypeRef RTCPShallowCopyPacketList(void *__src, CFTypeRef *__dst)
{
  memcpy(__dst, __src, 0x668uLL);
  return CFRetain(__dst[12]);
}

uint64_t RTCPReducedSizePackets(uint64_t a1, char a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2147549186;
  *(_BYTE *)(v3 + 10460) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t RTCPSetHopByHopEncryptionEnabled(uint64_t a1, char a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2147549186;
  *(_BYTE *)(v3 + 10462) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t RTPGetRTCPHasPendingPLI(uint64_t a1, _DWORD *a2)
{
  uint64_t v2;
  uint64_t v4;

  v2 = 2147549185;
  if (a2)
  {
    v4 = CheckInHandleDebug();
    if (v4)
    {
      *a2 = *(_DWORD *)(v4 + 104);
      CheckOutHandleDebug();
      return 0;
    }
    else
    {
      return 2147549186;
    }
  }
  return v2;
}

uint64_t RTPGetRecvStats(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v6;

  v3 = 2147549185;
  if (a2 && a3)
  {
    v6 = CheckInHandleDebug();
    if (v6)
    {
      *a2 = *(_DWORD *)(v6 + 320);
      *a3 = *(_DWORD *)(v6 + 324);
      CheckOutHandleDebug();
      return 0;
    }
    else
    {
      return 2147549186;
    }
  }
  return v3;
}

uint64_t RTCPSetSendPLI()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  int v3;
  int ErrorLogLevelForModule;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  int v10;
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v0 = 2147549239;
  v1 = CheckInHandleDebug();
  if (!v1)
    return 2147549186;
  v2 = v1;
  v3 = *(_DWORD *)(v1 + 104);
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (v3)
  {
    if (ErrorLogLevelForModule >= 7)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v6 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v10 = 136315650;
        v11 = v5;
        v12 = 2080;
        v13 = "RTCPSetSendPLI";
        v14 = 1024;
        v15 = 256;
        _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d PSFB PLI is already scheduled to be sent in the next RTCP interval", (uint8_t *)&v10, 0x1Cu);
      }
    }
  }
  else
  {
    if (ErrorLogLevelForModule >= 7)
    {
      v7 = VRTraceErrorLogLevelToCSTR();
      v8 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v10 = 136315650;
        v11 = v7;
        v12 = 2080;
        v13 = "RTCPSetSendPLI";
        v14 = 1024;
        v15 = 253;
        _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d PSFB PLI will be sent in the next RTCP interval", (uint8_t *)&v10, 0x1Cu);
      }
    }
    v0 = 0;
    *(_DWORD *)(v2 + 104) = 1;
  }
  CheckOutHandleDebug();
  return v0;
}

uint64_t RTCPSetSendTMMBR(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  int v10;
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v3 = 2147549239;
  v4 = CheckInHandleDebug();
  if (!v4)
    return 2147549186;
  if (*(_DWORD *)(v4 + 128) && *(_DWORD *)(v4 + 132) == a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v6 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v10 = 136315650;
        v11 = v5;
        v12 = 2080;
        v13 = "RTCPSetSendTMMBR";
        v14 = 1024;
        v15 = 315;
        _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTPFB TMMBR is already scheduled to be sent in the next RTCP interval", (uint8_t *)&v10, 0x1Cu);
      }
    }
    goto LABEL_11;
  }
  *(_DWORD *)(v4 + 128) = 1;
  *(_DWORD *)(v4 + 132) = a2;
  if ((int)VRTraceGetErrorLogLevelForModule() < 7)
    goto LABEL_10;
  v7 = VRTraceErrorLogLevelToCSTR();
  v8 = *MEMORY[0x1E0CF2758];
  v3 = 0;
  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
  {
    v10 = 136315906;
    v11 = v7;
    v12 = 2080;
    v13 = "RTCPSetSendTMMBR";
    v14 = 1024;
    v15 = 313;
    v16 = 1024;
    v17 = a2;
    _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTPFB TMMBR bitrate:%d, will be sent in the next RTCP interval", (uint8_t *)&v10, 0x22u);
LABEL_10:
    v3 = 0;
  }
LABEL_11:
  CheckOutHandleDebug();
  return v3;
}

uint64_t RTPCheckRTCPSendIntervalElapsed(uint64_t a1, _DWORD *a2, double *a3)
{
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;

  v3 = 2147549185;
  if (a2)
  {
    v6 = CheckInHandleDebug();
    if (v6)
    {
      v7 = v6;
      v8 = micro();
      v9 = *(double *)(v7 + 160);
      v10 = v8 + 0.001 - v9;
      v11 = *(double *)(v7 + 176);
      *a2 = v10 > v11;
      v12 = v11 - (v8 - v9);
      if (v10 > v11)
        v12 = 0.0;
      *a3 = v12;
      CheckOutHandleDebug();
      return 0;
    }
    else
    {
      return 2147549186;
    }
  }
  return v3;
}

uint64_t RTPSendControlPacket(uint64_t a1, int *a2)
{
  uint64_t v4;
  uint64_t v5;
  double v6;
  double v7;
  int v8;
  int v9;
  uint64_t v10;
  double *v11;
  double v12;

  v4 = CheckInHandleDebug();
  if (v4)
  {
    v5 = v4;
    if (*(_DWORD *)(v4 + 184))
    {
      v6 = micro();
      v7 = v6;
      v8 = *a2;
      if ((*a2 & 0x50) != 0)
      {
        if ((v8 & 0x10) != 0)
        {
          v9 = a2[12];
          *(_DWORD *)(v5 + 136) = 1;
          *(_DWORD *)(v5 + 140) = v9;
        }
        if ((v8 & 0x40) != 0)
        {
          *(_DWORD *)(v5 + 96) = 1;
          *(_BYTE *)(v5 + 100) = *((_BYTE *)a2 + 24);
        }
        v10 = RTPSendRTCP(a1);
        if ((v10 & 0x80000000) != 0)
          goto LABEL_15;
        v11 = (double *)(v5 + 160);
        goto LABEL_13;
      }
      v12 = *(double *)(v5 + 160);
      v11 = (double *)(v5 + 160);
      if (v6 + 0.001 - v12 > v11[2])
      {
        v10 = RTPSendRTCP(a1);
        if ((v10 & 0x80000000) != 0)
        {
LABEL_15:
          CheckOutHandleDebug();
          return v10;
        }
LABEL_13:
        *v11 = v7;
        goto LABEL_15;
      }
    }
    v10 = 0;
    goto LABEL_15;
  }
  return 2147549186;
}

uint64_t RTPSendRTCP(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  char v6;
  int v7;
  int v8;
  unsigned int v9;
  uint64_t *v10;
  uint64_t v11;
  int v12;
  unsigned __int16 *v13;
  int v14;
  unsigned int v15;
  __int16 v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  os_log_t *v20;
  int ErrorLogLevelForModule;
  int v22;
  uint64_t v24;
  int v25;
  char IsOSFaultDisabled;
  NSObject *v27;
  unint64_t v28;
  unsigned __int16 *v29;
  unint64_t v30;
  int v31;
  int v32;
  unint64_t v33;
  unsigned __int16 *v34;
  int v35;
  int v36;
  NSObject *v37;
  unint64_t v38;
  unsigned __int16 *v39;
  NSObject *v40;
  unint64_t v41;
  int v42;
  int v43;
  unint64_t v44;
  unsigned __int16 *v45;
  int v46;
  int v47;
  unsigned int v48;
  int v49;
  unsigned int v50;
  unsigned int v51;
  unsigned int v52;
  char *v53;
  char *v54;
  int v55;
  BOOL v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  unint64_t v64;
  unint64_t v65;
  uint8_t *v66;
  uint64_t v67;
  int v68;
  uint64_t v69;
  int v70;
  _DWORD *v71;
  char *v72;
  uint64_t v73;
  int v74;
  char *v75;
  unint64_t v76;
  uint64_t v77;
  int v78;
  uint64_t v79;
  char *v80;
  unint64_t v81;
  size_t v82;
  char *v83;
  size_t v84;
  char *v85;
  int v86;
  char *v87;
  uint64_t v88;
  int v89;
  uint8_t *v90;
  uint64_t v91;
  int v92;
  char *v93;
  uint64_t v94;
  int v95;
  char *v96;
  uint64_t v97;
  int v98;
  char *v99;
  uint64_t v100;
  int v101;
  char *v102;
  uint64_t v103;
  uint64_t *v104;
  uint64_t v105;
  uint64_t v106;
  char v107;
  uint64_t v108;
  _WORD *v109;
  unint64_t v110;
  BOOL v111;
  unsigned int v112;
  char v113;
  char v114;
  char v115;
  unsigned int v116;
  unint64_t v117;
  signed int v118;
  int v119;
  char *v120;
  uint64_t v121;
  unint64_t v122;
  _BOOL4 v123;
  char *v124;
  char *v126;
  BOOL v127;
  __int16 v128;
  unint64_t v129;
  double v130;
  unint64_t v131;
  unint64_t v132;
  double v133;
  double v134;
  double v135;
  unsigned int v136;
  NSObject *v137;
  NSObject *v138;
  int v139;
  unint64_t v140;
  uint64_t v141;
  unint64_t v142;
  uint64_t v143;
  int v144;
  char *v145;
  unint64_t v146;
  int v147;
  _WORD *v148;
  int v149;
  int v150;
  uint64_t v151;
  int v152;
  char v153;
  NSObject *v154;
  int v155;
  int v157;
  int v158;
  int v159;
  int v160;
  NSObject *v161;
  size_t v162;
  char *v163;
  NSObject *v164;
  int v165;
  int v166;
  int v167;
  int v168;
  uint64_t v169;
  NSObject *v170;
  const char *v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  unint64_t v175;
  unsigned int v176;
  signed int v177;
  char *v178;
  unsigned int v179;
  uint64_t v180;
  uint64_t v181;
  int v182;
  int v183;
  uint64_t v184;
  unsigned int v185;
  _BOOL4 v186;
  unint64_t v187;
  int v188;
  _OWORD v189[2];
  int v190;
  int v191;
  unint64_t v192;
  signed int v193;
  unint64_t v194;
  _DWORD __b[259];
  _DWORD __src[259];
  _WORD v197[2];
  unsigned int v198;
  char v199;
  char v200;
  _BYTE v201[258];
  uint64_t v202;
  char v203[1472];
  uint8_t buf[24];
  int v205;
  __int16 v206;
  int v207;
  __int16 v208;
  int v209;
  __int16 v210;
  int v211;
  __int16 v212;
  unsigned int v213;
  uint64_t v214;

  MEMORY[0x1E0C80A78](a1);
  v2 = v1;
  v214 = *MEMORY[0x1E0C80C00];
  v192 = 0xAAAAAAAAAAAAAAAALL;
  v190 = 0;
  memset(v189, 0, sizeof(v189));
  memset(__b, 170, sizeof(__b));
  v3 = CheckInHandleDebug();
  if (!v3)
    return 2147549186;
  v4 = v3;
  if (v3 == 0xFFFFFFFFLL)
    return 2147549190;
  memset(v203, 170, sizeof(v203));
  memset(__src, 170, sizeof(__src));
  if ((*(_WORD *)v2 & 0xE27) != 0)
  {
    v186 = 0;
LABEL_7:
    v6 = 1;
    goto LABEL_11;
  }
  v186 = *(_DWORD *)(v4 + 204) != 0;
  if (!*(_DWORD *)(v4 + 4832) && !*(_BYTE *)(v2 + 64))
    goto LABEL_7;
  v6 = 0;
LABEL_11:
  bzero(v201, 0x402uLL);
  v7 = strnlen((const char *)(v4 + 360), 0x100uLL);
  v8 = v7;
  if (v7 >= 256)
  {
    CheckOutHandleDebug();
    return 2147549192;
  }
  v184 = 2863311530;
  v193 = -1431655766;
  v9 = v7 + 6;
  if (v7 < -6)
    v9 = v7 + 9;
  v197[0] = -13695;
  v179 = (v9 >> 2) + 1;
  v197[1] = bswap32(v179) >> 16;
  v198 = bswap32(*(_DWORD *)(v4 + 200));
  v199 = 1;
  v200 = v7;
  __strncpy_chk();
  v10 = (uint64_t *)&v201[v8];
  if (v10 >= &v202 || v10 < (uint64_t *)v201)
    goto LABEL_381;
  *(_BYTE *)v10 = 0;
  v182 = *(_DWORD *)v2;
  if ((*(_DWORD *)v2 & 1) == 0)
  {
    if ((*(_DWORD *)v2 & 8) == 0)
    {
      LOWORD(v185) = 0;
      goto LABEL_70;
    }
    if (*(_DWORD *)(v4 + 148))
    {
      LOWORD(__src[0]) = __src[0] & 0x1F | 0xCE80;
      v12 = *(_DWORD *)(v2 + 40);
      if (v12)
      {
        if (v12 < 2)
        {
          v16 = 0;
        }
        else
        {
          v13 = *(unsigned __int16 **)(v2 + 32);
          v14 = *v13;
          LODWORD(v13) = v13[1];
          LOWORD(__src[0]) = -12670;
          v15 = bswap32(*(_DWORD *)(v4 + 4832));
          __src[1] = bswap32(*(_DWORD *)(v4 + 200));
          __src[2] = v15;
          __src[3] = bswap32((((_DWORD)v13 * v14) >> 2) & 0x7FC0 | 0x80000);
          v16 = 3;
        }
      }
      else
      {
        LOWORD(__src[0]) = -12671;
        v48 = bswap32(*(_DWORD *)(v4 + 4832));
        __src[1] = bswap32(*(_DWORD *)(v4 + 200));
        __src[2] = v48;
        v16 = 2;
      }
      LOWORD(v185) = v16;
      HIWORD(__src[0]) = v16 << 8;
      goto LABEL_70;
    }
    LODWORD(v17) = *(_DWORD *)(v2 + 40);
    LOWORD(__src[0]) = -16256;
    v185 = ((v17 + 1) >> 1) + 1;
    HIWORD(__src[0]) = bswap32(v185) >> 16;
    __src[1] = bswap32(*(_DWORD *)(v4 + 200));
    if ((int)v17 >= 1)
    {
      v18 = 0;
      v19 = 0;
      v20 = (os_log_t *)MEMORY[0x1E0CF2758];
      while (1)
      {
        if (v18 == 20)
          goto LABEL_381;
        *(_WORD *)((char *)&__src[2] + v18) = bswap32(*(unsigned __int16 *)(*(_QWORD *)(v2 + 32) + v18)) >> 16;
        ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
        v22 = *(_DWORD *)(v4 + 10456);
        if (v22 > ErrorLogLevelForModule || v22 < 1)
          goto LABEL_33;
        v24 = VRTraceErrorLogLevelToCSTR();
        v25 = *(_DWORD *)(v4 + 10456);
        if (v25 > 2)
        {
          if (v25 > 4)
          {
            if (v25 > 7)
            {
              if (v25 == 8)
              {
                v37 = *v20;
                v40 = *v20;
                if (!*MEMORY[0x1E0CF2748])
                {
                  if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
                  {
                    v44 = *(_QWORD *)(v2 + 32);
                    v45 = (unsigned __int16 *)(v44 + v18);
                    if (v44 + v18 >= v44 + 2 * *(int *)(v2 + 40) || (unint64_t)v45 < v44)
                      goto LABEL_381;
                    v46 = *(unsigned __int16 *)((char *)&__src[2] + v18);
                    v47 = *v45;
                    *(_DWORD *)buf = 136316418;
                    *(_QWORD *)&buf[4] = v24;
                    *(_WORD *)&buf[12] = 2080;
                    *(_QWORD *)&buf[14] = "RTPSendRTCP";
                    *(_WORD *)&buf[22] = 1024;
                    v205 = 1862;
                    v206 = 1024;
                    v207 = v19;
                    v208 = 1024;
                    v209 = v46;
                    v210 = 1024;
                    v211 = v47;
                    _os_log_debug_impl(&dword_1D8A54000, v37, OS_LOG_TYPE_DEBUG, " [%s] %s:%d i=%d awSizeAndFirstMBs=%d paramSizeAndFirstMBs=%d", buf, 0x2Eu);
                  }
                  goto LABEL_33;
                }
                if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
                {
                  v41 = *(_QWORD *)(v2 + 32);
                  v39 = (unsigned __int16 *)(v41 + v18);
                  if (v41 + v18 >= v41 + 2 * *(int *)(v2 + 40) || (unint64_t)v39 < v41)
                    goto LABEL_381;
                  goto LABEL_60;
                }
              }
            }
            else
            {
              v37 = *v20;
              if (os_log_type_enabled(*v20, OS_LOG_TYPE_DEFAULT))
              {
                v38 = *(_QWORD *)(v2 + 32);
                v39 = (unsigned __int16 *)(v38 + v18);
                if (v38 + v18 >= v38 + 2 * *(int *)(v2 + 40) || (unint64_t)v39 < v38)
                  goto LABEL_381;
LABEL_60:
                v42 = *(unsigned __int16 *)((char *)&__src[2] + v18);
                v43 = *v39;
                *(_DWORD *)buf = 136316418;
                *(_QWORD *)&buf[4] = v24;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "RTPSendRTCP";
                *(_WORD *)&buf[22] = 1024;
                v205 = 1862;
                v206 = 1024;
                v207 = v19;
                v208 = 1024;
                v209 = v42;
                v210 = 1024;
                v211 = v43;
                _os_log_impl(&dword_1D8A54000, v37, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d i=%d awSizeAndFirstMBs=%d paramSizeAndFirstMBs=%d", buf, 0x2Eu);
              }
            }
          }
          else
          {
            v27 = *v20;
            if (os_log_type_enabled(*v20, OS_LOG_TYPE_ERROR))
            {
              v30 = *(_QWORD *)(v2 + 32);
              v29 = (unsigned __int16 *)(v30 + v18);
              if (v30 + v18 >= v30 + 2 * *(int *)(v2 + 40) || (unint64_t)v29 < v30)
                goto LABEL_381;
              goto LABEL_45;
            }
          }
        }
        else
        {
          IsOSFaultDisabled = VRTraceIsOSFaultDisabled();
          v27 = *v20;
          if ((IsOSFaultDisabled & 1) == 0)
          {
            if (os_log_type_enabled(*v20, OS_LOG_TYPE_FAULT))
            {
              v33 = *(_QWORD *)(v2 + 32);
              v34 = (unsigned __int16 *)(v33 + v18);
              if (v33 + v18 >= v33 + 2 * *(int *)(v2 + 40) || (unint64_t)v34 < v33)
                goto LABEL_381;
              v35 = *(unsigned __int16 *)((char *)&__src[2] + v18);
              v36 = *v34;
              *(_DWORD *)buf = 136316418;
              *(_QWORD *)&buf[4] = v24;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "RTPSendRTCP";
              *(_WORD *)&buf[22] = 1024;
              v205 = 1862;
              v206 = 1024;
              v207 = v19;
              v208 = 1024;
              v209 = v35;
              v210 = 1024;
              v211 = v36;
              _os_log_fault_impl(&dword_1D8A54000, v27, OS_LOG_TYPE_FAULT, " [%s] %s:%d i=%d awSizeAndFirstMBs=%d paramSizeAndFirstMBs=%d", buf, 0x2Eu);
            }
            goto LABEL_33;
          }
          if (os_log_type_enabled(*v20, OS_LOG_TYPE_ERROR))
          {
            v28 = *(_QWORD *)(v2 + 32);
            v29 = (unsigned __int16 *)(v28 + v18);
            if (v28 + v18 >= v28 + 2 * *(int *)(v2 + 40) || (unint64_t)v29 < v28)
              goto LABEL_381;
LABEL_45:
            v31 = *(unsigned __int16 *)((char *)&__src[2] + v18);
            v32 = *v29;
            *(_DWORD *)buf = 136316418;
            *(_QWORD *)&buf[4] = v24;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "RTPSendRTCP";
            *(_WORD *)&buf[22] = 1024;
            v205 = 1862;
            v206 = 1024;
            v207 = v19;
            v208 = 1024;
            v209 = v31;
            v210 = 1024;
            v211 = v32;
            _os_log_error_impl(&dword_1D8A54000, v27, OS_LOG_TYPE_ERROR, " [%s] %s:%d i=%d awSizeAndFirstMBs=%d paramSizeAndFirstMBs=%d", buf, 0x2Eu);
          }
        }
LABEL_33:
        ++v19;
        v17 = *(int *)(v2 + 40);
        v18 += 2;
        if (v19 >= v17)
          goto LABEL_69;
      }
    }
    LODWORD(v19) = 0;
LABEL_69:
    if ((v17 & 1) != 0)
    {
      v148 = (_WORD *)&__src[2] + v19;
      if (v148 >= (_WORD *)&__src[7])
        goto LABEL_381;
      *v148 = -1;
      v149 = VRTraceGetErrorLogLevelForModule();
      v150 = *(_DWORD *)(v4 + 10456);
      if (v150 <= v149 && v150 >= 1)
      {
        v151 = VRTraceErrorLogLevelToCSTR();
        v152 = *(_DWORD *)(v4 + 10456);
        if (v152 > 2)
        {
          if (v152 <= 4)
          {
            v154 = *MEMORY[0x1E0CF2758];
            if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              goto LABEL_70;
            goto LABEL_310;
          }
          if (v152 > 7)
          {
            if (v152 != 8)
              goto LABEL_70;
            v161 = *MEMORY[0x1E0CF2758];
            v164 = *MEMORY[0x1E0CF2758];
            if (!*MEMORY[0x1E0CF2748])
            {
              if (os_log_type_enabled(v164, OS_LOG_TYPE_DEBUG))
              {
                v167 = (unsigned __int16)*v148;
                v168 = *(_DWORD *)(v2 + 40);
                *(_DWORD *)buf = 136316418;
                *(_QWORD *)&buf[4] = v151;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "RTPSendRTCP";
                *(_WORD *)&buf[22] = 1024;
                v205 = 1866;
                v206 = 1024;
                v207 = v19;
                v208 = 1024;
                v209 = v167;
                v210 = 1024;
                v211 = v168;
                _os_log_debug_impl(&dword_1D8A54000, v161, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Invalid Slice! i=%d awSizeAndFirstMBs=%d paramSizeAndFirstMBs=%d", buf, 0x2Eu);
              }
              goto LABEL_70;
            }
            if (!os_log_type_enabled(v164, OS_LOG_TYPE_DEFAULT))
              goto LABEL_70;
          }
          else
          {
            v161 = *MEMORY[0x1E0CF2758];
            if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              goto LABEL_70;
          }
          v165 = (unsigned __int16)*v148;
          v166 = *(_DWORD *)(v2 + 40);
          *(_DWORD *)buf = 136316418;
          *(_QWORD *)&buf[4] = v151;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "RTPSendRTCP";
          *(_WORD *)&buf[22] = 1024;
          v205 = 1866;
          v206 = 1024;
          v207 = v19;
          v208 = 1024;
          v209 = v165;
          v210 = 1024;
          v211 = v166;
          _os_log_impl(&dword_1D8A54000, v161, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Invalid Slice! i=%d awSizeAndFirstMBs=%d paramSizeAndFirstMBs=%d", buf, 0x2Eu);
          goto LABEL_70;
        }
        v153 = VRTraceIsOSFaultDisabled();
        v154 = *MEMORY[0x1E0CF2758];
        if ((v153 & 1) != 0)
        {
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            goto LABEL_70;
LABEL_310:
          v157 = (unsigned __int16)*v148;
          v158 = *(_DWORD *)(v2 + 40);
          *(_DWORD *)buf = 136316418;
          *(_QWORD *)&buf[4] = v151;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "RTPSendRTCP";
          *(_WORD *)&buf[22] = 1024;
          v205 = 1866;
          v206 = 1024;
          v207 = v19;
          v208 = 1024;
          v209 = v157;
          v210 = 1024;
          v211 = v158;
          _os_log_error_impl(&dword_1D8A54000, v154, OS_LOG_TYPE_ERROR, " [%s] %s:%d Invalid Slice! i=%d awSizeAndFirstMBs=%d paramSizeAndFirstMBs=%d", buf, 0x2Eu);
          goto LABEL_70;
        }
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_FAULT))
        {
          v159 = (unsigned __int16)*v148;
          v160 = *(_DWORD *)(v2 + 40);
          *(_DWORD *)buf = 136316418;
          *(_QWORD *)&buf[4] = v151;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "RTPSendRTCP";
          *(_WORD *)&buf[22] = 1024;
          v205 = 1866;
          v206 = 1024;
          v207 = v19;
          v208 = 1024;
          v209 = v159;
          v210 = 1024;
          v211 = v160;
          _os_log_fault_impl(&dword_1D8A54000, v154, OS_LOG_TYPE_FAULT, " [%s] %s:%d Invalid Slice! i=%d awSizeAndFirstMBs=%d paramSizeAndFirstMBs=%d", buf, 0x2Eu);
        }
      }
    }
LABEL_70:
    v49 = *(_DWORD *)v2;
    if ((*(_DWORD *)v2 & 4) != 0)
    {
      v50 = bswap32(*(_DWORD *)(v4 + 200));
      __b[0] = 33603968;
      __b[1] = v50;
      LOWORD(__b[2]) = bswap32(*(unsigned __int16 *)(v2 + 46)) >> 16;
      HIWORD(__b[2]) = bswap32(*(unsigned __int16 *)(v2 + 44)) >> 16;
      v183 = 2;
      if ((v49 & 0x800) == 0)
      {
LABEL_75:
        v181 = 2863267840;
        v11 = 43690;
        goto LABEL_76;
      }
    }
    else
    {
      v183 = 0;
      if ((v49 & 0x800) == 0)
        goto LABEL_75;
    }
    v51 = bswap32(*(_DWORD *)(v4 + 200));
    __b[0] = 50384257;
    __b[1] = v51;
    __b[2] = bswap32(*(_DWORD *)(v4 + 4832));
    LOWORD(__b[3]) = bswap32(*(unsigned __int16 *)(v2 + 46)) >> 16;
    HIWORD(__b[3]) = bswap32(*(unsigned __int16 *)(v2 + 44)) >> 16;
    v183 = 3;
    goto LABEL_75;
  }
  v183 = 0;
  LOWORD(v185) = 0;
  v184 = bswap32(*(_DWORD *)(v4 + 200));
  v181 = 0x1000000;
  v11 = 52097;
LABEL_76:
  v180 = v11;
  v187 = v4 + 27616;
  if ((v6 & 1) != 0)
  {
    v52 = 0;
    v53 = 0;
    v54 = 0;
  }
  else
  {
    v52 = *(unsigned __int8 *)(v2 + 64);
    if (*(_BYTE *)(v2 + 64) || *(_BYTE *)(v4 + 10461))
    {
      v54 = *(char **)(v2 + 56);
      v53 = &v54[36 * *(unsigned __int8 *)(v2 + 64)];
    }
    else
    {
      if (v4 >= v187)
        goto LABEL_381;
      v54 = (char *)v189;
      v53 = (char *)&v191;
      _RTCPInitializeReceptionReportBlock(v4, (uint64_t)v189);
      if (*(_DWORD *)(v4 + 28) <= 1u)
      {
        kdebug_trace();
        v54 = (char *)v189;
      }
      v52 = 1;
    }
  }
  v55 = *(_DWORD *)v2;
  v57 = (*(_DWORD *)v2 & 0xEFE) != 0 && *(_BYTE *)(v4 + 10460) != 0;
  v193 = 0;
  if ((v55 & 0x20) != 0)
  {
    v194 = 1472;
    v60 = *(_QWORD *)(v2 + 72);
    buf[5] = 0;
    *(_WORD *)&buf[6] = 0;
    strcpy((char *)buf, "LTCR");
    *(_QWORD *)&buf[8] = v60;
    *(_QWORD *)&buf[16] = 0;
    if (v4 >= v187)
      goto LABEL_381;
    v61 = _RTCPAddCustomReportPacket(v4, (unint64_t)v203, 0x5C0uLL, &v194, (uint64_t)buf);
    if ((v61 & 0x80000000) != 0)
    {
      v5 = v61;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          RTPSendRTCP_cold_22();
      }
      goto LABEL_306;
    }
LABEL_101:
    v62 = v194;
    v193 = v194;
    goto LABEL_102;
  }
  if (*(_BYTE *)(v4 + 10461))
  {
    v194 = 1472;
    memset(buf, 0, sizeof(buf));
    if (v186)
      v58 = 1297568594;
    else
      v58 = 1297568338;
    *(_DWORD *)buf = v58;
    if (v54 > v53)
      goto LABEL_381;
    if ((uint64_t)(0x8E38E38E38E38E39 * ((v53 - v54) >> 2)) < v52)
      goto LABEL_381;
    *(_QWORD *)&buf[8] = v54;
    *(_DWORD *)&buf[16] = v52;
    if (v4 >= v187)
      goto LABEL_381;
    v59 = _RTCPAddCustomReportPacket(v4, (unint64_t)v203, 0x5C0uLL, &v194, (uint64_t)buf);
    if ((v59 & 0x80000000) != 0)
    {
      v5 = v59;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          RTPSendRTCP_cold_21();
      }
      goto LABEL_306;
    }
    goto LABEL_101;
  }
  if (v57)
  {
    v62 = 0;
    goto LABEL_102;
  }
  v118 = 0;
  v119 = 0;
  if (v54)
    v120 = v53;
  else
    v120 = 0;
  do
  {
    if (v52 - v119 >= 0x1F)
      v121 = 31;
    else
      v121 = v52 - v119;
    v122 = 1472 - v118;
    v192 = v122;
    v123 = v186;
    if (v119)
      v123 = 0;
    if (v54)
      v124 = &v54[36 * v119];
    else
      v124 = 0;
    if (v124 > v120 || v54 > v124)
      goto LABEL_381;
    v126 = &v203[v118];
    v127 = 0x8E38E38E38E38E39 * ((v120 - v124) >> 2) < v121 || v126 > (char *)buf;
    if (v127 || v203 > v126 || v4 >= v187)
      goto LABEL_381;
    if (v122 < 4)
      goto LABEL_279;
    if (v123)
      v128 = -14208;
    else
      v128 = -13952;
    *(_WORD *)&v203[v118] = v128 | v121 | *(_WORD *)&v203[v118] & 0x20;
    v129 = 1468 - v118;
    if (v123)
    {
      if (v129 < 0x18)
        goto LABEL_279;
      v177 = v118;
      v178 = v120;
      v130 = micro();
      v131 = MicroToNTP(v130);
      LODWORD(v132) = *(_DWORD *)(v4 + 312);
      v133 = (double)v132;
      LODWORD(v132) = *(_DWORD *)(v4 + 700);
      v134 = (double)v132;
      v135 = NTPToMicro(*(_QWORD *)(v4 + 304));
      v136 = _RTPSendTimestampWithMediaSampleTime(v4, (v133 + v134 * (v130 - v135)));
      if (v126 + 52 > (char *)buf)
        goto LABEL_381;
      v175 = HIDWORD(v131);
      *((_DWORD *)v126 + 1) = bswap32(*(_DWORD *)(v4 + 200));
      *((_DWORD *)v126 + 2) = bswap32(HIDWORD(v131));
      v176 = v136;
      *((_DWORD *)v126 + 3) = bswap32(v131);
      *((_DWORD *)v126 + 4) = bswap32(v136);
      *(int8x8_t *)(v126 + 20) = vrev32_s8(*(int8x8_t *)(v4 + 204));
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v174 = VRTraceErrorLogLevelToCSTR();
        v137 = *MEMORY[0x1E0CF2758];
        v138 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v138, OS_LOG_TYPE_DEFAULT))
          {
            v139 = *(_DWORD *)(v4 + 28);
            *(_DWORD *)buf = 136316674;
            *(_QWORD *)&buf[4] = v174;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_RTCPAddSenderReportHeader";
            *(_WORD *)&buf[22] = 1024;
            v205 = 1428;
            v206 = 1024;
            v207 = 1428;
            v208 = 1024;
            v209 = v139;
            v210 = 1024;
            v211 = v175;
            v212 = 1024;
            v213 = v176;
            _os_log_impl(&dword_1D8A54000, v137, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/RTCPTransport.c:%d: Sending RTCP SR packet PayloadType=%d NTP Seconds=%u RTPTimestamp=%u", buf, 0x34u);
          }
        }
        else if (os_log_type_enabled(v138, OS_LOG_TYPE_DEBUG))
        {
          v147 = *(_DWORD *)(v4 + 28);
          *(_DWORD *)buf = 136316674;
          *(_QWORD *)&buf[4] = v174;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_RTCPAddSenderReportHeader";
          *(_WORD *)&buf[22] = 1024;
          v205 = 1428;
          v206 = 1024;
          v207 = 1428;
          v208 = 1024;
          v209 = v147;
          v210 = 1024;
          v211 = v175;
          v212 = 1024;
          v213 = v176;
          _os_log_debug_impl(&dword_1D8A54000, v137, OS_LOG_TYPE_DEBUG, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/RTCPTransport.c:%d: Sending RTCP SR packet PayloadType=%d NTP Seconds=%u RTPTimestamp=%u", buf, 0x34u);
        }
      }
      v140 = (unint64_t)(v126 + 28);
      if (v126 + 4 > v126 + 28 || v140 > (unint64_t)buf)
        goto LABEL_381;
      v141 = -28;
      v118 = v177;
      v120 = v178;
    }
    else
    {
      if (v129 < 4)
      {
LABEL_279:
        v5 = 2147549187;
LABEL_290:
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            RTPSendRTCP_cold_20();
        }
        goto LABEL_306;
      }
      if (v126 + 32 > (char *)buf)
        goto LABEL_381;
      *((_DWORD *)v126 + 1) = bswap32(*(_DWORD *)(v4 + 200));
      v140 = (unint64_t)(v126 + 8);
      v141 = -8;
    }
    if ((_DWORD)v121)
    {
      v142 = v141 + v122;
      v143 = v121;
      while (v124)
      {
        if (v142 <= 0x17)
          goto LABEL_279;
        *(_DWORD *)v140 = bswap32(*(_DWORD *)v124);
        v144 = *((_DWORD *)v124 + 1);
        *(_BYTE *)(v140 + 4) = v144;
        *(_DWORD *)(v140 + 4) = v144 | (*((_DWORD *)v124 + 2) << 8);
        *(_DWORD *)(v140 + 4) = bswap32(*((_DWORD *)v124 + 2) & 0xFFFFFF) & 0xFFFFFF00 | v144;
        *(int8x16_t *)(v140 + 8) = vrev32q_s8(*(int8x16_t *)(v124 + 12));
        v140 += 24;
        v142 -= 24;
        v124 += 36;
        if (!--v143)
          goto LABEL_273;
      }
      if (v142 <= 0x17)
        v5 = 2147549187;
      else
        v5 = 2147549185;
      goto LABEL_290;
    }
LABEL_273:
    v145 = v120;
    v146 = _RTCPFinalizePacket((unint64_t)v126, v122, &v192, v140 - (_QWORD)v126);
    if ((v146 & 0x80000000) != 0)
    {
      v5 = v146;
      goto LABEL_290;
    }
    v118 += v192;
    v193 = v118;
    v119 += v121;
    v120 = v145;
  }
  while (v52 != v119);
  v162 = 4 * (unsigned __int16)v179 + 4;
  v62 = v118 + v162;
  if (v118 + (int)v162 >= 1473)
  {
    v5 = 2147549192;
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      goto LABEL_306;
    v173 = VRTraceErrorLogLevelToCSTR();
    v170 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      goto LABEL_306;
    *(_DWORD *)buf = 136316418;
    *(_QWORD *)&buf[4] = v173;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = "RTPSendRTCP";
    *(_WORD *)&buf[22] = 1024;
    v205 = 1989;
    v206 = 1024;
    v207 = v118;
    v208 = 1024;
    v209 = 4 * (unsigned __int16)v179 + 4;
    v210 = 1024;
    v211 = 1472;
    v171 = " [%s] %s:%d RTCP buffer too small. Unable to add SDES: %d + %d > %d";
    goto LABEL_347;
  }
  v163 = &v203[v118];
  if (v203 > v163 || (unsigned __int16)v179 > 0x102u || v163 > (char *)buf || 1472 - v118 < v162)
    goto LABEL_381;
  memcpy(v163, v197, v162);
  v193 = v118 + v162;
LABEL_102:
  v63 = *(_DWORD *)v2;
  if ((*(_DWORD *)v2 & 0x100) != 0)
  {
    v65 = 1472 - v62;
    *(_QWORD *)buf = v65;
    v66 = (uint8_t *)&v203[v62];
    if (v66 > buf)
      goto LABEL_381;
    if (v203 > (char *)v66)
      goto LABEL_381;
    v67 = *(_QWORD *)(v2 + 80);
    v68 = *(unsigned __int8 *)(v2 + 88);
    v69 = *(_QWORD *)(v2 + 96);
    v70 = *(unsigned __int8 *)(v2 + 104);
    if (v4 >= v187)
      goto LABEL_381;
    if (v65 <= 3)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          RTPSendRTCP_cold_19();
      }
    }
    else
    {
      *(_WORD *)v66 = *(_WORD *)v66 & 0x20 | 0xCF80;
      v71 = v66 + 4;
      if ((v65 & 0x7FFFFFFFFFFFFFFCLL) != 4)
      {
        v109 = v66 + 8;
        if (v66 + 8 > buf)
          goto LABEL_381;
        *v71 = *(_DWORD *)(v4 + 4832);
        if (v71 > (_DWORD *)v109)
          goto LABEL_381;
        v110 = 1464 - v62;
        if (v67 && v68)
        {
          while (1)
          {
            v111 = v110 >= 0x28;
            v110 -= 40;
            if (!v111)
              break;
            v112 = *(_DWORD *)(v4 + 4832);
            *(_BYTE *)v109 = 6;
            v113 = *((_BYTE *)v109 + 1) & 0x7F | (*(_BYTE *)v67 << 7);
            *((_BYTE *)v109 + 1) = v113;
            v114 = v113 & 0xBF | (*(_BYTE *)(v67 + 1) << 6);
            *((_BYTE *)v109 + 1) = v114;
            v115 = v114 & 0xDF | (32 * *(_BYTE *)(v67 + 2));
            *((_BYTE *)v109 + 1) = v115;
            *((_BYTE *)v109 + 1) = v115 & 0xE0 | (8 * (*(_BYTE *)(v67 + 4) & 3));
            v109[1] = 2304;
            *((_DWORD *)v109 + 1) = bswap32(v112);
            v109[4] = bswap32(*(unsigned __int16 *)(v67 + 12)) >> 16;
            v109[5] = bswap32(*(unsigned __int16 *)(v67 + 14)) >> 16;
            *(int8x16_t *)(v109 + 6) = vrev32q_s8(*(int8x16_t *)(v67 + 16));
            *(int8x8_t *)(v109 + 14) = vrev32_s8(*(int8x8_t *)(v67 + 32));
            *((_DWORD *)v109 + 9) = *(_DWORD *)(v67 + 40);
            v109 += 20;
            if (!--v68)
              goto LABEL_222;
          }
          v155 = VRTraceGetErrorLogLevelForModule();
          if (v155 >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              RTPSendRTCP_cold_18();
          }
        }
        else
        {
LABEL_222:
          if (!v69 || !v70)
          {
LABEL_226:
            v117 = _RTCPFinalizePacket((unint64_t)v66, v65, (unint64_t *)buf, (char *)v109 - (char *)v66);
            if ((v117 & 0x80000000) == 0)
            {
              v62 += *(_DWORD *)buf;
              v193 = v62;
              v63 = *(_DWORD *)v2;
              goto LABEL_103;
            }
            v5 = v117;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                RTPSendRTCP_cold_16();
            }
            goto LABEL_303;
          }
          while (v110 > 0x23)
          {
            v116 = bswap32(*(_DWORD *)(v4 + 4832));
            *(_DWORD *)v109 = 134217735;
            *((_DWORD *)v109 + 1) = v116;
            *((_DWORD *)v109 + 2) = *(_DWORD *)v69;
            *(int8x8_t *)(v109 + 6) = vrev16_s8(*(int8x8_t *)(v69 + 4));
            *(_QWORD *)(v109 + 10) = *(_QWORD *)(v69 + 12);
            *((_BYTE *)v109 + 28) = *(_BYTE *)(v69 + 20);
            *((_BYTE *)v109 + 29) = 0;
            v109[15] = bswap32(*(unsigned __int16 *)(v69 + 22)) >> 16;
            v109[16] = bswap32(*(unsigned __int16 *)(v69 + 24)) >> 16;
            v109[17] = bswap32(*(unsigned __int16 *)(v69 + 26)) >> 16;
            v109 += 18;
            v110 -= 36;
            if (!--v70)
              goto LABEL_226;
          }
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              RTPSendRTCP_cold_17();
          }
        }
        goto LABEL_302;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          RTPSendRTCP_cold_15();
LABEL_302:
        v5 = 2147549187;
        goto LABEL_303;
      }
    }
    v5 = 2147549187;
LABEL_303:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RTPSendRTCP_cold_14();
    }
    goto LABEL_306;
  }
LABEL_103:
  if ((v63 & 0x600) == 0)
    goto LABEL_134;
  v64 = 1472 - v62;
  if (v64 > 0x5C0 || v4 >= v187)
    goto LABEL_381;
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = 0;
  if ((v63 & 0x200) != 0)
  {
    *(_DWORD *)buf = 6;
    *(_QWORD *)&buf[8] = *(_QWORD *)(v2 + 152);
    v194 = 0;
    v72 = &v203[v62];
    if (v72 < v203 || v72 > &v203[v64] || &v203[v64] - v72 < v64)
      goto LABEL_381;
    v73 = _RTCPAddPSFBAlfbPacket(v4, (unint64_t)v72, 1472 - v62, &v194, (unsigned int *)buf);
    if ((v73 & 0x80000000) == 0)
    {
      v5 = 0;
      v62 += v194;
      v193 = v62;
      if ((*(_DWORD *)v2 & 0x400) == 0)
        goto LABEL_133;
      goto LABEL_128;
    }
    v5 = v73;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RTPSendRTCP_cold_13();
    }
LABEL_373:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RTPSendRTCP_cold_11();
    }
    goto LABEL_306;
  }
  v5 = 2147549192;
  if ((v63 & 0x400) == 0)
    goto LABEL_133;
LABEL_128:
  v74 = *(_DWORD *)(v2 + 160);
  *(_DWORD *)buf = 5;
  *(_DWORD *)&buf[8] = v74;
  v194 = 0;
  v75 = &v203[v62];
  if (&v203[v64] < v75)
    goto LABEL_381;
  if (v75 < v203)
    goto LABEL_381;
  v76 = v64 - v62;
  if (v76 > &v203[v64] - v75)
    goto LABEL_381;
  v5 = _RTCPAddPSFBAlfbPacket(v4, (unint64_t)v75, v76, &v194, (unsigned int *)buf);
  if ((v5 & 0x80000000) != 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RTPSendRTCP_cold_12();
    }
  }
  else
  {
    v62 += v194;
    v193 = v62;
  }
LABEL_133:
  if ((v5 & 0x80000000) != 0)
    goto LABEL_373;
LABEL_134:
  v77 = *(_QWORD *)(v2 + 16);
  if (!v77)
    goto LABEL_140;
  v194 = 1472 - v62;
  v78 = *(_DWORD *)(v2 + 4);
  v79 = *(_QWORD *)(v2 + 8);
  *(_DWORD *)&buf[4] = 0;
  *(_QWORD *)&buf[8] = v79;
  *(_DWORD *)buf = v78;
  *(_QWORD *)&buf[16] = v77;
  v80 = &v203[v62];
  if (v80 > (char *)buf || v203 > v80 || v4 >= v187)
    goto LABEL_381;
  v81 = _RTCPAddAppPacket(v4, (unint64_t)v80, 1472 - v62, &v194, (uint64_t)buf);
  if ((v81 & 0x80000000) != 0)
  {
    v5 = v81;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RTPSendRTCP_cold_10();
    }
    goto LABEL_306;
  }
  v62 += v194;
  v193 = v62;
LABEL_140:
  if (!(_WORD)v185)
  {
LABEL_147:
    if (!v183)
    {
LABEL_153:
      if (*(_DWORD *)(v4 + 96))
      {
        v86 = 1472 - v62;
        *(_DWORD *)buf = 1472 - v62;
        v87 = &v203[v62];
        if (v87 > (char *)buf || v203 > v87 || v4 >= v187 || v86 < 0 || 1472 - v62 < v86)
          goto LABEL_381;
        v88 = RTCPAddFIR(v4, (uint64_t)v87, v86, buf);
        if ((v88 & 0x80000000) != 0)
        {
          v5 = v88;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              RTPSendRTCP_cold_9();
          }
          goto LABEL_306;
        }
        v62 += *(_DWORD *)buf;
        v193 = v62;
        *(_DWORD *)(v4 + 96) = 0;
      }
      if (*(_DWORD *)(v4 + 104))
      {
        v89 = 1472 - v62;
        *(_DWORD *)buf = 1472 - v62;
        v90 = (uint8_t *)&v203[v62];
        if (v90 > buf || v203 > (char *)v90 || v4 >= v187 || v89 < 0 || 1472 - v62 < v89)
          goto LABEL_381;
        v91 = RTCPAddPLI(v4, v90, v89, buf);
        if ((v91 & 0x80000000) != 0)
        {
          v5 = v91;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              RTPSendRTCP_cold_8();
          }
          goto LABEL_306;
        }
        v62 += *(_DWORD *)buf;
        v193 = v62;
        *(_DWORD *)(v4 + 104) = 0;
      }
      if (*(_DWORD *)(v4 + 112))
      {
        v92 = 1472 - v62;
        *(_DWORD *)buf = 1472 - v62;
        v93 = &v203[v62];
        if (v93 > (char *)buf || v203 > v93 || v4 >= v187 || v92 < 0 || 1472 - v62 < v92)
          goto LABEL_381;
        v94 = RTCPAddTST(v4, (uint64_t)v93, v92, buf, 0);
        if ((v94 & 0x80000000) != 0)
        {
          v5 = v94;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              RTPSendRTCP_cold_7();
          }
          goto LABEL_306;
        }
        v62 += *(_DWORD *)buf;
        v193 = v62;
        *(_DWORD *)(v4 + 112) = 0;
      }
      if (*(_DWORD *)(v4 + 120))
      {
        v95 = 1472 - v62;
        *(_DWORD *)buf = 1472 - v62;
        v96 = &v203[v62];
        if (v96 > (char *)buf || v203 > v96 || v4 >= v187 || v95 < 0 || 1472 - v62 < v95)
          goto LABEL_381;
        v97 = RTCPAddTST(v4, (uint64_t)v96, v95, buf, 1);
        if ((v97 & 0x80000000) != 0)
        {
          v5 = v97;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              RTPSendRTCP_cold_6();
          }
          goto LABEL_306;
        }
        v62 += *(_DWORD *)buf;
        v193 = v62;
        *(_DWORD *)(v4 + 120) = 0;
      }
      if (*(_DWORD *)(v4 + 128))
      {
        v98 = 1472 - v62;
        *(_DWORD *)buf = 1472 - v62;
        v99 = &v203[v62];
        if (v99 > (char *)buf || v203 > v99 || v4 >= v187 || v98 < 0 || 1472 - v62 < v98)
          goto LABEL_381;
        v100 = RTCPAddTMMB((_DWORD *)v4, (uint64_t)v99, v98, buf, 0);
        if ((v100 & 0x80000000) != 0)
        {
          v5 = v100;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              RTPSendRTCP_cold_5();
          }
          goto LABEL_306;
        }
        v62 += *(_DWORD *)buf;
        v193 = v62;
        *(_DWORD *)(v4 + 128) = 0;
      }
      if (*(_DWORD *)(v4 + 136))
      {
        v101 = 1472 - v62;
        *(_DWORD *)buf = 1472 - v62;
        v102 = &v203[v62];
        if (v102 > (char *)buf || v203 > v102 || v4 >= v187 || v101 < 0 || 1472 - v62 < v101)
          goto LABEL_381;
        v103 = RTCPAddTMMB((_DWORD *)v4, (uint64_t)v102, v101, buf, 1);
        if ((v103 & 0x80000000) != 0)
        {
          v5 = v103;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              RTPSendRTCP_cold_4();
          }
          goto LABEL_306;
        }
        v62 += *(_DWORD *)buf;
        v193 = v62;
        *(_DWORD *)(v4 + 136) = 0;
      }
      if ((v182 & 1) == 0)
        goto LABEL_206;
      if (v62 < 1465)
      {
        v104 = (uint64_t *)&v203[v62];
        if (v104 > (uint64_t *)buf || v203 > (char *)v104)
          goto LABEL_381;
        *v104 = v181 | (v184 << 32) | v180;
        v62 += 8;
        v193 = v62;
LABEL_206:
        v188 = v62 - 8;
        if (v4 >= v187)
          goto LABEL_381;
        v105 = SRTCPEncrypt(v4 + 7960, (unint64_t)&v203[8], v62 - 8, 1464, &v188);
        if ((v105 & 0x80000000) != 0 && (v5 = v105, (_DWORD)v105 != -2145255368))
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              RTPSendRTCP_cold_1();
          }
        }
        else
        {
          v193 = v188 + 8;
          v106 = SRTCPAddAuthenticationTag((_DWORD *)(v4 + 7960), 1472, v203, v188 + 8, &v193);
          if ((v106 & 0x80000000) != 0 && (v5 = v106, (_DWORD)v106 != -2145255368))
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                RTPSendRTCP_cold_2();
            }
          }
          else
          {
            v107 = (*(_DWORD *)v2 & 0x48) != 0;
            if (*(_QWORD *)(v4 + 11112))
              v108 = _RTCPSendWithTransportStream(v4, v203, v193, v107, v2);
            else
              v108 = _RTCPSendWithSocket(v4, v203, v193, v107);
            v5 = v108;
          }
        }
        goto LABEL_306;
      }
      v5 = 2147549192;
      if ((int)VRTraceGetErrorLogLevelForModule() < 3)
        goto LABEL_306;
      VRTraceErrorLogLevelToCSTR();
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        goto LABEL_306;
      RTPSendRTCP_cold_3();
LABEL_369:
      v5 = 2147549192;
      goto LABEL_306;
    }
    v84 = (4 * v183 + 4);
    if (v62 + (int)v84 < 1473)
    {
      v85 = &v203[v62];
      if (v85 > (char *)buf || v203 > v85 || 1472 - v62 < v84)
        goto LABEL_381;
      memcpy(v85, __b, v84);
      v193 = v62 + v84;
      v62 += v84;
      goto LABEL_153;
    }
    v5 = 2147549192;
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      goto LABEL_306;
    v172 = VRTraceErrorLogLevelToCSTR();
    v170 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      goto LABEL_306;
    *(_DWORD *)buf = 136316418;
    *(_QWORD *)&buf[4] = v172;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = "RTPSendRTCP";
    *(_WORD *)&buf[22] = 1024;
    v205 = 2031;
    v206 = 1024;
    v207 = v62;
    v208 = 1024;
    v209 = 4 * v183 + 4;
    v210 = 1024;
    v211 = 1472;
    v171 = " [%s] %s:%d RTCP buffer too small. Unable to add NACK: %d + %d > %d";
LABEL_347:
    _os_log_error_impl(&dword_1D8A54000, v170, OS_LOG_TYPE_ERROR, v171, buf, 0x2Eu);
    goto LABEL_369;
  }
  v82 = 4 * (unsigned __int16)v185 + 4;
  if (v62 + (int)v82 < 1473)
  {
    v83 = &v203[v62];
    if (v203 <= v83 && (unsigned __int16)v185 <= 0x102u && v83 <= (char *)buf && 1472 - v62 >= v82)
    {
      memcpy(v83, __src, v82);
      v193 = v62 + v82;
      v62 += v82;
      goto LABEL_147;
    }
LABEL_381:
    __break(0x5519u);
  }
  v5 = 2147549192;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v169 = VRTraceErrorLogLevelToCSTR();
    v170 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136316418;
      *(_QWORD *)&buf[4] = v169;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "RTPSendRTCP";
      *(_WORD *)&buf[22] = 1024;
      v205 = 2023;
      v206 = 1024;
      v207 = v62;
      v208 = 1024;
      v209 = 4 * (unsigned __int16)v185 + 4;
      v210 = 1024;
      v211 = 1472;
      v171 = " [%s] %s:%d RTCP buffer too small. Unable to add FIR: %d + %d > %d";
      goto LABEL_347;
    }
  }
LABEL_306:
  CheckOutHandleDebug();
  return v5;
}

uint64_t RTPSendRateControlPacket(uint64_t a1, _BYTE *a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = 2147549186;
  v5 = CheckInHandleDebug();
  if (v5)
  {
    if (*(_DWORD *)(v5 + 184))
    {
      if ((*a2 & 0x20) != 0)
        v4 = RTPSendRTCP(a1);
      else
        v4 = 2147549200;
    }
    else
    {
      v4 = 0;
    }
    CheckOutHandleDebug();
  }
  return v4;
}

uint64_t RTCPGetVoIPMetricsReportBlock(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  NSObject *v13;
  int v14;
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = 2147549201;
  v4 = CheckInHandleDebug();
  if (!v4)
    return 2147549186;
  if (*(_DWORD *)(v4 + 188))
  {
    if (*(_DWORD *)(v4 + 7004))
    {
      v5 = *(unsigned int *)(v4 + 704);
      if ((_DWORD)v5)
      {
        v6 = *(_DWORD *)(v4 + 692) - *(unsigned __int16 *)(v4 + 688) + 1;
        v7 = ((v6 - v5) << 8) / v6;
      }
      else
      {
        LOBYTE(v7) = -1;
      }
      v3 = 0;
      *(_BYTE *)a2 = v7;
      v8 = *(_DWORD *)(*(_QWORD *)(v4 + 10408) + 48);
      if (v8 > 0xFFFE)
        LOWORD(v8) = -1;
      *(_WORD *)(a2 + 8) = v8;
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v12 = VRTraceErrorLogLevelToCSTR();
      v13 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v14 = 136315650;
        v15 = v12;
        v16 = 2080;
        v17 = "RTCPGetVoIPMetricsReportBlock";
        v18 = 1024;
        v19 = 1613;
        _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Haven't received any RTP packet yet", (uint8_t *)&v14, 0x1Cu);
      }
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v10 = VRTraceErrorLogLevelToCSTR();
      v11 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v14 = 136315650;
        v15 = v10;
        v16 = 2080;
        v17 = "RTCPGetVoIPMetricsReportBlock";
        v18 = 1024;
        v19 = 1612;
        _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTCP XR is not enabled", (uint8_t *)&v14, 0x1Cu);
      }
    }
    v3 = 67;
  }
  CheckOutHandleDebug();
  return v3;
}

unint64_t _RTCPInitializeReceptionReportBlock(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  unint64_t v9;
  uint64_t v10;
  int v11;
  int v13;
  unint64_t v14;
  uint64_t v15;
  NSObject *v16;
  int v17;
  int v18;
  unint64_t v19;
  unint64_t result;
  int v21;
  uint64_t v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  __int16 v33;
  uint64_t v34;
  __int16 v35;
  int v36;
  __int16 v37;
  uint64_t v38;
  __int16 v39;
  int v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v4 = *(_DWORD *)(a1 + 692) - *(unsigned __int16 *)(a1 + 688) + 1;
  v5 = *(unsigned int *)(a1 + 704);
  v6 = v4 - v5 + 0x1000000;
  if (v4 >= v5)
    v6 = v4 - v5;
  if (v4 - v5 >= 0x7FFFFF)
    v7 = 0x7FFFFFLL;
  else
    v7 = v6;
  v8 = *(_DWORD *)(a1 + 708);
  v9 = (v4 - v8);
  v10 = v9 - (v5 - *(_DWORD *)(a1 + 712));
  v11 = v4 - v8;
  *(_DWORD *)(a1 + 708) = v4;
  *(_DWORD *)(a1 + 712) = v5;
  if ((_DWORD)v4 == v8 || v10 < 1)
    v13 = 0;
  else
    v13 = ((v10 << 8) / v9);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v15 = VRTraceErrorLogLevelToCSTR();
    v16 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v17 = *(_DWORD *)(a1 + 200);
      v18 = *(_DWORD *)(a1 + 4832);
      v21 = 136317442;
      v22 = v15;
      v23 = 2080;
      v24 = "_RTCPInitializeReceptionReportBlock";
      v25 = 1024;
      v26 = 762;
      v27 = 1024;
      v28 = v17;
      v29 = 1024;
      v30 = v18;
      v31 = 1024;
      v32 = v4;
      v33 = 2048;
      v34 = v7;
      v35 = 1024;
      v36 = v11;
      v37 = 2048;
      v38 = v10;
      v39 = 1024;
      v40 = v13;
      _os_log_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d localSSRC:%X remoteSSRC:%X dwPacketExp = %u lPacketLost = %ld, dwPacketExpInt = %d, lPacketLostInt = %ld, fraction = %d", (uint8_t *)&v21, 0x4Eu);
    }
  }
  if (*(_DWORD *)(a1 + 6500))
    v19 = GetNTPTime() - *(_QWORD *)(a1 + 6496);
  else
    v19 = 0;
  *(_DWORD *)a2 = *(_DWORD *)(a1 + 4832);
  *(_DWORD *)(a2 + 4) = v13;
  *(_DWORD *)(a2 + 8) = v7;
  *(_DWORD *)(a2 + 12) = *(_DWORD *)(a1 + 692);
  LODWORD(v14) = *(_DWORD *)(a1 + 4828);
  *(_DWORD *)(a2 + 16) = vcvtad_u64_f64(*(double *)(a1 + 27608) * (double)v14);
  *(_DWORD *)(a2 + 20) = NTPToMiddle32(*(_QWORD *)(a1 + 6504));
  result = NTPToMiddle32(v19);
  *(_DWORD *)(a2 + 24) = result;
  *(_BYTE *)(a2 + 32) = *(_BYTE *)(a1 + 617);
  return result;
}

uint64_t _RTCPAddCustomReportPacket(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t *a4, uint64_t a5)
{
  uint64_t result;
  unsigned int v10;
  _OWORD *v11;
  __int128 *v12;
  __int128 v13;
  unint64_t v14[3];

  v14[2] = *MEMORY[0x1E0C80C00];
  if ((a3 & 0x8000000000000000) != 0)
    __break(0x5519u);
  result = 2147549187;
  if (a3 > 3)
  {
    *(_WORD *)a2 = *(_WORD *)a2 & 0x20 | 0xCC80;
    if (a3 - 12 <= 0xFFFFFFFFFFFFFFF7)
    {
      v10 = *(_DWORD *)a5;
      *(_DWORD *)(a2 + 4) = bswap32(*(_DWORD *)(a1 + 200));
      *(_DWORD *)(a2 + 8) = bswap32(v10);
      v11 = (_OWORD *)(a2 + 12);
      v14[0] = a2 + 12;
      v14[1] = a3 - 12;
      if (v10 == 1297568338 || v10 == 1297568594)
      {
        result = _RTCPAddCustomReport(v14, a1, a5);
        if ((result & 0x80000000) == 0)
        {
          v11 = (_OWORD *)v14[0];
          return _RTCPFinalizePacket(a2, a3, a4, (unint64_t)v11 - a2);
        }
      }
      else
      {
        if (v10 != 1380144204)
          return _RTCPFinalizePacket(a2, a3, a4, (unint64_t)v11 - a2);
        if (a3 - 12 >= 0x14)
        {
          v12 = *(__int128 **)(a5 + 8);
          v13 = *v12;
          *(_DWORD *)(a2 + 28) = *((_DWORD *)v12 + 4);
          *v11 = v13;
          v11 = (_OWORD *)(a2 + 32);
          return _RTCPFinalizePacket(a2, a3, a4, (unint64_t)v11 - a2);
        }
      }
    }
  }
  return result;
}

unint64_t _RTCPAddAppPacket(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t *a4, uint64_t a5)
{
  size_t v7;
  unsigned int v9;
  size_t v10;
  unint64_t result;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;

  if (a3 < 4)
    return 2147549187;
  *(_WORD *)a2 = *(_WORD *)a2 & 0x20 | 0xCC80;
  v7 = a3 - 12;
  if (a3 - 12 > 0xFFFFFFFFFFFFFFF7)
    return 2147549187;
  v9 = bswap32(*(_DWORD *)a5);
  *(_DWORD *)(a2 + 4) = bswap32(*(_DWORD *)(a1 + 200));
  *(_DWORD *)(a2 + 8) = v9;
  v10 = *(_QWORD *)(a5 + 16);
  if (v7 < v10)
    return 2147549187;
  v13 = a2 + 12;
  result = (unint64_t)memcpy((void *)(a2 + 12), *(const void **)(a5 + 8), v10);
  v14 = *(_QWORD *)(a5 + 16);
  v15 = v13 + v14;
  if (a2 + a3 >= v13 + v14 && v13 <= v15 && v7 - v14 <= a3 - (v14 + 12))
    return _RTCPFinalizePacket(a2, a3, a4, v15 - a2);
  __break(0x5519u);
  return result;
}

uint64_t RTCPAddFIR(uint64_t a1, uint64_t a2, int a3, _DWORD *a4)
{
  unsigned int v4;
  unsigned int v5;
  char v6;
  uint64_t v7;

  v4 = *(_DWORD *)(a1 + 200);
  v5 = *(_DWORD *)(a1 + 4832);
  v6 = *(_BYTE *)(a1 + 100);
  if (a3 < 20)
  {
    v7 = 2147549192;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RTCPAddFIR_cold_1();
    }
  }
  else
  {
    v7 = 0;
    *(_DWORD *)a2 = 67161732;
    *(_QWORD *)(a2 + 4) = bswap32(v4);
    *(_DWORD *)(a2 + 12) = bswap32(v5);
    *(_BYTE *)(a2 + 16) = v6;
    *(_WORD *)(a2 + 17) = 0;
    *(_BYTE *)(a2 + 19) = 0;
    *a4 = 20;
  }
  return v7;
}

uint64_t RTCPAddPLI(uint64_t a1, _DWORD *a2, int a3, _DWORD *a4)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;

  if (a3 < 12)
  {
    v4 = 2147549192;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RTCPAddPLI_cold_1();
    }
  }
  else
  {
    v4 = 0;
    v5 = bswap32(*(_DWORD *)(a1 + 4832));
    v6 = bswap32(*(_DWORD *)(a1 + 200));
    *a2 = 33607297;
    a2[1] = v6;
    a2[2] = v5;
    *a4 = 12;
  }
  return v4;
}

uint64_t RTCPAddTST(uint64_t a1, uint64_t a2, int a3, _DWORD *a4, int a5)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  char v10;
  unsigned int v11;
  unsigned int v12;
  __int16 v13;
  uint64_t v15;
  NSObject *v16;
  const char *v18;
  int v19;
  uint64_t v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (a3 < 20)
  {
    v6 = 2147549192;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v15 = VRTraceErrorLogLevelToCSTR();
      v16 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v18 = "TSTR";
        v19 = 136316418;
        v20 = v15;
        v21 = 2080;
        v22 = "RTCPAddTST";
        if (a5 == 1)
          v18 = "TSTN";
        v23 = 1024;
        v24 = 549;
        v25 = 2080;
        v26 = v18;
        v27 = 1024;
        v28 = 20;
        v29 = 1024;
        v30 = a3;
        _os_log_error_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_ERROR, " [%s] %s:%d Unable to add %s, buffer too small: %d > %d", (uint8_t *)&v19, 0x32u);
      }
    }
  }
  else
  {
    v6 = 0;
    v7 = 108;
    if (a5 == 1)
      v7 = 117;
    v8 = *(unsigned __int8 *)(a1 + v7);
    v9 = 116;
    if (a5 == 1)
      v9 = 124;
    v10 = *(_BYTE *)(a1 + v9);
    v11 = *(_DWORD *)(a1 + 4832);
    v12 = *(_DWORD *)(a1 + 200);
    if (a5 == 1)
      v13 = -12666;
    else
      v13 = -12667;
    *(_WORD *)a2 = v13;
    *(_WORD *)(a2 + 2) = 1024;
    *(_QWORD *)(a2 + 4) = bswap32(v12);
    *(_DWORD *)(a2 + 12) = bswap32(v11);
    *(_DWORD *)(a2 + 16) = bswap32(v10 & 0x1F | (v8 << 24));
    *a4 = 20;
  }
  return v6;
}

uint64_t RTCPAddTMMB(_DWORD *a1, uint64_t a2, int a3, _DWORD *a4, int a5)
{
  __int16 v7;
  uint64_t v8;
  unsigned int v9;
  int v10;
  unsigned int v11;
  BOOL v12;
  uint64_t v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  BOOL v17;
  int v18;
  uint64_t v19;
  NSObject *v20;
  const char *v22;
  int v23;
  uint64_t v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  int v32;
  __int16 v33;
  int v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  if (a5 == 1)
    v7 = -12924;
  else
    v7 = -12925;
  v8 = 33;
  if (a5 == 1)
    v8 = 35;
  v9 = a1[v8];
  if (v9 >= 0x20000)
  {
    LOBYTE(v10) = 0;
    v11 = v9 >> 17;
    do
    {
      LOBYTE(v10) = v10 + 1;
      v12 = v11 > 1;
      v11 >>= 1;
    }
    while (v12);
    v10 = v10;
  }
  else
  {
    v10 = 0;
  }
  if (a3 < 20)
  {
    v13 = 2147549192;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v19 = VRTraceErrorLogLevelToCSTR();
      v20 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v22 = "TMMBR";
        v23 = 136316418;
        v24 = v19;
        v25 = 2080;
        v26 = "RTCPAddTMMB";
        if (a5 == 1)
          v22 = "TMMBN";
        v27 = 1024;
        v28 = 623;
        v29 = 2080;
        v30 = v22;
        v31 = 1024;
        v32 = 20;
        v33 = 1024;
        v34 = a3;
        _os_log_error_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_ERROR, " [%s] %s:%d Unable to add %s, buffer too small: %d > %d", (uint8_t *)&v23, 0x32u);
      }
    }
  }
  else
  {
    v13 = 0;
    v14 = (v9 >> v10 << 9) | (v10 << 26);
    v15 = bswap32(a1[50]);
    v16 = bswap32(a1[1208]);
    v17 = a1[3] == 0;
    *(_WORD *)a2 = v7;
    if (v17)
      v18 = 40;
    else
      v18 = 60;
    *(_WORD *)(a2 + 2) = 1024;
    *(_DWORD *)(a2 + 4) = v15;
    *(_DWORD *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 12) = v16;
    *(_DWORD *)(a2 + 16) = bswap32(v14 | v18);
    *a4 = 20;
  }
  return v13;
}

uint64_t _RTCPSendWithTransportStream(uint64_t a1, void *a2, size_t a3, char a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t (*v13)(uint64_t, CMBlockBufferRef *);
  uint64_t v14;
  int v15;
  CMBlockBufferRef blockBufferOut[14];
  __int128 v17;
  __int128 v18;
  _BYTE v19[24];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v17 = unk_1D910B048;
  v18 = xmmword_1D910B058;
  memset(v19, 170, sizeof(v19));
  memset(blockBufferOut, 170, sizeof(blockBufferOut));
  VCPacketInitialize((uint64_t)blockBufferOut);
  if (!a5)
  {
    v14 = 2147549185;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _RTCPSendWithTransportStream_cold_1();
    }
    goto LABEL_12;
  }
  if (*(unsigned __int8 *)(a5 + 130) >= 0xDu)
  {
    v14 = 2147549185;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _RTCPSendWithTransportStream_cold_2();
    }
    goto LABEL_12;
  }
  result = CMBlockBufferCreateWithMemoryBlock(*(CFAllocatorRef *)(a1 + 10480), a2, a3, (CFAllocatorRef)*MEMORY[0x1E0C9AE20], 0, 0, a3, 0, blockBufferOut);
  if ((_DWORD)result)
  {
    if ((int)result >= 0)
      v15 = result;
    else
      v15 = -(int)result;
    v14 = v15 | 0xD0010000;
    goto LABEL_12;
  }
  LOWORD(blockBufferOut[1]) = 257;
  v19[8] = a4;
  v19[9] = 1;
  BYTE4(blockBufferOut[4]) = *(_BYTE *)(a5 + 131);
  blockBufferOut[5] = *(CMBlockBufferRef *)(a5 + 136);
  BYTE2(blockBufferOut[4]) = *(_BYTE *)(a5 + 130);
  LOBYTE(blockBufferOut[6]) = *(_BYTE *)(a1 + 10462);
  BYTE1(blockBufferOut[6]) = *(_BYTE *)(a5 + 144);
  if (!BYTE2(blockBufferOut[4]))
  {
LABEL_7:
    v11 = _RTPEnsureTransportStreamsActivated(a1);
    if ((v11 & 0x80000000) == 0)
    {
      v12 = *(_QWORD *)(a1 + 11112);
      v13 = *(uint64_t (**)(uint64_t, CMBlockBufferRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 16);
      if (!v13)
      {
        v14 = 4294954514;
        goto LABEL_12;
      }
      v11 = v13(v12, blockBufferOut);
    }
    v14 = v11;
LABEL_12:
    VCPacketInvalidate((uint64_t *)blockBufferOut);
    return v14;
  }
  if (BYTE2(blockBufferOut[4]) <= 0xCu)
  {
    __memcpy_chk();
    goto LABEL_7;
  }
  __break(0x5519u);
  return result;
}

uint64_t _RTCPSendWithSocket(uint64_t a1, _OWORD *a2, size_t a3, char a4)
{
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  _OWORD v8[10];
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  v11 = 0u;
  v12 = 0u;
  v9 = 0u;
  v10 = 0u;
  memset(v8, 0, sizeof(v8));
  DWORD2(v8[0]) = *(_DWORD *)(a1 + 10400);
  BYTE9(v9) = a4;
  BYTE10(v9) = 1;
  v4 = 0;
  if (VTP_Send(*(_DWORD *)(a1 + 8), a2, a3, 0, (uint64_t)v8) == -1)
  {
    v4 = *__error() | 0xC0010000;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v6 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _RTCPSendWithSocket_cold_1(v5, v6);
    }
  }
  return v4;
}

uint64_t _RTCPTransport_ParsePacket(unint64_t a1, uint64_t *a2, int a3)
{
  unint64_t v4;
  _WORD *v5;
  unint64_t v6;
  unint64_t v7;
  _WORD *v8;
  unsigned int v9;
  unint64_t v10;
  char v11;
  BOOL v12;
  uint64_t v13;
  unsigned int v14;
  BOOL v15;
  int v16;
  __int16 **v17;
  __int16 *v19;
  unsigned int v20;
  unint64_t v21;
  _BOOL4 BoolValueForKey;
  int v23;
  _BOOL4 v24;
  uint64_t v25;
  unint64_t v26;
  __int16 *v27;
  uint64_t v29;
  NSObject *v30;
  NSObject *v31;
  unsigned int v32;
  unsigned int v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  unint64_t v37;
  unsigned int v38;
  uint64_t v39;
  NSObject *v40;
  NSObject *v41;
  unsigned int v42;
  int v43;
  int v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  unint64_t v48;
  unsigned int v49;
  unint64_t v50;
  unint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  unsigned int v56;
  int v57;
  unsigned __int16 v58;
  int v59;
  int v60;
  uint64_t v61;
  unsigned __int16 *v62;
  char v63;
  uint64_t v64;
  char *v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  char *v69;
  unint64_t v70;
  uint64_t v71;
  char *v72;
  uint64_t v73;
  int v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  int8x8_t *v78;
  unsigned int v79;
  unint64_t v80;
  __int16 *v81;
  uint64_t v82;
  NSObject *v83;
  char v84;
  unsigned int v85;
  int v86;
  int v87;
  int ErrorLogLevelForModule;
  unint64_t v90;
  int v91;
  uint64_t v92;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  unsigned int v97;
  int8x8_t *v98;
  unint64_t v99;
  _BYTE buf[22];
  __int16 v101;
  int v102;
  __int16 v103;
  int v104;
  __int16 v105;
  unsigned int v106;
  __int16 v107;
  int v108;
  __int16 v109;
  int v110;
  uint64_t v111;

  v4 = 0;
  v111 = *MEMORY[0x1E0C80C00];
  v5 = (_WORD *)a2[13];
  v6 = (unint64_t)v5 + a2[14];
  v7 = (unint64_t)v5 + a3;
  *((_BYTE *)a2 + 8) = 0;
  v96 = (unint64_t)(a2 + 2);
  v8 = v5;
  do
  {
    if ((unint64_t)(v8 + 2) > v7)
    {
      v13 = 2147549191;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _RTCPTransport_ParsePacket_cold_1();
      }
      return v13;
    }
    if (v8 && ((unint64_t)v8 >= v6 || v8 < v5))
      goto LABEL_224;
    v9 = bswap32((unsigned __int16)v8[1]) >> 16;
    v8[1] = v9;
    if (v9 >= 0x103)
    {
      v13 = 2147549191;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _RTCPTransport_ParsePacket_cold_2();
      }
      return v13;
    }
    v10 = (unint64_t)&v8[2 * v9 + 2];
    if (v10 > v7)
    {
      if ((_BYTE)v4)
        goto LABEL_30;
      return 0;
    }
    if ((*v8 & 0xC0) != 0x80)
    {
      v13 = 2147549191;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _RTCPTransport_ParsePacket_cold_14();
      }
      return v13;
    }
    v11 = v4 + 1;
    *((_BYTE *)a2 + 8) = v4 + 1;
    a2[v4 + 2] = (uint64_t)v8;
    v12 = v10 >= v7 || v4++ >= 9;
    v8 = (_WORD *)v10;
  }
  while (!v12);
  if (v10 != v7)
  {
    v13 = 2147549191;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _RTCPTransport_ParsePacket_cold_13();
    }
    return v13;
  }
  if (!v11)
    return 0;
LABEL_30:
  v14 = 0;
  v92 = *a2;
  v95 = (unint64_t)(a2 + 12);
  v90 = (unint64_t)a2 + 124;
  v94 = (unint64_t)a2 + 1596;
  if (a1)
    v15 = a1 + 27616 > a1;
  else
    v15 = 1;
  v16 = v15;
  v91 = v16;
  while (2)
  {
    v97 = v14;
    v17 = (__int16 **)(v96 + 8 * v14);
    if ((unint64_t)v17 >= v95 || (unint64_t)v17 < v96)
      goto LABEL_224;
    v19 = *v17;
    v20 = (unsigned __int16)**v17;
    v21 = (unint64_t)(*v17 + 518);
    switch(v20 >> 8)
    {
      case 0xC0u:
        if ((unsigned __int16)v19[1] - 7 > 0xFFFFFFF9)
        {
          *((_DWORD *)v19 + 1) = bswap32(*((_DWORD *)v19 + 1));
          BoolValueForKey = VCDefaults_GetBoolValueForKey(CFSTR("enableLTRPLogging"), 0);
          if (BoolValueForKey)
            v23 = 7;
          else
            v23 = 8;
          if ((unint64_t)v19 >= v21)
            goto LABEL_224;
          if (((2 * v19[1] + 254) & 0xFELL) != 0)
          {
            v24 = BoolValueForKey;
            v25 = 0;
            v26 = 0;
            v27 = v19 + 4;
            do
            {
              if (&v27[v25] >= v19 + 14 || &v27[v25] < v27)
                goto LABEL_224;
              v27[v26] = bswap32((unsigned __int16)v27[v26]) >> 16;
              if (v23 <= (int)VRTraceGetErrorLogLevelForModule())
              {
                v29 = VRTraceErrorLogLevelToCSTR();
                if (v24)
                {
                  v30 = *MEMORY[0x1E0CF2758];
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                    goto LABEL_61;
                }
                else
                {
                  v30 = *MEMORY[0x1E0CF2758];
                  v31 = *MEMORY[0x1E0CF2758];
                  if (!*MEMORY[0x1E0CF2748])
                  {
                    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
                    {
                      v33 = (unsigned __int16)v27[v26];
                      *(_DWORD *)buf = 136316162;
                      *(_QWORD *)&buf[4] = v29;
                      *(_WORD *)&buf[12] = 2080;
                      *(_QWORD *)&buf[14] = "_RTCPTransport_ParsePacket";
                      v101 = 1024;
                      v102 = 2215;
                      v103 = 1024;
                      v104 = v97;
                      v105 = 1024;
                      v106 = v33;
                      _os_log_debug_impl(&dword_1D8A54000, v30, OS_LOG_TYPE_DEBUG, " [%s] %s:%d j=%d awSizeAndFirstMBs=%d", buf, 0x28u);
                    }
                    goto LABEL_64;
                  }
                  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
                  {
LABEL_61:
                    v32 = (unsigned __int16)v27[v26];
                    *(_DWORD *)buf = 136316162;
                    *(_QWORD *)&buf[4] = v29;
                    *(_WORD *)&buf[12] = 2080;
                    *(_QWORD *)&buf[14] = "_RTCPTransport_ParsePacket";
                    v101 = 1024;
                    v102 = 2215;
                    v103 = 1024;
                    v104 = v97;
                    v105 = 1024;
                    v106 = v32;
                    _os_log_impl(&dword_1D8A54000, v30, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d j=%d awSizeAndFirstMBs=%d", buf, 0x28u);
                  }
                }
              }
LABEL_64:
              ++v26;
              ++v25;
            }
            while (v26 < ((2 * v19[1] - 2) & 0xFEu));
          }
LABEL_188:
          v14 = (v97 + 1);
          if (v14 >= *((unsigned __int8 *)a2 + 8))
            return 0;
          continue;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _RTCPTransport_ParsePacket_cold_8();
        }
        return 2147549191;
      case 0xC1u:
        if (v19[1] == 2)
        {
          *((_DWORD *)v19 + 1) = bswap32(*((_DWORD *)v19 + 1));
          v19[4] = bswap32((unsigned __int16)v19[4]) >> 16;
          v19[5] = bswap32((unsigned __int16)v19[5]) >> 16;
          goto LABEL_188;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _RTCPTransport_ParsePacket_cold_9();
        }
        return 2147549191;
      case 0xC8u:
        v34 = 24 * (v20 & 0x1F);
        if (4 * (unsigned __int16)v19[1] + 4 == v34 + 28)
        {
          *(int8x16_t *)(v19 + 2) = vrev32q_s8(*(int8x16_t *)(v19 + 2));
          *(int8x8_t *)(v19 + 10) = vrev32_s8(*(int8x8_t *)(v19 + 10));
          if ((v20 & 0x1F) == 0)
          {
LABEL_74:
            if ((int)VRTraceGetErrorLogLevelForModule() > 7)
            {
              v39 = VRTraceErrorLogLevelToCSTR();
              v40 = *MEMORY[0x1E0CF2758];
              v41 = *MEMORY[0x1E0CF2758];
              if (*MEMORY[0x1E0CF2748])
              {
                if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
                {
                  v42 = *(_DWORD *)(a1 + 28);
                  v43 = *((_DWORD *)v19 + 2);
                  v44 = *((_DWORD *)v19 + 4);
                  *(_DWORD *)buf = 136316674;
                  *(_QWORD *)&buf[4] = v39;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = "_RTCPProcessSenderReportPacket";
                  v101 = 1024;
                  v102 = 1459;
                  v103 = 1024;
                  v104 = 1459;
                  v105 = 1024;
                  v106 = v42;
                  v107 = 1024;
                  v108 = v43;
                  v109 = 1024;
                  v110 = v44;
                  _os_log_impl(&dword_1D8A54000, v40, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/RTCPTransport.c:%d: Received RTCP SR packet PayloadType=%d NTP Seconds=%u RTPTimestamp=%u", buf, 0x34u);
                }
              }
              else if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
              {
                v85 = *(_DWORD *)(a1 + 28);
                v86 = *((_DWORD *)v19 + 2);
                v87 = *((_DWORD *)v19 + 4);
                *(_DWORD *)buf = 136316674;
                *(_QWORD *)&buf[4] = v39;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "_RTCPProcessSenderReportPacket";
                v101 = 1024;
                v102 = 1459;
                v103 = 1024;
                v104 = 1459;
                v105 = 1024;
                v106 = v85;
                v107 = 1024;
                v108 = v86;
                v109 = 1024;
                v110 = v87;
                _os_log_debug_impl(&dword_1D8A54000, v40, OS_LOG_TYPE_DEBUG, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/RTCPTransport.c:%d: Received RTCP SR packet PayloadType=%d NTP Seconds=%u RTPTimestamp=%u", buf, 0x34u);
              }
            }
            *(_QWORD *)(a1 + 6496) = v92;
            *(_DWORD *)(a1 + 6508) = *((_DWORD *)v19 + 2);
            *(_DWORD *)(a1 + 6504) = *((_DWORD *)v19 + 3);
            if (!v91)
              goto LABEL_224;
            v74 = _RTPMediaSampleTimeWithReceiveTimestamp(a1, *((_DWORD *)v19 + 4), 0);
            *((_DWORD *)v19 + 4) = v74;
            *(_DWORD *)(a1 + 4824) = v74;
            goto LABEL_188;
          }
          v35 = (unint64_t)v19 + v34 + 28;
          v36 = v20 & 0x1F;
          v37 = (unint64_t)(v19 + 14);
          while (v37 < v35 && v37 >= (unint64_t)(v19 + 14))
          {
            v38 = *(_DWORD *)(v37 + 4) | (bswap32(*(_DWORD *)(v37 + 4)) << 8);
            *(_DWORD *)v37 = bswap32(*(_DWORD *)v37);
            *(_DWORD *)(v37 + 4) = v38;
            *(int8x16_t *)(v37 + 8) = vrev32q_s8(*(int8x16_t *)(v37 + 8));
            v37 += 24;
            if (!--v36)
              goto LABEL_74;
          }
          goto LABEL_224;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _RTCPTransport_ParsePacket_cold_3();
        }
        return 2147549191;
      case 0xC9u:
        v45 = 24 * (v20 & 0x1F);
        if (4 * (unsigned __int16)v19[1] + 4 == v45 + 8)
        {
          *((_DWORD *)v19 + 1) = bswap32(*((_DWORD *)v19 + 1));
          if ((v20 & 0x1F) == 0)
            goto LABEL_188;
          v46 = (unint64_t)v19 + v45 + 8;
          v47 = v20 & 0x1F;
          v48 = (unint64_t)(v19 + 4);
          while (v48 < v46 && v48 >= (unint64_t)(v19 + 4))
          {
            v49 = *(_DWORD *)(v48 + 4) | (bswap32(*(_DWORD *)(v48 + 4)) << 8);
            *(_DWORD *)v48 = bswap32(*(_DWORD *)v48);
            *(_DWORD *)(v48 + 4) = v49;
            *(int8x16_t *)(v48 + 8) = vrev32q_s8(*(int8x16_t *)(v48 + 8));
            v48 += 24;
            if (!--v47)
              goto LABEL_188;
          }
LABEL_224:
          __break(0x5519u);
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _RTCPTransport_ParsePacket_cold_4();
        }
        return 2147549191;
      case 0xCAu:
        if ((unsigned __int16)v19[1] - 67 > 0xFFFFFFBD)
          goto LABEL_88;
        ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
        if (ErrorLogLevelForModule >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _RTCPTransport_ParsePacket_cold_5();
        }
        return 2147549191;
      case 0xCBu:
        if (v19[1] == 1)
        {
LABEL_88:
          *((_DWORD *)v19 + 1) = bswap32(*((_DWORD *)v19 + 1));
          goto LABEL_188;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _RTCPTransport_ParsePacket_cold_6();
        }
        return 2147549191;
      case 0xCCu:
        if ((unint64_t)v19 >= v21)
          goto LABEL_224;
        v50 = (unsigned __int16)v19[1];
        if (v50 > 0x102)
          goto LABEL_224;
        v51 = 4 * v50 + 4;
        *(_QWORD *)buf = *v17;
        *(_QWORD *)&buf[8] = v51;
        v52 = _RTCPProcessCommonHeader((__int16 **)buf);
        if ((v52 & 0x80000000) != 0)
          return v52;
        v53 = *(_QWORD *)&buf[8];
        v54 = *(_QWORD *)&buf[8] - 8;
        if (*(_QWORD *)&buf[8] < 8uLL)
          return 2147549192;
        v55 = *(_QWORD *)buf;
        v56 = *(_DWORD *)(*(_QWORD *)buf + 4);
        v57 = bswap32(v56);
        **(_DWORD **)buf = bswap32(**(_DWORD **)buf);
        *(_DWORD *)(v55 + 4) = v57;
        if (v57 <= 1297568593)
        {
          if (v57 != 5)
          {
            v58 = 21074;
            goto LABEL_113;
          }
          if (v54 <= 3)
          {
            v13 = 2147549192;
          }
          else
          {
            v54 = v53 - 12;
            v13 = 0;
          }
          if (v54)
          {
LABEL_216:
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                _RTCPTransport_ParsePacket_cold_7();
            }
            return 2147549191;
          }
LABEL_175:
          if ((v13 & 0x80000000) != 0)
            return v13;
          goto LABEL_188;
        }
        if (v57 == 1380144204)
        {
          if (v54 >= 0x14)
          {
            if (*((_BYTE *)a2 + 8) != 1 || v53 != 28)
              goto LABEL_216;
            goto LABEL_188;
          }
          v13 = 2147549192;
          if (v54)
            goto LABEL_216;
          goto LABEL_175;
        }
        v58 = 21330;
LABEL_113:
        if (v57 != (v58 | 0x4D570000))
          goto LABEL_188;
        if (v56 == 1381193549)
          v63 = -10;
        else
          v63 = -11;
        *((_BYTE *)v19 + 1) = v63;
        v64 = *((unsigned int *)a2 + 30);
        v65 = (char *)(v90 + v64);
        if (v90 + v64 > v94)
          goto LABEL_224;
        if (v90 > (unint64_t)v65)
          goto LABEL_224;
        v66 = 1472 - v64;
        if (v66 > v94 - (unint64_t)v65)
          goto LABEL_224;
        v67 = v55 + 8 - (_QWORD)v19;
        v68 = v66 - v67;
        if (v66 < v67)
          return 2147549192;
        if (v67 > v51)
          goto LABEL_224;
        memcpy(v65, v19, v55 + 8 - (_QWORD)v19);
        v69 = &v65[v67];
        if (v94 < (unint64_t)&v65[v67] || v65 > v69 || v68 > v94 - (unint64_t)&v65[v67])
          goto LABEL_224;
        if (v68 < 4)
          return 2147549192;
        *(_DWORD *)v69 = 0;
        v70 = (unint64_t)(v69 + 4);
        if ((unint64_t)(v69 + 4) > v94 || (unint64_t)v69 > v70)
          goto LABEL_224;
        if (!v54)
          return 2147549192;
        LODWORD(v98) = v68 - 4;
        if ((v54 & 0x80000000) != 0 || (int)v54 > (uint64_t)v54)
          goto LABEL_224;
        v52 = CompressionUtils_DecompressWithZlib();
        if ((v52 & 0x80000000) != 0)
          return v52;
        v71 = (int)v98;
        if (v68 - 4 < (int)v98)
          goto LABEL_224;
        if (v56 == 1381193549)
        {
          if (v98 < 0x11)
            return 2147549192;
          *(int8x16_t *)(v69 + 4) = vrev32q_s8(*(int8x16_t *)(v69 + 4));
          *(_QWORD *)(a1 + 6496) = v92;
          *(_DWORD *)(a1 + 6508) = *((_DWORD *)v69 + 1);
          *(_DWORD *)(a1 + 6504) = *((_DWORD *)v69 + 2);
          *(_BYTE *)(a1 + 617) = v69[20] & 0xF;
          v72 = v69 + 21;
          if (v70 > (unint64_t)(v69 + 21) || (unint64_t)v72 > v70 + v71)
            goto LABEL_224;
          v73 = -17;
        }
        else
        {
          if (!(_DWORD)v98)
            return 2147549192;
          v72 = v69 + 5;
          v73 = -1;
        }
        v80 = v73 + v71;
        if (!v80)
        {
LABEL_170:
          v81 = (__int16 *)(1472 - *((unsigned int *)a2 + 30));
          v98 = (int8x8_t *)v81;
          if ((unint64_t)v81 > v94 - (unint64_t)v65)
            goto LABEL_224;
          _RTCPFinalizePacket((unint64_t)v65, (unint64_t)v81, (unint64_t *)&v98, v72 - v65);
          if ((unint64_t)(v65 + 1036) > v94)
            goto LABEL_224;
          *((_WORD *)v65 + 1) = bswap32(*((unsigned __int16 *)v65 + 1)) >> 16;
          *((_DWORD *)a2 + 30) += (_DWORD)v98;
          if ((unint64_t)v65 >= v94)
            goto LABEL_224;
          *v17 = (__int16 *)v65;
          goto LABEL_188;
        }
        while (v80 >= 0xC)
        {
          *(_DWORD *)v72 = bswap32(*(_DWORD *)v72);
          *((_WORD *)v72 + 3) = bswap32(*((unsigned __int16 *)v72 + 3)) >> 16;
          *((_WORD *)v72 + 4) = bswap32(*((unsigned __int16 *)v72 + 4)) >> 16;
          v72 += 12;
          ++*(_DWORD *)v69;
          v80 -= 12;
          if (!v80)
            goto LABEL_170;
        }
        return 2147549192;
      case 0xCDu:
        v59 = v20 & 0x1F;
        if (v59 == 4 || v59 == 3)
        {
          if (v19[1] != 4)
            goto LABEL_192;
LABEL_110:
          *(int8x16_t *)(v19 + 2) = vrev32q_s8(*(int8x16_t *)(v19 + 2));
          goto LABEL_188;
        }
        if (v59 == 1)
        {
          v60 = (unsigned __int16)v19[1];
          if ((v60 - 3) <= 0xFF)
          {
            if ((unint64_t)v19 < v21)
            {
              *(int8x8_t *)(v19 + 2) = vrev32_s8(*(int8x8_t *)(v19 + 2));
              v61 = (v60 - 2);
              v62 = (unsigned __int16 *)(v19 + 6);
              while ((unint64_t)v62 < v21 && v62 >= (unsigned __int16 *)v19 + 6)
              {
                *v62 = bswap32(*v62) >> 16;
                v62[1] = bswap32(v62[1]) >> 16;
                v62 += 2;
                if (!--v61)
                  goto LABEL_188;
              }
            }
            goto LABEL_224;
          }
        }
LABEL_192:
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _RTCPTransport_ParsePacket_cold_12();
        }
        return 2147549191;
      case 0xCEu:
        switch(v20 & 0x1F)
        {
          case 1u:
            if (v19[1] != 2)
              goto LABEL_213;
            *(int8x8_t *)(v19 + 2) = vrev32_s8(*(int8x8_t *)(v19 + 2));
            goto LABEL_188;
          case 2u:
            if (v19[1] != 3)
              goto LABEL_213;
            *(int8x8_t *)(v19 + 2) = vrev32_s8(*(int8x8_t *)(v19 + 2));
            *((_DWORD *)v19 + 3) = bswap32(*((_DWORD *)v19 + 3));
            goto LABEL_188;
          case 4u:
            if (v19[1] != 4)
              goto LABEL_213;
            *(int8x8_t *)(v19 + 2) = vrev32_s8(*(int8x8_t *)(v19 + 2));
            *(_QWORD *)(v19 + 6) = bswap32(*((_DWORD *)v19 + 3));
            goto LABEL_188;
          case 5u:
          case 6u:
            if (v19[1] != 4)
              goto LABEL_213;
            goto LABEL_110;
          case 0xFu:
            if ((unint64_t)v19 >= v21)
              goto LABEL_224;
            v75 = (unsigned __int16)v19[1];
            if (v75 > 0x102)
              goto LABEL_224;
            v98 = (int8x8_t *)*v17;
            v99 = 4 * v75 + 4;
            v52 = _RTCPProcessCommonHeader((__int16 **)&v98);
            if ((v52 & 0x80000000) != 0)
              return v52;
            v76 = v99;
            v77 = v99 - 12;
            if (v99 < 0xC)
              return 2147549192;
            v78 = v98;
            *v98 = vrev32_s8(*v98);
            v79 = bswap32(v78[1].u32[0]);
            v78[1].i32[0] = v79;
            if (v79 == 5)
            {
              if (v77 >= 4)
              {
                v13 = 0;
                v78[1].i32[1] = bswap32(v78[1].u32[1]);
                v77 = v76 - 16;
                goto LABEL_183;
              }
              v84 = 0;
              v13 = 2147549192;
            }
            else
            {
              if (v79 != 6)
              {
                if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                {
                  v82 = VRTraceErrorLogLevelToCSTR();
                  v83 = *MEMORY[0x1E0CF2758];
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 136316162;
                    *(_QWORD *)&buf[4] = v82;
                    *(_WORD *)&buf[12] = 2080;
                    *(_QWORD *)&buf[14] = "_RTCPProcessPSFBAlfbPacket";
                    v101 = 1024;
                    v102 = 1393;
                    v103 = 1024;
                    v104 = 1393;
                    v105 = 1024;
                    v106 = v79;
                    _os_log_error_impl(&dword_1D8A54000, v83, OS_LOG_TYPE_ERROR, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/RTCPTransport.c:%d: Unsupported PSFB ALFB app type=%u", buf, 0x28u);
                  }
                }
                v13 = 0;
                goto LABEL_183;
              }
              if (v77 >= 8)
              {
                v13 = 0;
                v78[1].i32[1] = bswap32(v78[1].u32[1]);
                v78[2].i16[0] = bswap32(v78[2].u16[0]) >> 16;
                v77 = v76 - 20;
LABEL_183:
                v84 = 1;
                goto LABEL_186;
              }
              v84 = 0;
              v13 = 2147549187;
            }
LABEL_186:
            if (!v77)
            {
              if ((v84 & 1) == 0)
                return v13;
              goto LABEL_188;
            }
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                _RTCPTransport_ParsePacket_cold_11();
            }
            return 2147549191;
          default:
LABEL_213:
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                _RTCPTransport_ParsePacket_cold_10();
            }
            return 2147549191;
        }
      default:
        goto LABEL_188;
    }
  }
}

uint64_t RTCPPacketByteSize(uint64_t a1)
{
  return 4 * *(unsigned __int16 *)(a1 + 2) + 4;
}

uint64_t RTCPPacketFIREntryCount(uint64_t a1)
{
  return (2 * *(unsigned __int8 *)(a1 + 2) - 2) & 0xFE;
}

uint64_t _RTCPPacketCallback(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  const __CFAllocator **v4;
  unint64_t v5;
  const __CFAllocator **v6;
  const __CFAllocator **v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  NSObject *v13;
  const __CFAllocator **v14;
  uint8_t buf[4];
  uint64_t v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = 2147549187;
  v4 = (const __CFAllocator **)CheckInHandleDebug();
  if (!v4)
    return 2147549186;
  v5 = (unint64_t)v4;
  v6 = _RTCPPacketCreate(v4);
  v14 = v6;
  if (!v6)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v12 = VRTraceErrorLogLevelToCSTR();
      v13 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        v16 = v12;
        v17 = 2080;
        v18 = "_RTCPPacketCallback";
        v19 = 1024;
        v20 = 2412;
        _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Failed to allocate RTCP packet list", buf, 0x1Cu);
      }
    }
    goto LABEL_7;
  }
  v7 = v6;
  v8 = _RTCPParseVTPPacket(v5, a2, (uint64_t)v6);
  v9 = v8;
  if ((v8 & 0x80000000) != 0)
  {
    v3 = 2149711929;
    if ((_DWORD)v8 == -2145255367)
      goto LABEL_7;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _RTCPPacketCallback_cold_1();
    }
  }
  else
  {
    v10 = *(_QWORD *)(v5 + 10664);
    if (v10)
      (*(void (**)(uint64_t, _QWORD, const __CFAllocator **))(v10 + 16))(v10, *(_QWORD *)(v5 + 10656), v7);
  }
  v3 = v9;
LABEL_7:
  _RTCPPacketForget(v5, (uint64_t)&v14);
  CheckOutHandleDebug();
  return v3;
}

const __CFAllocator **_RTCPPacketCreate(const __CFAllocator **result)
{
  unint64_t v1;

  if (result)
  {
    result = (const __CFAllocator **)VCBoundsSafety_AllocatorAllocate(result[1330], 1640, 0);
    if (result)
    {
      if ((unint64_t)(result + 205) > v1
        || (*((_BYTE *)result + 1620) = 0,
            result[13] = 0,
            result[14] = 0,
            result[12] = 0,
            (unint64_t)result >= v1))
      {
        __break(0x5519u);
      }
    }
  }
  return result;
}

uint64_t _RTCPParseVTPPacket(unint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  _QWORD v8[22];

  v8[21] = *MEMORY[0x1E0C80C00];
  *(_OWORD *)&v8[14] = unk_1D910B048;
  *(_OWORD *)&v8[16] = xmmword_1D910B058;
  memset(&v8[18], 170, 24);
  memset(v8, 170, 112);
  VCPacketInitialize((uint64_t)v8);
  VCGetVCPacketWithVTPPacket(a2, (uint64_t)v8);
  v6 = _RTCPParseVCPacket(a1, (uint64_t)v8, a3);
  VCPacketInvalidate(v8);
  return v6;
}

void _RTCPPacketForget(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  const void *v5;

  if (a1)
  {
    if (a2)
    {
      v3 = *(_QWORD **)a2;
      if (*(_QWORD *)a2)
      {
        v5 = (const void *)v3[12];
        if (v5)
        {
          CFRelease(v5);
          *(_QWORD *)(*(_QWORD *)a2 + 96) = 0;
          v3 = *(_QWORD **)a2;
        }
        CFAllocatorDeallocate(*(CFAllocatorRef *)(a1 + 10640), v3);
        *(_QWORD *)a2 = 0;
      }
    }
  }
}

unint64_t RTCPRegisterPacketCallback(uint64_t a1, uint64_t a2, const void *a3)
{
  unint64_t result;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  unint64_t v10;
  unint64_t v11;
  _DWORD *v12;
  uint64_t v14;
  NSObject *v15;
  int v16;
  int v17;
  uint64_t v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  int v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (a1 == 0xFFFFFFFFLL)
  {
    v8 = 2147549185;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RTCPRegisterPacketCallback_cold_1();
    }
    return v8;
  }
  result = CheckInHandleDebug();
  if (!result)
  {
    v8 = 2147549186;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        RTCPRegisterPacketCallback_cold_2();
        return 2147549186;
      }
    }
    return v8;
  }
  v7 = result;
  if (*(_QWORD *)(result + 10664))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RTCPRegisterPacketCallback_cold_4();
    }
    CheckOutHandleDebug();
    return 2147549233;
  }
  if (result < result + 27616)
  {
    v9 = _Block_copy(a3);
    *(_QWORD *)(v7 + 10664) = v9;
    if (v9)
    {
      *(_QWORD *)(v7 + 10656) = a2;
      v10 = *(unsigned int *)(v7 + 8);
      if (v10 > 0x3FF)
      {
        if (*(_QWORD *)(v7 + 11112))
        {
          v8 = _RTPEnsureTransportStreamsActivated(v7);
        }
        else
        {
          v8 = 2147549226;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            v14 = VRTraceErrorLogLevelToCSTR();
            v15 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            {
              v16 = *(_DWORD *)(v7 + 8);
              v17 = 136316162;
              v18 = v14;
              v19 = 2080;
              v20 = "RTCPRegisterPacketCallback";
              v21 = 1024;
              v22 = 2468;
              v23 = 2048;
              v24 = a1;
              v25 = 1024;
              v26 = v16;
              _os_log_error_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_ERROR, " [%s] %s:%d RTPHandle[%p], Socket[%d] is invalid", (uint8_t *)&v17, 0x2Cu);
              v8 = 2147549226;
            }
          }
        }
      }
      else
      {
        *(_OWORD *)(v7 + 10784) = 0u;
        v11 = v7 + 10672;
        *(_OWORD *)(v7 + 10768) = 0u;
        *(_OWORD *)(v7 + 10752) = 0u;
        *(_OWORD *)(v7 + 10736) = 0u;
        *(_OWORD *)(v7 + 10720) = 0u;
        *(_OWORD *)(v7 + 10704) = 0u;
        *(_OWORD *)(v7 + 10688) = 0u;
        *(_OWORD *)(v7 + 10672) = 0u;
        result = __darwin_check_fd_set_overflow(v10, (const void *)(v7 + 10672), 0);
        if ((_DWORD)result)
        {
          v12 = (_DWORD *)(v11 + ((v10 >> 3) & 0x1FFFFFFC));
          if ((unint64_t)v12 >= v7 + 10800 || (unint64_t)v12 < v11)
            goto LABEL_35;
          *v12 |= 1 << v10;
        }
        v8 = 0;
        *(_DWORD *)(v7 + 10648) = VTP_RegisterPacketCallback((_OWORD *)(v7 + 10672), a1, &__block_literal_global_17);
      }
    }
    else
    {
      v8 = 2147549188;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          RTCPRegisterPacketCallback_cold_3();
          v8 = 2147549188;
        }
      }
    }
    CheckOutHandleDebug();
    return v8;
  }
LABEL_35:
  __break(0x5519u);
  return result;
}

void _RTCPUnregisterPacketCallback(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 10664);
  if (v2)
  {
    if (*(_DWORD *)(a1 + 10648) != -1)
    {
      VTP_UnregisterPacketCallback(*(_DWORD *)(a1 + 10648));
      *(_DWORD *)(a1 + 10648) = -1;
      v2 = *(const void **)(a1 + 10664);
    }
    _Block_release(v2);
    *(_QWORD *)(a1 + 10664) = 0;
    *(_QWORD *)(a1 + 10656) = 0;
  }
}

uint64_t RTCPUnregisterPacketCallback()
{
  uint64_t v0;

  v0 = CheckInHandleDebug();
  if (!v0)
    return 2147549186;
  if (*(_QWORD *)(v0 + 10664))
  {
    _RTCPUnregisterPacketCallback(v0);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      RTCPUnregisterPacketCallback_cold_1();
  }
  CheckOutHandleDebug();
  return 0;
}

uint64_t RTPRecvRTCP(uint64_t a1, void *a2)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t (*v9)(uint64_t);
  uint64_t v10;
  void *v12[2];

  v12[1] = *(void **)MEMORY[0x1E0C80C00];
  v3 = 2147549186;
  v4 = CheckInHandleDebug();
  if (v4)
  {
    v5 = (_QWORD *)v4;
    if (v4 == 0xFFFFFFFFLL)
      return 2147549190;
    if (!*(_QWORD *)(v4 + 11112))
    {
      v12[0] = 0;
      if ((VTP_Recvfrom(*(_DWORD *)(v4 + 8), v12) & 0x80000000) != 0)
      {
        v3 = *__error() | 0xC0010000;
LABEL_19:
        RTCPCleanupPacketList((uint64_t)a2);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            RTPRecvRTCP_cold_1();
        }
        goto LABEL_22;
      }
      v3 = _RTCPParseVTPPacket((unint64_t)v5, (uint64_t)v12[0], (uint64_t)a2);
      VTP_ReleasePacket(v12);
      if ((v3 & 0x80000000) != 0)
        goto LABEL_19;
LABEL_22:
      CheckOutHandleDebug();
      return v3;
    }
    v12[0] = 0;
    v3 = _RTPEnsureTransportStreamsActivated(v4);
    if ((v3 & 0x80000000) == 0)
    {
      v6 = v5 + 1397;
      v7 = (_QWORD *)v5[1397];
      v12[0] = v7;
      if (v7)
      {
LABEL_10:
        v10 = v7[204];
        *v6 = v10;
        if (!v10)
          v5[1398] = v6;
        memcpy(a2, v7, 0x668uLL);
        v7[12] = 0;
LABEL_13:
        RTCPCleanupPacketList((uint64_t)v7);
        _RTCPPacketForget((uint64_t)v5, (uint64_t)v12);
        if ((v3 & 0x80000000) != 0)
          goto LABEL_19;
        goto LABEL_22;
      }
      v8 = v5[1389];
      v9 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 48);
      if (!v9)
      {
        v7 = 0;
        v3 = 4294954514;
        goto LABEL_13;
      }
      v3 = v9(v8);
      if ((v3 & 0x80000000) == 0)
      {
        v7 = (_QWORD *)*v6;
        v12[0] = *(void **)v6;
        goto LABEL_10;
      }
    }
    v7 = 0;
    goto LABEL_13;
  }
  return v3;
}

uint64_t RTPGetLatestRTCPTimestamp(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v4;

  v2 = 2147549185;
  if (a2)
  {
    v4 = CheckInHandleDebug();
    if (v4)
    {
      *a2 = *(_QWORD *)(v4 + 168);
      CheckOutHandleDebug();
      return 0;
    }
    else
    {
      return 2147549186;
    }
  }
  return v2;
}

uint64_t RTCPComputeRoundTripTimeMiddle32(uint64_t a1, unint64_t a2)
{
  int v3;
  unsigned int v4;
  unsigned int v5;
  BOOL v6;
  unsigned int v7;

  if (!*(_DWORD *)(a1 + 20))
    return 0;
  v3 = NTPToMiddle32(a2);
  v4 = *(_DWORD *)(a1 + 20);
  v5 = v3 - *(_DWORD *)(a1 + 16);
  v6 = v5 >= v4;
  v7 = v5 - v4;
  if (v6)
    return v7;
  else
    return 0;
}

uint64_t RTCPInitializeReceptionReportBlock(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2147549186;
  _RTCPInitializeReceptionReportBlock(v3, a2);
  CheckOutHandleDebug();
  return 0;
}

void RTCPCleanupPacketList(uint64_t a1)
{
  const void *v2;

  if (a1)
  {
    *(_BYTE *)(a1 + 8) = 0;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_OWORD *)(a1 + 80) = 0u;
    *(_QWORD *)(a1 + 104) = 0;
    *(_QWORD *)(a1 + 112) = 0;
    v2 = *(const void **)(a1 + 96);
    if (v2)
    {
      CFRelease(v2);
      *(_QWORD *)(a1 + 96) = 0;
    }
  }
}

uint64_t _RTPTransportStreamRTCPCallback(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  os_log_t *v6;
  const __CFAllocator **v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  const __CFAllocator **v13;
  uint64_t v15;
  NSObject *v16;
  const __CFAllocator **v17;
  uint8_t buf[4];
  uint64_t v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v17 = 0;
  if (a2)
  {
    v2 = a2;
    v3 = CheckInHandleDebug();
    if (v3)
    {
      v4 = v3;
      v5 = v3 + 27616;
      v6 = (os_log_t *)MEMORY[0x1E0CF2758];
      while (1)
      {
        v7 = _RTCPPacketCreate((const __CFAllocator **)v4);
        v17 = v7;
        if (!v7)
          break;
        v8 = _RTCPParseVCPacket(v4, v2, (uint64_t)v7);
        v9 = v8;
        if ((v8 & 0x80000000) != 0)
        {
          if ((_DWORD)v8 != -2145255367 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            v11 = VRTraceErrorLogLevelToCSTR();
            v12 = *v6;
            if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136315906;
              v19 = v11;
              v20 = 2080;
              v21 = "_RTPTransportStreamRTCPCallback";
              v22 = 1024;
              v23 = 2682;
              v24 = 1024;
              v25 = v9;
              _os_log_error_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_ERROR, " [%s] %s:%d RTCP error[%x]", buf, 0x22u);
            }
          }
        }
        else
        {
          v10 = *(_QWORD *)(v4 + 10664);
          if (v10)
          {
            (*(void (**)(uint64_t, _QWORD, const __CFAllocator **))(v10 + 16))(v10, *(_QWORD *)(v4 + 10656), v17);
          }
          else
          {
            v13 = v17;
            v17[204] = 0;
            **(_QWORD **)(v4 + 11184) = v13;
            *(_QWORD *)(v4 + 11184) = v17 + 204;
            v17 = 0;
          }
        }
        if (v4 >= v5)
          goto LABEL_28;
        _RTCPPacketForget(v4, (uint64_t)&v17);
        v2 = *(_QWORD *)(v2 + 160);
        if (!v2)
          goto LABEL_15;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v15 = VRTraceErrorLogLevelToCSTR();
        v16 = *v6;
        if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          v19 = v15;
          v20 = 2080;
          v21 = "_RTPTransportStreamRTCPCallback";
          v22 = 1024;
          v23 = 2671;
          _os_log_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Failed to allocate RTCP packet", buf, 0x1Cu);
        }
      }
      if (v4 >= v5)
LABEL_28:
        __break(0x5519u);
      v9 = 2147549187;
LABEL_15:
      _RTCPPacketForget(v4, (uint64_t)&v17);
      CheckOutHandleDebug();
    }
    else
    {
      v9 = 2147549186;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          _RTPTransportStreamRTCPCallback_cold_2();
          return 2147549186;
        }
      }
    }
  }
  else
  {
    v9 = 2147549185;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _RTPTransportStreamRTCPCallback_cold_1();
    }
  }
  return v9;
}

uint64_t _RTCPParseVCPacket(unint64_t a1, uint64_t a2, uint64_t a3)
{
  OSStatus DataPointer;
  int v7;
  int v8;
  uint64_t v9;
  size_t v10;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  unsigned __int16 *v14;
  unsigned int v15;
  unsigned __int8 *v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  const void *v25;
  unsigned int v26;
  int v27;
  char *dataPointerOut;
  size_t lengthAtOffsetOut;
  int v30;
  uint8_t buf[4];
  uint64_t v32;
  __int16 v33;
  const char *v34;
  __int16 v35;
  int v36;
  __int16 v37;
  int v38;
  __int16 v39;
  unsigned int v40;
  __int16 v41;
  int v42;
  __int16 v43;
  int v44;
  __int16 v45;
  int v46;
  __int16 v47;
  int v48;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  v30 = -1431655766;
  if (*(_DWORD *)(a2 + 88) == -1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      return 2147549195;
    VRTraceErrorLogLevelToCSTR();
    v9 = 2147549195;
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _RTCPParseVCPacket_cold_1();
    return v9;
  }
  dataPointerOut = 0;
  lengthAtOffsetOut = 0;
  DataPointer = CMBlockBufferGetDataPointer(*(CMBlockBufferRef *)a2, 0, &lengthAtOffsetOut, 0, &dataPointerOut);
  if (DataPointer)
  {
    v7 = DataPointer;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _RTCPParseVCPacket_cold_6();
    }
    if (v7 >= 0)
      v8 = v7;
    else
      v8 = -v7;
    return v8 | (v7 << 31) | 0x50010000u;
  }
  v10 = lengthAtOffsetOut;
  if (lengthAtOffsetOut < 4)
    return 2147549192;
  *(_QWORD *)(a3 + 104) = dataPointerOut;
  *(_QWORD *)(a3 + 112) = v10;
  result = MicroToNTP(*(double *)(a2 + 128));
  *(_QWORD *)a3 = result;
  *(_DWORD *)(a3 + 120) = 0;
  *(_BYTE *)(a3 + 1621) = *(_BYTE *)(a2 + 36);
  *(_QWORD *)(a3 + 1624) = *(_QWORD *)(a2 + 40);
  v12 = *(unsigned __int8 *)(a2 + 34);
  if (*(_BYTE *)(a2 + 34))
  {
    *(_BYTE *)(a3 + 1620) = v12;
    if (v12 > 0xC)
      goto LABEL_60;
    result = (uint64_t)memcpy((void *)(a3 + 1596), (const void *)(a2 + 10), 2 * v12);
  }
  v14 = *(unsigned __int16 **)(a3 + 104);
  v13 = *(_QWORD *)(a3 + 112);
  if (v13 || !v14)
  {
    v15 = *v14;
    if ((v15 & 0xFEE0) != 0xC880 && (v15 & 0xFF80) != 0xCC80)
    {
      v16 = (unsigned __int8 *)(a1 + 10460);
      if (!*(_BYTE *)(a1 + 10460)
        || (v15 >> 8) - 192 > 0xE
        || ((1 << (BYTE1(v15) + 64)) & 0x7003) == 0
        || (v15 & 0xC0) != 0x80)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v17 = VRTraceErrorLogLevelToCSTR();
          v18 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            v26 = *v14;
            v27 = *v16;
            *(_DWORD *)buf = 136317186;
            v32 = v17;
            v33 = 2080;
            v34 = "_RTCPIsValidPacket";
            v35 = 1024;
            v36 = 2316;
            v37 = 1024;
            v38 = 2316;
            v39 = 1024;
            v40 = v26 >> 8;
            v41 = 1024;
            v42 = v26 >> 6;
            v43 = 1024;
            v44 = v26 & 0x1F;
            v45 = 1024;
            v46 = (v26 >> 5) & 1;
            v47 = 1024;
            v48 = v27;
            _os_log_error_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_ERROR, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/RTCPTransport.c:%d: Invalid RTCP Packet(packetType=%d, version=%d, count=%d, padding=%d) useReducedSizePackets=%d", buf, 0x40u);
          }
        }
        v9 = 2147549191;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _RTCPParseVCPacket_cold_5();
        }
        return v9;
      }
    }
    if ((v13 & 0x80000000) == 0 && (int)v13 <= v13)
    {
      result = SRTCPVerifyAuthenticationTag((_DWORD *)(a1 + 8400), *(char **)(a3 + 104), v13, &v30);
      if ((result & 0x80000000) != 0)
      {
        v9 = result;
        if ((_DWORD)result != -2145255368)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              _RTCPParseVCPacket_cold_4();
          }
          return v9;
        }
      }
      if (v30 <= 7)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _RTCPParseVCPacket_cold_2();
        }
        return 2147549192;
      }
      v19 = (v30 - 8);
      *(_DWORD *)buf = v30 - 8;
      if (v30 == 8)
      {
        v20 = 8;
LABEL_56:
        v30 = v20;
        v9 = _RTCPTransport_ParsePacket(a1, (uint64_t *)a3, v20);
        if ((v9 & 0x80000000) == 0)
        {
          v25 = *(const void **)a2;
          if (*(_QWORD *)a2)
            v25 = CFRetain(v25);
          *(_QWORD *)(a3 + 96) = v25;
          *(_QWORD *)(a1 + 168) = *(_QWORD *)(a2 + 128);
        }
        return v9;
      }
      v22 = *(_QWORD *)(a3 + 104);
      v21 = *(_QWORD *)(a3 + 112);
      v23 = v22 + 8;
      if (v22 + 8 <= v22 + v21 && v22 <= v23 && v21 - 8 >= v19)
      {
        v24 = SRTCPDecrypt(a1 + 8400, v23, v19, (int *)buf);
        if ((v24 & 0x80000000) != 0)
        {
          v9 = v24;
          if ((_DWORD)v24 != -2145255368)
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                _RTCPParseVCPacket_cold_3();
            }
            return v9;
          }
        }
        v20 = *(_DWORD *)buf + 8;
        goto LABEL_56;
      }
    }
  }
LABEL_60:
  __break(0x5519u);
  return result;
}

uint64_t _RTCPAddCustomReport(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  size_t v6;
  unint64_t v7;
  _BYTE *v8;
  _BYTE *v9;
  double v10;
  unint64_t v11;
  unint64_t v12;
  double v13;
  double v14;
  double v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  uint64_t v19;
  _DWORD *v20;
  double v21;
  unint64_t v22;
  int v23;
  uint64_t v24;
  _DWORD *v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  BOOL v30;
  char v31;
  int v32;
  unsigned int v33;
  int64_t v34;
  uint64_t result;
  uint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  _BYTE v42[4];
  int v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v6 = a1[1];
  v7 = v6;
  MEMORY[0x1E0C80A78](a1);
  v8 = &v42[-((v6 + 15) & 0xFFFFFFFFFFFFFFF0)];
  if (v6)
  {
    memset(&v42[-((v6 + 15) & 0xFFFFFFFFFFFFFFF0)], 170, v6);
    if ((v6 & 0x8000000000000000) != 0)
      goto LABEL_44;
  }
  if (*(_DWORD *)a3 != 1297568338)
  {
    v9 = &v42[-((v6 + 15) & 0xFFFFFFFFFFFFFFF0)];
    if (*(_DWORD *)a3 != 1297568594)
      goto LABEL_17;
    v7 = v6 - 17;
    if (v6 >= 0x11)
    {
      v10 = micro();
      v11 = MicroToNTP(v10);
      LODWORD(v12) = *(_DWORD *)(a2 + 312);
      v13 = (double)v12;
      LODWORD(v12) = *(_DWORD *)(a2 + 700);
      v14 = (double)v12;
      v15 = NTPToMicro(*(_QWORD *)(a2 + 304));
      v16 = _RTPSendTimestampWithMediaSampleTime(a2, (v13 + v14 * (v10 - v15)));
      *(_DWORD *)v8 = bswap32(HIDWORD(v11));
      *((_DWORD *)v8 + 1) = bswap32(v11);
      v17 = bswap32(*(_DWORD *)(a2 + 204));
      *((_DWORD *)v8 + 2) = bswap32(v16);
      *((_DWORD *)v8 + 3) = v17;
      v8[16] = v8[16] & 0xF0 | *(_BYTE *)(a2 + 616) & 0xF;
      v18 = NTPToMiddle32(v11);
      v19 = *(unsigned __int8 *)(a2 + 616);
      v20 = (_DWORD *)(a2 + 620 + 4 * v19);
      if ((unint64_t)v20 >= a2 + 684)
        goto LABEL_44;
      if ((unint64_t)v20 < a2 + 620)
        goto LABEL_44;
      *v20 = v18;
      *(_BYTE *)(a2 + 616) = (v19 + 1) & 0xF;
      v9 = v8 + 17;
      if (v8 + 17 > &v8[v6] || v8 > v9)
        goto LABEL_44;
      goto LABEL_17;
    }
    return 2147549187;
  }
  if (!v6)
    return 2147549187;
  v21 = micro();
  v22 = MicroToNTP(v21);
  v9 = v8 + 1;
  if (v8 + 1 > &v8[v6])
    goto LABEL_44;
  *v8 = *v8 & 0xF0 | *(_BYTE *)(a2 + 616) & 0xF;
  v23 = NTPToMiddle32(v22);
  v24 = *(unsigned __int8 *)(a2 + 616);
  v25 = (_DWORD *)(a2 + 620 + 4 * v24);
  if ((unint64_t)v25 >= a2 + 684)
    goto LABEL_44;
  if ((unint64_t)v25 < a2 + 620)
    goto LABEL_44;
  *v25 = v23;
  *(_BYTE *)(a2 + 616) = (v24 + 1) & 0xF;
  if (v8 > v9)
    goto LABEL_44;
  v7 = v6 - 1;
LABEL_17:
  v26 = *(unsigned int *)(a3 + 16);
  if ((_DWORD)v26)
  {
    v27 = (unint64_t)&v9[v7];
    v28 = v7 - 12 * (v26 - 1) - 12;
    v29 = *(_QWORD *)(a3 + 8) + 16;
    do
    {
      v30 = v7 >= 0xC;
      v7 -= 12;
      if (!v30)
        return 2147549187;
      *(_DWORD *)v9 = bswap32(*(_DWORD *)(v29 - 16));
      v31 = *(_BYTE *)(v29 + 16);
      *((_WORD *)v9 + 2) = *((_WORD *)v9 + 2) & 0xFFF0 | v31 & 0xF;
      *((_WORD *)v9 + 3) = bswap32(1000 * *(_DWORD *)(v29 + 8));
      v9[10] = *(_DWORD *)(v29 - 12);
      *((_WORD *)v9 + 4) = bswap32(*(unsigned __int16 *)(v29 - 4)) >> 16;
      v32 = 16 * *(_DWORD *)v29;
      if (HIWORD(*(_DWORD *)v29))
        LOWORD(v32) = -16;
      *((_WORD *)v9 + 2) = v32 & 0xFFF0 | v31 & 0xF;
      v33 = *(_DWORD *)(v29 + 12);
      if (v33 >= 0xFF)
        LOBYTE(v33) = -1;
      v9[11] = v33;
      if ((unint64_t)(v9 + 12) > v27 || v9 > v9 + 12)
        goto LABEL_44;
      v29 += 36;
      v9 += 12;
      --v26;
    }
    while (v26);
    v7 = v28;
  }
  v34 = v6 - v7;
  if (v6 < v7)
LABEL_44:
    __break(0x5519u);
  if (v6 == v7)
    return 0;
  v36 = a1[1];
  v43 = v36;
  if ((v34 & 0x80000000) != 0 || (int)v34 > v34 || (v36 & 0x80000000) != 0 || (int)v36 > v36)
    goto LABEL_44;
  result = CompressionUtils_CompressWithZLib();
  if ((result & 0x80000000) == 0)
  {
    v37 = a1[1];
    v38 = *a1 + v37;
    v39 = *a1 + v43;
    v30 = v38 >= v39;
    v40 = v38 - v39;
    if (!v30)
      goto LABEL_44;
    if (*a1 > v39)
      goto LABEL_44;
    v41 = v37 - v43;
    if (v41 > v40)
      goto LABEL_44;
    result = 0;
    *a1 = v39;
    a1[1] = v41;
  }
  return result;
}

unint64_t _RTCPFinalizePacket(unint64_t result, unint64_t a2, unint64_t *a3, unint64_t a4)
{
  unsigned int v4;
  unint64_t v5;
  uint64_t v6;
  _BYTE *v7;

  if (result + 4 <= result + a2)
  {
    v4 = a4 + 3;
    v5 = (a4 + 3) & 0xFFFFFFFFFFFFFFFCLL;
    *(_WORD *)result = *(_WORD *)result & 0xFFDF | (32 * (v5 != a4));
    if (v5 == a4)
    {
LABEL_8:
      v6 = 0;
      *a3 = a4;
      *(_WORD *)(result + 2) = bswap32((v4 >> 2) - 1) >> 16;
      return v6;
    }
    if (v5 > a2)
      return 2147549187;
    v7 = (_BYTE *)(v5 + result - 1);
    if ((unint64_t)v7 < result + a2 && (unint64_t)v7 >= result)
    {
      *v7 = v5 - a4;
      a4 = (a4 + 3) & 0xFFFFFFFFFFFFFFFCLL;
      goto LABEL_8;
    }
  }
  __break(0x5519u);
  return result;
}

uint64_t _RTCPAddPSFBAlfbPacket(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t *a4, unsigned int *a5)
{
  uint64_t v5;
  unint64_t v6;
  unsigned int v7;
  unsigned int v8;
  unint64_t v9;

  v5 = 2147549187;
  if (a3 >= 4)
  {
    *(_WORD *)a2 = *(_WORD *)a2 & 0x20 | 0xCE8F;
    v6 = a3 - 16;
    if (a3 - 16 <= 0xFFFFFFFFFFFFFFF3)
    {
      v7 = *a5;
      v8 = bswap32(*(_DWORD *)(a1 + 4832));
      *(_DWORD *)(a2 + 4) = bswap32(*(_DWORD *)(a1 + 200));
      *(_DWORD *)(a2 + 8) = v8;
      *(_DWORD *)(a2 + 12) = bswap32(v7);
      if (v7 == 5)
      {
        if (v6 >= 4)
        {
          *(_DWORD *)(a2 + 16) = bswap32(a5[2]);
          v9 = 20;
          return _RTCPFinalizePacket(a2, a3, a4, v9);
        }
      }
      else if (v7 == 6)
      {
        if (v6 >= 8)
        {
          *(_BYTE *)(a2 + 22) = *(_BYTE *)(*((_QWORD *)a5 + 1) + 6);
          *(_BYTE *)(a2 + 23) = *(_BYTE *)(*((_QWORD *)a5 + 1) + 7);
          *(_DWORD *)(a2 + 16) = bswap32(**((_DWORD **)a5 + 1));
          *(_WORD *)(a2 + 20) = bswap32(*(unsigned __int16 *)(*((_QWORD *)a5 + 1) + 4)) >> 16;
          v9 = 24;
          return _RTCPFinalizePacket(a2, a3, a4, v9);
        }
      }
      else
      {
        v5 = 2147549191;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            _RTCPAddPSFBAlfbPacket_cold_1();
            return 2147549191;
          }
        }
      }
    }
  }
  return v5;
}

uint64_t _RTCPProcessCommonHeader(__int16 **a1)
{
  uint64_t result;
  unint64_t v3;
  __int16 *v4;
  __int16 v5;
  uint64_t v6;
  unint64_t v7;
  BOOL v8;
  char *v9;
  char *v10;

  result = 2147549192;
  v3 = (unint64_t)a1[1];
  if (v3 >= 4)
  {
    v4 = *a1;
    v5 = **a1;
    if ((v5 & 0xC0) != 0x80)
      return 2147549193;
    v6 = 4 * (unsigned __int16)v4[1];
    if (v3 >= v6 + 4)
    {
      if ((v5 & 0x20) != 0)
      {
        v7 = *((unsigned __int8 *)v4 + (v6 | 3));
        if (v3 - 4 < v7)
          return 2147549191;
        v8 = v3 >= v7;
        v3 -= v7;
        if (!v8)
          goto LABEL_14;
        a1[1] = (__int16 *)v3;
      }
      v9 = (char *)v4 + v3;
      v10 = (char *)(v4 + 2);
      if (v10 > v9)
      {
LABEL_14:
        __break(0x5519u);
        return result;
      }
      result = 0;
      *a1 = (__int16 *)v10;
      a1[1] = (__int16 *)(v3 - 4);
    }
  }
  return result;
}

uint64_t VCFBOUtils_ObjectCreate(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, int a5)
{
  int v7;
  uint64_t v8;
  int v10;

  if (!a2)
    return (a5 << 16) | 0x80000001;
  v7 = CMDerivedObjectCreate();
  if (v7)
  {
    if (v7 >= 0)
      v10 = v7;
    else
      v10 = -v7;
    return v10 | (a5 << 16) | 0xD0000000;
  }
  else
  {
    v8 = 0;
    *a2 = 0;
  }
  return v8;
}

BOOL VCFBOUtils_IsKindOfClass(uint64_t a1, uint64_t a2)
{
  _BOOL8 result;
  uint64_t v3;
  NSObject *v4;

  if (a1)
    return CMBaseObjectGetVTable() == a2;
  if ((int)VRTraceGetErrorLogLevelForModule() < 3)
    return 0;
  v3 = VRTraceErrorLogLevelToCSTR();
  v4 = *MEMORY[0x1E0CF2758];
  result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
  if (result)
  {
    VCFBOUtils_IsKindOfClass_cold_1(v3, v4);
    return 0;
  }
  return result;
}

void OUTLINED_FUNCTION_6_5(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x26u);
}

void sub_1D8B4C4C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1D8B4CE58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t _VCAudioStreamSourceContextTransportCompare(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  BOOL v4;
  unsigned int v5;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a2 + 8);
  v4 = v2 == v3;
  v5 = 2 * (v2 >= v3);
  if (v4)
    return 1;
  else
    return v5;
}

uint64_t _VCAudioStreamSyncDelegateCompare(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  BOOL v4;
  unsigned int v5;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a2 + 8);
  v4 = v2 == v3;
  v5 = 2 * (v2 >= v3);
  if (v4)
    return 1;
  else
    return v5;
}

void _VCAudioStream_NWConnectionNotificationHandler(uint64_t a1, _BYTE *a2)
{
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  const char *v17;
  NSObject *v18;
  uint32_t v19;
  uint64_t v20;
  NSObject *v21;
  NSObject *v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  uint64_t v28;
  NSObject *v29;
  NSObject *v30;
  int v31;
  uint64_t v32;
  NSObject *v33;
  int v34;
  uint64_t v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  const char *v45;
  NSObject *v46;
  uint32_t v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  uint64_t v59;
  int v60;
  int RATFromNWNotification;
  int v62;
  int v63;
  int v64;
  int v65;
  uint64_t v66;
  __int16 v67;
  const char *v68;
  __int16 v69;
  int v70;
  __int16 v71;
  uint64_t v72;
  __int16 v73;
  _BYTE v74[10];
  _BYTE v75[6];
  _BYTE v76[6];
  _BYTE v77[6];
  int v78;
  __int16 v79;
  int v80;
  __int16 v81;
  int v82;
  __int16 v83;
  int v84;
  __int16 v85;
  int v86;
  __int16 v87;
  int v88;
  uint64_t v89;

  v89 = *MEMORY[0x1E0C80C00];
  if (+[VCAudioStream isVoLTE:](VCAudioStream, "isVoLTE:", objc_msgSend((id)objc_msgSend((id)a1, "defaultStreamConfig"), "audioStreamMode")))
  {
    if (a1)
    {
      if (a2)
      {
        if (*a2 == 2)
        {
          if (a2[2] == 2)
          {
            objc_msgSend((id)a1, "updateRateAdaptationWithNetworkNotification:", a2);
            switch(*((_DWORD *)a2 + 1))
            {
              case 0:
                if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
                {
                  v4 = VRTraceErrorLogLevelToCSTR();
                  v5 = *MEMORY[0x1E0CF2758];
                  v6 = *MEMORY[0x1E0CF2758];
                  if (*MEMORY[0x1E0CF2748])
                  {
                    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
                    {
                      v7 = *((_QWORD *)a2 + 2);
                      v8 = a2[60];
                      v9 = *(__int16 *)(a2 + 61);
                      v10 = *(__int16 *)(a2 + 63);
                      v11 = (char)a2[65];
                      v12 = a2[66];
                      v13 = a2[68];
                      v14 = *((unsigned __int16 *)a2 + 35);
                      v15 = a2[69];
                      v16 = a2[67];
                      v65 = 136318466;
                      v66 = v4;
                      v67 = 2080;
                      v68 = "_VCAudioStream_LogNWConnectionNotification";
                      v69 = 1024;
                      v70 = 2474;
                      v71 = 2048;
                      v72 = a1;
                      v73 = 2048;
                      *(_QWORD *)v74 = v7;
                      *(_WORD *)&v74[8] = 1024;
                      *(_DWORD *)v75 = v8;
                      *(_WORD *)&v75[4] = 1024;
                      *(_DWORD *)v76 = v9;
                      *(_WORD *)&v76[4] = 1024;
                      *(_DWORD *)v77 = v10;
                      *(_WORD *)&v77[4] = 1024;
                      v78 = v11;
                      v79 = 1024;
                      v80 = v12;
                      v81 = 1024;
                      v82 = v13;
                      v83 = 1024;
                      v84 = v14;
                      v85 = 1024;
                      v86 = v15;
                      v87 = 1024;
                      v88 = v16;
                      v17 = "VCAudioStream [%s] %s:%d VCAudioStream[%p] Cellular Network Notification: timestamp=%llu rad"
                            "ioAccessTechnology=%u referenceSignalLevel=%d signalLevel=%d signalQuality=%d uplinkBler=%u "
                            "bandwidthLimitationIndication=%u cdrxCycleLength=%u cdrxState=%u downlinkBLER=%u";
                      v18 = v5;
                      v19 = 102;
                      goto LABEL_24;
                    }
                  }
                  else if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
                  {
                    v35 = *((_QWORD *)a2 + 2);
                    v36 = a2[60];
                    v37 = *(__int16 *)(a2 + 61);
                    v38 = *(__int16 *)(a2 + 63);
                    v39 = (char)a2[65];
                    v40 = a2[66];
                    v41 = a2[68];
                    v42 = *((unsigned __int16 *)a2 + 35);
                    v43 = a2[69];
                    v44 = a2[67];
                    v65 = 136318466;
                    v66 = v4;
                    v67 = 2080;
                    v68 = "_VCAudioStream_LogNWConnectionNotification";
                    v69 = 1024;
                    v70 = 2474;
                    v71 = 2048;
                    v72 = a1;
                    v73 = 2048;
                    *(_QWORD *)v74 = v35;
                    *(_WORD *)&v74[8] = 1024;
                    *(_DWORD *)v75 = v36;
                    *(_WORD *)&v75[4] = 1024;
                    *(_DWORD *)v76 = v37;
                    *(_WORD *)&v76[4] = 1024;
                    *(_DWORD *)v77 = v38;
                    *(_WORD *)&v77[4] = 1024;
                    v78 = v39;
                    v79 = 1024;
                    v80 = v40;
                    v81 = 1024;
                    v82 = v41;
                    v83 = 1024;
                    v84 = v42;
                    v85 = 1024;
                    v86 = v43;
                    v87 = 1024;
                    v88 = v44;
                    v45 = "VCAudioStream [%s] %s:%d VCAudioStream[%p] Cellular Network Notification: timestamp=%llu radio"
                          "AccessTechnology=%u referenceSignalLevel=%d signalLevel=%d signalQuality=%d uplinkBler=%u band"
                          "widthLimitationIndication=%u cdrxCycleLength=%u cdrxState=%u downlinkBLER=%u";
                    v46 = v5;
                    v47 = 102;
                    goto LABEL_48;
                  }
                }
                break;
              case 2:
                if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
                {
                  v20 = VRTraceErrorLogLevelToCSTR();
                  v21 = *MEMORY[0x1E0CF2758];
                  v22 = *MEMORY[0x1E0CF2758];
                  if (*MEMORY[0x1E0CF2748])
                  {
                    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
                    {
                      v23 = *((_DWORD *)a2 + 2);
                      v24 = *((__int16 *)a2 + 6);
                      v25 = *((__int16 *)a2 + 7);
                      v26 = (char)a2[16];
                      v27 = a2[17];
                      v65 = 136317186;
                      v66 = v20;
                      v67 = 2080;
                      v68 = "_VCAudioStream_LogNWConnectionNotification";
                      v69 = 1024;
                      v70 = 2478;
                      v71 = 2048;
                      v72 = a1;
                      v73 = 1024;
                      *(_DWORD *)v74 = v23;
                      *(_WORD *)&v74[4] = 1024;
                      *(_DWORD *)&v74[6] = v24;
                      *(_WORD *)v75 = 1024;
                      *(_DWORD *)&v75[2] = v25;
                      *(_WORD *)v76 = 1024;
                      *(_DWORD *)&v76[2] = v26;
                      *(_WORD *)v77 = 1024;
                      *(_DWORD *)&v77[2] = v27;
                      v17 = "VCAudioStream [%s] %s:%d VCAudioStream[%p] Cellular Link Measurement Notification: radioAcce"
                            "ssTechnology=%u referenceSignalLevel=%d signalLevel=%d signalQuality=%d uplinkBler=%u";
                      v18 = v21;
                      v19 = 68;
                      goto LABEL_24;
                    }
                  }
                  else if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
                  {
                    v48 = *((_DWORD *)a2 + 2);
                    v49 = *((__int16 *)a2 + 6);
                    v50 = *((__int16 *)a2 + 7);
                    v51 = (char)a2[16];
                    v52 = a2[17];
                    v65 = 136317186;
                    v66 = v20;
                    v67 = 2080;
                    v68 = "_VCAudioStream_LogNWConnectionNotification";
                    v69 = 1024;
                    v70 = 2478;
                    v71 = 2048;
                    v72 = a1;
                    v73 = 1024;
                    *(_DWORD *)v74 = v48;
                    *(_WORD *)&v74[4] = 1024;
                    *(_DWORD *)&v74[6] = v49;
                    *(_WORD *)v75 = 1024;
                    *(_DWORD *)&v75[2] = v50;
                    *(_WORD *)v76 = 1024;
                    *(_DWORD *)&v76[2] = v51;
                    *(_WORD *)v77 = 1024;
                    *(_DWORD *)&v77[2] = v52;
                    v45 = "VCAudioStream [%s] %s:%d VCAudioStream[%p] Cellular Link Measurement Notification: radioAccess"
                          "Technology=%u referenceSignalLevel=%d signalLevel=%d signalQuality=%d uplinkBler=%u";
                    v46 = v21;
                    v47 = 68;
                    goto LABEL_48;
                  }
                }
                break;
              case 3:
                if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
                {
                  v28 = VRTraceErrorLogLevelToCSTR();
                  v29 = *MEMORY[0x1E0CF2758];
                  v30 = *MEMORY[0x1E0CF2758];
                  if (*MEMORY[0x1E0CF2748])
                  {
                    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
                    {
                      v31 = a2[8];
                      v65 = 136316162;
                      v66 = v28;
                      v67 = 2080;
                      v68 = "_VCAudioStream_LogNWConnectionNotification";
                      v69 = 1024;
                      v70 = 2476;
                      v71 = 2048;
                      v72 = a1;
                      v73 = 1024;
                      *(_DWORD *)v74 = v31;
                      v17 = "VCAudioStream [%s] %s:%d VCAudioStream[%p] Cellular BW Limitation: bandwidthLimitationIndication=%u";
                      goto LABEL_23;
                    }
                  }
                  else if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
                  {
                    v53 = a2[8];
                    v65 = 136316162;
                    v66 = v28;
                    v67 = 2080;
                    v68 = "_VCAudioStream_LogNWConnectionNotification";
                    v69 = 1024;
                    v70 = 2476;
                    v71 = 2048;
                    v72 = a1;
                    v73 = 1024;
                    *(_DWORD *)v74 = v53;
                    v45 = "VCAudioStream [%s] %s:%d VCAudioStream[%p] Cellular BW Limitation: bandwidthLimitationIndication=%u";
                    goto LABEL_47;
                  }
                }
                break;
              case 4:
                if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
                {
                  v32 = VRTraceErrorLogLevelToCSTR();
                  v29 = *MEMORY[0x1E0CF2758];
                  v33 = *MEMORY[0x1E0CF2758];
                  if (*MEMORY[0x1E0CF2748])
                  {
                    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
                    {
                      v34 = *((unsigned __int16 *)a2 + 5);
                      v65 = 136316162;
                      v66 = v32;
                      v67 = 2080;
                      v68 = "_VCAudioStream_LogNWConnectionNotification";
                      v69 = 1024;
                      v70 = 2480;
                      v71 = 2048;
                      v72 = a1;
                      v73 = 1024;
                      *(_DWORD *)v74 = v34;
                      v17 = "VCAudioStream [%s] %s:%d VCAudioStream[%p] Cellular CDRX Notification: cdrxCycleLength=%u";
LABEL_23:
                      v18 = v29;
                      v19 = 44;
LABEL_24:
                      _os_log_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_DEFAULT, v17, (uint8_t *)&v65, v19);
                    }
                  }
                  else if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
                  {
                    v64 = *((unsigned __int16 *)a2 + 5);
                    v65 = 136316162;
                    v66 = v32;
                    v67 = 2080;
                    v68 = "_VCAudioStream_LogNWConnectionNotification";
                    v69 = 1024;
                    v70 = 2480;
                    v71 = 2048;
                    v72 = a1;
                    v73 = 1024;
                    *(_DWORD *)v74 = v64;
                    v45 = "VCAudioStream [%s] %s:%d VCAudioStream[%p] Cellular CDRX Notification: cdrxCycleLength=%u";
LABEL_47:
                    v46 = v29;
                    v47 = 44;
LABEL_48:
                    _os_log_debug_impl(&dword_1D8A54000, v46, OS_LOG_TYPE_DEBUG, v45, (uint8_t *)&v65, v47);
                  }
                }
                break;
              default:
                break;
            }
            if (memcmp(a2, (const void *)(a1 + 1576), 0x68uLL))
            {
              v54 = *(_OWORD *)a2;
              v55 = *((_OWORD *)a2 + 2);
              *(_OWORD *)(a1 + 1592) = *((_OWORD *)a2 + 1);
              *(_OWORD *)(a1 + 1608) = v55;
              *(_OWORD *)(a1 + 1576) = v54;
              v56 = *((_OWORD *)a2 + 3);
              v57 = *((_OWORD *)a2 + 4);
              v58 = *((_OWORD *)a2 + 5);
              *(_QWORD *)(a1 + 1672) = *((_QWORD *)a2 + 12);
              *(_OWORD *)(a1 + 1640) = v57;
              *(_OWORD *)(a1 + 1656) = v58;
              *(_OWORD *)(a1 + 1624) = v56;
              pthread_mutex_lock((pthread_mutex_t *)(a1 + 176));
              v59 = *(_QWORD *)(a1 + 1280);
              if (v59)
                VCAudioReceiver_ProcessCellularNetworkNotification(v59, a1 + 1576);
              pthread_mutex_unlock((pthread_mutex_t *)(a1 + 176));
              objc_msgSend((id)objc_msgSend((id)a1, "audioTransmitter"), "processNWConnectionNotification:", a1 + 1576);
              v60 = *(_DWORD *)(*(_QWORD *)(a1 + 1280) + 388);
              RATFromNWNotification = VCNWConnectionMonitorUtils_GetRATFromNWNotification(a1 + 1576);
              if ((RATFromNWNotification - 7) >= 2)
                v62 = v60;
              else
                v62 = 6;
              if (RATFromNWNotification == 5)
                v63 = 2;
              else
                v63 = v62;
              if (v60 != v63)
              {
                VCAudioTransmitter_ProcessConnectionType(*(_QWORD *)(a1 + 1160), v63);
                VCAudioReceiver_ProcessConnectionType(*(_QWORD *)(a1 + 1280), v63);
              }
              if (*((_DWORD *)a2 + 1) == 6)
                objc_msgSend((id)a1, "handleBasebandRateTrendSuggestion:", *((unsigned int *)a2 + 2));
            }
          }
          else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              _VCAudioStream_NWConnectionNotificationHandler_cold_3();
          }
        }
        else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VCAudioStream_NWConnectionNotificationHandler_cold_4();
        }
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCAudioStream_NWConnectionNotificationHandler_cold_2();
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCAudioStream_NWConnectionNotificationHandler_cold_1();
    }
  }
}

void _VCAudioStream_ProcessDelegateEventQueue(uint64_t a1)
{
  double v2;
  _DWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _DWORD *v11;
  int v12;
  os_log_t *v13;
  uint64_t v14;
  NSObject *v15;
  int v16;
  uint64_t v17;
  int v18;
  uint8_t buf[4];
  uint64_t v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  int v28;
  __int16 v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v2 = 0.0;
  if (VRTraceIsInternalOSInstalled())
    v2 = micro();
  v3 = CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 1688));
  if (v3)
  {
    v11 = v3;
    v12 = 0;
    v13 = (os_log_t *)MEMORY[0x1E0CF2758];
    do
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v14 = VRTraceErrorLogLevelToCSTR();
        v15 = *v13;
        if (os_log_type_enabled(*v13, OS_LOG_TYPE_DEFAULT))
        {
          v16 = v11[4];
          v17 = *((_QWORD *)v11 + 1);
          *(_DWORD *)buf = 136316418;
          v20 = v14;
          v21 = 2080;
          v22 = "_VCAudioStream_ProcessDelegateEventQueue";
          v23 = 1024;
          v24 = 3216;
          v25 = 2048;
          v26 = a1;
          v27 = 1024;
          v28 = v16;
          v29 = 2048;
          v30 = v17;
          _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, "VCAudioStream [%s] %s:%d Process event: stream=%p type=%d entry delegate=%p", buf, 0x36u);
        }
      }
      v18 = v11[4];
      if (v18 == 1)
      {
        _VCAudioStream_DeregisterSyncDelegateEvent(a1, (uint64_t)v11);
      }
      else if (!v18)
      {
        _VCAudioStream_RegisterSyncDelegateEvent(a1, (uint64_t)v11);
      }
      v11 = CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 1688));
      ++v12;
    }
    while (v11);
  }
  LogProfileTimeOverLimit_0(v2, 0, v4, v5, v6, v7, v8, v9, v10, (char)"_VCAudioStream_ProcessDelegateEventQueue");
}

void _VCAudioStream_ReleaseSyncDelegateEvent(uint64_t *a1, int a2)
{
  uint64_t v2;

  if (a1)
  {
    v2 = *a1;
    if (*a1)
    {
      *a1 = 0;
      if (a2)
        dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v2 + 24));

      dispatch_release(*(dispatch_object_t *)(v2 + 24));
      free((void *)v2);
    }
  }
}

void _VCAudioStream_UpdateSourceNTPToRTPTimeMappingCallback(uint64_t a1, int a2, double a3)
{
  int Count;
  CFIndex v7;
  const void *ValueAtIndex;
  uint64_t v9;
  NSObject *v10;
  uint8_t buf[4];
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  __int16 v19;
  const void *v20;
  __int16 v21;
  double v22;
  __int16 v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 1696));
    v7 = (Count - 1);
    if (Count - 1 >= 0)
    {
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 1696), v7);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v9 = VRTraceErrorLogLevelToCSTR();
          v10 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136316674;
            v12 = v9;
            v13 = 2080;
            v14 = "_VCAudioStream_UpdateSourceNTPToRTPTimeMappingCallback";
            v15 = 1024;
            v16 = 3383;
            v17 = 1024;
            v18 = 3383;
            v19 = 2112;
            v20 = ValueAtIndex;
            v21 = 2048;
            v22 = a3;
            v23 = 1024;
            v24 = a2;
            _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, "VCAudioStream [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VCAudioStream.m:%d: updating syncSourceDelegates=(%@) with ntpTime=%.6f and rtpTimestamp=%u", buf, 0x3Cu);
          }
        }
        VCMediaStreamSyncSourceDelegate_updateSourceNTPTimeWithRTPTimeStamp((uint64_t)ValueAtIndex, a2, a3);
        --Count;
        --v7;
      }
      while (Count > 0);
    }
  }
}

void _VCAudioStream_StreamSwitchCallback(uint64_t a1, int a2, int a3)
{
  uint64_t v6;
  NSObject *v7;
  int v8;
  uint64_t v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v6 = VRTraceErrorLogLevelToCSTR();
    v7 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v8 = 136316418;
      v9 = v6;
      v10 = 2080;
      v11 = "_VCAudioStream_StreamSwitchCallback";
      v12 = 1024;
      v13 = 3427;
      v14 = 2048;
      v15 = a1;
      v16 = 1024;
      v17 = a2;
      v18 = 1024;
      v19 = a3;
      _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, "VCAudioStream [%s] %s:%d audioStream=%p switched from streamID=%u to streamID=%u", (uint8_t *)&v8, 0x32u);
    }
  }
}

void _VCAudioStream_DTMFEventCallback(uint64_t a1, char a2)
{
  NSObject *v2;
  _QWORD block[5];
  char v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = *(NSObject **)(a1 + 168);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = ___VCAudioStream_DTMFEventCallback_block_invoke;
    block[3] = &unk_1E9E521E8;
    block[4] = a1;
    v4 = a2;
    dispatch_async(v2, block);
  }
}

void VCAudioStream_PullAudioSamples(uint64_t a1, unsigned int *a2)
{
  uint64_t v4;
  float v5;
  double v6;
  double v7;
  double v8;
  double v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  char v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  double v18;
  uint64_t v19;
  NSObject *v20;
  int v21;
  double v22;
  uint64_t v23;
  _QWORD *v24;
  int v25;
  int v26;
  unint64_t v27;
  _QWORD *i;
  uint64_t v29;
  double v30;
  double v31;
  uint64_t v33;
  unint64_t v34;
  double v35;
  float OWRD;
  int v37;
  float PercentPacketsLateAndMissing;
  uint64_t v39;
  NSObject *v40;
  double v41;
  uint64_t v42;
  NSObject *v43;
  int v44;
  BOOL v45;
  double v46;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int Timestamp;
  uint64_t v52;
  NSObject *v53;
  int v54;
  __int16 v55;
  double v56;
  int v57;
  int v58;
  uint8_t v59[4];
  uint64_t v60;
  __int16 v61;
  const char *v62;
  __int16 v63;
  int v64;
  __int16 v65;
  double v66;
  __int16 v67;
  _BYTE v68[14];
  __int16 v69;
  double v70;
  uint8_t buf[48];
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  uint64_t v88;

  v88 = *MEMORY[0x1E0C80C00];
  ++*(_DWORD *)(a1 + 32);
  v4 = *(_QWORD *)(a1 + 184);
  _VCAudioStream_ProcessDelegateEventQueue(v4);
  v57 = 0;
  v58 = -1431655766;
  v56 = 0.0;
  VCAudioReceiver_PullAudioSamples(*(_QWORD *)(a1 + 24), (uint64_t)a2, &v57, &v56, 0, &v58, 0);
  v5 = *(float *)(a1 + 36);
  if (v5 != -1.0)
    VCAudioBufferList_ApplyGain((uint64_t)a2, v5);
  v6 = v56;
  v7 = micro();
  v8 = *(double *)(a1 + 48);
  v9 = v7 - v6;
  if (v8 == 0.0 && v9 > 0.0 && (objc_opt_respondsToSelector() & 1) != 0)
  {
    v10 = *(void **)(a1 + 168);
    v11 = *(_QWORD *)(a1 + 184);
    *(_OWORD *)buf = *MEMORY[0x1E0CA2E68];
    *(_QWORD *)&buf[16] = *(_QWORD *)(MEMORY[0x1E0CA2E68] + 16);
    objc_msgSend(v10, "vcMediaStream:didReceiveFirstFrameWithTime:", v11, buf);
    objc_msgSend(*(id *)(a1 + 184), "reportingAlgosAudioStreamEvent:", 0);
  }
  if (v8 < v6)
  {
    if (*(_BYTE *)(a1 + 42))
      ++*(_DWORD *)(a1 + 56);
    *(double *)(a1 + 48) = v6;
  }
  if (v9 <= *(double *)(a1 + 64) * (double)(*(unsigned __int8 *)(a1 + 76) + 1) / 3.0)
  {
    if (*(int *)(a1 + 56) >= 2 && *(_BYTE *)(a1 + 42))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v19 = VRTraceErrorLogLevelToCSTR();
        v20 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v21 = *(_DWORD *)(a1 + 56);
          *(_DWORD *)buf = 136316418;
          *(_QWORD *)&buf[4] = v19;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VCAudioStream_UpdateRemoteMediaStallState";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 428;
          *(_WORD *)&buf[28] = 2048;
          *(double *)&buf[30] = v6;
          *(_WORD *)&buf[38] = 2048;
          *(double *)&buf[40] = v7;
          LOWORD(v72) = 1024;
          *(_DWORD *)((char *)&v72 + 2) = v21;
          _os_log_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_DEFAULT, "VCAudioStream [%s] %s:%d Unstalling lastReceivedPacketTime %f currentTime %f packetCount %d", buf, 0x36u);
        }
      }
      *(_BYTE *)(a1 + 42) = 0;
      *(_BYTE *)(a1 + 76) = 0;
      if ((objc_opt_respondsToSelector() & 1) != 0)
      {
        v15 = *(void **)(a1 + 168);
        v16 = *(_QWORD *)(a1 + 184);
        v17 = *(unsigned __int8 *)(a1 + 42);
        v18 = 0.0;
        goto LABEL_26;
      }
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v12 = VRTraceErrorLogLevelToCSTR();
      v13 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)&buf[4] = v12;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VCAudioStream_UpdateRemoteMediaStallState";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 418;
        *(_WORD *)&buf[28] = 2048;
        *(double *)&buf[30] = v6;
        *(_WORD *)&buf[38] = 2048;
        *(double *)&buf[40] = v7;
        _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, "VCAudioStream [%s] %s:%d Stalling lastReceivedPacketTime %f currentTime %f", buf, 0x30u);
      }
    }
    v14 = *(_BYTE *)(a1 + 76);
    if (!v14)
    {
      *(_BYTE *)(a1 + 42) = 1;
      *(_DWORD *)(a1 + 56) = 0;
    }
    *(_BYTE *)(a1 + 76) = v14 + 1;
    if ((objc_opt_respondsToSelector() & 1) != 0)
    {
      v15 = *(void **)(a1 + 168);
      v16 = *(_QWORD *)(a1 + 184);
      v17 = *(unsigned __int8 *)(a1 + 42);
      v18 = v7 - v6;
LABEL_26:
      objc_msgSend(v15, "vcMediaStream:remoteMediaStalled:duration:", v16, v17, v18);
    }
  }
  if (*(_BYTE *)(a1 + 41))
    VCAudioBufferList_ZeroMemory((uint64_t)a2);
  v22 = micro();
  v23 = *(_QWORD *)(a1 + 184);
  if (v23)
  {
    v24 = *(_QWORD **)(v23 + 1368);
    if (v24)
    {
      v25 = v57;
      do
      {
        VCMediaStreamSyncSourceDelegate_updateSourcePlayoutSampleRTPTimestamp(v24[1], v25, v22);
        v24 = (_QWORD *)*v24;
      }
      while (v24);
    }
  }
  if (*(_BYTE *)(a1 + 40))
  {
    objc_msgSend(*(id *)(a1 + 192), "stream:addAudioSampleBuffer:timestamp:", *(_QWORD *)(a1 + 184), a2, (micro() * 1000.0));
    v26 = *(_DWORD *)(a1 + 72) + 1;
    *(_DWORD *)(a1 + 72) = v26;
    HIDWORD(v27) = 652835029 * v26;
    LODWORD(v27) = 652835029 * v26;
    if ((v27 >> 2) <= 0x83126E)
      VCAudioReceiver_ReportAWDMetrics(*(unsigned int **)(a1 + 24));
    memset(buf, 0, 40);
    VCAudioReceiver_GetJitterBufferMetrics(*(_QWORD *)(a1 + 24), (uint64_t)buf);
    for (i = *(_QWORD **)(a1 + 80); i; i = (_QWORD *)*i)
      VCAudioStreamTransport_SubmitWRMReportWithJitterBufferMetrics(i[1], (uint64_t)buf);
  }
  v55 = -21846;
  if (!VCAudioReceiver_GetActiveStreamId(*(_QWORD *)(a1 + 24), &v55)
    && v55 == *(_WORD *)(a1 + 144)
    && *(_BYTE *)(a1 + 160))
  {
    v29 = *(_QWORD *)(a1 + 184);
    if (v29)
    {
      v30 = v56;
      v31 = v56 - *(double *)(v29 + 1496);
      if (v31 > 1.0 || v22 - *(double *)(v29 + 1504) > 1.0)
      {
        v33 = *(_QWORD *)(a1 + 152);
        if (v33)
        {
          *(_QWORD *)&v81 = 0;
          v79 = 0u;
          v80 = 0u;
          v77 = 0u;
          v78 = 0u;
          v75 = 0u;
          v76 = 0u;
          v73 = 0u;
          v74 = 0u;
          v72 = 0u;
          memset(buf, 0, sizeof(buf));
          VCRateControlGetStatistics(v33, 3, (uint64_t)buf);
          LODWORD(v34) = DWORD1(v72);
          v35 = (double)v34 / 1000.0;
          OWRD = VCAudioReceiver_GetOWRD(*(_QWORD *)(a1 + 24));
          v37 = v73;
          *(double *)(v29 + 1512) = *(double *)&buf[24] / 100.0 + *(double *)(v29 + 1512);
          ++*(_DWORD *)(v29 + 1520);
          *(double *)(v29 + 1504) = v22;
          PercentPacketsLateAndMissing = VCAudioReceiver_GetPercentPacketsLateAndMissing(*(_QWORD *)(a1 + 24));
          if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
          {
            v39 = VRTraceErrorLogLevelToCSTR();
            v40 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              v41 = *(double *)(v29 + 1528);
              *(_DWORD *)v59 = 136316674;
              v60 = v39;
              v61 = 2080;
              v62 = "_VCAudioStream_CheckAbnormalOWRDAndResetLagReference";
              v63 = 1024;
              v64 = 462;
              v65 = 2048;
              v66 = v35;
              v67 = 1024;
              *(_DWORD *)v68 = v37;
              *(_WORD *)&v68[4] = 2048;
              *(double *)&v68[6] = v41 * 100.0;
              v69 = 2048;
              v70 = PercentPacketsLateAndMissing * 100.0;
              _os_log_impl(&dword_1D8A54000, v40, OS_LOG_TYPE_DEFAULT, "VCAudioStream [%s] %s:%d RTT=%.3f, TxBW=%ub/sec, PLR=%.2f%%, PLaMR=%.2f%%", v59, 0x40u);
            }
          }
          if (v31 > 1.0)
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v42 = VRTraceErrorLogLevelToCSTR();
              v43 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                v44 = *(_DWORD *)(v29 + 1488);
                *(_DWORD *)v59 = 136316418;
                v60 = v42;
                v61 = 2080;
                v62 = "_VCAudioStream_CheckAbnormalOWRDAndResetLagReference";
                v63 = 1024;
                v64 = 467;
                v65 = 2048;
                v66 = v35;
                v67 = 2048;
                *(double *)v68 = OWRD;
                *(_WORD *)&v68[8] = 1024;
                *(_DWORD *)&v68[10] = v44;
                _os_log_impl(&dword_1D8A54000, v43, OS_LOG_TYPE_DEFAULT, "VCAudioStream [%s] %s:%d Abnormal OWRD Verification: rtt=%f, owrd=%f, _abnormalOWRDCount=%d", v59, 0x36u);
              }
            }
            *(double *)(v29 + 1496) = v30;
            v45 = v35 <= 0.0 || OWRD <= 2.0;
            v46 = OWRD;
            if (!v45 && v35 * 5.0 < v46)
            {
              ++*(_DWORD *)(v29 + 1488);
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                v52 = VRTraceErrorLogLevelToCSTR();
                v53 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                {
                  v54 = *(_DWORD *)(v29 + 1488);
                  *(_DWORD *)v59 = 136316418;
                  v60 = v52;
                  v61 = 2080;
                  v62 = "_VCAudioStream_CheckAbnormalOWRDAndResetLagReference";
                  v63 = 1024;
                  v64 = 474;
                  v65 = 2048;
                  v66 = v35;
                  v67 = 2048;
                  *(double *)v68 = v46;
                  *(_WORD *)&v68[8] = 1024;
                  *(_DWORD *)&v68[10] = v54;
                  _os_log_error_impl(&dword_1D8A54000, v53, OS_LOG_TYPE_ERROR, "VCAudioStream [%s] %s:%d Abnormal OWRD detected: rtt=%f, owrd=%f, _abnormalOWRDCount=%d", v59, 0x36u);
                }
              }
            }
            else
            {
              *(_DWORD *)(v29 + 1488) = 0;
            }
            if (*(_DWORD *)(v29 + 1488) >= 4u)
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  VCAudioStream_PullAudioSamples_cold_3();
              }
              VCAudioReceiver_ResetLagReference(*(_QWORD *)(a1 + 24));
            }
          }
        }
        else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCAudioStream_PullAudioSamples_cold_2();
        }
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioStream_PullAudioSamples_cold_1();
    }
    if (v22 - *(double *)(v29 + 1536) >= 5.0)
    {
      *(double *)(v29 + 1528) = *(double *)(v29 + 1512) / (double)*(int *)(v29 + 1520);
      *(_QWORD *)(v29 + 1512) = 0;
      *(_DWORD *)(v29 + 1520) = 0;
      *(double *)(v29 + 1536) = v22;
    }
    v86 = 0u;
    v87 = 0u;
    v84 = 0u;
    v85 = 0u;
    v82 = 0u;
    v83 = 0u;
    v80 = 0u;
    v81 = 0u;
    v78 = 0u;
    v79 = 0u;
    v76 = 0u;
    v77 = 0u;
    v74 = 0u;
    v75 = 0u;
    v72 = 0u;
    v73 = 0u;
    memset(buf, 0, sizeof(buf));
    v48 = *(_QWORD *)(a1 + 200);
    if (v48)
    {
      WRMIncrementTime(v48);
      VCAudioTransmitter_UpdateWrmMetrics(*(_QWORD *)(a1 + 208), *(_QWORD *)(a1 + 200));
      VCAudioReceiver_UpdateWrmMetrics(*(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 200));
      if (WRMGenerateReport(*(unsigned __int8 **)(a1 + 200), (uint64_t)buf))
        WRMSubmitReport(*(_QWORD *)(a1 + 200), (uint64_t)buf);
    }
  }
  if (*(_BYTE *)a1)
    VCAudioBufferList_ZeroMemory((uint64_t)a2);
  _VCAudioStream_UpdateSoundMeter(v4, a1 + 8, 0, (uint64_t)a2);
  if (*(_BYTE *)(v4 + 1776))
    VCAudioPowerSpectrumSource_PushAudioSamples(*(id **)(v4 + 1480), (uint64_t)a2);
  v49 = *(_QWORD *)(v4 + 1888);
  if (v49)
    VCAudioCaptionsCoordinator_PushAudioSamples(v49, *(_QWORD *)(v4 + 632), a2);
  v50 = *(_QWORD *)(v4 + 1824);
  if (v50)
  {
    Timestamp = VCAudioBufferList_GetTimestamp((uint64_t)a2);
    VCMediaRecorder_AddRemoteAudioSampleBuffer(v50, (uint64_t)a2, Timestamp);
  }
  VCMediaStream_CheckForDecryptionTimeout(v4);
}

void VCAudioStream_SetAllowedCodecConfigurations(uint64_t a1, const __CFDictionary *a2)
{
  uint64_t v4;
  int ErrorLogLevelForModule;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  CFMutableArrayRef Mutable;
  __CFArray *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t i;
  void *v16;
  const void *v17;
  _BYTE v18[128];
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint8_t buf[4];
  uint64_t v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  uint64_t v30;
  __int16 v31;
  uint64_t v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v4 = *(_QWORD *)(a1 + 1160);
    ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    if (v4)
    {
      if (ErrorLogLevelForModule >= 7)
      {
        v6 = VRTraceErrorLogLevelToCSTR();
        v7 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v8 = *(_QWORD *)(a1 + 1160);
          *(_DWORD *)buf = 136316162;
          v24 = v6;
          v25 = 2080;
          v26 = "VCAudioStream_SetAllowedCodecConfigurations";
          v27 = 1024;
          v28 = 2010;
          v29 = 2048;
          v30 = a1;
          v31 = 2048;
          v32 = v8;
          _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, "VCAudioStream [%s] %s:%d stream=%p audioTransmitter=%p", buf, 0x30u);
        }
      }
      Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
      if (Mutable)
      {
        v10 = Mutable;
        v21 = 0u;
        v22 = 0u;
        v19 = 0u;
        v20 = 0u;
        v11 = *(void **)(a1 + 1744);
        v12 = objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v19, v18, 16);
        if (v12)
        {
          v13 = v12;
          v14 = *(_QWORD *)v20;
          do
          {
            for (i = 0; i != v13; ++i)
            {
              if (*(_QWORD *)v20 != v14)
                objc_enumerationMutation(v11);
              v16 = *(void **)(*((_QWORD *)&v19 + 1) + 8 * i);
              v17 = (const void *)objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInteger:", VCPayloadUtils_CodecTypeForPayload(objc_msgSend((id)objc_msgSend(v16, "config"), "payload")));
              if (CFDictionaryContainsKey(a2, v17))
                CFArrayAppendValue(v10, v16);
            }
            v13 = objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v19, v18, 16);
          }
          while (v13);
        }
        VCAudioTransmitter_SetAllowedPayloads(*(_QWORD *)(a1 + 1160), v10);
        CFRelease(v10);
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCAudioStream_SetAllowedCodecConfigurations_cold_3();
      }
    }
    else if (ErrorLogLevelForModule >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioStream_SetAllowedCodecConfigurations_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioStream_SetAllowedCodecConfigurations_cold_1();
  }
}

void VCAudioStream_SetAudioPlayoutDelay(uint64_t a1, double a2, double a3)
{
  uint64_t v3;

  if (a1)
  {
    *(double *)(a1 + 1808) = a2;
    v3 = *(_QWORD *)(a1 + 1280);
    if (v3)
      VCAudioReceiver_SetAudioPlayoutDelay(v3, a2, a3);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioStream_SetAudioPlayoutDelay_cold_1();
  }
}

void VCAudioStream_PushAudioSamples(uint64_t a1, unsigned int *a2)
{
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  double HostTime;
  int SampleCount;
  double HostTimeJumpSize;
  __CFDictionary *Mutable;
  int *v12;
  uint64_t v13;
  double v14;
  double v15;
  float v16;
  unsigned int v17;
  unsigned int v18;
  NSObject *v19;
  double v20;
  double v21;
  unint64_t v22;
  double v23;
  unsigned int *v24;
  unsigned int v25;
  unint64_t *v26;
  unint64_t v27;
  int v28;
  int v29;
  int v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint8_t buf[4];
  uint64_t v39;
  __int16 v40;
  const char *v41;
  __int16 v42;
  int v43;
  __int16 v44;
  const char *v45;
  __int16 v46;
  int Timestamp;
  __int16 v48;
  int v49;
  __int16 v50;
  int v51;
  __int16 v52;
  double v53;
  __int16 v54;
  unsigned int v55;
  __int16 v56;
  uint64_t v57;
  __int16 v58;
  double v59;
  __int16 v60;
  unsigned int v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (pthread_rwlock_tryrdlock((pthread_rwlock_t *)(a1 + 864)))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v4 = VRTraceErrorLogLevelToCSTR();
        v5 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316162;
          v39 = v4;
          v40 = 2080;
          v41 = "VCAudioStream_PushAudioSamples";
          v42 = 1024;
          v43 = 3182;
          v44 = 2048;
          v45 = (const char *)a1;
          v46 = 1024;
          Timestamp = VCAudioBufferList_GetTimestamp((uint64_t)a2);
          _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, "VCAudioStream [%s] %s:%d VCAudioStream[%p] IOProc:  Missing grabbing lock onCaptureSound at %u", buf, 0x2Cu);
        }
      }
    }
    else
    {
      v6 = a1 + 1240;
      if (*(_DWORD *)(a1 + 408) == 2)
      {
        v7 = VCAudioBufferList_GetTimestamp((uint64_t)a2);
        HostTime = VCAudioBufferList_GetHostTime((uint64_t)a2);
        SampleCount = VCAudioBufferList_GetSampleCount((uint64_t)a2);
        HostTimeJumpSize = VCAudioBufferList_GetHostTimeJumpSize((uint64_t)a2);
        Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        CFDictionaryAddValue(Mutable, CFSTR("VCASHostTimeJumpSize"), (const void *)objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", HostTimeJumpSize * 1000.0));
        reportingAudioStreamEvent();
        if (Mutable)
          CFRelease(Mutable);
        v12 = &OBJC_IVAR___AVCRTCPReceiverReport__reportedSourceSSRC;
        v13 = v7;
        if (*(_DWORD *)(a1 + 432) != 6)
        {
          v14 = *(double *)(a1 + 824);
          if (v14 == 0.0)
          {
            v28 = 0;
          }
          else
          {
            v15 = HostTime - v14;
            v16 = *(double *)(a1 + 1072) / (double)SampleCount;
            v17 = SampleCount * llround(v15 * v16);
            if (v17 != SampleCount)
            {
              v18 = v7 - *(_DWORD *)(a1 + 852);
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                v37 = VRTraceErrorLogLevelToCSTR();
                v19 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                {
                  v35 = *(_DWORD *)(a1 + 852);
                  v36 = *(_QWORD *)(a1 + 824);
                  *(_DWORD *)buf = 136317954;
                  v39 = v37;
                  v40 = 2080;
                  v41 = "_VCAudioStream_ComputePacketTimestampWithInputTimestamp";
                  v42 = 1024;
                  v43 = 222;
                  v44 = 2080;
                  v45 = "_VCAudioStream_ComputePacketTimestampWithInputTimestamp";
                  v46 = 1024;
                  Timestamp = v18;
                  v48 = 1024;
                  v49 = v35;
                  v50 = 1024;
                  v51 = v7;
                  v52 = 2048;
                  v53 = v15;
                  v54 = 1024;
                  v55 = v17;
                  v56 = 2048;
                  v57 = v36;
                  v58 = 2048;
                  v59 = HostTime;
                  v60 = 1024;
                  v61 = v17;
                  _os_log_error_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_ERROR, "VCAudioStream [%s] %s:%d %s Timestamp jumped=%u (%u to %u), host time=%f (samples=%d) (%f to %f). Adjustment=%d", buf, 0x62u);
                }
              }
              v20 = *(double *)(a1 + 1072);
              if (v20 != 0.0)
              {
                v21 = (double)(1000 * (unint64_t)v18) / v20;
                v22 = atomic_load((unint64_t *)(a1 + 1736));
                v23 = (double)v22;
                if (v21 >= (double)v22)
                  v23 = v21;
                v24 = (unsigned int *)(a1 + 1720);
                do
                  v25 = __ldaxr(v24);
                while (__stlxr(v25 + 1, v24));
                v26 = (unint64_t *)(a1 + 1728);
                do
                  v27 = __ldaxr(v26);
                while (__stlxr(v27 + (unint64_t)v21, v26));
                atomic_store((unint64_t)v23, (unint64_t *)(a1 + 1736));
              }
              SampleCount = v17;
            }
            v28 = (int)((double)(objc_msgSend((id)objc_msgSend(*(id *)(a1 + 1160), "currentAudioPayloadConfig", v37), "codecSampleRate")* (uint64_t)SampleCount)/ *(double *)(a1 + 1072));
            v12 = &OBJC_IVAR___AVCRTCPReceiverReport__reportedSourceSSRC;
          }
          v13 = (*(_DWORD *)(a1 + v12[502]) + v28);
        }
        if ((objc_msgSend(*(id *)(a1 + 1128), "shouldTransmitDTMFWithTimestamp:", v13) & 1) != 0)
        {
          objc_msgSend(*(id *)(a1 + 1128), "sendingDTMFEventWithTimeStamp:interval:RTPHandle:", v13, (int)(*(double *)(a1 + 1072)* (double)(v13 - *(_DWORD *)(a1 + v12[502]))/ (double)objc_msgSend((id)objc_msgSend(*(id *)(a1 + 1160), "currentAudioPayloadConfig"), "codecSampleRate")), objc_msgSend((id)objc_msgSend((id)a1, "defaultTransport"), "rtpHandle"));
        }
        else
        {
          VCAudioBufferList_SetTime((uint64_t)a2, v13, HostTime);
          v29 = *(unsigned __int8 *)(a1 + 1221);
          if (v29 != objc_msgSend(*(id *)(a1 + 1160), "isCurrentDTXEnabled"))
            objc_msgSend(*(id *)(a1 + 1160), "setCurrentDTXEnable:", *(unsigned __int8 *)(a1 + 1221));
          VCAudioTransmitter_PushAudioSamples(*(_QWORD *)(a1 + 1160), (uint64_t)a2);
          VCAudioBufferList_SetTime((uint64_t)a2, v7, HostTime);
        }
        *(_DWORD *)(a1 + v12[502]) = v13;
        *(_DWORD *)(a1 + 852) = v7;
        *(double *)(a1 + 824) = HostTime;
        v30 = *(_DWORD *)(a1 + 1680) + 1;
        *(_DWORD *)(a1 + 1680) = v30;
        HIDWORD(v31) = 652835029 * v30;
        LODWORD(v31) = 652835029 * v30;
        v6 = a1 + 1240;
        if ((v31 >> 2) <= 0x83126E)
          VCAudioTransmitter_ReportAWDMetrics(*(_QWORD *)(a1 + 1160));
      }
      _VCAudioStream_UpdateSoundMeter(a1, v6, 1, (uint64_t)a2);
      if (*(_BYTE *)(a1 + 1776))
        VCAudioPowerSpectrumSource_PushAudioSamples(*(id **)(a1 + 1472), (uint64_t)a2);
      v32 = *(_QWORD *)(a1 + 1888);
      if (v32)
        VCAudioCaptionsCoordinator_PushAudioSamples(v32, *(_QWORD *)(a1 + 624), a2);
      v33 = *(_QWORD *)(a1 + 1824);
      if (v33)
      {
        v34 = VCAudioBufferList_GetTimestamp((uint64_t)a2);
        VCMediaRecorder_AddLocalAudioSampleBuffer(v33, (uint64_t)a2, v34);
      }
      pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 864));
    }
  }
}

void _VCAudioStream_UpdateSoundMeter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __CFData *v5;
  void (*v6)(void);

  if (*(_BYTE *)a2)
  {
    v5 = VCFFTMeter_Compute(*(_QWORD *)(a2 + 8), a4);
    if (*(_QWORD *)(a1 + 256))
    {
      v6 = *(void (**)(void))(a1 + 264);
      if (v6)
        v6();
    }
    if (v5)
      CFRelease(v5);
  }
}

void VCAudioStream_PushRemainingSamples(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  __int16 v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (pthread_rwlock_tryrdlock((pthread_rwlock_t *)(a1 + 864)))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v2 = VRTraceErrorLogLevelToCSTR();
      v3 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v4 = 136315906;
        v5 = v2;
        v6 = 2080;
        v7 = "VCAudioStream_PushRemainingSamples";
        v8 = 1024;
        v9 = 3195;
        v10 = 2048;
        v11 = a1;
        _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, "VCAudioStream [%s] %s:%d VCAudioStream[%p] IOProc: Missing grabbing lock onCaptureSound", (uint8_t *)&v4, 0x26u);
      }
    }
  }
  else
  {
    VCAudioTransmitter_PushRemainingSamples(*(_QWORD *)(a1 + 1160));
    pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 864));
  }
}

_DWORD *_VCAudioStream_NewSyncDelegateEvent(int a1, uint64_t a2, void *a3)
{
  _DWORD *v6;
  id v7;
  NSObject *v8;

  v6 = malloc_type_calloc(1uLL, 0x20uLL, 0x10A0040F8598106uLL);
  v6[4] = a1;
  *((_QWORD *)v6 + 1) = a3;
  v7 = a3;
  v8 = *(NSObject **)(a2 + 1792);
  *((_QWORD *)v6 + 3) = v8;
  dispatch_retain(v8);
  return v6;
}

void _VCAudioStream_RegisterSyncDelegateEvent(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint8_t buf[4];
  uint64_t v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  uint64_t v16;
  __int16 v17;
  uint64_t v18;
  __int16 v19;
  int v20;
  __int16 v21;
  uint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v8 = a2;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(a2 + 16);
      v7 = *(_QWORD *)(a2 + 8);
      *(_DWORD *)buf = 136316674;
      v10 = v4;
      v11 = 2080;
      v12 = "_VCAudioStream_RegisterSyncDelegateEvent";
      v13 = 1024;
      v14 = 3262;
      v15 = 2048;
      v16 = a1;
      v17 = 2048;
      v18 = a2;
      v19 = 1024;
      v20 = v6;
      v21 = 2048;
      v22 = v7;
      _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, "VCAudioStream [%s] %s:%d Registering audioStream=%p entry=%p entryType=%d delegate=%p", buf, 0x40u);
    }
  }
  if ((VCSingleLinkedListPush(a1 + 1368, (_QWORD *)a2) & 1) == 0)
    _VCAudioStream_ReleaseSyncDelegateEvent(&v8, 0);
}

void _VCAudioStream_DeregisterSyncDelegateEvent(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE buf[12];
  __int16 v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  int v19;
  __int16 v20;
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v8 = a2;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(a2 + 16);
      v7 = *(_QWORD *)(a2 + 8);
      *(_DWORD *)buf = 136316674;
      *(_QWORD *)&buf[4] = v4;
      v10 = 2080;
      v11 = "_VCAudioStream_DeregisterSyncDelegateEvent";
      v12 = 1024;
      v13 = 3253;
      v14 = 2048;
      v15 = a1;
      v16 = 2048;
      v17 = a2;
      v18 = 1024;
      v19 = v6;
      v20 = 2048;
      v21 = v7;
      _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, "VCAudioStream [%s] %s:%d Deregistering audioStream=%p entry=%p entryType=%d delegate=%p", buf, 0x40u);
    }
  }
  *(_QWORD *)buf = VCSingleLinkedListRemove(a1 + 1368, a2);
  if (*(_QWORD *)buf)
    _VCAudioStream_ReleaseSyncDelegateEvent((uint64_t *)buf, 0);
  _VCAudioStream_ReleaseSyncDelegateEvent(&v8, 1);
}

void CodecRateModeChangeNotificationCallback(void *a1, __int128 *a2)
{
  void *v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v4 = (void *)MEMORY[0x1DF088A10]();
  v5 = *a2;
  v6 = *((_QWORD *)a2 + 2);
  objc_msgSend(a1, "handleCodecModeChangeEvent:", &v5);
  objc_autoreleasePoolPop(v4);
}

void _VCAudioStream_ActiveStreamChangeCallback(uint64_t a1, __int16 a2)
{
  void *v4;
  NSObject *v5;
  uint64_t v6;
  NSObject *v7;
  _QWORD v8[5];
  __int16 v9;
  uint8_t buf[4];
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v4 = (void *)MEMORY[0x1DF088A10]();
  if (a1)
  {
    v5 = *(NSObject **)(a1 + 168);
    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 3221225472;
    v8[2] = ___VCAudioStream_ActiveStreamChangeCallback_block_invoke;
    v8[3] = &unk_1E9E52A50;
    v8[4] = a1;
    v9 = a2;
    dispatch_async(v5, v8);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v6 = VRTraceErrorLogLevelToCSTR();
    v7 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      v11 = v6;
      v12 = 2080;
      v13 = "_VCAudioStream_ActiveStreamChangeCallback";
      v14 = 1024;
      v15 = 3404;
      _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, "VCAudioStream [%s] %s:%d stream is nil", buf, 0x1Cu);
    }
  }
  objc_autoreleasePoolPop(v4);
}

void LogProfileTimeOverLimit_0(double a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10)
{
  double v11;
  __int128 v12;
  uint64_t v13;
  NSObject *v14;
  uint8_t buf[4];
  uint64_t v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  char *v22;
  __int16 v23;
  double v24;
  char __str[16];
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  if (VRTraceIsInternalOSInstalled())
  {
    v11 = micro() - a1;
    if (v11 > 0.00300000003)
    {
      *(_QWORD *)&v12 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v39 = v12;
      v40 = v12;
      v37 = v12;
      v38 = v12;
      v35 = v12;
      v36 = v12;
      v33 = v12;
      v34 = v12;
      v31 = v12;
      v32 = v12;
      v30 = v12;
      v28 = v12;
      v29 = v12;
      v26 = v12;
      v27 = v12;
      *(_OWORD *)__str = v12;
      vsnprintf(__str, 0x100uLL, "%s: Iterations=%d", &a10);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v13 = VRTraceErrorLogLevelToCSTR();
        v14 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316162;
          v16 = v13;
          v17 = 2080;
          v18 = "_LogProfileTimeLimitHelper";
          v19 = 1024;
          v20 = 36;
          v21 = 2080;
          v22 = __str;
          v23 = 2048;
          v24 = v11;
          _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, "VCAudioStream [%s] %s:%d %s: Took a long time %fs", buf, 0x30u);
        }
      }
    }
  }
}

void OUTLINED_FUNCTION_14_1(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, a5, 0x26u);
}

uint64_t VCMediaNegotiationBlobV2ReadFrom(id *a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  VCMediaNegotiationBlobV2GeneralInfo *v17;
  uint64_t result;
  VCMediaNegotiationBlobV2BandwidthSettings *v19;
  VCMediaNegotiationBlobV2CodecFeatures *v20;
  VCMediaNegotiationBlobV2MicrophoneSettingsU1 *v21;
  VCMediaNegotiationBlobV2CameraSettingsU1 *v22;
  VCMediaNegotiationBlobV2MomentsSettings *v23;
  VCMediaNegotiationBlobV2StreamGroup *v24;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) >= *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
    return *(_BYTE *)(a2 + *v5) == 0;
  v7 = (int *)MEMORY[0x1E0D82BB8];
  while (2)
  {
    if (*(_BYTE *)(a2 + *v5))
      return *(_BYTE *)(a2 + *v5) == 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v11 = *v3;
      v12 = *(_QWORD *)(a2 + v11);
      if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
        break;
      v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
      *(_QWORD *)(a2 + v11) = v12 + 1;
      v10 |= (unint64_t)(v13 & 0x7F) << v8;
      if ((v13 & 0x80) == 0)
        goto LABEL_12;
      v8 += 7;
      if (v9++ >= 9)
      {
        v10 = 0;
        v15 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
    v15 = *(unsigned __int8 *)(a2 + *v5);
    if (*(_BYTE *)(a2 + *v5))
      v10 = 0;
LABEL_14:
    if (v15 || (v10 & 7) == 4)
      return *(_BYTE *)(a2 + *v5) == 0;
    switch((v10 >> 3))
    {
      case 1u:
        v17 = objc_alloc_init(VCMediaNegotiationBlobV2GeneralInfo);

        a1[4] = v17;
        if (PBReaderPlaceMark()
          && (VCMediaNegotiationBlobV2GeneralInfoReadFrom((uint64_t)v17, a2) & 1) != 0)
        {
          goto LABEL_41;
        }
        return 0;
      case 2u:
        v19 = objc_alloc_init(VCMediaNegotiationBlobV2BandwidthSettings);

        a1[1] = v19;
        if (!PBReaderPlaceMark() || !VCMediaNegotiationBlobV2BandwidthSettingsReadFrom((uint64_t)v19, a2))
          return 0;
        goto LABEL_41;
      case 3u:
        v20 = objc_alloc_init(VCMediaNegotiationBlobV2CodecFeatures);

        a1[3] = v20;
        if (!PBReaderPlaceMark()
          || (VCMediaNegotiationBlobV2CodecFeaturesReadFrom((uint64_t)v20, a2) & 1) == 0)
        {
          return 0;
        }
        goto LABEL_41;
      case 4u:
        v21 = objc_alloc_init(VCMediaNegotiationBlobV2MicrophoneSettingsU1);

        a1[5] = v21;
        if (!PBReaderPlaceMark()
          || !VCMediaNegotiationBlobV2MicrophoneSettingsU1ReadFrom((uint64_t)v21, a2))
        {
          return 0;
        }
        goto LABEL_41;
      case 5u:
        v22 = objc_alloc_init(VCMediaNegotiationBlobV2CameraSettingsU1);

        a1[2] = v22;
        if (!PBReaderPlaceMark() || (VCMediaNegotiationBlobV2CameraSettingsU1ReadFrom(v22, a2) & 1) == 0)
          return 0;
        goto LABEL_41;
      case 6u:
        v23 = objc_alloc_init(VCMediaNegotiationBlobV2MomentsSettings);

        a1[6] = v23;
        if (!PBReaderPlaceMark() || !VCMediaNegotiationBlobV2MomentsSettingsReadFrom((uint64_t)v23, a2))
          return 0;
        goto LABEL_41;
      case 7u:
        v24 = objc_alloc_init(VCMediaNegotiationBlobV2StreamGroup);
        objc_msgSend(a1, "addStreamGroups:", v24);

        if (PBReaderPlaceMark()
          && (VCMediaNegotiationBlobV2StreamGroupReadFrom((uint64_t)v24, a2) & 1) != 0)
        {
LABEL_41:
          PBReaderRecallMark();
LABEL_42:
          if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
            return *(_BYTE *)(a2 + *v5) == 0;
          continue;
        }
        return 0;
      default:
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
        goto LABEL_42;
    }
  }
}

void _VCScreenCapture_setRepeatFrameAttributes(opaqueCMSampleBuffer *a1, int a2)
{
  __CVBuffer *ImageBuffer;
  CFTypeRef *v4;

  ImageBuffer = CMSampleBufferGetImageBuffer(a1);
  if (ImageBuffer)
  {
    v4 = (CFTypeRef *)MEMORY[0x1E0C9AE50];
    if (!a2)
      v4 = (CFTypeRef *)MEMORY[0x1E0C9AE40];
    CVBufferSetAttachment(ImageBuffer, (CFStringRef)*MEMORY[0x1E0CED620], *v4, kCVAttachmentMode_ShouldPropagate);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCScreenCapture_setRepeatFrameAttributes_cold_1();
  }
}

void _VCScreenCapture_handleFrameInternal(uint64_t a1, CMSampleBufferRef cf, int a3, char a4)
{
  uint64_t v8;
  NSObject *v9;
  int v10;
  CVImageBufferRef ImageBuffer;
  __CVBuffer *v12;
  const __CFString *v13;
  CFTypeRef v14;
  uint64_t v15;
  NSObject *v16;
  size_t Height;
  double Seconds;
  double v19;
  __CVBuffer *v20;
  __int128 v21;
  __int128 v22;
  double v23;
  double v24;
  double v25;
  uint64_t v26;
  NSObject *v27;
  NSObject *v28;
  Float64 v29;
  Float64 v30;
  int v31;
  int v32;
  uint64_t v33;
  NSObject *v34;
  NSObject *v35;
  Float64 v36;
  int32_t v37;
  uint64_t v38;
  NSObject *v39;
  NSObject *v40;
  Float64 v41;
  Float64 v42;
  uint64_t v43;
  NSObject *v44;
  Float64 v45;
  Float64 v46;
  int v47;
  int v48;
  int v49;
  size_t v50;
  __CVBuffer *ResizeFrame;
  size_t v52;
  size_t v53;
  int v54;
  CMTimeFlags v55;
  const void *v56;
  CFTypeRef v57;
  __IOSurface *IOSurface;
  const __CFDictionary *Mutable;
  __int128 v60;
  CMTimeEpoch epoch;
  Float64 v62;
  Float64 v63;
  Float64 v64;
  size_t Width;
  CMTime v66;
  CMTime v67;
  CMTime v68;
  CMTime extraRowsOnBottom;
  CMTime extraColumnsOnRight;
  _BYTE buf[48];
  __int128 v72;
  _QWORD v73[6];

  v73[3] = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 464) != a3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v8 = VRTraceErrorLogLevelToCSTR();
      v9 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v10 = *(_DWORD *)(a1 + 464);
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)&buf[4] = v8;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VCScreenCapture_handleFrameInternal";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 493;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v10;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = a3;
        _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, "VCScreenCapture [%s] %s:%d Source frame transform has changed. old transform=%d -> new transform=%d", buf, 0x28u);
      }
    }
    *(_DWORD *)(a1 + 464) = a3;
  }
  if ((a4 & 1) == 0)
    _VCScreenCapture_UpdateShouldClearScreen(a1, 0);
  CFRetain(cf);
  ImageBuffer = CMSampleBufferGetImageBuffer(cf);
  if (!ImageBuffer)
    goto LABEL_103;
  v12 = ImageBuffer;
  memset(&v66, 170, sizeof(v66));
  CMSampleBufferGetOutputPresentationTimeStamp(&v66, cf);
  v13 = (const __CFString *)*MEMORY[0x1E0CED620];
  v14 = CMGetAttachment(cf, (CFStringRef)*MEMORY[0x1E0CED620], 0);
  if ((a4 & 1) == 0 && !*(_BYTE *)(a1 + 476))
  {
    *(_BYTE *)(a1 + 476) = 1;
    extraColumnsOnRight.value = 0xAAAAAAAAAAAAAAAALL;
    extraRowsOnBottom.value = 0xAAAAAAAAAAAAAAAALL;
    CVPixelBufferGetExtendedPixels(v12, 0, (size_t *)&extraColumnsOnRight, 0, (size_t *)&extraRowsOnBottom);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v15 = VRTraceErrorLogLevelToCSTR();
      v16 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        Width = CVPixelBufferGetWidth(v12);
        Height = CVPixelBufferGetHeight(v12);
        *(_DWORD *)buf = 136316930;
        *(_QWORD *)&buf[4] = v15;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VCScreenCapture_handleFrameInternal";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 513;
        *(_WORD *)&buf[28] = 2048;
        *(_QWORD *)&buf[30] = Width;
        *(_WORD *)&buf[38] = 2048;
        *(_QWORD *)&buf[40] = Height;
        LOWORD(v72) = 1024;
        *(_DWORD *)((char *)&v72 + 2) = a3;
        WORD3(v72) = 2048;
        *((_QWORD *)&v72 + 1) = extraColumnsOnRight.value;
        LOWORD(v73[0]) = 2048;
        *(_QWORD *)((char *)v73 + 2) = extraRowsOnBottom.value;
        _os_log_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEFAULT, "VCScreenCapture [%s] %s:%d Captured first frame with source width %.1zu x height:%.1zu transform=%d extendedPixelsRight=%zu  extendedPixelsBottom=%zu", buf, 0x4Au);
      }
    }
  }
  if (!*(_BYTE *)(a1 + 468))
  {
    v31 = 0;
    v32 = 1;
    goto LABEL_48;
  }
  *(CMTime *)buf = v66;
  Seconds = CMTimeGetSeconds((CMTime *)buf);
  *(_OWORD *)buf = *(_OWORD *)(a1 + 396);
  *(_QWORD *)&buf[16] = *(_QWORD *)(a1 + 412);
  v19 = Seconds - CMTimeGetSeconds((CMTime *)buf);
  v20 = CMSampleBufferGetImageBuffer(cf);
  if (v14)
  {
    CVBufferSetAttachment(v20, v13, v14, kCVAttachmentMode_ShouldPropagate);
    CMTimeMake(&v68, 2, 60);
    v67 = v66;
    v21 = *(_OWORD *)(MEMORY[0x1E0CA2E90] + 48);
    *(_OWORD *)&buf[32] = *(_OWORD *)(MEMORY[0x1E0CA2E90] + 32);
    v72 = v21;
    v73[0] = *(_QWORD *)(MEMORY[0x1E0CA2E90] + 64);
    v22 = *(_OWORD *)(MEMORY[0x1E0CA2E90] + 16);
    *(_OWORD *)buf = *MEMORY[0x1E0CA2E90];
    *(_OWORD *)&buf[16] = v22;
    extraColumnsOnRight = v66;
    extraRowsOnBottom = v68;
    CMTimeAdd((CMTime *)&buf[24], &extraColumnsOnRight, &extraRowsOnBottom);
    extraColumnsOnRight = *(CMTime *)&buf[24];
    CMSampleBufferSetOutputPresentationTimeStamp(cf, &extraColumnsOnRight);
    extraColumnsOnRight = *(CMTime *)&buf[24];
    v23 = CMTimeGetSeconds(&extraColumnsOnRight);
    extraColumnsOnRight = v67;
    v24 = CMTimeGetSeconds(&extraColumnsOnRight);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v25 = v23 - v24;
      v26 = VRTraceErrorLogLevelToCSTR();
      v27 = *MEMORY[0x1E0CF2758];
      v28 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
        {
          *(CMTime *)buf = v66;
          v29 = CMTimeGetSeconds((CMTime *)buf);
          *(CMTime *)buf = v66;
          v30 = CMTimeGetSeconds((CMTime *)buf);
          *(_DWORD *)buf = 136316418;
          *(_QWORD *)&buf[4] = v26;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VCScreenCapture_performIdleTimeAdjustments";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 437;
          *(_WORD *)&buf[28] = 2048;
          *(Float64 *)&buf[30] = v29;
          *(_WORD *)&buf[38] = 2048;
          *(double *)&buf[40] = v25 + v30;
          LOWORD(v72) = 2048;
          *(double *)((char *)&v72 + 2) = v25;
          _os_log_impl(&dword_1D8A54000, v27, OS_LOG_TYPE_DEFAULT, "VCScreenCapture [%s] %s:%d Idle frame, moving time forward. BeforeTime=%f, AfterTime=%f, Delta=%f ", buf, 0x3Au);
        }
      }
      else if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
      {
        *(CMTime *)buf = v66;
        v62 = CMTimeGetSeconds((CMTime *)buf);
        *(CMTime *)buf = v66;
        v63 = CMTimeGetSeconds((CMTime *)buf);
        *(_DWORD *)buf = 136316418;
        *(_QWORD *)&buf[4] = v26;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VCScreenCapture_performIdleTimeAdjustments";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 437;
        *(_WORD *)&buf[28] = 2048;
        *(Float64 *)&buf[30] = v62;
        *(_WORD *)&buf[38] = 2048;
        *(double *)&buf[40] = v25 + v63;
        LOWORD(v72) = 2048;
        *(double *)((char *)&v72 + 2) = v25;
        _os_log_debug_impl(&dword_1D8A54000, v27, OS_LOG_TYPE_DEBUG, "VCScreenCapture [%s] %s:%d Idle frame, moving time forward. BeforeTime=%f, AfterTime=%f, Delta=%f ", buf, 0x3Au);
      }
    }
    CMSampleBufferGetOutputPresentationTimeStamp((CMTime *)buf, cf);
    v66 = *(CMTime *)buf;
    *(_BYTE *)(a1 + 486) = 1;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v33 = VRTraceErrorLogLevelToCSTR();
    v34 = *MEMORY[0x1E0CF2758];
    v35 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
      {
        *(CMTime *)buf = v66;
        v36 = CMTimeGetSeconds((CMTime *)buf);
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)&buf[4] = v33;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VCScreenCapture_performIdleTimeAdjustments";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 442;
        *(_WORD *)&buf[28] = 2048;
        *(Float64 *)&buf[30] = v36;
        *(_WORD *)&buf[38] = 2048;
        *(double *)&buf[40] = v19;
        _os_log_impl(&dword_1D8A54000, v34, OS_LOG_TYPE_DEFAULT, "VCScreenCapture [%s] %s:%d Non idle frame. PresentationTime=%f, interArrivalTime=%f ", buf, 0x30u);
      }
    }
    else if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
    {
      *(CMTime *)buf = v66;
      v42 = CMTimeGetSeconds((CMTime *)buf);
      *(_DWORD *)buf = 136316162;
      *(_QWORD *)&buf[4] = v33;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "_VCScreenCapture_performIdleTimeAdjustments";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 442;
      *(_WORD *)&buf[28] = 2048;
      *(Float64 *)&buf[30] = v42;
      *(_WORD *)&buf[38] = 2048;
      *(double *)&buf[40] = v19;
      _os_log_debug_impl(&dword_1D8A54000, v34, OS_LOG_TYPE_DEBUG, "VCScreenCapture [%s] %s:%d Non idle frame. PresentationTime=%f, interArrivalTime=%f ", buf, 0x30u);
    }
  }
  extraRowsOnBottom = v66;
  *(_OWORD *)buf = *(_OWORD *)(a1 + 396);
  *(_QWORD *)&buf[16] = *(_QWORD *)(a1 + 412);
  extraColumnsOnRight = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68];
  v37 = CMTimeCompare((CMTime *)buf, &extraColumnsOnRight);
  v32 = 1;
  if (!v14)
  {
    if (v37)
    {
      if (v19 < 0.00833333333)
      {
        if (*(_BYTE *)(a1 + 486))
        {
          *(_BYTE *)(a1 + 486) = 0;
          v32 = 0;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            v38 = VRTraceErrorLogLevelToCSTR();
            v39 = *MEMORY[0x1E0CF2758];
            v40 = *MEMORY[0x1E0CF2758];
            if (*MEMORY[0x1E0CF2748])
            {
              v32 = 0;
              if (!os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
                goto LABEL_41;
              *(CMTime *)buf = extraRowsOnBottom;
              v41 = CMTimeGetSeconds((CMTime *)buf);
              *(_DWORD *)buf = 136316162;
              *(_QWORD *)&buf[4] = v38;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_VCScreenCapture_validateFrameTime";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 400;
              *(_WORD *)&buf[28] = 2048;
              *(Float64 *)&buf[30] = v41;
              *(_WORD *)&buf[38] = 2048;
              *(double *)&buf[40] = v19;
              _os_log_impl(&dword_1D8A54000, v39, OS_LOG_TYPE_DEFAULT, "VCScreenCapture [%s] %s:%d First non idle frame received within 1/120 sec of the last idle frame, not adding frame capture signpost. PresentationTime=%f, interArrivalTime=%f ", buf, 0x30u);
            }
            else if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
            {
              *(CMTime *)buf = extraRowsOnBottom;
              v64 = CMTimeGetSeconds((CMTime *)buf);
              *(_DWORD *)buf = 136316162;
              *(_QWORD *)&buf[4] = v38;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_VCScreenCapture_validateFrameTime";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 400;
              *(_WORD *)&buf[28] = 2048;
              *(Float64 *)&buf[30] = v64;
              *(_WORD *)&buf[38] = 2048;
              *(double *)&buf[40] = v19;
              _os_log_debug_impl(&dword_1D8A54000, v39, OS_LOG_TYPE_DEBUG, "VCScreenCapture [%s] %s:%d First non idle frame received within 1/120 sec of the last idle frame, not adding frame capture signpost. PresentationTime=%f, interArrivalTime=%f ", buf, 0x30u);
            }
            v32 = 0;
          }
        }
      }
    }
  }
LABEL_41:
  *(CMTime *)buf = extraRowsOnBottom;
  extraColumnsOnRight = *(CMTime *)(a1 + 396);
  if (CMTimeCompare((CMTime *)buf, &extraColumnsOnRight) < 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v43 = VRTraceErrorLogLevelToCSTR();
      v44 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(CMTime *)buf = extraRowsOnBottom;
        v45 = CMTimeGetSeconds((CMTime *)buf);
        *(_OWORD *)buf = *(_OWORD *)(a1 + 396);
        *(_QWORD *)&buf[16] = *(_QWORD *)(a1 + 412);
        v46 = CMTimeGetSeconds((CMTime *)buf);
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)&buf[4] = v43;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VCScreenCapture_validateFrameTime";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 410;
        *(_WORD *)&buf[28] = 2048;
        *(Float64 *)&buf[30] = v45;
        *(_WORD *)&buf[38] = 2048;
        *(Float64 *)&buf[40] = v46;
        _os_log_impl(&dword_1D8A54000, v44, OS_LOG_TYPE_DEFAULT, "VCScreenCapture [%s] %s:%d Frame PresentationTime %f going backwards with respect to previous frame PresentationTime %f. Dropping frame and not adding frame capture signpost.", buf, 0x30u);
      }
    }
    v32 = 0;
    v31 = 1;
    if (!cf)
      goto LABEL_103;
  }
  else
  {
    v31 = 0;
    if (!cf)
      goto LABEL_103;
  }
LABEL_48:
  v47 = *(_DWORD *)(a1 + 480);
  if (v47 == 2)
  {
    v49 = 2 * a3;
    if (2 * a3 != 14)
    {
      if (v49 != 8)
      {
        if (v49 == 6)
          goto LABEL_74;
        goto LABEL_75;
      }
LABEL_73:
      v55 = 3;
      goto LABEL_84;
    }
LABEL_76:
    v55 = 2;
    goto LABEL_84;
  }
  if (v47 == 3)
  {
    v48 = 2 * a3;
    if (2 * a3 != 14)
    {
      if (v48 != 8)
      {
        if (v48 == 6)
          goto LABEL_76;
        goto LABEL_73;
      }
LABEL_74:
      v55 = 1;
      goto LABEL_84;
    }
LABEL_75:
    v55 = 0;
    goto LABEL_84;
  }
  if (!*(_BYTE *)(a1 + 485))
  {
    v50 = CVPixelBufferGetWidth(v12);
    if (vabds_f32((float)(v50 / CVPixelBufferGetHeight(v12)), (float)*(int *)(a1 + 456) / (float)*(int *)(a1 + 460)) > 0.0001)
    {
      *(_BYTE *)(a1 + 484) = 1;
      *(_BYTE *)(a1 + 485) = 1;
    }
  }
  if (*(_BYTE *)(a1 + 484))
  {
    CFRelease(cf);
    ResizeFrame = VCMediaRecorderUtil_CreateResizeFrame(v12, *(OpaqueVTPixelTransferSession **)(a1 + 432), *(CVPixelBufferPoolRef *)(a1 + 424));
    *(CMTime *)buf = v66;
    cf = createSampleBufferWithPixelBuffer(ResizeFrame, (__int128 *)buf);
    CVPixelBufferRelease(ResizeFrame);
    if (!cf)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCScreenCapture_handleFrameInternal_cold_5();
      }
      goto LABEL_115;
    }
  }
  v52 = CVPixelBufferGetWidth(v12);
  v53 = CVPixelBufferGetHeight(v12);
  v54 = 2 * a3;
  if (v52 >= v53)
  {
    switch(v54)
    {
      case 14:
        goto LABEL_74;
      case 8:
        goto LABEL_75;
      case 6:
        goto LABEL_73;
    }
    goto LABEL_76;
  }
  if (v54 == 14)
  {
    v55 = 2;
  }
  else if (v54 == 8)
  {
    v55 = 3;
  }
  else
  {
    v55 = v54 == 6;
  }
  extraRowsOnBottom.value = 0xAAAAAAAAAAAAAAAALL;
  if (!CVPixelBufferPoolCreatePixelBuffer((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *(CVPixelBufferPoolRef *)(a1 + 448), (CVPixelBufferRef *)&extraRowsOnBottom))
  {
    MEMORY[0x1DF087C00](*(_QWORD *)(a1 + 440), v12, extraRowsOnBottom.value);
    memset(buf, 170, 24);
    CMSampleBufferGetOutputPresentationTimeStamp((CMTime *)buf, cf);
    CFRelease(cf);
    extraColumnsOnRight = *(CMTime *)buf;
    cf = createSampleBufferWithPixelBuffer((__CVBuffer *)extraRowsOnBottom.value, (__int128 *)&extraColumnsOnRight.value);
    CVBufferRelease((CVBufferRef)extraRowsOnBottom.value);
    if (cf)
      goto LABEL_84;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCScreenCapture_handleFrameInternal_cold_1();
    }
LABEL_115:
    cf = 0;
    goto LABEL_103;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCScreenCapture_handleFrameInternal_cold_4();
  }
LABEL_84:
  if (*(_BYTE *)(a1 + 376) && (a4 & 1) == 0)
  {
    v56 = *(const void **)(a1 + 384);
    if (v56)
      CFRelease(v56);
    if (cf)
      v57 = CFRetain(cf);
    else
      v57 = 0;
    *(_QWORD *)(a1 + 384) = v57;
    *(_DWORD *)(a1 + 392) = a3;
    *(_BYTE *)(a1 + 377) = 0;
  }
  IOSurface = CVPixelBufferGetIOSurface(v12);
  if (!v32 || !IOSurface || v14)
    goto LABEL_99;
  IOSurfaceGetID(IOSurface);
  IOSurfaceGetIndexedTimestamp();
  IOSurfaceGetIndexedTimestamp();
  *(CMTime *)buf = v66;
  CMTimeGetSeconds((CMTime *)buf);
  kdebug_trace();
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (FigCFDictionarySetInt32())
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCScreenCapture_handleFrameInternal_cold_3();
    }
  }
  else
  {
    if (!FigCFDictionarySetInt64())
    {
      CMSetAttachments(cf, Mutable, 0);
      if (Mutable)
        CFRelease(Mutable);
LABEL_99:
      if (!v31)
      {
        if ((a4 & 1) == 0)
          VCScreenCapture_attachUpdateWindowToPixelBuffer(v12);
        v60 = *(_OWORD *)&v66.value;
        *(_OWORD *)(a1 + 396) = *(_OWORD *)&v66.value;
        epoch = v66.epoch;
        *(_QWORD *)(a1 + 412) = v66.epoch;
        extraColumnsOnRight.value = 0x3AAAA0000;
        extraColumnsOnRight.timescale = -1431699456;
        extraColumnsOnRight.flags = v55;
        LODWORD(extraColumnsOnRight.epoch) = -1431655766;
        LOBYTE(extraColumnsOnRight.epoch) = v55 | 0x90;
        *(_OWORD *)buf = v60;
        *(_QWORD *)&buf[16] = epoch;
        VCVideoCapture_DistributeVideoFrame(a1, (uint64_t)cf, (__int128 *)buf, (uint64_t)&extraColumnsOnRight);
        ++*(_DWORD *)(a1 + 472);
      }
      goto LABEL_103;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCScreenCapture_handleFrameInternal_cold_2();
    }
  }
LABEL_103:
  if (cf)
    CFRelease(cf);
}

uint64_t VCScreenCapture_attachUpdateWindowToPixelBuffer(__CVBuffer *a1)
{
  const __CFArray *Attachment;
  CFDictionaryRef DictionaryRepresentation;
  CFMutableArrayRef v4;
  CFMutableArrayRef Mutable;
  double Width;
  double Height;
  int ErrorLogLevelForModule;
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  CFNumberRef v12;
  uint64_t v13;
  int v15;
  uint64_t v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  double v22;
  __int16 v23;
  double v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  uint64_t v28;
  uint64_t v29;
  CGRect v30;

  v29 = *MEMORY[0x1E0C80C00];
  Attachment = (const __CFArray *)CVBufferGetAttachment(a1, CFSTR("FVDWindowRectangles"), 0);
  if (Attachment && CFArrayGetCount(Attachment))
  {
    DictionaryRepresentation = 0;
    v4 = 0;
    goto LABEL_13;
  }
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  if (Mutable)
  {
    v4 = Mutable;
    Width = (double)CVPixelBufferGetWidth(a1);
    Height = (double)CVPixelBufferGetHeight(a1);
    v30.origin.x = 0.0;
    v30.origin.y = 0.0;
    v30.size.width = Width;
    v30.size.height = Height;
    DictionaryRepresentation = CGRectCreateDictionaryRepresentation(v30);
    ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    if (!DictionaryRepresentation)
    {
      v13 = 2148073475;
      if (ErrorLogLevelForModule >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCScreenCapture_attachUpdateWindowToPixelBuffer_cold_2();
      }
      v12 = 0;
LABEL_21:
      CFRelease(v4);
LABEL_22:
      if (v12)
        CFRelease(v12);
      return v13;
    }
    if (ErrorLogLevelForModule >= 8)
    {
      v9 = VRTraceErrorLogLevelToCSTR();
      v10 = *MEMORY[0x1E0CF2758];
      v11 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          v15 = 136316674;
          v16 = v9;
          v17 = 2080;
          v18 = "VCScreenCapture_attachUpdateWindowToPixelBuffer";
          v19 = 1024;
          v20 = 466;
          v21 = 2048;
          v22 = Width;
          v23 = 2048;
          v24 = Height;
          v25 = 2048;
          v26 = 0;
          v27 = 2048;
          v28 = 0;
          _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, "VCScreenCapture [%s] %s:%d visibleRect=%.2fx%.2f@(%.2f, %.2f)", (uint8_t *)&v15, 0x44u);
        }
      }
      else if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        v15 = 136316674;
        v16 = v9;
        v17 = 2080;
        v18 = "VCScreenCapture_attachUpdateWindowToPixelBuffer";
        v19 = 1024;
        v20 = 466;
        v21 = 2048;
        v22 = Width;
        v23 = 2048;
        v24 = Height;
        v25 = 2048;
        v26 = 0;
        v27 = 2048;
        v28 = 0;
        _os_log_debug_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEBUG, "VCScreenCapture [%s] %s:%d visibleRect=%.2fx%.2f@(%.2f, %.2f)", (uint8_t *)&v15, 0x44u);
      }
    }
    CFArrayAppendValue(v4, DictionaryRepresentation);
    CVBufferSetAttachment(a1, CFSTR("FVDWindowRectangles"), v4, kCVAttachmentMode_ShouldPropagate);
LABEL_13:
    if (CVBufferGetAttachment(a1, CFSTR("FVDWindowScaleFactor"), 0))
    {
      v12 = 0;
    }
    else
    {
      v15 = 1;
      v12 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &v15);
      if (!v12)
      {
        v13 = 2148073475;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCScreenCapture_attachUpdateWindowToPixelBuffer_cold_3();
        }
LABEL_18:
        if (DictionaryRepresentation)
          CFRelease(DictionaryRepresentation);
        if (!v4)
          goto LABEL_22;
        goto LABEL_21;
      }
      CVBufferSetAttachment(a1, CFSTR("FVDWindowScaleFactor"), v12, kCVAttachmentMode_ShouldPropagate);
    }
    v13 = 0;
    goto LABEL_18;
  }
  v13 = 2148073475;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCScreenCapture_attachUpdateWindowToPixelBuffer_cold_1();
  }
  return v13;
}

uint64_t createPixelBufferPool(CVPixelBufferPoolRef *a1, uint64_t a2, uint64_t a3)
{
  id v6;
  void *v7;
  id v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const __CFDictionary *v12;
  uint64_t v13;

  v6 = objc_alloc(MEMORY[0x1E0C99D80]);
  v7 = (void *)objc_msgSend(v6, "initWithObjectsAndKeys:", MEMORY[0x1E0C9AAB0], *MEMORY[0x1E0CBC018], CFSTR("AVConference:ScreenCaptureResize"), *MEMORY[0x1E0CBC048], 0);
  v8 = objc_alloc(MEMORY[0x1E0C99D80]);
  v9 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", a2);
  v10 = *MEMORY[0x1E0CA90E0];
  v11 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", a3);
  v12 = (const __CFDictionary *)objc_msgSend(v8, "initWithObjectsAndKeys:", v9, v10, v11, *MEMORY[0x1E0CA8FD8], &unk_1E9EF4208, *MEMORY[0x1E0CA9040], v7, *MEMORY[0x1E0CA8FF0], 0);
  v13 = CVPixelBufferPoolCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v12, a1);

  return v13;
}

void _VCScreenCapture_handleFrame(uint64_t a1, opaqueCMSampleBuffer *a2, int a3)
{
  _VCScreenCapture_handleFrameInternal(a1, a2, a3, 0);
}

uint64_t _VCScreenCapture_clearScreenProc(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  pthread_cond_t *v4;
  pthread_mutex_t *v5;
  uint64_t v6;
  NSObject *v7;
  unint64_t v8;
  uint64_t v9;
  NSObject *v10;
  timespec v12;
  timeval v13;
  uint8_t buf[4];
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v13.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v13.tv_usec = 0xAAAAAAAAAAAAAAAALL;
  v12.tv_sec = 0;
  v12.tv_nsec = 0;
  pthread_setname_np("com.apple.vcscreencapture.clearscreenproc");
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      v15 = v2;
      v16 = 2080;
      v17 = "_VCScreenCapture_clearScreenProc";
      v18 = 1024;
      v19 = 309;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, "VCScreenCapture [%s] %s:%d Clear Screen Thread Started", buf, 0x1Cu);
    }
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 312));
  if (objc_msgSend((id)a1, "isClearScreenThreadRunning"))
  {
    do
    {
      v4 = (pthread_cond_t *)(a1 + 248);
      v5 = (pthread_mutex_t *)(a1 + 312);
      if (*(_BYTE *)(a1 + 420))
      {
        pthread_cond_timedwait(v4, v5, &v12);
      }
      else
      {
        pthread_cond_wait(v4, v5);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v6 = VRTraceErrorLogLevelToCSTR();
          v7 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315650;
            v15 = v6;
            v16 = 2080;
            v17 = "_VCScreenCapture_clearScreenProc";
            v18 = 1024;
            v19 = 319;
            _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, "VCScreenCapture [%s] %s:%d Clear Screen Signalled", buf, 0x1Cu);
          }
        }
        gettimeofday(&v13, 0);
        v12.tv_sec = v13.tv_sec;
        v12.tv_nsec = 1000 * v13.tv_usec;
      }
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 312));
      objc_msgSend((id)a1, "processAndSendIdleBlackFrame");
      v8 = v12.tv_nsec + 1000000000 * v12.tv_sec + 33333333;
      v12.tv_sec = v8 / 0x3B9ACA00;
      v12.tv_nsec = v8 % 0x3B9ACA00;
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 312));
    }
    while ((objc_msgSend((id)a1, "isClearScreenThreadRunning") & 1) != 0);
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 312));
  if ((int)VRTraceGetErrorLogLevelForModule() > 6)
  {
    v9 = VRTraceErrorLogLevelToCSTR();
    v10 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      v15 = v9;
      v16 = 2080;
      v17 = "_VCScreenCapture_clearScreenProc";
      v18 = 1024;
      v19 = 334;
      _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, "VCScreenCapture [%s] %s:%d Clear Screen Thread Ended", buf, 0x1Cu);
    }
  }
  return a1;
}

uint64_t _VCScreenCapture_UpdateShouldClearScreen(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  const char *v7;
  uint64_t v8;
  int v10;
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 312));
  if (*(unsigned __int8 *)(a1 + 420) != a2)
  {
    *(_BYTE *)(a1 + 420) = a2;
    v4 = *(_QWORD *)(a1 + 160);
    if (v4)
      VCScreenCaptureManager_ScreenShareDidClearScreen(v4, a2);
    if (a2)
    {
      pthread_cond_signal((pthread_cond_t *)(a1 + 248));
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v5 = VRTraceErrorLogLevelToCSTR();
        v6 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v10 = 136315650;
          v11 = v5;
          v12 = 2080;
          v13 = "_VCScreenCapture_UpdateShouldClearScreen";
          v14 = 1024;
          v15 = 347;
          v7 = "VCScreenCapture [%s] %s:%d Enter Clear Screen";
LABEL_11:
          _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)&v10, 0x1Cu);
        }
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v8 = VRTraceErrorLogLevelToCSTR();
      v6 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v10 = 136315650;
        v11 = v8;
        v12 = 2080;
        v13 = "_VCScreenCapture_UpdateShouldClearScreen";
        v14 = 1024;
        v15 = 349;
        v7 = "VCScreenCapture [%s] %s:%d Exit Clear Screen";
        goto LABEL_11;
      }
    }
  }
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 312));
}

_OWORD *VCAudioDucker_Allocate(__int128 *a1)
{
  _OWORD *v2;
  _OWORD *v3;
  __int128 v4;
  __int128 v5;

  v2 = malloc_type_calloc(1uLL, 0x38uLL, 0x102004047CAF6D5uLL);
  v3 = v2;
  if (v2)
  {
    v4 = *a1;
    v5 = a1[2];
    v2[1] = a1[1];
    v2[2] = v5;
    *v2 = v4;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioDucker_Allocate_cold_1();
  }
  return v3;
}

void VCAudioDucker_Destroy(void **a1)
{
  void *v2;

  if (a1)
  {
    v2 = *a1;
    *a1 = 0;
    if (v2)
      free(v2);
  }
}

OpaqueAudioComponentInstance *VCAudioDucker_Start(AudioComponentInstance *a1)
{
  AudioUnit *v2;
  OSStatus v3;
  OSStatus v4;
  AudioUnitElement v5;
  char v6;
  char v7;
  OSStatus v8;
  OpaqueAudioComponentInstance *result;
  OSStatus v10;
  uint64_t v11;
  NSObject *v12;
  const char *v13;
  OSStatus v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  OSStatus v23;
  __int16 v24;
  AudioUnitElement v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = (OpaqueAudioComponentInstance *)os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!(_DWORD)result)
        return result;
      VCAudioDucker_Start_cold_1();
    }
    return 0;
  }
  v2 = a1 + 6;
  if (!VCAudioUnit_NewInstance(a1 + 6, 0x6479646Bu))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = (OpaqueAudioComponentInstance *)os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!(_DWORD)result)
        return result;
      VCAudioDucker_Start_cold_15();
    }
    return 0;
  }
  v3 = AudioUnitSetProperty(a1[6], 0xEu, 0, 0, a1 + 5, 4u);
  if (v3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioDucker_Start_cold_14();
    }
LABEL_33:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioDucker_Start_cold_13();
    }
    goto LABEL_36;
  }
  do
  {
    v4 = AudioUnitSetProperty(a1[6], 8u, 1u, v3, a1, 0x28u);
    if (v4)
    {
      v10 = v4;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v11 = VRTraceErrorLogLevelToCSTR();
        v12 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v16 = 136316162;
          v17 = v11;
          v18 = 2080;
          v19 = "_VCAudioDucker_SetProperties";
          v20 = 1024;
          v21 = 89;
          v22 = 1024;
          v23 = v10;
          v24 = 1024;
          v25 = v3;
          v13 = " [%s] %s:%d AudioUnitSetProperty kAudioUnitProperty_StreamFormat for kAudioUnitScope_Input err=%d inputNum=%d";
LABEL_75:
          _os_log_error_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_ERROR, v13, (uint8_t *)&v16, 0x28u);
        }
      }
      goto LABEL_33;
    }
    ++v3;
  }
  while (v3 != 5);
  v5 = 0;
  v6 = 1;
  do
  {
    v7 = v6;
    v8 = AudioUnitSetProperty(a1[6], 8u, 2u, v5, a1, 0x28u);
    if (v8)
    {
      v14 = v8;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v15 = VRTraceErrorLogLevelToCSTR();
        v12 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v16 = 136316162;
          v17 = v15;
          v18 = 2080;
          v19 = "_VCAudioDucker_SetProperties";
          v20 = 1024;
          v21 = 94;
          v22 = 1024;
          v23 = v14;
          v24 = 1024;
          v25 = v5;
          v13 = " [%s] %s:%d AudioUnitSetProperty kAudioUnitProperty_StreamFormat for kAudioUnitScope_Output err=%d outputNum=%d";
          goto LABEL_75;
        }
      }
      goto LABEL_33;
    }
    v6 = 0;
    v5 = 1;
  }
  while ((v7 & 1) != 0);
  if (AudioUnitSetParameter(*v2, 2u, 0, 0, -15.0, 0))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioDucker_Start_cold_12();
    }
    goto LABEL_68;
  }
  if (AudioUnitSetParameter(*v2, 4u, 0, 0, -32.0, 0))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioDucker_Start_cold_11();
    }
    goto LABEL_68;
  }
  if (AudioUnitSetParameter(*v2, 5u, 0, 0, -30.0, 0))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioDucker_Start_cold_10();
    }
    goto LABEL_68;
  }
  if (AudioUnitSetParameter(*v2, 7u, 0, 0, -30.0, 0))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioDucker_Start_cold_9();
    }
    goto LABEL_68;
  }
  if (AudioUnitSetParameter(*v2, 8u, 0, 0, 0.0, 0))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioDucker_Start_cold_8();
    }
    goto LABEL_68;
  }
  if (AudioUnitSetParameter(*v2, 0xDu, 0, 0, 0.15, 0))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioDucker_Start_cold_7();
    }
    goto LABEL_68;
  }
  if (AudioUnitSetParameter(*v2, 0xEu, 0, 0, 0.8, 0))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioDucker_Start_cold_6();
    }
    goto LABEL_68;
  }
  if (AudioUnitSetParameter(*v2, 0xFu, 0, 0, 1.3, 0))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioDucker_Start_cold_5();
    }
    goto LABEL_68;
  }
  if (AudioUnitSetParameter(*v2, 0x10u, 0, 0, 1.0, 0))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioDucker_Start_cold_4();
    }
LABEL_68:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioDucker_Start_cold_3();
    }
    goto LABEL_36;
  }
  if (!AudioUnitInitialize(*v2))
    return (OpaqueAudioComponentInstance *)1;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioDucker_Start_cold_2();
  }
LABEL_36:
  result = *v2;
  if (*v2)
  {
    AudioComponentInstanceDispose(result);
    result = 0;
    *v2 = 0;
  }
  return result;
}

void VCAudioDucker_Stop(uint64_t a1)
{
  OpaqueAudioComponentInstance *v2;

  if (a1)
  {
    v2 = *(OpaqueAudioComponentInstance **)(a1 + 48);
    if (v2)
    {
      AudioComponentInstanceDispose(v2);
      *(_QWORD *)(a1 + 48) = 0;
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioDucker_Stop_cold_1();
  }
}

BOOL VCAudioDucker_Process(UInt64 a1, uint64_t a2, uint64_t a3)
{
  UInt32 SampleCount;
  __int128 v7;
  OSStatus v8;
  _BOOL8 v9;
  uint64_t v10;
  NSObject *v11;
  AudioUnitRenderActionFlags ioActionFlags;
  AudioBufferList *ioOutputBufferLists[2];
  AudioBufferList *inInputBufferLists[3];
  AudioBufferList *AudioBufferList;
  uint64_t v17;
  AudioTimeStamp inTimeStamp;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (a1 && a2 && a3)
  {
    ioActionFlags = 512;
    SampleCount = VCAudioBufferList_GetSampleCount(a2);
    inTimeStamp.mSampleTime = NAN;
    inTimeStamp.mHostTime = 0xAAAAAAAAAAAAAAAALL;
    inTimeStamp.mRateScalar = NAN;
    *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&inTimeStamp.mWordClockTime = v7;
    *(_OWORD *)&inTimeStamp.mSMPTETime.mType = v7;
    *(_QWORD *)&inTimeStamp.mFlags = 0xAAAAAAAAAAAAAAAALL;
    VCAudioBufferList_GetAudioTimestamp(a2, (uint64_t)&inTimeStamp);
    inInputBufferLists[0] = (AudioBufferList *)VCAudioBufferList_GetAudioBufferList(a2);
    inInputBufferLists[1] = 0;
    inInputBufferLists[2] = 0;
    AudioBufferList = (AudioBufferList *)VCAudioBufferList_GetAudioBufferList(a3);
    v17 = 0;
    ioOutputBufferLists[0] = inInputBufferLists[0];
    ioOutputBufferLists[1] = AudioBufferList;
    v8 = AudioUnitProcessMultiple(*(AudioUnit *)(a1 + 48), &ioActionFlags, &inTimeStamp, SampleCount, 5u, (const AudioBufferList **)inInputBufferLists, 2u, ioOutputBufferLists);
    v9 = v8 == 0;
    if (v8)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCAudioDucker_Process_cold_1();
      }
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v10 = VRTraceErrorLogLevelToCSTR();
      v11 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        LODWORD(inTimeStamp.mSampleTime) = 136316418;
        *(_QWORD *)((char *)&inTimeStamp.mSampleTime + 4) = v10;
        WORD2(inTimeStamp.mHostTime) = 2080;
        *(UInt64 *)((char *)&inTimeStamp.mHostTime + 6) = (UInt64)"VCAudioDucker_Process";
        HIWORD(inTimeStamp.mRateScalar) = 1024;
        LODWORD(inTimeStamp.mWordClockTime) = 177;
        WORD2(inTimeStamp.mWordClockTime) = 2048;
        *(UInt64 *)((char *)&inTimeStamp.mWordClockTime + 6) = a1;
        HIWORD(inTimeStamp.mSMPTETime.mCounter) = 2048;
        *(_QWORD *)&inTimeStamp.mSMPTETime.mType = a2;
        inTimeStamp.mSMPTETime.mHours = 2048;
        *(_QWORD *)&inTimeStamp.mSMPTETime.mMinutes = a3;
        _os_log_error_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_ERROR, " [%s] %s:%d invalid parameter, audioDucker=%p sampleBuffer=%p sysaSampleBuffer=%p", (uint8_t *)&inTimeStamp, 0x3Au);
      }
    }
    return 0;
  }
  return v9;
}

uint64_t RTPSendH263Packet(uint64_t a1, char a2, int a3, char a4, char a5, int a6, int a7, char a8, double a9, char a10, void *a11, signed int a12, _DWORD *a13, const void *a14, unsigned __int8 a15, int a16, int a17, unsigned __int8 a18, _DWORD *a19, int a20,uint64_t a21,int a22,uint64_t a23,uint64_t a24,__int128 *a25)
{
  uint64_t v25;
  uint64_t v35;
  unint64_t v36;
  int v37;
  int v39;
  uint64_t v40;

  v25 = a23;
  v40 = *MEMORY[0x1E0C80C00];
  v39 = -1431655766;
  if (a13)
  {
    *a13 = 0;
    v35 = CheckInHandleDebug();
    if (v35 == 0xFFFFFFFFLL)
    {
      VCMediaControlInfoDispose(a23);
      return 2147549190;
    }
    else if (v35)
    {
      v37 = a7;
      v36 = 2147549185;
      *(_WORD *)(v35 + 16) = *(_WORD *)(v35 + 16) & 0x80FF | ((a2 & 0x7F) << 8);
      if ((a2 & 0x7F) == 0x7E)
      {
        if (!a3)
        {
          if (a12 <= 1456)
          {
            LOBYTE(v39) = a10 & 7 | (8 * (a8 & 7));
            BYTE1(v39) = (32 * a4) | (16 * (a5 & 1));
            HIWORD(v39) = 0;
            v36 = SendRTP(a1, v35, a6, v37, &v39, 4u, a11, a12, a9, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22,
                    a23,
                    a24,
                    a25,
                    0,
                    0);
            v25 = 0;
          }
          else
          {
            v36 = 2147549198;
          }
        }
      }
      else
      {
        v36 = 2147549199;
      }
      VCMediaControlInfoDispose(v25);
      CheckOutHandleDebug();
    }
    else
    {
      VCMediaControlInfoDispose(a23);
      return 2147549186;
    }
  }
  else
  {
    v36 = 2147549185;
    VCMediaControlInfoDispose(a23);
  }
  return v36;
}

uint64_t RTPProcessH263Packet(uint64_t a1, int *a2, int *a3, _BYTE *a4, _BYTE *a5, CFAllocatorRef structureAllocator, CMBlockBufferRef *blockBufferOut)
{
  uint64_t v7;
  uint64_t *v8;
  _BYTE *v9;
  uint64_t v10;
  size_t v11;
  OpaqueCMBlockBuffer *v12;
  OpaqueCMBlockBuffer *v13;
  OSStatus v14;
  int v15;
  uint64_t v16;
  NSObject *v17;

  v7 = 2147549185;
  if (a1 && blockBufferOut)
  {
    v8 = (uint64_t *)(a1 + 152);
    if (!*(_QWORD *)(a1 + 152))
      return 2147549199;
    v9 = *(_BYTE **)(a1 + 160);
    if ((*v9 & 0xC0) == 0x80)
    {
      *a4 = (*v9 >> 3) & 7;
      *a5 = *v9 & 7;
      *a2 = v9[1] >> 5;
      *a3 = v9[4] >> 7;
      v10 = *v8;
      if ((unint64_t)*v8 <= 7)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            RTPProcessH263Packet_cold_3();
        }
        return 2147549199;
      }
      v11 = 8;
    }
    else
    {
      if ((*v9 & 0xC0) != 0)
        return 2147549200;
      *a4 = (*v9 >> 3) & 7;
      *a5 = *v9 & 7;
      *a2 = v9[1] >> 5;
      *a3 = (v9[1] >> 4) & 1;
      v10 = *v8;
      if ((unint64_t)*v8 <= 3)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            RTPProcessH263Packet_cold_1();
        }
        return 2147549199;
      }
      v11 = 4;
    }
    v12 = (OpaqueCMBlockBuffer *)(v10 - v11);
    v13 = (OpaqueCMBlockBuffer *)(*(_QWORD *)(a1 + 160) + v11);
    blockBufferOut[1] = v12;
    blockBufferOut[2] = v13;
    v14 = CMBlockBufferCreateWithBufferReference(structureAllocator, *(CMBlockBufferRef *)(a1 + 144), v11, (size_t)v12, 0, blockBufferOut);
    if (v14)
    {
      v15 = v14;
      v7 = 2147549187;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v16 = VRTraceErrorLogLevelToCSTR();
        v17 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          RTPProcessH263Packet_cold_2(v16, v15, v17);
      }
    }
    else
    {
      return 0;
    }
  }
  return v7;
}

uint64_t VCTimescale_InitializeTimescaleAlgo(int *a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, int a6)
{
  _DWORD *v12;
  int v13;
  uint64_t v14;
  NSObject *v15;
  _BOOL4 v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  NSObject *v21;
  _BOOL4 v22;
  uint64_t v23;
  NSObject *v24;
  int v25;
  _OWORD *v26;
  int v27;
  uint64_t (*v28)();
  uint64_t (*v29)();
  uint64_t (*v30)();
  uint64_t (*v31)();
  uint64_t (*v32)();
  uint64_t (*v33)();
  uint64_t (*v34)();
  uint64_t (*v35)();
  uint64_t v36;
  uint64_t v37;
  NSObject *v38;
  _BOOL8 v40;
  _BOOL8 BoolValueForKey;
  _OWORD *v42;
  uint64_t v43;
  NSObject *v44;
  int v45;
  const char *v46;
  int v48;
  uint64_t v49;
  __int16 v50;
  const char *v51;
  __int16 v52;
  int v53;
  __int16 v54;
  const char *v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v12 = a1 + 8675;
  v13 = HasMulticore();
  if (a4 < 5)
  {
    v18 = v13;
    v19 = a6;
    if (a4 >= 2)
    {
      v19 = a6;
      if (a6 == 1)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() < 5)
        {
          v19 = 0;
        }
        else
        {
          v20 = VRTraceErrorLogLevelToCSTR();
          v21 = *MEMORY[0x1E0CF2758];
          v22 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
          v19 = 0;
          if (v22)
          {
            v48 = 136315906;
            v49 = v20;
            v50 = 2080;
            v51 = "_VCTimescale_TimescaleEnablement";
            v52 = 1024;
            v53 = 46;
            v54 = 1024;
            LODWORD(v55) = a4;
            _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Disable WSOLA Timescale selected for channelCount=%d", (uint8_t *)&v48, 0x22u);
            v19 = 0;
            v17 = 0;
            if (!v18)
              goto LABEL_15;
LABEL_13:
            v17 = v19;
            goto LABEL_15;
          }
        }
      }
    }
    if (!v18)
      goto LABEL_14;
    goto LABEL_13;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() < 7)
  {
LABEL_14:
    v17 = 0;
    goto LABEL_15;
  }
  v14 = VRTraceErrorLogLevelToCSTR();
  v15 = *MEMORY[0x1E0CF2758];
  v16 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
  v17 = 0;
  if (v16)
  {
    v48 = 136315906;
    v49 = v14;
    v50 = 2080;
    v51 = "_VCTimescale_TimescaleEnablement";
    v52 = 1024;
    v53 = 44;
    v54 = 1024;
    LODWORD(v55) = a4;
    _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Timescale Disabled channelCount[%d]", (uint8_t *)&v48, 0x22u);
    goto LABEL_14;
  }
LABEL_15:
  *a1 = v17;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v23 = VRTraceErrorLogLevelToCSTR();
    v24 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v25 = *a1;
      v48 = 136315906;
      v49 = v23;
      v50 = 2080;
      v51 = "_VCTimescale_TimescaleEnablement";
      v52 = 1024;
      v53 = 51;
      v54 = 1024;
      LODWORD(v55) = v25;
      _os_log_impl(&dword_1D8A54000, v24, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Timescale algorithm selected is %d", (uint8_t *)&v48, 0x22u);
    }
  }
  *(_BYTE *)v12 = a4;
  v26 = malloc_type_malloc(0x40uLL, 0x80040A284212CuLL);
  *(_QWORD *)(v12 + 1) = v26;
  if (v26)
  {
    v27 = *a1 - 1;
    if (v27 >= 3)
    {
      v26[2] = 0u;
      v26[3] = 0u;
      *v26 = 0u;
      v26[1] = 0u;
      if (!**(_QWORD **)(v12 + 1))
      {
        v36 = 0;
LABEL_35:
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v43 = VRTraceErrorLogLevelToCSTR();
          v44 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v45 = *a1;
            if (*a1 == 1)
            {
              v46 = "WSOLA";
            }
            else
            {
              v46 = "PSOLA";
              if (v45 != 2 && v45 != 3)
                v46 = "Empty";
            }
            v48 = 136315906;
            v49 = v43;
            v50 = 2080;
            v51 = "VCTimescale_InitializeTimescaleAlgo";
            v52 = 1024;
            v53 = 127;
            v54 = 2080;
            v55 = v46;
            _os_log_impl(&dword_1D8A54000, v44, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d %s Timescale successfully initialized ", (uint8_t *)&v48, 0x26u);
          }
        }
        return v36;
      }
    }
    else
    {
      v28 = off_1E9E53CE8[v27];
      v29 = off_1E9E53D00[v27];
      v30 = off_1E9E53D18[v27];
      v31 = off_1E9E53D30[v27];
      v32 = off_1E9E53D48[v27];
      v33 = off_1E9E53D60[v27];
      v34 = off_1E9E53D78[v27];
      v35 = off_1E9E53D90[v27];
      *(_QWORD *)v26 = v28;
      *((_QWORD *)v26 + 1) = v29;
      *((_QWORD *)v26 + 4) = v32;
      *((_QWORD *)v26 + 5) = v31;
      *((_QWORD *)v26 + 2) = v30;
      *((_QWORD *)v26 + 3) = v33;
      *((_QWORD *)v26 + 6) = v34;
      *((_QWORD *)v26 + 7) = v35;
    }
    v40 = a6 == 2 || (a6 & 0xFFFFFFFD) == 1;
    BoolValueForKey = VCDefaults_GetBoolValueForKey(CFSTR("audioTimescalingHysteresisEnabled"), v40);
    v36 = (**(uint64_t (***)(int *, uint64_t, uint64_t, uint64_t, _BOOL8))(v12 + 1))(a1, a2, a3, a5, BoolValueForKey);
    if ((v36 & 0x80000000) != 0)
    {
      v42 = *(_OWORD **)(v12 + 1);
      if (v42)
      {
        v42[2] = 0u;
        v42[3] = 0u;
        *v42 = 0u;
        v42[1] = 0u;
      }
    }
    goto LABEL_35;
  }
  v36 = 2147549187;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v37 = VRTraceErrorLogLevelToCSTR();
    v38 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCTimescale_InitializeTimescaleAlgo_cold_1(v37, v38);
  }
  return v36;
}

uint64_t VCTimescale_UpdateTimescaleHistoryBuffer(uint64_t result)
{
  uint64_t (*v1)(void);

  if (result)
  {
    v1 = *(uint64_t (**)(void))(*(_QWORD *)(result + 34704) + 24);
    if (v1)
    {
      if (*(_DWORD *)result)
        return v1();
    }
  }
  return result;
}

uint64_t VCTimescale_ActiveSpeechAdapt(uint64_t a1)
{
  uint64_t (*v1)(void);

  v1 = *(uint64_t (**)(void))(*(_QWORD *)(a1 + 34704) + 32);
  if (v1 && *(_DWORD *)a1)
    return v1();
  else
    return 0;
}

uint64_t VCTimescale_IsCompressionNeeded(uint64_t a1)
{
  uint64_t (*v1)(void);

  v1 = *(uint64_t (**)(void))(*(_QWORD *)(a1 + 34704) + 40);
  if (v1 && *(_DWORD *)a1)
    return v1();
  else
    return 0;
}

uint64_t VCTimescale_TailSize(uint64_t a1)
{
  uint64_t (*v1)(void);

  v1 = *(uint64_t (**)(void))(*(_QWORD *)(a1 + 34704) + 16);
  if (v1 && *(_DWORD *)a1)
    return v1();
  else
    return 0;
}

void VCTimescale_Finalize(uint64_t a1)
{
  _QWORD **v2;
  _QWORD *v3;
  void (*v4)(uint64_t);

  v2 = (_QWORD **)(a1 + 34704);
  v3 = *(_QWORD **)(a1 + 34704);
  if (v3)
  {
    v4 = (void (*)(uint64_t))v3[1];
    if (v4)
    {
      if (*(_DWORD *)a1)
      {
        v4(a1);
        v3 = *v2;
      }
    }
    free(v3);
    *v2 = 0;
  }
}

uint64_t VCTimescale_TailExtractAvailable(uint64_t a1)
{
  uint64_t (*v1)(void);

  v1 = *(uint64_t (**)(void))(*(_QWORD *)(a1 + 34704) + 48);
  if (v1 && *(_DWORD *)a1)
    return v1();
  else
    return 0;
}

uint64_t VCTimescale_WarpFrameSize(uint64_t a1)
{
  uint64_t (*v1)(void);

  v1 = *(uint64_t (**)(void))(*(_QWORD *)(a1 + 34704) + 56);
  if (v1 && *(_DWORD *)a1)
    return v1();
  else
    return 0;
}

uint64_t RTPSendH264Packet(uint64_t a1, char a2, unsigned int a3, int a4, int a5, void *a6, signed int a7, _DWORD *a8, double a9, const void *a10, unsigned __int8 a11, int a12, int a13, unsigned __int8 a14, _DWORD *a15, int a16, uint64_t a17, int a18, uint64_t a19, uint64_t a20,__int128 *a21,char a22,int a23)
{
  uint64_t v23;
  unint64_t v24;
  uint64_t v34;

  v23 = a19;
  v24 = 2147549198;
  if (a8)
  {
    *a8 = 0;
    v34 = CheckInHandleDebug();
    if (v34 == 0xFFFFFFFFLL)
    {
      VCMediaControlInfoDispose(a19);
      return 2147549190;
    }
    else if (v34)
    {
      if (a7 >= 1
        && ((*(_WORD *)(v34 + 16) = *(_WORD *)(v34 + 16) & 0x80FF | ((a2 & 0x7F) << 8), (a2 & 0x7F) == 0x7B)
         || (a2 & 0x7F) == 0x64))
      {
        if (a3 <= 1)
        {
          if (a7 < 0x5B5)
          {
            v24 = SendRTP(a1, v34, a4, a5, 0, 0, a6, a7, a9, a8, a10, a11, a12, a13, a14, a15, a16, a17, a18,
                    a19,
                    a20,
                    a21,
                    a22,
                    a23);
            v23 = 0;
          }
          else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              RTPSendH264Packet_cold_1();
          }
        }
        else
        {
          v24 = 2147549185;
        }
      }
      else
      {
        v24 = 2147549199;
      }
      VCMediaControlInfoDispose(v23);
      CheckOutHandleDebug();
    }
    else
    {
      VCMediaControlInfoDispose(a19);
      return 2147549186;
    }
  }
  else
  {
    VCMediaControlInfoDispose(a19);
    return 2147549185;
  }
  return v24;
}

uint64_t RTPProcessH264FragmentationHeader(uint64_t a1, int a2, int *a3, int *a4, _WORD *a5, _BYTE *a6, int *a7, int a8)
{
  int v13;
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  NSObject *v17;
  int v18;
  const char *v19;
  uint64_t v20;
  NSObject *v21;
  int v22;
  int v24;
  uint64_t v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  int v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if (a2 > 0)
  {
    v13 = *(_BYTE *)a1 & 0x1F;
    if (a7)
      *a7 = v13;
    if (a6)
      *a6 = 0;
    switch(v13)
    {
      case 25:
        if (a3)
          *a3 = 1;
        if (a4)
          *a4 = 1;
        v14 = 0;
        if (!a5 || !a6)
          goto LABEL_47;
        if (a2 < 3)
        {
          v14 = 2147549199;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              RTPProcessH264FragmentationHeader_cold_6();
          }
          goto LABEL_47;
        }
        *a5 = bswap32(*(unsigned __int16 *)(a1 + 1)) >> 16;
        *a6 = 1;
        if ((int)VRTraceGetErrorLogLevelForModule() < 8)
          goto LABEL_46;
        v15 = VRTraceErrorLogLevelToCSTR();
        v16 = *MEMORY[0x1E0CF2758];
        v17 = *MEMORY[0x1E0CF2758];
        if (!*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
            RTPProcessH264FragmentationHeader_cold_5();
          goto LABEL_46;
        }
        v14 = 0;
        if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          goto LABEL_47;
        v18 = (unsigned __int16)*a5;
        v24 = 136315906;
        v25 = v15;
        v26 = 2080;
        v27 = "RTPProcessH264FragmentationHeader";
        v28 = 1024;
        v29 = 197;
        v30 = 1024;
        v31 = v18;
        v19 = " [%s] %s:%d STAP-B Decoding order is %hu";
        break;
      case 29:
        _RTPProcessH264FragmentationHeaderStartEndBits(a1, a2, a3, a4);
        v14 = 0;
        if (!a5 || !a6)
          goto LABEL_47;
        if (a2 < 4)
        {
          v14 = 2147549199;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              RTPProcessH264FragmentationHeader_cold_4();
          }
          goto LABEL_47;
        }
        *a5 = bswap32(*(unsigned __int16 *)(a1 + 2)) >> 16;
        *a6 = 1;
        if ((int)VRTraceGetErrorLogLevelForModule() < 8)
          goto LABEL_46;
        v20 = VRTraceErrorLogLevelToCSTR();
        v16 = *MEMORY[0x1E0CF2758];
        v21 = *MEMORY[0x1E0CF2758];
        if (!*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
            RTPProcessH264FragmentationHeader_cold_3();
          goto LABEL_46;
        }
        v14 = 0;
        if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
          goto LABEL_47;
        v22 = (unsigned __int16)*a5;
        v24 = 136315906;
        v25 = v20;
        v26 = 2080;
        v27 = "RTPProcessH264FragmentationHeader";
        v28 = 1024;
        v29 = 180;
        v30 = 1024;
        v31 = v22;
        v19 = " [%s] %s:%d FU-B Decoding order is %hu";
        break;
      case 28:
        _RTPProcessH264FragmentationHeaderStartEndBits(a1, a2, a3, a4);
LABEL_46:
        v14 = 0;
        goto LABEL_47;
      default:
        if (a3)
          *a3 = 1;
        if (!a4)
          goto LABEL_46;
        v14 = 0;
        *a4 = 1;
LABEL_47:
        if (a6)
        {
          if (a8)
          {
            if (!*a6 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                RTPProcessH264FragmentationHeader_cold_2();
            }
          }
        }
        return v14;
    }
    _os_log_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEFAULT, v19, (uint8_t *)&v24, 0x22u);
    goto LABEL_46;
  }
  v14 = 2147549199;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      RTPProcessH264FragmentationHeader_cold_1();
  }
  return v14;
}

void _RTPProcessH264FragmentationHeaderStartEndBits(uint64_t a1, int a2, int *a3, int *a4)
{
  if (a2 > 1)
  {
    if (a3)
      *a3 = *(unsigned __int8 *)(a1 + 1) >> 7;
    if (a4)
      *a4 = (*(unsigned __int8 *)(a1 + 1) >> 6) & 1;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _RTPProcessH264FragmentationHeaderStartEndBits_cold_1();
  }
}

uint64_t RTPProcessH264Packet(uint64_t a1, uint64_t a2)
{
  _BYTE *v4;
  uint64_t appended;
  size_t v6;
  int v7;
  int v9;
  char *DataPointer;
  CMBlockBufferRef targetBBuf[2];

  targetBBuf[1] = *(CMBlockBufferRef *)MEMORY[0x1E0C80C00];
  v4 = *(_BYTE **)(a2 + 24);
  if (v4)
    *v4 = 0;
  appended = 2147549187;
  v6 = *(_QWORD *)(a1 + 8);
  if (!v6)
    return 2147549199;
  switch(**(_BYTE **)(a1 + 16) & 0x1F)
  {
    case 0x18:
      v7 = 0;
      return _RTPProcessSTAPPacket(a1, a2, v7);
    case 0x19:
      v7 = 1;
      return _RTPProcessSTAPPacket(a1, a2, v7);
    case 0x1C:
      v9 = 0;
      return _RTPProcessFUPacket(a1, a2, v9, **(_BYTE **)(a1 + 16));
    case 0x1D:
      v9 = 1;
      return _RTPProcessFUPacket(a1, a2, v9, **(_BYTE **)(a1 + 16));
    default:
      **(_BYTE **)a2 = 1;
      **(_BYTE **)(a2 + 8) = 1;
      targetBBuf[0] = 0;
      DataPointer = VCBlockBufferUtilities_CreateAndGetDataPointer(*(const __CFAllocator **)(a2 + 32), 0, 4uLL, *(const __CFAllocator **)(a2 + 40), 0, 0, 4uLL, 1u, targetBBuf);
      if (DataPointer)
      {
        *(_DWORD *)DataPointer = bswap32(v6);
        appended = CMBlockBufferAppendBufferReference(*(CMBlockBufferRef *)(a2 + 48), targetBBuf[0], 0, 4uLL, 0);
        if ((_DWORD)appended)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              RTPProcessH264Packet_cold_3();
          }
        }
        else
        {
          if (!CMBlockBufferAppendBufferReference(*(CMBlockBufferRef *)(a2 + 48), *(CMBlockBufferRef *)a1, 0, v6, 0))
            goto LABEL_14;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              RTPProcessH264Packet_cold_2();
          }
        }
        appended = 2147549187;
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          RTPProcessH264Packet_cold_1();
      }
LABEL_14:
      if (targetBBuf[0])
        CFRelease(targetBBuf[0]);
      break;
  }
  return appended;
}

uint64_t _RTPProcessSTAPPacket(uint64_t a1, uint64_t a2, int a3)
{
  unint64_t v3;
  uint64_t v6;
  unint64_t v7;
  _WORD *v8;
  unsigned __int16 **v9;
  _BYTE *v10;
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  int v14;
  unint64_t v15;
  BOOL v16;
  const __CFAllocator *v17;
  const __CFAllocator *v18;
  char *DataPointer;
  uint64_t v21;
  int ErrorLogLevelForModule;
  uint64_t v23;
  CMBlockBufferRef targetBBuf;
  uint8_t buf[4];
  uint64_t v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a1 + 8);
  targetBBuf = 0;
  if (v3)
  {
    v6 = 1;
    **(_BYTE **)a2 = 1;
    **(_BYTE **)(a2 + 8) = 1;
    v7 = v3 - 1;
    if (!a3)
      goto LABEL_13;
    if (v3 > 2)
    {
      v9 = (unsigned __int16 **)(a2 + 16);
      v8 = *(_WORD **)(a2 + 16);
      if (v8)
      {
        v10 = *(_BYTE **)(a2 + 24);
        if (v10)
        {
          *v8 = bswap32(*(unsigned __int16 *)(*(_QWORD *)(a1 + 16) + 1)) >> 16;
          *v10 = 1;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            v11 = VRTraceErrorLogLevelToCSTR();
            v12 = *MEMORY[0x1E0CF2758];
            v13 = *MEMORY[0x1E0CF2758];
            if (*MEMORY[0x1E0CF2748])
            {
              if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
              {
                v14 = **v9;
                *(_DWORD *)buf = 136315906;
                v26 = v11;
                v27 = 2080;
                v28 = "_RTPProcessSTAPPacket";
                v29 = 1024;
                v30 = 238;
                v31 = 1024;
                v32 = v14;
                _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d STAP-B Decoding order is %hu", buf, 0x22u);
              }
            }
            else if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
            {
              _RTPProcessSTAPPacket_cold_8();
            }
          }
        }
      }
      v7 = v3 - 3;
      v6 = 3;
LABEL_13:
      if (v7)
      {
        while (v7 != 1)
        {
          v15 = bswap32(*(unsigned __int16 *)(*(_QWORD *)(a1 + 16) + v6)) >> 16;
          v16 = v7 - 2 >= v15;
          v7 = v7 - 2 - v15;
          if (!v16)
          {
            v21 = 2147549199;
            ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
            if (ErrorLogLevelForModule >= 3)
            {
              v23 = VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                _RTPProcessSTAPPacket_cold_3(v23);
            }
            goto LABEL_24;
          }
          v17 = *(const __CFAllocator **)(a2 + 32);
          v18 = *(const __CFAllocator **)(a2 + 40);
          targetBBuf = 0;
          DataPointer = VCBlockBufferUtilities_CreateAndGetDataPointer(v17, 0, 4uLL, v18, 0, 0, 4uLL, 1u, &targetBBuf);
          if (!DataPointer)
          {
            v21 = 2147549187;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                _RTPProcessSTAPPacket_cold_4();
            }
            goto LABEL_24;
          }
          *(_DWORD *)DataPointer = bswap32(v15);
          if (CMBlockBufferAppendBufferReference(*(CMBlockBufferRef *)(a2 + 48), targetBBuf, 0, 4uLL, 0))
          {
            v21 = 2147549187;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                _RTPProcessSTAPPacket_cold_6();
            }
            goto LABEL_24;
          }
          if (CMBlockBufferAppendBufferReference(*(CMBlockBufferRef *)(a2 + 48), *(CMBlockBufferRef *)a1, v6 + 2, v15, 0))
          {
            v21 = 2147549187;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                _RTPProcessSTAPPacket_cold_5();
            }
            goto LABEL_24;
          }
          if (targetBBuf)
          {
            CFRelease(targetBBuf);
            targetBBuf = 0;
          }
          v6 += 2 + v15;
          if (!v7)
            goto LABEL_23;
        }
        v21 = 2147549199;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _RTPProcessSTAPPacket_cold_7();
        }
      }
      else
      {
LABEL_23:
        v21 = 0;
      }
      goto LABEL_24;
    }
    v21 = 2147549199;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _RTPProcessSTAPPacket_cold_2();
    }
  }
  else
  {
    v21 = 2147549199;
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      return v21;
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _RTPProcessSTAPPacket_cold_1();
  }
LABEL_24:
  if (targetBBuf)
    CFRelease(targetBBuf);
  return v21;
}

uint64_t _RTPProcessFUPacket(uint64_t a1, uint64_t a2, int a3, char a4)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v9;
  _BYTE *v10;
  unsigned __int8 v11;
  _WORD *v12;
  unsigned __int16 **v13;
  _BYTE *v14;
  uint64_t v15;
  NSObject *v16;
  NSObject *v17;
  int v18;
  int v19;
  size_t v20;
  char *DataPointer;
  OSStatus appended;
  CMBlockBufferRef targetBBuf;
  uint8_t buf[4];
  uint64_t v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 8);
  targetBBuf = 0;
  if (v4 <= 1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      return 2147549199;
    VRTraceErrorLogLevelToCSTR();
    v5 = 2147549199;
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _RTPProcessFUPacket_cold_1();
    return v5;
  }
  v9 = *(_QWORD *)(a1 + 16);
  v10 = *(_BYTE **)a2;
  if (a3)
  {
    *v10 = *(_BYTE *)(v9 + 1) >> 7;
    **(_BYTE **)(a2 + 8) = (*(_BYTE *)(v9 + 1) & 0x40) != 0;
    v11 = *(_BYTE *)(v9 + 1);
    v13 = (unsigned __int16 **)(a2 + 16);
    v12 = *(_WORD **)(a2 + 16);
    if (v12)
    {
      v14 = *(_BYTE **)(a2 + 24);
      if (v14)
      {
        *v12 = bswap32(*(unsigned __int16 *)(v9 + 2)) >> 16;
        *v14 = 1;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          v15 = VRTraceErrorLogLevelToCSTR();
          v16 = *MEMORY[0x1E0CF2758];
          v17 = *MEMORY[0x1E0CF2758];
          if (*MEMORY[0x1E0CF2748])
          {
            if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
            {
              v18 = **v13;
              *(_DWORD *)buf = 136315906;
              v26 = v15;
              v27 = 2080;
              v28 = "_RTPProcessFUPacket";
              v29 = 1024;
              v30 = 306;
              v31 = 1024;
              v32 = v18;
              _os_log_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d FU-B Decoding order is %hu", buf, 0x22u);
            }
          }
          else if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
          {
            _RTPProcessFUPacket_cold_5();
          }
        }
      }
    }
    v19 = -3;
    v20 = 4;
  }
  else
  {
    v11 = *(_BYTE *)(v9 + 1);
    *v10 = v11 >> 7;
    **(_BYTE **)(a2 + 8) = (v11 & 0x40) != 0;
    v19 = -1;
    v20 = 2;
  }
  if (!**(_BYTE **)a2)
    goto LABEL_20;
  DataPointer = VCBlockBufferUtilities_CreateAndGetDataPointer(*(const __CFAllocator **)(a2 + 32), 0, 5uLL, *(const __CFAllocator **)(a2 + 40), 0, 0, 5uLL, 1u, &targetBBuf);
  if (!DataPointer)
  {
    v5 = 2147549187;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _RTPProcessFUPacket_cold_3();
    }
    goto LABEL_21;
  }
  *(_DWORD *)DataPointer = bswap32(v19 + v4);
  DataPointer[4] = v11 & 0x1F | a4 & 0xE0;
  if (CMBlockBufferAppendBufferReference(*(CMBlockBufferRef *)(a2 + 48), targetBBuf, 0, 5uLL, 0))
  {
    v5 = 2147549187;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _RTPProcessFUPacket_cold_4();
    }
  }
  else
  {
LABEL_20:
    appended = CMBlockBufferAppendBufferReference(*(CMBlockBufferRef *)(a2 + 48), *(CMBlockBufferRef *)a1, v20, v4 - v20, 0);
    v5 = 0;
    if (appended)
    {
      v5 = 2147549187;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _RTPProcessFUPacket_cold_2();
      }
    }
  }
LABEL_21:
  if (targetBBuf)
    CFRelease(targetBBuf);
  return v5;
}

uint64_t _VCCannedVideoPacketSource_InjectionThread(uint64_t a1)
{
  unint64_t v1;
  uint64_t v2;
  OpaqueCMClock *HostTimeClock;
  id v5;
  double v6;
  double v7;
  double v8;
  __darwin_time_t tv_sec;
  __darwin_suseconds_t tv_usec;
  CMTimeValue value;
  int v12;
  double v13;
  double v14;
  int v15;
  unint64_t v16;
  double *v17;
  uint64_t v18;
  _BYTE *v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  id v24;
  unsigned int v25;
  void *v26;
  uint64_t v27;
  id v28;
  unsigned int v29;
  void *v30;
  uint64_t v31;
  unint64_t i;
  OpaqueCMClock *v33;
  id v34;
  unint64_t j;
  int ErrorLogLevelForModule;
  os_log_t *v38;
  pthread_mutex_t *v39;
  timeval v40;
  char v41;
  char v42;
  CMTime v43;
  _BYTE v44[8];
  unint64_t v45;
  unsigned __int8 v46;
  double v47[3];
  double v48;
  _BYTE v49[32];
  CFTypeRef cf;
  _BYTE v51[24];
  _BYTE v52[24];
  _BYTE v53[1420];
  _BYTE v54[4468];
  CMTime v55;
  double v56;
  int v57;
  double v58;
  uint64_t v59;

  v2 = MEMORY[0x1E0C80A78](a1);
  v59 = *MEMORY[0x1E0C80C00];
  v41 = 0;
  bzero(v44, 0x17B8uLL);
  v40.tv_sec = 0;
  *(_QWORD *)&v40.tv_usec = 0;
  gettimeofday(&v40, 0);
  setRealTimeConstraints(0.0);
  bzero(&v55, 0x17B8uLL);
  v42 = 0;
  do
  {
    _VCCannedVideoPacketSource_ReadPacketAndAllocateBlockBuffers(v2, (uint64_t)&v55, &v42);
    if (v42)
    {
      ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
      v38 = (os_log_t *)MEMORY[0x1E0CF2758];
      if (ErrorLogLevelForModule >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled(*v38, OS_LOG_TYPE_ERROR))
          _VCCannedVideoPacketSource_InjectionThread_cold_2();
      }
      objc_msgSend(*(id *)(v2 + 16), "seekToFileOffset:", 0);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled(*v38, OS_LOG_TYPE_ERROR))
          _VCCannedVideoPacketSource_InjectionThread_cold_1();
      }
      return 0;
    }
  }
  while (LOBYTE(v55.value) != 1 || v55.timescale != 0);
  LODWORD(v1) = v57;
  memset(&v43, 170, sizeof(v43));
  HostTimeClock = CMClockGetHostTimeClock();
  CMClockGetTime(&v43, HostTimeClock);
  v5 = +[VCCannedAVSync sharedCannedAVSync](VCCannedAVSync, "sharedCannedAVSync");
  VCCannedAVSync_SetBase((uint64_t)v5, (double)v43.value / (double)v43.timescale);
  v6 = (double)v1 / 90000.0;
  v7 = VCCannedAVSync_AddDrift((uint64_t)v5, v6);
  if (LOBYTE(v55.value) == 2)
  {
    v7 = NTPToMicro(*(uint64_t *)&v55.timescale);
    v8 = v7;
  }
  else
  {
    if (LOBYTE(v55.value) != 1)
      goto LABEL_13;
    if (v55.timescale == 1)
    {
      v8 = v56;
    }
    else
    {
      if (!v55.timescale)
      {
        v8 = v58;
        goto LABEL_16;
      }
LABEL_13:
      v8 = NAN;
    }
  }
LABEL_16:
  objc_msgSend(*(id *)(v2 + 16), "seekToFileOffset:", 0, v7);
  _VCCannedVideoPacketSource_ReadPacketAndAllocateBlockBuffers(v2, (uint64_t)v44, &v41);
  v39 = (pthread_mutex_t *)(v2 + 88);
  pthread_mutex_lock((pthread_mutex_t *)(v2 + 88));
  if (!*(_BYTE *)(v2 + 80))
  {
    tv_sec = v40.tv_sec;
    tv_usec = v40.tv_usec;
    while (1)
    {
      v43.value = 0xAAAAAAAAAAAAAAAALL;
      *(_QWORD *)&v43.timescale = 0xAAAAAAAAAAAAAAAALL;
      *(_QWORD *)&v55.timescale = 0;
      v55.value = 0;
      gettimeofday((timeval *)&v55, 0);
      value = tv_sec;
      do
      {
        while (1)
        {
          if (tv_usec <= 979999)
          {
            v12 = 20000;
          }
          else
          {
            tv_sec = ++value;
            v12 = -980000;
          }
          tv_usec += v12;
          v8 = v8 + 0.02;
          if (value == v55.value)
            break;
          if (value >= v55.value)
            goto LABEL_26;
        }
      }
      while (tv_usec < v55.timescale);
      value = v55.value;
LABEL_26:
      v43.value = value;
      *(_QWORD *)&v43.timescale = 1000 * tv_usec;
      if (pthread_cond_timedwait((pthread_cond_t *)(v2 + 152), v39, (const timespec *)&v43) == 60)
        break;
LABEL_86:
      if (*(_BYTE *)(v2 + 80))
        goto LABEL_87;
    }
    v13 = micro();
    while (2)
    {
      if (v44[0] == 2)
      {
        v14 = NTPToMicro(v45);
      }
      else
      {
        if (v44[0] != 1)
          goto LABEL_86;
        if ((_DWORD)v45 == 1)
        {
          v14 = v47[0];
        }
        else
        {
          if ((_DWORD)v45)
            goto LABEL_86;
          v14 = v48;
        }
      }
      if (v14 >= v8)
        goto LABEL_86;
      v15 = v44[0];
      if (v44[0] == 2)
      {
        v45 = MicroToNTP(v13);
        v15 = v44[0];
        v16 = 0x1E0CB3000;
      }
      else
      {
        v16 = 0x1E0CB3000uLL;
        if (v44[0] == 1)
        {
          v17 = &v48;
          if (!(_DWORD)v45 || (v17 = v47, (_DWORD)v45 == 1))
          {
            *v17 = v13;
            goto LABEL_45;
          }
LABEL_51:
          v19 = 0;
          LOBYTE(v18) = 0;
          goto LABEL_52;
        }
      }
      if (v15 == 1)
      {
LABEL_45:
        if ((_DWORD)v45)
          v19 = 0;
        else
          v19 = v49;
        if ((_DWORD)v45)
          LOBYTE(v18) = 0;
        else
          LOBYTE(v18) = v49[24];
      }
      else
      {
        if (v15 != 2)
          goto LABEL_51;
        LOBYTE(v18) = v54[24];
        v19 = v54;
      }
LABEL_52:
      v20 = (void *)objc_msgSend(objc_alloc(*(Class *)(v16 + 2024)), "initWithInt:", 0);
      v21 = objc_msgSend(*(id *)(v2 + 56), "objectForKeyedSubscript:", v20);
      v22 = objc_msgSend(*(id *)(v2 + 64), "objectForKeyedSubscript:", v20);

      v23 = v44[0];
      if (v44[0] == 2)
      {
        if (!(_BYTE)v18)
        {
          v21 = v22;
          if (v22)
            goto LABEL_62;
        }
        if ((_BYTE)v18)
        {
          v18 = v18;
          do
          {
            v28 = objc_alloc(MEMORY[0x1E0CB37E8]);
            v29 = *(unsigned __int16 *)v19;
            v19 += 2;
            v30 = (void *)objc_msgSend(v28, "initWithInt:", v29);
            v31 = objc_msgSend(*(id *)(v2 + 64), "objectForKeyedSubscript:", v30);
            (*(void (**)(uint64_t, unint64_t *))(v31 + 16))(v31, &v45);

            --v18;
          }
          while (v18);
        }
LABEL_66:
        v23 = v44[0];
      }
      else if (v44[0] == 1)
      {
        if ((_BYTE)v18 || !v21)
        {
          if ((_BYTE)v18)
          {
            v18 = v18;
            do
            {
              v24 = objc_alloc(MEMORY[0x1E0CB37E8]);
              v25 = *(unsigned __int16 *)v19;
              v19 += 2;
              v26 = (void *)objc_msgSend(v24, "initWithInt:", v25);
              v27 = objc_msgSend(*(id *)(v2 + 56), "objectForKeyedSubscript:", v26);
              (*(void (**)(uint64_t, unint64_t *))(v27 + 16))(v27, &v45);

              --v18;
            }
            while (v18);
          }
          goto LABEL_66;
        }
LABEL_62:
        (*(void (**)(uint64_t, unint64_t *))(v21 + 16))(v21, &v45);
        goto LABEL_66;
      }
      if (v23 == 1)
      {
        if (!(_DWORD)v45)
        {
          VCBlockBuffer_Clear((uint64_t)v51);
          VCBlockBuffer_Clear((uint64_t)v52);
          VCBlockBuffer_Clear((uint64_t)v53);
        }
      }
      else if (v23 == 2)
      {
        if (v46)
        {
          for (i = 0; i < v46; v47[i++] = 0.0)
            CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 40), *(void **)&v47[i]);
        }
        if (cf)
        {
          CFRelease(cf);
          cf = 0;
        }
      }
      _VCCannedVideoPacketSource_ReadPacketAndAllocateBlockBuffers(v2, (uint64_t)v44, &v41);
      if (v41)
      {
        if (v44[0] == 2)
        {
          v8 = NTPToMicro(v45);
        }
        else
        {
          if (v44[0] != 1)
            goto LABEL_82;
          if ((_DWORD)v45 == 1)
          {
            v8 = v47[0];
            goto LABEL_85;
          }
          if ((_DWORD)v45)
LABEL_82:
            v8 = NAN;
          else
            v8 = v48;
        }
LABEL_85:
        memset(&v55, 170, sizeof(v55));
        v33 = CMClockGetHostTimeClock();
        CMClockGetTime(&v55, v33);
        v34 = +[VCCannedAVSync sharedCannedAVSync](VCCannedAVSync, "sharedCannedAVSync");
        VCCannedAVSync_SetBase((uint64_t)v34, (double)v55.value / (double)v55.timescale);
        VCCannedAVSync_AddDrift((uint64_t)v34, v6);
        goto LABEL_86;
      }
      continue;
    }
  }
LABEL_87:
  if (v44[0] == 1)
  {
    if (!(_DWORD)v45)
    {
      VCBlockBuffer_Clear((uint64_t)v51);
      VCBlockBuffer_Clear((uint64_t)v52);
      VCBlockBuffer_Clear((uint64_t)v53);
    }
  }
  else if (v44[0] == 2)
  {
    if (v46)
    {
      for (j = 0; j < v46; v47[j++] = 0.0)
        CFAllocatorDeallocate(*(CFAllocatorRef *)(v2 + 40), *(void **)&v47[j]);
    }
    if (cf)
    {
      CFRelease(cf);
      cf = 0;
    }
  }
  pthread_mutex_unlock(v39);
  return 0;
}

uint64_t VCCannedVideoPacketSource_RegisterForCannedReplay(uint64_t a1, unsigned __int16 *a2, unsigned __int16 *a3, unsigned __int16 *a4)
{
  int v4;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  void *v14;
  void *v15;
  _QWORD v17[6];
  uint64_t aBlock;
  uint64_t v19;
  void *v20;
  void *v21;
  unsigned __int16 *v22;
  unsigned __int16 *v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v4 = *(unsigned __int8 *)(a1 + 8);
  if (!*(_BYTE *)(a1 + 8))
    return 0;
  if (v4 == 1)
  {
    if (!a2)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCCannedVideoPacketSource_RegisterForCannedReplay_cold_4();
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCCannedVideoPacketSource_RegisterForCannedReplay_cold_3();
      }
      return 2147549183;
    }
    v13 = MEMORY[0x1E0C809B0];
    aBlock = MEMORY[0x1E0C809B0];
    v19 = 3221225472;
    v20 = ___VCCannedVideoPacketSource_RegisterRTPCallback_block_invoke;
    v21 = &unk_1E9E53E00;
    v22 = a3;
    v23 = a2;
    v14 = _Block_copy(&aBlock);
    objc_msgSend(*(id *)(a1 + 56), "setObject:forKeyedSubscript:", v14, objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedShort:", *a2));
    _Block_release(v14);
    aBlock = v13;
    v19 = 3221225472;
    v20 = ___VCCannedVideoPacketSource_RegisterRTCPCallback_block_invoke;
    v21 = &unk_1E9E53E28;
    v22 = a4;
    v23 = a2;
    v15 = _Block_copy(&aBlock);
    objc_msgSend(*(id *)(a1 + 64), "setObject:forKeyedSubscript:", v15, objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedShort:", *a2));
    _Block_release(v15);
    return 0;
  }
  if (v4 != 2)
    return 2147549183;
  v8 = *((_QWORD *)a2 + 6);
  v9 = MEMORY[0x1E0C809B0];
  aBlock = MEMORY[0x1E0C809B0];
  v19 = 3221225472;
  v20 = ___VCCannedVideoPacketSource_RegisterCannedReplayWriteCallbacks_block_invoke;
  v21 = &unk_1E9E53DB0;
  v22 = (unsigned __int16 *)a1;
  v23 = a3;
  v10 = RTPRegisterPacketCallback(v8, (uint64_t)a2, &aBlock);
  if ((v10 & 0x80000000) != 0)
  {
    v12 = v10;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCCannedVideoPacketSource_RegisterForCannedReplay_cold_1();
    }
  }
  else
  {
    v11 = *((_QWORD *)a2 + 6);
    v17[0] = v9;
    v17[1] = 3221225472;
    v17[2] = ___VCCannedVideoPacketSource_RegisterCannedReplayWriteCallbacks_block_invoke_48;
    v17[3] = &unk_1E9E53DD8;
    v17[4] = a1;
    v17[5] = a4;
    v12 = RTCPRegisterPacketCallback(v11, (uint64_t)a2, v17);
    if ((v12 & 0x80000000) != 0 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCCannedVideoPacketSource_RegisterForCannedReplay_cold_2();
    }
  }
  return v12;
}

uint64_t VCCannedVideoPacketSource_UnregisterForCannedReplay(uint64_t a1, unsigned __int16 *a2)
{
  int v3;
  uint64_t v5;
  unint64_t v6;

  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCCannedVideoPacketSource_UnregisterForCannedReplay_cold_1();
    }
    return 2147549183;
  }
  v3 = *(unsigned __int8 *)(a1 + 8);
  if (!*(_BYTE *)(a1 + 8))
    return 0;
  if (v3 != 2)
  {
    if (v3 == 1)
    {
      objc_msgSend(*(id *)(a1 + 56), "setObject:forKeyedSubscript:", 0, objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedShort:", *a2));
      objc_msgSend(*(id *)(a1 + 56), "setObject:forKeyedSubscript:", 0, objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedShort:", *a2));
      return 0;
    }
    return 2147549183;
  }
  v6 = RTPUnregisterPacketCallback();
  if ((v6 & 0x80000000) != 0)
  {
    v5 = v6;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCCannedVideoPacketSource_UnregisterForCannedReplay_cold_2();
    }
  }
  else
  {
    v5 = RTCPUnregisterPacketCallback();
    if ((v5 & 0x80000000) != 0 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCCannedVideoPacketSource_UnregisterForCannedReplay_cold_3();
    }
  }
  return v5;
}

void _VCCannedVideoPacketSource_WriteBytes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  NSObject *v5;
  _QWORD block[7];

  block[6] = *MEMORY[0x1E0C80C00];
  if (a3)
  {
    v4 = objc_msgSend(objc_alloc(MEMORY[0x1E0C99D50]), "initWithBytes:length:", a2, a3);
    if (v4)
    {
      v5 = *(NSObject **)(a1 + 48);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = ___VCCannedVideoPacketSource_WriteBytes_block_invoke;
      block[3] = &unk_1E9E52238;
      block[4] = a1;
      block[5] = v4;
      dispatch_async(v5, block);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCCannedVideoPacketSource_WriteBytes_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCCannedVideoPacketSource_WriteBytes_cold_1();
  }
}

void _VCCannedVideoPacketSource_WriteBlockBuffer(uint64_t a1, uint64_t a2)
{
  size_t v3;
  char *v4;
  CMBlockBufferRef blockBufferOut;
  uint64_t v6[2];

  v6[1] = *MEMORY[0x1E0C80C00];
  v6[0] = 0;
  if (a2 && (v3 = *(_QWORD *)(a2 + 8)) != 0)
  {
    blockBufferOut = 0;
    if (CMBlockBufferCreateContiguous(*(CFAllocatorRef *)(a1 + 32), *(CMBlockBufferRef *)a2, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, v3, 0, &blockBufferOut))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCCannedVideoPacketSource_WriteBlockBuffer_cold_2();
      }
    }
    else
    {
      v4 = 0;
      if (CMBlockBufferGetDataPointer(blockBufferOut, 0, 0, 0, &v4))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VCCannedVideoPacketSource_WriteBlockBuffer_cold_1();
        }
      }
      else
      {
        v6[0] = CMBlockBufferGetDataLength(blockBufferOut);
        _VCCannedVideoPacketSource_WriteBytes(a1, (uint64_t)v6, 8);
        _VCCannedVideoPacketSource_WriteBytes(a1, (uint64_t)v4, v6[0]);
      }
    }
    if (blockBufferOut)
      CFRelease(blockBufferOut);
  }
  else
  {
    _VCCannedVideoPacketSource_WriteBytes(a1, (uint64_t)v6, 8);
  }
}

void _VCCannedVideoPacketSource_ReadPacketAndAllocateBlockBuffers(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  int PacketTypeFromFile;
  unint64_t v7;
  void *v8;
  _QWORD v9[4];

  v9[3] = *MEMORY[0x1E0C80C00];
  if (a3)
    *a3 = 0;
  if (*(_BYTE *)(a1 + 8) == 1)
  {
    PacketTypeFromFile = _VCCannedVideoPacketSource_ReadPacketTypeFromFile(a1);
    if (PacketTypeFromFile)
      goto LABEL_5;
    if (a3)
      *a3 = 1;
    objc_msgSend(*(id *)(a1 + 16), "seekToFileOffset:", 0);
    PacketTypeFromFile = _VCCannedVideoPacketSource_ReadPacketTypeFromFile(a1);
    if (PacketTypeFromFile)
    {
LABEL_5:
      if (PacketTypeFromFile == 2)
      {
        _VCCannedVideoPacketSource_ReadDataFromFile(*(void **)(a1 + 16), 0x668uLL, (void *)(a2 + 8));
        if (*(_BYTE *)(a2 + 16))
        {
          v7 = 0;
          do
          {
            v8 = CFAllocatorAllocate(*(CFAllocatorRef *)(a1 + 40), 1036, 0);
            *(_QWORD *)(a2 + 24 + 8 * v7) = v8;
            _VCCannedVideoPacketSource_ReadDataFromFile(*(void **)(a1 + 16), 0x40CuLL, v8);
            ++v7;
          }
          while (v7 < *(unsigned __int8 *)(a2 + 16));
        }
        memset(v9, 0, 24);
        _VCCannedVideoPacketSource_ReadBlockBufferFromFile(a1, *(void **)(a1 + 16), (uint64_t)v9);
        *(_QWORD *)(a2 + 104) = v9[0];
      }
      else if (PacketTypeFromFile == 1)
      {
        _VCCannedVideoPacketSource_ReadDataFromFile(*(void **)(a1 + 16), 0x17B0uLL, (void *)(a2 + 8));
        if (!*(_DWORD *)(a2 + 8))
        {
          *(_OWORD *)(a2 + 184) = 0u;
          *(_QWORD *)(a2 + 200) = 0;
          *(_OWORD *)(a2 + 152) = 0u;
          *(_OWORD *)(a2 + 168) = 0u;
          *(_OWORD *)(a2 + 136) = 0u;
          _VCCannedVideoPacketSource_ReadBlockBufferFromFile(a1, *(void **)(a1 + 16), a2 + 136);
          _VCCannedVideoPacketSource_ReadBlockBufferFromFile(a1, *(void **)(a1 + 16), a2 + 160);
          _VCCannedVideoPacketSource_ReadBlockBufferFromFile(a1, *(void **)(a1 + 16), a2 + 184);
        }
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCCannedVideoPacketSource_ReadPacketAndAllocateBlockBuffers_cold_1();
    }
    *(_BYTE *)a2 = PacketTypeFromFile;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCCannedVideoPacketSource_ReadPacketAndAllocateBlockBuffers_cold_2();
  }
}

uint64_t _VCCannedVideoPacketSource_ReadPacketTypeFromFile(uint64_t a1)
{
  uint64_t result;
  unsigned __int8 v2;
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  v2 = 0;
  result = _VCCannedVideoPacketSource_ReadDataFromFile(*(void **)(a1 + 16), 1uLL, &v2);
  if ((_DWORD)result)
  {
    result = v2;
    if (v2 - 3 <= 0xFFFFFFFD)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
        if (!(_DWORD)result)
          return result;
        _VCCannedVideoPacketSource_ReadPacketTypeFromFile_cold_1();
      }
      return 0;
    }
  }
  return result;
}

void _VCCannedVideoPacketSource_ReadBlockBufferFromFile(uint64_t a1, void *a2, uint64_t a3)
{
  void *v6;
  BOOL v7;
  const void *v8;
  char *v9;
  int ErrorLogLevelForModule;
  char *dataPointerOut;
  uint64_t v12;
  size_t dataLength[2];

  dataLength[1] = *MEMORY[0x1E0C80C00];
  dataLength[0] = 0;
  _VCCannedVideoPacketSource_ReadDataFromFile(*(void **)(a1 + 16), 8uLL, dataLength);
  if (dataLength[0])
  {
    v12 = 0;
    v6 = (void *)objc_msgSend(a2, "readDataUpToLength:error:", dataLength[0], &v12);
    if (objc_msgSend(v6, "length"))
      v7 = v12 == 0;
    else
      v7 = 0;
    if (v7)
    {
      if (CMBlockBufferCreateWithMemoryBlock(*(CFAllocatorRef *)(a1 + 32), 0, dataLength[0], (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, dataLength[0], 1u, (CMBlockBufferRef *)a3))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VCCannedVideoPacketSource_ReadBlockBufferFromFile_cold_4();
        }
      }
      else
      {
        v8 = (const void *)objc_msgSend(v6, "bytes");
        if (CMBlockBufferReplaceDataBytes(v8, *(CMBlockBufferRef *)a3, 0, dataLength[0]))
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              _VCCannedVideoPacketSource_ReadBlockBufferFromFile_cold_3();
          }
        }
        else
        {
          dataPointerOut = 0;
          if (!CMBlockBufferGetDataPointer(*(CMBlockBufferRef *)a3, 0, 0, 0, &dataPointerOut))
          {
            v9 = dataPointerOut;
            if (dataPointerOut)
            {
              *(_QWORD *)(a3 + 8) = dataLength[0];
              *(_QWORD *)(a3 + 16) = v9;
              return;
            }
          }
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              _VCCannedVideoPacketSource_ReadBlockBufferFromFile_cold_2();
          }
        }
      }
    }
    else
    {
      ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
      if (ErrorLogLevelForModule >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCCannedVideoPacketSource_ReadBlockBufferFromFile_cold_1();
      }
    }
  }
  if (*(_QWORD *)a3)
  {
    CFRelease(*(CFTypeRef *)a3);
    *(_QWORD *)a3 = 0;
  }
}

uint64_t _VCCannedVideoPacketSource_ReadDataFromFile(void *a1, size_t a2, void *a3)
{
  void *v5;
  void *v6;
  uint64_t result;
  _QWORD v8[2];

  v8[1] = *MEMORY[0x1E0C80C00];
  v8[0] = 0xAAAAAAAAAAAAAAAALL;
  v5 = (void *)objc_msgSend(a1, "readDataUpToLength:error:", a2, v8);
  if (v8[0])
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!(_DWORD)result)
        return result;
      _VCCannedVideoPacketSource_ReadDataFromFile_cold_1();
    }
    return 0;
  }
  v6 = v5;
  result = objc_msgSend(v5, "length");
  if (result)
  {
    memcpy(a3, (const void *)objc_msgSend(v6, "bytes"), a2);
    return 1;
  }
  return result;
}

void OUTLINED_FUNCTION_15_0(uint64_t a1@<X8>)
{
  uint64_t v1;

  *(_QWORD *)(v1 - 8) = a1;
}

FILE **LogDump_OpenLog(uint64_t a1, uint64_t a2, uint64_t a3, char a4, char a5, char a6)
{
  int AppBooleanValue;
  FILE **v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  NSObject *v33;
  const char *v34;
  Boolean keyExistsAndHasValidFormat[4];
  uint64_t v37;
  __int16 v38;
  const char *v39;
  __int16 v40;
  int v41;
  __int16 v42;
  const char *v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  keyExistsAndHasValidFormat[0] = 0;
  AppBooleanValue = CFPreferencesGetAppBooleanValue(CFSTR("enableTFRCDump"), CFSTR("com.apple.VideoConference"), keyExistsAndHasValidFormat);
  if (!keyExistsAndHasValidFormat[0])
  {
    if (VCDefaults_DefaultDumpEnablementValue())
      goto LABEL_3;
LABEL_5:
    v13 = 0;
    goto LABEL_6;
  }
  if (!AppBooleanValue)
    goto LABEL_5;
LABEL_3:
  v13 = VRLogfileAlloc(0, a1, a2, a3, "com.apple.VideoConference.Jitterlog", a5);
  VRLogfilePrintSync(v13, "VERSION = %s, DTX Support\n", v14, v15, v16, v17, v18, v19, a6);
  VRLogfilePrintSync(v13, "CALLID = %s\n", v20, v21, v22, v23, v24, v25, a1);
  VRLogfilePrintSync(v13, "%s", v26, v27, v28, v29, v30, v31, a4);
LABEL_6:
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v32 = VRTraceErrorLogLevelToCSTR();
    v33 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v34 = "Enabled";
      v37 = v32;
      *(_DWORD *)keyExistsAndHasValidFormat = 136315906;
      v39 = "LogDump_OpenLog";
      v38 = 2080;
      if (!v13)
        v34 = "Disabled";
      v40 = 1024;
      v41 = 69;
      v42 = 2080;
      v43 = v34;
      _os_log_impl(&dword_1D8A54000, v33, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Log Dump is %s", keyExistsAndHasValidFormat, 0x26u);
    }
  }
  return v13;
}

uint64_t LogDump_CloseLog(uint64_t a1)
{
  uint64_t v2[2];

  v2[1] = *MEMORY[0x1E0C80C00];
  v2[0] = a1;
  VRLogfileFree(v2);
  return VRLogfileRemoveOldFilesInDefaultLogDumpPath();
}

unint64_t GetNTPTime()
{
  double v0;

  v0 = micro();
  if (!dword_1F01BD1DC)
    TimeZeroInit();
  return (unint64_t)((double)TimeZero + v0 * 4294967300.0);
}

unint64_t MicroToNTP(double a1)
{
  if (!dword_1F01BD1DC)
    TimeZeroInit();
  return (unint64_t)((double)TimeZero + a1 * 4294967300.0);
}

void TimeZeroInit()
{
  double v0;
  double v1;
  timeval v2[2];
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  memset(v2, 170, sizeof(v2));
  v0 = micro();
  gettimeofday(&v2[1], 0);
  v1 = micro();
  gettimeofday(v2, 0);
  if (micro() - v1 < v1 - v0)
  {
    v2[1] = v2[0];
    v0 = v1;
  }
  TimeZero = vcvtd_n_u64_f64((double)v2[1].tv_sec + (double)v2[1].tv_usec * 0.000001 + 2208988800.0 - v0, 0x20uLL);
}

double NTPToMicro(uint64_t a1)
{
  if (!dword_1F01BD1DC)
    TimeZeroInit();
  return (double)(unint64_t)(a1 - TimeZero) * 2.32830644e-10;
}

unint64_t NTPToMiddle32(unint64_t a1)
{
  return a1 >> 16;
}

unint64_t Middle32ToMilliSeconds(int a1)
{
  return (unint64_t)((double)(a1 << 16) * 2.32830644e-10 * 1000.0);
}

void _VCStreamIOAudioController_SampleBufferCallback(uint64_t a1, CMSampleBufferRef sbuf)
{
  CMItemCount NumSamples;
  unsigned int SampleCapacity;
  double v6;
  int v7;
  Float64 Seconds;
  uint64_t v9;
  uint64_t v10;
  double v11;
  int v12;
  NSObject *v13;
  Float64 v14;
  Float64 v15;
  Float64 v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  AudioBufferList *AudioBufferList;
  OSStatus v21;
  uint64_t v22;
  double v23;
  unsigned int v24;
  uint64_t v25;
  NSObject *v26;
  uint64_t v27;
  const char *v28;
  NSObject *v29;
  OSStatus v30;
  uint64_t v31;
  NSObject *v32;
  uint64_t v33;
  uint64_t v34;
  CMTime v35;
  CMTime v36;
  CMTime rhs;
  CMTime v38;
  CMTime lhs;
  int v40;
  __int16 v41;
  _BYTE v42[24];
  __int16 v43;
  Float64 v44;
  __int16 v45;
  Float64 v46;
  __int16 v47;
  uint64_t v48;
  __int16 v49;
  uint64_t v50;
  __int16 v51;
  int v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    NumSamples = CMSampleBufferGetNumSamples(sbuf);
    SampleCapacity = VCAudioBufferList_GetSampleCapacity(*(_QWORD *)(a1 + 248));
    if (NumSamples > SampleCapacity)
    {
      v24 = SampleCapacity;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v25 = VRTraceErrorLogLevelToCSTR();
        v26 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v27 = objc_msgSend((id)objc_msgSend(*(id *)(a1 + 224), "streamInputID"), "longValue");
          LODWORD(lhs.value) = 136316418;
          *(CMTimeValue *)((char *)&lhs.value + 4) = v25;
          LOWORD(lhs.flags) = 2080;
          *(_QWORD *)((char *)&lhs.flags + 2) = "_VCStreamIOAudioController_SampleBufferCallback";
          HIWORD(lhs.epoch) = 1024;
          v40 = 501;
          v41 = 2048;
          *(_QWORD *)v42 = NumSamples;
          *(_WORD *)&v42[8] = 1024;
          *(_DWORD *)&v42[10] = v24;
          *(_WORD *)&v42[14] = 2048;
          *(_QWORD *)&v42[16] = v27;
          v28 = "VCStreamIOAudioController [%s] %s:%d Frame size=%ld changed unexpectedly and sample buffer size=%u is no"
                "t big enough for streamInputID=%ld.";
          v29 = v26;
LABEL_23:
          _os_log_error_impl(&dword_1D8A54000, v29, OS_LOG_TYPE_ERROR, v28, (uint8_t *)&lhs, 0x36u);
        }
      }
    }
    else
    {
      memset(&v36, 170, sizeof(v36));
      CMSampleBufferGetPresentationTimeStamp(&v36, sbuf);
      v35 = v36;
      if (*(_BYTE *)(a1 + 296))
      {
        v6 = *(double *)objc_msgSend(*(id *)(a1 + 232), "clientFormat");
        lhs = v35;
        rhs = *(CMTime *)(a1 + 304);
        memset(&v38, 170, sizeof(v38));
        CMTimeSubtract(&v38, &lhs, &rhs);
        v7 = *(_DWORD *)(a1 + 328);
        lhs = v38;
        Seconds = CMTimeGetSeconds(&lhs);
        v9 = *(_QWORD *)(a1 + 328);
        v10 = llround(Seconds * (v6 / (double)v9)) * v7;
        if (v9 == v10)
        {
          v11 = NAN;
        }
        else
        {
          lhs = v38;
          v11 = CMTimeGetSeconds(&lhs);
          lhs = v38;
          *(_DWORD *)(a1 + 300) += llround(v6 * CMTimeGetSeconds(&lhs)) - *(_DWORD *)(a1 + 328);
          if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
          {
            v34 = VRTraceErrorLogLevelToCSTR();
            v13 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              lhs = v38;
              v14 = CMTimeGetSeconds(&lhs);
              lhs = *(CMTime *)(a1 + 304);
              v15 = CMTimeGetSeconds(&lhs);
              lhs = v35;
              v16 = CMTimeGetSeconds(&lhs);
              v17 = objc_msgSend((id)objc_msgSend(*(id *)(a1 + 224), "streamInputID"), "longValue");
              v18 = *(_QWORD *)(a1 + 328);
              v19 = *(_DWORD *)(a1 + 300);
              LODWORD(lhs.value) = 136317698;
              *(CMTimeValue *)((char *)&lhs.value + 4) = v34;
              LOWORD(lhs.flags) = 2080;
              *(_QWORD *)((char *)&lhs.flags + 2) = "_VCStreamIOAudioController_GetSampleBufferTimestamp";
              HIWORD(lhs.epoch) = 1024;
              v40 = 476;
              v41 = 2048;
              *(_QWORD *)v42 = a1;
              *(_WORD *)&v42[8] = 2048;
              *(Float64 *)&v42[10] = v14;
              *(_WORD *)&v42[18] = 1024;
              *(_DWORD *)&v42[20] = v10;
              v43 = 2048;
              v44 = v15;
              v45 = 2048;
              v46 = v16;
              v47 = 2048;
              v48 = v17;
              v49 = 2048;
              v50 = v18;
              v51 = 1024;
              v52 = v19;
              _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, "VCStreamIOAudioController [%s] %s:%d controller=%p Real time miss. host time jumped: %f (%u samples) (%f to %f) for streamInputID=%ld. lastSampleCount=%lu -> nextExpectedSampleTime=%u", (uint8_t *)&lhs, 0x64u);
            }
          }
        }
        v12 = *(_DWORD *)(a1 + 300);
      }
      else
      {
        v12 = 0;
        v11 = NAN;
      }
      *(CMTime *)(a1 + 304) = v35;
      *(_QWORD *)(a1 + 328) = NumSamples;
      *(_DWORD *)(a1 + 300) += NumSamples;
      *(_BYTE *)(a1 + 296) = 1;
      VCAudioBufferList_Reset(*(_QWORD *)(a1 + 248));
      AudioBufferList = (AudioBufferList *)VCAudioBufferList_GetAudioBufferList(*(_QWORD *)(a1 + 248));
      v21 = CMSampleBufferCopyPCMDataIntoAudioBufferList(sbuf, 0, NumSamples, AudioBufferList);
      if (!v21)
      {
        v22 = *(_QWORD *)(a1 + 248);
        lhs = v36;
        v23 = CMTimeGetSeconds(&lhs);
        VCAudioBufferList_SetTime(v22, v12, v23);
        VCAudioBufferList_SetSampleCount(*(_QWORD *)(a1 + 248), NumSamples);
        VCAudioBufferList_SetPriority(*(_QWORD *)(a1 + 248), 255);
        VCAudioBufferList_SetVoiceActivity(*(_QWORD *)(a1 + 248), 1);
        VCAudioBufferList_SetHostTimeJumpSize(*(_QWORD *)(a1 + 248), v11);
        PacketThread_SendSampleBuffer(*(_QWORD *)(a1 + 240), *(const void **)(a1 + 248));
        return;
      }
      v30 = v21;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v31 = VRTraceErrorLogLevelToCSTR();
        v32 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v33 = objc_msgSend((id)objc_msgSend(*(id *)(a1 + 224), "streamInputID"), "longValue");
          LODWORD(lhs.value) = 136316418;
          *(CMTimeValue *)((char *)&lhs.value + 4) = v31;
          LOWORD(lhs.flags) = 2080;
          *(_QWORD *)((char *)&lhs.flags + 2) = "_VCStreamIOAudioController_SampleBufferCallback";
          HIWORD(lhs.epoch) = 1024;
          v40 = 510;
          v41 = 1024;
          *(_DWORD *)v42 = v30;
          *(_WORD *)&v42[4] = 2048;
          *(_QWORD *)&v42[6] = a1;
          *(_WORD *)&v42[14] = 2048;
          *(_QWORD *)&v42[16] = v33;
          v28 = "VCStreamIOAudioController [%s] %s:%d CMSampleBufferCopyPCMDataIntoAudioBufferList failed with err=%d for"
                " controller=%p streamInputID=%ld";
          v29 = v32;
          goto LABEL_23;
        }
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCStreamIOAudioController_SampleBufferCallback_cold_1();
  }
}

void _VCStreamIOAudioController_PullAudioSamples(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  double *SampleFormat;
  CMSampleBufferRef v6;
  CFNumberRef v7;
  CFNumberRef v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  _QWORD v12[2];
  uint64_t valuePtr;
  _QWORD v14[3];
  uint8_t buf[4];
  uint64_t v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 280);
  v12[0] = 0xAAAAAAAAAAAAAAAALL;
  VCAudioBufferList_ZeroMemory(a2);
  SampleFormat = (double *)VCAudioBufferList_GetSampleFormat(a2);
  if (SampleFormat)
  {
    LODWORD(v12[0]) = *SampleFormat;
    v12[1] = VCAudioBufferList_GetTimestamp(a2);
    (*(void (**)(_QWORD, _QWORD *, uint64_t))(v4 + 8))(*(_QWORD *)v4, v12, a2);
    memset(v14, 170, sizeof(v14));
    VCAudioBufferList_GetNetworkTimestamp(a2, (uint64_t)v14);
    if ((v14[1] & 0x100000000) != 0)
    {
      v6 = VCAudioBufferList_CreateSampleBufferAllocateWithAllocator(a2, *(CFAllocatorRef *)(a1 + 256), *(const __CFAllocator **)(a1 + 288));
      valuePtr = v14[0];
      v7 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt64Type, &valuePtr);
      if (v7)
      {
        v8 = v7;
        CMSetAttachment(v6, CFSTR("networkTimestamp"), v7, 1u);
        CFRelease(v8);
        os_unfair_lock_lock((os_unfair_lock_t)(a1 + 272));
        v9 = *(_QWORD *)(a1 + 264);
        if (v9)
        {
          if ((VCStreamOutput_EnqueueSampleBuffer(v9, v6) & 1) == 0 && (int)VRTraceGetErrorLogLevelForModule() >= 5)
          {
            v10 = VRTraceErrorLogLevelToCSTR();
            v11 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315650;
              v16 = v10;
              v17 = 2080;
              v18 = "_VCStreamIOAudioController_EnqueueSampleBuffer";
              v19 = 1024;
              v20 = 557;
              _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, "VCStreamIOAudioController [%s] %s:%d Enqueue failed", buf, 0x1Cu);
            }
          }
        }
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 272));
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCStreamIOAudioController_PullAudioSamples_cold_1();
      }
      if (v6)
        CFRelease(v6);
    }
  }
}

void VCVirtualAVCaptureDeviceInput_OnMediaSample(uint64_t a1, const void *a2, uint64_t a3)
{
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t i;
  void *v11;
  _BYTE v12[128];
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 40));
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  v6 = *(void **)(a1 + 24);
  v7 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v13, v12, 16);
  if (v7)
  {
    v8 = v7;
    v9 = *(_QWORD *)v14;
    do
    {
      for (i = 0; i != v8; ++i)
      {
        if (*(_QWORD *)v14 != v9)
          objc_enumerationMutation(v6);
        v11 = *(void **)(*((_QWORD *)&v13 + 1) + 8 * i);
        if (objc_msgSend((id)objc_msgSend(v11, "mediaType"), "isEqual:", a3))
          VCVirtualAVCaptureInputPort_OnMediaSample((uint64_t)v11, a2, a3);
      }
      v8 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v13, v12, 16);
    }
    while (v8);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 40));
}

uint64_t _VCConnectionStatisticsCollector_ComparePacketCounts(void *a1, void *a2)
{
  unsigned int v3;
  unsigned int v4;
  uint64_t v5;

  v3 = objc_msgSend((id)objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("PktCnt")), "unsignedIntValue");
  v4 = objc_msgSend((id)objc_msgSend(a2, "objectForKeyedSubscript:", CFSTR("PktCnt")), "unsignedIntValue");
  if (v3 <= v4)
    v5 = 0;
  else
    v5 = -1;
  if (v3 < v4)
    return 1;
  else
    return v5;
}

char *RTPMapCreate()
{
  char *v0;
  char *v1;

  v0 = (char *)malloc_type_calloc(1uLL, 0x50uLL, 0x102004089B94702uLL);
  v1 = v0;
  if (v0)
    pthread_mutex_init((pthread_mutex_t *)(v0 + 16), 0);
  return v1;
}

void RTPMapDestroy(void **a1)
{
  uint64_t v2;

  v2 = (uint64_t)*a1;
  if (v2)
  {
    RTPMapResetMapping(v2);
    pthread_mutex_destroy((pthread_mutex_t *)((char *)*a1 + 16));
    free(*a1);
    *a1 = 0;
  }
}

void RTPMapResetMapping(uint64_t a1)
{
  pthread_mutex_t *v2;

  if (a1)
  {
    v2 = (pthread_mutex_t *)(a1 + 16);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
    free(*(void **)a1);
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    pthread_mutex_unlock(v2);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      RTPMapResetMapping_cold_1();
  }
}

void RTPMapAddMappingForPayload(char **a1, int a2, int a3, int a4)
{
  uint64_t v4;
  NSObject *v5;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int16 *v13;
  unsigned __int16 *v14;
  int v16;
  int v17;
  int v18;
  unsigned int v19;
  char *v20;
  char *v21;
  char *v22;
  uint64_t v23;
  size_t v24;
  uint64_t v25;
  NSObject *v26;
  unint64_t v27;
  uint64_t v29;
  NSObject *v30;
  unsigned __int16 *v31;
  int v32;
  char *v33;
  char *v34;
  char *v36;
  pthread_mutex_t *v37;
  uint8_t buf[4];
  uint64_t v39;
  __int16 v40;
  const char *v41;
  __int16 v42;
  int v43;
  __int16 v44;
  int v45;
  __int16 v46;
  int v47;
  __int16 v48;
  int v49;
  __int16 v50;
  int v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  if (a4 == 128)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v4 = VRTraceErrorLogLevelToCSTR();
      v5 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        v39 = v4;
        v40 = 2080;
        v41 = "RTPMapAddMappingForPayload";
        v42 = 1024;
        v43 = 63;
        _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d internalPayload is invalid.", buf, 0x1Cu);
      }
    }
  }
  else if (a1)
  {
    v37 = (pthread_mutex_t *)(a1 + 2);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 2));
    v10 = *((unsigned int *)a1 + 3);
    v11 = *((int *)a1 + 2);
    if ((int)v10 < 1)
    {
      v18 = 0;
LABEL_22:
      if ((_DWORD)v10 == (_DWORD)v11)
      {
        v19 = v10 + 5;
        v20 = (char *)malloc_type_malloc(6 * ((int)v10 + 5), 0x1000040274DC3F3uLL);
        v21 = v20;
        if (v20)
          v22 = &v20[6 * (int)v10 + 30];
        else
          v22 = 0;
        if (v20)
        {
          if ((int)v10 < -5)
            goto LABEL_61;
          v23 = *((int *)a1 + 2);
          if ((v23 & 0x80000000) != 0)
            goto LABEL_61;
          v24 = 6 * *((int *)a1 + 3);
          if (v24 > 6 * v23 || v24 > 6 * ((int)v10 + 5))
            goto LABEL_61;
          memcpy(v20, *a1, v24);
          free(*a1);
          *a1 = 0;
          *((_DWORD *)a1 + 2) = 0;
        }
        else
        {
          v19 = 0;
        }
        if (v21 > v22 || (uint64_t)(0xAAAAAAAAAAAAAAABLL * ((v22 - v21) >> 1)) < v19)
          goto LABEL_61;
        v11 = v19;
        *a1 = v21;
        *((_DWORD *)a1 + 2) = v19;
      }
      else
      {
        v21 = *a1;
      }
      v33 = &v21[6 * v11];
      v34 = &v21[6 * v18];
      if (v34 >= v33 || v34 < v21)
LABEL_61:
        __break(0x5519u);
      *(_WORD *)v34 = a4;
      v36 = &v21[6 * v18];
      *((_WORD *)v36 + 1) = a2;
      *((_WORD *)v36 + 2) = a3;
      ++*((_DWORD *)a1 + 3);
      pthread_mutex_unlock(v37);
    }
    else
    {
      v12 = 0;
      v13 = (unsigned __int16 *)*a1;
      while (1)
      {
        v14 = &v13[v12];
        if (&v13[v12] >= (unsigned __int16 *)&(*a1)[6 * (int)v11] || v14 < v13)
          goto LABEL_61;
        v16 = *v14;
        v17 = v14[1];
        if (v16 == a4)
        {
          if (v17 != a2 || v13[v12 + 2] != a3)
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v25 = VRTraceErrorLogLevelToCSTR();
              v26 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315906;
                v39 = v25;
                v40 = 2080;
                v41 = "RTPMapAddMappingForPayload";
                v42 = 1024;
                v43 = 79;
                v44 = 1024;
                v45 = a4;
                _os_log_impl(&dword_1D8A54000, v26, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Internal payload(%d)'s mapping is overwriten", buf, 0x22u);
              }
            }
            v27 = (unint64_t)&(*a1)[v12 * 2];
            if (v27 < (unint64_t)&(*a1)[6 * *((int *)a1 + 2)] && v27 >= (unint64_t)*a1)
            {
              *(_WORD *)(v27 + 2) = a2;
              *(_WORD *)(v27 + 4) = a3;
              goto LABEL_49;
            }
            goto LABEL_61;
          }
          goto LABEL_49;
        }
        if (v17 == a2 && v13[v12 + 2] == a3)
          break;
        v12 += 3;
        if (3 * v10 == v12)
        {
          v18 = *((_DWORD *)a1 + 3);
          goto LABEL_22;
        }
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v29 = VRTraceErrorLogLevelToCSTR();
        v30 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v31 = (unsigned __int16 *)&(*a1)[v12 * 2];
          if (v31 < (unsigned __int16 *)&(*a1)[6 * *((int *)a1 + 2)] && v31 >= (unsigned __int16 *)*a1)
          {
            v32 = *v31;
            *(_DWORD *)buf = 136316674;
            v39 = v29;
            v40 = 2080;
            v41 = "RTPMapAddMappingForPayload";
            v42 = 1024;
            v43 = 95;
            v44 = 1024;
            v45 = a2;
            v46 = 1024;
            v47 = a3;
            v48 = 1024;
            v49 = v32;
            v50 = 1024;
            v51 = a4;
            _os_log_impl(&dword_1D8A54000, v30, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d External payloads send(%d), recv(%d) are used twice by existing internal payload %d and new internal payload %d. Treated as no-op", buf, 0x34u);
            goto LABEL_49;
          }
          goto LABEL_61;
        }
      }
LABEL_49:
      pthread_mutex_unlock(v37);
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      RTPMapAddMappingForPayload_cold_1();
  }
}

void RTPMapPrintMapping(uint64_t a1)
{
  pthread_mutex_t *v2;
  uint64_t v3;
  uint64_t v4;
  _BYTE *v5;
  NSObject **v6;
  uint64_t v7;
  NSObject *v8;
  NSObject *v9;
  unsigned __int16 *v10;
  int v12;
  int v13;
  int v14;
  unsigned __int16 *v15;
  int v17;
  int v18;
  int v19;
  uint8_t buf[4];
  uint64_t v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  __int16 v28;
  int v29;
  __int16 v30;
  int v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = (pthread_mutex_t *)(a1 + 16);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
    if (*(int *)(a1 + 12) >= 1)
    {
      v3 = 0;
      v4 = 0;
      v5 = (_BYTE *)MEMORY[0x1E0CF2748];
      v6 = (NSObject **)MEMORY[0x1E0CF2758];
      do
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          v7 = VRTraceErrorLogLevelToCSTR();
          v8 = *v6;
          v9 = *v6;
          if (*v5)
          {
            if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
            {
              v10 = (unsigned __int16 *)(*(_QWORD *)a1 + v3);
              if ((unint64_t)v10 >= *(_QWORD *)a1 + 6 * *(int *)(a1 + 8)
                || (unint64_t)v10 < *(_QWORD *)a1)
              {
                goto LABEL_27;
              }
              v12 = v10[2];
              v13 = *v10;
              v14 = v10[1];
              *(_DWORD *)buf = 136316418;
              v21 = v7;
              v22 = 2080;
              v23 = "RTPMapPrintMapping";
              v24 = 1024;
              v25 = 155;
              v26 = 1024;
              v27 = v12;
              v28 = 1024;
              v29 = v13;
              v30 = 1024;
              v31 = v14;
              _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d *** RTPPrintRTPMapping *** external payload receive %d -> internal payload %d -> external payload send %d", buf, 0x2Eu);
            }
          }
          else if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
          {
            v15 = (unsigned __int16 *)(*(_QWORD *)a1 + v3);
            if ((unint64_t)v15 >= *(_QWORD *)a1 + 6 * *(int *)(a1 + 8)
              || (unint64_t)v15 < *(_QWORD *)a1)
            {
LABEL_27:
              __break(0x5519u);
            }
            v17 = v15[2];
            v18 = *v15;
            v19 = v15[1];
            *(_DWORD *)buf = 136316418;
            v21 = v7;
            v22 = 2080;
            v23 = "RTPMapPrintMapping";
            v24 = 1024;
            v25 = 155;
            v26 = 1024;
            v27 = v17;
            v28 = 1024;
            v29 = v18;
            v30 = 1024;
            v31 = v19;
            _os_log_debug_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEBUG, " [%s] %s:%d *** RTPPrintRTPMapping *** external payload receive %d -> internal payload %d -> external payload send %d", buf, 0x2Eu);
          }
        }
        ++v4;
        v3 += 6;
      }
      while (v4 < *(int *)(a1 + 12));
    }
    pthread_mutex_unlock(v2);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      RTPMapPrintMapping_cold_1();
  }
}

uint64_t RTPMapGetInternalPayload(unsigned __int16 **a1, unsigned int a2)
{
  pthread_mutex_t *v4;
  uint64_t result;
  uint64_t v6;
  unsigned __int16 *v7;
  unsigned __int16 v8;
  int v9;

  if (a1)
  {
    if (a2 > 0x5F || a2 == 20)
    {
      v4 = (pthread_mutex_t *)(a1 + 2);
      result = pthread_mutex_lock((pthread_mutex_t *)(a1 + 2));
      v6 = *((unsigned int *)a1 + 3);
      if ((int)v6 < 1)
      {
LABEL_10:
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 2));
      }
      else
      {
        v7 = *a1;
        while (1)
        {
          if (v7 >= &(*a1)[3 * *((int *)a1 + 2)] || v7 < *a1)
          {
            __break(0x5519u);
            return result;
          }
          if (v7[2] == a2)
            break;
          v7 += 3;
          if (!--v6)
            goto LABEL_10;
        }
        v8 = *v7;
        v9 = *v7;
        pthread_mutex_unlock(v4);
        if (v9 != 128)
          return v8;
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      RTPMapGetInternalPayload_cold_1();
  }
  return (unsigned __int16)a2;
}

uint64_t RTPMapGetExternalPayload(unsigned __int16 **a1, unsigned int a2)
{
  pthread_mutex_t *v4;
  uint64_t result;
  uint64_t v6;
  unsigned __int16 *v7;
  unsigned __int16 v8;

  if (a1)
  {
    if (a2 > 0x5F || a2 == 20)
    {
      v4 = (pthread_mutex_t *)(a1 + 2);
      result = pthread_mutex_lock((pthread_mutex_t *)(a1 + 2));
      v6 = *((unsigned int *)a1 + 3);
      if ((int)v6 < 1)
      {
LABEL_10:
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 2));
      }
      else
      {
        v7 = *a1;
        while (1)
        {
          if (v7 >= &(*a1)[3 * *((int *)a1 + 2)] || v7 < *a1)
          {
            __break(0x5519u);
            return result;
          }
          if (*v7 == a2)
            break;
          v7 += 3;
          if (!--v6)
            goto LABEL_10;
        }
        v8 = v7[1];
        pthread_mutex_unlock(v4);
        if (v8 != 128)
          return v8;
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      RTPMapGetExternalPayload_cold_1();
  }
  return (unsigned __int16)a2;
}

double _VCRateControlAlgorithmLayeredContinuousTier_Configure(uint64_t a1, void *a2, int a3)
{
  unint64_t v4;
  double result;

  VCRateControlAlgorithmStabilizedNOWRDPriv_Configure(a1, a2, a3);
  *(_QWORD *)(a1 + 25592) = 0;
  *(_DWORD *)(a1 + 25600) = 0;
  LODWORD(v4) = *(_DWORD *)(a1 + 1072);
  result = (double)v4;
  *(double *)(a1 + 1064) = result;
  *(_DWORD *)(a1 + 1076) = vcRateControlTierBitrates[*(int *)(a1 + 1052)];
  return result;
}

BOOL _VCRateControlAlgorithmLayeredContinuousTier_DoRateControl(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10)
{
  int v12;
  _BOOL8 result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int ShouldRampDown;
  int ShouldRampUp;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  double v29;
  double v30;
  unint64_t v31;
  uint64_t v32;
  NSObject *v33;
  int v34;
  double v35;
  unint64_t v36;
  int v37;
  unint64_t v38;
  int v39;
  uint64_t v40;
  int v41;
  int v42;
  int v43;
  int v44;
  double v45;
  uint64_t v46;
  char v47;
  char v48;
  double v49;
  int v50;
  double v51;
  double v52;
  double v53;
  double v54;
  int v55;
  int v56;
  double v57;
  double v58;
  unsigned int v59;
  unsigned int v60;
  unsigned int v61;
  uint64_t v62;
  double v63;
  double v64;
  int v65;
  int v66;
  unsigned int v67;
  double v68;
  unsigned int v69;
  unsigned int v70;
  int v71;
  int v72;
  double v73;
  unsigned int v74;
  double v75;
  unsigned int v76;
  const char *v77;
  const char *v78;
  const char *v79;
  int v80;
  int v81;
  unsigned int v82;
  unsigned int v83;
  int v84;
  int v85;
  unsigned int v86;
  _BOOL4 IsVideoStopped;
  BOOL v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  int v95;
  uint64_t v96;
  NSObject *v97;
  uint64_t v98;
  uint64_t v99;
  NSObject *v100;
  unsigned int v101;
  uint64_t v102;
  int v103;
  unsigned int v104;
  unsigned int v105;
  unsigned int v106;
  unsigned int v107;
  int v108;
  const char *v109;
  const char *v110;
  int v111;
  unsigned int v112;
  int v113;
  int v114;
  int v115;
  unsigned int v116;
  uint8_t v117[4];
  uint64_t v118;
  __int16 v119;
  const char *v120;
  __int16 v121;
  int v122;
  __int16 v123;
  uint8_t *v124;
  uint8_t buf[32];
  __int128 v126;
  __int128 v127;
  __int128 v128;
  __int128 v129;
  __int128 v130;
  __int128 v131;
  __int128 v132;
  __int128 v133;
  __int128 v134;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  __int128 v138;
  __int128 v139;
  __int128 v140;
  __int128 v141;
  __int128 v142;
  __int128 v143;
  __int128 v144;
  __int128 v145;
  __int128 v146;
  __int128 v147;
  __int128 v148;
  uint64_t v149;

  v149 = *MEMORY[0x1E0C80C00];
  v12 = *(_DWORD *)a2;
  if (*(int *)a2 > 10)
  {
    if (v12 == 11)
      return VCRateControlAlgorithmStabilizedNOWRDPriv_DoRateControlWithNWStatistics(a1, a2);
    if (v12 != 14)
    {
LABEL_20:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
        if (!result)
          return result;
        _VCRateControlAlgorithmLayeredContinuousTier_DoRateControl_cold_1();
      }
      return 0;
    }
    if (!*(_DWORD *)(a1 + 1040))
    {
      VCRateControlAlgorithmStabilizedNOWRDPriv_ResetBytesInFlight(a1);
      return 0;
    }
    v22 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(a1 + 5312) = v22;
    LODWORD(v22) = *(_DWORD *)(a1 + 5284);
    LODWORD(a10) = *(_DWORD *)(a2 + 40);
    *(_DWORD *)(a1 + 5284) = ((double)*(unint64_t *)&a10 * 0.1 + (double)v22 * 0.9);
    VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateBytesInFlightThreshold(a1);
    if (!*(_BYTE *)(a1 + 5292))
    {
      result = 0;
      *(_BYTE *)(a1 + 5281) = 1;
      return result;
    }
    if (VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampDownDueToLocalRCEvent(a1))
    {
      v30 = (double)(*(_DWORD *)(a1 + 5284) - *(_DWORD *)(a1 + 5288))
          / (double)*(unsigned int *)(a1 + 5288);
      if (v30 < 0.25)
        v30 = 0.25;
      *(double *)(a1 + 25616) = v30;
      VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "congestionSeverity=%f, bytesInFlight=%u, bytesInFlightThreshold=%u", v23, v24, v25, v26, v27, v28, SLOBYTE(v30));
      *(double *)(a1 + 1064) = (double)_VCRateControlAlgorithmLayeredContinuousTier_RampDown(a1);
      VCRateControlAlgorithmBasePriv_StateChange(a1, 6);
    }
    else
    {
      *(_BYTE *)(a1 + 5281) = VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampUpDueToLocalRCEvent(a1, v29);
    }
    _VCRateControlAlgorithmLayeredContinuousTier_UpdateTargetBitrate(a1, *(double *)(a1 + 1064));
    return 1;
  }
  if (v12 != 1)
  {
    if (v12 == 2)
    {
      result = VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateInternalStatistics(a1, a2);
      if (!result)
        return result;
      VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateSmartBrakeOutputWithVCRCStatistics(a1, a2);
      ShouldRampDown = VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampDown(a1);
      if ((ShouldRampDown & 1) != 0)
        ShouldRampUp = 0;
      else
        ShouldRampUp = VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampUp(a1);
      switch(*(_DWORD *)(a1 + 1040))
      {
        case 0:
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v32 = VRTraceErrorLogLevelToCSTR();
            v33 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315650;
              *(_QWORD *)&buf[4] = v32;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_VCRateControlAlgorithmLayeredContinuousTier_RunRateControlStateTransition";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 356;
              _os_log_impl(&dword_1D8A54000, v33, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d VCRateControl is paused", buf, 0x1Cu);
            }
          }
          break;
        case 1:
          if (ShouldRampDown)
            goto LABEL_69;
          if (ShouldRampUp)
          {
            *(double *)(a1 + 1064) = (double)_VCRateControlAlgorithmLayeredContinuousTier_RampUp(a1);
            v37 = *(_DWORD *)(a1 + 60) >= *(_DWORD *)(a1 + 72) ? *(_DWORD *)(a1 + 72) : *(_DWORD *)(a1 + 60);
            LODWORD(v36) = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * v37);
            if (*(double *)(a1 + 1064) >= (double)v36)
              goto LABEL_59;
          }
          break;
        case 2:
          if (ShouldRampDown)
          {
            v34 = *(double *)(a1 + 1064);
            v35 = *(double *)(a1 + 25592);
            if (v35 == 0.0)
            {
              *(double *)(a1 + 25592) = (double)v34;
              ++*(_DWORD *)(a1 + 25600);
            }
            else
            {
              v42 = (int)((double)v34 - v35);
              if (v42 >= 0)
                v43 = (int)((double)v34 - v35);
              else
                v43 = -v42;
              if (v35 * 0.15 <= (double)v43)
              {
                *(_DWORD *)(a1 + 25600) = 0;
              }
              else
              {
                v44 = ++*(_DWORD *)(a1 + 25600);
                if (v44 >= 10)
                  v44 = 10;
                *(_DWORD *)(a1 + 25600) = v44;
              }
              v45 = (double)v34 * 0.5 + *(double *)(a1 + 25592) * 0.5;
              *(double *)(a1 + 25592) = v45;
              VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "VCRC update bandwidthWall=%f, confidence=%u, diff=%d", v14, v15, v16, v17, v18, v19, SLOBYTE(v45));
            }
LABEL_69:
            *(double *)(a1 + 1064) = (double)_VCRateControlAlgorithmLayeredContinuousTier_RampDown(a1);
            v40 = a1;
            v41 = 6;
            goto LABEL_70;
          }
          if (ShouldRampUp)
          {
            *(double *)(a1 + 1064) = (double)_VCRateControlAlgorithmLayeredContinuousTier_RampUp(a1);
            if (VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldFastRampUp(a1))
            {
              v39 = *(_DWORD *)(a1 + 60);
              if (v39 >= *(_DWORD *)(a1 + 72))
                v39 = *(_DWORD *)(a1 + 72);
              LODWORD(v38) = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * v39);
              if (*(double *)(a1 + 1064) < (double)v38)
              {
                v40 = a1;
                v41 = 1;
                goto LABEL_70;
              }
            }
          }
          break;
        case 6:
          if (ShouldRampDown)
          {
            *(double *)(a1 + 1064) = (double)_VCRateControlAlgorithmLayeredContinuousTier_RampDown(a1);
          }
          else if (ShouldRampUp)
          {
            *(double *)(a1 + 1064) = (double)_VCRateControlAlgorithmLayeredContinuousTier_RampUp(a1);
LABEL_59:
            v40 = a1;
            v41 = 2;
LABEL_70:
            VCRateControlAlgorithmBasePriv_StateChange(v40, v41);
          }
          break;
        default:
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              _VCRateControlAlgorithmLayeredContinuousTier_DoRateControl_cold_2();
          }
          break;
      }
      _VCRateControlAlgorithmLayeredContinuousTier_UpdateTargetBitrate(a1, *(double *)(a1 + 1064));
      if (*(_DWORD *)(a1 + 1044) != 2 || *(_DWORD *)(a1 + 1048))
        *(_QWORD *)(a1 + 25584) = *(_QWORD *)(a1 + 1096);
      VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateVCRateControlHistory(a1);
      v46 = *(_QWORD *)(a1 + 1016);
      if (v46)
      {
        if (*(_BYTE *)(a1 + 1121))
          v47 = *(double *)(a1 + 1096) - *(double *)(a1 + 5192) > 0.5;
        else
          v47 = 0;
        if (*(_DWORD *)(a1 + 1040) == 1)
          v48 = v47 ^ 1;
        else
          v48 = 0;
        VCRateControlMediaController_SetShouldDisableLargeFrameRequestsWhenInitialRampUp(v46, v48);
        VCRateControlMediaController_SetRateLimitedMaxTimeExceeded(*(_QWORD *)(a1 + 1016), v47);
      }
      v147 = 0u;
      v148 = 0u;
      v145 = 0u;
      v146 = 0u;
      v143 = 0u;
      v144 = 0u;
      v141 = 0u;
      v142 = 0u;
      v139 = 0u;
      v140 = 0u;
      v137 = 0u;
      v138 = 0u;
      v135 = 0u;
      v136 = 0u;
      v133 = 0u;
      v134 = 0u;
      v131 = 0u;
      v132 = 0u;
      v130 = 0u;
      v49 = *(double *)(a1 + 1096);
      v50 = *(unsigned __int16 *)(a1 + 5186);
      v128 = 0u;
      v129 = 0u;
      v51 = *(double *)(a1 + 2856);
      v52 = *(double *)(a1 + 2864);
      v126 = 0u;
      v127 = 0u;
      v53 = *(double *)(a1 + 2872);
      v54 = *(double *)(a1 + 2880);
      memset(buf, 0, sizeof(buf));
      v55 = (int)(*(double *)(a1 + 5072) * 1000.0);
      v56 = *(_DWORD *)(a1 + 1168);
      v57 = *(double *)(a1 + 5216);
      v58 = *(double *)(a1 + 5200);
      v59 = ((v57 + v58) / 1000.0);
      v60 = (v57 / 1000.0);
      v61 = (v58 / 1000.0);
      if (*(_BYTE *)(a1 + 5104))
        v62 = 79;
      else
        v62 = 88;
      v63 = *(double *)(a1 + 5224);
      v64 = *(double *)(a1 + 5208);
      v65 = *(_DWORD *)(a1 + 4984);
      v66 = *(_DWORD *)(a1 + 1172);
      v67 = ((v63 + v64) / 1000.0);
      v68 = *(double *)(a1 + 4992) * 100.0;
      v69 = (v63 / 1000.0);
      v70 = (v64 / 1000.0);
      v71 = *(_DWORD *)(a1 + 1044);
      v72 = *(_DWORD *)(a1 + 1048);
      v73 = *(double *)(a1 + 5056) * 100.0;
      v115 = *(_DWORD *)(a1 + 1084);
      v114 = *(_DWORD *)(a1 + 5260);
      v74 = *(_DWORD *)(a1 + 1080) / 0x3E8u;
      v75 = *(double *)(a1 + 5264) * 1000.0;
      v76 = v75;
      v116 = *(_DWORD *)(a1 + 1072) / 0x3E8u;
      v77 = "ON";
      v113 = *(_DWORD *)(a1 + 5284);
      v111 = *(_DWORD *)(a1 + 5288);
      if (!*(_BYTE *)(a1 + 5280))
        v77 = "OFF";
      v110 = v77;
      v112 = *(_DWORD *)(a1 + 5256) / 0x3E8u;
      if (*(_BYTE *)(a1 + 5188))
        v78 = "S";
      else
        v78 = "U";
      v109 = v78;
      if (*(_BYTE *)(a1 + 1121))
      {
        v79 = "<";
      }
      else
      {
        v107 = ((v63 + v64) / 1000.0);
        v108 = (int)(*(double *)(a1 + 5072) * 1000.0);
        v80 = v50;
        v81 = *(_DWORD *)(a1 + 1168);
        v105 = (v64 / 1000.0);
        v106 = (v63 / 1000.0);
        v101 = v75;
        v102 = v62;
        v82 = v59;
        v83 = v60;
        v103 = *(_DWORD *)(a1 + 1044);
        v104 = *(_DWORD *)(a1 + 1080) / 0x3E8u;
        v84 = *(_DWORD *)(a1 + 4984);
        v85 = *(_DWORD *)(a1 + 1172);
        v86 = v61;
        IsVideoStopped = VCRateControlMediaController_IsVideoStopped(*(_BYTE **)(a1 + 1016));
        v61 = v86;
        v66 = v85;
        v65 = v84;
        v71 = v103;
        v74 = v104;
        v60 = v83;
        v76 = v101;
        v62 = v102;
        v59 = v82;
        v70 = v105;
        v69 = v106;
        v56 = v81;
        v50 = v80;
        v88 = !IsVideoStopped;
        v67 = v107;
        v55 = v108;
        if (v88)
          v79 = "-";
        else
          v79 = "_";
      }
      snprintf((char *)buf, 0x190uLL, "%8.3f/%04X:\t%.4f\t%.4f\t%.4f\t%.4f %c\tRTT:%-4u\tPLR:%4.2f@%.1f\tRRx:%u\tMBL:%d %u\t%4u/%4u\t %4u:%4u/%4u  %4u:%4u/%4u  CS: %05X %05X %u BB: %3u\t%4u\t%3u\t%s UAT %u\t%u\t%s\t%s\t%d\t%d\t%d\t%d\t%.3f\t%.3f\t%u\t%u\t%.3f\t%u\t%u", v49, v50, v51, v52, v53, v54, v62, v55, v68, v73, v56, v65, v66, v74, v116,
        v59,
        v60,
        v61,
        v67,
        v69,
        v70,
        v71,
        v72,
        v115,
        v112,
        v114,
        v76,
        v110,
        v113,
        v111,
        v109,
        v79,
        *(_DWORD *)(a1 + 1040),
        *(_DWORD *)(a1 + 4972) / 0x3E8u,
        *(_DWORD *)(a1 + 4976),
        *(_DWORD *)(a1 + 4968),
        *(double *)(a1 + 5136),
        *(float *)(a1 + 5296),
        *(_DWORD *)(a1 + 5300) / 0x3E8u,
        *(_DWORD *)(a1 + 5304) / 0x3E8u,
        *(double *)(a1 + 25608),
        *(double *)(a1 + 25592) / 0x3E8,
        *(_DWORD *)(a1 + 25600));
      if (*(_BYTE *)(a1 + 5128))
      {
        v95 = *(_DWORD *)(a1 + 1088);
        *(_DWORD *)(a1 + 1088) = v95 + 1;
        if ((v95 & 0xF) == 0 && (int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v96 = VRTraceErrorLogLevelToCSTR();
          v97 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)v117 = 136315906;
            v118 = v96;
            v119 = 2080;
            v120 = "_VCRateControlAlgorithmLayeredContinuousTier_PrintRateControlInfoToLogDump";
            v121 = 1024;
            v122 = 575;
            v123 = 2080;
            v124 = buf;
            _os_log_impl(&dword_1D8A54000, v97, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d %s", v117, 0x26u);
          }
        }
      }
      v98 = *(_QWORD *)(a1 + 5112);
      if (v98)
        VRLogfilePrintWithTimestamp(v98, "%s\n", v89, v90, v91, v92, v93, v94, (char)buf);
      *(_DWORD *)(a1 + 1044) = 0;
      *(_DWORD *)(a1 + 1048) = 0;
      return 1;
    }
    goto LABEL_20;
  }
  if (*(_DWORD *)(a1 + 1040))
  {
    if (*(_QWORD *)(a1 + 1016))
    {
      VCRateControlAlgorithmStabilizedNOWRDPriv_UpdateAlgorithmWithBasebandStatistics(a1, a2, a3, a4, a5, a6, a7, a8);
      if (VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampDownDueToBaseband(a1))
      {
        *(_DWORD *)(a1 + 1052) = VCRateControlAlgorithmStabilizedNOWRDPriv_RampDownTierDueToBaseband(a1, *(double *)(a1 + 5232));
        LODWORD(v31) = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * *(int *)(a1 + 1052));
        *(double *)(a1 + 1064) = (double)v31;
        VCRateControlAlgorithmBasePriv_StateChange(a1, 6);
      }
      else if (VCRateControlAlgorithmStabilizedNOWRDPriv_ShouldRampUpDueToBaseband((double *)a1))
      {
        *(_DWORD *)(a1 + 5276) = VCRateControlAlgorithmStabilizedNOWRDPriv_BasebandAdditionalTiersForRampUp(a1);
      }
      _VCRateControlAlgorithmLayeredContinuousTier_UpdateTargetBitrate(a1, *(double *)(a1 + 1064));
      if (*(_BYTE *)(a1 + 5280))
        VCRateControlMediaController_UpdateBasebandSuggestion(*(_QWORD *)(a1 + 1016), a2);
      return 1;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      return 0;
    v99 = VRTraceErrorLogLevelToCSTR();
    v100 = *MEMORY[0x1E0CF2758];
    result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
    if (result)
    {
      _VCRateControlAlgorithmLayeredContinuousTier_DoRateControl_cold_4(v99, v100);
      return 0;
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      return 0;
    VRTraceErrorLogLevelToCSTR();
    result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
    if (result)
    {
      _VCRateControlAlgorithmLayeredContinuousTier_DoRateControl_cold_3();
      return 0;
    }
  }
  return result;
}

uint64_t _VCRateControlAlgorithmLayeredContinuousTier_UpdateTargetBitrate(uint64_t result, unsigned int a2)
{
  int v2;
  int v4;
  int v5;

  v2 = *(_DWORD *)(result + 60);
  if ((v2 & 0x80000000) == 0)
  {
    while (vcRateControlTierBitrates[v2] > a2)
    {
      if (v2-- <= 0)
      {
        v2 = -1;
        break;
      }
    }
  }
  v4 = *(_DWORD *)(result + 1052);
  v5 = *(_DWORD *)(result + 64);
  if (v2 > v5)
    v5 = v2;
  *(_DWORD *)(result + 1052) = v5;
  if (*(_DWORD *)(result + 1052) < v4)
    *(_QWORD *)(result + 1144) = *(_QWORD *)(result + 1096);
  *(_DWORD *)(result + 1072) = a2;
  *(_DWORD *)(result + 1076) = vcRateControlTierBitrates[*(int *)(result + 1052)];
  return result;
}

uint64_t _VCRateControlAlgorithmLayeredContinuousTier_RampDown(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  double v8;
  unint64_t v9;
  double v10;
  long double v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  double v18;
  unint64_t v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  uint64_t result;

  VCRateControlAlgorithmStabilizedNOWRDPriv_SetBitrateUnstable(a1);
  VCRateControlAlgorithmBasePriv_UpdateCongestionStatusWhenRampDown(a1, *(double *)(a1 + 1096));
  v8 = *(double *)(a1 + 1064);
  HIDWORD(v9) = 1091294464;
  if (v8 <= 228000.0)
  {
    LODWORD(v9) = vcRateControlTierBitrates[*(int *)(a1 + 80)];
    v22 = (double)v9;
    v23 = 1.0;
    if (v8 >= v22 && (*(_BYTE *)(a1 + 1049) & 2) == 0 && !*(_BYTE *)(a1 + 419))
      v23 = 3.0;
    v24 = v23 * *(double *)(a1 + 25616);
    *(double *)(a1 + 25608) = v24;
    v25 = *(double *)(a1 + 1064);
    if (v25 >= 50000.0)
    {
      if (v25 >= 132000.0)
        v26 = 32000.0;
      else
        v26 = 16000.0;
    }
    else
    {
      v26 = 8000.0;
    }
    v27 = v8 - v26 * v24;
    LODWORD(v26) = vcRateControlTierBitrates[*(int *)(a1 + 64)];
    v28 = (double)*(unint64_t *)&v26;
    if (v27 <= v28)
      v21 = v28;
    else
      v21 = v27;
    VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "[%u] Congestion!!! New bitrate down linearly newTargetBitrate=%f, congestionSeverity=%f", v2, v3, v4, v5, v6, v7, *(_DWORD *)(a1 + 1084));
  }
  else
  {
    v10 = 1.0;
    if ((*(_BYTE *)(a1 + 1049) & 2) == 0 && !*(_BYTE *)(a1 + 419))
      v10 = 3.0;
    v11 = v10 * *(double *)(a1 + 25616);
    *(long double *)(a1 + 25608) = v11;
    v18 = v8 / pow(1.159, v11);
    LODWORD(v19) = vcRateControlTierBitrates[*(int *)(a1 + 64)];
    v20 = (double)v19;
    if (v18 <= v20)
      v21 = v20;
    else
      v21 = v18;
    VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "[%u] Congestion!!! New bitrate down exponentially to newTargetBitrate=%f, congestionSeverity=%f", v12, v13, v14, v15, v16, v17, *(_DWORD *)(a1 + 1084));
  }
  result = v21;
  *(_QWORD *)(a1 + 25616) = 0x3FF0000000000000;
  return result;
}

uint64_t _VCRateControlAlgorithmLayeredContinuousTier_RampUp(uint64_t a1)
{
  double v2;
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;

  VCRateControlAlgorithmStabilizedNOWRDPriv_SetBitrateUnstable(a1);
  VCRateControlAlgorithmBasePriv_UpdateCongestionStatusWhenRampUp(a1);
  *(_DWORD *)(a1 + 4968) = 0;
  v2 = *(double *)(a1 + 1064);
  v3 = *(double *)(a1 + 1096) - *(double *)(a1 + 25584);
  v4 = _VCRateControlAlgorithmLayeredContinuousTier_RampUpSpeedFactor(a1);
  *(double *)(a1 + 25608) = v4;
  v5 = v3 * v4;
  if (v2 <= 228000.0)
    v6 = v2 + v5 * 32000.0;
  else
    v6 = v2 * pow(1.159, v5);
  LODWORD(v5) = vcRateControlTierBitrates[*(int *)(a1 + 60)];
  v7 = (double)*(unint64_t *)&v5;
  if (v6 >= v7)
    return v7;
  return v6;
}

double _VCRateControlAlgorithmLayeredContinuousTier_RampUpSpeedFactor(uint64_t a1)
{
  double *v2;
  double v3;
  double v4;
  unsigned int v5;
  double v6;
  int v7;
  double v8;
  double v9;
  double v10;

  if (*(_DWORD *)(a1 + 1040) == 1)
  {
    v2 = (double *)(a1 + 5080);
LABEL_6:
    v3 = *v2;
    goto LABEL_7;
  }
  if (!*(_BYTE *)(a1 + 5190) || (v3 = 30.0, *(_DWORD *)(a1 + 1052) <= *(_DWORD *)(a1 + 68)))
  {
    v2 = (double *)(a1
                  + 40
                  + 8 * VCRateControlCongestionLevel_BitrateRange(*(double *)(a1 + 1064))
                  + 328);
    goto LABEL_6;
  }
LABEL_7:
  v4 = *(double *)(a1 + 1064);
  v5 = 1000 * *(_DWORD *)(a1 + 1168);
  v6 = *(double *)(a1 + 25592);
  v7 = 3;
  if (v6 == 0.0 || v4 < 76000.0 || v5 && v6 > (double)v5)
    v6 = (double)v5;
  else
    v7 = *(_DWORD *)(a1 + 25600);
  v8 = 1.0 / v3;
  v9 = v6 - v4;
  v10 = -(v6 - v4);
  if (v9 < 0.0)
    v9 = v10;
  if (v7 >= 3 && v9 < v6 * 0.15)
    v8 = v9 / (v6 * 0.15) / (double)(v7 - 2);
  return fmin(fmax(v8, 0.0166666667), 2.0);
}

uint64_t RTPGenerateSSRC()
{
  unsigned int v0;
  uint64_t result;

  do
  {
    v0 = vcvtd_n_s64_f64((double)hwrandom() * 4.65661287e-10, 0x10uLL);
    result = vcvtd_n_s64_f64((double)hwrandom() * 4.65661287e-10, 0x10uLL) | (v0 << 16);
  }
  while (!(_DWORD)result);
  return result;
}

uint64_t RTPCreateHandle(uint64_t *a1, unsigned int a2, uint64_t a3, int a4, int a5, uint64_t a6, uint64_t a7, unsigned int a8)
{
  uint64_t v9;
  char *v16;
  char *v17;
  int v18;
  uint64_t v19;
  NSObject *v20;
  int v21;
  unsigned int v22;
  unsigned int v23;
  _QWORD *v24;
  const __CFAllocator *v25;
  const __CFAllocator *v26;
  OSStatus v27;
  uint64_t Handle;
  uint64_t v29;
  int v30;
  uint64_t v31;
  NSObject *v32;
  int v34;
  const void *v35;
  OSQueueHead *v36;
  const void *v37;
  const void *v38;
  const void *v39;
  const void *v40;
  CMBlockBufferRef blockBufferOut;
  __int128 v42;
  uint8_t buf[4];
  uint64_t v44;
  __int16 v45;
  const char *v46;
  __int16 v47;
  int v48;
  __int16 v49;
  char *v50;
  __int16 v51;
  unsigned int v52;
  __int16 v53;
  int v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  if (a2 >= 2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      return 2147549199;
    VRTraceErrorLogLevelToCSTR();
    v9 = 2147549199;
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      RTPCreateHandle_cold_1();
    return v9;
  }
  v16 = (char *)malloc_type_calloc(1uLL, 0x6BE0uLL, 0x10F00409C7AC759uLL);
  if (v16)
  {
    v17 = v16;
    *((_DWORD *)v16 + 2) = -1;
    *(_QWORD *)v16 = 0xFFFFFFFF00000001;
    *((_WORD *)v16 + 8) = 128;
    *((_QWORD *)v16 + 8) = RTPMapCreate();
    *((_DWORD *)v17 + 7) = a2;
    *((_QWORD *)v17 + 1298) = a6;
    *((_QWORD *)v17 + 1299) = a7;
    *((_DWORD *)v17 + 38) = -1;
    *((_DWORD *)v17 + 2600) = a5;
    *((_DWORD *)v17 + 1750) = 3;
    *((_QWORD *)v17 + 23) = 1;
    *(_OWORD *)(v17 + 10424) = 0u;
    *((_QWORD *)v17 + 1306) = 0;
    *((_QWORD *)v17 + 1305) = 0;
    *(_OWORD *)(v17 + 168) = xmmword_1D910B1F0;
    *((_DWORD *)v17 + 2622) = -1;
    *((_DWORD *)v17 + 2662) = -1;
    *((_DWORD *)v17 + 6900) = 0;
    *((_DWORD *)v17 + 2211) = 0;
    bzero(v17 + 7080, 0x6E0uLL);
    *((_DWORD *)v17 + 179) = 1;
    if (!*((_WORD *)v17 + 96))
    {
      do
      {
        v18 = hwrandom16();
        *((_WORD *)v17 + 96) = v18;
      }
      while (!v18);
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      v19 = VRTraceErrorLogLevelToCSTR();
      v20 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v21 = *((unsigned __int16 *)v17 + 96);
        *(_DWORD *)buf = 136316418;
        v44 = v19;
        v45 = 2080;
        v46 = "RTPCreateHandle";
        v47 = 1024;
        v48 = 216;
        v49 = 2048;
        v50 = v17;
        v51 = 1024;
        v52 = a2;
        v53 = 1024;
        v54 = v21;
        _os_log_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d %p Starting SeqNum for PayloadType %d = %d", buf, 0x32u);
      }
    }
    if (!a8)
      a8 = RTPGenerateSSRC();
    *((_DWORD *)v17 + 50) = a8;
    v22 = *((_DWORD *)v17 + 49);
    if (a4 && !v22)
    {
      do
      {
        v23 = hwrandom();
        v22 = vcvtd_n_s64_f64((double)hwrandom() * 4.65661287e-10, 0x10uLL) | (vcvtd_n_s64_f64((double)v23* 4.65661287e-10, 0x10uLL) << 16);
        *((_DWORD *)v17 + 49) = v22;
      }
      while (!v22);
      a8 = *((_DWORD *)v17 + 50);
    }
    *((_QWORD *)v17 + 37) = 0;
    *((_QWORD *)v17 + 3451) = 0x3FF0000000000000;
    *((_QWORD *)v17 + 29) = v22;
    *((_QWORD *)v17 + 30) = v22;
    *((_QWORD *)v17 + 31) = v22;
    *((_QWORD *)v17 + 32) = v22;
    *((_DWORD *)v17 + 79) = 24000;
    *((_DWORD *)v17 + 6) = bswap32(a8);
    pthread_mutex_init((pthread_mutex_t *)(v17 + 7016), 0);
    v24 = VCMemoryPool_Create(0x17B0uLL);
    *((_QWORD *)v17 + 1309) = v24;
    if (v24)
    {
      v25 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      if (VCAllocatorFirstCome_Create((const __CFAllocator *)*MEMORY[0x1E0C9AE00], (uint64_t)"RTCPPacketAllocator", (CFAllocatorRef *)v17 + 1330))
      {
        v9 = 2147549187;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            RTPCreateHandle_cold_9();
        }
      }
      else if (VCAllocatorFirstCome_Create(v25, (uint64_t)"RTCPBlockBufferHeaderAllocator", (CFAllocatorRef *)v17 + 1310))
      {
        v9 = 2147549187;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            RTPCreateHandle_cold_8();
        }
      }
      else if (VCAllocatorFirstCome_Create(v25, (uint64_t)"RTPPacketBlockBufferAllocator", (CFAllocatorRef *)v17 + 1350))
      {
        v9 = 2147549187;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            RTPCreateHandle_cold_7();
        }
      }
      else
      {
        v26 = (const __CFAllocator *)*((_QWORD *)v17 + 1350);
        blockBufferOut = 0;
        v27 = CMBlockBufferCreateWithMemoryBlock(v26, 0, 0x5DCuLL, 0, 0, 0, 0x5DCuLL, 1u, &blockBufferOut);
        if (v27)
        {
          if (v27 >= 0)
            v34 = v27;
          else
            v34 = -v27;
          v9 = v34 | 0xD0010000;
        }
        else
        {
          if (blockBufferOut)
          {
            CFRelease(blockBufferOut);
            blockBufferOut = 0;
          }
          if (VCAllocatorFirstCome_Create(v25, (uint64_t)"channelDataFormatAllocator", (CFAllocatorRef *)v17 + 1352))
          {
            v9 = 2147549187;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                RTPCreateHandle_cold_6();
            }
          }
          else
          {
            v42 = xmmword_1D910B220;
            if (VCAllocatorMultiQueue_Create(v25, (uint64_t)"RTPPacketMetadataAllocator", 2u, (unint64_t *)&v42, (CFAllocatorRef *)v17 + 1351))
            {
              v9 = 2147549187;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  RTPCreateHandle_cold_5();
              }
            }
            else
            {
              Handle = CreateHandle();
              if (Handle != 0xFFFFFFFFLL)
              {
                v29 = Handle;
                *((_QWORD *)v17 + 1294) = 0xFFFFFFFFLL;
                *((_QWORD *)v17 + 1295) = 0xFFFFFFFFLL;
                *((_QWORD *)v17 + 1296) = 0;
                *((_DWORD *)v17 + 2594) = 0;
                *((_DWORD *)v17 + 2616) = -1;
                if (VCDefaults_GetBoolValueForKey(CFSTR("enableLTRPLogging"), 0))
                  v30 = 7;
                else
                  v30 = 8;
                *((_DWORD *)v17 + 2614) = v30;
                *((_QWORD *)v17 + 1395) = 0;
                *((_QWORD *)v17 + 1396) = v17 + 11160;
                *((_QWORD *)v17 + 1397) = 0;
                *((_QWORD *)v17 + 1398) = v17 + 11176;
                *((_QWORD *)v17 + 1399) = 0;
                bzero(v17 + 11208, 0x4000uLL);
                v9 = 0;
                *a1 = v29;
                return v9;
              }
              v9 = 2147549189;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                {
                  RTPCreateHandle_cold_4();
                  v9 = 2147549189;
                }
              }
            }
          }
        }
      }
    }
    else
    {
      v9 = 2147549187;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          RTPCreateHandle_cold_3();
      }
    }
    pthread_mutex_destroy((pthread_mutex_t *)(v17 + 7016));
    v35 = (const void *)*((_QWORD *)v17 + 1330);
    if (v35)
      CFRelease(v35);
    v36 = (OSQueueHead *)*((_QWORD *)v17 + 1309);
    if (v36)
      VCMemoryPool_Destroy(v36);
    v37 = (const void *)*((_QWORD *)v17 + 1310);
    if (v37)
      CFRelease(v37);
    v38 = (const void *)*((_QWORD *)v17 + 1350);
    if (v38)
      CFRelease(v38);
    v39 = (const void *)*((_QWORD *)v17 + 1352);
    if (v39)
      CFRelease(v39);
    v40 = (const void *)*((_QWORD *)v17 + 1351);
    if (v40)
      CFRelease(v40);
    free(v17);
  }
  else
  {
    v9 = 2147549187;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v31 = VRTraceErrorLogLevelToCSTR();
      v32 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RTPCreateHandle_cold_2(v31, v32);
    }
  }
  return v9;
}

uint64_t RTPGetTimestampBase()
{
  uint64_t v0;
  uint64_t v1;

  v0 = CheckInHandleDebug();
  if (!v0)
    return 0;
  v1 = *(unsigned int *)(v0 + 196);
  CheckOutHandleDebug();
  return v1;
}

void RTPCloseHandle()
{
  uint64_t v0;
  unint64_t v1;
  int v2;
  int v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  int v13;
  unsigned int v14;
  void *v15;
  void *v16;
  void *v17;
  const void *v18;
  const void *v19;
  const void *v20;
  const void *v21;
  const void *v22;
  const void *v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  const void *v34;
  const void *v35;
  const void *v36;
  const void *v37;
  const void *v38;
  uint64_t v39;
  _BYTE buf[12];
  __int16 v41;
  const char *v42;
  __int16 v43;
  int v44;
  __int16 v45;
  uint64_t v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  v0 = CheckInHandleDebug();
  if (!v0)
    return;
  v1 = v0;
  _RTPUnregisterPacketCallback(v0);
  _RTCPUnregisterPacketCallback(v1);
  v2 = *(_DWORD *)(v1 + 4);
  if (v2 != -1)
    VTP_Close(v2);
  v3 = *(_DWORD *)(v1 + 8);
  if (v3 != -1)
    VTP_Close(v3);
  CheckOutHandleDebug();
  if (*(_QWORD *)(v1 + 10424))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v4 = VRTraceErrorLogLevelToCSTR();
      v5 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v6 = *(_QWORD *)(v1 + 10424);
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = v4;
        v41 = 2080;
        v42 = "RTPCloseHandle";
        v43 = 1024;
        v44 = 406;
        v45 = 2048;
        v46 = v6;
        _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Releasing the statisticsCollector:%p", buf, 0x26u);
      }
    }
    CFRelease(*(CFTypeRef *)(v1 + 10424));
  }
  if (*(_QWORD *)(v1 + 10432))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v7 = VRTraceErrorLogLevelToCSTR();
      v8 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v9 = *(_QWORD *)(v1 + 10432);
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = v7;
        v41 = 2080;
        v42 = "RTPCloseHandle";
        v43 = 1024;
        v44 = 410;
        v45 = 2048;
        v46 = v9;
        _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Releasing the basebandCongestionDetector:%p", buf, 0x26u);
      }
    }
    CFRelease(*(CFTypeRef *)(v1 + 10432));
  }
  if (*(_QWORD *)(v1 + 10440))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v10 = VRTraceErrorLogLevelToCSTR();
      v11 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v12 = *(_QWORD *)(v1 + 10440);
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = v10;
        v41 = 2080;
        v42 = "RTPCloseHandle";
        v43 = 1024;
        v44 = 414;
        v45 = 2048;
        v46 = v12;
        _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Releasing the mediaQueue:%p", buf, 0x26u);
      }
    }
    CFRelease(*(CFTypeRef *)(v1 + 10440));
  }
  if (v1 >= v1 + 27616)
  {
    __break(0x5519u);
    return;
  }
  v13 = 0;
  do
  {
    v14 = (unsigned __int16)v13;
    _RTPTransportMediaPacketHistoryCleanUp(v1, (unsigned __int16)v13++);
  }
  while (v14 < 0x3FF);
  if (*(_DWORD *)(v1 + 28) <= 1u)
  {
    pthread_mutex_destroy((pthread_mutex_t *)(v1 + 7016));
    SRTPCleanUp(v1 + 7080);
    SRTPCleanUp(v1 + 7520);
    SRTPCleanUp(v1 + 7960);
    SRTPCleanUp(v1 + 8400);
    v15 = *(void **)(v1 + 40);
    if (v15)
    {
      free(v15);
      *(_QWORD *)(v1 + 40) = 0;
      *(_DWORD *)(v1 + 32) = 0;
    }
    v16 = *(void **)(v1 + 56);
    if (v16)
    {
      free(v16);
      *(_QWORD *)(v1 + 56) = 0;
      *(_DWORD *)(v1 + 48) = 0;
    }
  }
  if (*(_QWORD *)(v1 + 64))
    RTPMapDestroy((void **)(v1 + 64));
  v17 = *(void **)(v1 + 80);
  if (v17)
    free(v17);
  v18 = *(const void **)(v1 + 10448);
  if (v18)
    CFRelease(v18);
  _RTPClearTransportStreamsInternal((_QWORD *)v1);
  v19 = *(const void **)(v1 + 11128);
  if (v19)
    CFRelease(v19);
  v20 = *(const void **)(v1 + 11136);
  if (v20)
    CFRelease(v20);
  v21 = *(const void **)(v1 + 11144);
  if (v21)
    CFRelease(v21);
  v22 = *(const void **)(v1 + 11152);
  if (v22)
    CFRelease(v22);
  v23 = *(const void **)(v1 + 11192);
  if (v23)
    CFRelease(v23);
  v24 = *(_QWORD *)(v1 + 11160);
  *(_QWORD *)buf = v24;
  if (!v24)
    goto LABEL_55;
  v25 = (uint64_t *)(v1 + 11160);
  while (1)
  {
    v26 = *(_QWORD *)(v24 + 6056);
    v27 = *v25;
    if (*v25 != v24)
      break;
    *v25 = v26;
    if (!v26)
      goto LABEL_54;
LABEL_52:
    _RTPReleaseRTPPacketInternal(v1, (_DWORD **)buf);
    *(_QWORD *)buf = v26;
    v24 = v26;
  }
  do
  {
    v28 = v27;
    v27 = *(_QWORD *)(v27 + 6056);
  }
  while (v27 != v24);
  *(_QWORD *)(v28 + 6056) = v26;
  if (v26)
    goto LABEL_52;
  v25 = (uint64_t *)(v28 + 6056);
LABEL_54:
  *(_QWORD *)(v1 + 11168) = v25;
  _RTPReleaseRTPPacketInternal(v1, (_DWORD **)buf);
  *(_QWORD *)buf = v26;
LABEL_55:
  v29 = *(_QWORD *)(v1 + 11176);
  v39 = v29;
  if (!v29)
    goto LABEL_64;
  v30 = (uint64_t *)(v1 + 11176);
  while (2)
  {
    v31 = *(_QWORD *)(v29 + 1632);
    v32 = *v30;
    if (*v30 == v29)
    {
      *v30 = v31;
      if (!v31)
        goto LABEL_63;
      goto LABEL_62;
    }
    do
    {
      v33 = v32;
      v32 = *(_QWORD *)(v32 + 1632);
    }
    while (v32 != v29);
    *(_QWORD *)(v33 + 1632) = v31;
    if (v31)
    {
LABEL_62:
      _RTCPPacketForget(v1, (uint64_t)&v39);
      v39 = v31;
      v29 = v31;
      continue;
    }
    break;
  }
  v30 = (uint64_t *)(v33 + 1632);
LABEL_63:
  *(_QWORD *)(v1 + 11184) = v30;
  _RTCPPacketForget(v1, (uint64_t)&v39);
  v39 = v31;
LABEL_64:
  v34 = *(const void **)(v1 + 10640);
  if (v34)
    CFRelease(v34);
  VCMemoryPool_Destroy(*(OSQueueHead **)(v1 + 10472));
  v35 = *(const void **)(v1 + 10480);
  if (v35)
    CFRelease(v35);
  v36 = *(const void **)(v1 + 10800);
  if (v36)
    CFRelease(v36);
  v37 = *(const void **)(v1 + 10816);
  if (v37)
    CFRelease(v37);
  v38 = *(const void **)(v1 + 10808);
  if (v38)
    CFRelease(v38);
  free((void *)v1);
}

void _RTPUnregisterPacketCallback(uint64_t a1)
{
  int v2;

  if (*(_QWORD *)(a1 + 10504))
  {
    v2 = *(_DWORD *)(a1 + 10488);
    if (v2 == -1)
    {
      if (*(_QWORD *)(a1 + 11104))
        _RTPEnsureTransportStreamsDeactivated(a1);
    }
    else
    {
      VTP_UnregisterPacketCallback(v2);
      *(_DWORD *)(a1 + 10488) = -1;
    }
    _Block_release(*(const void **)(a1 + 10504));
    *(_QWORD *)(a1 + 10504) = 0;
    *(_QWORD *)(a1 + 10496) = 0;
  }
}

uint64_t _RTPClearTransportStreamsInternal(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  int v11;
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v2 = _RTPEnsureTransportStreamsDeactivated((uint64_t)a1);
  if ((v2 & 0x80000000) != 0 && (int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v3 = VRTraceErrorLogLevelToCSTR();
    v4 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v11 = 136315906;
      v12 = v3;
      v13 = 2080;
      v14 = "_RTPClearTransportStreamsInternal";
      v15 = 1024;
      v16 = 5514;
      v17 = 1024;
      v18 = v2;
      _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d _RTPEnsureTransportStreamsDeactivated failed %d", (uint8_t *)&v11, 0x22u);
    }
  }
  v5 = (const void *)a1[1388];
  if (v5)
  {
    CFRelease(v5);
    a1[1388] = 0;
  }
  v6 = (const void *)a1[1389];
  if (v6)
  {
    CFRelease(v6);
    a1[1389] = 0;
  }
  v7 = (const void *)a1[1390];
  if (v7)
  {
    CFRelease(v7);
    a1[1390] = 0;
  }
  v8 = (const void *)a1[984];
  if (v8)
  {
    CFRelease(v8);
    a1[984] = 0;
  }
  v9 = (const void *)a1[985];
  if (v9)
  {
    CFRelease(v9);
    a1[985] = 0;
  }
  return v2;
}

void _RTPReleaseRTPPacketInternal(uint64_t a1, _DWORD **a2)
{
  _DWORD *v2;

  if (a2)
  {
    v2 = *a2;
    *a2 = 0;
    if (v2)
    {
      if (!*v2)
      {
        VCBlockBuffer_Clear((uint64_t)(v2 + 32));
        VCBlockBuffer_Clear((uint64_t)(v2 + 38));
        VCBlockBuffer_Clear((uint64_t)(v2 + 44));
      }
      if (v2 >= v2 + 1516)
        __break(0x5519u);
      else
        VCMemoryPool_Free(*(OSQueueHead **)(a1 + 10472), v2);
    }
  }
}

uint64_t RTPGetJitter(uint64_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t v4;
  uint64_t v8;

  v4 = 2147549185;
  if (a2 && a3 && a4)
  {
    v8 = CheckInHandleDebug();
    if (v8)
    {
      *a2 = *(_DWORD *)(v8 + 4828);
      *a3 = *(_DWORD *)(v8 + 6776);
      *a4 = vcvtad_u64_f64(*(double *)(v8 + 6784));
      CheckOutHandleDebug();
      return 0;
    }
    else
    {
      return 2147549186;
    }
  }
  return v4;
}

uint64_t RTPGetPacketSent(uint64_t a1, _DWORD *a2)
{
  uint64_t v2;
  uint64_t v4;

  v2 = 2147549185;
  if (a2)
  {
    v4 = CheckInHandleDebug();
    if (v4)
    {
      *a2 = *(_DWORD *)(v4 + 204);
      CheckOutHandleDebug();
      return 0;
    }
    else
    {
      return 2147549186;
    }
  }
  return v2;
}

uint64_t RTPSetAudioReceiver(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2147549186;
  *(_QWORD *)(v3 + 10416) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t RTPSetWRMInfo(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;

  v2 = 2147549185;
  if (a2)
  {
    v4 = CheckInHandleDebug();
    if (v4)
    {
      *(_QWORD *)(v4 + 10408) = a2;
      CheckOutHandleDebug();
      return 0;
    }
    else
    {
      return 2147549186;
    }
  }
  return v2;
}

uint64_t RTPGetPacketLossMetrics(uint64_t a1, unsigned int *a2, unsigned int *a3, unsigned int *a4)
{
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  _BOOL4 v14;
  int v16;
  uint64_t v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  unsigned int v23;
  __int16 v24;
  unsigned int v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v7 = CheckInHandleDebug();
  if (!v7)
    return 2147549186;
  if (*(_DWORD *)(v7 + 7004))
  {
    v8 = *(_DWORD *)(v7 + 704) - *(_DWORD *)(v7 + 712);
    v9 = *(_DWORD *)(v7 + 692) - (*(_DWORD *)(v7 + 708) + *(unsigned __int16 *)(v7 + 688)) + 1;
    if (a2)
      *a2 = v8;
    if (a3)
      *a3 = v9;
    if (!a4)
      goto LABEL_19;
    v10 = v9 - v8;
    if (v9 >= v8)
      goto LABEL_18;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v11 = VRTraceErrorLogLevelToCSTR();
      v12 = *MEMORY[0x1E0CF2758];
      v13 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
        v10 = 0;
        if (!v14)
        {
LABEL_18:
          *a4 = v10;
          goto LABEL_19;
        }
        v16 = 136316162;
        v17 = v11;
        v18 = 2080;
        v19 = "RTPGetPacketLossMetrics";
        v20 = 1024;
        v21 = 587;
        v22 = 1024;
        v23 = v8;
        v24 = 1024;
        v25 = v9;
        _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Negative packetsLostForInterval detected. receivedForInterval=%d expectedForInterval=%d. Reset to 0", (uint8_t *)&v16, 0x28u);
      }
      else if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        v16 = 136316162;
        v17 = v11;
        v18 = 2080;
        v19 = "RTPGetPacketLossMetrics";
        v20 = 1024;
        v21 = 587;
        v22 = 1024;
        v23 = v8;
        v24 = 1024;
        v25 = v9;
        _os_log_debug_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Negative packetsLostForInterval detected. receivedForInterval=%d expectedForInterval=%d. Reset to 0", (uint8_t *)&v16, 0x28u);
      }
    }
    v10 = 0;
    goto LABEL_18;
  }
  *a2 = 0;
  *a3 = 0;
  *a4 = 0;
LABEL_19:
  CheckOutHandleDebug();
  return 0;
}

uint64_t RTPResetHandle()
{
  uint64_t v0;

  v0 = CheckInHandleDebug();
  if (!v0)
    return 2147549186;
  RTPReset(v0, *(_DWORD *)(v0 + 4832));
  CheckOutHandleDebug();
  return 0;
}

void RTPReset(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  int v7;
  uint64_t v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v4 = a1 + 6480;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v5 = VRTraceErrorLogLevelToCSTR();
    v6 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v7 = 136315906;
      v8 = v5;
      v9 = 2080;
      v10 = "RTPReset";
      v11 = 1024;
      v12 = 603;
      v13 = 1024;
      v14 = a2;
      _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d SSRC:%X", (uint8_t *)&v7, 0x22u);
    }
  }
  *(_WORD *)(a1 + 688) = 0;
  *(_QWORD *)(a1 + 692) = 0;
  *(_QWORD *)(a1 + 704) = 0;
  *(_DWORD *)(a1 + 712) = 0;
  *(_QWORD *)(a1 + 4816) = 0;
  *(_DWORD *)(a1 + 4828) = 0;
  *(_DWORD *)(a1 + 4832) = a2;
  *(_QWORD *)(a1 + 4852) = 0;
  *(_QWORD *)(a1 + 4840) = 0;
  *(_QWORD *)(a1 + 6472) = 0x800000007FFFFFFFLL;
  *(_WORD *)v4 = 255;
  *(_QWORD *)(a1 + 6488) = 0;
  *(_DWORD *)(a1 + 7004) = 0;
  *(_DWORD *)(a1 + 10464) = -1;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 8844));
  *(_BYTE *)(v4 + 2360) = 0;
  *(_DWORD *)(a1 + 7640) = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 8844));
  *(_WORD *)(a1 + 7650) = 0;
}

uint64_t RTPResetDecryptionStatus()
{
  uint64_t v0;

  v0 = CheckInHandleDebug();
  if (!v0)
    return 2147549186;
  *(_DWORD *)(v0 + 10464) = -1;
  CheckOutHandleDebug();
  return 0;
}

uint64_t RTPSetDestinationWithToken(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  int v9;
  int v11;
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v5 = CheckInHandleDebug();
  if (!v5)
    return 2147549186;
  v6 = v5;
  *(_DWORD *)(v5 + 144) = a3;
  VTP_SetSourceDestinationWithToken(*(_DWORD *)(v5 + 4), a2);
  VTP_SetSourceDestinationWithToken(*(_DWORD *)(v6 + 8), a2);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v7 = VRTraceErrorLogLevelToCSTR();
    v8 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v9 = *(_DWORD *)(v6 + 28);
      v11 = 136316162;
      v12 = v7;
      v13 = 2080;
      v14 = "RTPSetDestinationWithToken";
      v15 = 1024;
      v16 = 683;
      v17 = 1024;
      v18 = v9;
      v19 = 1024;
      v20 = a2;
      _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTP/RTCP Destination for PT%d = [IDS datagram channel token %u]", (uint8_t *)&v11, 0x28u);
    }
  }
  CheckOutHandleDebug();
  return 0;
}

uint64_t RTPSetDestination(uint64_t a1, int a2, const char *a3, int a4, int a5, int a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t result;
  sockaddr *ai_addr;
  sockaddr *v19;
  uint64_t v20;
  NSObject *v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  NSObject *v26;
  uint64_t v27;
  NSObject *v28;
  addrinfo *v29;
  addrinfo v30;
  char v31[8];
  uint8_t buf[4];
  uint64_t v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  int v37;
  __int16 v38;
  int v39;
  __int16 v40;
  _BYTE v41[20];
  _DWORD v42[4];
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  memset(v31, 170, 6);
  v29 = 0;
  v13 = CheckInHandleDebug();
  if (!v13)
    return 2147549186;
  v14 = v13;
  if (!a7)
    *(_DWORD *)(v13 + 144) = a6;
  *(_DWORD *)(v13 + 12) = a2;
  memset(&v30, 0, sizeof(v30));
  if (a2)
    v15 = 30;
  else
    v15 = 2;
  v30.ai_family = v15;
  v30.ai_socktype = 2;
  __sprintf_chk(v31, 0, 6uLL, "%u", a4);
  v16 = getaddrinfo(a3, v31, &v30, &v29);
  if (v16 == -1 || !v29)
  {
    v24 = v16 | 0xB0010000;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v25 = VRTraceErrorLogLevelToCSTR();
      v26 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136316674;
        v33 = v25;
        v34 = 2080;
        v35 = "RTPSetDestination";
        v36 = 1024;
        v37 = 718;
        v38 = 1024;
        v39 = 718;
        v40 = 2080;
        *(_QWORD *)v41 = a3;
        *(_WORD *)&v41[8] = 2080;
        *(_QWORD *)&v41[10] = v31;
        *(_WORD *)&v41[18] = 1024;
        v42[0] = v24;
        _os_log_error_impl(&dword_1D8A54000, v26, OS_LOG_TYPE_ERROR, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/RTPTransport.c:%d: getaddrinfo(%s,%s) failed(%08X)", buf, 0x3Cu);
      }
    }
    goto LABEL_29;
  }
  result = *(unsigned int *)(v14 + 4);
  ai_addr = v29->ai_addr;
  if (!ai_addr || ai_addr < (sockaddr *)((char *)ai_addr + v29->ai_addrlen))
  {
    VTP_SetSourceDestinationWithIPPort(result);
    freeaddrinfo(v29);
    __sprintf_chk(v31, 0, 6uLL, "%u", a5);
    if (getaddrinfo(a3, v31, &v30, &v29) == -1)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      {
        v24 = 0xFFFFFFFFLL;
      }
      else
      {
        v27 = VRTraceErrorLogLevelToCSTR();
        v28 = *MEMORY[0x1E0CF2758];
        v24 = 0xFFFFFFFFLL;
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136316674;
          v33 = v27;
          v34 = 2080;
          v35 = "RTPSetDestination";
          v36 = 1024;
          v37 = 734;
          v38 = 1024;
          v39 = 734;
          v40 = 2080;
          *(_QWORD *)v41 = a3;
          *(_WORD *)&v41[8] = 2080;
          *(_QWORD *)&v41[10] = v31;
          *(_WORD *)&v41[18] = 1024;
          v42[0] = -1;
          _os_log_error_impl(&dword_1D8A54000, v28, OS_LOG_TYPE_ERROR, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/RTPTransport.c:%d: getaddrinfo(%s,%s) failed(%08X)", buf, 0x3Cu);
        }
      }
      goto LABEL_29;
    }
    result = *(unsigned int *)(v14 + 8);
    v19 = v29->ai_addr;
    if (!v19 || v19 < (sockaddr *)((char *)v19 + v29->ai_addrlen))
    {
      VTP_SetSourceDestinationWithIPPort(result);
      freeaddrinfo(v29);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v20 = VRTraceErrorLogLevelToCSTR();
        v21 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v22 = *(_DWORD *)(v14 + 28);
          *(_DWORD *)buf = 136316930;
          v33 = v20;
          v34 = 2080;
          v35 = "RTPSetDestination";
          v36 = 1024;
          v37 = 745;
          v38 = 1024;
          v39 = v22;
          v40 = 1024;
          *(_DWORD *)v41 = a7;
          *(_WORD *)&v41[4] = 2080;
          *(_QWORD *)&v41[6] = a3;
          *(_WORD *)&v41[14] = 1024;
          *(_DWORD *)&v41[16] = a4;
          LOWORD(v42[0]) = 1024;
          *(_DWORD *)((char *)v42 + 2) = a5;
          _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTP/RTCP Destination for PT%d(%d) = [%s:%u/%u]", buf, 0x3Eu);
        }
      }
      v23 = *(_QWORD *)(v14 + 10352);
      if (v23 != 0xFFFFFFFFLL)
        MediaQueue_SetThrottlingIsIPv6(v23, *(_DWORD *)(v14 + 12) != 0);
      v24 = 0;
LABEL_29:
      CheckOutHandleDebug();
      return v24;
    }
  }
  __break(0x5519u);
  return result;
}

uint64_t RTPPayloads_PayloadProperties(int a1, int a2, uint64_t a3, int a4, int a5, _DWORD *a6, int *a7, _DWORD *a8, int *a9)
{
  uint64_t v9;
  int *v10;
  uint64_t result;
  int v12;
  int v13;
  BOOL v14;
  int v15;

  v9 = 0x10u;
  while (1)
  {
    v10 = (int *)((char *)&g_payloadInfo + v9);
    if (*(_DWORD *)((char *)&g_payloadInfo + v9 - 16) == a5)
      break;
    v9 += 20;
    if (v9 == 496)
      return 2147549199;
  }
  v12 = *(v10 - 2);
  v13 = *v10;
  if (a5 > 118)
  {
    if (a5 == 119)
    {
      if (a4)
      {
        v12 = a4;
        v13 = a4 | 0x200000;
      }
      goto LABEL_23;
    }
    if (a5 != 123 && a5 != 126)
      goto LABEL_23;
LABEL_12:
    if (a7)
      v14 = a2 == 0;
    else
      v14 = 1;
    if (v14)
      v12 = 8000;
    else
      v12 = 90000;
    goto LABEL_23;
  }
  if (a5 == 3)
  {
    if (a1)
      v13 = 458753;
    else
      v13 = 458754;
    goto LABEL_23;
  }
  if (a5 == 100)
    goto LABEL_12;
LABEL_23:
  v15 = *(v10 - 1);
  if (a6)
    *a6 = *(v10 - 3);
  if (a7)
    *a7 = v12;
  if (a8)
  {
    if (v15 == -1)
      v15 = *(_DWORD *)(a3 + 40);
    *a8 = v15;
  }
  result = 0;
  if (a9)
    *a9 = v13;
  return result;
}

uint64_t RTPSetRTCPFB(uint64_t a1, int a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2147549186;
  *(_DWORD *)(v3 + 148) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t RTPSetTxPayloadList(uint64_t a1, int a2, const void *a3)
{
  uint64_t v3;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  void *v10;
  void *v11;

  v3 = 2147549187;
  result = 2147549185;
  if (a2 >= 1 && a3)
  {
    v7 = CheckInHandleDebug();
    if (v7)
    {
      v8 = v7;
      v9 = *(void **)(v7 + 56);
      if (v9)
      {
        free(v9);
        *(_QWORD *)(v8 + 56) = 0;
        *(_DWORD *)(v8 + 48) = 0;
      }
      v10 = malloc_type_malloc(4 * a2, 0x2E3CE8E9uLL);
      if (v10)
      {
        v11 = v10;
        memcpy(v10, a3, 4 * a2);
        v3 = 0;
        *(_QWORD *)(v8 + 56) = v11;
        *(_DWORD *)(v8 + 48) = a2;
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          RTPSetTxPayloadList_cold_1();
      }
      CheckOutHandleDebug();
      return v3;
    }
    else
    {
      return 2147549186;
    }
  }
  return result;
}

uint64_t RTPSetRxPayloadList(uint64_t a1, int a2, const void *a3)
{
  uint64_t v3;
  uint64_t v6;
  unint64_t v7;
  void *v8;
  void *v9;
  const void *v10;
  uint64_t result;
  CFIndex v12;
  const __CFAllocator *v13;
  CFMutableArrayRef Mutable;
  uint64_t v15;
  __CFArray *v16;
  uint64_t v17;
  uint64_t v18;
  CFNumberRef v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t CMBaseObject;
  uint64_t (*v23)(uint64_t, const __CFString *, __CFArray *);
  uint64_t v24;

  v3 = 2147549185;
  if (a2 < 1 || !a3)
    return v3;
  v6 = CheckInHandleDebug();
  if (!v6)
    return 2147549186;
  v7 = v6;
  v8 = *(void **)(v6 + 40);
  if (v8)
  {
    free(v8);
    *(_QWORD *)(v7 + 40) = 0;
    *(_DWORD *)(v7 + 32) = 0;
  }
  v9 = malloc_type_malloc(4 * a2, 0x100004052888210uLL);
  if (!v9)
  {
    v24 = 2147549187;
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      goto LABEL_25;
    VRTraceErrorLogLevelToCSTR();
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      goto LABEL_25;
    RTPSetRxPayloadList_cold_1();
    goto LABEL_30;
  }
  v10 = v9;
  memcpy(v9, a3, 4 * a2);
  *(_QWORD *)(v7 + 40) = v10;
  *(_DWORD *)(v7 + 32) = a2;
  result = *(unsigned int *)(v7 + 4);
  if ((_DWORD)result != -1)
    result = VTP_SetPayloadList(result, a2, v10);
  if (v7 < v7 + 27616)
  {
    if (*(_QWORD *)(v7 + 40))
    {
      v12 = *(int *)(v7 + 32);
      if ((int)v12 > 0)
      {
        v13 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v12, MEMORY[0x1E0C9B378]);
        if (Mutable)
        {
          v16 = Mutable;
          if (*(int *)(v7 + 32) >= 1)
          {
            v17 = 0;
            v18 = 0;
            do
            {
              v19 = CFNumberCreate(v13, kCFNumberIntType, (const void *)(*(_QWORD *)(v7 + 40) + v17));
              CFArrayAppendValue(v16, v19);
              CFRelease(v19);
              ++v18;
              v17 += 4;
            }
            while (v18 < *(int *)(v7 + 32));
          }
          v20 = *(_QWORD *)(v7 + 11128);
          if (!v20)
          {
            v21 = VCPacketFilterRTPCreate((uint64_t)v13, (_QWORD *)(v7 + 11128));
            if ((v21 & 0x80000000) != 0)
              goto LABEL_21;
            v20 = *(_QWORD *)(v7 + 11128);
          }
          CMBaseObject = VCPacketFilterGetCMBaseObject(v20, v15);
          v23 = *(uint64_t (**)(uint64_t, const __CFString *, __CFArray *))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                               + 8)
                                                                                   + 56);
          if (!v23)
          {
            v24 = 4294954514;
            goto LABEL_24;
          }
          v21 = v23(CMBaseObject, CFSTR("RTPPayloadList"), v16);
LABEL_21:
          v24 = v21;
LABEL_24:
          CFRelease(v16);
LABEL_25:
          CheckOutHandleDebug();
          return v24;
        }
LABEL_30:
        v24 = 2147549187;
        goto LABEL_25;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          RTPSetRxPayloadList_cold_3();
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RTPSetRxPayloadList_cold_2();
    }
    v24 = 2147549185;
    goto LABEL_25;
  }
  __break(0x5519u);
  return result;
}

uint64_t RTPAddMappingForPayload(uint64_t a1, int a2, int a3, int a4)
{
  uint64_t v7;
  uint64_t v8;

  v7 = CheckInHandleDebug();
  if (!v7)
    return 2147549186;
  v8 = v7;
  RTPMapAddMappingForPayload(*(char ***)(v7 + 64), a2, a3, a4);
  RTPMapPrintMapping(*(_QWORD *)(v8 + 64));
  CheckOutHandleDebug();
  return 0;
}

uint64_t RTPResetPayloadMapping()
{
  uint64_t v0;

  v0 = CheckInHandleDebug();
  if (!v0)
    return 2147549186;
  RTPMapResetMapping(*(_QWORD *)(v0 + 64));
  CheckOutHandleDebug();
  return 0;
}

uint64_t RTPGetInternalPayload(uint64_t a1, unsigned int a2)
{
  uint64_t v3;
  uint64_t InternalPayload;

  v3 = CheckInHandleDebug();
  if (v3)
  {
    InternalPayload = RTPMapGetInternalPayload(*(unsigned __int16 ***)(v3 + 64), a2);
    CheckOutHandleDebug();
    return InternalPayload;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RTPGetInternalPayload_cold_1();
    }
    return 128;
  }
}

uint64_t RTPGetExternalPayload(uint64_t a1, unsigned int a2)
{
  uint64_t v3;
  uint64_t ExternalPayload;

  v3 = CheckInHandleDebug();
  if (v3)
  {
    ExternalPayload = RTPMapGetExternalPayload(*(unsigned __int16 ***)(v3 + 64), a2);
    CheckOutHandleDebug();
    return ExternalPayload;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RTPGetExternalPayload_cold_1();
    }
    return 128;
  }
}

uint64_t RTPSetSourceRate(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  int v7;
  int v9;
  uint64_t v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = CheckInHandleDebug();
  if (!v3)
    return 2147549186;
  v4 = v3;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v5 = VRTraceErrorLogLevelToCSTR();
    v6 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v7 = *(_DWORD *)(v4 + 28);
      v9 = 136316162;
      v10 = v5;
      v11 = 2080;
      v12 = "RTPSetSourceRate";
      v13 = 1024;
      v14 = 1003;
      v15 = 1024;
      v16 = v7;
      v17 = 1024;
      v18 = a2;
      _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d payloadType=%d, sourceRate=%u", (uint8_t *)&v9, 0x28u);
    }
  }
  *(_DWORD *)(v4 + 700) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t RTPGetPacketMultiplexMode()
{
  unsigned int *v0;
  uint64_t v1;

  v0 = (unsigned int *)CheckInHandleDebug();
  if (!v0)
    return 0;
  v1 = *v0;
  CheckOutHandleDebug();
  return v1;
}

uint64_t RTPSetPacketMultiplexMode(uint64_t a1, int a2)
{
  _DWORD *v3;

  v3 = (_DWORD *)CheckInHandleDebug();
  if (!v3)
    return 2147549186;
  *v3 = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t RTPSetThrottlingAudioInterval(double a1)
{
  uint64_t v2;

  v2 = CheckInHandleDebug();
  if (!v2)
    return 2147549186;
  if (*(_QWORD *)(v2 + 10352) != 0xFFFFFFFFLL)
    MediaQueue_SetThrottlingAudioInterval(a1);
  CheckOutHandleDebug();
  return 0;
}

uint64_t RTPSetRTCPEnabled(uint64_t a1, int a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2147549186;
  *(_DWORD *)(v3 + 184) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t RTPSetRTCPXREnabled(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2147549186;
  *(_DWORD *)(v3 + 188) = a2;
  v4 = *(_QWORD *)(v3 + 11104);
  if (v4)
    _RTPSetTransportStreamReceiveHopLimitEnabled(v4, a2 != 0);
  CheckOutHandleDebug();
  return 0;
}

uint64_t _RTPSetTransportStreamReceiveHopLimitEnabled(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t CMBaseObject;
  uint64_t result;
  uint64_t (*v5)(uint64_t, const __CFString *, uint64_t);
  uint64_t v6;

  v2 = a2;
  CMBaseObject = VCPacketFilterGetCMBaseObject(a1, a2);
  result = CMBaseObjectGetVTable();
  v5 = *(uint64_t (**)(uint64_t, const __CFString *, uint64_t))(*(_QWORD *)(result + 8) + 56);
  if (v5)
  {
    if (v2)
      v6 = *MEMORY[0x1E0C9AE50];
    else
      v6 = *MEMORY[0x1E0C9AE40];
    return v5(CMBaseObject, CFSTR("ReceiveHopLimitEnabled"), v6);
  }
  return result;
}

uint64_t RTPSetRTCPSendInterval(double a1)
{
  uint64_t v2;
  double v3;

  v2 = CheckInHandleDebug();
  if (!v2)
    return 2147549186;
  v3 = 5.0;
  if (a1 > 0.0)
    v3 = a1;
  *(double *)(v2 + 176) = v3;
  CheckOutHandleDebug();
  return 0;
}

uint64_t RTPGetSequenceNumber(uint64_t a1, _WORD *a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2147549186;
  if (a2)
    *a2 = *(_WORD *)(v3 + 18);
  CheckOutHandleDebug();
  return 0;
}

uint64_t RTPGetSendROCWithSequenceNumber(uint64_t a1, int *a2, unsigned int a3)
{
  uint64_t v5;

  v5 = CheckInHandleDebug();
  if (!v5)
    return 2147549186;
  SRTPGetSendROC(v5 + 7080, __rev16(a3), a2);
  CheckOutHandleDebug();
  return 0;
}

uint64_t RTCPGetReportNTPTimeMiddle32(uint64_t a1, char a2, _DWORD *a3)
{
  uint64_t result;
  _DWORD *v6;

  result = CheckInHandleDebug();
  if (!result)
    return 2147549186;
  v6 = (_DWORD *)(result + 620 + 4 * (a2 & 0xF));
  if ((unint64_t)v6 < result + 684 && (unint64_t)v6 >= result + 620)
  {
    *a3 = *v6;
    CheckOutHandleDebug();
    return 0;
  }
  else
  {
    __break(0x5519u);
  }
  return result;
}

uint64_t RTPGetExtendedSequenceNumber(uint64_t a1, unsigned int a2, unsigned int *a3)
{
  uint64_t v5;
  int v6;

  v5 = CheckInHandleDebug();
  if (!v5)
    return 2147549186;
  v6 = *(_DWORD *)(v5 + 224);
  if (a2 < (unsigned __int16)v6)
    v6 -= 0x10000;
  *a3 = v6 & 0xFFFF0000 | a2;
  CheckOutHandleDebug();
  return 0;
}

unint64_t RTPSendRTP(uint64_t a1, char a2, int a3, int a4, void *a5, unsigned int a6, _DWORD *a7, const void *a8, double a9, float a10, unsigned __int8 a11, int a12, uint64_t a13, uint64_t a14, char a15, int a16)
{
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  _QWORD v30[2];
  int v31;
  float v32;
  int v33;
  uint64_t v34;

  v26 = a13;
  v34 = *MEMORY[0x1E0C80C00];
  v27 = 2147549186;
  v28 = CheckInHandleDebug();
  if (v28)
  {
    if (v28 == 0xFFFFFFFF)
    {
      v27 = 2147549190;
    }
    else
    {
      *(_WORD *)(v28 + 16) = *(_WORD *)(v28 + 16) & 0x80FF | ((a2 & 0x7F) << 8);
      v30[1] = 0;
      v31 = 0;
      v30[0] = 0;
      v33 = 0;
      v32 = a10;
      if ((a6 & 0x80000000) != 0 || v28 >= v28 + 27616)
        __break(0x5519u);
      v27 = SendRTP(a1, v28, a3, a4, 0, 0, a5, a6, a9, a7, a8, a11, a12, 0, 0, 0, 0, (uint64_t)v30, 0,
              a13,
              a14,
              0,
              a15,
              a16);
      CheckOutHandleDebug();
      v26 = 0;
    }
  }
  VCMediaControlInfoDispose(v26);
  return v27;
}

unint64_t SendRTP(uint64_t a1, uint64_t a2, int a3, int a4, void *a5, unsigned int a6, void *a7, unsigned int a8, double a9, _DWORD *a10, const void *a11, unsigned __int8 a12, int a13, int a14, unsigned __int8 a15, _DWORD *a16, int a17, uint64_t a18, int a19, uint64_t a20,uint64_t a21,__int128 *a22,char a23,int a24)
{
  double v33;
  int v34;
  size_t v35;
  unsigned int v36;
  int v37;
  _BOOL4 v38;
  unint64_t v39;
  unsigned int v40;
  _WORD *v41;
  unsigned int v42;
  unint64_t v43;
  int v44;
  unsigned int v45;
  unsigned int v46;
  uint64_t v47;
  double *v48;
  double *v49;
  int v50;
  unint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  char *v55;
  int v56;
  uint64_t Size;
  uint64_t v58;
  int v59;
  uint64_t v60;
  double *v61;
  unsigned int v62;
  double *v63;
  double *v64;
  uint64_t v65;
  double *v66;
  BOOL v67;
  size_t v68;
  unint64_t v69;
  double *v70;
  unsigned int v71;
  int v72;
  int v73;
  unint64_t v74;
  int64_t v75;
  unint64_t v76;
  unint64_t v77;
  uint64_t v78;
  uint64_t v79;
  unsigned int v80;
  double *v81;
  uint64_t v82;
  void *v83;
  _DWORD *v84;
  _DWORD *v85;
  char v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  uint64_t v90;
  _BYTE *v91;
  BOOL v92;
  int v93;
  uint64_t v94;
  int v95;
  double *v96;
  BOOL v97;
  int v98;
  _BOOL4 v99;
  int v100;
  size_t v101;
  int v102;
  _WORD *v103;
  unsigned int v104;
  uint64_t v105;
  OSStatus v106;
  OpaqueCMBlockBuffer *v107;
  uint64_t v108;
  _OWORD *v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  size_t v116;
  int IDSHeaderSizeWithChannelDataFormatArray;
  uint64_t v118;
  uint64_t v119;
  int v120;
  char v121;
  BOOL v122;
  int v123;
  unsigned int v124;
  uint64_t v125;
  NSObject *v126;
  NSObject *v127;
  unsigned int v128;
  unsigned int v129;
  int v130;
  int v131;
  int IDSAttributeSizeWithChannelDataFormat;
  uint64_t v133;
  int v134;
  int v135;
  uint64_t v136;
  _BOOL4 v137;
  int v138;
  uint64_t v139;
  _DWORD *v140;
  unint64_t v141;
  _QWORD *v142;
  _OWORD *v143;
  unint64_t v144;
  __int128 v145;
  __int128 v146;
  __int128 v147;
  uint64_t v148;
  unint64_t v149;
  __int128 *v150;
  uint64_t v151;
  const __CFAllocator *v152;
  OSStatus v153;
  OSStatus v154;
  OSStatus v155;
  uint64_t v156;
  NSObject *v157;
  NSObject *v158;
  const char *v159;
  int v160;
  __int128 v161;
  __int128 v162;
  int v163;
  char v164;
  int v165;
  uint64_t v166;
  char v167;
  _DWORD *v168;
  unint64_t v169;
  uint64_t v170;
  uint64_t (*v171)(uint64_t, uint8_t *);
  int v172;
  uint64_t v173;
  NSObject *v174;
  uint64_t v175;
  NSObject *v176;
  OSStatus v177;
  uint64_t v178;
  NSObject *v179;
  uint32_t v180;
  uint64_t v181;
  NSObject *v182;
  unsigned int v183;
  unsigned int v184;
  int v185;
  uint64_t v186;
  NSObject *v187;
  NSObject *v188;
  const char *v189;
  uint64_t v190;
  NSObject *v191;
  int *v192;
  uint64_t v193;
  NSObject *v194;
  int v195;
  uint64_t v196;
  NSObject *v197;
  uint64_t v198;
  int v199;
  char v200;
  uint64_t v201;
  NSObject *v202;
  int v203;
  char v204;
  uint64_t v206;
  NSObject *v207;
  char v208;
  uint64_t v209;
  _BOOL4 v210;
  uint64_t v211;
  BOOL v212;
  _BOOL4 blockAllocator;
  const __CFAllocator *blockAllocatora;
  uint64_t v215;
  unsigned int v216;
  unsigned int v217;
  pthread_mutex_t *v218;
  void *__src;
  uint64_t v220;
  void *v221;
  int v222;
  int v223;
  void *v224;
  unint64_t v225;
  unsigned int v226;
  double *sourceBytes;
  int v228;
  uint64_t v229;
  CMBlockBufferRef blockBufferOut;
  uint64_t v231;
  double *v232;
  _BYTE dataLength[68];
  __int128 v234;
  _BYTE src[22];
  __int16 v236;
  int v237;
  __int16 v238;
  OSStatus v239;
  uint8_t buf[112];
  __int128 v241;
  _OWORD v242[3];
  __int128 v243;
  __int128 v244;
  __int128 v245;
  __int128 v246;
  __int128 v247;
  __int128 v248;
  __int128 v249;
  _DWORD v250[10];
  uint64_t v251;

  v251 = *MEMORY[0x1E0C80C00];
  *(_DWORD *)dataLength = 12;
  v232 = 0;
  v33 = micro();
  blockBufferOut = 0;
  v231 = 0;
  v234 = 0u;
  memset(&dataLength[4], 0, 64);
  v229 = 0;
  if (a10)
    *a10 = 0;
  v221 = (void *)a20;
  ++*(_QWORD *)(a2 + 352);
  if ((a6 & 0x80000000) != 0)
  {
    v43 = 2147549185;
    if ((int)VRTraceGetErrorLogLevelForModule() < 8)
      goto LABEL_298;
    v186 = VRTraceErrorLogLevelToCSTR();
    v187 = *MEMORY[0x1E0CF2758];
    v54 = a20;
    v188 = *MEMORY[0x1E0CF2758];
    if (!*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v188, OS_LOG_TYPE_DEBUG))
        SendRTP_cold_1();
      goto LABEL_334;
    }
    if (!os_log_type_enabled(v188, OS_LOG_TYPE_DEFAULT))
      goto LABEL_334;
    *(_DWORD *)buf = 136315906;
    *(_QWORD *)&buf[4] = v186;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = "SendRTP";
    *(_WORD *)&buf[22] = 1024;
    *(_DWORD *)&buf[24] = 1576;
    *(_WORD *)&buf[28] = 1024;
    *(_DWORD *)&buf[30] = a8;
    v189 = " [%s] %s:%d Header size is negative: %d";
LABEL_263:
    _os_log_impl(&dword_1D8A54000, v187, OS_LOG_TYPE_DEFAULT, v189, buf, 0x22u);
    goto LABEL_334;
  }
  if ((a8 & 0x80000000) != 0)
  {
    v43 = 2147549185;
    if ((int)VRTraceGetErrorLogLevelForModule() < 8)
      goto LABEL_298;
    v190 = VRTraceErrorLogLevelToCSTR();
    v187 = *MEMORY[0x1E0CF2758];
    v54 = a20;
    v191 = *MEMORY[0x1E0CF2758];
    if (!*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v191, OS_LOG_TYPE_DEBUG))
        SendRTP_cold_2();
      goto LABEL_334;
    }
    if (!os_log_type_enabled(v191, OS_LOG_TYPE_DEFAULT))
      goto LABEL_334;
    *(_DWORD *)buf = 136315906;
    *(_QWORD *)&buf[4] = v190;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = "SendRTP";
    *(_WORD *)&buf[22] = 1024;
    *(_DWORD *)&buf[24] = 1577;
    *(_WORD *)&buf[28] = 1024;
    *(_DWORD *)&buf[30] = a8;
    v189 = " [%s] %s:%d Data size is negative: %d";
    goto LABEL_263;
  }
  if ((*(_DWORD *)(a2 + 7000) & 0xFFFFFFFD) == 0)
  {
    v43 = 2147549185;
    if ((int)VRTraceGetErrorLogLevelForModule() < 8)
      goto LABEL_298;
    v192 = (int *)(a2 + 7000);
    v193 = VRTraceErrorLogLevelToCSTR();
    v187 = *MEMORY[0x1E0CF2758];
    v54 = a20;
    v194 = *MEMORY[0x1E0CF2758];
    if (!*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v194, OS_LOG_TYPE_DEBUG))
        SendRTP_cold_3();
      goto LABEL_334;
    }
    if (!os_log_type_enabled(v194, OS_LOG_TYPE_DEFAULT))
      goto LABEL_334;
    v195 = *v192;
    *(_DWORD *)buf = 136315906;
    *(_QWORD *)&buf[4] = v193;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = "SendRTP";
    *(_WORD *)&buf[22] = 1024;
    *(_DWORD *)&buf[24] = 1578;
    *(_WORD *)&buf[28] = 1024;
    *(_DWORD *)&buf[30] = v195;
    v189 = " [%s] %s:%d RTP SendRTP direction[%d] dropping packet";
    goto LABEL_263;
  }
  __src = a5;
  if (!*(_QWORD *)(a2 + 10440))
  {
    v34 = *(_DWORD *)(a2 + 7500);
    if ((v34 - 10) >= 0xFFFFFFFE)
    {
      v43 = 2149711924;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v196 = VRTraceErrorLogLevelToCSTR();
        v197 = *MEMORY[0x1E0CF2758];
        v54 = a20;
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v198 = *(_QWORD *)(a2 + 10440);
          v199 = *(_DWORD *)(a2 + 200);
          *(_DWORD *)buf = 136316674;
          *(_QWORD *)&buf[4] = v196;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "SendRTP";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 1585;
          *(_WORD *)&buf[28] = 2048;
          *(_QWORD *)&buf[30] = a1;
          *(_WORD *)&buf[38] = 2048;
          *(_QWORD *)&buf[40] = v198;
          *(_WORD *)&buf[48] = 1024;
          *(_DWORD *)&buf[50] = v34;
          *(_WORD *)&buf[54] = 1024;
          *(_DWORD *)&buf[56] = v199;
          _os_log_error_impl(&dword_1D8A54000, v197, OS_LOG_TYPE_ERROR, " [%s] %s:%d Attempt to send un-encrypted packet with rtpHandle=%p, VCMediaQueue=%p, cipherSuite=%d, and ssrc=%u", buf, 0x3Cu);
        }
        goto LABEL_334;
      }
      goto LABEL_298;
    }
  }
  v224 = a7;
  if (a11)
    v35 = a12;
  else
    v35 = 0;
  if (a16 && *a16)
  {
    v36 = a16[2];
    if (v36 >> 30)
      v37 = 0x400000;
    else
      v37 = 0x800000;
    v38 = (v37 & v36) == 0;
  }
  else
  {
    v38 = 0;
  }
  v215 = a1;
  v39 = MicroToNTP(a9);
  v40 = *(_DWORD *)(a2 + 196) + a4;
  *(_QWORD *)(a2 + 304) = v39;
  *(_DWORD *)(a2 + 312) = v40;
  if (!*(_DWORD *)(a2 + 220))
    *(_QWORD *)(a2 + 216) = v39;
  v41 = (_WORD *)(a2 + 16);
  *(_WORD *)(a2 + 16) = ((a3 != 0) << 15) | (32 * ((_DWORD)v35 != 0)) | *(_WORD *)(a2 + 16) & 0x7FCF;
  v42 = *(unsigned __int16 *)(a2 + 192);
  blockAllocator = v38;
  if (v38)
    *(_WORD *)(a2 + 192) = --v42;
  v43 = 2147549198;
  *(_WORD *)(a2 + 18) = bswap32(v42) >> 16;
  v226 = _RTPSendTimestampWithMediaSampleTime(a2, v40);
  *(_DWORD *)(a2 + 20) = bswap32(v226);
  v44 = *(_DWORD *)(a2 + 224);
  v45 = *(unsigned __int16 *)(a2 + 192);
  if (v45 >= (unsigned __int16)v44)
    v46 = v44 & 0xFFFF0000;
  else
    v46 = (v44 & 0xFFFF0000) + 0x10000;
  *(_DWORD *)(a2 + 224) = v46 | v45;
  *(_WORD *)(a2 + 192) = v45 + 1;
  v47 = *(_QWORD *)(a2 + 10352);
  v212 = v47 != 0xFFFFFFFFLL;
  v211 = v47;
  v223 = a3;
  if (v47 == 0xFFFFFFFFLL)
  {
    v48 = *(double **)(a2 + 80);
    if (v48)
    {
      v51 = *(int *)(a2 + 72);
      v49 = (double *)((char *)v48 + v51);
    }
    else
    {
      v51 = 1500;
      v48 = (double *)malloc_type_calloc(0x5DCuLL, 1uLL, 0x100004077774924uLL);
      if (!v48)
      {
        v54 = a20;
        v43 = 2147549187;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            SendRTP_cold_18();
        }
        goto LABEL_334;
      }
      v49 = (double *)((char *)v48 + 1500);
      *(_QWORD *)(a2 + 80) = v48;
      *(_DWORD *)(a2 + 72) = 1500;
    }
    v50 = 12;
  }
  else
  {
    MediaQueue_Malloc(v33, v47, 12, &v232);
    if (!v232)
    {
      v43 = 2147549187;
      goto LABEL_298;
    }
    v48 = (double *)((char *)v232 + 4);
    v49 = v232 + 188;
    v50 = *(_DWORD *)dataLength;
    v51 = 1500;
  }
  v220 = a21;
  v222 = v50 + 4 * (*(_WORD *)(a2 + 16) & 0xF);
  *(_DWORD *)dataLength = v222;
  sourceBytes = v48;
  if (*(_DWORD *)(a2 + 28))
  {
    v52 = 0x7FF8000000000000;
  }
  else
  {
    v53 = *(_QWORD *)(a2 + 10424);
    if (v53)
    {
      *(_QWORD *)&v244 = 0;
      v243 = 0u;
      memset(v242, 0, sizeof(v242));
      v241 = 0u;
      memset(buf, 0, sizeof(buf));
      VCRateControlGetStatistics(v53, 2, (uint64_t)buf);
      v231 = *(_QWORD *)&buf[8];
      v52 = *(_QWORD *)&buf[80];
    }
    else
    {
      AFRCGetPeerArrivalTime(*(_QWORD *)(a2 + 10360), 0, &v231);
      v52 = 0x7FF8000000000000;
    }
    v48 = sourceBytes;
  }
  v54 = a20;
  if (*(_QWORD *)(a2 + 10360) == 0xFFFFFFFFLL && !*(_QWORD *)(a2 + 10424))
  {
LABEL_44:
    if (a20)
    {
      *v41 |= 0x10u;
      *(_QWORD *)buf = 0xAAAAAAAAAAAAAAAALL;
      v55 = (char *)v48 + *(int *)dataLength;
      if (v55 && (v55 >= (char *)v49 || v55 < (char *)sourceBytes))
        goto LABEL_359;
      v56 = VCMediaControlInfoSerialize(a20);
      VCMediaControlInfoDispose(a20);
      if ((v56 & 0x80000000) == 0)
        *(_DWORD *)dataLength += *(_DWORD *)buf;
    }
    goto LABEL_56;
  }
  if (a21)
  {
    if (!a20 || *(_BYTE *)(a21 + 24))
      goto LABEL_44;
  }
  else if (!a20)
  {
LABEL_56:
    LOBYTE(v217) = 0;
    v221 = 0;
    goto LABEL_62;
  }
  Size = VCMediaControlInfoGetSize(a20);
  v58 = Size;
  if ((Size & 3) != 0)
  {
    v43 = 2147549227;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v201 = VRTraceErrorLogLevelToCSTR();
      v202 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)&buf[4] = v201;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "SendRTP";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 1659;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = 1659;
        *(_WORD *)&buf[34] = 2048;
        *(_QWORD *)&buf[36] = v58;
        _os_log_error_impl(&dword_1D8A54000, v202, OS_LOG_TYPE_ERROR, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/RTPTransport.c:%d: Bad RTP extension length (%ld)", buf, 0x2Cu);
        v43 = 2147549227;
        if (v211 == 0xFFFFFFFFLL)
          goto LABEL_334;
        goto LABEL_296;
      }
    }
    v99 = 0;
    v137 = 0;
    goto LABEL_343;
  }
  v59 = *(_DWORD *)(a2 + 28);
  if (v59 == 1)
  {
    if (!a13 && !Size)
    {
      v217 = a15 & ((char)a15 >> 7) & 0xB | (16 * a14);
      goto LABEL_62;
    }
  }
  else if (!Size || v59)
  {
    LOBYTE(v217) = 0;
    goto LABEL_62;
  }
  *v41 |= 0x10u;
  if (Size + *(int *)dataLength > v51)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 3
      || (VRTraceErrorLogLevelToCSTR(), !os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR)))
    {
LABEL_323:
      v99 = 0;
      v137 = 0;
      goto LABEL_342;
    }
    SendRTP_cold_17();
LABEL_365:
    v54 = (uint64_t)v221;
    if ((v200 & 1) == 0)
    {
LABEL_333:
      VCTerminateProcess((uint64_t)CFSTR("Failed to add data into RTP packet"), CFSTR("SendRTP"), 0);
      goto LABEL_334;
    }
    goto LABEL_296;
  }
  LOBYTE(v217) = 0;
  *(_DWORD *)dataLength += Size;
LABEL_62:
  v43 = *(int *)dataLength;
  *(_WORD *)(a2 + 16) = *(_WORD *)(a2 + 16) & 0x80FF | ((RTPMapGetExternalPayload(*(unsigned __int16 ***)(a2 + 64), *(_BYTE *)(a2 + 17) & 0x7F) & 0x7F) << 8);
  if (sourceBytes > v49)
    goto LABEL_359;
  v225 = (char *)v49 - (char *)sourceBytes;
  if ((unint64_t)((char *)v49 - (char *)sourceBytes) < 0xC)
    goto LABEL_359;
  v60 = *(_QWORD *)v41;
  v61 = sourceBytes;
  *((_DWORD *)sourceBytes + 2) = *(_DWORD *)(a2 + 24);
  *(_QWORD *)sourceBytes = v60;
  v62 = *(_DWORD *)dataLength;
  if (a6)
  {
    if (v51 < (int)(*(_DWORD *)dataLength + a6))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        v43 = 2147549198;
        v97 = v212;
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          SendRTP_cold_16();
          goto LABEL_365;
        }
        goto LABEL_279;
      }
LABEL_280:
      v99 = 0;
      v137 = 0;
      v54 = (uint64_t)v221;
      v43 = 2147549198;
LABEL_343:
      v97 = v212;
      goto LABEL_185;
    }
    v63 = (double *)((char *)sourceBytes + *(int *)dataLength);
    if (v49 < v63 || sourceBytes > v63 || (char *)v49 - (char *)v63 < (unint64_t)a6)
      goto LABEL_359;
    memcpy(v63, __src, a6);
    v62 = *(_DWORD *)dataLength + a6;
    *(_DWORD *)dataLength += a6;
    v61 = sourceBytes;
  }
  if (v51 < (int)(v62 + a8))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      v43 = 2147549198;
      v97 = v212;
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        SendRTP_cold_4();
        goto LABEL_365;
      }
      goto LABEL_279;
    }
    goto LABEL_280;
  }
  v64 = (double *)((char *)v61 + (int)v62);
  if (v49 < v64 || sourceBytes > v64 || (char *)v49 - (char *)v64 < (unint64_t)a8)
    goto LABEL_359;
  memcpy(v64, v224, a8);
  v65 = *(int *)dataLength + (uint64_t)(int)a8;
  *(_DWORD *)dataLength += a8;
  if (!(_DWORD)v35)
    goto LABEL_83;
  if (v51 < (int)v35 + (int)v65 + 1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      v43 = 2147549198;
      v97 = v212;
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
LABEL_360:
        SendRTP_cold_15();
        goto LABEL_365;
      }
LABEL_279:
      v99 = 0;
      v137 = 0;
LABEL_184:
      v54 = (uint64_t)v221;
      goto LABEL_185;
    }
    goto LABEL_280;
  }
  v66 = (double *)((char *)sourceBytes + v65);
  v67 = v49 >= (double *)((char *)sourceBytes + v65);
  v68 = (char *)v49 - ((char *)sourceBytes + v65);
  if (!v67)
    goto LABEL_359;
  if (sourceBytes > v66)
    goto LABEL_359;
  if (v68 < v35)
    goto LABEL_359;
  memcpy(v66, a11, v35);
  v69 = *(int *)dataLength + (unint64_t)v35;
  *(_DWORD *)dataLength = v69 + 1;
  v70 = (double *)((char *)sourceBytes + v69);
  if (v70 >= v49 || v70 < sourceBytes)
    goto LABEL_359;
  *(_BYTE *)v70 = v35 + 1;
LABEL_83:
  if (*(_DWORD *)(a2 + 28) == 1 && !*(_DWORD *)(a2 + 7084) && *(_DWORD *)(a2 + 7080) == 1)
  {
    v99 = 0;
    v137 = 0;
    v43 = 2147549204;
    goto LABEL_342;
  }
  v71 = *(_DWORD *)(a2 + 7488) - 3;
  v72 = SRTPCalculateTotalSuffixBytes(a2 + 7080, *(_QWORD *)(a2 + 10448), bswap32(*(unsigned __int16 *)(a2 + 18)) >> 16);
  if (v72 == -1)
  {
    v99 = 0;
    v137 = 0;
    v43 = 2149711873;
LABEL_342:
    v54 = (uint64_t)v221;
    goto LABEL_343;
  }
  v73 = v72;
  if (v71 <= 1)
  {
    *(_DWORD *)dataLength += v72;
    goto LABEL_99;
  }
  v74 = (unint64_t)sourceBytes + v43;
  if ((double *)((char *)sourceBytes + v43) > v49)
    goto LABEL_359;
  if ((unint64_t)sourceBytes > v74)
    goto LABEL_359;
  v75 = *(int *)dataLength - v43;
  if ((v75 & 0x80000000) != 0 || (uint64_t)((uint64_t)v49 - v74) < v75)
    goto LABEL_359;
  SRTPEncrypt(a2 + 7080, bswap32(*(unsigned __int16 *)(a2 + 18)) >> 16, v74, v75);
  if ((v76 & 0x80000000) != 0)
  {
    v77 = v76;
    if ((_DWORD)v76 != -2145255368)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        v54 = (uint64_t)v221;
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          SendRTP_cold_13();
LABEL_288:
        v43 = v77;
        if (v211 == 0xFFFFFFFFLL)
          goto LABEL_331;
        goto LABEL_296;
      }
LABEL_287:
      v54 = (uint64_t)v221;
      goto LABEL_288;
    }
  }
  if ((v51 & 0x80000000) != 0 || (uint64_t)v51 > (uint64_t)v225)
  {
LABEL_359:
    __break(0x5519u);
    goto LABEL_360;
  }
  v78 = SRTPAddAuthenticationTag(a2 + 7080, *(_QWORD *)(a2 + 10448), bswap32(*(unsigned __int16 *)(a2 + 18)) >> 16, v51, (char *)sourceBytes, *(signed int *)dataLength, (signed int *)dataLength);
  if ((v78 & 0x80000000) != 0)
  {
    v77 = v78;
    if ((_DWORD)v78 != -2145255368)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        v54 = (uint64_t)v221;
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          SendRTP_cold_14();
        goto LABEL_288;
      }
      goto LABEL_287;
    }
  }
LABEL_99:
  v228 = -1;
  v79 = _RTPGetRTPSocketForMediaQueue(a2, &v228);
  v80 = v79;
  if ((v79 & 0x80000000) != 0)
  {
    v99 = 0;
    v137 = 0;
    v43 = v79;
    goto LABEL_342;
  }
  v81 = v232;
  if (v232 && *(_QWORD *)(a2 + 10352) != 0xFFFFFFFFLL)
  {
    v82 = a21;
    if (!a21)
    {
      v86 = 0;
      v83 = v221;
      v84 = a10;
      v85 = a16;
LABEL_115:
      *((_BYTE *)v81 + 1621) = v86;
      *((_DWORD *)v81 + 398) = v222;
      *(_DWORD *)v81 = *(_DWORD *)dataLength;
      v94 = *(_QWORD *)v41;
      *((_DWORD *)v81 + 378) = *(_DWORD *)(a2 + 24);
      *((_QWORD *)v81 + 188) = v94;
      *((_DWORD *)v81 + 379) = *(_DWORD *)(a2 + 28);
      *((_DWORD *)v81 + 380) = *(_DWORD *)(a2 + 10400);
      *((_DWORD *)v81 + 381) = v228;
      *((_BYTE *)v81 + 1528) = *(_DWORD *)(a2 + 12) != 0;
      v81[192] = v33;
      *((_DWORD *)v81 + 386) = 0;
      *((_QWORD *)v81 + 194) = v231;
      *((_DWORD *)v81 + 390) = a17;
      *((_DWORD *)v81 + 391) = a19;
      if (!v85 || (v95 = v85[12], v95 <= 1))
        v95 = 1;
      *((_DWORD *)v81 + 387) = v95;
      *((_QWORD *)v81 + 198) = v83;
      v81[196] = 0.0;
      *((_BYTE *)v81 + 1578) = a13 != 0;
      *((_BYTE *)v81 + 1579) = v223 != 0;
      Throttling_RTP_SendRTP_SetThrottlingParams((uint64_t)v81, a18);
      v96 = v232;
      *((_BYTE *)v232 + 1620) = v217;
      v216 = MediaQueue_AddPacket(*(_QWORD *)(a2 + 10352), (uint64_t)v96);
      if ((v216 & 0x80000000) == 0)
      {
        v221 = 0;
        if (v84)
        {
          v97 = 0;
          v98 = 0;
          v99 = 0;
          v100 = *((_DWORD *)v232 + 387);
          LODWORD(v101) = *(_DWORD *)dataLength;
LABEL_160:
          if ((_DWORD)v101 == -1)
          {
            v133 = *__error() | 0xC0010000;
            v99 = v99;
            v137 = v98 != 0;
            goto LABEL_181;
          }
          kdebug_trace();
          if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            v125 = VRTraceErrorLogLevelToCSTR();
            v126 = *MEMORY[0x1E0CF2758];
            v127 = *MEMORY[0x1E0CF2758];
            if (*MEMORY[0x1E0CF2748])
            {
              if (os_log_type_enabled(v127, OS_LOG_TYPE_DEFAULT))
              {
                v128 = *(unsigned __int16 *)(a2 + 16);
                v129 = bswap32(*(unsigned __int16 *)(a2 + 18));
                v130 = *(_DWORD *)(a2 + 200);
                *(_DWORD *)buf = 136316930;
                *(_QWORD *)&buf[4] = v125;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "SendRTP";
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&buf[24] = 1896;
                *(_WORD *)&buf[28] = 1024;
                *(_DWORD *)&buf[30] = v128 >> 15;
                *(_WORD *)&buf[34] = 1024;
                *(_DWORD *)&buf[36] = (v128 >> 8) & 0x7F;
                *(_WORD *)&buf[40] = 1024;
                *(_DWORD *)&buf[42] = HIWORD(v129);
                *(_WORD *)&buf[46] = 1024;
                *(_DWORD *)&buf[48] = v226;
                *(_WORD *)&buf[52] = 1024;
                *(_DWORD *)&buf[54] = v130;
                _os_log_impl(&dword_1D8A54000, v126, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Sent RTP packet with marker: %u, payload type: %u, sequence number: %u, timestamp: %u, ssrc: %u", buf, 0x3Au);
              }
            }
            else if (os_log_type_enabled(v127, OS_LOG_TYPE_DEBUG))
            {
              v183 = *(unsigned __int16 *)(a2 + 16);
              v184 = bswap32(*(unsigned __int16 *)(a2 + 18));
              v185 = *(_DWORD *)(a2 + 200);
              *(_DWORD *)buf = 136316930;
              *(_QWORD *)&buf[4] = v125;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "SendRTP";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 1896;
              *(_WORD *)&buf[28] = 1024;
              *(_DWORD *)&buf[30] = v183 >> 15;
              *(_WORD *)&buf[34] = 1024;
              *(_DWORD *)&buf[36] = (v183 >> 8) & 0x7F;
              *(_WORD *)&buf[40] = 1024;
              *(_DWORD *)&buf[42] = HIWORD(v184);
              *(_WORD *)&buf[46] = 1024;
              *(_DWORD *)&buf[48] = v226;
              *(_WORD *)&buf[52] = 1024;
              *(_DWORD *)&buf[54] = v185;
              _os_log_debug_impl(&dword_1D8A54000, v126, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Sent RTP packet with marker: %u, payload type: %u, sequence number: %u, timestamp: %u, ssrc: %u", buf, 0x3Au);
            }
          }
          v131 = *(_DWORD *)(a2 + 208) + *(_DWORD *)dataLength;
          ++*(_DWORD *)(a2 + 204);
          *(_DWORD *)(a2 + 208) = v131;
          if (v82)
            IDSAttributeSizeWithChannelDataFormat = VCIDSChannelData_GetIDSAttributeSizeWithChannelDataFormat(v82);
          else
            IDSAttributeSizeWithChannelDataFormat = 0;
          v133 = v216;
          v134 = *(_DWORD *)(a2 + 27600);
          if (!v134)
          {
            if (*(_DWORD *)(a2 + 12))
              v134 = 48;
            else
              v134 = 28;
          }
          v135 = IDSAttributeSizeWithChannelDataFormat + v101 + v134;
          *v84 = v135;
          v136 = *(_QWORD *)(a2 + 27592);
          if (v136)
          {
            *(_QWORD *)buf = 0xAAAAAAAAAAAAAAAALL;
            *(_DWORD *)buf = *(_DWORD *)(a2 + 200);
            *(_WORD *)&buf[4] = bswap32(*(unsigned __int16 *)(a2 + 18)) >> 16;
            *(double *)&buf[8] = v33;
            *(_QWORD *)&buf[16] = v135;
            VCNACKConsumer_UpdateTransmissionStatus(v136, (int *)buf);
          }
          v99 = v99;
          v137 = v98 != 0;
          if (*(_DWORD *)(a2 + 28) == 1)
          {
            if (*(_QWORD *)(a2 + 10352) == 0xFFFFFFFFLL)
              v138 = 1;
            else
              v138 = v100;
            _RTPUpdateAFRCVideoSendingBitrate(a2, v138 * *v84, a13 != 0, v33);
LABEL_181:
            v54 = (uint64_t)v221;
            if (!v97)
              goto LABEL_325;
LABEL_186:
            MediaQueue_FreePacket(*(_QWORD *)(a2 + 10352), (uint64_t)v232);
            v43 = v133;
            if (!v137)
              goto LABEL_329;
            goto LABEL_326;
          }
          v43 = v216;
          goto LABEL_184;
        }
        v43 = 2147549185;
LABEL_298:
        v54 = (uint64_t)v221;
        goto LABEL_334;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3
        && (VRTraceErrorLogLevelToCSTR(), os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR)))
      {
        v43 = v216;
        SendRTP_cold_11();
        v54 = 0;
      }
      else
      {
        v54 = 0;
        v43 = v216;
      }
LABEL_296:
      MediaQueue_FreePacket(*(_QWORD *)(a2 + 10352), (uint64_t)v232);
      goto LABEL_331;
    }
    v83 = v221;
    v84 = a10;
    v85 = a16;
    if (!*(_BYTE *)(a21 + 24))
    {
      v86 = *(_BYTE *)(a21 + 30);
      if (v86)
      {
        *(_OWORD *)(v232 + 203) = *(_OWORD *)a21;
        v87 = *(_OWORD *)(a21 + 16);
        v88 = *(_OWORD *)(a21 + 32);
        v89 = *(_OWORD *)(a21 + 64);
        *(_OWORD *)(v81 + 209) = *(_OWORD *)(a21 + 48);
        *(_OWORD *)(v81 + 211) = v89;
        *(_OWORD *)(v81 + 205) = v87;
        *(_OWORD *)(v81 + 207) = v88;
        v86 = 1;
      }
      goto LABEL_115;
    }
    v43 = 2147549194;
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
    {
      v99 = 0;
      v137 = 0;
      v97 = v212;
      v54 = (uint64_t)v221;
LABEL_185:
      v133 = v43;
      if (!v97)
        goto LABEL_325;
      goto LABEL_186;
    }
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      SendRTP_cold_12();
      v54 = (uint64_t)v221;
      if ((v204 & 1) == 0)
        goto LABEL_334;
      goto LABEL_296;
    }
    goto LABEL_323;
  }
  v90 = *(_QWORD *)(a2 + 10440);
  v91 = (_BYTE *)a21;
  v210 = v90 != 0;
  if (!v90)
  {
    v216 = v80;
    if (a16)
    {
      if ((int)a16[12] <= 1)
        v93 = 1;
      else
        v93 = a16[12];
    }
    else
    {
      v93 = 1;
    }
    v43 = a21 + 80;
    blockAllocatora = (const __CFAllocator *)*MEMORY[0x1E0C9AE20];
    v218 = (pthread_mutex_t *)(a2 + 7016);
    v149 = a21;
    v150 = (__int128 *)a21;
    while (1)
    {
      v101 = *(int *)dataLength;
      if (v225 < *(int *)dataLength || v150 && ((unint64_t)v150 >= v43 || (unint64_t)v150 < v149))
        goto LABEL_359;
      v151 = bswap32(*(unsigned __int16 *)(a2 + 18)) >> 16;
      if (!*(_QWORD *)(a2 + 11104))
      {
        if (!*(_DWORD *)dataLength)
          goto LABEL_359;
        v160 = *(_DWORD *)(a2 + 4);
        memset(v250, 0, 32);
        v248 = 0u;
        v249 = 0u;
        v246 = 0u;
        v247 = 0u;
        v244 = 0u;
        v245 = 0u;
        v243 = 0u;
        memset(v242, 0, sizeof(v242));
        v241 = 0u;
        memset(buf, 0, sizeof(buf));
        *(_DWORD *)&buf[8] = *(_DWORD *)(a2 + 10400);
        if (v150)
        {
          v161 = v150[3];
          v245 = v150[2];
          v246 = v161;
          v247 = v150[4];
          v162 = v150[1];
          v243 = *v150;
          v244 = v162;
          BYTE13(v244) = 1;
        }
        v250[0] = a24;
        v163 = *(_DWORD *)(a2 + 200);
        v164 = *(_BYTE *)(a2 + 17) & 0x7F;
        *(_DWORD *)&src[12] = 0;
        src[0] = 1;
        src[1] = v164;
        *(_WORD *)&src[2] = v151;
        *(_DWORD *)&src[4] = v226;
        *(_DWORD *)&src[8] = v163;
        uuid_copy((unsigned __int8 *)&v250[1], src);
        pthread_mutex_lock(v218);
        VTP_SetPktTag((uint64_t)buf, 0, v151);
        VTP_SetPktTag((uint64_t)buf, 1u, *(unsigned int *)(a2 + 200));
        VTP_SetPktTag((uint64_t)buf, 2u, v226);
        v165 = VTP_Send(v160, sourceBytes, v101, 800, (uint64_t)buf);
        pthread_mutex_unlock(v218);
        LODWORD(v101) = v165;
        goto LABEL_242;
      }
      v241 = unk_1D910B4B0;
      v242[0] = xmmword_1D910B4C0;
      memset(&v242[1], 170, 24);
      memset(buf, 170, sizeof(buf));
      VCPacketInitialize((uint64_t)buf);
      if (!*(_QWORD *)(a2 + 11104))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() < 3)
          goto LABEL_241;
        v173 = VRTraceErrorLogLevelToCSTR();
        v174 = *MEMORY[0x1E0CF2758];
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          goto LABEL_241;
        *(_DWORD *)src = 136315650;
        *(_QWORD *)&src[4] = v173;
        *(_WORD *)&src[12] = 2080;
        *(_QWORD *)&src[14] = "_RTPSendWithTransportStream";
        v236 = 1024;
        v237 = 5638;
        v158 = v174;
        v159 = " [%s] %s:%d NULL transportStream";
        goto LABEL_239;
      }
      if (!(_DWORD)v101)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() < 3)
          goto LABEL_241;
        v175 = VRTraceErrorLogLevelToCSTR();
        v176 = *MEMORY[0x1E0CF2758];
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          goto LABEL_241;
        *(_DWORD *)src = 136315650;
        *(_QWORD *)&src[4] = v175;
        *(_WORD *)&src[12] = 2080;
        *(_QWORD *)&src[14] = "_RTPSendWithTransportStream";
        v236 = 1024;
        v237 = 5640;
        v158 = v176;
        v159 = " [%s] %s:%d data length <= 0";
        goto LABEL_239;
      }
      v152 = *(const __CFAllocator **)(a2 + 10480);
      if (*(_QWORD *)(a2 + 27592))
      {
        v153 = CMBlockBufferCreateWithMemoryBlock(v152, 0, v101, 0, 0, 0, v101, 1u, (CMBlockBufferRef *)buf);
        if (v153)
        {
          v177 = v153;
          if ((int)VRTraceGetErrorLogLevelForModule() < 3)
            goto LABEL_241;
          v178 = VRTraceErrorLogLevelToCSTR();
          v179 = *MEMORY[0x1E0CF2758];
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            goto LABEL_241;
          *(_DWORD *)src = 136315906;
          *(_QWORD *)&src[4] = v178;
          *(_WORD *)&src[12] = 2080;
          *(_QWORD *)&src[14] = "_RTPSendWithTransportStream";
          v236 = 1024;
          v237 = 5645;
          v238 = 1024;
          v239 = v177;
          v158 = v179;
          v159 = " [%s] %s:%d Failed to create a CMBlockBuffer. Error=%d!";
LABEL_235:
          v180 = 34;
          goto LABEL_240;
        }
        v154 = CMBlockBufferReplaceDataBytes(sourceBytes, *(CMBlockBufferRef *)buf, 0, v101);
        if (v154)
        {
          v155 = v154;
          if ((int)VRTraceGetErrorLogLevelForModule() < 3)
            goto LABEL_241;
          v156 = VRTraceErrorLogLevelToCSTR();
          v157 = *MEMORY[0x1E0CF2758];
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            goto LABEL_241;
          *(_DWORD *)src = 136315906;
          *(_QWORD *)&src[4] = v156;
          *(_WORD *)&src[12] = 2080;
          *(_QWORD *)&src[14] = "_RTPSendWithTransportStream";
          v236 = 1024;
          v237 = 5648;
          v238 = 1024;
          v239 = v155;
          v158 = v157;
          v159 = " [%s] %s:%d Failed to copy data bytes. Error=%d!";
          goto LABEL_235;
        }
      }
      else if (CMBlockBufferCreateWithMemoryBlock(v152, sourceBytes, v101, blockAllocatora, 0, 0, v101, 0, (CMBlockBufferRef *)buf))
      {
        goto LABEL_241;
      }
      *(_WORD *)&buf[8] = 257;
      *((double *)&v241 + 1) = v33;
      v166 = *(unsigned int *)(a2 + 200);
      *(_QWORD *)&buf[56] = v151;
      *(_QWORD *)&buf[64] = v166;
      *(_QWORD *)&buf[72] = v226;
      DWORD1(v242[0]) = a24;
      v167 = *(_BYTE *)(a2 + 17) & 0x7F;
      *(_DWORD *)&src[12] = 0;
      src[0] = 1;
      src[1] = v167;
      *(_WORD *)&src[2] = v151;
      *(_DWORD *)&src[4] = v226;
      *(_DWORD *)&src[8] = v166;
      uuid_copy((unsigned __int8 *)v242 + 8, src);
      if ((_RTPEnsureTransportStreamsActivated(a2) & 0x80000000) == 0)
      {
        if (*(_QWORD *)(a2 + 27592))
        {
          LOWORD(v241) = v101;
          v168 = VCBoundsSafety_AllocatorAllocate(*(const __CFAllocator **)(a2 + 10808), 80, 0);
          if (!v168)
          {
            if ((int)VRTraceGetErrorLogLevelForModule() < 3)
              goto LABEL_241;
            v181 = VRTraceErrorLogLevelToCSTR();
            v182 = *MEMORY[0x1E0CF2758];
            if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              goto LABEL_241;
            *(_DWORD *)src = 136315650;
            *(_QWORD *)&src[4] = v181;
            *(_WORD *)&src[12] = 2080;
            *(_QWORD *)&src[14] = "_RTPSendWithTransportStream";
            v236 = 1024;
            v237 = 5669;
            v158 = v182;
            v159 = " [%s] %s:%d Could not update media packet history";
LABEL_239:
            v180 = 28;
LABEL_240:
            _os_log_error_impl(&dword_1D8A54000, v158, OS_LOG_TYPE_ERROR, v159, src, v180);
            goto LABEL_241;
          }
          if ((unint64_t)v168 >= v169)
            goto LABEL_359;
          *(_WORD *)v168 = *(_WORD *)&buf[56];
          v168[1] = *(_DWORD *)&buf[64];
          v168[4] = *(_DWORD *)&buf[72];
          v168[13] = DWORD1(v242[0]);
          v168[2] = (unsigned __int16)v241;
          *((_BYTE *)v168 + 56) = 0;
          *((_QWORD *)v168 + 8) = *((_QWORD *)&v241 + 1);
          *((_WORD *)v168 + 36) = 0;
          *(_QWORD *)src = v168;
          *(_QWORD *)&src[8] = *(_QWORD *)buf;
          _RTPTransportAddMediaPacketHistory(a2, (_WORD **)src);
        }
        v170 = *(_QWORD *)(a2 + 11104);
        v171 = *(uint64_t (**)(uint64_t, uint8_t *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 16);
        if (v171)
        {
          v172 = v171(v170, buf);
          VCPacketInvalidate((uint64_t *)buf);
          if (v172 < 0)
            LODWORD(v101) = -1;
          goto LABEL_242;
        }
      }
LABEL_241:
      VCPacketInvalidate((uint64_t *)buf);
      LODWORD(v101) = -1;
LABEL_242:
      if (a22)
      {
        v149 = (unint64_t)a22;
        v43 = (unint64_t)(a22 + 5);
        v150 = a22;
      }
      if (!--v93)
      {
        v99 = 0;
        v98 = 0;
        v97 = v212;
        goto LABEL_246;
      }
    }
  }
  if (a21)
  {
    if (a18)
    {
LABEL_109:
      v92 = *(_BYTE *)(a18 + 1) != 0;
      goto LABEL_124;
    }
  }
  else
  {
    if (*(_DWORD *)(a2 + 28))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          SendRTP_cold_10();
          v54 = (uint64_t)v221;
          v43 = 2147549194;
          if ((v208 & 1) == 0)
            goto LABEL_334;
          goto LABEL_296;
        }
      }
      v99 = 0;
      v137 = 0;
      v54 = (uint64_t)v221;
      v43 = 2147549194;
      goto LABEL_343;
    }
    HIBYTE(v234) = 1;
    v91 = &dataLength[4];
    if (a18)
      goto LABEL_109;
  }
  v92 = 0;
LABEL_124:
  v220 = (uint64_t)v91;
  if (v91[42])
  {
    v102 = 0;
  }
  else if (!v221 || *(_DWORD *)(a2 + 28) || (v102 = 0, (VCMediaControlInfoHasInfo(v221, 0) & 1) == 0))
  {
    v102 = 1;
  }
  if (*(_BYTE *)(v220 + 72))
    v103 = (_WORD *)(v220 + 74);
  else
    v103 = (_WORD *)v220;
  v104 = (unsigned __int16)*v103;
  if (!*(_BYTE *)(v220 + 24) && !*v103)
    v104 = *(_DWORD *)(a2 + 200);
  v105 = VCMediaQueue_AllocMediaPacket(*(_QWORD *)(a2 + 10440), v104, 0, (uint64_t)&v229);
  v99 = v105 == 0;
  if ((_DWORD)v105)
  {
    v133 = v105;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SendRTP_cold_9();
    }
    v137 = 0;
  }
  else
  {
    v106 = CMBlockBufferCreateWithMemoryBlock(*(CFAllocatorRef *)(a2 + 10800), 0, 0x5DCuLL, 0, 0, 0, *(int *)dataLength, 1u, &blockBufferOut);
    if (v106)
    {
      v137 = 0;
      if (v106 >= 0)
        v203 = v106;
      else
        v203 = -v106;
      v133 = v203 | 0xD0010000;
    }
    else
    {
      v108 = v229;
      v107 = blockBufferOut;
      *(_QWORD *)(v229 + 8) = blockBufferOut;
      *(double *)(v108 + 272) = v33;
      v109 = (_OWORD *)v220;
      *(_OWORD *)(v108 + 16) = *(_OWORD *)v220;
      v110 = *(_OWORD *)(v220 + 64);
      v112 = *(_OWORD *)(v220 + 16);
      v111 = *(_OWORD *)(v220 + 32);
      *(_OWORD *)(v108 + 64) = *(_OWORD *)(v220 + 48);
      *(_OWORD *)(v108 + 80) = v110;
      *(_OWORD *)(v108 + 32) = v112;
      *(_OWORD *)(v108 + 48) = v111;
      if (a22)
        v109 = a22;
      v114 = v109[3];
      v113 = v109[4];
      v115 = v109[2];
      *(_OWORD *)(v108 + 112) = v109[1];
      *(_OWORD *)(v108 + 128) = v115;
      *(_OWORD *)(v108 + 144) = v114;
      *(_OWORD *)(v108 + 160) = v113;
      *(_OWORD *)(v108 + 96) = *v109;
      v116 = *(int *)dataLength;
      *(_WORD *)(v108 + 4) = *(_WORD *)dataLength;
      *(_QWORD *)(v108 + 200) = 0xFFFFFFFFLL;
      *(_BYTE *)(v108 + 297) = v71 < 2;
      if (v71 <= 1)
      {
        *(_QWORD *)(v108 + 192) = RTPMediaQueueSecurityCallback;
        *(_QWORD *)(v108 + 200) = v215;
        *(_DWORD *)(v108 + 300) = (unsigned __int16)v116 - (v73 + v43);
      }
      v84 = a10;
      if ((unsigned __int16)v116 >= 0x5DDu)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            SendRTP_cold_5();
        }
        v137 = 1;
        v133 = 2147549198;
      }
      else
      {
        if (!CMBlockBufferReplaceDataBytes(sourceBytes, v107, 0, v116))
        {
          IDSHeaderSizeWithChannelDataFormatArray = VCIDSChannelData_GetIDSHeaderSizeWithChannelDataFormatArray(v220, 1u);
          v118 = v229;
          *(_DWORD *)v229 = IDSHeaderSizeWithChannelDataFormatArray;
          *(_DWORD *)(v118 + 176) = v102;
          v82 = v220;
          *(_QWORD *)(v118 + 184) = v221;
          *(_DWORD *)(v118 + 244) = v222;
          v119 = v231;
          *(_QWORD *)(v118 + 208) = v52;
          *(_QWORD *)(v118 + 216) = v119;
          *(_BYTE *)(v118 + 224) = 0;
          v120 = *(unsigned __int8 *)(v220 + 77);
          *(_BYTE *)(v118 + 225) = v120 ^ 1;
          if (v120)
            v121 = 1;
          else
            v121 = v92;
          *(_BYTE *)(v118 + 288) = v121;
          *(_BYTE *)(v118 + 226) = v120;
          *(_BYTE *)(v118 + 289) = a23;
          *(_BYTE *)(v118 + 293) = *(_DWORD *)(a2 + 12) != 0;
          v43 = 2147549198;
          if (a16)
            v122 = *a16 != 0;
          else
            v122 = 0;
          *(_BYTE *)(v118 + 290) = v122;
          *(_BYTE *)(v118 + 291) = a13 != 0;
          *(_BYTE *)(v118 + 292) = v223 != 0;
          *(_QWORD *)(v118 + 304) = 0;
          *(_DWORD *)(v118 + 232) = *(_DWORD *)(a2 + 10400);
          *(_WORD *)(v118 + 248) = bswap32(*(unsigned __int16 *)(a2 + 18)) >> 16;
          *(_DWORD *)(v118 + 264) = v228;
          *(_DWORD *)(v118 + 236) = v226;
          *(_DWORD *)(v118 + 240) = *(_DWORD *)(a2 + 316);
          *(_DWORD *)(v118 + 252) = *(_DWORD *)(a2 + 200);
          *(_BYTE *)(v118 + 227) = *(_DWORD *)(a2 + 28) == 0;
          *(_DWORD *)(v118 + 256) = a17;
          *(_DWORD *)(v118 + 260) = a19;
          *(_WORD *)(v118 + 294) = 1;
          if (a16 && (v123 = a16[12], v123 >= 2))
          {
            *(_DWORD *)(v118 + 268) = v123;
            *(_BYTE *)(v118 + 288) = 1;
          }
          else
          {
            *(_DWORD *)(v118 + 268) = 1;
          }
          v97 = v212;
          VCMediaQueue_AddPacket(*(_QWORD *)(a2 + 10440), v118);
          v216 = v124;
          if (v124)
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                SendRTP_cold_7();
            }
            LODWORD(v101) = -1;
            v99 = 1;
            v98 = 1;
            if (a10)
              goto LABEL_159;
LABEL_247:
            v133 = 2147549185;
            if (v211 == 0xFFFFFFFFLL)
            {
              v54 = (uint64_t)v221;
              v137 = v210;
              goto LABEL_325;
            }
            v54 = (uint64_t)v221;
            LOBYTE(v137) = v210;
            goto LABEL_186;
          }
          v221 = 0;
          v99 = 0;
          LODWORD(v101) = *(_DWORD *)dataLength;
          v98 = 1;
          if (blockAllocator || !*(_QWORD *)(a2 + 27592))
          {
            v216 = 0;
            if (!a10)
              goto LABEL_247;
            goto LABEL_159;
          }
          v139 = v229;
          v140 = VCBoundsSafety_AllocatorAllocate(*(const __CFAllocator **)(a2 + 10808), 80, 0);
          if (!v140)
          {
LABEL_355:
            v216 = -2147418109;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              v206 = VRTraceErrorLogLevelToCSTR();
              v207 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              {
                v209 = *(_QWORD *)(a2 + 27592);
                *(_DWORD *)buf = 136316162;
                *(_QWORD *)&buf[4] = v206;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "SendRTP";
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&buf[24] = 1868;
                *(_WORD *)&buf[28] = 2048;
                *(_QWORD *)&buf[30] = v229;
                *(_WORD *)&buf[38] = 2048;
                *(_QWORD *)&buf[40] = v209;
                _os_log_error_impl(&dword_1D8A54000, v207, OS_LOG_TYPE_ERROR, " [%s] %s:%d Could not update media packet history for packet=%pfor nackConsumer=%p", buf, 0x30u);
              }
            }
            v99 = 0;
            v221 = 0;
            v98 = 1;
LABEL_246:
            v84 = a10;
            v82 = v220;
            if (a10)
              goto LABEL_159;
            goto LABEL_247;
          }
          v142 = v140;
          if ((unint64_t)v140 < v141)
          {
            *(_WORD *)v140 = *(_WORD *)(v139 + 248);
            v140[1] = *(_DWORD *)(a2 + 200);
            *((_WORD *)v140 + 10) = *(_WORD *)(v139 + 291);
            v140[2] = *(unsigned __int16 *)(v139 + 4);
            v140[3] = *(_DWORD *)(v139 + 244);
            v140[4] = *(_DWORD *)(v139 + 236);
            *((_BYTE *)v140 + 22) = *(_BYTE *)(v139 + 290);
            v140[6] = *(_DWORD *)(v139 + 256);
            *((_BYTE *)v140 + 28) = *(_BYTE *)(v139 + 288);
            v140[8] = *(_DWORD *)(v139 + 260);
            *((_QWORD *)v140 + 5) = 0;
            v143 = VCBoundsSafety_AllocatorAllocate(*(const __CFAllocator **)(a2 + 10816), 80, 0);
            if (!v143 || (unint64_t)v143 < v144)
            {
              v142[5] = v143;
              if (v143)
              {
                *v143 = *(_OWORD *)(v139 + 16);
                v145 = *(_OWORD *)(v139 + 32);
                v146 = *(_OWORD *)(v139 + 48);
                v147 = *(_OWORD *)(v139 + 80);
                v143[3] = *(_OWORD *)(v139 + 64);
                v143[4] = v147;
                v143[1] = v145;
                v143[2] = v146;
                *((_BYTE *)v142 + 48) = *(_BYTE *)(v139 + 289);
                *((_BYTE *)v142 + 56) = 1;
                v142[8] = *(_QWORD *)(v139 + 272);
                *((_WORD *)v142 + 36) = 0;
                v148 = *(_QWORD *)(v139 + 8);
                *(_QWORD *)buf = v142;
                *(_QWORD *)&buf[8] = v148;
                _RTPTransportAddMediaPacketHistory(a2, (_WORD **)buf);
                v99 = 0;
                v216 = 0;
                v221 = 0;
                if (!a10)
                  goto LABEL_247;
LABEL_159:
                v100 = 0;
                goto LABEL_160;
              }
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  SendRTP_cold_6();
              }
              CFAllocatorDeallocate(*(CFAllocatorRef *)(a2 + 10808), v142);
              goto LABEL_355;
            }
          }
          goto LABEL_359;
        }
        v133 = 2147549188;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            SendRTP_cold_8();
        }
        v137 = 1;
      }
    }
  }
  v54 = (uint64_t)v221;
  if (v211 != 0xFFFFFFFFLL)
    goto LABEL_186;
LABEL_325:
  v43 = v133;
  if (!v137)
    goto LABEL_329;
LABEL_326:
  if (blockBufferOut)
  {
    CFRelease(blockBufferOut);
    blockBufferOut = 0;
    if (v99)
      goto LABEL_330;
    goto LABEL_331;
  }
LABEL_329:
  if (v99)
LABEL_330:
    VCMediaQueue_FreeMediaPacket(*(_QWORD *)(a2 + 10440), v229);
LABEL_331:
  if ((_DWORD)v43 == -2145255410 || (_DWORD)v43 == -2147418098)
    goto LABEL_333;
LABEL_334:
  VCMediaControlInfoDispose(v54);
  return v43;
}

uint64_t _RTPUpdateAFRCVideoSendingBitrate(uint64_t a1, int a2, int a3, double a4)
{
  uint64_t result;
  double v8;
  unint64_t v9;
  int v10;
  double *v11;
  unsigned int v13;
  int v14;
  int v15;
  int v16;
  double v17;
  double *v18;
  BOOL v20;

  result = *(_QWORD *)(a1 + 10360);
  if (result != 0xFFFFFFFFLL)
  {
    if (a3)
    {
      v8 = *(double *)(a1 + 11088);
      if (v8 <= 0.0)
      {
LABEL_26:
        *(double *)(a1 + 11088) = a4;
        *(_DWORD *)(a1 + 11096) = a2;
      }
      else
      {
        v9 = a1 + 10824;
        v10 = *(_DWORD *)(a1 + 11080);
        v11 = (double *)(a1 + 10824 + 16 * v10);
        if ((unint64_t)v11 < a1 + 11080 && (unint64_t)v11 >= v9)
        {
          *(_DWORD *)(v9 + 16 * v10 + 8) = *(_DWORD *)(a1 + 11096);
          *v11 = a4 - v8;
          *(_DWORD *)(a1 + 11080) = ((_BYTE)v10 + 1) & 0xF;
          v13 = *(_DWORD *)(a1 + 11084);
          if (v13 > 0xF)
          {
            v14 = 16;
          }
          else
          {
            v14 = v13 + 1;
            *(_DWORD *)(a1 + 11084) = v13 + 1;
          }
          v15 = 0;
          v16 = v14 - 1;
          v17 = 0.0;
          while (1)
          {
            v18 = (double *)(v9 + 16 * (v10 & 0xF));
            if ((unint64_t)v18 >= a1 + 11080 || (unint64_t)v18 < v9)
              break;
            v15 += *(_DWORD *)(v9 + 16 * (v10 & 0xF) + 8);
            v17 = v17 + *v18;
            v20 = v17 > 0.5 || v16-- == 0;
            LOBYTE(v10) = v10 - 1;
            if (v20)
            {
              if (v17 > 0.0)
                result = AFRCUpdateVideoSendingBitrate(result, (int)((double)(8 * v15) / v17));
              goto LABEL_26;
            }
          }
        }
        __break(0x5519u);
      }
    }
    else
    {
      *(_DWORD *)(a1 + 11096) += a2;
    }
  }
  return result;
}

uint64_t RTPMediaQueueSecurityCallback(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  NSObject *v18;
  signed int v19;
  uint8_t buf[4];
  uint64_t v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  signed int v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (a1 == 0xFFFFFFFFLL)
  {
    v15 = 2149711873;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RTPMediaQueueSecurityCallback_cold_1();
    }
  }
  else if (a2)
  {
    if (a3)
    {
      v9 = CheckInHandleDebug();
      if (v9)
      {
        v10 = v9;
        if ((*(_DWORD *)(v9 + 7488) - 5) <= 0xFFFFFFFD)
        {
          v15 = 2149711876;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            {
              RTPMediaQueueSecurityCallback_cold_5();
              v15 = 2149711876;
            }
          }
          goto LABEL_16;
        }
        v11 = a2 + a3;
        if (a2 + 12 <= a2 + a3)
        {
          v12 = a2 + a4;
          if (a2 + a4 <= v11 && v12 >= a2 && (a5 & 0x80000000) == 0 && a5 <= (uint64_t)(v11 - v12))
          {
            v13 = bswap32(*(unsigned __int16 *)(a2 + 2)) >> 16;
            SRTPEncrypt(v9 + 7080, v13, v12, a5);
            if ((v14 & 0x80000000) != 0)
            {
              v15 = v14;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  RTPMediaQueueSecurityCallback_cold_6();
              }
              goto LABEL_16;
            }
            v19 = 0;
            if ((a3 & 0x80000000) == 0 && (int)a3 <= a3)
            {
              v15 = SRTPAddAuthenticationTag(v10 + 7080, *(_QWORD *)(v10 + 10448), v13, a3, (char *)a2, a5 + (int)a4, &v19);
              if ((v15 & 0x80000000) != 0)
              {
                if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                {
                  VRTraceErrorLogLevelToCSTR();
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                    RTPMediaQueueSecurityCallback_cold_7();
                }
              }
              else if (v19 != a3 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                v17 = VRTraceErrorLogLevelToCSTR();
                v18 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136316162;
                  v21 = v17;
                  v22 = 2080;
                  v23 = "RTPMediaQueueSecurityCallback";
                  v24 = 1024;
                  v25 = 1527;
                  v26 = 2048;
                  v27 = a3;
                  v28 = 1024;
                  v29 = v19;
                  _os_log_error_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_ERROR, " [%s] %s:%d SRTP authentication tag generation size mismatch: expected size=%zu, authenticated size=%d", buf, 0x2Cu);
                }
              }
LABEL_16:
              CheckOutHandleDebug();
              return v15;
            }
          }
        }
        __break(0x5519u);
      }
      v15 = 2147549186;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          RTPMediaQueueSecurityCallback_cold_4();
      }
    }
    else
    {
      v15 = 2149711873;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          RTPMediaQueueSecurityCallback_cold_3();
      }
    }
  }
  else
  {
    v15 = 2149711873;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RTPMediaQueueSecurityCallback_cold_2();
    }
  }
  return v15;
}

unint64_t _RTPSendTimestampWithMediaSampleTime(uint64_t a1, unsigned int a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unsigned int *v10;
  unsigned int v11;
  unint64_t result;

  v3 = *(_QWORD *)(a1 + 232);
  v4 = *(_QWORD *)(a1 + 240);
  v5 = v3 & 0xFFFFFFFF00000000;
  if (v3 - a2 >= 0x7FFFFFFF)
    v6 = v3 & 0xFFFFFFFF00000000;
  else
    v6 = (v3 & 0xFFFFFFFF00000000) - 0x100000000;
  if (v3 >= a2)
    v6 = v3 & 0xFFFFFFFF00000000;
  if (a2 - v3 < 0x7FFFFFFF)
    v5 += 0x100000000;
  if (v3 > a2)
    v7 = v5;
  else
    v7 = v6;
  v8 = v7 + a2;
  *(_QWORD *)(a1 + 232) = v8;
  v9 = v8 - v4;
  v10 = (unsigned int *)(a1 + 296);
  v11 = *(_DWORD *)(a1 + 296);
  if (v11 >= 7)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _RTPSendTimestampWithMediaSampleTime_cold_2();
    }
    v11 = *v10;
  }
  switch(v11)
  {
    case 1u:
      v9 >>= 1;
      break;
    case 2u:
      v9 -= v9 >> 2;
      break;
    case 3u:
    case 5u:
    case 6u:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _RTPSendTimestampWithMediaSampleTime_cold_1();
      }
      break;
    case 4u:
      v9 *= 2;
      break;
    default:
      break;
  }
  result = *(_QWORD *)(a1 + 256) + v9;
  *(_QWORD *)(a1 + 248) = result;
  return result;
}

uint64_t _RTPGetRTPSocketForMediaQueue(uint64_t a1, _DWORD *a2)
{
  uint64_t v3;
  uint64_t CMBaseObject;
  uint64_t (*v5)(uint64_t, const __CFString *, _QWORD, CFNumberRef *);
  uint64_t v6;
  CFNumberRef number[2];

  number[1] = *(CFNumberRef *)MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a2)
    {
      v3 = *(_QWORD *)(a1 + 11104);
      if (v3)
      {
        number[0] = 0;
        CMBaseObject = VCPacketFilterGetCMBaseObject(v3, a2);
        v5 = *(uint64_t (**)(uint64_t, const __CFString *, _QWORD, CFNumberRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                                          + 48);
        if (v5)
        {
          v6 = v5(CMBaseObject, CFSTR("UnderlyingVFD"), *MEMORY[0x1E0C9AE00], number);
          if ((v6 & 0x80000000) == 0)
          {
            CFNumberGetValue(number[0], kCFNumberIntType, a2);
            CFRelease(number[0]);
          }
        }
        else
        {
          return 4294954514;
        }
      }
      else
      {
        v6 = 0;
        *a2 = *(_DWORD *)(a1 + 4);
      }
    }
    else
    {
      v6 = 2147549185;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _RTPGetRTPSocketForMediaQueue_cold_2();
      }
    }
  }
  else
  {
    v6 = 2147549185;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _RTPGetRTPSocketForMediaQueue_cold_1();
    }
  }
  return v6;
}

uint64_t RTPTransportResendRTP(double a1, uint64_t a2, int a3, int a4, int *a5)
{
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unsigned __int16 **v14;
  unsigned __int16 *v15;
  unsigned __int16 *v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  BOOL v20;
  uint64_t v21;
  int *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  char v30;
  int v31;
  int *v32;
  uint64_t v33;
  int v34;
  const void *v35;
  unsigned __int8 v36;
  uint64_t v37;
  uint64_t (*v38)(uint64_t, uint8_t *);
  int v39;
  uint64_t v40;
  NSObject *v41;
  NSObject *v42;
  unsigned int v43;
  unsigned int v44;
  int v45;
  int v46;
  int v47;
  int IDSAttributeSizeWithChannelDataFormat;
  int v49;
  int v50;
  unsigned int v51;
  unsigned int v52;
  int v53;
  int v54;
  uint64_t v55;
  NSObject *v56;
  uint64_t v57;
  NSObject *v58;
  NSObject *v59;
  int v61;
  int *v62;
  int v63;
  __int16 v64;
  __int16 v65;
  double v66;
  unint64_t v67;
  uint64_t v68;
  uint64_t v69;
  unsigned __int8 src[2];
  __int16 v71;
  int v72;
  int v73;
  int v74;
  uint8_t buf[112];
  __int128 v76;
  _OWORD v77[3];
  uint64_t v78;

  v78 = *MEMORY[0x1E0C80C00];
  v9 = 2147549188;
  v69 = 0;
  v10 = CheckInHandleDebug();
  if (!v10)
    return 2147549186;
  v11 = v10;
  if (v10 != 0xFFFFFFFF)
  {
    v62 = a5;
    if (v10 >= v10 + 27616)
      goto LABEL_97;
    ++*(_QWORD *)(v10 + 352);
    v63 = a3;
    v64 = a4;
    v65 = 1;
    v66 = a1;
    v67 = 0xAAAAAAAAAAAA0000;
    v68 = 0;
    v12 = a4 & 0x3FF;
    v13 = v10 + 11208;
    v14 = (unsigned __int16 **)(v10 + 11208 + 16 * v12);
    if (!v14)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v55 = VRTraceErrorLogLevelToCSTR();
        v56 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136316162;
          *(_QWORD *)&buf[4] = v55;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_RTPTransportRetrieveMediaPacketHistory";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 1358;
          *(_WORD *)&buf[28] = 2048;
          *(_QWORD *)&buf[30] = v11;
          *(_WORD *)&buf[38] = 1024;
          *(_DWORD *)&buf[40] = a4 & 0x3FF;
          _os_log_error_impl(&dword_1D8A54000, v56, OS_LOG_TYPE_ERROR, " [%s] %s:%d mediaPacketHistory retrieval failed for rtpInfo=%p with seqNumHash=%d", buf, 0x2Cu);
        }
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v57 = VRTraceErrorLogLevelToCSTR();
        v58 = *MEMORY[0x1E0CF2758];
        v59 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = v57;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "RTPTransportResendRTP";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 1971;
            _os_log_impl(&dword_1D8A54000, v58, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Couldn't retrieve media packet from cache for retransmission", buf, 0x1Cu);
          }
        }
        else if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG))
        {
          RTPTransportResendRTP_cold_1();
        }
      }
      LOBYTE(v65) = 0;
      goto LABEL_92;
    }
    if ((unint64_t)v14 >= v10 + 27592
      || v13 > (unint64_t)v14
      || (unint64_t)(v14 + 2) > v10 + 27592)
    {
      goto LABEL_97;
    }
    v15 = *v14;
    if (!*v14)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          RTPTransportResendRTP_cold_2();
      }
      goto LABEL_92;
    }
    v16 = v15 + 40;
    if (*v15 != a4)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          RTPTransportResendRTP_cold_10();
      }
      goto LABEL_92;
    }
    if (*((_DWORD *)v15 + 1) != a3)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          RTPTransportResendRTP_cold_9();
      }
      goto LABEL_92;
    }
    v61 = *((unsigned __int8 *)v15 + 56);
    if (*((_BYTE *)v15 + 56))
    {
      v17 = *((_QWORD *)v15 + 5);
      if (v17)
      {
        *(_BYTE *)(v17 + 76) = 1;
        v18 = 74;
        if (!*(_BYTE *)(v17 + 72))
          v18 = 0;
        v19 = *(unsigned __int16 *)(v17 + v18);
        if (*(_BYTE *)(v17 + 24))
          v20 = 0;
        else
          v20 = v19 == 0;
        if (v20)
          v19 = *(_DWORD *)(v10 + 200);
        *(_DWORD *)buf = -1;
        v21 = _RTPGetRTPSocketForMediaQueue(v10, buf);
        if ((v21 & 0x80000000) == 0)
        {
          v22 = (int *)(v15 + 4);
          if (*((int *)v15 + 2) >= 1501)
          {
            v9 = 2147549198;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              {
                RTPTransportResendRTP_cold_6();
                v9 = 2147549198;
              }
            }
            goto LABEL_92;
          }
          v23 = VCMediaQueue_AllocMediaPacket(*(_QWORD *)(v11 + 10440), v19, 2, (uint64_t)&v69);
          if ((v23 & 0x80000000) != 0)
          {
            v9 = v23;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                RTPTransportResendRTP_cold_7();
            }
            goto LABEL_92;
          }
          v24 = *(_QWORD *)(v13 + 16 * v12 + 8);
          v25 = v69;
          *(_QWORD *)(v69 + 8) = v24;
          *(double *)(v25 + 272) = a1;
          v26 = *(_OWORD *)(v17 + 16);
          v27 = *(_OWORD *)(v17 + 32);
          v28 = *(_OWORD *)(v17 + 48);
          *(_OWORD *)(v25 + 80) = *(_OWORD *)(v17 + 64);
          v29 = *(_OWORD *)v17;
          *(_OWORD *)(v25 + 48) = v27;
          *(_OWORD *)(v25 + 64) = v28;
          *(_OWORD *)(v25 + 16) = v29;
          *(_OWORD *)(v25 + 32) = v26;
          *(_DWORD *)(v25 + 176) = 3;
          *(_BYTE *)(v25 + 295) = 1;
          *(_BYTE *)(v25 + 94) = 0;
          *(_WORD *)(v25 + 248) = a4;
          *(_WORD *)(v25 + 4) = *((_DWORD *)v15 + 2);
          *(_DWORD *)(v25 + 264) = *(_DWORD *)buf;
          if (v15 < v16)
          {
            *(_DWORD *)v25 = VCIDSChannelData_GetIDSHeaderSizeWithChannelDataFormatArray(v25 + 16, 1u);
            *(_DWORD *)(v25 + 244) = *((_DWORD *)v15 + 3);
            *(_OWORD *)(v25 + 208) = xmmword_1D910B200;
            *(_BYTE *)(v25 + 224) = 0;
            v30 = *(_BYTE *)(v25 + 93);
            *(_BYTE *)(v25 + 225) = v30 ^ 1;
            *(_BYTE *)(v25 + 288) = *((_BYTE *)v15 + 28);
            *(_BYTE *)(v25 + 226) = v30;
            *(_BYTE *)(v25 + 289) = *((_BYTE *)v15 + 48);
            *(_BYTE *)(v25 + 293) = *(_DWORD *)(v11 + 12) != 0;
            *(_BYTE *)(v25 + 290) = *((_BYTE *)v15 + 22);
            *(_BYTE *)(v25 + 291) = *((_BYTE *)v15 + 20);
            v32 = (int *)(v15 + 8);
            v31 = *((_DWORD *)v15 + 4);
            *(_BYTE *)(v25 + 292) = *((_BYTE *)v15 + 21);
            *(_QWORD *)(v25 + 304) = 0;
            *(_DWORD *)(v25 + 232) = *(_DWORD *)(v11 + 10400);
            *(_DWORD *)(v25 + 236) = v31;
            *(_DWORD *)(v25 + 240) = *(_DWORD *)(v11 + 316);
            *(_DWORD *)(v25 + 252) = *(_DWORD *)(v11 + 200);
            *(_BYTE *)(v25 + 227) = *(_DWORD *)(v11 + 28) == 0;
            *(_DWORD *)(v25 + 256) = *((_DWORD *)v15 + 6);
            *(_DWORD *)(v25 + 260) = *((_DWORD *)v15 + 8);
            *(_BYTE *)(v25 + 294) = 1;
            VCMediaQueue_AddPacket(*(_QWORD *)(v11 + 10440), v69);
            v9 = v33;
            if ((v33 & 0x80000000) != 0)
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  RTPTransportResendRTP_cold_8();
              }
              goto LABEL_92;
            }
            v34 = *(unsigned __int16 *)(v69 + 4);
            goto LABEL_37;
          }
LABEL_97:
          __break(0x5519u);
        }
        v9 = v21;
      }
LABEL_92:
      VCNACKConsumer_UpdateRetransmissionStatus(*(_QWORD *)(v11 + 27592), &v63);
      CheckOutHandleDebug();
      return v9;
    }
    if (v15 >= v16)
      goto LABEL_97;
    v35 = *(const void **)(v13 + 16 * v12 + 8);
    v76 = unk_1D910B4B0;
    v77[0] = xmmword_1D910B4C0;
    memset(&v77[1], 170, 24);
    memset(buf, 170, sizeof(buf));
    if ((VCPacketInitialize((uint64_t)buf) & 0x80000000) == 0)
    {
      if (*(_QWORD *)(v11 + 11104))
      {
        if (v35)
        {
          v22 = (int *)(v15 + 4);
          if (*((int *)v15 + 2) <= 0)
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                RTPTransportResendRTP_cold_5();
            }
          }
          else
          {
            *(_QWORD *)buf = v35;
            CFRetain(v35);
            *(_WORD *)&buf[8] = 257;
            *(_QWORD *)&buf[56] = *v15;
            *(_QWORD *)&buf[64] = *((unsigned int *)v15 + 1);
            v32 = (int *)(v15 + 8);
            *(_QWORD *)&buf[72] = *((unsigned int *)v15 + 4);
            DWORD1(v77[0]) = *((_DWORD *)v15 + 13);
            v36 = *(_BYTE *)(v11 + 17) & 0x7F;
            v73 = *(_DWORD *)&buf[64];
            v74 = 0;
            src[0] = 1;
            src[1] = v36;
            v71 = *(_WORD *)&buf[56];
            v72 = *(_DWORD *)&buf[72];
            uuid_copy((unsigned __int8 *)v77 + 8, src);
            if ((_RTPEnsureTransportStreamsActivated(v11) & 0x80000000) == 0)
            {
              v37 = *(_QWORD *)(v11 + 11104);
              v38 = *(uint64_t (**)(uint64_t, uint8_t *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 16);
              if (v38)
              {
                v39 = v38(v37, buf);
                VCPacketInvalidate((uint64_t *)buf);
                if ((v39 & 0x80000000) == 0)
                {
                  v34 = *v22;
                  if (*v22 != -1)
                  {
                    v9 = 0;
                    v17 = 0;
LABEL_37:
                    kdebug_trace();
                    HIBYTE(v65) = 1;
                    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
                    {
                      v40 = VRTraceErrorLogLevelToCSTR();
                      v41 = *MEMORY[0x1E0CF2758];
                      v42 = *MEMORY[0x1E0CF2758];
                      if (*MEMORY[0x1E0CF2748])
                      {
                        if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
                        {
                          v43 = *(unsigned __int16 *)(v11 + 16);
                          v44 = bswap32(*(unsigned __int16 *)(v11 + 18));
                          v45 = *v32;
                          v46 = *(_DWORD *)(v11 + 200);
                          *(_DWORD *)buf = 136316930;
                          *(_QWORD *)&buf[4] = v40;
                          *(_WORD *)&buf[12] = 2080;
                          *(_QWORD *)&buf[14] = "RTPTransportResendRTP";
                          *(_WORD *)&buf[22] = 1024;
                          *(_DWORD *)&buf[24] = 2027;
                          *(_WORD *)&buf[28] = 1024;
                          *(_DWORD *)&buf[30] = v43 >> 15;
                          *(_WORD *)&buf[34] = 1024;
                          *(_DWORD *)&buf[36] = (v43 >> 8) & 0x7F;
                          *(_WORD *)&buf[40] = 1024;
                          *(_DWORD *)&buf[42] = HIWORD(v44);
                          *(_WORD *)&buf[46] = 1024;
                          *(_DWORD *)&buf[48] = v45;
                          *(_WORD *)&buf[52] = 1024;
                          *(_DWORD *)&buf[54] = v46;
                          _os_log_impl(&dword_1D8A54000, v41, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Resent RTP packet with marker=%u, payload type=%u, sequence number=%u, timestamp=%u, ssrc=%u", buf, 0x3Au);
                        }
                      }
                      else if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
                      {
                        v51 = *(unsigned __int16 *)(v11 + 16);
                        v52 = bswap32(*(unsigned __int16 *)(v11 + 18));
                        v53 = *v32;
                        v54 = *(_DWORD *)(v11 + 200);
                        *(_DWORD *)buf = 136316930;
                        *(_QWORD *)&buf[4] = v40;
                        *(_WORD *)&buf[12] = 2080;
                        *(_QWORD *)&buf[14] = "RTPTransportResendRTP";
                        *(_WORD *)&buf[22] = 1024;
                        *(_DWORD *)&buf[24] = 2027;
                        *(_WORD *)&buf[28] = 1024;
                        *(_DWORD *)&buf[30] = v51 >> 15;
                        *(_WORD *)&buf[34] = 1024;
                        *(_DWORD *)&buf[36] = (v51 >> 8) & 0x7F;
                        *(_WORD *)&buf[40] = 1024;
                        *(_DWORD *)&buf[42] = HIWORD(v52);
                        *(_WORD *)&buf[46] = 1024;
                        *(_DWORD *)&buf[48] = v53;
                        *(_WORD *)&buf[52] = 1024;
                        *(_DWORD *)&buf[54] = v54;
                        _os_log_debug_impl(&dword_1D8A54000, v41, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Resent RTP packet with marker=%u, payload type=%u, sequence number=%u, timestamp=%u, ssrc=%u", buf, 0x3Au);
                      }
                    }
                    v47 = *(_DWORD *)(v11 + 208);
                    ++*(_DWORD *)(v11 + 204);
                    *(_DWORD *)(v11 + 208) = v47 + *v22;
                    if (v61)
                      IDSAttributeSizeWithChannelDataFormat = VCIDSChannelData_GetIDSAttributeSizeWithChannelDataFormat(v17);
                    else
                      IDSAttributeSizeWithChannelDataFormat = 0;
                    if (*(_DWORD *)(v11 + 12))
                      v49 = 48;
                    else
                      v49 = 28;
                    v50 = IDSAttributeSizeWithChannelDataFormat + v34 + v49;
                    v68 = v50;
                    if (v62)
                      *v62 = v50;
                    if (*(_DWORD *)(v11 + 28) == 1)
                      _RTPUpdateAFRCVideoSendingBitrate(v11, v50, *((unsigned __int8 *)v15 + 20), a1);
                    goto LABEL_92;
                  }
                }
                goto LABEL_91;
              }
            }
          }
        }
        else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            RTPTransportResendRTP_cold_4();
        }
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          RTPTransportResendRTP_cold_3();
      }
    }
    VCPacketInvalidate((uint64_t *)buf);
LABEL_91:
    v9 = *__error() | 0xC0010000;
    goto LABEL_92;
  }
  return 2147549190;
}

uint64_t RTPRexmitRTP(uint64_t a1, int a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  NSObject *v11;
  int v13;
  uint64_t v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v6 = 2147549186;
  v7 = CheckInHandleDebug();
  if (v7)
  {
    v8 = v7;
    if (*(_QWORD *)(v7 + 10352) != 0xFFFFFFFFLL)
    {
      if (v7 == 0xFFFFFFFFLL)
      {
        return 2147549190;
      }
      else
      {
        *a4 = 0;
        v9 = bswap32(*(_DWORD *)(v7 + 24));
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v10 = VRTraceErrorLogLevelToCSTR();
          v11 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v13 = 136315906;
            v14 = v10;
            v15 = 2080;
            v16 = "RTPRexmitRTP";
            v17 = 1024;
            v18 = 2072;
            v19 = 1024;
            v20 = a2;
            _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTPRexmitRTP rexmit packet (%04X)", (uint8_t *)&v13, 0x22u);
          }
        }
        MediaQueue_RexmitPacket(*(_QWORD *)(v8 + 10352), v9, a2, a4);
        CheckOutHandleDebug();
        if (*a4)
          return 0;
        else
          return 2147549196;
      }
    }
  }
  return v6;
}

unint64_t _RTPMediaSampleTimeWithReceiveTimestamp(uint64_t a1, unsigned int a2, int a3)
{
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unsigned int v9;
  unint64_t v10;
  unint64_t result;

  if (a3)
  {
    v4 = a2;
    *(_QWORD *)(a1 + 280) = a2;
    *(_QWORD *)(a1 + 288) = 0;
    *(_QWORD *)(a1 + 264) = 0;
    *(_QWORD *)(a1 + 272) = 0;
  }
  else
  {
    v5 = *(_QWORD *)(a1 + 280);
    v6 = v5 & 0xFFFFFFFF00000000;
    if (v5 - a2 >= 0x7FFFFFFF)
      v7 = v5 & 0xFFFFFFFF00000000;
    else
      v7 = (v5 & 0xFFFFFFFF00000000) - 0x100000000;
    if (v5 >= a2)
      v7 = v5 & 0xFFFFFFFF00000000;
    if (a2 - v5 < 0x7FFFFFFF)
      v6 += 0x100000000;
    if (v5 > a2)
      v8 = v6;
    else
      v8 = v7;
    v4 = v8 + a2;
    *(_QWORD *)(a1 + 280) = v4;
  }
  v9 = *(_DWORD *)(a1 + 300);
  if (v9 >= 7)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _RTPMediaSampleTimeWithReceiveTimestamp_cold_2();
    }
    v9 = *(_DWORD *)(a1 + 300);
    v4 = *(_QWORD *)(a1 + 280);
  }
  v10 = v4 - *(_QWORD *)(a1 + 288);
  switch(v9)
  {
    case 1u:
      v10 >>= 1;
      break;
    case 2u:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _RTPMediaSampleTimeWithReceiveTimestamp_cold_1();
      }
      break;
    case 3u:
      v10 += v10 / 3;
      break;
    case 4u:
      v10 *= 2;
      break;
    case 5u:
      v10 += v10 >> 1;
      break;
    case 6u:
      v10 *= 3;
      break;
    default:
      break;
  }
  result = *(_QWORD *)(a1 + 272) + v10;
  *(_QWORD *)(a1 + 264) = result;
  return result;
}

uint64_t RTPProcessDecryptionStatusChange(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2147549186;
  v4 = _RTPProcessDecryptionStatusChange(v3, a2);
  CheckOutHandleDebug();
  return v4;
}

uint64_t _RTPProcessDecryptionStatusChange(uint64_t a1, int a2)
{
  int v2;
  uint64_t (*v4)(uint64_t, _QWORD, char *, _QWORD);
  uint64_t v5;
  uint64_t v6;
  char v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = a2;
  v2 = *(_DWORD *)(a1 + 10464);
  if (v2 != -1 && v2 == a2)
    return 0;
  *(_DWORD *)(a1 + 10464) = a2;
  v4 = *(uint64_t (**)(uint64_t, _QWORD, char *, _QWORD))(a1 + 10384);
  if (!v4)
    return 0;
  v5 = v4(5, *(_QWORD *)(a1 + 10392), &v8, 0);
  if ((v5 & 0x80000000) == 0)
    return 0;
  v6 = v5;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _RTPProcessDecryptionStatusChange_cold_1();
  }
  return v6;
}

uint64_t RTPReleaseRTPPacket(uint64_t a1, _DWORD **a2)
{
  uint64_t result;

  result = CheckInHandleDebug();
  if (result)
  {
    _RTPReleaseRTPPacketInternal(result, a2);
    return CheckOutHandleDebug();
  }
  return result;
}

uint64_t RTPRecvRTP(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _DWORD *v7;
  int v8;
  int v9;
  uint64_t v10;
  _DWORD *v11;
  uint64_t v12;
  NSObject *v13;
  int v14;
  uint64_t v16;
  NSObject *v17;
  _DWORD *v18;
  uint8_t buf[4];
  uint64_t v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v4 = 2147549186;
  v5 = CheckInHandleDebug();
  if (v5)
  {
    v6 = v5;
    if (v5 == 0xFFFFFFFFLL)
    {
      return 2147549190;
    }
    else
    {
      v18 = 0;
      v4 = (uint64_t)RecvRTP(a1, v5, &v18);
      if ((v4 & 0x80000000) != 0 || (v7 = v18) == 0)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          v16 = VRTraceErrorLogLevelToCSTR();
          v17 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315906;
            v20 = v16;
            v21 = 2080;
            v22 = "RTPRecvRTP";
            v23 = 1024;
            v24 = 2293;
            v25 = 1024;
            v26 = v4;
            _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Failed to parse RTP packet: %d", buf, 0x22u);
          }
        }
      }
      else
      {
        if (!*v18 && !*(_DWORD *)(v6 + 28))
        {
          v8 = *((unsigned __int8 *)v18 + 104);
          v9 = *(_DWORD *)(v6 + 152);
          if (v9 != v8)
          {
            if (*((_BYTE *)v18 + 104))
            {
              (*(void (**)(uint64_t, _QWORD, _DWORD *, _QWORD))(v6 + 10384))(2, *(_QWORD *)(v6 + 10392), v18 + 25, 0);
            }
            else
            {
              if (v9 == -1)
              {
                v11 = v18 + 25;
                v10 = 0;
              }
              else
              {
                v10 = 1;
                v11 = 0;
              }
              (*(void (**)(uint64_t, _QWORD, _DWORD *, _QWORD))(v6 + 10384))(v10, *(_QWORD *)(v6 + 10392), v11, 0);
            }
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v12 = VRTraceErrorLogLevelToCSTR();
              v13 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                v14 = *(_DWORD *)(v6 + 152);
                *(_DWORD *)buf = 136316162;
                v20 = v12;
                v21 = 2080;
                v22 = "RTPRecvRTP";
                v23 = 1024;
                v24 = 2311;
                v25 = 1024;
                v26 = v14;
                v27 = 1024;
                v28 = v8;
                _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTP relay flag (%d->%d).", buf, 0x28u);
              }
            }
            *(_DWORD *)(v6 + 152) = v8;
          }
        }
        *a2 = v7;
        v18 = 0;
      }
      _RTPReleaseRTPPacketInternal(v6, &v18);
      CheckOutHandleDebug();
    }
  }
  return v4;
}

_DWORD *RecvRTP(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  const __CFAllocator *v9;
  __CFArray *Mutable;
  const void *v11;
  uint64_t (*v12)(uint64_t, double);
  uint64_t v13;
  _DWORD *v15[2];

  v15[1] = *(_DWORD **)MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(a2 + 11104))
  {
    v15[0] = 0;
    v5 = _RTPEnsureTransportStreamsActivated(a2);
    if ((v5 & 0x80000000) == 0)
    {
      v6 = (uint64_t *)(a2 + 11160);
      v7 = *(_QWORD *)(a2 + 11160);
      v15[0] = (_DWORD *)v7;
      if (v7)
      {
LABEL_14:
        v13 = *(_QWORD *)(v7 + 6056);
        *v6 = v13;
        if (!v13)
          *(_QWORD *)(a2 + 11168) = v6;
        *a3 = v7;
        v15[0] = 0;
        goto LABEL_17;
      }
      v8 = *(_QWORD *)(a2 + 11152);
      if (!v8)
      {
        v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
        CFArrayAppendValue(Mutable, *(const void **)(a2 + 11104));
        v11 = *(const void **)(a2 + 11120);
        if (v11)
          CFArrayAppendValue(Mutable, v11);
        v5 = VCTransportStreamRunLoopCreateWithTransportStreams(v9, Mutable, (CFTypeRef *)(a2 + 11152));
        if (Mutable)
          CFRelease(Mutable);
        if ((v5 & 0x80000000) != 0)
          goto LABEL_17;
        v8 = *(_QWORD *)(a2 + 11152);
      }
      v12 = *(uint64_t (**)(uint64_t, double))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 24);
      if (v12)
      {
        v5 = v12(v8, 0.0);
        if ((v5 & 0x80000000) == 0)
        {
          v7 = *v6;
          goto LABEL_14;
        }
      }
      else
      {
        v5 = 4294954514;
      }
    }
LABEL_17:
    _RTPReleaseRTPPacketInternal(a2, v15);
    return (_DWORD *)v5;
  }
  return _RTPRecvWithSocket(a1, a2, a3);
}

uint64_t _RTPTransport_EstimateRTCPXRSummaryJitter(uint64_t result, uint64_t a2, int a3, uint64_t a4, double a5, double a6, double a7)
{
  int v7;
  double v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int *v13;
  unsigned int v15;
  unsigned int v16;

  v7 = *(_DWORD *)(result + 4836) - *(_DWORD *)(a4 + 4);
  if (v7)
  {
    v8 = *(double *)(a2 + 128);
    v9 = *(unsigned __int16 *)(a4 + 2);
    v10 = *(_DWORD *)(result + 4848);
    if (v10 >= v9)
      v10 = *(unsigned __int16 *)(a4 + 2);
    v11 = v9 - v10;
    if (v9 - v10 <= 0x13F)
      v9 = v10;
    *(_DWORD *)(result + 4848) = v9;
    if (v11 <= 0x13F)
      v12 = v11;
    else
      v12 = 0;
    v13 = (unsigned int *)(result + 4872 + 4 * v12);
    if ((unint64_t)v13 < result + 6152 && (unint64_t)v13 >= result + 4872)
    {
      LODWORD(a7) = *(_DWORD *)(result + 700);
      v15 = v7 + vcvtad_u64_f64((v8 - *(double *)(result + 4864)) * (double)*(unint64_t *)&a7);
      if (a3)
        v15 = 0;
      *v13 = v15;
      *(_DWORD *)(result + 4836) = *(_DWORD *)(a4 + 4);
      *(double *)(result + 4864) = v8;
      *(_BYTE *)(result + 6152 + v12) = *(_BYTE *)(a2 + 136);
      v16 = *(_DWORD *)(result + 4856);
      if (v12 > v16)
        v16 = v12;
      *(_DWORD *)(result + 4856) = v16;
    }
    else
    {
      __break(0x5519u);
    }
  }
  return result;
}

uint64_t _RTPTransport_ParseMediaPacket(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  int v7;
  OSStatus DataPointer;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  _BOOL4 v17;
  unsigned int v18;
  double v20;
  uint64_t v21;
  NSObject *v22;
  int v23;
  int v24;
  _DWORD *v25;
  uint64_t v26;
  NSObject *v27;
  int v28;
  int v29;
  uint64_t v30;
  NSObject *v31;
  double v32;
  int v33;
  uint64_t v34;
  NSObject *v35;
  double v36;
  uint64_t v37;
  NSObject *v38;
  int v39;
  int v40;
  uint64_t v41;
  unsigned int *v42;
  uint64_t v43;
  size_t v44;
  int v45;
  uint64_t v46;
  int v47;
  int v48;
  NSObject *v49;
  NSObject *v50;
  unsigned int *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  _DWORD *v56;
  int v57;
  size_t v58;
  size_t v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  size_t v65;
  uint64_t v66;
  uint64_t (*v67)(uint64_t, _QWORD, uint64_t, _QWORD);
  uint64_t v68;
  NSObject *v69;
  uint64_t v70;
  NSObject *v71;
  uint64_t v72;
  char *v73;
  uint64_t v74;
  uint64_t v75;
  unsigned int v76;
  uint64_t (*v77)(uint64_t, _QWORD, void *, _QWORD);
  const __CFDictionary *ValueAtIndex;
  const char *Value;
  int v80;
  int ErrorLogLevelForModule;
  uint64_t v82;
  NSObject *v83;
  const char *v84;
  int v85;
  int v86;
  int v87;
  uint64_t v88;
  int v89;
  uint64_t v90;
  NSObject *v91;
  uint64_t v92;
  NSObject *v93;
  int v94;
  uint64_t v95;
  NSObject *v96;
  uint64_t v97;
  NSObject *v98;
  uint64_t v99;
  NSObject *v100;
  const char *v101;
  const char *v102;
  unint64_t v103;
  int v104;
  uint64_t v105;
  unsigned int v106;
  int v107;
  char *v108;
  __int16 v109;
  uint64_t v110;
  __int128 v111;
  double v112;
  unsigned int v113;
  unsigned int v114;
  double v115;
  unsigned int v116;
  int v117;
  unsigned int v118;
  unsigned int v119;
  OpaqueCMBlockBuffer *v120;
  size_t v121;
  char *v122;
  double v123;
  double v124;
  double v125;
  unsigned int v126;
  unint64_t v127;
  size_t v128;
  char *v129;
  OpaqueCMBlockBuffer *v130;
  char *v131;
  char *v132;
  uint64_t v133;
  size_t v134;
  char *v135;
  uint64_t v136;
  char *v137;
  char *v138;
  char *v139;
  size_t v140;
  unint64_t v141;
  size_t v142;
  char *v143;
  char *v144;
  char *v145;
  uint64_t v146;
  size_t v147;
  unsigned __int8 v148;
  uint64_t v149;
  char *v150;
  int v151;
  BOOL v153;
  unint64_t v154;
  uint64_t v155;
  NSObject *v156;
  char *v157;
  uint64_t v158;
  NSObject *v159;
  uint64_t v160;
  unsigned __int16 offsetToData;
  size_t offsetToDataa;
  uint64_t offsetToDatab;
  uint64_t v164;
  uint64_t v165;
  size_t v166;
  unsigned int v167;
  char InternalPayload;
  uint64_t v169;
  uint64_t v170;
  char *v171;
  int v172;
  unsigned int v173;
  int log;
  int loga;
  NSObject *logb;
  unsigned int logc;
  int v178;
  size_t v179;
  unsigned int v180;
  unsigned int v181;
  unsigned int v182;
  uint64_t v183;
  char *dataPointerOut;
  size_t lengthAtOffsetOut;
  uint64_t v186;
  unsigned int v187;
  signed int v188;
  char v189;
  CFArrayRef theArray;
  void *v191;
  uint64_t v192;
  _BYTE buf[28];
  _OWORD v194[2];
  __int128 v195;
  unsigned int v196;
  __int128 v197;
  __int128 v198;
  __int128 v199;
  __int128 v200;
  __int128 v201;
  __int128 v202;
  __int128 v203;
  uint64_t v204;
  uint64_t v205;

  v205 = *MEMORY[0x1E0C80C00];
  v3 = a2 + 88;
  if (*(_DWORD *)(a2 + 88) == -1)
  {
    v10 = 2147549195;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        _RTPTransport_ParseMediaPacket_cold_1();
        return 2147549195;
      }
    }
  }
  else
  {
    v7 = *(_DWORD *)(a1 + 4832);
    dataPointerOut = 0;
    lengthAtOffsetOut = 0;
    DataPointer = CMBlockBufferGetDataPointer(*(CMBlockBufferRef *)a2, 0, &lengthAtOffsetOut, 0, &dataPointerOut);
    if (!DataPointer)
    {
      *(_DWORD *)a3 = 0;
      if (dataPointerOut && !lengthAtOffsetOut)
        goto LABEL_304;
      v9 = 2147549191;
      if (lengthAtOffsetOut < 0xC)
      {
        v9 = 2147549192;
        goto LABEL_23;
      }
      v11 = *(_QWORD *)dataPointerOut;
      v186 = v11;
      v12 = *((_DWORD *)dataPointerOut + 2);
      v13 = WORD1(v11);
      v14 = __rev16(WORD1(v11));
      WORD1(v186) = v14;
      v15 = bswap32(HIDWORD(v11));
      v16 = bswap32(v12);
      v187 = v16;
      if (*(_DWORD *)(a1 + 7004))
        v17 = *(_DWORD *)(a1 + 4832) != v16;
      else
        v17 = 1;
      v181 = _RTPMediaSampleTimeWithReceiveTimestamp(a1, v15, v17);
      HIDWORD(v186) = v181;
      v18 = (unsigned __int16)v186;
      if ((v186 & 0xC0) != 0x80)
      {
        v9 = 2147549193;
LABEL_23:
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _RTPTransport_ParseMediaPacket_cold_2();
        }
        return v9;
      }
      if (!*(_DWORD *)(a1 + 7004) && !v13 && !*(_DWORD *)(a1 + 188))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _RTPTransport_ParseMediaPacket_cold_3();
        }
        goto LABEL_23;
      }
      v167 = BYTE1(v186) & 0x7F;
      InternalPayload = RTPMapGetInternalPayload(*(unsigned __int16 ***)(a1 + 64), v167);
      LOWORD(v186) = ((InternalPayload & 0x7F) << 8) | v18 & 0x80FF;
      if (!*(_DWORD *)(a1 + 28))
        kdebug_trace();
      v178 = v7;
      v182 = v14;
      v173 = v16;
      v180 = v18;
      if (*(_DWORD *)(a1 + 7004) && *(_DWORD *)(a1 + 4832) == v16)
      {
        v172 = 0;
      }
      else
      {
        v20 = *(double *)(a2 + 128);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
        {
          v21 = VRTraceErrorLogLevelToCSTR();
          v22 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v23 = *(_DWORD *)(a1 + 28);
            v24 = *(_DWORD *)(a1 + 4832);
            *(_DWORD *)buf = 136317186;
            *(_QWORD *)&buf[4] = v21;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_RTPTransport_ReinitializeStream";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 2361;
            LOWORD(v194[0]) = 1024;
            *(_DWORD *)((char *)v194 + 2) = v23;
            WORD3(v194[0]) = 1024;
            DWORD2(v194[0]) = v173;
            WORD6(v194[0]) = 1024;
            *(_DWORD *)((char *)v194 + 14) = v24;
            WORD1(v194[1]) = 1024;
            DWORD1(v194[1]) = InternalPayload & 0x7F;
            WORD4(v194[1]) = 1024;
            *(_DWORD *)((char *)&v194[1] + 10) = v14;
            HIWORD(v194[1]) = 1024;
            LODWORD(v195) = v181;
            _os_log_impl(&dword_1D8A54000, v22, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTP(%d): recv started(%X,%X, %d) SeqNum = %u, TimeStamp = %u", buf, 0x40u);
          }
        }
        *(_WORD *)(a1 + 688) = v14;
        *(_DWORD *)(a1 + 692) = v14;
        *(_DWORD *)(a1 + 696) = v181;
        *(_QWORD *)(a1 + 4816) = 0;
        *(_DWORD *)(a1 + 4828) = 0;
        *(_DWORD *)(a1 + 4832) = v173;
        bzero((void *)(a1 + 716), 0x1000uLL);
        *(_OWORD *)(a1 + 704) = xmmword_1D910B210;
        *(_QWORD *)(a1 + 6488) = MicroToNTP(v20);
        *(_DWORD *)(a1 + 7004) = 1;
        *(_OWORD *)(a1 + 6792) = 0u;
        *(_OWORD *)(a1 + 6808) = 0u;
        *(_OWORD *)(a1 + 6824) = 0u;
        *(_OWORD *)(a1 + 6840) = 0u;
        *(_OWORD *)(a1 + 6856) = 0u;
        *(_OWORD *)(a1 + 6872) = 0u;
        *(_OWORD *)(a1 + 6888) = 0u;
        *(_OWORD *)(a1 + 6904) = 0u;
        *(_OWORD *)(a1 + 6920) = 0u;
        *(_OWORD *)(a1 + 6936) = 0u;
        *(_OWORD *)(a1 + 6952) = 0u;
        *(_OWORD *)(a1 + 6968) = 0u;
        *(_QWORD *)(a1 + 6984) = 0;
        *(_QWORD *)(a1 + 6992) = 0;
        os_unfair_lock_lock((os_unfair_lock_t)(a1 + 8844));
        v25 = (_DWORD *)(a1 + 7520);
        *(_DWORD *)(a1 + 7640) = v173;
        *(_BYTE *)(a1 + 8840) = 1;
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 8844));
        *(_DWORD *)(a1 + 8520) = v173;
        *(_WORD *)(a1 + 7650) = v14;
        if ((int)VRTraceGetErrorLogLevelForModule() > 6)
        {
          v26 = VRTraceErrorLogLevelToCSTR();
          v27 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v28 = *v25 & 1;
            v29 = (*v25 >> 2) & 1;
            *(_DWORD *)buf = 136316162;
            *(_QWORD *)&buf[4] = v26;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_RTPTransport_ReinitializeStream";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 2395;
            LOWORD(v194[0]) = 1024;
            *(_DWORD *)((char *)v194 + 2) = v28;
            WORD3(v194[0]) = 1024;
            DWORD2(v194[0]) = v29;
            _os_log_impl(&dword_1D8A54000, v27, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTPTransport: need to wait for SRTP to init? (%d/%d)", buf, 0x28u);
          }
        }
        if (*v25 == 1)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v30 = VRTraceErrorLogLevelToCSTR();
            v31 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315650;
              *(_QWORD *)&buf[4] = v30;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_RTPTransport_ReinitializeStream";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 2398;
              _os_log_impl(&dword_1D8A54000, v31, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTPTransport: Need to wait for SRTP to init...", buf, 0x1Cu);
            }
          }
          v192 = 0x4034000000000000;
          v32 = micro();
          v33 = SRTPWaitUseEncryptionRTP(a1 + 7520, &v192);
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v34 = VRTraceErrorLogLevelToCSTR();
            v35 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              v36 = micro();
              *(_DWORD *)buf = 136316162;
              *(_QWORD *)&buf[4] = v34;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_RTPTransport_ReinitializeStream";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 2404;
              LOWORD(v194[0]) = 2048;
              *(double *)((char *)v194 + 2) = v36 - v32;
              WORD5(v194[0]) = 1024;
              HIDWORD(v194[0]) = v33;
              _os_log_impl(&dword_1D8A54000, v35, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTPTransport: end wait SRTP @ %.3f seconds (%08X)", buf, 0x2Cu);
            }
          }
          v7 = v178;
          if (v33 < 0)
          {
            v10 = 2147549199;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              {
                _RTPTransport_ParseMediaPacket_cold_17();
                v10 = 2147549199;
              }
            }
LABEL_285:
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v155 = VRTraceErrorLogLevelToCSTR();
              v156 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315906;
                *(_QWORD *)&buf[4] = v155;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "RTPUninitialize";
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&buf[24] = 635;
                LOWORD(v194[0]) = 1024;
                *(_DWORD *)((char *)v194 + 2) = v10;
                _os_log_impl(&dword_1D8A54000, v156, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Uninitializing RTP with error %X", buf, 0x22u);
              }
            }
            RTPReset(a1, v7);
            return v10;
          }
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
        {
          v37 = VRTraceErrorLogLevelToCSTR();
          v38 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v39 = *v25 & 1;
            v40 = (*v25 >> 2) & 1;
            *(_DWORD *)buf = 136316162;
            *(_QWORD *)&buf[4] = v37;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_RTPTransport_ReinitializeStream";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 2411;
            LOWORD(v194[0]) = 1024;
            *(_DWORD *)((char *)v194 + 2) = v39;
            WORD3(v194[0]) = 1024;
            DWORD2(v194[0]) = v40;
            _os_log_impl(&dword_1D8A54000, v38, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTPTransport: done waiting for SRTP to init. (%d/%d)", buf, 0x28u);
          }
        }
        v172 = 1;
        v14 = v182;
      }
      if (*(_DWORD *)(a1 + 12))
        v41 = 48;
      else
        v41 = 28;
      v42 = (unsigned int *)(a1 + 716 + 4 * (v14 & 0x3FF));
      if ((unint64_t)v42 >= a1 + 4812 || (unint64_t)v42 < a1 + 716)
        goto LABEL_304;
      v43 = *(_QWORD *)(a2 + 104);
      v44 = lengthAtOffsetOut;
      if (*v42 == v14)
      {
        if (!*(_DWORD *)(a1 + 28))
        {
          if (*(_DWORD *)(a1 + 188))
          {
            ++*(_DWORD *)(a1 + 4840);
            v51 = (unsigned int *)(a1 + 6792 + 4 * *(unsigned int *)(a1 + 6992));
            if ((unint64_t)v51 >= a1 + 6992 || (unint64_t)v51 < a1 + 6792)
              goto LABEL_304;
            v14 = v182;
            *v51 = v182;
            *(_DWORD *)(a1 + 6992) = (*(_DWORD *)(a1 + 6992) + 1) % 0x32u;
            log = 1;
            v45 = 1;
          }
          else
          {
            log = 1;
            v45 = 1;
          }
          goto LABEL_91;
        }
        v45 = 1;
      }
      else
      {
        *v42 = v14;
        ++*(_DWORD *)(a1 + 704);
        v46 = *(_QWORD *)(a1 + 10408);
        if (v46)
          ++*(_DWORD *)(v46 + 56);
        v45 = 0;
        ++*(_QWORD *)(a1 + 328);
      }
      if (*(_BYTE *)(a1 + 11100))
      {
        log = 0;
        goto LABEL_91;
      }
      v47 = *(_DWORD *)(a1 + 692);
      if (v14 == (unsigned __int16)v47 || (unsigned __int16)(v14 - v47) > 0x7FFEu)
      {
        if ((unsigned __int16)(v47 - v14) < 0x33u)
        {
LABEL_90:
          log = 0;
          v7 = v178;
          goto LABEL_91;
        }
      }
      else
      {
        v48 = v47 + 0x10000;
        if (v14 >= (unsigned __int16)v47)
          v48 = *(_DWORD *)(a1 + 692);
        *(_DWORD *)(a1 + 692) = v48 & 0xFFFF0000 | v14;
        if ((unsigned __int16)(v14 - v47) < 2u)
          goto LABEL_90;
        loga = (unsigned __int16)(v14 - v47);
        offsetToData = v14 - v47;
        v164 = v43;
        v169 = v41;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          v160 = VRTraceErrorLogLevelToCSTR();
          v49 = *MEMORY[0x1E0CF2758];
          v50 = *MEMORY[0x1E0CF2758];
          if (*MEMORY[0x1E0CF2748])
          {
            if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315906;
              *(_QWORD *)&buf[4] = v160;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_RTPTransport_DetectPacketLoss";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 2710;
              LOWORD(v194[0]) = 1024;
              *(_DWORD *)((char *)v194 + 2) = loga - 1;
              _os_log_impl(&dword_1D8A54000, v49, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d %d packets lost", buf, 0x22u);
            }
          }
          else if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG))
          {
            _RTPTransport_ParseMediaPacket_cold_16();
          }
        }
        v52 = *(_QWORD *)(a1 + 10360);
        logc = loga - 1;
        if (*(_DWORD *)(a1 + 28) == 1)
        {
          AFRCRecordMaxBurstyLoss(v52, logc);
          *(_QWORD *)&buf[11] = 0;
          *(_QWORD *)&buf[4] = 0;
          memset(v194, 0, sizeof(v194));
          v195 = 0u;
          v197 = 0u;
          v198 = 0u;
          v199 = 0u;
          v200 = 0u;
          v201 = 0u;
          v202 = 0u;
          v203 = 0u;
          v204 = 0;
          v53 = *(_QWORD *)(a1 + 10424);
          *(_DWORD *)buf = 7;
          buf[19] = 1;
          v54 = 0x200000000;
        }
        else
        {
          AFRCRecordMaxAudioConsecutiveLoss(v52, logc);
          *(_QWORD *)&buf[11] = 0;
          *(_QWORD *)&buf[4] = 0;
          memset(v194, 0, sizeof(v194));
          v195 = 0u;
          v197 = 0u;
          v198 = 0u;
          v199 = 0u;
          v200 = 0u;
          v201 = 0u;
          v202 = 0u;
          v203 = 0u;
          v204 = 0;
          v53 = *(_QWORD *)(a1 + 10424);
          *(_DWORD *)buf = 7;
          buf[19] = 1;
          v54 = 0x100000000;
        }
        *(_QWORD *)&buf[20] = v54;
        v196 = logc;
        VCRateControlSetStatistics(v53, buf);
        v14 = v182;
        v41 = v169;
        v43 = v164;
        if (offsetToData <= 0x5DCu)
          goto LABEL_90;
      }
      v165 = v43;
      v170 = v41;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        offsetToDataa = VRTraceErrorLogLevelToCSTR();
        logb = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316162;
          *(_QWORD *)&buf[4] = offsetToDataa;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_RTPTransport_DetectPacketLoss";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 2744;
          LOWORD(v194[0]) = 1024;
          *(_DWORD *)((char *)v194 + 2) = (unsigned __int16)v47;
          WORD3(v194[0]) = 1024;
          DWORD2(v194[0]) = v14;
          _os_log_impl(&dword_1D8A54000, logb, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Big jump in sequence Number! LastSeq:%d CurrentSeq:%d", buf, 0x28u);
        }
      }
      log = 0;
      v7 = v178;
      v41 = v170;
      v43 = v165;
LABEL_91:
      v55 = *(_DWORD *)v3;
      v56 = *(_DWORD **)(a1 + 10408);
      v57 = *(_DWORD *)(a1 + 28);
      if (v56)
      {
        if (v57)
        {
          if (v57 == 1)
            v56[64] = *(_DWORD *)(a1 + 692) - *(unsigned __int16 *)(a1 + 688) + 1;
          goto LABEL_102;
        }
        if (!v55)
        {
          ++v56[61];
          v56[65] = *(_DWORD *)(a1 + 692) - *(unsigned __int16 *)(a1 + 688) + 1;
        }
        ++v56[63];
      }
      else if (v57)
      {
        goto LABEL_102;
      }
      if (v55 >= 2)
      {
        v10 = 2147549199;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v92 = VRTraceErrorLogLevelToCSTR();
          v93 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            v94 = *(_DWORD *)v3;
            *(_DWORD *)buf = 136316162;
            *(_QWORD *)&buf[4] = v92;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_RTPTransport_ParseMediaPacket";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 2918;
            LOWORD(v194[0]) = 1024;
            *(_DWORD *)((char *)v194 + 2) = 2918;
            WORD3(v194[0]) = 1024;
            DWORD2(v194[0]) = v94;
            _os_log_error_impl(&dword_1D8A54000, v93, OS_LOG_TYPE_ERROR, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/RTPTransport.c:%d: Wrong connection index: %d.", buf, 0x28u);
            v10 = 2147549199;
            goto LABEL_265;
          }
        }
        goto LABEL_284;
      }
      v57 = 0;
LABEL_102:
      v58 = v44 + v43 + v41;
      if (v45)
        v59 = 0;
      else
        v59 = v58;
      v60 = *(_QWORD *)(a1 + 10352);
      if (v60 == 0xFFFFFFFFLL)
      {
        if (v59)
        {
          ++*(_DWORD *)(a1 + 320);
          HIDWORD(v61) = 1083129856;
          LODWORD(v61) = *(_DWORD *)(a1 + 324);
          *(_DWORD *)(a1 + 324) = ((double)(8 * v59) / 1000.0 + (double)v61);
        }
      }
      else
      {
        MediaQueue_RecordNewPacketWithSize(v60, v59, v57, (_DWORD *)(a1 + 320), (unsigned int *)(a1 + 324));
      }
      if (!*(_DWORD *)(a1 + 10376))
        AFRCCalcRxEstimate(*(double *)(a2 + 128), *(_QWORD *)(a1 + 10360), *(unsigned int *)(a1 + 28), v181, v14, v58, 0, 0);
      v62 = *(_QWORD *)(a1 + 11192);
      if (v62)
        VCConnectionManager_UpdateConnectionHealthWithIndicator(v62, *(_DWORD *)v3 == 0, v14, log);
      v166 = v58;
      v183 = 0;
      v63 = _RTPTransport_PacketExtensionLength((unint64_t)dataPointerOut, lengthAtOffsetOut, &v186, &v183);
      if ((v63 & 0x80000000) != 0)
      {
        v10 = v63;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v90 = VRTraceErrorLogLevelToCSTR();
          v91 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315906;
            *(_QWORD *)&buf[4] = v90;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_RTPTransport_ParseMediaPacket";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 2928;
            LOWORD(v194[0]) = 1024;
            *(_DWORD *)((char *)v194 + 2) = v10;
            _os_log_error_impl(&dword_1D8A54000, v91, OS_LOG_TYPE_ERROR, " [%s] %s:%d Failed to retrieve extension size: %d", buf, 0x22u);
            goto LABEL_264;
          }
        }
LABEL_296:
        v7 = v178;
        goto LABEL_284;
      }
      v64 = v183;
      v65 = lengthAtOffsetOut;
      v171 = dataPointerOut;
      v189 = 0;
      v188 = 0;
      v66 = a1 + 8840;
      if (*(_DWORD *)(a1 + 7928) == 1)
      {
        if (*(_BYTE *)(a1 + 11200))
        {
          if (*(unsigned __int16 *)(a1 + 11202) + 1 != v182)
          {
            v192 = 0;
            pthread_mutex_lock((pthread_mutex_t *)(a1 + 7808));
            VCMediaKeyIndex_ReleaseAndCopyNewValue((const void **)&v192, *(void **)(a1 + 7872));
            pthread_mutex_unlock((pthread_mutex_t *)(a1 + 7808));
            v67 = *(uint64_t (**)(uint64_t, _QWORD, uint64_t, _QWORD))(a1 + 10384);
            if (v67)
            {
              if ((v67(6, *(_QWORD *)(a1 + 10392), v192, 0) & 0x80000000) != 0
                && (int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  _RTPTransport_ParseMediaPacket_cold_15();
              }
            }
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              v68 = VRTraceErrorLogLevelToCSTR();
              v69 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              {
                v87 = *(unsigned __int16 *)(a1 + 11202) + 1;
                v88 = *(_QWORD *)(a1 + 10392);
                *(_DWORD *)buf = 136316674;
                *(_QWORD *)&buf[4] = v68;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "_RTPTransport_DetectSequenceNumberGap";
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&buf[24] = 2128;
                LOWORD(v194[0]) = 1024;
                *(_DWORD *)((char *)v194 + 2) = v87;
                WORD3(v194[0]) = 1024;
                DWORD2(v194[0]) = v182;
                WORD6(v194[0]) = 2048;
                *(_QWORD *)((char *)v194 + 14) = v88;
                WORD3(v194[1]) = 2112;
                *((_QWORD *)&v194[1] + 1) = v192;
                _os_log_error_impl(&dword_1D8A54000, v69, OS_LOG_TYPE_ERROR, " [%s] %s:%d Detected gap in RTP sequence number: expected=%u, received=%u, for stream=%p with MKI=%@", buf, 0x3Cu);
              }
            }
            VCMediaKeyIndex_Release((const void **)&v192);
            v66 = a1 + 8840;
            *(_BYTE *)(a1 + 11200) = 0;
          }
          *(_WORD *)(v66 + 2362) = v182;
        }
        if (!*(_QWORD *)(a1 + 7872))
        {
          *(_BYTE *)(v66 + 2360) = 1;
          *(_WORD *)(v66 + 2362) = v182;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v70 = VRTraceErrorLogLevelToCSTR();
            v71 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              v72 = *(_QWORD *)(a1 + 10392);
              *(_DWORD *)buf = 136315906;
              *(_QWORD *)&buf[4] = v70;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_RTPTransport_DetectSequenceNumberGap";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 2139;
              LOWORD(v194[0]) = 2048;
              *(_QWORD *)((char *)v194 + 2) = v72;
              _os_log_impl(&dword_1D8A54000, v71, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Started RTP sequence number gap detection for stream=%p", buf, 0x26u);
            }
          }
        }
      }
      v73 = v171;
      if ((v65 & 0x80000000) != 0 || (int)v65 > (uint64_t)v65)
        goto LABEL_304;
      offsetToDatab = 4 * (v18 & 0xF) + 12;
      v179 = v64 + offsetToDatab;
      v74 = 2149711929;
      v75 = SRTPVerifyAuthenticationTag(a1 + 7520, v182, v171, v65, (unsigned int *)&v188, &v189);
      if ((v75 & 0x80000000) != 0)
      {
        v10 = v75;
        if ((_DWORD)v75 != -2145255368)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            v7 = v178;
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              _RTPTransport_ParseMediaPacket_cold_6();
            goto LABEL_202;
          }
          v86 = 0;
LABEL_206:
          v7 = v178;
          goto LABEL_207;
        }
      }
      if (!v189)
      {
LABEL_193:
        v103 = (unint64_t)&v73[v179];
        if (&v73[v179] > &v73[v65])
          goto LABEL_304;
        if (v103 < (unint64_t)v73)
          goto LABEL_304;
        v104 = v188 - v179;
        if (v188 - (_DWORD)v179 < 0 || (uint64_t)(v65 - v179) < v104)
          goto LABEL_304;
        v105 = SRTPDecrypt(a1 + 7520, v182, v103, v104);
        if ((v105 & 0x80000000) == 0 || (v10 = v105, (_DWORD)v105 == -2145255368))
        {
          v10 = 0;
          v65 = v188;
          v7 = v178;
          if (!*(_DWORD *)(a1 + 7912))
          {
LABEL_208:
            if (v65 > lengthAtOffsetOut)
              goto LABEL_304;
            lengthAtOffsetOut = v65;
            if ((v10 & 0x80000000) != 0)
              goto LABEL_284;
            v106 = v180;
            if ((v180 & 0x20) != 0)
            {
              v108 = &dataPointerOut[v65 - 1];
              if (v108 >= &dataPointerOut[v65] || v108 < dataPointerOut)
                goto LABEL_304;
              v107 = *v108;
            }
            else
            {
              v107 = 0;
            }
            if ((v65 - v107 - v179) < 0x5C1)
            {
              v109 = v182;
              if ((log & 1) != 0)
              {
LABEL_217:
                *(_QWORD *)(a3 + 120) = v166;
                *(_QWORD *)(a3 + 40) = *(_QWORD *)(a2 + 128);
                v110 = *(unsigned __int8 *)(a2 + 34);
                if (!*(_BYTE *)(a2 + 34))
                {
LABEL_220:
                  v10 = 0;
                  *(_BYTE *)(a3 + 50) = *(_BYTE *)(a2 + 36);
                  *(_QWORD *)(a3 + 56) = *(_QWORD *)(a2 + 40);
                  *(_BYTE *)(a3 + 89) = *(_BYTE *)(a2 + 35);
                  v111 = *(_OWORD *)v3;
                  *(_QWORD *)(a3 + 112) = *(_QWORD *)(v3 + 16);
                  *(_OWORD *)(a3 + 96) = v111;
                  *(_BYTE *)(a3 + 49) = *(_BYTE *)(a2 + 9);
                  *(_BYTE *)(a3 + 48) = v172;
                  *(_DWORD *)(a3 + 8) = v106 >> 15;
                  *(_DWORD *)(a3 + 12) = InternalPayload & 0x7F;
                  *(_DWORD *)(a3 + 16) = v167;
                  *(_WORD *)(a3 + 20) = v109;
                  *(_DWORD *)(a3 + 24) = v181;
                  *(_DWORD *)(a3 + 28) = v173;
                  *(_BYTE *)(a3 + 200) = log;
                  *(_BYTE *)(a3 + 201) = *(_DWORD *)(a2 + 88) == 0;
                  *(_BYTE *)(a3 + 202) = *(_BYTE *)(a2 + 137);
                  *(_BYTE *)(a3 + 203) = *(_BYTE *)(a2 + 138);
                  return v10;
                }
                *(_BYTE *)(a3 + 88) = v110;
                if (v110 <= 0xC)
                {
                  memcpy((void *)(a3 + 64), (const void *)(a2 + 10), 2 * v110);
                  v109 = v182;
                  v106 = v180;
                  goto LABEL_220;
                }
LABEL_304:
                __break(0x5519u);
              }
              v112 = *(double *)(a2 + 128);
              v113 = *(_DWORD *)(a1 + 696);
              v114 = *(_DWORD *)(a1 + 700);
              v115 = NTPToMicro(*(_QWORD *)(a1 + 6488));
              if (v181 != *(_DWORD *)(a1 + 4824))
              {
                v116 = ((double)v113 + (double)v114 * (v112 - v115)) - v181;
                if ((v172 & 1) != 0)
                {
                  v117 = 0;
                }
                else
                {
                  v117 = v116 - *(_DWORD *)(a1 + 4816);
                  if (v117 < 0)
                    v117 = *(_DWORD *)(a1 + 4816) - v116;
                }
                *(_QWORD *)(a1 + 4816) = (int)v116;
                v118 = v117 - ((*(_DWORD *)(a1 + 4828) + 8) >> 4) + *(_DWORD *)(a1 + 4828);
                *(_DWORD *)(a1 + 4828) = v118;
                *(_DWORD *)(a1 + 4824) = v181;
                *(double *)(a1 + 6784) = ((double)(v118 >> 4)
                                        + *(double *)(a1 + 6784) * (double)(*(_DWORD *)(a1 + 704) - 1))
                                       / (double)*(unsigned int *)(a1 + 704);
                if (*(_DWORD *)(a1 + 6776) <= v118 >> 4)
                  v119 = v118 >> 4;
                else
                  v119 = *(_DWORD *)(a1 + 6776);
                *(_DWORD *)(a1 + 6776) = v119;
              }
              if (a3 + 8 >= (unint64_t)(a3 + 208))
                goto LABEL_304;
              v120 = *(OpaqueCMBlockBuffer **)a2;
              v122 = dataPointerOut;
              v121 = lengthAtOffsetOut;
              VCBlockBuffer_Clear(a3 + 128);
              v126 = v180;
              if ((v180 & 0x10) == 0)
              {
LABEL_242:
                v130 = *(OpaqueCMBlockBuffer **)a2;
                v131 = dataPointerOut;
                v132 = &dataPointerOut[lengthAtOffsetOut];
                v106 = v126;
                if ((v126 & 0x20) != 0)
                {
                  v135 = &dataPointerOut[lengthAtOffsetOut - 1];
                  v7 = v178;
                  v134 = v179;
                  if (v135 >= v132 || v135 < dataPointerOut)
                    goto LABEL_304;
                  v133 = *v135;
                }
                else
                {
                  v133 = 0;
                  v7 = v178;
                  v134 = v179;
                }
                v136 = 0;
                v137 = 0;
                v138 = 0;
                v139 = 0;
                v140 = v133 + v134;
                *(_QWORD *)buf = 0;
                v141 = lengthAtOffsetOut - v140;
                if (lengthAtOffsetOut != v140)
                {
                  v142 = v134;
                  if (CMBlockBufferCreateWithBufferReference(*(CFAllocatorRef *)(a1 + 10480), v130, v134, lengthAtOffsetOut - v140, 0, (CMBlockBufferRef *)buf))
                  {
                    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                    {
                      VRTraceErrorLogLevelToCSTR();
                      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                        _RTPTransport_ParseMediaPacket_cold_4();
                    }
                    if (*(_QWORD *)buf)
                      CFRelease(*(CFTypeRef *)buf);
                    v10 = 2147549188;
                    goto LABEL_264;
                  }
                  v139 = &v131[v142];
                  v136 = *(_QWORD *)buf;
                  v137 = v131;
                  v138 = v132;
                  v106 = v180;
                }
                *(_QWORD *)(a3 + 152) = v136;
                if (v138 < v139 || v137 > v139 || v141 > v138 - v139)
                  goto LABEL_304;
                *(_QWORD *)(a3 + 160) = v141;
                *(_QWORD *)(a3 + 168) = v139;
                v109 = v182;
                if ((v106 & 0x20) == 0)
                {
LABEL_254:
                  if (*(_DWORD *)(a1 + 188))
                  {
                    if (v172)
                      *(_DWORD *)(a1 + 4848) = 0;
                    _RTPTransport_EstimateRTCPXRSummaryJitter(a1, a2, v172, (uint64_t)&v186, v123, v124, v125);
                  }
                  goto LABEL_217;
                }
                v143 = dataPointerOut;
                v144 = &dataPointerOut[lengthAtOffsetOut];
                v145 = &dataPointerOut[lengthAtOffsetOut - 1];
                if (v145 >= &dataPointerOut[lengthAtOffsetOut] || v145 < dataPointerOut)
                  goto LABEL_304;
                v146 = *v145;
                v147 = lengthAtOffsetOut - v146;
                v148 = v146 - 1;
                if (*(_DWORD *)(a1 + 28))
                {
                  if ((v146 - 1) > 3u)
                  {
LABEL_262:
                    v10 = 2147549191;
                    goto LABEL_284;
                  }
                  if ((_BYTE)v146 != 1)
                  {
                    v149 = (v146 - 1);
                    v150 = &dataPointerOut[v147];
                    while (v150 < v144 && v150 >= dataPointerOut)
                    {
                      v151 = *v150;
                      v153 = v151 == 255 && v148 > 2u;
                      if ((v151 - 4) < 0xFB || v153)
                        goto LABEL_262;
                      ++v150;
                      if (!--v149)
                        goto LABEL_282;
                    }
                    goto LABEL_304;
                  }
LABEL_282:
                  v154 = v148;
                  if (!CMBlockBufferCreateWithBufferReference(*(CFAllocatorRef *)(a1 + 10480), *(CMBlockBufferRef *)a2, v147, v148, 0, (CMBlockBufferRef *)(a3 + 176)))
                  {
                    v157 = &v143[v147];
                    if (v144 < &v143[v147] || v157 < v143 || v144 - &v143[v147] < v154)
                      goto LABEL_304;
                    *(_QWORD *)(a3 + 184) = v154;
                    *(_QWORD *)(a3 + 192) = v157;
                    v109 = v182;
                    v106 = v180;
                    goto LABEL_254;
                  }
                  v10 = 2147549187;
                  goto LABEL_284;
                }
                v10 = 2147549191;
                if ((v146 - 1) <= 0xAu)
                  goto LABEL_282;
LABEL_284:
                if (!v172)
                  return v10;
                goto LABEL_285;
              }
              *(_QWORD *)buf = 0;
              v127 = _RTPTransport_PacketExtensionLength((unint64_t)v122, v121, &v186, (uint64_t *)buf);
              if ((v127 & 0x80000000) == 0)
              {
                v128 = *(_QWORD *)buf;
                if (*(_QWORD *)buf)
                {
                  v129 = &v122[offsetToDatab];
                  if (&v122[offsetToDatab] < v122 || v129 > &v122[v121] || *(_QWORD *)buf > v121 - offsetToDatab)
                    goto LABEL_304;
                  *(_QWORD *)(a3 + 136) = *(_QWORD *)buf;
                  *(_QWORD *)(a3 + 144) = v129;
                  if (CMBlockBufferCreateWithBufferReference(*(CFAllocatorRef *)(a1 + 10480), v120, offsetToDatab, v128, 0, (CMBlockBufferRef *)(a3 + 128)))
                  {
                    v10 = 2147549188;
                    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                    {
                      VRTraceErrorLogLevelToCSTR();
                      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                        _RTPTransport_ParseMediaPacket_cold_5();
                    }
                    goto LABEL_264;
                  }
                }
                v126 = v180;
                goto LABEL_242;
              }
              v10 = v127;
LABEL_264:
              v7 = v178;
LABEL_265:
              if ((v172 & 1) == 0)
                return v10;
              goto LABEL_285;
            }
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              v158 = VRTraceErrorLogLevelToCSTR();
              v159 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136316674;
                *(_QWORD *)&buf[4] = v158;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "_RTPTransport_ParseMediaPacket";
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&buf[24] = 2940;
                LOWORD(v194[0]) = 1024;
                *(_DWORD *)((char *)v194 + 2) = lengthAtOffsetOut;
                WORD3(v194[0]) = 1024;
                DWORD2(v194[0]) = lengthAtOffsetOut;
                WORD6(v194[0]) = 1024;
                *(_DWORD *)((char *)v194 + 14) = v179;
                WORD1(v194[1]) = 1024;
                DWORD1(v194[1]) = (v180 >> 5) & 1;
                _os_log_error_impl(&dword_1D8A54000, v159, OS_LOG_TYPE_ERROR, " [%s] %s:%d Invalid packet! length:%d iRet:%d iOffset:%d padding:%d, ", buf, 0x34u);
                v10 = 2147549191;
                goto LABEL_264;
              }
            }
            v10 = 2147549191;
            goto LABEL_296;
          }
          v86 = 1;
LABEL_207:
          _RTPProcessDecryptionStatusChange(a1, v86);
          goto LABEL_208;
        }
        v7 = v178;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _RTPTransport_ParseMediaPacket_cold_7();
        }
LABEL_202:
        v86 = 0;
        goto LABEL_207;
      }
      v191 = 0;
      v192 = 0;
      theArray = 0;
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 7808));
      VCMediaKeyIndex_ReleaseAndCopyNewValue((const void **)&v192, *(void **)(a1 + 7872));
      VCMediaKeyIndex_ReleaseAndCopyNewValue((const void **)&v191, *(void **)(a1 + 7880));
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 7808));
      v76 = *(_DWORD *)(a1 + 7928);
      if (v76 <= 4 && ((1 << v76) & 0x1A) != 0)
      {
        if ((VCSecurityKeyHolder_CopyKeyMaterialForKeyIndex(*(_QWORD *)(a1 + 10448), (const char *)v191, (uint64_t *)&theArray) & 0x80000000) != 0)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            v95 = VRTraceErrorLogLevelToCSTR();
            v96 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              _RTPTransport_ParseMediaPacket_cold_8(v95, &v191, v96);
          }
        }
        else if (theArray)
        {
          v77 = *(uint64_t (**)(uint64_t, _QWORD, void *, _QWORD))(a1 + 10384);
          if (v77 && (v77(4, *(_QWORD *)(a1 + 10392), v191, 0) & 0x80000000) != 0)
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                _RTPTransport_ParseMediaPacket_cold_14();
            }
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                _RTPTransport_ParseMediaPacket_cold_13();
            }
          }
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, 0);
          Value = (const char *)CFDictionaryGetValue(ValueAtIndex, CFSTR("SecurityKeyIndex"));
          if (Value)
          {
            if ((VCSecurityKeyHolder_AssociateKeyIndex(*(_QWORD *)(a1 + 10448), Value) & 0x80000000) != 0)
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  _RTPTransport_ParseMediaPacket_cold_11();
              }
            }
            else
            {
              v80 = SRTPUpdateKeyMaterialForRTPInfo(a1, ValueAtIndex);
              ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
              if (!v80)
              {
                if (ErrorLogLevelForModule >= 7)
                {
                  v82 = VRTraceErrorLogLevelToCSTR();
                  v83 = *MEMORY[0x1E0CF2758];
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                  {
                    v84 = VCMediaKeyIndex_Description(v191);
                    *(_DWORD *)buf = 136316162;
                    *(_QWORD *)&buf[4] = v82;
                    *(_WORD *)&buf[12] = 2080;
                    *(_QWORD *)&buf[14] = "_RTPTransport_HandleMKIChanged";
                    *(_WORD *)&buf[22] = 1024;
                    *(_DWORD *)&buf[24] = 2681;
                    LOWORD(v194[0]) = 2048;
                    *(_QWORD *)((char *)v194 + 2) = a1;
                    WORD5(v194[0]) = 2080;
                    *(_QWORD *)((char *)v194 + 12) = v84;
                    _os_log_impl(&dword_1D8A54000, v83, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d rtpInfo=%p: SRTP has been updated with new key material with index=%s", buf, 0x30u);
                  }
                }
                v74 = 0;
                v85 = 1;
                goto LABEL_190;
              }
              if (ErrorLogLevelForModule >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  _RTPTransport_ParseMediaPacket_cold_12();
              }
            }
          }
          else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              _RTPTransport_ParseMediaPacket_cold_10();
          }
        }
        else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v97 = VRTraceErrorLogLevelToCSTR();
          v98 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _RTPTransport_ParseMediaPacket_cold_9(v97, &v191, v98);
        }
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v99 = VRTraceErrorLogLevelToCSTR();
        v100 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v101 = VCMediaKeyIndex_Description(v191);
          v102 = VCMediaKeyIndex_Description((void *)v192);
          *(_DWORD *)buf = 136316418;
          *(_QWORD *)&buf[4] = v99;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_RTPTransport_HandleMKIChanged";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 2684;
          LOWORD(v194[0]) = 2048;
          *(_QWORD *)((char *)v194 + 2) = a1;
          WORD5(v194[0]) = 2080;
          *(_QWORD *)((char *)v194 + 12) = v101;
          WORD2(v194[1]) = 2080;
          *(_QWORD *)((char *)&v194[1] + 6) = v102;
          _os_log_impl(&dword_1D8A54000, v100, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d rtpInfo=%p: SRTP drop packet due to media key index changed [new:%s, old:%s]", buf, 0x3Au);
        }
      }
      v85 = 0;
LABEL_190:
      v73 = v171;
      if (theArray)
        CFRelease(theArray);
      VCMediaKeyIndex_Release((const void **)&v192);
      VCMediaKeyIndex_Release((const void **)&v191);
      if (!v85)
      {
        v86 = 0;
        v10 = v74;
        goto LABEL_206;
      }
      goto LABEL_193;
    }
    if (DataPointer >= 0)
      v89 = DataPointer;
    else
      v89 = -DataPointer;
    v10 = v89 | (DataPointer << 31) | 0x50010000u;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _RTPTransport_ParseMediaPacket_cold_18();
    }
  }
  return v10;
}

unint64_t _RTPTransport_PacketExtensionLength(unint64_t result, unint64_t a2, _WORD *a3, uint64_t *a4)
{
  uint64_t v4;
  unint64_t v5;
  unsigned __int16 *v6;
  uint64_t v8;

  if (a4)
  {
    *a4 = 0;
    if ((*a3 & 0x10) != 0)
    {
      v5 = 4 * (*a3 & 0xFLL) + 12;
      if (v5 >= a2)
      {
        v4 = 2147549191;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _RTPTransport_PacketExtensionLength_cold_4();
        }
      }
      else if (4 * (*a3 & 0xFuLL) + 16 <= a2)
      {
        v6 = (unsigned __int16 *)(result + v5 + 2);
        if ((unint64_t)v6 >= result + a2 || (unint64_t)v6 < result)
        {
          __break(0x5519u);
          return result;
        }
        v8 = 4 * (bswap32(*v6) >> 16) + 4;
        if (v8 + v5 <= a2)
        {
          v4 = 0;
          *a4 = v8;
        }
        else
        {
          v4 = 2147549191;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              _RTPTransport_PacketExtensionLength_cold_3();
          }
        }
      }
      else
      {
        v4 = 2147549191;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _RTPTransport_PacketExtensionLength_cold_2();
        }
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v4 = 2147549188;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _RTPTransport_PacketExtensionLength_cold_1();
    }
  }
  return v4;
}

_DWORD *_RTPRecvWithSocket(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v4;
  _DWORD *result;
  BOOL v7;
  _DWORD *v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  const char *v12;
  NSObject *v13;
  uint32_t v14;
  uint64_t v15;
  NSObject *v16;
  NSObject *v17;
  _DWORD *v18;
  uint64_t v19;
  uint8_t buf[4];
  uint64_t v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v19 = 0;
  v4 = *(_QWORD *)(a2 + 10472);
  if (!v4)
  {
    v18 = 0;
    goto LABEL_12;
  }
  result = VCMemoryPool_Alloc(*(OSQueueHead **)(a2 + 10472));
  if (result)
    v7 = result >= (_DWORD *)((char *)result + *(_QWORD *)(v4 + 16));
  else
    v7 = 0;
  if (!v7)
  {
    v8 = result;
    v18 = result;
    if (result)
    {
      if ((VTP_Recvfrom(*(_DWORD *)(a2 + 4), &v19) & 0x80000000) != 0)
      {
        v9 = *__error() | 0xC0010000;
        goto LABEL_10;
      }
      v9 = _RTPTransport_ParseVTPPacket(a2, v19, v8);
      if ((v9 & 0x80000000) == 0)
      {
        *a3 = v8;
        v18 = 0;
        goto LABEL_10;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() < 8)
        goto LABEL_10;
      v15 = VRTraceErrorLogLevelToCSTR();
      v16 = *MEMORY[0x1E0CF2758];
      v17 = *MEMORY[0x1E0CF2758];
      if (!*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
          _RTPRecvWithSocket_cold_1();
        goto LABEL_10;
      }
      if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
LABEL_10:
        _RTPReleaseRTPPacketInternal(a2, &v18);
        VTP_ReleasePacket((void **)&v19);
        return (_DWORD *)v9;
      }
      *(_DWORD *)buf = 136315906;
      v21 = v15;
      v22 = 2080;
      v23 = "_RTPRecvWithSocket";
      v24 = 1024;
      v25 = 3025;
      v26 = 1024;
      v27 = v9;
      v12 = " [%s] %s:%d RTP packet parsing failed: %d";
      v13 = v16;
      v14 = 34;
LABEL_20:
      _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, v12, buf, v14);
      goto LABEL_10;
    }
LABEL_12:
    v9 = 2147549187;
    if ((int)VRTraceGetErrorLogLevelForModule() < 5)
      goto LABEL_10;
    v10 = VRTraceErrorLogLevelToCSTR();
    v11 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      goto LABEL_10;
    *(_DWORD *)buf = 136315650;
    v21 = v10;
    v22 = 2080;
    v23 = "_RTPRecvWithSocket";
    v24 = 1024;
    v25 = 3019;
    v12 = " [%s] %s:%d Failed to allocate RTP packet";
    v13 = v11;
    v14 = 28;
    goto LABEL_20;
  }
  __break(0x5519u);
  return result;
}

uint64_t _RTPTransport_ParseVTPPacket(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD v9[22];

  v9[21] = *MEMORY[0x1E0C80C00];
  *(_OWORD *)&v9[14] = unk_1D910B4B0;
  *(_OWORD *)&v9[16] = xmmword_1D910B4C0;
  memset(&v9[18], 170, 24);
  memset(v9, 170, 112);
  VCGetVCPacketWithVTPPacket(a2, (uint64_t)v9);
  if (*(_DWORD *)(a1 + 28) || *(_DWORD *)(a2 + 348) != 256)
    v6 = _RTPTransport_ParseMediaPacket(a1, (uint64_t)v9, (uint64_t)a3);
  else
    v6 = _RTPTransport_ParseBasebandNotification(a1, (uint64_t)v9, a3);
  v7 = v6;
  VCPacketInvalidate(v9);
  return v7;
}

void RTPGetUplinkReportingStats(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;

  if (a2)
  {
    v3 = CheckInHandleDebug();
    if (v3)
    {
      *a2 = *(_QWORD *)(v3 + 352);
      CheckOutHandleDebug();
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RTPGetUplinkReportingStats_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      RTPGetUplinkReportingStats_cold_1();
  }
}

void RTPGetDownlinkReportingStats(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  __int128 v4;

  if (a2)
  {
    v3 = CheckInHandleDebug();
    if (v3)
    {
      v4 = *(_OWORD *)(v3 + 328);
      *(_QWORD *)(a2 + 16) = *(_QWORD *)(v3 + 344);
      *(_OWORD *)a2 = v4;
      CheckOutHandleDebug();
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RTPGetDownlinkReportingStats_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      RTPGetDownlinkReportingStats_cold_1();
  }
}

uint64_t _RTPSocketRTPAndBBNoteCallback(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  _DWORD *v6;
  BOOL v7;
  _DWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v14;
  NSObject *v15;
  const char *v16;
  uint64_t v17;
  _DWORD *v18;
  uint8_t buf[4];
  uint64_t v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v3 = CheckInHandleDebug();
  if (v3)
  {
    v4 = v3;
    v5 = *(_QWORD *)(v3 + 10472);
    if (v5)
    {
      v6 = VCMemoryPool_Alloc(*(OSQueueHead **)(v3 + 10472));
      if (v6)
        v7 = v6 >= (_DWORD *)((char *)v6 + *(_QWORD *)(v5 + 16));
      else
        v7 = 0;
      if (v7)
        goto LABEL_33;
      v8 = v6;
      v18 = v6;
      if (v6)
      {
        if (v4 < v4 + 27616)
        {
          v9 = _RTPTransport_ParseVTPPacket(v4, a2, v6);
          v10 = v9;
          if ((v9 & 0x80000000) != 0)
          {
            if ((_DWORD)v9 != -2147418057 && (_DWORD)v9 != -2145255367 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                _RTPSocketRTPAndBBNoteCallback_cold_2();
            }
            goto LABEL_19;
          }
          v11 = *(_QWORD *)(v4 + 10504);
          if (v11)
          {
            (*(void (**)(uint64_t, _QWORD, _DWORD *))(v11 + 16))(v11, *(_QWORD *)(v4 + 10496), v8);
            goto LABEL_19;
          }
          v10 = 2147549186;
          if ((int)VRTraceGetErrorLogLevelForModule() < 5)
            goto LABEL_19;
          v17 = VRTraceErrorLogLevelToCSTR();
          v15 = *MEMORY[0x1E0CF2758];
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            goto LABEL_19;
          *(_DWORD *)buf = 136315650;
          v20 = v17;
          v21 = 2080;
          v22 = "_RTPSocketRTPAndBBNoteCallback";
          v23 = 1024;
          v24 = 3087;
          v16 = " [%s] %s:%d callback is NULL";
          goto LABEL_31;
        }
LABEL_33:
        __break(0x5519u);
      }
    }
    else
    {
      v18 = 0;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() < 5)
    {
      v10 = 2147549187;
      goto LABEL_19;
    }
    v14 = VRTraceErrorLogLevelToCSTR();
    v15 = *MEMORY[0x1E0CF2758];
    v10 = 2147549187;
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
LABEL_19:
      _RTPReleaseRTPPacketInternal(v4, &v18);
      CheckOutHandleDebug();
      return v10;
    }
    *(_DWORD *)buf = 136315650;
    v20 = v14;
    v21 = 2080;
    v22 = "_RTPSocketRTPAndBBNoteCallback";
    v23 = 1024;
    v24 = 3081;
    v16 = " [%s] %s:%d Failed to allocate RTP packet";
LABEL_31:
    _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, v16, buf, 0x1Cu);
    goto LABEL_19;
  }
  v10 = 2147549186;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _RTPSocketRTPAndBBNoteCallback_cold_1();
  }
  return v10;
}

uint64_t RTPGetReceiveStatus(uint64_t a1, unsigned int *a2, int a3, unsigned int a4)
{
  uint64_t result;
  unsigned int *v6;
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int *v11;
  uint64_t v12;
  char *v13;
  unsigned int v14;
  unint64_t v15;
  __int128 *v16;
  int v17;
  unint64_t v18;
  __int128 *v19;
  int v20;
  unsigned int v21;
  __int128 *v22;
  uint64_t v23;
  __int128 *v24;
  unsigned int v25;
  unint64_t v26;
  __int128 *v27;
  unint64_t v28;
  __int128 *v29;
  unsigned int v30;
  __int128 *v31;
  unsigned int v33;
  int v34;
  _OWORD v35[9];
  __int128 v36[8];
  __int128 v37;

  *(_QWORD *)&v37 = *MEMORY[0x1E0C80C00];
  result = 2147549186;
  if (a1)
  {
    v6 = a2;
    if (a2)
    {
      if (a3)
      {
        memset(v36, 0, sizeof(v36));
        if (a3 >= 1)
        {
          v33 = -2147418110;
          v7 = 0;
          *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v35[7] = v8;
          v35[8] = v8;
          v35[5] = v8;
          v35[6] = v8;
          v35[3] = v8;
          v35[4] = v8;
          v9 = a3;
          v10 = 8 * a3;
          v35[1] = v8;
          v35[2] = v8;
          v34 = -1;
          v11 = a2;
          v35[0] = v8;
          do
          {
            v12 = CheckInHandleDebug();
            v13 = (char *)v35 + v7;
            if ((_OWORD *)((char *)v35 + v7) >= v36 || (_OWORD *)((char *)v35 + v7) < v35)
              goto LABEL_68;
            *(_QWORD *)v13 = v12;
            if (v12)
            {
              v14 = *v11;
              if ((*v11 & 0x10) != 0)
              {
                v15 = *(unsigned int *)(v12 + 4);
                if (v15 <= 0x3FF)
                {
                  if (__darwin_check_fd_set_overflow(*(_DWORD *)(v12 + 4), v36, 0))
                  {
                    v16 = (__int128 *)((char *)v36 + ((v15 >> 3) & 0x1FFFFFFC));
                    if (v16 >= &v37 || v16 < v36)
                      goto LABEL_68;
                    *(_DWORD *)v16 |= 1 << v15;
                  }
                  v12 = *(_QWORD *)v13;
                  v17 = v34;
                  if (*(_DWORD *)(*(_QWORD *)v13 + 4) > v34)
                    v17 = *(_DWORD *)(*(_QWORD *)v13 + 4);
                  v34 = v17;
                  v14 = *v11;
                }
              }
              if ((v14 & 0x20) != 0)
              {
                v18 = *(unsigned int *)(v12 + 8);
                if (v18 <= 0x3FF)
                {
                  if (__darwin_check_fd_set_overflow(*(_DWORD *)(v12 + 8), v36, 0))
                  {
                    v19 = (__int128 *)((char *)v36 + ((v18 >> 3) & 0x1FFFFFFC));
                    if (v19 >= &v37 || v19 < v36)
                      goto LABEL_68;
                    *(_DWORD *)v19 |= 1 << v18;
                  }
                  v20 = v34;
                  if (*(_DWORD *)(*(_QWORD *)v13 + 8) > v34)
                    v20 = *(_DWORD *)(*(_QWORD *)v13 + 8);
                  v34 = v20;
                }
              }
            }
            else
            {
              *v11 = 0;
            }
            ++v11;
            v7 += 8;
          }
          while (v10 != v7);
          v21 = v34;
          if (v34 != -1)
          {
            if (a4 <= 0x3FF)
            {
              if (v34 <= (int)a4)
                v21 = a4;
              if (__darwin_check_fd_set_overflow(a4, v36, 0))
              {
                v22 = (__int128 *)((char *)v36 + 4 * (a4 >> 5));
                if (v22 >= &v37 || v22 < v36)
LABEL_68:
                  __break(0x5519u);
                *(_DWORD *)v22 |= 1 << a4;
              }
            }
            if (VTP_Select(v21 + 1, v36, 0, 0, 0) == -1)
            {
              v33 = *__error() | 0xC0010000;
              goto LABEL_60;
            }
            v23 = v9;
            v24 = v35;
            while (1)
            {
              if (v24 >= v36 || v24 < v35)
                goto LABEL_68;
              if (!*(_QWORD *)v24)
                goto LABEL_57;
              v25 = *v6;
              if ((*v6 & 0x10) == 0)
                goto LABEL_49;
              v26 = *(unsigned int *)(*(_QWORD *)v24 + 4);
              if (v26 > 0x3FF)
                goto LABEL_49;
              if (__darwin_check_fd_set_overflow(*(_DWORD *)(*(_QWORD *)v24 + 4), v36, 0))
              {
                v27 = (__int128 *)((char *)v36 + ((v26 >> 3) & 0x1FFFFFFC));
                if (v27 >= &v37 || v27 < v36)
                  goto LABEL_68;
                if (((*(_DWORD *)v27 >> v26) & 1) != 0)
                  break;
              }
              v30 = *v6 & 0xFFFFFFEF;
              *v6 = v30;
              if ((v30 & 0x20) != 0)
              {
LABEL_50:
                v28 = *(unsigned int *)(*(_QWORD *)v24 + 8);
                if (v28 <= 0x3FF)
                {
                  if (!__darwin_check_fd_set_overflow(*(_DWORD *)(*(_QWORD *)v24 + 8), v36, 0))
                    goto LABEL_55;
                  v29 = (__int128 *)((char *)v36 + ((v28 >> 3) & 0x1FFFFFFC));
                  if (v29 >= &v37 || v29 < v36)
                    goto LABEL_68;
                  if (((*(_DWORD *)v29 >> v28) & 1) == 0)
LABEL_55:
                    *v6 &= ~0x20u;
                }
              }
LABEL_57:
              ++v6;
              v24 = (__int128 *)((char *)v24 + 8);
              if (!--v23)
              {
                v33 = 0;
                goto LABEL_60;
              }
            }
            v25 = *v6;
LABEL_49:
            if ((v25 & 0x20) != 0)
              goto LABEL_50;
            goto LABEL_57;
          }
LABEL_60:
          v31 = v35;
          do
          {
            if (v31 >= v36 || v31 < v35)
              goto LABEL_68;
            if (*(_QWORD *)v31)
              CheckOutHandleDebug();
            a1 += 8;
            v31 = (__int128 *)((char *)v31 + 8);
            --v9;
          }
          while (v9);
          return v33;
        }
      }
    }
  }
  return result;
}

uint64_t RTPGetLocalSSRC(uint64_t a1, _DWORD *a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2147549186;
  if (a2)
    *a2 = *(_DWORD *)(v3 + 200);
  CheckOutHandleDebug();
  return 0;
}

unint64_t RTPSetRemoteSSRC(uint64_t a1, int a2)
{
  uint64_t v3;
  unint64_t result;
  unint64_t v5;
  int v6;
  uint64_t v7;
  NSObject *v8;
  int v9;
  int v10;
  uint64_t v11;
  CFNumberRef v12;
  uint64_t v13;
  CFNumberRef v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t CMBaseObject;
  uint64_t (*v18)(uint64_t, const __CFString *, CFNumberRef);
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t (*v23)(uint64_t, const __CFString *, CFNumberRef);
  uint64_t v24;
  NSObject *v25;
  int v26;
  uint64_t v27;
  __int16 v28;
  const char *v29;
  __int16 v30;
  int v31;
  __int16 v32;
  int v33;
  __int16 v34;
  int v35;
  __int16 v36;
  int v37;
  __int16 v38;
  int v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v3 = 2147549185;
  result = CheckInHandleDebug();
  if (!result)
    return 2147549186;
  v5 = result;
  *(_DWORD *)(result + 88) = 1;
  *(_DWORD *)(result + 4832) = a2;
  if (result < result + 27616)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(result + 8844));
    *(_DWORD *)(v5 + 7640) = a2;
    *(_BYTE *)(v5 + 8840) = 1;
    os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 8844));
    *(_DWORD *)(v5 + 8520) = a2;
    *(_DWORD *)(v5 + 7004) = 0;
    v6 = *(_DWORD *)(v5 + 4);
    if (v6 != -1)
    {
      VTP_SetRemoteSSRC(v6, a2);
      VTP_SetRemoteSSRC(*(_DWORD *)(v5 + 8), a2);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v7 = VRTraceErrorLogLevelToCSTR();
        v8 = *MEMORY[0x1E0CF2758];
        v3 = 0;
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
LABEL_27:
          CheckOutHandleDebug();
          return v3;
        }
        v9 = *(_DWORD *)(v5 + 4);
        v10 = *(_DWORD *)(v5 + 8);
        v26 = 136316674;
        v27 = v7;
        v28 = 2080;
        v29 = "RTPSetRemoteSSRC";
        v30 = 1024;
        v31 = 3220;
        v32 = 1024;
        v33 = v9;
        v34 = 1024;
        v35 = v10;
        v36 = 1024;
        v37 = a2;
        v38 = 1024;
        v39 = a2;
        _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTPSetRemoteSSRC [%d/%d]: SSRC = 0x%X(%u)", (uint8_t *)&v26, 0x34u);
      }
      v3 = 0;
      goto LABEL_27;
    }
    if (!*(_DWORD *)(v5 + 4832))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          RTPSetRemoteSSRC_cold_1();
      }
      goto LABEL_24;
    }
    v11 = *MEMORY[0x1E0C9AE00];
    v12 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, (const void *)(v5 + 4832));
    if (!v12)
    {
      v3 = 2147549187;
LABEL_24:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v24 = VRTraceErrorLogLevelToCSTR();
        v25 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v26 = 136316162;
          v27 = v24;
          v28 = 2080;
          v29 = "RTPSetRemoteSSRC";
          v30 = 1024;
          v31 = 3223;
          v32 = 1024;
          v33 = a2;
          v34 = 1024;
          v35 = a2;
          _os_log_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTPSetRemoteSSRC: SSRC = 0x%X(%u)", (uint8_t *)&v26, 0x28u);
        }
      }
      goto LABEL_27;
    }
    v14 = v12;
    v15 = *(_QWORD *)(v5 + 11128);
    if (!v15)
    {
      v16 = VCPacketFilterRTPCreate(v11, (_QWORD *)(v5 + 11128));
      if ((v16 & 0x80000000) != 0)
        goto LABEL_21;
      v15 = *(_QWORD *)(v5 + 11128);
    }
    CMBaseObject = VCPacketFilterGetCMBaseObject(v15, v13);
    v18 = *(uint64_t (**)(uint64_t, const __CFString *, CFNumberRef))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                             + 56);
    if (!v18)
      goto LABEL_22;
    v16 = v18(CMBaseObject, CFSTR("RTPRemoteSSRC"), v14);
    if ((v16 & 0x80000000) == 0)
    {
      v20 = *(_QWORD *)(v5 + 11136);
      if (v20)
        goto LABEL_19;
      v21 = (uint64_t *)(v5 + 11136);
      v16 = VCPacketFilterRTCPCreate(v11, v21);
      if ((v16 & 0x80000000) == 0)
      {
        v20 = *v21;
LABEL_19:
        v22 = VCPacketFilterGetCMBaseObject(v20, v19);
        v23 = *(uint64_t (**)(uint64_t, const __CFString *, CFNumberRef))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                             + 8)
                                                                                 + 56);
        if (v23)
        {
          v16 = v23(v22, CFSTR("RTCPRemoteSSRC"), v14);
          goto LABEL_21;
        }
LABEL_22:
        v3 = 4294954514;
        goto LABEL_23;
      }
    }
LABEL_21:
    v3 = v16;
LABEL_23:
    CFRelease(v14);
    goto LABEL_24;
  }
  __break(0x5519u);
  return result;
}

void RTPSetCellularUniqueTag(uint64_t a1, int a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  NSObject *v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = CheckInHandleDebug();
  if (v3)
  {
    v4 = v3;
    if (*(_DWORD *)(v3 + 28))
      goto LABEL_11;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v6 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v7 = *(_DWORD *)(v4 + 4);
        v9 = 136316418;
        v10 = v5;
        v11 = 2080;
        v12 = "RTPSetCellularUniqueTag";
        v13 = 1024;
        v14 = 3241;
        v15 = 1024;
        v16 = v7;
        v17 = 1024;
        v18 = a2;
        v19 = 1024;
        v20 = a2;
        _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTPSetCellularUniqueTag vfd = %d tag = 0x%X(%u)", (uint8_t *)&v9, 0x2Eu);
      }
    }
    *(_DWORD *)(v4 + 92) = a2;
    if (!*(_QWORD *)(v4 + 11120))
    {
      v8 = *(_DWORD *)(v4 + 4);
      if (v8 != -1)
        VTP_SetCellularUniqueTag(v8, a2);
      goto LABEL_11;
    }
    if (v4 < v4 + 27616)
    {
      _RTPSetCellularUniqueTagOnPacketFilters(v4);
LABEL_11:
      CheckOutHandleDebug();
      return;
    }
    __break(0x5519u);
  }
}

uint64_t _RTPSetCellularUniqueTagOnPacketFilters(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  CFNumberRef v4;
  uint64_t v5;
  CFNumberRef v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t CMBaseObject;
  uint64_t (*v11)(uint64_t, const __CFString *, CFNumberRef);

  v1 = 2147549185;
  if (a1)
  {
    if (*(_DWORD *)(a1 + 92))
    {
      v3 = *MEMORY[0x1E0C9AE00];
      v4 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, (const void *)(a1 + 92));
      if (!v4)
        return 2147549187;
      v6 = v4;
      v7 = *(_QWORD *)(a1 + 11144);
      if (!v7)
      {
        v8 = (uint64_t *)(a1 + 11144);
        v9 = VCPacketFilterBasebandNotificationCreate(v3, v8);
        if ((v9 & 0x80000000) != 0)
          goto LABEL_9;
        v7 = *v8;
      }
      CMBaseObject = VCPacketFilterGetCMBaseObject(v7, v5);
      v11 = *(uint64_t (**)(uint64_t, const __CFString *, CFNumberRef))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                               + 56);
      if (!v11)
      {
        v1 = 4294954514;
        goto LABEL_11;
      }
      v9 = v11(CMBaseObject, CFSTR("CellularUniqueTag"), v6);
LABEL_9:
      v1 = v9;
LABEL_11:
      CFRelease(v6);
      return v1;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _RTPSetCellularUniqueTagOnPacketFilters_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _RTPSetCellularUniqueTagOnPacketFilters_cold_1();
  }
  return v1;
}

uint64_t RTPSetStreamDirection(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  int v7;
  int v8;
  int v10;
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v3 = CheckInHandleDebug();
  if (!v3)
    return 2147549186;
  v4 = v3;
  *(_DWORD *)(v3 + 7000) = a2;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v5 = VRTraceErrorLogLevelToCSTR();
    v6 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v7 = *(_DWORD *)(v4 + 4);
      v8 = *(_DWORD *)(v4 + 8);
      v10 = 136316674;
      v11 = v5;
      v12 = 2080;
      v13 = "RTPSetStreamDirection";
      v14 = 1024;
      v15 = 3266;
      v16 = 2048;
      v17 = v4;
      v18 = 1024;
      v19 = v7;
      v20 = 1024;
      v21 = v8;
      v22 = 1024;
      v23 = a2;
      _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTPSetStreamDirection [%p] [%d/%d]: Direction[%d]", (uint8_t *)&v10, 0x38u);
    }
  }
  CheckOutHandleDebug();
  return 0;
}

unint64_t RTPTransport_SetNACKConsumer(uint64_t a1, uint64_t a2)
{
  unint64_t result;
  _DWORD *v4;
  int v5;
  unsigned int v6;
  uint64_t v7;
  NSObject *v8;
  int v9;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  _DWORD *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  int v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  result = CheckInHandleDebug();
  if (!result)
    return 2147549186;
  v4 = (_DWORD *)result;
  *(_QWORD *)(result + 27592) = a2;
  if (!a2)
  {
    if (result >= result + 27616)
    {
      __break(0x5519u);
      return result;
    }
    v5 = 0;
    do
    {
      v6 = (unsigned __int16)v5;
      _RTPTransportMediaPacketHistoryCleanUp((uint64_t)v4, (unsigned __int16)v5++);
    }
    while (v6 < 0x3FF);
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v7 = VRTraceErrorLogLevelToCSTR();
    v8 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v9 = v4[1];
      v10 = v4[2];
      v11 = v4[50];
      v12 = 136316930;
      v13 = v7;
      v14 = 2080;
      v15 = "RTPTransport_SetNACKConsumer";
      v16 = 1024;
      v17 = 3332;
      v18 = 2048;
      v19 = v4;
      v20 = 1024;
      v21 = v9;
      v22 = 1024;
      v23 = v10;
      v24 = 2048;
      v25 = a2;
      v26 = 1024;
      v27 = v11;
      _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTPTransport_SetNACKConsumer [%p] [%d/%d]: nackConsumer[%p] ssrc=%u", (uint8_t *)&v12, 0x42u);
    }
  }
  CheckOutHandleDebug();
  return 0;
}

uint64_t _RTPConfigureVirtualSockets(unsigned int *a1, int a2, int a3)
{
  _BOOL4 v6;
  uint64_t v7;
  NSObject *v8;
  _BOOL4 v9;
  uint64_t v10;
  NSObject *v11;
  int v12;
  int v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  NSObject *v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  int v21;
  const void *v22;
  uint64_t v23;
  NSObject *v24;
  unsigned int v25;
  uint64_t v26;
  NSObject *v27;
  unsigned int v28;
  int v29;
  unsigned int v30;
  int v31;
  uint64_t v32;
  socklen_t v34;
  _OWORD v35[2];
  uint64_t v36;
  uint8_t buf[4];
  uint64_t v38;
  __int16 v39;
  const char *v40;
  __int16 v41;
  int v42;
  __int16 v43;
  int v44;
  __int16 v45;
  int v46;
  __int16 v47;
  int v48;
  sockaddr v49[8];
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  memset(v49, 0, sizeof(v49));
  v49[0].sa_len = 0x80;
  v6 = RTPMapPacketMultiplexModeToVTPMode(*a1);
  VTP_SetSocketMode(a2, v6);
  v34 = 128;
  if (VTP_Getsockname(a2, v49, &v34))
  {
    v32 = *__error() | 0xC0010000;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _RTPConfigureVirtualSockets_cold_2();
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v7 = VRTraceErrorLogLevelToCSTR();
      v8 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        v38 = v7;
        v39 = 2080;
        v40 = "_RTPConfigureVirtualSockets";
        v41 = 1024;
        v42 = 3430;
        v43 = 1024;
        v44 = a2;
        _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Start listening RTP on sock %d", buf, 0x22u);
      }
    }
    v9 = RTPMapPacketMultiplexModeToVTPMode(*a1);
    VTP_SetSocketMode(a3, v9);
    v34 = 128;
    if (!VTP_Getsockname(a3, v49, &v34))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v10 = VRTraceErrorLogLevelToCSTR();
        v11 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315906;
          v38 = v10;
          v39 = 2080;
          v40 = "_RTPConfigureVirtualSockets";
          v41 = 1024;
          v42 = 3437;
          v43 = 1024;
          v44 = a3;
          _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Start listening RTCP on sock %d", buf, 0x22u);
        }
      }
      v12 = a1[1];
      if (v12 != -1)
        VTP_Close(v12);
      v13 = a1[2];
      if (v13 != -1)
        VTP_Close(v13);
      a1[1] = a2;
      a1[2] = a3;
      if (a1[7])
      {
        VTP_SetPktType(a2, 32);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v14 = VRTraceErrorLogLevelToCSTR();
          v15 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136316162;
            v38 = v14;
            v39 = 2080;
            v40 = "_RTPConfigureVirtualSockets";
            v41 = 1024;
            v42 = 3456;
            v43 = 1024;
            v44 = a2;
            v45 = 1024;
            v46 = 32;
            _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTP  vfd (%d) accepts pkt (%04X)", buf, 0x28u);
          }
        }
        VTP_SetPktType(a3, 128);
        if ((int)VRTraceGetErrorLogLevelForModule() < 7)
          goto LABEL_27;
        v16 = VRTraceErrorLogLevelToCSTR();
        v17 = *MEMORY[0x1E0CF2758];
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          goto LABEL_27;
        *(_DWORD *)buf = 136316162;
        v38 = v16;
        v39 = 2080;
        v40 = "_RTPConfigureVirtualSockets";
        v41 = 1024;
        v42 = 3458;
        v43 = 1024;
        v44 = a3;
        v45 = 1024;
        v46 = 128;
      }
      else
      {
        VTP_SetPktType(a2, 272);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v18 = VRTraceErrorLogLevelToCSTR();
          v19 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136316162;
            v38 = v18;
            v39 = 2080;
            v40 = "_RTPConfigureVirtualSockets";
            v41 = 1024;
            v42 = 3451;
            v43 = 1024;
            v44 = a2;
            v45 = 1024;
            v46 = 272;
            _os_log_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTP  vfd (%d) accepts pkt (%04X)", buf, 0x28u);
          }
        }
        VTP_SetPktType(a3, 64);
        if ((int)VRTraceGetErrorLogLevelForModule() < 7)
          goto LABEL_27;
        v20 = VRTraceErrorLogLevelToCSTR();
        v17 = *MEMORY[0x1E0CF2758];
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          goto LABEL_27;
        *(_DWORD *)buf = 136316162;
        v38 = v20;
        v39 = 2080;
        v40 = "_RTPConfigureVirtualSockets";
        v41 = 1024;
        v42 = 3453;
        v43 = 1024;
        v44 = a3;
        v45 = 1024;
        v46 = 64;
      }
      _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTCP vfd (%d) accepts pkt (%04X)", buf, 0x28u);
LABEL_27:
      v21 = a1[8];
      v22 = (const void *)*((_QWORD *)a1 + 5);
      if (v22 && v21 < 1)
        __break(0x5519u);
      VTP_SetPayloadList(a2, v21, v22);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v23 = VRTraceErrorLogLevelToCSTR();
        v24 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v25 = a1[7];
          *(_DWORD *)buf = 136316418;
          v38 = v23;
          v39 = 2080;
          v40 = "_RTPConfigureVirtualSockets";
          v41 = 1024;
          v42 = 3464;
          v43 = 1024;
          v44 = v25;
          v45 = 1024;
          v46 = a2;
          v47 = 1024;
          v48 = a3;
          _os_log_impl(&dword_1D8A54000, v24, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTP/RTCP sockets for PayloadType %d are %d and %d", buf, 0x2Eu);
        }
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v26 = VRTraceErrorLogLevelToCSTR();
        v27 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v28 = a1[1];
          v29 = a1[1208];
          v30 = a1[23];
          *(_DWORD *)buf = 136316418;
          v38 = v26;
          v39 = 2080;
          v40 = "_RTPConfigureVirtualSockets";
          v41 = 1024;
          v42 = 3466;
          v43 = 1024;
          v44 = v28;
          v45 = 1024;
          v46 = v29;
          v47 = 1024;
          v48 = v30;
          _os_log_impl(&dword_1D8A54000, v27, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Configure RTP sockets: iSocRTP %d, dwRemoteSSRC %08X, cellularUniqueTag %d", buf, 0x2Eu);
        }
      }
      if (a1[22])
      {
        VTP_SetRemoteSSRC(a1[1], a1[1208]);
        VTP_SetRemoteSSRC(a1[2], a1[1208]);
      }
      v31 = a1[23];
      if (v31)
        VTP_SetCellularUniqueTag(a1[1], v31);
      v36 = 0;
      memset(v35, 0, sizeof(v35));
      SAToIPPORT();
      RTPSetDefaultCNAME((uint64_t)a1, 0, (int *)v35);
      return 0;
    }
    v32 = *__error() | 0xC0010000;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _RTPConfigureVirtualSockets_cold_1();
    }
  }
  return v32;
}

BOOL RTPMapPacketMultiplexModeToVTPMode(_BOOL8 result)
{
  if (!result && result != 2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      RTPMapPacketMultiplexModeToVTPMode_cold_1();
    }
    return 0;
  }
  return result;
}

void RTPSetDefaultCNAME(uint64_t a1, int *a2, int *a3)
{
  __int128 v6;
  char *v7;
  const char *v8;
  int v9;
  int v10;
  int v11;
  const char *v12;
  const char *v13;
  uint64_t v14;
  NSObject *v15;
  uint8_t buf[4];
  uint64_t v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  uint64_t v25;
  char __dst[16];
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v40 = v6;
  v41 = v6;
  v38 = v6;
  v39 = v6;
  v36 = v6;
  v37 = v6;
  v34 = v6;
  v35 = v6;
  v32 = v6;
  v33 = v6;
  v30 = v6;
  v31 = v6;
  v28 = v6;
  v29 = v6;
  *(_OWORD *)__dst = v6;
  v27 = v6;
  v7 = getlogin();
  if (v7)
    v8 = v7;
  else
    v8 = "user";
  if (a2 && IsIPPORTValid())
  {
    IPToString();
    v9 = *a2;
LABEL_10:
    v10 = v9 & 1;
    goto LABEL_12;
  }
  if (a3 && IsIPPORTValid())
  {
    IPToString();
    v9 = *a3;
    goto LABEL_10;
  }
  strncpy(__dst, "hostname", 0x100uLL);
  v10 = 0;
LABEL_12:
  v11 = hwrandom();
  v12 = "[";
  if (v10)
  {
    v13 = "]";
  }
  else
  {
    v12 = "";
    v13 = "";
  }
  __sprintf_chk((char *)(a1 + 360), 0, 0x100uLL, "%s%08X@%s%s%s", v8, v11, v12, __dst, v13);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v14 = VRTraceErrorLogLevelToCSTR();
    v15 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136316162;
      v17 = v14;
      v18 = 2080;
      v19 = "RTPSetDefaultCNAME";
      v20 = 1024;
      v21 = 3317;
      v22 = 2048;
      v23 = a1;
      v24 = 2080;
      v25 = a1 + 360;
      _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d CNAME for RTP(%p) is [%s]", buf, 0x30u);
    }
  }
}

uint64_t RTPSetSockets(uint64_t a1, int a2, int a3)
{
  sockaddr v5;
  uint64_t v6;
  unsigned int *v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  socklen_t v17;
  uint64_t v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  int v24;
  __int16 v25;
  int v26;
  sockaddr v27;
  sockaddr v28;
  sockaddr v29;
  sockaddr v30;
  sockaddr v31;
  sockaddr v32;
  sockaddr v33;
  sockaddr v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v5.sa_len = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v5.sa_data[6] = 0xAAAAAAAAAAAAAAAALL;
  v33 = v5;
  v34 = v5;
  v31 = v5;
  v32 = v5;
  v29 = v5;
  v30 = v5;
  v27 = v5;
  v28 = v5;
  if (a2 == -1 || a3 == -1)
  {
    v13 = 2147549185;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v14 = VRTraceErrorLogLevelToCSTR();
      v15 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v17 = 136316162;
        v18 = v14;
        v19 = 2080;
        v20 = "RTPSetSockets";
        v21 = 1024;
        v22 = 3492;
        v23 = 1024;
        v24 = a2;
        v25 = 1024;
        v26 = a3;
        _os_log_error_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_ERROR, " [%s] %s:%d RTPSetSockets: Invalid sockets passed: rtp(%d) rtcp(%d)", (uint8_t *)&v17, 0x28u);
      }
    }
  }
  else
  {
    v6 = CheckInHandleDebug();
    if (v6)
    {
      v7 = (unsigned int *)v6;
      v17 = 128;
      getsockname(a2, &v27, &v17);
      v8 = VTP_SocketWithRealSocket(v27.sa_family, 2, 17, a2);
      if (v8 == -1)
      {
        v13 = *__error() | 0xC0010000;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            RTPSetSockets_cold_1();
        }
        if (a2 != a3)
          close(a2);
      }
      else
      {
        v9 = v8;
        v17 = 128;
        getsockname(a3, &v27, &v17);
        v10 = VTP_SocketWithRealSocket(v27.sa_family, 2, 17, a3);
        if (v10 != -1)
        {
          v11 = v10;
          v12 = _RTPConfigureVirtualSockets(v7, v9, v10);
          if ((v12 & 0x80000000) != 0)
          {
            v13 = v12;
            VTP_Close(v9);
            VTP_Close(v11);
          }
          else
          {
            v13 = 0;
          }
          goto LABEL_13;
        }
        v13 = *__error() | 0xC0010000;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            RTPSetSockets_cold_2();
        }
        VTP_Close(v9);
      }
      close(a3);
LABEL_13:
      CheckOutHandleDebug();
      return v13;
    }
    return 2147549186;
  }
  return v13;
}

uint64_t RTPSetNWConnections(uint64_t a1, NSObject *a2)
{
  uint64_t v3;
  unsigned int *v4;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;

  if (a2)
  {
    v3 = CheckInHandleDebug();
    if (v3)
    {
      v4 = (unsigned int *)v3;
      v5 = VTP_SocketWithNWConnection(2u, 17, a2);
      if (v5 == -1)
      {
        v10 = *__error() | 0xC0010000;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            RTPSetNWConnections_cold_2();
        }
        goto LABEL_13;
      }
      v6 = v5;
      v7 = VTP_SocketWithNWConnection(2u, 17, a2);
      if (v7 == -1)
      {
        v10 = *__error() | 0xC0010000;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            RTPSetNWConnections_cold_3();
        }
        v11 = v6;
      }
      else
      {
        v8 = v7;
        v9 = _RTPConfigureVirtualSockets(v4, v6, v7);
        if ((v9 & 0x80000000) == 0)
        {
          v10 = 0;
LABEL_13:
          CheckOutHandleDebug();
          return v10;
        }
        v10 = v9;
        VTP_Close(v6);
        v11 = v8;
      }
      VTP_Close(v11);
      goto LABEL_13;
    }
    return 2147549186;
  }
  else
  {
    v10 = 2147549185;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RTPSetNWConnections_cold_1();
    }
  }
  return v10;
}

void RTPCreateSocketsForIDSInternal(unsigned int *a1)
{
  int v2;
  int v3;
  _BOOL4 v4;
  uint64_t v5;
  NSObject *v6;
  int v7;
  int v8;
  _BOOL4 v9;
  uint64_t v10;
  NSObject *v11;
  int v12;
  int v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  NSObject *v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  int v21;
  const void *v22;
  uint64_t v23;
  NSObject *v24;
  unsigned int v25;
  int v26;
  unsigned int v27;
  unsigned int v28;
  int v29;
  int v30;
  uint64_t v31;
  __int16 v32;
  const char *v33;
  __int16 v34;
  int v35;
  __int16 v36;
  int v37;
  __int16 v38;
  int v39;
  __int16 v40;
  unsigned int v41;
  __int16 v42;
  unsigned int v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v2 = VTP_SocketForIDS();
  if (v2 == -1)
  {
    __error();
    if ((int)VRTraceGetErrorLogLevelForModule() > 2)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RTPCreateSocketsForIDSInternal_cold_1();
    }
  }
  else
  {
    v3 = v2;
    v4 = RTPMapPacketMultiplexModeToVTPMode(*a1);
    VTP_SetSocketMode(v3, v4);
    VTP_SetTransportSessionID(v3, a1[2600]);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v6 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v30 = 136315906;
        v31 = v5;
        v32 = 2080;
        v33 = "RTPCreateSocketsForIDSInternal";
        v34 = 1024;
        v35 = 3588;
        v36 = 1024;
        v37 = v3;
        _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Start listening RTP on virtual socket %d", (uint8_t *)&v30, 0x22u);
      }
    }
    v7 = VTP_SocketForIDS();
    if (v7 != -1)
    {
      v8 = v7;
      v9 = RTPMapPacketMultiplexModeToVTPMode(*a1);
      VTP_SetSocketMode(v8, v9);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v10 = VRTraceErrorLogLevelToCSTR();
        v11 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v30 = 136315906;
          v31 = v10;
          v32 = 2080;
          v33 = "RTPCreateSocketsForIDSInternal";
          v34 = 1024;
          v35 = 3602;
          v36 = 1024;
          v37 = v8;
          _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Start listening RTCP on virtual socket %d", (uint8_t *)&v30, 0x22u);
        }
      }
      v12 = a1[1];
      if (v12 != -1)
        VTP_Close(v12);
      v13 = a1[2];
      if (v13 != -1)
        VTP_Close(v13);
      a1[1] = v3;
      a1[2] = v8;
      if (a1[7])
      {
        VTP_SetPktType(v3, 32);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v14 = VRTraceErrorLogLevelToCSTR();
          v15 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v30 = 136316162;
            v31 = v14;
            v32 = 2080;
            v33 = "RTPCreateSocketsForIDSInternal";
            v34 = 1024;
            v35 = 3621;
            v36 = 1024;
            v37 = v3;
            v38 = 1024;
            v39 = 32;
            _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTP  vfd (%d) accepts pkt (%04X)", (uint8_t *)&v30, 0x28u);
          }
        }
        VTP_SetPktType(v8, 128);
        if ((int)VRTraceGetErrorLogLevelForModule() < 7)
          goto LABEL_34;
        v16 = VRTraceErrorLogLevelToCSTR();
        v17 = *MEMORY[0x1E0CF2758];
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          goto LABEL_34;
        v30 = 136316162;
        v31 = v16;
        v32 = 2080;
        v33 = "RTPCreateSocketsForIDSInternal";
        v34 = 1024;
        v35 = 3623;
        v36 = 1024;
        v37 = v8;
        v38 = 1024;
        v39 = 128;
      }
      else
      {
        VTP_SetPktType(v3, 272);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v18 = VRTraceErrorLogLevelToCSTR();
          v19 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v30 = 136316162;
            v31 = v18;
            v32 = 2080;
            v33 = "RTPCreateSocketsForIDSInternal";
            v34 = 1024;
            v35 = 3616;
            v36 = 1024;
            v37 = v3;
            v38 = 1024;
            v39 = 272;
            _os_log_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTP  vfd (%d) accepts pkt (%04X)", (uint8_t *)&v30, 0x28u);
          }
        }
        VTP_SetPktType(v8, 64);
        if ((int)VRTraceGetErrorLogLevelForModule() < 7)
          goto LABEL_34;
        v20 = VRTraceErrorLogLevelToCSTR();
        v17 = *MEMORY[0x1E0CF2758];
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          goto LABEL_34;
        v30 = 136316162;
        v31 = v20;
        v32 = 2080;
        v33 = "RTPCreateSocketsForIDSInternal";
        v34 = 1024;
        v35 = 3618;
        v36 = 1024;
        v37 = v8;
        v38 = 1024;
        v39 = 64;
      }
      _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTCP vfd (%d) accepts pkt (%04X)", (uint8_t *)&v30, 0x28u);
LABEL_34:
      v21 = a1[8];
      v22 = (const void *)*((_QWORD *)a1 + 5);
      if (v22 && v21 < 1)
      {
        __break(0x5519u);
      }
      else
      {
        VTP_SetPayloadList(v3, v21, v22);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v23 = VRTraceErrorLogLevelToCSTR();
          v24 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v25 = a1[1];
            v26 = a1[2];
            v27 = a1[1208];
            v28 = a1[23];
            v30 = 136316674;
            v31 = v23;
            v32 = 2080;
            v33 = "RTPCreateSocketsForIDSInternal";
            v34 = 1024;
            v35 = 3627;
            v36 = 1024;
            v37 = v25;
            v38 = 1024;
            v39 = v26;
            v40 = 1024;
            v41 = v27;
            v42 = 1024;
            v43 = v28;
            _os_log_impl(&dword_1D8A54000, v24, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTPCreateSocketsForIDS iSocRTP %d, iSocRTCP %d, dwRemoteSSRC %08X, cellularUniqueTag %d", (uint8_t *)&v30, 0x34u);
          }
        }
        if (a1[22])
        {
          VTP_SetRemoteSSRC(a1[1], a1[1208]);
          VTP_SetRemoteSSRC(a1[2], a1[1208]);
        }
        v29 = a1[23];
        if (v29)
          VTP_SetCellularUniqueTag(a1[1], v29);
      }
      return;
    }
    __error();
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RTPCreateSocketsForIDSInternal_cold_2();
    }
    VTP_Close(v3);
  }
}

uint64_t RTPCreateSocketsForIDS()
{
  unsigned int *v0;
  uint64_t v1;
  uint64_t v2;

  v0 = (unsigned int *)CheckInHandleDebug();
  if (!v0)
    return 2147549186;
  RTPCreateSocketsForIDSInternal(v0);
  v2 = v1;
  CheckOutHandleDebug();
  return v2;
}

void RTPCreateSocketsRetryBind(uint64_t a1, __int128 *a2, uint64_t a3, int *a4)
{
  __int128 v5;
  uint64_t v8;
  unint64_t v9;
  __int128 v10;
  int v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  NSObject *v16;
  __int16 v17;
  int v18;
  uint64_t v19;
  NSObject *v20;
  int v21;
  int v22;
  int ErrorLogLevelForModule;
  uint64_t v25;
  NSObject *v26;
  uint64_t v27;
  NSObject *v28;
  int v29;
  int v30;
  uint64_t v31;
  NSObject *v32;
  uint64_t v33;
  NSObject *v34;
  uint64_t v35;
  NSObject *v36;
  uint64_t v37;
  int v38;
  const void *v39;
  uint64_t v40;
  NSObject *v41;
  int v42;
  uint64_t v43;
  NSObject *v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int *v49;
  unint64_t v50;
  socklen_t v51;
  int v52;
  int v53;
  uint8_t buf[4];
  uint64_t v55;
  __int16 v56;
  const char *v57;
  __int16 v58;
  int v59;
  __int16 v60;
  _BYTE v61[10];
  _BYTE v62[6];
  int v63;
  __int16 v64;
  int v65;
  __int128 v66;
  __int128 v67;
  unint64_t v68;
  sockaddr v69[8];
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  v52 = -1;
  v53 = -1;
  memset(v69, 0, sizeof(v69));
  v69[0].sa_len = 0x80;
  if (!a2)
    return;
  v51 = -1431655766;
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v66 = v5;
  v67 = v5;
  v68 = 0xAAAAAAAAAAAAAAAALL;
  if ((*((_BYTE *)a2 + 36) & 1) != 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RTPCreateSocketsRetryBind_cold_1();
    }
  }
  else
  {
    v8 = CheckInHandleDebug();
    if (!v8)
      return;
    v9 = v8;
    v49 = a4;
    v50 = v8 + 27616;
    v10 = a2[1];
    v66 = *a2;
    v67 = v10;
    v68 = *((_QWORD *)a2 + 4);
    v11 = 100;
    do
    {
      v12 = CreateSocket((unsigned int *)v9, (int *)&v66, &v53);
      if (v12 < 0)
      {
        v18 = v12;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v19 = VRTraceErrorLogLevelToCSTR();
          v20 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136316162;
            v55 = v19;
            v56 = 2080;
            v57 = "RTPCreateSocketsRetryBind";
            v58 = 1024;
            v59 = 3692;
            v60 = 1024;
            *(_DWORD *)v61 = v18;
            *(_WORD *)&v61[4] = 1024;
            *(_DWORD *)&v61[6] = WORD2(v68);
            _os_log_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTPCreateSocketsRetryBind failed to create RTP socket: hResult(%x) port(%d)", buf, 0x28u);
          }
        }
        v17 = 2;
      }
      else
      {
        ++WORD2(v68);
        v13 = CreateSocket((unsigned int *)v9, (int *)&v66, &v52);
        if ((v13 & 0x80000000) == 0)
          break;
        v14 = v13;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v15 = VRTraceErrorLogLevelToCSTR();
          v16 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136316162;
            v55 = v15;
            v56 = 2080;
            v57 = "RTPCreateSocketsRetryBind";
            v58 = 1024;
            v59 = 3687;
            v60 = 1024;
            *(_DWORD *)v61 = v14;
            *(_WORD *)&v61[4] = 1024;
            *(_DWORD *)&v61[6] = WORD2(v68);
            _os_log_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTPCreateSocketsRetryBind failed to create RTCP socket: hResult(%x) port(%d)", buf, 0x28u);
          }
        }
        VTP_Close(v53);
        v17 = 1;
      }
      WORD2(v68) += v17;
      --v11;
    }
    while (v11);
    v21 = v52;
    v22 = v53;
    if (v53 != -1 && v52 != -1)
    {
      v51 = 128;
      VTP_Getsockname(v53, v69, &v51);
      ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
      if (ErrorLogLevelForModule >= 7)
      {
        v25 = VRTraceErrorLogLevelToCSTR();
        v26 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315906;
          v55 = v25;
          v56 = 2080;
          v57 = "RTPCreateSocketsRetryBind";
          v58 = 1024;
          v59 = 3703;
          v60 = 1024;
          *(_DWORD *)v61 = v22;
          _os_log_impl(&dword_1D8A54000, v26, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Start listening RTP on sock %d", buf, 0x22u);
        }
      }
      v51 = 128;
      VTP_Getsockname(v21, v69, &v51);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v27 = VRTraceErrorLogLevelToCSTR();
        v28 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315906;
          v55 = v27;
          v56 = 2080;
          v57 = "RTPCreateSocketsRetryBind";
          v58 = 1024;
          v59 = 3707;
          v60 = 1024;
          *(_DWORD *)v61 = v21;
          _os_log_impl(&dword_1D8A54000, v28, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Start listening RTCP on sock %d", buf, 0x22u);
        }
      }
      v29 = *(_DWORD *)(v9 + 4);
      if (v29 != -1)
        VTP_Close(v29);
      v30 = *(_DWORD *)(v9 + 8);
      if (v30 != -1)
        VTP_Close(v30);
      *(_DWORD *)(v9 + 4) = v22;
      *(_DWORD *)(v9 + 8) = v21;
      if (*(_DWORD *)(v9 + 28))
      {
        VTP_SetPktType(v22, 32);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v31 = VRTraceErrorLogLevelToCSTR();
          v32 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136316162;
            v55 = v31;
            v56 = 2080;
            v57 = "RTPCreateSocketsRetryBind";
            v58 = 1024;
            v59 = 3726;
            v60 = 1024;
            *(_DWORD *)v61 = v22;
            *(_WORD *)&v61[4] = 1024;
            *(_DWORD *)&v61[6] = 32;
            _os_log_impl(&dword_1D8A54000, v32, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTP  vfd (%d) accepts pkt (%04X)", buf, 0x28u);
          }
        }
        VTP_SetPktType(v21, 128);
        if ((int)VRTraceGetErrorLogLevelForModule() < 7)
          goto LABEL_55;
        v33 = VRTraceErrorLogLevelToCSTR();
        v34 = *MEMORY[0x1E0CF2758];
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          goto LABEL_55;
        *(_DWORD *)buf = 136316162;
        v55 = v33;
        v56 = 2080;
        v57 = "RTPCreateSocketsRetryBind";
        v58 = 1024;
        v59 = 3728;
        v60 = 1024;
        *(_DWORD *)v61 = v21;
        *(_WORD *)&v61[4] = 1024;
        *(_DWORD *)&v61[6] = 128;
      }
      else
      {
        VTP_SetPktType(v22, 272);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v35 = VRTraceErrorLogLevelToCSTR();
          v36 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136316162;
            v55 = v35;
            v56 = 2080;
            v57 = "RTPCreateSocketsRetryBind";
            v58 = 1024;
            v59 = 3721;
            v60 = 1024;
            *(_DWORD *)v61 = v22;
            *(_WORD *)&v61[4] = 1024;
            *(_DWORD *)&v61[6] = 272;
            _os_log_impl(&dword_1D8A54000, v36, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTP  vfd (%d) accepts pkt (%04X)", buf, 0x28u);
          }
        }
        VTP_SetPktType(v21, 64);
        if ((int)VRTraceGetErrorLogLevelForModule() < 7)
          goto LABEL_55;
        v37 = VRTraceErrorLogLevelToCSTR();
        v34 = *MEMORY[0x1E0CF2758];
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          goto LABEL_55;
        *(_DWORD *)buf = 136316162;
        v55 = v37;
        v56 = 2080;
        v57 = "RTPCreateSocketsRetryBind";
        v58 = 1024;
        v59 = 3723;
        v60 = 1024;
        *(_DWORD *)v61 = v21;
        *(_WORD *)&v61[4] = 1024;
        *(_DWORD *)&v61[6] = 64;
      }
      _os_log_impl(&dword_1D8A54000, v34, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTCP vfd (%d) accepts pkt (%04X)", buf, 0x28u);
LABEL_55:
      v38 = *(_DWORD *)(v9 + 32);
      v39 = *(const void **)(v9 + 40);
      if (v39 && v38 < 1)
        goto LABEL_70;
      VTP_SetPayloadList(v22, v38, v39);
      if ((int)VRTraceGetErrorLogLevelForModule() > 6)
      {
        v40 = VRTraceErrorLogLevelToCSTR();
        v41 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v42 = *(_DWORD *)(v9 + 28);
          *(_DWORD *)buf = 136316418;
          v55 = v40;
          v56 = 2080;
          v57 = "RTPCreateSocketsRetryBind";
          v58 = 1024;
          v59 = 3733;
          v60 = 1024;
          *(_DWORD *)v61 = v42;
          *(_WORD *)&v61[4] = 1024;
          *(_DWORD *)&v61[6] = v22;
          *(_WORD *)v62 = 1024;
          *(_DWORD *)&v62[2] = v21;
          _os_log_impl(&dword_1D8A54000, v41, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTP/RTCP sockets for PayloadType %d are %d and %d", buf, 0x2Eu);
        }
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
      {
        v43 = VRTraceErrorLogLevelToCSTR();
        v44 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v45 = *(_DWORD *)(v9 + 4);
          v46 = *(_DWORD *)(v9 + 4832);
          v47 = *(_DWORD *)(v9 + 92);
          *(_DWORD *)buf = 136316674;
          v55 = v43;
          v56 = 2080;
          v57 = "RTPCreateSocketsRetryBind";
          v58 = 1024;
          v59 = 3735;
          v60 = 2048;
          *(_QWORD *)v61 = a1;
          *(_WORD *)&v61[8] = 1024;
          *(_DWORD *)v62 = v45;
          *(_WORD *)&v62[4] = 1024;
          v63 = v46;
          v64 = 1024;
          v65 = v47;
          _os_log_impl(&dword_1D8A54000, v44, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTPCreateSockets hRTP %p, iSocRTP %d, dwRemoteSSRC %08X cellularUniqueTag %d", buf, 0x38u);
        }
      }
      if (*(_DWORD *)(v9 + 88))
      {
        VTP_SetRemoteSSRC(*(_DWORD *)(v9 + 4), *(_DWORD *)(v9 + 4832));
        VTP_SetRemoteSSRC(*(_DWORD *)(v9 + 8), *(_DWORD *)(v9 + 4832));
      }
      v48 = *(_DWORD *)(v9 + 92);
      if (v48)
        VTP_SetCellularUniqueTag(*(_DWORD *)(v9 + 4), v48);
      if (v9 >= v50)
      {
LABEL_70:
        __break(0x5519u);
      }
      else
      {
        RTPSetDefaultCNAME(v9, (int *)a2, v49);
        CheckOutHandleDebug();
      }
      return;
    }
    if (v53 != -1)
      VTP_Close(v53);
    if (v21 != -1)
      VTP_Close(v21);
    CheckOutHandleDebug();
  }
}

uint64_t CreateSocket(unsigned int *a1, int *a2, int *a3)
{
  __int128 v6;
  int v7;
  int ai_family;
  int v9;
  int v10;
  addrinfo *v11;
  int v12;
  addrinfo *v13;
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  int v17;
  int v18;
  _BOOL4 v19;
  uint64_t result;
  unint64_t ai_addr;
  uint64_t ai_addrlen;
  int v23;
  const char *v24;
  uint64_t v25;
  NSObject *v26;
  unsigned int v27;
  addrinfo *v28;
  addrinfo v29;
  char v30[8];
  uint8_t buf[4];
  uint64_t v32;
  __int16 v33;
  const char *v34;
  __int16 v35;
  int v36;
  __int16 v37;
  int v38;
  __int16 v39;
  char *v40;
  __int16 v41;
  char *v42;
  __int16 v43;
  int v44;
  _OWORD v45[3];
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v45[1] = v6;
  v45[2] = v6;
  v45[0] = v6;
  memset(v30, 170, 6);
  v28 = (addrinfo *)0xAAAAAAAAAAAAAAAALL;
  v7 = *a2;
  if ((*a2 & 1) != 0)
    ai_family = 30;
  else
    ai_family = 2;
  if ((v7 & 1) != 0)
    v9 = 125;
  else
    v9 = 25;
  memset(&v29.ai_socktype, 0, 40);
  v29.ai_flags = 1;
  v29.ai_family = ai_family;
  v29.ai_socktype = 2;
  IPToString();
  __sprintf_chk(v30, 0, 6uLL, "%u", *((unsigned __int16 *)a2 + 18));
  v10 = getaddrinfo((const char *)v45, v30, &v29, &v28);
  if (v10 || (v11 = v28) == 0)
  {
    v14 = v10 | 0xB0010000;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v15 = VRTraceErrorLogLevelToCSTR();
      v16 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136316674;
        v32 = v15;
        v33 = 2080;
        v34 = "CreateSocket";
        v35 = 1024;
        v36 = 3363;
        v37 = 1024;
        v38 = 3363;
        v39 = 2080;
        v40 = (char *)v45;
        v41 = 2080;
        v42 = v30;
        v43 = 1024;
        v44 = v14;
        _os_log_error_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_ERROR, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/RTPTransport.c:%d: getaddrinfo(%s,%s) failed(%08X)", buf, 0x3Cu);
      }
    }
    return v14;
  }
  v12 = (v7 << 31 >> 31) & 0x29;
  v13 = v28;
  while (v13->ai_family != ai_family)
  {
    v13 = v13->ai_next;
    if (!v13)
    {
      ai_family = v28->ai_family;
      goto LABEL_17;
    }
  }
  v11 = v13;
LABEL_17:
  v17 = VTP_Socket(ai_family, v11->ai_socktype, v11->ai_protocol);
  if (v17 == -1)
  {
    v14 = *__error() | 0xC0010000;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateSocket_cold_1();
    }
    freeaddrinfo(v28);
    return v14;
  }
  v18 = v17;
  v19 = RTPMapPacketMultiplexModeToVTPMode(*a1);
  result = VTP_SetSocketMode(v18, v19);
  ai_addr = (unint64_t)v11->ai_addr;
  ai_addrlen = v11->ai_addrlen;
  if (!ai_addr || ai_addr < ai_addr + ai_addrlen)
  {
    v23 = VTP_BindNew(v18, ai_addr, ai_addrlen);
    v24 = (const char *)(a2 + 1);
    VTP_DetectNAT64Prefix(v18, v24);
    freeaddrinfo(v28);
    if (v23 == -1)
    {
      v14 = *__error() | 0xC0010000;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v25 = VRTraceErrorLogLevelToCSTR();
        v26 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136316418;
          v32 = v25;
          v33 = 2080;
          v34 = "CreateSocket";
          v35 = 1024;
          v36 = 3392;
          v37 = 1024;
          v38 = 3392;
          v39 = 2080;
          v40 = v30;
          v41 = 1024;
          LODWORD(v42) = v14;
          _os_log_error_impl(&dword_1D8A54000, v26, OS_LOG_TYPE_ERROR, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/RTPTransport.c:%d: bind on %s failed(%08X)", buf, 0x32u);
        }
      }
    }
    else
    {
      if (!*v24 || (v27 = if_nametoindex(v24)) == 0 || !VTP_Setsockopt(v18, v12, v9, &v27, 4u))
      {
        v14 = 0;
        *a3 = v18;
        return v14;
      }
      v14 = *__error() | 0xC0010000;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          CreateSocket_cold_2();
      }
    }
    VTP_Close(v18);
    return v14;
  }
  __break(0x5519u);
  return result;
}

uint64_t RTPSetCName(int a1, _BYTE *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  int v9;
  uint64_t v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  int v16;
  __int16 v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v4 = CheckInHandleDebug();
  if (!v4)
    return 2147549186;
  if (*a2)
  {
    v5 = v4 + 360;
    __strlcpy_chk();
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v6 = VRTraceErrorLogLevelToCSTR();
      v7 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v9 = 136316162;
        v10 = v6;
        v11 = 2080;
        v12 = "RTPSetCName";
        v13 = 1024;
        v14 = 3775;
        v15 = 1024;
        v16 = a1;
        v17 = 2080;
        v18 = v5;
        _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d CNAME for RTP Handle(%d) is [%s]", (uint8_t *)&v9, 0x2Cu);
      }
    }
  }
  CheckOutHandleDebug();
  return 0;
}

void RTPCreateSockets(uint64_t a1, uint64_t a2, int *a3, int *a4, int *a5)
{
  uint64_t v10;
  unsigned int *v11;
  __int128 v12;
  int v13;
  int v14;
  addrinfo *v15;
  addrinfo *v16;
  int ai_family;
  unsigned int v18;
  uint64_t v19;
  NSObject *v20;
  int v21;
  int v22;
  _BOOL4 v23;
  int v24;
  addrinfo *v25;
  addrinfo *v26;
  unsigned int v27;
  uint64_t v28;
  NSObject *v29;
  int v30;
  int v31;
  _BOOL4 v32;
  int v33;
  int v34;
  uint64_t v35;
  NSObject *v36;
  uint64_t v37;
  NSObject *v38;
  uint64_t v39;
  NSObject *v40;
  uint64_t v41;
  int v42;
  const void *v43;
  uint64_t v44;
  NSObject *v45;
  unsigned int v46;
  uint64_t v47;
  NSObject *v48;
  unsigned int v49;
  unsigned int v50;
  unsigned int v51;
  int v52;
  uint64_t v53;
  int v54;
  int v55;
  uint64_t v56;
  NSObject *v57;
  unsigned int v58;
  uint64_t v59;
  addrinfo *v60;
  addrinfo v61;
  socklen_t v62;
  char v63[8];
  uint8_t buf[4];
  uint64_t v65;
  __int16 v66;
  const char *v67;
  __int16 v68;
  int v69;
  __int16 v70;
  __int128 v71;
  _BYTE v72[14];
  sockaddr v73[8];
  _OWORD v74[3];
  uint64_t v75;

  v75 = *MEMORY[0x1E0C80C00];
  memset(v63, 170, 6);
  memset(v73, 0, sizeof(v73));
  v73[0].sa_len = 0x80;
  v10 = CheckInHandleDebug();
  if (!v10)
    return;
  v11 = (unsigned int *)v10;
  v62 = -1431655766;
  *(_QWORD *)&v12 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v74[0] = v12;
  v74[1] = v12;
  v74[2] = v12;
  v60 = (addrinfo *)0xAAAAAAAAAAAAAAAALL;
  if ((*(_DWORD *)a2 & 1) != 0)
    v13 = 30;
  else
    v13 = 2;
  memset(&v61.ai_socktype, 0, 40);
  v61.ai_flags = 1;
  v61.ai_family = v13;
  v61.ai_socktype = 2;
  IPToString();
  __sprintf_chk(v63, 0, 6uLL, "%u", *(unsigned __int16 *)(a2 + 36));
  v14 = getaddrinfo((const char *)v74, v63, &v61, &v60);
  if (v14 || (v15 = v60) == 0)
  {
    v18 = v14 | 0xB0010000;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v19 = VRTraceErrorLogLevelToCSTR();
      v20 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136316674;
        v65 = v19;
        v66 = 2080;
        v67 = "RTPCreateSockets";
        v68 = 1024;
        v69 = 3815;
        v70 = 1024;
        LODWORD(v71) = 3815;
        WORD2(v71) = 2080;
        *(_QWORD *)((char *)&v71 + 6) = v74;
        HIWORD(v71) = 2080;
        *(_QWORD *)v72 = v63;
        *(_WORD *)&v72[8] = 1024;
        *(_DWORD *)&v72[10] = v18;
        _os_log_error_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_ERROR, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/RTPTransport.c:%d: getaddrinfo(%s,%s) failed(%08X)", buf, 0x3Cu);
      }
    }
    goto LABEL_48;
  }
  v16 = v60;
  while (v16->ai_family != v13)
  {
    v16 = v16->ai_next;
    if (!v16)
    {
      ai_family = v60->ai_family;
      goto LABEL_16;
    }
  }
  ai_family = v13;
  v15 = v16;
LABEL_16:
  v21 = VTP_Socket(ai_family, v15->ai_socktype, v15->ai_protocol);
  if (v21 == -1)
  {
    __error();
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RTPCreateSockets_cold_1();
    }
    freeaddrinfo(v60);
    goto LABEL_48;
  }
  v22 = v21;
  v23 = RTPMapPacketMultiplexModeToVTPMode(*v11);
  VTP_SetSocketMode(v22, v23);
  VTP_DetectNAT64Prefix(v22, (const char *)(a2 + 4));
  freeaddrinfo(v60);
  __sprintf_chk(v63, 0, 6uLL, "%u", *(unsigned __int16 *)(a2 + 36));
  v24 = getaddrinfo((const char *)v74, v63, &v61, &v60);
  if (v24 || (v25 = v60) == 0)
  {
    v27 = v24 | 0xB0010000;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v28 = VRTraceErrorLogLevelToCSTR();
      v29 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136316674;
        v65 = v28;
        v66 = 2080;
        v67 = "RTPCreateSockets";
        v68 = 1024;
        v69 = 3853;
        v70 = 1024;
        LODWORD(v71) = 3853;
        WORD2(v71) = 2080;
        *(_QWORD *)((char *)&v71 + 6) = v74;
        HIWORD(v71) = 2080;
        *(_QWORD *)v72 = v63;
        *(_WORD *)&v72[8] = 1024;
        *(_DWORD *)&v72[10] = v27;
        _os_log_error_impl(&dword_1D8A54000, v29, OS_LOG_TYPE_ERROR, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/RTPTransport.c:%d: getaddrinfo(%s,%s) failed(%08X)", buf, 0x3Cu);
      }
    }
    goto LABEL_47;
  }
  v26 = v60;
  while (v26->ai_family != v13)
  {
    v26 = v26->ai_next;
    if (!v26)
    {
      v13 = v60->ai_family;
      goto LABEL_31;
    }
  }
  v25 = v26;
LABEL_31:
  v30 = VTP_Socket(v13, v25->ai_socktype, v25->ai_protocol);
  if (v30 == -1)
  {
    __error();
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RTPCreateSockets_cold_2();
    }
    freeaddrinfo(v60);
LABEL_47:
    VTP_Close(v22);
LABEL_48:
    CheckOutHandleDebug();
    return;
  }
  v31 = v30;
  v32 = RTPMapPacketMultiplexModeToVTPMode(*v11);
  VTP_SetSocketMode(v31, v32);
  VTP_DetectNAT64Prefix(v31, (const char *)(a2 + 4));
  freeaddrinfo(v60);
  v33 = v11[1];
  if (v33 != -1)
    VTP_Close(v33);
  v34 = v11[2];
  if (v34 != -1)
    VTP_Close(v34);
  v11[1] = v22;
  v11[2] = v31;
  v62 = 128;
  VTP_Getsockname(v22, v73, &v62);
  v62 = 128;
  VTP_Getsockname(v31, v73, &v62);
  if (v11[7])
  {
    VTP_SetPktType(v22, 32);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v35 = VRTraceErrorLogLevelToCSTR();
      v36 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136316162;
        v65 = v35;
        v66 = 2080;
        v67 = "RTPCreateSockets";
        v68 = 1024;
        v69 = 3911;
        v70 = 1024;
        LODWORD(v71) = v22;
        WORD2(v71) = 1024;
        *(_DWORD *)((char *)&v71 + 6) = 32;
        _os_log_impl(&dword_1D8A54000, v36, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTP  vfd (%d) accepts pkt (%04X)", buf, 0x28u);
      }
    }
    VTP_SetPktType(v31, 128);
    if ((int)VRTraceGetErrorLogLevelForModule() < 7)
      goto LABEL_56;
    v37 = VRTraceErrorLogLevelToCSTR();
    v38 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      goto LABEL_56;
    *(_DWORD *)buf = 136316162;
    v65 = v37;
    v66 = 2080;
    v67 = "RTPCreateSockets";
    v68 = 1024;
    v69 = 3914;
    v70 = 1024;
    LODWORD(v71) = v31;
    WORD2(v71) = 1024;
    *(_DWORD *)((char *)&v71 + 6) = 128;
  }
  else
  {
    VTP_SetPktType(v22, 272);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v39 = VRTraceErrorLogLevelToCSTR();
      v40 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136316162;
        v65 = v39;
        v66 = 2080;
        v67 = "RTPCreateSockets";
        v68 = 1024;
        v69 = 3904;
        v70 = 1024;
        LODWORD(v71) = v22;
        WORD2(v71) = 1024;
        *(_DWORD *)((char *)&v71 + 6) = 16;
        _os_log_impl(&dword_1D8A54000, v40, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTP  vfd (%d) accepts pkt (%04X)", buf, 0x28u);
      }
    }
    VTP_SetPktType(v31, 64);
    if ((int)VRTraceGetErrorLogLevelForModule() < 7)
      goto LABEL_56;
    v41 = VRTraceErrorLogLevelToCSTR();
    v38 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      goto LABEL_56;
    *(_DWORD *)buf = 136316162;
    v65 = v41;
    v66 = 2080;
    v67 = "RTPCreateSockets";
    v68 = 1024;
    v69 = 3907;
    v70 = 1024;
    LODWORD(v71) = v31;
    WORD2(v71) = 1024;
    *(_DWORD *)((char *)&v71 + 6) = 64;
  }
  _os_log_impl(&dword_1D8A54000, v38, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTCP vfd (%d) accepts pkt (%04X)", buf, 0x28u);
LABEL_56:
  v42 = v11[8];
  v43 = (const void *)*((_QWORD *)v11 + 5);
  if (!v43 || v42 >= 1)
  {
    VTP_SetPayloadList(v22, v42, v43);
    if ((int)VRTraceGetErrorLogLevelForModule() > 6)
    {
      v44 = VRTraceErrorLogLevelToCSTR();
      v45 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v46 = v11[7];
        *(_DWORD *)buf = 136316418;
        v65 = v44;
        v66 = 2080;
        v67 = "RTPCreateSockets";
        v68 = 1024;
        v69 = 3919;
        v70 = 1024;
        LODWORD(v71) = v46;
        WORD2(v71) = 1024;
        *(_DWORD *)((char *)&v71 + 6) = v22;
        WORD5(v71) = 1024;
        HIDWORD(v71) = v31;
        _os_log_impl(&dword_1D8A54000, v45, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTP/RTCP sockets for PayloadType %d are %d and %d", buf, 0x2Eu);
      }
    }
    *a4 = v31;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      v47 = VRTraceErrorLogLevelToCSTR();
      v48 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v49 = v11[1];
        v50 = v11[1208];
        v51 = v11[23];
        *(_DWORD *)buf = 136316674;
        v65 = v47;
        v66 = 2080;
        v67 = "RTPCreateSockets";
        v68 = 1024;
        v69 = 3923;
        v70 = 2048;
        *(_QWORD *)&v71 = a1;
        WORD4(v71) = 1024;
        *(_DWORD *)((char *)&v71 + 10) = v49;
        HIWORD(v71) = 1024;
        *(_DWORD *)v72 = v50;
        *(_WORD *)&v72[4] = 1024;
        *(_DWORD *)&v72[6] = v51;
        _os_log_impl(&dword_1D8A54000, v48, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTPCreateSockets hRTP %p, iSocRTP %d, dwRemoteSSRC %08X cellularUniquetag %d", buf, 0x38u);
      }
    }
    if (v11[22])
    {
      VTP_SetRemoteSSRC(v11[1], v11[1208]);
      VTP_SetRemoteSSRC(v11[2], v11[1208]);
    }
    v52 = v11[23];
    if (v52)
      VTP_SetCellularUniqueTag(v11[1], v52);
    v53 = *((_QWORD *)v11 + 1295);
    if (v53 != 0xFFFFFFFFLL)
    {
      v54 = VTP_SetAFRC(v11[1], v53);
      if (v54)
      {
        v55 = v54;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          v56 = VRTraceErrorLogLevelToCSTR();
          v57 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v58 = v11[1];
            v59 = *((_QWORD *)v11 + 1295);
            *(_DWORD *)buf = 136316674;
            v65 = v56;
            v66 = 2080;
            v67 = "RTPCreateSockets";
            v68 = 1024;
            v69 = 3940;
            v70 = 1024;
            LODWORD(v71) = v55;
            WORD2(v71) = 2048;
            *(_QWORD *)((char *)&v71 + 6) = a1;
            HIWORD(v71) = 1024;
            *(_DWORD *)v72 = v58;
            *(_WORD *)&v72[4] = 2048;
            *(_QWORD *)&v72[6] = v59;
            _os_log_impl(&dword_1D8A54000, v57, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTPCreateSocket:VTP_SetAFRC failed with %d for hRTP/iSocRTP: %p/%d hAFRC %p ", buf, 0x3Cu);
          }
        }
      }
    }
    if (v11 < v11 + 6904)
    {
      RTPSetDefaultCNAME((uint64_t)v11, a3, a5);
      goto LABEL_48;
    }
  }
  __break(0x5519u);
}

uint64_t RTPSetMediaQueue(double a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;

  v5 = CheckInHandleDebug();
  if (!v5)
    return 2147549186;
  v6 = v5;
  *(_QWORD *)(v5 + 10352) = a3;
  if (!*(_DWORD *)(v5 + 28))
  {
    MediaQueue_SetThrottlingAudioInterval(a1);
    MediaQueue_SetThrottlingIsIPv6(*(_QWORD *)(v6 + 10352), *(_DWORD *)(v6 + 12) != 0);
  }
  CheckOutHandleDebug();
  return 0;
}

uint64_t RTPSetVCMediaQueue(uint64_t a1, const void *a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2147549186;
  _VCBoundsSafety_ReleaseAssignAndRetain((const void **)(v3 + 10440), a2);
  CheckOutHandleDebug();
  return 0;
}

uint64_t RTPSetStatisticsCollector(uint64_t a1, const void *a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2147549186;
  _VCBoundsSafety_ReleaseAssignAndRetain((const void **)(v3 + 10424), a2);
  CheckOutHandleDebug();
  return 0;
}

uint64_t RTPSetBasebandCongestionDetector(uint64_t a1, const void *a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2147549186;
  _VCBoundsSafety_ReleaseAssignAndRetain((const void **)(v3 + 10432), a2);
  CheckOutHandleDebug();
  return 0;
}

uint64_t RTPSetAFRCHandle(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  NSObject *v10;
  int v11;
  int v13;
  uint64_t v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  int v24;
  __int16 v25;
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v4 = CheckInHandleDebug();
  if (!v4)
    return 2147549186;
  v5 = v4;
  *(_QWORD *)(v4 + 10360) = a2;
  v6 = *(_DWORD *)(v4 + 4);
  if (v6 != -1)
  {
    v7 = VTP_SetAFRC(v6, a2);
    if (v7)
    {
      v8 = v7;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v9 = VRTraceErrorLogLevelToCSTR();
        v10 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v11 = *(_DWORD *)(v5 + 4);
          v13 = 136316674;
          v14 = v9;
          v15 = 2080;
          v16 = "RTPSetAFRCHandle";
          v17 = 1024;
          v18 = 4054;
          v19 = 1024;
          v20 = v8;
          v21 = 2048;
          v22 = a1;
          v23 = 1024;
          v24 = v11;
          v25 = 2048;
          v26 = a2;
          _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTPSetAFRCHandle:VTP_SetAFRC failed with %d for hRTP/iSockRTP: %p/%d  hAFRC %p ", (uint8_t *)&v13, 0x3Cu);
        }
      }
    }
  }
  CheckOutHandleDebug();
  return 0;
}

uint64_t RTPGetAFRCTxInfo(uint64_t a1, _DWORD *a2, _QWORD *a3, _DWORD *a4, _DWORD *a5, _QWORD *a6, _DWORD *a7, _DWORD *a8, _DWORD *a9, _DWORD *a10, BOOL *a11, _DWORD *a12)
{
  uint64_t v19;
  uint64_t v20;

  v19 = CheckInHandleDebug();
  if (!v19)
    return 2147549186;
  v20 = AFRCGetTxInfo(*(_QWORD *)(v19 + 10360), a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
  CheckOutHandleDebug();
  return v20;
}

uint64_t RTPSetAFRCTxCap(uint64_t a1, unsigned int a2)
{
  uint64_t v3;
  uint64_t v4;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2147549186;
  v4 = *(_QWORD *)(v3 + 10360);
  if (v4 != 0xFFFFFFFFLL)
    AFRCSetTxCap(v4, a2);
  CheckOutHandleDebug();
  return 0;
}

uint64_t RTPSetAFRCVideoPaused(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2147549186;
  v4 = *(_QWORD *)(v3 + 10360);
  if (v4 != 0xFFFFFFFFLL)
    AFRCSetVideoPaused(v4, a2);
  CheckOutHandleDebug();
  return 0;
}

uint64_t RTPSetRedundantAudio(uint64_t a1, int a2, int a3)
{
  uint64_t v5;
  uint64_t v6;

  v5 = CheckInHandleDebug();
  if (!v5)
    return 2147549186;
  v6 = MediaQueue_SetRedundantAudio(*(_QWORD *)(v5 + 10352), a2, a3);
  CheckOutHandleDebug();
  return v6;
}

uint64_t RTPGetOWRD(uint64_t a1, double *a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  double OWRD;
  uint64_t v8;
  _OWORD v10[5];
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v2 = 2147549185;
  if (a2)
  {
    v4 = CheckInHandleDebug();
    if (v4)
    {
      v5 = v4;
      v6 = *(_QWORD *)(v4 + 10424);
      if (v6)
      {
        v18 = 0;
        v16 = 0u;
        v17 = 0u;
        v14 = 0u;
        v15 = 0u;
        v12 = 0u;
        v13 = 0u;
        v11 = 0u;
        memset(v10, 0, sizeof(v10));
        VCRateControlGetStatistics(v6, 2, (uint64_t)v10);
        v2 = 0;
        OWRD = *(double *)&v11;
      }
      else
      {
        v8 = *(_QWORD *)(v5 + 10416);
        if (!v8)
        {
          v2 = 2147549188;
          goto LABEL_9;
        }
        v2 = 0;
        OWRD = VCAudioReceiver_GetOWRD(v8);
      }
      *a2 = OWRD;
LABEL_9:
      CheckOutHandleDebug();
      return v2;
    }
    return 2147549186;
  }
  return v2;
}

uint64_t RTPSetOWRD(double a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _WORD v6[10];
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  double v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v2 = CheckInHandleDebug();
  if (v2)
  {
    v3 = *(_QWORD *)(v2 + 10424);
    if (v3)
    {
      memset(&v6[2], 0, 14);
      v13 = 0u;
      v14 = 0u;
      v15 = 0u;
      v16 = 0u;
      v17 = 0u;
      v18 = 0u;
      v19 = 0u;
      v20 = 0u;
      v21 = 0;
      *(_DWORD *)v6 = 7;
      v6[9] = 257;
      v7 = 0x500000000;
      v8 = 0;
      v10 = 0;
      v9 = 0;
      v11 = 0;
      v12 = a1;
      VCRateControlSetStatistics(v3, v6);
    }
    CheckOutHandleDebug();
    return 0;
  }
  else
  {
    v4 = 2147549186;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RTPSetOWRD_cold_1();
    }
  }
  return v4;
}

uint64_t RTPSetAFRCProcessingDelay(uint64_t a1, _WORD *a2, void *a3, double a4, double a5)
{
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unint64_t v12;
  unsigned int v13;
  double v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v18 = 0;
  v16 = 0u;
  v17 = 0u;
  if (!a3)
    return 2147549185;
  v15 = NAN;
  RTPGetOWRD(a1, &v15);
  v9 = vcvtd_n_u64_f64(v15, 0xDuLL);
  if (v15 < 0.0)
    v9 = 0;
  v10 = v9;
  v11 = vcvtd_n_u64_f64(a5 - a4, 0xAuLL);
  if (v11 <= 1)
    v11 = 1;
  if (a4 == 0.0)
    v11 = 0;
  HIDWORD(v17) = v10;
  DWORD1(v17) = v11;
  v12 = MicroToNTP(a5);
  v13 = NTPToMiddle32(v12);
  *a2 = v13 >> 6;
  WORD4(v17) = v13 >> 6;
  VCMediaControlInfoSetInfoUnserialized(a3, (const char *)&v16, 1);
  return 0;
}

uint64_t RTPPackDouble(double a1)
{
  unsigned int v1;

  v1 = vcvtd_n_u64_f64(a1, 0xDuLL);
  if (a1 < 0.0)
    return 0;
  return v1;
}

uint64_t RTPGetAFRCStat(uint64_t a1, double *a2, _DWORD *a3, _DWORD *a4, int *a5, uint64_t a6, _DWORD *a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  float AverageInterarrivalTimeForWindow;

  v13 = 2147549186;
  v14 = CheckInHandleDebug();
  if (v14)
  {
    v15 = v14;
    v16 = *(_QWORD *)(v14 + 10416);
    if (v16)
    {
      AverageInterarrivalTimeForWindow = VCAudioReceiver_GetAverageInterarrivalTimeForWindow(v16);
      v13 = AFRCGetStat(*(_QWORD *)(v15 + 10360), a2, a3, a4, a5, (int)(AverageInterarrivalTimeForWindow * 10000.0), a6, a7);
    }
    else
    {
      v13 = 2147549201;
    }
    CheckOutHandleDebug();
  }
  return v13;
}

uint64_t RTPRecordFrameRate(double a1)
{
  uint64_t v2;

  v2 = CheckInHandleDebug();
  if (!v2)
    return 2147549186;
  *(double *)(v2 + 10368) = a1;
  CheckOutHandleDebug();
  return 0;
}

uint64_t RTPSetAFRCRecvMode(uint64_t a1, int a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2147549186;
  *(_DWORD *)(v3 + 10376) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t RTPRecordKeyFrame(uint64_t a1, char a2, int a3, int a4, int a5)
{
  uint64_t v9;
  uint64_t v10;

  v9 = CheckInHandleDebug();
  if (!v9)
    return 2147549186;
  v10 = AFRCRecordKeyFrame(*(_QWORD *)(v9 + 10360), a2, (unsigned __int16)(*(_WORD *)(v9 + 192) + 1), a3, a4, a5);
  CheckOutHandleDebug();
  return v10;
}

uint64_t RTPGetTimeRefreshFrame(uint64_t a1, _QWORD *a2, _DWORD *a3)
{
  uint64_t v5;
  uint64_t TimeRefreshFrame;
  uint64_t v7;

  v5 = CheckInHandleDebug();
  if (!v5)
    return 2147549186;
  if (*(_QWORD *)(v5 + 10352) == 0xFFFFFFFFLL)
    TimeRefreshFrame = VCMediaQueue_GetTimeRefreshFrame(*(_QWORD *)(v5 + 10440), a2, a3);
  else
    TimeRefreshFrame = MediaQueue_GetTimeRefreshFrame(*(_QWORD *)(v5 + 10352), a2, a3);
  v7 = TimeRefreshFrame;
  CheckOutHandleDebug();
  return v7;
}

uint64_t RTPGetLastEchoedMyTxTS(uint64_t a1, _DWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t EchoedMyTxTS;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = CheckInHandleDebug();
  if (!v3)
    return 2147549186;
  v4 = v3;
  v5 = *(_QWORD *)(v3 + 10424);
  if (v5)
  {
    v20 = 0;
    v18 = 0u;
    v19 = 0u;
    v16 = 0u;
    v17 = 0u;
    v14 = 0u;
    v15 = 0u;
    v12 = 0u;
    v13 = 0u;
    v10 = 0u;
    v11 = 0u;
    v8 = 0u;
    v9 = 0u;
    VCRateControlGetStatistics(v5, 2, (uint64_t)&v8);
    if (a2)
      *a2 = DWORD2(v9);
    EchoedMyTxTS = 0;
  }
  else
  {
    EchoedMyTxTS = AFRCGetLastEchoedMyTxTS(*(_QWORD *)(v4 + 10360), a2);
  }
  CheckOutHandleDebug();
  return EchoedMyTxTS;
}

uint64_t RTPUpdateAudioOnlyRateChange(uint64_t a1, unsigned int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2147549186;
  if (*(_QWORD *)(v3 + 10352) == 0xFFFFFFFFLL)
    v4 = VCMediaQueue_UpdateAudioOnlyRateChange(*(_QWORD *)(v3 + 10440), a2);
  else
    v4 = MediaQueue_UpdateAudioOnlyRateChange(*(_QWORD *)(v3 + 10352), a2);
  v5 = v4;
  CheckOutHandleDebug();
  return v5;
}

uint64_t RTPResetConnectionStats()
{
  uint64_t v0;

  v0 = CheckInHandleDebug();
  if (!v0)
    return 2147549186;
  if (!*(_DWORD *)(v0 + 28))
    AFRCMarkResetCS();
  CheckOutHandleDebug();
  return 0;
}

uint64_t RTPUpdateIsIPv6(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t IsIPv6;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2147549186;
  *(_DWORD *)(v3 + 12) = a2;
  IsIPv6 = MediaQueue_SetThrottlingIsIPv6(*(_QWORD *)(v3 + 10352), a2);
  CheckOutHandleDebug();
  return IsIPv6;
}

uint64_t RTPGetIsIPv6(uint64_t a1, BOOL *a2)
{
  uint64_t v3;
  uint64_t v4;

  if (a2)
  {
    v3 = CheckInHandleDebug();
    if (v3)
    {
      *a2 = *(_DWORD *)(v3 + 12) != 0;
      CheckOutHandleDebug();
      return 0;
    }
    else
    {
      v4 = 2147549186;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          RTPGetIsIPv6_cold_2();
          return 2147549186;
        }
      }
    }
  }
  else
  {
    v4 = 2147549185;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RTPGetIsIPv6_cold_1();
    }
  }
  return v4;
}

uint64_t RTPUpdateConstantTransportOverhead(uint64_t a1, int a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2147549186;
  *(_DWORD *)(v3 + 27600) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t RTPMarkSpecialVideoFlush(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t result;
  uint64_t v9;

  v5 = CheckInHandleDebug();
  if (!v5)
    return 2147549186;
  v6 = v5;
  v7 = v5 + 27616;
  result = AFRCMarkSpecialVideoFlush(*(_QWORD *)(v5 + 10360), a2, a3);
  if (v6 < v7)
  {
    v9 = result;
    _RTPMarkSpecialVCRCVideoFlush(v6, a3);
    CheckOutHandleDebug();
    return v9;
  }
  __break(0x5519u);
  return result;
}

uint64_t _RTPMarkSpecialVCRCVideoFlush(uint64_t a1, int a2)
{
  uint64_t result;
  int v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  int v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  result = *(_QWORD *)(a1 + 10424);
  if (result)
  {
    v5 = 0;
    v4 = 0;
    v6 = 0;
    v9 = 0u;
    v10 = 0u;
    v11 = 0u;
    v12 = 0u;
    v13 = 0u;
    v14 = 0u;
    v15 = 0u;
    v16 = 0u;
    v17 = 0u;
    v18 = 0u;
    v19 = 0;
    v3 = 10;
    v7 = 2;
    v8 = a2;
    return VCRateControlSetStatistics(result, &v3);
  }
  return result;
}

uint64_t RTPLogMQFlushedPackets(uint64_t a1, char a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2147549186;
  AFRCLogMQFlushedPackets(*(_QWORD *)(v3 + 10360), a2);
  CheckOutHandleDebug();
  return 0;
}

uint64_t RTPFlushBaseband(int a1, int a2, int a3, unsigned __int16 a4, int a5, int a6, _WORD *a7)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  __CFDictionary *Mutable;
  unsigned int v19;
  int v20;
  uint64_t v21;
  uint64_t i;
  int v23;
  unint64_t v24;
  int *v25;
  CFNumberRef v27;
  CFNumberRef v28;
  CFNumberRef v29;
  CFNumberRef v30;
  CFNumberRef v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  NSObject *v35;
  const char *v36;
  uint64_t v37;
  const char *v38;
  _WORD *v39;
  unint64_t v40;
  int v41;
  const __CFAllocator *allocator;
  __CFArray *theArray;
  unsigned int v44;
  char valuePtr;
  unsigned __int8 v46;
  unsigned __int16 v47;
  int v48;
  uint8_t buf[4];
  uint64_t v50;
  __int128 v51;
  _BYTE v52[172];
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v48 = a3;
  v47 = a4;
  v12 = CheckInHandleDebug();
  if (!v12)
    return 2147549186;
  v16 = v12;
  v41 = a1;
  if (a2 && *(_DWORD *)(v12 + 28) == 1)
    MediaQueue_ThrottlingFlushThrottlingQueue();
  Mutable = (__CFDictionary *)(v16 + 27616);
  v46 = -86;
  if (*(_BYTE *)(v16 + 10380))
  {
    if (a5)
    {
      AFRCMarkSpecialAudioFlush(*(_QWORD *)(v16 + 10360), a6);
      if (v16 >= (unint64_t)Mutable)
        goto LABEL_49;
      _RTPMarkSpecialVCRCAudioFlush(v16, a6);
    }
    else
    {
      if ((int)*MEMORY[0x1E0CF2740] >= 5)
      {
        if (*(_DWORD *)(v16 + 28) == 1)
          v38 = "PT_VIDEO";
        else
          v38 = "PT_AUDIO";
        StallModeTracePrint_(5, (uint64_t)"", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/RTPTransport.c", 4598, "RTPFlushBaseband flush from non-MQ sources for %s ", v13, v14, v15, (char)v38);
      }
      if (!*(_DWORD *)(v16 + 28))
        goto LABEL_41;
    }
  }
  theArray = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  if (!theArray)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        goto LABEL_50;
    }
    goto LABEL_41;
  }
  v39 = a7;
  v40 = v16 + 27616;
  do
    v19 = __ldxr((unsigned int *)&RTPFlushBaseband_s_iTransactionID);
  while (__stxr(v19 + 1, (unsigned int *)&RTPFlushBaseband_s_iTransactionID));
  v20 = 1;
  v46 = 1;
  if (*(_DWORD *)(v16 + 28) || (v20 = *(_DWORD *)(v16 + 48), v20 >= 1))
  {
    v21 = 0;
    allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    for (i = v20; i; --i)
    {
      if (*(_DWORD *)(v16 + 28))
      {
        LOBYTE(v23) = *(_BYTE *)(v16 + 17) & 0x7F;
      }
      else
      {
        v24 = *(_QWORD *)(v16 + 56);
        v25 = (int *)(v24 + v21);
        if (v24 + v21 >= v24 + 4 * *(int *)(v16 + 48) || (unint64_t)v25 < v24)
          goto LABEL_49;
        v23 = *v25;
      }
      Mutable = CFDictionaryCreateMutable(allocator, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      valuePtr = v23;
      v27 = CFNumberCreate(0, kCFNumberSInt8Type, &valuePtr);
      CFDictionaryAddValue(Mutable, CFSTR("transportSessionBasebandQueueFlushPayloadType"), v27);
      CFRelease(v27);
      v28 = CFNumberCreate(0, kCFNumberSInt8Type, &v46);
      CFDictionaryAddValue(Mutable, CFSTR("transportSessionBasebandQueueFlushPayloadTypeFieldOffset"), v28);
      CFRelease(v28);
      *(_WORD *)buf = RTPFlushBaseband_s_iTransactionID;
      v29 = CFNumberCreate(0, kCFNumberSInt16Type, buf);
      CFDictionaryAddValue(Mutable, CFSTR("transportSessionBasebandQueueFlushTransactionID"), v29);
      CFRelease(v29);
      v30 = CFNumberCreate(0, kCFNumberSInt16Type, &v47);
      CFDictionaryAddValue(Mutable, CFSTR("transportSessionBasebandQueueFlushCriterion"), v30);
      CFRelease(v30);
      v31 = CFNumberCreate(0, kCFNumberSInt32Type, &v48);
      CFDictionaryAddValue(Mutable, CFSTR("transportSessionBasebandQueueFlushTimestamp"), v31);
      CFRelease(v31);
      CFArrayAppendValue(theArray, Mutable);
      CFRelease(Mutable);
      v21 += 4;
    }
  }
  v44 = 1;
  v32 = (*(uint64_t (**)(uint64_t, _QWORD, __CFArray *, unsigned int *))(v16 + 10384))(3, *(_QWORD *)(v16 + 10392), theArray, &v44);
  CFRelease(theArray);
  if (v32 < 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      Mutable = (__CFDictionary *)*MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RTPFlushBaseband_cold_2();
    }
    AFRCCancelFlush();
    if (v16 < v40)
    {
LABEL_42:
      v37 = *(_QWORD *)(v16 + 10424);
      if (v37)
      {
        v51 = 0uLL;
        v50 = 0;
        memset(v52, 0, sizeof(v52));
        *(_DWORD *)buf = 10;
        VCRateControlSetStatistics(v37, buf);
      }
      goto LABEL_44;
    }
    do
    {
LABEL_49:
      __break(0x5519u);
LABEL_50:
      RTPFlushBaseband_cold_1();
LABEL_41:
      AFRCCancelFlush();
    }
    while (v16 >= (unint64_t)Mutable);
    goto LABEL_42;
  }
  if (v44 >= 2)
  {
    AFRCMarkAdditionalFlushes(*(_QWORD *)(v16 + 10360), v44 - 1);
    if (v16 < v40)
    {
      v33 = *(_QWORD *)(v16 + 10424);
      if (v33)
      {
        *(_QWORD *)&v51 = 0;
        v50 = 0;
        *((_QWORD *)&v51 + 1) = 0x100000000;
        memset(&v52[4], 0, 168);
        *(_DWORD *)buf = 10;
        *(_DWORD *)v52 = v44 - 1;
        VCRateControlSetStatistics(v33, buf);
      }
      goto LABEL_32;
    }
    goto LABEL_49;
  }
LABEL_32:
  if (v39)
    *v39 = RTPFlushBaseband_s_iTransactionID;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v34 = VRTraceErrorLogLevelToCSTR();
    v35 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v36 = "video";
      if (!*(_DWORD *)(v16 + 28))
        v36 = "audio";
      *(_DWORD *)buf = 136316674;
      v50 = v34;
      LOWORD(v51) = 2080;
      *(_QWORD *)((char *)&v51 + 2) = "RTPFlushBaseband";
      WORD5(v51) = 1024;
      HIDWORD(v51) = 4691;
      *(_WORD *)v52 = 1024;
      *(_DWORD *)&v52[2] = v41;
      *(_WORD *)&v52[6] = 1024;
      *(_DWORD *)&v52[8] = v47;
      *(_WORD *)&v52[12] = 2080;
      *(_QWORD *)&v52[14] = v36;
      *(_WORD *)&v52[22] = 1024;
      *(_DWORD *)&v52[24] = v46;
      _os_log_impl(&dword_1D8A54000, v35, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d RTP(%08X) flushes baseband: OP(%u) PL(%s) Offset(%u) ", buf, 0x38u);
    }
  }
LABEL_44:
  CheckOutHandleDebug();
  return 0;
}

uint64_t _RTPMarkSpecialVCRCAudioFlush(uint64_t a1, int a2)
{
  uint64_t result;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  result = *(_QWORD *)(a1 + 10424);
  if (result)
  {
    v5 = 0;
    v4 = 0;
    v6 = 0x300000000;
    v9 = 0u;
    v10 = 0u;
    v11 = 0u;
    v12 = 0u;
    v13 = 0u;
    v14 = 0u;
    v15 = 0u;
    v16 = 0u;
    v17 = 0u;
    v18 = 0u;
    v3 = 10;
    v7 = 0;
    v8 = a2;
    return VCRateControlSetStatistics(result, &v3);
  }
  return result;
}

uint64_t RTPFlushBaseband_SpecialMQAudioTS(int a1, int a2, int a3, _WORD *a4)
{
  char v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v4 = a2;
  v8 = RTPFlushBaseband(a1, 0, a2, 2u, 1, a3, a4);
  if ((int)*MEMORY[0x1E0CF2740] >= 5)
    StallModeTracePrint_(5, (uint64_t)"", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/RTPTransport.c", 4711, "RTPFlushBaseband_SpecialMQAudioTS: issuing special AUDIO FLUSH TS %d ID: %d rate: %d ", v5, v6, v7, v4);
  return v8;
}

uint64_t RTPSetCellularAudioStallState(uint64_t a1, int a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v4 = CheckInHandleDebug();
  if (!v4)
    return 2147549186;
  v5 = v4;
  v6 = v4 + 27616;
  if (a2 && *(_DWORD *)(v4 + 28) == 1)
  {
    v13 = 0;
    result = AFRCGetKeyFrameTimestamp(*(_QWORD *)(v4 + 10360), &v13);
    if (v5 >= v6)
      goto LABEL_20;
    v8 = *(_QWORD *)(v5 + 10424);
    if (v8)
    {
      v26 = 0;
      v24 = 0u;
      v25 = 0u;
      v22 = 0u;
      v23 = 0u;
      v20 = 0u;
      v21 = 0u;
      v18 = 0u;
      v19 = 0u;
      v16 = 0u;
      v17 = 0u;
      v14 = 0u;
      v15 = 0u;
      VCRateControlGetStatistics(v8, 10, (uint64_t)&v14);
      if (DWORD2(v15) == 4)
        v13 = v18;
    }
    RTPFlushBaseband(a1, 1, v13, 1u, 0, 0, 0);
    AFRCMarkSpecialVideoFlush(*(_QWORD *)(v5 + 10360), 0, 0);
    _RTPMarkSpecialVCRCVideoFlush(v5, 0);
  }
  *(_BYTE *)(v5 + 10380) = a2;
  if (*(_DWORD *)(v5 + 28))
  {
LABEL_10:
    v9 = 0;
LABEL_18:
    CheckOutHandleDebug();
    return v9;
  }
  result = AFRCMarkSpecialAudioFlush(*(_QWORD *)(v5 + 10360), 0);
  if (v5 < v6)
  {
    _RTPMarkSpecialVCRCAudioFlush(v5, 0);
    v10 = *(_QWORD *)(v5 + 10352);
    if (v10 == 0xFFFFFFFFLL)
    {
      v12 = *(_QWORD *)(v5 + 10440);
      if (!v12)
        goto LABEL_10;
      v11 = VCMediaQueue_SetAudioStallBasebandFlushState(v12, a2, a1);
    }
    else
    {
      v11 = MediaQueue_SetCellularAudioStallState(v10, a2);
    }
    v9 = v11;
    goto LABEL_18;
  }
LABEL_20:
  __break(0x5519u);
  return result;
}

uint64_t RTPGetAFRCProbeSeqId(uint64_t a1, unint64_t a2, int a3, int a4, int a5, _DWORD *a6, _WORD *a7, int *a8, _BYTE *a9, int *a10)
{
  uint64_t result;
  __int16 v12;
  unsigned int v17;
  int v18;
  unsigned int v19;
  unint64_t v20;
  uint64_t v21;
  _BYTE *v22;
  unsigned int v23;
  unsigned int *v24;
  BOOL v25;
  unsigned int v27;
  uint64_t v28;
  NSObject *v29;
  NSObject *v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  __int16 v39;
  const char *v40;
  __int16 v41;
  int v42;
  __int16 v43;
  int v44;
  __int16 v45;
  int v46;
  __int16 v47;
  unsigned int v48;
  __int16 v49;
  int v50;
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  *a9 = 0;
  *a10 = 0;
  if (a3 < 12)
    return 2147549192;
  v12 = *(_WORD *)a2;
  if ((*(_WORD *)a2 & 0xC0) != 0x80)
    return 2147549193;
  result = 0;
  v17 = *(_DWORD *)(a2 + 4);
  if (a4)
    v18 = 48;
  else
    v18 = 28;
  v19 = *(unsigned __int16 *)(a2 + 2);
  *a6 = v18 + a3;
  *a7 = bswap32(v19) >> 16;
  *a8 = bswap32(v17);
  if (a1 != 0xFFFFFFFFLL && a5 && (v12 & 0x10) != 0)
  {
    v20 = a2 + a3;
    v21 = 4 * (v12 & 0xF);
    v22 = (_BYTE *)(v21 + a2 + 12);
    if ((unint64_t)v22 >= v20 || (unint64_t)v22 < a2)
      goto LABEL_42;
    result = VCMediaControlInfoRTPExtensionVersionIsValid(*v22 >> 6);
    if ((result & 1) == 0)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          RTPGetAFRCProbeSeqId_cold_2();
      }
      return 2147549227;
    }
    if (v21 + a2 + 13 >= v20 || (unint64_t)a3 - (v21 + 14) < 2)
      goto LABEL_42;
    v23 = bswap32(*(unsigned __int16 *)(v21 + a2 + 14)) >> 16;
    if (a3 + (int)v21 - 12 < v23)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          RTPGetAFRCProbeSeqId_cold_1();
      }
      return 2147549227;
    }
    if ((*(_BYTE *)(v21 + a2 + 13) & 8) == 0)
      return 0;
    v24 = (unsigned int *)&v22[4 * (v23 - 1) + 4];
    v25 = v20 >= (unint64_t)v24 && (unint64_t)v24 >= a2;
    if (!v25 || v20 - (unint64_t)v24 < 4)
    {
LABEL_42:
      __break(0x5519u);
      return result;
    }
    v27 = *v24;
    *a10 = bswap32(*v24);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v28 = VRTraceErrorLogLevelToCSTR();
      v29 = *MEMORY[0x1E0CF2758];
      v30 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
        {
          v31 = *a8;
          v32 = (unsigned __int16)*a7;
          v33 = *a10;
          v37 = 136316674;
          v38 = v28;
          v39 = 2080;
          v40 = "RTPGetAFRCProbeSeqId";
          v41 = 1024;
          v42 = 4862;
          v43 = 1024;
          v44 = v31;
          v45 = 1024;
          v46 = v32;
          v47 = 1024;
          v48 = v27;
          v49 = 1024;
          v50 = v33;
          _os_log_impl(&dword_1D8A54000, v29, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d \t\t RTPGetAFRCProbeSeqId for VP %d/%d: net %x   id %d \n ", (uint8_t *)&v37, 0x34u);
        }
      }
      else if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
      {
        v34 = *a8;
        v35 = (unsigned __int16)*a7;
        v36 = *a10;
        v37 = 136316674;
        v38 = v28;
        v39 = 2080;
        v40 = "RTPGetAFRCProbeSeqId";
        v41 = 1024;
        v42 = 4862;
        v43 = 1024;
        v44 = v34;
        v45 = 1024;
        v46 = v35;
        v47 = 1024;
        v48 = v27;
        v49 = 1024;
        v50 = v36;
        _os_log_debug_impl(&dword_1D8A54000, v29, OS_LOG_TYPE_DEBUG, " [%s] %s:%d \t\t RTPGetAFRCProbeSeqId for VP %d/%d: net %x   id %d \n ", (uint8_t *)&v37, 0x34u);
      }
    }
    result = 0;
    *a9 = 1;
  }
  return result;
}

uint64_t RTPNotifyAFRCRxEstimate(uint64_t a1, uint64_t a2, unint64_t a3, int a4, int a5, double a6)
{
  uint64_t v9;
  unsigned __int8 v11;
  uint64_t v12;
  unsigned __int16 v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = 0;
  v13 = 0;
  v12 = 0;
  v11 = 0;
  if (a4 < 0)
    __break(0x5519u);
  v9 = RTPGetAFRCProbeSeqId(a1, a3, a4, a5 != 0, a2 == 1, &v14, &v13, (int *)&v12 + 1, &v11, (int *)&v12);
  if (!(_DWORD)v9)
    AFRCCalcRxEstimate(a6, a1, a2, HIDWORD(v12), v13, v14, v11, v12);
  return v9;
}

uint64_t RTPInsertAFRCProbeSeqId(int *a1, unsigned int a2, int a3)
{
  uint64_t v6;
  int *v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int *v11;
  int *v12;
  BOOL v13;
  int *v14;
  size_t v15;
  BOOL v16;
  BOOL v17;
  BOOL v18;
  uint64_t v19;
  NSObject *v20;
  NSObject *v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  int v25;
  char Version;
  char v27;
  int *v28;
  unint64_t v29;
  int *v30;
  size_t v31;
  char v32;
  int *v33;
  int *v34;
  char *v35;
  int *v36;
  uint64_t v37;
  NSObject *v38;
  NSObject *v39;
  unsigned int v40;
  unsigned int v41;
  int v42;
  int v43;
  int v44;
  unsigned int v46;
  unsigned int v47;
  int v48;
  int v49;
  unsigned int v50;
  unsigned int v51;
  int v52;
  int v53;
  unsigned int v54;
  uint8_t buf[4];
  uint64_t v56;
  __int16 v57;
  const char *v58;
  __int16 v59;
  int v60;
  __int16 v61;
  unsigned int v62;
  __int16 v63;
  unsigned int v64;
  __int16 v65;
  int v66;
  __int16 v67;
  int v68;
  __int16 v69;
  unsigned int v70;
  uint64_t v71;

  v71 = *MEMORY[0x1E0C80C00];
  if (a3)
    v6 = 4;
  else
    v6 = 0;
  v7 = a1 + 376;
  v8 = v6 + 4 * (a1[376] & 0xF) + 12;
  v9 = *((_QWORD *)a1 + 198);
  if (v9)
  {
    v10 = v8 + VCMediaControlInfoGetSize(v9);
    v11 = a1 + 1;
    v12 = (int *)((char *)a1 + v10 + 4);
    v13 = v12 > v7 || v11 > v12;
    if (v13
      || ((v14 = v12 + 1, v15 = *a1 - (uint64_t)v10, (char *)v7 - (char *)v12 >= v15) ? (v16 = v14 > v7) : (v16 = 1),
          !v16 ? (v17 = v11 > v14) : (v17 = 1),
          !v17 ? (v18 = (char *)v7 - (char *)(v12 + 1) >= v15) : (v18 = 0),
          !v18))
    {
LABEL_52:
      __break(0x5519u);
    }
    memmove(v14, v12, v15);
    v54 = bswap32(a2);
    VCMediaControlInfoSetInfo(*((void **)a1 + 198), (const char *)8, (uint64_t)&v54, 4);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v19 = VRTraceErrorLogLevelToCSTR();
      v20 = *MEMORY[0x1E0CF2758];
      v21 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          v22 = bswap32(a1[377]);
          v23 = bswap32(*((unsigned __int16 *)a1 + 753));
          v24 = *a1;
          v25 = *((unsigned __int8 *)a1 + 1576);
          *(_DWORD *)buf = 136316930;
          v56 = v19;
          v57 = 2080;
          v58 = "RTPInsertAFRCProbeSeqId";
          v59 = 1024;
          v60 = 4930;
          v61 = 1024;
          v62 = v22;
          v63 = 1024;
          v64 = HIWORD(v23);
          v65 = 1024;
          v66 = v24;
          v67 = 1024;
          v68 = v25;
          v69 = 1024;
          v70 = a2;
          _os_log_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d INSERT: ^^^^^^ MP %d/%d/%d P: %d  PROBE_id: %d", buf, 0x3Au);
        }
      }
      else if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
      {
        v46 = bswap32(a1[377]);
        v47 = bswap32(*((unsigned __int16 *)a1 + 753));
        v48 = *a1;
        v49 = *((unsigned __int8 *)a1 + 1576);
        *(_DWORD *)buf = 136316930;
        v56 = v19;
        v57 = 2080;
        v58 = "RTPInsertAFRCProbeSeqId";
        v59 = 1024;
        v60 = 4930;
        v61 = 1024;
        v62 = v46;
        v63 = 1024;
        v64 = HIWORD(v47);
        v65 = 1024;
        v66 = v48;
        v67 = 1024;
        v68 = v49;
        v69 = 1024;
        v70 = a2;
        _os_log_debug_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_DEBUG, " [%s] %s:%d INSERT: ^^^^^^ MP %d/%d/%d P: %d  PROBE_id: %d", buf, 0x3Au);
      }
    }
    v44 = 4;
    if (a3)
      goto LABEL_46;
  }
  else
  {
    Version = VCMediaControlInfoGetVersion(0);
    v27 = *((_BYTE *)a1 + 1620);
    *((_WORD *)a1 + 752) |= 0x10u;
    v28 = a1 + 1;
    v29 = (unint64_t)a1 + v6 + 4;
    if (v29 > (unint64_t)v7)
      goto LABEL_52;
    if ((unint64_t)v28 > v29)
      goto LABEL_52;
    if ((unint64_t)v7 - v29 < 0xC)
      goto LABEL_52;
    *(_QWORD *)v29 = *(_QWORD *)v7;
    *(_DWORD *)(v29 + 8) = v7[2];
    v30 = (int *)((char *)v28 + v8);
    if (v7 < v30)
      goto LABEL_52;
    if (v28 > v30)
      goto LABEL_52;
    v31 = *a1 - v8;
    if ((char *)v7 - (char *)v30 < v31)
      goto LABEL_52;
    v32 = Version;
    v33 = (int *)((char *)v28 + (v8 + 8));
    if (v33 > v7)
      goto LABEL_52;
    if (v28 > v33)
      goto LABEL_52;
    if ((char *)v7 - (char *)v33 < v31)
      goto LABEL_52;
    memmove(v33, (char *)v28 + v8, v31);
    if (v30 >= v7)
      goto LABEL_52;
    *(_BYTE *)v30 = v27 & 0xF | (v32 << 6);
    v34 = (int *)((char *)v28 + (v8 | 1));
    if (v34 >= v7)
      goto LABEL_52;
    if (v34 < v28)
      goto LABEL_52;
    *(_BYTE *)v34 = v27 & 0xF0 | 8;
    v35 = (char *)v28 + (v8 | 2);
    if ((unint64_t)((char *)v7 - v35) < 2)
      goto LABEL_52;
    *(_WORD *)v35 = 256;
    v36 = (int *)((char *)v28 + (v8 + 4));
    if (v7 < v36 || (unint64_t)((char *)v7 - (char *)v36) < 4)
      goto LABEL_52;
    *v36 = bswap32(a2);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v37 = VRTraceErrorLogLevelToCSTR();
      v38 = *MEMORY[0x1E0CF2758];
      v39 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
        {
          v40 = bswap32(a1[377]);
          v41 = bswap32(*((unsigned __int16 *)a1 + 753));
          v42 = *a1;
          v43 = *((unsigned __int8 *)a1 + 1576);
          *(_DWORD *)buf = 136316930;
          v56 = v37;
          v57 = 2080;
          v58 = "RTPInsertAFRCProbeSeqId";
          v59 = 1024;
          v60 = 4980;
          v61 = 1024;
          v62 = v40;
          v63 = 1024;
          v64 = HIWORD(v41);
          v65 = 1024;
          v66 = v42;
          v67 = 1024;
          v68 = v43;
          v69 = 1024;
          v70 = a2;
          _os_log_impl(&dword_1D8A54000, v38, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d INSERT: ^^^^^^ MP %d/%d/%d P: %d  PROBE_id: %d ", buf, 0x3Au);
        }
      }
      else if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
      {
        v50 = bswap32(a1[377]);
        v51 = bswap32(*((unsigned __int16 *)a1 + 753));
        v52 = *a1;
        v53 = *((unsigned __int8 *)a1 + 1576);
        *(_DWORD *)buf = 136316930;
        v56 = v37;
        v57 = 2080;
        v58 = "RTPInsertAFRCProbeSeqId";
        v59 = 1024;
        v60 = 4980;
        v61 = 1024;
        v62 = v50;
        v63 = 1024;
        v64 = HIWORD(v51);
        v65 = 1024;
        v66 = v52;
        v67 = 1024;
        v68 = v53;
        v69 = 1024;
        v70 = a2;
        _os_log_debug_impl(&dword_1D8A54000, v38, OS_LOG_TYPE_DEBUG, " [%s] %s:%d INSERT: ^^^^^^ MP %d/%d/%d P: %d  PROBE_id: %d ", buf, 0x3Au);
      }
    }
    v44 = 8;
    if (a3)
LABEL_46:
      *((_WORD *)a1 + 3) = bswap32(v44 + (bswap32(*((unsigned __int16 *)a1 + 3)) >> 16)) >> 16;
  }
  *a1 += v44;
  return 1;
}

uint64_t RTPSetWRMMetricConfig(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  pthread_mutex_t *v9;
  uint64_t v10;
  int v12;
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v2 = 2147549185;
  if (a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v4 = VRTraceErrorLogLevelToCSTR();
      v5 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v6 = *a2;
        v12 = 136315906;
        v13 = v4;
        v14 = 2080;
        v15 = "RTPSetWRMMetricConfig";
        v16 = 1024;
        v17 = 5013;
        v18 = 1024;
        v19 = v6;
        _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d WRM: Set metric reportInterval=%d", (uint8_t *)&v12, 0x22u);
      }
    }
    v7 = CheckInHandleDebug();
    if (v7)
    {
      v8 = v7;
      v9 = *(pthread_mutex_t **)(v7 + 10408);
      if (v9)
      {
        pthread_mutex_lock(v9 + 2);
        v10 = *(_QWORD *)(v8 + 10408);
        *(_DWORD *)(v10 + 16) = *a2;
        pthread_mutex_unlock((pthread_mutex_t *)(v10 + 128));
      }
      CheckOutHandleDebug();
      return 0;
    }
    else
    {
      return 2147549186;
    }
  }
  return v2;
}

uint64_t RTPSetWRMMetricsCallback(uint64_t a1, uint64_t a2, __int128 *a3)
{
  uint64_t v5;

  v5 = CheckInHandleDebug();
  if (!v5)
    return 2147549186;
  WRMSetReportingCallback(*(_QWORD *)(v5 + 10408), a2, a3);
  CheckOutHandleDebug();
  return 0;
}

uint64_t RTPSetWRMCallId(uint64_t a1, unsigned int a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2147549186;
  WRMSetCallId(*(_QWORD *)(v3 + 10408), a2);
  CheckOutHandleDebug();
  return 0;
}

uint64_t RTPUpdateWRMInfo(uint64_t a1, int a2, int a3, int a4)
{
  uint64_t v7;
  uint64_t v8;
  int v9;
  _DWORD *v10;

  v7 = CheckInHandleDebug();
  if (!v7)
    return 2147549186;
  v8 = v7;
  *(_DWORD *)(*(_QWORD *)(v7 + 10408) + 44) = *(_DWORD *)(*(_QWORD *)(v7 + 10408) + 20);
  v9 = Middle32ToMilliSeconds(a2);
  v10 = *(_DWORD **)(v8 + 10408);
  v10[12] = v9;
  v10[13] = a3;
  v10[22] = a4;
  CheckOutHandleDebug();
  return 0;
}

uint64_t RTPSetSendTimestampRate(uint64_t a1, int a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2147549186;
  *(_DWORD *)(v3 + 316) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t RTPProcessMediaControlInfo(uint64_t a1, void *a2, int a3)
{
  uint64_t v5;
  unint64_t v6;
  int v7;
  unsigned __int8 FECFeedbackVersion;
  uint64_t result;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  double v14;
  double *v15;
  char v16;
  uint64_t v17;
  NSObject *v18;
  int v19;
  double v20;
  int v21;
  int v22;
  int v23;
  double v24;
  double v25;
  int32x4_t v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  uint8_t buf[4];
  uint64_t v31;
  __int16 v32;
  const char *v33;
  __int16 v34;
  int v35;
  __int16 v36;
  unsigned int v37;
  __int16 v38;
  int v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  if (!a2)
    return 0;
  v5 = CheckInHandleDebug();
  if (!v5)
    return 2147549186;
  v6 = v5;
  v29 = 0;
  VCMediaControlInfoGetInfo(a2, (const char *)0xB, (uint64_t)&v29 + 4, 4, 0);
  VCMediaControlInfoGetInfo(a2, (const char *)0xC, (uint64_t)&v29, 4, 0);
  v7 = 8 * v29;
  LODWORD(v29) = 8 * v29;
  if (!a3)
  {
    AFRCProcessVideoReceiveMetric(*(_QWORD *)(v6 + 10360), SHIDWORD(v29), v7);
    goto LABEL_36;
  }
  v27 = 0u;
  v28 = 0u;
  v26 = 0u;
  AFRCGenerateFeedbackWithControlInfo(a2, &v26);
  if (*(_QWORD *)(v6 + 10360) == 0xFFFFFFFFLL)
  {
LABEL_36:
    CheckOutHandleDebug();
    return 0;
  }
  FECFeedbackVersion = VCMediaControlInfoGetFECFeedbackVersion(a2);
  result = VCMediaControlInfo_IsLossStatsEnabled(FECFeedbackVersion);
  if (!*(_DWORD *)(v6 + 10336))
  {
    *(_DWORD *)(v6 + 10336) = 1;
    v10 = DWORD2(v27);
    *(_DWORD *)(v6 + 10340) = DWORD2(v27);
    v11 = 0;
    if ((result & 1) == 0)
      *(_DWORD *)(v6 + 10348) = HIDWORD(v27);
    goto LABEL_22;
  }
  if (v6 < v6 + 27616)
  {
    v10 = *(_DWORD *)(v6 + 10340);
    v11 = ((DWORD2(v27) - v10) >> 11) & 1;
    if (((DWORD2(v27) - v10) & 0x800) == 0)
    {
      if ((*(_DWORD *)(v6 + 10340) & 0xFFFu) <= WORD4(v27))
        v12 = *(_DWORD *)(v6 + 10340);
      else
        v12 = v10 + 4096;
      v10 = v12 & 0xFFFFF000 | WORD4(v27);
      *(_DWORD *)(v6 + 10340) = v10;
    }
    DWORD2(v27) = v10;
    if ((result & 1) == 0)
    {
      v13 = *(_DWORD *)(v6 + 10348);
      if (((HIDWORD(v27) - v13) & 0x800) == 0)
      {
        if ((*(_DWORD *)(v6 + 10348) & 0xFFFu) > WORD6(v27))
          v13 += 4096;
        v13 = v13 & 0xFFFFF000 | WORD6(v27);
        *(_DWORD *)(v6 + 10348) = v13;
      }
      HIDWORD(v27) = v13;
    }
LABEL_22:
    v25 = -1.0;
    v14 = -1.0;
    if ((_DWORD)result)
      v14 = 0.0;
    v24 = v14;
    v22 = -1;
    v23 = -1;
    if (v26.i32[1])
    {
      v15 = &v24;
      if ((_DWORD)result)
        v15 = 0;
      MediaQueue_FindPacketInTxHistory(*(_QWORD *)(v6 + 10352), v26.u16[0], v10, 0, v27, (uint64_t)&v23, (uint64_t)&v22, *(_DWORD *)(v6 + 10348), (uint64_t)v15, (uint64_t)&v25, 0);
    }
    v21 = 0;
    VCMediaControlInfoGetInfo(a2, (const char *)0x10, (uint64_t)&v21, 4, 0);
    v20 = 0.0;
    VCMediaControlInfoGetInfo(a2, (const char *)0xA, (uint64_t)&v20, 8, 0);
    v19 = 0;
    VCMediaControlInfoGetInfo(a2, (const char *)0x11, (uint64_t)&v19, 4, 0);
    if (v21)
      v16 = v11;
    else
      v16 = 1;
    if ((v16 & 1) != 0)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v17 = VRTraceErrorLogLevelToCSTR();
        v18 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316162;
          v31 = v17;
          v32 = 2080;
          v33 = "RTPProcessMediaControlInfo";
          v34 = 1024;
          v35 = 5178;
          v36 = 1024;
          v37 = v11;
          v38 = 1024;
          v39 = v21;
          _os_log_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Skip AFRCProcessFeedbackPacket, due to isFeedbackOOO = %d, receivedBytes = %d,", buf, 0x28u);
        }
      }
    }
    else
    {
      AFRCProcessFeedbackPacket(v20, v25, v24, *(_QWORD *)(v6 + 10360), (uint64_t)&v26, v19, SHIDWORD(v29), v29, v23, v22);
    }
    goto LABEL_36;
  }
  __break(0x5519u);
  return result;
}

uint64_t RTPRegisterPacketCallback(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t result;
  unint64_t v10;
  unint64_t v11;
  _DWORD *v12;
  uint64_t v14;
  NSObject *v15;
  int v16;
  int v17;
  uint64_t v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  int v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (a1 == 0xFFFFFFFFLL)
  {
    v8 = 2147549185;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RTPRegisterPacketCallback_cold_1();
    }
    return v8;
  }
  v6 = CheckInHandleDebug();
  if (!v6)
  {
    v8 = 2147549186;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        RTPRegisterPacketCallback_cold_2();
        return 2147549186;
      }
    }
    return v8;
  }
  v7 = v6;
  if (*(_QWORD *)(v6 + 10504))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RTPRegisterPacketCallback_cold_4();
    }
    CheckOutHandleDebug();
    return 2147549233;
  }
  result = (uint64_t)_Block_copy(a3);
  *(_QWORD *)(v7 + 10504) = result;
  if (!result)
  {
    v8 = 2147549188;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        RTPRegisterPacketCallback_cold_3();
        v8 = 2147549188;
      }
    }
    goto LABEL_30;
  }
  *(_QWORD *)(v7 + 10496) = a2;
  v10 = *(unsigned int *)(v7 + 4);
  if (v10 <= 0x3FF)
  {
    *(_OWORD *)(v7 + 10624) = 0u;
    v11 = v7 + 10512;
    *(_OWORD *)(v7 + 10608) = 0u;
    *(_OWORD *)(v7 + 10592) = 0u;
    *(_OWORD *)(v7 + 10576) = 0u;
    *(_OWORD *)(v7 + 10560) = 0u;
    *(_OWORD *)(v7 + 10544) = 0u;
    *(_OWORD *)(v7 + 10528) = 0u;
    *(_OWORD *)(v7 + 10512) = 0u;
    result = __darwin_check_fd_set_overflow(v10, (const void *)(v7 + 10512), 0);
    if ((_DWORD)result)
    {
      v12 = (_DWORD *)(v11 + ((v10 >> 3) & 0x1FFFFFFC));
      if ((unint64_t)v12 >= v7 + 10640 || (unint64_t)v12 < v11)
        goto LABEL_35;
      *v12 |= 1 << v10;
    }
    v8 = 0;
    *(_DWORD *)(v7 + 10488) = VTP_RegisterPacketCallback((_OWORD *)(v7 + 10512), a1, &__block_literal_global_20);
LABEL_30:
    CheckOutHandleDebug();
    return v8;
  }
  if (!*(_QWORD *)(v7 + 11104))
  {
    v8 = 2147549226;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v14 = VRTraceErrorLogLevelToCSTR();
      v15 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v16 = *(_DWORD *)(v7 + 4);
        v17 = 136316162;
        v18 = v14;
        v19 = 2080;
        v20 = "RTPRegisterPacketCallback";
        v21 = 1024;
        v22 = 5230;
        v23 = 2048;
        v24 = a1;
        v25 = 1024;
        v26 = v16;
        _os_log_error_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_ERROR, " [%s] %s:%d RTPHandle[%p], Socket[%d] is invalid", (uint8_t *)&v17, 0x2Cu);
        v8 = 2147549226;
      }
    }
    goto LABEL_30;
  }
  if (v7 < v7 + 27616)
  {
    v8 = _RTPEnsureTransportStreamsActivated(v7);
    goto LABEL_30;
  }
LABEL_35:
  __break(0x5519u);
  return result;
}

uint64_t _RTPEnsureTransportStreamsActivated(uint64_t a1)
{
  _BYTE *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t (*v5)(uint64_t, uint64_t);
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t (*v9)(uint64_t, uint64_t);
  uint64_t v10;
  uint64_t v11;
  uint64_t (*v12)(uint64_t, uint64_t);
  uint64_t v13;
  uint64_t (*v14)(uint64_t);
  uint64_t v15;
  uint64_t (*v16)(uint64_t);
  uint64_t v17;
  uint64_t v18;
  uint64_t (*v19)(uint64_t);

  if (!a1)
  {
    v17 = 2147549185;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _RTPEnsureTransportStreamsActivated_cold_1();
    }
    return v17;
  }
  v2 = (_BYTE *)(a1 + 11101);
  if (*(_BYTE *)(a1 + 11101))
    return 0;
  v3 = *(_QWORD *)(a1 + 11128);
  if (v3)
  {
    v4 = *(_QWORD *)(a1 + 11104);
    v5 = *(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 24);
    if (!v5)
      return 4294954514;
    v6 = v5(v4, v3);
    if ((v6 & 0x80000000) != 0)
      return v6;
  }
  v7 = *(_QWORD *)(a1 + 11136);
  if (v7)
  {
    v8 = *(_QWORD *)(a1 + 11112);
    v9 = *(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 24);
    if (!v9)
      return 4294954514;
    v6 = v9(v8, v7);
    if ((v6 & 0x80000000) != 0)
      return v6;
  }
  if (*(_QWORD *)(a1 + 11120))
  {
    v6 = _RTPSetCellularUniqueTagOnPacketFilters(a1);
    if ((v6 & 0x80000000) != 0)
      return v6;
    v10 = *(_QWORD *)(a1 + 11120);
    v11 = *(_QWORD *)(a1 + 11144);
    v12 = *(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 24);
    if (!v12)
      return 4294954514;
    v6 = v12(v10, v11);
    if ((v6 & 0x80000000) != 0)
      return v6;
  }
  v13 = *(_QWORD *)(a1 + 11104);
  v14 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 56);
  if (!v14)
    return 4294954514;
  v6 = v14(v13);
  if ((v6 & 0x80000000) != 0)
    return v6;
  v15 = *(_QWORD *)(a1 + 11112);
  v16 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 56);
  if (!v16)
    return 4294954514;
  v17 = v16(v15);
  if ((v17 & 0x80000000) != 0)
    return v17;
  v18 = *(_QWORD *)(a1 + 11120);
  if (!v18)
  {
LABEL_20:
    *v2 = 1;
    return v17;
  }
  v19 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 56);
  if (!v19)
    return 4294954514;
  v17 = v19(v18);
  if ((v17 & 0x80000000) == 0)
    goto LABEL_20;
  return v17;
}

unint64_t RTPUnregisterPacketCallback()
{
  unint64_t result;

  result = CheckInHandleDebug();
  if (!result)
    return 2147549186;
  if (!*(_QWORD *)(result + 10504))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RTPUnregisterPacketCallback_cold_1();
    }
    goto LABEL_9;
  }
  if (result < result + 27616)
  {
    _RTPUnregisterPacketCallback(result);
LABEL_9:
    CheckOutHandleDebug();
    return 0;
  }
  __break(0x5519u);
  return result;
}

uint64_t RTPSetTimestampRateScale(uint64_t a1, signed int a2)
{
  uint64_t v3;
  _DWORD *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  int v9;
  int v10;
  int v12;
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  _DWORD *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v3 = CheckInHandleDebug();
  if (!v3)
    return 2147549186;
  v4 = (_DWORD *)v3;
  if (a2 <= 7)
  {
    v5 = dword_1D910B508[a2];
    v6 = qword_1D910B528[a2];
    *(_DWORD *)(v3 + 296) = dword_1D910B4E8[a2];
    *(_DWORD *)(v3 + 300) = v5;
    *(_QWORD *)(v3 + 27608) = v6;
  }
  *(_QWORD *)(v3 + 256) = *(_QWORD *)(v3 + 248);
  *(_QWORD *)(v3 + 240) = *(_QWORD *)(v3 + 232);
  *(_QWORD *)(v3 + 288) = *(_QWORD *)(v3 + 280);
  *(_QWORD *)(v3 + 272) = *(_QWORD *)(v3 + 264);
  if (*(_DWORD *)(v3 + 228) != a2 && (int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v7 = VRTraceErrorLogLevelToCSTR();
    v8 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v9 = v4[74];
      v10 = v4[75];
      v12 = 136316418;
      v13 = v7;
      v14 = 2080;
      v15 = "RTPSetTimestampRateScale";
      v16 = 1024;
      v17 = 5334;
      v18 = 2048;
      v19 = v4;
      v20 = 1024;
      v21 = v9;
      v22 = 1024;
      v23 = v10;
      _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d [%p] Updating the network sample rate shift factors. send[%d] receive[%d]", (uint8_t *)&v12, 0x32u);
    }
  }
  v4[57] = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t RTPCopyPreferredSendQueue(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t CMBaseObject;
  uint64_t (*v7)(uint64_t, const __CFString *, _QWORD, _QWORD *);
  uint64_t v8;
  NSObject *v9;
  const char *v10;
  uint64_t v11;
  int v13;
  uint64_t v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v2 = 2147549185;
  if (a2)
  {
    v4 = CheckInHandleDebug();
    if (v4)
    {
      if (*(_QWORD *)(v4 + 11104))
      {
        CMBaseObject = VCPacketFilterGetCMBaseObject(*(_QWORD *)(v4 + 11104), v5);
        v7 = *(uint64_t (**)(uint64_t, const __CFString *, _QWORD, _QWORD *))(*(_QWORD *)(CMBaseObjectGetVTable()
                                                                                                 + 8)
                                                                                     + 48);
        if (v7)
        {
          v2 = v7(CMBaseObject, CFSTR("PreferredSendQueue"), *MEMORY[0x1E0C9AE00], a2);
          if ((v2 & 0x80000000) == 0)
          {
LABEL_18:
            CheckOutHandleDebug();
            return v2;
          }
        }
        else
        {
          v2 = 4294954514;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() < 5)
          goto LABEL_18;
        v11 = VRTraceErrorLogLevelToCSTR();
        v9 = *MEMORY[0x1E0CF2758];
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          goto LABEL_18;
        v13 = 136315906;
        v14 = v11;
        v15 = 2080;
        v16 = "RTPCopyPreferredSendQueue";
        v17 = 1024;
        v18 = 5379;
        v19 = 1024;
        v20 = v2;
        v10 = " [%s] %s:%d Getting kVCTransportStreamProperty_PreferredSendQueue failed - %x";
      }
      else
      {
        if (!VTP_CopyPreferredSendQueue(*(_DWORD *)(v4 + 4), a2))
        {
          v2 = 0;
          goto LABEL_18;
        }
        v2 = *__error() | 0xC0010000;
        if ((int)VRTraceGetErrorLogLevelForModule() < 5)
          goto LABEL_18;
        v8 = VRTraceErrorLogLevelToCSTR();
        v9 = *MEMORY[0x1E0CF2758];
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          goto LABEL_18;
        v13 = 136315906;
        v14 = v8;
        v15 = 2080;
        v16 = "RTPCopyPreferredSendQueue";
        v17 = 1024;
        v18 = 5387;
        v19 = 1024;
        v20 = v2;
        v10 = " [%s] %s:%d VTP_GetPreferredSendQueue failed - %x";
      }
      _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, v10, (uint8_t *)&v13, 0x22u);
      goto LABEL_18;
    }
    return 2147549186;
  }
  return v2;
}

uint64_t RTPSetTransportStreams(uint64_t a1, const void *a2, const void *a3, const void *a4)
{
  uint64_t v4;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t (*v12)(const void *, _QWORD *);
  uint64_t v13;
  uint64_t (*v14)(const void *, _QWORD *);
  CFNumberRef v15;
  const __CFString *v16;
  const __CFAllocator *v17;
  CFNumberRef v18;
  uint64_t v19;
  uint64_t CMBaseObject;
  uint64_t (*v21)(uint64_t, const __CFString *, CFNumberRef);
  uint64_t (*v22)(const void *, _QWORD *);
  uint64_t v23;
  uint64_t v24;
  uint64_t (*v25)(uint64_t, const __CFString *, const __CFAllocator *, CFBooleanRef *);
  int v26;
  NSObject *v27;
  uint64_t v29;
  _QWORD v30[5];
  _QWORD v31[5];
  _QWORD v32[5];
  CFBooleanRef BOOLean;
  uint8_t buf[4];
  uint64_t v35;
  __int16 v36;
  const char *v37;
  __int16 v38;
  int v39;
  __int16 v40;
  const __CFString *v41;
  __int16 v42;
  int v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (a3)
    {
      v9 = CheckInHandleDebug();
      if (v9)
      {
        v10 = v9;
        if (*(_BYTE *)(v9 + 11101))
        {
          if ((int)VRTraceGetErrorLogLevelForModule() < 3)
          {
            v4 = 2147549233;
          }
          else
          {
            VRTraceErrorLogLevelToCSTR();
            v4 = 2147549233;
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              RTPSetTransportStreams_cold_4();
          }
          goto LABEL_33;
        }
        v11 = MEMORY[0x1E0C809B0];
        v32[0] = MEMORY[0x1E0C809B0];
        v32[1] = 0x40000000;
        v32[2] = __RTPSetTransportStreams_block_invoke;
        v32[3] = &__block_descriptor_tmp_21;
        v32[4] = a1;
        v12 = *(uint64_t (**)(const void *, _QWORD *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 40);
        if (v12)
        {
          v13 = v12(a2, v32);
          if ((v13 & 0x80000000) != 0)
            goto LABEL_49;
          v31[0] = v11;
          v31[1] = 0x40000000;
          v31[2] = __RTPSetTransportStreams_block_invoke_2;
          v31[3] = &__block_descriptor_tmp_22_0;
          v31[4] = a1;
          v14 = *(uint64_t (**)(const void *, _QWORD *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 40);
          if (v14)
          {
            v13 = v14(a3, v31);
            if ((v13 & 0x80000000) == 0)
            {
              v15 = (CFNumberRef)(v10 + 27616);
              v16 = (const __CFString *)(v10 + 11136);
              if (*(_QWORD *)(v10 + 11136))
              {
                v17 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
                goto LABEL_14;
              }
              if (v10 >= (unint64_t)v15)
                goto LABEL_50;
              v17 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
              v13 = VCPacketFilterRTCPCreate(*MEMORY[0x1E0C9AE00], (_QWORD *)(v10 + 11136));
              if ((v13 & 0x80000000) == 0)
              {
LABEL_14:
                if (v10 < (unint64_t)v15)
                {
                  v18 = CFNumberCreate(v17, kCFNumberIntType, (const void *)(v10 + 200));
                  if (!v18)
                  {
                    v4 = 2147549187;
                    goto LABEL_33;
                  }
                  v15 = v18;
                  CMBaseObject = VCPacketFilterGetCMBaseObject(v16->isa, v19);
                  v21 = *(uint64_t (**)(uint64_t, const __CFString *, CFNumberRef))(*(_QWORD *)(CMBaseObjectGetVTable() + 8)
                                                                                           + 56);
                  if (v21)
                  {
                    v4 = v21(CMBaseObject, CFSTR("RTCPLocalSSRC"), v15);
                    if ((v4 & 0x80000000) != 0)
                      goto LABEL_32;
                    if (!a4)
                    {
LABEL_21:
                      _RTPSetTransportStreamReceiveHopLimitEnabled((uint64_t)a2, *(_DWORD *)(v10 + 188) != 0);
                      BOOLean = 0;
                      v16 = CFSTR("IsIPv6");
                      v24 = VCPacketFilterGetCMBaseObject(a2, v23);
                      v25 = *(uint64_t (**)(uint64_t, const __CFString *, const __CFAllocator *, CFBooleanRef *))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 48);
                      if (!v25)
                      {
                        v26 = -12782;
LABEL_26:
                        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                        {
                          v29 = VRTraceErrorLogLevelToCSTR();
                          v27 = *MEMORY[0x1E0CF2758];
                          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                          {
                            *(_DWORD *)buf = 136316162;
                            v35 = v29;
                            v36 = 2080;
                            v37 = "_RTPSetIsIPv6WithTransportStream";
                            v38 = 1024;
                            v39 = 5400;
                            v40 = 2112;
                            v41 = v16;
                            v42 = 1024;
                            v43 = v26;
                            _os_log_error_impl(&dword_1D8A54000, v27, OS_LOG_TYPE_ERROR, " [%s] %s:%d VCTransportStreamCopyProperty %@ failed %d", buf, 0x2Cu);
                          }
                        }
                        goto LABEL_29;
                      }
                      LODWORD(v13) = v25(v24, CFSTR("IsIPv6"), v17, &BOOLean);
                      if ((v13 & 0x80000000) == 0)
                      {
                        *(_DWORD *)(v10 + 12) = CFBooleanGetValue(BOOLean);
LABEL_29:
                        if (BOOLean)
                          CFRelease(BOOLean);
                        _VCBoundsSafety_ReleaseAssignAndRetain((const void **)(v10 + 11104), a2);
                        _VCBoundsSafety_ReleaseAssignAndRetain((const void **)(v10 + 11112), a3);
                        _VCBoundsSafety_ReleaseAssignAndRetain((const void **)(v10 + 11120), a4);
                        goto LABEL_32;
                      }
LABEL_51:
                      v26 = v13;
                      goto LABEL_26;
                    }
                    v30[0] = v11;
                    v30[1] = 0x40000000;
                    v30[2] = __RTPSetTransportStreams_block_invoke_3;
                    v30[3] = &__block_descriptor_tmp_23;
                    v30[4] = a1;
                    v22 = *(uint64_t (**)(const void *, _QWORD *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                           + 40);
                    if (v22)
                    {
                      v4 = v22(a4, v30);
                      if ((v4 & 0x80000000) == 0)
                        goto LABEL_21;
LABEL_32:
                      CFRelease(v15);
                      goto LABEL_33;
                    }
                  }
                  v4 = 4294954514;
                  goto LABEL_32;
                }
LABEL_50:
                __break(0x5519u);
                goto LABEL_51;
              }
            }
LABEL_49:
            v4 = v13;
            goto LABEL_33;
          }
        }
        v4 = 4294954514;
LABEL_33:
        CheckOutHandleDebug();
        return v4;
      }
      v4 = 2147549186;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          RTPSetTransportStreams_cold_3();
          return 2147549186;
        }
      }
    }
    else
    {
      v4 = 2147549185;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          RTPSetTransportStreams_cold_2();
      }
    }
  }
  else
  {
    v4 = 2147549185;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RTPSetTransportStreams_cold_1();
    }
  }
  return v4;
}

void _RTPTransportStreamRTPAndBBNoteCallback(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  _DWORD *v9;
  BOOL v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  _DWORD *v16;
  uint64_t v17;
  NSObject *v18;
  _DWORD *v19;
  uint8_t buf[4];
  uint64_t v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v19 = 0;
  if (!a2)
  {
LABEL_33:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _RTPTransportStreamRTPAndBBNoteCallback_cold_1();
    }
    return;
  }
  v4 = a2;
  v5 = CheckInHandleDebug();
  if (v5)
  {
    v6 = v5;
    v7 = v5 + 27616;
    while (1)
    {
      v8 = *(_QWORD *)(v6 + 10472);
      if (!v8)
        break;
      v9 = VCMemoryPool_Alloc(*(OSQueueHead **)(v6 + 10472));
      if (v9)
        v10 = v9 >= (_DWORD *)((char *)v9 + *(_QWORD *)(v8 + 16));
      else
        v10 = 0;
      if (v10)
        goto LABEL_32;
      v19 = v9;
      if (!v9)
        goto LABEL_28;
      if (a3)
      {
        if (v6 >= v7)
          goto LABEL_32;
        v11 = _RTPTransport_ParseBasebandNotification(v6, v4, v9);
      }
      else
      {
        if (v6 >= v7)
          goto LABEL_32;
        ++*(_QWORD *)(v6 + 336);
        v11 = _RTPTransport_ParseMediaPacket(v6, v4, (uint64_t)v9);
      }
      v12 = v11;
      if (v11 < 0)
      {
        if (v11 != -2147418057 && v11 != -2145255367 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v14 = VRTraceErrorLogLevelToCSTR();
          v15 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315906;
            v21 = v14;
            v22 = 2080;
            v23 = "_RTPTransportStreamRTPAndBBNoteCallback";
            v24 = 1024;
            v25 = 5775;
            v26 = 1024;
            v27 = v12;
            _os_log_error_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_ERROR, " [%s] %s:%d RTP error[%x]", buf, 0x22u);
          }
        }
      }
      else
      {
        v13 = *(_QWORD *)(v6 + 10504);
        if (v13)
        {
          ++*(_QWORD *)(v6 + 344);
          (*(void (**)(uint64_t, _QWORD, _DWORD *))(v13 + 16))(v13, *(_QWORD *)(v6 + 10496), v19);
        }
        else
        {
          v16 = v19;
          *((_QWORD *)v19 + 757) = 0;
          **(_QWORD **)(v6 + 11168) = v16;
          *(_QWORD *)(v6 + 11168) = v19 + 1514;
          v19 = 0;
        }
      }
      _RTPReleaseRTPPacketInternal(v6, &v19);
      v4 = *(_QWORD *)(v4 + 160);
      if (!v4)
        goto LABEL_25;
    }
    v19 = 0;
LABEL_28:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v17 = VRTraceErrorLogLevelToCSTR();
      v18 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        v21 = v17;
        v22 = 2080;
        v23 = "_RTPTransportStreamRTPAndBBNoteCallback";
        v24 = 1024;
        v25 = 5758;
        _os_log_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Failed to allocate RTP packet", buf, 0x1Cu);
      }
    }
    if (v6 < v7)
    {
LABEL_25:
      _RTPReleaseRTPPacketInternal(v6, &v19);
      CheckOutHandleDebug();
      return;
    }
LABEL_32:
    __break(0x5519u);
    goto LABEL_33;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _RTPTransportStreamRTPAndBBNoteCallback_cold_2();
  }
}

uint64_t RTPClearTransportStreams()
{
  _QWORD *v0;
  uint64_t v1;

  v0 = (_QWORD *)CheckInHandleDebug();
  if (v0)
  {
    v1 = _RTPClearTransportStreamsInternal(v0);
    CheckOutHandleDebug();
    return v1;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RTPClearTransportStreams_cold_1();
    }
    return 2147549186;
  }
}

uint64_t RTPGetReceiveStatusWithRunLoop(uint64_t a1, unsigned int *a2, int a3, uint64_t a4)
{
  __int128 v4;
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int *v11;
  uint64_t v12;
  __int128 v13;
  unsigned int *v14;
  uint64_t v15;
  uint64_t v16;
  CFMutableArrayRef Mutable;
  __CFArray *v18;
  uint64_t i;
  const void **v20;
  unsigned int v21;
  uint64_t v22;
  const void *v23;
  uint64_t (*v24)(uint64_t, const void *);
  const void *v25;
  uint64_t (*v26)(uint64_t, const void *);
  const void *v27;
  uint64_t (*v28)(uint64_t, const void *);
  uint64_t (*v29)(uint64_t, double);
  uint64_t v30;
  int Count;
  CFIndex v32;
  uint64_t v33;
  const void *ValueAtIndex;
  void (*v35)(uint64_t, const void *);
  _QWORD *j;
  uint64_t v38;
  char v40;
  _OWORD __src[4];
  unint64_t v42;
  _OWORD v43[9];
  _QWORD v44[4];

  v44[1] = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v43[7] = v4;
  v43[8] = v4;
  v43[5] = v4;
  v43[6] = v4;
  v43[3] = v4;
  v43[4] = v4;
  v43[1] = v4;
  v43[2] = v4;
  v43[0] = v4;
  if (a1)
  {
    if (a2)
    {
      if (a3 <= 0)
      {
        v16 = 2147549185;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            RTPGetReceiveStatusWithRunLoop_cold_3();
        }
      }
      else
      {
        if (a4)
        {
          v6 = a1;
          v8 = 0;
          v38 = a3;
          v9 = a3;
          v10 = 8 * a3;
          v11 = a2;
          do
          {
            v12 = CheckInHandleDebug();
            if ((_QWORD *)((char *)v43 + v8) >= v44 || (_OWORD *)((char *)v43 + v8) < v43)
              goto LABEL_71;
            *(_QWORD *)((char *)v43 + v8) = v12;
            if (!v12)
              *v11 = 0;
            ++v11;
            v8 += 8;
          }
          while (v10 != v8);
          v42 = 0xAAAAAAAAAAAAAAAALL;
          *(_QWORD *)&v13 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
          __src[2] = v13;
          __src[3] = v13;
          __src[0] = v13;
          __src[1] = v13;
          v40 = 0;
          if (a3 < 0x13)
          {
            v14 = a2;
            v15 = _RTPSetReceiveStatusFlags(v43, a2, a3, (unsigned int *)__src, &v40);
            if ((v15 & 0x80000000) != 0)
            {
              v16 = v15;
            }
            else if (v40)
            {
              if ((unint64_t)(4 * v38) > 0x48)
                goto LABEL_71;
              memcpy(a2, __src, 4 * v38);
              v16 = 0;
            }
            else
            {
              Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
              if (Mutable)
              {
                v18 = Mutable;
                for (i = 0; i != v9; ++i)
                {
                  v20 = (const void **)*((_QWORD *)v43 + i);
                  if (v20)
                  {
                    v21 = v14[i];
                    v22 = _RTPEnsureTransportStreamsActivated(*((_QWORD *)v43 + i));
                    if ((v22 & 0x80000000) != 0)
                      goto LABEL_53;
                    if ((v21 & 0x10) != 0)
                    {
                      v23 = v20[1388];
                      if (v23)
                      {
                        v24 = *(uint64_t (**)(uint64_t, const void *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                              + 8);
                        if (!v24)
                          goto LABEL_39;
                        v22 = v24(a4, v23);
                        if ((v22 & 0x80000000) != 0)
                          goto LABEL_53;
                        CFArrayAppendValue(v18, v20[1388]);
                      }
                      v25 = v20[1390];
                      if (v25)
                      {
                        v26 = *(uint64_t (**)(uint64_t, const void *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                              + 8);
                        if (!v26)
                          goto LABEL_39;
                        v22 = v26(a4, v25);
                        if ((v22 & 0x80000000) != 0)
                          goto LABEL_53;
                        CFArrayAppendValue(v18, v20[1390]);
                      }
                    }
                    if ((v21 & 0x20) != 0)
                    {
                      v27 = v20[1389];
                      if (v27)
                      {
                        v28 = *(uint64_t (**)(uint64_t, const void *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16)
                                                                              + 8);
                        if (!v28)
                          goto LABEL_39;
                        v22 = v28(a4, v27);
                        if ((v22 & 0x80000000) != 0)
                        {
LABEL_53:
                          v16 = v22;
                          goto LABEL_40;
                        }
                        CFArrayAppendValue(v18, v20[1389]);
                      }
                    }
                  }
                }
                v29 = *(uint64_t (**)(uint64_t, double))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 24);
                if (v29)
                {
                  v30 = v29(a4, 0.0);
                  if ((v30 & 0x80000000) == 0)
                    v30 = _RTPSetReceiveStatusFlags(v43, v14, a3, v14, 0);
                  v16 = v30;
                }
                else
                {
LABEL_39:
                  v16 = 4294954514;
                }
LABEL_40:
                Count = CFArrayGetCount(v18);
                if (Count >= 1)
                {
                  v32 = 0;
                  v33 = Count;
                  do
                  {
                    ValueAtIndex = CFArrayGetValueAtIndex(v18, v32);
                    v35 = *(void (**)(uint64_t, const void *))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 16);
                    if (v35)
                      v35(a4, ValueAtIndex);
                    ++v32;
                  }
                  while (v33 != v32);
                }
                CFRelease(v18);
              }
              else if ((int)VRTraceGetErrorLogLevelForModule() < 3)
              {
                v16 = 2147549187;
              }
              else
              {
                VRTraceErrorLogLevelToCSTR();
                v16 = 2147549187;
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  RTPGetReceiveStatusWithRunLoop_cold_5();
              }
            }
            for (j = v43; j < v44 && j >= (_QWORD *)v43; ++j)
            {
              if (*j)
                CheckOutHandleDebug();
              v6 += 8;
              if (!--v9)
                return v16;
            }
          }
LABEL_71:
          __break(0x5519u);
        }
        v16 = 2147549185;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            RTPGetReceiveStatusWithRunLoop_cold_4();
        }
      }
    }
    else
    {
      v16 = 2147549185;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          RTPGetReceiveStatusWithRunLoop_cold_2();
      }
    }
  }
  else
  {
    v16 = 2147549185;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RTPGetReceiveStatusWithRunLoop_cold_1();
    }
  }
  return v16;
}

uint64_t _RTPSetReceiveStatusFlags(_QWORD *a1, unsigned int *a2, int a3, unsigned int *a4, _BYTE *a5)
{
  char v5;
  uint64_t v6;
  _QWORD *v7;
  unsigned int v8;
  uint64_t v9;

  if (a1)
  {
    if (a2)
    {
      if (a4)
      {
        if (a3 >= 1)
        {
          v5 = 0;
          v6 = a3;
          while (1)
          {
            v7 = (_QWORD *)*a1;
            if (!*a1)
              goto LABEL_18;
            v8 = *a2;
            *a4 = *a2;
            if ((*a2 & 0x10) == 0 || !v7[1388])
              goto LABEL_11;
            if (v7[1395])
              break;
            v8 &= ~0x10u;
            *a4 = v8;
            if ((*a2 & 0x20) != 0)
            {
LABEL_12:
              if (v7[1389])
              {
                if (v7[1397])
                  v5 = 1;
                else
                  *a4 = v8 & 0xFFFFFFDF;
              }
            }
LABEL_18:
            ++a4;
            ++a2;
            ++a1;
            if (!--v6)
            {
              v9 = 0;
              if (a5)
                *a5 = v5 & 1;
              return v9;
            }
          }
          v5 = 1;
LABEL_11:
          if ((*a2 & 0x20) != 0)
            goto LABEL_12;
          goto LABEL_18;
        }
        v9 = 2147549185;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _RTPSetReceiveStatusFlags_cold_4();
        }
      }
      else
      {
        v9 = 2147549185;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _RTPSetReceiveStatusFlags_cold_3();
        }
      }
    }
    else
    {
      v9 = 2147549185;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _RTPSetReceiveStatusFlags_cold_2();
      }
    }
  }
  else
  {
    v9 = 2147549185;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _RTPSetReceiveStatusFlags_cold_1();
    }
  }
  return v9;
}

double RTPUnpackDouble(unsigned int a1)
{
  double result;

  result = (double)a1 * 0.000122070312;
  if (a1 == 0xFFFF)
    return 0.0;
  return result;
}

uint64_t RTPSetConnectionManager(uint64_t a1, const void *a2)
{
  uint64_t v3;
  uint64_t v4;

  if (a2)
  {
    v3 = CheckInHandleDebug();
    if (v3)
    {
      _VCBoundsSafety_ReleaseAssignAndRetain((const void **)(v3 + 11192), a2);
      CheckOutHandleDebug();
      return 0;
    }
    else
    {
      v4 = 2147549186;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          RTPSetConnectionManager_cold_2();
          return 2147549186;
        }
      }
    }
  }
  else
  {
    v4 = 2147549185;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        RTPSetConnectionManager_cold_1();
    }
  }
  return v4;
}

unint64_t RTPIgnorePacketLossAccounting(uint64_t a1, int a2)
{
  unint64_t result;
  unint64_t v4;
  _BYTE *v5;
  uint64_t v6;
  NSObject *v7;
  int v8;
  uint64_t v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  unint64_t v15;
  __int16 v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  result = CheckInHandleDebug();
  if (!result)
    return 2147549186;
  v4 = result;
  v5 = (_BYTE *)(result + 11100);
  if (*(unsigned __int8 *)(result + 11100) == a2)
  {
LABEL_8:
    CheckOutHandleDebug();
    return 0;
  }
  if (result < result + 27616)
  {
    RTPReset(result, *(_DWORD *)(result + 4832));
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v6 = VRTraceErrorLogLevelToCSTR();
      v7 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v8 = 136316162;
        v9 = v6;
        v10 = 2080;
        v11 = "RTPIgnorePacketLossAccounting";
        v12 = 1024;
        v13 = 6041;
        v14 = 2048;
        v15 = v4;
        v16 = 1024;
        v17 = a2;
        _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Setting RTP(%p) ignorePacketLossAccounting = %d", (uint8_t *)&v8, 0x2Cu);
      }
    }
    *v5 = a2;
    goto LABEL_8;
  }
  __break(0x5519u);
  return result;
}

uint64_t RTPSetVCSecurityKeyHolder(uint64_t a1, const void *a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2147549186;
  _VCBoundsSafety_ReleaseAssignAndRetain((const void **)(v3 + 10448), a2);
  CheckOutHandleDebug();
  return 0;
}

uint64_t RTPGetFramingOverhead(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v4;
  __int16 v5;
  uint64_t v6;

  v2 = 2147549185;
  if (a2)
  {
    v4 = CheckInHandleDebug();
    if (v4)
    {
      v5 = *(_WORD *)(v4 + 16);
      CheckOutHandleDebug();
      v2 = 0;
      v6 = 16;
      if ((v5 & 0x10) == 0)
        v6 = 12;
      *a2 = v6 + 4 * (v5 & 0xF);
    }
    else
    {
      return 2147549186;
    }
  }
  return v2;
}

void _RTPTransportMediaPacketHistoryCleanUp(uint64_t a1, unsigned int a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v5;
  unint64_t v7;
  const void *v8;
  _QWORD *v9;
  const void *v10;
  _QWORD *v11;
  void *v12;

  v2 = a1 + 11208;
  v3 = a1 + 11208 + 16 * a2;
  if (v3)
  {
    v5 = a1 + 27592;
    if (v2 > v3 || v3 + 16 > v5)
      goto LABEL_17;
    v7 = v2 + 16 * a2;
    v10 = *(const void **)(v7 + 8);
    v9 = (_QWORD *)(v7 + 8);
    v8 = v10;
    if (v10)
    {
      if (v3 >= v5)
        goto LABEL_17;
      CFRelease(v8);
      *v9 = 0;
    }
    v11 = *(_QWORD **)v3;
    if (*(_QWORD *)v3)
    {
      v12 = (void *)v11[5];
      if (v12)
        CFAllocatorDeallocate(*(CFAllocatorRef *)(a1 + 10816), v12);
      CFAllocatorDeallocate(*(CFAllocatorRef *)(a1 + 10808), v11);
    }
    if (v5 >= v3 && v5 - v3 >= 0x10)
    {
      *(_QWORD *)v3 = 0;
      *(_QWORD *)(v3 + 8) = 0;
      return;
    }
LABEL_17:
    __break(0x5519u);
  }
}

uint64_t _RTPTransportAddMediaPacketHistory(uint64_t a1, _WORD **a2)
{
  _WORD *v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v9;
  int v10;
  const void *v14;
  _WORD *v15;
  _QWORD v17[3];

  v17[2] = *MEMORY[0x1E0C80C00];
  v3 = *a2;
  v4 = **a2 & 0x3FF;
  v17[0] = 0;
  v17[1] = *((_QWORD *)v3 + 8);
  v5 = a1 + 11208;
  v6 = (uint64_t *)(a1 + 27592);
  v7 = (uint64_t *)(a1 + 11208 + 16 * v4);
  if (v7)
  {
    if (v7 >= v6 || (unint64_t)v7 < v5)
LABEL_24:
      __break(0x5519u);
    v9 = *v7;
    if (*v7)
    {
      v10 = *(_DWORD *)(v9 + 4);
      if (v10)
      {
        if (*(_QWORD *)(v5 + 16 * v4 + 8))
        {
          if (v7 + 2 > v6)
            goto LABEL_24;
          WORD2(v17[0]) = *(_WORD *)v9;
          LODWORD(v17[0]) = v10;
          VCNACKConsumer_UpdatePacketCacheStatus(*(_QWORD *)(a1 + 27592), (int *)v17);
          _RTPTransportMediaPacketHistoryCleanUp(a1, v4);
        }
      }
    }
  }
  if (v6 < v7 || v5 > (unint64_t)v7 || (unint64_t)((char *)v6 - (char *)v7) < 0x10)
    goto LABEL_24;
  *(_OWORD *)v7 = *(_OWORD *)a2;
  if (v7 + 2 > v6)
    goto LABEL_24;
  v14 = *(const void **)(v5 + 16 * v4 + 8);
  if (v14)
    CFRetain(v14);
  v15 = *a2;
  WORD2(v17[0]) = **a2;
  LODWORD(v17[0]) = *((_DWORD *)v15 + 1);
  return VCNACKConsumer_UpdatePacketCacheStatus(*v6, (int *)v17);
}

uint64_t _RTPTransport_ParseBasebandNotification(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  int *v6;
  uint64_t result;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v12;
  NSObject *v13;
  NSObject *v14;
  int v15;
  uint64_t v16;
  NSObject *v17;
  int v18;
  char *v19;
  size_t lengthAtOffsetOut;
  uint8_t buf[4];
  uint64_t v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  *a3 = 1;
  v6 = a3 + 2;
  v19 = 0;
  lengthAtOffsetOut = 0;
  result = CMBlockBufferGetDataPointer(*(CMBlockBufferRef *)a2, 0, &lengthAtOffsetOut, 0, &v19);
  if ((_DWORD)result)
  {
    v8 = result;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _RTPTransport_ParseBasebandNotification_cold_4();
    }
    if (v8 >= 0)
      v9 = v8;
    else
      v9 = -v8;
    return v9 | (v8 << 31) | 0x50010000u;
  }
  if ((lengthAtOffsetOut & 0x80000000) == 0 && (int)lengthAtOffsetOut <= (uint64_t)lengthAtOffsetOut && v6 < a3 + 1514)
  {
    if (!VCBasebandNotificationParser_ParseNotification((unint64_t)v19, lengthAtOffsetOut, (uint64_t)v6, *(double *)(a2 + 128))|| !*v6)
    {
      v10 = 2147549191;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _RTPTransport_ParseBasebandNotification_cold_1();
      }
      return v10;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v12 = VRTraceErrorLogLevelToCSTR();
      v13 = *MEMORY[0x1E0CF2758];
      v14 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          v15 = *v6;
          *(_DWORD *)buf = 136315906;
          v22 = v12;
          v23 = 2080;
          v24 = "_RTPTransport_ParseBasebandNotification";
          v25 = 1024;
          v26 = 2343;
          v27 = 1024;
          v28 = v15;
          _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Received baseband notification with type %d", buf, 0x22u);
        }
      }
      else if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        _RTPTransport_ParseBasebandNotification_cold_3();
      }
    }
    if (*v6 == 3 && (int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v16 = VRTraceErrorLogLevelToCSTR();
      v17 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v18 = *v6;
        *(_DWORD *)buf = 136315906;
        v22 = v16;
        v23 = 2080;
        v24 = "_RTPTransport_ParseBasebandNotification";
        v25 = 1024;
        v26 = 2345;
        v27 = 1024;
        v28 = v18;
        _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Received codec rate mode change request with suggested bitrate %d", buf, 0x22u);
      }
    }
    result = *(_QWORD *)(a1 + 10360);
    if (result == 0xFFFFFFFFLL)
    {
      v10 = 0;
LABEL_38:
      VCRateControlProcessBasebandNotification(*(void **)(a1 + 10432), (uint64_t)v6);
      return v10;
    }
    if (!v19 || lengthAtOffsetOut)
    {
      v10 = AFRCProcessBasebandNotification(result);
      if ((v10 & 0x80000000) != 0 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _RTPTransport_ParseBasebandNotification_cold_2();
      }
      goto LABEL_38;
    }
  }
  __break(0x5519u);
  return result;
}

uint64_t _RTPEnsureTransportStreamsDeactivated(uint64_t a1)
{
  _BYTE *v2;
  uint64_t v3;
  uint64_t (*v4)(uint64_t);
  uint64_t v5;
  uint64_t v6;
  uint64_t (*v7)(uint64_t);
  uint64_t v8;
  uint64_t v9;
  uint64_t (*v10)(uint64_t);

  if (a1)
  {
    v2 = (_BYTE *)(a1 + 11101);
    if (!*(_BYTE *)(a1 + 11101))
      return 0;
    v3 = *(_QWORD *)(a1 + 11104);
    v4 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 64);
    if (!v4)
      return 4294954514;
    v5 = v4(v3);
    if ((v5 & 0x80000000) != 0)
      return v5;
    v6 = *(_QWORD *)(a1 + 11112);
    v7 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 64);
    if (!v7)
      return 4294954514;
    v8 = v7(v6);
    if ((v8 & 0x80000000) != 0)
      return v8;
    v9 = *(_QWORD *)(a1 + 11120);
    if (!v9)
    {
LABEL_10:
      *v2 = 0;
      return v8;
    }
    v10 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 16) + 64);
    if (!v10)
      return 4294954514;
    v8 = v10(v9);
    if ((v8 & 0x80000000) == 0)
      goto LABEL_10;
  }
  else
  {
    v8 = 2147549185;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _RTPEnsureTransportStreamsDeactivated_cold_1();
    }
  }
  return v8;
}

const char *OUTLINED_FUNCTION_27@<X0>(void **a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  *(_QWORD *)(v2 - 24) = a2;
  return VCMediaKeyIndex_Description(*a1);
}

double Format_Float(uint64_t a1, int a2, int a3)
{
  double result;

  *(double *)a1 = (double)a3;
  *(_OWORD *)(a1 + 8) = xmmword_1D9108BF0;
  *(_DWORD *)(a1 + 24) = 4;
  *(_DWORD *)(a1 + 28) = a2;
  *(_QWORD *)&result = 32;
  *(_QWORD *)(a1 + 32) = 32;
  return result;
}

double Format_Short(uint64_t a1, int a2, int a3)
{
  double result;

  *(double *)a1 = (double)a3;
  *(_QWORD *)(a1 + 8) = 0x2C6C70636DLL;
  *(_DWORD *)(a1 + 16) = 2 * a2;
  *(_DWORD *)(a1 + 20) = 1;
  *(_DWORD *)(a1 + 24) = 2 * a2;
  *(_DWORD *)(a1 + 28) = a2;
  *(_QWORD *)&result = 16;
  *(_QWORD *)(a1 + 32) = 16;
  return result;
}

float BitrateToQuality(int a1, unsigned int a2, int a3, int a4)
{
  float v4;
  BOOL v6;
  float v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  unsigned int v11;

  if (a1 < 1179648)
  {
    if (a1 != 720896 && a1 != 0x100000)
    {
      if (a1 != 1114112)
        goto LABEL_59;
      return (float)a2;
    }
    if (a3 == 16000)
    {
      v4 = -9.0;
      if (a2 < 0x2329)
        return v4;
      v4 = 0.0;
      if (a2 < 0x2EE1)
        return v4;
      v4 = 9.0;
      if (a2 < 0x36B1)
        return v4;
      v4 = 18.0;
      if (a2 < 0x3E81)
        return v4;
      v4 = 27.0;
      if (a2 < 0x4651)
        return v4;
      if (a2 >= 0x4E21)
      {
        if (a2 >= 0x5DC1)
        {
          v6 = a2 >= 0x6D61;
          v7 = 63.0;
          goto LABEL_66;
        }
LABEL_63:
        v9 = 1110704128;
        return *(float *)&v9;
      }
    }
    else
    {
      v4 = -18.0;
      if (a2 < 0x2329)
        return v4;
      v4 = -9.0;
      if (a2 < 0x2EE1)
        return v4;
      v4 = 0.0;
      if (a2 < 0x3E81)
        return v4;
      v4 = 9.0;
      if (a2 < 0x4E21)
        return v4;
      v4 = 18.0;
      if (a2 < 0x5DC1)
        return v4;
      v4 = 27.0;
      if (a2 < 0x6D61)
        return v4;
      if (a2 >= 0x7D01)
      {
        if (a2 >= 0x8CA1)
        {
          v6 = a2 >= 0x9C41;
          v7 = 64.0;
LABEL_66:
          if (v6)
            return v7;
          else
            return 54.0;
        }
        goto LABEL_63;
      }
    }
    v9 = 1108344832;
    return *(float *)&v9;
  }
  if (a1 < 0x400000)
  {
    if (a1 != 1179648)
    {
      if (a1 == 0x200000)
      {
        if (a3 == 48000 && a4 == 4)
          return (float)((float)(a2 >> 2) / 300000.0) * 127.0;
        if (a2 <= 0x1388)
          v10 = 5000;
        else
          v10 = a2;
        if (v10 >= 0xBB80)
          v11 = 48000;
        else
          v11 = v10;
        return (double)v11 / 1000.0;
      }
      goto LABEL_59;
    }
    return (float)a2;
  }
  if (a1 == 0x400000)
  {
    v4 = 0.0;
    if (a3 == 16000)
    {
      if (a2 < 0x19C9)
        return v4;
      v4 = 1.0;
      if (a2 < 0x2293)
        return v4;
      v4 = 2.0;
      if (a2 < 0x316B)
        return v4;
      v4 = 3.0;
      if (a2 < 0x37AB)
        return v4;
      v4 = 4.0;
      if (a2 < 0x3DEB)
        return v4;
      v4 = 5.0;
      if (a2 < 0x474B)
        return v4;
      v4 = 6.0;
      if (a2 < 0x4D8B)
        return v4;
      v4 = 7.0;
      if (a2 < 0x5A0B)
        return v4;
      v4 = 8.0;
      v8 = 23851;
    }
    else
    {
      if (a2 < 0x128F)
        return v4;
      v4 = 1.0;
      if (a2 < 0x141F)
        return v4;
      v4 = 2.0;
      if (a2 < 0x170D)
        return v4;
      v4 = 3.0;
      if (a2 < 0x1A2D)
        return v4;
      v4 = 4.0;
      if (a2 < 0x1CE9)
        return v4;
      v4 = 5.0;
      if (a2 < 0x1F0F)
        return v4;
      v4 = 6.0;
      if (a2 < 0x27D9)
        return v4;
      v4 = 7.0;
      v8 = 12201;
    }
    if (a2 < v8)
      return v4;
    goto LABEL_59;
  }
  if (a1 == 5242880)
    return (float)a2;
LABEL_59:
  v4 = 0.0;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      BitrateToQuality_cold_1();
  }
  return v4;
}

void FileUtil_PrintBasicDesc(uint64_t a1, uint64_t *a2)
{
  int ErrorLogLevelForModule;
  os_log_t *v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  char *v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  uint64_t v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  char *v29;
  __int16 v30;
  int v31;
  __int16 v32;
  int v33;
  __int16 v34;
  int v35;
  __int16 v36;
  int v37;
  __int16 v38;
  int v39;
  __int16 v40;
  int v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  v5 = (os_log_t *)MEMORY[0x1E0CF2758];
  if (ErrorLogLevelForModule >= 7)
  {
    v6 = VRTraceErrorLogLevelToCSTR();
    v7 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
    {
      v18 = 136315906;
      v19 = v6;
      v20 = 2080;
      v21 = "FileUtil_PrintBasicDesc";
      v22 = 1024;
      v23 = 433;
      v24 = 2080;
      v25 = a1;
      _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d %s mSampleRate : mFormatID : mFormatFlags : mBytesPerPacket : mFramesPerPacket : mBytesPerFrame : mChannelsPerFrame : mBitsPerChannel :", (uint8_t *)&v18, 0x26u);
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v8 = VRTraceErrorLogLevelToCSTR();
    v9 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
    {
      v10 = *a2;
      v11 = FourccToCStr(*((_DWORD *)a2 + 2));
      v12 = *((_DWORD *)a2 + 3);
      v13 = *((_DWORD *)a2 + 4);
      v14 = *((_DWORD *)a2 + 5);
      v15 = *((_DWORD *)a2 + 6);
      v16 = *((_DWORD *)a2 + 7);
      v17 = *((_DWORD *)a2 + 8);
      v18 = 136317954;
      v19 = v8;
      v20 = 2080;
      v21 = "FileUtil_PrintBasicDesc";
      v22 = 1024;
      v23 = 443;
      v24 = 2080;
      v25 = a1;
      v26 = 2048;
      v27 = v10;
      v28 = 2080;
      v29 = v11;
      v30 = 1024;
      v31 = v12;
      v32 = 1024;
      v33 = v13;
      v34 = 1024;
      v35 = v14;
      v36 = 1024;
      v37 = v15;
      v38 = 1024;
      v39 = v16;
      v40 = 1024;
      v41 = v17;
      _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d %s %8.0f    : %7s   :  0x%08x  : %8u        : %9u        : %8u       : %9u         : %9u       :", (uint8_t *)&v18, 0x5Eu);
    }
  }
}

void SoundDec_PrepareAudioConverter()
{
  _BOOL4 v0;
  int ErrorLogLevelForModule;
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  NSObject *v5;
  int v6;
  uint64_t v7;
  __int16 v8;
  const char *v9;
  __int16 v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v0 = VCFeatureFlagManager_UseOutOfProcessAudioDecoding();
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (v0)
  {
    if (ErrorLogLevelForModule >= 7)
    {
      v2 = VRTraceErrorLogLevelToCSTR();
      v3 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v6 = 136315650;
        v7 = v2;
        v8 = 2080;
        v9 = "SoundDec_PrepareAudioConverter";
        v10 = 1024;
        v11 = 628;
        _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Calling AudioConverterPrepare()", (uint8_t *)&v6, 0x1Cu);
      }
    }
    AudioConverterPrepare();
  }
  else if (ErrorLogLevelForModule >= 7)
  {
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v6 = 136315650;
      v7 = v4;
      v8 = 2080;
      v9 = "SoundDec_PrepareAudioConverter";
      v10 = 1024;
      v11 = 631;
      _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d UseOutOfProcessAudioDecoding is OFF; Not calling AudioConverterPrepare()",
        (uint8_t *)&v6,
        0x1Cu);
    }
  }
}

uint64_t SoundDec_Create(_QWORD *a1, uint64_t a2)
{
  uint64_t result;
  _OWORD *v5;
  _OWORD *v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  void *v12;
  int v13;
  int AppBooleanValue;
  int v15;
  uint64_t v16;
  NSObject *v17;
  int v18;
  int v19;
  AudioConverterRef *v20;
  int v21;
  int v22;
  uint64_t v23;
  NSObject *v24;
  uint64_t v25;
  NSObject *v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  BOOL v32;
  uint64_t v33;
  NSObject *v34;
  int inPropertyData;
  Boolean keyExistsAndHasValidFormat[4];
  uint64_t v37;
  __int16 v38;
  const char *v39;
  __int16 v40;
  int v41;
  __int16 v42;
  int v43;
  __int16 v44;
  int v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  result = 2147811329;
  if (!a1 || !a2)
    return result;
  v5 = malloc_type_calloc(1uLL, 0x110uLL, 0x1030040C827E633uLL);
  if (!v5)
    return 2147811331;
  v6 = v5;
  result = (uint64_t)malloc_type_malloc(0x2328uLL, 0x7ADA61D3uLL);
  v7 = result + 9000;
  if (!result)
    v7 = 0;
  if (v7 - result <= 8999)
  {
    __break(0x5519u);
    return result;
  }
  *((_QWORD *)v6 + 20) = result;
  *((_DWORD *)v6 + 43) = 9000;
  if (!result)
  {
LABEL_24:
    free(v6);
    return 2147811331;
  }
  *((_DWORD *)v6 + 42) = 0;
  *((_DWORD *)v6 + 47) = 0;
  v8 = *(_OWORD *)a2;
  v9 = *(_OWORD *)(a2 + 16);
  *((_QWORD *)v6 + 4) = *(_QWORD *)(a2 + 32);
  *v6 = v8;
  v6[1] = v9;
  v10 = *(_OWORD *)(a2 + 40);
  v11 = *(_OWORD *)(a2 + 56);
  *((_QWORD *)v6 + 9) = *(_QWORD *)(a2 + 72);
  *(_OWORD *)((char *)v6 + 56) = v11;
  *(_OWORD *)((char *)v6 + 40) = v10;
  *((_DWORD *)v6 + 20) = TranslateASBDToPayloadFormat(a2);
  *((_DWORD *)v6 + 21) = TranslateASBDToPayloadFormat(a2 + 40);
  if (*((_WORD *)v6 + 41) != 256)
    goto LABEL_11;
  v12 = malloc_type_malloc(0x64uLL, 0xF28CA9BFuLL);
  if (!v12)
  {
    free(*((void **)v6 + 20));
    goto LABEL_24;
  }
  *((_BYTE *)v6 + 120) = 1;
  *((_QWORD *)v6 + 12) = v12;
  *(_OWORD *)((char *)v6 + 104) = xmmword_1D910B570;
LABEL_11:
  *((_QWORD *)v6 + 19) = malloc_type_calloc(1uLL, (16 * *(unsigned int *)(a2 + 68)) | 8, 0x28FF24FAuLL);
  v13 = *((unsigned __int16 *)v6 + 41) << 16;
  if (v13 < 0x200000)
  {
    if (v13 >= 1114112)
    {
      if (v13 != 1114112 && v13 != 1179648)
        goto LABEL_34;
    }
    else if (v13 != 655360)
    {
      if (v13 != 0x100000)
        goto LABEL_34;
      keyExistsAndHasValidFormat[0] = 0;
      AppBooleanValue = CFPreferencesGetAppBooleanValue(CFSTR("useZeroSignaling"), CFSTR("com.apple.VideoConference"), keyExistsAndHasValidFormat);
      if (keyExistsAndHasValidFormat[0])
        v15 = AppBooleanValue;
      else
        v15 = 1;
LABEL_33:
      *((_DWORD *)v6 + 45) = v15;
      goto LABEL_34;
    }
LABEL_32:
    v15 = 1;
    goto LABEL_33;
  }
  if (v13 >= 5242880)
  {
    if (v13 != 5242880 && v13 != 0x800000 && v13 != 0x1000000)
      goto LABEL_34;
    goto LABEL_32;
  }
  if (v13 == 0x200000 || v13 == 0x400000)
    goto LABEL_32;
LABEL_34:
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v16 = VRTraceErrorLogLevelToCSTR();
    v17 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v18 = *((_DWORD *)v6 + 20);
      v19 = *((_DWORD *)v6 + 21);
      *(_DWORD *)keyExistsAndHasValidFormat = 136316162;
      v37 = v16;
      v38 = 2080;
      v39 = "SoundDec_Create";
      v40 = 1024;
      v41 = 700;
      v42 = 1024;
      v43 = v18;
      v44 = 1024;
      v45 = v19;
      _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d SoundDec_Create(%08x --> %08x)", keyExistsAndHasValidFormat, 0x28u);
    }
  }
  FileUtil_PrintBasicDesc((uint64_t)"in  format:", (uint64_t *)v6);
  FileUtil_PrintBasicDesc((uint64_t)"out format:", (uint64_t *)v6 + 5);
  if (*((unsigned __int16 *)v6 + 43) << 16 == 983040)
  {
    if (!RegisterG722Encoder())
    {
LABEL_47:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v25 = VRTraceErrorLogLevelToCSTR();
        v26 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)keyExistsAndHasValidFormat = 136315906;
          v37 = v25;
          v38 = 2080;
          v39 = "SoundDec_Create";
          v40 = 1024;
          v41 = 706;
          v42 = 1024;
          v43 = -2147155964;
          _os_log_impl(&dword_1D8A54000, v26, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Failed to register: %X", keyExistsAndHasValidFormat, 0x22u);
        }
      }
      SoundDec_Destroy((uint64_t)v6);
      return 2147811332;
    }
  }
  else if (*((unsigned __int16 *)v6 + 41) << 16 == 983040 && !RegisterG722Decoder())
  {
    goto LABEL_47;
  }
  v20 = (AudioConverterRef *)v6 + 11;
  v21 = SoundDec_AudioConverterInstantiate((uint64_t)v6, (uint64_t)v6 + 40, *(unsigned __int8 *)(a2 + 80), (OpaqueAudioConverter **)v6 + 11);
  if (v21)
  {
    v22 = v21;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v23 = VRTraceErrorLogLevelToCSTR();
      v24 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SoundDec_Create_cold_6(v23, v22, v24);
    }
    SoundDec_Destroy((uint64_t)v6);
    return -v22 | 0xA0050000;
  }
  v27 = *((unsigned __int16 *)v6 + 43) << 16;
  if (v27 == 655360)
  {
    *(_DWORD *)keyExistsAndHasValidFormat = 127;
    if (AudioConverterSetProperty(*v20, 0x73726371u, 4u, keyExistsAndHasValidFormat))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          SoundDec_Create_cold_5();
      }
    }
    if (*((_DWORD *)v6 + 21) == 671360)
      v28 = 2;
    else
      v28 = 1;
    inPropertyData = v28;
    if (AudioConverterSetProperty(*((AudioConverterRef *)v6 + 11), 0x7365716Cu, 4u, &inPropertyData))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          SoundDec_Create_cold_4();
      }
    }
    goto LABEL_94;
  }
  if (v27 == 983040)
  {
    *(_DWORD *)keyExistsAndHasValidFormat = 0;
    if (AudioConverterSetProperty(*v20, 0x65736164u, 4u, keyExistsAndHasValidFormat))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          SoundDec_Create_cold_3();
      }
    }
    goto LABEL_94;
  }
  if (v27 >= 0x200000)
  {
    if (v27 != 0x200000)
    {
      if (v27 == 5242880)
      {
        v29 = *((_DWORD *)v6 + 12);
        v30 = 1936029299;
LABEL_92:
        if (v29 == v30)
          goto LABEL_93;
        goto LABEL_94;
      }
      if (v27 != 0x400000)
        goto LABEL_94;
    }
LABEL_76:
    *(_DWORD *)keyExistsAndHasValidFormat = 1;
    v31 = *((_DWORD *)v6 + 12);
    if (v31 == 1633772390
      || (v31 != 1633772389 || (int)*((double *)v6 + 5) != 48000 ? (v32 = 0) : (v32 = *((_DWORD *)v6 + 17) == 2),
          v27 == 0x200000 || v32 || v31 == 1935764850 || v31 == 1936029299 || v31 == 1935767394))
    {
      *(_DWORD *)keyExistsAndHasValidFormat = 3;
      *((_DWORD *)v6 + 47) = 1;
    }
    if (AudioConverterSetProperty(*v20, 0x61636266u, 4u, keyExistsAndHasValidFormat))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          SoundDec_Create_cold_2();
      }
    }
    goto LABEL_94;
  }
  switch(v27)
  {
    case 1048576:
      goto LABEL_76;
    case 1114112:
LABEL_93:
      *((_DWORD *)v6 + 47) = 1;
      break;
    case 1179648:
      v29 = *((_DWORD *)v6 + 12);
      v30 = 1633903462;
      goto LABEL_92;
  }
LABEL_94:
  if (*(double *)v6 != *((double *)v6 + 5))
  {
    *(_DWORD *)keyExistsAndHasValidFormat = 2;
    if (AudioConverterSetProperty(*v20, 0x70726D6Du, 4u, keyExistsAndHasValidFormat))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          SoundDec_Create_cold_1();
      }
    }
    if (*(_BYTE *)(a2 + 81))
      _SoundDec_ConfigureRamStadSRC((uint64_t)v6);
  }
  inPropertyData = 1;
  AudioConverterSetProperty(*((AudioConverterRef *)v6 + 11), 0x646D6F64u, 4u, &inPropertyData);
  *a1 = v6;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v33 = VRTraceErrorLogLevelToCSTR();
    v34 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)keyExistsAndHasValidFormat = 136315650;
      v37 = v33;
      v38 = 2080;
      v39 = "SoundDec_Create";
      v40 = 1024;
      v41 = 788;
      _os_log_impl(&dword_1D8A54000, v34, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Leaving SoundDec_Create", keyExistsAndHasValidFormat, 0x1Cu);
    }
  }
  return 0;
}

uint64_t TranslateASBDToPayloadFormat(uint64_t a1)
{
  uint64_t v1;
  int v2;
  int v3;
  int v6;
  unsigned int v7;

  v1 = (int)*(double *)a1;
  v2 = *(_DWORD *)(a1 + 8);
  if (v2 <= 1819304812)
  {
    if (v2 <= 1633903461)
    {
      if ((v2 - 1633772389) < 3)
        return v1 | 0x100000;
      if (v2 == 1633772396)
      {
        v3 = 720896;
        return v1 | v3;
      }
      goto LABEL_42;
    }
    if (v2 > 1685354615)
    {
      if (v2 == 1685354616)
        return v1 | 0x800000;
      if (v2 == 1735091043)
        return v1 | 0xF0000;
    }
    else
    {
      if (v2 == 1633903462)
      {
        v3 = 1179648;
        return v1 | v3;
      }
      if (v2 == 1634492791)
      {
        v3 = 327680;
        return v1 | v3;
      }
    }
    goto LABEL_42;
  }
  if (v2 > 1936029298)
  {
    if (v2 > 1953790319)
    {
      if (v2 == 1953790320)
        return v1 | 0x1000000;
      if (v2 == 1970037111)
        return v1 | 0x40000;
    }
    else
    {
      if (v2 == 1936029299)
      {
        v3 = 5242880;
        return v1 | v3;
      }
      if (v2 == 1936745848)
      {
        v3 = 655360;
        return v1 | v3;
      }
    }
LABEL_42:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        TranslateASBDToPayloadFormat_cold_1();
    }
    return v1;
  }
  if (v2 > 1935764849)
  {
    if (v2 == 1935764850 || v2 == 1935767394)
      return v1 | 0x400000;
    goto LABEL_42;
  }
  if (v2 != 1819304813)
  {
    if (v2 == 1869641075)
      return v1 | 0x200000;
    goto LABEL_42;
  }
  if ((~*(_DWORD *)(a1 + 12) & 9) != 0)
  {
    v6 = *(_DWORD *)(a1 + 24);
    v7 = v1 | 0xD0000;
    if (v6 != 4)
      v7 = (int)*(double *)a1;
    if (v6 == 2)
      return v1 | 0x30000;
    else
      return v7;
  }
  else if (*(_DWORD *)(a1 + 28) == 2)
  {
    return v1 | 0x20000;
  }
  else
  {
    return v1 | 0x10000;
  }
}

uint64_t SoundDec_Destroy(uint64_t a1)
{
  OpaqueAudioConverter *v2;
  void *v3;
  void *v4;

  if (!a1)
    return 2147811329;
  v2 = *(OpaqueAudioConverter **)(a1 + 88);
  if (v2)
  {
    AudioConverterDispose(v2);
    *(_QWORD *)(a1 + 88) = 0;
  }
  free(*(void **)(a1 + 160));
  *(_QWORD *)(a1 + 160) = 0;
  *(_DWORD *)(a1 + 172) = 0;
  if (*(_WORD *)(a1 + 82) == 256)
  {
    v3 = *(void **)(a1 + 96);
    if (v3)
    {
      if (*(_BYTE *)(a1 + 120))
      {
        free(v3);
        *(_BYTE *)(a1 + 120) = 0;
      }
      *(_QWORD *)(a1 + 96) = 0;
      *(_QWORD *)(a1 + 104) = 0;
      *(_QWORD *)(a1 + 112) = 0;
    }
  }
  v4 = *(void **)(a1 + 152);
  if (v4)
    free(v4);
  free((void *)a1);
  return 0;
}

uint64_t SoundDec_AudioConverterInstantiate(uint64_t a1, uint64_t a2, int a3, OpaqueAudioConverter **a4)
{
  int v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  _BOOL4 v12;
  _BOOL4 v13;
  uint64_t v14;
  NSObject *v15;
  char *v16;
  char *v17;
  uint64_t v18;
  OpaqueAudioConverter *v19;
  OSStatus v20;
  int ErrorLogLevelForModule;
  uint64_t v22;
  NSObject *v23;
  uint64_t v24;
  NSObject *v25;
  char *v26;
  uint64_t v27;
  NSObject *v28;
  char *v29;
  char *v30;
  int inPropertyData;
  uint8_t buf[4];
  uint64_t v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  int v38;
  __int16 v39;
  char *v40;
  __int16 v41;
  char *v42;
  __int16 v43;
  _BYTE v44[10];
  __int16 v45;
  int v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  if (a1 && a2 && a4)
  {
    if ((a3 & 1) != 0)
    {
      v8 = 1;
    }
    else
    {
      v12 = *(_DWORD *)(a1 + 8) != 1819304813 && *(_DWORD *)(a2 + 8) == 1819304813;
      v13 = VCFeatureFlagManager_UseOutOfProcessAudioDecoding();
      v8 = v12 && v13;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v14 = VRTraceErrorLogLevelToCSTR();
        v15 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v16 = FourccToCStr(*(_DWORD *)(a1 + 8));
          v17 = FourccToCStr(*(_DWORD *)(a2 + 8));
          *(_DWORD *)buf = 136316930;
          v34 = v14;
          v35 = 2080;
          v36 = "SoundDec_AudioConverterInstantiate";
          v37 = 1024;
          v38 = 1874;
          v39 = 2080;
          v40 = v16;
          v41 = 2080;
          v42 = v17;
          v43 = 1024;
          *(_DWORD *)v44 = v12;
          *(_WORD *)&v44[4] = 1024;
          *(_DWORD *)&v44[6] = v13;
          v45 = 1024;
          v46 = v12 && v13;
          _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d sourceFormat=%s, destinationFormat=%s, decoding=%d, useOutOfProcessAudioDecoding=%d, instantiationOptions=%d", buf, 0x42u);
        }
      }
    }
    v18 = AudioConverterInstantiate();
    v11 = v18;
    if (v8)
    {
      if (!(_DWORD)v18)
      {
        v19 = *a4;
        if (*a4)
        {
          inPropertyData = 1;
          v20 = AudioConverterSetProperty(v19, 0x756D6662u, 4u, &inPropertyData);
          ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
          if (v20)
          {
            if (ErrorLogLevelForModule >= 3)
            {
              v22 = VRTraceErrorLogLevelToCSTR();
              v23 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                SoundDec_AudioConverterInstantiate_cold_1(v22, v20, v23);
            }
          }
          else if (ErrorLogLevelForModule >= 7)
          {
            v24 = VRTraceErrorLogLevelToCSTR();
            v25 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              v26 = FourccToCStr(1970103906);
              *(_DWORD *)buf = 136316162;
              v34 = v24;
              v35 = 2080;
              v36 = "SoundDec_AudioConverterInstantiate";
              v37 = 1024;
              v38 = 1881;
              v39 = 2080;
              v40 = v26;
              v41 = 1024;
              LODWORD(v42) = inPropertyData;
              _os_log_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d AudioConverterSetProperty succeeded to set property kAudioConverterPropertyUseMessengerForBundleData=%s useMessengerForBundleData=%u", buf, 0x2Cu);
            }
          }
        }
      }
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v27 = VRTraceErrorLogLevelToCSTR();
      v28 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v29 = FourccToCStr(*(_DWORD *)(a1 + 8));
        v30 = FourccToCStr(*(_DWORD *)(a2 + 8));
        *(_DWORD *)buf = 136316930;
        v34 = v27;
        v35 = 2080;
        v36 = "SoundDec_AudioConverterInstantiate";
        v37 = 1024;
        v38 = 1886;
        v39 = 2080;
        v40 = v29;
        v41 = 2080;
        v42 = v30;
        v43 = 1024;
        *(_DWORD *)v44 = a3;
        *(_WORD *)&v44[4] = 1024;
        *(_DWORD *)&v44[6] = v8;
        v45 = 1024;
        v46 = v11;
        _os_log_impl(&dword_1D8A54000, v28, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d sourceFormat=%s, destinationFormat=%s, loadConverterOutOfProcess=%d, instantiationOptions=%d, status=%d", buf, 0x42u);
      }
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v9 = VRTraceErrorLogLevelToCSTR();
      v10 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136316418;
        v34 = v9;
        v35 = 2080;
        v36 = "SoundDec_AudioConverterInstantiate";
        v37 = 1024;
        v38 = 1866;
        v39 = 2048;
        v40 = (char *)a1;
        v41 = 2048;
        v42 = (char *)a2;
        v43 = 2048;
        *(_QWORD *)v44 = a4;
        _os_log_error_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_ERROR, " [%s] %s:%d Invalid paramter(s): sourceFormat=%p, destinationFormat=%p, audioConverter=%p", buf, 0x3Au);
      }
    }
    return 1;
  }
  return v11;
}

void _SoundDec_ConfigureRamStadSRC(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  OSStatus v4;
  int ErrorLogLevelForModule;
  uint64_t v6;
  NSObject *v7;
  OSStatus v8;
  int v9;
  uint64_t v10;
  NSObject *v11;
  int v12;
  int inPropertyData;
  uint8_t buf[4];
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      v15 = v2;
      v16 = 2080;
      v17 = "_SoundDec_ConfigureRamStadSRC";
      v18 = 1024;
      v19 = 607;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Configuring Ramstad SRC", buf, 0x1Cu);
    }
  }
  inPropertyData = 1835626096;
  v4 = AudioConverterSetProperty(*(AudioConverterRef *)(a1 + 88), 0x73726361u, 4u, &inPropertyData);
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (v4)
  {
    if (ErrorLogLevelForModule >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _SoundDec_ConfigureRamStadSRC_cold_2();
    }
  }
  else if (ErrorLogLevelForModule >= 7)
  {
    v6 = VRTraceErrorLogLevelToCSTR();
    v7 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      v15 = v6;
      v16 = 2080;
      v17 = "_SoundDec_ConfigureRamStadSRC";
      v18 = 1024;
      v19 = 614;
      v20 = 1024;
      v21 = inPropertyData;
      _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d AudioConverterSetProperty succeeded to set kAudioConverterSampleRateConverterComplexity=%u", buf, 0x22u);
    }
  }
  v12 = 34;
  v8 = AudioConverterSetProperty(*(AudioConverterRef *)(a1 + 88), 0x73726371u, 4u, &v12);
  v9 = VRTraceGetErrorLogLevelForModule();
  if (v8)
  {
    if (v9 >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _SoundDec_ConfigureRamStadSRC_cold_1();
    }
  }
  else if (v9 >= 7)
  {
    v10 = VRTraceErrorLogLevelToCSTR();
    v11 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      v15 = v10;
      v16 = 2080;
      v17 = "_SoundDec_ConfigureRamStadSRC";
      v18 = 1024;
      v19 = 622;
      v20 = 1024;
      v21 = v12;
      _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d AudioConverterSetProperty succeeded to set kAudioConverterSampleRateConverterQuality=%u", buf, 0x22u);
    }
  }
}

uint64_t SoundDec_ShouldRampDownMissingPackets(uint64_t a1, int *a2)
{
  uint64_t result;
  int v4;
  int v5;

  result = 2147811329;
  if (a1 && a2)
  {
    v4 = 0;
    v5 = *(unsigned __int16 *)(a1 + 82) << 16;
    if (v5 < 1114112)
    {
      if (v5 >= 983040)
      {
        if (v5 == 983040 || v5 == 0x100000)
          goto LABEL_19;
      }
      else if (v5 == 655360 || v5 == 720896)
      {
        goto LABEL_19;
      }
    }
    else if (v5 < 0x400000)
    {
      if (v5 == 1114112 || v5 == 1179648)
        goto LABEL_19;
    }
    else if (v5 == 0x400000 || v5 == 5242880 || v5 == 0x800000)
    {
      goto LABEL_19;
    }
    v4 = 1;
LABEL_19:
    result = 0;
    *a2 = v4;
  }
  return result;
}

uint64_t NilDecodeProc(uint64_t a1, _DWORD *a2, uint64_t a3, _QWORD *a4, uint64_t a5)
{
  *(_QWORD *)(a5 + 128) = 0;
  *(_QWORD *)(a5 + 136) = 0;
  *a2 = 1;
  *(_DWORD *)(a3 + 12) = 4;
  *(_QWORD *)(a3 + 16) = &NilDecodeProc_tmpArry;
  *(_DWORD *)a3 = 1;
  *a4 = a5 + 128;
  return 0;
}

uint64_t DecodeNilPacket(unsigned int *inInputDataProcUserData, char *a2, unsigned int a3, _DWORD *a4)
{
  uint64_t v8;
  unsigned int v9;
  AudioBufferList *v10;
  int v11;
  signed int v12;
  char *v13;
  uint64_t v14;
  unint64_t mBuffers;
  char *v16;
  BOOL v17;
  UInt32 ioOutputDataPacketSize;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v8 = inInputDataProcUserData[17];
  v9 = a3 / (inInputDataProcUserData[16] * v8);
  ioOutputDataPacketSize = v9;
  v10 = (AudioBufferList *)*((_QWORD *)inInputDataProcUserData + 19);
  v10->mNumberBuffers = v8;
  if ((_DWORD)v8)
  {
    v11 = 0;
    v12 = a3 / v8;
    v13 = &a2[a3];
    v14 = v8;
    mBuffers = (unint64_t)v10->mBuffers;
    while (1)
    {
      v16 = &a2[v12 * v11];
      v17 = v16 <= v13 && v16 >= a2;
      if (!v17
        || v12 < 0
        || v13 - v16 < v12
        || mBuffers < (unint64_t)v10->mBuffers
        || mBuffers >= (unint64_t)&v10->mBuffers[v8])
      {
        break;
      }
      *(_QWORD *)(mBuffers + 8) = v16;
      ++v11;
      *(_DWORD *)mBuffers = 1;
      *(_DWORD *)(mBuffers + 4) = v12;
      mBuffers += 16;
      if (!--v14)
        goto LABEL_13;
    }
LABEL_19:
    __break(0x5519u);
  }
LABEL_13:
  if (AudioConverterFillComplexBuffer(*((AudioConverterRef *)inInputDataProcUserData + 11), (AudioConverterComplexInputDataProc)NilDecodeProc, inInputDataProcUserData, &ioOutputDataPacketSize, v10, 0))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        DecodeNilPacket_cold_1();
    }
  }
  *a4 = v9 * v8 * inInputDataProcUserData[16];
  if ((a3 & 0x80000000) != 0)
    goto LABEL_19;
  FillGap(a2, a3, v9, ioOutputDataPacketSize, inInputDataProcUserData[16], v8);
  return 0;
}

void FillGap(char *__src, unsigned int a2, int a3, int a4, int a5, int a6)
{
  char *v6;
  int v7;
  size_t v8;
  size_t v9;
  size_t v10;
  char *v11;
  char *v12;
  uint64_t v14;
  size_t v15;
  char *v16;
  BOOL v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v22;

  v6 = __src;
  if (a4)
  {
    v20 = (a3 - a4);
    if ((int)v20 >= 1)
    {
      v7 = 0;
      v8 = a5;
      v19 = (int)v20 * (uint64_t)a5;
      v9 = a5 * a4;
      v22 = a5 * (uint64_t)a3;
LABEL_4:
      if (v7 != a6)
      {
        v10 = a2;
        if (v9 <= a2)
        {
          v11 = &v6[a2];
          v12 = &v6[v19];
          if (&v6[v19] <= v11 && v6 <= v12 && v11 - v12 >= v9)
          {
            memmove(&v6[v19], v6, v9);
            if (v11 - v12 >= v8)
            {
              v14 = v20;
              v15 = v10;
              v16 = v6;
              while (v16 <= v11)
              {
                if (v6 > v16)
                  break;
                v17 = v15 >= v8;
                v15 -= v8;
                if (!v17)
                  break;
                memcpy(v16, v12, v8);
                v16 += v8;
                if (!--v14)
                {
                  v18 = &v6[v22];
                  if (&v6[v22] <= v11 && v6 <= v18)
                  {
                    a2 = v10 - v22;
                    if ((((_DWORD)v10 - (_DWORD)v22) & 0x80000000) == 0)
                    {
                      ++v7;
                      v6 += v22;
                      if (v11 - v18 >= (int)a2)
                        goto LABEL_4;
                    }
                  }
                  break;
                }
              }
            }
          }
        }
        __break(0x5519u);
      }
    }
  }
  else
  {
    bzero(__src, a2);
  }
}

uint64_t SoundDec_Decode(uint64_t a1, const void *a2, unsigned int a3, char *a4, signed int a5, int *a6, int a7)
{
  OpaqueAudioConverter *v10;
  int v14;
  unsigned int v15;
  uint64_t v16;
  size_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  void *v22;
  unsigned int v23;
  double v24;
  double v25;
  double v26;
  unint64_t v27;
  UInt32 v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  BOOL v32;
  size_t v33;
  int v34;
  UInt32 v35;
  AudioBufferList *v36;
  uint64_t v37;
  int v38;
  signed int v39;
  char *v40;
  uint64_t v41;
  unint64_t mBuffers;
  char *v43;
  BOOL v44;
  OSStatus v45;
  OSStatus v46;
  NSObject *v47;
  char *v48;
  int v49;
  const char *v50;
  uint64_t v51;
  NSObject *v52;
  _BYTE v54[4];
  int v55;
  char *v56;
  uint64_t v57;
  unsigned int v58;
  UInt32 ioOutputDataPacketSize;
  uint8_t buf[4];
  uint64_t v61;
  __int16 v62;
  const char *v63;
  __int16 v64;
  int v65;
  __int16 v66;
  _BYTE v67[10];
  int v68;
  __int16 v69;
  char *v70;
  __int16 v71;
  int v72;
  __int16 v73;
  OSStatus v74;
  __int16 v75;
  const char *v76;
  uint64_t v77;

  v77 = *MEMORY[0x1E0C80C00];
  ioOutputDataPacketSize = -1431655766;
  if (a1 && (v10 = *(OpaqueAudioConverter **)(a1 + 88)) != 0)
  {
    v14 = *(_DWORD *)(a1 + 80);
    v15 = v14 & 0xFFFF0000;
    v58 = v14 & 0xFFFF0000;
    if (a7)
    {
      v16 = AudioConverterReset(v10);
      if (a2)
      {
        if (v15 == 0x100000 || v15 == 655360)
        {
          if (*(_DWORD *)(a1 + 180))
          {
            v17 = *a6;
            MEMORY[0x1E0C80A78](v16);
            if ((_DWORD)v17)
            {
              memset(&v54[-((v17 + 15) & 0x1FFFFFFF0)], 170, v17);
              if ((v17 & 0x80000000) != 0)
                goto LABEL_75;
            }
            DecodeNilPacket((unsigned int *)a1, &v54[-((v17 + 15) & 0x1FFFFFFF0)], v17, buf);
          }
          v18 = (int)a3;
LABEL_21:
          if ((a3 & 0x80000000) != 0)
            goto LABEL_75;
          *(_QWORD *)(a1 + 104) = v18;
          *(_QWORD *)(a1 + 112) = v18;
          *(_QWORD *)(a1 + 96) = a2;
          goto LABEL_25;
        }
LABEL_15:
        v18 = (int)a3;
        if (v15 == 0x1000000)
        {
          if ((a3 & 0x80000000) != 0)
            goto LABEL_75;
          v20 = *(_QWORD *)(a1 + 96);
          v21 = v20 + *(_QWORD *)(a1 + 104);
          v22 = (void *)(v20 + *(_QWORD *)(a1 + 112));
          if ((unint64_t)v22 > v21 || v20 > (unint64_t)v22 || v21 - (unint64_t)v22 < (int)a3)
            goto LABEL_75;
          memcpy(v22, a2, (int)a3);
          *(_QWORD *)(a1 + 112) += (int)a3;
          goto LABEL_25;
        }
        goto LABEL_21;
      }
    }
    else if (a2)
    {
      goto LABEL_15;
    }
    if (*(_QWORD *)(a1 + 112) && v15 == 0x1000000)
    {
LABEL_25:
      v23 = (v14 - 0x10000) >> 16;
      if (v23 > 4 || v23 == 2)
      {
        v30 = *a6;
        v29 = *(_DWORD *)(a1 + 64);
        v28 = *a6 / v29 / *(_DWORD *)(a1 + 68);
      }
      else
      {
        v24 = *(double *)(a1 + 40);
        v25 = v24 * (double)(a3 / *(_DWORD *)(a1 + 28));
        LODWORD(v24) = *(_DWORD *)(a1 + 60);
        v26 = v25 / (double)*(unint64_t *)&v24;
        v27 = *(_QWORD *)a1;
        LODWORD(v27) = *(_DWORD *)(a1 + 24);
        v28 = (v26 / *(double *)a1 / (double)v27);
        v29 = *(_DWORD *)(a1 + 64);
        v30 = *a6;
      }
      ioOutputDataPacketSize = v28;
      if (v29)
      {
        v35 = v30 / v29;
        if (v28 > v35)
        {
          ioOutputDataPacketSize = v35;
          v28 = v35;
        }
      }
      v36 = *(AudioBufferList **)(a1 + 152);
      v37 = *(unsigned int *)(a1 + 68);
      v36->mNumberBuffers = v37;
      if ((_DWORD)v37)
      {
        v38 = 0;
        v39 = v30 / v37;
        v40 = &a4[a5];
        v41 = v37;
        mBuffers = (unint64_t)v36->mBuffers;
        while (1)
        {
          v43 = &a4[v39 * v38];
          v44 = v43 <= v40 && v43 >= a4;
          if (!v44
            || v39 < 0
            || v40 - v43 < v39
            || mBuffers < (unint64_t)v36->mBuffers
            || mBuffers >= (unint64_t)&v36->mBuffers[v37])
          {
            break;
          }
          *(_QWORD *)(mBuffers + 8) = v43;
          ++v38;
          *(_DWORD *)mBuffers = 1;
          *(_DWORD *)(mBuffers + 4) = v39;
          mBuffers += 16;
          if (!--v41)
            goto LABEL_51;
        }
LABEL_75:
        __break(0x5519u);
      }
LABEL_51:
      v45 = AudioConverterFillComplexBuffer(*(AudioConverterRef *)(a1 + 88), (AudioConverterComplexInputDataProc)SoundDec_DataProc, (void *)a1, &ioOutputDataPacketSize, v36, 0);
      if (v45)
      {
        v46 = v45;
        v19 = 2147811332;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          v57 = VRTraceErrorLogLevelToCSTR();
          v47 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v56 = FourccToCStr(*(_DWORD *)(a1 + 8));
            v55 = (int)*(double *)a1;
            v48 = FourccToCStr(*(_DWORD *)(a1 + 48));
            v49 = (int)*(double *)(a1 + 40);
            v50 = " (AVC Out of Data error)";
            if (v46 != 95)
              v50 = "";
            *(_DWORD *)buf = 136317186;
            v61 = v57;
            v62 = 2080;
            v63 = "SoundDec_Decode";
            v64 = 1024;
            v65 = 1159;
            v66 = 2080;
            *(_QWORD *)v67 = v56;
            *(_WORD *)&v67[8] = 1024;
            v68 = v55;
            v69 = 2080;
            v70 = v48;
            v71 = 1024;
            v72 = v49;
            v73 = 1024;
            v74 = v46;
            v75 = 2080;
            v76 = v50;
            _os_log_impl(&dword_1D8A54000, v47, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d AudioConverter (%s/%d -> %s/%d) returned error %d%s during FillComplexBuffer.", buf, 0x4Cu);
          }
        }
      }
      else
      {
        v19 = 0;
      }
      if (ioOutputDataPacketSize < v28)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          v51 = VRTraceErrorLogLevelToCSTR();
          v52 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136316162;
            v61 = v51;
            v62 = 2080;
            v63 = "SoundDec_Decode";
            v64 = 1024;
            v65 = 1164;
            v66 = 1024;
            *(_DWORD *)v67 = ioOutputDataPacketSize;
            *(_WORD *)&v67[4] = 1024;
            *(_DWORD *)&v67[6] = v28;
            _os_log_impl(&dword_1D8A54000, v52, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Error filling a gap? packets[%d] < full_packets[%d]", buf, 0x28u);
          }
        }
        if (v28 - ioOutputDataPacketSize < 2)
        {
          v28 = ioOutputDataPacketSize;
        }
        else
        {
          if (a5 < 0)
            goto LABEL_75;
          FillGap(a4, a5, v28, ioOutputDataPacketSize, *(_DWORD *)(a1 + 56), v37);
        }
      }
      v34 = *(_DWORD *)(a1 + 56) * v28 * *(_DWORD *)(a1 + 68);
      if (v58 == 655360)
      {
        if (a4 && a5 < 1)
          goto LABEL_75;
        _SoundDec_ScaleSpeex(a1, (float *)a4, v28);
      }
      goto LABEL_70;
    }
    v31 = (v14 - 0x10000) >> 16;
    v32 = v31 > 4 || v31 == 2;
    if (!v32 || !*(_DWORD *)(a1 + 180))
    {
      if (a5 < 0)
        goto LABEL_75;
      v33 = *a6;
      if (v33 > a5)
        goto LABEL_75;
      bzero(a4, v33);
      v19 = 0;
      v34 = *a6;
LABEL_70:
      *a6 = v34;
      return v19;
    }
    if (a5 < 0)
      goto LABEL_75;
    DecodeNilPacket((unsigned int *)a1, a4, a5, a6);
    return 0;
  }
  else
  {
    if (a5 < 0)
      goto LABEL_75;
    bzero(a4, a5);
    return 2147811329;
  }
}

uint64_t SoundDec_DataProc(uint64_t a1, signed int *a2, unsigned int *a3, _QWORD *a4, unint64_t a5)
{
  unint64_t v9;
  signed int v10;
  size_t v11;
  size_t v12;
  _BYTE *v13;
  char *v14;
  char *v15;
  size_t v16;
  size_t v17;
  uint64_t result;
  int v19;
  int v20;
  int v21;
  unsigned int v22;
  signed int v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  signed int v29;
  unsigned int *v30;
  unsigned int *v31;
  unsigned int *v32;
  unint64_t v33;
  unsigned int *v34;
  BOOL v35;
  unsigned int *v36;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v43;
  unsigned int *v44;
  int __n[3];

  *(_QWORD *)&__n[1] = *MEMORY[0x1E0C80C00];
  v9 = a5 + 272;
  v10 = *a2;
  v11 = *(_QWORD *)(a5 + 112);
  if (v11)
  {
    if (*(_DWORD *)(a5 + 172) <= (int)v11)
    {
      __n[0] = *(_QWORD *)(a5 + 112);
      if (v9 <= a5)
        goto LABEL_72;
      ExpandCallbackBuffer(a5, __n);
      v11 = __n[0];
      *(_QWORD *)(a5 + 112) = __n[0];
    }
    v12 = *(int *)(a5 + 172);
    v13 = *(_BYTE **)(a5 + 160);
    if (*(_DWORD *)(a5 + 8) == 1953790320)
    {
      if (!*(_QWORD *)(a5 + 104))
        goto LABEL_72;
      if ((v12 & 0x80000000) != 0)
        goto LABEL_72;
      if (!(_DWORD)v12)
        goto LABEL_72;
      *v13 = **(_BYTE **)(a5 + 96);
      *(_DWORD *)(a5 + 168) = 1;
      v14 = *(char **)(a5 + 96);
      v15 = v14 + 1;
      if (v14 >= v14 + 1)
        goto LABEL_72;
      v16 = *(_QWORD *)(a5 + 104);
      if (v15 > &v14[v16])
        goto LABEL_72;
      v17 = *(_QWORD *)(a5 + 112) - 1;
      if (v17 > v16 - 1 || v17 > v16)
        goto LABEL_72;
      memmove(v14, v15, v17);
      --*(_QWORD *)(a5 + 112);
    }
    else
    {
      if (v11 > *(_QWORD *)(a5 + 104) || (v12 & 0x80000000) != 0 || v11 > v12)
        goto LABEL_72;
      memcpy(v13, *(const void **)(a5 + 96), v11);
      *(_DWORD *)(a5 + 168) = *(_QWORD *)(a5 + 112);
      *(_QWORD *)(a5 + 96) = 0;
      *(_QWORD *)(a5 + 104) = 0;
      *(_QWORD *)(a5 + 112) = 0;
    }
  }
  else if (*(int *)(a5 + 168) <= 0)
  {
    *a2 = 0;
    return 95;
  }
  v19 = *(unsigned __int16 *)(a5 + 82) << 16;
  if (v19 != 720896 && v19 != 0x100000)
  {
    v20 = *(_DWORD *)(a5 + 8);
    if (v20 <= 1935764849)
    {
      if (v20 > 1735091042)
      {
        if (v20 == 1735091043)
          goto LABEL_35;
        v21 = 1869641075;
      }
      else
      {
        if (v20 == 1633903462)
          goto LABEL_35;
        v21 = 1685354616;
      }
      goto LABEL_34;
    }
    if (v20 <= 1936029298)
    {
      if (v20 == 1935764850)
        goto LABEL_35;
      v21 = 1935767394;
      goto LABEL_34;
    }
    if (v20 != 1936029299 && v20 != 1953790320)
    {
      v21 = 1936745848;
LABEL_34:
      if (v20 == v21)
        goto LABEL_35;
      v23 = (*(_DWORD *)(a5 + 168) / *(_DWORD *)(a5 + 16)) / *(_DWORD *)(a5 + 28);
      *a2 = v23;
      if (v23 >= v10 || *(_DWORD *)(a5 + 176) || (*(_DWORD *)(a5 + 80) & 0xFFFE0000 | 0x10000) == 0x50000)
      {
LABEL_47:
        v26 = *a3;
        if ((_DWORD)v26)
        {
          v27 = 0;
          v28 = 0;
          v29 = *(_DWORD *)(a5 + 168) / v26;
          v30 = *(unsigned int **)(a5 + 144);
          v31 = a3 + 2;
          v32 = v30 + 2;
          v33 = (unint64_t)&a3[4 * v26 + 2];
          do
          {
            if (v30)
            {
              v34 = &v30[v27 + 2];
              v35 = v34 < v32 || v34 >= &v32[4 * *v30];
              v36 = &a3[v27 + 2];
              if (v35 || v36 < v31 || (unint64_t)v36 >= v33)
                goto LABEL_72;
              *(_QWORD *)&a3[v27 + 4] = *(_QWORD *)&v30[v27 + 4];
              *(_QWORD *)v36 = *(_QWORD *)v34;
            }
            else
            {
              v39 = *(_QWORD *)(a5 + 160);
              v40 = v39 + *(int *)(a5 + 172);
              v41 = v39 + v28 * v29;
              if (v41 > v40 || v39 > v41)
                goto LABEL_72;
              if (v29 < 0)
                goto LABEL_72;
              if ((uint64_t)(v40 - v41) < v29)
                goto LABEL_72;
              v43 = (unint64_t)&a3[v27 + 2];
              if (v43 < (unint64_t)v31 || v43 >= v33)
                goto LABEL_72;
              v44 = &a3[v27];
              *((_QWORD *)v44 + 2) = v41;
              v44[3] = v29;
            }
            ++v28;
            v27 += 4;
            LODWORD(v26) = v26 - 1;
          }
          while ((_DWORD)v26);
        }
        result = 0;
        goto LABEL_37;
      }
      v24 = *(_DWORD *)(a5 + 16) * v10;
      __n[0] = v24;
      v25 = *(_DWORD *)(a5 + 172);
      if ((int)v24 > (int)v25)
      {
        if (v9 <= a5)
          goto LABEL_72;
        ExpandCallbackBuffer(a5, __n);
        v25 = *(_DWORD *)(a5 + 172);
        v24 = __n[0];
      }
      if ((v25 & 0x80000000) == 0 && v24 <= v25)
      {
        bzero(*(void **)(a5 + 160), v24);
        *(_DWORD *)(a5 + 168) = v24;
        *a2 = v24 / *(_DWORD *)(a5 + 16);
        *(_DWORD *)(a5 + 176) = 1;
        goto LABEL_47;
      }
LABEL_72:
      __break(0x5519u);
    }
  }
LABEL_35:
  a3[2] = 1;
  v22 = *(_DWORD *)(a5 + 168);
  a3[3] = v22;
  *((_QWORD *)a3 + 2) = *(_QWORD *)(a5 + 160);
  *(_QWORD *)(a5 + 128) = 0;
  *(_DWORD *)(a5 + 140) = v22;
  if (v9 <= a5)
    goto LABEL_72;
  result = 0;
  *a4 = a5 + 128;
  *a2 = 1;
LABEL_37:
  *(_DWORD *)(a5 + 168) = 0;
  return result;
}

void _SoundDec_ScaleSpeex(uint64_t a1, float *__A, int a3)
{
  uint64_t v5;
  char *v6;
  _QWORD v7[2];

  v7[1] = *MEMORY[0x1E0C80C00];
  if ((*(_BYTE *)(a1 + 52) & 1) != 0)
  {
    vDSP_vsmul(__A, 1, &_SoundDec_ScaleSpeex_speexScale, __A, 1, a3);
  }
  else
  {
    MEMORY[0x1E0C80A78](a1);
    v6 = (char *)v7 - v5;
    if (a3)
    {
      memset(v6, 170, 2 * a3);
      VSMUL_Q15_Portable((__int16 *)__A, 0x2000, v6, a3);
      VADD_Q15_Portable((__int16 *)__A, (__int16 *)v6, (__int16 *)__A, a3);
    }
    else
    {
      __break(0x5519u);
    }
  }
}

uint64_t _SoundDec_HandleCodecModeRequest(uint64_t a1)
{
  OSStatus v2;
  int ErrorLogLevelForModule;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  int v7;
  __int128 v9;
  uint8_t buf[4];
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 220))
  {
    v4 = 0;
    goto LABEL_18;
  }
  v9 = *(_OWORD *)(a1 + 204);
  if (*(_DWORD *)(a1 + 48) == 1936029299 || *(_DWORD *)(a1 + 8) == 1936029299)
  {
    v2 = AudioConverterSetProperty(*(AudioConverterRef *)(a1 + 88), 0x5E636D72u, 0x10u, &v9);
    ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    if (!v2)
    {
      if (ErrorLogLevelForModule >= 7)
      {
        v5 = VRTraceErrorLogLevelToCSTR();
        v6 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316674;
          v11 = v5;
          v12 = 2080;
          v13 = "_SoundDec_SetEVSCMRInternal";
          v14 = 1024;
          v15 = 1837;
          v16 = 1024;
          v17 = v9;
          v18 = 1024;
          v19 = DWORD1(v9);
          v20 = 1024;
          v21 = DWORD2(v9);
          v22 = 1024;
          v23 = HIDWORD(v9);
          _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d AudioConverterSetProperty succeeded to set property kAudioCodecPrivatePropertyCMR mode=%u bandwidth=%u offset=%u indicator=%u", buf, 0x34u);
        }
      }
      v4 = 0;
      goto LABEL_17;
    }
    v4 = 2147811332;
    if (ErrorLogLevelForModule >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _SoundDec_HandleCodecModeRequest_cold_4();
    }
  }
  else
  {
    v4 = 2147811329;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _SoundDec_HandleCodecModeRequest_cold_3();
  }
LABEL_17:
  *(_BYTE *)(a1 + 220) = 0;
LABEL_18:
  if (*(_BYTE *)(a1 + 222))
  {
    v4 = _SoundDec_SetAMRCMRInternal(a1, *(_BYTE *)(a1 + 221));
    if ((v4 & 0x80000000) != 0 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _SoundDec_HandleCodecModeRequest_cold_2();
    }
    v7 = (*(_BYTE *)(a1 + 223))++ + 1;
    if (v7 == 4)
    {
      v4 = _SoundDec_SetAMRCMRInternal(a1, 0xFu);
      if ((v4 & 0x80000000) != 0 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _SoundDec_HandleCodecModeRequest_cold_1();
      }
      *(_BYTE *)(a1 + 222) = 0;
    }
  }
  return v4;
}

uint64_t _SoundDec_SetAMRCMRInternal(uint64_t a1, unsigned __int8 a2)
{
  uint64_t v2;
  int v3;
  int v5;
  OSStatus v7;
  int ErrorLogLevelForModule;
  uint64_t v9;
  NSObject *v10;
  unsigned __int8 inPropertyData;
  uint8_t buf[4];
  uint64_t v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v2 = 2147811332;
  inPropertyData = a2;
  if (!a1)
    return 2147811329;
  v3 = *(_DWORD *)(a1 + 48);
  if (v3 != 1935764850 && v3 != 1935767394)
  {
    v5 = *(_DWORD *)(a1 + 8);
    if (v5 != 1935767394 && v5 != 1935764850)
      return 2147811329;
  }
  v7 = AudioConverterSetProperty(*(AudioConverterRef *)(a1 + 88), 0x5E636D72u, 1u, &inPropertyData);
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (!v7)
  {
    if (ErrorLogLevelForModule >= 7)
    {
      v9 = VRTraceErrorLogLevelToCSTR();
      v10 = *MEMORY[0x1E0CF2758];
      v2 = 0;
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        return v2;
      *(_DWORD *)buf = 136315906;
      v14 = v9;
      v15 = 2080;
      v16 = "_SoundDec_SetAMRCMRInternal";
      v17 = 1024;
      v18 = 1854;
      v19 = 1024;
      v20 = inPropertyData;
      _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d AudioConverterSetProperty succeeded to set property kAudioCodecPrivatePropertyCMR mode=%u", buf, 0x22u);
    }
    return 0;
  }
  if (ErrorLogLevelForModule >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _SoundDec_SetAMRCMRInternal_cold_1();
  }
  return v2;
}

void SoundDec_Encode(uint64_t a1, uint64_t a2, int a3, void *a4, unsigned int a5, UInt32 *a6, AudioStreamPacketDescription *a7, int a8)
{
  OpaqueAudioConverter *v12;
  OSStatus v15;
  int ErrorLogLevelForModule;
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;
  NSObject *v20;
  unsigned int v21;
  int v22;
  OSStatus v23;
  unint64_t v24;
  OSStatus v25;
  OSStatus v26;
  int v27;
  uint64_t v28;
  NSObject *v29;
  uint64_t v30;
  NSObject *v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  OSStatus v37;
  int v38;
  uint64_t v39;
  NSObject *v40;
  uint64_t v41;
  NSObject *v42;
  int v43;
  int v44;
  unsigned int v45;
  int v46;
  unint64_t v47;
  unint64_t v48;
  unsigned int v49;
  UInt32 v50;
  double v51;
  double v52;
  double v53;
  double v54;
  unsigned int v55;
  UInt32 v56;
  uint64_t v57;
  OSStatus v58;
  OSStatus v59;
  int v60;
  uint64_t v61;
  NSObject *v62;
  NSObject *v63;
  char *v64;
  int v65;
  char *v66;
  int v67;
  const char *v68;
  UInt32 v69;
  char *v70;
  int v71;
  char *v72;
  int v73;
  const char *v74;
  uint64_t v75;
  NSObject *log;
  UInt32 ioOutputDataPacketSize;
  unsigned int v78;
  int v79;
  int inPropertyData;
  uint8_t buf[4];
  uint64_t v82;
  __int16 v83;
  const char *v84;
  __int16 v85;
  int v86;
  __int16 v87;
  _BYTE v88[10];
  char *v89;
  _BYTE v90[6];
  __int16 v91;
  char *v92;
  __int16 v93;
  int v94;
  __int16 v95;
  OSStatus v96;
  __int16 v97;
  const char *v98;
  __int16 v99;
  int v100;
  __int16 v101;
  UInt32 v102;
  uint64_t v103;

  v103 = *MEMORY[0x1E0C80C00];
  ioOutputDataPacketSize = -1431655766;
  if (a1 && a7 && a2 && (v12 = *(OpaqueAudioConverter **)(a1 + 88)) != 0)
  {
    if (a8)
      AudioConverterReset(v12);
    if (*(_DWORD *)(a1 + 240) != *(_DWORD *)(a1 + 232) || *(_DWORD *)(a1 + 244) != *(_DWORD *)(a1 + 236))
      _SoundDec_SetEVSRFParams(a1, (OSStatus *)(a1 + 232));
    if (*(_BYTE *)(a1 + 228))
    {
      inPropertyData = *(_DWORD *)(a1 + 224);
      if (*(_DWORD *)(a1 + 48) == 1936029299 || *(_DWORD *)(a1 + 8) == 1936029299)
      {
        v15 = AudioConverterSetProperty(*(AudioConverterRef *)(a1 + 88), 0x5E626477u, 4u, &inPropertyData);
        ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
        if (v15)
        {
          if (ErrorLogLevelForModule >= 3)
          {
            v17 = VRTraceErrorLogLevelToCSTR();
            v18 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136316162;
              v82 = v17;
              v83 = 2080;
              v84 = "_SoundDec_SetEVSAudioCodecPropertyMaxBandwidth";
              v85 = 1024;
              v86 = 1754;
              v87 = 1024;
              *(_DWORD *)v88 = inPropertyData;
              *(_WORD *)&v88[4] = 1024;
              *(_DWORD *)&v88[6] = v15;
              _os_log_error_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_ERROR, " [%s] %s:%d AudioConverterSetProperty failed to set property kAudioCodecPrivatePropertyAdjustMaxBandwidth for bandwidth=%u with error %08x", buf, 0x28u);
            }
          }
        }
        else if (ErrorLogLevelForModule >= 6)
        {
          v19 = VRTraceErrorLogLevelToCSTR();
          v20 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315906;
            v82 = v19;
            v83 = 2080;
            v84 = "_SoundDec_SetEVSAudioCodecPropertyMaxBandwidth";
            v85 = 1024;
            v86 = 1757;
            v87 = 1024;
            *(_DWORD *)v88 = inPropertyData;
            _os_log_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d AudioConverterSetProperty succeeded to set property kAudioCodecPrivatePropertyAdjustMaxBandwidth bandwidth=%u", buf, 0x22u);
          }
        }
      }
      *(_BYTE *)(a1 + 228) = 0;
    }
    v21 = *(_DWORD *)(a1 + 200);
    if (v21 != *(_DWORD *)(a1 + 196))
    {
      v22 = *(unsigned __int8 *)(a1 + 184);
      inPropertyData = *(_DWORD *)(a1 + 200);
      if (*(_DWORD *)(a1 + 188))
      {
        v79 = (int)BitrateToQuality(*(unsigned __int16 *)(a1 + 86) << 16, v21, *(double *)(a1 + 40), *(_DWORD *)(a1 + 68));
        v23 = AudioConverterSetProperty(*(AudioConverterRef *)(a1 + 88), 0x5E71616Cu, 4u, &v79);
        if (v22)
        {
          LODWORD(v24) = *(_DWORD *)(a1 + 60);
          v78 = ((double)v21 / (*(double *)(a1 + 40) / (double)v24));
          v25 = AudioConverterSetProperty(*(AudioConverterRef *)(a1 + 88), 0x70616B6Cu, 4u, &v78);
          if (v25)
          {
            v26 = v25;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              v75 = VRTraceErrorLogLevelToCSTR();
              log = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136316674;
                v82 = v75;
                v83 = 2080;
                v84 = "_SoundDec_SetBitrateInternal";
                v85 = 1024;
                v86 = 1381;
                v87 = 1024;
                *(_DWORD *)v88 = 1381;
                *(_WORD *)&v88[4] = 1024;
                *(_DWORD *)&v88[6] = v78;
                LOWORD(v89) = 1024;
                *(_DWORD *)((char *)&v89 + 2) = v21;
                HIWORD(v89) = 1024;
                *(_DWORD *)v90 = v26;
                _os_log_error_impl(&dword_1D8A54000, log, OS_LOG_TYPE_ERROR, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/SoundDec.c:%d: Failed to set max packet size[%d] for bitrate[%d] with err[%d]", buf, 0x34u);
              }
            }
          }
        }
      }
      else
      {
        v23 = AudioConverterSetProperty(*(AudioConverterRef *)(a1 + 88), 0x62726174u, 4u, &inPropertyData);
      }
      v27 = VRTraceGetErrorLogLevelForModule();
      if (v23)
      {
        if (v27 >= 3)
        {
          v28 = VRTraceErrorLogLevelToCSTR();
          v29 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136316418;
            v82 = v28;
            v83 = 2080;
            v84 = "_SoundDec_SetBitrateInternal";
            v85 = 1024;
            v86 = 1390;
            v87 = 1024;
            *(_DWORD *)v88 = 1390;
            *(_WORD *)&v88[4] = 1024;
            *(_DWORD *)&v88[6] = inPropertyData;
            LOWORD(v89) = 1024;
            *(_DWORD *)((char *)&v89 + 2) = v23;
            _os_log_error_impl(&dword_1D8A54000, v29, OS_LOG_TYPE_ERROR, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/SoundDec.c:%d: Failed to set bitrate[%d]: %d", buf, 0x2Eu);
          }
        }
      }
      else
      {
        if (v27 >= 7)
        {
          v30 = VRTraceErrorLogLevelToCSTR();
          v31 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v32 = *(_DWORD *)(a1 + 188);
            *(_DWORD *)buf = 136316418;
            v82 = v30;
            v83 = 2080;
            v84 = "_SoundDec_SetBitrateInternal";
            v85 = 1024;
            v86 = 1394;
            v87 = 1024;
            *(_DWORD *)v88 = inPropertyData;
            *(_WORD *)&v88[4] = 1024;
            *(_DWORD *)&v88[6] = v32;
            LOWORD(v89) = 1024;
            *(_DWORD *)((char *)&v89 + 2) = v22;
            _os_log_impl(&dword_1D8A54000, v31, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d NEW AUDIO BITRATE (vbr)=%d fvbrcodec=%d enablePacketSizeLimit=%d", buf, 0x2Eu);
          }
        }
        *(_DWORD *)(a1 + 196) = inPropertyData;
      }
    }
    v33 = *(unsigned __int8 *)(a1 + 260);
    if (*(unsigned __int8 *)(a1 + 248) != v33)
    {
      v34 = *(unsigned __int8 *)(a1 + 248);
      v35 = *(_DWORD *)(a1 + 252);
      v36 = *(_DWORD *)(a1 + 256);
      if (v33 != v34 || *(_DWORD *)(a1 + 264) != v35 || *(_DWORD *)(a1 + 268) != v36)
      {
        if (!*(_BYTE *)(a1 + 248))
          v36 = 0;
        inPropertyData = v36;
        v37 = AudioConverterSetProperty(*(AudioConverterRef *)(a1 + 88), 0x5E737262u, 4u, &inPropertyData);
        v38 = VRTraceGetErrorLogLevelForModule();
        if (v37)
        {
          if (v38 >= 3)
          {
            v39 = VRTraceErrorLogLevelToCSTR();
            v40 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136316162;
              v82 = v39;
              v83 = 2080;
              v84 = "_SoundDec_EnableShortREDInternal";
              v85 = 1024;
              v86 = 1915;
              v87 = 1024;
              *(_DWORD *)v88 = inPropertyData;
              *(_WORD *)&v88[4] = 1024;
              *(_DWORD *)&v88[6] = v37;
              _os_log_error_impl(&dword_1D8A54000, v40, OS_LOG_TYPE_ERROR, " [%s] %s:%d AudioConverterSetProperty failed to set kAudioCodecPrivatePropertyShortREDBitrate to shortREDBitrate=%u with error=%d", buf, 0x28u);
            }
          }
        }
        else
        {
          if (v38 >= 7)
          {
            v41 = VRTraceErrorLogLevelToCSTR();
            v42 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315906;
              v82 = v41;
              v83 = 2080;
              v84 = "_SoundDec_EnableShortREDInternal";
              v85 = 1024;
              v86 = 1918;
              v87 = 1024;
              *(_DWORD *)v88 = inPropertyData;
              _os_log_impl(&dword_1D8A54000, v42, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d AudioConverterSetProperty succeeded to set property kAudioCodecPrivatePropertyShortREDBitrate shortREDBitrate=%u", buf, 0x22u);
            }
          }
          *(_BYTE *)(a1 + 260) = v34;
          if (v34)
            v43 = v35;
          else
            v43 = 0;
          *(_DWORD *)(a1 + 264) = v43;
        }
      }
    }
    _SoundDec_HandleCodecModeRequest(a1);
    v44 = *(_DWORD *)(a1 + 84);
    v45 = v44 & 0xFFFF0000;
    v46 = *(_DWORD *)(a1 + 16) * a3 * *(_DWORD *)(a1 + 28);
    if ((v44 & 0xFFFF0000) != 0x1000000)
    {
      *(_QWORD *)(a1 + 144) = a2;
      *(_DWORD *)(a1 + 168) = v46;
      goto LABEL_63;
    }
    v47 = *(_QWORD *)(a2 + 16);
    v48 = *(unsigned int *)(a2 + 12);
    if (*(_BYTE *)(a1 + 120))
    {
      free(*(void **)(a1 + 96));
      *(_BYTE *)(a1 + 120) = 0;
    }
    if (v47 <= v47 + v48 && v46 <= v48)
    {
      *(_QWORD *)(a1 + 104) = v46;
      *(_QWORD *)(a1 + 112) = v46;
      *(_QWORD *)(a1 + 96) = v47;
LABEL_63:
      v49 = (v44 - 0x10000) >> 16;
      v50 = 1;
      if (v49 <= 4 && v49 != 2)
      {
        v51 = *(double *)(a1 + 40);
        v52 = v51 * (double)(v46 / *(_DWORD *)(a1 + 28));
        LODWORD(v51) = *(_DWORD *)(a1 + 60);
        v53 = v52 / (double)*(unint64_t *)&v51;
        v54 = *(double *)a1;
        LODWORD(v54) = *(_DWORD *)(a1 + 24);
        v50 = (v53 / *(double *)a1 / (double)*(unint64_t *)&v54);
      }
      ioOutputDataPacketSize = v50;
      v55 = *(_DWORD *)(a1 + 64);
      if (v55)
      {
        v56 = *a6 / v55;
        if (v50 > v56)
          ioOutputDataPacketSize = v56;
      }
      v57 = *(_QWORD *)(a1 + 152);
      *(_DWORD *)v57 = 1;
      *(_DWORD *)(v57 + 8) = 1;
      *(_DWORD *)(v57 + 12) = *a6;
      *(_QWORD *)(v57 + 16) = a4;
      v58 = AudioConverterFillComplexBuffer(*(AudioConverterRef *)(a1 + 88), (AudioConverterComplexInputDataProc)SoundDec_DataProc, (void *)a1, &ioOutputDataPacketSize, (AudioBufferList *)v57, a7);
      if (!v58)
        goto LABEL_86;
      v59 = v58;
      v60 = v45 == 0x1000000 ? 8 : 7;
      if (v60 > (int)VRTraceGetErrorLogLevelForModule())
        goto LABEL_86;
      v61 = VRTraceErrorLogLevelToCSTR();
      if (v45 == 0x1000000)
      {
        v62 = *MEMORY[0x1E0CF2758];
        v63 = *MEMORY[0x1E0CF2758];
        if (!*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v63, OS_LOG_TYPE_DEBUG))
          {
            v70 = FourccToCStr(*(_DWORD *)(a1 + 8));
            v71 = (int)*(double *)a1;
            v72 = FourccToCStr(*(_DWORD *)(a1 + 48));
            v73 = (int)*(double *)(a1 + 40);
            v74 = " (AVC Out of Data error)";
            if (v59 != 95)
              v74 = "";
            *(_DWORD *)buf = 136317954;
            v82 = v61;
            v83 = 2080;
            v84 = "SoundDec_Encode";
            v85 = 1024;
            v86 = 1293;
            v87 = 2080;
            *(_QWORD *)v88 = "SoundDec_Encode";
            *(_WORD *)&v88[8] = 2080;
            v89 = v70;
            *(_WORD *)v90 = 1024;
            *(_DWORD *)&v90[2] = v71;
            v91 = 2080;
            v92 = v72;
            v93 = 1024;
            v94 = v73;
            v95 = 1024;
            v96 = v59;
            v97 = 2080;
            v98 = v74;
            v99 = 1024;
            v100 = v46;
            v101 = 1024;
            v102 = ioOutputDataPacketSize;
            _os_log_debug_impl(&dword_1D8A54000, v62, OS_LOG_TYPE_DEBUG, " [%s] %s:%d %s AudioConverter (%s/%d -> %s/%d) returned error %d%s during FillComplexBuffer inBytes[%d] packets[%d].", buf, 0x62u);
          }
          goto LABEL_86;
        }
        if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
        {
          v64 = FourccToCStr(*(_DWORD *)(a1 + 8));
          v65 = (int)*(double *)a1;
          v66 = FourccToCStr(*(_DWORD *)(a1 + 48));
          v67 = (int)*(double *)(a1 + 40);
          v68 = " (AVC Out of Data error)";
          v69 = ioOutputDataPacketSize;
          if (v59 != 95)
            v68 = "";
LABEL_84:
          *(_DWORD *)buf = 136317954;
          v82 = v61;
          v83 = 2080;
          v84 = "SoundDec_Encode";
          v85 = 1024;
          v86 = 1293;
          v87 = 2080;
          *(_QWORD *)v88 = "SoundDec_Encode";
          *(_WORD *)&v88[8] = 2080;
          v89 = v64;
          *(_WORD *)v90 = 1024;
          *(_DWORD *)&v90[2] = v65;
          v91 = 2080;
          v92 = v66;
          v93 = 1024;
          v94 = v67;
          v95 = 1024;
          v96 = v59;
          v97 = 2080;
          v98 = v68;
          v99 = 1024;
          v100 = v46;
          v101 = 1024;
          v102 = v69;
          _os_log_impl(&dword_1D8A54000, v62, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d %s AudioConverter (%s/%d -> %s/%d) returned error %d%s during FillComplexBuffer inBytes[%d] packets[%d].", buf, 0x62u);
        }
      }
      else
      {
        v62 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v64 = FourccToCStr(*(_DWORD *)(a1 + 8));
          v65 = (int)*(double *)a1;
          v66 = FourccToCStr(*(_DWORD *)(a1 + 48));
          v67 = (int)*(double *)(a1 + 40);
          v68 = " (AVC Out of Data error)";
          v69 = ioOutputDataPacketSize;
          if (v59 != 95)
            v68 = "";
          goto LABEL_84;
        }
      }
LABEL_86:
      *a6 = ioOutputDataPacketSize;
      return;
    }
  }
  else if ((a5 & 0x80000000) == 0)
  {
    bzero(a4, a5);
    return;
  }
  __break(0x5519u);
}

uint64_t _SoundDec_SetEVSRFParams(uint64_t a1, OSStatus *inPropertyData)
{
  uint64_t v2;
  OSStatus v5;
  OSStatus v6;
  uint64_t v7;
  NSObject *v8;
  OSStatus v9;
  uint64_t v10;
  NSObject *v11;
  OSStatus v12;
  OSStatus v13;
  int v15;
  uint64_t v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  OSStatus v22;
  __int16 v23;
  OSStatus v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v2 = 2147811329;
  if (a1 && (*(_DWORD *)(a1 + 48) == 1936029299 || *(_DWORD *)(a1 + 8) == 1936029299))
  {
    v5 = AudioConverterSetProperty(*(AudioConverterRef *)(a1 + 88), 0x5E726670u, 8u, inPropertyData);
    if (!v5)
    {
      *(_QWORD *)(a1 + 240) = *(_QWORD *)inPropertyData;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
      {
        v10 = VRTraceErrorLogLevelToCSTR();
        v11 = *MEMORY[0x1E0CF2758];
        v2 = 0;
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          return v2;
        v12 = *inPropertyData;
        v13 = inPropertyData[1];
        v15 = 136316162;
        v16 = v10;
        v17 = 2080;
        v18 = "_SoundDec_SetEVSRFParams";
        v19 = 1024;
        v20 = 1516;
        v21 = 1024;
        v22 = v12;
        v23 = 1024;
        v24 = v13;
        _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d AudioConverterSetProperty succeeded to set property kAudioCodecPrivatePropertyEVSRFParams offset=%d indicator=%d", (uint8_t *)&v15, 0x28u);
      }
      return 0;
    }
    v6 = v5;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v7 = VRTraceErrorLogLevelToCSTR();
      v8 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v9 = *inPropertyData;
        v15 = 136316162;
        v16 = v7;
        v17 = 2080;
        v18 = "_SoundDec_SetEVSRFParams";
        v19 = 1024;
        v20 = 1511;
        v21 = 1024;
        v22 = v9;
        v23 = 1024;
        v24 = v6;
        _os_log_error_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_ERROR, " [%s] %s:%d AudioConverterSetProperty failed to set property kAudioCodecPrivatePropertyEVSRFParams %d with error %08x", (uint8_t *)&v15, 0x28u);
      }
    }
  }
  return v2;
}

uint64_t SoundDec_Reset(uint64_t a1)
{
  uint64_t result;
  OpaqueAudioConverter *v3;

  result = 2147811329;
  if (a1)
  {
    v3 = *(OpaqueAudioConverter **)(a1 + 88);
    if (v3)
    {
      AudioConverterReset(v3);
      return 0;
    }
  }
  return result;
}

uint64_t SoundDec_SetDTXPrimerSamples(uint64_t a1, void *inPropertyData, UInt32 a3)
{
  uint64_t v3;
  OpaqueAudioConverter *v4;
  OSStatus v7;
  int ErrorLogLevelForModule;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  NSObject *v12;
  int v14;
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  _BYTE v21[14];
  __int16 v22;
  UInt32 v23;
  __int16 v24;
  OSStatus v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v3 = 2147811329;
  if (a1)
  {
    v4 = *(OpaqueAudioConverter **)(a1 + 88);
    if (v4)
    {
      v7 = AudioConverterSetProperty(v4, 0x5E636E70u, a3, inPropertyData);
      ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
      if (!v7)
      {
        if (ErrorLogLevelForModule >= 7)
        {
          v11 = VRTraceErrorLogLevelToCSTR();
          v12 = *MEMORY[0x1E0CF2758];
          v3 = 0;
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            return v3;
          v14 = 136316162;
          v15 = v11;
          v16 = 2080;
          v17 = "SoundDec_SetDTXPrimerSamples";
          v18 = 1024;
          v19 = 1357;
          v20 = 2048;
          *(_QWORD *)v21 = inPropertyData;
          *(_WORD *)&v21[8] = 1024;
          *(_DWORD *)&v21[10] = a3;
          _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d AudioConverterSetProperty succeeded with dtx encoder primer sample buffer=%p bytes=%u", (uint8_t *)&v14, 0x2Cu);
        }
        return 0;
      }
      if (ErrorLogLevelForModule >= 3)
      {
        v9 = VRTraceErrorLogLevelToCSTR();
        v10 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v14 = 136316674;
          v15 = v9;
          v16 = 2080;
          v17 = "SoundDec_SetDTXPrimerSamples";
          v18 = 1024;
          v19 = 1354;
          v20 = 1024;
          *(_DWORD *)v21 = 1354;
          *(_WORD *)&v21[4] = 2048;
          *(_QWORD *)&v21[6] = inPropertyData;
          v22 = 1024;
          v23 = a3;
          v24 = 1024;
          v25 = v7;
          _os_log_error_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_ERROR, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/SoundDec.c:%d: Failed to set DTX encoder primer sample buffer[%p] bytes[%d] err[%d]", (uint8_t *)&v14, 0x38u);
        }
      }
    }
  }
  return v3;
}

uint64_t SoundDec_SetDTX(uint64_t a1, int a2)
{
  uint64_t v2;
  int v3;
  BOOL v4;
  int v5;
  BOOL v6;
  BOOL v7;
  BOOL v8;
  OSStatus v9;
  int ErrorLogLevelForModule;
  uint64_t v11;
  NSObject *v12;
  _BOOL4 inPropertyData;
  uint8_t buf[4];
  uint64_t v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  _BOOL4 v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v2 = 2147811329;
  if (a1)
  {
    v3 = *(_DWORD *)(a1 + 48);
    v4 = v3 == 1935764850 || v3 == 1935767394;
    if (v4
      || ((v5 = *(_DWORD *)(a1 + 8), v5 != 1935764850) ? (v6 = v3 == 1936029299) : (v6 = 1),
          !v6 ? (v7 = v5 == 1935767394) : (v7 = 1),
          !v7 ? (v8 = v5 == 1936029299) : (v8 = 1),
          v8))
    {
      inPropertyData = a2 != 0;
      v9 = AudioConverterSetProperty(*(AudioConverterRef *)(a1 + 88), 0x65736164u, 4u, &inPropertyData);
      ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
      if (!v9)
      {
        if (ErrorLogLevelForModule >= 7)
        {
          v11 = VRTraceErrorLogLevelToCSTR();
          v12 = *MEMORY[0x1E0CF2758];
          v2 = 0;
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            return v2;
          *(_DWORD *)buf = 136315906;
          v16 = v11;
          v17 = 2080;
          v18 = "SoundDec_SetDTX";
          v19 = 1024;
          v20 = 1441;
          v21 = 1024;
          v22 = inPropertyData;
          _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d AudioConverterSetProperty succeeded to set property kAudioCodecPrivatePropertyEnableSAD dtxEnabled=%u", buf, 0x22u);
        }
        return 0;
      }
      if (ErrorLogLevelForModule >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          SoundDec_SetDTX_cold_1();
      }
    }
  }
  return v2;
}

uint64_t SoundDec_SetEVSSIDPeriod(uint64_t a1, int a2)
{
  uint64_t v2;
  OSStatus v3;
  int ErrorLogLevelForModule;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  int inPropertyData;
  uint8_t buf[4];
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  __int16 v19;
  OSStatus v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v2 = 2147811329;
  inPropertyData = a2;
  if (a1 && (*(_DWORD *)(a1 + 48) == 1936029299 || *(_DWORD *)(a1 + 8) == 1936029299))
  {
    v3 = AudioConverterSetProperty(*(AudioConverterRef *)(a1 + 88), 0x73696470u, 4u, &inPropertyData);
    ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    if (!v3)
    {
      if (ErrorLogLevelForModule >= 7)
      {
        v7 = VRTraceErrorLogLevelToCSTR();
        v8 = *MEMORY[0x1E0CF2758];
        v2 = 0;
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          return v2;
        *(_DWORD *)buf = 136315906;
        v12 = v7;
        v13 = 2080;
        v14 = "SoundDec_SetEVSSIDPeriod";
        v15 = 1024;
        v16 = 1457;
        v17 = 1024;
        v18 = inPropertyData;
        _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d AudioConverterSetProperty succeeded to set property kAudioCodecPrivatePropertyEVSSIDPeriod evsSIDPeriod=%u ", buf, 0x22u);
      }
      return 0;
    }
    if (ErrorLogLevelForModule >= 3)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v6 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136316162;
        v12 = v5;
        v13 = 2080;
        v14 = "SoundDec_SetEVSSIDPeriod";
        v15 = 1024;
        v16 = 1454;
        v17 = 1024;
        v18 = inPropertyData;
        v19 = 1024;
        v20 = v3;
        _os_log_error_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_ERROR, " [%s] %s:%d AudioConverterSetProperty failed to set property kAudioCodecPrivatePropertyEVSSIDPeriod %d with error %08x", buf, 0x28u);
      }
    }
  }
  return v2;
}

uint64_t SoundDec_SetEVSCodecCMRMode(uint64_t a1, int a2)
{
  uint64_t v2;
  OSStatus v3;
  int ErrorLogLevelForModule;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  int inPropertyData;
  uint8_t buf[4];
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  __int16 v19;
  OSStatus v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v2 = 2147811329;
  inPropertyData = a2;
  if (a1 && (*(_DWORD *)(a1 + 48) == 1936029299 || *(_DWORD *)(a1 + 8) == 1936029299))
  {
    v3 = AudioConverterSetProperty(*(AudioConverterRef *)(a1 + 88), 0x63657673u, 4u, &inPropertyData);
    ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    if (!v3)
    {
      if (ErrorLogLevelForModule >= 7)
      {
        v7 = VRTraceErrorLogLevelToCSTR();
        v8 = *MEMORY[0x1E0CF2758];
        v2 = 0;
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          return v2;
        *(_DWORD *)buf = 136315906;
        v12 = v7;
        v13 = 2080;
        v14 = "SoundDec_SetEVSCodecCMRMode";
        v15 = 1024;
        v16 = 1472;
        v17 = 1024;
        v18 = inPropertyData;
        _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d AudioConverterSetProperty succeeded to set property kAudioCodecPrivatePropertyEVSCMRSettingInSDPOffer evsCMRMode=%d ", buf, 0x22u);
      }
      return 0;
    }
    if (ErrorLogLevelForModule >= 3)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v6 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136316162;
        v12 = v5;
        v13 = 2080;
        v14 = "SoundDec_SetEVSCodecCMRMode";
        v15 = 1024;
        v16 = 1469;
        v17 = 1024;
        v18 = inPropertyData;
        v19 = 1024;
        v20 = v3;
        _os_log_error_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_ERROR, " [%s] %s:%d AudioConverterSetProperty failed to set property kAudioCodecPrivatePropertyEVSCMRSettingInSDPOffer with evsCMRMode=%d with error=%08x", buf, 0x28u);
      }
    }
  }
  return v2;
}

uint64_t SoundDec_SetCodecInitialBitrate(uint64_t a1, int a2, int a3)
{
  OSStatus v5;
  int ErrorLogLevelForModule;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  NSObject *v13;
  OSStatus v14;
  int v15;
  uint64_t v16;
  NSObject *v17;
  uint64_t v18;
  NSObject *v19;
  int v20;
  unsigned int v22;
  int inPropertyData;
  uint8_t buf[4];
  uint64_t v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  int v31;
  __int16 v32;
  unsigned int v33;
  __int16 v34;
  int v35;
  __int16 v36;
  OSStatus v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  inPropertyData = a2;
  v5 = AudioConverterSetProperty(*(AudioConverterRef *)(a1 + 88), 0x62726174u, 4u, &inPropertyData);
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (v5)
  {
    v9 = 2147811329;
    if (ErrorLogLevelForModule >= 3)
    {
      v10 = VRTraceErrorLogLevelToCSTR();
      v11 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136316162;
        v25 = v10;
        v26 = 2080;
        v27 = "SoundDec_SetCodecInitialBitrate";
        v28 = 1024;
        v29 = 1485;
        v30 = 1024;
        v31 = inPropertyData;
        v32 = 1024;
        v33 = v5;
        _os_log_error_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_ERROR, " [%s] %s:%d AudioConverterSetProperty failed to set property kAudioCodecPropertyCurrentTargetBitRate for bitrate=%u with error %08x", buf, 0x28u);
      }
    }
  }
  else
  {
    if (ErrorLogLevelForModule >= 6)
    {
      v12 = VRTraceErrorLogLevelToCSTR();
      v13 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        v25 = v12;
        v26 = 2080;
        v27 = "SoundDec_SetCodecInitialBitrate";
        v28 = 1024;
        v29 = 1488;
        v30 = 1024;
        v31 = inPropertyData;
        _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d AudioConverterSetProperty succeeded to set property kAudioCodecPropertyCurrentTargetBitRate bitrate=%u", buf, 0x22u);
      }
    }
    if (a3)
    {
      LODWORD(v7) = inPropertyData;
      LODWORD(v8) = *(_DWORD *)(a1 + 60);
      v22 = ((double)v7 / (*(double *)(a1 + 40) / (double)v8));
      v14 = AudioConverterSetProperty(*(AudioConverterRef *)(a1 + 88), 0x70616B6Cu, 4u, &v22);
      v15 = VRTraceGetErrorLogLevelForModule();
      if (v14)
      {
        if (v15 >= 3)
        {
          v16 = VRTraceErrorLogLevelToCSTR();
          v17 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136316674;
            v25 = v16;
            v26 = 2080;
            v27 = "SoundDec_SetCodecInitialBitrate";
            v28 = 1024;
            v29 = 1494;
            v30 = 1024;
            v31 = 1494;
            v32 = 1024;
            v33 = v22;
            v34 = 1024;
            v35 = inPropertyData;
            v36 = 1024;
            v37 = v14;
            _os_log_error_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_ERROR, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/SoundDec.c:%d: Failed to set max packet size[%d] for bitrate[%d] with err[%d]", buf, 0x34u);
          }
        }
      }
      else if (v15 >= 7)
      {
        v18 = VRTraceErrorLogLevelToCSTR();
        v19 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315906;
          v25 = v18;
          v26 = 2080;
          v27 = "SoundDec_SetCodecInitialBitrate";
          v28 = 1024;
          v29 = 1496;
          v30 = 1024;
          v31 = v22;
          _os_log_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d AudioConverterSetProperty succeeded to set kAudioCodecPropertyPacketSizeLimitForVBR value=%d", buf, 0x22u);
        }
      }
    }
    v9 = 0;
    v20 = inPropertyData;
    *(_DWORD *)(a1 + 196) = inPropertyData;
    *(_DWORD *)(a1 + 200) = v20;
  }
  return v9;
}

uint64_t SoundDec_SetEVSChannelAwareOffset(uint64_t a1, int *a2)
{
  uint64_t result;
  uint64_t v5;
  NSObject *v6;
  _BOOL4 v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  result = 2147811329;
  if (a1 && (*(_DWORD *)(a1 + 48) == 1936029299 || *(_DWORD *)(a1 + 8) == 1936029299))
  {
    *(_QWORD *)(a1 + 232) = *(_QWORD *)a2;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v6 = *MEMORY[0x1E0CF2758];
      v7 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
      result = 0;
      if (!v7)
        return result;
      v8 = *a2;
      v9 = a2[1];
      v10 = 136316162;
      v11 = v5;
      v12 = 2080;
      v13 = "SoundDec_SetEVSChannelAwareOffset";
      v14 = 1024;
      v15 = 1525;
      v16 = 1024;
      v17 = v8;
      v18 = 1024;
      v19 = v9;
      _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d SoundDec_SetEVSChannelAwareOffset Requested EVSRFParams offset=%d indicator=%d", (uint8_t *)&v10, 0x28u);
    }
    return 0;
  }
  return result;
}

uint64_t SoundDec_SetEVSFormatHandling(uint64_t a1, int a2)
{
  uint64_t v2;
  int v3;
  OSStatus v4;
  int ErrorLogLevelForModule;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  NSObject *v9;
  int inPropertyData;
  uint8_t buf[4];
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  __int16 v20;
  OSStatus v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v2 = 2147811329;
  if (!a1 || *(_DWORD *)(a1 + 48) != 1936029299 && *(_DWORD *)(a1 + 8) != 1936029299)
    return v2;
  inPropertyData = 0;
  switch(a2)
  {
    case 3:
      v3 = 3;
      goto LABEL_10;
    case 2:
      v3 = 2;
      goto LABEL_10;
    case 1:
      v3 = 1;
LABEL_10:
      inPropertyData = v3;
      break;
  }
  v4 = AudioConverterSetProperty(*(AudioConverterRef *)(a1 + 88), 0x66657673u, 4u, &inPropertyData);
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (!v4)
  {
    if (ErrorLogLevelForModule >= 7)
    {
      v8 = VRTraceErrorLogLevelToCSTR();
      v9 = *MEMORY[0x1E0CF2758];
      v2 = 0;
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        return v2;
      *(_DWORD *)buf = 136315906;
      v13 = v8;
      v14 = 2080;
      v15 = "SoundDec_SetEVSFormatHandling";
      v16 = 1024;
      v17 = 1555;
      v18 = 1024;
      v19 = inPropertyData;
      _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d AudioConverterSetProperty succeeded to set property kAudioCodecPrivatePropertyEVSFormatHandling evsFormatHandling=%u", buf, 0x22u);
    }
    return 0;
  }
  if (ErrorLogLevelForModule >= 3)
  {
    v6 = VRTraceErrorLogLevelToCSTR();
    v7 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136316162;
      v13 = v6;
      v14 = 2080;
      v15 = "SoundDec_SetEVSFormatHandling";
      v16 = 1024;
      v17 = 1552;
      v18 = 1024;
      v19 = inPropertyData;
      v20 = 1024;
      v21 = v4;
      _os_log_error_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_ERROR, " [%s] %s:%d AudioConverterSetProperty failed to set property kAudioCodecPrivatePropertyEVSFormatHandling %d with error %08x", buf, 0x28u);
    }
  }
  return v2;
}

uint64_t SoundDec_SetEVSDecodeRF(uint64_t a1, int a2)
{
  uint64_t v2;
  OSStatus v4;
  int ErrorLogLevelForModule;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  NSObject *v9;
  _DWORD inPropertyData[2];
  uint8_t buf[4];
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  __int16 v20;
  OSStatus v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v2 = 2147811329;
  if (a1 && (*(_DWORD *)(a1 + 48) == 1936029299 || *(_DWORD *)(a1 + 8) == 1936029299))
  {
    inPropertyData[0] = -1431655935;
    inPropertyData[1] = a2;
    v4 = AudioConverterSetProperty(*(AudioConverterRef *)(a1 + 88), 0x5E647066u, 8u, inPropertyData);
    ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    if (!v4)
    {
      if (ErrorLogLevelForModule >= 7)
      {
        v8 = VRTraceErrorLogLevelToCSTR();
        v9 = *MEMORY[0x1E0CF2758];
        v2 = 0;
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          return v2;
        *(_DWORD *)buf = 136315906;
        v13 = v8;
        v14 = 2080;
        v15 = "SoundDec_SetEVSDecodeRF";
        v16 = 1024;
        v17 = 1571;
        v18 = 1024;
        v19 = a2;
        _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d AudioConverterSetProperty succeeded to set property kAudioCodecPrivatePropertyEVSDecodeRF frameType=%u", buf, 0x22u);
      }
      return 0;
    }
    if (ErrorLogLevelForModule >= 3)
    {
      v6 = VRTraceErrorLogLevelToCSTR();
      v7 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136316162;
        v13 = v6;
        v14 = 2080;
        v15 = "SoundDec_SetEVSDecodeRF";
        v16 = 1024;
        v17 = 1568;
        v18 = 1024;
        v19 = a2;
        v20 = 1024;
        v21 = v4;
        _os_log_error_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_ERROR, " [%s] %s:%d AudioConverterSetProperty failed to set property kAudioCodecPrivatePropertyEVSDecodeRF %d with error %08x", buf, 0x28u);
      }
    }
  }
  return v2;
}

uint64_t SoundDec_SetAMRPayloadFormat(uint64_t a1, int a2)
{
  uint64_t v2;
  int v4;
  BOOL v5;
  int v6;
  BOOL v7;
  OSStatus v8;
  int ErrorLogLevelForModule;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  NSObject *v13;
  int inPropertyData;
  uint8_t buf[4];
  uint64_t v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  __int16 v26;
  OSStatus v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v2 = 2147811329;
  if (a1)
  {
    v4 = *(_DWORD *)(a1 + 48);
    v5 = v4 == 1935764850 || v4 == 1935767394;
    if (v5 || ((v6 = *(_DWORD *)(a1 + 8), v6 != 1935767394) ? (v7 = v6 == 1935764850) : (v7 = 1), v7))
    {
      inPropertyData = 1;
      if (a2)
      {
        inPropertyData = 2;
        *(_DWORD *)(a1 + 188) = 1;
      }
      v8 = AudioConverterSetProperty(*(AudioConverterRef *)(a1 + 88), 0x73617066u, 4u, &inPropertyData);
      ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
      if (!v8)
      {
        if (ErrorLogLevelForModule >= 7)
        {
          v12 = VRTraceErrorLogLevelToCSTR();
          v13 = *MEMORY[0x1E0CF2758];
          v2 = 0;
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            return v2;
          *(_DWORD *)buf = 136315906;
          v17 = v12;
          v18 = 2080;
          v19 = "SoundDec_SetAMRPayloadFormat";
          v20 = 1024;
          v21 = 1592;
          v22 = 1024;
          v23 = a2;
          _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d AudioConverterSetProperty succeeded to set property kAudioCodecPrivatePropertyAMRPayloadFormat isOctetAligned=%u", buf, 0x22u);
        }
        return 0;
      }
      if (ErrorLogLevelForModule >= 3)
      {
        v10 = VRTraceErrorLogLevelToCSTR();
        v11 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136316418;
          v17 = v10;
          v18 = 2080;
          v19 = "SoundDec_SetAMRPayloadFormat";
          v20 = 1024;
          v21 = 1589;
          v22 = 1024;
          v23 = 1589;
          v24 = 1024;
          v25 = inPropertyData;
          v26 = 1024;
          v27 = v8;
          _os_log_error_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_ERROR, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/SoundDec.c:%d: AudioConverterSetProperty failed to set property kAudioCodecPrivatePropertyAMRPayloadFormat %d with error %08x", buf, 0x2Eu);
        }
      }
    }
  }
  return v2;
}

uint64_t SoundDec_SetAACELDPacketLossConcealmentAlgorithm(uint64_t a1)
{
  uint64_t v1;
  int v3;
  OSStatus v4;
  int ErrorLogLevelForModule;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  NSObject *v9;
  int inPropertyData;
  uint8_t buf[4];
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  __int16 v22;
  OSStatus v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v1 = 2147811329;
  if (a1)
  {
    v3 = *(unsigned __int16 *)(a1 + 82) << 16;
    if (v3 == 0x100000 || v3 == 720896)
    {
      inPropertyData = VCHardwareSettingsEmbedded_AACELDPacketLossConcealmentAlgorithm();
      if (inPropertyData == 6 && *(double *)a1 > 24000.0 && *(_DWORD *)(a1 + 28) == 2)
        inPropertyData = 5;
      v4 = AudioConverterSetProperty(*(AudioConverterRef *)(a1 + 88), 0x636F6E6Du, 4u, &inPropertyData);
      ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
      if (!v4)
      {
        if (ErrorLogLevelForModule >= 7)
        {
          v8 = VRTraceErrorLogLevelToCSTR();
          v9 = *MEMORY[0x1E0CF2758];
          v1 = 0;
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            return v1;
          *(_DWORD *)buf = 136315906;
          v13 = v8;
          v14 = 2080;
          v15 = "SoundDec_SetAACELDPacketLossConcealmentAlgorithm";
          v16 = 1024;
          v17 = 1617;
          v18 = 1024;
          v19 = inPropertyData;
          _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d AudioConverterSetProperty succeeded to set property kAudioCodecPropertyConcealmentMode plcMode=%u", buf, 0x22u);
        }
        return 0;
      }
      if (ErrorLogLevelForModule >= 3)
      {
        v6 = VRTraceErrorLogLevelToCSTR();
        v7 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136316418;
          v13 = v6;
          v14 = 2080;
          v15 = "SoundDec_SetAACELDPacketLossConcealmentAlgorithm";
          v16 = 1024;
          v17 = 1614;
          v18 = 1024;
          v19 = 1614;
          v20 = 1024;
          v21 = inPropertyData;
          v22 = 1024;
          v23 = v4;
          _os_log_error_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_ERROR, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/SoundDec.c:%d: AudioConverterSetProperty failed to set property kAudioCodecPropertyConcealmentMode %d with error %08x", buf, 0x2Eu);
        }
      }
    }
  }
  return v1;
}

uint64_t SoundDec_SetEnablePacketSizeLimitForVBR(uint64_t a1, char a2)
{
  uint64_t result;

  if (!a1)
    return 2147811329;
  result = 0;
  *(_BYTE *)(a1 + 184) = a2;
  return result;
}

uint64_t SoundDec_SetBitrate(uint64_t a1, int a2)
{
  uint64_t v3;
  NSObject *v4;
  _BOOL4 v5;
  uint64_t result;
  int v7;
  uint64_t v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 2147811329;
  *(_DWORD *)(a1 + 200) = a2;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v3 = VRTraceErrorLogLevelToCSTR();
    v4 = *MEMORY[0x1E0CF2758];
    v5 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v5)
      return result;
    v7 = 136315906;
    v8 = v3;
    v9 = 2080;
    v10 = "SoundDec_SetBitrate";
    v11 = 1024;
    v12 = 1635;
    v13 = 1024;
    v14 = a2;
    _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d SoundDec_SetBitrate Requested bitrate: %d", (uint8_t *)&v7, 0x22u);
  }
  return 0;
}

uint64_t SoundDec_GetMagicCookie(uint64_t a1, void *outPropertyData, UInt32 *a3)
{
  uint64_t v3;
  OSStatus Property;
  OSStatus v7;
  uint64_t v8;
  NSObject *v9;
  UInt32 v10;
  int v12;
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  void *v19;
  __int16 v20;
  UInt32 v21;
  __int16 v22;
  OSStatus v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v3 = 2147811329;
  if (a1)
  {
    Property = AudioConverterGetProperty(*(AudioConverterRef *)(a1 + 88), 0x6B756B69u, a3, outPropertyData);
    if (Property)
    {
      v7 = Property;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v8 = VRTraceErrorLogLevelToCSTR();
        v9 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v10 = *a3;
          v12 = 136316418;
          v13 = v8;
          v14 = 2080;
          v15 = "SoundDec_GetMagicCookie";
          v16 = 1024;
          v17 = 1648;
          v18 = 2048;
          v19 = outPropertyData;
          v20 = 1024;
          v21 = v10;
          v22 = 1024;
          v23 = v7;
          _os_log_error_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_ERROR, " [%s] %s:%d SoundDec_GetMagicCookie Failed to retrieve cookie [%p, %u] %d", (uint8_t *)&v12, 0x32u);
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return v3;
}

uint64_t SoundDec_GetSpeechCodecBundleData(uint64_t a1, uint64_t *outPropertyData)
{
  uint64_t v3;
  uint64_t result;
  OSStatus Property;
  OSStatus v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  int v11;
  UInt32 ioPropertyDataSize;
  uint8_t buf[4];
  uint64_t v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  uint64_t v20;
  __int16 v21;
  int v22;
  __int16 v23;
  OSStatus v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v3 = 2147811332;
  result = 2147811329;
  if (a1 && outPropertyData)
  {
    ioPropertyDataSize = 336;
    Property = AudioConverterGetProperty(*(AudioConverterRef *)(a1 + 88), 0x626E6464u, &ioPropertyDataSize, outPropertyData);
    if (!Property)
      return 0;
    v7 = Property;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v8 = VRTraceErrorLogLevelToCSTR();
      v9 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v10 = *outPropertyData;
        v11 = *((_DWORD *)outPropertyData + 2);
        *(_DWORD *)buf = 136316418;
        v14 = v8;
        v15 = 2080;
        v16 = "SoundDec_GetSpeechCodecBundleData";
        v17 = 1024;
        v18 = 1665;
        v19 = 2048;
        v20 = v10;
        v21 = 1024;
        v22 = v11;
        v23 = 1024;
        v24 = v7;
        _os_log_error_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_ERROR, " [%s] %s:%d SoundDec_GetSpeechCodecBundleData Failed to get bundle data [%p, %u] %d", buf, 0x32u);
      }
    }
    return v3;
  }
  return result;
}

uint64_t SoundDec_SetMagicCookie(uint64_t a1, void *inPropertyData, UInt32 inPropertyDataSize)
{
  uint64_t v3;
  uint64_t v6;
  NSObject *v7;
  OSStatus v10;
  OSStatus v11;
  uint64_t v12;
  NSObject *v13;
  int v14;
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  void *v21;
  __int16 v22;
  UInt32 v23;
  __int16 v24;
  OSStatus v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v3 = 2147811329;
  if (a1)
  {
    if (*(_DWORD *)(a1 + 192)
      || (v10 = AudioConverterSetProperty(*(AudioConverterRef *)(a1 + 88), 0x6B756B69u, inPropertyDataSize, inPropertyData), *(_DWORD *)(a1 + 192) = 1, !v10))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v6 = VRTraceErrorLogLevelToCSTR();
        v7 = *MEMORY[0x1E0CF2758];
        v3 = 0;
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          return v3;
        v14 = 136315906;
        v15 = v6;
        v16 = 2080;
        v17 = "SoundDec_SetMagicCookie";
        v18 = 1024;
        v19 = 1687;
        v20 = 1024;
        LODWORD(v21) = inPropertyDataSize;
        _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d SoundDec_SetMagicCookie succeeded %d", (uint8_t *)&v14, 0x22u);
      }
      return 0;
    }
    v11 = v10;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v12 = VRTraceErrorLogLevelToCSTR();
      v13 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v14 = 136316418;
        v15 = v12;
        v16 = 2080;
        v17 = "SoundDec_SetMagicCookie";
        v18 = 1024;
        v19 = 1684;
        v20 = 2048;
        v21 = inPropertyData;
        v22 = 1024;
        v23 = inPropertyDataSize;
        v24 = 1024;
        v25 = v11;
        _os_log_error_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_ERROR, " [%s] %s:%d SoundDec_SetMagicCookie Failed to set cookie [%p, %u] %d", (uint8_t *)&v14, 0x32u);
      }
    }
  }
  return v3;
}

uint64_t SoundDec_FormatASBD(int a1, uint64_t a2, int a3, unsigned int a4, int a5, float a6)
{
  signed int v6;
  int v7;
  uint64_t v8;
  double v9;
  uint64_t v10;
  int v11;
  int v12;
  _QWORD *v13;
  double v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  int v19;

  v6 = a1 & 0xFFFF0000;
  if ((int)(a1 & 0xFFFF0000) >= 851968)
  {
    if (v6 < 0x400000)
    {
      if (v6 >= 0x100000)
      {
        if (v6 == 0x100000)
        {
          v7 = 0;
          *(double *)a2 = (double)(unsigned __int16)a1;
          if (a5 == 1)
            v19 = 1633772390;
          else
            v19 = 1633772389;
          *(_DWORD *)(a2 + 12) = 0;
          *(_DWORD *)(a2 + 16) = 0;
          *(_DWORD *)(a2 + 8) = v19;
        }
        else
        {
          if (v6 != 0x200000)
            return 0;
          v7 = 0;
          *(double *)a2 = (double)(unsigned __int16)a1;
          *(_QWORD *)(a2 + 8) = 1869641075;
          *(_DWORD *)(a2 + 16) = 0;
          a3 = (float)((float)((float)(unsigned __int16)a1 * a6) * (float)a5);
        }
        v8 = a4;
        goto LABEL_61;
      }
      if (v6 != 851968)
      {
        if (v6 == 983040)
        {
          v7 = 0;
          *(_QWORD *)a2 = 0x40CF400000000000;
          *(_QWORD *)(a2 + 8) = 1735091043;
          *(_DWORD *)(a2 + 16) = 0;
          v8 = 1;
          a3 = 320;
LABEL_61:
          *(_DWORD *)(a2 + 20) = a3;
          goto LABEL_62;
        }
        return 0;
      }
      v14 = (double)(unsigned __int16)a1;
      v15 = 0xC0C6C70636DLL;
      goto LABEL_43;
    }
    if (v6 >= 0x800000)
    {
      if (v6 == 0x800000)
      {
        v7 = 0;
        *(_QWORD *)a2 = 0x40D7700000000000;
        *(_QWORD *)(a2 + 8) = 1685354616;
        *(_DWORD *)(a2 + 16) = 0;
        v8 = 1;
        a3 = 480;
        goto LABEL_61;
      }
      if (v6 != 0x1000000)
        return 0;
      v7 = 0;
      *(double *)a2 = (double)(unsigned __int16)a1;
      *(_QWORD *)(a2 + 8) = 1953790320;
      *(_DWORD *)(a2 + 16) = 0;
      goto LABEL_35;
    }
    if (v6 != 0x400000)
    {
      if (v6 != 5242880)
        return 0;
      v7 = 0;
      if ((unsigned __int16)a1 == 32000)
        v11 = 640;
      else
        v11 = 160;
      *(_DWORD *)(a2 + 16) = 0;
      *(double *)a2 = (double)(unsigned __int16)a1;
      *(_QWORD *)(a2 + 8) = 1936029299;
      if ((unsigned __int16)a1 == 16000)
        v12 = 320;
      else
        v12 = v11;
      a3 = v12 * a5;
LABEL_35:
      v13 = (_QWORD *)&unk_1D910A000;
LABEL_60:
      v8 = v13[416];
      goto LABEL_61;
    }
    v16 = 1935764850;
    *(double *)a2 = (double)(unsigned __int16)a1;
    *(_DWORD *)(a2 + 12) = 0;
    *(_DWORD *)(a2 + 16) = 0;
    v13 = &unk_1D910A000;
    if ((unsigned __int16)a1 == 8000)
    {
      v17 = 160;
      goto LABEL_57;
    }
    if ((unsigned __int16)a1 == 16000)
    {
      v16 = 1935767394;
      v17 = 320;
LABEL_57:
      v7 = 0;
      *(_DWORD *)(a2 + 8) = v16;
      a3 = v17 * a5;
      goto LABEL_60;
    }
LABEL_55:
    v7 = 0;
    v8 = 1;
LABEL_62:
    *(_DWORD *)(a2 + 24) = v7;
    *(_QWORD *)(a2 + 28) = v8;
    *(_DWORD *)(a2 + 36) = 0;
    return 0;
  }
  if (v6 < 0x40000)
  {
    if (v6 != 0x10000)
    {
      if (v6 == 0x20000)
      {
        *(double *)a2 = (double)(unsigned __int16)a1;
        *(_QWORD *)(a2 + 8) = 0x296C70636DLL;
        v7 = 4;
        *(_DWORD *)(a2 + 16) = 4;
        v8 = 0x2000000002;
      }
      else
      {
        if (v6 != 196608)
          return 0;
        *(double *)a2 = (double)(unsigned __int16)a1;
        *(_QWORD *)(a2 + 8) = 0x2C6C70636DLL;
        v7 = 2;
        *(_DWORD *)(a2 + 16) = 2;
        v8 = 0x1000000001;
      }
LABEL_45:
      a3 = 1;
      goto LABEL_61;
    }
    v14 = (double)(unsigned __int16)a1;
    v15 = 0x296C70636DLL;
LABEL_43:
    *(double *)a2 = v14;
    *(_QWORD *)(a2 + 8) = v15;
    v7 = 4;
    *(_DWORD *)(a2 + 16) = 4;
    v8 = 0x2000000001;
    goto LABEL_45;
  }
  if (v6 < 655360)
  {
    if (v6 == 0x40000)
    {
      v9 = (double)(unsigned __int16)a1;
      v10 = 1970037111;
    }
    else
    {
      if (v6 != 327680)
        return 0;
      v9 = (double)(unsigned __int16)a1;
      v10 = 1634492791;
    }
    *(double *)a2 = v9;
    *(_QWORD *)(a2 + 8) = v10;
    a3 = 1;
    *(_DWORD *)(a2 + 16) = 1;
    v8 = 0x800000001;
    v7 = 1;
    goto LABEL_61;
  }
  if (v6 == 655360)
  {
    *(double *)a2 = (double)(unsigned __int16)a1;
    *(_QWORD *)(a2 + 8) = 1936745848;
    *(_DWORD *)(a2 + 16) = 0;
    v13 = &unk_1D910A000;
    if ((unsigned __int16)a1 == 8000)
    {
      v18 = 160;
    }
    else
    {
      if ((unsigned __int16)a1 != 16000)
        goto LABEL_55;
      v18 = 320;
    }
    v7 = 0;
    a3 = v18 * a5;
    goto LABEL_60;
  }
  if (v6 == 720896)
  {
    v7 = 0;
    *(double *)a2 = (double)(unsigned __int16)a1;
    *(_QWORD *)(a2 + 8) = 1633772396;
    *(_DWORD *)(a2 + 16) = 0;
    v8 = 1;
    a3 = 512;
    goto LABEL_61;
  }
  return 0;
}

uint64_t SoundDec_SetOpusInBandFecEnabled(uint64_t a1, int a2)
{
  uint64_t v2;
  OSStatus v3;
  int ErrorLogLevelForModule;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  int inPropertyData;
  uint8_t buf[4];
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  __int16 v19;
  OSStatus v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v2 = 2147811329;
  inPropertyData = a2;
  if (a1 && (*(_DWORD *)(a1 + 8) == 1869641075 || *(_DWORD *)(a1 + 48) == 1869641075))
  {
    v3 = AudioConverterSetProperty(*(AudioConverterRef *)(a1 + 88), 0x70666563u, 4u, &inPropertyData);
    ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    if (!v3)
    {
      if (ErrorLogLevelForModule >= 7)
      {
        v7 = VRTraceErrorLogLevelToCSTR();
        v8 = *MEMORY[0x1E0CF2758];
        v2 = 0;
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          return v2;
        *(_DWORD *)buf = 136315906;
        v12 = v7;
        v13 = 2080;
        v14 = "SoundDec_SetOpusInBandFecEnabled";
        v15 = 1024;
        v16 = 1709;
        v17 = 1024;
        v18 = inPropertyData;
        _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d AudioConverterSetProperty succeeded to set property kAudioCodecPrivatePropertyEnableFEC opusInBandFecEnabled=%u", buf, 0x22u);
      }
      return 0;
    }
    if (ErrorLogLevelForModule >= 3)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v6 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136316162;
        v12 = v5;
        v13 = 2080;
        v14 = "SoundDec_SetOpusInBandFecEnabled";
        v15 = 1024;
        v16 = 1706;
        v17 = 1024;
        v18 = inPropertyData;
        v19 = 1024;
        v20 = v3;
        _os_log_error_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_ERROR, " [%s] %s:%d AudioConverterSetProperty failed to set property kAudioCodecPrivatePropertyEnableFEC %d with error %08x", buf, 0x28u);
      }
    }
  }
  return v2;
}

uint64_t SoundDec_SetPacketLossPercentage(uint64_t a1, int a2)
{
  uint64_t v2;
  OSStatus v3;
  int ErrorLogLevelForModule;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  int inPropertyData;
  uint8_t buf[4];
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  __int16 v19;
  OSStatus v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v2 = 2147811329;
  inPropertyData = a2;
  if (a1 && (*(_DWORD *)(a1 + 8) == 1869641075 || *(_DWORD *)(a1 + 48) == 1869641075))
  {
    v3 = AudioConverterSetProperty(*(AudioConverterRef *)(a1 + 88), 0x5E6C7370u, 4u, &inPropertyData);
    ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    if (!v3)
    {
      if (ErrorLogLevelForModule >= 7)
      {
        v7 = VRTraceErrorLogLevelToCSTR();
        v8 = *MEMORY[0x1E0CF2758];
        v2 = 0;
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          return v2;
        *(_DWORD *)buf = 136315906;
        v12 = v7;
        v13 = 2080;
        v14 = "SoundDec_SetPacketLossPercentage";
        v15 = 1024;
        v16 = 1725;
        v17 = 1024;
        v18 = inPropertyData;
        _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d AudioConverterSetProperty succeeded to set property kAudioCodecPrivatePropertyPacketLossPercentage packetLossPercentage=%u", buf, 0x22u);
      }
      return 0;
    }
    if (ErrorLogLevelForModule >= 3)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v6 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136316162;
        v12 = v5;
        v13 = 2080;
        v14 = "SoundDec_SetPacketLossPercentage";
        v15 = 1024;
        v16 = 1722;
        v17 = 1024;
        v18 = inPropertyData;
        v19 = 1024;
        v20 = v3;
        _os_log_error_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_ERROR, " [%s] %s:%d AudioConverterSetProperty failed to set property kAudioCodecPrivatePropertyPacketLossPercentage %d with error %08x", buf, 0x28u);
      }
    }
  }
  return v2;
}

uint64_t SoundDec_GetOpusDecodeFECStatus(uint64_t a1, void *outPropertyData)
{
  uint64_t v3;
  uint64_t result;
  UInt32 ioPropertyDataSize;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v3 = 2147811332;
  result = 2147811329;
  if (a1 && (*(_DWORD *)(a1 + 8) == 1869641075 || *(_DWORD *)(a1 + 48) == 1869641075))
  {
    ioPropertyDataSize = 4;
    if (!AudioConverterGetProperty(*(AudioConverterRef *)(a1 + 88), 0x66737473u, &ioPropertyDataSize, outPropertyData))
      return 0;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SoundDec_GetOpusDecodeFECStatus_cold_1();
    }
    return v3;
  }
  return result;
}

uint64_t SoundDec_SetEVSAudioCodecBandwidth(uint64_t a1, int a2)
{
  uint64_t result;
  OSStatus v4;
  int ErrorLogLevelForModule;
  os_log_t *v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  int inPropertyData;
  uint8_t buf[4];
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  result = 2147811329;
  if (a1 && (*(_DWORD *)(a1 + 48) == 1936029299 || *(_DWORD *)(a1 + 8) == 1936029299))
  {
    inPropertyData = a2;
    v4 = AudioConverterSetProperty(*(AudioConverterRef *)(a1 + 88), 0x626E6477u, 4u, &inPropertyData);
    ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    if (v4)
    {
      v6 = (os_log_t *)MEMORY[0x1E0CF2758];
      if (ErrorLogLevelForModule >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
          SoundDec_SetEVSAudioCodecBandwidth_cold_1();
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v7 = VRTraceErrorLogLevelToCSTR();
        v8 = *v6;
        if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315906;
          v13 = v7;
          v14 = 2080;
          v15 = "SoundDec_SetEVSAudioCodecBandwidth";
          v16 = 1024;
          v17 = 1787;
          v18 = 1024;
          v19 = -2147155964;
          _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Failed to set EVS audio codec bandwidth. result=%X", buf, 0x22u);
        }
      }
      return 2147811332;
    }
    else
    {
      if (ErrorLogLevelForModule >= 7)
      {
        v9 = VRTraceErrorLogLevelToCSTR();
        v10 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315906;
          v13 = v9;
          v14 = 2080;
          v15 = "_SoundDec_SetEVSAudioCodecPropertyBandwidth";
          v16 = 1024;
          v17 = 1773;
          v18 = 1024;
          v19 = inPropertyData;
          _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d AudioConverterSetProperty succeeded to set property kAudioCodecPrivatePropertyBandwidth codecBandwidth=%u", buf, 0x22u);
        }
      }
      return 0;
    }
  }
  return result;
}

uint64_t SoundDec_SetEVSAudioCodecBandwidthUpdate(uint64_t a1, int a2)
{
  uint64_t result;

  result = 2147811329;
  if (a1 && (*(_DWORD *)(a1 + 48) == 1936029299 || *(_DWORD *)(a1 + 8) == 1936029299))
  {
    result = 0;
    *(_DWORD *)(a1 + 224) = a2;
    *(_BYTE *)(a1 + 228) = 1;
  }
  return result;
}

uint64_t SoundDec_SetCMR(uint64_t a1, int a2, int a3)
{
  uint64_t result;
  int v7;
  int v8;
  BOOL v9;
  BOOL v10;
  BOOL v11;
  BOOL v12;
  uint64_t v13;
  NSObject *v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  int v24;
  __int16 v25;
  int v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  result = 2147811329;
  if (a1)
  {
    v7 = *(_DWORD *)(a1 + 48);
    if (v7 == 1936029299
      || ((v8 = *(_DWORD *)(a1 + 8), v8 != 1936029299) ? (v9 = v7 == 1935764850) : (v9 = 1),
          !v9 ? (v10 = v7 == 1935767394) : (v10 = 1),
          !v10 ? (v11 = v8 == 1935767394) : (v11 = 1),
          !v11 ? (v12 = v8 == 1935764850) : (v12 = 1),
          v12))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v13 = VRTraceErrorLogLevelToCSTR();
        v14 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v17 = 136316162;
          v18 = v13;
          v19 = 2080;
          v20 = "SoundDec_SetCMR";
          v21 = 1024;
          v22 = 1810;
          v23 = 1024;
          v24 = a2;
          v25 = 1024;
          v26 = a3;
          _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d SoundDec_SetCMR mode=%u bandwidth=%u", (uint8_t *)&v17, 0x28u);
        }
      }
      v15 = *(_DWORD *)(a1 + 48);
      if (v15 == 1936029299 || *(_DWORD *)(a1 + 8) == 1936029299)
      {
        *(_DWORD *)(a1 + 204) = a2;
        *(_DWORD *)(a1 + 208) = a3;
        *(_BYTE *)(a1 + 220) = 1;
      }
      if (v15 == 1935764850 || v15 == 1935767394 || (v16 = *(_DWORD *)(a1 + 8), v16 == 1935767394) || v16 == 1935764850)
      {
        result = 0;
        *(_BYTE *)(a1 + 221) = a2;
        *(_WORD *)(a1 + 222) = 1;
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t SoundDec_EnableShortRED(uint64_t a1, int a2, int a3, int a4)
{
  uint64_t result;
  uint64_t v9;
  NSObject *v10;
  _BOOL4 v11;
  int v12;
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  result = 2147811329;
  if (a1 && (*(_DWORD *)(a1 + 48) == 1633903462 || *(_DWORD *)(a1 + 8) == 1633903462))
  {
    *(_DWORD *)(a1 + 252) = a3;
    *(_DWORD *)(a1 + 256) = a4;
    *(_BYTE *)(a1 + 248) = a2;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v9 = VRTraceErrorLogLevelToCSTR();
      v10 = *MEMORY[0x1E0CF2758];
      v11 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
      result = 0;
      if (!v11)
        return result;
      v12 = 136316418;
      v13 = v9;
      v14 = 2080;
      v15 = "SoundDec_EnableShortRED";
      v16 = 1024;
      v17 = 1902;
      v18 = 1024;
      v19 = a2;
      v20 = 1024;
      v21 = a3;
      v22 = 1024;
      v23 = a4;
      _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d SoundDec_EnableShortRED Requested shortREDEnabled=%d shortREDBytesPerFrame=%u shortREDBitrate=%u", (uint8_t *)&v12, 0x2Eu);
    }
    return 0;
  }
  return result;
}

uint64_t SoundDec_IsShortREDEnabled(uint64_t a1, _BYTE *a2)
{
  uint64_t result;

  result = 2147811329;
  if (a1)
  {
    if (a2)
    {
      result = 0;
      *a2 = *(_BYTE *)(a1 + 260);
    }
  }
  return result;
}

uint64_t SoundDec_GetShortREDBytesPerFrame(uint64_t a1, _DWORD *a2)
{
  uint64_t result;

  result = 2147811329;
  if (a1)
  {
    if (a2)
    {
      result = 0;
      *a2 = *(_DWORD *)(a1 + 264);
    }
  }
  return result;
}

char *ExpandCallbackBuffer(uint64_t a1, int *a2)
{
  int v4;
  void *v5;
  int v6;
  char *result;
  char *v8;

  v4 = *(_DWORD *)(a1 + 172);
  v5 = *(void **)(a1 + 160);
  v6 = (int)((double)*a2 * 1.25);
  result = (char *)malloc_type_realloc(v5, v6, 0x7A91EAE3uLL);
  v8 = &result[v6];
  if (!result)
    v8 = 0;
  if (result > v8 || v6 < 0 || v8 - result < v6)
    goto LABEL_10;
  *(_QWORD *)(a1 + 160) = result;
  *(_DWORD *)(a1 + 172) = v6;
  if (result)
    return result;
  if (v4 < 0)
  {
LABEL_10:
    __break(0x5519u);
    return result;
  }
  *(_DWORD *)(a1 + 172) = v4;
  *(_QWORD *)(a1 + 160) = v5;
  *a2 = v4;
  return result;
}

uint64_t VCDatagramChannelIDS_Token(uint64_t a1)
{
  uint64_t result;
  uint64_t v2;
  NSObject *v3;
  _BOOL4 v4;
  int v5;
  uint64_t v6;
  __int16 v7;
  const char *v8;
  __int16 v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (a1)
    return *(unsigned int *)(a1 + 168);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    v4 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v4)
      return result;
    v5 = 136315650;
    v6 = v2;
    v7 = 2080;
    v8 = "VCDatagramChannelIDS_Token";
    v9 = 1024;
    v10 = 36;
    _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v5, 0x1Cu);
  }
  return 0;
}

uint64_t VCTimescalePSOLA_VectorBitShiftW32ToW16(uint64_t result, int a2, int *a3, int a4)
{
  char v4;
  _WORD *v6;
  unsigned int v7;
  int v8;
  __int16 v9;
  unsigned int v10;
  int v11;

  v4 = a4;
  v6 = (_WORD *)result;
  if (a4 < 0)
  {
    if (a2 >= 1)
    {
      v9 = -(__int16)a4;
      v10 = a2 + 1;
      do
      {
        v11 = *a3++;
        result = VCTimescalePSOLA_SatW32ToW16(v11 << v9);
        *v6++ = result;
        --v10;
      }
      while (v10 > 1);
    }
  }
  else if (a2 >= 1)
  {
    v7 = a2 + 1;
    do
    {
      v8 = *a3++;
      result = VCTimescalePSOLA_SatW32ToW16(v8 >> v4);
      *v6++ = result;
      --v7;
    }
    while (v7 > 1);
  }
  return result;
}

uint64_t VCTimescalePSOLA_DownsampleFast(uint64_t a1, int a2, _WORD *a3, int a4, __int16 *a5, int a6, int a7, int a8)
{
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __int16 *v19;
  int v20;
  uint64_t v21;
  __int16 *v22;
  __int16 *v23;
  int v24;
  int v25;
  int v26;

  v8 = 61;
  v9 = a4 - 1;
  if (a4 >= 1 && a6 >= 1)
  {
    v10 = v9 * a7;
    v11 = v9 * a7 + a8;
    if (v11 < a2)
    {
      if (v10 < 0)
      {
        return 0;
      }
      else
      {
        v14 = a8;
        v15 = a7;
        v16 = v11;
        v17 = a6;
        v18 = 2 * a7;
        v19 = (__int16 *)(a1 + 2 * a8);
        do
        {
          v20 = 2048;
          v21 = v17;
          v22 = a5;
          v23 = v19;
          do
          {
            v25 = *v22++;
            v24 = v25;
            v26 = *v23--;
            v20 += v26 * v24;
            --v21;
          }
          while (v21);
          *a3++ = VCTimescalePSOLA_SatW32ToW16(v20 >> 12);
          v14 += v15;
          v19 = (__int16 *)((char *)v19 + v18);
        }
        while (v14 <= v16);
        return 0;
      }
    }
  }
  return v8;
}

_DWORD *VCTimescalePSOLA_CrossCorrelation(_DWORD *result, __int16 *a2, __int16 *a3, int a4, int a5, char a6, int a7)
{
  uint64_t v7;
  int v8;
  uint64_t v9;
  __int16 *v10;
  __int16 *v11;
  int v12;
  int v13;
  int v14;

  if (a5 >= 1)
  {
    v7 = 0;
    do
    {
      *result = 0;
      if (a4 >= 1)
      {
        v8 = 0;
        v9 = a4;
        v10 = a2;
        v11 = a3;
        do
        {
          v13 = *v10++;
          v12 = v13;
          v14 = *v11++;
          v8 += (v14 * v12) >> a6;
          --v9;
        }
        while (v9);
        *result = v8;
      }
      ++result;
      ++v7;
      a3 += a7;
    }
    while (v7 != (unsigned __int16)a5);
  }
  return result;
}

uint64_t VCTimescalePSOLA_DivW32W16(int a1, int a2)
{
  if (a2)
    return (a1 / a2);
  else
    return 0x7FFFFFFFLL;
}

uint64_t VCTimescalePSOLA_DivW32W16ResW16(int a1, int a2)
{
  int v2;

  if (a2)
    v2 = a1 / a2;
  else
    LOWORD(v2) = 0x7FFF;
  return (__int16)v2;
}

uint64_t VCTimescalePSOLA_MaxAbsValueW16(__int16 *a1, int a2)
{
  int v2;
  uint64_t v3;
  int v4;
  int v5;

  LOWORD(v2) = -1;
  if (a1 && a2 >= 1)
  {
    v2 = 0;
    v3 = a2;
    do
    {
      v5 = *a1++;
      v4 = v5;
      if (v5 < 0)
        v4 = -v4;
      if (v2 <= v4)
        v2 = v4;
      --v3;
    }
    while (v3);
    if (v2 >= 0x7FFF)
      LOWORD(v2) = 0x7FFF;
  }
  return (__int16)v2;
}

uint64_t VCTimescalePSOLA_MaxAbsValueW32(int *a1, int a2)
{
  uint64_t result;
  uint64_t v4;
  unsigned int v5;
  int v6;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 1)
  {
    LODWORD(result) = 0;
    v4 = a2;
    do
    {
      v6 = *a1++;
      v5 = v6;
      if (v6 < 0)
        v5 = -v5;
      if (v5 <= result)
        result = result;
      else
        result = v5;
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t VCTimescalePSOLA_MaxIndexW16(uint64_t a1, int a2)
{
  uint64_t result;
  uint64_t v4;
  __int16 v5;
  int v6;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 >= 1)
  {
    v4 = 0;
    LODWORD(result) = 0;
    v5 = 0x8000;
    do
    {
      v6 = *(__int16 *)(a1 + 2 * v4);
      if (v6 <= v5)
        result = result;
      else
        result = v4;
      if (v6 > v5)
        v5 = *(_WORD *)(a1 + 2 * v4);
      ++v4;
    }
    while (a2 != v4);
  }
  return result;
}

uint64_t VCTimescalePSOLA_DotProductWithScale(int16x4_t *a1, int16x4_t *a2, int a3, char a4)
{
  unint64_t v5;
  uint64_t result;
  unsigned int v7;
  int32x4_t v8;
  int16x4_t *v9;
  int16x4_t *v10;
  int16x4_t v11;
  int16x4_t v12;
  int16x4_t v13;
  __int16 *v14;
  __int16 *v15;
  int v16;
  int v17;
  int v18;

  if (a3 < 4)
  {
    result = 0;
    v7 = 0;
  }
  else
  {
    v5 = 0;
    LODWORD(result) = 0;
    v7 = a3 & 0xFFFFFFFC;
    v8 = vnegq_s32(vdupq_n_s32(a4));
    v9 = a1;
    v10 = a2;
    do
    {
      v11 = *v9++;
      v12 = v11;
      v13 = *v10++;
      result = (vaddvq_s32(vshlq_s32(vmull_s16(v13, v12), v8)) + result);
      v5 += 4;
    }
    while (v5 < (a3 - 3));
  }
  if ((int)v7 < a3)
  {
    v14 = (__int16 *)a2 + v7;
    v15 = (__int16 *)a1 + v7;
    do
    {
      v17 = *v15++;
      v16 = v17;
      v18 = *v14++;
      result = (((v18 * v16) >> a4) + result);
      ++v7;
    }
    while ((int)v7 < a3);
  }
  return result;
}

double _VCVideoPlayer_GetDisplayTimestamp(uint64_t a1)
{
  return *(double *)(a1 + 624);
}

uint64_t _VCVideoPlayer_LogPlayoutTimeChange(uint64_t a1, uint64_t a2, uint64_t a3, double a4, Float64 a5, double a6)
{
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  int v18;
  CMTime v20;
  CMTime v21;
  CMTime buf;
  int v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  int v31;
  __int16 v32;
  uint64_t v33;
  __int16 v34;
  int v35;
  __int16 v36;
  double v37;
  __int16 v38;
  int v39;
  __int16 v40;
  double v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v12 = VRTraceErrorLogLevelToCSTR();
    v13 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v14 = *(_QWORD *)(a3 + 160);
      v15 = *(_DWORD *)(a3 + 168);
      v16 = *(_QWORD *)(a3 + 112);
      v17 = *(_DWORD *)(a1 + 24);
      v18 = *(unsigned __int8 *)(a3 + 136);
      LODWORD(buf.value) = 136317954;
      *(CMTimeValue *)((char *)&buf.value + 4) = v12;
      LOWORD(buf.flags) = 2080;
      *(_QWORD *)((char *)&buf.flags + 2) = "_VCVideoPlayer_LogPlayoutTimeChange";
      HIWORD(buf.epoch) = 1024;
      v23 = 201;
      v24 = 2048;
      v25 = a2;
      v26 = 2048;
      v27 = a3;
      v28 = 2048;
      v29 = v14;
      v30 = 1024;
      v31 = v15;
      v32 = 2048;
      v33 = v16;
      v34 = 1024;
      v35 = v17;
      v36 = 2048;
      v37 = a4;
      v38 = 1024;
      v39 = v18;
      v40 = 2048;
      v41 = a6;
      _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] playbackClient=%p reference changed lastFrame.presentationTime=%f lastFrame.rtpTimestamp=%u adjustedPresentationTime=%f current RTPTimeStamp=%u lastFrame.presentationTime changed by %f seconds preventBackward=%d delayOffsetInSeconds=%f", (uint8_t *)&buf, 0x6Au);
    }
  }
  CMTimeMakeWithSeconds(&v21, a5, 1000000000);
  buf = v21;
  CMTimeGetSeconds(&buf);
  CMTimeMakeWithSeconds(&v20, *(Float64 *)(a3 + 160), 1000000000);
  buf = v20;
  CMTimeGetSeconds(&buf);
  return kdebug_trace();
}

uint64_t _VCVideoPlayer_DoPlayoutTimeReAnchor(uint64_t a1, uint64_t a2, double *a3, double a4)
{
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double DisplayTimestamp;

  v8 = *(double *)(a2 + 176);
  v9 = *(double *)(a2 + 160);
  v10 = *a3 - v8 + v9;
  v11 = *a3 - *(double *)(a2 + 96) + *(double *)(a2 + 80) + a4;
  v12 = v11 - v10;
  v13 = vabdd_f64(v11, v10);
  if (v12 < 0.0 && v13 < 2.0)
    *(_BYTE *)(a2 + 136) = 1;
  *(double *)(a2 + 112) = v9 + v12;
  *(double *)(a2 + 128) = v8;
  *(_BYTE *)(a2 + 104) = 1;
  *(_BYTE *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 64) = 0;
  *(_BYTE *)(a2 + 72) = 0;
  *(_QWORD *)(a2 + 80) = 0;
  *(_QWORD *)(a2 + 96) = 0;
  DisplayTimestamp = _VCVideoPlayer_GetDisplayTimestamp(a1);
  return _VCVideoPlayer_LogPlayoutTimeChange((uint64_t)a3, a1, a2, v12, DisplayTimestamp, a4);
}

uint64_t _VCVideoPlayer_JitterAdaptation_HandleQueueSizeChange(uint64_t a1, uint64_t a2, uint64_t a3, Float64 a4, double a5)
{
  double v7;

  v7 = *(double *)(a2 + 64);
  if (v7 < 0.0)
    *(_BYTE *)(a2 + 136) = 1;
  if (*(_BYTE *)(a2 + 104))
  {
    *(double *)(a2 + 112) = v7 + *(double *)(a2 + 112);
  }
  else
  {
    *(double *)(a2 + 112) = v7 + *(double *)(a2 + 160);
    *(_QWORD *)(a2 + 128) = *(_QWORD *)(a2 + 176);
  }
  *(_BYTE *)(a2 + 104) = 1;
  *(_BYTE *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 64) = 0;
  return _VCVideoPlayer_LogPlayoutTimeChange(a3, a1, a2, v7, a4, a5);
}

double _VCVideoPlayer_PreventBackwardPresentationTime(uint64_t a1, uint64_t a2, uint64_t a3, double a4)
{
  double v7;
  double v8;
  double v9;
  uint64_t v10;
  NSObject *v11;
  int v12;
  uint64_t v13;
  NSObject *v14;
  int v15;
  double v16;
  int v18;
  uint64_t v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  double v29;
  __int16 v30;
  int v31;
  __int16 v32;
  double v33;
  __int16 v34;
  double v35;
  uint64_t v36;

  v7 = a4;
  v36 = *MEMORY[0x1E0C80C00];
  v8 = *(double *)a2 - *(double *)(a3 + 128);
  v9 = *(double *)(a3 + 160);
  if (v9 <= a4)
  {
    if (*(_DWORD *)(a2 + 32) == 1)
    {
      *(_BYTE *)(a3 + 136) = 0;
      v7 = v8 + *(double *)(a3 + 112);
      *(_DWORD *)(a3 + 120) = *(_DWORD *)(a2 + 24);
      *(_BYTE *)(a3 + 105) = 1;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v13 = VRTraceErrorLogLevelToCSTR();
        v14 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v15 = *(_DWORD *)(a2 + 24);
          v16 = *(double *)(a3 + 160);
          v18 = 136317186;
          v19 = v13;
          v20 = 2080;
          v21 = "_VCVideoPlayer_PreventBackwardPresentationTime";
          v22 = 1024;
          v23 = 277;
          v24 = 2048;
          v25 = a1;
          v26 = 2048;
          v27 = a3;
          v28 = 2048;
          v29 = v7;
          v30 = 1024;
          v31 = v15;
          v32 = 2048;
          v33 = v16;
          v34 = 2048;
          v35 = v8;
          _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] playbackClient=%p finished keeping presentationTime=%f the same rtpTimeStamp=%u lastFrame.presentationTime=%f durationSinceLastAdjustment=%f", (uint8_t *)&v18, 0x54u);
        }
      }
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v10 = VRTraceErrorLogLevelToCSTR();
      v11 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v12 = *(_DWORD *)(a2 + 24);
        v18 = 136316930;
        v19 = v10;
        v20 = 2080;
        v21 = "_VCVideoPlayer_PreventBackwardPresentationTime";
        v22 = 1024;
        v23 = 271;
        v24 = 2048;
        v25 = a1;
        v26 = 2048;
        v27 = a3;
        v28 = 2048;
        v29 = v9;
        v30 = 1024;
        v31 = v12;
        v32 = 2048;
        v33 = v8;
        _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] playbackClient=%p keeping presentationTime=%f the same to prevent it from going backward rtpTimestamp=%u durationSinceLastAdjustment=%f", (uint8_t *)&v18, 0x4Au);
      }
    }
    return v9;
  }
  return v7;
}

double _VCVideoPlayer_GetPresentationTime(uint64_t a1, uint64_t a2, uint64_t a3, Float64 a4, double a5)
{
  double v9;
  double v10;
  double v11;
  uint64_t v12;
  NSObject *v13;
  NSObject *v14;
  int v15;
  double v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  NSObject *v20;
  int v21;
  uint64_t v22;
  double v23;
  double v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  double v28;
  uint64_t v29;
  double v30;
  int v31;
  int v33;
  int v34;
  double v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  __int16 v39;
  const char *v40;
  __int16 v41;
  int v42;
  __int16 v43;
  double v44;
  __int16 v45;
  int v46;
  __int16 v47;
  double v48;
  __int16 v49;
  uint64_t v50;
  __int16 v51;
  double v52;
  __int16 v53;
  double v54;
  __int16 v55;
  uint64_t v56;
  __int16 v57;
  int v58;
  uint64_t v59;

  v59 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a2 + 32))
  {
    if (*(_DWORD *)a2)
    {
      if (*(_BYTE *)(a1 + 560))
      {
        if (*(_BYTE *)(a2 + 72))
        {
          _VCVideoPlayer_DoPlayoutTimeReAnchor(a1, a2, (double *)a3, a5);
        }
        else if (*(_BYTE *)(a1 + 563) && *(_BYTE *)(a2 + 40))
        {
          _VCVideoPlayer_JitterAdaptation_HandleQueueSizeChange(a1, a2, a3, a4, a5);
        }
      }
      v9 = *(double *)a3;
      if (*(_BYTE *)(a2 + 104))
      {
        v10 = v9 - *(double *)(a2 + 128);
        v11 = *(double *)(a2 + 112) + v10;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          v12 = VRTraceErrorLogLevelToCSTR();
          v13 = *MEMORY[0x1E0CF2758];
          v14 = *MEMORY[0x1E0CF2758];
          if (*MEMORY[0x1E0CF2748])
          {
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
            {
              v15 = *(_DWORD *)(a3 + 24);
              v16 = *(double *)(a2 + 112);
              v17 = *(_QWORD *)(a2 + 128);
              v37 = 136316930;
              v38 = v12;
              v39 = 2080;
              v40 = "_VCVideoPlayer_GetPresentationTime";
              v41 = 1024;
              v42 = 317;
              v43 = 2048;
              v44 = v11;
              v45 = 1024;
              v46 = v15;
              v47 = 2048;
              v48 = v16;
              v49 = 2048;
              v50 = v17;
              v51 = 2048;
              v52 = v10;
              _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, "VCVideoPlayer [%s] %s:%d Adjusting presentationTime=%f rtpTimestamp=%u adjustedPresentationTime=%f adjustedVideoFrameTimeInSeconds=%f durationInSeconds=%f", (uint8_t *)&v37, 0x4Au);
            }
          }
          else if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
          {
            v34 = *(_DWORD *)(a3 + 24);
            v35 = *(double *)(a2 + 112);
            v36 = *(_QWORD *)(a2 + 128);
            v37 = 136316930;
            v38 = v12;
            v39 = 2080;
            v40 = "_VCVideoPlayer_GetPresentationTime";
            v41 = 1024;
            v42 = 317;
            v43 = 2048;
            v44 = v11;
            v45 = 1024;
            v46 = v34;
            v47 = 2048;
            v48 = v35;
            v49 = 2048;
            v50 = v36;
            v51 = 2048;
            v52 = v10;
            _os_log_debug_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEBUG, "VCVideoPlayer [%s] %s:%d Adjusting presentationTime=%f rtpTimestamp=%u adjustedPresentationTime=%f adjustedVideoFrameTimeInSeconds=%f durationInSeconds=%f", (uint8_t *)&v37, 0x4Au);
          }
        }
        if (!*(_BYTE *)(a2 + 105) && *(_DWORD *)(a3 + 32) == 1 && !*(_BYTE *)(a2 + 136))
        {
          *(_DWORD *)(a2 + 120) = *(_DWORD *)(a3 + 24);
          *(_BYTE *)(a2 + 105) = 1;
        }
      }
      else
      {
        v11 = *(double *)(a2 + 160) + v9 - *(double *)(a2 + 176);
      }
      if (*(_BYTE *)(a2 + 136))
        v11 = _VCVideoPlayer_PreventBackwardPresentationTime(a1, a3, a2, v11);
    }
    else if (*(_DWORD *)(a3 + 24) == *(_DWORD *)(a2 + 16))
    {
      v11 = *(double *)(a2 + 8);
    }
    else
    {
      v11 = *(double *)(a2 + 8) + *(double *)a3 - *(double *)(a2 + 24);
    }
  }
  else
  {
    v11 = *(double *)(a2 + 8);
    if (v11 == 0.0)
    {
      v11 = micro();
      *(double *)(a2 + 8) = v11;
      *(_DWORD *)(a2 + 16) = *(_DWORD *)(a3 + 24);
    }
    *(_QWORD *)(a2 + 24) = *(_QWORD *)a3;
    *(_BYTE *)(a2 + 32) = 1;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v18 = VRTraceErrorLogLevelToCSTR();
    v19 = *MEMORY[0x1E0CF2758];
    v20 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        v21 = *(_DWORD *)(a3 + 24);
        v22 = *(_QWORD *)(a2 + 160);
        if (*(_DWORD *)a2)
        {
          v23 = *(double *)a3 - *(double *)(a2 + 176);
          v24 = *(double *)a3;
          v25 = *(_QWORD *)(a2 + 176);
        }
        else
        {
          v24 = *(double *)a3;
          v25 = *(_QWORD *)(a2 + 176);
          v23 = 0.0;
        }
        v31 = *(_DWORD *)(a3 + 32);
        v37 = 136317698;
        v38 = v18;
        v39 = 2080;
        v40 = "_VCVideoPlayer_GetPresentationTime";
        v41 = 1024;
        v42 = 333;
        v43 = 2048;
        v44 = v11;
        v45 = 1024;
        v46 = v21;
        v47 = 2048;
        v48 = a5;
        v49 = 2048;
        v50 = v22;
        v51 = 2048;
        v52 = v23;
        v53 = 2048;
        v54 = v24;
        v55 = 2048;
        v56 = v25;
        v57 = 1024;
        v58 = v31;
        _os_log_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_DEFAULT, "VCVideoPlayer [%s] %s:%d presentationTime=%f rtpTimestamp=%u delayOffsetInSeconds=%f lastFrame.presentationTime=%f durationInSeconds=%f videoFrameTimeInSeconds=%f lastFrame.videoFrameTimeInSeconds=%f alarmType=%d", (uint8_t *)&v37, 0x64u);
      }
    }
    else if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      v26 = *(_DWORD *)(a3 + 24);
      v27 = *(_QWORD *)(a2 + 160);
      if (*(_DWORD *)a2)
      {
        v30 = *(double *)a3 - *(double *)(a2 + 176);
        v28 = *(double *)a3;
        v29 = *(_QWORD *)(a2 + 176);
      }
      else
      {
        v28 = *(double *)a3;
        v29 = *(_QWORD *)(a2 + 176);
        v30 = 0.0;
      }
      v33 = *(_DWORD *)(a3 + 32);
      v37 = 136317698;
      v38 = v18;
      v39 = 2080;
      v40 = "_VCVideoPlayer_GetPresentationTime";
      v41 = 1024;
      v42 = 333;
      v43 = 2048;
      v44 = v11;
      v45 = 1024;
      v46 = v26;
      v47 = 2048;
      v48 = a5;
      v49 = 2048;
      v50 = v27;
      v51 = 2048;
      v52 = v30;
      v53 = 2048;
      v54 = v28;
      v55 = 2048;
      v56 = v29;
      v57 = 1024;
      v58 = v33;
      _os_log_debug_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_DEBUG, "VCVideoPlayer [%s] %s:%d presentationTime=%f rtpTimestamp=%u delayOffsetInSeconds=%f lastFrame.presentationTime=%f durationInSeconds=%f videoFrameTimeInSeconds=%f lastFrame.videoFrameTimeInSeconds=%f alarmType=%d", (uint8_t *)&v37, 0x64u);
    }
  }
  return v11;
}

BOOL _VCVideoPlayer_ShouldProcessAlarmForExternalPlayout(uint64_t a1, uint64_t a2, uint64_t a3, double *a4, double *a5)
{
  double v10;
  double v11;
  double v12;

  v10 = micro();
  if (*(_BYTE *)(a1 + 800))
    v11 = *(double *)(a2 + 152) + *(double *)a3 - *(double *)(a2 + 272);
  else
    v11 = v10;
  *a4 = v11;
  v12 = *(double *)a3 - *(double *)(a2 + 144) + *(double *)(a2 + 152) - v10;
  *a5 = v12;
  if (!*(_BYTE *)(a2 + 32))
  {
    *(double *)(a2 + 8) = *a4;
    *(_DWORD *)(a2 + 16) = *(_DWORD *)(a3 + 24);
    *(_QWORD *)(a2 + 24) = *(_QWORD *)a3;
    *(_BYTE *)(a2 + 32) = 1;
    v12 = *a5;
  }
  return v12 <= 0.001 || !*(_DWORD *)a2 || *(_DWORD *)(a2 + 36) != 0;
}

BOOL _VCVideoPlayer_ShouldProcessAlarmForDeferredDecode(uint64_t a1, uint64_t a2, uint64_t a3, double *a4, double *a5)
{
  double v10;
  double v11;
  double PresentationTime;
  double v13;

  v10 = *(double *)(a1 + 792) + *(double *)(a2 + 48) + *(double *)(a2 + 256);
  *(double *)(a2 + 56) = v10;
  v11 = micro();
  PresentationTime = _VCVideoPlayer_GetPresentationTime(a1, a2, a3, v11, v10);
  *a4 = PresentationTime;
  v13 = PresentationTime - v11;
  *a5 = v13;
  return v13 <= 0.001 || !*(_DWORD *)a2 || *(_DWORD *)(a2 + 36) != 0;
}

uint64_t _VCVideoPlayer_ShouldProcessAlarmForDisplayLinkImmediateDecode(uint64_t a1, double *a2, uint64_t a3, double *a4, double *a5, double *a6)
{
  double v12;
  double DisplayTimestamp;
  double PresentationTime;
  double v15;
  uint64_t v16;
  NSObject *v17;
  NSObject *v18;
  double v19;
  double v21;
  int v22;
  uint64_t v23;
  __int16 v24;
  const char *v25;
  __int16 v26;
  int v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  double v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v12 = *(double *)(a1 + 792) + a2[6] + a2[32];
  a2[7] = v12;
  DisplayTimestamp = _VCVideoPlayer_GetDisplayTimestamp(a1);
  *a5 = DisplayTimestamp;
  PresentationTime = _VCVideoPlayer_GetPresentationTime(a1, (uint64_t)a2, a3, DisplayTimestamp, v12);
  *a4 = PresentationTime;
  v15 = PresentationTime - *a5 - *(double *)(a1 + 576);
  *a6 = v15;
  if (v15 > 0.001 && (int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v16 = VRTraceErrorLogLevelToCSTR();
    v17 = *MEMORY[0x1E0CF2758];
    v18 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        v19 = *a6;
        v22 = 136316162;
        v23 = v16;
        v24 = 2080;
        v25 = "_VCVideoPlayer_ShouldProcessAlarmForDisplayLinkImmediateDecode";
        v26 = 1024;
        v27 = 439;
        v28 = 2048;
        v29 = a1;
        v30 = 2048;
        v31 = v19;
        _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] high leeway:%f, decoding anyways!", (uint8_t *)&v22, 0x30u);
      }
    }
    else if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      v21 = *a6;
      v22 = 136316162;
      v23 = v16;
      v24 = 2080;
      v25 = "_VCVideoPlayer_ShouldProcessAlarmForDisplayLinkImmediateDecode";
      v26 = 1024;
      v27 = 439;
      v28 = 2048;
      v29 = a1;
      v30 = 2048;
      v31 = v21;
      _os_log_debug_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEBUG, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] high leeway:%f, decoding anyways!", (uint8_t *)&v22, 0x30u);
    }
  }
  return 1;
}

uint64_t _VCVideoPlayer_ShouldProcessAlarmForDisplayLinkWithDisplayAlarms(uint64_t a1, uint64_t a2, uint64_t a3, double *a4, Float64 *a5, double *a6)
{
  double v12;
  double PresentationTime;
  uint64_t v14;
  NSObject *v15;
  NSObject *v16;
  double v17;
  double v18;
  Float64 v19;
  double v21;
  double v22;
  Float64 v23;
  int v24;
  uint64_t v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  double v33;
  __int16 v34;
  double v35;
  __int16 v36;
  Float64 v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  *a5 = _VCVideoPlayer_GetDisplayTimestamp(a1);
  v12 = *(double *)(a1 + 792) + *(double *)(a2 + 48) + *(double *)(a2 + 256);
  *(double *)(a2 + 56) = v12;
  PresentationTime = _VCVideoPlayer_GetPresentationTime(a1, a2, a3, *a5, v12);
  *a4 = PresentationTime;
  *a6 = PresentationTime - *a5;
  if (*a4 > *a5 && (int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v14 = VRTraceErrorLogLevelToCSTR();
    v15 = *MEMORY[0x1E0CF2758];
    v16 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        v17 = *a6;
        v18 = *a4;
        v19 = *a5;
        v24 = 136316674;
        v25 = v14;
        v26 = 2080;
        v27 = "_VCVideoPlayer_ShouldProcessAlarmForDisplayLinkWithDisplayAlarms";
        v28 = 1024;
        v29 = 451;
        v30 = 2048;
        v31 = a1;
        v32 = 2048;
        v33 = v17;
        v34 = 2048;
        v35 = v18;
        v36 = 2048;
        v37 = v19;
        _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] leeway=%f waiting for next tick. presentationTime=%f displayTimestamp=%f", (uint8_t *)&v24, 0x44u);
      }
    }
    else if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      v21 = *a6;
      v22 = *a4;
      v23 = *a5;
      v24 = 136316674;
      v25 = v14;
      v26 = 2080;
      v27 = "_VCVideoPlayer_ShouldProcessAlarmForDisplayLinkWithDisplayAlarms";
      v28 = 1024;
      v29 = 451;
      v30 = 2048;
      v31 = a1;
      v32 = 2048;
      v33 = v21;
      v34 = 2048;
      v35 = v22;
      v36 = 2048;
      v37 = v23;
      _os_log_debug_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEBUG, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] leeway=%f waiting for next tick. presentationTime=%f displayTimestamp=%f", (uint8_t *)&v24, 0x44u);
    }
  }
  if (*(_DWORD *)(a3 + 32))
  {
    if (*a4 > *a5 && *(_DWORD *)a2)
      return *(_DWORD *)(a2 + 36) != 0;
  }
  else if (*a4 > *a5
         && *(unsigned __int16 *)(a2 + 300) >= *(unsigned __int16 *)(a1 + 592)
         && *(_DWORD *)a2
         && *(_BYTE *)(a2 + 302))
  {
    return *(_DWORD *)(a2 + 36) != 0;
  }
  return 1;
}

uint64_t _VCVideoPlayer_ShouldProcessAlarm(_BYTE *a1, double *a2, uint64_t a3, double *a4, double *a5, double *a6)
{
  if (!a1[560])
    return _VCVideoPlayer_ShouldProcessAlarmForExternalPlayout((uint64_t)a1, (uint64_t)a2, a3, a4, a6);
  if (a1[561])
  {
    _VCVideoPlayer_ShouldProcessAlarmForDisplayLinkImmediateDecode((uint64_t)a1, a2, a3, a4, a5, a6);
    return 1;
  }
  else if (a1[562])
  {
    return _VCVideoPlayer_ShouldProcessAlarmForDisplayLinkWithDisplayAlarms((uint64_t)a1, (uint64_t)a2, a3, a4, a5, a6);
  }
  else
  {
    return _VCVideoPlayer_ShouldProcessAlarmForDeferredDecode((uint64_t)a1, (uint64_t)a2, a3, a4, a6);
  }
}

uint64_t _VCVideoPlayer_ProcessAlarmForDecode(uint64_t a1, uint64_t a2, _DWORD *a3, double a4)
{
  int v8;
  double v9;
  __int16 v10;
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  int v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  NSObject *v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  void (*v23)(uint64_t, _BYTE *, uint64_t, _QWORD);
  uint64_t v24;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  _BYTE v35[12];
  _BYTE v36[12];
  int v37;
  __int16 v38;
  uint64_t v39;
  __int16 v40;
  int v41;
  __int16 v42;
  int v43;
  __int16 v44;
  int v45;
  __int16 v46;
  int v47;
  __int16 v48;
  int v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 562))
  {
    *(double *)(a2 + 160) = a4;
    v8 = a3[6];
    if (*(_BYTE *)(a2 + 104) && v8 == *(_DWORD *)(a2 + 120))
    {
      *(_WORD *)(a2 + 104) = 0;
      *(_QWORD *)(a2 + 128) = 0;
      *(_QWORD *)(a2 + 112) = 0;
      *(_BYTE *)(a2 + 136) = 0;
    }
    *(_QWORD *)(a2 + 176) = *(_QWORD *)a3;
    *(_DWORD *)(a2 + 168) = v8;
    *(_OWORD *)(a2 + 184) = *(_OWORD *)(a2 + 160);
    *(_QWORD *)(a2 + 200) = *(_QWORD *)(a2 + 176);
    v9 = micro();
    _VideoPlayer_UpdateReportedAVSyncOffset(a1, a2, v9);
    ++*(_DWORD *)(a1 + 712);
    if (*(double *)(a1 + 720) == 0.0)
      *(_QWORD *)(a1 + 720) = *(_QWORD *)(a2 + 152);
  }
  v10 = *((_WORD *)a3 + 14);
  *(_WORD *)(a2 + 296) = v10;
  if (*(_BYTE *)(a2 + 302))
    *(_WORD *)(a2 + 300) = v10 - *(_WORD *)(a2 + 298);
  if (*(_DWORD *)a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v11 = VRTraceErrorLogLevelToCSTR();
      v12 = *MEMORY[0x1E0CF2758];
      v13 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          v14 = a3[6];
          v15 = *(unsigned __int16 *)(a2 + 300);
          v16 = *(unsigned __int16 *)(a2 + 296);
          v17 = *(unsigned __int16 *)(a2 + 298);
          *(_DWORD *)v35 = 136316930;
          *(_QWORD *)&v35[4] = v11;
          *(_WORD *)v36 = 2080;
          *(_QWORD *)&v36[2] = "_VCVideoPlayer_ProcessAlarmForDecode";
          *(_WORD *)&v36[10] = 1024;
          v37 = 527;
          v38 = 2048;
          v39 = a1;
          v40 = 1024;
          v41 = v14;
          v42 = 1024;
          v43 = v15;
          v44 = 1024;
          v45 = v16;
          v46 = 1024;
          v47 = v17;
          _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] rtpTimestamp=%u alarmsSentForDecodeButNotDisplayedCount=%u lastFrameSequenceNumberSentForDecode=%u lastFrameSequenceNumberSentForDisplay=%u", v35, 0x3Eu);
        }
      }
      else if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        v26 = a3[6];
        v27 = *(unsigned __int16 *)(a2 + 300);
        v28 = *(unsigned __int16 *)(a2 + 296);
        v29 = *(unsigned __int16 *)(a2 + 298);
        *(_DWORD *)v35 = 136316930;
        *(_QWORD *)&v35[4] = v11;
        *(_WORD *)v36 = 2080;
        *(_QWORD *)&v36[2] = "_VCVideoPlayer_ProcessAlarmForDecode";
        *(_WORD *)&v36[10] = 1024;
        v37 = 527;
        v38 = 2048;
        v39 = a1;
        v40 = 1024;
        v41 = v26;
        v42 = 1024;
        v43 = v27;
        v44 = 1024;
        v45 = v28;
        v46 = 1024;
        v47 = v29;
        _os_log_debug_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEBUG, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] rtpTimestamp=%u alarmsSentForDecodeButNotDisplayedCount=%u lastFrameSequenceNumberSentForDecode=%u lastFrameSequenceNumberSentForDisplay=%u", v35, 0x3Eu);
      }
    }
    if (*(unsigned __int16 *)(a2 + 300) >= *(unsigned __int16 *)(a1 + 592))
    {
      if (*(_BYTE *)(a2 + 302))
      {
        if (*(_BYTE *)(a1 + 562))
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            v18 = VRTraceErrorLogLevelToCSTR();
            v19 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            {
              v30 = *(unsigned __int16 *)(a2 + 300);
              v31 = *(unsigned __int16 *)(a1 + 592);
              v32 = a3[6];
              v33 = *(unsigned __int16 *)(a2 + 296);
              v34 = *(unsigned __int16 *)(a2 + 298);
              *(_DWORD *)v35 = 136317186;
              *(_QWORD *)&v35[4] = v18;
              *(_WORD *)v36 = 2080;
              *(_QWORD *)&v36[2] = "_VCVideoPlayer_ProcessAlarmForDecode";
              *(_WORD *)&v36[10] = 1024;
              v37 = 529;
              v38 = 2048;
              v39 = a1;
              v40 = 1024;
              v41 = v30;
              v42 = 1024;
              v43 = v31;
              v44 = 1024;
              v45 = v32;
              v46 = 1024;
              v47 = v33;
              v48 = 1024;
              v49 = v34;
              _os_log_error_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_ERROR, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] alarmsSentForDecodeButNotDisplayedCount=%u is excessively high, at or above the threshold of %u. rtpTimestamp=%u lastFrameSequenceNumberSentForDecode=%u lastFrameSequenceNumberSentForDisplay=%u", v35, 0x44u);
            }
          }
        }
      }
    }
  }
  *(_QWORD *)(a2 + 240) = *((_QWORD *)a3 + 5);
  v20 = a3[6];
  v21 = *(_QWORD *)a3;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  v23 = (void (*)(uint64_t, _BYTE *, uint64_t, _QWORD))*((_QWORD *)a3 + 1);
  v22 = *((_QWORD *)a3 + 2);
  v24 = *((unsigned __int8 *)a3 + 30);
  *(double *)v35 = a4;
  *(_DWORD *)&v35[8] = v20;
  *(_DWORD *)v36 = -1431655766;
  *(_QWORD *)&v36[4] = v21;
  v23(v22, v35, v24, 0);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  Release(*(_QWORD *)(a1 + 552), a3);
  ++*(_DWORD *)(a1 + 684);
  if (!*(_BYTE *)(a1 + 562))
  {
    *(_DWORD *)a2 = 1;
    *(_DWORD *)(a2 + 36) = 0;
  }
  return 1;
}

double _VideoPlayer_UpdateReportedAVSyncOffset(uint64_t a1, uint64_t a2, double a3)
{
  double v3;
  double v4;
  int v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double result;
  double v17;

  v3 = *(double *)(a2 + 272) + a3 - *(double *)(a2 + 152) - *(double *)(a2 + 176);
  v4 = *(double *)(a1 + 760);
  if (v4 <= v3)
  {
    v6 = *(double *)(a1 + 768);
    if (v6 >= v3)
      v5 = 0;
    else
      v5 = vcvtpd_s64_f64((v6 - v3) * 60.0);
  }
  else
  {
    v5 = vcvtmd_s64_f64((v4 - v3) * 60.0);
  }
  v7 = v3 * 1000.0;
  v8 = (double)v5 / 60.0 * 1000.0;
  v9 = *(double *)(a2 + 344);
  v10 = *(double *)(a2 + 352);
  v11 = fabs(v8);
  if (fabs(v9) >= v11)
    v9 = (double)v5 / 60.0 * 1000.0;
  ++*(_DWORD *)(a2 + 376);
  if (fabs(v10) <= v11)
    v10 = (double)v5 / 60.0 * 1000.0;
  *(double *)(a2 + 344) = v9;
  *(double *)(a2 + 352) = v10;
  v12 = v11 + *(double *)(a2 + 368);
  *(double *)(a2 + 360) = v8 + *(double *)(a2 + 360);
  *(double *)(a2 + 368) = v12;
  ++*(_DWORD *)(a2 + 416);
  v13 = *(double *)(a2 + 384);
  v14 = *(double *)(a2 + 392);
  v15 = fabs(v7);
  if (fabs(v13) >= v15)
    v13 = v7;
  if (fabs(v14) <= v15)
    v14 = v7;
  *(double *)(a2 + 384) = v13;
  *(double *)(a2 + 392) = v14;
  result = v7 + *(double *)(a2 + 400);
  v17 = v15 + *(double *)(a2 + 408);
  *(double *)(a2 + 400) = result;
  *(double *)(a2 + 408) = v17;
  return result;
}

BOOL _VCVideoPlayer_ProcessAlarmForDisplay(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, double a5)
{
  int v6;
  double v8;
  int v11;
  unsigned int v12;
  unsigned int v13;
  BOOL v14;
  unsigned int v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  int v22;
  double v23;
  double DisplayTimestamp;
  double v25;
  double v26;
  double v27;
  double v28;
  _BOOL4 v29;
  uint64_t v30;
  NSObject *v31;
  double v32;
  double v33;
  char v34;
  double v35;
  double v36;
  int v37;
  double v38;
  uint64_t v39;
  NSObject *v40;
  NSObject *v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  double v56;
  double v57;
  double v58;
  _BOOL4 v59;
  int v60;
  double v61;
  int v62;
  uint64_t v63;
  NSObject *v64;
  NSObject *v65;
  int v66;
  double v67;
  uint64_t v68;
  int v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  NSObject *v74;
  uint64_t v75;
  NSObject *v76;
  NSObject *v77;
  int v78;
  int v79;
  int v80;
  int v81;
  int v82;
  uint64_t v83;
  uint64_t v84;
  void (*v85)(uint64_t, _BYTE *, uint64_t, _QWORD, uint64_t, uint64_t);
  uint64_t v86;
  uint64_t v87;
  double v89;
  double v90;
  double v91;
  int v92;
  int v93;
  int v94;
  int v95;
  int v96;
  int v97;
  int v98;
  int v99;
  int v100;
  int v101;
  double v102;
  uint64_t v103;
  int v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  int v108;
  int v109;
  int v110;
  int v111;
  int v112;
  int v113;
  int v114;
  int v115;
  int v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  double v122;
  double v123;
  double v124;
  _BYTE buf[12];
  _BYTE v126[12];
  int v127;
  __int16 v128;
  uint64_t v129;
  __int16 v130;
  _BYTE v131[10];
  _BYTE v132[24];
  _BYTE v133[10];
  __int16 v134;
  _BYTE v135[10];
  uint64_t v136;
  _BYTE v137[6];
  _BYTE v138[6];
  _BYTE v139[6];
  _BYTE v140[76];
  uint64_t v141;
  __int16 v142;
  _BOOL4 v143;
  uint64_t v144;

  v144 = *MEMORY[0x1E0C80C00];
  v6 = *(unsigned __int8 *)(a1 + 562);
  if (*(_BYTE *)(a1 + 562))
  {
    v8 = a5;
    *(double *)(a2 + 160) = a5;
    v11 = a3[6];
    if (*(_BYTE *)(a2 + 104) && v11 == *(_DWORD *)(a2 + 120))
    {
      *(_WORD *)(a2 + 104) = 0;
      *(_QWORD *)(a2 + 128) = 0;
      *(_QWORD *)(a2 + 112) = 0;
      *(_BYTE *)(a2 + 136) = 0;
    }
    *(_QWORD *)(a2 + 176) = *(_QWORD *)a3;
    *(_DWORD *)(a2 + 168) = v11;
    if ((_DWORD)a4)
    {
      *(_OWORD *)(a2 + 184) = *(_OWORD *)(a2 + 160);
      *(_QWORD *)(a2 + 200) = *(_QWORD *)(a2 + 176);
      ++*(_DWORD *)(a1 + 712);
      if (*(double *)(a1 + 720) == 0.0)
        *(_QWORD *)(a1 + 720) = *(_QWORD *)(a2 + 152);
    }
    v12 = *((unsigned __int16 *)a3 + 14);
    *(_WORD *)(a2 + 298) = v12;
    if (!*((_BYTE *)a3 + 30) || *(_BYTE *)(a2 + 302))
    {
      v13 = *(unsigned __int16 *)(a2 + 296);
      v14 = v13 >= v12;
      v15 = v13 - v12;
      if (v15 != 0 && v14)
      {
        *(_WORD *)(a2 + 300) = v15;
        *(_BYTE *)(a2 + 302) = 1;
      }
    }
    v16 = micro();
    v17 = v16;
    if (*(_BYTE *)(a1 + 752))
    {
      v124 = v8;
      v18 = *(double *)(a2 + 272);
      v19 = v18 + v16 - *(double *)(a2 + 152);
      v20 = *(double *)(a2 + 176);
      v21 = *(double *)(a2 + 48);
      v22 = *(_DWORD *)(a1 + 564);
      v23 = *(double *)a3;
      DisplayTimestamp = _VCVideoPlayer_GetDisplayTimestamp(a1);
      v26 = *(double *)(a2 + 280);
      v25 = *(double *)(a2 + 288);
      v27 = *(double *)(a2 + 272);
      v28 = *(double *)(a2 + 152);
      v29 = v25 != 0.0 && vabdd_f64(v27 + v17 - v28, v26 + v17 - v25) >= *(double *)(a1 + 776);
      v32 = v19 - v20;
      v33 = *(double *)(a1 + 784);
      *(double *)(a2 + 280) = v27;
      *(double *)(a2 + 288) = v28;
      v123 = v32;
      if (!*(_DWORD *)a2
        || *((_BYTE *)a3 + 30)
        || !(_DWORD)a4
        || v27 == 0.0
        || (*(_BYTE *)(a2 + 136) ? (v34 = 1) : (v34 = v29),
            (v34 & 1) != 0 || v26 == v27 || v33 <= v21 || v26 == 0.0 || v22 == 3))
      {
        v122 = DisplayTimestamp;
        v38 = 0.0;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          v18 = v23 - v18;
          v39 = VRTraceErrorLogLevelToCSTR();
          v40 = *MEMORY[0x1E0CF2758];
          v41 = *MEMORY[0x1E0CF2758];
          if (*MEMORY[0x1E0CF2748])
          {
            if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
            {
              v42 = a3[8];
              v43 = a3[6];
              v44 = *(_DWORD *)a2;
              v45 = *(unsigned __int8 *)(a2 + 136);
              v46 = *(unsigned __int8 *)(a2 + 72);
              v47 = *(unsigned __int8 *)(a2 + 104);
              v48 = *(unsigned __int8 *)(a2 + 40);
              v49 = *(_DWORD *)(a2 + 212);
              v50 = *(_DWORD *)(a2 + 224);
              v51 = *(_QWORD *)a3;
              v52 = *(_QWORD *)(a2 + 160);
              v53 = *(_QWORD *)(a2 + 272);
              v54 = *(_QWORD *)(a2 + 216);
              v55 = *(_QWORD *)(a2 + 256);
              *(_DWORD *)buf = 136321794;
              *(_QWORD *)&buf[4] = v39;
              *(_WORD *)v126 = 2080;
              *(_QWORD *)&v126[2] = "_VCVideoPlayer_ShouldProcessAVSyncOffset";
              *(_WORD *)&v126[10] = 1024;
              v127 = 381;
              v128 = 2048;
              v129 = a1;
              v130 = 2048;
              *(_QWORD *)v131 = a2;
              *(_WORD *)&v131[8] = 1024;
              *(_DWORD *)v132 = v42;
              *(_WORD *)&v132[4] = 1024;
              *(_DWORD *)&v132[6] = v43;
              *(_WORD *)&v132[10] = 1024;
              *(_DWORD *)&v132[12] = v44;
              *(_WORD *)&v132[16] = 1024;
              *(_DWORD *)&v132[18] = v45;
              *(_WORD *)&v132[22] = 1024;
              *(_DWORD *)v133 = v46;
              *(_WORD *)&v133[4] = 1024;
              *(_DWORD *)&v133[6] = v47;
              v134 = 1024;
              *(_DWORD *)v135 = v48;
              *(_WORD *)&v135[4] = 1024;
              *(_DWORD *)&v135[6] = v29;
              LOWORD(v136) = 1024;
              *(_DWORD *)((char *)&v136 + 2) = v26 == v27;
              HIWORD(v136) = 1024;
              *(_DWORD *)v137 = v33 <= v21;
              *(_WORD *)&v137[4] = 1024;
              *(_DWORD *)v138 = v43;
              *(_WORD *)&v138[4] = 1024;
              *(_DWORD *)v139 = v49;
              *(_WORD *)&v139[4] = 1024;
              *(_DWORD *)v140 = v50;
              *(_WORD *)&v140[4] = 2048;
              *(_QWORD *)&v140[6] = v51;
              *(_WORD *)&v140[14] = 2048;
              *(_QWORD *)&v140[16] = v52;
              *(_WORD *)&v140[24] = 2048;
              *(_QWORD *)&v140[26] = v53;
              *(_WORD *)&v140[34] = 2048;
              *(double *)&v140[36] = v122;
              *(_WORD *)&v140[44] = 2048;
              *(_QWORD *)&v140[46] = v54;
              *(_WORD *)&v140[54] = 2048;
              *(double *)&v140[56] = v18;
              *(_WORD *)&v140[64] = 2048;
              *(double *)&v140[66] = v21;
              *(_WORD *)&v140[74] = 2048;
              v141 = v55;
              v142 = 1024;
              v143 = v22 == 3;
              _os_log_impl(&dword_1D8A54000, v40, OS_LOG_TYPE_DEFAULT, "VCVideoPlayer [%s] %s:%d videoPlayer[%p] playbackClient[%p] Skipping avsync offset calculation. alarmType=%d rtpTimestamp=%u firstFramePresented=%d preventBackwardPresentationTime=%d shouldResetReferenceRTPTimestamp=%d shouldUseAdjustedReference=%d shouldResetPlaybackOffset=%d, isAudioTimestampJumpDetected=%d isAudioStalled=%d isDelayOffsetLagerThanAVSyncMaxJBThreshold=%d | videoFrameRTPTimestamp=%u playoutRTPTimestamp=%u timestampWraps=%u |videoFrameTimeInSeconds=%f lastFrame.presentationTime=%f ExternalSrcPlayoutTimeInSeconds=%f displayLinkTimestamp=%f lastPlayoutRTPTimestampInSeconds=%f | videoAlarmToAudioLeeway=%f | delayOffsetInSeconds=%f avSyncOffset=%f skipAVSyncDueToFixedMode=%d", buf, 0xD4u);
            }
          }
          else if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
          {
            v108 = a3[8];
            v109 = a3[6];
            v110 = *(_DWORD *)a2;
            v111 = *(unsigned __int8 *)(a2 + 136);
            v112 = *(unsigned __int8 *)(a2 + 72);
            v113 = *(unsigned __int8 *)(a2 + 104);
            v114 = *(unsigned __int8 *)(a2 + 40);
            v115 = *(_DWORD *)(a2 + 212);
            v116 = *(_DWORD *)(a2 + 224);
            v117 = *(_QWORD *)a3;
            v118 = *(_QWORD *)(a2 + 160);
            v119 = *(_QWORD *)(a2 + 272);
            v120 = *(_QWORD *)(a2 + 216);
            v121 = *(_QWORD *)(a2 + 256);
            *(_DWORD *)buf = 136321794;
            *(_QWORD *)&buf[4] = v39;
            *(_WORD *)v126 = 2080;
            *(_QWORD *)&v126[2] = "_VCVideoPlayer_ShouldProcessAVSyncOffset";
            *(_WORD *)&v126[10] = 1024;
            v127 = 381;
            v128 = 2048;
            v129 = a1;
            v130 = 2048;
            *(_QWORD *)v131 = a2;
            *(_WORD *)&v131[8] = 1024;
            *(_DWORD *)v132 = v108;
            *(_WORD *)&v132[4] = 1024;
            *(_DWORD *)&v132[6] = v109;
            *(_WORD *)&v132[10] = 1024;
            *(_DWORD *)&v132[12] = v110;
            *(_WORD *)&v132[16] = 1024;
            *(_DWORD *)&v132[18] = v111;
            *(_WORD *)&v132[22] = 1024;
            *(_DWORD *)v133 = v112;
            *(_WORD *)&v133[4] = 1024;
            *(_DWORD *)&v133[6] = v113;
            v134 = 1024;
            *(_DWORD *)v135 = v114;
            *(_WORD *)&v135[4] = 1024;
            *(_DWORD *)&v135[6] = v29;
            LOWORD(v136) = 1024;
            *(_DWORD *)((char *)&v136 + 2) = v26 == v27;
            HIWORD(v136) = 1024;
            *(_DWORD *)v137 = v33 <= v21;
            *(_WORD *)&v137[4] = 1024;
            *(_DWORD *)v138 = v109;
            *(_WORD *)&v138[4] = 1024;
            *(_DWORD *)v139 = v115;
            *(_WORD *)&v139[4] = 1024;
            *(_DWORD *)v140 = v116;
            *(_WORD *)&v140[4] = 2048;
            *(_QWORD *)&v140[6] = v117;
            *(_WORD *)&v140[14] = 2048;
            *(_QWORD *)&v140[16] = v118;
            *(_WORD *)&v140[24] = 2048;
            *(_QWORD *)&v140[26] = v119;
            *(_WORD *)&v140[34] = 2048;
            *(double *)&v140[36] = v122;
            *(_WORD *)&v140[44] = 2048;
            *(_QWORD *)&v140[46] = v120;
            *(_WORD *)&v140[54] = 2048;
            *(double *)&v140[56] = v18;
            *(_WORD *)&v140[64] = 2048;
            *(double *)&v140[66] = v21;
            *(_WORD *)&v140[74] = 2048;
            v141 = v121;
            v142 = 1024;
            v143 = v22 == 3;
            _os_log_debug_impl(&dword_1D8A54000, v40, OS_LOG_TYPE_DEBUG, "VCVideoPlayer [%s] %s:%d videoPlayer[%p] playbackClient[%p] Skipping avsync offset calculation. alarmType=%d rtpTimestamp=%u firstFramePresented=%d preventBackwardPresentationTime=%d shouldResetReferenceRTPTimestamp=%d shouldUseAdjustedReference=%d shouldResetPlaybackOffset=%d, isAudioTimestampJumpDetected=%d isAudioStalled=%d isDelayOffsetLagerThanAVSyncMaxJBThreshold=%d | videoFrameRTPTimestamp=%u playoutRTPTimestamp=%u timestampWraps=%u |videoFrameTimeInSeconds=%f lastFrame.presentationTime=%f ExternalSrcPlayoutTimeInSeconds=%f displayLinkTimestamp=%f lastPlayoutRTPTimestampInSeconds=%f | videoAlarmToAudioLeeway=%f | delayOffsetInSeconds=%f avSyncOffset=%f skipAVSyncDueToFixedMode=%d", buf, 0xD4u);
          }
        }
        v8 = v124;
      }
      else
      {
        v35 = v32 * 0.2 + *(double *)(a2 + 264) * 0.8;
        *(double *)(a2 + 264) = v35;
        v36 = *(double *)(a1 + 760);
        if (v36 <= v35)
        {
          v89 = *(double *)(a1 + 768);
          v8 = v124;
          if (v89 >= v35)
            v37 = 0;
          else
            v37 = vcvtpd_s64_f64((v89 - v35) * 60.0);
        }
        else
        {
          v37 = vcvtmd_s64_f64((v36 - v35) * 60.0);
          v8 = v124;
        }
        v38 = (double)v37 / 60.0;
        if (v38 != 0.0)
        {
          *(double *)(a2 + 64) = v38 + *(double *)(a2 + 64);
          *(double *)(a2 + 264) = v35 + v38;
          *(_BYTE *)(a2 + 40) = 1;
          ++*(_DWORD *)(a2 + 336);
          *(double *)(a2 + 320) = *(double *)(a2 + 320) + (double)(int)((fabs(v38) + 0.0005) * 1000.0);
        }
        *(double *)(a2 + 256) = v38;
        v90 = v38 * 1000.0;
        v91 = *(double *)(a2 + 304);
        if (v91 >= v38 * 1000.0)
          v91 = v38 * 1000.0;
        if (*(double *)(a2 + 312) > v90)
          v90 = *(double *)(a2 + 312);
        *(double *)(a2 + 304) = v91;
        *(double *)(a2 + 312) = v90;
      }
      v56 = *(double *)(a2 + 272) + v17 - *(double *)(a2 + 152);
      v57 = *(double *)(a2 + 176);
      v58 = v56 - (v57 - v38);
      v59 = v58 <= 0.0343333333 && v58 >= -0.0176666667;
      LODWORD(v18) = *(_DWORD *)(a1 + 568);
      v60 = *(_DWORD *)(a2 + 168);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v61 = v57 - v56;
        v62 = (int)(v56 * (double)*(unint64_t *)&v18) - v60;
        v63 = VRTraceErrorLogLevelToCSTR();
        v64 = *MEMORY[0x1E0CF2758];
        v65 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
          {
            v66 = *((unsigned __int16 *)a3 + 14);
            v67 = v17 - *(double *)(a2 + 152);
            v68 = *(_QWORD *)(a2 + 56);
            v69 = *(_DWORD *)(a2 + 168);
            v70 = *(_QWORD *)(a2 + 176);
            v72 = *(_QWORD *)(a2 + 264);
            v71 = *(_QWORD *)(a2 + 272);
            *(_DWORD *)buf = 136320770;
            *(_QWORD *)&buf[4] = v63;
            *(_WORD *)v126 = 2080;
            *(_QWORD *)&v126[2] = "_VCVideoPlayer_DumpAVSyncState";
            *(_WORD *)&v126[10] = 1024;
            v127 = 399;
            v128 = 2048;
            v129 = a1;
            v130 = 2048;
            *(_QWORD *)v131 = a2;
            *(_WORD *)&v131[8] = 2048;
            *(_QWORD *)v132 = a3;
            *(_WORD *)&v132[8] = 1024;
            *(_DWORD *)&v132[10] = v66;
            *(_WORD *)&v132[14] = 2048;
            *(_QWORD *)&v132[16] = v71;
            *(_WORD *)v133 = 2048;
            *(double *)&v133[2] = v17;
            v134 = 2048;
            *(double *)v135 = v67;
            *(_WORD *)&v135[8] = 2048;
            v136 = v68;
            *(_WORD *)v137 = 1024;
            *(_DWORD *)&v137[2] = v69;
            *(_WORD *)v138 = 1024;
            *(_DWORD *)&v138[2] = (int)(v56 * (double)*(unint64_t *)&v18);
            *(_WORD *)v139 = 1024;
            *(_DWORD *)&v139[2] = v62;
            *(_WORD *)v140 = 2048;
            *(_QWORD *)&v140[2] = v70;
            *(_WORD *)&v140[10] = 2048;
            *(double *)&v140[12] = v56;
            *(_WORD *)&v140[20] = 2048;
            *(double *)&v140[22] = v123;
            *(_WORD *)&v140[30] = 2048;
            *(_QWORD *)&v140[32] = v72;
            *(_WORD *)&v140[40] = 2048;
            *(_QWORD *)&v140[42] = 0;
            *(_WORD *)&v140[50] = 2048;
            *(double *)&v140[52] = v38;
            *(_WORD *)&v140[60] = 2048;
            *(double *)&v140[62] = v58;
            *(_WORD *)&v140[70] = 1024;
            *(_DWORD *)&v140[72] = v59;
            LOWORD(v141) = 1024;
            *(_DWORD *)((char *)&v141 + 2) = v61 > 0.0;
            _os_log_impl(&dword_1D8A54000, v64, OS_LOG_TYPE_DEFAULT, "VCVideoPlayer [%s] %s:%d videoPlayer[%p] playbackClient[%p] displayAlarm[%p] frameSequenceNumber=%u ExternalSrcPlayoutTimeInSeconds=%f currentTime=%f HostTimeOffset=%f playbackOffsetInSeconds=%f | Math: lastFrame.rtpTimestamp=%u externalSourcePlayoutTimestamp=%u avSyncDeltaInSamples=%d, videoTimeInSeconds=%f, audioTimeInSeconds=%f playoutOffset=%f avPlayoutOffsetAverage=%f avSyncOffset=%f avSyncOffsetQuantized=%f | Validation: avSyncOffsetValidation=%f isNewPresentationTimeInLineWithAVSyncOffset=%d | isVideoEarly=%d", buf, 0xCCu);
          }
        }
        else if (os_log_type_enabled(v65, OS_LOG_TYPE_DEBUG))
        {
          v101 = *((unsigned __int16 *)a3 + 14);
          v102 = v17 - *(double *)(a2 + 152);
          v103 = *(_QWORD *)(a2 + 56);
          v104 = *(_DWORD *)(a2 + 168);
          v105 = *(_QWORD *)(a2 + 176);
          v107 = *(_QWORD *)(a2 + 264);
          v106 = *(_QWORD *)(a2 + 272);
          *(_DWORD *)buf = 136320770;
          *(_QWORD *)&buf[4] = v63;
          *(_WORD *)v126 = 2080;
          *(_QWORD *)&v126[2] = "_VCVideoPlayer_DumpAVSyncState";
          *(_WORD *)&v126[10] = 1024;
          v127 = 399;
          v128 = 2048;
          v129 = a1;
          v130 = 2048;
          *(_QWORD *)v131 = a2;
          *(_WORD *)&v131[8] = 2048;
          *(_QWORD *)v132 = a3;
          *(_WORD *)&v132[8] = 1024;
          *(_DWORD *)&v132[10] = v101;
          *(_WORD *)&v132[14] = 2048;
          *(_QWORD *)&v132[16] = v106;
          *(_WORD *)v133 = 2048;
          *(double *)&v133[2] = v17;
          v134 = 2048;
          *(double *)v135 = v102;
          *(_WORD *)&v135[8] = 2048;
          v136 = v103;
          *(_WORD *)v137 = 1024;
          *(_DWORD *)&v137[2] = v104;
          *(_WORD *)v138 = 1024;
          *(_DWORD *)&v138[2] = (int)(v56 * (double)*(unint64_t *)&v18);
          *(_WORD *)v139 = 1024;
          *(_DWORD *)&v139[2] = v62;
          *(_WORD *)v140 = 2048;
          *(_QWORD *)&v140[2] = v105;
          *(_WORD *)&v140[10] = 2048;
          *(double *)&v140[12] = v56;
          *(_WORD *)&v140[20] = 2048;
          *(double *)&v140[22] = v123;
          *(_WORD *)&v140[30] = 2048;
          *(_QWORD *)&v140[32] = v107;
          *(_WORD *)&v140[40] = 2048;
          *(_QWORD *)&v140[42] = 0;
          *(_WORD *)&v140[50] = 2048;
          *(double *)&v140[52] = v38;
          *(_WORD *)&v140[60] = 2048;
          *(double *)&v140[62] = v58;
          *(_WORD *)&v140[70] = 1024;
          *(_DWORD *)&v140[72] = v59;
          LOWORD(v141) = 1024;
          *(_DWORD *)((char *)&v141 + 2) = v61 > 0.0;
          _os_log_debug_impl(&dword_1D8A54000, v64, OS_LOG_TYPE_DEBUG, "VCVideoPlayer [%s] %s:%d videoPlayer[%p] playbackClient[%p] displayAlarm[%p] frameSequenceNumber=%u ExternalSrcPlayoutTimeInSeconds=%f currentTime=%f HostTimeOffset=%f playbackOffsetInSeconds=%f | Math: lastFrame.rtpTimestamp=%u externalSourcePlayoutTimestamp=%u avSyncDeltaInSamples=%d, videoTimeInSeconds=%f, audioTimeInSeconds=%f playoutOffset=%f avPlayoutOffsetAverage=%f avSyncOffset=%f avSyncOffsetQuantized=%f | Validation: avSyncOffsetValidation=%f isNewPresentationTimeInLineWithAVSyncOffset=%d | isVideoEarly=%d", buf, 0xCCu);
        }
      }
    }
    _VideoPlayer_UpdateReportedAVSyncOffset(a1, a2, v17);
    if (*(unsigned __int16 *)(a2 + 300) >= *(unsigned __int16 *)(a1 + 592)
      && (int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v73 = VRTraceErrorLogLevelToCSTR();
      v74 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v92 = *(unsigned __int16 *)(a2 + 300);
        v93 = *(unsigned __int16 *)(a1 + 592);
        v94 = a3[6];
        v95 = *(unsigned __int16 *)(a2 + 296);
        v96 = *(unsigned __int16 *)(a2 + 298);
        *(_DWORD *)buf = 136317186;
        *(_QWORD *)&buf[4] = v73;
        *(_WORD *)v126 = 2080;
        *(_QWORD *)&v126[2] = "_VCVideoPlayer_ProcessAlarmForDisplay";
        *(_WORD *)&v126[10] = 1024;
        v127 = 636;
        v128 = 2048;
        v129 = a1;
        v130 = 1024;
        *(_DWORD *)v131 = v92;
        *(_WORD *)&v131[4] = 1024;
        *(_DWORD *)&v131[6] = v93;
        *(_WORD *)v132 = 1024;
        *(_DWORD *)&v132[2] = v94;
        *(_WORD *)&v132[6] = 1024;
        *(_DWORD *)&v132[8] = v95;
        *(_WORD *)&v132[12] = 1024;
        *(_DWORD *)&v132[14] = v96;
        _os_log_error_impl(&dword_1D8A54000, v74, OS_LOG_TYPE_ERROR, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] alarmsSentForDecodeButNotDisplayedCount=%u is excessively high, at or above the threshold of %u. rtpTimestamp=%u lastFrameSequenceNumberSentForDecode=%u lastFrameSequenceNumberSentForDisplay=%u", buf, 0x44u);
      }
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v75 = VRTraceErrorLogLevelToCSTR();
      v76 = *MEMORY[0x1E0CF2758];
      v77 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
        {
          v78 = a3[6];
          v79 = *(unsigned __int16 *)(a2 + 300);
          v80 = *(unsigned __int16 *)(a2 + 296);
          v81 = *(unsigned __int16 *)(a2 + 298);
          *(_DWORD *)buf = 136316930;
          *(_QWORD *)&buf[4] = v75;
          *(_WORD *)v126 = 2080;
          *(_QWORD *)&v126[2] = "_VCVideoPlayer_ProcessAlarmForDisplay";
          *(_WORD *)&v126[10] = 1024;
          v127 = 638;
          v128 = 2048;
          v129 = a1;
          v130 = 1024;
          *(_DWORD *)v131 = v78;
          *(_WORD *)&v131[4] = 1024;
          *(_DWORD *)&v131[6] = v79;
          *(_WORD *)v132 = 1024;
          *(_DWORD *)&v132[2] = v80;
          *(_WORD *)&v132[6] = 1024;
          *(_DWORD *)&v132[8] = v81;
          _os_log_impl(&dword_1D8A54000, v76, OS_LOG_TYPE_DEFAULT, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] rtpTimestamp=%u alarmsSentForDecodeButNotDisplayedCount=%u lastFrameSequenceNumberSentForDecode=%u lastFrameSequenceNumberSentForDisplay=%u", buf, 0x3Eu);
        }
      }
      else if (os_log_type_enabled(v77, OS_LOG_TYPE_DEBUG))
      {
        v97 = a3[6];
        v98 = *(unsigned __int16 *)(a2 + 300);
        v99 = *(unsigned __int16 *)(a2 + 296);
        v100 = *(unsigned __int16 *)(a2 + 298);
        *(_DWORD *)buf = 136316930;
        *(_QWORD *)&buf[4] = v75;
        *(_WORD *)v126 = 2080;
        *(_QWORD *)&v126[2] = "_VCVideoPlayer_ProcessAlarmForDisplay";
        *(_WORD *)&v126[10] = 1024;
        v127 = 638;
        v128 = 2048;
        v129 = a1;
        v130 = 1024;
        *(_DWORD *)v131 = v97;
        *(_WORD *)&v131[4] = 1024;
        *(_DWORD *)&v131[6] = v98;
        *(_WORD *)v132 = 1024;
        *(_DWORD *)&v132[2] = v99;
        *(_WORD *)&v132[6] = 1024;
        *(_DWORD *)&v132[8] = v100;
        _os_log_debug_impl(&dword_1D8A54000, v76, OS_LOG_TYPE_DEBUG, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] rtpTimestamp=%u alarmsSentForDecodeButNotDisplayedCount=%u lastFrameSequenceNumberSentForDecode=%u lastFrameSequenceNumberSentForDisplay=%u", buf, 0x3Eu);
      }
    }
    *(_QWORD *)(a2 + 248) = *((_QWORD *)a3 + 5);
    v82 = a3[6];
    v83 = *(_QWORD *)a3;
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
    v85 = (void (*)(uint64_t, _BYTE *, uint64_t, _QWORD, uint64_t, uint64_t))*((_QWORD *)a3 + 1);
    v84 = *((_QWORD *)a3 + 2);
    v86 = *((unsigned __int8 *)a3 + 30);
    v87 = *((unsigned __int16 *)a3 + 14);
    *(double *)buf = v8;
    *(_DWORD *)&buf[8] = v82;
    *(_DWORD *)v126 = -1431655766;
    *(_QWORD *)&v126[4] = v83;
    v85(v84, buf, v86, 0, a4, v87);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
    Release(*(_QWORD *)(a1 + 552), a3);
    ++*(_DWORD *)(a1 + 692);
    *(_DWORD *)a2 = 1;
    *(_DWORD *)(a2 + 36) = 0;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v30 = VRTraceErrorLogLevelToCSTR();
    v31 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCVideoPlayer_ProcessAlarmForDisplay_cold_1(v30, a1, v31);
  }
  return v6 != 0;
}

BOOL _VCVideoPlayer_IsNextDisplayAlarmReadyToShow(uint64_t a1, double *a2, uint64_t a3, double a4)
{
  uint64_t v4;
  double v5;
  _BOOL8 result;

  result = 0;
  if (a3)
  {
    v4 = *(_QWORD *)(a3 + 40);
    if (v4)
    {
      v5 = *(double *)(a1 + 792) + a2[6] + a2[32];
      a2[7] = v5;
      if (_VCVideoPlayer_GetPresentationTime(a1, (uint64_t)a2, v4, a4, v5) <= a4)
        return 1;
    }
  }
  return result;
}

uint64_t _VCVideoPlayer_CheckForNoVideoDisplayedTimeout(uint64_t a1, _DWORD *a2, double a3)
{
  pthread_mutex_t *v6;
  double v7;
  uint64_t v8;
  double v9;

  v6 = (pthread_mutex_t *)(a1 + 816);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 816));
  v7 = *(double *)(a1 + 616);
  if (a3 - *(double *)(a1 + 880) >= v7 && *(_QWORD *)(a1 + 896))
  {
    v8 = 46;
    if (!*a2)
      v8 = 2;
    v9 = a3 - *(double *)&a2[v8];
    if (v9 > v7)
    {
      *(double *)(a1 + 880) = a3;
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
      (*(void (**)(_QWORD, double))(a1 + 896))(*(_QWORD *)(a1 + 888), v9);
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
    }
  }
  return pthread_mutex_unlock(v6);
}

BOOL _VCVideoPlayer_CheckAndProcessAlarm(uint64_t a1, uint64_t a2, _DWORD *a3, double *a4)
{
  int ShouldProcessAlarm;
  int ErrorLogLevelForModule;
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  NSObject *v16;
  NSObject *v17;
  _BOOL8 v18;
  int v19;
  int v20;
  int v21;
  _BOOL8 v22;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  double v30;
  double v31;
  uint8_t buf[4];
  uint64_t v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  int v37;
  __int16 v38;
  uint64_t v39;
  __int16 v40;
  int v41;
  __int16 v42;
  double v43;
  __int16 v44;
  double v45;
  __int16 v46;
  int v47;
  __int16 v48;
  int v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  v30 = 0.0;
  v31 = 0.0;
  ShouldProcessAlarm = _VCVideoPlayer_ShouldProcessAlarm((_BYTE *)a1, (double *)a2, (uint64_t)a3, &v31, &v30, a4);
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (!ShouldProcessAlarm)
  {
    if (ErrorLogLevelForModule >= 8)
    {
      v15 = VRTraceErrorLogLevelToCSTR();
      v16 = *MEMORY[0x1E0CF2758];
      v17 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        v18 = 0;
        if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          goto LABEL_19;
        v19 = a3[8];
        v20 = a3[6];
        v21 = *(unsigned __int16 *)(a2 + 300);
        *(_DWORD *)buf = 136317186;
        v33 = v15;
        v34 = 2080;
        v35 = "_VCVideoPlayer_CheckAndProcessAlarm";
        v36 = 1024;
        v37 = 714;
        v38 = 2048;
        v39 = a1;
        v40 = 1024;
        v41 = v19;
        v42 = 2048;
        v43 = v31;
        v44 = 2048;
        v45 = v30;
        v46 = 1024;
        v47 = v20;
        v48 = 1024;
        v49 = v21;
        _os_log_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEFAULT, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] NOT Processing alarmType=%d, presentationTime=%f displayTime=%f rtpTimeStamp=%u alarmsSentForDecodeButNotDisplayedCount=%d", buf, 0x4Cu);
      }
      else if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        v27 = a3[8];
        v28 = a3[6];
        v29 = *(unsigned __int16 *)(a2 + 300);
        *(_DWORD *)buf = 136317186;
        v33 = v15;
        v34 = 2080;
        v35 = "_VCVideoPlayer_CheckAndProcessAlarm";
        v36 = 1024;
        v37 = 714;
        v38 = 2048;
        v39 = a1;
        v40 = 1024;
        v41 = v27;
        v42 = 2048;
        v43 = v31;
        v44 = 2048;
        v45 = v30;
        v46 = 1024;
        v47 = v28;
        v48 = 1024;
        v49 = v29;
        _os_log_debug_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEBUG, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] NOT Processing alarmType=%d, presentationTime=%f displayTime=%f rtpTimeStamp=%u alarmsSentForDecodeButNotDisplayedCount=%d", buf, 0x4Cu);
      }
    }
    v18 = 0;
    goto LABEL_19;
  }
  if (ErrorLogLevelForModule >= 8)
  {
    v9 = VRTraceErrorLogLevelToCSTR();
    v10 = *MEMORY[0x1E0CF2758];
    v11 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        v12 = a3[8];
        v13 = a3[6];
        v14 = *(unsigned __int16 *)(a2 + 300);
        *(_DWORD *)buf = 136317186;
        v33 = v9;
        v34 = 2080;
        v35 = "_VCVideoPlayer_CheckAndProcessAlarm";
        v36 = 1024;
        v37 = 701;
        v38 = 2048;
        v39 = a1;
        v40 = 1024;
        v41 = v12;
        v42 = 2048;
        v43 = v31;
        v44 = 2048;
        v45 = v30;
        v46 = 1024;
        v47 = v13;
        v48 = 1024;
        v49 = v14;
        _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] Processing alarmType=%d, presentationTime=%f displayTime=%f rtpTimeStamp=%u alarmsSentForDecodeButNotDisplayedCount=%d", buf, 0x4Cu);
      }
    }
    else if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      v24 = a3[8];
      v25 = a3[6];
      v26 = *(unsigned __int16 *)(a2 + 300);
      *(_DWORD *)buf = 136317186;
      v33 = v9;
      v34 = 2080;
      v35 = "_VCVideoPlayer_CheckAndProcessAlarm";
      v36 = 1024;
      v37 = 701;
      v38 = 2048;
      v39 = a1;
      v40 = 1024;
      v41 = v24;
      v42 = 2048;
      v43 = v31;
      v44 = 2048;
      v45 = v30;
      v46 = 1024;
      v47 = v25;
      v48 = 1024;
      v49 = v26;
      _os_log_debug_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEBUG, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] Processing alarmType=%d, presentationTime=%f displayTime=%f rtpTimeStamp=%u alarmsSentForDecodeButNotDisplayedCount=%d", buf, 0x4Cu);
    }
  }
  if (a3[8])
  {
    v22 = !_VCVideoPlayer_IsNextDisplayAlarmReadyToShow(a1, (double *)a2, (uint64_t)a3, v30);
    v18 = _VCVideoPlayer_ProcessAlarmForDisplay(a1, a2, a3, v22, v31);
    if (!v22)
      ++*(_DWORD *)(a1 + 696);
  }
  else
  {
    _VCVideoPlayer_ProcessAlarmForDecode(a1, a2, a3, v31);
    v18 = 1;
  }
LABEL_19:
  _VCVideoPlayer_CheckForNoVideoDisplayedTimeout(a1, (_DWORD *)a2, v31);
  return v18;
}

void _VCVideoPlayer_SetTargetQueueSizeInSeconds(uint64_t a1, uint64_t a2, double a3)
{
  double v4;
  uint64_t v7;
  NSObject *v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  uint64_t v16;
  __int16 v17;
  uint64_t v18;
  __int16 v19;
  double v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v4 = *(double *)(a2 + 48);
  if (v4 != a3)
  {
    *(double *)(a2 + 64) = a3 - v4 + *(double *)(a2 + 64);
    *(double *)(a2 + 48) = a3;
    *(_BYTE *)(a2 + 40) = 1;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v7 = VRTraceErrorLogLevelToCSTR();
      v8 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v9 = 136316418;
        v10 = v7;
        v11 = 2080;
        v12 = "_VCVideoPlayer_SetTargetQueueSizeInSeconds";
        v13 = 1024;
        v14 = 726;
        v15 = 2048;
        v16 = a1;
        v17 = 2048;
        v18 = a2;
        v19 = 2048;
        v20 = a3;
        _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] playbackClient=%p targetQueueSizeInSeconds=%f", (uint8_t *)&v9, 0x3Au);
      }
    }
  }
}

void _VCVideoPlayer_CheckAndProcessDisplayAlarms(uint64_t a1)
{
  _DWORD *v2;
  BOOL v3;
  BOOL v4;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  uint64_t v8;
  uint8_t buf[4];
  uint64_t v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  uint64_t v16;
  __int16 v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 562))
  {
    v2 = *(_DWORD **)(a1 + 376);
    if (v2)
    {
      while (1)
      {
        v8 = 0;
        v3 = _VCVideoPlayer_CheckAndProcessAlarm(a1, a1 + 128, v2, (double *)&v8);
        if (!v3)
          break;
        v2 = *(_DWORD **)(a1 + 376);
        if (v2)
          v4 = v3;
        else
          v4 = 0;
        if (!v4)
          goto LABEL_8;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v5 = VRTraceErrorLogLevelToCSTR();
        v6 = *MEMORY[0x1E0CF2758];
        v7 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136316162;
            v10 = v5;
            v11 = 2080;
            v12 = "_VCVideoPlayer_CheckAndProcessDisplayAlarms";
            v13 = 1024;
            v14 = 739;
            v15 = 2048;
            v16 = a1;
            v17 = 2048;
            v18 = v8;
            _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] Not processing display alarm, wait until next leeway=%f", buf, 0x30u);
          }
        }
        else if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136316162;
          v10 = v5;
          v11 = 2080;
          v12 = "_VCVideoPlayer_CheckAndProcessDisplayAlarms";
          v13 = 1024;
          v14 = 739;
          v15 = 2048;
          v16 = a1;
          v17 = 2048;
          v18 = v8;
          _os_log_debug_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEBUG, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] Not processing display alarm, wait until next leeway=%f", buf, 0x30u);
        }
      }
    }
    else
    {
LABEL_8:
      if (*(_BYTE *)a1)
        pthread_cond_signal((pthread_cond_t *)(a1 + 80));
    }
  }
}

uint64_t _VCVideoPlayer_QueueAlarm(double a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, int a6, int a7, int a8)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  NSObject *v19;
  uint64_t v20;
  NSObject *v21;
  _DWORD *v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  NSObject *v29;
  NSObject *v30;
  const char *v31;
  int v32;
  uint64_t v33;
  NSObject *v34;
  NSObject *v35;
  const char *v36;
  int v37;
  const char *v39;
  int v40;
  const char *v41;
  int v42;
  uint8_t buf[4];
  uint64_t v45;
  __int16 v46;
  const char *v47;
  __int16 v48;
  int v49;
  __int16 v50;
  uint64_t v51;
  __int16 v52;
  _BYTE v53[14];
  __int16 v54;
  int v55;
  __int16 v56;
  int v57;
  __int16 v58;
  int v59;
  uint64_t v60;

  v60 = *MEMORY[0x1E0C80C00];
  v14 = 2147680258;
  v15 = CheckInHandleDebug();
  if (v15)
  {
    v16 = v15;
    if (a3 == 1 && !*(_BYTE *)(v15 + 562))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v20 = VRTraceErrorLogLevelToCSTR();
        v21 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315906;
          v45 = v20;
          v46 = 2080;
          v47 = "_VCVideoPlayer_QueueAlarm";
          v48 = 1024;
          v49 = 827;
          v50 = 2048;
          v51 = v16;
          _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] Ignoring QueueAlarmForDisplay.", buf, 0x26u);
        }
      }
      v14 = 0;
      goto LABEL_56;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v17 = VRTraceErrorLogLevelToCSTR();
      v18 = *MEMORY[0x1E0CF2758];
      v19 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136317186;
          v45 = v17;
          v46 = 2080;
          v47 = "_VCVideoPlayer_QueueAlarm";
          v48 = 1024;
          v49 = 832;
          v50 = 2048;
          v51 = v16;
          v52 = 1024;
          *(_DWORD *)v53 = a3;
          *(_WORD *)&v53[4] = 2048;
          *(double *)&v53[6] = a1;
          v54 = 1024;
          v55 = a6;
          v56 = 1024;
          v57 = a7;
          v58 = 1024;
          v59 = a8;
          _os_log_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_DEFAULT, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] alarmType=%d videoFrameTimeInSeconds=%f rtpTimestamp=%u frameSequenceNumber=%u didAssembleFail=%d", buf, 0x48u);
        }
      }
      else if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136317186;
        v45 = v17;
        v46 = 2080;
        v47 = "_VCVideoPlayer_QueueAlarm";
        v48 = 1024;
        v49 = 832;
        v50 = 2048;
        v51 = v16;
        v52 = 1024;
        *(_DWORD *)v53 = a3;
        *(_WORD *)&v53[4] = 2048;
        *(double *)&v53[6] = a1;
        v54 = 1024;
        v55 = a6;
        v56 = 1024;
        v57 = a7;
        v58 = 1024;
        v59 = a8;
        _os_log_debug_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_DEBUG, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] alarmType=%d videoFrameTimeInSeconds=%f rtpTimestamp=%u frameSequenceNumber=%u didAssembleFail=%d", buf, 0x48u);
      }
    }
    pthread_mutex_lock((pthread_mutex_t *)(v16 + 16));
    v22 = Alloc(*(int **)(v16 + 552));
    if (!v22)
    {
      v14 = 2147680259;
      goto LABEL_55;
    }
    *(double *)v22 = a1;
    v22[6] = a6;
    *((_WORD *)v22 + 14) = a7;
    *((_BYTE *)v22 + 30) = a8;
    v22[8] = a3;
    *((_QWORD *)v22 + 1) = a4;
    *((_QWORD *)v22 + 2) = a5;
    v23 = (_QWORD *)(v16 + 368);
    v24 = 688;
    if (!a3)
      v24 = 680;
    v25 = 376;
    if (a3)
      v23 = (_QWORD *)(v16 + 376);
    else
      v25 = 368;
    ++*(_DWORD *)(v16 + v24);
    v26 = *(_QWORD *)(v16 + v25);
    if (v26 && *(double *)v26 <= a1)
    {
      do
      {
        v27 = v26;
        v26 = *(_QWORD *)(v26 + 40);
      }
      while (v26 && *(double *)v26 <= a1);
      v23 = (_QWORD *)(v27 + 40);
    }
    *((_QWORD *)v22 + 5) = v26;
    *v23 = v22;
    if ((a8 & 1) != 0)
    {
      if (a3)
      {
LABEL_36:
        if (a3 != 1 || *(_BYTE *)(v16 + 737))
          goto LABEL_54;
        if (*(unsigned __int16 *)(v16 + 428) < *(unsigned __int16 *)(v16 + 592) || !*(_BYTE *)(v16 + 430))
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            v33 = VRTraceErrorLogLevelToCSTR();
            v34 = *MEMORY[0x1E0CF2758];
            v35 = *MEMORY[0x1E0CF2758];
            if (*MEMORY[0x1E0CF2748])
            {
              if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
              {
                v36 = "Decode";
                v37 = *(unsigned __int16 *)(v16 + 428);
                *(_DWORD *)buf = 136316674;
                if (a8)
                  v36 = "Player";
                v45 = v33;
                v46 = 2080;
                v47 = "_VCVideoPlayer_QueueAlarm";
                v48 = 1024;
                v49 = 878;
                v50 = 2048;
                v51 = v16;
                v52 = 2080;
                *(_QWORD *)v53 = v36;
                *(_WORD *)&v53[8] = 1024;
                *(_DWORD *)&v53[10] = a6;
                v54 = 1024;
                v55 = v37;
                _os_log_impl(&dword_1D8A54000, v34, OS_LOG_TYPE_DEFAULT, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] Processing on %s Thread. rtpTimeStamp=%u alarmsSentForDecodeButNotDisplayedCount=%u", buf, 0x3Cu);
              }
            }
            else if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
            {
              v41 = "Decode";
              v42 = *(unsigned __int16 *)(v16 + 428);
              *(_DWORD *)buf = 136316674;
              if (a8)
                v41 = "Player";
              v45 = v33;
              v46 = 2080;
              v47 = "_VCVideoPlayer_QueueAlarm";
              v48 = 1024;
              v49 = 878;
              v50 = 2048;
              v51 = v16;
              v52 = 2080;
              *(_QWORD *)v53 = v41;
              *(_WORD *)&v53[8] = 1024;
              *(_DWORD *)&v53[10] = a6;
              v54 = 1024;
              v55 = v42;
              _os_log_debug_impl(&dword_1D8A54000, v34, OS_LOG_TYPE_DEBUG, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] Processing on %s Thread. rtpTimeStamp=%u alarmsSentForDecodeButNotDisplayedCount=%u", buf, 0x3Cu);
            }
          }
          _VCVideoPlayer_CheckAndProcessDisplayAlarms(v16);
          goto LABEL_54;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() < 8)
        {
LABEL_54:
          v14 = 0;
          goto LABEL_55;
        }
        v28 = VRTraceErrorLogLevelToCSTR();
        v29 = *MEMORY[0x1E0CF2758];
        v30 = *MEMORY[0x1E0CF2758];
        if (!*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
          {
            v39 = "Decode";
            v40 = *(unsigned __int16 *)(v16 + 428);
            *(_DWORD *)buf = 136316674;
            if (a8)
              v39 = "Player";
            v45 = v28;
            v46 = 2080;
            v47 = "_VCVideoPlayer_QueueAlarm";
            v48 = 1024;
            v49 = 881;
            v50 = 2048;
            v51 = v16;
            v52 = 2080;
            *(_QWORD *)v53 = v39;
            *(_WORD *)&v53[8] = 1024;
            *(_DWORD *)&v53[10] = a6;
            v54 = 1024;
            v55 = v40;
            _os_log_debug_impl(&dword_1D8A54000, v29, OS_LOG_TYPE_DEBUG, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] NOT processing on %s Thread. rtpTimeStamp=%u alarmsSentForDecodeButNotDisplayedCount=%u", buf, 0x3Cu);
          }
          goto LABEL_54;
        }
        v14 = 0;
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
        {
          v31 = "Decode";
          v32 = *(unsigned __int16 *)(v16 + 428);
          *(_DWORD *)buf = 136316674;
          if (a8)
            v31 = "Player";
          v45 = v28;
          v46 = 2080;
          v47 = "_VCVideoPlayer_QueueAlarm";
          v48 = 1024;
          v49 = 881;
          v50 = 2048;
          v51 = v16;
          v52 = 2080;
          *(_QWORD *)v53 = v31;
          *(_WORD *)&v53[8] = 1024;
          *(_DWORD *)&v53[10] = a6;
          v54 = 1024;
          v55 = v32;
          _os_log_impl(&dword_1D8A54000, v29, OS_LOG_TYPE_DEFAULT, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] NOT processing on %s Thread. rtpTimeStamp=%u alarmsSentForDecodeButNotDisplayedCount=%u", buf, 0x3Cu);
          goto LABEL_54;
        }
LABEL_55:
        pthread_mutex_unlock((pthread_mutex_t *)(v16 + 16));
LABEL_56:
        CheckOutHandleDebug();
        return v14;
      }
    }
    else if (a3 || *(unsigned __int16 *)(v16 + 424) >= *(unsigned __int16 *)(v16 + 426))
    {
      goto LABEL_33;
    }
    if (*(_BYTE *)(v16 + 562))
    {
      *(_WORD *)(v16 + 428) = 0;
      *(_BYTE *)(v16 + 430) = 0;
    }
LABEL_33:
    if (!a3 && *(_BYTE *)v16)
    {
      pthread_cond_signal((pthread_cond_t *)(v16 + 80));
      goto LABEL_54;
    }
    goto LABEL_36;
  }
  return v14;
}

uint64_t VCVideoPlayer_QueueAlarmForDecode(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, int a6, double a7)
{
  return _VCVideoPlayer_QueueAlarm(a7, a1, 0, a2, a3, a4, a5, a6);
}

uint64_t VCVideoPlayer_QueueAlarmForDisplay(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, int a6, double a7)
{
  return _VCVideoPlayer_QueueAlarm(a7, a1, 1, a2, a3, a4, a5, a6);
}

uint64_t VCVideoPlayer_CallAlarms(uint64_t a1, double a2, double a3)
{
  uint64_t v6;
  uint64_t v7;
  double v8;
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v14;
  int v15;
  uint64_t v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  double v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v6 = CheckInHandleDebug();
  if (!v6)
    return 2147680258;
  v7 = v6;
  if (!*(_BYTE *)(v6 + 800))
    a2 = micro();
  pthread_mutex_lock((pthread_mutex_t *)(v7 + 16));
  if (a2 - *(double *)(v7 + 360) > 5.0)
  {
    _VCVideoPlayer_HealthPrint(v7, v7 + 128, NAN);
    *(double *)(v7 + 360) = a2;
  }
  if (!*(_BYTE *)(v7 + 560))
  {
    if (a3 == 0.0)
      *(_DWORD *)(v7 + 164) = 1;
    v8 = *(double *)(v7 + 600) + *(double *)(v7 + 808);
    if (a3 == 0.0 || a3 - *(double *)(v7 + 272) > v8)
      pthread_cond_signal((pthread_cond_t *)(v7 + 80));
    *(double *)(v7 + 272) = v8 + a3;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v9 = VRTraceErrorLogLevelToCSTR();
      v10 = *MEMORY[0x1E0CF2758];
      v11 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          v12 = *(_QWORD *)(v7 + 272);
          v15 = 136316674;
          v16 = v9;
          v17 = 2080;
          v18 = "VCVideoPlayer_CallAlarms";
          v19 = 1024;
          v20 = 924;
          v21 = 2048;
          v22 = v7;
          v23 = 2048;
          v24 = a1;
          v25 = 2048;
          v26 = v12;
          v27 = 2048;
          v28 = a2;
          _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] PlayerHandle=%p nextPlayoutTimeInSeconds=%.6f hostTimeForPlayout=%.6f", (uint8_t *)&v15, 0x44u);
        }
      }
      else if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        v14 = *(_QWORD *)(v7 + 272);
        v15 = 136316674;
        v16 = v9;
        v17 = 2080;
        v18 = "VCVideoPlayer_CallAlarms";
        v19 = 1024;
        v20 = 924;
        v21 = 2048;
        v22 = v7;
        v23 = 2048;
        v24 = a1;
        v25 = 2048;
        v26 = v14;
        v27 = 2048;
        v28 = a2;
        _os_log_debug_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEBUG, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] PlayerHandle=%p nextPlayoutTimeInSeconds=%.6f hostTimeForPlayout=%.6f", (uint8_t *)&v15, 0x44u);
      }
    }
  }
  *(double *)(v7 + 280) = a2;
  *(double *)(v7 + 400) = a3;
  pthread_mutex_unlock((pthread_mutex_t *)(v7 + 16));
  CheckOutHandleDebug();
  return 0;
}

void _VCVideoPlayer_HealthPrint(uint64_t a1, uint64_t a2, double a3)
{
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  __int128 v11;
  __int128 v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int ErrorLogLevelForModule;
  NSObject *v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  NSObject *v30;
  uint32_t v31;
  uint64_t v32;
  NSObject *v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  double v38;
  double v39;
  uint64_t v40;
  int v41;
  uint8_t buf[4];
  uint64_t v43;
  __int16 v44;
  const char *v45;
  __int16 v46;
  int v47;
  __int16 v48;
  uint64_t v49;
  __int16 v50;
  int v51;
  __int16 v52;
  int v53;
  __int16 v54;
  int v55;
  __int16 v56;
  _BYTE v57[10];
  uint64_t v58;
  __int128 v59;
  _BYTE v60[10];
  _BYTE v61[10];
  _BYTE v62[14];
  __int16 v63;
  uint64_t v64;
  __int16 v65;
  uint64_t v66;
  __int16 v67;
  uint64_t v68;
  uint64_t v69;

  v69 = *MEMORY[0x1E0C80C00];
  v6 = *(_DWORD *)(a1 + 632);
  v7 = *(_DWORD *)(a1 + 636);
  v8 = *(_DWORD *)(a1 + 640);
  v9 = *(_DWORD *)(a1 + 644);
  v10 = *(_DWORD *)(a1 + 648);
  v11 = *(_OWORD *)(a1 + 696);
  v12 = *(_OWORD *)(a1 + 712);
  *(_OWORD *)(a1 + 632) = *(_OWORD *)(a1 + 680);
  *(_OWORD *)(a1 + 648) = v11;
  v13 = *(_DWORD *)(a1 + 680) - v6;
  v41 = *(_DWORD *)(a1 + 684) - v7;
  v14 = *(_DWORD *)(a1 + 688);
  v15 = *(_DWORD *)(a1 + 692);
  v16 = *(_DWORD *)(a1 + 696);
  *(_OWORD *)(a1 + 664) = v12;
  v17 = *(unsigned __int8 *)(a1 + 562);
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (v17)
  {
    if (ErrorLogLevelForModule >= 6)
    {
      v40 = VRTraceErrorLogLevelToCSTR();
      v19 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v20 = *(_DWORD *)(a1 + 728);
        v21 = *(unsigned __int16 *)(a2 + 300);
        v22 = *(_QWORD *)(a1 + 624);
        v23 = *(_QWORD *)(a2 + 160);
        v24 = *(_DWORD *)(a2 + 168);
        v25 = *(_QWORD *)(a2 + 176);
        v27 = *(_QWORD *)(a2 + 48);
        v26 = *(_QWORD *)(a2 + 56);
        v28 = *(_QWORD *)(a2 + 256);
        *(_DWORD *)buf = 136319746;
        v43 = v40;
        v44 = 2080;
        v45 = "_VCVideoPlayer_HealthPrint";
        v46 = 1024;
        v47 = 810;
        v48 = 2048;
        v49 = a1;
        v50 = 1024;
        v51 = v20;
        v52 = 1024;
        v53 = v13;
        v54 = 1024;
        v55 = v41;
        v56 = 1024;
        *(_DWORD *)v57 = v14 - v8;
        *(_WORD *)&v57[4] = 1024;
        *(_DWORD *)&v57[6] = v15 - v9;
        LOWORD(v58) = 1024;
        *(_DWORD *)((char *)&v58 + 2) = v16 - v10;
        HIWORD(v58) = 1024;
        LODWORD(v59) = v21;
        WORD2(v59) = 2048;
        *(double *)((char *)&v59 + 6) = a3;
        HIWORD(v59) = 2048;
        *(_QWORD *)v60 = v22;
        *(_WORD *)&v60[8] = 2048;
        *(_QWORD *)v61 = v23;
        *(_WORD *)&v61[8] = 1024;
        *(_DWORD *)v62 = v24;
        *(_WORD *)&v62[4] = 2048;
        *(_QWORD *)&v62[6] = v25;
        v63 = 2048;
        v64 = v27;
        v65 = 2048;
        v66 = v26;
        v67 = 2048;
        v68 = v28;
        v29 = "VCVideoPlayer [%s] %s:%d @=@ Health: VCVideoPlayer [%p] Health displayLinkTickCount=%d numAlarmsEnqueuedFo"
              "rDecode=%d numAlarmsProcessedForDecode=%d numAlarmsEnqueuedForDisplay=%d numAlarmsProcessedForDisplay=%d n"
              "umAlarmsDropped=%d alarmsSentForDecodeButNotDisplayedCount=%d tickInterval=%f displayLinkTimestamp=%f last"
              "PresentationTime=%f lastRTPTimestamp=%u lastFrameTimeInSeconds=%f targetJitterBufferInSeconds=%f playbackO"
              "ffsetInSeconds=%f avSyncOffset=%f";
        v30 = v19;
        v31 = 156;
LABEL_8:
        _os_log_impl(&dword_1D8A54000, v30, OS_LOG_TYPE_DEFAULT, v29, buf, v31);
      }
    }
  }
  else if (ErrorLogLevelForModule >= 6)
  {
    v32 = VRTraceErrorLogLevelToCSTR();
    v33 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v34 = *(_DWORD *)(a1 + 728);
      v35 = *(_QWORD *)(a1 + 624);
      v36 = *(_QWORD *)(a2 + 160);
      v37 = *(_DWORD *)(a2 + 168);
      v38 = *(double *)(a2 + 176);
      v39 = *(double *)(a2 + 144);
      *(_DWORD *)buf = 136318466;
      v43 = v32;
      v44 = 2080;
      v45 = "_VCVideoPlayer_HealthPrint";
      v46 = 1024;
      v47 = 812;
      v48 = 2048;
      v49 = a1;
      v50 = 1024;
      v51 = v34;
      v52 = 1024;
      v53 = v13;
      v54 = 1024;
      v55 = v41;
      v56 = 2048;
      *(double *)v57 = a3;
      *(_WORD *)&v57[8] = 2048;
      v58 = v35;
      LOWORD(v59) = 2048;
      *(_QWORD *)((char *)&v59 + 2) = v36;
      WORD5(v59) = 1024;
      HIDWORD(v59) = v37;
      *(_WORD *)v60 = 2048;
      *(double *)&v60[2] = v38;
      *(_WORD *)v61 = 2048;
      *(double *)&v61[2] = v39;
      *(_WORD *)v62 = 2048;
      *(double *)&v62[2] = v38 - v39;
      v29 = "VCVideoPlayer [%s] %s:%d @=@ Health: VCVideoPlayer [%p] Health displayLinkTickCount=%d numAlarmsEnqueuedForD"
            "ecode=%d numAlarmsProcessedForDecode=%d tickInterval=%f displayLinkTimestamp=%f lastPresentationTime=%f last"
            "RTPTimestamp=%u lastFrameTimeInSeconds=%f externalSourcePlayoutTimeInSeconds=%f lastFrameTimeInSeconds-exter"
            "nalSourcePlayoutTimeInSeconds=%f";
      v30 = v33;
      v31 = 122;
      goto LABEL_8;
    }
  }
}

uint64_t VCVideoPlayer_DisplayLinkTick(double a1, double a2, double a3)
{
  uint64_t v6;
  uint64_t v7;
  pthread_mutex_t *v8;
  int v9;
  signed int v10;
  uint64_t v12;
  NSObject *v13;
  NSObject *v14;
  int v15;
  uint64_t v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  double v24;
  __int16 v25;
  double v26;
  __int16 v27;
  double v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v6 = CheckInHandleDebug();
  if (!v6)
    return 2147680259;
  v7 = v6;
  v8 = (pthread_mutex_t *)(v6 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(v6 + 16));
  v9 = *(_DWORD *)(v7 + 728);
  if (v9)
  {
    v10 = *(_DWORD *)(v7 + 732);
  }
  else
  {
    *(double *)(v7 + 744) = a1;
    v10 = vcvtpd_s64_f64(5.0 / a1);
    *(_DWORD *)(v7 + 732) = v10;
  }
  if (!(v9 % v10))
    _VCVideoPlayer_HealthPrint(v7, v7 + 128, a1);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v12 = VRTraceErrorLogLevelToCSTR();
    v13 = *MEMORY[0x1E0CF2758];
    v14 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        v15 = 136316674;
        v16 = v12;
        v17 = 2080;
        v18 = "VCVideoPlayer_DisplayLinkTick";
        v19 = 1024;
        v20 = 953;
        v21 = 2048;
        v22 = v7;
        v23 = 2048;
        v24 = a1;
        v25 = 2048;
        v26 = a2;
        v27 = 2048;
        v28 = a3;
        _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] duration=%f currentDisplayTime=%f targetDisplayTime=%f ", (uint8_t *)&v15, 0x44u);
      }
    }
    else if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      v15 = 136316674;
      v16 = v12;
      v17 = 2080;
      v18 = "VCVideoPlayer_DisplayLinkTick";
      v19 = 1024;
      v20 = 953;
      v21 = 2048;
      v22 = v7;
      v23 = 2048;
      v24 = a1;
      v25 = 2048;
      v26 = a2;
      v27 = 2048;
      v28 = a3;
      _os_log_debug_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEBUG, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] duration=%f currentDisplayTime=%f targetDisplayTime=%f ", (uint8_t *)&v15, 0x44u);
    }
  }
  *(double *)(v7 + 624) = a3;
  ++*(_DWORD *)(v7 + 728);
  _VCVideoPlayer_CheckAndProcessDisplayAlarms(v7);
  pthread_mutex_unlock(v8);
  CheckOutHandleDebug();
  return 0;
}

uint64_t VCVideoPlayer_GetPlayoutInfo(uint64_t a1, unsigned int *a2, uint64_t *a3)
{
  uint64_t v5;
  uint64_t v6;
  pthread_mutex_t *v7;
  double DisplayTimestamp;
  double v9;
  double v10;
  double v11;
  int v12;
  double v13;
  unsigned int v14;
  unsigned int v15;
  int v17;
  uint64_t result;
  uint64_t v20;
  NSObject *v21;
  uint64_t v22;
  int v23;
  unint64_t v24;
  uint64_t v25;
  NSObject *v26;
  NSObject *v27;
  _BOOL4 v28;
  unsigned int v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  int v38;
  __int16 v39;
  _BYTE v40[18];
  __int16 v41;
  double v42;
  __int16 v43;
  uint64_t v44;
  __int16 v45;
  double v46;
  __int16 v47;
  int v48;
  __int16 v49;
  unsigned int v50;
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  v5 = CheckInHandleDebug();
  if (!v5)
    return 2147680258;
  v6 = v5;
  v7 = (pthread_mutex_t *)(v5 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(v5 + 16));
  if (*(_DWORD *)(v6 + 128) && *(_BYTE *)(v6 + 560))
  {
    DisplayTimestamp = _VCVideoPlayer_GetDisplayTimestamp(v6);
    v9 = *(double *)(v6 + 312);
    v10 = DisplayTimestamp - v9;
    if (v9 == 0.0)
      v11 = 0.0;
    else
      v11 = DisplayTimestamp - v9;
    v12 = *(_DWORD *)(v6 + 320);
    if (v11 >= 0.0)
    {
      v13 = v11 * (double)*(unsigned int *)(v6 + 568);
      v14 = v12 + v13;
      v15 = *(_DWORD *)(v6 + 340);
      if (v14 >= v15 || v14 - v15 >= 0x7FFFFFFF)
        goto LABEL_20;
      v17 = 1;
    }
    else
    {
      LODWORD(v10) = *(_DWORD *)(v6 + 568);
      v13 = (v11 + *(double *)(v6 + 744)) * (double)*(unint64_t *)&v10;
      v14 = v12 + v13;
      v15 = *(_DWORD *)(v6 + 340);
      if (v15 >= v14 || v15 - v14 > 0x7FFFFFFE)
        goto LABEL_20;
      v17 = -1;
    }
    *(_DWORD *)(v6 + 352) += v17;
LABEL_20:
    if (!*(_BYTE *)(v6 + 336))
      *(_BYTE *)(v6 + 336) = 1;
    if (v15 == v14 && (int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v20 = VRTraceErrorLogLevelToCSTR();
      v21 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v22 = *(_QWORD *)(v6 + 312);
        v23 = *(_DWORD *)(v6 + 320);
        v33 = 136317442;
        v34 = v20;
        v35 = 2080;
        v36 = "_VCVideoPlayer_GetPlayoutRTPTimestamp";
        v37 = 1024;
        v38 = 993;
        v39 = 2048;
        *(_QWORD *)v40 = v6;
        *(_WORD *)&v40[8] = 2048;
        *(_QWORD *)&v40[10] = v6 + 128;
        v41 = 2048;
        v42 = DisplayTimestamp;
        v43 = 2048;
        v44 = v22;
        v45 = 2048;
        v46 = v11;
        v47 = 1024;
        v48 = v23;
        v49 = 1024;
        v50 = v15;
        _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] playbackClient:%p displayTimestamp:%f lastDisplayedFrame.presentationTime:%f timeDiff:%f lastDisplayedFrame.rtpTimestamp:%u playoutRTPTimestamp:%u", (uint8_t *)&v33, 0x5Au);
      }
    }
    *(_DWORD *)(v6 + 340) = v14;
    LODWORD(v13) = *(_DWORD *)(v6 + 352);
    *(double *)&v24 = (double)v14;
    LODWORD(v24) = *(_DWORD *)(v6 + 568);
    *(double *)(v6 + 344) = ((double)v14 + (double)*(unint64_t *)&v13 * 4294967300.0) / (double)v24;
    *a2 = v14;
    *a3 = *(_QWORD *)(v6 + 384);
  }
  pthread_mutex_unlock(v7);
  CheckOutHandleDebug();
  if ((int)VRTraceGetErrorLogLevelForModule() < 8)
    return 0;
  v25 = VRTraceErrorLogLevelToCSTR();
  v26 = *MEMORY[0x1E0CF2758];
  v27 = *MEMORY[0x1E0CF2758];
  if (*MEMORY[0x1E0CF2748])
  {
    v28 = os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (v28)
    {
      v29 = *a2;
      v30 = *a3;
      v33 = 136316162;
      v34 = v25;
      v35 = 2080;
      v36 = "VCVideoPlayer_GetPlayoutInfo";
      v37 = 1024;
      v38 = 1018;
      v39 = 1024;
      *(_DWORD *)v40 = v29;
      *(_WORD *)&v40[4] = 2048;
      *(_QWORD *)&v40[6] = v30;
      _os_log_impl(&dword_1D8A54000, v26, OS_LOG_TYPE_DEFAULT, "VCVideoPlayer [%s] %s:%d VCVideoPlayer_GetPlayoutInfo setting PlayoutRTPTimestamp: %u, avSyncOffset: %.4f", (uint8_t *)&v33, 0x2Cu);
      return 0;
    }
  }
  else
  {
    result = os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG);
    if ((_DWORD)result)
    {
      v31 = *a2;
      v32 = *a3;
      v33 = 136316162;
      v34 = v25;
      v35 = 2080;
      v36 = "VCVideoPlayer_GetPlayoutInfo";
      v37 = 1024;
      v38 = 1018;
      v39 = 1024;
      *(_DWORD *)v40 = v31;
      *(_WORD *)&v40[4] = 2048;
      *(_QWORD *)&v40[6] = v32;
      _os_log_debug_impl(&dword_1D8A54000, v26, OS_LOG_TYPE_DEBUG, "VCVideoPlayer [%s] %s:%d VCVideoPlayer_GetPlayoutInfo setting PlayoutRTPTimestamp: %u, avSyncOffset: %.4f", (uint8_t *)&v33, 0x2Cu);
      return 0;
    }
  }
  return result;
}

uint64_t VCVideoPlayer_SetReferenceRTPTimestamp(double a1, double a2, uint64_t a3, int a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  int v14;
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  int v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v7 = CheckInHandleDebug();
  if (!v7)
    return 2147680258;
  v8 = v7;
  if (*(_DWORD *)(v7 + 564) != 3)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v7 + 16));
    if (!*(_BYTE *)(v8 + 160))
    {
      *(double *)(v8 + 136) = a1;
      *(_DWORD *)(v8 + 144) = a4;
    }
    if (*(_DWORD *)(v8 + 216) != a4)
    {
      *(_DWORD *)(v8 + 216) = a4;
      *(_BYTE *)(v8 + 200) = 1;
      *(double *)(v8 + 208) = a1;
      *(double *)(v8 + 224) = a2;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v9 = VRTraceErrorLogLevelToCSTR();
        v10 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v11 = *(_QWORD *)(v8 + 208);
          v12 = *(_QWORD *)(v8 + 224);
          v14 = 136316674;
          v15 = v9;
          v16 = 2080;
          v17 = "VCVideoPlayer_SetReferenceRTPTimestamp";
          v18 = 1024;
          v19 = 1045;
          v20 = 2048;
          v21 = v8;
          v22 = 1024;
          v23 = a4;
          v24 = 2048;
          v25 = v11;
          v26 = 2048;
          v27 = v12;
          _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] referenceRTPTimestamp=%u referencePresentationTime=%f videoFrameTimeInSeconds=%f", (uint8_t *)&v14, 0x40u);
        }
      }
    }
    pthread_mutex_unlock((pthread_mutex_t *)(v8 + 16));
    CheckOutHandleDebug();
  }
  return 0;
}

uint64_t VCVideoPlayer_SetTargetQueueSizeInSeconds(double a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  int v7;
  uint64_t v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  uint64_t v14;
  __int16 v15;
  double v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v2 = CheckInHandleDebug();
  if (!v2)
    return 2147680258;
  v3 = v2;
  if (!*(_BYTE *)(v2 + 563))
    goto LABEL_11;
  if (fabs(a1) <= 2.0)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 16));
    _VCVideoPlayer_SetTargetQueueSizeInSeconds(v3, v3 + 128, a1);
    pthread_mutex_unlock((pthread_mutex_t *)(v3 + 16));
LABEL_11:
    CheckOutHandleDebug();
    return 0;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      v7 = 136316162;
      v8 = v4;
      v9 = 2080;
      v10 = "VCVideoPlayer_SetTargetQueueSizeInSeconds";
      v11 = 1024;
      v12 = 1068;
      v13 = 2048;
      v14 = v3;
      v15 = 2048;
      v16 = a1;
      _os_log_error_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_ERROR, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] invalid targetQueueSizeInSeconds:%f!", (uint8_t *)&v7, 0x30u);
    }
  }
  CheckOutHandleDebug();
  return 14;
}

uint64_t VCVideoPlayer_Create(uint64_t *a1, __int128 *a2)
{
  uint64_t result;
  char *v5;
  char *v6;
  char *Alloc;
  uint64_t Handle;
  int v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  double v13;
  void *v14;
  void *v15;
  void *v16;
  CFDictionaryRef v17;
  int v18;
  double v19;
  uint64_t v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  NSObject *v27;
  _BOOL4 v28;
  int v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  __int16 v39;
  const char *v40;
  __int16 v41;
  int v42;
  __int16 v43;
  char *v44;
  __int16 v45;
  _BYTE v46[20];
  _BYTE v47[10];
  _BYTE v48[10];
  uint64_t *v49;
  int v50;
  __int16 v51;
  int v52;
  __int16 v53;
  int v54;
  void *values[3];
  void *keys[4];

  keys[3] = *(void **)MEMORY[0x1E0C80C00];
  result = 2147680257;
  if (!a1 || !a2)
    return result;
  v5 = (char *)malloc_type_calloc(1uLL, 0x388uLL, 0x10A004090E2E21CuLL);
  if (!v5)
    return 2147680259;
  v6 = v5;
  Alloc = CreateAlloc(48, 0);
  *((_QWORD *)v6 + 69) = Alloc;
  if (!Alloc)
  {
    free(v6);
    return 2147680259;
  }
  Handle = CreateHandle();
  *a1 = Handle;
  if (Handle == 0xFFFFFFFFLL)
  {
    DestroyAlloc(*((_QWORD *)v6 + 69));
    free(v6);
    return 2147680261;
  }
  pthread_mutex_init((pthread_mutex_t *)(v6 + 816), 0);
  pthread_mutex_init((pthread_mutex_t *)(v6 + 16), 0);
  pthread_cond_init((pthread_cond_t *)(v6 + 80), 0);
  v9 = _os_feature_enabled_impl();
  v6[800] = v9;
  v11 = *a2;
  v10 = a2[1];
  v12 = a2[3];
  *((_OWORD *)v6 + 37) = a2[2];
  *((_OWORD *)v6 + 38) = v12;
  *((_OWORD *)v6 + 35) = v11;
  *((_OWORD *)v6 + 36) = v10;
  v13 = *((double *)v6 + 75);
  if (v13 == 0.0)
  {
    *((_QWORD *)v6 + 75) = 0x3F947AE147AE147BLL;
    v13 = 0.02;
  }
  if (*((double *)v6 + 77) == 0.0)
    *((_QWORD *)v6 + 77) = 0x4014000000000000;
  if (!v9)
    v13 = 0.0;
  *((double *)v6 + 101) = v13;
  *((_QWORD *)v6 + 78) = 0x7FF8000000000000;
  v14 = (void *)*MEMORY[0x1E0C9AE40];
  if (v6[608])
    v15 = (void *)*MEMORY[0x1E0C9AE40];
  else
    v15 = (void *)*MEMORY[0x1E0C9AE50];
  v16 = (void *)*MEMORY[0x1E0CA52D0];
  keys[0] = *(void **)MEMORY[0x1E0CA52C8];
  keys[1] = v16;
  keys[2] = *(void **)MEMORY[0x1E0CA52C0];
  values[0] = CFSTR("com.apple.avconference.VCVideoPlayer.alarmproc");
  values[1] = v14;
  values[2] = v15;
  v17 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)keys, (const void **)values, 3, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v18 = FigThreadCreate();
  if (v17)
    CFRelease(v17);
  if (v18)
  {
    CheckOutHandleDebug();
    DestroyAlloc(*((_QWORD *)v6 + 69));
    pthread_mutex_destroy((pthread_mutex_t *)(v6 + 816));
    pthread_mutex_destroy((pthread_mutex_t *)(v6 + 16));
    pthread_cond_destroy((pthread_cond_t *)(v6 + 80));
    free(v6);
    return v18 | 0xA0030000;
  }
  v19 = 0.0166666667;
  if ((*((_DWORD *)v6 + 141) & 0xFFFFFFFD) != 0)
    v19 = 0.0;
  *((double *)v6 + 99) = VCDefaults_GetDoubleValueForKey(CFSTR("videoPlayerAverageDecodeTime"), v19);
  v6[752] = *((_BYTE *)a2 + 34);
  v6[737] = VCDefaults_GetBoolValueForKey(CFSTR("videoPlayerProcessDisplayFramesOnlyOnDisplayLinkThread"), 0);
  *((double *)v6 + 95) = VCDefaults_GetDoubleValueForKey(CFSTR("avSyncAudioEarlyThreshold"), -0.0166666667);
  *((double *)v6 + 96) = VCDefaults_GetDoubleValueForKey(CFSTR("avSyncAudioLateThreshold"), 0.0333333333);
  *((double *)v6 + 97) = VCDefaults_GetDoubleValueForKey(CFSTR("avSyncAudioTimestampJumpDetectionThreshold"), 0.06);
  *((double *)v6 + 98) = VCDefaults_GetDoubleValueForKey(CFSTR("avSyncMaxAudioJitterBufferLevelThreshold"), 0.5);
  *((_OWORD *)v6 + 27) = xmmword_1D910B660;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v20 = VRTraceErrorLogLevelToCSTR();
    v21 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v22 = *((_QWORD *)v6 + 95);
      v23 = *((_QWORD *)v6 + 96);
      v24 = *((_QWORD *)v6 + 97);
      v25 = *((_QWORD *)v6 + 98);
      v37 = 136317186;
      v38 = v20;
      v39 = 2080;
      v40 = "VCVideoPlayer_Create";
      v41 = 1024;
      v42 = 1175;
      v43 = 2048;
      v44 = v6;
      v45 = 2048;
      *(_QWORD *)v46 = v22;
      *(_WORD *)&v46[8] = 2048;
      *(_QWORD *)&v46[10] = v23;
      *(_WORD *)&v46[18] = 2048;
      *(_QWORD *)v47 = v24;
      *(_WORD *)&v47[8] = 2048;
      *(_QWORD *)v48 = v25;
      *(_WORD *)&v48[8] = 2048;
      v49 = a1;
      _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] Defaults: avSyncAudioEarlyThreshold=%f, avSyncAudioLateThreshold=%f avSyncAudioTimestampJumpThreshold=%f avSyncAudioMaxJBThreshold=%f videoPlayerHandlePtr=%p", (uint8_t *)&v37, 0x58u);
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() < 7)
    return 0;
  v26 = VRTraceErrorLogLevelToCSTR();
  v27 = *MEMORY[0x1E0CF2758];
  v28 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
  result = 0;
  if (v28)
  {
    v29 = v6[752];
    v30 = *((_QWORD *)v6 + 75);
    v31 = v6[800];
    v32 = *((_QWORD *)v6 + 101);
    v33 = v6[562];
    v34 = v6[561];
    v35 = v6[560];
    v36 = v6[563];
    v37 = 136318210;
    v38 = v26;
    v39 = 2080;
    v40 = "VCVideoPlayer_Create";
    v41 = 1024;
    v42 = 1176;
    v43 = 2048;
    v44 = v6;
    v45 = 1024;
    *(_DWORD *)v46 = v29;
    *(_WORD *)&v46[4] = 2048;
    *(_QWORD *)&v46[6] = v30;
    *(_WORD *)&v46[14] = 1024;
    *(_DWORD *)&v46[16] = v31;
    *(_WORD *)v47 = 2048;
    *(_QWORD *)&v47[2] = v30;
    *(_WORD *)v48 = 2048;
    *(_QWORD *)&v48[2] = v32;
    LOWORD(v49) = 1024;
    *(_DWORD *)((char *)&v49 + 2) = v33;
    HIWORD(v49) = 1024;
    v50 = v34;
    v51 = 1024;
    v52 = v35;
    v53 = 1024;
    v54 = v36;
    _os_log_impl(&dword_1D8A54000, v27, OS_LOG_TYPE_DEFAULT, "VCVideoPlayer [%s] %s:%d Created VCVideoPlayer[%p] successfully with enableAVLooseSync=%d minPlaybackInterval=%f useAudioHostTimeForAVSync=%d minPlaybackInterval=%f outputLatency=%f, enableQueueAlarmForDisplay=%d, enableImmediateDecode=%d, useInternalClockForPresentation=%d, enableJitterBuffer=%d", (uint8_t *)&v37, 0x68u);
    return 0;
  }
  return result;
}

uint64_t VCVideoPlaybackAlarmThread()
{
  uint64_t v0;
  uint64_t v1;
  pthread_mutex_t *v2;
  __darwin_time_t v3;
  uint64_t v4;
  _DWORD *v6;
  uint64_t v7;
  NSObject *v8;
  NSObject *v9;
  int v10;
  double v11;
  uint64_t v12;
  uint64_t v13;
  double v14;
  timespec v15;
  _BYTE buf[22];
  __int16 v17;
  int v18;
  __int16 v19;
  uint64_t v20;
  __int16 v21;
  double v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v0 = CheckInHandleDebug();
  if (!v0)
    return -2147287038;
  v1 = v0;
  v2 = (pthread_mutex_t *)(v0 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(v0 + 16));
  convertTimeoutToRelativeTimespec(*(double *)(v1 + 616));
  v15.tv_sec = v3;
  v15.tv_nsec = v4;
  while (!*(_DWORD *)(v1 + 4))
  {
    v6 = *(_DWORD **)(v1 + 368);
    if (v6)
    {
      v14 = 0.0;
      if (!_VCVideoPlayer_CheckAndProcessAlarm(v1, v1 + 128, v6, &v14))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          v7 = VRTraceErrorLogLevelToCSTR();
          v8 = *MEMORY[0x1E0CF2758];
          v9 = *MEMORY[0x1E0CF2758];
          if (*MEMORY[0x1E0CF2748])
          {
            if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136316162;
              *(_QWORD *)&buf[4] = v7;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "VCVideoPlaybackAlarmThread";
              v17 = 1024;
              v18 = 776;
              v19 = 2048;
              v20 = v1;
              v21 = 2048;
              v22 = v14;
              _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] Not processing decode alarm, wait until next leeway=%f", buf, 0x30u);
            }
          }
          else if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136316162;
            *(_QWORD *)&buf[4] = v7;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "VCVideoPlaybackAlarmThread";
            v17 = 1024;
            v18 = 776;
            v19 = 2048;
            v20 = v1;
            v21 = 2048;
            v22 = v14;
            _os_log_debug_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEBUG, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] Not processing decode alarm, wait until next leeway=%f", buf, 0x30u);
          }
        }
        memset(buf, 170, 16);
        convertTimeoutToRelativeTimespec(v14);
        *(_QWORD *)buf = v12;
        *(_QWORD *)&buf[8] = v13;
        *(_BYTE *)v1 = 1;
        pthread_cond_timedwait_relative_np((pthread_cond_t *)(v1 + 80), v2, (const timespec *)buf);
        *(_BYTE *)v1 = 0;
      }
    }
    else
    {
      *(_BYTE *)v1 = 1;
      v10 = pthread_cond_timedwait_relative_np((pthread_cond_t *)(v1 + 80), v2, &v15);
      *(_BYTE *)v1 = 0;
      if (v10 == 60)
      {
        v11 = micro();
        _VCVideoPlayer_CheckForNoVideoDisplayedTimeout(v1, (_DWORD *)(v1 + 128), v11);
      }
    }
  }
  pthread_mutex_unlock(v2);
  CheckOutHandleDebug();
  return 0;
}

void _VCVideoPlayer_FlushQueuedAlarms(uint64_t a1, uint64_t a2)
{
  double v4;
  _QWORD *v5;
  _QWORD *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  void (*v10)(uint64_t, double *, uint64_t, uint64_t);
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  void (*v17)(uint64_t, double *, uint64_t, uint64_t, _QWORD, uint64_t);
  uint64_t v18;
  uint64_t v19;
  double v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v4 = micro();
  v5 = *(_QWORD **)(a2 + 240);
  if (v5)
  {
    do
    {
      v6 = (_QWORD *)v5[5];
      v7 = *((_DWORD *)v5 + 6);
      v8 = *v5;
      v10 = (void (*)(uint64_t, double *, uint64_t, uint64_t))v5[1];
      v9 = v5[2];
      v11 = *((unsigned __int8 *)v5 + 30);
      v20 = v4;
      v21 = v7;
      v22 = -1431655766;
      v23 = v8;
      v10(v9, &v20, v11, 1);
      Release(*(_QWORD *)(a1 + 552), v5);
      v5 = v6;
    }
    while (v6);
  }
  *(_QWORD *)(a2 + 240) = 0;
  v12 = *(_QWORD **)(a2 + 248);
  if (v12)
  {
    do
    {
      v13 = (_QWORD *)v12[5];
      v14 = *((_DWORD *)v12 + 6);
      v15 = *v12;
      v17 = (void (*)(uint64_t, double *, uint64_t, uint64_t, _QWORD, uint64_t))v12[1];
      v16 = v12[2];
      v18 = *((unsigned __int8 *)v12 + 30);
      v19 = *((unsigned __int16 *)v12 + 14);
      v20 = v4;
      v21 = v14;
      v22 = -1431655766;
      v23 = v15;
      v17(v16, &v20, v18, 1, 0, v19);
      Release(*(_QWORD *)(a1 + 552), v12);
      v12 = v13;
    }
    while (v13);
  }
  *(_QWORD *)(a2 + 248) = 0;
  *(_WORD *)(a2 + 300) = 0;
  *(_DWORD *)(a2 + 296) = 0;
}

uint64_t VCVideoPlayer_UpdateJitterBufferMode(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  double v7;
  int v9;
  uint64_t v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  uint64_t v16;
  __int16 v17;
  int v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = CheckInHandleDebug();
  if (!v3)
    return 2147680258;
  v4 = v3;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v5 = VRTraceErrorLogLevelToCSTR();
    v6 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136316162;
      v10 = v5;
      v11 = 2080;
      v12 = "VCVideoPlayer_UpdateJitterBufferMode";
      v13 = 1024;
      v14 = 1209;
      v15 = 2048;
      v16 = v4;
      v17 = 1024;
      v18 = a2;
      _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] Jitter buffer mode reconfigured to %d", (uint8_t *)&v9, 0x2Cu);
    }
  }
  *(_DWORD *)(v4 + 564) = a2;
  *(_BYTE *)(v4 + 800) = a2 != 3;
  v7 = 0.0166666667;
  if ((a2 & 0xFFFFFFFD) != 0)
    v7 = 0.0;
  *(double *)(v4 + 792) = VCDefaults_GetDoubleValueForKey(CFSTR("videoPlayerAverageDecodeTime"), v7);
  *(_QWORD *)(v4 + 384) = 0;
  *(_QWORD *)(v4 + 392) = 0;
  CheckOutHandleDebug();
  return 0;
}

uint64_t VCVideoPlayer_CollectVideoPlayerStatsForReporting(double a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  pthread_mutex_t *v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  int v15;
  double v16;
  double v17;

  v3 = 2147680257;
  if (a3)
  {
    v6 = CheckInHandleDebug();
    if (v6)
    {
      v7 = v6;
      v8 = (pthread_mutex_t *)(v6 + 16);
      pthread_mutex_lock((pthread_mutex_t *)(v6 + 16));
      v9 = *(_QWORD *)(v7 + 464);
      v10 = *(_OWORD *)(v7 + 448);
      *(_OWORD *)(a3 + 32) = *(_OWORD *)(v7 + 432);
      *(_OWORD *)(a3 + 48) = v10;
      *(_QWORD *)(a3 + 64) = v9;
      if (*(double *)(a3 + 32) == 2147483650.0)
        *(_QWORD *)(a3 + 32) = 0;
      if (*(double *)(a3 + 40) == -2147483650.0)
        *(_QWORD *)(a3 + 40) = 0;
      v11 = *(_OWORD *)(v7 + 472);
      v12 = *(_OWORD *)(v7 + 488);
      *(_QWORD *)(a3 + 104) = *(_QWORD *)(v7 + 504);
      *(_OWORD *)(a3 + 88) = v12;
      *(_OWORD *)(a3 + 72) = v11;
      v13 = *(_OWORD *)(v7 + 512);
      v14 = *(_OWORD *)(v7 + 528);
      *(_QWORD *)(a3 + 144) = *(_QWORD *)(v7 + 544);
      *(_OWORD *)(a3 + 112) = v13;
      *(_OWORD *)(a3 + 128) = v14;
      v15 = *(_DWORD *)(v7 + 692) - *(_DWORD *)(v7 + 708);
      *(_DWORD *)(a3 + 152) = *(_DWORD *)(v7 + 684) - *(_DWORD *)(v7 + 704);
      *(_DWORD *)(a3 + 156) = v15;
      *(_WORD *)a3 = *(_WORD *)(v7 + 428);
      *(_QWORD *)&v14 = *(_QWORD *)(v7 + 272);
      *(_QWORD *)(a3 + 16) = *(_QWORD *)(v7 + 304);
      *(_QWORD *)(a3 + 24) = v14;
      v16 = *(double *)(v7 + 720);
      if (v16 != 0.0)
      {
        v17 = a1 - v16;
        if (v17 >= 2.0)
        {
          *(double *)(a3 + 160) = (double)*(int *)(v7 + 712);
          *(double *)(a3 + 168) = v17;
        }
      }
      pthread_mutex_unlock(v8);
      CheckOutHandleDebug();
      return 0;
    }
    else
    {
      return 2147680258;
    }
  }
  return v3;
}

uint64_t VCVideoPlayer_ResetVideoPlayerStatsForReporting(double a1)
{
  uint64_t v2;
  uint64_t v3;
  pthread_mutex_t *v4;

  v2 = CheckInHandleDebug();
  if (!v2)
    return 2147680258;
  v3 = v2;
  v4 = (pthread_mutex_t *)(v2 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(v2 + 16));
  *(_QWORD *)(v3 + 472) = 0x7FEFFFFFFFFFFFFFLL;
  *(_OWORD *)(v3 + 480) = 0u;
  *(_OWORD *)(v3 + 496) = 0u;
  *(_QWORD *)(v3 + 512) = 0x7FEFFFFFFFFFFFFFLL;
  *(_OWORD *)(v3 + 520) = 0u;
  *(_OWORD *)(v3 + 536) = 0u;
  *(_OWORD *)(v3 + 432) = xmmword_1D910B670;
  *(_QWORD *)(v3 + 448) = 0;
  *(_QWORD *)(v3 + 456) = 0;
  *(_DWORD *)(v3 + 464) = 0;
  *(_DWORD *)(v3 + 704) = *(_DWORD *)(v3 + 684);
  *(_QWORD *)(v3 + 708) = *(unsigned int *)(v3 + 692);
  *(double *)(v3 + 720) = a1;
  pthread_mutex_unlock(v4);
  CheckOutHandleDebug();
  return 0;
}

uint64_t VCVideoPlayer_GetVideoPlayerStatsForJB(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  pthread_mutex_t *v6;
  uint64_t v7;

  v2 = 2147680257;
  if (a2)
  {
    v4 = CheckInHandleDebug();
    if (v4)
    {
      v5 = v4;
      v6 = (pthread_mutex_t *)(v4 + 16);
      pthread_mutex_lock((pthread_mutex_t *)(v4 + 16));
      *(_WORD *)a2 = *(_WORD *)(v5 + 428);
      *(_BYTE *)(a2 + 4) = 1;
      *(_DWORD *)(v5 + 700) = *(_DWORD *)(v5 + 696);
      v7 = *(_QWORD *)(v5 + 272);
      *(_QWORD *)(a2 + 16) = *(_QWORD *)(v5 + 304);
      *(_QWORD *)(a2 + 24) = v7;
      pthread_mutex_unlock(v6);
      CheckOutHandleDebug();
      return 0;
    }
    else
    {
      return 2147680258;
    }
  }
  return v2;
}

double VCVideoPlayer_GetPlaybackTimeOffset()
{
  uint64_t v0;
  uint64_t v1;
  pthread_mutex_t *v2;
  double v3;

  v0 = CheckInHandleDebug();
  if (!v0)
    return -2147287040.0;
  v1 = v0;
  v2 = (pthread_mutex_t *)(v0 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(v0 + 16));
  v3 = *(double *)(v1 + 184);
  pthread_mutex_unlock(v2);
  CheckOutHandleDebug();
  return v3;
}

uint64_t VCVideoPlayer_SetOutputLatency(double a1)
{
  uint64_t v2;
  uint64_t v3;
  double v4;
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  uint64_t v16;
  __int16 v17;
  double v18;
  __int16 v19;
  double v20;
  __int16 v21;
  double v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v2 = CheckInHandleDebug();
  if (!v2)
    return 2147680258;
  v3 = v2;
  if (*(_BYTE *)(v2 + 800))
    v4 = *(double *)(v2 + 600);
  else
    v4 = 0.0;
  if (v4 + a1 != *(double *)(v2 + 808))
  {
    *(double *)(v2 + 808) = v4 + a1;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v6 = VRTraceErrorLogLevelToCSTR();
      v7 = *MEMORY[0x1E0CF2758];
      v8 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          v9 = 136316674;
          v10 = v6;
          v11 = 2080;
          v12 = "VCVideoPlayer_SetOutputLatency";
          v13 = 1024;
          v14 = 1365;
          v15 = 2048;
          v16 = v3;
          v17 = 2048;
          v18 = v4 + a1;
          v19 = 2048;
          v20 = a1;
          v21 = 2048;
          v22 = v4;
          _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] Updating outputLatency=%f (requestLatency=%f + minPlaybackInterval=%f)", (uint8_t *)&v9, 0x44u);
        }
      }
      else if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        v9 = 136316674;
        v10 = v6;
        v11 = 2080;
        v12 = "VCVideoPlayer_SetOutputLatency";
        v13 = 1024;
        v14 = 1365;
        v15 = 2048;
        v16 = v3;
        v17 = 2048;
        v18 = v4 + a1;
        v19 = 2048;
        v20 = a1;
        v21 = 2048;
        v22 = v4;
        _os_log_debug_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEBUG, "VCVideoPlayer [%s] %s:%d VCVideoPlayer[%p] Updating outputLatency=%f (requestLatency=%f + minPlaybackInterval=%f)", (uint8_t *)&v9, 0x44u);
      }
    }
  }
  CheckOutHandleDebug();
  return 0;
}

uint64_t VCVideoPlayer_Destroy(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  pthread_mutex_t *v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t buf[4];
  uint64_t v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v2 = 2147680258;
  if (*a1 != 0xFFFFFFFFLL)
  {
    v3 = CheckInHandleDebug();
    if (v3)
    {
      v4 = v3;
      v5 = (pthread_mutex_t *)(v3 + 16);
      pthread_mutex_lock((pthread_mutex_t *)(v3 + 16));
      _VCVideoPlayer_FlushQueuedAlarms(v4, v4 + 128);
      *(_DWORD *)(v4 + 4) = 1;
      pthread_cond_signal((pthread_cond_t *)(v4 + 80));
      pthread_mutex_unlock(v5);
      FigThreadJoin();
      CheckOutHandleDebug();
      DestroyAlloc(*(_QWORD *)(v4 + 552));
      pthread_mutex_destroy((pthread_mutex_t *)(v4 + 816));
      pthread_mutex_destroy(v5);
      pthread_cond_destroy((pthread_cond_t *)(v4 + 80));
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v6 = VRTraceErrorLogLevelToCSTR();
        v7 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315906;
          v10 = v6;
          v11 = 2080;
          v12 = "VCVideoPlayer_Destroy";
          v13 = 1024;
          v14 = 1402;
          v15 = 2048;
          v16 = v4;
          _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, "VCVideoPlayer [%s] %s:%d Destroying VCVideoPlayer[%p]", buf, 0x26u);
        }
      }
      free((void *)v4);
      v2 = 0;
      *a1 = 0xFFFFFFFFLL;
    }
  }
  return v2;
}

uint64_t VCVideoPlayer_RegisterForNoVideoDisplayedTimeoutCallbacks(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  pthread_mutex_t *v8;

  v3 = 2147680257;
  if (a2 && a3)
  {
    v6 = CheckInHandleDebug();
    if (v6)
    {
      v7 = v6;
      v8 = (pthread_mutex_t *)(v6 + 816);
      pthread_mutex_lock((pthread_mutex_t *)(v6 + 816));
      *(_QWORD *)(v7 + 896) = a2;
      *(_QWORD *)(v7 + 888) = a3;
      pthread_mutex_unlock(v8);
      CheckOutHandleDebug();
      return 0;
    }
    else
    {
      return 2147680258;
    }
  }
  return v3;
}

uint64_t VCVideoPlayer_UnregisterForNoVideoDisplayedTimeoutCallbacks()
{
  uint64_t v0;
  _QWORD *v1;
  pthread_mutex_t *v2;

  v0 = CheckInHandleDebug();
  if (!v0)
    return 2147680258;
  v1 = (_QWORD *)v0;
  v2 = (pthread_mutex_t *)(v0 + 816);
  pthread_mutex_lock((pthread_mutex_t *)(v0 + 816));
  v1[110] = 0;
  v1[112] = 0;
  v1[111] = 0;
  pthread_mutex_unlock(v2);
  CheckOutHandleDebug();
  return 0;
}

uint64_t VCVideoPlayer_SetLooseAVSyncEnabled(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  pthread_mutex_t *v5;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2147680258;
  v4 = v3;
  v5 = (pthread_mutex_t *)(v3 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 16));
  if (*(unsigned __int8 *)(v4 + 752) != a2)
  {
    *(_BYTE *)(v4 + 752) = a2;
    *(_QWORD *)(v4 + 384) = 0;
    *(_QWORD *)(v4 + 392) = 0;
  }
  pthread_mutex_unlock(v5);
  CheckOutHandleDebug();
  return 0;
}

char *FourccToCStr(int a1)
{
  unint64_t v1;
  char *v2;

  v1 = FourccToCStr_ix++;
  v2 = (char *)&FourccToCStr_str + 5 * (v1 % 0xA);
  *v2 = HIBYTE(a1);
  v2[1] = BYTE2(a1);
  v2[2] = BYTE1(a1);
  v2[3] = a1;
  v2[4] = 0;
  return v2;
}

uint64_t CStrToFourcc(char *a1)
{
  unsigned int v2;
  uint64_t v3;
  char v4;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  unint64_t v8;
  char *v9;
  unint64_t v11;
  char *v12;
  int v13;
  uint64_t v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  char *v20;
  __int16 v21;
  char *v22;
  __int16 v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v2 = a1[3];
  v3 = (a1[1] << 16) | (*a1 << 24) | (a1[2] << 8) | v2;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v4 = v2;
    v5 = VRTraceErrorLogLevelToCSTR();
    v6 = *MEMORY[0x1E0CF2758];
    v7 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        v8 = FourccToCStr_ix++;
        v9 = (char *)&FourccToCStr_str + 5 * (v8 % 0xA);
        *v9 = BYTE3(v3);
        v9[1] = BYTE2(v3);
        v9[2] = BYTE1(v3);
        v9[3] = v4;
        v9[4] = 0;
        v13 = 136316418;
        v14 = v5;
        v15 = 2080;
        v16 = "CStrToFourcc";
        v17 = 1024;
        v18 = 154;
        v19 = 2080;
        v20 = a1;
        v21 = 2080;
        v22 = v9;
        v23 = 1024;
        v24 = v3;
        _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d CStrToFourcc: input %s, output %s(%X)", (uint8_t *)&v13, 0x36u);
      }
    }
    else if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      v11 = FourccToCStr_ix++;
      v12 = (char *)&FourccToCStr_str + 5 * (v11 % 0xA);
      *v12 = BYTE3(v3);
      v12[1] = BYTE2(v3);
      v12[2] = BYTE1(v3);
      v12[3] = v4;
      v12[4] = 0;
      v13 = 136316418;
      v14 = v5;
      v15 = 2080;
      v16 = "CStrToFourcc";
      v17 = 1024;
      v18 = 154;
      v19 = 2080;
      v20 = a1;
      v21 = 2080;
      v22 = v12;
      v23 = 1024;
      v24 = v3;
      _os_log_debug_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEBUG, " [%s] %s:%d CStrToFourcc: input %s, output %s(%X)", (uint8_t *)&v13, 0x36u);
    }
  }
  return v3;
}

char *FormatToCStr(uint64_t a1, char *__str, size_t __size)
{
  uint64_t v4;
  int v5;
  unint64_t v6;
  char *v7;

  if (a1)
  {
    v4 = *(double *)a1;
    v5 = *(_DWORD *)(a1 + 8);
    if (v5)
    {
      v6 = FourccToCStr_ix++;
      v7 = (char *)&FourccToCStr_str + 5 * (v6 % 0xA);
      *v7 = HIBYTE(v5);
      v7[1] = BYTE2(v5);
      v7[2] = BYTE1(v5);
      v7[3] = v5;
      v7[4] = 0;
    }
    else
    {
      v7 = "nope";
    }
    snprintf(__str, __size, "{ %u, %s, %x, %d, %d, %d, %d, %d }", v4, v7);
  }
  else
  {
    snprintf(__str, __size, "<NULL>");
  }
  return __str;
}

char *CreateAlloc(int a1, uint64_t a2)
{
  char *v4;
  char *v5;
  void *v6;

  v4 = (char *)malloc_type_malloc(0x60uLL, 0x1080040CF619488uLL);
  v5 = v4;
  if (v4)
  {
    *(_DWORD *)v4 = a1;
    *((_QWORD *)v4 + 1) = a2;
    *((_QWORD *)v4 + 3) = 0xA00000000;
    v6 = malloc_type_malloc(0x50uLL, 0x10040436913F5uLL);
    *((_QWORD *)v5 + 2) = v6;
    if (v6)
    {
      pthread_mutex_init((pthread_mutex_t *)(v5 + 32), 0);
    }
    else
    {
      free(v5);
      return 0;
    }
  }
  return v5;
}

void DestroyAlloc(uint64_t a1)
{
  int v2;
  BOOL v3;
  int v4;
  int v5;

  v2 = *(_DWORD *)(a1 + 24);
  v3 = __OFSUB__(v2, 1);
  v4 = v2 - 1;
  *(_DWORD *)(a1 + 24) = v4;
  if (v4 < 0 == v3)
  {
    do
    {
      free(*(void **)(*(_QWORD *)(a1 + 16) + 8 * v4));
      v5 = *(_DWORD *)(a1 + 24);
      v4 = v5 - 1;
      *(_DWORD *)(a1 + 24) = v5 - 1;
    }
    while (v5 > 0);
  }
  free(*(void **)(a1 + 16));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 32));
  free((void *)a1);
}

void *Alloc(int *a1)
{
  pthread_mutex_t *v2;
  int v3;
  uint64_t v4;
  int v5;
  void *v6;
  void *v7;
  void (*v8)(void *);

  v2 = (pthread_mutex_t *)(a1 + 8);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  v3 = a1[6];
  if (v3)
  {
    v4 = *((_QWORD *)a1 + 2);
    v5 = v3 - 1;
    a1[6] = v5;
    v6 = *(void **)(v4 + 8 * v5);
    pthread_mutex_unlock(v2);
    if (v6)
      return v6;
  }
  else
  {
    pthread_mutex_unlock(v2);
  }
  v7 = malloc_type_malloc(*a1, 0xD6EBE52uLL);
  v6 = v7;
  if (v7)
  {
    v8 = (void (*)(void *))*((_QWORD *)a1 + 1);
    if (v8)
      v8(v7);
    else
      bzero(v7, *a1);
  }
  return v6;
}

void Release(uint64_t a1, void *a2)
{
  pthread_mutex_t *v4;
  int v5;
  _QWORD *v6;
  _QWORD *v7;

  v4 = (pthread_mutex_t *)(a1 + 32);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
  v5 = *(_DWORD *)(a1 + 24);
  if (v5 != *(_DWORD *)(a1 + 28))
  {
    v7 = *(_QWORD **)(a1 + 16);
    goto LABEL_5;
  }
  *(_DWORD *)(a1 + 28) = 2 * v5;
  v6 = malloc_type_malloc(16 * v5, 0x10040436913F5uLL);
  if (v6)
  {
    v7 = v6;
    memcpy(v6, *(const void **)(a1 + 16), 8 * *(int *)(a1 + 24));
    free(*(void **)(a1 + 16));
    *(_QWORD *)(a1 + 16) = v7;
    v5 = *(_DWORD *)(a1 + 24);
LABEL_5:
    *(_DWORD *)(a1 + 24) = v5 + 1;
    v7[v5] = a2;
    pthread_mutex_unlock(v4);
    return;
  }
  pthread_mutex_unlock(v4);
  free(a2);
}

uint64_t SummerCreateHandle(uint64_t *a1, int a2)
{
  _QWORD *v4;
  _QWORD *v5;
  void *v6;
  uint64_t Handle;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;

  v4 = malloc_type_malloc(0x28uLL, 0x1080040B7564605uLL);
  if (v4)
  {
    v5 = v4;
    *v4 = malloc_type_calloc(1uLL, 8 * a2, 0x100004000313F17uLL);
    v6 = malloc_type_malloc(8 * a2, 0x100004000313F17uLL);
    v5[2] = 0;
    v5[3] = 0;
    v5[1] = v6;
    *((_DWORD *)v5 + 8) = a2;
    Handle = CreateHandle();
    *a1 = Handle;
    if (Handle == 0xFFFFFFFFLL)
    {
      v8 = 2148728837;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          SummerCreateHandle_cold_2();
          return 2148728837;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v8 = 2148728835;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v9 = VRTraceErrorLogLevelToCSTR();
      v10 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SummerCreateHandle_cold_1(v9, v10);
    }
  }
  return v8;
}

uint64_t SummerReset()
{
  uint64_t v0;
  int v1;
  int v2;
  int v3;
  uint64_t v4;
  uint64_t v5;

  v0 = CheckInHandleDebug();
  if (!v0)
    return 2148728834;
  v1 = *(_DWORD *)(v0 + 28);
  if (v1)
  {
    v2 = *(_DWORD *)(v0 + 24);
    v3 = *(_DWORD *)(v0 + 32);
    v4 = *(_QWORD *)v0;
    v5 = *(_QWORD *)(v0 + 8);
    do
    {
      v2 = (v3 - 1 + v2) % v3;
      *(_QWORD *)(v4 + 8 * v2) = 0;
      *(_QWORD *)(v5 + 8 * v2) = 0;
      --v1;
    }
    while (v1);
    *(_QWORD *)(v0 + 16) = 0;
    *(_QWORD *)(v0 + 24) = 0;
  }
  CheckOutHandleDebug();
  return 0;
}

uint64_t SummerCloseHandle()
{
  uint64_t v0;
  void **v1;

  v0 = CheckInHandleDebug();
  if (!v0)
    return 2148728834;
  v1 = (void **)v0;
  CheckOutHandleDebug();
  free(v1[1]);
  free(*v1);
  free(v1);
  return 0;
}

uint64_t SummerAdd(double a1, double a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;

  v4 = CheckInHandleDebug();
  if (!v4)
    return 2148728834;
  v5 = *(_QWORD *)v4;
  v6 = *(_QWORD *)(v4 + 8);
  v7 = *(_DWORD *)(v4 + 28);
  v8 = *(int *)(v4 + 24);
  *(double *)(v4 + 16) = *(double *)(v4 + 16) + a1 - *(double *)(*(_QWORD *)v4 + 8 * v8);
  *(double *)(v5 + 8 * v8) = a1;
  *(double *)(v6 + 8 * v8) = a2;
  LODWORD(v6) = *(_DWORD *)(v4 + 32);
  *(_DWORD *)(v4 + 24) = ((int)v8 + 1) % (int)v6;
  if (v7 < (int)v6)
    *(_DWORD *)(v4 + 28) = v7 + 1;
  CheckOutHandleDebug();
  return 0;
}

uint64_t SummerLengthPred(double a1, uint64_t a2, uint64_t (*a3)(double, double, double), double *a4, int *a5)
{
  uint64_t v5;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  double v14;
  int v15;
  int v16;
  int v17;
  double v18;
  double v19;
  BOOL v20;
  double v21;
  BOOL v22;
  int v23;

  v5 = 2148728833;
  if (a3 && a4 && a5)
  {
    v10 = CheckInHandleDebug();
    if (v10)
    {
      v11 = v10;
      v12 = *(_DWORD *)(v10 + 28);
      if (v12)
      {
        *a5 = 0;
        v13 = (*(_DWORD *)(v10 + 24) + *(_DWORD *)(v10 + 32) - 1) % *(_DWORD *)(v10 + 32);
        v14 = *(double *)(*(_QWORD *)(v10 + 8) + 8 * v13);
        while (1)
        {
          v15 = a3(a1, *(double *)(*(_QWORD *)v11 + 8 * v13), *(double *)(*(_QWORD *)(v11 + 8) + 8 * v13));
          v16 = *a5;
          if (!v15)
            break;
          *a5 = ++v16;
          v17 = *(_DWORD *)(v11 + 32);
          v13 = (v13 + v17 - 1) % v17;
          if (!--v12)
            goto LABEL_13;
        }
        v17 = *(_DWORD *)(v11 + 32);
LABEL_13:
        v18 = *(double *)(*(_QWORD *)(v11 + 8) + 8 * ((v13 + 1) % v17));
        v19 = v14 - v18;
        v20 = v14 > v18;
        v21 = 1.0;
        if (v20)
          v21 = v19;
        *a4 = v21;
        v5 = 0;
        v22 = __OFSUB__(v16, 1);
        v23 = v16 - 1;
        if (v23 < 0 == v22)
          *a5 = v23;
      }
      else
      {
        v5 = 2148728849;
      }
      CheckOutHandleDebug();
    }
    else
    {
      return 2148728834;
    }
  }
  return v5;
}

uint64_t SummerSumPred(double a1, double a2, uint64_t a3, unsigned int (*a4)(double, double, double), double (*a5)(double, double, double), double *a6, double *a7)
{
  uint64_t v7;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  double v18;
  int v19;
  int v20;
  uint64_t v21;
  double v22;
  double v23;
  BOOL v24;
  double v25;

  v7 = 2148728833;
  if (a4 && a5 && a6 && a7)
  {
    v14 = CheckInHandleDebug();
    if (v14)
    {
      v15 = v14;
      *a7 = 0.0;
      v16 = *(_DWORD *)(v14 + 28);
      if (v16)
      {
        v17 = (*(_DWORD *)(v14 + 24) + *(_DWORD *)(v14 + 32) - 1) % *(_DWORD *)(v14 + 32);
        v18 = *(double *)(*(_QWORD *)(v14 + 8) + 8 * v17);
        while (a4(a1, *(double *)(*(_QWORD *)v15 + 8 * v17), *(double *)(*(_QWORD *)(v15 + 8) + 8 * v17)))
        {
          --v16;
          *a7 = a5(a2, *(double *)(*(_QWORD *)v15 + 8 * v17), *(double *)(*(_QWORD *)(v15 + 8) + 8 * v17)) + *a7;
          v19 = *(_DWORD *)(v15 + 32);
          v17 = (v17 + v19 - 1) % v19;
          if (!v16)
            goto LABEL_14;
        }
        v19 = *(_DWORD *)(v15 + 32);
LABEL_14:
        v20 = (v17 + 1) % v19;
        v21 = *(_QWORD *)(v15 + 8);
        v22 = *(double *)(v21 + 8 * v20);
        v23 = v18 - v22;
        v24 = v18 > v22;
        v25 = 1.0;
        if (v24)
          v25 = v23;
        *a6 = v25;
        v7 = 0;
        if (*a7 > 0.0)
          *a7 = *a7 - a5(a2, *(double *)(*(_QWORD *)v15 + 8 * v20), *(double *)(v21 + 8 * v20));
      }
      else
      {
        v7 = 2148728849;
      }
      CheckOutHandleDebug();
    }
    else
    {
      return 2148728834;
    }
  }
  return v7;
}

double SummerIdentity(double a1, double a2)
{
  return a2;
}

BOOL SummerGreaterThan(double a1, double a2, double a3)
{
  return a3 > a1;
}

uint64_t HasAltivec()
{
  uint64_t result;
  size_t v1;
  unsigned int v2;
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  result = HasAltivec_result;
  if (HasAltivec_result == -1)
  {
    v2 = 0;
    v1 = 4;
    if (sysctlbyname("hw.optional.altivec", &v2, &v1, 0, 0))
      result = 0;
    else
      result = v2;
    HasAltivec_result = result;
  }
  return result;
}

uint64_t HasMMX()
{
  uint64_t result;
  size_t v1;
  unsigned int v2;
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  result = HasMMX_result;
  if (HasMMX_result == -1)
  {
    v2 = 0;
    v1 = 4;
    if (sysctlbyname("hw.optional.mmx", &v2, &v1, 0, 0))
      result = 0;
    else
      result = v2;
    HasMMX_result = result;
  }
  return result;
}

uint64_t HasSSE()
{
  uint64_t result;
  size_t v1;
  unsigned int v2;
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  result = HasSSE_result;
  if (HasSSE_result == -1)
  {
    v2 = 0;
    v1 = 4;
    if (sysctlbyname("hw.optional.sse", &v2, &v1, 0, 0))
      result = 0;
    else
      result = v2;
    HasSSE_result = result;
  }
  return result;
}

uint64_t HasSSE2()
{
  uint64_t result;
  size_t v1;
  unsigned int v2;
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  result = HasSSE2_result;
  if (HasSSE2_result == -1)
  {
    v2 = 0;
    v1 = 4;
    if (sysctlbyname("hw.optional.sse2", &v2, &v1, 0, 0))
      result = 0;
    else
      result = v2;
    HasSSE2_result = result;
  }
  return result;
}

uint64_t HasSSE3()
{
  uint64_t result;
  size_t v1;
  unsigned int v2;
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  result = HasSSE3_result;
  if (HasSSE3_result == -1)
  {
    v2 = 0;
    v1 = 4;
    if (sysctlbyname("hw.optional.sse3", &v2, &v1, 0, 0))
      result = 0;
    else
      result = v2;
    HasSSE3_result = result;
  }
  return result;
}

uint64_t HasMulticore()
{
  uint64_t result;
  uint64_t v1;
  NSObject *v2;
  size_t v3;
  int v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  result = HasMulticore_result;
  if (HasMulticore_result == -1)
  {
    v4 = 0;
    v3 = 4;
    if (!sysctlbyname("hw.activecpu", &v4, &v3, 0, 0))
    {
      result = v4 > 1;
      goto LABEL_8;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v1 = VRTraceErrorLogLevelToCSTR();
      v2 = *MEMORY[0x1E0CF2758];
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!(_DWORD)result)
      {
LABEL_8:
        HasMulticore_result = result;
        return result;
      }
      HasMulticore_cold_1(v1, v2);
    }
    result = 0;
    goto LABEL_8;
  }
  return result;
}

uint64_t GetVectorTypeAvailable()
{
  uint64_t result;

  result = GetVectorTypeAvailable_result;
  if (GetVectorTypeAvailable_result == -1)
  {
    if (HasAltivec())
    {
      result = 1;
    }
    else if (HasSSE3())
    {
      result = 5;
    }
    else if (HasSSE2())
    {
      result = 4;
    }
    else if (HasSSE())
    {
      result = 3;
    }
    else
    {
      result = 2 * (HasMMX() != 0);
    }
    GetVectorTypeAvailable_result = result;
  }
  return result;
}

uint64_t ProcessorSpeedMHz()
{
  return 0;
}

uint64_t CPUCountPhysical()
{
  uint64_t result;
  size_t v1;
  unsigned int v2;
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  result = CPUCountPhysical_result;
  if (CPUCountPhysical_result == -1)
  {
    v2 = 0;
    v1 = 4;
    if (sysctlbyname("hw.physicalcpu", &v2, &v1, 0, 0))
      result = 0;
    else
      result = v2;
    CPUCountPhysical_result = result;
  }
  return result;
}

uint64_t VCCPUCount()
{
  uint64_t result;

  result = VCCPUCount_result;
  if (VCCPUCount_result == -1)
  {
    result = CPUCountPhysical();
    VCCPUCount_result = result;
  }
  return result;
}

uint64_t MachineType()
{
  uint64_t v0;
  unsigned __int8 *v1;
  uint64_t i;
  signed __int8 v3;
  unsigned __int8 *v4;
  int v5;
  int v6;
  int v7;
  size_t size;
  int v10[2];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v0 = MachineType_machine_type;
  if (!MachineType_machine_type)
  {
    size = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)v10 = 0x200000006;
    sysctl(v10, 2u, 0, &size, 0, 0);
    v1 = (unsigned __int8 *)malloc_type_malloc(size, 0x1109974BuLL);
    sysctl(v10, 2u, v1, &size, 0, 0);
    for (i = 0; i != 123; i += 3)
    {
      if (!strcasecmp((const char *)v1, MachineType_models[i]))
      {
        v0 = LODWORD(MachineType_models[i + 2]);
        goto LABEL_28;
      }
    }
    v3 = *v1;
    if (*v1)
    {
      v4 = v1 + 1;
      do
      {
        *(v4 - 1) = __tolower(v3);
        v5 = *v4++;
        v3 = v5;
      }
      while (v5);
    }
    if (strstr((char *)v1, "powerbook1,"))
      goto LABEL_9;
    if (strstr((char *)v1, "powerbook2,"))
      goto LABEL_12;
    if (!strstr((char *)v1, "powerbook3,"))
    {
      if (strstr((char *)v1, "powerbook4,"))
      {
LABEL_12:
        v6 = 132;
        goto LABEL_13;
      }
      if (!strstr((char *)v1, "powerbook5,") && !strstr((char *)v1, "powerbook6,"))
      {
        if (strstr((char *)v1, "powermac7,"))
        {
          v0 = 288;
        }
        else if (strstr((char *)v1, "powermac8,"))
        {
          v0 = 784;
        }
        else
        {
          if (!strstr((char *)v1, "powermac12,"))
          {
            if (strstr((char *)v1, "book"))
              v6 = 4;
            else
              v6 = 32;
LABEL_13:
            if (HasSSE3())
            {
              v0 = v6 | 0x400u;
            }
            else
            {
              v7 = VCCPUCount_result;
              if (VCCPUCount_result == -1)
              {
                v7 = CPUCountPhysical();
                VCCPUCount_result = v7;
              }
              if (v7 < 3)
              {
                if (HasAltivec())
                  v0 = v6 | 2u;
                else
                  v0 = v6 | 1u;
              }
              else
              {
                v0 = v6 | 0x100u;
              }
            }
            goto LABEL_28;
          }
          v0 = 2320;
        }
LABEL_28:
        free(v1);
        MachineType_machine_type = v0;
        return v0;
      }
    }
LABEL_9:
    v6 = 68;
    goto LABEL_13;
  }
  return v0;
}

BOOL hasG5()
{
  __int128 v0;
  host_t v1;
  mach_msg_type_number_t host_info_outCnt;
  integer_t host_info_out[4];
  __int128 v6;
  __int128 v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if ((MachineType() & 0x100) != 0)
    return 1;
  *(_QWORD *)&v0 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v0 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v6 = v0;
  v7 = v0;
  *(_OWORD *)host_info_out = v0;
  host_info_outCnt = 12;
  v1 = MEMORY[0x1DF0884D0]();
  host_info(v1, 1, host_info_out, &host_info_outCnt);
  return host_info_out[3] == 18 && (_DWORD)v6 == 100;
}

uint64_t ReadFirstMBAndSliceType(uint64_t a1, unsigned int a2, _WORD *a3, _WORD *a4, uint64_t a5)
{
  uint64_t result;
  const uint8_t *v9;
  const __CFAllocator *v10;
  size_t v11;
  CFStringEncoding SystemEncoding;
  BOOL v13;
  unsigned int v14;
  int v15;
  CMVideoDimensions Dimensions;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  __int16 v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  CMVideoFormatDescriptionRef videoDesc[2];

  result = 0;
  videoDesc[1] = *(CMVideoFormatDescriptionRef *)MEMORY[0x1E0C80C00];
  if (a2 >= 4 && a1 && a3 && a4 && a5)
  {
    if (*(_DWORD *)a1 == -1547639150)
    {
      v9 = (const uint8_t *)(a1 + 4);
      videoDesc[0] = (CMVideoFormatDescriptionRef)0xAAAAAAAAAAAAAAAALL;
      v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v11 = (int)(a2 - 4);
      SystemEncoding = CFStringGetSystemEncoding();
      if (CMVideoFormatDescriptionCreateFromBigEndianImageDescriptionData(v10, v9, v11, SystemEncoding, 0, videoDesc))
        v13 = 1;
      else
        v13 = videoDesc[0] == 0;
      if (!v13)
      {
        Dimensions = CMVideoFormatDescriptionGetDimensions(videoDesc[0]);
        *a3 = Dimensions.width;
        *a4 = Dimensions.height;
        FigFormatDescriptionRelease();
        return 2;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
        if (!(_DWORD)result)
          return result;
        ReadFirstMBAndSliceType_cold_1();
      }
      return 0;
    }
    v14 = bswap32(*(_DWORD *)a1);
    v15 = HIBYTE(v14) & 0x1F;
    if (v15 == 7)
      return 3;
    if (v15 == 8)
      return 4;
    if ((v14 & 0x1E000000) == 0x1C000000)
      return 6;
    if ((v14 & 0x9B000000) != 0x1000000)
      return 0;
    if (a2 <= 0xB)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
        if (!(_DWORD)result)
          return result;
        ReadFirstMBAndSliceType_cold_2();
      }
      return 0;
    }
    v17 = bswap32(*(_DWORD *)(a1 + 4));
    v18 = __PAIR64__(v14, v17) >> 24;
    if (v18 < 0x80000)
      return 0;
    result = 0;
    v19 = __clz(v18);
    v20 = *(unsigned __int8 *)(a1 + 8) | (v17 << 8);
    if (v19)
      v21 = v18 << (v19 + 1) >> -(char)v19;
    else
      v21 = 0;
    *a3 = v21 + ~(-1 << v19);
    v22 = (v20 >> -((2 * v19) | 1)) | (v18 << ((2 * v19) | 1));
    if (v22 >= 0x80000)
    {
      v23 = __clz(v22);
      v24 = v22 << (v23 + 1) >> -(char)v23;
      if (!v23)
        LOWORD(v24) = 0;
      *a4 = v24 + ~(-1 << v23);
      return 1;
    }
  }
  return result;
}

uint64_t hwrandom()
{
  unsigned int bytes;
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  bytes = -1431655766;
  if (!SecRandomCopyBytes((SecRandomRef)*MEMORY[0x1E0CD7000], 4uLL, &bytes))
    return bytes;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      hwrandom_cold_1();
  }
  return arc4random();
}

uint64_t hwrandom16()
{
  uint64_t result;
  __int16 bytes;
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  bytes = -21846;
  if (SecRandomCopyBytes((SecRandomRef)*MEMORY[0x1E0CD7000], 2uLL, &bytes))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        hwrandom16_cold_1();
    }
    LOWORD(result) = arc4random();
  }
  else
  {
    LOWORD(result) = bytes;
  }
  return (unsigned __int16)result;
}

uint64_t ReadFrameSliceHeader(int32_t a1, uint64_t a2, int a3, CFDictionaryRef *a4)
{
  uint64_t v4;
  const __CFAllocator *v8;
  size_t v9;
  CFStringEncoding SystemEncoding;
  BOOL v11;
  char v13;
  uint64_t v14;
  CMVideoDimensions Dimensions;
  int ErrorLogLevelForModule;
  uint64_t v17;
  NSObject *v18;
  CFDictionaryRef v19;
  uint64_t v20;
  char v21;
  char v22;
  const void *v23;
  uint64_t v24;
  uint64_t v25;
  NSObject *v26;
  int v29;
  uint64_t v30;
  NSObject *v31;
  NSObject *v32;
  uint64_t v33;
  NSObject *v34;
  CFDictionaryRef v35;
  uint64_t v36;
  char v37;
  char v38;
  const void *v39;
  CFDictionaryRef v40;
  uint64_t v41;
  char v42;
  char v43;
  const void *v44;
  int v45;
  int v46;
  _DWORD v47[5];
  __int16 v48;
  __int16 v49;
  unsigned __int16 v50;
  CMVideoFormatDescriptionRef formatDescriptionOut;
  int32_t height;
  int32_t valuePtr;
  uint8_t buf[4];
  uint64_t v55;
  __int16 v56;
  const char *v57;
  __int16 v58;
  int v59;
  __int16 v60;
  int32_t v61;
  __int16 v62;
  int32_t v63;
  void *values;
  CFNumberRef v65;
  void *keys[2];
  uint64_t v67;

  v4 = 0;
  v67 = *MEMORY[0x1E0C80C00];
  if (!a2 || a3 < 4)
    return v4;
  if (*(_DWORD *)a2 == -1547639150)
  {
    if (!a4)
      return 2;
    formatDescriptionOut = (CMVideoFormatDescriptionRef)0xAAAAAAAAAAAAAAAALL;
    v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v9 = a3 - 4;
    SystemEncoding = CFStringGetSystemEncoding();
    if (CMVideoFormatDescriptionCreateFromBigEndianImageDescriptionData(v8, (const uint8_t *)(a2 + 4), v9, SystemEncoding, 0, &formatDescriptionOut))
    {
      v11 = 1;
    }
    else
    {
      v11 = formatDescriptionOut == 0;
    }
    if (!v11)
    {
      Dimensions = CMVideoFormatDescriptionGetDimensions(formatDescriptionOut);
      height = Dimensions.height;
      valuePtr = Dimensions.width;
      FigFormatDescriptionRelease();
      *(_OWORD *)keys = xmmword_1E9E54340;
      values = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
      v65 = CFNumberCreate(0, kCFNumberIntType, &height);
      ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
      if (ErrorLogLevelForModule > 6)
      {
        v17 = VRTraceErrorLogLevelToCSTR();
        v18 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316162;
          v55 = v17;
          v56 = 2080;
          v57 = "ReadFrameSliceHeader";
          v58 = 1024;
          v59 = 1140;
          v60 = 1024;
          v61 = valuePtr;
          v62 = 1024;
          v63 = height;
          _os_log_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d %dx%d", buf, 0x28u);
        }
      }
      v19 = CFDictionaryCreate(v8, (const void **)keys, (const void **)&values, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      v20 = 0;
      *a4 = v19;
      v21 = 1;
      do
      {
        v22 = v21;
        v23 = *(&values + v20);
        if (v23)
          CFRelease(v23);
        v21 = 0;
        v20 = 1;
      }
      while ((v22 & 1) != 0);
      return 2;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        ReadFrameSliceHeader_cold_1();
    }
    return 0;
  }
  v13 = a1 - 100;
  if ((a1 - 100) > 0x1A)
    goto LABEL_35;
  if (((1 << v13) & 0x3000400) != 0)
    return 0;
  if (((1 << v13) & 0x4800000) != 0)
  {
    v50 = -21846;
    v49 = -21846;
    v48 = -21846;
    v14 = ReadFirstMBAndSliceType(a2, a3, &v50, &v49, (uint64_t)&v48);
    v4 = v14;
    if (a4)
    {
      if ((_DWORD)v14 == 1)
      {
        LODWORD(formatDescriptionOut) = v50;
        if (v49 == 7 || v49 == 2)
          v29 = 2;
        else
          v29 = 0;
        valuePtr = v29;
        *(_OWORD *)keys = xmmword_1E9E54350;
        values = CFNumberCreate(0, kCFNumberIntType, &formatDescriptionOut);
        v65 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          v30 = VRTraceErrorLogLevelToCSTR();
          v31 = *MEMORY[0x1E0CF2758];
          v32 = *MEMORY[0x1E0CF2758];
          if (*MEMORY[0x1E0CF2748])
          {
            if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136316162;
              v55 = v30;
              v56 = 2080;
              v57 = "ReadFrameSliceHeader";
              v58 = 1024;
              v59 = 1219;
              v60 = 1024;
              v61 = (int)formatDescriptionOut;
              v62 = 1024;
              v63 = valuePtr;
              _os_log_impl(&dword_1D8A54000, v31, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d FirstMB=%d sliceType=%d", buf, 0x28u);
            }
          }
          else if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136316162;
            v55 = v30;
            v56 = 2080;
            v57 = "ReadFrameSliceHeader";
            v58 = 1024;
            v59 = 1219;
            v60 = 1024;
            v61 = (int)formatDescriptionOut;
            v62 = 1024;
            v63 = valuePtr;
            _os_log_debug_impl(&dword_1D8A54000, v31, OS_LOG_TYPE_DEBUG, " [%s] %s:%d FirstMB=%d sliceType=%d", buf, 0x28u);
          }
        }
        v40 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)keys, (const void **)&values, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        v41 = 0;
        *a4 = v40;
        v42 = 1;
        do
        {
          v43 = v42;
          v44 = *(&values + v41);
          if (v44)
            CFRelease(v44);
          v42 = 0;
          v41 = 1;
        }
        while ((v43 & 1) != 0);
      }
      else if ((_DWORD)v14 == 3
             && (LODWORD(formatDescriptionOut) = -1431655766,
                 height = -1431655766,
                 valuePtr = -1431655766,
                 memset(v47, 170, sizeof(v47)),
                 !readSPSAndGetDecoderParams((unsigned int *)a2, a3, &formatDescriptionOut, &valuePtr, &height, &v47[4], &v47[3], &v47[2], &v47[1], v47)))
      {
        v45 = 16 * valuePtr;
        v46 = 16 * (_DWORD)formatDescriptionOut;
        *(_OWORD *)keys = xmmword_1E9E54340;
        values = CFNumberCreate(0, kCFNumberIntType, &v46);
        v65 = CFNumberCreate(0, kCFNumberIntType, &v45);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v33 = VRTraceErrorLogLevelToCSTR();
          v34 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136316162;
            v55 = v33;
            v56 = 2080;
            v57 = "ReadFrameSliceHeader";
            v58 = 1024;
            v59 = 1198;
            v60 = 1024;
            v61 = v46;
            v62 = 1024;
            v63 = v45;
            _os_log_impl(&dword_1D8A54000, v34, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d %dx%d", buf, 0x28u);
          }
        }
        v35 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)keys, (const void **)&values, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        v36 = 0;
        *a4 = v35;
        v37 = 1;
        do
        {
          v38 = v37;
          v39 = *(&values + v36);
          if (v39)
            CFRelease(v39);
          v37 = 0;
          v36 = 1;
        }
        while ((v38 & 1) != 0);
      }
      else
      {
        *a4 = 0;
      }
    }
    return v4;
  }
  if (a1 != 100)
  {
LABEL_35:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v25 = VRTraceErrorLogLevelToCSTR();
      v26 = *MEMORY[0x1E0CF2758];
      v4 = 0;
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        return v4;
      *(_DWORD *)buf = 136315906;
      v55 = v25;
      v56 = 2080;
      v57 = "ReadFrameSliceHeader";
      v58 = 1024;
      v59 = 1245;
      v60 = 1024;
      v61 = a1;
      _os_log_impl(&dword_1D8A54000, v26, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d ReadFrameSliceHeader: UNEXPECTED payload %d", buf, 0x22u);
    }
    return 0;
  }
  v24 = VCPReadHEVCSliceHeader();
  v4 = v24;
  if ((v24 - 4) > 0xFFFFFFFD)
    return v4;
  if (a3 < 1)
    return 0;
  if ((*(_BYTE *)a2 & 0x7E) == 0x62)
    return 6;
  else
    return v24;
}

uint64_t RetrieveResolutionFromFrameInfoDict(CFDictionaryRef theDict, _WORD *a2, _WORD *a3)
{
  uint64_t result;
  const __CFNumber *Value;
  const __CFNumber *v8;
  int valuePtr;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (theDict && a2 && a3)
  {
    valuePtr = -1431655766;
    Value = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("Width"));
    if (Value
      && (CFNumberGetValue(Value, kCFNumberIntType, &valuePtr),
          *a2 = valuePtr,
          (v8 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("Height"))) != 0))
    {
      CFNumberGetValue(v8, kCFNumberIntType, &valuePtr);
      result = 0;
      *a3 = valuePtr;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t RetrieveMBSliceTypeFromFrameInfoDict(CFDictionaryRef theDict, _WORD *a2, _WORD *a3)
{
  uint64_t result;
  const __CFNumber *Value;
  const __CFNumber *v8;
  __int16 v9;
  unsigned int valuePtr;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (theDict && a2 && a3)
  {
    valuePtr = -1431655766;
    Value = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("FirstMB"));
    if (Value)
    {
      CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
      *a2 = valuePtr;
    }
    v8 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("SliceType"));
    if (v8)
    {
      CFNumberGetValue(v8, kCFNumberIntType, &valuePtr);
      v9 = valuePtr;
      if (valuePtr >= 3 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          RetrieveMBSliceTypeFromFrameInfoDict_cold_1();
      }
      *a3 = v9;
    }
    return 0;
  }
  return result;
}

uint64_t ReadCodecConfigParams(int a1, uint64_t a2, unint64_t a3, _DWORD *a4, _DWORD *a5, int *a6, int *a7, int *a8)
{
  uint64_t DecoderParams;
  uint64_t v12;
  NSObject *v13;
  uint64_t v17;
  NSObject *v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  NSObject *v23;
  int v25;
  int v26;
  int v27;
  int v28;
  CFTypeRef cf;
  uint8_t buf[4];
  uint64_t v31;
  __int16 v32;
  const char *v33;
  __int16 v34;
  int v35;
  __int16 v36;
  int v37;
  __int16 v38;
  int v39;
  __int16 v40;
  int v41;
  __int16 v42;
  int v43;
  __int16 v44;
  int v45;
  __int16 v46;
  int v47;
  __int16 v48;
  int v49;
  __int16 v50;
  int v51;
  __int16 v52;
  int v53;
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  switch(a1)
  {
    case 'd':
      goto LABEL_4;
    case '~':
      v28 = 15;
      LODWORD(cf) = 20;
      v26 = 1;
      v27 = 1;
      v25 = 0;
      DecoderParams = readAVCCAndGetDecoderParams(a2, a3, &cf, &v28, &v27, &v26, a6, a7, a8, &v25);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v17 = VRTraceErrorLogLevelToCSTR();
        v18 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v19 = *a6;
          v20 = *a7;
          v21 = *a8;
          *(_DWORD *)buf = 136317954;
          v31 = v17;
          v32 = 2080;
          v33 = "ReadCodecConfigParams";
          v34 = 1024;
          v35 = 1338;
          v36 = 1024;
          v37 = DecoderParams;
          v38 = 1024;
          v39 = (int)cf;
          v40 = 1024;
          v41 = v28;
          v42 = 1024;
          v43 = v27;
          v44 = 1024;
          v45 = v26;
          v46 = 1024;
          v47 = v19;
          v48 = 1024;
          v49 = v20;
          v50 = 1024;
          v51 = v21;
          v52 = 1024;
          v53 = v25;
          _os_log_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Parsing SPS for H.264: %d, %u, %u, %u, %u, %u, %u, %u, %u", buf, 0x52u);
        }
      }
      *a4 = 16 * (_DWORD)cf;
      *a5 = 16 * v28;
      break;
    case '{':
LABEL_4:
      cf = 0;
      VCPReadCodecConfigParams();
      LOWORD(v28) = 0;
      LOWORD(v27) = 0;
      DecoderParams = RetrieveResolutionFromFrameInfoDict(0, &v28, &v27);
      if (!(_DWORD)DecoderParams)
      {
        *a4 = (unsigned __int16)v28;
        *a5 = (unsigned __int16)v27;
      }
      if (cf)
        CFRelease(cf);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v12 = VRTraceErrorLogLevelToCSTR();
        v13 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316418;
          v31 = v12;
          v32 = 2080;
          v33 = "ReadCodecConfigParams";
          v34 = 1024;
          v35 = 1320;
          v36 = 1024;
          v37 = DecoderParams;
          v38 = 1024;
          v39 = (unsigned __int16)v28;
          v40 = 1024;
          v41 = (unsigned __int16)v27;
          _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Parsing SPS: %d, %u, %u", buf, 0x2Eu);
        }
      }
      return DecoderParams;
    default:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v22 = VRTraceErrorLogLevelToCSTR();
        v23 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315906;
          v31 = v22;
          v32 = 2080;
          v33 = "ReadCodecConfigParams";
          v34 = 1024;
          v35 = 1346;
          v36 = 1024;
          v37 = a1;
          _os_log_impl(&dword_1D8A54000, v23, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d ReadCodecConfigParams: UNEXPECTED payload %d", buf, 0x22u);
        }
      }
      return 4294954396;
  }
  return DecoderParams;
}

double __nanosecondsToAbsoluteTime_block_invoke()
{
  unint64_t v0;
  unint64_t v1;
  double result;
  mach_timebase_info v3[2];

  v3[1] = *(mach_timebase_info *)MEMORY[0x1E0C80C00];
  v3[0] = (mach_timebase_info)0xAAAAAAAAAAAAAAAALL;
  mach_timebase_info(v3);
  LODWORD(v0) = v3[0].denom;
  LODWORD(v1) = v3[0].numer;
  result = (double)v0 / (double)v1;
  nanosecondsToAbsoluteTime_conversionRatio = *(_QWORD *)&result;
  return result;
}

uint64_t setRealTimeConstraints(double a1)
{
  _opaque_pthread_t *v2;
  thread_act_t v3;
  integer_t policy_info[4];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v2 = pthread_self();
  v3 = pthread_mach_thread_np(v2);
  if (nanosecondsToAbsoluteTime_onceToken != -1)
    dispatch_once(&nanosecondsToAbsoluteTime_onceToken, &__block_literal_global_22);
  policy_info[0] = (unint64_t)(*(double *)&nanosecondsToAbsoluteTime_conversionRatio
                                    * (double)(unint64_t)(a1 * 1000000000.0));
  policy_info[1] = (unint64_t)(*(double *)&nanosecondsToAbsoluteTime_conversionRatio * 500000.0);
  policy_info[2] = policy_info[0];
  policy_info[3] = 1;
  return thread_policy_set(v3, 2u, policy_info, 4u);
}

uint64_t Util_BinaryGCD(int a1, int a2)
{
  uint64_t v2;
  char v3;
  int v4;
  int v5;
  int v6;
  int v7;
  BOOL v8;
  unsigned int v9;
  unsigned int v10;

  v2 = a2 | a1;
  if (a1 && a2)
  {
    if (((a2 | a1) & 1) != 0)
    {
      v3 = 0;
    }
    else
    {
      v3 = 0;
      v4 = a1;
      do
      {
        a1 = v4 >> 1;
        a2 >>= 1;
        ++v3;
        v5 = a2 | (v4 >> 1);
        v4 >>= 1;
      }
      while ((v5 & 1) == 0);
    }
    do
    {
      v6 = a1;
      a1 >>= 1;
    }
    while ((v6 & 1) == 0);
    do
    {
      do
      {
        v7 = a2;
        a2 >>= 1;
      }
      while ((v7 & 1) == 0);
      v9 = v6 - v7;
      v8 = v6 - v7 < 0;
      if (v6 >= v7)
        v6 = v7;
      if (v8)
        v10 = -v9;
      else
        v10 = v9;
      a2 = v10 >> 1;
    }
    while (v10 > 1);
    return (v6 << v3);
  }
  return v2;
}

void SimplifyRatio(int *a1, int *a2)
{
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  NSObject *v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  v5 = Util_BinaryGCD(*a1, *a2);
  if (v5)
  {
    *a1 = v4 / v5;
    v6 = *a2 / v5;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v7 = VRTraceErrorLogLevelToCSTR();
      v8 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v9 = *a1;
        v10 = *a2;
        v11 = 136316162;
        v12 = v7;
        v13 = 2080;
        v14 = "SimplifyRatio";
        v15 = 1024;
        v16 = 1425;
        v17 = 1024;
        v18 = v9;
        v19 = 1024;
        v20 = v10;
        _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Resetting the ratio from %d:%d to 3:4", (uint8_t *)&v11, 0x28u);
      }
    }
    *a1 = 3;
    v6 = 4;
  }
  *a2 = v6;
}

double SimplifyFixedPointRatio(double *a1)
{
  int v2;
  double result;
  double v4;
  int v5;
  int v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = (int)*a1;
    v5 = (int)a1[1];
    v6 = v2;
    SimplifyRatio(&v6, &v5);
    result = (double)v6;
    v4 = (double)v5;
    *a1 = (double)v6;
    a1[1] = v4;
  }
  return result;
}

float *VCUtil_ExponentialMovingAverage(float *result, float a2, float a3)
{
  float v3;

  v3 = (float)((float)(2.0 / (float)(a3 + 1.0)) * a2) + *result * (1.0 - (float)(2.0 / (float)(a3 + 1.0)));
  *result = v3;
  return result;
}

size_t VCUtil_ConvertStreamIDArrayToString(size_t result, unsigned int a2, char *a3, size_t a4)
{
  size_t v6;
  uint64_t v7;
  uint64_t v8;
  size_t v9;
  BOOL v10;
  char __source[16];
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  *(_OWORD *)__source = 0u;
  v12 = 0u;
  if (a2)
  {
    v6 = result;
    v7 = 0;
    v8 = 2 * a2;
    v9 = a4;
    while (1)
    {
      __sprintf_chk(__source, 0, 0x60uLL, " %u,", *(unsigned __int16 *)(v6 + v7));
      if (v7)
        strlcat(a3, __source, v9);
      else
        strncpy(a3, __source, v9);
      result = strlen(__source);
      v10 = v9 > result;
      v9 -= result;
      if (!v10)
        break;
      v7 += 2;
      if (v8 == v7)
        return result;
    }
    a3[a4 - 1] = 0;
  }
  return result;
}

void VCUtil_AppendFromDictionary(__CFDictionary *a1, CFDictionaryRef theDict)
{
  CFIndex Count;
  size_t v5;
  unint64_t v6;
  const void **v7;
  void *v8;
  const void **v9;
  const void *v10;
  const void *v11;
  const void *v12;
  void *values[2];

  values[1] = *(void **)MEMORY[0x1E0C80C00];
  Count = CFDictionaryGetCount(theDict);
  v5 = 8 * Count;
  v6 = (8 * Count + 15) & 0xFFFFFFFFFFFFFFF0;
  v7 = (const void **)((char *)values - v6);
  if (MEMORY[0x1E0C80A78](Count))
  {
    v8 = memset((char *)values - v6, 170, v5);
    MEMORY[0x1E0C80A78](v8);
    v9 = (const void **)((char *)values - v6);
    memset(v9, 170, v5);
    CFDictionaryGetKeysAndValues(theDict, v7, v9);
    if (Count >= 1)
    {
      do
      {
        v11 = *v7++;
        v10 = v11;
        v12 = *v9++;
        CFDictionaryAddValue(a1, v10, v12);
        --Count;
      }
      while (Count);
    }
  }
  else
  {
    CFDictionaryGetKeysAndValues(theDict, (const void **)((char *)values - v6), (const void **)values);
  }
}

uint64_t VCUtil_BinaryPrefix(unint64_t a1, double *a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;

  if (a1 >= 0x400)
  {
    v2 = 0;
    v3 = a1;
    do
    {
      v4 = v2++;
      if (v4 > 4)
        break;
      v5 = v3 >> 20;
      v3 >>= 10;
    }
    while (v5);
  }
  else
  {
    v2 = 0;
  }
  if (a2)
    *a2 = (double)a1 / (double)(unint64_t)(1 << (10 * v2));
  return VCUtil_BinaryPrefix_prefixes[v2];
}

BOOL VCUtil_AuditTokenValid(uint64_t a1)
{
  _BOOL8 result;

  result = 0;
  if (a1)
  {
    if ((_UNKNOWN *)a1 != &_VCUtil_InvalidAuditToken)
      return (*(_QWORD *)a1 & *(_QWORD *)(a1 + 8) & *(_QWORD *)(a1 + 16) & *(_QWORD *)(a1 + 24)) != -1;
  }
  return result;
}

double VCUtil_AuditTokenForCurrentProcess@<D0>(_OWORD *a1@<X8>)
{
  __int128 v2;
  __int128 v3;
  __int128 v4;
  mach_msg_type_number_t task_info_outCnt;
  integer_t task_info_out[4];
  __int128 v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v2 = -1;
  *((_QWORD *)&v2 + 1) = -1;
  *(_OWORD *)task_info_out = v2;
  v8 = v2;
  task_info_outCnt = 8;
  if ((*MEMORY[0x1E0C83DA0] - 1) > 0xFFFFFFFD)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCUtil_AuditTokenForCurrentProcess_cold_2();
    }
  }
  else
  {
    if (!task_info(*MEMORY[0x1E0C83DA0], 0xFu, task_info_out, &task_info_outCnt))
    {
      *(_QWORD *)&v3 = *(_QWORD *)task_info_out;
      v4 = v8;
      *a1 = *(_OWORD *)task_info_out;
      a1[1] = v4;
      return *(double *)&v3;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCUtil_AuditTokenForCurrentProcess_cold_1();
    }
  }
  *(_QWORD *)&v3 = -1;
  *((_QWORD *)&v3 + 1) = -1;
  *a1 = v3;
  a1[1] = v3;
  return *(double *)&v3;
}

void _VCUtil_GenerateTailspin(int a1, uint64_t a2)
{
  __int128 v4;
  int v5;
  int v6;
  int v7;
  uint64_t v8;
  NSObject *v9;
  unsigned int *v10;
  unsigned int v11;
  NSObject *global_queue;
  _QWORD block[7];
  int v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  void *v18;
  _BYTE buf[24];
  _BYTE v20[14];
  __int16 v21;
  int v22;
  char __b[1024];
  _OWORD v24[8];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v15 = 0;
  v16 = &v15;
  v17 = 0x2000000000;
  v18 = (void *)0xAAAAAAAAAAAAAAAALL;
  _VCUtil_DiagnosticsAtomicSharedInstance();
  v18 = &_VCUtil_DiagnosticsAtomicSharedInstance_tailspinOrSpinDumpInProgress;
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v24[6] = v4;
  v24[7] = v4;
  v24[4] = v4;
  v24[5] = v4;
  v24[2] = v4;
  v24[3] = v4;
  v24[0] = v4;
  v24[1] = v4;
  VRLogfileGetTimestamp((char *)v24, 0x80u);
  memset(__b, 170, sizeof(__b));
  VCDiskUtils_CreateDirectory();
  snprintf(__b, 0x400uLL, "/private/var/tmp/avconference/avconferenced_%s.XXXXXX.tailspin", (const char *)v24);
  v5 = mkostemps(__b, 9, 0);
  if (v5 != -1)
  {
    v6 = v5;
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2000000000;
    *(_QWORD *)v20 = strndup(__b, 0x400uLL);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = ___VCUtil_GenerateTailspin_block_invoke;
    block[3] = &unk_1E9E54388;
    v14 = v6;
    block[5] = &v15;
    block[6] = a2;
    block[4] = buf;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3
      && (VRTraceErrorLogLevelToCSTR(), os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR)))
    {
      _VCUtil_GenerateTailspin_cold_1();
      if (a1)
        goto LABEL_5;
    }
    else if (a1)
    {
LABEL_5:
      ___VCUtil_GenerateTailspin_block_invoke((uint64_t)block);
LABEL_14:
      _Block_object_dispose(buf, 8);
      goto LABEL_15;
    }
    global_queue = dispatch_get_global_queue(-32768, 0);
    dispatch_async(global_queue, block);
    goto LABEL_14;
  }
  v7 = *__error();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v8 = VRTraceErrorLogLevelToCSTR();
    v9 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136316162;
      *(_QWORD *)&buf[4] = v8;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "_VCUtil_GenerateTailspin";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)v20 = 1590;
      *(_WORD *)&v20[4] = 2080;
      *(_QWORD *)&v20[6] = __b;
      v21 = 1024;
      v22 = v7;
      _os_log_error_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_ERROR, " [%s] %s:%d Failed to open file=%s: %{darwin.errno}d", buf, 0x2Cu);
    }
  }
  v10 = (unsigned int *)v16[3];
  do
    v11 = __ldaxr(v10);
  while (__stlxr(v11 - 1, v10));
LABEL_15:
  _Block_object_dispose(&v15, 8);
}

void _VCUtil_DiagnosticsAtomicSharedInstance()
{
  _QWORD v0[6];

  v0[5] = *MEMORY[0x1E0C80C00];
  v0[0] = MEMORY[0x1E0C809B0];
  v0[1] = 0x40000000;
  v0[2] = ___VCUtil_DiagnosticsAtomicSharedInstance_block_invoke;
  v0[3] = &__block_descriptor_tmp_119;
  v0[4] = &_VCUtil_DiagnosticsAtomicSharedInstance_tailspinOrSpinDumpInProgress;
  if (_VCUtil_DiagnosticsAtomicSharedInstance_onceToken != -1)
    dispatch_once(&_VCUtil_DiagnosticsAtomicSharedInstance_onceToken, v0);
}

void _VCUtil_GenerateStackshot(int a1, const char *a2)
{
  size_t v4;
  NSObject *global_queue;
  _QWORD v6[5];
  _QWORD v7[5];

  v7[4] = *MEMORY[0x1E0C80C00];
  if (VRTraceIsInternalOSInstalled())
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCUtil_GenerateStackshot_cold_1();
    }
    v4 = strlen(a2);
    v7[0] = 0;
    v7[1] = v7;
    v7[2] = 0x2000000000;
    v7[3] = strndup(a2, v4 + 1);
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 0x40000000;
    v6[2] = ___VCUtil_GenerateStackshot_block_invoke;
    v6[3] = &unk_1E9E543B0;
    v6[4] = v7;
    if (a1)
    {
      ___VCUtil_GenerateStackshot_block_invoke((uint64_t)v6);
    }
    else
    {
      global_queue = dispatch_get_global_queue(-32768, 0);
      dispatch_async(global_queue, v6);
    }
    _Block_object_dispose(v7, 8);
  }
}

void _VCUtil_GenerateSpindump(int a1, uint64_t a2, uint64_t a3)
{
  NSObject *global_queue;
  _QWORD v7[7];
  _QWORD v8[3];
  void *v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v8[0] = 0;
  v8[1] = v8;
  v8[2] = 0x2000000000;
  v9 = (void *)0xAAAAAAAAAAAAAAAALL;
  _VCUtil_DiagnosticsAtomicSharedInstance();
  v9 = &_VCUtil_DiagnosticsAtomicSharedInstance_tailspinOrSpinDumpInProgress;
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 0x40000000;
  v7[2] = ___VCUtil_GenerateSpindump_block_invoke;
  v7[3] = &unk_1E9E543F8;
  v7[5] = a2;
  v7[6] = a3;
  v7[4] = v8;
  if (a1)
  {
    ___VCUtil_GenerateSpindump_block_invoke((uint64_t)v7);
  }
  else
  {
    global_queue = dispatch_get_global_queue(-32768, 0);
    dispatch_async(global_queue, v7);
  }
  _Block_object_dispose(v8, 8);
}

uint64_t _VCUtil_GenerateDiagnosticsInternal(int a1, char a2, const char *a3, unsigned int a4, uint64_t a5)
{
  BOOL BoolValueForKey;
  uint64_t result;
  int v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v16;
  NSObject *v17;
  int v18;
  uint64_t v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if ((a2 & 1) != 0)
  {
    if (!a4)
      return 0;
  }
  else
  {
    BoolValueForKey = VCDefaults_GetBoolValueForKey(CFSTR("isGenerateStackshotEnabled"), 0);
    result = 0;
    if (!a4 || !BoolValueForKey)
      return result;
  }
  result = VRTraceIsInternalOSInstalled();
  if ((_DWORD)result)
  {
    if ((a4 & 1) != 0)
      _VCUtil_GenerateStackshot(a1, a3);
    v11 = a4 & 2;
    v12 = (a4 >> 1) & 1;
    v13 = a4 & 4;
    v14 = v12 + (v13 >> 2);
    _VCUtil_DiagnosticsAtomicSharedInstance();
    while (!__ldaxr((unsigned int *)&_VCUtil_DiagnosticsAtomicSharedInstance_tailspinOrSpinDumpInProgress))
    {
      if (!__stlxr(v14, (unsigned int *)&_VCUtil_DiagnosticsAtomicSharedInstance_tailspinOrSpinDumpInProgress))
      {
        if (v11)
          _VCUtil_GenerateTailspin(a1, (uint64_t)a3);
        if (v13)
          _VCUtil_GenerateSpindump(a1, (uint64_t)a3, a5);
        return 0;
      }
    }
    __clrex();
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v16 = VRTraceErrorLogLevelToCSTR();
      v17 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v18 = 136315650;
        v19 = v16;
        v20 = 2080;
        v21 = "_VCUtil_GenerateDiagnosticsInternal";
        v22 = 1024;
        v23 = 1716;
        _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Tailspin/spindump already in progress. Skipping.", (uint8_t *)&v18, 0x1Cu);
      }
    }
    return 1;
  }
  return result;
}

uint64_t VCUtil_GenerateDiagnostics(int a1, char a2, const char *a3, unsigned int a4)
{
  return _VCUtil_GenerateDiagnosticsInternal(a1, a2, a3, a4, 0);
}

void OUTLINED_FUNCTION_10_4(uint64_t a1@<X8>)
{
  uint64_t v1;

  *(_QWORD *)(v1 - 8) = a1;
}

BOOL VCMediaNegotiationBlobV2MomentsSettingsReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  char v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char v22;
  BOOL v23;
  int *v24;
  char v25;
  unsigned int v26;
  uint64_t v27;
  unint64_t v28;
  char v29;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    while (1)
    {
      if (*(_BYTE *)(a2 + *v5))
        return *(_BYTE *)(a2 + *v5) == 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        return *(_BYTE *)(a2 + *v5) == 0;
      if ((v10 >> 3) == 2)
        break;
      if ((v10 >> 3) == 1)
      {
        v17 = 0;
        v18 = 0;
        v19 = 0;
        *(_BYTE *)(a1 + 16) |= 1u;
        while (1)
        {
          v20 = *v3;
          v21 = *(_QWORD *)(a2 + v20);
          if (v21 == -1 || v21 >= *(_QWORD *)(a2 + *v4))
          {
            v24 = &OBJC_IVAR___VCMediaNegotiationBlobV2MomentsSettings__capabilities;
            goto LABEL_38;
          }
          v22 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v21);
          *(_QWORD *)(a2 + v20) = v21 + 1;
          v19 |= (unint64_t)(v22 & 0x7F) << v17;
          if ((v22 & 0x80) == 0)
            break;
          v17 += 7;
          v23 = v18++ > 8;
          if (v23)
          {
            LODWORD(v19) = 0;
            v24 = &OBJC_IVAR___VCMediaNegotiationBlobV2MomentsSettings__capabilities;
            goto LABEL_41;
          }
        }
        v24 = &OBJC_IVAR___VCMediaNegotiationBlobV2MomentsSettings__capabilities;
LABEL_39:
        if (*(_BYTE *)(a2 + *v5))
          LODWORD(v19) = 0;
LABEL_41:
        *(_DWORD *)(a1 + *v24) = v19;
        goto LABEL_42;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0)
        return 0;
LABEL_42:
      if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
        return *(_BYTE *)(a2 + *v5) == 0;
    }
    v25 = 0;
    v26 = 0;
    v19 = 0;
    *(_BYTE *)(a1 + 16) |= 2u;
    while (1)
    {
      v27 = *v3;
      v28 = *(_QWORD *)(a2 + v27);
      if (v28 == -1 || v28 >= *(_QWORD *)(a2 + *v4))
        break;
      v29 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v28);
      *(_QWORD *)(a2 + v27) = v28 + 1;
      v19 |= (unint64_t)(v29 & 0x7F) << v25;
      if ((v29 & 0x80) == 0)
      {
        v24 = &OBJC_IVAR___VCMediaNegotiationBlobV2MomentsSettings__supportedCodecs;
        goto LABEL_39;
      }
      v25 += 7;
      v23 = v26++ > 8;
      if (v23)
      {
        LODWORD(v19) = 0;
        v24 = &OBJC_IVAR___VCMediaNegotiationBlobV2MomentsSettings__supportedCodecs;
        goto LABEL_41;
      }
    }
    v24 = &OBJC_IVAR___VCMediaNegotiationBlobV2MomentsSettings__supportedCodecs;
LABEL_38:
    *(_BYTE *)(a2 + *v5) = 1;
    goto LABEL_39;
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

uint64_t VCSingleLinkedListClear(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  int v4;
  _QWORD *v5;
  _QWORD v6[2];

  v6[1] = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v2 = result;
    v6[0] = 0;
    if (*(_BYTE *)(result + 8))
    {
      v4 = 1;
      do
      {
        v5 = *(_QWORD **)v2;
        if (!*(_QWORD *)v2)
          break;
        *(_QWORD *)v2 = *v5;
        *v5 = 0;
        --*(_QWORD *)(v2 + 24);
        v6[0] = v5;
        if (a2)
        {
          result = (*(uint64_t (**)(uint64_t, _QWORD *))(a2 + 16))(a2, v6);
          v4 = *(unsigned __int8 *)(v2 + 8);
        }
      }
      while (v4);
    }
  }
  return result;
}

uint64_t *VCSingleLinkedListPop(uint64_t *result)
{
  _QWORD *v1;

  if (result)
  {
    v1 = result;
    if (*((_BYTE *)result + 8))
    {
      result = (uint64_t *)*result;
      if (*v1)
      {
        *v1 = *result;
        *result = 0;
        --v1[3];
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

_QWORD *VCSingleLinkedListRemove(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  _QWORD *v5;

  if (!a1)
    return 0;
  v3 = 0;
  if (a2 && *(_BYTE *)(a1 + 8))
  {
    v3 = (_QWORD *)a1;
    while (1)
    {
      v5 = v3;
      v3 = (_QWORD *)*v3;
      if (!v3)
        break;
      if ((*(unsigned int (**)(_QWORD *, uint64_t))(a1 + 16))(v3, a2) == 1)
      {
        *v5 = *v3;
        *v3 = 0;
        --*(_QWORD *)(a1 + 24);
        return v3;
      }
    }
  }
  return v3;
}

uint64_t VCSingleLinkedGetNumberEntries(uint64_t result)
{
  if (result)
  {
    if (*(_BYTE *)(result + 8))
      return *(_QWORD *)(result + 24);
    else
      return 0;
  }
  return result;
}

uint64_t VCSingleLinkedListEnumerate(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  _QWORD *v4;
  BOOL v5;
  char v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v3 = result;
    result = 0;
    if (a2)
    {
      if (*(_BYTE *)(v3 + 8))
      {
        v6 = 0;
        v4 = *(_QWORD **)v3;
        if (*(_QWORD *)v3)
        {
          do
          {
            (*(void (**)(uint64_t, _QWORD *, char *))(a2 + 16))(a2, v4, &v6);
            v4 = (_QWORD *)*v4;
            if (v4)
              v5 = v6 == 0;
            else
              v5 = 0;
          }
          while (v5);
        }
        return 1;
      }
    }
  }
  return result;
}

uint64_t VCSessionOneToOneSystemAudioTierTable()
{
  _QWORD v1[2];
  _QWORD v2[3];

  v2[2] = *MEMORY[0x1E0C80C00];
  v1[0] = &unk_1E9EF4220;
  v1[1] = &unk_1E9EF4250;
  v2[0] = &unk_1E9EF4238;
  v2[1] = &unk_1E9EF4268;
  return objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v2, v1, 2);
}

uint64_t VCSessionOneToOneCameraTierTable()
{
  _QWORD v1[6];
  _QWORD v2[7];

  v2[6] = *MEMORY[0x1E0C80C00];
  v1[0] = &unk_1E9EF4280;
  v1[1] = &unk_1E9EF42B0;
  v2[0] = &unk_1E9EF4298;
  v2[1] = &unk_1E9EF42C8;
  v1[2] = &unk_1E9EF42E0;
  v1[3] = &unk_1E9EF4310;
  v2[2] = &unk_1E9EF42F8;
  v2[3] = &unk_1E9EF4328;
  v1[4] = &unk_1E9EF4340;
  v1[5] = &unk_1E9EF4370;
  v2[4] = &unk_1E9EF4358;
  v2[5] = &unk_1E9EF4388;
  return objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v2, v1, 6);
}

uint64_t VCSessionOneToOneScreenTierTable()
{
  _QWORD v1[8];
  _QWORD v2[9];

  v2[8] = *MEMORY[0x1E0C80C00];
  v1[0] = &unk_1E9EF43A0;
  v1[1] = &unk_1E9EF43D0;
  v2[0] = &unk_1E9EF43B8;
  v2[1] = &unk_1E9EF43E8;
  v1[2] = &unk_1E9EF4400;
  v1[3] = &unk_1E9EF4430;
  v2[2] = &unk_1E9EF4418;
  v2[3] = &unk_1E9EF4448;
  v1[4] = &unk_1E9EF4460;
  v1[5] = &unk_1E9EF4490;
  v2[4] = &unk_1E9EF4478;
  v2[5] = &unk_1E9EF44A8;
  v1[6] = &unk_1E9EF44C0;
  v1[7] = &unk_1E9EF44F0;
  v2[6] = &unk_1E9EF44D8;
  v2[7] = &unk_1E9EF4508;
  return objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v2, v1, 8);
}

uint64_t VCSessionOneToOneScreenTierTableForegroundCamera()
{
  _QWORD v1[5];
  _QWORD v2[6];

  v2[5] = *MEMORY[0x1E0C80C00];
  v1[0] = &unk_1E9EF43A0;
  v1[1] = &unk_1E9EF43D0;
  v2[0] = &unk_1E9EF43B8;
  v2[1] = &unk_1E9EF43E8;
  v1[2] = &unk_1E9EF4430;
  v1[3] = &unk_1E9EF4490;
  v2[2] = &unk_1E9EF4418;
  v2[3] = &unk_1E9EF4448;
  v1[4] = &unk_1E9EF44C0;
  v2[4] = &unk_1E9EF4478;
  return objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v2, v1, 5);
}

uint64_t VCSessionOneToOneReducedMicTierTable()
{
  _QWORD v1[3];
  _QWORD v2[4];

  v2[3] = *MEMORY[0x1E0C80C00];
  v1[0] = &unk_1E9EF4520;
  v1[1] = &unk_1E9EF4550;
  v2[0] = &unk_1E9EF4538;
  v2[1] = &unk_1E9EF4568;
  v1[2] = &unk_1E9EF4580;
  v2[2] = &unk_1E9EF4598;
  return objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v2, v1, 3);
}

uint64_t VCSessionOneToOneFullMicTierTable()
{
  _QWORD v1[8];
  _QWORD v2[9];

  v2[8] = *MEMORY[0x1E0C80C00];
  v1[0] = &unk_1E9EF45B0;
  v1[1] = &unk_1E9EF4520;
  v2[0] = &unk_1E9EF45C8;
  v2[1] = &unk_1E9EF4538;
  v1[2] = &unk_1E9EF45E0;
  v1[3] = &unk_1E9EF45F8;
  v2[2] = &unk_1E9EF4298;
  v2[3] = &unk_1E9EF4610;
  v1[4] = &unk_1E9EF4628;
  v1[5] = &unk_1E9EF4550;
  v2[4] = &unk_1E9EF4640;
  v2[5] = &unk_1E9EF4568;
  v1[6] = &unk_1E9EF4580;
  v1[7] = &unk_1E9EF4658;
  v2[6] = &unk_1E9EF4598;
  v2[7] = &unk_1E9EF4670;
  return objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v2, v1, 8);
}

uint64_t VCSessionOneToOneFTXTTierTable()
{
  _QWORD v1[3];
  _QWORD v2[4];

  v2[3] = *MEMORY[0x1E0C80C00];
  v1[0] = &unk_1E9EF4688;
  v1[1] = &unk_1E9EF46B8;
  v2[0] = &unk_1E9EF46A0;
  v2[1] = &unk_1E9EF46D0;
  v1[2] = &unk_1E9EF46E8;
  v2[2] = &unk_1E9EF4700;
  return objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v2, v1, 3);
}

uint64_t VCSessionOneToOneFTXTTierTableWithRedundancy()
{
  _QWORD v1[3];
  _QWORD v2[4];

  v2[3] = *MEMORY[0x1E0C80C00];
  v1[0] = &unk_1E9EF4688;
  v1[1] = &unk_1E9EF46B8;
  v2[0] = &unk_1E9EF4718;
  v2[1] = &unk_1E9EF4730;
  v1[2] = &unk_1E9EF46E8;
  v2[2] = &unk_1E9EF4748;
  return objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v2, v1, 3);
}

uint64_t VCSessionOneToOneBDATTierTable()
{
  _QWORD v1[2];
  _QWORD v2[3];

  v2[2] = *MEMORY[0x1E0C80C00];
  v1[0] = &unk_1E9EF4760;
  v1[1] = &unk_1E9EF4790;
  v2[0] = &unk_1E9EF4778;
  v2[1] = &unk_1E9EF47A8;
  return objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v2, v1, 2);
}

uint64_t VCSessionLowLatencyVideoCallMicrophoneBandwidthTable()
{
  _QWORD v1[10];
  _QWORD v2[11];

  v2[10] = *MEMORY[0x1E0C80C00];
  v1[0] = &unk_1E9EF47C0;
  v1[1] = &unk_1E9EF47F0;
  v2[0] = &unk_1E9EF47D8;
  v2[1] = &unk_1E9EF45C8;
  v1[2] = &unk_1E9EF4568;
  v1[3] = &unk_1E9EF4820;
  v2[2] = &unk_1E9EF4808;
  v2[3] = &unk_1E9EF4538;
  v1[4] = &unk_1E9EF4838;
  v1[5] = &unk_1E9EF4850;
  v2[4] = &unk_1E9EF4298;
  v2[5] = &unk_1E9EF4610;
  v1[6] = &unk_1E9EF4868;
  v1[7] = &unk_1E9EF4880;
  v2[6] = &unk_1E9EF4640;
  v2[7] = &unk_1E9EF4568;
  v1[8] = &unk_1E9EF4898;
  v1[9] = &unk_1E9EF48B0;
  v2[8] = &unk_1E9EF4598;
  v2[9] = &unk_1E9EF4670;
  return objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v2, v1, 10);
}

uint64_t VCSessionVideoCallMicrophoneBandwidthTable()
{
  _QWORD v1[9];
  _QWORD v2[10];

  v2[9] = *MEMORY[0x1E0C80C00];
  v1[0] = &unk_1E9EF47C0;
  v1[1] = &unk_1E9EF47F0;
  v2[0] = &unk_1E9EF47D8;
  v2[1] = &unk_1E9EF45C8;
  v1[2] = &unk_1E9EF4568;
  v1[3] = &unk_1E9EF4820;
  v2[2] = &unk_1E9EF4808;
  v2[3] = &unk_1E9EF4538;
  v1[4] = &unk_1E9EF4838;
  v1[5] = &unk_1E9EF4850;
  v2[4] = &unk_1E9EF4298;
  v2[5] = &unk_1E9EF4610;
  v1[6] = &unk_1E9EF4868;
  v1[7] = &unk_1E9EF4880;
  v2[6] = &unk_1E9EF4640;
  v2[7] = &unk_1E9EF4568;
  v1[8] = &unk_1E9EF4898;
  v2[8] = &unk_1E9EF48C8;
  return objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v2, v1, 9);
}

uint64_t VCSessionLowLatencyMicrophoneOnlyBandwidthTable()
{
  _QWORD v1[9];
  _QWORD v2[10];

  v2[9] = *MEMORY[0x1E0C80C00];
  v1[0] = &unk_1E9EF43B8;
  v1[1] = &unk_1E9EF4808;
  v2[0] = &unk_1E9EF47D8;
  v2[1] = &unk_1E9EF45C8;
  v1[2] = &unk_1E9EF47F0;
  v1[3] = &unk_1E9EF4640;
  v2[2] = &unk_1E9EF48E0;
  v2[3] = &unk_1E9EF48F8;
  v1[4] = &unk_1E9EF4568;
  v1[5] = &unk_1E9EF4928;
  v2[4] = &unk_1E9EF4910;
  v2[5] = &unk_1E9EF4940;
  v1[6] = &unk_1E9EF4838;
  v1[7] = &unk_1E9EF4958;
  v2[6] = &unk_1E9EF48C8;
  v2[7] = &unk_1E9EF4670;
  v1[8] = &unk_1E9EF4970;
  v2[8] = &unk_1E9EF4988;
  return objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v2, v1, 9);
}

uint64_t VCSessionMicrophoneOnlyBandwidthTable()
{
  _QWORD v1[9];
  _QWORD v2[10];

  v2[9] = *MEMORY[0x1E0C80C00];
  v1[0] = &unk_1E9EF43B8;
  v1[1] = &unk_1E9EF4808;
  v2[0] = &unk_1E9EF47D8;
  v2[1] = &unk_1E9EF45C8;
  v1[2] = &unk_1E9EF47F0;
  v1[3] = &unk_1E9EF4640;
  v2[2] = &unk_1E9EF48E0;
  v2[3] = &unk_1E9EF48F8;
  v1[4] = &unk_1E9EF4568;
  v1[5] = &unk_1E9EF4928;
  v2[4] = &unk_1E9EF4910;
  v2[5] = &unk_1E9EF4940;
  v1[6] = &unk_1E9EF4838;
  v1[7] = &unk_1E9EF4958;
  v2[6] = &unk_1E9EF48C8;
  v2[7] = &unk_1E9EF49A0;
  v1[8] = &unk_1E9EF4850;
  v2[8] = &unk_1E9EF49B8;
  return objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v2, v1, 9);
}

uint64_t _NACKConsumer_CloseSummerHandles(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;

  v1 = a1 + 1054736;
  if (*(_QWORD *)(a1 + 1054736) != 0xFFFFFFFFLL)
    SummerCloseHandle();
  result = *(_QWORD *)(v1 + 8);
  if (result != 0xFFFFFFFFLL)
    return SummerCloseHandle();
  return result;
}

uint64_t _VCNACKConsumerClassRegister(uint64_t *a1)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

uint64_t VCNACKConsumer_Create(uint64_t a1, uint64_t *a2)
{
  uint64_t Instance;
  uint64_t v4;
  uint64_t Handle;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  int v10;
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (VCNACKConsumerGetTypeID_initOnce != -1)
      dispatch_once_f(&VCNACKConsumerGetTypeID_initOnce, &VCNACKConsumerGetTypeID_typeID, (dispatch_function_t)_VCNACKConsumerClassRegister);
    Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      v4 = Instance;
      if ((SummerCreateHandle((uint64_t *)(Instance + 1054736), 400) & 0x80000000) != 0)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCNACKConsumer_Create_cold_3();
        }
      }
      else
      {
        Handle = SummerCreateHandle((uint64_t *)(v4 + 1054744), 400);
        if ((Handle & 0x80000000) == 0)
        {
          v6 = Handle;
          SummerAdd(0.0, 0.0);
          *(_DWORD *)(v4 + 1054764) = 10;
          *(_BYTE *)(v4 + 1054760) = 1;
          *(_DWORD *)(v4 + 1054768) = reportingDefaultRealtimePeriod();
          *(_BYTE *)(v4 + 1054772) = VCDefaults_GetBoolValueForKey(CFSTR("ignoreRetransmissionBudget"), 0);
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v7 = VRTraceErrorLogLevelToCSTR();
            v8 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              v10 = 136315906;
              v11 = v7;
              v12 = 2080;
              v13 = "VCNACKConsumer_Create";
              v14 = 1024;
              v15 = 166;
              v16 = 2048;
              v17 = v4;
              _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d New instance created=%p", (uint8_t *)&v10, 0x26u);
            }
          }
          *a2 = v4;
          return v6;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCNACKConsumer_Create_cold_4();
        }
      }
      _NACKConsumer_CloseSummerHandles(v4);
      CFRelease((CFTypeRef)v4);
      return 2152071172;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
    {
      return 2152071171;
    }
    else
    {
      VRTraceErrorLogLevelToCSTR();
      v6 = 2152071171;
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCNACKConsumer_Create_cold_2();
    }
  }
  else
  {
    v6 = 2152071169;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCNACKConsumer_Create_cold_1();
    }
  }
  return v6;
}

uint64_t VCNACKConsumer_GetRetransmissionRequestInfoFromNACK(uint64_t a1, int *a2, uint64_t a3)
{
  uint64_t v6;
  int v7;
  unsigned int v8;
  uint64_t v9;
  _DWORD *v10;
  int v11;
  unsigned int v12;
  __int16 v13;
  int v14;
  int *v15;
  unsigned __int8 v16;
  BOOL v17;
  uint64_t v18;
  NSObject *v19;
  NSObject *v20;
  int v21;
  uint64_t v22;
  uint64_t v24;
  NSObject *v25;
  NSObject *v26;
  int v27;
  uint64_t v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  int v32;
  __int16 v33;
  int v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a2)
    {
      if (a3)
      {
        v6 = a1 + 1054760;
        if (*(_BYTE *)(a1 + 1054760))
        {
          v7 = *a2;
          v8 = *a2 & 0x3F;
          v9 = a1 + 16480 * v8;
          v11 = *(_DWORD *)(v9 + 16);
          v10 = (_DWORD *)(v9 + 16);
          if (v11 != *a2)
          {
            bzero(v10, 0x4060uLL);
            *v10 = v7;
          }
          v12 = *((unsigned __int16 *)a2 + 3);
          v13 = *((_WORD *)a2 + 2);
          v15 = (int *)(v6 + 4);
          v14 = *(_DWORD *)(v6 + 4);
          if (v14 > 0 || *(_BYTE *)(v6 + 12))
          {
            *(_WORD *)(a3 + 10) = v13;
            *v15 = --v14;
            v16 = 1;
            if (v12)
            {
LABEL_10:
              while (v14 > 0 || *(_BYTE *)(v6 + 12))
              {
                ++v13;
                if ((v12 & 1) != 0)
                {
                  *(_WORD *)(a3 + 2 * v16 + 10) = v13;
                  *v15 = --v14;
                  ++v16;
                }
                v17 = v12 > 1;
                v12 >>= 1;
                if (!v17)
                  goto LABEL_15;
              }
              goto LABEL_17;
            }
          }
          else
          {
            v16 = 0;
            if (v12)
              goto LABEL_10;
          }
LABEL_15:
          if (v14 > 0 || *(_BYTE *)(v6 + 12))
          {
LABEL_25:
            *(_WORD *)(a3 + 4) = v16;
            v22 = a1 + 16480 * v8;
            *(_QWORD *)(v22 + 24) += v16;
            ++*(_QWORD *)(v22 + 56);
            return 0;
          }
LABEL_17:
          if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            v18 = VRTraceErrorLogLevelToCSTR();
            v19 = *MEMORY[0x1E0CF2758];
            v20 = *MEMORY[0x1E0CF2758];
            if (*MEMORY[0x1E0CF2748])
            {
              if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
              {
                v21 = *v15;
                v27 = 136315906;
                v28 = v18;
                v29 = 2080;
                v30 = "VCNACKConsumer_GetRetransmissionRequestInfoFromNACK";
                v31 = 1024;
                v32 = 233;
                v33 = 1024;
                v34 = v21;
                _os_log_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Retransmission packet count exceeded allotted budget. retransmissionBudget=%d", (uint8_t *)&v27, 0x22u);
              }
            }
            else if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
            {
              VCNACKConsumer_GetRetransmissionRequestInfoFromNACK_cold_5(v18, v15, v19);
            }
          }
          goto LABEL_25;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          v24 = VRTraceErrorLogLevelToCSTR();
          v25 = *MEMORY[0x1E0CF2758];
          v26 = *MEMORY[0x1E0CF2758];
          if (*MEMORY[0x1E0CF2748])
          {
            if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
            {
              v27 = 136315650;
              v28 = v24;
              v29 = 2080;
              v30 = "VCNACKConsumer_GetRetransmissionRequestInfoFromNACK";
              v31 = 1024;
              v32 = 212;
              _os_log_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Cannot retransmit - retransmission bitrate exceeded allotted quota", (uint8_t *)&v27, 0x1Cu);
            }
          }
          else if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
          {
            VCNACKConsumer_GetRetransmissionRequestInfoFromNACK_cold_4();
          }
        }
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCNACKConsumer_GetRetransmissionRequestInfoFromNACK_cold_3();
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCNACKConsumer_GetRetransmissionRequestInfoFromNACK_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCNACKConsumer_GetRetransmissionRequestInfoFromNACK_cold_1();
  }
  return 0;
}

uint64_t _VCNACKConsumer_CheckBitrateLimits(uint64_t a1, double a2)
{
  uint64_t v4;
  double v5;
  double v6;
  double v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  int v14;
  int v15;
  uint64_t v17;
  NSObject *v18;
  NSObject *v19;
  double v20;
  double v21;
  int v22;
  _BYTE buf[12];
  __int16 v24;
  const char *v25;
  __int16 v26;
  int v27;
  __int16 v28;
  double v29;
  __int16 v30;
  int v31;
  __int16 v32;
  _BOOL4 v33;
  __int16 v34;
  double v35;
  __int16 v36;
  double v37;
  __int16 v38;
  double v39;
  __int16 v40;
  int v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v4 = a1 + 1054736;
  v20 = 0.0;
  v21 = 0.0;
  v5 = *(double *)(a1 + 1054752);
  if (v5 != 0.0)
  {
    v6 = a2 - v5;
    if (a2 - v5 <= 0.1)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v17 = VRTraceErrorLogLevelToCSTR();
        v18 = *MEMORY[0x1E0CF2758];
        v19 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          v11 = 0;
          if (!os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
            return v11;
          *(_DWORD *)buf = 136315906;
          *(_QWORD *)&buf[4] = v17;
          v24 = 2080;
          v25 = "_VCNACKConsumer_CheckBitrateLimits";
          v26 = 1024;
          v27 = 291;
          v28 = 2048;
          v29 = v6;
          _os_log_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Use cached canSendNACK, timeSinceLastCheck=%f", buf, 0x26u);
        }
        else if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
        {
          _VCNACKConsumer_CheckBitrateLimits_cold_1();
        }
      }
      return 0;
    }
  }
  if ((_VCNACKConsumer_GetBitrate(a1, &v21, &v20, a2 + -1.0) & 0x80000000) != 0)
  {
    v11 = 2152071172;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCNACKConsumer_CheckBitrateLimits_cold_2();
    }
  }
  else
  {
    if (v21 == 0.0)
      v7 = 0.0;
    else
      v7 = v20 / v21;
    v8 = v7 < 0.2;
    v9 = *(_QWORD *)v4;
    v22 = 0;
    *(_QWORD *)buf = 0;
    v10 = SummerLengthPred(a2 + -0.1, v9, (uint64_t (*)(double, double, double))SummerGreaterThan, (double *)buf, &v22);
    if ((v10 & 0x80000000) != 0)
    {
      v11 = 2152071172;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCNACKConsumer_CheckBitrateLimits_cold_3();
      }
    }
    else
    {
      v11 = v10;
      *(_DWORD *)(v4 + 28) = vcvtpd_s64_f64((double)v22 * 0.2);
      if (*(unsigned __int8 *)(v4 + 24) != v8 && (int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v12 = VRTraceErrorLogLevelToCSTR();
        v13 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v14 = *(unsigned __int8 *)(v4 + 24);
          v15 = *(_DWORD *)(v4 + 28);
          *(_DWORD *)buf = 136317442;
          *(_QWORD *)&buf[4] = v12;
          v24 = 2080;
          v25 = "_VCNACKConsumer_CheckBitrateLimits";
          v26 = 1024;
          v27 = 304;
          v28 = 2048;
          v29 = *(double *)&a1;
          v30 = 1024;
          v31 = v14;
          v32 = 1024;
          v33 = v7 < 0.2;
          v34 = 2048;
          v35 = v21;
          v36 = 2048;
          v37 = v20;
          v38 = 2048;
          v39 = v7;
          v40 = 1024;
          v41 = v15;
          _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCNACKConsumer[%p] Based on bitrate limits, canRetransmit changed from before=%d to after=%d, mediaBitrate=%3.3f, retransmittedBitrate=%3.3f, overhead=%3.3f retransmissionBudget=%d", buf, 0x56u);
        }
      }
      *(double *)(v4 + 16) = a2;
      *(_BYTE *)(v4 + 24) = v8;
    }
  }
  return v11;
}

uint64_t _VCNACKConsumer_GetBitrate(uint64_t a1, double *a2, double *a3, double a4)
{
  uint64_t *v6;
  uint64_t v7;
  uint64_t v9;
  NSObject *v10;
  const char *v11;
  uint64_t v12;
  NSObject *v13;
  NSObject *log;
  uint8_t buf[4];
  uint64_t v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v6 = (uint64_t *)(a1 + 1054736);
  if (!a2)
  {
    v7 = 0;
    if (!a3)
      return v7;
    goto LABEL_6;
  }
  v7 = _VCNACKConsumer_ComputeSummerBitrate(*v6, a2, a4);
  if ((v7 & 0x80000000) == 0)
  {
    if (!a3)
      return v7;
LABEL_6:
    v7 = _VCNACKConsumer_ComputeSummerBitrate(v6[1], a3, a4);
    if ((v7 & 0x80000000) != 0 && (int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v12 = VRTraceErrorLogLevelToCSTR();
      v13 = *MEMORY[0x1E0CF2758];
      log = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          v16 = v12;
          v17 = 2080;
          v18 = "_VCNACKConsumer_GetBitrate";
          v19 = 1024;
          v20 = 263;
          v11 = " [%s] %s:%d Failed to compute summer bitrate for retransmitted bytes";
          goto LABEL_16;
        }
      }
      else if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        _VCNACKConsumer_GetBitrate_cold_1();
      }
    }
    return v7;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v9 = VRTraceErrorLogLevelToCSTR();
    v10 = *MEMORY[0x1E0CF2758];
    log = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        v16 = v9;
        v17 = 2080;
        v18 = "_VCNACKConsumer_GetBitrate";
        v19 = 1024;
        v20 = 259;
        v11 = " [%s] %s:%d Failed to compute summer bitrate for media bytes";
LABEL_16:
        _os_log_impl(&dword_1D8A54000, log, OS_LOG_TYPE_DEFAULT, v11, buf, 0x1Cu);
      }
    }
    else if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      _VCNACKConsumer_GetBitrate_cold_2();
    }
  }
  return v7;
}

uint64_t VCNACKConsumer_UpdateRetransmissionStatus(uint64_t a1, int *a2)
{
  int v4;
  unsigned int v5;
  uint64_t v6;
  _DWORD *v7;
  int v8;
  uint64_t v9;
  double v10;
  uint64_t v11;
  double v12;
  double v13;
  BOOL v15;
  uint64_t v16;
  double v17;
  double v18;
  BOOL v20;
  unsigned int v21;
  uint64_t v22;
  _WORD *v23;
  unsigned int v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;

  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCNACKConsumer_UpdateRetransmissionStatus_cold_1();
    }
    return 0;
  }
  v4 = *a2;
  v5 = *a2 & 0x3F;
  v6 = a1 + 16480 * v5;
  v8 = *(_DWORD *)(v6 + 16);
  v7 = (_DWORD *)(v6 + 16);
  if (v8 != *a2)
  {
    bzero(v7, 0x4060uLL);
    *v7 = v4;
  }
  v9 = a2[1] & 0x7FF;
  v10 = *((double *)a2 + 1);
  if (*((_BYTE *)a2 + 6))
  {
    v11 = a1 + 16480 * v5;
    ++*(_QWORD *)(v11 + 40);
    v12 = *(double *)(v11 + 8 * v9 + 96);
    v13 = v10 - v12;
    v15 = v12 <= 0.0 || v10 <= v12 || v13 > 5.0;
    if (!v15 && v10 > 0.0)
      *(double *)(a1 + 16480 * v5 + 16480) = v13;
  }
  else
  {
    v16 = a1 + 16480 * v5;
    v17 = *(double *)(v16 + 8 * (a2[1] & 0x7FF) + 96);
    ++*(_QWORD *)(v16 + 48);
    v18 = v10 - v17;
    v20 = v17 <= 0.0 || v10 <= v17 || v18 > 5.0;
    if (!v20 && v10 > 0.0)
      *(double *)(a1 + 16480 * v5 + 16488) = v18;
  }
  if (*((_BYTE *)a2 + 7))
    ++*(_QWORD *)(a1 + 16480 * v5 + 32);
  v21 = *((unsigned __int16 *)a2 + 8);
  if (v21 >= 2)
    ++*(_QWORD *)(a1 + 16480 * v5 + 64);
  v22 = a1 + 16480 * v5;
  v24 = *(unsigned __int16 *)(v22 + 72);
  v23 = (_WORD *)(v22 + 72);
  if (v21 > v24)
    *v23 = v21;
  v25 = *((_QWORD *)a2 + 3);
  if (!v25)
    return 0;
  *(_QWORD *)(a1 + 16480 * v5 + 80) += v25;
  v26 = SummerAdd((double)v25, v10);
  if ((v26 & 0x80000000) != 0)
  {
    v27 = 2152071172;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCNACKConsumer_UpdateRetransmissionStatus_cold_2();
    }
  }
  else
  {
    v27 = v26;
    _VCNACKConsumer_CheckBitrateLimits(a1, v10);
  }
  return v27;
}

uint64_t VCNACKConsumer_UpdateTransmissionStatus(uint64_t a1, int *a2)
{
  int v4;
  unsigned int v5;
  uint64_t v6;
  _DWORD *v7;
  int v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCNACKConsumer_UpdateTransmissionStatus_cold_1();
    }
    return 0;
  }
  v4 = *a2;
  v5 = *a2 & 0x3F;
  v6 = a1 + 16480 * v5;
  v8 = *(_DWORD *)(v6 + 16);
  v7 = (_DWORD *)(v6 + 16);
  if (v8 != *a2)
  {
    bzero(v7, 0x4060uLL);
    *v7 = v4;
  }
  v9 = *((_QWORD *)a2 + 2);
  if (!v9)
    return 0;
  *(_QWORD *)(a1 + 16480 * v5 + 88) += v9;
  v10 = SummerAdd((double)v9, *((double *)a2 + 1));
  if ((v10 & 0x80000000) != 0)
  {
    v11 = 2152071172;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCNACKConsumer_UpdateTransmissionStatus_cold_2();
    }
  }
  else
  {
    v11 = v10;
    _VCNACKConsumer_CheckBitrateLimits(a1, *((double *)a2 + 1));
  }
  return v11;
}

uint64_t VCNACKConsumer_UpdatePacketCacheStatus(uint64_t a1, int *a2)
{
  int v4;
  unsigned int v5;
  uint64_t v6;
  _DWORD *v7;
  int v8;
  uint64_t v9;

  if (a2)
  {
    v4 = *a2;
    v5 = *a2 & 0x3F;
    v6 = a1 + 16480 * v5;
    v8 = *(_DWORD *)(v6 + 16);
    v7 = (_DWORD *)(v6 + 16);
    if (v8 != *a2)
    {
      bzero(v7, 0x4060uLL);
      *v7 = v4;
    }
    v9 = 0;
    *(_QWORD *)(a1 + 16480 * v5 + 8 * (a2[1] & 0x7FF) + 96) = *((_QWORD *)a2 + 1);
  }
  else
  {
    v9 = 2152071169;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCNACKConsumer_UpdatePacketCacheStatus_cold_1();
    }
  }
  return v9;
}

void VCNACKConsumer_GetStatistics(uint64_t a1, __CFDictionary *a2)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  double v7;
  uint64_t v8;
  double v9;
  uint64_t v10;
  int64x2_t v11;
  int64x2_t v12;
  double v13;
  double v14;
  const __CFAllocator *v15;
  CFNumberRef v16;
  CFNumberRef v17;
  CFNumberRef v18;
  CFNumberRef v19;
  CFNumberRef v20;
  CFNumberRef v21;
  CFNumberRef v22;
  double v23;
  double v24;
  unsigned int v25;
  CFNumberRef v26;
  unsigned int v27;
  CFNumberRef v28;
  unint64_t v29;
  CFNumberRef v30;
  CFNumberRef v31;
  uint64_t v32;
  NSObject *v33;
  uint64_t v34;
  uint64_t v35;
  int64x2_t v36;
  __int128 v37;
  unsigned int valuePtr;
  uint64_t v39;
  __int16 v40;
  const char *v41;
  __int16 v42;
  int v43;
  __int16 v44;
  uint64_t v45;
  __int16 v46;
  uint64_t v47;
  __int16 v48;
  uint64_t v49;
  __int16 v50;
  uint64_t v51;
  __int16 v52;
  uint64_t v53;
  __int16 v54;
  uint64_t v55;
  __int16 v56;
  uint64_t v57;
  __int16 v58;
  unsigned int v59;
  __int16 v60;
  double v61;
  __int16 v62;
  double v63;
  __int16 v64;
  uint64_t v65;
  __int16 v66;
  uint64_t v67;
  uint64_t v68;

  v68 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v4 = 0;
    v5 = 0;
    LOWORD(v6) = 0;
    v7 = 0.0;
    v8 = 64;
    v9 = 0.0;
    v10 = a1;
    v11 = 0uLL;
    v12 = 0uLL;
    do
    {
      v12 = vaddq_s64(*(int64x2_t *)(v10 + 40), v12);
      v11 = vaddq_s64(*(int64x2_t *)(v10 + 24), v11);
      v4 += *(_QWORD *)(v10 + 56);
      v5 += *(_QWORD *)(v10 + 64);
      if (*(unsigned __int16 *)(v10 + 72) <= (unsigned __int16)v6)
        v6 = (unsigned __int16)v6;
      else
        v6 = *(unsigned __int16 *)(v10 + 72);
      v13 = *(double *)(v10 + 16480);
      v14 = *(double *)(v10 + 16488);
      *(_QWORD *)(v10 + 16480) = 0;
      *(_OWORD *)(v10 + 40) = 0uLL;
      *(_OWORD *)(v10 + 24) = 0uLL;
      *(_OWORD *)(v10 + 56) = 0uLL;
      *(_WORD *)(v10 + 72) = 0;
      v10 += 16480;
      v7 = v7 + v13;
      v9 = v9 + v14;
      --v8;
    }
    while (v8);
    v34 = v11.i64[0];
    valuePtr = v11.i32[0];
    v15 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v35 = v11.i64[1];
    v36 = v12;
    v16 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &valuePtr);
    CFDictionaryAddValue(a2, CFSTR("UNRPC"), v16);
    CFRelease(v16);
    valuePtr = v35;
    v17 = CFNumberCreate(v15, kCFNumberIntType, &valuePtr);
    CFDictionaryAddValue(a2, CFSTR("UNFPC"), v17);
    CFRelease(v17);
    valuePtr = v36.i32[0];
    v18 = CFNumberCreate(v15, kCFNumberIntType, &valuePtr);
    CFDictionaryAddValue(a2, CFSTR("UNCHPC"), v18);
    CFRelease(v18);
    valuePtr = v36.u32[2];
    v19 = CFNumberCreate(v15, kCFNumberIntType, &valuePtr);
    CFDictionaryAddValue(a2, CFSTR("UNCMPC"), v19);
    CFRelease(v19);
    valuePtr = v4;
    v20 = CFNumberCreate(v15, kCFNumberIntType, &valuePtr);
    CFDictionaryAddValue(a2, CFSTR("UNTRC"), v20);
    CFRelease(v20);
    valuePtr = v5;
    v21 = CFNumberCreate(v15, kCFNumberIntType, &valuePtr);
    CFDictionaryAddValue(a2, CFSTR("UNRRC"), v21);
    CFRelease(v21);
    valuePtr = v6;
    v22 = CFNumberCreate(v15, kCFNumberIntType, &valuePtr);
    CFDictionaryAddValue(a2, CFSTR("UNRRMC"), v22);
    CFRelease(v22);
    v23 = 0.0;
    if (v36.i64[0])
      v24 = v7 / (double)v36.u64[0];
    else
      v24 = 0.0;
    *(float *)&v25 = v24;
    valuePtr = v25;
    v26 = CFNumberCreate(v15, kCFNumberFloat32Type, &valuePtr);
    CFDictionaryAddValue(a2, CFSTR("UNART"), v26);
    CFRelease(v26);
    if (v36.i64[1])
      v23 = v9 / (double)v36.u64[1];
    *(float *)&v27 = v23;
    valuePtr = v27;
    v28 = CFNumberCreate(v15, kCFNumberFloat32Type, &valuePtr);
    CFDictionaryAddValue(a2, CFSTR("UNALT"), v28);
    CFRelease(v28);
    v37 = 0uLL;
    LODWORD(v29) = *(_DWORD *)(a1 + 1054768);
    if ((_VCNACKConsumer_GetBitrate(a1, (double *)&v37 + 1, (double *)&v37, (double)v29) & 0x80000000) == 0)
    {
      valuePtr = (*((double *)&v37 + 1) / 1000.0 + 0.5);
      v30 = CFNumberCreate(v15, kCFNumberIntType, &valuePtr);
      CFDictionaryAddValue(a2, CFSTR("UNMB"), v30);
      CFRelease(v30);
      valuePtr = (*(double *)&v37 / 1000.0 + 0.5);
      v31 = CFNumberCreate(v15, kCFNumberIntType, &valuePtr);
      CFDictionaryAddValue(a2, CFSTR("UNRB"), v31);
      CFRelease(v31);
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      v32 = VRTraceErrorLogLevelToCSTR();
      v33 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        valuePtr = 136318722;
        v39 = v32;
        v40 = 2080;
        v41 = "VCNACKConsumer_GetStatistics";
        v42 = 1024;
        v43 = 442;
        v44 = 2048;
        v45 = a1;
        v46 = 2048;
        v47 = v34;
        v48 = 2048;
        v49 = v35;
        v50 = 2048;
        v51 = v36.i64[0];
        v52 = 2048;
        v53 = v36.i64[1];
        v54 = 2048;
        v55 = v4;
        v56 = 2048;
        v57 = v5;
        v58 = 1024;
        v59 = v6;
        v60 = 2048;
        v61 = v24;
        v62 = 2048;
        v63 = v23;
        v64 = 2048;
        v65 = *((_QWORD *)&v37 + 1);
        v66 = 2048;
        v67 = v37;
        _os_log_impl(&dword_1D8A54000, v33, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d @=@ Health: VCNACKConsumer [%p] RTX health report retransmissionRequestPacketCount=%llu retransmissionFulfilledPacketCount=%llu aggregatedRetransmissionCacheHitCount=%llu aggregatedRetransmissionCacheMissCount=%llu aggregatedRetransmissionNACKReceivedCount=%llu aggregatedRetransmissionRepeatedRequestCount=%llu retransmissionRepeatedRequestMaxCount=%u averageResponseTime=%f averageLateTime=%f mediaBitrate=%f retransmittedBitrate=%f", (uint8_t *)&valuePtr, 0x90u);
      }
    }
  }
}

void _VCNACKConsumer_Init(uint64_t a1)
{
  _QWORD *v1;

  v1 = (_QWORD *)(a1 + 1054736);
  bzero((void *)(a1 + 16), 0x101828uLL);
  *v1 = 0xFFFFFFFFLL;
  v1[1] = 0xFFFFFFFFLL;
}

