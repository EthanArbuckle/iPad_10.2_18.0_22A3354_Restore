uint64_t _VCNACKConsumer_ComputeSummerBitrate(uint64_t a1, double *a2, double a3)
{
  uint64_t result;
  double v5[2];

  v5[1] = *(double *)MEMORY[0x1E0C80C00];
  *a2 = 0.0;
  if (a1 == 0xFFFFFFFFLL)
    return 2149515266;
  v5[0] = NAN;
  result = SummerSumPred(a3, 0.0, a1, (unsigned int (*)(double, double, double))SummerGreaterThan, (double (*)(double, double, double))SummerIdentity, v5, a2);
  if ((result & 0x80000000) == 0 && v5[0] >= 0.5)
    *a2 = *a2 * 8.0 / v5[0];
  return result;
}

__int16 *VADD_Q15_Portable(__int16 *result, __int16 *a2, __int16 *a3, int a4)
{
  int v4;
  int v5;
  int v6;
  int v7;
  __int16 v8;
  __int16 v9;
  __int16 v10;

  for (; a4; --a4)
  {
    v5 = *result++;
    v4 = v5;
    v6 = *a2++;
    v7 = v6 + v4;
    if (v7 >= 0x7FFF)
      v8 = 0x7FFF;
    else
      v8 = v7;
    if (v7 <= -32768)
      v9 = 0x8000;
    else
      v9 = v7;
    if (v7 <= 0)
      v10 = v9;
    else
      v10 = v8;
    *a3++ = v10;
  }
  return result;
}

__int16 *VSMUL_Q15_Portable(__int16 *result, int a2, _WORD *a3, int a4)
{
  int v4;

  for (; a4; --a4)
  {
    v4 = *result++;
    *a3++ = (v4 * a2) >> 15;
  }
  return result;
}

__int16 *SVESQ_Q15_Portable(__int16 *result, int a2, _DWORD *a3, char a4)
{
  int i;
  int v5;

  for (i = 0; a2; --a2)
  {
    v5 = *result++;
    i += (v5 * v5) >> (a4 - 1);
  }
  *a3 = i;
  return result;
}

void _FECUtil_SetupFECHeaderV0(int a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, _QWORD *a7, int a8, __int16 a9, __int16 a10, char a11, uint64_t a12, uint64_t a13)
{
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  NSObject *v22;
  NSObject *v23;
  int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  NSObject *v28;
  NSObject *v29;
  int v30;
  int v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  uint8_t buf[4];
  uint64_t v36;
  __int16 v37;
  const char *v38;
  __int16 v39;
  int v40;
  __int16 v41;
  int v42;
  __int16 v43;
  int v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v34 = 0;
  v33 = 0;
  if (RSU_Encode(a6, (__int16 *)(a4 + 12), a5, a7, (_DWORD *)(a2 + 12016), (_DWORD *)&v34 + 1, (int *)&v34, &v33, 0, 0))
  {
    *(_DWORD *)a4 = 0;
  }
  else
  {
    v32 = a2;
    if (a5 >= 1)
    {
      v19 = 0;
      v20 = a3 + 4 * a8;
      do
      {
        *(_DWORD *)(a12 + 4 * v19) = ((a11 & 0x7F) << 16) | 0x800000 | (((a1 << 6) | (8 * (_DWORD)v34) | ((_BYTE)v33 + (_BYTE)v34 * (_BYTE)v19) & 7) << 24) | *(_DWORD *)(v20 + 4 * v19) & 0x1FFF | (unsigned __int16)((a9 << 15) | ((_WORD)v33 << 11));
        if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          v21 = VRTraceErrorLogLevelToCSTR();
          v22 = *MEMORY[0x1E0CF2758];
          v23 = *MEMORY[0x1E0CF2758];
          if (*MEMORY[0x1E0CF2748])
          {
            if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
            {
              v24 = *(_DWORD *)(a12 + 4 * v19);
              *(_DWORD *)buf = 136316162;
              v36 = v21;
              v37 = 2080;
              v38 = "_FECUtil_SetupFECHeaderV0";
              v39 = 1024;
              v40 = 73;
              v41 = 1024;
              v42 = v19;
              v43 = 1024;
              v44 = v24;
              _os_log_impl(&dword_1D8A54000, v22, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Setup FEC Main header (data packet %d) = %08x", buf, 0x28u);
            }
          }
          else if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
          {
            v25 = *(_DWORD *)(a12 + 4 * v19);
            *(_DWORD *)buf = 136316162;
            v36 = v21;
            v37 = 2080;
            v38 = "_FECUtil_SetupFECHeaderV0";
            v39 = 1024;
            v40 = 73;
            v41 = 1024;
            v42 = v19;
            v43 = 1024;
            v44 = v25;
            _os_log_debug_impl(&dword_1D8A54000, v22, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Setup FEC Main header (data packet %d) = %08x", buf, 0x28u);
          }
        }
        ++v19;
      }
      while (a5 != v19);
    }
    if (SHIDWORD(v34) >= 1)
    {
      v26 = 0;
      do
      {
        *(_DWORD *)(a13 + 4 * v26) = ((a11 & 0x7F) << 16) | (((a1 << 6) | (8 * (_DWORD)v34) | ((_BYTE)v34 * (_BYTE)v26) & 7) << 24) | *(_DWORD *)(v32 + 12016 + 4 * v26) & 0x1FFF | (unsigned __int16)((a9 << 15) | ((_WORD)v33 << 11));
        if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          v27 = VRTraceErrorLogLevelToCSTR();
          v28 = *MEMORY[0x1E0CF2758];
          v29 = *MEMORY[0x1E0CF2758];
          if (*MEMORY[0x1E0CF2748])
          {
            if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
            {
              v30 = *(_DWORD *)(a12 + 4 * v26);
              *(_DWORD *)buf = 136316162;
              v36 = v27;
              v37 = 2080;
              v38 = "_FECUtil_SetupFECHeaderV0";
              v39 = 1024;
              v40 = 84;
              v41 = 1024;
              v42 = v26;
              v43 = 1024;
              v44 = v30;
              _os_log_impl(&dword_1D8A54000, v28, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Setup FEC Main header (parity packet %d) = %08x", buf, 0x28u);
            }
          }
          else if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
          {
            v31 = *(_DWORD *)(a12 + 4 * v26);
            *(_DWORD *)buf = 136316162;
            v36 = v27;
            v37 = 2080;
            v38 = "_FECUtil_SetupFECHeaderV0";
            v39 = 1024;
            v40 = 84;
            v41 = 1024;
            v42 = v26;
            v43 = 1024;
            v44 = v31;
            _os_log_debug_impl(&dword_1D8A54000, v28, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Setup FEC Main header (parity packet %d) = %08x", buf, 0x28u);
          }
        }
        ++v26;
      }
      while (v26 < SHIDWORD(v34));
    }
  }
}

void _FECUtil_SetupFECHeaderV1(int a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, unsigned int a6, uint64_t a7, _QWORD *a8, int a9, __int16 a10, __int16 a11, char a12, uint64_t a13, uint64_t a14)
{
  int v18;
  uint64_t v19;
  uint64_t v20;
  NSObject *v21;
  NSObject *v22;
  int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  NSObject *v27;
  NSObject *v28;
  int v29;
  int v30;
  int v31;
  uint64_t v32;
  uint8_t buf[4];
  uint64_t v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  int v38;
  __int16 v39;
  int v40;
  __int16 v41;
  int v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v32 = 0;
  v31 = 0;
  if (RSU_Encode(a7, (__int16 *)(a4 + 12), a5, a8, (_DWORD *)(a2 + 12016), (_DWORD *)&v32 + 1, (int *)&v32, &v31, (_WORD *)(a2 + 12044), 1))
  {
    *(_DWORD *)a4 = 0;
  }
  else
  {
    v18 = a1 << 7;
    if (a5 >= 1)
    {
      v19 = 0;
      do
      {
        *(_DWORD *)(a13 + 4 * v19) = (unsigned __int16)((a10 << 14) | ((_WORD)v31 << 10)) | FECUtil_FECLevelofProtectionToFECPercentage(a6) | ((a12 & 0x7F) << 15) | 0x400000 | ((((_BYTE)v31 + (_BYTE)v32 * (_BYTE)v19) & 0xF | v18 | (16 * (_DWORD)v32)) << 23);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          v20 = VRTraceErrorLogLevelToCSTR();
          v21 = *MEMORY[0x1E0CF2758];
          v22 = *MEMORY[0x1E0CF2758];
          if (*MEMORY[0x1E0CF2748])
          {
            if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
            {
              v23 = *(_DWORD *)(a13 + 4 * v19);
              *(_DWORD *)buf = 136316162;
              v34 = v20;
              v35 = 2080;
              v36 = "_FECUtil_SetupFECHeaderV1";
              v37 = 1024;
              v38 = 124;
              v39 = 1024;
              v40 = v19;
              v41 = 1024;
              v42 = v23;
              _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Setup FEC Main header (data packet %d) = %08x", buf, 0x28u);
            }
          }
          else if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
          {
            v24 = *(_DWORD *)(a13 + 4 * v19);
            *(_DWORD *)buf = 136316162;
            v34 = v20;
            v35 = 2080;
            v36 = "_FECUtil_SetupFECHeaderV1";
            v37 = 1024;
            v38 = 124;
            v39 = 1024;
            v40 = v19;
            v41 = 1024;
            v42 = v24;
            _os_log_debug_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Setup FEC Main header (data packet %d) = %08x", buf, 0x28u);
          }
        }
        ++v19;
      }
      while (a5 != v19);
    }
    if (SHIDWORD(v32) >= 1)
    {
      v25 = 0;
      do
      {
        *(_DWORD *)(a14 + 4 * v25) = (unsigned __int16)((a10 << 14) | ((_WORD)v31 << 10)) | FECUtil_FECLevelofProtectionToFECPercentage(a6) | ((a12 & 0x7F) << 15) | ((v18 & 0xF0 | (16 * v32) | ((_BYTE)v32 * (_BYTE)v25) & 0xF) << 23);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          v26 = VRTraceErrorLogLevelToCSTR();
          v27 = *MEMORY[0x1E0CF2758];
          v28 = *MEMORY[0x1E0CF2758];
          if (*MEMORY[0x1E0CF2748])
          {
            if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
            {
              v29 = *(_DWORD *)(a13 + 4 * v25);
              *(_DWORD *)buf = 136316162;
              v34 = v26;
              v35 = 2080;
              v36 = "_FECUtil_SetupFECHeaderV1";
              v37 = 1024;
              v38 = 135;
              v39 = 1024;
              v40 = v25;
              v41 = 1024;
              v42 = v29;
              _os_log_impl(&dword_1D8A54000, v27, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Setup FEC Main header (parity packet %d) = %08x", buf, 0x28u);
            }
          }
          else if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
          {
            v30 = *(_DWORD *)(a13 + 4 * v25);
            *(_DWORD *)buf = 136316162;
            v34 = v26;
            v35 = 2080;
            v36 = "_FECUtil_SetupFECHeaderV1";
            v37 = 1024;
            v38 = 135;
            v39 = 1024;
            v40 = v25;
            v41 = 1024;
            v42 = v30;
            _os_log_debug_impl(&dword_1D8A54000, v27, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Setup FEC Main header (parity packet %d) = %08x", buf, 0x28u);
          }
        }
        ++v25;
      }
      while (v25 < SHIDWORD(v32));
    }
  }
}

uint64_t FECUtil_FECLevelofProtectionToFECPercentage(unsigned int a1)
{
  uint64_t v3;
  NSObject *v4;
  int v5;
  uint64_t v6;
  __int16 v7;
  const char *v8;
  __int16 v9;
  int v10;
  __int16 v11;
  unsigned int v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (a1 < 6)
    return dword_1D910B6C8[a1];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v3 = VRTraceErrorLogLevelToCSTR();
    v4 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v5 = 136315906;
      v6 = v3;
      v7 = 2080;
      v8 = "FECUtil_FECLevelofProtectionToFECPercentage";
      v9 = 1024;
      v10 = 550;
      v11 = 1024;
      v12 = a1;
      _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Unsupported iFECLevelOfProtection: %d", (uint8_t *)&v5, 0x22u);
    }
  }
  return 1;
}

void FECUtil_SetupFECHeader(int a1, uint64_t a2, uint64_t a3, _DWORD *a4, unsigned int a5, signed int a6, uint64_t a7, int a8, __int16 a9, __int16 a10, char a11, uint64_t a12, uint64_t a13)
{
  uint64_t v13;
  __int128 v14;
  int *v15;
  int *v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  _OWORD v23[3];
  unint64_t v24;
  uint64_t v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  unint64_t v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (a5 - 2 <= 6 && a6 >= 1)
  {
    v13 = 0;
    v29 = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)&v14 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v27 = v14;
    v28 = v14;
    v26 = v14;
    v24 = 0xAAAAAAAAAAAAAAAALL;
    v25 = a7;
    v23[1] = v14;
    v23[2] = v14;
    *a4 = 1;
    a4[1] = a1;
    a4[11] = a5;
    v15 = (int *)(a3 + 4 * a8);
    v17 = *v15;
    v16 = v15 + 1;
    v23[0] = v14;
    a4[3] = v17;
    do
    {
      v18 = *(v16 - 1);
      v19 = *v16++;
      a7 += v18;
      *(&v25 + v13 + 1) = a7;
      a4[v13++ + 4] = v19;
    }
    while (a5 - 1 != v13);
    v20 = 0;
    v21 = a2 + 16;
    do
    {
      *(_QWORD *)((char *)v23 + v20) = v21;
      v20 += 8;
      v21 += 1500;
    }
    while (v20 != 56);
    if (a1 == 1)
    {
      _FECUtil_SetupFECHeaderV1(1, a2, a3, (uint64_t)a4, a5, a6, (uint64_t)&v25, v23, v22, a9, a10, a11, a12, a13);
    }
    else if (a1)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          FECUtil_SetupFECHeader_cold_1();
      }
    }
    else
    {
      _FECUtil_SetupFECHeaderV0(0, a2, a3, (uint64_t)a4, a5, (uint64_t)&v25, v23, a8, a9, a10, a11, a12, a13);
    }
  }
}

void _FECHeader_UnpackV0ParitySubHeaderFromBuffer(_DWORD *a1, unsigned __int16 *a2, unint64_t a3)
{
  unsigned int v4;
  unsigned int v5;
  int *v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  int v11;
  int v12;
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (a1 && a2)
  {
    if (a3 > 1)
    {
      v4 = *a2;
      v5 = __rev16(v4);
      a1[11] = v5;
      v6 = a1 + 11;
      if (v5 < 9)
      {
        if (a3 - 2 >= 2 * (unint64_t)v5)
        {
          if (v4)
          {
            v7 = 0;
            do
            {
              a1[v7 + 3] = bswap32(a2[v7 + 1]) >> 16;
              ++v7;
            }
            while (v7 < *v6);
          }
          if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            v8 = VRTraceErrorLogLevelToCSTR();
            v9 = *MEMORY[0x1E0CF2758];
            v10 = *MEMORY[0x1E0CF2758];
            if (*MEMORY[0x1E0CF2748])
            {
              if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
              {
                v11 = *v6;
                v12 = 136315906;
                v13 = v8;
                v14 = 2080;
                v15 = "_FECHeader_UnpackV0ParitySubHeaderFromBuffer";
                v16 = 1024;
                v17 = 211;
                v18 = 1024;
                v19 = v11;
                _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Unpack legacy parity subheader wNumPkt=%d", (uint8_t *)&v12, 0x22u);
              }
            }
            else if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
            {
              _FECHeader_UnpackV0ParitySubHeaderFromBuffer_cold_5();
            }
          }
        }
        else
        {
          *v6 = 0;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              _FECHeader_UnpackV0ParitySubHeaderFromBuffer_cold_4();
          }
        }
      }
      else
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _FECHeader_UnpackV0ParitySubHeaderFromBuffer_cold_3();
        }
        *a1 = 0;
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _FECHeader_UnpackV0ParitySubHeaderFromBuffer_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _FECHeader_UnpackV0ParitySubHeaderFromBuffer_cold_1();
  }
}

void _FECHeader_UnpackV1ParitySubHeaderFromBuffer(uint64_t a1, unsigned __int16 *a2, unint64_t a3)
{
  unsigned int v4;
  unsigned int v5;
  int v6;
  uint64_t v7;
  NSObject *v8;
  NSObject *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (a1 && a2)
  {
    v4 = *(_DWORD *)(a1 + 8);
    v5 = (v4 >> 27) & 7;
    if (v5)
    {
      if (v4 >> 30)
        v6 = (v4 >> 10) & 0xF;
      else
        v6 = (v4 >> 11) & 7;
      *(_DWORD *)(a1 + 44) = (8 - v6) / v5;
      if (a3 > 1)
      {
        *(_WORD *)(a1 + 52) = bswap32(*a2) >> 16;
        if (a3 - 2 > 1)
        {
          *(_WORD *)(a1 + 54) = bswap32(a2[1]) >> 16;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            v7 = VRTraceErrorLogLevelToCSTR();
            v8 = *MEMORY[0x1E0CF2758];
            v9 = *MEMORY[0x1E0CF2758];
            if (*MEMORY[0x1E0CF2748])
            {
              if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
              {
                v10 = *(unsigned __int16 *)(a1 + 52);
                v11 = *(unsigned __int16 *)(a1 + 54);
                v14 = 136316162;
                v15 = v7;
                v16 = 2080;
                v17 = "_FECHeader_UnpackV1ParitySubHeaderFromBuffer";
                v18 = 1024;
                v19 = 246;
                v20 = 1024;
                v21 = v10;
                v22 = 1024;
                v23 = v11;
                _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Unpack parity subheader redundantBitsForPayloadSize=%d, paritySequenceNumber=%d", (uint8_t *)&v14, 0x28u);
              }
            }
            else if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
            {
              v12 = *(unsigned __int16 *)(a1 + 52);
              v13 = *(unsigned __int16 *)(a1 + 54);
              v14 = 136316162;
              v15 = v7;
              v16 = 2080;
              v17 = "_FECHeader_UnpackV1ParitySubHeaderFromBuffer";
              v18 = 1024;
              v19 = 246;
              v20 = 1024;
              v21 = v12;
              v22 = 1024;
              v23 = v13;
              _os_log_debug_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Unpack parity subheader redundantBitsForPayloadSize=%d, paritySequenceNumber=%d", (uint8_t *)&v14, 0x28u);
            }
          }
        }
        else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _FECHeader_UnpackV1ParitySubHeaderFromBuffer_cold_4();
        }
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _FECHeader_UnpackV1ParitySubHeaderFromBuffer_cold_3();
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _FECHeader_UnpackV1ParitySubHeaderFromBuffer_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _FECHeader_UnpackV1ParitySubHeaderFromBuffer_cold_1();
  }
}

void FECHeader_UnpackHeaderFromBuffer(_DWORD *a1, int a2, unsigned int *a3, unint64_t a4)
{
  unsigned __int16 *v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  int v11;
  uint64_t v12;
  NSObject *v13;
  int v14;
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  __int16 v22;
  unsigned int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (a1 && a3)
  {
    if (a4 <= 3)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          FECHeader_UnpackHeaderFromBuffer_cold_2();
      }
      return;
    }
    v7 = *a3;
    v6 = (unsigned __int16 *)(a3 + 1);
    v8 = bswap32(v7);
    a1[2] = v8;
    *a1 = 1;
    v9 = v8 >> 30;
    if (v8 >> 30)
      v10 = 0x400000;
    else
      v10 = 0x800000;
    if (v9 != a2)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v12 = VRTraceErrorLogLevelToCSTR();
        v13 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v14 = 136316162;
          v15 = v12;
          v16 = 2080;
          v17 = "FECHeader_UnpackHeaderFromBuffer";
          v18 = 1024;
          v19 = 271;
          v20 = 1024;
          v21 = a2;
          v22 = 1024;
          v23 = v9;
          _os_log_error_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_ERROR, " [%s] %s:%d FEC Header version mismatch expected %d, but got %d", (uint8_t *)&v14, 0x28u);
        }
      }
      goto LABEL_26;
    }
    v11 = v10 & v8;
    if (a2 != 1)
    {
      if (!a2)
      {
        if (!v11)
          _FECHeader_UnpackV0ParitySubHeaderFromBuffer(a1, v6, a4 - 4);
        return;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          FECHeader_UnpackHeaderFromBuffer_cold_3();
      }
LABEL_26:
      *a1 = 0;
      return;
    }
    if (!v11)
      _FECHeader_UnpackV1ParitySubHeaderFromBuffer((uint64_t)a1, v6, a4 - 4);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      FECHeader_UnpackHeaderFromBuffer_cold_1();
  }
}

void _FECHeader_PackV0ParitySubHeaderToBuffer(uint64_t a1, _WORD *a2, unint64_t a3, _QWORD *a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  __int16 v22;
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (a1 && a2 && a4)
  {
    if (a3 > 1)
    {
      *a2 = bswap32(*(unsigned __int16 *)(a1 + 44)) >> 16;
      v6 = *(int *)(a1 + 44);
      if (a3 - 2 >= 2 * v6)
      {
        if ((int)v6 >= 1)
        {
          v7 = 0;
          do
          {
            a2[v7 + 1] = bswap32(*(_DWORD *)(a1 + 12 + 4 * v7)) >> 16;
            ++v7;
          }
          while (v7 < *(int *)(a1 + 44));
          LODWORD(v6) = *(_DWORD *)(a1 + 44);
        }
        v8 = (int)(((2 * (v6 + ((int)v6 < 0))) & 0xFFFFFFFC) + 4);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          v9 = VRTraceErrorLogLevelToCSTR();
          v10 = *MEMORY[0x1E0CF2758];
          v11 = *MEMORY[0x1E0CF2758];
          if (*MEMORY[0x1E0CF2748])
          {
            if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
            {
              v12 = *(_DWORD *)(a1 + 44);
              v14 = 136316162;
              v15 = v9;
              v16 = 2080;
              v17 = "_FECHeader_PackV0ParitySubHeaderToBuffer";
              v18 = 1024;
              v19 = 362;
              v20 = 1024;
              v21 = v12;
              v22 = 2048;
              v23 = v8;
              _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Pack legacy parity sub header wPktLen=%d, length=%ld", (uint8_t *)&v14, 0x2Cu);
            }
          }
          else if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
          {
            v13 = *(_DWORD *)(a1 + 44);
            v14 = 136316162;
            v15 = v9;
            v16 = 2080;
            v17 = "_FECHeader_PackV0ParitySubHeaderToBuffer";
            v18 = 1024;
            v19 = 362;
            v20 = 1024;
            v21 = v13;
            v22 = 2048;
            v23 = v8;
            _os_log_debug_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Pack legacy parity sub header wPktLen=%d, length=%ld", (uint8_t *)&v14, 0x2Cu);
          }
        }
        *a4 += v8;
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _FECHeader_PackV0ParitySubHeaderToBuffer_cold_3();
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _FECHeader_PackV0ParitySubHeaderToBuffer_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _FECHeader_PackV0ParitySubHeaderToBuffer_cold_1();
  }
}

void _FECHeader_PackV1ParitySubHeaderToBuffer(uint64_t a1, _WORD *a2, unint64_t a3, _QWORD *a4)
{
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (a1 && a2 && a4)
  {
    if (a3 > 1)
    {
      *a2 = bswap32(*(unsigned __int16 *)(a1 + 52)) >> 16;
      if (a3 - 2 > 1)
      {
        a2[1] = bswap32(*(unsigned __int16 *)(a1 + 54)) >> 16;
        *a4 += 4;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          v5 = VRTraceErrorLogLevelToCSTR();
          v6 = *MEMORY[0x1E0CF2758];
          v7 = *MEMORY[0x1E0CF2758];
          if (*MEMORY[0x1E0CF2748])
          {
            if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
            {
              v8 = *(unsigned __int16 *)(a1 + 52);
              v9 = *(unsigned __int16 *)(a1 + 54);
              v12 = 136316162;
              v13 = v5;
              v14 = 2080;
              v15 = "_FECHeader_PackV1ParitySubHeaderToBuffer";
              v16 = 1024;
              v17 = 400;
              v18 = 1024;
              v19 = v8;
              v20 = 1024;
              v21 = v9;
              _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Pack fec data sub header redundantBitsForPayloadSize=%d, paritySequenceNumber=%d", (uint8_t *)&v12, 0x28u);
            }
          }
          else if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
          {
            v10 = *(unsigned __int16 *)(a1 + 52);
            v11 = *(unsigned __int16 *)(a1 + 54);
            v12 = 136316162;
            v13 = v5;
            v14 = 2080;
            v15 = "_FECHeader_PackV1ParitySubHeaderToBuffer";
            v16 = 1024;
            v17 = 400;
            v18 = 1024;
            v19 = v10;
            v20 = 1024;
            v21 = v11;
            _os_log_debug_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Pack fec data sub header redundantBitsForPayloadSize=%d, paritySequenceNumber=%d", (uint8_t *)&v12, 0x28u);
          }
        }
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _FECHeader_PackV1ParitySubHeaderToBuffer_cold_3();
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _FECHeader_PackV1ParitySubHeaderToBuffer_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _FECHeader_PackV1ParitySubHeaderToBuffer_cold_1();
  }
}

void FECHeader_PackHeaderToBuffer(_DWORD *a1, int a2, _DWORD *a3, unint64_t a4, _QWORD *a5)
{
  _WORD *v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  int v10;
  _BOOL4 v11;
  _BOOL4 v12;
  uint64_t v13;
  NSObject *v14;
  int v15;
  uint64_t v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  __int16 v23;
  unsigned int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (a5 && (*a5 = 0, a1) && a3 && a4 > 0x23)
  {
    *a3 = bswap32(a1[2]);
    v6 = a3 + 1;
    *a5 += 4;
    v7 = a1[2];
    v8 = v7 >> 30;
    v9 = HIWORD(v7) & 0x80;
    v10 = v7 & 0x400000;
    if (!v8)
      v10 = v9;
    v11 = v10 == 0;
    if (*a1)
      v12 = v11;
    else
      v12 = 0;
    if (v8 == a2)
    {
      if (a2 == 1)
      {
        if (v12)
          _FECHeader_PackV1ParitySubHeaderToBuffer((uint64_t)a1, v6, a4 - 4, a5);
      }
      else if (a2)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            FECHeader_PackHeaderToBuffer_cold_2();
        }
      }
      else if (v12)
      {
        _FECHeader_PackV0ParitySubHeaderToBuffer((uint64_t)a1, v6, a4 - 4, a5);
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v13 = VRTraceErrorLogLevelToCSTR();
      v14 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v15 = 136316162;
        v16 = v13;
        v17 = 2080;
        v18 = "FECHeader_PackHeaderToBuffer";
        v19 = 1024;
        v20 = 424;
        v21 = 1024;
        v22 = a2;
        v23 = 1024;
        v24 = v8;
        _os_log_error_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_ERROR, " [%s] %s:%d FEC Header version mismatch expected %d, but got %d", (uint8_t *)&v15, 0x28u);
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      FECHeader_PackHeaderToBuffer_cold_1();
  }
}

uint64_t FECUtil_GetRealNumParity(int a1, uint64_t a2)
{
  unsigned int v2;
  unsigned int *v3;

  if ((_DWORD)a2)
  {
    v2 = a1 - 1;
    if ((_DWORD)a2 == 2)
    {
      if (v2 < 8)
      {
        v3 = (unsigned int *)&unk_1D910B700;
        return v3[v2];
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          FECUtil_GetRealNumParity_cold_3();
      }
    }
    else if ((_DWORD)a2 == 1)
    {
      if (v2 < 8)
      {
        v3 = (unsigned int *)&unk_1D910B6E0;
        return v3[v2];
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          FECUtil_GetRealNumParity_cold_2();
      }
    }
    else
    {
      if (v2 < 8)
      {
        v3 = (unsigned int *)&unk_1D910B720;
        return v3[v2];
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          FECUtil_GetRealNumParity_cold_1();
      }
    }
    return 0;
  }
  return a2;
}

float FECUtil_FECLevelofProtectionToRateRatio(int a1)
{
  float result;

  result = 1.0;
  if ((a1 - 1) <= 4)
    return flt_1D910B740[a1 - 1];
  return result;
}

uint64_t FECUtil_FECPercentageToLevelofProtection(unsigned int a1)
{
  int v1;
  int v2;
  int v3;
  unsigned int v4;

  if (a1 < 0xC9)
    v1 = 4;
  else
    v1 = 5;
  if (a1 >= 0x65)
    v2 = v1;
  else
    v2 = 3;
  if (a1 >= 0x33)
    v3 = v2;
  else
    v3 = 2;
  if ((int)a1 >= 26)
    v4 = v3;
  else
    v4 = 1;
  if (a1)
    return v4;
  else
    return 0;
}

uint64_t FECUtil_FECRatioToLevelofProtection(float a1)
{
  unsigned int v1;

  v1 = (int)(float)(a1 * 100.0);
  if (!v1)
    return 0;
  if ((int)v1 < 26)
    return 1;
  if (v1 < 0x33)
    return 2;
  if (v1 < 0x65)
    return 3;
  if (v1 < 0xC9)
    return 4;
  return 5;
}

uint64_t FECUtil_ParityGroupTransmissionCountForFECLevel(int a1)
{
  if ((a1 - 1) > 4)
    return 0;
  else
    return dword_1D910B754[a1 - 1];
}

uint64_t FECUtil_GetExpectedParityPacketCount(uint64_t a1)
{
  uint64_t result;

  if (*(_DWORD *)a1 == 1)
    return *(_DWORD *)(a1 + 8) - *(unsigned __int16 *)(a1 + 6) + 1;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    FECUtil_GetExpectedParityPacketCount_cold_1();
  }
  return 0;
}

void FECUtil_UpdateParitySequenceNumberHistory(uint64_t a1, unsigned int a2)
{
  int v2;

  if (a1)
  {
    if (*(_BYTE *)(a1 + 4))
    {
      v2 = *(_DWORD *)(a1 + 8);
      if (a2 != (unsigned __int16)v2 && (unsigned __int16)(a2 - v2) <= 0x7FFEu)
      {
        if (a2 < (unsigned __int16)v2)
          v2 += 0x10000;
        *(_DWORD *)(a1 + 8) = v2 & 0xFFFF0000 | a2;
      }
    }
    else
    {
      *(_BYTE *)(a1 + 4) = 1;
      *(_WORD *)(a1 + 6) = a2;
      *(_DWORD *)(a1 + 8) = a2;
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      FECUtil_UpdateParitySequenceNumberHistory_cold_1();
  }
}

uint64_t FECUtil_ConvertNumberOfSymbolsToPackets(uint64_t a1, unsigned int a2)
{
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  int v7;
  uint64_t v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  int v14;
  __int16 v15;
  unsigned int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v3 = a1;
    if (a1 < 9)
    {
      LODWORD(v3) = vcvtps_u32_f32((float)a1 / (float)a2);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v4 = VRTraceErrorLogLevelToCSTR();
      v5 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v7 = 136316162;
        v8 = v4;
        v9 = 2080;
        v10 = "FECUtil_ConvertNumberOfSymbolsToPackets";
        v11 = 1024;
        v12 = 706;
        v13 = 1024;
        v14 = v3;
        v15 = 1024;
        v16 = a2;
        _os_log_error_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_ERROR, " [%s] %s:%d Number of symbols is larger than supported. numberOfSymbols=%d symbolsPerPacket=%d", (uint8_t *)&v7, 0x28u);
      }
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        FECUtil_ConvertNumberOfSymbolsToPackets_cold_1();
    }
    return 0;
  }
  return v3;
}

void FECUtil_PackFrameLoss(_WORD *a1, int a2, int a3)
{
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    *a1 = a3 & 0x3F | ((a2 & 0x3F) << 6);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v6 = VRTraceErrorLogLevelToCSTR();
      v7 = *MEMORY[0x1E0CF2758];
      v8 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          v9 = (unsigned __int16)*a1;
          v11 = 136316418;
          v12 = v6;
          v13 = 2080;
          v14 = "FECUtil_PackFrameLoss";
          v15 = 1024;
          v16 = 720;
          v17 = 1024;
          v18 = v9;
          v19 = 1024;
          v20 = a2;
          v21 = 1024;
          v22 = a3;
          _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d FECv2 loss signal pack=%d size=%d loss=%d", (uint8_t *)&v11, 0x2Eu);
        }
      }
      else if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        v10 = (unsigned __int16)*a1;
        v11 = 136316418;
        v12 = v6;
        v13 = 2080;
        v14 = "FECUtil_PackFrameLoss";
        v15 = 1024;
        v16 = 720;
        v17 = 1024;
        v18 = v10;
        v19 = 1024;
        v20 = a2;
        v21 = 1024;
        v22 = a3;
        _os_log_debug_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEBUG, " [%s] %s:%d FECv2 loss signal pack=%d size=%d loss=%d", (uint8_t *)&v11, 0x2Eu);
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      FECUtil_PackFrameLoss_cold_1();
  }
}

void FECUtil_UnpackFrameLoss(unsigned int a1, int *a2, int *a3)
{
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  unsigned int v20;
  __int16 v21;
  int v22;
  __int16 v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (a2 && a3)
  {
    *a2 = (a1 >> 6) & 0x3F;
    *a3 = a1 & 0x3F;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v6 = VRTraceErrorLogLevelToCSTR();
      v7 = *MEMORY[0x1E0CF2758];
      v8 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          v9 = *a2;
          v10 = *a3;
          v13 = 136316418;
          v14 = v6;
          v15 = 2080;
          v16 = "FECUtil_UnpackFrameLoss";
          v17 = 1024;
          v18 = 730;
          v19 = 1024;
          v20 = a1;
          v21 = 1024;
          v22 = v9;
          v23 = 1024;
          v24 = v10;
          _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d FECv2 loss signal unpack=%d size=%d loss=%d", (uint8_t *)&v13, 0x2Eu);
        }
      }
      else if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        v11 = *a2;
        v12 = *a3;
        v13 = 136316418;
        v14 = v6;
        v15 = 2080;
        v16 = "FECUtil_UnpackFrameLoss";
        v17 = 1024;
        v18 = 730;
        v19 = 1024;
        v20 = a1;
        v21 = 1024;
        v22 = v11;
        v23 = 1024;
        v24 = v12;
        _os_log_debug_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEBUG, " [%s] %s:%d FECv2 loss signal unpack=%d size=%d loss=%d", (uint8_t *)&v13, 0x2Eu);
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      FECUtil_UnpackFrameLoss_cold_1();
  }
}

__CFString *VCSessionMediaState_Name(uint64_t a1)
{
  if (a1 >= 3)
    return (__CFString *)objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("Unknown (%d)"), a1);
  else
    return off_1E9E54480[(int)a1];
}

uint64_t VCSessionMediaState_FromAVCSessionMediaState(uint64_t result)
{
  if (result >= 3)
    return 0xFFFFFFFFLL;
  else
    return result;
}

void VCMediaRecorderHistoryBuffer_UpdateBufferWithSample(uint64_t a1, const void *a2, int a3)
{
  int Count;
  int v7;
  const __CFArray *v8;
  int v9;
  const __CFNumber *ValueAtIndex;
  int v11;
  CFNumberRef v12;
  CFNumberRef v13;
  uint64_t v14;
  NSObject *v15;
  int v16;
  uint64_t v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a2)
    {
      Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 32));
      v7 = CFArrayGetCount(*(CFArrayRef *)(a1 + 24));
      if (v7 == Count)
      {
        if (*(_DWORD *)(a1 + 16) == Count)
          _VCMediaRecorderHistoryBuffer_DequeueOneFrame((const __CFArray **)a1);
        v16 = 0;
        v8 = *(const __CFArray **)(a1 + 24);
        v9 = CFArrayGetCount(v8);
        if (v9)
        {
          ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(v8, (v9 - 1));
          CFNumberGetValue(ValueAtIndex, kCFNumberIntType, &v16);
          v11 = v16;
        }
        else
        {
          v11 = 0;
        }
        if ((*(_DWORD *)(a1 + 40) - a3) > 0x7FFFFFFE)
        {
          if ((v11 - a3) > 0x7FFFFFFE)
          {
            *(_DWORD *)(a1 + 40) = a3;
LABEL_14:
            v16 = a3;
            v12 = CFNumberCreate(*(CFAllocatorRef *)(a1 + 48), kCFNumberIntType, &v16);
            if (v12)
            {
              v13 = v12;
              if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 32), v12))
              {
                if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                {
                  VRTraceErrorLogLevelToCSTR();
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                    VCMediaRecorderHistoryBuffer_UpdateBufferWithSample_cold_4();
                }
              }
              else
              {
                CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 24), v13);
                CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), v13, a2);
              }
              CFRelease(v13);
            }
            else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                VCMediaRecorderHistoryBuffer_UpdateBufferWithSample_cold_3();
            }
            return;
          }
          *(_DWORD *)(a1 + 40) = a3;
        }
        a3 = v11 + 480;
        goto LABEL_14;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v14 = VRTraceErrorLogLevelToCSTR();
        v15 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v16 = 136316162;
          v17 = v14;
          v18 = 2080;
          v19 = "VCMediaRecorderHistoryBuffer_UpdateBufferWithSample";
          v20 = 1024;
          v21 = 68;
          v22 = 1024;
          v23 = v7;
          v24 = 1024;
          v25 = Count;
          _os_log_error_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_ERROR, " [%s] %s:%d timestampQueue length=%u != sampleMap length=%u, sizes are inconsistent", (uint8_t *)&v16, 0x28u);
        }
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCMediaRecorderHistoryBuffer_UpdateBufferWithSample_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCMediaRecorderHistoryBuffer_UpdateBufferWithSample_cold_1();
  }
}

void _VCMediaRecorderHistoryBuffer_DequeueOneFrame(const __CFArray **a1)
{
  const __CFArray *v2;
  const void *ValueAtIndex;
  const void *Value;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  void *v8;
  unsigned int valuePtr;
  uint8_t buf[4];
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  const char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v2 = a1[3];
  if (CFArrayGetCount(v2))
  {
    ValueAtIndex = CFArrayGetValueAtIndex(v2, 0);
    CFRetain(ValueAtIndex);
    valuePtr = 0;
    CFNumberGetValue((CFNumberRef)ValueAtIndex, kCFNumberIntType, &valuePtr);
    CFArrayRemoveValueAtIndex(v2, 0);
    Value = CFDictionaryGetValue(a1[4], ValueAtIndex);
    if (!Value && (int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v6 = *MEMORY[0x1E0CF2758];
      v7 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315906;
          v11 = v5;
          v12 = 2080;
          v13 = "_VCMediaRecorderHistoryBuffer_DequeueOneFrame";
          v14 = 1024;
          v15 = 148;
          v16 = 2080;
          v17 = "void _VCMediaRecorderHistoryBuffer_DequeueOneFrame(VCMediaRecorderHistoryBuffer *)";
          _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCMediaRecorderHistoryBuffer %s the old frame does not in buffer, something is wrong", buf, 0x26u);
        }
      }
      else if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        _VCMediaRecorderHistoryBuffer_DequeueOneFrame_cold_1();
      }
    }
    v8 = (void *)objc_msgSend(a1, "delegate");
    objc_msgSend(v8, "historyBuffer:didDequeueSample:timestamp:", a1, Value, valuePtr);
    CFDictionaryRemoveValue(a1[4], ValueAtIndex);
    CFRelease(ValueAtIndex);
  }
}

uint64_t VCCarrierBundle_QueryCarrierBundleValueForKey(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  id v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  _QWORD v10[2];

  v2 = (uint64_t)a2;
  v10[1] = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    *a2 = 0;
    v4 = objc_alloc_init(MEMORY[0x1E0CA6E38]);
    v10[0] = 0;
    v5 = objc_msgSend(v4, "getCurrentDataSubscriptionContextSync:", v10);
    if (v5
      && (v6 = v5,
          v7 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CA6D00]), "initWithBundleType:", 1),
          v8 = objc_msgSend(v4, "copyCarrierBundleValueWithDefault:key:bundleType:error:", v6, a1, v7, v10),
          v7,
          v8))
    {
      *(_QWORD *)v2 = v8;
      v2 = 1;
    }
    else
    {
      v2 = 0;
    }

  }
  return v2;
}

uint64_t VCCarrierBundle_GetPSVoiceOnAPEnabled()
{
  id v0;
  void *v1;
  uint64_t v2;
  BOOL v3;
  uint64_t v4;
  BOOL v5;
  void *v6;
  uint64_t v8;
  NSObject *v9;
  int ErrorLogLevelForModule;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13[2];

  v13[1] = *MEMORY[0x1E0C80C00];
  v0 = objc_alloc_init(MEMORY[0x1E0CA6E38]);
  v1 = v0;
  if (v0)
  {
    v13[0] = 0;
    v2 = objc_msgSend(v0, "getCurrentDataSubscriptionContextSync:", v13);
    if (v2)
      v3 = v13[0] == 0;
    else
      v3 = 0;
    if (v3)
    {
      v4 = objc_msgSend(v1, "context:getCarrierBundleValue:error:", v2, &unk_1E9EF9BD8, v13);
      if (v4)
        v5 = v13[0] == 0;
      else
        v5 = 0;
      if (v5)
      {
        v6 = (void *)v4;

        return objc_msgSend(v6, "BOOLValue");
      }
    }
    else
    {
      ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
      if (ErrorLogLevelForModule >= 3)
      {
        v11 = VRTraceErrorLogLevelToCSTR();
        v12 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCCarrierBundle_GetPSVoiceOnAPEnabled_cold_2(v11, v13, v12);
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v8 = VRTraceErrorLogLevelToCSTR();
    v9 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCCarrierBundle_GetPSVoiceOnAPEnabled_cold_1(v8, v9);
  }

  return 0;
}

void _VCMediaStreamManager_UpdateFrequencyLevel(uint64_t a1, uint64_t a2, int a3)
{
  const char *v4;
  const __CFString *v5;
  id v6;

  if (a3)
    v4 = "vcMediaStreamUpdateInputFrequencyMetering";
  else
    v4 = "vcMediaStreamUpdateOutputFrequencyMetering";
  if (a3)
    v5 = CFSTR("vcMediaStreamInputFreqMetering");
  else
    v5 = CFSTR("vcMediaStreamOutputFreqMetering");
  v6 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D80]), "initWithObjectsAndKeys:", a2, v5, 0);
  objc_msgSend(+[AVConferenceXPCServer AVConferenceXPCServerSingleton](AVConferenceXPCServer, "AVConferenceXPCServerSingleton"), "sendMessageAsync:arguments:context:", v4, v6, a1);

}

void OUTLINED_FUNCTION_11_3(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, &a9, 0x1Cu);
}

uint64_t OUTLINED_FUNCTION_13_1@<X0>(uint64_t a1@<X8>)
{
  uint64_t v1;

  *(_QWORD *)(v1 - 24) = a1;
  return objc_opt_class();
}

uint64_t RTPPackGenericDataPacket(char *__src, _DWORD *a2, unsigned int a3, __int16 a4)
{
  size_t v5;
  char *v7;
  BOOL v8;
  BOOL v9;
  uint64_t v12;
  uint64_t v14;
  NSObject *v15;
  int v16;
  uint64_t v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  unsigned int v23;
  __int16 v24;
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v5 = *a2;
  if ((int)v5 + 8 > a3)
  {
    v12 = 2147549198;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v14 = VRTraceErrorLogLevelToCSTR();
      v15 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v16 = 136316162;
        v17 = v14;
        v18 = 2080;
        v19 = "RTPPackGenericDataPacket";
        v20 = 1024;
        v21 = 60;
        v22 = 1024;
        v23 = a3;
        v24 = 1024;
        v25 = v5 + 8;
        _os_log_error_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_ERROR, " [%s] %s:%d Data buffer is too small. currentSize=%u needed=%u", (uint8_t *)&v16, 0x28u);
      }
    }
  }
  else
  {
    v7 = __src + 8;
    if (v7 < __src
      || (v5 <= a3 ? (v8 = v7 > &__src[a3]) : (v8 = 1),
          !v8 ? (v9 = (unint64_t)a3 - 8 >= v5) : (v9 = 0),
          !v9 || (memmove(v7, __src, v5), a3 < 8)))
    {
      __break(0x5519u);
    }
    v12 = 0;
    *(_QWORD *)__src = ((_DWORD)v5 << 16) | ((unint64_t)(a4 & 0x7FFF) << 32);
    *a2 = v5 + 8;
  }
  return v12;
}

uint64_t RTPUnpackGenericDataPacket(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  unsigned __int16 *v4;
  size_t v6;
  OSStatus appended;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  int v14;
  size_t v15;
  uint8_t buf[4];
  uint64_t v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  unint64_t v23;
  __int16 v24;
  int v25;
  __int16 v26;
  size_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 8);
  **(_BYTE **)a2 = 1;
  **(_BYTE **)(a2 + 8) = 1;
  if (v2 < 8)
  {
    v8 = 2147549192;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v10 = VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        RTPUnpackGenericDataPacket_cold_1(v10);
        return 2147549192;
      }
    }
  }
  else
  {
    v3 = *(_QWORD *)(a1 + 16);
    v4 = (unsigned __int16 *)(v3 + 2);
    if (v3 + 2 >= v3 + *(_QWORD *)(a1 + 8) || (unint64_t)v4 < v3)
      __break(0x5519u);
    v6 = *v4;
    if (v2 < v6 + 8)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      {
        return 2147549199;
      }
      else
      {
        v14 = v6;
        v15 = v6 + 8;
        v11 = VRTraceErrorLogLevelToCSTR();
        v12 = *MEMORY[0x1E0CF2758];
        v8 = 2147549199;
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136316418;
          v17 = v11;
          v18 = 2080;
          v19 = "RTPUnpackGenericDataPacket";
          v20 = 1024;
          v21 = 88;
          v22 = 2048;
          v23 = v2;
          v24 = 1024;
          v25 = v14;
          v26 = 2048;
          v27 = v15;
          _os_log_error_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_ERROR, " [%s] %s:%d Invalid data length. inDataLength:%zu, payloadLength:%hu totalLength=%zu", buf, 0x36u);
        }
      }
    }
    else
    {
      appended = CMBlockBufferAppendBufferReference(*(CMBlockBufferRef *)(a2 + 48), *(CMBlockBufferRef *)a1, 8uLL, v6, 0);
      v8 = 0;
      if (appended)
      {
        v8 = 2147549187;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v13 = VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            RTPUnpackGenericDataPacket_cold_2(v13);
        }
      }
    }
  }
  return v8;
}

uint64_t VCMediaNegotiationBlobV2StreamGroupReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  int v15;
  char v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char v22;
  uint64_t result;
  VCMediaNegotiationBlobV2StreamGroupPayload *v24;
  VCMediaNegotiationBlobV2StreamGroupStream *v25;
  VCMediaNegotiationBlobV2SettingsU1 *v26;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) >= *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
    return *(_BYTE *)(a2 + *v5) == 0;
  v7 = (int *)MEMORY[0x1E0D82BB8];
  while (2)
  {
    if (*(_BYTE *)(a2 + *v5))
      return *(_BYTE *)(a2 + *v5) == 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v11 = *v3;
      v12 = *(_QWORD *)(a2 + v11);
      if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
        break;
      v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
      *(_QWORD *)(a2 + v11) = v12 + 1;
      v10 |= (unint64_t)(v13 & 0x7F) << v8;
      if ((v13 & 0x80) == 0)
        goto LABEL_12;
      v8 += 7;
      v14 = v9++ >= 9;
      if (v14)
      {
        v10 = 0;
        v15 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
    v15 = *(unsigned __int8 *)(a2 + *v5);
    if (*(_BYTE *)(a2 + *v5))
      v10 = 0;
LABEL_14:
    if (v15 || (v10 & 7) == 4)
      return *(_BYTE *)(a2 + *v5) == 0;
    switch((v10 >> 3))
    {
      case 1u:
        v17 = 0;
        v18 = 0;
        v19 = 0;
        *(_BYTE *)(a1 + 40) |= 1u;
        while (1)
        {
          v20 = *v3;
          v21 = *(_QWORD *)(a2 + v20);
          if (v21 == -1 || v21 >= *(_QWORD *)(a2 + *v4))
            break;
          v22 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v21);
          *(_QWORD *)(a2 + v20) = v21 + 1;
          v19 |= (unint64_t)(v22 & 0x7F) << v17;
          if ((v22 & 0x80) == 0)
            goto LABEL_38;
          v17 += 7;
          v14 = v18++ >= 9;
          if (v14)
          {
            LODWORD(v19) = 0;
            goto LABEL_40;
          }
        }
        *(_BYTE *)(a2 + *v5) = 1;
LABEL_38:
        if (*(_BYTE *)(a2 + *v5))
          LODWORD(v19) = 0;
LABEL_40:
        *(_DWORD *)(a1 + 24) = v19;
        goto LABEL_41;
      case 2u:
        v24 = objc_alloc_init(VCMediaNegotiationBlobV2StreamGroupPayload);
        objc_msgSend((id)a1, "addPayloads:", v24);

        if (!PBReaderPlaceMark()
          || (VCMediaNegotiationBlobV2StreamGroupPayloadReadFrom((uint64_t)v24, a2) & 1) == 0)
        {
          return 0;
        }
        goto LABEL_36;
      case 3u:
        v25 = objc_alloc_init(VCMediaNegotiationBlobV2StreamGroupStream);
        objc_msgSend((id)a1, "addStreams:", v25);

        if (PBReaderPlaceMark()
          && (VCMediaNegotiationBlobV2StreamGroupStreamReadFrom((uint64_t)v25, a2) & 1) != 0)
        {
          goto LABEL_36;
        }
        return 0;
      case 4u:
        v26 = objc_alloc_init(VCMediaNegotiationBlobV2SettingsU1);

        *(_QWORD *)(a1 + 16) = v26;
        if (PBReaderPlaceMark()
          && (VCMediaNegotiationBlobV2SettingsU1ReadFrom((uint64_t)v26, a2) & 1) != 0)
        {
LABEL_36:
          PBReaderRecallMark();
LABEL_41:
          if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
            return *(_BYTE *)(a2 + *v5) == 0;
          continue;
        }
        return 0;
      default:
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
        goto LABEL_41;
    }
  }
}

void _VideoPacketBuffer_ClearFrameList(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v5;

  v3 = *a2;
  if (*a2)
  {
    do
    {
      v5 = *(_QWORD *)(v3 + 112);
      *(_BYTE *)(v3 + 161) = _VideoPacketBuffer_IsFrameComplete(v3, 0);
      _VideoPacketBuffer_FreeFrame(a1, (_QWORD *)v3);
      v3 = v5;
    }
    while (v5);
  }
  *a2 = 0;
}

BOOL _VideoPacketBuffer_IsFrameComplete(uint64_t a1, _WORD *a2)
{
  unsigned __int16 *v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  _BYTE *v7;
  NSObject **v8;
  int v9;
  int v10;
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  int v14;
  unsigned __int16 *v15;
  int v16;
  int v17;
  uint64_t v18;
  NSObject *v19;
  NSObject *v20;
  _BOOL4 v21;
  _BOOL8 result;
  int v23;
  const char *v24;
  NSObject *v25;
  uint32_t v26;
  uint64_t v27;
  NSObject *v28;
  NSObject *v29;
  int ErrorLogLevelForModule;
  uint64_t v31;
  NSObject *v32;
  NSObject *v33;
  _BOOL4 v34;
  int v35;
  int v36;
  uint64_t v37;
  NSObject *v38;
  NSObject *v39;
  _BOOL4 v40;
  uint8_t buf[4];
  uint64_t v42;
  __int16 v43;
  const char *v44;
  __int16 v45;
  int v46;
  __int16 v47;
  int v48;
  __int16 v49;
  int v50;
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  v3 = *(unsigned __int16 **)(a1 + 96);
  if ((int)VRTraceGetErrorLogLevelForModule() < 8)
    goto LABEL_7;
  v4 = VRTraceErrorLogLevelToCSTR();
  v5 = *MEMORY[0x1E0CF2758];
  v6 = *MEMORY[0x1E0CF2758];
  if (!*MEMORY[0x1E0CF2748])
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      _VideoPacketBuffer_IsFrameComplete_cold_4();
      if (!v3)
        goto LABEL_44;
LABEL_8:
      if (*((_DWORD *)v3 + 2))
      {
        v7 = (_BYTE *)MEMORY[0x1E0CF2748];
        v8 = (NSObject **)MEMORY[0x1E0CF2758];
        do
        {
          if (a2)
          {
            v9 = *v3;
            v10 = v9 - (unsigned __int16)*a2;
            if (v10)
            {
              if ((unsigned __int16)v10 <= 0x7FFEu)
                *a2 = v9;
            }
          }
          if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            v11 = VRTraceErrorLogLevelToCSTR();
            v12 = *v8;
            v13 = *v8;
            if (*v7)
            {
              if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
              {
                v14 = *v3;
                *(_DWORD *)buf = 136315906;
                v42 = v11;
                v43 = 2080;
                v44 = "_VideoPacketBuffer_IsFrameComplete";
                v45 = 1024;
                v46 = 1770;
                v47 = 1024;
                v48 = v14;
                _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d Packet seq:%d", buf, 0x22u);
              }
            }
            else if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
            {
              v17 = *v3;
              *(_DWORD *)buf = 136315906;
              v42 = v11;
              v43 = 2080;
              v44 = "_VideoPacketBuffer_IsFrameComplete";
              v45 = 1024;
              v46 = 1770;
              v47 = 1024;
              v48 = v17;
              _os_log_debug_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEBUG, "VideoPacketBuffer [%s] %s:%d Packet seq:%d", buf, 0x22u);
            }
          }
          if (*((_DWORD *)v3 + 4))
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
            {
              v27 = VRTraceErrorLogLevelToCSTR();
              v28 = *v8;
              v29 = *v8;
              if (*v7)
              {
                if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 136315650;
                  v42 = v27;
                  v43 = 2080;
                  v44 = "_VideoPacketBuffer_IsFrameComplete";
                  v45 = 1024;
                  v46 = 1772;
                  _os_log_impl(&dword_1D8A54000, v28, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d END", buf, 0x1Cu);
                }
              }
              else if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
              {
                _VideoPacketBuffer_IsFrameComplete_cold_3();
              }
            }
            return 1;
          }
          v15 = (unsigned __int16 *)*((_QWORD *)v3 + 13);
          if (!v15)
            goto LABEL_44;
          v16 = *v3;
          v3 = (unsigned __int16 *)*((_QWORD *)v3 + 13);
        }
        while (*v15 - v16 < 2);
        ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
        if (ErrorLogLevelForModule < 8)
          return 0;
        v31 = VRTraceErrorLogLevelToCSTR();
        v32 = *v8;
        v33 = *v8;
        if (!*v7)
        {
          result = os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG);
          if (!result)
            return result;
          v36 = *v15;
          *(_DWORD *)buf = 136316162;
          v42 = v31;
          v43 = 2080;
          v44 = "_VideoPacketBuffer_IsFrameComplete";
          v45 = 1024;
          v46 = 1778;
          v47 = 1024;
          v48 = v16;
          v49 = 1024;
          v50 = v36;
          _os_log_debug_impl(&dword_1D8A54000, v32, OS_LOG_TYPE_DEBUG, "VideoPacketBuffer [%s] %s:%d Error! Missing middle frames, beforeSeq:%d afterSeq:%d", buf, 0x28u);
          return 0;
        }
        v34 = os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT);
        result = 0;
        if (!v34)
          return result;
        v35 = *v15;
        *(_DWORD *)buf = 136316162;
        v42 = v31;
        v43 = 2080;
        v44 = "_VideoPacketBuffer_IsFrameComplete";
        v45 = 1024;
        v46 = 1778;
        v47 = 1024;
        v48 = v16;
        v49 = 1024;
        v50 = v35;
        v24 = "VideoPacketBuffer [%s] %s:%d Error! Missing middle frames, beforeSeq:%d afterSeq:%d";
        v25 = v32;
        v26 = 40;
        goto LABEL_48;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v18 = VRTraceErrorLogLevelToCSTR();
        v19 = *MEMORY[0x1E0CF2758];
        v20 = *MEMORY[0x1E0CF2758];
        if (!*MEMORY[0x1E0CF2748])
        {
          result = os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG);
          if (!result)
            return result;
          _VideoPacketBuffer_IsFrameComplete_cold_2();
          return 0;
        }
        v21 = os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT);
        result = 0;
        if (!v21)
          return result;
        v23 = *v3;
        *(_DWORD *)buf = 136315906;
        v42 = v18;
        v43 = 2080;
        v44 = "_VideoPacketBuffer_IsFrameComplete";
        v45 = 1024;
        v46 = 1762;
        v47 = 1024;
        v48 = v23;
        v24 = "VideoPacketBuffer [%s] %s:%d Error! Missing inital frames, seq:%d";
        v25 = v19;
        v26 = 34;
        goto LABEL_48;
      }
      return 0;
    }
LABEL_7:
    if (!v3)
      goto LABEL_44;
    goto LABEL_8;
  }
  if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    goto LABEL_7;
  *(_DWORD *)buf = 136315650;
  v42 = v4;
  v43 = 2080;
  v44 = "_VideoPacketBuffer_IsFrameComplete";
  v45 = 1024;
  v46 = 1760;
  _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d BEGIN", buf, 0x1Cu);
  if (v3)
    goto LABEL_8;
LABEL_44:
  if ((int)VRTraceGetErrorLogLevelForModule() < 8)
    return 0;
  v37 = VRTraceErrorLogLevelToCSTR();
  v38 = *MEMORY[0x1E0CF2758];
  v39 = *MEMORY[0x1E0CF2758];
  if (*MEMORY[0x1E0CF2748])
  {
    v40 = os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v40)
      return result;
    *(_DWORD *)buf = 136315650;
    v42 = v37;
    v43 = 2080;
    v44 = "_VideoPacketBuffer_IsFrameComplete";
    v45 = 1024;
    v46 = 1782;
    v24 = "VideoPacketBuffer [%s] %s:%d Error! Missing end of frame";
    v25 = v38;
    v26 = 28;
LABEL_48:
    _os_log_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_DEFAULT, v24, buf, v26);
    return 0;
  }
  result = os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG);
  if (result)
  {
    _VideoPacketBuffer_IsFrameComplete_cold_1();
    return 0;
  }
  return result;
}

void _VideoPacketBuffer_FreeFrame(uint64_t a1, _QWORD *a2)
{
  OSQueueHead **v3;
  _QWORD *v4;
  char v5;
  void (*v6)(uint64_t, _DWORD *);
  __int16 v7;
  char v8;
  int v9;
  char v10;
  char v11;
  __int16 v12;
  uint64_t v13;
  char v14;
  uint64_t v15;
  _QWORD *v16;
  OSQueueHead *v17;
  _DWORD v18[3];
  __int16 v19;
  char v20;
  char v21;
  __int16 v22;
  char v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  char v27;
  __int16 v28;
  int v29;
  __int16 v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char v34;
  __int16 v35;
  char v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v3 = (OSQueueHead **)(a1 + 146016);
  v4 = (_QWORD *)a2[12];
  v5 = *((_BYTE *)a2 + 161);
  if (v5)
  {
    v6 = *(void (**)(uint64_t, _DWORD *))(a1 + 272);
    if (v6)
    {
      v7 = *(unsigned __int8 *)(a1 + 240);
      v8 = *((_BYTE *)a2 + 152);
      if (v8)
        v8 = *((_BYTE *)a2 + 153) == 0;
      v9 = *((_DWORD *)a2 + 3);
      v10 = *((_BYTE *)a2 + 120);
      v11 = *((_BYTE *)a2 + 149);
      v12 = *((_WORD *)a2 + 75);
      v13 = a2[3];
      if (*(_BYTE *)(a1 + 240))
      {
        v7 = *((_WORD *)a2 + 73);
        v14 = *((_BYTE *)a2 + 148);
      }
      else
      {
        v14 = 0;
      }
      v15 = *(_QWORD *)(a1 + 264);
      v18[0] = *(_DWORD *)a2;
      v18[1] = 0;
      v18[2] = v9;
      v19 = 0;
      v20 = v10;
      v21 = 0;
      v22 = v7;
      v23 = v14;
      v25 = 0;
      v24 = 0;
      v26 = 0;
      v27 = v11;
      v28 = v12;
      v29 = 0;
      v30 = 0;
      v31 = v13;
      v32 = 0;
      v33 = 0;
      v34 = v8;
      v35 = 0;
      v36 = v5;
      v38 = 0;
      v37 = 0;
      v39 = 0;
      v6(v15, v18);
    }
  }
  VCBlockBuffer_Clear((uint64_t)(a2 + 9));
  VCMemoryPool_Free(*v3, a2);
  if (v4)
  {
    do
    {
      v16 = (_QWORD *)v4[13];
      VCBlockBuffer_Clear((uint64_t)(v4 + 15));
      v17 = v3[1];
      if (v17)
        VCMemoryPool_Free(v17, v4);
      v4 = v16;
    }
    while (v16);
  }
}

unsigned __int16 *VideoPacketBuffer_Create(_QWORD *a1)
{
  _QWORD *v2;
  unsigned __int16 *v3;
  _QWORD *v4;
  void *v5;
  int v6;
  int v7;
  uint64_t v8;
  NSObject *v9;
  double v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  FILE **v17;
  OpaqueCMMemoryPool *v18;
  CFAllocatorRef Allocator;
  const __CFAllocator *v21;
  OpaqueCMMemoryPool *v22;
  CFAllocatorRef v23;
  const void *v24;
  const void *v25;
  char v26;
  unint64_t v27;
  _BYTE buf[22];
  __int16 v29;
  int v30;
  __int16 v31;
  unsigned __int16 *v32;
  __int16 v33;
  int v34;
  __int16 v35;
  int v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v2 = malloc_type_calloc(1uLL, 0x23AB8uLL, 0x10F004091FBC634uLL);
  v3 = (unsigned __int16 *)v2;
  if (!v2)
    return v3;
  v4 = v2 + 18241;
  memcpy(v2, a1, 0x160uLL);
  *((_QWORD *)v3 + 18250) = a1[2];
  if (*((_DWORD *)v3 + 56))
  {
    *((_QWORD *)v3 + 18249) = 0x10000;
    v5 = malloc_type_calloc(1uLL, 0x2000uLL, 0x100004077774924uLL);
  }
  else
  {
    v5 = 0;
  }
  *((_QWORD *)v3 + 18248) = v5;
  pthread_mutex_init((pthread_mutex_t *)(v3 + 176), 0);
  v6 = *v3;
  v7 = *((_DWORD *)v3 + 1);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v8 = VRTraceErrorLogLevelToCSTR();
    v9 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136316418;
      *(_QWORD *)&buf[4] = v8;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "VideoPacketBuffer_Reset";
      v29 = 1024;
      v30 = 514;
      v31 = 2048;
      v32 = v3;
      v33 = 1024;
      v34 = v6;
      v35 = 1024;
      v36 = v7;
      _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] wFirstSeqNumber:%d, dwFirstTimestamp=%d", buf, 0x32u);
    }
  }
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 176));
  _VideoPacketBuffer_FreeAllFrames((uint64_t)v3);
  *((_QWORD *)v3 + 18242) = 0;
  *((_DWORD *)v3 + 36491) = 0;
  *((_DWORD *)v3 + 104) = v7 - 1;
  v3[210] = v6 - 1;
  v10 = micro();
  v11 = 0;
  *((double *)v3 + 54) = v10;
  *((double *)v3 + 55) = v10;
  *v4 = 0;
  *((_BYTE *)v3 + 146072) = 0;
  *((_QWORD *)v3 + 18246) = 0;
  *((_BYTE *)v3 + 145976) = 0;
  v3[212] = 0;
  *((_QWORD *)v3 + 56) = 0x3FD0000000000000;
  do
  {
    VideoPacketBuffer_ResetBurstLossStatistics((char *)&v3[v11 + 21344]);
    v11 += 400;
  }
  while (v11 != 51200);
  v17 = (FILE **)*((_QWORD *)v3 + 18250);
  if (v17)
    VRDump_AddEvent(v17, 3u, 0, v12, v13, v14, v15, v16, v26);
  pthread_mutex_unlock((pthread_mutex_t *)(v3 + 176));
  *((_QWORD *)v3 + 18252) = VCMemoryPool_Create(0xB0uLL);
  *((_QWORD *)v3 + 18253) = VCMemoryPool_Create(0x90uLL);
  v18 = CMMemoryPoolCreate(0);
  *((_QWORD *)v3 + 18254) = v18;
  if (!v18)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoPacketBuffer_Create_cold_1();
    }
    goto LABEL_56;
  }
  if (*((_QWORD *)v3 + 29))
  {
    *((_QWORD *)v3 + 18255) = CFRetain(*((CFTypeRef *)v3 + 29));
    *((_QWORD *)v3 + 18257) = CFRetain(*((CFTypeRef *)v3 + 29));
    *((_QWORD *)v3 + 18256) = CFRetain(*((CFTypeRef *)v3 + 29));
    *((_QWORD *)v3 + 18258) = CFRetain(*((CFTypeRef *)v3 + 29));
    return v3;
  }
  Allocator = CMMemoryPoolGetAllocator(v18);
  *((_QWORD *)v3 + 18255) = Allocator;
  if (!Allocator)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoPacketBuffer_Create_cold_2();
    }
    goto LABEL_56;
  }
  CFRetain(Allocator);
  *(_OWORD *)buf = xmmword_1D910B7A0;
  v21 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (VCAllocatorMultiQueue_Create((const __CFAllocator *)*MEMORY[0x1E0C9AE00], (uint64_t)"VideoPacketBufferBlockBufferAllocator", 2u, (unint64_t *)buf, (CFAllocatorRef *)v3 + 18256))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoPacketBuffer_Create_cold_9();
    }
    goto LABEL_56;
  }
  if (VCAllocatorFirstCome_Create(v21, (uint64_t)"VPBSampleBufferAllocator", (CFAllocatorRef *)v3 + 18257))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoPacketBuffer_Create_cold_8();
    }
    goto LABEL_56;
  }
  if (VCUseFigMemoryPoolForDataBlockBuffer())
  {
    v22 = CMMemoryPoolCreate(0);
    *((_QWORD *)v3 + 18262) = v22;
    if (v22)
    {
      v23 = CMMemoryPoolGetAllocator(v22);
      *((_QWORD *)v3 + 18258) = v23;
      if (v23)
      {
        CFRetain(v23);
        goto LABEL_24;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
      {
        VRTraceErrorLogLevelToCSTR();
        if ((VRTraceIsOSFaultDisabled() & 1) != 0)
        {
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VideoPacketBuffer_Create_cold_5();
        }
        else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_FAULT))
        {
          VideoPacketBuffer_Create_cold_6();
        }
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 2)
    {
      VRTraceErrorLogLevelToCSTR();
      if ((VRTraceIsOSFaultDisabled() & 1) != 0)
      {
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VideoPacketBuffer_Create_cold_3();
      }
      else if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_FAULT))
      {
        VideoPacketBuffer_Create_cold_4();
      }
    }
LABEL_56:
    VideoPacketBuffer_Destroy((uint64_t)v3);
    return 0;
  }
  v27 = 6;
  if (VCAllocatorMultiQueue_Create(v21, (uint64_t)"VideoPacketBufferSliceHeaderAllocator", 1u, &v27, (CFAllocatorRef *)v3 + 18258))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoPacketBuffer_Create_cold_7();
    }
    goto LABEL_56;
  }
LABEL_24:
  if (*((_BYTE *)v3 + 280))
  {
    v24 = (const void *)*((_QWORD *)v3 + 18261);
    v25 = (const void *)*((_QWORD *)v3 + 36);
    *((_QWORD *)v3 + 18261) = v25;
    if (v25)
      CFRetain(v25);
    if (v24)
      CFRelease(v24);
  }
  return v3;
}

void VideoPacketBuffer_Destroy(uint64_t a1)
{
  uint64_t v2;
  pthread_mutex_t *v3;
  OSQueueHead *v4;
  OSQueueHead *v5;
  const void *v6;
  const void *v7;
  OpaqueCMMemoryPool *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  OpaqueCMMemoryPool *v13;
  const void *v14;

  if (a1)
  {
    v2 = a1 + 145984;
    v3 = (pthread_mutex_t *)(a1 + 352);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 352));
    if (*(_QWORD *)v2)
    {
      free(*(void **)v2);
      *(_QWORD *)v2 = 0;
    }
    *(_OWORD *)(a1 + 248) = 0u;
    *(_OWORD *)(a1 + 264) = 0u;
    _VideoPacketBuffer_FreeAllFrames(a1);
    v4 = *(OSQueueHead **)(v2 + 32);
    if (v4)
    {
      VCMemoryPool_Destroy(v4);
      *(_QWORD *)(v2 + 32) = 0;
    }
    v5 = *(OSQueueHead **)(v2 + 40);
    if (v5)
    {
      VCMemoryPool_Destroy(v5);
      *(_QWORD *)(v2 + 40) = 0;
    }
    v6 = *(const void **)(v2 + 104);
    if (v6)
    {
      CFRelease(v6);
      *(_QWORD *)(v2 + 104) = 0;
    }
    v7 = *(const void **)(v2 + 56);
    if (v7)
    {
      CFRelease(v7);
      *(_QWORD *)(v2 + 56) = 0;
    }
    v8 = *(OpaqueCMMemoryPool **)(v2 + 48);
    if (v8)
    {
      CMMemoryPoolInvalidate(v8);
      v9 = *(const void **)(v2 + 48);
      if (v9)
      {
        CFRelease(v9);
        *(_QWORD *)(v2 + 48) = 0;
      }
    }
    v10 = *(const void **)(v2 + 64);
    if (v10)
      CFRelease(v10);
    v11 = *(const void **)(v2 + 72);
    if (v11)
      CFRelease(v11);
    v12 = *(const void **)(v2 + 80);
    if (v12)
      CFRelease(v12);
    v13 = *(OpaqueCMMemoryPool **)(v2 + 112);
    if (v13)
    {
      CMMemoryPoolInvalidate(v13);
      v14 = *(const void **)(v2 + 112);
      if (v14)
      {
        CFRelease(v14);
        *(_QWORD *)(v2 + 112) = 0;
      }
    }
    pthread_mutex_unlock(v3);
    pthread_mutex_destroy(v3);
    free((void *)a1);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VideoPacketBuffer_Destroy_cold_1();
  }
}

void _VideoPacketBuffer_FreeAllFrames(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  NSObject *v4;
  int v5;
  uint64_t v6;
  __int16 v7;
  const char *v8;
  __int16 v9;
  int v10;
  __int16 v11;
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v2 = (_QWORD *)(a1 + 145912);
  _VideoPacketBuffer_ClearFrameList(a1, (uint64_t *)(a1 + 145896));
  _VideoPacketBuffer_ClearFrameList(a1, (uint64_t *)(a1 + 145904));
  *v2 = 0;
  v2[12] = 0;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v3 = VRTraceErrorLogLevelToCSTR();
    v4 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v5 = 136315906;
      v6 = v3;
      v7 = 2080;
      v8 = "_VideoPacketBuffer_FreeAllFrames";
      v9 = 1024;
      v10 = 346;
      v11 = 2048;
      v12 = a1;
      _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Freed all frames", (uint8_t *)&v5, 0x26u);
    }
  }
}

void VideoPacketBuffer_NeedRefreshFrame(uint64_t a1, int a2, int a3, unsigned int a4)
{
  uint64_t v8;
  pthread_mutex_t *v9;
  BOOL v11;
  BOOL v12;
  int v15;
  uint64_t v16;
  NSObject *v17;
  char *v18;
  int v19;
  uint64_t v20;
  NSObject *v21;
  int v22;
  uint64_t v23;
  __int16 v24;
  const char *v25;
  __int16 v26;
  int v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  int v31;
  __int16 v32;
  char *v33;
  __int16 v34;
  int v35;
  __int16 v36;
  int v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v8 = a1 + 145936;
    v9 = (pthread_mutex_t *)(a1 + 352);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 352));
    v11 = a4 == 27 || a4 - 17 < 2;
    if (*(_DWORD *)(v8 + 36))
      v12 = a4 > 0x1B;
    else
      v12 = 1;
    if (v12 || ((1 << a4) & 0x8060000) == 0 || (a2 & ~a3) == 0)
    {
      _VideoPacketBuffer_FreeAllFrames(a1);
      *(_QWORD *)v8 = 0;
      if (a4 == 27)
        v15 = *(_DWORD *)(v8 + 28);
      else
        v15 = 0;
      *(_DWORD *)(v8 + 28) = v15;
      *(_BYTE *)(v8 + 40) = v11;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v16 = VRTraceErrorLogLevelToCSTR();
        v17 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v18 = kVCKeyFrameRequestReasonStrings[a4];
          v19 = *(unsigned __int8 *)(v8 + 40);
          v22 = 136316930;
          v23 = v16;
          v24 = 2080;
          v25 = "VideoPacketBuffer_NeedRefreshFrame";
          v26 = 1024;
          v27 = 496;
          v28 = 2048;
          v29 = a1;
          v30 = 1024;
          v31 = a2;
          v32 = 2080;
          v33 = v18;
          v34 = 1024;
          v35 = a3;
          v36 = 1024;
          v37 = v19;
          _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] needIntraframe=%d reason=%s, needImageDescription=%d, isDecoderOutOfSync=%d", (uint8_t *)&v22, 0x42u);
        }
      }
      if (a2)
      {
        *(_DWORD *)(v8 + 36) = 1;
        *(_DWORD *)(v8 + 44) = a4;
      }
      if (a3)
        *(_DWORD *)(v8 + 32) = 0;
      pthread_mutex_unlock(v9);
    }
    else
    {
      pthread_mutex_unlock(v9);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v20 = VRTraceErrorLogLevelToCSTR();
        v21 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v22 = 136315906;
          v23 = v20;
          v24 = 2080;
          v25 = "VideoPacketBuffer_NeedRefreshFrame";
          v26 = 1024;
          v27 = 486;
          v28 = 2048;
          v29 = a1;
          _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Already in need refresh state, no need to clear buffers again.", (uint8_t *)&v22, 0x26u);
        }
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VideoPacketBuffer_NeedRefreshFrame_cold_1();
  }
}

void VideoPacketBuffer_GetCachedBurstLossStatistics(uint64_t a1, void *__dst)
{
  if (a1 && __dst)
  {
    memcpy(__dst, (const void *)(a1 + 145088), 0x320uLL);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VideoPacketBuffer_GetCachedBurstLossStatistics_cold_1();
  }
}

void VideoPacketBuffer_ResetBurstLossStatistics(char *a1)
{
  uint64_t i;

  if (a1)
  {
    bzero(a1, 0x320uLL);
    for (i = 0; i != 768; i += 6)
      *(_DWORD *)&a1[i + 34] = 524296;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VideoPacketBuffer_ResetBurstLossStatistics_cold_1();
  }
}

void _VideoPacketBuffer_ProcessFrameStats(uint64_t a1, double a2)
{
  uint64_t v3;
  char v4;
  __int16 v5;
  __int16 v6;
  unsigned int v7;
  unsigned __int16 v8;
  __int16 v9;
  unsigned __int16 v10;
  unsigned int v11;
  int v12;
  uint64_t v13;
  _QWORD *v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  double v18;
  float v19;
  int v20;
  unsigned int v21;
  int v22;
  unsigned int v23;
  double v24;
  double v25;
  double v26;
  BOOL v27;
  unsigned int v30;
  float v31;
  unsigned int v32;
  unsigned int v33;
  _WORD *v34;
  int v35;
  unsigned int v36;
  char v37;
  _WORD *v38;
  int v39;
  NSObject *v40;
  int v41;
  int v42;
  uint64_t v43;
  NSObject *log;
  unsigned __int16 v45;
  uint64_t v46;
  uint8_t buf[4];
  uint64_t v48;
  __int16 v49;
  const char *v50;
  __int16 v51;
  int v52;
  __int16 v53;
  uint64_t v54;
  __int16 v55;
  int v56;
  __int16 v57;
  int v58;
  __int16 v59;
  int v60;
  __int16 v61;
  unsigned int v62;
  __int16 v63;
  int v64;
  __int16 v65;
  int v66;
  __int16 v67;
  double v68;
  __int16 v69;
  double v70;
  uint64_t v71;

  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  LOWORD(v7) = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v71 = *MEMORY[0x1E0C80C00];
  v13 = a1 + 145088;
  v14 = (_QWORD *)(a1 + 42712);
  v15 = *(_DWORD *)(a1 + 145888);
  v16 = a1 + 1068;
  v17 = a1 + 21876;
  v18 = 0.0;
  v19 = 0.0;
  v20 = -1;
  do
  {
    v21 = *((unsigned __int16 *)v14 - 7);
    v22 = *((_DWORD *)v14 - 6);
    v23 = *((_DWORD *)v14 - 5);
    if (*(double *)(a1 + 448) < 0.0500000007 || (v24 = 0.75, *(double *)(a1 + 448) <= 0.75))
    {
      v24 = 0.0500000007;
      if (*(double *)(a1 + 448) >= 0.0500000007)
        v24 = *(double *)(a1 + 448);
    }
    v25 = *(double *)v14;
    v26 = v24 * 1.20000005;
    if (*((_WORD *)v14 - 7))
      v27 = v22 == -1;
    else
      v27 = 1;
    if (!v27 && v23 <= v15 && a2 - *(double *)v14 > v26)
    {
      v30 = *((unsigned __int16 *)v14 - 5);
      v31 = (double)v30 / (double)v21;
      if (v19 <= v31)
      {
        if (v21 >= 0x66)
          v32 = 102;
        else
          v32 = *((unsigned __int16 *)v14 - 7);
        if (v30 >= v32)
          v33 = v32;
        else
          v33 = *((unsigned __int16 *)v14 - 5);
        v34 = (_WORD *)(v16 + 204 * v32 + 2 * v33);
        v35 = (unsigned __int16)*v34;
        if (v35 != 0xFFFF)
          *v34 = v35 + 1;
        if (*((unsigned __int16 *)v14 - 8) <= 0x66u)
          v36 = *((_WORD *)v14 - 8);
        else
          v36 = 102;
        v7 = *((unsigned __int16 *)v14 - 4);
        if (v36 >= v7)
          v37 = *((_WORD *)v14 - 4);
        else
          v37 = v36;
        v38 = (_WORD *)(v17 + 204 * (v36 + v32) + 2 * (v37 + v33));
        v39 = (unsigned __int16)*v38;
        if (v39 == 0xFFFF)
        {
          v8 = v30;
          v10 = v21;
        }
        else
        {
          *v38 = v39 + 1;
          v10 = *((_WORD *)v14 - 7);
          v8 = *((_WORD *)v14 - 5);
          LOWORD(v7) = *((_WORD *)v14 - 4);
        }
        v9 = *((_WORD *)v14 - 6);
        v4 = *((_BYTE *)v14 - 2);
        v12 = v22;
        v11 = v23;
        v6 = *((_WORD *)v14 - 3);
        v18 = v25;
        v19 = (double)v30 / (double)v21;
        v20 = v3;
        v5 = *((_WORD *)v14 - 2);
      }
      *((_DWORD *)v14 - 6) = -1;
    }
    ++v3;
    v14 += 100;
  }
  while (v3 != 128);
  if (v20 != -1)
  {
    v45 = v8;
    v46 = v13;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v43 = VRTraceErrorLogLevelToCSTR();
      v40 = *MEMORY[0x1E0CF2758];
      log = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
        {
          v41 = *(_DWORD *)(v46 + 800);
          *(_DWORD *)buf = 136317954;
          v48 = v43;
          v49 = 2080;
          v50 = "_VideoPacketBuffer_ProcessFrameStats";
          v51 = 1024;
          v52 = 706;
          v53 = 2048;
          v54 = a1;
          v55 = 1024;
          v56 = v20;
          v57 = 1024;
          v58 = v12;
          v59 = 1024;
          v60 = v41;
          v61 = 1024;
          v62 = v11;
          v63 = 1024;
          v64 = v10;
          v65 = 1024;
          v66 = v45;
          v67 = 2048;
          v68 = v19;
          v69 = 2048;
          v70 = v18;
          _os_log_impl(&dword_1D8A54000, log, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] FEC Feedback computed maxLossFrameIndex=%d frameSequenceNumber=%d playoutRTPTimestamp=%u rtpTimestamp=%u frameSize=%u VideoPacketsLostPerFrame=%u lossRatio=%2.2f arrivalTime=%2.3f", buf, 0x5Eu);
        }
      }
      else if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
      {
        v42 = *(_DWORD *)(v46 + 800);
        *(_DWORD *)buf = 136317954;
        v48 = v43;
        v49 = 2080;
        v50 = "_VideoPacketBuffer_ProcessFrameStats";
        v51 = 1024;
        v52 = 706;
        v53 = 2048;
        v54 = a1;
        v55 = 1024;
        v56 = v20;
        v57 = 1024;
        v58 = v12;
        v59 = 1024;
        v60 = v42;
        v61 = 1024;
        v62 = v11;
        v63 = 1024;
        v64 = v10;
        v65 = 1024;
        v66 = v45;
        v67 = 2048;
        v68 = v19;
        v69 = 2048;
        v70 = v18;
        _os_log_debug_impl(&dword_1D8A54000, log, OS_LOG_TYPE_DEBUG, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] FEC Feedback computed maxLossFrameIndex=%d frameSequenceNumber=%d playoutRTPTimestamp=%u rtpTimestamp=%u frameSize=%u VideoPacketsLostPerFrame=%u lossRatio=%2.2f arrivalTime=%2.3f", buf, 0x5Eu);
      }
    }
    *(_WORD *)(v46 + 10) = v10;
    *(_WORD *)(v46 + 12) = v9;
    *(_DWORD *)v46 = v12;
    *(_DWORD *)(v46 + 4) = v11;
    *(_BYTE *)(v46 + 22) = v4;
    *(double *)(v46 + 24) = v18;
    *(_WORD *)(v46 + 14) = v45;
    *(_WORD *)(v46 + 16) = v7;
    *(_WORD *)(v46 + 18) = v6;
    *(_WORD *)(v46 + 20) = v5;
  }
}

void VideoPacketBuffer_UpdateMaxFrameBurstLossStatistics(uint64_t a1, unsigned int a2, unsigned __int16 *a3, int a4, int a5, char a6, double a7)
{
  unsigned __int16 *v14;
  unsigned int v15;
  unsigned __int16 *v16;
  unsigned int v17;
  int v18;
  uint64_t v19;
  NSObject *v20;
  NSObject *v21;
  _WORD *v22;
  int v23;
  uint64_t v24;
  NSObject *v25;
  NSObject *v26;
  _WORD *v27;
  uint64_t v28;
  NSObject *v29;
  NSObject *v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  uint64_t v47;
  NSObject *v48;
  int v49;
  uint64_t v50;
  __int16 v51;
  const char *v52;
  __int16 v53;
  int v54;
  __int16 v55;
  _BYTE v56[10];
  _BYTE v57[6];
  __int16 v58;
  int v59;
  __int16 v60;
  int v61;
  __int16 v62;
  int v63;
  __int16 v64;
  int v65;
  __int16 v66;
  int v67;
  __int16 v68;
  int v69;
  __int16 v70;
  int v71;
  uint64_t v72;

  v72 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a3)
    {
      if ((a2 & 0x80000000) == 0)
      {
        v14 = (unsigned __int16 *)(a1 + 800 * a2 + 42688);
        bzero(v14, 0x320uLL);
        v15 = *a3;
        v14[5] = v15;
        v16 = v14 + 5;
        v14[4] = a3[1];
        *(_DWORD *)v14 = a4;
        *((_DWORD *)v14 + 1) = a5;
        *((_BYTE *)v14 + 22) = a6;
        *((double *)v14 + 3) = a7;
        if (v15 < 2)
          return;
        v17 = a2;
        v18 = v15 - a3[2];
        if (v18 < 0)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            v19 = VRTraceErrorLogLevelToCSTR();
            v20 = *MEMORY[0x1E0CF2758];
            v21 = *MEMORY[0x1E0CF2758];
            if (*MEMORY[0x1E0CF2748])
            {
              v18 = 0;
              if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
                goto LABEL_13;
              v49 = 136315650;
              v50 = v19;
              v51 = 2080;
              v52 = "VideoPacketBuffer_UpdateMaxFrameBurstLossStatistics";
              v53 = 1024;
              v54 = 752;
              _os_log_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d Received more video packets than expected.", (uint8_t *)&v49, 0x1Cu);
            }
            else if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
            {
              VideoPacketBuffer_UpdateMaxFrameBurstLossStatistics_cold_4();
            }
          }
          v18 = 0;
        }
LABEL_13:
        v22 = (_WORD *)(a1 + 800 * v17 + 42702);
        *v22 = v18;
        v23 = a3[1] - a3[3];
        if (v23 >= 0)
          goto LABEL_21;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          v24 = VRTraceErrorLogLevelToCSTR();
          v25 = *MEMORY[0x1E0CF2758];
          v26 = *MEMORY[0x1E0CF2758];
          if (*MEMORY[0x1E0CF2748])
          {
            v23 = 0;
            if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
              goto LABEL_21;
            v49 = 136315650;
            v50 = v24;
            v51 = 2080;
            v52 = "VideoPacketBuffer_UpdateMaxFrameBurstLossStatistics";
            v53 = 1024;
            v54 = 759;
            _os_log_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d Received more parity packets than expected.", (uint8_t *)&v49, 0x1Cu);
          }
          else if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
          {
            VideoPacketBuffer_UpdateMaxFrameBurstLossStatistics_cold_3();
          }
        }
        v23 = 0;
LABEL_21:
        v27 = (_WORD *)(a1 + 800 * v17 + 42704);
        *v27 = v23;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          v28 = VRTraceErrorLogLevelToCSTR();
          v29 = *MEMORY[0x1E0CF2758];
          v30 = *MEMORY[0x1E0CF2758];
          if (*MEMORY[0x1E0CF2748])
          {
            if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
            {
              v31 = *(_DWORD *)v14;
              v32 = *v16;
              v33 = (unsigned __int16)*v22;
              v34 = (unsigned __int16)*v27;
              v35 = *a3;
              v36 = a3[1];
              v37 = a3[2];
              v38 = a3[3];
              v49 = 136318210;
              v50 = v28;
              v51 = 2080;
              v52 = "VideoPacketBuffer_UpdateMaxFrameBurstLossStatistics";
              v53 = 1024;
              v54 = 764;
              v55 = 1024;
              *(_DWORD *)v56 = v31;
              *(_WORD *)&v56[4] = 1024;
              *(_DWORD *)&v56[6] = v32;
              *(_WORD *)v57 = 1024;
              *(_DWORD *)&v57[2] = v33;
              v58 = 1024;
              v59 = v34;
              v60 = 1024;
              v61 = v18;
              v62 = 1024;
              v63 = v23;
              v64 = 1024;
              v65 = v35;
              v66 = 1024;
              v67 = v36;
              v68 = 1024;
              v69 = v37;
              v70 = 1024;
              v71 = v38;
              _os_log_impl(&dword_1D8A54000, v29, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d frameSequenceNumber=%d size=%d maxVideoPacketsLostPerFrame=%d, maxParityPacketsLostPerFrame=%d, videoPacketsLost=%d, parityPacketsLost=%d, videoPacketsExpected=%d, parityPacketsExpected=%d, videoPacketsReceived=%d, parityPacketsReceived=%d", (uint8_t *)&v49, 0x58u);
            }
          }
          else if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
          {
            v39 = *(_DWORD *)v14;
            v40 = *v16;
            v41 = (unsigned __int16)*v22;
            v42 = (unsigned __int16)*v27;
            v43 = *a3;
            v44 = a3[1];
            v45 = a3[2];
            v46 = a3[3];
            v49 = 136318210;
            v50 = v28;
            v51 = 2080;
            v52 = "VideoPacketBuffer_UpdateMaxFrameBurstLossStatistics";
            v53 = 1024;
            v54 = 764;
            v55 = 1024;
            *(_DWORD *)v56 = v39;
            *(_WORD *)&v56[4] = 1024;
            *(_DWORD *)&v56[6] = v40;
            *(_WORD *)v57 = 1024;
            *(_DWORD *)&v57[2] = v41;
            v58 = 1024;
            v59 = v42;
            v60 = 1024;
            v61 = v18;
            v62 = 1024;
            v63 = v23;
            v64 = 1024;
            v65 = v43;
            v66 = 1024;
            v67 = v44;
            v68 = 1024;
            v69 = v45;
            v70 = 1024;
            v71 = v46;
            _os_log_debug_impl(&dword_1D8A54000, v29, OS_LOG_TYPE_DEBUG, "VideoPacketBuffer [%s] %s:%d frameSequenceNumber=%d size=%d maxVideoPacketsLostPerFrame=%d, maxParityPacketsLostPerFrame=%d, videoPacketsLost=%d, parityPacketsLost=%d, videoPacketsExpected=%d, parityPacketsExpected=%d, videoPacketsReceived=%d, parityPacketsReceived=%d", (uint8_t *)&v49, 0x58u);
          }
        }
        return;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v47 = VRTraceErrorLogLevelToCSTR();
        v48 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v49 = 136316162;
          v50 = v47;
          v51 = 2080;
          v52 = "VideoPacketBuffer_UpdateMaxFrameBurstLossStatistics";
          v53 = 1024;
          v54 = 735;
          v55 = 2048;
          *(_QWORD *)v56 = a1;
          *(_WORD *)&v56[8] = 1024;
          *(_DWORD *)v57 = a2;
          _os_log_error_impl(&dword_1D8A54000, v48, OS_LOG_TYPE_ERROR, "VideoPacketBuffer [%s] %s:%d Invalid frameIndex for updating max frame burst loss for VideoPacketBuffer=%p, frameIndex=%d", (uint8_t *)&v49, 0x2Cu);
        }
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoPacketBuffer_UpdateMaxFrameBurstLossStatistics_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VideoPacketBuffer_UpdateMaxFrameBurstLossStatistics_cold_1();
  }
}

void VideoPacketBuffer_UpdateMaxGroupBurstLossStatistics(uint64_t a1, uint64_t a2, int a3, unsigned int a4, int a5, int a6)
{
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  int v14;
  int v15;
  uint64_t v16;
  _WORD *v17;
  int v18;
  int v19;
  uint64_t v21;
  uint64_t v22;
  NSObject *v23;
  NSObject *v24;
  int v25;
  uint64_t v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  __int16 v33;
  int v34;
  __int16 v35;
  int v36;
  __int16 v37;
  unsigned int v38;
  __int16 v39;
  int v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if ((int)a2 >= 9)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v11 = VRTraceErrorLogLevelToCSTR();
        v12 = *MEMORY[0x1E0CF2758];
        v13 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            v25 = 136315650;
            v26 = v11;
            v27 = 2080;
            v28 = "VideoPacketBuffer_UpdateMaxGroupBurstLossStatistics";
            v29 = 1024;
            v30 = 778;
            _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d Lost more video symbols than expected.", (uint8_t *)&v25, 0x1Cu);
          }
        }
        else if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
        {
          VideoPacketBuffer_UpdateMaxGroupBurstLossStatistics_cold_2();
        }
      }
      a2 = 8;
    }
    v14 = FECUtil_ConvertNumberOfSymbolsToPackets(a2, a4);
    v15 = v14;
    v16 = a1 + 6 * a6;
    v19 = *(unsigned __int16 *)(v16 + 34);
    v17 = (_WORD *)(v16 + 34);
    v18 = v19;
    if (v19 == 8 || v14 <= v18)
    {
      v21 = a1 + 6 * a6;
      *(_WORD *)(v21 + 32) = a5;
      *v17 = v14;
      *(_WORD *)(v21 + 36) = a3;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v22 = VRTraceErrorLogLevelToCSTR();
      v23 = *MEMORY[0x1E0CF2758];
      v24 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          v25 = 136316930;
          v26 = v22;
          v27 = 2080;
          v28 = "VideoPacketBuffer_UpdateMaxGroupBurstLossStatistics";
          v29 = 1024;
          v30 = 791;
          v31 = 1024;
          v32 = a6;
          v33 = 1024;
          v34 = v15;
          v35 = 1024;
          v36 = a3;
          v37 = 1024;
          v38 = a4;
          v39 = 1024;
          v40 = a5;
          _os_log_impl(&dword_1D8A54000, v23, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d groupID=%d videoPacketsLost=%d parityPacketsLostPerGroup=%d numberOfSymbolsPerPacket=%d numberOfDataPackets=%d", (uint8_t *)&v25, 0x3Au);
        }
      }
      else if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
      {
        v25 = 136316930;
        v26 = v22;
        v27 = 2080;
        v28 = "VideoPacketBuffer_UpdateMaxGroupBurstLossStatistics";
        v29 = 1024;
        v30 = 791;
        v31 = 1024;
        v32 = a6;
        v33 = 1024;
        v34 = v15;
        v35 = 1024;
        v36 = a3;
        v37 = 1024;
        v38 = a4;
        v39 = 1024;
        v40 = a5;
        _os_log_debug_impl(&dword_1D8A54000, v23, OS_LOG_TYPE_DEBUG, "VideoPacketBuffer [%s] %s:%d groupID=%d videoPacketsLost=%d parityPacketsLostPerGroup=%d numberOfSymbolsPerPacket=%d numberOfDataPackets=%d", (uint8_t *)&v25, 0x3Au);
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VideoPacketBuffer_UpdateMaxGroupBurstLossStatistics_cold_1();
  }
}

void VideoPacketBuffer_GetStatistics(uint64_t a1, void *__dst)
{
  if (a1)
  {
    if (__dst)
      memcpy(__dst, (const void *)(a1 + 456), 0xA4F8uLL);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VideoPacketBuffer_GetStatistics_cold_1();
  }
}

void VideoPacketBuffer_ResetStatistics(uint64_t a1)
{
  if (a1)
  {
    bzero((void *)(a1 + 456), 0xA4F8uLL);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VideoPacketBuffer_ResetStatistics_cold_1();
  }
}

uint64_t VideoPacketBuffer_AddPacket(uint64_t a1, int *a2, int a3, int a4, char a5, double a6)
{
  uint64_t v9;
  int *v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  NSObject *v17;
  NSObject *v18;
  uint64_t v19;
  NSObject *v20;
  unsigned int v21;
  uint64_t v22;
  NSObject *v23;
  double v24;
  _DWORD *v25;
  unsigned int v26;
  int v27;
  _BOOL4 v28;
  _BOOL4 v29;
  unsigned int v30;
  int v31;
  double v32;
  float v33;
  _BOOL4 v34;
  float v35;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char v45;
  __int16 v46;
  int v47;
  uint64_t v48;
  __int16 v49;
  uint64_t v50;
  _QWORD *v51;
  int v52;
  unsigned int v53;
  BOOL v54;
  _BOOL4 v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  NSObject *v65;
  NSObject *v66;
  int v67;
  int v68;
  int v69;
  uint64_t v70;
  NSObject *v71;
  int v72;
  int v73;
  FILE **v74;
  unint64_t v75;
  __int16 v76;
  uint64_t v77;
  void **v78;
  char *v79;
  int v80;
  uint64_t v81;
  char v82;
  char v83;
  char v84;
  uint64_t v85;
  NSObject *v86;
  pthread_mutex_t *v87;
  int v88;
  int v89;
  const char *v90;
  int v91;
  uint64_t v92;
  char v93;
  uint64_t v94;
  double v95;
  uint64_t v96;
  NSObject *v97;
  int v98;
  int v99;
  uint64_t v100;
  uint64_t v101;
  _BOOL4 v102;
  int v103;
  unsigned int v104;
  unint64_t v105;
  unint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  NSObject *v110;
  int v111;
  int v112;
  uint64_t v113;
  int v114;
  int v115;
  BOOL v116;
  uint64_t v117;
  double v118;
  uint64_t v119;
  NSObject *v120;
  unsigned __int16 *v121;
  _QWORD *v122;
  _DWORD *v123;
  int v124;
  unsigned int v125;
  int v126;
  char v127;
  unsigned int v128;
  unsigned int v129;
  unsigned int v130;
  unsigned int v131;
  unsigned int v132;
  char v133;
  unsigned int v134;
  unsigned int v135;
  int v136;
  _BOOL4 v137;
  BOOL v138;
  _BOOL4 v139;
  char *v140;
  uint64_t v141;
  NSObject *v142;
  NSObject *v143;
  int v144;
  unsigned int v145;
  uint64_t v146;
  NSObject *v147;
  NSObject *v148;
  unsigned int v149;
  BOOL v150;
  char v151;
  int v152;
  int v153;
  int v154;
  const char *v155;
  NSObject *v156;
  uint64_t v157;
  int v158;
  uint64_t v159;
  NSObject *v160;
  NSObject *v161;
  unsigned int v162;
  BOOL v163;
  char v164;
  int v165;
  int v166;
  int v167;
  const char *v168;
  NSObject *v169;
  __int128 *v170;
  __int128 v171;
  __int128 v172;
  __int128 v173;
  uint64_t v175;
  int v176;
  int v177;
  unsigned int v178;
  BOOL v179;
  char v180;
  int v181;
  int v182;
  int v183;
  const char *v184;
  NSObject *v185;
  uint64_t v186;
  NSObject *v187;
  NSObject *v188;
  NSObject *v189;
  NSObject *v190;
  unsigned int v191;
  BOOL v192;
  char v193;
  int v194;
  int v195;
  int v196;
  const char *v197;
  NSObject *v198;
  int v199;
  int v200;
  int v201;
  int v202;
  _BOOL4 v203;
  int v204;
  int v205;
  __int16 v206;
  char v207;
  int v208;
  int v210;
  _BOOL4 v211;
  pthread_mutex_t *v212;
  unsigned int v213;
  int v214;
  int v215;
  unsigned int v216;
  uint64_t v217;
  int v218;
  int v219;
  _BYTE buf[40];
  _BYTE v221[32];
  __int16 v222;
  int v223;
  __int16 v224;
  int v225;
  __int16 v226;
  int v227;
  uint64_t v228;

  v228 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v19 = VRTraceErrorLogLevelToCSTR();
      v20 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)&buf[4] = v19;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "VideoPacketBuffer_AddPacket";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 1442;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = a4;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = a3;
        _os_log_error_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_ERROR, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer pointer is null, isBaseLayerStream=%d, isTemporalScaledStream=%d", buf, 0x28u);
      }
    }
    return 0;
  }
  v9 = a1;
  if (!*((_QWORD *)a2 + 7))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoPacketBuffer_AddPacket_cold_1();
    }
    return 0;
  }
  v12 = (int *)*((_QWORD *)a2 + 8);
  v13 = *v12;
  v218 = v12[1];
  v219 = *((unsigned __int16 *)v12 + 6);
  v14 = v12[4];
  v15 = *((unsigned __int8 *)v12 + 81);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v16 = VRTraceErrorLogLevelToCSTR();
    v17 = *MEMORY[0x1E0CF2758];
    v18 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = v16;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "VideoPacketBuffer_AddPacket";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 1464;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v15;
        _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d [Media Priority] Received video priority=%u", buf, 0x22u);
      }
    }
    else if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      VideoPacketBuffer_AddPacket_cold_3();
    }
  }
  v210 = a4;
  v21 = *((unsigned __int8 *)v12 + 80);
  v205 = *((unsigned __int16 *)v12 + 12);
  v208 = *((unsigned __int8 *)v12 + 26);
  if (v21 < 0xD)
  {
    v213 = *((unsigned __int8 *)v12 + 80);
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v22 = VRTraceErrorLogLevelToCSTR();
      v23 = *MEMORY[0x1E0CF2758];
      v213 = 0;
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        goto LABEL_21;
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = v22;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "VideoPacketBuffer_AddPacket";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 1472;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = v21;
      _os_log_impl(&dword_1D8A54000, v23, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d Invalid Stream Id Count %d", buf, 0x22u);
    }
    v213 = 0;
  }
LABEL_21:
  v24 = micro();
  v25 = (_DWORD *)*((_QWORD *)a2 + 7);
  v207 = v15;
  if (v25)
  {
    if (*v25)
    {
      v26 = v25[2];
      if (v26 >> 30)
        v27 = 0x400000;
      else
        v27 = 0x800000;
      v28 = (v27 & v26) == 0;
    }
    else
    {
      v28 = 0;
    }
    v29 = *v25 != 0;
  }
  else
  {
    v28 = 0;
    v29 = 0;
  }
  v30 = v25[2];
  if (v30 >> 30)
    v31 = (v30 >> 23) & 0xF;
  else
    v31 = HIBYTE(v30) & 7;
  v32 = (double)(v25[2] & 0x3FF) / 100.0;
  v33 = v32;
  if (v29)
  {
    if (v30 >> 30)
    {
      v35 = v32;
      v216 = FECUtil_FECRatioToLevelofProtection(v35);
      v34 = *((unsigned __int16 *)a2 + 24) == 1;
    }
    else
    {
      v34 = 0;
      v216 = 2 * (v213 > 1);
    }
  }
  else
  {
    v216 = 0;
    v34 = 0;
  }
  if ((v218 - 100) > 0x1A || ((1 << (v218 - 100)) & 0x7800401) == 0)
    return 0;
  v203 = v34;
  v37 = v9 + 145888;
  v212 = (pthread_mutex_t *)(v9 + 352);
  pthread_mutex_lock((pthread_mutex_t *)(v9 + 352));
  v44 = *(_QWORD *)(v9 + 146088);
  if (v44)
    v45 = v28;
  else
    v45 = 1;
  if ((v45 & 1) == 0)
  {
    *(_OWORD *)buf = xmmword_1D910B810;
    *(_OWORD *)&buf[16] = unk_1D910B820;
    v46 = *((_WORD *)v12 + 6);
    buf[16] = *((_BYTE *)v12 + 194);
    v47 = v12[4];
    *(_DWORD *)buf = v12[5];
    *(_WORD *)&buf[4] = v46;
    *(_QWORD *)&buf[8] = *((_QWORD *)v12 + 4);
    *(_DWORD *)&buf[20] = v47;
    buf[24] = v29;
    *(_WORD *)&buf[26] = *((_WORD *)a2 + 23);
    *(_WORD *)&buf[28] = *((_QWORD *)v12 + 14);
    buf[30] = 0;
    buf[31] = a5;
    VCNACKGenerator_AddPacketInfo(v44, (double *)buf, v38, v39, v40, v41, v42, v43);
  }
  v204 = v13;
  if (v29)
  {
    v48 = *(_QWORD *)(*((_QWORD *)a2 + 2) + 8);
    v49 = v219;
    v50 = v9 + 40 * v216;
    if (v28)
      v51 = (_QWORD *)(v50 + 480);
    else
      v51 = (_QWORD *)(v50 + 472);
  }
  else
  {
    v48 = *(_QWORD *)(*((_QWORD *)a2 + 2) + 8);
    v49 = v219;
    if (*((_BYTE *)a2 + 72))
      v51 = (_QWORD *)(v9 + 600);
    else
      v51 = (_QWORD *)(v9 + 472);
  }
  *v51 += v48;
  if (*((_BYTE *)a2 + 72))
    v52 = 1;
  else
    v52 = v28;
  *(double *)(v9 + 448) = a6;
  *(double *)(v9 + 440) = v24;
  v53 = v14 - *(_DWORD *)(v9 + 416);
  v54 = v53 > 0x7FFFFFFE;
  v55 = v53 > 0x7FFFFFFE || v14 == *(_DWORD *)(v9 + 416);
  v56 = v52 ^ 1;
  v206 = v52 ^ 1;
  if (!v54)
    v56 = 0;
  v214 = v56;
  v215 = v52;
  v217 = v9 + 145888;
  if (!*(_QWORD *)(v9 + 146000))
    goto LABEL_79;
  v57 = *((_QWORD *)a2 + 8);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v64 = VRTraceErrorLogLevelToCSTR();
    v65 = *MEMORY[0x1E0CF2758];
    v66 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
      {
        v67 = *((unsigned __int16 *)a2 + 23);
        v68 = *(unsigned __int16 *)(v57 + 12);
        *(_DWORD *)buf = 136317186;
        *(_QWORD *)&buf[4] = v64;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VideoPacketBuffer_LogNewPacket";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 1368;
        *(_WORD *)&buf[28] = 2048;
        *(_QWORD *)&buf[30] = v9;
        *(_WORD *)&buf[38] = 1024;
        *(_DWORD *)v221 = v67;
        *(_WORD *)&v221[4] = 1024;
        *(_DWORD *)&v221[6] = v215;
        *(_WORD *)&v221[10] = 1024;
        *(_DWORD *)&v221[12] = v29;
        *(_WORD *)&v221[16] = 1024;
        *(_DWORD *)&v221[18] = v68;
        *(_WORD *)&v221[22] = 1024;
        *(_DWORD *)&v221[24] = v31;
        _os_log_impl(&dword_1D8A54000, v65, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Add Packet frameSequenceNumber=%d fParityPacket=%d fecProtected=%d seq=%d startPosition=%d", buf, 0x44u);
      }
    }
    else if (os_log_type_enabled(v66, OS_LOG_TYPE_DEBUG))
    {
      v199 = *((unsigned __int16 *)a2 + 23);
      v200 = *(unsigned __int16 *)(v57 + 12);
      *(_DWORD *)buf = 136317186;
      *(_QWORD *)&buf[4] = v64;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "_VideoPacketBuffer_LogNewPacket";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 1368;
      *(_WORD *)&buf[28] = 2048;
      *(_QWORD *)&buf[30] = v9;
      *(_WORD *)&buf[38] = 1024;
      *(_DWORD *)v221 = v199;
      *(_WORD *)&v221[4] = 1024;
      *(_DWORD *)&v221[6] = v215;
      *(_WORD *)&v221[10] = 1024;
      *(_DWORD *)&v221[12] = v29;
      *(_WORD *)&v221[16] = 1024;
      *(_DWORD *)&v221[18] = v200;
      *(_WORD *)&v221[22] = 1024;
      *(_DWORD *)&v221[24] = v31;
      _os_log_debug_impl(&dword_1D8A54000, v65, OS_LOG_TYPE_DEBUG, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Add Packet frameSequenceNumber=%d fParityPacket=%d fecProtected=%d seq=%d startPosition=%d", buf, 0x44u);
    }
  }
  v69 = v214;
  if (!v214)
    goto LABEL_76;
  v37 = v9 + 145888;
  v49 = v219;
  if (*(_DWORD *)(v9 + 145972))
  {
    v69 = 0;
    goto LABEL_77;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v70 = VRTraceErrorLogLevelToCSTR();
    v71 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v72 = *(_DWORD *)(v9 + 416);
      v73 = *(_DWORD *)(v57 + 16);
      *(_DWORD *)buf = 136316418;
      *(_QWORD *)&buf[4] = v70;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "_VideoPacketBuffer_LogNewPacket";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 1371;
      *(_WORD *)&buf[28] = 2048;
      *(_QWORD *)&buf[30] = v9;
      *(_WORD *)&buf[38] = 1024;
      *(_DWORD *)v221 = v72;
      *(_WORD *)&v221[4] = 1024;
      *(_DWORD *)&v221[6] = v73;
      _os_log_impl(&dword_1D8A54000, v71, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Received a packet out of order. lastAssembledTimestamp=%d packetTimestamp=%d", buf, 0x32u);
    }
    v69 = 1;
LABEL_76:
    v49 = v219;
    v37 = v9 + 145888;
    goto LABEL_77;
  }
  v69 = 1;
LABEL_77:
  v74 = *(FILE ***)(v37 + 112);
  if (v74)
  {
    *(_OWORD *)buf = xmmword_1D910B7C8;
    *(_OWORD *)&buf[16] = unk_1D910B7D8;
    *(_QWORD *)buf = *(_QWORD *)(v57 + 32);
    HIDWORD(v75) = *(_DWORD *)&buf[4];
    *(_DWORD *)&buf[8] = *(unsigned __int16 *)(v57 + 12);
    LODWORD(v75) = *(_DWORD *)(v57 + 16);
    *(double *)&buf[16] = (double)v75;
    *(_DWORD *)&buf[24] = *(_QWORD *)(v57 + 152);
    buf[28] = (a2[10] & 2) != 0;
    *(_DWORD *)&buf[32] = *(unsigned __int16 *)(v57 + 56);
    *(_DWORD *)&buf[36] = 0;
    *(_DWORD *)v221 = 0;
    *(_DWORD *)&v221[4] = v29;
    *(_DWORD *)&v221[8] = v216;
    *(_DWORD *)&v221[12] = 0;
    *(_DWORD *)&v221[16] = *(unsigned __int8 *)(v57 + 194);
    *(_DWORD *)&v221[20] = v55;
    *(_DWORD *)&v221[24] = v69;
    *(_DWORD *)&v221[28] = *(_DWORD *)&v221[16];
    VRDump_AddPacket(v74, (uint64_t)buf, v58, v59, v60, v61, v62, v63);
  }
LABEL_79:
  if (v55)
  {
    v76 = v49;
    if (*((_BYTE *)a2 + 45))
      v76 = *((_WORD *)a2 + 23);
    if (*(_BYTE *)(v9 + 241))
    {
      v77 = 424;
      if (!*((_BYTE *)a2 + 45))
        v77 = 422;
      if (*(_DWORD *)(v37 + 84) && (unsigned __int16)(v76 - *(_WORD *)(v9 + v77)) <= 0x7FFEu)
      {
        v211 = v55;
        v78 = (void **)(v37 + 16);
        kdebug_trace();
        _VideoPacketBuffer_CorrectFrameStats(v9, *((unsigned __int16 *)a2 + 23), v215);
        goto LABEL_89;
      }
    }
    v91 = *(_DWORD *)(v9 + 416);
    v92 = (v91 - v14);
    if (v91 == (_DWORD)v14)
      v93 = 1;
    else
      v93 = v215;
    if ((v93 & 1) == 0)
    {
      v94 = *(int *)(v9 + 8);
      v95 = *(double *)(v9 + 432);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v96 = VRTraceErrorLogLevelToCSTR();
        v97 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136317954;
          v98 = *(_DWORD *)(v9 + 416);
          v99 = *((unsigned __int16 *)a2 + 23);
          *(_QWORD *)&buf[4] = v96;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "VideoPacketBuffer_AddPacket";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 1541;
          *(_WORD *)&buf[28] = 2048;
          *(_QWORD *)&buf[30] = v9;
          *(_WORD *)&buf[38] = 1024;
          *(_DWORD *)v221 = v29;
          *(_WORD *)&v221[4] = 1024;
          *(_DWORD *)&v221[6] = v14;
          *(_WORD *)&v221[10] = 1024;
          *(_DWORD *)&v221[12] = v98;
          *(_WORD *)&v221[16] = 1024;
          *(_DWORD *)&v221[18] = v219;
          *(_WORD *)&v221[22] = 2048;
          *(double *)&v221[24] = v24 - v95 + (double)(v92 / v94);
          v222 = 1024;
          v223 = v99;
          v224 = 1024;
          v225 = a3;
          v226 = 1024;
          v227 = v210;
          _os_log_impl(&dword_1D8A54000, v97, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Discarding packet fecProtected=%d TS=%d lastTS=%d seq=%d that arrived late [%f]s frameSequenceNumber=%d isTemporalStreamEnabled=%d isBaseLayerStream=%d", buf, 0x5Au);
        }
      }
    }
    _VideoPacketBuffer_CorrectFrameStats(v9, *((unsigned __int16 *)a2 + 23), v215);
    pthread_mutex_unlock(v212);
    return 0;
  }
  v211 = v55;
  v78 = (void **)(v37 + 8);
LABEL_89:
  v79 = (char *)*v78;
  if (!*v78)
  {
    v101 = v9;
    v102 = v29;
    v103 = v14;
    v81 = 0;
    v202 = 0;
LABEL_125:
    v79 = (char *)VCMemoryPool_Alloc(*(OSQueueHead **)(v217 + 128));
    *(_DWORD *)v79 = v218;
    *(_QWORD *)(v79 + 4) = *(_QWORD *)a2;
    *((_DWORD *)v79 + 3) = v103;
    *((_DWORD *)v79 + 4) = v12[5];
    *((_DWORD *)v79 + 8) = a2[10];
    v79[36] = *((_BYTE *)a2 + 44);
    v79[149] = *((_BYTE *)a2 + 45);
    *((_WORD *)v79 + 75) = *((_WORD *)a2 + 23);
    v104 = *((unsigned __int16 *)a2 + 24);
    *((_WORD *)v79 + 52) = v104;
    *((_WORD *)v79 + 53) = (int)(float)(v33 * (float)v104);
    *((_DWORD *)v79 + 10) = v102;
    *((_WORD *)v79 + 26) = 0;
    v79[55] = v211;
    v79[56] = v214;
    *((_DWORD *)v79 + 15) = 0;
    *((_DWORD *)v79 + 16) = v216;
    v79[120] = v207;
    v79[121] = v213;
    v79[152] = a3;
    v79[153] = v210;
    v79[57] |= *((_BYTE *)v12 + 194);
    *((_QWORD *)v79 + 21) = 0;
    memcpy(v79 + 122, v12 + 14, 2 * v213);
    VCBlockBuffer_Copy(*((_QWORD *)a2 + 4), (uint64_t)(v79 + 72));
    v9 = v101;
    if (v79[55])
    {
      LODWORD(v105) = *(_DWORD *)v217;
      LODWORD(v106) = *((_DWORD *)v79 + 3);
      _VideoPacketBuffer_StartTrackingEvictedFrameStats(v101, (uint64_t)v79, v24 - ((double)v105 - (double)v106) / (double)*(int *)(v101 + 8));
    }
    *((_QWORD *)v79 + 14) = *v78;
    _VideoPacketBuffer_UpdatePreviousFrameSequenceNumber((uint64_t)v79, v81, v202);
    *v78 = v79;
    v107 = *(_QWORD *)(v217 + 16);
    do
    {
      v108 = v107;
      if (!v107)
        break;
      v107 = *(_QWORD *)(v107 + 112);
    }
    while (v107);
    *(_QWORD *)(v217 + 24) = v108;
    if (v211)
      ++*(_DWORD *)(v217 + 124);
    else
      ++*(_DWORD *)(v217 + 120);
    goto LABEL_133;
  }
  v80 = *((_DWORD *)v79 + 3);
  if ((v80 - v14) < 0x7FFFFFFF)
  {
    v81 = 0;
    goto LABEL_95;
  }
  do
  {
    v81 = (uint64_t)v79;
    v79 = (char *)*((_QWORD *)v79 + 14);
    if (!v79)
    {
      v101 = v9;
      v102 = v29;
      v103 = v14;
      v202 = 0;
      v78 = (void **)(v81 + 112);
      goto LABEL_125;
    }
    v80 = *((_DWORD *)v79 + 3);
  }
  while ((v80 - v14) >= 0x7FFFFFFF);
  v78 = (void **)(v81 + 112);
LABEL_95:
  if (v80 != (_DWORD)v14)
  {
    v101 = v9;
    v102 = v29;
    v103 = v14;
    v202 = 1;
    goto LABEL_125;
  }
  if (!v79[36])
    v79[36] = *((_BYTE *)a2 + 44);
  v79[55] = v211;
  v79[56] |= v214;
  v79[57] |= *((_BYTE *)v12 + 194);
  if (*(_DWORD *)v79 == v218)
    v82 = 1;
  else
    v82 = v215;
  if ((v82 & 1) == 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 7)
      goto LABEL_228;
    v157 = VRTraceErrorLogLevelToCSTR();
    v86 = *MEMORY[0x1E0CF2758];
    v87 = (pthread_mutex_t *)(v9 + 352);
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      goto LABEL_227;
    v158 = *(_DWORD *)v79;
    *(_DWORD *)buf = 136316930;
    *(_QWORD *)&buf[4] = v157;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = "VideoPacketBuffer_AddPacket";
    *(_WORD *)&buf[22] = 1024;
    *(_DWORD *)&buf[24] = 1634;
    *(_WORD *)&buf[28] = 2048;
    *(_QWORD *)&buf[30] = v9;
    *(_WORD *)&buf[38] = 1024;
    *(_DWORD *)v221 = v219;
    *(_WORD *)&v221[4] = 2048;
    *(_QWORD *)&v221[6] = v14;
    *(_WORD *)&v221[14] = 1024;
    *(_DWORD *)&v221[16] = v158;
    *(_WORD *)&v221[20] = 1024;
    *(_DWORD *)&v221[22] = v218;
    v90 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] $ Discarding packet %d, frame %lu.  Packet.payload disagree"
          ", first %d, then %d";
LABEL_226:
    _os_log_impl(&dword_1D8A54000, v86, OS_LOG_TYPE_DEFAULT, v90, buf, 0x42u);
    goto LABEL_227;
  }
  if (*((_DWORD *)v79 + 1) == *a2)
    v83 = 1;
  else
    v83 = v215;
  if ((v83 & 1) == 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 7)
      goto LABEL_228;
    v175 = VRTraceErrorLogLevelToCSTR();
    v86 = *MEMORY[0x1E0CF2758];
    v87 = (pthread_mutex_t *)(v9 + 352);
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      goto LABEL_227;
    v176 = *((_DWORD *)v79 + 1);
    v177 = *a2;
    *(_DWORD *)buf = 136316930;
    *(_QWORD *)&buf[4] = v175;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = "VideoPacketBuffer_AddPacket";
    *(_WORD *)&buf[22] = 1024;
    *(_DWORD *)&buf[24] = 1639;
    *(_WORD *)&buf[28] = 2048;
    *(_QWORD *)&buf[30] = v9;
    *(_WORD *)&buf[38] = 1024;
    *(_DWORD *)v221 = v219;
    *(_WORD *)&v221[4] = 2048;
    *(_QWORD *)&v221[6] = v14;
    *(_WORD *)&v221[14] = 1024;
    *(_DWORD *)&v221[16] = v176;
    *(_WORD *)&v221[20] = 1024;
    *(_DWORD *)&v221[22] = v177;
    v90 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] $ Discarding packet %d, frame %lu.  Packet.srcfmt disagree,"
          " first %d, then %d";
    goto LABEL_226;
  }
  if (*((_DWORD *)v79 + 2) == a2[1])
    v84 = 1;
  else
    v84 = v215;
  if ((v84 & 1) == 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v85 = VRTraceErrorLogLevelToCSTR();
      v86 = *MEMORY[0x1E0CF2758];
      v87 = (pthread_mutex_t *)(v9 + 352);
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v88 = *((_DWORD *)v79 + 2);
        v89 = a2[1];
        *(_DWORD *)buf = 136316930;
        *(_QWORD *)&buf[4] = v85;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "VideoPacketBuffer_AddPacket";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 1644;
        *(_WORD *)&buf[28] = 2048;
        *(_QWORD *)&buf[30] = v9;
        *(_WORD *)&buf[38] = 1024;
        *(_DWORD *)v221 = v219;
        *(_WORD *)&v221[4] = 2048;
        *(_QWORD *)&v221[6] = v14;
        *(_WORD *)&v221[14] = 1024;
        *(_DWORD *)&v221[16] = v88;
        *(_WORD *)&v221[20] = 1024;
        *(_DWORD *)&v221[22] = v89;
        v90 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] $ Discarding packet %d, frame %lu.  Packet.pctype disag"
              "ree, first %d, then %d";
        goto LABEL_226;
      }
LABEL_227:
      v100 = 0;
      goto LABEL_221;
    }
LABEL_228:
    v100 = 0;
    v87 = (pthread_mutex_t *)(v9 + 352);
    goto LABEL_221;
  }
LABEL_133:
  if (*((_BYTE *)v12 + 194))
  {
    if (*(_BYTE *)(v9 + 242))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v109 = VRTraceErrorLogLevelToCSTR();
        v110 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v111 = v12[5];
          v112 = *((unsigned __int16 *)v12 + 6);
          v113 = *((_QWORD *)v12 + 14);
          v114 = *((unsigned __int8 *)v12 + 194);
          v115 = *((unsigned __int16 *)v79 + 75);
          *(_DWORD *)buf = 136316930;
          *(_QWORD *)&buf[4] = v109;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "VideoPacketBuffer_AddPacket";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 1650;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = v111;
          *(_WORD *)&buf[34] = 1024;
          *(_DWORD *)&buf[36] = v112;
          *(_WORD *)v221 = 1024;
          *(_DWORD *)&v221[2] = v113;
          *(_WORD *)&v221[6] = 1024;
          *(_DWORD *)&v221[8] = v114;
          *(_WORD *)&v221[12] = 1024;
          *(_DWORD *)&v221[14] = v115;
          _os_log_impl(&dword_1D8A54000, v110, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d Retransmitted packet arrived ssrc=%u seqNum=%u packetLen=%d isRetransmitted=%d frameSequenceNumber=%d", buf, 0x3Au);
        }
      }
    }
  }
  if (v79[54])
    v116 = 1;
  else
    v116 = *((_BYTE *)v12 + 40) != 0;
  LODWORD(v117) = v219;
  v79[54] = v116;
  v118 = *((double *)v12 + 4);
  if (v118 > *((double *)v79 + 3))
    *((double *)v79 + 3) = v118;
  if (v208 && *(_BYTE *)(v9 + 240))
  {
    if (v79[148])
    {
      if (*((unsigned __int16 *)v79 + 73) != v205)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v119 = VRTraceErrorLogLevelToCSTR();
          v120 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            v201 = *((unsigned __int16 *)v79 + 73);
            *(_DWORD *)buf = 136316418;
            *(_QWORD *)&buf[4] = v119;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VideoPacketBuffer_UpdateFrameDecodingOrder";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 1235;
            *(_WORD *)&buf[28] = 2048;
            *(_QWORD *)&buf[30] = v9;
            *(_WORD *)&buf[38] = 1024;
            *(_DWORD *)v221 = v201;
            *(_WORD *)&v221[4] = 1024;
            *(_DWORD *)&v221[6] = v205;
            _os_log_error_impl(&dword_1D8A54000, v120, OS_LOG_TYPE_ERROR, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Decoding order is different within a frame. Previous:%d New:%d", buf, 0x32u);
          }
        }
        *((_WORD *)v79 + 73) = v205;
        LODWORD(v117) = v219;
      }
    }
    else
    {
      *((_WORD *)v79 + 73) = v205;
      v79[148] = 1;
    }
  }
  v122 = v79 + 96;
  v121 = (unsigned __int16 *)*((_QWORD *)v79 + 12);
  if (!v121)
    goto LABEL_186;
  v123 = (_DWORD *)*((_QWORD *)a2 + 7);
  while (2)
  {
    v124 = *v121;
    if (v124 != (_DWORD)v117 && (unsigned __int16)(v124 - v117) < 0x7FFFu)
      goto LABEL_186;
    if (v124 != (_DWORD)v117)
      goto LABEL_185;
    if (v123 && *v123)
    {
      v125 = v123[2];
      v126 = HIWORD(v125) & 0x80;
      if (v125 >> 30)
        v126 = v125 & 0x400000;
      if (!v126)
      {
        if (v125 >> 30)
          v127 = 15;
        else
          v127 = 16;
        if (v125 >> 30)
          v128 = (v125 >> 23) & 0xF;
        else
          v128 = HIBYTE(v125) & 7;
        if (*((_DWORD *)v121 + 6))
        {
          v129 = *((_DWORD *)v121 + 8);
          v130 = v129 >> 23;
          v131 = v129 >> 30;
          if (v129 >> 30)
            LOBYTE(v130) = v129 >> 22;
          if ((v130 & 1) == 0)
          {
            v132 = (v125 >> v127) & 0x7F;
            if (v131)
              v133 = 15;
            else
              v133 = 16;
            v134 = (v129 >> v133) & 0x7F;
            v135 = HIBYTE(v129) & 7;
            v136 = (v129 >> 23) & 0xF;
            if (v131)
              v135 = v136;
            if (v128 != v135 || v132 != v134)
            {
              v137 = v128 < v135;
              v138 = v132 >= v134;
              v139 = v132 == v134 && v137;
              if (v138 && !v139)
                goto LABEL_185;
              if ((int)VRTraceGetErrorLogLevelForModule() < 8)
                goto LABEL_186;
              v117 = VRTraceErrorLogLevelToCSTR();
              v189 = *MEMORY[0x1E0CF2758];
              v190 = *MEMORY[0x1E0CF2758];
              if (*MEMORY[0x1E0CF2748])
              {
                if (os_log_type_enabled(v190, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 136316674;
                  *(_QWORD *)&buf[4] = v117;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = "_VideoPacketBuffer_ShouldInsertParityPacketBeforePacket";
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&buf[24] = 1263;
                  *(_WORD *)&buf[28] = 1024;
                  LOWORD(v117) = v219;
                  *(_DWORD *)&buf[30] = v219;
                  *(_WORD *)&buf[34] = 1024;
                  *(_DWORD *)&buf[36] = 1;
                  *(_WORD *)v221 = 1024;
                  *(_DWORD *)&v221[2] = v132;
                  *(_WORD *)&v221[6] = 1024;
                  *(_DWORD *)&v221[8] = v128;
                  v168 = "VideoPacketBuffer [%s] %s:%d Out of order parity packet! Incoming packet with sequenceNumber=%d"
                         ", isParity=%d, groupID=%d, startPosition=%d";
                  v169 = v189;
LABEL_245:
                  _os_log_impl(&dword_1D8A54000, v169, OS_LOG_TYPE_DEFAULT, v168, buf, 0x34u);
                  goto LABEL_186;
                }
                goto LABEL_256;
              }
              if (!os_log_type_enabled(v190, OS_LOG_TYPE_DEBUG))
                goto LABEL_256;
              *(_DWORD *)buf = 136316674;
              *(_QWORD *)&buf[4] = v117;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_VideoPacketBuffer_ShouldInsertParityPacketBeforePacket";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 1263;
              *(_WORD *)&buf[28] = 1024;
              LOWORD(v117) = v219;
              *(_DWORD *)&buf[30] = v219;
              *(_WORD *)&buf[34] = 1024;
              *(_DWORD *)&buf[36] = 1;
              *(_WORD *)v221 = 1024;
              *(_DWORD *)&v221[2] = v132;
              *(_WORD *)&v221[6] = 1024;
              *(_DWORD *)&v221[8] = v128;
              v197 = "VideoPacketBuffer [%s] %s:%d Out of order parity packet! Incoming packet with sequenceNumber=%d, is"
                     "Parity=%d, groupID=%d, startPosition=%d";
              v198 = v189;
LABEL_259:
              _os_log_debug_impl(&dword_1D8A54000, v198, OS_LOG_TYPE_DEBUG, v197, buf, 0x34u);
              goto LABEL_186;
            }
            v87 = v212;
            if ((int)VRTraceGetErrorLogLevelForModule() < 8)
              goto LABEL_254;
            v186 = VRTraceErrorLogLevelToCSTR();
            v187 = *MEMORY[0x1E0CF2758];
            v188 = *MEMORY[0x1E0CF2758];
            if (*MEMORY[0x1E0CF2748])
            {
              if (os_log_type_enabled(v188, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136316674;
                *(_QWORD *)&buf[4] = v186;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "_VideoPacketBuffer_ShouldInsertParityPacketBeforePacket";
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&buf[24] = 1257;
                *(_WORD *)&buf[28] = 1024;
                *(_DWORD *)&buf[30] = v219;
                *(_WORD *)&buf[34] = 1024;
                *(_DWORD *)&buf[36] = 1;
                *(_WORD *)v221 = 1024;
                *(_DWORD *)&v221[2] = v132;
                *(_WORD *)&v221[6] = 1024;
                *(_DWORD *)&v221[8] = v128;
                v155 = "VideoPacketBuffer [%s] %s:%d Duplicate parity packet! Incoming packet with sequenceNumber=%d, isP"
                       "arity=%d, groupID=%d, startPosition=%d";
                v156 = v187;
                goto LABEL_203;
              }
              goto LABEL_254;
            }
            if (!os_log_type_enabled(v188, OS_LOG_TYPE_DEBUG))
              goto LABEL_254;
            *(_DWORD *)buf = 136316674;
            *(_QWORD *)&buf[4] = v186;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VideoPacketBuffer_ShouldInsertParityPacketBeforePacket";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 1257;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = v219;
            *(_WORD *)&buf[34] = 1024;
            *(_DWORD *)&buf[36] = 1;
            *(_WORD *)v221 = 1024;
            *(_DWORD *)&v221[2] = v132;
            *(_WORD *)&v221[6] = 1024;
            *(_DWORD *)&v221[8] = v128;
            v184 = "VideoPacketBuffer [%s] %s:%d Duplicate parity packet! Incoming packet with sequenceNumber=%d, isParit"
                   "y=%d, groupID=%d, startPosition=%d";
            v185 = v187;
            goto LABEL_236;
          }
        }
LABEL_185:
        v122 = v121 + 52;
        v121 = (unsigned __int16 *)*((_QWORD *)v121 + 13);
        if (!v121)
          goto LABEL_186;
        continue;
      }
    }
    break;
  }
  if (!*((_DWORD *)v121 + 6))
    goto LABEL_194;
  v145 = *((_DWORD *)v121 + 8);
  if (v145 >> 30)
  {
    if ((v145 & 0x400000) == 0)
      goto LABEL_209;
LABEL_194:
    v87 = v212;
    if ((int)VRTraceGetErrorLogLevelForModule() < 8)
      goto LABEL_254;
    v146 = VRTraceErrorLogLevelToCSTR();
    v147 = *MEMORY[0x1E0CF2758];
    v148 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v148, OS_LOG_TYPE_DEFAULT))
      {
        v149 = v123[2];
        v150 = v149 >> 30 == 0;
        if (v149 >> 30)
          v151 = 15;
        else
          v151 = 16;
        *(_DWORD *)buf = 136316674;
        v152 = (v149 >> v151) & 0x7F;
        *(_QWORD *)&buf[4] = v146;
        v153 = HIBYTE(v149) & 7;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VideoPacketBuffer_ShouldInsertNonParityPacketBeforePacket";
        v154 = (v149 >> 23) & 0xF;
        *(_WORD *)&buf[22] = 1024;
        if (v150)
          v154 = v153;
        *(_DWORD *)&buf[24] = 1278;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v219;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = 0;
        *(_WORD *)v221 = 1024;
        *(_DWORD *)&v221[2] = v152;
        *(_WORD *)&v221[6] = 1024;
        *(_DWORD *)&v221[8] = v154;
        v155 = "VideoPacketBuffer [%s] %s:%d Duplicate non-partity packet! Incoming packet with sequenceNumber=%d, isPari"
               "ty=%d, groupID=%d, startPosition=%d";
        v156 = v147;
LABEL_203:
        _os_log_impl(&dword_1D8A54000, v156, OS_LOG_TYPE_DEFAULT, v155, buf, 0x34u);
      }
LABEL_254:
      v100 = 0;
      ++*((_DWORD *)v121 + 24);
      goto LABEL_221;
    }
    if (!os_log_type_enabled(v148, OS_LOG_TYPE_DEBUG))
      goto LABEL_254;
    v178 = v123[2];
    v179 = v178 >> 30 == 0;
    if (v178 >> 30)
      v180 = 15;
    else
      v180 = 16;
    *(_DWORD *)buf = 136316674;
    v181 = (v178 >> v180) & 0x7F;
    *(_QWORD *)&buf[4] = v146;
    v182 = HIBYTE(v178) & 7;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = "_VideoPacketBuffer_ShouldInsertNonParityPacketBeforePacket";
    v183 = (v178 >> 23) & 0xF;
    *(_WORD *)&buf[22] = 1024;
    if (v179)
      v183 = v182;
    *(_DWORD *)&buf[24] = 1278;
    *(_WORD *)&buf[28] = 1024;
    *(_DWORD *)&buf[30] = v219;
    *(_WORD *)&buf[34] = 1024;
    *(_DWORD *)&buf[36] = 0;
    *(_WORD *)v221 = 1024;
    *(_DWORD *)&v221[2] = v181;
    *(_WORD *)&v221[6] = 1024;
    *(_DWORD *)&v221[8] = v183;
    v184 = "VideoPacketBuffer [%s] %s:%d Duplicate non-partity packet! Incoming packet with sequenceNumber=%d, isParity=%"
           "d, groupID=%d, startPosition=%d";
    v185 = v147;
LABEL_236:
    _os_log_debug_impl(&dword_1D8A54000, v185, OS_LOG_TYPE_DEBUG, v184, buf, 0x34u);
    goto LABEL_254;
  }
  if ((v145 & 0x800000) != 0)
    goto LABEL_194;
LABEL_209:
  if ((int)VRTraceGetErrorLogLevelForModule() < 8)
    goto LABEL_186;
  v159 = VRTraceErrorLogLevelToCSTR();
  v160 = *MEMORY[0x1E0CF2758];
  v161 = *MEMORY[0x1E0CF2758];
  if (!*MEMORY[0x1E0CF2748])
  {
    if (!os_log_type_enabled(v161, OS_LOG_TYPE_DEBUG))
      goto LABEL_256;
    v191 = v123[2];
    v192 = v191 >> 30 == 0;
    if (v191 >> 30)
      v193 = 15;
    else
      v193 = 16;
    *(_DWORD *)buf = 136316674;
    v194 = (v191 >> v193) & 0x7F;
    *(_QWORD *)&buf[4] = v159;
    v195 = HIBYTE(v191) & 7;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = "_VideoPacketBuffer_ShouldInsertNonParityPacketBeforePacket";
    v196 = (v191 >> 23) & 0xF;
    *(_WORD *)&buf[22] = 1024;
    if (v192)
      v196 = v195;
    *(_DWORD *)&buf[24] = 1274;
    *(_WORD *)&buf[28] = 1024;
    LOWORD(v117) = v219;
    *(_DWORD *)&buf[30] = v219;
    *(_WORD *)&buf[34] = 1024;
    *(_DWORD *)&buf[36] = 0;
    *(_WORD *)v221 = 1024;
    *(_DWORD *)&v221[2] = v194;
    *(_WORD *)&v221[6] = 1024;
    *(_DWORD *)&v221[8] = v196;
    v197 = "VideoPacketBuffer [%s] %s:%d Out of order non-parity packet. Incoming packet with sequenceNumber=%d, isParity"
           "=%d, groupID=%d, startPosition=%d";
    v198 = v160;
    goto LABEL_259;
  }
  if (os_log_type_enabled(v161, OS_LOG_TYPE_DEFAULT))
  {
    v162 = v123[2];
    v163 = v162 >> 30 == 0;
    if (v162 >> 30)
      v164 = 15;
    else
      v164 = 16;
    *(_DWORD *)buf = 136316674;
    v165 = (v162 >> v164) & 0x7F;
    *(_QWORD *)&buf[4] = v159;
    v166 = HIBYTE(v162) & 7;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = "_VideoPacketBuffer_ShouldInsertNonParityPacketBeforePacket";
    v167 = (v162 >> 23) & 0xF;
    *(_WORD *)&buf[22] = 1024;
    if (v163)
      v167 = v166;
    *(_DWORD *)&buf[24] = 1274;
    *(_WORD *)&buf[28] = 1024;
    LOWORD(v117) = v219;
    *(_DWORD *)&buf[30] = v219;
    *(_WORD *)&buf[34] = 1024;
    *(_DWORD *)&buf[36] = 0;
    *(_WORD *)v221 = 1024;
    *(_DWORD *)&v221[2] = v165;
    *(_WORD *)&v221[6] = 1024;
    *(_DWORD *)&v221[8] = v167;
    v168 = "VideoPacketBuffer [%s] %s:%d Out of order non-parity packet. Incoming packet with sequenceNumber=%d, isParity"
           "=%d, groupID=%d, startPosition=%d";
    v169 = v160;
    goto LABEL_245;
  }
LABEL_256:
  LOWORD(v117) = v219;
LABEL_186:
  v140 = (char *)VCMemoryPool_Alloc(*(OSQueueHead **)(v217 + 136));
  *((_DWORD *)v140 + 20) = 0;
  *(_WORD *)v140 = v117;
  *((_QWORD *)v140 + 1) = *((_QWORD *)a2 + 1);
  *((_DWORD *)v140 + 4) = v204;
  *((_QWORD *)v140 + 11) = *((_QWORD *)v12 + 4);
  *((_DWORD *)v140 + 21) = v12[4];
  *((_DWORD *)v140 + 24) = 1;
  v140[112] = *((_BYTE *)v12 + 194);
  VCBlockBuffer_Copy(*((_QWORD *)a2 + 2), (uint64_t)(v140 + 120));
  v87 = v212;
  if (v203)
  {
    **((_DWORD **)a2 + 7) = 0;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v141 = VRTraceErrorLogLevelToCSTR();
      v142 = *MEMORY[0x1E0CF2758];
      v143 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v143, OS_LOG_TYPE_DEFAULT))
        {
          v144 = *((unsigned __int16 *)a2 + 23);
          *(_DWORD *)buf = 136315906;
          *(_QWORD *)&buf[4] = v141;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "VideoPacketBuffer_AddPacket";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 1681;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = v144;
          _os_log_impl(&dword_1D8A54000, v142, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d invalidating fecHeader for frame with frameSequenceNumber:%d", buf, 0x22u);
        }
      }
      else if (os_log_type_enabled(v143, OS_LOG_TYPE_DEBUG))
      {
        VideoPacketBuffer_AddPacket_cold_2();
      }
    }
  }
  v170 = (__int128 *)*((_QWORD *)a2 + 7);
  v171 = *v170;
  v172 = v170[1];
  v173 = v170[2];
  *((_QWORD *)v140 + 9) = *((_QWORD *)v170 + 6);
  *(_OWORD *)(v140 + 56) = v173;
  *(_OWORD *)(v140 + 40) = v172;
  *(_OWORD *)(v140 + 24) = v171;
  *((_QWORD *)v140 + 13) = *v122;
  *v122 = v140;
  v100 = 1;
LABEL_221:
  *((_WORD *)v79 + 55) += v215;
  *((_WORD *)v79 + 54) += v206;
  _VideoPacketBuffer_CorrectFrameStats(v9, *((unsigned __int16 *)a2 + 23), v215);
  pthread_mutex_unlock(v87);
  return v100;
}

void _VideoPacketBuffer_CorrectFrameStats(uint64_t a1, int a2, int a3)
{
  unsigned int v3;
  uint64_t v7;
  uint64_t v8;
  int v9;
  BOOL v10;
  __int16 v11;
  uint64_t v12;
  NSObject *v13;
  NSObject *v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  __int16 v31;
  unsigned int v32;
  __int16 v33;
  int v34;
  __int16 v35;
  int v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v3 = a2 & 0x7F;
  if (*(_DWORD *)(a1 + 800 * (a2 & 0x7F) + 42688) == a2)
  {
    v7 = a1 + 800 * (a2 & 0x7F);
    if ((a3 & 1) != 0)
      v8 = 42704;
    else
      v8 = 42702;
    v9 = *(unsigned __int16 *)(v7 + v8);
    v10 = v9 != 0;
    v11 = v9 - 1;
    if (!v10)
      v11 = 0;
    *(_WORD *)(v7 + v8) = v11;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v12 = VRTraceErrorLogLevelToCSTR();
      v13 = *MEMORY[0x1E0CF2758];
      v14 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          v15 = *(unsigned __int16 *)(a1 + 800 * v3 + 42702);
          v16 = *(unsigned __int16 *)(a1 + 800 * v3 + 42704);
          v19 = 136317186;
          v20 = v12;
          v21 = 2080;
          v22 = "_VideoPacketBuffer_CorrectFrameStats";
          v23 = 1024;
          v24 = 728;
          v25 = 2048;
          v26 = a1;
          v27 = 1024;
          v28 = a2;
          v29 = 1024;
          v30 = a3;
          v31 = 1024;
          v32 = v3;
          v33 = 1024;
          v34 = v15;
          v35 = 1024;
          v36 = v16;
          _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Correct loss frameSequenceNumber=%d isParity=%d frameIndex=%d maxVideoPacketsLostPerFrame=%d maxParityPacketsLostPerFrame=%d", (uint8_t *)&v19, 0x44u);
        }
      }
      else if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        v17 = *(unsigned __int16 *)(a1 + 800 * v3 + 42702);
        v18 = *(unsigned __int16 *)(a1 + 800 * v3 + 42704);
        v19 = 136317186;
        v20 = v12;
        v21 = 2080;
        v22 = "_VideoPacketBuffer_CorrectFrameStats";
        v23 = 1024;
        v24 = 728;
        v25 = 2048;
        v26 = a1;
        v27 = 1024;
        v28 = a2;
        v29 = 1024;
        v30 = a3;
        v31 = 1024;
        v32 = v3;
        v33 = 1024;
        v34 = v17;
        v35 = 1024;
        v36 = v18;
        _os_log_debug_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEBUG, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Correct loss frameSequenceNumber=%d isParity=%d frameIndex=%d maxVideoPacketsLostPerFrame=%d maxParityPacketsLostPerFrame=%d", (uint8_t *)&v19, 0x44u);
      }
    }
  }
}

void _VideoPacketBuffer_StartTrackingEvictedFrameStats(uint64_t a1, uint64_t a2, double a3)
{
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  uint64_t v8;
  const char *v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VideoPacketBuffer_StartTrackingEvictedFrameStats_cold_1();
    }
    return;
  }
  if (*(double *)(a2 + 168) == 0.0)
  {
    ++*(_DWORD *)(a1 + 1036);
    *(double *)(a2 + 168) = a3;
    if ((int)VRTraceGetErrorLogLevelForModule() < 8)
      return;
    v5 = VRTraceErrorLogLevelToCSTR();
    v6 = *MEMORY[0x1E0CF2758];
    v7 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        v8 = *(_QWORD *)(a2 + 168);
        v16 = 136316418;
        v17 = v5;
        v18 = 2080;
        v19 = "_VideoPacketBuffer_StartTrackingEvictedFrameStats";
        v20 = 1024;
        v21 = 1326;
        v22 = 2048;
        v23 = a1;
        v24 = 2048;
        v25 = a2;
        v26 = 2048;
        v27 = v8;
        v9 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Starting to track late frame[%p] at t=%.4f";
LABEL_11:
        _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v16, 0x3Au);
        return;
      }
      return;
    }
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      return;
    v13 = *(_QWORD *)(a2 + 168);
    v16 = 136316418;
    v17 = v5;
    v18 = 2080;
    v19 = "_VideoPacketBuffer_StartTrackingEvictedFrameStats";
    v20 = 1024;
    v21 = 1326;
    v22 = 2048;
    v23 = a1;
    v24 = 2048;
    v25 = a2;
    v26 = 2048;
    v27 = v13;
    v14 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Starting to track late frame[%p] at t=%.4f";
LABEL_17:
    _os_log_debug_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEBUG, v14, (uint8_t *)&v16, 0x3Au);
    return;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() < 8)
    return;
  v10 = VRTraceErrorLogLevelToCSTR();
  v6 = *MEMORY[0x1E0CF2758];
  v11 = *MEMORY[0x1E0CF2758];
  if (!*MEMORY[0x1E0CF2748])
  {
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      return;
    v15 = *(_QWORD *)(a2 + 168);
    v16 = 136316418;
    v17 = v10;
    v18 = 2080;
    v19 = "_VideoPacketBuffer_StartTrackingEvictedFrameStats";
    v20 = 1024;
    v21 = 1328;
    v22 = 2048;
    v23 = a1;
    v24 = 2048;
    v25 = a2;
    v26 = 2048;
    v27 = v15;
    v14 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Already tracking frame=%p with t=%.4f";
    goto LABEL_17;
  }
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v12 = *(_QWORD *)(a2 + 168);
    v16 = 136316418;
    v17 = v10;
    v18 = 2080;
    v19 = "_VideoPacketBuffer_StartTrackingEvictedFrameStats";
    v20 = 1024;
    v21 = 1328;
    v22 = 2048;
    v23 = a1;
    v24 = 2048;
    v25 = a2;
    v26 = 2048;
    v27 = v12;
    v9 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Already tracking frame=%p with t=%.4f";
    goto LABEL_11;
  }
}

void _VideoPacketBuffer_UpdatePreviousFrameSequenceNumber(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  int v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  int v24;
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if (a3)
  {
    v5 = *(_QWORD *)(a1 + 112);
    if (v5)
    {
      *(_DWORD *)(v5 + 156) = *(unsigned __int16 *)(a1 + 150);
      *(_BYTE *)(v5 + 160) = *(_BYTE *)(a1 + 149);
    }
  }
  if (a2)
  {
    *(_DWORD *)(a1 + 156) = *(unsigned __int16 *)(a2 + 150);
    *(_BYTE *)(a1 + 160) = *(_BYTE *)(a1 + 149);
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v6 = VRTraceErrorLogLevelToCSTR();
    v7 = *MEMORY[0x1E0CF2758];
    v8 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        v9 = *(unsigned __int16 *)(a1 + 150);
        v10 = *(_DWORD *)(a1 + 156);
        v11 = *(_QWORD *)(a1 + 112);
        if (v11)
        {
          v12 = *(unsigned __int16 *)(v11 + 150);
          LODWORD(v11) = *(_DWORD *)(v11 + 156);
        }
        else
        {
          v12 = 0;
        }
        v17 = 136316930;
        v18 = v6;
        v19 = 2080;
        v20 = "_VideoPacketBuffer_UpdatePreviousFrameSequenceNumber";
        v21 = 1024;
        v22 = 1420;
        v23 = 1024;
        v24 = a3;
        v25 = 1024;
        v26 = v9;
        v27 = 1024;
        v28 = v10;
        v29 = 1024;
        v30 = v12;
        v31 = 1024;
        v32 = v11;
        _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d isNewFrameOufOfOrder=%d, newFrame->seq=%d, newFrame->prevSeq=%d, newFrame->nextSeq=%d, newFrame->next->prevSeq=%d", (uint8_t *)&v17, 0x3Au);
      }
    }
    else if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      v13 = *(unsigned __int16 *)(a1 + 150);
      v14 = *(_DWORD *)(a1 + 156);
      v15 = *(_QWORD *)(a1 + 112);
      if (v15)
      {
        v16 = *(unsigned __int16 *)(v15 + 150);
        LODWORD(v15) = *(_DWORD *)(v15 + 156);
      }
      else
      {
        v16 = 0;
      }
      v17 = 136316930;
      v18 = v6;
      v19 = 2080;
      v20 = "_VideoPacketBuffer_UpdatePreviousFrameSequenceNumber";
      v21 = 1024;
      v22 = 1420;
      v23 = 1024;
      v24 = a3;
      v25 = 1024;
      v26 = v13;
      v27 = 1024;
      v28 = v14;
      v29 = 1024;
      v30 = v16;
      v31 = 1024;
      v32 = v15;
      _os_log_debug_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEBUG, "VideoPacketBuffer [%s] %s:%d isNewFrameOufOfOrder=%d, newFrame->seq=%d, newFrame->prevSeq=%d, newFrame->nextSeq=%d, newFrame->next->prevSeq=%d", (uint8_t *)&v17, 0x3Au);
    }
  }
}

BOOL VideoPacketBuffer_ScheduleFutureFrame(uint64_t a1, int a2, int a3, _DWORD *a4, unsigned int a5, int a6, int a7, double a8)
{
  unsigned int *v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  int v19;
  _BOOL4 v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  NSObject *v25;
  NSObject *v26;
  unint64_t v27;
  double v28;
  int v29;
  uint64_t v30;
  NSObject *v31;
  unsigned int v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  int ErrorLogLevelForModule;
  uint64_t v37;
  NSObject *v38;
  NSObject *v39;
  unsigned int v40;
  int v41;
  int v42;
  int v43;
  const char *v44;
  NSObject *v45;
  uint32_t v46;
  uint64_t v47;
  NSObject *v48;
  unsigned int v49;
  unsigned int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  uint64_t v57;
  NSObject *v58;
  NSObject *v59;
  unsigned int v60;
  unsigned int v61;
  int v62;
  int v63;
  int v64;
  const char *v65;
  NSObject *v66;
  uint32_t v67;
  uint64_t v68;
  NSObject *v69;
  NSObject *v70;
  unsigned int v71;
  uint64_t *v73;
  pthread_mutex_t *v74;
  uint8_t buf[4];
  uint64_t v77;
  __int16 v78;
  const char *v79;
  __int16 v80;
  int v81;
  __int16 v82;
  uint64_t v83;
  __int16 v84;
  unsigned int v85;
  __int16 v86;
  unsigned int v87;
  __int16 v88;
  _BYTE v89[10];
  __int16 v90;
  int v91;
  __int16 v92;
  int v93;
  __int16 v94;
  int v95;
  __int16 v96;
  int v97;
  __int16 v98;
  int v99;
  __int16 v100;
  int v101;
  __int16 v102;
  int v103;
  __int16 v104;
  int v105;
  uint64_t v106;

  v106 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoPacketBuffer_ScheduleFutureFrame_cold_1();
    }
    return 0;
  }
  if (!a4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoPacketBuffer_ScheduleFutureFrame_cold_2();
    }
    return 0;
  }
  v15 = (unsigned int *)(a1 + 145888);
  v74 = (pthread_mutex_t *)(a1 + 352);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 352));
  *v15 = a5;
  v16 = *(_QWORD *)(a1 + 146088);
  if (v16)
    VCNACKGenerator_UpdatePlayoutRTPTimestamp(v16, a2, a5);
  v17 = *(_QWORD *)(a1 + 145896);
  if (v17)
  {
    v73 = (uint64_t *)(v15 + 2);
    v18 = 0;
    while (1)
    {
      *(_BYTE *)(v17 + 55) = 0;
      v19 = *(_DWORD *)(v17 + 12);
      if (a3 == v19 || (a3 - v19) >= 0x7FFFFFFF)
      {
        if (a3 == v19 && !*(_DWORD *)(v17 + 48))
          v18 = _VideoPacketBuffer_ScheduleSingleFrame(a1, v17, a4, a5, a6, a7);
        goto LABEL_83;
      }
      if (*(_DWORD *)(v17 + 48))
      {
        v22 = *(_QWORD *)(v17 + 112);
      }
      else
      {
        v21 = _VideoPacketBuffer_ScheduleSingleFrame(a1, v17, a4, a5, a6, a7);
        if (a5 && a5 - *(_DWORD *)(v17 + 12) >= 0x7FFFFFFF)
        {
          if (v21)
          {
LABEL_17:
            v18 = v21;
            goto LABEL_83;
          }
          ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
          if (ErrorLogLevelForModule >= 8)
          {
            v37 = VRTraceErrorLogLevelToCSTR();
            v38 = *MEMORY[0x1E0CF2758];
            v39 = *MEMORY[0x1E0CF2758];
            if (*MEMORY[0x1E0CF2748])
            {
              v18 = 0;
              if (!os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
                goto LABEL_83;
              v40 = **(unsigned __int16 **)(v17 + 96);
              v41 = *(_DWORD *)(v17 + 12);
              v42 = *(unsigned __int16 *)(v17 + 150);
              v43 = *(_DWORD *)(v17 + 156);
              *(_DWORD *)buf = 136317442;
              v77 = v37;
              v78 = 2080;
              v79 = "VideoPacketBuffer_ScheduleFutureFrame";
              v80 = 1024;
              v81 = 1925;
              v82 = 2048;
              v83 = a1;
              v84 = 1024;
              v85 = v40;
              v86 = 1024;
              v87 = a5;
              v88 = 1024;
              *(_DWORD *)v89 = v41;
              *(_WORD *)&v89[4] = 1024;
              *(_DWORD *)&v89[6] = v41 - a5;
              v90 = 1024;
              v91 = v42;
              v92 = 1024;
              v93 = v43;
              v44 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] seq:%u playoutRTPTimestamp:%u frameTimestamp:%u d"
                    "iff:%d frameSequenceNumber=%d previousFrameSequenceNumber=%d";
              v45 = v38;
              v46 = 74;
LABEL_72:
              _os_log_impl(&dword_1D8A54000, v45, OS_LOG_TYPE_DEFAULT, v44, buf, v46);
              break;
            }
            if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
            {
              v61 = **(unsigned __int16 **)(v17 + 96);
              v62 = *(_DWORD *)(v17 + 12);
              v63 = *(unsigned __int16 *)(v17 + 150);
              v64 = *(_DWORD *)(v17 + 156);
              *(_DWORD *)buf = 136317442;
              v77 = v37;
              v78 = 2080;
              v79 = "VideoPacketBuffer_ScheduleFutureFrame";
              v80 = 1024;
              v81 = 1925;
              v82 = 2048;
              v83 = a1;
              v84 = 1024;
              v85 = v61;
              v86 = 1024;
              v87 = a5;
              v88 = 1024;
              *(_DWORD *)v89 = v62;
              *(_WORD *)&v89[4] = 1024;
              *(_DWORD *)&v89[6] = v62 - a5;
              v90 = 1024;
              v91 = v63;
              v92 = 1024;
              v93 = v64;
              v65 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] seq:%u playoutRTPTimestamp:%u frameTimestamp:%u d"
                    "iff:%d frameSequenceNumber=%d previousFrameSequenceNumber=%d";
              v66 = v38;
              v67 = 74;
LABEL_81:
              _os_log_debug_impl(&dword_1D8A54000, v66, OS_LOG_TYPE_DEBUG, v65, buf, v67);
              break;
            }
          }
          break;
        }
        if (v21)
          goto LABEL_17;
        if (*(_BYTE *)(a1 + 240))
        {
          if (*(_BYTE *)(v17 + 148))
          {
            if (a6)
            {
              v23 = *(unsigned __int16 *)(v17 + 146) - a7;
              if (v23)
              {
                if ((unsigned __int16)v23 <= 0x7FFEu)
                {
                  if ((int)VRTraceGetErrorLogLevelForModule() < 8)
                    break;
                  v57 = VRTraceErrorLogLevelToCSTR();
                  v58 = *MEMORY[0x1E0CF2758];
                  v59 = *MEMORY[0x1E0CF2758];
                  if (*MEMORY[0x1E0CF2748])
                  {
                    v18 = 0;
                    if (!os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
                      goto LABEL_83;
                    v60 = *(unsigned __int16 *)(v17 + 146);
                    *(_DWORD *)buf = 136316418;
                    v77 = v57;
                    v78 = 2080;
                    v79 = "VideoPacketBuffer_ScheduleFutureFrame";
                    v80 = 1024;
                    v81 = 1932;
                    v82 = 2048;
                    v83 = a1;
                    v84 = 1024;
                    v85 = v60;
                    v86 = 1024;
                    v87 = a7;
                    v44 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] frameDecodingOrder:%hu, expectedDecodingOrder:%hu";
                    v45 = v58;
                    v46 = 50;
                    goto LABEL_72;
                  }
                  if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG))
                  {
                    v71 = *(unsigned __int16 *)(v17 + 146);
                    *(_DWORD *)buf = 136316418;
                    v77 = v57;
                    v78 = 2080;
                    v79 = "VideoPacketBuffer_ScheduleFutureFrame";
                    v80 = 1024;
                    v81 = 1932;
                    v82 = 2048;
                    v83 = a1;
                    v84 = 1024;
                    v85 = v71;
                    v86 = 1024;
                    v87 = a7;
                    v65 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] frameDecodingOrder:%hu, expectedDecodingOrder:%hu";
                    v66 = v58;
                    v67 = 50;
                    goto LABEL_81;
                  }
                  break;
                }
              }
            }
          }
        }
        if (*(_DWORD *)(v17 + 40)
          && !*(_DWORD *)(v17 + 44)
          && VideoPacketBuffer_FrameReadyForRecovery(v17))
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            v24 = VRTraceErrorLogLevelToCSTR();
            v25 = *MEMORY[0x1E0CF2758];
            v26 = *MEMORY[0x1E0CF2758];
            if (*MEMORY[0x1E0CF2748])
            {
              if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315906;
                v77 = v24;
                v78 = 2080;
                v79 = "VideoPacketBuffer_ScheduleFutureFrame";
                v80 = 1024;
                v81 = 1939;
                v82 = 2048;
                v83 = a1;
                _os_log_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] FEC Protected Frame begin recovery", buf, 0x26u);
              }
            }
            else if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136315906;
              v77 = v24;
              v78 = 2080;
              v79 = "VideoPacketBuffer_ScheduleFutureFrame";
              v80 = 1024;
              v81 = 1939;
              v82 = 2048;
              v83 = a1;
              _os_log_debug_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_DEBUG, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] FEC Protected Frame begin recovery", buf, 0x26u);
            }
          }
          if (!RecoverOneFrame(a1, (int *)v17))
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
            {
              v68 = VRTraceErrorLogLevelToCSTR();
              v69 = *MEMORY[0x1E0CF2758];
              v70 = *MEMORY[0x1E0CF2758];
              if (*MEMORY[0x1E0CF2748])
              {
                if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 136315906;
                  v77 = v68;
                  v78 = 2080;
                  v79 = "VideoPacketBuffer_ScheduleFutureFrame";
                  v80 = 1024;
                  v81 = 1942;
                  v82 = 2048;
                  v83 = a1;
                  _os_log_impl(&dword_1D8A54000, v69, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Scheduling FEC Protected Frame after successful recovery (when next frame come)", buf, 0x26u);
                }
              }
              else if (os_log_type_enabled(v70, OS_LOG_TYPE_DEBUG))
              {
                VideoPacketBuffer_ScheduleFutureFrame_cold_3();
              }
            }
            v18 = 1;
            *(_DWORD *)(v17 + 44) = 1;
            *a4 = *(_DWORD *)(v17 + 12);
            *(_DWORD *)(v17 + 48) = 1;
            goto LABEL_83;
          }
        }
        *a4 = *(_DWORD *)(v17 + 12);
        *(_DWORD *)(v17 + 48) = 1;
        if (*(_DWORD *)(v17 + 40) && !*(_DWORD *)(v17 + 60))
          *(_DWORD *)(v17 + 60) = 2;
        _VideoPacketBuffer_StartTrackingEvictedFrameStats(a1, v17, a8);
        kdebug_trace();
        LODWORD(v27) = *(_DWORD *)(v17 + 12);
        v28 = ((double)a5 - (double)v27) / (double)*(int *)(a1 + 8);
        v29 = VRTraceGetErrorLogLevelForModule();
        if (v28 <= 0.5)
        {
          if (v29 >= 5)
          {
            v47 = VRTraceErrorLogLevelToCSTR();
            v48 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              v49 = *(_DWORD *)(v17 + 40);
              v50 = **(unsigned __int16 **)(v17 + 96);
              v51 = *(_DWORD *)(v17 + 12);
              v52 = *(unsigned __int16 *)(v17 + 146);
              v53 = *(unsigned __int8 *)(v17 + 148);
              v54 = *(_DWORD *)(v17 + 60);
              v55 = *(unsigned __int16 *)(v17 + 150);
              v56 = *(_DWORD *)(v17 + 156);
              *(_DWORD *)buf = 136318978;
              v77 = v47;
              v78 = 2080;
              v79 = "VideoPacketBuffer_ScheduleFutureFrame";
              v80 = 1024;
              v81 = 1976;
              v82 = 2048;
              v83 = a1;
              v84 = 1024;
              v85 = v49;
              v86 = 1024;
              v87 = v50;
              v88 = 1024;
              *(_DWORD *)v89 = a5;
              *(_WORD *)&v89[4] = 1024;
              *(_DWORD *)&v89[6] = v51;
              v90 = 1024;
              v91 = v51 - a5;
              v92 = 1024;
              v93 = v52;
              v94 = 1024;
              v95 = v53;
              v96 = 1024;
              v97 = a7;
              v98 = 1024;
              v99 = a6;
              v100 = 1024;
              v101 = v54;
              v102 = 1024;
              v103 = v55;
              v104 = 1024;
              v105 = v56;
              _os_log_impl(&dword_1D8A54000, v48, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] scheduling incomplete frame! fecProtected:%d seq:%u playoutRTPTimestamp:%u frameTimestamp:%u diff:%d decodingOrder:%u isDecodingOrderValid:%d expectdDecodingOrder:%d isExpectedDecodingOrderValid:%d fecStatus=%d frameSequenceNumber=%d previousFrameSequenceNumber=%d", buf, 0x6Eu);
            }
          }
          v18 = 1;
          goto LABEL_83;
        }
        if (v29 >= 5)
        {
          v30 = VRTraceErrorLogLevelToCSTR();
          v31 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v32 = *(_DWORD *)(v17 + 12);
            *(_DWORD *)buf = 136316674;
            v77 = v30;
            v78 = 2080;
            v79 = "VideoPacketBuffer_ScheduleFutureFrame";
            v80 = 1024;
            v81 = 1967;
            v82 = 2048;
            v83 = a1;
            v84 = 1024;
            v85 = a5;
            v86 = 1024;
            v87 = v32;
            v88 = 2048;
            *(double *)v89 = v28;
            _os_log_impl(&dword_1D8A54000, v31, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] discarding incomplete frame that is too old. playoutRTPTimestamp:%u frameTimestamp:%u missedPlayoutDelta:%g", buf, 0x3Cu);
          }
        }
        v22 = *(_QWORD *)(v17 + 112);
        v33 = (uint64_t *)(v15 + 2);
        v34 = *v73;
        if (!*v73)
          goto LABEL_49;
        if (v34 != v17)
        {
          while (1)
          {
            v35 = v34;
            v34 = *(_QWORD *)(v34 + 112);
            if (!v34)
              break;
            if (v34 == v17)
            {
              v33 = (uint64_t *)(v35 + 112);
              goto LABEL_48;
            }
          }
LABEL_49:
          v18 = 0;
          goto LABEL_19;
        }
LABEL_48:
        *v33 = v22;
        _VideoPacketBuffer_FreeFrame(a1, (_QWORD *)v17);
        v18 = 0;
        --*(_DWORD *)(a1 + 146008);
      }
LABEL_19:
      v17 = v22;
      if (!v22)
        goto LABEL_83;
    }
  }
  v18 = 0;
LABEL_83:
  pthread_mutex_unlock(v74);
  return v18;
}

BOOL _VideoPacketBuffer_ScheduleSingleFrame(uint64_t a1, uint64_t a2, _DWORD *a3, int a4, int a5, int a6)
{
  uint64_t v9;
  NSObject *v10;
  _BOOL8 result;
  int v12;
  int v13;
  int v14;
  int v15;
  int v19;
  uint64_t v20;
  NSObject *v21;
  _BOOL4 v22;
  int v23;
  const char *v24;
  NSObject *v25;
  uint32_t v26;
  uint64_t v27;
  NSObject *v28;
  NSObject *v29;
  uint64_t v30;
  NSObject *v31;
  NSObject *v32;
  int v33;
  int v34;
  int v35;
  int v36;
  uint64_t v37;
  NSObject *v38;
  NSObject *v39;
  _BOOL4 v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  uint64_t v46;
  NSObject *v47;
  _BOOL4 v48;
  int v49;
  int v50;
  int v51;
  int v52;
  uint64_t v53;
  NSObject *v54;
  NSObject *v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  const char *v64;
  NSObject *v65;
  uint32_t v66;
  int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  int ErrorLogLevelForModule;
  uint64_t v73;
  NSObject *v74;
  NSObject *v75;
  _BOOL4 v76;
  uint64_t v77;
  NSObject *v78;
  NSObject *v79;
  int v80;
  uint64_t v81;
  NSObject *v82;
  _BOOL4 v83;
  int v84;
  int v85;
  int v86;
  int v87;
  uint64_t v88;
  NSObject *v89;
  NSObject *v90;
  _BOOL4 v91;
  int v92;
  int v93;
  int v94;
  int v95;
  int v96;
  int v97;
  int v98;
  int v99;
  int v100;
  int v101;
  int v102;
  int v103;
  int v104;
  int v105;
  int v106;
  int v107;
  int v108;
  int v109;
  int v110;
  int v111;
  int v112;
  int v113;
  int v114;
  uint64_t v115;
  __int16 v116;
  const char *v117;
  __int16 v118;
  int v119;
  __int16 v120;
  uint64_t v121;
  __int16 v122;
  int v123;
  __int16 v124;
  int v125;
  __int16 v126;
  int v127;
  __int16 v128;
  int v129;
  __int16 v130;
  int v131;
  __int16 v132;
  int v133;
  uint64_t v134;

  v134 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a2 + 48))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v9 = VRTraceErrorLogLevelToCSTR();
      v10 = *MEMORY[0x1E0CF2758];
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      v12 = *(unsigned __int16 *)(a1 + 420) + 1;
      v13 = **(unsigned __int16 **)(a2 + 96);
      v14 = *(_DWORD *)(a2 + 12);
      v15 = *(unsigned __int16 *)(a2 + 150);
      v114 = 136317186;
      v115 = v9;
      v116 = 2080;
      v117 = "_VideoPacketBuffer_ScheduleSingleFrame";
      v118 = 1024;
      v119 = 1816;
      v120 = 2048;
      v121 = a1;
      v122 = 1024;
      v123 = v12;
      v124 = 1024;
      v125 = v13;
      v126 = 1024;
      v127 = v14;
      v128 = 1024;
      v129 = v15;
      v130 = 1024;
      v131 = a4;
      _os_log_error_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_ERROR, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Frame already scheduled! expectedSeq=%u seq=%u frameTimestamp=%u frameSequenceNumber=%u playoutRTPTimestamp=%u", (uint8_t *)&v114, 0x44u);
    }
    return 0;
  }
  if (!a3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      _VideoPacketBuffer_ScheduleSingleFrame_cold_1();
    }
    return 0;
  }
  if (!*(_BYTE *)(a1 + 426))
    goto LABEL_9;
  if (!*(_BYTE *)(a2 + 152))
  {
    v45 = **(unsigned __int16 **)(a2 + 96);
    if (v45 != (unsigned __int16)(*(_WORD *)(a1 + 420) + 1)
      && (unsigned __int16)(v45 - (*(_WORD *)(a1 + 420) + 1)) <= 0x7FFEu)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 8)
        return 0;
      v46 = VRTraceErrorLogLevelToCSTR();
      v38 = *MEMORY[0x1E0CF2758];
      v47 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        v48 = os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT);
        result = 0;
        if (!v48)
          return result;
        v49 = *(unsigned __int16 *)(a1 + 420) + 1;
        v50 = **(unsigned __int16 **)(a2 + 96);
        v51 = *(_DWORD *)(a2 + 12);
        v52 = *(unsigned __int16 *)(a2 + 150);
        v114 = 136317186;
        v115 = v46;
        v116 = 2080;
        v117 = "_VideoPacketBuffer_ScheduleSingleFrame";
        v118 = 1024;
        v119 = 1826;
        v120 = 2048;
        v121 = a1;
        v122 = 1024;
        v123 = v49;
        v124 = 1024;
        v125 = v50;
        v126 = 1024;
        v127 = v51;
        v128 = 1024;
        v129 = v52;
        v130 = 1024;
        v131 = a4;
        v24 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Out of order. expectedSeq:%u seq:%u frameTimestamp:%u f"
              "rameSequenceNumber=%u playoutRTPTimestamp:%u";
        goto LABEL_36;
      }
      result = os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG);
      if (!result)
        return result;
      v67 = *(unsigned __int16 *)(a1 + 420) + 1;
      v68 = **(unsigned __int16 **)(a2 + 96);
      v69 = *(_DWORD *)(a2 + 12);
      v70 = *(unsigned __int16 *)(a2 + 150);
      v114 = 136317186;
      v115 = v46;
      v116 = 2080;
      v117 = "_VideoPacketBuffer_ScheduleSingleFrame";
      v118 = 1024;
      v119 = 1826;
      v120 = 2048;
      v121 = a1;
      v122 = 1024;
      v123 = v67;
      v124 = 1024;
      v125 = v68;
      v126 = 1024;
      v127 = v69;
      v128 = 1024;
      v129 = v70;
      v130 = 1024;
      v131 = a4;
      v64 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Out of order. expectedSeq:%u seq:%u frameTimestamp:%u fra"
            "meSequenceNumber=%u playoutRTPTimestamp:%u";
      goto LABEL_51;
    }
    goto LABEL_9;
  }
  if (*(_DWORD *)(a1 + 145972))
  {
LABEL_9:
    if (*(_BYTE *)(a1 + 240))
    {
      if (*(_BYTE *)(a2 + 148))
      {
        if (a5)
        {
          v19 = *(unsigned __int16 *)(a2 + 146) - a6;
          if (v19)
          {
            if ((unsigned __int16)v19 <= 0x7FFEu)
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
              {
                v20 = VRTraceErrorLogLevelToCSTR();
                v21 = *MEMORY[0x1E0CF2758];
                v22 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
                result = 0;
                if (!v22)
                  return result;
                v23 = *(unsigned __int16 *)(a2 + 146);
                v114 = 136316418;
                v115 = v20;
                v116 = 2080;
                v117 = "_VideoPacketBuffer_ScheduleSingleFrame";
                v118 = 1024;
                v119 = 1835;
                v120 = 2048;
                v121 = a1;
                v122 = 1024;
                v123 = v23;
                v124 = 1024;
                v125 = a6;
                v24 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] frameDecodingOrder:%hu, expectedDecodingOrder:%hu";
                v25 = v21;
                v26 = 50;
                goto LABEL_37;
              }
              return 0;
            }
          }
        }
      }
    }
    if (*(_DWORD *)(a2 + 40))
    {
      if (!*(_DWORD *)(a2 + 44) && VideoPacketBuffer_FrameReadyForRecovery(a2))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          v27 = VRTraceErrorLogLevelToCSTR();
          v28 = *MEMORY[0x1E0CF2758];
          v29 = *MEMORY[0x1E0CF2758];
          if (*MEMORY[0x1E0CF2748])
          {
            if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
            {
              v114 = 136315906;
              v115 = v27;
              v116 = 2080;
              v117 = "_VideoPacketBuffer_ScheduleSingleFrame";
              v118 = 1024;
              v119 = 1841;
              v120 = 2048;
              v121 = a1;
              _os_log_impl(&dword_1D8A54000, v28, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] FEC Protected Frame begin recovery", (uint8_t *)&v114, 0x26u);
            }
          }
          else if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
          {
            _VideoPacketBuffer_ScheduleSingleFrame_cold_4();
          }
        }
        v71 = RecoverOneFrame(a1, (int *)a2);
        ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
        if (v71)
        {
          if (ErrorLogLevelForModule < 8)
            return 0;
          v73 = VRTraceErrorLogLevelToCSTR();
          v74 = *MEMORY[0x1E0CF2758];
          v75 = *MEMORY[0x1E0CF2758];
          if (!*MEMORY[0x1E0CF2748])
          {
            result = os_log_type_enabled(v75, OS_LOG_TYPE_DEBUG);
            if (!result)
              return result;
            _VideoPacketBuffer_ScheduleSingleFrame_cold_3();
            return 0;
          }
          v76 = os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT);
          result = 0;
          if (!v76)
            return result;
          v114 = 136315906;
          v115 = v73;
          v116 = 2080;
          v117 = "_VideoPacketBuffer_ScheduleSingleFrame";
          v118 = 1024;
          v119 = 1850;
          v120 = 2048;
          v121 = a1;
          v24 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] FEC Protected Frame unsuccessful recovery";
          v25 = v74;
          v26 = 38;
          goto LABEL_37;
        }
        if (ErrorLogLevelForModule >= 8)
        {
          v77 = VRTraceErrorLogLevelToCSTR();
          v78 = *MEMORY[0x1E0CF2758];
          v79 = *MEMORY[0x1E0CF2758];
          if (*MEMORY[0x1E0CF2748])
          {
            if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
            {
              v114 = 136315906;
              v115 = v77;
              v116 = 2080;
              v117 = "_VideoPacketBuffer_ScheduleSingleFrame";
              v118 = 1024;
              v119 = 1844;
              v120 = 2048;
              v121 = a1;
              _os_log_impl(&dword_1D8A54000, v78, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Scheduling FEC Protected Frame after successful recovery", (uint8_t *)&v114, 0x26u);
            }
          }
          else if (os_log_type_enabled(v79, OS_LOG_TYPE_DEBUG))
          {
            _VideoPacketBuffer_ScheduleSingleFrame_cold_2();
          }
        }
        *a3 = *(_DWORD *)(a2 + 12);
        *(_QWORD *)(a2 + 44) = 0x100000001;
        return 1;
      }
    }
    else if (_VideoPacketBuffer_IsFrameComplete(a2, 0))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v30 = VRTraceErrorLogLevelToCSTR();
        v31 = *MEMORY[0x1E0CF2758];
        v32 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
          {
            v33 = **(unsigned __int16 **)(a2 + 96);
            v34 = *(_DWORD *)(a2 + 12);
            v35 = *(unsigned __int8 *)(a2 + 152);
            v36 = *(unsigned __int8 *)(a2 + 153);
            v114 = 136317186;
            v115 = v30;
            v116 = 2080;
            v117 = "_VideoPacketBuffer_ScheduleSingleFrame";
            v118 = 1024;
            v119 = 1854;
            v120 = 2048;
            v121 = a1;
            v122 = 1024;
            v123 = v33;
            v124 = 1024;
            v125 = v34;
            v126 = 1024;
            v127 = a4;
            v128 = 1024;
            v129 = v35;
            v130 = 1024;
            v131 = v36;
            _os_log_impl(&dword_1D8A54000, v31, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Scheduling Regular Frame seq:%u frameTimestamp:%u playoutRTPTimestamp:%u, isTemporalScaledStream=%d, isBaseLayerStream=%d", (uint8_t *)&v114, 0x44u);
          }
        }
        else if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
        {
          v106 = **(unsigned __int16 **)(a2 + 96);
          v107 = *(_DWORD *)(a2 + 12);
          v108 = *(unsigned __int8 *)(a2 + 152);
          v109 = *(unsigned __int8 *)(a2 + 153);
          v114 = 136317186;
          v115 = v30;
          v116 = 2080;
          v117 = "_VideoPacketBuffer_ScheduleSingleFrame";
          v118 = 1024;
          v119 = 1854;
          v120 = 2048;
          v121 = a1;
          v122 = 1024;
          v123 = v106;
          v124 = 1024;
          v125 = v107;
          v126 = 1024;
          v127 = a4;
          v128 = 1024;
          v129 = v108;
          v130 = 1024;
          v131 = v109;
          _os_log_debug_impl(&dword_1D8A54000, v31, OS_LOG_TYPE_DEBUG, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Scheduling Regular Frame seq:%u frameTimestamp:%u playoutRTPTimestamp:%u, isTemporalScaledStream=%d, isBaseLayerStream=%d", (uint8_t *)&v114, 0x44u);
        }
      }
      *a3 = *(_DWORD *)(a2 + 12);
      result = 1;
      *(_DWORD *)(a2 + 48) = 1;
      return result;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() < 8)
      return 0;
    v37 = VRTraceErrorLogLevelToCSTR();
    v38 = *MEMORY[0x1E0CF2758];
    v39 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      v40 = os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT);
      result = 0;
      if (!v40)
        return result;
      v41 = **(unsigned __int16 **)(a2 + 96);
      v42 = *(_DWORD *)(a2 + 12);
      v43 = *(unsigned __int8 *)(a2 + 152);
      v44 = *(unsigned __int8 *)(a2 + 153);
      v114 = 136317186;
      v115 = v37;
      v116 = 2080;
      v117 = "_VideoPacketBuffer_ScheduleSingleFrame";
      v118 = 1024;
      v119 = 1860;
      v120 = 2048;
      v121 = a1;
      v122 = 1024;
      v123 = v41;
      v124 = 1024;
      v125 = v42;
      v126 = 1024;
      v127 = a4;
      v128 = 1024;
      v129 = v43;
      v130 = 1024;
      v131 = v44;
      v24 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Frame is not yet ready seq:%u frameTimestamp:%u playoutRT"
            "PTimestamp:%u, isTemporalScaledStream=%d, isBaseLayerStream=%d";
LABEL_36:
      v25 = v38;
      v26 = 68;
LABEL_37:
      _os_log_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_DEFAULT, v24, (uint8_t *)&v114, v26);
      return 0;
    }
    result = os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG);
    if (!result)
      return result;
    v60 = **(unsigned __int16 **)(a2 + 96);
    v61 = *(_DWORD *)(a2 + 12);
    v62 = *(unsigned __int8 *)(a2 + 152);
    v63 = *(unsigned __int8 *)(a2 + 153);
    v114 = 136317186;
    v115 = v37;
    v116 = 2080;
    v117 = "_VideoPacketBuffer_ScheduleSingleFrame";
    v118 = 1024;
    v119 = 1860;
    v120 = 2048;
    v121 = a1;
    v122 = 1024;
    v123 = v60;
    v124 = 1024;
    v125 = v61;
    v126 = 1024;
    v127 = a4;
    v128 = 1024;
    v129 = v62;
    v130 = 1024;
    v131 = v63;
    v64 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Frame is not yet ready seq:%u frameTimestamp:%u playoutRTPT"
          "imestamp:%u, isTemporalScaledStream=%d, isBaseLayerStream=%d";
    goto LABEL_51;
  }
  if (!*(_BYTE *)(a2 + 160) && (int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v53 = VRTraceErrorLogLevelToCSTR();
    v54 = *MEMORY[0x1E0CF2758];
    v55 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
      {
        v56 = *(_DWORD *)(a2 + 12);
        v57 = *(unsigned __int16 *)(a2 + 150);
        v58 = *(unsigned __int16 *)(a1 + 424);
        v59 = *(unsigned __int8 *)(a1 + 146072);
        v114 = 136317186;
        v115 = v53;
        v116 = 2080;
        v117 = "_VideoPacketBuffer_ShouldSkipTemporalFrameScheduling";
        v118 = 1024;
        v119 = 1789;
        v120 = 2048;
        v121 = a1;
        v122 = 1024;
        v123 = v56;
        v124 = 1024;
        v125 = v57;
        v126 = 1024;
        v127 = v58;
        v128 = 1024;
        v129 = v59;
        v130 = 1024;
        v131 = a4;
        _os_log_impl(&dword_1D8A54000, v54, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Previous frame is unknown. frameTimestamp=%u frameSequenceNumber=%d lastAssembledFrameSequenceNumber=%u baseLayerFrameAssemblyFailed=%d playoutRTPTimestamp=%u", (uint8_t *)&v114, 0x44u);
      }
    }
    else if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
    {
      v110 = *(_DWORD *)(a2 + 12);
      v111 = *(unsigned __int16 *)(a2 + 150);
      v112 = *(unsigned __int16 *)(a1 + 424);
      v113 = *(unsigned __int8 *)(a1 + 146072);
      v114 = 136317186;
      v115 = v53;
      v116 = 2080;
      v117 = "_VideoPacketBuffer_ShouldSkipTemporalFrameScheduling";
      v118 = 1024;
      v119 = 1789;
      v120 = 2048;
      v121 = a1;
      v122 = 1024;
      v123 = v110;
      v124 = 1024;
      v125 = v111;
      v126 = 1024;
      v127 = v112;
      v128 = 1024;
      v129 = v113;
      v130 = 1024;
      v131 = a4;
      _os_log_debug_impl(&dword_1D8A54000, v54, OS_LOG_TYPE_DEBUG, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Previous frame is unknown. frameTimestamp=%u frameSequenceNumber=%d lastAssembledFrameSequenceNumber=%u baseLayerFrameAssemblyFailed=%d playoutRTPTimestamp=%u", (uint8_t *)&v114, 0x44u);
    }
  }
  if (!*(_WORD *)(a1 + 424) || !*(_BYTE *)(a2 + 160) || *(_DWORD *)(a2 + 156) == *(unsigned __int16 *)(a1 + 424))
  {
    if (*(_BYTE *)(a2 + 153))
    {
      v80 = **(unsigned __int16 **)(a2 + 96);
      if (v80 != (unsigned __int16)(*(_WORD *)(a1 + 146080) + 1)
        && (unsigned __int16)(v80 - (*(_WORD *)(a1 + 146080) + 1)) <= 0x7FFEu)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() < 8)
          return 0;
        v81 = VRTraceErrorLogLevelToCSTR();
        v38 = *MEMORY[0x1E0CF2758];
        v82 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          v83 = os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT);
          result = 0;
          if (!v83)
            return result;
          v84 = *(unsigned __int16 *)(a1 + 146080) + 1;
          v85 = **(unsigned __int16 **)(a2 + 96);
          v86 = *(_DWORD *)(a2 + 12);
          v87 = *(unsigned __int16 *)(a2 + 150);
          v114 = 136317186;
          v115 = v81;
          v116 = 2080;
          v117 = "_VideoPacketBuffer_ShouldSkipTemporalFrameScheduling";
          v118 = 1024;
          v119 = 1800;
          v120 = 2048;
          v121 = a1;
          v122 = 1024;
          v123 = v84;
          v124 = 1024;
          v125 = v85;
          v126 = 1024;
          v127 = v86;
          v128 = 1024;
          v129 = v87;
          v130 = 1024;
          v131 = a4;
          v24 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Temporal base layer frame out of order. expectedSeq=%"
                "u seq=%u frameTimestamp=%d baseLayerFrameSequenceNumber=%d playoutRTPTimestamp=%u";
          goto LABEL_36;
        }
        result = os_log_type_enabled(v82, OS_LOG_TYPE_DEBUG);
        if (!result)
          return result;
        v97 = *(unsigned __int16 *)(a1 + 146080) + 1;
        v98 = **(unsigned __int16 **)(a2 + 96);
        v99 = *(_DWORD *)(a2 + 12);
        v100 = *(unsigned __int16 *)(a2 + 150);
        v114 = 136317186;
        v115 = v81;
        v116 = 2080;
        v117 = "_VideoPacketBuffer_ShouldSkipTemporalFrameScheduling";
        v118 = 1024;
        v119 = 1800;
        v120 = 2048;
        v121 = a1;
        v122 = 1024;
        v123 = v97;
        v124 = 1024;
        v125 = v98;
        v126 = 1024;
        v127 = v99;
        v128 = 1024;
        v129 = v100;
        v130 = 1024;
        v131 = a4;
        v64 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Temporal base layer frame out of order. expectedSeq=%u "
              "seq=%u frameTimestamp=%d baseLayerFrameSequenceNumber=%d playoutRTPTimestamp=%u";
LABEL_51:
        v65 = v38;
        v66 = 68;
LABEL_52:
        _os_log_debug_impl(&dword_1D8A54000, v65, OS_LOG_TYPE_DEBUG, v64, (uint8_t *)&v114, v66);
        return 0;
      }
    }
    goto LABEL_9;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() < 8)
    return 0;
  v88 = VRTraceErrorLogLevelToCSTR();
  v89 = *MEMORY[0x1E0CF2758];
  v90 = *MEMORY[0x1E0CF2758];
  if (*MEMORY[0x1E0CF2748])
  {
    v91 = os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v91)
      return result;
    v92 = *(_DWORD *)(a2 + 12);
    v93 = *(unsigned __int16 *)(a2 + 150);
    v94 = *(_DWORD *)(a2 + 156);
    v95 = *(unsigned __int16 *)(a1 + 424);
    v96 = *(unsigned __int8 *)(a1 + 146072);
    v114 = 136317442;
    v115 = v88;
    v116 = 2080;
    v117 = "_VideoPacketBuffer_ShouldSkipTemporalFrameScheduling";
    v118 = 1024;
    v119 = 1794;
    v120 = 2048;
    v121 = a1;
    v122 = 1024;
    v123 = v92;
    v124 = 1024;
    v125 = v93;
    v126 = 1024;
    v127 = v94;
    v128 = 1024;
    v129 = v95;
    v130 = 1024;
    v131 = v96;
    v132 = 1024;
    v133 = a4;
    v24 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Trying to assemble a frame while previous frame assembly is"
          " pending. frameTimestamp=%u frameSequenceNumber=%d previousFrameSequenceNumber=%d lastAssembledFrameSequenceNu"
          "mber=%u baseLayerFrameAssemblyFailed=%d playoutRTPTimestamp=%u";
    v25 = v89;
    v26 = 74;
    goto LABEL_37;
  }
  result = os_log_type_enabled(v90, OS_LOG_TYPE_DEBUG);
  if (result)
  {
    v101 = *(_DWORD *)(a2 + 12);
    v102 = *(unsigned __int16 *)(a2 + 150);
    v103 = *(_DWORD *)(a2 + 156);
    v104 = *(unsigned __int16 *)(a1 + 424);
    v105 = *(unsigned __int8 *)(a1 + 146072);
    v114 = 136317442;
    v115 = v88;
    v116 = 2080;
    v117 = "_VideoPacketBuffer_ShouldSkipTemporalFrameScheduling";
    v118 = 1024;
    v119 = 1794;
    v120 = 2048;
    v121 = a1;
    v122 = 1024;
    v123 = v101;
    v124 = 1024;
    v125 = v102;
    v126 = 1024;
    v127 = v103;
    v128 = 1024;
    v129 = v104;
    v130 = 1024;
    v131 = v105;
    v132 = 1024;
    v133 = a4;
    v64 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Trying to assemble a frame while previous frame assembly is"
          " pending. frameTimestamp=%u frameSequenceNumber=%d previousFrameSequenceNumber=%d lastAssembledFrameSequenceNu"
          "mber=%u baseLayerFrameAssemblyFailed=%d playoutRTPTimestamp=%u";
    v65 = v89;
    v66 = 74;
    goto LABEL_52;
  }
  return result;
}

uint64_t VideoPacketBuffer_FrameReadyForRecovery(uint64_t a1)
{
  uint64_t v1;
  unsigned int v2;

  if (!*(_DWORD *)(a1 + 40))
    return 0;
  v1 = *(_QWORD *)(a1 + 96);
  if (!v1)
    return 0;
  while (1)
  {
    if (!*(_DWORD *)(v1 + 24))
      goto LABEL_8;
    v2 = *(_DWORD *)(v1 + 32);
    if (v2 >> 30)
      break;
    if ((v2 & 0x8000) != 0)
      return 1;
LABEL_8:
    v1 = *(_QWORD *)(v1 + 104);
    if (!v1)
      return 0;
  }
  if ((v2 & 0x4000) == 0)
    goto LABEL_8;
  return 1;
}

uint64_t RecoverOneFrame(uint64_t a1, int *a2)
{
  unsigned int *v2;
  uint64_t v3;
  uint64_t *v4;
  int v5;
  unsigned int v6;
  char v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  unsigned int v14;
  char v15;
  int v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int *v23;
  BOOL v24;
  unsigned int v25;
  unsigned int v26;
  int v27;
  size_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  unsigned int v32;
  _BOOL4 v33;
  unsigned int v34;
  NSObject *v35;
  NSObject *v36;
  int v37;
  const char *v38;
  const char *v39;
  int v40;
  unsigned int v41;
  unsigned int v42;
  unsigned int v43;
  unsigned int v44;
  unsigned int v45;
  uint64_t v46;
  unsigned int *v47;
  unsigned int *v48;
  unsigned int v49;
  unsigned int v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  unsigned int v55;
  int v56;
  int v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t i;
  int v63;
  int v64;
  uint64_t v65;
  int v66;
  uint64_t v67;
  char *v68;
  _WORD *v69;
  CFTypeRef *v70;
  OSStatus v71;
  OSStatus DataPointer;
  int DataLength;
  uint64_t v74;
  uint64_t v75;
  __int16 v76;
  uint64_t v77;
  int v78;
  BOOL v79;
  char v80;
  int v81;
  int v82;
  int v83;
  int ErrorLogLevelForModule;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  NSObject *v92;
  int v93;
  int *v94;
  uint64_t *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t *v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t *v107;
  uint64_t v108;
  unsigned int v109;
  uint64_t v110;
  int FrameSliceHeader;
  _DWORD *v112;
  uint64_t v113;
  unsigned int v114;
  uint64_t v115;
  uint64_t *v116;
  uint64_t v117;
  uint64_t v118;
  int v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  NSObject *v123;
  int v124;
  uint64_t v125;
  uint64_t v126;
  NSObject *v127;
  NSObject *v128;
  const char *v129;
  uint32_t v130;
  uint64_t v131;
  NSObject *v132;
  uint64_t v133;
  NSObject *v134;
  NSObject *v135;
  const char *v136;
  int v137;
  uint64_t v138;
  NSObject *v139;
  uint64_t v140;
  NSObject *v141;
  NSObject *v142;
  const char *v143;
  uint32_t v144;
  OSStatus v145;
  uint64_t v146;
  NSObject *v147;
  OSStatus v148;
  uint64_t v149;
  NSObject *v150;
  uint64_t v151;
  NSObject *v152;
  uint64_t v153;
  NSObject *v154;
  unsigned int v156;
  uint64_t v157;
  uint64_t v158;
  BOOL v159;
  int v160;
  unsigned int v161;
  unsigned int v162;
  char v163;
  _BOOL4 v164;
  _BOOL4 v165;
  int v166;
  int v167;
  unsigned int v168;
  int v169;
  uint64_t v171;
  uint64_t v172;
  int v173;
  const __CFAllocator *structureAllocator;
  unsigned int v175;
  unsigned int v176;
  uint64_t *v179;
  unsigned int v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  __int16 v184;
  int v185;
  uint64_t v186;
  unsigned int v187;
  int v188;
  int v189;
  uint64_t v190;
  _BYTE buf[44];
  __int16 v192;
  _BYTE v193[10];
  _BYTE v194[6];
  int v195;
  _WORD v196[8];
  _OWORD v197[4];
  int v198[16];
  int v199[16];
  _QWORD v200[2];
  _QWORD v201[2];
  _BYTE __b[16];
  _QWORD v203[16];
  _QWORD v204[18];

  v204[15] = *MEMORY[0x1E0C80C00];
  if (!a2[10])
    return 0;
  v2 = (unsigned int *)a2;
  v4 = (uint64_t *)(a2 + 24);
  v3 = *((_QWORD *)a2 + 12);
  if (!v3)
    return 0;
  v5 = 0;
  v183 = a1 + 146024;
  do
  {
    v6 = *(_DWORD *)(v3 + 32);
    if (v6 >> 30)
      v7 = 15;
    else
      v7 = 16;
    v8 = (v6 >> v7) & 0x7F;
    if (v8 >= v5)
      v5 = v8 + 1;
    v3 = *(_QWORD *)(v3 + 104);
  }
  while (v3);
  if (v5 < 1)
    return 0;
  v9 = 0;
  v10 = 0;
  structureAllocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v11 = *((_QWORD *)a2 + 12);
  v179 = (uint64_t *)(a2 + 24);
  while (2)
  {
    v12 = 0;
    if (v11)
    {
      v13 = v4;
      do
      {
        v14 = *(_DWORD *)(v11 + 32);
        if (v14 >> 30)
          v15 = 15;
        else
          v15 = 16;
        v16 = (v14 >> v15) & 0x7F;
        v17 = (uint64_t *)(v11 + 104);
        if (v16 == v9)
        {
          *v13 = *v17;
          *v17 = 0;
          if (v12)
          {
            v18 = v12;
            do
            {
              v19 = v18;
              v18 = *(_QWORD *)(v18 + 104);
            }
            while (v18);
            *(_QWORD *)(v19 + 104) = v11;
          }
          else
          {
            v12 = v11;
          }
        }
        else
        {
          v13 = (uint64_t *)(v11 + 104);
        }
        v11 = *v13;
      }
      while (*v13);
    }
    v20 = *v2;
    v184 = *((_WORD *)v2 + 75);
    v21 = v2[3];
    v180 = v2[4];
    memset(v204, 0, 120);
    memset(__b, 0, 15);
    v200[1] = 0;
    v200[0] = 0;
    *(_QWORD *)((char *)v201 + 6) = 0;
    v201[0] = 0;
    memset(v199, 0, 60);
    memset(v198, 0, 60);
    memset(v197, 0, 60);
    memset(v196, 0, 14);
    v190 = 0;
    memset(v203, 0, 120);
    if (v12)
    {
      v181 = v10;
      v23 = (unsigned int *)(v12 + 32);
      v22 = *(_DWORD *)(v12 + 32);
      v24 = v22 >> 30 == 0;
      v25 = HIWORD(v22);
      v26 = v22 >> 15;
      if (v22 >> 30)
        LOBYTE(v25) = v22 >> 15;
      if ((v25 & 0x7F) != v9)
      {
        v187 = 0;
        v189 = 0;
        v56 = 0;
        goto LABEL_176;
      }
      v175 = v21;
      v176 = v20;
      v189 = 0;
      v185 = 0;
      v27 = 0;
      LODWORD(v28) = 0;
      v29 = 0;
      v188 = -1431655766;
      v30 = v12;
      while (1)
      {
        v31 = v22;
        if (!(_DWORD)v29)
        {
          v32 = (v22 >> 11) & 7;
          v33 = *(_DWORD *)(v30 + 24) != 0;
          if (v24)
            v28 = v32;
          else
            v28 = (v31 >> 10) & 0xF;
          if (v24)
            v34 = v26;
          else
            v34 = v31 >> 14;
          if ((_DWORD)v28)
            memset(__b, 255, v28);
          v188 = v31 >> 30;
          v185 = v34 & v33;
          RSU_GetPacketLayout((v31 >> 27) & 7, v28, (int *)&v190 + 1, (int *)&v190);
          if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            v186 = VRTraceErrorLogLevelToCSTR();
            v35 = *MEMORY[0x1E0CF2758];
            v36 = *MEMORY[0x1E0CF2758];
            if (*MEMORY[0x1E0CF2748])
            {
              if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
              {
                if (*(_DWORD *)(v30 + 24))
                {
                  if (*v23 >> 30)
                    v37 = 0x400000;
                  else
                    v37 = 0x800000;
                  v38 = "data";
                  if ((v37 & *v23) == 0)
                    v38 = "parity";
                }
                else
                {
                  v38 = "data";
                }
                *(_DWORD *)buf = 136316674;
                *(_QWORD *)&buf[4] = v186;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "RecoverOneFECGroup";
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&buf[24] = 840;
                *(_WORD *)&buf[28] = 2080;
                *(_QWORD *)&buf[30] = v38;
                *(_WORD *)&buf[38] = 1024;
                *(_DWORD *)&buf[40] = v31 >> 30;
                v192 = 1024;
                *(_DWORD *)v193 = HIDWORD(v190);
                *(_WORD *)&v193[4] = 1024;
                *(_DWORD *)&v193[6] = v190;
                _os_log_impl(&dword_1D8A54000, v35, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d Received %s packet FEC Header version %d with numberOfDataPackets: %d, numberOfParityPackets:%d", buf, 0x38u);
              }
            }
            else if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
            {
              v39 = "data";
              if (*(_DWORD *)(v30 + 24))
              {
                v40 = *v23 >> 30 ? 0x400000 : 0x800000;
                v39 = "data";
                if ((v40 & *v23) == 0)
                  v39 = "parity";
              }
              *(_DWORD *)buf = 136316674;
              *(_QWORD *)&buf[4] = v186;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "RecoverOneFECGroup";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 840;
              *(_WORD *)&buf[28] = 2080;
              *(_QWORD *)&buf[30] = v39;
              *(_WORD *)&buf[38] = 1024;
              *(_DWORD *)&buf[40] = v31 >> 30;
              v192 = 1024;
              *(_DWORD *)v193 = HIDWORD(v190);
              *(_WORD *)&v193[4] = 1024;
              *(_DWORD *)&v193[6] = v190;
              _os_log_debug_impl(&dword_1D8A54000, v35, OS_LOG_TYPE_DEBUG, "VideoPacketBuffer [%s] %s:%d Received %s packet FEC Header version %d with numberOfDataPackets: %d, numberOfParityPackets:%d", buf, 0x38u);
            }
          }
          v29 = (v31 >> 27) & 7;
        }
        v41 = *v23;
        v42 = *v23 >> 30;
        if (v42)
          v43 = (*v23 >> 23) & 0xF;
        else
          v43 = HIBYTE(*v23) & 7;
        if (*(_DWORD *)(v30 + 24))
        {
          v44 = v41 >> 23;
          v45 = v41 >> 22;
          if (!v42)
            LOBYTE(v45) = v44;
          if ((v45 & 1) == 0)
          {
            v189 += *(_DWORD *)(v30 + 96);
            if (v188 == 1)
            {
              v196[v43 / v29] = *(_WORD *)(v30 + 76);
            }
            else if (!v188 && !LODWORD(v197[0]))
            {
              v46 = *(unsigned int *)(v30 + 68);
              if ((int)v46 >= 1)
              {
                v47 = (unsigned int *)(v30 + 36);
                v48 = (unsigned int *)v197;
                do
                {
                  v50 = *v47++;
                  v49 = v50;
                  if (v50 >= 0x5DD)
                  {
                    v187 = v29;
                    v137 = v31 & 0x3FF;
                    v2 = (unsigned int *)a2;
                    a2[15] = 3;
                    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
                    {
                      v124 = 0;
                      v58 = 0;
                      v125 = 0xFFFFFFFFLL;
                      v10 = v181;
                      v57 = v137;
                      v4 = v179;
                    }
                    else
                    {
                      v138 = VRTraceErrorLogLevelToCSTR();
                      v139 = *MEMORY[0x1E0CF2758];
                      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                      {
                        v168 = *v48;
                        *(_DWORD *)buf = 136316418;
                        *(_QWORD *)&buf[4] = v138;
                        *(_WORD *)&buf[12] = 2080;
                        *(_QWORD *)&buf[14] = "RecoverOneFECGroup";
                        *(_WORD *)&buf[22] = 1024;
                        *(_DWORD *)&buf[24] = 856;
                        *(_WORD *)&buf[28] = 1024;
                        *(_DWORD *)&buf[30] = 856;
                        *(_WORD *)&buf[34] = 2048;
                        *(_QWORD *)&buf[36] = a1;
                        v192 = 1024;
                        *(_DWORD *)v193 = v168;
                        _os_log_error_impl(&dword_1D8A54000, v139, OS_LOG_TYPE_ERROR, "VideoPacketBuffer [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/VideoPacketBuffer.c:%d: VideoPacketBuffer[%p] packet size (%d) is too big", buf, 0x32u);
                      }
                      v124 = 0;
                      v58 = 0;
                      v125 = 0xFFFFFFFFLL;
                      v57 = v137;
                      v4 = v179;
                      v10 = v181;
                      v2 = (unsigned int *)a2;
                    }
                    goto LABEL_223;
                  }
                  *v48++ = v49;
                  --v46;
                }
                while (v46);
              }
            }
            v43 += 8;
          }
        }
        if ((int)v29 >= 1)
        {
          v51 = v29;
          memset(&__b[v43], 255, v29);
          v29 = v51;
        }
        v52 = ((int)(v43 - v28) / (int)v29);
        if (v52 >= 0xF)
          break;
        v53 = v204[v52];
        if (v53)
        {
          v187 = v29;
          if ((int)VRTraceGetErrorLogLevelForModule() < 3)
            goto LABEL_188;
          v131 = VRTraceErrorLogLevelToCSTR();
          v132 = *MEMORY[0x1E0CF2758];
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            goto LABEL_188;
          v160 = *(_DWORD *)(v53 + 24);
          v161 = *(_DWORD *)(v53 + 32);
          v162 = v161 >> 30;
          if (v161 >> 30)
            v163 = 22;
          else
            v163 = 23;
          v164 = ((v161 >> v163) & 1) == 0;
          *(_DWORD *)buf = 136316930;
          if (v160)
            v165 = v164;
          else
            v165 = 0;
          *(_QWORD *)&buf[4] = v131;
          v166 = HIBYTE(v161) & 7;
          v167 = (v161 >> 23) & 0xF;
          *(_WORD *)&buf[12] = 2080;
          if (!v162)
            v167 = v166;
          *(_QWORD *)&buf[14] = "RecoverOneFECGroup";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 889;
          *(_WORD *)&buf[28] = 2048;
          *(_QWORD *)&buf[30] = a1;
          *(_WORD *)&buf[38] = 1024;
          *(_DWORD *)&buf[40] = v9;
          v192 = 2048;
          *(_QWORD *)v193 = v53;
          *(_WORD *)&v193[8] = 1024;
          *(_DWORD *)v194 = v165;
          *(_WORD *)&v194[4] = 1024;
          v195 = v167;
          v128 = v132;
          v129 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Unexpected duplicate packet found! GroupID=%d packet"
                 "=%p parity=%d position=%d";
          v130 = 66;
LABEL_250:
          _os_log_error_impl(&dword_1D8A54000, v128, OS_LOG_TYPE_ERROR, v129, buf, v130);
LABEL_188:
          v124 = 0;
          v58 = 0;
          v57 = v31 & 0x3FF;
          v2 = (unsigned int *)a2;
          a2[15] = 3;
          v125 = 0xFFFFFFFFLL;
          v4 = v179;
          v10 = v181;
          goto LABEL_223;
        }
        v203[v52] = *(_QWORD *)(v30 + 136);
        v204[v52] = v30;
        v54 = *(_DWORD *)(v30 + 128);
        v199[v52] = v54;
        v198[v52] = v54;
        if (v27 <= v54)
          v27 = v54;
        *((_WORD *)v200 + v52) = *(_WORD *)v30;
        *(_DWORD *)(v30 + 80) = 1;
        *(_DWORD *)(v30 + 20) = 0;
        v30 = *(_QWORD *)(v30 + 104);
        if (!v30)
        {
          v57 = v31 & 0x3FF;
          if ((int)v28 <= 7)
          {
            v10 = v181;
            goto LABEL_89;
          }
          v187 = v29;
          v58 = 0;
          v10 = v181;
LABEL_193:
          v125 = 0;
          v124 = 1;
          v2 = (unsigned int *)a2;
          a2[15] = 1;
LABEL_194:
          v4 = v179;
          goto LABEL_223;
        }
        v23 = (unsigned int *)(v30 + 32);
        v22 = *(_DWORD *)(v30 + 32);
        v24 = v22 >> 30 == 0;
        v55 = HIWORD(v22);
        v26 = v22 >> 15;
        if (v22 >> 30)
          LOBYTE(v55) = v22 >> 15;
        if ((v55 & 0x7F) != v9)
        {
          v187 = v29;
          v56 = v31 & 0x3FF;
          v2 = (unsigned int *)a2;
LABEL_176:
          v2[15] = 3;
          v10 = v181;
          if ((int)VRTraceGetErrorLogLevelForModule() < 3)
          {
            v124 = 0;
            v58 = 0;
            v125 = 0xFFFFFFFFLL;
          }
          else
          {
            v122 = VRTraceErrorLogLevelToCSTR();
            v123 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136316162;
              *(_QWORD *)&buf[4] = v122;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "RecoverOneFECGroup";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 824;
              *(_WORD *)&buf[28] = 2048;
              *(_QWORD *)&buf[30] = a1;
              *(_WORD *)&buf[38] = 1024;
              *(_DWORD *)&buf[40] = v9;
              _os_log_error_impl(&dword_1D8A54000, v123, OS_LOG_TYPE_ERROR, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] group_id mismatch, expected (%d)", buf, 0x2Cu);
            }
            v124 = 0;
            v58 = 0;
            v125 = 0xFFFFFFFFLL;
          }
          v57 = v56;
          goto LABEL_194;
        }
      }
      v187 = v29;
      if ((int)VRTraceGetErrorLogLevelForModule() < 3)
        goto LABEL_188;
      v126 = VRTraceErrorLogLevelToCSTR();
      v127 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        goto LABEL_188;
      *(_DWORD *)buf = 136316930;
      *(_QWORD *)&buf[4] = v126;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "RecoverOneFECGroup";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 878;
      *(_WORD *)&buf[28] = 2048;
      *(_QWORD *)&buf[30] = a1;
      *(_WORD *)&buf[38] = 1024;
      *(_DWORD *)&buf[40] = v52;
      v192 = 1024;
      *(_DWORD *)v193 = v43;
      *(_WORD *)&v193[4] = 1024;
      *(_DWORD *)&v193[6] = v28;
      *(_WORD *)v194 = 1024;
      *(_DWORD *)&v194[2] = v187;
      v128 = v127;
      v129 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Unexpected index index=%d startPosition=%d dataPacketOff"
             "set=%d numberOfSymbolsPerPacket=%d";
      v130 = 62;
      goto LABEL_250;
    }
    v175 = v21;
    v176 = v20;
    LODWORD(v29) = 0;
    LODWORD(v28) = 0;
    v27 = 0;
    v185 = 0;
    v189 = 0;
    v57 = 0;
    v188 = -1431655766;
LABEL_89:
    LODWORD(v58) = 0;
    v59 = 0;
    v60 = v28;
    v61 = v183;
    do
    {
      if (__b[v60])
      {
        v58 = v58;
      }
      else
      {
        ++v59;
        v58 = (v58 + 1);
      }
      ++v60;
    }
    while ((_DWORD)v60 != 8);
    v187 = v29;
    if (!v59)
      goto LABEL_193;
    v173 = v57;
    for (i = 0; i != 7; ++i)
    {
      if (!__b[i + 8])
        ++v59;
    }
    if (!RSU_IsRecoverable(v59))
    {
      v124 = 0;
      v2 = (unsigned int *)a2;
      a2[15] = 2;
      v125 = 0xFFFFFFFFLL;
      v4 = v179;
      goto LABEL_222;
    }
    v182 = v10;
    v63 = HIDWORD(v190);
    v64 = v190;
    LODWORD(v65) = v190 + HIDWORD(v190);
    v66 = v187;
    if ((int)v190 + HIDWORD(v190) < 1)
    {
LABEL_123:
      v83 = RSU_Decode((uint64_t)v203, v199, v198, v65, v66, v28, (uint64_t)v196, v188 == 1);
      ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
      if (v83 < 0)
      {
        v4 = v179;
        v2 = (unsigned int *)a2;
        if (ErrorLogLevelForModule < 3)
          goto LABEL_220;
        v133 = VRTraceErrorLogLevelToCSTR();
        v134 = *MEMORY[0x1E0CF2758];
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          goto LABEL_220;
        *(_DWORD *)buf = 136316418;
        *(_QWORD *)&buf[4] = v133;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "RecoverOneFECGroup";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 1019;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = 1019;
        *(_WORD *)&buf[34] = 2048;
        *(_QWORD *)&buf[36] = a1;
        v192 = 1024;
        *(_DWORD *)v193 = 0;
        v135 = v134;
        v136 = "VideoPacketBuffer [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sour"
               "ces/Others/VideoPacketBuffer.c:%d: VideoPacketBuffer[%p] RSU_Decode failed (%d)";
LABEL_254:
        _os_log_error_impl(&dword_1D8A54000, v135, OS_LOG_TYPE_ERROR, v136, buf, 0x32u);
LABEL_220:
        v125 = 0;
        v2[15] = 3;
        v124 = 1;
        goto LABEL_221;
      }
      v4 = v179;
      v2 = (unsigned int *)a2;
      if (ErrorLogLevelForModule >= 7)
      {
        v91 = VRTraceErrorLogLevelToCSTR();
        v92 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316674;
          *(_QWORD *)&buf[4] = v91;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "RecoverOneFECGroup";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 1026;
          *(_WORD *)&buf[28] = 2048;
          *(_QWORD *)&buf[30] = a1;
          *(_WORD *)&buf[38] = 1024;
          *(_DWORD *)&buf[40] = v175;
          v192 = 1024;
          *(_DWORD *)v193 = v9;
          *(_WORD *)&v193[4] = 1024;
          *(_DWORD *)&v193[6] = v185;
          _os_log_impl(&dword_1D8A54000, v92, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] recovered frame (%08X) group (%d:%d)", buf, 0x38u);
        }
      }
      v93 = HIDWORD(v190);
      if (v188 == 1 && SHIDWORD(v190) >= 1)
      {
        v94 = v199;
        v95 = v204;
        v96 = HIDWORD(v190);
        while (1)
        {
          v97 = *v94;
          if ((int)v97 >= 1501)
            break;
          v98 = *v95++;
          *(_QWORD *)(v98 + 128) = v97;
          ++v94;
          if (!--v96)
            goto LABEL_132;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() < 3)
          goto LABEL_220;
        v153 = VRTraceErrorLogLevelToCSTR();
        v154 = *MEMORY[0x1E0CF2758];
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          goto LABEL_220;
        v169 = *v94;
        *(_DWORD *)buf = 136316418;
        *(_QWORD *)&buf[4] = v153;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "RecoverOneFECGroup";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 1032;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = 1032;
        *(_WORD *)&buf[34] = 2048;
        *(_QWORD *)&buf[36] = a1;
        v192 = 1024;
        *(_DWORD *)v193 = v169;
        v135 = v154;
        v136 = "VideoPacketBuffer [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sour"
               "ces/Others/VideoPacketBuffer.c:%d: VideoPacketBuffer[%p] payload size (%d) is too big";
        goto LABEL_254;
      }
LABEL_132:
      v99 = (v190 + v93);
      if ((int)v190 >= 1)
      {
        v100 = v93;
        do
          *(_QWORD *)(v204[v100++] + 128) = v27;
        while (v100 < (int)v99);
      }
      v12 = v204[0];
      if ((int)v99 > 1)
      {
        v101 = v99 - 1;
        v102 = &v204[1];
        v103 = v204[0];
        do
        {
          v104 = *v102++;
          *(_QWORD *)(v103 + 104) = v104;
          v103 = v104;
          --v101;
        }
        while (v101);
      }
      *(_QWORD *)(v204[(int)v99 - 1] + 104) = 0;
      v105 = v176;
      if (v93 < 1)
      {
LABEL_191:
        v125 = 0;
        a2[15] = 4;
        v124 = 1;
        v10 = v182;
        goto LABEL_222;
      }
      v106 = 0;
      v107 = v204;
      while (1)
      {
        v108 = v204[v106];
        if (!*(_DWORD *)(v108 + 24))
          break;
        v109 = *(_DWORD *)(v108 + 32);
        if (v109 >> 30)
        {
          if ((v109 & 0x400000) != 0)
            break;
        }
        else if ((v109 & 0x800000) != 0)
        {
          break;
        }
        *(_DWORD *)(v108 + 80) = 4;
LABEL_172:
        ++v106;
        ++v107;
        if (v106 >= v93)
          goto LABEL_191;
      }
      if ((_DWORD)v105 == 123 || (_DWORD)v105 == 100)
      {
        if (*(_DWORD *)(v108 + 20))
        {
          *(_DWORD *)(v108 + 80) = 3;
          if (v106 == v93 - 1)
            *(_DWORD *)(v108 + 16) = 1;
        }
LABEL_169:
        v120 = *(_QWORD *)(v183 + 64);
        if (v120 && *(_DWORD *)(v108 + 80) == 3)
        {
          *(_OWORD *)buf = xmmword_1D910B810;
          *(_OWORD *)&buf[16] = unk_1D910B820;
          *(_DWORD *)buf = *(_DWORD *)(v108 + 4);
          *(_WORD *)&buf[4] = *(_WORD *)v108;
          *(_QWORD *)&buf[8] = *(_QWORD *)(v108 + 88);
          buf[16] = 0;
          *(_DWORD *)&buf[20] = *(_DWORD *)(v108 + 84);
          buf[24] = 1;
          *(_WORD *)&buf[26] = v184;
          *(_WORD *)&buf[28] = *(_QWORD *)(v108 + 128);
          *(_WORD *)&buf[30] = 1;
          v121 = v105;
          VCNACKGenerator_AddPacketInfo(v120, (double *)buf, v85, v86, v87, v88, v89, v90);
          v105 = v121;
          v93 = HIDWORD(v190);
        }
        goto LABEL_172;
      }
      if (!*(_DWORD *)(v108 + 20))
      {
        if (v106)
        {
          if (*(_DWORD *)(v108 + 8))
          {
            v113 = v204[(v106 - 1)];
            if (*(_DWORD *)(v113 + 20))
              *(_DWORD *)(v113 + 12) = 1;
          }
        }
        goto LABEL_169;
      }
      *(_DWORD *)(v108 + 80) = 3;
      v110 = v105;
      FrameSliceHeader = ReadFrameSliceHeader(v105, *(_QWORD *)(v108 + 136) + 4, *(_DWORD *)(v108 + 128) - 4, 0);
      if (FrameSliceHeader == 1)
      {
        if (v106 >= SHIDWORD(v190))
        {
          v114 = 0;
          v105 = v110;
        }
        else
        {
          v114 = 0;
          v115 = HIDWORD(v190);
          v116 = v107;
          v105 = v110;
          do
          {
            v117 = *v116++;
            v114 += *(_DWORD *)(v117 + 128);
            --v115;
          }
          while (v106 != v115);
        }
        v4 = v179;
        if (bswap32(**(_DWORD **)(v108 + 136)) + 4 > v114
          || (*(_DWORD *)(v108 + 8) = 1, !v106)
          || (v118 = v204[(v106 - 1)], v119 = *(_DWORD *)(v118 + 12), v112 = (_DWORD *)(v118 + 12), v119))
        {
LABEL_167:
          v93 = HIDWORD(v190);
          if (v106 == HIDWORD(v190) - 1)
            *(_QWORD *)(v108 + 12) = 0x100000001;
          goto LABEL_169;
        }
      }
      else
      {
        v105 = v110;
        v4 = v179;
        if (FrameSliceHeader != 2)
          goto LABEL_167;
        *(_DWORD *)(v108 + 8) = 1;
        v112 = (_DWORD *)(v108 + 12);
      }
      *v112 = 1;
      goto LABEL_167;
    }
    v67 = 0;
    while (1)
    {
      if (v203[v67])
      {
        LODWORD(v65) = v63 + v64;
        goto LABEL_122;
      }
      v68 = (char *)VCMemoryPool_Alloc(*(OSQueueHead **)v61);
      if (!v68)
        break;
      v69 = v68;
      v204[v67] = v68;
      v70 = (CFTypeRef *)(v68 + 120);
      v71 = CMBlockBufferCreateWithMemoryBlock(structureAllocator, 0, 0x5DCuLL, *(CFAllocatorRef *)(v61 + 16), 0, 0, 0x5DCuLL, 1u, (CMBlockBufferRef *)v68 + 15);
      if (v71)
      {
        v145 = v71;
        v10 = v182;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v146 = VRTraceErrorLogLevelToCSTR();
          v147 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136316162;
            *(_QWORD *)&buf[4] = v146;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "VideoPacketBuffer_CreateBlockBufferForPacket";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 543;
            *(_WORD *)&buf[28] = 2048;
            *(_QWORD *)&buf[30] = a1;
            *(_WORD *)&buf[38] = 1024;
            *(_DWORD *)&buf[40] = v145;
            _os_log_error_impl(&dword_1D8A54000, v147, OS_LOG_TYPE_ERROR, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Failed to create block buffer with error %d", buf, 0x2Cu);
          }
        }
LABEL_214:
        v2 = (unsigned int *)a2;
        a2[15] = 3;
        VCMemoryPool_Free(*(OSQueueHead **)v183, v69);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v151 = VRTraceErrorLogLevelToCSTR();
          v152 = *MEMORY[0x1E0CF2758];
          v4 = v179;
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            goto LABEL_216;
          *(_DWORD *)buf = 136315906;
          *(_QWORD *)&buf[4] = v151;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "RecoverOneFECGroup";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 964;
          *(_WORD *)&buf[28] = 2048;
          *(_QWORD *)&buf[30] = a1;
          v142 = v152;
          v143 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Block buffer init failed";
          v144 = 38;
          goto LABEL_252;
        }
        v124 = 0;
        v125 = 0xFFFFFFFFLL;
        v4 = v179;
        goto LABEL_222;
      }
      DataPointer = CMBlockBufferGetDataPointer(*((CMBlockBufferRef *)v69 + 15), 0, 0, 0, (char **)v69 + 17);
      if (DataPointer)
      {
        v148 = DataPointer;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v149 = VRTraceErrorLogLevelToCSTR();
          v150 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136316162;
            *(_QWORD *)&buf[4] = v149;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "VideoPacketBuffer_CreateBlockBufferForPacket";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 549;
            *(_WORD *)&buf[28] = 2048;
            *(_QWORD *)&buf[30] = a1;
            *(_WORD *)&buf[38] = 1024;
            *(_DWORD *)&buf[40] = v148;
            _os_log_error_impl(&dword_1D8A54000, v150, OS_LOG_TYPE_ERROR, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Failed to get data pointer with error %d", buf, 0x2Cu);
          }
        }
        v10 = v182;
        if (*v70)
        {
          CFRelease(*v70);
          *v70 = 0;
        }
        goto LABEL_214;
      }
      DataLength = CMBlockBufferGetDataLength(*((CMBlockBufferRef *)v69 + 15));
      v203[v67] = *((_QWORD *)v69 + 17);
      v198[v67] = DataLength;
      *((_DWORD *)v69 + 20) = 2;
      v63 = HIDWORD(v190);
      v74 = SHIDWORD(v190);
      v64 = v190;
      v65 = (v190 + HIDWORD(v190));
      v61 = v183;
      v66 = v187;
      if ((int)v65 >= 1)
      {
        v75 = 0;
        while (!*((_WORD *)v200 + v75))
        {
          if (v65 == ++v75)
            goto LABEL_116;
        }
        if (v67 >= SHIDWORD(v190))
          v76 = *((_WORD *)v200 + HIDWORD(v190) - 1);
        else
          v76 = v67 - v75 + *((_WORD *)v200 + v75);
        *((_WORD *)v200 + v67) = v76;
        *v69 = v76;
      }
LABEL_116:
      v77 = *((int *)v197 + v67);
      *((_QWORD *)v69 + 16) = v77;
      *((_DWORD *)v69 + 1) = v180;
      v78 = v77 & 0x1FFF;
      v79 = v67 < v74;
      if (v67 >= v74)
        v80 = (v67 - v63) * v187;
      else
        v80 = v28 + v187 * v67;
      *((_DWORD *)v69 + 6) = 1;
      v81 = v80 & 7 | (8 * (v187 & 0x1F));
      v82 = (v9 & 0x7F) << 16;
      if (v79)
        v82 = ((v9 & 0x7F) << 16) | 0x800000;
      *((_DWORD *)v69 + 8) = v82 | (v81 << 24) | v78 | (unsigned __int16)(((_WORD)v185 << 15) | ((_WORD)v28 << 11));
      *((_DWORD *)v69 + 17) = v63;
      *(_OWORD *)(v69 + 4) = xmmword_1D910B210;
      *((_QWORD *)v69 + 13) = 0;
LABEL_122:
      if (++v67 >= (int)v65)
        goto LABEL_123;
    }
    v2 = (unsigned int *)a2;
    a2[15] = 3;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v140 = VRTraceErrorLogLevelToCSTR();
      v141 = *MEMORY[0x1E0CF2758];
      v4 = v179;
      v10 = v182;
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
LABEL_216:
        v124 = 0;
        v125 = 0xFFFFFFFFLL;
        goto LABEL_222;
      }
      *(_DWORD *)buf = 136316162;
      *(_QWORD *)&buf[4] = v140;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "RecoverOneFECGroup";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 953;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 953;
      *(_WORD *)&buf[34] = 2048;
      *(_QWORD *)&buf[36] = a1;
      v142 = v141;
      v143 = "VideoPacketBuffer [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Source"
             "s/Others/VideoPacketBuffer.c:%d: VideoPacketBuffer[%p] malloc failed";
      v144 = 44;
LABEL_252:
      _os_log_error_impl(&dword_1D8A54000, v142, OS_LOG_TYPE_ERROR, v143, buf, v144);
      goto LABEL_216;
    }
    v124 = 0;
    v125 = 0xFFFFFFFFLL;
    v4 = v179;
LABEL_221:
    v10 = v182;
LABEL_222:
    v57 = v173;
LABEL_223:
    if (v2[15] != 3 && SHIDWORD(v190) >= 1)
    {
      v156 = vcvtps_s32_f32((float)(HIDWORD(v190) * v57) / 100.0);
      VideoPacketBuffer_UpdateMaxGroupBurstLossStatistics(a1 + 800 * (v184 & 0x7F) + 42688, v58, (v156 - v189) & ~((int)(v156 - v189) >> 31), v187, SHIDWORD(v190), v9);
    }
    if (v10)
    {
      v157 = v10;
      do
      {
        v158 = v157;
        v157 = *(_QWORD *)(v157 + 104);
      }
      while (v157);
      *(_QWORD *)(v158 + 104) = v12;
      if (!v124)
        goto LABEL_257;
LABEL_234:
      v11 = *v4;
      ++v9;
      if (*v4)
        v159 = v9 == v5;
      else
        v159 = 1;
      if (v159)
      {
        v125 = 0;
        goto LABEL_257;
      }
      continue;
    }
    break;
  }
  v10 = v12;
  if (v124)
    goto LABEL_234;
LABEL_257:
  if (v10)
  {
    v171 = v10;
    do
    {
      v172 = v171;
      v171 = *(_QWORD *)(v171 + 104);
    }
    while (v171);
    *(_QWORD *)(v172 + 104) = *v4;
    *v4 = v10;
  }
  return v125;
}

uint64_t _VideoPacketBuffer_SchedulePastIncompleteFrame_InternalLoop(uint64_t a1, _DWORD *a2, int a3, int a4, int a5)
{
  uint64_t v5;
  uint64_t v6;
  _WORD *v11;
  _WORD *v12;
  uint64_t *v13;
  uint64_t v14;
  _WORD *v15;
  _WORD *v16;
  uint64_t v18;
  NSObject *v19;
  int v20;
  int v21;
  int v22;
  uint8_t buf[4];
  uint64_t v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  int v33;
  __int16 v34;
  int v35;
  __int16 v36;
  int v37;
  __int16 v38;
  int v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v5 = a1 + 145904;
  v6 = *(_QWORD *)(a1 + 145904);
  if (v6)
  {
    v11 = (_WORD *)(a1 + 424);
    v12 = (_WORD *)(a1 + 422);
    v13 = (uint64_t *)(a1 + 145904);
    do
    {
      v14 = v6;
      while (1)
      {
        if (*(_BYTE *)(v14 + 149))
        {
          v15 = (_WORD *)(v14 + 150);
          v16 = v11;
        }
        else
        {
          v15 = *(_WORD **)(v14 + 96);
          v16 = v12;
        }
        if ((unsigned __int16)(*v15 - *v16) < 0x7FFFu)
          break;
        *v13 = *(_QWORD *)(v14 + 112);
        *(_BYTE *)(v14 + 161) = _VideoPacketBuffer_IsFrameComplete(v14, 0);
        _VideoPacketBuffer_FreeFrame(a1, (_QWORD *)v14);
        --*(_DWORD *)(v5 + 108);
        v14 = *v13;
        if (!*v13)
          return 0;
      }
      if (!*(_BYTE *)(v14 + 152) && **(unsigned __int16 **)(v14 + 96) != (unsigned __int16)(*v12 + 1))
        break;
      if (!*(_DWORD *)(v14 + 48) && _VideoPacketBuffer_ScheduleSingleFrame(a1, v14, a2, a3, a4, a5))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v18 = VRTraceErrorLogLevelToCSTR();
          v19 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v20 = *(_DWORD *)(a1 + 1032);
            v21 = *(unsigned __int16 *)(v14 + 150);
            v22 = *(_DWORD *)(v14 + 156);
            *(_DWORD *)buf = 136316930;
            v25 = v18;
            v26 = 2080;
            v27 = "_VideoPacketBuffer_SchedulePastIncompleteFrame_InternalLoop";
            v28 = 1024;
            v29 = 2053;
            v30 = 2048;
            v31 = a1;
            v32 = 1024;
            v33 = v20;
            v34 = 1024;
            v35 = a3;
            v36 = 1024;
            v37 = v21;
            v38 = 1024;
            v39 = v22;
            _os_log_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Late frame scheduled lateFramesScheduledCount=%d playoutRTPTimestamp=%u frameSequenceNumber=%u previousFrameSequenceNumber=%u", buf, 0x3Eu);
          }
        }
        ++*(_DWORD *)(a1 + 1032);
        kdebug_trace();
        *(_WORD *)(a1 + 420) = *(_WORD *)(a1 + 422);
        return 1;
      }
      v6 = *(_QWORD *)(v14 + 112);
      v13 = (uint64_t *)(v14 + 112);
    }
    while (v6);
  }
  return 0;
}

uint64_t VideoPacketBuffer_SchedulePastIncompleteFrame(uint64_t a1, int a2, _DWORD *a3, unsigned int a4, int a5, int a6)
{
  uint64_t v12;
  pthread_mutex_t *v13;
  unint64_t v14;
  uint64_t v15;
  double v16;
  uint64_t v17;
  uint64_t v19;
  NSObject *v20;
  uint64_t v21;
  NSObject *v22;
  int v23;
  int v24;
  uint64_t v25;
  NSObject *v26;
  NSObject *v27;
  int v28;
  uint64_t v29;
  __int16 v30;
  const char *v31;
  __int16 v32;
  int v33;
  __int16 v34;
  uint64_t v35;
  __int16 v36;
  _BYTE v37[10];
  __int16 v38;
  int v39;
  __int16 v40;
  int v41;
  __int16 v42;
  double v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (a1 && a3)
  {
    v12 = a1 + 145904;
    v13 = (pthread_mutex_t *)(a1 + 352);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 352));
    v15 = *(_QWORD *)v12;
    if (*(_QWORD *)v12)
    {
      if (*(_QWORD *)(a1 + 145912)
        && ((v16 = *(double *)(a1 + 440) - *(double *)(v15 + 24), v16 >= 0.5)
         || (LODWORD(v14) = *(_DWORD *)(v15 + 12), ((double)a4 - (double)v14) / (double)*(int *)(a1 + 8) >= 0.5)))
      {
        *(_BYTE *)(a1 + 145921) = 1;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v21 = VRTraceErrorLogLevelToCSTR();
          v22 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v23 = *(unsigned __int16 *)(*(_QWORD *)v12 + 150);
            v24 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 145912) + 150);
            v28 = 136317186;
            v29 = v21;
            v30 = 2080;
            v31 = "_VideoPacketBuffer_IsIncompleteFramesTooOld";
            v32 = 1024;
            v33 = 2012;
            v34 = 2048;
            v35 = a1;
            v36 = 1024;
            *(_DWORD *)v37 = a2;
            *(_WORD *)&v37[4] = 1024;
            *(_DWORD *)&v37[6] = a4;
            v38 = 1024;
            v39 = v23;
            v40 = 1024;
            v41 = v24;
            v42 = 2048;
            v43 = v16;
            _os_log_impl(&dword_1D8A54000, v22, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Flushing incomplete frame bufer timestamp=%u playoutRTPTimestamp=%u frameSequenceNumberAtHead=%hu frameSequenceNumberAtTail=%hu diffTime=%5.5f", (uint8_t *)&v28, 0x48u);
          }
        }
        _VideoPacketBuffer_ClearFrameList(a1, (uint64_t *)(a1 + 145904));
        *(_QWORD *)(a1 + 145912) = 0;
        *(_DWORD *)(a1 + 146012) = 0;
      }
      else if (*(_DWORD *)(a1 + 145972))
      {
        v17 = _VideoPacketBuffer_SchedulePastIncompleteFrame_InternalLoop(a1, a3, a4, a5, a6);
        pthread_mutex_unlock(v13);
        return v17;
      }
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v25 = VRTraceErrorLogLevelToCSTR();
      v26 = *MEMORY[0x1E0CF2758];
      v27 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        {
          v28 = 136315906;
          v29 = v25;
          v30 = 2080;
          v31 = "VideoPacketBuffer_SchedulePastIncompleteFrame";
          v32 = 1024;
          v33 = 2073;
          v34 = 2048;
          v35 = a1;
          _os_log_impl(&dword_1D8A54000, v26, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] schedule pointer is null", (uint8_t *)&v28, 0x26u);
        }
      }
      else if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
      {
        VideoPacketBuffer_SchedulePastIncompleteFrame_cold_1();
      }
    }
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 352));
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v19 = VRTraceErrorLogLevelToCSTR();
    v20 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      v28 = 136316162;
      v29 = v19;
      v30 = 2080;
      v31 = "VideoPacketBuffer_SchedulePastIncompleteFrame";
      v32 = 1024;
      v33 = 2066;
      v34 = 2048;
      v35 = a1;
      v36 = 2048;
      *(_QWORD *)v37 = a3;
      _os_log_error_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_ERROR, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] pointer is null scheduledFrameTimestamps=%p", (uint8_t *)&v28, 0x30u);
    }
  }
  return 0;
}

BOOL VideoPacketBuffer_GetFrameDecodingOrder(uint64_t a1, _BYTE *a2, _WORD *a3, _DWORD *a4)
{
  uint64_t v8;
  _BOOL8 result;

  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      VideoPacketBuffer_GetFrameDecodingOrder_cold_1();
    }
    return 0;
  }
  if (!*(_BYTE *)(a1 + 240))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      VideoPacketBuffer_GetFrameDecodingOrder_cold_2();
    }
    return 0;
  }
  *a2 = 0;
  *a3 = 0;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 352));
  v8 = *(_QWORD *)(a1 + 145896);
  if (v8)
  {
    while (*(_DWORD *)(v8 + 48))
    {
      v8 = *(_QWORD *)(v8 + 112);
      if (!v8)
        goto LABEL_15;
    }
    *a2 = *(_BYTE *)(v8 + 148);
    *a3 = *(_WORD *)(v8 + 146);
    *a4 = *(_DWORD *)(v8 + 12);
  }
LABEL_15:
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 352));
  return 1;
}

uint64_t _VideoPacketBuffer_GetStreamIDsForFrameInBuffer(uint64_t a1, uint64_t a2, int a3, _BYTE *a4, _QWORD *a5)
{
  pthread_mutex_t *v9;
  uint64_t v10;

  v9 = (pthread_mutex_t *)(a1 + 352);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 352));
  if (a2)
  {
    while (*(_DWORD *)(a2 + 12) != a3)
    {
      a2 = *(_QWORD *)(a2 + 112);
      if (!a2)
        goto LABEL_4;
    }
    *a4 = *(_BYTE *)(a2 + 121);
    *a5 = a2 + 122;
    v10 = 1;
  }
  else
  {
LABEL_4:
    v10 = 0;
  }
  pthread_mutex_unlock(v9);
  return v10;
}

uint64_t VideoPacketBuffer_GetFrameStreamIDs(uint64_t a1, int a2, _BYTE *a3, _QWORD *a4)
{
  uint64_t v8;
  int StreamIDsForFrameInBuffer;
  uint64_t result;

  if (a1)
  {
    v8 = a1 + 145896;
    StreamIDsForFrameInBuffer = _VideoPacketBuffer_GetStreamIDsForFrameInBuffer(a1, *(_QWORD *)(a1 + 145896), a2, a3, a4);
    return StreamIDsForFrameInBuffer | _VideoPacketBuffer_GetStreamIDsForFrameInBuffer(a1, *(_QWORD *)(v8 + 8), a2, a3, a4);
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    VideoPacketBuffer_GetFrameStreamIDs_cold_1();
  }
  return 0;
}

BOOL VideoPacketBuffer_FirstIDRReceived(uint64_t a1)
{
  _BOOL8 result;

  if (a1)
    return *(_DWORD *)(a1 + 145964) != 0;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    VideoPacketBuffer_FirstIDRReceived_cold_1();
  }
  return 0;
}

void VideoPacketBuffer_SetFrameSize(uint64_t a1, int a2, int a3)
{
  int ErrorLogLevelForModule;
  _DWORD *v7;
  uint64_t v8;
  NSObject *v9;
  pthread_mutex_t *v10;
  int v11;
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  uint64_t v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (a1)
  {
    v7 = (_DWORD *)(a1 + 145928);
    if (ErrorLogLevelForModule >= 7)
    {
      v8 = VRTraceErrorLogLevelToCSTR();
      v9 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v11 = 136316418;
        v12 = v8;
        v13 = 2080;
        v14 = "VideoPacketBuffer_SetFrameSize";
        v15 = 1024;
        v16 = 2875;
        v17 = 2048;
        v18 = a1;
        v19 = 1024;
        v20 = a2;
        v21 = 1024;
        v22 = a3;
        _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] %dx%d", (uint8_t *)&v11, 0x32u);
      }
    }
    v10 = (pthread_mutex_t *)(a1 + 352);
    pthread_mutex_lock(v10);
    *v7 = a2;
    v7[1] = a3;
    pthread_mutex_unlock(v10);
  }
  else if (ErrorLogLevelForModule >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VideoPacketBuffer_SetFrameSize_cold_1();
  }
}

uint64_t VideoPacketBuffer_GetNextFrame(uint64_t a1, int a2, uint64_t a3, int *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7, _DWORD *a8, _BYTE *a9, _QWORD *a10, unsigned __int16 a11, uint64_t a12)
{
  uint64_t v18;
  pthread_mutex_t *v19;
  uint64_t v20;
  _BOOL4 v21;
  unsigned int v22;
  double v23;
  BOOL v24;
  int v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _BOOL4 v30;
  char v31;
  int v32;
  char v33;
  int v34;
  unsigned int v35;
  int v36;
  uint64_t v37;
  NSObject *v38;
  NSObject *v39;
  int v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  uint64_t v46;
  _WORD *v47;
  _WORD *v48;
  unsigned int v49;
  _WORD *v50;
  _WORD *v51;
  _WORD *v52;
  uint64_t v53;
  unsigned int v54;
  pthread_mutex_t *v56;
  int v57;
  uint64_t v59;
  NSObject *v60;
  NSObject *v61;
  int v62;
  int v63;
  int v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  NSObject *v71;
  int v72;
  int v73;
  int v74;
  int v75;
  int v76;
  _BOOL4 v77;
  _DWORD *v78;
  int *v79;
  pthread_mutex_t *v81;
  uint64_t v82;
  uint64_t v83;
  uint8_t buf[4];
  uint64_t v85;
  __int16 v86;
  const char *v87;
  __int16 v88;
  int v89;
  __int16 v90;
  uint64_t v91;
  __int16 v92;
  int v93;
  __int16 v94;
  int v95;
  __int16 v96;
  int v97;
  __int16 v98;
  int v99;
  __int16 v100;
  int v101;
  uint64_t v102;

  v102 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoPacketBuffer_GetNextFrame_cold_1();
    }
    return 0;
  }
  v18 = a1 + 145896;
  v83 = 0;
  *a6 = 0;
  *a4 = -1;
  v19 = (pthread_mutex_t *)(a1 + 352);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 352));
  v20 = *(_QWORD *)v18;
  v21 = *(_QWORD *)v18 != 0;
  if (!*(_QWORD *)v18)
  {
    v20 = *(_QWORD *)(v18 + 8);
    if (!v20)
    {
      pthread_mutex_unlock(v19);
      return 0;
    }
  }
  v81 = v19;
  v79 = a4;
  v22 = *(_WORD *)(v20 + 150) & 0x7F;
  v82 = *(_QWORD *)(v20 + 104);
  v23 = micro();
  if (*(_BYTE *)(v20 + 152))
    v24 = *(_BYTE *)(v20 + 153) == 0;
  else
    v24 = 0;
  v25 = *(_DWORD *)(v18 + 68);
  if (!v25)
  {
    if (!*(_DWORD *)(v20 + 8))
      v24 = 1;
    if (!v24)
    {
      v77 = v21;
      v78 = a5;
      v29 = 0;
      *(_DWORD *)(v18 + 76) = 1;
      goto LABEL_28;
    }
  }
  v26 = *(_DWORD *)(v20 + 12) - a2;
  if (v26 < 1)
  {
LABEL_18:
    v78 = a5;
    v77 = v21;
    if (!v25 && !*(_BYTE *)(v20 + 55) && *(_DWORD *)(v20 + 8))
    {
      v29 = 0;
LABEL_28:
      *(_DWORD *)(v18 + 84) = 13;
LABEL_29:
      v28 = 0;
      if (a12 && !v29)
      {
        *(_DWORD *)a12 = *(_DWORD *)v20;
        *(_DWORD *)(a12 + 8) = *(_DWORD *)(v20 + 12);
        *(_BYTE *)(a12 + 14) = *(_BYTE *)(v20 + 120);
        *(_BYTE *)(a12 + 39) = *(_BYTE *)(v20 + 149);
        *(_WORD *)(a12 + 40) = *(_WORD *)(v20 + 150);
        v31 = *(_BYTE *)(v20 + 152);
        if (v31)
          v31 = *(_BYTE *)(v20 + 153) == 0;
        *(_BYTE *)(a12 + 72) = v31;
        *(_QWORD *)(a12 + 48) = *(_QWORD *)(v20 + 24);
        *(_BYTE *)(a12 + 75) = *(_BYTE *)(v20 + 161);
        v28 = 0;
        v29 = 0;
        if (a11 >= 2u)
        {
          *(_WORD *)(a12 + 16) = *(_WORD *)(v20 + 146);
          *(_BYTE *)(a12 + 18) = *(_BYTE *)(v20 + 148);
        }
      }
      goto LABEL_58;
    }
    v30 = _VCVideoPacketBuffer_AssembleFrame(a1, v20, &v83);
    *(_BYTE *)(a1 + 426) = v30;
    v29 = v83;
    if (!v30 || !v83)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v70 = VRTraceErrorLogLevelToCSTR();
        v71 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v72 = *(_DWORD *)(v20 + 12);
          v73 = **(unsigned __int16 **)(v20 + 96);
          v74 = *(unsigned __int16 *)(v20 + 150);
          v75 = *(unsigned __int8 *)(v20 + 149);
          *(_DWORD *)buf = 136317186;
          v85 = v70;
          v86 = 2080;
          v87 = "VideoPacketBuffer_GetNextFrame";
          v88 = 1024;
          v89 = 2993;
          v90 = 2048;
          v91 = a1;
          v92 = 1024;
          v93 = v72;
          v94 = 1024;
          v95 = a2;
          v96 = 1024;
          v97 = v73;
          v98 = 1024;
          v99 = v74;
          v100 = 1024;
          v101 = v75;
          _os_log_impl(&dword_1D8A54000, v71, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Frame assembly failed frameTS:%u for timestamp:%u seq=%u frameSequenceNumber=%u isFrameSequenceNumberValid=%d", buf, 0x44u);
        }
      }
      goto LABEL_29;
    }
    *(_DWORD *)(v83 + 8) = *(_DWORD *)v20;
    *(_DWORD *)(v29 + 16) = *(_DWORD *)(v20 + 12);
    *(_BYTE *)(v29 + 22) = *(_BYTE *)(v20 + 120);
    *(_DWORD *)(v29 + 40) = *(_DWORD *)(v20 + 4);
    *(_DWORD *)(v29 + 12) = *(_DWORD *)(v18 + 72);
    *(_WORD *)(v29 + 24) = *(_WORD *)(v20 + 146);
    *(_BYTE *)(v29 + 26) = *(_BYTE *)(v20 + 148);
    *(_BYTE *)(v29 + 47) = *(_BYTE *)(v20 + 149);
    *(_BYTE *)(v29 + 82) = *(_BYTE *)(v20 + 56);
    *(_WORD *)(v29 + 48) = *(_WORD *)(v20 + 150);
    *(_BYTE *)(v29 + 46) = *(_BYTE *)(v20 + 54);
    *(_QWORD *)(v29 + 56) = *(_QWORD *)(v20 + 24);
    if (*(_BYTE *)(v20 + 52))
    {
      *(_BYTE *)(v29 + 23) = 1;
    }
    else
    {
      v32 = *(unsigned __int8 *)(v20 + 53);
      *(_BYTE *)(v29 + 23) = v32;
      if (!v32)
      {
LABEL_39:
        v33 = *(_BYTE *)(v20 + 152);
        if (v33)
          v33 = *(_BYTE *)(v20 + 153) == 0;
        *(_BYTE *)(v29 + 80) = v33;
        *(_BYTE *)(v29 + 81) = *(_DWORD *)(v20 + 40) != 0;
        VCBlockBuffer_Copy(v20 + 72, v29 + 200);
        *a10 = v29;
        if ((*(_BYTE *)(v20 + 32) & 1) != 0 && !*(_DWORD *)(v18 + 76))
        {
          if (a7)
            *a7 = 1;
          if (a8)
          {
            if (*(_BYTE *)(a1 + 240))
              v34 = *(unsigned __int16 *)(v20 + 146);
            else
              v34 = *(_DWORD *)(v20 + 12);
            *a8 = v34;
          }
        }
        if (a9)
          *a9 = *(_BYTE *)(v20 + 36);
        if (v26)
          v28 = 2;
        else
          v28 = 1;
        if (*(_DWORD *)(v18 + 72) == 2)
          *(_DWORD *)(v18 + 72) = 1;
LABEL_58:
        v35 = *(_DWORD *)(v20 + 64);
        switch(*(_DWORD *)(v20 + 60))
        {
          case 0:
            break;
          case 1:
            ++*(_DWORD *)(a1 + 40 * v35 + 492);
            break;
          case 2:
            ++*(_DWORD *)(a1 + 40 * v35 + 496);
            break;
          case 3:
            ++*(_DWORD *)(a1 + 40 * v35 + 500);
            break;
          default:
            ++*(_DWORD *)(a1 + 40 * v35 + 504);
            break;
        }
        v36 = *(unsigned __int8 *)(v20 + 55);
        if (!*(_BYTE *)(v20 + 55) || !*(_DWORD *)(v18 + 76))
          *(_DWORD *)(a1 + 416) = *(_DWORD *)(v20 + 12);
        *(double *)(a1 + 432) = v23;
        if (*(_BYTE *)(v18 + 24))
        {
          a5 = v78;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            v37 = VRTraceErrorLogLevelToCSTR();
            v38 = *MEMORY[0x1E0CF2758];
            v39 = *MEMORY[0x1E0CF2758];
            if (*MEMORY[0x1E0CF2748])
            {
              if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
              {
                v40 = *(_DWORD *)(v20 + 12);
                v41 = *(unsigned __int16 *)(v20 + 150);
                *(_DWORD *)buf = 136316418;
                v85 = v37;
                v86 = 2080;
                v87 = "VideoPacketBuffer_GetNextFrame";
                v88 = 1024;
                v89 = 3062;
                v90 = 2048;
                v91 = a1;
                v92 = 1024;
                v93 = v40;
                v94 = 1024;
                v95 = v41;
                _os_log_impl(&dword_1D8A54000, v38, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Assembled incomplete frame with timestamp=%u, frameSequenceNumber=%d. Merging buffers!", buf, 0x32u);
              }
            }
            else if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
            {
              v63 = *(_DWORD *)(v20 + 12);
              v64 = *(unsigned __int16 *)(v20 + 150);
              *(_DWORD *)buf = 136316418;
              v85 = v37;
              v86 = 2080;
              v87 = "VideoPacketBuffer_GetNextFrame";
              v88 = 1024;
              v89 = 3062;
              v90 = 2048;
              v91 = a1;
              v92 = 1024;
              v93 = v63;
              v94 = 1024;
              v95 = v64;
              _os_log_debug_impl(&dword_1D8A54000, v38, OS_LOG_TYPE_DEBUG, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Assembled incomplete frame with timestamp=%u, frameSequenceNumber=%d. Merging buffers!", buf, 0x32u);
            }
          }
          v44 = (uint64_t *)(v18 + 8);
          v43 = *(_QWORD *)(v18 + 8);
          if (v43)
            v43 = *(_QWORD *)(v43 + 112);
          *v44 = v43;
          _VideoPacketBuffer_FreeFrame(a1, (_QWORD *)v20);
          v45 = *v44;
          if (*v44)
          {
            do
            {
              v46 = *(_QWORD *)(v45 + 112);
              _VideoPacketBuffer_AddFrameToBufferInOrder((uint64_t *)v18, v45);
              v45 = v46;
            }
            while (v46);
          }
          *v44 = 0;
          *(_QWORD *)(v18 + 16) = 0;
          *(_QWORD *)(v18 + 112) = (*(_DWORD *)(v18 + 116) + *(_DWORD *)(v18 + 112) - 1);
          *(_BYTE *)(v18 + 24) = 0;
        }
        else if (!*(_BYTE *)(a1 + 241) || v29 || !*(_DWORD *)(v18 + 76) || *(_BYTE *)(a1 + 426) || *(_BYTE *)(v18 + 25))
        {
          if (v77)
          {
            v42 = *(_QWORD *)v18;
            a5 = v78;
            if (*(_QWORD *)v18)
              v42 = *(_QWORD *)(v42 + 112);
            *(_QWORD *)v18 = v42;
            _VideoPacketBuffer_FreeFrame(a1, (_QWORD *)v20);
            --*(_DWORD *)(v18 + 112);
          }
          else
          {
            a5 = v78;
          }
        }
        else
        {
          a5 = v78;
          if (!v36)
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
            {
              v59 = VRTraceErrorLogLevelToCSTR();
              v60 = *MEMORY[0x1E0CF2758];
              v61 = *MEMORY[0x1E0CF2758];
              if (*MEMORY[0x1E0CF2748])
              {
                if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
                {
                  v62 = *(unsigned __int16 *)(v20 + 150);
                  *(_DWORD *)buf = 136316162;
                  v85 = v59;
                  v86 = 2080;
                  v87 = "_VideoPacketBuffer_MoveEvictedFrameToIncompleteFrameBuffer";
                  v88 = 1024;
                  v89 = 2887;
                  v90 = 2048;
                  v91 = a1;
                  v92 = 1024;
                  v93 = v62;
                  _os_log_impl(&dword_1D8A54000, v60, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Moving Evicted frame with frameSequenceNumber=%u to incomplete buffer", buf, 0x2Cu);
                }
              }
              else if (os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG))
              {
                v76 = *(unsigned __int16 *)(v20 + 150);
                *(_DWORD *)buf = 136316162;
                v85 = v59;
                v86 = 2080;
                v87 = "_VideoPacketBuffer_MoveEvictedFrameToIncompleteFrameBuffer";
                v88 = 1024;
                v89 = 2887;
                v90 = 2048;
                v91 = a1;
                v92 = 1024;
                v93 = v76;
                _os_log_debug_impl(&dword_1D8A54000, v60, OS_LOG_TYPE_DEBUG, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Moving Evicted frame with frameSequenceNumber=%u to incomplete buffer", buf, 0x2Cu);
              }
            }
            v65 = *(_QWORD *)v18;
            if (*(_QWORD *)v18 == v20)
            {
              v65 = *(_QWORD *)(v20 + 112);
              *(_QWORD *)v18 = v65;
            }
            while (v65)
            {
              v66 = v65;
              v65 = *(_QWORD *)(v65 + 112);
              if (v65 == v20)
              {
                if (v20)
                  v67 = *(_QWORD *)(v20 + 112);
                else
                  v67 = 0;
                *(_QWORD *)(v66 + 112) = v67;
                break;
              }
            }
            _VideoPacketBuffer_AddFrameToBufferInOrder((uint64_t *)(v18 + 8), v20);
            *(int32x2_t *)(v18 + 112) = vadd_s32(*(int32x2_t *)(v18 + 112), (int32x2_t)0x1FFFFFFFFLL);
            v68 = *(_QWORD *)(v18 + 8);
            do
            {
              v69 = v68;
              if (!v68)
                break;
              v68 = *(_QWORD *)(v68 + 112);
            }
            while (v68);
            *(_QWORD *)(v18 + 16) = v69;
            *(_BYTE *)(v20 + 55) = 1;
            kdebug_trace();
          }
          *(_DWORD *)(v20 + 44) = 0;
          *(_DWORD *)(v20 + 48) = 0;
        }
        goto LABEL_88;
      }
    }
    *(_DWORD *)(v29 + 68) = *(_DWORD *)(v18 + 36) * *(_DWORD *)(v18 + 32);
    goto LABEL_39;
  }
  v27 = *(_QWORD *)(v18 + 8);
  if (v27)
  {
    v28 = 0;
    v26 = *(_DWORD *)(v27 + 12) - a2;
    if (v26 <= 0)
    {
      v21 = 0;
      v20 = *(_QWORD *)(v18 + 8);
      goto LABEL_18;
    }
  }
  else
  {
    v28 = 0;
  }
LABEL_88:
  VideoPacketBuffer_UpdateMaxFrameBurstLossStatistics(a1, v22, (unsigned __int16 *)&v82, *(unsigned __int16 *)(v20 + 150), *(_DWORD *)(v20 + 12), *(_DWORD *)(v20 + 44) != 0, *(double *)(v20 + 24));
  v47 = (_WORD *)(a1 + 800 * v22);
  v48 = v47 + 21353;
  v49 = (unsigned __int16)v47[21353];
  v50 = v47 + 21350;
  v51 = v47 + 21354;
  v52 = v47 + 21362;
  v53 = 128;
  do
  {
    v54 = (unsigned __int16)*(v52 - 1);
    if (v54 != 8 && v54 >= v49)
    {
      *v50 = *(v52 - 2);
      *v48 = v54;
      *v51 = *v52;
      v49 = v54;
    }
    v52 += 3;
    --v53;
  }
  while (v53);
  memcpy((void *)(a1 + 145120), (const void *)(a1 + 800 * v22 + 42720), 0x300uLL);
  _VideoPacketBuffer_ProcessFrameStats(a1, v23);
  if (*(_DWORD *)(v18 + 76))
  {
    ++*(_DWORD *)(a1 + 456);
    v56 = v81;
    *a6 = 1;
    if (v23 - *(double *)(v18 + 40) > *(double *)(a1 + 448))
    {
      if (*(_DWORD *)(v18 + 68) && *(_DWORD *)(v18 + 72))
        v57 = 2;
      else
        v57 = 0;
      *v79 = v57;
      *a5 = *(_DWORD *)(v18 + 84);
      *(double *)(v18 + 40) = v23;
    }
  }
  else
  {
    *(_QWORD *)(v18 + 40) = 0;
    v56 = v81;
  }
  pthread_mutex_unlock(v56);
  return v28;
}

BOOL _VCVideoPacketBuffer_AssembleFrame(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  unsigned int v9;
  int v10;
  unsigned int v11;
  int v12;
  uint64_t v13;
  NSObject *v14;
  NSObject *v15;
  int v16;
  unsigned int v18;
  unsigned __int16 *v19;
  BOOL v20;
  char v21;
  unsigned int v22;
  const void *v23;
  unsigned int v24;
  int v25;
  BOOL v26;
  OSStatus Empty;
  const __CFAllocator *v28;
  const __CFAllocator *v29;
  int32_t v30;
  int v31;
  OSStatus appended;
  OpaqueCMBlockBuffer *v33;
  int v34;
  int v35;
  int v36;
  uint64_t v37;
  NSObject *v38;
  BOOL v39;
  int v40;
  int v41;
  size_t v42;
  unsigned __int16 v43;
  uint64_t v44;
  NSObject *v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  size_t v51;
  OSStatus v52;
  int v53;
  unsigned int v54;
  size_t v55;
  uint64_t v56;
  CMBlockBufferRef v57;
  unsigned int v58;
  BOOL v59;
  uint64_t v60;
  unint64_t v61;
  OSStatus v62;
  uint64_t v63;
  NSObject *v64;
  int v65;
  uint64_t v66;
  NSObject *v67;
  unsigned int v68;
  const __CFAllocator *v69;
  const __CFAllocator *DataLength;
  const __CFAllocator **v71;
  OSStatus Contiguous;
  uint64_t v73;
  NSObject *v74;
  NSObject *v75;
  int v76;
  int v77;
  int v78;
  uint64_t (*v79)(_QWORD, CMBlockBufferRef, CMBlockBufferRef *);
  int v80;
  size_t v81;
  unint64_t v82;
  OpaqueCMBlockBuffer *v83;
  int v84;
  uint64_t v85;
  NSObject *v86;
  int v87;
  int v88;
  int v89;
  int v90;
  int v91;
  int v92;
  int v93;
  const __CFAllocator **v94;
  __int128 v95;
  unsigned int v96;
  BOOL v97;
  size_t v98;
  uint64_t v99;
  int v100;
  size_t v103;
  size_t v104;
  int v105;
  size_t v106;
  OSStatus v107;
  int FrameSliceHeader;
  unint64_t v109;
  uint64_t v110;
  NSObject *v111;
  uint64_t v112;
  NSObject *v113;
  NSObject *v114;
  const char *v115;
  uint32_t v116;
  uint64_t v117;
  NSObject *v118;
  OSStatus v119;
  int v120;
  int v121;
  uint64_t v122;
  NSObject *v123;
  int v124;
  int v125;
  int v126;
  uint64_t v127;
  NSObject *v128;
  OSStatus v129;
  uint64_t v130;
  NSObject *v131;
  OSStatus v132;
  uint64_t v133;
  NSObject *v134;
  int v135;
  uint64_t v136;
  NSObject *v137;
  int v138;
  int v139;
  int v140;
  int v141;
  int v142;
  BOOL v143;
  int v144;
  int v145;
  uint64_t v146;
  NSObject *v147;
  int v148;
  int v149;
  int v150;
  int v151;
  int v152;
  char v153;
  uint64_t v154;
  NSObject *v155;
  int v156;
  int v157;
  int v158;
  int v159;
  int v160;
  uint64_t v161;
  NSObject *v162;
  int v163;
  int v164;
  int v165;
  int v166;
  int v167;
  _BOOL4 v168;
  int v169;
  uint64_t v170;
  NSObject *v171;
  int v172;
  int v173;
  int v174;
  uint64_t v175;
  NSObject *v176;
  int v177;
  int v178;
  int v179;
  uint64_t v180;
  NSObject *v181;
  int v182;
  uint64_t v183;
  NSObject *v184;
  int v185;
  int v186;
  int v187;
  int v188;
  double v189;
  double v190;
  double v191;
  uint64_t v192;
  double v193;
  unsigned int v194;
  unsigned int v195;
  uint64_t v196;
  NSObject *v197;
  NSObject *v198;
  int v199;
  int v200;
  int v201;
  uint64_t v202;
  uint64_t v203;
  int v204;
  uint64_t v205;
  NSObject *v206;
  unsigned int v207;
  uint64_t v208;
  NSObject *v209;
  int v210;
  int v211;
  int v212;
  uint64_t v213;
  NSObject *v214;
  size_t v215;
  uint64_t v216;
  int v217;
  OSStatus v218;
  uint64_t v219;
  NSObject *v220;
  uint64_t v221;
  NSObject *v222;
  NSObject *v223;
  int v224;
  int v225;
  const char *v226;
  NSObject *v227;
  uint32_t v228;
  int v229;
  uint64_t v230;
  NSObject *v231;
  NSObject *v232;
  int v233;
  int v234;
  int v235;
  int v236;
  int v237;
  int v238;
  uint64_t v239;
  NSObject *v240;
  int ErrorLogLevelForModule;
  uint64_t v242;
  NSObject *v243;
  uint64_t v244;
  NSObject *v245;
  size_t v246;
  const char *v247;
  NSObject *v248;
  int v249;
  int v250;
  const char *v251;
  NSObject *v252;
  uint32_t v253;
  OSStatus v254;
  uint64_t v255;
  NSObject *v256;
  uint32_t v257;
  uint64_t v258;
  NSObject *v259;
  __int16 v260;
  unsigned __int16 *v261;
  unsigned int v262;
  unsigned int v263;
  unsigned __int16 v264;
  unsigned int v265;
  uint64_t v266;
  NSObject *v267;
  _BOOL8 v268;
  unsigned int v269;
  uint64_t v270;
  NSObject *v271;
  int v272;
  uint64_t v273;
  NSObject *v274;
  int v275;
  FILE **v276;
  unint64_t v277;
  __int128 v278;
  uint64_t v280;
  NSObject *v281;
  int v282;
  const char *v283;
  const __CFAllocator **v284;
  uint64_t v285;
  NSObject *v286;
  int v287;
  int v288;
  int v289;
  const char *v290;
  int v291;
  int v292;
  const char *v293;
  const char *v294;
  NSObject *v295;
  uint32_t v296;
  int v297;
  int v298;
  int v299;
  uint64_t v300;
  uint64_t v301;
  uint64_t v302;
  NSObject *v303;
  int v304;
  OSStatus v305;
  uint64_t v306;
  NSObject *v307;
  size_t v308;
  uint64_t v309;
  NSObject *v310;
  OSStatus v311;
  uint64_t v312;
  NSObject *v313;
  OSStatus v314;
  uint64_t v315;
  OSStatus v316;
  uint64_t v317;
  int v318;
  uint64_t v319;
  NSObject *v320;
  int v321;
  uint64_t v322;
  NSObject *v323;
  int v324;
  int v325;
  int v326;
  const __CFAllocator **v327;
  char **v328;
  size_t *v329;
  char **v330;
  size_t *v331;
  char **v332;
  size_t *v333;
  CMBlockBufferRef *v334;
  CMBlockBufferRef *v335;
  CMBlockBufferRef *v336;
  size_t v337;
  unint64_t offsetToData;
  int v339;
  int v340;
  int v341;
  _DWORD *v342;
  int v343;
  int v344;
  int v346;
  unint64_t v347;
  int v348;
  OpaqueCMBlockBuffer *v349;
  uint64_t v350;
  uint64_t v351;
  uint64_t v352;
  unint64_t v353;
  const __CFAllocator **v354;
  CFTypeRef v355;
  uint64_t v356;
  size_t v357;
  CMBlockBufferRef theBuffer;
  CMBlockBufferRef blockBufferOut;
  unsigned __int16 v360;
  unsigned __int16 v361;
  CFTypeRef cf;
  size_t totalLengthOut;
  size_t v364;
  char *dataPointerOut;
  uint8_t buf[96];
  __int128 v367;
  __int128 v368;
  __int128 v369;
  __int128 v370;
  __int128 v371;
  __int128 v372;
  _OWORD v373[13];
  CMBlockBufferRef __s2[2];
  _BYTE lengthAtOffsetOut[12];
  __int16 v376;
  const char *v377;
  __int16 v378;
  int v379;
  __int16 v380;
  uint64_t v381;
  __int16 v382;
  __int128 v383;
  __int16 v384;
  _BYTE v385[10];
  _BYTE v386[10];
  __int16 v387;
  const char *v388;
  uint64_t v389;

  v4 = a1;
  v389 = *MEMORY[0x1E0C80C00];
  v5 = a1 + 145888;
  theBuffer = 0;
  blockBufferOut = 0;
  v355 = 0;
  v356 = 0;
  v357 = 0;
  v354 = 0;
  if (CMBlockBufferCreateEmpty(*(CFAllocatorRef *)(a1 + 146048), 0x1F4u, 0, &blockBufferOut))
  {
    v33 = 0;
    LODWORD(v353) = 0;
    LOBYTE(v352) = 0;
    v344 = 0;
    v217 = 7;
    goto LABEL_364;
  }
  v6 = *(_QWORD *)(a2 + 96);
  if (v6)
  {
    v7 = 0;
    v8 = *(_QWORD *)(a2 + 96);
    while (1)
    {
      if (!*(_DWORD *)(v8 + 24))
        goto LABEL_9;
      v9 = *(_DWORD *)(v8 + 32);
      if (!(v9 >> 30))
        break;
      if ((v9 & 0x400000) != 0)
        goto LABEL_9;
LABEL_10:
      v8 = *(_QWORD *)(v8 + 104);
      if (!v8)
      {
        v10 = 0;
        while (1)
        {
          if (*(_DWORD *)(v6 + 24))
          {
            v11 = *(_DWORD *)(v6 + 32);
            if (!(v11 >> 30))
            {
              if ((v11 & 0x800000) != 0)
                goto LABEL_18;
LABEL_17:
              ++v10;
              goto LABEL_18;
            }
            if ((v11 & 0x400000) == 0)
              goto LABEL_17;
          }
LABEL_18:
          v6 = *(_QWORD *)(v6 + 104);
          if (!v6)
            goto LABEL_21;
        }
      }
    }
    if ((v9 & 0x800000) == 0)
      goto LABEL_10;
LABEL_9:
    ++v7;
    goto LABEL_10;
  }
  v7 = 0;
  v10 = 0;
LABEL_21:
  v343 = *(unsigned __int16 *)(a2 + 104);
  v344 = v10;
  v341 = v7;
  v346 = v343 - v7;
  v12 = v343 - v7 - v10;
  if (v343 - v7 > v10 && (int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v13 = VRTraceErrorLogLevelToCSTR();
    v14 = *MEMORY[0x1E0CF2758];
    v15 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        v16 = *(unsigned __int16 *)(a2 + 150);
        *(_DWORD *)buf = 136317186;
        *(_QWORD *)&buf[4] = v13;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VCVideoPacketBuffer_AssembleFrame";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 2692;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v16;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = v343;
        *(_WORD *)&buf[40] = 1024;
        *(_DWORD *)&buf[42] = v346;
        *(_WORD *)&buf[46] = 1024;
        *(_DWORD *)&buf[48] = v341;
        *(_WORD *)&buf[52] = 1024;
        *(_DWORD *)&buf[54] = v344;
        *(_WORD *)&buf[58] = 1024;
        *(_DWORD *)&buf[60] = v12;
        _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d This frame has unrecoverable loss, consider checking why the FEC Feedback Analyzer did not provide enough protection frameSequenceNumber=%d videoPacketsExpected=%d missingMediaPacketsCount=%d mediaCount=%d parityCount=%d  extraParityPacketsNeededCount=%d", buf, 0x40u);
      }
    }
    else if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      v229 = *(unsigned __int16 *)(a2 + 150);
      *(_DWORD *)buf = 136317186;
      *(_QWORD *)&buf[4] = v13;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "_VCVideoPacketBuffer_AssembleFrame";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 2692;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = v229;
      *(_WORD *)&buf[34] = 1024;
      *(_DWORD *)&buf[36] = v343;
      *(_WORD *)&buf[40] = 1024;
      *(_DWORD *)&buf[42] = v346;
      *(_WORD *)&buf[46] = 1024;
      *(_DWORD *)&buf[48] = v341;
      *(_WORD *)&buf[52] = 1024;
      *(_DWORD *)&buf[54] = v344;
      *(_WORD *)&buf[58] = 1024;
      *(_DWORD *)&buf[60] = v12;
      _os_log_debug_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEBUG, "VideoPacketBuffer [%s] %s:%d This frame has unrecoverable loss, consider checking why the FEC Feedback Analyzer did not provide enough protection frameSequenceNumber=%d videoPacketsExpected=%d missingMediaPacketsCount=%d mediaCount=%d parityCount=%d  extraParityPacketsNeededCount=%d", buf, 0x40u);
    }
  }
  if (*(_DWORD *)(a2 + 40))
  {
    if (v346 >= 1 && *(_WORD *)(a2 + 104) != 0)
    {
      if (v346 >= 101)
        v18 = 101;
      else
        v18 = v346;
      ++*(_WORD *)(v4 + 2 * v18 + 712);
    }
  }
  v19 = *(unsigned __int16 **)(a2 + 96);
  if (!v19)
  {
    _VCVideoPacketBuffer_FinalizeGOBLengthAdjustement((uint64_t)&v355);
    LODWORD(v353) = 0;
    goto LABEL_508;
  }
  v350 = v5;
  v20 = 0;
  v352 = 0;
  v353 = 0;
  v348 = 0;
  v342 = (_DWORD *)(v4 + 42684);
  v21 = 1;
  v351 = v4;
  while (*((_DWORD *)v19 + 6))
  {
    v22 = *((_DWORD *)v19 + 8);
    if (v22 >> 30)
    {
      if ((v22 & 0x400000) != 0)
        break;
    }
    else if ((v22 & 0x800000) != 0)
    {
      break;
    }
LABEL_107:
    v19 = (unsigned __int16 *)*((_QWORD *)v19 + 13);
    if (!v19)
    {
      _VCVideoPacketBuffer_FinalizeGOBLengthAdjustement((uint64_t)&v355);
      if (v20)
      {
        v5 = v350;
        if (!*(_BYTE *)(a2 + 152))
        {
LABEL_119:
          if (*(_BYTE *)(v4 + 228))
          {
            *(_QWORD *)lengthAtOffsetOut = 0xAAAAAAAAAAAAAAAALL;
            __s2[0] = 0;
            if (CMBlockBufferGetDataPointer(blockBufferOut, v353 - 8, (size_t *)lengthAtOffsetOut, 0, (char **)__s2))
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  _VCVideoPacketBuffer_AssembleFrame_cold_7();
              }
            }
            else if (*((_DWORD *)__s2[0] + 1) == 1357975584)
            {
              v54 = *(_DWORD *)__s2[0];
              v55 = 0;
              if (CMBlockBufferGetDataPointer(blockBufferOut, 0, (size_t *)lengthAtOffsetOut, 0, (char **)__s2))
              {
                LODWORD(v56) = 0;
                v57 = 0;
              }
              else
              {
                do
                {
                  v57 = __s2[0];
                  v56 = bswap32(*(_DWORD *)__s2[0]);
                  v55 += v56 + 4;
                }
                while (!CMBlockBufferGetDataPointer(blockBufferOut, v55, (size_t *)lengthAtOffsetOut, 0, (char **)__s2));
              }
              if (v55 == v353)
              {
                v58 = bswap32(v54);
                v59 = v56 >= v58;
                v60 = v56 - v58;
                if ((_DWORD)v60 != 0 && v59)
                {
                  *(_DWORD *)v57 = v54;
                  *(_QWORD *)buf = 0xAAAAAAAAAAAAAAAALL;
                  v61 = v353 - v60;
                  if (CMBlockBufferCreateWithBufferReference(*(CFAllocatorRef *)(v350 + 160), blockBufferOut, 0, v353 - v60, 0, (CMBlockBufferRef *)buf))
                  {
                    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                    {
                      VRTraceErrorLogLevelToCSTR();
                      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                        _VCVideoPacketBuffer_AssembleFrame_cold_6();
                    }
                  }
                  else
                  {
                    if (blockBufferOut)
                      CFRelease(blockBufferOut);
                    blockBufferOut = *(CMBlockBufferRef *)buf;
                    v353 = v61;
                  }
                }
              }
              else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                v66 = VRTraceErrorLogLevelToCSTR();
                v67 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136316418;
                  *(_QWORD *)&buf[4] = v66;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = "_VCVideoPacketBuffer_StripFakeLargeFramePadding";
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&buf[24] = 264;
                  *(_WORD *)&buf[28] = 2048;
                  *(_QWORD *)&buf[30] = v4;
                  *(_WORD *)&buf[38] = 1024;
                  *(_DWORD *)&buf[40] = v55;
                  *(_WORD *)&buf[44] = 1024;
                  *(_DWORD *)&buf[46] = v353;
                  _os_log_error_impl(&dword_1D8A54000, v67, OS_LOG_TYPE_ERROR, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Found corrupted buffer. Offset:%d BufferLen:%d", buf, 0x32u);
                }
              }
            }
          }
          VCVideoReceiverSampleBuffer_Create(*(const __CFAllocator **)(v350 + 168), &v354);
          v68 = *(_DWORD *)a2 - 110;
          if (v68 <= 0xF && ((1 << v68) & 0xC001) != 0)
          {
            v69 = (const __CFAllocator *)CFRetain(blockBufferOut);
            v354[13] = v69;
            DataLength = (const __CFAllocator *)CMBlockBufferGetDataLength(blockBufferOut);
            v71 = v354;
            v354[14] = DataLength;
            Contiguous = CMBlockBufferCreateContiguous(*(CFAllocatorRef *)(v350 + 160), blockBufferOut, 0, 0, 0, (size_t)DataLength, 0, v71 + 15);
            if (Contiguous)
            {
              v305 = Contiguous;
              if ((int)VRTraceGetErrorLogLevelForModule() < 3)
                goto LABEL_417;
              v306 = VRTraceErrorLogLevelToCSTR();
              v307 = *MEMORY[0x1E0CF2758];
              if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                goto LABEL_417;
              *(_DWORD *)buf = 136316162;
              *(_QWORD *)&buf[4] = v306;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_VCVideoPacketBuffer_AssembleFrame";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 2753;
              *(_WORD *)&buf[28] = 2048;
              *(_QWORD *)&buf[30] = v4;
              *(_WORD *)&buf[38] = 1024;
              *(_DWORD *)&buf[40] = v305;
              v294 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] failed to create data frame. Status=%d";
              v295 = v307;
              v296 = 44;
              goto LABEL_503;
            }
            *(_DWORD *)(v350 + 76) = 1;
            ++*v342;
LABEL_159:
            if (!*(_BYTE *)(v4 + 240) && !*(_BYTE *)(a2 + 152))
            {
              if (*(_BYTE *)(a2 + 149))
              {
                if (*(_WORD *)(v4 + 424))
                {
                  v84 = *(unsigned __int16 *)(a2 + 150) - *(unsigned __int16 *)(v4 + 424);
                  if (v84 >= 2
                    && !*(_BYTE *)(a2 + 52)
                    && !*(_BYTE *)(a2 + 53)
                    && (int)VRTraceGetErrorLogLevelForModule() >= 3)
                  {
                    v85 = VRTraceErrorLogLevelToCSTR();
                    v86 = *MEMORY[0x1E0CF2758];
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                    {
                      v87 = *(_DWORD *)(a2 + 12);
                      v88 = *(unsigned __int8 *)(a2 + 53);
                      v89 = *(unsigned __int8 *)(a2 + 52);
                      v90 = *(unsigned __int16 *)(a2 + 150);
                      v91 = *(unsigned __int16 *)(v4 + 424);
                      *(_DWORD *)buf = 136317442;
                      *(_QWORD *)&buf[4] = v85;
                      *(_WORD *)&buf[12] = 2080;
                      *(_QWORD *)&buf[14] = "_VCVideoPacketBuffer_AssembleFrame";
                      *(_WORD *)&buf[22] = 1024;
                      *(_DWORD *)&buf[24] = 2774;
                      *(_WORD *)&buf[28] = 2048;
                      *(_QWORD *)&buf[30] = v4;
                      *(_WORD *)&buf[38] = 1024;
                      *(_DWORD *)&buf[40] = v87;
                      *(_WORD *)&buf[44] = 1024;
                      *(_DWORD *)&buf[46] = v88;
                      *(_WORD *)&buf[50] = 1024;
                      *(_DWORD *)&buf[52] = v89;
                      *(_WORD *)&buf[56] = 1024;
                      *(_DWORD *)&buf[58] = v90;
                      *(_WORD *)&buf[62] = 1024;
                      *(_DWORD *)&buf[64] = v91;
                      *(_WORD *)&buf[68] = 1024;
                      *(_DWORD *)&buf[70] = v84;
                      _os_log_error_impl(&dword_1D8A54000, v86, OS_LOG_TYPE_ERROR, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Assembled after gap in Frame Sequence Number without Refresh Frame timestamp=%u isLTRPFrame=%u isIntraFrame=%u frameSequenceNumber=%u lastAssembledFrameSequenceNumber=%u gapFrameSequenceNumber=%d", buf, 0x4Au);
                    }
                  }
                }
              }
            }
            if (*(_BYTE *)(a2 + 52) || *(_BYTE *)(a2 + 53))
            {
              if (*(_BYTE *)(v5 + 33))
              {
                *(_BYTE *)(v5 + 33) = 0;
                if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
                {
                  v73 = VRTraceErrorLogLevelToCSTR();
                  v74 = *MEMORY[0x1E0CF2758];
                  v75 = *MEMORY[0x1E0CF2758];
                  if (*MEMORY[0x1E0CF2748])
                  {
                    if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
                    {
                      v76 = *(unsigned __int8 *)(a2 + 52);
                      v77 = *(unsigned __int8 *)(a2 + 53);
                      v78 = *(unsigned __int16 *)(a2 + 150);
                      *(_DWORD *)buf = 136316674;
                      *(_QWORD *)&buf[4] = v73;
                      *(_WORD *)&buf[12] = 2080;
                      *(_QWORD *)&buf[14] = "_VCVideoPacketBuffer_AssembleFrame";
                      *(_WORD *)&buf[22] = 1024;
                      *(_DWORD *)&buf[24] = 2782;
                      *(_WORD *)&buf[28] = 2048;
                      *(_QWORD *)&buf[30] = v4;
                      *(_WORD *)&buf[38] = 1024;
                      *(_DWORD *)&buf[40] = v76;
                      *(_WORD *)&buf[44] = 1024;
                      *(_DWORD *)&buf[46] = v77;
                      *(_WORD *)&buf[50] = 1024;
                      *(_DWORD *)&buf[52] = v78;
                      _os_log_impl(&dword_1D8A54000, v74, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Refresh frame has arrived and we can resume enqueueing late frames isIntraFrame=%d isLTRPFrame=%d frameSequenceNumber=%u", buf, 0x38u);
                    }
                  }
                  else if (os_log_type_enabled(v75, OS_LOG_TYPE_DEBUG))
                  {
                    v236 = *(unsigned __int8 *)(a2 + 52);
                    v237 = *(unsigned __int8 *)(a2 + 53);
                    v238 = *(unsigned __int16 *)(a2 + 150);
                    *(_DWORD *)buf = 136316674;
                    *(_QWORD *)&buf[4] = v73;
                    *(_WORD *)&buf[12] = 2080;
                    *(_QWORD *)&buf[14] = "_VCVideoPacketBuffer_AssembleFrame";
                    *(_WORD *)&buf[22] = 1024;
                    *(_DWORD *)&buf[24] = 2782;
                    *(_WORD *)&buf[28] = 2048;
                    *(_QWORD *)&buf[30] = v4;
                    *(_WORD *)&buf[38] = 1024;
                    *(_DWORD *)&buf[40] = v236;
                    *(_WORD *)&buf[44] = 1024;
                    *(_DWORD *)&buf[46] = v237;
                    *(_WORD *)&buf[50] = 1024;
                    *(_DWORD *)&buf[52] = v238;
                    _os_log_debug_impl(&dword_1D8A54000, v74, OS_LOG_TYPE_DEBUG, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Refresh frame has arrived and we can resume enqueueing late frames isIntraFrame=%d isLTRPFrame=%d frameSequenceNumber=%u", buf, 0x38u);
                  }
                }
              }
            }
            v33 = 0;
            v92 = 0;
            v93 = 1;
            goto LABEL_434;
          }
          v79 = *(uint64_t (**)(_QWORD, CMBlockBufferRef, CMBlockBufferRef *))(v4 + 256);
          if (!v79)
          {
            if (blockBufferOut)
              v83 = (OpaqueCMBlockBuffer *)CFRetain(blockBufferOut);
            else
              v83 = 0;
            theBuffer = v83;
            v82 = v353;
LABEL_187:
            v94 = v354;
            __s2[0] = (CMBlockBufferRef)0xAAAAAAAAAAAAAAAALL;
            __s2[1] = (CMBlockBufferRef)0xAAAAAAAAAAAAAAAALL;
            *(_QWORD *)&v95 = 0xAAAAAAAAAAAAAAAALL;
            *((_QWORD *)&v95 + 1) = 0xAAAAAAAAAAAAAAAALL;
            v373[11] = v95;
            v373[12] = v95;
            v373[9] = v95;
            v373[10] = v95;
            v373[7] = v95;
            v373[8] = v95;
            v373[5] = v95;
            v373[6] = v95;
            v373[3] = v95;
            v373[4] = v95;
            v373[1] = v95;
            v373[2] = v95;
            v372 = v95;
            v373[0] = v95;
            v370 = v95;
            v371 = v95;
            v368 = v95;
            v369 = v95;
            *(_OWORD *)&buf[80] = v95;
            v367 = v95;
            *(_OWORD *)&buf[48] = v95;
            *(_OWORD *)&buf[64] = v95;
            *(_OWORD *)&buf[16] = v95;
            *(_OWORD *)&buf[32] = v95;
            *(_OWORD *)buf = v95;
            v94[13] = (const __CFAllocator *)CFRetain(v83);
            v94[14] = (const __CFAllocator *)CMBlockBufferGetDataLength(v83);
            v327 = v94;
            if ((int)v82 >= 1)
            {
              v96 = 0;
              v339 = 0;
              v336 = v94 + 22;
              v337 = 0;
              v332 = (char **)(v94 + 24);
              v333 = (size_t *)(v94 + 23);
              v330 = (char **)(v94 + 18);
              v331 = (size_t *)(v94 + 17);
              v334 = v94 + 19;
              v335 = v94 + 16;
              v328 = (char **)(v94 + 21);
              v329 = (size_t *)(v94 + 20);
              offsetToData = -1;
              v340 = 1;
              v349 = v83;
              v347 = v82;
              while (1)
              {
                v364 = 0xAAAAAAAAAAAAAAAALL;
                dataPointerOut = 0;
                totalLengthOut = 0xAAAAAAAAAAAAAAAALL;
                if (CMBlockBufferGetDataPointer(v83, v96, &v364, 0, &dataPointerOut))
                  break;
                v97 = v364 < 4 || (unint64_t)v96 + 4 > v82;
                if (v97)
                {
                  if ((int)VRTraceGetErrorLogLevelForModule() < 3)
                  {
                    v204 = 2;
                    goto LABEL_377;
                  }
                  VRTraceErrorLogLevelToCSTR();
                  v5 = v350;
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                    _VCVideoPacketBuffer_AssembleFrame_cold_3();
LABEL_395:
                  v204 = 2;
                  goto LABEL_414;
                }
                v98 = bswap32(*(_DWORD *)dataPointerOut);
                v99 = (v98 + 4);
                v100 = v99 + v96;
                if (v98 > 0x7FFFFFFB || v100 <= 3 || v100 > (int)v82)
                {
                  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
                  if (ErrorLogLevelForModule < 3)
                  {
                    v204 = 2;
                    goto LABEL_336;
                  }
                  v242 = VRTraceErrorLogLevelToCSTR();
                  v243 = *MEMORY[0x1E0CF2758];
                  v5 = v350;
                  v4 = v351;
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)lengthAtOffsetOut = 136316674;
                    *(_QWORD *)&lengthAtOffsetOut[4] = v242;
                    v376 = 2080;
                    v377 = "_VCVideoPacketBuffer_ParseCompletedPacket";
                    v378 = 1024;
                    v379 = 2353;
                    v380 = 2048;
                    v381 = v351;
                    v382 = 1024;
                    LODWORD(v383) = v98 + 4;
                    WORD2(v383) = 1024;
                    *(_DWORD *)((char *)&v383 + 6) = v96;
                    WORD5(v383) = 1024;
                    HIDWORD(v383) = v82;
                    _os_log_error_impl(&dword_1D8A54000, v243, OS_LOG_TYPE_ERROR, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] jump=%d i=%d frameBufferLength=%u", lengthAtOffsetOut, 0x38u);
                  }
                  goto LABEL_395;
                }
                cf = 0;
                if (CMBlockBufferGetDataPointer(v83, v96 + 4, &v364, &totalLengthOut, &dataPointerOut))
                {
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                  {
                    VRTraceErrorLogLevelToCSTR();
                    v5 = v350;
                    v4 = v351;
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                      _VCVideoPacketBuffer_AssembleFrame_cold_4();
                    goto LABEL_413;
                  }
                  goto LABEL_411;
                }
                v103 = v364;
                v104 = v99 - 4;
                v105 = v364;
                if (v364 < v99 - 4 && v364 <= 0x18F)
                {
                  if ((int)v98 >= 400)
                    v106 = 400;
                  else
                    v106 = v98;
                  v364 = v106;
                  v107 = CMBlockBufferAccessDataBytes(v349, v96 + 4, v106, buf, &dataPointerOut);
                  if (v107)
                  {
                    v254 = v107;
                    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
                    {
LABEL_411:
                      v5 = v350;
                      goto LABEL_412;
                    }
                    v255 = VRTraceErrorLogLevelToCSTR();
                    v256 = *MEMORY[0x1E0CF2758];
                    v5 = v350;
                    v4 = v351;
                    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                      goto LABEL_413;
                    *(_DWORD *)lengthAtOffsetOut = 136316418;
                    *(_QWORD *)&lengthAtOffsetOut[4] = v255;
                    v376 = 2080;
                    v377 = "_VCVideoPacketBuffer_ParseCompletedPacket";
                    v378 = 1024;
                    v379 = 2363;
                    v380 = 2048;
                    v381 = v351;
                    v382 = 1024;
                    LODWORD(v383) = v254;
                    WORD2(v383) = 2048;
                    *(_QWORD *)((char *)&v383 + 6) = v364;
                    v247 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] CMBlockBufferAccessDataBytes failed with s"
                           "tatus=%d dataPointerLength=%lu";
                    v248 = v256;
LABEL_409:
                    v257 = 54;
                    goto LABEL_410;
                  }
                  v105 = v364;
                }
                FrameSliceHeader = ReadFrameSliceHeader(*(_DWORD *)a2, (uint64_t)dataPointerOut, v105, (CFDictionaryRef *)&cf);
                switch(FrameSliceHeader)
                {
                  case 0:
                  case 6:
                  case 7:
                    goto LABEL_252;
                  case 1:
                    v109 = offsetToData;
                    if (offsetToData >= v96)
                      v109 = v96;
                    v361 = -21846;
                    v360 = -21846;
                    if (RetrieveMBSliceTypeFromFrameInfoDict((CFDictionaryRef)cf, &v361, &v360))
                    {
                      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
                      {
                        v110 = VRTraceErrorLogLevelToCSTR();
                        v111 = *MEMORY[0x1E0CF2758];
                        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                        {
                          *(_DWORD *)lengthAtOffsetOut = 136315906;
                          *(_QWORD *)&lengthAtOffsetOut[4] = v110;
                          v376 = 2080;
                          v377 = "_VCVideoPacketBuffer_ParseCompletedPacket";
                          v378 = 1024;
                          v379 = 2376;
                          v380 = 2048;
                          v381 = v351;
                          _os_log_impl(&dword_1D8A54000, v111, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] FRAMEHEADER_SLICEINFO bad dictHeaderInfo", lengthAtOffsetOut, 0x26u);
                        }
                      }
                    }
                    if (!v96 && v361)
                    {
                      v204 = 14;
LABEL_336:
                      v5 = v350;
LABEL_337:
                      v4 = v351;
                      goto LABEL_414;
                    }
                    if (v339 >= 8)
                    {
                      v4 = v351;
                      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
                      {
                        v205 = VRTraceErrorLogLevelToCSTR();
                        v206 = *MEMORY[0x1E0CF2758];
                        v5 = v350;
                        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                        {
                          *(_DWORD *)lengthAtOffsetOut = 136316162;
                          *(_QWORD *)&lengthAtOffsetOut[4] = v205;
                          v376 = 2080;
                          v377 = "_VCVideoPacketBuffer_ParseCompletedPacket";
                          v378 = 1024;
                          v379 = 2387;
                          v380 = 2048;
                          v381 = v351;
                          v382 = 1024;
                          LODWORD(v383) = v339;
                          _os_log_impl(&dword_1D8A54000, v206, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] *** BAD FRAME -- %d: iSlices >= MAX_SLICES  Stop!", lengthAtOffsetOut, 0x2Cu);
                        }
                        v204 = 15;
                        goto LABEL_414;
                      }
                      v204 = 15;
LABEL_377:
                      v5 = v350;
                      goto LABEL_414;
                    }
                    v337 += v99;
                    offsetToData = v109;
                    v340 = v340 & (v360 == 2);
                    *((_WORD *)__s2 + v339++) = v361;
LABEL_252:
                    if (cf)
                      CFRelease(cf);
                    v96 += v99;
                    v82 = v347;
                    v97 = v100 < (int)v347;
                    v4 = v351;
                    v83 = v349;
                    if (!v97)
                      goto LABEL_257;
                    break;
                  case 2:
                    if (v103 < v104 && (int)VRTraceGetErrorLogLevelForModule() >= 5)
                    {
                      v130 = VRTraceErrorLogLevelToCSTR();
                      v131 = *MEMORY[0x1E0CF2758];
                      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)lengthAtOffsetOut = 136315906;
                        *(_QWORD *)&lengthAtOffsetOut[4] = v130;
                        v376 = 2080;
                        v377 = "_VCVideoPacketBuffer_ParseCompletedPacket";
                        v378 = 1024;
                        v379 = 2424;
                        v380 = 2048;
                        v381 = v351;
                        _os_log_impl(&dword_1D8A54000, v131, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] IMGDESC is in multiple chuncks, copy needed", lengthAtOffsetOut, 0x26u);
                      }
                    }
                    v5 = v350;
                    v132 = CMBlockBufferCreateContiguous(*(CFAllocatorRef *)(v350 + 160), v349, *(CFAllocatorRef *)(v350 + 152), 0, v96 + 4, v98, 0, v335);
                    if (v132)
                    {
                      v311 = v132;
                      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                      {
                        v312 = VRTraceErrorLogLevelToCSTR();
                        v313 = *MEMORY[0x1E0CF2758];
                        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                        {
                          *(_DWORD *)lengthAtOffsetOut = 136316162;
                          *(_QWORD *)&lengthAtOffsetOut[4] = v312;
                          v376 = 2080;
                          v377 = "_VCVideoPacketBuffer_ParseCompletedPacket";
                          v378 = 1024;
                          v379 = 2428;
                          v380 = 2048;
                          v4 = v351;
                          v381 = v351;
                          v382 = 1024;
                          LODWORD(v383) = v311;
                          v247 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Failed to create contiguous IMGDESC "
                                 "buffer. Status:%d";
                          goto LABEL_531;
                        }
                      }
                      goto LABEL_412;
                    }
                    CMBlockBufferGetDataPointer(*v335, 0, v331, 0, v330);
                    v361 = -21846;
                    v360 = -21846;
                    if (RetrieveResolutionFromFrameInfoDict((CFDictionaryRef)cf, &v361, &v360))
                    {
                      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
                      {
                        v133 = VRTraceErrorLogLevelToCSTR();
                        v134 = *MEMORY[0x1E0CF2758];
                        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                        {
                          *(_DWORD *)lengthAtOffsetOut = 136315906;
                          *(_QWORD *)&lengthAtOffsetOut[4] = v133;
                          v376 = 2080;
                          v377 = "_VCVideoPacketBuffer_ParseCompletedPacket";
                          v378 = 1024;
                          v379 = 2435;
                          v380 = 2048;
                          v381 = v351;
                          _os_log_impl(&dword_1D8A54000, v134, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] FRAMEHEADER_IMGDESC bad dictHeaderInfo", lengthAtOffsetOut, 0x26u);
                        }
                      }
                    }
                    v135 = v360;
                    *(_DWORD *)(v350 + 40) = v361;
                    *(_DWORD *)(v350 + 44) = v135;
                    *(_DWORD *)(v350 + 80) = 1;
                    *(_DWORD *)(v350 + 56) = 0;
                    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
                    {
                      v136 = VRTraceErrorLogLevelToCSTR();
                      v137 = *MEMORY[0x1E0CF2758];
                      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                      {
                        v138 = *(_DWORD *)(v350 + 40);
                        v139 = *(_DWORD *)(v350 + 44);
                        v140 = *(_DWORD *)(a2 + 12);
                        v141 = *(unsigned __int8 *)(a2 + 152);
                        v142 = *(unsigned __int8 *)(a2 + 153);
                        *(_DWORD *)lengthAtOffsetOut = 136317186;
                        *(_QWORD *)&lengthAtOffsetOut[4] = v136;
                        v376 = 2080;
                        v377 = "_VCVideoPacketBuffer_ParseCompletedPacket";
                        v378 = 1024;
                        v379 = 2445;
                        v380 = 2048;
                        v381 = v351;
                        v382 = 1024;
                        LODWORD(v383) = v138;
                        WORD2(v383) = 1024;
                        *(_DWORD *)((char *)&v383 + 6) = v139;
                        WORD5(v383) = 1024;
                        HIDWORD(v383) = v140;
                        v384 = 1024;
                        *(_DWORD *)v385 = v141;
                        *(_WORD *)&v385[4] = 1024;
                        *(_DWORD *)&v385[6] = v142;
                        v114 = v137;
                        v115 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] RECEIVED IMGDESC(%dx%d) TS:%08X, isTem"
                               "poralScaledStream=%d, isBaseLayerStream=%d";
                        v116 = 68;
LABEL_251:
                        _os_log_impl(&dword_1D8A54000, v114, OS_LOG_TYPE_DEFAULT, v115, lengthAtOffsetOut, v116);
                      }
                    }
                    goto LABEL_252;
                  case 3:
                    if (v103 < v104 && (int)VRTraceGetErrorLogLevelForModule() >= 5)
                    {
                      v117 = VRTraceErrorLogLevelToCSTR();
                      v118 = *MEMORY[0x1E0CF2758];
                      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)lengthAtOffsetOut = 136315906;
                        *(_QWORD *)&lengthAtOffsetOut[4] = v117;
                        v376 = 2080;
                        v377 = "_VCVideoPacketBuffer_ParseCompletedPacket";
                        v378 = 1024;
                        v379 = 2399;
                        v380 = 2048;
                        v381 = v351;
                        _os_log_impl(&dword_1D8A54000, v118, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] SPS is in multiple chuncks, copy needed", lengthAtOffsetOut, 0x26u);
                      }
                    }
                    v5 = v350;
                    v119 = CMBlockBufferCreateContiguous(*(CFAllocatorRef *)(v350 + 160), v349, *(CFAllocatorRef *)(v350 + 152), 0, v96 + 4, v98, 0, v334);
                    if (v119)
                    {
                      v314 = v119;
                      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                      {
                        v315 = VRTraceErrorLogLevelToCSTR();
                        v313 = *MEMORY[0x1E0CF2758];
                        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                        {
                          *(_DWORD *)lengthAtOffsetOut = 136316162;
                          *(_QWORD *)&lengthAtOffsetOut[4] = v315;
                          v376 = 2080;
                          v377 = "_VCVideoPacketBuffer_ParseCompletedPacket";
                          v378 = 1024;
                          v379 = 2402;
                          v380 = 2048;
                          v4 = v351;
                          v381 = v351;
                          v382 = 1024;
                          LODWORD(v383) = v314;
                          v247 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Failed to create contiguous SPS buffer. Status:%d";
                          goto LABEL_531;
                        }
                      }
                      goto LABEL_412;
                    }
                    CMBlockBufferGetDataPointer(*v334, 0, v329, 0, v328);
                    v361 = -21846;
                    v360 = -21846;
                    v120 = RetrieveResolutionFromFrameInfoDict((CFDictionaryRef)cf, &v361, &v360);
                    if (v120)
                    {
                      v318 = v120;
                      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
                      {
                        v319 = VRTraceErrorLogLevelToCSTR();
                        v320 = *MEMORY[0x1E0CF2758];
                        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                        {
                          *(_DWORD *)lengthAtOffsetOut = 136316162;
                          *(_QWORD *)&lengthAtOffsetOut[4] = v319;
                          v376 = 2080;
                          v377 = "_VCVideoPacketBuffer_ParseCompletedPacket";
                          v378 = 1024;
                          v379 = 2409;
                          v380 = 2048;
                          v381 = v351;
                          v382 = 1024;
                          LODWORD(v383) = v318;
                          _os_log_impl(&dword_1D8A54000, v320, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] FRAMEHEADER_SPSPPS bad dictHeaderInfo. err=%d", lengthAtOffsetOut, 0x2Cu);
                        }
                      }
                      v204 = 3;
                      goto LABEL_337;
                    }
                    v121 = v360;
                    *(_DWORD *)(v350 + 40) = v361;
                    *(_DWORD *)(v350 + 44) = v121;
                    *(_DWORD *)(v350 + 80) = 2;
                    *(_DWORD *)(v350 + 56) = 0;
                    if ((int)VRTraceGetErrorLogLevelForModule() < 7)
                      goto LABEL_252;
                    v122 = VRTraceErrorLogLevelToCSTR();
                    v123 = *MEMORY[0x1E0CF2758];
                    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                      goto LABEL_252;
                    v124 = *(_DWORD *)(a2 + 12);
                    v125 = *(unsigned __int8 *)(a2 + 152);
                    v126 = *(unsigned __int8 *)(a2 + 153);
                    *(_DWORD *)lengthAtOffsetOut = 136316674;
                    *(_QWORD *)&lengthAtOffsetOut[4] = v122;
                    v376 = 2080;
                    v377 = "_VCVideoPacketBuffer_ParseCompletedPacket";
                    v378 = 1024;
                    v379 = 2418;
                    v380 = 2048;
                    v381 = v351;
                    v382 = 1024;
                    LODWORD(v383) = v124;
                    WORD2(v383) = 1024;
                    *(_DWORD *)((char *)&v383 + 6) = v125;
                    WORD5(v383) = 1024;
                    HIDWORD(v383) = v126;
                    v114 = v123;
                    v115 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] RECEIVED SPS/PPS TS: %08X, isTemporalScale"
                           "dStream=%d, isBaseLayerStream=%d";
                    v116 = 56;
                    goto LABEL_251;
                  case 4:
                    if (v103 < v104 && (int)VRTraceGetErrorLogLevelForModule() >= 5)
                    {
                      v127 = VRTraceErrorLogLevelToCSTR();
                      v128 = *MEMORY[0x1E0CF2758];
                      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)lengthAtOffsetOut = 136315906;
                        *(_QWORD *)&lengthAtOffsetOut[4] = v127;
                        v376 = 2080;
                        v377 = "_VCVideoPacketBuffer_ParseCompletedPacket";
                        v378 = 1024;
                        v379 = 2452;
                        v380 = 2048;
                        v381 = v351;
                        _os_log_impl(&dword_1D8A54000, v128, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] SPS is in multiple chuncks, copy needed", lengthAtOffsetOut, 0x26u);
                      }
                    }
                    v5 = v350;
                    v129 = CMBlockBufferCreateContiguous(*(CFAllocatorRef *)(v350 + 160), v349, *(CFAllocatorRef *)(v350 + 152), 0, v96 + 4, v98, 0, v336);
                    if (v129)
                    {
                      v316 = v129;
                      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                      {
                        v317 = VRTraceErrorLogLevelToCSTR();
                        v313 = *MEMORY[0x1E0CF2758];
                        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                        {
                          *(_DWORD *)lengthAtOffsetOut = 136316162;
                          *(_QWORD *)&lengthAtOffsetOut[4] = v317;
                          v376 = 2080;
                          v377 = "_VCVideoPacketBuffer_ParseCompletedPacket";
                          v378 = 1024;
                          v379 = 2455;
                          v380 = 2048;
                          v4 = v351;
                          v381 = v351;
                          v382 = 1024;
                          LODWORD(v383) = v316;
                          v247 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Failed to create contiguous PPS buffer. Status:%d";
LABEL_531:
                          v248 = v313;
                          v257 = 44;
LABEL_410:
                          _os_log_error_impl(&dword_1D8A54000, v248, OS_LOG_TYPE_ERROR, v247, lengthAtOffsetOut, v257);
LABEL_413:
                          v204 = HIDWORD(v352);
LABEL_414:
                          HIDWORD(v352) = v204;
                          v145 = -2145976286;
LABEL_415:
                          if ((int)VRTraceGetErrorLogLevelForModule() < 3
                            || (v258 = VRTraceErrorLogLevelToCSTR(),
                                v259 = *MEMORY[0x1E0CF2758],
                                !os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR)))
                          {
LABEL_417:
                            v33 = 0;
                            goto LABEL_418;
                          }
                          if (HIDWORD(v352))
                            v290 = kVCKeyFrameRequestReasonStrings[HIDWORD(v352)];
                          else
                            v290 = "NONE";
                          *(_DWORD *)buf = 136317442;
                          *(_QWORD *)&buf[4] = v258;
                          *(_WORD *)&buf[12] = 2080;
                          *(_QWORD *)&buf[14] = "_VCVideoPacketBuffer_AssembleFrame";
                          *(_WORD *)&buf[22] = 1024;
                          *(_DWORD *)&buf[24] = 2769;
                          *(_WORD *)&buf[28] = 2048;
                          *(_QWORD *)&buf[30] = v4;
                          *(_WORD *)&buf[38] = 1024;
                          *(_DWORD *)&buf[40] = v145;
                          *(_WORD *)&buf[44] = 1024;
                          *(_DWORD *)&buf[46] = v343;
                          *(_WORD *)&buf[50] = 1024;
                          *(_DWORD *)&buf[52] = v341;
                          *(_WORD *)&buf[56] = 1024;
                          *(_DWORD *)&buf[58] = v344;
                          *(_WORD *)&buf[62] = 1024;
                          *(_DWORD *)&buf[64] = v346;
                          *(_WORD *)&buf[68] = 2080;
                          *(_QWORD *)&buf[70] = v290;
                          v294 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Failed to parse reconstructed packet"
                                 " result=%d videoPacketsExpected=%d, mediaCount=%d parityCount=%d missingMediaPacketsCou"
                                 "nt=%d error.reason=%s";
                          v295 = v259;
                          v296 = 78;
LABEL_503:
                          _os_log_error_impl(&dword_1D8A54000, v295, OS_LOG_TYPE_ERROR, v294, buf, v296);
                          goto LABEL_417;
                        }
                      }
LABEL_412:
                      v4 = v351;
                      goto LABEL_413;
                    }
                    CMBlockBufferGetDataPointer(*v336, 0, v333, 0, v332);
                    goto LABEL_252;
                  default:
                    if ((int)VRTraceGetErrorLogLevelForModule() < 5)
                      goto LABEL_252;
                    v112 = VRTraceErrorLogLevelToCSTR();
                    v113 = *MEMORY[0x1E0CF2758];
                    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                      goto LABEL_252;
                    *(_DWORD *)lengthAtOffsetOut = 136316162;
                    *(_QWORD *)&lengthAtOffsetOut[4] = v112;
                    v376 = 2080;
                    v377 = "_VCVideoPacketBuffer_ParseCompletedPacket";
                    v378 = 1024;
                    v379 = 2465;
                    v380 = 2048;
                    v381 = v351;
                    v382 = 1024;
                    LODWORD(v383) = FrameSliceHeader;
                    v114 = v113;
                    v115 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Unknown InfoType: %d";
                    v116 = 44;
                    goto LABEL_251;
                }
              }
              if ((int)VRTraceGetErrorLogLevelForModule() < 3)
              {
                v5 = v350;
                goto LABEL_413;
              }
              v244 = VRTraceErrorLogLevelToCSTR();
              v245 = *MEMORY[0x1E0CF2758];
              v5 = v350;
              if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                goto LABEL_413;
              v246 = CMBlockBufferGetDataLength(v83);
              *(_DWORD *)lengthAtOffsetOut = 136316418;
              *(_QWORD *)&lengthAtOffsetOut[4] = v244;
              v376 = 2080;
              v377 = "_VCVideoPacketBuffer_ParseCompletedPacket";
              v378 = 1024;
              v379 = 2348;
              v380 = 2048;
              v381 = v4;
              v382 = 2048;
              *(_QWORD *)&v383 = v246;
              WORD4(v383) = 1024;
              *(_DWORD *)((char *)&v383 + 10) = v96;
              v247 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Failed to get length pointer, bufferLength is %zu, i is %d";
              v248 = v245;
              goto LABEL_409;
            }
            v339 = 0;
            v337 = 0;
            offsetToData = -1;
            v340 = 1;
LABEL_257:
            if (*(_BYTE *)(a2 + 152))
              v143 = *(_BYTE *)(a2 + 153) == 0;
            else
              v143 = 0;
            v5 = v350;
            v144 = v340;
            if (!v143 && !*(_DWORD *)(v350 + 80))
            {
              *(_DWORD *)(v350 + 84) = 1;
              v145 = -2145976303;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v146 = VRTraceErrorLogLevelToCSTR();
                v147 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                {
                  v148 = *(_DWORD *)(a2 + 12);
                  v149 = *(unsigned __int8 *)(a2 + 152);
                  v150 = *(unsigned __int8 *)(a2 + 153);
                  *(_DWORD *)lengthAtOffsetOut = 136316674;
                  *(_QWORD *)&lengthAtOffsetOut[4] = v146;
                  v376 = 2080;
                  v377 = "_VCVideoPacketBuffer_ParseCompletedPacket";
                  v378 = 1024;
                  v379 = 2480;
                  v380 = 2048;
                  v381 = v4;
                  v382 = 1024;
                  LODWORD(v383) = v148;
                  WORD2(v383) = 1024;
                  *(_DWORD *)((char *)&v383 + 6) = v149;
                  WORD5(v383) = 1024;
                  HIDWORD(v383) = v150;
                  _os_log_impl(&dword_1D8A54000, v147, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] RECEIVED NO IMGDESC YET TS:%08X, isTemporalScaledStream=%d, isBaseLayerStream=%d", lengthAtOffsetOut, 0x38u);
                }
              }
              v151 = 3;
              goto LABEL_266;
            }
            v152 = *(_DWORD *)(v350 + 56);
            if (v152)
            {
              if (!*(_BYTE *)(v4 + 229))
              {
                if (v152 == v339)
                {
                  v153 = !memcmp((const void *)(v4 + 145948), __s2, 2 * v339) || v143;
                  if ((v153 & 1) == 0)
                    goto LABEL_354;
                }
                else if (!v143)
                {
LABEL_354:
                  *(_DWORD *)(v350 + 80) = 0;
                  *(_DWORD *)(v350 + 84) = 1;
                  *(_DWORD *)(v350 + 76) = 0;
                  v145 = -2145976303;
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
                  {
                    v208 = VRTraceErrorLogLevelToCSTR();
                    v209 = *MEMORY[0x1E0CF2758];
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                    {
                      v210 = *(_DWORD *)(v350 + 56);
                      v211 = *(unsigned __int8 *)(a2 + 152);
                      v212 = *(unsigned __int8 *)(a2 + 153);
                      *(_DWORD *)lengthAtOffsetOut = 136316930;
                      *(_QWORD *)&lengthAtOffsetOut[4] = v208;
                      v376 = 2080;
                      v377 = "_VCVideoPacketBuffer_ParseCompletedPacket";
                      v378 = 1024;
                      v379 = 2495;
                      v380 = 2048;
                      v381 = v4;
                      v382 = 1024;
                      LODWORD(v383) = v210;
                      WORD2(v383) = 1024;
                      *(_DWORD *)((char *)&v383 + 6) = v339;
                      WORD5(v383) = 1024;
                      HIDWORD(v383) = v211;
                      v384 = 1024;
                      *(_DWORD *)v385 = v212;
                      _os_log_impl(&dword_1D8A54000, v209, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] RECEIVED A FRAME WITH NO MATCHING SLICES(%d -> %d), isTemporalScaledStream=%d, isBaseLayerStream=%d", lengthAtOffsetOut, 0x3Eu);
                    }
                  }
                  v151 = 4;
                  goto LABEL_266;
                }
              }
            }
            else
            {
              *(_DWORD *)(v350 + 56) = v339;
              memcpy((void *)(v4 + 145948), __s2, 2 * v339);
            }
            if ((*(_BYTE *)(a2 + 32) & 2) != 0)
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v154 = VRTraceErrorLogLevelToCSTR();
                v155 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                {
                  v156 = **(unsigned __int16 **)(a2 + 96);
                  v157 = *(_DWORD *)(a2 + 12);
                  v158 = *(_DWORD *)(a2 + 32);
                  v159 = *(unsigned __int8 *)(a2 + 152);
                  v160 = *(unsigned __int8 *)(a2 + 153);
                  *(_DWORD *)lengthAtOffsetOut = 136317442;
                  *(_QWORD *)&lengthAtOffsetOut[4] = v154;
                  v376 = 2080;
                  v377 = "_VCVideoPacketBuffer_ParseCompletedPacket";
                  v378 = 1024;
                  v379 = 2501;
                  v380 = 2048;
                  v381 = v4;
                  v382 = 1024;
                  LODWORD(v383) = v156;
                  WORD2(v383) = 1024;
                  *(_DWORD *)((char *)&v383 + 6) = v157;
                  WORD5(v383) = 1024;
                  HIDWORD(v383) = v158;
                  v384 = 1024;
                  *(_DWORD *)v385 = v339;
                  *(_WORD *)&v385[4] = 1024;
                  *(_DWORD *)&v385[6] = v159;
                  *(_WORD *)v386 = 1024;
                  *(_DWORD *)&v386[2] = v160;
                  _os_log_impl(&dword_1D8A54000, v155, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] RECEIVED REFRESH FRAME seq:%d TS:%08X BITS:%04X SLICES:%d, isTemporalScaledStream=%d, isBaseLayerStream=%d", lengthAtOffsetOut, 0x4Au);
                }
              }
              *(_BYTE *)(a2 + 53) = 1;
            }
            if (v340)
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v161 = VRTraceErrorLogLevelToCSTR();
                v162 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                {
                  v163 = *(_DWORD *)(a2 + 12);
                  v164 = *(_DWORD *)(a2 + 32);
                  v165 = *(unsigned __int8 *)(a2 + 152);
                  v166 = *(unsigned __int8 *)(a2 + 153);
                  *(_DWORD *)lengthAtOffsetOut = 136317186;
                  *(_QWORD *)&lengthAtOffsetOut[4] = v161;
                  v376 = 2080;
                  v377 = "_VCVideoPacketBuffer_ParseCompletedPacket";
                  v378 = 1024;
                  v379 = 2507;
                  v380 = 2048;
                  v381 = v4;
                  v382 = 1024;
                  LODWORD(v383) = v163;
                  WORD2(v383) = 1024;
                  *(_DWORD *)((char *)&v383 + 6) = v164;
                  WORD5(v383) = 1024;
                  HIDWORD(v383) = v339;
                  v384 = 1024;
                  *(_DWORD *)v385 = v165;
                  *(_WORD *)&v385[4] = 1024;
                  *(_DWORD *)&v385[6] = v166;
                  _os_log_impl(&dword_1D8A54000, v162, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] RECEIVED INTRA FRAME TS:%08X BITS:%04X SLICES:%d, isTemporalScaledStream=%d, isBaseLayerStream=%d", lengthAtOffsetOut, 0x44u);
                }
              }
              *(_BYTE *)(a2 + 52) = 1;
            }
            if (!*(_DWORD *)(v350 + 84))
            {
              if (!v348 || *(_DWORD *)(a2 + 32) & 2 | v340 || *(_BYTE *)(a2 + 152))
              {
LABEL_321:
                v189 = *(double *)(a2 + 168);
                if (v189 != 0.0)
                {
                  HIDWORD(v190) = 1083129856;
                  v191 = (*(double *)(a2 + 24) - v189) * 1000.0;
                  if (v191 > 0.0)
                  {
                    v192 = 0;
                    do
                    {
                      if (v192 == 92)
                        goto LABEL_327;
                      LODWORD(v190) = *(_DWORD *)((char *)&LateFrameDelayHistBucketRanges + v192 + 4);
                      v190 = (double)*(unint64_t *)&v190;
                      v192 += 4;
                    }
                    while (v191 >= v190);
                    ++*(_DWORD *)(v4 + v192 + 912);
LABEL_327:
                    v193 = v191 + *(double *)(v4 + 1008);
                    *(double *)(v4 + 1008) = v193;
                    if (*(double *)(v4 + 1024) > v191)
                      v191 = *(double *)(v4 + 1024);
                    *(double *)(v4 + 1024) = v191;
                    v194 = *(_DWORD *)(v4 + 1040) + 1;
                    *(_DWORD *)(v4 + 1040) = v194;
                    *(double *)(v4 + 1016) = v193 / (double)v194;
                    v195 = *(_DWORD *)(v4 + 1036);
                    if (v195)
                      *(double *)(v4 + 1048) = (double)(v194 / v195);
                  }
                }
                if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
                {
                  v196 = VRTraceErrorLogLevelToCSTR();
                  v197 = *MEMORY[0x1E0CF2758];
                  v198 = *MEMORY[0x1E0CF2758];
                  if (*MEMORY[0x1E0CF2748])
                  {
                    if (os_log_type_enabled(v198, OS_LOG_TYPE_DEFAULT))
                    {
                      v199 = *(_DWORD *)(a2 + 12);
                      v200 = *(_DWORD *)(v4 + 1036);
                      v201 = *(_DWORD *)(v4 + 1040);
                      v202 = *(_QWORD *)(v4 + 1048);
                      v203 = *(_QWORD *)(v4 + 1016);
                      *(_DWORD *)lengthAtOffsetOut = 136317186;
                      *(_QWORD *)&lengthAtOffsetOut[4] = v196;
                      v376 = 2080;
                      v377 = "_VideoPacketBuffer_ConfirmFrameAssembledAndCalculateStats";
                      v378 = 1024;
                      v379 = 1359;
                      v380 = 2048;
                      v381 = v4;
                      v382 = 1024;
                      LODWORD(v383) = v199;
                      WORD2(v383) = 1024;
                      *(_DWORD *)((char *)&v383 + 6) = v200;
                      WORD5(v383) = 1024;
                      HIDWORD(v383) = v201;
                      v384 = 2048;
                      *(_QWORD *)v385 = v202;
                      *(_WORD *)&v385[8] = 2048;
                      *(_QWORD *)v386 = v203;
                      _os_log_impl(&dword_1D8A54000, v197, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] FrameTimestamp=%d, evictedFramesTrackedCount=%d, evictedFramesRecoveredCount=%d, percOfEvictedFramesRecovered=%f, averageLatePacketDelayForEvictedFrames=%f,", lengthAtOffsetOut, 0x4Cu);
                    }
                  }
                  else if (os_log_type_enabled(v198, OS_LOG_TYPE_DEBUG))
                  {
                    v297 = *(_DWORD *)(a2 + 12);
                    v298 = *(_DWORD *)(v4 + 1036);
                    v299 = *(_DWORD *)(v4 + 1040);
                    v300 = *(_QWORD *)(v4 + 1048);
                    v301 = *(_QWORD *)(v4 + 1016);
                    *(_DWORD *)lengthAtOffsetOut = 136317186;
                    *(_QWORD *)&lengthAtOffsetOut[4] = v196;
                    v376 = 2080;
                    v377 = "_VideoPacketBuffer_ConfirmFrameAssembledAndCalculateStats";
                    v378 = 1024;
                    v379 = 1359;
                    v380 = 2048;
                    v381 = v4;
                    v382 = 1024;
                    LODWORD(v383) = v297;
                    WORD2(v383) = 1024;
                    *(_DWORD *)((char *)&v383 + 6) = v298;
                    WORD5(v383) = 1024;
                    HIDWORD(v383) = v299;
                    v384 = 2048;
                    *(_QWORD *)v385 = v300;
                    *(_WORD *)&v385[8] = 2048;
                    *(_QWORD *)v386 = v301;
                    _os_log_debug_impl(&dword_1D8A54000, v197, OS_LOG_TYPE_DEBUG, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] FrameTimestamp=%d, evictedFramesTrackedCount=%d, evictedFramesRecoveredCount=%d, percOfEvictedFramesRecovered=%f, averageLatePacketDelayForEvictedFrames=%f,", lengthAtOffsetOut, 0x4Cu);
                  }
                }
                *(_WORD *)(v4 + 422) = *(_WORD *)(v4 + 420);
                if (!*(_BYTE *)(a2 + 55))
                  kdebug_trace();
                if (v144 && !*(_DWORD *)(a2 + 8)
                  || (v207 = *(_DWORD *)a2 - 110, v207 <= 0xF) && ((1 << v207) & 0xC001) != 0)
                {
                  *(_DWORD *)(v350 + 76) = 1;
                  ++*v342;
                }
                if (v337)
                {
                  *((_DWORD *)v327 + 56) = offsetToData;
                  CMBlockBufferCreateWithBufferReference(*(CFAllocatorRef *)(v350 + 160), v83, offsetToData, v337, 0, v327 + 15);
                }
                goto LABEL_159;
              }
              v145 = -2145976286;
              goto LABEL_403;
            }
            if (!*(_BYTE *)(a2 + 55))
            {
              if (*(_DWORD *)(a2 + 32) & 2 | v340)
              {
                if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
                {
                  v183 = VRTraceErrorLogLevelToCSTR();
                  v184 = *MEMORY[0x1E0CF2758];
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                  {
                    v185 = *(unsigned __int16 *)(a2 + 122);
                    v186 = *(unsigned __int16 *)(a2 + 150);
                    v187 = *(unsigned __int8 *)(a2 + 152);
                    v188 = *(unsigned __int8 *)(a2 + 153);
                    *(_DWORD *)lengthAtOffsetOut = 136316930;
                    *(_QWORD *)&lengthAtOffsetOut[4] = v183;
                    v376 = 2080;
                    v377 = "_VCVideoPacketBuffer_ParseCompletedPacket";
                    v378 = 1024;
                    v379 = 2546;
                    v380 = 2048;
                    v381 = v4;
                    v382 = 1024;
                    LODWORD(v383) = v185;
                    WORD2(v383) = 1024;
                    *(_DWORD *)((char *)&v383 + 6) = v186;
                    WORD5(v383) = 1024;
                    HIDWORD(v383) = v187;
                    v384 = 1024;
                    *(_DWORD *)v385 = v188;
                    _os_log_impl(&dword_1D8A54000, v184, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Received refresh frame for streamID=%d, frameSeqNumber=%d, isTemporalScalingStream=%d, isBaseLayerStream=%d", lengthAtOffsetOut, 0x3Eu);
                  }
                }
                _VideoPacketBuffer_ClearFrameList(v4, (uint64_t *)(v4 + 145904));
                *(_QWORD *)(v350 + 24) = 0;
                *(_DWORD *)(v350 + 124) = 0;
                *(_DWORD *)(v350 + 84) = 0;
                *(_BYTE *)(v350 + 88) = 0;
                *(_BYTE *)(v350 + 184) = 0;
                goto LABEL_321;
              }
              v145 = -2145976286;
              v151 = 5;
LABEL_266:
              HIDWORD(v352) = v151;
              goto LABEL_415;
            }
            if (v348 && !(*(_DWORD *)(a2 + 32) & 2 | v340))
            {
              v145 = -2145976286;
              if ((int)VRTraceGetErrorLogLevelForModule() < 8)
                goto LABEL_403;
              v221 = VRTraceErrorLogLevelToCSTR();
              v222 = *MEMORY[0x1E0CF2758];
              v223 = *MEMORY[0x1E0CF2758];
              if (*MEMORY[0x1E0CF2748])
              {
                if (os_log_type_enabled(v223, OS_LOG_TYPE_DEFAULT))
                {
                  v224 = *(_DWORD *)(a2 + 12);
                  v225 = *(unsigned __int16 *)(a2 + 150);
                  *(_DWORD *)lengthAtOffsetOut = 136316418;
                  *(_QWORD *)&lengthAtOffsetOut[4] = v221;
                  v376 = 2080;
                  v377 = "_VCVideoPacketBuffer_ParseCompletedPacket";
                  v378 = 1024;
                  v379 = 2515;
                  v380 = 2048;
                  v381 = v4;
                  v382 = 1024;
                  LODWORD(v383) = v224;
                  WORD2(v383) = 1024;
                  *(_DWORD *)((char *)&v383 + 6) = v225;
                  v226 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Late frame was discarded in parse stage time"
                         "stamp=%u frameSequenceNumber=%u";
                  v227 = v222;
                  v228 = 50;
LABEL_382:
                  _os_log_impl(&dword_1D8A54000, v227, OS_LOG_TYPE_DEFAULT, v226, lengthAtOffsetOut, v228);
                }
LABEL_403:
                v151 = 6;
                goto LABEL_266;
              }
              if (!os_log_type_enabled(v223, OS_LOG_TYPE_DEBUG))
                goto LABEL_403;
              v249 = *(_DWORD *)(a2 + 12);
              v250 = *(unsigned __int16 *)(a2 + 150);
              *(_DWORD *)lengthAtOffsetOut = 136316418;
              *(_QWORD *)&lengthAtOffsetOut[4] = v221;
              v376 = 2080;
              v377 = "_VCVideoPacketBuffer_ParseCompletedPacket";
              v378 = 1024;
              v379 = 2515;
              v380 = 2048;
              v381 = v4;
              v382 = 1024;
              LODWORD(v383) = v249;
              WORD2(v383) = 1024;
              *(_DWORD *)((char *)&v383 + 6) = v250;
              v251 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Late frame was discarded in parse stage timestam"
                     "p=%u frameSequenceNumber=%u";
              v252 = v222;
              v253 = 50;
            }
            else
            {
              if (v340 || (*(_BYTE *)(a2 + 32) & 2) != 0)
              {
                v167 = 1;
              }
              else
              {
                if (*(_BYTE *)(v350 + 88))
                {
                  v145 = -2145976286;
                  v151 = 17;
                  goto LABEL_266;
                }
                v167 = 0;
              }
              if (!*(_BYTE *)(a2 + 152) || !*(_BYTE *)(v350 + 184))
              {
LABEL_306:
                if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
                {
                  v175 = VRTraceErrorLogLevelToCSTR();
                  v176 = *MEMORY[0x1E0CF2758];
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                  {
                    v177 = *(_DWORD *)(a2 + 12);
                    v178 = *(unsigned __int16 *)(a2 + 150);
                    v179 = *(unsigned __int8 *)(a2 + 57);
                    *(_DWORD *)lengthAtOffsetOut = 136316930;
                    *(_QWORD *)&lengthAtOffsetOut[4] = v175;
                    v376 = 2080;
                    v377 = "_VCVideoPacketBuffer_ParseCompletedPacket";
                    v378 = 1024;
                    v379 = 2530;
                    v380 = 2048;
                    v381 = v4;
                    v382 = 1024;
                    LODWORD(v383) = v177;
                    WORD2(v383) = 1024;
                    *(_DWORD *)((char *)&v383 + 6) = v178;
                    WORD5(v383) = 1024;
                    HIDWORD(v383) = v167;
                    v384 = 1024;
                    *(_DWORD *)v385 = v179;
                    _os_log_impl(&dword_1D8A54000, v176, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Successfully assembled previously incomplete late frame timestamp=%u frameSequenceNumber=%u isRefreshFrame=%d hasRetransmittedPackets=%d", lengthAtOffsetOut, 0x3Eu);
                  }
                }
                v144 = v340;
                if (*(_BYTE *)(a2 + 57) && *(_BYTE *)(v4 + 242))
                {
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
                  {
                    v180 = VRTraceErrorLogLevelToCSTR();
                    v181 = *MEMORY[0x1E0CF2758];
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                    {
                      v182 = *(unsigned __int16 *)(a2 + 150);
                      *(_DWORD *)lengthAtOffsetOut = 136316162;
                      *(_QWORD *)&lengthAtOffsetOut[4] = v180;
                      v376 = 2080;
                      v377 = "_VCVideoPacketBuffer_ParseCompletedPacket";
                      v378 = 1024;
                      v379 = 2534;
                      v380 = 2048;
                      v381 = v4;
                      v382 = 1024;
                      LODWORD(v383) = v182;
                      _os_log_impl(&dword_1D8A54000, v181, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] late frame assembled with retransmitted packets frameSequenceNumber=%d", lengthAtOffsetOut, 0x2Cu);
                    }
                  }
                  ++*(_DWORD *)(v4 + 1056);
                }
                *(_BYTE *)(v350 + 32) = 1;
                *(_DWORD *)(v350 + 84) = 0;
                *(_BYTE *)(v350 + 88) = 0;
                kdebug_trace();
                goto LABEL_321;
              }
              v168 = *(_DWORD *)(v350 + 188) != *(unsigned __int16 *)(a2 + 150);
              v169 = VRTraceGetErrorLogLevelForModule();
              if ((v168 & ~v167 & 1) == 0)
              {
                if (v169 >= 7)
                {
                  v170 = VRTraceErrorLogLevelToCSTR();
                  v171 = *MEMORY[0x1E0CF2758];
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                  {
                    v172 = *(unsigned __int8 *)(a2 + 153);
                    v173 = *(_DWORD *)(a2 + 12);
                    v174 = *(unsigned __int16 *)(a2 + 150);
                    *(_DWORD *)lengthAtOffsetOut = 136316930;
                    *(_QWORD *)&lengthAtOffsetOut[4] = v170;
                    v376 = 2080;
                    v377 = "_VideoReceiver_HandlePrecedingLossOnBaseLayerOfTemporalStream";
                    v378 = 1024;
                    v379 = 2317;
                    v380 = 2048;
                    v381 = v4;
                    v382 = 1024;
                    LODWORD(v383) = v167;
                    WORD2(v383) = 1024;
                    *(_DWORD *)((char *)&v383 + 6) = v172;
                    WORD5(v383) = 1024;
                    HIDWORD(v383) = v173;
                    v384 = 1024;
                    *(_DWORD *)v385 = v174;
                    _os_log_impl(&dword_1D8A54000, v171, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Exiting base layer preceding loss state. isRefreshFrame=%d isBaseLayerStream=%d timestamp=%u frameSequenceNumber=%u", lengthAtOffsetOut, 0x3Eu);
                  }
                }
                *(_BYTE *)(v350 + 184) = 0;
                goto LABEL_306;
              }
              v145 = -2145976286;
              if (v169 < 8)
                goto LABEL_403;
              v230 = VRTraceErrorLogLevelToCSTR();
              v231 = *MEMORY[0x1E0CF2758];
              v232 = *MEMORY[0x1E0CF2758];
              if (*MEMORY[0x1E0CF2748])
              {
                if (os_log_type_enabled(v232, OS_LOG_TYPE_DEFAULT))
                {
                  v233 = *(unsigned __int8 *)(a2 + 153);
                  v234 = *(_DWORD *)(a2 + 12);
                  v235 = *(unsigned __int16 *)(a2 + 150);
                  *(_DWORD *)lengthAtOffsetOut = 136316930;
                  *(_QWORD *)&lengthAtOffsetOut[4] = v230;
                  v376 = 2080;
                  v377 = "_VideoReceiver_HandlePrecedingLossOnBaseLayerOfTemporalStream";
                  v378 = 1024;
                  v379 = 2320;
                  v380 = 2048;
                  v381 = v4;
                  v382 = 1024;
                  LODWORD(v383) = 0;
                  WORD2(v383) = 1024;
                  *(_DWORD *)((char *)&v383 + 6) = v233;
                  WORD5(v383) = 1024;
                  HIDWORD(v383) = v234;
                  v384 = 1024;
                  *(_DWORD *)v385 = v235;
                  v226 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] VPB is still in preceding loss state, droppi"
                         "ng this frame. isRefreshFrame=%d isBaseLayerStream=%d timestamp=%u frameSequenceNumber=%u";
                  v227 = v231;
                  v228 = 62;
                  goto LABEL_382;
                }
                goto LABEL_403;
              }
              if (!os_log_type_enabled(v232, OS_LOG_TYPE_DEBUG))
                goto LABEL_403;
              v324 = *(unsigned __int8 *)(a2 + 153);
              v325 = *(_DWORD *)(a2 + 12);
              v326 = *(unsigned __int16 *)(a2 + 150);
              *(_DWORD *)lengthAtOffsetOut = 136316930;
              *(_QWORD *)&lengthAtOffsetOut[4] = v230;
              v376 = 2080;
              v377 = "_VideoReceiver_HandlePrecedingLossOnBaseLayerOfTemporalStream";
              v378 = 1024;
              v379 = 2320;
              v380 = 2048;
              v381 = v4;
              v382 = 1024;
              LODWORD(v383) = 0;
              WORD2(v383) = 1024;
              *(_DWORD *)((char *)&v383 + 6) = v324;
              WORD5(v383) = 1024;
              HIDWORD(v383) = v325;
              v384 = 1024;
              *(_DWORD *)v385 = v326;
              v251 = "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] VPB is still in preceding loss state, dropping t"
                     "his frame. isRefreshFrame=%d isBaseLayerStream=%d timestamp=%u frameSequenceNumber=%u";
              v252 = v231;
              v253 = 62;
            }
            _os_log_debug_impl(&dword_1D8A54000, v252, OS_LOG_TYPE_DEBUG, v251, lengthAtOffsetOut, v253);
            goto LABEL_403;
          }
          v80 = v79(*(_QWORD *)(v4 + 248), blockBufferOut, &theBuffer);
          if (v80)
          {
            v321 = v80;
            if ((int)VRTraceGetErrorLogLevelForModule() < 3)
              goto LABEL_541;
            v322 = VRTraceErrorLogLevelToCSTR();
            v323 = *MEMORY[0x1E0CF2758];
            if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              goto LABEL_541;
            *(_DWORD *)buf = 136316162;
            *(_QWORD *)&buf[4] = v322;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VCVideoPacketBuffer_AssembleFrame";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 2761;
            *(_WORD *)&buf[28] = 2048;
            v4 = v351;
            *(_QWORD *)&buf[30] = v351;
            *(_WORD *)&buf[38] = 1024;
            *(_DWORD *)&buf[40] = v321;
            _os_log_error_impl(&dword_1D8A54000, v323, OS_LOG_TYPE_ERROR, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Failed to decrypt the frame with frameDecryptionCallback result=%d", buf, 0x2Cu);
          }
          else
          {
            v81 = CMBlockBufferGetDataLength(theBuffer);
            if (v81)
            {
              v82 = v81;
              v83 = theBuffer;
              goto LABEL_187;
            }
            if ((int)VRTraceGetErrorLogLevelForModule() < 3
              || (VRTraceErrorLogLevelToCSTR(), !os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR)))
            {
LABEL_541:
              v33 = 0;
              v5 = v350;
              v4 = v351;
              goto LABEL_418;
            }
            v4 = v351;
            _VCVideoPacketBuffer_AssembleFrame_cold_5();
          }
          v33 = 0;
LABEL_366:
          v5 = v350;
          goto LABEL_418;
        }
        *(_WORD *)lengthAtOffsetOut = 0;
        if (_VideoPacketBuffer_IsFrameComplete(a2, lengthAtOffsetOut))
        {
          if (*(_BYTE *)(a2 + 152) && *(_BYTE *)(a2 + 153))
            *(_WORD *)(v350 + 192) = *(_WORD *)lengthAtOffsetOut;
          goto LABEL_119;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v309 = VRTraceErrorLogLevelToCSTR();
          v310 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136316674;
            *(_QWORD *)&buf[4] = v309;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VCVideoPacketBuffer_AssembleFrame";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 2733;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = v343;
            *(_WORD *)&buf[34] = 1024;
            *(_DWORD *)&buf[36] = v341;
            *(_WORD *)&buf[40] = 1024;
            *(_DWORD *)&buf[42] = v344;
            *(_WORD *)&buf[46] = 1024;
            *(_DWORD *)&buf[48] = v346;
            _os_log_error_impl(&dword_1D8A54000, v310, OS_LOG_TYPE_ERROR, "VideoPacketBuffer [%s] %s:%d Frame assembly failed because of lost packets videoPacketsExpected=%d mediaCount=%d parityCount=%d missingMediaPacketsCount=%d", buf, 0x34u);
          }
        }
        v33 = 0;
        v304 = 10;
LABEL_521:
        HIDWORD(v352) = v304;
        LOBYTE(v352) = 1;
        goto LABEL_418;
      }
      v5 = v350;
LABEL_508:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v302 = VRTraceErrorLogLevelToCSTR();
        v303 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136316674;
          *(_QWORD *)&buf[4] = v302;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VCVideoPacketBuffer_AssembleFrame";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 2727;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = v343;
          *(_WORD *)&buf[34] = 1024;
          *(_DWORD *)&buf[36] = v341;
          *(_WORD *)&buf[40] = 1024;
          *(_DWORD *)&buf[42] = v344;
          *(_WORD *)&buf[46] = 1024;
          *(_DWORD *)&buf[48] = v346;
          _os_log_error_impl(&dword_1D8A54000, v303, OS_LOG_TYPE_ERROR, "VideoPacketBuffer [%s] %s:%d Frame assembly failed because of no end of frame videoPacketsExpected=%d mediaCount=%d parityCount=%d missingMediaPacketsCount=%d", buf, 0x34u);
        }
      }
      v33 = 0;
      v304 = 12;
      goto LABEL_521;
    }
  }
  LOBYTE(v364) = 0;
  LOBYTE(totalLengthOut) = 0;
  LOWORD(dataPointerOut) = 0;
  LOBYTE(cf) = 0;
  __s2[0] = 0;
  v23 = (const void *)*((_QWORD *)v19 + 15);
  if (!v23)
  {
    v5 = v350;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      HIDWORD(v352) = 16;
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        goto LABEL_140;
      _VCVideoPacketBuffer_AssembleFrame_cold_2();
    }
    v65 = 16;
LABEL_139:
    HIDWORD(v352) = v65;
LABEL_140:
    if (__s2[0])
      CFRelease(__s2[0]);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCVideoPacketBuffer_AssembleFrame_cold_1();
    }
    goto LABEL_417;
  }
  v24 = *(_DWORD *)a2 - 100;
  v97 = v24 > 0x19;
  v25 = (1 << v24) & 0x3800401;
  v26 = v97 || v25 == 0;
  v5 = v350;
  if (v26)
  {
    v33 = (OpaqueCMBlockBuffer *)CFRetain(v23);
    goto LABEL_79;
  }
  Empty = CMBlockBufferCreateEmpty(*(CFAllocatorRef *)(v350 + 160), 0, 0, __s2);
  if (Empty)
  {
    v218 = Empty;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v219 = VRTraceErrorLogLevelToCSTR();
      v220 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)lengthAtOffsetOut = 136316162;
        *(_QWORD *)&lengthAtOffsetOut[4] = v219;
        v376 = 2080;
        v377 = "_VCVideoPacketBuffer_ProcessRTPPackets";
        v378 = 1024;
        v379 = 2173;
        v380 = 2048;
        v381 = v4;
        v382 = 1024;
        LODWORD(v383) = v218;
        _os_log_error_impl(&dword_1D8A54000, v220, OS_LOG_TYPE_ERROR, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Failed to create block buffer for packet. Status:%d", lengthAtOffsetOut, 0x2Cu);
      }
    }
    v65 = 7;
    goto LABEL_139;
  }
  *(_QWORD *)buf = &v364;
  *(_QWORD *)&buf[8] = &totalLengthOut;
  *(_QWORD *)&buf[16] = &dataPointerOut;
  v28 = *(const __CFAllocator **)(v350 + 160);
  v29 = *(const __CFAllocator **)(v350 + 176);
  *(_QWORD *)&buf[24] = &cf;
  *(_QWORD *)&buf[32] = v28;
  *(_QWORD *)&buf[40] = v29;
  *(CMBlockBufferRef *)&buf[48] = __s2[0];
  v30 = *(_DWORD *)a2;
  if ((*(_DWORD *)a2 - 124) >= 2)
  {
    if (v30 == 110)
    {
      v31 = RTPUnpackGenericDataPacket((uint64_t)(v19 + 60), (uint64_t)buf);
    }
    else if (v30 == 100)
    {
      v31 = RTPProcessHEVCPacket(100, &v364, (BOOL *)&totalLengthOut, &dataPointerOut, &cf, *(unsigned __int8 *)(v4 + 240), v28, v29, (uint64_t)(v19 + 60), __s2[0]);
    }
    else
    {
      v31 = RTPProcessH264Packet((uint64_t)(v19 + 60), (uint64_t)buf);
    }
    if ((v31 & 0x80000000) == 0)
      goto LABEL_60;
    v62 = 0;
    goto LABEL_135;
  }
  LOBYTE(v364) = 1;
  LOBYTE(totalLengthOut) = 1;
  appended = CMBlockBufferAppendBufferReference(__s2[0], *((CMBlockBufferRef *)v19 + 15), 0, 0, 0);
  if (appended)
  {
    v62 = appended;
LABEL_135:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v63 = VRTraceErrorLogLevelToCSTR();
      v64 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)lengthAtOffsetOut = 136316162;
        *(_QWORD *)&lengthAtOffsetOut[4] = v63;
        v376 = 2080;
        v377 = "_VCVideoPacketBuffer_ProcessRTPPackets";
        v378 = 1024;
        v379 = 2201;
        v380 = 2048;
        v381 = v4;
        v382 = 1024;
        LODWORD(v383) = v62;
        _os_log_error_impl(&dword_1D8A54000, v64, OS_LOG_TYPE_ERROR, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Failed to create block buffer for packet. Status:%d", lengthAtOffsetOut, 0x2Cu);
      }
    }
    v65 = 8;
    goto LABEL_139;
  }
LABEL_60:
  v34 = v364;
  v35 = totalLengthOut;
  *((_DWORD *)v19 + 2) = v364;
  *((_DWORD *)v19 + 3) = v35;
  if (*(_BYTE *)(v4 + 240) && (_BYTE)cf)
  {
    v36 = (unsigned __int16)dataPointerOut;
    if (*(_BYTE *)(a2 + 148))
    {
      if (*(unsigned __int16 *)(a2 + 146) != (unsigned __int16)dataPointerOut)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v37 = VRTraceErrorLogLevelToCSTR();
          v38 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            v53 = *(unsigned __int16 *)(a2 + 146);
            *(_DWORD *)lengthAtOffsetOut = 136316418;
            *(_QWORD *)&lengthAtOffsetOut[4] = v37;
            v376 = 2080;
            v377 = "_VideoPacketBuffer_UpdateFrameDecodingOrder";
            v378 = 1024;
            v379 = 1235;
            v380 = 2048;
            v381 = v4;
            v382 = 1024;
            LODWORD(v383) = v53;
            WORD2(v383) = 1024;
            *(_DWORD *)((char *)&v383 + 6) = v36;
            _os_log_error_impl(&dword_1D8A54000, v38, OS_LOG_TYPE_ERROR, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Decoding order is different within a frame. Previous:%d New:%d", lengthAtOffsetOut, 0x32u);
          }
        }
        *(_WORD *)(a2 + 146) = v36;
        v34 = v364;
        v5 = v350;
      }
    }
    else
    {
      *(_WORD *)(a2 + 146) = (_WORD)dataPointerOut;
      *(_BYTE *)(a2 + 148) = 1;
    }
  }
  v39 = *(unsigned __int16 **)(a2 + 96) == v19 && v34 == 0;
  v40 = v352;
  if (v39)
    v40 = 1;
  LODWORD(v352) = v40;
  v41 = HIDWORD(v352);
  if (v39)
    v41 = 9;
  HIDWORD(v352) = v41;
  v33 = __s2[0];
LABEL_79:
  v42 = CMBlockBufferGetDataLength(v33);
  if (*(_BYTE *)(a2 + 152))
    goto LABEL_94;
  v43 = *v19 + ~*(_WORD *)(v4 + 420);
  if ((__int16)v43 < 1)
  {
    v48 = 0;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v44 = VRTraceErrorLogLevelToCSTR();
      v45 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v46 = *v19;
        v47 = *(unsigned __int16 *)(v351 + 420);
        *(_DWORD *)buf = 136316674;
        *(_QWORD *)&buf[4] = v44;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VCVideoPacketBuffer_DetectMissingPackets";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 2228;
        *(_WORD *)&buf[28] = 2048;
        *(_QWORD *)&buf[30] = v351;
        *(_WORD *)&buf[38] = 1024;
        *(_DWORD *)&buf[40] = v46;
        *(_WORD *)&buf[44] = 1024;
        *(_DWORD *)&buf[46] = v47;
        *(_WORD *)&buf[50] = 1024;
        *(_DWORD *)&buf[52] = v43;
        _os_log_impl(&dword_1D8A54000, v45, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] PacketSeq:%d LastSeq:%d missingCount:%d", buf, 0x38u);
      }
    }
    if ((v21 & 1) != 0)
    {
      v48 = 0;
      v348 = 1;
    }
    else
    {
      v352 = 0xA00000001;
      v48 = 1;
    }
    v5 = v350;
    v4 = v351;
  }
  v49 = *v19;
  v50 = v49 - *(unsigned __int16 *)(v4 + 420);
  if (v50 && (unsigned __int16)v50 <= 0x7FFEu)
    *(_WORD *)(v4 + 420) = v49;
  if (!v48)
  {
LABEL_94:
    if (*(_DWORD *)a2 == 123 || *(_DWORD *)a2 == 100)
    {
      if (v355 && *((_DWORD *)v19 + 2))
        _VCVideoPacketBuffer_FinalizeGOBLengthAdjustement((uint64_t)&v355);
      if (*((_DWORD *)v19 + 2) && !*((_DWORD *)v19 + 3))
      {
        v355 = CFRetain(v33);
        v356 = 0;
        v357 = v42;
        *(_QWORD *)buf = 0;
        *(_QWORD *)lengthAtOffsetOut = 0;
        __s2[0] = 0;
        CMBlockBufferGetDataPointer(v33, 4uLL, (size_t *)lengthAtOffsetOut, (size_t *)__s2, (char **)buf);
        if (*(_QWORD *)lengthAtOffsetOut >= 4uLL && **(_DWORD **)buf == -1547639150)
        {
          CMBlockBufferGetDataPointer(v33, 0, (size_t *)lengthAtOffsetOut, 0, (char **)buf);
          v356 = bswap32(**(_DWORD **)buf) + 4;
          v357 = v42 - v356;
          if (v42 == v356)
          {
            v356 = 0;
            v357 = v42;
          }
        }
      }
      else if (v355)
      {
        v357 += v42;
      }
    }
    v51 = CMBlockBufferGetDataLength(blockBufferOut);
    v52 = CMBlockBufferAppendBufferReference(blockBufferOut, v33, 0, v42, 0);
    if (v51 + v42 == CMBlockBufferGetDataLength(blockBufferOut))
    {
      v4 = v351;
      if (!v52)
      {
        v353 += v42;
        v20 = *((_DWORD *)v19 + 4) != 0;
        if (v33)
          CFRelease(v33);
        v21 = 0;
        goto LABEL_107;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v216 = VRTraceErrorLogLevelToCSTR();
        v214 = *MEMORY[0x1E0CF2758];
        v5 = v350;
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          goto LABEL_363;
        v308 = CMBlockBufferGetDataLength(blockBufferOut);
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)&buf[4] = v216;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VCVideoPacketBuffer_AssembleFrame";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 2717;
        *(_WORD *)&buf[28] = 2048;
        *(_QWORD *)&buf[30] = v351;
        *(_WORD *)&buf[38] = 2048;
        *(_QWORD *)&buf[40] = v308;
        goto LABEL_516;
      }
    }
    else
    {
      v4 = v351;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v213 = VRTraceErrorLogLevelToCSTR();
        v214 = *MEMORY[0x1E0CF2758];
        v5 = v350;
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
LABEL_363:
          v217 = 11;
LABEL_364:
          HIDWORD(v352) = v217;
          goto LABEL_418;
        }
        v215 = CMBlockBufferGetDataLength(blockBufferOut);
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)&buf[4] = v213;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VCVideoPacketBuffer_AssembleFrame";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 2716;
        *(_WORD *)&buf[28] = 2048;
        *(_QWORD *)&buf[30] = v351;
        *(_WORD *)&buf[38] = 2048;
        *(_QWORD *)&buf[40] = v215;
LABEL_516:
        _os_log_error_impl(&dword_1D8A54000, v214, OS_LOG_TYPE_ERROR, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Error appending packets, buffer size %zu", buf, 0x30u);
        goto LABEL_363;
      }
    }
    HIDWORD(v352) = 11;
    goto LABEL_366;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v239 = VRTraceErrorLogLevelToCSTR();
    v240 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136316674;
      *(_QWORD *)&buf[4] = v239;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "_VCVideoPacketBuffer_AssembleFrame";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 2710;
      *(_WORD *)&buf[28] = 2048;
      *(_QWORD *)&buf[30] = v4;
      *(_WORD *)&buf[38] = 1024;
      *(_DWORD *)&buf[40] = v346;
      *(_WORD *)&buf[44] = 1024;
      *(_DWORD *)&buf[46] = v341;
      *(_WORD *)&buf[50] = 1024;
      *(_DWORD *)&buf[52] = v344;
      _os_log_error_impl(&dword_1D8A54000, v240, OS_LOG_TYPE_ERROR, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Error while detecting missing packets missingMediaPacketsCount=%d mediaCount=%d parityCount=%d", buf, 0x38u);
    }
  }
LABEL_418:
  v93 = *(unsigned __int8 *)(v4 + 242);
  if (!*(_BYTE *)(v4 + 242))
    goto LABEL_433;
  v260 = 0;
  v372 = 0u;
  memset(v373, 0, 28);
  v370 = 0u;
  v371 = 0u;
  v368 = 0u;
  v369 = 0u;
  v367 = 0u;
  memset(buf, 0, sizeof(buf));
  v261 = *(unsigned __int16 **)(a2 + 96);
  LOWORD(v262) = *v261;
  while (2)
  {
    if (*((_DWORD *)v261 + 6))
    {
      v263 = *((_DWORD *)v261 + 8);
      if (v263 >> 30)
      {
        if ((v263 & 0x400000) == 0)
          goto LABEL_428;
      }
      else if ((v263 & 0x800000) == 0)
      {
        goto LABEL_428;
      }
    }
    v264 = v262 + 1;
    v262 = *v261;
    if (v262 > v264)
    {
      v265 = v264;
      do
      {
        snprintf((char *)buf, 0xDCuLL, "%s (%i)", (const char *)buf, v265);
        ++v260;
        ++v265;
        v262 = *v261;
      }
      while (v265 < v262);
    }
LABEL_428:
    v261 = (unsigned __int16 *)*((_QWORD *)v261 + 13);
    if (v261)
      continue;
    break;
  }
  if (v260)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v266 = VRTraceErrorLogLevelToCSTR();
      v267 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v291 = *(unsigned __int16 *)(a2 + 150);
        v292 = *(_DWORD *)(a2 + 16);
        if (HIDWORD(v352))
          v293 = kVCKeyFrameRequestReasonStrings[HIDWORD(v352)];
        else
          v293 = "NONE";
        *(_DWORD *)lengthAtOffsetOut = 136317698;
        *(_QWORD *)&lengthAtOffsetOut[4] = v266;
        v376 = 2080;
        v377 = "_VideoPacketBuffer_PrintMissingSequenceNumbers";
        v378 = 1024;
        v379 = 2659;
        v380 = 2048;
        v381 = v4;
        v382 = 1024;
        LODWORD(v383) = v346;
        WORD2(v383) = 1024;
        *(_DWORD *)((char *)&v383 + 6) = v341;
        WORD5(v383) = 1024;
        HIDWORD(v383) = v344;
        v384 = 1024;
        *(_DWORD *)v385 = v291;
        *(_WORD *)&v385[4] = 1024;
        *(_DWORD *)&v385[6] = v292;
        *(_WORD *)v386 = 2080;
        *(_QWORD *)&v386[2] = buf;
        v387 = 2080;
        v388 = v293;
        _os_log_error_impl(&dword_1D8A54000, v267, OS_LOG_TYPE_ERROR, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Error in assembly missingMediaPacketsCount=%d mediaCount=%d parityCount=%d frameSequenceNumber=%d ssrc=%u missingPackets=%s reason=%s", lengthAtOffsetOut, 0x58u);
      }
    }
  }
  v93 = 0;
LABEL_433:
  v92 = 1;
LABEL_434:
  if (*(_BYTE *)(a2 + 152) && (*(_DWORD *)a2 & 0xFFFFFFFE) != 0x7C)
  {
    if (v92)
    {
      v93 = *(unsigned __int8 *)(a2 + 153);
      if (*(_BYTE *)(a2 + 153))
      {
        if (*(_BYTE *)(v5 + 184) || *(_BYTE *)(v5 + 88))
          goto LABEL_440;
        v284 = v354;
        *(_DWORD *)(v5 + 188) = *(unsigned __int16 *)(a2 + 150);
        *(_DWORD *)(v5 + 84) = 1;
        *(_BYTE *)(v5 + 184) = 1;
        *(_DWORD *)(v5 + 92) = 6;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          v285 = VRTraceErrorLogLevelToCSTR();
          v286 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v287 = *(unsigned __int16 *)(a2 + 150);
            v288 = *(_DWORD *)(a2 + 12);
            v289 = *(_DWORD *)(v5 + 188);
            *(_DWORD *)buf = 136316674;
            *(_QWORD *)&buf[4] = v285;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VideoPacketBuffer_CheckForMissingBaseLayerAssemblyOfTemporalStream";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 2624;
            *(_WORD *)&buf[28] = 2048;
            *(_QWORD *)&buf[30] = v4;
            *(_WORD *)&buf[38] = 1024;
            *(_DWORD *)&buf[40] = v287;
            *(_WORD *)&buf[44] = 1024;
            *(_DWORD *)&buf[46] = v288;
            *(_WORD *)&buf[50] = 1024;
            *(_DWORD *)&buf[52] = v289;
            _os_log_impl(&dword_1D8A54000, v286, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] Assembly of base layer frame of temporal stream failed, refresh frame is needed. frameSequenceNumber=%d timestamp=%u baseLayerFrameAssemblyFailedSequenceNumber=%d", buf, 0x38u);
          }
        }
        if (!v284)
LABEL_440:
          v93 = 0;
        else
          v93 = v284[16] != 0;
      }
    }
    else
    {
      v93 = 1;
    }
    if (!*(_BYTE *)(a2 + 153) && *(_BYTE *)(v5 + 184) && !*(_BYTE *)(a2 + 52) && !*(_BYTE *)(a2 + 53))
      v93 = 0;
  }
  if (v93)
  {
    v268 = 1;
  }
  else
  {
    v269 = *(_DWORD *)a2 - 110;
    if (v269 <= 0xF && ((1 << v269) & 0xC001) != 0 || *(_BYTE *)(a2 + 152))
      goto LABEL_447;
    *(_DWORD *)(v5 + 84) = 1;
    *(_DWORD *)(v5 + 92) = HIDWORD(v352);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v280 = VRTraceErrorLogLevelToCSTR();
      v281 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v282 = **(unsigned __int16 **)(a2 + 96);
        if (HIDWORD(v352))
          v283 = kVCKeyFrameRequestReasonStrings[HIDWORD(v352)];
        else
          v283 = "NONE";
        *(_DWORD *)buf = 136316418;
        *(_QWORD *)&buf[4] = v280;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VCVideoPacketBuffer_AssembleFrame";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 2795;
        *(_WORD *)&buf[28] = 2048;
        *(_QWORD *)&buf[30] = v4;
        *(_WORD *)&buf[38] = 1024;
        *(_DWORD *)&buf[40] = v282;
        *(_WORD *)&buf[44] = 2080;
        *(_QWORD *)&buf[46] = v283;
        _os_log_impl(&dword_1D8A54000, v281, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] seq:%d Needs Refresh badFrame reason:%s ", buf, 0x36u);
      }
    }
    if ((_BYTE)v352)
      ++*(_DWORD *)(v4 + 460);
    if (!v354)
LABEL_447:
      v268 = 0;
    else
      v268 = v354[16] != 0;
  }
  if (!*(_DWORD *)(a2 + 40))
  {
    ++*(_DWORD *)(v4 + 468);
    if ((_BYTE)v352)
    {
      ++*(_DWORD *)(v4 + 496);
    }
    else
    {
      ++*(_DWORD *)(v4 + 464);
      ++*(_DWORD *)(v4 + 492);
    }
  }
  if (v268)
  {
    if (*(_BYTE *)(a2 + 57))
    {
      if (*(_BYTE *)(v4 + 242))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v270 = VRTraceErrorLogLevelToCSTR();
          v271 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v272 = *(unsigned __int16 *)(a2 + 150);
            *(_DWORD *)buf = 136316162;
            *(_QWORD *)&buf[4] = v270;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VCVideoPacketBuffer_AssembleFrame";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 2818;
            *(_WORD *)&buf[28] = 2048;
            *(_QWORD *)&buf[30] = v4;
            *(_WORD *)&buf[38] = 1024;
            *(_DWORD *)&buf[40] = v272;
            _os_log_impl(&dword_1D8A54000, v271, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] frame recovered with retransmitted packets frameSequenceNumber=%d", buf, 0x2Cu);
          }
        }
      }
      ++*(_DWORD *)(v4 + 1060);
    }
    *(_WORD *)(v4 + 424) = *(_WORD *)(a2 + 150);
    *a3 = v354;
    v354 = 0;
  }
  else
  {
    if (*(_BYTE *)(a2 + 57))
    {
      if (*(_BYTE *)(v4 + 242))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v273 = VRTraceErrorLogLevelToCSTR();
          v274 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v275 = *(unsigned __int16 *)(a2 + 150);
            *(_DWORD *)buf = 136316162;
            *(_QWORD *)&buf[4] = v273;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VCVideoPacketBuffer_AssembleFrame";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 2828;
            *(_WORD *)&buf[28] = 2048;
            *(_QWORD *)&buf[30] = v4;
            *(_WORD *)&buf[38] = 1024;
            *(_DWORD *)&buf[40] = v275;
            _os_log_impl(&dword_1D8A54000, v274, OS_LOG_TYPE_DEFAULT, "VideoPacketBuffer [%s] %s:%d VideoPacketBuffer[%p] frame with retransmitted packets failed to assemble frameSequenceNumber=%d", buf, 0x2Cu);
          }
        }
      }
      ++*(_DWORD *)(v4 + 1064);
    }
    *a3 = 0;
  }
  v276 = *(FILE ***)(v5 + 112);
  if (v276)
  {
    *(_OWORD *)buf = xmmword_1D910B830;
    *(_OWORD *)&buf[16] = unk_1D910B840;
    memset(&buf[32], 170, 64);
    *(_QWORD *)buf = *(_QWORD *)(a2 + 24);
    HIDWORD(v277) = *(_DWORD *)&buf[4];
    *(_DWORD *)&buf[8] = *(unsigned __int16 *)(a2 + 150);
    LODWORD(v277) = *(_DWORD *)(a2 + 12);
    *(double *)&buf[16] = (double)v277;
    *(_DWORD *)&buf[24] = v353;
    buf[28] = *(_BYTE *)(a2 + 52);
    *(_QWORD *)&v278 = *(_QWORD *)(v5 + 120);
    *((_QWORD *)&v278 + 1) = *(_QWORD *)(v5 + 40);
    *(_DWORD *)&buf[32] = *(unsigned __int16 *)(a2 + 122);
    *(_OWORD *)&buf[36] = v278;
    *(_DWORD *)&buf[52] = v343;
    *(_DWORD *)&buf[56] = v343 - v346;
    *(_DWORD *)&buf[60] = v346;
    *(_DWORD *)&buf[64] = v344;
    *(_DWORD *)&buf[68] = v346 - v344;
    *(_DWORD *)&buf[72] = v346;
    *(_DWORD *)&buf[76] = *(unsigned __int8 *)(a2 + 152);
    *(_DWORD *)&buf[80] = 0;
    *(_QWORD *)&buf[84] = __PAIR64__(HIDWORD(v352), v268);
    LODWORD(v278) = *(_DWORD *)v5;
    *(double *)&v367 = (double)(unint64_t)v278;
    VRDump_AssembleFrame(v276, (uint64_t)buf);
  }
  _VCVideoPacketBuffer_FinalizeGOBLengthAdjustement((uint64_t)&v355);
  if (v33)
    CFRelease(v33);
  VCVideoReceiverSampleBuffer_Destroy(&v354);
  if (blockBufferOut)
    CFRelease(blockBufferOut);
  if (theBuffer)
    CFRelease(theBuffer);
  return v268;
}

void VideoPacketBuffer_SetRoundTripTime(uint64_t a1, double a2)
{
  pthread_mutex_t *v4;

  if (a1)
  {
    v4 = (pthread_mutex_t *)(a1 + 352);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 352));
    VCNACKGenerator_UpdateRTT(*(_QWORD *)(a1 + 146088), a2);
    pthread_mutex_unlock(v4);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VideoPacketBuffer_SetRoundTripTime_cold_1();
  }
}

void _VCVideoPacketBuffer_FinalizeGOBLengthAdjustement(uint64_t a1)
{
  void *v2;
  unsigned int sourceBytes;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v2 = *(void **)a1;
  if (*(_QWORD *)a1)
  {
    if (*(_QWORD *)(a1 + 16) == 4
      || (sourceBytes = bswap32(*(_DWORD *)(a1 + 16) - 4),
          CMBlockBufferReplaceDataBytes(&sourceBytes, (CMBlockBufferRef)v2, *(_QWORD *)(a1 + 8), 4uLL),
          (v2 = *(void **)a1) != 0))
    {
      CFRelease(v2);
      *(_QWORD *)a1 = 0;
    }
  }
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
}

void _VideoPacketBuffer_AddFrameToBufferInOrder(uint64_t *a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  int v5;
  int v6;
  unsigned int v8;
  uint64_t v10;
  _BOOL4 v11;

  v3 = a1;
  v4 = *a1;
  if (*a1)
  {
    v5 = *(_DWORD *)(a2 + 12);
    v6 = *(_DWORD *)(v4 + 12);
    if (v6 == v5 || (v6 - v5) >= 0x7FFFFFFF)
    {
      do
      {
        v10 = v4;
        v4 = *(_QWORD *)(v4 + 112);
        v11 = v4 != 0;
        if (!v4)
          break;
        v8 = *(_DWORD *)(v4 + 12) - v5;
      }
      while (!v8 || v8 >= 0x7FFFFFFF);
      v3 = (uint64_t *)(v10 + 112);
    }
    else
    {
      v10 = 0;
      v11 = 1;
    }
  }
  else
  {
    v10 = 0;
    v11 = 0;
  }
  *(_QWORD *)(a2 + 112) = v4;
  _VideoPacketBuffer_UpdatePreviousFrameSequenceNumber(a2, v10, v11);
  *v3 = a2;
}

uint64_t VideoDecoder_Create(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  char *v5;
  char *v6;
  uint64_t Handle;

  v2 = 2147745793;
  if (a2)
  {
    if (*(_QWORD *)(a2 + 24))
    {
      v5 = (char *)malloc_type_calloc(1uLL, 0xD0uLL, 0x10F004099750CEEuLL);
      if (v5)
      {
        v6 = v5;
        pthread_mutex_init((pthread_mutex_t *)(v5 + 112), 0);
        *(_QWORD *)v6 = *(_QWORD *)(a2 + 8);
        *((_DWORD *)v6 + 2) = VCReporting_GetDynamicReportingModuleID();
        *((_DWORD *)v6 + 3) = 0;
        if (*(_BYTE *)(a2 + 16))
          *((_DWORD *)v6 + 5) |= 4u;
        if (*(_BYTE *)(a2 + 17))
          *((_DWORD *)v6 + 5) |= 1u;
        *(_OWORD *)(v6 + 184) = *(_OWORD *)(a2 + 24);
        Handle = CreateHandle();
        *a1 = Handle;
        if (Handle == 0xFFFFFFFFLL)
        {
          free(v6);
          return 2147745797;
        }
        else
        {
          return 0;
        }
      }
      else
      {
        return 2147745795;
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoDecoder_Create_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VideoDecoder_Create_cold_1();
  }
  return v2;
}

uint64_t VideoDecoder_Destroy()
{
  uint64_t v0;
  uint64_t v1;
  void *v2;

  v0 = CheckInHandleDebug();
  if (!v0)
    return 2147745794;
  v1 = v0;
  CheckOutHandleDebug();
  v2 = *(void **)(v1 + 40);
  if (v2)
    free(v2);
  VideoDecoder_DecompClose(v1);
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 112));
  free((void *)v1);
  return 0;
}

void VideoDecoder_DecompClose(uint64_t a1)
{
  const void *v2;
  OSQueueHead *v3;

  if (*(_DWORD *)(a1 + 12))
  {
    VCPDecompressionSessionWaitForAsynchronousFrames();
    v2 = *(const void **)(a1 + 24);
    if (v2)
      CFRelease(v2);
    *(_QWORD *)(a1 + 24) = 0;
    FigFormatDescriptionRelease();
    *(_QWORD *)(a1 + 32) = 0;
    *(_DWORD *)(a1 + 12) = 0;
  }
  v3 = *(OSQueueHead **)(a1 + 176);
  if (v3)
  {
    VCMemoryPool_Destroy(v3);
    *(_QWORD *)(a1 + 176) = 0;
  }
}

void VideoDecoder_SetDecoderSpecification(__CFDictionary *a1)
{
  char v2;
  const void *v3;

  v2 = VCFeatureFlagManager_UseAvconferencedOniOSSpecficFeatures(a1);
  if (a1 && (v2 & 1) == 0)
  {
    v3 = (const void *)VCAudioSessionCMS_SessionReference();
    if (v3)
      CFDictionarySetValue(a1, (const void *)*MEMORY[0x1E0CEDC90], v3);
  }
}

uint64_t VideoDecoder_NewFormat_InitDecoder(unint64_t a1, char *a2, int *a3, const char *a4, int32_t *a5, int32_t *a6, char a7, int a8, char a9, __int16 a10, __int16 a11, ...)
{
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const __CFString *v20;
  const __CFString *v21;
  uint64_t v22;
  NSObject *v23;
  uint64_t v24;
  NSObject *v25;
  void *v26;
  CFAllocatorRef *v27;
  size_t v28;
  unint64_t *v29;
  void *v30;
  int v31;
  size_t v32;
  void *v33;
  unint64_t v34;
  const uint8_t *v35;
  const __CFAllocator *v36;
  CFStringEncoding SystemEncoding;
  const void *v38;
  CMVideoDimensions Dimensions;
  const __CFDictionary *Extensions;
  const __CFDictionary *v41;
  const void *v42;
  __CFDictionary *MutableCopy;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  size_t v48;
  int v50;
  const opaqueCMFormatDescription *v51;
  int AppBooleanValue;
  uint64_t v53;
  NSObject *v54;
  const char *v55;
  uint64_t v56;
  const void *v57;
  const void **v58;
  void *v59;
  void **v60;
  const void *v61;
  const void **v62;
  const __CFAllocator *v63;
  CFDataRef v64;
  CFDataRef v65;
  CFTypeID TypeID;
  __CFDictionary *v67;
  __CFDictionary *v68;
  const void *v69;
  __CFDictionary *v70;
  uint64_t v71;
  uint64_t v72;
  NSObject *v73;
  char *v74;
  int v75;
  int v76;
  uint64_t v77;
  NSObject *v78;
  const char *v79;
  uint64_t v80;
  uint64_t v81;
  NSObject *v82;
  const __CFAllocator *v83;
  CFNumberRef v84;
  const CFDictionaryKeyCallBacks *v85;
  const CFDictionaryValueCallBacks *v86;
  __CFDictionary *Mutable;
  CFDictionaryRef v88;
  CFDictionaryRef v89;
  __CFDictionary *v90;
  uint64_t v91;
  NSObject *v92;
  const void *v93;
  __CFDictionary *v94;
  CFNumberRef v95;
  uint64_t v96;
  NSObject *v97;
  _BOOL4 v98;
  const void *v99;
  CFStringRef v100;
  int v101;
  int ErrorLogLevelForModule;
  uint64_t v104;
  NSObject *v105;
  uint64_t v106;
  int v107;
  int v108;
  char *v109;
  uint64_t v110;
  uint64_t v111;
  NSObject *v112;
  CFNumberRef v113;
  CFNumberRef v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  NSObject *v119;
  void *value;
  int v121;
  pthread_mutex_t *v122;
  CMVideoFormatDescriptionRef formatDescriptionOut;
  void (*v126)(uint64_t, unsigned __int8 *, int, uint64_t, void *, CMTime *);
  unint64_t v127;
  Boolean keyExistsAndHasValidFormat;
  int v129;
  int v130;
  _QWORD buf[3];
  int v132;
  __int16 v133;
  uint64_t v134;
  __int16 v135;
  _BYTE v136[10];
  int v137;
  __int16 v138;
  int v139;
  __int16 v140;
  char *v141;
  __int16 v142;
  const char *v143;
  __int16 v144;
  int v145;
  size_t parameterSetSizes[5];
  va_list va;

  va_start(va, a11);
  parameterSetSizes[3] = *MEMORY[0x1E0C80C00];
  v17 = 2147745796;
  v18 = CheckInHandleDebug();
  if (!v18)
    return 2147745794;
  v19 = v18;
  v121 = a8;
  v122 = (pthread_mutex_t *)(v18 + 112);
  pthread_mutex_lock((pthread_mutex_t *)(v18 + 112));
  VideoDecoder_DecompClose(v19);
  *(_DWORD *)(v19 + 16) = 1;
  *(_WORD *)(v19 + 56) = a11;
  v20 = (const __CFString *)CFPreferencesCopyAppValue(CFSTR("FaceTimeDecoder"), CFSTR("com.apple.VideoConference"));
  if (v20)
  {
    v21 = v20;
    if (CFStringCompare(v20, CFSTR("hw"), 0) == kCFCompareEqualTo)
    {
      *(_DWORD *)(v19 + 16) = 1;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v22 = VRTraceErrorLogLevelToCSTR();
        v23 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf[0]) = 136315650;
          *(_QWORD *)((char *)buf + 4) = v22;
          WORD2(buf[1]) = 2080;
          *(_QWORD *)((char *)&buf[1] + 6) = "VideoDecoder_NewFormat_InitDecoder";
          HIWORD(buf[2]) = 1024;
          v132 = 501;
          _os_log_impl(&dword_1D8A54000, v23, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d 'com.apple.VideoConference FaceTimeDecoder hw' forcing hardware decode", (uint8_t *)buf, 0x1Cu);
        }
      }
    }
    if (CFStringCompare(v21, CFSTR("sw"), 0) == kCFCompareEqualTo)
    {
      *(_DWORD *)(v19 + 16) = 2;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v24 = VRTraceErrorLogLevelToCSTR();
        v25 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf[0]) = 136315650;
          *(_QWORD *)((char *)buf + 4) = v24;
          WORD2(buf[1]) = 2080;
          *(_QWORD *)((char *)&buf[1] + 6) = "VideoDecoder_NewFormat_InitDecoder";
          HIWORD(buf[2]) = 1024;
          v132 = 505;
          _os_log_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d 'com.apple.VideoConference FaceTimeDecoder sw' forcing software decode", (uint8_t *)buf, 0x1Cu);
        }
      }
    }
    CFRelease(v21);
  }
  v26 = *(void **)(v19 + 40);
  v27 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  if ((a7 & 1) == 0)
  {
    if (v26)
    {
      free(v26);
      *(_QWORD *)(v19 + 40) = 0;
    }
    v32 = *a3;
    v33 = malloc_type_calloc(1uLL, v32, 0x571227FCuLL);
    *(_QWORD *)(v19 + 40) = v33;
    v34 = a1;
    if (v33)
    {
      memcpy(v33, a2, v32);
      *(_QWORD *)(v19 + 48) = v32;
      v35 = *(const uint8_t **)(v19 + 40);
    }
    else
    {
      v35 = 0;
      v32 = *(_QWORD *)(v19 + 48);
    }
    v126 = (void (*)(uint64_t, unsigned __int8 *, int, uint64_t, void *, CMTime *))0xAAAAAAAAAAAAAAAALL;
    v127 = 0xAAAAAAAAAAAAAAAALL;
    formatDescriptionOut = 0;
    v36 = *v27;
    SystemEncoding = CFStringGetSystemEncoding();
    if (CMVideoFormatDescriptionCreateFromBigEndianImageDescriptionData(v36, v35, v32, SystemEncoding, 0, &formatDescriptionOut))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VideoDecoder_NewFormat_InitDecoder_cold_8();
      }
    }
    else
    {
      v38 = *(const void **)(v19 + 32);
      if (v38)
        CFRelease(v38);
      *(_QWORD *)(v19 + 32) = formatDescriptionOut;
    }
    Dimensions = CMVideoFormatDescriptionGetDimensions(*(CMVideoFormatDescriptionRef *)(v19 + 32));
    *(CMVideoDimensions *)(v19 + 60) = Dimensions;
    if (a5)
      *a5 = Dimensions.width;
    if (a6)
      *a6 = Dimensions.height;
    *(_DWORD *)(v19 + 68) = CMFormatDescriptionGetMediaSubType(*(CMFormatDescriptionRef *)(v19 + 32));
    Extensions = CMFormatDescriptionGetExtensions(*(CMFormatDescriptionRef *)(v19 + 32));
    if (Extensions)
    {
      v41 = Extensions;
      v42 = (const void *)*MEMORY[0x1E0CA8D68];
      if (!CFDictionaryContainsKey(Extensions, (const void *)*MEMORY[0x1E0CA8D68]))
      {
        buf[0] = 0xAAAAAAAAAAAAAAAALL;
        MutableCopy = CFDictionaryCreateMutableCopy(v36, 0, v41);
        CFDictionarySetValue(MutableCopy, v42, (const void *)*MEMORY[0x1E0CA8D88]);
        CFDictionarySetValue(MutableCopy, (const void *)*MEMORY[0x1E0CA8E98], (const void *)*MEMORY[0x1E0CA8EB0]);
        CFDictionarySetValue(MutableCopy, (const void *)*MEMORY[0x1E0CA8EE8], (const void *)*MEMORY[0x1E0CA8F18]);
        if (CMVideoFormatDescriptionCreate(v36, *(_DWORD *)(v19 + 68), *(_DWORD *)(v19 + 60), *(_DWORD *)(v19 + 64), MutableCopy, (CMVideoFormatDescriptionRef *)buf))
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VideoDecoder_NewFormat_InitDecoder_cold_7();
          }
        }
        else
        {
          FigFormatDescriptionRelease();
          *(_QWORD *)(v19 + 32) = buf[0];
        }
        CFRelease(MutableCopy);
      }
    }
LABEL_116:
    if (*(_DWORD *)(v19 + 16) == 2)
    {
      *(_DWORD *)(v19 + 68) = 1718908515;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v77 = VRTraceErrorLogLevelToCSTR();
        v78 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf[0]) = 136315650;
          *(_QWORD *)((char *)buf + 4) = v77;
          WORD2(buf[1]) = 2080;
          *(_QWORD *)((char *)&buf[1] + 6) = "VideoDecoder_NewFormat_InitDecoder";
          HIWORD(buf[2]) = 1024;
          v132 = 658;
          v79 = " [%s] %s:%d Using Software Video Decoder";
LABEL_123:
          _os_log_impl(&dword_1D8A54000, v78, OS_LOG_TYPE_DEFAULT, v79, (uint8_t *)buf, 0x1Cu);
        }
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v80 = VRTraceErrorLogLevelToCSTR();
      v78 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf[0]) = 136315650;
        *(_QWORD *)((char *)buf + 4) = v80;
        WORD2(buf[1]) = 2080;
        *(_QWORD *)((char *)&buf[1] + 6) = "VideoDecoder_NewFormat_InitDecoder";
        HIWORD(buf[2]) = 1024;
        v132 = 660;
        v79 = " [%s] %s:%d Using Hardware Video Decoder";
        goto LABEL_123;
      }
    }
    LODWORD(parameterSetSizes[0]) = -1431655766;
    LODWORD(parameterSetSizes[0]) = FigThreadGetMachThreadPriorityValue();
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v81 = VRTraceErrorLogLevelToCSTR();
      v82 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf[0]) = 136315906;
        *(_QWORD *)((char *)buf + 4) = v81;
        WORD2(buf[1]) = 2080;
        *(_QWORD *)((char *)&buf[1] + 6) = "VideoDecoder_NewFormat_InitDecoder";
        HIWORD(buf[2]) = 1024;
        v132 = 665;
        v133 = 1024;
        LODWORD(v134) = parameterSetSizes[0];
        _os_log_impl(&dword_1D8A54000, v82, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d machThreadPriority=%d", (uint8_t *)buf, 0x22u);
      }
    }
    v83 = *v27;
    v84 = CFNumberCreate(*v27, kCFNumberSInt32Type, parameterSetSizes);
    v85 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
    v86 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
    Mutable = CFDictionaryCreateMutable(v83, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v88 = CFDictionaryCreate(0, 0, 0, 0, v85, v86);
    if (v88)
    {
      v89 = v88;
      CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CA8FF0], v88);
      CFRelease(v89);
    }
    v90 = CFDictionaryCreateMutable(v83, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (VCFeatureFlagManager_UseOutOfProcessVideoDecoding())
    {
      if (!v84)
        goto LABEL_142;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v91 = VRTraceErrorLogLevelToCSTR();
        v92 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf[0]) = 136315906;
          *(_QWORD *)((char *)buf + 4) = v91;
          WORD2(buf[1]) = 2080;
          *(_QWORD *)((char *)&buf[1] + 6) = "VideoDecoder_NewFormat_InitDecoder";
          HIWORD(buf[2]) = 1024;
          v132 = 680;
          v133 = 1024;
          LODWORD(v134) = parameterSetSizes[0];
          _os_log_impl(&dword_1D8A54000, v92, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Adding machThreadPriority=%d as kVTDecompressionPropertyKey_MachThreadPriorityOfConsistentThreadCallingDecodeFrame", (uint8_t *)buf, 0x22u);
        }
      }
      v93 = (const void *)*MEMORY[0x1E0CED338];
      v94 = v90;
      v95 = v84;
    }
    else
    {
      if ((int)VRTraceGetErrorLogLevelForModule() <= 6)
      {
        v99 = (const void *)*MEMORY[0x1E0CED458];
      }
      else
      {
        v96 = VRTraceErrorLogLevelToCSTR();
        v97 = *MEMORY[0x1E0CF2758];
        v98 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
        v99 = (const void *)*MEMORY[0x1E0CED458];
        if (v98)
        {
          LODWORD(buf[0]) = 136315906;
          *(_QWORD *)((char *)buf + 4) = v96;
          WORD2(buf[1]) = 2080;
          *(_QWORD *)((char *)&buf[1] + 6) = "VideoDecoder_NewFormat_InitDecoder";
          HIWORD(buf[2]) = 1024;
          v132 = 684;
          v133 = 2112;
          v134 = (uint64_t)v99;
          _os_log_impl(&dword_1D8A54000, v97, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Adding kVTDecompressionSessionOption_AllowClientProcessDecode=%@ to decoderSpecification", (uint8_t *)buf, 0x26u);
        }
        v34 = a1;
      }
      v95 = (CFNumberRef)*MEMORY[0x1E0C9AE50];
      v94 = v90;
      v93 = v99;
    }
    CFDictionarySetValue(v94, v93, v95);
LABEL_142:
    VideoDecoder_SetDecoderSpecification(v90);
    v100 = CFStringCreateWithCString(0, a4, 0);
    CFDictionarySetValue(v90, CFSTR("NegotiationDetails"), v100);
    if (v100)
      CFRelease(v100);
    FigCFDictionarySetInt64();
    v126 = VideoDecoder_VTDecompressionCallback;
    v127 = v34;
    v101 = VCPDecompressionSessionCreate();
    if (v90)
      CFRelease(v90);
    ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    if (v101)
    {
      if (ErrorLogLevelForModule >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VideoDecoder_NewFormat_InitDecoder_cold_3();
      }
      VideoUtil_PrintFormatDesc(*(const opaqueCMFormatDescription **)(v19 + 32));
      if (!v84)
        goto LABEL_152;
    }
    else
    {
      if (ErrorLogLevelForModule >= 7)
      {
        v104 = VRTraceErrorLogLevelToCSTR();
        v105 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v106 = *(_QWORD *)(v19 + 24);
          v107 = *(_DWORD *)(v19 + 60);
          v108 = *(_DWORD *)(v19 + 64);
          v109 = FourccToCStr(*(_DWORD *)(v19 + 68));
          v110 = *(_QWORD *)(v19 + 192);
          LODWORD(buf[0]) = 136317442;
          *(_QWORD *)((char *)buf + 4) = v104;
          WORD2(buf[1]) = 2080;
          *(_QWORD *)((char *)&buf[1] + 6) = "VideoDecoder_NewFormat_InitDecoder";
          HIWORD(buf[2]) = 1024;
          v132 = 717;
          v133 = 2048;
          v134 = v19;
          v135 = 2048;
          *(_QWORD *)v136 = v106;
          *(_WORD *)&v136[8] = 1024;
          v137 = v107;
          v138 = 1024;
          v139 = v108;
          v140 = 2080;
          v141 = v109;
          v142 = 2080;
          v143 = a4;
          v144 = 1024;
          v145 = v110;
          _os_log_impl(&dword_1D8A54000, v105, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d [AR_RX][FLS] Created decoder=%p session=%p width=%d height=%d codec=%s featureListString=%s videoReceiverHandle=0x%x", (uint8_t *)buf, 0x56u);
        }
      }
      if (VCFeatureFlagManager_UseOutOfProcessVideoDecoding() && v84)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v111 = VRTraceErrorLogLevelToCSTR();
          v112 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf[0]) = 136315906;
            *(_QWORD *)((char *)buf + 4) = v111;
            WORD2(buf[1]) = 2080;
            *(_QWORD *)((char *)&buf[1] + 6) = "VideoDecoder_NewFormat_InitDecoder";
            HIWORD(buf[2]) = 1024;
            v132 = 721;
            v133 = 1024;
            LODWORD(v134) = parameterSetSizes[0];
            _os_log_impl(&dword_1D8A54000, v112, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Adding machThreadPriority=%d as kVTDecompressionPropertyKey_MachThreadPriorityOfConsistentThreadCallingDecodeFrame", (uint8_t *)buf, 0x22u);
          }
        }
        VCPDecompressionSessionSetProperty();
      }
      v113 = CFNumberCreate(0, kCFNumberIntType, va);
      if (v113)
      {
        v114 = v113;
        VCPDecompressionSessionSetProperty();
        CFRelease(v114);
      }
      v115 = *MEMORY[0x1E0C9AE50];
      v116 = *MEMORY[0x1E0C9AE40];
      VCPDecompressionSessionSetProperty();
      if ((a9 & 2) != 0)
        v117 = v115;
      else
        v117 = v116;
      VCPDecompressionSessionSetProperty();
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v118 = VRTraceErrorLogLevelToCSTR();
        v119 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf[0]) = 136315906;
          *(_QWORD *)((char *)buf + 4) = v118;
          WORD2(buf[1]) = 2080;
          *(_QWORD *)((char *)&buf[1] + 6) = "VideoDecoder_NewFormat_InitDecoder";
          HIWORD(buf[2]) = 1024;
          v132 = 739;
          v133 = 2112;
          v134 = v117;
          _os_log_impl(&dword_1D8A54000, v119, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d kVCPDecompressionPropertyKey_MLEnhance=%@", (uint8_t *)buf, 0x26u);
        }
      }
      LODWORD(buf[1]) = 0;
      buf[0] = 0;
      snprintf((char *)buf, 0xCuLL, "%d", v121);
      reportingLog();
      if (!v84)
        goto LABEL_152;
    }
    CFRelease(v84);
LABEL_152:
    CFRelease(Mutable);
    if (v101)
      v17 = -v101 | 0xA0040000;
    else
      v17 = 0;
    *(_DWORD *)(v19 + 12) = v101 == 0;
    *(_QWORD *)(v19 + 176) = VCMemoryPool_Create(0x38uLL);
    pthread_mutex_unlock(v122);
LABEL_156:
    CheckOutHandleDebug();
    return v17;
  }
  if (v26)
  {
    free(v26);
    *(_QWORD *)(v19 + 40) = 0;
  }
  v28 = *(_QWORD *)a3 + 64;
  *(_QWORD *)(v19 + 48) = v28;
  v29 = (unint64_t *)(v19 + 48);
  v30 = malloc_type_calloc(v28, 1uLL, 0x100004077774924uLL);
  *(_QWORD *)(v19 + 40) = v30;
  if (v30)
  {
    if (v121 == 100)
      v31 = 1752589105;
    else
      v31 = 1635148593;
    if (gksVCPParseParameterSetsAndCreateConfigurationRecord() || (v44 = *v29) == 0)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VideoDecoder_NewFormat_InitDecoder_cold_2();
      }
      pthread_mutex_unlock(v122);
      goto LABEL_156;
    }
    v126 = (void (*)(uint64_t, unsigned __int8 *, int, uint64_t, void *, CMTime *))0xAAAAAAAAAAAAAAAALL;
    v127 = 0xAAAAAAAAAAAAAAAALL;
    formatDescriptionOut = 0;
    *(_DWORD *)(v19 + 68) = v31;
    if (v121 == 100)
    {
      memset(buf, 0, sizeof(buf));
      memset(parameterSetSizes, 0, 24);
      v45 = *(_QWORD *)a3;
      v27 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
      if (*(_QWORD *)a3)
      {
        v46 = 0;
        v47 = 0;
        do
        {
          v48 = bswap32(*(_DWORD *)&a2[v47]);
          buf[v46] = &a2[v47 + 4];
          parameterSetSizes[v46] = v48;
          v47 += (v48 + 4);
        }
        while (v47 < v45 && v46++ < 2);
      }
      CMVideoFormatDescriptionCreateFromHEVCParameterSets(*v27, 3uLL, (const uint8_t *const *)buf, parameterSetSizes, 4, 0, &formatDescriptionOut);
      if (ReadCodecConfigParams(100, *(_QWORD *)(v19 + 40), *(_QWORD *)(v19 + 48), (_DWORD *)(v19 + 60), (_DWORD *)(v19 + 64), 0, 0, 0) << 16)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VideoDecoder_NewFormat_InitDecoder_cold_4();
        }
        return v17;
      }
      v34 = a1;
      v51 = formatDescriptionOut;
      goto LABEL_111;
    }
    LODWORD(parameterSetSizes[0]) = 1;
    v129 = 1;
    v130 = 1;
    v50 = ReadCodecConfigParams(v121, *(_QWORD *)(v19 + 40), v44, (_DWORD *)(v19 + 60), (_DWORD *)(v19 + 64), (int *)parameterSetSizes, &v130, &v129);
    v27 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
    if (v50 << 16)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        v34 = a1;
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VideoDecoder_NewFormat_InitDecoder_cold_6();
LABEL_109:
        v51 = 0;
        goto LABEL_110;
      }
      v51 = 0;
LABEL_107:
      v34 = a1;
LABEL_110:
      formatDescriptionOut = v51;
LABEL_111:
      if (v51)
      {
        FigFormatDescriptionRelease();
        *(_QWORD *)(v19 + 32) = formatDescriptionOut;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v72 = VRTraceErrorLogLevelToCSTR();
          v73 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v74 = FourccToCStr(*(_DWORD *)(v19 + 68));
            v75 = *(_DWORD *)(v19 + 60);
            v76 = *(_DWORD *)(v19 + 64);
            LODWORD(buf[0]) = 136316418;
            *(_QWORD *)((char *)buf + 4) = v72;
            WORD2(buf[1]) = 2080;
            *(_QWORD *)((char *)&buf[1] + 6) = "VideoDecoder_NewFormat_InitDecoder";
            HIWORD(buf[2]) = 1024;
            v132 = 592;
            v133 = 2080;
            v134 = (uint64_t)v74;
            v135 = 1024;
            *(_DWORD *)v136 = v75;
            *(_WORD *)&v136[4] = 1024;
            *(_DWORD *)&v136[6] = v76;
            _os_log_impl(&dword_1D8A54000, v73, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Recreated format description: %s, %d, %d", (uint8_t *)buf, 0x32u);
          }
        }
        *a5 = *(_DWORD *)(v19 + 60);
        *a6 = *(_DWORD *)(v19 + 64);
      }
      goto LABEL_116;
    }
    keyExistsAndHasValidFormat = 0;
    AppBooleanValue = CFPreferencesGetAppBooleanValue(CFSTR("forceHDR10ColorInfo"), CFSTR("com.apple.VideoConference"), &keyExistsAndHasValidFormat);
    v34 = a1;
    if (keyExistsAndHasValidFormat)
    {
      if (AppBooleanValue)
      {
        LODWORD(parameterSetSizes[0]) = 9;
        v129 = 9;
        v130 = 16;
        if ((int)VRTraceGetErrorLogLevelForModule() < 7)
          goto LABEL_81;
        v53 = VRTraceErrorLogLevelToCSTR();
        v54 = *MEMORY[0x1E0CF2758];
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          goto LABEL_81;
        LODWORD(buf[0]) = 136315650;
        *(_QWORD *)((char *)buf + 4) = v53;
        WORD2(buf[1]) = 2080;
        *(_QWORD *)((char *)&buf[1] + 6) = "recreateFormatDescription";
        HIWORD(buf[2]) = 1024;
        v132 = 301;
        v55 = " [%s] %s:%d ITU_R_2020 HDR color settings applied on the decoder";
      }
      else
      {
        LODWORD(parameterSetSizes[0]) = 12;
        v129 = 1;
        v130 = 16;
        if ((int)VRTraceGetErrorLogLevelForModule() < 7)
          goto LABEL_81;
        v56 = VRTraceErrorLogLevelToCSTR();
        v54 = *MEMORY[0x1E0CF2758];
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          goto LABEL_81;
        LODWORD(buf[0]) = 136315650;
        *(_QWORD *)((char *)buf + 4) = v56;
        WORD2(buf[1]) = 2080;
        *(_QWORD *)((char *)&buf[1] + 6) = "recreateFormatDescription";
        HIWORD(buf[2]) = 1024;
        v132 = 306;
        v55 = " [%s] %s:%d P3_D65 HDR color settings applied on the decoder";
      }
      _os_log_impl(&dword_1D8A54000, v54, OS_LOG_TYPE_DEFAULT, v55, (uint8_t *)buf, 0x1Cu);
    }
LABEL_81:
    v57 = 0;
    switch(LODWORD(parameterSetSizes[0]))
    {
      case 1:
        v58 = (const void **)MEMORY[0x1E0CA8D88];
        goto LABEL_87;
      case 5:
        v58 = (const void **)MEMORY[0x1E0CA8D78];
        goto LABEL_87;
      case 6:
        v58 = (const void **)MEMORY[0x1E0CA8DA0];
        goto LABEL_87;
      case 9:
        v58 = (const void **)MEMORY[0x1E0CA2108];
        goto LABEL_87;
      case 0xC:
        v58 = (const void **)MEMORY[0x1E0CA2120];
LABEL_87:
        v57 = *v58;
        break;
      default:
        break;
    }
    v59 = 0;
    switch(v130)
    {
      case 1:
      case 2:
      case 6:
        v60 = (void **)MEMORY[0x1E0CA8EB0];
        goto LABEL_93;
      case 3:
      case 4:
      case 5:
        goto LABEL_94;
      case 7:
        v60 = (void **)MEMORY[0x1E0CA8EC0];
        goto LABEL_93;
      default:
        if (v130 != 16)
          goto LABEL_94;
        v60 = (void **)MEMORY[0x1E0CA2338];
LABEL_93:
        v59 = *v60;
LABEL_94:
        v61 = 0;
        switch(v129)
        {
          case 1:
            v62 = (const void **)MEMORY[0x1E0CA8F18];
            goto LABEL_99;
          case 6:
            v62 = (const void **)MEMORY[0x1E0CA8F10];
            goto LABEL_99;
          case 7:
            v62 = (const void **)MEMORY[0x1E0CA8F30];
            goto LABEL_99;
          case 9:
            v62 = (const void **)MEMORY[0x1E0CA2360];
LABEL_99:
            v61 = *v62;
            break;
          default:
            break;
        }
        buf[0] = 0xAAAAAAAAAAAAAAAALL;
        v63 = *v27;
        v64 = CFDataCreate(*v27, *(const UInt8 **)(v19 + 40), *(_QWORD *)(v19 + 48));
        if (!v64)
          goto LABEL_109;
        v65 = v64;
        value = v59;
        TypeID = CFDataGetTypeID();
        if (TypeID != CFGetTypeID(v65))
        {
          CFRelease(v65);
          goto LABEL_109;
        }
        v67 = CFDictionaryCreateMutable(v63, 1, 0, 0);
        CFDictionarySetValue(v67, CFSTR("avcC"), v65);
        v68 = CFDictionaryCreateMutable(v63, 0, 0, 0);
        CFDictionarySetValue(v68, (const void *)*MEMORY[0x1E0CA8D68], v57);
        CFDictionarySetValue(v68, (const void *)*MEMORY[0x1E0CA8E98], value);
        v69 = v61;
        v70 = v67;
        CFDictionarySetValue(v68, (const void *)*MEMORY[0x1E0CA8EE8], v69);
        CFDictionarySetValue(v68, (const void *)*MEMORY[0x1E0CA2240], v67);
        if ((unsigned __int16)CMVideoFormatDescriptionCreate(v63, *(_DWORD *)(v19 + 68), *(_DWORD *)(v19 + 60), *(_DWORD *)(v19 + 64), v68, (CMVideoFormatDescriptionRef *)buf))
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            v71 = VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VideoDecoder_NewFormat_InitDecoder_cold_5(v71);
          }
        }
        CFRelease(v65);
        CFRelease(v70);
        CFRelease(v68);
        v51 = (const opaqueCMFormatDescription *)buf[0];
        break;
    }
    goto LABEL_107;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VideoDecoder_NewFormat_InitDecoder_cold_1();
  }
  pthread_mutex_unlock(v122);
  CheckOutHandleDebug();
  return 2147745795;
}

void VideoDecoder_VTDecompressionCallback(uint64_t a1, unsigned __int8 *a2, int a3, uint64_t a4, void *a5, CMTime *a6)
{
  uint64_t v10;
  uint64_t v11;
  CFTypeID TypeID;
  __CVBuffer *v13;
  int v14;
  uint64_t v15;
  NSObject *v16;
  NSObject *v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  int v24;
  uint64_t v25;
  NSObject *v26;
  int v27;
  int v28;
  int v29;
  const __CFAllocator *v30;
  const CFDictionaryKeyCallBacks *v31;
  const CFDictionaryValueCallBacks *v32;
  __CFDictionary *Mutable;
  int v34;
  __CFDictionary *v35;
  __CFDictionary *v36;
  CFStringRef v37;
  CFNumberRef v38;
  uint64_t v39;
  void (*v40)(uint64_t, __CVBuffer *, unsigned __int8 *, CMTime *);
  int v41;
  CMTime buf;
  int v43;
  __int16 v44;
  int v45;
  __int16 v46;
  int v47;
  __int16 v48;
  int v49;
  __int16 v50;
  uint64_t v51;
  __int16 v52;
  uint64_t v53;
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  v10 = CheckInHandleDebug();
  if (v10)
  {
    v11 = v10;
    if (a5)
    {
      CFRetain(a5);
      TypeID = CVPixelBufferGetTypeID();
      if (TypeID == CFGetTypeID(a5) && a2[42])
      {
        v13 = CVPixelBufferRetain((CVPixelBufferRef)a5);
        v14 = 1;
      }
      else
      {
        v14 = 0;
        v13 = 0;
      }
      CFRelease(a5);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v15 = VRTraceErrorLogLevelToCSTR();
        v16 = *MEMORY[0x1E0CF2758];
        v17 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            v18 = *(_DWORD *)a2;
            v19 = a2[42];
            v20 = *((unsigned __int16 *)a2 + 12);
            v21 = (unsigned __int16)*((_QWORD *)a2 + 2);
            v22 = HIDWORD(*((_QWORD *)a2 + 2));
            LODWORD(buf.value) = 136316930;
            *(CMTimeValue *)((char *)&buf.value + 4) = v15;
            LOWORD(buf.flags) = 2080;
            *(_QWORD *)((char *)&buf.flags + 2) = "VideoDecoder_VTDecompressionCallback";
            HIWORD(buf.epoch) = 1024;
            v43 = 141;
            v44 = 1024;
            v45 = v18;
            v46 = 1024;
            v47 = v19;
            v48 = 1024;
            v49 = v20;
            v50 = 2048;
            v51 = v21;
            v52 = 2048;
            v53 = v22;
            _os_log_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Decoder returned frame with RTPTimestamp=%u, showFrame %d, streamID %d, decoding order %llu, tileID %llu", (uint8_t *)&buf, 0x42u);
          }
        }
        else if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
        {
          VideoDecoder_VTDecompressionCallback_cold_4();
        }
      }
      *(_DWORD *)(v11 + 200) = 0;
      if (v14)
      {
        if (CVBufferGetAttachment((CVBufferRef)a5, CFSTR("HIDTimeStamp"), 0))
          FigCFNumberGetUInt64();
        v14 = 1;
      }
      goto LABEL_31;
    }
    v23 = *(unsigned __int16 *)(v10 + 56);
    if (v23 == 1)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VideoDecoder_VTDecompressionCallback_cold_2();
      }
    }
    else
    {
      v24 = *(_DWORD *)(v10 + 200) + 1;
      *(_DWORD *)(v10 + 200) = v24;
      if (v24 >= v23)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VideoDecoder_VTDecompressionCallback_cold_3();
        }
        v13 = 0;
        v14 = 0;
        *(_DWORD *)(v11 + 200) = 0;
LABEL_31:
        buf = *a6;
        CMTimeGetSeconds(&buf);
        kdebug_trace();
        if (a3)
        {
          memset(&buf, 170, 12);
          __sprintf_chk((char *)&buf, 0, 0xCuLL, "%d", a3);
          reportingLog();
          if (a3 == -17694)
            a2[44] = 1;
          a2[43] = a2[49] ^ 1;
          a2[42] = 0;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            v25 = VRTraceErrorLogLevelToCSTR();
            v26 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            {
              v27 = *((unsigned __int16 *)a2 + 12);
              v28 = a2[43];
              v29 = a2[49];
              LODWORD(buf.value) = 136316674;
              *(CMTimeValue *)((char *)&buf.value + 4) = v25;
              LOWORD(buf.flags) = 2080;
              *(_QWORD *)((char *)&buf.flags + 2) = "VideoDecoder_VTDecompressionCallback";
              HIWORD(buf.epoch) = 1024;
              v43 = 173;
              v44 = 1024;
              v45 = a3;
              v46 = 1024;
              v47 = v27;
              v48 = 1024;
              v49 = v28;
              v50 = 1024;
              LODWORD(v51) = v29;
              _os_log_error_impl(&dword_1D8A54000, v26, OS_LOG_TYPE_ERROR, " [%s] %s:%d Failure status=%d for streamId=%d, requestIntra=%d, isNonBaseLayerOfTemporalStream=%d", (uint8_t *)&buf, 0x34u);
            }
          }
        }
        else if (v14)
        {
          v30 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          v31 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
          v32 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
          Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          v34 = *(_DWORD *)(v11 + 60);
          v41 = *(_DWORD *)(v11 + 64);
          v35 = CFDictionaryCreateMutable(v30, 0, v31, v32);
          v36 = v35;
          if (v35)
          {
            setIntValue(v35, CFSTR("VCPixelBufferLeftX"), 0);
            setIntValue(v36, CFSTR("VCPixelBufferTopY"), 0);
            setIntValue(v36, CFSTR("VCPixelBufferWidth"), v34);
            setIntValue(v36, CFSTR("VCPixelBufferHeight"), v41);
          }
          v37 = CFStringCreateWithFormat(v30, 0, CFSTR("%d"), *((_QWORD *)a2 + 4));
          CFDictionarySetValue(Mutable, v37, v36);
          if (a2[42])
          {
            CVBufferSetAttachment(v13, CFSTR("VCPixelBufferAttributes"), Mutable, kCVAttachmentMode_ShouldPropagate);
            if (a2[45])
            {
              v38 = CFNumberCreate(v30, kCFNumberSInt8Type, a2 + 46);
              CVBufferSetAttachment(v13, CFSTR("FramePriority"), v38, kCVAttachmentMode_ShouldPropagate);
              CFRelease(v38);
            }
          }
          CFRelease(v37);
          CFRelease(v36);
          CFRelease(Mutable);
          goto LABEL_45;
        }
        a2[42] = 0;
LABEL_45:
        v40 = *(void (**)(uint64_t, __CVBuffer *, unsigned __int8 *, CMTime *))(v11 + 184);
        v39 = *(_QWORD *)(v11 + 192);
        buf = *a6;
        v40(v39, v13, a2, &buf);
        VCMemoryPool_Free(*(OSQueueHead **)(v11 + 176), a2);
        CVPixelBufferRelease(v13);
        CheckOutHandleDebug();
        return;
      }
    }
    v13 = 0;
    v14 = 0;
    goto LABEL_31;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VideoDecoder_VTDecompressionCallback_cold_1();
  }
}

uint64_t VideoDecoder_NewFormat_SPSPPS(unint64_t a1, char *a2, int *a3, const char *a4, int32_t *a5, int32_t *a6, int a7, int a8, __int16 a9, int a10)
{
  return VideoDecoder_NewFormat_InitDecoder(a1, a2, a3, a4, a5, a6, 1, a7, a8, SHIWORD(a8), a9, a10);
}

uint64_t VideoDecoder_NewFormat_ImgDesc(unint64_t a1, char *a2, uint64_t a3, const char *a4, int32_t *a5, int32_t *a6, int a7, __int16 a8, int a9)
{
  _QWORD v11[2];

  v11[1] = *MEMORY[0x1E0C80C00];
  v11[0] = a3;
  return VideoDecoder_NewFormat_InitDecoder(a1, a2, (int *)v11, a4, a5, a6, 0, 128, a7, SHIWORD(a7), a8, a9);
}

uint64_t VideoDecoder_IsFormatCompatible_SPSPPS(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, int a5, _DWORD *a6, _DWORD *a7)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  size_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  size_t v18;
  _QWORD v20[2];

  v20[1] = *MEMORY[0x1E0C80C00];
  v11 = 2147745824;
  v12 = CheckInHandleDebug();
  if (!v12)
    return 2147745794;
  v13 = v12;
  if (*(_DWORD *)(v12 + 72) == a5 && *(_QWORD *)(v12 + 40) && *(_QWORD *)(v12 + 48))
  {
    v20[0] = *a4 + 64;
    MEMORY[0x1E0C80A78](v12);
    v16 = (v15 + 79) & 0xFFFFFFFFFFFFFFF0;
    v17 = (char *)v20 - v16;
    if (v14)
      memset((char *)v20 - v16, 170, v14);
    if (!(unsigned __int16)gksVCPParseParameterSetsAndCreateConfigurationRecord())
    {
      v18 = *(_QWORD *)(v13 + 48);
      if (v18 == v20[0] && !memcmp(*(const void **)(v13 + 40), v17, v18))
      {
        v11 = 0;
        *a6 = *(_DWORD *)(v13 + 60);
        *a7 = *(_DWORD *)(v13 + 64);
      }
    }
  }
  CheckOutHandleDebug();
  return v11;
}

uint64_t VideoDecoder_IsFormatCompatible_ImgDesc(uint64_t a1, const void *a2, int a3, int a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const void *v10;
  size_t v11;
  BOOL v12;

  v7 = 2147745824;
  v8 = CheckInHandleDebug();
  if (!v8)
    return 2147745794;
  v9 = v8;
  if (*(_DWORD *)(v8 + 72) == a4)
  {
    v10 = *(const void **)(v8 + 40);
    if (v10)
    {
      if (a2)
      {
        v11 = *(_QWORD *)(v9 + 48);
        if (v11)
          v12 = v11 == a3;
        else
          v12 = 0;
        if (v12)
        {
          if (!memcmp(v10, a2, v11))
            v7 = 0;
          else
            v7 = 2147745824;
        }
      }
    }
  }
  CheckOutHandleDebug();
  return v7;
}

uint64_t VideoDecoder_DecodeFrame(uint64_t a1, uint64_t a2, _BYTE *a3, _BYTE *a4, BOOL *a5, const void *a6, __int128 *a7)
{
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  const __CFNumber *v18;
  const __CFNumber *v19;
  const __CFNumber *v20;
  uint64_t v21;
  NSObject *v22;
  NSObject *v23;
  int v24;
  int v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  int v30;
  __int16 v31;
  int v32;
  int v33;
  uint64_t v35;
  NSObject *v36;
  int v38;
  char v39;
  uint64_t v40;
  int valuePtr;
  uint8_t buf[4];
  uint64_t v43;
  __int16 v44;
  const char *v45;
  __int16 v46;
  int v47;
  __int16 v48;
  int v49;
  __int16 v50;
  int v51;
  __int16 v52;
  int v53;
  __int16 v54;
  uint64_t v55;
  __int16 v56;
  uint64_t v57;
  __int16 v58;
  int v59;
  uint64_t v60;

  v60 = *MEMORY[0x1E0C80C00];
  v12 = 2147745794;
  v13 = CheckInHandleDebug();
  if (v13)
  {
    if (!*(_DWORD *)(v13 + 12))
    {
      v12 = 2147745809;
LABEL_33:
      CheckOutHandleDebug();
      return v12;
    }
    v14 = VCMemoryPool_Alloc(*(OSQueueHead **)(v13 + 176));
    v16 = a7[1];
    v15 = a7[2];
    v17 = *a7;
    v14[6] = *((_QWORD *)a7 + 6);
    *((_OWORD *)v14 + 1) = v16;
    *((_OWORD *)v14 + 2) = v15;
    *(_OWORD *)v14 = v17;
    valuePtr = 0;
    v18 = (const __CFNumber *)CMGetAttachment(a6, CFSTR("rtpTimestsamp"), 0);
    if (v18)
    {
      CFNumberGetValue(v18, kCFNumberSInt32Type, &valuePtr);
      *(_DWORD *)v14 = valuePtr;
    }
    v40 = 0;
    v19 = (const __CFNumber *)CMGetAttachment(a6, CFSTR("subFrameIndentifier"), 0);
    if (v19)
    {
      CFNumberGetValue(v19, kCFNumberSInt64Type, &v40);
      v14[2] = v40;
    }
    v39 = 0;
    v20 = (const __CFNumber *)CMGetAttachment(a6, CFSTR("FramePriority"), 0);
    if (v20)
    {
      CFNumberGetValue(v20, kCFNumberSInt8Type, &v39);
      *((_BYTE *)v14 + 45) = 1;
      *((_BYTE *)v14 + 46) = v39;
    }
    kdebug_trace();
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v21 = VRTraceErrorLogLevelToCSTR();
      v22 = *MEMORY[0x1E0CF2758];
      v23 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          v24 = *(_DWORD *)v14;
          v25 = *((unsigned __int8 *)v14 + 42);
          v26 = *((unsigned __int16 *)v14 + 12);
          v27 = HIDWORD(v14[2]);
          v28 = (unsigned __int16)v14[2];
          v29 = *((unsigned __int8 *)v14 + 48);
          *(_DWORD *)buf = 136317186;
          v43 = v21;
          v44 = 2080;
          v45 = "VideoDecoder_DecodeFrame";
          v46 = 1024;
          v47 = 886;
          v48 = 1024;
          v49 = v24;
          v50 = 1024;
          v51 = v25;
          v52 = 1024;
          v53 = v26;
          v54 = 2048;
          v55 = v27;
          v56 = 2048;
          v57 = v28;
          v58 = 1024;
          v59 = v29;
          _os_log_impl(&dword_1D8A54000, v22, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Decode frame with RTPTimestamp=%u, showFrame %d, streamID %d, tileID %llu, decoding order %llu, canStopVideoStall=%d", buf, 0x48u);
        }
      }
      else if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
      {
        VideoDecoder_DecodeFrame_cold_1();
      }
    }
    v30 = VCPDecompressionSessionDecodeFrame();
    v31 = v30;
    v32 = v30 << 16;
    v33 = (__int16)v30;
    if (v30 << 16 <= -587792385)
    {
      if (v32 != -1159593984 && v32 != -846004224)
        goto LABEL_27;
    }
    else if (v32 != -587792384)
    {
      if (!v32)
      {
LABEL_30:
        if (v31)
          v12 = -v33 | 0xA0040000;
        else
          v12 = 0;
        goto LABEL_33;
      }
      if (v32 != -6553600)
      {
LABEL_27:
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v35 = VRTraceErrorLogLevelToCSTR();
          v36 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            v38 = *((unsigned __int16 *)v14 + 12);
            *(_DWORD *)buf = 136316418;
            v43 = v35;
            v44 = 2080;
            v45 = "VideoDecoder_DecodeFrame";
            v46 = 1024;
            v47 = 902;
            v48 = 1024;
            v49 = 902;
            v50 = 1024;
            v51 = v33;
            v52 = 1024;
            v53 = v38;
            _os_log_error_impl(&dword_1D8A54000, v36, OS_LOG_TYPE_ERROR, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/VideoDecoder.c:%d: VCPDecompressionSessionDecodeFrame: error: %d for stream %d", buf, 0x2Eu);
          }
        }
        goto LABEL_30;
      }
    }
    *a3 = 1;
    *a4 = 1;
    *a5 = v32 == -1159593984;
    goto LABEL_27;
  }
  return v12;
}

uint64_t VideoDecoder_GetFormatDescription(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2147745794;
  *a2 = *(_QWORD *)(v3 + 32);
  CheckOutHandleDebug();
  return 0;
}

uint64_t VideoDecoder_GetBufferPool()
{
  if (!CheckInHandleDebug())
    return 2147745794;
  VCPDecompressionSessionCopyProperty();
  CheckOutHandleDebug();
  return 0;
}

uint64_t VideoDecoder_SetShouldEnableFaceZoom()
{
  uint64_t v0;
  uint64_t v1;
  pthread_mutex_t *v2;

  v0 = CheckInHandleDebug();
  if (!v0)
    return 2147745794;
  v1 = v0;
  v2 = (pthread_mutex_t *)(v0 + 112);
  pthread_mutex_lock((pthread_mutex_t *)(v0 + 112));
  if (*(_QWORD *)(v1 + 24))
    VCPDecompressionSessionSetProperty();
  pthread_mutex_unlock(v2);
  CheckOutHandleDebug();
  return 0;
}

uint64_t VideoDecoder_SetShouldEnableMLEnhance(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  pthread_mutex_t *v5;
  uint64_t v6;
  NSObject *v7;
  int v9;
  uint64_t v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v3 = CheckInHandleDebug();
  if (!v3)
    return 2147745794;
  v4 = v3;
  v5 = (pthread_mutex_t *)(v3 + 112);
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 112));
  if (*(_QWORD *)(v4 + 24))
  {
    VCPDecompressionSessionSetProperty();
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v6 = VRTraceErrorLogLevelToCSTR();
      v7 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v9 = 136315906;
        v10 = v6;
        v11 = 2080;
        v12 = "VideoDecoder_SetShouldEnableMLEnhance";
        v13 = 1024;
        v14 = 981;
        v15 = 1024;
        v16 = a2;
        _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d kVCPDecompressionPropertyKey_MLEnhance=%d", (uint8_t *)&v9, 0x22u);
      }
    }
  }
  pthread_mutex_unlock(v5);
  CheckOutHandleDebug();
  return 0;
}

uint64_t VideoDecoder_IsLastSubframe(uint64_t a1, uint64_t a2, int a3, _BYTE *a4)
{
  uint64_t v7;
  int v8;
  __int16 v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  int v14;
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v7 = CheckInHandleDebug();
  if (v7)
  {
    if (a4)
    {
      *a4 = 0;
      if (a2)
      {
        if (*(_QWORD *)(v7 + 24))
        {
          v8 = VCPDecompressionSessionCheckIfLastSubFrame();
          if (v8 << 16)
          {
            v9 = v8;
            v10 = 2147745796;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              v11 = VRTraceErrorLogLevelToCSTR();
              v12 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              {
                v14 = 136316162;
                v15 = v11;
                v16 = 2080;
                v17 = "VideoDecoder_IsLastSubframe";
                v18 = 1024;
                v19 = 1006;
                v20 = 1024;
                v21 = v9;
                v22 = 1024;
                v23 = a3;
                _os_log_error_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_ERROR, " [%s] %s:%d Error: %d calling VCPDecompressionSessionCheckIfLastSubFrame for tileIndex %u", (uint8_t *)&v14, 0x28u);
                v10 = 2147745796;
              }
            }
          }
          else
          {
            v10 = 0;
          }
        }
        else
        {
          v10 = 2147745809;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            {
              VideoDecoder_IsLastSubframe_cold_3();
              v10 = 2147745809;
            }
          }
        }
        goto LABEL_11;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VideoDecoder_IsLastSubframe_cold_2();
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoDecoder_IsLastSubframe_cold_1();
    }
    v10 = 2147745793;
LABEL_11:
    CheckOutHandleDebug();
    return v10;
  }
  return 2147745794;
}

void setIntValue(__CFDictionary *a1, const void *a2, int a3)
{
  CFNumberRef v5;
  int valuePtr;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  valuePtr = a3;
  v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &valuePtr);
  CFDictionarySetValue(a1, a2, v5);
  CFRelease(v5);
}

void OUTLINED_FUNCTION_12_2(uint64_t a1@<X8>)
{
  uint64_t v1;

  *(_QWORD *)(v1 - 8) = a1;
}

void _VCAnsweringMachine_PullAudioSamples(uint64_t a1, uint64_t a2)
{
  int Timestamp;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  unsigned int SampleCount;
  double HostTime;
  unsigned int v10;
  char v11;
  _BOOL4 v12;
  NSObject *v13;
  BOOL v14;
  _QWORD block[6];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  Timestamp = VCAudioBufferList_GetTimestamp(a2);
  v5 = a1 + 200;
  v6 = *(_QWORD *)(a1 + 200);
  if ((*(_BYTE *)(a1 + 216) & 8) == 0)
  {
    if (!v6)
    {
LABEL_5:
      SampleCount = VCAudioBufferList_GetSampleCount(a2);
      HostTime = VCAudioBufferList_GetHostTime(a2);
      VCAudioBufferList_AppendSilence(a2, Timestamp, SampleCount, HostTime);
      goto LABEL_13;
    }
    v7 = *(_DWORD *)(a1 + 208);
    if (v7 < *(_DWORD *)(a1 + 212))
    {
      *(_DWORD *)(a1 + 208) = v7 + 1;
      goto LABEL_5;
    }
    *(_BYTE *)(a1 + 216) |= 8u;
    reportingGenericEvent();
    v6 = *(_QWORD *)v5;
  }
  if (v6)
  {
    v10 = *(_DWORD *)(a1 + 208);
    if (v10 < *(_DWORD *)(a1 + 212))
      *(_DWORD *)(a1 + 208) = v10 + 1;
  }
  v14 = 0;
  v11 = *(_BYTE *)(a1 + 216);
  VCCannedAudioInjector_InjectSamples(v6, a2, 0, &v14);
  v12 = v14;
  *(_BYTE *)(a1 + 216) |= v14;
  if ((v11 & 1) == 0 && v12)
  {
    v13 = *(NSObject **)(a1 + 176);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = ___VCAnsweringMachine_DispatchFinishAnnouncementNotice_block_invoke;
    block[3] = &unk_1E9E52210;
    v16 = 1;
    block[4] = a1;
    block[5] = 0;
    dispatch_async(v13, block);
  }
LABEL_13:
  *(_DWORD *)(v5 + 20) = Timestamp;
  *(float *)(v5 + 24) = VCAudioBufferList_GetAveragePower(a2);
}

void _VCAnsweringMachine_PushAudioSamples(uint64_t a1, unsigned int *a2)
{
  int Timestamp;
  NSObject *v5;
  int v6;
  _QWORD block[5];
  int8x16_t v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  Timestamp = VCAudioBufferList_GetTimestamp((uint64_t)a2);
  *(_DWORD *)(a1 + 244) = Timestamp;
  if ((*(_BYTE *)(a1 + 216) & 3) != 0)
  {
    VCAudioCaptionsCoordinator_PushAudioSamples(*(_QWORD *)(a1 + 232), *(_QWORD *)(a1 + 280), a2);
    if ((*(_BYTE *)(a1 + 240) & 0x10) == 0)
    {
      *(_BYTE *)(a1 + 240) |= 0x10u;
      reportingGenericEvent();
    }
  }
  if ((*(_BYTE *)(a1 + 240) & 0x20) == 0 && (*(_BYTE *)(a1 + 216) & 5) != 0 && *(_QWORD *)(a1 + 256))
  {
    VCMediaRecorder_ClearHistoryBuffer(*(_QWORD *)(a1 + 256));
    *(_BYTE *)(a1 + 240) |= 0x20u;
    v5 = *(NSObject **)(a1 + 176);
    v6 = *(_DWORD *)(a1 + 244);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = ___VCAnsweringMachine_StartMediaRecording_block_invoke;
    block[3] = &unk_1E9E54780;
    block[4] = a1;
    v8 = vextq_s8(*(int8x16_t *)(a1 + 264), *(int8x16_t *)(a1 + 264), 8uLL);
    v9 = v6;
    dispatch_async(v5, block);
  }
  VCMediaRecorder_AddLocalAudioSampleBuffer(*(_QWORD *)(a1 + 256), (uint64_t)a2, Timestamp);
  *(float *)(a1 + 248) = VCAudioBufferList_GetAveragePower((uint64_t)a2);
}

BOOL VCAudioDecoderList_GetDecoderSettings(uint64_t a1, int a2, int a3, _QWORD *a4)
{
  unint64_t v7;
  uint64_t v8;
  _DWORD *v9;
  BOOL v10;
  uint64_t v11;
  NSObject *v12;
  int v14;
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v7 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v7)
  {
    v8 = 0;
    v9 = *(_DWORD **)a1;
    v10 = 1;
    while (*v9 != a2 || v9[1] != a3)
    {
      v10 = ++v8 < v7;
      v9 += 10;
      if (v7 == v8)
        goto LABEL_6;
    }
    *a4 = v9;
  }
  else
  {
LABEL_6:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v11 = VRTraceErrorLogLevelToCSTR();
      v12 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v14 = 136316418;
        v15 = v11;
        v16 = 2080;
        v17 = "VCAudioDecoderList_GetDecoderSettings";
        v18 = 1024;
        v19 = 23;
        v20 = 2048;
        v21 = a1;
        v22 = 1024;
        v23 = a2;
        v24 = 1024;
        v25 = a3;
        _os_log_error_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_ERROR, " [%s] %s:%d Audio decoder (%p) received a packet with unknown payload=%d networkPayload=%d", (uint8_t *)&v14, 0x32u);
      }
    }
    return 0;
  }
  return v10;
}

void VCAudioDecoderList_Cleanup(uint64_t a1)
{
  void *v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  os_log_t *v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  uint8_t buf[4];
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  uint64_t v19;
  __int16 v20;
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v2 = *(void **)a1;
  if (v2)
  {
    v3 = *(unsigned int *)(a1 + 8);
    if ((_DWORD)v3)
    {
      v4 = 0;
      v5 = 8;
      v6 = (os_log_t *)MEMORY[0x1E0CF2758];
      do
      {
        if (*(_QWORD *)(*(_QWORD *)a1 + v5))
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v7 = VRTraceErrorLogLevelToCSTR();
            v8 = *v6;
            if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
            {
              v9 = *(_QWORD *)(*(_QWORD *)a1 + v5);
              *(_DWORD *)buf = 136316418;
              v11 = v7;
              v12 = 2080;
              v13 = "VCAudioDecoderList_Cleanup";
              v14 = 1024;
              v15 = 31;
              v16 = 2048;
              v17 = a1;
              v18 = 2048;
              v19 = v9;
              v20 = 1024;
              v21 = v4;
              _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Found existing audio receiver (%p) decoder (%p) at index %u. Release decoder.", buf, 0x36u);
            }
          }
          SoundDec_Destroy(*(_QWORD *)(*(_QWORD *)a1 + v5));
          v3 = *(unsigned int *)(a1 + 8);
        }
        ++v4;
        v5 += 40;
      }
      while (v4 < v3);
      v2 = *(void **)a1;
    }
    free(v2);
    *(_QWORD *)a1 = 0;
    *(_DWORD *)(a1 + 8) = 0;
  }
}

uint64_t VCAudioDecoderList_SetMagicCookieForPayload(uint64_t a1, int a2, int a3, void *a4, UInt32 a5)
{
  uint64_t result;
  _QWORD v8[2];

  v8[1] = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v8[0] = 0;
    result = VCAudioDecoderList_GetDecoderSettings(a1, a2, a3, v8);
    if ((_DWORD)result)
      return SoundDec_SetMagicCookie(*(_QWORD *)(v8[0] + 8), a4, a5);
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioDecoderList_SetMagicCookieForPayload_cold_1();
    }
    return 56;
  }
  return result;
}

uint64_t VCAudioDecoderList_GetEVSHeaderFormat(uint64_t a1, int a2)
{
  uint64_t result;

  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!(_DWORD)result)
        return result;
      VCAudioDecoderList_GetEVSHeaderFormat_cold_1();
    }
    return 0;
  }
  result = *(unsigned __int8 *)(a1 + 32);
  if (*(_DWORD *)a1 == 98 && a2 == 107 && *(_BYTE *)(a1 + 17))
  {
    if (*(_BYTE *)(a1 + 16))
      return 3;
    else
      return 2;
  }
  return result;
}

uint64_t VCAudioDecoderList_Setup(uint64_t a1, uint64_t *a2)
{
  size_t v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  uint64_t v17;
  NSObject *v18;
  _QWORD *v19;
  int v20;
  float v21;
  __int128 v22;
  uint64_t *v23;
  uint64_t v24;
  _DWORD *v25;
  int EVSHeaderFormat;
  uint64_t v27;
  NSObject *v28;
  int v29;
  int v30;
  int *v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  unint64_t v37;
  uint64_t v38;
  NSObject *v39;
  int v40;
  int v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  NSObject *v45;
  int v46;
  uint64_t v48;
  NSObject *v49;
  uint64_t v50;
  int v51;
  char *v52;
  char *v53;
  uint64_t v54;
  _QWORD *v55;
  _QWORD *v56;
  _QWORD *v57;
  int v58;
  uint8_t v59[4];
  uint64_t v60;
  __int16 v61;
  const char *v62;
  __int16 v63;
  int v64;
  __int16 v65;
  int v66;
  __int16 v67;
  _BYTE v68[10];
  _BYTE v69[6];
  char *v70;
  _BYTE v71[6];
  _BYTE v72[10];
  __int16 v73;
  int v74;
  __int16 v75;
  int v76;
  char v77[16];
  __int128 v78;
  __int128 v79;
  __int128 v80;
  _OWORD __str[4];
  uint8_t buf[40];
  _BYTE v83[48];
  uint64_t v84;

  v84 = *MEMORY[0x1E0C80C00];
  if (!a2)
    return 1;
  v4 = *((unsigned int *)a2 + 2);
  if (!(_DWORD)v4)
  {
    v6 = 0;
    goto LABEL_46;
  }
  v5 = malloc_type_calloc(v4, 0x28uLL, 0x10200404FFF9C0CuLL);
  if (v5)
  {
    v6 = v5;
    if (*((_DWORD *)a2 + 2))
    {
      v54 = a1;
      v7 = 0;
      v8 = 0;
      v55 = 0;
      v56 = 0;
      v9 = -1;
      v57 = v5;
      while (1)
      {
        v58 = 393219;
        v10 = *a2;
        v11 = (uint64_t *)(*a2 + v8);
        v12 = &v6[v7];
        v13 = *v11;
        *v12 = *v11;
        *((_DWORD *)v12 + 8) = *((_DWORD *)v11 + 5);
        *((_BYTE *)v12 + 28) = *((_BYTE *)v11 + 16);
        *((_BYTE *)v12 + 36) = *((_BYTE *)v11 + 25);
        *((_DWORD *)v12 + 5) = *((_DWORD *)v11 + 2);
        v14 = v13;
        if ((int)v13 > 107)
          break;
        if ((_DWORD)v13 != 13)
        {
          if ((_DWORD)v13 == 98)
          {
            if (*(_BYTE *)(v10 + v8 + 17))
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v15 = VRTraceErrorLogLevelToCSTR();
                v16 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 136315650;
                  *(_QWORD *)&buf[4] = v15;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = "VCAudioDecoderList_Setup";
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&buf[24] = 116;
                  _os_log_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Overriding AMR payload with EVS Decoder", buf, 0x1Cu);
                }
                v14 = 107;
                v55 = v12;
                v6 = v57;
                goto LABEL_26;
              }
              v14 = 107;
            }
            else
            {
              v14 = 98;
            }
          }
          goto LABEL_25;
        }
LABEL_26:
        v19 = &v6[v7];
        RTPPayloads_PayloadProperties(0, *((_DWORD *)a2 + 16), (uint64_t)(a2 + 2), *(_DWORD *)(*a2 + v8 + 28), v14, 0, (int *)&v6[v7 + 2], 0, &v58);
        v20 = VCPayloadUtils_CodecSamplesPerFrameWithSampleRate(v14, LODWORD(v6[v7 + 2]));
        v21 = VCPayloadUtils_BlockSizeForPayload(v14, *((unsigned int *)v19 + 4));
        memset(&v83[8], 170, 40);
        *(_QWORD *)v83 = -1;
        memset(buf, 0, sizeof(buf));
        v22 = *((_OWORD *)a2 + 2);
        *(_OWORD *)v83 = *((_OWORD *)a2 + 1);
        *(_OWORD *)&v83[16] = v22;
        *(_QWORD *)&v83[32] = a2[6];
        v83[40] = *((_BYTE *)a2 + 68);
        v83[41] = *((_BYTE *)a2 + 69);
        SoundDec_FormatASBD(v58, (uint64_t)buf, v20, *((_DWORD *)a2 + 11), *(_DWORD *)(*a2 + v8 + 12), v21);
        v23 = v19 + 1;
        v24 = SoundDec_Create(v19 + 1, (uint64_t)buf);
        if ((v24 & 0x80000000) != 0)
        {
          v43 = v24;
          memset(__str, 0, sizeof(__str));
          v79 = 0u;
          v80 = 0u;
          *(_OWORD *)v77 = 0u;
          v78 = 0u;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            v48 = VRTraceErrorLogLevelToCSTR();
            v49 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            {
              v51 = v83[40];
              v52 = FormatToCStr((uint64_t)buf, (char *)__str, 0x40uLL);
              v53 = FormatToCStr((uint64_t)v83, v77, 0x40uLL);
              *(_DWORD *)v59 = 136317186;
              v60 = v48;
              v61 = 2080;
              v62 = "VCAudioDecoderList_Setup";
              v63 = 1024;
              v64 = 134;
              v65 = 1024;
              v66 = v43;
              v67 = 2048;
              *(_QWORD *)v68 = v54;
              *(_WORD *)&v68[8] = 1024;
              *(_DWORD *)v69 = v51;
              *(_WORD *)&v69[4] = 2080;
              v70 = v52;
              *(_WORD *)v71 = 1024;
              *(_DWORD *)&v71[2] = v14;
              *(_WORD *)v72 = 2080;
              *(_QWORD *)&v72[2] = v53;
              _os_log_error_impl(&dword_1D8A54000, v49, OS_LOG_TYPE_ERROR, " [%s] %s:%d SoundDec_Create failed(%08X) for audio receiver (%p). outOfProcess=%{BOOL}d inputFormat=%s payload=%u outputFormat=%s", v59, 0x4Cu);
            }
          }
          if (v8)
          {
            do
            {
              v50 = v9;
              SoundDec_Destroy(v57[5 * v9 + 1]);
              LODWORD(v9) = v9 - 1;
            }
            while (v50);
          }
          free(v57);
          return v43;
        }
        v25 = v19 + 3;
        if ((SoundDec_ShouldRampDownMissingPackets(*v23, (int *)v19 + 6) & 0x80000000) != 0)
          *v25 = 1;
        SoundDec_SetAMRPayloadFormat(*v23, *(unsigned __int8 *)(*a2 + v8 + 16));
        EVSHeaderFormat = VCAudioDecoderList_GetEVSHeaderFormat(*a2 + v8, v14);
        SoundDec_SetEVSFormatHandling(*v23, EVSHeaderFormat);
        SoundDec_SetAACELDPacketLossConcealmentAlgorithm(*v23);
        if (*(_BYTE *)(*a2 + v8 + 25))
        {
          SoundDec_SetOpusInBandFecEnabled(*v23, 1);
          *v25 = 0;
        }
        if ((_DWORD)v14 == 111)
          SoundDec_SetEVSAudioCodecBandwidth(*v23, 0);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
        {
          v27 = VRTraceErrorLogLevelToCSTR();
          v28 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v29 = *((_DWORD *)a2 + 14);
            v30 = *((_DWORD *)a2 + 16);
            v31 = (int *)(*a2 + v8);
            v32 = *((unsigned __int8 *)v31 + 16);
            v33 = *v31;
            v34 = v31[1];
            v36 = v31[2];
            v35 = v31[3];
            LODWORD(v31) = *((unsigned __int8 *)v31 + 17);
            *(_DWORD *)v59 = 136318210;
            v60 = v27;
            v61 = 2080;
            v62 = "VCAudioDecoderList_Setup";
            v63 = 1024;
            v64 = 161;
            v65 = 1024;
            v66 = v29;
            v67 = 1024;
            *(_DWORD *)v68 = v30;
            *(_WORD *)&v68[4] = 1024;
            *(_DWORD *)&v68[6] = v32;
            *(_WORD *)v69 = 1024;
            *(_DWORD *)&v69[2] = v33;
            LOWORD(v70) = 1024;
            *(_DWORD *)((char *)&v70 + 2) = v14;
            HIWORD(v70) = 1024;
            *(_DWORD *)v71 = v34;
            *(_WORD *)&v71[4] = 1024;
            *(_DWORD *)v72 = v35;
            *(_WORD *)&v72[4] = 1024;
            *(_DWORD *)&v72[6] = v36;
            v73 = 1024;
            v74 = (int)v31;
            v75 = 1024;
            v76 = EVSHeaderFormat;
            _os_log_impl(&dword_1D8A54000, v28, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d InternalBlockSize=%d useRTC=%d amrOctetAligned=%d payload=%d selectedPayload=%d networkPayload=%d flags=%d blockSize=%d forceEVSWideBandforAMR=%d headerFormat=%d", v59, 0x58u);
          }
        }
        v12 = v56;
LABEL_37:
        v37 = v9 + 2;
        ++v9;
        v8 += 36;
        v7 += 5;
        v6 = v57;
        if (v37 >= *((unsigned int *)a2 + 2))
        {
          if (v12)
          {
            if (v55)
            {
              *((_BYTE *)v12 + 28) = *((_BYTE *)v55 + 28);
              v12[2] = v55[2];
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v38 = VRTraceErrorLogLevelToCSTR();
                v39 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                {
                  v40 = *((unsigned __int8 *)v12 + 28);
                  v41 = *((_DWORD *)v12 + 4);
                  v42 = *((_DWORD *)v12 + 5);
                  *(_DWORD *)buf = 136316418;
                  *(_QWORD *)&buf[4] = v38;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = "VCAudioDecoderList_Setup";
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&buf[24] = 169;
                  *(_WORD *)&buf[28] = 1024;
                  *(_DWORD *)&buf[30] = v41;
                  *(_WORD *)&buf[34] = 1024;
                  *(_DWORD *)&buf[36] = v40;
                  *(_WORD *)v83 = 1024;
                  *(_DWORD *)&v83[2] = v42;
                  _os_log_impl(&dword_1D8A54000, v39, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Updated DTMF sampleRate=%d isOctedAligned=%d convertedSamples=%d", buf, 0x2Eu);
                }
              }
            }
          }
          a1 = v54;
          goto LABEL_46;
        }
      }
      if ((_DWORD)v13 == 108)
      {
        if (*(_BYTE *)(v10 + v8 + 24))
          v14 = 107;
        else
          v14 = 108;
      }
      else if ((_DWORD)v13 == 117)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v17 = VRTraceErrorLogLevelToCSTR();
          v18 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = v17;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "VCAudioDecoderList_Setup";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 103;
            _os_log_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Skip creating decoder for DTMF", buf, 0x1Cu);
          }
        }
        v56 = v12;
        goto LABEL_37;
      }
LABEL_25:
      v55 = &v6[v7];
      goto LABEL_26;
    }
LABEL_46:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v44 = VRTraceErrorLogLevelToCSTR();
      v45 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v46 = *((_DWORD *)a2 + 2);
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)&buf[4] = v44;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "VCAudioDecoderList_Setup";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 173;
        *(_WORD *)&buf[28] = 2048;
        *(_QWORD *)&buf[30] = a1;
        *(_WORD *)&buf[38] = 1024;
        *(_DWORD *)v83 = v46;
        _os_log_impl(&dword_1D8A54000, v45, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Update audio receiver (%p) decoders: count=%u", buf, 0x2Cu);
      }
    }
    VCAudioDecoderList_Cleanup(a1);
    v43 = 0;
    *(_DWORD *)(a1 + 8) = *((_DWORD *)a2 + 2);
    *(_QWORD *)a1 = v6;
    return v43;
  }
  v43 = 2150105091;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioDecoderList_Setup_cold_1();
  }
  return v43;
}

BOOL VCAudioDecoderList_GetSpeechCodecBundleData(uint64_t a1, int a2, int a3, uint64_t a4)
{
  _BOOL8 result;
  _QWORD v6[2];

  v6[1] = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a4 && *(_QWORD *)a4 && *(_DWORD *)(a4 + 8))
    {
      v6[0] = 0;
      result = VCAudioDecoderList_GetDecoderSettings(a1, a2, a3, v6);
      if (!result)
        return result;
      if ((SoundDec_GetSpeechCodecBundleData(*(_QWORD *)(v6[0] + 8), (uint64_t *)a4) & 0x80000000) == 0)
        return 1;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
        if (!result)
          return result;
        VCAudioDecoderList_GetSpeechCodecBundleData_cold_3();
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      VCAudioDecoderList_GetSpeechCodecBundleData_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    VCAudioDecoderList_GetSpeechCodecBundleData_cold_1();
  }
  return 0;
}

uint64_t VCAudioDecoderList_IsDTXFrame(uint64_t a1, int a2, int a3, uint64_t a4, int a5, _DWORD *a6, _BYTE *a7)
{
  char v9;
  __int128 v15;
  char *v16;
  int v17;
  char v18;
  uint64_t v19;
  NSObject *v20;
  int v22;
  uint64_t v23;
  __int16 v24;
  const char *v25;
  __int16 v26;
  int v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  int v31;
  uint64_t v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  unint64_t v53;
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  if (!a6)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioDecoderList_IsDTXFrame_cold_1();
    }
    goto LABEL_12;
  }
  if (!a7)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioDecoderList_IsDTXFrame_cold_2();
    }
    goto LABEL_12;
  }
  if (a2 != 13)
  {
    if (VCPayloadUtils_supportsInternalDTXForPayload(a2))
    {
      *(_QWORD *)&v15 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v51 = v15;
      v52 = v15;
      v49 = v15;
      v50 = v15;
      v53 = 0xAAAAAAAAAAAAAAAALL;
      v48 = v15;
      v47 = v15;
      v46 = v15;
      v45 = v15;
      v44 = v15;
      v43 = v15;
      v42 = v15;
      v41 = v15;
      v40 = v15;
      v39 = v15;
      v38 = v15;
      v37 = v15;
      v35 = v15;
      v36 = v15;
      v33 = v15;
      v34 = v15;
      v32 = a4;
      LODWORD(v33) = a5;
      if (VCAudioDecoderList_GetSpeechCodecBundleData(a1, a2, a3, (uint64_t)&v32))
      {
        if (DWORD2(v34))
        {
          v16 = (char *)&v32 + 20 * (DWORD2(v34) - 1);
          v17 = *((_DWORD *)v16 + 9);
          LOBYTE(v16) = v16[40];
          v18 = v16 & 1;
          v9 = v16 | (v17 == 0);
          *a6 = v17;
          *a7 = v18;
          return v9 & 1;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v19 = VRTraceErrorLogLevelToCSTR();
          v20 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            v22 = 136316162;
            v23 = v19;
            v24 = 2080;
            v25 = "VCAudioDecoderList_IsDTXFrame";
            v26 = 1024;
            v27 = 229;
            v28 = 2048;
            v29 = a4;
            v30 = 1024;
            v31 = a5;
            _os_log_error_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_ERROR, " [%s] %s:%d No packets in the bundle data [%p, %u]", (uint8_t *)&v22, 0x2Cu);
          }
        }
      }
    }
LABEL_12:
    v9 = 0;
    return v9 & 1;
  }
  v9 = 1;
  return v9 & 1;
}

double _VCConnectionLegacy_SourceDestinationInfo(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  int v4;
  __int16 v5;
  __int128 v6;
  __int128 v7;
  double result;
  __int128 v9;
  _OWORD v10[2];
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a1 + 272);
  v4 = *(_DWORD *)(v3 + 20);
  if (v4)
    v5 = *(_WORD *)(v3 + 26);
  else
    v5 = 0;
  VCSDInfoConstructWithIPPorts(v3 + 28, v3 + 148, v4 != 0, v5, (uint64_t)v10);
  v6 = v14;
  *(_OWORD *)(a2 + 64) = v13;
  *(_OWORD *)(a2 + 80) = v6;
  *(_OWORD *)(a2 + 96) = v15;
  *(_QWORD *)(a2 + 112) = v16;
  v7 = v10[1];
  *(_OWORD *)a2 = v10[0];
  *(_OWORD *)(a2 + 16) = v7;
  result = *(double *)&v11;
  v9 = v12;
  *(_OWORD *)(a2 + 32) = v11;
  *(_OWORD *)(a2 + 48) = v9;
  return result;
}

uint64_t _VCConnectionLegacy_IsLocalOnCellular(uint64_t a1)
{
  return (*(unsigned __int8 *)(*(_QWORD *)(a1 + 272) + 108) >> 2) & 1;
}

uint64_t _VCConnectionLegacy_IsRemoteOnCellular(uint64_t a1)
{
  int v2;
  uint64_t v3;

  v2 = IsIPPORTValid();
  v3 = 68;
  if (!v2)
    v3 = 148;
  return (*(unsigned __int8 *)(*(_QWORD *)(a1 + 272) + v3) >> 2) & 1;
}

uint64_t _VCConnectionLegacy_IsIPv6(uint64_t a1)
{
  return *(_DWORD *)(*(_QWORD *)(a1 + 272) + 108) & 1;
}

BOOL _VCConnectionLegacy_IsRelay(uint64_t a1)
{
  return *(_DWORD *)(*(_QWORD *)(a1 + 272) + 20) != 0;
}

BOOL _VCConnectionLegacy_MatchesSourceDestinationInfo(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  const sockaddr *address;
  int sa_family;
  _BOOL4 v6;
  int v7;
  __int128 v8;
  uint16_t port;
  uint64_t v11;
  int v12;
  _BYTE v13[32];
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)a2 == 5)
  {
    v3 = nw_connection_copy_endpoint(*(nw_connection_t *)(a2 + 8));
    address = nw_endpoint_get_address(v3);
    v11 = 0;
    v12 = 0;
    sa_family = address->sa_family;
    v6 = sa_family == 30;
    if (sa_family == 30)
    {
      v7 = *(_DWORD *)&address->sa_data[6];
      v11 = *(_QWORD *)&address->sa_data[10];
      v12 = *(_DWORD *)&address[1].sa_data[2];
    }
    else
    {
      v7 = 0;
      if (sa_family == 2)
        v7 = *(_DWORD *)&address->sa_data[2];
    }
    port = nw_endpoint_get_port(v3);
    nw_release(v3);
    *(_DWORD *)v13 = v6;
    *(_QWORD *)&v13[12] = 0;
    *(_QWORD *)&v13[4] = 0;
    *(_DWORD *)&v13[20] = v7;
    *(_QWORD *)&v13[24] = v11;
    LODWORD(v14) = v12;
    HIDWORD(v14) = port;
  }
  else
  {
    v8 = *(_OWORD *)(a2 + 64);
    *(_OWORD *)v13 = *(_OWORD *)(a2 + 48);
    *(_OWORD *)&v13[16] = v8;
    v14 = *(_QWORD *)(a2 + 80);
  }
  return VCConnectionLegacy_IsRemoteIPPort(a1, (uint64_t)v13);
}

BOOL _VCConnectionLegacy_Equal(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  int v5;
  BOOL v6;
  int v7;
  int v8;

  v2 = *(_QWORD *)(a1 + 272);
  v3 = *(_DWORD *)(v2 + 20);
  v4 = *(_QWORD *)(a2 + 272);
  v5 = *(_DWORD *)(v4 + 20);
  if (v3)
    v6 = v5 == 0;
  else
    v6 = 1;
  if (v6)
  {
    if (v3 | v5 || (*(_DWORD *)(v2 + 148) & 1) != (*(_DWORD *)(v4 + 148) & 1))
      return 0;
    if ((*(_DWORD *)(v2 + 148) & 1) != 0)
    {
      if (*(_QWORD *)(v2 + 168) != *(_QWORD *)(v4 + 168) || *(_QWORD *)(v2 + 176) != *(_QWORD *)(v4 + 176))
        return 0;
    }
    else if (*(_DWORD *)(v2 + 168) != *(_DWORD *)(v4 + 168))
    {
      return 0;
    }
    if (*(unsigned __int16 *)(v2 + 184) != *(unsigned __int16 *)(v4 + 184)
      || (*(_DWORD *)(v2 + 108) & 1) != (*(_DWORD *)(v4 + 108) & 1))
    {
      return 0;
    }
    if ((*(_DWORD *)(v2 + 108) & 1) != 0)
    {
      if (*(_QWORD *)(v2 + 128) != *(_QWORD *)(v4 + 128) || *(_QWORD *)(v2 + 136) != *(_QWORD *)(v4 + 136))
        return 0;
    }
    else if (*(_DWORD *)(v2 + 128) != *(_DWORD *)(v4 + 128))
    {
      return 0;
    }
    v7 = *(unsigned __int16 *)(v2 + 144);
    v8 = *(unsigned __int16 *)(v4 + 144);
  }
  else
  {
    v7 = *(unsigned __int16 *)(v2 + 26);
    v8 = *(unsigned __int16 *)(v4 + 26);
  }
  return v7 == v8;
}

uint64_t _VCConnectionLegacy_LocalCellTech(uint64_t a1)
{
  uint64_t result;

  result = VCConnection_IsLocalOnCellular(a1);
  if ((_DWORD)result)
    return *(unsigned int *)(*(_QWORD *)(a1 + 272) + 280);
  return result;
}

uint64_t _VCConnectionLegacy_SetLocalCellTech(uint64_t a1, int a2)
{
  uint64_t result;

  result = VCConnection_IsLocalOnCellular(a1);
  if ((_DWORD)result)
    *(_DWORD *)(*(_QWORD *)(a1 + 272) + 280) = a2;
  return result;
}

uint64_t _VCConnectionLegacy_RemoteCellTech(uint64_t a1)
{
  uint64_t result;

  result = VCConnection_IsRemoteOnCellular(a1);
  if ((_DWORD)result)
    return *(unsigned int *)(*(_QWORD *)(a1 + 272) + 284);
  return result;
}

uint64_t _VCConnectionLegacy_SetRemoteCellTech(uint64_t a1, int a2)
{
  uint64_t result;

  result = VCConnection_IsRemoteOnCellular(a1);
  if ((_DWORD)result)
    *(_DWORD *)(*(_QWORD *)(a1 + 272) + 284) = a2;
  return result;
}

CFStringRef _VCConnectionLegacy_CopyDescription(uint64_t a1)
{
  __int128 v2;
  uint64_t v3;
  const __CFAllocator *v4;
  const char *v5;
  const char *v6;
  const char *v7;
  _OWORD v9[16];
  _OWORD v10[16];
  _OWORD v11[16];
  _OWORD v12[16];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v2 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v12[15] = v2;
  v12[14] = v2;
  v12[13] = v2;
  v12[11] = v2;
  v12[12] = v2;
  v12[9] = v2;
  v12[10] = v2;
  v12[7] = v2;
  v12[8] = v2;
  v12[5] = v2;
  v12[6] = v2;
  v12[3] = v2;
  v12[4] = v2;
  v12[1] = v2;
  v12[2] = v2;
  v11[15] = v2;
  v12[0] = v2;
  v11[13] = v2;
  v11[14] = v2;
  v11[11] = v2;
  v11[12] = v2;
  v11[9] = v2;
  v11[10] = v2;
  v11[7] = v2;
  v11[8] = v2;
  v11[5] = v2;
  v11[6] = v2;
  v11[3] = v2;
  v11[4] = v2;
  v11[1] = v2;
  v11[2] = v2;
  v10[15] = v2;
  v11[0] = v2;
  v10[13] = v2;
  v10[14] = v2;
  v10[11] = v2;
  v10[12] = v2;
  v10[9] = v2;
  v10[10] = v2;
  v10[7] = v2;
  v10[8] = v2;
  v10[5] = v2;
  v10[6] = v2;
  v10[3] = v2;
  v10[4] = v2;
  v10[1] = v2;
  v10[2] = v2;
  v9[15] = v2;
  v10[0] = v2;
  v9[13] = v2;
  v9[14] = v2;
  v9[11] = v2;
  v9[12] = v2;
  v9[9] = v2;
  v9[10] = v2;
  v9[7] = v2;
  v9[8] = v2;
  v9[5] = v2;
  v9[6] = v2;
  v9[3] = v2;
  v9[4] = v2;
  v9[1] = v2;
  v9[2] = v2;
  v3 = *(_QWORD *)(a1 + 272) + 28;
  v9[0] = v2;
  _VCConnectionLegacy_IPPortToString(v3, (char *)v12);
  _VCConnectionLegacy_IPPortToString(*(_QWORD *)(a1 + 272) + 108, (char *)v11);
  _VCConnectionLegacy_IPPortToString(*(_QWORD *)(a1 + 272) + 148, (char *)v10);
  _VCConnectionLegacy_IPPortToString(*(_QWORD *)(a1 + 272) + 68, (char *)v9);
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (VCConnection_IsRelay(a1))
    v5 = "RELAY";
  else
    v5 = "NOT RELAY";
  if (VCConnection_IsLocalOnWiFi(a1))
    v6 = "WiFi";
  else
    v6 = "Cell";
  if (VCConnection_IsRemoteOnWiFi(a1))
    v7 = "WiFi";
  else
    v7 = "Cell";
  return CFStringCreateWithFormat(v4, 0, CFSTR("[%s %s(%s)<>%s<===>%s<>%s(%s)]"), v5, v12, v6, v11, v10, v9, v7);
}

BOOL _VCConnectionLegacy_IsLocalOnWiFiOrWired(uint64_t a1)
{
  return (*(_BYTE *)(*(_QWORD *)(a1 + 272) + 108) & 4) == 0;
}

BOOL _VCConnectionLegacy_IsRemoteOnWiFiOrWired(uint64_t a1)
{
  int v2;
  uint64_t v3;

  v2 = IsIPPORTValid();
  v3 = 68;
  if (!v2)
    v3 = 148;
  return (*(_BYTE *)(*(_QWORD *)(a1 + 272) + v3) & 4) == 0;
}

BOOL _VCConnectionLegacy_IsLocalOnWiFi(uint64_t a1)
{
  return (*(_BYTE *)(*(_QWORD *)(a1 + 272) + 108) & 4) == 0;
}

BOOL _VCConnectionLegacy_IsRemoteOnWiFi(uint64_t a1)
{
  int v2;
  uint64_t v3;

  v2 = IsIPPORTValid();
  v3 = 68;
  if (!v2)
    v3 = 148;
  return (*(_BYTE *)(*(_QWORD *)(a1 + 272) + v3) & 4) == 0;
}

BOOL _VCConnectionLegacy_IsLocalOnWired(uint64_t a1)
{
  return (*(_BYTE *)(*(_QWORD *)(a1 + 272) + 108) & 4) == 0;
}

BOOL _VCConnectionLegacy_IsRemoteOnWired(uint64_t a1)
{
  int v2;
  uint64_t v3;

  v2 = IsIPPORTValid();
  v3 = 68;
  if (!v2)
    v3 = 148;
  return (*(_BYTE *)(*(_QWORD *)(a1 + 272) + v3) & 4) == 0;
}

uint64_t _VCConnectionLegacy_IsOnSameInterfacesWithConnection(_QWORD *a1, void *a2)
{
  uint64_t v4;
  int ErrorLogLevelForModule;
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  uint64_t v12;
  int IsLocalOnWiFi;
  int IsRemoteOnWiFi;
  uint64_t v15;
  NSObject *v16;
  NSObject *v17;
  int v19;
  uint64_t v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  uint64_t v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v4 = a1[34];
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (!a2 || !v4)
  {
    if (ErrorLogLevelForModule >= 8)
    {
      v9 = VRTraceErrorLogLevelToCSTR();
      v10 = *MEMORY[0x1E0CF2758];
      v11 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        v12 = 0;
        if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          return v12;
        v19 = 136315650;
        v20 = v9;
        v21 = 2080;
        v22 = "_VCConnectionLegacy_IsOnSameInterfacesWithConnection";
        v23 = 1024;
        v24 = 216;
        _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCConnection: isOnSameInterfacesWithConnection: NO", (uint8_t *)&v19, 0x1Cu);
      }
      else if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        _VCConnectionLegacy_IsOnSameInterfacesWithConnection_cold_2();
      }
    }
    return 0;
  }
  if (ErrorLogLevelForModule >= 8)
  {
    v6 = VRTraceErrorLogLevelToCSTR();
    v7 = *MEMORY[0x1E0CF2758];
    v8 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        v19 = 136316162;
        v20 = v6;
        v21 = 2080;
        v22 = "_VCConnectionLegacy_IsOnSameInterfacesWithConnection";
        v23 = 1024;
        v24 = 220;
        v25 = 2080;
        v26 = objc_msgSend((id)objc_msgSend(a1, "description"), "UTF8String");
        v27 = 2080;
        v28 = objc_msgSend((id)objc_msgSend(a2, "description"), "UTF8String");
        _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCConnection: isOnSameInterfacesWithConnection: %s vs. %s", (uint8_t *)&v19, 0x30u);
      }
    }
    else if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      v19 = 136316162;
      v20 = v6;
      v21 = 2080;
      v22 = "_VCConnectionLegacy_IsOnSameInterfacesWithConnection";
      v23 = 1024;
      v24 = 220;
      v25 = 2080;
      v26 = objc_msgSend((id)objc_msgSend(a1, "description"), "UTF8String");
      v27 = 2080;
      v28 = objc_msgSend((id)objc_msgSend(a2, "description"), "UTF8String");
      _os_log_debug_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEBUG, " [%s] %s:%d VCConnection: isOnSameInterfacesWithConnection: %s vs. %s", (uint8_t *)&v19, 0x30u);
    }
  }
  IsLocalOnWiFi = VCConnection_IsLocalOnWiFi((uint64_t)a1);
  if (IsLocalOnWiFi == VCConnection_IsLocalOnWiFi((uint64_t)a2))
  {
    IsRemoteOnWiFi = VCConnection_IsRemoteOnWiFi((uint64_t)a1);
    v12 = IsRemoteOnWiFi ^ VCConnection_IsRemoteOnWiFi((uint64_t)a2) ^ 1;
  }
  else
  {
    v12 = 0;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v15 = VRTraceErrorLogLevelToCSTR();
    v16 = *MEMORY[0x1E0CF2758];
    v17 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        v19 = 136315906;
        v20 = v15;
        v21 = 2080;
        v22 = "_VCConnectionLegacy_IsOnSameInterfacesWithConnection";
        v23 = 1024;
        v24 = 223;
        v25 = 1024;
        LODWORD(v26) = v12;
        _os_log_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCConnection: isOnSameInterfacesWithConnection: %{BOOL}d", (uint8_t *)&v19, 0x22u);
      }
    }
    else if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
    {
      _VCConnectionLegacy_IsOnSameInterfacesWithConnection_cold_1(v15, v12, v16);
    }
  }
  return v12;
}

uint64_t _VCConnectionLegacy_IsEndToEndLink()
{
  return 1;
}

uint64_t _VCConnectionLegacy_ConnectionID(uint64_t a1)
{
  return *(unsigned int *)(*(_QWORD *)(a1 + 272) + 4);
}

uint64_t _VCConnectionLegacy_IsLocalExpensive()
{
  return 0;
}

uint64_t _VCConnectionLegacy_IsLocalConstrained()
{
  return 0;
}

uint64_t _VCConnectionLegacy_IsRemoteExpensive()
{
  return 0;
}

uint64_t _VCConnectionLegacy_IsRemoteConstrained()
{
  return 0;
}

uint64_t _VCConnectionLegacy_ReportingIPVersion(uint64_t a1)
{
  if ((*(_BYTE *)(*(_QWORD *)(a1 + 272) + 108) & 1) != 0)
    return 3;
  else
    return 1;
}

uint64_t _VCConnectionLegacy_ReportingQRServerConfig()
{
  return 0;
}

uint64_t _VCConnectionLegacy_IsHopByHopEncryptionSupported()
{
  return 0;
}

BOOL VCConnectionLegacy_IsRemoteIPPort(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  NSObject *v7;
  _BOOL8 v8;
  const char *v9;
  NSObject *v10;
  uint32_t v11;
  uint64_t v12;
  NSObject *v13;
  NSObject *v14;
  uint64_t v17;
  NSObject *v18;
  NSObject *v19;
  const char *v20;
  int v22;
  uint64_t v23;
  __int16 v24;
  const char *v25;
  __int16 v26;
  int v27;
  __int16 v28;
  const char *v29;
  __int16 v30;
  uint64_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if (!a1 || !a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 5)
      return 0;
    v6 = VRTraceErrorLogLevelToCSTR();
    v7 = *MEMORY[0x1E0CF2758];
    v8 = 0;
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      return v8;
    v22 = 136316162;
    v23 = v6;
    v24 = 2080;
    v25 = "VCConnectionLegacy_IsRemoteIPPort";
    v26 = 1024;
    v27 = 170;
    v28 = 2048;
    v29 = (const char *)a1;
    v30 = 2048;
    v31 = a2;
    v9 = " [%s] %s:%d nil instance=%p or remoteIPPort=%p passed";
    v10 = v7;
    v11 = 48;
LABEL_11:
    _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v22, v11);
    return 0;
  }
  v4 = *(_QWORD *)(a1 + 272);
  if (!v4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 8)
      return 0;
    v12 = VRTraceErrorLogLevelToCSTR();
    v13 = *MEMORY[0x1E0CF2758];
    v14 = *MEMORY[0x1E0CF2758];
    if (!*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
        VCConnectionLegacy_IsRemoteIPPort_cold_1();
      return 0;
    }
    v8 = 0;
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      return v8;
    v22 = 136315650;
    v23 = v12;
    v24 = 2080;
    v25 = "VCConnectionLegacy_IsRemoteIPPort";
    v26 = 1024;
    v27 = 174;
    v9 = " [%s] %s:%d VCConnection: isRemoteIPPort: NO";
    v10 = v13;
    v11 = 28;
    goto LABEL_11;
  }
  v5 = *(_DWORD *)a2 & 1;
  if ((*(_DWORD *)(v4 + 68) & 1) != v5)
    goto LABEL_23;
  if ((*(_DWORD *)(v4 + 68) & 1) != 0)
  {
    if (*(_QWORD *)(v4 + 88) != *(_QWORD *)(a2 + 20) || *(_QWORD *)(v4 + 96) != *(_QWORD *)(a2 + 28))
      goto LABEL_23;
  }
  else if (*(_DWORD *)(v4 + 88) != *(_DWORD *)(a2 + 20))
  {
    goto LABEL_23;
  }
  if (*(unsigned __int16 *)(v4 + 104) == *(unsigned __int16 *)(a2 + 36))
  {
    v8 = 1;
    goto LABEL_32;
  }
LABEL_23:
  if ((*(_DWORD *)(v4 + 188) & 1) == v5)
  {
    if (v5)
    {
      if (*(_QWORD *)(v4 + 208) == *(_QWORD *)(a2 + 20) && *(_QWORD *)(v4 + 216) == *(_QWORD *)(a2 + 28))
        goto LABEL_26;
    }
    else if (*(_DWORD *)(v4 + 208) == *(_DWORD *)(a2 + 20))
    {
LABEL_26:
      v8 = *(unsigned __int16 *)(v4 + 224) == *(unsigned __int16 *)(a2 + 36);
      goto LABEL_32;
    }
  }
  v8 = 0;
LABEL_32:
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v17 = VRTraceErrorLogLevelToCSTR();
    v18 = *MEMORY[0x1E0CF2758];
    v19 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        v20 = "NO";
        v23 = v17;
        v22 = 136315906;
        v25 = "VCConnectionLegacy_IsRemoteIPPort";
        v24 = 2080;
        if (v8)
          v20 = "YES";
        v26 = 1024;
        v27 = 180;
        v28 = 2080;
        v29 = v20;
        _os_log_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCConnection: isRemoteIPPort: %s", (uint8_t *)&v22, 0x26u);
      }
    }
    else if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      VCConnectionLegacy_IsRemoteIPPort_cold_2(v17);
    }
  }
  return v8;
}

uint64_t _VCConnectionLegacy_IPPortToString(uint64_t a1, char *a2)
{
  __int128 v4;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  char v14[16];
  _BYTE v15[30];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v15[14] = v4;
  *(_OWORD *)v14 = v4;
  *(_OWORD *)v15 = v4;
  v12 = 0u;
  v13 = 0u;
  v10 = 0u;
  v11 = 0u;
  v8 = 0u;
  v9 = 0u;
  v6 = 0u;
  v7 = 0u;
  FillSockAddrStorage();
  return snprintf(a2, 0x100uLL, "%s:%d", v14, *(unsigned __int16 *)(a1 + 36));
}

uint64_t _VideoReceiver_UpdateMediaControlInfo(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int Version;
  _BOOL4 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;

  v1 = a1;
  v2 = a1 + 41536;
  v3 = (uint64_t *)(a1 + 40648);
  v4 = a1 + 40356;
  if (a1)
  {
    v5 = *(_QWORD *)(a1 + 40360);
    if (!v5 || (a1 = *(_QWORD *)(v5 + 80)) == 0)
      a1 = *v3;
  }
  Version = VCMediaControlInfoGeneratorGetVersion(a1);
  if (*(_BYTE *)(v1 + 1187))
    v7 = 1;
  else
    v7 = *(_DWORD *)v4 == 0;
  if (Version <= 1)
    v7 = 0;
  *(_DWORD *)v2 = v7;
  v8 = *(_QWORD *)(v4 + 4);
  if (!v8 || (v9 = *(_QWORD *)(v8 + 80)) == 0)
    v9 = *v3;
  result = VCMediaControlInfoGeneratorGetFECFeedbackVersion(v9);
  *(_BYTE *)(v2 + 12) = result;
  return result;
}

void _VideoReceiver_DecoderCallback(uint64_t a1, __CVBuffer *a2, __int128 *a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CFTypeRef Attachment;
  double Width;
  double Height;
  uint64_t v16;
  NSObject *v17;
  double v18;
  uint64_t v19;
  uint64_t v20;
  NSObject *v21;
  NSObject *v22;
  int v23;
  int v24;
  const __CFAllocator *v25;
  int v26;
  int v27;
  uint64_t v28;
  NSObject *v29;
  NSObject *v30;
  int v31;
  int v32;
  int v33;
  uint64_t v34;
  int v35;
  int v36;
  unsigned int *Stream;
  uint64_t v38;
  double v39;
  double v40;
  int IsSafeViewMode;
  int v42;
  int v43;
  unsigned int v44;
  int ErrorLogLevelForModule;
  uint64_t v46;
  NSObject *v47;
  uint64_t v48;
  NSObject *v49;
  uint64_t v50;
  NSObject *v51;
  NSObject *v52;
  NSObject *v53;
  NSObject *v54;
  double v55;
  void (*v56)(_QWORD, uint64_t);
  uint64_t v57;
  NSObject *v58;
  int v59;
  uint64_t v60;
  NSObject *v61;
  NSObject *v62;
  int v63;
  int v64;
  const __CFAllocator **v65;
  char v66;
  BOOL v67;
  unsigned int v68;
  _BYTE buf[24];
  __int128 v70;
  _OWORD v71[8];
  uint64_t v72;

  v72 = *MEMORY[0x1E0C80C00];
  v66 = 1;
  v8 = CheckInHandleDebug();
  if (v8)
  {
    v9 = v8;
    v10 = v8 + 40824;
    v11 = v8 + 40384;
    ++*(_WORD *)(v8 + 41036);
    Attachment = CVBufferGetAttachment(a2, CFSTR("FrameMLEnahnced"), 0);
    if (Attachment && CFEqual(Attachment, (CFTypeRef)*MEMORY[0x1E0C9AE50]))
      ++*(_WORD *)(v10 + 214);
    Width = (double)CVPixelBufferGetWidth(a2);
    Height = (double)CVPixelBufferGetHeight(a2);
    if (*(double *)v10 != Width || *(double *)(v10 + 8) != Height)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v16 = VRTraceErrorLogLevelToCSTR();
        v17 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v18 = *(double *)v10;
          v19 = *(_QWORD *)(v10 + 8);
          *(_DWORD *)buf = 136316674;
          *(_QWORD *)&buf[4] = v16;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VideoReceiver_DecoderCallback";
          *(_WORD *)&buf[22] = 1024;
          LODWORD(v70) = 648;
          WORD2(v70) = 2048;
          *(double *)((char *)&v70 + 6) = v18;
          HIWORD(v70) = 2048;
          *(_QWORD *)&v71[0] = v19;
          WORD4(v71[0]) = 2048;
          *(double *)((char *)v71 + 10) = Width;
          WORD1(v71[1]) = 2048;
          *(double *)((char *)&v71[1] + 4) = Height;
          _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d decoded frame size changed from %fx%f to %fx%f", buf, 0x44u);
        }
      }
      *(double *)v10 = Width;
      *(double *)(v10 + 8) = Height;
    }
    *(_DWORD *)(v11 + 288) += VideoUtil_GetDecodedFrameSEINaluOverheadBytes(a2);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v20 = VRTraceErrorLogLevelToCSTR();
      v21 = *MEMORY[0x1E0CF2758];
      v22 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          v23 = *(_DWORD *)a3;
          v24 = *((unsigned __int8 *)a3 + 48);
          *(_DWORD *)buf = 136316418;
          *(_QWORD *)&buf[4] = v20;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VideoReceiver_DecoderCallback";
          *(_WORD *)&buf[22] = 1024;
          LODWORD(v70) = 654;
          WORD2(v70) = 2048;
          *(_QWORD *)((char *)&v70 + 6) = v9;
          HIWORD(v70) = 1024;
          LODWORD(v71[0]) = v23;
          WORD2(v71[0]) = 1024;
          *(_DWORD *)((char *)v71 + 6) = v24;
          _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] RTPTimestamp=%u canStopVideoStall=%d", buf, 0x32u);
        }
      }
      else if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
      {
        v35 = *(_DWORD *)a3;
        v36 = *((unsigned __int8 *)a3 + 48);
        *(_DWORD *)buf = 136316418;
        *(_QWORD *)&buf[4] = v20;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VideoReceiver_DecoderCallback";
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v70) = 654;
        WORD2(v70) = 2048;
        *(_QWORD *)((char *)&v70 + 6) = v9;
        HIWORD(v70) = 1024;
        LODWORD(v71[0]) = v35;
        WORD2(v71[0]) = 1024;
        *(_DWORD *)((char *)v71 + 6) = v36;
        _os_log_debug_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEBUG, "VideoReceiver [%s] %s:%d VideoReceiver[%p] RTPTimestamp=%u canStopVideoStall=%d", buf, 0x32u);
      }
    }
    v65 = 0;
    v25 = *(const __CFAllocator **)(v10 + 584);
    *(_OWORD *)buf = *(_OWORD *)a4;
    *(_QWORD *)&buf[16] = *(_QWORD *)(a4 + 16);
    if (!VCVideoReceiverDecodedFrame_Create(v25, &v65, 0, a2, a3, (__int128 *)buf))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v57 = VRTraceErrorLogLevelToCSTR();
        v58 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v59 = *(_DWORD *)a3;
          *(_DWORD *)buf = 136316162;
          *(_QWORD *)&buf[4] = v57;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VideoReceiver_DecoderCallback";
          *(_WORD *)&buf[22] = 1024;
          LODWORD(v70) = 658;
          WORD2(v70) = 2048;
          *(_QWORD *)((char *)&v70 + 6) = v9;
          HIWORD(v70) = 1024;
          LODWORD(v71[0]) = v59;
          _os_log_error_impl(&dword_1D8A54000, v58, OS_LOG_TYPE_ERROR, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Unable to create VCVideoReceiverDecodedFrame for frame with timestamp=%u", buf, 0x2Cu);
        }
      }
      goto LABEL_27;
    }
    if (!v65 || !*((_BYTE *)a3 + 50) || *((_BYTE *)a3 + 43))
    {
LABEL_26:
      if (!_VideoReceiver_EnqueueDecodedFrameForDisplay(a1, v9, (int *)a3, (uint64_t *)&v65, &v66)
        && (int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v60 = VRTraceErrorLogLevelToCSTR();
        v61 = *MEMORY[0x1E0CF2758];
        v62 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
          {
            v63 = *(_DWORD *)a3;
            *(_DWORD *)buf = 136316162;
            *(_QWORD *)&buf[4] = v60;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VideoReceiver_DecoderCallback";
            *(_WORD *)&buf[22] = 1024;
            LODWORD(v70) = 668;
            WORD2(v70) = 2048;
            *(_QWORD *)((char *)&v70 + 6) = v9;
            HIWORD(v70) = 1024;
            LODWORD(v71[0]) = v63;
            _os_log_impl(&dword_1D8A54000, v61, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Unable to enqueue frame for display. timestamp=%u", buf, 0x2Cu);
          }
        }
        else if (os_log_type_enabled(v62, OS_LOG_TYPE_DEBUG))
        {
          v64 = *(_DWORD *)a3;
          *(_DWORD *)buf = 136316162;
          *(_QWORD *)&buf[4] = v60;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VideoReceiver_DecoderCallback";
          *(_WORD *)&buf[22] = 1024;
          LODWORD(v70) = 668;
          WORD2(v70) = 2048;
          *(_QWORD *)((char *)&v70 + 6) = v9;
          HIWORD(v70) = 1024;
          LODWORD(v71[0]) = v64;
          _os_log_debug_impl(&dword_1D8A54000, v61, OS_LOG_TYPE_DEBUG, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Unable to enqueue frame for display. timestamp=%u", buf, 0x2Cu);
        }
      }
LABEL_27:
      _VideoReceiver_CheckAndRequestKeyFrame(v9, (uint64_t)v65);
      if (v65)
      {
        if (v66)
          VCVideoReceiverDecodedFrame_Destroy(&v65);
      }
      CheckOutHandleDebug();
      return;
    }
    v26 = *(unsigned __int8 *)(v10 + 368);
    if (*(_BYTE *)(v10 + 368))
      v27 = 7;
    else
      v27 = 8;
    if (v27 <= (int)VRTraceGetErrorLogLevelForModule())
    {
      v28 = VRTraceErrorLogLevelToCSTR();
      if (v26)
      {
        v29 = *MEMORY[0x1E0CF2758];
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          goto LABEL_44;
LABEL_41:
        v31 = *((_DWORD *)a3 + 13);
        v32 = *((unsigned __int16 *)a3 + 12);
        v33 = *((unsigned __int8 *)a3 + 47);
        v34 = *((_QWORD *)a3 + 4);
        *(_DWORD *)buf = 136316674;
        *(_QWORD *)&buf[4] = v28;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VideoReceiver_DecoderCallback";
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v70) = 662;
        WORD2(v70) = 1024;
        *(_DWORD *)((char *)&v70 + 6) = v31;
        WORD5(v70) = 1024;
        HIDWORD(v70) = v32;
        LOWORD(v71[0]) = 1024;
        *(_DWORD *)((char *)v71 + 2) = v33;
        WORD3(v71[0]) = 2048;
        *((_QWORD *)&v71[0] + 1) = v34;
        _os_log_impl(&dword_1D8A54000, v29, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d Sending LTR ACK with timestamp=%d decodedargs->streamID=%u, decodedargs->isOneToOne=%u streamToken=%ld", buf, 0x38u);
        goto LABEL_44;
      }
      v29 = *MEMORY[0x1E0CF2758];
      v30 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (!os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
          goto LABEL_44;
        goto LABEL_41;
      }
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
        _VideoReceiver_DecoderCallback_cold_2();
    }
LABEL_44:
    Stream = _VideoReceiver_GetStream((unsigned int *)v9, *((unsigned __int16 *)a3 + 12), *((unsigned __int8 *)a3 + 47));
    v38 = *((unsigned int *)a3 + 13);
    v39 = micro();
    v68 = v38;
    if (!(_DWORD)v38)
      goto LABEL_26;
    v40 = v39;
    v67 = 0;
    IsSafeViewMode = VideoTransmitter_IsSafeViewMode(*(_QWORD *)v11, &v67);
    v42 = *(unsigned __int8 *)(v10 + 368);
    if (v42)
      v43 = 7;
    else
      v43 = 8;
    if ((IsSafeViewMode & 0x80000000) == 0 && v67 || *((_BYTE *)Stream + 102))
    {
      v44 = Stream[26];
      ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
      if (v44 == 2)
      {
        if (v43 <= ErrorLogLevelForModule)
        {
          v46 = VRTraceErrorLogLevelToCSTR();
          if (v42)
          {
            v47 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
LABEL_66:
              *(_DWORD *)buf = 136316162;
              *(_QWORD *)&buf[4] = v46;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_VideoReceiver_SendLTRACK";
              *(_WORD *)&buf[22] = 1024;
              LODWORD(v70) = 2440;
              WORD2(v70) = 2048;
              *(_QWORD *)((char *)&v70 + 6) = v9;
              HIWORD(v70) = 1024;
              LODWORD(v71[0]) = v38;
              _os_log_impl(&dword_1D8A54000, v47, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Received RTCP request to send PSFB LTRP ACK for timestamp=%u", buf, 0x2Cu);
            }
          }
          else
          {
            v47 = *MEMORY[0x1E0CF2758];
            v52 = *MEMORY[0x1E0CF2758];
            if (!*MEMORY[0x1E0CF2748])
            {
              if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 136316162;
                *(_QWORD *)&buf[4] = v46;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "_VideoReceiver_SendLTRACK";
                *(_WORD *)&buf[22] = 1024;
                LODWORD(v70) = 2440;
                WORD2(v70) = 2048;
                *(_QWORD *)((char *)&v70 + 6) = v9;
                HIWORD(v70) = 1024;
                LODWORD(v71[0]) = v38;
                _os_log_debug_impl(&dword_1D8A54000, v47, OS_LOG_TYPE_DEBUG, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Received RTCP request to send PSFB LTRP ACK for timestamp=%u", buf, 0x2Cu);
              }
              goto LABEL_75;
            }
            if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
              goto LABEL_66;
          }
        }
LABEL_75:
        _VideoReceiver_SendRTCPResiliencyInfo(v9, (uint64_t)Stream, v38, 1, 0, 0, v40);
        goto LABEL_26;
      }
      if (v43 <= ErrorLogLevelForModule)
      {
        v48 = VRTraceErrorLogLevelToCSTR();
        if (v42)
        {
          v49 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
LABEL_69:
            *(_DWORD *)buf = 136316162;
            *(_QWORD *)&buf[4] = v48;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VideoReceiver_SendLTRACK";
            *(_WORD *)&buf[22] = 1024;
            LODWORD(v70) = 2443;
            WORD2(v70) = 2048;
            *(_QWORD *)((char *)&v70 + 6) = v9;
            HIWORD(v70) = 1024;
            LODWORD(v71[0]) = v38;
            _os_log_impl(&dword_1D8A54000, v49, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Sending RTCP APP LTRP ACK for timestamp=%u", buf, 0x2Cu);
          }
        }
        else
        {
          v49 = *MEMORY[0x1E0CF2758];
          v53 = *MEMORY[0x1E0CF2758];
          if (!*MEMORY[0x1E0CF2748])
          {
            if (os_log_type_enabled(v53, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136316162;
              *(_QWORD *)&buf[4] = v48;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_VideoReceiver_SendLTRACK";
              *(_WORD *)&buf[22] = 1024;
              LODWORD(v70) = 2443;
              WORD2(v70) = 2048;
              *(_QWORD *)((char *)&v70 + 6) = v9;
              HIWORD(v70) = 1024;
              LODWORD(v71[0]) = v38;
              _os_log_debug_impl(&dword_1D8A54000, v49, OS_LOG_TYPE_DEBUG, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Sending RTCP APP LTRP ACK for timestamp=%u", buf, 0x2Cu);
            }
            goto LABEL_78;
          }
          if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
            goto LABEL_69;
        }
      }
LABEL_78:
      v68 = bswap32(v38);
      memset(v71, 0, sizeof(v71));
      v70 = 0u;
      *(_QWORD *)buf = 0x500000002;
      *(_QWORD *)&buf[8] = &v68;
      *(_QWORD *)&buf[16] = 4;
      v55 = micro();
      _VideoReceiver_SendRTCP(v9, (uint64_t)Stream, (__int128 *)buf, 0, v55);
      ++Stream[1067];
      goto LABEL_26;
    }
    if (v43 <= (int)VRTraceGetErrorLogLevelForModule())
    {
      v50 = VRTraceErrorLogLevelToCSTR();
      if (v42)
      {
        v51 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
LABEL_72:
          *(_DWORD *)buf = 136316162;
          *(_QWORD *)&buf[4] = v50;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VideoReceiver_SendLTRACK";
          *(_WORD *)&buf[22] = 1024;
          LODWORD(v70) = 2456;
          WORD2(v70) = 2048;
          *(_QWORD *)((char *)&v70 + 6) = v9;
          HIWORD(v70) = 1024;
          LODWORD(v71[0]) = v38;
          _os_log_impl(&dword_1D8A54000, v51, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Sending VideoTransmitter LTRP ACK for %d", buf, 0x2Cu);
        }
      }
      else
      {
        v51 = *MEMORY[0x1E0CF2758];
        v54 = *MEMORY[0x1E0CF2758];
        if (!*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136316162;
            *(_QWORD *)&buf[4] = v50;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VideoReceiver_SendLTRACK";
            *(_WORD *)&buf[22] = 1024;
            LODWORD(v70) = 2456;
            WORD2(v70) = 2048;
            *(_QWORD *)((char *)&v70 + 6) = v9;
            HIWORD(v70) = 1024;
            LODWORD(v71[0]) = v38;
            _os_log_debug_impl(&dword_1D8A54000, v51, OS_LOG_TYPE_DEBUG, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Sending VideoTransmitter LTRP ACK for %d", buf, 0x2Cu);
          }
          goto LABEL_81;
        }
        if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
          goto LABEL_72;
      }
    }
LABEL_81:
    v56 = *(void (**)(_QWORD, uint64_t))(v9 + 1424);
    if (v56)
      v56(*(_QWORD *)(v9 + 1416), v38);
    VideoTransmitter_SendLTRACK(*(_QWORD *)v11, v38);
    goto LABEL_26;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VideoReceiver_DecoderCallback_cold_1();
  }
}

unsigned int *_VideoReceiver_GetStream(unsigned int *a1, int a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  unsigned int *v7;
  unsigned int *result;
  uint64_t v9;
  unsigned int *v10;
  uint64_t v11;
  NSObject *v12;
  int v13;
  uint64_t v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  unsigned int *v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v5 = *a1;
  if (!(_DWORD)v5)
  {
LABEL_13:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v11 = VRTraceErrorLogLevelToCSTR();
      v12 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v13 = 136316162;
        v14 = v11;
        v15 = 2080;
        v16 = "_VideoReceiver_GetStream";
        v17 = 1024;
        v18 = 1441;
        v19 = 2048;
        v20 = a1;
        v21 = 1024;
        v22 = a2;
        _os_log_error_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_ERROR, "VideoReceiver [%s] %s:%d VideoReceiver[%p] unknown streamID:%d", (uint8_t *)&v13, 0x2Cu);
      }
    }
    return 0;
  }
  v6 = 0;
  v7 = a1 + 367;
  while (1)
  {
    result = &a1[1080 * v6 + 364];
    if (a3)
    {
      if (BYTE1(a1[1080 * v6 + 381]))
        return result;
      goto LABEL_12;
    }
    if (*(unsigned __int16 *)result == a2 || HIWORD(a1[1080 * v6 + 364]) == a2)
      return result;
    v9 = a1[1080 * v6 + 366];
    v10 = v7;
    if ((_DWORD)v9)
      break;
LABEL_12:
    ++v6;
    v7 += 1080;
    if (v6 == v5)
      goto LABEL_13;
  }
  while (*(unsigned __int16 *)v10 != a2 && *((unsigned __int16 *)v10 + 9) != a2)
  {
    v10 = (unsigned int *)((char *)v10 + 2);
    if (!--v9)
      goto LABEL_12;
  }
  return result;
}

BOOL _VideoReceiver_EnqueueDecodedFrameForDisplay(uint64_t a1, uint64_t a2, int *a3, uint64_t *a4, _BYTE *a5)
{
  uint64_t v6;
  uint64_t *v10;
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  int v14;
  uint64_t v15;
  int v16;
  OSStatus v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  NSObject *v21;
  NSObject *v22;
  int v23;
  uint64_t v24;
  NSObject *v25;
  NSObject *v26;
  int v27;
  _BOOL8 result;
  int v29;
  int32_t Count;
  int v31;
  uint64_t v32;
  int v33;
  int v34;
  uint64_t v35;
  NSObject *v36;
  int v37;
  int v38;
  uint64_t v39;
  NSObject *v40;
  NSObject *v41;
  _BOOL4 v42;
  const char *v43;
  NSObject *v44;
  uint32_t v45;
  uint64_t v46;
  NSObject *v47;
  NSObject *v48;
  _BOOL4 v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  uint64_t v56;
  int v57;
  uint8_t buf[4];
  uint64_t v60;
  __int16 v61;
  const char *v62;
  __int16 v63;
  int v64;
  __int16 v65;
  uint64_t v66;
  __int16 v67;
  _BOOL4 v68;
  __int16 v69;
  _BYTE v70[10];
  int v71;
  __int16 v72;
  OSStatus v73;
  __int16 v74;
  int32_t v75;
  uint64_t v76;

  v76 = *MEMORY[0x1E0C80C00];
  *a5 = 1;
  v6 = *a4;
  if (!*(_BYTE *)(a2 + 1188))
  {
    if (!*(_DWORD *)(a2 + 1448))
    {
      if (*(_BYTE *)(v6 + 67))
        _VideoReceiver_UpdateVideoStallStatus(a2, 1);
      _VideoReceiver_ShowFrame(a2, v6);
      return 1;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() < 8)
      return 0;
    v39 = VRTraceErrorLogLevelToCSTR();
    v40 = *MEMORY[0x1E0CF2758];
    v41 = *MEMORY[0x1E0CF2758];
    if (!*MEMORY[0x1E0CF2748])
    {
      result = os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG);
      if (result)
      {
        _VideoReceiver_EnqueueDecodedFrameForDisplay_cold_1();
        return 0;
      }
      return result;
    }
    v42 = os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v42)
      return result;
    *(_DWORD *)buf = 136315906;
    v60 = v39;
    v61 = 2080;
    v62 = "_VideoReceiver_EnqueueDecodedFrameForDisplay";
    v63 = 1024;
    v64 = 603;
    v65 = 2048;
    v66 = a2;
    v43 = "VideoReceiver [%s] %s:%d VideoReceiver[%p] stopping";
    v44 = v40;
    v45 = 38;
LABEL_49:
    _os_log_impl(&dword_1D8A54000, v44, OS_LOG_TYPE_DEFAULT, v43, buf, v45);
    return 0;
  }
  if (*(unsigned __int16 *)(a2 + 1162) >= 2u && !*(_QWORD *)(v6 + 16) && !*(_QWORD *)(v6 + 8))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 8)
      return 0;
    v46 = VRTraceErrorLogLevelToCSTR();
    v47 = *MEMORY[0x1E0CF2758];
    v48 = *MEMORY[0x1E0CF2758];
    if (!*MEMORY[0x1E0CF2748])
    {
      result = os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG);
      if (result)
      {
        v53 = *(_DWORD *)(v6 + 24);
        v54 = *(unsigned __int8 *)(v6 + 67);
        v55 = *(unsigned __int8 *)(v6 + 66);
        *(_DWORD *)buf = 136316674;
        v60 = v46;
        v61 = 2080;
        v62 = "_VideoReceiver_EnqueueDecodedFrameForDisplay";
        v63 = 1024;
        v64 = 588;
        v65 = 2048;
        v66 = a2;
        v67 = 1024;
        v68 = v53;
        v69 = 1024;
        *(_DWORD *)v70 = v54;
        *(_WORD *)&v70[4] = 1024;
        *(_DWORD *)&v70[6] = v55;
        _os_log_debug_impl(&dword_1D8A54000, v47, OS_LOG_TYPE_DEBUG, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Empty frame from decoder for display with RTPTimestamp=%u requestIntra=%d showFrame=%d", buf, 0x38u);
        return 0;
      }
      return result;
    }
    v49 = os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v49)
      return result;
    v50 = *(_DWORD *)(v6 + 24);
    v51 = *(unsigned __int8 *)(v6 + 67);
    v52 = *(unsigned __int8 *)(v6 + 66);
    *(_DWORD *)buf = 136316674;
    v60 = v46;
    v61 = 2080;
    v62 = "_VideoReceiver_EnqueueDecodedFrameForDisplay";
    v63 = 1024;
    v64 = 588;
    v65 = 2048;
    v66 = a2;
    v67 = 1024;
    v68 = v50;
    v69 = 1024;
    *(_DWORD *)v70 = v51;
    *(_WORD *)&v70[4] = 1024;
    *(_DWORD *)&v70[6] = v52;
    v43 = "VideoReceiver [%s] %s:%d VideoReceiver[%p] Empty frame from decoder for display with RTPTimestamp=%u requestIn"
          "tra=%d showFrame=%d";
    v44 = v47;
    v45 = 56;
    goto LABEL_49;
  }
  v10 = (uint64_t *)(a2 + 40432);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v11 = VRTraceErrorLogLevelToCSTR();
    v12 = *MEMORY[0x1E0CF2758];
    v13 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        v14 = *(unsigned __int16 *)(v6 + 48);
        v15 = *(_QWORD *)(v6 + 40);
        v16 = *(_DWORD *)(v6 + 24);
        *(_DWORD *)buf = 136316674;
        v60 = v11;
        v61 = 2080;
        v62 = "_VideoReceiver_EnqueueForDisplay";
        v63 = 1024;
        v64 = 469;
        v65 = 2048;
        v66 = a2;
        v67 = 1024;
        v68 = v14;
        v69 = 2048;
        *(_QWORD *)v70 = v15;
        *(_WORD *)&v70[8] = 1024;
        v71 = v16;
        _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] for streamID=%u enqueue frame for display. subframe=%llu RTPTimestamp=%u", buf, 0x3Cu);
      }
    }
    else if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      v31 = *(unsigned __int16 *)(v6 + 48);
      v32 = *(_QWORD *)(v6 + 40);
      v33 = *(_DWORD *)(v6 + 24);
      *(_DWORD *)buf = 136316674;
      v60 = v11;
      v61 = 2080;
      v62 = "_VideoReceiver_EnqueueForDisplay";
      v63 = 1024;
      v64 = 469;
      v65 = 2048;
      v66 = a2;
      v67 = 1024;
      v68 = v31;
      v69 = 2048;
      *(_QWORD *)v70 = v32;
      *(_WORD *)&v70[8] = 1024;
      v71 = v33;
      _os_log_debug_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEBUG, "VideoReceiver [%s] %s:%d VideoReceiver[%p] for streamID=%u enqueue frame for display. subframe=%llu RTPTimestamp=%u", buf, 0x3Cu);
    }
  }
  v17 = CMSimpleQueueEnqueue(*(CMSimpleQueueRef *)(a2 + 41296), (const void *)v6);
  if (v17)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v18 = VRTraceErrorLogLevelToCSTR();
      v19 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v29 = *(unsigned __int16 *)(v6 + 48);
        v56 = *(_QWORD *)(v6 + 40);
        v57 = *(_DWORD *)(v6 + 24);
        Count = CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a2 + 41296));
        *(_DWORD *)buf = 136317186;
        v60 = v18;
        v61 = 2080;
        v62 = "_VideoReceiver_EnqueueForDisplay";
        v63 = 1024;
        v64 = 473;
        v65 = 2048;
        v66 = a2;
        v67 = 1024;
        v68 = v29;
        v69 = 2048;
        *(_QWORD *)v70 = v56;
        *(_WORD *)&v70[8] = 1024;
        v71 = v57;
        v72 = 1024;
        v73 = v17;
        v74 = 1024;
        v75 = Count;
        _os_log_error_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_ERROR, "VideoReceiver [%s] %s:%d VideoReceiver[%p] for streamID=%d failed to enqueue frame for display. subframe=%llu RTPTimestamp=%u status=%d count=%d", buf, 0x48u);
      }
    }
    if (!*(_BYTE *)(a2 + 41268))
    {
      *(_BYTE *)(a2 + 41268) = 1;
      VCUtil_GenerateDiagnostics(0, 0, "VideoReceiver failed to enqueue frame into frameQueueForDisplay", 1u);
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v20 = VRTraceErrorLogLevelToCSTR();
    v21 = *MEMORY[0x1E0CF2758];
    v22 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        v23 = *(_DWORD *)(v6 + 24);
        *(_DWORD *)buf = 136316418;
        v60 = v20;
        v61 = 2080;
        v62 = "_VideoReceiver_EnqueueDecodedFrameForDisplay";
        v63 = 1024;
        v64 = 591;
        v65 = 2048;
        v66 = a2;
        v67 = 1024;
        v68 = v17 == 0;
        v69 = 1024;
        *(_DWORD *)v70 = v23;
        _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Finished _VideoReceiver_EnqueueForDisplay, result=%d RTPTimestamp=%u", buf, 0x32u);
        if (v17)
          goto LABEL_38;
        goto LABEL_28;
      }
    }
    else if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
    {
      v34 = *(_DWORD *)(v6 + 24);
      *(_DWORD *)buf = 136316418;
      v60 = v20;
      v61 = 2080;
      v62 = "_VideoReceiver_EnqueueDecodedFrameForDisplay";
      v63 = 1024;
      v64 = 591;
      v65 = 2048;
      v66 = a2;
      v67 = 1024;
      v68 = v17 == 0;
      v69 = 1024;
      *(_DWORD *)v70 = v34;
      _os_log_debug_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEBUG, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Finished _VideoReceiver_EnqueueForDisplay, result=%d RTPTimestamp=%u", buf, 0x32u);
      if (!v17)
        goto LABEL_28;
      goto LABEL_38;
    }
  }
  if (!v17)
  {
LABEL_28:
    _VideoReceiver_GetStream((unsigned int *)a2, *(unsigned __int16 *)(v6 + 48), *(unsigned __int8 *)(v6 + 71));
    kdebug_trace();
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v24 = VRTraceErrorLogLevelToCSTR();
      v25 = *MEMORY[0x1E0CF2758];
      v26 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          v27 = *a3;
          *(_DWORD *)buf = 136316162;
          v60 = v24;
          v61 = 2080;
          v62 = "_VideoReceiver_EnqueueDecodedFrameForDisplay";
          v63 = 1024;
          v64 = 597;
          v65 = 2048;
          v66 = a2;
          v67 = 1024;
          v68 = v27;
          _os_log_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Calling VCVideoPlayer_QueueAlarmForDisplay, RTPTimestamp=%u", buf, 0x2Cu);
        }
      }
      else if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
      {
        v38 = *a3;
        *(_DWORD *)buf = 136316162;
        v60 = v24;
        v61 = 2080;
        v62 = "_VideoReceiver_EnqueueDecodedFrameForDisplay";
        v63 = 1024;
        v64 = 597;
        v65 = 2048;
        v66 = a2;
        v67 = 1024;
        v68 = v38;
        _os_log_debug_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_DEBUG, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Calling VCVideoPlayer_QueueAlarmForDisplay, RTPTimestamp=%u", buf, 0x2Cu);
      }
    }
    VCVideoPlayer_QueueAlarmForDisplay(*v10, (uint64_t)VideoReceiver_VideoAlarmForDisplay, a1, *(_DWORD *)(v6 + 24), *(unsigned __int16 *)(v6 + 28), *(unsigned __int8 *)(v6 + 67), *(double *)(v6 + 32));
    *a5 = 0;
    *a4 = 0;
    return 1;
  }
LABEL_38:
  if ((int)VRTraceGetErrorLogLevelForModule() < 3)
    return 0;
  v35 = VRTraceErrorLogLevelToCSTR();
  v36 = *MEMORY[0x1E0CF2758];
  result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
  if (result)
  {
    v37 = *(_DWORD *)(v6 + 24);
    *(_DWORD *)buf = 136316162;
    v60 = v35;
    v61 = 2080;
    v62 = "_VideoReceiver_EnqueueDecodedFrameForDisplay";
    v63 = 1024;
    v64 = 592;
    v65 = 2048;
    v66 = a2;
    v67 = 1024;
    v68 = v37;
    _os_log_error_impl(&dword_1D8A54000, v36, OS_LOG_TYPE_ERROR, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Unable to enqueue frame for display with RTPTimestamp=%u", buf, 0x2Cu);
    return 0;
  }
  return result;
}

void _VideoReceiver_CheckAndRequestKeyFrame(uint64_t a1, uint64_t a2)
{
  unsigned int *Stream;
  uint64_t v5;
  NSObject *v6;
  int v7;
  int v8;
  uint64_t v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a2 && *(_BYTE *)(a2 + 67))
  {
    if (*(unsigned __int16 *)(a1 + 1162) < 2u)
      Stream = _VideoReceiver_GetStream((unsigned int *)a1, *(unsigned __int16 *)(a2 + 48), *(unsigned __int8 *)(a2 + 71));
    else
      Stream = _VideoReceiver_GetStreamWithTileIndex((unsigned int *)a1, *(unsigned __int16 *)(a2 + 44));
    if (Stream)
    {
      _VideoReceiver_DecoderRequestKeyFrame(a1, (unsigned __int16 *)Stream, 0x12u, *(_DWORD *)(a2 + 24), *((unsigned __int8 *)Stream + 100), *(unsigned __int8 *)(a2 + 68));
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v6 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v7 = *(unsigned __int16 *)(a2 + 48);
        v8 = 136316162;
        v9 = v5;
        v10 = 2080;
        v11 = "_VideoReceiver_CheckAndRequestKeyFrame";
        v12 = 1024;
        v13 = 1905;
        v14 = 2048;
        v15 = a1;
        v16 = 1024;
        v17 = v7;
        _os_log_error_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_ERROR, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Unable to find the VCVideoReceiverStream matching streamID=%d", (uint8_t *)&v8, 0x2Cu);
      }
    }
  }
}

int32x2_t *VideoReceiver_IncrementFIRCount(uint64_t a1, int a2)
{
  int32x2_t *result;

  result = (int32x2_t *)CheckInHandleDebug();
  if (result)
  {
    result[5123] = vadd_s32(result[5123], (int32x2_t)0x100000001);
    if (a2 == 3)
      ++result[5124].i32[0];
    return (int32x2_t *)CheckOutHandleDebug();
  }
  return result;
}

uint64_t _VideoReceiver_HandleSendRTCPSuccess(uint64_t a1, _BYTE *a2, double a3)
{
  uint64_t result;
  __CFDictionary *ReportingEventDictionary;

  result = CheckInHandleDebug();
  if (result)
  {
    *(double *)(result + 40728) = a3;
    if ((*a2 & 0x48) != 0)
    {
      ReportingEventDictionary = _VideoReceiver_CreateReportingEventDictionary(result);
      reportingVideoStreamEvent();
      VideoReceiver_IncrementFIRCount(a1, -1);
      if (ReportingEventDictionary)
        CFRelease(ReportingEventDictionary);
    }
    return CheckOutHandleDebug();
  }
  return result;
}

__CFDictionary *_VideoReceiver_CreateReportingEventDictionary(uint64_t a1)
{
  const __CFAllocator *v2;
  __CFDictionary *Mutable;
  char *v4;
  CFStringRef v5;
  char *v6;
  CFStringRef v7;

  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    v4 = FourccToCStr(*(_DWORD *)(a1 + 1248));
    v5 = CFStringCreateWithCString(v2, v4, 0x8000100u);
    v6 = FourccToCStr(*(_DWORD *)(a1 + 1248));
    v7 = CFStringCreateWithCString(v2, v6, 0x8000100u);
    if (v5)
    {
      CFDictionaryAddValue(Mutable, CFSTR("VCMSStreamGroup"), v5);
      CFRelease(v5);
    }
    if (v7)
    {
      CFDictionaryAddValue(Mutable, CFSTR("VCSPUUID"), v7);
      CFRelease(v7);
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VideoReceiver_CreateReportingEventDictionary_cold_1();
  }
  return Mutable;
}

void _VideoReceiver_SendRTCP(uint64_t a1, uint64_t a2, __int128 *a3, int a4, double a5)
{
  BOOL v5;
  uint64_t v8;
  uint64_t v9;
  NSObject **v10;
  int v11;
  NSObject *v12;
  int v13;
  uint64_t v14;
  NSObject *v15;
  char *v16;
  _QWORD block[4];
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  double v32;
  char *v33;
  uint8_t buf[4];
  uint64_t v35;
  __int16 v36;
  const char *v37;
  __int16 v38;
  int v39;
  __int16 v40;
  int v41;
  __int16 v42;
  uint64_t v43;
  __int16 v44;
  int v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  uint64_t v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)a3)
    v5 = 0;
  else
    v5 = a4 == 0;
  if (!v5)
  {
    v8 = *(_QWORD *)(a2 + 48);
    v9 = *(_QWORD *)(a2 + 128);
    v10 = (NSObject **)(a1 + 40736);
    v56 = 0;
    v54 = 0u;
    v55 = 0u;
    v52 = 0u;
    v53 = 0u;
    v50 = 0u;
    v51 = 0u;
    v48 = 0u;
    v49 = 0u;
    v46 = 0u;
    v47 = 0u;
    v16 = 0;
    v11 = RTCPCopySendControlParameters(a3, (uint64_t)&v46, *(OSQueueHead **)(a1 + 41392), &v16);
    if (v11 < 0)
    {
      v13 = v11;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v14 = VRTraceErrorLogLevelToCSTR();
        v15 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136316418;
          v35 = v14;
          v36 = 2080;
          v37 = "_VideoReceiver_SendRTCP";
          v38 = 1024;
          v39 = 1543;
          v40 = 1024;
          v41 = 1543;
          v42 = 2048;
          v43 = a1;
          v44 = 1024;
          v45 = v13;
          _os_log_error_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_ERROR, "VideoReceiver [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/VideoReceiver.c:%d: VideoReceiver[%p] deep copy of rtcp send control params failed (%08X)", buf, 0x32u);
        }
      }
    }
    else
    {
      v12 = *v10;
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 0x40000000;
      block[2] = ___VideoReceiver_SendRTCP_block_invoke;
      block[3] = &__block_descriptor_tmp_7;
      v26 = v54;
      v27 = v55;
      v22 = v50;
      v23 = v51;
      v24 = v52;
      v25 = v53;
      v18 = v46;
      v19 = v47;
      v20 = v48;
      v21 = v49;
      v28 = v56;
      v29 = v8;
      v30 = a1;
      v31 = v9;
      v32 = a5;
      v33 = v16;
      dispatch_async(v12, block);
    }
  }
}

BOOL _VideoReceiver_HandleStreamSwitch(uint64_t a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned __int16 *v10;
  uint64_t v11;
  int v12;
  uint64_t *v14;
  int v15;
  unsigned __int16 *v16;
  unsigned __int16 *v17;
  uint64_t v18;
  NSObject *v19;
  NSObject *v20;
  uint64_t v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  uint64_t v27;
  NSObject *v28;
  int v29;
  int v30;
  int v31;
  int v32;
  FILE **v33;
  int v34;
  uint64_t v35;
  __int16 v36;
  const char *v37;
  __int16 v38;
  int v39;
  __int16 v40;
  uint64_t v41;
  __int16 v42;
  int v43;
  __int16 v44;
  int v45;
  __int16 v46;
  int v47;
  __int16 v48;
  int v49;
  __int16 v50;
  int v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 1209))
    return 0;
  v10 = (unsigned __int16 *)(a1 + 40336);
  v11 = *(_QWORD *)(a1 + 40368);
  if ((unsigned __int16 *)v11 == a2)
    return 0;
  if (v11 && (!*(_BYTE *)(v11 + 70) || !*((_BYTE *)a2 + 70)))
  {
    v14 = (uint64_t *)(a1 + 40680);
    atomic_store(1u, (unsigned __int8 *)(a1 + 41721));
    atomic_store(1u, (unsigned __int8 *)(a1 + 41722));
    v15 = *(unsigned __int8 *)(a1 + 40342);
    if (*((_BYTE *)a2 + 70))
    {
      if (*(_BYTE *)(a1 + 40342))
      {
        v15 = *(unsigned __int8 *)(a1 + 40350);
        if (*(_BYTE *)(a1 + 40350))
        {
          v16 = (unsigned __int16 *)(a1 + 40340);
          v17 = (unsigned __int16 *)(a1 + 40348);
LABEL_15:
          v15 = *v16 == *v17;
        }
      }
    }
    else if (*(_BYTE *)(a1 + 40342))
    {
      v15 = *(unsigned __int8 *)(a1 + 40350);
      if (*(_BYTE *)(a1 + 40350))
      {
        v17 = (unsigned __int16 *)(a1 + 40344);
        v16 = (unsigned __int16 *)(a1 + 40336);
        goto LABEL_15;
      }
    }
    if (*(_BYTE *)(a1 + 40376))
    {
      VCMediaStreamSynchronizer_resetDestinationState(*(_QWORD *)(a1 + 41576));
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v18 = VRTraceErrorLogLevelToCSTR();
        v19 = *MEMORY[0x1E0CF2758];
        v20 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            v21 = *v14;
            v22 = *(_DWORD *)(a1 + 40688);
            v23 = *(_DWORD *)(a1 + 40692);
            v24 = *(_DWORD *)(a1 + 40696);
            v25 = *(_DWORD *)(a1 + 40700);
            v26 = *(unsigned __int8 *)(a1 + 40704);
            v34 = 136317186;
            v35 = v18;
            v36 = 2080;
            v37 = "_VideoReceiver_HandleStreamSwitch";
            v38 = 1024;
            v39 = 2957;
            v40 = 2048;
            v41 = v21;
            v42 = 1024;
            v43 = v22;
            v44 = 1024;
            v45 = v23;
            v46 = 1024;
            v47 = v24;
            v48 = 1024;
            v49 = v25;
            v50 = 1024;
            v51 = v26;
            _os_log_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d Before resetting playoutContext, soundAlarmReferenceTimestamp=%llu playoutRTPTimestamp=%u lastVideoTS=%u videoTSWraps=%u lastReceivedTimestamp=%u lastReceivedTimestampValid=%d", (uint8_t *)&v34, 0x44u);
          }
        }
        else if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
        {
          _VideoReceiver_HandleStreamSwitch_cold_1();
        }
      }
      *(_QWORD *)(a1 + 40712) = 0;
      *(_OWORD *)(a1 + 40680) = 0u;
      *(_OWORD *)(a1 + 40696) = 0u;
    }
    else if (!v15)
    {
      v12 = 0;
LABEL_30:
      v33 = (FILE **)v14[123];
      if (v33)
      {
        v34 = *a2;
        v35 = *(uint64_t *)((char *)v14 + 116);
        VRDump_AddEvent(v33, 9u, &v34, a4, a5, a6, a7, a8, v34);
      }
      goto LABEL_32;
    }
    RTPResetHandle();
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v27 = VRTraceErrorLogLevelToCSTR();
      v28 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v29 = *v10;
        v30 = v10[4];
        v31 = **((unsigned __int16 **)v10 + 4);
        v32 = *a2;
        v34 = 136316930;
        v35 = v27;
        v36 = 2080;
        v37 = "_VideoReceiver_HandleStreamSwitch";
        v38 = 1024;
        v39 = 2966;
        v40 = 2048;
        v41 = a1;
        v42 = 1024;
        v43 = v29;
        v44 = 1024;
        v45 = v30;
        v46 = 1024;
        v47 = v31;
        v48 = 1024;
        v49 = v32;
        _os_log_impl(&dword_1D8A54000, v28, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] currentStreamID:%u targetStreamID:%u, packet receive switched from stream:%u to stream:%u", (uint8_t *)&v34, 0x3Eu);
      }
    }
    v12 = 1;
    goto LABEL_30;
  }
  v12 = 0;
LABEL_32:
  *((_QWORD *)v10 + 4) = a2;
  return v12 != 0;
}

uint64_t _VideoReceiver_DecryptFrame(uint64_t a1, OpaqueCMBlockBuffer *a2, CMBlockBufferRef *a3)
{
  uint64_t v4;

  if (!a1)
    return 2149515265;
  v4 = VCSFrameCryptorH264_Decrypt(*(uint64_t **)(a1 + 4272), a2, a3);
  if ((v4 & 0x80000000) != 0 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VideoReceiver_DecryptFrame_cold_1();
  }
  RTPProcessDecryptionStatusChange(*(_QWORD *)(a1 + 48), (int)v4 >= 0);
  return v4;
}

uint64_t _VideoReceiver_GetAssemblyRTPTimestamp(uint64_t a1)
{
  int *v1;
  uint64_t v2;
  unsigned int v3;
  double v5;
  unsigned int v6;
  uint64_t v7;
  double v8;
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  __int16 v33;
  double v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v1 = (int *)(a1 + 40688);
  v2 = *(unsigned int *)(a1 + 40700);
  v3 = *(_DWORD *)(a1 + 40688);
  if (v3 - 1 < v2 && *(_BYTE *)(a1 + 1078))
  {
    v5 = (double)*(int *)(a1 + 1036);
    v6 = v2 - (*(double *)(a1 + 1080) * v5);
    if (v6 <= v3)
      v7 = v3;
    else
      v7 = v6;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v8 = (double)(v2 - v3) / v5;
      v9 = VRTraceErrorLogLevelToCSTR();
      v10 = *MEMORY[0x1E0CF2758];
      v11 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          v12 = *(_QWORD *)(a1 + 1080);
          v13 = v1[3];
          v14 = *v1;
          v19 = 136316930;
          v20 = v9;
          v21 = 2080;
          v22 = "_VideoReceiver_GetAssemblyRTPTimestamp";
          v23 = 1024;
          v24 = 3358;
          v25 = 2048;
          v26 = v12;
          v27 = 1024;
          v28 = v7;
          v29 = 1024;
          v30 = v13;
          v31 = 1024;
          v32 = v14;
          v33 = 2048;
          v34 = v8;
          _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d deferredAssemblyOffset=%f assemblyTimestamp=%u lastReceivedTimestamp=%u playoutRTPTimestamp=%u bufferDepth=%f", (uint8_t *)&v19, 0x42u);
        }
      }
      else if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        v16 = *(_QWORD *)(a1 + 1080);
        v17 = v1[3];
        v18 = *v1;
        v19 = 136316930;
        v20 = v9;
        v21 = 2080;
        v22 = "_VideoReceiver_GetAssemblyRTPTimestamp";
        v23 = 1024;
        v24 = 3358;
        v25 = 2048;
        v26 = v16;
        v27 = 1024;
        v28 = v7;
        v29 = 1024;
        v30 = v17;
        v31 = 1024;
        v32 = v18;
        v33 = 2048;
        v34 = v8;
        _os_log_debug_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEBUG, "VideoReceiver [%s] %s:%d deferredAssemblyOffset=%f assemblyTimestamp=%u lastReceivedTimestamp=%u playoutRTPTimestamp=%u bufferDepth=%f", (uint8_t *)&v19, 0x42u);
      }
    }
    return v7;
  }
  return v2;
}

uint64_t VideoReceiver_SetTargetStreamID(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned __int16 *v6;
  unsigned int *Stream;
  uint64_t v8;
  unsigned __int16 *v9;
  uint64_t v10;
  double v11;

  v3 = 2149515265;
  v4 = CheckInHandleDebug();
  if (!v4)
    return 2149515266;
  v5 = v4;
  v6 = (unsigned __int16 *)(v4 + 40336);
  if (*(unsigned __int16 *)(v4 + 40344) == a2 && *(_BYTE *)(v4 + 40350))
  {
    CheckOutHandleDebug();
    return 0;
  }
  else
  {
    Stream = _VideoReceiver_GetStream((unsigned int *)v4, a2, *(unsigned __int8 *)(v4 + 77));
    if (Stream)
    {
      v8 = (uint64_t)Stream;
      _VideoReceiver_UpdateStreamSwitchContextForTargetStream(v5, a2, *((_WORD *)Stream + 1), *((_WORD *)Stream + 2));
      if (*((_BYTE *)v6 + 6))
      {
        v9 = v6 + 2;
        v10 = 6;
        if (!*(_BYTE *)(v8 + 70))
        {
          v10 = 4;
          v9 = v6;
        }
        if (*v9 != v6[v10] && *(_BYTE *)(v8 + 64))
        {
          v11 = micro();
          _VideoReceiver_SendFIR(v5, v8, 0, 25, v11);
        }
      }
      v3 = 0;
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoReceiver_SetTargetStreamID_cold_1();
    }
    CheckOutHandleDebug();
  }
  return v3;
}

void _VideoReceiver_UpdateStreamSwitchContextForTargetStream(uint64_t a1, __int16 a2, __int16 a3, __int16 a4)
{
  unsigned __int16 *v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  uint64_t v18;
  __int16 v19;
  uint64_t v20;
  __int16 v21;
  int v22;
  __int16 v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v5 = (unsigned __int16 *)(a1 + 40344);
  *(_WORD *)(a1 + 40344) = a2;
  *(_WORD *)(a1 + 40348) = a4;
  *(_WORD *)(a1 + 40346) = a3;
  *(_BYTE *)(a1 + 40350) = 1;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v6 = VRTraceErrorLogLevelToCSTR();
    v7 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v8 = *(_QWORD *)(a1 + 1152);
      v9 = *v5;
      v10 = v5[2];
      v11 = 136316674;
      v12 = v6;
      v13 = 2080;
      v14 = "_VideoReceiver_UpdateStreamSwitchContextForTargetStream";
      v15 = 1024;
      v16 = 3405;
      v17 = 2048;
      v18 = a1;
      v19 = 2048;
      v20 = v8;
      v21 = 1024;
      v22 = v9;
      v23 = 1024;
      v24 = v10;
      _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] participantId[%llu]: Setting target stream info. targetStreamID=%d, targetBaseStreamID=%d", (uint8_t *)&v11, 0x3Cu);
    }
  }
}

uint64_t _VideoReceiver_SendFIR(uint64_t a1, uint64_t a2, int a3, int a4, double a5)
{
  uint64_t v9;
  double v10;
  int v12;
  int v13;
  int ErrorLogLevelForModule;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  NSObject *v21;
  FILE **v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  NSObject *v30;
  uint64_t v31;
  int v32;
  int v33;
  char *v34;
  int v35;
  FILE **v36;
  uint64_t v37;
  NSObject *v38;
  uint64_t v39;
  uint8_t v40;
  void (*v41)(uint64_t, uint64_t, uint64_t);
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  int v46;
  int v47;
  uint64_t v48;
  NSObject *v49;
  NSObject *v50;
  uint64_t v51;
  uint64_t v53;
  uint64_t v54;
  char v55;
  uint8_t v57[4];
  uint64_t v58;
  __int16 v59;
  const char *v60;
  __int16 v61;
  int v62;
  __int16 v63;
  uint64_t v64;
  __int16 v65;
  uint64_t v66;
  __int16 v67;
  _BYTE v68[10];
  __int16 v69;
  int v70;
  _QWORD v71[3];
  uint8_t buf[112];
  __int128 v73;
  __int128 v74;
  __int128 v75;
  uint64_t v76;
  uint64_t v77;

  v77 = *MEMORY[0x1E0C80C00];
  v9 = a1 + 40656;
  if (a3)
  {
    v10 = *(double *)(a1 + 41120);
    if (v10 == 0.0 || a5 - v10 <= 15.0)
    {
      v12 = 2;
      v13 = 1;
    }
    else
    {
      ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
      if (ErrorLogLevelForModule >= 3)
      {
        v20 = VRTraceErrorLogLevelToCSTR();
        v21 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v53 = *(_QWORD *)(a2 + 112);
          *(_DWORD *)buf = 136316418;
          *(_QWORD *)&buf[4] = v20;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VideoReceiver_SendFIR";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 1597;
          *(_WORD *)&buf[28] = 2048;
          *(_QWORD *)&buf[30] = a1;
          *(_WORD *)&buf[38] = 2048;
          *(_QWORD *)&buf[40] = v53;
          *(_WORD *)&buf[48] = 1024;
          *(_DWORD *)&buf[50] = 15;
          _os_log_error_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_ERROR, "VideoReceiver [%s] %s:%d VideoReceiver[%p] VideoPacketBuffer[%p] Forcing Full IDR request since video quality has been bad for more than %d secs", buf, 0x36u);
        }
      }
      v22 = *(FILE ***)(v9 + 1008);
      if (v22)
        VRDump_AddEvent(v22, 7u, 0, v15, v16, v17, v18, v19, v55);
      v13 = 0;
      v12 = 0;
      *(_BYTE *)(v9 + 1016) = 1;
    }
  }
  else
  {
    v13 = 0;
    v12 = 0;
  }
  v23 = *(unsigned __int16 *)(a2 + 4 * *(unsigned __int8 *)(a2 + 70));
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v29 = VRTraceErrorLogLevelToCSTR();
    v30 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v31 = *(_QWORD *)(a2 + 112);
      v32 = *(_DWORD *)(v9 + 140);
      v33 = *(_DWORD *)(v9 + 144);
      v34 = kVCKeyFrameRequestReasonStrings_0[a4];
      v35 = *(unsigned __int8 *)(a2 + 70);
      *(_DWORD *)buf = 136317954;
      *(_QWORD *)&buf[4] = v29;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "_VideoReceiver_SendFIR";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 1609;
      *(_WORD *)&buf[28] = 2048;
      *(_QWORD *)&buf[30] = a1;
      *(_WORD *)&buf[38] = 2048;
      *(_QWORD *)&buf[40] = v31;
      *(_WORD *)&buf[48] = 1024;
      *(_DWORD *)&buf[50] = v12;
      *(_WORD *)&buf[54] = 1024;
      *(_DWORD *)&buf[56] = v32;
      *(_WORD *)&buf[60] = 1024;
      *(_DWORD *)&buf[62] = v33;
      *(_WORD *)&buf[66] = 2048;
      *(_QWORD *)&buf[68] = a2;
      *(_WORD *)&buf[76] = 1024;
      *(_DWORD *)&buf[78] = v23;
      *(_WORD *)&buf[82] = 2080;
      *(_QWORD *)&buf[84] = v34;
      *(_WORD *)&buf[92] = 1024;
      *(_DWORD *)&buf[94] = v35;
      _os_log_impl(&dword_1D8A54000, v30, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] VideoPacketBuffer[%p] Sending FIR(%d) %dx%d stream[%p] streamID=%d reason=%s isTemporalScalingEnabled=%d", buf, 0x62u);
    }
  }
  v36 = *(FILE ***)(v9 + 1008);
  if (v36)
    VRDump_AddEvent(v36, 4u, 0, v24, v25, v26, v27, v28, v55);
  *(double *)(a2 + 4312) = a5;
  if (*(_BYTE *)(a1 + 1189))
  {
    v76 = 0;
    v74 = 0u;
    v75 = 0u;
    v73 = 0u;
    memset(buf, 0, sizeof(buf));
    memset(v71, 170, 20);
    if (*(_BYTE *)(a1 + 1190))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v37 = VRTraceErrorLogLevelToCSTR();
        v38 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v39 = *(_QWORD *)(a2 + 112);
          *(_DWORD *)v57 = 136316418;
          v58 = v37;
          v59 = 2080;
          v60 = "_VideoReceiver_SendFIR";
          v61 = 1024;
          v62 = 1630;
          v63 = 2048;
          v64 = a1;
          v65 = 2048;
          v66 = v39;
          v67 = 2048;
          *(_QWORD *)v68 = a2;
          _os_log_impl(&dword_1D8A54000, v38, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] VideoPacketBuffer[%p] stream[%p] Sending PSFB FIR", v57, 0x3Au);
        }
      }
      *(_DWORD *)buf = 64;
      v40 = *(_BYTE *)(v9 + 912) + 1;
      *(_BYTE *)(v9 + 912) = v40;
      buf[24] = v40;
      *((_QWORD *)&v74 + 1) = *(_QWORD *)(a1 + 1152);
      BYTE3(v74) = 1;
      goto LABEL_48;
    }
    *(_DWORD *)buf = 8;
    if (a3)
    {
      v45 = *(_DWORD *)(v9 + 144);
      LOWORD(v71[0]) = *(_DWORD *)(v9 + 140);
      WORD1(v71[0]) = v45;
      *(_QWORD *)&buf[32] = v71;
      *(_DWORD *)&buf[40] = v12;
      v46 = *(unsigned __int8 *)(v9 + 536);
      v47 = *(_BYTE *)(v9 + 536) ? 7 : 8;
      if (v47 <= (int)VRTraceGetErrorLogLevelForModule())
      {
        v48 = VRTraceErrorLogLevelToCSTR();
        if (v46)
        {
          v49 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
LABEL_45:
            v51 = *(_QWORD *)(a2 + 112);
            *(_DWORD *)v57 = 136316930;
            v58 = v48;
            v59 = 2080;
            v60 = "_VideoReceiver_SendFIR";
            v61 = 1024;
            v62 = 1643;
            v63 = 2048;
            v64 = a1;
            v65 = 2048;
            v66 = v51;
            v67 = 1024;
            *(_DWORD *)v68 = LOWORD(v71[0]);
            *(_WORD *)&v68[4] = 1024;
            *(_DWORD *)&v68[6] = WORD1(v71[0]);
            v69 = 1024;
            v70 = v12;
            _os_log_impl(&dword_1D8A54000, v49, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] VideoPacketBuffer[%p] %dx%d %d", v57, 0x42u);
          }
        }
        else
        {
          v49 = *MEMORY[0x1E0CF2758];
          v50 = *MEMORY[0x1E0CF2758];
          if (!*MEMORY[0x1E0CF2748])
          {
            if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG))
            {
              v54 = *(_QWORD *)(a2 + 112);
              *(_DWORD *)v57 = 136316930;
              v58 = v48;
              v59 = 2080;
              v60 = "_VideoReceiver_SendFIR";
              v61 = 1024;
              v62 = 1643;
              v63 = 2048;
              v64 = a1;
              v65 = 2048;
              v66 = v54;
              v67 = 1024;
              *(_DWORD *)v68 = LOWORD(v71[0]);
              *(_WORD *)&v68[4] = 1024;
              *(_DWORD *)&v68[6] = WORD1(v71[0]);
              v69 = 1024;
              v70 = v12;
              _os_log_debug_impl(&dword_1D8A54000, v49, OS_LOG_TYPE_DEBUG, "VideoReceiver [%s] %s:%d VideoReceiver[%p] VideoPacketBuffer[%p] %dx%d %d", v57, 0x42u);
            }
            goto LABEL_48;
          }
          if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
            goto LABEL_45;
        }
      }
    }
LABEL_48:
    _VideoReceiver_SendRTCP(a1, a2, (__int128 *)buf, 0, a5);
    return kdebug_trace();
  }
  v41 = *(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 1408);
  if (v41 && *(_BYTE *)(a2 + 64))
  {
    if (v13 && *(_BYTE *)(a2 + 69))
    {
      v42 = *(_QWORD *)(a1 + 1384);
      v43 = v23;
      v44 = 2;
LABEL_42:
      v41(v42, v43, v44);
      return kdebug_trace();
    }
    v42 = *(_QWORD *)(a1 + 1384);
    v43 = v23;
    if (a4 != 28)
    {
      v44 = 0;
      goto LABEL_42;
    }
    v41(v42, v23, 3);
    reportingSymptom();
  }
  return kdebug_trace();
}

uint64_t VideoReceiver_SetShouldEnableFaceZoom(uint64_t a1, char a2)
{
  uint64_t v3;
  uint64_t v4;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149515266;
  v4 = v3 + 40440;
  VideoDecoder_SetShouldEnableFaceZoom();
  *(_BYTE *)(v4 + 1000) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t VideoReceiver_SetShouldEnableMLEnhance(uint64_t a1, int a2, int a3)
{
  unsigned int *v5;
  unsigned int *v6;
  uint64_t v7;
  unsigned __int16 *v8;
  _BYTE *v9;
  uint64_t v11;
  NSObject *v12;
  int v13;
  uint64_t v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  unsigned int *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v5 = (unsigned int *)CheckInHandleDebug();
  if (!v5)
    return 2149515266;
  v6 = v5;
  v7 = *v5;
  if ((_DWORD)v7)
  {
    v8 = (unsigned __int16 *)(v5 + 10084);
    v9 = v5 + 391;
    while (*((unsigned __int16 *)v9 - 54) != a2)
    {
      v9 += 4320;
      if (!--v7)
        goto LABEL_14;
    }
    if (*v9 != a3)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v11 = VRTraceErrorLogLevelToCSTR();
        v12 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v13 = 136316418;
          v14 = v11;
          v15 = 2080;
          v16 = "VideoReceiver_SetShouldEnableMLEnhance";
          v17 = 1024;
          v18 = 3498;
          v19 = 2048;
          v20 = v6;
          v21 = 1024;
          v22 = a3;
          v23 = 1024;
          v24 = a2;
          _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] ML Enhance setting shouldEnableMLEnhance=%u on streamID=%u", (uint8_t *)&v13, 0x32u);
        }
      }
      *v9 = a3;
      if (*v8 == a2)
        VideoDecoder_SetShouldEnableMLEnhance(*((_QWORD *)v6 + 5055), a3);
    }
  }
LABEL_14:
  CheckOutHandleDebug();
  return 0;
}

void _VideoReceiver_ProcessRTTStatistics(unsigned int *a1, _DWORD *a2)
{
  double v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (*a2 == 3)
  {
    v3 = (double)(a2[13] << (*((_BYTE *)a1 + 40352) == 0)) / 1000.0;
    if (v3 != 0.0)
    {
      v4 = *a1;
      if ((_DWORD)v4)
      {
        v5 = 0;
        v6 = 392;
        do
        {
          v7 = *(_QWORD *)&a1[v6];
          if (v7)
          {
            VideoPacketBuffer_SetRoundTripTime(v7, v3);
            v4 = *a1;
          }
          ++v5;
          v6 += 1080;
        }
        while (v5 < v4);
      }
    }
  }
}

void _VideoReceiver_RegisterStatistics(uint64_t a1)
{
  uint64_t *v2;
  void *v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  int v7;
  _QWORD v8[5];
  uint8_t buf[4];
  uint64_t v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  uint64_t v16;
  __int16 v17;
  uint64_t v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 1260))
  {
    v2 = (uint64_t *)(a1 + 41400);
    v3 = *(void **)(a1 + 41400);
    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 0x40000000;
    v8[2] = ___VideoReceiver_RegisterStatistics_block_invoke;
    v8[3] = &__block_descriptor_tmp_4_0;
    v8[4] = a1;
    *((_DWORD *)v2 + 59) = VCRateControlRegisterStatisticsChangeHandler(v3, 3, (uint64_t)v8);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v4 = VRTraceErrorLogLevelToCSTR();
      v5 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v6 = *v2;
        v7 = *((_DWORD *)v2 + 59);
        *(_DWORD *)buf = 136316418;
        v10 = v4;
        v11 = 2080;
        v12 = "_VideoReceiver_RegisterStatistics";
        v13 = 1024;
        v14 = 3743;
        v15 = 2048;
        v16 = a1;
        v17 = 2048;
        v18 = v6;
        v19 = 1024;
        v20 = v7;
        _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Registered statisticsCollector[%p] with index=%d", buf, 0x36u);
      }
    }
  }
}

void _VideoReceiver_UnregisterStatistics(uint64_t a1)
{
  uint64_t *v2;
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  uint64_t v14;
  __int16 v15;
  uint64_t v16;
  __int16 v17;
  int v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v2 = (uint64_t *)(a1 + 41400);
  VCRateControlUnregisterStatisticsChangeHandler(*(void **)(a1 + 41400), 3, *(unsigned int *)(a1 + 41636));
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v3 = VRTraceErrorLogLevelToCSTR();
    v4 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v5 = *v2;
      v6 = *((_DWORD *)v2 + 59);
      v7 = 136316418;
      v8 = v3;
      v9 = 2080;
      v10 = "_VideoReceiver_UnregisterStatistics";
      v11 = 1024;
      v12 = 3749;
      v13 = 2048;
      v14 = a1;
      v15 = 2048;
      v16 = v5;
      v17 = 1024;
      v18 = v6;
      _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Unregistered statisticsCollector[%p] with index=%d", (uint8_t *)&v7, 0x36u);
    }
  }
}

FILE **_VideoReceiver_SwitchIntoOneToOne(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6;
  const void *v7;
  CFTypeRef v8;
  void (*v9)(_QWORD, _QWORD);
  int v10;
  int v11;
  const __CFAllocator *v12;
  __CFDictionary *Mutable;
  CFNumberRef v14;
  CFNumberRef v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int valuePtr;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v6 = a1 + 40352;
  *(_QWORD *)(a1 + 40360) = a3;
  *(_DWORD *)(a1 + 40356) = *(_DWORD *)(a3 + 96);
  *(_BYTE *)(a1 + 40352) = a2;
  _VideoReceiver_UnregisterStatistics(a1);
  v7 = *(const void **)(v6 + 1048);
  if (v7)
    CFRelease(v7);
  v8 = *(CFTypeRef *)(a3 + 88);
  if (v8)
    v8 = CFRetain(v8);
  *(_QWORD *)(v6 + 1048) = v8;
  _VideoReceiver_RegisterStatistics(a1);
  _VideoReceiver_UpdateMediaControlInfo(a1);
  *(_BYTE *)(a1 + 1183) = *(_BYTE *)(a3 + 100);
  v9 = *(void (**)(_QWORD, _QWORD))(a1 + 1440);
  if (v9)
    v9(*(_QWORD *)(a1 + 1384), *(unsigned int *)(a3 + 96));
  if (*(_BYTE *)(a1 + 1260))
    _VideoReceiver_ReportRTXConfiguration((unsigned __int8 *)a1);
  if (*(_BYTE *)(a3 + 102) && *(_DWORD *)(a3 + 104) == 2)
  {
    v10 = *(unsigned __int8 *)(a3 + 101);
    v11 = 1;
  }
  else
  {
    if (!*(_BYTE *)(a3 + 101))
      goto LABEL_15;
    v11 = 0;
    v10 = 1;
  }
  v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  valuePtr = v10;
  v14 = CFNumberCreate(v12, kCFNumberIntType, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("RtcpForLoss"), v14);
  CFRelease(v14);
  valuePtr = v11;
  v15 = CFNumberCreate(v12, kCFNumberIntType, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("RtcpForLtrAck"), v15);
  CFRelease(v15);
  reportingFeatureConfigEvent();
  CFRelease(Mutable);
LABEL_15:
  *(_DWORD *)(v6 + 760) = 0;
  *(_OWORD *)(a1 + 41088) = 0u;
  *(_OWORD *)(a1 + 41120) = 0u;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 40520));
  if (*(_QWORD *)(v6 + 40) != 0xFFFFFFFFLL)
    SummerReset();
  if (*(_QWORD *)(v6 + 48) != 0xFFFFFFFFLL)
    SummerReset();
  if (*(_QWORD *)(v6 + 56) != 0xFFFFFFFFLL)
    SummerReset();
  if (*(_QWORD *)(v6 + 64) != 0xFFFFFFFFLL)
    SummerReset();
  if (*(_QWORD *)(v6 + 72) != 0xFFFFFFFFLL)
    SummerReset();
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 40520));
  return VRDump_SwitchMode(*(FILE ***)(v6 + 1312), a2, v16, v17, v18, v19, v20, v21);
}

void _VideoReceiver_ReportRTXConfiguration(unsigned __int8 *a1)
{
  const __CFAllocator *v2;
  __CFDictionary *Mutable;
  CFNumberRef v4;
  CFNumberRef v5;
  unsigned int v6;
  CFNumberRef v7;
  float valuePtr;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  LODWORD(valuePtr) = a1[1260];
  v4 = CFNumberCreate(v2, kCFNumberIntType, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("NacksRTXEnabled"), v4);
  CFRelease(v4);
  LODWORD(valuePtr) = a1[1276];
  v5 = CFNumberCreate(v2, kCFNumberIntType, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("NacksRTXDelayedEnabled"), v5);
  CFRelease(v5);
  LOBYTE(v6) = a1[1264];
  valuePtr = (float)v6;
  v7 = CFNumberCreate(v2, kCFNumberFloat32Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("NacksRTXConfigVersion"), v7);
  CFRelease(v7);
  reportingFeatureConfigEvent();
  CFRelease(Mutable);
}

uint64_t _VideoReceiver_GetVPBStats(uint64_t a1)
{
  unsigned int *v1;
  uint64_t v2;
  _DWORD *v3;
  uint64_t v4;
  _DWORD *v5;
  unsigned int *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  double v11;
  uint64_t v12;
  int32x4_t v13;
  uint64_t i;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  int *v18;
  uint64_t j;
  uint64_t v20;
  uint64_t v21;
  _DWORD *v22;
  uint64_t k;
  unsigned int v24;
  uint64_t v25;
  uint64_t v27;
  int v28;
  int32x4_t __dst[34];
  double v30;
  double v31;
  int32x2_t v32;
  int v33;
  int32x2_t v34;
  int v35;
  int v36;
  _DWORD v37[5203];
  uint64_t v38;

  v1 = (unsigned int *)MEMORY[0x1E0C80A78](a1);
  v38 = *MEMORY[0x1E0C80C00];
  if (v1)
  {
    v4 = v2;
    if (v2)
    {
      v5 = v3;
      if (v3)
      {
        v6 = v1;
        if (*v1)
        {
          v7 = 0;
          v27 = v2 + 612;
          do
          {
            v8 = *(_QWORD *)&v6[1080 * v7 + 392];
            if (v8)
            {
              bzero(__dst, 0xA4F8uLL);
              VideoPacketBuffer_GetStatistics(v8, __dst);
              *(int32x4_t *)v4 = vaddq_s32(*(int32x4_t *)v4, __dst[0]);
              *(_DWORD *)(v4 + 42228) += v37[5202];
              *(double *)(v4 + 552) = v30 + *(double *)(v4 + 552);
              *(int32x2_t *)(v4 + 576) = vadd_s32(*(int32x2_t *)(v4 + 576), v32);
              *(_DWORD *)(v4 + 584) += v33;
              *(_DWORD *)(v4 + 608) += v35;
              v9 = 115;
              *(int32x2_t *)(v4 + 600) = vadd_s32(*(int32x2_t *)(v4 + 600), v34);
              do
              {
                *(_DWORD *)(v4 + v9 * 4) += __dst[0].i32[v9];
                ++v9;
              }
              while (v9 != 138);
              v10 = 0;
              v11 = *(double *)(v4 + 568);
              if (v11 <= v31)
                v11 = v31;
              *(double *)(v4 + 568) = v11;
              do
              {
                v12 = v4 + v10;
                *(int64x2_t *)(v12 + 16) = vaddq_s64(*(int64x2_t *)(v4 + v10 + 16), *(int64x2_t *)((char *)&__dst[1] + v10));
                v13 = *(int32x4_t *)((char *)&__dst[2] + v10 + 4);
                *(int32x4_t *)(v12 + 36) = vaddq_s32(*(int32x4_t *)(v4 + v10 + 36), v13);
                *(_DWORD *)(v12 + 32) = vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v13.i8, 1), v13), vaddq_s32(vdupq_laneq_s32(v13, 2), vdupq_laneq_s32(v13, 3))).u32[0]+ *(_DWORD *)(v4 + v10 + 32);
                v10 += 40;
              }
              while (v10 != 240);
              for (i = 128; i != 230; ++i)
              {
                v15 = *(unsigned __int16 *)(v4 + i * 2);
                if (v15 <= __dst[0].u16[i])
                  LOWORD(v15) = __dst[0].i16[i];
                *(_WORD *)(v4 + i * 2) = v15;
              }
              v16 = 0;
              v17 = v27;
              v18 = &v36;
              do
              {
                for (j = 0; j != 204; j += 2)
                  *(_WORD *)(v17 + j) += *(_WORD *)((char *)v18 + j);
                ++v16;
                v18 += 51;
                v17 += 204;
              }
              while (v16 != 102);
              v20 = 0;
              v21 = v4 + 21420;
              v22 = v37;
              do
              {
                for (k = 0; k != 204; k += 2)
                  *(_WORD *)(v21 + k) += *(_WORD *)((char *)v22 + k);
                ++v20;
                v22 += 51;
                v21 += 204;
              }
              while (v20 != 102);
            }
            v24 = *(_DWORD *)(v4 + 584);
            if (v24)
              *(double *)(v4 + 560) = *(double *)(v4 + 552) / (double)v24;
            v28 = 0;
            __dst[0].i32[0] = 0;
            RTPGetRecvStats(*(_QWORD *)&v6[1080 * v7 + 376], __dst, &v28);
            *v5 += __dst[0].i32[0];
            ++v7;
          }
          while (v7 < *v6);
        }
        return 0;
      }
      else
      {
        v25 = 2149515265;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VideoReceiver_GetVPBStats_cold_3();
        }
      }
    }
    else
    {
      v25 = 2149515265;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VideoReceiver_GetVPBStats_cold_2();
      }
    }
  }
  else
  {
    v25 = 2149515265;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VideoReceiver_GetVPBStats_cold_1();
    }
  }
  return v25;
}

void _VideoReceiver_ReportVideoPlayerStatsForReporting(uint64_t a1, __CFDictionary *a2)
{
  const __CFAllocator *v4;
  CFNumberRef v5;
  CFNumberRef v6;
  CFNumberRef v7;
  CFNumberRef v8;
  CFNumberRef v9;
  CFNumberRef v10;
  CFNumberRef v11;
  CFNumberRef v12;
  CFNumberRef v13;
  CFNumberRef v14;
  CFNumberRef v15;
  CFNumberRef v16;
  _QWORD v17[2];

  v17[1] = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a2)
    {
      LODWORD(v17[0]) = *(_DWORD *)(a1 + 144);
      v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, v17);
      CFDictionaryAddValue(a2, CFSTR("VPAVTDCount"), v5);
      CFRelease(v5);
      v17[0] = *(_QWORD *)(a1 + 128);
      v6 = CFNumberCreate(v4, kCFNumberDoubleType, v17);
      CFDictionaryAddValue(a2, CFSTR("VPAVTDSum"), v6);
      CFRelease(v6);
      v17[0] = *(_QWORD *)(a1 + 136);
      v7 = CFNumberCreate(v4, kCFNumberDoubleType, v17);
      CFDictionaryAddValue(a2, CFSTR("VPAVTDAbsSum"), v7);
      CFRelease(v7);
      v17[0] = *(_QWORD *)(a1 + 120);
      v8 = CFNumberCreate(v4, kCFNumberDoubleType, v17);
      CFDictionaryAddValue(a2, CFSTR("VPAVTDMax"), v8);
      CFRelease(v8);
      v17[0] = *(_QWORD *)(a1 + 112);
      v9 = CFNumberCreate(v4, kCFNumberDoubleType, v17);
      CFDictionaryAddValue(a2, CFSTR("VPAVTDMin"), v9);
      CFRelease(v9);
      LODWORD(v17[0]) = *(_DWORD *)(a1 + 104);
      v10 = CFNumberCreate(v4, kCFNumberIntType, v17);
      CFDictionaryAddValue(a2, CFSTR("VPAVSOCount"), v10);
      CFRelease(v10);
      v17[0] = *(_QWORD *)(a1 + 88);
      v11 = CFNumberCreate(v4, kCFNumberDoubleType, v17);
      CFDictionaryAddValue(a2, CFSTR("VPAVSOSum"), v11);
      CFRelease(v11);
      v17[0] = *(_QWORD *)(a1 + 96);
      v12 = CFNumberCreate(v4, kCFNumberDoubleType, v17);
      CFDictionaryAddValue(a2, CFSTR("VPAVSOAbsSum"), v12);
      CFRelease(v12);
      v17[0] = *(_QWORD *)(a1 + 80);
      v13 = CFNumberCreate(v4, kCFNumberDoubleType, v17);
      CFDictionaryAddValue(a2, CFSTR("VPAVSOMax"), v13);
      CFRelease(v13);
      v17[0] = *(_QWORD *)(a1 + 72);
      v14 = CFNumberCreate(v4, kCFNumberDoubleType, v17);
      CFDictionaryAddValue(a2, CFSTR("VPAVSOMin"), v14);
      CFRelease(v14);
      LODWORD(v17[0]) = *(_DWORD *)(a1 + 152);
      v15 = CFNumberCreate(v4, kCFNumberIntType, v17);
      CFDictionaryAddValue(a2, CFSTR("VPDECAC"), v15);
      CFRelease(v15);
      LODWORD(v17[0]) = *(_DWORD *)(a1 + 156);
      v16 = CFNumberCreate(v4, kCFNumberIntType, v17);
      CFDictionaryAddValue(a2, CFSTR("VPDISAC"), v16);
      CFRelease(v16);
    }
  }
}

void VideoReceiverConfig_CleanupFeatureStrings(_DWORD *a1)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  const void *v5;

  v2 = *a1;
  if ((_DWORD)v2)
  {
    v3 = 0;
    v4 = 16;
    do
    {
      v5 = *(const void **)&a1[v4];
      if (v5)
      {
        CFRelease(v5);
        *(_QWORD *)&a1[v4] = 0;
        v2 = *a1;
      }
      ++v3;
      v4 += 28;
    }
    while (v3 < v2);
  }
  *a1 = 0;
}

uint64_t _VideoReceiver_CloseSummers(uint64_t a1)
{
  _QWORD *v1;
  uint64_t result;

  v1 = (_QWORD *)(a1 + 40392);
  if (*(_QWORD *)(a1 + 40392) != 0xFFFFFFFFLL)
    SummerCloseHandle();
  if (v1[1] != 0xFFFFFFFFLL)
    SummerCloseHandle();
  if (v1[4] != 0xFFFFFFFFLL)
    SummerCloseHandle();
  if (v1[2] != 0xFFFFFFFFLL)
    SummerCloseHandle();
  result = v1[3];
  if (result != 0xFFFFFFFFLL)
    return SummerCloseHandle();
  return result;
}

uint64_t _VideoReceiver_CreateSummers(uint64_t *a1)
{
  if ((SummerCreateHandle(a1 + 5049, 400) & 0x80000000) == 0
    && (SummerCreateHandle(a1 + 5050, 400) & 0x80000000) == 0
    && (SummerCreateHandle(a1 + 5053, 400) & 0x80000000) == 0
    && (SummerCreateHandle(a1 + 5051, 400) & 0x80000000) == 0
    && (SummerCreateHandle(a1 + 5052, 400) & 0x80000000) == 0)
  {
    return 1;
  }
  _VideoReceiver_CloseSummers((uint64_t)a1);
  return 0;
}

uint64_t VideoReceiver_CreateHandle(uint64_t *a1, uint64_t a2, const void *a3, _OWORD *a4, const void *a5)
{
  char *v10;
  char *v11;
  const void *v12;
  const void *v13;
  unint64_t v14;
  const void **v15;
  CFAllocatorRef **v16;
  uint64_t v17;
  const void *v18;
  unint64_t v19;
  unsigned int IsInternalOSInstalled;
  CFTypeRef *v21;
  __int16 v22;
  CFTypeRef v23;
  CFTypeRef v24;
  int v25;
  const __CFAllocator *v26;
  OpaqueCMMemoryPool *v27;
  CFAllocatorRef Allocator;
  CFTypeRef v29;
  const void *v30;
  const void *v31;
  uint64_t v32;
  NSObject *v33;
  FILE *v34;
  uint64_t v35;
  NSObject *v36;
  FILE *v37;
  unint64_t v38;
  CFTypeRef **v39;
  uint64_t v40;
  NSObject *v41;
  FILE *v42;
  const char *CStringPtr;
  char *v44;
  unsigned int v45;
  __int128 v46;
  uint64_t v47;
  NSObject *v48;
  unsigned int v49;
  uint64_t v50;
  uint64_t Handle;
  uint64_t v52;
  unint64_t v53;
  unint64_t v54;
  uint64_t *v55;
  _OWORD *v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  uint64_t v62;
  NSObject *v63;
  unsigned int v64;
  int v65;
  int v66;
  uint64_t v67;
  unsigned int v68;
  char *v69;
  double JitterBufferMaxQueueSize;
  unsigned int v71;
  uint64_t v72;
  int v73;
  __int128 v74;
  NSObject *CustomRootQueue;
  dispatch_queue_t v76;
  _QWORD *v77;
  uint64_t v78;
  CFTypeRef v79;
  uint64_t OverlaySourceForToken;
  unint64_t v81;
  CFTypeRef **v82;
  unint64_t v83;
  CFTypeRef **v84;
  uint64_t v86;
  int v87;
  _QWORD *v88;
  unint64_t v89;
  unint64_t v90;
  uint64_t v91;
  uint64_t v92;
  unint64_t v93;
  CFTypeRef **v94;
  const void *v95;
  const void *v96;
  const void *v97;
  FILE *v98;
  FILE *v99;
  FILE *v100;
  FILE *v101;
  NSObject *v102;
  const void *v103;
  const void *v104;
  OpaqueCMMemoryPool *v105;
  const void *v106;
  const void *v107;
  CFTypeRef *v108;
  CFTypeRef *v109;
  uint64_t *v110;
  uint64_t *v111;
  _OWORD *v112;
  char *v113;
  int v114[2];
  uint64_t v115;
  uint64_t v116;
  void (*v117)(uint64_t, __CVBuffer *, __int128 *, uint64_t);
  uint64_t v118;
  _BYTE v119[4];
  int v120;
  __int128 v121;
  __int128 v122;
  __int128 v123;
  uint64_t v124;
  _BYTE buf[224];
  _BYTE v126[80];
  uint64_t v127;
  uint64_t v128;

  v128 = *MEMORY[0x1E0C80C00];
  if (!*(_DWORD *)a2 || !*(_BYTE *)(a2 + 1192) && !*(_DWORD *)(a2 + 1256))
    return 2149515265;
  v10 = (char *)malloc_type_calloc(1uLL, 0xA300uLL, 0x10E004051797852uLL);
  if (v10)
  {
    v11 = v10;
    v113 = v10 + 40356;
    memcpy(v10, (const void *)a2, 0x568uLL);
    v12 = (const void *)*((_QWORD *)v11 + 154);
    if (v12)
      CFRetain(v12);
    v13 = (const void *)*((_QWORD *)v11 + 155);
    if (v13)
      CFRetain(v13);
    v112 = a4;
    v111 = a1;
    *(_DWORD *)v113 = *((_DWORD *)v11 + 254);
    if (*(_DWORD *)v11)
    {
      v14 = 0;
      v15 = (const void **)(v11 + 80);
      v16 = (CFAllocatorRef **)(v11 + 5728);
      v17 = 2;
      while (1)
      {
        v18 = *(v15 - 2);
        if (v18)
          CFRetain(v18);
        if (*v15)
        {
          v17 = VCSFrameCryptorH264_Create(*v15, v16);
          v19 = *(unsigned int *)v11;
          if ((_DWORD)v17)
          {
            if (*(_DWORD *)v11)
            {
              v38 = 0;
              v39 = (CFTypeRef **)(v11 + 5728);
              do
              {
                VCSFrameCryptorH264_Destroy(v39);
                ++v38;
                v39 += 540;
              }
              while (v38 < *(unsigned int *)v11);
            }
            goto LABEL_120;
          }
        }
        else
        {
          v19 = *(unsigned int *)v11;
        }
        ++v14;
        v15 += 14;
        v16 += 540;
        if (v14 >= v19)
          goto LABEL_21;
      }
    }
    v17 = 2;
LABEL_21:
    if (VCDefaults_GetBoolValueForKey(CFSTR("SupportsOneToOneMode"), 0) || *(_DWORD *)v113 || v11[1183])
    {
      if (*(_DWORD *)(a2 + 1068))
        IsInternalOSInstalled = VRTraceIsInternalOSInstalled();
      else
        IsInternalOSInstalled = 0;
      v21 = (CFTypeRef *)(v11 + 40648);
      *((_DWORD *)v11 + 267) = IsInternalOSInstalled;
      v11[1164] = VCDefaults_GetBoolValueForKey(CFSTR("forceUseInternalRTPThreading"), *(unsigned __int8 *)(a2 + 1164));
      v11[1191] = VCDefaults_GetBoolValueForKey(CFSTR("enableDynamicVideoJitterBufferModeChange"), 0);
      if (*(_DWORD *)(a2 + 1020) == 2)
        v22 = 16;
      else
        v22 = 5;
      *((_WORD *)v11 + 609) = v22;
      v11[1261] = VCDefaults_GetBoolValueForKey(CFSTR("useRTTForFIRThrottling"), 0);
      if (*((double *)v11 + 170) == 0.0)
        *((double *)v11 + 170) = VCDefaults_GetDoubleValueForKey(CFSTR("noVideoDisplayFailSafeTimeout"), 5.0);
      v23 = (CFTypeRef)*((_QWORD *)v11 + 150);
      if (v23)
        v23 = CFRetain(v23);
      *v21 = v23;
      _VideoReceiver_UpdateMediaControlInfo((uint64_t)v11);
      *((_DWORD *)v11 + 10393) = *(_DWORD *)(a2 + 1212);
      if (a3)
        v24 = CFRetain(a3);
      else
        v24 = 0;
      *((_QWORD *)v11 + 5082) = v24;
      *((_DWORD *)v11 + 10358) = VCReporting_GetDynamicReportingModuleID();
      reportingInheritModuleSpecificInfoFromParent();
      *((_QWORD *)v11 + 180) = *(_QWORD *)(a2 + 1144);
      *((_QWORD *)v11 + 175) = *(_QWORD *)(a2 + 1104);
      *((_QWORD *)v11 + 176) = *(_QWORD *)(a2 + 1120);
      *(_OWORD *)(v11 + 1384) = *(_OWORD *)(a2 + 1088);
      *((_QWORD *)v11 + 177) = 0;
      *((_OWORD *)v11 + 89) = *(_OWORD *)(a2 + 1128);
      *(_QWORD *)(v113 + 76) = 0xFFFFFFFFLL;
      *(_QWORD *)(v113 + 28) = 0xFFFFFFFFLL;
      *(_QWORD *)(v113 + 84) = 0xFFFFFFFFLL;
      *(_QWORD *)(v11 + 40812) = 0;
      *((_DWORD *)v11 + 10278) = 0;
      *((_QWORD *)v11 + 5143) = 0;
      *((_OWORD *)v11 + 2568) = 0u;
      *((_OWORD *)v11 + 2570) = 0u;
      v11[41152] = *(_BYTE *)(a2 + 1040);
      *((_DWORD *)v11 + 10318) = 0;
      v11[41276] = 0;
      *((_OWORD *)v11 + 2545) = 0u;
      *(_OWORD *)(v11 + 41064) = 0u;
      *((_QWORD *)v11 + 5135) = 0x7FEFFFFFFFFFFFFFLL;
      *((double *)v11 + 5096) = micro();
      *((_QWORD *)v11 + 5199) = 0x3FD0000000000000;
      v11[41673] = 1;
      *((_WORD *)v11 + 20750) = 0;
      v11[41440] = *(_BYTE *)(a2 + 1076);
      v25 = 2 * *((unsigned __int16 *)v11 + 609);
      *((_QWORD *)v11 + 5197) = 0;
      *((double *)v11 + 5198) = (double)v25;
      v110 = (uint64_t *)(v113 + 76);
      v113[20] = 0;
      *((_DWORD *)v11 + 10409) = -1;
      *((_QWORD *)v11 + 5211) = 0;
      *((_DWORD *)v11 + 10289) = 0;
      v11[41696] = _os_feature_enabled_impl();
      *((_QWORD *)v11 + 5213) = 0x7FF8000000000000;
      v26 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v109 = (CFTypeRef *)(v11 + 41288);
      CMSimpleQueueCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 2000, (CMSimpleQueueRef *)v11 + 5161);
      CMSimpleQueueCreate(v26, (int)*((double *)v11 + 5198), (CMSimpleQueueRef *)v11 + 5162);
      pthread_mutex_init((pthread_mutex_t *)(v11 + 41304), 0);
      v27 = CMMemoryPoolCreate(0);
      *((_QWORD *)v11 + 5172) = v27;
      Allocator = CMMemoryPoolGetAllocator(v27);
      *((_QWORD *)v11 + 5173) = Allocator;
      CFRetain(Allocator);
      v11[41504] = *(_BYTE *)(a2 + 1192);
      v29 = a5;
      if (a5)
        v29 = CFRetain(a5);
      *((_QWORD *)v11 + 5175) = v29;
      *((_QWORD *)v11 + 5184) = 0x7FF8000000000000;
      *((_QWORD *)v11 + 5183) = 0x7FF8000000000000;
      *((_QWORD *)v11 + 5185) = 0x7FF8000000000000;
      if (v112)
        *(_OWORD *)(v11 + 41240) = *v112;
      v11[41160] = 0;
      v11[41176] = 0;
      *((_QWORD *)v11 + 5146) = 0;
      *((_QWORD *)v11 + 5148) = 0;
      *((_QWORD *)v11 + 5154) = 0;
      *((_QWORD *)v11 + 5150) = 0;
      v30 = (const void *)*((_QWORD *)v11 + 5201);
      v31 = *(const void **)(a2 + 1224);
      *((_QWORD *)v11 + 5201) = v31;
      if (v31)
        CFRetain(v31);
      if (v30)
        CFRelease(v30);
      if (VRTraceIsInternalOSInstalled())
      {
        v11[41160] = CFPreferencesGetAppBooleanValue(CFSTR("enableReceiverPacketDump"), CFSTR("com.apple.VideoConference"), 0) != 0;
        v11[41176] = CFPreferencesGetAppBooleanValue(CFSTR("enableReceiverFrameDump"), CFSTR("com.apple.VideoConference"), 0) != 0;
        v11[41193] = CFPreferencesGetAppBooleanValue(CFSTR("enablePacketLogging"), CFSTR("com.apple.VideoConference"), 0) != 0;
        v11[41192] = VCDefaults_GetBoolValueForKey(CFSTR("enableLTRPLogging"), 0);
        v11[41195] = CFPreferencesGetAppBooleanValue(CFSTR("enableReceiverRtpPacketDumpAsCsv"), CFSTR("com.apple.VideoConference"), 0) != 0;
        v11[41194] = VCDefaults_GetBoolValueForKey(CFSTR("enableNACKLogging"), 0);
      }
      if (v11[41160])
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
        {
          v32 = VRTraceErrorLogLevelToCSTR();
          v33 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315906;
            *(_QWORD *)&buf[4] = v32;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "VideoReceiver_CreateHandle";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 4907;
            *(_WORD *)&buf[28] = 2048;
            *(_QWORD *)&buf[30] = v11;
            _os_log_impl(&dword_1D8A54000, v33, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Found enableReceiverPacketDump YES. Log incoming video packets into AFRC folder", buf, 0x26u);
          }
        }
        memset(buf, 170, 12);
        __sprintf_chk(buf, 0, 0xCuLL, "%010u", *((_DWORD *)v11 + 262));
        v34 = openLogDump(0, (uint64_t)buf, 1, (uint64_t)"in_pkt", (uint64_t)".txt", 0);
        *((_QWORD *)v11 + 5146) = v34;
        if (!v34 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VideoReceiver_CreateHandle_cold_13();
        }
      }
      if (v11[41195])
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
        {
          v35 = VRTraceErrorLogLevelToCSTR();
          v36 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315906;
            *(_QWORD *)&buf[4] = v35;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "VideoReceiver_CreateHandle";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 4917;
            *(_WORD *)&buf[28] = 2048;
            *(_QWORD *)&buf[30] = v11;
            _os_log_impl(&dword_1D8A54000, v36, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Found enableReceiverRtpPacketDumpAsCsv YES. Log incoming video rtp packets into AFRC folder", buf, 0x26u);
          }
        }
        memset(buf, 170, 12);
        __sprintf_chk(buf, 0, 0xCuLL, "%010u", *((_DWORD *)v11 + 262));
        v37 = openLogDump(0, (uint64_t)buf, 1, (uint64_t)"received_rtp_pkts", (uint64_t)".txt", 0);
        *((_QWORD *)v11 + 5150) = v37;
        if (v37)
        {
          fwrite("Video RTP Packet Dump File. Please modify the extension to .csv.\n\nInstructions:\nRTPMediaPacket header: One row per packet. Contains all the information relevant to the rtp header.\nRTPMediaPacket data: Several rows per packet. Carries the data dump.\nRTPMediaPacket extData: One row per packet. Dumps the extension data.\n\n", 0x140uLL, 1uLL, v37);
        }
        else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VideoReceiver_CreateHandle_cold_12();
        }
      }
      v11[41720] = 0;
      if (v11[41176])
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
        {
          v40 = VRTraceErrorLogLevelToCSTR();
          v41 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315906;
            *(_QWORD *)&buf[4] = v40;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "VideoReceiver_CreateHandle";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 4930;
            *(_WORD *)&buf[28] = 2048;
            *(_QWORD *)&buf[30] = v11;
            _os_log_impl(&dword_1D8A54000, v41, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Found enableReceiverFrameDump YES. Log incoming video frames into AFRC folder", buf, 0x26u);
          }
        }
        memset(buf, 170, 12);
        __sprintf_chk(buf, 0, 0xCuLL, "%010u", *((_DWORD *)v11 + 262));
        v42 = openLogDump(0, (uint64_t)buf, 1, (uint64_t)"in_frame", (uint64_t)".txt", 0);
        *((_QWORD *)v11 + 5148) = v42;
        if (!v42 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VideoReceiver_CreateHandle_cold_11();
        }
      }
      CStringPtr = CFStringGetCStringPtr(*((CFStringRef *)v11 + 154), 0x8000100u);
      v44 = FourccToCStr(*((_DWORD *)v11 + 312));
      *((_QWORD *)v11 + 5208) = VRDump_OpenDumpFile(CStringPtr, v44, *((_DWORD *)v11 + 259), (char)v11);
      if (*(_DWORD *)v113 != 1)
        VideoReceiver_DumpRecvCreate((uint64_t)v11, 0);
      v45 = *((_DWORD *)v11 + 265);
      if (v45 == 1)
      {
        *(_QWORD *)&v46 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v46 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)v126 = v46;
        *(_OWORD *)&v126[16] = v46;
        *(_OWORD *)&buf[192] = v46;
        *(_OWORD *)&buf[208] = v46;
        *(_OWORD *)&buf[160] = v46;
        *(_OWORD *)&buf[176] = v46;
        *(_OWORD *)&buf[128] = v46;
        *(_OWORD *)&buf[144] = v46;
        *(_OWORD *)&buf[96] = v46;
        *(_OWORD *)&buf[112] = v46;
        *(_OWORD *)&buf[64] = v46;
        *(_OWORD *)&buf[80] = v46;
        *(_OWORD *)&buf[32] = v46;
        *(_OWORD *)&buf[48] = v46;
        *(_OWORD *)buf = v46;
        *(_OWORD *)&buf[16] = v46;
        _VideoReceiverUtil_Generate2vuyName(buf, 0x100uLL);
        *((_QWORD *)v11 + 5153) = fopen(buf, "wb");
        v45 = *((_DWORD *)v11 + 265);
      }
      if (v45 == 2)
        VCDiskUtils_CreateDirectory();
      if ((_VideoReceiver_CreateSummers((uint64_t *)v11) & 1) == 0)
      {
        VideoReceiverConfig_CleanupFeatureStrings(v11);
        if (*(_DWORD *)v11)
        {
          v81 = 0;
          v82 = (CFTypeRef **)(v11 + 5728);
          do
          {
            VCSFrameCryptorH264_Destroy(v82);
            ++v81;
            v82 += 540;
          }
          while (v81 < *(unsigned int *)v11);
        }
        goto LABEL_120;
      }
      if (v11[1181])
      {
        if (!v11[1077] && (int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          v47 = VRTraceErrorLogLevelToCSTR();
          v48 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = v47;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "VideoReceiver_CreateHandle";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 4963;
            _os_log_impl(&dword_1D8A54000, v48, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d Display link should be enabled for this configuration!", buf, 0x1Cu);
          }
        }
      }
      v121 = 0u;
      v122 = 0u;
      v123 = 0u;
      v119[0] = v11[41504];
      v49 = *((_DWORD *)v11 + 259);
      v119[1] = v11[1182];
      v119[2] = v11[1188];
      v119[3] = v11[1181];
      *(_QWORD *)&v122 = *((_QWORD *)v11 + 5082);
      v120 = *(_DWORD *)(a2 + 1020);
      LODWORD(v121) = v49;
      WORD4(v122) = *((_WORD *)v11 + 609);
      BYTE10(v122) = v11[1217];
      v50 = *((_QWORD *)v11 + 170);
      *(_QWORD *)&v123 = *((_QWORD *)v11 + 169);
      v124 = v50;
      v17 = VCVideoPlayer_Create(v110, (__int128 *)v119);
      v108 = (CFTypeRef *)(v11 + 41296);
      if ((v17 & 0x80000000) == 0)
      {
        VCVideoPlayer_RegisterForNoVideoDisplayedTimeoutCallbacks(*v110, (uint64_t)_VideoReceiver_NoVideoDisplayedTimeoutCallback, (uint64_t)v111);
        if (VCAllocatorFirstCome_Create(v26, (uint64_t)"VideoReceiverBlockBufferHeaderAllocator", (CFAllocatorRef *)v11 + 5186))
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VideoReceiver_CreateHandle_cold_10();
          }
        }
        else if (VCAllocatorFirstCome_Create(v26, (uint64_t)"VideoReceiverNumberPropertyAllocator", (CFAllocatorRef *)v11 + 5189))
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VideoReceiver_CreateHandle_cold_9();
          }
        }
        else
        {
          if (!VCAllocatorFirstCome_Create(v26, (uint64_t)"VideoReceiverDecodedFrameAllocator", (CFAllocatorRef *)v11 + 5176))
          {
            if (VCAllocatorFirstCome_Create(v26, (uint64_t)"VideoReceiverFormatDescriptionAllocator", (CFAllocatorRef *)v11 + 5177))
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  VideoReceiver_CreateHandle_cold_7();
              }
            }
            else if (VCAllocatorFirstCome_Create(v26, (uint64_t)"VideoReceiverSampleBufferAllocator", (CFAllocatorRef *)v11 + 5178))
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  VideoReceiver_CreateHandle_cold_6();
              }
            }
            else
            {
              Handle = CreateHandle();
              if (Handle != 0xFFFFFFFFLL)
              {
                v52 = Handle;
                pthread_mutex_init((pthread_mutex_t *)(v11 + 40456), 0);
                pthread_mutex_init((pthread_mutex_t *)(v11 + 40520), 0);
                pthread_mutex_init((pthread_mutex_t *)(v11 + 40584), 0);
                v53 = *(unsigned int *)v11;
                if ((_DWORD)v53)
                {
                  v54 = 0;
                  v55 = (uint64_t *)(v11 + 1584);
                  v56 = v11 + 8;
                  do
                  {
                    v57 = v56[5];
                    v58 = v56[6];
                    v59 = v56[3];
                    *((_OWORD *)v55 - 4) = v56[4];
                    v60 = v56[1];
                    v61 = v56[2];
                    *((_OWORD *)v55 - 8) = *v56;
                    *((_OWORD *)v55 - 7) = v60;
                    *((_OWORD *)v55 - 3) = v57;
                    *((_OWORD *)v55 - 2) = v58;
                    *((_OWORD *)v55 - 6) = v61;
                    *((_OWORD *)v55 - 5) = v59;
                    *((_BYTE *)v55 - 60) = v54;
                    *v55 = v52;
                    ++v54;
                    v55 += 540;
                    v56 += 7;
                  }
                  while (v54 < v53);
                }
                *(_QWORD *)(v113 + 4) = v11 + 1456;
                if ((int)VRTraceGetErrorLogLevelForModule() > 6)
                {
                  v62 = VRTraceErrorLogLevelToCSTR();
                  v63 = *MEMORY[0x1E0CF2758];
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                  {
                    v64 = *((_DWORD *)v11 + 259);
                    v65 = v11[1180];
                    v66 = v11[1181];
                    *(_DWORD *)buf = 136317186;
                    *(_QWORD *)&buf[4] = v62;
                    *(_WORD *)&buf[12] = 2080;
                    *(_QWORD *)&buf[14] = "VideoReceiver_CreateHandle";
                    *(_WORD *)&buf[22] = 1024;
                    *(_DWORD *)&buf[24] = 5020;
                    *(_WORD *)&buf[28] = 2048;
                    *(_QWORD *)&buf[30] = v52;
                    *(_WORD *)&buf[38] = 2048;
                    *(_QWORD *)&buf[40] = v11;
                    *(_WORD *)&buf[48] = 1024;
                    *(_DWORD *)&buf[50] = v64;
                    *(_WORD *)&buf[54] = 1024;
                    *(_DWORD *)&buf[56] = v65;
                    *(_WORD *)&buf[60] = 1024;
                    *(_DWORD *)&buf[62] = v66;
                    *(_WORD *)&buf[66] = 2048;
                    *(_QWORD *)&buf[68] = v113 + 76;
                    _os_log_impl(&dword_1D8A54000, v63, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d Created VideoReceiver handle=%p for videoReceiver=%p, videoReceiver->config.videoTSRate=%d, videoReceiver->config.enableJitterBufferInReceiver=%d, videoReceiver->config.enableJitterBufferInPlayer=%d, videoPlayerHandlePtr=%p", buf, 0x4Cu);
                  }
                }
                if (v11[1180])
                {
                  v67 = *((_QWORD *)v11 + 5201);
                  *(_QWORD *)v126 = 0xAAAAAAAAAAAAAAAALL;
                  memset(&buf[32], 170, 192);
                  *(_DWORD *)&buf[200] = *((_DWORD *)v11 + 255);
                  *(_QWORD *)&buf[208] = *((_QWORD *)v11 + 5082);
                  v68 = *((_DWORD *)v11 + 259);
                  *(_DWORD *)&buf[216] = *((_DWORD *)v11 + 294);
                  *(_DWORD *)&buf[220] = v68;
                  v126[0] = 1;
                  memset(buf, 0, 200);
                  buf[204] = 0;
                  *(_QWORD *)&v126[8] = v67;
                  *(_DWORD *)&v126[4] = *((_DWORD *)v11 + 312);
                  *(_QWORD *)&v126[16] = *((_QWORD *)v11 + 171);
                  _VCVideoReceiver_InitDumpFileName((uint64_t)v11, buf);
                  v69 = VCVideoJitterBuffer_Create((uint64_t)buf);
                  *((_QWORD *)v11 + 5190) = v69;
                  JitterBufferMaxQueueSize = VCVideoJitterBuffer_GetJitterBufferMaxQueueSize((uint64_t)v69);
                  *((double *)v11 + 5200) = VCDefaults_GetDoubleValueForKey(CFSTR("framesForDecodeQueueHighWatermarkSeconds"), JitterBufferMaxQueueSize + JitterBufferMaxQueueSize);
                }
                *((_DWORD *)v11 + 363) = -1;
                if (v11[1164])
                {
                  v71 = VTP_Socket(2, 1, 6);
                  *((_DWORD *)v11 + 363) = v71;
                  if (v71 == -1)
                  {
                    v17 = *__error() | 0xC01F0000;
                    goto LABEL_154;
                  }
                }
                v72 = *((_QWORD *)v11 + 128);
                v115 = *((_QWORD *)v11 + 5082);
                v116 = 0;
                v117 = _VideoReceiver_DecoderCallback;
                v118 = v52;
                v73 = v11[1184];
                v114[0] = v72;
                v114[1] = v73;
                v116 = v73 ^ 1u;
                BYTE1(v116) = v73;
                VCVideoDecoder_NewVideoDecoder(v113 + 84, v114);
                *((_DWORD *)v11 + 10359) = reportingDefaultRealtimePeriod();
                *(_QWORD *)buf = MEMORY[0x1E0C809B0];
                *(_QWORD *)&buf[8] = 0x40000000;
                *(_QWORD *)&buf[16] = ___VideoReceiver_ReportingRegisterPeriodicTask_block_invoke;
                *(_QWORD *)&buf[24] = &__block_descriptor_tmp_302;
                *(_QWORD *)&buf[32] = v52;
                reportingRegisterPeriodicTask();
                if (*((_DWORD *)v11 + 261))
                {
                  *(_QWORD *)&buf[192] = 0xAAAAAAAAAAAAAAAALL;
                  *(_QWORD *)&v74 = 0xAAAAAAAAAAAAAAAALL;
                  *((_QWORD *)&v74 + 1) = 0xAAAAAAAAAAAAAAAALL;
                  *(_OWORD *)&buf[160] = v74;
                  *(_OWORD *)&buf[176] = v74;
                  *(_OWORD *)&buf[128] = v74;
                  *(_OWORD *)&buf[144] = v74;
                  *(_OWORD *)&buf[96] = v74;
                  *(_OWORD *)&buf[112] = v74;
                  *(_OWORD *)&buf[64] = v74;
                  *(_OWORD *)&buf[80] = v74;
                  *(_OWORD *)&buf[32] = v74;
                  *(_OWORD *)&buf[48] = v74;
                  *(_OWORD *)buf = v74;
                  *(_OWORD *)&buf[16] = v74;
                  _VCVideoReceiver_InitDumpFileName((uint64_t)v11, buf);
                  *((_QWORD *)v11 + 5154) = VideoPacketDump_OpenRTPLog((uint64_t)buf);
                }
                CustomRootQueue = VCDispatchQueue_GetCustomRootQueue(56);
                v76 = dispatch_queue_create_with_target_V2("com.apple.AVConference.VideoReceiver.rtcpSendQueue", 0, CustomRootQueue);
                *((_QWORD *)v11 + 5092) = v76;
                if (v76)
                {
                  v77 = VCMemoryPool_Create(0x800uLL);
                  *((_QWORD *)v11 + 5174) = v77;
                  if (v77)
                  {
                    if (!v11[1260])
                      goto LABEL_112;
                    v78 = *((_QWORD *)v11 + 154);
                    v127 = 0;
                    memset(&v126[16], 0, 64);
                    *(_OWORD *)v126 = 0u;
                    memset(&buf[32], 0, 192);
                    buf[32] = v11[41194];
                    *(_QWORD *)&v126[60] = *((_QWORD *)v11 + 164);
                    *(_QWORD *)buf = _VideoReceiver_SendNACK;
                    *(_QWORD *)&buf[8] = v11;
                    *(_OWORD *)&buf[16] = 0uLL;
                    *(_OWORD *)&v126[44] = *((_OWORD *)v11 + 81);
                    *(_OWORD *)&v126[12] = *((_OWORD *)v11 + 79);
                    *(_OWORD *)&v126[28] = *((_OWORD *)v11 + 80);
                    *(_DWORD *)&v126[68] = *((_DWORD *)v11 + 259);
                    *(_QWORD *)&v126[72] = v78;
                    LODWORD(v127) = *((_DWORD *)v11 + 312);
                    _VCVideoReceiver_InitDumpFileName((uint64_t)v11, &buf[33]);
                    if (!VCNACKGenerator_Create((uint64_t)v26, (uint64_t *)v11 + 5203, (uint64_t)buf))
                    {
                      _VideoReceiver_ReportRTXConfiguration((unsigned __int8 *)v11);
LABEL_112:
                      _VideoReceiver_RegisterStatistics((uint64_t)v11);
                      v79 = *(CFTypeRef *)(a2 + 1328);
                      if (v79)
                        v79 = CFRetain(v79);
                      *((_QWORD *)v11 + 5205) = v79;
                      if ((VCOverlayManager_isOverlayEnabled() & 1) != 0)
                      {
                        OverlaySourceForToken = VCOverlayManager_createOverlaySourceForToken(*((_QWORD *)v11 + 168), 1u);
                        *((_QWORD *)v11 + 5207) = OverlaySourceForToken;
                        if (!OverlaySourceForToken)
                          goto LABEL_123;
                      }
                      else
                      {
                        OverlaySourceForToken = *((_QWORD *)v11 + 5207);
                        if (!OverlaySourceForToken)
                        {
LABEL_123:
                          v17 = 0;
                          *((double *)v11 + 5214) = micro();
                          *v111 = v52;
                          *(_WORD *)(v11 + 41721) = 0;
                          return v17;
                        }
                      }
                      *(_QWORD *)(*(_QWORD *)(OverlaySourceForToken + 40) + 16) = *((_QWORD *)v11 + 154);
                      *(_QWORD *)(*(_QWORD *)(*((_QWORD *)v11 + 5207) + 48) + 16) = *((_QWORD *)v11 + 154);
                      *(_QWORD *)(*(_QWORD *)(*((_QWORD *)v11 + 5207) + 56) + 16) = *((_QWORD *)v11 + 154);
                      goto LABEL_123;
                    }
                    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                    {
                      VRTraceErrorLogLevelToCSTR();
                      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                        VideoReceiver_CreateHandle_cold_5();
                    }
                    goto LABEL_154;
                  }
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                  {
                    VRTraceErrorLogLevelToCSTR();
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                      VideoReceiver_CreateHandle_cold_4();
                  }
                }
                else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                {
                  VRTraceErrorLogLevelToCSTR();
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                    VideoReceiver_CreateHandle_cold_3();
                }
                goto LABEL_143;
              }
              v17 = 2149515269;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                {
                  VideoReceiver_CreateHandle_cold_2();
                  v17 = 2149515269;
                }
              }
            }
LABEL_153:
            v52 = 0xFFFFFFFFLL;
            goto LABEL_154;
          }
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VideoReceiver_CreateHandle_cold_8();
          }
        }
        v52 = 0xFFFFFFFFLL;
LABEL_143:
        v17 = 2149515267;
LABEL_154:
        v86 = *((_QWORD *)v11 + 5154);
        if (v86)
          VideoPacketDump_CloseRTPLog(v86);
        if (v11[1164])
        {
          v87 = *((_DWORD *)v11 + 363);
          if (v87 != -1)
            VTP_Close(v87);
        }
        v88 = (_QWORD *)*((_QWORD *)v11 + 5190);
        if (v88)
          VCVideoJitterBuffer_Finalize(v88);
        v89 = *(unsigned int *)v11;
        if ((_DWORD)v89)
        {
          v90 = 0;
          v91 = 1568;
          do
          {
            v92 = *(_QWORD *)&v11[v91];
            if (v92)
            {
              VideoPacketBuffer_Destroy(v92);
              *(_QWORD *)&v11[v91] = 0;
              v89 = *(unsigned int *)v11;
            }
            ++v90;
            v91 += 4320;
          }
          while (v90 < v89);
          if (v89)
          {
            v93 = 0;
            v94 = (CFTypeRef **)(v11 + 5728);
            do
            {
              VCSFrameCryptorH264_Destroy(v94);
              ++v93;
              v94 += 540;
            }
            while (v93 < *(unsigned int *)v11);
          }
        }
        pthread_mutex_destroy((pthread_mutex_t *)(v11 + 40584));
        pthread_mutex_destroy((pthread_mutex_t *)(v11 + 40520));
        pthread_mutex_destroy((pthread_mutex_t *)(v11 + 40456));
        if (v52 != 0xFFFFFFFFLL)
          VideoReceiver_CloseHandle();
        v95 = (const void *)*((_QWORD *)v11 + 5176);
        if (v95)
        {
          CFRelease(v95);
          *((_QWORD *)v11 + 5176) = 0;
        }
        v96 = (const void *)*((_QWORD *)v11 + 5189);
        if (v96)
        {
          CFRelease(v96);
          *((_QWORD *)v11 + 5189) = 0;
        }
        v97 = (const void *)*((_QWORD *)v11 + 5186);
        if (v97)
        {
          CFRelease(v97);
          *((_QWORD *)v11 + 5186) = 0;
        }
        VCVideoPlayer_Destroy(v110);
        _VideoReceiver_CloseSummers((uint64_t)v11);
        v98 = (FILE *)*((_QWORD *)v11 + 5153);
        if (v98)
          fclose(v98);
        v99 = (FILE *)*((_QWORD *)v11 + 5148);
        if (v99)
          fclose(v99);
        v100 = (FILE *)*((_QWORD *)v11 + 5146);
        if (v100)
          fclose(v100);
        v101 = (FILE *)*((_QWORD *)v11 + 5150);
        if (v101)
          fclose(v101);
        v102 = *((_QWORD *)v11 + 5092);
        if (v102)
          dispatch_release(v102);
        VideoReceiverConfig_CleanupFeatureStrings(v11);
        v103 = (const void *)*((_QWORD *)v11 + 5175);
        if (v103)
        {
          CFRelease(v103);
          *((_QWORD *)v11 + 5175) = 0;
        }
        v104 = (const void *)*((_QWORD *)v11 + 5173);
        if (v104)
        {
          CFRelease(v104);
          *((_QWORD *)v11 + 5173) = 0;
        }
        v105 = (OpaqueCMMemoryPool *)*((_QWORD *)v11 + 5172);
        if (v105)
        {
          CMMemoryPoolInvalidate(v105);
          v106 = (const void *)*((_QWORD *)v11 + 5172);
          if (v106)
          {
            CFRelease(v106);
            *((_QWORD *)v11 + 5172) = 0;
          }
        }
        if (*v108)
        {
          CFRelease(*v108);
          *v108 = 0;
        }
        pthread_mutex_destroy((pthread_mutex_t *)(v11 + 41304));
        if (*v109)
        {
          CFRelease(*v109);
          *v109 = 0;
        }
        reportingCacheModuleSpecificInfo();
        v107 = (const void *)*((_QWORD *)v11 + 5082);
        if (v107)
        {
          CFRelease(v107);
          *((_QWORD *)v11 + 5082) = 0;
        }
        if (*v21)
        {
          CFRelease(*v21);
          *v21 = 0;
        }
        VCMemoryPool_Destroy(*((OSQueueHead **)v11 + 5174));
LABEL_120:
        free(v11);
        return v17;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VideoReceiver_CreateHandle_cold_1();
      }
      goto LABEL_153;
    }
    if (*(_DWORD *)v11)
    {
      v83 = 0;
      v84 = (CFTypeRef **)(v11 + 5728);
      do
      {
        VCSFrameCryptorH264_Destroy(v84);
        ++v83;
        v84 += 540;
      }
      while (v83 < *(unsigned int *)v11);
    }
    free(v11);
    return 2149515265;
  }
  return 2149515267;
}

void VideoReceiver_DumpRecvCreate(uint64_t a1, int a2)
{
  FILE **v4;
  uint64_t v5;
  FILE *v6;
  __int128 v7;
  FILE *v8;
  int ErrorLogLevelForModule;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  NSObject *v13;
  uint8_t buf[4];
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  char *v23;
  char __filename[16];
  __int128 v25;
  __int128 v26;
  __int128 v27;
  char v28[8];
  char v29[8];
  uint64_t v30;
  int v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 1068))
  {
    v4 = (FILE **)(a1 + 41216);
    v5 = a1 + 40356;
    v6 = *(FILE **)(a1 + 41216);
    if (v6)
      fclose(v6);
    *(_QWORD *)v29 = 0;
    v30 = 0;
    v31 = 0;
    *(_QWORD *)v28 = 0;
    if (*(_DWORD *)v5 == 1)
    {
      __sprintf_chk(v29, 0, 0x14uLL, "%llx_", a1);
      __sprintf_chk(v28, 0, 8uLL, "_%u", a2);
      *(_WORD *)(v5 + 852) = a2;
    }
    *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v26 = v7;
    v27 = v7;
    *(_OWORD *)__filename = v7;
    v25 = v7;
    _VideoReceiverUtil_GenerateBitStreamDumpName(__filename, 0x40uLL, v29, v28);
    VCDiskUtils_CreateDirectory();
    v8 = fopen(__filename, "wb");
    *v4 = v8;
    ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    if (v8)
    {
      if (ErrorLogLevelForModule >= 7)
      {
        v10 = VRTraceErrorLogLevelToCSTR();
        v11 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316162;
          v15 = v10;
          v16 = 2080;
          v17 = "VideoReceiver_DumpRecvCreate";
          v18 = 1024;
          v19 = 715;
          v20 = 2048;
          v21 = a1;
          v22 = 2080;
          v23 = __filename;
          _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Created new video dump file: %s", buf, 0x30u);
        }
      }
    }
    else if (ErrorLogLevelForModule >= 3)
    {
      v12 = VRTraceErrorLogLevelToCSTR();
      v13 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136316162;
        v15 = v12;
        v16 = 2080;
        v17 = "VideoReceiver_DumpRecvCreate";
        v18 = 1024;
        v19 = 713;
        v20 = 2048;
        v21 = a1;
        v22 = 2080;
        v23 = __filename;
        _os_log_error_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_ERROR, "VideoReceiver [%s] %s:%d VideoReceiver[%p] failed to open %s", buf, 0x30u);
      }
    }
  }
}

void _VideoReceiver_NoVideoDisplayedTimeoutCallback(uint64_t a1, double a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  double v6;
  double v7;
  uint64_t v8;

  if (a1)
  {
    v3 = CheckInHandleDebug();
    if (v3)
    {
      v4 = v3;
      v5 = v3 + 40360;
      v6 = micro();
      v7 = *(double *)(v4 + 1360);
      v8 = *(_QWORD *)v5;
      os_unfair_lock_lock((os_unfair_lock_t)(v4 + 41688));
      if (*(_BYTE *)(v5 + 1313))
      {
        if (v7 < a2 && v6 - *(double *)(v5 + 1320) > v7 && v6 - *(double *)(v8 + 4312) >= v7)
          _VideoReceiver_DecoderNeedsRefresh(v4, v8, 0, 28, v6);
      }
      os_unfair_lock_unlock((os_unfair_lock_t)(v4 + 41688));
      CheckOutHandleDebug();
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VideoReceiver_NoVideoDisplayedTimeoutCallback_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VideoReceiver_NoVideoDisplayedTimeoutCallback_cold_1();
  }
}

uint64_t _VCVideoReceiver_InitDumpFileName(uint64_t a1, char *a2)
{
  const __CFString *v4;

  v4 = *(const __CFString **)(a1 + 1240);
  if (v4)
  {
    CFStringGetCStringPtr(v4, 0x8000100u);
    CFStringGetCStringPtr(*(CFStringRef *)(a1 + 1232), 0x8000100u);
    FourccToCStr(*(_DWORD *)(a1 + 1248));
    return snprintf(a2, 0xC8uLL, "session_%s-participant_%s-groupid_%s");
  }
  else if (*(_DWORD *)(a1 + 1048))
  {
    return snprintf(a2, 0xC8uLL, "%010u");
  }
  else
  {
    return snprintf(a2, 0xC8uLL, "streamtoken_%ld");
  }
}

void _VideoReceiver_SendNACK(unsigned int *a1, int a2, int a3, int a4, double a5)
{
  int v10;
  int v11;
  uint64_t v12;
  NSObject *v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17[2];
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;
  uint8_t buf[4];
  uint64_t v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  int v32;
  __int16 v33;
  unsigned int *v34;
  __int16 v35;
  int v36;
  __int16 v37;
  int v38;
  __int16 v39;
  int v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  if (!a3)
    return;
  v10 = *((unsigned __int8 *)a1 + 41194);
  if (*((_BYTE *)a1 + 41194))
    v11 = 7;
  else
    v11 = 8;
  if (v11 <= (int)VRTraceGetErrorLogLevelForModule())
  {
    v12 = VRTraceErrorLogLevelToCSTR();
    if (v10)
    {
      v13 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        goto LABEL_14;
      goto LABEL_11;
    }
    v13 = *MEMORY[0x1E0CF2758];
    v14 = *MEMORY[0x1E0CF2758];
    if (!*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136316674;
        v28 = v12;
        v29 = 2080;
        v30 = "_VideoReceiver_SendNACK";
        v31 = 1024;
        v32 = 2248;
        v33 = 2048;
        v34 = a1;
        v35 = 1024;
        v36 = a2;
        v37 = 1024;
        v38 = a3;
        v39 = 1024;
        v40 = a4;
        _os_log_debug_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEBUG, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Sending NACK for ssrc=%u with highestSeqNum=%u bitMask_hex=%x", buf, 0x38u);
      }
      goto LABEL_14;
    }
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
LABEL_11:
      *(_DWORD *)buf = 136316674;
      v28 = v12;
      v29 = 2080;
      v30 = "_VideoReceiver_SendNACK";
      v31 = 1024;
      v32 = 2248;
      v33 = 2048;
      v34 = a1;
      v35 = 1024;
      v36 = a2;
      v37 = 1024;
      v38 = a3;
      v39 = 1024;
      v40 = a4;
      _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Sending NACK for ssrc=%u with highestSeqNum=%u bitMask_hex=%x", buf, 0x38u);
    }
  }
LABEL_14:
  v26 = 0;
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  memset(v17, 0, sizeof(v17));
  LODWORD(v17[0]) = 2048;
  HIWORD(v18) = a3;
  WORD6(v18) = a4;
  LOBYTE(v25) = 1;
  if (*a1)
  {
    v15 = 0;
    v16 = 0;
    do
    {
      if (a1[v15 + 398] == a2)
        v16 = (uint64_t)&a1[v15 + 364];
      v15 += 1080;
    }
    while (1080 * *a1 != v15);
    if (v16)
      _VideoReceiver_SendRTCP((uint64_t)a1, v16, v17, 0, a5);
  }
}

uint64_t VideoReceiver_CloseHandle()
{
  uint64_t v0;
  unsigned int *v1;
  uint64_t v2;
  uint64_t v3;
  os_log_t *v4;
  int v5;
  uint64_t v7;
  NSObject *v8;
  unint64_t v9;
  unsigned __int16 *v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  double v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const void *v23;
  const void *v24;
  const void *v25;
  const void *v26;
  const void *v27;
  const void *v28;
  const void *v29;
  uint64_t v30;
  NSObject *v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  unint64_t v35;
  unint64_t v36;
  uint64_t *v37;
  unint64_t v38;
  CFTypeRef **v39;
  const void *v40;
  const void *v41;
  OpaqueCMMemoryPool *v42;
  const void *v43;
  __CVPixelBufferPool *v44;
  const void *v45;
  const void *v46;
  const void *v47;
  const void *v48;
  const void *v49;
  uint64_t FigBaseObject;
  uint64_t v51;
  void (*v52)(uint64_t);
  int v53;
  const void *v54;
  const void *v55;
  const void *v56;
  FILE *v57;
  FILE *v58;
  FILE *v59;
  FILE *v60;
  const void *v61;
  FILE *v62;
  NSObject *v63;
  const void *v64;
  _BYTE buf[24];
  int v66;
  _BYTE v67[17];
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  _BYTE v76[27];
  uint64_t v77;

  v77 = *MEMORY[0x1E0C80C00];
  v0 = CheckInHandleDebug();
  if (!v0)
    return 2149515266;
  v1 = (unsigned int *)v0;
  v2 = v0 + 40432;
  _VideoReceiver_UnregisterStatistics(v0);
  reportingUnregisterPeriodicTask();
  v1[362] = 1;
  v3 = *(_QWORD *)(v2 + 1144);
  if (v3)
    VCMediaStreamSynchronizer_setSourcePlayoutTimeUpdatedHandler(v3, 0);
  v4 = (os_log_t *)MEMORY[0x1E0CF2758];
  if (*((_BYTE *)v1 + 1164))
  {
    v5 = v1[363];
    if (v5 != -1)
      VTP_Close(v5);
    if (*(_QWORD *)(v2 + 16))
    {
      *(_QWORD *)buf = 0xAAAAAAAAAAAAAAAALL;
      FigThreadJoin();
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v7 = VRTraceErrorLogLevelToCSTR();
      v8 = *v4;
      if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = v7;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VideoReceiver_UnregisterTransportCallbacks";
        *(_WORD *)&buf[22] = 1024;
        v66 = 1408;
        *(_WORD *)v67 = 2048;
        *(_QWORD *)&v67[2] = v1;
        _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] unregister packet callback", buf, 0x26u);
      }
    }
    if (*v1)
    {
      v9 = 0;
      v10 = (unsigned __int16 *)(v1 + 364);
      do
      {
        v11 = *(_QWORD *)(v2 + 1208);
        if (v11)
        {
          VCCannedVideoPacketSource_UnregisterForCannedReplay(v11, v10);
        }
        else
        {
          RTPUnregisterPacketCallback();
          RTCPUnregisterPacketCallback();
        }
        ++v9;
        v10 += 2160;
      }
      while (v9 < *v1);
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v12 = VRTraceErrorLogLevelToCSTR();
    v13 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = v12;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "VideoReceiver_CloseHandle";
      *(_WORD *)&buf[22] = 1024;
      v66 = 5251;
      *(_WORD *)v67 = 2048;
      *(_QWORD *)&v67[2] = v1;
      _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d Calling CheckOutHandle with BIT_CLOSE for VideoReceiver=%p", buf, 0x26u);
    }
  }
  v14 = 0.0;
  if (VRTraceIsInternalOSInstalled())
    v14 = micro();
  v15 = CheckOutHandleDebug();
  LogProfileTimeOverLimit_1(v14, v15, v16, v17, v18, v19, v20, v21, v22, (char)"VideoReceiver_CloseHandle");
  v23 = *(const void **)(v2 + 1208);
  if (v23)
  {
    CFRelease(v23);
    *(_QWORD *)(v2 + 1208) = 0;
  }
  v24 = *(const void **)(v2 + 976);
  if (v24)
  {
    CFRelease(v24);
    *(_QWORD *)(v2 + 976) = 0;
  }
  v25 = *(const void **)(v2 + 1080);
  if (v25)
  {
    CFRelease(v25);
    *(_QWORD *)(v2 + 1080) = 0;
  }
  v26 = *(const void **)(v2 + 1056);
  if (v26)
  {
    CFRelease(v26);
    *(_QWORD *)(v2 + 1056) = 0;
  }
  v27 = *(const void **)(v2 + 984);
  if (v27)
  {
    CFRelease(v27);
    *(_QWORD *)(v2 + 984) = 0;
  }
  v28 = *(const void **)(v2 + 992);
  if (v28)
  {
    CFRelease(v28);
    *(_QWORD *)(v2 + 992) = 0;
  }
  v29 = *(const void **)(v2 + 1176);
  if (v29)
  {
    CFRelease(v29);
    *(_QWORD *)(v2 + 1176) = 0;
  }
  MEMORY[0x1DF086EF8](v1 + 354);
  _VideoReceiver_CloseSummers((uint64_t)v1);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v30 = VRTraceErrorLogLevelToCSTR();
    v31 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = v30;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "VideoReceiver_CloseHandle";
      *(_WORD *)&buf[22] = 1024;
      v66 = 5267;
      *(_WORD *)v67 = 2048;
      *(_QWORD *)&v67[2] = v1;
      _os_log_impl(&dword_1D8A54000, v31, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d About to Destroy VCVideoPlayer for VideoReceiver=%p", buf, 0x26u);
    }
  }
  VCVideoPlayer_UnregisterForNoVideoDisplayedTimeoutCallbacks();
  VCVideoPlayer_Destroy((_QWORD *)v2);
  VCVideoDecoder_ReleaseVideoDecoder(v1[256]);
  v32 = *(_QWORD *)(v2 + 968);
  if (v32)
  {
    *(_QWORD *)&buf[11] = 0;
    *(_QWORD *)&buf[4] = 0;
    *(_OWORD *)&v67[1] = 0u;
    v68 = 0u;
    v69 = 0u;
    v70 = 0u;
    v71 = 0u;
    v72 = 0u;
    v73 = 0u;
    v74 = 0u;
    v75 = 0u;
    memset(v76, 0, sizeof(v76));
    v33 = *((_QWORD *)v1 + 128);
    *(_DWORD *)buf = 4;
    buf[19] = 1;
    *(_DWORD *)&buf[20] = 0;
    v66 = v33;
    v67[0] = 1;
    VCRateControlSetStatistics(v32, buf);
  }
  v34 = *(_QWORD **)(v2 + 1088);
  if (v34)
  {
    VCVideoJitterBuffer_Finalize(v34);
    *(_QWORD *)(v2 + 1088) = 0;
  }
  v35 = *v1;
  if ((_DWORD)v35)
  {
    v36 = 0;
    v37 = (uint64_t *)(v1 + 392);
    do
    {
      if (*v37)
      {
        if (!*((_BYTE *)v37 - 42) || *((unsigned __int16 *)v37 - 54) == *((unsigned __int16 *)v37 - 56))
        {
          VideoPacketBuffer_Destroy(*v37);
          v35 = *v1;
        }
        *v37 = 0;
      }
      ++v36;
      v37 += 540;
    }
    while (v36 < v35);
    if (v35)
    {
      v38 = 0;
      v39 = (CFTypeRef **)(v1 + 1432);
      do
      {
        VCSFrameCryptorH264_Destroy(v39);
        ++v38;
        v39 += 540;
      }
      while (v38 < *v1);
    }
  }
  v40 = *(const void **)(v2 + 1192);
  if (v40)
  {
    CFRelease(v40);
    *(_QWORD *)(v2 + 1192) = 0;
  }
  _VideoReceiver_DrainAndReleaseQueue(*(opaqueCMSimpleQueue **)(v2 + 856), 1);
  _VideoReceiver_DrainAndReleaseQueue(*(opaqueCMSimpleQueue **)(v2 + 864), 0);
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 10326));
  v41 = *(const void **)(v2 + 952);
  if (v41)
  {
    CFRelease(v41);
    *(_QWORD *)(v2 + 952) = 0;
  }
  v42 = *(OpaqueCMMemoryPool **)(v2 + 944);
  if (v42)
  {
    CMMemoryPoolInvalidate(v42);
    v43 = *(const void **)(v2 + 944);
    if (v43)
    {
      CFRelease(v43);
      *(_QWORD *)(v2 + 944) = 0;
    }
  }
  v44 = *(__CVPixelBufferPool **)(v2 + 416);
  if (v44)
    CVPixelBufferPoolRelease(v44);
  v45 = *(const void **)(v2 + 488);
  if (v45)
    CFRelease(v45);
  v46 = *(const void **)(v2 + 968);
  if (v46)
    CFRelease(v46);
  v47 = *(const void **)(v2 + 424);
  if (v47)
    CFRelease(v47);
  v48 = *(const void **)(v2 + 432);
  if (v48)
    CFRelease(v48);
  v49 = *(const void **)(v2 + 480);
  if (v49)
    CFRelease(v49);
  if (*(_QWORD *)(v2 + 456))
  {
    FigBaseObject = FigFormatWriterGetFigBaseObject();
    if (FigBaseObject)
    {
      v51 = FigBaseObject;
      v52 = *(void (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable() + 8) + 24);
      if (v52)
        v52(v51);
    }
    CFRelease(*(CFTypeRef *)(v2 + 456));
  }
  if (*(_QWORD *)(v2 + 440))
  {
    FigFileForkClose();
    *(_QWORD *)(v2 + 440) = 0;
    v53 = *(_DWORD *)(v2 + 472);
    if (v53 >= 1)
      close(v53);
  }
  v54 = *(const void **)(v2 + 448);
  if (v54)
    CFRelease(v54);
  v55 = (const void *)*((_QWORD *)v1 + 154);
  if (v55)
  {
    CFRelease(v55);
    *((_QWORD *)v1 + 154) = 0;
  }
  v56 = (const void *)*((_QWORD *)v1 + 155);
  if (v56)
  {
    CFRelease(v56);
    *((_QWORD *)v1 + 155) = 0;
  }
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 10114));
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 10130));
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 10146));
  v57 = *(FILE **)(v2 + 736);
  if (v57)
    fclose(v57);
  v58 = *(FILE **)(v2 + 752);
  if (v58)
    fclose(v58);
  if (v1[267])
  {
    v59 = *(FILE **)(v2 + 784);
    if (v59)
      fclose(v59);
  }
  v60 = *(FILE **)(v2 + 768);
  if (v60)
    fclose(v60);
  VideoReceiverConfig_CleanupFeatureStrings(v1);
  v61 = *(const void **)(v2 + 216);
  if (v61)
    CFRelease(v61);
  v62 = *(FILE **)(v2 + 792);
  if (v62)
    fclose(v62);
  v63 = *(NSObject **)(v2 + 304);
  if (v63)
    dispatch_release(v63);
  VCMemoryPool_Destroy(*(OSQueueHead **)(v2 + 960));
  VideoPacketDump_CloseRTPLog(*(_QWORD *)(v2 + 800));
  reportingCacheModuleSpecificInfo();
  VRDump_CloseDumpFile((uint64_t *)v1 + 5208);
  v64 = *(const void **)(v2 + 224);
  if (v64)
    CFRelease(v64);
  if (*(_QWORD *)(v2 + 1224))
  {
    VCOverlayManager_releaseOverlaySourceWithToken(*((_QWORD *)v1 + 168), 1u);
    CFRelease(*(CFTypeRef *)(v2 + 1224));
  }
  free(v1);
  return 0;
}

void LogProfileTimeOverLimit_1(double a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10)
{
  double v11;
  __int128 v12;
  uint64_t v13;
  NSObject *v14;
  uint8_t buf[4];
  uint64_t v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  char *v22;
  __int16 v23;
  double v24;
  char __str[16];
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  if (VRTraceIsInternalOSInstalled())
  {
    v11 = micro() - a1;
    if (v11 > 4.0)
    {
      *(_QWORD *)&v12 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v39 = v12;
      v40 = v12;
      v37 = v12;
      v38 = v12;
      v35 = v12;
      v36 = v12;
      v33 = v12;
      v34 = v12;
      v31 = v12;
      v32 = v12;
      v30 = v12;
      v28 = v12;
      v29 = v12;
      v26 = v12;
      v27 = v12;
      *(_OWORD *)__str = v12;
      vsnprintf(__str, 0x100uLL, "%s: CheckOutHandle with BIT_CLOSE for VideoReceiver=%p", &a10);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v13 = VRTraceErrorLogLevelToCSTR();
        v14 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316162;
          v16 = v13;
          v17 = 2080;
          v18 = "_LogProfileTimeLimitHelper";
          v19 = 1024;
          v20 = 36;
          v21 = 2080;
          v22 = __str;
          v23 = 2048;
          v24 = v11;
          _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d %s: Took a long time %fs", buf, 0x30u);
        }
      }
    }
  }
}

void _VideoReceiver_DrainAndReleaseQueue(opaqueCMSimpleQueue *a1, int a2)
{
  const __CFAllocator **v4[2];

  v4[1] = *(const __CFAllocator ***)MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (CMSimpleQueueGetCount(a1) >= 1)
    {
      do
      {
        v4[0] = (const __CFAllocator **)0xAAAAAAAAAAAAAAAALL;
        v4[0] = (const __CFAllocator **)CMSimpleQueueDequeue(a1);
        if (a2)
          VCVideoReceiverSampleBuffer_Destroy(v4);
        else
          VCVideoReceiverDecodedFrame_Destroy(v4);
      }
      while (CMSimpleQueueGetCount(a1) > 0);
    }
    CFRelease(a1);
  }
}

uint64_t VideoReceiver_DisplayLinkTick(double a1, double a2, double a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  CMTime v12;
  CMTime time;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v6 = 2149515266;
  v7 = CheckInHandleDebug();
  if (v7)
  {
    v8 = v7;
    v9 = v7 + 40432;
    v10 = VCVideoPlayer_DisplayLinkTick(a1, a2, a3);
    if (*(_BYTE *)(v9 + 1072)
      && (VCVideoPlayer_GetPlayoutInfo(*(_QWORD *)v9, (unsigned int *)(v8 + 40688), (uint64_t *)(v8 + 40712)) & 0x80000000) != 0)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VideoReceiver_DisplayLinkTick_cold_1();
      }
    }
    else
    {
      CMTimeMakeWithSeconds(&v12, a3, 1000000000);
      time = v12;
      CMTimeGetSeconds(&time);
      kdebug_trace();
      v6 = v10;
    }
    CheckOutHandleDebug();
  }
  return v6;
}

uint64_t _VideoReceiver_CallAlarms(uint64_t a1, int *a2, double a3)
{
  double v3;
  uint64_t v4;
  int v5;
  double v6;
  double v7;
  double v8;
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  NSObject *v17;
  uint64_t v18;
  int v19;
  uint8_t buf[4];
  uint64_t v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  _BYTE v27[10];
  double v28;
  __int16 v29;
  int v30;
  uint64_t v31;

  v3 = a3;
  v31 = *MEMORY[0x1E0C80C00];
  v4 = a1 + 40432;
  v5 = *a2;
  LODWORD(a3) = a2[1];
  v6 = (double)*a2 + (double)*(unint64_t *)&a3 * 4294967300.0;
  v7 = (double)*(int *)(a1 + 1032);
  if (!*(_BYTE *)(a1 + 1077))
  {
    if (*(_BYTE *)(a1 + 1192))
    {
      if ((VCVideoPlayer_GetPlayoutInfo(*(_QWORD *)v4, (unsigned int *)(a1 + 40688), (uint64_t *)(a1 + 40712)) & 0x80000000) != 0
        && (int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VideoReceiver_CallAlarms_cold_1();
      }
    }
    else
    {
      v14 = *(_QWORD *)(a1 + 41576);
      if (v14)
      {
        v19 = 0;
        if (VCMediaStreamSynchronizer_destRTPTimestampFromSourceRTPTimestamp(v14, v5, (uint64_t)&v19))
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            v15 = VRTraceErrorLogLevelToCSTR();
            v16 = *MEMORY[0x1E0CF2758];
            v17 = *MEMORY[0x1E0CF2758];
            if (*MEMORY[0x1E0CF2748])
            {
              if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136316162;
                v21 = v15;
                v22 = 2080;
                v23 = "_VideoReceiver_SetPlayoutRTPTimestamp";
                v24 = 1024;
                v25 = 5518;
                v26 = 1024;
                *(_DWORD *)v27 = v5;
                *(_WORD *)&v27[4] = 1024;
                *(_DWORD *)&v27[6] = v19;
                _os_log_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d Converted audioPlayoutRTPTimestamp=%u into video domain with timestamp=%u", buf, 0x28u);
              }
            }
            else if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136316162;
              v21 = v15;
              v22 = 2080;
              v23 = "_VideoReceiver_SetPlayoutRTPTimestamp";
              v24 = 1024;
              v25 = 5518;
              v26 = 1024;
              *(_DWORD *)v27 = v5;
              *(_WORD *)&v27[4] = 1024;
              *(_DWORD *)&v27[6] = v19;
              _os_log_debug_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEBUG, "VideoReceiver [%s] %s:%d Converted audioPlayoutRTPTimestamp=%u into video domain with timestamp=%u", buf, 0x28u);
            }
          }
          *(_DWORD *)(v4 + 256) = v19;
        }
      }
      else
      {
        *(_DWORD *)(v4 + 256) = v5;
      }
    }
  }
  v8 = v6 / v7;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v9 = VRTraceErrorLogLevelToCSTR();
    v10 = *MEMORY[0x1E0CF2758];
    v11 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        v12 = *(_QWORD *)v4;
        *(_DWORD *)buf = 136316418;
        v21 = v9;
        v22 = 2080;
        v23 = "_VideoReceiver_CallAlarms";
        v24 = 1024;
        v25 = 5537;
        v26 = 2048;
        *(_QWORD *)v27 = v12;
        *(_WORD *)&v27[8] = 2048;
        v28 = v8;
        v29 = 1024;
        v30 = v5;
        _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d Calling VCVideoPlayer_CallAlarms with PlayerHandle=%p with sourceTime=%.6f for audioPlayoutRTPTimestamp=%u", buf, 0x36u);
      }
    }
    else if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      v18 = *(_QWORD *)v4;
      *(_DWORD *)buf = 136316418;
      v21 = v9;
      v22 = 2080;
      v23 = "_VideoReceiver_CallAlarms";
      v24 = 1024;
      v25 = 5537;
      v26 = 2048;
      *(_QWORD *)v27 = v18;
      *(_WORD *)&v27[8] = 2048;
      v28 = v8;
      v29 = 1024;
      v30 = v5;
      _os_log_debug_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEBUG, "VideoReceiver [%s] %s:%d Calling VCVideoPlayer_CallAlarms with PlayerHandle=%p with sourceTime=%.6f for audioPlayoutRTPTimestamp=%u", buf, 0x36u);
    }
  }
  return VCVideoPlayer_CallAlarms(*(_QWORD *)v4, v3, v8);
}

uint64_t VideoReceiver_UpdateSourcePlayoutTime(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  os_unfair_lock_s *v4;
  uint64_t v5;
  double v6;
  _BYTE *v7;
  double v8;
  double v9;
  uint64_t v10;
  NSObject *v11;
  char *v12;
  int v13;
  double v14;
  double v15;
  uint64_t v16;
  _BYTE *v17;
  CMTime v19;
  uint8_t buf[4];
  uint64_t v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  os_unfair_lock_s *v27;
  __int16 v28;
  char *v29;
  __int16 v30;
  int v31;
  __int16 v32;
  double v33;
  __int16 v34;
  double v35;
  __int16 v36;
  double v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149515266;
  v4 = (os_unfair_lock_s *)v3;
  v5 = v3 + 40432;
  v6 = micro();
  v19 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68];
  if (*(_BYTE *)(v5 + 1264))
  {
    os_unfair_lock_lock(v4 + 10423);
    v7 = (_BYTE *)*a2;
    *(_QWORD *)(v5 + 1016) = a2[3];
    *(_QWORD *)(v5 + 248) = v7;
    VCVideoPlayer_SetOutputLatency(*(double *)(v5 + 1272));
    CMTimeMake(&v19, (unint64_t)((double)*(unint64_t *)(v5 + 248)+ (v6 - *(double *)(v5 + 1016)) * (double)(int)v4[258]._os_unfair_lock_opaque), v4[258]._os_unfair_lock_opaque);
    os_unfair_lock_unlock(v4 + 10423);
    os_unfair_lock_lock(v4 + 10289);
    if (*(_BYTE *)(v5 + 720))
    {
      v8 = *(double *)(v5 + 712);
      if (v8 != 0.0)
      {
        v9 = v6 - v8;
        if (v6 - v8 > *(double *)(v5 + 696) + 0.132)
        {
          _VideoReceiver_UpdateVideoStallTime((uint64_t)v4, v9, v6);
          ++*(_DWORD *)(v5 + 680);
          *(double *)(v5 + 696) = v9;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v10 = VRTraceErrorLogLevelToCSTR();
            v11 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              v12 = FourccToCStr(v4[312]._os_unfair_lock_opaque);
              v13 = *(_DWORD *)(v5 + 680);
              v14 = *(double *)(v5 + 656) * 1000.0;
              v15 = *(double *)(v5 + 704) * 1000.0;
              *(_DWORD *)buf = 136317186;
              v21 = v10;
              v22 = 2080;
              v23 = "_VideoReceiver_UpdateFrameDiscontinuityStatus";
              v24 = 1024;
              v25 = 1311;
              v26 = 2048;
              v27 = v4;
              v28 = 2080;
              v29 = v12;
              v30 = 1024;
              v31 = v13;
              v32 = 2048;
              v33 = v9 * 1000.0;
              v34 = 2048;
              v35 = v14;
              v36 = 2048;
              v37 = v15;
              _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Frame Discontinuity Detected streamGroupID=%s count=%u frameDiscontinuityLength=%f frameDiscontinuityTime=%f frameDiscontinuityMaxSegment=%f", buf, 0x54u);
            }
          }
        }
      }
    }
    os_unfair_lock_unlock(v4 + 10289);
  }
  else
  {
    if (*(_BYTE *)(v5 + 1009))
    {
      v17 = (_BYTE *)*a2;
      *(double *)(v5 + 1016) = micro();
      *(_QWORD *)(v5 + 248) = v17;
    }
    v19 = *(CMTime *)a2;
  }
  v16 = _VideoReceiver_CallAlarms((uint64_t)v4, (int *)&v19, v6);
  CheckOutHandleDebug();
  return v16;
}

uint64_t VideoReceiver_SetVTHandleAndStart(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unsigned int *v4;
  uint64_t v5;
  pthread_mutex_t *v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  unint64_t v11;
  unsigned int *v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  NSObject *v16;
  const char *v17;
  uint64_t v24;
  NSObject *v25;
  uint64_t v26;
  NSObject *v27;
  CFDictionaryRef v28;
  int v29;
  uint64_t v30;
  NSObject *v31;
  unsigned int *v33;
  _BYTE buf[24];
  _BYTE v35[20];
  __int16 v36;
  int v37;
  _BYTE v38[12];
  __int16 v39;
  const char *v40;
  __int16 v41;
  int v42;
  __int16 v43;
  unsigned int *v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v3 = CheckInHandleDebug();
  if (v3)
  {
    v4 = (unsigned int *)v3;
    v5 = v3 + 40384;
    *(_QWORD *)(v3 + 40384) = a2;
    *(_BYTE *)(v3 + 41441) = *(_BYTE *)(v3 + 1160);
    v6 = (pthread_mutex_t *)(v3 + 40456);
    pthread_mutex_lock((pthread_mutex_t *)(v3 + 40456));
    if (*((_BYTE *)v4 + 1164))
    {
      if (*(_QWORD *)(v5 + 64))
        goto LABEL_4;
      *(_QWORD *)v38 = CFSTR("com.apple.avconference.videoreceiver.recvproc");
      v28 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], MEMORY[0x1E0CA52C8], (const void **)v38, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      v29 = FigThreadCreate();
      if (v28)
        CFRelease(v28);
      if (!v29)
      {
LABEL_4:
        v7 = 0;
      }
      else
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v30 = VRTraceErrorLogLevelToCSTR();
          v31 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136316418;
            *(_QWORD *)&buf[4] = v30;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "VideoReceiver_SetVTHandleAndStart";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)v35 = 5569;
            *(_WORD *)&v35[4] = 1024;
            *(_DWORD *)&v35[6] = 5569;
            *(_WORD *)&v35[10] = 2048;
            *(_QWORD *)&v35[12] = v4;
            v36 = 1024;
            v37 = v29;
            _os_log_error_impl(&dword_1D8A54000, v31, OS_LOG_TYPE_ERROR, "VideoReceiver [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/VideoReceiver.c:%d: VideoReceiver[%p] VideoReceiver_RecvProc thread create failed(%d)", buf, 0x32u);
          }
        }
        v7 = v29 | 0xA01F0000;
      }
      goto LABEL_35;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v8 = VRTraceErrorLogLevelToCSTR();
      v9 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = v8;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VideoReceiver_RegisterTransportCallbacks";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)v35 = 1386;
        *(_WORD *)&v35[4] = 2048;
        *(_QWORD *)&v35[6] = v4;
        _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] register packet callback", buf, 0x26u);
      }
    }
    if (!*v4)
    {
LABEL_27:
      v7 = 0;
LABEL_35:
      pthread_mutex_unlock(v6);
      CheckOutHandleDebug();
      return v7;
    }
    v10 = 0;
    v11 = 0;
    v33 = v4 + 364;
    while (1)
    {
      v12 = &v4[v10];
      *(_QWORD *)buf = MEMORY[0x1E0C809B0];
      *(_QWORD *)&buf[8] = 0x40000000;
      *(_QWORD *)&buf[16] = ___VideoReceiver_RegisterTransportCallbacks_block_invoke;
      *(_QWORD *)v35 = &__block_descriptor_tmp_336;
      *(_QWORD *)&v35[8] = v4;
      *(_DWORD *)&v35[16] = v11;
      v13 = *(_QWORD *)(v5 + 1256);
      if (v13)
      {
        if ((VCCannedVideoPacketSource_RegisterForCannedReplay(v13, (unsigned __int16 *)&v4[v10 + 364], (unsigned __int16 *)buf, __block_literal_global_28) & 0x80000000) == 0)goto LABEL_18;
        if ((int)VRTraceGetErrorLogLevelForModule() < 3)
          goto LABEL_18;
        v14 = VRTraceErrorLogLevelToCSTR();
        v15 = *MEMORY[0x1E0CF2758];
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          goto LABEL_18;
        *(_DWORD *)v38 = 136315906;
        *(_QWORD *)&v38[4] = v14;
        v39 = 2080;
        v40 = "_VideoReceiver_RegisterTransportCallbacksForStream";
        v41 = 1024;
        v42 = 1373;
        v43 = 2048;
        v44 = &v33[v10];
        v16 = v15;
        v17 = "VideoReceiver [%s] %s:%d Failed to register canned replay callbacks for stream[%p]";
      }
      else
      {
        _X8 = v12 + 2536;
        __asm { PRFM            #0, [X8] }
        if ((RTPRegisterPacketCallback(*((_QWORD *)v12 + 188), (uint64_t)&v4[v10 + 364], buf) & 0x80000000) != 0)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() < 3)
            goto LABEL_18;
          v24 = VRTraceErrorLogLevelToCSTR();
          v25 = *MEMORY[0x1E0CF2758];
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            goto LABEL_18;
          *(_DWORD *)v38 = 136315906;
          *(_QWORD *)&v38[4] = v24;
          v39 = 2080;
          v40 = "_VideoReceiver_RegisterTransportCallbacksForStream";
          v41 = 1024;
          v42 = 1376;
          v43 = 2048;
          v44 = &v33[v10];
          v16 = v25;
          v17 = "VideoReceiver [%s] %s:%d Failed to register RTP packet callbacks for stream[%p]";
        }
        else
        {
          if ((RTCPRegisterPacketCallback(*((_QWORD *)v12 + 188), (uint64_t)&v4[v10 + 364], __block_literal_global_28) & 0x80000000) == 0)
            goto LABEL_18;
          if ((int)VRTraceGetErrorLogLevelForModule() < 3)
            goto LABEL_18;
          v26 = VRTraceErrorLogLevelToCSTR();
          v27 = *MEMORY[0x1E0CF2758];
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            goto LABEL_18;
          *(_DWORD *)v38 = 136315906;
          *(_QWORD *)&v38[4] = v26;
          v39 = 2080;
          v40 = "_VideoReceiver_RegisterTransportCallbacksForStream";
          v41 = 1024;
          v42 = 1379;
          v43 = 2048;
          v44 = &v33[v10];
          v16 = v27;
          v17 = "VideoReceiver [%s] %s:%d Failed to register RTCP packet callbacks for stream[%p]";
        }
      }
      _os_log_error_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_ERROR, v17, v38, 0x26u);
LABEL_18:
      ++v11;
      v10 += 1080;
      if (v11 >= *v4)
        goto LABEL_27;
    }
  }
  return 2149515266;
}

uint64_t VideoReceiver_RecvProc(uint64_t a1)
{
  uint64_t v2;
  unsigned int *v3;
  int ErrorLogLevelForModule;
  NSObject **v5;
  uint64_t v6;
  NSObject *v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  NSObject *v15;
  _OWORD v17[4];
  uint64_t v18;
  _OWORD v19[2];
  int v20;
  _BYTE buf[12];
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  unsigned int *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v20 = 0;
  memset(v19, 0, sizeof(v19));
  v18 = 0;
  memset(v17, 0, sizeof(v17));
  v2 = CheckInHandleDebug();
  if (!v2)
    return -2145452030;
  v3 = (unsigned int *)v2;
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  v5 = (NSObject **)MEMORY[0x1E0CF2758];
  if (ErrorLogLevelForModule >= 7)
  {
    v6 = VRTraceErrorLogLevelToCSTR();
    v7 = *v5;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = v6;
      v22 = 2080;
      v23 = "VideoReceiver_RecvProc";
      v24 = 1024;
      v25 = 4147;
      v26 = 2048;
      v27 = v3;
      _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] ##### VideoReceiver_RecvProc start", buf, 0x26u);
    }
  }
  while (!v3[362])
  {
    v8 = *v3;
    if ((_DWORD)v8)
    {
      v9 = 0;
      v10 = v3 + 376;
      do
      {
        *((_DWORD *)v19 + v9) = 48;
        *((_QWORD *)v17 + v9++) = *v10;
        v10 += 540;
      }
      while (v9 < v8);
    }
    if ((RTPGetReceiveStatus((uint64_t)v17, (unsigned int *)v19, v8, v3[363]) & 0x80000000) != 0)
    {
      usleep(0x2710u);
    }
    else
    {
      if (*v3)
      {
        v11 = 0;
        v12 = (uint64_t)(v3 + 364);
        do
        {
          v13 = *((_DWORD *)v19 + v11);
          if ((v13 & 0x10) != 0)
          {
            *(_QWORD *)buf = 0;
            if ((RTPRecvRTP(*(_QWORD *)(v12 + 48), buf) & 0x80000000) == 0)
            {
              kdebug_trace();
              _VideoReceiver_ProcessVideoRTPInternal(a1, v3, (unsigned __int16 *)v12, *(uint64_t *)buf);
              RTPReleaseRTPPacket(*(_QWORD *)(v12 + 48), (_DWORD **)buf);
            }
            v13 = *((_DWORD *)v19 + v11);
          }
          if ((v13 & 0x20) != 0)
          {
            bzero(buf, 0x668uLL);
            if ((RTPRecvRTCP(*(_QWORD *)(v12 + 48), buf) & 0x80000000) == 0)
            {
              _VideoReceiver_ProcessVideoRTCPInternal((uint64_t)v3, v12, (uint64_t)buf);
              RTCPCleanupPacketList((uint64_t)buf);
            }
          }
          ++v11;
          v12 += 4320;
        }
        while (v11 < *v3);
      }
      if (v3[10089] == 1 || *((_BYTE *)v3 + 40352))
        _VideoReceiver_ScheduleFramesForDecodingMultiway(a1, v3, v3[10175]);
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v14 = VRTraceErrorLogLevelToCSTR();
    v15 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = v14;
      v22 = 2080;
      v23 = "VideoReceiver_RecvProc";
      v24 = 1024;
      v25 = 4175;
      v26 = 2048;
      v27 = v3;
      _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] ##### VideoReceiver_RecvProc end", buf, 0x26u);
    }
  }
  CheckOutHandleDebug();
  return 0;
}

uint64_t VideoReceiver_SetVTHandle(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149515266;
  *(_QWORD *)(v3 + 40384) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t VideoReceiver_SetFeedbackDelegate()
{
  if (!CheckInHandleDebug())
    return 2149515266;
  FigCFWeakReferenceStore();
  CheckOutHandleDebug();
  return 0;
}

uint64_t VideoReceiver_GetFramerate(float a1, uint64_t a2, double *a3)
{
  uint64_t v5;
  uint64_t v6;
  double v7;
  uint64_t v8;
  double v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v5 = CheckInHandleDebug();
  if (!v5)
    return 2149515266;
  v11 = -1431655766;
  v10 = NAN;
  *a3 = 0.0;
  v6 = *(_QWORD *)(v5 + 40392);
  v7 = micro();
  v8 = SummerLengthPred(v7 - a1, v6, (uint64_t (*)(double, double, double))SummerGreaterThan, &v10, &v11);
  if ((v8 & 0x80000000) == 0 && v10 >= 0.5)
    *a3 = (double)v11 / v10;
  CheckOutHandleDebug();
  return v8;
}

uint64_t VideoReceiver_GetBitrate(float a1, uint64_t a2, uint64_t a3, double *a4, double *a5, double *a6, double *a7)
{
  uint64_t v13;
  uint64_t *v14;
  double v15;

  v13 = CheckInHandleDebug();
  if (!v13)
    return 2149515266;
  v14 = (uint64_t *)(v13 + 40392);
  v15 = micro() - a1;
  if (a3 && (a3 = _VCNACKConsumer_ComputeSummerBitrate(*v14, (double *)a3, v15), (a3 & 0x80000000) != 0))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoReceiver_GetBitrate_cold_5();
    }
  }
  else if (a4 && (a3 = _VCNACKConsumer_ComputeSummerBitrate(v14[1], a4, v15), (a3 & 0x80000000) != 0))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoReceiver_GetBitrate_cold_4();
    }
  }
  else if (a5 && (a3 = _VCNACKConsumer_ComputeSummerBitrate(v14[4], a5, v15), (a3 & 0x80000000) != 0))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoReceiver_GetBitrate_cold_3();
    }
  }
  else if (a6 && (a3 = _VCNACKConsumer_ComputeSummerBitrate(v14[2], a6, v15), (a3 & 0x80000000) != 0))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoReceiver_GetBitrate_cold_2();
    }
  }
  else if (a7)
  {
    a3 = _VCNACKConsumer_ComputeSummerBitrate(v14[3], a7, v15);
    if ((a3 & 0x80000000) != 0 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoReceiver_GetBitrate_cold_1();
    }
  }
  CheckOutHandleDebug();
  return a3;
}

uint64_t VideoReceiver_GetMediaChannelMetrics(float a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t *v6;
  double v7;
  double v8;
  double v9;
  uint64_t v10;
  double v11;
  uint64_t v12;
  uint64_t v13;
  int64x2_t v14;
  double v16;
  double v17;
  int v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v5 = CheckInHandleDebug();
  if (!v5)
    return 2149515266;
  v6 = (uint64_t *)(v5 + 40392);
  v18 = -1431655766;
  v16 = 0.0;
  v17 = NAN;
  v7 = a1;
  v8 = micro() - a1;
  v9 = 0.0;
  if ((SummerSumPred(v8, 0.0, *v6, (unsigned int (*)(double, double, double))SummerGreaterThan, (double (*)(double, double, double))SummerIdentity, &v17, &v16) & 0x80000000) == 0&& v17 >= 0.5)
  {
    v16 = v16 * 8.0 / v17;
  }
  v10 = *v6;
  v11 = micro();
  v12 = SummerLengthPred(v11 - v7, v10, (uint64_t (*)(double, double, double))SummerGreaterThan, &v17, &v18);
  if ((v12 & 0x80000000) == 0 && v17 >= 0.5)
    v9 = (double)v18 / v17;
  if (a3)
  {
    *(_DWORD *)a3 = (v16 / 1000.0);
    *(double *)(a3 + 32) = v9;
    v13 = *(uint64_t *)((char *)v6 + 420);
    v14.i64[0] = (int)v13;
    v14.i64[1] = SHIDWORD(v13);
    *(float64x2_t *)(a3 + 40) = vcvtq_f64_s64(v14);
  }
  CheckOutHandleDebug();
  return v12;
}

uint64_t VideoReceiver_GetLastReceivedVideoRTPPacketTime(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149515266;
  *a2 = *(_QWORD *)(v3 + 41464);
  CheckOutHandleDebug();
  return 0;
}

uint64_t VideoReceiver_GetLastReceivedVideoRTCPPacketTime(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149515266;
  *a2 = *(_QWORD *)(v3 + 41472);
  CheckOutHandleDebug();
  return 0;
}

uint64_t VideoReceiver_GetLastVideoStallDuration(uint64_t a1, float *a2)
{
  uint64_t v3;
  double *v4;
  double v5;
  float v6;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149515266;
  if (a2)
  {
    v4 = (double *)(v3 + 41088);
    _VideoReceiver_CheckIfVideoStalling(v3);
    v5 = *v4;
    v6 = *v4 - v4[2];
    *a2 = v6;
    v4[2] = v5;
  }
  CheckOutHandleDebug();
  return 0;
}

void _VideoReceiver_CheckIfVideoStalling(uint64_t a1)
{
  double *v1;
  double VideoStallLength;
  double v3;

  v1 = (double *)(a1 + 41088);
  if (!*(_BYTE *)(a1 + 41152))
  {
    if (*(double *)(a1 + 41120) == 0.0)
    {
      *(_QWORD *)(a1 + 41128) = 0;
    }
    else
    {
      VideoStallLength = _VideoReceiver_GetVideoStallLength(a1);
      v3 = v1[5];
      if (v3 == 0.0)
      {
        v1[5] = VideoStallLength;
        *v1 = VideoStallLength + *v1;
      }
      else
      {
        *v1 = VideoStallLength - v3 + *v1;
        v1[5] = VideoStallLength;
      }
      if (v1[6] > VideoStallLength)
        VideoStallLength = v1[6];
      v1[6] = VideoStallLength;
    }
  }
}

uint64_t VideoReceiver_GetShowFrameRTPTimestamp()
{
  uint64_t v0;
  uint64_t v1;

  v0 = CheckInHandleDebug();
  if (v0)
  {
    v1 = *(unsigned int *)(v0 + 41264);
    CheckOutHandleDebug();
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoReceiver_GetShowFrameRTPTimestamp_cold_1();
    }
    return 0;
  }
  return v1;
}

uint64_t VideoReceiver_CellTechChanged()
{
  uint64_t v0;
  uint64_t v1;

  v0 = CheckInHandleDebug();
  if (v0)
  {
    *(_QWORD *)(v0 + 41136) = 0;
    CheckOutHandleDebug();
    return 0;
  }
  else
  {
    v1 = 2149515266;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoReceiver_CellTechChanged_cold_1();
    }
  }
  return v1;
}

uint64_t VideoReceiver_SetSynchronizer(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[6];

  v10[5] = *MEMORY[0x1E0C80C00];
  v4 = CheckInHandleDebug();
  if (v4)
  {
    v5 = v4 + 40376;
    if (*(_DWORD *)(v4 + 1256) == 2)
    {
      if (a2)
      {
        v10[0] = MEMORY[0x1E0C809B0];
        v10[1] = 0x40000000;
        v10[2] = __VideoReceiver_SetSynchronizer_block_invoke;
        v10[3] = &__block_descriptor_tmp_76;
        v10[4] = a1;
        v6 = v10;
        v7 = a2;
LABEL_10:
        VCMediaStreamSynchronizer_setSourcePlayoutTimeUpdatedHandler(v7, v6);
        goto LABEL_11;
      }
      v7 = *(_QWORD *)(v4 + 41576);
      if (v7)
      {
        v6 = 0;
        goto LABEL_10;
      }
    }
LABEL_11:
    *(_QWORD *)(v5 + 1200) = a2;
    *(_BYTE *)v5 = a2 != 0;
    CheckOutHandleDebug();
    return 0;
  }
  v8 = 2149515266;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VideoReceiver_SetSynchronizer_cold_1();
  }
  return v8;
}

uint64_t _VideoReceiver_RTPPacketCallback(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int *v6;
  uint64_t v7;
  uint64_t v8;
  int AssemblyRTPTimestamp;
  uint64_t v11;
  NSObject *v12;
  int v13;
  uint64_t v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  unsigned int *v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 128);
  v5 = CheckInHandleDebug();
  if (!v5)
    return 2149515266;
  v6 = (unsigned int *)v5;
  v7 = v5 + 40352;
  *(_QWORD *)(v5 + 41464) = *(_QWORD *)(a2 + 40);
  ++*(_DWORD *)(v5 + 41460);
  v8 = _VideoReceiver_ProcessVideoRTPInternal(v4, (unsigned int *)v5, (unsigned __int16 *)a1, a2);
  if ((v8 & 0x80000000) != 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v11 = VRTraceErrorLogLevelToCSTR();
      v12 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v13 = 136316162;
        v14 = v11;
        v15 = 2080;
        v16 = "_VideoReceiver_RTPPacketCallback";
        v17 = 1024;
        v18 = 3377;
        v19 = 2048;
        v20 = v6;
        v21 = 1024;
        v22 = v8;
        _os_log_error_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_ERROR, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Failed to process RTP packet. status[%x]", (uint8_t *)&v13, 0x2Cu);
      }
    }
  }
  else if (*(_DWORD *)(v7 + 4) == 1 || *(_BYTE *)v7)
  {
    AssemblyRTPTimestamp = _VideoReceiver_GetAssemblyRTPTimestamp((uint64_t)v6);
    _VideoReceiver_ScheduleFramesForDecodingMultiway(v4, v6, AssemblyRTPTimestamp);
  }
  CheckOutHandleDebug();
  return v8;
}

void _VideoReceiverStreamStats_AddPacket(uint64_t a1, int a2, unsigned int a3)
{
  uint64_t v5;
  unsigned int *v6;
  int v7;
  int v8;

  if (*(_DWORD *)(a1 + 4) != a2)
  {
    *(_DWORD *)(a1 + 4) = a2;
    *(_QWORD *)(a1 + 16) = 0;
    bzero((void *)(a1 + 24), 0x1000uLL);
LABEL_5:
    *(_BYTE *)a1 = 1;
    *(_WORD *)(a1 + 8) = a3;
    *(_DWORD *)(a1 + 12) = a3;
    goto LABEL_6;
  }
  if (!*(_BYTE *)a1)
    goto LABEL_5;
LABEL_6:
  v5 = a1 + 4 * (a3 & 0x3FF);
  v7 = *(_DWORD *)(v5 + 24);
  v6 = (unsigned int *)(v5 + 24);
  if (v7 != a3)
  {
    *v6 = a3;
    v8 = *(_DWORD *)(a1 + 12);
    ++*(_DWORD *)(a1 + 16);
    if (a3 != (unsigned __int16)v8 && (unsigned __int16)(a3 - v8) <= 0x7FFEu)
    {
      if (a3 < (unsigned __int16)v8)
        v8 += 0x10000;
      *(_DWORD *)(a1 + 12) = v8 & 0xFFFF0000 | a3;
    }
  }
}

double _VideoReceiver_GetTotalPLR(unsigned int *a1)
{
  uint64_t v1;
  unsigned int v2;
  int *v3;
  double result;
  int v5;
  int v6;
  int v7;
  int v8;
  int64_t v9;
  int v10;
  BOOL v11;
  double v12;

  v1 = *a1;
  if (!(_DWORD)v1)
    return 0.0;
  v2 = 0;
  v3 = (int *)(a1 + 404);
  result = 0.0;
  do
  {
    v5 = *(v3 - 1);
    v6 = *v3;
    v7 = *((unsigned __int16 *)v3 - 4);
    v8 = *((unsigned __int16 *)v3 - 6);
    v9 = (unsigned __int16)(v7 - v8) - (unint64_t)(v5 - *v3);
    v10 = v7 - v8;
    if (v10)
      v11 = v9 < 1;
    else
      v11 = 1;
    v12 = 0.0;
    if (!v11)
      v12 = (double)v9 / (double)(unsigned __int16)v10;
    v3 += 1080;
    if (v5 == v6)
      v12 = -0.0;
    result = result + v12;
    if (v5 != v6)
      ++v2;
    --v1;
  }
  while (v1);
  if (v2)
    return result / (double)v2;
  return result;
}

unsigned int *_VideoReceiver_ResetStreamStats(unsigned int *result)
{
  uint64_t v1;

  v1 = *result;
  if ((_DWORD)v1)
  {
    do
    {
      result[404] = result[403];
      *((_WORD *)result + 802) = result[402];
      *(_QWORD *)(result + 1429) = 0;
      result[1431] = 0;
      result += 1080;
      --v1;
    }
    while (v1);
  }
  return result;
}

uint64_t VideoReceiver_SetJitterBufferMode(uint64_t a1, unsigned int a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2147680258;
  _VideoReceiver_SetJitterBufferMode(v3, a2);
  CheckOutHandleDebug();
  return 0;
}

void _VideoReceiver_SetJitterBufferMode(uint64_t a1, unsigned int a2)
{
  uint64_t v4;

  if (*(_DWORD *)(a1 + 1020) != a2)
  {
    v4 = a1 + 40432;
    VCVideoPlayer_UpdateJitterBufferMode(*(_QWORD *)(a1 + 40432), a2);
    VCVideoJitterBuffer_UpdateMode(*(_QWORD *)(v4 + 1088), a2);
    *(_DWORD *)(a1 + 1020) = a2;
  }
}

uint64_t VideoReceiver_UpdateVideoExpected(uint64_t a1, int a2)
{
  os_unfair_lock_s *v3;
  char *v4;
  os_unfair_lock_s *v5;

  v3 = (os_unfair_lock_s *)CheckInHandleDebug();
  if (!v3)
    return 2147680258;
  v4 = (char *)&v3[10418]._os_unfair_lock_opaque + 1;
  v5 = v3 + 10422;
  os_unfair_lock_lock(v3 + 10422);
  *v4 = a2;
  if (a2)
    *(double *)(v4 + 7) = micro();
  os_unfair_lock_unlock(v5);
  CheckOutHandleDebug();
  return 0;
}

uint64_t VideoReceiver_SetExternalOutputLatency(double a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = CheckInHandleDebug();
  if (v2)
  {
    *(double *)(v2 + 41704) = a1;
    if (*(_QWORD *)(v2 + 40432) != 0xFFFFFFFFLL)
      VCVideoPlayer_SetOutputLatency(a1);
    CheckOutHandleDebug();
    return 0;
  }
  else
  {
    v3 = 2147680258;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoReceiver_SetExternalOutputLatency_cold_1();
    }
  }
  return v3;
}

uint64_t VideoReceiver_SetDeferredAssemblyEnabled(uint64_t a1, char a2)
{
  uint64_t v3;
  uint64_t v4;

  v3 = CheckInHandleDebug();
  if (v3)
  {
    *(_BYTE *)(v3 + 1078) = a2;
    CheckOutHandleDebug();
    return 0;
  }
  else
  {
    v4 = 2147680258;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoReceiver_SetDeferredAssemblyEnabled_cold_1();
    }
  }
  return v4;
}

uint64_t VideoReceiver_SetLooseAVSyncEnabled(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;

  v3 = CheckInHandleDebug();
  if (v3)
  {
    v4 = VCVideoPlayer_SetLooseAVSyncEnabled(*(_QWORD *)(v3 + 40432), a2);
    CheckOutHandleDebug();
    return v4;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoReceiver_SetLooseAVSyncEnabled_cold_1();
    }
    return 2147680258;
  }
}

void VideoReceiver_VideoAlarmForDisplay(uint64_t a1, __int128 *a2, int a3, int a4, int a5, int a6)
{
  __int128 v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v6 = *a2;
  v7 = *((_QWORD *)a2 + 2);
  _VideoReceiver_VideoAlarmCommon(a1, (uint64_t)&v6, a3, a4, 1, a5, a6);
}

void _VideoReceiver_UpdateVideoStallStatus(uint64_t a1, int a2)
{
  uint64_t v2;
  _DWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  FILE **v11;
  uint64_t v12;
  NSObject *v13;
  int v14;
  double VideoStallLength;
  double v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  FILE **v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  NSObject *v29;
  int v30;
  uint64_t v31;
  FILE **v32;
  __CFDictionary *ReportingEventDictionary;
  __CFDictionary *v34;
  CFNumberRef v35;
  int v36;
  uint64_t v37;
  __int16 v38;
  const char *v39;
  __int16 v40;
  int v41;
  __int16 v42;
  uint64_t v43;
  __int16 v44;
  int v45;
  __int16 v46;
  double v47;
  __int16 v48;
  uint64_t v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  v2 = a1 + 40656;
  if (!*(_BYTE *)(a1 + 41152))
  {
    v5 = (_DWORD *)(a1 + 40356);
    if (!a2 || *(double *)(a1 + 40928) == 0.0)
    {
      if (*(double *)(a1 + 41120) > 0.0)
      {
        VideoStallLength = _VideoReceiver_GetVideoStallLength(a1);
        v16 = micro();
        _VideoReceiver_UpdateVideoStallTime(a1, VideoStallLength, v16);
        v22 = *(FILE ***)(v2 + 1008);
        if (v22)
          VRDump_AddEvent(v22, 6u, 0, v17, v18, v19, v20, v21, v36);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v28 = VRTraceErrorLogLevelToCSTR();
          v29 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v30 = *(_DWORD *)(v2 + 456);
            v31 = *(_QWORD *)(v2 + 432);
            v36 = 136316674;
            v37 = v28;
            v38 = 2080;
            v39 = "_VideoReceiver_UpdateVideoStallStatus";
            v40 = 1024;
            v41 = 1332;
            v42 = 2048;
            v43 = a1;
            v44 = 1024;
            v45 = v30;
            v46 = 2048;
            v47 = VideoStallLength;
            v48 = 2048;
            v49 = v31;
            _os_log_impl(&dword_1D8A54000, v29, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Stopping video stall. count=%u stall length=%f total stall time=%f", (uint8_t *)&v36, 0x40u);
          }
        }
        if (*(_BYTE *)(v2 + 1016))
        {
          v32 = *(FILE ***)(v2 + 1008);
          if (v32)
            VRDump_AddEvent(v32, 8u, 0, v23, v24, v25, v26, v27, v36);
        }
      }
    }
    else if (*(double *)(a1 + 41120) == 0.0)
    {
      *(double *)(a1 + 41120) = micro();
      *(_QWORD *)(v2 + 472) = 0;
      ++*(_DWORD *)(v2 + 456);
      v11 = *(FILE ***)(v2 + 1008);
      if (v11)
        VRDump_AddEvent(v11, 5u, 0, v6, v7, v8, v9, v10, v36);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v12 = VRTraceErrorLogLevelToCSTR();
        v13 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v14 = *(_DWORD *)(v2 + 456);
          v36 = 136316162;
          v37 = v12;
          v38 = 2080;
          v39 = "_VideoReceiver_UpdateVideoStallStatus";
          v40 = 1024;
          v41 = 1325;
          v42 = 2048;
          v43 = a1;
          v44 = 1024;
          v45 = v14;
          _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Starting video stall. count=%u", (uint8_t *)&v36, 0x2Cu);
        }
      }
    }
    if ((*v5 & 0xFFFFFFFE) == 2)
    {
      ReportingEventDictionary = _VideoReceiver_CreateReportingEventDictionary(a1);
      if (ReportingEventDictionary)
      {
        v34 = ReportingEventDictionary;
        v36 = a2;
        v35 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &v36);
        CFDictionaryAddValue(v34, CFSTR("VCSPVideoDegraded"), v35);
        CFRelease(v35);
        reportingGenericEvent();
        CFRelease(v34);
      }
    }
  }
}

void _VideoReceiver_ShowFrame(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  __CVBuffer *v5;
  const __CFNumber *Attachment;
  int Width;
  const __CFNumber *v8;
  int Height;
  __CFDictionary *ReportingEventDictionary;
  __CVBuffer *v11;
  int v12;
  int v13;
  int32_t v14;
  int32_t v15;
  int BytesPerRow;
  void *BaseAddress;
  __CVBuffer *v18;
  const __CFArray *v19;
  uint64_t v20;
  NSObject *v21;
  int v22;
  Float64 Seconds;
  int v24;
  const void *ValueAtIndex;
  const void *v26;
  const void *v27;
  CFNumberRef v28;
  void (*v29)(uint64_t, uint64_t, CMTime *, uint64_t);
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  NSObject *v34;
  int v35;
  double v36;
  double v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  NSObject *v43;
  NSObject *v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  Float64 v53;
  int v54;
  int v55;
  CVAttachmentMode attachmentMode;
  CVAttachmentMode v57;
  CMTime valuePtr;
  int v59;
  __int16 v60;
  uint64_t v61;
  __int16 v62;
  int v63;
  __int16 v64;
  int v65;
  __int16 v66;
  _BYTE v67[10];
  int v68;
  __int16 v69;
  const void *v70;
  __int16 v71;
  const void *v72;
  __int16 v73;
  const void *v74;
  uint64_t v75;

  v75 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v4 = a1 + 40360;
    CVPixelBufferRetain(*(CVPixelBufferRef *)(a2 + 16));
    if (*(_BYTE *)(a2 + 66))
    {
      if (*(_BYTE *)(a2 + 72))
        _VideoReceiver_UpdateVideoStallStatus(a1, 0);
      v5 = *(__CVBuffer **)(a2 + 16);
      v57 = kCVAttachmentMode_ShouldNotPropagate;
      LODWORD(valuePtr.value) = 0;
      attachmentMode = -1431655766;
      Attachment = (const __CFNumber *)CVBufferGetAttachment(v5, CFSTR("VraWidth"), &attachmentMode);
      if (!Attachment
        || (CFNumberGetValue(Attachment, kCFNumberIntType, &valuePtr),
            Width = valuePtr.value,
            SLODWORD(valuePtr.value) <= 0))
      {
        Width = CVPixelBufferGetWidth(v5);
      }
      v8 = (const __CFNumber *)CVBufferGetAttachment(v5, CFSTR("VraHeight"), &attachmentMode);
      if (!v8
        || (CFNumberGetValue(v8, kCFNumberIntType, &v57),
            Height = v57,
            (int)v57 <= (int)kCVAttachmentMode_ShouldNotPropagate))
      {
        Height = CVPixelBufferGetHeight(v5);
      }
      if (*(_DWORD *)(v4 + 452) != Width || *(_DWORD *)(v4 + 456) != Height)
      {
        ReportingEventDictionary = _VideoReceiver_CreateReportingEventDictionary(a1);
        reportingVideoProp();
        if (ReportingEventDictionary)
          CFRelease(ReportingEventDictionary);
        *(_DWORD *)(v4 + 452) = Width;
        *(_DWORD *)(v4 + 456) = Height;
      }
      v11 = *(__CVBuffer **)(a2 + 16);
      v12 = *(_DWORD *)(a2 + 24);
      v13 = *(_DWORD *)(a1 + 1060);
      if (v13 == 1)
      {
        if (*(_DWORD *)(a1 + 1056))
          goto LABEL_19;
        v14 = CVPixelBufferGetWidth(*(CVPixelBufferRef *)(a2 + 16));
        v15 = CVPixelBufferGetHeight(v11);
        BytesPerRow = CVPixelBufferGetBytesPerRow(v11);
        CVPixelBufferLockBaseAddress(v11, 0);
        BaseAddress = CVPixelBufferGetBaseAddress(v11);
        VideoReceiverUtil_Capture2vuyFile(BaseAddress, BytesPerRow * v15, v14, v15, *(int *)(a1 + 1036) >> 2, a1 + 40840, (v12 - *(_DWORD *)(v4 + 548)) >> 2);
        CVPixelBufferUnlockBaseAddress(v11, 0);
        v13 = *(_DWORD *)(a1 + 1060);
        if (v13 == 1)
        {
LABEL_19:
          WriteYuvFrame(v11, *(_QWORD *)(v4 + 864), 0);
          v13 = *(_DWORD *)(a1 + 1060);
        }
      }
      if (v13 == 2)
        DumpFrameYuvWithTimestamp(1, v11, v12);
      v18 = *(__CVBuffer **)(a2 + 16);
      if (*(_BYTE *)(v4 + 833))
      {
        v57 = -1431655766;
        v19 = (const __CFArray *)CVBufferGetAttachment(v18, CFSTR("PSNRArray"), &v57);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v20 = VRTraceErrorLogLevelToCSTR();
          v21 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v22 = *(unsigned __int16 *)(a2 + 48);
            v55 = *(_DWORD *)(a2 + 24);
            valuePtr = *(CMTime *)(a2 + 80);
            Seconds = CMTimeGetSeconds(&valuePtr);
            v24 = *(unsigned __int8 *)(a2 + 66);
            ValueAtIndex = CFArrayGetValueAtIndex(v19, 0);
            v26 = CFArrayGetValueAtIndex(v19, 1);
            v27 = CFArrayGetValueAtIndex(v19, 2);
            LODWORD(valuePtr.value) = 136317698;
            *(CMTimeValue *)((char *)&valuePtr.value + 4) = v20;
            LOWORD(valuePtr.flags) = 2080;
            *(_QWORD *)((char *)&valuePtr.flags + 2) = "_VideoReceiver_ShowFrame";
            HIWORD(valuePtr.epoch) = 1024;
            v59 = 1865;
            v60 = 2048;
            v61 = a1;
            v62 = 1024;
            v63 = v22;
            v64 = 1024;
            v65 = v55;
            v66 = 2048;
            *(Float64 *)v67 = Seconds;
            *(_WORD *)&v67[8] = 1024;
            v68 = v24;
            v69 = 2112;
            v70 = ValueAtIndex;
            v71 = 2112;
            v72 = v26;
            v73 = 2112;
            v74 = v27;
            _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] for streamID=%d decoded frame with presentationTimestamp=%u frameTime=%f shouldShowFrame=%d Y-PSNR=%@ U-PSNR=%@ V-PSNR=%@", (uint8_t *)&valuePtr, 0x60u);
          }
        }
        v18 = *(__CVBuffer **)(a2 + 16);
      }
      *(_DWORD *)(v4 + 904) = *(_DWORD *)(a2 + 24);
      ++*(_WORD *)(v4 + 660);
      ++*(_DWORD *)(v4 + 644);
      if (v18)
      {
        v28 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt16Type, (const void *)(a2 + 28));
        CVBufferSetAttachment(*(CVBufferRef *)(a2 + 16), CFSTR("FrameSequenceNumber"), v28, kCVAttachmentMode_ShouldPropagate);
        if (v28)
          CFRelease(v28);
        v29 = *(void (**)(uint64_t, uint64_t, CMTime *, uint64_t))(a1 + 1392);
        v30 = *(_QWORD *)(a1 + 1384);
        v31 = *(_QWORD *)(a2 + 16);
        v32 = *(unsigned __int8 *)(v4 + 1008);
        valuePtr = *(CMTime *)(a2 + 80);
        v29(v30, v31, &valuePtr, v32);
      }
      else if (*(_QWORD *)(a2 + 8))
      {
        (*(void (**)(_QWORD))(a1 + 1400))(*(_QWORD *)(a1 + 1384));
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v33 = VRTraceErrorLogLevelToCSTR();
        v34 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v51 = *(unsigned __int16 *)(a2 + 48);
          v52 = *(_DWORD *)(a2 + 24);
          valuePtr = *(CMTime *)(a2 + 80);
          v53 = CMTimeGetSeconds(&valuePtr);
          v54 = *(unsigned __int8 *)(a2 + 66);
          LODWORD(valuePtr.value) = 136316930;
          *(CMTimeValue *)((char *)&valuePtr.value + 4) = v33;
          LOWORD(valuePtr.flags) = 2080;
          *(_QWORD *)((char *)&valuePtr.flags + 2) = "_VideoReceiver_ShowFrame";
          HIWORD(valuePtr.epoch) = 1024;
          v59 = 1881;
          v60 = 2048;
          v61 = a1;
          v62 = 1024;
          v63 = v51;
          v64 = 1024;
          v65 = v52;
          v66 = 2048;
          *(Float64 *)v67 = v53;
          *(_WORD *)&v67[8] = 1024;
          v68 = v54;
          _os_log_error_impl(&dword_1D8A54000, v34, OS_LOG_TYPE_ERROR, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Trying to show a NULL frame for streamID=%d decoded frame with presentationTimestamp=%u frameTime=%f shouldShowFrame=%d", (uint8_t *)&valuePtr, 0x42u);
        }
      }
    }
    CVPixelBufferRelease(*(CVPixelBufferRef *)(a2 + 16));
    v35 = *(_DWORD *)(a2 + 24);
    v36 = micro();
    *(_DWORD *)(v4 + 548) = v35;
    v37 = *(double *)(v4 + 568);
    if (v37 != 0.0)
    {
      v38 = (int)((v36 - v37) * 1000.0 + 0.5);
      if (*(unsigned __int16 *)(v4 + 576) < v38)
        *(_WORD *)(v4 + 576) = v38;
    }
    *(double *)(v4 + 568) = v36;
    v39 = *(_QWORD *)(a1 + 1168);
    if (v39)
    {
      if (!*(_QWORD *)v4 || (v40 = *(_QWORD *)(*(_QWORD *)v4 + 80)) == 0)
        v40 = *(_QWORD *)(v4 + 288);
      if (VCMediaControlInfoGeneratorGetVersion(v40) == 2)
      {
        v41 = *(_DWORD *)(v4 + 656) - *(unsigned __int16 *)(v4 + 648) + 1;
        *(_DWORD *)(v39 + 40) = v41 - *(_DWORD *)(v4 + 644);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          v42 = VRTraceErrorLogLevelToCSTR();
          v43 = *MEMORY[0x1E0CF2758];
          v44 = *MEMORY[0x1E0CF2758];
          if (*MEMORY[0x1E0CF2748])
          {
            if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
            {
              v45 = *(_DWORD *)(v39 + 40);
              v46 = *(_DWORD *)(v4 + 656);
              v47 = *(unsigned __int16 *)(v4 + 648);
              LODWORD(valuePtr.value) = 136316930;
              *(CMTimeValue *)((char *)&valuePtr.value + 4) = v42;
              LOWORD(valuePtr.flags) = 2080;
              *(_QWORD *)((char *)&valuePtr.flags + 2) = "_VideoReceiver_UpdateWRMFrameErasureMetrics";
              HIWORD(valuePtr.epoch) = 1024;
              v59 = 1712;
              v60 = 2048;
              v61 = a1;
              v62 = 1024;
              v63 = v45;
              v64 = 1024;
              v65 = v41;
              v66 = 1024;
              *(_DWORD *)v67 = v46;
              *(_WORD *)&v67[4] = 1024;
              *(_DWORD *)&v67[6] = v47;
              _os_log_impl(&dword_1D8A54000, v43, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] videoFrameErasureCount=%d videoFramesExpected=%d maxFrameSequenceNumber=%d baseFrameSequenceNumber=%d", (uint8_t *)&valuePtr, 0x3Eu);
            }
          }
          else if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
          {
            v48 = *(_DWORD *)(v39 + 40);
            v49 = *(_DWORD *)(v4 + 656);
            v50 = *(unsigned __int16 *)(v4 + 648);
            LODWORD(valuePtr.value) = 136316930;
            *(CMTimeValue *)((char *)&valuePtr.value + 4) = v42;
            LOWORD(valuePtr.flags) = 2080;
            *(_QWORD *)((char *)&valuePtr.flags + 2) = "_VideoReceiver_UpdateWRMFrameErasureMetrics";
            HIWORD(valuePtr.epoch) = 1024;
            v59 = 1712;
            v60 = 2048;
            v61 = a1;
            v62 = 1024;
            v63 = v48;
            v64 = 1024;
            v65 = v41;
            v66 = 1024;
            *(_DWORD *)v67 = v49;
            *(_WORD *)&v67[4] = 1024;
            *(_DWORD *)&v67[6] = v50;
            _os_log_debug_impl(&dword_1D8A54000, v43, OS_LOG_TYPE_DEBUG, "VideoReceiver [%s] %s:%d VideoReceiver[%p] videoFrameErasureCount=%d videoFramesExpected=%d maxFrameSequenceNumber=%d baseFrameSequenceNumber=%d", (uint8_t *)&valuePtr, 0x3Eu);
          }
        }
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VideoReceiver_ShowFrame_cold_1();
  }
}

void _VideoReceiver_VideoAlarmCommon(uint64_t a1, uint64_t a2, int a3, int a4, int a5, int a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  int v15;
  int ErrorLogLevelForModule;
  BOOL v17;
  uint64_t v18;
  NSObject *v19;
  NSObject *v20;
  uint64_t v21;
  NSObject *v22;
  NSObject *v23;
  uint64_t v24;
  NSObject *v25;
  NSObject *v26;
  int v27;
  double v28;
  double v29;
  double v30;
  char *v31;
  uint64_t v32;
  NSObject *v33;
  NSObject *v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  uint64_t v41;
  NSObject *v42;
  NSObject *v43;
  int v44;
  double v45;
  CMTime v47;
  const __CFAllocator **v48;
  CMTime buf;
  int v50;
  __int16 v51;
  uint64_t v52;
  __int16 v53;
  int v54;
  __int16 v55;
  int v56;
  __int16 v57;
  double v58;
  __int16 v59;
  int v60;
  __int16 v61;
  int v62;
  uint64_t v63;

  v63 = *MEMORY[0x1E0C80C00];
  v13 = CheckInHandleDebug();
  if (v13)
  {
    v14 = v13;
    v15 = *(_DWORD *)(v13 + 1448);
    ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    if (v15)
      v17 = 0;
    else
      v17 = a4 == 0;
    if (v17)
    {
      if (ErrorLogLevelForModule >= 8)
      {
        v24 = VRTraceErrorLogLevelToCSTR();
        v25 = *MEMORY[0x1E0CF2758];
        v26 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
          {
            v27 = *(_DWORD *)(a2 + 8);
            v28 = *(double *)a2;
            LODWORD(buf.value) = 136317186;
            *(CMTimeValue *)((char *)&buf.value + 4) = v24;
            LOWORD(buf.flags) = 2080;
            *(_QWORD *)((char *)&buf.flags + 2) = "_VideoReceiver_VideoAlarmCommon";
            HIWORD(buf.epoch) = 1024;
            v50 = 2135;
            v51 = 2048;
            v52 = v14;
            v53 = 1024;
            v54 = v27;
            v55 = 1024;
            v56 = a5;
            v57 = 2048;
            v58 = v28;
            v59 = 1024;
            v60 = a6;
            v61 = 1024;
            v62 = a3;
            _os_log_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] alarmRtpTimestamp=%u alarmType=%d presentationTime=%f shouldShowFrame=%d didAssembleFail=%d", (uint8_t *)&buf, 0x48u);
          }
        }
        else if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
        {
          v44 = *(_DWORD *)(a2 + 8);
          v45 = *(double *)a2;
          LODWORD(buf.value) = 136317186;
          *(CMTimeValue *)((char *)&buf.value + 4) = v24;
          LOWORD(buf.flags) = 2080;
          *(_QWORD *)((char *)&buf.flags + 2) = "_VideoReceiver_VideoAlarmCommon";
          HIWORD(buf.epoch) = 1024;
          v50 = 2135;
          v51 = 2048;
          v52 = v14;
          v53 = 1024;
          v54 = v44;
          v55 = 1024;
          v56 = a5;
          v57 = 2048;
          v58 = v45;
          v59 = 1024;
          v60 = a6;
          v61 = 1024;
          v62 = a3;
          _os_log_debug_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_DEBUG, "VideoReceiver [%s] %s:%d VideoReceiver[%p] alarmRtpTimestamp=%u alarmType=%d presentationTime=%f shouldShowFrame=%d didAssembleFail=%d", (uint8_t *)&buf, 0x48u);
        }
      }
      CMTimeMake(&v47, (uint64_t)(*(double *)a2 * 1000000000.0), 1000000000);
      buf = v47;
      CMTimeGetSeconds(&buf);
      kdebug_trace();
      if (a3)
      {
        if (a5 == 1 || !*(_BYTE *)(v14 + 1188))
        {
          _VideoReceiver_UpdateVideoStallStatus(v14, 1);
        }
        else if (!a5)
        {
          VCVideoPlayer_QueueAlarmForDisplay(*(_QWORD *)(v14 + 40432), (uint64_t)VideoReceiver_VideoAlarmForDisplay, a1, *(_DWORD *)(a2 + 8), a7, 1, *(double *)(a2 + 16));
        }
      }
      if (_VideoReceiver_CanDequeue(v14, a5, *(_DWORD *)(a2 + 8)))
      {
        do
        {
          if (*(_BYTE *)(v14 + 41152))
          {
            v29 = *(double *)a2;
            os_unfair_lock_lock((os_unfair_lock_t)(v14 + 41156));
            *(double *)(v14 + 41144) = v29;
            if (*(double *)(v14 + 41128) < v29)
              *(_QWORD *)(v14 + 41128) = 0;
            os_unfair_lock_unlock((os_unfair_lock_t)(v14 + 41156));
          }
          if (a5)
          {
            v30 = *(double *)a2;
            pthread_mutex_lock((pthread_mutex_t *)(v14 + 41304));
            v31 = (char *)CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(v14 + 41296));
            v48 = (const __CFAllocator **)v31;
            pthread_mutex_unlock((pthread_mutex_t *)(v14 + 41304));
            if (v31)
            {
              CMTimeMake(&buf, (uint64_t)(v30 * 1000000000.0), 1000000000);
              *(CMTime *)(v31 + 80) = buf;
              v31[66] = a6;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
              {
                v32 = VRTraceErrorLogLevelToCSTR();
                v33 = *MEMORY[0x1E0CF2758];
                v34 = *MEMORY[0x1E0CF2758];
                if (*MEMORY[0x1E0CF2748])
                {
                  if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
                  {
                    v35 = *((unsigned __int16 *)v31 + 24);
                    v36 = *((_DWORD *)v31 + 6);
                    v37 = v31[72];
                    LODWORD(buf.value) = 136317186;
                    *(CMTimeValue *)((char *)&buf.value + 4) = v32;
                    LOWORD(buf.flags) = 2080;
                    *(_QWORD *)((char *)&buf.flags + 2) = "_VideoReceiver_DequeueAndDisplayFrame";
                    HIWORD(buf.epoch) = 1024;
                    v50 = 568;
                    v51 = 2048;
                    v52 = v14;
                    v53 = 1024;
                    v54 = v35;
                    v55 = 1024;
                    v56 = v36;
                    v57 = 2048;
                    v58 = v30;
                    v59 = 1024;
                    v60 = a6;
                    v61 = 1024;
                    v62 = v37;
                    _os_log_impl(&dword_1D8A54000, v33, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] for streamID=%u dequeue and display frame. RTPTimestamp=%u presentationTime=%f shouldShowFrame=%d canStopVideoStall=%d", (uint8_t *)&buf, 0x48u);
                  }
                }
                else if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
                {
                  v38 = *((unsigned __int16 *)v31 + 24);
                  v39 = *((_DWORD *)v31 + 6);
                  v40 = v31[72];
                  LODWORD(buf.value) = 136317186;
                  *(CMTimeValue *)((char *)&buf.value + 4) = v32;
                  LOWORD(buf.flags) = 2080;
                  *(_QWORD *)((char *)&buf.flags + 2) = "_VideoReceiver_DequeueAndDisplayFrame";
                  HIWORD(buf.epoch) = 1024;
                  v50 = 568;
                  v51 = 2048;
                  v52 = v14;
                  v53 = 1024;
                  v54 = v38;
                  v55 = 1024;
                  v56 = v39;
                  v57 = 2048;
                  v58 = v30;
                  v59 = 1024;
                  v60 = a6;
                  v61 = 1024;
                  v62 = v40;
                  _os_log_debug_impl(&dword_1D8A54000, v33, OS_LOG_TYPE_DEBUG, "VideoReceiver [%s] %s:%d VideoReceiver[%p] for streamID=%u dequeue and display frame. RTPTimestamp=%u presentationTime=%f shouldShowFrame=%d canStopVideoStall=%d", (uint8_t *)&buf, 0x48u);
                }
              }
              _VideoReceiver_ShowFrame(v14, (uint64_t)v31);
              _VideoReceiver_CheckAndRequestKeyFrame(v14, (uint64_t)v31);
              VCVideoReceiverDecodedFrame_Destroy(&v48);
            }
            else if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
            {
              v41 = VRTraceErrorLogLevelToCSTR();
              v42 = *MEMORY[0x1E0CF2758];
              v43 = *MEMORY[0x1E0CF2758];
              if (*MEMORY[0x1E0CF2748])
              {
                if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
                {
                  LODWORD(buf.value) = 136315906;
                  *(CMTimeValue *)((char *)&buf.value + 4) = v41;
                  LOWORD(buf.flags) = 2080;
                  *(_QWORD *)((char *)&buf.flags + 2) = "_VideoReceiver_DequeueAndDisplayFrame";
                  HIWORD(buf.epoch) = 1024;
                  v50 = 563;
                  v51 = 2048;
                  v52 = v14;
                  _os_log_impl(&dword_1D8A54000, v42, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Unable to dequeue and display frame.  No frame returned from the queue.", (uint8_t *)&buf, 0x26u);
                }
              }
              else if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
              {
                LODWORD(buf.value) = 136315906;
                *(CMTimeValue *)((char *)&buf.value + 4) = v41;
                LOWORD(buf.flags) = 2080;
                *(_QWORD *)((char *)&buf.flags + 2) = "_VideoReceiver_DequeueAndDisplayFrame";
                HIWORD(buf.epoch) = 1024;
                v50 = 563;
                v51 = 2048;
                v52 = v14;
                _os_log_debug_impl(&dword_1D8A54000, v42, OS_LOG_TYPE_DEBUG, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Unable to dequeue and display frame.  No frame returned from the queue.", (uint8_t *)&buf, 0x26u);
              }
            }
          }
          else
          {
            _VideoReceiver_DequeueAndDecode(v14, *(_DWORD *)(a2 + 8), *(double *)a2, *(double *)(a2 + 16));
          }
        }
        while ((_VideoReceiver_CanDequeue(v14, a5, *(_DWORD *)(a2 + 8)) & 1) != 0);
      }
    }
    else if (ErrorLogLevelForModule >= 8)
    {
      v18 = VRTraceErrorLogLevelToCSTR();
      v19 = *MEMORY[0x1E0CF2758];
      v20 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf.value) = 136315906;
          *(CMTimeValue *)((char *)&buf.value + 4) = v18;
          LOWORD(buf.flags) = 2080;
          *(_QWORD *)((char *)&buf.flags + 2) = "_VideoReceiver_VideoAlarmCommon";
          HIWORD(buf.epoch) = 1024;
          v50 = 2130;
          v51 = 2048;
          v52 = v14;
          _os_log_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] stopping", (uint8_t *)&buf, 0x26u);
        }
      }
      else if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        _VideoReceiver_VideoAlarmCommon_cold_2();
      }
    }
    CheckOutHandleDebug();
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v21 = VRTraceErrorLogLevelToCSTR();
    v22 = *MEMORY[0x1E0CF2758];
    v23 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.value) = 136315906;
        *(CMTimeValue *)((char *)&buf.value + 4) = v21;
        LOWORD(buf.flags) = 2080;
        *(_QWORD *)((char *)&buf.flags + 2) = "_VideoReceiver_VideoAlarmCommon";
        HIWORD(buf.epoch) = 1024;
        v50 = 2125;
        v51 = 1024;
        LODWORD(v52) = a5;
        _os_log_impl(&dword_1D8A54000, v22, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver is null. alarmType=%d", (uint8_t *)&buf, 0x22u);
      }
    }
    else if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
    {
      _VideoReceiver_VideoAlarmCommon_cold_1();
    }
  }
}

const void *_VideoReceiver_CanDequeue(uint64_t a1, int a2, int a3)
{
  opaqueCMSimpleQueue **v6;
  opaqueCMSimpleQueue *v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  pthread_mutex_t *v11;
  _DWORD *Head;
  int v13;
  const void *result;
  int v16;
  uint64_t v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int32_t Count;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v6 = (opaqueCMSimpleQueue **)(a1 + 41288);
  if (a2)
    v6 = (opaqueCMSimpleQueue **)(a1 + 41296);
  v7 = *v6;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v8 = VRTraceErrorLogLevelToCSTR();
    v9 = *MEMORY[0x1E0CF2758];
    v10 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        v16 = 136316418;
        v17 = v8;
        v18 = 2080;
        v19 = "_VideoReceiver_CanDequeue";
        v20 = 1024;
        v21 = 536;
        v22 = 2048;
        v23 = a1;
        v24 = 1024;
        v25 = a3;
        v26 = 1024;
        Count = CMSimpleQueueGetCount(v7);
        _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] alarmRTPTimestamp=%u count=%d", (uint8_t *)&v16, 0x32u);
        if (!a2)
          goto LABEL_14;
LABEL_10:
        v11 = (pthread_mutex_t *)(a1 + 41304);
        pthread_mutex_lock(v11);
        Head = CMSimpleQueueGetHead(v7);
        if (!Head)
        {
          pthread_mutex_unlock(v11);
          return 0;
        }
        v13 = Head[6];
        pthread_mutex_unlock(v11);
        return (const void *)(v13 == a3 || (v13 - a3) > 0x7FFFFFFE);
      }
    }
    else if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      v16 = 136316418;
      v17 = v8;
      v18 = 2080;
      v19 = "_VideoReceiver_CanDequeue";
      v20 = 1024;
      v21 = 536;
      v22 = 2048;
      v23 = a1;
      v24 = 1024;
      v25 = a3;
      v26 = 1024;
      Count = CMSimpleQueueGetCount(v7);
      _os_log_debug_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEBUG, "VideoReceiver [%s] %s:%d VideoReceiver[%p] alarmRTPTimestamp=%u count=%d", (uint8_t *)&v16, 0x32u);
      if (a2)
        goto LABEL_10;
      goto LABEL_14;
    }
  }
  if (a2)
    goto LABEL_10;
LABEL_14:
  result = CMSimpleQueueGetHead(v7);
  if (!result)
    return result;
  v13 = *((_DWORD *)CMSimpleQueueGetHead(v7) + 4);
  return (const void *)(v13 == a3 || (v13 - a3) > 0x7FFFFFFE);
}

void _VideoReceiver_DequeueAndDecode(uint64_t a1, int a2, double a3, double a4)
{
  uint64_t v7;
  uint64_t v8;
  const __CFAllocator **v9;
  const __CFAllocator **v10;
  unsigned int v11;
  unsigned int *Stream;
  unsigned int *v13;
  uint64_t v14;
  _BOOL4 v15;
  unsigned int v16;
  int v17;
  unsigned int v18;
  int v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  NSObject *v24;
  int v25;
  int v26;
  int v27;
  unsigned int v28;
  unsigned int v29;
  __int16 v30;
  uint64_t v31;
  NSObject *v32;
  NSObject *v33;
  int v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  NSObject *v39;
  int v40;
  int v41;
  int v42;
  double v43;
  int v44;
  __int128 v45;
  int v46;
  size_t v47;
  FILE *v48;
  uint64_t i;
  __int128 v50;
  char v51;
  size_t v52;
  size_t v53;
  size_t j;
  CC_LONG v55;
  uint64_t v56;
  int v57;
  int v58;
  size_t v59;
  uint64_t v60;
  NSObject *v61;
  OSStatus v62;
  OSStatus v63;
  uint64_t v64;
  NSObject *v65;
  int v66;
  OpaqueCMBlockBuffer *SampleFromBuffer;
  char *v68;
  uint64_t v69;
  int v70;
  uint64_t v71;
  NSObject *v72;
  int v73;
  int v74;
  char *v75;
  _DWORD *v76;
  uint64_t v77;
  NSObject *v78;
  uint64_t v79;
  int v80;
  const void *v81;
  CFTypeRef *v82;
  int v83;
  size_t v84;
  size_t v85;
  size_t v86;
  const opaqueCMFormatDescription *v87;
  __int128 v88;
  __int128 v89;
  unsigned int v90;
  CFNumberRef v91;
  CFNumberRef v92;
  uint64_t v93;
  NSObject *v94;
  NSObject *v95;
  __int128 v96;
  const __CFDictionary *v97;
  CFNumberRef v98;
  const __CFString *v99;
  const __CFDictionary *v100;
  CFNumberRef v101;
  const __CFString *v102;
  int v103;
  int v104;
  uint64_t v105;
  NSObject *v106;
  uint64_t v107;
  int v108;
  __int128 v109;
  const __CFDictionary *v110;
  CFNumberRef v111;
  const __CFString *Value;
  int v113;
  CC_LONG v114;
  OpaqueCMBlockBuffer *v115;
  uint64_t v116;
  const opaqueCMFormatDescription *v117;
  int ErrorLogLevelForModule;
  uint64_t v119;
  NSObject *v120;
  CFNumberRef v121;
  CFNumberRef v122;
  CFNumberRef v123;
  CFNumberRef v124;
  const __CFArray *SampleAttachmentsArray;
  __CFDictionary *ValueAtIndex;
  CFNumberRef v127;
  CFNumberRef v128;
  CFNumberRef v129;
  CFNumberRef v130;
  uint64_t v131;
  NSObject *v132;
  int v133;
  uint64_t v134;
  NSObject *v135;
  char v136;
  int v137;
  int v138;
  int v139;
  int v140;
  uint64_t v141;
  NSObject *v142;
  int v143;
  int v144;
  int v145;
  uint64_t v146;
  NSObject *v147;
  int v148;
  CFNumberRef v149;
  CFNumberRef v150;
  uint64_t v151;
  NSObject *v152;
  const __CFAllocator **v153;
  char v154;
  NSObject *v155;
  const __CFAllocator *v156;
  int v157;
  int v158;
  char v159;
  int v160;
  char v161;
  uint64_t v162;
  unsigned __int16 v163;
  unsigned int v164;
  const __CFAllocator *v165;
  unsigned int v166;
  int v167;
  uint64_t v168;
  NSObject *v169;
  uint64_t v170;
  const __CFAllocator *v171;
  int v172;
  int v173;
  const char *v174;
  uint8_t *p_c;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  NSObject *v179;
  int v180;
  uint64_t v181;
  uint64_t v182;
  NSObject *v183;
  const char *v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  NSObject *v188;
  int v189;
  char v190;
  unsigned int v191;
  int v192;
  unsigned int *v193;
  uint64_t v194;
  __int128 v195[3];
  unint64_t v196;
  unint64_t v197;
  int v198;
  const __CFAllocator **v199;
  int32_t v200;
  int32_t v201;
  size_t lengthAtOffsetOut;
  char *dataPointerOut;
  CC_SHA1_CTX c;
  unsigned __int8 md[24];
  _BYTE valuePtr[64];
  __int128 v207;
  __int128 v208;
  __int128 v209;
  __int128 v210;
  _OWORD v211[2];
  _BYTE buf[2048];
  uint64_t v213;

  v7 = a1;
  v213 = *MEMORY[0x1E0C80C00];
  v8 = a1 + 40848;
  v9 = (const __CFAllocator **)CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 41288));
  v199 = v9;
  if (!v9)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VideoReceiver_DequeueAndDecode_cold_1();
    }
    goto LABEL_230;
  }
  v10 = v9;
  *((double *)v9 + 4) = a3;
  v11 = *(unsigned __int16 *)(v7 + 1162);
  if (v11 < 2)
    Stream = _VideoReceiver_GetStream((unsigned int *)v7, *((unsigned __int16 *)v9 + 10), *((unsigned __int8 *)v9 + 64));
  else
    Stream = _VideoReceiver_GetStreamWithTileIndex((unsigned int *)v7, *((unsigned __int16 *)v9 + 22));
  v13 = Stream;
  if (!Stream)
  {
    v177 = v7;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v178 = VRTraceErrorLogLevelToCSTR();
      v179 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v180 = *((unsigned __int16 *)v10 + 10);
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)&buf[4] = v178;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VideoReceiver_DequeueAndDecode";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 2033;
        *(_WORD *)&buf[28] = 2048;
        *(_QWORD *)&buf[30] = v177;
        *(_WORD *)&buf[38] = 1024;
        *(_DWORD *)&buf[40] = v180;
        _os_log_error_impl(&dword_1D8A54000, v179, OS_LOG_TYPE_ERROR, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Unable to find the VCVideoReceiverStream matching streamID %d", buf, 0x2Cu);
      }
    }
    goto LABEL_230;
  }
  v14 = v7 + 40356;
  if (*(_BYTE *)(v7 + 1253))
    v15 = *((_BYTE *)v10 + 82) != 0;
  else
    v15 = 0;
  v189 = a2;
  v16 = _VideoReceiver_CanDequeue(v7, 0, a2);
  v190 = v15 | v16;
  v191 = v11;
  v17 = (v15 | v16) ^ 1;
  if (v11 > 1)
    v17 = 1;
  v193 = v13;
  v194 = v7 + 40356;
  v192 = v17;
  if ((v17 & 1) == 0)
  {
    v18 = v16;
    v19 = *(_DWORD *)(v7 + 40688);
    v20 = *((_DWORD *)v10 + 4);
    v21 = v7;
    v22 = *(_DWORD *)(v7 + 1032);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v23 = VRTraceErrorLogLevelToCSTR();
      v24 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136318210;
        v25 = *((_DWORD *)v10 + 2);
        v26 = *((_DWORD *)v10 + 4);
        v27 = *(_DWORD *)(v194 + 332);
        *(_QWORD *)&buf[4] = v23;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VideoReceiver_DequeueAndDecode";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 2051;
        *(_WORD *)&buf[28] = 2048;
        *(_QWORD *)&buf[30] = v21;
        *(_WORD *)&buf[38] = 1024;
        *(_DWORD *)&buf[40] = v25;
        *(_WORD *)&buf[44] = 1024;
        *(_DWORD *)&buf[46] = v26;
        *(_WORD *)&buf[50] = 1024;
        *(_DWORD *)&buf[52] = v189;
        *(_WORD *)&buf[56] = 1024;
        *(_DWORD *)&buf[58] = v27;
        *(_WORD *)&buf[62] = 2048;
        *(_QWORD *)&buf[64] = 96;
        *(_WORD *)&buf[72] = 1024;
        *(_DWORD *)&buf[74] = 0;
        *(_WORD *)&buf[78] = 1024;
        *(_DWORD *)&buf[80] = v15;
        *(_WORD *)&buf[84] = 1024;
        *(_DWORD *)&buf[86] = v18;
        *(_WORD *)&buf[90] = 2048;
        *(double *)&buf[92] = (double)(v19 - v20) / (double)v22;
        _os_log_impl(&dword_1D8A54000, v24, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] decode but skip frame payload=%d sampleBuffer.timestamp=%u alarmRtpTimestamp=%u playoutRTPTimestamp=%u argsLength=%zu shouldShowFrame=%d didFrameArriveLate=%d canDequeue=%d exceededTime=%2.4f", buf, 0x64u);
      }
    }
    ++*(_DWORD *)(v8 + 180);
    v7 = v21;
    v13 = v193;
    v14 = v194;
  }
  v28 = *((unsigned __int16 *)v10 + 24);
  if (*(_BYTE *)(v8 + 148))
  {
    v29 = *(_DWORD *)(v8 + 168);
    if (v28 != (unsigned __int16)v29 && (unsigned __int16)(v28 - v29) <= 0x7FFEu)
    {
      if (v28 < (unsigned __int16)v29)
        v29 += 0x10000;
      v29 = v29 & 0xFFFF0000 | v28;
      *(_DWORD *)(v8 + 168) = v29;
    }
  }
  else
  {
    *(_DWORD *)(v8 + 168) = v28;
    *(_WORD *)(v8 + 160) = v28;
    *(_BYTE *)(v8 + 148) = 1;
    LOWORD(v29) = v28;
  }
  v30 = v29 - *(_WORD *)(v8 + 160);
  *(_WORD *)(v8 + 162) = v30 + 1;
  if (!*(_WORD *)(v8 + 164))
    *(_WORD *)(v8 + 164) = v30;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v31 = VRTraceErrorLogLevelToCSTR();
    v32 = *MEMORY[0x1E0CF2758];
    v33 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
      {
        v34 = *(unsigned __int16 *)(v8 + 162);
        v35 = *(unsigned __int16 *)(v8 + 164);
        v36 = *(_DWORD *)(v8 + 168);
        v37 = *(unsigned __int16 *)(v8 + 160);
        *(_DWORD *)buf = 136316930;
        *(_QWORD *)&buf[4] = v31;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VideoReceiver_UpdateExpectedNetworkFrameNumber";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 2006;
        *(_WORD *)&buf[28] = 2048;
        *(_QWORD *)&buf[30] = v7;
        *(_WORD *)&buf[38] = 1024;
        *(_DWORD *)&buf[40] = v34;
        *(_WORD *)&buf[44] = 1024;
        *(_DWORD *)&buf[46] = v35;
        *(_WORD *)&buf[50] = 1024;
        *(_DWORD *)&buf[52] = v36;
        *(_WORD *)&buf[56] = 1024;
        *(_DWORD *)&buf[58] = v37;
        _os_log_impl(&dword_1D8A54000, v32, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] expectedNetworkFrameNumber=%d lastReportedExpectedNetworkFrameNumber=%d maxFrameSequenceNumber=%d baseFrameSequenceNumber=%d", buf, 0x3Eu);
      }
    }
    else if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
    {
      v137 = *(unsigned __int16 *)(v8 + 162);
      v138 = *(unsigned __int16 *)(v8 + 164);
      v139 = *(_DWORD *)(v8 + 168);
      v140 = *(unsigned __int16 *)(v8 + 160);
      *(_DWORD *)buf = 136316930;
      *(_QWORD *)&buf[4] = v31;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "_VideoReceiver_UpdateExpectedNetworkFrameNumber";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 2006;
      *(_WORD *)&buf[28] = 2048;
      *(_QWORD *)&buf[30] = v7;
      *(_WORD *)&buf[38] = 1024;
      *(_DWORD *)&buf[40] = v137;
      *(_WORD *)&buf[44] = 1024;
      *(_DWORD *)&buf[46] = v138;
      *(_WORD *)&buf[50] = 1024;
      *(_DWORD *)&buf[52] = v139;
      *(_WORD *)&buf[56] = 1024;
      *(_DWORD *)&buf[58] = v140;
      _os_log_debug_impl(&dword_1D8A54000, v32, OS_LOG_TYPE_DEBUG, "VideoReceiver [%s] %s:%d VideoReceiver[%p] expectedNetworkFrameNumber=%d lastReportedExpectedNetworkFrameNumber=%d maxFrameSequenceNumber=%d baseFrameSequenceNumber=%d", buf, 0x3Eu);
    }
  }
  if (*(_BYTE *)(v8 + 345))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v38 = VRTraceErrorLogLevelToCSTR();
      v39 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v40 = *((unsigned __int16 *)v10 + 10);
        v41 = *((_DWORD *)v10 + 2);
        v42 = *((_DWORD *)v10 + 4);
        *(_DWORD *)buf = 136317186;
        *(_QWORD *)&buf[4] = v38;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VideoReceiver_DequeueAndDecode";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 2059;
        *(_WORD *)&buf[28] = 2048;
        *(_QWORD *)&buf[30] = v7;
        *(_WORD *)&buf[38] = 1024;
        *(_DWORD *)&buf[40] = v40;
        *(_WORD *)&buf[44] = 1024;
        *(_DWORD *)&buf[46] = v41;
        *(_WORD *)&buf[50] = 1024;
        *(_DWORD *)&buf[52] = v42;
        *(_WORD *)&buf[56] = 2048;
        *(_QWORD *)&buf[58] = 96;
        *(_WORD *)&buf[66] = 1024;
        *(_DWORD *)&buf[68] = v192;
        _os_log_impl(&dword_1D8A54000, v39, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] for streamID:%d dequeue frame for decode payload:%d timestamp:%u argsLength:%zu shouldShowFrame:%d", buf, 0x48u);
      }
    }
  }
  v200 = -1431655766;
  v201 = -1431655766;
  v43 = micro();
  if (*(_BYTE *)(v8 + 328) && *(_QWORD *)(v8 + 336))
  {
    v44 = *((_DWORD *)v10 + 4);
    memset(md, 170, 20);
    lengthAtOffsetOut = 0;
    dataPointerOut = 0;
    *(_QWORD *)&v45 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v45 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&c.data[9] = v45;
    *(_OWORD *)&c.data[13] = v45;
    *(_OWORD *)&c.data[1] = v45;
    *(_OWORD *)&c.data[5] = v45;
    *(_OWORD *)&c.h0 = v45;
    *(_OWORD *)&c.h4 = v45;
    CC_SHA1_Init(&c);
    if (CMBlockBufferGetDataPointer(v10[13], 0, &lengthAtOffsetOut, 0, &dataPointerOut))
    {
      v46 = 0;
    }
    else
    {
      v47 = 0;
      do
      {
        CC_SHA1_Update(&c, dataPointerOut, lengthAtOffsetOut);
        v47 += lengthAtOffsetOut;
      }
      while (!CMBlockBufferGetDataPointer(v10[13], v47, &lengthAtOffsetOut, 0, &dataPointerOut));
      v46 = v47;
    }
    CC_SHA1_Final(md, &c);
    v48 = *(FILE **)(v8 + 336);
    fprintf(v48, "[%08X:%dB SHA1:", v44, v46);
    for (i = 0; i != 20; ++i)
      fprintf(v48, "%02X", md[i]);
    fwrite("]\n", 2uLL, 1uLL, v48);
    *(_QWORD *)&v50 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v50 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&buf[284] = v50;
    *(_OWORD *)&buf[257] = v50;
    *(_OWORD *)&buf[273] = v50;
    *(_OWORD *)&buf[241] = v50;
    *(_OWORD *)&buf[225] = v50;
    *(_OWORD *)&buf[209] = v50;
    *(_OWORD *)&buf[193] = v50;
    *(_OWORD *)&buf[177] = v50;
    *(_OWORD *)&buf[161] = v50;
    *(_OWORD *)&buf[145] = v50;
    *(_OWORD *)&buf[129] = v50;
    *(_OWORD *)&buf[113] = v50;
    *(_OWORD *)&buf[97] = v50;
    *(_OWORD *)&buf[81] = v50;
    *(_OWORD *)&buf[65] = v50;
    *(_OWORD *)&buf[49] = v50;
    *(_OWORD *)&buf[33] = v50;
    *(_OWORD *)&buf[17] = v50;
    *(_OWORD *)&buf[1] = v50;
    LODWORD(v209) = -1431655766;
    v207 = v50;
    v208 = v50;
    *(_OWORD *)&valuePtr[32] = v50;
    *(_OWORD *)&valuePtr[48] = v50;
    *(_OWORD *)valuePtr = v50;
    *(_OWORD *)&valuePtr[16] = v50;
    buf[0] = 0;
    lengthAtOffsetOut = 0;
    dataPointerOut = 0;
    if (!CMBlockBufferGetDataPointer(v10[13], 0, &lengthAtOffsetOut, 0, &dataPointerOut))
    {
      v51 = 0;
      v52 = 0;
      do
      {
        v53 = lengthAtOffsetOut;
        if (lengthAtOffsetOut)
        {
          for (j = 0; j < lengthAtOffsetOut; ++j)
          {
            __sprintf_chk(valuePtr, 0, 0x64uLL, " %02X", dataPointerOut[j]);
            __strlcat_chk();
            if ((~(v51 + (_BYTE)j) & 0x1F) == 0)
            {
              fprintf(v48, "%s\n", buf);
              buf[0] = 0;
            }
            v53 = lengthAtOffsetOut;
          }
          v51 += j;
        }
        v52 += v53;
      }
      while (!CMBlockBufferGetDataPointer(v10[13], v52, &lengthAtOffsetOut, 0, &dataPointerOut));
      v13 = v193;
      v14 = v194;
      if ((v51 & 0x1F) != 0)
        fprintf(v48, "%s\n", buf);
    }
  }
  v55 = *((_DWORD *)v10 + 2);
  if (v55 == 100)
    v56 = 1752589105;
  else
    v56 = 1635148593;
  *(_DWORD *)(v8 + 800) = v56;
  v57 = *((_DWORD *)v10 + 3);
  v58 = *((_DWORD *)v10 + 4);
  if (v55 - 110 <= 0xF && ((1 << (v55 - 110)) & 0xC001) != 0)
    *(_DWORD *)(v14 + 448) = 1;
  if (v57 == 2)
  {
    *(_QWORD *)md = 0;
    v59 = *((int *)v10 + 56);
    dataPointerOut = (char *)v59;
    memset(buf, 170, sizeof(buf));
    if (v59 >= 0x801)
    {
      v59 = 2048;
      dataPointerOut = (char *)2048;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v60 = VRTraceErrorLogLevelToCSTR();
        v61 = *MEMORY[0x1E0CF2758];
        v59 = 2048;
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)valuePtr = 136315906;
          *(_QWORD *)&valuePtr[4] = v60;
          *(_WORD *)&valuePtr[12] = 2080;
          *(_QWORD *)&valuePtr[14] = "_VideoReceiver_CreateCompressedVideoFrameForDecode";
          *(_WORD *)&valuePtr[22] = 1024;
          *(_DWORD *)&valuePtr[24] = 953;
          *(_WORD *)&valuePtr[28] = 2048;
          *(_QWORD *)&valuePtr[30] = 2048;
          _os_log_error_impl(&dword_1D8A54000, v61, OS_LOG_TYPE_ERROR, "VideoReceiver [%s] %s:%d ParameterSet size=%zu too large", valuePtr, 0x26u);
          v59 = (size_t)dataPointerOut;
        }
        v13 = v193;
      }
    }
    v62 = CMBlockBufferAccessDataBytes(v10[13], 0, v59, buf, (char **)md);
    if (v62)
    {
      v63 = v62;
      if ((int)VRTraceGetErrorLogLevelForModule() < 3)
        goto LABEL_70;
      v64 = VRTraceErrorLogLevelToCSTR();
      v65 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        goto LABEL_70;
      *(_DWORD *)valuePtr = 136316162;
      *(_QWORD *)&valuePtr[4] = v64;
      *(_WORD *)&valuePtr[12] = 2080;
      *(_QWORD *)&valuePtr[14] = "_VideoReceiver_CreateCompressedVideoFrameForDecode";
      *(_WORD *)&valuePtr[22] = 1024;
      *(_DWORD *)&valuePtr[24] = 958;
      *(_WORD *)&valuePtr[28] = 2048;
      *(_QWORD *)&valuePtr[30] = v7;
      *(_WORD *)&valuePtr[38] = 1024;
      *(_DWORD *)&valuePtr[40] = v63;
      v174 = "VideoReceiver [%s] %s:%d VideoReceiver[%p] CMBlockBufferAccessDataBytes returned error:%i";
      p_c = valuePtr;
LABEL_232:
      _os_log_error_impl(&dword_1D8A54000, v65, OS_LOG_TYPE_ERROR, v174, p_c, 0x2Cu);
LABEL_70:
      v66 = 1;
LABEL_71:
      SampleFromBuffer = 0;
      goto LABEL_72;
    }
    v75 = *(char **)md;
    v76 = (_DWORD *)v194;
    if ((VideoDecoder_IsFormatCompatible_SPSPPS(*(_QWORD *)(v194 + 84), v56, *(uint64_t *)md, &dataPointerOut, 0, &v201, &v200) & 0x80000000) != 0)
    {
      *(_QWORD *)((char *)v211 + 14) = 0xAAAAAAAAAAAAAAAALL;
      *(_QWORD *)&v109 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v109 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v210 = v109;
      v211[0] = v109;
      v208 = v109;
      v209 = v109;
      *(_OWORD *)&valuePtr[48] = v109;
      v207 = v109;
      *(_OWORD *)&valuePtr[16] = v109;
      *(_OWORD *)&valuePtr[32] = v109;
      *(_OWORD *)valuePtr = v109;
      v110 = (const __CFDictionary *)*((_QWORD *)v13 + 7);
      c.h0 = v55;
      v111 = CFNumberCreate(*(CFAllocatorRef *)(v8 + 664), kCFNumberIntType, &c);
      Value = (const __CFString *)CFDictionaryGetValue(v110, v111);
      CFRelease(v111);
      if (!Value || !CFStringGetCString(Value, valuePtr, 150, 0x8000100u) || !valuePtr[0])
      {
        valuePtr[0] = 0;
        ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
        v66 = 0;
        v13 = v193;
        if (ErrorLogLevelForModule >= 3)
        {
          v119 = VRTraceErrorLogLevelToCSTR();
          v120 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            c.h0 = 136316162;
            *(_QWORD *)&c.h1 = v119;
            LOWORD(c.h3) = 2080;
            *(_QWORD *)((char *)&c.h3 + 2) = "_VideoReceiver_CreateCompressedVideoFrameForDecode";
            HIWORD(c.Nl) = 1024;
            c.Nh = 972;
            LOWORD(c.data[0]) = 2048;
            *(_QWORD *)((char *)c.data + 2) = v7;
            HIWORD(c.data[2]) = 1024;
            c.data[3] = v55;
            _os_log_error_impl(&dword_1D8A54000, v120, OS_LOG_TYPE_ERROR, "VideoReceiver [%s] %s:%d VideoReceiver[%p] No matched feature list string for payload: %d", (uint8_t *)&c, 0x2Cu);
          }
          v66 = 0;
        }
        goto LABEL_71;
      }
      v13 = v193;
      if ((*(_DWORD *)v194 & 0xFFFFFFFE) == 2)
        v113 = 42;
      else
        v113 = 1;
      v114 = *(unsigned __int8 *)(v8 + 592) | (2 * *((unsigned __int8 *)v193 + 108));
      if ((VideoDecoder_NewFormat_SPSPPS(*(_QWORD *)(v194 + 84), v75, (int *)&dataPointerOut, valuePtr, &v201, &v200, v55, v114, *(_WORD *)(v7 + 1162), v113) & 0x80000000) != 0)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() < 3)
          goto LABEL_70;
        v176 = VRTraceErrorLogLevelToCSTR();
        v65 = *MEMORY[0x1E0CF2758];
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          goto LABEL_70;
        c.h0 = 136316162;
        *(_QWORD *)&c.h1 = v176;
        LOWORD(c.h3) = 2080;
        *(_QWORD *)((char *)&c.h3 + 2) = "_VideoReceiver_CreateCompressedVideoFrameForDecode";
        HIWORD(c.Nl) = 1024;
        c.Nh = 982;
        LOWORD(c.data[0]) = 2048;
        *(_QWORD *)((char *)c.data + 2) = v7;
        HIWORD(c.data[2]) = 1024;
        c.data[3] = v114;
        v174 = "VideoReceiver [%s] %s:%d VideoReceiver=%p decoderFlags=%d VideoDecoder_NewFormat_SPSPPS failed";
        p_c = (uint8_t *)&c;
        goto LABEL_232;
      }
      v76 = (_DWORD *)v194;
    }
    v76[110] = v201;
    v76[111] = v200;
    v76[112] = 1;
    *(_WORD *)(v8 + 362) = *(_WORD *)v13;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v77 = VRTraceErrorLogLevelToCSTR();
      v78 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v79 = *(_QWORD *)(v7 + 1152);
        v80 = *(unsigned __int16 *)v13;
        *(_DWORD *)valuePtr = 136317186;
        *(_QWORD *)&valuePtr[4] = v77;
        *(_WORD *)&valuePtr[12] = 2080;
        *(_QWORD *)&valuePtr[14] = "_VideoReceiver_CreateCompressedVideoFrameForDecode";
        *(_WORD *)&valuePtr[22] = 1024;
        *(_DWORD *)&valuePtr[24] = 992;
        *(_WORD *)&valuePtr[28] = 2048;
        *(_QWORD *)&valuePtr[30] = v7;
        *(_WORD *)&valuePtr[38] = 2048;
        *(_QWORD *)&valuePtr[40] = v79;
        *(_WORD *)&valuePtr[48] = 2048;
        *(_QWORD *)&valuePtr[50] = v13;
        *(_WORD *)&valuePtr[58] = 1024;
        *(_DWORD *)&valuePtr[60] = v80;
        LOWORD(v207) = 1024;
        *(_DWORD *)((char *)&v207 + 2) = v201;
        WORD3(v207) = 1024;
        DWORD2(v207) = v200;
        _os_log_impl(&dword_1D8A54000, v78, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] participantId[%llu] stream[%p] streamId[%d] Got ImgDesc:%dx%d", valuePtr, 0x4Cu);
      }
    }
    v82 = (CFTypeRef *)(v8 + 72);
    v81 = *(const void **)(v8 + 72);
    if (!v81)
      goto LABEL_86;
LABEL_85:
    CFRelease(v81);
    *v82 = 0;
LABEL_86:
    v14 = v194;
    VideoDecoder_GetFormatDescription(*(_QWORD *)(v194 + 84), v82);
    if (*v82)
    {
      CFRetain(*v82);
      if (*(_DWORD *)(v7 + 1068))
        VideoReceiver_DumpRecvSPSPPS(v7, v55, (unsigned __int16 *)v13);
    }
    if (*(_QWORD *)v8)
    {
      CVPixelBufferPoolRelease(*(CVPixelBufferPoolRef *)v8);
      *(_QWORD *)v8 = 0;
    }
    VideoDecoder_GetBufferPool();
    goto LABEL_92;
  }
  c.h0 = -1431655766;
  *(_DWORD *)md = -1431655766;
  if (!v10[16])
    goto LABEL_92;
  v68 = (char *)v10[18] + 4;
  v69 = *(_QWORD *)(v14 + 84);
  v70 = *((_DWORD *)v10 + 34) - 4;
  if ((VideoDecoder_IsFormatCompatible_ImgDesc(v69, v68, v70, 0) & 0x80000000) != 0)
  {
    *(_QWORD *)&buf[142] = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)&v96 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v96 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&buf[112] = v96;
    *(_OWORD *)&buf[128] = v96;
    *(_OWORD *)&buf[80] = v96;
    *(_OWORD *)&buf[96] = v96;
    *(_OWORD *)&buf[48] = v96;
    *(_OWORD *)&buf[64] = v96;
    *(_OWORD *)&buf[16] = v96;
    *(_OWORD *)&buf[32] = v96;
    *(_OWORD *)buf = v96;
    v97 = (const __CFDictionary *)*((_QWORD *)v13 + 7);
    *(_DWORD *)valuePtr = v55;
    v98 = CFNumberCreate(*(CFAllocatorRef *)(v8 + 664), kCFNumberIntType, valuePtr);
    v99 = (const __CFString *)CFDictionaryGetValue(v97, v98);
    CFRelease(v98);
    if (!v99 || !CFStringGetCString(v99, buf, 150, 0x8000100u) || !buf[0])
    {
      buf[0] = 0;
      if (v55 == 126)
      {
        v100 = (const __CFDictionary *)*((_QWORD *)v193 + 7);
        *(_DWORD *)valuePtr = 123;
        v101 = CFNumberCreate(*(CFAllocatorRef *)(v8 + 664), kCFNumberIntType, valuePtr);
        v102 = (const __CFString *)CFDictionaryGetValue(v100, v101);
        CFRelease(v101);
        if (v102 && CFStringGetCString(v102, buf, 150, 0x8000100u) && buf[0])
          goto LABEL_132;
        buf[0] = 0;
      }
      v13 = v193;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v131 = VRTraceErrorLogLevelToCSTR();
        v132 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)valuePtr = 136316162;
          *(_QWORD *)&valuePtr[4] = v131;
          *(_WORD *)&valuePtr[12] = 2080;
          *(_QWORD *)&valuePtr[14] = "_VideoReceiver_CreateCompressedVideoFrameForDecode";
          *(_WORD *)&valuePtr[22] = 1024;
          *(_DWORD *)&valuePtr[24] = 1026;
          *(_WORD *)&valuePtr[28] = 2048;
          *(_QWORD *)&valuePtr[30] = v7;
          *(_WORD *)&valuePtr[38] = 1024;
          *(_DWORD *)&valuePtr[40] = v55;
          _os_log_error_impl(&dword_1D8A54000, v132, OS_LOG_TYPE_ERROR, "VideoReceiver [%s] %s:%d VideoReceiver[%p] No matched feature list string for payload: %d", valuePtr, 0x2Cu);
        }
      }
      v133 = 0;
      v14 = v194;
      goto LABEL_178;
    }
LABEL_132:
    if ((*(_DWORD *)v194 & 0xFFFFFFFE) == 2)
      v103 = 42;
    else
      v103 = 1;
    v104 = *(unsigned __int8 *)(v8 + 592) | (2 * *((unsigned __int8 *)v193 + 108));
    if ((VideoDecoder_NewFormat_ImgDesc(*(_QWORD *)(v194 + 84), v68, v70, buf, (int32_t *)&c, (int32_t *)md, v104, *(_WORD *)(v7 + 1162), v103) & 0x80000000) == 0)
    {
      *(_DWORD *)(v194 + 440) = c.h0;
      *(_DWORD *)(v194 + 444) = *(_DWORD *)md;
      *(_DWORD *)(v194 + 448) = 1;
      *(_WORD *)(v8 + 362) = *(_WORD *)v193;
      v13 = v193;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v105 = VRTraceErrorLogLevelToCSTR();
        v106 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v107 = *(_QWORD *)(v7 + 1152);
          v108 = *(unsigned __int16 *)v193;
          *(_DWORD *)valuePtr = 136317186;
          *(_QWORD *)&valuePtr[4] = v105;
          *(_WORD *)&valuePtr[12] = 2080;
          *(_QWORD *)&valuePtr[14] = "_VideoReceiver_CreateCompressedVideoFrameForDecode";
          *(_WORD *)&valuePtr[22] = 1024;
          *(_DWORD *)&valuePtr[24] = 1045;
          *(_WORD *)&valuePtr[28] = 2048;
          *(_QWORD *)&valuePtr[30] = v7;
          *(_WORD *)&valuePtr[38] = 2048;
          *(_QWORD *)&valuePtr[40] = v107;
          *(_WORD *)&valuePtr[48] = 2048;
          *(_QWORD *)&valuePtr[50] = v193;
          *(_WORD *)&valuePtr[58] = 1024;
          *(_DWORD *)&valuePtr[60] = v108;
          LOWORD(v207) = 1024;
          *(_DWORD *)((char *)&v207 + 2) = c.h0;
          WORD3(v207) = 1024;
          DWORD2(v207) = *(_DWORD *)md;
          _os_log_impl(&dword_1D8A54000, v106, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] participantId[%llu] stream[%p] streamId[%d] Got ImgDesc:%dx%d", valuePtr, 0x4Cu);
        }
      }
      v82 = (CFTypeRef *)(v8 + 72);
      v81 = *(const void **)(v8 + 72);
      if (!v81)
        goto LABEL_86;
      goto LABEL_85;
    }
    v14 = v194;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v134 = VRTraceErrorLogLevelToCSTR();
      v135 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)valuePtr = 136316162;
        *(_QWORD *)&valuePtr[4] = v134;
        *(_WORD *)&valuePtr[12] = 2080;
        *(_QWORD *)&valuePtr[14] = "_VideoReceiver_CreateCompressedVideoFrameForDecode";
        *(_WORD *)&valuePtr[22] = 1024;
        *(_DWORD *)&valuePtr[24] = 1038;
        *(_WORD *)&valuePtr[28] = 2048;
        *(_QWORD *)&valuePtr[30] = v7;
        *(_WORD *)&valuePtr[38] = 1024;
        *(_DWORD *)&valuePtr[40] = v104;
        _os_log_error_impl(&dword_1D8A54000, v135, OS_LOG_TYPE_ERROR, "VideoReceiver [%s] %s:%d VideoReceiver=%p decoderFlags=%d VideoDecoder_NewFormat_SPSPPS failed", valuePtr, 0x2Cu);
      }
    }
    v133 = 1;
    v13 = v193;
LABEL_178:
    SampleFromBuffer = 0;
    if (v133)
      goto LABEL_179;
    goto LABEL_184;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v71 = VRTraceErrorLogLevelToCSTR();
    v72 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v73 = *(unsigned __int16 *)(v8 + 362);
      v74 = *(unsigned __int16 *)v13;
      *(_DWORD *)buf = 136316418;
      *(_QWORD *)&buf[4] = v71;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "_VideoReceiver_CreateCompressedVideoFrameForDecode";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 1066;
      *(_WORD *)&buf[28] = 2048;
      *(_QWORD *)&buf[30] = v7;
      *(_WORD *)&buf[38] = 1024;
      *(_DWORD *)&buf[40] = v73;
      *(_WORD *)&buf[44] = 1024;
      *(_DWORD *)&buf[46] = v74;
      _os_log_impl(&dword_1D8A54000, v72, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] update lastKeyFrameStreamId from %d to %d", buf, 0x32u);
    }
  }
  *(_WORD *)(v8 + 362) = *(_WORD *)v13;
  v14 = v194;
LABEL_92:
  if (!*(_DWORD *)(v14 + 448))
  {
    SampleFromBuffer = 0;
    goto LABEL_179;
  }
  SampleFromBuffer = v10[15];
  if (!SampleFromBuffer)
    goto LABEL_184;
  if (*(_DWORD *)(v7 + 1068))
  {
    v83 = *(unsigned __int16 *)v13;
    c.h0 = 0x1000000;
    if (*(_DWORD *)v14 == 1 && *(unsigned __int16 *)(v8 + 360) != v83)
      VideoReceiver_DumpRecvCreate(v7, v83);
    if (*(_QWORD *)(v8 + 368))
    {
      *(_QWORD *)buf = 0xAAAAAAAAAAAAAAAALL;
      *(_QWORD *)valuePtr = 0;
      if (!CMBlockBufferGetDataPointer(SampleFromBuffer, 0, (size_t *)buf, 0, (char **)valuePtr))
      {
        v84 = 0;
        do
        {
          v85 = bswap32(**(_DWORD **)valuePtr) + 4;
          fwrite(&c, 1uLL, 4uLL, *(FILE **)(v8 + 368));
          v84 += 4;
          if (v84 != v85)
          {
            do
            {
              CMBlockBufferGetDataPointer(SampleFromBuffer, v84, (size_t *)buf, 0, (char **)valuePtr);
              if (*(_QWORD *)buf >= v85 - v84)
                v86 = v85 - v84;
              else
                v86 = *(_QWORD *)buf;
              fwrite(*(const void **)valuePtr, 1uLL, v86, *(FILE **)(v8 + 368));
              v84 += v86;
            }
            while (v84 != v85);
            v84 = v85;
            v14 = v194;
          }
        }
        while (!CMBlockBufferGetDataPointer(SampleFromBuffer, v84, (size_t *)buf, 0, (char **)valuePtr));
      }
    }
  }
  if (*(_DWORD *)(v7 + 1056))
  {
    v87 = *(const opaqueCMFormatDescription **)(v8 + 72);
    if (v87)
      VideoReceiverUtil_CaptureBitstreamFile(v10[15], *(int *)(v7 + 1036) >> 2, v7 + 40840, v87, (v58 - *(_DWORD *)(v8 + 60)) >> 2);
  }
  v88 = *(_OWORD *)(MEMORY[0x1E0CA2E90] + 48);
  *(_OWORD *)&buf[32] = *(_OWORD *)(MEMORY[0x1E0CA2E90] + 32);
  *(_OWORD *)&buf[48] = v88;
  *(_QWORD *)&buf[64] = *(_QWORD *)(MEMORY[0x1E0CA2E90] + 64);
  v89 = *(_OWORD *)(MEMORY[0x1E0CA2E90] + 16);
  *(_OWORD *)buf = *MEMORY[0x1E0CA2E90];
  *(_OWORD *)&buf[16] = v89;
  CMTimeMake((CMTime *)valuePtr, (uint64_t)(*((double *)v10 + 4) * 1000000000.0), 1000000000);
  *(_OWORD *)&buf[24] = *(_OWORD *)valuePtr;
  *(_QWORD *)&buf[40] = *(_QWORD *)&valuePtr[16];
  *(_OWORD *)&buf[48] = *MEMORY[0x1E0CA2E18];
  *(_QWORD *)&buf[64] = *(_QWORD *)(MEMORY[0x1E0CA2E18] + 16);
  CMTimeMake((CMTime *)valuePtr, 1, 1);
  *(_OWORD *)buf = *(_OWORD *)valuePtr;
  *(_QWORD *)&buf[16] = *(_QWORD *)&valuePtr[16];
  v90 = *((_DWORD *)v10 + 2) - 110;
  if (v90 > 0xF || ((1 << v90) & 0xC001) == 0)
  {
    if (*(unsigned __int16 *)v13 != *(unsigned __int16 *)(v8 + 362) && !*((_BYTE *)v13 + 70))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v141 = VRTraceErrorLogLevelToCSTR();
        v142 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v143 = *(unsigned __int16 *)v13;
          v144 = *(unsigned __int16 *)(v8 + 362);
          v145 = *((_DWORD *)v10 + 4);
          *(_DWORD *)valuePtr = 136316930;
          *(_QWORD *)&valuePtr[4] = v141;
          *(_WORD *)&valuePtr[12] = 2080;
          *(_QWORD *)&valuePtr[14] = "_VideoReceiver_CreateCompressedVideoFrameForDecode";
          *(_WORD *)&valuePtr[22] = 1024;
          *(_DWORD *)&valuePtr[24] = 1104;
          *(_WORD *)&valuePtr[28] = 2048;
          *(_QWORD *)&valuePtr[30] = v7;
          *(_WORD *)&valuePtr[38] = 1024;
          *(_DWORD *)&valuePtr[40] = v143;
          *(_WORD *)&valuePtr[44] = 1024;
          *(_DWORD *)&valuePtr[46] = v144;
          *(_WORD *)&valuePtr[50] = 1024;
          *(_DWORD *)&valuePtr[52] = v145;
          *(_WORD *)&valuePtr[56] = 1024;
          *(_DWORD *)&valuePtr[58] = v143;
          _os_log_impl(&dword_1D8A54000, v142, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Skip frame due to mismatch with decoder. streamID=%d, lastKeyFrameStreamId=%d, timestamp=%u. Request key frame for streamID=%d", valuePtr, 0x3Eu);
        }
      }
      SampleFromBuffer = 0;
      goto LABEL_179;
    }
    v115 = v10[13];
    v116 = *(_QWORD *)(v8 + 536);
    v117 = *(const opaqueCMFormatDescription **)(v8 + 72);
    *(_OWORD *)&valuePtr[32] = *(_OWORD *)&buf[32];
    *(_OWORD *)&valuePtr[48] = *(_OWORD *)&buf[48];
    *(_QWORD *)&v207 = *(_QWORD *)&buf[64];
    *(_OWORD *)valuePtr = *(_OWORD *)buf;
    *(_OWORD *)&valuePtr[16] = *(_OWORD *)&buf[16];
    SampleFromBuffer = VideoUtil_CreateSampleFromBuffer(v115, (const CMSampleTimingInfo *)valuePtr, v116, v117);
    if (SampleFromBuffer)
      goto LABEL_119;
    goto LABEL_152;
  }
  *(_QWORD *)valuePtr = 0;
  *(_QWORD *)&c.h0 = 0;
  if (CMFormatDescriptionCreate(*(CFAllocatorRef *)(v8 + 568), 0x6D657461u, 0x64617461u, 0, (CMFormatDescriptionRef *)&c))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VideoReceiver_DequeueAndDecode_cold_12();
    }
  }
  else
  {
    if (!CMSampleBufferCreate(*(CFAllocatorRef *)(v8 + 576), v10[13], 1u, 0, 0, *(CMFormatDescriptionRef *)&c.h0, 1, 1, (const CMSampleTimingInfo *)buf, 0, 0, (CMSampleBufferRef *)valuePtr))
    {
      SampleFromBuffer = *(OpaqueCMBlockBuffer **)valuePtr;
      *(_QWORD *)valuePtr = 0;
      goto LABEL_116;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VideoReceiver_DequeueAndDecode_cold_11();
    }
  }
  if (*(_QWORD *)valuePtr)
    CFRelease(*(CFTypeRef *)valuePtr);
  SampleFromBuffer = 0;
LABEL_116:
  if (*(_QWORD *)&c.h0)
    CFRelease(*(CFTypeRef *)&c.h0);
  if (!SampleFromBuffer)
  {
LABEL_152:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VideoReceiver_DequeueAndDecode_cold_3();
      SampleFromBuffer = 0;
      v66 = 0;
      v13 = v193;
      goto LABEL_72;
    }
    SampleFromBuffer = 0;
LABEL_184:
    pthread_mutex_lock((pthread_mutex_t *)(v7 + 40520));
    SummerAdd((double)*(int *)(v14 + 308), v43);
    *(_DWORD *)(v14 + 308) = 0;
    SummerAdd((double)*(int *)(v14 + 312), v43);
    *(_DWORD *)(v14 + 312) = 0;
    SummerAdd((double)*(int *)(v14 + 320), v43);
    *(_DWORD *)(v14 + 320) = 0;
    SummerAdd((double)(unint64_t)v10[11], v43);
    SummerAdd((double)*(int *)(v14 + 316), v43);
    *(_DWORD *)(v14 + 316) = 0;
    pthread_mutex_unlock((pthread_mutex_t *)(v7 + 40520));
    v136 = 1;
    goto LABEL_185;
  }
LABEL_119:
  LOBYTE(lengthAtOffsetOut) = *((_BYTE *)v10 + 22);
  v91 = CFNumberCreate(*(CFAllocatorRef *)(v8 + 664), kCFNumberCharType, &lengthAtOffsetOut);
  if (v91)
  {
    v92 = v91;
    CMSetAttachment(SampleFromBuffer, CFSTR("FramePriority"), v91, 1u);
    CFRelease(v92);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v93 = VRTraceErrorLogLevelToCSTR();
      v94 = *MEMORY[0x1E0CF2758];
      v95 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v95, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)valuePtr = 136316162;
          *(_QWORD *)&valuePtr[4] = v93;
          *(_WORD *)&valuePtr[12] = 2080;
          *(_QWORD *)&valuePtr[14] = "_VideoReceiver_PrepareDecodeSampleBufferAttachments";
          *(_WORD *)&valuePtr[22] = 1024;
          *(_DWORD *)&valuePtr[24] = 896;
          *(_WORD *)&valuePtr[28] = 1024;
          *(_DWORD *)&valuePtr[30] = lengthAtOffsetOut;
          *(_WORD *)&valuePtr[34] = 2112;
          *(_QWORD *)&valuePtr[36] = CFSTR("FramePriority");
          _os_log_impl(&dword_1D8A54000, v94, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d [Media Priority] Attaching video priority=%u as kVCPixelBufferOptionKey_FramePriority(%@)", valuePtr, 0x2Cu);
        }
      }
      else if (os_log_type_enabled(v95, OS_LOG_TYPE_DEBUG))
      {
        _VideoReceiver_DequeueAndDecode_cold_10();
      }
    }
    *(_DWORD *)md = *((_DWORD *)v10 + 4);
    v121 = CFNumberCreate(*(CFAllocatorRef *)(v8 + 664), kCFNumberSInt32Type, md);
    if (v121)
    {
      v122 = v121;
      CMSetAttachment(SampleFromBuffer, CFSTR("rtpTimestsamp"), v121, 0);
      CFRelease(v122);
      *(_QWORD *)&c.h0 = VideoUtil_ConstructSubFrameIdentifer(*((unsigned __int16 *)v10 + 12), *((unsigned __int16 *)v10 + 22));
      v123 = CFNumberCreate(*(CFAllocatorRef *)(v8 + 664), kCFNumberSInt64Type, &c);
      v13 = v193;
      if (v123)
      {
        v124 = v123;
        CMSetAttachment(SampleFromBuffer, CFSTR("subFrameIndentifier"), v123, 0);
        CFRelease(v124);
        v14 = v194;
        kdebug_trace();
        if (*(unsigned __int16 *)(v7 + 1162) < 2u)
          goto LABEL_184;
        SampleAttachmentsArray = CMSampleBufferGetSampleAttachmentsArray(SampleFromBuffer, 1u);
        ValueAtIndex = (__CFDictionary *)CFArrayGetValueAtIndex(SampleAttachmentsArray, 0);
        *(_DWORD *)valuePtr = *((unsigned __int16 *)v10 + 22);
        v127 = CFNumberCreate(*(CFAllocatorRef *)(v8 + 664), kCFNumberSInt32Type, valuePtr);
        if (v127)
        {
          v128 = v127;
          CFDictionarySetValue(ValueAtIndex, CFSTR("TileID"), v127);
          CFRelease(v128);
          LODWORD(dataPointerOut) = *((unsigned __int16 *)v10 + 12);
          v129 = CFNumberCreate(*(CFAllocatorRef *)(v8 + 664), kCFNumberSInt32Type, &dataPointerOut);
          if (v129)
          {
            v130 = v129;
            CFDictionarySetValue(ValueAtIndex, CFSTR("TileOrder"), v129);
            CFRelease(v130);
            v14 = v194;
            goto LABEL_184;
          }
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              _VideoReceiver_DequeueAndDecode_cold_9();
          }
        }
        else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VideoReceiver_DequeueAndDecode_cold_8();
        }
        v13 = v193;
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VideoReceiver_DequeueAndDecode_cold_7();
      }
    }
    else
    {
      v13 = v193;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VideoReceiver_DequeueAndDecode_cold_6();
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VideoReceiver_DequeueAndDecode_cold_5();
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VideoReceiver_DequeueAndDecode_cold_4();
  }
  CFRelease(SampleFromBuffer);
  SampleFromBuffer = 0;
  v66 = 0;
LABEL_72:
  v14 = v194;
  if (!v66)
    goto LABEL_184;
LABEL_179:
  v136 = 0;
LABEL_185:
  if (*((_DWORD *)v10 + 3) == 2)
    VideoPacketBuffer_SetFrameSize(*((_QWORD *)v13 + 14), v201, v200);
  if ((v136 & 1) == 0 && !*((_BYTE *)v10 + 80))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v146 = VRTraceErrorLogLevelToCSTR();
      v147 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v148 = *(unsigned __int16 *)v13;
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)&buf[4] = v146;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VideoReceiver_CreateSampleBufferForDecode";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 1972;
        *(_WORD *)&buf[28] = 2048;
        *(_QWORD *)&buf[30] = v7;
        *(_WORD *)&buf[38] = 1024;
        *(_DWORD *)&buf[40] = v148;
        _os_log_impl(&dword_1D8A54000, v147, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] CreateCompressedVideoFrameForDecode failed, request key frame for stream %d", buf, 0x2Cu);
      }
    }
    _VideoReceiver_DecoderNeedsRefresh(v7, (uint64_t)v13, 0, 19, v43);
  }
  if (SampleFromBuffer)
  {
    v198 = *((_DWORD *)v199 + 4);
    v149 = CFNumberCreate(*(CFAllocatorRef *)(v8 + 664), kCFNumberSInt32Type, &v198);
    CMSetAttachment(SampleFromBuffer, CFSTR("rtpTimestsamp"), v149, 0);
    v197 = 0xAAAAAAAAAAAAAAAALL;
    v197 = VideoUtil_ConstructSubFrameIdentifer(*((unsigned __int16 *)v199 + 12), *((unsigned __int16 *)v199 + 22));
    v150 = CFNumberCreate(*(CFAllocatorRef *)(v8 + 664), kCFNumberSInt64Type, &v197);
    CMSetAttachment(SampleFromBuffer, CFSTR("subFrameIndentifier"), v150, 0);
    kdebug_trace();
    if ((int)VRTraceGetErrorLogLevelForModule() <= 7)
    {
      v153 = v199;
      v154 = v190;
    }
    else
    {
      v151 = VRTraceErrorLogLevelToCSTR();
      v152 = *MEMORY[0x1E0CF2758];
      v153 = v199;
      v154 = v190;
      v155 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v155, OS_LOG_TYPE_DEFAULT))
        {
          v156 = v153[4];
          v157 = *((unsigned __int8 *)v153 + 23);
          v158 = *((unsigned __int16 *)v153 + 22);
          *(_DWORD *)buf = 136316674;
          *(_QWORD *)&buf[4] = v151;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VideoReceiver_DequeueAndDecode";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 2074;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = v198;
          *(_WORD *)&buf[34] = 2048;
          *(_QWORD *)&buf[36] = v156;
          *(_WORD *)&buf[44] = 1024;
          *(_DWORD *)&buf[46] = v157;
          *(_WORD *)&buf[50] = 1024;
          *(_DWORD *)&buf[52] = v158;
          _os_log_impl(&dword_1D8A54000, v152, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d Start Decode RTPTimestamp=%u PresentationTime=%f isRefreshFrame=%d tileIndex=%u", buf, 0x38u);
        }
      }
      else if (os_log_type_enabled(v155, OS_LOG_TYPE_DEBUG))
      {
        v171 = v153[4];
        v172 = *((unsigned __int8 *)v153 + 23);
        v173 = *((unsigned __int16 *)v153 + 22);
        *(_DWORD *)buf = 136316674;
        *(_QWORD *)&buf[4] = v151;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VideoReceiver_DequeueAndDecode";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 2074;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v198;
        *(_WORD *)&buf[34] = 2048;
        *(_QWORD *)&buf[36] = v171;
        *(_WORD *)&buf[44] = 1024;
        *(_DWORD *)&buf[46] = v172;
        *(_WORD *)&buf[50] = 1024;
        *(_DWORD *)&buf[52] = v173;
        _os_log_debug_impl(&dword_1D8A54000, v152, OS_LOG_TYPE_DEBUG, "VideoReceiver [%s] %s:%d Start Decode RTPTimestamp=%u PresentationTime=%f isRefreshFrame=%d tileIndex=%u", buf, 0x38u);
      }
      v13 = v193;
      v14 = v194;
    }
    CFRelease(v150);
    CFRelease(v149);
    v159 = *((_BYTE *)v153 + 22);
    v160 = *((unsigned __int8 *)v153 + 23);
    v161 = v154 ^ 1;
    if (v191 >= 2)
      v161 = 0;
    v196 = 0xAAAAAAAAAAAAAAAALL;
    if (v160)
      v161 = 1;
    v195[0] = xmmword_1D910BB28;
    memset(&v195[1], 170, 32);
    LODWORD(v195[0]) = v198;
    WORD2(v195[0]) = *((_WORD *)v153 + 24);
    *((double *)v195 + 1) = a4;
    *(_QWORD *)&v195[1] = v197;
    WORD4(v195[1]) = *(_WORD *)v13;
    v162 = *(_QWORD *)(v7 + 1024);
    *(_QWORD *)&v195[2] = v162;
    v163 = *((_WORD *)v13 + 33);
    WORD4(v195[2]) = v163;
    BYTE10(v195[2]) = v192;
    *(_WORD *)((char *)&v195[2] + 11) = 0;
    BYTE13(v195[2]) = v159 != 0;
    BYTE14(v195[2]) = v159;
    HIBYTE(v195[2]) = *((_BYTE *)v13 + 69);
    LOBYTE(v196) = v161;
    BYTE1(v196) = *((_BYTE *)v153 + 80);
    BYTE2(v196) = *((_BYTE *)v153 + 96);
    HIDWORD(v196) = *((_DWORD *)v153 + 25);
    v164 = *((_DWORD *)v153 + 2) - 110;
    if (v164 <= 0xF && ((1 << v164) & 0xC001) != 0)
    {
      *(_QWORD *)&c.h0 = 0;
      md[0] = 1;
      memset(valuePtr, 170, 24);
      CMSampleBufferGetPresentationTimeStamp((CMTime *)valuePtr, SampleFromBuffer);
      v165 = *(const __CFAllocator **)(v8 + 560);
      *(_OWORD *)buf = *(_OWORD *)valuePtr;
      *(_QWORD *)&buf[16] = *(_QWORD *)&valuePtr[16];
      if (VCVideoReceiverDecodedFrame_Create(v165, &c, SampleFromBuffer, 0, v195, (__int128 *)buf))
      {
        if ((_VideoReceiver_EnqueueDecodedFrameForDisplay(*((_QWORD *)v13 + 16), v7, v195, &c, md) & 1) == 0)
        {
          v185 = v7;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            v186 = VRTraceErrorLogLevelToCSTR();
            v183 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136316162;
              *(_QWORD *)&buf[4] = v186;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_VideoReceiver_DecoderCallbackUncompressed";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 624;
              *(_WORD *)&buf[28] = 2048;
              *(_QWORD *)&buf[30] = v185;
              *(_WORD *)&buf[38] = 1024;
              *(_DWORD *)&buf[40] = v195[0];
              v184 = "VideoReceiver [%s] %s:%d VideoReceiver[%p] Unable to enqueue for display frame. timestamp=%u";
              goto LABEL_251;
            }
          }
        }
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v181 = v7;
        v182 = VRTraceErrorLogLevelToCSTR();
        v183 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136316162;
          *(_QWORD *)&buf[4] = v182;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VideoReceiver_DecoderCallbackUncompressed";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 621;
          *(_WORD *)&buf[28] = 2048;
          *(_QWORD *)&buf[30] = v181;
          *(_WORD *)&buf[38] = 1024;
          *(_DWORD *)&buf[40] = v195[0];
          v184 = "VideoReceiver [%s] %s:%d VideoReceiver[%p] Unable to create VCVideoReceiverDecodedFrame for frame with timestamp=%u";
LABEL_251:
          _os_log_error_impl(&dword_1D8A54000, v183, OS_LOG_TYPE_ERROR, v184, buf, 0x2Cu);
        }
      }
      if (*(_QWORD *)&c.h0 && md[0])
        VCVideoReceiverDecodedFrame_Destroy((const __CFAllocator ***)&c);
LABEL_229:
      CFRelease(SampleFromBuffer);
      goto LABEL_230;
    }
    valuePtr[0] = 0;
    LOBYTE(c.h0) = 0;
    md[0] = 0;
    *(_WORD *)(v8 + 176) = v163 * *(_WORD *)(v8 + 588);
    if (*(_BYTE *)(v8 + 149))
    {
      v166 = v189 - *(_DWORD *)(v8 + 152);
      if (!v166 || v166 > 0x7FFFFFFE)
        goto LABEL_219;
    }
    else
    {
      *(_BYTE *)(v8 + 149) = 1;
    }
    *(_DWORD *)(v8 + 152) = v189;
    ++*(_WORD *)(v8 + 174);
LABEL_219:
    v167 = VideoDecoder_DecodeFrame(*(_QWORD *)(v14 + 84), v162, valuePtr, &c, (BOOL *)md, SampleFromBuffer, v195);
    if (v167 < 0 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v168 = VRTraceErrorLogLevelToCSTR();
      v169 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136316418;
        *(_QWORD *)&buf[4] = v168;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VideoReceiver_DecodeFrame";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 1815;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = 1815;
        *(_WORD *)&buf[34] = 2048;
        *(_QWORD *)&buf[36] = v7;
        *(_WORD *)&buf[44] = 1024;
        *(_DWORD *)&buf[46] = v167;
        _os_log_error_impl(&dword_1D8A54000, v169, OS_LOG_TYPE_ERROR, "VideoReceiver [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/VideoReceiver.c:%d: VideoReceiver[%p] VideoPlayer_DecodeFrame failed (%08X)", buf, 0x32u);
      }
    }
    if (valuePtr[0] && !BYTE1(v196))
      _VideoReceiver_DecoderRequestKeyFrame(v7, (unsigned __int16 *)v13, 0x11u, v195[0], *((unsigned __int8 *)v13 + 100), md[0]);
    v170 = v7;
    if (LOBYTE(c.h0))
      ++*(_DWORD *)(v8 + 192);
    if (v167 < 0 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v187 = VRTraceErrorLogLevelToCSTR();
      v188 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)&buf[4] = v187;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VideoReceiver_DequeueAndDecode";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 2114;
        *(_WORD *)&buf[28] = 2048;
        *(_QWORD *)&buf[30] = v170;
        *(_WORD *)&buf[38] = 1024;
        *(_DWORD *)&buf[40] = v167;
        _os_log_error_impl(&dword_1D8A54000, v188, OS_LOG_TYPE_ERROR, "VideoReceiver [%s] %s:%d VideoReceiver[%p] _VideoReceiver_DecodeFrame failed (%08X)", buf, 0x2Cu);
      }
    }
    goto LABEL_229;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VideoReceiver_DequeueAndDecode_cold_2();
  }
LABEL_230:
  VCVideoReceiverSampleBuffer_Destroy(&v199);
}

unsigned int *_VideoReceiver_GetStreamWithTileIndex(unsigned int *a1, int a2)
{
  uint64_t v4;
  unsigned int *result;
  uint64_t v6;
  NSObject *v7;
  int v8;
  uint64_t v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  unsigned int *v15;
  __int16 v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  if ((_DWORD)v4)
  {
    result = a1 + 364;
    while (*((unsigned __int8 *)result + 68) != a2)
    {
      result += 1080;
      if (!--v4)
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v6 = VRTraceErrorLogLevelToCSTR();
      v7 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v8 = 136316162;
        v9 = v6;
        v10 = 2080;
        v11 = "_VideoReceiver_GetStreamWithTileIndex";
        v12 = 1024;
        v13 = 1452;
        v14 = 2048;
        v15 = a1;
        v16 = 1024;
        v17 = a2;
        _os_log_error_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_ERROR, "VideoReceiver [%s] %s:%d VideoReceiver[%p] unknown tileIndex:%u", (uint8_t *)&v8, 0x2Cu);
      }
    }
    return 0;
  }
  return result;
}

void _VideoReceiver_DecoderNeedsRefresh(uint64_t a1, uint64_t a2, int a3, int a4, double a5)
{
  _VideoReceiver_SendFIR(a1, a2, a3, a4, a5);
  if (a4 != 28 || !*(_BYTE *)(a1 + 1380))
    _VideoReceiver_UpdateVideoStallStatus(a1, 1);
  _VideoReceiver_ResetExpectedDecodingOrder(a1);
}

void VideoReceiver_DumpRecvSPSPPS(uint64_t a1, int a2, unsigned __int16 *a3)
{
  uint64_t v6;
  int v7;
  const __CFData *AvcCFromFormatDescriptionForLog;
  const __CFData *v9;
  const UInt8 *BytePtr;
  CFIndex Length;
  int v12;
  size_t v13;
  char *v14;
  __int16 v15;
  __int16 v16;
  uint64_t v17;
  NSObject *v18;
  __int128 v19;
  const __CFDictionary *v20;
  CFNumberRef v21;
  const __CFString *Value;
  size_t v23;
  uint64_t v24;
  NSObject *v25;
  size_t v26;
  int __ptr;
  int valuePtr;
  uint64_t v29;
  __int16 v30;
  const char *v31;
  __int16 v32;
  int v33;
  __int16 v34;
  uint64_t v35;
  __int16 v36;
  int v37;
  _BYTE buf[64];
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  _BYTE v43[22];
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v26 = 0;
  if (*(_DWORD *)(a1 + 1068))
  {
    v6 = a1 + 40920;
    if (*(_DWORD *)(a1 + 40356) == 1)
    {
      v7 = *a3;
      if (*(unsigned __int16 *)(a1 + 41208) != v7)
        VideoReceiver_DumpRecvCreate(a1, v7);
    }
    if (*(_QWORD *)(v6 + 296))
    {
      AvcCFromFormatDescriptionForLog = extractAvcCFromFormatDescriptionForLog(*(const opaqueCMFormatDescription **)v6);
      if (AvcCFromFormatDescriptionForLog)
      {
        v9 = AvcCFromFormatDescriptionForLog;
        BytePtr = CFDataGetBytePtr(AvcCFromFormatDescriptionForLog);
        Length = CFDataGetLength(v9);
        v12 = Length;
        MEMORY[0x1E0C80A78](Length);
        v14 = (char *)&v26 - ((v13 + 15) & 0x1FFFFFFF0);
        if (v13)
          memset((char *)&v26 - ((v13 + 15) & 0x1FFFFFFF0), 170, v13);
        v15 = readAVCCAndEncodeH264SPSPPS((uint64_t)BytePtr, v12, (uint64_t)v14, &v26);
        if (v15)
        {
          v16 = v15;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            v17 = VRTraceErrorLogLevelToCSTR();
            v18 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136316418;
              *(_QWORD *)&buf[4] = v17;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "VideoReceiver_DumpRecvSPSPPS";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 747;
              *(_WORD *)&buf[28] = 1024;
              *(_DWORD *)&buf[30] = 747;
              *(_WORD *)&buf[34] = 2048;
              *(_QWORD *)&buf[36] = a1;
              *(_WORD *)&buf[44] = 1024;
              *(_DWORD *)&buf[46] = v16;
              _os_log_error_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_ERROR, "VideoReceiver [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/VideoReceiver.c:%d: VideoReceiver[%p] readAVCCAndEncodeH264SPSPPS %d", buf, 0x32u);
            }
          }
        }
        else
        {
          __ptr = 50331648;
          fwrite(&__ptr, 1uLL, 4uLL, *(FILE **)(v6 + 296));
          *(_QWORD *)&v43[14] = 0xAAAAAAAAAAAAAAAALL;
          *(_QWORD *)&v19 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v19 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v42 = v19;
          *(_OWORD *)v43 = v19;
          v40 = v19;
          v41 = v19;
          *(_OWORD *)&buf[48] = v19;
          v39 = v19;
          *(_OWORD *)&buf[16] = v19;
          *(_OWORD *)&buf[32] = v19;
          *(_OWORD *)buf = v19;
          v20 = (const __CFDictionary *)*((_QWORD *)a3 + 7);
          valuePtr = a2;
          v21 = CFNumberCreate(*(CFAllocatorRef *)(v6 + 592), kCFNumberIntType, &valuePtr);
          Value = (const __CFString *)CFDictionaryGetValue(v20, v21);
          CFRelease(v21);
          if (Value && CFStringGetCString(Value, buf, 150, 0x8000100u) && buf[0])
          {
            v23 = strlen(buf);
            fwrite(buf, 1uLL, v23 + 1, *(FILE **)(v6 + 296));
          }
          else
          {
            buf[0] = 0;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              v24 = VRTraceErrorLogLevelToCSTR();
              v25 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              {
                valuePtr = 136316162;
                v29 = v24;
                v30 = 2080;
                v31 = "VideoReceiver_DumpRecvSPSPPS";
                v32 = 1024;
                v33 = 769;
                v34 = 2048;
                v35 = a1;
                v36 = 1024;
                v37 = a2;
                _os_log_error_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_ERROR, "VideoReceiver [%s] %s:%d VideoReceiver[%p] No matched feature list string for payload: %d", (uint8_t *)&valuePtr, 0x2Cu);
              }
            }
          }
          fwrite(v14, 1uLL, v26, *(FILE **)(v6 + 296));
        }
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VideoReceiver_DumpRecvSPSPPS_cold_1();
      }
    }
  }
}

void _VideoReceiver_ResetExpectedDecodingOrder(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  int v5;
  int v6;
  uint64_t v7;
  __int16 v8;
  const char *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  uint64_t v13;
  __int16 v14;
  int v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (*(unsigned __int16 *)(a1 + 1162) >= 2u)
  {
    v2 = a1 + 41496;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v3 = VRTraceErrorLogLevelToCSTR();
      v4 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v5 = *(unsigned __int16 *)(v2 + 6);
        v6 = 136316162;
        v7 = v3;
        v8 = 2080;
        v9 = "_VideoReceiver_ResetExpectedDecodingOrder";
        v10 = 1024;
        v11 = 816;
        v12 = 2048;
        v13 = a1;
        v14 = 1024;
        v15 = v5;
        _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Reset expectedDecodingOrder:%hu", (uint8_t *)&v6, 0x2Cu);
      }
    }
    *(_BYTE *)(v2 + 4) = 0;
    *(_DWORD *)v2 = 0;
  }
}

void _VideoReceiver_DecoderRequestKeyFrame(uint64_t a1, unsigned __int16 *a2, unsigned int a3, int a4, int a5, int a6)
{
  char v9;
  unsigned int v10;
  unsigned int v11;
  BOOL v12;
  uint64_t v13;
  NSObject *v14;
  int v15;
  char *v16;
  int v17;
  _BOOL4 v18;
  double v19;
  uint64_t v20;
  NSObject *v21;
  int v22;
  int v23;
  char *v24;
  int v25;
  _BOOL4 v26;
  int v27;
  uint64_t v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  int v32;
  __int16 v33;
  uint64_t v34;
  __int16 v35;
  int v36;
  __int16 v37;
  int v38;
  __int16 v39;
  _BYTE v40[14];
  __int16 v41;
  _BOOL4 v42;
  __int16 v43;
  _BOOL4 v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v9 = a5 & a6;
  if ((a5 & a6) != 0)
    v10 = 27;
  else
    v10 = a3;
  if (*((_BYTE *)a2 + 70) && ((v11 = a4 - *(_DWORD *)(a1 + 41616)) != 0 ? (v12 = v11 >= 0x7FFFFFFF) : (v12 = 1), v12))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v20 = VRTraceErrorLogLevelToCSTR();
      v21 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v22 = *(_DWORD *)(a1 + 41616);
        v23 = *a2;
        v24 = kVCKeyFrameRequestReasonStrings_0[v10];
        v25 = *((unsigned __int8 *)a2 + 70);
        v26 = v23 == a2[2];
        v27 = 136317442;
        v28 = v20;
        v29 = 2080;
        v30 = "_VideoReceiver_RequestKeyFrame";
        v31 = 1024;
        v32 = 1767;
        v33 = 2048;
        v34 = a1;
        v35 = 1024;
        v36 = a4;
        v37 = 1024;
        v38 = v22;
        v39 = 1024;
        *(_DWORD *)v40 = v23;
        *(_WORD *)&v40[4] = 2080;
        *(_QWORD *)&v40[6] = v24;
        v41 = 1024;
        v42 = v25;
        v43 = 1024;
        v44 = v26;
        _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Decoder requested a key frame for timestamp=%u, when a more recent key frame with timestamp=%u has already been assembled, skipping FIR. Stream %u reason=%s isTemporalScaledStream=%d isBaseLayer=%d", (uint8_t *)&v27, 0x4Eu);
      }
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v13 = VRTraceErrorLogLevelToCSTR();
      v14 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v15 = *a2;
        v16 = kVCKeyFrameRequestReasonStrings_0[v10];
        v17 = *((unsigned __int8 *)a2 + 70);
        v18 = v15 == a2[2];
        v27 = 136317186;
        v28 = v13;
        v29 = 2080;
        v30 = "_VideoReceiver_RequestKeyFrame";
        v31 = 1024;
        v32 = 1769;
        v33 = 2048;
        v34 = a1;
        v35 = 1024;
        v36 = a4;
        v37 = 1024;
        v38 = v15;
        v39 = 2080;
        *(_QWORD *)v40 = v16;
        *(_WORD *)&v40[8] = 1024;
        *(_DWORD *)&v40[10] = v17;
        v41 = 1024;
        v42 = v18;
        _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Requested key frame for timestamp=%u stream=%u reason=%s isTemporalScaledStream=%d isBaseLayer=%d", (uint8_t *)&v27, 0x48u);
      }
    }
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 40584));
    VideoPacketBuffer_NeedRefreshFrame(*((_QWORD *)a2 + 14), 1, 0, v10);
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 40584));
    v19 = micro();
    _VideoReceiver_DecoderNeedsRefresh(a1, (uint64_t)a2, v9 & 1, v10, v19);
  }
}

double _VideoReceiver_GetVideoStallLength(uint64_t a1)
{
  uint64_t v2;
  double v3;
  uint64_t v4;
  NSObject *v5;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  uint64_t v18;
  __int16 v19;
  int v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  double v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  uint64_t v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v2 = a1 + 40656;
  v3 = micro() - *(double *)(a1 + 41120);
  if (v3 < 0.0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v4 = VRTraceErrorLogLevelToCSTR();
      v5 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v7 = *(_DWORD *)(v2 + 456);
        v8 = *(_QWORD *)(v2 + 432);
        v9 = *(_QWORD *)(v2 + 464);
        v10 = *(_QWORD *)(v2 + 472);
        v11 = 136317186;
        v12 = v4;
        v13 = 2080;
        v14 = "_VideoReceiver_GetVideoStallLength";
        v15 = 1024;
        v16 = 1255;
        v17 = 2048;
        v18 = a1;
        v19 = 1024;
        v20 = v7;
        v21 = 2048;
        v22 = v9;
        v23 = 2048;
        v24 = v3;
        v25 = 2048;
        v26 = v8;
        v27 = 2048;
        v28 = v10;
        _os_log_error_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_ERROR, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Invalid video stall time. count=%u stall start time=%f stall length=%f total stall time=%f stall time delta=%f", (uint8_t *)&v11, 0x54u);
      }
    }
    reportingSymptom();
    return 0.0;
  }
  return v3;
}

uint64_t _VideoReceiver_UpdateVideoStallTime(uint64_t result, double a2, double a3)
{
  uint64_t v4;
  double v5;
  double v6;
  uint64_t v7;
  unsigned int v8;
  double v9;
  double v10;
  unsigned int v12;
  uint64_t v13;
  NSObject *v14;
  int v15;
  int v16;
  uint64_t v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  unsigned int v25;
  __int16 v26;
  int v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v4 = result + 40656;
  v5 = *(double *)(result + 41136);
  v6 = *(double *)(result + 41088) + a2 - *(double *)(result + 41128);
  *(double *)(result + 41088) = v6;
  if (v5 < a2)
    v5 = a2;
  *(double *)(result + 41136) = v5;
  *(_OWORD *)(result + 41120) = 0u;
  if (!*(_BYTE *)(result + 41720))
  {
    v7 = result;
    v8 = *(_DWORD *)(result + 1376);
    if (v8)
    {
      v9 = *(double *)(result + 41712);
      v10 = a3 - v9;
      if (v9 != 0.0 && v10 >= 5.0)
      {
        v12 = (v6 * 10000.0 / v10);
        if (v8 < v12)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
          {
            v13 = VRTraceErrorLogLevelToCSTR();
            v14 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              v15 = *(_DWORD *)(v7 + 1376);
              v16 = 136316418;
              v17 = v13;
              v18 = 2080;
              v19 = "_VideoReceiver_CheckAndReportRegressedVideoStallPercentage";
              v20 = 1024;
              v21 = 1281;
              v22 = 2048;
              v23 = v7;
              v24 = 1024;
              v25 = v12;
              v26 = 1024;
              v27 = v15;
              _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] VideoStallPercentage=%d >= ReportingThresholdFromTelemetry=%d", (uint8_t *)&v16, 0x32u);
            }
          }
          result = reportingSymptom();
          *(_BYTE *)(v4 + 1064) = 1;
        }
      }
    }
  }
  if (a2 > 3.0)
    return reportingSymptom();
  return result;
}

void _VideoReceiver_SendRTCPResiliencyInfo(uint64_t a1, uint64_t a2, int a3, int a4, __int16 a5, uint64_t a6, double a7)
{
  __int16 v12;
  int v13;
  char v14;
  int v15;
  uint64_t v16;
  NSObject *v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  __int128 v22[9];
  __int128 v23;
  uint64_t v24;
  uint8_t buf[4];
  uint64_t v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  __int16 v33;
  int v34;
  __int16 v35;
  int v36;
  __int16 v37;
  int v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  memset(v22, 0, sizeof(v22));
  v23 = 0u;
  v24 = 0;
  v20 = 0;
  if (a6)
  {
    v12 = *(_WORD *)(a6 + 14);
    if (v12)
    {
      v13 = *(_DWORD *)(a6 + 4);
      if (v13 != *(_DWORD *)(a2 + 4304))
        goto LABEL_6;
    }
    if (a7 - *(double *)(a2 + 4296) >= 0.1)
    {
      v13 = *(_DWORD *)(a6 + 4);
LABEL_6:
      LODWORD(v20) = v13;
      WORD2(v20) = a5;
      v14 = *(_BYTE *)(a6 + 10);
      goto LABEL_15;
    }
LABEL_11:
    *((_QWORD *)&v23 + 1) = 0;
    if (!a4)
      return;
    v15 = 1024;
    goto LABEL_23;
  }
  if (!*(_BYTE *)(a2 + 101))
    goto LABEL_11;
  v21 = 0;
  bzero(buf, 0x320uLL);
  VideoPacketBuffer_GetCachedBurstLossStatistics(*(_QWORD *)(a2 + 112), buf);
  _VideoReceiver_PackFrameLoss(a1, &v21, (unsigned __int16 *)buf);
  LOBYTE(v12) = (_BYTE)v28;
  if (!(_WORD)v28 || (v13 = v26, (_DWORD)v26 == *(_DWORD *)(a2 + 4304)))
  {
    if (a7 - *(double *)(a2 + 4296) < 0.1)
      goto LABEL_11;
    v13 = v26;
  }
  LODWORD(v20) = v13;
  WORD2(v20) = v21;
  v14 = BYTE6(v26);
LABEL_15:
  BYTE6(v20) = v14;
  HIBYTE(v20) = v12;
  *((_QWORD *)&v23 + 1) = &v20;
  LODWORD(v22[0]) = 512;
  *(_DWORD *)(a2 + 4304) = v13;
  *(double *)(a2 + 4296) = a7;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v16 = VRTraceErrorLogLevelToCSTR();
    v17 = *MEMORY[0x1E0CF2758];
    v18 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136316674;
        v26 = v16;
        v27 = 2080;
        v28 = "_VideoReceiver_SendRTCPResiliencyInfo";
        v29 = 1024;
        v30 = 2328;
        v31 = 1024;
        v32 = v20;
        v33 = 1024;
        v34 = WORD2(v20);
        v35 = 1024;
        v36 = BYTE6(v20);
        v37 = 1024;
        v38 = HIBYTE(v20);
        _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d RTCP sending loss feedback: frameRTPTimestamp=%u, numReceivedPackets=%u, frameSize=%u, numLostPackets=%u", buf, 0x34u);
        if ((a4 & 1) == 0)
          goto LABEL_25;
        goto LABEL_22;
      }
    }
    else if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      _VideoReceiver_SendRTCPResiliencyInfo_cold_1();
      if ((a4 & 1) != 0)
        goto LABEL_22;
LABEL_25:
      v19 = 4264;
      goto LABEL_26;
    }
  }
  if ((a4 & 1) == 0)
    goto LABEL_25;
LABEL_22:
  v15 = 1536;
LABEL_23:
  LODWORD(v22[0]) = v15;
  LODWORD(v24) = a3;
  v19 = 4260;
LABEL_26:
  ++*(_DWORD *)(a2 + v19);
  _VideoReceiver_SendRTCP(a1, a2, v22, 0, a7);
}

void _VideoReceiver_PackFrameLoss(uint64_t a1, _WORD *a2, unsigned __int16 *a3)
{
  int v5;
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  unsigned int v9;
  unsigned int v10;
  float v11;
  double v12;
  uint64_t v13;
  NSObject *v14;
  unsigned int v15;
  unsigned int v16;
  float v17;
  double v18;
  unsigned int v19;
  unsigned int v20;
  double v21;
  float v22;
  const char *v23;
  unsigned int v24;
  unsigned int v25;
  double v26;
  float v27;
  const char *v28;
  int v29;
  uint64_t v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  int v34;
  __int16 v35;
  uint64_t v36;
  __int16 v37;
  unsigned int v38;
  __int16 v39;
  unsigned int v40;
  __int16 v41;
  double v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v5 = *(unsigned __int8 *)(a1 + 41548);
  if (v5 == 2)
  {
    FECUtil_PackFrameLoss(a2, a3[6], a3[9]);
    if ((int)VRTraceGetErrorLogLevelForModule() < 8)
      return;
    v13 = VRTraceErrorLogLevelToCSTR();
    v7 = *MEMORY[0x1E0CF2758];
    v14 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        return;
      v15 = a3[6];
      v16 = a3[9];
      if (a3[5])
      {
        v17 = (double)v16 / (double)a3[5];
        v18 = v17;
      }
      else
      {
        v18 = 0.0;
      }
      v29 = 136316674;
      v30 = v13;
      v31 = 2080;
      v32 = "_VideoReceiver_PackFrameLoss";
      v33 = 1024;
      v34 = 2276;
      v35 = 2048;
      v36 = a1;
      v37 = 1024;
      v38 = v15;
      v39 = 1024;
      v40 = v16;
      v41 = 2048;
      v42 = v18;
      v28 = "VideoReceiver [%s] %s:%d VideoReceiver[%p] FEC Feedback ready groupSize=%d loss=%d ratio=%2.2f";
      goto LABEL_26;
    }
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      return;
    v24 = a3[6];
    v25 = a3[9];
    v26 = 0.0;
    if (a3[5])
    {
      v27 = (double)v25 / (double)a3[5];
      v26 = v27;
    }
    v29 = 136316674;
    v30 = v13;
    v31 = 2080;
    v32 = "_VideoReceiver_PackFrameLoss";
    v33 = 1024;
    v34 = 2276;
    v35 = 2048;
    v36 = a1;
    v37 = 1024;
    v38 = v24;
    v39 = 1024;
    v40 = v25;
    v41 = 2048;
    v42 = v26;
    v23 = "VideoReceiver [%s] %s:%d VideoReceiver[%p] FEC Feedback ready groupSize=%d loss=%d ratio=%2.2f";
LABEL_21:
    _os_log_debug_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEBUG, v23, (uint8_t *)&v29, 0x3Cu);
    return;
  }
  if (v5 == 1)
  {
    FECUtil_PackFrameLoss(a2, a3[5], a3[7]);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v6 = VRTraceErrorLogLevelToCSTR();
      v7 = *MEMORY[0x1E0CF2758];
      v8 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
          return;
        v9 = a3[5];
        v10 = a3[7];
        if (a3[5])
        {
          v11 = (double)v10 / (double)v9;
          v12 = v11;
        }
        else
        {
          v12 = 0.0;
        }
        v29 = 136316674;
        v30 = v6;
        v31 = 2080;
        v32 = "_VideoReceiver_PackFrameLoss";
        v33 = 1024;
        v34 = 2273;
        v35 = 2048;
        v36 = a1;
        v37 = 1024;
        v38 = v9;
        v39 = 1024;
        v40 = v10;
        v41 = 2048;
        v42 = v12;
        v28 = "VideoReceiver [%s] %s:%d VideoReceiver[%p] FEC Feedback ready frameSize=%d loss=%d ratio=%2.2f";
LABEL_26:
        _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, v28, (uint8_t *)&v29, 0x3Cu);
        return;
      }
      if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        return;
      v19 = a3[5];
      v20 = a3[7];
      v21 = 0.0;
      if (a3[5])
      {
        v22 = (double)v20 / (double)v19;
        v21 = v22;
      }
      v29 = 136316674;
      v30 = v6;
      v31 = 2080;
      v32 = "_VideoReceiver_PackFrameLoss";
      v33 = 1024;
      v34 = 2273;
      v35 = 2048;
      v36 = a1;
      v37 = 1024;
      v38 = v19;
      v39 = 1024;
      v40 = v20;
      v41 = 2048;
      v42 = v21;
      v23 = "VideoReceiver [%s] %s:%d VideoReceiver[%p] FEC Feedback ready frameSize=%d loss=%d ratio=%2.2f";
      goto LABEL_21;
    }
  }
}

void _VideoReceiver_ComputePacketLoss2DHistogram(__CFDictionary *a1, const void *a2, uint64_t a3)
{
  const __CFAllocator *v4;
  __CFDictionary *Mutable;
  uint64_t v6;
  const CFArrayCallBacks *v7;
  uint64_t v8;
  int v9;
  int v10;
  __CFArray *v11;
  uint64_t v12;
  uint64_t v13;
  CFNumberRef v14;
  CFNumberRef v15;
  CFStringRef v16;
  CFStringRef v17;
  int valuePtr;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v6 = 0;
  v7 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
  do
  {
    v8 = 0;
    v9 = 0;
    v10 = 0;
    do
    {
      if (*(_WORD *)(a3 + 2 * v8))
        v9 = v8;
      v10 += *(unsigned __int16 *)(a3 + 2 * v8++);
    }
    while (v8 != 102);
    if (v10)
    {
      v11 = CFArrayCreateMutable(v4, 0, v7);
      if ((v9 & 0x80000000) == 0)
      {
        v12 = 0;
        v13 = 2 * (v9 + 1);
        while (1)
        {
          valuePtr = *(unsigned __int16 *)(a3 + v12);
          v14 = CFNumberCreate(v4, kCFNumberSInt32Type, &valuePtr);
          v15 = v14;
          if (v11)
          {
            if (v14)
              break;
          }
          if (v14)
            goto LABEL_13;
LABEL_14:
          v12 += 2;
          if (v13 == v12)
            goto LABEL_15;
        }
        CFArrayAppendValue(v11, v14);
LABEL_13:
        CFRelease(v15);
        goto LABEL_14;
      }
LABEL_15:
      v16 = CFStringCreateWithFormat(v4, 0, CFSTR("%d"), v6);
      v17 = v16;
      if (Mutable && v16 && v11)
      {
        CFDictionaryAddValue(Mutable, v16, v11);
      }
      else if (!v16)
      {
        goto LABEL_21;
      }
      CFRelease(v17);
LABEL_21:
      if (v11)
        CFRelease(v11);
    }
    ++v6;
    a3 += 204;
  }
  while (v6 != 102);
  if (a1 && Mutable)
  {
    CFDictionaryAddValue(a1, a2, Mutable);
    goto LABEL_28;
  }
  if (Mutable)
LABEL_28:
    CFRelease(Mutable);
}

void _VideoReceiver_ScheduleFramesForDecodingMultiway(uint64_t a1, unsigned int *a2, int a3)
{
  unsigned __int16 *v3;
  unint64_t v4;
  int v5;
  unsigned int v6;
  unint64_t v7;
  __int128 v8;
  unsigned int *v9;
  unsigned int *v10;
  unsigned __int16 *v11;
  uint64_t v12;
  uint64_t *v13;
  char v14;
  char v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t i;
  char v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  int *v24;
  int v25;
  int v26;
  unsigned int v27;
  uint64_t v29;
  char v30;
  unsigned __int16 *v31;
  uint64_t v32;
  int v33;
  int v34;
  uint64_t v36;
  BOOL v37;
  uint64_t v39;
  uint64_t v40;
  NSObject *v41;
  char *v42;
  char v43;
  uint64_t v44;
  _BYTE *j;
  unsigned __int16 *v46;
  int v47;
  uint64_t v48;
  NSObject *v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  BOOL v53;
  int v54;
  int ErrorLogLevelForModule;
  uint64_t v56;
  NSObject *v57;
  uint64_t v58;
  int v59;
  NSObject *v60;
  const char *v61;
  uint32_t v62;
  uint64_t v63;
  NSObject *v64;
  uint64_t v65;
  int v66;
  int v67;
  int v68;
  unint64_t v70;
  unsigned __int8 v73;
  unsigned __int16 *v74;
  __int128 v75;
  _OWORD v76[5];
  unint64_t v77;
  uint8_t buf[4];
  uint64_t v79;
  __int16 v80;
  const char *v81;
  __int16 v82;
  int v83;
  __int16 v84;
  unsigned int *v85;
  __int16 v86;
  uint64_t v87;
  __int16 v88;
  int v89;
  __int16 v90;
  int v91;
  __int16 v92;
  int v93;
  uint64_t v94;

  v94 = *MEMORY[0x1E0C80C00];
  v3 = (unsigned __int16 *)(a2 + 10084);
  if (*((_BYTE *)a2 + 40704))
  {
    v4 = *a2;
    if ((_DWORD)v4)
    {
      v5 = a3;
      v6 = 0;
      v7 = 0;
      *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v76[3] = v8;
      v76[4] = v8;
      v76[1] = v8;
      v76[2] = v8;
      v75 = v8;
      v76[0] = v8;
      v9 = a2;
      do
      {
        v10 = &v9[1080 * v7];
        if (*((_QWORD *)v10 + 196))
        {
          if (v6 == 4)
            goto LABEL_65;
          v11 = (unsigned __int16 *)(v10 + 364);
          if (!*((_BYTE *)v10 + 1526) || *((unsigned __int16 *)v10 + 730) == *v11)
          {
            v70 = v7;
            v12 = 0;
            v13 = (uint64_t *)(v10 + 392);
            v77 = 0xAAAAAAAAAAAAAAAALL;
            v14 = 1;
            while (1)
            {
              v15 = v14;
              if (v6 + v12 > 3
                || !VideoPacketBuffer_SchedulePastIncompleteFrame(*v13, v5, &buf[4 * v12 - 8], *((_DWORD *)v3 + 88), 0, 0))
              {
                break;
              }
              v14 = 0;
              v12 = 1;
              if ((v15 & 1) == 0)
              {
                v16 = 2;
                goto LABEL_19;
              }
            }
            while (1)
            {
              v17 = v12;
              if (v6 + v12 > 3
                || !VideoPacketBuffer_ScheduleFutureFrame(*v13, v9[1080 * v70 + 398], v5, &buf[4 * v12 - 8], *((_DWORD *)v3 + 88), 0, 0, *((double *)v3 + 141)))
              {
                break;
              }
              v12 = 1;
              if (v17)
              {
                v16 = 2;
                goto LABEL_19;
              }
            }
            if ((_DWORD)v12)
            {
              v16 = 1;
LABEL_19:
              for (i = 0; i != v16; ++i)
              {
                v74 = 0;
                v73 = 0;
                if (*((_BYTE *)v11 + 69))
                {
LABEL_21:
                  v19 = 0;
                  LODWORD(v20) = 1;
LABEL_22:
                  v21 = *(_DWORD *)&buf[4 * i - 8];
                  if (v6)
                  {
                    v22 = 0;
                    v23 = v6;
                    v24 = (int *)&v75;
                    while (1)
                    {
                      v26 = *v24;
                      v24 += 6;
                      v25 = v26;
                      v27 = v21 - v26;
                      if (v21 == v26 || v27 >= 0x7FFFFFFF)
                        break;
                      --v22;
                      if (!(v6 + v22))
                        goto LABEL_58;
                    }
                    if (v21 == v25)
                      v20 = v20;
                    else
                      v20 = 0;
                    if (v6 <= (int)v20 - (int)v22)
                    {
                      v23 = (v20 - v22);
                    }
                    else
                    {
                      v39 = v20 - v22;
                      memmove((char *)&v76[-1] + 24 * (v20 - v22 + 1), (char *)&v76[-1] + 24 * (v20 - v22), 24 * (v6 - v20 + v22));
                      v23 = v39;
                    }
                  }
                  else
                  {
                    v23 = 0;
                  }
LABEL_58:
                  v42 = (char *)&v76[-1] + 24 * v23;
                  *(_DWORD *)v42 = v21;
                  *((_DWORD *)v42 + 1) = 0;
                  *((_QWORD *)v42 + 1) = v11;
                  v42[16] = v19;
                  *(_DWORD *)(v42 + 17) = 0;
                  *((_DWORD *)v42 + 5) = 0;
                  ++v6;
                }
                else
                {
                  VideoPacketBuffer_GetFrameStreamIDs(*v13, *(_DWORD *)&buf[4 * i - 8], &v73, &v74);
                  v29 = v73;
                  if (v73)
                  {
                    v30 = 0;
                    v31 = v74;
                    v32 = *((_QWORD *)v3 + 1);
                    do
                    {
                      v34 = *v31++;
                      v33 = v34;
                      if ((v32 & 0x1000000000000) != 0
                        && (v33 == (unsigned __int16)*((_QWORD *)v3 + 1) || WORD1(v32) == v33))
                      {
                        LODWORD(v20) = 0;
                        v19 = 1;
                        goto LABEL_22;
                      }
                      v36 = *(_QWORD *)v3;
                      v37 = (*(_QWORD *)v3 & 0x1000000000000) != 0
                         && (v33 == (unsigned __int16)v36 || v33 == WORD1(v36));
                      v30 |= v37;
                      --v29;
                    }
                    while (v29);
                    if ((v30 & 1) != 0)
                      goto LABEL_21;
                  }
                  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                  {
                    v40 = VRTraceErrorLogLevelToCSTR();
                    v41 = *MEMORY[0x1E0CF2758];
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)buf = 136315906;
                      v79 = v40;
                      v80 = 2080;
                      v81 = "_VideoReceiver_FindCurrentAndTargetFramesToBeScheduledForMultiway";
                      v82 = 1024;
                      v83 = 3620;
                      v84 = 2048;
                      v85 = a2;
                      _os_log_error_impl(&dword_1D8A54000, v41, OS_LOG_TYPE_ERROR, "VideoReceiver [%s] %s:%d VideoReceiver[%p] No valid stream id found in packet!", buf, 0x26u);
                    }
                  }
                }
              }
            }
            v9 = a2;
            v4 = *a2;
            v5 = a3;
            v7 = v70;
          }
        }
        ++v7;
      }
      while (v7 < v4);
      if (v6)
      {
LABEL_65:
        v43 = 0;
        v44 = v6;
        for (j = v76; ; j += 24)
        {
          v46 = (unsigned __int16 *)*((_QWORD *)j - 1);
          if (!*((_BYTE *)v46 + 69) && (v43 & 1) != 0 && !*j)
            goto LABEL_76;
          _VideoReceiver_AssembleAndEnqueueFrame(a1, (uint64_t)a2, *((unsigned __int16 **)j - 1), *((_DWORD *)j - 4));
          v47 = *((unsigned __int8 *)v46 + 69);
          if (!*((_BYTE *)v46 + 69))
            break;
          if (!*((_BYTE *)v3 + 16))
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v48 = VRTraceErrorLogLevelToCSTR();
              v49 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                v50 = *((_QWORD *)a2 + 144);
                v51 = *v3;
                *(_DWORD *)buf = 136316418;
                v79 = v48;
                v80 = 2080;
                v81 = "_VideoReceiver_ApplyMultiwaySchedule";
                v82 = 1024;
                v83 = 3833;
                v84 = 2048;
                v85 = a2;
                v86 = 2048;
                v87 = v50;
                v88 = 1024;
                v89 = v51;
                _os_log_impl(&dword_1D8A54000, v49, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] participantId[%llu] Successfully switched stream %d -> 1:1", buf, 0x36u);
              }
            }
            v52 = (uint64_t)a2;
            _VideoReceiver_UpdateStreamSwitchContextForTargetStream((uint64_t)a2, *v46, v46[1], v46[2]);
            _VideoReceiver_CompleteStreamSwitch(a2, (uint64_t)v46);
LABEL_75:
            _VideoReceiver_SwitchIntoOneToOne(v52, v47 != 0, (uint64_t)v46);
LABEL_76:
            v43 = 1;
          }
LABEL_90:
          if (!--v44)
            return;
        }
        if (!*j)
          goto LABEL_90;
        v53 = *((_BYTE *)v3 + 16) || !*((_BYTE *)v3 + 6) || !*((_BYTE *)v3 + 14) || *v3 != v3[4];
        if (v43 & 1 | !v53)
          goto LABEL_90;
        if (!VideoPacketBuffer_FirstIDRReceived(*((_QWORD *)v46 + 14)))
        {
          v43 = 0;
          goto LABEL_90;
        }
        v54 = *((unsigned __int8 *)v3 + 16);
        ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
        if (v54)
        {
          if (ErrorLogLevelForModule >= 7)
          {
            v56 = VRTraceErrorLogLevelToCSTR();
            v57 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              v58 = *((_QWORD *)a2 + 144);
              v59 = v3[4];
              *(_DWORD *)buf = 136316418;
              v79 = v56;
              v80 = 2080;
              v81 = "_VideoReceiver_ApplyMultiwaySchedule";
              v82 = 1024;
              v83 = 3846;
              v84 = 2048;
              v85 = a2;
              v86 = 2048;
              v87 = v58;
              v88 = 1024;
              v89 = v59;
              v60 = v57;
              v61 = "VideoReceiver [%s] %s:%d VideoReceiver[%p] participantId[%llu] Successfully switched stream 1:1 -> %d";
              v62 = 54;
LABEL_95:
              _os_log_impl(&dword_1D8A54000, v60, OS_LOG_TYPE_DEFAULT, v61, buf, v62);
            }
          }
        }
        else if (ErrorLogLevelForModule >= 7)
        {
          v63 = VRTraceErrorLogLevelToCSTR();
          v64 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v65 = *((_QWORD *)a2 + 144);
            v66 = *v46;
            v67 = *v3;
            v68 = v3[4];
            *(_DWORD *)buf = 136316930;
            v79 = v63;
            v80 = 2080;
            v81 = "_VideoReceiver_ApplyMultiwaySchedule";
            v82 = 1024;
            v83 = 3848;
            v84 = 2048;
            v85 = a2;
            v86 = 2048;
            v87 = v65;
            v88 = 1024;
            v89 = v66;
            v90 = 1024;
            v91 = v67;
            v92 = 1024;
            v93 = v68;
            v60 = v64;
            v61 = "VideoReceiver [%s] %s:%d VideoReceiver[%p] participantId[%llu] streamId:[%d] Successfully switched stream %d -> %d";
            v62 = 66;
            goto LABEL_95;
          }
        }
        v52 = (uint64_t)a2;
        _VideoReceiver_CompleteStreamSwitch(a2, (uint64_t)v46);
        if (*((_BYTE *)v3 + 16))
          goto LABEL_75;
        goto LABEL_76;
      }
    }
  }
}

uint64_t _VideoReceiver_ProcessVideoRTPInternal(uint64_t a1, unsigned int *a2, unsigned __int16 *a3, uint64_t a4)
{
  unsigned __int16 *v7;
  int64_t v8;
  uint64_t v9;
  double v10;
  unsigned __int16 *v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  int v15;
  int v16;
  int v17;
  int v18;
  char v19;
  unsigned __int16 *v20;
  uint64_t v21;
  uint64_t v22;
  NSObject *v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  const char *v31;
  NSObject *v32;
  uint32_t v33;
  unsigned int v34;
  uint64_t v35;
  NSObject *v36;
  unsigned int v37;
  unsigned int v38;
  char v39;
  int v40;
  uint64_t v41;
  unsigned __int16 *v42;
  int v43;
  int v44;
  BOOL v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  void *ControlInfoWithBuffer;
  void *v53;
  unint64_t v54;
  uint64_t v55;
  NSObject *v56;
  uint64_t v57;
  NSObject *v58;
  uint64_t v59;
  BOOL v60;
  int v61;
  int v62;
  unsigned int *v63;
  int v64;
  void (*v65)(_QWORD);
  char v66;
  unsigned int v67;
  unsigned int v68;
  uint64_t v69;
  uint64_t v70;
  double v71;
  unsigned int v72;
  int v73;
  int v74;
  unsigned int FrameSliceHeader;
  unsigned int *v76;
  NSObject *v77;
  NSObject *v78;
  unsigned int v79;
  const char *v80;
  NSObject *v81;
  uint32_t v82;
  NSObject *v83;
  NSObject *v84;
  unsigned int v85;
  const char *v86;
  NSObject *v87;
  uint32_t v88;
  NSObject *v89;
  uint64_t v90;
  uint64_t v91;
  uint8_t v92;
  _DWORD *v93;
  int v94;
  uint64_t v95;
  uint64_t v96;
  NSObject *v97;
  NSObject *v98;
  int v99;
  unsigned int *v100;
  int v101;
  int *v102;
  unsigned int v103;
  uint64_t v104;
  uint64_t v105;
  unsigned int *v106;
  __int128 v107;
  double v108;
  unint64_t i;
  int v110;
  uint64_t v111;
  NSObject *v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  int v119;
  unsigned int v120;
  uint64_t v121;
  unsigned int *Stream;
  unsigned int *v123;
  uint64_t v124;
  unsigned __int16 *v125;
  uint64_t v126;
  NSObject *v127;
  int v128;
  uint64_t v129;
  int v130;
  BOOL v131;
  uint64_t (*v132)(uint64_t, OpaqueCMBlockBuffer *, CMBlockBufferRef *);
  void (*v133)(uint64_t, uint64_t, double);
  int v134;
  uint64_t v135;
  NSObject *v136;
  char *v137;
  uint64_t v138;
  NSObject *v139;
  uint64_t v140;
  int v141;
  int v142;
  _BOOL4 v143;
  _BOOL4 v144;
  int v145;
  unint64_t v146;
  unint64_t v147;
  unsigned int *v148;
  BOOL v149;
  int v150;
  uint64_t v151;
  NSObject *v152;
  uint64_t v153;
  int v154;
  int v155;
  _BOOL4 v156;
  double v157;
  unint64_t v158;
  int v159;
  unint64_t v160;
  uint64_t v161;
  double v162;
  uint64_t v163;
  uint64_t v164;
  NSObject *v165;
  NSObject *v166;
  uint64_t v167;
  int64_t v168;
  double v169;
  double v170;
  double v171;
  uint64_t v172;
  NSObject *v173;
  uint64_t v174;
  uint64_t v175;
  unsigned int v176;
  uint64_t v177;
  uint64_t v178;
  unsigned __int16 *v179;
  int v180;
  float v181;
  float v182;
  double v183;
  double v184;
  unsigned int v185;
  float v186;
  unsigned int *v187;
  unsigned int v188;
  double TotalPLR;
  float v190;
  float v191;
  int v192;
  float v193;
  unsigned int v194;
  float v195;
  float v196;
  char v197;
  int v198;
  unsigned int v199;
  uint64_t v200;
  unsigned int v201;
  float v202;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  int v207;
  int v208;
  int v209;
  _DWORD *v210;
  int v211;
  int *v212;
  int v213;
  uint64_t *v215;
  uint64_t v216;
  __int128 v217;
  __int128 v218;
  _OWORD v219[2];
  __int128 v220;
  __int16 v221;
  CMBlockBufferRef blockBufferOut;
  unint64_t v223;
  uint64_t v224;
  int v225;
  unsigned int v226;
  double v227;
  _BOOL4 v228;
  __int128 v229;
  __int128 v230;
  __int128 v231;
  int v232;
  _OWORD __dst[50];
  uint8_t buf[800];
  double v235[4];
  int v236;
  uint64_t v237;

  v237 = *MEMORY[0x1E0C80C00];
  v7 = (unsigned __int16 *)(a2 + 10084);
  v211 = *(_DWORD *)(a4 + 12);
  v213 = *(unsigned __int16 *)(a4 + 20);
  v8 = *(unsigned int *)(a4 + 24);
  v226 = 0;
  v9 = *(_QWORD *)(a4 + 40);
  v10 = micro();
  v225 = 0;
  v232 = 0;
  v231 = 0u;
  v230 = 0u;
  v229 = 0u;
  blockBufferOut = 0;
  v223 = 0;
  v224 = 0;
  v221 = -21846;
  *((_QWORD *)v7 + 141) = v9;
  v228 = 0;
  v12 = *(_QWORD *)(a4 + 136);
  v11 = *(unsigned __int16 **)(a4 + 144);
  v220 = 0u;
  v218 = 0u;
  memset(v219, 0, sizeof(v219));
  v217 = 0u;
  if (*((_BYTE *)v7 + 857))
  {
    if (*(_BYTE *)(a4 + 88))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v13 = VRTraceErrorLogLevelToCSTR();
        v14 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v15 = *v7;
          v16 = v7[4];
          v17 = *(unsigned __int8 *)(a4 + 88);
          v18 = *(unsigned __int16 *)(a4 + 64);
          *(_DWORD *)buf = 136316930;
          *(_QWORD *)&buf[4] = v13;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VideoReceiver_ProcessVideoRTPInternal";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 3138;
          *(_WORD *)&buf[28] = 2048;
          *(_QWORD *)&buf[30] = a2;
          *(_WORD *)&buf[38] = 1024;
          *(_DWORD *)&buf[40] = v15;
          *(_WORD *)&buf[44] = 1024;
          *(_DWORD *)&buf[46] = v16;
          *(_WORD *)&buf[50] = 1024;
          *(_DWORD *)&buf[52] = v17;
          *(_WORD *)&buf[56] = 1024;
          *(_DWORD *)&buf[58] = v18;
          _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] currentStreamId:%u targetStreamId:%u received packet with numOfStreamIDs:%d streamID[0]:%u", buf, 0x3Eu);
        }
      }
    }
  }
  if ((_VideoReceiver_ShouldProcessPacket((uint64_t)a2, (uint64_t)a3, *(unsigned __int8 *)(a4 + 50), *(_QWORD *)(a4 + 56), (unsigned __int16 *)(a4 + 64), *(unsigned __int8 *)(a4 + 88)) & 1) == 0)
  {
    v21 = 2149515265;
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      return v21;
    v22 = VRTraceErrorLogLevelToCSTR();
    v23 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      return v21;
    v24 = *v7;
    v25 = v7[4];
    v26 = *(unsigned __int8 *)(a4 + 88);
    v27 = *(unsigned __int16 *)(a4 + 64);
    v28 = *(unsigned __int16 *)(a4 + 66);
    v29 = *(unsigned __int16 *)(a4 + 68);
    v30 = *(unsigned __int16 *)(a4 + 70);
    *(_DWORD *)buf = 136317698;
    *(_QWORD *)&buf[4] = v22;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = "_VideoReceiver_ProcessVideoRTPInternal";
    *(_WORD *)&buf[22] = 1024;
    *(_DWORD *)&buf[24] = 3143;
    *(_WORD *)&buf[28] = 2048;
    *(_QWORD *)&buf[30] = a2;
    *(_WORD *)&buf[38] = 1024;
    *(_DWORD *)&buf[40] = v24;
    *(_WORD *)&buf[44] = 1024;
    *(_DWORD *)&buf[46] = v25;
    *(_WORD *)&buf[50] = 1024;
    *(_DWORD *)&buf[52] = v26;
    *(_WORD *)&buf[56] = 1024;
    *(_DWORD *)&buf[58] = v27;
    *(_WORD *)&buf[62] = 1024;
    *(_DWORD *)&buf[64] = v28;
    *(_WORD *)&buf[68] = 1024;
    *(_DWORD *)&buf[70] = v29;
    *(_WORD *)&buf[74] = 1024;
    *(_DWORD *)&buf[76] = v30;
    v31 = "VideoReceiver [%s] %s:%d VideoReceiver[%p] Ignoring video packet (currentID:%d target:%d numOfStreamIDs:%d str"
          "eamIDs:[%d %d %d %d...]) !";
    v32 = v23;
    v33 = 80;
LABEL_193:
    _os_log_error_impl(&dword_1D8A54000, v32, OS_LOG_TYPE_ERROR, v31, buf, v33);
    return v21;
  }
  v215 = (uint64_t *)(a2 + 10162);
  kdebug_trace();
  v19 = *((_BYTE *)a2 + 1209);
  if (v19)
  {
    v20 = a3;
    if (*((_BYTE *)a3 + 69))
    {
      v19 = 0;
    }
    else if (*(_BYTE *)(a4 + 88))
    {
      v40 = *a3;
      v41 = *(unsigned __int8 *)(a4 + 88) - 1;
      v42 = (unsigned __int16 *)(a4 + 64);
      do
      {
        v44 = *v42++;
        v43 = v44;
        v46 = v41-- != 0;
        v149 = v43 == v40;
        v19 = v43 != v40;
      }
      while (!v149 && v46);
    }
    else
    {
      v19 = 1;
    }
  }
  else
  {
    v20 = a3;
  }
  v212 = (int *)(a2 + 10384);
  v210 = a2 + 10089;
  v217 = xmmword_1D91092B0;
  *(_QWORD *)&v218 = &blockBufferOut;
  DWORD2(v218) = 0;
  memset(v219, 0, 18);
  *((_QWORD *)&v219[1] + 1) = &v228;
  *(_QWORD *)&v220 = a4 + 8;
  BYTE8(v220) = v19;
  if (*((_BYTE *)a2 + 40704))
  {
    v34 = a2[10175];
    if (v34 != (_DWORD)v8 && v34 - v8 <= 0x7FFFFFFE)
    {
      ++a2[10364];
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v35 = VRTraceErrorLogLevelToCSTR();
        v36 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v37 = a2[10175];
          v38 = a2[10364];
          *(_DWORD *)buf = 136316674;
          *(_QWORD *)&buf[4] = v35;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VideoReceiver_CheckStartOfNewFrameAndOutOfOrderCondition";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 2803;
          *(_WORD *)&buf[28] = 2048;
          *(_QWORD *)&buf[30] = a2;
          *(_WORD *)&buf[38] = 1024;
          *(_DWORD *)&buf[40] = v37;
          *(_WORD *)&buf[44] = 1024;
          *(_DWORD *)&buf[46] = v8;
          *(_WORD *)&buf[50] = 1024;
          *(_DWORD *)&buf[52] = v38;
          _os_log_impl(&dword_1D8A54000, v36, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Video packet arrived out of order. lastReceivedPacketTimestamp=%u, packetTimestamp=%u, significantOutOfOrderPacketCount=%u", buf, 0x38u);
        }
      }
LABEL_23:
      v39 = 1;
      if (!(_DWORD)v12)
        goto LABEL_87;
      goto LABEL_34;
    }
    if (v34 == (_DWORD)v8)
      goto LABEL_23;
    v39 = 0;
    a2[10175] = v8;
    if (!(_DWORD)v12)
      goto LABEL_87;
  }
  else
  {
    v39 = 0;
    a2[10175] = v8;
    *((_BYTE *)a2 + 40704) = 1;
    if (!(_DWORD)v12)
      goto LABEL_87;
  }
LABEL_34:
  v216 = 0;
  RTPGetRecvStats(*((_QWORD *)v20 + 6), (_DWORD *)&v216 + 1, &v216);
  if (VCMediaControlInfo_IsLossStatsEnabled(*((unsigned __int8 *)a2 + 41548)) && (v47 = *((_QWORD *)v20 + 14)) != 0)
  {
    memcpy(buf, &unk_1D910BB60, sizeof(buf));
    VideoPacketBuffer_GetCachedBurstLossStatistics(v47, buf);
    memcpy(__dst, buf, sizeof(__dst));
    if (*((_BYTE *)v20 + 101))
      _VideoReceiver_SendRTCPResiliencyInfo((uint64_t)a2, (uint64_t)v20, 0, 0, SWORD2(v216), (uint64_t)__dst, v10);
    _VideoReceiver_PackFrameLoss((uint64_t)a2, (_WORD *)&v216 + 2, (unsigned __int16 *)buf);
  }
  else if (*((_BYTE *)v20 + 109))
  {
    HIDWORD(v216) = 0;
  }
  v48 = *((_QWORD *)v20 + 10);
  if (v48 || (v59 = *((_QWORD *)a2 + 5045)) != 0 && *(_QWORD *)(v59 + 80) || *v215)
  {
    v49 = v12;
    *(_OWORD *)((char *)__dst + 8) = 0u;
    *(_OWORD *)((char *)&__dst[1] + 8) = 0u;
    *(_QWORD *)&__dst[0] = v9;
    v50 = *(_DWORD *)(a4 + 24);
    DWORD2(__dst[0]) = *(_QWORD *)(a4 + 120);
    DWORD1(__dst[1]) = HIDWORD(v216);
    HIDWORD(__dst[1]) = v50;
    DWORD2(__dst[1]) = v216 >> 3;
    if (!v48)
    {
      v51 = *((_QWORD *)a2 + 5045);
      if (!v51 || (v48 = *(_QWORD *)(v51 + 80)) == 0)
        v48 = *v215;
    }
    v21 = 2149515265;
    ControlInfoWithBuffer = VCMediaControlInfoGeneratorCreateControlInfoWithBuffer(v48, (uint64_t)v11, v49, (uint64_t)__dst);
    v53 = ControlInfoWithBuffer;
    if (!ControlInfoWithBuffer)
      goto LABEL_62;
    if (VCMediaControlInfoHasInfo(ControlInfoWithBuffer, (const char *)3))
    {
      VCMediaControlInfoGetInfo(v53, (const char *)3, (uint64_t)v219 + 12, 1, 0);
      BYTE12(v219[0]) |= 0x80u;
    }
    if (VCMediaControlInfoHasInfo(v53, (const char *)4))
      VCMediaControlInfoGetInfo(v53, (const char *)4, (uint64_t)v219 + 8, 4, 0);
    if (VCMediaControlInfoHasInfo(v53, (const char *)6) && VCMediaControlInfoGetVersion(v53) == 2)
    {
      *(_DWORD *)buf = -1431655766;
      VCMediaControlInfoGetInfo(v53, (const char *)6, (uint64_t)buf, 4, 0);
      HIDWORD(v54) = *(_DWORD *)buf;
      LODWORD(v54) = *(_DWORD *)buf;
      BYTE13(v219[0]) = 1;
      *(_DWORD *)((char *)v219 + 14) = v54 >> 16;
    }
    if (VCMediaControlInfoHasInfo(v53, (const char *)5))
    {
      VCMediaControlInfoGetInfo(v53, (const char *)5, (uint64_t)&v226, 4, 0);
      v226 = bswap32(v226);
    }
    if (VCMediaControlInfoHasInfo(v53, (const char *)7))
    {
      v236 = 0;
      memset(v235, 0, sizeof(v235));
      v227 = -3.72066208e-103;
      VCMediaControlInfoGetInfo(v53, (const char *)7, (uint64_t)v235, 36, (uint64_t)&v227);
      if (*(_QWORD *)&v227 <= 3uLL)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v55 = VRTraceErrorLogLevelToCSTR();
          v56 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136316162;
            *(_QWORD *)&buf[4] = v55;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VideoReceiver_ProcessVideoControlInfo";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 2696;
            *(_WORD *)&buf[28] = 2048;
            *(_QWORD *)&buf[30] = a2;
            *(_WORD *)&buf[38] = 2048;
            *(double *)&buf[40] = v227;
            _os_log_error_impl(&dword_1D8A54000, v56, OS_LOG_TYPE_ERROR, "VideoReceiver [%s] %s:%d VideoReceiver[%p] FEC header size %ld too small!", buf, 0x30u);
          }
        }
        v21 = 2149515307;
LABEL_62:
        VCMediaControlInfoDispose((uint64_t)v53);
        if ((int)VRTraceGetErrorLogLevelForModule() < 3)
          return v21;
        v57 = VRTraceErrorLogLevelToCSTR();
        v58 = *MEMORY[0x1E0CF2758];
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          return v21;
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)&buf[4] = v57;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VideoReceiver_ProcessVideoRTPInternal";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 3173;
        *(_WORD *)&buf[28] = 2048;
        *(_QWORD *)&buf[30] = a2;
        *(_WORD *)&buf[38] = 1024;
        *(_DWORD *)&buf[40] = v21;
        v31 = "VideoReceiver [%s] %s:%d VideoReceiver[%p] UNEXPECTED hResult:%d after processing video control Info";
        goto LABEL_173;
      }
      FECHeader_UnpackHeaderFromBuffer(&v228, *v212, (unsigned int *)v235, *(unint64_t *)&v227);
    }
    VCMediaControlInfoDispose((uint64_t)v53);
    goto LABEL_75;
  }
  if (a2[10393])
  {
    if ((VCCVOExtensionUtils_CameraStatusBitsFromCVOExtension(a2[10393], v11, v12, (_BYTE *)v219 + 12) & 1) == 0
      && (int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VideoReceiver_ProcessVideoRTPInternal_cold_6();
    }
  }
LABEL_75:
  v60 = v228;
  if (v228)
  {
    if (DWORD1(v229) >> 30)
      v61 = 0x400000;
    else
      v61 = 0x800000;
    v62 = v61 & DWORD1(v229);
    v60 = v62 == 0;
    v63 = a2 + 10162;
    if (*v212 == 1 && !v62)
    {
      FECUtil_UpdateParitySequenceNumberHistory((uint64_t)v212, *(unsigned __int16 *)(*((_QWORD *)&v219[1] + 1) + 54));
      v60 = 1;
    }
  }
  else
  {
    v63 = a2 + 10162;
  }
  if (LOWORD(v219[1]) == 1)
    ++v63[96];
  if (v60)
  {
    v209 = 1;
    goto LABEL_90;
  }
LABEL_87:
  if (!*(_BYTE *)(a4 + 202))
    _VideoReceiverStreamStats_AddPacket((uint64_t)(v20 + 70), *(_DWORD *)(a4 + 28), *(unsigned __int16 *)(a4 + 20));
  v209 = 0;
LABEL_90:
  if (*((_BYTE *)a2 + 1183))
  {
    v64 = v226;
    if (v226)
    {
      v65 = (void (*)(_QWORD))*((_QWORD *)a2 + 179);
      if (v65)
      {
        v65(*((_QWORD *)a2 + 177));
        v64 = v226;
      }
      VideoTransmitter_ACKLTRFrame(*((_QWORD *)a2 + 5048), v64);
    }
  }
  if (*((_BYTE *)a2 + 1186))
    v66 = v39;
  else
    v66 = 1;
  if ((v66 & 1) == 0)
  {
    v67 = a2[259];
    buf[23] = 0;
    *(_DWORD *)&buf[19] = 0;
    memset(&buf[72], 0, 128);
    v68 = a2[10238];
    v69 = *((_QWORD *)a2 + 5093);
    v70 = *((_QWORD *)a2 + 5175);
    *(_QWORD *)buf = 7;
    *(_QWORD *)&buf[8] = v9;
    *(_WORD *)&buf[16] = 0;
    buf[18] = 1;
    *(_DWORD *)&buf[24] = 4;
    *(_DWORD *)&buf[28] = v8;
    *(_DWORD *)&buf[32] = v67;
    *(_DWORD *)&buf[36] = v68;
    *(_QWORD *)&buf[40] = 0;
    *(_QWORD *)&buf[48] = v9;
    *(_QWORD *)&buf[56] = 0;
    *(_QWORD *)&buf[64] = v69;
    VCRateControlSetStatistics(v70, buf);
  }
  v71 = *(double *)(a4 + 40);
  v72 = *(_DWORD *)(a4 + 24);
  v73 = *(_DWORD *)(a4 + 8);
  if ((*v210 - 2) < 2)
  {
    v74 = 0;
    goto LABEL_105;
  }
  if (*v210 == 1 && *(_BYTE *)(a4 + 88))
  {
    v74 = *(unsigned __int16 *)(a4 + 64);
LABEL_105:
    if (v71 - *((double *)a2 + 5160) < 2.0)
      goto LABEL_142;
    v207 = v74;
    v208 = *(_DWORD *)(a4 + 120);
    FrameSliceHeader = ReadFrameSliceHeader(*(_DWORD *)(a4 + 12), *(_QWORD *)(a4 + 168), *(_DWORD *)(a4 + 160), 0);
    if (FrameSliceHeader <= 6 && ((1 << FrameSliceHeader) & 0x4C) != 0)
    {
      v76 = a2 + 10162;
      a2[10318] = v72;
      *((_BYTE *)a2 + 41276) = 1;
      if ((int)VRTraceGetErrorLogLevelForModule() < 8)
        goto LABEL_127;
      v204 = VRTraceErrorLogLevelToCSTR();
      v77 = *MEMORY[0x1E0CF2758];
      v78 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        v76 = a2 + 10162;
        if (!os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
          goto LABEL_127;
        v79 = a2[10318];
        *(_DWORD *)buf = 136316418;
        *(_QWORD *)&buf[4] = v204;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VideoReceiver_ProcessProbingSequence";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 2742;
        *(_WORD *)&buf[28] = 2048;
        *(_QWORD *)&buf[30] = a2;
        *(_WORD *)&buf[38] = 1024;
        *(_DWORD *)&buf[40] = v79;
        *(_WORD *)&buf[44] = 1024;
        *(_DWORD *)&buf[46] = v207;
        v80 = "VideoReceiver [%s] %s:%d VideoReceiver[%p] Receiving a packet of a probing sequence:%u, streamID:%u";
        v81 = v77;
        v82 = 50;
        goto LABEL_126;
      }
      v76 = a2 + 10162;
      if (!os_log_type_enabled(v78, OS_LOG_TYPE_DEBUG))
        goto LABEL_127;
      v85 = a2[10318];
      *(_DWORD *)buf = 136316418;
      *(_QWORD *)&buf[4] = v204;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "_VideoReceiver_ProcessProbingSequence";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 2742;
      *(_WORD *)&buf[28] = 2048;
      *(_QWORD *)&buf[30] = a2;
      *(_WORD *)&buf[38] = 1024;
      *(_DWORD *)&buf[40] = v85;
      *(_WORD *)&buf[44] = 1024;
      *(_DWORD *)&buf[46] = v207;
      v86 = "VideoReceiver [%s] %s:%d VideoReceiver[%p] Receiving a packet of a probing sequence:%u, streamID:%u";
      v87 = v77;
      v88 = 50;
      goto LABEL_139;
    }
    v76 = a2 + 10162;
    if (v72 == a2[10318])
    {
      *((_BYTE *)a2 + 41276) = 1;
      if ((int)VRTraceGetErrorLogLevelForModule() < 8)
        goto LABEL_127;
      v205 = VRTraceErrorLogLevelToCSTR();
      v83 = *MEMORY[0x1E0CF2758];
      v84 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        v76 = a2 + 10162;
        if (!os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
          goto LABEL_127;
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)&buf[4] = v205;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VideoReceiver_ProcessProbingSequence";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 2746;
        *(_WORD *)&buf[28] = 2048;
        *(_QWORD *)&buf[30] = a2;
        *(_WORD *)&buf[38] = 1024;
        *(_DWORD *)&buf[40] = v207;
        v80 = "VideoReceiver [%s] %s:%d VideoReceiver[%p] Continue receiving a packet of the same probing sequence, streamID:%u";
LABEL_125:
        v81 = v83;
        v82 = 44;
LABEL_126:
        _os_log_impl(&dword_1D8A54000, v81, OS_LOG_TYPE_DEFAULT, v80, buf, v82);
        goto LABEL_127;
      }
      v76 = a2 + 10162;
      if (!os_log_type_enabled(v84, OS_LOG_TYPE_DEBUG))
        goto LABEL_127;
      *(_DWORD *)buf = 136316162;
      *(_QWORD *)&buf[4] = v205;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "_VideoReceiver_ProcessProbingSequence";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 2746;
      *(_WORD *)&buf[28] = 2048;
      *(_QWORD *)&buf[30] = a2;
      *(_WORD *)&buf[38] = 1024;
      *(_DWORD *)&buf[40] = v207;
      v86 = "VideoReceiver [%s] %s:%d VideoReceiver[%p] Continue receiving a packet of the same probing sequence, streamID:%u";
    }
    else
    {
      if (!*((_BYTE *)a2 + 41276))
        goto LABEL_142;
      v76 = a2 + 10162;
      *((_BYTE *)a2 + 41276) = 0;
      a2[10318] = 0;
      if ((int)VRTraceGetErrorLogLevelForModule() < 8)
      {
LABEL_127:
        v90 = *((_QWORD *)v76 + 94);
        if (v90)
        {
          v91 = *((_QWORD *)a2 + 128);
          v92 = *((_BYTE *)v76 + 628);
          *(_QWORD *)buf = 4;
          *(double *)&buf[8] = v71;
          *(_WORD *)&buf[16] = 0;
          buf[18] = v73 != 0;
          buf[19] = 1;
          *(_DWORD *)&buf[20] = 0;
          *(_DWORD *)&buf[24] = v91;
          buf[28] = 0;
          buf[29] = v92;
          *(_WORD *)&buf[30] = v73 != 0;
          *(_DWORD *)&buf[32] = v72;
          *(_DWORD *)&buf[36] = v208;
          *(double *)&buf[40] = v71;
          memset(&buf[52], 0, 148);
          *(_DWORD *)&buf[48] = v72;
          VCRateControlSetStatistics(v90, buf);
          v20 = a3;
          if (v73)
            goto LABEL_133;
        }
        else
        {
          v20 = a3;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3
            && (VRTraceErrorLogLevelToCSTR(), os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR)))
          {
            _VideoReceiver_ProcessVideoRTPInternal_cold_5();
            if (v73)
              goto LABEL_133;
          }
          else if (v73)
          {
            goto LABEL_133;
          }
        }
        if (*((_BYTE *)a2 + 41276))
          goto LABEL_142;
LABEL_133:
        *((double *)a2 + 5160) = v71;
        goto LABEL_142;
      }
      v206 = VRTraceErrorLogLevelToCSTR();
      v83 = *MEMORY[0x1E0CF2758];
      v89 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        v76 = a2 + 10162;
        if (!os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
          goto LABEL_127;
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)&buf[4] = v206;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VideoReceiver_ProcessProbingSequence";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 2751;
        *(_WORD *)&buf[28] = 2048;
        *(_QWORD *)&buf[30] = a2;
        *(_WORD *)&buf[38] = 1024;
        *(_DWORD *)&buf[40] = v207;
        v80 = "VideoReceiver [%s] %s:%d VideoReceiver[%p] Receiving a packet that is not a probing sequence, streamID:%u";
        goto LABEL_125;
      }
      v76 = a2 + 10162;
      if (!os_log_type_enabled(v89, OS_LOG_TYPE_DEBUG))
        goto LABEL_127;
      *(_DWORD *)buf = 136316162;
      *(_QWORD *)&buf[4] = v206;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "_VideoReceiver_ProcessProbingSequence";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 2751;
      *(_WORD *)&buf[28] = 2048;
      *(_QWORD *)&buf[30] = a2;
      *(_WORD *)&buf[38] = 1024;
      *(_DWORD *)&buf[40] = v207;
      v86 = "VideoReceiver [%s] %s:%d VideoReceiver[%p] Receiving a packet that is not a probing sequence, streamID:%u";
    }
    v87 = v83;
    v88 = 44;
LABEL_139:
    _os_log_debug_impl(&dword_1D8A54000, v87, OS_LOG_TYPE_DEBUG, v86, buf, v88);
    goto LABEL_127;
  }
LABEL_142:
  ++a2[10238];
  v93 = (_DWORD *)*((_QWORD *)a2 + 146);
  if (v93)
  {
    v94 = *(_DWORD *)(a4 + 96);
    v95 = *((_QWORD *)a2 + 5192);
    *(_QWORD *)buf = v95;
    *(_DWORD *)&buf[8] = a2[10386];
    if ((_DWORD)v95)
    {
      if ((_DWORD)v95 == 1)
      {
        if (!v94)
          ++v93[60];
        ++v93[62];
        v93[64] += FECUtil_GetExpectedParityPacketCount((uint64_t)buf);
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VideoReceiver_ProcessVideoRTPInternal_cold_4();
      }
    }
    else if ((v209 & 1) == 0)
    {
      if (!v94)
        ++v93[60];
      ++v93[62];
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v96 = VRTraceErrorLogLevelToCSTR();
    v97 = *MEMORY[0x1E0CF2758];
    v98 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v98, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = v96;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VideoReceiver_UpdateWRMVideoPacketMetrics";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 1680;
        *(_WORD *)&buf[28] = 2048;
        *(_QWORD *)&buf[30] = a2;
        _os_log_impl(&dword_1D8A54000, v97, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Uninitialized wrmInfo: cannot update WRM video packet metrics!", buf, 0x26u);
      }
    }
    else if (os_log_type_enabled(v98, OS_LOG_TYPE_DEBUG))
    {
      _VideoReceiver_ProcessVideoRTPInternal_cold_3();
    }
  }
  v99 = v211;
  v100 = a2 + 10384;
  if ((v211 - 100) > 0x19)
    goto LABEL_169;
  v101 = 1 << (v211 - 100);
  if ((v101 & 0x3000400) == 0)
  {
    if ((v101 & 0x800001) != 0)
    {
      v21 = 0;
      v221 = 0;
      if ((v209 & 1) != 0)
        goto LABEL_177;
      v102 = (int *)((unint64_t)&v217 | 0xC);
      v103 = *((unsigned __int16 *)a2 + 581);
      if (v211 == 123)
      {
        v104 = RTPProcessH264FragmentationHeader(*(_QWORD *)(a4 + 168), *(_DWORD *)(a4 + 160), (int *)&v217 + 2, v102, (_WORD *)(a4 + 32), (_BYTE *)(a4 + 34), &v225, v103 > 1);
      }
      else
      {
        if (v211 != 100)
        {
          v21 = 0;
LABEL_177:
          VCBlockBuffer_Copy(a4 + 152, (uint64_t)&blockBufferOut);
          if ((v21 & 0x80000000) == 0)
            goto LABEL_178;
LABEL_170:
          VCBlockBuffer_Clear((uint64_t)&blockBufferOut);
          if ((int)VRTraceGetErrorLogLevelForModule() < 3)
            return v21;
          v105 = VRTraceErrorLogLevelToCSTR();
          v58 = *MEMORY[0x1E0CF2758];
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            return v21;
          *(_DWORD *)buf = 136316162;
          *(_QWORD *)&buf[4] = v105;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VideoReceiver_ProcessVideoRTPInternal";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 3248;
          *(_WORD *)&buf[28] = 2048;
          *(_QWORD *)&buf[30] = a2;
          *(_WORD *)&buf[38] = 1024;
          *(_DWORD *)&buf[40] = v21;
          v31 = "VideoReceiver [%s] %s:%d VideoReceiver[%p] UNEXPECTED hResult:%d";
LABEL_173:
          v32 = v58;
          v33 = 44;
          goto LABEL_193;
        }
        v104 = RTPProcessHEVCFragmentationHeader(*(unsigned __int8 **)(a4 + 168), *(_DWORD *)(a4 + 160), (unsigned int *)&v217 + 2, v102, (_WORD *)(a4 + 32), (_BYTE *)(a4 + 34), v103 > 1, &v225);
      }
      v21 = v104;
      goto LABEL_177;
    }
LABEL_169:
    v21 = RTPProcessH263Packet(a4 + 8, (int *)&v217, (int *)&v217 + 1, (_BYTE *)&v221 + 1, &v221, *((CFAllocatorRef *)a2 + 5186), &blockBufferOut);
    DWORD2(v217) = (HIBYTE(v221) >> 1) & 1;
    HIDWORD(v217) = HIBYTE(v221) & 1;
    if ((v21 & 0x80000000) == 0)
      goto LABEL_178;
    goto LABEL_170;
  }
  v221 = 0;
  *((_QWORD *)&v217 + 1) = 0x100000001;
  VCBlockBuffer_Copy(a4 + 152, (uint64_t)&blockBufferOut);
LABEL_178:
  v106 = a2 + 10162;
  if (*((_BYTE *)a2 + 41160))
  {
    if (*((_QWORD *)a2 + 5146))
    {
      *(_QWORD *)&v107 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v107 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)&buf[284] = v107;
      *(_OWORD *)&buf[257] = v107;
      *(_OWORD *)&buf[273] = v107;
      *(_OWORD *)&buf[241] = v107;
      *(_OWORD *)&buf[225] = v107;
      *(_OWORD *)&buf[209] = v107;
      *(_OWORD *)&buf[193] = v107;
      *(_OWORD *)&buf[177] = v107;
      *(_OWORD *)&buf[161] = v107;
      *(_OWORD *)&buf[145] = v107;
      *(_OWORD *)&buf[129] = v107;
      *(_OWORD *)&buf[113] = v107;
      *(_OWORD *)&buf[97] = v107;
      *(_OWORD *)&buf[81] = v107;
      *(_OWORD *)&buf[65] = v107;
      *(_OWORD *)&buf[49] = v107;
      *(_OWORD *)&buf[33] = v107;
      *(_OWORD *)&buf[17] = v107;
      *(_OWORD *)&buf[1] = v107;
      LODWORD(__dst[6]) = -1431655766;
      __dst[5] = v107;
      __dst[4] = v107;
      __dst[3] = v107;
      __dst[2] = v107;
      __dst[1] = v107;
      __dst[0] = v107;
      buf[0] = 0;
      v108 = micro();
      fprintf(*((FILE **)a2 + 5146), "[%.6f:%04X:%08X:%d:%08X]\n", v108, v213, v8, v223, DWORD1(v229));
      if (v223)
      {
        for (i = 0; i < v223; ++i)
        {
          __sprintf_chk((char *)__dst, 0, 0x64uLL, " %02X", *(unsigned __int8 *)(v224 + i));
          __strlcat_chk();
          if ((~(_BYTE)i & 0x1F) == 0)
          {
            fprintf(*((FILE **)a2 + 5146), "%s\n", (const char *)buf);
            buf[0] = 0;
          }
        }
        v149 = (i & 0x1F) == 0;
        v20 = a3;
        v100 = a2 + 10384;
        v99 = v211;
        if (!v149)
          fprintf(*((FILE **)a2 + 5146), "%s\n", (const char *)buf);
      }
    }
  }
  if (!v223)
  {
    v21 = 2149515265;
    VCBlockBuffer_Clear((uint64_t)&blockBufferOut);
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      return v21;
    v111 = VRTraceErrorLogLevelToCSTR();
    v112 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      return v21;
    *(_DWORD *)buf = 136316674;
    *(_QWORD *)&buf[4] = v111;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = "_VideoReceiver_ProcessVideoRTPInternal";
    *(_WORD *)&buf[22] = 1024;
    *(_DWORD *)&buf[24] = 3259;
    *(_WORD *)&buf[28] = 2048;
    *(_QWORD *)&buf[30] = a2;
    *(_WORD *)&buf[38] = 1024;
    *(_DWORD *)&buf[40] = v213;
    *(_WORD *)&buf[44] = 1024;
    *(_DWORD *)&buf[46] = v8;
    *(_WORD *)&buf[50] = 1024;
    *(_DWORD *)&buf[52] = v99;
    v31 = "VideoReceiver [%s] %s:%d VideoReceiver[%p] UNEXPECTED: Received 0-length pkt seq: %d ts: %d payload: %d ";
    v32 = v112;
    v33 = 56;
    goto LABEL_193;
  }
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 10130));
  v110 = *(_DWORD *)(v220 + 112);
  a2[10166] += v110;
  if (v209)
    a2[10167] += v110;
  else
    a2[10169] += *(_DWORD *)(v218 + 8);
  pthread_mutex_unlock((pthread_mutex_t *)(a2 + 10130));
  *((_BYTE *)v100 + 96) = _VideoReceiver_HandleStreamSwitch((uint64_t)a2, v20, v113, v114, v115, v116, v117, v118);
  if (!*((_BYTE *)v20 + 120))
  {
    *((_DWORD *)v20 + 34) = *(_DWORD *)(a4 + 28);
    if (!*((_QWORD *)v20 + 14))
    {
      if (!*((_BYTE *)v20 + 70) || (v119 = v20[2], *v20 == v119))
      {
        memset(buf, 0, 352);
        *(_WORD *)buf = *(_WORD *)(a4 + 20);
        v120 = a2[259];
        *(_DWORD *)&buf[4] = *(_DWORD *)(a4 + 24);
        *(_DWORD *)&buf[8] = v120;
        if (*((_BYTE *)v20 + 69))
          v121 = *((_QWORD *)v100 + 16);
        else
          v121 = 0;
        *(_QWORD *)&buf[16] = v121;
        *(_DWORD *)&buf[224] = a2[266];
        buf[228] = a2[10312] != 0;
        buf[229] = *((_BYTE *)a2 + 1208);
        buf[240] = *((unsigned __int16 *)a2 + 581) > 1u;
        if (buf[240])
          v131 = 0;
        else
          v131 = *((_BYTE *)a2 + 1253) != 0;
        buf[241] = v131;
        if (*((_QWORD *)v20 + 534))
          v132 = _VideoReceiver_DecryptFrame;
        else
          v132 = 0;
        *(_QWORD *)&buf[248] = v20;
        *(_QWORD *)&buf[256] = v132;
        if (*((_BYTE *)a2 + 1180))
          v133 = _VideoReceiver_EnqueueFailedFrameToJitterBuffer;
        else
          v133 = 0;
        *(_QWORD *)&buf[264] = a2;
        *(_QWORD *)&buf[272] = v133;
        v134 = *((unsigned __int8 *)a2 + 1260);
        buf[280] = *((_BYTE *)a2 + 1260);
        *(_QWORD *)&buf[288] = *((_QWORD *)v100 + 11);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v135 = VRTraceErrorLogLevelToCSTR();
          v136 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v137 = FourccToCStr(a2[312]);
            LODWORD(__dst[0]) = 136316418;
            *(_QWORD *)((char *)__dst + 4) = v135;
            WORD6(__dst[0]) = 2080;
            *(_QWORD *)((char *)__dst + 14) = "_VideoReceiver_NewVideoPacketBufferConfig";
            WORD3(__dst[1]) = 1024;
            DWORD2(__dst[1]) = 3049;
            WORD6(__dst[1]) = 2048;
            *(_QWORD *)((char *)&__dst[1] + 14) = a2;
            WORD3(__dst[2]) = 1024;
            DWORD2(__dst[2]) = v134;
            WORD6(__dst[2]) = 2080;
            *(_QWORD *)((char *)&__dst[2] + 14) = v137;
            _os_log_impl(&dword_1D8A54000, v136, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d [%p] isServerPacketRetransmissionEnabled=%d streamGroupID=%s", (uint8_t *)__dst, 0x36u);
          }
        }
        _VCVideoReceiver_InitDumpFileName((uint64_t)a2, (char *)&buf[24]);
        *((_QWORD *)v20 + 14) = VideoPacketBuffer_Create(buf);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v138 = VRTraceErrorLogLevelToCSTR();
          v139 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v140 = *((_QWORD *)v20 + 14);
            v141 = *v20;
            v142 = *((unsigned __int8 *)v20 + 70);
            v143 = v20[2] == v141;
            LODWORD(__dst[0]) = 136316930;
            *(_QWORD *)((char *)__dst + 4) = v138;
            WORD6(__dst[0]) = 2080;
            *(_QWORD *)((char *)__dst + 14) = "_VideoReceiver_CreateVPB";
            WORD3(__dst[1]) = 1024;
            DWORD2(__dst[1]) = 3072;
            WORD6(__dst[1]) = 2048;
            *(_QWORD *)((char *)&__dst[1] + 14) = a2;
            WORD3(__dst[2]) = 2048;
            *((_QWORD *)&__dst[2] + 1) = v140;
            LOWORD(__dst[3]) = 1024;
            *(_DWORD *)((char *)&__dst[3] + 2) = v141;
            WORD3(__dst[3]) = 1024;
            DWORD2(__dst[3]) = v142;
            WORD6(__dst[3]) = 1024;
            *(_DWORD *)((char *)&__dst[3] + 14) = v143;
            _os_log_impl(&dword_1D8A54000, v139, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] created VideoPacketBuffer[%p] for stream:%d, isTemporalScalingEnabled=%d, isBaseLayerStream=%d", (uint8_t *)__dst, 0x42u);
          }
        }
        *((_BYTE *)v20 + 120) = 1;
LABEL_224:
        v100 = a2 + 10384;
        goto LABEL_225;
      }
      Stream = _VideoReceiver_GetStream(a2, v119, *((unsigned __int8 *)v20 + 69));
      if (Stream)
      {
        v123 = Stream;
        v124 = *((_QWORD *)Stream + 14);
        if (v124)
        {
          *((_QWORD *)v20 + 14) = v124;
          v125 = v20;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v126 = VRTraceErrorLogLevelToCSTR();
            v127 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              v128 = *v125;
              v129 = *((_QWORD *)v125 + 14);
              v130 = *(unsigned __int16 *)v123;
              *(_DWORD *)buf = 136316674;
              *(_QWORD *)&buf[4] = v126;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_VideoReceiver_CreateVPB";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 3066;
              *(_WORD *)&buf[28] = 2048;
              *(_QWORD *)&buf[30] = a2;
              *(_WORD *)&buf[38] = 1024;
              *(_DWORD *)&buf[40] = v128;
              *(_WORD *)&buf[44] = 2048;
              *(_QWORD *)&buf[46] = v129;
              *(_WORD *)&buf[54] = 1024;
              *(_DWORD *)&buf[56] = v130;
              _os_log_impl(&dword_1D8A54000, v127, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Higher layer in temporal scaling group with streamID %d, uses base layer's VPB[%p]. Base Layer streamID is %d", buf, 0x3Cu);
            }
          }
          *((_BYTE *)v125 + 120) = 1;
          v20 = v125;
          goto LABEL_224;
        }
        v100 = a2 + 10384;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VideoReceiver_ProcessVideoRTPInternal_cold_2();
        }
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VideoReceiver_ProcessVideoRTPInternal_cold_1();
      }
    }
  }
LABEL_225:
  v144 = v20[2] == *v20;
  VideoPacketDump_RTPLog(*((_QWORD *)a2 + 5154));
  VideoPacketBuffer_AddPacket(*((_QWORD *)v20 + 14), (int *)&v217, *((unsigned __int8 *)v20 + 70), v144, *((_BYTE *)v100 + 96), *((double *)v100 + 7));
  VCBlockBuffer_Clear((uint64_t)&blockBufferOut);
  if (!*((_BYTE *)a2 + 1209) && *(_BYTE *)(a4 + 49))
  {
    if (*((unsigned __int16 *)a2 + 581) < 2u)
    {
      _VideoReceiver_ScheduleFramesForVideoPacketBuffer(a1, (uint64_t)a2, *((_QWORD *)v20 + 14), v8, (uint64_t)v20);
    }
    else
    {
      BYTE4(v216) = 0;
      LOWORD(v235[0]) = 0;
      LODWORD(__dst[0]) = 0;
      VideoPacketBuffer_GetFrameDecodingOrder(*((_QWORD *)v20 + 14), (_BYTE *)&v216 + 4, v235, __dst);
      if (BYTE4(v216))
      {
        if (*((_BYTE *)a2 + 41500))
        {
          v145 = LOWORD(v235[0]) - *((unsigned __int16 *)a2 + 20751);
          if (v145)
          {
            if ((unsigned __int16)v145 <= 0x7FFEu && a2[10172] - LODWORD(__dst[0]) <= 0x7FFFFFFE)
            {
              v146 = *a2;
              if ((_DWORD)v146)
              {
                v147 = 0;
                v148 = a2 + 364;
                do
                {
                  if (v148 != (unsigned int *)v20)
                  {
                    LOBYTE(v216) = 0;
                    LOWORD(v227) = 0;
                    *(_DWORD *)buf = 0;
                    VideoPacketBuffer_GetFrameDecodingOrder(*((_QWORD *)v148 + 14), &v216, &v227, buf);
                    if ((_BYTE)v216)
                      v149 = BYTE4(v216) == 0;
                    else
                      v149 = 1;
                    if (!v149)
                    {
                      v150 = LOWORD(v235[0]) - LOWORD(v227);
                      if (v150)
                      {
                        if ((unsigned __int16)v150 <= 0x7FFEu)
                          goto LABEL_252;
                      }
                    }
                    v146 = *a2;
                  }
                  ++v147;
                  v148 += 1080;
                }
                while (v147 < v146);
              }
              if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
              {
                v151 = VRTraceErrorLogLevelToCSTR();
                v152 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                {
                  v153 = *((_QWORD *)v20 + 14);
                  v154 = *((unsigned __int16 *)a2 + 20751);
                  v155 = *((unsigned __int8 *)a2 + 41500);
                  *(_DWORD *)buf = 136316930;
                  *(_QWORD *)&buf[4] = v151;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = "_VideoReceiver_DetectFullSubFrameLoss";
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&buf[24] = 2872;
                  *(_WORD *)&buf[28] = 2048;
                  *(_QWORD *)&buf[30] = a2;
                  *(_WORD *)&buf[38] = 2048;
                  *(_QWORD *)&buf[40] = v153;
                  *(_WORD *)&buf[48] = 1024;
                  *(_DWORD *)&buf[50] = LOWORD(v235[0]);
                  *(_WORD *)&buf[54] = 1024;
                  *(_DWORD *)&buf[56] = v154;
                  *(_WORD *)&buf[60] = 1024;
                  *(_DWORD *)&buf[62] = v155;
                  _os_log_impl(&dword_1D8A54000, v152, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] VideoPacketBuffer[%p] Needs refresh and reset DON due to sub frame loss in frameDecodingOrder:%hu expectedDecodingOrder:%hu isExpectedDecodingOrderValid:%d", buf, 0x42u);
                }
              }
              if (*((_BYTE *)a2 + 1183))
                v156 = a2[10201] != 0;
              else
                v156 = 0;
              v157 = micro();
              _VideoReceiver_DecoderNeedsRefresh((uint64_t)a2, (uint64_t)v20, v156, 23, v157);
            }
          }
        }
      }
LABEL_252:
      LODWORD(v158) = *a2;
      v159 = (int)(exp2((double)*a2) + -1.0);
      while (v159)
      {
        if ((_DWORD)v158)
        {
          v160 = 0;
          v161 = (uint64_t)(a2 + 364);
          do
          {
            if (_VideoReceiver_ScheduleFramesForVideoPacketBuffer(a1, (uint64_t)a2, *(_QWORD *)(v161 + 112), v8, v161))v159 |= 1 << v160;
            else
              v159 &= ~(1 << v160);
            ++v160;
            v158 = *a2;
            v161 += 4320;
          }
          while (v160 < v158);
        }
      }
    }
    v20 = a3;
    v106 = a2 + 10162;
    v162 = v10 - *((double *)a2 + 5091);
    memset(buf, 0, 168);
    _VideoReceiver_SendRTCP((uint64_t)a2, (uint64_t)a3, (__int128 *)buf, v162 > 5.0, v10);
    v100 = a2 + 10384;
  }
  v163 = *((_QWORD *)v100 + 5);
  if (v163 && *((_BYTE *)v106 + 793))
  {
    LODWORD(__dst[0]) = 0;
    if (!VCMediaStreamSynchronizer_sourceRTPTimestampFromDestinationRTPTimestamp(v163, v8, __dst))
    {
      *(_OWORD *)buf = *MEMORY[0x1E0CA2E68];
      *(_QWORD *)&buf[16] = *(_QWORD *)(MEMORY[0x1E0CA2E68] + 16);
      _VideoReceiver_CallAlarms((uint64_t)a2, (int *)buf, v10);
      goto LABEL_274;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v164 = VRTraceErrorLogLevelToCSTR();
      v165 = *MEMORY[0x1E0CF2758];
      v166 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v166, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316162;
          *(_QWORD *)&buf[4] = v164;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VideoReceiver_ProcessVideoRTPInternal";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 3305;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = v8;
          *(_WORD *)&buf[34] = 1024;
          *(_DWORD *)&buf[36] = __dst[0];
          _os_log_impl(&dword_1D8A54000, v165, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d Converted video dwTimestamp=%u into audio domain with timestamp=%u", buf, 0x28u);
        }
      }
      else if (os_log_type_enabled(v166, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)&buf[4] = v164;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VideoReceiver_ProcessVideoRTPInternal";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 3305;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v8;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = __dst[0];
        _os_log_debug_impl(&dword_1D8A54000, v165, OS_LOG_TYPE_DEBUG, "VideoReceiver [%s] %s:%d Converted video dwTimestamp=%u into audio domain with timestamp=%u", buf, 0x28u);
      }
    }
    v168 = LODWORD(__dst[0]);
    v167 = (uint64_t)a2;
  }
  else
  {
    v167 = (uint64_t)a2;
    v168 = v8;
  }
  _VideoReceiver_ProcessInternalCallAlarms(v167, v168, v10);
LABEL_274:
  if (*((_BYTE *)a2 + 1276))
  {
    v169 = *((double *)v20 + 536);
    if (v169 != 0.0)
    {
      v170 = *((double *)v106 + 35);
      v171 = v10 - v169;
      if (v170 == 0.0 || v171 > 0.15 && *((double *)v106 + 59) != 0.0)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          v172 = VRTraceErrorLogLevelToCSTR();
          v173 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v174 = *((_QWORD *)v20 + 14);
            v175 = *((_QWORD *)v100 + 7);
            *(_DWORD *)buf = 136317186;
            *(_QWORD *)&buf[4] = v172;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VideoReceiver_ShallSendCachedDelayedFIR";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 1584;
            *(_WORD *)&buf[28] = 2048;
            *(_QWORD *)&buf[30] = a2;
            *(_WORD *)&buf[38] = 2048;
            *(_QWORD *)&buf[40] = v174;
            *(_WORD *)&buf[48] = 2048;
            *(double *)&buf[50] = v171;
            *(_WORD *)&buf[58] = 2048;
            *(_QWORD *)&buf[60] = 0x3FC3333333333333;
            *(_WORD *)&buf[68] = 2048;
            *(_QWORD *)&buf[70] = v175;
            *(_WORD *)&buf[78] = 1024;
            *(_DWORD *)&buf[80] = v170 == 0.0;
            _os_log_impl(&dword_1D8A54000, v173, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] VideoPacketBuffer[%p] Sending Delayed FIR timeSinceFIRRequest=%2.4f waitFIRTime=%2.4f roundTripTime=%2.4f noFramesDisplayed=%d", buf, 0x54u);
          }
        }
        _VideoReceiver_SendFIR((uint64_t)a2, (uint64_t)v20, *((unsigned __int8 *)v20 + 4280), *((_DWORD *)v20 + 1071), *((double *)v20 + 536));
        *((_QWORD *)v20 + 536) = 0;
      }
    }
  }
  if (*((_QWORD *)v100 + 15))
  {
    *(_QWORD *)&__dst[0] = 0;
    v235[0] = 0.0;
    v227 = 0.0;
    VideoReceiver_GetBitrate(1.0, a1, (uint64_t)__dst, v235, &v227, 0, 0);
    memset(buf, 0, 32);
    VCVideoPlayer_GetVideoPlayerStatsForJB(*((_QWORD *)a2 + 5054), (uint64_t)buf);
    v176 = (v227 / 1000.0 + 0.5);
    v177 = *((_QWORD *)v100 + 15);
    v178 = *(_QWORD *)(v177 + 40);
    v179 = (unsigned __int16 *)*((_QWORD *)a2 + 5045);
    if (v179)
      v180 = *v179;
    else
      v180 = *(_DWORD *)(v178 + 24);
    v181 = 0.0;
    v182 = 0.0;
    if (*((_WORD *)v106 + 146))
    {
      LOWORD(v182) = *((_WORD *)v106 + 145);
      v182 = (float)LODWORD(v182) / (float)*((unsigned __int16 *)v106 + 146);
    }
    v183 = *((double *)v106 + 52) / 1000.0 + 0.5;
    v184 = *(double *)__dst / 1000.0 + 0.5;
    v185 = (v235[0] / 1000.0 + 0.5);
    if (v182 == 0.0)
      v186 = *(float *)(v178 + 128);
    else
      v186 = v182;
    v187 = v100;
    v188 = v100[28];
    TotalPLR = _VideoReceiver_GetTotalPLR(a2);
    v190 = *((double *)v106 + 51);
    v191 = v190;
    if (v176)
      v181 = (float)(v185 / v176);
    v192 = (int)TotalPLR;
    v193 = *((double *)v106 + 50);
    v194 = v106[116];
    v195 = *((double *)v106 + 55) * 1000.0;
    v196 = *((double *)v106 + 12) * 1000.0;
    v197 = *((_BYTE *)a2 + 1181);
    v198 = v187[5] - v187[6];
    v199 = v106[85];
    v200 = *(_QWORD *)&buf[8];
    v201 = v106[197];
    if (v201)
      v202 = *((double *)v106 + 17) / (double)v201 * 1000.0;
    else
      v202 = 0.0;
    *(_DWORD *)(v178 + 24) = v180;
    *(_DWORD *)(v178 + 28) = v188;
    *(_DWORD *)(v178 + 92) = v184;
    *(_DWORD *)(v178 + 96) = v176;
    *(_DWORD *)(v178 + 100) = v185;
    *(float *)(v178 + 104) = v181;
    *(_DWORD *)(v178 + 108) = v192;
    *(float *)(v178 + 120) = v191;
    *(float *)(v178 + 124) = v193;
    *(float *)(v178 + 128) = v186;
    *(_DWORD *)(v178 + 152) = v183;
    *(float *)(v178 + 156) = v195;
    *(_DWORD *)(v178 + 160) = v194;
    *(float *)(v178 + 164) = v196;
    *(_BYTE *)(v178 + 168) = v197;
    *(float *)(v178 + 172) = v202;
    *(_DWORD *)(v178 + 176) = v198;
    *(_DWORD *)(v178 + 188) = v199;
    *(_QWORD *)(v178 + 192) = v200;
    VCOverlaySource_Write(v177);
  }
  return 0;
}

uint64_t _VideoReceiver_ShouldProcessPacket(uint64_t a1, uint64_t a2, int a3, uint64_t a4, unsigned __int16 *a5, unsigned int a6)
{
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  _BOOL4 v15;
  _BOOL4 v17;
  uint64_t v19;
  NSObject *v20;
  _BOOL4 v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  uint64_t v30;
  __int16 v31;
  uint64_t v32;
  __int16 v33;
  uint64_t v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 1209) || *(_BYTE *)(a2 + 69))
    return 1;
  if (!a3 || *(_QWORD *)(a1 + 1152) == a4)
  {
    if (a6)
    {
      v9 = *(_QWORD *)(a1 + 40336);
      v10 = *(_QWORD *)(a1 + 40344);
      v11 = a6 - 1;
      while (1)
      {
        v12 = v11;
        v14 = *a5++;
        v13 = v14;
        if ((v9 & 0x1000000000000) != 0)
        {
          v15 = v13 == (unsigned __int16)v9 || WORD1(v9) == v13;
          if ((v10 & 0x1000000000000) != 0)
          {
LABEL_11:
            v17 = v13 == (unsigned __int16)v10 || WORD1(v10) == v13;
            goto LABEL_25;
          }
        }
        else
        {
          v15 = 0;
          if ((v10 & 0x1000000000000) != 0)
            goto LABEL_11;
        }
        v17 = 0;
LABEL_25:
        result = v15 | v17;
        if (!v15 && !v17)
        {
          v11 = v12 - 1;
          if (v12)
            continue;
        }
        return result;
      }
    }
    return 0;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() < 5)
    return 0;
  v19 = VRTraceErrorLogLevelToCSTR();
  v20 = *MEMORY[0x1E0CF2758];
  v21 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
  result = 0;
  if (v21)
  {
    v22 = *(_QWORD *)(a1 + 1152);
    v23 = 136316418;
    v24 = v19;
    v25 = 2080;
    v26 = "_VideoReceiver_ShouldProcessPacket";
    v27 = 1024;
    v28 = 2826;
    v29 = 2048;
    v30 = a1;
    v31 = 2048;
    v32 = a4;
    v33 = 2048;
    v34 = v22;
    _os_log_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Unexpected idsParticipantID=%llu, expected=%llu", (uint8_t *)&v23, 0x3Au);
    return 0;
  }
  return result;
}

uint64_t _VideoReceiver_ProcessInternalCallAlarms(uint64_t result, int64_t value, double a3)
{
  uint64_t v3;
  unsigned int v5;
  os_unfair_lock_s *v6;
  double v7;
  unint64_t v8;
  double v9;
  int32_t os_unfair_lock_opaque;
  int64_t v11;
  CMTime v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v3 = result + 40680;
  if (*(_BYTE *)(result + 41441))
  {
    v5 = value;
    v6 = (os_unfair_lock_s *)result;
    v12 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E68];
    if (*(_BYTE *)(result + 41696))
    {
      os_unfair_lock_lock((os_unfair_lock_t)(result + 41692));
      v7 = *(double *)(v3 + 768);
      if (v7 == 0.0)
      {
        v8 = v5;
        *(double *)(v3 + 768) = a3;
        *(_QWORD *)v3 = v5;
        v7 = a3;
      }
      else
      {
        v8 = *(_QWORD *)v3;
      }
      CMTimeMake(&v12, (unint64_t)((double)v8 + (a3 - v7) * (double)(int)v6[258]._os_unfair_lock_opaque), v6[258]._os_unfair_lock_opaque);
      os_unfair_lock_unlock(v6 + 10423);
    }
    else
    {
      v9 = *(double *)(result + 41448);
      if (v9 == 0.0)
      {
        v11 = value;
        *(double *)(v3 + 768) = a3;
        *(_QWORD *)v3 = value;
        os_unfair_lock_opaque = v6[258]._os_unfair_lock_opaque;
      }
      else
      {
        os_unfair_lock_opaque = *(_DWORD *)(result + 1032);
        v11 = (unint64_t)((double)*(unint64_t *)v3 + (a3 - v9) * (double)os_unfair_lock_opaque);
      }
      CMTimeMake(&v12, v11, os_unfair_lock_opaque);
    }
    return _VideoReceiver_CallAlarms((uint64_t)v6, (int *)&v12, a3);
  }
  return result;
}

void _VideoReceiver_EnqueueFailedFrameToJitterBuffer(uint64_t a1, uint64_t a2, double a3)
{
  if (a1)
  {
    if (*(_BYTE *)(a1 + 1180) && *(_QWORD *)(a1 + 41520) && !*(_BYTE *)(a2 + 18))
    {
      *(double *)(a2 + 64) = _VideoReceiver_GetVideoFrameTimeInSeconds(a1, *(_DWORD *)(a2 + 8), a3);
      _VideoReceiver_EnqueueFrameToJitterBuffer(a1, a2);
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VideoReceiver_EnqueueFailedFrameToJitterBuffer_cold_1();
  }
}

double _VideoReceiver_GetVideoFrameTimeInSeconds(uint64_t a1, unsigned int a2, double a3)
{
  _DWORD *v5;
  uint64_t v6;
  double v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  const char *v11;
  uint64_t v12;
  NSObject *v13;
  const char *v14;
  int v16;
  uint64_t v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  double v25;
  __int16 v26;
  unsigned int v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v5 = (_DWORD *)(a1 + 40696);
  v6 = *(_QWORD *)(a1 + 41576);
  if (v6)
  {
    v7 = VCMediaStreamSynchronizer_scheduleTimeForDestinationRTPTimestamp(v6, a2);
    if ((int)VRTraceGetErrorLogLevelForModule() < 8)
      return v7;
    v8 = VRTraceErrorLogLevelToCSTR();
    v9 = *MEMORY[0x1E0CF2758];
    v10 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        v16 = 136316418;
        v17 = v8;
        v18 = 2080;
        v19 = "_VideoReceiver_GetVideoFrameTimeInSeconds";
        v20 = 1024;
        v21 = 2600;
        v22 = 2048;
        v23 = a1;
        v24 = 2048;
        v25 = v7;
        v26 = 1024;
        v27 = a2;
        v11 = "VideoReceiver [%s] %s:%d VideoReceiver[%p] videoFrameTimeInSeconds=%.6f from VCMediaStreamSynchronizer for"
              " RTPTimestamp=%u";
LABEL_10:
        _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, v11, (uint8_t *)&v16, 0x36u);
        return v7;
      }
      return v7;
    }
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      return v7;
    v16 = 136316418;
    v17 = v8;
    v18 = 2080;
    v19 = "_VideoReceiver_GetVideoFrameTimeInSeconds";
    v20 = 1024;
    v21 = 2600;
    v22 = 2048;
    v23 = a1;
    v24 = 2048;
    v25 = v7;
    v26 = 1024;
    v27 = a2;
    v14 = "VideoReceiver [%s] %s:%d VideoReceiver[%p] videoFrameTimeInSeconds=%.6f from VCMediaStreamSynchronizer for RTPTimestamp=%u";
LABEL_16:
    _os_log_debug_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEBUG, v14, (uint8_t *)&v16, 0x36u);
    return v7;
  }
  LODWORD(a3) = *v5;
  v7 = ((double)a2 + (double)*(unint64_t *)&a3 * 4294967300.0) / (double)*(int *)(a1 + 1036);
  if ((int)VRTraceGetErrorLogLevelForModule() < 8)
    return v7;
  v12 = VRTraceErrorLogLevelToCSTR();
  v9 = *MEMORY[0x1E0CF2758];
  v13 = *MEMORY[0x1E0CF2758];
  if (!*MEMORY[0x1E0CF2748])
  {
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      return v7;
    v16 = 136316418;
    v17 = v12;
    v18 = 2080;
    v19 = "_VideoReceiver_GetVideoFrameTimeInSeconds";
    v20 = 1024;
    v21 = 2603;
    v22 = 2048;
    v23 = a1;
    v24 = 2048;
    v25 = v7;
    v26 = 1024;
    v27 = a2;
    v14 = "VideoReceiver [%s] %s:%d VideoReceiver[%p] videoFrameTimeInSeconds=%.6f for RTPTimestamp=%u";
    goto LABEL_16;
  }
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v16 = 136316418;
    v17 = v12;
    v18 = 2080;
    v19 = "_VideoReceiver_GetVideoFrameTimeInSeconds";
    v20 = 1024;
    v21 = 2603;
    v22 = 2048;
    v23 = a1;
    v24 = 2048;
    v25 = v7;
    v26 = 1024;
    v27 = a2;
    v11 = "VideoReceiver [%s] %s:%d VideoReceiver[%p] videoFrameTimeInSeconds=%.6f for RTPTimestamp=%u";
    goto LABEL_10;
  }
  return v7;
}

void _VideoReceiver_EnqueueFrameToJitterBuffer(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  __int128 v21;
  __int128 v22;
  _BYTE buf[34];
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  __int16 v28;
  int v29;
  __int16 v30;
  int v31;
  __int16 v32;
  int v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (*(double *)(a2 + 48) == 0.0)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VideoReceiver_EnqueueFrameToJitterBuffer_cold_1();
      }
    }
    else
    {
      v3 = a1 + 40432;
      if (*(_BYTE *)(a2 + 75))
      {
        ++*(_DWORD *)(a1 + 41556);
        *(_WORD *)(a1 + 41550) = *(_WORD *)(a2 + 40);
      }
      v21 = 0u;
      v22 = 0u;
      VCVideoPlayer_GetVideoPlayerStatsForJB(*(_QWORD *)v3, (uint64_t)&v21);
      *((_QWORD *)&v21 + 1) = *(_QWORD *)(v3 + 280);
      v4 = *(_DWORD *)(v3 + 1124);
      WORD1(v21) = v4 - *(_WORD *)(v3 + 1132);
      *(_DWORD *)(v3 + 1132) = v4;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v5 = VRTraceErrorLogLevelToCSTR();
        v6 = *MEMORY[0x1E0CF2758];
        v7 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
          {
            v8 = *(unsigned __int16 *)(a2 + 16);
            v9 = *(unsigned __int16 *)(a2 + 36);
            v10 = *(unsigned __int8 *)(a2 + 39);
            v11 = *(unsigned __int16 *)(a2 + 40);
            v12 = *(_DWORD *)(a2 + 8);
            v13 = *(unsigned __int8 *)(a2 + 75);
            *(_DWORD *)buf = 136317186;
            *(_QWORD *)&buf[4] = v5;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VideoReceiver_EnqueueFrameToJitterBuffer";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 2211;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = v8;
            v24 = 1024;
            v25 = v9;
            v26 = 1024;
            v27 = v10;
            v28 = 1024;
            v29 = v11;
            v30 = 1024;
            v31 = v12;
            v32 = 1024;
            v33 = v13;
            _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d Sending frame to video jitter buffer with DON=%u tileIndex=%u for isFrameSequenceNumberValid=%d FrameSequenceNumber=%u rtpTimeStamp=%u isFailedCompleteFrame=%d", buf, 0x40u);
          }
        }
        else if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
        {
          v15 = *(unsigned __int16 *)(a2 + 16);
          v16 = *(unsigned __int16 *)(a2 + 36);
          v17 = *(unsigned __int8 *)(a2 + 39);
          v18 = *(unsigned __int16 *)(a2 + 40);
          v19 = *(_DWORD *)(a2 + 8);
          v20 = *(unsigned __int8 *)(a2 + 75);
          *(_DWORD *)buf = 136317186;
          *(_QWORD *)&buf[4] = v5;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VideoReceiver_EnqueueFrameToJitterBuffer";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 2211;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = v15;
          v24 = 1024;
          v25 = v16;
          v26 = 1024;
          v27 = v17;
          v28 = 1024;
          v29 = v18;
          v30 = 1024;
          v31 = v19;
          v32 = 1024;
          v33 = v20;
          _os_log_debug_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEBUG, "VideoReceiver [%s] %s:%d Sending frame to video jitter buffer with DON=%u tileIndex=%u for isFrameSequenceNumberValid=%d FrameSequenceNumber=%u rtpTimeStamp=%u isFailedCompleteFrame=%d", buf, 0x40u);
        }
      }
      v14 = *(_QWORD *)(v3 + 1088);
      *(_OWORD *)buf = v21;
      *(_OWORD *)&buf[16] = v22;
      VCVideoJitterBuffer_EnqueueFrame(v14, a2, (__int128 *)buf);
    }
  }
}

uint64_t _VideoReceiver_ScheduleFramesForVideoPacketBuffer(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  char v12;
  unsigned int v13;
  unsigned int v14;
  char v15;
  unsigned int v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v10 = a2 + 40688;
  v17 = -1431655766;
  v11 = VideoPacketBuffer_SchedulePastIncompleteFrame(a3, a4, &v17, *(_DWORD *)(a2 + 40688), *(unsigned __int8 *)(a2 + 41500), *(unsigned __int16 *)(a2 + 41502));
  if ((_DWORD)v11)
  {
    v12 = 0;
    v13 = 0;
    do
    {
      v14 = v17;
      if ((v12 & 1) != 0 && v13 == v17)
        break;
      _VideoReceiver_AssembleAndEnqueueFrame(a1, a2, (unsigned __int16 *)a5, v17);
      v15 = VideoPacketBuffer_SchedulePastIncompleteFrame(a3, a4, &v17, *(_DWORD *)v10, *(unsigned __int8 *)(v10 + 812), *(unsigned __int16 *)(v10 + 814));
      v12 = 1;
      v13 = v14;
    }
    while ((v15 & 1) != 0);
  }
  if (VideoPacketBuffer_ScheduleFutureFrame(a3, *(_DWORD *)(a5 + 136), a4, &v17, *(_DWORD *)v10, *(unsigned __int8 *)(v10 + 812), *(unsigned __int16 *)(v10 + 814), *(double *)(v10 + 776)))
  {
    do
      _VideoReceiver_AssembleAndEnqueueFrame(a1, a2, (unsigned __int16 *)a5, v17);
    while (VideoPacketBuffer_ScheduleFutureFrame(a3, *(_DWORD *)(a5 + 136), a4, &v17, *(_DWORD *)v10, *(unsigned __int8 *)(v10 + 812), *(unsigned __int16 *)(v10 + 814), *(double *)(v10 + 776)));
    return 1;
  }
  return v11;
}

uint64_t _VideoReceiver_AssembleAndEnqueueFrame(uint64_t a1, uint64_t a2, unsigned __int16 *a3, unsigned int a4)
{
  uint64_t v6;
  unsigned int v7;
  BOOL v8;
  unsigned int v9;
  int ErrorLogLevelForModule;
  unsigned __int8 *v12;
  uint64_t v13;
  int v14;
  NSObject *v15;
  NSObject *v16;
  double VideoFrameTimeInSeconds;
  double v18;
  int NextFrame;
  _BOOL4 v21;
  int v22;
  uint64_t v23;
  NSObject *v24;
  uint64_t v25;
  uint64_t v26;
  __CFDictionary *ReportingEventDictionary;
  CFNumberRef v28;
  uint64_t v29;
  NSObject *v30;
  int v31;
  const __CFAllocator *v32;
  int v33;
  int v34;
  int v35;
  _BOOL4 v36;
  char *v37;
  int v38;
  int v39;
  int v40;
  uint64_t v41;
  NSObject *v42;
  int v43;
  uint64_t v44;
  NSObject *v45;
  int v46;
  int v47;
  int v48;
  uint64_t v49;
  NSObject *v50;
  int v51;
  int v52;
  int v53;
  uint64_t v54;
  NSObject *v55;
  int v56;
  int v57;
  int v58;
  NSObject *v59;
  const char *v60;
  uint32_t v61;
  uint64_t v62;
  NSObject *v63;
  uint64_t v64;
  NSObject *v65;
  int v66;
  int v67;
  int v68;
  uint64_t v69;
  NSObject *v70;
  int v71;
  int v72;
  BOOL v73;
  char v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  uint64_t v79;
  NSObject *v80;
  int v81;
  int v82;
  int v83;
  unsigned int v84;
  int v85;
  unsigned int v86;
  uint64_t v87;
  unsigned int v88;
  unsigned int v89;
  uint64_t v90;
  NSObject *v91;
  int v92;
  int v93;
  int v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  NSObject *v98;
  int v99;
  int v100;
  int v101;
  int v102;
  int v103;
  int v104;
  uint64_t v105;
  double *Head;
  unint64_t v107;
  unint64_t v108;
  double v109;
  double v110;
  int32_t Count;
  uint64_t v112;
  NSObject *v113;
  OSStatus v114;
  OSStatus v115;
  uint64_t v116;
  NSObject *v117;
  uint64_t v118;
  NSObject *v119;
  int v120;
  int v121;
  int v122;
  int v123;
  uint64_t v124;
  NSObject *v125;
  uint64_t v126;
  int v127;
  int v128;
  int v129;
  _BOOL4 v130;
  int v131;
  int v132;
  int v133;
  uint64_t v134;
  NSObject *v135;
  NSObject *v136;
  int v137;
  int v138;
  int v139;
  int v140;
  double v141;
  double TargetJitterQueueSize;
  double DoubleValueForKey;
  double v144;
  double v145;
  uint64_t v148;
  __int128 v150;
  __int128 v151;
  __int128 v152;
  __int128 v153;
  __int128 v154;
  __int128 v155;
  int v156;
  const __CFAllocator **element;
  int v158;
  int v159;
  int v160;
  int v161;
  int v162;
  uint8_t v163[4];
  uint64_t v164;
  __int16 v165;
  const char *v166;
  __int16 v167;
  int v168;
  __int16 v169;
  uint64_t v170;
  __int16 v171;
  int v172;
  __int16 v173;
  int v174;
  __int16 v175;
  int v176;
  __int16 v177;
  int v178;
  __int16 v179;
  _BYTE *v180;
  __int16 v181;
  _OWORD *v182;
  __int16 v183;
  int v184;
  __int16 v185;
  _BOOL4 v186;
  _OWORD v187[6];
  _BYTE buf[110];
  __int128 v189;
  __int128 v190;
  __int128 v191;
  __int128 v192;
  _BYTE v193[26];
  uint64_t v194;

  v194 = *MEMORY[0x1E0C80C00];
  v6 = a2 + 40656;
  v7 = *(_DWORD *)(a2 + 40692);
  v8 = a4 >= v7;
  v9 = a4 - v7;
  if (!v8 && v9 <= 0x7FFFFFFE)
    ++*(_DWORD *)(a2 + 40696);
  v148 = a2 + 40353;
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  v12 = (unsigned __int8 *)MEMORY[0x1E0CF2748];
  if (ErrorLogLevelForModule >= 8)
  {
    v13 = VRTraceErrorLogLevelToCSTR();
    v14 = *v12;
    v15 = *MEMORY[0x1E0CF2758];
    v16 = *MEMORY[0x1E0CF2758];
    if (v14)
    {
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)&buf[4] = v13;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VideoReceiver_AssembleAndEnqueueFrame";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 2612;
        *(_WORD *)&buf[28] = 2048;
        *(_QWORD *)&buf[30] = a2;
        *(_WORD *)&buf[38] = 1024;
        *(_DWORD *)&buf[40] = a4;
        _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Got frame with RTPTimestamp=%u", buf, 0x2Cu);
      }
    }
    else if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136316162;
      *(_QWORD *)&buf[4] = v13;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "_VideoReceiver_AssembleAndEnqueueFrame";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 2612;
      *(_WORD *)&buf[28] = 2048;
      *(_QWORD *)&buf[30] = a2;
      *(_WORD *)&buf[38] = 1024;
      *(_DWORD *)&buf[40] = a4;
      _os_log_debug_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEBUG, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Got frame with RTPTimestamp=%u", buf, 0x2Cu);
    }
  }
  *(_DWORD *)(v6 + 36) = a4;
  v154 = 0u;
  v155 = 0u;
  v152 = 0u;
  v153 = 0u;
  v150 = 0u;
  v151 = 0u;
  VideoFrameTimeInSeconds = _VideoReceiver_GetVideoFrameTimeInSeconds(a2, a4, 0.0);
  v161 = -1431655766;
  v160 = -1431655766;
  v159 = 0;
  v156 = 0;
  v158 = 1;
  while (1)
  {
    pthread_mutex_lock((pthread_mutex_t *)(a2 + 40584));
    v160 = 0;
    v18 = micro();
    v156 = 0;
    v161 = -1;
    element = 0;
    v162 = -1431655936;
    NextFrame = VideoPacketBuffer_GetNextFrame(*((_QWORD *)a3 + 14), a4, 0, &v161, &v158, &v156, &v160, &v159, &v162, &element, *(_WORD *)(a2 + 1162), (uint64_t)&v150);
    if ((char)v162 < 0)
      *(_BYTE *)(v6 + 712) = v162;
    if (v161 != -1)
    {
      v21 = v161 == 2 && *(_BYTE *)(a2 + 1183) != 0;
      v22 = v158;
      if (*(_BYTE *)(a2 + 1276))
      {
        *((_BYTE *)a3 + 4280) = v21;
        *((_DWORD *)a3 + 1071) = v22;
        if (*((double *)a3 + 536) == 0.0)
          *((double *)a3 + 536) = v18;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          v23 = VRTraceErrorLogLevelToCSTR();
          v24 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v25 = *((_QWORD *)a3 + 14);
            v26 = *((_QWORD *)a3 + 536);
            *(_DWORD *)buf = 136316418;
            *(_QWORD *)&buf[4] = v23;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VideoReceiver_SendFIRWithDelay";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 1574;
            *(_WORD *)&buf[28] = 2048;
            *(_QWORD *)&buf[30] = a2;
            *(_WORD *)&buf[38] = 2048;
            *(_QWORD *)&buf[40] = v25;
            *(_WORD *)&buf[48] = 2048;
            *(_QWORD *)&buf[50] = v26;
            _os_log_impl(&dword_1D8A54000, v24, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] VideoPacketBuffer[%p] Delay FIR cachedFIRcurrentTime=%2.4f", buf, 0x3Au);
          }
        }
      }
      else
      {
        _VideoReceiver_SendFIR(a2, (uint64_t)a3, v21, v158, v18);
      }
    }
    if (v156)
      _VideoReceiver_ResetExpectedDecodingOrder(a2);
    if (element)
    {
      if (*((_BYTE *)element + 23))
      {
        *(_WORD *)buf = (unsigned __int16)element[14];
        ReportingEventDictionary = _VideoReceiver_CreateReportingEventDictionary(a2);
        v28 = CFNumberCreate(*(CFAllocatorRef *)(v6 + 856), kCFNumberSInt16Type, buf);
        CFDictionaryAddValue(ReportingEventDictionary, CFSTR("VCVSKeyFrameSize"), v28);
        CFRelease(v28);
        reportingVideoStreamEvent();
        CFRelease(ReportingEventDictionary);
        memset(buf, 0, 96);
        memset(v187, 0, sizeof(v187));
        VCUtil_ConvertStreamIDArrayToString((size_t)(a3 + 6), a3[4], buf, 0x60uLL);
        VCUtil_ConvertStreamIDArrayToString((size_t)(a3 + 15), a3[4], (char *)v187, 0x60uLL);
        *(_DWORD *)(v6 + 960) = *((_DWORD *)element + 4);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v29 = VRTraceErrorLogLevelToCSTR();
          v30 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v31 = *(_DWORD *)(v6 + 960);
            v32 = element[14];
            v33 = *a3;
            v34 = a3[1];
            v35 = *((unsigned __int8 *)a3 + 70);
            v36 = v33 == a3[2];
            *(_DWORD *)v163 = 136317954;
            v164 = v29;
            v165 = 2080;
            v166 = "_VideoReceiver_AssembleAndEnqueueForDecode";
            v167 = 1024;
            v168 = 2510;
            v169 = 2048;
            v170 = a2;
            v171 = 1024;
            v172 = v31;
            v173 = 1024;
            v174 = (int)v32;
            v175 = 1024;
            v176 = v33;
            v177 = 1024;
            v178 = v34;
            v179 = 2080;
            v180 = buf;
            v181 = 2080;
            v182 = v187;
            v183 = 1024;
            v184 = v35;
            v185 = 1024;
            v186 = v36;
            _os_log_impl(&dword_1D8A54000, v30, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Received key frame timestamp=%u bytes=%d for streamID=%d, repairStreamID=%d, subStreamIDs=%s, repairSubStreamIDs=%s, isTemporalScaledStream=%d isBaseLayer=%d", v163, 0x5Eu);
          }
        }
      }
    }
    if (!NextFrame)
      break;
    v37 = (char *)element;
    if (!element)
      goto LABEL_148;
    if (*(unsigned __int16 *)(a2 + 1162) >= 2u)
    {
      if (!*((_BYTE *)element + 26))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v62 = VRTraceErrorLogLevelToCSTR();
          v63 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315906;
            *(_QWORD *)&buf[4] = v62;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VideoReceiver_AssembleAndEnqueueForDecode";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 2527;
            *(_WORD *)&buf[28] = 2048;
            *(_QWORD *)&buf[30] = a2;
            _os_log_error_impl(&dword_1D8A54000, v63, OS_LOG_TYPE_ERROR, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Received a frame with invalid decoding order!", buf, 0x26u);
          }
        }
        goto LABEL_75;
      }
      v38 = *((unsigned __int8 *)element + 23);
      v39 = *((unsigned __int16 *)element + 12);
      if (*(_BYTE *)(v6 + 844))
      {
        v40 = v39 - *(unsigned __int16 *)(v6 + 846);
        if (v40)
        {
          if ((unsigned __int16)v40 <= 0x7FFEu && (int)VRTraceGetErrorLogLevelForModule() >= 5)
          {
            v41 = VRTraceErrorLogLevelToCSTR();
            v42 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              v43 = *(unsigned __int16 *)(v6 + 846);
              *(_DWORD *)buf = 136316418;
              *(_QWORD *)&buf[4] = v41;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_VideoReceiver_UpdateExpectedDecodingOrder";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 853;
              *(_WORD *)&buf[28] = 2048;
              *(_QWORD *)&buf[30] = a2;
              *(_WORD *)&buf[38] = 1024;
              *(_DWORD *)&buf[40] = v39;
              *(_WORD *)&buf[44] = 1024;
              *(_DWORD *)&buf[46] = v43;
              _os_log_impl(&dword_1D8A54000, v42, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Jump in frameDecodingOrder:%hu expectedDecodingOrder:%hu", buf, 0x32u);
            }
          }
        }
        if ((unsigned __int16)(v39 - *(_WORD *)(v6 + 846)) >= 0x7FFFu && (int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          v44 = VRTraceErrorLogLevelToCSTR();
          v45 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v46 = *(unsigned __int16 *)(v6 + 846);
            *(_DWORD *)buf = 136316418;
            *(_QWORD *)&buf[4] = v44;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VideoReceiver_UpdateExpectedDecodingOrder";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 856;
            *(_WORD *)&buf[28] = 2048;
            *(_QWORD *)&buf[30] = a2;
            *(_WORD *)&buf[38] = 1024;
            *(_DWORD *)&buf[40] = v39;
            *(_WORD *)&buf[44] = 1024;
            *(_DWORD *)&buf[46] = v46;
            _os_log_impl(&dword_1D8A54000, v45, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] out of order in frameDecodingOrder:%hu expectedDecodingOrder:%hu", buf, 0x32u);
          }
        }
        if (*(_BYTE *)(v6 + 844))
        {
          if ((unsigned __int16)(v39 - *(_WORD *)(v6 + 846)) <= 0x7FFEu)
            *(_WORD *)(v6 + 846) = v39 + 1;
          goto LABEL_75;
        }
      }
      if (v38)
      {
        v47 = *(_DWORD *)(v6 + 840) + 1;
        *(_DWORD *)(v6 + 840) = v47;
        if (!*(_BYTE *)(v6 + 845))
        {
          *(_WORD *)(v6 + 846) = v39 + 1;
          *(_BYTE *)(v6 + 844) = v47 == *(unsigned __int16 *)(a2 + 1162);
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v64 = VRTraceErrorLogLevelToCSTR();
            v65 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              v66 = *(_DWORD *)(v6 + 840);
              v67 = *(unsigned __int16 *)(v6 + 846);
              v68 = *(unsigned __int8 *)(v6 + 844);
              *(_DWORD *)buf = 136316930;
              *(_QWORD *)&buf[4] = v64;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_VideoReceiver_UpdateExpectedDecodingOrderForRefreshFrame";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 830;
              *(_WORD *)&buf[28] = 2048;
              *(_QWORD *)&buf[30] = a2;
              *(_WORD *)&buf[38] = 1024;
              *(_DWORD *)&buf[40] = v39;
              *(_WORD *)&buf[44] = 1024;
              *(_DWORD *)&buf[46] = v66;
              *(_WORD *)&buf[50] = 1024;
              *(_DWORD *)&buf[52] = v67;
              *(_WORD *)&buf[56] = 1024;
              *(_DWORD *)&buf[58] = v68;
              _os_log_impl(&dword_1D8A54000, v65, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] First refresh frameDecodingOrder:%hu refreshFrameCount:%d expectedDecodingOrder:%hu isExpectedDecodingOrderValid:%d", buf, 0x3Eu);
            }
          }
          *(_BYTE *)(v6 + 845) = 1;
          goto LABEL_75;
        }
        v48 = *(unsigned __int16 *)(v6 + 846);
        if ((unsigned __int16)(v39 - v48) <= 0x7FFEu)
        {
          if (v39 != v48)
          {
            *(_DWORD *)(v6 + 840) = 1;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v49 = VRTraceErrorLogLevelToCSTR();
              v50 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                v51 = *(_DWORD *)(v6 + 840);
                v52 = *(unsigned __int16 *)(v6 + 846);
                v53 = *(unsigned __int8 *)(v6 + 844);
                *(_DWORD *)buf = 136316930;
                *(_QWORD *)&buf[4] = v49;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "_VideoReceiver_UpdateExpectedDecodingOrderForRefreshFrame";
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&buf[24] = 839;
                *(_WORD *)&buf[28] = 2048;
                *(_QWORD *)&buf[30] = a2;
                *(_WORD *)&buf[38] = 1024;
                *(_DWORD *)&buf[40] = v39;
                *(_WORD *)&buf[44] = 1024;
                *(_DWORD *)&buf[46] = v51;
                *(_WORD *)&buf[50] = 1024;
                *(_DWORD *)&buf[52] = v52;
                *(_WORD *)&buf[56] = 1024;
                *(_DWORD *)&buf[58] = v53;
                _os_log_impl(&dword_1D8A54000, v50, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Jump within refresh frameDecodingOrder:%hu refreshFrameCount:%d expectedDecodingOrder:%hu isExpectedDecodingOrderValid:%d", buf, 0x3Eu);
              }
            }
          }
          *(_WORD *)(v6 + 846) = v39 + 1;
          *(_BYTE *)(v6 + 844) = *(_DWORD *)(v6 + 840) == *(unsigned __int16 *)(a2 + 1162);
          if ((int)VRTraceGetErrorLogLevelForModule() < 7)
            goto LABEL_75;
          v54 = VRTraceErrorLogLevelToCSTR();
          v55 = *MEMORY[0x1E0CF2758];
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            goto LABEL_75;
          v56 = *(_DWORD *)(v6 + 840);
          v57 = *(unsigned __int16 *)(v6 + 846);
          v58 = *(unsigned __int8 *)(v6 + 844);
          *(_DWORD *)buf = 136316930;
          *(_QWORD *)&buf[4] = v54;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VideoReceiver_UpdateExpectedDecodingOrderForRefreshFrame";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 844;
          *(_WORD *)&buf[28] = 2048;
          *(_QWORD *)&buf[30] = a2;
          *(_WORD *)&buf[38] = 1024;
          *(_DWORD *)&buf[40] = v39;
          *(_WORD *)&buf[44] = 1024;
          *(_DWORD *)&buf[46] = v56;
          *(_WORD *)&buf[50] = 1024;
          *(_DWORD *)&buf[52] = v57;
          *(_WORD *)&buf[56] = 1024;
          *(_DWORD *)&buf[58] = v58;
          v59 = v55;
          v60 = "VideoReceiver [%s] %s:%d VideoReceiver[%p] Refresh frameDecodingOrder:%d refreshFrameCount:%d expectedDe"
                "codingOrder:%hu isExpectedDecodingOrderValid:%d";
          v61 = 62;
LABEL_74:
          _os_log_impl(&dword_1D8A54000, v59, OS_LOG_TYPE_DEFAULT, v60, buf, v61);
LABEL_75:
          v37 = (char *)element;
          *((_WORD *)element + 22) = *((unsigned __int8 *)a3 + 68);
          goto LABEL_76;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() < 7)
          goto LABEL_75;
        v69 = VRTraceErrorLogLevelToCSTR();
        v70 = *MEMORY[0x1E0CF2758];
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          goto LABEL_75;
        v71 = *(unsigned __int16 *)(v6 + 846);
        v72 = *(unsigned __int8 *)(v6 + 844);
        *(_DWORD *)buf = 136316674;
        *(_QWORD *)&buf[4] = v69;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VideoReceiver_UpdateExpectedDecodingOrderForRefreshFrame";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 846;
        *(_WORD *)&buf[28] = 2048;
        *(_QWORD *)&buf[30] = a2;
        *(_WORD *)&buf[38] = 1024;
        *(_DWORD *)&buf[40] = v39;
        *(_WORD *)&buf[44] = 1024;
        *(_DWORD *)&buf[46] = v71;
        *(_WORD *)&buf[50] = 1024;
        *(_DWORD *)&buf[52] = v72;
        v59 = v70;
        v60 = "VideoReceiver [%s] %s:%d VideoReceiver[%p] Received out of order refresh frameDecodingOrder:%hu expectedDe"
              "codingOrder:%hu isExpectedDecodingOrderValid:%d";
      }
      else
      {
        if ((int)VRTraceGetErrorLogLevelForModule() < 8)
          goto LABEL_75;
        v134 = VRTraceErrorLogLevelToCSTR();
        v135 = *MEMORY[0x1E0CF2758];
        v136 = *MEMORY[0x1E0CF2758];
        if (!*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v136, OS_LOG_TYPE_DEBUG))
          {
            v139 = *(unsigned __int16 *)(v6 + 846);
            v140 = *(unsigned __int8 *)(v6 + 844);
            *(_DWORD *)buf = 136316674;
            *(_QWORD *)&buf[4] = v134;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VideoReceiver_UpdateExpectedDecodingOrder";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 871;
            *(_WORD *)&buf[28] = 2048;
            *(_QWORD *)&buf[30] = a2;
            *(_WORD *)&buf[38] = 1024;
            *(_DWORD *)&buf[40] = v39;
            *(_WORD *)&buf[44] = 1024;
            *(_DWORD *)&buf[46] = v139;
            *(_WORD *)&buf[50] = 1024;
            *(_DWORD *)&buf[52] = v140;
            _os_log_debug_impl(&dword_1D8A54000, v135, OS_LOG_TYPE_DEBUG, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Not a refresh frameDecodingOrder:%hu expectedDecodingOrder:%hu isExpectedDecodingOrderValid:%d", buf, 0x38u);
          }
          goto LABEL_75;
        }
        if (!os_log_type_enabled(v136, OS_LOG_TYPE_DEFAULT))
          goto LABEL_75;
        v137 = *(unsigned __int16 *)(v6 + 846);
        v138 = *(unsigned __int8 *)(v6 + 844);
        *(_DWORD *)buf = 136316674;
        *(_QWORD *)&buf[4] = v134;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VideoReceiver_UpdateExpectedDecodingOrder";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 871;
        *(_WORD *)&buf[28] = 2048;
        *(_QWORD *)&buf[30] = a2;
        *(_WORD *)&buf[38] = 1024;
        *(_DWORD *)&buf[40] = v39;
        *(_WORD *)&buf[44] = 1024;
        *(_DWORD *)&buf[46] = v137;
        *(_WORD *)&buf[50] = 1024;
        *(_DWORD *)&buf[52] = v138;
        v59 = v135;
        v60 = "VideoReceiver [%s] %s:%d VideoReceiver[%p] Not a refresh frameDecodingOrder:%hu expectedDecodingOrder:%hu "
              "isExpectedDecodingOrderValid:%d";
      }
      v61 = 56;
      goto LABEL_74;
    }
LABEL_76:
    *((_WORD *)v37 + 10) = *a3;
    v37[64] = *((_BYTE *)a3 + 69);
    *((double *)v37 + 9) = VideoFrameTimeInSeconds;
    *((_QWORD *)v37 + 11) = *((_QWORD *)v37 + 14);
    if (*(_BYTE *)(a2 + 1183))
      v73 = v160 == 0;
    else
      v73 = 1;
    v74 = !v73;
    v37[96] = v74;
    *((_DWORD *)v37 + 25) = v159;
    v75 = *(_OWORD *)(v37 + 24);
    v150 = *(_OWORD *)(v37 + 8);
    v151 = v75;
    v76 = *(_OWORD *)(v37 + 56);
    v77 = *(_OWORD *)(v37 + 88);
    v78 = *(_OWORD *)(v37 + 40);
    v154 = *(_OWORD *)(v37 + 72);
    v155 = v77;
    v152 = v78;
    v153 = v76;
    if (*(_BYTE *)(v6 + 537))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v79 = VRTraceErrorLogLevelToCSTR();
        v80 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v81 = *((unsigned __int16 *)v37 + 10);
          v82 = *((_DWORD *)v37 + 2);
          v83 = *((_DWORD *)v37 + 4);
          *(_DWORD *)buf = 136316930;
          *(_QWORD *)&buf[4] = v79;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VideoReceiver_EnqueueForDecode";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 2376;
          *(_WORD *)&buf[28] = 2048;
          *(_QWORD *)&buf[30] = a2;
          *(_WORD *)&buf[38] = 1024;
          *(_DWORD *)&buf[40] = v81;
          *(_WORD *)&buf[44] = 1024;
          *(_DWORD *)&buf[46] = v82;
          *(_WORD *)&buf[50] = 1024;
          *(_DWORD *)&buf[52] = v83;
          *(_WORD *)&buf[56] = 2048;
          *(_QWORD *)&buf[58] = 96;
          _os_log_impl(&dword_1D8A54000, v80, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] for streamID=%d enqueue encoded frame for later decode. payload=%d timestamp=%u argsLength=%zu", buf, 0x42u);
        }
      }
    }
    v84 = *(unsigned __int16 *)(a2 + 1162);
    if (v84 >= 2)
    {
      if (!*(_BYTE *)(v6 + 844) && !v37[23])
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          v118 = VRTraceErrorLogLevelToCSTR();
          v119 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v120 = *(unsigned __int16 *)(v6 + 846);
            v121 = v37[23];
            v122 = v37[26];
            v123 = *((unsigned __int16 *)v37 + 12);
            *(_DWORD *)buf = 136316930;
            *(_QWORD *)&buf[4] = v118;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VideoReceiver_EnqueueForDecode";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 2379;
            *(_WORD *)&buf[28] = 2048;
            *(_QWORD *)&buf[30] = a2;
            *(_WORD *)&buf[38] = 1024;
            *(_DWORD *)&buf[40] = v120;
            *(_WORD *)&buf[44] = 1024;
            *(_DWORD *)&buf[46] = v121;
            *(_WORD *)&buf[50] = 1024;
            *(_DWORD *)&buf[52] = v122;
            *(_WORD *)&buf[56] = 1024;
            *(_DWORD *)&buf[58] = v123;
            _os_log_impl(&dword_1D8A54000, v119, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Don't process sub frame when expectedDecodingOrder:%d is invalid! isRefreshFrame:%d frameDecodingOrderValid:%d frameDecodingOrder:%d", buf, 0x3Eu);
          }
        }
        v104 = 20;
        goto LABEL_137;
      }
      if (*(unsigned __int16 *)(v6 + 846) != (unsigned __int16)(*((_WORD *)v37 + 12) + 1))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          v97 = VRTraceErrorLogLevelToCSTR();
          v98 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v99 = *(unsigned __int16 *)(v6 + 846);
            v100 = *(unsigned __int8 *)(v6 + 844);
            v101 = v37[23];
            v102 = v37[26];
            v103 = *((unsigned __int16 *)v37 + 12);
            *(_DWORD *)buf = 136317186;
            *(_QWORD *)&buf[4] = v97;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VideoReceiver_EnqueueForDecode";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 2385;
            *(_WORD *)&buf[28] = 2048;
            *(_QWORD *)&buf[30] = a2;
            *(_WORD *)&buf[38] = 1024;
            *(_DWORD *)&buf[40] = v99;
            *(_WORD *)&buf[44] = 1024;
            *(_DWORD *)&buf[46] = v100;
            *(_WORD *)&buf[50] = 1024;
            *(_DWORD *)&buf[52] = v101;
            *(_WORD *)&buf[56] = 1024;
            *(_DWORD *)&buf[58] = v102;
            *(_WORD *)&buf[62] = 1024;
            *(_DWORD *)&buf[64] = v103;
            _os_log_impl(&dword_1D8A54000, v98, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Don't process sub frame when expectedDecodingOrder:%d isExpectedDecodingOrderValid:%d is jumping or out of order! isRefreshFrame:%d frameDecodingOrderValid:%d frameDecodingOrder:%d", buf, 0x44u);
          }
        }
        v104 = 21;
LABEL_137:
        v158 = v104;
LABEL_138:
        if (*(unsigned __int16 *)(a2 + 1162) >= 2u && !*(_BYTE *)(v6 + 844))
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
          {
            v124 = VRTraceErrorLogLevelToCSTR();
            v125 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              v126 = *((_QWORD *)a3 + 14);
              v127 = *((unsigned __int16 *)element + 12);
              v128 = *(unsigned __int16 *)(v6 + 846);
              v129 = *(unsigned __int8 *)(v6 + 844);
              *(_DWORD *)buf = 136316930;
              *(_QWORD *)&buf[4] = v124;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_VideoReceiver_AssembleAndEnqueueForDecode";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 2543;
              *(_WORD *)&buf[28] = 2048;
              *(_QWORD *)&buf[30] = a2;
              *(_WORD *)&buf[38] = 2048;
              *(_QWORD *)&buf[40] = v126;
              *(_WORD *)&buf[48] = 1024;
              *(_DWORD *)&buf[50] = v127;
              *(_WORD *)&buf[54] = 1024;
              *(_DWORD *)&buf[56] = v128;
              *(_WORD *)&buf[60] = 1024;
              *(_DWORD *)&buf[62] = v129;
              _os_log_impl(&dword_1D8A54000, v125, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] VideoPacketBuffer[%p] Needs refresh and reset DON due to failure to enqueue video frameDecodingOrder:%hu expectedDecodingOrder:%hu isExpectedDecodingOrderValid:%d", buf, 0x42u);
            }
          }
          if (*(_BYTE *)(a2 + 1183))
            v130 = *(_DWORD *)(v6 + 148) != 0;
          else
            v130 = 0;
          _VideoReceiver_DecoderNeedsRefresh(a2, (uint64_t)a3, v130, v158, v18);
        }
        VCVideoReceiverSampleBuffer_Destroy(&element);
        goto LABEL_148;
      }
    }
    if (*(_BYTE *)(a2 + 1180))
    {
      if (*(_BYTE *)(a2 + 1191) && v37[23])
      {
        v85 = *((_DWORD *)v37 + 17);
        if (v85 != *(_DWORD *)(v6 + 152))
        {
          v86 = (int)VCDefaults_GetIntValueForKey(CFSTR("pixelCountThresholdForDynamicVideoJitterBufferMode"), 8294400) > v85;
          _VideoReceiver_SetJitterBufferMode(a2, v86);
          v84 = *(unsigned __int16 *)(a2 + 1162);
        }
        *(_DWORD *)(v6 + 152) = v85;
      }
      v87 = (uint64_t)(v37 + 8);
      if (v84 >= 2)
      {
        buf[0] = 0;
        VideoDecoder_IsLastSubframe(*(_QWORD *)(v148 + 87), *((_QWORD *)v37 + 13), *((unsigned __int16 *)v37 + 22), buf);
        if (!buf[0])
          v87 = 0;
      }
      _VideoReceiver_EnqueueFrameToJitterBuffer(a2, v87);
    }
    if (!*((_BYTE *)a3 + 70) && *((unsigned __int16 *)v37 + 10) == *(unsigned __int16 *)(v6 + 896))
    {
      if (*(_BYTE *)(v6 + 340))
      {
        v88 = (unsigned __int16)(*((_WORD *)v37 + 24) - *(_WORD *)(v6 + 894));
        if (v88 >= 2)
        {
          v89 = v88 - 1;
          *(_DWORD *)(v6 + 900) += v88 - 1;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
          {
            v90 = VRTraceErrorLogLevelToCSTR();
            v91 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              v92 = *((_DWORD *)v37 + 4);
              v93 = *((unsigned __int16 *)v37 + 24);
              v94 = *(unsigned __int16 *)(v6 + 894);
              *(_DWORD *)buf = 136316930;
              *(_QWORD *)&buf[4] = v90;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_VideoReceiver_CalculateFrameErasures";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 2237;
              *(_WORD *)&buf[28] = 2048;
              *(_QWORD *)&buf[30] = a2;
              *(_WORD *)&buf[38] = 1024;
              *(_DWORD *)&buf[40] = v89;
              *(_WORD *)&buf[44] = 1024;
              *(_DWORD *)&buf[46] = v92;
              *(_WORD *)&buf[50] = 1024;
              *(_DWORD *)&buf[52] = v93;
              *(_WORD *)&buf[56] = 1024;
              *(_DWORD *)&buf[58] = v94;
              _os_log_impl(&dword_1D8A54000, v91, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Detected video frame erasure count of %u frames. rtpTimestamp=%u frameSequenceNumber=%u lastFrameSequenceNumber=%u", buf, 0x3Eu);
            }
          }
        }
      }
    }
    *(_WORD *)(v6 + 894) = *((_WORD *)v37 + 24);
    *(_WORD *)(v6 + 896) = *((_WORD *)v37 + 10);
    if (!v37[23])
    {
      if (*(_BYTE *)v148)
      {
        if (!v37[81])
        {
          v95 = *((_QWORD *)v37 + 7);
          memset(&buf[28], 0, 82);
          v189 = 0u;
          v190 = 0u;
          v191 = 0u;
          v192 = 0u;
          memset(v193, 0, sizeof(v193));
          v96 = *(_QWORD *)(v6 + 744);
          *(_QWORD *)buf = 10;
          *(_QWORD *)&buf[8] = v95;
          *(_QWORD *)&buf[16] = 0;
          *(_DWORD *)&buf[24] = 5;
          goto LABEL_117;
        }
      }
      else if (v37[81])
      {
        v105 = *((_QWORD *)v37 + 7);
        *(_QWORD *)&buf[28] = 0;
        *(_QWORD *)&buf[36] = 0;
        *(_WORD *)&buf[44] = 256;
        memset(&buf[46], 0, 64);
        v189 = 0u;
        v190 = 0u;
        v191 = 0u;
        v192 = 0u;
        memset(v193, 0, sizeof(v193));
        v96 = *(_QWORD *)(v6 + 744);
        *(_QWORD *)buf = 10;
        *(_QWORD *)&buf[8] = v105;
        *(_QWORD *)&buf[16] = 0;
        *(_DWORD *)&buf[24] = 5;
LABEL_117:
        VCRateControlSetStatistics(v96, buf);
      }
      *(_BYTE *)v148 = v37[81];
    }
    if (*(_BYTE *)(a2 + 1254))
    {
      Head = (double *)CMSimpleQueueGetHead(*(CMSimpleQueueRef *)(v6 + 632));
      if (Head)
      {
        v109 = Head[9];
        LODWORD(v107) = *(_DWORD *)(v6 + 32);
        LODWORD(v108) = *(_DWORD *)(v6 + 40);
        v110 = ((double)v107 + (double)v108 * 4294967300.0) / (double)*(int *)(a2 + 1036);
        if (v110 - v109 > *(double *)(v6 + 944) && *(double *)(v6 + 808) - *(double *)(v6 + 824) > 30.0)
        {
          Count = CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(v6 + 632));
          if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
          {
            v112 = VRTraceErrorLogLevelToCSTR();
            v113 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136316930;
              *(_QWORD *)&buf[4] = v112;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_VideoReceiver_CheckQueueDepthMeetsRealtime";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 2365;
              *(_WORD *)&buf[28] = 2048;
              *(_QWORD *)&buf[30] = a2;
              *(_WORD *)&buf[38] = 2048;
              *(double *)&buf[40] = v110 - v109;
              *(_WORD *)&buf[48] = 2048;
              *(double *)&buf[50] = v110;
              *(_WORD *)&buf[58] = 2048;
              *(double *)&buf[60] = v109;
              *(_WORD *)&buf[68] = 1024;
              *(_DWORD *)&buf[70] = Count;
              _os_log_impl(&dword_1D8A54000, v113, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] High watermark exceeded in frameQueueForDecode. delay=%0.3f playoutTimeInSeconds=%0.6f, oldestVideoFrameTimeInSeconds=%0.6f, numFramesEnqueuedForDecode=%d", buf, 0x4Au);
            }
          }
          reportingSymptom();
          *(_QWORD *)(v6 + 824) = *(_QWORD *)(v6 + 808);
        }
      }
    }
    v114 = CMSimpleQueueEnqueue(*(CMSimpleQueueRef *)(v6 + 632), v37);
    if (v114)
    {
      v115 = v114;
      v158 = 22;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v116 = VRTraceErrorLogLevelToCSTR();
        v117 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v131 = *((unsigned __int16 *)v37 + 10);
          v132 = *((_DWORD *)v37 + 2);
          v133 = *((_DWORD *)v37 + 4);
          *(_DWORD *)buf = 136316930;
          *(_QWORD *)&buf[4] = v116;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VideoReceiver_EnqueueForDecode";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 2423;
          *(_WORD *)&buf[28] = 2048;
          *(_QWORD *)&buf[30] = a2;
          *(_WORD *)&buf[38] = 1024;
          *(_DWORD *)&buf[40] = v131;
          *(_WORD *)&buf[44] = 1024;
          *(_DWORD *)&buf[46] = v132;
          *(_WORD *)&buf[50] = 1024;
          *(_DWORD *)&buf[52] = v133;
          *(_WORD *)&buf[56] = 1024;
          *(_DWORD *)&buf[58] = v115;
          _os_log_error_impl(&dword_1D8A54000, v117, OS_LOG_TYPE_ERROR, "VideoReceiver [%s] %s:%d VideoReceiver[%p] for streamID=%d failed to enqueue frame for decode. payload=%d timestamp=%u status=%d", buf, 0x3Eu);
        }
      }
      if (!*(_BYTE *)(v6 + 612))
      {
        *(_BYTE *)(v6 + 612) = 1;
        VCUtil_GenerateDiagnostics(0, 0, "VideoReceiver failed to enqueue frame into frameQueueForDecode", 1u);
      }
      goto LABEL_138;
    }
LABEL_148:
    pthread_mutex_unlock((pthread_mutex_t *)(a2 + 40584));
  }
  VCVideoReceiverSampleBuffer_Destroy(&element);
  pthread_mutex_unlock((pthread_mutex_t *)(a2 + 40584));
  if (*(_BYTE *)(a2 + 1180))
  {
    if (*(_BYTE *)(a2 + 1181) && (*(_BYTE *)(a2 + 1252) || !*(_BYTE *)(v6 + 876)))
    {
      *(_OWORD *)buf = xmmword_1D910BE80;
      *(_OWORD *)&buf[16] = unk_1D910BE90;
      VCVideoJitterBuffer_GetReferenceFrame(*(_QWORD *)(v6 + 864), buf);
      if (buf[24])
      {
        if (*(_DWORD *)&buf[8] != *(_DWORD *)(v6 + 872))
        {
          VCVideoPlayer_SetReferenceRTPTimestamp(*(double *)buf, *(double *)&buf[16], *(_QWORD *)(v148 + 79), *(int *)&buf[8]);
          *(_DWORD *)(v6 + 872) = *(_DWORD *)&buf[8];
          *(_BYTE *)(v6 + 876) = 1;
        }
      }
    }
    v141 = micro();
    *(_QWORD *)(v6 + 96) = *(_QWORD *)(v6 + 88);
    TargetJitterQueueSize = VCVideoJitterBuffer_GetTargetJitterQueueSize(*(_QWORD *)(v6 + 864));
    DoubleValueForKey = VCDefaults_GetDoubleValueForKey(CFSTR("videoPlayerJitterQueueSize"), TargetJitterQueueSize);
    *(double *)(v6 + 88) = DoubleValueForKey;
    v144 = *(double *)(v6 + 96);
    if (v144 != DoubleValueForKey)
    {
      v145 = v141 - *(double *)(v6 + 112);
      ++*(_WORD *)(v6 + 104);
      *(double *)(v6 + 128) = *(double *)(v6 + 128) + v145 * v144;
      if (DoubleValueForKey == 0.0 || v144 != 0.0)
        *(double *)(v6 + 120) = v145 + *(double *)(v6 + 120);
      *(double *)(v6 + 112) = v141;
    }
    VCVideoPlayer_SetTargetQueueSizeInSeconds(DoubleValueForKey);
  }
  VideoUtil_ConstructSubFrameIdentifer((unsigned __int16)v151, *((unsigned __int8 *)a3 + 68));
  kdebug_trace();
  return VCVideoPlayer_QueueAlarmForDecode(*(_QWORD *)(v148 + 79), (uint64_t)VideoReceiver_VideoAlarmForDecode, a1, a4, WORD4(v152), v156 != 0, VideoFrameTimeInSeconds);
}

void VideoReceiver_VideoAlarmForDecode(uint64_t a1, __int128 *a2, int a3, int a4)
{
  __int128 v4;
  uint64_t v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v4 = *a2;
  v5 = *((_QWORD *)a2 + 2);
  _VideoReceiver_VideoAlarmCommon(a1, (uint64_t)&v4, a3, a4, 0, 1, 0);
}

void _VideoReceiver_ProcessVideoRTCPInternal(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  double v7;
  double v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int16 *v13;
  uint64_t v14;
  _WORD *v15;
  __int16 v16;
  int v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  NSObject *v21;
  unint64_t v22;
  uint64_t v23;
  __int16 *v24;
  uint64_t v25;
  NSObject *v26;
  NSObject *v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  uint64_t v34;
  NSObject *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  double v46;
  uint64_t v47;
  NSObject *v48;
  _DWORD *v49;
  __int16 v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  int v55;
  __int128 v56;
  double v57;
  int v58;
  double v59;
  uint64_t v60;
  uint64_t v61;
  NSObject *v62;
  NSObject *v63;
  int v64;
  int v65;
  int v66;
  int v67;
  NSObject *v68;
  NSObject *v69;
  _BOOL4 v70;
  int v71;
  __CFDictionary *Mutable;
  __CFDictionary *v73;
  const void *v74;
  CFNumberRef v75;
  double v76;
  uint64_t v77;
  uint64_t v78;
  NSObject *v79;
  NSObject *v80;
  uint64_t v81;
  NSObject *v82;
  uint64_t v83;
  NSObject *v84;
  int v85;
  int v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  const __CFAllocator *allocator;
  int v91;
  _DWORD *v92;
  uint64_t v93;
  int v94;
  __int16 v95;
  int v96;
  __int128 v97;
  __int128 v98;
  uint64_t v99;
  __int128 v100;
  int v101;
  _QWORD v102[2];
  int v103;
  _BYTE buf[24];
  int v105;
  _QWORD v106[24];

  *(_QWORD *)((char *)&v106[21] + 4) = *MEMORY[0x1E0C80C00];
  v6 = a1 + 40384;
  v102[0] = 0;
  v102[1] = 0;
  v103 = 0;
  v7 = micro();
  *(double *)(v6 + 1088) = v7;
  if (!*(_BYTE *)(a3 + 8))
    return;
  v8 = v7;
  v9 = 0;
  v91 = 0;
  v92 = 0;
  v96 = -1431655766;
  allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v93 = a2;
  while (2)
  {
    v10 = *(_QWORD *)(a3 + 8 * v9 + 16);
    switch(*(_BYTE *)(v10 + 1))
    {
      case 0xC0:
        v11 = RTCPPacketFIREntryCount(*(_QWORD *)(a3 + 8 * v9 + 16));
        v12 = v11;
        if (!(_DWORD)v11)
          goto LABEL_13;
        v13 = (unsigned __int16 *)(v10 + 8);
        v14 = v11;
        v15 = v102;
        do
        {
          v17 = *v13++;
          v16 = v17;
          if (v17 == 0xFFFF)
            break;
          *v15++ = v16;
          --v14;
        }
        while (v14);
        if (*(_BYTE *)(a1 + 1183))
          goto LABEL_13;
        if ((int)VRTraceGetErrorLogLevelForModule() < 7)
          goto LABEL_12;
        v18 = VRTraceErrorLogLevelToCSTR();
        v19 = *MEMORY[0x1E0CF2758];
        v12 = 0;
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315906;
          *(_QWORD *)&buf[4] = v18;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VideoReceiver_ProcessVideoRTCPInternal";
          *(_WORD *)&buf[22] = 1024;
          v105 = 4061;
          LOWORD(v106[0]) = 2048;
          *(_QWORD *)((char *)v106 + 2) = a1;
          _os_log_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] LTRP is disabled. Converting refresh request to key frame request", buf, 0x26u);
LABEL_12:
          v12 = 0;
        }
LABEL_13:
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v20 = VRTraceErrorLogLevelToCSTR();
          v21 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136316674;
            *(_QWORD *)&buf[4] = v20;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VideoReceiver_ProcessVideoRTCPInternal";
            *(_WORD *)&buf[22] = 1024;
            v105 = 4065;
            LOWORD(v106[0]) = 2048;
            *(_QWORD *)((char *)v106 + 2) = a1;
            WORD1(v106[1]) = 1024;
            HIDWORD(v106[1]) = v12;
            LOWORD(v106[2]) = 1024;
            *(_DWORD *)((char *)&v106[2] + 2) = LOWORD(v102[0]);
            HIWORD(v106[2]) = 1024;
            LODWORD(v106[3]) = WORD1(v102[0]);
            _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Received FIR(%d) %dx%d", buf, 0x38u);
          }
        }
        v91 = 1;
        VideoTransmitter_GenerateKeyFrameNow(*(_QWORD *)v6, (unsigned __int16 *)v102, v12, 0, 1, 2 * ((_DWORD)v12 != 0));
LABEL_77:
        if (++v9 < (unint64_t)*(unsigned __int8 *)(a3 + 8))
          continue;
        if (v92)
        {
          VideoTransmitter_SetVideoLossFraction(*(_QWORD *)v6, *((unsigned __int8 *)v92 + 4));
          if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
          {
            v83 = VRTraceErrorLogLevelToCSTR();
            v84 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              v85 = v92[1];
              v86 = v92[1] >> 8;
              v87 = v92[3];
              v88 = *(_QWORD *)(v6 + 1208);
              *(_DWORD *)buf = 136317186;
              *(_QWORD *)&buf[4] = v83;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_VideoReceiver_ProcessVideoRTCPInternal";
              *(_WORD *)&buf[22] = 1024;
              v105 = 4102;
              LOWORD(v106[0]) = 2048;
              *(_QWORD *)((char *)v106 + 2) = a1;
              WORD1(v106[1]) = 1024;
              HIDWORD(v106[1]) = v85;
              LOWORD(v106[2]) = 1024;
              *(_DWORD *)((char *)&v106[2] + 2) = v86;
              HIWORD(v106[2]) = 2048;
              v106[3] = v87;
              LOWORD(v106[4]) = 2048;
              *(_QWORD *)((char *)&v106[4] + 2) = v88;
              WORD1(v106[5]) = 1024;
              HIDWORD(v106[5]) = v91;
              _os_log_impl(&dword_1D8A54000, v84, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] VRTCP: Fraction=%03d, Lost=%d, Jitter=%lu, RTT=%.3f, FIR=%d", buf, 0x4Cu);
            }
          }
        }
        return;
      case 0xC1:
        if (!*(_BYTE *)(a1 + 1260)
          && *(double *)(v6 + 1208) < 0.2
          && (RTPRexmitRTP(*(_QWORD *)(a2 + 48), *(unsigned __int16 *)(v10 + 8), *(unsigned __int16 *)(v10 + 10), &v96) & 0x80000000) == 0)
        {
          VideoTransmitter_AddRexmitBytes(*(_QWORD *)v6, v96);
        }
        goto LABEL_77;
      case 0xC8:
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v34 = VRTraceErrorLogLevelToCSTR();
          v35 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = v34;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VideoReceiver_ProcessRTCPSRPacket";
            *(_WORD *)&buf[22] = 1024;
            v105 = 3887;
            _os_log_impl(&dword_1D8A54000, v35, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d Received RTCP SR", buf, 0x1Cu);
          }
        }
        if (_VideoReceiver_ShouldProcessPacket(a1, a2, *(unsigned __int8 *)(a3 + 1621), *(_QWORD *)(a3 + 1624), (unsigned __int16 *)(a3 + 1596), *(unsigned __int8 *)(a3 + 1620)))
        {
          *(_BYTE *)(v6 + 1248) = _VideoReceiver_HandleStreamSwitch(a1, (unsigned __int16 *)a2, v36, v37, v38, v39, v40, v41);
          v42 = a2;
          v43 = *(unsigned int *)(v10 + 8);
          v44 = *(unsigned int *)(v10 + 12);
          v92 = (_DWORD *)(v10 + 28);
          _VideoReceiver_ProcessReceptionReportBlock(*(_QWORD *)(v42 + 48), *(_WORD *)v10 & 0x1F, (_DWORD *)(v10 + 28), *(_QWORD *)a3);
          v45 = *(_QWORD *)(v6 + 1192);
          if (v45)
          {
            v46 = NTPToMicro(v44 | (v43 << 32));
            VCMediaStreamSynchronizer_updateDestinationNTPTime(v45, *(_DWORD *)(v10 + 16), v46);
          }
          goto LABEL_41;
        }
        goto LABEL_77;
      case 0xC9:
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v47 = VRTraceErrorLogLevelToCSTR();
          v48 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = v47;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VideoReceiver_ProcessVideoRTCPInternal";
            *(_WORD *)&buf[22] = 1024;
            v105 = 4013;
            _os_log_impl(&dword_1D8A54000, v48, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d Received RTCP RR", buf, 0x1Cu);
          }
        }
        v50 = *(_WORD *)v10;
        v49 = (_DWORD *)(v10 + 8);
        _VideoReceiver_ProcessReceptionReportBlock(*(_QWORD *)(a2 + 48), v50 & 0x1F, v49, *(_QWORD *)a3);
        v92 = v49;
        goto LABEL_77;
      case 0xCC:
        v51 = *(_DWORD *)(v10 + 8);
        if (v51 == 1380144204)
        {
          v101 = -1431655766;
          *(_QWORD *)&v100 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v100 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v56 = *(_OWORD *)(v10 + 12);
          v101 = *(_DWORD *)(v10 + 28);
          v100 = v56;
          v99 = 0;
          v97 = 0u;
          v98 = 0u;
          v95 = 0;
          v94 = 16843010;
          VCMediaControlInfoUnserializeWithData((uint64_t)&v97, (unsigned __int16 *)&v100, 0x14uLL, (unsigned __int8 *)&v94);
          v57 = micro();
          v58 = WORD4(v98);
          v59 = RTPUnpackDouble(HIDWORD(v98));
          v60 = *(_QWORD *)(v6 + 1016);
          *(_QWORD *)buf = 2;
          *(double *)&buf[8] = v57;
          *(_WORD *)&buf[16] = 0;
          buf[18] = 1;
          *(_DWORD *)&buf[19] = 0;
          buf[23] = 0;
          v105 = v58;
          a2 = v93;
          LODWORD(v106[0]) = DWORD1(v98);
          HIDWORD(v106[0]) = WORD1(v97);
          LODWORD(v106[1]) = 0;
          HIDWORD(v106[2]) = 0;
          LODWORD(v106[3]) = 0;
          *(_QWORD *)((char *)&v106[1] + 4) = WORD2(v97);
          HIDWORD(v106[3]) = WORD3(v97);
          v106[4] = 0;
          LODWORD(v106[5]) = (unsigned __int16)v97;
          *(_QWORD *)((char *)&v106[5] + 4) = 0;
          *(double *)((char *)&v106[6] + 4) = v59;
          memset((char *)&v106[7] + 4, 0, 112);
          VCRateControlSetStatistics(v60, buf);
          if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            v61 = VRTraceErrorLogLevelToCSTR();
            v62 = *MEMORY[0x1E0CF2758];
            v63 = *MEMORY[0x1E0CF2758];
            if (*MEMORY[0x1E0CF2748])
            {
              if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136316930;
                *(_QWORD *)&buf[4] = v61;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "_VideoReceiver_ProcessVideoRTCPInternal";
                *(_WORD *)&buf[22] = 1024;
                v105 = 4043;
                LOWORD(v106[0]) = 2048;
                *(_QWORD *)((char *)v106 + 2) = a1;
                WORD1(v106[1]) = 1024;
                HIDWORD(v106[1]) = HIDWORD(v98);
                LOWORD(v106[2]) = 1024;
                *(_DWORD *)((char *)&v106[2] + 2) = WORD1(v97);
                HIWORD(v106[2]) = 1024;
                LODWORD(v106[3]) = WORD2(v97);
                WORD2(v106[3]) = 1024;
                *(_DWORD *)((char *)&v106[3] + 6) = v98;
                _os_log_impl(&dword_1D8A54000, v62, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Received APP_RTCL with owrd:%u, BWE:%u, burstyLoss:%u, JQSize:%u", buf, 0x3Eu);
              }
            }
            else if (os_log_type_enabled(v63, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136316930;
              *(_QWORD *)&buf[4] = v61;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_VideoReceiver_ProcessVideoRTCPInternal";
              *(_WORD *)&buf[22] = 1024;
              v105 = 4043;
              LOWORD(v106[0]) = 2048;
              *(_QWORD *)((char *)v106 + 2) = a1;
              WORD1(v106[1]) = 1024;
              HIDWORD(v106[1]) = HIDWORD(v98);
              LOWORD(v106[2]) = 1024;
              *(_DWORD *)((char *)&v106[2] + 2) = WORD1(v97);
              HIWORD(v106[2]) = 1024;
              LODWORD(v106[3]) = WORD2(v97);
              WORD2(v106[3]) = 1024;
              *(_DWORD *)((char *)&v106[3] + 6) = v98;
              _os_log_debug_impl(&dword_1D8A54000, v62, OS_LOG_TYPE_DEBUG, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Received APP_RTCL with owrd:%u, BWE:%u, burstyLoss:%u, JQSize:%u", buf, 0x3Eu);
            }
          }
          VideoTransmitter_SetPacketExpirationTime(*(_QWORD *)v6, v98);
        }
        else if (v51 == 5)
        {
          v52 = a1;
          v53 = *(_QWORD *)(a3 + 8 * v9 + 16);
          v54 = 204;
          goto LABEL_52;
        }
        goto LABEL_77;
      case 0xCD:
        if (*(double *)(v6 + 1208) < 0.2
          && (RTPRexmitRTP(*(_QWORD *)(a2 + 48), *(unsigned __int16 *)(v10 + 12), *(unsigned __int16 *)(v10 + 14), &v96) & 0x80000000) == 0)
        {
          VideoTransmitter_AddRexmitBytes(*(_QWORD *)v6, v96);
        }
        v22 = *(unsigned __int16 *)(v10 + 2);
        if (v22 >= 3)
        {
          v23 = (v22 - 2);
          v24 = (__int16 *)(v10 + 14);
          do
          {
            if ((VideoTransmitter_RetransmitPackets(v8, *(_QWORD *)v6, *(_DWORD *)(v10 + 8), *(v24 - 1), *v24) & 0x80000000) != 0
              && (int)VRTraceGetErrorLogLevelForModule() >= 8)
            {
              v25 = VRTraceErrorLogLevelToCSTR();
              v26 = *MEMORY[0x1E0CF2758];
              v27 = *MEMORY[0x1E0CF2758];
              if (*MEMORY[0x1E0CF2748])
              {
                if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
                {
                  v28 = *(_DWORD *)(v10 + 8);
                  v29 = (unsigned __int16)*(v24 - 1);
                  v30 = (unsigned __int16)*v24;
                  *(_DWORD *)buf = 136316930;
                  *(_QWORD *)&buf[4] = v25;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = "_VideoReceiver_ProcessVideoRTCPNACKPacket";
                  *(_WORD *)&buf[22] = 1024;
                  v105 = 3990;
                  LOWORD(v106[0]) = 2048;
                  *(_QWORD *)((char *)v106 + 2) = a1;
                  WORD1(v106[1]) = 1024;
                  HIDWORD(v106[1]) = v28;
                  LOWORD(v106[2]) = 1024;
                  *(_DWORD *)((char *)&v106[2] + 2) = v29;
                  HIWORD(v106[2]) = 1024;
                  LODWORD(v106[3]) = v30;
                  WORD2(v106[3]) = 2048;
                  *(double *)((char *)&v106[3] + 6) = v8;
                  _os_log_impl(&dword_1D8A54000, v26, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] VRTCP: Failed to retransmit packets ssrc=%u, firstSequenceNumber=%u, bitmask=%u, currentTime=%f", buf, 0x42u);
                }
              }
              else if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
              {
                v31 = *(_DWORD *)(v10 + 8);
                v32 = (unsigned __int16)*(v24 - 1);
                v33 = (unsigned __int16)*v24;
                *(_DWORD *)buf = 136316930;
                *(_QWORD *)&buf[4] = v25;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "_VideoReceiver_ProcessVideoRTCPNACKPacket";
                *(_WORD *)&buf[22] = 1024;
                v105 = 3990;
                LOWORD(v106[0]) = 2048;
                *(_QWORD *)((char *)v106 + 2) = a1;
                WORD1(v106[1]) = 1024;
                HIDWORD(v106[1]) = v31;
                LOWORD(v106[2]) = 1024;
                *(_DWORD *)((char *)&v106[2] + 2) = v32;
                HIWORD(v106[2]) = 1024;
                LODWORD(v106[3]) = v33;
                WORD2(v106[3]) = 2048;
                *(double *)((char *)&v106[3] + 6) = v8;
                _os_log_debug_impl(&dword_1D8A54000, v26, OS_LOG_TYPE_DEBUG, "VideoReceiver [%s] %s:%d VideoReceiver[%p] VRTCP: Failed to retransmit packets ssrc=%u, firstSequenceNumber=%u, bitmask=%u, currentTime=%f", buf, 0x42u);
              }
            }
            v24 += 2;
            --v23;
          }
          while (v23);
LABEL_41:
          a2 = v93;
        }
        goto LABEL_77;
      case 0xCE:
        LODWORD(v98) = 0;
        v97 = 0uLL;
        v55 = *(_DWORD *)(v10 + 12);
        if (v55 == 6)
        {
          v64 = *(_DWORD *)(v10 + 16);
          v65 = *(unsigned __int16 *)(v10 + 20);
          v66 = *(unsigned __int8 *)(v10 + 22);
          v67 = *(unsigned __int8 *)(v10 + 23);
          if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            v89 = VRTraceErrorLogLevelToCSTR();
            v68 = *MEMORY[0x1E0CF2758];
            v69 = *MEMORY[0x1E0CF2758];
            if (*MEMORY[0x1E0CF2748])
            {
              if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136316674;
                *(_QWORD *)&buf[4] = v89;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "_VideoReceiver_ProcessRtcpLossFeedback";
                *(_WORD *)&buf[22] = 1024;
                v105 = 3926;
                LOWORD(v106[0]) = 1024;
                *(_DWORD *)((char *)v106 + 2) = v64;
                HIWORD(v106[0]) = 1024;
                LODWORD(v106[1]) = v65;
                WORD2(v106[1]) = 1024;
                *(_DWORD *)((char *)&v106[1] + 6) = v66;
                WORD1(v106[2]) = 1024;
                HIDWORD(v106[2]) = v67;
                _os_log_impl(&dword_1D8A54000, v68, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d RTCP received loss feedback: frameRTPTimestamp=%u, numReceivedPackets=%u, frameSize=%u, numLostPackets=%u", buf, 0x34u);
              }
            }
            else if (os_log_type_enabled(v69, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136316674;
              *(_QWORD *)&buf[4] = v89;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_VideoReceiver_ProcessRtcpLossFeedback";
              *(_WORD *)&buf[22] = 1024;
              v105 = 3926;
              LOWORD(v106[0]) = 1024;
              *(_DWORD *)((char *)v106 + 2) = v64;
              HIWORD(v106[0]) = 1024;
              LODWORD(v106[1]) = v65;
              WORD2(v106[1]) = 1024;
              *(_DWORD *)((char *)&v106[1] + 6) = v66;
              WORD1(v106[2]) = 1024;
              HIDWORD(v106[2]) = v67;
              _os_log_debug_impl(&dword_1D8A54000, v68, OS_LOG_TYPE_DEBUG, "VideoReceiver [%s] %s:%d RTCP received loss feedback: frameRTPTimestamp=%u, numReceivedPackets=%u, frameSize=%u, numLostPackets=%u", buf, 0x34u);
            }
          }
          v76 = micro();
          v77 = *(_QWORD *)(v6 + 1016);
          *(_QWORD *)buf = 13;
          *(double *)&buf[8] = v76;
          *(_WORD *)&buf[16] = 0;
          buf[18] = 1;
          *(_DWORD *)&buf[19] = 0;
          buf[23] = 0;
          v105 = v64;
          LOWORD(v106[0]) = v65;
          BYTE2(v106[0]) = v66;
          BYTE3(v106[0]) = v67;
          memset((char *)v106 + 4, 0, 48);
          memset((char *)&v106[6] + 4, 0, 120);
          VCRateControlSetStatistics(v77, buf);
          a2 = v93;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            v78 = VRTraceErrorLogLevelToCSTR();
            v79 = *MEMORY[0x1E0CF2758];
            v80 = *MEMORY[0x1E0CF2758];
            if (*MEMORY[0x1E0CF2748])
            {
              if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315906;
                *(_QWORD *)&buf[4] = v78;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "_VideoReceiver_ProcessRtcpPSFBPacket";
                *(_WORD *)&buf[22] = 1024;
                v105 = 3971;
                LOWORD(v106[0]) = 2048;
                *(_QWORD *)((char *)v106 + 2) = a1;
                _os_log_impl(&dword_1D8A54000, v79, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Received PSFB LOSS FB", buf, 0x26u);
              }
            }
            else if (os_log_type_enabled(v80, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136315906;
              *(_QWORD *)&buf[4] = v78;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_VideoReceiver_ProcessRtcpPSFBPacket";
              *(_WORD *)&buf[22] = 1024;
              v105 = 3971;
              LOWORD(v106[0]) = 2048;
              *(_QWORD *)((char *)v106 + 2) = a1;
              _os_log_debug_impl(&dword_1D8A54000, v79, OS_LOG_TYPE_DEBUG, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Received PSFB LOSS FB", buf, 0x26u);
            }
          }
        }
        else if (v55 == 5)
        {
          v52 = a1;
          v53 = v10;
          v54 = 206;
LABEL_52:
          _VideoReceiver_ProcessRtcpLTRAck(v52, v53, v54);
        }
        else
        {
          v70 = (*(_WORD *)v10 & 0x1F) == 2;
          v71 = *(_DWORD *)(a1 + 1248);
          Mutable = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          if (Mutable)
          {
            v73 = Mutable;
            v74 = *(const void **)(a1 + 1232);
            if (v74)
              CFDictionaryAddValue(Mutable, CFSTR("VCSPUUID"), v74);
            *(_DWORD *)buf = v71;
            v75 = CFNumberCreate(allocator, kCFNumberIntType, buf);
            CFDictionaryAddValue(v73, CFSTR("VCASStreamIDs"), v75);
            CFRelease(v75);
            reportingVideoStreamEvent();
            CFRelease(v73);
          }
          else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            v81 = VRTraceErrorLogLevelToCSTR();
            v82 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136315650;
              *(_QWORD *)&buf[4] = v81;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_VideoReceiver_ReportFIRFBReceived";
              *(_WORD *)&buf[22] = 1024;
              v105 = 3939;
              _os_log_error_impl(&dword_1D8A54000, v82, OS_LOG_TYPE_ERROR, "VideoReceiver [%s] %s:%d Failed to create reporting dictionary", buf, 0x1Cu);
            }
          }
          VideoTransmitter_GenerateKeyFrameNow(*(_QWORD *)v6, (unsigned __int16 *)&v97, (2 * v70), 1, 1, 2 * v70);
          a2 = v93;
        }
        goto LABEL_77;
      default:
        goto LABEL_77;
    }
  }
}

void _VideoReceiver_ProcessReceptionReportBlock(uint64_t a1, int a2, _DWORD *a3, unint64_t a4)
{
  uint64_t v7;
  NSObject *v8;
  const char *v9;
  NSObject *v10;
  uint32_t v11;
  int v12;
  uint64_t v13;
  NSObject *v14;
  int v15;
  uint8_t buf[4];
  uint64_t v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v15 = 0;
  if ((RTPGetLocalSSRC(a1, &v15) & 0x80000000) != 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v7 = VRTraceErrorLogLevelToCSTR();
      v8 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        v17 = v7;
        v18 = 2080;
        v19 = "_VideoReceiver_ProcessReceptionReportBlock";
        v20 = 1024;
        v21 = 3872;
        v9 = "VideoReceiver [%s] %s:%d Could not get the local SSRC";
        v10 = v8;
        v11 = 28;
LABEL_12:
        _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, v9, buf, v11);
      }
    }
  }
  else if (a2)
  {
    while (*a3 != v15)
    {
      a3 += 6;
      if (!--a2)
        return;
    }
    v12 = RTCPComputeRoundTripTimeMiddle32((uint64_t)a3, a4);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v13 = VRTraceErrorLogLevelToCSTR();
      v14 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        v17 = v13;
        v18 = 2080;
        v19 = "_VideoReceiver_ProcessReceptionReportBlock";
        v20 = 1024;
        v21 = 3879;
        v22 = 1024;
        v23 = v12;
        v9 = "VideoReceiver [%s] %s:%d RTCP ReceptionReport RTT=%u";
        v10 = v14;
        v11 = 34;
        goto LABEL_12;
      }
    }
  }
}

void _VideoReceiver_ProcessRtcpLTRAck(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t *v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  void (*v12)(_QWORD, uint64_t);
  int v13;
  uint64_t v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  uint64_t v20;
  __int16 v21;
  int v22;
  __int16 v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v5 = (uint64_t *)(a1 + 40384);
  if (a3 == 204)
    v6 = bswap32(*(_DWORD *)(a2 + 12));
  else
    v6 = *(unsigned int *)(a2 + 16);
  v7 = *(unsigned __int8 *)(a1 + 41192);
  if (*(_BYTE *)(a1 + 41192))
    v8 = 7;
  else
    v8 = 8;
  if (v8 <= (int)VRTraceGetErrorLogLevelForModule())
  {
    v9 = VRTraceErrorLogLevelToCSTR();
    if (v7)
    {
      v10 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        goto LABEL_13;
    }
    else
    {
      v10 = *MEMORY[0x1E0CF2758];
      v11 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
LABEL_13:
          v13 = 136316418;
          v14 = v9;
          v15 = 2080;
          v16 = "_VideoReceiver_ProcessRtcpLTRAck";
          v17 = 1024;
          v18 = 3910;
          v19 = 2048;
          v20 = a1;
          v21 = 1024;
          v22 = v6;
          v23 = 1024;
          v24 = a3;
          _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Received APP_LTRP_ACK timestamp=%u, RTCP packet type=%u", (uint8_t *)&v13, 0x32u);
        }
      }
      else if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        v13 = 136316418;
        v14 = v9;
        v15 = 2080;
        v16 = "_VideoReceiver_ProcessRtcpLTRAck";
        v17 = 1024;
        v18 = 3910;
        v19 = 2048;
        v20 = a1;
        v21 = 1024;
        v22 = v6;
        v23 = 1024;
        v24 = a3;
        _os_log_debug_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEBUG, "VideoReceiver [%s] %s:%d VideoReceiver[%p] Received APP_LTRP_ACK timestamp=%u, RTCP packet type=%u", (uint8_t *)&v13, 0x32u);
      }
    }
  }
  if (*(_BYTE *)(a1 + 1183) && (_DWORD)v6)
  {
    v12 = *(void (**)(_QWORD, uint64_t))(a1 + 1432);
    if (v12)
      v12(*(_QWORD *)(a1 + 1416), v6);
    VideoTransmitter_ACKLTRFrame(*v5, v6);
  }
}

void _VideoReceiver_CompleteStreamSwitch(unsigned int *a1, uint64_t a2)
{
  unsigned __int16 *v4;
  void (*v5)(_QWORD, _QWORD, _QWORD);
  unsigned __int16 *v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unsigned __int16 *v11;
  int v17;
  int ErrorLogLevelForModule;
  uint64_t v19;
  NSObject *v20;
  NSObject *v21;
  const char *v22;
  uint32_t v23;
  uint64_t v24;
  NSObject *v25;
  uint64_t v28;
  NSObject *v29;
  uint64_t v30;
  int v31;
  int v32;
  int v33;
  unint64_t v34;
  uint64_t v35;
  unsigned int v36;
  int v37;
  BOOL v38;
  uint64_t v39;
  int v40;
  int v42;
  int v44;
  uint8_t buf[4];
  uint64_t v46;
  __int16 v47;
  const char *v48;
  __int16 v49;
  int v50;
  __int16 v51;
  unsigned int *v52;
  __int16 v53;
  uint64_t v54;
  __int16 v55;
  int v56;
  __int16 v57;
  int v58;
  __int16 v59;
  int v60;
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  v4 = (unsigned __int16 *)(a1 + 10084);
  v5 = (void (*)(_QWORD, _QWORD, _QWORD))*((_QWORD *)a1 + 139);
  if (v5)
    v5(*((_QWORD *)a1 + 136), *((unsigned __int16 *)a1 + 20168), *((unsigned __int16 *)a1 + 20172));
  if (*((_BYTE *)v4 + 6))
  {
    v6 = v4 + 2;
    v7 = 6;
    if (!*(_BYTE *)(a2 + 70))
    {
      v7 = 4;
      v6 = v4;
    }
    if (*v6 != v4[v7])
    {
      v8 = *a1;
      if ((_DWORD)v8)
      {
        v9 = 0;
        v10 = 0;
        while (1)
        {
          v11 = (unsigned __int16 *)&a1[v9 + 364];
          if (v11 != (unsigned __int16 *)a2)
            break;
LABEL_21:
          ++v10;
          v9 += 1080;
          if (v10 >= v8)
            goto LABEL_22;
        }
        _X23 = (char *)&a1[v9 + 3621] + 1;
        __asm { PRFM            #0, [X23] }
        v17 = BYTE1(a1[v9 + 381]);
        ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
        if (v17)
        {
          if (ErrorLogLevelForModule < 7)
            goto LABEL_18;
          v19 = VRTraceErrorLogLevelToCSTR();
          v20 = *MEMORY[0x1E0CF2758];
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            goto LABEL_18;
          *(_DWORD *)buf = 136315906;
          v46 = v19;
          v47 = 2080;
          v48 = "_VideoReceiver_ResetNonTargetStreams";
          v49 = 1024;
          v50 = 3657;
          v51 = 2048;
          v52 = a1;
          v21 = v20;
          v22 = "VideoReceiver [%s] %s:%d VideoReceiver[%p] resetting 1:1 stream";
          v23 = 38;
        }
        else
        {
          if (ErrorLogLevelForModule < 7)
            goto LABEL_18;
          v24 = VRTraceErrorLogLevelToCSTR();
          v25 = *MEMORY[0x1E0CF2758];
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            goto LABEL_18;
          _X8 = _X23 - 69;
          __asm { PRFM            #0, [X8] }
          LODWORD(_X8) = *v11;
          *(_DWORD *)buf = 136316162;
          v46 = v24;
          v47 = 2080;
          v48 = "_VideoReceiver_ResetNonTargetStreams";
          v49 = 1024;
          v50 = 3659;
          v51 = 2048;
          v52 = a1;
          v53 = 1024;
          LODWORD(v54) = (_DWORD)_X8;
          v21 = v25;
          v22 = "VideoReceiver [%s] %s:%d VideoReceiver[%p] resetting non target stream %d";
          v23 = 44;
        }
        _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, v22, buf, v23);
LABEL_18:
        if (*(_QWORD *)&a1[v9 + 392])
        {
          pthread_mutex_lock((pthread_mutex_t *)(a1 + 10146));
          VideoPacketBuffer_NeedRefreshFrame(*(_QWORD *)&a1[v9 + 392], 1, 1, 0x18u);
          pthread_mutex_unlock((pthread_mutex_t *)(a1 + 10146));
        }
        *((_BYTE *)v4 + 1296) = 1;
        RTPResetHandle();
        v8 = *a1;
        goto LABEL_21;
      }
    }
  }
LABEL_22:
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v28 = VRTraceErrorLogLevelToCSTR();
    v29 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v30 = *((_QWORD *)a1 + 144);
      v31 = *v4;
      v32 = v4[4];
      v33 = v4[6];
      *(_DWORD *)buf = 136316930;
      v46 = v28;
      v47 = 2080;
      v48 = "_VideoReceiver_UpdateStreamSwitchContextForCurrentStream";
      v49 = 1024;
      v50 = 3680;
      v51 = 2048;
      v52 = a1;
      v53 = 2048;
      v54 = v30;
      v55 = 1024;
      v56 = v31;
      v57 = 1024;
      v58 = v32;
      v59 = 1024;
      v60 = v33;
      _os_log_impl(&dword_1D8A54000, v29, OS_LOG_TYPE_DEFAULT, "VideoReceiver [%s] %s:%d VideoReceiver[%p] participantId[%llu]: Stream switch completed from (%d), to (%d). New baseStreamID is (%d)", buf, 0x42u);
    }
  }
  *v4 = v4[4];
  *(_DWORD *)(v4 + 1) = *(_DWORD *)(v4 + 5);
  *((_BYTE *)v4 + 6) = 1;
  if (a2)
  {
    v34 = *(unsigned int *)(a2 + 8);
    if (!(_DWORD)v34)
      goto LABEL_40;
    v35 = 0;
    v36 = WORD1(*(_QWORD *)v4);
    v37 = (unsigned __int16)*(_QWORD *)v4;
    v38 = 1;
    do
    {
      if ((*(_QWORD *)v4 & 0x1000000000000) != 0)
      {
        v39 = a2 + 2 * v35;
        v40 = *(unsigned __int16 *)(v39 + 12);
        if (v40 == v37 || v36 == v40)
          break;
        v42 = *(unsigned __int16 *)(v39 + 30);
        if (v42 == v37 || v36 == v42)
          break;
      }
      v38 = ++v35 < v34;
    }
    while (v34 != v35);
    if (v38)
      v44 = 1;
    else
LABEL_40:
      v44 = 0;
    RTPIgnorePacketLossAccounting(*(_QWORD *)(a2 + 48), v44);
  }
  atomic_store(0, (unsigned __int8 *)v4 + 1385);
}

uint64_t OUTLINED_FUNCTION_11_5@<X0>(void *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  *(_QWORD *)(v2 - 24) = a2;
  return objc_msgSend(a1, "payloadSpecOrPayloads");
}

CMSimpleQueueRef *VCAudioIssueDetectorUtil_Create(int a1)
{
  CMSimpleQueueRef *v2;
  CMSimpleQueueRef *v3;
  OSStatus v4;
  int ErrorLogLevelForModule;
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  int v10;
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v2 = (CMSimpleQueueRef *)malloc_type_calloc(1uLL, 0x4650uLL, 0x1020040E3657F74uLL);
  if (!v2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioIssueDetectorUtil_Create_cold_1();
    }
    return 0;
  }
  v3 = v2;
  *((_DWORD *)v2 + 4494) = a1;
  v4 = CMSimpleQueueCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 25, v2 + 2246);
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (v4)
  {
    if (ErrorLogLevelForModule >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioIssueDetectorUtil_Create_cold_3();
    }
    free(v3);
    return 0;
  }
  if (ErrorLogLevelForModule >= 8)
  {
    v6 = VRTraceErrorLogLevelToCSTR();
    v7 = *MEMORY[0x1E0CF2758];
    v8 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        v10 = 136315906;
        v11 = v6;
        v12 = 2080;
        v13 = "VCAudioIssueDetectorUtil_Create";
        v14 = 1024;
        v15 = 1515;
        v16 = 1024;
        v17 = a1;
        _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Audio issue detector created for direction=%d", (uint8_t *)&v10, 0x22u);
      }
    }
    else if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      VCAudioIssueDetectorUtil_Create_cold_2();
    }
  }
  return v3;
}

void VCAudioIssueDetectorUtil_Configure(uint64_t a1, unsigned __int16 *a2)
{
  __int16 v4;
  int *v5;
  const void *v6;
  const void *v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  NSObject *v18;
  int v19;
  int v20;
  const char *v21;
  NSObject *v22;
  uint32_t v23;
  uint64_t v24;
  NSObject *v25;
  int v26;
  uint64_t v27;
  __int16 v28;
  const char *v29;
  __int16 v30;
  int v31;
  __int16 v32;
  _BYTE v33[10];
  _QWORD v34[3];

  v34[2] = *MEMORY[0x1E0C80C00];
  if (!a1 || !a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      return;
    v24 = VRTraceErrorLogLevelToCSTR();
    v25 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      return;
    v26 = 136316162;
    v27 = v24;
    v28 = 2080;
    v29 = "VCAudioIssueDetectorUtil_Configure";
    v30 = 1024;
    v31 = 1528;
    v32 = 2048;
    *(_QWORD *)v33 = a1;
    *(_WORD *)&v33[8] = 2048;
    v34[0] = a2;
    v21 = " [%s] %s:%d Invalid parameter issueDetectorUtil=%p config=%p";
    v22 = v25;
    v23 = 48;
LABEL_22:
    _os_log_error_impl(&dword_1D8A54000, v22, OS_LOG_TYPE_ERROR, v21, (uint8_t *)&v26, v23);
    return;
  }
  if (!a2[1] || (v4 = *a2) == 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      return;
    v17 = VRTraceErrorLogLevelToCSTR();
    v18 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      return;
    v19 = a2[1];
    v20 = *a2;
    v26 = 136316418;
    v27 = v17;
    v28 = 2080;
    v29 = "VCAudioIssueDetectorUtil_Configure";
    v30 = 1024;
    v31 = 1529;
    v32 = 2048;
    *(_QWORD *)v33 = a1;
    *(_WORD *)&v33[8] = 1024;
    LODWORD(v34[0]) = v19;
    WORD2(v34[0]) = 1024;
    *(_DWORD *)((char *)v34 + 6) = v20;
    v21 = " [%s] %s:%d Invalid parameter issueDetectorUtil=%p audioIOSampleRate=%d audioIOSampleCount=%d";
    v22 = v18;
    v23 = 50;
    goto LABEL_22;
  }
  v5 = (int *)(a1 + 17976);
  *(_WORD *)(a1 + 17982) = a2[1];
  *(_WORD *)(a1 + 17980) = v4;
  v6 = *(const void **)(a1 + 17984);
  v7 = (const void *)*((_QWORD *)a2 + 1);
  *(_QWORD *)(a1 + 17984) = v7;
  if (v7)
    CFRetain(v7);
  if (v6)
    CFRelease(v6);
  *(_QWORD *)(a1 + 17992) = *((_QWORD *)a2 + 2);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v8 = VRTraceErrorLogLevelToCSTR();
    v9 = *MEMORY[0x1E0CF2758];
    v10 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        v11 = *v5;
        v12 = *a2;
        v13 = a2[1];
        v26 = 136316418;
        v27 = v8;
        v28 = 2080;
        v29 = "VCAudioIssueDetectorUtil_Configure";
        v30 = 1024;
        v31 = 1535;
        v32 = 1024;
        *(_DWORD *)v33 = v11;
        *(_WORD *)&v33[4] = 1024;
        *(_DWORD *)&v33[6] = v12;
        LOWORD(v34[0]) = 1024;
        *(_DWORD *)((char *)v34 + 2) = v13;
        _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Audio issue detector configured for direction=%d with audioIOSampleCount=%d, audioIOSampleRate=%d", (uint8_t *)&v26, 0x2Eu);
      }
    }
    else if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      v14 = *v5;
      v15 = *a2;
      v16 = a2[1];
      v26 = 136316418;
      v27 = v8;
      v28 = 2080;
      v29 = "VCAudioIssueDetectorUtil_Configure";
      v30 = 1024;
      v31 = 1535;
      v32 = 1024;
      *(_DWORD *)v33 = v14;
      *(_WORD *)&v33[4] = 1024;
      *(_DWORD *)&v33[6] = v15;
      LOWORD(v34[0]) = 1024;
      *(_DWORD *)((char *)v34 + 2) = v16;
      _os_log_debug_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Audio issue detector configured for direction=%d with audioIOSampleCount=%d, audioIOSampleRate=%d", (uint8_t *)&v26, 0x2Eu);
    }
  }
}

void VCAudioIssueDetectorUtil_UpdateRATType(uint64_t a1, int a2)
{
  int *v2;
  uint64_t v3;
  NSObject *v4;
  NSObject *v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = (int *)(a1 + 17976);
    if (*(_DWORD *)(a1 + 17996) != a2)
    {
      *(_DWORD *)(a1 + 17996) = a2;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v3 = VRTraceErrorLogLevelToCSTR();
        v4 = *MEMORY[0x1E0CF2758];
        v5 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
          {
            v6 = v2[5];
            v7 = *v2;
            v10 = 136316162;
            v11 = v3;
            v12 = 2080;
            v13 = "VCAudioIssueDetectorUtil_UpdateRATType";
            v14 = 1024;
            v15 = 1544;
            v16 = 1024;
            v17 = v6;
            v18 = 1024;
            v19 = v7;
            _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Audio issue detector link type updated to %d for direction=%d", (uint8_t *)&v10, 0x28u);
          }
        }
        else if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
        {
          v8 = v2[5];
          v9 = *v2;
          v10 = 136316162;
          v11 = v3;
          v12 = 2080;
          v13 = "VCAudioIssueDetectorUtil_UpdateRATType";
          v14 = 1024;
          v15 = 1544;
          v16 = 1024;
          v17 = v8;
          v18 = 1024;
          v19 = v9;
          _os_log_debug_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Audio issue detector link type updated to %d for direction=%d", (uint8_t *)&v10, 0x28u);
        }
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioIssueDetectorUtil_UpdateRATType_cold_1();
  }
}

void VCAudioIssueDetectorUtil_ProcessCellularNetworkNotification(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  int v3;

  if (a1)
  {
    if (a2)
    {
      v2 = (_QWORD *)(a1 + 14736);
      v3 = *(_DWORD *)(a2 + 4);
      if (!v3)
      {
        if (*(unsigned __int8 *)(a1 + 14737) != *(unsigned __int8 *)(a2 + 60))
        {
          *v2 = 0;
          *(_QWORD *)(a1 + 14744) = 0;
          *(_WORD *)(a1 + 14752) = 0;
          *(_BYTE *)(a1 + 14737) = *(_BYTE *)(a2 + 60);
        }
        *(_WORD *)(a1 + 14738) = *(_WORD *)(a2 + 61);
        *(_WORD *)(a1 + 14740) = *(_WORD *)(a2 + 63);
        *(_BYTE *)(a1 + 14742) = *(_BYTE *)(a2 + 65);
        *(_BYTE *)(a1 + 14743) = *(_BYTE *)(a2 + 66);
        *(_BYTE *)(a1 + 14744) = *(_BYTE *)(a2 + 67);
        *(_BYTE *)(a1 + 14745) = *(_BYTE *)(a2 + 68) != 0;
        *(_BYTE *)(a1 + 14746) = *(_BYTE *)(a2 + 69) != 0;
        *(_WORD *)(a1 + 14748) = *(_WORD *)(a2 + 70);
        *(_BYTE *)(a1 + 14750) = *(_BYTE *)(a2 + 74) != 0;
        *(_BYTE *)v2 = 1;
        v3 = *(_DWORD *)(a2 + 4);
      }
      switch(v3)
      {
        case 2:
          *(_BYTE *)(a1 + 14737) = *(_DWORD *)(a2 + 8);
          *(_BYTE *)(a1 + 14742) = *(_BYTE *)(a2 + 16);
          *(_BYTE *)(a1 + 14744) = *(_BYTE *)(a2 + 18);
          break;
        case 5:
          *(_BYTE *)(a1 + 14737) = *(_DWORD *)(a2 + 8);
          *(_WORD *)(a1 + 14752) = *(_WORD *)(a2 + 12);
          *(_BYTE *)(a1 + 14750) = *(_BYTE *)(a2 + 74) != 0;
          break;
        case 4:
          *(_WORD *)(a1 + 14748) = *(_WORD *)(a2 + 10);
          *(_BYTE *)(a1 + 14746) = *(_BYTE *)(a2 + 8) != 0;
          break;
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioIssueDetectorUtil_ProcessCellularNetworkNotification_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioIssueDetectorUtil_ProcessCellularNetworkNotification_cold_1();
  }
}

void VCAudioIssueDetectorUtil_Finalize(int32x2_t **a1)
{
  int32x2_t *v2;

  if (a1)
  {
    v2 = *a1;
    if (v2)
      _VCAudioIssueDetectorUtil_StateMachine(v2, 5, 5, 0, 0.0);
    *a1 = 0;
  }
}

void _VCAudioIssueDetectorUtil_StateMachine(int32x2_t *a1, int a2, int a3, unsigned int a4, float a5)
{
  int32x2_t *v8;
  int v9;
  int v10;
  unsigned int v11;
  int v12;
  int v13;
  _QWORD v14[2];

  v8 = a1;
  v14[1] = *MEMORY[0x1E0C80C00];
  if (a3 != 5)
  {
    v9 = a1->i32[1] + 1;
    a1->i32[1] = v9;
    a1[23].i32[1] = v9;
  }
  switch(a1->i32[0])
  {
    case 0:
      v14[0] = a1;
      if (a2 == 5)
      {
LABEL_47:
        _VCAudioIssueDetectorUtilDeInit(v14);
      }
      else if (a2)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VCAudioIssueDetectorUtil_StateMachine_cold_2();
        }
      }
      else
      {
LABEL_24:
        _VCAudioIssueDetectorUtil_InitAndUseLatestConfig((uint64_t)a1);
LABEL_26:
        v8->i32[0] = 1;
      }
      break;
    case 1:
      v14[0] = a1;
      switch(a2)
      {
        case 0:
          goto LABEL_24;
        case 1:
        case 3:
          v10 = 2;
          goto LABEL_28;
        case 2:
          v10 = 3;
LABEL_28:
          a1->i32[0] = v10;
          _VCAudioIssueDetectorUtil_UpdateAggregatedStats(a1, a3);
          _VCAudioIssueDetectorUtil_UpdateRmsStats((uint64_t)v8, a5);
          break;
        case 5:
          _VCAudioIssueDetectorUtil_ReportCallEndStatsIfNeeded((uint64_t)a1);
          goto LABEL_47;
        default:
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              _VCAudioIssueDetectorUtil_StateMachine_cold_3();
          }
          break;
      }
      break;
    case 2:
      switch(a2)
      {
        case 0:
          goto LABEL_25;
        case 1:
        case 3:
          _VCAudioIssueDetectorUtil_UpdateAggregatedStats(a1, a3);
          if (v8[2247].i32[0])
          {
            ++v8[19].i32[0];
            if ((a3 & 0xFFFFFFFE) == 2)
              ++v8[19].i32[1];
          }
          else
          {
            ++v8[19].i16[0];
          }
          goto LABEL_50;
        case 2:
          a1->i32[0] = 3;
          _VCAudioIssueDetectorUtil_MonitorAndUpdateRmsSegmentStats((uint64_t)a1, 2, 2);
          _VCAudioIssueDetectorUtil_UpdateAggregatedStats(v8, a3);
          _VCAudioIssueDetectorUtil_UpdateRmsStats((uint64_t)v8, a5);
          _VCAudioIssueDetectorUtilFlushSilenceDistortionStats((uint64_t)v8);
          break;
        case 4:
          a1->i32[0] = 1;
          v12 = 2;
          goto LABEL_44;
        case 5:
          v14[0] = a1;
          a1->i32[0] = 0;
          v13 = 2;
          goto LABEL_46;
        default:
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              _VCAudioIssueDetectorUtil_StateMachine_cold_4();
          }
          break;
      }
      break;
    case 3:
      switch(a2)
      {
        case 0:
LABEL_25:
          bzero(a1, 0x4630uLL);
          v8[2].i32[1] = -956694528;
          v8[4].i32[0] = -956694528;
          v8[8].i32[1] = -956694528;
          v8[10].i32[0] = -956694528;
          goto LABEL_26;
        case 1:
          a1->i32[0] = 2;
          _VCAudioIssueDetectorUtil_MonitorAndUpdateRmsSegmentStats((uint64_t)a1, 1, 3);
          _VCAudioIssueDetectorUtil_UpdateAggregatedStats(v8, a3);
          _VCAudioIssueDetectorUtil_MonitorContinuousSpeechDistortion(v8, a3);
          _VCAudioIssueDetectorUtil_MonitorAverageSpeechDistortion(v8);
LABEL_50:
          _VCAudioIssueDetectorUtil_UpdateRmsStats((uint64_t)v8, a5);
          break;
        case 2:
        case 3:
          _VCAudioIssueDetectorUtil_UpdateAggregatedStats(a1, a3);
          _VCAudioIssueDetectorUtil_MonitorContinuousSpeechDistortion(v8, a3);
          _VCAudioIssueDetectorUtil_UpdateRmsStats((uint64_t)v8, a5);
          if (a4)
          {
            v11 = v8[23].u16[1];
            if (v11 != a4 && (a4 > 0x960 || v11 <= 0x960))
              v8[23].i16[1] = a4;
          }
          break;
        case 4:
          _VCAudioIssueDetectorUtil_MonitorContinuousSpeechDistortion(a1, a3);
          _VCAudioIssueDetectorUtil_MonitorAverageSpeechDistortion(v8);
          v8->i32[0] = 1;
          a1 = v8;
          v12 = 3;
LABEL_44:
          _VCAudioIssueDetectorUtil_MonitorAndUpdateRmsSegmentStats((uint64_t)a1, 4, v12);
          _VCAudioIssueDetectorUtilFlushSilenceDistortionStats((uint64_t)v8);
          _VCAudioIssueDetectorUtil_StopZerosMonitoring((uint64_t)v8);
          _VCAudioIssueDetectorUtil_FlushRmsStats((uint64_t)v8);
          _VCAudioIssueDetectorUtil_ReportCallEndStatsIfNeeded((uint64_t)v8);
          VCAudioIssueDetectorUtil_FlushLogEvents((uint64_t)v8);
          break;
        case 5:
          v14[0] = a1;
          _VCAudioIssueDetectorUtil_MonitorContinuousSpeechDistortion(a1, a3);
          _VCAudioIssueDetectorUtil_MonitorAverageSpeechDistortion(v8);
          v8->i32[0] = 0;
          a1 = v8;
          v13 = 3;
LABEL_46:
          _VCAudioIssueDetectorUtil_MonitorAndUpdateRmsSegmentStats((uint64_t)a1, 5, v13);
          _VCAudioIssueDetectorUtilFlushSilenceDistortionStats((uint64_t)v8);
          _VCAudioIssueDetectorUtil_StopZerosMonitoring((uint64_t)v8);
          _VCAudioIssueDetectorUtil_FlushRmsStats((uint64_t)v8);
          _VCAudioIssueDetectorUtil_ReportCallEndStatsIfNeeded((uint64_t)v8);
          VCAudioIssueDetectorUtil_FlushLogEvents((uint64_t)v8);
          goto LABEL_47;
        default:
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              _VCAudioIssueDetectorUtil_StateMachine_cold_5();
          }
          break;
      }
      break;
    default:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCAudioIssueDetectorUtil_StateMachine_cold_1();
      }
      break;
  }
}

void VCAudioIssueDetectorUtil_Start(int32x2_t *a1)
{
  if (a1)
  {
    _VCAudioIssueDetectorUtil_StateMachine(a1, 0, 5, 0, 0.0);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioIssueDetectorUtil_Start_cold_1();
  }
}

void VCAudioIssueDetectorUtil_Stop(int32x2_t *a1)
{
  if (a1)
  {
    _VCAudioIssueDetectorUtil_StateMachine(a1, 4, 5, 0, 0.0);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioIssueDetectorUtil_Stop_cold_1();
  }
}

void VCAudioIssueDetectorUtil_ProcessFrame(int32x2_t *a1, unsigned __int16 *a2)
{
  int v4;
  char v5;
  int v6;
  __int32 v7;
  int v8;
  unsigned int v9;
  __int32 v10;
  uint64_t v11;
  NSObject *v12;
  char v13;
  char *v14;
  char *v15;
  _DWORD *v16;
  int v17;
  int v18;
  uint64_t v19;
  int *v20;
  uint64_t v21;
  NSObject *v22;
  int v23;
  int v24;
  uint64_t v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  __int32 v31;
  __int16 v32;
  int v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioIssueDetectorUtil_ProcessFrame_cold_1();
    }
    return;
  }
  if (!a1->i32[0])
    _VCAudioIssueDetectorUtil_StateMachine(a1, 0, 5, 0, 0.0);
  if (!a2[4])
  {
    v6 = 3;
    v5 = 1;
    v4 = 4;
    goto LABEL_20;
  }
  if (a1[2247].i32[0] == 1)
  {
    v4 = *((unsigned __int8 *)a2 + 20);
    if (*((_BYTE *)a2 + 18))
    {
      if (*((_BYTE *)a2 + 20))
        v4 = 3;
      else
        v4 = 2;
      v5 = 1;
      goto LABEL_17;
    }
  }
  else
  {
    if (*((_BYTE *)a2 + 18))
    {
      v5 = 1;
      v4 = 2;
LABEL_17:
      v6 = 1;
      goto LABEL_20;
    }
    v4 = 0;
  }
  v5 = 0;
  v6 = 2;
LABEL_20:
  _VCAudioIssueDetectorUtil_StateMachine(a1, v6, v4, a2[2], *((float *)a2 + 3));
  v7 = *a2;
  if (a1[22].i32[1] != v7)
    a1[22].i32[1] = v7;
  v8 = *((_DWORD *)a2 + 1);
  if ((_WORD)v8)
  {
    v9 = a1[23].u16[1];
    if (v9 != (unsigned __int16)v8 && ((unsigned __int16)v8 > 0x960u || v9 <= 0x960))
      a1[23].i16[1] = v8;
  }
  v10 = a2[8];
  if (a2[8] && a1[23].u16[0] != v10)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v11 = VRTraceErrorLogLevelToCSTR();
      v12 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v24 = 136315906;
        v25 = v11;
        v26 = 2080;
        v27 = "_VCAudioIssueDetectorUtil_UpdateCodecSampleRate";
        v28 = 1024;
        v29 = 844;
        v30 = 1024;
        v31 = v10;
        _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Audio issue detector update codecSampleRate=%d", (uint8_t *)&v24, 0x22u);
      }
    }
    a1[23].i16[0] = v10;
    v7 = *a2;
    v8 = *((_DWORD *)a2 + 1);
  }
  if (v8)
    v13 = v5;
  else
    v13 = 1;
  if ((v13 & 1) == 0)
  {
    v14 = (char *)&a1[41] + 4;
    v15 = (char *)&a1[41] + 12 * a1[89].u8[4] + 4;
    v18 = *((_DWORD *)v15 + 2);
    v16 = v15 + 8;
    v17 = v18;
    if (v18 && *(unsigned __int16 *)&v14[12 * a1[89].u8[4]] == v7 && *(_DWORD *)&v14[12 * a1[89].u8[4] + 4] == v8)
    {
      *v16 = v17 + 1;
    }
    else
    {
      v19 = 0;
      v20 = (int *)&a1[42] + 1;
      do
      {
        if (!*v20)
        {
          *((_WORD *)v20 - 4) = v7;
          *(v20 - 1) = v8;
          v23 = 1;
LABEL_51:
          *v20 = v23;
          a1[89].i8[4] = v19;
          return;
        }
        if (*((unsigned __int16 *)v20 - 4) == v7 && *(v20 - 1) == v8)
        {
          v23 = *v20 + 1;
          goto LABEL_51;
        }
        ++v19;
        v20 += 3;
      }
      while (v19 != 32);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v21 = VRTraceErrorLogLevelToCSTR();
        v22 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v24 = 136316162;
          v25 = v21;
          v26 = 2080;
          v27 = "_VCAudioIssueDetectorUtil_AddOrUpdateBitRateCount";
          v28 = 1024;
          v29 = 1405;
          v30 = 1024;
          v31 = v7;
          v32 = 1024;
          v33 = v8;
          _os_log_impl(&dword_1D8A54000, v22, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d BitRate counter out of entries for payload=%d, bitRate=%d", (uint8_t *)&v24, 0x28u);
        }
      }
    }
  }
}

void VCAudioIssueDetectorUtil_FlushLogEvents(uint64_t a1)
{
  opaqueCMSimpleQueue *v2;
  _DWORD *v3;
  _DWORD *v4;
  int v5;
  os_log_t *v6;
  uint64_t v7;
  os_log_t v8;
  int v9;
  int v10;
  NSObject *v11;
  const char *v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  os_log_t v16;
  int v17;
  int v18;
  uint64_t v19;
  os_log_t v20;
  int v21;
  int v22;
  uint64_t v23;
  os_log_t v24;
  int v25;
  int v26;
  uint64_t v27;
  os_log_t v28;
  int v29;
  int v30;
  uint64_t v31;
  os_log_t v32;
  int v33;
  int v34;
  uint64_t v35;
  os_log_t v36;
  int v37;
  int v38;
  uint64_t v39;
  os_log_t v40;
  int v41;
  int v42;
  uint64_t v43;
  os_log_t v44;
  int v45;
  int v46;
  uint32_t v47;
  uint64_t v48;
  os_log_t v49;
  int v50;
  int v51;
  int v52;
  uint64_t v53;
  os_log_t v54;
  int v55;
  int v56;
  int v57;
  uint64_t v58;
  os_log_t v59;
  int v60;
  const char *v61;
  const char *v62;
  uint64_t v63;
  os_log_t v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  int v72;
  uint64_t v73;
  os_log_t v74;
  int v75;
  int v76;
  int v77;
  int v78;
  int v79;
  int v80;
  int v81;
  int v82;
  int v83;
  int v84;
  int v85;
  int v86;
  const char *v87;
  int v88;
  int v89;
  int v90;
  int v91;
  int v92;
  int v93;
  int v94;
  uint8_t buf[4];
  uint64_t v96;
  __int16 v97;
  const char *v98;
  __int16 v99;
  int v100;
  __int16 v101;
  int v102;
  __int16 v103;
  int v104;
  __int16 v105;
  int v106;
  __int16 v107;
  int v108;
  __int16 v109;
  int v110;
  __int16 v111;
  int v112;
  __int16 v113;
  int v114;
  __int16 v115;
  int v116;
  __int16 v117;
  int v118;
  __int16 v119;
  int v120;
  __int16 v121;
  int v122;
  __int16 v123;
  int v124;
  __int16 v125;
  int v126;
  __int16 v127;
  const char *v128;
  __int16 v129;
  const char *v130;
  __int16 v131;
  const char *v132;
  uint64_t v133;

  v133 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = *(opaqueCMSimpleQueue **)(a1 + 17968);
    if (v2)
    {
      v3 = CMSimpleQueueDequeue(v2);
      if (v3)
      {
        v4 = v3;
        v5 = *(_DWORD *)(a1 + 17976);
        v6 = (os_log_t *)MEMORY[0x1E0CF2758];
        do
        {
          switch(*v4)
          {
            case 0:
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v7 = VRTraceErrorLogLevelToCSTR();
                v8 = *v6;
                if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
                {
                  v9 = v4[1];
                  v10 = v4[2];
                  *(_DWORD *)buf = 136316418;
                  v96 = v7;
                  v97 = 2080;
                  v98 = "_VCAudioIssueDetectorUtil_HandleLogEvents";
                  v99 = 1024;
                  v100 = 1451;
                  v101 = 1024;
                  v102 = v5;
                  v103 = 1024;
                  v104 = v9;
                  v105 = 1024;
                  v106 = v10;
                  v11 = v8;
                  v12 = " [%s] %s:%d Audio issue detector: DistortionEvent: Continuous speech loss: direction=%d, disorti"
                        "onTimeMs=%d, distortionDurationMs=%d";
                  goto LABEL_36;
                }
              }
              break;
            case 1:
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v15 = VRTraceErrorLogLevelToCSTR();
                v16 = *v6;
                if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
                {
                  v17 = v4[1];
                  v18 = v4[2];
                  *(_DWORD *)buf = 136316418;
                  v96 = v15;
                  v97 = 2080;
                  v98 = "_VCAudioIssueDetectorUtil_HandleLogEvents";
                  v99 = 1024;
                  v100 = 1454;
                  v101 = 1024;
                  v102 = v5;
                  v103 = 1024;
                  v104 = v17;
                  v105 = 1024;
                  v106 = v18;
                  v11 = v16;
                  v12 = " [%s] %s:%d Audio issue detector: DistortionEvent: Average speech loss: direction=%d, disortionT"
                        "imeMs=%d, distortionDurationMs=%d";
                  goto LABEL_36;
                }
              }
              break;
            case 2:
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v19 = VRTraceErrorLogLevelToCSTR();
                v20 = *v6;
                if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
                {
                  v21 = v4[1];
                  v22 = v4[2];
                  *(_DWORD *)buf = 136316418;
                  v96 = v19;
                  v97 = 2080;
                  v98 = "_VCAudioIssueDetectorUtil_HandleLogEvents";
                  v99 = 1024;
                  v100 = 1457;
                  v101 = 1024;
                  v102 = v5;
                  v103 = 1024;
                  v104 = v21;
                  v105 = 1024;
                  v106 = v22;
                  v11 = v20;
                  v12 = " [%s] %s:%d Audio issue detector: DistortionEvent: Downlink link broken: direction=%d, disortion"
                        "TimeMs=%d, distortionDurationMs=%d";
                  goto LABEL_36;
                }
              }
              break;
            case 3:
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v23 = VRTraceErrorLogLevelToCSTR();
                v24 = *v6;
                if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
                {
                  v25 = v4[1];
                  v26 = v4[2];
                  *(_DWORD *)buf = 136316418;
                  v96 = v23;
                  v97 = 2080;
                  v98 = "_VCAudioIssueDetectorUtil_HandleLogEvents";
                  v99 = 1024;
                  v100 = 1460;
                  v101 = 1024;
                  v102 = v5;
                  v103 = 1024;
                  v104 = v25;
                  v105 = 1024;
                  v106 = v26;
                  v11 = v24;
                  v12 = " [%s] %s:%d Audio issue detector: DistortionEvent: Downlink silence > 5s: direction=%d, disortio"
                        "nTimeMs=%d, distortionDurationMs=%d";
                  goto LABEL_36;
                }
              }
              break;
            case 4:
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v27 = VRTraceErrorLogLevelToCSTR();
                v28 = *v6;
                if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
                {
                  v29 = v4[1];
                  v30 = v4[2];
                  *(_DWORD *)buf = 136316418;
                  v96 = v27;
                  v97 = 2080;
                  v98 = "_VCAudioIssueDetectorUtil_HandleLogEvents";
                  v99 = 1024;
                  v100 = 1463;
                  v101 = 1024;
                  v102 = v5;
                  v103 = 1024;
                  v104 = v29;
                  v105 = 1024;
                  v106 = v30;
                  v11 = v28;
                  v12 = " [%s] %s:%d Audio issue detector: DistortionEvent: Uplink silence > 5s: direction=%d, disortionT"
                        "imeMs=%d, distortionDurationMs=%d";
                  goto LABEL_36;
                }
              }
              break;
            case 5:
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v31 = VRTraceErrorLogLevelToCSTR();
                v32 = *v6;
                if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
                {
                  v33 = v4[1];
                  v34 = v4[2];
                  *(_DWORD *)buf = 136316418;
                  v96 = v31;
                  v97 = 2080;
                  v98 = "_VCAudioIssueDetectorUtil_HandleLogEvents";
                  v99 = 1024;
                  v100 = 1466;
                  v101 = 1024;
                  v102 = v5;
                  v103 = 1024;
                  v104 = v33;
                  v105 = 1024;
                  v106 = v34;
                  v11 = v32;
                  v12 = " [%s] %s:%d Audio issue detector: DistortionEvent: Continuous zero pcm samples > 5s in uplink: d"
                        "irection=%d, disortionTimeMs=%d, distortionDurationMs=%d";
                  goto LABEL_36;
                }
              }
              break;
            case 6:
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v35 = VRTraceErrorLogLevelToCSTR();
                v36 = *v6;
                if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
                {
                  v37 = v4[1];
                  v38 = v4[2];
                  *(_DWORD *)buf = 136316418;
                  v96 = v35;
                  v97 = 2080;
                  v98 = "_VCAudioIssueDetectorUtil_HandleLogEvents";
                  v99 = 1024;
                  v100 = 1469;
                  v101 = 1024;
                  v102 = v5;
                  v103 = 1024;
                  v104 = v37;
                  v105 = 1024;
                  v106 = v38;
                  v11 = v36;
                  v12 = " [%s] %s:%d Audio issue detector: DistortionEvent: Continuous zero pcm samples > 5s in downlink:"
                        " direction=%d, disortionTimeMs=%d, distortionDurationMs=%d";
                  goto LABEL_36;
                }
              }
              break;
            case 7:
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v39 = VRTraceErrorLogLevelToCSTR();
                v40 = *v6;
                if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
                {
                  v41 = v4[1];
                  v42 = v4[2];
                  *(_DWORD *)buf = 136316418;
                  v96 = v39;
                  v97 = 2080;
                  v98 = "_VCAudioIssueDetectorUtil_HandleLogEvents";
                  v99 = 1024;
                  v100 = 1472;
                  v101 = 1024;
                  v102 = v5;
                  v103 = 1024;
                  v104 = v41;
                  v105 = 1024;
                  v106 = v42;
                  v11 = v40;
                  v12 = " [%s] %s:%d Audio issue detector: DistortionEvent: Low energy in uplink: direction=%d, disortion"
                        "TimeMs=%d, distortionDurationMs=%d";
                  goto LABEL_36;
                }
              }
              break;
            case 8:
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v43 = VRTraceErrorLogLevelToCSTR();
                v44 = *v6;
                if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
                {
                  v45 = v4[1];
                  v46 = v4[2];
                  *(_DWORD *)buf = 136316418;
                  v96 = v43;
                  v97 = 2080;
                  v98 = "_VCAudioIssueDetectorUtil_HandleLogEvents";
                  v99 = 1024;
                  v100 = 1475;
                  v101 = 1024;
                  v102 = v5;
                  v103 = 1024;
                  v104 = v45;
                  v105 = 1024;
                  v106 = v46;
                  v11 = v44;
                  v12 = " [%s] %s:%d Audio issue detector: DistortionEvent: Low energy in downlink: direction=%d, disorti"
                        "onTimeMs=%d, distortionDurationMs=%d";
LABEL_36:
                  v47 = 46;
                  goto LABEL_37;
                }
              }
              break;
            case 9:
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v48 = VRTraceErrorLogLevelToCSTR();
                v49 = *v6;
                if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
                {
                  v50 = v4[1];
                  v51 = v4[2];
                  v52 = v4[3];
                  *(_DWORD *)buf = 136316674;
                  v96 = v48;
                  v97 = 2080;
                  v98 = "_VCAudioIssueDetectorUtil_HandleLogEvents";
                  v99 = 1024;
                  v100 = 1478;
                  v101 = 1024;
                  v102 = v5;
                  v103 = 1024;
                  v104 = v50;
                  v105 = 1024;
                  v106 = v51;
                  v107 = 1024;
                  v108 = v52;
                  v11 = v49;
                  v12 = " [%s] %s:%d Audio issue detector: DistortionEvent: High noise floor in uplink: direction=%d, dis"
                        "ortionTimeMs=%d, distortionDurationMs=%d, segmentRmsMeanDb=%d";
                  goto LABEL_46;
                }
              }
              break;
            case 0xA:
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v53 = VRTraceErrorLogLevelToCSTR();
                v54 = *v6;
                if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
                {
                  v55 = v4[1];
                  v56 = v4[2];
                  v57 = v4[3];
                  *(_DWORD *)buf = 136316674;
                  v96 = v53;
                  v97 = 2080;
                  v98 = "_VCAudioIssueDetectorUtil_HandleLogEvents";
                  v99 = 1024;
                  v100 = 1481;
                  v101 = 1024;
                  v102 = v5;
                  v103 = 1024;
                  v104 = v55;
                  v105 = 1024;
                  v106 = v56;
                  v107 = 1024;
                  v108 = v57;
                  v11 = v54;
                  v12 = " [%s] %s:%d Audio issue detector: DistortionEvent: High noise floor in downlink: direction=%d, d"
                        "isortionTimeMs=%d, distortionDurationMs=%d, segmentRmsMeanDb=%d";
LABEL_46:
                  v47 = 52;
                  goto LABEL_37;
                }
              }
              break;
            case 0xB:
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v58 = VRTraceErrorLogLevelToCSTR();
                v59 = *v6;
                if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
                {
                  v83 = v4[1];
                  v84 = v4[2];
                  v85 = *((unsigned __int16 *)v4 + 12);
                  v86 = *((unsigned __int16 *)v4 + 13);
                  v60 = v4[5];
                  v88 = v4[4];
                  v89 = v4[7];
                  v92 = v4[10];
                  v93 = v4[9];
                  v90 = v4[8];
                  v91 = v4[11];
                  v94 = v4[12];
                  v87 = _VCAudioIssueDetectorUtil_PayloadBitRateString(*((unsigned __int16 *)v4 + 86), v4[44]);
                  v61 = _VCAudioIssueDetectorUtil_PayloadBitRateString(*((unsigned __int16 *)v4 + 92), v4[47]);
                  v62 = _VCAudioIssueDetectorUtil_PayloadBitRateString(*((unsigned __int16 *)v4 + 98), v4[50]);
                  *(_DWORD *)buf = 136319746;
                  v96 = v58;
                  v97 = 2080;
                  v98 = "_VCAudioIssueDetectorUtil_HandleLogEvents";
                  v99 = 1024;
                  v100 = 1493;
                  v101 = 1024;
                  v102 = v5;
                  v103 = 1024;
                  v104 = v83;
                  v105 = 1024;
                  v106 = v84;
                  v107 = 1024;
                  v108 = v60;
                  v6 = (os_log_t *)MEMORY[0x1E0CF2758];
                  v109 = 1024;
                  v110 = v85;
                  v111 = 1024;
                  v112 = v86;
                  v113 = 1024;
                  v114 = v88;
                  v115 = 1024;
                  v116 = v89;
                  v117 = 1024;
                  v118 = v90;
                  v119 = 1024;
                  v120 = v92;
                  v121 = 1024;
                  v122 = v91;
                  v123 = 1024;
                  v124 = v93;
                  v125 = 1024;
                  v126 = v94;
                  v127 = 2080;
                  v128 = v87;
                  v129 = 2080;
                  v130 = v61;
                  v131 = 2080;
                  v132 = v62;
                  v11 = v59;
                  v12 = " [%s] %s:%d Audio issue detector: CallEndEvent: Call end stats: direction=%d, disortionTimeMs=%d"
                        ", distortionDurationMs=%d, payloadType=%d, codecSampleRate=%d, bitRateInBps=%d, ratType=%d, tota"
                        "lFrameCount=%d, speechFrameCount=%d, speechBadFrameCount=%d, speechLostFrameCount=%d, silenceFra"
                        "meCount=%d, noDataFrameCount=%d, top1UsedBitrate=%s, top2UsedBitrate=%s, top3UsedBitrate=%s";
                  v47 = 136;
                  goto LABEL_37;
                }
              }
              break;
            case 0xC:
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v63 = VRTraceErrorLogLevelToCSTR();
                v64 = *v6;
                if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
                {
                  v65 = v4[1];
                  v66 = v4[2];
                  v67 = v4[3];
                  v68 = v4[4];
                  v69 = v4[5];
                  v70 = v4[6];
                  v72 = v4[7];
                  v71 = v4[8];
                  *(_DWORD *)buf = 136317954;
                  v96 = v63;
                  v97 = 2080;
                  v98 = "_VCAudioIssueDetectorUtil_HandleLogEvents";
                  v99 = 1024;
                  v100 = 1484;
                  v101 = 1024;
                  v102 = v5;
                  v103 = 1024;
                  v104 = v65;
                  v105 = 1024;
                  v106 = v66;
                  v107 = 1024;
                  v108 = v67;
                  v109 = 1024;
                  v110 = v69;
                  v111 = 1024;
                  v112 = v68;
                  v113 = 1024;
                  v114 = v70;
                  v115 = 1024;
                  v116 = v71;
                  v117 = 1024;
                  v118 = v72;
                  v11 = v64;
                  v12 = " [%s] %s:%d Audio issue detector: CallEndEvent: Speech state rms stats: direction=%d, disortionT"
                        "imeMs=%d, distortionDurationMs=%d, rmsMeanDb=%d, rmsMinDb=%d, rmsMaxDb=%d, rmsSegmentMeanDb=%d, "
                        "rmsSegmentMinDb=%d, rmsSegmentMaxDb=%d";
                  goto LABEL_56;
                }
              }
              break;
            case 0xD:
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v73 = VRTraceErrorLogLevelToCSTR();
                v74 = *v6;
                if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
                {
                  v75 = v4[1];
                  v76 = v4[2];
                  v77 = v4[3];
                  v78 = v4[4];
                  v79 = v4[5];
                  v80 = v4[6];
                  v82 = v4[7];
                  v81 = v4[8];
                  *(_DWORD *)buf = 136317954;
                  v96 = v73;
                  v97 = 2080;
                  v98 = "_VCAudioIssueDetectorUtil_HandleLogEvents";
                  v99 = 1024;
                  v100 = 1487;
                  v101 = 1024;
                  v102 = v5;
                  v103 = 1024;
                  v104 = v75;
                  v105 = 1024;
                  v106 = v76;
                  v107 = 1024;
                  v108 = v77;
                  v109 = 1024;
                  v110 = v79;
                  v111 = 1024;
                  v112 = v78;
                  v113 = 1024;
                  v114 = v80;
                  v115 = 1024;
                  v116 = v81;
                  v117 = 1024;
                  v118 = v82;
                  v11 = v74;
                  v12 = " [%s] %s:%d Audio issue detector: CallEndEvent: Silence state rms stats: direction=%d, disortion"
                        "TimeMs=%d, distortionDurationMs=%d, rmsMeanDb=%d, rmsMinDb=%d, rmsMaxDb=%d, rmsSegmentMeanDb=%d,"
                        " rmsSegmentMinDb=%d, rmsSegmentMaxDb=%d";
LABEL_56:
                  v47 = 82;
LABEL_37:
                  _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, v12, buf, v47);
                }
              }
              break;
            default:
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                v13 = VRTraceErrorLogLevelToCSTR();
                v14 = *v6;
                if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136315906;
                  v96 = v13;
                  v97 = 2080;
                  v98 = "_VCAudioIssueDetectorUtil_HandleLogEvents";
                  v99 = 1024;
                  v100 = 1496;
                  v101 = 1024;
                  v102 = 1496;
                  _os_log_error_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_ERROR, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VCAudioIssueDetectorUtil.c:%d: Unexpected log event", buf, 0x22u);
                }
              }
              break;
          }
          v4 = CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 17968));
        }
        while (v4);
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioIssueDetectorUtil_FlushLogEvents_cold_1();
  }
}

uint64_t VCAudioIssueDetectorUtil_RtpPacketIndication(uint64_t a1)
{
  uint64_t result;

  if (a1)
  {
    result = 0;
    *(_DWORD *)(a1 + 14728) = *(_DWORD *)(a1 + 4) * *(unsigned __int16 *)(a1 + 8);
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioIssueDetectorUtil_RtpPacketIndication_cold_1();
    }
    return 4;
  }
  return result;
}

uint64_t VCAudioIssueDetectorUtil_RtpPacketTimeoutIndication(uint64_t a1)
{
  int v2;
  unsigned int v3;
  int v4;
  uint64_t v5;
  uint64_t result;

  if (a1)
  {
    v2 = *(_DWORD *)(a1 + 4) * *(unsigned __int16 *)(a1 + 8);
    v3 = v2 - *(_DWORD *)(a1 + 14728);
    *(_DWORD *)(a1 + 14732) = v3;
    if (v3 >= 0x1389 && !_VCAudioIssueDetectorUtil_IsReportingQueueFull(*(opaqueCMSimpleQueue **)(a1 + 17968)))
    {
      v4 = *(unsigned __int16 *)(a1 + 720);
      *(_WORD *)(a1 + 720) = v4 + 1;
      v5 = a1
         + 560
         * (unsigned __int16)(v4
                            - 25
                            * ((((unsigned __int16)(v4 - ((18351 * v4) >> 16)) >> 1)
                              + ((18351 * v4) >> 16)) >> 4));
      *(_DWORD *)(v5 + 724) = 14;
      *(_QWORD *)(v5 + 728) = *(_QWORD *)(a1 + 14728);
      _VCAudioIssueDetectorUtil_EnqueueDistortion(a1, (unsigned int *)(v5 + 724));
    }
    result = 0;
    *(_DWORD *)(a1 + 14728) = v2;
    *(_DWORD *)(a1 + 14732) = 0;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioIssueDetectorUtil_RtpPacketTimeoutIndication_cold_1();
    }
    return 4;
  }
  return result;
}

void _VCAudioIssueDetectorUtil_InitAndUseLatestConfig(uint64_t a1)
{
  int *v2;
  unsigned int v3;
  uint64_t v4;
  NSObject *v5;
  int v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v2 = (int *)(a1 + 17976);
  bzero((void *)a1, 0x4630uLL);
  *(_DWORD *)(a1 + 20) = -956694528;
  *(_DWORD *)(a1 + 32) = -956694528;
  *(_DWORD *)(a1 + 68) = -956694528;
  *(_DWORD *)(a1 + 80) = -956694528;
  if (*((_WORD *)v2 + 3) && (v3 = *((unsigned __int16 *)v2 + 2), *((_WORD *)v2 + 2)))
  {
    *(_WORD *)(a1 + 8) = 0x3E8 / (*((unsigned __int16 *)v2 + 3) / v3);
    *(_WORD *)(a1 + 136) = v3;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      v6 = *((unsigned __int16 *)v2 + 3);
      v7 = *((unsigned __int16 *)v2 + 2);
      v8 = *v2;
      v9 = 136316418;
      v10 = v4;
      v11 = 2080;
      v12 = "_VCAudioIssueDetectorUtil_InitAndUseLatestConfig";
      v13 = 1024;
      v14 = 1155;
      v15 = 1024;
      v16 = v6;
      v17 = 1024;
      v18 = v7;
      v19 = 1024;
      v20 = v8;
      _os_log_error_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_ERROR, " [%s] %s:%d Unexpected configuration audioIOSampleRate=%d, audioIOSampleCount=%d for direction=%d", (uint8_t *)&v9, 0x2Eu);
    }
  }
}

void _VCAudioIssueDetectorUtilDeInit(_QWORD *a1)
{
  _QWORD *v2;
  void *v3;
  const void *v4;

  if (a1 && (v2 = (_QWORD *)*a1) != 0 && (v3 = (void *)v2[2246]) != 0)
  {
    free(v3);
    v2[2246] = 0;
    v4 = (const void *)v2[2248];
    if (v4)
      CFRelease(v4);
    *a1 = 0;
    free(v2);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCAudioIssueDetectorUtilDeInit_cold_1();
  }
}

_DWORD *_VCAudioIssueDetectorUtil_UpdateAggregatedStats(_DWORD *result, int a2)
{
  _DWORD *v2;

  if ((*result - 1) >= 2)
  {
    if (*result != 3)
      return result;
    ++result[48];
    if (a2 == 4)
    {
      v2 = result + 51;
    }
    else
    {
      if (a2 != 1)
        return result;
      v2 = result + 50;
    }
  }
  else
  {
    ++result[49];
    if (a2 != 4)
      return result;
    v2 = result + 52;
  }
  ++*v2;
  return result;
}

void _VCAudioIssueDetectorUtil_UpdateRmsStats(uint64_t a1, float a2)
{
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  float v8;
  int v9;
  float v10;
  int v11;
  float v12;
  float v13;

  *(float *)(a1 + 140) = log10f(a2) * 20.0;
  v4 = *(unsigned __int16 *)(a1 + 17980);
  *(_WORD *)(a1 + 136) = v4;
  *(double *)(a1 + 144) = *(double *)(a1 + 144) + (float)((float)(a2 * a2) * (float)v4);
  *(_QWORD *)(a1 + 128) += v4;
  if (a2 == 0.0)
  {
    v5 = *(_DWORD *)(a1 + 116);
    if (v5 == 1)
    {
      *(_DWORD *)(a1 + 124) = *(_DWORD *)(a1 + 4) * *(unsigned __int16 *)(a1 + 8) - *(_DWORD *)(a1 + 120);
    }
    else if (!v5)
    {
      v6 = *(_DWORD *)a1;
      *(_QWORD *)(a1 + 120) = *(_DWORD *)(a1 + 4) * *(unsigned __int16 *)(a1 + 8);
      *(_DWORD *)(a1 + 112) = v6;
      *(_DWORD *)(a1 + 116) = 1;
    }
  }
  else
  {
    v7 = *(_DWORD *)a1;
    _VCAudioIssueDetectorUtil_StopZerosMonitoring(a1);
    if (v7 == 2)
    {
      v11 = *(unsigned __int16 *)(a1 + 196);
      *(_DWORD *)(a1 + 44) = v11;
      v12 = *(float *)(a1 + 140);
      v13 = *(float *)(a1 + 16);
      if (v12 <= *(float *)(a1 + 20))
      {
        if (v12 < *(float *)(a1 + 24))
          *(float *)(a1 + 24) = v12;
      }
      else
      {
        *(float *)(a1 + 20) = v12;
      }
      *(float *)(a1 + 16) = (float)(v12 + (float)(v13 * (float)(v11 - 1))) / (float)v11;
    }
    else if (v7 == 3)
    {
      v8 = *(float *)(a1 + 140);
      if (v8 > -75.0)
      {
        v9 = *(_DWORD *)(a1 + 92) + 1;
        *(_DWORD *)(a1 + 92) = v9;
        v10 = *(float *)(a1 + 64);
        if (v8 <= *(float *)(a1 + 68))
        {
          if (v8 < *(float *)(a1 + 72))
            *(float *)(a1 + 72) = v8;
        }
        else
        {
          *(float *)(a1 + 68) = v8;
        }
        *(float *)(a1 + 64) = (float)(v8 + (float)(v10 * (float)((unsigned __int16)v9 - 1)))
                            / (float)(unsigned __int16)v9;
      }
    }
  }
}

void _VCAudioIssueDetectorUtil_ReportCallEndStatsIfNeeded(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  const __CFAllocator *v3;
  __CFDictionary *Mutable;
  __CFDictionary *v5;
  CFNumberRef v6;
  CFNumberRef v7;
  CFNumberRef v8;
  CFNumberRef v9;
  CFNumberRef v10;
  CFNumberRef v11;
  const char *v12;
  CFStringRef v13;
  CFStringRef v14;
  const char *v15;
  CFStringRef v16;
  CFStringRef v17;
  const char *v18;
  CFStringRef v19;
  CFStringRef v20;
  __CFDictionary *v21;
  __CFDictionary *v22;
  uint64_t v23;
  int *v24;
  const __CFString *v25;
  const char *CStringPtr;
  CFStringRef v27;
  CFNumberRef v28;
  const char *v29;
  CFStringRef v30;
  CFNumberRef v31;
  int v32;
  uint64_t v33;
  unsigned int *v34;
  uint64_t v35;
  int valuePtr;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v1 = a1 + 14724;
  if (*(_BYTE *)(a1 + 14724))
    return;
  v2 = a1;
  *(_DWORD *)(a1 + 176) = *(_DWORD *)(a1 + 17996);
  if (*(_QWORD *)(a1 + 17984))
  {
    v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v5 = Mutable;
    if (!Mutable)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCAudioIssueDetectorUtil_ReportCallEndStatsIfNeeded_cold_2();
      }
      goto LABEL_11;
    }
    _VCAudioIssueDetectorUtil_AddAudioCommonStatToDictionary(Mutable, v2);
    valuePtr = *(_DWORD *)(v2 + 188);
    v6 = CFNumberCreate(v3, kCFNumberIntType, &valuePtr);
    CFDictionaryAddValue(v5, CFSTR("AudioTotalFrameCount"), v6);
    CFRelease(v6);
    valuePtr = *(_DWORD *)(v2 + 192);
    v7 = CFNumberCreate(v3, kCFNumberIntType, &valuePtr);
    CFDictionaryAddValue(v5, CFSTR("AudioSpeechFrameCount"), v7);
    CFRelease(v7);
    valuePtr = *(_DWORD *)(v2 + 196);
    v8 = CFNumberCreate(v3, kCFNumberIntType, &valuePtr);
    CFDictionaryAddValue(v5, CFSTR("AudioSilenceFrameCount"), v8);
    CFRelease(v8);
    valuePtr = *(_DWORD *)(v2 + 200);
    v9 = CFNumberCreate(v3, kCFNumberIntType, &valuePtr);
    CFDictionaryAddValue(v5, CFSTR("AudioSpeechBadFrameCount"), v9);
    CFRelease(v9);
    valuePtr = *(_DWORD *)(v2 + 204);
    v10 = CFNumberCreate(v3, kCFNumberIntType, &valuePtr);
    CFDictionaryAddValue(v5, CFSTR("AudioSpeechLostFrameCount"), v10);
    CFRelease(v10);
    valuePtr = *(_DWORD *)(v2 + 208);
    v11 = CFNumberCreate(v3, kCFNumberIntType, &valuePtr);
    CFDictionaryAddValue(v5, CFSTR("AudioNoDataFrameCount"), v11);
    CFRelease(v11);
    qsort((void *)(v2 + 332), 0x20uLL, 0xCuLL, (int (__cdecl *)(const void *, const void *))_VCAudioIssueDetectorUtil_CompareBitRateCount);
    v12 = _VCAudioIssueDetectorUtil_PayloadBitRateString(*(unsigned __int16 *)(v2 + 332), *(_DWORD *)(v2 + 336));
    if (!v12)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCAudioIssueDetectorUtil_ReportCallEndStatsIfNeeded_cold_3();
      }
      goto LABEL_11;
    }
    v13 = CFStringCreateWithCString(v3, v12, 0x8000100u);
    if (v13)
    {
      v14 = v13;
      CFDictionaryAddValue(v5, CFSTR("AudioTop1UsedBitrate"), v13);
      CFRelease(v14);
      v15 = _VCAudioIssueDetectorUtil_PayloadBitRateString(*(unsigned __int16 *)(v2 + 344), *(_DWORD *)(v2 + 348));
      if (!v15)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VCAudioIssueDetectorUtil_ReportCallEndStatsIfNeeded_cold_4();
        }
        goto LABEL_11;
      }
      v16 = CFStringCreateWithCString(v3, v15, 0x8000100u);
      if (v16)
      {
        v17 = v16;
        CFDictionaryAddValue(v5, CFSTR("AudioTop2UsedBitrate"), v16);
        CFRelease(v17);
        v18 = _VCAudioIssueDetectorUtil_PayloadBitRateString(*(unsigned __int16 *)(v2 + 356), *(_DWORD *)(v2 + 360));
        if (!v18)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              _VCAudioIssueDetectorUtil_ReportCallEndStatsIfNeeded_cold_5();
          }
          goto LABEL_11;
        }
        v19 = CFStringCreateWithCString(v3, v18, 0x8000100u);
        if (v19)
        {
          v20 = v19;
          CFDictionaryAddValue(v5, CFSTR("AudioTop3UsedBitrate"), v19);
          CFRelease(v20);
          reportingAudioStreamEvent();
LABEL_11:
          CFRelease(v5);
        }
      }
    }
    v21 = CFDictionaryCreateMutable(v3, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v22 = v21;
    if (v21)
    {
      _VCAudioIssueDetectorUtil_AddAudioCommonStatToDictionary(v21, v2);
      v23 = 0;
      v35 = v2;
      v24 = (int *)(v2 + 216);
      do
      {
        if (v23 <= 0xAu)
        {
          v25 = off_1E9E54948[v23];
          CStringPtr = CFStringGetCStringPtr(v25, 0x8000100u);
          v27 = CFStringCreateWithFormat(v3, 0, CFSTR("%sCount"), CStringPtr);
          valuePtr = *(v24 - 1);
          v28 = CFNumberCreate(v3, kCFNumberIntType, &valuePtr);
          CFDictionaryAddValue(v22, v27, v28);
          CFRelease(v28);
          CFRelease(v27);
          v29 = CFStringGetCStringPtr(v25, 0x8000100u);
          v30 = CFStringCreateWithFormat(v3, 0, CFSTR("%sDuration"), v29);
          valuePtr = *v24;
          v31 = CFNumberCreate(v3, kCFNumberIntType, &valuePtr);
          CFDictionaryAddValue(v22, v30, v31);
          CFRelease(v31);
          CFRelease(v30);
        }
        ++v23;
        v24 += 2;
      }
      while (v23 != 11);
      v2 = v35;
      reportingAudioStreamEvent();
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCAudioIssueDetectorUtil_ReportCallEndStatsIfNeeded_cold_1();
    }
    CFRelease(v22);
    if (*(_DWORD *)(v1 + 3272) != 3)
    {
      _VCAudioIssueDetectorUtil_ReportDistortionRadioHistogram(v2, CFSTR("AudioDistortionContinuousSpeechLoss"), 0);
      _VCAudioIssueDetectorUtil_ReportDistortionRadioHistogram(v2, CFSTR("AudioDistortionAverageSpeechLoss"), 1u);
      _VCAudioIssueDetectorUtil_ReportDistortionRadioHistogram(v2, CFSTR("AudioDistortionRxLinkBroken"), 2u);
      _VCAudioIssueDetectorUtil_ReportDistortionRadioHistogram(v2, CFSTR("AudioDistortionRxSilence"), 3u);
      _VCAudioIssueDetectorUtil_ReportDistortionRadioHistogram(v2, CFSTR("AudioDistortionTxSilence"), 4u);
      _VCAudioIssueDetectorUtil_ReportDistortionRadioHistogram(v2, CFSTR("AudioDistortionZerosTx"), 5u);
      _VCAudioIssueDetectorUtil_ReportDistortionRadioHistogram(v2, CFSTR("AudioDistortionZerosRx"), 6u);
      _VCAudioIssueDetectorUtil_ReportDistortionRadioHistogram(v2, CFSTR("AudioDistortionLowEnergyTx"), 7u);
      _VCAudioIssueDetectorUtil_ReportDistortionRadioHistogram(v2, CFSTR("AudioDistortionLowEnergyRx"), 8u);
      _VCAudioIssueDetectorUtil_ReportDistortionRadioHistogram(v2, CFSTR("AudioDistortionHighNoiseTx"), 9u);
      _VCAudioIssueDetectorUtil_ReportDistortionRadioHistogram(v2, CFSTR("AudioDistortionHighNoiseRx"), 0xAu);
      _VCAudioIssueDetectorUtil_ReportDistortionRadioHistogram(v2, CFSTR("AudioDistortionDownlinkRtpTimeout"), 0xEu);
    }
  }
  if (!_VCAudioIssueDetectorUtil_IsReportingQueueFull(*(opaqueCMSimpleQueue **)(v2 + 17968)))
  {
    v32 = *(unsigned __int16 *)(v2 + 720);
    *(_WORD *)(v2 + 720) = v32 + 1;
    v33 = v2
        + 560
        * (unsigned __int16)(v32
                           - 25
                           * ((((unsigned __int16)(v32 - ((18351 * v32) >> 16)) >> 1)
                             + ((18351 * v32) >> 16)) >> 4));
    v34 = (unsigned int *)(v33 + 724);
    *(_DWORD *)(v33 + 724) = 11;
    *(_QWORD *)(v33 + 728) = *(_DWORD *)(v2 + 4) * *(unsigned __int16 *)(v2 + 8);
    memcpy((void *)(v33 + 736), (const void *)(v2 + 172), 0x224uLL);
    _VCAudioIssueDetectorUtil_EnqueueDistortion(v2, v34);
  }
  _VCAudioIssueDetectorUtil_ReportRmsStatEvents(v2, 0xCu, (float *)(v2 + 64));
  _VCAudioIssueDetectorUtil_ReportRmsStatEvents(v2, 0xDu, (float *)(v2 + 16));
  *(_BYTE *)v1 = 1;
}

void _VCAudioIssueDetectorUtil_StopZerosMonitoring(uint64_t a1)
{
  unsigned int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  unsigned int *v7;

  if (*(_DWORD *)(a1 + 116) == 1)
  {
    v2 = *(_DWORD *)(a1 + 124);
    if (v2 >= 0x1389 && !_VCAudioIssueDetectorUtil_IsReportingQueueFull(*(opaqueCMSimpleQueue **)(a1 + 17968)))
    {
      v3 = *(unsigned __int16 *)(a1 + 720);
      v4 = v3
         - 25
         * ((((unsigned __int16)(v3 - ((18351 * v3) >> 16)) >> 1) + ((18351 * v3) >> 16)) >> 4);
      v5 = *(_DWORD *)(a1 + 17976);
      *(_WORD *)(a1 + 720) = v3 + 1;
      if (v5)
        v6 = 6;
      else
        v6 = 5;
      v7 = (unsigned int *)(a1 + 560 * (unsigned __int16)v4);
      v7[181] = v6;
      v7[182] = *(_DWORD *)(a1 + 120);
      v7[183] = v2;
      _VCAudioIssueDetectorUtil_EnqueueDistortion(a1, v7 + 181);
    }
    *(_QWORD *)(a1 + 120) = 0;
    *(_DWORD *)(a1 + 116) = 0;
  }
}

BOOL _VCAudioIssueDetectorUtil_IsReportingQueueFull(opaqueCMSimpleQueue *a1)
{
  int32_t Capacity;

  Capacity = CMSimpleQueueGetCapacity(a1);
  return Capacity - CMSimpleQueueGetCount(a1) == 1 || CMSimpleQueueGetCount(a1) >= 25;
}

void _VCAudioIssueDetectorUtil_EnqueueDistortion(uint64_t a1, unsigned int *a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  _BYTE *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  uint64_t v27;

  if (CMSimpleQueueEnqueue(*(CMSimpleQueueRef *)(a1 + 17968), a2))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCAudioIssueDetectorUtil_EnqueueDistortion_cold_1();
    }
  }
  v4 = *a2;
  if (v4 <= 0xA)
  {
    v5 = a1 + 8 * v4;
    v6 = *(_DWORD *)(v5 + 216) + a2[2];
    ++*(_DWORD *)(v5 + 212);
    *(_DWORD *)(v5 + 216) = v6;
    if (*(_DWORD *)(a1 + 17996) != 3)
    {
      if (*(_BYTE *)(a1 + 14736))
      {
        v7 = a1 + 292 * v4;
        v8 = *(__int16 *)(a1 + 14738);
        if (v8 <= -45)
        {
          v9 = 0;
          while (rsrpBinBoundaries[v9] < v8)
          {
            if (++v9 == 19)
              goto LABEL_14;
          }
        }
        else
        {
          v9 = 19;
        }
        ++*(_WORD *)(v7 + 14756 + 2 * v9);
LABEL_14:
        v10 = *(__int16 *)(a1 + 14740);
        if (v10 <= 0)
        {
          v11 = 0;
          while (rssiBinBoundaries[v11] < v10)
          {
            if (++v11 == 11)
              goto LABEL_17;
          }
        }
        else
        {
          v11 = 11;
        }
        ++*(_WORD *)(a1 + 292 * v4 + 14796 + 2 * v11);
LABEL_17:
        v12 = *(char *)(a1 + 14742);
        if (v12 <= 30)
        {
          v13 = 0;
          while (snrBinBoundaries[v13] < v12)
          {
            if (++v13 == 21)
              goto LABEL_23;
          }
        }
        else
        {
          v13 = 21;
        }
        ++*(_WORD *)(a1 + 292 * v4 + 14820 + 2 * v13);
LABEL_23:
        v14 = *(unsigned __int8 *)(a1 + 14743);
        if (v14 <= 0x64)
        {
          v15 = 0;
          while (blerBinBoundaries[v15] < (int)v14)
          {
            if (++v15 == 27)
              goto LABEL_29;
          }
        }
        else
        {
          v15 = 27;
        }
        ++*(_WORD *)(a1 + 292 * v4 + 14864 + 2 * v15);
LABEL_29:
        v16 = *(unsigned __int8 *)(a1 + 14744);
        if (v16 <= 0x64)
        {
          v17 = 0;
          while (blerBinBoundaries[v17] < (int)v16)
          {
            if (++v17 == 27)
              goto LABEL_35;
          }
        }
        else
        {
          v17 = 27;
        }
        ++*(_WORD *)(a1 + 292 * v4 + 14920 + 2 * v17);
LABEL_35:
        v18 = (_BYTE *)(v7 + 14754);
        v19 = a1 + 292 * v4;
        v20 = v19 + 14754 + 2 * *(unsigned __int8 *)(a1 + 14745);
        ++*(_WORD *)(v20 + 222);
        v21 = v19 + 14754 + 2 * *(unsigned __int8 *)(a1 + 14746);
        ++*(_WORD *)(v21 + 228);
        v22 = *(unsigned __int16 *)(a1 + 14748);
        if (v22 <= 0x500)
        {
          v23 = 0;
          while (cdrxCycleBinBoundaries[v23] < (int)v22)
          {
            if (++v23 == 9)
              goto LABEL_41;
          }
        }
        else
        {
          v23 = 9;
        }
        ++*(_WORD *)(v19 + 14988 + 2 * v23);
LABEL_41:
        v24 = a1 + 292 * v4;
        v25 = v24 + 2 * *(unsigned __int8 *)(a1 + 14750);
        ++*(_WORD *)(v25 + 15008);
        v26 = *(unsigned __int16 *)(a1 + 14752);
        if (v26 <= 0x2710)
        {
          v27 = 0;
          while (outageBinBoundaries[v27] < (int)v26)
          {
            if (++v27 == 15)
              goto LABEL_47;
          }
        }
        else
        {
          v27 = 15;
        }
        ++*(_WORD *)(v24 + 15014 + 2 * v27);
LABEL_47:
        *v18 = 1;
      }
    }
  }
}

void _VCAudioIssueDetectorUtil_AddAudioCommonStatToDictionary(__CFDictionary *a1, uint64_t a2)
{
  _DWORD *v4;
  const __CFAllocator *v5;
  CFNumberRef v6;
  int v7;
  int v8;
  CFNumberRef v9;
  CFNumberRef v10;
  CFNumberRef v11;
  const __CFString *v12;
  CFNumberRef v13;
  int valuePtr;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v4 = (_DWORD *)(a2 + 17976);
  valuePtr = *(_DWORD *)(a2 + 17976);
  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v6 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &valuePtr);
  CFDictionaryAddValue(a1, CFSTR("AudioStatDirection"), v6);
  CFRelease(v6);
  v7 = *(_DWORD *)(a2 + 176) - 2;
  if (v7 > 4)
    v8 = 0;
  else
    v8 = dword_1D910BFF4[v7];
  valuePtr = v8;
  v9 = CFNumberCreate(v5, kCFNumberIntType, &valuePtr);
  CFDictionaryAddValue(a1, CFSTR("RATType"), v9);
  CFRelease(v9);
  valuePtr = *(unsigned __int16 *)(a2 + 184);
  v10 = CFNumberCreate(v5, kCFNumberIntType, &valuePtr);
  CFDictionaryAddValue(a1, CFSTR("CodecSampleRate"), v10);
  CFRelease(v10);
  if (*v4)
  {
    valuePtr = *(unsigned __int16 *)(a2 + 186);
    v11 = CFNumberCreate(v5, kCFNumberIntType, &valuePtr);
    v12 = CFSTR("DownlinkCodecBitRate");
  }
  else
  {
    valuePtr = *(unsigned __int16 *)(a2 + 186);
    v11 = CFNumberCreate(v5, kCFNumberIntType, &valuePtr);
    v12 = CFSTR("UplinkCodecBitRate");
  }
  CFDictionaryAddValue(a1, v12, v11);
  CFRelease(v11);
  valuePtr = *(_DWORD *)(a2 + 180);
  v13 = CFNumberCreate(v5, kCFNumberIntType, &valuePtr);
  CFDictionaryAddValue(a1, CFSTR("CodecPayload"), v13);
  CFRelease(v13);
}

const char *_VCAudioIssueDetectorUtil_PayloadBitRateString(int a1, int a2)
{
  if (a1 <= 106)
  {
    if (a1 == 97)
      return VCPayloadUtils_AmrNbBitRateStringForBitRate(a2);
    if (a1 == 98)
      return VCPayloadUtils_AmrWbBitRateStringForBitRate(a2);
  }
  else if ((a1 - 107) < 2 || a1 == 111)
  {
    return VCPayloadUtils_EvsBitRateStringForBitRate(a2);
  }
  return "";
}

void _VCAudioIssueDetectorUtil_ReportDistortionRadioHistogram(uint64_t a1, const void *a2, unsigned int a3)
{
  const __CFAllocator *v6;
  __CFDictionary *Mutable;
  __CFDictionary *v8;
  unsigned int v9;
  int v10;
  CFNumberRef v11;
  uint64_t v12;
  int valuePtr;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 292 * a3 + 14754))
  {
    v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v8 = Mutable;
    if (Mutable)
    {
      CFDictionaryAddValue(Mutable, CFSTR("AudioDistortionType"), a2);
      v9 = *(_DWORD *)(a1 + 176) - 2;
      if (v9 > 4)
        v10 = 0;
      else
        v10 = dword_1D910BFF4[v9];
      valuePtr = v10;
      v11 = CFNumberCreate(v6, kCFNumberIntType, &valuePtr);
      CFDictionaryAddValue(v8, CFSTR("RATType"), v11);
      CFRelease(v11);
      v12 = a1 + 292 * a3;
      _VCAudioIssueDetectorUtil_AddHistogramEntryToDict(v8, CFSTR("RsrpHistogram"), v12 + 14756, 0x13u);
      _VCAudioIssueDetectorUtil_AddHistogramEntryToDict(v8, CFSTR("RssiHistogram"), v12 + 14796, 0xBu);
      _VCAudioIssueDetectorUtil_AddHistogramEntryToDict(v8, CFSTR("SnrHistogram"), v12 + 14820, 0x15u);
      _VCAudioIssueDetectorUtil_AddHistogramEntryToDict(v8, CFSTR("UlBlerHistogram"), v12 + 14864, 0x1Bu);
      _VCAudioIssueDetectorUtil_AddHistogramEntryToDict(v8, CFSTR("DlBlerHistogram"), v12 + 14920, 0x1Bu);
      _VCAudioIssueDetectorUtil_AddHistogramEntryToDict(v8, CFSTR("TtiHistogram"), v12 + 14976, 2u);
      _VCAudioIssueDetectorUtil_AddHistogramEntryToDict(v8, CFSTR("CdrxStateHistogram"), v12 + 14982, 2u);
      _VCAudioIssueDetectorUtil_AddHistogramEntryToDict(v8, CFSTR("CdrxCycleHistogram"), v12 + 14988, 9u);
      _VCAudioIssueDetectorUtil_AddHistogramEntryToDict(v8, CFSTR("OutageStateHistogram"), v12 + 15008, 2u);
      _VCAudioIssueDetectorUtil_AddHistogramEntryToDict(v8, CFSTR("OutagePeriodHistogram"), v12 + 15014, 0xFu);
      reportingAudioStreamEvent();
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCAudioIssueDetectorUtil_ReportDistortionRadioHistogram_cold_1();
    }
    CFRelease(v8);
  }
}

void _VCAudioIssueDetectorUtil_AddHistogramEntryToDict(__CFDictionary *a1, const void *a2, uint64_t a3, unsigned int a4)
{
  const __CFAllocator *v8;
  CFMutableArrayRef Mutable;
  __CFArray *v10;
  unsigned __int8 v11;
  CFNumberRef v12;
  CFNumberRef v13;
  int valuePtr;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  if (Mutable)
  {
    v10 = Mutable;
    v11 = 0;
    do
    {
      valuePtr = *(unsigned __int16 *)(a3 + 2 * v11);
      v12 = CFNumberCreate(v8, kCFNumberSInt32Type, &valuePtr);
      if (v12)
      {
        v13 = v12;
        CFArrayAppendValue(v10, v12);
        CFRelease(v13);
      }
      ++v11;
    }
    while (a4 >= v11);
    CFDictionaryAddValue(a1, a2, v10);
    CFRelease(v10);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCAudioIssueDetectorUtil_AddHistogramEntryToDict_cold_1();
  }
}

void _VCAudioIssueDetectorUtil_ReportRmsStatEvents(uint64_t a1, unsigned int a2, float *a3)
{
  int v6;
  unsigned int *v7;
  unsigned int v8;

  if (!_VCAudioIssueDetectorUtil_IsReportingQueueFull(*(opaqueCMSimpleQueue **)(a1 + 17968)))
  {
    v6 = *(unsigned __int16 *)(a1 + 720);
    *(_WORD *)(a1 + 720) = v6 + 1;
    v7 = (unsigned int *)(a1
                        + 560
                        * (unsigned __int16)(v6
                                           - 25
                                           * ((((unsigned __int16)(v6 - ((18351 * v6) >> 16)) >> 1)
                                             + ((18351 * v6) >> 16)) >> 4)));
    v7[181] = a2;
    v7[182] = *(_DWORD *)(a1 + 4) * *(unsigned __int16 *)(a1 + 8);
    v7[185] = llroundf(a3[1]);
    v7[184] = llroundf(*a3);
    v7[186] = llroundf(a3[2]);
    v8 = llroundf(a3[4]);
    v7[183] = 0;
    v7[188] = v8;
    v7[189] = llroundf(a3[5]);
    v7[187] = llroundf(a3[3]);
    _VCAudioIssueDetectorUtil_EnqueueDistortion(a1, v7 + 181);
  }
}

void _VCAudioIssueDetectorUtil_MonitorAndUpdateRmsSegmentStats(uint64_t a1, int a2, int a3)
{
  long double v4;
  _QWORD *v5;
  double v8;
  double v9;
  float v10;
  float v11;
  float v12;

  v4 = *(double *)(a1 + 144);
  if (v4 != 0.0)
  {
    v8 = log10(v4);
    v5 = (_QWORD *)(a1 + 128);
    v9 = (v8 - log10((double)*(unint64_t *)(a1 + 128))) * 10.0;
    v10 = v9;
    if (*(_DWORD *)a1 == 3)
    {
      if (a2 != 2)
        goto LABEL_13;
    }
    else
    {
      if (*(_DWORD *)a1 == 2)
      {
        if (a2 != 1)
          goto LABEL_13;
        goto LABEL_12;
      }
      if (a3 == 3)
      {
LABEL_12:
        v12 = v9;
        _VCAudioIssueDetectorUtil_UpdateRmsSegmentStats(a1 + 64, v12);
        _VCAudioIssueDetectorUtil_RmsMonitorThresholdSpeech(a1, v10);
        goto LABEL_13;
      }
      if (a3 != 2)
      {
LABEL_13:
        *(_QWORD *)(a1 + 144) = 0;
        goto LABEL_14;
      }
    }
    v11 = v9;
    _VCAudioIssueDetectorUtil_UpdateRmsSegmentStats(a1 + 16, v11);
    _VCAudioIssueDetectorUtil_RmsMonitorSilenceThreshold(a1, v10);
    goto LABEL_13;
  }
  v5 = (_QWORD *)(a1 + 128);
LABEL_14:
  *v5 = 0;
}

void _VCAudioIssueDetectorUtilFlushSilenceDistortionStats(uint64_t a1)
{
  int v2;
  unsigned int v3;
  int v4;
  unsigned int *v5;
  unsigned int v6;
  int v7;
  unsigned int *v8;
  int v9;

  v2 = *(_DWORD *)(a1 + 17976);
  if (v2 == 1)
  {
    v6 = *(_DWORD *)(a1 + 152) * *(unsigned __int16 *)(a1 + 8);
    if (v6 >> 3 >= 0x271 && !_VCAudioIssueDetectorUtil_IsReportingQueueFull(*(opaqueCMSimpleQueue **)(a1 + 17968)))
    {
      v7 = *(unsigned __int16 *)(a1 + 720);
      *(_WORD *)(a1 + 720) = v7 + 1;
      v8 = (unsigned int *)(a1
                          + 560
                          * (unsigned __int16)(v7
                                             - 25
                                             * ((((unsigned __int16)(v7 - ((18351 * v7) >> 16)) >> 1)
                                               + ((18351 * v7) >> 16)) >> 4)));
      if (*(_DWORD *)(a1 + 156))
        v9 = 3;
      else
        v9 = 2;
      v8[181] = v9;
      v8[182] = *(_DWORD *)(a1 + 4) * *(unsigned __int16 *)(a1 + 8) - v6;
      v8[183] = v6;
      _VCAudioIssueDetectorUtil_EnqueueDistortion(a1, v8 + 181);
    }
    *(_DWORD *)(a1 + 152) = 0;
  }
  else if (!v2)
  {
    v3 = *(unsigned __int16 *)(a1 + 8) * *(unsigned __int16 *)(a1 + 152);
    if (v3 >> 3 >= 0x271 && !_VCAudioIssueDetectorUtil_IsReportingQueueFull(*(opaqueCMSimpleQueue **)(a1 + 17968)))
    {
      v4 = *(unsigned __int16 *)(a1 + 720);
      *(_WORD *)(a1 + 720) = v4 + 1;
      v5 = (unsigned int *)(a1
                          + 560
                          * (unsigned __int16)(v4
                                             - 25
                                             * ((((unsigned __int16)(v4 - ((18351 * v4) >> 16)) >> 1)
                                               + ((18351 * v4) >> 16)) >> 4)));
      v5[181] = 4;
      v5[182] = *(_DWORD *)(a1 + 4) * *(unsigned __int16 *)(a1 + 8) - v3;
      v5[183] = v3;
      _VCAudioIssueDetectorUtil_EnqueueDistortion(a1, v5 + 181);
    }
    *(_WORD *)(a1 + 152) = 0;
  }
}

void _VCAudioIssueDetectorUtil_FlushRmsStats(uint64_t a1)
{
  int v2;
  int v3;

  if (*(_DWORD *)(a1 + 108) >= 0x1389u)
  {
    if (*(_DWORD *)(a1 + 17976))
      v2 = 8;
    else
      v2 = 7;
    _VCAudioIssueDetectorUtil_ReportEnergybreach(a1, v2, a1 + 64, *(float *)(a1 + 76));
  }
  if (*(_DWORD *)(a1 + 60) >= 0x1389u)
  {
    if (*(_DWORD *)(a1 + 17976))
      v3 = 10;
    else
      v3 = 9;
    _VCAudioIssueDetectorUtil_ReportEnergybreach(a1, v3, a1 + 16, *(float *)(a1 + 28));
  }
  *(_DWORD *)(a1 + 108) = 0;
  *(_DWORD *)(a1 + 60) = 0;
}

uint64_t _VCAudioIssueDetectorUtil_UpdateRmsSegmentStats(uint64_t result, float a2)
{
  float v2;
  int v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *(float *)(result + 12);
  v3 = *(_DWORD *)(result + 24);
  v4 = (v3 + 1);
  *(_DWORD *)(result + 24) = v4;
  if (v3)
  {
    v5 = *(unsigned __int16 *)(result + 32);
  }
  else
  {
    if (*(_DWORD *)(result + 28) < 5u)
    {
      *(_WORD *)(result + 32) = 2;
      return result;
    }
    v5 = 1;
    *(_WORD *)(result + 32) = 1;
  }
  *(float *)(result + 12) = (float)(a2 + (float)(v2 * (float)(v4 - v5))) / (float)(v4 - v5 + 1);
  if (*(float *)(result + 16) < a2)
    *(float *)(result + 16) = a2;
  if (*(float *)(result + 20) > a2)
    *(float *)(result + 20) = a2;
  return result;
}

void _VCAudioIssueDetectorUtil_RmsMonitorThresholdSpeech(uint64_t a1, float a2)
{
  unint64_t v2;
  int v3;
  int v4;
  int v5;
  _BOOL4 v7;
  BOOL v8;

  v2 = *(_QWORD *)(a1 + 128) / (unint64_t)*(unsigned __int16 *)(a1 + 136);
  v3 = *(_DWORD *)(a1 + 100);
  v4 = *(unsigned __int16 *)(a1 + 8);
  v5 = v4 * v2;
  v7 = a2 >= -55.0 && v3 == 1;
  if (v3)
    v8 = 0;
  else
    v8 = a2 < -55.0;
  if (v8 || v7)
  {
    _VCAudioIssueDetectorUtil_HandleBreachTransition(a1, (_DWORD *)(a1 + 64), (*(_DWORD *)(a1 + 4) - v2) * v4, v5, v3, 1, a2);
  }
  else if (a2 < -55.0 && v3 == 1)
  {
    *(_DWORD *)(a1 + 108) += v5;
  }
}

void _VCAudioIssueDetectorUtil_HandleBreachTransition(uint64_t a1, _DWORD *a2, int a3, int a4, int a5, int a6, float a7)
{
  int v8;
  uint64_t v9;

  if (a5 == 1)
  {
    if (a2[11] >= 0x1389u)
    {
      if (!a2[10])
        a2[10] = a3;
      if (a6)
      {
        if (*(_DWORD *)(a1 + 17976))
          v8 = 8;
        else
          v8 = 7;
        v9 = a1 + 64;
      }
      else
      {
        if (*(_DWORD *)(a1 + 17976))
          v8 = 10;
        else
          v8 = 9;
        v9 = a1 + 16;
      }
      _VCAudioIssueDetectorUtil_ReportEnergybreach(a1, v8, v9, a7);
    }
    *((_QWORD *)a2 + 5) = 0;
    a2[9] = 0;
  }
  else if (!a5)
  {
    a2[9] = 1;
    a2[10] = a3;
    a2[11] += a4;
  }
}

void _VCAudioIssueDetectorUtil_ReportEnergybreach(uint64_t a1, int a2, uint64_t a3, float a4)
{
  int v8;
  uint64_t v9;

  if (!_VCAudioIssueDetectorUtil_IsReportingQueueFull(*(opaqueCMSimpleQueue **)(a1 + 17968)))
  {
    v8 = *(unsigned __int16 *)(a1 + 720);
    *(_WORD *)(a1 + 720) = v8 + 1;
    v9 = a1
       + 560
       * (unsigned __int16)(v8
                          - 25
                          * ((((unsigned __int16)(v8 - ((18351 * v8) >> 16)) >> 1)
                            + ((18351 * v8) >> 16)) >> 4));
    *(_DWORD *)(v9 + 724) = a2;
    *(_QWORD *)(v9 + 728) = *(_QWORD *)(a3 + 40);
    *(_DWORD *)(v9 + 736) = llroundf(a4);
    _VCAudioIssueDetectorUtil_EnqueueDistortion(a1, (unsigned int *)(v9 + 724));
  }
}

void _VCAudioIssueDetectorUtil_RmsMonitorSilenceThreshold(uint64_t a1, float a2)
{
  unint64_t v2;
  int v3;
  int v4;
  int v5;
  _BOOL4 v7;
  BOOL v8;

  v2 = *(_QWORD *)(a1 + 128) / (unint64_t)*(unsigned __int16 *)(a1 + 136);
  v3 = *(_DWORD *)(a1 + 52);
  v4 = *(unsigned __int16 *)(a1 + 8);
  v5 = v4 * v2;
  v7 = a2 < -65.0 && v3 == 1;
  if (v3)
    v8 = 1;
  else
    v8 = a2 < -65.0;
  if (!v8 || v7)
  {
    _VCAudioIssueDetectorUtil_HandleBreachTransition(a1, (_DWORD *)(a1 + 16), (*(_DWORD *)(a1 + 4) - v2) * v4, v5, v3, 0, a2);
  }
  else if (a2 > -65.0 && v3 == 1)
  {
    *(_DWORD *)(a1 + 60) += v5;
  }
}

void _VCAudioIssueDetectorUtil_MonitorContinuousSpeechDistortion(int32x2_t *a1, int a2)
{
  int32x2_t *v2;

  if (a1[2247].i32[0] == 1)
  {
    if (a1->i32[0] == 3 && ((a1[19] = 0, ++a1[21].i32[0], a2 == 4) || a2 == 1))
    {
      a1[20] = vadd_s32(a1[20], (int32x2_t)0x100000001);
    }
    else
    {
      v2 = a1 + 20;
      if (a1[20].i32[0] >= 3u)
        _VCAudioIssueDetectorUtil_LogDistortion((uint64_t)a1, &a1[20], &a1[20], 0);
      v2->i32[0] = 0;
    }
  }
}

void _VCAudioIssueDetectorUtil_MonitorAverageSpeechDistortion(_DWORD *a1)
{
  unsigned int v1;
  _QWORD *v2;

  if (a1[4494] == 1)
  {
    v1 = a1[42];
    if (v1)
    {
      v2 = a1 + 41;
      if (100 * a1[41] / v1 >= 0xA)
        _VCAudioIssueDetectorUtil_LogDistortion((uint64_t)a1, a1 + 42, a1 + 41, 1u);
      *v2 = 0;
    }
  }
}

void _VCAudioIssueDetectorUtil_LogDistortion(uint64_t a1, _DWORD *a2, _DWORD *a3, unsigned int a4)
{
  int v8;
  unsigned int *v9;
  int v10;

  if (!_VCAudioIssueDetectorUtil_IsReportingQueueFull(*(opaqueCMSimpleQueue **)(a1 + 17968)))
  {
    v8 = *(unsigned __int16 *)(a1 + 720);
    *(_WORD *)(a1 + 720) = v8 + 1;
    v9 = (unsigned int *)(a1
                        + 560
                        * (unsigned __int16)(v8
                                           - 25
                                           * ((((unsigned __int16)(v8 - ((18351 * v8) >> 16)) >> 1)
                                             + ((18351 * v8) >> 16)) >> 4)));
    v9[181] = a4;
    v10 = *(unsigned __int16 *)(a1 + 8);
    v9[182] = (*(_DWORD *)(a1 + 4) - *a2) * v10;
    v9[183] = *a3 * v10;
    _VCAudioIssueDetectorUtil_EnqueueDistortion(a1, v9 + 181);
    *a3 = 0;
    *a2 = 0;
  }
}

uint64_t _VCAudioIssueDetectorUtil_CompareBitRateCount(uint64_t a1, uint64_t a2)
{
  return (*(_DWORD *)(a2 + 8) - *(_DWORD *)(a1 + 8));
}

void OUTLINED_FUNCTION_12_3(uint64_t a1@<X8>)
{
  uint64_t v1;

  *(_QWORD *)(v1 - 8) = a1;
}

uint64_t VideoTransmitter_CloseSummerHandles(uint64_t result)
{
  uint64_t v1;
  unint64_t v2;
  uint64_t *v3;

  if (*(_DWORD *)(result + 1600))
  {
    v1 = result;
    v2 = 0;
    v3 = (uint64_t *)(result + 560);
    do
    {
      if (*(v3 - 4) != 0xFFFFFFFFLL)
        SummerCloseHandle();
      if (*(v3 - 3) != 0xFFFFFFFFLL)
        SummerCloseHandle();
      if (*(v3 - 2) != 0xFFFFFFFFLL)
        SummerCloseHandle();
      if (*(v3 - 1) != 0xFFFFFFFFLL)
        SummerCloseHandle();
      result = *v3;
      if (*v3 != 0xFFFFFFFFLL)
        result = SummerCloseHandle();
      ++v2;
      v3 += 15;
    }
    while (v2 < *(unsigned int *)(v1 + 1600));
  }
  return result;
}

void VideoTransmitter_CleanupSframeCryptors(uint64_t a1)
{
  unint64_t v2;
  CFTypeRef **v3;
  const void *v4;
  const void *v5;

  if (*(_DWORD *)(a1 + 1600))
  {
    v2 = 0;
    v3 = (CFTypeRef **)(a1 + 632);
    do
    {
      VCSFrameCryptorH264_Destroy(v3);
      ++v2;
      v3 += 15;
    }
    while (v2 < *(unsigned int *)(a1 + 1600));
  }
  v4 = *(const void **)(a1 + 18200);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 18200) = 0;
  }
  v5 = *(const void **)(a1 + 18192);
  if (v5)
  {
    CFRelease(v5);
    *(_QWORD *)(a1 + 18192) = 0;
  }
}

uint64_t VideoTransmitter_SetupSFrameCryptors(uint64_t a1, _DWORD *a2)
{
  unint64_t v3;
  _DWORD *v4;
  CFAllocatorRef *v5;
  const __CFAllocator *v6;
  CFAllocatorRef *v7;
  CFAllocatorRef **v8;
  uint64_t i;
  const void *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v14[2];

  v14[1] = *MEMORY[0x1E0C80C00];
  if (!*a2)
    return 0;
  v3 = 0;
  v4 = a2 + 110;
  v5 = (CFAllocatorRef *)(a1 + 18200);
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v7 = (CFAllocatorRef *)(a1 + 18192);
  v8 = (CFAllocatorRef **)(a1 + 632);
  for (i = 8; ; i += 8)
  {
    v10 = *(const void **)&a2[i];
    if (!v10)
      goto LABEL_10;
    if (*v4 != 123)
      break;
    v11 = VCSFrameCryptorH264_Create(v10, v8);
    if ((_DWORD)v11)
    {
      v12 = v11;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VideoTransmitter_SetupSFrameCryptors_cold_3();
      }
      return v12;
    }
    if (!*v5
      && VCAllocatorFirstCome_Create(v6, (uint64_t)"VideoTransmitterEncryptedBufferHeaderAllocator", v5))
    {
      v12 = 2149449731;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VideoTransmitter_SetupSFrameCryptors_cold_2();
      }
      return v12;
    }
    if (!*v7)
    {
      v14[0] = 0x2000;
      if (VCAllocatorMultiQueue_Create(v6, (uint64_t)"VideoTransmitterEncryptedBufferDataAllocator", 1u, v14, v7))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VideoTransmitter_SetupSFrameCryptors_cold_1();
        }
        return 2149449731;
      }
    }
LABEL_10:
    ++v3;
    v8 += 15;
    if (v3 >= *a2)
      return 0;
  }
  v12 = 2149515265;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VideoTransmitter_SetupSFrameCryptors_cold_4();
  }
  return v12;
}

uint64_t VideoTransmitter_CreateHandle(uint64_t *a1, unsigned int *a2)
{
  char *v4;
  uint64_t v5;
  uint64_t v6;
  _DWORD *v7;
  uint64_t *v8;
  uint64_t v9;
  _QWORD *v10;
  __int128 v11;
  unint64_t v12;
  unsigned int *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t Handle;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  unsigned int v25;
  int v26;
  uint64_t v27;
  unsigned int v28;
  unsigned int v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  int v33;
  int v34;
  uint64_t v35;
  unsigned int v36;
  int v37;
  uint64_t v38;
  NSObject *v39;
  _BOOL4 v40;
  unsigned int v41;
  const void *v42;
  CFTypeRef v43;
  unsigned int v44;
  CFTypeRef v45;
  CFTypeRef v46;
  const void *v47;
  const void *v48;
  _WORD *v49;
  __int128 v50;
  double v51;
  unsigned int v52;
  BOOL v54;
  unsigned int Version;
  int v56;
  int v57;
  int v58;
  unsigned int v59;
  unsigned int v60;
  __int128 v62;
  CFTypeRef v63;
  uint64_t v64;
  NSObject *v65;
  NSObject *v66;
  int v67;
  int v68;
  uint64_t v69;
  NSObject *v70;
  int v71;
  int v72;
  const char *v73;
  __int16 v74;
  int IsInternalOSInstalled;
  __int16 IntValueForKey;
  int AppBooleanValue;
  _OWORD *v78;
  CFTypeRef v79;
  uint64_t *v80;
  unsigned int v81;
  uint64_t v82;
  NSObject *v83;
  const char *v84;
  unsigned int v85;
  const char *v86;
  _QWORD *v87;
  unsigned int v88;
  int v89;
  const __CFString *v90;
  const __CFString *v91;
  CFComparisonResult v92;
  BOOL v94;
  uint64_t v95;
  NSObject *v96;
  const char *v97;
  CFComparisonResult v98;
  BOOL v99;
  BOOL v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  _DWORD *v104;
  dispatch_queue_t *v105;
  uint64_t *v106;
  uint64_t v107;
  NSObject *v108;
  NSObject *CustomRootQueue;
  unsigned int v110;
  dispatch_semaphore_t v111;
  uint64_t v112;
  int v113;
  uint64_t v114;
  NSObject *v115;
  const char *v116;
  uint64_t v117;
  uint64_t v118;
  NSObject *v119;
  FILE *v120;
  uint64_t v121;
  NSObject *v122;
  FILE *v123;
  uint64_t v124;
  NSObject *v125;
  __int128 v126;
  FILE *v127;
  void *v128;
  uint64_t v129;
  NSObject *v130;
  uint64_t v131;
  int v132;
  OpaqueCMMemoryPool *v133;
  CFAllocatorRef Allocator;
  unsigned int FECFeedbackVersion;
  uint64_t v136;
  CFTypeRef v137;
  int v139;
  int v140;
  uint64_t v141;
  NSObject *v142;
  unsigned int v143;
  unsigned int v144;
  const __CFAllocator *v145;
  Boolean keyExistsAndHasValidFormat;
  _QWORD v147[5];
  _BYTE buf[64];
  __int128 v149;
  __int128 v150;
  __int128 v151;
  __int128 v152;
  uint64_t v153;

  v153 = *MEMORY[0x1E0C80C00];
  v4 = (char *)malloc_type_calloc(1uLL, 0x4788uLL, 0x10F004060C298BCuLL);
  if (!v4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoTransmitter_CreateHandle_cold_2();
    }
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      return 2149449731;
    VRTraceErrorLogLevelToCSTR();
    v136 = 2149449731;
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VideoTransmitter_CreateHandle_cold_1();
    return v136;
  }
  v5 = (uint64_t)v4;
  LODWORD(v6) = *a2;
  if (*a2 >= 0xA)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
    {
      v136 = 2149515265;
    }
    else
    {
      VRTraceErrorLogLevelToCSTR();
      v136 = 2149515265;
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoTransmitter_CreateHandle_cold_3();
    }
    goto LABEL_216;
  }
  v7 = v4 + 16760;
  v4[18208] = 0;
  v8 = (uint64_t *)MEMORY[0x1E0C9AE00];
  if (*((_BYTE *)a2 + 617))
  {
    v9 = VCNACKConsumer_Create(*MEMORY[0x1E0C9AE00], (uint64_t *)v4 + 2284);
    *(_BYTE *)(v5 + 18186) = 1;
    if ((v9 & 0x80000000) != 0)
    {
      v136 = v9;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VideoTransmitter_CreateHandle_cold_28();
      }
      goto LABEL_216;
    }
    LODWORD(v6) = *a2;
  }
  if ((_DWORD)v6)
  {
    v6 = v6;
    v10 = (_QWORD *)(v5 + 560);
    *(_QWORD *)&v11 = 0xFFFFFFFFLL;
    *((_QWORD *)&v11 + 1) = 0xFFFFFFFFLL;
    do
    {
      *((_OWORD *)v10 - 2) = v11;
      *((_OWORD *)v10 - 1) = v11;
      *v10 = 0xFFFFFFFFLL;
      v10 += 15;
      --v6;
    }
    while (v6);
    v12 = 0;
    v13 = a2 + 4;
    v14 = v5;
    while (1)
    {
      v15 = *((_QWORD *)v13 - 1);
      *(_QWORD *)(v14 + 520) = v15;
      *(_WORD *)(v14 + 600) = *(_WORD *)v13;
      v16 = RTPGetLocalSSRC(v15, (_DWORD *)(v14 + 576));
      if ((v16 & 0x80000000) != 0)
        break;
      v17 = *(_QWORD *)(v5 + 18272);
      if (v17)
      {
        v18 = RTPTransport_SetNACKConsumer(*((_QWORD *)v13 - 1), v17);
        if ((v18 & 0x80000000) != 0)
        {
          v136 = v18;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VideoTransmitter_CreateHandle_cold_27();
          }
          goto LABEL_216;
        }
      }
      Handle = SummerCreateHandle((uint64_t *)(v14 + 528), 400);
      if ((Handle & 0x80000000) != 0)
      {
        v136 = Handle;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VideoTransmitter_CreateHandle_cold_22();
        }
        goto LABEL_216;
      }
      v20 = SummerCreateHandle((uint64_t *)(v14 + 536), 400);
      if ((v20 & 0x80000000) != 0)
      {
        v136 = v20;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VideoTransmitter_CreateHandle_cold_23();
        }
        goto LABEL_216;
      }
      v21 = SummerCreateHandle((uint64_t *)(v14 + 544), 400);
      if ((v21 & 0x80000000) != 0)
      {
        v136 = v21;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VideoTransmitter_CreateHandle_cold_24();
        }
        goto LABEL_216;
      }
      v22 = SummerCreateHandle((uint64_t *)(v14 + 552), 400);
      if ((v22 & 0x80000000) != 0)
      {
        v136 = v22;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VideoTransmitter_CreateHandle_cold_25();
        }
        goto LABEL_216;
      }
      v23 = SummerCreateHandle((uint64_t *)(v14 + 560), 400);
      if ((v23 & 0x80000000) != 0)
      {
        v136 = v23;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VideoTransmitter_CreateHandle_cold_26();
        }
        goto LABEL_216;
      }
      *(_DWORD *)(v14 + 628) = v13[2];
      ++v12;
      v13 += 8;
      v14 += 120;
      if (v12 >= *a2)
        goto LABEL_19;
    }
    v136 = v16;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoTransmitter_CreateHandle_cold_21();
    }
    goto LABEL_216;
  }
LABEL_19:
  if (VideoTransmitter_SetupSFrameCryptors(v5, a2))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
    {
      v136 = 2149449731;
    }
    else
    {
      VRTraceErrorLogLevelToCSTR();
      v136 = 2149449731;
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoTransmitter_CreateHandle_cold_20();
    }
    goto LABEL_216;
  }
  v24 = *a2;
  *(_DWORD *)(v5 + 1600) = *a2;
  *(_QWORD *)(v5 + 1608) = *((_QWORD *)a2 + 37);
  *(_QWORD *)(v5 + 1640) = *((_QWORD *)a2 + 68);
  v25 = a2[134];
  if (v25 - 1 >= 9)
  {
    v136 = 2149449729;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoTransmitter_CreateHandle_cold_19();
    }
    goto LABEL_216;
  }
  *(_DWORD *)(v5 + 18088) = v25;
  v26 = *((unsigned __int8 *)a2 + 568);
  *(_BYTE *)(v5 + 18104) = v26;
  if (v26 && v24 >= 2)
  {
    v27 = 0;
    v28 = v24 - 1;
    do
    {
      if (v24 == (_DWORD)v27 + 1)
      {
        LOBYTE(v29) = 0;
        v30 = v27 + 1;
      }
      else
      {
        v29 = 0;
        v30 = v27 + 1;
        v31 = *(unsigned __int16 *)(v5 + 120 * v27 + 600);
        v32 = v28;
        v33 = v27 + 1;
        do
        {
          v34 = LOWORD(a2[8 * v33 + 4]);
          if (v31 != v34)
            *(_WORD *)(v5 + 120 * v27 + 2 * v29++ + 602) = v34;
          ++v33;
          --v32;
        }
        while (v32);
      }
      *(_BYTE *)(v5 + 120 * v27 + 626) = v29;
      --v28;
      v27 = v30;
    }
    while (v30 != v24 - 1);
  }
  *(_DWORD *)(v5 + 18108) = a2[143];
  *(_QWORD *)(v5 + 18112) = *((_QWORD *)a2 + 74);
  if (!a2[128])
  {
    v136 = 2149449729;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoTransmitter_CreateHandle_cold_4();
    }
    goto LABEL_216;
  }
  v35 = *v8;
  if (VTU_CreatePacketAllocator(*((unsigned __int16 *)a2 + 248), *v8, (CFAllocatorRef *)(v5 + 18128)))
  {
    v136 = 2149449729;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoTransmitter_CreateHandle_cold_18();
    }
    goto LABEL_216;
  }
  *(_BYTE *)(v5 + 508) = VCDefaults_GetBoolValueForKey(CFSTR("rateControllAllowFECLowBitrate"), 0);
  *(_BYTE *)(v5 + 18153) = VCDefaults_GetBoolValueForKey(CFSTR("forceDisableFEC"), 0);
  *(_DWORD *)(v5 + 496) = a2[128];
  *(_DWORD *)(v5 + 500) = a2[146];
  *(_DWORD *)(v5 + 504) = a2[129];
  v36 = a2[131];
  if (v36 >= 6)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v38 = VRTraceErrorLogLevelToCSTR();
      v39 = *MEMORY[0x1E0CF2758];
      v40 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
      v37 = 0;
      if (!v40)
        goto LABEL_39;
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = v38;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "_VideoTransmitter_VCPEncoderUsageWithEncoderUsage";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 1199;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = v36;
      _os_log_impl(&dword_1D8A54000, v39, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Invalid encoderUsage=%u", buf, 0x22u);
    }
    v37 = 0;
    goto LABEL_39;
  }
  v37 = dword_1D910C058[v36];
LABEL_39:
  *(_DWORD *)(v5 + 17372) = v37;
  v41 = a2[128];
  *(_BYTE *)(v5 + 18092) = (v41 == 5 || v41 == 3) && *(_DWORD *)(v5 + 18088) > 1;
  v42 = (const void *)*((_QWORD *)a2 + 38);
  if (v42)
  {
    v43 = CFRetain(v42);
    *(_QWORD *)(v5 + 1648) = v43;
    v44 = a2[144];
    *(_DWORD *)(v5 + 18224) = v44;
    if (v44 && !v43)
      goto LABEL_46;
  }
  else
  {
    *(_QWORD *)(v5 + 1648) = 0;
    v59 = a2[144];
    *(_DWORD *)(v5 + 18224) = v59;
    if (v59)
LABEL_46:
      *(_QWORD *)(v5 + 1648) = VCMediaControlInfoGeneratorCreateWithType(2);
  }
  v45 = (CFTypeRef)*((_QWORD *)a2 + 41);
  if (v45)
    v45 = CFRetain(v45);
  *(_QWORD *)(v5 + 1656) = v45;
  v46 = (CFTypeRef)*((_QWORD *)a2 + 42);
  if (v46)
    v46 = CFRetain(v46);
  *(_QWORD *)(v5 + 1664) = v46;
  v47 = *(const void **)v5;
  v48 = (const void *)*((_QWORD *)a2 + 39);
  *(_QWORD *)v5 = v48;
  if (v48)
    CFRetain(v48);
  v49 = (_WORD *)(v5 + 16498);
  if (v47)
    CFRelease(v47);
  *(_DWORD *)(v5 + 8) = VCReporting_GetDynamicReportingModuleID();
  reportingInheritModuleSpecificInfoFromParent();
  *(_QWORD *)&v50 = *((_QWORD *)a2 + 47);
  *(_DWORD *)(v5 + 44) = a2[96];
  *(_DWORD *)(v5 + 88) = a2[97];
  *(_OWORD *)(v5 + 64) = *(_OWORD *)(a2 + 98);
  *(_QWORD *)(v5 + 80) = *((_QWORD *)a2 + 51);
  *(_DWORD *)(v5 + 92) = 0;
  DWORD2(v50) = a2[104];
  HIDWORD(v50) = DWORD2(v50);
  *(_OWORD *)(v5 + 24) = v50;
  *(_DWORD *)(v5 + 40) = DWORD2(v50);
  *(_DWORD *)(v5 + 4380) = DWORD2(v50);
  *(_QWORD *)(v5 + 48) = *(_QWORD *)(a2 + 105);
  *(_QWORD *)(v5 + 4352) = *((_QWORD *)a2 + 54);
  v51 = micro();
  *(_OWORD *)(v5 + 4360) = 0u;
  *(double *)(v5 + 4336) = v51;
  *(double *)(v5 + 4344) = v51;
  *(_QWORD *)(v5 + 56) = *((_QWORD *)a2 + 58);
  *(_DWORD *)(v5 + 18100) = a2[138];
  v52 = a2[110];
  *(_DWORD *)(v5 + 16) = v52;
  v54 = v52 != 110 && (v52 & 0xFFFFFFFE) != 124;
  *(_BYTE *)(v5 + 18248) = v54;
  *(_DWORD *)(v5 + 17764) = a2[118];
  *(_DWORD *)(v5 + 96) = a2[88];
  *(_DWORD *)(v5 + 100) = a2[90];
  *(_DWORD *)(v5 + 4420) = *((unsigned __int8 *)a2 + 346);
  *(_DWORD *)(v5 + 4424) = *((unsigned __int8 *)a2 + 347);
  Version = VCMediaControlInfoGeneratorGetVersion(*(_QWORD *)(v5 + 1648));
  v56 = 0;
  if (Version >= 2)
    v56 = *((unsigned __int8 *)a2 + 540);
  *(_DWORD *)(v5 + 4428) = v56;
  *(_DWORD *)(v5 + 4440) = a2[87];
  *(_DWORD *)(v5 + 4432) = 0;
  *(_QWORD *)(v5 + 16488) = 0;
  if (!*(_WORD *)(v5 + 16500))
  {
    do
    {
      v57 = hwrandom16();
      *(_WORD *)(v5 + 16500) = v57;
    }
    while (!v57);
  }
  if (!*v49)
  {
    do
    {
      v58 = hwrandom16();
      *v49 = v58;
    }
    while (!v58);
  }
  *(_BYTE *)(v5 + 16508) = 1;
  *(_BYTE *)(v5 + 17464) = *((_BYTE *)a2 + 510);
  *(_WORD *)(v5 + 16825) = 256;
  if (*((_QWORD *)a2 + 61))
  {
    __strlcpy_chk();
  }
  else
  {
    v60 = *(_DWORD *)(v5 + 16) - 110;
    if (v60 > 0xF || ((1 << v60) & 0xC001) == 0)
    {
      v136 = 2149449729;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VideoTransmitter_CreateHandle_cold_5();
      }
      goto LABEL_216;
    }
  }
  *(_QWORD *)(v5 + 4400) = *(_QWORD *)(a2 + 111);
  *(_QWORD *)(v5 + 16608) = 0;
  *(_DWORD *)(v5 + 16672) = a2[92];
  *(_OWORD *)(v5 + 16744) = xmmword_1D910C030;
  *(_DWORD *)(v5 + 16976) = a2[89];
  *(_DWORD *)(v5 + 16980) = 0;
  *(_DWORD *)(v5 + 16988) = a2[93];
  *(_BYTE *)(v5 + 16992) = *((_BYTE *)a2 + 344);
  *(_DWORD *)(v5 + 1776) = 1;
  *(_QWORD *)(v5 + 16520) = 0;
  *(_DWORD *)(v5 + 17776) = 0;
  *(_DWORD *)(v5 + 16512) = 260;
  pthread_mutex_init((pthread_mutex_t *)(v5 + 17000), 0);
  *(_QWORD *)(v5 + 17064) = 0;
  *(_WORD *)(v5 + 17072) = 0;
  *(_QWORD *)(v5 + 17248) = 0;
  *(_OWORD *)(v5 + 17076) = 0u;
  *(_QWORD *)&v62 = *((_QWORD *)a2 + 47);
  *((_QWORD *)&v62 + 1) = v62;
  *(_OWORD *)(v5 + 17256) = v62;
  *(_BYTE *)(v5 + 18209) = *((_BYTE *)a2 + 541);
  *(_OWORD *)(v5 + 368) = xmmword_1D910C040;
  *(_WORD *)(v5 + 16556) = -1;
  *(_QWORD *)(v5 + 416) = 0x7FEFFFFFFFFFFFFFLL;
  pthread_mutex_init((pthread_mutex_t *)(v5 + 17288), 0);
  *(_WORD *)(v5 + 17276) = *((_WORD *)a2 + 248);
  *(_BYTE *)(v5 + 17278) = *((_BYTE *)a2 + 345);
  *(_DWORD *)(v5 + 17280) = a2[126];
  *(_WORD *)(v5 + 17284) = *((_WORD *)a2 + 254);
  *(_DWORD *)(v5 + 18084) = 0;
  *(_WORD *)(v5 + 18094) = hwrandom16();
  v63 = (CFTypeRef)*((_QWORD *)a2 + 70);
  if (v63)
    v63 = CFRetain(v63);
  *(_QWORD *)(v5 + 18216) = v63;
  *(_DWORD *)(v5 + 18120) = a2[150];
  if ((int)VRTraceGetErrorLogLevelForModule() > 7)
  {
    v64 = VRTraceErrorLogLevelToCSTR();
    v65 = *MEMORY[0x1E0CF2758];
    v66 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
      {
        v67 = *(_DWORD *)(v5 + 17764);
        v68 = *(_DWORD *)(v5 + 16);
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)&buf[4] = v64;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "VideoTransmitter_CreateHandle";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 1651;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v67;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = v68;
        _os_log_impl(&dword_1D8A54000, v65, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d parameterSetSupport=%u iPayload=%d", buf, 0x28u);
      }
    }
    else if (os_log_type_enabled(v66, OS_LOG_TYPE_DEBUG))
    {
      v139 = *(_DWORD *)(v5 + 17764);
      v140 = *(_DWORD *)(v5 + 16);
      *(_DWORD *)buf = 136316162;
      *(_QWORD *)&buf[4] = v64;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "VideoTransmitter_CreateHandle";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 1651;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = v139;
      *(_WORD *)&buf[34] = 1024;
      *(_DWORD *)&buf[36] = v140;
      _os_log_debug_impl(&dword_1D8A54000, v65, OS_LOG_TYPE_DEBUG, " [%s] %s:%d parameterSetSupport=%u iPayload=%d", buf, 0x28u);
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v69 = VRTraceErrorLogLevelToCSTR();
    v70 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v71 = *((unsigned __int16 *)a2 + 248);
      v72 = *((unsigned __int8 *)a2 + 345);
      v73 = "Y";
      if (!*((_BYTE *)a2 + 541))
        v73 = "N";
      *(_DWORD *)buf = 136316418;
      *(_QWORD *)&buf[4] = v69;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "VideoTransmitter_CreateHandle";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 1652;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = v71;
      *(_WORD *)&buf[34] = 1024;
      *(_DWORD *)&buf[36] = v72;
      *(_WORD *)&buf[40] = 2080;
      *(_QWORD *)&buf[42] = v73;
      _os_log_impl(&dword_1D8A54000, v70, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VideoTransmitter_CreateHandle wMTU[%d] bIsIPv6[%d] reinitEnabled[%s]", buf, 0x32u);
    }
  }
  if (!*(_WORD *)(v5 + 17276))
  {
    v74 = *(_BYTE *)(v5 + 17278) ? 1280 : 1450;
    *(_WORD *)(v5 + 17276) = v74;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoTransmitter_CreateHandle_cold_17();
    }
  }
  *(_BYTE *)(v5 + 17352) = VCDefaults_GetBoolValueForKey(CFSTR("disableDynamicMediaPacketHeaderCalculations"), 0);
  IsInternalOSInstalled = VRTraceIsInternalOSInstalled();
  IntValueForKey = 0;
  if (IsInternalOSInstalled)
    IntValueForKey = VCDefaults_GetIntValueForKey(CFSTR("forceVideoTransmitterMTU"), 0);
  *(_WORD *)(v5 + 17354) = IntValueForKey;
  *(_BYTE *)(v5 + 16984) = 0;
  keyExistsAndHasValidFormat = 0;
  AppBooleanValue = CFPreferencesGetAppBooleanValue(CFSTR("treatLTEAs4G"), CFSTR("com.apple.VideoConference"), &keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat && AppBooleanValue && NetworkUtils_IsLTEOrNewer(a2[89]))
    *(_BYTE *)(v5 + 16984) = 1;
  if (*(_DWORD *)(v5 + 4420))
    RTPSetAFRCTxCap(*(_QWORD *)(v5 + 520), a2[104]);
  v78 = (_OWORD *)*((_QWORD *)a2 + 57);
  if (v78)
    *(_OWORD *)(v5 + 16808) = *v78;
  v79 = (CFTypeRef)*((_QWORD *)a2 + 60);
  v145 = (const __CFAllocator *)v35;
  if (v79)
    v79 = CFRetain(v79);
  v80 = a1;
  *(_QWORD *)(v5 + 16600) = v79;
  *(_DWORD *)(v5 + 16652) = -1;
  *(_DWORD *)(v5 + 16656) = a2[130];
  *(_QWORD *)(v5 + 16664) = *((_QWORD *)a2 + 66);
  if (*(_BYTE *)(v5 + 16984))
    v81 = 0;
  else
    v81 = a2[88];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v82 = VRTraceErrorLogLevelToCSTR();
    v83 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v84 = "NO";
      v85 = a2[90];
      *(_DWORD *)buf = 136316162;
      if (v81)
        v86 = "YES";
      else
        v86 = "NO";
      *(_QWORD *)&buf[4] = v82;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "VideoTransmitter_CreateHandle";
      if (v85)
        v84 = "YES";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 1695;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = v86;
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = v84;
      _os_log_impl(&dword_1D8A54000, v83, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VideoTransmitter_CreateHandle: local uses cellular[%s], remote uses cellular[%s].", buf, 0x30u);
    }
  }
  v87 = (_QWORD *)(v5 + 17364);
  *(_QWORD *)(v5 + 17364) = 0;
  v88 = a2[110];
  if (v88 == 100)
    v89 = 1752589105;
  else
    v89 = 1635148593;
  *(_DWORD *)(v5 + 17468) = v89;
  v90 = (const __CFString *)CFPreferencesCopyAppValue(CFSTR("FaceTimeEncoder"), CFSTR("com.apple.VideoConference"));
  if (v90)
  {
    v91 = v90;
    v92 = CFStringCompare(v90, CFSTR("hw"), 0);
    if (v88 == 100 || v92)
    {
      v98 = CFStringCompare(v91, CFSTR("sw"), 0);
      if (v88 == 100 || v98)
        goto LABEL_145;
      *v87 = 0x100000000;
      *(_DWORD *)(v5 + 16) = v88;
      v99 = v88 == 110 || (v88 & 0xFFFFFFFE) == 124;
      v100 = !v99;
      *(_BYTE *)(v5 + 18248) = v100;
      if ((int)VRTraceGetErrorLogLevelForModule() < 6)
        goto LABEL_145;
      v101 = VRTraceErrorLogLevelToCSTR();
      v96 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        goto LABEL_145;
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = v101;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "_VideoTransmitter_ForceEncoderType";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 1046;
      v97 = " [%s] %s:%d 'com.apple.VideoConference FaceTimeEncoder sw' forcing software h.264 encode";
    }
    else
    {
      *v87 = 0x100000001;
      *(_DWORD *)(v5 + 16) = v88;
      v94 = v88 != 110 && (v88 & 0xFFFFFFFE) != 124;
      *(_BYTE *)(v5 + 18248) = v94;
      if ((int)VRTraceGetErrorLogLevelForModule() < 6)
        goto LABEL_145;
      v95 = VRTraceErrorLogLevelToCSTR();
      v96 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        goto LABEL_145;
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = v95;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "_VideoTransmitter_ForceEncoderType";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 1041;
      v97 = " [%s] %s:%d 'com.apple.VideoConference FaceTimeEncoder hw' forcing hardware h.264 encode";
    }
    _os_log_impl(&dword_1D8A54000, v96, OS_LOG_TYPE_DEFAULT, v97, buf, 0x1Cu);
LABEL_145:
    CFRelease(v91);
  }
  *(_BYTE *)(v5 + 18248) = ((*(_DWORD *)(v5 + 16) - 110) > 0xF) | (0x3FFEu >> (*(_BYTE *)(v5 + 16) - 110)) & 1;
  *(_DWORD *)(v5 + 16648) = VCDefaults_GetIntValueForKey(CFSTR("forcePacketExpirationTime"), 0xFFFFFFFFLL);
  v102 = CreateHandle();
  if (v102 == 0xFFFFFFFFLL)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
    {
      v136 = 2149449733;
    }
    else
    {
      VRTraceErrorLogLevelToCSTR();
      v136 = 2149449733;
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoTransmitter_CreateHandle_cold_6();
    }
LABEL_216:
    v103 = 0xFFFFFFFFLL;
    goto LABEL_217;
  }
  v103 = v102;
  *(_QWORD *)(v5 + 512) = v102;
  if (*(_DWORD *)(v5 + 17368))
    v104 = (_DWORD *)(v5 + 17364);
  else
    v104 = (_DWORD *)(v5 + 16620);
  if ((_VideoTransmitter_CreateEncoder(v5, a2[94], a2[95], v5 + 104, *v104 != 0, a2[90] | (v81 != 0)) & 0x80000000) != 0)
  {
    v136 = 2149449730;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v141 = VRTraceErrorLogLevelToCSTR();
      v142 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v143 = a2[94];
        v144 = a2[95];
        *(_DWORD *)buf = 136316418;
        *(_QWORD *)&buf[4] = v141;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "VideoTransmitter_CreateHandle";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 1713;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v143;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = v144;
        *(_WORD *)&buf[40] = 1024;
        v136 = 2149449730;
        *(_DWORD *)&buf[42] = -2145517566;
        _os_log_error_impl(&dword_1D8A54000, v142, OS_LOG_TYPE_ERROR, " [%s] %s:%d VideoTransmitter_CreateHandle: EncCreateHandle FAILED %dx%d result: %d", buf, 0x2Eu);
      }
    }
    goto LABEL_217;
  }
  v105 = (dispatch_queue_t *)(v5 + 17720);
  if ((RTPCopyPreferredSendQueue(*(_QWORD *)(v5 + 520), (_QWORD *)(v5 + 17720)) & 0x80000000) != 0
    && (int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VideoTransmitter_CreateHandle_cold_16();
  }
  v106 = v80;
  if (!*v105)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v107 = VRTraceErrorLogLevelToCSTR();
      v108 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = v107;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VideoTransmitter_SetupTransmitQueue";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 1179;
        _os_log_impl(&dword_1D8A54000, v108, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Preferred transmit queue not set, creating default queue", buf, 0x1Cu);
      }
    }
    CustomRootQueue = VCDispatchQueue_GetCustomRootQueue(56);
    *v105 = dispatch_queue_create_with_target_V2("com.apple.VideoConference.videoTransmit", 0, CustomRootQueue);
  }
  if (*(_DWORD *)(v5 + 88) == 2016686640)
    v110 = 3;
  else
    v110 = 1;
  if ((VCSimpleQueueCreate(v110, (_QWORD *)(v5 + 17504)) & 0x80000000) != 0
    && (int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VideoTransmitter_CreateHandle_cold_15();
  }
  v111 = dispatch_semaphore_create(0);
  *(_QWORD *)(v5 + 17496) = v111;
  if (!v111 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VideoTransmitter_CreateHandle_cold_14();
  }
  *(_BYTE *)(v5 + 17488) = 0;
  *(_BYTE *)(v5 + 17760) = 0;
  pthread_rwlock_init((pthread_rwlock_t *)(v5 + 17520), 0);
  v112 = VCRealTimeThread_Initialize(18, (uint64_t)VideoTransmitter_EncoderProc, v5, "com.apple.avconference.videotransmitter.encoderproc", 2);
  *(_QWORD *)(v5 + 17480) = v112;
  if (v112)
  {
    v113 = VCRealTimeThread_Start(v112);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v114 = VRTraceErrorLogLevelToCSTR();
      v115 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v116 = "FAILED";
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = v114;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VideoTransmitter_SetupEncoderThreadAndPool";
        if (v113)
          v116 = "SUCCEEDED";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 944;
        *(_WORD *)&buf[28] = 2080;
        *(_QWORD *)&buf[30] = v116;
        _os_log_impl(&dword_1D8A54000, v115, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCRealTimeThread_Start for video encoder %s", buf, 0x26u);
      }
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoTransmitter_CreateHandle_cold_13();
    }
    VCRealTimeThread_Finalize(*(_QWORD *)(v5 + 17480));
  }
  *(_QWORD *)(v5 + 17728) = VCMemoryPool_Create(0x1C8uLL);
  *(_QWORD *)(v5 + 17736) = VCMemoryPool_Create(4uLL);
  *(_QWORD *)(v5 + 17744) = VCMemoryPool_Create(0x38uLL);
  CMSimpleQueueCreate(v145, 10, (CMSimpleQueueRef *)(v5 + 17752));
  if ((VCSimpleQueueSetElementEvictedCallback(*(_QWORD *)(v5 + 17504), (uint64_t)_VideoTransmitter_BufferEvictedCallback, *(_QWORD *)(v5 + 17744)) & 0x80000000) != 0&& (int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VideoTransmitter_CreateHandle_cold_12();
  }
  if ((VCSimpleQueueSetWillDestroyElementCallback(*(_QWORD *)(v5 + 17504), (uint64_t)_VideoTransmitter_BufferEvictedCallback, *(_QWORD *)(v5 + 17744)) & 0x80000000) != 0&& (int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VideoTransmitter_CreateHandle_cold_11();
  }
  pthread_mutex_init((pthread_mutex_t *)(v5 + 1680), 0);
  pthread_mutex_init((pthread_mutex_t *)(v5 + 2992), 0);
  pthread_mutex_init((pthread_mutex_t *)(v5 + 4272), 0);
  pthread_mutex_init((pthread_mutex_t *)(v5 + 16832), 0);
  pthread_mutex_init((pthread_mutex_t *)(v5 + 16912), 0);
  *(_WORD *)(v5 + 17356) = 257;
  *(_DWORD *)(v5 + 17360) = 0;
  *(_BYTE *)(v5 + 18264) = 1;
  v117 = MEMORY[0x1E0C809B0];
  *(_QWORD *)buf = MEMORY[0x1E0C809B0];
  *(_QWORD *)&buf[8] = 0x40000000;
  *(_QWORD *)&buf[16] = ___VideoTransmitter_ReportingRegisterPeriodicTask_block_invoke;
  *(_QWORD *)&buf[24] = &__block_descriptor_tmp_153;
  *(_QWORD *)&buf[32] = v103;
  reportingRegisterPeriodicTask();
  *v7 = a2[125];
  *(_BYTE *)(v5 + 16764) = 0;
  *(_BYTE *)(v5 + 16776) = 0;
  *(_QWORD *)(v5 + 16768) = 0;
  *(_QWORD *)(v5 + 16784) = 0;
  if (VRTraceIsInternalOSInstalled())
  {
    *(_BYTE *)(v5 + 16764) = CFPreferencesGetAppBooleanValue(CFSTR("enableTransmitterPacketDump"), CFSTR("com.apple.VideoConference"), 0) != 0;
    *(_BYTE *)(v5 + 16776) = CFPreferencesGetAppBooleanValue(CFSTR("enableTransmitterFrameDump"), CFSTR("com.apple.VideoConference"), 0) != 0;
    *(_BYTE *)(v5 + 18289) = CFPreferencesGetAppBooleanValue(CFSTR("enableTransmitterTestVerification"), CFSTR("com.apple.VideoConference"), 0) != 0;
  }
  if (*(_BYTE *)(v5 + 16764))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      v118 = VRTraceErrorLogLevelToCSTR();
      v119 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = v118;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VideoTransmitter_SetupLogFiles";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 901;
        _os_log_impl(&dword_1D8A54000, v119, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VideoConferenceTransmitter: Found enableTransmitterPacketDump YES. Log outgoing video packets into AFRC folder", buf, 0x1Cu);
      }
    }
    memset(buf, 170, 12);
    __sprintf_chk(buf, 0, 0xCuLL, "%010u", *v7);
    v120 = openLogDump(0, (uint64_t)buf, 1, (uint64_t)"out_pkt", (uint64_t)".txt", 0);
    *(_QWORD *)(v5 + 16768) = v120;
    if (!v120 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoTransmitter_CreateHandle_cold_10();
    }
  }
  if (*(_BYTE *)(v5 + 16776))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      v121 = VRTraceErrorLogLevelToCSTR();
      v122 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = v121;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VideoTransmitter_SetupLogFiles";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 911;
        _os_log_impl(&dword_1D8A54000, v122, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VideoConferenceTransmitter: Found enableTransmitterFrameDump YES. Log outgoing video frames into AFRC folder", buf, 0x1Cu);
      }
    }
    memset(buf, 170, 12);
    __sprintf_chk(buf, 0, 0xCuLL, "%010u", *v7);
    v123 = openLogDump(0, (uint64_t)buf, 1, (uint64_t)"out_frame", (uint64_t)".txt", 0);
    *(_QWORD *)(v5 + 16784) = v123;
    if (!v123 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoTransmitter_CreateHandle_cold_9();
    }
  }
  if (VCDefaults_GetBoolValueForKey(CFSTR("enableVideoCaptureStatistics"), 0))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      v124 = VRTraceErrorLogLevelToCSTR();
      v125 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = v124;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VideoTransmitter_SetupLogFiles";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 921;
        *(_WORD *)&buf[28] = 2048;
        *(_QWORD *)&buf[30] = v5;
        _os_log_impl(&dword_1D8A54000, v125, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VideoTransmitter[%p]: Found enableVideoCaptureStatistics YES. Log outgoing video frames statistics", buf, 0x26u);
      }
    }
    *(_QWORD *)&v126 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v126 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v151 = v126;
    v152 = v126;
    v149 = v126;
    v150 = v126;
    *(_OWORD *)&buf[32] = v126;
    *(_OWORD *)&buf[48] = v126;
    *(_OWORD *)buf = v126;
    *(_OWORD *)&buf[16] = v126;
    snprintf(buf, 0x80uLL, "videotransmitter-%p_%dx%d", (const void *)v5, *(_DWORD *)(v5 + 24), *(_DWORD *)(v5 + 28));
    v127 = openLogDump(0, (uint64_t)buf, 0, (uint64_t)"statistics", (uint64_t)".log", 0);
    *(_QWORD *)(v5 + 16800) = v127;
    if (v127)
    {
      fputs("System Timestamp\tHost Time\tAudio TimeStamp\tAudio HostTime\tTimestamp\n", v127);
      *(_BYTE *)(v5 + 16792) = 1;
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoTransmitter_CreateHandle_cold_8();
    }
  }
  if (*(_DWORD *)(v5 + 496) == 1)
  {
    v128 = *(void **)(v5 + 1664);
    v147[0] = v117;
    v147[1] = 0x40000000;
    v147[2] = ___VideoTransmitter_RegisterStatistics_block_invoke;
    v147[3] = &__block_descriptor_tmp_180;
    v147[4] = v5;
    *(_DWORD *)(v5 + 18080) = VCRateControlRegisterStatisticsChangeHandler(v128, 3, (uint64_t)v147);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v129 = VRTraceErrorLogLevelToCSTR();
      v130 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v131 = *(_QWORD *)(v5 + 1664);
        v132 = *(_DWORD *)(v5 + 18080);
        *(_DWORD *)buf = 136316418;
        *(_QWORD *)&buf[4] = v129;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VideoTransmitter_RegisterStatistics";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 1244;
        *(_WORD *)&buf[28] = 2048;
        *(_QWORD *)&buf[30] = v5;
        *(_WORD *)&buf[38] = 2048;
        *(_QWORD *)&buf[40] = v131;
        *(_WORD *)&buf[48] = 1024;
        *(_DWORD *)&buf[50] = v132;
        _os_log_impl(&dword_1D8A54000, v130, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d videoTransmitter[%p] Registered statisticsCollector[%p] with index=%d", buf, 0x36u);
      }
    }
  }
  v133 = CMMemoryPoolCreate(0);
  *(_QWORD *)(v5 + 18144) = v133;
  Allocator = CMMemoryPoolGetAllocator(v133);
  *(_QWORD *)(v5 + 18136) = Allocator;
  CFRetain(Allocator);
  *(_DWORD *)(v5 + 12) = reportingDefaultRealtimePeriod();
  *(_BYTE *)(v5 + 18184) = *((_BYTE *)a2 + 580);
  *(_BYTE *)(v5 + 18152) = *((_BYTE *)a2 + 542);
  *(_WORD *)(v5 + 18185) = *((_WORD *)a2 + 308);
  FECFeedbackVersion = VCMediaControlInfoGeneratorGetFECFeedbackVersion(*(_QWORD *)(v5 + 1648));
  *(_DWORD *)(v5 + 18252) = a2[151];
  VCAllocatorFirstCome_Create(v145, (uint64_t)"VideoTransmitterBufferDataAllocator", (CFAllocatorRef *)(v5 + 18168));
  VCAllocatorFirstCome_Create(v145, (uint64_t)"VideoTransmitterBufferHeaderAllocator", (CFAllocatorRef *)(v5 + 18176));
  VCAllocatorFirstCome_Create(v145, (uint64_t)"VideoTransmitterNumberPropertyAllocator", (CFAllocatorRef *)(v5 + 18304));
  v136 = VCFECGenerator_Create((uint64_t)v145, (uint64_t *)(v5 + 18160), *(_DWORD *)(v5 + 4428), FECFeedbackVersion, *(const void **)(v5 + 18176), *(const void **)(v5 + 18168), *(const void **)v5);
  if ((v136 & 0x80000000) != 0 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VideoTransmitter_CreateHandle_cold_7();
  }
  v137 = (CFTypeRef)*((_QWORD *)a2 + 76);
  if (v137)
    v137 = CFRetain(v137);
  *(_QWORD *)(v5 + 18296) = v137;
  *(double *)(v5 + 18240) = micro();
  *v106 = v103;
  if ((_DWORD)v136)
LABEL_217:
    _VideoTransmitter_CleanUp(v5, v103);
  return v136;
}

uint64_t _VideoTransmitter_CreateEncoder(uint64_t a1, int a2, int a3, uint64_t a4, int a5, unsigned int a6)
{
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  int v15;
  int v16;
  uint64_t v17;
  NSObject *v18;
  char *v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  __int128 v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int *v28;
  _DWORD *v29;
  uint64_t v30;
  int v31;
  int v32;
  _DWORD *v33;
  uint64_t v34;
  uint64_t v35;
  _BYTE v37[24];
  int v38;
  __int16 v39;
  uint64_t v40;
  __int16 v41;
  int v42;
  __int16 v43;
  int v44;
  __int16 v45;
  char *v46;
  __int16 v47;
  int v48;
  uint8_t buf[4];
  uint64_t v50;
  _BYTE v51[24];
  _BYTE v52[20];
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  _DWORD v59[16];
  uint64_t v60;

  v60 = *MEMORY[0x1E0C80C00];
  v12 = a1 + 16524;
  if (*(_BYTE *)(a1 + 18092))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v13 = VRTraceErrorLogLevelToCSTR();
      v14 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v15 = *(unsigned __int16 *)(v12 + 1572);
        v16 = *(unsigned __int16 *)(v12 + 1570);
        *(_DWORD *)buf = 136316418;
        v50 = v13;
        *(_WORD *)v51 = 2080;
        *(_QWORD *)&v51[2] = "_VideoTransmitter_CreateEncoder";
        *(_WORD *)&v51[10] = 1024;
        *(_DWORD *)&v51[12] = 1111;
        *(_WORD *)&v51[16] = 1024;
        *(_DWORD *)&v51[18] = v15;
        *(_WORD *)&v51[22] = 1024;
        *(_DWORD *)v52 = v16;
        *(_WORD *)&v52[4] = 1024;
        *(_DWORD *)&v52[6] = v16 + v15;
        _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Encoder is being created. Resetting expectedDecodingOrder(%d) to 0. Setting decodingOrderBase(%d) to %d", buf, 0x2Eu);
      }
    }
    *(_WORD *)(v12 + 1570) += *(_WORD *)(v12 + 1572);
    *(_WORD *)(v12 + 1572) = 0;
  }
  memset(v59, 0, 48);
  v58 = 0u;
  v57 = 0u;
  v56 = 0u;
  v55 = 0u;
  v54 = 0u;
  v53 = 0u;
  *(_OWORD *)&v52[4] = 0u;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v17 = VRTraceErrorLogLevelToCSTR();
    v18 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v19 = FourccToCStr(*(_DWORD *)(v12 + 944));
      v20 = *(_QWORD *)(a1 + 512);
      *(_DWORD *)v37 = 136316930;
      *(_QWORD *)&v37[4] = v17;
      *(_WORD *)&v37[12] = 2080;
      *(_QWORD *)&v37[14] = "_VideoTransmitter_CreateEncoder";
      *(_WORD *)&v37[22] = 1024;
      v38 = 1116;
      v39 = 2048;
      v40 = a1;
      v41 = 1024;
      v42 = a3;
      v43 = 1024;
      v44 = a2;
      v45 = 2080;
      v46 = v19;
      v47 = 1024;
      v48 = v20;
      _os_log_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Create encoder=%p height=%d, width=%d, codec=%s, videoTransmitterHandle=0x%x", v37, 0x42u);
    }
  }
  *(_DWORD *)buf = a2;
  LODWORD(v50) = a3;
  DWORD2(v57) = *(_DWORD *)(a1 + 88);
  v21 = *(_DWORD *)(v12 + 944);
  v22 = *(_QWORD *)(a1 + 56);
  *(_QWORD *)&v23 = v22;
  *((_QWORD *)&v23 + 1) = HIDWORD(v22);
  *(_OWORD *)&v51[4] = v23;
  *(_DWORD *)&v51[20] = *(_DWORD *)(a1 + 32);
  *(_QWORD *)v52 = *(_QWORD *)(a1 + 44);
  *(_QWORD *)&v52[12] = *(_QWORD *)(a1 + 16600);
  *(_QWORD *)&v53 = a4;
  DWORD2(v53) = a5;
  BYTE12(v53) = *(_DWORD *)(v12 + 292) != 0;
  *(_QWORD *)&v54 = __PAIR64__(*(_DWORD *)v12, a6);
  DWORD2(v54) = *(_DWORD *)(v12 + 756);
  BYTE12(v54) = *(_BYTE *)(v12 + 760);
  v24 = *(_DWORD *)(v12 + 1560);
  LODWORD(v55) = *(_DWORD *)(v12 + 848);
  DWORD1(v55) = v24;
  v25 = *(_QWORD *)(a1 + 512);
  *((_QWORD *)&v55 + 1) = _VideoTransmitter_DispatchEncoderCallback;
  *((_QWORD *)&v56 + 1) = v25;
  LODWORD(v25) = *(_DWORD *)(v12 + 1564);
  LODWORD(v57) = *(_DWORD *)(v12 + 132);
  DWORD1(v57) = v25;
  HIDWORD(v50) = *(_DWORD *)(a1 + 52);
  *(_DWORD *)v51 = v21;
  WORD6(v57) = *(_WORD *)(v12 + 1570);
  *(_QWORD *)&v58 = *(_QWORD *)(a1 + 18216);
  v59[13] = *(_DWORD *)(v12 + 1596);
  BYTE8(v58) = *(_BYTE *)(v12 + 1580);
  v26 = *(unsigned int *)(v12 + 1584);
  v27 = *(unsigned int *)(a1 + 1600);
  v59[12] = *(_DWORD *)(v12 + 1584);
  HIDWORD(v58) = v27;
  if ((_DWORD)v27)
  {
    v28 = (int *)(a1 + 628);
    v29 = v59;
    v30 = v27;
    do
    {
      v31 = *v28;
      v28 += 30;
      *v29++ = v31;
      --v30;
    }
    while (v30);
  }
  if (v27 < v26)
  {
    v32 = *(_DWORD *)(a1 + 120 * (v27 - 1) + 628);
    v33 = &v59[v27];
    v34 = v26 - v27;
    do
    {
      *v33++ = v32;
      --v34;
    }
    while (v34);
    HIDWORD(v58) = v26;
  }
  memset(v37, 170, sizeof(v37));
  VCVideoEncoderVCPInitialize((uint64_t)v37);
  v35 = *(_QWORD *)&v37[16];
  *(_QWORD *)(a1 + 1632) = *(_QWORD *)&v37[16];
  *(_OWORD *)(a1 + 1616) = *(_OWORD *)v37;
  if (v35 == 0xFFFFFFFFLL)
    return (**(uint64_t (***)(uint64_t, uint8_t *))(a1 + 1616))(a1 + 1632, buf);
  else
    return 2148007957;
}

void _VideoTransmitter_BufferEvictedCallback(int a1, OSQueueHead *__list, CFTypeRef *__new)
{
  if (*__new)
  {
    CFRelease(*__new);
    *__new = 0;
  }
  VCMemoryPool_Free(__list, __new);
}

void _VideoTransmitter_CleanUp(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  _QWORD *v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t *v7;
  const void *v8;
  uint64_t v9;
  NSObject *v10;
  const void *v11;
  OpaqueCMMemoryPool *v12;
  const void *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  const void *v17;
  const void *v18;
  const void *v19;
  OSQueueHead *v20;
  OSQueueHead *v21;
  OSQueueHead *v22;
  __CVBuffer *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  const void *v28;
  const void *v29;
  const void *v30;
  const void *v31;
  const void *v32;
  OpaqueVTPixelTransferSession *v33;
  const void *v34;
  __CVPixelBufferPool *v35;
  FILE *v36;
  FILE *v37;
  FILE *v38;
  const void *v39;
  const void *v40;

  if (a2 != 0xFFFFFFFFLL)
    CheckOutHandleDebug();
  v3 = *(NSObject **)(a1 + 17496);
  if (v3)
    dispatch_release(v3);
  v4 = *(_QWORD **)(a1 + 17504);
  if (v4)
  {
    VCSimpleQueueDestroy(v4);
    *(_QWORD *)(a1 + 17504) = 0;
  }
  v5 = *(unsigned int *)(a1 + 1600);
  if ((_DWORD)v5)
  {
    v6 = 0;
    v7 = (uint64_t *)(a1 + 520);
    do
    {
      if (*v7 != 0xFFFFFFFFLL)
      {
        RTPTransport_SetNACKConsumer(*v7, 0);
        v5 = *(unsigned int *)(a1 + 1600);
      }
      ++v6;
      v7 += 15;
    }
    while (v6 < v5);
  }
  v8 = *(const void **)(a1 + 18272);
  if (v8)
  {
    CFRelease(v8);
    *(_QWORD *)(a1 + 18272) = 0;
  }
  VideoTransmitter_CleanupSframeCryptors(a1);
  VideoTransmitter_CloseSummerHandles(a1);
  v9 = *(_QWORD *)(a1 + 1616);
  if (v9 && *(_QWORD *)(a1 + 1632) != 0xFFFFFFFFLL)
  {
    (*(void (**)(void))(v9 + 8))();
    *(_QWORD *)(a1 + 1632) = 0xFFFFFFFFLL;
  }
  v10 = *(NSObject **)(a1 + 17720);
  if (v10)
  {
    dispatch_release(v10);
    *(_QWORD *)(a1 + 17720) = 0;
  }
  _VideoTransmitter_DequeueEncoderError(a1);
  v11 = *(const void **)(a1 + 18136);
  if (v11)
  {
    CFRelease(v11);
    *(_QWORD *)(a1 + 18136) = 0;
  }
  v12 = *(OpaqueCMMemoryPool **)(a1 + 18144);
  if (v12)
  {
    CMMemoryPoolInvalidate(v12);
    v13 = *(const void **)(a1 + 18144);
    if (v13)
    {
      CFRelease(v13);
      *(_QWORD *)(a1 + 18144) = 0;
    }
  }
  v14 = *(const void **)(a1 + 18296);
  if (v14)
  {
    CFRelease(v14);
    *(_QWORD *)(a1 + 18296) = 0;
  }
  v15 = *(const void **)(a1 + 18160);
  if (v15)
  {
    CFRelease(v15);
    *(_QWORD *)(a1 + 18160) = 0;
  }
  v16 = *(const void **)(a1 + 18168);
  if (v16)
  {
    CFRelease(v16);
    *(_QWORD *)(a1 + 18168) = 0;
  }
  v17 = *(const void **)(a1 + 18176);
  if (v17)
  {
    CFRelease(v17);
    *(_QWORD *)(a1 + 18176) = 0;
  }
  v18 = *(const void **)(a1 + 18304);
  if (v18)
  {
    CFRelease(v18);
    *(_QWORD *)(a1 + 18304) = 0;
  }
  v19 = *(const void **)(a1 + 17752);
  if (v19)
  {
    CFRelease(v19);
    *(_QWORD *)(a1 + 17752) = 0;
  }
  v20 = *(OSQueueHead **)(a1 + 17728);
  if (v20)
  {
    VCMemoryPool_Destroy(v20);
    *(_QWORD *)(a1 + 17728) = 0;
  }
  v21 = *(OSQueueHead **)(a1 + 17736);
  if (v21)
  {
    VCMemoryPool_Destroy(v21);
    *(_QWORD *)(a1 + 17736) = 0;
  }
  v22 = *(OSQueueHead **)(a1 + 17744);
  if (v22)
  {
    VCMemoryPool_Destroy(v22);
    *(_QWORD *)(a1 + 17744) = 0;
  }
  v23 = *(__CVBuffer **)(a1 + 432);
  if (v23)
  {
    CVPixelBufferRelease(v23);
    *(_QWORD *)(a1 + 432) = 0;
  }
  v24 = *(void **)(a1 + 280);
  if (v24)
  {
    free(v24);
    *(_QWORD *)(a1 + 280) = 0;
  }
  v25 = *(void **)(a1 + 288);
  if (v25)
  {
    free(v25);
    *(_QWORD *)(a1 + 288) = 0;
  }
  v26 = *(void **)(a1 + 312);
  if (v26)
  {
    free(v26);
    *(_QWORD *)(a1 + 312) = 0;
  }
  v27 = *(void **)(a1 + 304);
  if (v27)
  {
    free(v27);
    *(_QWORD *)(a1 + 304) = 0;
  }
  v28 = *(const void **)(a1 + 18216);
  if (v28)
    CFRelease(v28);
  v29 = *(const void **)(a1 + 16600);
  if (v29)
    CFRelease(v29);
  v30 = *(const void **)(a1 + 1648);
  if (v30)
    CFRelease(v30);
  v31 = *(const void **)(a1 + 1656);
  if (v31)
    CFRelease(v31);
  v32 = *(const void **)(a1 + 1664);
  if (v32)
    CFRelease(v32);
  reportingCacheModuleSpecificInfo();
  if (*(_QWORD *)a1)
    CFRelease(*(CFTypeRef *)a1);
  v33 = *(OpaqueVTPixelTransferSession **)(a1 + 17448);
  if (v33)
  {
    VTPixelTransferSessionInvalidate(v33);
    v34 = *(const void **)(a1 + 17448);
    if (v34)
    {
      CFRelease(v34);
      *(_QWORD *)(a1 + 17448) = 0;
    }
  }
  v35 = *(__CVPixelBufferPool **)(a1 + 17456);
  if (v35)
  {
    CVPixelBufferPoolRelease(v35);
    *(_QWORD *)(a1 + 17456) = 0;
  }
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 1680));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 2992));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 4272));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16832));
  v36 = *(FILE **)(a1 + 16784);
  if (v36)
    fclose(v36);
  v37 = *(FILE **)(a1 + 16768);
  if (v37)
    fclose(v37);
  v38 = *(FILE **)(a1 + 16800);
  if (v38)
    fclose(v38);
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16832));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16912));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 17000));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 17288));
  v39 = *(const void **)(a1 + 18128);
  if (v39)
  {
    CFRelease(v39);
    *(_QWORD *)(a1 + 18128) = 0;
  }
  v40 = *(const void **)(a1 + 4392);
  if (v40)
    CFRelease(v40);
  free((void *)a1);
}

uint64_t VideoTransmitter_CloseHandle(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  int v9;
  int v11;
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  uint64_t v18;
  __int16 v19;
  uint64_t v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v2 = CheckInHandleDebug();
  if (!v2)
    return 2149449730;
  v3 = v2;
  v4 = v2 + 17488;
  *(_BYTE *)(v2 + 17488) = 1;
  *(_BYTE *)(v2 + 17760) = 0;
  VCRealTimeThread_Stop(*(_QWORD *)(v2 + 17480));
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v3 + 17496));
  VCRealTimeThread_Finalize(*(_QWORD *)(v3 + 17480));
  pthread_rwlock_destroy((pthread_rwlock_t *)(v3 + 17520));
  reportingUnregisterPeriodicTask();
  v5 = *(unsigned int *)(v4 + 592);
  if ((int)v5 >= 1)
  {
    VCRateControlUnregisterStatisticsChangeHandler(*(void **)(v3 + 1664), 3, v5);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v6 = VRTraceErrorLogLevelToCSTR();
      v7 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v8 = *(_QWORD *)(v3 + 1664);
        v9 = *(_DWORD *)(v4 + 592);
        v11 = 136316418;
        v12 = v6;
        v13 = 2080;
        v14 = "_VideoTransmitter_UnregisterStatistics";
        v15 = 1024;
        v16 = 1251;
        v17 = 2048;
        v18 = v3;
        v19 = 2048;
        v20 = v8;
        v21 = 1024;
        v22 = v9;
        _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d videoTransmitter[%p] Unregistered statisticsCollector[%p] with index=%d", (uint8_t *)&v11, 0x36u);
      }
    }
  }
  _VideoTransmitter_CleanUp(v3, a1);
  return 0;
}

uint64_t _VideoTransmitter_PrepareEncodingBuffer(uint64_t a1, CVPixelBufferRef texture, CVPixelBufferRef *a3, int a4, _DWORD *a5, char a6)
{
  uint64_t v9;
  __int128 v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  NSObject *v18;
  double v19;
  double v20;
  __int128 v21;
  int v23;
  uint64_t v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  uint64_t v30;
  __int16 v31;
  double v32;
  __int16 v33;
  char *v34;
  __int16 v35;
  char *v36;
  __int16 v37;
  int v38;
  char v39[16];
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  char __str[16];
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v9 = a1 + 16672;
  v10 = *(_OWORD *)(MEMORY[0x1E0C9D628] + 16);
  v11 = a1 + 16680;
  *(_OWORD *)(a1 + 16680) = *MEMORY[0x1E0C9D628];
  *(_OWORD *)(a1 + 16696) = v10;
  if ((a6 & 0x10) != 0)
    v12 = 0;
  else
    v12 = *(_DWORD *)(a1 + 16988);
  *a3 = CVPixelBufferRetain(texture);
  *a5 = 0;
  if (*(_BYTE *)(v9 + 1617))
    VCVideoHardwareDumpCollector_RecordEncoderBuffer(*(_QWORD *)(a1 + 18296), a4 != 0, 0, 0, 0, 0);
  if (v12 && *(_DWORD *)v9)
  {
    *(double *)(a1 + 16680) = VideoUtil_CalculateVisibleRect();
    *(_QWORD *)(a1 + 16688) = v13;
    *(_QWORD *)(a1 + 16696) = v14;
    *(_QWORD *)(a1 + 16704) = v15;
  }
  if (!CGRectEqualToRect(*(CGRect *)(a1 + 16712), *(CGRect *)(a1 + 16680)))
  {
    *(_QWORD *)&v16 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v53 = v16;
    v54 = v16;
    v51 = v16;
    v52 = v16;
    v49 = v16;
    v50 = v16;
    *(_OWORD *)__str = v16;
    v48 = v16;
    v45 = v16;
    v46 = v16;
    v43 = v16;
    v44 = v16;
    v41 = v16;
    v42 = v16;
    *(_OWORD *)v39 = v16;
    v40 = v16;
    VideoUtil_StringVisibleRect((double *)(a1 + 16712), __str, 0x80uLL);
    VideoUtil_StringVisibleRect((double *)v11, v39, 0x80uLL);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v17 = VRTraceErrorLogLevelToCSTR();
      v18 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v19 = *(double *)(a1 + 16704);
        v20 = 0.0;
        if (v19 != 0.0)
          v20 = *(double *)(a1 + 16696) / v19;
        v23 = 136316930;
        v24 = v17;
        v25 = 2080;
        v26 = "_VideoTransmitter_PrepareEncodingBuffer";
        v27 = 1024;
        v28 = 2271;
        v29 = 2048;
        v30 = a1;
        v31 = 2048;
        v32 = v20;
        v33 = 2080;
        v34 = __str;
        v35 = 2080;
        v36 = v39;
        v37 = 1024;
        v38 = a4;
        _os_log_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d [AR_TX][%p] AspectRatio=%.3f, visibleRect changed from %s to %s, fPortrait = %d", (uint8_t *)&v23, 0x4Au);
      }
    }
    v21 = *(_OWORD *)(v11 + 16);
    *(_OWORD *)(a1 + 16712) = *(_OWORD *)v11;
    *(_OWORD *)(a1 + 16728) = v21;
  }
  return 0;
}

uint64_t _VideoTransmitter_CalculateVideoTimestamp(uint64_t a1, uint64_t a2, double a3, double a4)
{
  double v5;
  uint64_t v8;
  double v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  int v14;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  int v19;
  __int128 v20;
  FILE *v21;
  char *Timestamp;
  uint64_t v24;
  NSObject *v25;
  _BYTE buf[48];
  _OWORD v27[5];
  uint64_t v28;

  v5 = a3;
  v28 = *MEMORY[0x1E0C80C00];
  v8 = a1 + 16792;
  if ((_DWORD)a2)
  {
    v9 = (double)a2 + (a4 - a3) * (double)*(int *)(a1 + 4404);
  }
  else
  {
    if (a3 == 0.0)
      v5 = a4;
    v9 = (a4 - v5) * (double)(*(_DWORD *)(a1 + 4404) - 500);
  }
  v10 = v9;
  if (!*(_BYTE *)(a1 + 17356))
    goto LABEL_13;
  if (((v10 ^ a2) & 0x80000000) == 0 || a2 >> 30 && v10 >> 30)
  {
    *(_BYTE *)(a1 + 17356) = 0;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v11 = VRTraceErrorLogLevelToCSTR();
      v12 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136316674;
        *(_QWORD *)&buf[4] = v11;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VideoTransmitter_CalculateVideoTimestamp";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 2439;
        *(_WORD *)&buf[28] = 2048;
        *(double *)&buf[30] = v5;
        *(_WORD *)&buf[38] = 2048;
        *(double *)&buf[40] = a4;
        LOWORD(v27[0]) = 1024;
        *(_DWORD *)((char *)v27 + 2) = a2;
        WORD3(v27[0]) = 1024;
        DWORD2(v27[0]) = v10;
        _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d CalculateVideoTimestamp (pol match): dAudio/dVideo: %f/%f  dwAudioTS/dwVideoTS: %u/%u", buf, 0x3Cu);
      }
    }
LABEL_13:
    v13 = v10;
    goto LABEL_14;
  }
  v13 = a2;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v24 = VRTraceErrorLogLevelToCSTR();
    v25 = *MEMORY[0x1E0CF2758];
    v13 = a2;
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136316930;
      *(_QWORD *)&buf[4] = v24;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "_VideoTransmitter_CalculateVideoTimestamp";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 2435;
      *(_WORD *)&buf[28] = 2048;
      *(double *)&buf[30] = v5;
      *(_WORD *)&buf[38] = 2048;
      *(double *)&buf[40] = a4;
      LOWORD(v27[0]) = 1024;
      *(_DWORD *)((char *)v27 + 2) = a2;
      WORD3(v27[0]) = 1024;
      DWORD2(v27[0]) = v10;
      WORD6(v27[0]) = 1024;
      *(_DWORD *)((char *)v27 + 14) = a2;
      _os_log_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d CalculateVideoTimestamp override (pol mismatch): dAudio/dVideo: %f/%f  dwAudioTS/dwVideoTS: %u/%u -> %u", buf, 0x42u);
      v13 = a2;
    }
  }
LABEL_14:
  if (*(_BYTE *)(v8 + 565))
  {
    *(_BYTE *)(v8 + 565) = 0;
  }
  else
  {
    v14 = *(_DWORD *)(v8 + 568);
    if ((_DWORD)v13 == v14 || (v13 - v14) >= 0x7FFFFFFF)
    {
      v16 = (v14 + 1);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v17 = VRTraceErrorLogLevelToCSTR();
        v18 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v19 = *(_DWORD *)(v8 + 568);
          *(_DWORD *)buf = 136317186;
          *(_QWORD *)&buf[4] = v17;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VideoTransmitter_CalculateVideoTimestamp";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 2453;
          *(_WORD *)&buf[28] = 2048;
          *(double *)&buf[30] = v5;
          *(_WORD *)&buf[38] = 2048;
          *(double *)&buf[40] = a4;
          LOWORD(v27[0]) = 1024;
          *(_DWORD *)((char *)v27 + 2) = a2;
          WORD3(v27[0]) = 1024;
          DWORD2(v27[0]) = v13;
          WORD6(v27[0]) = 1024;
          *(_DWORD *)((char *)v27 + 14) = v16;
          WORD1(v27[1]) = 1024;
          DWORD1(v27[1]) = v19;
          _os_log_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d CalculateVideoTimestamp FORCE forward: dAudio/dVideo: %f/%f  dwAudioTS/dwVideoTS: %u/%u -> %u (last: %u)", buf, 0x48u);
        }
      }
      v13 = v16;
    }
  }
  *(_DWORD *)(v8 + 568) = v13;
  if (*(_BYTE *)v8)
  {
    *(_QWORD *)&v20 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v27[3] = v20;
    v27[4] = v20;
    v27[1] = v20;
    v27[2] = v20;
    *(_OWORD *)&buf[32] = v20;
    v27[0] = v20;
    *(_OWORD *)buf = v20;
    *(_OWORD *)&buf[16] = v20;
    v21 = *(FILE **)(a1 + 16800);
    Timestamp = VRLogfileGetTimestamp(buf, 0x80u);
    fprintf(v21, "%s\t%f\t%d\t%f\t%d\n", Timestamp, a4, a2, v5, v13);
  }
  return v13;
}

uint64_t _VideoTransmitter_UpdateEncoderBitrate(uint64_t a1, unsigned int a2)
{
  int v3;
  unsigned int v4;
  int v5;
  unsigned int *v6;
  unsigned int v7;
  double v8;
  uint64_t v9;
  NSObject *v10;
  unsigned int v11;
  unsigned int v12;
  double v13;
  uint64_t v14;
  NSObject *v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  NSObject *v19;
  unsigned int v20;
  const __CFAllocator *v21;
  CFMutableArrayRef Mutable;
  __CFArray *v23;
  CFNumberRef v24;
  CFNumberRef v25;
  uint64_t v26;
  int v28;
  uint64_t v29;
  __int16 v30;
  const char *v31;
  __int16 v32;
  int v33;
  __int16 v34;
  unsigned int v35;
  __int16 v36;
  _BYTE v37[24];
  __int16 v38;
  uint64_t v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v3 = *(_DWORD *)(a1 + 4400);
  v4 = v3 + 15000;
  v5 = a2 - v3;
  if (v5 <= 15000)
    v5 = 15000;
  if (v4 >= a2)
    v5 = 15000;
  *(_DWORD *)(a1 + 36) = v5;
  v6 = (unsigned int *)(a1 + 36);
  if (*(_DWORD *)(a1 + 17372) == 20 && *(_DWORD *)(a1 + 4420))
  {
    v7 = atomic_load((unsigned int *)(a1 + 16492));
    v8 = (double)v7;
    if (v7 > 0x4AF)
    {
      v12 = *(_DWORD *)(a1 + 36);
      v13 = v8 / 6000.0 + -0.2;
      *(_DWORD *)(a1 + 36) = (int)fmax((1.0 - v13) * (double)v12, 15000.0);
      if (*(double *)(a1 + 384) != v13)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v14 = VRTraceErrorLogLevelToCSTR();
          v15 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v16 = *v6;
            v28 = 136316930;
            v29 = v14;
            v30 = 2080;
            v31 = "_VideoTransmitter_AdjustEncoderBitrateBasedOnMediaQueueSize";
            v32 = 1024;
            v33 = 2658;
            v34 = 1024;
            v35 = v12;
            v36 = 1024;
            *(_DWORD *)v37 = v16;
            *(_WORD *)&v37[4] = 2048;
            *(double *)&v37[6] = v8 / 6000.0 + -0.2;
            *(_WORD *)&v37[14] = 2048;
            *(double *)&v37[16] = v8;
            v38 = 2048;
            v39 = 0x40B7700000000000;
            _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Adjust video bitrate from currentBitrate=%u to newBitrate=%u with new adjustmentFactor=%f, queueSize=%f, queueSizeLimit=%f", (uint8_t *)&v28, 0x46u);
          }
        }
        *(double *)(a1 + 384) = v13;
      }
    }
    else
    {
      if (*(double *)(a1 + 384) > 0.0 && (int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v9 = VRTraceErrorLogLevelToCSTR();
        v10 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v11 = *v6;
          v28 = 136316418;
          v29 = v9;
          v30 = 2080;
          v31 = "_VideoTransmitter_AdjustEncoderBitrateBasedOnMediaQueueSize";
          v32 = 1024;
          v33 = 2649;
          v34 = 1024;
          v35 = v11;
          v36 = 2048;
          *(double *)v37 = v8;
          *(_WORD *)&v37[8] = 2048;
          *(_QWORD *)&v37[10] = 0x40B7700000000000;
          _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Stop adjusting video bitrate=%u with low queueSize=%f, queueSizeLimit=%f", (uint8_t *)&v28, 0x36u);
        }
      }
      *(_QWORD *)(a1 + 384) = 0;
    }
  }
  v17 = *(_DWORD *)(a1 + 36);
  if (v17 != *(_DWORD *)(a1 + 32))
  {
    if (v17 >= *(_DWORD *)(a1 + 40))
      v17 = *(_DWORD *)(a1 + 40);
    *(_DWORD *)(a1 + 36) = v17;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v18 = VRTraceErrorLogLevelToCSTR();
      v19 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v20 = *v6;
        v28 = 136315906;
        v29 = v18;
        v30 = 2080;
        v31 = "_VideoTransmitter_UpdateEncoderBitrate";
        v32 = 1024;
        v33 = 2683;
        v34 = 1024;
        v35 = v20;
        _os_log_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d SETTING THE NEW VIDEO RATE to %u bps", (uint8_t *)&v28, 0x22u);
      }
    }
    v21 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
    if (Mutable)
    {
      v23 = Mutable;
      v24 = CFNumberCreate(v21, kCFNumberIntType, v6);
      if (v24)
      {
        v25 = v24;
        CFArrayAppendValue(v23, v24);
        CFRelease(v25);
        v26 = *(_QWORD *)(a1 + 1632);
        if (v26 != 0xFFFFFFFFLL)
          (*(void (**)(uint64_t, __CFArray *))(*(_QWORD *)(a1 + 1616) + 24))(v26, v23);
        CFRelease(v23);
        *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 36);
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VideoTransmitter_UpdateEncoderBitrate_cold_2();
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VideoTransmitter_UpdateEncoderBitrate_cold_1();
    }
  }
  return *(unsigned int *)(a1 + 32);
}

BOOL _VideoTransmitter_RequireEncoderResolutionChange(uint64_t a1, int *a2, int *a3, const char **a4, double a5)
{
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  unint64_t v14;
  double v15;
  unint64_t v16;
  unint64_t v17;
  double v18;
  uint64_t v19;
  NSObject *v20;
  int v21;
  int v22;
  int v24;
  BOOL v25;
  _BOOL4 v26;
  double v27;
  char v28;
  int v29;
  BOOL v31;
  char v32;
  int ErrorLogLevelForModule;
  uint64_t v34;
  NSObject *v35;
  const char *v36;
  uint64_t v37;
  uint64_t v38;
  NSObject *v39;
  int v40;
  int v41;
  int v42;
  int v43;
  const char *v44;
  int v45;
  uint64_t v46;
  __int16 v47;
  const char *v48;
  __int16 v49;
  int v50;
  __int16 v51;
  _BYTE v52[10];
  _BYTE v53[6];
  _BYTE v54[6];
  __int16 v55;
  const char *v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  v10 = a1 + 17072;
  v11 = *a2;
  v12 = *a3;
  if (*(_DWORD *)(a1 + 17264) == *a2 && *(_DWORD *)(a1 + 17268) == v12)
  {
    v13 = 0;
  }
  else
  {
    *(_DWORD *)(a1 + 17264) = v11;
    *(_DWORD *)(a1 + 17268) = v12;
    v13 = 1;
  }
  if (*(_BYTE *)(a1 + 18209))
  {
    v14 = *(_QWORD *)(a1 + 18112);
    if (!v14)
      goto LABEL_14;
    if (v13)
    {
      v15 = (double)v11 / (double)v12;
      v16 = v12 * (uint64_t)v11;
      if (v14 >= v16)
        v17 = v16;
      else
        v17 = *(_QWORD *)(a1 + 18112);
      *a2 = (int)VideoUtil_ComputeScreenSizeForAspectRatio(v17, v15);
      *a3 = (int)v18;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v19 = VRTraceErrorLogLevelToCSTR();
        v20 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v21 = *a2;
          v22 = *a3;
          v45 = 136316418;
          v46 = v19;
          v47 = 2080;
          v48 = "_VideoTransmitter_RequireEncoderResolutionChange";
          v49 = 1024;
          v50 = 3014;
          v51 = 2048;
          *(_QWORD *)v52 = a1;
          *(_WORD *)&v52[8] = 1024;
          *(_DWORD *)v53 = v21;
          *(_WORD *)&v53[4] = 1024;
          *(_DWORD *)v54 = v22;
          _os_log_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VideoTransmitter=%p pendingWidth=%d pendingHeight=%d", (uint8_t *)&v45, 0x32u);
        }
      }
LABEL_14:
      if (*(_DWORD *)(v10 + 184) == *a2)
        return *(_DWORD *)(v10 + 188) != *a3;
      return 1;
    }
    return 0;
  }
  if (*(_DWORD *)(a1 + 17256) == *a3 && *(_DWORD *)(a1 + 17260) == *a2)
    return 0;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 17000));
  if (!*(_BYTE *)(v10 + 1))
  {
LABEL_29:
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 17000));
    return 0;
  }
  v24 = *(_DWORD *)(v10 + 12);
  if (*a2 == v24)
  {
    v25 = *a3 == *(_DWORD *)(v10 + 16);
    if (v24)
    {
LABEL_21:
      v26 = 0;
      goto LABEL_24;
    }
  }
  else
  {
    v25 = 0;
    if (v24)
      goto LABEL_21;
  }
  v26 = *(_DWORD *)(v10 + 16) == 0;
LABEL_24:
  v27 = *(double *)(a1 + 17248);
  v28 = v27 < a5 || v25;
  if ((v28 & 1) == 0 && !v26)
    goto LABEL_29;
  v29 = *(_DWORD *)(a1 + 20);
  v31 = v29 != 110 && (v29 & 0xFFFFFFFE) != 124;
  *a2 = *(_DWORD *)(v10 + 4);
  *a3 = *(_DWORD *)(v10 + 8);
  *(_DWORD *)(a1 + 16) = v29;
  *(_BYTE *)(v10 + 1176) = v31;
  *(_DWORD *)(v10 + 396) = *(_DWORD *)(v10 + 400);
  v32 = v27 >= a5 || v25;
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if ((v32 & 1) != 0)
  {
    if (ErrorLogLevelForModule < 7)
      goto LABEL_48;
    v34 = VRTraceErrorLogLevelToCSTR();
    v35 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      goto LABEL_48;
    v45 = 136315650;
    v46 = v34;
    v47 = 2080;
    v48 = "_VideoTransmitter_RequireEncoderResolutionChange";
    v49 = 1024;
    v50 = 3044;
    v36 = " [%s] %s:%d VideoTransmitter:RequireEncoderResolutionChange: updated to new size";
  }
  else
  {
    if (ErrorLogLevelForModule < 5)
      goto LABEL_48;
    v37 = VRTraceErrorLogLevelToCSTR();
    v35 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      goto LABEL_48;
    v45 = 136315650;
    v46 = v37;
    v47 = 2080;
    v48 = "_VideoTransmitter_RequireEncoderResolutionChange";
    v49 = 1024;
    v50 = 3042;
    v36 = " [%s] %s:%d VideoTransmitter:RequireEncoderResolutionChange: timed out";
  }
  _os_log_impl(&dword_1D8A54000, v35, OS_LOG_TYPE_DEFAULT, v36, (uint8_t *)&v45, 0x1Cu);
LABEL_48:
  if (*(_BYTE *)(v10 + 20) && strncmp((const char *)(v10 + 20), *a4, 0x96uLL))
    *a4 = (const char *)(v10 + 20);
  *(_WORD *)v10 = 0;
  *(_QWORD *)(a1 + 17248) = 0;
  *(_QWORD *)(v10 + 4) = 0;
  *(_QWORD *)(v10 + 12) = 0;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 17000));
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v38 = VRTraceErrorLogLevelToCSTR();
    v39 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v40 = *(_DWORD *)(a1 + 24);
      v41 = *(_DWORD *)(a1 + 28);
      v42 = *a2;
      v43 = *a3;
      v44 = *a4;
      v45 = 136316930;
      v46 = v38;
      v47 = 2080;
      v48 = "_VideoTransmitter_RequireEncoderResolutionChange";
      v49 = 1024;
      v50 = 3073;
      v51 = 1024;
      *(_DWORD *)v52 = v40;
      *(_WORD *)&v52[4] = 1024;
      *(_DWORD *)&v52[6] = v41;
      *(_WORD *)v53 = 1024;
      *(_DWORD *)&v53[2] = v42;
      *(_WORD *)v54 = 1024;
      *(_DWORD *)&v54[2] = v43;
      v55 = 2080;
      v56 = v44;
      _os_log_impl(&dword_1D8A54000, v39, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VideoTransmitter:RequireEncoderResolutionChange: Switching encoder from %dx%d to %dx%d, featureListString %s", (uint8_t *)&v45, 0x3Eu);
    }
  }
  return 1;
}

uint64_t _VideoTransmitter_EncodeVideo(uint64_t a1, __CVBuffer *a2, uint64_t a3, CMTime *a4, int a5, unsigned int a6, uint64_t a7, double a8)
{
  __CVBuffer *v8;
  uint64_t v16;
  double Seconds;
  int v18;
  double v19;
  float v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  uint64_t v26;
  NSObject *v27;
  NSObject *v28;
  CMTimeValue v29;
  CMTimeEpoch v30;
  float v31;
  float v32;
  uint64_t v33;
  NSObject *v34;
  uint64_t updated;
  unsigned int *v36;
  unsigned int v37;
  uint64_t v38;
  int Width;
  CFAllocatorRef *v40;
  __CVPixelBufferPool *v41;
  CVPixelBufferRef v42;
  const char *v43;
  __CVBuffer *v44;
  int v45;
  unsigned int v46;
  uint64_t v47;
  int Encoder;
  int ErrorLogLevelForModule;
  NSObject *v50;
  int v51;
  char *v52;
  uint64_t v53;
  NSObject *v54;
  const char *v55;
  uint64_t v56;
  NSObject *v57;
  unsigned int v58;
  int v59;
  const __CFNumber *Attachment;
  char *v61;
  __CVBuffer *v62;
  __int128 v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  __int128 v67;
  uint64_t v68;
  void *v69;
  unsigned int v70;
  uint64_t v71;
  NSObject *v72;
  NSObject *v73;
  int v74;
  uint64_t v75;
  NSObject *v76;
  Float64 v77;
  int v78;
  uint64_t v79;
  void *v80;
  CMTimeValue v82;
  CMTimeEpoch v83;
  CMTimeValue v84;
  uint64_t v85;
  int v86;
  CMTimeFlags v87;
  CMTimeFlags v88;
  int v89;
  NSObject *log;
  uint64_t v91;
  unsigned int v92;
  int v93;
  int v94;
  int v95;
  const char *v96;
  int Height;
  int v98;
  CVPixelBufferRef pixelBufferOut;
  int v100;
  uint64_t v101;
  CVPixelBufferRef texture;
  int v103;
  int v104;
  CMTime __str;
  int v106;
  __int16 v107;
  Float64 v108;
  __int16 v109;
  int v110;
  CMTime time[19];
  uint64_t v112;

  v112 = *MEMORY[0x1E0C80C00];
  v103 = 0;
  v104 = -1431655766;
  texture = 0;
  if (a1)
  {
    v8 = a2;
    if (a2)
    {
      if (!(_DWORD)a3 && *(_DWORD *)(a1 + 260))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() < 3)
          return 2149449745;
        VRTraceErrorLogLevelToCSTR();
        v16 = 2149449745;
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VideoTransmitter_EncodeVideo_cold_3();
        return v16;
      }
      time[0] = *a4;
      Seconds = CMTimeGetSeconds(time);
      v18 = _VideoTransmitter_CalculateVideoTimestamp(a1, a3, a8, Seconds);
      v101 = 0x3FF0000000000000;
      v19 = micro();
      time[0] = *a4;
      v20 = CMTimeGetSeconds(time);
      v21 = v20;
      _VideoTransmitter_UpdateAVHostTimeStats(a1, a8, v20);
      v22 = *(double *)(a1 + 4360);
      if (v22 == 0.0)
      {
        *(double *)(a1 + 4360) = v19;
        *(double *)(a1 + 4368) = v21;
        v22 = v19;
        v23 = v21;
      }
      else
      {
        v23 = *(double *)(a1 + 4368);
      }
      v24 = v21 - v23;
      v25 = v19 - v22;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v26 = VRTraceErrorLogLevelToCSTR();
        v27 = *MEMORY[0x1E0CF2758];
        v28 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
          {
            v29 = *(_QWORD *)(a1 + 4360);
            v30 = *(_QWORD *)(a1 + 4368);
            LODWORD(time[0].value) = 136317186;
            *(CMTimeValue *)((char *)&time[0].value + 4) = v26;
            LOWORD(time[0].flags) = 2080;
            *(_QWORD *)((char *)&time[0].flags + 2) = "_VideoTransmitter_EncodeVideo";
            HIWORD(time[0].epoch) = 1024;
            LODWORD(time[1].value) = 3180;
            WORD2(time[1].value) = 2048;
            *(CMTimeValue *)((char *)&time[1].value + 6) = v29;
            HIWORD(time[1].flags) = 2048;
            time[1].epoch = v30;
            LOWORD(time[2].value) = 2048;
            *(double *)((char *)&time[2].value + 2) = v19;
            HIWORD(time[2].timescale) = 2048;
            *(double *)&time[2].flags = v21;
            WORD2(time[2].epoch) = 2048;
            *(double *)((char *)&time[2].epoch + 6) = v25;
            HIWORD(time[3].value) = 2048;
            *(double *)&time[3].timescale = v24;
            _os_log_impl(&dword_1D8A54000, v27, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d pVT->firstSystemTime=%f pVT->firstVideoHostTime=%f currentTime=%f videoHostTimeInSeconds=%f systemTimeDifference=%f videoHostTimeDifference=%f", (uint8_t *)time, 0x58u);
          }
        }
        else if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
        {
          v82 = *(_QWORD *)(a1 + 4360);
          v83 = *(_QWORD *)(a1 + 4368);
          LODWORD(time[0].value) = 136317186;
          *(CMTimeValue *)((char *)&time[0].value + 4) = v26;
          LOWORD(time[0].flags) = 2080;
          *(_QWORD *)((char *)&time[0].flags + 2) = "_VideoTransmitter_EncodeVideo";
          HIWORD(time[0].epoch) = 1024;
          LODWORD(time[1].value) = 3180;
          WORD2(time[1].value) = 2048;
          *(CMTimeValue *)((char *)&time[1].value + 6) = v82;
          HIWORD(time[1].flags) = 2048;
          time[1].epoch = v83;
          LOWORD(time[2].value) = 2048;
          *(double *)((char *)&time[2].value + 2) = v19;
          HIWORD(time[2].timescale) = 2048;
          *(double *)&time[2].flags = v21;
          WORD2(time[2].epoch) = 2048;
          *(double *)((char *)&time[2].epoch + 6) = v25;
          HIWORD(time[3].value) = 2048;
          *(double *)&time[3].timescale = v24;
          _os_log_debug_impl(&dword_1D8A54000, v27, OS_LOG_TYPE_DEBUG, " [%s] %s:%d pVT->firstSystemTime=%f pVT->firstVideoHostTime=%f currentTime=%f videoHostTimeInSeconds=%f systemTimeDifference=%f videoHostTimeDifference=%f", (uint8_t *)time, 0x58u);
        }
      }
      v31 = v24;
      v32 = v25;
      if (!VCMU_CompareWithAccuracy(v31, v32, 0.5) && v19 - *(double *)(a1 + 18232) > 0.5)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v33 = VRTraceErrorLogLevelToCSTR();
          v34 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            v84 = *(_QWORD *)(a1 + 4368);
            v85 = *(_QWORD *)(a1 + 4360);
            LODWORD(time[0].value) = 136317698;
            *(CMTimeValue *)((char *)&time[0].value + 4) = v33;
            LOWORD(time[0].flags) = 2080;
            *(_QWORD *)((char *)&time[0].flags + 2) = "_VideoTransmitter_EncodeVideo";
            HIWORD(time[0].epoch) = 1024;
            LODWORD(time[1].value) = 3182;
            WORD2(time[1].value) = 2048;
            *(double *)((char *)&time[1].value + 6) = v24;
            HIWORD(time[1].flags) = 2048;
            *(double *)&time[1].epoch = v21;
            LOWORD(time[2].value) = 2048;
            *(CMTimeValue *)((char *)&time[2].value + 2) = v84;
            HIWORD(time[2].timescale) = 2048;
            *(double *)&time[2].flags = v25;
            WORD2(time[2].epoch) = 2048;
            *(double *)((char *)&time[2].epoch + 6) = v19;
            HIWORD(time[3].value) = 2048;
            *(_QWORD *)&time[3].timescale = v85;
            LOWORD(time[3].epoch) = 2048;
            *(CMTimeEpoch *)((char *)&time[3].epoch + 2) = vabdd_f64(v24, v25);
            WORD1(time[4].value) = 2048;
            *(CMTimeValue *)((char *)&time[4].value + 4) = 0x3FE0000000000000;
            _os_log_error_impl(&dword_1D8A54000, v34, OS_LOG_TYPE_ERROR, " [%s] %s:%d videoHostTimeDifference=%f[%f-%f] and systemTimeDifference=%f[%f-%f] drifted by %f with threshold=%f", (uint8_t *)time, 0x6Cu);
          }
        }
        *(double *)(a1 + 18232) = v19;
      }
      CVPixelBufferRetain(v8);
      updated = _VideoTransmitter_UpdateRateControlStatus(a1, (unsigned int *)&v104, (unsigned int *)&v103, &v101);
      if ((updated & 0x80000000) == 0)
      {
        v95 = v18;
        v36 = (unsigned int *)(a1 + 16492);
        v37 = v104;
        *(_DWORD *)(a1 + 4376) = v104;
        _VideoTransmitter_UpdateEncoderBitrate(a1, v37);
        if (*(_DWORD *)(a1 + 16524) != *(_DWORD *)(a1 + 16520))
        {
          v38 = *(_QWORD *)(a1 + 1632);
          if (v38 != 0xFFFFFFFFLL)
            (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 1616) + 16))(v38, *(unsigned int *)(a1 + 16524));
          reportingThermal();
          *(_DWORD *)(a1 + 16520) = *(_DWORD *)(a1 + 16524);
        }
        v100 = 0;
        pixelBufferOut = 0;
        if (*(_BYTE *)(a1 + 18209))
          goto LABEL_50;
        Width = CVPixelBufferGetWidth(v8);
        if (vabds_f32((float)Width / (float)(int)CVPixelBufferGetHeight(v8), (float)*(int *)(a1 + 24) / (float)*(int *)(a1 + 28)) < 0.05)goto LABEL_50;
        v40 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
        if (!*(_QWORD *)(a1 + 17448))
        {
          VTPixelTransferSessionCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (VTPixelTransferSessionRef *)(a1 + 17448));
          VTSessionSetProperty(*(VTSessionRef *)(a1 + 17448), (CFStringRef)*MEMORY[0x1E0CED848], (CFTypeRef)*MEMORY[0x1E0CEDB48]);
        }
        v41 = *(__CVPixelBufferPool **)(a1 + 17456);
        if (!v41)
        {
          v41 = (__CVPixelBufferPool *)VideoUtil_ReseizeFrameForBufferpool(*(_DWORD *)(a1 + 24), *(_DWORD *)(a1 + 28), *(_DWORD *)(a1 + 88), 4);
          *(_QWORD *)(a1 + 17456) = v41;
        }
        CVPixelBufferPoolCreatePixelBuffer(*v40, v41, &pixelBufferOut);
        v42 = pixelBufferOut;
        if (pixelBufferOut)
        {
          VTPixelTransferSessionTransferImage(*(VTPixelTransferSessionRef *)(a1 + 17448), v8, pixelBufferOut);
          if (!*(_BYTE *)(a1 + 18289))
            goto LABEL_49;
        }
        else if (!*(_BYTE *)(a1 + 18289))
        {
          goto LABEL_50;
        }
        VCVideoHardwareDumpCollector_RecordResizeForEncoder(*(_QWORD *)(a1 + 18296), v42 != 0, (uint64_t)pixelBufferOut, *(_DWORD *)(a1 + 24), *(_DWORD *)(a1 + 28));
        if (v42)
        {
LABEL_49:
          CVPixelBufferRelease(v8);
          v8 = pixelBufferOut;
        }
LABEL_50:
        v98 = CVPixelBufferGetWidth(v8);
        Height = CVPixelBufferGetHeight(v8);
        v96 = (const char *)(a1 + 104);
        if (_VideoTransmitter_RequireEncoderResolutionChange(a1, &v98, &Height, &v96, v19))
        {
          v93 = v98;
          v94 = Height;
          v43 = v96;
          v44 = *(__CVBuffer **)(a1 + 432);
          if (v44)
          {
            CVPixelBufferRelease(v44);
            *(_QWORD *)(a1 + 432) = 0;
          }
          if (*(_QWORD *)(a1 + 1632) != 0xFFFFFFFFLL)
          {
            (*(void (**)(void))(*(_QWORD *)(a1 + 1616) + 8))();
            *(_QWORD *)(a1 + 1632) = 0xFFFFFFFFLL;
          }
          if (*(_DWORD *)(a1 + 16) == 100)
            *(_DWORD *)(a1 + 16620) = 0;
          v45 = *(_DWORD *)(a1 + 496);
          if (v45 == 3 || v45 == 5 || (*(_DWORD *)(a1 + 504) - 1) <= 1)
            *(_DWORD *)(a1 + 16620) = 1;
          ++*(_DWORD *)(a1 + 18084);
          if (*(_BYTE *)(a1 + 16984))
          {
            v46 = 0;
          }
          else if (*(_DWORD *)(a1 + 96))
          {
            v46 = 1;
          }
          else
          {
            v46 = *(_DWORD *)(a1 + 100) != 0;
          }
          v47 = 218;
          if (!*(_DWORD *)(a1 + 17368))
            v47 = 32;
          v92 = v36[v47];
          Encoder = _VideoTransmitter_CreateEncoder(a1, v93, v94, (uint64_t)v43, v92 != 0, v46);
          ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
          if (Encoder < 0)
          {
            if (ErrorLogLevelForModule >= 3)
            {
              v56 = VRTraceErrorLogLevelToCSTR();
              v57 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              {
                v86 = *(_DWORD *)(a1 + 24);
                v87 = *(_DWORD *)(a1 + 28);
                LODWORD(time[0].value) = 136316674;
                *(CMTimeValue *)((char *)&time[0].value + 4) = v56;
                LOWORD(time[0].flags) = 2080;
                *(_QWORD *)((char *)&time[0].flags + 2) = "_VideoTransmitter_CreateEncoderForResolutionChange";
                HIWORD(time[0].epoch) = 1024;
                LODWORD(time[1].value) = 3120;
                WORD2(time[1].value) = 1024;
                *(_DWORD *)((char *)&time[1].value + 6) = v86;
                HIWORD(time[1].timescale) = 1024;
                time[1].flags = v87;
                LOWORD(time[1].epoch) = 1024;
                *(_DWORD *)((char *)&time[1].epoch + 2) = v93;
                HIWORD(time[1].epoch) = 1024;
                LODWORD(time[2].value) = v94;
                _os_log_error_impl(&dword_1D8A54000, v57, OS_LOG_TYPE_ERROR, " [%s] %s:%d Switching encoder FAILED from %dx%d to %dx%d", (uint8_t *)time, 0x34u);
              }
            }
          }
          else
          {
            if (ErrorLogLevelForModule >= 7)
            {
              v91 = VRTraceErrorLogLevelToCSTR();
              v50 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                log = v50;
                v51 = *(_DWORD *)(a1 + 24);
                v88 = *(_DWORD *)(a1 + 28);
                v89 = *(_DWORD *)(a1 + 44);
                v52 = FourccToCStr(*(_DWORD *)(a1 + 17468));
                LODWORD(time[0].value) = 136317442;
                *(CMTimeValue *)((char *)&time[0].value + 4) = v91;
                LOWORD(time[0].flags) = 2080;
                *(_QWORD *)((char *)&time[0].flags + 2) = "_VideoTransmitter_CreateEncoderForResolutionChange";
                HIWORD(time[0].epoch) = 1024;
                LODWORD(time[1].value) = 3110;
                WORD2(time[1].value) = 1024;
                *(_DWORD *)((char *)&time[1].value + 6) = v51;
                HIWORD(time[1].timescale) = 1024;
                time[1].flags = v88;
                LOWORD(time[1].epoch) = 1024;
                *(_DWORD *)((char *)&time[1].epoch + 2) = v93;
                HIWORD(time[1].epoch) = 1024;
                LODWORD(time[2].value) = v94;
                WORD2(time[2].value) = 1024;
                *(_DWORD *)((char *)&time[2].value + 6) = v89;
                HIWORD(time[2].timescale) = 2080;
                *(_QWORD *)&time[2].flags = v52;
                WORD2(time[2].epoch) = 2080;
                *(CMTimeEpoch *)((char *)&time[2].epoch + 6) = (CMTimeEpoch)v43;
                _os_log_impl(&dword_1D8A54000, log, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Switching encoder from %dx%d to %dx%d %dfps (%s: %s)", (uint8_t *)time, 0x4Eu);
              }
            }
            *(_DWORD *)(a1 + 24) = v93;
            *(_DWORD *)(a1 + 28) = v94;
            *(_DWORD *)(a1 + 17256) = v93;
            *(_DWORD *)(a1 + 17260) = v94;
            if (strncmp((const char *)(a1 + 104), v43, 0x96uLL))
              __strlcpy_chk();
            __str.timescale = 0;
            __str.value = 0;
            snprintf((char *)&__str, 0xCuLL, "%d", *(_DWORD *)(a1 + 16));
            reportingLog();
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v53 = VRTraceErrorLogLevelToCSTR();
              v54 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                v55 = "Hardware";
                LODWORD(time[0].value) = 136315906;
                *(CMTimeValue *)((char *)&time[0].value + 4) = v53;
                LOWORD(time[0].flags) = 2080;
                *(_QWORD *)((char *)&time[0].flags + 2) = "_VideoTransmitter_HandleEncodeCreateSuccess";
                if (!v92)
                  v55 = "Software";
                HIWORD(time[0].epoch) = 1024;
                LODWORD(time[1].value) = 640;
                WORD2(time[1].value) = 2080;
                *(CMTimeValue *)((char *)&time[1].value + 6) = (CMTimeValue)v55;
                _os_log_impl(&dword_1D8A54000, v54, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Using %s Video Encoder", (uint8_t *)time, 0x26u);
              }
            }
          }
        }
        _VideoTransmitter_PrepareEncodingBuffer(a1, v8, &texture, (a6 & 2) == 0, &v100, a6);
        CVPixelBufferRelease(v8);
        if (v100)
          v58 = a6 | 3;
        else
          v58 = a6;
        v59 = *(_DWORD *)(a1 + 256);
        LOWORD(pixelBufferOut) = 0;
        Attachment = (const __CFNumber *)CVBufferGetAttachment(v8, CFSTR("CaptureMediaPriorirty"), 0);
        if (Attachment)
          CFNumberGetValue(Attachment, kCFNumberSInt16Type, &pixelBufferOut);
        v61 = (char *)VCMemoryPool_Alloc(*(OSQueueHead **)(a1 + 17728));
        v62 = texture;
        __str = *a4;
        v63 = *(_OWORD *)(a7 + 16);
        *(_OWORD *)&time[0].value = *(_OWORD *)a7;
        *(_OWORD *)&time[0].epoch = v63;
        *(_QWORD *)&time[1].timescale = *(_QWORD *)(a7 + 32);
        v64 = _VideoTransmitter_PrepareAndSetupEncodingArgs(a1, (uint64_t)v61, v59, texture, v58, v95, a5, (__int128 *)&__str.value, v19, v104, v103, (__int128 *)&time[0].value, (__int16)pixelBufferOut);
        if ((v64 & 0x80000000) != 0)
        {
          v16 = v64;
          CVPixelBufferRelease(v62);
          VCMemoryPool_Free(*(OSQueueHead **)(a1 + 17728), v61);
        }
        else
        {
          if (v19 - *(double *)(a1 + 16608) > 1.0)
          {
            if (*(_DWORD *)(a1 + 1600))
            {
              v65 = 0;
              v66 = a1 + 520;
              do
              {
                time[0].value = 0;
                _VideoTransmitter_GetFramerateForStream(a1, v66, (double *)&time[0].value, 1.0);
                v66 += 120;
                RTPRecordFrameRate(*(double *)&time[0].value);
                ++v65;
              }
              while (v65 < *(unsigned int *)(a1 + 1600));
            }
            *(double *)(a1 + 16608) = v19;
          }
          *((_DWORD *)v61 + 42) = *(_DWORD *)(a1 + 18056);
          *((int32x2_t *)v61 + 20) = vrev64_s32(*(int32x2_t *)(a1 + 18060));
          v67 = *(_OWORD *)(a1 + 16680);
          *(_OWORD *)(v61 + 264) = *(_OWORD *)(a1 + 16696);
          *(_OWORD *)(v61 + 248) = v67;
          pthread_mutex_lock((pthread_mutex_t *)(a1 + 2992));
          v68 = *(unsigned int *)(a1 + 2588);
          *((_DWORD *)v61 + 30) = v68;
          if ((int)v68 >= 1)
          {
            v69 = malloc_type_malloc(4 * v68, 0x100004052888210uLL);
            *((_QWORD *)v61 + 14) = v69;
            if (v69)
              memcpy(v69, (const void *)(a1 + 2592), 4 * *((int *)v61 + 30));
            *(_DWORD *)(a1 + 2588) = 0;
          }
          pthread_mutex_unlock((pthread_mutex_t *)(a1 + 2992));
          if (*(_DWORD *)(a1 + 17372) == 20)
          {
            v70 = atomic_load(v36);
            *((_DWORD *)v61 + 71) = v70;
            *((_DWORD *)v61 + 72) = 6000;
          }
          ++*(_DWORD *)(a1 + 17788);
          time[0] = *(CMTime *)(v61 + 404);
          CMTimeGetSeconds(time);
          kdebug_trace();
          memcpy(time, v61, sizeof(time));
          if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            v71 = VRTraceErrorLogLevelToCSTR();
            v72 = *MEMORY[0x1E0CF2758];
            v73 = *MEMORY[0x1E0CF2758];
            if (*MEMORY[0x1E0CF2748])
            {
              if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
              {
                v74 = *((_DWORD *)v61 + 45);
                LODWORD(__str.value) = 136315906;
                *(CMTimeValue *)((char *)&__str.value + 4) = v71;
                LOWORD(__str.flags) = 2080;
                *(_QWORD *)((char *)&__str.flags + 2) = "_VideoTransmitter_EncodeVideo";
                HIWORD(__str.epoch) = 1024;
                v106 = 3266;
                v107 = 1024;
                LODWORD(v108) = v74;
                _os_log_impl(&dword_1D8A54000, v72, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Encode frame with RTP timestamp %d", (uint8_t *)&__str, 0x22u);
              }
            }
            else if (os_log_type_enabled(v73, OS_LOG_TYPE_DEBUG))
            {
              _VideoTransmitter_EncodeVideo_cold_5();
            }
          }
          if (*(_BYTE *)(a1 + 17285))
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v75 = VRTraceErrorLogLevelToCSTR();
              v76 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                __str = *(CMTime *)(v61 + 40);
                v77 = CMTimeGetSeconds(&__str);
                v78 = *((_DWORD *)v61 + 45);
                LODWORD(__str.value) = 136316162;
                *(CMTimeValue *)((char *)&__str.value + 4) = v75;
                LOWORD(__str.flags) = 2080;
                *(_QWORD *)((char *)&__str.flags + 2) = "_VideoTransmitter_EncodeVideo";
                HIWORD(__str.epoch) = 1024;
                v106 = 3268;
                v107 = 2048;
                v108 = v77;
                v109 = 1024;
                v110 = v78;
                _os_log_impl(&dword_1D8A54000, v76, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Timestamp Alignment: Encode Host Time = %f, RTP timestamp = %08X", (uint8_t *)&__str, 0x2Cu);
              }
            }
          }
          v79 = *(_QWORD *)(a1 + 1632);
          if (v79 == 0xFFFFFFFFLL)
            v16 = 2148007957;
          else
            v16 = (*(uint64_t (**)(uint64_t, char *))(*(_QWORD *)(a1 + 1616) + 32))(v79, v61);
          if (*(_BYTE *)(a1 + 18289))
            VCVideoHardwareDumpCollector_RecordEncodedFrame(*(_QWORD *)(a1 + 18296), (uint64_t)time);
          CVPixelBufferRelease(texture);
          if ((v16 & 0x80000000) != 0)
          {
            if ((_DWORD)v16 == -2146959339 || (_DWORD)v16 == -2146959358)
            {
              v80 = (void *)*((_QWORD *)v61 + 14);
              if (v80)
                free(v80);
              VCMemoryPool_Free(*(OSQueueHead **)(a1 + 17728), v61);
            }
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                _VideoTransmitter_EncodeVideo_cold_4();
            }
          }
        }
        return v16;
      }
      v16 = updated;
      CVPixelBufferRelease(v8);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VideoTransmitter_EncodeVideo_cold_6();
      }
    }
    else
    {
      v16 = 2149449729;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VideoTransmitter_EncodeVideo_cold_2();
      }
    }
  }
  else
  {
    v16 = 2149449730;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        _VideoTransmitter_EncodeVideo_cold_1();
        return 2149449730;
      }
    }
  }
  return v16;
}

double _VideoTransmitter_UpdateAVHostTimeStats(uint64_t a1, double a2, double a3)
{
  double v3;
  double v4;
  double result;

  v3 = (a2 - a3) * 1000.0;
  v4 = fabs(v3);
  if (v4 > fabs(*(double *)(a1 + 408)))
    *(double *)(a1 + 408) = v3;
  if (v4 < fabs(*(double *)(a1 + 416)))
    *(double *)(a1 + 416) = v3;
  result = v3 + *(double *)(a1 + 400);
  *(double *)(a1 + 392) = v4 + *(double *)(a1 + 392);
  *(double *)(a1 + 400) = result;
  ++*(_DWORD *)(a1 + 424);
  return result;
}

uint64_t _VideoTransmitter_UpdateRateControlStatus(uint64_t a1, unsigned int *a2, unsigned int *a3, _QWORD *a4)
{
  unsigned __int8 *v7;
  int v8;
  BOOL v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  unsigned int v13;
  char v14;
  int v15;
  uint64_t v16;
  NSObject *v17;
  unsigned int v18;
  int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  NSObject *v23;
  uint64_t v24;
  NSObject *v25;
  uint64_t v26;
  NSObject *v27;
  unsigned int v28;
  pthread_mutex_t *v29;
  unint64_t v30;
  unsigned int v31;
  uint64_t v32;
  NSObject *v33;
  double v35;
  unsigned int v36;
  int v37;
  int v38;
  uint8_t buf[4];
  unint64_t v40;
  _BYTE v41[10];
  __int16 v42;
  int v43;
  __int16 v44;
  unsigned int v45;
  __int16 v46;
  int v47;
  __int16 v48;
  int v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  v38 = 0;
  if (!*(_DWORD *)(a1 + 4420))
  {
    v20 = 0;
    *a2 = *(_DWORD *)(a1 + 4380);
    *a4 = 0;
    *a3 = 0;
    return v20;
  }
  v7 = (unsigned __int8 *)(a1 + 16824);
  v36 = -1431655766;
  v37 = -1431655766;
  v35 = NAN;
  v8 = *(_DWORD *)(a1 + 496);
  v9 = v8 == 3 || v8 == 5;
  if (v9 || *(_QWORD *)(a1 + 1664))
  {
    if (a2)
      *a2 = *(_DWORD *)(a1 + 4380);
    if (a3)
      *a3 = *(_DWORD *)(a1 + 4384);
    v10 = 0;
    v38 = *(_DWORD *)(a1 + 4388);
    *(_DWORD *)(a1 + 4400) = 0;
    goto LABEL_12;
  }
  *(_DWORD *)buf = -1431655766;
  v10 = RTPGetAFRCTxInfo(*(_QWORD *)(a1 + 520), a2, 0, 0, 0, a4, a3, (_DWORD *)(a1 + 4400), (_DWORD *)(a1 + 17776), &v38, (BOOL *)(a1 + 16824), buf);
  if ((v38 & 1) != 0 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VideoTransmitter_UpdateRateControlStatus_cold_1();
  }
  VCRateControlSetAFRCBandwidth(*(void **)(a1 + 1656), (1000 * *(_DWORD *)buf), *a2);
  if ((v10 & 0x80000000) == 0)
  {
LABEL_12:
    if (!*(_DWORD *)(a1 + 96))
    {
LABEL_28:
      v19 = 1;
      goto LABEL_29;
    }
    if (v38 != *(_DWORD *)(a1 + 16828) && (int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v11 = VRTraceErrorLogLevelToCSTR();
      v12 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v13 = *(_DWORD *)(a1 + 16828);
        *(_DWORD *)buf = 136316162;
        v40 = v11;
        *(_WORD *)v41 = 2080;
        *(_QWORD *)&v41[2] = "_VideoTransmitter_UpdateRateControlStatus";
        v42 = 1024;
        v43 = 2523;
        v44 = 1024;
        v45 = v13;
        v46 = 1024;
        v47 = v38;
        _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d New baseband action:[%02X->%02X].", buf, 0x28u);
      }
    }
    v14 = v38;
    if ((v38 & 8) != 0)
    {
      RTPFlushBaseband(*(_QWORD *)(a1 + 1608), *v7, 0, 0, 0, 0, 0);
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 16832));
      ++*(_DWORD *)(a1 + 16896);
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16832));
      v14 = v38;
      if ((v38 & 2) == 0)
      {
LABEL_19:
        if ((v14 & 0x10) == 0)
        {
LABEL_21:
          v15 = *(_DWORD *)(a1 + 16828);
          if ((v14 & 1) != 0)
          {
            if ((v15 & 1) == 0)
            {
              if (a3)
                RTPUpdateAudioOnlyRateChange(*(_QWORD *)(a1 + 520), *a3);
              if (a2)
              {
                if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
                {
                  v26 = VRTraceErrorLogLevelToCSTR();
                  v27 = *MEMORY[0x1E0CF2758];
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                  {
                    v28 = *a2 / 0x3E8;
                    *(_DWORD *)buf = 136315906;
                    v40 = v26;
                    *(_WORD *)v41 = 2080;
                    *(_QWORD *)&v41[2] = "_VideoTransmitter_UpdateRateControlStatus";
                    v42 = 1024;
                    v43 = 2565;
                    v44 = 1024;
                    v45 = v28;
                    _os_log_impl(&dword_1D8A54000, v27, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d === Suspend outgoing video (rate:%u).", buf, 0x22u);
                  }
                }
              }
            }
            v20 = 2149449745;
            *(_DWORD *)(a1 + 4388) &= 0xFFFFFFE5;
            *(_DWORD *)(a1 + 16828) = v38;
            return v20;
          }
          if (a2)
          {
            if ((v15 & 1) != 0 && (int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v16 = VRTraceErrorLogLevelToCSTR();
              v17 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                v18 = *a2 / 0x3E8;
                *(_DWORD *)buf = 136315906;
                v40 = v16;
                *(_WORD *)v41 = 2080;
                *(_QWORD *)&v41[2] = "_VideoTransmitter_UpdateRateControlStatus";
                v42 = 1024;
                v43 = 2577;
                v44 = 1024;
                v45 = v18;
                _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d === Resume outgoing video (rate:%u).", buf, 0x22u);
              }
            }
          }
          *(_DWORD *)(a1 + 4388) &= 0xFFFFFFE5;
          *(_DWORD *)(a1 + 16828) = v38;
          goto LABEL_28;
        }
LABEL_20:
        *(_QWORD *)v41 = 0xAAAAAAAAAAAAAAAALL;
        v40 = 0xAAAAAAAAAAAAAAAALL;
        *(_DWORD *)buf = *(_DWORD *)(a1 + 1748);
        _VideoTransmitter_GenerateKeyFrameNow(a1, (unsigned __int16 *)buf, 2, 0, 0);
        v14 = v38;
        goto LABEL_21;
      }
    }
    else if ((v38 & 2) == 0)
    {
      goto LABEL_19;
    }
    RTPFlushBaseband(*(_QWORD *)(a1 + 520), *v7, *(_DWORD *)(a1 + 17272), 1u, 0, 0, 0);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 16832));
    ++*(_DWORD *)(a1 + 16900);
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16832));
    v14 = v38;
    if ((v38 & 0x10) == 0)
      goto LABEL_21;
    goto LABEL_20;
  }
  v19 = 0;
LABEL_29:
  v20 = 2149449745;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16912));
  v21 = *(_DWORD *)(a1 + 16904);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16912));
  if (!v21)
  {
    if (v19)
    {
      if (*(_BYTE *)(a1 + 18281) && !*(_BYTE *)(a1 + 18280) && *(_BYTE *)(a1 + 18288))
      {
        if (a3)
          RTPUpdateAudioOnlyRateChange(*(_QWORD *)(a1 + 520), *a3);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v22 = VRTraceErrorLogLevelToCSTR();
          v23 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315650;
            v40 = v22;
            *(_WORD *)v41 = 2080;
            *(_QWORD *)&v41[2] = "_VideoTransmitter_UpdateRateControlStatus";
            v42 = 1024;
            v43 = 2603;
            _os_log_impl(&dword_1D8A54000, v23, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Outgoing video stopped using Smart Brake", buf, 0x1Cu);
          }
        }
        *(_BYTE *)(a1 + 18280) = 1;
      }
      if (*(_BYTE *)(a1 + 18282))
      {
        if (*(_BYTE *)(a1 + 18280))
        {
          if (!*(_BYTE *)(a1 + 18288))
            return v20;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v24 = VRTraceErrorLogLevelToCSTR();
            v25 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315650;
              v40 = v24;
              *(_WORD *)v41 = 2080;
              *(_QWORD *)&v41[2] = "_VideoTransmitter_UpdateRateControlStatus";
              v42 = 1024;
              v43 = 2608;
              _os_log_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Outgoing video resumed using Smart Brake", buf, 0x1Cu);
            }
          }
          *(_BYTE *)(a1 + 18280) = 0;
        }
      }
      else if (*(_BYTE *)(a1 + 18280))
      {
        return v20;
      }
    }
    v29 = (pthread_mutex_t *)(a1 + 1680);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 1680));
    if (*(_DWORD *)(a1 + 1772) != *(_DWORD *)(a1 + 1768))
    {
      RTPGetTimeRefreshFrame(*(_QWORD *)(a1 + 520), &v35, &v36);
      if (v36 >= *(_DWORD *)(a1 + 1768))
      {
        v30 = MicroToNTP(v35);
        v31 = NTPToMiddle32(v30);
        RTPGetLastEchoedMyTxTS(*(_QWORD *)(a1 + 520), &v37);
        if (v37 != -1 && (unsigned __int16)(v37 - (v31 >> 6)) <= 0x7FFEu)
        {
          *(_DWORD *)(a1 + 1776) = 1;
          *(_DWORD *)(a1 + 1772) = *(_DWORD *)(a1 + 1768);
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v32 = VRTraceErrorLogLevelToCSTR();
            v33 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136316418;
              v40 = v32;
              *(_WORD *)v41 = 2080;
              *(_QWORD *)&v41[2] = "_VideoTransmitter_UpdateRateControlStatus";
              v42 = 1024;
              v43 = 2631;
              v44 = 1024;
              v45 = v36;
              v46 = 1024;
              v47 = v37;
              v48 = 1024;
              v49 = (unsigned __int16)(v31 >> 6);
              _os_log_impl(&dword_1D8A54000, v33, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Refresh frame[%u] stabilized(TxTS %u >= %u).\n", buf, 0x2Eu);
            }
          }
        }
      }
    }
    pthread_mutex_unlock(v29);
    return v10;
  }
  return v20;
}

uint64_t _VideoTransmitter_PrepareAndSetupEncodingArgs(uint64_t a1, uint64_t a2, int a3, __CVBuffer *a4, unsigned int a5, int a6, int a7, __int128 *a8, double a9, int a10, int a11, __int128 *a12, __int16 a13)
{
  pthread_mutex_t *v21;
  int v22;
  _QWORD *v23;
  int v24;
  __CVBuffer *v25;
  int v26;
  int v27;
  unsigned int v28;
  int ErrorLogLevelForModule;
  NSObject *v30;
  _BOOL4 v31;
  int v32;
  __int128 v33;
  unsigned int *v34;
  unsigned int v35;
  unsigned int *v36;
  unsigned int v37;
  unsigned int *v38;
  unsigned int v39;
  uint64_t result;
  int v41;
  _BOOL4 v43;
  __int128 v44;
  __int128 v45;
  _BOOL4 v46;
  uint64_t v47;
  NSObject *log;
  int v49;
  int v50;
  __CVBuffer *v51;
  uint8_t buf[4];
  uint64_t v54;
  __int16 v55;
  const char *v56;
  __int16 v57;
  int v58;
  __int16 v59;
  int v60;
  _QWORD v61[3];

  v61[2] = *MEMORY[0x1E0C80C00];
  v21 = (pthread_mutex_t *)(a1 + 1680);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1680));
  v22 = *(_DWORD *)(a1 + 1744);
  pthread_mutex_unlock(v21);
  if (a3 && *(_QWORD *)(a1 + 432) && v22 >= 3)
  {
    v49 = a6;
    v50 = a7;
    v23 = v61;
    v24 = v22 - 2;
    v51 = *(__CVBuffer **)(a1 + 432);
    goto LABEL_13;
  }
  if ((((*(_DWORD *)(a1 + 16) - 110) < 0x10) & (0xC001u >> (*(_BYTE *)(a1 + 16) - 110))) != 0)
  {
    v49 = a6;
    v50 = a7;
    v51 = a4;
LABEL_12:
    v24 = 0;
    v23 = 0;
    goto LABEL_13;
  }
  if (!a4)
    return 2149449745;
  v51 = a4;
  v49 = a6;
  v50 = a7;
  if (*(_DWORD *)(a1 + 496) != 1)
    goto LABEL_12;
  v25 = *(__CVBuffer **)(a1 + 432);
  if (v25)
  {
    CVPixelBufferRelease(v25);
    *(_QWORD *)(a1 + 432) = 0;
  }
  v24 = 0;
  v23 = 0;
  *(_QWORD *)(a1 + 432) = CVPixelBufferRetain(a4);
LABEL_13:
  v26 = a11;
  if (*(_DWORD *)(a1 + 496) == 2)
  {
    if (a9 - *(double *)(a1 + 17768) <= 5.0)
      goto LABEL_25;
    v27 = a11;
    v28 = *(_DWORD *)(a1 + 32) / 400;
    if (v28 <= 0x101)
      v28 = 257;
    *(_DWORD *)(a1 + 17776) = v28;
    ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    v26 = a11;
    if (ErrorLogLevelForModule < 8)
      goto LABEL_25;
    v47 = VRTraceErrorLogLevelToCSTR();
    v30 = *MEMORY[0x1E0CF2758];
    log = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      v31 = os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT);
      v26 = a11;
      if (!v31)
        goto LABEL_25;
      v32 = *(_DWORD *)(a1 + 17776);
      *(_DWORD *)buf = 136315906;
      v54 = v47;
      v55 = 2080;
      v56 = "_VideoTransmitter_PrepareAndSetupEncodingArgs";
      v57 = 1024;
      v58 = 2739;
      v59 = 1024;
      v60 = v32;
      _os_log_impl(&dword_1D8A54000, log, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d generate fake frame now, size %d", buf, 0x22u);
      goto LABEL_23;
    }
    v46 = os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG);
    v26 = a11;
    if (v46)
    {
      _VideoTransmitter_PrepareAndSetupEncodingArgs_cold_1();
      goto LABEL_23;
    }
  }
  else
  {
    if (*(_BYTE *)(a1 + 16826))
    {
      v27 = a11;
      VCRateControlGetLargeFrameSize(*(void **)(a1 + 1656), (_DWORD *)(a1 + 17776));
LABEL_23:
      v26 = v27;
      goto LABEL_25;
    }
    *(_DWORD *)(a1 + 17776) = 0;
  }
LABEL_25:
  *(_DWORD *)(a2 + 180) = v49;
  v33 = *a8;
  *(_QWORD *)(a2 + 56) = *((_QWORD *)a8 + 2);
  *(_OWORD *)(a2 + 40) = v33;
  *(_DWORD *)(a2 + 192) = v50;
  *(_DWORD *)(a2 + 172) = *(_DWORD *)(a1 + 17776);
  *(_DWORD *)(a2 + 240) = v26;
  *(_DWORD *)(a2 + 224) = a10;
  *(_BYTE *)(a2 + 244) = a5;
  *(_QWORD *)a2 = *(_QWORD *)(a1 + 24);
  *(_DWORD *)(a2 + 8) = v24;
  *(_QWORD *)(a2 + 16) = v23;
  *(_DWORD *)(a2 + 24) = v24;
  *(_QWORD *)(a2 + 32) = v23;
  *(_QWORD *)(a2 + 88) = v51;
  *(_QWORD *)(a2 + 100) = 0xFFFFFFFF00000000;
  *(_DWORD *)(a2 + 120) = 0;
  *(_QWORD *)(a2 + 112) = 0;
  v34 = (unsigned int *)(a1 + 4436);
  do
    v35 = __ldxr(v34);
  while (__stxr(0, v34));
  *(_DWORD *)(a2 + 124) = v35;
  v36 = (unsigned int *)(a1 + 4416);
  do
    v37 = __ldxr(v36);
  while (__stxr(0, v36));
  *(_DWORD *)(a2 + 128) = v37;
  v38 = (unsigned int *)(a1 + 1676);
  do
    v39 = __ldxr(v38);
  while (__stxr(0, v38));
  *(_DWORD *)(a2 + 280) = v39;
  *(_OWORD *)(a2 + 136) = *(_OWORD *)(a1 + 16528);
  *(_QWORD *)(a2 + 152) = *(_QWORD *)(a1 + 16544);
  memcpy((void *)(a2 + 330), (const void *)(a1 + 440), 2 * *(unsigned __int8 *)(a1 + 464));
  *(_BYTE *)(a2 + 354) = *(_BYTE *)(a1 + 464);
  memcpy((void *)(a2 + 356), (const void *)(a1 + 466), 2 * *(unsigned __int8 *)(a1 + 490));
  result = 0;
  *(_DWORD *)(a2 + 380) = *(_DWORD *)(a1 + 490);
  *(_DWORD *)(a2 + 184) = (*(_DWORD *)(a1 + 17764) >> 2) & (*(_DWORD *)(a1 + 17764) << 30 >> 31);
  v41 = *(_DWORD *)(a1 + 16976);
  v43 = v41 == 2 || v41 == 4;
  *(_DWORD *)(a2 + 188) = v43;
  *(_DWORD *)(a2 + 232) = (a5 >> 3) & 1;
  *(_DWORD *)(a2 + 236) = *(unsigned __int8 *)(a1 + 16992);
  *(_QWORD *)(a2 + 196) = *(_QWORD *)(a1 + 17376);
  *(int32x4_t *)(a2 + 204) = vuzp1q_s32((int32x4_t)vcvtq_s64_f64(*(float64x2_t *)(a1 + 17400)), (int32x4_t)vcvtq_s64_f64(*(float64x2_t *)(a1 + 17432)));
  *(_BYTE *)(a2 + 440) = *(_BYTE *)(a1 + 18092);
  *(_BYTE *)(a2 + 448) = *(_BYTE *)(a1 + 18104);
  v44 = *a12;
  v45 = a12[1];
  *(_QWORD *)(a2 + 432) = *((_QWORD *)a12 + 4);
  *(_OWORD *)(a2 + 400) = v44;
  *(_OWORD *)(a2 + 416) = v45;
  *(_WORD *)(a2 + 452) = a13;
  *(_DWORD *)(a1 + 320) += *(_DWORD *)(a2 + 124);
  *(_DWORD *)(a1 + 324) += *(_DWORD *)(a1 + 4416);
  return result;
}

void _VideoTransmitter_CheckStatusAndHandleError(uint64_t a1, int a2)
{
  if ((a2 + 12915) <= 0xF && ((1 << (a2 + 115)) & 0xBD89) != 0 || a2 == -12211 || a2 == -12218)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VideoTransmitter_CheckStatusAndHandleError_cold_1();
    }
    _VideoTransmitter_EnqueueEncoderError(a1, -2145517538);
  }
}

void _VideoTransmitter_EnqueueEncoderError(uint64_t a1, int a2)
{
  _DWORD *v4;
  OSStatus v5;
  OSStatus v6;
  uint64_t v7;
  NSObject *v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  uint64_t v16;
  __int16 v17;
  OSStatus v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v4 = VCMemoryPool_Alloc(*(OSQueueHead **)(a1 + 17736));
  *v4 = a2;
  v5 = CMSimpleQueueEnqueue(*(CMSimpleQueueRef *)(a1 + 17752), v4);
  if (v5)
  {
    v6 = v5;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v7 = VRTraceErrorLogLevelToCSTR();
      v8 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v9 = 136316162;
        v10 = v7;
        v11 = 2080;
        v12 = "_VideoTransmitter_EnqueueEncoderError";
        v13 = 1024;
        v14 = 3398;
        v15 = 2048;
        v16 = a1;
        v17 = 1024;
        v18 = v6;
        _os_log_error_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_ERROR, " [%s] %s:%d %p CMSimpleQueueEnqueue Full error=%d", (uint8_t *)&v9, 0x2Cu);
      }
    }
    VCMemoryPool_Free(*(OSQueueHead **)(a1 + 17736), v4);
  }
}

void _VideoTransmitter_TransmitFrame(uint64_t a1, uint64_t a2, opaqueCMSampleBuffer *a3)
{
  if ((_VideoTransmitter_TransmitEncodedVideoFrame(a1, a2, a3) & 0x80000000) != 0
    && (int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VideoTransmitter_TransmitFrame_cold_1();
  }
}

uint64_t _VideoTransmitter_TransmitEncodedVideoFrame(uint64_t a1, uint64_t a2, CMSampleBufferRef sbuf)
{
  uint64_t v6;
  __int16 v7;
  unsigned int v8;
  BOOL v9;
  int v10;
  OpaqueCMBlockBuffer *DataBuffer;
  int SampleSize;
  int v14;
  const __CFArray *SampleAttachmentsArray;
  const __CFDictionary *ValueAtIndex;
  int ValueIfPresent;
  const void *v18;
  void *v19;
  const void *v20;
  char v23;
  unsigned int v24;
  uint64_t v29;
  NSObject *v30;
  _BOOL4 v31;
  uint64_t v32;
  NSObject *v33;
  const __CFNumber *v34;
  int v35;
  const __CFNumber *v36;
  _QWORD *v37;
  const __CFNumber *v38;
  _QWORD *v39;
  const __CFNumber *v40;
  _QWORD *v41;
  const __CFNumber *v42;
  int v43;
  const __CFNumber *v44;
  _DWORD *v45;
  const __CFNumber *v46;
  uint64_t v47;
  NSObject *v48;
  const __CFNumber *v49;
  int v50;
  const __CFNumber *v51;
  uint64_t v52;
  NSObject *v53;
  uint64_t v54;
  NSObject *v55;
  NSObject *v56;
  int v57;
  int v58;
  int v59;
  uint64_t v60;
  OpaqueCMBlockBuffer *v61;
  unsigned int v62;
  uint64_t v63;
  uint64_t Stream;
  int v65;
  uint64_t v66;
  NSObject *v67;
  int v68;
  int v69;
  int v70;
  int v71;
  unsigned int v72;
  uint64_t v73;
  NSObject *v74;
  int v75;
  uint64_t v76;
  int v77;
  unsigned __int8 v78;
  uint64_t v79;
  uint64_t v80;
  NSObject *v81;
  NSObject *v82;
  int v83;
  double Seconds;
  int v85;
  int v86;
  unsigned int v87;
  double v88;
  uint64_t v89;
  unsigned int v90;
  BOOL v91;
  int v92;
  char ProbePkt;
  BOOL v94;
  int v95;
  _BOOL4 v97;
  __int16 v98;
  uint64_t *v99;
  int v100;
  int v101;
  int v102;
  int v103;
  uint64_t v104;
  int v105;
  NSObject *v106;
  uint64_t v107;
  unsigned int v108;
  uint64_t v109;
  unsigned int v110;
  int v111;
  int v112;
  uint64_t v113;
  NSObject *v114;
  NSObject *v115;
  int v116;
  int v117;
  int v118;
  int v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  NSObject *v123;
  int v124;
  int v125;
  int v126;
  const __CFAllocator *v127;
  __CFDictionary *Mutable;
  CFNumberRef v129;
  int v130;
  double v131;
  double v132;
  double v133;
  int v135;
  uint64_t v136;
  NSObject *v137;
  NSObject *v138;
  uint64_t v139;
  int v140;
  uint64_t v141;
  int ErrorLogLevelForModule;
  uint64_t v143;
  NSObject *v144;
  NSObject *v145;
  const char *v146;
  NSObject *v147;
  uint32_t v148;
  uint64_t v149;
  NSObject *v150;
  NSObject *v151;
  __int128 v152;
  uint64_t v153;
  uint64_t *v154;
  int v155;
  pthread_mutex_t *v156;
  unsigned int v157;
  unsigned __int8 v158;
  int v159;
  int v160;
  int v161;
  __int16 v162;
  char v163;
  char v164;
  int v165;
  uint64_t v166;
  int v167;
  _BOOL4 v168;
  uint64_t *v169;
  char *v170;
  unsigned int v171;
  int v172;
  int v173;
  __int128 v174;
  uint64_t v175;
  char *v176;
  int v177;
  __int128 v178;
  void *destination[2];
  uint64_t v180;
  CFTypeRef cf;
  void *value;
  __int128 v183;
  __int128 v184;
  __int128 v185;
  __int128 v186;
  uint64_t v187;
  CFAllocatorRef allocator;
  uint64_t v189;
  uint64_t v190;
  void *ptr;
  int v192;
  _BYTE valuePtr[12];
  __int16 v194;
  const char *v195;
  __int16 v196;
  int v197;
  __int16 v198;
  _BYTE v199[14];
  char v200[24];
  _BYTE buf[28];
  _QWORD v202[24];

  *(_QWORD *)((char *)&v202[21] + 4) = *MEMORY[0x1E0C80C00];
  v6 = a1 + 16496;
  cf = 0;
  v180 = 0;
  v178 = 0u;
  *(_OWORD *)destination = 0u;
  v7 = *(_WORD *)(a1 + 18096);
  *(_WORD *)(a1 + 18096) = v7 + 1;
  WORD1(v178) = v7;
  if (!sbuf)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v136 = VRTraceErrorLogLevelToCSTR();
      v137 = *MEMORY[0x1E0CF2758];
      v138 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v138, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = v136;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VideoTransmitter_ReadSampleBufferAttachments";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 3576;
          _os_log_impl(&dword_1D8A54000, v137, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCPCompressionSession Error: Encoder returned a NULL frame", buf, 0x1Cu);
        }
      }
      else if (os_log_type_enabled(v138, OS_LOG_TYPE_DEBUG))
      {
        _VideoTransmitter_TransmitEncodedVideoFrame_cold_8();
      }
    }
    v14 = 0;
    v24 = 0;
    goto LABEL_20;
  }
  v8 = *(_DWORD *)(a1 + 16) - 110;
  v9 = v8 > 0xF;
  v10 = (1 << v8) & 0xC001;
  _ZF = v9 || v10 == 0;
  if (_ZF)
  {
    SampleSize = CMSampleBufferGetSampleSize(sbuf, 0);
  }
  else
  {
    DataBuffer = CMSampleBufferGetDataBuffer(sbuf);
    if (!DataBuffer)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VideoTransmitter_TransmitEncodedVideoFrame_cold_11();
      }
      v14 = 0;
      goto LABEL_10;
    }
    SampleSize = CMBlockBufferGetDataLength(DataBuffer);
  }
  v14 = SampleSize;
LABEL_10:
  SampleAttachmentsArray = CMSampleBufferGetSampleAttachmentsArray(sbuf, 0);
  if (SampleAttachmentsArray)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(SampleAttachmentsArray, 0);
    _VideoTransmitter_ProcessMediaPriorityAttachment(a1, ValueAtIndex, a2);
    value = 0;
    ValueIfPresent = CFDictionaryGetValueIfPresent(ValueAtIndex, (const void *)*MEMORY[0x1E0CA2620], (const void **)&value);
    v18 = (const void *)*MEMORY[0x1E0C9AE50];
    v19 = value;
    v20 = CFDictionaryGetValue(ValueAtIndex, (const void *)*MEMORY[0x1E0CA25C8]);
    if (v18 == v19 && ValueIfPresent != 0 || *MEMORY[0x1E0C9AE40] != (_QWORD)v20)
    {
      v23 = 0x80;
      goto LABEL_27;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v29 = VRTraceErrorLogLevelToCSTR();
      v30 = *MEMORY[0x1E0CF2758];
      v31 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
      v23 = 0;
      if (!v31)
        goto LABEL_27;
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = v29;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "_VideoTransmitter_ProcessSampleAttachmentsArray";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 3468;
      LOWORD(v202[0]) = 1024;
      *(_DWORD *)((char *)v202 + 2) = v14;
      _os_log_impl(&dword_1D8A54000, v30, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d GOT A KEY FRAME FROM ENCODER (%d)!", buf, 0x22u);
    }
    v23 = 0;
LABEL_27:
    *(_BYTE *)(a2 + 96) = v23;
    if (v18 == CFDictionaryGetValue(ValueAtIndex, (const void *)*MEMORY[0x1E0CEDA90]))
    {
      *(_DWORD *)(a2 + 100) |= 2u;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v32 = VRTraceErrorLogLevelToCSTR();
        v33 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = v32;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VideoTransmitter_ProcessSampleAttachmentsArray";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 3477;
          _os_log_impl(&dword_1D8A54000, v33, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d GET A REFRESH FRAME FROM ENCODER!", buf, 0x1Cu);
        }
      }
    }
    *(_DWORD *)valuePtr = -1431655766;
    v34 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, (const void *)*MEMORY[0x1E0CEDA98]);
    if (v34)
    {
      CFNumberGetValue(v34, kCFNumberSInt32Type, valuePtr);
      v35 = *(_DWORD *)valuePtr;
      *(_DWORD *)(a2 + 100) |= 1u;
    }
    else
    {
      v35 = -1;
    }
    *(_DWORD *)(a2 + 104) = v35;
    v36 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, (const void *)*MEMORY[0x1E0CEDB18]);
    v37 = (_QWORD *)(a2 + 136);
    if (v36)
      CFNumberGetValue(v36, kCFNumberDoubleType, v37);
    else
      *v37 = 0xBFF0000000000000;
    v38 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, (const void *)*MEMORY[0x1E0CEDAD8]);
    v39 = (_QWORD *)(a2 + 144);
    if (v38)
      CFNumberGetValue(v38, kCFNumberDoubleType, v39);
    else
      *v39 = 0xBFF0000000000000;
    v40 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, (const void *)*MEMORY[0x1E0CEDAB8]);
    v41 = (_QWORD *)(a2 + 152);
    if (v40)
      CFNumberGetValue(v40, kCFNumberDoubleType, v41);
    else
      *v41 = 0xBFF0000000000000;
    LODWORD(v174) = 0;
    v42 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, (const void *)*MEMORY[0x1E0CEDA80]);
    if (v42)
    {
      CFNumberGetValue(v42, kCFNumberSInt32Type, &v174);
      v43 = v174;
    }
    else
    {
      v43 = 0;
    }
    *(_DWORD *)(a2 + 176) = v43;
    LODWORD(v180) = VideoUtil_GetEncodedFrameSEINaluOverheadBytes(ValueAtIndex);
    v44 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("EncoderMode"));
    v45 = (_DWORD *)(a2 + 228);
    if (v44)
      CFNumberGetValue(v44, kCFNumberSInt32Type, v45);
    else
      *v45 = 0;
    if (*(_BYTE *)(a2 + 440))
    {
      v46 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("TileOrder"));
      if (v46)
      {
        CFNumberGetValue(v46, kCFNumberSInt16Type, &v178);
        if ((unsigned __int16)v178 != WORD1(v178) && (int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v47 = VRTraceErrorLogLevelToCSTR();
          v48 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136316162;
            *(_QWORD *)&buf[4] = v47;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VideoTransmitter_ProcessSampleAttachmentsArray";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 3537;
            LOWORD(v202[0]) = 1024;
            *(_DWORD *)((char *)v202 + 2) = (unsigned __int16)v178;
            HIWORD(v202[0]) = 1024;
            LODWORD(v202[1]) = WORD1(v178);
            _os_log_error_impl(&dword_1D8A54000, v48, OS_LOG_TYPE_ERROR, " [%s] %s:%d Received decoding order %u, but expecting decoding order %u", buf, 0x28u);
          }
        }
      }
      else
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VideoTransmitter_TransmitEncodedVideoFrame_cold_10();
        }
        LOWORD(v178) = 0;
      }
      v49 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("TileID"));
      if (v49)
      {
        CFNumberGetValue(v49, kCFNumberSInt32Type, (char *)&v178 + 4);
        v50 = DWORD1(v178);
      }
      else
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VideoTransmitter_TransmitEncodedVideoFrame_cold_9();
        }
        v50 = 0;
        DWORD1(v178) = 0;
      }
      DWORD2(v178) = v50;
    }
    if (*(_BYTE *)(a2 + 448))
    {
      v51 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("TemporalID"));
      if (v51)
        CFNumberGetValue(v51, kCFNumberSInt32Type, (char *)&v178 + 8);
    }
    v24 = v14;
    goto LABEL_70;
  }
  v24 = v14;
LABEL_20:
  if (*(_BYTE *)(a2 + 448))
    _VideoTransmitter_GetStreamIndexFromAttachment(sbuf, (char *)&v178 + 8);
  *(_BYTE *)(a2 + 96) = 0;
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)(a2 + 136) = _Q0;
  *(_QWORD *)(a2 + 152) = 0xBFF0000000000000;
LABEL_70:
  if (DWORD2(v178) >= *(_DWORD *)(a1 + 1600))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v52 = VRTraceErrorLogLevelToCSTR();
      v53 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v116 = *(_DWORD *)(a1 + 1600);
        *(_DWORD *)buf = 136316418;
        *(_QWORD *)&buf[4] = v52;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VideoTransmitter_ReadSampleBufferAttachments";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 3592;
        LOWORD(v202[0]) = 2048;
        *(_QWORD *)((char *)v202 + 2) = a1;
        WORD1(v202[1]) = 1024;
        HIDWORD(v202[1]) = DWORD2(v178);
        LOWORD(v202[2]) = 1024;
        *(_DWORD *)((char *)&v202[2] + 2) = v116;
        _os_log_error_impl(&dword_1D8A54000, v53, OS_LOG_TYPE_ERROR, " [%s] %s:%d VideoTransmitter=%p Invaid streamIndex=%d (streamCount=%u)", buf, 0x32u);
      }
    }
    DWORD2(v178) = 0;
  }
  if (*(_DWORD *)(a1 + 496) == 2)
    _VideoTransmitter_UpdateVideoPriorityScore(a1, a2, sbuf);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v54 = VRTraceErrorLogLevelToCSTR();
    v55 = *MEMORY[0x1E0CF2758];
    v56 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
      {
        v57 = *(_DWORD *)(a2 + 180);
        *(_DWORD *)buf = 136316418;
        *(_QWORD *)&buf[4] = v54;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VideoTransmitter_TransmitEncodedVideoFrame";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 4950;
        LOWORD(v202[0]) = 1024;
        *(_DWORD *)((char *)v202 + 2) = v57;
        HIWORD(v202[0]) = 1024;
        LODWORD(v202[1]) = (unsigned __int16)v178;
        WORD2(v202[1]) = 1024;
        *(_DWORD *)((char *)&v202[1] + 6) = DWORD1(v178);
        _os_log_impl(&dword_1D8A54000, v55, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Encoder returned frame with RTP timestamp %d, decodingOrder %d, tileID %d", buf, 0x2Eu);
      }
    }
    else if (os_log_type_enabled(v56, OS_LOG_TYPE_DEBUG))
    {
      v135 = *(_DWORD *)(a2 + 180);
      *(_DWORD *)buf = 136316418;
      *(_QWORD *)&buf[4] = v54;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "_VideoTransmitter_TransmitEncodedVideoFrame";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 4950;
      LOWORD(v202[0]) = 1024;
      *(_DWORD *)((char *)v202 + 2) = v135;
      HIWORD(v202[0]) = 1024;
      LODWORD(v202[1]) = (unsigned __int16)v178;
      WORD2(v202[1]) = 1024;
      *(_DWORD *)((char *)&v202[1] + 6) = DWORD1(v178);
      _os_log_debug_impl(&dword_1D8A54000, v55, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Encoder returned frame with RTP timestamp %d, decodingOrder %d, tileID %d", buf, 0x2Eu);
    }
  }
  if (*(_DWORD *)(v6 + 320) && (v58 = *(_DWORD *)(a2 + 172)) != 0)
  {
    if (v58 <= v14)
      v58 = v14;
    v59 = v58 + 408;
  }
  else
  {
    v59 = v14 + 400;
  }
  destination[0] = CFAllocatorAllocate(*(CFAllocatorRef *)(a1 + 18136), v59, 0);
  destination[1] = (void *)__PAIR64__(v59, v14);
  if (destination[0])
  {
    if (v14 >= 1)
    {
      v61 = CMSampleBufferGetDataBuffer(sbuf);
      CMBlockBufferCopyDataBytes(v61, 0, v24, destination[0]);
    }
    v177 = -1431655766;
    v176 = 0;
    v62 = *(_DWORD *)(a1 + 16) - 110;
    if (v62 <= 0xF && ((1 << v62) & 0xC001) != 0)
    {
      ++*(_DWORD *)(v6 + 1296);
      _VideoTransmitter_UpdateCompoundStreamIDs(a1, a2, (uint64_t)&v178);
      v63 = a1 + 120 * SDWORD2(v178);
      Stream = v63 + 520;
      *(_DWORD *)(v63 + 572) = DWORD1(v178);
      *(_DWORD *)(a1 + 4432) = _VideoTransmitter_GetFECLevelOfProtection(a1, a2);
      v176 = (char *)destination[0];
      v177 = (int)destination[1];
      goto LABEL_117;
    }
    v65 = *(_DWORD *)(v6 + 972);
    if (v65 == 1752589105 || v65 == 1635148593)
    {
      if (destination[0] && LODWORD(destination[1]) == 4)
        *(_DWORD *)destination[0] = 0x4000000;
      if (!*(_BYTE *)(a2 + 96))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v66 = VRTraceErrorLogLevelToCSTR();
          v67 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v68 = *(_DWORD *)(a1 + 24);
            v69 = *(_DWORD *)(a1 + 28);
            v71 = *(_DWORD *)(a2 + 180);
            v70 = *(_DWORD *)(a2 + 184);
            *(_DWORD *)buf = 136316674;
            *(_QWORD *)&buf[4] = v66;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VideoTransmitter_PrepareBitstream";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 3649;
            LOWORD(v202[0]) = 1024;
            *(_DWORD *)((char *)v202 + 2) = v68;
            HIWORD(v202[0]) = 1024;
            LODWORD(v202[1]) = v69;
            WORD2(v202[1]) = 1024;
            *(_DWORD *)((char *)&v202[1] + 6) = v70;
            WORD1(v202[2]) = 1024;
            HIDWORD(v202[2]) = v71;
            _os_log_impl(&dword_1D8A54000, v67, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VideoUtil_AddImgDescToBitstream to stream with width %d, height %d fUseSPSPPS %d TS:%08X", buf, 0x34u);
          }
        }
        VideoUtil_AddImgDescToBitstream(sbuf, a2, *(_DWORD *)(a2 + 184), *(_DWORD *)(v6 + 972), (uint64_t)destination[0], (int *)&destination[1], SHIDWORD(destination[1]));
      }
      if (*(_DWORD *)(v6 + 320) && LODWORD(destination[1]) != 4 && SLODWORD(destination[1]) < *(_DWORD *)(a2 + 172))
        VideoUtil_AddFakeLargeFrameData(a2, (uint64_t)destination[0], (int *)&destination[1]);
    }
    v72 = *(_DWORD *)(a2 + 172);
    if (v72)
    {
      if (LODWORD(destination[1]) < v72)
      {
        if (*(_DWORD *)(v6 + 324))
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v73 = VRTraceErrorLogLevelToCSTR();
            v74 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              v75 = *(_DWORD *)(a2 + 172);
              *(_DWORD *)buf = 136316162;
              *(_QWORD *)&buf[4] = v73;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_VideoTransmitter_PrepareBitstream";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 3676;
              LOWORD(v202[0]) = 1024;
              *(_DWORD *)((char *)v202 + 2) = v75;
              HIWORD(v202[0]) = 1024;
              LODWORD(v202[1]) = destination[1];
              _os_log_impl(&dword_1D8A54000, v74, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d ^^^^ CODEC LATE/SKIPPING: reqd %d  got %d ", buf, 0x28u);
            }
          }
        }
      }
    }
    Stream = _VideoTransmitter_UpdateEncoderArgsAndGetStream(a1, a2, v60, (uint64_t)&v178);
    v76 = _VideoTransmitter_EncryptFrame(a1, Stream, &v176, &v177, (uint64_t)&v178, *(_BYTE *)(a2 + 96) == 0, (CMBlockBufferRef *)&cf);
    if (!(_DWORD)v76)
    {
      if (!Stream)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VideoTransmitter_TransmitEncodedVideoFrame_cold_2();
        }
        goto LABEL_214;
      }
LABEL_117:
      v77 = *(unsigned __int8 *)(a2 + 96);
      v78 = *(_BYTE *)(a2 + 244);
      v79 = *(_QWORD *)(a1 + 1648);
      if (v79 && VCMediaControlInfoGeneratorGetVersion(v79) == 1)
        v78 &= ~4u;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v80 = VRTraceErrorLogLevelToCSTR();
        v81 = *MEMORY[0x1E0CF2758];
        v82 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
          {
            v83 = *(unsigned __int8 *)(a2 + 384);
            *(_DWORD *)buf = 136315906;
            *(_QWORD *)&buf[4] = v80;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VideoTransmitter_TransmitEncodedVideoFrame";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 4989;
            LOWORD(v202[0]) = 1024;
            *(_DWORD *)((char *)v202 + 2) = v83;
            _os_log_impl(&dword_1D8A54000, v81, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d [Media Priority] Sending video priority=%d", buf, 0x22u);
          }
        }
        else if (os_log_type_enabled(v82, OS_LOG_TYPE_DEBUG))
        {
          _VideoTransmitter_TransmitEncodedVideoFrame_cold_6();
        }
      }
      v168 = v77 == 0;
      v173 = v177;
      v170 = v176;
      v171 = *(_DWORD *)(a2 + 180);
      *(_OWORD *)buf = *(_OWORD *)(a2 + 40);
      *(_QWORD *)&buf[16] = *(_QWORD *)(a2 + 56);
      Seconds = CMTimeGetSeconds((CMTime *)buf);
      v85 = *(_DWORD *)(a2 + 100);
      v172 = *(unsigned __int8 *)(a2 + 354);
      v164 = *(_BYTE *)(a2 + 384);
      v165 = *(_DWORD *)(a2 + 240);
      v86 = *(unsigned __int8 *)(a2 + 448);
      v162 = *(_WORD *)(a2 + 450);
      v163 = *(_BYTE *)(a2 + 380);
      v87 = v180;
      v161 = *(_DWORD *)(a2 + 400);
      v174 = *(_OWORD *)(a2 + 404);
      v175 = *(_QWORD *)(a2 + 420);
      v159 = *(_DWORD *)(a2 + 428);
      v160 = v86;
      v166 = *(_QWORD *)(a2 + 432);
      v192 = 0;
      ptr = 0;
      v88 = micro();
      if (v77)
      {
        if ((v85 & 2) == 0)
          goto LABEL_129;
      }
      else
      {
        *(_DWORD *)(a1 + 260) = 1;
        ++*(_DWORD *)(a1 + 264);
        ++*(_DWORD *)(a1 + 272);
        if ((v85 & 2) == 0)
        {
LABEL_129:
          v89 = 2149449731;
          if (!*(_DWORD *)(a1 + 260))
          {
            v89 = 2149449745;
            goto LABEL_219;
          }
          v158 = v78;
          v167 = v77;
          v155 = *(_DWORD *)(a1 + 4432);
          SummerAdd((double)v173, v88);
          v169 = (uint64_t *)Stream;
          SummerAdd((double)v87, v88);
          v183 = 0u;
          v184 = 0u;
          v185 = 0u;
          v186 = 0u;
          v90 = *(_DWORD *)(a1 + 496);
          value = (void *)(a1 + 1748);
          LOWORD(v183) = 10;
          *((_QWORD *)&v183 + 1) = a1 + 1744;
          *(_QWORD *)&v184 = a1 + 1680;
          v156 = (pthread_mutex_t *)(a1 + 1680);
          v154 = (uint64_t *)(a1 + 280);
          *((_QWORD *)&v184 + 1) = a1 + 280;
          *(_QWORD *)&v185 = a1 + 288;
          v187 = 0;
          *((_QWORD *)&v185 + 1) = a1 + 276;
          v91 = v90 == 2 && *(_DWORD *)(a1 + 4432) == 0;
          BYTE3(v187) = v91;
          allocator = *(CFAllocatorRef *)(a1 + 18128);
          v189 = a1 + 304;
          v190 = a1 + 312;
          if (!VCRateControlGetProbingSequencePacketizationInfo(*(void **)(a1 + 1656), &v186, (_DWORD *)&v186 + 2, (_DWORD *)&v186 + 1)|| !*(_BYTE *)(v6 + 330))
          {
            DWORD2(v186) = 0;
            *(_QWORD *)&v186 = 0;
          }
          if (*(_DWORD *)(a1 + 496) == 2)
          {
            if (*(_DWORD *)(v6 + 1280))
              LODWORD(v186) = 3;
            *(_DWORD *)(v6 + 1280) = 0;
          }
          v92 = v186;
          BYTE12(v186) = *(_DWORD *)(v6 + 316) != 0;
          v157 = (int)v186 > 0;
          ProbePkt = Throttling_VideoTransmitter_ForceMinFirstProbePkt(*(unsigned __int8 *)(v6 + 328), v157);
          v94 = 0;
          BYTE13(v186) = ProbePkt;
          v95 = *(_DWORD *)(v6 + 480);
          v97 = v95 == 2 || v95 == 4;
          if (!v167 && v97)
            v94 = *(_DWORD *)(a1 + 4376) >> 6 < 0x271u;
          BYTE14(v186) = v94;
          HIWORD(v187) = *(_WORD *)(Stream + 48);
          BYTE4(v187) = *(_BYTE *)(v6 + 1596);
          pthread_mutex_lock((pthread_mutex_t *)(a1 + 17288));
          v98 = *(_WORD *)(v6 + 858);
          if (!v98)
            v98 = *(_WORD *)(v6 + 780);
          LOWORD(v187) = v98;
          BYTE2(v187) = *(_BYTE *)(v6 + 782);
          pthread_mutex_unlock((pthread_mutex_t *)(a1 + 17288));
          if (!v172 || *(_BYTE *)(v6 + 856))
          {
            LOWORD(v187) = v187
                         - VTU_GetOverhead(v172, (v90 < 6) & (0x3Au >> v90), (v90 < 6) & (0x3Au >> v90), BYTE2(v187));
            v99 = (uint64_t *)Stream;
          }
          else
          {
            LOWORD(v187) = v187 - VCNetworkUtils_AdditionalOverheadForIDSOptions(v172, 1, 1);
            *(_QWORD *)valuePtr = 0;
            *(_QWORD *)v200 = 0;
            *(_DWORD *)v200 = VCMediaControlInfoGeneratorGetType(*(_QWORD *)(a1 + 1648));
            v200[4] = VCMediaControlInfoGeneratorGetVersion(*(_QWORD *)(a1 + 1648));
            v99 = (uint64_t *)Stream;
            v100 = VCFramingOverheadCalculationUtils_PerPacketMediaFramingOverheadWithRTPHandle(*(_QWORD *)Stream, (unsigned int *)v200, (uint64_t *)valuePtr);
            if (v100 < 0)
            {
              v105 = v100;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                v153 = VRTraceErrorLogLevelToCSTR();
                v106 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                {
                  v107 = *v169;
                  *(_DWORD *)buf = 136316674;
                  *(_QWORD *)&buf[4] = v153;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = "_VideoTransmitter_SetupSplitterData";
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&buf[24] = 2055;
                  LOWORD(v202[0]) = 1024;
                  *(_DWORD *)((char *)v202 + 2) = v105;
                  HIWORD(v202[0]) = 2048;
                  v202[1] = v107;
                  LOWORD(v202[2]) = 1024;
                  *(_DWORD *)((char *)&v202[2] + 2) = *(_DWORD *)v200;
                  HIWORD(v202[2]) = 1024;
                  LODWORD(v202[3]) = v200[4];
                  _os_log_error_impl(&dword_1D8A54000, v106, OS_LOG_TYPE_ERROR, " [%s] %s:%d Failed to get framing overhead response=%d rtpHandle=%p, mediaControlConfig generatorType=%u version=%d", buf, 0x38u);
                }
              }
            }
            else
            {
              LOWORD(v187) = v187 - *(_WORD *)valuePtr;
            }
          }
          v101 = *(_DWORD *)(a1 + 16);
          if ((v101 - 110) <= 0xF && ((1 << (v101 - 110)) & 0xC001) != 0)
            v102 = VTU_SplitGenericDataIntoPackets((uint64_t)&value, v101, (uint64_t)v170, v173, &ptr, *(_DWORD *)(a1 + 4376));
          else
            v102 = VTU_SplitVideoIntoPackets((unsigned __int16 **)&value, v101, v170, v173, &ptr, 0, 0, 1, 0, *(_DWORD *)(a1 + 4424), *(_DWORD *)(a1 + 4376), v155);
          v103 = v102;
          if (v102 < 2)
          {
            if (!v102)
              goto LABEL_167;
          }
          else
          {
            *(double *)(a1 + 17768) = v88;
          }
          if (v102 > *(_DWORD *)(a1 + 276))
          {
LABEL_167:
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                _VideoTransmitter_TransmitEncodedVideoFrame_cold_4();
            }
            v104 = *(_QWORD *)(a1 + 1632);
            if (v104 != 0xFFFFFFFFLL)
              (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 1616) + 40))(v104, a1 + 1748, 2);
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                _VideoTransmitter_TransmitEncodedVideoFrame_cold_3();
            }
            goto LABEL_216;
          }
          *(_WORD *)v6 = v102;
          if (*(_BYTE *)(v6 + 12))
          {
            *(_DWORD *)(v6 + 8) = v171;
            *(_BYTE *)(v6 + 12) = 0;
          }
          else
          {
            v108 = v171 - *(_DWORD *)(v6 + 8);
            if (v108 && v108 <= 0x7FFFFFFE)
            {
              ++*(_WORD *)(v6 + 4);
              *(_DWORD *)(v6 + 8) = v171;
            }
          }
          if (v85 & 2 | v168)
          {
            RTPRecordKeyFrame(*v99, *(_DWORD *)(a1 + 16), v102, v171, v168);
            v109 = *(_QWORD *)(a1 + 1664);
            if (v109)
            {
              *(_QWORD *)&buf[12] = 0;
              *(_QWORD *)&buf[4] = 0;
              *(_QWORD *)&buf[20] = 0x400000000;
              memset((char *)&v202[2] + 1, 0, 19);
              memset(&v202[6], 0, 124);
              v110 = *(_DWORD *)(a1 + 16);
              *(_DWORD *)buf = 10;
              v202[1] = 0;
              v202[0] = 0;
              LOBYTE(v202[2]) = v167 == 0;
              HIDWORD(v202[4]) = v171;
              v202[5] = __PAIR64__(v103, v110);
              VCRateControlSetStatistics(v109, buf);
            }
          }
          if (!*(_DWORD *)(v6 + 316) && !*(_DWORD *)(v6 + 320))
            goto LABEL_198;
          if (v92 < 1)
            goto LABEL_198;
          v111 = v186;
          if ((_DWORD)v186 == v103 || !*(_DWORD *)(v6 + 324))
            goto LABEL_198;
          v112 = DWORD2(v186);
          if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
          {
            v113 = VRTraceErrorLogLevelToCSTR();
            v114 = *MEMORY[0x1E0CF2758];
            v115 = *MEMORY[0x1E0CF2758];
            if (*MEMORY[0x1E0CF2748])
            {
              if (os_log_type_enabled(v115, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136316162;
                *(_QWORD *)&buf[4] = v113;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "_VideoTransmitter_LogBWEInfo";
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&buf[24] = 1891;
                LOWORD(v202[0]) = 1024;
                *(_DWORD *)((char *)v202 + 2) = v111;
                HIWORD(v202[0]) = 1024;
                LODWORD(v202[1]) = v103;
                _os_log_impl(&dword_1D8A54000, v114, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d ^^^^MISMATCH of req'd Probe Packets and splitter's: %d %d", buf, 0x28u);
              }
            }
            else if (os_log_type_enabled(v115, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136316162;
              *(_QWORD *)&buf[4] = v113;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_VideoTransmitter_LogBWEInfo";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 1891;
              LOWORD(v202[0]) = 1024;
              *(_DWORD *)((char *)v202 + 2) = v111;
              HIWORD(v202[0]) = 1024;
              LODWORD(v202[1]) = v103;
              _os_log_debug_impl(&dword_1D8A54000, v114, OS_LOG_TYPE_DEBUG, " [%s] %s:%d ^^^^MISMATCH of req'd Probe Packets and splitter's: %d %d", buf, 0x28u);
            }
          }
          if (g_iBWEstLogLevel < 6)
            goto LABEL_198;
          memset(v200, 170, 20);
          strncpy(buf, "^^^^Probe pkts ", 0xC8uLL);
          if (v103 < 1)
          {
            v140 = 0;
          }
          else
          {
            v139 = 0;
            v140 = 0;
            v141 = *v154;
            do
            {
              __sprintf_chk(v200, 0, 0x14uLL, "%d ", *(_DWORD *)(v141 + v139));
              __strlcat_chk();
              v141 = *v154;
              if ((double)v112 * 0.95 <= (double)*(int *)(*v154 + v139))
                ++v140;
              if (strlen(buf) > 0xB9)
                break;
              _ZF = 4 * v103 - 4 == v139;
              v139 += 4;
            }
            while (!_ZF);
          }
          ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
          if (v140 >= v111)
          {
            if (ErrorLogLevelForModule >= 8)
            {
              v149 = VRTraceErrorLogLevelToCSTR();
              v150 = *MEMORY[0x1E0CF2758];
              v151 = *MEMORY[0x1E0CF2758];
              if (!*MEMORY[0x1E0CF2748])
              {
                if (os_log_type_enabled(v151, OS_LOG_TYPE_DEBUG))
                  _VideoTransmitter_TransmitEncodedVideoFrame_cold_5();
                goto LABEL_274;
              }
              if (os_log_type_enabled(v151, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)valuePtr = 136315906;
                *(_QWORD *)&valuePtr[4] = v149;
                v194 = 2080;
                v195 = "_VideoTransmitter_LogBWEInfo";
                v196 = 1024;
                v197 = 1913;
                v198 = 2080;
                *(_QWORD *)v199 = buf;
                v146 = " [%s] %s:%d szMsg = %s";
                v147 = v150;
                v148 = 38;
                goto LABEL_269;
              }
            }
          }
          else if (ErrorLogLevelForModule >= 8)
          {
            v143 = VRTraceErrorLogLevelToCSTR();
            v144 = *MEMORY[0x1E0CF2758];
            v145 = *MEMORY[0x1E0CF2758];
            if (!*MEMORY[0x1E0CF2748])
            {
              if (os_log_type_enabled(v145, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)valuePtr = 136316162;
                *(_QWORD *)&valuePtr[4] = v143;
                v194 = 2080;
                v195 = "_VideoTransmitter_LogBWEInfo";
                v196 = 1024;
                v197 = 1915;
                v198 = 1024;
                *(_DWORD *)v199 = v112;
                *(_WORD *)&v199[4] = 2080;
                *(_QWORD *)&v199[6] = buf;
                _os_log_debug_impl(&dword_1D8A54000, v144, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Expected: %d but \t %s", valuePtr, 0x2Cu);
              }
              goto LABEL_274;
            }
            if (os_log_type_enabled(v145, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)valuePtr = 136316162;
              *(_QWORD *)&valuePtr[4] = v143;
              v194 = 2080;
              v195 = "_VideoTransmitter_LogBWEInfo";
              v196 = 1024;
              v197 = 1915;
              v198 = 1024;
              *(_DWORD *)v199 = v112;
              *(_WORD *)&v199[4] = 2080;
              *(_QWORD *)&v199[6] = buf;
              v146 = " [%s] %s:%d Expected: %d but \t %s";
              v147 = v144;
              v148 = 44;
LABEL_269:
              _os_log_impl(&dword_1D8A54000, v147, OS_LOG_TYPE_DEFAULT, v146, valuePtr, v148);
            }
          }
LABEL_274:
          v99 = v169;
LABEL_198:
          *(_OWORD *)buf = v174;
          *(_QWORD *)&buf[16] = v175;
          CMTimeGetSeconds((CMTime *)buf);
          kdebug_trace();
          if (*(int *)(v6 + 1592) > 1)
          {
            VideoUtil_ConstructSubFrameIdentifer(*((unsigned __int16 *)v99 + 24), *((unsigned int *)v99 + 13));
            kdebug_trace();
          }
          v117 = *(_DWORD *)(a1 + 496);
          if (v117 == 5 || v117 == 3)
          {
            *(_QWORD *)&buf[16] = 0x1000000;
            memset(&v202[1], 0, 164);
            v118 = *(_DWORD *)(a1 + 16584) + *(_DWORD *)(a1 + 16568);
            v119 = *(_DWORD *)(v6 + 80) + *(_DWORD *)(v6 + 64);
            v120 = *(_QWORD *)(a1 + 1664);
            *(_QWORD *)buf = 6;
            *(double *)&buf[8] = v88;
            *(_DWORD *)&buf[24] = (unsigned __int16)(v171 >> 8);
            v202[0] = __PAIR64__(v118, v119);
            VCRateControlSetStatistics(v120, buf);
          }
          *(_OWORD *)&buf[4] = v174;
          *(_QWORD *)&buf[20] = v175;
          *(_DWORD *)buf = v161;
          LODWORD(v202[0]) = v159;
          *(_QWORD *)((char *)v202 + 4) = v166;
          *((_QWORD *)&v152 + 1) = &v192;
          *(_QWORD *)&v152 = ptr;
          v121 = _VideoTransmitter_TransmitVideoPacketsInGroups(a1, v99, v103, v171, v168, 0, 0, v85, Seconds, v88, v158, v165, v157, v173, v152, (__int16 *)(a2 + 330), v172, v164, (__int16 *)(a2 + 356),
                   v163,
                   buf,
                   v160 != 0,
                   v162);
          if ((v121 & 0x80000000) != 0)
          {
            v89 = v121;
LABEL_216:
            if (ptr && ptr != v170)
              CFAllocatorDeallocate(allocator, ptr);
            goto LABEL_219;
          }
          ++*(_DWORD *)(v6 + 1304);
          if (!v167 && *(_BYTE *)(v6 + 1752))
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v122 = VRTraceErrorLogLevelToCSTR();
              v123 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                v124 = *(_DWORD *)(a1 + 264);
                v125 = *(unsigned __int16 *)(a2 + 330);
                v126 = *((unsigned __int16 *)v99 + 24);
                *(_DWORD *)buf = 136316930;
                *(_QWORD *)&buf[4] = v122;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "_VideoTransmitter_PacketizeAndTransmitEncodedVideoFrame";
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&buf[24] = 4796;
                LOWORD(v202[0]) = 2048;
                *(_QWORD *)((char *)v202 + 2) = a1;
                WORD1(v202[1]) = 1024;
                HIDWORD(v202[1]) = v124;
                LOWORD(v202[2]) = 1024;
                *(_DWORD *)((char *)&v202[2] + 2) = v192;
                HIWORD(v202[2]) = 1024;
                LODWORD(v202[3]) = v125;
                WORD2(v202[3]) = 1024;
                *(_DWORD *)((char *)&v202[3] + 6) = v126;
                _os_log_impl(&dword_1D8A54000, v123, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VideoTransmitter[%p] keyFrameCounter:%d Sent key frame bytes:%d with streamID:%d decodingOrder:%d", buf, 0x3Eu);
              }
            }
            *(double *)(a1 + 4336) = v88;
            *(_WORD *)buf = v192;
            v127 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
            Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            v129 = CFNumberCreate(v127, kCFNumberSInt16Type, buf);
            CFDictionaryAddValue(Mutable, CFSTR("VCVSKeyFrameSize"), v129);
            CFRelease(v129);
            reportingVideoStreamEvent();
            CFRelease(Mutable);
          }
          if (ptr && ptr != v170)
            CFAllocatorDeallocate(allocator, ptr);
          pthread_mutex_lock(v156);
          v130 = *(_DWORD *)(a1 + 1672);
          *(_DWORD *)(a1 + 1672) = 0;
          pthread_mutex_unlock(v156);
          SummerAdd((double)(v192 + v130), v88);
LABEL_214:
          v89 = 0;
          goto LABEL_219;
        }
      }
      ++*(_DWORD *)(a1 + 272);
      goto LABEL_129;
    }
    v89 = v76;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VideoTransmitter_TransmitEncodedVideoFrame_cold_7();
    }
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VideoTransmitter_TransmitEncodedVideoFrame_cold_1();
    }
    v89 = 4294967089;
  }
LABEL_219:
  v131 = *(double *)(a2 + 136);
  if (v131 <= 0.0)
    v131 = *(double *)(a1 + 16528);
  *(double *)(a1 + 16528) = v131;
  v132 = *(double *)(a2 + 144);
  if (v132 <= 0.0)
    v132 = *(double *)(a1 + 16536);
  *(double *)(a1 + 16536) = v132;
  v133 = *(double *)(a2 + 152);
  if (v133 <= 0.0)
    v133 = *(double *)(a1 + 16544);
  *(double *)(a1 + 16544) = v133;
  if (destination[0])
  {
    CFAllocatorDeallocate(*(CFAllocatorRef *)(a1 + 18136), destination[0]);
    destination[0] = 0;
  }
  if (cf)
    CFRelease(cf);
  return v89;
}

void _VideoTransmitter_DispatchEncoderCallback(uint64_t a1, uint64_t a2, int a3, opaqueCMSampleBuffer *a4)
{
  uint64_t v8;
  uint64_t v9;
  const __CFArray *SampleAttachmentsArray;
  const __CFDictionary *ValueAtIndex;
  const __CFNumber *Value;
  const __CFNumber *v13;
  uint64_t value_low;
  uint64_t v15;
  NSObject *v16;
  NSObject *v17;
  const char *v18;
  uint64_t v19;
  NSObject *v20;
  NSObject *v21;
  _QWORD block[8];
  unsigned __int16 valuePtr;
  CMTime buf;
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v8 = CheckInHandleDebug();
  if (v8)
  {
    v9 = v8;
    _VideoTransmitter_CheckStatusAndHandleError(v8, a3);
    if (a4)
    {
      if (CMSampleBufferGetSampleSize(a4, 0))
      {
        valuePtr = 0;
        LODWORD(buf.value) = 0;
        SampleAttachmentsArray = CMSampleBufferGetSampleAttachmentsArray(a4, 0);
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(SampleAttachmentsArray, 0);
        Value = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("TileOrder"));
        if (Value)
        {
          CFNumberGetValue(Value, kCFNumberSInt16Type, &valuePtr);
          valuePtr += *(_WORD *)(v9 + 18094);
        }
        v13 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("TileID"));
        if (v13)
        {
          CFNumberGetValue(v13, kCFNumberSInt32Type, &buf);
          value_low = LODWORD(buf.value);
        }
        else
        {
          value_low = 0;
        }
        VideoUtil_ConstructSubFrameIdentifer(valuePtr, value_low);
        buf = *(CMTime *)(a2 + 404);
        CMTimeGetSeconds(&buf);
        kdebug_trace();
        if (*(_BYTE *)(v9 + 18208))
        {
          _VideoTransmitter_TransmitFrame(v9, a2, a4);
          _VideoTransmitter_ProcessEncoderArgs(v9, (_DWORD *)a2);
          CheckOutHandleDebug();
        }
        else
        {
          CFRetain(a4);
          v21 = *(NSObject **)(v9 + 17720);
          block[0] = MEMORY[0x1E0C809B0];
          block[1] = 0x40000000;
          block[2] = ___VideoTransmitter_DispatchEncoderCallback_block_invoke;
          block[3] = &__block_descriptor_tmp_8;
          block[4] = v9;
          block[5] = a2;
          block[6] = a4;
          block[7] = a1;
          dispatch_async(v21, block);
        }
        return;
      }
      _VideoTransmitter_ProcessEncoderArgs(v9, (_DWORD *)a2);
      CheckOutHandleDebug();
      if ((int)VRTraceGetErrorLogLevelForModule() < 8)
        return;
      v19 = VRTraceErrorLogLevelToCSTR();
      v16 = *MEMORY[0x1E0CF2758];
      v20 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (!os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          return;
        LODWORD(buf.value) = 136315650;
        *(CMTimeValue *)((char *)&buf.value + 4) = v19;
        LOWORD(buf.flags) = 2080;
        *(_QWORD *)((char *)&buf.flags + 2) = "_VideoTransmitter_DispatchEncoderCallback";
        HIWORD(buf.epoch) = 1024;
        v25 = 3359;
        v18 = " [%s] %s:%d Encoder callback returned an empty sample buffer";
        goto LABEL_19;
      }
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
        _VideoTransmitter_DispatchEncoderCallback_cold_3();
    }
    else
    {
      _VideoTransmitter_ProcessEncoderArgs(v9, (_DWORD *)a2);
      CheckOutHandleDebug();
      if ((int)VRTraceGetErrorLogLevelForModule() < 8)
        return;
      v15 = VRTraceErrorLogLevelToCSTR();
      v16 = *MEMORY[0x1E0CF2758];
      v17 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          return;
        LODWORD(buf.value) = 136315650;
        *(CMTimeValue *)((char *)&buf.value + 4) = v15;
        LOWORD(buf.flags) = 2080;
        *(_QWORD *)((char *)&buf.flags + 2) = "_VideoTransmitter_DispatchEncoderCallback";
        HIWORD(buf.epoch) = 1024;
        v25 = 3351;
        v18 = " [%s] %s:%d Encoder callback returned a nil sample buffer";
LABEL_19:
        _os_log_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEFAULT, v18, (uint8_t *)&buf, 0x1Cu);
        return;
      }
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
        _VideoTransmitter_DispatchEncoderCallback_cold_2();
    }
  }
  else
  {
    free((void *)a2);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VideoTransmitter_DispatchEncoderCallback_cold_1();
    }
  }
}

void _VideoTransmitter_ProcessEncoderArgs(uint64_t a1, _DWORD *__new)
{
  int v2;
  void *v5;

  v2 = __new[111] + 1;
  __new[111] = v2;
  if (*(_DWORD *)(a1 + 18088) == v2)
  {
    v5 = (void *)*((_QWORD *)__new + 14);
    if (v5)
      free(v5);
    VCMemoryPool_Free(*(OSQueueHead **)(a1 + 17728), __new);
  }
}

uint64_t _VideoTransmitter_DequeueEncoderError(uint64_t a1)
{
  unsigned int *v2;
  uint64_t v3;

  if (CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 17752)) < 1)
    return 0;
  while (1)
  {
    v2 = (unsigned int *)CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 17752));
    if (v2)
    {
      v3 = *v2;
      VCMemoryPool_Free(*(OSQueueHead **)(a1 + 17736), v2);
      if ((_DWORD)v3 == -2145517538 || (_DWORD)v3 == -2145517566)
        break;
    }
    if (CMSimpleQueueGetCount(*(CMSimpleQueueRef *)(a1 + 17752)) <= 0)
      return 0;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VideoTransmitter_DequeueEncoderError_cold_1();
  }
  return v3;
}

void _VideoTransmitter_ProcessMediaPriorityAttachment(uint64_t a1, CFDictionaryRef theDict, uint64_t a3)
{
  const __CFNumber *Value;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  CFNumberRef v11;
  uint64_t v12;
  NSObject *v13;
  NSObject *v14;
  int v15;
  int v16;
  unsigned __int16 valuePtr;
  unsigned __int16 v18;
  uint8_t buf[4];
  uint64_t v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  const __CFString *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  valuePtr = 0;
  Value = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("PriorityScore"));
  if (Value)
  {
    CFNumberGetValue(Value, kCFNumberSInt16Type, &valuePtr);
    v7 = valuePtr;
  }
  else
  {
    v7 = 0;
  }
  v8 = *(unsigned __int16 *)(a3 + 452);
  if (v8 <= v7)
    v8 = v7;
  if (v8 >= 0xFF)
    v9 = 255;
  else
    v9 = v8;
  if (v9 <= 1)
    v9 = 1;
  if (v8)
    v10 = v9;
  else
    v10 = 0;
  v18 = v10;
  if (v7 != v10)
  {
    v11 = CFNumberCreate(*(CFAllocatorRef *)(a1 + 18304), kCFNumberSInt16Type, &v18);
    CFDictionarySetValue(theDict, CFSTR("PriorityScore"), v11);
    if (v11)
      CFRelease(v11);
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v12 = VRTraceErrorLogLevelToCSTR();
    v13 = *MEMORY[0x1E0CF2758];
    v14 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        v15 = *(unsigned __int16 *)(a3 + 452);
        *(_DWORD *)buf = 136316674;
        v20 = v12;
        v21 = 2080;
        v22 = "_VideoTransmitter_ProcessMediaPriorityAttachment";
        v23 = 1024;
        v24 = 3449;
        v25 = 2112;
        v26 = CFSTR("PriorityScore");
        v27 = 1024;
        v28 = v18;
        v29 = 1024;
        v30 = valuePtr;
        v31 = 1024;
        v32 = v15;
        _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d [Media Priority] key=%@, score=%u. (encoder=%3u, capture=%d)", buf, 0x38u);
      }
    }
    else if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      v16 = *(unsigned __int16 *)(a3 + 452);
      *(_DWORD *)buf = 136316674;
      v20 = v12;
      v21 = 2080;
      v22 = "_VideoTransmitter_ProcessMediaPriorityAttachment";
      v23 = 1024;
      v24 = 3449;
      v25 = 2112;
      v26 = CFSTR("PriorityScore");
      v27 = 1024;
      v28 = v18;
      v29 = 1024;
      v30 = valuePtr;
      v31 = 1024;
      v32 = v16;
      _os_log_debug_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEBUG, " [%s] %s:%d [Media Priority] key=%@, score=%u. (encoder=%3u, capture=%d)", buf, 0x38u);
    }
  }
  *(_BYTE *)(a3 + 384) = v18;
}

uint64_t _VideoTransmitter_SetNewEncoderMode(uint64_t a1, uint64_t a2)
{
  int *v3;
  uint64_t v4;
  NSObject *v5;
  int v6;
  const char *v7;
  _DWORD buf[3];
  __int16 v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  const char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v3 = (int *)(a1 + 16652);
  *(_DWORD *)(a1 + 16652) = *(_DWORD *)(a2 + 228);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v6 = *v3;
      buf[0] = 136315906;
      if (v6)
        v7 = "Software";
      else
        v7 = "Hardware";
      *(_QWORD *)&buf[1] = v4;
      v10 = 2080;
      v11 = "_VideoTransmitter_SetNewEncoderMode";
      v12 = 1024;
      v13 = 3722;
      v14 = 2080;
      v15 = v7;
      _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d SETTING NEW ENCODER MODE: %s.", (uint8_t *)buf, 0x26u);
    }
  }
  memset(buf, 0, sizeof(buf));
  snprintf((char *)buf, 0xCuLL, "%d", *(_DWORD *)(a1 + 16));
  return reportingLog();
}

uint64_t _VideoTransmitter_FlushBasebandForRefreshFrame(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  unsigned __int8 *v4;
  uint64_t v5;
  NSObject *v6;
  int v7;
  int v8;
  unsigned __int16 v9;
  uint8_t buf[4];
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(result + 96))
  {
    v3 = result;
    v4 = (unsigned __int8 *)(result + 16824);
    v9 = 0;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v6 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v7 = *(_DWORD *)(a2 + 180);
        *(_DWORD *)buf = 136315906;
        v11 = v5;
        v12 = 2080;
        v13 = "_VideoTransmitter_FlushBasebandForRefreshFrame";
        v14 = 1024;
        v15 = 3736;
        v16 = 1024;
        v17 = v7;
        _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Got a refresh frame (%08X)", buf, 0x22u);
      }
    }
    v8 = *(_DWORD *)(a2 + 180);
    *((_DWORD *)v4 + 112) = v8;
    RTPFlushBaseband(*(_QWORD *)(v3 + 520), *v4, v8, 2u, 0, 0, &v9);
    return RTPMarkSpecialVideoFlush(*(_QWORD *)(v3 + 520), 1, v9);
  }
  return result;
}

uint64_t _videoTransmitter_HandleLTRFrame(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  int v13;
  int v15;
  int v16;
  uint64_t v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 18092))
    a3 = *(_DWORD *)(a2 + 180);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v6 = VRTraceErrorLogLevelToCSTR();
    v7 = *MEMORY[0x1E0CF2758];
    v8 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        v9 = *(_DWORD *)(a2 + 104);
        v16 = 136316162;
        v17 = v6;
        v18 = 2080;
        v19 = "_videoTransmitter_HandleLTRFrame";
        v20 = 1024;
        v21 = 3790;
        v22 = 1024;
        v23 = a3;
        v24 = 1024;
        v25 = v9;
        _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Adding new LTR from encoder timestamp=%d token=%d", (uint8_t *)&v16, 0x28u);
      }
    }
    else if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      v15 = *(_DWORD *)(a2 + 104);
      v16 = 136316162;
      v17 = v6;
      v18 = 2080;
      v19 = "_videoTransmitter_HandleLTRFrame";
      v20 = 1024;
      v21 = 3790;
      v22 = 1024;
      v23 = a3;
      v24 = 1024;
      v25 = v15;
      _os_log_debug_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Adding new LTR from encoder timestamp=%d token=%d", (uint8_t *)&v16, 0x28u);
    }
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 2992));
  v10 = *(_DWORD *)(a1 + 1780);
  if (v10 > 99)
  {
    *(_DWORD *)(a1 + 1780 + 4 * *(int *)(a1 + 1784) + 8) = *(_DWORD *)(a2 + 104);
    *(_DWORD *)(a1 + 1780 + 4 * *(int *)(a1 + 1784) + 408) = a3;
    v13 = *(_DWORD *)(a1 + 1784);
    if (v13 < 99)
      *(_DWORD *)(a1 + 1784) = v13 + 1;
    else
      *(_DWORD *)(a1 + 1784) = 0;
  }
  else
  {
    v11 = *(_DWORD *)(a1 + 1784) + v10;
    if (v11 > 99)
      v11 -= 100;
    v12 = a1 + 1780 + 4 * v11;
    *(_DWORD *)(v12 + 8) = *(_DWORD *)(a2 + 104);
    *(_DWORD *)(v12 + 408) = a3;
    ++*(_DWORD *)(a1 + 1780);
  }
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 2992));
}

uint64_t _VideoTransmitter_GetFramerateForStream(uint64_t a1, uint64_t a2, double *a3, float a4)
{
  uint64_t v6;
  double v7;
  uint64_t result;
  double v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  *a3 = 0.0;
  if (!a1)
    return 2149449730;
  v10 = -1431655766;
  v9 = NAN;
  v6 = *(_QWORD *)(a2 + 8);
  v7 = micro();
  result = SummerLengthPred(v7 - a4, v6, (uint64_t (*)(double, double, double))SummerGreaterThan, &v9, &v10);
  if ((result & 0x80000000) == 0 && v9 >= 0.5)
    *a3 = (double)v10 / v9;
  return result;
}

uint64_t _VideoTransmitter_GenerateKeyFrameNow(uint64_t a1, unsigned __int16 *a2, uint64_t a3, int a4, int a5)
{
  uint64_t v5;
  pthread_mutex_t *v11;
  unsigned int v12;
  BOOL v13;
  int v14;
  uint64_t v16;
  NSObject *v17;
  int v18;
  uint64_t v19;
  NSObject *v20;
  int v21;
  int v22;
  uint64_t v23;
  NSObject *v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  NSObject *v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v34;
  uint64_t v35;
  __int16 v36;
  const char *v37;
  __int16 v38;
  int v39;
  __int16 v40;
  int v41;
  __int16 v42;
  int v43;
  __int16 v44;
  int v45;
  __int16 v46;
  int v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v5 = 2149449730;
  if (!a1)
    return v5;
  v11 = (pthread_mutex_t *)(a1 + 1680);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1680));
  v12 = *(_DWORD *)(a1 + 496);
  v13 = v12 > 5;
  v14 = (1 << v12) & 0x2E;
  if (!v13 && v14 != 0)
    *(_DWORD *)(a1 + 1776) = 1;
  if (*(_DWORD *)(a1 + 4420) && a5 && !*(_DWORD *)(a1 + 1776))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v16 = VRTraceErrorLogLevelToCSTR();
      v17 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v18 = *(_DWORD *)(a1 + 1768);
        v34 = 136315906;
        v35 = v16;
        v36 = 2080;
        v37 = "_VideoTransmitter_GenerateKeyFrameNow";
        v38 = 1024;
        v39 = 3854;
        v40 = 1024;
        v41 = v18;
        _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Current FIR[%u] is not stabilized, ignore.", (uint8_t *)&v34, 0x22u);
      }
    }
    goto LABEL_33;
  }
  if ((_DWORD)a3)
  {
    if (a4)
    {
      *a2 = *(_WORD *)(a1 + 1748);
      a2[1] = *(_WORD *)(a1 + 1750);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v19 = VRTraceErrorLogLevelToCSTR();
        v20 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v21 = *a2;
          v22 = a2[1];
          v34 = 136316162;
          v35 = v19;
          v36 = 2080;
          v37 = "_VideoTransmitter_GenerateKeyFrameNow";
          v38 = 1024;
          v39 = 3866;
          v40 = 1024;
          v41 = v21;
          v42 = 1024;
          v43 = v22;
          _os_log_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d new RTCP feedback message: use %d X %d", (uint8_t *)&v34, 0x28u);
        }
      }
      goto LABEL_18;
    }
    if ((int)a3 < 2 || *(int *)(a1 + 1744) < 2)
    {
LABEL_33:
      pthread_mutex_unlock(v11);
      return 2149449745;
    }
    if (!a2 || *(unsigned __int16 *)(a1 + 1748) == *a2 && *(unsigned __int16 *)(a1 + 1750) == a2[1])
      goto LABEL_18;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v27 = VRTraceErrorLogLevelToCSTR();
      v28 = *MEMORY[0x1E0CF2758];
      a3 = 0;
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        goto LABEL_18;
      v29 = *(unsigned __int16 *)(a1 + 1748);
      v30 = *(unsigned __int16 *)(a1 + 1750);
      v31 = *a2;
      v32 = a2[1];
      v34 = 136316674;
      v35 = v27;
      v36 = 2080;
      v37 = "_VideoTransmitter_GenerateKeyFrameNow";
      v38 = 1024;
      v39 = 3875;
      v40 = 1024;
      v41 = v29;
      v42 = 1024;
      v43 = v30;
      v44 = 1024;
      v45 = v31;
      v46 = 1024;
      v47 = v32;
      _os_log_impl(&dword_1D8A54000, v28, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VideoTransmitter_GenerateKeyFrameNow: sizes don't match (%ux%u != %ux%u), request an IDR.", (uint8_t *)&v34, 0x34u);
    }
    a3 = 0;
  }
LABEL_18:
  ++*(_DWORD *)(a1 + 1768);
  *(_DWORD *)(a1 + 1776) = 0;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v23 = VRTraceErrorLogLevelToCSTR();
    v24 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v25 = *(_DWORD *)(a1 + 1768);
      v34 = 136315906;
      v35 = v23;
      v36 = 2080;
      v37 = "_VideoTransmitter_GenerateKeyFrameNow";
      v38 = 1024;
      v39 = 3885;
      v40 = 1024;
      v41 = v25;
      _os_log_impl(&dword_1D8A54000, v24, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VideoTransmitter_GenerateKeyFrameNow counter[%u].", (uint8_t *)&v34, 0x22u);
    }
  }
  pthread_mutex_unlock(v11);
  v26 = *(_QWORD *)(a1 + 1632);
  if (v26 == 0xFFFFFFFFLL)
    return 2148007957;
  else
    return (*(uint64_t (**)(uint64_t, unsigned __int16 *, uint64_t))(*(_QWORD *)(a1 + 1616) + 40))(v26, a2, a3);
}

uint64_t VideoTransmitter_EnqueueBuffer(uint64_t a1, CMSampleBufferRef sbuf, uint64_t a3, __int128 *a4, int a5, unsigned int a6, double a7)
{
  const opaqueCMFormatDescription *FormatDescription;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __CVBuffer *ImageBuffer;
  int Height;
  int Width;
  CFTypeRef v22;
  BOOL v23;
  int v24;
  _BOOL4 v25;
  uint64_t v26;
  NSObject *v27;
  char *v28;
  __int128 v29;
  const __CFNumber *v30;
  const __CFNumber *v31;
  __CVBuffer *pixelBuffer;
  uint64_t valuePtr;
  int v34;
  CMTime buf;
  int v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  FormatDescription = CMSampleBufferGetFormatDescription(sbuf);
  if (FormatDescription && CMFormatDescriptionGetMediaType(FormatDescription) == 1835365473)
    return _VideoTransmitter_HandleUncompressedVideo(a1, sbuf, a3, a5, a6, a7);
  v16 = CheckInHandleDebug();
  if (!v16)
    return 2149449730;
  v17 = v16;
  v18 = _VideoTransmitter_DequeueEncoderError(v16);
  if ((v18 & 0x80000000) == 0)
  {
    ImageBuffer = CMSampleBufferGetImageBuffer(sbuf);
    Height = CVPixelBufferGetHeight(ImageBuffer);
    pixelBuffer = ImageBuffer;
    Width = CVPixelBufferGetWidth(ImageBuffer);
    ++*(_DWORD *)(v17 + 17780);
    v22 = CMGetAttachment(sbuf, (CFStringRef)*MEMORY[0x1E0CED620], 0);
    if (v22)
      ++*(_DWORD *)(v17 + 17808);
    *(_BYTE *)(v17 + 16516) = v22 != 0;
    v23 = *(_DWORD *)(v17 + 68) == Height && *(_DWORD *)(v17 + 64) == Width
       || *(_DWORD *)(v17 + 80) == Height && *(_DWORD *)(v17 + 76) == Width;
    v24 = *(_DWORD *)(v17 + 496);
    if (v24 != 4 && v24 != 1)
      goto LABEL_20;
    if (*(_DWORD *)(v17 + 260))
      v23 = 1;
    if (!v23)
      v25 = *(_DWORD *)(v17 + 92) < 10;
    else
LABEL_20:
      v25 = 0;
    if (*(_BYTE *)(v17 + 17760))
    {
      if (v25)
      {
        ++*(_DWORD *)(v17 + 92);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VideoTransmitter_EnqueueBuffer_cold_1();
        }
      }
      else
      {
        v28 = (char *)VCMemoryPool_Alloc(*(OSQueueHead **)(v17 + 17744));
        if (sbuf)
          CFRetain(sbuf);
        *(_QWORD *)v28 = sbuf;
        *((_DWORD *)v28 + 2) = a3;
        *((double *)v28 + 2) = a7;
        v29 = *a4;
        *((_QWORD *)v28 + 5) = *((_QWORD *)a4 + 2);
        *(_OWORD *)(v28 + 24) = v29;
        *((_DWORD *)v28 + 12) = a5;
        v28[52] = a6;
        v30 = (const __CFNumber *)CMGetAttachment(sbuf, CFSTR("ioSurfaceID"), 0);
        v31 = (const __CFNumber *)CMGetAttachment(sbuf, CFSTR("ioSurfaceTimestamp"), 0);
        v34 = -1431655766;
        valuePtr = 0;
        _VideoTransmitter_ExtractIOSurfaceID(&v34, v30, pixelBuffer);
        if (v31)
          CFNumberGetValue(v31, kCFNumberSInt64Type, &valuePtr);
        buf = *(CMTime *)a4;
        CMTimeGetSeconds(&buf);
        kdebug_trace();
        v18 = VCSimpleQueueEnqueue(*(_QWORD *)(v17 + 17504), (uint64_t)v28);
        if ((v18 & 0x80000000) != 0)
        {
          if (*(_QWORD *)v28)
          {
            CFRelease(*(CFTypeRef *)v28);
            *(_QWORD *)v28 = 0;
          }
          VCMemoryPool_Free(*(OSQueueHead **)(v17 + 17744), v28);
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VideoTransmitter_EnqueueBuffer_cold_2();
          }
        }
        else
        {
          ++*(_DWORD *)(v17 + 17784);
          dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v17 + 17496));
        }
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v26 = VRTraceErrorLogLevelToCSTR();
      v27 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.value) = 136315650;
        *(CMTimeValue *)((char *)&buf.value + 4) = v26;
        LOWORD(buf.flags) = 2080;
        *(_QWORD *)((char *)&buf.flags + 2) = "VideoTransmitter_EnqueueBuffer";
        HIWORD(buf.epoch) = 1024;
        v36 = 3951;
        _os_log_impl(&dword_1D8A54000, v27, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d CMBufferQueueEnqueue failed. Encoder thread is not running yet.", (uint8_t *)&buf, 0x1Cu);
      }
    }
  }
  CheckOutHandleDebug();
  return v18;
}

uint64_t _VideoTransmitter_HandleUncompressedVideo(uint64_t a1, opaqueCMSampleBuffer *a2, uint64_t a3, int a4, unsigned int a5, double a6)
{
  uint64_t v12;
  uint64_t v13;
  float Seconds;
  double v15;
  int v16;
  const __CFNumber *v17;
  const __CFNumber *v18;
  int v19;
  uint64_t v20;
  const __CFNumber *v21;
  double v22;
  uint64_t updated;
  unsigned int v24;
  uint64_t v25;
  int v26;
  unsigned int *v27;
  int v28;
  unsigned int v29;
  uint64_t v30;
  _DWORD *v31;
  int v32;
  uint64_t v33;
  NSObject *v34;
  _QWORD block[8];
  CMTime v37;
  uint64_t v38;
  CMTime v39;
  uint64_t v40;
  int valuePtr;
  CMTime v42;
  int v43;
  int v44;
  _BYTE time[28];
  int v46;
  uint64_t v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v43 = 0;
  v44 = -1431655766;
  v12 = CheckInHandleDebug();
  if (v12)
  {
    v13 = v12;
    memset(&v42, 170, sizeof(v42));
    CMSampleBufferGetPresentationTimeStamp(&v42, a2);
    *(CMTime *)time = v42;
    Seconds = CMTimeGetSeconds((CMTime *)time);
    v15 = Seconds;
    v16 = _VideoTransmitter_CalculateVideoTimestamp(v13, a3, a6, Seconds);
    _VideoTransmitter_UpdateAVHostTimeStats(v13, a6, v15);
    valuePtr = 0;
    v40 = 0;
    v17 = (const __CFNumber *)CMGetAttachment(a2, CFSTR("ioSurfaceID"), 0);
    v18 = (const __CFNumber *)CMGetAttachment(a2, CFSTR("ioSurfaceTimestamp"), 0);
    v19 = 0;
    v20 = 0;
    if (v17)
    {
      v21 = v18;
      if (v18)
      {
        CFNumberGetValue(v17, kCFNumberSInt32Type, &valuePtr);
        CFNumberGetValue(v21, kCFNumberSInt64Type, &v40);
        v19 = valuePtr;
        v20 = v40;
      }
    }
    v39 = v42;
    v38 = 0x3FF0000000000000;
    v22 = micro();
    updated = _VideoTransmitter_UpdateRateControlStatus(v13, (unsigned int *)&v44, (unsigned int *)&v43, &v38);
    if ((updated & 0x80000000) != 0)
    {
      v30 = updated;
    }
    else
    {
      v24 = v44;
      *(_DWORD *)(v13 + 4376) = v44;
      ++*(_DWORD *)(v13 + 17780);
      if (*(_BYTE *)(v13 + 18104))
      {
        v25 = *(unsigned int *)(v13 + 1600);
        if ((_DWORD)v25)
        {
          v26 = v25 - 1;
          v27 = (unsigned int *)(v13 + 628);
          v28 = -1;
          while (1)
          {
            v29 = *v27;
            v27 += 30;
            if (v29 > v24)
              break;
            ++v28;
            if (!--v25)
            {
              v28 = v26;
              break;
            }
          }
        }
        else
        {
          v28 = -1;
        }
        *(_DWORD *)time = 0;
        _VideoTransmitter_GetStreamIndexFromAttachment(a2, time);
        if (*(int *)time > v28)
          goto LABEL_21;
      }
      v31 = VCMemoryPool_Alloc(*(OSQueueHead **)(v13 + 17728));
      v32 = *(_DWORD *)(v13 + 256);
      v37 = v42;
      *(CMTime *)&time[4] = v39;
      *(_DWORD *)time = v19;
      v46 = -1431655766;
      v47 = v20;
      v33 = _VideoTransmitter_PrepareAndSetupEncodingArgs(v13, (uint64_t)v31, v32, 0, a5, v16, a4, (__int128 *)&v37.value, v22, v44, v43, (__int128 *)time, 0);
      if ((v33 & 0x80000000) == 0)
      {
        if (!*(_BYTE *)(v13 + 18208))
        {
          if (a2)
            CFRetain(a2);
          v34 = *(NSObject **)(v13 + 17720);
          block[0] = MEMORY[0x1E0C809B0];
          block[1] = 0x40000000;
          block[2] = ___VideoTransmitter_HandleUncompressedVideo_block_invoke;
          block[3] = &__block_descriptor_tmp_39;
          block[4] = v13;
          block[5] = v31;
          block[6] = a2;
          block[7] = a1;
          dispatch_async(v34, block);
          return 0;
        }
        _VideoTransmitter_TransmitFrame(v13, (uint64_t)v31, a2);
        _VideoTransmitter_ProcessEncoderArgs(v13, v31);
LABEL_21:
        CheckOutHandleDebug();
        return 0;
      }
      v30 = v33;
      VCMemoryPool_Free(*(OSQueueHead **)(v13 + 17728), v31);
    }
    CheckOutHandleDebug();
  }
  else
  {
    v30 = 2149449730;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VideoTransmitter_HandleUncompressedVideo_cold_1();
    }
  }
  return v30;
}

__IOSurface *_VideoTransmitter_ExtractIOSurfaceID(_DWORD *valuePtr, CFNumberRef number, CVPixelBufferRef pixelBuffer)
{
  __IOSurface *result;

  if (number)
    return (__IOSurface *)CFNumberGetValue(number, kCFNumberSInt32Type, valuePtr);
  result = CVPixelBufferGetIOSurface(pixelBuffer);
  if (result)
    result = (__IOSurface *)IOSurfaceGetID(result);
  *valuePtr = (_DWORD)result;
  return result;
}

void VideoTransmitter_EncoderProc(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  _BYTE *v5;
  uint64_t v6;
  NSObject *v7;
  opaqueCMSampleBuffer **v8;
  opaqueCMSampleBuffer **v9;
  opaqueCMSampleBuffer *v10;
  const __CFNumber *v11;
  const __CFNumber *v12;
  __CVBuffer *ImageBuffer;
  int v14;
  uint64_t v15;
  uint64_t v16;
  double v17;
  int v18;
  unsigned int v19;
  int v20;
  uint64_t v21;
  NSObject *v22;
  NSObject *v23;
  os_signpost_id_t value;
  NSObject *v25;
  CMTime v26;
  __int128 v27;
  opaqueCMSampleBuffer *v28;
  uint64_t valuePtr;
  int v30;
  CMTime v31;
  _BYTE buf[28];
  _BYTE v33[12];
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
LABEL_6:
    *a3 = 1;
    return;
  }
  v5 = (_BYTE *)(a1 + 17488);
  *(_BYTE *)(a1 + 17760) = 1;
  ++*(_DWORD *)(a1 + 17796);
  dispatch_semaphore_wait(*(dispatch_semaphore_t *)(a1 + 17496), 0xFFFFFFFFFFFFFFFFLL);
  if (*v5)
  {
    *v5 = 0;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v6 = VRTraceErrorLogLevelToCSTR();
      v7 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = v6;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "VideoTransmitter_EncoderProc";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 4005;
        *(_WORD *)v33 = 2080;
        *(_QWORD *)&v33[2] = "com.apple.avconference.videotransmitter.encoderproc";
        _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Encoder thread \"%s\" terminated", buf, 0x26u);
      }
    }
    goto LABEL_6;
  }
  v8 = (opaqueCMSampleBuffer **)VCSimpleQueueDequeue(*(_QWORD *)(a1 + 17504));
  if (v8)
  {
    v9 = v8;
    v10 = *v8;
    if (*v8)
    {
      memset(&v31, 170, sizeof(v31));
      CMSampleBufferGetPresentationTimeStamp(&v31, v10);
      if (*MEMORY[0x1E0CF2760])
      {
        value = v31.value;
        if ((unint64_t)(v31.value - 1) <= 0xFFFFFFFFFFFFFFFDLL)
        {
          v25 = *MEMORY[0x1E0CF2758];
          if (os_signpost_enabled((os_log_t)*MEMORY[0x1E0CF2758]))
          {
            *(_WORD *)buf = 0;
            _os_signpost_emit_with_name_impl(&dword_1D8A54000, v25, OS_SIGNPOST_EVENT, value, "VideoTransmitter_FrameDequeue", (const char *)&unk_1D91A2482, buf, 2u);
          }
        }
      }
      v30 = 0;
      valuePtr = 0;
      v11 = (const __CFNumber *)CMGetAttachment(v10, CFSTR("ioSurfaceID"), 0);
      v12 = (const __CFNumber *)CMGetAttachment(v10, CFSTR("ioSurfaceTimestamp"), 0);
      ImageBuffer = CMSampleBufferGetImageBuffer(v10);
      _VideoTransmitter_ExtractIOSurfaceID(&v30, v11, ImageBuffer);
      if (v12)
        CFNumberGetValue(v12, kCFNumberSInt64Type, &valuePtr);
      *(_OWORD *)buf = *(_OWORD *)(v9 + 3);
      *(_QWORD *)&buf[16] = v9[5];
      CMTimeGetSeconds((CMTime *)buf);
      kdebug_trace();
      v27 = *(_OWORD *)(v9 + 3);
      v28 = v9[5];
      v14 = v30;
      v15 = valuePtr;
      VideoUtil_PropagateSampleBufferAttachmentsToPixelBuffer(v10, ImageBuffer);
      v16 = *((unsigned int *)v9 + 2);
      v17 = *((double *)v9 + 2);
      v18 = *((_DWORD *)v9 + 12);
      v19 = *((unsigned __int8 *)v9 + 52);
      v26 = *(CMTime *)((_BYTE *)v9 + 1);
      *(_DWORD *)buf = v14;
      *(_OWORD *)&buf[4] = v27;
      *(_QWORD *)&buf[20] = v28;
      *(_DWORD *)v33 = -1431655766;
      *(_QWORD *)&v33[4] = v15;
      v20 = _VideoTransmitter_EncodeVideo(a1, ImageBuffer, v16, &v26, v18, v19, (uint64_t)buf, v17);
      if (*v9)
      {
        CFRelease(*v9);
        *v9 = 0;
      }
      _VideoTransmitter_EnqueueEncoderError(a1, v20);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoTransmitter_EncoderProc_cold_2();
    }
    VCMemoryPool_Free(*(OSQueueHead **)(a1 + 17744), v9);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v21 = VRTraceErrorLogLevelToCSTR();
    v22 = *MEMORY[0x1E0CF2758];
    v23 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = v21;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "VideoTransmitter_EncoderProc";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 4049;
        _os_log_impl(&dword_1D8A54000, v22, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Dequeued buffer was nil!", buf, 0x1Cu);
      }
    }
    else if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
    {
      VideoTransmitter_EncoderProc_cold_1();
    }
  }
}

VCMediaControlInfoFaceTimeAudio *_VideoTransmitter_SetStandardControlInfo(uint64_t a1, char *a2, int a3)
{
  VCMediaControlInfoFaceTimeAudio *ControlInfo;
  int v4;
  uint64_t v6;
  _QWORD v8[2];

  ControlInfo = 0;
  v8[1] = *MEMORY[0x1E0C80C00];
  v4 = *a2;
  if (v4 < 0 && a3)
  {
    v8[0] = 0xAAAAAAAAAAAAAAAALL;
    VCCVOExtensionUtils_FillCVOExtension(v4, *(_DWORD *)(a1 + 18224), (uint64_t)v8);
    v6 = *(_QWORD *)(a1 + 1648);
    if (v6)
      ControlInfo = VCMediaControlInfoGeneratorCreateControlInfo(v6);
    else
      ControlInfo = 0;
    VCMediaControlInfoSetInfo(ControlInfo, (const char *)9, (uint64_t)v8, 8);
  }
  return ControlInfo;
}

VCMediaControlInfoFaceTimeAudio *_VideoTransmitter_SetControlInfo(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, _DWORD *a5, unsigned __int8 *a6, char a7, int a8)
{
  VCMediaControlInfoFaceTimeAudio *ControlInfo;
  VCMediaControlInfoFaceTimeAudio *v18;
  int v19;
  int v20;
  NSObject *v21;
  int v22;
  uint64_t v23;
  int v24;
  int v25;
  int v26;
  int v27;
  uint64_t v28;
  NSObject *v29;
  uint64_t v30;
  uint8_t buf[36];
  int v32;
  __int128 v33;
  uint64_t v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  if (!*(_QWORD *)(a1 + 1648))
    return 0;
  if (VCMediaControlInfoGeneratorGetType() == 2)
    return _VideoTransmitter_SetStandardControlInfo(a1, a3, a8);
  ControlInfo = VCMediaControlInfoGeneratorCreateControlInfo(*(_QWORD *)(a1 + 1648));
  v18 = ControlInfo;
  if (ControlInfo)
  {
    v19 = *(unsigned __int16 *)(a1 + 16496);
    v20 = *(unsigned __int16 *)(a1 + 16500);
    if (VCMediaControlInfoGetVersion(ControlInfo) == 2)
    {
      LOWORD(v33) = v19;
      WORD1(v33) = v20;
      VCMediaControlInfoSetInfo(v18, (const char *)6, (uint64_t)&v33, 4);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v28 = VRTraceErrorLogLevelToCSTR();
        v21 = *MEMORY[0x1E0CF2758];
        v29 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136316162;
            *(_QWORD *)&buf[4] = v28;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VideoTransmitter_SetFrameExtensionData";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 1938;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = v20;
            *(_WORD *)&buf[34] = 1024;
            v32 = v19;
            _os_log_impl(&dword_1D8A54000, v29, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Media Control Info - frameExtensionData frameSequenceNumber=%d totalPacketsPerFrame=%d", buf, 0x28u);
            if (!a5)
              goto LABEL_17;
LABEL_13:
            v22 = *(_DWORD *)(a1 + 4428);
            *(_QWORD *)&v33 = 0;
            memset(buf, 0, sizeof(buf));
            if (!*a5)
              goto LABEL_21;
            FECHeader_PackHeaderToBuffer(a5, v22, buf, 0x24uLL, &v33);
            v23 = v33;
            if (!(_QWORD)v33)
              goto LABEL_21;
LABEL_20:
            VCMediaControlInfoSetInfo(v18, (const char *)7, (uint64_t)buf, v23);
LABEL_21:
            if (a4 && *(_BYTE *)(a4 + 2))
            {
              *(_DWORD *)buf = 0;
              VCMediaControlInfoSetInfo(v18, (const char *)8, (uint64_t)buf, 4);
            }
            pthread_mutex_lock((pthread_mutex_t *)(a1 + 4272));
            v24 = *(_DWORD *)(a1 + 3056);
            v25 = v24 - 1;
            if (v24 >= 1)
            {
              v26 = *(_DWORD *)(a1 + 3060) + v24;
              if (v26 <= 100)
                v27 = -1;
              else
                v27 = -101;
              *(_DWORD *)buf = bswap32(*(_DWORD *)(a1 + 3056 + 4 * (v27 + v26) + 408));
              *(_DWORD *)(a1 + 3056) = v25;
              VCMediaControlInfoSetInfo(v18, (const char *)5, (uint64_t)buf, 4);
            }
            pthread_mutex_unlock((pthread_mutex_t *)(a1 + 4272));
            VCMediaControlInfoSetInfo(v18, (const char *)3, (uint64_t)a3, 1);
            VCMediaControlInfoSetInfo(v18, (const char *)4, a2, 4);
            if ((a7 & 1) != 0
              || (VCMediaControlInfoHasInfo(v18, (const char *)5) & 1) != 0
              || (VCMediaControlInfoHasInfo(v18, (const char *)6) & 1) != 0
              || (VCMediaControlInfoHasInfo(v18, (const char *)7) & 1) != 0
              || (VCMediaControlInfoHasInfo(v18, (const char *)8) & 1) != 0)
            {
              return v18;
            }
            VCMediaControlInfoDispose((uint64_t)v18);
            return 0;
          }
        }
        else if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136316162;
          *(_QWORD *)&buf[4] = v28;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VideoTransmitter_SetFrameExtensionData";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 1938;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = v20;
          *(_WORD *)&buf[34] = 1024;
          v32 = v19;
          _os_log_debug_impl(&dword_1D8A54000, v29, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Media Control Info - frameExtensionData frameSequenceNumber=%d totalPacketsPerFrame=%d", buf, 0x28u);
          if (a5)
            goto LABEL_13;
          goto LABEL_17;
        }
      }
    }
    if (a5)
      goto LABEL_13;
LABEL_17:
    if (!a6)
      goto LABEL_21;
    v30 = 0;
    memset(buf, 0, sizeof(buf));
    if ((~*a6 & 3) == 0)
      goto LABEL_21;
    v33 = *(_OWORD *)a6;
    v34 = *((_QWORD *)a6 + 2);
    VCFECHeader_WriteToBuffer((unsigned __int8 *)&v33, buf, 0x24uLL, &v30);
    v23 = v30;
    if (!v30)
      goto LABEL_21;
    goto LABEL_20;
  }
  return v18;
}

_DWORD *_VideoTransmitter_FillLegacyFECHeader@<X0>(_DWORD *result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, uint64_t a5@<X8>)
{
  int v5;
  _BOOL4 v6;
  _BOOL4 v7;
  int v8;
  int v9;
  int v10;

  *(_OWORD *)(a5 + 40) = 0u;
  *(_OWORD *)(a5 + 24) = 0u;
  *(_OWORD *)(a5 + 8) = 0u;
  v5 = result[1106];
  if (v5)
    v6 = *(_DWORD *)(a3 + 32) == 0;
  else
    v6 = 1;
  v7 = v5 != 0;
  v8 = result[1107];
  *(_DWORD *)(a5 + 48) = 1;
  *(_DWORD *)a5 = v7;
  *(_DWORD *)(a5 + 4) = 1;
  if (*(_BYTE *)a3)
  {
    *(_DWORD *)(a5 + 8) = (v8 == 1) << 30;
  }
  else
  {
    if (v8 == 1)
      v9 = 1077936128;
    else
      v9 = 0x800000;
    *(_DWORD *)(a5 + 8) = v9;
    if (*(int *)(a2 + 8) <= 1)
      *(_DWORD *)a5 = 0;
    if (((v6 | a4 ^ 1) & 1) == 0)
      *(_DWORD *)(a5 + 48) = *(_DWORD *)(a3 + 24) + 1;
  }
  if (a4)
    v10 = *(_DWORD *)(a3 + 24) + 1;
  else
    v10 = 0;
  result[4148] += v10;
  return result;
}

__n128 _VideoTransmitter_PostProcessFECPacket@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, unsigned __int8 *a4@<X3>, OpaqueCMBlockBuffer *a5@<X4>, int a6@<W5>, unsigned __int32 a7@<W6>, __n128 *a8@<X8>)
{
  __int16 v15;
  unsigned int v16;
  BOOL v17;
  BOOL v18;
  BOOL v19;
  unsigned __int32 DataLength;
  int v21;
  uint64_t v22;
  __n128 result;
  unsigned __int8 v25;
  char *dataPointerOut[2];

  dataPointerOut[1] = *(char **)MEMORY[0x1E0C80C00];
  v15 = *((_WORD *)a4 + 1);
  v16 = v15 & 0x1000;
  if ((v15 & 0x1000) != 0)
  {
    v17 = 0;
  }
  else
  {
    v17 = VCFECGenerator_GetNumberOutputMediaPackets(*(_QWORD *)(a1 + 18160)) == 0;
    v15 = *((_WORD *)a4 + 1);
  }
  v18 = 1;
  if ((v15 & 0x80) == 0 && (a7 & 1) == 0)
    v18 = (~*a4 & 3) == 0;
  v19 = v17 && v18;
  if (v16)
    v19 = 0;
  v25 = v19;
  if (a7)
    a7 = FECUtil_ParityGroupTransmissionCountForFECLevel(a6);
  DataLength = CMBlockBufferGetDataLength(a5);
  if (a3 | v16)
  {
    dataPointerOut[0] = 0;
    CMBlockBufferGetDataPointer(a5, 0, 0, 0, dataPointerOut);
    LOBYTE(v21) = 0;
    if (v16)
      goto LABEL_23;
  }
  else
  {
    if (*(_DWORD *)(a2 + 24))
      LOBYTE(v21) = 1;
    else
      v21 = (*(unsigned __int8 *)(a2 + 44) >> 1) & 1;
    dataPointerOut[0] = 0;
    CMBlockBufferGetDataPointer(a5, 0, 0, 0, dataPointerOut);
  }
  v22 = *(_QWORD *)(a2 + 160);
  if (*(_BYTE *)(v22 + 1))
  {
    if (*(_BYTE *)(a1 + 16824))
      Throttling_VideoTransmitter_SetPerPktProbeSeqState(v22, a3, *(_DWORD *)(*(_QWORD *)(a1 + 280) + 4 * a3));
    else
      *(_BYTE *)(v22 + 2) = 1;
  }
  *(_BYTE *)(a2 + 48) &= ~4u;
LABEL_23:
  result.n128_u64[0] = 0xAAAAAAAAAAAAAAAALL;
  result.n128_u64[1] = 0xAAAAAAAAAAAAAAAALL;
  *a8 = result;
  a8[1] = result;
  a8[2].n128_u64[0] = 0xAAAAAAAAAAAAAAAALL;
  a8->n128_u8[0] = v16 >> 12;
  a8->n128_u32[1] = 0;
  a8->n128_u32[2] = DataLength;
  a8[1].n128_u64[0] = (unint64_t)dataPointerOut[0];
  a8[1].n128_u32[2] = a7;
  a8[1].n128_u8[12] = (a3 | v16) == 0;
  a8[1].n128_u8[13] = v25;
  a8[2].n128_u32[0] = a6;
  a8[2].n128_u8[4] = v21;
  return result;
}

uint64_t _VideoTransmitter_TransmitOneVideoPacketWithFECv2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5, int a6, char a7, int a8)
{
  uint64_t v10;
  char v11;
  __int16 **v12;
  __int16 *v13;
  __int128 v14;
  uint64_t v15;
  char v16;
  __int16 v17;
  int v18;
  int v19;
  _BOOL4 v20;
  uint64_t v21;
  int v22;
  int v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;
  int v27;
  int v28;
  int v29;
  double v30;
  void *v31;
  signed int v32;
  const void *v33;
  unsigned __int8 v34;
  int v35;
  int v36;
  unsigned __int8 v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  uint64_t v45;
  NSObject *v46;
  uint64_t v47;
  uint64_t v48;
  NSObject *v49;
  uint64_t v55;
  uint64_t v57;
  _BYTE buf[64];
  __int128 v60;
  __int128 v61[2];
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  if (!a6)
  {
    v11 = *(_BYTE *)(a2 + 88);
LABEL_7:
    v12 = (__int16 **)(a2 + 80);
    goto LABEL_8;
  }
  v10 = 88;
  if (!*(_BYTE *)(a1 + 18184))
    v10 = 104;
  v11 = *(_BYTE *)(a2 + v10);
  if (*(_BYTE *)(a1 + 18184))
    goto LABEL_7;
  v12 = (__int16 **)(a2 + 96);
LABEL_8:
  v13 = *v12;
  *(_QWORD *)&v14 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v68 = v14;
  v69 = v14;
  v66 = v14;
  v67 = v14;
  v65 = v14;
  v55 = a3;
  v15 = *(_QWORD *)(a1 + 1640);
  v16 = *(_BYTE *)(a2 + 89);
  v17 = *(_WORD *)(a2 + 174);
  v18 = *(unsigned __int8 *)(a2 + 172);
  v19 = *(unsigned __int8 *)(a3 + 36);
  v57 = a1 + 16512;
  v20 = *(_DWORD *)(a1 + 17372) == 20;
  v21 = *(_QWORD *)(a2 + 160);
  v22 = *(unsigned __int8 *)(v21 + 1);
  v23 = *(unsigned __int8 *)(v21 + 24);
  _VideoTransmitter_SetupIDSChannelDataFormat(v15, v16, v13, v11, v17, v18, v19, v20, (uint64_t)&v65, *(_BYTE *)(v21 + 1), *(_BYTE *)(v21 + 24));
  if ((int)a5[12] < 2 || *(_BYTE *)(v57 + 1672))
  {
    v62 = v67;
    v63 = v68;
    v64 = v69;
    v25 = v65;
    v24 = v66;
  }
  else
  {
    _VideoTransmitter_SetupIDSChannelDataFormat(v15, v16, *(__int16 **)(a2 + 96), *(_BYTE *)(a2 + 104), v17, v18 != 0, v19 != 0, v20, (uint64_t)buf, v22 != 0, v23 != 0);
    v62 = *(_OWORD *)&buf[32];
    v63 = *(_OWORD *)&buf[48];
    v64 = v60;
    v25 = *(_OWORD *)buf;
    v24 = *(_OWORD *)&buf[16];
  }
  v61[0] = v25;
  v61[1] = v24;
  v26 = **(_QWORD **)a2;
  v27 = *(_DWORD *)(a1 + 16);
  v28 = *(unsigned __int8 *)(v55 + 29);
  v29 = *(_DWORD *)(a2 + 12);
  v30 = *(double *)(a2 + 16);
  v31 = *(void **)(v55 + 16);
  v32 = *(_DWORD *)(v55 + 8);
  v33 = *(const void **)(a2 + 32);
  v34 = *(_BYTE *)(a2 + 40);
  v35 = *(unsigned __int8 *)(v55 + 28);
  v36 = *(_DWORD *)(a2 + 44);
  v37 = *(_BYTE *)(a2 + 48);
  v38 = *(_DWORD *)(a2 + 52);
  v39 = *(_DWORD *)(a1 + 1768);
  v40 = *(_DWORD *)(a2 + 24);
  if ((v27 - 100) > 0x19)
    goto LABEL_17;
  v41 = *(_DWORD *)v57;
  v42 = 1 << (v27 - 100);
  if ((v42 & 0x3000400) == 0)
  {
    if ((v42 & 0x800001) != 0)
    {
      v43 = RTPSendH264Packet(v26, v27, 1u, v28, v29, v31, v32, (_DWORD *)(v55 + 4), v30, v33, v34, v35, v36, v37, a5, v38, v21, v39, a4,
              (uint64_t)&v65,
              v61,
              v40 != 0,
              v41);
      goto LABEL_18;
    }
LABEL_17:
    v43 = RTPSendH263Packet(v26, v27, 0, *(_DWORD *)(a2 + 168), v40 == 0, v28, v29, a7, v30, 0, v31, v32, (_DWORD *)(v55 + 4), v33, v34, v35, v36, v37, a5,
            v38,
            v21,
            v39,
            a4,
            0,
            0);
    goto LABEL_18;
  }
  v43 = RTPSendUncompressedVideoPacket(v26, v27, v28, v29, v31, v32, (_DWORD *)(v55 + 4), v33, v30, v34, v35, v36, v37, a5, v38, v21, v39, a4, (uint64_t)&v65,
          v61,
          v40 != 0,
          v41);
LABEL_18:
  v44 = v43;
  if (v43 < 0 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v45 = VRTraceErrorLogLevelToCSTR();
    v46 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136316674;
      *(_QWORD *)&buf[4] = v45;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "_VideoTransmitter_TransmitOneVideoPacketWithFECv2";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 4495;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 4495;
      *(_WORD *)&buf[34] = 2048;
      *(_QWORD *)&buf[36] = v44;
      *(_WORD *)&buf[44] = 1024;
      *(_DWORD *)&buf[46] = a8;
      *(_WORD *)&buf[50] = 1024;
      *(_DWORD *)&buf[52] = a6;
      _os_log_error_impl(&dword_1D8A54000, v46, OS_LOG_TYPE_ERROR, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/VideoTransmitter.c:%d: VideoTransmitter_TransmitOneFrame failed! result=%08lX i=%d isParity=%d\n", buf, 0x38u);
    }
  }
  if (*(_BYTE *)(v57 + 252) && *(_QWORD *)(a1 + 16768))
    _VideoTransmitter_LogPacket(a1, *(_QWORD *)(v55 + 16), *(_DWORD *)(v55 + 8), *(_DWORD *)(a2 + 12), a5, 0);
  v47 = 2147549204;
  if (v44 != -2147418092)
    return 0;
  if (*(_QWORD *)(a1 + 1632) != 0xFFFFFFFFLL)
    (*(void (**)(void))(*(_QWORD *)(a1 + 1616) + 48))();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v48 = VRTraceErrorLogLevelToCSTR();
    v49 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136316674;
      *(_QWORD *)&buf[4] = v48;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "_VideoTransmitter_TransmitOneVideoPacketWithFECv2";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 4504;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 4504;
      *(_WORD *)&buf[34] = 2048;
      *(_QWORD *)&buf[36] = -2147418092;
      *(_WORD *)&buf[44] = 1024;
      *(_DWORD *)&buf[46] = a8;
      *(_WORD *)&buf[50] = 1024;
      *(_DWORD *)&buf[52] = a6;
      _os_log_error_impl(&dword_1D8A54000, v49, OS_LOG_TYPE_ERROR, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/VideoTransmitter.c:%d: VideoTransmitter_TransmitOneFrame failed (RTP_E_RESTART) result=%08lX i=%d  isParity=%d\n", buf, 0x38u);
    }
  }
  return v47;
}

uint64_t _VideoTransmitter_SetupIDSChannelDataFormat@<X0>(uint64_t result@<X0>, char a2@<W1>, __int16 *a3@<X2>, char a4@<W3>, __int16 a5@<W4>, char a6@<W5>, char a7@<W6>, int a8@<W7>, uint64_t a9@<X8>, char a10, char a11)
{
  *(_OWORD *)(a9 + 48) = 0u;
  *(_OWORD *)(a9 + 64) = 0u;
  *(_OWORD *)(a9 + 16) = 0u;
  *(_OWORD *)(a9 + 32) = 0u;
  *(_OWORD *)a9 = 0u;
  if (result)
  {
    *(_BYTE *)(a9 + 30) = 1;
    *(_QWORD *)(a9 + 32) = result;
  }
  else
  {
    *(_BYTE *)(a9 + 24) = a4;
    result = __memcpy_chk();
  }
  *(_BYTE *)(a9 + 41) = 1;
  *(_BYTE *)(a9 + 28) = a2;
  *(_BYTE *)(a9 + 56) = a7;
  *(_BYTE *)(a9 + 72) = a6;
  if ((a6 & 1) == 0)
    a5 = *a3;
  *(_WORD *)(a9 + 74) = a5;
  *(_BYTE *)(a9 + 77) = a8 == 20;
  if (a10)
  {
    *(_BYTE *)(a9 + 25) = 1;
    *(_BYTE *)(a9 + 78) = a11;
  }
  return result;
}

uint64_t _VideoTransmitter_LogPacket(uint64_t result, uint64_t a2, int a3, int a4, _DWORD *a5, int a6)
{
  FILE *v6;
  __int128 v9;
  int v10;
  uint64_t v11;
  char v12[16];
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  int v18;
  char v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  _BYTE v37[27];
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v6 = *(FILE **)(result + 16768);
  if (v6)
  {
    *(_QWORD *)&v9 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&v37[11] = v9;
    v36 = v9;
    *(_OWORD *)v37 = v9;
    v35 = v9;
    v34 = v9;
    v33 = v9;
    v32 = v9;
    v31 = v9;
    v30 = v9;
    v29 = v9;
    v28 = v9;
    v27 = v9;
    v26 = v9;
    v25 = v9;
    v24 = v9;
    v23 = v9;
    v22 = v9;
    v21 = v9;
    v20 = v9;
    v18 = -1431655766;
    v16 = v9;
    v17 = v9;
    v14 = v9;
    v15 = v9;
    *(_OWORD *)v12 = v9;
    v13 = v9;
    v19 = 0;
    if (a5)
    {
      v10 = a5[2];
      if (!*a5)
        v10 = 0;
    }
    else
    {
      v10 = 0;
    }
    result = fprintf(v6, "[%08X:%d:%d:%08X]\n", a4, a6, a3, v10);
    if (a3 >= 1)
    {
      v11 = 0;
      do
      {
        __sprintf_chk(v12, 0, 0x64uLL, " %02X", *(unsigned __int8 *)(a2 + v11));
        result = __strlcat_chk();
        if ((~(_BYTE)v11 & 0x1F) == 0)
        {
          result = fprintf(v6, "%s\n", &v19);
          v19 = 0;
        }
        ++v11;
      }
      while (a3 != v11);
      if ((a3 & 0x1F) != 0)
        return fprintf(v6, "%s\n", &v19);
    }
  }
  return result;
}

uint64_t _VideoTransmitter_TransmitVideoPacketsWithFecVersion2(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unsigned int v5;
  _BOOL4 v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  size_t v13;
  OSStatus v14;
  BOOL v15;
  OSStatus v16;
  uint64_t v17;
  NSObject *v18;
  int v19;
  int v20;
  uint64_t v21;
  NSObject *v22;
  unsigned int v23;
  int NumberOutputMediaPackets;
  int NumberOutputPackets;
  int ErrorLogLevelForModule;
  _BYTE *v27;
  uint64_t v28;
  NSObject *v29;
  NSObject *v30;
  int v31;
  int v32;
  int v33;
  unsigned int *v34;
  unsigned int *v35;
  int v36;
  int v37;
  __n128 v38;
  int v39;
  VCMediaControlInfoFaceTimeAudio *v40;
  __int128 v41;
  int v42;
  uint64_t v43;
  unsigned int v44;
  float v45;
  BOOL v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  unsigned __int32 v50;
  int v51;
  unsigned int v52;
  int v53;
  unsigned int v54;
  uint64_t v55;
  unsigned int v56;
  unsigned int v57;
  unsigned int v58;
  uint64_t v59;
  uint64_t v60;
  NSObject *v61;
  int v62;
  _BOOL4 v63;
  int v64;
  uint64_t v65;
  NSObject *v66;
  int v67;
  int v68;
  uint64_t v69;
  NSObject *v70;
  uint64_t v71;
  NSObject *v72;
  NSObject *v73;
  int v74;
  int v76;
  int v77;
  int v78;
  uint64_t v79;
  uint64_t v80;
  _BOOL4 v81;
  uint64_t v82;
  int v83;
  unsigned int v84;
  __n128 v85;
  __n128 v86;
  unint64_t v87;
  CFTypeRef cf;
  _BYTE destinationBuffer[44];
  __int16 v90;
  uint64_t v91;
  _BYTE buf[56];
  _QWORD v93[6];

  v93[3] = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)a2;
  *(_QWORD *)(v4 + 64) = 0;
  *(_QWORD *)(v4 + 72) = 0;
  v5 = *(_DWORD *)(a1 + 4432);
  v7 = *(_DWORD *)(a2 + 8) == 1 && v5 > 2;
  v81 = v7;
  v83 = *(_DWORD *)(a2 + 8);
  if (v7)
  {
    v8 = FECUtil_ParityGroupTransmissionCountForFECLevel(v5);
    v84 = 0;
    v9 = *(_DWORD *)(a2 + 8);
  }
  else
  {
    v84 = v5;
    v8 = 0;
    v9 = *(_DWORD *)(a2 + 8);
  }
  if (v9 >= 1)
  {
    v10 = 0;
    v11 = 0;
    v82 = *(_QWORD *)(a2 + 64);
    v12 = 4 * v9;
    do
    {
      *(_QWORD *)destinationBuffer = 0;
      v13 = *(int *)(*(_QWORD *)(a1 + 280) + v10);
      v14 = CMBlockBufferCreateWithMemoryBlock(*(CFAllocatorRef *)(a1 + 18176), 0, 0x76CuLL, *(CFAllocatorRef *)(a1 + 18168), 0, 0, v13, 1u, (CMBlockBufferRef *)destinationBuffer);
      if (v14)
        v15 = 1;
      else
        v15 = *(_QWORD *)destinationBuffer == 0;
      if (v15)
      {
        v16 = v14;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v17 = VRTraceErrorLogLevelToCSTR();
          v18 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136316162;
            *(_QWORD *)&buf[4] = v17;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = "_VideoTransmitter_PushPacketsAndEncodeWithFECVersion2";
            *(_WORD *)&buf[22] = 1024;
            *(_DWORD *)&buf[24] = 4350;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = v16;
            *(_WORD *)&buf[34] = 2048;
            *(_QWORD *)&buf[36] = *(_QWORD *)destinationBuffer;
            _os_log_error_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_ERROR, " [%s] %s:%d _VideoTransmitter_TransmitVideoPacketsInGroups Buffer Allocation failed! status=%d inputBlockPacket=%p", buf, 0x2Cu);
          }
        }
      }
      else
      {
        CMBlockBufferReplaceDataBytes((const void *)(v82 + v11), *(CMBlockBufferRef *)destinationBuffer, 0, v13);
        v19 = VCFECGenerator_PushPacket(*(_QWORD *)(a1 + 18160), *(const void **)destinationBuffer);
        if (v19 < 0)
        {
          v20 = v19;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            v21 = VRTraceErrorLogLevelToCSTR();
            v22 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136315906;
              *(_QWORD *)&buf[4] = v21;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = "_VideoTransmitter_PushPacketsAndEncodeWithFECVersion2";
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = 4345;
              *(_WORD *)&buf[28] = 1024;
              *(_DWORD *)&buf[30] = v20;
              _os_log_error_impl(&dword_1D8A54000, v22, OS_LOG_TYPE_ERROR, " [%s] %s:%d VCFECGenerator_PushPacket failed! resultFECGenerator=%d", buf, 0x22u);
            }
          }
        }
        if (*(_QWORD *)destinationBuffer)
          CFRelease(*(CFTypeRef *)destinationBuffer);
        v11 += v13;
      }
      v10 += 4;
    }
    while (v12 != v10);
  }
  v23 = FECUtil_FECLevelofProtectionToFECPercentage(v84);
  if ((VCFECGenerator_SetFixedFECLevel(*(_QWORD *)(a1 + 18160), v23) & 0x80000000) != 0
    && (int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VideoTransmitter_TransmitVideoPacketsWithFecVersion2_cold_2();
  }
  VCFECGenerator_PerformAction(*(_QWORD *)(a1 + 18160), 2);
  NumberOutputMediaPackets = VCFECGenerator_GetNumberOutputMediaPackets(*(_QWORD *)(a1 + 18160));
  NumberOutputPackets = VCFECGenerator_GetNumberOutputPackets(*(_QWORD *)(a1 + 18160));
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  v27 = (_BYTE *)MEMORY[0x1E0CF2748];
  if (ErrorLogLevelForModule >= 8)
  {
    v28 = VRTraceErrorLogLevelToCSTR();
    v29 = *MEMORY[0x1E0CF2758];
    v30 = *MEMORY[0x1E0CF2758];
    if (*v27)
    {
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        v31 = *(_DWORD *)(a2 + 8);
        *(_DWORD *)buf = 136316418;
        *(_QWORD *)&buf[4] = v28;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VideoTransmitter_TransmitVideoPacketsWithFecVersion2";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 4524;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v31;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = NumberOutputPackets;
        *(_WORD *)&buf[40] = 1024;
        *(_DWORD *)&buf[42] = NumberOutputMediaPackets;
        _os_log_impl(&dword_1D8A54000, v29, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCFECGenerator Pulling Packets [start] params.numPackets=%d numOutputPackets=%d numOutputMediaPackets=%d", buf, 0x2Eu);
      }
    }
    else if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
    {
      v76 = *(_DWORD *)(a2 + 8);
      *(_DWORD *)buf = 136316418;
      *(_QWORD *)&buf[4] = v28;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "_VideoTransmitter_TransmitVideoPacketsWithFecVersion2";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 4524;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = v76;
      *(_WORD *)&buf[34] = 1024;
      *(_DWORD *)&buf[36] = NumberOutputPackets;
      *(_WORD *)&buf[40] = 1024;
      *(_DWORD *)&buf[42] = NumberOutputMediaPackets;
      _os_log_debug_impl(&dword_1D8A54000, v29, OS_LOG_TYPE_DEBUG, " [%s] %s:%d VCFECGenerator Pulling Packets [start] params.numPackets=%d numOutputPackets=%d numOutputMediaPackets=%d", buf, 0x2Eu);
    }
  }
  v32 = v83;
  if (NumberOutputPackets >= 1)
  {
    v33 = 0;
    v79 = 0;
    v34 = (unsigned int *)(a1 + 4416);
    v35 = (unsigned int *)(a1 + 4436);
    v78 = NumberOutputPackets;
    while (1)
    {
      cf = 0;
      memset(v93, 0, 24);
      if ((VCFECGenerator_PopPacket(*(_QWORD *)(a1 + 18160), &cf, (uint64_t)v93) & 0x80000000) != 0)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() < 3)
          goto LABEL_91;
        VRTraceErrorLogLevelToCSTR();
        v63 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
        v27 = (_BYTE *)MEMORY[0x1E0CF2748];
        v62 = HIDWORD(v79);
        if (v63)
          _VideoTransmitter_TransmitVideoPacketsWithFecVersion2_cold_1();
        goto LABEL_90;
      }
      v36 = (unsigned __int16)(WORD1(v93[0]) & 0x1000) >> 12;
      v37 = v79;
      if ((v93[0] & 0x10000000) == 0)
        v37 = v79 + 1;
      v87 = 0xAAAAAAAAAAAAAAAALL;
      v38.n128_u64[0] = 0xAAAAAAAAAAAAAAAALL;
      v38.n128_u64[1] = 0xAAAAAAAAAAAAAAAALL;
      v85 = v38;
      v86 = v38;
      LODWORD(v79) = v37;
      HIDWORD(v79) += v36;
      v39 = v37 - 1;
      _VideoTransmitter_PostProcessFECPacket(a1, a2, v37 - 1, (unsigned __int8 *)v93, (OpaqueCMBlockBuffer *)cf, v84, v32 == 1, &v85);
      v80 = v39;
      while (1)
      {
        v40 = _VideoTransmitter_SetControlInfo(a1, a2 + 44, (char *)(a2 + 48), *(_QWORD *)(a2 + 160), 0, (unsigned __int8 *)v93, v86.n128_i8[12], v86.n128_u8[13]);
        *(_QWORD *)&buf[48] = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v41 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v41 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)&buf[16] = v41;
        *(_OWORD *)&buf[32] = v41;
        *(_OWORD *)buf = v41;
        *(__n128 *)destinationBuffer = v85;
        *(__n128 *)&destinationBuffer[16] = v86;
        *(_QWORD *)&destinationBuffer[32] = v87;
        _VideoTransmitter_FillLegacyFECHeader((_DWORD *)a1, a2, (uint64_t)destinationBuffer, v32 == 1, (uint64_t)buf);
        if ((v36 & 1) != 0)
          LOBYTE(v42) = 0;
        else
          v42 = *(_DWORD *)(*(_QWORD *)(a1 + 288) + 4 * v80);
        v43 = _VideoTransmitter_TransmitOneVideoPacketWithFECv2(a1, a2, (uint64_t)&v85, (uint64_t)v40, buf, v36 & 1, v42, v33);
        v32 = v83;
        if ((v43 & 0x80000000) != 0)
          break;
        v44 = v84;
        if (*(_DWORD *)(a1 + 4428) == 1)
        {
          v45 = (double)(WORD2(v93[0]) & 0x3FF) / 100.0;
          v44 = FECUtil_FECRatioToLevelofProtection(v45);
        }
        if (*(_DWORD *)(a1 + 4424))
          v46 = v83 == 1;
        else
          v46 = 0;
        v47 = v85.n128_u8[0];
        v49 = v85.n128_i32[1];
        v48 = v85.n128_i32[2];
        if (v46)
          v50 = v86.n128_u32[2];
        else
          v50 = 0;
        if (v85.n128_u8[0])
          v51 = 1;
        else
          v51 = v50 + 1;
        **(_DWORD **)(a2 + 72) += v51 * v85.n128_u32[1];
        v52 = v51 * ((v49 - v48) & ~(((int)v49 - (int)v48) >> 31));
        v53 = *(unsigned __int8 *)(a1 + 18184);
        if (*(_BYTE *)(a1 + 18184))
        {
          do
            v54 = __ldxr(v34);
          while (__stxr(v54 + v52, v34));
        }
        v55 = *(_QWORD *)a2;
        *(_QWORD *)(*(_QWORD *)a2 + 72) += v52;
        if (v47)
        {
          LODWORD(v48) = v51 * v48;
          ++*(_DWORD *)(a1 + 16576);
          *(_QWORD *)(a1 + 16584) += (int)v48;
          if (v53)
          {
            do
              v56 = __ldxr(v35);
            while (__stxr(v56 + v48, v35));
            v55 = *(_QWORD *)a2;
          }
          v48 = (int)v48;
          *(_QWORD *)(v55 + 64) += (int)v48;
          v57 = v44;
LABEL_71:
          *(_QWORD *)(a1 + 40 * v57 + 17824) += v48;
          goto LABEL_72;
        }
        *(_QWORD *)(a1 + 296) = *(_QWORD *)(a2 + 152);
        ++*(_DWORD *)(a1 + 16560);
        *(_QWORD *)(a1 + 16568) += v49;
        *(_QWORD *)(a1 + 40 * v44 + 17816) += v48;
        if (v83 == 1)
        {
          v48 = v50 * v48;
          *(_DWORD *)(a1 + 16576) += v50;
          *(_QWORD *)(a1 + 16584) += v48;
          if (v53)
          {
            do
              v58 = __ldxr(v35);
            while (__stxr(v58 + v48, v35));
            v55 = *(_QWORD *)a2;
          }
          v57 = v44;
          *(_QWORD *)(v55 + 64) += v48;
          goto LABEL_71;
        }
LABEL_72:
        v84 = v44;
        if (v81)
        {
          v59 = v8 - (v36 & 1);
          LOBYTE(v36) = 1;
          v85.n128_u8[0] = 1;
        }
        else
        {
          v59 = v8;
        }
        v8 = v59;
        if (!(_DWORD)v59)
          goto LABEL_81;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v60 = VRTraceErrorLogLevelToCSTR();
        v61 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)destinationBuffer = 136316418;
          *(_QWORD *)&destinationBuffer[4] = v60;
          *(_WORD *)&destinationBuffer[12] = 2080;
          *(_QWORD *)&destinationBuffer[14] = "_VideoTransmitter_TransmitVideoPacketsWithFecVersion2";
          *(_WORD *)&destinationBuffer[22] = 1024;
          *(_DWORD *)&destinationBuffer[24] = 4551;
          *(_WORD *)&destinationBuffer[28] = 1024;
          *(_DWORD *)&destinationBuffer[30] = 4551;
          *(_WORD *)&destinationBuffer[34] = 2048;
          *(_QWORD *)&destinationBuffer[36] = a1;
          v90 = 2048;
          v91 = (int)v43;
          _os_log_error_impl(&dword_1D8A54000, v61, OS_LOG_TYPE_ERROR, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/VideoTransmitter.c:%d: VideoTransmitter[%p] Failed to transmit the video packet with FECv2. result=%08lX", destinationBuffer, 0x36u);
        }
      }
      v32 = v83;
LABEL_81:
      if (cf)
        CFRelease(cf);
      if ((v43 & 0x80000000) != 0)
      {
LABEL_92:
        v27 = (_BYTE *)MEMORY[0x1E0CF2748];
        v62 = HIDWORD(v79);
        goto LABEL_93;
      }
      if (++v33 == v78)
      {
LABEL_91:
        v43 = 0;
        goto LABEL_92;
      }
    }
  }
  v62 = 0;
LABEL_90:
  v43 = 0;
LABEL_93:
  v64 = VCFECGenerator_GetNumberOutputPackets(*(_QWORD *)(a1 + 18160));
  if (v64)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v65 = VRTraceErrorLogLevelToCSTR();
      v66 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136316418;
        *(_QWORD *)&buf[4] = v65;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VideoTransmitter_TransmitVideoPacketsWithFecVersion2";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 4575;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = 4575;
        *(_WORD *)&buf[34] = 2048;
        *(_QWORD *)&buf[36] = a1;
        *(_WORD *)&buf[44] = 1024;
        *(_DWORD *)&buf[46] = v64;
        _os_log_impl(&dword_1D8A54000, v66, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/VideoTransmitter.c:%d: VideoTransmitter[%p] VCFECGenerator output packest is not zero, will force a flush numOutputPackets=%d", buf, 0x32u);
      }
    }
    v67 = VCFECGenerator_PerformAction(*(_QWORD *)(a1 + 18160), 1);
    if (v67 < 0)
    {
      v68 = v67;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v69 = VRTraceErrorLogLevelToCSTR();
        v70 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136316418;
          *(_QWORD *)&buf[4] = v69;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VideoTransmitter_TransmitVideoPacketsWithFecVersion2";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 4578;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = 4578;
          *(_WORD *)&buf[34] = 2048;
          *(_QWORD *)&buf[36] = a1;
          *(_WORD *)&buf[44] = 2048;
          *(_QWORD *)&buf[46] = v68;
          _os_log_error_impl(&dword_1D8A54000, v70, OS_LOG_TYPE_ERROR, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/VideoTransmitter.c:%d: VideoTransmitter[%p] VCFECGenerator flush failed result=%08lX", buf, 0x36u);
        }
      }
    }
  }
  SummerAdd((double)*(unint64_t *)(*(_QWORD *)a2 + 72), *(double *)(a2 + 152));
  SummerAdd((double)*(unint64_t *)(*(_QWORD *)a2 + 64), *(double *)(a2 + 152));
  if (v62)
    ++*(_DWORD *)(a1 + 40 * v84 + 17832);
  else
    ++*(_DWORD *)(a1 + 17804);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v71 = VRTraceErrorLogLevelToCSTR();
    v72 = *MEMORY[0x1E0CF2758];
    v73 = *MEMORY[0x1E0CF2758];
    if (*v27)
    {
      if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
      {
        v74 = *(_DWORD *)(a2 + 8);
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)&buf[4] = v71;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VideoTransmitter_TransmitVideoPacketsWithFecVersion2";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 4590;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v74;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = v64;
        _os_log_impl(&dword_1D8A54000, v72, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCFECGenerator Pulling Packets [stop] params.numPackets=%d numOutputPackets=%d", buf, 0x28u);
      }
    }
    else if (os_log_type_enabled(v73, OS_LOG_TYPE_DEBUG))
    {
      v77 = *(_DWORD *)(a2 + 8);
      *(_DWORD *)buf = 136316162;
      *(_QWORD *)&buf[4] = v71;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "_VideoTransmitter_TransmitVideoPacketsWithFecVersion2";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 4590;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = v77;
      *(_WORD *)&buf[34] = 1024;
      *(_DWORD *)&buf[36] = v64;
      _os_log_debug_impl(&dword_1D8A54000, v72, OS_LOG_TYPE_DEBUG, " [%s] %s:%d VCFECGenerator Pulling Packets [stop] params.numPackets=%d numOutputPackets=%d", buf, 0x28u);
    }
  }
  return v43;
}

uint64_t _VideoTransmitter_TransmitVideoPacketsInGroups(uint64_t a1, uint64_t *a2, int a3, int a4, int a5, const void *a6, unsigned __int8 a7, int a8, double a9, double a10, unsigned __int8 a11, int a12, unsigned int a13, unsigned int a14, __int128 a15, __int16 *a16, char a17, char a18, __int16 *a19, char a20,unsigned __int8 *a21,char a22,__int16 a23)
{
  int v24;
  uint64_t v28;
  uint64_t v29;
  int v30;
  int v31;
  BOOL v32;
  char v33;
  unint64_t v34;
  __int128 v35;
  int v37;
  int v38;
  _BOOL4 v39;
  uint64_t v40;
  NSObject *v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  _BOOL4 v46;
  __int16 *v47;
  char v48;
  uint64_t v49;
  NSObject *v50;
  NSObject *v51;
  int v52;
  char v53;
  uint64_t v54;
  int v55;
  uint64_t v56;
  int v57;
  _BOOL4 v58;
  _BOOL4 v60;
  int v61;
  int v62;
  VCMediaControlInfoFaceTimeAudio *v63;
  int v64;
  char v65;
  __int128 v66;
  uint64_t v67;
  int v68;
  signed int v69;
  int v70;
  int v71;
  int v72;
  int v73;
  const void *v74;
  int v75;
  int v76;
  int v77;
  int v78;
  uint64_t v79;
  int v80;
  int v81;
  BOOL v82;
  int v83;
  int RealNumParity;
  uint64_t v85;
  uint64_t v86;
  char *v87;
  __int16 v88;
  VCMediaControlInfoFaceTimeAudio *v89;
  __int128 v90;
  uint64_t v91;
  signed int v92;
  int v93;
  int v94;
  int v95;
  int v96;
  uint64_t v97;
  NSObject *v98;
  int v99;
  int v100;
  int v101;
  unsigned int v102;
  unsigned int v103;
  unsigned int *v104;
  unsigned int *v105;
  uint64_t v106;
  int v107;
  char v109;
  int v110;
  int v111;
  int v112;
  int v113;
  signed int v114;
  uint64_t v115;
  int v116;
  const void *v117;
  char *v118;
  uint64_t v120;
  char v121;
  __int16 *v122;
  uint64_t v124;
  uint64_t v127;
  _QWORD v128[3];
  int v129;
  int v130;
  unsigned __int8 v131;
  int v132;
  _BYTE buf[48];
  __int128 v134;
  __int128 v135;
  __int16 *v136;
  char v137;
  char v138;
  int v139;
  __int16 v140;
  __int16 *v141;
  char v142;
  unint64_t v143;
  __int128 v144;
  _BYTE v145[23];
  double v146;
  _QWORD *v147;
  int v148;
  char v149;
  char v150;
  __int16 v151;
  __int128 v152;
  _OWORD v153[2];
  _DWORD v154[12];
  uint64_t v155;
  _QWORD v156[3];
  int v157;
  uint64_t v158;

  v24 = a3;
  v158 = *MEMORY[0x1E0C80C00];
  v28 = a1 + 17372;
  v29 = a1 + 16498;
  v155 = 0;
  memset(v154, 0, sizeof(v154));
  if (*(_DWORD *)(a1 + 24) == 176)
    v30 = 2;
  else
    v30 = 3;
  v110 = v30;
  memset(v128, 0, sizeof(v128));
  v129 = 0;
  Throttling_VideoTransmitter_CalcThrottlingRate(*(unsigned __int8 *)(a1 + 16824), *(_DWORD *)(a1 + 4376), *(_DWORD *)(a1 + 32), a13 != 0, a3, *(_QWORD *)(a1 + 280), a14, (uint64_t)v128);
  v31 = *(_DWORD *)(a1 + 496);
  if (v31 == 1)
  {
    LOBYTE(v129) = *(_BYTE *)(v29 + 328);
  }
  else if (v31 == 2)
  {
    v32 = v24 <= 1 || *(_BYTE *)(v29 + 327) == 0;
    v33 = !v32;
    BYTE1(v128[0]) = v33;
  }
  if (*(_BYTE *)(v28 + 780))
  {
    v34 = ((unint64_t)*a21 << 56) | 0xAAAAAAAAAAAAAALL;
    v35 = *(_OWORD *)(a21 + 17);
    v152 = *(_OWORD *)(a21 + 1);
    v153[0] = v35;
    *(_QWORD *)((char *)v153 + 15) = *((_QWORD *)a21 + 4);
    *(_QWORD *)buf = a2;
    *(_DWORD *)&buf[8] = v24;
    *(_DWORD *)&buf[12] = a4;
    *(double *)&buf[16] = a9;
    *(_DWORD *)&buf[24] = a5;
    *(_DWORD *)&buf[28] = -1431655766;
    *(_QWORD *)&buf[32] = a6;
    buf[40] = a7;
    *(_WORD *)&buf[41] = -21846;
    buf[43] = -86;
    *(_DWORD *)&buf[44] = a8;
    LOBYTE(v134) = a11;
    *(_WORD *)((char *)&v134 + 1) = -21846;
    BYTE3(v134) = -86;
    *(_QWORD *)((char *)&v134 + 4) = __PAIR64__(a13, a12);
    HIDWORD(v134) = a14;
    v135 = a15;
    v136 = a16;
    v137 = a17;
    v138 = a18;
    v140 = -21846;
    v139 = -1431655766;
    v141 = a19;
    v142 = a20;
    v143 = v34;
    v144 = v152;
    *(_OWORD *)v145 = v153[0];
    *(_QWORD *)&v145[15] = *(_QWORD *)((char *)v153 + 15);
    v146 = a10;
    v147 = v128;
    v148 = v110;
    v149 = a22;
    v150 = -86;
    v151 = a23;
    return _VideoTransmitter_TransmitVideoPacketsWithFecVersion2(a1, (uint64_t)buf);
  }
  v37 = VTU_ComputeTotalNumberOfGroupsPerFrame(v24);
  v38 = v37;
  v117 = a6;
  if (v24 < 9)
  {
    if (v37 < 129)
    {
      v113 = 1;
      goto LABEL_27;
    }
LABEL_22:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      v40 = VRTraceErrorLogLevelToCSTR();
      v41 = *MEMORY[0x1E0CF2758];
      v113 = 0;
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        goto LABEL_27;
      *(_DWORD *)buf = 136316162;
      *(_QWORD *)&buf[4] = v40;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "_VideoTransmitter_TransmitVideoPacketsInGroups";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 4629;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = v38;
      *(_WORD *)&buf[34] = 1024;
      *(_DWORD *)&buf[36] = 128;
      _os_log_impl(&dword_1D8A54000, v41, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d This frame has more groups (%d) than is supported (%d). It will be sent without FEC!", buf, 0x28u);
    }
    v113 = 0;
LABEL_27:
    if (v24 < 1)
      return 0;
    goto LABEL_28;
  }
  v39 = *(_DWORD *)(a1 + 4440) != 1;
  if (v37 >= 129)
    v39 = 0;
  v113 = v39;
  if (v37 >= 129)
    goto LABEL_22;
LABEL_28:
  v42 = 0;
  v109 = a5 == 0;
  v105 = (unsigned int *)(a1 + 4436);
  v104 = (unsigned int *)(a1 + 4416);
  v106 = 0;
  v43 = a1 + 16444;
  v124 = v28;
  do
  {
    if (v24 == 9)
      LODWORD(v44) = 5;
    else
      LODWORD(v44) = 8;
    if (v24 >= 8)
      v44 = v44;
    else
      v44 = v24;
    v120 = v44;
    v45 = v24 - v44;
    v46 = v45 < 1;
    v114 = *(_DWORD *)(a1 + 4432);
    v152 = 0u;
    v153[0] = 0u;
    memset(v156, 0, sizeof(v156));
    v157 = 0;
    v47 = a16;
    if (!*(_BYTE *)(v28 + 812))
      v47 = a19;
    v122 = v47;
    v48 = a17;
    if (!*(_BYTE *)(v28 + 812))
      v48 = a20;
    v121 = v48;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v49 = VRTraceErrorLogLevelToCSTR();
      v50 = *MEMORY[0x1E0CF2758];
      v51 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316418;
          *(_QWORD *)&buf[4] = v49;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VideoTransmitter_TransmitVideoPacketsOneGroup";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 4299;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = v106;
          *(_WORD *)&buf[34] = 1024;
          *(_DWORD *)&buf[36] = v120;
          *(_WORD *)&buf[40] = 1024;
          *(_DWORD *)&buf[42] = v114;
          _os_log_impl(&dword_1D8A54000, v50, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d FEC Group iGroupID=%d iNumPacketsInGroup=%d fecLevelOfProtection=%d", buf, 0x2Eu);
        }
      }
      else if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136316418;
        *(_QWORD *)&buf[4] = v49;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VideoTransmitter_TransmitVideoPacketsOneGroup";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 4299;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v106;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = v120;
        *(_WORD *)&buf[40] = 1024;
        *(_DWORD *)&buf[42] = v114;
        _os_log_debug_impl(&dword_1D8A54000, v50, OS_LOG_TYPE_DEBUG, " [%s] %s:%d FEC Group iGroupID=%d iNumPacketsInGroup=%d fecLevelOfProtection=%d", buf, 0x2Eu);
      }
    }
    v107 = v45;
    v52 = *(_DWORD *)(a1 + 4424);
    v53 = v113 ^ 1;
    if (!v52)
      v53 = 1;
    LODWORD(v54) = v114;
    if ((v53 & 1) == 0)
    {
      FECUtil_SetupFECHeader(*(_DWORD *)(a1 + 4428), a1 + 4428, *(_QWORD *)(a1 + 280), v154, v120, v114, a15 + SHIDWORD(v106), v42, v46, SHIWORD(v46), v106, (uint64_t)&v152, (uint64_t)v156);
      v52 = *(_DWORD *)(a1 + 4424);
    }
    v127 = 0;
    v55 = 0;
    v56 = 0;
    v112 = 0;
    v132 = a8;
    v131 = a11;
    v130 = -1431655766;
    v111 = v42;
    v115 = 4 * v42;
    v118 = (char *)(a15 + SHIDWORD(v106));
    while (1)
    {
      v57 = v111 | v56;
      v58 = (v111 | v56) == 0;
      v60 = v107 < 1 && (_DWORD)v120 - 1 == v56;
      v32 = v52 == 0;
      v61 = v113;
      if (v32)
        v61 = 0;
      if ((int)v54 >= 1)
      {
        if (v61)
        {
          v154[2] = *((_DWORD *)&v153[-1] + v56);
          LODWORD(v155) = 1;
          if ((_DWORD)v120 == 1)
          {
            v112 = FECUtil_ParityGroupTransmissionCountForFECLevel(v54);
            LODWORD(v155) = v155 + v112;
          }
        }
      }
      if ((_DWORD)v120 == 1)
        v62 = v112 + 1;
      else
        v62 = 0;
      *(_DWORD *)(v29 + 94) += v62;
      if (BYTE1(v128[0]))
      {
        if (*(_BYTE *)(v29 + 326))
          Throttling_VideoTransmitter_SetPerPktProbeSeqState((uint64_t)v128, v111 + v56, *(_DWORD *)(*(_QWORD *)(a1 + 280) + v115 + 4 * v56));
        else
          BYTE2(v128[0]) = 1;
      }
      v131 &= ~4u;
      v63 = _VideoTransmitter_SetControlInfo(a1, (uint64_t)&v132, (char *)&v131, (uint64_t)v128, v154, 0, v57 == 0, v60);
      v64 = v132;
      if (v57)
        v65 = 0;
      else
        v65 = (a5 | v132 & 2) != 0;
      *(_QWORD *)&v66 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v66 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v134 = v66;
      v135 = v66;
      *(_OWORD *)&buf[16] = v66;
      *(_OWORD *)&buf[32] = v66;
      *(_OWORD *)buf = v66;
      _VideoTransmitter_SetupIDSChannelDataFormat(*(_QWORD *)(a1 + 1640), a18, a16, a17, a23, a22, v65, *(_DWORD *)v124, (uint64_t)buf, SBYTE1(v128[0]), v129);
      v67 = *a2;
      v68 = *(_DWORD *)(a1 + 16);
      v69 = *(_DWORD *)(*(_QWORD *)(a1 + 280) + v115 + 4 * v56);
      v70 = *(_DWORD *)(a1 + 1768);
      if ((v68 - 100) > 0x19)
      {
LABEL_77:
        v77 = v60;
        v74 = v117;
        v75 = RTPSendH263Packet(v67, v68, 0, v110, v109, v77, a4, *(_BYTE *)(*(_QWORD *)(a1 + 288) + v115 + 4 * v56), a9, 0, v118, v69, &v130, v117, a7, v58, v64, v131, v154,
                a12,
                (uint64_t)v128,
                v70,
                (uint64_t)v63,
                0,
                0);
        goto LABEL_78;
      }
      v71 = *(_DWORD *)(v29 + 14);
      v72 = 1 << (v68 - 100);
      if ((v72 & 0x3000400) != 0)
      {
        v73 = v60;
        v74 = v117;
        v75 = RTPSendUncompressedVideoPacket(v67, v68, v73, a4, v118, v69, &v130, v117, a9, a7, v58, v64, v131, v154, a12, (uint64_t)v128, v70, (uint64_t)v63, (uint64_t)buf,
                0,
                a5 != 0,
                v71);
      }
      else
      {
        if ((v72 & 0x800001) == 0)
          goto LABEL_77;
        v76 = v60;
        v74 = v117;
        v75 = RTPSendH264Packet(v67, v68, 1u, v76, a4, v118, v69, &v130, a9, v117, a7, v58, v64, v131, v154, a12, (uint64_t)v128, v70, (uint64_t)v63,
                (uint64_t)buf,
                0,
                a5 != 0,
                v71);
      }
LABEL_78:
      v78 = v75;
      ++*(_DWORD *)(v29 + 62);
      *(_QWORD *)(a1 + 16568) += v130;
      v54 = v114;
      if (*(_BYTE *)(v29 + 266) && *(_QWORD *)(a1 + 16768))
        _VideoTransmitter_LogPacket(a1, (uint64_t)v118, *(_DWORD *)(*(_QWORD *)(a1 + 280) + v115 + 4 * v56), a4, v154, v120);
      if (v78 == -2147418092)
        break;
      *(double *)(a1 + 296) = micro();
      v79 = *(int *)(*(_QWORD *)(a1 + 280) + v115 + 4 * v56);
      HIDWORD(v127) += v130;
      v80 = v130 - v79;
      v55 += v80 & ~(v80 >> 31);
      v52 = *(_DWORD *)(a1 + 4424);
      if ((_DWORD)v120 == 1 && v114 >= 1 && v52)
      {
        HIDWORD(v127) += v130 * v112;
        v55 += v80 * v112;
        LODWORD(v127) = v79 * v112;
      }
      v118 += v79;
      if (v120 == ++v56)
        goto LABEL_90;
    }
    if (*(_QWORD *)(a1 + 1632) != 0xFFFFFFFFLL)
      (*(void (**)(void))(*(_QWORD *)(a1 + 1616) + 48))();
LABEL_90:
    v116 = FECUtil_ParityGroupTransmissionCountForFECLevel(v114);
    if (v116 >= 1)
    {
      v81 = 0;
      while (1)
      {
        v132 = a8;
        v131 = a11;
        v130 = 0;
        v82 = (int)v54 <= 0 || *(_DWORD *)(a1 + 4424) == 0;
        v83 = v113;
        if (v82)
          v83 = 0;
        if (v83 == 1)
        {
          RealNumParity = FECUtil_GetRealNumParity(v120, v54);
          if (RealNumParity >= 1)
            break;
        }
LABEL_116:
        ++v81;
        v54 = v114;
        if (v81 == v116)
          goto LABEL_117;
      }
      v85 = 0;
      v86 = RealNumParity;
      v87 = (char *)(a1 + 4444);
      while (2)
      {
        if (*(int *)(v43 + 4 * v85) > 0)
        {
          v154[2] = *((_DWORD *)v156 + v85);
          WORD2(v155) = *(_WORD *)(v43 + 2 * v85 + 28);
          v88 = (*(_WORD *)v29)++;
          HIWORD(v155) = v88;
          v89 = _VideoTransmitter_SetControlInfo(a1, (uint64_t)&v132, (char *)&v131, (uint64_t)v128, v154, 0, 0, 0);
          *(_QWORD *)&v90 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v90 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v134 = v90;
          v135 = v90;
          *(_OWORD *)&buf[16] = v90;
          *(_OWORD *)&buf[32] = v90;
          *(_OWORD *)buf = v90;
          _VideoTransmitter_SetupIDSChannelDataFormat(*(_QWORD *)(a1 + 1640), a18, v122, v121, a23, a22, 0, *(_DWORD *)v124, (uint64_t)buf, SBYTE1(v128[0]), v129);
          v91 = *a2;
          v92 = *(_DWORD *)(v43 + 4 * v85);
          v93 = *(_DWORD *)(a1 + 16);
          v94 = *(_DWORD *)(a1 + 1768);
          if ((v93 - 100) <= 0x19)
          {
            v95 = *(_DWORD *)(v29 + 14);
            v96 = 1 << (v93 - 100);
            if ((v96 & 0x3000400) != 0)
            {
              RTPSendUncompressedVideoPacket(v91, v93, 0, a4, v87, v92, &v130, v74, a9, a7, 0, v132, v131, v154, a12, (uint64_t)v128, v94, (uint64_t)v89, (uint64_t)buf,
                0,
                a5 != 0,
                v95);
LABEL_111:
              ++*(_DWORD *)(v29 + 78);
              v99 = v130;
              *(_QWORD *)(a1 + 16584) += v130;
              if (*(_BYTE *)(v29 + 266) && *(_QWORD *)(a1 + 16768))
              {
                _VideoTransmitter_LogPacket(a1, (uint64_t)v87, *(_DWORD *)(v43 + 4 * v85), a4, v154, v120);
                v99 = v130;
              }
              v100 = *(_DWORD *)(v43 + 4 * v85);
              HIDWORD(v127) += v99;
              v55 += (v99 - v100) & ~((v99 - v100) >> 31);
              LODWORD(v127) = (v100 & ~(v100 >> 31)) + v127;
LABEL_115:
              ++v85;
              v87 += 1500;
              if (v86 == v85)
                goto LABEL_116;
              continue;
            }
            if ((v96 & 0x800001) != 0)
            {
              RTPSendH264Packet(v91, v93, 1u, 0, a4, v87, v92, &v130, a9, v74, a7, 0, v132, v131, v154, a12, (uint64_t)v128, v94, (uint64_t)v89,
                (uint64_t)buf,
                0,
                a5 != 0,
                v95);
              goto LABEL_111;
            }
          }
          RTPSendH263Packet(v91, v93, 0, v110, v109, 0, a4, 0, a9, 0, v87, v92, &v130, v74, a7, 0, v132, v131, v154,
            a12,
            (uint64_t)v128,
            v94,
            (uint64_t)v89,
            0,
            0);
          goto LABEL_111;
        }
        break;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v97 = VRTraceErrorLogLevelToCSTR();
        v98 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v101 = *(_DWORD *)(v43 + 4 * v85);
          *(_DWORD *)buf = 136316162;
          *(_QWORD *)&buf[4] = v97;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "_VideoTransmitter_TransmitParityPackets";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 4244;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = v85;
          *(_WORD *)&buf[34] = 1024;
          *(_DWORD *)&buf[36] = v101;
          _os_log_error_impl(&dword_1D8A54000, v98, OS_LOG_TYPE_ERROR, " [%s] %s:%d Invalid parity size i=%d ParitySizes[i]=%d", buf, 0x28u);
        }
        v74 = v117;
      }
      goto LABEL_115;
    }
LABEL_117:
    **((_DWORD **)&a15 + 1) += HIDWORD(v127);
    v28 = v124;
    if (*(_BYTE *)(v124 + 812))
    {
      do
        v102 = __ldxr(v105);
      while (__stxr(v102 + v127, v105));
      do
        v103 = __ldxr(v104);
      while (__stxr(v103 + v55, v104));
    }
    SummerAdd((double)(int)v127, a10);
    SummerAdd((double)v55, a10);
    HIDWORD(v106) = (_DWORD)v118 - a15;
    v42 = v120 + v111;
    LODWORD(v106) = v106 + 1;
    v24 = v107;
  }
  while (v107 > 0);
  return 0;
}

void _VideoTransmitter_UpdateVideoPriorityScore(uint64_t a1, uint64_t a2, CMSampleBufferRef sbuf)
{
  unsigned __int8 *v6;
  int v7;
  uint64_t v8;
  NSObject *v9;
  int v10;
  unsigned __int8 v11;
  __CVBuffer *ImageBuffer;
  CFNumberRef v13;
  CFNumberRef v14;
  int v15;
  uint64_t v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v6 = *(unsigned __int8 **)(a1 + 16664);
  if ((*(_DWORD *)(a1 + 16656) - 1) > 1)
  {
    if (v6)
    {
      v11 = atomic_load(v6);
      *(_BYTE *)(a2 + 384) = v11;
    }
  }
  else
  {
    v7 = atomic_load(v6);
    if (v7 != *(unsigned __int8 *)(a2 + 384) && (int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v8 = VRTraceErrorLogLevelToCSTR();
      v9 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v10 = *(unsigned __int8 *)(a2 + 384);
        v15 = 136316162;
        v16 = v8;
        v17 = 2080;
        v18 = "_VideoTransmitter_UpdateVideoPriorityScore";
        v19 = 1024;
        v20 = 4817;
        v21 = 2048;
        v22 = a1;
        v23 = 1024;
        v24 = v10;
        _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VideoTransmitter[%p] videoPriority=%u", (uint8_t *)&v15, 0x2Cu);
      }
    }
    atomic_store(*(_BYTE *)(a2 + 384), *(unsigned __int8 **)(a1 + 16664));
  }
  if (*(_BYTE *)(a2 + 384))
  {
    ImageBuffer = CMSampleBufferGetImageBuffer(sbuf);
    v13 = CFNumberCreate(*(CFAllocatorRef *)(a1 + 18304), kCFNumberCharType, (const void *)(a2 + 384));
    if (v13)
    {
      v14 = v13;
      CVBufferSetAttachment(ImageBuffer, CFSTR("FramePriority"), v13, kCVAttachmentMode_ShouldPropagate);
      CFRelease(v14);
    }
  }
}

void _VideoTransmitter_UpdateCompoundStreamIDs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  __int16 v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a2 + 448))
  {
    v6 = *(unsigned __int8 *)(a2 + 354);
    v7 = *(_DWORD *)(a3 + 8);
    v8 = *(unsigned __int8 *)(a1 + 120 * v7 + 626);
    if ((v8 + v6) >= 0xD)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v11 = VRTraceErrorLogLevelToCSTR();
        v12 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v13 = *(unsigned __int8 *)(a2 + 354);
          v14 = *(unsigned __int8 *)(a1 + 120 * *(int *)(a3 + 8) + 626);
          v15 = 136316162;
          v16 = v11;
          v17 = 2080;
          v18 = "_VideoTransmitter_UpdateCompoundStreamIDs";
          v19 = 1024;
          v20 = 4840;
          v21 = 1024;
          v22 = v13;
          v23 = 1024;
          v24 = v14;
          _os_log_error_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_ERROR, " [%s] %s:%d Temporal compounding exceeds channel limitations (main=%d temporal=%d)", (uint8_t *)&v15, 0x28u);
        }
      }
    }
    else
    {
      v9 = a1 + 520;
      memcpy((void *)(a2 + 330 + 2 * v6), (const void *)(a1 + 520 + 120 * v7 + 82), 2 * v8);
      v10 = v9 + 120 * *(int *)(a3 + 8);
      *(_BYTE *)(a2 + 354) += *(_BYTE *)(v10 + 106);
      *(_WORD *)(a2 + 450) = *(_WORD *)(a2 + 330);
      *(_WORD *)(a2 + 330) = *(_WORD *)(v10 + 80);
    }
  }
}

uint64_t _VideoTransmitter_UpdateEncoderArgsAndGetStream(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  int v10;
  int v11;
  int v12;
  __int16 v13;
  uint64_t v14;
  unsigned __int8 *v15;
  uint64_t v16;
  int v17;
  FILE *v18;
  uint64_t i;
  __int128 v20;
  uint64_t j;
  uint64_t v22;
  uint64_t v23;
  unsigned __int16 v24;
  uint64_t v26;
  char v27[16];
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  int v33;
  _BYTE buf[49];
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  _BYTE v49[27];
  unsigned __int8 md[8];
  uint64_t v51;
  int v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  if (*(int *)(a4 + 24) < 1)
    return 0;
  v7 = a1 + 16652;
  ++*(_DWORD *)(a1 + 17792);
  if (*(_DWORD *)(a1 + 16652) != *(_DWORD *)(a2 + 228))
    _VideoTransmitter_SetNewEncoderMode(a1, a2);
  if (!*(_BYTE *)(a2 + 96))
  {
    *(_DWORD *)(v7 + 620) = *(_DWORD *)(a2 + 180);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 2992));
    if (*(int *)(a1 + 1780) >= 1)
      *(_QWORD *)(a1 + 1780) = 0;
    if (*(int *)(a1 + 2588) >= 1)
      *(_DWORD *)(a1 + 2588) = 0;
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 2992));
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v8 = VRTraceErrorLogLevelToCSTR();
      v9 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v10 = *(_DWORD *)a2;
        v11 = *(_DWORD *)(a2 + 4);
        v12 = *(_DWORD *)(a2 + 180);
        *(_DWORD *)buf = 136316418;
        *(_QWORD *)&buf[4] = v8;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "_VideoTransmitter_ResetLTRforKeyFrame";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 3783;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v10;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = v11;
        *(_WORD *)&buf[40] = 1024;
        *(_DWORD *)&buf[42] = v12;
        _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Got a key frame resolution=%dx%d timestamp=%08X, reset LTR.", buf, 0x2Eu);
      }
    }
  }
  if ((*(_BYTE *)(a2 + 100) & 2) != 0 && *(_BYTE *)(a2 + 96))
    _VideoTransmitter_FlushBasebandForRefreshFrame(a1, a2);
  *(_DWORD *)(a1 + 4432) = _VideoTransmitter_GetFECLevelOfProtection(a1, a2);
  if (*(_BYTE *)(v7 + 174)
    && (*(_DWORD *)(v7 + 160) || *(_DWORD *)(v7 + 164))
    && !VCRateControlScheduleProbingSequence(*(void **)(a1 + 1656), *(unsigned int *)(a4 + 24), *(unsigned int *)(a2 + 176), *(unsigned int *)(a2 + 180), 0)&& (int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VideoTransmitter_UpdateEncoderArgsAndGetStream_cold_1();
  }
  _VideoTransmitter_UpdateCompoundStreamIDs(a1, a2, a4);
  if (!*(_BYTE *)(a2 + 96) && *(_BYTE *)(a2 + 381))
  {
    v13 = *(_WORD *)(a2 + 382);
    v14 = *(unsigned __int8 *)(a2 + 354);
    *(_BYTE *)(a2 + 354) = v14 + 1;
    *(_WORD *)(a2 + 2 * v14 + 330) = v13;
  }
  if (*(_BYTE *)(v7 + 124) && *(_QWORD *)(a1 + 16784))
  {
    v26 = v7;
    v15 = *(unsigned __int8 **)(a4 + 16);
    v16 = *(unsigned int *)(a4 + 24);
    v17 = *(_DWORD *)(a2 + 180);
    *(_QWORD *)md = 0;
    v51 = 0;
    v52 = 0;
    CC_SHA1(v15, v16, md);
    v18 = *(FILE **)(a1 + 16784);
    fprintf(v18, "[%08X:%dB SHA1:", v17, v16);
    for (i = 0; i != 20; ++i)
      fprintf(v18, "%02X", md[i]);
    fwrite("]\n", 2uLL, 1uLL, v18);
    *(_QWORD *)&v20 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&v49[11] = v20;
    v48 = v20;
    *(_OWORD *)v49 = v20;
    v47 = v20;
    v46 = v20;
    v45 = v20;
    v44 = v20;
    v43 = v20;
    v42 = v20;
    v41 = v20;
    v40 = v20;
    v39 = v20;
    v38 = v20;
    v37 = v20;
    v36 = v20;
    v35 = v20;
    *(_OWORD *)&buf[33] = v20;
    *(_OWORD *)&buf[17] = v20;
    *(_OWORD *)&buf[1] = v20;
    v33 = -1431655766;
    v31 = v20;
    v32 = v20;
    v29 = v20;
    v30 = v20;
    *(_OWORD *)v27 = v20;
    v28 = v20;
    buf[0] = 0;
    if ((int)v16 >= 1)
    {
      for (j = 0; j != v16; ++j)
      {
        __sprintf_chk(v27, 0, 0x64uLL, " %02X", v15[j]);
        __strlcat_chk();
        if ((~(_BYTE)j & 0x1F) == 0)
        {
          fprintf(v18, "%s\n", buf);
          buf[0] = 0;
        }
      }
      if ((v16 & 0x1F) != 0)
        fprintf(v18, "%s\n", buf);
    }
    v7 = v26;
  }
  v22 = a1 + 120 * *(int *)(a4 + 8);
  v23 = v22 + 520;
  *(_DWORD *)(v22 + 572) = *(_DWORD *)(a4 + 4);
  v24 = *(_WORD *)(v7 + 1442) + *(_WORD *)a4;
  *(_WORD *)(v22 + 568) = v24;
  if ((*(_BYTE *)(a2 + 100) & 1) != 0 && *(_DWORD *)(a2 + 104) != -1)
    _videoTransmitter_HandleLTRFrame(a1, a2, v24);
  return v23;
}

uint64_t _VideoTransmitter_GetFECLevelOfProtection(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  BOOL v6;
  int v7;
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  int v12;
  unsigned int v13;
  int v14;
  unsigned int v16;
  int v17;
  float v18;
  BOOL v19;
  int v20;
  int v21;
  uint64_t v22;
  NSObject *v23;
  unsigned int v24;
  int v25;
  unsigned int v26;
  int v27;
  int v28;
  uint64_t v29;
  __int16 v30;
  const char *v31;
  __int16 v32;
  int v33;
  __int16 v34;
  int v35;
  __int16 v36;
  unsigned int v37;
  __int16 v38;
  int v39;
  __int16 v40;
  int v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v3 = a1 + 16488;
  v4 = atomic_load((unsigned int *)(a1 + 16488));
  if (*(_DWORD *)(a1 + 496) == 1)
  {
    v5 = *(_DWORD *)(a1 + 16) - 110;
    v6 = v5 > 0xF;
    v7 = (1 << v5) & 0xC001;
    if (v6 || v7 == 0)
    {
      if (*(_BYTE *)(a2 + 96))
      {
        if (v4 <= 1)
          v16 = 1;
        else
          v16 = v4;
        if ((*(_BYTE *)(a2 + 100) & 2) != 0)
          v4 = v16;
        else
          v4 = v4;
      }
      else if (v4 <= 3)
      {
        v4 = 3;
      }
      else
      {
        v4 = v4;
      }
      if (!*(_BYTE *)(a1 + 508))
      {
        do
        {
          v17 = *(_DWORD *)(a1 + 32);
          v18 = FECUtil_FECLevelofProtectionToRateRatio(v4);
          v19 = (_DWORD)v4 != 0;
          LODWORD(v4) = v4 - 1;
        }
        while (v19 && (float)((float)v17 / v18) < 77000.0);
        v4 = (v4 + 1);
      }
      if (*(_DWORD *)(a1 + 4432) != (_DWORD)v4)
      {
        v20 = *(_DWORD *)(a1 + 44);
        if (v20 >= 1 && v4 >= 3)
        {
          v21 = (int)((double)(*(_DWORD *)(a1 + 32) / v20) * 0.125);
          if (v21 <= *(unsigned __int16 *)(v3 + 788) && (int)VRTraceGetErrorLogLevelForModule() >= 6)
          {
            v22 = VRTraceErrorLogLevelToCSTR();
            v23 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              v24 = *(unsigned __int16 *)(v3 + 788);
              v28 = 136316418;
              v29 = v22;
              v30 = 2080;
              v31 = "_VideoTransmitter_GetFECLevelOfProtection";
              v32 = 1024;
              v33 = 6039;
              v34 = 1024;
              v35 = v21;
              v36 = 1024;
              v37 = v24;
              v38 = 1024;
              v39 = v4;
              _os_log_impl(&dword_1D8A54000, v23, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Duplicating single packet frames. estimatedFrameSize=%d MTU=%d level=%d", (uint8_t *)&v28, 0x2Eu);
            }
          }
        }
      }
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v9 = VRTraceErrorLogLevelToCSTR();
    v10 = *MEMORY[0x1E0CF2758];
    v11 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        v12 = *(_DWORD *)(a1 + 496);
        v13 = atomic_load((unsigned int *)v3);
        v14 = *(_DWORD *)(a1 + 32);
        v28 = 136316674;
        v29 = v9;
        v30 = 2080;
        v31 = "_VideoTransmitter_GetFECLevelOfProtection";
        v32 = 1024;
        v33 = 6044;
        v34 = 1024;
        v35 = v12;
        v36 = 1024;
        v37 = v13;
        v38 = 1024;
        v39 = v4;
        v40 = 1024;
        v41 = v14;
        _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Fec mode=%d fecLevel=%d fecLevelOfProtection=%d iBitRate=%d", (uint8_t *)&v28, 0x34u);
      }
    }
    else if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      v25 = *(_DWORD *)(a1 + 496);
      v26 = atomic_load((unsigned int *)v3);
      v27 = *(_DWORD *)(a1 + 32);
      v28 = 136316674;
      v29 = v9;
      v30 = 2080;
      v31 = "_VideoTransmitter_GetFECLevelOfProtection";
      v32 = 1024;
      v33 = 6044;
      v34 = 1024;
      v35 = v25;
      v36 = 1024;
      v37 = v26;
      v38 = 1024;
      v39 = v4;
      v40 = 1024;
      v41 = v27;
      _os_log_debug_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Fec mode=%d fecLevel=%d fecLevelOfProtection=%d iBitRate=%d", (uint8_t *)&v28, 0x34u);
    }
  }
  return v4;
}

uint64_t _VideoTransmitter_EncryptFrame(uint64_t a1, uint64_t a2, char **a3, _DWORD *a4, uint64_t a5, int a6, CMBlockBufferRef *a7)
{
  uint64_t v12;
  int DataLength;
  uint64_t v14;
  CMBlockBufferRef theBuffer[2];

  theBuffer[1] = *(CMBlockBufferRef *)MEMORY[0x1E0C80C00];
  theBuffer[0] = 0;
  if (a7)
  {
    if (a2 && *(_QWORD *)(a2 + 112))
    {
      if (CMBlockBufferCreateWithMemoryBlock(*(CFAllocatorRef *)(a1 + 18200), *(void **)(a5 + 16), *(int *)(a5 + 24), (CFAllocatorRef)*MEMORY[0x1E0C9AE20], 0, 0, *(int *)(a5 + 24), 0, theBuffer))
      {
        v14 = 2149449731;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VideoTransmitter_EncryptFrame_cold_5();
        }
      }
      else
      {
        v12 = VCSFrameCryptorH264_Encrypt(*(_QWORD *)(a2 + 112), a6, theBuffer[0], a7);
        if ((_DWORD)v12)
        {
          v14 = v12;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              _VideoTransmitter_EncryptFrame_cold_4();
          }
        }
        else
        {
          DataLength = CMBlockBufferGetDataLength(*a7);
          *a4 = DataLength;
          if (CMBlockBufferIsRangeContiguous(*a7, 0, DataLength))
          {
            if (CMBlockBufferGetDataPointer(*a7, 0, 0, 0, a3))
            {
              v14 = 2149449796;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  _VideoTransmitter_EncryptFrame_cold_3();
              }
            }
            else
            {
              v14 = 0;
            }
          }
          else
          {
            v14 = 2149449796;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                _VideoTransmitter_EncryptFrame_cold_2();
            }
          }
        }
      }
    }
    else
    {
      v14 = 0;
      *a3 = *(char **)(a5 + 16);
      *a4 = *(_DWORD *)(a5 + 24);
    }
  }
  else
  {
    v14 = 2149449729;
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      return v14;
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VideoTransmitter_EncryptFrame_cold_1();
  }
  if (theBuffer[0])
    CFRelease(theBuffer[0]);
  return v14;
}

uint64_t VideoTransmitter_Pause(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  pthread_mutex_t *v5;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149449730;
  v4 = v3;
  v5 = (pthread_mutex_t *)(v3 + 16912);
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 16912));
  *(_DWORD *)(v4 + 256) = a2;
  if (*(_DWORD *)(v4 + 4420))
  {
    RTPSetAFRCVideoPaused(*(_QWORD *)(v4 + 520), *(_DWORD *)(v4 + 16904) | a2);
    VCRateControlPauseVideo(*(void **)(v4 + 1656), (*(_DWORD *)(v4 + 16904) | a2) != 0);
  }
  pthread_mutex_unlock(v5);
  CheckOutHandleDebug();
  return 0;
}

uint64_t VideoTransmitter_GetLastVideoSampleTime(uint64_t a1, _DWORD *a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149449730;
  *a2 = *(_DWORD *)(v3 + 17360);
  CheckOutHandleDebug();
  return 0;
}

uint64_t VideoTransmitter_GetFramerate(float a1, uint64_t a2, double *a3)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t FramerateForStream;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  double v14;
  uint8_t buf[4];
  uint64_t v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  __int16 v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v5 = CheckInHandleDebug();
  if (!v5)
    return 2149449730;
  v6 = v5;
  if (*(_DWORD *)(v5 + 1600))
  {
    v7 = 0;
    v8 = v5 + 520;
    while (1)
    {
      v14 = 0.0;
      FramerateForStream = _VideoTransmitter_GetFramerateForStream(v6, v8, &v14, a1);
      v10 = FramerateForStream;
      if ((FramerateForStream & 0x80000000) != 0)
        break;
      *a3 = v14 + *a3;
      ++v7;
      v8 += 120;
      if (v7 >= *(unsigned int *)(v6 + 1600))
        goto LABEL_14;
    }
    if (((_DWORD)FramerateForStream != -2146238447 || *(_DWORD *)(v6 + 496) != 2)
      && (int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v11 = VRTraceErrorLogLevelToCSTR();
      v12 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136316162;
        v16 = v11;
        v17 = 2080;
        v18 = "VideoTransmitter_GetFramerate";
        v19 = 1024;
        v20 = 5164;
        v21 = 1024;
        v22 = v7;
        v23 = 1024;
        v24 = v10;
        _os_log_error_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_ERROR, " [%s] %s:%d Failed to get framerate for stream[%u] with error %d", buf, 0x28u);
      }
    }
  }
  else
  {
    v10 = 0;
  }
LABEL_14:
  CheckOutHandleDebug();
  return v10;
}

uint64_t VideoTransmitter_GetBitrate(float a1, uint64_t a2, double *a3)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  double v8;
  uint64_t *v9;
  uint64_t v10;
  double v11;
  uint64_t v12;
  double v14;
  double v15[2];

  v15[1] = *(double *)MEMORY[0x1E0C80C00];
  v5 = CheckInHandleDebug();
  if (!v5)
    return 2149449730;
  v6 = v5;
  v15[0] = NAN;
  *a3 = 0.0;
  if (*(_DWORD *)(v5 + 1600))
  {
    v7 = 0;
    v8 = a1;
    v9 = (uint64_t *)(v5 + 528);
    do
    {
      v14 = 0.0;
      v10 = *v9;
      v11 = micro();
      v12 = SummerSumPred(v11 - v8, 0.0, v10, (unsigned int (*)(double, double, double))SummerGreaterThan, (double (*)(double, double, double))SummerIdentity, v15, &v14);
      if ((v12 & 0x80000000) == 0 && v15[0] >= 0.5)
        *a3 = *a3 + v14 * 8.0 / v15[0];
      ++v7;
      v9 += 15;
    }
    while (v7 < *(unsigned int *)(v6 + 1600));
  }
  else
  {
    v12 = 0;
  }
  CheckOutHandleDebug();
  return v12;
}

void _VideoTransmitter_GetBitrates(uint64_t a1, double *a2, double *a3, double *a4, double *a5, double *a6, float a7)
{
  double v14;
  uint64_t v15;
  double v16;
  uint64_t *i;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  double v23[2];

  v23[1] = *(double *)MEMORY[0x1E0C80C00];
  v14 = micro();
  *a2 = 0.0;
  *a3 = 0.0;
  *a4 = 0.0;
  *a5 = 0.0;
  *a6 = 0.0;
  if (*(_DWORD *)(a1 + 1600))
  {
    v15 = 0;
    v16 = v14 - a7;
    v23[0] = NAN;
    for (i = (uint64_t *)(a1 + 560); ; i += 15)
    {
      _VideoTransmitter_ComputeSummerBitrate(*(i - 3), v23, v16);
      if (v18 < 0 && v18 != -2146238447)
        break;
      *a2 = v23[0] + *a2;
      _VideoTransmitter_ComputeSummerBitrate(*(i - 2), v23, v16);
      if (v19 < 0 && v19 != -2146238447)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VideoTransmitter_GetBitrates_cold_2();
        }
        return;
      }
      *a3 = v23[0] + *a3;
      _VideoTransmitter_ComputeSummerBitrate(*(i - 1), v23, v16);
      if (v20 < 0 && v20 != -2146238447)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VideoTransmitter_GetBitrates_cold_3();
        }
        return;
      }
      *a4 = v23[0] + *a4;
      _VideoTransmitter_ComputeSummerBitrate(*i, v23, v16);
      if (v21 < 0 && v21 != -2146238447)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VideoTransmitter_GetBitrates_cold_4();
        }
        return;
      }
      *a5 = v23[0] + *a5;
      _VideoTransmitter_ComputeSummerBitrate(*(i - 4), v23, v16);
      if (v22 < 0 && v22 != -2146238447)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VideoTransmitter_GetBitrates_cold_5();
        }
        return;
      }
      *a6 = v23[0] + *a6;
      if (++v15 >= (unint64_t)*(unsigned int *)(a1 + 1600))
        return;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VideoTransmitter_GetBitrates_cold_1();
    }
  }
}

double _VideoTransmitter_ComputeSummerBitrate(uint64_t a1, double *a2, double a3)
{
  double result;
  double v5;
  double v6[2];

  v6[1] = *(double *)MEMORY[0x1E0C80C00];
  v5 = 0.0;
  v6[0] = NAN;
  *a2 = 0.0;
  if ((SummerSumPred(a3, 0.0, a1, (unsigned int (*)(double, double, double))SummerGreaterThan, (double (*)(double, double, double))SummerIdentity, v6, &v5) & 0x80000000) == 0)
  {
    result = v6[0];
    if (v6[0] >= 0.5)
    {
      result = v5 * 8.0 / v6[0];
      *a2 = result;
    }
  }
  return result;
}

uint64_t VideoTransmitter_SetBitrate(uint64_t a1, unsigned int a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149449730;
  *(_DWORD *)(v3 + 36) = a2;
  *(_DWORD *)(v3 + 40) = a2;
  if (*(_DWORD *)(v3 + 4420))
    RTPSetAFRCTxCap(*(_QWORD *)(v3 + 520), a2);
  else
    *(_DWORD *)(v3 + 4380) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t VideoTransmitter_SetTemporalBitrates(uint64_t a1, const void *a2)
{
  uint64_t v3;
  _QWORD *v4;
  const void *v5;
  const void *v6;
  CFTypeRef v7;
  uint64_t v8;

  v3 = CheckInHandleDebug();
  if (v3)
  {
    v4 = (_QWORD *)v3;
    v5 = *(const void **)(v3 + 4392);
    if (v5)
    {
      if (CFEqual(v5, a2))
      {
LABEL_8:
        CheckOutHandleDebug();
        return 0;
      }
      v6 = (const void *)v4[549];
      if (v6)
      {
        CFRelease(v6);
        v4[549] = 0;
      }
    }
    v7 = CFRetain(a2);
    v4[549] = v7;
    v8 = v4[204];
    if (v8 != 0xFFFFFFFFLL)
      (*(void (**)(uint64_t, CFTypeRef))(v4[202] + 24))(v8, v7);
    goto LABEL_8;
  }
  return 2149449730;
}

uint64_t VideoTransmitter_SetHighestActiveQualityIndex(uint64_t a1, int a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149449730;
  *(_DWORD *)(v3 + 18100) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t VideoTransmitter_GenerateKeyFrameNow(uint64_t a1, unsigned __int16 *a2, uint64_t a3, int a4, int a5, int a6)
{
  uint64_t KeyFrameNow;
  uint64_t v12;
  uint64_t v13;
  double v14;
  uint64_t v15;
  NSObject *v16;
  uint64_t v17;
  NSObject *v18;
  int v20;
  uint64_t v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  KeyFrameNow = 2149449758;
  v12 = CheckInHandleDebug();
  if (!v12)
    return 2149449730;
  v13 = v12;
  v14 = micro();
  if (v14 - *(double *)(v13 + 4344) < *(double *)(v13 + 4352))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v15 = VRTraceErrorLogLevelToCSTR();
      v16 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v20 = 136315650;
        v21 = v15;
        v22 = 2080;
        v23 = "VideoTransmitter_GenerateKeyFrameNow";
        v24 = 1024;
        v25 = 5344;
        _os_log_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Request key frame too soon, discard", (uint8_t *)&v20, 0x1Cu);
      }
    }
LABEL_18:
    CheckOutHandleDebug();
    return KeyFrameNow;
  }
  if (a6 != 3 || !*(_BYTE *)(v13 + 16516))
  {
    KeyFrameNow = _VideoTransmitter_GenerateKeyFrameNow(v13, a2, a3, a4, a5);
    if ((KeyFrameNow & 0x80000000) != 0)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VideoTransmitter_GenerateKeyFrameNow_cold_1();
      }
    }
    else
    {
      *(double *)(v13 + 4344) = v14;
    }
    goto LABEL_18;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v17 = VRTraceErrorLogLevelToCSTR();
    v18 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v20 = 136315650;
      v21 = v17;
      v22 = 2080;
      v23 = "VideoTransmitter_GenerateKeyFrameNow";
      v24 = 1024;
      v25 = 5350;
      _os_log_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Ignoring fail safe FIR in idle state", (uint8_t *)&v20, 0x1Cu);
    }
  }
  return KeyFrameNow;
}

uint64_t _VideoTransmitter_RetransmitPacketDispatched(uint64_t a1, uint64_t a2, int a3, __int16 a4, uint64_t a5, double a6)
{
  NSObject *v7;
  uint64_t v8;
  uint64_t v10;
  NSObject *v11;
  _QWORD block[8];
  int v13;
  __int16 v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  int v18;
  uint8_t buf[4];
  uint64_t v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v15 = 0;
  v16 = &v15;
  v17 = 0x2000000000;
  v18 = 0;
  v7 = *(NSObject **)(a1 + 17720);
  if (v7)
  {
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = ___VideoTransmitter_RetransmitPacketDispatched_block_invoke;
    block[3] = &unk_1E9E549E8;
    block[4] = &v15;
    block[5] = a2;
    v13 = a3;
    v14 = a4;
    *(double *)&block[6] = a6;
    block[7] = a5;
    dispatch_async(v7, block);
  }
  else
  {
    v18 = -2145517567;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v10 = VRTraceErrorLogLevelToCSTR();
      v11 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        v20 = v10;
        v21 = 2080;
        v22 = "_VideoTransmitter_RetransmitPacketDispatched";
        v23 = 1024;
        v24 = 5366;
        v25 = 2048;
        v26 = a1;
        _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VideoTransmitter[%p] TransmitQueue is NULL", buf, 0x26u);
      }
    }
  }
  v8 = *((unsigned int *)v16 + 6);
  _Block_object_dispose(&v15, 8);
  return v8;
}

uint64_t VideoTransmitter_RetransmitPackets(double a1, uint64_t a2, int a3, __int16 a4, __int16 a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t RetransmissionRequestInfoFromNACK;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned __int8 v22;
  uint64_t v23;
  char *v24;
  int v25;
  unsigned __int16 *v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  NSObject *v30;
  uint64_t v31;
  int v32;
  uint64_t v34;
  uint64_t v35;
  NSObject *v36;
  NSObject *v37;
  uint64_t v38;
  NSObject *v39;
  uint64_t v40;
  int v41;
  int v42;
  __int16 v43;
  __int16 v44;
  uint64_t v45;
  uint8_t buf[4];
  uint64_t v47;
  __int16 v48;
  const char *v49;
  __int16 v50;
  int v51;
  __int16 v52;
  uint64_t v53;
  __int16 v54;
  uint64_t v55;
  __int16 v56;
  int v57;
  __int16 v58;
  int v59;
  _OWORD v60[3];
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  v9 = CheckInHandleDebug();
  if (v9)
  {
    v10 = v9;
    v11 = *(_QWORD *)(v9 + 18272);
    if (v11)
    {
      if (*(_BYTE *)(v10 + 18186))
      {
        v42 = a3;
        v43 = a4;
        v44 = a5;
        v45 = 0;
        memset(v60, 0, 44);
        RetransmissionRequestInfoFromNACK = VCNACKConsumer_GetRetransmissionRequestInfoFromNACK(v11, &v42, (uint64_t)v60);
        if ((RetransmissionRequestInfoFromNACK & 0x80000000) != 0)
        {
          v18 = RetransmissionRequestInfoFromNACK;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            v38 = VRTraceErrorLogLevelToCSTR();
            v39 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            {
              v40 = *(_QWORD *)(v10 + 18272);
              *(_DWORD *)buf = 136316162;
              v47 = v38;
              v48 = 2080;
              v49 = "VideoTransmitter_RetransmitPackets";
              v50 = 1024;
              v51 = 5391;
              v52 = 2048;
              v53 = v10;
              v54 = 2048;
              v55 = v40;
              _os_log_error_impl(&dword_1D8A54000, v39, OS_LOG_TYPE_ERROR, " [%s] %s:%d VideoTransmitter[%p] NACKConsumer[%p] Unable to get retransmission request info", buf, 0x30u);
            }
          }
        }
        else
        {
          v13 = *(unsigned int *)(v10 + 1600);
          if (!(_DWORD)v13)
            goto LABEL_9;
          v14 = 0;
          v15 = 120 * v13;
          while (*(_DWORD *)(v10 + v14 + 576) != a3)
          {
            v14 += 120;
            if (v15 == v14)
              goto LABEL_9;
          }
          v19 = *(_QWORD *)(v10 + v14 + 520);
          if (v19 == 0xFFFFFFFFLL)
          {
LABEL_9:
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              v16 = VRTraceErrorLogLevelToCSTR();
              v17 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              {
                v34 = *(_QWORD *)(v10 + 18272);
                *(_DWORD *)buf = 136316418;
                v47 = v16;
                v48 = 2080;
                v49 = "VideoTransmitter_RetransmitPackets";
                v50 = 1024;
                v51 = 5394;
                v52 = 2048;
                v53 = v10;
                v54 = 2048;
                v55 = v34;
                v56 = 1024;
                v57 = a3;
                _os_log_error_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_ERROR, " [%s] %s:%d VideoTransmitter[%p] NACKConsumer[%p] Unable to get RTP handle ssrc=%d", buf, 0x36u);
              }
            }
            v18 = 2147549186;
          }
          else
          {
            v20 = CheckInHandleDebug();
            if (WORD2(v60[0]))
            {
              v21 = v20;
              v22 = 0;
              v23 = 0;
              do
              {
                v41 = 0;
                v24 = (char *)v60 + 2 * v22;
                v27 = *((unsigned __int16 *)v24 + 5);
                v26 = (unsigned __int16 *)(v24 + 10);
                v25 = v27;
                if (*(_QWORD *)(v21 + 10440))
                  v28 = RTPTransportResendRTP(a1, v19, a3, v25, &v41);
                else
                  v28 = _VideoTransmitter_RetransmitPacketDispatched(v10, v19, a3, v25, (uint64_t)&v41, a1);
                v18 = v28;
                if ((v28 & 0x80000000) != 0)
                {
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                  {
                    v29 = VRTraceErrorLogLevelToCSTR();
                    v30 = *MEMORY[0x1E0CF2758];
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                    {
                      v31 = *(_QWORD *)(v10 + 18272);
                      v32 = *v26;
                      *(_DWORD *)buf = 136316674;
                      v47 = v29;
                      v48 = 2080;
                      v49 = "VideoTransmitter_RetransmitPackets";
                      v50 = 1024;
                      v51 = 5407;
                      v52 = 2048;
                      v53 = v10;
                      v54 = 2048;
                      v55 = v31;
                      v56 = 1024;
                      v57 = a3;
                      v58 = 1024;
                      v59 = v32;
                      _os_log_error_impl(&dword_1D8A54000, v30, OS_LOG_TYPE_ERROR, " [%s] %s:%d VideoTransmitter[%p] NACKConsumer[%p] Unable to resend packet ssrc=%d seqNum=%d", buf, 0x3Cu);
                    }
                  }
                }
                else
                {
                  *(_DWORD *)(v10 + 1676) += v41;
                  v18 = v23;
                }
                ++v22;
                v23 = v18;
              }
              while (WORD2(v60[0]) > v22);
            }
            else
            {
              v18 = 0;
            }
            CheckOutHandleDebug();
          }
        }
        goto LABEL_29;
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v35 = VRTraceErrorLogLevelToCSTR();
      v36 = *MEMORY[0x1E0CF2758];
      v37 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        v18 = 0;
        if (!os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
        {
LABEL_29:
          CheckOutHandleDebug();
          return v18;
        }
        *(_DWORD *)buf = 136315906;
        v47 = v35;
        v48 = 2080;
        v49 = "VideoTransmitter_RetransmitPackets";
        v50 = 1024;
        v51 = 5381;
        v52 = 2048;
        v53 = v10;
        _os_log_impl(&dword_1D8A54000, v36, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VideoTransmitter[%p] NACK Consumer is NULL", buf, 0x26u);
      }
      else if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
      {
        VideoTransmitter_RetransmitPackets_cold_1();
      }
    }
    v18 = 0;
    goto LABEL_29;
  }
  return 2149449730;
}

uint64_t VideoTransmitter_AddRexmitBytes(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  pthread_mutex_t *v5;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149449730;
  v4 = v3;
  v5 = (pthread_mutex_t *)(v3 + 1680);
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 1680));
  *(_DWORD *)(v4 + 1672) += a2;
  pthread_mutex_unlock(v5);
  CheckOutHandleDebug();
  return 0;
}

uint64_t VideoTransmitter_ACKLTRFrame(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  int ErrorLogLevelForModule;
  unsigned __int8 *v6;
  NSObject **v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  int v12;
  int v13;
  int v14;
  int v15;
  unsigned __int8 *v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  int v23;
  NSObject *v24;
  NSObject *v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  int v32;
  __int16 v33;
  int v34;
  __int16 v35;
  int v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149449730;
  v4 = v3;
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  v6 = (unsigned __int8 *)MEMORY[0x1E0CF2748];
  v7 = (NSObject **)MEMORY[0x1E0CF2758];
  if (ErrorLogLevelForModule >= 8)
  {
    v8 = VRTraceErrorLogLevelToCSTR();
    v9 = *v7;
    v10 = *v7;
    if (*v6)
    {
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        v27 = 136315906;
        v28 = v8;
        v29 = 2080;
        v30 = "VideoTransmitter_ACKLTRFrame";
        v31 = 1024;
        v32 = 5447;
        v33 = 1024;
        v34 = a2;
        _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Received LTR ACK timestamp=%d", (uint8_t *)&v27, 0x22u);
      }
    }
    else if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      VideoTransmitter_ACKLTRFrame_cold_1();
    }
  }
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 2992));
  v12 = *(_DWORD *)(v4 + 1780);
  if (v12 < 1)
  {
LABEL_15:
    v16 = v6;
    v17 = -1;
  }
  else
  {
    v13 = 0;
    v14 = *(_DWORD *)(v4 + 1784);
    while (1)
    {
      v15 = v14 - 100;
      if (v14 <= 99)
        v15 = v14;
      if (*(_DWORD *)(v4 + 4 * v15 + 2188) == a2)
        break;
      --v13;
      ++v14;
      if (!(v12 + v13))
        goto LABEL_15;
    }
    v17 = *(_DWORD *)(v4 + 4 * v15 + 1788);
    if (v15 + 1 < v12 + v15 + v13)
    {
      v18 = v15 + v13;
      do
      {
        v19 = v15 - 100;
        v20 = v15 - 99;
        if (v15 <= 99)
          v19 = v15;
        if (v15 <= 98)
          v20 = v15 + 1;
        if (v15 < 0)
          v19 = v15 + 100;
        v21 = v15 + 2;
        ++v15;
        *(_DWORD *)(v4 + 2188 + 4 * v19) = *(_DWORD *)(v4 + 2188 + 4 * v20);
        *(_DWORD *)(v4 + 1788 + 4 * v19) = *(_DWORD *)(v4 + 1788 + 4 * v20);
        v12 = *(_DWORD *)(v4 + 1780);
      }
      while (v21 < v18 + v12);
    }
    v16 = v6;
    *(_DWORD *)(v4 + 1780) = v12 - 1;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v22 = VRTraceErrorLogLevelToCSTR();
    v23 = *v16;
    v24 = *v7;
    v25 = *v7;
    if (v23)
    {
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        v27 = 136316162;
        v28 = v22;
        v29 = 2080;
        v30 = "VideoTransmitter_ACKLTRFrame";
        v31 = 1024;
        v32 = 5481;
        v33 = 1024;
        v34 = a2;
        v35 = 1024;
        v36 = v17;
        _os_log_impl(&dword_1D8A54000, v24, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Mapped incoming LTR ACK timestamp=%d to token=%d", (uint8_t *)&v27, 0x28u);
      }
    }
    else if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
    {
      v27 = 136316162;
      v28 = v22;
      v29 = 2080;
      v30 = "VideoTransmitter_ACKLTRFrame";
      v31 = 1024;
      v32 = 5481;
      v33 = 1024;
      v34 = a2;
      v35 = 1024;
      v36 = v17;
      _os_log_debug_impl(&dword_1D8A54000, v24, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Mapped incoming LTR ACK timestamp=%d to token=%d", (uint8_t *)&v27, 0x28u);
    }
  }
  if (v17 != -1)
  {
    v26 = *(int *)(v4 + 2588);
    if ((int)v26 > 99)
    {
      memmove((void *)(v4 + 2592), (const void *)(v4 + 2596), 0x18CuLL);
      *(_DWORD *)(v4 + 2988) = v17;
    }
    else
    {
      *(_DWORD *)(v4 + 4 * v26 + 2592) = v17;
      ++*(_DWORD *)(v4 + 2588);
    }
  }
  if (*(_DWORD *)(v4 + 18252) == 2)
    ++*(_DWORD *)(v4 + 18256);
  else
    ++*(_DWORD *)(v4 + 18260);
  pthread_mutex_unlock((pthread_mutex_t *)(v4 + 2992));
  CheckOutHandleDebug();
  return 0;
}

uint64_t VideoTransmitter_SendLTRACK(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  pthread_mutex_t *v5;
  int v6;
  uint64_t v7;
  int v8;
  int v10;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149449730;
  v4 = v3;
  v5 = (pthread_mutex_t *)(v3 + 4272);
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 4272));
  v6 = *(_DWORD *)(v4 + 3056);
  v7 = *(int *)(v4 + 3060);
  if (v6 > 99)
  {
    *(_DWORD *)(v4 + 4 * v7 + 3464) = a2;
    v10 = *(_DWORD *)(v4 + 3060);
    if (v10 < 99)
      *(_DWORD *)(v4 + 3060) = v10 + 1;
    else
      *(_DWORD *)(v4 + 3060) = 0;
  }
  else
  {
    v8 = v7 + v6;
    if (v8 > 99)
      v8 -= 100;
    *(_DWORD *)(v4 + 3056 + 4 * v8 + 408) = a2;
    ++*(_DWORD *)(v4 + 3056);
  }
  pthread_mutex_unlock(v5);
  CheckOutHandleDebug();
  return 0;
}

uint64_t VideoTransmitter_SetAspectRatios(double a1, double a2, double a3, double a4)
{
  float *v8;
  float *v9;
  float *v10;
  float v11;
  float v12;
  float v13;
  float v14;
  uint64_t v15;
  NSObject *v16;
  double v17;
  double v18;
  double v19;
  double v20;
  int v22;
  uint64_t v23;
  __int16 v24;
  const char *v25;
  __int16 v26;
  int v27;
  __int16 v28;
  float *v29;
  __int16 v30;
  double v31;
  __int16 v32;
  double v33;
  __int16 v34;
  double v35;
  __int16 v36;
  double v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v8 = (float *)CheckInHandleDebug();
  if (!v8)
    return 2149449730;
  v9 = v8;
  v10 = v8 + 4186;
  v11 = a1 / a2;
  v12 = a2 / a1;
  v8[4186] = v11;
  v8[4187] = v12;
  v13 = a3 / a4;
  v14 = a4 / a3;
  v8[4188] = v13;
  v8[4189] = v14;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v15 = VRTraceErrorLogLevelToCSTR();
    v16 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v17 = *v10;
      v18 = v10[1];
      v19 = v10[2];
      v20 = v10[3];
      v22 = 136316930;
      v23 = v15;
      v24 = 2080;
      v25 = "VideoTransmitter_SetAspectRatios";
      v26 = 1024;
      v27 = 5562;
      v28 = 2048;
      v29 = v9;
      v30 = 2048;
      v31 = v17;
      v32 = 2048;
      v33 = v18;
      v34 = 2048;
      v35 = v19;
      v36 = 2048;
      v37 = v20;
      _os_log_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d [AR_TX][%p] portraitAR=%.3f, portraitAR_rcp=%.3f, landscapeAR=%.3f, landscapeAR_rcp=%.3f", (uint8_t *)&v22, 0x4Eu);
    }
  }
  CheckOutHandleDebug();
  return 0;
}

uint64_t VideoTransmitter_SetCellTech(uint64_t a1, int a2, int a3, int a4, int a5)
{
  _DWORD *v9;
  int v10;
  int v11;
  uint64_t v12;
  NSObject *v13;
  int v15;
  uint64_t v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  __int16 v23;
  int v24;
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v9 = (_DWORD *)CheckInHandleDebug();
  if (!v9)
    return 2149449730;
  v9[24] = a2;
  v9[25] = a4;
  if (a2)
    v10 = 0;
  else
    v10 = a3;
  if (a4)
    v11 = 0;
  else
    v11 = a5;
  v9[4244] = v10;
  v9[4245] = v11;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v12 = VRTraceErrorLogLevelToCSTR();
    v13 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v15 = 136316674;
      v16 = v12;
      v17 = 2080;
      v18 = "VideoTransmitter_SetCellTech";
      v19 = 1024;
      v20 = 5582;
      v21 = 1024;
      v22 = a3;
      v23 = 1024;
      v24 = a5;
      v25 = 1024;
      v26 = a2;
      v27 = 1024;
      v28 = a4;
      _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VideoTransmitter_SetCellTech [Local:%d Remote:%d], use celular(%d/%d)", (uint8_t *)&v15, 0x34u);
    }
  }
  CheckOutHandleDebug();
  return 0;
}

uint64_t VideoTransmitter_SetThermalLevel(uint64_t a1, int a2)
{
  uint64_t v3;
  int *v4;
  uint64_t v5;
  NSObject *v6;
  int v7;
  int v9;
  uint64_t v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149449730;
  v4 = (int *)(v3 + 16520);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v5 = VRTraceErrorLogLevelToCSTR();
    v6 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v7 = *v4;
      v9 = 136316162;
      v10 = v5;
      v11 = 2080;
      v12 = "VideoTransmitter_SetThermalLevel";
      v13 = 1024;
      v14 = 5594;
      v15 = 1024;
      v16 = v7;
      v17 = 1024;
      v18 = a2;
      _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Setting old thermal level %d -> new thermal level %d", (uint8_t *)&v9, 0x28u);
    }
  }
  v4[1] = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t VideoTransmitter_UpdateMTU(uint64_t a1, int a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  unsigned __int16 *v7;
  uint64_t v8;
  NSObject *v9;
  int v10;
  int v11;
  pthread_mutex_t *v12;
  int v14;
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v5 = CheckInHandleDebug();
  if (!v5)
    return 2149449730;
  v6 = v5;
  v7 = (unsigned __int16 *)(v5 + 17276);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v8 = VRTraceErrorLogLevelToCSTR();
    v9 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v10 = *v7;
      v11 = *((unsigned __int8 *)v7 + 2);
      v14 = 136316674;
      v15 = v8;
      v16 = 2080;
      v17 = "VideoTransmitter_UpdateMTU";
      v18 = 1024;
      v19 = 5607;
      v20 = 1024;
      v21 = v10;
      v22 = 1024;
      v23 = a2;
      v24 = 1024;
      v25 = v11;
      v26 = 1024;
      v27 = a3;
      _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VideoTransmitter_UpdateMTU %d -> %d  ipv6: %d -> %d ", (uint8_t *)&v14, 0x34u);
    }
  }
  v12 = (pthread_mutex_t *)(v6 + 17288);
  pthread_mutex_lock(v12);
  *v7 = a2;
  *((_BYTE *)v7 + 2) = a3;
  pthread_mutex_unlock(v12);
  CheckOutHandleDebug();
  return 0;
}

uint64_t VideoTransmitter_SetIsRtxEnabled(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  int v7;
  unint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  int v12;
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149449730;
  v4 = v3;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v5 = VRTraceErrorLogLevelToCSTR();
    v6 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v7 = *(unsigned __int8 *)(v4 + 18186);
      v12 = 136316418;
      v13 = v5;
      v14 = 2080;
      v15 = "VideoTransmitter_SetIsRtxEnabled";
      v16 = 1024;
      v17 = 5623;
      v18 = 1024;
      v19 = 5623;
      v20 = 1024;
      v21 = v7;
      v22 = 1024;
      v23 = a2;
      _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/VideoTransmitter.c:%d: isUplinkRetransmissionEnabled oldValue=%d newValue=%d", (uint8_t *)&v12, 0x2Eu);
    }
  }
  *(_BYTE *)(v4 + 18186) = a2;
  if ((a2 & 1) == 0 && *(_DWORD *)(v4 + 1600))
  {
    v8 = 0;
    v9 = (uint64_t *)(v4 + 520);
    do
    {
      v10 = *v9;
      v9 += 15;
      RTPTransport_SetNACKConsumer(v10, 0);
      ++v8;
    }
    while (v8 < *(unsigned int *)(v4 + 1600));
  }
  CheckOutHandleDebug();
  return 0;
}

uint64_t VideoTransmitter_SetWindowState(uint64_t a1, int a2, int a3)
{
  uint64_t v5;
  uint64_t v7;
  NSObject *v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v5 = CheckInHandleDebug();
  if (!v5)
    return 2149449730;
  if (a2)
    *(_DWORD *)(v5 + 17376) = a3;
  else
    *(_DWORD *)(v5 + 17380) = a3;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v7 = VRTraceErrorLogLevelToCSTR();
    v8 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136316162;
      v10 = v7;
      v11 = 2080;
      v12 = "VideoTransmitter_SetWindowState";
      v13 = 1024;
      v14 = 5645;
      v15 = 1024;
      v16 = a2;
      v17 = 1024;
      v18 = a3;
      _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VideoTransmitter_SetWindowState: Local %d, state: %d", (uint8_t *)&v9, 0x28u);
    }
  }
  CheckOutHandleDebug();
  return 0;
}

uint64_t VideoTransmitter_SetVisualRectangle(double a1, double a2, double a3, double a4, uint64_t a5, int a6)
{
  double *v11;
  uint64_t v12;
  uint64_t v14;
  NSObject *v15;
  int v16;
  uint64_t v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  __int16 v24;
  double v25;
  __int16 v26;
  double v27;
  __int16 v28;
  double v29;
  __int16 v30;
  double v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v11 = (double *)CheckInHandleDebug();
  if (!v11)
    return 2149449730;
  if (a6)
  {
    v11[2173] = a1;
    v11[2174] = a2;
    v11[2175] = a3;
    v12 = 2176;
  }
  else
  {
    v11[2177] = a1;
    v11[2178] = a2;
    v11[2179] = a3;
    v12 = 2180;
  }
  v11[v12] = a4;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v14 = VRTraceErrorLogLevelToCSTR();
    v15 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v16 = 136316930;
      v17 = v14;
      v18 = 2080;
      v19 = "VideoTransmitter_SetVisualRectangle";
      v20 = 1024;
      v21 = 5664;
      v22 = 1024;
      v23 = a6;
      v24 = 2048;
      v25 = a1;
      v26 = 2048;
      v27 = a2;
      v28 = 2048;
      v29 = a3;
      v30 = 2048;
      v31 = a4;
      _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VideoTransmitter_SetVisualRectangle: Local %d, Rect: (%g, %g), %gx%g", (uint8_t *)&v16, 0x4Au);
    }
  }
  CheckOutHandleDebug();
  return 0;
}

uint64_t VideoTransmitter_IsSafeViewMode(uint64_t a1, BOOL *a2)
{
  uint64_t v2;
  uint64_t v4;

  v2 = 2149449729;
  if (a2)
  {
    v4 = CheckInHandleDebug();
    if (v4)
    {
      *a2 = *(_DWORD *)(v4 + 17372) == 39;
      CheckOutHandleDebug();
      return 0;
    }
    else
    {
      return 2149449730;
    }
  }
  return v2;
}

uint64_t VideoTransmitter_SetVideoLossFraction(uint64_t a1, unsigned int a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149449730;
  *(double *)(v3 + 4408) = (double)a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t VideoTransmitter_SetMediaSuggestion(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  int v4;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149449730;
  if ((a2 & 1) != 0)
    *(_DWORD *)(v3 + 4388) |= 1u;
  if ((a2 & 0x100) != 0)
  {
    v4 = *(_DWORD *)(v3 + 4388);
    if ((v4 & 1) != 0)
      *(_DWORD *)(v3 + 4388) = v4 & 0xFFFFFFFE;
  }
  if ((a2 & 0x10000) != 0)
    *(_DWORD *)(v3 + 4388) |= 0x10u;
  if ((a2 & 0x1000000) != 0)
    *(_DWORD *)(v3 + 4388) |= 2u;
  if ((a2 & 0x100000000) != 0)
    *(_DWORD *)(v3 + 4388) |= 8u;
  *(_WORD *)(v3 + 18281) = a2;
  *(_BYTE *)(v3 + 18283) = BYTE2(a2);
  *(_BYTE *)(v3 + 18284) = BYTE3(a2);
  *(_BYTE *)(v3 + 18285) = BYTE4(a2);
  *(_WORD *)(v3 + 18286) = HIDWORD(a2) >> 8;
  *(_BYTE *)(v3 + 18288) = HIBYTE(a2);
  CheckOutHandleDebug();
  return 0;
}

uint64_t VideoTransmitter_SetTargetBitrate(uint64_t a1, int a2, int a3, char a4)
{
  uint64_t v7;

  v7 = CheckInHandleDebug();
  if (!v7)
    return 2149449730;
  *(_DWORD *)(v7 + 4380) = a2;
  *(_DWORD *)(v7 + 4384) = a3;
  *(_BYTE *)(v7 + 16824) = a4;
  CheckOutHandleDebug();
  return 0;
}

uint64_t VideoTransmitter_SetServerBasedBandwidthProbing(uint64_t a1, char a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149449730;
  if (*(_DWORD *)(v3 + 496) == 2)
    *(_BYTE *)(v3 + 16825) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t VideoTransmitter_SetEndToEndBasedBandwidthProbing(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  int v8;
  uint64_t v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149449730;
  v4 = v3;
  if (*(_DWORD *)(v3 + 496) == 1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v6 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v8 = 136316162;
        v9 = v5;
        v10 = 2080;
        v11 = "VideoTransmitter_SetEndToEndBasedBandwidthProbing";
        v12 = 1024;
        v13 = 5762;
        v14 = 2048;
        v15 = v4;
        v16 = 1024;
        v17 = a2;
        _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d videoTransmitter=%p set endToEndBasedBandwidthProbing=%d", (uint8_t *)&v8, 0x2Cu);
      }
    }
    *(_BYTE *)(v4 + 16826) = a2;
  }
  CheckOutHandleDebug();
  return 0;
}

uint64_t VideoTransmitter_GetLastKeyFrameSentTime(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149449730;
  *a2 = *(_QWORD *)(v3 + 4336);
  CheckOutHandleDebug();
  return 0;
}

uint64_t VideoTransmitter_SetKeyFrameOnlyStreamID(uint64_t a1, int a2)
{
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  int v7;
  uint64_t v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v3 = VRTraceErrorLogLevelToCSTR();
    v4 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v7 = 136315906;
      v8 = v3;
      v9 = 2080;
      v10 = "VideoTransmitter_SetKeyFrameOnlyStreamID";
      v11 = 1024;
      v12 = 5783;
      v13 = 1024;
      v14 = a2;
      _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d keyFrameOnlyStreamID:%d", (uint8_t *)&v7, 0x22u);
    }
  }
  v5 = CheckInHandleDebug();
  if (!v5)
    return 2149449730;
  *(_BYTE *)(v5 + 491) = 1;
  *(_WORD *)(v5 + 492) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t VideoTransmitter_SetMediaQueueSize(uint64_t a1, unsigned int a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149449730;
  atomic_store(a2, (unsigned int *)(v3 + 16492));
  CheckOutHandleDebug();
  return 0;
}

uint64_t VideoTransmitter_SetFECRatio(double a1)
{
  uint64_t v2;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  uint64_t v7;
  unsigned int *v8;
  float v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  NSObject *v14;
  const __CFAllocator *v15;
  __CFDictionary *Mutable;
  CFNumberRef v17;
  int v19;
  uint64_t v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  unsigned int v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v2 = 2149449729;
  if (a1 <= -0.00000011920929 || a1 > 3.0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v4 = VRTraceErrorLogLevelToCSTR();
      v5 = *MEMORY[0x1E0CF2758];
      v6 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          v19 = 136315650;
          v20 = v4;
          v21 = 2080;
          v22 = "VideoTransmitter_SetFECRatio";
          v23 = 1024;
          v24 = 5807;
          _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d invalid parameter!", (uint8_t *)&v19, 0x1Cu);
        }
      }
      else if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        VideoTransmitter_SetFECRatio_cold_1();
      }
    }
  }
  else
  {
    v7 = CheckInHandleDebug();
    if (v7)
    {
      v8 = (unsigned int *)(v7 + 16488);
      if (!*(_BYTE *)(v7 + 18153))
      {
        v9 = a1;
        v10 = FECUtil_FECRatioToLevelofProtection(v9);
        v11 = atomic_load(v8);
        if (v11 != v10)
        {
          v12 = v10;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v13 = VRTraceErrorLogLevelToCSTR();
            v14 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              v19 = 136315906;
              v20 = v13;
              v21 = 2080;
              v22 = "VideoTransmitter_SetFECRatio";
              v23 = 1024;
              v24 = 5819;
              v25 = 1024;
              v26 = v12;
              _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d fecLevel:%d", (uint8_t *)&v19, 0x22u);
            }
          }
          v15 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          v19 = (__int16)v12;
          v17 = CFNumberCreate(v15, kCFNumberIntType, &v19);
          CFDictionaryAddValue(Mutable, CFSTR("VCVSFecLevel"), v17);
          CFRelease(v17);
          reportingEventWithAllowedClientType();
          CFRelease(Mutable);
          atomic_store(v12, v8);
        }
      }
      CheckOutHandleDebug();
      return 0;
    }
    else
    {
      return 2149449730;
    }
  }
  return v2;
}

uint64_t VideoTransmitter_SetNetworkStats(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149449730;
  v4 = *(_QWORD *)(a2 + 16);
  *(_OWORD *)(v3 + 18056) = *(_OWORD *)a2;
  *(_QWORD *)(v3 + 18072) = v4;
  CheckOutHandleDebug();
  return 0;
}

uint64_t VideoTransmitter_SetPacketExpirationTime(uint64_t a1, unsigned int a2)
{
  uint64_t v3;
  int *v4;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  int v8;
  const char *v9;
  uint64_t v11;
  NSObject *v12;
  int v13;
  uint64_t v14;
  NSObject *v15;
  int v16;
  uint64_t v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  unsigned int v23;
  __int16 v24;
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149449730;
  v4 = (int *)(v3 + 16512);
  if (a2 <= 0x103)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v6 = *MEMORY[0x1E0CF2758];
      v7 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        v8 = 260;
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          v16 = 136316162;
          v17 = v5;
          v18 = 2080;
          v19 = "VideoTransmitter_SetPacketExpirationTime";
          v20 = 1024;
          v21 = 5848;
          v22 = 1024;
          v23 = a2;
          v24 = 1024;
          v25 = 260;
          v9 = " [%s] %s:%d Setting expiration time (remote jitter size) with %d ms, below the min %d ms";
LABEL_13:
          _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v16, 0x28u);
          goto LABEL_21;
        }
        goto LABEL_21;
      }
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
        VideoTransmitter_SetPacketExpirationTime_cold_1();
    }
    v8 = 260;
    goto LABEL_21;
  }
  if (a2 < 0x191)
  {
    v8 = a2;
    goto LABEL_21;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() < 8)
  {
LABEL_20:
    v8 = 400;
    goto LABEL_21;
  }
  v11 = VRTraceErrorLogLevelToCSTR();
  v6 = *MEMORY[0x1E0CF2758];
  v12 = *MEMORY[0x1E0CF2758];
  if (!*MEMORY[0x1E0CF2748])
  {
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      VideoTransmitter_SetPacketExpirationTime_cold_2();
    goto LABEL_20;
  }
  v8 = 400;
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    v16 = 136316162;
    v17 = v11;
    v18 = 2080;
    v19 = "VideoTransmitter_SetPacketExpirationTime";
    v20 = 1024;
    v21 = 5853;
    v22 = 1024;
    v23 = a2;
    v24 = 1024;
    v25 = 400;
    v9 = " [%s] %s:%d Setting expiration time (remote jitter size) with %d ms, above the max %d ms";
    goto LABEL_13;
  }
LABEL_21:
  if (v4[34] >= 0)
    v13 = v4[34];
  else
    v13 = v8;
  if (v13 != *v4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v14 = VRTraceErrorLogLevelToCSTR();
      v15 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v16 = 136315906;
        v17 = v14;
        v18 = 2080;
        v19 = "VideoTransmitter_SetPacketExpirationTime";
        v20 = 1024;
        v21 = 5866;
        v22 = 1024;
        v23 = v13;
        _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Setting expiration time %d ms", (uint8_t *)&v16, 0x22u);
      }
    }
    *v4 = v13;
  }
  CheckOutHandleDebug();
  return 0;
}

uint64_t VideoTransmitter_SetStreamIDs(uint64_t a1, const void *a2, unsigned int a3, const void *a4, unsigned int a5)
{
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE *v13;
  uint64_t v14;
  int v16;
  uint64_t v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  unsigned int v23;
  __int16 v24;
  unsigned int v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v9 = VRTraceErrorLogLevelToCSTR();
    v10 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v16 = 136316162;
      v17 = v9;
      v18 = 2080;
      v19 = "VideoTransmitter_SetStreamIDs";
      v20 = 1024;
      v21 = 5875;
      v22 = 1024;
      v23 = a3;
      v24 = 1024;
      v25 = a5;
      _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d numOfStreamIDs:%u, numOfRepairedCompoundStreamIDs:%u", (uint8_t *)&v16, 0x28u);
    }
  }
  v11 = 2149449729;
  if (a2 && a3 && a5 + a3 < 0xD)
  {
    v12 = CheckInHandleDebug();
    if (v12)
    {
      v13 = (_BYTE *)v12;
      v14 = v12 + 440;
      memcpy((void *)(v12 + 440), a2, 2 * a3);
      memcpy((void *)(v14 + 2 * a3), a4, 2 * a5);
      v13[464] = a5 + a3;
      if (a4)
        memcpy(v13 + 466, a4, 2 * a5);
      v13[490] = a5;
      CheckOutHandleDebug();
      return 0;
    }
    else
    {
      return 2149449730;
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VideoTransmitter_SetStreamIDs_cold_1();
  }
  return v11;
}

uint64_t VideoTransmitter_PrepareForResChange(uint64_t a1, int a2, int a3, int a4, int a5, _BYTE *a6, int a7, int a8, int a9)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  pthread_mutex_t *v18;
  _DWORD *v19;
  uint64_t v21;
  NSObject *v22;
  int v23;
  uint64_t v24;
  NSObject *v25;
  int v26;
  double v27;
  uint64_t v28;
  NSObject *v29;
  char *v30;
  uint64_t v31;
  uint8_t buf[4];
  uint64_t v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  int v38;
  __int16 v39;
  int v40;
  __int16 v41;
  int v42;
  __int16 v43;
  int v44;
  __int16 v45;
  int v46;
  __int16 v47;
  int v48;
  __int16 v49;
  char *v50;
  __int16 v51;
  uint64_t v52;
  __int16 v53;
  double v54;
  __int16 v55;
  uint64_t v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  v15 = CheckInHandleDebug();
  if (!v15)
    return 2149449730;
  v16 = v15;
  v17 = v15 + 17072;
  v18 = (pthread_mutex_t *)(v15 + 17000);
  pthread_mutex_lock((pthread_mutex_t *)(v15 + 17000));
  if (*(_BYTE *)(v17 + 1))
  {
    if (*(_DWORD *)(v17 + 4) == a2)
    {
      v19 = (_DWORD *)(v17 + 8);
      goto LABEL_8;
    }
LABEL_15:
    if (a4 == 100)
      v23 = 1752589105;
    else
      v23 = 1635148593;
    *(_DWORD *)(v17 + 400) = v23;
    *(_DWORD *)(v16 + 20) = a4;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v24 = VRTraceErrorLogLevelToCSTR();
      v25 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v26 = *(_DWORD *)(v16 + 20);
        *(_DWORD *)buf = 136315906;
        v34 = v24;
        v35 = 2080;
        v36 = "VideoTransmitter_PrepareForResChange";
        v37 = 1024;
        v38 = 5940;
        v39 = 1024;
        v40 = v26;
        _os_log_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Setting pendingPayload to %d", buf, 0x22u);
      }
    }
    *(_DWORD *)(v17 + 692) = a9;
    *(_DWORD *)(v16 + 44) = a5;
    *(_DWORD *)(v17 + 4) = a2;
    *(_DWORD *)(v17 + 8) = a3;
    *(_DWORD *)(v17 + 12) = a7;
    *(_DWORD *)(v17 + 16) = a8;
    if (a6 && *a6)
      __strlcpy_chk();
    v27 = micro();
    *(double *)(v16 + 17248) = v27 + 2.0;
    *(_BYTE *)(v17 + 1) = 1;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v28 = VRTraceErrorLogLevelToCSTR();
      v29 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v30 = FourccToCStr(*(_DWORD *)(v17 + 396));
        v31 = *(_QWORD *)(v16 + 17248);
        *(_DWORD *)buf = 136317954;
        v34 = v28;
        v35 = 2080;
        v36 = "VideoTransmitter_PrepareForResChange";
        v37 = 1024;
        v38 = 5954;
        v39 = 1024;
        v40 = a7;
        v41 = 1024;
        v42 = a8;
        v43 = 1024;
        v44 = a2;
        v45 = 1024;
        v46 = a3;
        v47 = 1024;
        v48 = a5;
        v49 = 2080;
        v50 = v30;
        v51 = 2080;
        v52 = v16 + 17092;
        v53 = 2048;
        v54 = v27;
        v55 = 2048;
        v56 = v31;
        _os_log_impl(&dword_1D8A54000, v29, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VideoTransmitter_PrepareForResChange to capture: %dx%d encode: %dx%d %dfps (%s: %s) (now: %f timeout will be %f)", buf, 0x62u);
      }
    }
    goto LABEL_27;
  }
  if (*(_DWORD *)(v16 + 24) != a2)
    goto LABEL_15;
  v19 = (_DWORD *)(v16 + 28);
LABEL_8:
  if (*v19 != a3)
    goto LABEL_15;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v21 = VRTraceErrorLogLevelToCSTR();
    v22 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136316162;
      v34 = v21;
      v35 = 2080;
      v36 = "VideoTransmitter_PrepareForResChange";
      v37 = 1024;
      v38 = 5919;
      v39 = 1024;
      v40 = a2;
      v41 = 1024;
      v42 = a3;
      _os_log_impl(&dword_1D8A54000, v22, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VideoTransmitter_PrepareForResChange: already in %dx%d resolution.", buf, 0x28u);
    }
  }
  if (*(_BYTE *)v17)
    *(_BYTE *)v17 = 0;
LABEL_27:
  pthread_mutex_unlock(v18);
  CheckOutHandleDebug();
  return 0;
}

uint64_t VideoTransmitter_PauseEncoder()
{
  uint64_t v0;
  uint64_t v1;
  _BYTE *v2;
  uint64_t v3;
  NSObject *v4;
  int v6;
  uint64_t v7;
  __int16 v8;
  const char *v9;
  __int16 v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v0 = CheckInHandleDebug();
  if (!v0)
    return 2149449730;
  v1 = v0;
  v2 = (_BYTE *)(v0 + 17488);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v3 = VRTraceErrorLogLevelToCSTR();
    v4 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v6 = 136315650;
      v7 = v3;
      v8 = 2080;
      v9 = "VideoTransmitter_PauseEncoder";
      v10 = 1024;
      v11 = 5968;
      _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d ", (uint8_t *)&v6, 0x1Cu);
    }
  }
  atomic_store(0, v2 + 776);
  *v2 = 1;
  v2[272] = 0;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v1 + 17496));
  VCRealTimeThread_Stop(*(_QWORD *)(v1 + 17480));
  if (*(_QWORD *)(v1 + 1632) != 0xFFFFFFFFLL)
  {
    (*(void (**)(void))(*(_QWORD *)(v1 + 1616) + 8))();
    *(_QWORD *)(v1 + 1632) = 0xFFFFFFFFLL;
  }
  CheckOutHandleDebug();
  return 0;
}

uint64_t VideoTransmitter_ResumeEncoder()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  uint64_t Encoder;
  unsigned int v6;
  _DWORD *v7;
  uint64_t v8;
  NSObject *v9;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  __int16 v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v0 = CheckInHandleDebug();
  if (!v0)
    return 2149449730;
  v1 = v0;
  v2 = v0 + 16620;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v3 = VRTraceErrorLogLevelToCSTR();
    v4 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v13 = 136315650;
      v14 = v3;
      v15 = 2080;
      v16 = "VideoTransmitter_ResumeEncoder";
      v17 = 1024;
      v18 = 5989;
      _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d ", (uint8_t *)&v13, 0x1Cu);
    }
  }
  atomic_store(1u, (unsigned __int8 *)(v2 + 1644));
  *(_BYTE *)(v2 + 868) = 0;
  if (*(_QWORD *)(v1 + 1632) == 0xFFFFFFFFLL)
  {
    if (*(_BYTE *)(v2 + 364))
    {
      v6 = 0;
    }
    else if (*(_DWORD *)(v1 + 96))
    {
      v6 = 1;
    }
    else
    {
      v6 = *(_DWORD *)(v1 + 100) != 0;
    }
    if (*(_DWORD *)(v2 + 748))
      v7 = (_DWORD *)(v2 + 744);
    else
      v7 = (_DWORD *)v2;
    Encoder = _VideoTransmitter_CreateEncoder(v1, *(_DWORD *)(v1 + 24), *(_DWORD *)(v1 + 28), v1 + 104, *v7 != 0, v6);
    if ((Encoder & 0x80000000) != 0)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v8 = VRTraceErrorLogLevelToCSTR();
        v9 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v11 = *(_DWORD *)(v1 + 24);
          v12 = *(_DWORD *)(v1 + 28);
          v13 = 136316418;
          v14 = v8;
          v15 = 2080;
          v16 = "VideoTransmitter_ResumeEncoder";
          v17 = 1024;
          v18 = 5999;
          v19 = 1024;
          v20 = v11;
          v21 = 1024;
          v22 = v12;
          v23 = 1024;
          v24 = Encoder;
          _os_log_error_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_ERROR, " [%s] %s:%d VideoTransmitter_CreateHandle: EncCreateHandle FAILED %dx%d result: %d", (uint8_t *)&v13, 0x2Eu);
        }
      }
    }
    else
    {
      VCRealTimeThread_Start(*(_QWORD *)(v1 + 17480));
    }
  }
  else
  {
    VCRealTimeThread_Start(*(_QWORD *)(v1 + 17480));
    Encoder = 0;
  }
  CheckOutHandleDebug();
  return Encoder;
}

uint64_t VideoTransmitter_SetFECLevelPerGroupSizeVector(uint64_t a1, unint64_t a2, char *a3)
{
  uint64_t v5;
  _WORD *v6;
  uint64_t v7;
  int v8;
  char *v9;
  char v10;

  v5 = CheckInHandleDebug();
  if (!v5)
    return 2149449730;
  v6 = (_WORD *)(v5 + 16486);
  if (*(_BYTE *)(v5 + 18153))
  {
    v7 = 0;
  }
  else
  {
    v7 = VCFECGenerator_SetFECLevelPerGroupSizeVector(*(_QWORD *)(v5 + 18160), a2, a3);
    if (a2)
    {
      v8 = (unsigned __int16)*v6;
      v9 = a3 + 1;
      do
      {
        v10 = *v9;
        v9 += 2;
        v8 |= 1 << v10;
        --a2;
      }
      while (a2);
      *v6 = v8;
    }
  }
  CheckOutHandleDebug();
  return v7;
}

uint64_t VideoTransmitter_SetEncodingMode(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2149449730;
  if (*(_QWORD *)(v3 + 1632) == 0xFFFFFFFFLL)
    v4 = 2148007957;
  else
    v4 = (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)(v3 + 1616) + 64))(*(_QWORD *)(v3 + 1632), a2);
  CheckOutHandleDebug();
  return v4;
}

void _VideoTransmitter_GetStreamIndexFromAttachment(const void *a1, void *a2)
{
  const __CFNumber *v3;

  if (a2)
  {
    v3 = (const __CFNumber *)CMGetAttachment(a1, CFSTR("tileIndex"), 0);
    if (v3)
    {
      CFNumberGetValue(v3, kCFNumberSInt32Type, a2);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VideoTransmitter_GetStreamIndexFromAttachment_cold_1();
    }
  }
}

void OUTLINED_FUNCTION_15_3(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_debug_impl(a1, log, OS_LOG_TYPE_DEBUG, a4, (uint8_t *)va, 0x28u);
}

uint64_t VCSystemAudioCaptureController_PushAudioSamples(uint64_t a1, uint64_t a2)
{
  _QWORD v5[3];

  v5[2] = *MEMORY[0x1E0C80C00];
  v5[0] = 0xAAAAAAAAAAAAAAAALL;
  LODWORD(v5[0]) = *(double *)VCAudioBufferList_GetSampleFormat(a2);
  v5[1] = VCAudioBufferList_GetTimestamp(a2);
  VCAudioBufferList_SetPriority(a2, 255);
  VCAudioBufferList_SetVoiceActivity(a2, 1);
  return (*(uint64_t (**)(_QWORD, _QWORD *, uint64_t))(a1 + 8))(*(_QWORD *)a1, v5, a2);
}

void OUTLINED_FUNCTION_10_7(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_fault_impl(a1, log, OS_LOG_TYPE_FAULT, a4, (uint8_t *)va, 0x22u);
}

uint64_t OUTLINED_FUNCTION_12_4@<X0>(void *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  *(_QWORD *)(v2 - 24) = a2;
  return objc_msgSend(a1, "UTF8String");
}

unint64_t AudioPacketArray_Next(unint64_t result)
{
  uint64_t v1;
  unint64_t v2;

  v1 = *(unsigned int *)(result + 804);
  if (v1 >= *(_DWORD *)(result + 800))
    return 0;
  *(_DWORD *)(result + 804) = v1 + 1;
  v2 = result + 8 * v1;
  if (v2 < result + 800 && v2 >= result)
    return *(_QWORD *)v2;
  __break(0x5519u);
  return result;
}

uint64_t AudioPacketArray_First(_DWORD *a1)
{
  if (a1[200])
    return *(_QWORD *)a1;
  else
    return 0;
}

unint64_t AudioPacketArray_Last(unint64_t result)
{
  int v1;
  unint64_t v2;

  v1 = *(_DWORD *)(result + 800);
  if (!v1)
    return 0;
  v2 = result + 8 * (v1 - 1);
  if (v2 < result + 800 && v2 >= result)
    return *(_QWORD *)v2;
  __break(0x5519u);
  return result;
}

BOOL AudioPacketArray_Append(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(unsigned int *)(a1 + 800);
  if (v2 <= 0x63)
  {
    *(_DWORD *)(a1 + 800) = v2 + 1;
    *(_QWORD *)(a1 + 8 * v2) = a2;
  }
  return v2 < 0x64;
}

void VCMediaRecorder_AddLocalAudioSampleBuffer(uint64_t a1, uint64_t a2, int a3)
{
  double v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  __int16 v34;
  uint64_t v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (*(_BYTE *)(a1 + 228))
    {
      *(_DWORD *)(a1 + 252) = a3;
      ++*(_QWORD *)(a1 + 280);
      VCMediaRecorderHistory_AddAudioSampleBuffer(*(_QWORD *)(a1 + 192), a2, a3, 1);
      v4 = micro();
      if (v4 - *(double *)(a1 + 256) >= 5.0)
      {
        *(double *)(a1 + 256) = v4;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
        {
          v5 = VRTraceErrorLogLevelToCSTR();
          v6 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v7 = *(_QWORD *)(a1 + 264);
            v8 = *(_QWORD *)(a1 + 272);
            v9 = *(_QWORD *)(a1 + 280);
            v10 = *(_QWORD *)(a1 + 288);
            v11 = *(_QWORD *)(a1 + 296);
            v12 = *(_QWORD *)(a1 + 304);
            v13 = *(_QWORD *)(a1 + 312);
            v14 = 136317698;
            v15 = v5;
            v16 = 2080;
            v17 = "_VCMediaRecorder_LogHealth";
            v18 = 1024;
            v19 = 145;
            v20 = 2048;
            v21 = a1;
            v22 = 2048;
            v23 = v7;
            v24 = 2048;
            v25 = v8;
            v26 = 2048;
            v27 = v9;
            v28 = 2048;
            v29 = v10;
            v30 = 2048;
            v31 = v11;
            v32 = 2048;
            v33 = v12;
            v34 = 2048;
            v35 = v13;
            _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d @=@ Health: VCMediaRecorder instance=%p, localVideoCallbacksCount=%lu, localVideoCallbacksClearedCount=%lu, localAudioCallbacksCount=%lu, localAudioCallbacksClearedCount=%lu, remoteAudioCallbacksCount=%lu, remoteAudioCallbacksClearedCount=%lu, bufferResets=%lu", (uint8_t *)&v14, 0x6Cu);
          }
        }
      }
    }
  }
}

void VCMediaRecorder_AddRemoteAudioSampleBuffer(uint64_t a1, uint64_t a2, int a3)
{
  if (a1)
  {
    if (*(_BYTE *)(a1 + 228))
    {
      ++*(_QWORD *)(a1 + 296);
      VCMediaRecorderHistory_AddAudioSampleBuffer(*(_QWORD *)(a1 + 192), a2, a3, 0);
    }
  }
}

void VCMediaRecorder_AddLocalVideoSampleBuffer(uint64_t a1, opaqueCMSampleBuffer *a2, char a3, int a4)
{
  if (a1 && a2)
  {
    if (*(_BYTE *)(a1 + 228))
    {
      ++*(_QWORD *)(a1 + 264);
      VCMediaRecorderHistory_AddLocalVideoSampleBuffer(*(_QWORD *)(a1 + 192), a2, a3, a4);
    }
  }
}

void sub_1D8BF2700(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void VCMediaRecorder_UpdateTargetScreenAttributes(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  _QWORD block[7];

  block[6] = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = *(NSObject **)(a1 + 208);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = __VCMediaRecorder_UpdateTargetScreenAttributes_block_invoke;
    block[3] = &unk_1E9E52238;
    block[4] = a2;
    block[5] = a1;
    dispatch_sync(v2, block);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCMediaRecorder_UpdateTargetScreenAttributes_cold_1();
  }
}

void VCMediaRecorder_PrepareVideoSampleBuffer(uint64_t a1, opaqueCMSampleBuffer *a2)
{
  if (a1 && a2)
  {
    if (*(_BYTE *)(a1 + 228))
      VCMediaRecorderHistory_PrepareVideoSampleBuffer(*(_QWORD *)(a1 + 192), a2);
  }
}

void _VCMediaRecorder_DispatchedClearHistoryBuffer(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 208));
  ++*(_QWORD *)(a1 + 312);
  *(_QWORD *)(a1 + 272) = *(_QWORD *)(a1 + 264);
  *(_QWORD *)(a1 + 288) = *(_QWORD *)(a1 + 280);
  *(_QWORD *)(a1 + 304) = *(_QWORD *)(a1 + 296);
  VCMediaRecorderHistory_ClearHistoryBuffer(*(_QWORD *)(a1 + 192));
}

void VCMediaRecorder_StopProcessingAllRequests(uint64_t a1)
{
  NSObject *v1;
  uint64_t v2;
  NSObject *v3;
  _QWORD block[5];
  uint8_t buf[4];
  uint64_t v6;
  __int16 v7;
  const char *v8;
  __int16 v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v1 = *(NSObject **)(a1 + 208);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = __VCMediaRecorder_StopProcessingAllRequests_block_invoke;
    block[3] = &unk_1E9E521C0;
    block[4] = a1;
    dispatch_async(v1, block);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      v6 = v2;
      v7 = 2080;
      v8 = "VCMediaRecorder_StopProcessingAllRequests";
      v9 = 1024;
      v10 = 455;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", buf, 0x1Cu);
    }
  }
}

void VCMediaRecorder_ClearHistoryBuffer(uint64_t a1)
{
  NSObject *v1;
  uint64_t v2;
  NSObject *v3;
  _QWORD block[5];
  uint8_t buf[4];
  uint64_t v6;
  __int16 v7;
  const char *v8;
  __int16 v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v1 = *(NSObject **)(a1 + 208);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = __VCMediaRecorder_ClearHistoryBuffer_block_invoke;
    block[3] = &unk_1E9E521C0;
    block[4] = a1;
    dispatch_async(v1, block);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      v6 = v2;
      v7 = 2080;
      v8 = "VCMediaRecorder_ClearHistoryBuffer";
      v9 = 1024;
      v10 = 475;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", buf, 0x1Cu);
    }
  }
}

void sub_1D8BF86D4(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void VCAudioRedBuilder_UpdatePayloadHistory(uint64_t a1)
{
  unint64_t v2;
  uint64_t v3;
  int *v4;
  _BYTE *v5;
  uint64_t v6;
  int v7;
  int v8;
  __int128 v9;
  int v10;
  _DWORD *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int *v15;
  int v16;
  uint64_t v17;
  _BYTE *v18;
  char *v19;
  uint64_t v20;
  NSObject *v21;
  NSObject *v22;
  uint64_t v23;
  char *__lasts;
  char *__str;
  uint8_t buf[4];
  uint64_t v27;
  __int16 v28;
  const char *v29;
  __int16 v30;
  int v31;
  __int16 v32;
  const char *v33;
  __int16 v34;
  char *v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  if (a1 && *(_BYTE *)(a1 + 29))
  {
    v2 = 0;
    v3 = a1 + 32;
    v4 = (int *)(a1 + 84);
    v5 = (_BYTE *)(a1 + 94);
    v23 = a1 + 32;
    do
    {
      v6 = v3 + 344 * v2;
      v7 = *(_DWORD *)(v6 + 320);
      if ((v7 + 1) < 9)
        v8 = v7 + 1;
      else
        v8 = 9;
      *(_DWORD *)(v6 + 320) = v8;
      memmove((void *)(v6 + 64), (const void *)(v6 + 32), 32 * (v8 - 1));
      v9 = *(_OWORD *)(v6 + 16);
      *(_OWORD *)(v6 + 32) = *(_OWORD *)v6;
      *(_OWORD *)(v6 + 48) = v9;
      if (*(_BYTE *)(a1 + 28))
        v10 = 9 * *(_DWORD *)(a1 + 24);
      else
        v10 = 0x3FFF;
      v11 = (_DWORD *)(v6 + 320);
      v12 = *(unsigned int *)(v6 + 320);
      if ((_DWORD)v12)
      {
        v13 = 0;
        v14 = v10 - *(_DWORD *)(v6 + 20);
        v15 = v4;
        while (1)
        {
          v16 = *v15;
          v15 += 8;
          if ((v14 + v16) > 0x7FFFFFFE)
            break;
          if (v12 == ++v13)
            goto LABEL_17;
        }
        v12 = v13;
LABEL_17:
        *v11 = v12;
        if (v12)
        {
          v17 = 0;
          v18 = v5;
          do
          {
            *v18 = ++v17;
            v18 += 32;
          }
          while (v12 != v17);
        }
      }
      else
      {
        *v11 = 0;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        __str = 0;
        asprintf(&__str, "infoIndex=%u count=%d history=%s ", v2, *v11, (const char *)objc_msgSend((id)a1, "payloadHistoryDescriptionForInfoIndex:", v2));
        if (__str)
        {
          __lasts = 0;
          v19 = strtok_r(__str, "\n", &__lasts);
          do
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
            {
              v20 = VRTraceErrorLogLevelToCSTR();
              v21 = *MEMORY[0x1E0CF2758];
              v22 = *MEMORY[0x1E0CF2758];
              if (*MEMORY[0x1E0CF2748])
              {
                if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 136316162;
                  v27 = v20;
                  v28 = 2080;
                  v29 = "VCAudioRedBuilder_UpdatePayloadHistory";
                  v30 = 1024;
                  v31 = 484;
                  v32 = 2080;
                  v33 = "VCAudioRedBuilder_UpdatePayloadHistory";
                  v34 = 2080;
                  v35 = v19;
                  _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, "VCAudioRedBuilder [%s] %s:%d %s %s", buf, 0x30u);
                }
              }
              else if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 136316162;
                v27 = v20;
                v28 = 2080;
                v29 = "VCAudioRedBuilder_UpdatePayloadHistory";
                v30 = 1024;
                v31 = 484;
                v32 = 2080;
                v33 = "VCAudioRedBuilder_UpdatePayloadHistory";
                v34 = 2080;
                v35 = v19;
                _os_log_debug_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEBUG, "VCAudioRedBuilder [%s] %s:%d %s %s", buf, 0x30u);
              }
            }
            v19 = strtok_r(0, "\n", &__lasts);
          }
          while (v19);
          free(__str);
          v3 = v23;
        }
      }
      ++v2;
      v4 += 86;
      v5 += 344;
    }
    while (v2 < *(unsigned __int8 *)(a1 + 29));
  }
}

uint64_t VCAudioRedBuilder_GetPrimaryPayloadAndAppendSamples(uint64_t a1, _BYTE *a2, int a3)
{
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unint64_t v9;
  uint64_t v10;
  const void **v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  NSObject *v15;
  int v17;
  int v18;
  uint64_t v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  _BYTE *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  int v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if (a1 && a2 && a3 != 128 && (v6 = *a2, *a2))
  {
    v7 = *(unsigned __int8 *)(a1 + 29);
    if (v7 > v6)
    {
      v8 = v7 - 1;
      do
        *(_DWORD *)(a1 + 32 + 344 * v8-- + 320) = 0;
      while (v6 <= v8);
    }
    v9 = 0;
    v10 = a1 + 32;
    *(_BYTE *)(a1 + 29) = v6;
    v11 = (const void **)(a2 + 16);
    v12 = a1;
    do
    {
      v13 = (void *)(*(_QWORD *)(v12 + 360) + 1472 * *(int *)(v12 + 368));
      memcpy(v13, *(v11 - 1), *(unsigned int *)v11);
      *(_DWORD *)(v12 + 368) = (*(_DWORD *)(v12 + 368) + 1) % 9;
      *(_QWORD *)(v12 + 40) = v13;
      *(_DWORD *)(v12 + 32) = a3;
      *(_QWORD *)(v12 + 48) = *v11;
      *(_BYTE *)(v12 + 63) = *((_BYTE *)v11 + 8);
      ++v9;
      v12 += 344;
      v11 += 3;
    }
    while (v9 < *(unsigned __int8 *)(a1 + 29));
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v14 = VRTraceErrorLogLevelToCSTR();
      v15 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        if (a2)
          v17 = *a2;
        else
          v17 = 0;
        v18 = 136316674;
        v19 = v14;
        v20 = 2080;
        v21 = "VCAudioRedBuilder_GetPrimaryPayloadAndAppendSamples";
        v22 = 1024;
        v23 = 557;
        v24 = 2048;
        v25 = a1;
        v26 = 2048;
        v27 = a2;
        v28 = 1024;
        v29 = v17;
        v30 = 1024;
        v31 = a3;
        _os_log_error_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_ERROR, "VCAudioRedBuilder [%s] %s:%d Invalid input. builder=%p input=%p input->arrayCount=%u externalPayloadType=%u", (uint8_t *)&v18, 0x3Cu);
      }
    }
    return 0;
  }
  return v10;
}

void sub_1D8BF928C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1D8BF9424(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t VCAudioRedBuilder_SplitRedAudioPacket(uint64_t a1, _DWORD *a2, uint64_t a3, int a4, int a5, int a6)
{
  unint64_t v7;
  uint64_t v10;
  unsigned int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  unint64_t v17;
  unsigned int v18;
  unsigned __int8 v19;
  int v20;
  unsigned int v21;
  uint64_t v22;
  NSObject *v23;
  NSObject *v24;
  uint64_t v25;
  unsigned int v27;
  _DWORD *v28;
  uint64_t v29;
  _DWORD *v30;
  int v31;
  _BYTE *v32;
  _DWORD *v33;
  uint8_t buf[4];
  uint64_t v37;
  __int16 v38;
  const char *v39;
  __int16 v40;
  int v41;
  __int16 v42;
  int v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (a2[6] != 20)
    return 0;
  v7 = (int)a2[379];
  if (!(_DWORD)v7)
  {
LABEL_16:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioRedBuilder_SplitRedAudioPacket_cold_1();
    }
    return 0;
  }
  v10 = 0;
  v33 = a2 + 11;
  v11 = a2[4];
  if (a4 <= 1)
    v12 = 1;
  else
    v12 = a4;
  v13 = (v12 - 1);
  v14 = a3 + 16;
  v15 = 11;
  while (SLOBYTE(a2[v15]) < 0)
  {
    v16 = v7 >= 4;
    v17 = v7 - 4;
    if (!v16 || v13 == v10)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCAudioRedBuilder_SplitRedAudioPacket_cold_3();
      }
      return 0;
    }
    v18 = bswap32(a2[v15]);
    v19 = RTPGetInternalPayload(a1, HIBYTE(v18) & 0x7F);
    LOBYTE(v20) = a6;
    if (a6)
    {
      v20 = (v18 >> 18) & 0x3F;
      v21 = (v18 >> 10) * a5 / 0x64;
    }
    else
    {
      v21 = (v18 >> 10) & 0x3FFF;
    }
    if ((unsigned __int16)(v18 & 0x3FF) > (int)v17)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCAudioRedBuilder_SplitRedAudioPacket_cold_4();
      }
      return 0;
    }
    *(_BYTE *)(v14 + 12) = 1;
    *(_DWORD *)(v14 - 16) = v19;
    v7 = v17 - (v18 & 0x3FF);
    *(_DWORD *)v14 = v18 & 0x3FF;
    *(_DWORD *)(v14 + 4) = v11 - v21;
    ++v15;
    *(_BYTE *)(v14 + 14) = v20;
    *(_DWORD *)(v14 + 8) = v11;
    v14 += 32;
    ++v10;
    if (!v7)
      goto LABEL_16;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() > 7)
  {
    v22 = VRTraceErrorLogLevelToCSTR();
    v23 = *MEMORY[0x1E0CF2758];
    v24 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        v37 = v22;
        v38 = 2080;
        v39 = "_VCAudioRedBuilder_SplitRedPacketIntoArray";
        v40 = 1024;
        v41 = 703;
        v42 = 1024;
        v43 = v10;
        _os_log_impl(&dword_1D8A54000, v23, OS_LOG_TYPE_DEFAULT, "VCAudioRedBuilder [%s] %s:%d redundant payloads count:%d", buf, 0x22u);
      }
    }
    else if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
    {
      VCAudioRedBuilder_SplitRedAudioPacket_cold_2();
    }
  }
  v27 = v15 * 4 - 43;
  if ((_DWORD)v10)
  {
    v28 = (_DWORD *)(a3 + 16);
    v29 = v10;
    v30 = v33;
    do
    {
      *((_QWORD *)v28 - 1) = (char *)v33 + v27;
      v31 = *v28;
      v28 += 8;
      v27 += v31;
      --v29;
    }
    while (v29);
  }
  else
  {
    v30 = v33;
  }
  v25 = v10 + 1;
  *(_QWORD *)(v14 - 8) = (char *)v30 + v27;
  *(_DWORD *)v14 = v7 - 1;
  *(_BYTE *)(v14 + 12) = 0;
  *(_DWORD *)(v14 - 16) = RTPGetInternalPayload(a1, a2[v15] & 0x7F);
  *(int32x2_t *)(v14 + 4) = vdup_n_s32(v11);
  if (!a6)
  {
    v32 = (_BYTE *)(a3 + 30);
    do
    {
      *v32 = v10;
      v32 += 32;
      --v10;
    }
    while (v10 != -1);
  }
  return v25;
}

BOOL VCAudioRedBuilder_UpdateAudioPacketWithRedPayload(uint64_t a1, int *a2)
{
  size_t v2;
  uint64_t v3;
  int v6;
  uint64_t v7;
  NSObject *v8;

  v3 = (uint64_t)(a2 + 4);
  v2 = a2[4];
  if ((int)v2 >= 1473)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v7 = VRTraceErrorLogLevelToCSTR();
      v8 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioRedBuilder_UpdateAudioPacketWithRedPayload_cold_1(v7, v3, v8);
    }
  }
  else
  {
    *(_BYTE *)(a1 + 12) = *((_BYTE *)a2 + 28);
    *(_DWORD *)(a1 + 16) = a2[5];
    v6 = *a2;
    *(_DWORD *)(a1 + 24) = *a2;
    *(_DWORD *)(a1 + 28) = v6;
    memcpy((void *)(a1 + 44), *((const void **)a2 + 1), v2);
    *(_DWORD *)(a1 + 1516) = a2[4];
    *(_WORD *)(a1 + 14) -= *((unsigned __int8 *)a2 + 30);
    *(_DWORD *)(a1 + 20) = a2[6];
  }
  return (int)v2 < 1473;
}

BOOL VTU_MoveAndInsertData(_DWORD *a1, int a2, int a3, const void *a4, int a5)
{
  int v5;
  int v6;
  char *v10;
  size_t v11;

  v5 = a1[8];
  v6 = a3 + a2 + a5;
  if (v6 > v5)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VTU_MoveAndInsertData_cold_1();
    }
  }
  else
  {
    v10 = (char *)a1 + a2 + 40;
    v11 = a5;
    memmove(&v10[a5], v10, a3);
    memcpy(v10, a4, v11);
    *a1 += a5;
  }
  return v6 <= v5;
}

BOOL VTU_ReallocPktsInfo(void **a1, void **a2, unsigned int *a3, void **a4, void **a5, unsigned int a6)
{
  uint64_t v12;
  int v13;
  int v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  const char *v19;
  NSObject *v20;
  uint32_t v21;
  _BOOL8 result;
  uint64_t v23;
  NSObject *v24;
  void *v25;
  void *v26;
  int ErrorLogLevelForModule;
  os_log_t *v28;
  uint64_t v29;
  NSObject *v30;
  int v31;
  uint64_t v32;
  __int16 v33;
  const char *v34;
  __int16 v35;
  int v36;
  __int16 v37;
  _BYTE v38[10];
  void *v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v12 = *a3;
  if ((_DWORD)v12 || !*a1 && !*a2)
  {
    if (a6 >= 0x1F41)
    {
      ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
      v28 = (os_log_t *)MEMORY[0x1E0CF2758];
      if (ErrorLogLevelForModule >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled(*v28, OS_LOG_TYPE_ERROR))
          VTU_ReallocPktsInfo_cold_6();
      }
      *a3 = 0;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled(*v28, OS_LOG_TYPE_ERROR))
          VTU_ReallocPktsInfo_cold_5();
      }
    }
    else
    {
      v13 = 2 * v12;
      if ((2 * v12) >= 0x1F40)
        v13 = 8000;
      if (!(_DWORD)v12)
        v13 = 100;
      if (a6 <= 0x64)
        v14 = 100;
      else
        v14 = a6;
      if (a6)
        v15 = v14;
      else
        v15 = v13;
      if (v15 <= v12)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() < 7)
          return 1;
        v29 = VRTraceErrorLogLevelToCSTR();
        v30 = *MEMORY[0x1E0CF2758];
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          return 1;
        v31 = 136316162;
        v32 = v29;
        v33 = 2080;
        v34 = "VTU_ReallocPktsInfo";
        v35 = 1024;
        v36 = 1200;
        v37 = 1024;
        *(_DWORD *)v38 = a6;
        *(_WORD *)&v38[4] = 1024;
        *(_DWORD *)&v38[6] = v12;
        v19 = " [%s] %s:%d VTU_ReallocPktsInfo requested %d. Already have larger %d pkts.";
        v20 = v30;
        v21 = 40;
        goto LABEL_21;
      }
      v16 = 4 * v12;
      if (_VTU_ReallocateBuffer(a1, 4 * v12, 4 * v15))
      {
        if (_VTU_ReallocateBuffer(a2, v16, 4 * v15))
        {
          if (_VTU_ReallocateBuffer(a5, v16, 4 * v15))
          {
            if (_VTU_ReallocateBuffer(a4, v16, 4 * v15))
            {
              *a3 = v15;
              if ((int)VRTraceGetErrorLogLevelForModule() < 6)
                return 1;
              v17 = VRTraceErrorLogLevelToCSTR();
              v18 = *MEMORY[0x1E0CF2758];
              if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                return 1;
              v31 = 136315906;
              v32 = v17;
              v33 = 2080;
              v34 = "VTU_ReallocPktsInfo";
              v35 = 1024;
              v36 = 1216;
              v37 = 1024;
              *(_DWORD *)v38 = v15;
              v19 = " [%s] %s:%d VTU_ReallocPktsInfo succeeded for %d elements.";
              v20 = v18;
              v21 = 34;
LABEL_21:
              _os_log_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_DEFAULT, v19, (uint8_t *)&v31, v21);
              return 1;
            }
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                VTU_ReallocPktsInfo_cold_1();
            }
          }
          else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VTU_ReallocPktsInfo_cold_2();
          }
        }
        else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VTU_ReallocPktsInfo_cold_3();
        }
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VTU_ReallocPktsInfo_cold_4();
      }
    }
    result = 0;
    *a3 = 0;
    return result;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() < 3)
    return 0;
  v23 = VRTraceErrorLogLevelToCSTR();
  v24 = *MEMORY[0x1E0CF2758];
  result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
  if (result)
  {
    v25 = *a1;
    v26 = *a2;
    v31 = 136316162;
    v32 = v23;
    v33 = 2080;
    v34 = "VTU_ReallocPktsInfo";
    v35 = 1024;
    v36 = 1192;
    v37 = 2048;
    *(_QWORD *)v38 = v25;
    *(_WORD *)&v38[8] = 2048;
    v39 = v26;
    _os_log_error_impl(&dword_1D8A54000, v24, OS_LOG_TYPE_ERROR, " [%s] %s:%d VTU_ReallocPktsInfo failed; iNewMaxPacketCount==0 BUT *ppiPacketSizes=%p *ppiPacketFlags=%p",
      (uint8_t *)&v31,
      0x30u);
    return 0;
  }
  return result;
}

BOOL _VTU_ReallocateBuffer(void **a1, uint64_t a2, size_t size)
{
  void *v6;
  int ErrorLogLevelForModule;
  uint64_t v8;
  NSObject *v9;
  _BOOL8 result;
  int v11;
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  uint64_t v18;
  __int16 v19;
  size_t v20;
  __int16 v21;
  void *v22;
  __int16 v23;
  size_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 1;
  v6 = malloc_type_realloc(*a1, size, 0x693CFAA9uLL);
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (v6)
  {
    if (ErrorLogLevelForModule >= 6)
    {
      v8 = VRTraceErrorLogLevelToCSTR();
      v9 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v11 = 136316674;
        v12 = v8;
        v13 = 2080;
        v14 = "_VTU_ReallocateBuffer";
        v15 = 1024;
        v16 = 1148;
        v17 = 2048;
        v18 = a2;
        v19 = 2048;
        v20 = size;
        v21 = 2048;
        v22 = v6;
        v23 = 2048;
        v24 = (size_t)v6 + size;
        _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d _VTU_ReallocateBuffer.....Reallocing buffer of size %zu to %zu from [%p, %p)", (uint8_t *)&v11, 0x44u);
      }
    }
    *a1 = v6;
    return 1;
  }
  if (ErrorLogLevelForModule < 3)
    return 0;
  VRTraceErrorLogLevelToCSTR();
  result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
  if (result)
  {
    _VTU_ReallocateBuffer_cold_1();
    return 0;
  }
  return result;
}

uint64_t VTU_GetOverhead(int a1, int a2, int a3, int a4)
{
  int WorstCaseNetworkOverhead;
  int FacetimeNetworkOverhead;
  int v8;
  int v9;

  if (a1)
  {
    WorstCaseNetworkOverhead = VCConnection_GetWorstCaseNetworkOverhead(a1, 1);
  }
  else
  {
    FacetimeNetworkOverhead = VCConnection_GetFacetimeNetworkOverhead(a4);
    if (a2)
      v8 = 16;
    else
      v8 = 0;
    if (a3)
      v9 = 16;
    else
      v9 = 0;
    WorstCaseNetworkOverhead = v9 + v8 + FacetimeNetworkOverhead;
  }
  return (WorstCaseNetworkOverhead + 12);
}

uint64_t VTU_CreatePacketAllocator(uint64_t a1, uint64_t a2, CFAllocatorRef *a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t i;
  _OWORD v8[2];
  uint64_t v9;
  unint64_t v10[2];
  __int128 v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v10[0] = 2;
  v10[1] = a1 + 40;
  v11 = xmmword_1D910C100;
  v4 = VCAllocatorMultiQueue_Create((const __CFAllocator *)*MEMORY[0x1E0C9AE00], (uint64_t)"VCVideoTransmitterPacketAllocator", 4u, v10, a3);
  if (!(_DWORD)v4)
  {
    v5 = 0;
    v9 = 0;
    memset(v8, 0, sizeof(v8));
    do
    {
      _VTU_AllocateVPList(*a3, 2000000, (_OWORD *)((char *)v8 + v5));
      v5 += 8;
    }
    while (v5 != 40);
    for (i = 0; i != 40; i += 8)
      _VTU_FreeVPList(*(_QWORD **)((char *)v8 + i));
  }
  return v4;
}

BOOL _VTU_AllocateVPList(const __CFAllocator *a1, uint64_t a2, _QWORD *a3)
{
  char *v6;
  CFTypeRef v7;

  v6 = (char *)CFAllocatorAllocate(a1, a2 + 40, 0);
  if (v6)
  {
    if (a1)
      v7 = CFRetain(a1);
    else
      v7 = 0;
    *((_QWORD *)v6 + 3) = 0;
    *((_QWORD *)v6 + 4) = a2;
    *((_QWORD *)v6 + 2) = v7;
    *(_QWORD *)v6 = 0;
    *(_DWORD *)(v6 + 7) = 0;
    *a3 = v6;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VTU_AllocateVPList_cold_1();
  }
  return v6 != 0;
}

void _VTU_FreeVPList(_QWORD *ptr)
{
  _QWORD *v1;
  _QWORD *v2;
  const __CFAllocator *v3;

  if (ptr)
  {
    v1 = ptr;
    do
    {
      v2 = v1;
      v1 = (_QWORD *)v1[3];
      v3 = (const __CFAllocator *)v2[2];
      CFAllocatorDeallocate(v3, v2);
      if (v3)
        CFRelease(v3);
    }
    while (v1);
  }
}

uint64_t VTU_HandleMTUOverride(uint64_t a1, unsigned int a2, uint64_t a3)
{
  int v5;
  int v6;
  uint64_t v7;
  NSObject *v8;
  int v9;
  int v11;
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  __int16 v23;
  unsigned int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 75))
  {
    v5 = (int)((double)a2 * 0.0666 * 0.125 + -66.0);
    if (*(_BYTE *)(a1 + 70))
    {
      v6 = (int)((double)a2 * 0.1 * 0.125 + -66.0);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v7 = VRTraceErrorLogLevelToCSTR();
        v8 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v11 = 136316674;
          v12 = v7;
          v13 = 2080;
          v14 = "VTU_HandleMTUOverride";
          v15 = 1024;
          v16 = 1274;
          v17 = 1024;
          v18 = a3;
          v19 = 1024;
          v20 = v5;
          v21 = 1024;
          v22 = v6;
          v23 = 1024;
          v24 = a2;
          _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VTU_SplitVideoIntoPackets: bEnableInitialMTUOverrideFor2G    MTU: %d %d->%d  Tx: %d", (uint8_t *)&v11, 0x34u);
        }
      }
    }
    else
    {
      v6 = (int)((double)a2 * 0.0666 * 0.125 + -66.0);
    }
    v9 = (int)fmax((double)v6, 233.7);
    if (v9 >= (int)a3)
      return a3;
    else
      return v9;
  }
  return a3;
}

uint64_t VTU_SplitVideoIntoPackets(unsigned __int16 **a1, int32_t a2, char *a3, int a4, void **a5, uint64_t a6, int a7, int a8, int a9, int a10, unsigned int a11, int a12)
{
  uint64_t v12;
  void **v13;
  uint64_t v15;
  int v16;
  BOOL v17;
  int v18;
  unsigned int v19;
  int v20;
  int v21;
  unsigned __int16 **v22;
  int v23;
  int v24;
  float v25;
  double v26;
  int v27;
  int v28;
  uint64_t v29;
  NSObject *v30;
  int v31;
  int32_t v32;
  int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  int v38;
  char v39;
  uint64_t v40;
  unsigned int *v41;
  unsigned int v42;
  unsigned int v43;
  uint64_t v44;
  NSObject *v45;
  unsigned __int16 *v46;
  uint64_t v47;
  int FrameSliceHeader;
  uint64_t v49;
  NSObject *v50;
  unsigned __int16 *v51;
  int v52;
  int v53;
  char *v54;
  unsigned int v55;
  uint64_t v56;
  int v57;
  _BOOL4 v58;
  int v59;
  signed int v60;
  uint64_t v61;
  uint64_t v62;
  int v63;
  _DWORD *v64;
  uint64_t v65;
  int *v66;
  int v67;
  void **v68;
  void **v69;
  unsigned int *v70;
  int v71;
  unsigned int v72;
  const __CFAllocator *v73;
  unint64_t v74;
  int v75;
  unsigned int v76;
  int v77;
  BOOL v78;
  _QWORD *v79;
  unint64_t v80;
  int v81;
  int v82;
  uint64_t i;
  int v84;
  uint64_t v85;
  int v86;
  int v87;
  unsigned int v88;
  const __CFAllocator *v89;
  unint64_t v90;
  int v91;
  unsigned int v92;
  int v93;
  BOOL v94;
  _BYTE *v95;
  char v96;
  unsigned __int16 **v97;
  _DWORD *v98;
  int v99;
  int v100;
  BOOL v101;
  BOOL v102;
  int v103;
  int v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  int v108;
  unsigned int v109;
  uint64_t v110;
  int ProbePktSize;
  void **v112;
  unsigned int *v113;
  void **v114;
  BOOL v115;
  uint64_t v116;
  NSObject *v117;
  unsigned int *v118;
  void **v119;
  unsigned int v120;
  uint64_t v121;
  int v122;
  int *v123;
  uint64_t v124;
  int v125;
  int v126;
  int v127;
  unsigned int *v128;
  int v129;
  unsigned int *v130;
  unsigned __int16 *v131;
  int v132;
  int v133;
  unsigned int *v134;
  unsigned __int16 *v135;
  unsigned int v136;
  unsigned int v137;
  uint64_t v138;
  unsigned int *v139;
  unint64_t v140;
  int v141;
  size_t v142;
  unsigned int v143;
  unint64_t v144;
  unint64_t v145;
  unsigned int *v146;
  int v147;
  size_t v148;
  int v149;
  int v150;
  unsigned int v151;
  int v152;
  unsigned int v153;
  uint64_t v154;
  int v155;
  size_t v156;
  int v157;
  char *v158;
  unint64_t v159;
  uint64_t *v160;
  int v161;
  uint64_t v162;
  void *v163;
  uint64_t v164;
  int v165;
  unsigned int *v166;
  int v167;
  int v168;
  int v169;
  int v170;
  unsigned int *v171;
  unsigned int *v172;
  unsigned __int16 *v173;
  int v174;
  int v175;
  _QWORD *v176;
  unsigned __int16 *v177;
  unsigned int v178;
  unsigned int v179;
  size_t v180;
  unsigned int v181;
  unint64_t v182;
  unint64_t v183;
  int v184;
  int v185;
  int v186;
  char *v187;
  int v188;
  int *v189;
  int *v190;
  uint64_t v191;
  char *v192;
  size_t v193;
  _QWORD *v194;
  int v195;
  unsigned int *v196;
  size_t v197;
  char v198;
  size_t v199;
  int v200;
  char v201;
  _QWORD *v202;
  char *v203;
  int v204;
  int v206;
  int v207;
  int v208;
  int v209;
  uint64_t v210;
  char v211;
  int v212;
  int v213;
  char *v214;
  unint64_t v215;
  uint64_t *v216;
  int H264Fragment;
  void **v218;
  int ErrorLogLevelForModule;
  int v220;
  _QWORD *v221;
  _QWORD *v222;
  void *v223;
  uint64_t v224;
  int v225;
  unsigned int *v226;
  int v227;
  int v228;
  uint64_t v229;
  NSObject *v230;
  int v232;
  int v233;
  int v234;
  int v235;
  char v236;
  int v237;
  _QWORD *ptr;
  size_t __n;
  int v240;
  int v241;
  char v242;
  void **v243;
  void **v244;
  uint64_t v245;
  unsigned int *v246;
  unsigned int *v247;
  int v248;
  void **v249;
  void **v250;
  void **v251;
  int v252;
  int v253;
  void **v254;
  void **v255;
  void **v256;
  int v257;
  __int16 v258;
  int v259;
  int v260;
  int v261;
  unsigned int v262;
  int v263;
  char v264;
  char *v266;
  int v267;
  uint64_t v268;
  uint64_t v269;
  int v271;
  int v272;
  int v274;
  unsigned int v275;
  int v276;
  char v277;
  int v278;
  int v280;
  int v281;
  size_t v282;
  unsigned __int16 v285;
  CFTypeRef cf;
  unsigned __int16 __src;
  _BYTE buf[12];
  __int16 v289;
  const char *v290;
  __int16 v291;
  int v292;
  __int16 v293;
  int v294;
  __int16 v295;
  int v296;
  __int16 v297;
  int v298;
  __int16 v299;
  int v300;
  __int16 v301;
  int v302;
  _OWORD v303[12];
  uint64_t v304;
  _DWORD v305[48];
  uint64_t v306;
  uint64_t v307;

  v12 = 0;
  v307 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return v12;
  v13 = a5;
  if (!a5)
    return v12;
  *a5 = 0;
  v15 = *((unsigned __int16 *)a1 + 36);
  v306 = 0;
  memset(v305, 0, sizeof(v305));
  v304 = 0;
  memset(v303, 0, sizeof(v303));
  v16 = *((_DWORD *)a1 + 14);
  if (a10 && a12)
  {
    if ((a12 - 3) >= 3)
    {
      v18 = a4 + 3;
      if (a4 + 3 < 0)
        v18 = a4 + 6;
      v19 = v18 >> 2;
      if (a4 >= 4 * (int)v15)
        v19 = v15;
      v20 = 0;
      if ((a12 - 1) <= 1)
        v15 = v19;
      else
        v15 = v15;
    }
    else
    {
      v17 = v16 >= 1 || (int)v15 <= a4;
      if (v17)
      {
        v20 = 0;
        if (3 * (int)v15 > a4)
          v15 = ((a4 + 2) / 3);
        else
          v15 = v15;
      }
      else
      {
        v20 = 0;
      }
    }
  }
  else if ((int)((double)a11 * 0.00375) <= 250)
  {
    v20 = 250;
  }
  else
  {
    v20 = (int)((double)a11 * 0.00375);
  }
  v21 = VTU_HandleMTUOverride((uint64_t)a1, a11, v15);
  v22 = a1;
  v23 = v21;
  v24 = *((unsigned __int8 *)a1 + 68);
  if (v16 >= 1)
  {
    v25 = FECUtil_FECLevelofProtectionToRateRatio(a12);
    v22 = a1;
    v26 = v25;
    v27 = *((_DWORD *)a1 + 16);
    if (v27 != *((_DWORD *)a1 + 15) || (v28 = *((_DWORD *)a1 + 14), v28 * v27 > (int)((double)a4 * v26)))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v29 = VRTraceErrorLogLevelToCSTR();
        v30 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v185 = *((_DWORD *)a1 + 15);
          v184 = *((_DWORD *)a1 + 16);
          v186 = *((_DWORD *)a1 + 14);
          *(_DWORD *)buf = 136316930;
          *(_QWORD *)&buf[4] = v29;
          v289 = 2080;
          v290 = "VTU_SplitVideoIntoPackets";
          v291 = 1024;
          v292 = 1362;
          v293 = 1024;
          v294 = v184;
          v295 = 1024;
          v296 = v185;
          v297 = 1024;
          v298 = v186;
          v299 = 1024;
          v300 = a4;
          v301 = 1024;
          v302 = (int)((double)a4 * v26);
          _os_log_error_impl(&dword_1D8A54000, v30, OS_LOG_TYPE_ERROR, " [%s] %s:%d CU_SplitVideoIntoPackets failed sanity check!: iProbeSeqPacketSize = %d iProbeSeqFirstPacketSize = %d iProbeSeqPacketCount = %d len = %d lenWithFEC = %d", buf, 0x3Au);
        }
      }
      return 0;
    }
    if (a4 / v28 + 1 < v23)
      v23 = a4 / v28 + 1;
  }
  v31 = a4 - 4;
  v278 = v23;
  v267 = v24;
  v32 = a2;
  v257 = a4;
  if (a4 >= 4)
  {
    v260 = v20;
    v254 = v13;
    v36 = 0;
    v37 = 0;
    v38 = 0;
    v248 = 0;
    v39 = 0;
    do
    {
      v40 = 0;
      while (1)
      {
        if (v36 + v40 == 50)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VTU_SplitVideoIntoPackets_cold_19();
          }
          return 0;
        }
        v41 = (unsigned int *)&a3[v37];
        v42 = bswap32(*v41);
        if (v42 > v31 - v37)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VTU_SplitVideoIntoPackets_cold_20();
          }
          return 0;
        }
        v305[v36 + v40] = v37;
        v43 = v42 + 4;
        *((_DWORD *)v303 + v36 + v40) = v42 + 4;
        if ((v37 == 0) | v39 & 1)
          break;
        if (!v38)
        {
          v39 = 0;
          v23 = v278;
          goto LABEL_70;
        }
        cf = 0;
        if (ReadFrameSliceHeader(v32, (uint64_t)(v41 + 1), v42, (CFDictionaryRef *)&cf) == 1)
        {
          if (*(_DWORD *)a1[2] >= (int)*((unsigned __int16 *)a1 + 4))
          {
            pthread_mutex_unlock((pthread_mutex_t *)a1[3]);
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                VTU_SplitVideoIntoPackets_cold_21();
            }
            return 0;
          }
          __src = -21846;
          v285 = -21846;
          if (RetrieveMBSliceTypeFromFrameInfoDict((CFDictionaryRef)cf, &__src, &v285))
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
            {
              v44 = VRTraceErrorLogLevelToCSTR();
              v45 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315650;
                *(_QWORD *)&buf[4] = v44;
                v289 = 2080;
                v290 = "VTU_SplitVideoIntoPackets";
                v291 = 1024;
                v292 = 1467;
                _os_log_impl(&dword_1D8A54000, v45, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VTU_SplitVideoIntoPackets: FRAMEHEADER_SLICEINFO bad RetrieveMBSlice", buf, 0x1Cu);
              }
            }
          }
          else
          {
            v46 = a1[2];
            v47 = *(int *)v46;
            (*a1)[v47] = __src;
            *(_DWORD *)v46 = v47 + 1;
          }
        }
        if (cf)
          CFRelease(cf);
        v39 = 0;
        v37 += v43;
        ++v40;
        v38 = 1;
        v22 = a1;
        v32 = a2;
        if (v37 > v31)
        {
          v34 = v36 + v40;
          v13 = v254;
          v35 = a6;
          v23 = v278;
          goto LABEL_79;
        }
      }
      v245 = v36;
      cf = 0;
      FrameSliceHeader = ReadFrameSliceHeader(v32, (uint64_t)(v41 + 1), v42, (CFDictionaryRef *)&cf);
      v248 = FrameSliceHeader;
      if ((FrameSliceHeader - 2) >= 2)
      {
        if (FrameSliceHeader == 5)
          v39 = 1;
        v22 = a1;
        v23 = v278;
      }
      else
      {
        __src = -21846;
        v285 = -21846;
        if (RetrieveResolutionFromFrameInfoDict((CFDictionaryRef)cf, &__src, &v285))
        {
          if ((int)VRTraceGetErrorLogLevelForModule() < 5)
          {
            v22 = a1;
            v23 = v278;
          }
          else
          {
            v49 = VRTraceErrorLogLevelToCSTR();
            v50 = *MEMORY[0x1E0CF2758];
            v23 = v278;
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315650;
              *(_QWORD *)&buf[4] = v49;
              v289 = 2080;
              v290 = "VTU_SplitVideoIntoPackets";
              v291 = 1024;
              v292 = 1422;
              _os_log_impl(&dword_1D8A54000, v50, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VTU_SplitVideoIntoPackets: FRAMEHEADER_IMGDESC/SPS bad RetrieveMBSlice", buf, 0x1Cu);
            }
            v22 = a1;
          }
        }
        else
        {
          v22 = a1;
          v23 = v278;
          if (**a1 != __src || (*a1)[1] != v285)
          {
            pthread_mutex_lock((pthread_mutex_t *)a1[3]);
            v22 = a1;
            v51 = *a1;
            *v51 = __src;
            v51[1] = v285;
            *(_DWORD *)a1[2] = 2;
            v38 = 1;
          }
        }
        v39 = 0;
      }
      if (cf)
      {
        CFRelease(cf);
        v22 = a1;
      }
      v32 = a2;
      v36 = v245;
LABEL_70:
      v37 += v43;
      v36 += v40 + 1;
    }
    while (v37 <= v31);
    v35 = a6;
    v34 = v36;
    if (v38)
    {
      v13 = v254;
LABEL_79:
      v33 = v248;
      pthread_mutex_unlock((pthread_mutex_t *)v22[3]);
      v22 = a1;
      v20 = v260;
      v24 = v267;
      v32 = a2;
    }
    else
    {
      v13 = v254;
      v20 = v260;
      v24 = v267;
      v33 = v248;
    }
  }
  else
  {
    v33 = 0;
    v34 = 0;
    v35 = a6;
  }
  if (a7 <= 0)
  {
    v54 = a3;
    *v13 = a3;
    goto LABEL_108;
  }
  if (v33 == 1)
  {
    if (v34 % a8)
      goto LABEL_104;
    v53 = 0;
    v52 = v34;
  }
  else
  {
    if (v33 != 3 && v33 != 2)
      goto LABEL_104;
    v52 = v34 - 1;
    if (((v34 - 1) & 3) != 0)
      goto LABEL_104;
    v53 = 1;
  }
  v55 = v52 / a8;
  if (v52 / a8 >= 1)
  {
    v56 = 0;
    v57 = 0;
    v58 = 0;
    v59 = v55 + v53;
    do
    {
      if (v56 == a9 || !*(_DWORD *)(v35 + 4 * v56))
      {
        v60 = v59 + v55;
        if ((int)(v59 + v55) < v34)
        {
          v61 = v60;
          v62 = -4 * v55 + 4 * v60;
          do
          {
            *(_DWORD *)((char *)v305 + v62) = v305[v61];
            *(_DWORD *)((char *)v303 + v62) = *((_DWORD *)v303 + v61++);
            v62 += 4;
          }
          while (v61 < v34);
        }
        v34 -= v55;
        v58 = 1;
      }
      else
      {
        v59 += v55;
        v101 = !v58;
        v58 = v58;
        if (!v101)
          v57 = 1;
      }
      ++v56;
    }
    while (v56 != 3);
    if (v59 >= 51)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VTU_SplitVideoIntoPackets_cold_17();
      }
      return 0;
    }
    if (v57)
    {
      v121 = v59;
      if (v59 < 1)
      {
        v122 = 0;
      }
      else
      {
        v122 = 0;
        v123 = (int *)v303;
        v124 = v59;
        do
        {
          v125 = *v123++;
          v122 += v125;
          --v124;
        }
        while (v124);
      }
      v187 = (char *)CFAllocatorAllocate((CFAllocatorRef)v22[10], v122, 0);
      if (!v187)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VTU_SplitVideoIntoPackets_cold_18();
        }
        return 0;
      }
      v54 = v187;
      if (v59 <= 0)
      {
        v257 = 0;
        *v13 = v187;
        v305[0] = 0;
        v34 = v59;
        v22 = a1;
        v23 = v278;
        v32 = a2;
        goto LABEL_108;
      }
      v263 = v20;
      v188 = 0;
      v189 = (int *)v303;
      v190 = v305;
      do
      {
        v191 = *v190++;
        v192 = &a3[v191];
        v193 = *v189++;
        memcpy(&v54[v188], v192, v193);
        v188 += v193;
        --v121;
      }
      while (v121);
      v257 = v188;
      v34 = v59;
      v22 = a1;
      v23 = v278;
      v20 = v263;
      v24 = v267;
      v32 = a2;
    }
    else
    {
      v54 = a3;
      v34 = v59;
      v23 = v278;
    }
    goto LABEL_105;
  }
LABEL_104:
  v54 = a3;
LABEL_105:
  *v13 = v54;
  v305[0] = 0;
  if (v34 > 1)
  {
    v63 = 0;
    v64 = &v305[1];
    v65 = v34 - 1;
    v66 = (int *)v303;
    do
    {
      v67 = *v66++;
      v63 += v67;
      *v64++ = v63;
      --v65;
    }
    while (v65);
  }
LABEL_108:
  if (v32 != 123 && v32 != 100)
  {
    if (v34 > 1)
    {
      v80 = v34;
      while (1)
      {
        v81 = 1;
        if (v80 >= 3)
        {
          v82 = DWORD1(v303[0]);
          for (i = 2; i != v80; ++i)
          {
            v84 = *((_DWORD *)v303 + i);
            if (v82 + v84 < *((_DWORD *)v303 + v81 - 1) + *((_DWORD *)v303 + v81))
              v81 = i;
            v82 = v84;
          }
        }
        v85 = v81 - 1;
        v86 = *((_DWORD *)v303 + v85) + *((_DWORD *)v303 + v81);
        if (v86 > v23)
          break;
        *((_DWORD *)v303 + v85) = v86;
        LODWORD(v85) = v81 + 1;
        if ((uint64_t)v80 > v81 + 1)
        {
          v85 = (int)v85;
          do
            *((_DWORD *)v303 + v81++) = *((_DWORD *)v303 + v85++);
          while (v85 < (uint64_t)v80);
        }
        v17 = v80-- > 2;
        if (!v17)
        {
          v34 = 1;
          goto LABEL_169;
        }
      }
      v34 = v80;
    }
    if (v34 >= 1)
    {
LABEL_169:
      v12 = 0;
      v99 = 0;
      v276 = v23 - 1;
      v271 = v34;
      v261 = v20;
      while (1)
      {
        v100 = *((_DWORD *)v303 + v99);
        if (v100)
        {
          if (!v24 && (v100 > v20 ? (v101 = v34 == 1) : (v101 = 0), v101 ? (v102 = v100 < v278) : (v102 = 0), v102))
          {
            v103 = 0;
            v104 = 2;
          }
          else
          {
            v104 = (v276 + v100) / v278;
            if (!v104)
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                v116 = VRTraceErrorLogLevelToCSTR();
                v117 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136315650;
                  *(_QWORD *)&buf[4] = v116;
                  v289 = 2080;
                  v290 = "VTU_SplitVideoIntoPackets";
                  v291 = 1024;
                  v292 = 1730;
                  _os_log_error_impl(&dword_1D8A54000, v117, OS_LOG_TYPE_ERROR, " [%s] %s:%d \"parts\" is zero while trying to calculate \"each = (bytes / parts) + 1\"", buf, 0x1Cu);
                }
              }
              v22 = a1;
              goto LABEL_208;
            }
            v103 = v100 / v104 + 1;
          }
          if (v104 >= 1 && v100 >= 1)
            break;
        }
LABEL_208:
        if (++v99 >= v34)
          return v12;
      }
      v105 = 0;
      v106 = (int)v12;
      v281 = v12;
      v107 = 4 * (int)v12;
      while (1)
      {
        v108 = v100 - 50;
        if (v103)
        {
          v108 = v103;
          v109 = v103;
        }
        else
        {
          v109 = 50;
        }
        if (v103 > v100)
        {
          v110 = v100;
        }
        else
        {
          v103 = v108;
          v110 = v109;
        }
        if (!(v105 | v99) && *((_BYTE *)v22 + 69))
        {
          ProbePktSize = Throttling_VideoTransmitterUtil_ForceFirstProbePktSize(v100, v110);
          v22 = a1;
          LODWORD(v110) = ProbePktSize;
        }
        v112 = (void **)v22[5];
        v113 = (unsigned int *)v22[6];
        v114 = (void **)v22[4];
        if (v106 + v105 >= (int)*v113)
        {
          if (!VTU_ReallocPktsInfo(v114, v112, v113, 0, 0, 0))
          {
            v12 = (v281 + v105 + 1);
            v34 = v271;
            v99 = v271;
            v22 = a1;
LABEL_207:
            v20 = v261;
            v24 = v267;
            goto LABEL_208;
          }
          v22 = a1;
          v114 = (void **)a1[4];
          v112 = (void **)a1[5];
        }
        *(_DWORD *)((char *)*v114 + 4 * v105 + v107) = v110;
        *(_DWORD *)((char *)*v112 + 4 * v105 + v107) = (2 * ((_DWORD)v105 == 0)) | (v104 - 1 == (_DWORD)v105);
        if ((int)++v105 < v104)
        {
          v115 = __OFSUB__(v100, (_DWORD)v110);
          v100 -= v110;
          if (!((v100 < 0) ^ v115 | (v100 == 0)))
            continue;
        }
        v12 = (v281 + v105);
        v34 = v271;
        goto LABEL_207;
      }
    }
    return 0;
  }
  *v13 = 0;
  v69 = (void **)v22[4];
  v68 = (void **)v22[5];
  v70 = (unsigned int *)v22[6];
  if (v32 != 100)
  {
    v252 = *((unsigned __int8 *)v22 + 69);
    v87 = *((unsigned __int8 *)v22 + 76);
    v88 = *((unsigned __int16 *)v22 + 39);
    v89 = (const __CFAllocator *)v22[10];
    cf = 0;
    if (!v257)
    {
      if (!v87)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VTU_SplitVideoIntoPackets_cold_9();
        }
        goto LABEL_435;
      }
      v95 = CFAllocatorAllocate(v89, 2, 0);
      *v13 = v95;
      if (v95)
      {
        v96 = 12;
        goto LABEL_156;
      }
LABEL_223:
      v34 = 0;
      LODWORD(v68) = 0;
      goto LABEL_436;
    }
    v244 = v68;
    v247 = v70;
    v280 = v87;
    if (v34 <= 0)
    {
      v256 = v13;
      v258 = __rev16(v88);
      __src = v258;
      v120 = 2 * (v87 != 0);
    }
    else
    {
      v275 = v88;
      v250 = v69;
      v90 = 0;
      do
      {
        v91 = *((_DWORD *)v303 + v90);
        if (v91 <= v23)
          v92 = v23;
        else
          v92 = *((_DWORD *)v303 + v90);
        v93 = AddOneVPList((uint64_t *)&cf, v91, v305[v90++], (uint64_t)v54, v257, v92, v89);
        if (v93)
          v94 = 1;
        else
          v94 = v90 >= v34;
      }
      while (!v94);
      if (v93)
      {
LABEL_149:
        v79 = cf;
        goto LABEL_434;
      }
      v256 = v13;
      v87 = v280;
      v258 = __rev16(v275);
      __src = v258;
      v120 = 2 * (v280 != 0);
      if (v34 >= 2)
      {
        v169 = v23 - 5;
        v170 = v34;
        while (1)
        {
          v171 = (unsigned int *)cf;
          v172 = (unsigned int *)*((_QWORD *)cf + 3);
          if (!v172)
            break;
          v173 = (unsigned __int16 *)*((_QWORD *)v172 + 3);
          if (v173)
          {
            v174 = *v172;
            v175 = *(_DWORD *)cf;
            v176 = cf;
            v177 = (unsigned __int16 *)*((_QWORD *)cf + 3);
            do
            {
              v178 = *v172 + *(_DWORD *)v173;
              v179 = v174 + v175;
              if (v178 < v174 + v175)
                v174 = *(_DWORD *)v173;
              if (v178 < v179)
              {
                v177 = v173;
                v175 = *v172;
                v171 = v172;
              }
              v172 = (unsigned int *)*((_QWORD *)v172 + 3);
              v173 = (unsigned __int16 *)*((_QWORD *)v173 + 3);
            }
            while (v173);
          }
          else
          {
            v177 = (unsigned __int16 *)*((_QWORD *)cf + 3);
            v176 = cf;
          }
          v180 = *v171;
          if ((int)v180 + *(_DWORD *)v177 > v169)
          {
            v23 = v278;
            goto LABEL_341;
          }
          if (!*((_BYTE *)v171 + 10))
          {
            if (*((_QWORD *)v171 + 4) < (unint64_t)(v180 + 2))
            {
              v79 = v176;
              goto LABEL_434;
            }
            v181 = bswap32(v180) >> 16;
            memmove((char *)v171 + 42, v171 + 10, v180);
            *((_WORD *)v171 + 20) = v181;
            LODWORD(v180) = *v171 + 2;
            *v171 = v180;
          }
          v182 = *((_QWORD *)v171 + 4);
          if (!*((_BYTE *)v177 + 10))
          {
            v183 = (v180 + 2);
            if (v182 < v183)
            {
              _VTU_FreeVPList(v176);
              v97 = a1;
              LODWORD(v68) = -1;
              goto LABEL_437;
            }
            *(_WORD *)((char *)v171 + v180 + 40) = bswap32(*v177) >> 16;
            *v171 = v183;
            LODWORD(v180) = v180 + 2;
          }
          if (v182 < (*(_DWORD *)v177 + v180))
            goto LABEL_149;
          memcpy((char *)v171 + v180 + 40, v177 + 20, *(unsigned int *)v177);
          *v171 += *(_DWORD *)v177;
          *((_BYTE *)v171 + 10) = 1;
          *((_QWORD *)v171 + 3) = *((_QWORD *)v177 + 3);
          *((_QWORD *)v177 + 3) = 0;
          _VTU_FreeVPList(v177);
          v17 = v170-- <= 2;
          v23 = v278;
          v87 = v280;
          if (v17)
            goto LABEL_341;
        }
        v69 = v250;
LABEL_343:
        v195 = v120 | 1;
        v196 = v171;
        v197 = v120;
        if (v87)
          v198 = 57;
        else
          v198 = 56;
        ptr = v196;
        do
        {
          if (*((_BYTE *)v196 + 10) == 1)
          {
            v199 = *v196;
            if (*((_QWORD *)v196 + 4) < (unint64_t)(v199 + v195))
            {
LABEL_433:
              v79 = ptr;
              goto LABEL_434;
            }
            memmove((char *)v196 + v120 + 41, v196 + 10, v199);
            *((_BYTE *)v196 + 40) = v198;
            if (v280)
              memcpy((char *)v196 + 41, &__src, v120);
            *v196 += v195;
          }
          v196 = (unsigned int *)*((_QWORD *)v196 + 3);
        }
        while (v196);
        v251 = v69;
        v200 = v23 - (v120 + 2);
        if (v280)
          v201 = 29;
        else
          v201 = 28;
        v236 = v201;
        v237 = v200 - 1;
        v234 = v23 - (v120 + 2);
        v235 = v120 | 1;
        v202 = ptr;
        v272 = v34;
        v266 = v54;
LABEL_357:
        v203 = (char *)(v202 + 5);
        if (v280 && (*v203 & 0x1B) == 1)
        {
          v204 = *(_DWORD *)v202;
        }
        else
        {
          v204 = *(_DWORD *)v202;
          if (*(_DWORD *)v202 <= v23)
          {
            v210 = (uint64_t)v202;
            goto LABEL_391;
          }
        }
        if (v200 <= 0)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            v229 = VRTraceErrorLogLevelToCSTR();
            v230 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136316418;
              *(_QWORD *)&buf[4] = v229;
              v289 = 2080;
              v290 = "VTU_PrepareH264FrameData";
              v291 = 1024;
              v292 = 524;
              v293 = 1024;
              v294 = 524;
              v295 = 1024;
              v296 = v200;
              v297 = 1024;
              v298 = v23;
              _os_log_error_impl(&dword_1D8A54000, v230, OS_LOG_TYPE_ERROR, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/VideoTransmitterUtils.c:%d: Invalid adjustedMTU=%d MTU=%d", buf, 0x2Eu);
            }
          }
          goto LABEL_433;
        }
        v269 = v202[3];
        if ((v237 + v204) / v200 >= 2 || v280 == 0)
          v206 = (v237 + v204) / v200;
        else
          v206 = 2;
        v207 = v204 / v206 + 1;
        if (v252)
        {
          v208 = Throttling_VideoTransmitterUtil_ForceFirstProbePktSize(v204, (v204 / v206 + 1));
          v209 = v204 / v206 + 1;
          if (v207 != v208)
          {
            v207 = (v204 - v208) / (v206 - 1) + 1;
            v209 = v208;
          }
        }
        else
        {
          v209 = v204 / v206 + 1;
        }
        v211 = *v203;
        v277 = *v203 & 0xE0 | v236;
        v115 = __OFSUB__(v206, 1);
        v212 = v206 - 1;
        if ((v212 < 0) ^ v115 | (v212 == 0))
        {
          v264 = v211 & 0x1F;
          v210 = (uint64_t)v202;
          goto LABEL_387;
        }
        v213 = v204 - v209;
        v233 = v209;
        v214 = &v203[v209];
        v215 = (v207 + v197 + 2);
        v242 = v211;
        v264 = v211 & 0x1F;
        __n = v207;
        v241 = v207;
        v210 = (uint64_t)v202;
        while (1)
        {
          v216 = (uint64_t *)(v210 + 24);
          if (!_VTU_AllocateVPList(v89, (int)v215, (_QWORD *)(v210 + 24)))
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                VTU_SplitVideoIntoPackets_cold_16();
            }
LABEL_412:
            v194 = ptr;
LABEL_413:
            _VTU_FreeVPList(v194);
            LODWORD(v68) = -1;
            v97 = a1;
LABEL_414:
            v34 = v272;
LABEL_415:
            v54 = v266;
            goto LABEL_437;
          }
          v210 = *v216;
          *(_QWORD *)(*v216 + 24) = v269;
          if (v212 == 1)
          {
            if ((PrepareLastH264Fragment(v210, v277, v242, v214, v213, v258, v197) & 0x80000000) != 0)
            {
              ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
              if (ErrorLogLevelForModule >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  VTU_SplitVideoIntoPackets_cold_10();
              }
              goto LABEL_412;
            }
          }
          else
          {
            if (v213 <= v241)
            {
              H264Fragment = PrepareLastH264Fragment(v210, v277, v242, v214, v213, v258, v197);
              v34 = v272;
              v23 = v278;
              v209 = v233;
              if (H264Fragment < 0)
              {
                if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                {
                  VRTraceErrorLogLevelToCSTR();
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                    VTU_SplitVideoIntoPackets_cold_15();
                }
                goto LABEL_412;
              }
LABEL_387:
              *((_WORD *)v202 + 4) = 1;
              *(_DWORD *)v202 = v209 + v235;
              if (v202[4] < (unint64_t)(v209 + v235))
              {
                if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                {
                  VRTraceErrorLogLevelToCSTR();
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                    VTU_SplitVideoIntoPackets_cold_11();
                }
                _VTU_FreeVPList(ptr);
                LODWORD(v68) = -1;
                v97 = a1;
                goto LABEL_415;
              }
              memmove((char *)v202 + v197 + 42, (char *)v202 + 41, v209 - 1);
              *((_BYTE *)v202 + 40) = v277;
              *((_BYTE *)v202 + 41) = v264 | 0x80;
              if (v280)
                memcpy((char *)v202 + 42, &__src, v197);
              v200 = v234;
LABEL_391:
              v202 = *(_QWORD **)(v210 + 24);
              v54 = v266;
              if (!v202)
              {
                v220 = 0;
                v221 = ptr;
                v222 = ptr;
                do
                {
                  v220 += *(_DWORD *)v222;
                  v222 = (_QWORD *)v222[3];
                }
                while (v222);
                v218 = v256;
                if (v220)
                {
                  v223 = CFAllocatorAllocate(v89, v220, 0);
                  *v256 = v223;
                  if (v223)
                  {
                    v224 = 0;
                    v225 = 0;
                    v226 = (unsigned int *)ptr;
                    while (1)
                    {
                      memcpy((char *)*v256 + v225, v226 + 10, *v226);
                      v227 = *v226;
                      v228 = *v226;
                      if (v224 >= (int)*v247)
                      {
                        if (!VTU_ReallocPktsInfo(v251, v244, v247, 0, 0, 0))
                        {
                          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                          {
                            VRTraceErrorLogLevelToCSTR();
                            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                              VTU_SplitVideoIntoPackets_cold_13();
                          }
                          _VTU_FreeVPList(ptr);
                          CFAllocatorDeallocate(v89, *v256);
                          *v256 = 0;
                          goto LABEL_435;
                        }
                        v228 = *v226;
                      }
                      v225 += v227;
                      *((_DWORD *)*v251 + v224) = v228;
                      *((_DWORD *)*v244 + v224++) = *((unsigned __int8 *)v226 + 9) | (2 * *((unsigned __int8 *)v226 + 8));
                      v226 = (unsigned int *)*((_QWORD *)v226 + 3);
                      if (!v226)
                      {
                        _VTU_FreeVPList(ptr);
                        LODWORD(v68) = 0;
                        v34 = v224;
                        goto LABEL_436;
                      }
                    }
                  }
LABEL_399:
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                  {
                    VRTraceErrorLogLevelToCSTR();
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                      VTU_SplitVideoIntoPackets_cold_12();
                  }
                  v79 = v221;
LABEL_434:
                  _VTU_FreeVPList(v79);
LABEL_435:
                  LODWORD(v68) = -1;
                  goto LABEL_436;
                }
LABEL_398:
                *v218 = 0;
                goto LABEL_399;
              }
              goto LABEL_357;
            }
            *(_DWORD *)v210 = v215;
            *(_WORD *)(v210 + 8) = 0;
            if (*(_QWORD *)(v210 + 32) < v215)
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  VTU_SplitVideoIntoPackets_cold_14();
              }
              goto LABEL_412;
            }
            *(_BYTE *)(v210 + 40) = v277;
            *(_BYTE *)(v210 + 41) = v264;
            if (v280)
              *(_WORD *)(v210 + 42) = __src;
            memcpy((void *)(v210 + v197 + 42), v214, __n);
            v214 += __n;
            v213 -= v241;
          }
          if (!--v212)
          {
            v34 = v272;
            v23 = v278;
            v209 = v233;
            goto LABEL_387;
          }
        }
      }
LABEL_341:
      v69 = v250;
    }
    v171 = (unsigned int *)cf;
    if (!cf)
    {
      v221 = 0;
      v218 = v256;
      goto LABEL_398;
    }
    goto LABEL_343;
  }
  v71 = *((unsigned __int8 *)v22 + 76);
  v72 = *((unsigned __int16 *)v22 + 39);
  v73 = (const __CFAllocator *)v22[10];
  LOWORD(cf) = *((_WORD *)v22 + 39);
  *(_QWORD *)buf = 0;
  if (!v257)
  {
    if (!v71)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VTU_SplitVideoIntoPackets_cold_1();
      }
      goto LABEL_435;
    }
    v95 = CFAllocatorAllocate(v73, 2, 0);
    *v13 = v95;
    if (v95)
    {
      v96 = 76;
LABEL_156:
      *v95 = v96;
      if (v70)
        *v70 = 1;
      VTU_ReallocPktsInfo(v69, v68, v70, 0, 0, 0);
      if (v69 && *v69)
        *(_DWORD *)*v69 = 2;
      v97 = a1;
      if (v68)
      {
        v98 = *v68;
        if (*v68)
        {
          LODWORD(v68) = 0;
          *v98 = 3;
        }
        else
        {
          LODWORD(v68) = 0;
        }
      }
      v34 = 1;
      goto LABEL_437;
    }
    goto LABEL_223;
  }
  if (v34 <= 0)
  {
    v255 = v13;
    v266 = v54;
    v272 = v34;
    LOWORD(cf) = __rev16(v72);
LABEL_211:
    v118 = 0;
    __src = -21846;
    v119 = v255;
    goto LABEL_212;
  }
  v274 = v71;
  v246 = v70;
  v249 = v69;
  v243 = v68;
  v74 = 0;
  do
  {
    v75 = *((_DWORD *)v303 + v74);
    if (v75 <= v23)
      v76 = v23;
    else
      v76 = *((_DWORD *)v303 + v74);
    v77 = AddOneVPList((uint64_t *)buf, v75, v305[v74++], (uint64_t)v54, v257, v76, v73);
    if (v77)
      v78 = 1;
    else
      v78 = v74 >= v34;
  }
  while (!v78);
  if (v77)
  {
    v79 = *(_QWORD **)buf;
    goto LABEL_434;
  }
  v255 = v13;
  v266 = v54;
  v126 = v274;
  v127 = v34;
  v128 = *(unsigned int **)buf;
  LOWORD(cf) = bswap32((unsigned __int16)cf) >> 16;
  v282 = 2 * (v274 != 0);
  v272 = v127;
  if (v127 >= 2)
  {
    v129 = v127;
    do
    {
      v130 = (unsigned int *)*((_QWORD *)v128 + 3);
      if (!v130)
        goto LABEL_250;
      v131 = (unsigned __int16 *)*((_QWORD *)v130 + 3);
      if (v131)
      {
        v132 = *v130;
        v133 = *v128;
        v134 = v128;
        v135 = (unsigned __int16 *)*((_QWORD *)v128 + 3);
        do
        {
          v136 = *v130 + *(_DWORD *)v131;
          v137 = v132 + v133;
          if (v136 < v132 + v133)
            v132 = *(_DWORD *)v131;
          if (v136 < v137)
          {
            v135 = v131;
            v133 = *v130;
            v134 = v130;
          }
          v130 = (unsigned int *)*((_QWORD *)v130 + 3);
          v131 = (unsigned __int16 *)*((_QWORD *)v131 + 3);
        }
        while (v131);
        if (!v128)
        {
          v138 = 0;
          goto LABEL_239;
        }
      }
      else
      {
        v134 = v128;
        v135 = (unsigned __int16 *)*((_QWORD *)v128 + 3);
      }
      v138 = 0;
      v139 = v128;
      do
      {
        v138 += 2 * (*((_BYTE *)v139 + 10) == 1);
        v139 = (unsigned int *)*((_QWORD *)v139 + 3);
      }
      while (v139);
LABEL_239:
      v140 = v278 - v138;
      v141 = *((unsigned __int8 *)v135 + 10);
      v142 = *v134;
      if ((v282 + 2)
         + 2 * (*((_BYTE *)v134 + 10) != 1)
         + 2 * (v141 != 1)
         + (unint64_t)(v142 + *(_DWORD *)v135) > v140)
        break;
      if (!*((_BYTE *)v134 + 10))
      {
        if (*((_QWORD *)v134 + 4) < (unint64_t)(v142 + 2))
          goto LABEL_337;
        v143 = bswap32(v142) >> 16;
        memmove((char *)v134 + 42, v134 + 10, v142);
        *((_WORD *)v134 + 20) = v143;
        LODWORD(v142) = *v134 + 2;
        *v134 = v142;
        v141 = *((unsigned __int8 *)v135 + 10);
      }
      v144 = *((_QWORD *)v134 + 4);
      if (!v141)
      {
        v145 = (v142 + 2);
        if (v144 < v145)
        {
          _VTU_FreeVPList(v128);
          v97 = a1;
          LODWORD(v68) = -1;
          goto LABEL_414;
        }
        *(_WORD *)((char *)v134 + v142 + 40) = bswap32(*v135) >> 16;
        *v134 = v145;
        LODWORD(v142) = v142 + 2;
      }
      if (v144 < (*(_DWORD *)v135 + v142))
      {
LABEL_337:
        v194 = v128;
        goto LABEL_413;
      }
      memcpy((char *)v134 + v142 + 40, v135 + 20, *(unsigned int *)v135);
      *v134 += *(_DWORD *)v135;
      *((_BYTE *)v134 + 10) = 1;
      *((_QWORD *)v134 + 3) = *((_QWORD *)v135 + 3);
      *((_QWORD *)v135 + 3) = 0;
      _VTU_FreeVPList(v135);
      v17 = v129-- <= 2;
    }
    while (!v17);
  }
  if (!v128)
    goto LABEL_211;
LABEL_250:
  v146 = v128;
  v54 = v266;
  v119 = v255;
  v147 = 2 * (v274 != 0);
  do
  {
    if (*((_BYTE *)v146 + 10) == 1)
    {
      v148 = *v146;
      if (*((_QWORD *)v146 + 4) < (unint64_t)(v148 + 2))
      {
        _VTU_FreeVPList(v128);
        LODWORD(v68) = -1;
        v97 = a1;
LABEL_429:
        v34 = v272;
        goto LABEL_437;
      }
      memmove((char *)v146 + 42, v146 + 10, v148);
      *((_WORD *)v146 + 20) = 352;
      v149 = *v146;
      *v146 += 2;
      if (v274 && !VTU_MoveAndInsertData(v146, 2, v149, &cf, 2))
      {
        _VTU_FreeVPList(v128);
        v97 = a1;
        LODWORD(v68) = -1;
        goto LABEL_429;
      }
    }
    v146 = (unsigned int *)*((_QWORD *)v146 + 3);
  }
  while (v146);
  __src = -21846;
  v150 = v278 - v282 - 3;
  v240 = v282 + 2;
  while (1)
  {
    v151 = *v128;
    if ((int)(*v128 + v147) <= v278)
    {
      if (v126 && !*((_BYTE *)v128 + 10) && (v151 <= 1 || !VTU_MoveAndInsertData(v128, 2, v151 - 2, &cf, v147)))
      {
LABEL_453:
        _VTU_FreeVPList(*(_QWORD **)buf);
        LODWORD(v68) = -1;
        v34 = v272;
        goto LABEL_436;
      }
      goto LABEL_282;
    }
    if (v150 < 1)
      goto LABEL_453;
    v268 = *((_QWORD *)v128 + 3);
    v152 = (int)(v278 - v282 - 4 + v151) / v150;
    v153 = *((unsigned __int8 *)v128 + 40);
    HIBYTE(__src) = *((_BYTE *)v128 + 41);
    v262 = v153;
    LOBYTE(__src) = v153 & 0x81 | 0x62;
    v154 = (uint64_t)v128;
    v253 = (int)v151 / v152;
    v155 = v152 - 1;
    if (v152 > 1)
      break;
LABEL_278:
    if (*((_QWORD *)v128 + 4) < (unint64_t)(v240 + v253))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VTU_SplitVideoIntoPackets_cold_3();
      }
      goto LABEL_460;
    }
    *((_WORD *)v128 + 4) = 1;
    *v128 = v240 + v253;
    v147 = 2 * (v274 != 0);
    memmove((char *)v128 + v282 + 43, (char *)v128 + 42, v253 - 1);
    *((_WORD *)v128 + 20) = __src;
    *((_BYTE *)v128 + 42) = (v262 >> 1) & 0x3F | 0x80;
    v119 = v255;
    v126 = v274;
    if (v274)
      memmove((char *)v128 + 43, &cf, v282);
    v128 = (unsigned int *)v154;
    v54 = v266;
    v150 = v278 - v282 - 3;
LABEL_282:
    v128 = (unsigned int *)*((_QWORD *)v128 + 3);
    if (!v128)
    {
      v118 = *(unsigned int **)buf;
      if (*(_QWORD *)buf)
      {
        v161 = 0;
        v162 = *(_QWORD *)buf;
        do
        {
          v161 += *(_DWORD *)v162;
          v162 = *(_QWORD *)(v162 + 24);
        }
        while (v162);
        if (v161)
        {
          v163 = CFAllocatorAllocate(v73, v161, 0);
          *v119 = v163;
          if (v163)
          {
            v164 = 0;
            v165 = 0;
            v166 = v118;
            while (1)
            {
              memcpy((char *)*v119 + v165, v166 + 10, *v166);
              v167 = *v166;
              v168 = *v166;
              if (v164 >= (int)*v246)
              {
                if (!VTU_ReallocPktsInfo(v249, v243, v246, 0, 0, 0))
                {
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                  {
                    VRTraceErrorLogLevelToCSTR();
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                      VTU_SplitVideoIntoPackets_cold_5();
                  }
                  _VTU_FreeVPList(v118);
                  CFAllocatorDeallocate(v73, *v255);
                  *v255 = 0;
                  goto LABEL_461;
                }
                v168 = *v166;
              }
              v165 += v167;
              *((_DWORD *)*v249 + v164) = v168;
              *((_DWORD *)*v243 + v164++) = *((unsigned __int8 *)v166 + 9) | (2 * *((unsigned __int8 *)v166 + 8));
              v166 = (unsigned int *)*((_QWORD *)v166 + 3);
              if (!v166)
              {
                _VTU_FreeVPList(v118);
                LODWORD(v68) = 0;
                v34 = v164;
                goto LABEL_462;
              }
            }
          }
          goto LABEL_213;
        }
      }
LABEL_212:
      *v119 = 0;
LABEL_213:
      v34 = v272;
      v54 = v266;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VTU_SplitVideoIntoPackets_cold_4();
      }
      v79 = v118;
      goto LABEL_434;
    }
  }
  v156 = v253 + 1;
  v157 = v151 - (v253 + 1);
  v158 = (char *)v128 + v156 + 40;
  v159 = v253 + (v282 | 4);
  v259 = (v153 >> 1) & 0x3F;
  v154 = (uint64_t)v128;
  while (1)
  {
    v160 = (uint64_t *)(v154 + 24);
    if (!_VTU_AllocateVPList(v73, (int)v159, (_QWORD *)(v154 + 24)))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VTU_SplitVideoIntoPackets_cold_8();
      }
      goto LABEL_460;
    }
    v154 = *v160;
    *(_QWORD *)(*v160 + 24) = v268;
    if (v155 == 1)
    {
      if ((PrepareLastHEVCFragment(v154, &__src, v262, v158, v157, (__int16)cf, v282) & 0x80000000) != 0)
      {
        v232 = VRTraceGetErrorLogLevelForModule();
        if (v232 >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VTU_SplitVideoIntoPackets_cold_2();
        }
        goto LABEL_460;
      }
      goto LABEL_270;
    }
    if (v157 <= (int)v156)
      break;
    *(_DWORD *)v154 = v159;
    *(_WORD *)(v154 + 8) = 0;
    if (*((_QWORD *)v128 + 4) < v159)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VTU_SplitVideoIntoPackets_cold_6();
      }
      goto LABEL_460;
    }
    *(_WORD *)(v154 + 40) = __src;
    *(_BYTE *)(v154 + 42) = v259;
    if (v274)
      *(_WORD *)(v154 + 43) = (_WORD)cf;
    v157 -= v156;
    memcpy((void *)(v154 + v282 + 43), v158, v156);
    v158 += v156;
LABEL_270:
    if (!--v155)
      goto LABEL_278;
  }
  if ((PrepareLastHEVCFragment(v154, &__src, v262, v158, v157, (__int16)cf, v282) & 0x80000000) == 0)
    goto LABEL_278;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VTU_SplitVideoIntoPackets_cold_7();
  }
LABEL_460:
  _VTU_FreeVPList(*(_QWORD **)buf);
LABEL_461:
  LODWORD(v68) = -1;
  v34 = v272;
LABEL_462:
  v54 = v266;
LABEL_436:
  v97 = a1;
LABEL_437:
  if (v54 != a3)
    CFAllocatorDeallocate((CFAllocatorRef)v97[10], v54);
  if ((_DWORD)v68)
    return 0;
  else
    return v34;
}

uint64_t VTU_SplitGenericDataIntoPackets(uint64_t a1, int a2, uint64_t a3, int a4, _QWORD *a5, unsigned int a6)
{
  uint64_t v7;
  int v11;
  signed int v12;
  int v13;
  void **v14;
  int v15;
  unsigned int v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unsigned int v22;
  int v23;
  int v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  size_t v28;
  uint64_t v29;
  uint64_t v30;
  _DWORD *v31;
  _QWORD *v32;
  _QWORD *v33;
  __int16 v35;
  _QWORD *v36;
  CFIndex v37;
  _QWORD *v38;
  char *v39;
  char *v40;
  int v41;
  unsigned int *v42;
  int v43;
  unsigned int *v44;
  int v45;
  uint64_t v46;
  NSObject *v47;
  uint64_t v49;
  NSObject *v50;
  int v51;
  const char *v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  int v58;
  _QWORD *v59;
  int v60;
  const __CFAllocator *allocator;
  _DWORD *v63;
  uint8_t buf[4];
  uint64_t v65;
  __int16 v66;
  const char *v67;
  __int16 v68;
  int v69;
  __int16 v70;
  int v71;
  __int16 v72;
  int v73;
  __int16 v74;
  int v75;
  __int16 v76;
  int v77;
  __int16 v78;
  int v79;
  uint64_t v80;

  v80 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  v7 = 0;
  if ((a2 - 110) <= 0xF && ((1 << (a2 - 110)) & 0xC001) != 0)
  {
    if (a4 >= 1)
    {
      v11 = VTU_HandleMTUOverride(a1, a6, *(unsigned __int16 *)(a1 + 72));
      v12 = vcvtps_s32_f32((float)a4 / (float)(v11 - 20));
      if (v12 <= 0)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() < 3)
          return 0;
        v49 = VRTraceErrorLogLevelToCSTR();
        v50 = *MEMORY[0x1E0CF2758];
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          return 0;
        v51 = **(_DWORD **)(a1 + 48);
        *(_DWORD *)buf = 136316418;
        v65 = v49;
        v66 = 2080;
        v67 = "VTU_SplitGenericDataIntoPackets";
        v68 = 1024;
        v69 = 1806;
        v70 = 1024;
        v71 = a4;
        v72 = 1024;
        v73 = v12;
        v74 = 1024;
        v75 = v51;
        v52 = " [%s] %s:%d Invalid packet count: Length:%d, packets:%d, maxPacketCount:%d";
        goto LABEL_88;
      }
      v13 = v11;
      if (**(_DWORD **)(a1 + 48) >= v12)
        goto LABEL_10;
      **(_QWORD **)(a1 + 88) = malloc_type_realloc(**(void ***)(a1 + 88), 4 * v12, 0x100004052888210uLL);
      if (!**(_QWORD **)(a1 + 88))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() < 3)
          return 0;
        v53 = VRTraceErrorLogLevelToCSTR();
        v50 = *MEMORY[0x1E0CF2758];
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          return 0;
        v54 = **(_DWORD **)(a1 + 48);
        *(_DWORD *)buf = 136316418;
        v65 = v53;
        v66 = 2080;
        v67 = "VTU_SplitGenericDataIntoPackets";
        v68 = 1024;
        v69 = 1810;
        v70 = 1024;
        v71 = a4;
        v72 = 1024;
        v73 = v12;
        v74 = 1024;
        v75 = v54;
        v52 = " [%s] %s:%d Failed to realloc heads: Length:%d, packets:%d, maxPacketCount:%d";
        goto LABEL_88;
      }
      **(_QWORD **)(a1 + 96) = malloc_type_realloc(**(void ***)(a1 + 96), 4 * v12, 0x100004052888210uLL);
      v14 = *(void ***)(a1 + 96);
      if (!*v14)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() < 3)
          return 0;
        v55 = VRTraceErrorLogLevelToCSTR();
        v50 = *MEMORY[0x1E0CF2758];
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          return 0;
        v56 = **(_DWORD **)(a1 + 48);
        *(_DWORD *)buf = 136316418;
        v65 = v55;
        v66 = 2080;
        v67 = "VTU_SplitGenericDataIntoPackets";
        v68 = 1024;
        v69 = 1813;
        v70 = 1024;
        v71 = a4;
        v72 = 1024;
        v73 = v12;
        v74 = 1024;
        v75 = v56;
        v52 = " [%s] %s:%d Failed to realloc lineSizes: Length:%d, packets:%d, maxPacketCount:%d";
        goto LABEL_88;
      }
      if (VTU_ReallocPktsInfo(*(void ***)(a1 + 32), *(void ***)(a1 + 40), *(unsigned int **)(a1 + 48), *(void ***)(a1 + 88), v14, v12))
      {
LABEL_10:
        v15 = 0;
        v16 = 0;
        v17 = 0;
        v18 = v13 - 20;
        v19 = **(_QWORD **)(a1 + 96);
        v20 = **(_QWORD **)(a1 + 88);
        v21 = v18;
        do
        {
          v22 = v16;
          if (v21 >= a4)
            v23 = a4;
          else
            v23 = v21;
          *(_DWORD *)(v19 + 4 * v22) = v15 + v23;
          *(_DWORD *)(v20 + 4 * v22) = v17;
          v16 = v22 + 1;
          v15 += 20 - v13;
          v21 += v18;
          v17 += v18;
        }
        while (v17 < a4);
        allocator = *(const __CFAllocator **)(a1 + 80);
        *a5 = 0;
        if (v22 != -1)
        {
          v60 = a2;
          v59 = a5;
          v24 = a4;
          v25 = 0;
          v26 = 0;
          v27 = v22;
          while (1)
          {
            v28 = *(unsigned int *)(**(_QWORD **)(a1 + 96) + 4 * v25);
            v29 = *(unsigned int *)(**(_QWORD **)(a1 + 88) + 4 * v25);
            v30 = (int)v28 <= v13 ? v13 : v28;
            if ((v28 & 0x80000000) != 0 || (v29 & 0x80000000) != 0 || (int)v29 + (int)v28 > v24)
              break;
            v63 = (_DWORD *)0xAAAAAAAAAAAAAAAALL;
            if (!_VTU_AllocateVPList(allocator, v30, &v63))
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  VTU_SplitGenericDataIntoPackets_cold_9();
              }
LABEL_55:
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  VTU_SplitGenericDataIntoPackets_cold_3();
              }
              goto LABEL_58;
            }
            v31 = v63;
            *v63 = v28;
            v31[1] = v29;
            *((_WORD *)v31 + 4) = 257;
            *((_BYTE *)v31 + 10) = 0;
            memcpy(v31 + 10, (const void *)(a3 + v29), v28);
            if (v26)
            {
              v32 = v26;
              do
              {
                v33 = v32;
                v32 = (_QWORD *)v32[3];
              }
              while (v32);
              v33[3] = v31;
            }
            else
            {
              v26 = v31;
            }
            if (v25++ == v27)
            {
              if ((v60 & 0xFFFFFFFE) == 0x7C)
              {
LABEL_35:
                LODWORD(v37) = 0;
                v38 = v26;
                do
                {
                  v37 = (*(_DWORD *)v38 + v37);
                  v38 = (_QWORD *)v38[3];
                }
                while (v38);
                if ((int)v37 < 1)
                  goto LABEL_46;
                v39 = (char *)CFAllocatorAllocate(allocator, v37, 0);
                if (v39)
                {
                  v40 = v39;
                  LODWORD(v7) = 0;
                  v41 = 0;
                  v42 = (unsigned int *)v26;
                  while (1)
                  {
                    memcpy(&v40[v41], v42 + 10, *v42);
                    v43 = *v42;
                    v44 = *(unsigned int **)(a1 + 48);
                    v45 = *v42;
                    if (v7 >= *v44)
                    {
                      if (!VTU_ReallocPktsInfo(*(void ***)(a1 + 32), *(void ***)(a1 + 40), v44, *(void ***)(a1 + 88), *(void ***)(a1 + 96), 0))
                      {
                        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                        {
                          VRTraceErrorLogLevelToCSTR();
                          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                            VTU_SplitGenericDataIntoPackets_cold_6();
                        }
                        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                        {
                          VRTraceErrorLogLevelToCSTR();
                          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                            VTU_SplitGenericDataIntoPackets_cold_5();
                        }
                        CFAllocatorDeallocate(allocator, v40);
                        goto LABEL_58;
                      }
                      v45 = *v42;
                    }
                    v41 += v43;
                    *(_DWORD *)(**(_QWORD **)(a1 + 32) + 4 * v7) = v45;
                    *(_DWORD *)(**(_QWORD **)(a1 + 40) + 4 * v7) = *((unsigned __int8 *)v42 + 9) | (2 * *((unsigned __int8 *)v42 + 8));
                    v42 = (unsigned int *)*((_QWORD *)v42 + 3);
                    v7 = (v7 + 1);
                    if (!v42)
                    {
                      *v59 = v40;
                      _VTU_FreeVPList(v26);
                      return v7;
                    }
                  }
                }
                if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                {
                  VRTraceErrorLogLevelToCSTR();
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                    VTU_SplitGenericDataIntoPackets_cold_4();
                }
              }
              else
              {
                v35 = 0;
                v36 = v26;
                while ((RTPPackGenericDataPacket((char *)v36 + 40, v36, *((_DWORD *)v36 + 8), v35) & 0x80000000) == 0)
                {
                  ++v35;
                  v36 = (_QWORD *)v36[3];
                  if (!v36)
                    goto LABEL_35;
                }
                if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                {
                  VRTraceErrorLogLevelToCSTR();
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                    VTU_SplitGenericDataIntoPackets_cold_8();
                }
                if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                {
                  VRTraceErrorLogLevelToCSTR();
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                    VTU_SplitGenericDataIntoPackets_cold_7();
                }
              }
              goto LABEL_58;
            }
          }
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            v46 = VRTraceErrorLogLevelToCSTR();
            v47 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136316930;
              v65 = v46;
              v66 = 2080;
              v67 = "_VTU_AddOneVPListGeneric";
              v68 = 1024;
              v69 = 169;
              v70 = 1024;
              v71 = 169;
              v72 = 1024;
              v73 = v28;
              v74 = 1024;
              v75 = v29;
              v76 = 1024;
              v77 = v30;
              v78 = 1024;
              v79 = v24;
              _os_log_error_impl(&dword_1D8A54000, v47, OS_LOG_TYPE_ERROR, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/VideoTransmitterUtils.c:%d: Invalid size lineLen = %d, head = %d, buffer size = %d, dataLen = %d", buf, 0x3Au);
            }
          }
          goto LABEL_55;
        }
        v26 = 0;
LABEL_46:
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VTU_SplitGenericDataIntoPackets_cold_2();
        }
LABEL_58:
        _VTU_FreeVPList(v26);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VTU_SplitGenericDataIntoPackets_cold_1();
        }
        return 0;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v57 = VRTraceErrorLogLevelToCSTR();
        v50 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v58 = **(_DWORD **)(a1 + 48);
          *(_DWORD *)buf = 136316418;
          v65 = v57;
          v66 = 2080;
          v67 = "VTU_SplitGenericDataIntoPackets";
          v68 = 1024;
          v69 = 1816;
          v70 = 1024;
          v71 = a4;
          v72 = 1024;
          v73 = v12;
          v74 = 1024;
          v75 = v58;
          v52 = " [%s] %s:%d Failed to realloc packets: Length:%d, packets:%d, maxPacketCount:%d";
LABEL_88:
          _os_log_error_impl(&dword_1D8A54000, v50, OS_LOG_TYPE_ERROR, v52, buf, 0x2Eu);
        }
      }
    }
    return 0;
  }
  return v7;
}

uint64_t VTU_ComputeTotalNumberOfGroupsPerFrame(int a1)
{
  int v1;

  v1 = a1 - 1;
  if (a1 < 1)
    v1 = a1 + 6;
  return ((v1 >> 3) + 1);
}

uint64_t AddOneVPList(uint64_t *a1, int a2, int a3, uint64_t a4, int a5, unsigned int a6, const __CFAllocator *a7)
{
  uint64_t v13;
  size_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  NSObject *v20;
  uint64_t result;
  _BYTE v22[12];
  __int16 v23;
  const char *v24;
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  __int16 v33;
  unsigned int v34;
  __int16 v35;
  int v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  if (a2 <= 3 || a3 < 0 || a2 > a6 || a3 + a2 > a5)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v19 = VRTraceErrorLogLevelToCSTR();
      v20 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v22 = 136316930;
        *(_QWORD *)&v22[4] = v19;
        v23 = 2080;
        v24 = "AddOneVPList";
        v25 = 1024;
        v26 = 132;
        v27 = 1024;
        v28 = 132;
        v29 = 1024;
        v30 = a2;
        v31 = 1024;
        v32 = a3;
        v33 = 1024;
        v34 = a6;
        v35 = 1024;
        v36 = a5;
        _os_log_error_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_ERROR, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/Others/VideoTransmitterUtils.c:%d: Invalid size iGobs = %d, iHeads = %d, buffer size = %u, dataLen = %d", v22, 0x3Au);
      }
    }
    return 0xFFFFFFFFLL;
  }
  v13 = *a1;
  *(_QWORD *)v22 = 0xAAAAAAAAAAAAAAAALL;
  if (!_VTU_AllocateVPList(a7, (int)a6, v22))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        AddOneVPList_cold_1();
    }
    return 0xFFFFFFFFLL;
  }
  v14 = (a2 - 4);
  v15 = *(_QWORD *)v22;
  v16 = (a3 + 4);
  **(_DWORD **)v22 = v14;
  *(_DWORD *)(v15 + 4) = v16;
  *(_WORD *)(v15 + 8) = 257;
  *(_BYTE *)(v15 + 10) = 0;
  memcpy((void *)(v15 + 40), (const void *)(a4 + v16), v14);
  if (v13)
  {
    v17 = v13;
    do
    {
      v18 = v17;
      v17 = *(_QWORD *)(v17 + 24);
    }
    while (v17);
    *(_QWORD *)(v18 + 24) = v15;
  }
  else
  {
    v13 = v15;
  }
  result = 0;
  *a1 = v13;
  return result;
}

uint64_t PrepareLastHEVCFragment(uint64_t a1, _WORD *a2, unsigned int a3, const void *a4, int a5, __int16 a6, size_t __n)
{
  uint64_t v11;
  __int16 __src;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  __src = a6;
  if (a5 >= 1 && *(_DWORD *)(a1 + 32) - (int)__n - 3 >= a5)
  {
    *(_DWORD *)a1 = a5 + __n + 3;
    *(_WORD *)(a1 + 8) = 256;
    *(_WORD *)(a1 + 40) = *a2;
    *(_BYTE *)(a1 + 42) = (a3 >> 1) | 0x40;
    if ((_DWORD)__n)
    {
      v11 = __n;
      memcpy((void *)(a1 + 43), &__src, __n);
    }
    else
    {
      v11 = 0;
    }
    memcpy((void *)(a1 + v11 + 43), a4, a5);
    return 0;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        PrepareLastHEVCFragment_cold_1();
    }
    return 0xFFFFFFFFLL;
  }
}

uint64_t PrepareLastH264Fragment(uint64_t a1, char a2, char a3, const void *a4, int a5, __int16 a6, size_t __n)
{
  uint64_t v11;
  __int16 __src;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  __src = a6;
  if (a5 >= 1 && *(_DWORD *)(a1 + 32) - (int)__n - 2 >= a5)
  {
    *(_DWORD *)a1 = a5 + __n + 2;
    *(_WORD *)(a1 + 8) = 256;
    *(_BYTE *)(a1 + 40) = a2;
    *(_BYTE *)(a1 + 41) = a3 & 0x1F | 0x40;
    if ((_DWORD)__n)
    {
      v11 = __n;
      memcpy((void *)(a1 + 42), &__src, __n);
    }
    else
    {
      v11 = 0;
    }
    memcpy((void *)(a1 + v11 + 42), a4, a5);
    return 0;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        PrepareLastH264Fragment_cold_1();
    }
    return 0xFFFFFFFFLL;
  }
}

uint64_t compareByPref(uint64_t a1, uint64_t a2)
{
  _BYTE v4[28];
  unint64_t v5;
  _BYTE v6[28];
  unint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  memset(v6, 170, sizeof(v6));
  v7 = 0xAAAAAAAAFFFFFFFFLL;
  memset(v4, 170, sizeof(v4));
  v5 = 0xAAAAAAAAFFFFFFFFLL;
  +[SDPMediaLine fillImageStruct:imageStruct:](SDPMediaLine, "fillImageStruct:imageStruct:", a1, v6);
  +[SDPMediaLine fillImageStruct:imageStruct:](SDPMediaLine, "fillImageStruct:imageStruct:", a2, v4);
  if (*(float *)&v7 < *(float *)&v5)
    return -1;
  else
    return *(float *)&v7 > *(float *)&v5;
}

_OWORD *VCAudioLimiter_Allocate(__int128 *a1)
{
  _OWORD *v2;
  _OWORD *v3;
  __int128 v4;
  __int128 v5;

  v2 = malloc_type_calloc(1uLL, 0xA0uLL, 0x1020040D488A4C3uLL);
  v3 = v2;
  if (v2)
  {
    v4 = *a1;
    v5 = a1[2];
    v2[1] = a1[1];
    v2[2] = v5;
    *v2 = v4;
    *((_DWORD *)v2 + 32) = 2;
    *(_OWORD *)((char *)v2 + 136) = xmmword_1D910C110;
    *((_DWORD *)v2 + 38) = 1056964608;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCAudioLimiter_Allocate_cold_1();
  }
  return v3;
}

uint64_t VCAudioLimiter_Start(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  AudioUnit *v4;
  BOOL v5;
  int ErrorLogLevelForModule;
  uint64_t v7;
  NSObject *v8;
  AudioUnit v9;
  OSStatus v10;
  int v11;
  uint64_t v12;
  NSObject *v13;
  AudioUnit v14;
  OSStatus v15;
  int v16;
  uint64_t v17;
  NSObject *v18;
  AudioUnit v19;
  OSStatus v20;
  int v21;
  uint64_t v22;
  NSObject *v23;
  AudioUnit v24;
  OSStatus v25;
  int v26;
  uint64_t v27;
  NSObject *v28;
  AudioUnit v29;
  OSStatus v30;
  int v31;
  uint64_t v32;
  NSObject *v33;
  AudioUnit v34;
  OSStatus v35;
  int v36;
  uint64_t v37;
  NSObject *v38;
  AudioUnit v39;
  OSStatus v40;
  int v41;
  uint64_t v42;
  NSObject *v43;
  AudioUnit v44;
  OSStatus v45;
  int v46;
  uint64_t v47;
  NSObject *v48;
  AudioUnit v49;
  OSStatus v50;
  int v51;
  uint64_t v52;
  NSObject *v53;
  AudioUnit v54;
  uint64_t v55;
  NSObject *v56;
  AudioUnit v57;
  int v59;
  uint64_t v60;
  __int16 v61;
  const char *v62;
  __int16 v63;
  int v64;
  __int16 v65;
  AudioUnit v66;
  __int16 v67;
  int v68;
  uint64_t v69;

  v69 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v59 = 136315650;
      v60 = v2;
      v61 = 2080;
      v62 = "VCAudioLimiter_Start";
      v63 = 1024;
      v64 = 94;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d ", (uint8_t *)&v59, 0x1Cu);
    }
  }
  if (a1)
  {
    v4 = (AudioUnit *)(a1 + 64);
    v5 = VCAudioUnit_NewInstance((AudioComponentInstance *)(a1 + 64), 0x6366726Bu);
    ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    if (v5)
    {
      if (ErrorLogLevelForModule >= 7)
      {
        v7 = VRTraceErrorLogLevelToCSTR();
        v8 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v9 = *v4;
          v59 = 136315906;
          v60 = v7;
          v61 = 2080;
          v62 = "VCAudioLimiter_Start";
          v63 = 1024;
          v64 = 104;
          v65 = 2048;
          v66 = v9;
          _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d voiceLimiterUnit=%p VCAudioUnit_NewInstance kAudioUnitSubType_ControlFreak", (uint8_t *)&v59, 0x26u);
        }
      }
      v10 = AudioUnitSetProperty(*(AudioUnit *)(a1 + 64), 0xEu, 0, 0, (const void *)(a1 + 40), 4u);
      v11 = VRTraceGetErrorLogLevelForModule();
      if (v10)
      {
        if (v11 >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCAudioLimiter_Start_cold_9();
        }
      }
      else
      {
        if (v11 >= 7)
        {
          v12 = VRTraceErrorLogLevelToCSTR();
          v13 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v14 = *v4;
            v59 = 136315906;
            v60 = v12;
            v61 = 2080;
            v62 = "VCAudioLimiter_Start";
            v63 = 1024;
            v64 = 109;
            v65 = 2048;
            v66 = v14;
            _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d voiceLimiterUnit=%p kAudioUnitProperty_MaximumFramesPerSlice kAudioUnitScope_Global", (uint8_t *)&v59, 0x26u);
          }
        }
        v15 = AudioUnitSetProperty(*(AudioUnit *)(a1 + 64), 8u, 1u, 0, (const void *)a1, 0x28u);
        v16 = VRTraceGetErrorLogLevelForModule();
        if (v15)
        {
          if (v16 >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VCAudioLimiter_Start_cold_8();
          }
        }
        else
        {
          if (v16 >= 7)
          {
            v17 = VRTraceErrorLogLevelToCSTR();
            v18 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              v19 = *v4;
              v59 = 136315906;
              v60 = v17;
              v61 = 2080;
              v62 = "VCAudioLimiter_Start";
              v63 = 1024;
              v64 = 113;
              v65 = 2048;
              v66 = v19;
              _os_log_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d voiceLimiterUnit=%p kAudioUnitProperty_StreamFormat kAudioUnitScope_Input", (uint8_t *)&v59, 0x26u);
            }
          }
          v20 = AudioUnitSetProperty(*(AudioUnit *)(a1 + 64), 8u, 2u, 0, (const void *)a1, 0x28u);
          v21 = VRTraceGetErrorLogLevelForModule();
          if (v20)
          {
            if (v21 >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                VCAudioLimiter_Start_cold_7();
            }
          }
          else
          {
            if (v21 >= 7)
            {
              v22 = VRTraceErrorLogLevelToCSTR();
              v23 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                v24 = *v4;
                v59 = 136315906;
                v60 = v22;
                v61 = 2080;
                v62 = "VCAudioLimiter_Start";
                v63 = 1024;
                v64 = 117;
                v65 = 2048;
                v66 = v24;
                _os_log_impl(&dword_1D8A54000, v23, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d voiceLimiterUnit=%p kAudioUnitProperty_StreamFormat kAudioUnitScope_Output", (uint8_t *)&v59, 0x26u);
              }
            }
            v25 = AudioUnitSetParameter(*(AudioUnit *)(a1 + 64), 3u, 0, 0, *(AudioUnitParameterValue *)(a1 + 140), 0);
            v26 = VRTraceGetErrorLogLevelForModule();
            if (v25)
            {
              if (v26 >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  VCAudioLimiter_Start_cold_6();
              }
            }
            else
            {
              if (v26 >= 7)
              {
                v27 = VRTraceErrorLogLevelToCSTR();
                v28 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                {
                  v29 = *v4;
                  v59 = 136315906;
                  v60 = v27;
                  v61 = 2080;
                  v62 = "VCAudioLimiter_Start";
                  v63 = 1024;
                  v64 = 121;
                  v65 = 2048;
                  v66 = v29;
                  _os_log_impl(&dword_1D8A54000, v28, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d voiceLimiterUnit=%p kVCAudioLimiterParameterInputThresholddB kAudioUnitScope_Global", (uint8_t *)&v59, 0x26u);
                }
              }
              v30 = AudioUnitSetParameter(*(AudioUnit *)(a1 + 64), 4u, 0, 0, *(AudioUnitParameterValue *)(a1 + 144), 0);
              v31 = VRTraceGetErrorLogLevelForModule();
              if (v30)
              {
                if (v31 >= 3)
                {
                  VRTraceErrorLogLevelToCSTR();
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                    VCAudioLimiter_Start_cold_5();
                }
              }
              else
              {
                if (v31 >= 7)
                {
                  v32 = VRTraceErrorLogLevelToCSTR();
                  v33 = *MEMORY[0x1E0CF2758];
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                  {
                    v34 = *v4;
                    v59 = 136315906;
                    v60 = v32;
                    v61 = 2080;
                    v62 = "VCAudioLimiter_Start";
                    v63 = 1024;
                    v64 = 125;
                    v65 = 2048;
                    v66 = v34;
                    _os_log_impl(&dword_1D8A54000, v33, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d voiceLimiterUnit=%p kVCAudioLimiterParameterMinFastGain kAudioUnitScope_Global", (uint8_t *)&v59, 0x26u);
                  }
                }
                v35 = AudioUnitSetParameter(*(AudioUnit *)(a1 + 64), 5u, 0, 0, *(AudioUnitParameterValue *)(a1 + 148), 0);
                v36 = VRTraceGetErrorLogLevelForModule();
                if (v35)
                {
                  if (v36 >= 3)
                  {
                    VRTraceErrorLogLevelToCSTR();
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                      VCAudioLimiter_Start_cold_4();
                  }
                }
                else
                {
                  if (v36 >= 7)
                  {
                    v37 = VRTraceErrorLogLevelToCSTR();
                    v38 = *MEMORY[0x1E0CF2758];
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                    {
                      v39 = *v4;
                      v59 = 136315906;
                      v60 = v37;
                      v61 = 2080;
                      v62 = "VCAudioLimiter_Start";
                      v63 = 1024;
                      v64 = 129;
                      v65 = 2048;
                      v66 = v39;
                      _os_log_impl(&dword_1D8A54000, v38, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d voiceLimiterUnit=%p kVCAudioLimiterParameterFastGainReleaseTime kAudioUnitScope_Global", (uint8_t *)&v59, 0x26u);
                    }
                  }
                  v40 = AudioUnitSetParameter(*(AudioUnit *)(a1 + 64), 7u, 0, 0, *(AudioUnitParameterValue *)(a1 + 152), 0);
                  v41 = VRTraceGetErrorLogLevelForModule();
                  if (v40)
                  {
                    if (v41 >= 3)
                    {
                      VRTraceErrorLogLevelToCSTR();
                      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                        VCAudioLimiter_Start_cold_3();
                    }
                  }
                  else
                  {
                    if (v41 >= 7)
                    {
                      v42 = VRTraceErrorLogLevelToCSTR();
                      v43 = *MEMORY[0x1E0CF2758];
                      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                      {
                        v44 = *v4;
                        v59 = 136315906;
                        v60 = v42;
                        v61 = 2080;
                        v62 = "VCAudioLimiter_Start";
                        v63 = 1024;
                        v64 = 133;
                        v65 = 2048;
                        v66 = v44;
                        _os_log_impl(&dword_1D8A54000, v43, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d voiceLimiterUnit=%p kVCAudioLimiterParameterLookahead kAudioUnitScope_Global", (uint8_t *)&v59, 0x26u);
                      }
                    }
                    v45 = AudioUnitSetParameter(*(AudioUnit *)(a1 + 64), 2u, 0, 0, *(AudioUnitParameterValue *)(a1 + 136), 0);
                    v46 = VRTraceGetErrorLogLevelForModule();
                    if (v45)
                    {
                      if (v46 >= 3)
                      {
                        VRTraceErrorLogLevelToCSTR();
                        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                          VCAudioLimiter_Start_cold_2();
                      }
                    }
                    else
                    {
                      if (v46 >= 7)
                      {
                        v47 = VRTraceErrorLogLevelToCSTR();
                        v48 = *MEMORY[0x1E0CF2758];
                        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                        {
                          v49 = *v4;
                          v59 = 136315906;
                          v60 = v47;
                          v61 = 2080;
                          v62 = "VCAudioLimiter_Start";
                          v63 = 1024;
                          v64 = 137;
                          v65 = 2048;
                          v66 = v49;
                          _os_log_impl(&dword_1D8A54000, v48, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d voiceLimiterUnit=%p kVCAudioLimiterParameterInputGain kAudioUnitScope_Global", (uint8_t *)&v59, 0x26u);
                        }
                      }
                      v50 = AudioUnitInitialize(*v4);
                      v51 = VRTraceGetErrorLogLevelForModule();
                      if (!v50)
                      {
                        if (v51 >= 7)
                        {
                          v52 = VRTraceErrorLogLevelToCSTR();
                          v53 = *MEMORY[0x1E0CF2758];
                          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                          {
                            v54 = *v4;
                            v59 = 136315906;
                            v60 = v52;
                            v61 = 2080;
                            v62 = "VCAudioLimiter_Start";
                            v63 = 1024;
                            v64 = 141;
                            v65 = 2048;
                            v66 = v54;
                            _os_log_impl(&dword_1D8A54000, v53, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d voiceLimiterUnit=%p AudioUnitInitialize", (uint8_t *)&v59, 0x26u);
                          }
                        }
                        a1 = 1;
                        goto LABEL_46;
                      }
                      if (v51 >= 3)
                      {
                        VRTraceErrorLogLevelToCSTR();
                        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                          VCAudioLimiter_Start_cold_1();
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (*v4)
      {
        AudioComponentInstanceDispose(*v4);
        a1 = 0;
        *v4 = 0;
      }
      else
      {
        a1 = 0;
      }
LABEL_46:
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v55 = VRTraceErrorLogLevelToCSTR();
        v56 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v57 = *v4;
          v59 = 136316162;
          v60 = v55;
          v61 = 2080;
          v62 = "VCAudioLimiter_Start";
          v63 = 1024;
          v64 = 151;
          v65 = 2048;
          v66 = v57;
          v67 = 1024;
          v68 = a1;
          _os_log_impl(&dword_1D8A54000, v56, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d voiceLimiterUnit=%p status=%{BOOL}d", (uint8_t *)&v59, 0x2Cu);
        }
      }
      return a1;
    }
    if (ErrorLogLevelForModule >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioLimiter_Start_cold_10();
    }
    return 0;
  }
  return a1;
}

void VCAudioLimiter_Stop(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  OpaqueAudioComponentInstance *v4;
  uint64_t v5;
  NSObject *v6;
  int v7;
  uint64_t v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v7 = 136315906;
      v8 = v2;
      v9 = 2080;
      v10 = "VCAudioLimiter_Stop";
      v11 = 1024;
      v12 = 156;
      v13 = 2048;
      v14 = a1;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Stopping audioLimiter=%p", (uint8_t *)&v7, 0x26u);
    }
  }
  if (a1)
  {
    v4 = *(OpaqueAudioComponentInstance **)(a1 + 64);
    if (v4)
    {
      AudioComponentInstanceDispose(v4);
      *(_QWORD *)(a1 + 64) = 0;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v6 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v7 = 136315906;
        v8 = v5;
        v9 = 2080;
        v10 = "VCAudioLimiter_Stop";
        v11 = 1024;
        v12 = 164;
        v13 = 2048;
        v14 = a1;
        _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Stopped audioLimiter=%p", (uint8_t *)&v7, 0x26u);
      }
    }
  }
}

uint64_t VCAudioLimiter_Process(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  UInt32 SampleCount;
  __int128 v5;
  AudioBufferList *AudioBufferList;
  OSStatus v7;
  AudioTimeStamp v9;
  AudioUnitRenderActionFlags ioActionFlags;
  uint64_t v11;

  v2 = a1;
  v11 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    ioActionFlags = 512;
    SampleCount = VCAudioBufferList_GetSampleCount(a2);
    v9.mSampleTime = NAN;
    v9.mHostTime = 0xAAAAAAAAAAAAAAAALL;
    v9.mRateScalar = NAN;
    *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&v9.mWordClockTime = v5;
    *(_OWORD *)&v9.mSMPTETime.mType = v5;
    *(_QWORD *)&v9.mFlags = 0xAAAAAAAAAAAAAAAALL;
    VCAudioBufferList_GetAudioTimestamp(a2, (uint64_t)&v9);
    AudioBufferList = (AudioBufferList *)VCAudioBufferList_GetAudioBufferList(a2);
    v7 = AudioUnitProcess(*(AudioUnit *)(v2 + 64), &ioActionFlags, &v9, SampleCount, AudioBufferList);
    v2 = v7 == 0;
    if (v7)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCAudioLimiter_Process_cold_1();
      }
    }
  }
  return v2;
}

long double CalcDecayConstant(double a1, double a2)
{
  double v2;

  v2 = a1 * a2;
  if (v2 >= 0.00001)
    return exp(-6.90775528 / v2);
  else
    return 0.0;
}

void VCRateControlMediaController_EnableBWELogDump(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    *(_QWORD *)(a1 + 288) = a2;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlMediaController_EnableBWELogDump_cold_1();
  }
}

BOOL VCRateControlMediaController_IsAudioOnly(uint64_t a1)
{
  _BOOL8 result;

  if (a1)
    return *(_BYTE *)(a1 + 59) != 0;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    VCRateControlMediaController_IsAudioOnly_cold_1();
  }
  return 0;
}

void VCRateControlMediaController_SetAudioOnly(uint64_t a1, char a2)
{
  if (a1)
  {
    *(_BYTE *)(a1 + 59) = a2;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlMediaController_SetAudioOnly_cold_1();
  }
}

void VCRateControlMediaController_SetSenderProbingEnabled(uint64_t a1, char a2)
{
  if (a1)
  {
    *(_BYTE *)(a1 + 146) = a2;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlMediaController_SetSenderProbingEnabled_cold_1();
  }
}

void VCRateControlMediaController_SetAllowVideoStop(uint64_t a1, char a2)
{
  if (a1)
  {
    *(_BYTE *)(a1 + 63) = a2;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlMediaController_SetAllowVideoStop_cold_1();
  }
}

BOOL VCRateControlMediaController_IsVideoStopped(_BYTE *a1)
{
  _BOOL8 result;

  if (a1)
  {
    return a1[56] || a1[57] || a1[58] != 0;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      VCRateControlMediaController_IsVideoStopped_cold_1();
    }
    return 0;
  }
}

BOOL VCRateControlMediaController_IsVideoStoppedByVCRateControl(uint64_t a1)
{
  if (a1)
    return *(_BYTE *)(a1 + 56) != 0;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlMediaController_IsVideoStoppedByVCRateControl_cold_1();
  }
  return 1;
}

uint64_t VCRateControlMediaController_BasebandFlushCount(uint64_t a1)
{
  uint64_t result;

  if (a1)
    return *(unsigned int *)(a1 + 168);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    VCRateControlMediaController_BasebandFlushCount_cold_1();
  }
  return 0;
}

void VCRateControlMediaController_SetBasebandFlushCount(uint64_t a1, int a2)
{
  if (a1)
  {
    *(_DWORD *)(a1 + 168) = a2;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlMediaController_SetBasebandFlushCount_cold_1();
  }
}

double VCRateControlMediaController_LastBasebandFlushCountChangeTime(uint64_t a1)
{
  if (a1)
    return *(double *)(a1 + 184);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlMediaController_LastBasebandFlushCountChangeTime_cold_1();
  }
  return NAN;
}

void VCRateControlMediaController_SetLastBasebandFlushCountChangeTime(uint64_t a1, double a2)
{
  if (a1)
  {
    *(double *)(a1 + 184) = a2;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlMediaController_SetLastBasebandFlushCountChangeTime_cold_1();
  }
}

double VCRateControlMediaController_LastVideoKeyFrameTime(uint64_t a1)
{
  if (a1)
    return *(double *)(a1 + 112);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlMediaController_LastVideoKeyFrameTime_cold_1();
  }
  return NAN;
}

uint64_t VCRateControlMediaController_TrafficMetricsFromMediaQueueTxHistory(uint64_t a1, int a2)
{
  if (a1)
    return VCMediaQueue_TrafficMetricFromMediaQueueTxHistory(*(_QWORD *)(a1 + 32), a2);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlMediaController_TrafficMetricsFromMediaQueueTxHistory_cold_1();
  }
  return 0;
}

void VCRateControlMediaController_MediaQueueSettings(uint64_t a1, double *a2, double *a3, double *a4, double *a5)
{
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCRateControlMediaController_MediaQueueSettings_cold_1();
    }
    return;
  }
  v6 = *(_QWORD *)(a1 + 24);
  if (v6 == 0xFFFFFFFFLL && !*(_QWORD *)(a1 + 32))
    return;
  if (!a4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 7)
      return;
    v9 = VRTraceErrorLogLevelToCSTR();
    v10 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      return;
    v15 = 136315650;
    v16 = v9;
    v17 = 2080;
    v18 = "VCRateControlMediaController_MediaQueueSettings";
    v19 = 1024;
    v20 = 407;
    v11 = "VCRC [%s] %s:%d inAudioBitrate is nil";
LABEL_29:
    _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, v11, (uint8_t *)&v15, 0x1Cu);
    return;
  }
  if (!a5)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 7)
      return;
    v12 = VRTraceErrorLogLevelToCSTR();
    v10 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      return;
    v15 = 136315650;
    v16 = v12;
    v17 = 2080;
    v18 = "VCRateControlMediaController_MediaQueueSettings";
    v19 = 1024;
    v20 = 408;
    v11 = "VCRC [%s] %s:%d outAudioBitrate is nil";
    goto LABEL_29;
  }
  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 7)
      return;
    v13 = VRTraceErrorLogLevelToCSTR();
    v10 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      return;
    v15 = 136315650;
    v16 = v13;
    v17 = 2080;
    v18 = "VCRateControlMediaController_MediaQueueSettings";
    v19 = 1024;
    v20 = 409;
    v11 = "VCRC [%s] %s:%d inVideoBitrate is nil";
    goto LABEL_29;
  }
  if (a3)
  {
    v7 = *(_DWORD *)(a1 + 40);
    if (v7)
    {
      *a5 = 20000.0;
      *a4 = 20000.0;
      *a3 = (double)v7;
      *a2 = (double)v7;
    }
    else
    {
      v8 = *(_QWORD *)(a1 + 32);
      if (v8)
        VCMediaQueue_RetrieveAudioVideoRates(v8, a4, a2, a5, a3);
      else
        MediaQueue_RetrieveAudioVideoRates(v6, a4, a2, a5, a3);
    }
    return;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v14 = VRTraceErrorLogLevelToCSTR();
    v10 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v15 = 136315650;
      v16 = v14;
      v17 = 2080;
      v18 = "VCRateControlMediaController_MediaQueueSettings";
      v19 = 1024;
      v20 = 410;
      v11 = "VCRC [%s] %s:%d outVideoBitrate is nil";
      goto LABEL_29;
    }
  }
}

void VCRateControlMediaController_MediaQueueRateChangeCounter(uint64_t a1, _DWORD *a2, _QWORD *a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  const char *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v4 = *(_QWORD *)(a1 + 24);
    if (v4 != 0xFFFFFFFFLL || *(_QWORD *)(a1 + 32))
    {
      if (a2)
      {
        if (a3)
        {
          v5 = *(_QWORD *)(a1 + 32);
          if (v5)
            VCMediaQueue_GetTimeRateChanged(v5, a3, a2);
          else
            MediaQueue_GetTimeRateChanged(v4, a3, a2);
          return;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v9 = VRTraceErrorLogLevelToCSTR();
          v7 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v10 = 136315650;
            v11 = v9;
            v12 = 2080;
            v13 = "VCRateControlMediaController_MediaQueueRateChangeCounter";
            v14 = 1024;
            v15 = 431;
            v8 = "VCRC [%s] %s:%d rateChangeTime is nil";
            goto LABEL_18;
          }
        }
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v6 = VRTraceErrorLogLevelToCSTR();
        v7 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v10 = 136315650;
          v11 = v6;
          v12 = 2080;
          v13 = "VCRateControlMediaController_MediaQueueRateChangeCounter";
          v14 = 1024;
          v15 = 430;
          v8 = "VCRC [%s] %s:%d rateChangeCounter is nil";
LABEL_18:
          _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&v10, 0x1Cu);
        }
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlMediaController_MediaQueueRateChangeCounter_cold_1();
  }
}

void VCRateControlMediaController_ComputePacketLoss(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _BYTE v6[12];
  int v7;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  __int128 v11;
  uint64_t v12;
  int v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v3 = *(_QWORD *)(a1 + 24);
    v2 = *(_QWORD *)(a1 + 32);
    if (v3 == 0xFFFFFFFFLL)
    {
      if (!v2)
        return;
      v13 = -1431655766;
    }
    else
    {
      v13 = -1431655766;
      if (!v2)
      {
        MediaQueue_FindPacketInTxHistory(v3, *(_WORD *)a2, *(_DWORD *)(a2 + 4), *(_QWORD *)(a2 + 16), *(_DWORD *)(a2 + 24), (uint64_t)&v13, *(_QWORD *)(a2 + 32), *(_DWORD *)(a2 + 8), *(_QWORD *)(a2 + 56), *(_QWORD *)(a2 + 40), *(_QWORD *)(a2 + 48));
        return;
      }
    }
    *(_QWORD *)v6 = 0;
    *(_WORD *)v6 = *(_WORD *)a2;
    *(_QWORD *)&v6[4] = *(_QWORD *)(a2 + 4);
    v7 = *(_DWORD *)(a2 + 24);
    v4 = 1000 * *(_QWORD *)(a2 + 16);
    v10 = &v13;
    v5 = *(_QWORD *)(a2 + 32);
    v8 = v4;
    v9 = v5;
    v11 = *(_OWORD *)(a2 + 40);
    v12 = *(_QWORD *)(a2 + 56);
    VCMediaQueue_ComputeOneToOneStatsWithPacketInfo(v2, (unsigned __int16 *)v6);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlMediaController_ComputePacketLoss_cold_1();
  }
}

void VCRateControlMediaController_UpdateBasebandSuggestion(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  double v10;
  unsigned int v11;
  unsigned int v12;
  double v13;
  int v14;
  char v15;
  const char *v16;
  __int16 *v17;
  uint64_t v18;
  NSObject *v19;
  int v20;
  unsigned int v21;
  int v22;
  int v23;
  __int16 v24;
  int v25;
  double v26;
  double v27;
  unsigned int v28;
  unsigned int v29;
  double *v30;
  uint64_t v31;
  NSObject *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  NSObject *v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  double v50;
  int v51;
  uint64_t v52;
  unsigned int v53;
  BOOL IsVideoStopped;
  uint64_t v55;
  uint64_t v56;
  void *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  NSObject *v65;
  const char *v66;
  const char *v67;
  const char *v68;
  uint64_t v69;
  _BOOL4 v70;
  char v71;
  __int16 v72;
  uint8_t buf[4];
  uint64_t v74;
  __int16 v75;
  const char *v76;
  __int16 v77;
  int v78;
  __int16 v79;
  const char *v80;
  __int16 v81;
  const char *v82;
  __int16 v83;
  const char *v84;
  uint64_t v85;

  v85 = *MEMORY[0x1E0C80C00];
  if (a1 && a2)
  {
    if (*(_DWORD *)a2 == 1)
    {
      *(_DWORD *)(a1 + 228) = *(_DWORD *)(a2 + 36);
      *(_DWORD *)(a1 + 232) = *(_DWORD *)(a2 + 40);
      *(_DWORD *)(a1 + 236) = *(_DWORD *)(a2 + 28) + *(_DWORD *)(a2 + 24);
      *(_DWORD *)(a1 + 240) = *(_DWORD *)(a2 + 24);
      *(_QWORD *)(a1 + 248) = *(_QWORD *)(a2 + 64);
      *(_QWORD *)(a1 + 256) = *(_QWORD *)(a2 + 80);
      v72 = 0;
      v10 = micro();
      if (*(_DWORD *)(a1 + 228) > *(_DWORD *)(a1 + 44)
        || !*(_DWORD *)(a1 + 236)
        || !VCRateControlMediaController_IsVideoStopped((_BYTE *)a1))
      {
        *(double *)(a1 + 80) = v10;
      }
      if (*(_BYTE *)(a1 + 61))
      {
        v11 = *(_DWORD *)(a1 + 44);
        v12 = *(_DWORD *)(a1 + 232);
        v13 = (double)v12;
        if (*(_DWORD *)(a1 + 212))
          v11 = *(_DWORD *)(a1 + 212);
        if ((double)v11 * 1.5 < v13
          || (v14 = 0, v11 >= v12)
          && v10 - *(double *)(a1 + 216) > 0.25
          && (v14 = 0, v13 + v13 >= (double)(8 * *(_DWORD *)(a1 + 236))))
        {
          v15 = 0;
          v16 = "VCRateControl turn audio stall OFF!\n";
          v17 = &v72;
LABEL_16:
          v14 = 1;
          *(_BYTE *)v17 = 1;
          *(_BYTE *)(a1 + 61) = v15;
          VRLogfilePrintWithTimestamp(*(_QWORD *)(a1 + 280), v16, v4, v5, v6, v7, v8, v9, v71);
        }
      }
      else
      {
        v20 = *(_DWORD *)(a1 + 68);
        if (v20 == 2)
        {
          v21 = 12000;
        }
        else if (v20 == 1)
        {
          v21 = 16000;
        }
        else if (v20)
        {
          v21 = -1431655766;
        }
        else
        {
          v21 = *(_DWORD *)(a1 + 52);
        }
        if (*(_DWORD *)(a1 + 44) < v21)
          v21 = *(_DWORD *)(a1 + 44);
        if (*(_DWORD *)(a1 + 232) < v21
          && (8 * *(_DWORD *)(a1 + 236)) > 2 * (unint64_t)*(unsigned int *)(a1 + 52))
        {
          v16 = "VCRateControl turn audio stall ON!\n";
          v15 = 1;
          v17 = (__int16 *)((char *)&v72 + 1);
          goto LABEL_16;
        }
        v14 = 0;
      }
      if (*(_BYTE *)(a1 + 59))
      {
        v22 = 0;
        v23 = 0;
        v24 = 0;
LABEL_66:
        v29 = 0;
        goto LABEL_67;
      }
      if (*(double *)(a1 + 256) > 0.2)
        *(double *)(a1 + 264) = v10;
      v25 = VCStatisticsCollector_Mode(*(_QWORD *)(a1 + 16));
      v26 = *(double *)(a1 + 248);
      if (v26 <= 2.0 || v25 != 4 && ((v27 = *(double *)(a1 + 112), v27 <= 0.0) || v10 - v27 <= 0.5))
      {
        if (v26 < 0.5)
        {
          if (*(_BYTE *)(a1 + 272))
          {
            *(_BYTE *)(a1 + 272) = 0;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v31 = VRTraceErrorLogLevelToCSTR();
              v32 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315650;
                v74 = v31;
                v75 = 2080;
                v76 = "VCRateControlMediaController_UpdateBasebandSuggestion";
                v77 = 1024;
                v78 = 566;
                _os_log_impl(&dword_1D8A54000, v32, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Baseband queue LWM is hit", buf, 0x1Cu);
              }
            }
          }
        }
        if (!*(_BYTE *)(a1 + 57) || *(_BYTE *)(a1 + 272) || *(_DWORD *)(a1 + 68) || v10 - *(double *)(a1 + 264) <= 2.0)
        {
          v24 = 0;
        }
        else
        {
          *(_BYTE *)(a1 + 57) = 0;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v39 = VRTraceErrorLogLevelToCSTR();
            v40 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315650;
              v74 = v39;
              v75 = 2080;
              v76 = "VCRateControlMediaController_UpdateBasebandSuggestion";
              v77 = 1024;
              v78 = 577;
              _os_log_impl(&dword_1D8A54000, v40, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Baseband queue LWM is hit, [resume video]", buf, 0x1Cu);
            }
          }
          v41 = *(_QWORD *)(a1 + 280);
          if (v41)
            VRLogfilePrintWithTimestamp(v41, "Baseband queue LWM is hit, [delay:%.3f, queueDepth:%u, BBRate:%u, audioRate:%d, audioFraction:%d, resume video]\n", v33, v34, v35, v36, v37, v38, *(_QWORD *)(a1 + 248));
          v14 = 1;
          v24 = 256;
        }
        VCRateControlMediaController_IsVideoStopped((_BYTE *)a1);
        v22 = 0;
        v23 = 0;
        goto LABEL_66;
      }
      v28 = *(_DWORD *)(a1 + 228);
      if (v28 >= *(_DWORD *)(a1 + 44))
      {
        v53 = *(_DWORD *)(a1 + 48);
        IsVideoStopped = VCRateControlMediaController_IsVideoStopped((_BYTE *)a1);
        if (v28 >= v53)
        {
          if (!IsVideoStopped
            && (8 * *(_DWORD *)(a1 + 236)) > 2 * (unint64_t)*(unsigned int *)(a1 + 228)
            && v10 - *(double *)(a1 + 200) > 0.1)
          {
            v29 = 0;
            v23 = 0;
            *(double *)(a1 + 200) = v10;
            v14 = 1;
            v22 = 1;
            goto LABEL_104;
          }
          v29 = 0;
          v23 = 0;
LABEL_100:
          if (!v14 && *(_BYTE *)(a1 + 272))
          {
            v14 = 0;
            v22 = v29;
            goto LABEL_116;
          }
          v22 = v29;
LABEL_104:
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v64 = VRTraceErrorLogLevelToCSTR();
            v65 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              v66 = " flush audio";
              *(_DWORD *)buf = 136316418;
              v74 = v64;
              if (!v23)
                v66 = "";
              v75 = 2080;
              v76 = "VCRateControlMediaController_UpdateBasebandSuggestion";
              v67 = " flush video";
              if (!v22)
                v67 = "";
              v77 = 1024;
              v78 = 547;
              v79 = 2080;
              v80 = v66;
              v81 = 2080;
              if (v29)
                v68 = " stop video";
              else
                v68 = "";
              v82 = v67;
              v83 = 2080;
              v84 = v68;
              _os_log_impl(&dword_1D8A54000, v65, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Baseband queue HWM is hit, [mediaSuggestion:%s%s%s]", buf, 0x3Au);
            }
          }
          v69 = *(_QWORD *)(a1 + 280);
          if (v69)
            VRLogfilePrintWithTimestamp(v69, "Baseband queue HWM is hit, [delay:%.3f, queueDepth:%u, BBRate:%u, minRate:%u, audioRate:%u, audioFraction:%d, mediaSuggestion:%s%s%s]\n", v58, v59, v60, v61, v62, v63, *(_QWORD *)(a1 + 248));
LABEL_116:
          *(_BYTE *)(a1 + 272) = 1;
          v70 = VCRateControlMediaController_IsVideoStopped((_BYTE *)a1);
          v24 = 0;
          if (v23 && v70)
          {
            v24 = 0;
            if (v10 - *(double *)(a1 + 200) > 0.1)
            {
              *(double *)(a1 + 200) = v10;
              v23 = 1;
              v22 = 1;
LABEL_68:
              if (!*(_BYTE *)(a1 + 225))
              {
                if (*(_BYTE *)(a1 + 63))
                  v42 = v29;
                else
                  v42 = 0;
                v43 = *(_DWORD *)(a1 + 168);
                v50 = micro();
                if (v23)
                {
                  v51 = *(_DWORD *)(a1 + 240);
                  if (v51)
                  {
                    ++*(_DWORD *)(a1 + 168);
                    *(double *)(a1 + 184) = v50;
                    v51 = 1;
                    v52 = 0x100000000;
                  }
                  else
                  {
                    v52 = 0;
                  }
                }
                else
                {
                  v52 = 0;
                  v51 = 0;
                }
                if (v22 && *(_DWORD *)(a1 + 240))
                {
                  ++*(_DWORD *)(a1 + 168);
                  *(double *)(a1 + 184) = v50;
                  v51 = 1;
                  v55 = 0x1000000;
                }
                else
                {
                  v55 = 0;
                }
                if (v51)
                {
                  v56 = *(_QWORD *)(a1 + 280);
                  if (v56)
                    VRLogfilePrintWithTimestamp(v56, "Increase basebandFlushCount %d -> %d internally with suggestion.\n", v44, v45, v46, v47, v48, v49, v43);
                }
                v57 = (void *)MEMORY[0x1DF086F1C](a1 + 8);
                objc_msgSend(v57, "mediaController:mediaSuggestionDidChange:", a1, v24 & 0x100 | (unint64_t)v52 | v55 | ((unint64_t)HIBYTE(v72) << 40) | ((unint64_t)v72 << 48) | v42);
                if (v57)
                  CFRelease(v57);
              }
              return;
            }
            v23 = 1;
          }
LABEL_67:
          if (!v14)
            return;
          goto LABEL_68;
        }
        if (!IsVideoStopped)
        {
          v23 = 0;
          v30 = (double *)(a1 + 200);
          v29 = 1;
          goto LABEL_98;
        }
      }
      else
      {
        if (!VCRateControlMediaController_IsVideoStopped((_BYTE *)a1))
        {
          *(double *)(a1 + 192) = v10;
          v30 = (double *)(a1 + 200);
          v29 = 1;
LABEL_91:
          v23 = 1;
LABEL_98:
          *v30 = v10;
          v14 = 1;
          goto LABEL_99;
        }
        if ((8 * *(_DWORD *)(a1 + 236)) > 2 * (unint64_t)*(unsigned int *)(a1 + 44))
        {
          v29 = 0;
          v30 = (double *)(a1 + 192);
          if (v10 - *(double *)(a1 + 192) <= 0.1)
          {
            v23 = 0;
LABEL_99:
            *(_BYTE *)(a1 + 57) = 1;
            goto LABEL_100;
          }
          goto LABEL_91;
        }
      }
      v29 = 0;
      v23 = 0;
      goto LABEL_99;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCRateControlMediaController_UpdateBasebandSuggestion_cold_1();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v18 = VRTraceErrorLogLevelToCSTR();
    v19 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136316162;
      v74 = v18;
      v75 = 2080;
      v76 = "VCRateControlMediaController_UpdateBasebandSuggestion";
      v77 = 1024;
      v78 = 470;
      v79 = 2048;
      v80 = (const char *)a1;
      v81 = 2048;
      v82 = (const char *)a2;
      _os_log_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Invalid parameter. Rate controller=%p statistics=%p", buf, 0x30u);
    }
  }
}

void VCRateControlMediaController_SetAudioFractionTier(uint64_t a1, int a2)
{
  double v2;

  if (a1)
  {
    if (*(_DWORD *)(a1 + 68) != a2)
    {
      *(_DWORD *)(a1 + 68) = a2;
      v2 = 1.0;
      if ((a2 - 1) < 2)
        v2 = 0.0;
      MediaQueue_SetAudioFraction(v2);
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlMediaController_SetAudioFractionTier_cold_1();
  }
}

void VCRateControlMediaController_StopVideoBySmartBrake(unsigned __int8 *a1)
{
  if (a1)
  {
    a1[300] = 1;
    VCRateControlMediaController_StopVideoByVCRateControl(a1);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlMediaController_StopVideoBySmartBrake_cold_1();
  }
}

void VCRateControlMediaController_StopVideoByVCRateControl(unsigned __int8 *a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  void *v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (!a1[59] && (a1[300] || a1[63]))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v2 = VRTraceErrorLogLevelToCSTR();
        v3 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v4 = a1[58];
          v5 = a1[57];
          v6 = a1[56];
          v9 = 136316418;
          v10 = v2;
          v11 = 2080;
          v12 = "VCRateControlMediaController_StopVideoByVCRateControl";
          v13 = 1024;
          v14 = 703;
          v15 = 1024;
          v16 = v4;
          v17 = 1024;
          v18 = v5;
          v19 = 1024;
          v20 = v6;
          _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Suggest to stop video from rate controller due to congestion [pause:%d,stopByBB:%d,stopByRC:%d]", (uint8_t *)&v9, 0x2Eu);
        }
      }
      if (!a1[56] && !a1[57] && !a1[58])
      {
        if (a1[300])
        {
          a1[300] = 0;
          v7 = 0x100000000000001;
        }
        else
        {
          v7 = 1;
        }
        v8 = (void *)MEMORY[0x1DF086F1C](a1 + 8);
        objc_msgSend(v8, "mediaController:mediaSuggestionDidChange:", a1, v7);
        if (v8)
          CFRelease(v8);
      }
      a1[56] = 1;
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlMediaController_StopVideoByVCRateControl_cold_1();
  }
}

void VCRateControlMediaController_ResumeVideoBySmartBrake(unsigned __int8 *a1)
{
  if (a1)
  {
    a1[300] = 1;
    VCRateControlMediaController_ResumeVideo(a1);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlMediaController_ResumeVideoBySmartBrake_cold_1();
  }
}

void VCRateControlMediaController_ResumeVideo(unsigned __int8 *a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  void *v10;
  int v11;
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (!a1[59])
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v2 = VRTraceErrorLogLevelToCSTR();
        v3 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v4 = a1[58];
          v5 = a1[57];
          v6 = a1[56];
          v11 = 136316418;
          v12 = v2;
          v13 = 2080;
          v14 = "VCRateControlMediaController_ResumeVideo";
          v15 = 1024;
          v16 = 727;
          v17 = 1024;
          v18 = v4;
          v19 = 1024;
          v20 = v5;
          v21 = 1024;
          v22 = v6;
          _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Suggest to resume video from rate controller due to no congestion [pause:%d,stopByBB:%d,stopByRC:%d]", (uint8_t *)&v11, 0x2Eu);
        }
      }
      if (a1[58])
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v7 = VRTraceErrorLogLevelToCSTR();
          v8 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v11 = 136315650;
            v12 = v7;
            v13 = 2080;
            v14 = "VCRateControlMediaController_ResumeVideo";
            v15 = 1024;
            v16 = 729;
            _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Stop resuming video since user already pause the video", (uint8_t *)&v11, 0x1Cu);
          }
        }
      }
      else
      {
        if (a1[56] || a1[57])
        {
          if (a1[300])
          {
            a1[300] = 0;
            v9 = 0x100000000000100;
          }
          else
          {
            v9 = 256;
          }
          v10 = (void *)MEMORY[0x1DF086F1C](a1 + 8);
          objc_msgSend(v10, "mediaController:mediaSuggestionDidChange:", a1, v9);
          if (v10)
            CFRelease(v10);
        }
        *((_WORD *)a1 + 28) = 0;
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlMediaController_ResumeVideo_cold_1();
  }
}

void VCRateControlMediaController_SetTargetBitrate(uint64_t a1, unsigned int a2)
{
  if (a1)
  {
    *(_DWORD *)(a1 + 52) = a2;
    *(_BYTE *)(a1 + 62) = a2 >> 5 < 0xC35;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlMediaController_SetTargetBitrate_cold_1();
  }
}

void VCRateControlMediaController_SetMinTargetBitrate(uint64_t a1, int a2)
{
  if (a1)
  {
    *(_DWORD *)(a1 + 48) = a2;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlMediaController_SetMinTargetBitrate_cold_1();
  }
}

uint64_t VCRateControlMediaController_AudioSendingBitrate(uint64_t a1)
{
  uint64_t result;

  if (a1)
    return *(unsigned int *)(a1 + 44);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    VCRateControlMediaController_AudioSendingBitrate_cold_1();
  }
  return 0;
}

void VCRateControlMediaController_SetAudioSendingBitrate(uint64_t a1, unsigned int a2, double a3, double a4)
{
  uint64_t v5;
  NSObject *v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    *(_DWORD *)(a1 + 44) = a2;
    LODWORD(a4) = *(_DWORD *)(a1 + 52);
    if ((double)*(unint64_t *)&a4 * 1.15 < (double)a2 && (int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v5 = VRTraceErrorLogLevelToCSTR();
      v6 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v7 = *(_DWORD *)(a1 + 44);
        v8 = *(_DWORD *)(a1 + 52);
        v9 = 136316162;
        v10 = v5;
        v11 = 2080;
        v12 = "VCRateControlMediaController_SetAudioSendingBitrate";
        v13 = 1024;
        v14 = 860;
        v15 = 1024;
        v16 = v7;
        v17 = 1024;
        v18 = v8;
        _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Audio sending bitrate %u is set much higher than the target bitrate %u", (uint8_t *)&v9, 0x28u);
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlMediaController_SetAudioSendingBitrate_cold_1();
  }
}

void VCRateControlMediaController_SetShouldDisableLargeFrameRequestsWhenInitialRampUp(uint64_t a1, char a2)
{
  if (a1)
  {
    *(_BYTE *)(a1 + 144) = a2;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlMediaController_SetShouldDisableLargeFrameRequestsWhenInitialRampUp_cold_1();
  }
}

void VCRateControlMediaController_SetRateLimitedMaxTimeExceeded(uint64_t a1, char a2)
{
  if (a1)
  {
    *(_BYTE *)(a1 + 145) = a2;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlMediaController_SetRateLimitedMaxTimeExceeded_cold_1();
  }
}

double VCRateControlMediaController_LastVideoRefreshFrameTime(uint64_t a1)
{
  if (a1)
    return *(double *)(a1 + 104);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCRateControlMediaController_LastVideoRefreshFrameTime_cold_1();
  }
  return NAN;
}

uint64_t VCRateControlMediaController_AudioFractionTier(uint64_t a1)
{
  uint64_t result;

  if (a1)
    return *(unsigned int *)(a1 + 68);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    VCRateControlMediaController_AudioFractionTier_cold_1();
  }
  return 0;
}

BOOL VCRateControlMediaController_RampDownAudioFraction(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  double v8;
  int v9;
  unsigned int v11;
  int v12;
  uint64_t v13;
  _BOOL8 result;

  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      VCRateControlMediaController_RampDownAudioFraction_cold_1();
    }
    return 0;
  }
  if (*(_BYTE *)(a1 + 59) || !*(_BYTE *)(a1 + 56) && !*(_BYTE *)(a1 + 57) && !*(_BYTE *)(a1 + 58))
    return 0;
  v8 = micro();
  v9 = *(_DWORD *)(a1 + 68);
  if (v8 - *(double *)(a1 + 80) <= 2.0 || v9 == 2)
    return 0;
  v11 = *(_DWORD *)(a1 + 228);
  if (v11 >> 3 >= 0x753)
    v12 = v11 >> 5 < 0x271;
  else
    v12 = 2;
  *(_DWORD *)(a1 + 68) = v12;
  *(double *)(a1 + 72) = v8;
  *(double *)(a1 + 80) = v8;
  v13 = *(_QWORD *)(a1 + 280);
  if (v13)
    VRLogfilePrintWithTimestamp(v13, "Change audio fraction tier from %d -> %d.\n", v2, v3, v4, v5, v6, v7, v9);
  return 1;
}

BOOL VCRateControlGetLargeFrameSize(void *a1, _DWORD *a2)
{
  if (a1 && a2)
    *a2 = objc_msgSend(a1, "probingLargeFrameSize");
  return a1 != 0;
}

BOOL VCRateControlScheduleProbingSequence(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  char v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v8 = 0;
    objc_msgSend(a1, "scheduleProbingSequenceWithFrameSize:paddingBytes:timestamp:fecRatio:isProbingSequenceScheduled:", a2, a3, a4, &v8);
    if (a5)
      *a5 = v8;
  }
  return a1 != 0;
}

BOOL VCRateControlGetProbingSequencePacketizationInfo(void *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  int v7;

  if (a1)
  {
    if (a2)
      *a2 = objc_msgSend(a1, "probingSequencePacketCount");
    if (a3)
    {
      v7 = objc_msgSend(a1, "probingSequencePacketSize");
      *a3 = v7;
      if (a4)
        *a4 = v7;
    }
  }
  return a1 != 0;
}

BOOL VCRateControlPauseVideo(void *a1, uint64_t a2)
{
  if (a1)
    objc_msgSend(a1, "pauseVideoByUser:", a2);
  return a1 != 0;
}

BOOL VCRateControlSetAFRCBandwidth(void *a1, uint64_t a2, uint64_t a3)
{
  if (a1 && !objc_msgSend(a1, "statisticsCollector"))
  {
    objc_msgSend(a1, "setAfrcRemoteEstimatedBandwidth:", a2);
    objc_msgSend(a1, "setTargetBitrate:", a3);
  }
  return a1 != 0;
}

uint64_t VCConnection_Priority(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a1)
    return *(unsigned int *)(a1 + 28);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136315650;
      v5 = v2;
      v6 = 2080;
      v7 = "VCConnection_Priority";
      v8 = 1024;
      v9 = 48;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v4, 0x1Cu);
    }
  }
  return 0xFFFFFFFFLL;
}

void VCConnection_SetPriority(uint64_t a1, int a2)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    *(_DWORD *)(a1 + 28) = a2;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136315650;
      v5 = v2;
      v6 = 2080;
      v7 = "VCConnection_SetPriority";
      v8 = 1024;
      v9 = 56;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v4, 0x1Cu);
    }
  }
}

uint64_t VCConnection_IsLocalOnWired(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a1)
    return (*(uint64_t (**)(void))(a1 + 160))();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136315650;
      v5 = v2;
      v6 = 2080;
      v7 = "VCConnection_IsLocalOnWired";
      v8 = 1024;
      v9 = 350;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v4, 0x1Cu);
    }
  }
  return 0;
}

uint64_t VCConnection_IsLocalOnWiFiOrWired(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a1)
    return (*(uint64_t (**)(void))(a1 + 128))();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136315650;
      v5 = v2;
      v6 = 2080;
      v7 = "VCConnection_IsLocalOnWiFiOrWired";
      v8 = 1024;
      v9 = 318;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v4, 0x1Cu);
    }
  }
  return 0;
}

uint64_t VCConnection_IsRemoteOnWired(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a1)
    return (*(uint64_t (**)(void))(a1 + 168))();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136315650;
      v5 = v2;
      v6 = 2080;
      v7 = "VCConnection_IsRemoteOnWired";
      v8 = 1024;
      v9 = 358;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v4, 0x1Cu);
    }
  }
  return 0;
}

uint64_t VCConnection_IsRemoteOnWiFiOrWired(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a1)
    return (*(uint64_t (**)(void))(a1 + 136))();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136315650;
      v5 = v2;
      v6 = 2080;
      v7 = "VCConnection_IsRemoteOnWiFiOrWired";
      v8 = 1024;
      v9 = 326;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v4, 0x1Cu);
    }
  }
  return 0;
}

uint64_t VCConnection_IsRelay(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a1)
    return (*(uint64_t (**)(void))(a1 + 48))();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136315650;
      v5 = v2;
      v6 = 2080;
      v7 = "VCConnection_IsRelay";
      v8 = 1024;
      v9 = 236;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v4, 0x1Cu);
    }
  }
  return 0;
}

uint64_t VCConnection_IsEndToEndLink(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a1)
    return (*(uint64_t (**)(void))(a1 + 184))();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136315650;
      v5 = v2;
      v6 = 2080;
      v7 = "VCConnection_IsEndToEndLink";
      v8 = 1024;
      v9 = 374;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v4, 0x1Cu);
    }
  }
  return 0;
}

uint64_t VCConnection_IsIPv6(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a1)
    return (*(uint64_t (**)(void))(a1 + 80))();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136315650;
      v5 = v2;
      v6 = 2080;
      v7 = "VCConnection_IsIPv6";
      v8 = 1024;
      v9 = 270;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v4, 0x1Cu);
    }
  }
  return 0;
}

uint64_t VCConnection_MatchesSourceDestinationInfo(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  NSObject *v6;
  int v7;
  uint64_t v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  uint64_t v14;
  __int16 v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (a1 && a2)
    return (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 32))(a1, a2);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v5 = VRTraceErrorLogLevelToCSTR();
    v6 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v7 = 136316162;
      v8 = v5;
      v9 = 2080;
      v10 = "VCConnection_MatchesSourceDestinationInfo";
      v11 = 1024;
      v12 = 220;
      v13 = 2048;
      v14 = a1;
      v15 = 2048;
      v16 = a2;
      _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d NULL instance=%p or sourceDest=%p passed", (uint8_t *)&v7, 0x30u);
    }
  }
  return 0;
}

void VCConnection_SourceDestinationInfo(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  int v6;
  uint64_t v7;
  __int16 v8;
  const char *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  uint64_t v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (a1 && a2)
  {
    (*(void (**)(uint64_t, uint64_t))(a1 + 40))(a1, a2);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v6 = 136316162;
      v7 = v4;
      v8 = 2080;
      v9 = "VCConnection_SourceDestinationInfo";
      v10 = 1024;
      v11 = 228;
      v12 = 2048;
      v13 = a1;
      v14 = 2048;
      v15 = a2;
      _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance=%p or sourceDestinationInfo=%p passed", (uint8_t *)&v6, 0x30u);
    }
  }
}

uint64_t VCConnection_Equal(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  if (a1 == a2)
    return 1;
  v2 = 0;
  if (a1 && a2)
  {
    if (*(unsigned __int8 *)(a1 + 24) == *(unsigned __int8 *)(a2 + 24))
      return (*(uint64_t (**)(void))(a1 + 56))();
    return 0;
  }
  return v2;
}

uint64_t VCConnection_IsLocalOnCellular(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a1)
    return (*(uint64_t (**)(void))(a1 + 64))();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136315650;
      v5 = v2;
      v6 = 2080;
      v7 = "VCConnection_IsLocalOnCellular";
      v8 = 1024;
      v9 = 254;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v4, 0x1Cu);
    }
  }
  return 0;
}

uint64_t VCConnection_IsRemoteOnCellular(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a1)
    return (*(uint64_t (**)(void))(a1 + 72))();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136315650;
      v5 = v2;
      v6 = 2080;
      v7 = "VCConnection_IsRemoteOnCellular";
      v8 = 1024;
      v9 = 262;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v4, 0x1Cu);
    }
  }
  return 0;
}

uint64_t VCConnection_LocalCellTech(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a1)
    return (*(uint64_t (**)(void))(a1 + 88))();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136315650;
      v5 = v2;
      v6 = 2080;
      v7 = "VCConnection_LocalCellTech";
      v8 = 1024;
      v9 = 278;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v4, 0x1Cu);
    }
  }
  return 0;
}

void VCConnection_SetLocalCellTech(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  int v3;
  uint64_t v4;
  __int16 v5;
  const char *v6;
  __int16 v7;
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    (*(void (**)(void))(a1 + 96))();
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v1 = VRTraceErrorLogLevelToCSTR();
    v2 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v3 = 136315650;
      v4 = v1;
      v5 = 2080;
      v6 = "VCConnection_SetLocalCellTech";
      v7 = 1024;
      v8 = 286;
      _os_log_impl(&dword_1D8A54000, v2, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v3, 0x1Cu);
    }
  }
}

uint64_t VCConnection_RemoteCellTech(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a1)
    return (*(uint64_t (**)(void))(a1 + 104))();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136315650;
      v5 = v2;
      v6 = 2080;
      v7 = "VCConnection_RemoteCellTech";
      v8 = 1024;
      v9 = 294;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v4, 0x1Cu);
    }
  }
  return 0;
}

void VCConnection_SetRemoteCellTech(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  int v3;
  uint64_t v4;
  __int16 v5;
  const char *v6;
  __int16 v7;
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    (*(void (**)(void))(a1 + 112))();
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v1 = VRTraceErrorLogLevelToCSTR();
    v2 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v3 = 136315650;
      v4 = v1;
      v5 = 2080;
      v6 = "VCConnection_SetRemoteCellTech";
      v7 = 1024;
      v8 = 302;
      _os_log_impl(&dword_1D8A54000, v2, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v3, 0x1Cu);
    }
  }
}

uint64_t VCConnection_CopyDescription(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a1)
    return (*(uint64_t (**)(void))(a1 + 120))();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136315650;
      v5 = v2;
      v6 = 2080;
      v7 = "VCConnection_CopyDescription";
      v8 = 1024;
      v9 = 310;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v4, 0x1Cu);
    }
  }
  return 0;
}

uint64_t VCConnection_IsLocalOnWiFi(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a1)
    return (*(uint64_t (**)(void))(a1 + 144))();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136315650;
      v5 = v2;
      v6 = 2080;
      v7 = "VCConnection_IsLocalOnWiFi";
      v8 = 1024;
      v9 = 334;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v4, 0x1Cu);
    }
  }
  return 0;
}

uint64_t VCConnection_IsRemoteOnWiFi(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a1)
    return (*(uint64_t (**)(void))(a1 + 152))();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136315650;
      v5 = v2;
      v6 = 2080;
      v7 = "VCConnection_IsRemoteOnWiFi";
      v8 = 1024;
      v9 = 342;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v4, 0x1Cu);
    }
  }
  return 0;
}

uint64_t VCConnection_IsOnSameInterfacesWithConnection(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a1)
    return (*(uint64_t (**)(void))(a1 + 176))();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136315650;
      v5 = v2;
      v6 = 2080;
      v7 = "VCConnection_IsOnSameInterfacesWithConnection";
      v8 = 1024;
      v9 = 366;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v4, 0x1Cu);
    }
  }
  return 0;
}

uint64_t VCConnection_ConnectionID(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a1)
    return (*(uint64_t (**)(void))(a1 + 192))();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136315650;
      v5 = v2;
      v6 = 2080;
      v7 = "VCConnection_ConnectionID";
      v8 = 1024;
      v9 = 382;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v4, 0x1Cu);
    }
  }
  return 0;
}

uint64_t VCConnection_IsLocalExpensive(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a1)
    return (*(uint64_t (**)(void))(a1 + 200))();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136315650;
      v5 = v2;
      v6 = 2080;
      v7 = "VCConnection_IsLocalExpensive";
      v8 = 1024;
      v9 = 390;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v4, 0x1Cu);
    }
  }
  return 0;
}

uint64_t VCConnection_IsLocalConstrained(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a1)
    return (*(uint64_t (**)(void))(a1 + 208))();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136315650;
      v5 = v2;
      v6 = 2080;
      v7 = "VCConnection_IsLocalConstrained";
      v8 = 1024;
      v9 = 398;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v4, 0x1Cu);
    }
  }
  return 0;
}

uint64_t VCConnection_IsRemoteExpensive(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a1)
    return (*(uint64_t (**)(void))(a1 + 216))();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136315650;
      v5 = v2;
      v6 = 2080;
      v7 = "VCConnection_IsRemoteExpensive";
      v8 = 1024;
      v9 = 406;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v4, 0x1Cu);
    }
  }
  return 0;
}

uint64_t VCConnection_IsRemoteConstrained(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a1)
    return (*(uint64_t (**)(void))(a1 + 224))();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136315650;
      v5 = v2;
      v6 = 2080;
      v7 = "VCConnection_IsRemoteConstrained";
      v8 = 1024;
      v9 = 414;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v4, 0x1Cu);
    }
  }
  return 0;
}

uint64_t VCConnection_ReportingIPVersion(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a1)
    return (*(uint64_t (**)(void))(a1 + 232))();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136315650;
      v5 = v2;
      v6 = 2080;
      v7 = "VCConnection_ReportingIPVersion";
      v8 = 1024;
      v9 = 422;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v4, 0x1Cu);
    }
  }
  return 0;
}

uint64_t VCConnection_ReportingConnectionInterface(uint64_t (**a1)(_QWORD), int a2)
{
  char v3;
  int v4;
  int v6;
  uint64_t v7;
  NSObject *v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a2)
    {
      v3 = a1[16](a1);
      v4 = a1[18](a1);
      if ((v3 & 1) != 0)
        goto LABEL_4;
    }
    else
    {
      v6 = a1[17](a1);
      v4 = a1[19](a1);
      if (v6)
      {
LABEL_4:
        if (v4)
          return 87;
        else
          return 69;
      }
    }
    return 67;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v7 = VRTraceErrorLogLevelToCSTR();
    v8 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315650;
      v10 = v7;
      v11 = 2080;
      v12 = "VCConnection_ReportingConnectionInterface";
      v13 = 1024;
      v14 = 429;
      _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d instance should not be nil", (uint8_t *)&v9, 0x1Cu);
    }
  }
  return 88;
}

uint64_t VCConnection_ReportingConnectionType(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if ((*(unsigned int (**)(void))(a1 + 48))())
      return 82;
    else
      return 80;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v2 = VRTraceErrorLogLevelToCSTR();
      v3 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v4 = 136315650;
        v5 = v2;
        v6 = 2080;
        v7 = "VCConnection_ReportingConnectionType";
        v8 = 1024;
        v9 = 444;
        _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d instance should not be nil", (uint8_t *)&v4, 0x1Cu);
      }
    }
    return 88;
  }
}

uint64_t VCConnection_ReportingQRServerConfig(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a1)
    return (*(uint64_t (**)(void))(a1 + 240))();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136315650;
      v5 = v2;
      v6 = 2080;
      v7 = "VCConnection_ReportingQRServerConfig";
      v8 = 1024;
      v9 = 456;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v4, 0x1Cu);
    }
  }
  return 0;
}

uint64_t VCConnection_IsHopByHopEncryptionSupported(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a1)
    return (*(uint64_t (**)(void))(a1 + 248))();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136315650;
      v5 = v2;
      v6 = 2080;
      v7 = "VCConnection_IsHopByHopEncryptionSupported";
      v8 = 1024;
      v9 = 465;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v4, 0x1Cu);
    }
  }
  return 0;
}

uint64_t VCConnection_PerPacketConnectionOverhead(uint64_t a1)
{
  if (a1)
    return *(_QWORD *)(a1 + 16);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCConnection_PerPacketConnectionOverhead_cold_1();
  }
  return 0;
}

uint64_t VCConnection_GetDataMode(uint64_t a1)
{
  int v2;
  int v3;
  unsigned int v4;
  int v5;
  uint64_t result;

  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!(_DWORD)result)
        return result;
      VCConnection_GetDataMode_cold_1();
    }
    return 0;
  }
  if ((*(unsigned int (**)(void))(a1 + 200))())
    v2 = 2;
  else
    v2 = 0;
  v3 = (*(uint64_t (**)(uint64_t))(a1 + 216))(a1);
  v4 = (*(uint64_t (**)(uint64_t))(a1 + 208))(a1);
  if ((*(unsigned int (**)(uint64_t))(a1 + 224))(a1) | v3)
    v5 = v2 | 8;
  else
    v5 = v2;
  return v5 | v4;
}

uint64_t DLCreateHandle(uint64_t *a1, int a2, uint64_t a3, int a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8)
{
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;
  const char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  const char *v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  uint64_t v54;
  uint64_t v55;
  NSObject *v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  uint64_t Handle;
  int v69;
  uint64_t v70;
  __int16 v71;
  const char *v72;
  __int16 v73;
  int v74;
  __int16 v75;
  int v76;
  __int16 v77;
  uint64_t v78;
  pthread_mutexattr_t v79;
  uint64_t v80;

  v80 = *MEMORY[0x1E0C80C00];
  v79.__sig = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)v79.__opaque = 0xAAAAAAAAAAAAAAAALL;
  if (a3 && *(_DWORD *)(a3 + 4) == 1)
  {
    v16 = (uint64_t *)malloc_type_calloc(1uLL, 0x408uLL, 0x10A004066E76C10uLL);
    if (v16)
    {
      v17 = v16;
      *((_DWORD *)v16 + 1) = a2;
      *((_DWORD *)v16 + 2) = a6;
      *((_DWORD *)v16 + 252) = 0;
      *((_DWORD *)v16 + 3) = a4;
      v16[127] = a7;
      v16[128] = a8;
      v18 = MQCreateHandle(v16 + 121);
      if ((v18 & 0x80000000) == 0)
      {
        pthread_mutexattr_init(&v79);
        pthread_mutexattr_settype(&v79, 2);
        pthread_mutex_init((pthread_mutex_t *)(v17 + 70), &v79);
        pthread_mutexattr_destroy(&v79);
        if (a2)
          v19 = 1;
        else
          v19 = 7;
        *(_DWORD *)v17 = v19;
        *((_DWORD *)v17 + 8) = *(_DWORD *)(a3 + 568);
        v20 = *(_QWORD *)(a3 + 728);
        v21 = *(_OWORD *)(a3 + 712);
        *(_OWORD *)((char *)v17 + 36) = *(_OWORD *)(a3 + 696);
        *(uint64_t *)((char *)v17 + 68) = v20;
        *(_OWORD *)((char *)v17 + 52) = v21;
        v23 = *(_OWORD *)(a3 + 736);
        v22 = *(_OWORD *)(a3 + 752);
        *(uint64_t *)((char *)v17 + 108) = *(_QWORD *)(a3 + 768);
        *(_OWORD *)((char *)v17 + 76) = v23;
        *(_OWORD *)((char *)v17 + 92) = v22;
        v25 = *(_OWORD *)(a3 + 776);
        v24 = *(_OWORD *)(a3 + 792);
        *(uint64_t *)((char *)v17 + 148) = *(_QWORD *)(a3 + 808);
        *(_OWORD *)((char *)v17 + 116) = v25;
        *(_OWORD *)((char *)v17 + 132) = v24;
        v27 = *(_OWORD *)(a3 + 816);
        v26 = *(_OWORD *)(a3 + 832);
        *(uint64_t *)((char *)v17 + 188) = *(_QWORD *)(a3 + 848);
        *(_OWORD *)((char *)v17 + 156) = v27;
        *(_OWORD *)((char *)v17 + 172) = v26;
        v29 = *(_OWORD *)(a3 + 856);
        v28 = *(_OWORD *)(a3 + 872);
        *(uint64_t *)((char *)v17 + 228) = *(_QWORD *)(a3 + 888);
        *(_OWORD *)((char *)v17 + 196) = v29;
        *(_OWORD *)((char *)v17 + 212) = v28;
        if (IsIPPORTValid())
        {
          v30 = *(_OWORD *)(a3 + 856);
          v31 = *(_OWORD *)(a3 + 872);
          *(uint64_t *)((char *)v17 + 188) = *(_QWORD *)(a3 + 888);
          *(_OWORD *)((char *)v17 + 156) = v30;
          *(_OWORD *)((char *)v17 + 172) = v31;
        }
        v32 = *(_QWORD *)(a3 + 504);
        if (v32)
        {
          v33 = *(const char **)(a3 + 208);
          if (v33)
          {
            v34 = *(_QWORD *)(a3 + 312);
            if (v34)
            {
              v35 = *(_QWORD *)(a3 + 480);
              if (v35)
              {
                v36 = *(uint64_t **)(a3 + 272);
                if (v36)
                {
                  strncpy((char *)v17 + 510, (const char *)(v32 + 4), 4uLL);
                  strncpy((char *)v17 + 236, v33, 0x3CuLL);
                  if (!a4)
                  {
                    strncpy((char *)v17 + 296, (const char *)v34, 0x2BuLL);
                    strncpy((char *)v17 + 339, (const char *)v35, 0x2BuLL);
                    strncpy((char *)v17 + 382, (const char *)(v34 + 156), 0x40uLL);
                    v17[2] = *v36;
                    v17[3] = 0;
                    v57 = *(_OWORD *)(v34 + 108);
                    v58 = *(_OWORD *)(v34 + 140);
                    v59 = *(_OWORD *)(v34 + 92);
                    *((_OWORD *)v17 + 44) = *(_OWORD *)(v34 + 124);
                    *((_OWORD *)v17 + 45) = v58;
                    *((_OWORD *)v17 + 42) = v59;
                    *((_OWORD *)v17 + 43) = v57;
                    v60 = *(_OWORD *)(v34 + 44);
                    v61 = *(_OWORD *)(v34 + 76);
                    *((_OWORD *)v17 + 40) = *(_OWORD *)(v34 + 60);
                    *((_OWORD *)v17 + 41) = v61;
                    *((_OWORD *)v17 + 39) = v60;
                    v62 = *(_OWORD *)(v35 + 108);
                    v63 = *(_OWORD *)(v35 + 140);
                    v64 = *(_OWORD *)(v35 + 92);
                    *((_OWORD *)v17 + 51) = *(_OWORD *)(v35 + 124);
                    *((_OWORD *)v17 + 52) = v63;
                    *((_OWORD *)v17 + 49) = v64;
                    *((_OWORD *)v17 + 50) = v62;
                    v65 = *(_OWORD *)(v35 + 44);
                    v66 = *(_OWORD *)(v35 + 76);
                    *((_OWORD *)v17 + 47) = *(_OWORD *)(v35 + 60);
                    *((_OWORD *)v17 + 48) = v66;
                    *((_OWORD *)v17 + 46) = v65;
LABEL_33:
                    v17[124] = a5;
                    Handle = CreateHandle();
                    *a1 = Handle;
                    if (Handle != 0xFFFFFFFFLL)
                      return 0;
                    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                    {
                      VRTraceErrorLogLevelToCSTR();
                      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                        DLCreateHandle_cold_3();
                    }
                    pthread_mutex_destroy((pthread_mutex_t *)(v17 + 70));
                    MQCloseHandle();
                    free(v17);
                    return 2148270085;
                  }
                  v37 = *(_QWORD *)(a3 + 224);
                  if (v37)
                  {
                    v38 = *(const char **)(a3 + 496);
                    strncpy((char *)v17 + 296, (const char *)v35, 0x2BuLL);
                    strncpy((char *)v17 + 339, (const char *)v34, 0x2BuLL);
                    strncpy((char *)v17 + 446, (const char *)(v34 + 156), 0x40uLL);
                    if (v38)
                      strncpy((char *)v17 + 514, v38, 0x2BuLL);
                    v17[2] = 0;
                    v17[3] = *v36;
                    v39 = *(_OWORD *)(v37 + 44);
                    v40 = *(_OWORD *)(v37 + 76);
                    *((_OWORD *)v17 + 54) = *(_OWORD *)(v37 + 60);
                    *((_OWORD *)v17 + 55) = v40;
                    *((_OWORD *)v17 + 53) = v39;
                    v41 = *(_OWORD *)(v37 + 92);
                    v42 = *(_OWORD *)(v37 + 108);
                    v43 = *(_OWORD *)(v37 + 140);
                    *((_OWORD *)v17 + 58) = *(_OWORD *)(v37 + 124);
                    *((_OWORD *)v17 + 59) = v43;
                    *((_OWORD *)v17 + 56) = v41;
                    *((_OWORD *)v17 + 57) = v42;
                    v44 = *(_OWORD *)(v35 + 108);
                    v45 = *(_OWORD *)(v35 + 140);
                    v46 = *(_OWORD *)(v35 + 92);
                    *((_OWORD *)v17 + 44) = *(_OWORD *)(v35 + 124);
                    *((_OWORD *)v17 + 45) = v45;
                    *((_OWORD *)v17 + 42) = v46;
                    *((_OWORD *)v17 + 43) = v44;
                    v47 = *(_OWORD *)(v35 + 44);
                    v48 = *(_OWORD *)(v35 + 76);
                    *((_OWORD *)v17 + 40) = *(_OWORD *)(v35 + 60);
                    *((_OWORD *)v17 + 41) = v48;
                    *((_OWORD *)v17 + 39) = v47;
                    v49 = *(_OWORD *)(v34 + 44);
                    v50 = *(_OWORD *)(v34 + 76);
                    *((_OWORD *)v17 + 47) = *(_OWORD *)(v34 + 60);
                    *((_OWORD *)v17 + 48) = v50;
                    *((_OWORD *)v17 + 46) = v49;
                    v51 = *(_OWORD *)(v34 + 92);
                    v52 = *(_OWORD *)(v34 + 108);
                    v53 = *(_OWORD *)(v34 + 140);
                    *((_OWORD *)v17 + 51) = *(_OWORD *)(v34 + 124);
                    *((_OWORD *)v17 + 52) = v53;
                    *((_OWORD *)v17 + 49) = v51;
                    *((_OWORD *)v17 + 50) = v52;
                    *((_DWORD *)v17 + 240) = *(_DWORD *)(v37 + 156);
                    goto LABEL_33;
                  }
                }
              }
            }
          }
        }
        pthread_mutex_destroy((pthread_mutex_t *)(v17 + 70));
        MQCloseHandle();
        free(v17);
        return 2148270114;
      }
      v54 = v18;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          DLCreateHandle_cold_2();
      }
      free(v17);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() < 3)
    {
      return 2148270083;
    }
    else
    {
      VRTraceErrorLogLevelToCSTR();
      v54 = 2148270083;
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        DLCreateHandle_cold_1();
    }
  }
  else
  {
    v54 = 2148270081;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v55 = VRTraceErrorLogLevelToCSTR();
      v56 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v69 = 136316162;
        v70 = v55;
        v71 = 2080;
        v72 = "DLCreateHandle";
        v73 = 1024;
        v74 = 74;
        v75 = 1024;
        v76 = 74;
        v77 = 2048;
        v78 = a3;
        _os_log_impl(&dword_1D8A54000, v56, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/Dialog.c:%d: Invalid Request message(%p)", (uint8_t *)&v69, 0x2Cu);
      }
    }
  }
  return v54;
}

uint64_t DLCloseHandle()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  pthread_mutex_t *v3;
  uint64_t v4;
  _QWORD *v5;
  void (*v6)(_QWORD, _QWORD, _QWORD);

  v0 = 2148270082;
  v1 = CheckInHandleDebug();
  if (v1)
  {
    v2 = v1;
    v3 = (pthread_mutex_t *)(v1 + 560);
    pthread_mutex_lock((pthread_mutex_t *)(v1 + 560));
    v4 = CheckInHandleDebug();
    *(_DWORD *)(v2 + 1004) = 1;
    pthread_mutex_unlock(v3);
    CheckOutHandleDebug();
    if (v4)
    {
      MQCloseHandle();
      CheckOutHandleDebug();
      v5 = *(_QWORD **)(v4 + 976);
      if (v5)
        FreeSipMsg(v5);
      pthread_mutex_destroy((pthread_mutex_t *)(v4 + 560));
      v6 = *(void (**)(_QWORD, _QWORD, _QWORD))(v4 + 1016);
      if (v6)
        v6(*(_QWORD *)(v4 + 1024), *(unsigned int *)(v4 + 4), 0);
      free((void *)v4);
      return 0;
    }
  }
  return v0;
}

uint64_t DLCloseHandleAll()
{
  CloseAllHandles();
  return 0;
}

uint64_t DLUpdate(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  pthread_mutex_t *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  char *v15;
  const char *v16;
  size_t v17;
  uint64_t v18;
  const char *v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  int v26;
  uint64_t v27;
  __int16 v28;
  const char *v29;
  __int16 v30;
  int v31;
  __int16 v32;
  int v33;
  __int16 v34;
  uint64_t v35;
  __int16 v36;
  int v37;
  __int16 v38;
  int v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  if (a2 && *(_DWORD *)(a2 + 4) == 2)
  {
    v3 = *(_QWORD *)(a2 + 272);
    if (v3)
    {
      v4 = CheckInHandleDebug();
      if (v4)
      {
        v5 = v4;
        v6 = (pthread_mutex_t *)(v4 + 560);
        pthread_mutex_lock((pthread_mutex_t *)(v4 + 560));
        v7 = *(_DWORD *)(v3 + 8);
        if ((v7 - 3) < 2)
        {
          if ((*(_DWORD *)(a2 + 8) - 6) <= 0x2E)
            *(_DWORD *)v5 = 6;
          goto LABEL_32;
        }
        if (v7 != 1)
          goto LABEL_32;
        if ((*(_DWORD *)(a2 + 8) - 1) > 4)
        {
          v13 = 3;
        }
        else
        {
          if (*(_DWORD *)v5 > 1u)
          {
LABEL_22:
            v14 = *(_QWORD *)(a2 + 480);
            if (!*(_DWORD *)(v5 + 12))
            {
              v18 = *(_QWORD *)(a2 + 224);
              v19 = *(const char **)(a2 + 496);
              if (v14)
                strncpy((char *)(v5 + 446), (const char *)(v14 + 156), 0x40uLL);
              if (v18)
              {
                v20 = *(_OWORD *)(v18 + 44);
                v21 = *(_OWORD *)(v18 + 76);
                *(_OWORD *)(v5 + 864) = *(_OWORD *)(v18 + 60);
                *(_OWORD *)(v5 + 880) = v21;
                *(_OWORD *)(v5 + 848) = v20;
                v22 = *(_OWORD *)(v18 + 92);
                v23 = *(_OWORD *)(v18 + 108);
                v24 = *(_OWORD *)(v18 + 140);
                *(_OWORD *)(v5 + 928) = *(_OWORD *)(v18 + 124);
                *(_OWORD *)(v5 + 944) = v24;
                *(_OWORD *)(v5 + 896) = v22;
                *(_OWORD *)(v5 + 912) = v23;
                *(_DWORD *)(v5 + 960) = *(_DWORD *)(v18 + 156);
              }
              if (!v19)
                goto LABEL_32;
              v15 = (char *)(v5 + 514);
              v16 = v19;
              v17 = 43;
              goto LABEL_31;
            }
            if (v14)
            {
              v15 = (char *)(v5 + 382);
              v16 = (const char *)(v14 + 156);
              v17 = 64;
LABEL_31:
              strncpy(v15, v16, v17);
            }
LABEL_32:
            pthread_mutex_unlock(v6);
            CheckOutHandleDebug();
            return 0;
          }
          v13 = 2;
        }
        *(_DWORD *)v5 = v13;
        goto LABEL_22;
      }
      return 2148270082;
    }
    else
    {
      return 2148270114;
    }
  }
  else
  {
    v8 = 2148270081;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v9 = VRTraceErrorLogLevelToCSTR();
      v10 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        if (a2)
        {
          v11 = *(_DWORD *)(a2 + 4);
          v12 = *(_DWORD *)(a2 + 8);
        }
        else
        {
          v11 = -1;
          v12 = -1;
        }
        v26 = 136316674;
        v27 = v9;
        v28 = 2080;
        v29 = "DLUpdate";
        v30 = 1024;
        v31 = 238;
        v32 = 1024;
        v33 = 238;
        v34 = 2048;
        v35 = a2;
        v36 = 1024;
        v37 = v11;
        v38 = 1024;
        v39 = v12;
        _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/Dialog.c:%d: Invalid Response message(%p,%d,%d)", (uint8_t *)&v26, 0x38u);
      }
    }
  }
  return v8;
}

uint64_t DLFindWithSipMsgAndLock(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t Handle;

  v2 = 2148270081;
  if (a1 && a2)
  {
    Handle = FindHandle();
    *a1 = Handle;
    if (Handle == 0xFFFFFFFFLL)
      return 2148270102;
    else
      return 0;
  }
  return v2;
}

uint64_t MatchSipMsgAndLock(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  pthread_mutex_t *v10;
  uint64_t v11;
  NSObject *v12;
  int v13;
  uint64_t v14;
  NSObject *v15;
  const char *v16;
  int v17;
  uint64_t v18;
  NSObject *v19;
  const char *v20;
  int v21;
  const char *v22;
  uint64_t v23;
  NSObject *v24;
  const char *v25;
  const char *v26;
  uint64_t v27;
  NSObject *v28;
  const char *v29;
  int v30;
  int v31;
  uint64_t v32;
  __int16 v33;
  const char *v34;
  __int16 v35;
  int v36;
  __int16 v37;
  uint64_t v38;
  __int16 v39;
  const char *v40;
  __int16 v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  __int16 v45;
  uint64_t v46;
  __int16 v47;
  uint64_t v48;
  uint64_t v49;

  result = 0;
  v49 = *MEMORY[0x1E0C80C00];
  if (a1 && a2)
  {
    v5 = *(const char **)(a2 + 208);
    v6 = *(_QWORD *)(a2 + 312);
    v7 = *(_QWORD *)(a2 + 480);
    if (v5)
      v8 = v6 == 0;
    else
      v8 = 1;
    if (v8 || v7 == 0)
      return 0;
    v10 = (pthread_mutex_t *)(a1 + 560);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 560));
    if (*(_DWORD *)(a1 + 1004))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v11 = VRTraceErrorLogLevelToCSTR();
        v12 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v31 = 136315650;
          v32 = v11;
          v33 = 2080;
          v34 = "MatchSipMsgAndLock";
          v35 = 1024;
          v36 = 322;
          _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d MatchSipMsgAndLock: got a closing handle.", (uint8_t *)&v31, 0x1Cu);
        }
      }
      goto LABEL_45;
    }
    if (*(_DWORD *)a1 == 7 || *(_DWORD *)a1 == 1)
    {
      v13 = *(_DWORD *)(a2 + 4);
      if (v13 != 1)
      {
        if (v13 != 2)
          goto LABEL_45;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v14 = VRTraceErrorLogLevelToCSTR();
          v15 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v31 = 136316674;
            v32 = v14;
            v33 = 2080;
            v34 = "MatchSipMsgAndLock";
            v35 = 1024;
            v36 = 329;
            v37 = 2080;
            v38 = a1 + 236;
            v39 = 2080;
            v40 = v5;
            v41 = 2080;
            v42 = a1 + 382;
            v43 = 2080;
            v44 = v6 + 156;
            _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Dialog(CREATED) Match(STATUS) [%s]=[%s], [%s]=[%s]\n", (uint8_t *)&v31, 0x44u);
          }
        }
        if (strcmp((const char *)(a1 + 236), v5))
          goto LABEL_45;
        v16 = (const char *)(a1 + 382);
        goto LABEL_38;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v23 = VRTraceErrorLogLevelToCSTR();
        v24 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v31 = 136316674;
          v32 = v23;
          v33 = 2080;
          v34 = "MatchSipMsgAndLock";
          v35 = 1024;
          v36 = 339;
          v37 = 2080;
          v38 = a1 + 236;
          v39 = 2080;
          v40 = v5;
          v41 = 2080;
          v42 = a1 + 446;
          v43 = 2080;
          v44 = v6 + 156;
          _os_log_impl(&dword_1D8A54000, v24, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Dialog(CREATED) Match(REQUEST) [%s]=[%s], [%s]=[%s]\n", (uint8_t *)&v31, 0x44u);
        }
      }
      v25 = (const char *)(a1 + 236);
      v26 = v5;
    }
    else
    {
      v17 = *(_DWORD *)(a2 + 4);
      if (v17 != 1)
      {
        if (v17 != 2)
          goto LABEL_45;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v18 = VRTraceErrorLogLevelToCSTR();
          v19 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v31 = 136317186;
            v32 = v18;
            v33 = 2080;
            v34 = "MatchSipMsgAndLock";
            v35 = 1024;
            v36 = 352;
            v37 = 2080;
            v38 = a1 + 236;
            v39 = 2080;
            v40 = v5;
            v41 = 2080;
            v42 = a1 + 382;
            v43 = 2080;
            v44 = v6 + 156;
            v45 = 2080;
            v46 = a1 + 446;
            v47 = 2080;
            v48 = v7 + 156;
            _os_log_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Dialog Match(STATUS): [%s]=[%s], [%s]=[%s], [%s]=[%s]\n", (uint8_t *)&v31, 0x58u);
          }
        }
        if (strcmp((const char *)(a1 + 236), v5) || strcmp((const char *)(a1 + 382), (const char *)(v6 + 156)))
          goto LABEL_45;
        v21 = *(unsigned __int8 *)(v7 + 156);
        v20 = (const char *)(v7 + 156);
        if (!v21)
          return 1;
        v16 = (const char *)(a1 + 446);
        v22 = v20;
        goto LABEL_39;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v27 = VRTraceErrorLogLevelToCSTR();
        v28 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v31 = 136317186;
          v32 = v27;
          v33 = 2080;
          v34 = "MatchSipMsgAndLock";
          v35 = 1024;
          v36 = 365;
          v37 = 2080;
          v38 = a1 + 236;
          v39 = 2080;
          v40 = v5;
          v41 = 2080;
          v42 = a1 + 382;
          v43 = 2080;
          v44 = v7 + 156;
          v45 = 2080;
          v46 = a1 + 446;
          v47 = 2080;
          v48 = v6 + 156;
          _os_log_impl(&dword_1D8A54000, v28, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Dialog Match(REQUEST): [%s]=[%s], [%s]=[%s], [%s]=[%s]\n", (uint8_t *)&v31, 0x58u);
        }
      }
      if (strcmp((const char *)(a1 + 236), v5))
        goto LABEL_45;
      v30 = *(unsigned __int8 *)(v7 + 156);
      v29 = (const char *)(v7 + 156);
      if (!v30)
        goto LABEL_37;
      v25 = (const char *)(a1 + 382);
      v26 = v29;
    }
    if (strcmp(v25, v26))
      goto LABEL_45;
LABEL_37:
    v16 = (const char *)(a1 + 446);
LABEL_38:
    v22 = (const char *)(v6 + 156);
LABEL_39:
    if (!strcmp(v16, v22))
      return 1;
LABEL_45:
    pthread_mutex_unlock(v10);
    return 0;
  }
  return result;
}

uint64_t DLFindWithCallIDAndLock(uint64_t *a1)
{
  uint64_t v1;
  uint64_t Handle;

  v1 = 2148270081;
  if (a1)
  {
    Handle = FindHandle();
    *a1 = Handle;
    if (Handle == 0xFFFFFFFFLL)
      return 2148270102;
    else
      return 0;
  }
  return v1;
}

uint64_t MatchCallIDAndLock(uint64_t result, int a2)
{
  uint64_t v3;
  pthread_mutex_t *v4;

  if (result)
  {
    v3 = result;
    v4 = (pthread_mutex_t *)(result + 560);
    pthread_mutex_lock((pthread_mutex_t *)(result + 560));
    if (*(_DWORD *)(v3 + 1004) || *(_DWORD *)(v3 + 4) != a2)
    {
      pthread_mutex_unlock(v4);
      return 0;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t DLFindActiveDialogs(_DWORD *a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = 2148270081;
  if (a1 && a2)
  {
    *a1 = 0;
    *a2 = 0;
    FindHandle();
    return 0;
  }
  return v2;
}

uint64_t FindActive(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  void *v5;
  uint64_t v6;
  int *v7;
  uint64_t v8;

  if (a1[1] != *(_DWORD *)(a2 + 16) && (*a1 & 0xFFFFFFFE) == 2)
  {
    v5 = malloc_type_realloc(**(void ***)(a2 + 24), 8 * **(int **)(a2 + 8) + 8, 0x2004093837F09uLL);
    if (v5)
    {
      **(_QWORD **)(a2 + 24) = v5;
      v6 = **(_QWORD **)(a2 + 24);
      v7 = *(int **)(a2 + 8);
      v8 = *v7;
      *v7 = v8 + 1;
      *(_QWORD *)(v6 + 8 * v8) = a3;
    }
  }
  return 0;
}

uint64_t DLCountActiveDialogs(_DWORD *a1)
{
  if (!a1)
    return 2148270081;
  *a1 = 0;
  FindHandle();
  return 0;
}

uint64_t CountActive(_DWORD *a1, _DWORD *a2)
{
  if ((*a1 & 0xFFFFFFFE) == 2)
    ++*a2;
  return 0;
}

uint64_t DLUnlock()
{
  uint64_t v0;

  v0 = CheckInHandleDebug();
  if (!v0)
    return 2148270082;
  pthread_mutex_unlock((pthread_mutex_t *)(v0 + 560));
  CheckOutHandleDebug();
  return 0;
}

uint64_t DLSetConfIndex(uint64_t a1, int a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2148270082;
  *(_DWORD *)(v3 + 8) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t DLGetData(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2148270082;
  v4 = v3;
  *(_DWORD *)a2 = *(_DWORD *)(v3 + 12);
  *(_QWORD *)(a2 + 4) = *(_QWORD *)(v3 + 4);
  *(_QWORD *)(a2 + 16) = *(_QWORD *)(v3 + 16);
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(v3 + 32);
  v5 = *(_OWORD *)(v3 + 36);
  v6 = *(_OWORD *)(v3 + 52);
  *(_QWORD *)(a2 + 60) = *(_QWORD *)(v3 + 68);
  *(_OWORD *)(a2 + 44) = v6;
  *(_OWORD *)(a2 + 28) = v5;
  v7 = *(_OWORD *)(v3 + 76);
  v8 = *(_OWORD *)(v3 + 92);
  *(_QWORD *)(a2 + 100) = *(_QWORD *)(v3 + 108);
  *(_OWORD *)(a2 + 84) = v8;
  *(_OWORD *)(a2 + 68) = v7;
  v9 = *(_OWORD *)(v3 + 116);
  v10 = *(_OWORD *)(v3 + 132);
  *(_QWORD *)(a2 + 140) = *(_QWORD *)(v3 + 148);
  *(_OWORD *)(a2 + 124) = v10;
  *(_OWORD *)(a2 + 108) = v9;
  v11 = *(_OWORD *)(v3 + 156);
  v12 = *(_OWORD *)(v3 + 172);
  *(_QWORD *)(a2 + 180) = *(_QWORD *)(v3 + 188);
  *(_OWORD *)(a2 + 164) = v12;
  *(_OWORD *)(a2 + 148) = v11;
  v13 = *(_OWORD *)(v3 + 196);
  v14 = *(_OWORD *)(v3 + 212);
  *(_QWORD *)(a2 + 220) = *(_QWORD *)(v3 + 228);
  *(_OWORD *)(a2 + 204) = v14;
  *(_OWORD *)(a2 + 188) = v13;
  strncpy((char *)(a2 + 228), (const char *)(v3 + 236), 0x3CuLL);
  strncpy((char *)(a2 + 288), (const char *)(v4 + 296), 0x2BuLL);
  strncpy((char *)(a2 + 331), (const char *)(v4 + 339), 0x2BuLL);
  strncpy((char *)(a2 + 374), (const char *)(v4 + 382), 0x40uLL);
  strncpy((char *)(a2 + 438), (const char *)(v4 + 446), 0x40uLL);
  strncpy((char *)(a2 + 502), (const char *)(v4 + 510), 4uLL);
  strncpy((char *)(a2 + 506), (const char *)(v4 + 514), 0x2BuLL);
  v15 = *(_OWORD *)(v4 + 624);
  v16 = *(_OWORD *)(v4 + 656);
  *(_OWORD *)(a2 + 568) = *(_OWORD *)(v4 + 640);
  *(_OWORD *)(a2 + 584) = v16;
  *(_OWORD *)(a2 + 552) = v15;
  v17 = *(_OWORD *)(v4 + 672);
  v18 = *(_OWORD *)(v4 + 688);
  v19 = *(_OWORD *)(v4 + 720);
  *(_OWORD *)(a2 + 632) = *(_OWORD *)(v4 + 704);
  *(_OWORD *)(a2 + 648) = v19;
  *(_OWORD *)(a2 + 600) = v17;
  *(_OWORD *)(a2 + 616) = v18;
  v20 = *(_OWORD *)(v4 + 736);
  v21 = *(_OWORD *)(v4 + 768);
  *(_OWORD *)(a2 + 680) = *(_OWORD *)(v4 + 752);
  *(_OWORD *)(a2 + 696) = v21;
  *(_OWORD *)(a2 + 664) = v20;
  v22 = *(_OWORD *)(v4 + 784);
  v23 = *(_OWORD *)(v4 + 800);
  v24 = *(_OWORD *)(v4 + 832);
  *(_OWORD *)(a2 + 744) = *(_OWORD *)(v4 + 816);
  *(_OWORD *)(a2 + 760) = v24;
  *(_OWORD *)(a2 + 712) = v22;
  *(_OWORD *)(a2 + 728) = v23;
  v25 = *(_OWORD *)(v4 + 848);
  v26 = *(_OWORD *)(v4 + 880);
  *(_OWORD *)(a2 + 792) = *(_OWORD *)(v4 + 864);
  *(_OWORD *)(a2 + 808) = v26;
  *(_OWORD *)(a2 + 776) = v25;
  v27 = *(_OWORD *)(v4 + 896);
  v28 = *(_OWORD *)(v4 + 912);
  v29 = *(_OWORD *)(v4 + 944);
  *(_OWORD *)(a2 + 856) = *(_OWORD *)(v4 + 928);
  *(_OWORD *)(a2 + 872) = v29;
  *(_OWORD *)(a2 + 824) = v27;
  *(_OWORD *)(a2 + 840) = v28;
  *(_DWORD *)(a2 + 888) = *(_DWORD *)(v4 + 960);
  *(_DWORD *)(a2 + 892) = *(_DWORD *)(v4 + 984);
  *(_QWORD *)(a2 + 896) = *(_QWORD *)(v4 + 992);
  CheckOutHandleDebug();
  return 0;
}

uint64_t DLSetState(uint64_t a1, int a2)
{
  _DWORD *v3;

  v3 = (_DWORD *)CheckInHandleDebug();
  if (!v3)
    return 2148270082;
  *v3 = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t DLGetState(uint64_t a1, _DWORD *a2)
{
  uint64_t v2;
  _DWORD *v4;

  v2 = 2148270081;
  if (a2)
  {
    v4 = (_DWORD *)CheckInHandleDebug();
    if (v4)
    {
      *a2 = *v4;
      CheckOutHandleDebug();
      return 0;
    }
    else
    {
      return 2148270082;
    }
  }
  return v2;
}

uint64_t DLGetCallID(uint64_t a1, _DWORD *a2)
{
  uint64_t v2;
  uint64_t v4;

  v2 = 2148270081;
  if (a2)
  {
    v4 = CheckInHandleDebug();
    if (v4)
    {
      *a2 = *(_DWORD *)(v4 + 4);
      CheckOutHandleDebug();
      return 0;
    }
    else
    {
      return 2148270082;
    }
  }
  return v2;
}

uint64_t DLSetAck(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;

  v2 = 2148270081;
  if (a2)
  {
    v4 = CheckInHandleDebug();
    if (v4)
    {
      *(_QWORD *)(v4 + 976) = a2;
      CheckOutHandleDebug();
      return 0;
    }
    else
    {
      return 2148270082;
    }
  }
  return v2;
}

uint64_t DLGetAck(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v4;

  v2 = 2148270081;
  if (a2)
  {
    v4 = CheckInHandleDebug();
    if (v4)
    {
      *a2 = *(_QWORD *)(v4 + 976);
      CheckOutHandleDebug();
      return 0;
    }
    else
    {
      return 2148270082;
    }
  }
  return v2;
}

uint64_t DLPutMsg(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v6;

  v3 = 2148270081;
  if (a2)
  {
    v6 = CheckInHandleDebug();
    if (v6)
    {
      v3 = MQPut(*(_QWORD *)(v6 + 968), a2, a3);
      CheckOutHandleDebug();
    }
    else
    {
      return 2148270082;
    }
  }
  return v3;
}

uint64_t DLGetMsg(uint64_t a1, _QWORD *a2, unint64_t a3, int a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;

  v6 = 2148270081;
  if (!a2)
    return v6;
  v12 = CheckInHandleDebug();
  if (!v12)
    return 2148270082;
  if (a5)
  {
    v13 = *(uint64_t **)(a5 + 272);
    if (v13)
      a6 = *v13;
  }
  v14 = MQGet(*(_QWORD *)(v12 + 968), a2, a3, a4, a6);
  CheckOutHandleDebug();
  return v14;
}

uint64_t DLIncreaseLocalSeq(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  pthread_mutex_t *v5;
  uint64_t v6;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2148270082;
  v4 = v3;
  v5 = (pthread_mutex_t *)(v3 + 560);
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 560));
  v6 = *(_QWORD *)(v4 + 16) + 1;
  *(_QWORD *)(v4 + 16) = v6;
  *a2 = v6;
  pthread_mutex_unlock(v5);
  CheckOutHandleDebug();
  return 0;
}

uint64_t DLSetMediaType(uint64_t a1, unsigned int a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2148270082;
  *(_QWORD *)(v3 + 992) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t DLSetDoingKeyExchange(uint64_t a1, int a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2148270082;
  *(_DWORD *)(v3 + 1000) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t DLGetDoingKeyExchange(uint64_t a1, _DWORD *a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2148270082;
  *a2 = *(_DWORD *)(v3 + 1000);
  CheckOutHandleDebug();
  return 0;
}

uint64_t DLGetConfIndex(uint64_t a1, _DWORD *a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2148270082;
  *a2 = *(_DWORD *)(v3 + 8);
  CheckOutHandleDebug();
  return 0;
}

uint64_t DLGetSIPPing(uint64_t a1, _DWORD *a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2148270082;
  *a2 = *(_DWORD *)(v3 + 1008);
  CheckOutHandleDebug();
  return 0;
}

char *OUTLINED_FUNCTION_8_11@<X0>(int a1@<W1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  *(_QWORD *)(v2 - 24) = a2;
  return FourccToCStr(a1);
}

uint64_t VCCaptionsTranscriptionBlobReadFrom(_BYTE *a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  int v15;
  char v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char v22;
  uint64_t result;
  char v24;
  unsigned int v25;
  uint64_t v26;
  unint64_t v27;
  char v28;
  char v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  char v34;
  char v35;
  unsigned int v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  char v40;
  VCCaptionsSegmentBlob *v41;
  uint64_t v42;
  BOOL v43;
  uint64_t v44;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) >= *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
    return *(_BYTE *)(a2 + *v5) == 0;
  v7 = (int *)MEMORY[0x1E0D82BB8];
  while (2)
  {
    if (*(_BYTE *)(a2 + *v5))
      return *(_BYTE *)(a2 + *v5) == 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v11 = *v3;
      v12 = *(_QWORD *)(a2 + v11);
      if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
        break;
      v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
      *(_QWORD *)(a2 + v11) = v12 + 1;
      v10 |= (unint64_t)(v13 & 0x7F) << v8;
      if ((v13 & 0x80) == 0)
        goto LABEL_12;
      v8 += 7;
      v14 = v9++ >= 9;
      if (v14)
      {
        v10 = 0;
        v15 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
    v15 = *(unsigned __int8 *)(a2 + *v5);
    if (*(_BYTE *)(a2 + *v5))
      v10 = 0;
LABEL_14:
    if (v15 || (v10 & 7) == 4)
      return *(_BYTE *)(a2 + *v5) == 0;
    switch((v10 >> 3))
    {
      case 1u:
        v17 = 0;
        v18 = 0;
        v19 = 0;
        while (1)
        {
          v20 = *v3;
          v21 = *(_QWORD *)(a2 + v20);
          if (v21 == -1 || v21 >= *(_QWORD *)(a2 + *v4))
            break;
          v22 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v21);
          *(_QWORD *)(a2 + v20) = v21 + 1;
          v19 |= (unint64_t)(v22 & 0x7F) << v17;
          if ((v22 & 0x80) == 0)
            goto LABEL_53;
          v17 += 7;
          v14 = v18++ >= 9;
          if (v14)
          {
            LODWORD(v19) = 0;
            goto LABEL_55;
          }
        }
        *(_BYTE *)(a2 + *v5) = 1;
LABEL_53:
        if (*(_BYTE *)(a2 + *v5))
          LODWORD(v19) = 0;
LABEL_55:
        v42 = 20;
        goto LABEL_60;
      case 2u:
        v24 = 0;
        v25 = 0;
        v19 = 0;
        while (2)
        {
          v26 = *v3;
          v27 = *(_QWORD *)(a2 + v26);
          if (v27 == -1 || v27 >= *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v28 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v27);
            *(_QWORD *)(a2 + v26) = v27 + 1;
            v19 |= (unint64_t)(v28 & 0x7F) << v24;
            if (v28 < 0)
            {
              v24 += 7;
              v14 = v25++ >= 9;
              if (v14)
              {
                LODWORD(v19) = 0;
                goto LABEL_59;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          LODWORD(v19) = 0;
LABEL_59:
        v42 = 16;
LABEL_60:
        *(_DWORD *)&a1[v42] = v19;
        goto LABEL_70;
      case 3u:
        v29 = 0;
        v30 = 0;
        v31 = 0;
        a1[28] |= 2u;
        while (2)
        {
          v32 = *v3;
          v33 = *(_QWORD *)(a2 + v32);
          if (v33 == -1 || v33 >= *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v34 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v33);
            *(_QWORD *)(a2 + v32) = v33 + 1;
            v31 |= (unint64_t)(v34 & 0x7F) << v29;
            if (v34 < 0)
            {
              v29 += 7;
              v14 = v30++ >= 9;
              if (v14)
              {
                v31 = 0;
                goto LABEL_64;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v31 = 0;
LABEL_64:
        v43 = v31 != 0;
        v44 = 25;
        goto LABEL_69;
      case 4u:
        v35 = 0;
        v36 = 0;
        v37 = 0;
        a1[28] |= 1u;
        while (2)
        {
          v38 = *v3;
          v39 = *(_QWORD *)(a2 + v38);
          if (v39 == -1 || v39 >= *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v40 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v39);
            *(_QWORD *)(a2 + v38) = v39 + 1;
            v37 |= (unint64_t)(v40 & 0x7F) << v35;
            if (v40 < 0)
            {
              v35 += 7;
              v14 = v36++ >= 9;
              if (v14)
              {
                v37 = 0;
                goto LABEL_68;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v37 = 0;
LABEL_68:
        v43 = v37 != 0;
        v44 = 24;
LABEL_69:
        a1[v44] = v43;
        goto LABEL_70;
      case 5u:
        v41 = objc_alloc_init(VCCaptionsSegmentBlob);
        objc_msgSend(a1, "addSegments:", v41);

        if (PBReaderPlaceMark() && (VCCaptionsSegmentBlobReadFrom((uint64_t)v41, a2) & 1) != 0)
        {
          PBReaderRecallMark();
LABEL_70:
          if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
            return *(_BYTE *)(a2 + *v5) == 0;
          continue;
        }
        return 0;
      default:
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
        goto LABEL_70;
    }
  }
}

CFTypeRef _VCConnectionManagerLegacy_CopyConnection(uint64_t a1, uint64_t a2, char *a3)
{
  const void *v6;
  char v7;
  CFTypeRef v8;

  pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 96));
  v6 = *(const void **)(a1 + 296);
  if (!v6)
    goto LABEL_8;
  if ((VCConnection_MatchesSourceDestinationInfo(*(_QWORD *)(a1 + 296), a2) & 1) == 0)
  {
    v6 = *(const void **)(a1 + 304);
    if (v6 && VCConnection_MatchesSourceDestinationInfo(*(_QWORD *)(a1 + 304), a2))
    {
      v7 = 0;
      goto LABEL_7;
    }
LABEL_8:
    v8 = 0;
    goto LABEL_9;
  }
  v7 = 1;
LABEL_7:
  *a3 = v7;
  v8 = CFRetain(v6);
  VCConnection_SourceDestinationInfo((uint64_t)v6, a2);
LABEL_9:
  pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 96));
  return v8;
}

void _VCConnectionManagerLegacy_IsSourceOnCellularIPv6(uint64_t a1, uint64_t a2, _BYTE *a3, _BYTE *a4)
{
  *a3 = 0;
  *a4 = 0;
  if (*(_DWORD *)a2 == 1 && (*(_BYTE *)(a2 + 8) & 4) != 0)
  {
    *a3 = 1;
    if ((*(_BYTE *)(a2 + 8) & 4) != 0)
      *a4 = 1;
  }
}

CFTypeRef _VCConnectionManagerLegacy_CopyPrimaryConnection(uint64_t a1)
{
  CFTypeRef result;

  result = *(CFTypeRef *)(a1 + 296);
  if (result)
    return CFRetain(result);
  return result;
}

void _VCConnectionManagerLegacy_SetPrimaryConnection(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v2;

  v2 = *(CFTypeRef *)(a1 + 296);
  if (v2 != cf)
  {
    *(_QWORD *)(a1 + 296) = cf;
    if (cf)
      CFRetain(cf);
    if (v2)
      CFRelease(v2);
  }
}

uint64_t MQCreateHandle(uint64_t *a1)
{
  char *v2;
  char *v3;
  pthread_mutex_t *v4;
  uint64_t Handle;
  uint64_t v6;

  v2 = (char *)malloc_type_calloc(1uLL, 0x118uLL, 0x102004088A06470uLL);
  if (v2)
  {
    v3 = v2;
    *(_QWORD *)v2 = 0;
    v4 = (pthread_mutex_t *)(v2 + 8);
    pthread_mutex_init((pthread_mutex_t *)(v2 + 8), 0);
    pthread_cond_init((pthread_cond_t *)(v3 + 72), 0);
    Handle = CreateHandle();
    v6 = 0;
    *a1 = Handle;
    if (Handle == 0xFFFFFFFFLL)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          MQCreateHandle_cold_2();
      }
      pthread_mutex_destroy(v4);
      pthread_cond_destroy((pthread_cond_t *)(v3 + 72));
      free(v3);
      return 2148204549;
    }
  }
  else
  {
    v6 = 2148204547;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        MQCreateHandle_cold_1();
    }
  }
  return v6;
}

uint64_t MQCloseHandle()
{
  uint64_t v0;
  uint64_t v1;
  pthread_mutex_t *v2;
  uint64_t i;
  _QWORD *v4;

  v0 = CheckInHandleDebug();
  if (!v0)
    return 2148204546;
  v1 = v0;
  v2 = (pthread_mutex_t *)(v0 + 8);
  pthread_mutex_lock((pthread_mutex_t *)(v0 + 8));
  *(_DWORD *)(v1 + 4) = -1;
  pthread_cond_broadcast((pthread_cond_t *)(v1 + 72));
  pthread_mutex_unlock(v2);
  CheckOutHandleDebug();
  pthread_cond_destroy((pthread_cond_t *)(v1 + 72));
  pthread_mutex_destroy(v2);
  for (i = 120; i != 200; i += 8)
  {
    v4 = *(_QWORD **)(v1 + i);
    if (v4)
      FreeSipMsg(v4);
  }
  free((void *)v1);
  return 0;
}

uint64_t MQPut(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  pthread_mutex_t *v8;
  double v9;
  int v10;
  int v11;
  double v12;
  int i;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  char *v17;
  char *v18;
  uint64_t v19;
  uint64_t v21;
  NSObject *v22;
  int v23;
  uint64_t v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  int v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v5 = 2148204546;
  v6 = CheckInHandleDebug();
  if (!v6)
    return v5;
  v7 = v6;
  v8 = (pthread_mutex_t *)(v6 + 8);
  pthread_mutex_lock((pthread_mutex_t *)(v6 + 8));
  if ((*(_DWORD *)(v7 + 4) & 0x80000000) != 0)
  {
    pthread_mutex_unlock(v8);
    CheckOutHandleDebug();
    return 2148204562;
  }
  v9 = micro();
  v10 = *(_DWORD *)v7;
  v11 = *(_DWORD *)(v7 + 4);
  if (v11 < 1)
    goto LABEL_14;
  v12 = v9;
  for (i = 0; i != v11; ++i)
  {
    while (v12 - *(double *)(v7 + 8 * ((v10 + i) % 10) + 200) > 10.0)
    {
      MQDeleteAt((_DWORD *)v7, i, 1);
      v10 = *(_DWORD *)v7;
      v11 = *(_DWORD *)(v7 + 4);
      if (!v11)
        goto LABEL_14;
    }
  }
  if (v11 < 10)
  {
LABEL_14:
    v16 = v7 + 8 * ((v10 + v11) % 10);
    *(_QWORD *)(v16 + 120) = a2;
    *(double *)(v16 + 200) = micro();
    if (a3)
    {
      v17 = *(char **)(a2 + 992);
      if (v17)
        goto LABEL_18;
      v18 = (char *)malloc_type_calloc(0xAuLL, 8uLL, 0x2004093837F09uLL);
      if (v18)
      {
        v17 = v18;
        *(_QWORD *)(a2 + 992) = v18;
LABEL_18:
        v19 = 0;
        while (*(_QWORD *)&v17[v19])
        {
          v19 += 8;
          if (v19 == 80)
            goto LABEL_24;
        }
        *(_QWORD *)&v17[v19] = pthread_self();
        goto LABEL_24;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v21 = VRTraceErrorLogLevelToCSTR();
        v22 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v23 = 136315650;
          v24 = v21;
          v25 = 2080;
          v26 = "MQPut";
          v27 = 1024;
          v28 = 191;
          _os_log_impl(&dword_1D8A54000, v22, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d MQIgnore: out of memory", (uint8_t *)&v23, 0x1Cu);
        }
      }
    }
LABEL_24:
    ++*(_DWORD *)(v7 + 4);
    pthread_cond_broadcast((pthread_cond_t *)(v7 + 72));
    pthread_mutex_unlock(v8);
    CheckOutHandleDebug();
    return 0;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v14 = VRTraceErrorLogLevelToCSTR();
    v15 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v23 = 136315650;
      v24 = v14;
      v25 = 2080;
      v26 = "MQPut";
      v27 = 1024;
      v28 = 173;
      _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Message Queue is full", (uint8_t *)&v23, 0x1Cu);
    }
  }
  pthread_mutex_unlock(v8);
  CheckOutHandleDebug();
  return 2148204573;
}

uint64_t MQGet(uint64_t a1, _QWORD *a2, unint64_t a3, int a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v10;
  int *v11;
  double v12;
  double v13;
  int v14;
  double v15;
  int i;
  int *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  pthread_t v22;
  uint64_t v23;
  uint64_t *v24;
  int v25;
  uint64_t v26;
  BOOL v27;
  int v28;
  BOOL v29;
  int v30;
  double v31;
  uint64_t v32;
  NSObject *v33;
  uint64_t v34;
  NSObject *v35;
  uint64_t v36;
  int v37;
  pthread_cond_t *v39;
  unint64_t v40;
  pthread_mutex_t *v41;
  timespec v42;
  uint8_t buf[4];
  uint64_t v44;
  __int16 v45;
  const char *v46;
  __int16 v47;
  int v48;
  __int16 v49;
  int v50;
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  v5 = 2148204545;
  if (a2)
  {
    *a2 = 0;
    v10 = CheckInHandleDebug();
    if (v10)
    {
      v11 = (int *)v10;
      v41 = (pthread_mutex_t *)(v10 + 8);
      pthread_mutex_lock((pthread_mutex_t *)(v10 + 8));
      v12 = micro();
      v42.tv_sec = 0xAAAAAAAAAAAAAAAALL;
      v42.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
      v13 = micro();
      v14 = v11[1];
      if ((v14 & 0x80000000) == 0)
      {
        v15 = v13;
        v39 = (pthread_cond_t *)(v11 + 18);
        do
        {
          v40 = a3;
          if (v14)
          {
            for (i = 0; i != v11[1]; ++i)
            {
              v17 = &v11[2 * ((*v11 + i) % 10)];
              v20 = *((_QWORD *)v17 + 15);
              v19 = v17 + 30;
              v18 = v20;
              v21 = *(_QWORD *)(v20 + 992);
              v22 = pthread_self();
              if (v21)
              {
                v23 = 0;
                while (v22 != *(pthread_t *)(v21 + v23))
                {
                  v23 += 8;
                  if (v23 == 80)
                    goto LABEL_11;
                }
              }
              else
              {
LABEL_11:
                if (*(_DWORD *)v18 == 1
                  || (v24 = *(uint64_t **)(v18 + 272)) != 0
                  && ((v25 = *((_DWORD *)v24 + 2), a4 == 1) && v25 == 2
                   || ((v26 = *v24, a5 != -1) ? (v27 = v26 == a5) : (v27 = 1),
                       !v27 ? (v28 = 0) : (v28 = 1),
                       v25 == a4 ? (v29 = v28 == 0) : (v29 = 1),
                       !v29)))
                {
                  *a2 = *v19;
                  if (i)
                  {
                    MQDeleteAt(v11, i, 0);
                    v5 = 0;
                  }
                  else
                  {
                    v5 = 0;
                    v36 = *v11;
                    v37 = ((int)v36 + 1) % 10;
                    *(_QWORD *)&v11[2 * v36 + 30] = 0;
                    LODWORD(v36) = v11[1] - 1;
                    *v11 = v37;
                    v11[1] = v36;
                  }
                  goto LABEL_47;
                }
              }
            }
          }
          if (v40 == 0xFFFFFFFF)
          {
            v30 = pthread_cond_wait(v39, v41);
            a3 = 0xFFFFFFFFLL;
          }
          else
          {
            v31 = (v15 - v12) * 1000.0;
            if (v40 >= (unint64_t)v31)
              a3 = v40 - (unint64_t)v31;
            else
              a3 = 0;
            v42.tv_sec = a3 / 0x3E8;
            v42.tv_nsec = 1000000 * (a3 % 0x3E8);
            v30 = pthread_cond_timedwait_relative_np(v39, v41, &v42);
            v12 = v15;
          }
          if (v30 == 60)
          {
            v5 = 2148204567;
            goto LABEL_47;
          }
          v42.tv_sec = 0xAAAAAAAAAAAAAAAALL;
          v42.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
          v15 = micro();
          v14 = v11[1];
        }
        while ((v14 & 0x80000000) == 0);
      }
      if ((int)VRTraceGetErrorLogLevelForModule() < 5)
      {
        v5 = 2148204574;
      }
      else
      {
        v32 = VRTraceErrorLogLevelToCSTR();
        v33 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315906;
          v44 = v32;
          v45 = 2080;
          v46 = "MQGet";
          v47 = 1024;
          v48 = 291;
          v49 = 1024;
          v50 = 291;
          _os_log_impl(&dword_1D8A54000, v33, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/MsgQue.c:%d: Message Queue Closed during MQGet", buf, 0x22u);
        }
        v5 = 2148204574;
      }
LABEL_47:
      pthread_mutex_unlock(v41);
      CheckOutHandleDebug();
    }
    else
    {
      return 2148204546;
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v34 = VRTraceErrorLogLevelToCSTR();
    v35 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      v44 = v34;
      v45 = 2080;
      v46 = "MQGet";
      v47 = 1024;
      v48 = 271;
      v49 = 1024;
      v50 = 271;
      _os_log_impl(&dword_1D8A54000, v35, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/MsgQue.c:%d: ppSipMsg is NULL", buf, 0x22u);
    }
  }
  return v5;
}

void MQDeleteAt(_DWORD *a1, int a2, int a3)
{
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  NSObject *v12;
  int v13;
  int v14;
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  _DWORD *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (a2 < 0 || (v5 = a1[1], v5 <= a2))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v11 = VRTraceErrorLogLevelToCSTR();
      v12 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v13 = a1[1];
        v14 = 136316418;
        v15 = v11;
        v16 = 2080;
        v17 = "MQDeleteAt";
        v18 = 1024;
        v19 = 94;
        v20 = 2048;
        v21 = a1;
        v22 = 1024;
        v23 = v13;
        v24 = 1024;
        v25 = a2;
        _os_log_error_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_ERROR, "SIP [%s] %s:%d Trying to remove an invalid element from a message queue. pMsgQue=%p iAvail=%d nth=%d", (uint8_t *)&v14, 0x32u);
      }
    }
  }
  else
  {
    if (a3)
    {
      FreeSipMsg(*(_QWORD **)&a1[2 * ((*a1 + a2) % 10) + 30]);
      v5 = a1[1];
    }
    v6 = *a1;
    if (a2 + 1 < v5)
    {
      v7 = v6 + a2;
      v8 = ~a2 + v5;
      do
      {
        v9 = v7 % 10;
        *(_QWORD *)&a1[2 * v9 + 30] = *(_QWORD *)&a1[2 * (++v7 % 10) + 30];
        *(_QWORD *)&a1[2 * v9 + 50] = *(_QWORD *)&a1[2 * (v7 % 10) + 50];
        --v8;
      }
      while (v8);
    }
    v10 = v5 - 1;
    a1[1] = v10;
    *(_QWORD *)&a1[2 * ((v6 + v10) % 10) + 30] = 0;
  }
}

void _VCRateControlAlogirthmLowLatencyNOWRD_Configure(uint64_t a1, const void *a2, int a3)
{
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  uint8_t buf[4];
  uint64_t v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  __int16 v28;
  int v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  memcpy((void *)(a1 + 40), a2, 0x3D0uLL);
  _VCRateControlAlgorithmLowLatencyNOWRD_SetRateChangeCounter(a1);
  *(_BYTE *)(a1 + 1121) = 0;
  *(_QWORD *)(a1 + 4960) = 0;
  *(_QWORD *)(a1 + 5008) = *(_QWORD *)(a1 + 728);
  VCRateControlAlgorithmBasePriv_ResetLossEventBuffer(a1);
  if (a3)
  {
    *(_DWORD *)(a1 + 1040) = 1;
    *(_DWORD *)(a1 + 1052) = *(_DWORD *)(a1 + 56);
  }
  v5 = *(_DWORD *)(a1 + 1052);
  if (v5 >= *(_DWORD *)(a1 + 60))
    v5 = *(_DWORD *)(a1 + 60);
  if (v5 <= *(_DWORD *)(a1 + 64))
    v5 = *(_DWORD *)(a1 + 64);
  *(_DWORD *)(a1 + 1052) = v5;
  *(_DWORD *)(a1 + 1072) = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * *(int *)(a1 + 1052));
  VCRateControlMediaController_SetMinTargetBitrate(*(_QWORD *)(a1 + 1016), *(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * *(int *)(a1 + 64)));
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v12 = VRTraceErrorLogLevelToCSTR();
    v13 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v14 = *(_DWORD *)(a1 + 1072);
      v15 = *(_QWORD *)(a1 + 48);
      v16 = *(_DWORD *)(v15 + 4 * *(int *)(a1 + 64));
      v17 = *(_DWORD *)(v15 + 4 * *(int *)(a1 + 60));
      *(_DWORD *)buf = 136316418;
      v19 = v12;
      v20 = 2080;
      v21 = "_VCRateControlAlogirthmLowLatencyNOWRD_Configure";
      v22 = 1024;
      v23 = 161;
      v24 = 1024;
      v25 = v14;
      v26 = 1024;
      v27 = v16;
      v28 = 1024;
      v29 = v17;
      _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Configuring VCRateControl algorithm with targetBitrate=%d, minBitrate=%d, maxBitrate=%d", buf, 0x2Eu);
    }
  }
  VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Configure with targetBitrate=%d, minBitrate=%d, maxBitrate=%d", v6, v7, v8, v9, v10, v11, *(_DWORD *)(a1 + 1072));
}

BOOL _VCRateControlAlogirthmLowLatencyNOWRD_DoRateControl(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10)
{
  double v11;
  unsigned int v12;
  uint64_t v13;
  double v14;
  int v15;
  int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  double v24;
  double v25;
  __int16 v26;
  int v27;
  __int16 v28;
  unint64_t v29;
  double v30;
  _BOOL8 result;
  double v32;
  double v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  unsigned int v43;
  double v44;
  double v45;
  BOOL v46;
  double v47;
  int v48;
  int v49;
  uint64_t v50;
  NSObject *v51;
  NSObject *v52;
  _BOOL4 v53;
  unsigned int v54;
  int v55;
  uint64_t v56;
  NSObject *v57;
  int v58;
  uint64_t v59;
  int v60;
  int v61;
  uint64_t v62;
  NSObject *v63;
  int v64;
  double v65;
  double v66;
  double v67;
  int v68;
  const char *v69;
  const char *v70;
  _BOOL4 IsVideoStopped;
  int v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  char v81;
  unsigned int v82;
  unsigned int v83;
  unsigned int v84;
  int v85;
  int v86;
  int v87;
  unsigned int v88;
  int v89;
  unsigned int v90;
  int v91;
  int v92;
  int v93;
  int v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  int v99;
  uint64_t v100;
  uint64_t v101;
  uint8_t buf[4];
  uint64_t v103;
  __int16 v104;
  const char *v105;
  __int16 v106;
  int v107;
  __int16 v108;
  uint64_t v109;
  __int16 v110;
  int v111;
  __int16 v112;
  uint64_t v113;
  __int16 v114;
  uint64_t v115;
  __int16 v116;
  uint64_t v117;
  __int16 v118;
  uint64_t v119;
  __int16 v120;
  int v121;
  __int16 v122;
  int v123;
  __int16 v124;
  double v125;
  __int16 v126;
  double v127;
  __int16 v128;
  int v129;
  __int16 v130;
  int v131;
  __int16 v132;
  unsigned int v133;
  __int16 v134;
  unsigned int v135;
  __int16 v136;
  int v137;
  __int16 v138;
  int v139;
  __int16 v140;
  int v141;
  __int16 v142;
  unsigned int v143;
  __int16 v144;
  int v145;
  __int16 v146;
  unsigned int v147;
  __int16 v148;
  unsigned int v149;
  __int16 v150;
  int v151;
  __int16 v152;
  const char *v153;
  __int16 v154;
  const char *v155;
  __int16 v156;
  int v157;
  uint64_t v158;

  v158 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)a2 != 11)
  {
    if (*(_DWORD *)a2 == 2)
    {
      v11 = *(double *)(a2 + 8);
      v12 = *(unsigned __int16 *)(a2 + 24);
      v13 = *(_QWORD *)(a2 + 80);
      *(_DWORD *)(a1 + 1168) = *(_DWORD *)(a2 + 32) / *(_DWORD *)(a1 + 5108);
      *(_WORD *)(a1 + 5186) = *(_DWORD *)(a2 + 68);
      *(_WORD *)(a1 + 5190) = *(_DWORD *)(a2 + 28);
      *(_QWORD *)(a1 + 5072) = *(_QWORD *)(a2 + 104);
      v14 = *(double *)(a2 + 88);
      *(double *)(a1 + 4992) = v14;
      *(_DWORD *)(a1 + 4984) = *(_DWORD *)(a2 + 48);
      *(_DWORD *)(a1 + 5272) = *(_DWORD *)(a2 + 40);
      v16 = *(_DWORD *)(a2 + 96);
      v15 = *(_DWORD *)(a2 + 100);
      if (v16)
      {
        if (!*(_DWORD *)(a1 + 5260))
        {
          *(_QWORD *)(a1 + 5224) = *(_QWORD *)(a1 + 1096);
          v14 = *(double *)(a1 + 1096) - *(double *)(a1 + 5232);
          a10 = 5.0;
          if (v14 > 5.0)
          {
            VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Re-enter Initial Rampup!", a3, a4, a5, a6, a7, a8, v81);
            VCRateControlAlgorithmBasePriv_StateChange(a1, 1);
          }
        }
      }
      *(_DWORD *)(a1 + 5260) = v16;
      if (*(_DWORD *)(a1 + 5260))
      {
        v14 = *(double *)(a1 + 1096);
        *(double *)(a1 + 5232) = v14;
      }
      *(_DWORD *)(a1 + 5264) = v15;
      LODWORD(v14) = *(_DWORD *)(a1 + 5264);
      LODWORD(a10) = *(_DWORD *)(a1 + 1072);
      *(_BYTE *)(a1 + 1121) = *(double *)(a1 + 288) * (double)*(unint64_t *)&a10 > (double)*(unint64_t *)&v14;
      if (!*(_BYTE *)(a1 + 1123))
      {
        result = 0;
        *(_BYTE *)(a1 + 1123) = 1;
        *(_WORD *)(a1 + 5188) = v12;
        return result;
      }
      v17 = *(unsigned __int16 *)(a1 + 5188);
      if (v12 != v17 && (unsigned __int16)(v12 - v17) < 0x7FFFu)
      {
        if (v17 > v12)
          ++*(_DWORD *)(a1 + 5196);
        *(_WORD *)(a1 + 5188) = v12;
        *(double *)(a1 + 1096) = VCRateControlAlgorithmBasePriv_GetDoubleTimeFromTimestamp(v12, 0x400u, *(_DWORD *)(a1 + 5196));
        *(_DWORD *)(a1 + 5192) = VCRateControlAlgorithmBasePriv_GetTimestampFromMicroTime(v11);
        *(_QWORD *)(a1 + 2856) = v13;
        VCRateControlAlgorithmBasePriv_CalculateCongestionMetrics(a1, *(double *)(a1 + 2856), *(double *)(a1 + 1096));
        v24 = *(double *)(a1 + 192);
        if (*(_BYTE *)(a1 + 415) && *(double *)(a1 + 4960) == 0.0)
        {
          v25 = *(double *)(a1 + 5072);
          if (*(double *)(a1 + 456) * v25 < v24)
            v24 = *(double *)(a1 + 456) * v25;
          if (*(double *)(a1 + 312) > v24)
            v24 = *(double *)(a1 + 312);
        }
        v26 = *(_WORD *)(a1 + 5186);
        v27 = *(unsigned __int16 *)(a1 + 5190);
        *(double *)(a1 + 5312) = v24;
        if (!*(_BYTE *)(a1 + 5308))
        {
          if (*(_QWORD *)(a1 + 1016))
          {
            if (*(_DWORD *)(a1 + 536) == 1)
              v28 = vcvtd_n_s64_f64(*(double *)(a1 + 5320), 0xAuLL);
            else
              v28 = 0;
            if (v27 && (unsigned __int16)(v26 - v28) <= 0x7FFEu)
            {
              *(_QWORD *)(a1 + 1160) = *(_QWORD *)(a1 + 1096);
              *(_DWORD *)(a1 + 5200) = 1;
              VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "[%u] VCRC rate stabilized (TxTS %u >= %u FB). Collecting VCRC samples...", v18, v19, v20, v21, v22, v23, *(_DWORD *)(a1 + 1084));
            }
          }
          else if (!*(_DWORD *)(a1 + 5200))
          {
            *(_QWORD *)(a1 + 1160) = *(_QWORD *)(a1 + 1096);
            *(_DWORD *)(a1 + 5200) = 1;
            VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "[%u] VCRC rate stabilized since no mediaController. Collecting VCRC samples...", v18, v19, v20, v21, v22, v23, *(_DWORD *)(a1 + 1084));
          }
          v54 = *(_DWORD *)(a1 + 5200);
          if (v54)
          {
            if (*(double *)(a1 + 1096) - *(double *)(a1 + 1160) >= *(double *)(a1 + 312)
              && v54 >= *(_DWORD *)(a1 + 348))
            {
              VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "[%u] Collected %d VCRC samples (TxTS %u)", v18, v19, v20, v21, v22, v23, *(_DWORD *)(a1 + 1084));
              *(_BYTE *)(a1 + 5308) = 1;
              *(_DWORD *)(a1 + 5200) = 0;
            }
            else
            {
              *(_DWORD *)(a1 + 5200) = v54 + 1;
            }
          }
        }
        if (*(_DWORD *)(a1 + 1040) != 1
          && *(_BYTE *)(a1 + 5256)
          && *(double *)(a1 + 1096) - *(double *)(a1 + 1104) > *(double *)(a1 + 192))
        {
          *(_BYTE *)(a1 + 5256) = 0;
        }
        if (*(_BYTE *)(a1 + 1112)
          && *(_BYTE *)(a1 + 5308)
          && *(double *)(a1 + 1096) - *(double *)(a1 + 1136) > *(double *)(a1 + 304))
        {
          *(_BYTE *)(a1 + 1112) = 0;
        }
        if (*(_BYTE *)(a1 + 410))
          VCRateControlAlgorithmBasePriv_CheckBandwidthOvershoot(a1, 1000 * *(_DWORD *)(a1 + 1168));
        else
          *(_DWORD *)(a1 + 1168) = 0;
        switch(*(_DWORD *)(a1 + 1040))
        {
          case 0:
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v56 = VRTraceErrorLogLevelToCSTR();
              v57 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315650;
                v103 = v56;
                v104 = 2080;
                v105 = "_VCRateControlAlogirthmLowLatencyNOWRD_DoRateControlWithVCRCStatistics";
                v106 = 1024;
                v107 = 251;
                _os_log_impl(&dword_1D8A54000, v57, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d VCRateControl is paused", buf, 0x1Cu);
              }
            }
            goto LABEL_126;
          case 1:
            if (_VCRateControlAlgorithmLowLatencyNOWRD_ShouldRampDown(a1))
              goto LABEL_118;
            if (_VCRateControlAlgorithmLowLatencyNOWRD_ShouldRampUp(a1))
            {
              *(_DWORD *)(a1 + 1052) = _VCRateControlAlgorithmLowLatencyNOWRD_RampUpTier((_DWORD *)a1);
              if (*(_DWORD *)(a1 + 1052) == *(_DWORD *)(a1 + 60))
                goto LABEL_120;
            }
            goto LABEL_126;
          case 2:
            if (_VCRateControlAlgorithmLowLatencyNOWRD_ShouldRampDown(a1))
            {
LABEL_118:
              v58 = _VCRateControlAlgorithmLowLatencyNOWRD_RampDownTier(a1);
              goto LABEL_119;
            }
            if (_VCRateControlAlgorithmLowLatencyNOWRD_ShouldRampUp(a1))
            {
              v58 = _VCRateControlAlgorithmLowLatencyNOWRD_RampUpTier((_DWORD *)a1);
LABEL_119:
              *(_DWORD *)(a1 + 1052) = v58;
LABEL_120:
              v59 = a1;
              v60 = 3;
              goto LABEL_125;
            }
LABEL_126:
            *(_DWORD *)(a1 + 1072) = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * *(int *)(a1 + 1052));
            if (*(_BYTE *)(a1 + 5128))
            {
              v61 = *(_DWORD *)(a1 + 1088);
              *(_DWORD *)(a1 + 1088) = v61 + 1;
              if ((v61 & 0xF) == 0 && (int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v62 = VRTraceErrorLogLevelToCSTR();
                v63 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                {
                  v100 = *(_QWORD *)(a1 + 1096);
                  v101 = v62;
                  v99 = *(unsigned __int16 *)(a1 + 5186);
                  v98 = *(_QWORD *)(a1 + 2856);
                  v97 = *(_QWORD *)(a1 + 2864);
                  v96 = *(_QWORD *)(a1 + 2872);
                  v95 = *(_QWORD *)(a1 + 2880);
                  if (*(_DWORD *)(a1 + 1044))
                    v64 = 88;
                  else
                    v64 = 79;
                  v94 = v64;
                  v93 = (int)(*(double *)(a1 + 5072) * 1000.0);
                  v65 = *(double *)(a1 + 4992);
                  v66 = v65 * 100.0;
                  LODWORD(v65) = *(_DWORD *)(a1 + 5272);
                  v67 = (double)*(unint64_t *)&v65;
                  v92 = *(_DWORD *)(a1 + 1168);
                  v91 = *(_DWORD *)(a1 + 4984);
                  v90 = *(_DWORD *)(a1 + 5260) / 0x3E8u;
                  v88 = *(_DWORD *)(a1 + 1072) / 0x3E8u;
                  v89 = (unsigned __int16)*(_DWORD *)(a1 + 1044);
                  v87 = *(unsigned __int16 *)(a1 + 1048);
                  v86 = *(_DWORD *)(a1 + 1084);
                  v85 = *(_DWORD *)(a1 + 5300);
                  v84 = (*(double *)(a1 + 5288) * 1000.0);
                  v83 = *(_DWORD *)(a1 + 5280) / 0x3E8u;
                  v82 = VCRateControlMediaController_AudioSendingBitrate(*(_QWORD *)(a1 + 1016)) / 0x3E8;
                  v68 = VCRateControlMediaController_AudioFractionTier(*(_QWORD *)(a1 + 1016));
                  if (*(_BYTE *)(a1 + 5308))
                    v69 = "S";
                  else
                    v69 = "U";
                  if (*(_BYTE *)(a1 + 1121))
                  {
                    v70 = "<";
                  }
                  else
                  {
                    IsVideoStopped = VCRateControlMediaController_IsVideoStopped(*(_BYTE **)(a1 + 1016));
                    v70 = "-";
                    if (IsVideoStopped)
                      v70 = "_";
                  }
                  v72 = *(_DWORD *)(a1 + 1040);
                  *(_DWORD *)buf = 136322050;
                  v103 = v101;
                  v104 = 2080;
                  v105 = "_VCRateControlAlgorithmLowLatencyNOWRD_PrintRateControlInfoToLogDump";
                  v106 = 1024;
                  v107 = 745;
                  v108 = 2048;
                  v109 = v100;
                  v110 = 1024;
                  v111 = v99;
                  v112 = 2048;
                  v113 = v98;
                  v114 = 2048;
                  v115 = v97;
                  v116 = 2048;
                  v117 = v96;
                  v118 = 2048;
                  v119 = v95;
                  v120 = 1024;
                  v121 = v94;
                  v122 = 1024;
                  v123 = v93;
                  v124 = 2048;
                  v125 = v66;
                  v126 = 2048;
                  v127 = v67;
                  v128 = 1024;
                  v129 = v92;
                  v130 = 1024;
                  v131 = v91;
                  v132 = 1024;
                  v133 = v90;
                  v134 = 1024;
                  v135 = v88;
                  v136 = 1024;
                  v137 = v89;
                  v138 = 1024;
                  v139 = v87;
                  v140 = 1024;
                  v141 = v86;
                  v142 = 1024;
                  v143 = v83;
                  v144 = 1024;
                  v145 = v85;
                  v146 = 1024;
                  v147 = v84;
                  v148 = 1024;
                  v149 = v82;
                  v150 = 1024;
                  v151 = v68;
                  v152 = 2080;
                  v153 = v69;
                  v154 = 2080;
                  v155 = v70;
                  v156 = 1024;
                  v157 = v72;
                  _os_log_impl(&dword_1D8A54000, v63, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d %8.3f/%04X:\t%.4f\t%.4f\t%.4f\t%.4f %c\tRTT:%-4u\tPLR:%4.2f@%.1f\tRRx:%4u\tMBL:%d\t%4u/%4u\t  CS:%04X %04X %u BB: %3u\t%4u\t%3u\t%u\t%u\t UAT %s %s\t%d", buf, 0xD6u);
                }
              }
            }
            v73 = *(_QWORD *)(a1 + 5112);
            if (v73)
            {
              v74 = *(_QWORD *)(a1 + 1096);
              VCRateControlMediaController_AudioSendingBitrate(*(_QWORD *)(a1 + 1016));
              VCRateControlMediaController_AudioFractionTier(*(_QWORD *)(a1 + 1016));
              if (!*(_BYTE *)(a1 + 1121))
                VCRateControlMediaController_IsVideoStopped(*(_BYTE **)(a1 + 1016));
              VRLogfilePrintWithTimestamp(v73, "%8.3f/%04X:\t%.4f\t%.4f\t%.4f\t%.4f %c\tRTT:%-4u\tPLR:%4.2f@%.1f\tRRx:%u\tMBL:%d %u\t%4u/%4u\t %4u:%4u/%4u  %4u:%4u/%4u  CS: %04X %04X %u BB: %3u\t%4u\t%3u\t%u\t%u\t UAT %s %s\t%d\t%d\t%d\t%d\t%.3f\t%.3f\t%u\t%u\n", v75, v76, v77, v78, v79, v80, v74);
            }
            *(_DWORD *)(a1 + 1044) = 0;
            *(_DWORD *)(a1 + 1048) = 0;
            break;
          case 3:
            *(_DWORD *)(a1 + 1044) |= 1u;
            if (_VCRateControlAlgorithmLowLatencyNOWRD_ShouldRampDown(a1))
              *(_DWORD *)(a1 + 1052) = _VCRateControlAlgorithmLowLatencyNOWRD_RampDownTier(a1);
            if (*(double *)(a1 + 1096) - *(double *)(a1 + 1104) > *(double *)(a1 + 184))
            {
              v59 = a1;
              v60 = 2;
LABEL_125:
              VCRateControlAlgorithmBasePriv_StateChange(v59, v60);
            }
            goto LABEL_126;
          default:
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                _VCRateControlAlogirthmLowLatencyNOWRD_DoRateControl_cold_3();
            }
            goto LABEL_126;
        }
        return 1;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v50 = VRTraceErrorLogLevelToCSTR();
        v51 = *MEMORY[0x1E0CF2758];
        v52 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          v53 = os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT);
          result = 0;
          if (!v53)
            return result;
          *(_DWORD *)buf = 136315906;
          v103 = v50;
          v104 = 2080;
          v105 = "_VCRateControlAlogirthmLowLatencyNOWRD_DoRateControlWithVCRCStatistics";
          v106 = 1024;
          v107 = 207;
          v108 = 1024;
          LODWORD(v109) = v12;
          _os_log_impl(&dword_1D8A54000, v51, OS_LOG_TYPE_DEFAULT, "VCRC [%s] %s:%d Duplicated feedback or out-of-order feedback messages! timestamp:0x%04X", buf, 0x22u);
        }
        else
        {
          result = os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG);
          if (!result)
            return result;
          _VCRateControlAlogirthmLowLatencyNOWRD_DoRateControl_cold_2(v50, v12, v51);
        }
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      _VCRateControlAlogirthmLowLatencyNOWRD_DoRateControl_cold_1();
    }
    return 0;
  }
  *(_DWORD *)(a1 + 5284) = *(_DWORD *)(a2 + 80);
  *(_DWORD *)(a1 + 5304) = *(_DWORD *)(a2 + 84);
  v29 = *(_QWORD *)(a2 + 40);
  if (v29)
  {
    *(_DWORD *)(a1 + 5276) = v29 / *(unsigned int *)(a1 + 5108);
    *(_DWORD *)(a1 + 5280) = *(_QWORD *)(a2 + 72);
    LODWORD(a9) = *(_DWORD *)(a2 + 64);
    a9 = (double)*(unint64_t *)&a9;
    v30 = a9 / 1000.0;
    *(double *)(a1 + 5288) = a9 / 1000.0;
  }
  else
  {
    v30 = *(double *)(a1 + 5288);
  }
  LODWORD(a9) = *(_DWORD *)(a1 + 1072);
  v32 = 400000.0 / (double)*(unint64_t *)&a9;
  if (v32 < 0.02)
    v32 = 0.02;
  if (v32 <= 2.0)
    v33 = v32;
  else
    v33 = 2.0;
  if (v30 > v33)
  {
    *(_DWORD *)(a1 + 1048) |= 0x40u;
    *(_QWORD *)(a1 + 2880) = 0;
    ++*(_DWORD *)(a1 + 5300);
  }
  v34 = *(_DWORD *)(a1 + 5284);
  if (v34 < 0)
  {
    v48 = *(_DWORD *)(a1 + 1052);
    if (v48 >= 1
      && (v34 == 0x80000000
       || (*(_DWORD *)(a1 + 1072) + v34) <= *(_DWORD *)(*(_QWORD *)(a1 + 48)
                                                                    + 4 * (v48 - 1))))
    {
      if (v48 > 0x29 || (v49 = *(_DWORD *)(a1 + 5304)) == 0)
      {
        *(_DWORD *)(a1 + 1048) |= 0x80u;
        *(_QWORD *)(a1 + 2880) = 0;
        goto LABEL_40;
      }
      VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "Stop ramping down due to nw connection NACK [loss:%u]", a3, a4, a5, a6, a7, a8, v49);
    }
  }
  if (v30 > v33)
  {
LABEL_40:
    if (*(_DWORD *)(a1 + 1040) && *(double *)(a1 + 1096) > 0.0)
    {
      _VCRateControlAlgorithmLowLatencyNOWRD_SetRateChangeCounter(a1);
      *(_BYTE *)(a1 + 1112) = 1;
      *(_QWORD *)(a1 + 1136) = *(_QWORD *)(a1 + 1096);
      v41 = *(_DWORD *)(a1 + 1052);
      if (v41 <= 0)
        LODWORD(v42) = 0;
      else
        LODWORD(v42) = v41 - 1;
      v43 = *(_DWORD *)(a1 + 5280);
      if (v43)
      {
        v42 = (int)v42;
        while (*(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * v42) > v43)
        {
          if (--v42 <= *(int *)(a1 + 64))
          {
            LODWORD(v42) = *(_DWORD *)(a1 + 64);
            break;
          }
          if (*(_BYTE *)(a1 + 1121))
            break;
        }
      }
      if ((int)v42 <= *(_DWORD *)(a1 + 64))
        v55 = *(_DWORD *)(a1 + 64);
      else
        v55 = v42;
      if (v41 > v55)
      {
        VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "[%u] Congestion due to nw connection!!! New bitrate down to %u", v35, v36, v37, v38, v39, v40, *(_DWORD *)(a1 + 1084));
        v41 = *(_DWORD *)(a1 + 1052);
      }
      *(_DWORD *)(a1 + 1056) = v41;
      *(_DWORD *)(a1 + 1052) = v55;
      VCRateControlAlgorithmBasePriv_StateChange(a1, 3);
    }
    goto LABEL_93;
  }
  LODWORD(v32) = *(_DWORD *)(a1 + 1072);
  v44 = 400000.0 / (double)*(unint64_t *)&v32;
  if (v44 < 0.02)
    v44 = 0.02;
  v45 = v44 * 0.5;
  v46 = v44 <= 2.0;
  v47 = 1.0;
  if (v46)
    v47 = v45;
  if (*(double *)(a1 + 5288) > v47)
  {
    *(_DWORD *)(a1 + 1044) |= 0x400u;
    if ((*(_DWORD *)(a1 + 5284) & 0x80000000) == 0)
    {
LABEL_72:
      *(_BYTE *)(a1 + 5296) = 1;
      goto LABEL_93;
    }
LABEL_71:
    *(_DWORD *)(a1 + 1044) |= 0x800u;
    goto LABEL_72;
  }
  if ((*(_DWORD *)(a1 + 5284) & 0x80000000) != 0)
    goto LABEL_71;
  *(_BYTE *)(a1 + 5296) = 0;
LABEL_93:
  *(_DWORD *)(a1 + 1072) = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * *(int *)(a1 + 1052));
  return 1;
}

void _VCRateControlAlgorithmLowLatencyNOWRD_SetRateChangeCounter(uint64_t a1)
{
  ++*(_DWORD *)(a1 + 1084);
  *(_BYTE *)(a1 + 5308) = 0;
  if (*(_DWORD *)(a1 + 1040) != 1)
  {
    *(_QWORD *)(a1 + 1104) = *(_QWORD *)(a1 + 1096);
    *(_QWORD *)(a1 + 1176) = *(_QWORD *)(a1 + 1096);
  }
  if (*(_DWORD *)(a1 + 536) == 1)
    *(double *)(a1 + 5320) = micro();
}

uint64_t _VCRateControlAlgorithmLowLatencyNOWRD_ShouldRampDown(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 v9;
  int v10;
  uint64_t v11;
  double v12;
  double v13;
  double *v14;
  double v15;
  int v16;
  double v17;
  double v18;
  int v19;

  *(_DWORD *)(a1 + 5268) = *(_DWORD *)(a1 + 352);
  if (!*(_BYTE *)(a1 + 2848))
    return 0;
  v9 = VCRateControlAlgorithmBasePriv_KeepOvershootingRampDownBandwidth(a1);
  if (v9)
  {
    *(_DWORD *)(a1 + 1048) |= 0x10u;
    *(_DWORD *)(a1 + 5268) = 0;
    *(_QWORD *)(a1 + 2880) = 0;
  }
  if (*(_DWORD *)(a1 + 1040) != 1
    && *(double *)(a1 + 1096) - *(double *)(a1 + 2888) > *(double *)(a1 + 160)
    && *(_DWORD *)(a1 + 5260))
  {
    *(_DWORD *)(a1 + 1048) |= 1u;
    *(_QWORD *)(a1 + 2888) = *(_QWORD *)(a1 + 1096);
    *(_QWORD *)(a1 + 2880) = 0;
    v9 = 1;
  }
  if (*(_BYTE *)(a1 + 5256) || *(_DWORD *)(a1 + 1040) == 1)
  {
    v10 = *(unsigned __int8 *)(a1 + 1121);
    v11 = 88;
    if (!*(_BYTE *)(a1 + 1121))
      v11 = 104;
    v12 = *(double *)(a1 + 40 + v11);
    v13 = *(double *)(a1 + 2864);
    if (v13 > v12 && *(double *)(a1 + 5208) > v12 && *(double *)(a1 + 2872) > 0.0)
    {
      *(double *)(a1 + 5208) = v13;
      if (!v10 && *(double *)(a1 + 1096) - *(double *)(a1 + 5224) > *(double *)(a1 + 312))
      {
        *(_DWORD *)(a1 + 1048) |= 4u;
        *(_QWORD *)(a1 + 2880) = 0;
        v9 = 1;
      }
      goto LABEL_21;
    }
  }
  else
  {
    v13 = 0.0;
  }
  *(double *)(a1 + 5208) = v13;
LABEL_21:
  if (*(double *)(a1 + 5208) > *(double *)(a1 + 2864)
    || ((*(_BYTE *)(a1 + 5256) || *(_DWORD *)(a1 + 1040) == 1) && !*(_BYTE *)(a1 + 1121)
      ? (v14 = (double *)(a1 + 152))
      : (v14 = (double *)(a1 + 136)),
        (v15 = *(double *)(a1 + 2880), v15 <= *v14) || *(_DWORD *)(a1 + 1052) <= *(_DWORD *)(a1 + 64)))
  {
    v16 = 0;
  }
  else
  {
    *(double *)(a1 + 2880) = v15 - *(double *)(a1 + 136);
    if (*(double *)(a1 + 2880) < 0.0)
      *(_QWORD *)(a1 + 2880) = 0;
    v16 = 1;
  }
  if (*(double *)(a1 + 2856) <= 0.0)
  {
    v17 = *(double *)(a1 + 5248);
  }
  else
  {
    v17 = *(double *)(a1 + 1096);
    *(double *)(a1 + 5248) = v17;
  }
  if (v17 > 0.0)
  {
    v18 = *(double *)(a1 + 1096) - v17;
    if (v18 > 1.0)
    {
      *(_QWORD *)(a1 + 2880) = 0;
      *(_QWORD *)(a1 + 5248) = *(_QWORD *)(a1 + 1096);
      VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "OWRD has been 0 for %f seconds, reset NOWRDAcc", v3, v4, v5, v6, v7, v8, SLOBYTE(v18));
    }
  }
  if (v16 && *(double *)(a1 + 1096) - *(double *)(a1 + 5224) > *(double *)(a1 + 312))
  {
    *(_DWORD *)(a1 + 1048) |= 8u;
    v9 = 1;
  }
  v19 = *(_DWORD *)(a1 + 108);
  if (v19 >= 1 && *(_DWORD *)(a1 + 4984) > v19 && *(_DWORD *)(a1 + 5272))
  {
    *(_DWORD *)(a1 + 1048) |= 0x20u;
    *(_QWORD *)(a1 + 2880) = 0;
    v9 = 1;
    *(_BYTE *)(a1 + 5129) = 1;
  }
  if (*(_BYTE *)(a1 + 420)
    && VCRateControlAlgorithmBasePriv_ShouldRampDownDueToLossEvent(a1, v2, v3, v4, v5, v6, v7, v8))
  {
    *(_DWORD *)(a1 + 1048) |= 0x100u;
    *(_QWORD *)(a1 + 4952) = *(_QWORD *)(a1 + 1096);
    VCRateControlAlgorithmBasePriv_ResetLossEventBuffer(a1);
    *(_QWORD *)(a1 + 2880) = 0;
    return 1;
  }
  return v9;
}

uint64_t _VCRateControlAlgorithmLowLatencyNOWRD_RampDownTier(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;

  _VCRateControlAlgorithmLowLatencyNOWRD_SetRateChangeCounter(a1);
  *(_BYTE *)(a1 + 5256) = 0;
  *(_BYTE *)(a1 + 1112) = 1;
  *(_QWORD *)(a1 + 1136) = *(_QWORD *)(a1 + 1096);
  v8 = *(_DWORD *)(a1 + 1052);
  v9 = v8 - *(_DWORD *)(a1 + 96);
  if (*(_DWORD *)(a1 + 1040) == 1)
    v9 = v9 - *(_DWORD *)(a1 + 104) - (v8 == *(_DWORD *)(a1 + 56));
  if ((*(_BYTE *)(a1 + 1049) & 1) != 0 && *(double *)(a1 + 4960) > 0.0)
    --v9;
  v10 = *(_DWORD *)(a1 + 64);
  if (v9 <= v10)
    v11 = v10;
  else
    v11 = v9;
  if (v8 > (int)v11)
  {
    VCRateControlAlgorithmBasePriv_LogToDumpFiles(a1, "[%u] Congestion!!! New bitrate down to %u", v2, v3, v4, v5, v6, v7, *(_DWORD *)(a1 + 1084));
    *(double *)(a1 + 5240) = micro();
    v8 = *(_DWORD *)(a1 + 1052);
  }
  *(_DWORD *)(a1 + 1056) = v8;
  return v11;
}

uint64_t _VCRateControlAlgorithmLowLatencyNOWRD_ShouldRampUp(uint64_t a1)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;

  if (*(_BYTE *)(a1 + 5308) || !*(_BYTE *)(a1 + 420))
  {
    v2 = 1;
  }
  else
  {
    v2 = 0;
    *(_DWORD *)(a1 + 1044) |= 0x2000u;
  }
  if (*(_BYTE *)(a1 + 5256))
  {
    v2 = 0;
    *(_DWORD *)(a1 + 1044) |= 2u;
  }
  if (VCRateControlAlgorithmBasePriv_RecentlyGoAboveRampUpBandwidth(a1))
  {
    v2 = 0;
    *(_DWORD *)(a1 + 1044) |= 0x100u;
  }
  if (!*(_BYTE *)(a1 + 2848))
  {
    v2 = 0;
    *(_DWORD *)(a1 + 1044) |= 0x80u;
  }
  if (*(_BYTE *)(a1 + 412) && *(_BYTE *)(a1 + 1121) && *(_DWORD *)(a1 + 1052) >= *(_DWORD *)(a1 + 116))
  {
    v2 = 0;
    *(_DWORD *)(a1 + 1044) |= 4u;
  }
  if (*(_BYTE *)(a1 + 2849))
  {
    v2 = 0;
    *(_DWORD *)(a1 + 1044) |= 0x40u;
  }
  if (*(double *)(a1 + 2856) > *(double *)(a1 + 200))
  {
    v2 = 0;
    *(_DWORD *)(a1 + 1044) |= 8u;
  }
  if (*(double *)(a1 + 2864) > *(double *)(a1 + 208))
  {
    v2 = 0;
    *(_DWORD *)(a1 + 1044) |= 0x10u;
  }
  if (*(double *)(a1 + 2880) > *(double *)(a1 + 216))
  {
    v2 = 0;
    *(_DWORD *)(a1 + 1044) |= 0x20u;
  }
  if (*(_DWORD *)(a1 + 1052) >= *(_DWORD *)(a1 + 60)
    || (v10 = *(_DWORD *)(a1 + 5276)) != 0 && *(_DWORD *)(a1 + 1072) >= v10)
  {
    v2 = 0;
    *(_DWORD *)(a1 + 1044) |= 0x200u;
  }
  if (*(_BYTE *)(a1 + 420)
    && VCRateControlAlgorithmBasePriv_ShouldBlockRampUpDueToLossEventThreshold(a1, v3, v4, v5, v6, v7, v8, v9))
  {
    v2 = 0;
    *(_DWORD *)(a1 + 1044) |= 0x1000u;
  }
  if (*(_BYTE *)(a1 + 5296))
    return 0;
  else
    return v2;
}

uint64_t _VCRateControlAlgorithmLowLatencyNOWRD_RampUpTier(_DWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;

  _VCRateControlAlgorithmLowLatencyNOWRD_SetRateChangeCounter((uint64_t)a1);
  v8 = a1[23] + a1[263];
  if (a1[260] == 1)
    v8 += a1[25];
  v9 = a1[15];
  if (v8 >= v9)
    v10 = v9;
  else
    v10 = v8;
  a1[1242] = 0;
  VCRateControlAlgorithmBasePriv_LogToDumpFiles((uint64_t)a1, "[%u] Ramp up bitrate to %u", v2, v3, v4, v5, v6, v7, a1[271]);
  a1[264] = a1[263];
  return v10;
}

void _VCAudioCaptionsCoordinator_ReleaseSampleInfo(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;

  if (a2)
  {
    v2 = *a2;
    *a2 = 0;
    if (v2)
    {
      if (*(_QWORD *)(v2 + 8))
        VCAudioBufferList_Destroy((uint64_t *)(v2 + 8));
      if (*(_QWORD *)v2)
        CFRelease(*(CFTypeRef *)v2);
      CFAllocatorDeallocate(*(CFAllocatorRef *)(a1 + 400), (void *)v2);
    }
  }
}

void sub_1D8C18A84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_list va;

  va_start(va, a10);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1D8C18EC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_list va;

  va_start(va, a10);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t _VCAudioCaptionsCoordinator_PushAudioSamplesToRecognizer(void *a1, uint64_t a2)
{
  uint64_t Buffer;
  unsigned int SampleCount;

  Buffer = VCAudioCaptionsBufferInfo_GetBuffer(a2);
  objc_msgSend(a1, "pushAudioSamples:", Buffer);
  SampleCount = VCAudioBufferList_GetSampleCount(Buffer);
  return VCAudioBufferList_Shift(Buffer, SampleCount);
}

uint64_t _VCAudioCaptionsCoordinator_StartCaptioning(uint64_t a1, void *a2)
{
  void *v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  NSObject *v9;
  uint64_t v10;
  _QWORD v12[8];
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  char v16;
  _OWORD v17[3];
  uint8_t buf[4];
  uint64_t v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 216));
  v4 = *(void **)(a1 + 232);
  *(_QWORD *)&v17[0] = -1;
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)((char *)v17 + 8) = v5;
  *(_OWORD *)((char *)&v17[1] + 8) = v5;
  if (a2)
    objc_msgSend(a2, "format");
  else
    memset(v17, 0, 40);
  *(_QWORD *)(a1 + 208) = objc_msgSend(a2, "token");
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 216));
  v13 = 0;
  v14 = &v13;
  v15 = 0x2020000000;
  v16 = 0;
  v6 = objc_msgSend(a2, "token");
  v12[0] = MEMORY[0x1E0C809B0];
  v12[1] = 3221225472;
  v12[2] = ___VCAudioCaptionsCoordinator_StartCaptioning_block_invoke;
  v12[3] = &unk_1E9E54CC0;
  v12[4] = v4;
  v12[5] = a2;
  v12[6] = a1;
  v12[7] = &v13;
  objc_msgSend(v4, "start:forToken:withCompletionHandler:", v17, v6, v12);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v7 = VRTraceErrorLogLevelToCSTR();
    v8 = *MEMORY[0x1E0CF2758];
    v9 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        v19 = v7;
        v20 = 2080;
        v21 = "_VCAudioCaptionsCoordinator_StartCaptioning";
        v22 = 1024;
        v23 = 393;
        _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Waiting for captions to start...", buf, 0x1Cu);
      }
    }
    else if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      _VCAudioCaptionsCoordinator_StartCaptioning_cold_1();
    }
  }
  dispatch_semaphore_wait(*(dispatch_semaphore_t *)(a1 + 224), 0xFFFFFFFFFFFFFFFFLL);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 216));
  *(_QWORD *)(a1 + 200) = 2;
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 216));
  v10 = *((unsigned __int8 *)v14 + 24);
  _Block_object_dispose(&v13, 8);
  return v10;
}

void sub_1D8C19C64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t _VCAudioCaptionsCoordinator_StopCaptioning(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  NSObject *v4;
  NSObject *v5;
  uint64_t v6;
  _QWORD v8[6];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  char v12;
  uint8_t buf[4];
  uint64_t v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v9 = 0;
  v10 = &v9;
  v11 = 0x2020000000;
  v12 = 0;
  v2 = *(void **)(a1 + 232);
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = ___VCAudioCaptionsCoordinator_StopCaptioning_block_invoke;
  v8[3] = &unk_1E9E54CE8;
  v8[4] = a1;
  v8[5] = &v9;
  objc_msgSend(v2, "stopWithCompletionHandler:", v8);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v3 = VRTraceErrorLogLevelToCSTR();
    v4 = *MEMORY[0x1E0CF2758];
    v5 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        v14 = v3;
        v15 = 2080;
        v16 = "_VCAudioCaptionsCoordinator_StopCaptioning";
        v17 = 1024;
        v18 = 415;
        _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Waiting for captions to stop...", buf, 0x1Cu);
      }
    }
    else if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      _VCAudioCaptionsCoordinator_StopCaptioning_cold_1();
    }
  }
  dispatch_semaphore_wait(*(dispatch_semaphore_t *)(a1 + 224), 0xFFFFFFFFFFFFFFFFLL);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 216));
  *(_QWORD *)(a1 + 200) = 1;
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 216));
  v6 = *((unsigned __int8 *)v10 + 24);
  _Block_object_dispose(&v9, 8);
  return v6;
}

void sub_1D8C19EFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  _Unwind_Resume(exception_object);
}

BOOL _VCAudioCaptionsCoordinator_ShouldStopCaptioning(uint64_t a1, void *a2, char a3)
{
  __int128 v5;
  double v6;
  unsigned int v8;
  _BYTE v9[40];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a3 < 0)
    return 0;
  *(_QWORD *)v9 = -1;
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v9[8] = v5;
  *(_OWORD *)&v9[24] = v5;
  if (a2)
  {
    objc_msgSend(a2, "format");
    v6 = NAN;
  }
  else
  {
    memset(v9, 0, sizeof(v9));
    v6 = 0.0;
  }
  v8 = (*(double *)(a1 + 384) * v6);
  return objc_msgSend(a2, "countOfLowPrioritySamples", *(_OWORD *)v9, *(_QWORD *)&v9[16], *(_OWORD *)&v9[24], v10) >= v8;
}

uint64_t _VCAudioCaptionsCoordinator_HandleIdleStateAudioSamples(uint64_t a1, void *a2, uint64_t a3)
{
  int Priority;
  uint64_t v7;
  NSObject *v8;
  NSObject *v9;
  uint64_t Buffer;
  int SampleCount;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  int v17;
  uint64_t v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  int v26;
  __int16 v27;
  double HostTime;
  __int16 v29;
  double v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  Priority = VCAudioBufferList_GetPriority(a3);
  VCAudioCaptionsBufferInfoCollection_PushAudioSamples(*(_QWORD *)(a1 + 240), (uint64_t)a2, a3);
  if ((Priority & 0x80) != 0)
  {
    Buffer = VCAudioCaptionsBufferInfo_GetBuffer((uint64_t)a2);
    SampleCount = VCAudioBufferList_GetSampleCount(Buffer);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v12 = VRTraceErrorLogLevelToCSTR();
      v13 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v14 = objc_msgSend(a2, "token");
        v15 = VCAudioCaptionsBufferInfo_GetBuffer((uint64_t)a2);
        v17 = 136316674;
        v18 = v12;
        v19 = 2080;
        v20 = "_VCAudioCaptionsCoordinator_HandleIdleStateAudioSamples";
        v21 = 1024;
        v22 = 441;
        v23 = 2048;
        v24 = v14;
        v25 = 1024;
        v26 = SampleCount;
        v27 = 2048;
        HostTime = VCAudioBufferList_GetHostTime(v15);
        v29 = 2048;
        v30 = VCAudioBufferList_GetHostTime(a3);
        _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Will switch from idle to captioning. streamToken=%ld samplesToBackProcess=%d collectionHostTime=%f sampleHostTime=%f", (uint8_t *)&v17, 0x40u);
      }
    }
    return _VCAudioCaptionsCoordinator_StartCaptioning(a1, a2);
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v7 = VRTraceErrorLogLevelToCSTR();
      v8 = *MEMORY[0x1E0CF2758];
      v9 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          v17 = 136316162;
          v18 = v7;
          v19 = 2080;
          v20 = "_VCAudioCaptionsCoordinator_HandleIdleStateAudioSamples";
          v21 = 1024;
          v22 = 445;
          v23 = 2048;
          v24 = objc_msgSend(a2, "token");
          v25 = 1024;
          v26 = Priority;
          _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Not starting captions because priority is too low for streamToken=%ld priority=%d", (uint8_t *)&v17, 0x2Cu);
        }
      }
      else if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        v17 = 136316162;
        v18 = v7;
        v19 = 2080;
        v20 = "_VCAudioCaptionsCoordinator_HandleIdleStateAudioSamples";
        v21 = 1024;
        v22 = 445;
        v23 = 2048;
        v24 = objc_msgSend(a2, "token");
        v25 = 1024;
        v26 = Priority;
        _os_log_debug_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Not starting captions because priority is too low for streamToken=%ld priority=%d", (uint8_t *)&v17, 0x2Cu);
      }
    }
    return 1;
  }
}

uint64_t _VCAudioCaptionsCoordinator_HandleStartedStateAudioSamples(uint64_t a1, void *a2, uint64_t a3)
{
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  _BOOL4 v11;
  uint64_t result;
  uint64_t v13;
  uint64_t Buffer;
  int SampleCount;
  uint64_t v16;
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  unsigned int v29;
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  int v33;
  __int16 v34;
  double HostTime;
  __int16 v36;
  double v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  VCAudioCaptionsBufferInfoCollection_PushAudioSamples(*(_QWORD *)(a1 + 240), (uint64_t)a2, a3);
  v6 = objc_msgSend(a2, "priority");
  v7 = objc_msgSend((id)VCAudioCaptionsBufferInfoCollection_GetBufferInfo(*(_QWORD *)(a1 + 240), *(_QWORD *)(a1 + 208)), "priority");
  v8 = objc_msgSend(a2, "token");
  if (v8 == *(_QWORD *)(a1 + 208))
  {
    if (_VCAudioCaptionsCoordinator_ShouldStopCaptioning(a1, a2, v6))
    {
      if ((_VCAudioCaptionsCoordinator_StopCaptioning(a1) & 1) == 0)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v9 = VRTraceErrorLogLevelToCSTR();
          v10 = *MEMORY[0x1E0CF2758];
          v11 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
          result = 0;
          if (!v11)
            return result;
          v20 = 136316162;
          v21 = v9;
          v22 = 2080;
          v23 = "_VCAudioCaptionsCoordinator_HandleStartedStateAudioSamples";
          v24 = 1024;
          v25 = 463;
          v26 = 2048;
          v27 = objc_msgSend(a2, "token");
          v28 = 1024;
          v29 = v6;
          _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Tried to stop captions because priority is too low, but failed for streamToken=%ld priority=%d", (uint8_t *)&v20, 0x2Cu);
        }
        return 0;
      }
    }
    else
    {
      _VCAudioCaptionsCoordinator_PushAudioSamplesToRecognizer(*(void **)(a1 + 232), (uint64_t)a2);
    }
    return 1;
  }
  if (v6 <= v7)
    return 1;
  v13 = v8;
  Buffer = VCAudioCaptionsBufferInfo_GetBuffer((uint64_t)a2);
  SampleCount = VCAudioBufferList_GetSampleCount(Buffer);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v16 = VRTraceErrorLogLevelToCSTR();
    v17 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v18 = *(_QWORD *)(a1 + 208);
      v19 = VCAudioCaptionsBufferInfo_GetBuffer((uint64_t)a2);
      v20 = 136317186;
      v21 = v16;
      v22 = 2080;
      v23 = "_VCAudioCaptionsCoordinator_HandleStartedStateAudioSamples";
      v24 = 1024;
      v25 = 478;
      v26 = 2048;
      v27 = v13;
      v28 = 1024;
      v29 = v6;
      v30 = 2048;
      v31 = v18;
      v32 = 1024;
      v33 = SampleCount;
      v34 = 2048;
      HostTime = VCAudioBufferList_GetHostTime(v19);
      v36 = 2048;
      v37 = VCAudioBufferList_GetHostTime(a3);
      _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Found a new streamToken=%ld with higher priority=%d than streamToken=%ld, stop and start the captions. samplesToBackProcess=%d collectionHostTime=%f sampleHostTime=%f", (uint8_t *)&v20, 0x50u);
    }
  }
  if (_VCAudioCaptionsCoordinator_StopCaptioning(a1))
    return _VCAudioCaptionsCoordinator_StartCaptioning(a1, a2);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    _VCAudioCaptionsCoordinator_HandleStartedStateAudioSamples_cold_1();
  }
  return 0;
}

void VCAudioCaptionsCoordinator_setOneToOneVoicePriority(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  int v12;
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (VCAudioBufferList_GetVoiceActivity(a2) || *(_BYTE *)(a1 + 420))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v6 = VRTraceErrorLogLevelToCSTR();
      v7 = *MEMORY[0x1E0CF2758];
      v8 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          v12 = 136315650;
          v13 = v6;
          v14 = 2080;
          v15 = "VCAudioCaptionsCoordinator_setOneToOneVoicePriority";
          v16 = 1024;
          v17 = 521;
          _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Running sample through voice detector", (uint8_t *)&v12, 0x1Cu);
        }
      }
      else if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        VCAudioCaptionsCoordinator_setOneToOneVoicePriority_cold_2();
      }
    }
    VCVoiceDetector_ProcessSampleBuffer(a3, a2, 0);
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v9 = VRTraceErrorLogLevelToCSTR();
      v10 = *MEMORY[0x1E0CF2758];
      v11 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          v12 = 136315650;
          v13 = v9;
          v14 = 2080;
          v15 = "VCAudioCaptionsCoordinator_setOneToOneVoicePriority";
          v16 = 1024;
          v17 = 524;
          _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Not running voice detector", (uint8_t *)&v12, 0x1Cu);
        }
      }
      else if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        VCAudioCaptionsCoordinator_setOneToOneVoicePriority_cold_1();
      }
    }
    VCAudioBufferList_SetPriority(a2, 1);
  }
}

uint64_t VCAudioCaptionsCoordinator_PushAudioSamples(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  uint64_t BufferInfo;
  void *v7;
  _QWORD *v8;
  const void *v9;
  _QWORD *v10;
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  const char *v14;
  uint64_t v15;
  const void *v16;
  int i;
  uint64_t v19;
  NSObject *v20;
  NSObject *v21;
  uint64_t v22;
  NSObject *v23;
  _QWORD *v24;
  _BYTE buf[12];
  __int16 v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  uint64_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 1;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 216));
  BufferInfo = VCAudioCaptionsBufferInfoCollection_GetBufferInfo(*(_QWORD *)(a1 + 240), a2);
  if (BufferInfo)
  {
    v7 = (void *)BufferInfo;
    if (VCAudioCaptionsBufferInfo_UseSecondaryThread(BufferInfo))
    {
      v8 = CFAllocatorAllocate(*(CFAllocatorRef *)(a1 + 400), 16, 0);
      v24 = v8;
      if (!v8)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          v19 = VRTraceErrorLogLevelToCSTR();
          v20 = *MEMORY[0x1E0CF2758];
          v21 = *MEMORY[0x1E0CF2758];
          if (*MEMORY[0x1E0CF2748])
          {
            v15 = 0;
            if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
              goto LABEL_25;
            *(_DWORD *)buf = 136315906;
            *(_QWORD *)&buf[4] = v19;
            v26 = 2080;
            v27 = "_VCAudioCaptionsCoordinator_EnqueueSecondarySamples";
            v28 = 1024;
            v29 = 205;
            v30 = 2048;
            v31 = a1;
            _os_log_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d [%p] Failed to allocate the secondary sample buffer info", buf, 0x26u);
          }
          else if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
          {
            VCAudioCaptionsCoordinator_PushAudioSamples_cold_2();
          }
        }
        goto LABEL_24;
      }
      v9 = v8;
      v8[1] = 0;
      v10 = v8 + 1;
      *v8 = CFRetain(v7);
      if (VCAudioBufferList_CopySampleBuffer(a3, *(CFAllocatorRef *)(a1 + 392), v10))
      {
        if (!CMSimpleQueueEnqueue(*(CMSimpleQueueRef *)(a1 + 408), v9))
        {
          v15 = 1;
LABEL_25:
          os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 216));
          return v15;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() < 8)
          goto LABEL_23;
        v11 = VRTraceErrorLogLevelToCSTR();
        v12 = *MEMORY[0x1E0CF2758];
        v13 = *MEMORY[0x1E0CF2758];
        if (!*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
            VCAudioCaptionsCoordinator_PushAudioSamples_cold_3();
          goto LABEL_23;
        }
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315906;
          *(_QWORD *)&buf[4] = v11;
          v26 = 2080;
          v27 = "_VCAudioCaptionsCoordinator_EnqueueSecondarySamples";
          v28 = 1024;
          v29 = 214;
          v30 = 2048;
          v31 = a1;
          v14 = " [%s] %s:%d [%p] Failed to enqueue the samples";
LABEL_11:
          _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, v14, buf, 0x26u);
        }
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v22 = VRTraceErrorLogLevelToCSTR();
        v12 = *MEMORY[0x1E0CF2758];
        v23 = *MEMORY[0x1E0CF2758];
        if (!*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
            VCAudioCaptionsCoordinator_PushAudioSamples_cold_4();
          goto LABEL_23;
        }
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315906;
          *(_QWORD *)&buf[4] = v22;
          v26 = 2080;
          v27 = "_VCAudioCaptionsCoordinator_EnqueueSecondarySamples";
          v28 = 1024;
          v29 = 210;
          v30 = 2048;
          v31 = a1;
          v14 = " [%s] %s:%d [%p] Failed to copy the samples";
          goto LABEL_11;
        }
      }
LABEL_23:
      _VCAudioCaptionsCoordinator_ReleaseSampleInfo(a1, (uint64_t *)&v24);
LABEL_24:
      v15 = 0;
      goto LABEL_25;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 216));
    v16 = CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 408));
    *(_QWORD *)buf = v16;
    for (i = 1; v16; *(_QWORD *)buf = v16)
    {
      i &= _VCAudioCaptionsCoordinator_ProcessSamples(a1, *(void **)v16, *((_QWORD *)v16 + 1));
      _VCAudioCaptionsCoordinator_ReleaseSampleInfo(a1, (uint64_t *)buf);
      v16 = CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 408));
    }
    return _VCAudioCaptionsCoordinator_ProcessSamples(a1, v7, (uint64_t)a3) & i;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCAudioCaptionsCoordinator_PushAudioSamples_cold_1();
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 216));
    return 0;
  }
}

uint64_t _VCAudioCaptionsCoordinator_ProcessSamples(uint64_t a1, void *a2, uint64_t a3)
{
  _BOOL4 v6;
  uint64_t v7;
  int v8;
  _BOOL4 v9;
  uint64_t v10;
  int v11;
  int *v12;
  _QWORD **v13;
  uint64_t SampleFormat;
  int SampleCount;
  _QWORD *v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  NSObject *v20;
  uint64_t v21;
  int v23;
  uint64_t v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  uint64_t v30;
  __int16 v31;
  uint64_t v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v6 = VCAudioCaptionsBufferInfo_UseSecondaryThread((_BOOL8)a2);
  v7 = 1;
  if (v6)
    v8 = 2;
  else
    v8 = 1;
  if ((*(_DWORD *)(a1 + 416) & v8) != 0)
    return v7;
  v9 = v6;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 216));
  v10 = *(_QWORD *)(a1 + 200);
  v11 = *(unsigned __int8 *)(a1 + 248);
  v12 = &OBJC_IVAR___VCAudioCaptionsCoordinator__voiceDetectorInfoPrimary;
  if (v9)
    v12 = &OBJC_IVAR___VCAudioCaptionsCoordinator__voiceDetectorInfoSecondary;
  v13 = (_QWORD **)(a1 + *v12);
  if (*v13 && !*((_BYTE *)v13 + 8))
  {
    SampleFormat = VCAudioBufferList_GetSampleFormat(a3);
    SampleCount = VCAudioBufferList_GetSampleCount(a3);
    v16 = *(_QWORD **)(SampleFormat + 32);
    v17 = *(_OWORD *)(SampleFormat + 16);
    *((_OWORD *)v13 + 1) = *(_OWORD *)SampleFormat;
    *((_OWORD *)v13 + 2) = v17;
    v13[6] = v16;
    *((_DWORD *)v13 + 14) = SampleCount;
    VCVoiceDetector_Start(*v13, (uint64_t)(v13 + 2));
    *((_BYTE *)v13 + 8) = 1;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 216));
  if (v10 == 2)
  {
    if (v11)
      VCAudioCaptionsCoordinator_setOneToOneVoicePriority(a1, a3, *v13);
    v18 = _VCAudioCaptionsCoordinator_HandleStartedStateAudioSamples(a1, a2, a3);
  }
  else
  {
    if (v10 != 1)
    {
      v7 = 1;
      goto LABEL_20;
    }
    if (v11)
      VCAudioCaptionsCoordinator_setOneToOneVoicePriority(a1, a3, *v13);
    v18 = _VCAudioCaptionsCoordinator_HandleIdleStateAudioSamples(a1, a2, a3);
  }
  v7 = v18;
LABEL_20:
  if (v10 != *(_QWORD *)(a1 + 200) && (int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v19 = VRTraceErrorLogLevelToCSTR();
    v20 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v21 = *(_QWORD *)(a1 + 200);
      v23 = 136316162;
      v24 = v19;
      v25 = 2080;
      v26 = "_VCAudioCaptionsCoordinator_ProcessSamples";
      v27 = 1024;
      v28 = 573;
      v29 = 2048;
      v30 = v10;
      v31 = 2048;
      v32 = v21;
      _os_log_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d state changed from oldState=%ld to newState=%ld", (uint8_t *)&v23, 0x30u);
    }
  }
  return v7;
}

CFTypeRef VCConnectionSelector_CopyPrimaryConnection(uint64_t a1)
{
  const void *v1;

  if (a1 && (v1 = *(const void **)(a1 + 8)) != 0)
    return CFRetain(v1);
  else
    return 0;
}

void VCConnectionSelector_SetPrimaryConnection(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v2;

  if (a1)
  {
    v2 = *(CFTypeRef *)(a1 + 8);
    if (v2 != cf)
    {
      *(_QWORD *)(a1 + 8) = cf;
      if (cf)
        CFRetain(cf);
      if (v2)
        CFRelease(v2);
    }
  }
}

void VCConnectionSelector_UpdateConnectionForDuplication(uint64_t a1, int a2, int a3, int a4, int a5, const __CFArray *a6)
{
  const void *v12;
  const void **v13;
  const void *v14;
  const void *v15;
  const void **v16;
  const __CFArray *v17;
  const void *v18;
  uint64_t v19;
  NSObject *v20;
  unsigned int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  NSObject *v25;
  CFIndex v26;
  CFIndex v27;
  CFIndex v28;
  char v29;
  _BOOL4 v31;
  const void *ValueAtIndex;
  const void *v33;
  const void *v34;
  uint64_t v35;
  NSObject *v36;
  int IsEndToEndLink;
  const void *v38;
  CFIndex v39;
  CFNumberRef v40;
  CFNumberRef v41;
  unsigned __int16 FirstIndexOfValue;
  int v43;
  const void *v44;
  uint64_t v45;
  NSObject *v46;
  uint64_t v47;
  NSObject *v48;
  const void *v49;
  const void *v50;
  uint64_t v51;
  NSObject *v52;
  uint64_t v53;
  NSObject *v54;
  const char *v55;
  NSObject *v56;
  uint32_t v57;
  uint64_t v58;
  NSObject *v59;
  const __CFAllocator *allocator;
  const void **v61;
  const void **v62;
  const __CFArray *theArray;
  unsigned int v64;
  int IsRemoteOnWiFiOrWired;
  _BOOL4 v66;
  CFIndex Count;
  int IsLocalOnWiFiOrWired;
  int valuePtr;
  uint8_t buf[4];
  uint64_t v71;
  __int16 v72;
  const char *v73;
  __int16 v74;
  int v75;
  __int16 v76;
  _BYTE v77[10];
  _BYTE v78[6];
  __int16 v79;
  int v80;
  __int16 v81;
  _BOOL4 v82;
  __int16 v83;
  const void *v84;
  uint64_t v85;
  CFRange v86;

  v85 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 5)
      return;
    v53 = VRTraceErrorLogLevelToCSTR();
    v54 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      return;
    *(_DWORD *)buf = 136315650;
    v71 = v53;
    v72 = 2080;
    v73 = "VCConnectionSelector_UpdateConnectionForDuplication";
    v74 = 1024;
    v75 = 116;
    v55 = " [%s] %s:%d nil instance passed";
    v56 = v54;
    v57 = 28;
    goto LABEL_111;
  }
  if (*(_BYTE *)(a1 + 64) || VCConnection_IsRelay(*(_QWORD *)(a1 + 72)))
  {
    v13 = (const void **)(a1 + 88);
    v12 = *(const void **)(a1 + 88);
    v14 = *(const void **)(a1 + 72);
    if (v12 == v14)
      goto LABEL_12;
    *v13 = v14;
    if (v14)
      CFRetain(v14);
    if (!v12)
    {
LABEL_12:
      v16 = (const void **)(a1 + 80);
      v15 = *(const void **)(a1 + 80);
      if (v15 != v14)
      {
        *v16 = v14;
        if (v14)
          CFRetain(v14);
        if (v15)
          goto LABEL_16;
      }
      goto LABEL_17;
    }
LABEL_11:
    CFRelease(v12);
    goto LABEL_12;
  }
  v13 = (const void **)(a1 + 88);
  v12 = *(const void **)(a1 + 88);
  if (v12)
  {
    v14 = 0;
    *v13 = 0;
    goto LABEL_11;
  }
  v16 = (const void **)(a1 + 80);
  v15 = *(const void **)(a1 + 80);
  if (v15)
  {
    *v16 = 0;
LABEL_16:
    CFRelease(v15);
  }
LABEL_17:
  v17 = *(const __CFArray **)(a1 + 24);
  v61 = v13;
  v62 = v16;
  if (v17)
    Count = CFArrayGetCount(v17);
  else
    Count = 0;
  theArray = v17;
  IsLocalOnWiFiOrWired = a4 == 0;
  IsRemoteOnWiFiOrWired = a5 == 0;
  v18 = (const void *)VCConnection_CopyDescription(*(_QWORD *)(a1 + 72));
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v19 = VRTraceErrorLogLevelToCSTR();
    v20 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136317186;
      v71 = v19;
      v72 = 2080;
      v73 = "VCConnectionSelector_UpdateConnectionForDuplication";
      v74 = 1024;
      v75 = 133;
      v76 = 1024;
      *(_DWORD *)v77 = a4 == 0;
      *(_WORD *)&v77[4] = 1024;
      *(_DWORD *)&v77[6] = a5 == 0;
      *(_WORD *)v78 = 1024;
      *(_DWORD *)&v78[2] = a3;
      v79 = 1024;
      v80 = a2;
      v81 = 1024;
      v82 = Count != 0;
      v83 = 2112;
      v84 = v18;
      _os_log_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d HandoverReport: updateConnectionForDuplication isLocalPreferWiFi %d isRemotePreferWiFi: %d duplicationEnhancementEnabled: %d duplicationReason: %d useLinkPriorityForSelection: %d secondary connection %@", buf, 0x44u);
    }
  }
  v21 = a2 - 1;
  if ((a2 - 1) < 2)
    v22 = a3;
  else
    v22 = 0;
  if (v22 != 1)
    goto LABEL_32;
  if (Count)
  {
    v23 = *(_QWORD *)(a1 + 72);
    if (v23)
    {
      IsLocalOnWiFiOrWired = VCConnection_IsLocalOnWiFiOrWired(v23);
      IsRemoteOnWiFiOrWired = VCConnection_IsRemoteOnWiFiOrWired(*(_QWORD *)(a1 + 72));
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v24 = VRTraceErrorLogLevelToCSTR();
        v25 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316162;
          v71 = v24;
          v72 = 2080;
          v73 = "VCConnectionSelector_UpdateConnectionForDuplication";
          v74 = 1024;
          v75 = 143;
          v76 = 1024;
          *(_DWORD *)v77 = IsLocalOnWiFiOrWired;
          *(_WORD *)&v77[4] = 1024;
          *(_DWORD *)&v77[6] = IsRemoteOnWiFiOrWired;
          _os_log_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d HandoverReport: Duplication active due to missing packets - updateConnectionForDuplication forces to use secondary connection interface preferences - isLocalPreferWiFi(updated): %d isRemotePreferWiFi(updated): %d", buf, 0x28u);
        }
      }
    }
LABEL_32:
    if (v18)
      CFRelease(v18);
    if (a6)
    {
      v26 = CFArrayGetCount(a6);
      if (v26 < 1)
        return;
      v27 = v26;
      v28 = 0;
      v29 = v22 ^ 1;
      v31 = v21 < 2 && Count != 0;
      v66 = v31;
      allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v64 = 0xFFFF;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(a6, v28);
        v33 = ValueAtIndex;
        if (*(_BYTE *)(a1 + 64) || VCConnection_IsRelay((uint64_t)ValueAtIndex))
        {
          v34 = (const void *)VCConnection_CopyDescription((uint64_t)v33);
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v35 = VRTraceErrorLogLevelToCSTR();
            v36 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315906;
              v71 = v35;
              v72 = 2080;
              v73 = "VCConnectionSelector_UpdateConnectionForDuplication";
              v74 = 1024;
              v75 = 157;
              v76 = 2112;
              *(_QWORD *)v77 = v34;
              _os_log_impl(&dword_1D8A54000, v36, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d HandoverReport: updateConnectionForDuplication check connection %@", buf, 0x26u);
            }
          }
          if ((VCConnection_Priority((uint64_t)v33) & 0xFFFFFFFE) != 2
            && (VCConnection_IsOnSameInterfacesWithConnection((uint64_t)v33) & 1) == 0)
          {
            if (!*(_BYTE *)(a1 + 16)
              || (IsEndToEndLink = VCConnection_IsEndToEndLink((uint64_t)v33),
                  IsEndToEndLink == VCConnection_IsEndToEndLink(*(_QWORD *)(a1 + 8))))
            {
              if (IsLocalOnWiFiOrWired == VCConnection_IsLocalOnWiFiOrWired((uint64_t)v33))
              {
                if (((IsRemoteOnWiFiOrWired ^ VCConnection_IsRemoteOnWiFiOrWired((uint64_t)v33) ^ 1 | v66) & 1) != 0)
                {
LABEL_59:
                  if ((v29 & 1) != 0)
                  {
                    v38 = *v61;
                    if (*v61 != v33)
                    {
                      *v61 = v33;
                      if (v33)
                        CFRetain(v33);
                      if (v38)
                        CFRelease(v38);
                    }
                  }
                  if (!Count)
                  {
                    v50 = *v62;
                    if (*v62 != v33)
                    {
                      *v62 = v33;
                      if (v33)
                        CFRetain(v33);
                      if (v50)
                        CFRelease(v50);
                    }
                    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
                    {
                      v51 = VRTraceErrorLogLevelToCSTR();
                      v52 = *MEMORY[0x1E0CF2758];
                      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)buf = 136315906;
                        v71 = v51;
                        v72 = 2080;
                        v73 = "VCConnectionSelector_UpdateConnectionForDuplication";
                        v74 = 1024;
                        v75 = 182;
                        v76 = 2112;
                        *(_QWORD *)v77 = v34;
                        _os_log_impl(&dword_1D8A54000, v52, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d HandoverReport: updateConnectionForDuplication picks connection %@", buf, 0x26u);
                      }
                    }
                    if (v34)
                    {
                      v49 = v34;
LABEL_91:
                      CFRelease(v49);
                    }
                    return;
                  }
                  if (theArray)
                    v39 = CFArrayGetCount(theArray);
                  else
                    v39 = 0;
                  valuePtr = -1431655766;
                  valuePtr = VCConnection_ConnectionID((uint64_t)v33);
                  v40 = CFNumberCreate(allocator, kCFNumberIntType, &valuePtr);
                  v41 = v40;
                  if (theArray)
                  {
                    v86.location = 0;
                    v86.length = v39;
                    FirstIndexOfValue = CFArrayGetFirstIndexOfValue(theArray, v86, v40);
                    if (v41)
                      goto LABEL_71;
                  }
                  else
                  {
                    FirstIndexOfValue = 0;
                    if (v40)
LABEL_71:
                      CFRelease(v41);
                  }
                  v43 = FirstIndexOfValue;
                  if (FirstIndexOfValue <= v64)
                  {
                    v44 = *v62;
                    if (*v62 != v33)
                    {
                      *v62 = v33;
                      if (v33)
                        CFRetain(v33);
                      if (v44)
                        CFRelease(v44);
                    }
                    v64 = FirstIndexOfValue;
                    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
                    {
                      v45 = VRTraceErrorLogLevelToCSTR();
                      v46 = *MEMORY[0x1E0CF2758];
                      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)buf = 136316162;
                        v71 = v45;
                        v72 = 2080;
                        v73 = "VCConnectionSelector_UpdateConnectionForDuplication";
                        v74 = 1024;
                        v75 = 196;
                        v76 = 2112;
                        *(_QWORD *)v77 = v34;
                        *(_WORD *)&v77[8] = 1024;
                        *(_DWORD *)v78 = v43;
                        _os_log_impl(&dword_1D8A54000, v46, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d HandoverReport: updateConnectionForDuplication picks connection %@ selectedConnectionPriority: %d", buf, 0x2Cu);
                      }
                    }
                  }
                  if (v34)
                    CFRelease(v34);
                  v29 = 0;
                  goto LABEL_56;
                }
              }
              else if (v66)
              {
                goto LABEL_59;
              }
            }
          }
          if (v34)
            CFRelease(v34);
        }
LABEL_56:
        if (v27 == ++v28)
          return;
      }
    }
    if ((int)VRTraceGetErrorLogLevelForModule() < 5)
      return;
    v58 = VRTraceErrorLogLevelToCSTR();
    v59 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      return;
    *(_DWORD *)buf = 136315906;
    v71 = v58;
    v72 = 2080;
    v73 = "VCConnectionSelector_UpdateConnectionForDuplication";
    v74 = 1024;
    v75 = 149;
    v76 = 2048;
    *(_QWORD *)v77 = a1;
    v55 = " [%s] %s:%d nil connectionArray, instance=%p";
    v56 = v59;
    v57 = 38;
LABEL_111:
    _os_log_impl(&dword_1D8A54000, v56, OS_LOG_TYPE_DEFAULT, v55, buf, v57);
    return;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v47 = VRTraceErrorLogLevelToCSTR();
    v48 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      v71 = v47;
      v72 = 2080;
      v73 = "VCConnectionSelector_UpdateConnectionForDuplication";
      v74 = 1024;
      v75 = 137;
      v76 = 2112;
      *(_QWORD *)v77 = v18;
      _os_log_impl(&dword_1D8A54000, v48, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d HandoverReport: Duplication active due to missing packets - updateConnectionForDuplication forces to use secondary connection %@", buf, 0x26u);
    }
  }
  if (v18)
  {
    v49 = v18;
    goto LABEL_91;
  }
}

CFTypeRef VCConnectionSelector_CopyConnectionForDuplication(uint64_t a1)
{
  const void *v1;
  uint64_t v3;
  NSObject *v4;
  int v5;
  uint64_t v6;
  __int16 v7;
  const char *v8;
  __int16 v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v1 = *(const void **)(a1 + 80);
    if (v1)
      return CFRetain(v1);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v3 = VRTraceErrorLogLevelToCSTR();
    v4 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v5 = 136315650;
      v6 = v3;
      v7 = 2080;
      v8 = "VCConnectionSelector_CopyConnectionForDuplication";
      v9 = 1024;
      v10 = 356;
      _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Passing nil instance", (uint8_t *)&v5, 0x1Cu);
    }
  }
  return 0;
}

void sub_1D8C1DEAC(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1D8C1DFF0(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1D8C1E304(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void sub_1D8C1EA2C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1D8C1F104(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1D8C1FB44(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1D8C205B8(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1D8C20EFC(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t _VCAirPlayAudioHALPlugin_handleAudioFrame(uint64_t result, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t (*v5)(_QWORD, uint64_t *, uint64_t, uint64_t);
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v6 = a2;
    v8 = -1431655766;
    v7 = a3;
    v5 = *(uint64_t (**)(_QWORD, uint64_t *, uint64_t, uint64_t))(result + 56);
    if (v5)
      return v5(*(_QWORD *)(result + 48), &v6, a4, a5);
  }
  return result;
}

void sub_1D8C2AFB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v9;
  va_list va;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  va_list va1;

  va_start(va1, a8);
  va_start(va, a8);
  v9 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1D8C2B430(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v8;
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v8 - 72), 8);
  _Unwind_Resume(a1);
}

void freeValueCallback(int a1, void *a2)
{
  if (a2)
    free(a2);
}

VCMediaControlInfoFaceTimeAudio *VCMediaControlInfoGeneratorCreateControlInfo(uint64_t a1)
{
  VCMediaControlInfoFaceTimeAudio *ControlInfoFromPool;
  VCMediaControlInfoFaceTimeAudio *v3;
  uint64_t v4;
  NSObject *v5;
  VCMediaControlInfoFaceTimeAudio *v6;
  int v7;
  __objc2_class *v8;

  if (a1)
  {
    ControlInfoFromPool = (VCMediaControlInfoFaceTimeAudio *)_VCMediaControlInfo_CreateControlInfoFromPool(a1);
    if (!ControlInfoFromPool)
    {
      switch(*(_DWORD *)(a1 + 8))
      {
        case 0:
          v6 = objc_alloc_init(VCMediaControlInfoFaceTimeAudio);
          v3 = v6;
          v7 = *(_DWORD *)(a1 + 100);
          if ((v7 & 1) != 0)
          {
            VCMediaControlInfoFaceTimeAudio_SetVideoEnabled((uint64_t)v6, 1);
            v7 = *(_DWORD *)(a1 + 100);
          }
          if ((v7 & 2) != 0)
            -[VCMediaControlInfoFaceTimeAudio setEcnEnabled:](v3, "setEcnEnabled:", 1);
          goto LABEL_18;
        case 1:
          v8 = VCMediaControlInfoFaceTimeVideo;
          goto LABEL_17;
        case 2:
          v8 = VCMediaControlInfoIPCamera;
          goto LABEL_17;
        case 4:
          v8 = VCMediaControlInfoMultiwayAudio;
LABEL_17:
          v3 = (VCMediaControlInfoFaceTimeAudio *)objc_alloc_init(v8);
LABEL_18:
          VCMediaControlInfo_SetVersion((uint64_t)v3, *(_BYTE *)(a1 + 96));
          if (v3)
            goto LABEL_19;
          return v3;
        default:
          VCMediaControlInfo_SetVersion(0, *(_BYTE *)(a1 + 96));
          return 0;
      }
    }
    v3 = ControlInfoFromPool;
    VCMediaControlInfo_SetVersion((uint64_t)ControlInfoFromPool, *(_BYTE *)(a1 + 96));
LABEL_19:
    _VCMediaControlInfoGenerator_PassMediaControlInfo(a1, (uint64_t)v3, 1);
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v4 = VRTraceErrorLogLevelToCSTR();
      v5 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCMediaControlInfoGeneratorCreateControlInfo_cold_1(v4, v5);
    }
    return 0;
  }
  return v3;
}

uint64_t _VCMediaControlInfoGenerator_PassMediaControlInfo(uint64_t a1, uint64_t a2, int a3)
{
  pthread_rwlock_t *v6;
  CFIndex Count;
  size_t v8;
  unint64_t v9;
  const void **v10;
  void *v11;
  char *v12;
  void (**v13)(uint64_t, const void *, uint64_t);
  void (*v14)(uint64_t, const void *, uint64_t);
  uint64_t v16;
  void (*v17)(uint64_t, const void *);
  char v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v6 = (pthread_rwlock_t *)(a1 + 104);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 104));
  Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 16));
  v8 = 8 * Count;
  v9 = (8 * Count + 15) & 0xFFFFFFFFFFFFFFF0;
  v10 = (const void **)((char *)&v16 - v9);
  if (MEMORY[0x1E0C80A78](Count))
  {
    v11 = memset((char *)&v16 - v9, 170, v8);
    MEMORY[0x1E0C80A78](v11);
    v12 = (char *)&v16 - v9;
    memset(v12, 170, v8);
  }
  else
  {
    v12 = &v18;
  }
  v17 = _VCMediaControlInfoGenerator_DisposeControlInfo;
  VCMediaControlInfo_SetDelegateAndVTable(a2, (CFTypeRef)a1, &v17);
  CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 16), v10, (const void **)v12);
  if (Count >= 1)
  {
    do
    {
      v13 = *(void (***)(uint64_t, const void *, uint64_t))v12;
      if (a3)
      {
        if (!v13)
          goto LABEL_12;
        v14 = *v13;
        if (!v14)
          goto LABEL_12;
      }
      else
      {
        if (!v13)
          goto LABEL_12;
        v14 = v13[1];
        if (!v14)
          goto LABEL_12;
      }
      v14(a1, *v10, a2);
LABEL_12:
      ++v10;
      v12 += 8;
      --Count;
    }
    while (Count);
  }
  return pthread_rwlock_unlock(v6);
}

void *VCMediaControlInfoGeneratorCreateControlInfoWithBuffer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void *ControlInfoFromPool;
  void *v9;
  uint64_t v10;
  int *v11;
  uint64_t v12;
  NSObject *v13;

  if (!a1)
    return 0;
  ControlInfoFromPool = _VCMediaControlInfo_CreateControlInfoFromPool(a1);
  if (!ControlInfoFromPool)
  {
    v11 = (int *)(a1 + 8);
    v10 = *(int *)(a1 + 8);
    if (v10 < 5 && ((0x17u >> v10) & 1) != 0)
    {
      v9 = (void *)objc_msgSend(objc_alloc(off_1E9E54FC8[v10]->isa), "initWithBuffer:length:optionalControlInfo:version:", a2, a3, a4, *(unsigned __int8 *)(a1 + 96));
      objc_msgSend(v9, "setFecFeedbackVersion:", *(unsigned __int8 *)(a1 + 97));
      if (!v9)
        return v9;
      goto LABEL_4;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v12 = VRTraceErrorLogLevelToCSTR();
      v13 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCMediaControlInfoGeneratorCreateControlInfoWithBuffer_cold_1(v12, v11, v13);
    }
    return 0;
  }
  v9 = ControlInfoFromPool;
  objc_msgSend(ControlInfoFromPool, "setVersion:", *(unsigned __int8 *)(a1 + 96));
  objc_msgSend(v9, "configureWithBuffer:length:optionalControlInfo:", a2, a3, a4);
  objc_msgSend(v9, "setFecFeedbackVersion:", *(unsigned __int8 *)(a1 + 97));
LABEL_4:
  _VCMediaControlInfoGenerator_PassMediaControlInfo(a1, (uint64_t)v9, 0);
  return v9;
}

VCMediaControlInfoGenerator *VCMediaControlInfoGeneratorCreateWithTypeAndVersion(uint64_t a1, uint64_t a2)
{
  return -[VCMediaControlInfoGenerator initWithType:version:]([VCMediaControlInfoGenerator alloc], "initWithType:version:", a1, a2);
}

VCMediaControlInfoGenerator *VCMediaControlInfoGeneratorCreateWithType(uint64_t a1)
{
  return -[VCMediaControlInfoGenerator initWithType:version:]([VCMediaControlInfoGenerator alloc], "initWithType:version:", a1, 1);
}

uint64_t VCMediaControlInfoGeneratoSetFECFeedbackVersion(void *a1, const char *a2)
{
  return objc_msgSend(a1, "setFecFeedbackVersion:", a2);
}

uint64_t VCMediaControlInfoGeneratorRegisterCallbacks(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend(a1, "registerFillBlobCallback:processBlobCallback:context:", a3, a4, a2);
}

uint64_t VCMediaControlInfoGeneratorDeregisterCallbacks(void *a1, const char *a2)
{
  return objc_msgSend(a1, "deregisterCallbacksWithContext:", a2);
}

uint64_t VCMediaControlInfoGeneratorAddOptions(void *a1, const char *a2)
{
  return objc_msgSend(a1, "addMediaControlInfoOption:", a2);
}

uint64_t VCMediaControlInfoGeneratorGetSerializedSizeWithConfig(unsigned int *a1, uint64_t *a2)
{
  uint64_t result;
  VCMediaControlInfoGenerator *v5;
  VCMediaControlInfoFaceTimeAudio *ControlInfo;

  result = 1;
  if (a1 && a2)
  {
    v5 = -[VCMediaControlInfoGenerator initWithType:version:]([VCMediaControlInfoGenerator alloc], "initWithType:version:", *a1, *((unsigned __int8 *)a1 + 4));
    ControlInfo = VCMediaControlInfoGeneratorCreateControlInfo((uint64_t)v5);
    *a2 = VCMediaControlInfoGetSize((uint64_t)ControlInfo);
    VCMediaControlInfoDispose((uint64_t)ControlInfo);
    if (v5)
      CFRelease(v5);
    return 0;
  }
  return result;
}

void _VCMediaControlInfoGenerator_DisposeControlInfo(uint64_t a1, const void *a2)
{
  __CFArray *v4;

  VCMediaControlInfo_Invalidate((uint64_t)a2);
  if (a2)
  {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
    v4 = *(__CFArray **)(a1 + 24);
    if (v4)
      CFArrayAppendValue(v4, a2);
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 32));
    CFRelease(a2);
  }
}

void *_VCMediaControlInfo_CreateControlInfoFromPool(uint64_t a1)
{
  pthread_mutex_t *v2;
  const __CFArray *v3;
  void *ValueAtIndex;
  id v5;

  v2 = (pthread_mutex_t *)(a1 + 32);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
  if (objc_msgSend(*(id *)(a1 + 24), "count"))
  {
    v3 = *(const __CFArray **)(a1 + 24);
    ValueAtIndex = (void *)CFArrayGetValueAtIndex(v3, 0);
    v5 = ValueAtIndex;
    CFArrayRemoveValueAtIndex(v3, 0);
  }
  else
  {
    ValueAtIndex = 0;
  }
  pthread_mutex_unlock(v2);
  return ValueAtIndex;
}

uint64_t _VCAudioPowerSpectrumMeter_CompareListEntries(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  BOOL v4;
  unsigned int v5;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a2 + 8);
  v4 = v2 == v3;
  v5 = 2 * (v2 >= v3);
  if (v4)
    return 1;
  else
    return v5;
}

const void *_VCAudioPowerSpectrumMeter_ProcessEventQueue(uint64_t a1, int a2)
{
  const void *result;
  __int128 v5;
  uint64_t v6;
  os_log_t *v7;
  int v8;
  void *v9;
  int v10;
  int ErrorLogLevelForModule;
  uint64_t v12;
  NSObject *v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  const void **v19;
  uint64_t v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  NSObject *v25;
  uint64_t v26;
  NSObject *v27;
  CMSimpleQueueRef *v28;
  void *v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  __int128 v34;
  const void *v35;
  _QWORD *v36;
  _BYTE buf[12];
  __int16 v38;
  const char *v39;
  __int16 v40;
  int v41;
  __int16 v42;
  _BYTE v43[10];
  __int16 v44;
  void *v45;
  __int16 v46;
  uint64_t v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  result = CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 32));
  v35 = result;
  if (result)
  {
    v6 = (uint64_t)result;
    v7 = (os_log_t *)MEMORY[0x1E0CF2758];
    *(_QWORD *)&v5 = 136316674;
    v34 = v5;
    do
    {
      v8 = *(_DWORD *)(v6 + 76);
      switch(v8)
      {
        case 3:
          v36 = (_QWORD *)v6;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v20 = VRTraceErrorLogLevelToCSTR();
            v21 = *v7;
            if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
            {
              v22 = *(_QWORD *)(a1 + 88);
              *(_DWORD *)buf = 136315906;
              *(_QWORD *)&buf[4] = v20;
              v38 = 2080;
              v39 = "_VCAudioPowerSpectrumMeter_RemoveAllStream";
              v40 = 1024;
              v41 = 172;
              v42 = 2048;
              *(_QWORD *)v43 = v22;
              _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCAudioPowerSpectrumMeter=%p", buf, 0x26u);
            }
          }
          while (1)
          {
            v23 = VCSingleLinkedListPop((uint64_t *)a1);
            *(_QWORD *)buf = v23;
            if (!v23)
              break;
            VCAudioPowerSpectrumSource_UnregisterAudioPowerSpectrumSink((CMSimpleQueueRef *)v23[3], (void *)v23[6]);
            _VCAudioPowerSpectrumMeter_FreeStream((_QWORD **)buf);
          }
          break;
        case 2:
          *(_QWORD *)buf = v6;
          v17 = VCSingleLinkedListRemove(a1, v6);
          v36 = v17;
          if (v17)
          {
            v18 = v17;
            VCAudioPowerSpectrumSource_UnregisterAudioPowerSpectrumSink((CMSimpleQueueRef *)v17[3], (void *)v17[6]);
            CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 72), (const void *)v18[2]);
            _VCAudioPowerSpectrumMeter_FreeStream(&v36);
          }
          v19 = (const void **)buf;
          goto LABEL_28;
        case 1:
          v36 = (_QWORD *)v6;
          v9 = *(void **)(v6 + 40);
          VCAudioPowerSpectrumSource_UnregisterAudioPowerSpectrumSink((CMSimpleQueueRef *)objc_msgSend(v9, "realtimeContext"), (void *)a1);
          v10 = VCSingleLinkedListPush(a1, (_QWORD *)v6);
          ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
          if (v10)
          {
            if (ErrorLogLevelForModule >= 8)
            {
              v12 = VRTraceErrorLogLevelToCSTR();
              v13 = *v7;
              v14 = *v7;
              if (*MEMORY[0x1E0CF2748])
              {
                if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
                {
                  v15 = *(_QWORD *)(v6 + 8);
                  v16 = *(_QWORD *)(v6 + 56);
                  *(_DWORD *)buf = v34;
                  *(_QWORD *)&buf[4] = v12;
                  v38 = 2080;
                  v39 = "_VCAudioPowerSpectrumMeter_AddStream";
                  v40 = 1024;
                  v41 = 151;
                  v42 = 1024;
                  *(_DWORD *)v43 = 151;
                  *(_WORD *)&v43[4] = 1024;
                  *(_DWORD *)&v43[6] = v15;
                  v44 = 2048;
                  v45 = v9;
                  v46 = 2048;
                  v47 = v16;
                  _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VCAudioPowerSpectrumMeter.m:%d: streamToken %d is registered to source %p with spectrum %p", buf, 0x3Cu);
                }
              }
              else if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
              {
                v32 = *(_QWORD *)(v6 + 8);
                v33 = *(_QWORD *)(v6 + 56);
                *(_DWORD *)buf = v34;
                *(_QWORD *)&buf[4] = v12;
                v38 = 2080;
                v39 = "_VCAudioPowerSpectrumMeter_AddStream";
                v40 = 1024;
                v41 = 151;
                v42 = 1024;
                *(_DWORD *)v43 = 151;
                *(_WORD *)&v43[4] = 1024;
                *(_DWORD *)&v43[6] = v32;
                v44 = 2048;
                v45 = v9;
                v46 = 2048;
                v47 = v33;
                _os_log_debug_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEBUG, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VCAudioPowerSpectrumMeter.m:%d: streamToken %d is registered to source %p with spectrum %p", buf, 0x3Cu);
              }
            }
            v28 = (CMSimpleQueueRef *)objc_msgSend(v9, "realtimeContext", v34);
            if (a2)
              v29 = *(void **)(a1 + 88);
            else
              v29 = 0;
            VCAudioPowerSpectrumSource_RegisterAudioPowerSpectrumSink(v28, *(void **)(v6 + 48), *(void **)(v6 + 56), v29, VCAudioPowerSpectrum_PushAudioSamples);
            goto LABEL_29;
          }
          if (ErrorLogLevelForModule >= 3)
          {
            v26 = VRTraceErrorLogLevelToCSTR();
            v27 = *v7;
            if (os_log_type_enabled(*v7, OS_LOG_TYPE_ERROR))
            {
              v31 = *(_QWORD *)(v6 + 8);
              *(_DWORD *)buf = 136315906;
              *(_QWORD *)&buf[4] = v26;
              v38 = 2080;
              v39 = "_VCAudioPowerSpectrumMeter_AddStream";
              v40 = 1024;
              v41 = 155;
              v42 = 1024;
              *(_DWORD *)v43 = v31;
              _os_log_error_impl(&dword_1D8A54000, v27, OS_LOG_TYPE_ERROR, " [%s] %s:%d error VCAudioPowerSpectrum already exists for streamToken[%d]", buf, 0x22u);
            }
          }
          break;
        default:
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            v24 = VRTraceErrorLogLevelToCSTR();
            v25 = *v7;
            if (os_log_type_enabled(*v7, OS_LOG_TYPE_ERROR))
            {
              v30 = *(_DWORD *)(v6 + 76);
              *(_DWORD *)buf = 136315906;
              *(_QWORD *)&buf[4] = v24;
              v38 = 2080;
              v39 = "_VCAudioPowerSpectrumMeter_ProcessEventQueue";
              v40 = 1024;
              v41 = 194;
              v42 = 1024;
              *(_DWORD *)v43 = v30;
              _os_log_error_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_ERROR, " [%s] %s:%d Invalid operation: %d", buf, 0x22u);
            }
          }
          v19 = &v35;
          goto LABEL_28;
      }
      v19 = (const void **)&v36;
LABEL_28:
      _VCAudioPowerSpectrumMeter_FreeStream((_QWORD **)v19);
LABEL_29:
      result = CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 32));
      v6 = (uint64_t)result;
      v35 = result;
    }
    while (result);
  }
  return result;
}

void _VCAudioPowerSpectrumMeter_FreeStream(_QWORD **a1)
{
  _QWORD *v1;
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;

  v1 = *a1;
  *a1 = 0;
  if (v1)
  {
    v2 = (const void *)v1[1];
    if (v2)
      CFRelease(v2);
    v3 = (const void *)v1[2];
    if (v3)
      CFRelease(v3);
    v4 = (const void *)v1[5];
    if (v4)
      CFRelease(v4);
    v5 = (const void *)v1[7];
    if (v5)
      CFRelease(v5);
    v6 = (const void *)v1[8];
    if (v6)
      CFRelease(v6);
    free(v1);
  }
}

void VCAudioPowerSpectrumMeter_ProcessOutput(uint64_t a1, uint64_t a2)
{
  unsigned __int8 *v4;
  unsigned __int8 v5;
  double HostTime;
  uint64_t *v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  uint64_t *v14;
  int v15;
  unsigned __int16 v16;
  unsigned __int16 v17;
  unsigned int i;
  BOOL v19;
  void *v20;
  int v21;
  _QWORD v22[2];

  v22[1] = *MEMORY[0x1E0C80C00];
  v4 = (unsigned __int8 *)(a1 + 56);
  do
    v5 = __ldaxr(v4);
  while (__stlxr(1u, v4));
  if ((v5 & 1) == 0)
  {
    _VCAudioPowerSpectrumMeter_ProcessEventQueue(a1, 1);
    HostTime = VCAudioBufferList_GetHostTime(a2);
    if (HostTime - *(double *)(a1 + 64) >= 0.0)
    {
      v7 = *(uint64_t **)a1;
      if (*(_QWORD *)a1)
      {
        do
        {
          if (*((_BYTE *)v7 + 72))
            VCAudioPowerSpectrum_LogHealth(v7[6]);
          v7 = (uint64_t *)*v7;
        }
        while (v7);
      }
      *(double *)(a1 + 64) = HostTime + 5.0;
    }
    v8 = VCAudioBufferList_GetHostTime(a2);
    v9 = *(double *)(a1 + 40);
    if (v8 - v9 >= 0.0)
    {
      v10 = *(double *)(a1 + 48);
      v11 = v9 + v10;
      v12 = v8 + v10;
      v13 = v11 <= v8 ? v12 : v11;
      *(double *)(a1 + 40) = v13;
      v14 = *(uint64_t **)a1;
      if (*(_QWORD *)a1)
      {
        v15 = 0;
        do
        {
          v16 = VCAudioPowerSpectrum_ChannelCount(v14[6]);
          if (v16)
          {
            v17 = v16;
            if (!*((_BYTE *)v14 + 72))
            {
              CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 72), (const void *)v14[2], (const void *)v14[8]);
              *((_BYTE *)v14 + 72) = 1;
            }
            ++v15;
            objc_msgSend((id)v14[8], "checkNumChannels:", v17);
            for (i = 0; i != v17; ++i)
            {
              v22[0] = 0xAAAAAAAAAAAAAAAALL;
              v21 = -1431655766;
              VCAudioPowerSpectrum_GetFrequencyBins(v14[6], v22, &v21, i);
              if (v22[0])
                v19 = v21 == 0;
              else
                v19 = 1;
              if (!v19)
                objc_msgSend((id)v14[8], "applyChannelBins:binCount:channelID:");
            }
          }
          v14 = (uint64_t *)*v14;
        }
        while (v14);
        if (v15)
        {
          v20 = (void *)MEMORY[0x1DF086F1C](a1 + 80);
          objc_msgSend(v20, "audioPowerSpectrumMeter:didUpdateAudioPowerSpectrums:", *(_QWORD *)(a1 + 88), *(_QWORD *)(a1 + 72));
          if (v20)
            CFRelease(v20);
        }
      }
    }
    atomic_store(0, v4);
  }
}

void sub_1D8C2E3DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1D8C2E514(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t VCTimescaleInterface_InitializeWSOLA(uint64_t a1, unsigned int a2, uint64_t a3, int a4, char a5)
{
  VCTimescaleWSOLAClass **v7;
  uint64_t v8;
  int ErrorLogLevelForModule;
  uint64_t v10;
  NSObject *v11;
  int v12;
  int v13;
  uint64_t v14;
  NSObject *v15;
  int v17;
  uint64_t v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  unsigned int v24;
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v7 = (VCTimescaleWSOLAClass **)(a1 + 8);
  v8 = VCTimescaleWSOLA_Initialize(a1 + 8, a2, a3, a4, a5);
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if ((v8 & 0x80000000) != 0)
  {
    if (ErrorLogLevelForModule >= 7)
    {
      v14 = VRTraceErrorLogLevelToCSTR();
      v15 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v17 = 136315650;
        v18 = v14;
        v19 = 2080;
        v20 = "VCTimescaleInterface_InitializeWSOLA";
        v21 = 1024;
        v22 = 20;
        _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d WSOLA initialization failed", (uint8_t *)&v17, 0x1Cu);
      }
    }
    VCTimescaleWSOLA_Finalize(v7);
  }
  else if (ErrorLogLevelForModule >= 7)
  {
    v10 = VRTraceErrorLogLevelToCSTR();
    v11 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v12 = *(unsigned __int16 *)(a1 + 11578);
      v13 = *(unsigned __int16 *)(a1 + 11576);
      v17 = 136316418;
      v18 = v10;
      v19 = 2080;
      v20 = "VCTimescaleInterface_InitializeWSOLA";
      v21 = 1024;
      v22 = 18;
      v23 = 1024;
      v24 = a2;
      v25 = 1024;
      v26 = v12;
      v27 = 1024;
      v28 = v13;
      _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d WSOLA is enabled, Sample Rate = %d, Warp Frame Size = %d, Extended Buffer Size = %d", (uint8_t *)&v17, 0x2Eu);
    }
  }
  return v8;
}

uint64_t VCTimescaleInterface_InitializePSOLA(uint64_t a1, int a2, unsigned int a3, uint64_t a4, char a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  int v11;
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  VCTimescalePSOLA_DSPInit(a1 + 8, (unsigned __int16)a2, a3, a5, *(unsigned __int8 *)(a1 + 34700), *(_DWORD *)a1);
  v7 = v6;
  if ((v6 & 0x80000000) == 0 && (int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v8 = VRTraceErrorLogLevelToCSTR();
    v9 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v11 = 136315906;
      v12 = v8;
      v13 = 2080;
      v14 = "VCTimescaleInterface_InitializePSOLA";
      v15 = 1024;
      v16 = 29;
      v17 = 1024;
      v18 = a2;
      _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d PSOLA is enabled, Sample Rate = %d, ", (uint8_t *)&v11, 0x22u);
    }
  }
  return v7;
}

OpaqueAudioConverter *VCTimescaleInterface_FinalizeWSOLA(uint64_t a1)
{
  return VCTimescaleWSOLA_Finalize((VCTimescaleWSOLAClass **)(a1 + 8));
}

uint64_t VCTimescaleInterface_GetTailSizeWSOLA(uint64_t a1)
{
  uint64_t v1;
  _BYTE __dst[11616];
  uint64_t v4;

  v1 = MEMORY[0x1E0C80A78](a1);
  v4 = *MEMORY[0x1E0C80C00];
  memcpy(__dst, (const void *)(v1 + 8), sizeof(__dst));
  return VCTimescaleWSOLA_TailSize((uint64_t)__dst);
}

uint64_t VCTimescaleInterface_CheckCompressionWSOLA(uint64_t a1, int a2, int a3, int a4, double a5)
{
  return VCTimescaleWSOLA_CheckCompression(a1 + 8, a2, a3, a4, a5);
}

uint64_t VCTimescaleInterface_ActiveSpeechAdaptWSOLA(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 152) = 0;
  return VCTimescaleWSOLA_ActiveSpeechAdapt(a1 + 8, a2);
}

uint64_t VCTimescaleInterface_ActiveSpeechAdaptPSOLA(uint64_t a1, uint64_t a2, double a3)
{
  *(_BYTE *)(a2 + 152) = 0;
  if (*(_DWORD *)(a2 + 4) && !*(_BYTE *)(a2 + 168))
    return VCTimescalePSOLA_ActiveSpeechAdapt(a1 + 8, a2, a3);
  VCTimescalePSOLA_IncFrameScaledGapCount(a1 + 8);
  return 0;
}

void *VCTimescaleInterface_UpdateHistoryBufferWSOLA(uint64_t a1, uint64_t a2)
{
  return VCTimescaleWSOLA_UpdateHistoryBuffer(a1 + 8, a2);
}

void VCTimescaleInterface_UpdateHistoryBufferPSOLA(uint64_t a1, uint64_t a2)
{
  VCTimescalePSOLA_UpdateHistoryBuffer((unsigned __int8 *)(a1 + 8), a2);
}

BOOL VCTimescaleInterface_CheckCompressionPSOLA(uint64_t a1, uint64_t a2, int a3, int a4)
{
  return VCTimescalePSOLA_CheckCompressionPSOLA(a1 + 8, a3, a4);
}

uint64_t VCTimescaleInterface_TailExtractAvailableWSOLA(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 16);
}

uint64_t VCTimescaleInterface_GetWarpFrameSizeWSOLA(uint64_t a1, double a2)
{
  if (a2 <= 0.0)
    return 0;
  else
    return *(unsigned __int16 *)(a1 + 11578);
}

uint64_t VCTimescaleInterface_GetWarpFrameSizePSOLA(uint64_t a1, double a2, double a3)
{
  double *v3;
  double v4;

  v3 = (double *)(a1 + 34680);
  LOWORD(a3) = *(_WORD *)(a1 + 10);
  v4 = (double)*(unint64_t *)&a3;
  if (a2 <= 0.0)
    v3 = (double *)(a1 + 34688);
  return (int)(*v3 * v4);
}

uint64_t ParseMessage(_QWORD *a1, char *a2)
{
  __int128 v4;
  _DWORD *v5;
  _DWORD *v6;
  char *v7;
  char *v8;
  int v9;
  char *v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  NSObject *v21;
  const char *v22;
  uint64_t v23;
  NSObject *v24;
  uint64_t v25;
  NSObject *v26;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  NSObject *v33;
  uint32_t v34;
  uint64_t v35;
  NSObject *v36;
  const char *v37;
  char *v38;
  int v39;
  int StatusCode;
  char *v41;
  char *v42;
  char *v43;
  int v44;
  int v45;
  char *v46;
  uint64_t v47;
  uint64_t v48;
  NSObject *v49;
  int v50;
  char *__s2;
  char __s[16];
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  uint8_t buf[4];
  uint64_t v69;
  __int16 v70;
  const char *v71;
  __int16 v72;
  int v73;
  __int16 v74;
  int v75;
  __int16 v76;
  _BYTE v77[14];
  uint64_t v78;

  v78 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v66 = v4;
  v67 = v4;
  v64 = v4;
  v65 = v4;
  v62 = v4;
  v63 = v4;
  v60 = v4;
  v61 = v4;
  v58 = v4;
  v59 = v4;
  v56 = v4;
  v57 = v4;
  v54 = v4;
  v55 = v4;
  *(_OWORD *)__s = v4;
  v53 = v4;
  __s2 = (char *)0xAAAAAAAAAAAAAAAALL;
  v50 = -1431655766;
  v5 = malloc_type_calloc(1uLL, 0x400uLL, 0x10B2040CFE7BBC5uLL);
  if (v5)
  {
    v6 = v5;
    v7 = strstr(a2, "\r\n");
    if (v7)
    {
      v8 = v7 + 2;
      if (a2)
      {
        if ((int)v7 - (int)a2 >= 255)
          v9 = 255;
        else
          v9 = (_DWORD)v7 - (_DWORD)a2;
        __strncpy_chk();
        __s[v9] = 0;
        if (*(_DWORD *)__s == 793790803)
        {
          v6[1] = 2;
          v28 = strchr(__s, 32);
          if (v28)
          {
            *v28 = 0;
            if (*(_QWORD *)__s == 0x302E322F504953)
            {
              v37 = v28 + 1;
              v38 = strchr(v28 + 1, 32);
              if (v38)
              {
                *v38 = 0;
                v39 = atoi(v37);
                StatusCode = GetStatusCode(v39);
                v6[2] = StatusCode;
                if (!StatusCode)
                {
                  v19 = 2148139039;
                  if ((int)VRTraceGetErrorLogLevelForModule() < 5)
                    goto LABEL_30;
                  v48 = VRTraceErrorLogLevelToCSTR();
                  v49 = *MEMORY[0x1E0CF2758];
                  if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                    goto LABEL_30;
                  *(_DWORD *)buf = 136316418;
                  v69 = v48;
                  v70 = 2080;
                  v71 = "ParseStatusLine";
                  v72 = 1024;
                  v73 = 123;
                  v74 = 1024;
                  v75 = 123;
                  v76 = 1024;
                  *(_DWORD *)v77 = v39;
                  *(_WORD *)&v77[4] = 2080;
                  *(_QWORD *)&v77[6] = v37;
                  v22 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/S"
                        "IP/SipParse.c:%d: Invalid status code(%d[%s])";
                  v33 = v49;
                  v34 = 50;
                  goto LABEL_47;
                }
                __strlcpy_chk();
LABEL_54:
                v41 = strstr(v8, "\r\n");
                if (v41)
                {
                  v42 = v41 + 2;
                  do
                  {
                    v43 = v42;
                    v44 = (_DWORD)v42 - (_DWORD)v8 - 2;
                    if (v44 >= 255)
                      v45 = 255;
                    else
                      v45 = v44;
                    __strncpy_chk();
                    __s[v45] = 0;
                    if ((ParseHeader(&__s2, (unsigned int *)&v50, __s, 0) & 0x80000000) == 0 && __s2)
                      AssignHeader((uint64_t)v6, v50, __s2);
                    v46 = strstr(v43, "\r\n");
                    v42 = v46 + 2;
                    if (!v46)
                      break;
                    LODWORD(v8) = (_DWORD)v43;
                  }
                  while (v43);
                }
                v19 = 0;
                *a1 = v6;
                return v19;
              }
              v19 = 2148139039;
              if ((int)VRTraceGetErrorLogLevelForModule() < 5)
                goto LABEL_30;
              v47 = VRTraceErrorLogLevelToCSTR();
              v21 = *MEMORY[0x1E0CF2758];
              if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                goto LABEL_30;
              *(_DWORD *)buf = 136316162;
              v69 = v47;
              v70 = 2080;
              v71 = "ParseStatusLine";
              v72 = 1024;
              v73 = 116;
              v74 = 1024;
              v75 = 116;
              v76 = 2080;
              *(_QWORD *)v77 = __s;
              v22 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/S"
                    "ipParse.c:%d: No status code found in Status-Line[%s]";
            }
            else
            {
              v19 = 2148139039;
              if ((int)VRTraceGetErrorLogLevelForModule() < 5)
                goto LABEL_30;
              v29 = VRTraceErrorLogLevelToCSTR();
              v21 = *MEMORY[0x1E0CF2758];
              if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                goto LABEL_30;
              *(_DWORD *)buf = 136316162;
              v69 = v29;
              v70 = 2080;
              v71 = "ParseStatusLine";
              v72 = 1024;
              v73 = 107;
              v74 = 1024;
              v75 = 107;
              v76 = 2080;
              *(_QWORD *)v77 = __s;
              v22 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/S"
                    "ipParse.c:%d: Invalid SIP version in Status-Line[%s]";
            }
          }
          else
          {
            v19 = 2148139039;
            if ((int)VRTraceGetErrorLogLevelForModule() < 5)
              goto LABEL_30;
            v32 = VRTraceErrorLogLevelToCSTR();
            v21 = *MEMORY[0x1E0CF2758];
            if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              goto LABEL_30;
            *(_DWORD *)buf = 136316162;
            v69 = v32;
            v70 = 2080;
            v71 = "ParseStatusLine";
            v72 = 1024;
            v73 = 102;
            v74 = 1024;
            v75 = 102;
            v76 = 2080;
            *(_QWORD *)v77 = __s;
            v22 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/Sip"
                  "Parse.c:%d: No SIP Version found in Status-Line[%s]";
          }
        }
        else
        {
          v6[1] = 1;
          v10 = strchr(__s, 32);
          if (v10)
          {
            v11 = v10;
            *v10 = 0;
            v12 = 1;
            while (strcmp(__s, g_apszMethods[v12]))
            {
              if (++v12 == 12)
              {
                if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
                {
                  v13 = VRTraceErrorLogLevelToCSTR();
                  v14 = *MEMORY[0x1E0CF2758];
                  LODWORD(v12) = 0;
                  if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                    break;
                  *(_DWORD *)buf = 136316162;
                  v69 = v13;
                  v70 = 2080;
                  v71 = "ParseRequestLine";
                  v72 = 1024;
                  v73 = 66;
                  v74 = 1024;
                  v75 = 66;
                  v76 = 2080;
                  *(_QWORD *)v77 = __s;
                  _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SipParse.c:%d: Extension Method is not supported[%s]", buf, 0x2Cu);
                }
                LODWORD(v12) = 0;
                break;
              }
            }
            v6[2] = v12;
            v15 = v11 + 1;
            v16 = strchr(v15, 32);
            if (v16)
            {
              v17 = v16;
              *v16 = 0;
              v18 = ParseSipUri((uint64_t)(v6 + 3), v15);
              if ((v18 & 0x80000000) != 0)
              {
                v19 = v18;
                if ((int)VRTraceGetErrorLogLevelForModule() < 5)
                  goto LABEL_30;
                v35 = VRTraceErrorLogLevelToCSTR();
                v36 = *MEMORY[0x1E0CF2758];
                if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                  goto LABEL_30;
                *(_DWORD *)buf = 136316162;
                v69 = v35;
                v70 = 2080;
                v71 = "ParseRequestLine";
                v72 = 1024;
                v73 = 81;
                v74 = 1024;
                v75 = 81;
                v76 = 1024;
                *(_DWORD *)v77 = v19;
                v22 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP"
                      "/SipParse.c:%d: ParseSipUri failed(%08X)";
                v33 = v36;
                v34 = 40;
                goto LABEL_47;
              }
              if (strncmp(v17 + 1, "SIP/2.0", 7uLL))
              {
                v19 = 2148139039;
                if ((int)VRTraceGetErrorLogLevelForModule() < 5)
                  goto LABEL_30;
                v20 = VRTraceErrorLogLevelToCSTR();
                v21 = *MEMORY[0x1E0CF2758];
                if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                  goto LABEL_30;
                *(_DWORD *)buf = 136316162;
                v69 = v20;
                v70 = 2080;
                v71 = "ParseRequestLine";
                v72 = 1024;
                v73 = 87;
                v74 = 1024;
                v75 = 87;
                v76 = 2080;
                *(_QWORD *)v77 = __s;
                v22 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP"
                      "/SipParse.c:%d: Invalid SIP version in Request-Line[%s]";
                goto LABEL_46;
              }
              goto LABEL_54;
            }
            v19 = 2148139039;
            if ((int)VRTraceGetErrorLogLevelForModule() < 5)
              goto LABEL_30;
            v31 = VRTraceErrorLogLevelToCSTR();
            v21 = *MEMORY[0x1E0CF2758];
            if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              goto LABEL_30;
            *(_DWORD *)buf = 136316162;
            v69 = v31;
            v70 = 2080;
            v71 = "ParseRequestLine";
            v72 = 1024;
            v73 = 75;
            v74 = 1024;
            v75 = 75;
            v76 = 2080;
            *(_QWORD *)v77 = __s;
            v22 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/Sip"
                  "Parse.c:%d: No RequestURI found in Request-Line[%s]";
          }
          else
          {
            v19 = 2148139039;
            if ((int)VRTraceGetErrorLogLevelForModule() < 5)
              goto LABEL_30;
            v30 = VRTraceErrorLogLevelToCSTR();
            v21 = *MEMORY[0x1E0CF2758];
            if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              goto LABEL_30;
            *(_DWORD *)buf = 136316162;
            v69 = v30;
            v70 = 2080;
            v71 = "ParseRequestLine";
            v72 = 1024;
            v73 = 54;
            v74 = 1024;
            v75 = 54;
            v76 = 2080;
            *(_QWORD *)v77 = __s;
            v22 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/Sip"
                  "Parse.c:%d: No Method found in Request-Line[%s]";
          }
        }
LABEL_46:
        v33 = v21;
        v34 = 44;
LABEL_47:
        _os_log_impl(&dword_1D8A54000, v33, OS_LOG_TYPE_DEFAULT, v22, buf, v34);
LABEL_30:
        free(v6);
        return v19;
      }
      a2 = v7 + 2;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v25 = VRTraceErrorLogLevelToCSTR();
      v26 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136316162;
        v69 = v25;
        v70 = 2080;
        v71 = "ParseMessage";
        v72 = 1024;
        v73 = 150;
        v74 = 1024;
        v75 = 150;
        v76 = 2080;
        *(_QWORD *)v77 = a2;
        _os_log_impl(&dword_1D8A54000, v26, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SipParse.c:%d: No Topline found in the message[%s]", buf, 0x2Cu);
      }
    }
    v19 = 2148139039;
    goto LABEL_30;
  }
  v19 = 2148139011;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v23 = VRTraceErrorLogLevelToCSTR();
    v24 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      ParseMessage_cold_1(v23, v24);
  }
  return v19;
}

char *VCGetSystemBuildVersionString(char *a1, CFIndex a2)
{
  const __CFString *v4;
  const __CFString *v5;
  CFTypeID v6;

  v4 = (const __CFString *)MGCopyAnswer();
  if (v4)
  {
    v5 = v4;
    v6 = CFGetTypeID(v4);
    if (v6 == CFStringGetTypeID())
      CFStringGetCString(v5, a1, a2, 0x8000100u);
    CFRelease(v5);
  }
  return a1;
}

char *VCGetDeviceModelString(char *a1, size_t a2)
{
  __int128 v4;
  size_t v5;
  size_t v7;
  size_t __n;
  char __source;
  __int128 v10;
  __int128 v11;
  _BYTE v12[31];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v12[15] = v4;
  *(_OWORD *)v12 = v4;
  v11 = v4;
  v10 = v4;
  __source = 0;
  __n = 63;
  if (sysctlbyname("hw.machine", &__source, &__n, 0, 0)
    || (v7 = __n, !memchr(&__source, 44, __n))
    || strnstr(&__source, "iProd", v7))
  {
    v5 = 0;
    __n = 0;
  }
  else
  {
    v5 = __n;
  }
  *(&__source + v5) = 0;
  strlcpy(a1, &__source, a2);
  return a1;
}

CFTypeRef VCGetSerialNumber()
{
  mach_port_t v0;
  const __CFDictionary *v1;
  io_service_t MatchingService;
  io_object_t v3;
  CFTypeRef CFProperty;

  if (!VRTraceIsInternalOSInstalled())
    return 0;
  v0 = *MEMORY[0x1E0CBBAB8];
  v1 = IOServiceMatching("IOPlatformExpertDevice");
  MatchingService = IOServiceGetMatchingService(v0, v1);
  if (!MatchingService)
    return 0;
  v3 = MatchingService;
  CFProperty = IORegistryEntryCreateCFProperty(MatchingService, CFSTR("IOPlatformSerialNumber"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  IOObjectRelease(v3);
  if (CFProperty)
    CFAutorelease(CFProperty);
  return CFProperty;
}

const __CFString *VCCopyDeviceName()
{
  const __CFString *v0;
  const __CFString *v1;
  CFTypeID v2;
  CFTypeID v3;
  uint64_t v4;
  NSObject *v5;
  int v7;
  uint64_t v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  int v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v0 = (const __CFString *)MGCopyAnswer();
  if (!v0)
  {
LABEL_4:
    v1 = (const __CFString *)MGCopyAnswer();
    if (!v1)
      goto LABEL_7;
    goto LABEL_5;
  }
  v1 = v0;
  v2 = CFGetTypeID(v0);
  if (v2 != CFStringGetTypeID())
  {
    CFRelease(v1);
    goto LABEL_4;
  }
LABEL_5:
  v3 = CFGetTypeID(v1);
  if (v3 == CFStringGetTypeID())
    return v1;
  CFRelease(v1);
LABEL_7:
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v7 = 136315650;
      v8 = v4;
      v9 = 2080;
      v10 = "VCCopyDeviceName";
      v11 = 1024;
      v12 = 120;
      _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d No device name found, returning empty string", (uint8_t *)&v7, 0x1Cu);
    }
  }
  v1 = &stru_1E9E58EE0;
  CFRetain(&stru_1E9E58EE0);
  return v1;
}

BOOL VCAudioSession_IsDeferredNetworkUplinkClockUpdateSupported(_BOOL8 result)
{
  if (result)
    return *(_BYTE *)(result + 266) && *(_BYTE *)(result + 265) != 0;
  return result;
}

void VCAudioSession_ScheduleNetworkUplinkClockUpdate(uint64_t a1)
{
  int v2;

  v2 = VCFeatureFlagManager_UseAvconferencedOniOSSpecficFeatures();
  if (a1 && v2)
  {
    if (*(_BYTE *)(a1 + 266))
      VCAudioSessionAVAS_ScheduleNetworkUplinkClockUpdate(a1);
  }
}

uint64_t VCWRMHandler_ShouldForceWRMRecommendationUsingUserDefaults(uint64_t a1)
{
  int v2;
  int v3;
  uint64_t result;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  _BOOL4 v9;
  int v10;
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v7 = VRTraceErrorLogLevelToCSTR();
      v8 = *MEMORY[0x1E0CF2758];
      v9 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
      result = 0;
      if (!v9)
        return result;
      v10 = 136315650;
      v11 = v7;
      v12 = 2080;
      v13 = "VCWRMHandler_ShouldForceWRMRecommendationUsingUserDefaults";
      v14 = 1024;
      v15 = 39;
      _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v10, 0x1Cu);
    }
    return 0;
  }
  v2 = -[VCDefaults localWRMLinkType](+[VCDefaults sharedInstance](VCDefaults, "sharedInstance"), "localWRMLinkType");
  if (v2 < 0)
    return 0;
  v3 = v2;
  if (*(_DWORD *)(a1 + 8) == v2)
    return 0;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v5 = VRTraceErrorLogLevelToCSTR();
    v6 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v10 = 136315906;
      v11 = v5;
      v12 = 2080;
      v13 = "VCWRMHandler_ShouldForceWRMRecommendationUsingUserDefaults";
      v14 = 1024;
      v15 = 42;
      v16 = 1024;
      v17 = v3;
      _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d HandoverReport: Defaults settings force local iRATSuggestion to be %d", (uint8_t *)&v10, 0x22u);
    }
  }
  *(_DWORD *)(a1 + 8) = v3;
  return 1;
}

uint64_t VCWRMHandler_ShouldRequestWRMNotificationWithDuplicationReason(uint64_t a1, int a2, int a3, char a4, double a5)
{
  int ErrorLogLevelForModule;
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  uint64_t result;
  uint64_t v15;
  NSObject *v16;
  uint64_t v17;
  NSObject *v18;
  _BOOL4 v19;
  int v20;
  uint64_t v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  __int16 v28;
  int v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (!a1)
  {
    if (ErrorLogLevelForModule >= 5)
    {
      v17 = VRTraceErrorLogLevelToCSTR();
      v18 = *MEMORY[0x1E0CF2758];
      v19 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
      result = 0;
      if (!v19)
        return result;
      v20 = 136315650;
      v21 = v17;
      v22 = 2080;
      v23 = "VCWRMHandler_ShouldRequestWRMNotificationWithDuplicationReason";
      v24 = 1024;
      v25 = 52;
      _os_log_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v20, 0x1Cu);
    }
    return 0;
  }
  if (ErrorLogLevelForModule >= 8)
  {
    v11 = VRTraceErrorLogLevelToCSTR();
    v12 = *MEMORY[0x1E0CF2758];
    v13 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        v20 = 136316162;
        v21 = v11;
        v22 = 2080;
        v23 = "VCWRMHandler_ShouldRequestWRMNotificationWithDuplicationReason";
        v24 = 1024;
        v25 = 53;
        v26 = 1024;
        v27 = a2;
        v28 = 1024;
        v29 = a3;
        _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d HandoverReport: dupe state: %d and enableDuplication %d.", (uint8_t *)&v20, 0x28u);
      }
    }
    else if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      v20 = 136316162;
      v21 = v11;
      v22 = 2080;
      v23 = "VCWRMHandler_ShouldRequestWRMNotificationWithDuplicationReason";
      v24 = 1024;
      v25 = 53;
      v26 = 1024;
      v27 = a2;
      v28 = 1024;
      v29 = a3;
      _os_log_debug_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEBUG, " [%s] %s:%d HandoverReport: dupe state: %d and enableDuplication %d.", (uint8_t *)&v20, 0x28u);
    }
  }
  if ((a2 - 1) <= 1)
  {
    result = 0;
    *(double *)(a1 + 32) = a5;
    return result;
  }
  result = 0;
  if (a2 == 3 && (a4 & 1) == 0)
  {
    if (a5 - *(double *)(a1 + 32) > 20.0 && a5 - *(double *)(a1 + 40) > 60.0)
    {
      *(double *)(a1 + 40) = a5;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v15 = VRTraceErrorLogLevelToCSTR();
        v16 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v20 = 136315650;
          v21 = v15;
          v22 = 2080;
          v23 = "VCWRMHandler_ShouldRequestWRMNotificationWithDuplicationReason";
          v24 = 1024;
          v25 = 64;
          _os_log_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d HandoverReport: actively request for the latest iRAT recommendation from WRM.", (uint8_t *)&v20, 0x1Cu);
        }
      }
      return 1;
    }
    return 0;
  }
  return result;
}

void VCWRMHandler_UpdateWRMNotificationRequestTime(uint64_t a1, double a2)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    *(double *)(a1 + 40) = a2;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136315650;
      v5 = v2;
      v6 = 2080;
      v7 = "VCWRMHandler_UpdateWRMNotificationRequestTime";
      v8 = 1024;
      v9 = 73;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v4, 0x1Cu);
    }
  }
}

uint64_t VCWRMHandler_ProcessLocalWRMNotification(uint64_t a1, _DWORD *a2, int a3)
{
  unsigned int v3;
  uint64_t result;
  int v6;
  uint64_t v7;
  NSObject *v8;
  int v9;
  const char *v10;
  uint64_t v11;
  NSObject *v12;
  _BOOL4 v13;
  int v14;
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  const char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v11 = VRTraceErrorLogLevelToCSTR();
      v12 = *MEMORY[0x1E0CF2758];
      v13 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
      result = 0;
      if (!v13)
        return result;
      v14 = 136315650;
      v15 = v11;
      v16 = 2080;
      v17 = "VCWRMHandler_ProcessLocalWRMNotification";
      v18 = 1024;
      v19 = 81;
      _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v14, 0x1Cu);
    }
    return 0;
  }
  if (!a2)
    return 0;
  v3 = a2[1];
  if (v3 > 1 || (*a2 - 1) > 1)
    return 0;
  result = 1;
  if (a3)
    v6 = 2;
  else
    v6 = 1;
  if (*a2 != v6)
  {
    if (*(_DWORD *)(a1 + 8) != v3)
    {
      *(_DWORD *)(a1 + 8) = v3;
      *(double *)(a1 + 24) = micro();
      if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
      {
        v7 = VRTraceErrorLogLevelToCSTR();
        v8 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v9 = *(_DWORD *)(a1 + 8);
          v14 = 136315906;
          if (v9)
            v10 = "WiFi";
          else
            v10 = "Cellular";
          v15 = v7;
          v16 = 2080;
          v17 = "VCWRMHandler_ProcessLocalWRMNotification";
          v18 = 1024;
          v19 = 99;
          v20 = 2080;
          v21 = v10;
          _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d HandoverReport: Receive and cache local iRAT suggestion to %s.", (uint8_t *)&v14, 0x26u);
        }
      }
    }
    return 2;
  }
  return result;
}

uint64_t _VCJBTargetEstimatorSynchronizer_Configure(_OWORD *a1, _OWORD *a2)
{
  uint64_t v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;

  if (*(_DWORD *)a2 >= 4u)
  {
    v2 = 2151874561;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCJBTargetEstimatorSynchronizer_Configure_cold_1();
    }
  }
  else
  {
    v2 = 0;
    a1[22] = *a2;
    v3 = a2[1];
    v4 = a2[2];
    v5 = a2[4];
    a1[25] = a2[3];
    a1[26] = v5;
    a1[23] = v3;
    a1[24] = v4;
    v6 = a2[5];
    v7 = a2[6];
    v8 = a2[8];
    a1[29] = a2[7];
    a1[30] = v8;
    a1[27] = v6;
    a1[28] = v7;
    v9 = a2[9];
    v10 = a2[10];
    v11 = a2[11];
    *(_OWORD *)((char *)a1 + 540) = *(_OWORD *)((char *)a2 + 188);
    a1[32] = v10;
    a1[33] = v11;
    a1[31] = v9;
  }
  return v2;
}

uint64_t _VCJBTargetEstimatorSynchronizer_StoreCurrentSize(uint64_t a1, unsigned int a2, float a3, double a4)
{
  signed int v5;
  unint64_t v6;
  unint64_t *v7;
  uint64_t v9;
  uint64_t v11;
  NSObject *v12;
  signed int v13;
  uint8_t buf[4];
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  unsigned int v21;
  __int16 v22;
  signed int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v5 = atomic_load((unsigned int *)(a1 + 344));
  if (v5 <= (int)a2)
  {
    v9 = 2151874581;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v13 = v5;
      v11 = VRTraceErrorLogLevelToCSTR();
      v12 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136316162;
        v15 = v11;
        v16 = 2080;
        v17 = "_VCJBTargetEstimatorSynchronizer_StoreCurrentSize";
        v18 = 1024;
        v19 = 143;
        v20 = 1024;
        v21 = a2;
        v22 = 1024;
        v23 = v13;
        _os_log_error_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_ERROR, " [%s] %s:%d Invalid clientID clientID=%d currentClientID=%d", buf, 0x28u);
      }
    }
  }
  else
  {
    v6 = a1 + 96;
    v7 = (unint64_t *)(a1 + 96 + 24 * a2);
    if ((unint64_t)v7 >= a1 + 336 || (unint64_t)v7 < v6)
      __break(0x5519u);
    v9 = 0;
    atomic_store((uint64_t)(a3 * 100000.0), v7);
    atomic_store((uint64_t)(a4 * 100000.0), (unint64_t *)(v6 + 24 * a2 + 8));
  }
  return v9;
}

uint64_t _VCJBTargetEstimatorSynchronizerClassRegister(uint64_t *a1)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

uint64_t VCJBTargetEstimatorSynchronizer_Create(uint64_t a1, uint64_t *a2, _OWORD *a3)
{
  uint64_t Instance;
  int ErrorLogLevelForModule;
  uint64_t v7;
  NSObject *v8;
  int v9;
  uint64_t v10;
  int64x2_t v11;
  uint64_t v12;
  int v14;
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  int v23;
  __int16 v24;
  char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (a3)
    {
      if (VCJBTargetEstimatorSynchronizerGetTypeID_initOnce != -1)
        dispatch_once_f(&VCJBTargetEstimatorSynchronizerGetTypeID_initOnce, &VCJBTargetEstimatorSynchronizerGetTypeID_typeID, (dispatch_function_t)_VCJBTargetEstimatorSynchronizerClassRegister);
      Instance = _CFRuntimeCreateInstance();
      ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
      if (Instance)
      {
        if (ErrorLogLevelForModule >= 7)
        {
          v7 = VRTraceErrorLogLevelToCSTR();
          v8 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v9 = *(_DWORD *)a3;
            v14 = 136316418;
            v15 = v7;
            v16 = 2080;
            v17 = "VCJBTargetEstimatorSynchronizer_Create";
            v18 = 1024;
            v19 = 286;
            v20 = 2048;
            v21 = Instance;
            v22 = 1024;
            v23 = v9;
            v24 = 2080;
            v25 = (char *)a3 + 4;
            _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d targetSynchronizer[%p] config.policy=%d dumpNamePrefix=%s", (uint8_t *)&v14, 0x36u);
          }
        }
        v10 = 96;
        v11 = vdupq_n_s64(0x8000000000000000);
        do
        {
          *(int64x2_t *)(Instance + v10) = v11;
          v10 += 24;
        }
        while (v10 != 336);
        *(_QWORD *)(Instance + 336) = 0;
        *(_QWORD *)(Instance + 344) = 0;
        pthread_mutex_init((pthread_mutex_t *)(Instance + 32), 0);
        if (_VCJBTargetEstimatorSynchronizer_Configure((_OWORD *)Instance, a3))
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VCJBTargetEstimatorSynchronizer_Create_cold_4();
          }
          v12 = 2151874561;
          CFRelease((CFTypeRef)Instance);
        }
        else
        {
          v12 = 0;
          *a2 = Instance;
        }
      }
      else if (ErrorLogLevelForModule < 3)
      {
        return 2151874563;
      }
      else
      {
        VRTraceErrorLogLevelToCSTR();
        v12 = 2151874563;
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCJBTargetEstimatorSynchronizer_Create_cold_3();
      }
    }
    else
    {
      v12 = 2151874561;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCJBTargetEstimatorSynchronizer_Create_cold_2();
      }
    }
  }
  else
  {
    v12 = 2151874561;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCJBTargetEstimatorSynchronizer_Create_cold_1();
    }
  }
  return v12;
}

uint64_t VCJBTargetEstimatorSynchronizer_RegisterClient(uint64_t a1, _BYTE *a2, int a3)
{
  pthread_mutex_t *v6;
  uint64_t result;
  uint64_t v8;
  unsigned int *v9;
  unint64_t v10;
  _DWORD *v11;
  signed int v12;
  int v13;
  int v14;
  unsigned int v15;
  unint64_t v16;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  NSObject *v21;
  NSObject *v22;
  char *v23;
  uint64_t v24;
  NSObject *v25;
  uint64_t v26;
  char *v27;
  int v28;
  uint64_t v29;
  __int16 v30;
  const char *v31;
  __int16 v32;
  int v33;
  __int16 v34;
  _BYTE v35[14];
  __int16 v36;
  char *v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v6 = (pthread_mutex_t *)(a1 + 32);
    result = pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
    v8 = 0;
    v9 = (unsigned int *)(a1 + 344);
    v10 = a1 + 96;
    v11 = (_DWORD *)(a1 + 112);
    do
    {
      v12 = atomic_load(v9);
      if (v8 >= v12)
        break;
      if (*v11 == a3)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v24 = VRTraceErrorLogLevelToCSTR();
          v25 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v28 = 136316162;
            v29 = v24;
            v30 = 2080;
            v31 = "VCJBTargetEstimatorSynchronizer_RegisterClient";
            v32 = 1024;
            v33 = 310;
            v34 = 2080;
            *(_QWORD *)v35 = FourccToCStr(a3);
            *(_WORD *)&v35[8] = 1024;
            *(_DWORD *)&v35[10] = v8;
            _os_log_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Previously registered client for streamGroupID=%s with currentClientID=%d", (uint8_t *)&v28, 0x2Cu);
          }
        }
        *a2 = v8;
        goto LABEL_32;
      }
      ++v8;
      v11 += 6;
    }
    while (v8 != 10);
    v13 = atomic_load(v9);
    while (1)
    {
      v14 = v13;
      if (v13 > 9)
        break;
      v15 = v13 + 1;
      while (1)
      {
        v13 = __ldaxr(v9);
        if (v13 != v14)
          break;
        if (!__stlxr(v15, v9))
          goto LABEL_13;
      }
      __clrex();
    }
LABEL_13:
    v16 = v10 + 24 * v14;
    if (v16 >= a1 + 336 || v16 < v10)
    {
      __break(0x5519u);
      return result;
    }
    *(_DWORD *)(v10 + 24 * v14 + 16) = a3;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v18 = VRTraceErrorLogLevelToCSTR();
      v19 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v28 = 136316418;
        v29 = v18;
        v30 = 2080;
        v31 = "VCJBTargetEstimatorSynchronizer_RegisterClient";
        v32 = 1024;
        v33 = 326;
        v34 = 2048;
        *(_QWORD *)v35 = a1;
        *(_WORD *)&v35[8] = 1024;
        *(_DWORD *)&v35[10] = v14;
        v36 = 2080;
        v37 = FourccToCStr(a3);
        _os_log_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d targetSynchronizer[%p] currentClientID=%d streamGroupID=%s", (uint8_t *)&v28, 0x36u);
      }
    }
    if ((int)VRTraceGetErrorLogLevelForModule() > 7)
    {
      v20 = VRTraceErrorLogLevelToCSTR();
      v21 = *MEMORY[0x1E0CF2758];
      v22 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          v23 = FourccToCStr(a3);
          v28 = 136316162;
          v29 = v20;
          v30 = 2080;
          v31 = "VCJBTargetEstimatorSynchronizer_RegisterClient";
          v32 = 1024;
          v33 = 329;
          v34 = 1024;
          *(_DWORD *)v35 = v14;
          *(_WORD *)&v35[4] = 2080;
          *(_QWORD *)&v35[6] = v23;
          _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Succesfully registered Client ID currentClientID=%d streamGroupID=%s", (uint8_t *)&v28, 0x2Cu);
        }
      }
      else if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
      {
        v27 = FourccToCStr(a3);
        v28 = 136316162;
        v29 = v20;
        v30 = 2080;
        v31 = "VCJBTargetEstimatorSynchronizer_RegisterClient";
        v32 = 1024;
        v33 = 329;
        v34 = 1024;
        *(_DWORD *)v35 = v14;
        *(_WORD *)&v35[4] = 2080;
        *(_QWORD *)&v35[6] = v27;
        _os_log_debug_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Succesfully registered Client ID currentClientID=%d streamGroupID=%s", (uint8_t *)&v28, 0x2Cu);
      }
    }
    *a2 = v14;
LABEL_32:
    pthread_mutex_unlock(v6);
    return 0;
  }
  else
  {
    v26 = 2151874561;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCJBTargetEstimatorSynchronizer_RegisterClient_cold_1();
    }
  }
  return v26;
}

uint64_t VCJBTargetEstimatorSynchronizer_SetPolicy(uint64_t a1, int a2)
{
  uint64_t v2;

  if (a1)
  {
    v2 = 0;
    *(_DWORD *)(a1 + 352) = a2;
  }
  else
  {
    v2 = 2151874561;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCJBTargetEstimatorSynchronizer_SetPolicy_cold_1();
    }
  }
  return v2;
}

int64_t VCJBTargetEstimatorSynchronizer_GetSyncTarget(uint64_t a1, unsigned int a2, float *a3, float a4, float a5)
{
  double v10;
  int v11;
  int64_t result;
  float v13;
  uint64_t v14;
  float v15;
  int v16;
  uint64_t v17;
  signed int v18;
  unint64_t *v19;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t j;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  NSObject *v34;
  NSObject *v35;
  double v36;
  uint32_t v37;
  __int128 v38;
  size_t v39;
  uint64_t v40;
  NSObject *v41;
  uint64_t v42;
  int i;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  double v50;
  char __str[16];
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  unint64_t v63;
  uint8_t buf[408];
  uint64_t v65;

  v65 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v10 = a5;
    if ((_VCJBTargetEstimatorSynchronizer_StoreCurrentSize(a1, a2, a4, a5) & 0x80000000) != 0)
    {
      v17 = 2151874581;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCJBTargetEstimatorSynchronizer_GetSyncTarget_cold_2();
      }
    }
    else
    {
      v11 = atomic_load((unsigned int *)(a1 + 344));
      if (v11 <= 1)
      {
        *a3 = a4;
      }
      else
      {
        result = (uint64_t)(a4 * 100000.0);
        switch(*(_DWORD *)(a1 + 352))
        {
          case 0:
            goto LABEL_22;
          case 1:
            v13 = (float)result;
            v14 = a1;
            v15 = a5;
            v16 = 1;
            goto LABEL_13;
          case 2:
            v13 = (float)result;
            v14 = a1;
            v15 = a5;
            v16 = 0;
LABEL_13:
            result = _VCJBTargetEstimatorSynchronizer_ApplyPolicy_MinMax(v14, v16, v13, v15);
            goto LABEL_22;
          case 3:
            v18 = atomic_load((unsigned int *)(a1 + 348));
            v19 = (unint64_t *)(a1 + 96 + 24 * v18);
            if ((unint64_t)v19 >= a1 + 336 || (unint64_t)v19 < a1 + 96)
              goto LABEL_55;
            v21 = atomic_load(v19);
            if (v21 == 0x8000000000000000)
              result = (uint64_t)(float)result;
            else
              result = v21;
LABEL_22:
            atomic_store(result, (unint64_t *)(a1 + 336));
            *a3 = (float)result / 100000.0;
            if (!*(_BYTE *)(a1 + 16))
            {
              v37 = arc4random();
              *(_DWORD *)(a1 + 20) = v37;
              v63 = 0xAAAAAAAAAAAAAAAALL;
              *(_QWORD *)&v38 = 0xAAAAAAAAAAAAAAAALL;
              *((_QWORD *)&v38 + 1) = 0xAAAAAAAAAAAAAAAALL;
              v61 = v38;
              v62 = v38;
              v59 = v38;
              v60 = v38;
              v57 = v38;
              v58 = v38;
              v55 = v38;
              v56 = v38;
              v53 = v38;
              v54 = v38;
              *(_OWORD *)__str = v38;
              v52 = v38;
              snprintf(__str, 0xC8uLL, "%010u-%s", v37, (const char *)(a1 + 356));
              v39 = VCBoundsSafety_IndexableToNulTerminated(__str, 0xC8uLL);
              *(_QWORD *)(a1 + 24) = LogDump_OpenLog(v39, (uint64_t)"avconference", (uint64_t)".jbsyncdump", (char)"", 9, (char)"");
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v40 = VRTraceErrorLogLevelToCSTR();
                v41 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                {
                  v42 = *(_QWORD *)(a1 + 24);
                  *(_DWORD *)buf = 136316418;
                  *(_QWORD *)&buf[4] = v40;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = "_VCJBTargetEstimatorSynchronizer_CheckIfDumpIsInitialized";
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&buf[24] = 163;
                  *(_WORD *)&buf[28] = 2048;
                  *(_QWORD *)&buf[30] = a1;
                  *(_WORD *)&buf[38] = 2048;
                  *(_QWORD *)&buf[40] = v42;
                  *(_WORD *)&buf[48] = 2080;
                  *(_QWORD *)&buf[50] = __str;
                  _os_log_impl(&dword_1D8A54000, v41, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d synchronizer[%p] _logDump=%p dumpIDString=%s", buf, 0x3Au);
                }
              }
              *(_BYTE *)(a1 + 16) = 1;
              if (*(_QWORD *)(a1 + 24))
              {
                memcpy(buf, "Time\tClientID\tstreamGroupID\t", 0x190uLL);
                for (i = 0; i != 10; __sprintf_chk((char *)buf, 0, 0x190uLL, "%sClient%i\t", (const char *)buf, i++))
                  ;
                __sprintf_chk((char *)buf, 0, 0x190uLL, "%sSyncTarget\t", (const char *)buf);
                VRLogfilePrintSync(*(FILE ***)(a1 + 24), "%s\n", v44, v45, v46, v47, v48, v49, (char)buf);
                if (!*(_BYTE *)(a1 + 16))
                  break;
              }
            }
            if (!*(_QWORD *)(a1 + 24))
              break;
            memset(buf, 0, 400);
            result = __sprintf_chk((char *)buf, 0, 0x190uLL, "%s%d\t", (const char *)buf, a2);
            v22 = a1 + 96;
            v23 = a1 + 96 + 24 * a2;
            if (v23 >= a1 + 336 || v23 < v22)
            {
LABEL_55:
              __break(0x5519u);
              return result;
            }
            __sprintf_chk((char *)buf, 0, 0x190uLL, "%s%d\t", (const char *)buf, *(_DWORD *)(v22 + 24 * a2 + 16));
            for (j = 0; j != 240; j += 24)
            {
              v25 = atomic_load((unint64_t *)(v22 + j));
              if ((float)((float)v25 / 100000.0) >= 0.0)
                __sprintf_chk((char *)buf, 0, 0x190uLL, "%s%.4f\t");
              else
                __sprintf_chk((char *)buf, 0, 0x190uLL, "%s%c\t");
            }
            v26 = atomic_load((unint64_t *)(a1 + 336));
            __sprintf_chk((char *)buf, 0, 0x190uLL, "%s%.4f\t", (const char *)buf, (float)v26 / 100000.0);
            VRLogfilePrintWithTimestamp(*(_QWORD *)(a1 + 24), "%s\n", v27, v28, v29, v30, v31, v32, (char)buf);
            break;
          default:
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                VCJBTargetEstimatorSynchronizer_GetSyncTarget_cold_4();
            }
            v17 = 2151874581;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                VCJBTargetEstimatorSynchronizer_GetSyncTarget_cold_3();
            }
            return v17;
        }
      }
      if ((int)VRTraceGetErrorLogLevelForModule() < 8)
        return 0;
      v33 = VRTraceErrorLogLevelToCSTR();
      v34 = *MEMORY[0x1E0CF2758];
      v35 = *MEMORY[0x1E0CF2758];
      if (!*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
        {
          v50 = *a3;
          *(_DWORD *)buf = 136316930;
          *(_QWORD *)&buf[4] = v33;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "VCJBTargetEstimatorSynchronizer_GetSyncTarget";
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = 384;
          *(_WORD *)&buf[28] = 2048;
          *(_QWORD *)&buf[30] = a1;
          *(_WORD *)&buf[38] = 1024;
          *(_DWORD *)&buf[40] = a2;
          *(_WORD *)&buf[44] = 2048;
          *(double *)&buf[46] = a4;
          *(_WORD *)&buf[54] = 2048;
          *(double *)&buf[56] = v10;
          *(_WORD *)&buf[64] = 2048;
          *(double *)&buf[66] = v50;
          _os_log_debug_impl(&dword_1D8A54000, v34, OS_LOG_TYPE_DEBUG, " [%s] %s:%d targetSynchronizer[%p] clientID=%d currentTargetSize=%4.4f arrivalTime=%4.4f syncTargetSize=%4.4f", buf, 0x4Au);
        }
        return 0;
      }
      v17 = 0;
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
      {
        v36 = *a3;
        *(_DWORD *)buf = 136316930;
        *(_QWORD *)&buf[4] = v33;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "VCJBTargetEstimatorSynchronizer_GetSyncTarget";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 384;
        *(_WORD *)&buf[28] = 2048;
        *(_QWORD *)&buf[30] = a1;
        *(_WORD *)&buf[38] = 1024;
        *(_DWORD *)&buf[40] = a2;
        *(_WORD *)&buf[44] = 2048;
        *(double *)&buf[46] = a4;
        *(_WORD *)&buf[54] = 2048;
        *(double *)&buf[56] = v10;
        *(_WORD *)&buf[64] = 2048;
        *(double *)&buf[66] = v36;
        _os_log_impl(&dword_1D8A54000, v34, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d targetSynchronizer[%p] clientID=%d currentTargetSize=%4.4f arrivalTime=%4.4f syncTargetSize=%4.4f", buf, 0x4Au);
        return 0;
      }
    }
  }
  else
  {
    v17 = 2151874561;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCJBTargetEstimatorSynchronizer_GetSyncTarget_cold_1();
    }
  }
  return v17;
}

void _VCJBTargetEstimatorSynchronizer_Init(uint64_t a1)
{
  bzero((void *)(a1 + 16), 0x220uLL);
}

uint64_t _VCJBTargetEstimatorSynchronizer_Finalize(unint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  int v6;
  uint64_t v7;
  __int16 v8;
  const char *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  unint64_t v13;
  __int16 v14;
  unint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() > 6)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v6 = 136316162;
      v7 = v2;
      v8 = 2080;
      v9 = "_VCJBTargetEstimatorSynchronizer_Finalize";
      v10 = 1024;
      v11 = 73;
      v12 = 2048;
      v13 = a1;
      v14 = 2080;
      v15 = a1 + 356;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d targetSynchronizer[%p] dumpNamePrefix=%s", (uint8_t *)&v6, 0x30u);
    }
  }
  v4 = *(_QWORD *)(a1 + 24);
  if (v4)
  {
    LogDump_CloseLog(v4);
    *(_QWORD *)(a1 + 24) = 0;
  }
  if (a1 + 560 <= a1)
    __break(0x5519u);
  return pthread_mutex_destroy((pthread_mutex_t *)(a1 + 32));
}

uint64_t _VCJBTargetEstimatorSynchronizer_ApplyPolicy_MinMax(uint64_t a1, int a2, float a3, float a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t *v8;
  uint64_t v9;
  const char *v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  double v16;
  uint64_t v17;
  NSObject *v18;
  NSObject *v19;
  int64_t v20;
  int64_t v21;
  _BOOL4 v22;
  int v23;
  uint64_t v24;
  uint64_t v26;
  int64_t v28;
  uint8_t buf[4];
  uint64_t v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  int v34;
  __int16 v35;
  int v36;
  __int16 v37;
  double v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v4 = atomic_load((unsigned int *)(a1 + 344));
  v26 = (uint64_t)a3;
  if ((int)v4 >= 1)
  {
    v5 = 0;
    v6 = 0;
    v7 = a1 + 96;
    v8 = (unint64_t *)(a1 + 336);
    v9 = (uint64_t)(a4 * 100000.0);
    v10 = "";
    v11 = (unint64_t *)(a1 + 96);
    v28 = (uint64_t)a3;
    do
    {
      if (v11 >= v8 || (unint64_t)v11 < v7)
        __break(0x5519u);
      v12 = atomic_load(v11 + 1);
      v13 = v9 - v12;
      if ((uint64_t)(v9 - v12) < 200001)
      {
        v20 = atomic_load(v11);
        if (v20 != 0x8000000000000000)
        {
          v21 = v28;
          v22 = v28 < v20;
          if (!a2)
            v22 = v28 > v20;
          v23 = v6 ^ 1 | v22;
          v6 = v6 | v23;
          if ((v23 & 1) != 0)
            v21 = v20;
          v28 = v21;
        }
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v14 = v6;
        v15 = v10;
        v16 = (double)v13;
        v17 = VRTraceErrorLogLevelToCSTR();
        v18 = *MEMORY[0x1E0CF2758];
        v19 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136316162;
            v30 = v17;
            v31 = 2080;
            v32 = "_VCJBTargetEstimatorSynchronizer_ApplyPolicy_MinMax";
            v33 = 1024;
            v34 = 198;
            v35 = 1024;
            v36 = v5;
            v37 = 2048;
            v38 = v16 / 200000.0;
            _os_log_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Ignoring old jitter values i=%d timeDiff=%4.2f", buf, 0x2Cu);
          }
        }
        else if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136316162;
          v30 = v17;
          v31 = 2080;
          v32 = "_VCJBTargetEstimatorSynchronizer_ApplyPolicy_MinMax";
          v33 = 1024;
          v34 = 198;
          v35 = 1024;
          v36 = v5;
          v37 = 2048;
          v38 = v16 / 200000.0;
          _os_log_debug_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Ignoring old jitter values i=%d timeDiff=%4.2f", buf, 0x2Cu);
        }
        v10 = v15;
        v6 = v14;
      }
      ++v5;
      v11 += 3;
    }
    while (v4 != v5);
    if ((v6 & 1) != 0)
    {
      v24 = v28;
      atomic_store(v28, v8);
      return (uint64_t)(float)v24;
    }
  }
  return v26;
}

uint64_t VCMediaNegotiationBlobV2StreamGroupEncodeDecodeFeaturesReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  int v15;
  char v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char v22;
  void *Data;
  uint64_t result;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        v14 = v9++ >= 9;
        if (v14)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      if ((v10 >> 3) == 2)
      {
        Data = (void *)PBReaderReadData();

        *(_QWORD *)(a1 + 8) = Data;
      }
      else if ((v10 >> 3) == 1)
      {
        v17 = 0;
        v18 = 0;
        v19 = 0;
        *(_BYTE *)(a1 + 20) |= 1u;
        while (1)
        {
          v20 = *v3;
          v21 = *(_QWORD *)(a2 + v20);
          if (v21 == -1 || v21 >= *(_QWORD *)(a2 + *v4))
            break;
          v22 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v21);
          *(_QWORD *)(a2 + v20) = v21 + 1;
          v19 |= (unint64_t)(v22 & 0x7F) << v17;
          if ((v22 & 0x80) == 0)
            goto LABEL_31;
          v17 += 7;
          v14 = v18++ >= 9;
          if (v14)
          {
            LODWORD(v19) = 0;
            goto LABEL_33;
          }
        }
        *(_BYTE *)(a2 + *v5) = 1;
LABEL_31:
        if (*(_BYTE *)(a2 + *v5))
          LODWORD(v19) = 0;
LABEL_33:
        *(_DWORD *)(a1 + 16) = v19;
      }
      else
      {
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
      }
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

uint64_t NetworkReceiveProc(void *a1)
{
  if (a1)
    return objc_msgSend(a1, "networkReceivePackets");
  else
    return -2145452030;
}

void decoderFrameCallback(void *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, __int128 *a6)
{
  __int128 v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (a3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        decoderFrameCallback_cold_1();
    }
  }
  else if (a5)
  {
    v6 = *a6;
    v7 = *((_QWORD *)a6 + 2);
    objc_msgSend(a1, "showDecodedFrame:atTime:", a5, &v6);
  }
}

void _VCSessionParticipantRemote_AddMetaDataToSpatialAudioSourceID(const __CFNumber *a1, uint64_t a2, void *a3)
{
  uint64_t v5;
  unsigned int valuePtr;
  _QWORD v7[2];

  v7[1] = *MEMORY[0x1E0C80C00];
  if (a3)
  {
    if (a1)
    {
      if (a2)
      {
        v7[0] = 0;
        if ((VCSpatialAudioMetadata_SpatialAudioSourceID(a2, v7) & 0x80000000) != 0)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              _VCSessionParticipantRemote_AddMetaDataToSpatialAudioSourceID_cold_4();
          }
        }
        else
        {
          valuePtr = -1431655766;
          if (CFNumberGetValue(a1, kCFNumberSInt32Type, &valuePtr) == 1)
          {
            v5 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", v7[0]);
            objc_msgSend(a3, "setObject:forKeyedSubscript:", v5, objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", valuePtr));
          }
          else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              _VCSessionParticipantRemote_AddMetaDataToSpatialAudioSourceID_cold_5();
          }
        }
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          _VCSessionParticipantRemote_AddMetaDataToSpatialAudioSourceID_cold_3();
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCSessionParticipantRemote_AddMetaDataToSpatialAudioSourceID_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCSessionParticipantRemote_AddMetaDataToSpatialAudioSourceID_cold_1();
  }
}

void sub_1D8C52654(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

__CFString *OUTLINED_FUNCTION_16_0@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  *(_QWORD *)(v2 - 24) = a2;
  return VCSessionMediaType_Name(a1);
}

uint64_t OUTLINED_FUNCTION_18_0@<X0>(void *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  *(_QWORD *)(v2 - 24) = a2;
  return objc_msgSend(a1, "groupID");
}

void _VCVideoReceiverRealtime_SetExternalOutputLatency()
{
  objc_exception_throw((id)objc_msgSend(MEMORY[0x1E0C99DA0], "exceptionWithName:reason:userInfo:", *MEMORY[0x1E0C99778], objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%s must be overridden in a subclass/category"), "void _VCVideoReceiverRealtime_SetExternalOutputLatency(VCVideoReceiverBase *, CFTimeInterval)"), 0));
}

void VCVideoReceiver_SetExternalOutputVideoLatency(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  int v3;
  uint64_t v4;
  __int16 v5;
  const char *v6;
  __int16 v7;
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    (*(void (**)(void))(a1 + 8))();
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v1 = VRTraceErrorLogLevelToCSTR();
    v2 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v3 = 136315650;
      v4 = v1;
      v5 = 2080;
      v6 = "VCVideoReceiver_SetExternalOutputVideoLatency";
      v7 = 1024;
      v8 = 165;
      _os_log_impl(&dword_1D8A54000, v2, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d videoReceiver is NULL", (uint8_t *)&v3, 0x1Cu);
    }
  }
}

void _VCAllocatorMultiQueueCallback_Release(CFAllocatorRef *a1)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int v3;
  CFAllocatorRef *v4[2];

  v4[1] = *(CFAllocatorRef **)MEMORY[0x1E0C80C00];
  v4[0] = a1;
  v1 = (unsigned int *)(a1 + 1);
  do
  {
    v2 = __ldxr(v1);
    v3 = v2 - 1;
  }
  while (__stxr(v3, v1));
  if (!v3)
  {
    _VCAllocatorMultiQueue_FinalizeInfo((uint64_t)a1);
    _VCAllocatorMultiQueue_ReleaseInfo(v4);
  }
}

_QWORD *_VCAllocatorMultiQueueCallback_Alloc(unint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5;
  uint64_t v6;
  unsigned int v7;
  OSQueueHead *v8;
  BOOL v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  NSObject *v13;
  _QWORD *v14;
  unsigned int *v15;
  unsigned int v16;
  unsigned int *v17;
  unsigned int v18;
  _QWORD *v20;
  OSQueueHead *v21;
  unsigned int *v22;
  unsigned int v23;
  unsigned int *v24;
  unsigned int v25;
  signed int v26;
  double v27;
  double v28;
  uint64_t v29;
  NSObject *v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  int v37;
  __int16 v38;
  uint64_t v39;
  __int16 v40;
  int v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v5 = *(_QWORD *)(a3 + 16);
  if (!v5)
  {
LABEL_5:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v10 = VRTraceErrorLogLevelToCSTR();
      v11 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v32 = 136315650;
        v33 = v10;
        v34 = 2080;
        v35 = "_VCAllocatorMultiQueue_FindBufferQueue";
        v36 = 1024;
        v37 = 172;
        _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Unable to allocate buffer!", (uint8_t *)&v32, 0x1Cu);
      }
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v12 = VRTraceErrorLogLevelToCSTR();
      v13 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v32 = 136316162;
        v33 = v12;
        v34 = 2080;
        v35 = "_VCAllocatorMultiQueueCallback_Alloc";
        v36 = 1024;
        v37 = 218;
        v38 = 2080;
        v39 = a3 + 24;
        v40 = 1024;
        v41 = a1;
        _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Allocator[%s] was unable to find a relevant buffer queue. Requested size:%d", (uint8_t *)&v32, 0x2Cu);
      }
    }
    v14 = CFAllocatorAllocate(*(CFAllocatorRef *)a3, a1 + 8, 0);
    if (v14)
    {
      v15 = (unsigned int *)(a3 + 100);
      do
        v16 = __ldxr(v15);
      while (__stxr(v16 + 1, v15));
      v17 = (unsigned int *)(a3 + 96);
      do
        v18 = __ldxr(v17);
      while (__stxr(v18 + 1, v17));
      *v14 = 0;
      return v14 + 1;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      return 0;
    v29 = VRTraceErrorLogLevelToCSTR();
    v30 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      return 0;
    v32 = 136316162;
    v33 = v29;
    v34 = 2080;
    v35 = "_VCAllocatorMultiQueueCallback_Alloc";
    v36 = 1024;
    v37 = 226;
    v38 = 2080;
    v39 = a3 + 24;
    v40 = 1024;
    v41 = a1;
LABEL_34:
    _os_log_error_impl(&dword_1D8A54000, v30, OS_LOG_TYPE_ERROR, " [%s] %s:%d Allocator[%s] Failed to allocate memory. Size:%d", (uint8_t *)&v32, 0x2Cu);
    return 0;
  }
  v6 = 0;
  v7 = 1;
  while (1)
  {
    v8 = (OSQueueHead *)(a3 + v6);
    if (*(_QWORD *)(a3 + v6 + 112) >= a1)
      break;
    v9 = v5 > v7++;
    v6 += 48;
    if (!v9)
      goto LABEL_5;
  }
  v20 = OSAtomicDequeue(v8 + 9, 0);
  v21 = v8 + 7;
  if (!v20)
  {
    v20 = CFAllocatorAllocate(*(CFAllocatorRef *)a3, (CFIndex)v21->opaque1 + 8, 0);
    v22 = (unsigned int *)(a3 + v6 + 120);
    do
      v23 = __ldxr(v22);
    while (__stxr(v23 + 1, v22));
    if (!v20)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 3)
        return 0;
      v31 = VRTraceErrorLogLevelToCSTR();
      v30 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        return 0;
      v32 = 136316162;
      v33 = v31;
      v34 = 2080;
      v35 = "_VCAllocatorMultiQueueCallback_Alloc";
      v36 = 1024;
      v37 = 245;
      v38 = 2080;
      v39 = a3 + 24;
      v40 = 1024;
      v41 = a1;
      goto LABEL_34;
    }
  }
  *v20 = v21;
  v24 = (unsigned int *)(a3 + v6 + 124);
  do
  {
    v25 = __ldxr(v24);
    v26 = v25 + 1;
  }
  while (__stxr(v26, v24));
  v27 = (double)v26;
  v28 = *(double *)(a3 + v6 + 128);
  if (v28 > (double)v26)
    v27 = (double)v26 * 0.0196078431 + v28 * 0.980392157;
  *(double *)(a3 + v6 + 128) = v27;
  return v20 + 1;
}

char *_VCAllocatorMultiQueueCallback_Realloc(_QWORD *a1, unint64_t a2, uint64_t a3, CFAllocatorRef *a4)
{
  char *v6;
  size_t *v7;
  _QWORD *v9;
  char *v10;
  _QWORD *v11;
  uint64_t v12;
  NSObject *v13;
  int v15;
  uint64_t v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  CFAllocatorRef *v22;
  __int16 v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v6 = (char *)(a1 - 1);
  v7 = (size_t *)*(a1 - 1);
  if (v7)
  {
    if (*v7 <= a2)
    {
      v11 = _VCAllocatorMultiQueueCallback_Alloc(a2, (uint64_t)v6, (uint64_t)a4);
      v9 = v11;
      if (v11)
      {
        memcpy(v11, a1, *v7);
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v12 = VRTraceErrorLogLevelToCSTR();
        v13 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v15 = 136316162;
          v16 = v12;
          v17 = 2080;
          v18 = "_VCAllocatorMultiQueueCallback_Realloc";
          v19 = 1024;
          v20 = 265;
          v21 = 2080;
          v22 = a4 + 3;
          v23 = 1024;
          v24 = a2;
          _os_log_error_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_ERROR, " [%s] %s:%d Allocator[%s] Memory reallocation failed. Size:%d", (uint8_t *)&v15, 0x2Cu);
        }
      }
      _VCAllocatorMultiQueueCallback_Dealloc(a1, (uint64_t)a4);
    }
    else
    {
      return (char *)a1;
    }
  }
  else
  {
    v10 = (char *)CFAllocatorReallocate(*a4, v6, a2 + 8, 0);
    if (v10)
      return v10 + 8;
    else
      return 0;
  }
  return (char *)v9;
}

void _VCAllocatorMultiQueueCallback_Dealloc(_QWORD *__new, uint64_t a2)
{
  char *v2;
  uint64_t v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int *v6;
  double v7;
  unsigned int v8;
  unsigned int *v9;
  unsigned int v10;

  v2 = (char *)(__new - 1);
  v3 = *(__new - 1);
  if (v3)
  {
    v4 = (unsigned int *)(v3 + 12);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 - 1, v4));
    if (!*(_BYTE *)(a2 + 104)
      || (v6 = (unsigned int *)(v3 + 8), v7 = ceil(*(double *)(v3 + 16)), v7 + v7 >= (double)*(int *)(v3 + 8)))
    {
      OSAtomicEnqueue((OSQueueHead *)(v3 + 32), v2, 0);
      return;
    }
    do
      v8 = __ldxr(v6);
    while (__stxr(v8 - 1, v6));
  }
  else
  {
    v9 = (unsigned int *)(a2 + 100);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 - 1, v9));
  }
  CFAllocatorDeallocate(*(CFAllocatorRef *)a2, v2);
}

void _VCAllocatorMultiQueue_FinalizeInfo(uint64_t a1)
{
  uint64_t v2;
  unsigned int v3;
  os_log_t *v4;
  uint64_t v5;
  void *v6;
  void *v7;
  unsigned int *v8;
  unsigned int v9;
  uint64_t v10;
  int *v11;
  int v12;
  uint64_t v13;
  NSObject *v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  int v19;
  uint8_t buf[4];
  uint64_t v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  int v29;
  __int16 v30;
  uint64_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (*(_QWORD *)(a1 + 16))
    {
      v2 = 0;
      v3 = 0;
      v4 = (os_log_t *)MEMORY[0x1E0CF2758];
      do
      {
        v5 = a1 + 48 * v2;
        if (*(_BYTE *)(v5 + 136))
        {
          v6 = OSAtomicDequeue((OSQueueHead *)(a1 + 48 * v2 + 144), 0);
          if (v6)
          {
            v7 = v6;
            v8 = (unsigned int *)(a1 + 48 * v2 + 120);
            do
            {
              do
                v9 = __ldxr(v8);
              while (__stxr(v9 - 1, v8));
              CFAllocatorDeallocate(*(CFAllocatorRef *)a1, v7);
              v7 = OSAtomicDequeue((OSQueueHead *)(a1 + 48 * v2 + 144), 0);
            }
            while (v7);
          }
          v10 = a1 + 48 * v2;
          v12 = *(_DWORD *)(v10 + 120);
          v11 = (int *)(v10 + 120);
          if (v12)
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              v13 = VRTraceErrorLogLevelToCSTR();
              v14 = *v4;
              if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
              {
                v15 = *v11;
                v16 = *(_QWORD *)(v5 + 112);
                *(_DWORD *)buf = 136316418;
                v21 = v13;
                v22 = 2080;
                v23 = "_VCAllocatorMultiQueue_CleanupQueue";
                v24 = 1024;
                v25 = 62;
                v26 = 2080;
                v27 = a1 + 24;
                v28 = 1024;
                v29 = v15;
                v30 = 2048;
                v31 = v16;
                _os_log_error_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_ERROR, " [%s] %s:%d Allocator=%s. %d buffer leak(s) detected queue with size[%zu]", buf, 0x36u);
              }
            }
          }
        }
        v2 = ++v3;
      }
      while (*(_QWORD *)(a1 + 16) > (unint64_t)v3);
    }
    if (*(_DWORD *)(a1 + 100))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v17 = VRTraceErrorLogLevelToCSTR();
        v18 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v19 = *(_DWORD *)(a1 + 100);
          *(_DWORD *)buf = 136316162;
          v21 = v17;
          v22 = 2080;
          v23 = "_VCAllocatorMultiQueue_FinalizeInfo";
          v24 = 1024;
          v25 = 73;
          v26 = 2080;
          v27 = a1 + 24;
          v28 = 1024;
          v29 = v19;
          _os_log_error_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_ERROR, " [%s] %s:%d Allocator=%s. %d buffer leak(s) not associated with a queue", buf, 0x2Cu);
        }
      }
    }
    if (*(_QWORD *)a1)
      CFRelease(*(CFTypeRef *)a1);
    *(_QWORD *)a1 = 0;
  }
}

void _VCAllocatorMultiQueue_ReleaseInfo(CFAllocatorRef **a1)
{
  CFAllocatorRef *v2;
  CFAllocatorRef v3;

  if (a1)
  {
    v2 = *a1;
    if (*a1)
    {
      v3 = *v2;
      CFAllocatorDeallocate(*v2, v2);
      if (v3)
        CFRelease(v3);
      *a1 = 0;
    }
  }
}

void OUTLINED_FUNCTION_3_4(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x30u);
}

char *CopyRemoteDisplayWithoutQuotes(char *__dst, char *a2, char *a3, char *__source)
{
  int v5;

  if (!*a2)
  {
    if (*a3)
      a2 = a3;
    else
      a2 = __source;
    goto LABEL_9;
  }
  if (*a2 != 34)
  {
LABEL_9:
    strlcpy(__dst, a2, 0x56uLL);
    return __dst;
  }
  strlcpy(__dst, a2 + 1, 0x56uLL);
  v5 = strlen(__dst) - 1;
  if (__dst[v5] == 34)
    __dst[v5] = 0;
  return __dst;
}

uint64_t SIPSetMessageDelegateForCallID(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;

  v5 = CheckInHandleDebug();
  if (v5)
  {
    SIPClientDictionaryCInterface_SetObjectForKey(*(void **)(v5 + 136), CFSTR("SIPMessageReceivedHandler"), a3, a2);
    CheckOutHandleDebug();
    return 0;
  }
  else
  {
    v6 = 2148139010;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SIPSetMessageDelegateForCallID_cold_1();
    }
  }
  return v6;
}

uint64_t SIPSetCellConditionChangeHandler(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;

  v5 = CheckInHandleDebug();
  if (v5)
  {
    TPSetCellConditionChangeHandler(*(_QWORD *)(v5 + 24), a2, a3);
    CheckOutHandleDebug();
    return 0;
  }
  else
  {
    v6 = 2148139009;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SIPSetCellConditionChangeHandler_cold_1();
    }
  }
  return v6;
}

uint64_t SIPCreateHandle(uint64_t *a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  uint64_t v5;
  _DWORD *v9;
  void *v10;
  SIPClientDataDictionary *v11;
  char *v12;
  uint64_t Handle;
  uint64_t v14;

  if (a2)
  {
    if (a4 < 2)
    {
      v9 = malloc_type_calloc(1uLL, 0x90uLL, 0x10A0040338A4F97uLL);
      if (v9)
      {
        v10 = v9;
        v9[3] = 1;
        *(_QWORD *)v9 = 0;
        v9[5] = VCUniqueIDGenerator_GenerateID();
        pthread_mutex_init((pthread_mutex_t *)v10 + 1, 0);
        *((_QWORD *)v10 + 4) = a2;
        *((_QWORD *)v10 + 5) = a3;
        v11 = SIPClientDictionaryCInterface_Create();
        v12 = "TCP";
        *((_QWORD *)v10 + 17) = v11;
        if (!a4)
          v12 = "UDP";
        DEFAULT_TRANSPORT = v12;
        Handle = CreateHandle();
        *a1 = Handle;
        if (Handle == 0xFFFFFFFFLL)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              SIPCreateHandle_cold_4();
          }
          pthread_mutex_destroy((pthread_mutex_t *)v10 + 1);
          free(v10);
          return 2148139013;
        }
        else
        {
          v14 = TPCreateHandle((uint64_t *)v10 + 3, a4, (uint64_t)TUMsgCallback, (uint64_t)a1, 0, 0, 0, 0, 0, 0, 0);
          if ((v14 & 0x80000000) != 0)
          {
            v5 = v14;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                SIPCreateHandle_cold_5();
            }
            CheckOutHandleDebug();
            pthread_mutex_destroy((pthread_mutex_t *)v10 + 1);
            free(v10);
          }
          else
          {
            return 0;
          }
        }
      }
      else
      {
        v5 = 2148139011;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            SIPCreateHandle_cold_3();
        }
      }
    }
    else
    {
      v5 = 2147549185;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          SIPCreateHandle_cold_2();
      }
    }
  }
  else
  {
    v5 = 2147549185;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SIPCreateHandle_cold_1();
    }
  }
  return v5;
}

uint64_t TUMsgCallback(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int active;
  void *(__cdecl *v9)(void *);
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  NSObject *v17;
  __int128 v18;
  int v19;
  uint64_t v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  NSObject *v27;
  int v29;
  pthread_t v30;
  uint64_t v31;
  pthread_attr_t buf;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v31 = 0xAAAAAAAAAAAAAAAALL;
  v4 = *a1;
  pthread_setname_np("com.apple.AVConference.SIP.tuMessageCallbackProc");
  if (a2)
  {
    v5 = CheckInHandleDebug();
    if (v5)
    {
      v6 = v5;
      if (!*(_DWORD *)(a2 + 1008))
        UpdateCompressionMethodForMsg(a2, *(_DWORD *)(v5 + 16));
      if (*(_DWORD *)(a2 + 572))
      {
        v7 = 0;
      }
      else
      {
        v7 = DLFindWithSipMsgAndLock(&v31, a2);
        if ((v7 & 0x80000000) == 0)
        {
          DLGetCallID(v31, (_DWORD *)(a2 + 572));
          DLUnlock();
        }
      }
      if (*(_DWORD *)(a2 + 4) == 1)
      {
        v9 = (void *(__cdecl *)(void *))SIPCancelProc;
        switch(*(_DWORD *)(a2 + 8))
        {
          case 1:
            v10 = DLFindWithSipMsgAndLock(&v31, a2);
            if ((v10 & 0x80000000) != 0)
            {
              v7 = v10;
              v9 = (void *(__cdecl *)(void *))SIPNewCallProc;
              goto LABEL_36;
            }
            v7 = DLPutMsg(v31, a2, 0);
            if ((v7 & 0x80000000) != 0)
              FreeSipMsg((_QWORD *)a2);
            DLUnlock();
            goto LABEL_62;
          case 2:
            goto LABEL_47;
          case 4:
            v9 = (void *(__cdecl *)(void *))SIPHangupProc;
            goto LABEL_36;
          case 5:
            goto LABEL_36;
          case 7:
            v11 = *(uint64_t **)(a2 + 528);
            if (!v11)
              goto LABEL_35;
            v12 = *v11;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v13 = VRTraceErrorLogLevelToCSTR();
              v14 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                LODWORD(buf.__sig) = 136315906;
                *(uint64_t *)((char *)&buf.__sig + 4) = v13;
                *(_WORD *)&buf.__opaque[4] = 2080;
                *(_QWORD *)&buf.__opaque[6] = "TUMsgCallback";
                *(_WORD *)&buf.__opaque[14] = 1024;
                *(_DWORD *)&buf.__opaque[16] = 1555;
                *(_WORD *)&buf.__opaque[20] = 2048;
                *(_QWORD *)&buf.__opaque[22] = v12;
                _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d()()()()() SKE msg recved (%lu)", (uint8_t *)&buf, 0x26u);
              }
            }
            v15 = DLFindWithSipMsgAndLock(&v31, a2);
            if ((v15 & 0x80000000) != 0)
            {
              v7 = v15;
LABEL_35:
              v9 = (void *(__cdecl *)(void *))SIPMessageProc;
            }
            else
            {
              LODWORD(v30) = 0;
              v7 = DLGetDoingKeyExchange(v31, &v30);
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v16 = VRTraceErrorLogLevelToCSTR();
                v17 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                {
                  LODWORD(buf.__sig) = 136315906;
                  *(uint64_t *)((char *)&buf.__sig + 4) = v16;
                  *(_WORD *)&buf.__opaque[4] = 2080;
                  *(_QWORD *)&buf.__opaque[6] = "TUMsgCallback";
                  *(_WORD *)&buf.__opaque[14] = 1024;
                  *(_DWORD *)&buf.__opaque[16] = 1562;
                  *(_WORD *)&buf.__opaque[20] = 1024;
                  *(_DWORD *)&buf.__opaque[22] = (_DWORD)v30;
                  _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d()()()()() SKE flag = %d", (uint8_t *)&buf, 0x22u);
                }
              }
              if ((_DWORD)v30)
              {
                v7 = DLPutMsg(v31, a2, 0);
                if ((v7 & 0x80000000) != 0)
                  FreeSipMsg((_QWORD *)a2);
                DLUnlock();
                goto LABEL_62;
              }
              if (v12 != 1)
              {
                DLUnlock();
                goto LABEL_47;
              }
              DLSetDoingKeyExchange(v31, 1);
              DLUnlock();
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v20 = VRTraceErrorLogLevelToCSTR();
                v21 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                {
                  LODWORD(buf.__sig) = 136315650;
                  *(uint64_t *)((char *)&buf.__sig + 4) = v20;
                  *(_WORD *)&buf.__opaque[4] = 2080;
                  *(_QWORD *)&buf.__opaque[6] = "TUMsgCallback";
                  *(_WORD *)&buf.__opaque[14] = 1024;
                  *(_DWORD *)&buf.__opaque[16] = 1574;
                  _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SKE received??? - ignoring anyway", (uint8_t *)&buf, 0x1Cu);
                }
              }
              v9 = (void *(__cdecl *)(void *))SIPKeyExchangeProc;
            }
LABEL_36:
            v30 = (pthread_t)0xAAAAAAAAAAAAAAAALL;
            *(_QWORD *)&v18 = 0xAAAAAAAAAAAAAAAALL;
            *((_QWORD *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
            *(_OWORD *)&buf.__opaque[24] = v18;
            *(_OWORD *)&buf.__opaque[40] = v18;
            *(_OWORD *)&buf.__sig = v18;
            *(_OWORD *)&buf.__opaque[8] = v18;
            *(_QWORD *)(a2 + 1000) = a1;
            pthread_attr_init(&buf);
            pthread_attr_setscope(&buf, 1);
            pthread_attr_setdetachstate(&buf, 2);
            v19 = pthread_create(&v30, &buf, v9, (void *)a2);
            pthread_attr_destroy(&buf);
            if (!v19)
              goto LABEL_62;
            v7 = v19 | 0xC00A0000;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                TUMsgCallback_cold_1();
            }
            SendTPStatus(*(_QWORD *)(v6 + 24), a2, 42, 0, 0, *(_DWORD *)(v6 + 8));
            break;
          default:
            SendTPStatus(*(_QWORD *)(v6 + 24), a2, 13, 0, 0, *(_DWORD *)(v6 + 8));
            FreeSipMsg((_QWORD *)a2);
            CheckOutHandleDebug();
            return 0;
        }
        goto LABEL_61;
      }
LABEL_47:
      v22 = DLFindWithSipMsgAndLock(&v31, a2);
      if ((v22 & 0x80000000) != 0)
      {
        v7 = v22;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          v26 = VRTraceErrorLogLevelToCSTR();
          v27 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf.__sig) = 136316162;
            *(uint64_t *)((char *)&buf.__sig + 4) = v26;
            *(_WORD *)&buf.__opaque[4] = 2080;
            *(_QWORD *)&buf.__opaque[6] = "TUMsgCallback";
            *(_WORD *)&buf.__opaque[14] = 1024;
            *(_DWORD *)&buf.__opaque[16] = 1626;
            *(_WORD *)&buf.__opaque[20] = 1024;
            *(_DWORD *)&buf.__opaque[22] = 1626;
            *(_WORD *)&buf.__opaque[26] = 1024;
            *(_DWORD *)&buf.__opaque[28] = v7;
            _os_log_impl(&dword_1D8A54000, v27, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SIP.c:%d: Found no-match: Discard message(%08X)", (uint8_t *)&buf, 0x28u);
          }
        }
        goto LABEL_61;
      }
      if (*(_DWORD *)(a2 + 4) == 2)
      {
        buf.__sig = 0;
        v23 = *(_QWORD *)(a2 + 272);
        DLGetAck(v31, &buf);
        v24 = *(_DWORD *)(a2 + 8);
        if (v24 == 6)
        {
          if (*(_DWORD *)(v23 + 8) == 1 && buf.__sig)
          {
            v7 = TPSend(*(_QWORD *)(v6 + 24));
            v25 = *(_QWORD *)(a2 + 208);
            v29 = 0;
            LODWORD(v30) = 12;
            if (v25)
              (*(void (**)(uint64_t, _QWORD, uint64_t, _QWORD, uint64_t, _QWORD, pthread_t *, int *))(v6 + 32))(v4, *(_QWORD *)(v6 + 40), 15, *(unsigned int *)(a2 + 572), v25, 0, &v30, &v29);
            FreeSipMsg((_QWORD *)a2);
            DLUnlock();
            goto LABEL_62;
          }
        }
        else if ((v24 - 2) > 5)
        {
          goto LABEL_60;
        }
        DLUpdate(v31, a2);
      }
LABEL_60:
      DLUnlock();
      v7 = DLPutMsg(v31, a2, 0);
      if ((v7 & 0x80000000) == 0)
      {
LABEL_62:
        CheckOutHandleDebug();
        return v7;
      }
LABEL_61:
      FreeSipMsg((_QWORD *)a2);
      goto LABEL_62;
    }
    v7 = 2148139010;
    FreeSipMsg((_QWORD *)a2);
  }
  else
  {
    LODWORD(v30) = -1431655766;
    buf.__sig = 0;
    active = DLFindActiveDialogs(&v30, &buf);
    free((void *)buf.__sig);
    v7 = 2148139030;
    if ((active & 0x80000000) == 0 && (int)v30 >= 1)
      return SIPSendMessageAll((uint64_t)a1, 0, "PING");
  }
  return v7;
}

uint64_t SIPCloseHandle()
{
  uint64_t v0;
  uint64_t v1;
  const void *v2;

  v0 = CheckInHandleDebug();
  if (!v0)
    return 2148139010;
  v1 = v0;
  TPCloseHandle();
  DLCloseHandleAll();
  CheckOutHandleDebug();
  v2 = *(const void **)(v1 + 48);
  if (v2)
    CFRelease(v2);
  *(_QWORD *)(v1 + 48) = 0;
  SIPClientDictionaryCInterface_Release(*(id *)(v1 + 136));
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 64));
  free((void *)v1);
  return 0;
}

uint64_t SIPSetPacketMultiplexMode(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2148139010;
  v4 = *(_QWORD *)(v3 + 24);
  if (a2 != 1 && a2 != 2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SIPSetPacketMultiplexMode_cold_1();
    }
    a2 = 0;
  }
  TPSetPacketMultiplexMode(v4, a2);
  CheckOutHandleDebug();
  return 0;
}

uint64_t SIPStartListen(uint64_t a1, int a2, const unsigned __int8 *a3)
{
  uint64_t v5;
  int *v6;
  int *v7;
  int v8;
  int v9;
  uint64_t v10;
  int ErrorLogLevelForModule;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  NSObject *v17;
  uint64_t v19;
  NSObject *v20;
  uint64_t v21;
  NSObject *v22;
  unsigned __int16 v23;
  uint8_t v24[48];
  uint8_t buf[4];
  uint64_t v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v5 = 2148139010;
  v6 = (int *)CheckInHandleDebug();
  if (v6)
  {
    v7 = v6;
    if (a2 != 1)
    {
      if (a2)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            SIPStartListen_cold_1();
        }
        v5 = 0;
        goto LABEL_26;
      }
      v8 = *v6;
      if (*v6)
      {
        v5 = 0;
LABEL_6:
        *v7 = v8 + 1;
LABEL_26:
        CheckOutHandleDebug();
        return v5;
      }
      memset(v24, 0, 40);
      v10 = CheckInHandleDebug();
      if (v10)
      {
        v23 = 16402;
        v5 = TPListenOnPhysicalInterface(*(_QWORD *)(v10 + 24), &v23, 1, (uint64_t)v24, a3);
        ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
        if ((v5 & 0x80000000) == 0)
        {
          if (ErrorLogLevelForModule >= 7)
          {
            v12 = VRTraceErrorLogLevelToCSTR();
            v13 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315906;
              v26 = v12;
              v27 = 2080;
              v28 = "SIPListenOnPhysicalInterface";
              v29 = 1024;
              v30 = 1908;
              v31 = 1024;
              v32 = v23;
              _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TPListenOnPhysicalInterface on port %d", buf, 0x22u);
            }
          }
          CheckOutHandleDebug();
          v8 = *v7;
          goto LABEL_6;
        }
        if (ErrorLogLevelForModule >= 7)
        {
          v19 = VRTraceErrorLogLevelToCSTR();
          v20 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315906;
            v26 = v19;
            v27 = 2080;
            v28 = "SIPListenOnPhysicalInterface";
            v29 = 1024;
            v30 = 1904;
            v31 = 1024;
            v32 = v5;
            _os_log_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TPListenOnPhysicalInterface failed(%08X)", buf, 0x22u);
          }
        }
        CheckOutHandleDebug();
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          SIPStartListen_cold_2();
      }
      goto LABEL_26;
    }
    v9 = v6[1];
    if (v9)
    {
      v5 = 0;
LABEL_25:
      v7[1] = v9 + 1;
      goto LABEL_26;
    }
    v14 = CheckInHandleDebug();
    if (v14)
    {
      v5 = TPListenVirtualInterface(*(void **)(v14 + 24));
      v15 = VRTraceGetErrorLogLevelForModule();
      if ((v5 & 0x80000000) == 0)
      {
        if (v15 >= 7)
        {
          v16 = VRTraceErrorLogLevelToCSTR();
          v17 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)v24 = 136315650;
            *(_QWORD *)&v24[4] = v16;
            *(_WORD *)&v24[12] = 2080;
            *(_QWORD *)&v24[14] = "SIPListenOnVirtualInterface";
            *(_WORD *)&v24[22] = 1024;
            *(_DWORD *)&v24[24] = 1868;
            _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPListenOnVirtualInterface succeeded", v24, 0x1Cu);
          }
        }
        CheckOutHandleDebug();
        v9 = v7[1];
        goto LABEL_25;
      }
      if (v15 >= 7)
      {
        v21 = VRTraceErrorLogLevelToCSTR();
        v22 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v24 = 136315906;
          *(_QWORD *)&v24[4] = v21;
          *(_WORD *)&v24[12] = 2080;
          *(_QWORD *)&v24[14] = "SIPListenOnVirtualInterface";
          *(_WORD *)&v24[22] = 1024;
          *(_DWORD *)&v24[24] = 1866;
          *(_WORD *)&v24[28] = 1024;
          *(_DWORD *)&v24[30] = v5;
          _os_log_impl(&dword_1D8A54000, v22, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TPListenVirtualInterface failed(%08X)", v24, 0x22u);
        }
      }
      CheckOutHandleDebug();
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SIPStartListen_cold_3();
    }
    goto LABEL_26;
  }
  return v5;
}

uint64_t SIPStopListen(uint64_t a1, int a2)
{
  int *v4;
  BOOL v5;
  uint64_t v6;
  int v7;
  BOOL v8;
  int v9;

  v4 = (int *)CheckInHandleDebug();
  if (v4)
  {
    if (a2 == 1)
    {
      v7 = v4[1];
      v8 = __OFSUB__(v7, 1);
      v9 = v7 - 1;
      if (v9 < 0 == v8)
      {
        v4[1] = v9;
        if (!v9)
        {
          v6 = SIPStopListenOnInterface(a1, 1);
          if ((v6 & 0x80000000) != 0 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              SIPStopListen_cold_3();
          }
          goto LABEL_22;
        }
      }
    }
    else if (a2)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          SIPStopListen_cold_1();
      }
    }
    else
    {
      v5 = *v4 == 1;
      if (*v4 >= 1)
      {
        --*v4;
        if (v5)
        {
          v6 = SIPStopListenOnInterface(a1, 0);
          if ((v6 & 0x80000000) != 0 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              SIPStopListen_cold_2();
          }
          goto LABEL_22;
        }
      }
    }
    v6 = 0;
LABEL_22:
    CheckOutHandleDebug();
    return v6;
  }
  return 2148139010;
}

uint64_t SIPStopListenOnInterface(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  int ErrorLogLevelForModule;
  uint64_t v6;
  NSObject *v7;
  const char *v8;
  const char *v9;
  NSObject *v10;
  uint32_t v11;
  uint64_t v13;
  NSObject *v14;
  int v15;
  uint64_t v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  const char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v3 = CheckInHandleDebug();
  if (!v3)
    return 2148139010;
  v4 = TPStopListen(*(_QWORD *)(v3 + 24), a2);
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if ((v4 & 0x80000000) != 0)
  {
    if (ErrorLogLevelForModule < 7)
      goto LABEL_9;
    v13 = VRTraceErrorLogLevelToCSTR();
    v14 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      goto LABEL_9;
    v15 = 136315906;
    v16 = v13;
    v17 = 2080;
    v18 = "SIPStopListenOnInterface";
    v19 = 1024;
    v20 = 1883;
    v21 = 1024;
    LODWORD(v22) = v4;
    v9 = "SIP [%s] %s:%d TPStopListen failed(%08X)";
    v10 = v14;
    v11 = 34;
  }
  else
  {
    if (ErrorLogLevelForModule < 7)
      goto LABEL_9;
    v6 = VRTraceErrorLogLevelToCSTR();
    v7 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      goto LABEL_9;
    v8 = "physical";
    v15 = 136315906;
    v16 = v6;
    v17 = 2080;
    if (a2)
      v8 = "virtual";
    v18 = "SIPStopListenOnInterface";
    v19 = 1024;
    v20 = 1885;
    v21 = 2080;
    v22 = v8;
    v9 = "SIP [%s] %s:%d SIPStopListenOnInterface %s succeeded";
    v10 = v7;
    v11 = 38;
  }
  _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v15, v11);
LABEL_9:
  CheckOutHandleDebug();
  return v4;
}

uint64_t SIPConnectIPPort(uint64_t *a1, uint64_t a2, int a3, const char *a4, const char *a5, char *a6, char *a7, _OWORD *a8, int a9, int a10)
{
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t Ack;
  _DWORD *v21;
  _DWORD *v22;
  uint64_t active;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  char v32;
  void *v33;
  int v34;
  int v36;
  uint64_t Cancel;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  NSObject *v42;
  _QWORD *v43;
  uint64_t v44;
  NSObject *v45;
  uint64_t v47;
  NSObject *v48;
  uint64_t v49;
  _BOOL4 v50;
  uint64_t v51;
  __int128 v52;
  const char *v53;
  uint64_t v55;
  int v57;
  int v58;
  int v59;
  unsigned int v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  void *v64[3];
  int v65;
  _BYTE buf[48];
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  unint64_t v71;
  __int128 v72[2];
  unint64_t v73;
  __int128 v74[2];
  unint64_t v75;
  uint64_t v76;

  v76 = *MEMORY[0x1E0C80C00];
  v65 = 0;
  v75 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v16 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v74[0] = v16;
  v74[1] = v16;
  v73 = 0xAAAAAAAAAAAAAAAALL;
  v72[0] = v16;
  v72[1] = v16;
  v71 = 0xAAAAAAAAAAAAAAAALL;
  v69 = v16;
  v70 = v16;
  v63 = 0xFFFFFFFFLL;
  memset(v64, 170, sizeof(v64));
  v61 = 0xFFFFFFFFLL;
  v62 = 0xFFFFFFFFLL;
  v60 = -1431655766;
  v17 = *a1;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v18 = VRTraceErrorLogLevelToCSTR();
    v19 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = v18;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "SIPConnectIPPort";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 1929;
      _os_log_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPConnect start...", buf, 0x1Cu);
    }
  }
  Ack = 2148139025;
  v21 = (_DWORD *)CheckInHandleDebug();
  if (!v21)
    return 2148139010;
  v22 = v21;
  if (!*v21 && !v21[1])
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v41 = VRTraceErrorLogLevelToCSTR();
      v42 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = v41;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "SIPConnectIPPort";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 1937;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = 1937;
        _os_log_impl(&dword_1D8A54000, v42, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SIP.c:%d: Call SIPStartListen first.", buf, 0x22u);
      }
    }
    goto LABEL_69;
  }
  v55 = v17;
  MakeIPPORT();
  MakeIPPORT();
  v69 = 0u;
  v70 = 0u;
  v71 = 0;
  active = DLCountActiveDialogs(&v65);
  if ((active & 0x80000000) != 0)
  {
    v40 = active;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SIPConnectIPPort_cold_1();
    }
    goto LABEL_63;
  }
  v24 = CreateInvite((unint64_t *)&v64[2], a2, a3, (uint64_t)v74, v72, v74, v72, &v69, 0, 0, a4, a5, a6, v22[3], v65 != 0, v22[4]);
  if ((v24 & 0x80000000) != 0)
  {
    v40 = v24;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SIPConnectIPPort_cold_2();
    }
    goto LABEL_63;
  }
  if (a8)
    *((_OWORD *)v64[2] + 61) = *a8;
  (*((void (**)(uint64_t, _QWORD, uint64_t, uint64_t, _QWORD, _QWORD, unsigned int *, _QWORD))v22 + 4))(v17, *((_QWORD *)v22 + 5), 12, a2, 0, 0, &v60, 0);
  v25 = DLCreateHandle(&v63, a2, (uint64_t)v64[2], 0, v60, a9, (uint64_t)DLIsFinishedCallback, v17);
  if ((v25 & 0x80000000) != 0)
  {
    v40 = v25;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SIPConnectIPPort_cold_3();
    }
    goto LABEL_61;
  }
  v26 = TACreateHandle(&v62, 0, *((_QWORD *)v22 + 3), (uint64_t)v64[2], v63, (uint64_t)TUMsgCallback, (uint64_t)a1);
  if ((v26 & 0x80000000) != 0)
  {
    v40 = v26;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SIPConnectIPPort_cold_4();
    }
LABEL_61:
    v43 = v64[2];
    goto LABEL_62;
  }
  v59 = a2;
  TASetRTT(v62, a10, (uint64_t)TUGenericLogCallback, &v59);
  v27 = TAStart((void *)v62);
  if ((v27 & 0x80000000) != 0)
  {
    v40 = v27;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SIPConnectIPPort_cold_5();
    }
    goto LABEL_63;
  }
  v28 = v64[2];
  v29 = *((_QWORD *)v64[2] + 26);
  v57 = 0;
  v58 = 11;
  if (v29)
  {
    (*((void (**)(uint64_t, _QWORD, uint64_t, uint64_t, uint64_t, _QWORD, int *, int *))v22 + 4))(v17, *((_QWORD *)v22 + 5), 15, a2, v29, 0, &v58, &v57);
    v28 = v64[2];
  }
  v30 = DLGetMsg(v63, v64, 0xFFFFFFFFuLL, 1, (uint64_t)v28, -1);
  if ((v30 & 0x80000000) != 0)
  {
LABEL_40:
    v40 = v30;
LABEL_41:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SIPConnectIPPort_cold_6();
    }
    goto LABEL_63;
  }
  v31 = 0;
  v32 = 1;
  while (1)
  {
    while (1)
    {
      v33 = v64[0];
      v34 = *((_DWORD *)v64[0] + 1);
      if (*(_DWORD *)v64[0] != 1 || v34 != 1)
        break;
      if (*((_DWORD *)v64[0] + 2) == 5)
      {
        FreeSipMsg((_QWORD *)v64[0]);
        if ((v32 & 1) != 0)
        {
          if (!v31)
          {
            v40 = 2148139038;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v47 = VRTraceErrorLogLevelToCSTR();
              v48 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315650;
                *(_QWORD *)&buf[4] = v47;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "SIPConnectIPPort";
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&buf[24] = 2044;
                _os_log_impl(&dword_1D8A54000, v48, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Call request cancelled before receiving any response\n", buf, 0x1Cu);
                v40 = 2148139038;
              }
            }
            goto LABEL_64;
          }
          Cancel = CreateCancel(&v64[1], (uint64_t)v64[2]);
          if ((Cancel & 0x80000000) != 0)
          {
            v40 = Cancel;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                SIPConnectIPPort_cold_7();
            }
          }
          else
          {
            v38 = TACreateHandle(&v61, 1, *((_QWORD *)v22 + 3), (uint64_t)v64[1], 0xFFFFFFFFLL, (uint64_t)TUMsgCallback, (uint64_t)a1);
            if ((v38 & 0x80000000) != 0)
            {
              v40 = v38;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  SIPConnectIPPort_cold_8();
              }
              v43 = v64[1];
LABEL_62:
              FreeSipMsg(v43);
            }
            else
            {
              v39 = TAStart((void *)v61);
              if ((v39 & 0x80000000) == 0)
              {
                v31 = 1;
                goto LABEL_35;
              }
              v40 = v39;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  SIPConnectIPPort_cold_9();
              }
            }
          }
LABEL_63:
          if ((v40 & 0x10000000) != 0)
          {
LABEL_65:
            DLCloseHandle();
            Ack = v40;
            goto LABEL_66;
          }
LABEL_64:
          TACancel();
          TACancel();
          goto LABEL_65;
        }
LABEL_35:
        v40 = DLGetMsg(v63, v64, 0xFFFFFFFFuLL, 1, (uint64_t)v64[2], -1);
        v32 = 0;
        if ((v40 & 0x80000000) != 0)
          goto LABEL_41;
      }
      else
      {
LABEL_27:
        FreeSipMsg((_QWORD *)v64[0]);
        v30 = DLGetMsg(v63, v64, 0xFFFFFFFFuLL, 1, (uint64_t)v64[2], -1);
        if ((v30 & 0x80000000) != 0)
          goto LABEL_40;
      }
    }
    if (v34 != 2 || *(_DWORD *)(*((_QWORD *)v64[0] + 34) + 8) == 5)
      goto LABEL_27;
    v36 = *((_DWORD *)v64[0] + 2);
    if ((v36 - 1) <= 4)
    {
      (*((void (**)(uint64_t, _QWORD, uint64_t, uint64_t, char *, _QWORD, _QWORD, _QWORD))v22 + 4))(v55, *((_QWORD *)v22 + 5), 4, a2, (char *)v64[0] + 12, 0, 0, 0);
      FreeSipMsg((_QWORD *)v64[0]);
      v31 = 1;
      goto LABEL_39;
    }
    if ((v36 & 0xFFFFFFFE) == 6)
      break;
    if ((v36 - 8) <= 0x2C)
    {
      if (v36 == 10)
      {
        v51 = *((_QWORD *)v64[0] + 28);
        if (v51)
        {
          *(_QWORD *)&v52 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v52 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v68 = v52;
          *(_OWORD *)&buf[32] = v52;
          v67 = v52;
          *(_OWORD *)buf = v52;
          *(_OWORD *)&buf[16] = v52;
          ConstructUri(buf, (char *)(v51 + 44));
          (*((void (**)(uint64_t, _QWORD, uint64_t, uint64_t, const char *, uint64_t, _BYTE *, _QWORD))v22 + 4))(v55, *((_QWORD *)v22 + 5), 10, a2, a5, v51, buf, 0);
          v33 = v64[0];
        }
      }
      v40 = v36 | 0x900A0000;
      v43 = v33;
      goto LABEL_62;
    }
LABEL_39:
    v30 = DLGetMsg(v63, v64, 0xFFFFFFFFuLL, 1, (uint64_t)v64[2], -1);
    if ((v30 & 0x80000000) != 0)
      goto LABEL_40;
  }
  *(_QWORD *)buf = 0xAAAAAAAAAAAAAAAALL;
  v49 = *((_QWORD *)v64[0] + 28);
  v50 = (!v49 || !*(_DWORD *)(v49 + 156)) && v22[3];
  v22[2] = v50;
  v53 = (const char *)*((_QWORD *)v33 + 69);
  if (v53)
  {
    strlcpy(a7, v53, 0xA8CuLL);
    v33 = v64[0];
  }
  else
  {
    *a7 = 0;
  }
  Ack = CreateAck((unint64_t *)buf, (uint64_t)v64[2], (uint64_t)v33);
  FreeSipMsg((_QWORD *)v64[0]);
  if ((Ack & 0x80000000) != 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SIPConnectIPPort_cold_10();
    }
    goto LABEL_111;
  }
  Ack = TPSend(*((_QWORD *)v22 + 3));
  if ((Ack & 0x80000000) != 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SIPConnectIPPort_cold_11();
    }
    FreeSipMsg(*(_QWORD **)buf);
LABEL_111:
    v40 = Ack;
    goto LABEL_63;
  }
  v57 = 0;
  v58 = 12;
  if (v29)
    (*((void (**)(uint64_t, _QWORD, uint64_t, uint64_t, uint64_t, _QWORD, int *, int *))v22 + 4))(v55, *((_QWORD *)v22 + 5), 15, a2, v29, 0, &v58, &v57);
  DLSetAck(v63, *(uint64_t *)buf);
LABEL_66:
  TACloseHandle();
  TACloseHandle();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v44 = VRTraceErrorLogLevelToCSTR();
    v45 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = v44;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "SIPConnectIPPort";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 2159;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = Ack;
      _os_log_impl(&dword_1D8A54000, v45, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPConnect stop(%X)...", buf, 0x22u);
    }
  }
LABEL_69:
  CheckOutHandleDebug();
  return Ack;
}

uint64_t DLIsFinishedCallback(uint64_t a1, int a2)
{
  uint64_t result;

  result = CheckInHandleDebug();
  if (result)
  {
    TPRemovePreservedPortBindForCallID(*(_QWORD *)(result + 24), a2);
    return CheckOutHandleDebug();
  }
  return result;
}

uint64_t TUGenericLogCallback(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v6;

  v6 = CheckInHandleDebug();
  if (!v6)
    return 2148139010;
  (*(void (**)(uint64_t, _QWORD, uint64_t, _QWORD, uint64_t, _QWORD, _QWORD, _QWORD))(v6 + 32))(a1, *(_QWORD *)(v6 + 40), 16, *a2, a3, 0, 0, 0);
  CheckOutHandleDebug();
  return 0;
}

uint64_t SIPKeyExchange(uint64_t *a1, uint64_t a2, uint64_t a3, _QWORD *a4, int a5)
{
  if (a4)
    return SIPDoKeyExchange(a1, a2, a3, a4, a5);
  else
    return 2148139009;
}

uint64_t SIPDoKeyExchange(uint64_t *a1, uint64_t a2, uint64_t a3, _QWORD *a4, int a5)
{
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  _DWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  const char *v16;
  NSObject *v17;
  uint64_t v18;
  NSObject *v19;
  uint32_t v20;
  uint64_t v21;
  NSObject *v22;
  uint64_t v23;
  NSObject *v24;
  uint64_t v25;
  NSObject *v26;
  uint64_t v27;
  NSObject *v28;
  uint64_t v29;
  NSObject *v30;
  int v32;
  int v33;
  int v34;
  int v35;
  NSObject *v36;
  int v37;
  int v38;
  char *v39;
  int v40;
  uint64_t SKEMessageInDialog;
  int v42;
  int v43;
  int v44;
  uint64_t *v45;
  uint64_t v46;
  NSObject *v47;
  _QWORD *v48;
  _QWORD *v49;
  int ErrorLogLevelForModule;
  uint64_t v51;
  NSObject *v52;
  unsigned int v53;
  unint64_t *v54;
  unint64_t v55;
  uint64_t v56;
  NSObject *v57;
  NSObject *v58;
  const char *v59;
  uint64_t v60;
  NSObject *v61;
  int v62;
  int v63;
  uint64_t v64;
  NSObject *v65;
  int v66;
  int v67;
  uint64_t v68;
  NSObject *v69;
  int v70;
  BOOL v71;
  BOOL v72;
  int v73;
  uint64_t v74;
  NSObject *v75;
  uint64_t v76;
  int v77;
  char *v78;
  NSObject *v79;
  uint64_t v80;
  char *v81;
  int v82;
  int v83;
  uint64_t v84;
  NSObject *v85;
  int PeerCertStatus;
  int v87;
  NSObject *v88;
  NSObject *v89;
  const char *v90;
  uint32_t v91;
  uint64_t v92;
  NSObject *v93;
  uint64_t v94;
  NSObject *v95;
  NSObject *v96;
  const char *v97;
  uint64_t v98;
  NSObject *v99;
  uint64_t v100;
  NSObject *v101;
  int v102;
  int v103;
  uint64_t v104;
  NSObject *v105;
  uint64_t v106;
  NSObject *v107;
  int v108;
  int v109;
  uint64_t v110;
  NSObject *v111;
  int v112;
  int v113;
  NSObject *v114;
  int v115;
  int v116;
  uint64_t v117;
  NSObject *v118;
  uint64_t v119;
  NSObject *v120;
  uint64_t v121;
  NSObject *v122;
  int v123;
  const char *v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  int v128;
  uint64_t v129;
  uint64_t v130;
  NSObject *v131;
  uint64_t v132;
  NSObject *v133;
  uint64_t v134;
  void *v135;
  uint64_t v136;
  unsigned int v137;
  uint64_t v138;
  NSObject *v139;
  uint64_t v140;
  NSObject *v141;
  int v142;
  int v143;
  uint64_t v144;
  NSObject *v145;
  int v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  int PeerAbortReason;
  uint64_t v152;
  NSObject *v153;
  uint64_t v154;
  NSObject *v155;
  uint64_t v156;
  uint64_t v157;
  NSObject *v158;
  const __CFAllocator *bytesDeallocator;
  int v160;
  int v161;
  int v162;
  int v163;
  char v164;
  int v165;
  char *ptr;
  void *ptra;
  int v168;
  char *v169;
  int cf;
  int cfa;
  CFDataRef cfb;
  CFTypeRef cfc;
  CFTypeRef cfd;
  unint64_t v175;
  uint64_t v176;
  int v177;
  CFTypeRef v178;
  int v179;
  int v180;
  int v181;
  int v182;
  int v183;
  unsigned __int8 *v184;
  unsigned int v185;
  uint64_t v186;
  const __CFData *v187;
  uint64_t v188;
  uint64_t v189;
  _QWORD *v190;
  int v191;
  int v192;
  uint8_t buf[4];
  uint64_t v194;
  __int16 v195;
  const char *v196;
  __int16 v197;
  int v198;
  __int16 v199;
  _BYTE v200[10];
  _BYTE v201[12];
  int v202;
  uint64_t v203;

  v203 = *MEMORY[0x1E0C80C00];
  v191 = -1431655766;
  v192 = a5;
  v189 = 0xFFFFFFFFLL;
  v190 = 0;
  v187 = 0;
  v188 = 0xFFFFFFFFLL;
  v8 = *a1;
  v186 = 0;
  v185 = -1;
  v184 = 0;
  v183 = 0;
  v181 = 0;
  v182 = 0;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v9 = VRTraceErrorLogLevelToCSTR();
    v10 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      v194 = v9;
      v195 = 2080;
      v196 = "SIPDoKeyExchange";
      v197 = 1024;
      v198 = 2207;
      _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPDoKeyExchange start...", buf, 0x1Cu);
    }
  }
  *a4 = 0;
  v11 = (_DWORD *)CheckInHandleDebug();
  if (!v11)
    return 2148139010;
  v12 = (uint64_t)v11;
  if (!*v11 && !v11[1])
  {
    v13 = 2148139025;
    if ((int)VRTraceGetErrorLogLevelForModule() < 5)
      goto LABEL_29;
    v23 = VRTraceErrorLogLevelToCSTR();
    v24 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      goto LABEL_29;
    *(_DWORD *)buf = 136315906;
    v194 = v23;
    v195 = 2080;
    v196 = "SIPDoKeyExchange";
    v197 = 1024;
    v198 = 2217;
    v199 = 1024;
    *(_DWORD *)v200 = 2217;
    v16 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SIP.c:%d: C"
          "all SIPStartListen first.";
    v17 = v24;
    v20 = 34;
LABEL_28:
    _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, v16, buf, v20);
    goto LABEL_29;
  }
  if (!(_DWORD)a2)
  {
    v13 = 2148139009;
    if ((int)VRTraceGetErrorLogLevelForModule() < 5)
      goto LABEL_29;
    v14 = VRTraceErrorLogLevelToCSTR();
    v15 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      goto LABEL_29;
    *(_DWORD *)buf = 136316162;
    v194 = v14;
    v195 = 2080;
    v196 = "SIPDoKeyExchange";
    v197 = 1024;
    v198 = 2223;
    v199 = 1024;
    *(_DWORD *)v200 = 2223;
    *(_WORD *)&v200[4] = 1024;
    *(_DWORD *)&v200[6] = 0;
    v16 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SIP.c:%d: C"
          "allID(%d) is invalid";
    v17 = v15;
    goto LABEL_21;
  }
  v13 = DLFindWithCallIDAndLock(&v189);
  if ((v13 & 0x80000000) != 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 5)
      goto LABEL_29;
    v18 = VRTraceErrorLogLevelToCSTR();
    v19 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      goto LABEL_29;
    *(_DWORD *)buf = 136316162;
    v194 = v18;
    v195 = 2080;
    v196 = "SIPDoKeyExchange";
    v197 = 1024;
    v198 = 2230;
    v199 = 1024;
    *(_DWORD *)v200 = 2230;
    *(_WORD *)&v200[4] = 1024;
    *(_DWORD *)&v200[6] = a2;
    v16 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SIP.c:%d: C"
          "annot find call ID(%d)";
    v17 = v19;
LABEL_21:
    v20 = 40;
    goto LABEL_28;
  }
  DLSetDoingKeyExchange(v189, 1);
  DLGetState(v189, &v191);
  DLUnlock();
  if (v191 != 3)
  {
    v13 = 2148139025;
    if ((int)VRTraceGetErrorLogLevelForModule() < 5)
      goto LABEL_29;
    v21 = VRTraceErrorLogLevelToCSTR();
    v22 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      goto LABEL_29;
    *(_DWORD *)buf = 136316418;
    v194 = v21;
    v195 = 2080;
    v196 = "SIPDoKeyExchange";
    v197 = 1024;
    v198 = 2239;
    v199 = 1024;
    *(_DWORD *)v200 = 2239;
    *(_WORD *)&v200[4] = 1024;
    *(_DWORD *)&v200[6] = a2;
    *(_WORD *)v201 = 1024;
    *(_DWORD *)&v201[2] = v191;
    v16 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SIP.c:%d: C"
          "all(%d) is in state %d";
    v17 = v22;
    v20 = 46;
    goto LABEL_28;
  }
  if (SecKeyExchangeNodeCreateAsInitiator())
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SIPDoKeyExchange_cold_9();
    }
    goto LABEL_29;
  }
  v13 = SKE_FormMessageS(v187, (void **)&v184, &v182, &v183, &v181);
  CFRelease(v187);
  if ((v13 & 0x80000000) != 0)
  {
    SIPReportSKError(v8, v12, a2, v192, 8, 2262, (uint64_t)"Out of Memory");
    goto LABEL_29;
  }
  v165 = 0;
  v161 = 0;
  ptr = 0;
  v163 = 0;
  v160 = 0;
  v175 = 0;
  bytesDeallocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE20];
  v176 = -1;
  v164 = 1;
LABEL_51:
  v168 = 0;
  v162 = 0;
  v32 = v182;
  while (2)
  {
    v33 = v183;
    cf = v32;
    v34 = v32 - v183;
    if (v34 >= 900)
      v35 = 900;
    else
      v35 = v34;
    ++v175;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v157 = VRTraceErrorLogLevelToCSTR();
      v36 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        if (v35)
        {
          v37 = *v184;
          v38 = v184[v35 - 1];
        }
        else
        {
          v37 = -1;
          v38 = -1;
        }
        *(_DWORD *)buf = 136316674;
        v194 = v157;
        v195 = 2080;
        v196 = "SIPDoKeyExchange";
        v197 = 1024;
        v198 = 2594;
        v199 = 2048;
        *(_QWORD *)v200 = v175;
        *(_WORD *)&v200[8] = 1024;
        *(_DWORD *)v201 = v35;
        *(_WORD *)&v201[4] = 1024;
        *(_DWORD *)&v201[6] = v37;
        *(_WORD *)&v201[10] = 1024;
        v202 = v38;
        _os_log_impl(&dword_1D8A54000, v36, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPDoSKE: (%lu) send (%d) [%02X..%02X]", buf, 0x38u);
      }
    }
    if (v190)
    {
      FreeSipMsg(v190);
      v190 = 0;
    }
    if (v35)
      v39 = (char *)&v184[v33];
    else
      v39 = 0;
    if (v35)
      v40 = (cf + ~v33) / 900;
    else
      v40 = 0;
    SKEMessageInDialog = CreateSKEMessageInDialog((unint64_t *)&v190, v189, v39, v35, v175, v40, *(_DWORD *)(v12 + 16));
    if ((SKEMessageInDialog & 0x80000000) != 0)
    {
      v13 = SKEMessageInDialog;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          SIPDoKeyExchange_cold_1();
      }
      goto LABEL_248;
    }
    TACloseHandle();
    v188 = 0xFFFFFFFFLL;
    v42 = TACreateHandle(&v188, 1, *(_QWORD *)(v12 + 24), (uint64_t)v190, 0xFFFFFFFFLL, (uint64_t)TUMsgCallback, (uint64_t)a1);
    if (v42 < 0)
    {
      LODWORD(v13) = v42;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          SIPDoKeyExchange_cold_2();
      }
      goto LABEL_263;
    }
    v43 = TASetRetransmitTimeoutCap(v188, 2000);
    if (v43 < 0)
    {
      LODWORD(v13) = v43;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          SIPDoKeyExchange_cold_3();
      }
      goto LABEL_263;
    }
    v44 = TAStart((void *)v188);
    LODWORD(v13) = v44;
    v45 = (uint64_t *)v190[34];
    if (v45)
      v176 = *v45;
    v190 = 0;
    if (v44 < 0)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          SIPDoKeyExchange_cold_4();
      }
      goto LABEL_263;
    }
    if (v35)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v156 = VRTraceErrorLogLevelToCSTR();
        v158 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316418;
          v194 = v156;
          v195 = 2080;
          v196 = "SIPDoKeyExchange";
          v197 = 1024;
          v198 = 2638;
          v199 = 1024;
          *(_DWORD *)v200 = v35;
          *(_WORD *)&v200[4] = 1024;
          *(_DWORD *)&v200[6] = cf;
          *(_WORD *)v201 = 1024;
          *(_DWORD *)&v201[2] = v33;
          _os_log_impl(&dword_1D8A54000, v158, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPDoSKE: sent %d of %d at %d", buf, 0x2Eu);
        }
      }
      v183 = v35 + v33;
      if (v35 + v33 == cf)
      {
        v182 = 0;
        v183 = 0;
      }
    }
    if (!(v185 | v35) || v163)
      goto LABEL_263;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          while (1)
          {
            while (1)
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v46 = VRTraceErrorLogLevelToCSTR();
                v47 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 136315906;
                  v194 = v46;
                  v195 = 2080;
                  v196 = "SIPDoKeyExchange";
                  v197 = 1024;
                  v198 = 2270;
                  v199 = 1024;
                  *(_DWORD *)v200 = v175;
                  _os_log_impl(&dword_1D8A54000, v47, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPDoSKE TOP (%d)...", buf, 0x22u);
                }
              }
              v48 = v190;
              v190 = 0;
              LODWORD(v13) = DLGetMsg(v189, &v190, 0x7530uLL, 7, (uint64_t)v48, v176);
              v191 = 0;
              if ((DLGetState(v189, &v191) & 0x80000000) != 0 || v191 != 3)
              {
                if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
                {
                  v121 = VRTraceErrorLogLevelToCSTR();
                  v122 = *MEMORY[0x1E0CF2758];
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 136315906;
                    v194 = v121;
                    v195 = 2080;
                    v196 = "SIPDoKeyExchange";
                    v197 = 1024;
                    v198 = 2281;
                    v199 = 1024;
                    *(_DWORD *)v200 = v191;
                    _os_log_impl(&dword_1D8A54000, v122, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPDoSKE: terminated by remote party (%d)", buf, 0x22u);
                  }
                }
                if (v48)
                  FreeSipMsg(v48);
                goto LABEL_262;
              }
              if ((v13 & 0x80000000) != 0)
              {
                if ((int)VRTraceGetErrorLogLevelForModule() >= 3
                  && (VRTraceErrorLogLevelToCSTR(),
                      os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR)))
                {
                  SIPDoKeyExchange_cold_5();
                  if (!v48)
                    goto LABEL_228;
                }
                else if (!v48)
                {
LABEL_228:
                  v123 = v192;
                  v124 = "Dialog Timeout";
                  v125 = v8;
                  v126 = v12;
                  v127 = a2;
                  v128 = 1;
                  v129 = 2296;
LABEL_237:
                  SIPReportSKError(v125, v126, v127, v123, v128, v129, (uint64_t)v124);
                  goto LABEL_263;
                }
                FreeSipMsg(v48);
                goto LABEL_228;
              }
              if (v48)
                FreeSipMsg(v48);
              v49 = v190;
              ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
              if (!v49)
              {
                if (ErrorLogLevelForModule >= 3)
                {
                  VRTraceErrorLogLevelToCSTR();
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                    SIPDoKeyExchange_cold_6();
                }
                v123 = v192;
                v124 = "NULL Message";
                v125 = v8;
                v126 = v12;
                v127 = a2;
                v128 = 2;
                v129 = 2307;
                goto LABEL_237;
              }
              if (ErrorLogLevelForModule >= 7)
              {
                v51 = VRTraceErrorLogLevelToCSTR();
                v52 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 136315906;
                  v194 = v51;
                  v195 = 2080;
                  v196 = "SIPDoKeyExchange";
                  v197 = 1024;
                  v198 = 2311;
                  v199 = 2048;
                  *(_QWORD *)v200 = v190;
                  _os_log_impl(&dword_1D8A54000, v52, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPDoSKE: got msg %p", buf, 0x26u);
                }
              }
              if (*((_DWORD *)v190 + 1) == 2)
                break;
              if (*((_DWORD *)v190 + 2) == 5)
              {
                if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
                {
                  v130 = VRTraceErrorLogLevelToCSTR();
                  v131 = *MEMORY[0x1E0CF2758];
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 136315650;
                    v194 = v130;
                    v195 = 2080;
                    v196 = "SIPDoKeyExchange";
                    v197 = 1024;
                    v198 = 2316;
                    _os_log_impl(&dword_1D8A54000, v131, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPDoSKE: cancelled", buf, 0x1Cu);
                  }
                }
                v123 = v192;
                v124 = "Cancelled";
                v125 = v8;
                v126 = v12;
                v127 = a2;
                v128 = 5;
                v129 = 2317;
                goto LABEL_237;
              }
              if ((DLPutMsg(v189, (uint64_t)v190, 1) & 0x80000000) != 0)
              {
                if ((int)VRTraceGetErrorLogLevelForModule() < 7)
                  goto LABEL_269;
                v132 = VRTraceErrorLogLevelToCSTR();
                v133 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 136315650;
                  v194 = v132;
                  v195 = 2080;
                  v196 = "SIPDoKeyExchange";
                  v197 = 1024;
                  v198 = 2323;
                  goto LABEL_261;
                }
LABEL_262:
                LODWORD(v13) = -2146828235;
LABEL_263:
                v137 = v165;
                v135 = ptr;
                goto LABEL_264;
              }
              v190 = 0;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
              {
                v60 = VRTraceErrorLogLevelToCSTR();
                v61 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 136315650;
                  v194 = v60;
                  v195 = 2080;
                  v196 = "SIPDoKeyExchange";
                  v197 = 1024;
                  v198 = 2329;
                  v58 = v61;
                  v59 = "SIP [%s] %s:%d SIPDoSKE: skip msg";
                  goto LABEL_117;
                }
              }
            }
            if (*(_DWORD *)(v190[34] + 8) == 7)
              break;
            v62 = DLPutMsg(v189, (uint64_t)v190, 1);
            v63 = VRTraceGetErrorLogLevelForModule();
            if (v62 < 0)
            {
              if (v63 >= 7)
              {
                v134 = VRTraceErrorLogLevelToCSTR();
                v133 = *MEMORY[0x1E0CF2758];
                if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                  goto LABEL_262;
                *(_DWORD *)buf = 136315650;
                v194 = v134;
                v195 = 2080;
                v196 = "SIPDoKeyExchange";
                v197 = 1024;
                v198 = 2336;
LABEL_261:
                _os_log_impl(&dword_1D8A54000, v133, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPDoSKE: terminated by remote party", buf, 0x1Cu);
                goto LABEL_262;
              }
LABEL_269:
              LODWORD(v13) = -2146828235;
              goto LABEL_263;
            }
            if (v63 >= 7)
            {
              v64 = VRTraceErrorLogLevelToCSTR();
              v65 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315650;
                v194 = v64;
                v195 = 2080;
                v196 = "SIPDoKeyExchange";
                v197 = 1024;
                v198 = 2341;
                v58 = v65;
                v59 = "SIP [%s] %s:%d SIPDoSKE: not MT_MESSAGE";
                goto LABEL_117;
              }
            }
          }
          v53 = *((_DWORD *)v190 + 2);
          if (v53 > 0x34 || ((1 << v53) & 0x100000000000C0) == 0)
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v138 = VRTraceErrorLogLevelToCSTR();
              v139 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315650;
                v194 = v138;
                v195 = 2080;
                v196 = "SIPDoKeyExchange";
                v197 = 1024;
                v198 = 2349;
                _os_log_impl(&dword_1D8A54000, v139, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPDoSKE: SKE unsuccessful", buf, 0x1Cu);
              }
            }
            LODWORD(v13) = v53 | 0x900A0000;
            SIPReportSKError(v8, v12, a2, v192, 9, 2351, (uint64_t)"Unsuccessful");
            goto LABEL_263;
          }
          v54 = (unint64_t *)v190[66];
          if (v54)
            break;
          v66 = DLPutMsg(v189, (uint64_t)v190, 1);
          v67 = VRTraceGetErrorLogLevelForModule();
          if (v66 < 0)
          {
            if (v67 >= 7)
            {
              v136 = VRTraceErrorLogLevelToCSTR();
              v133 = *MEMORY[0x1E0CF2758];
              if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                goto LABEL_262;
              *(_DWORD *)buf = 136315650;
              v194 = v136;
              v195 = 2080;
              v196 = "SIPDoKeyExchange";
              v197 = 1024;
              v198 = 2358;
              goto LABEL_261;
            }
            goto LABEL_269;
          }
          if (v67 >= 7)
          {
            v68 = VRTraceErrorLogLevelToCSTR();
            v69 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315650;
              v194 = v68;
              v195 = 2080;
              v196 = "SIPDoKeyExchange";
              v197 = 1024;
              v198 = 2363;
              v58 = v69;
              v59 = "SIP [%s] %s:%d SIPDoSKE: message doesn't have SKESeq";
LABEL_117:
              _os_log_impl(&dword_1D8A54000, v58, OS_LOG_TYPE_DEFAULT, v59, buf, 0x1Cu);
            }
          }
        }
        v55 = *v54;
        if (*v54 >= v175)
          break;
        FreeSipMsg(v190);
        v190 = 0;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v56 = VRTraceErrorLogLevelToCSTR();
          v57 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315650;
            v194 = v56;
            v195 = 2080;
            v196 = "SIPDoKeyExchange";
            v197 = 1024;
            v198 = 2376;
            v58 = v57;
            v59 = "SIP [%s] %s:%d SIPDoSKE: SKESeq old";
            goto LABEL_117;
          }
        }
      }
      if (*v54 > v175)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v140 = VRTraceErrorLogLevelToCSTR();
          v141 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315906;
            v194 = v140;
            v195 = 2080;
            v196 = "SIPDoKeyExchange";
            v197 = 1024;
            v198 = 2381;
            v199 = 1024;
            *(_DWORD *)v200 = v55;
            _os_log_impl(&dword_1D8A54000, v141, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPDoSKE: SKESeq (%d) unexpected", buf, 0x22u);
          }
        }
        SIPReportSKError(v8, v12, a2, v192, 6, 2383, (uint64_t)"Out Of Sequence");
        LODWORD(v13) = -1073086451;
        goto LABEL_263;
      }
      v70 = *((_DWORD *)v54 + 2);
      v71 = !v168 || v168 - 1 == v70;
      v72 = v71;
      if ((v70 & 0x80000000) == 0 && v72)
        break;
      v73 = v70;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v74 = VRTraceErrorLogLevelToCSTR();
        v75 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316162;
          v194 = v74;
          v195 = 2080;
          v196 = "SIPDoKeyExchange";
          v197 = 1024;
          v198 = 2392;
          v199 = 1024;
          *(_DWORD *)v200 = v175;
          *(_WORD *)&v200[4] = 1024;
          *(_DWORD *)&v200[6] = v73;
          _os_log_impl(&dword_1D8A54000, v75, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPDoSKE: SKESeq (%d,%d)", buf, 0x28u);
        }
      }
    }
    v76 = *((unsigned int *)v190 + 140);
    if ((int)v76 < 1 || !v190[69])
      goto LABEL_144;
    cfa = v70;
    if (ptr)
    {
      v77 = v76 + v162;
      if (v161 >= v77)
      {
        v78 = ptr;
      }
      else
      {
        v78 = (char *)malloc_type_realloc(ptr, v77 + 2000, 0x6FEF2E28uLL);
        if (!v78)
        {
          v142 = VRTraceGetErrorLogLevelForModule();
          if (v142 >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              SIPDoKeyExchange_cold_8();
          }
          LODWORD(v13) = -1073086461;
          v123 = v192;
          v124 = "Out of Memory";
          v125 = v8;
          v126 = v12;
          v127 = a2;
          v128 = 8;
          v129 = 2417;
          goto LABEL_237;
        }
      }
LABEL_140:
      v169 = v78;
      memcpy(&v78[v162], (const void *)v190[69], *((int *)v190 + 140));
      v162 += *((_DWORD *)v190 + 140);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        ptra = (void *)VRTraceErrorLogLevelToCSTR();
        v79 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v80 = *((int *)v190 + 140);
          v81 = (char *)v190[69];
          v82 = *v81;
          LODWORD(v81) = v81[v80 - 1];
          *(_DWORD *)buf = 136316674;
          v194 = (uint64_t)ptra;
          v195 = 2080;
          v196 = "SIPDoKeyExchange";
          v197 = 1024;
          v198 = 2430;
          v199 = 1024;
          *(_DWORD *)v200 = v175;
          *(_WORD *)&v200[4] = 1024;
          *(_DWORD *)&v200[6] = v80;
          *(_WORD *)v201 = 1024;
          *(_DWORD *)&v201[2] = v82;
          *(_WORD *)&v201[6] = 1024;
          *(_DWORD *)&v201[8] = (_DWORD)v81;
          _os_log_impl(&dword_1D8A54000, v79, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPDoSKE: Got msg (%d) - (%d) [%02X...%02X]", buf, 0x34u);
        }
      }
      ptr = v169;
      v70 = cfa;
LABEL_144:
      if (v70)
      {
        v32 = 0;
        v163 = 0;
        v182 = 0;
        v183 = 0;
        v168 = v70;
        continue;
      }
      v163 = 0;
      v32 = v182;
      v168 = 0;
      if (v182 <= 0)
      {
        cfb = CFDataCreateWithBytesNoCopy(0, (const UInt8 *)ptr, v162, bytesDeallocator);
        v83 = SecKeyExchangeUpdate();
        if (v83)
        {
          v143 = v83;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v144 = VRTraceErrorLogLevelToCSTR();
            v145 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315906;
              v194 = v144;
              v195 = 2080;
              v196 = "SIPDoKeyExchange";
              v197 = 1024;
              v198 = 2452;
              v199 = 1024;
              *(_DWORD *)v200 = v143;
              _os_log_impl(&dword_1D8A54000, v145, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SecKeyExchangeUpdate failed (%d)", buf, 0x22u);
            }
          }
          SIPReportSKError(v8, v12, a2, v192, 10, 2453, (uint64_t)"Update Failed");
          CFRelease(cfb);
          goto LABEL_263;
        }
        CFRelease(cfb);
        v13 = SKE_FormMessageS(v187, (void **)&v184, &v182, &v183, &v181);
        if (v187)
          CFRelease(v187);
        if ((v13 & 0x80000000) != 0)
        {
          v146 = v192;
          v147 = v8;
          v148 = v12;
          v149 = a2;
          v150 = 2464;
        }
        else
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v84 = VRTraceErrorLogLevelToCSTR();
            v85 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136316418;
              v194 = v84;
              v195 = 2080;
              v196 = "SIPDoKeyExchange";
              v197 = 1024;
              v198 = 2468;
              v199 = 1024;
              *(_DWORD *)v200 = 0;
              *(_WORD *)&v200[4] = 1024;
              *(_DWORD *)&v200[6] = v185;
              *(_WORD *)v201 = 2048;
              *(_QWORD *)&v201[2] = v187;
              _os_log_impl(&dword_1D8A54000, v85, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPDoSKE: u= %d,%d,[%p]", buf, 0x32u);
            }
          }
          if (v185 == 2)
          {
            LODWORD(v178) = -1431655766;
            v180 = -1431655766;
            PeerAbortReason = SecKeyExchangeGetPeerAbortReason();
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v152 = VRTraceErrorLogLevelToCSTR();
              v153 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136316418;
                v194 = v152;
                v195 = 2080;
                v196 = "SIPDoKeyExchange";
                v197 = 1024;
                v198 = 2475;
                v199 = 1024;
                *(_DWORD *)v200 = v180;
                *(_WORD *)&v200[4] = 1024;
                *(_DWORD *)&v200[6] = (_DWORD)v178;
                *(_WORD *)v201 = 1024;
                *(_DWORD *)&v201[2] = PeerAbortReason;
                _os_log_impl(&dword_1D8A54000, v153, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPDoSKE: aborted by remote: %d (%d %d)", buf, 0x2Eu);
              }
            }
            SIPReportSKError(v8, v12, a2, v192, 12, 2477, (uint64_t)"Aborted");
            LODWORD(v13) = -1073086434;
            goto LABEL_263;
          }
          if (v185 >= 2)
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v154 = VRTraceErrorLogLevelToCSTR();
              v155 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315906;
                v194 = v154;
                v195 = 2080;
                v196 = "SIPDoKeyExchange";
                v197 = 1024;
                v198 = 2482;
                v199 = 1024;
                *(_DWORD *)v200 = v185;
                _os_log_impl(&dword_1D8A54000, v155, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPDoSKE: error while SKEUpdate (%d)", buf, 0x22u);
              }
            }
            SIPReportSKError(v8, v12, a2, v192, 11, 2484, (uint64_t)"Update Error");
            LODWORD(v13) = -1073086460;
            goto LABEL_263;
          }
          if (!*(_QWORD *)(v12 + 48) || v160)
            goto LABEL_200;
          v179 = -1431655766;
          v180 = -1431655766;
          v178 = 0;
          PeerCertStatus = SecKeyExchangeGetPeerCertStatus();
          if (PeerCertStatus)
          {
            v87 = PeerCertStatus;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              cfc = (CFTypeRef)VRTraceErrorLogLevelToCSTR();
              v88 = *MEMORY[0x1E0CF2758];
              v160 = 0;
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315906;
                v194 = (uint64_t)cfc;
                v195 = 2080;
                v196 = "SIPDoKeyExchange";
                v197 = 1024;
                v198 = 2499;
                v199 = 1024;
                *(_DWORD *)v200 = v87;
                v89 = v88;
                v90 = "SIP [%s] %s:%d SKE peerCertStatus failed (%d)";
                goto LABEL_162;
              }
LABEL_200:
              if (v53 == 52)
              {
                *a4 = 0;
                v163 = 1;
                v164 = 0;
                v165 = -1878392780;
              }
              else
              {
                v163 = 0;
                if (!v185)
                {
                  v108 = SecKeyExchangeCopySharedSecret();
                  v163 = 0;
                  if (v108)
                  {
                    v109 = v108;
                    v163 = 0;
                    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
                    {
                      v110 = VRTraceErrorLogLevelToCSTR();
                      v111 = *MEMORY[0x1E0CF2758];
                      v163 = 0;
                      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)buf = 136315906;
                        v194 = v110;
                        v195 = 2080;
                        v196 = "SIPDoKeyExchange";
                        v197 = 1024;
                        v198 = 2580;
                        v199 = 1024;
                        *(_DWORD *)v200 = v109;
                        _os_log_impl(&dword_1D8A54000, v111, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SecKeyExchangeCopySharedSecret error %d", buf, 0x22u);
                        v163 = 0;
                      }
                    }
                  }
                }
              }
              goto LABEL_51;
            }
LABEL_199:
            v160 = 0;
            goto LABEL_200;
          }
          if (v179)
          {
            if (v179 != 2)
            {
              if (v179 == 1)
              {
                if ((int)VRTraceGetErrorLogLevelForModule() < 7)
                  goto LABEL_199;
                v92 = VRTraceErrorLogLevelToCSTR();
                v93 = *MEMORY[0x1E0CF2758];
                v160 = 0;
                if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                  goto LABEL_200;
                *(_DWORD *)buf = 136315650;
                v194 = v92;
                v195 = 2080;
                v196 = "SIPDoKeyExchange";
                v197 = 1024;
                v198 = 2502;
                v89 = v93;
                v90 = "SIP [%s] %s:%d SKE peerCertStatus not yet valid";
              }
              else
              {
                if ((int)VRTraceGetErrorLogLevelForModule() < 7)
                  goto LABEL_199;
                v106 = VRTraceErrorLogLevelToCSTR();
                v107 = *MEMORY[0x1E0CF2758];
                v160 = 0;
                if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                  goto LABEL_200;
                *(_DWORD *)buf = 136315650;
                v194 = v106;
                v195 = 2080;
                v196 = "SIPDoKeyExchange";
                v197 = 1024;
                v198 = 2509;
                v89 = v107;
                v90 = "SIP [%s] %s:%d SKE peerCertStatus not ready";
              }
LABEL_197:
              v91 = 28;
LABEL_198:
              _os_log_impl(&dword_1D8A54000, v89, OS_LOG_TYPE_DEFAULT, v90, buf, v91);
              goto LABEL_199;
            }
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v98 = VRTraceErrorLogLevelToCSTR();
              v99 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315650;
                v194 = v98;
                v195 = 2080;
                v196 = "SIPDoKeyExchange";
                v197 = 1024;
                v198 = 2505;
                v96 = v99;
                v97 = "SIP [%s] %s:%d SKE peerCertStatus no value";
LABEL_176:
                _os_log_impl(&dword_1D8A54000, v96, OS_LOG_TYPE_DEFAULT, v97, buf, 0x1Cu);
              }
            }
            goto LABEL_177;
          }
          if (v180 == 1)
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v94 = VRTraceErrorLogLevelToCSTR();
              v95 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315650;
                v194 = v94;
                v195 = 2080;
                v196 = "SIPDoKeyExchange";
                v197 = 1024;
                v198 = 2512;
                v96 = v95;
                v97 = "SIP [%s] %s:%d SKE no cert";
                goto LABEL_176;
              }
            }
LABEL_177:
            v178 = 0;
          }
          else
          {
            v112 = SecKeyExchangeCopyPeerCert();
            if (v112)
            {
              v113 = v112;
              if ((int)VRTraceGetErrorLogLevelForModule() < 7)
                goto LABEL_199;
              cfd = (CFTypeRef)VRTraceErrorLogLevelToCSTR();
              v114 = *MEMORY[0x1E0CF2758];
              v160 = 0;
              if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                goto LABEL_200;
              *(_DWORD *)buf = 136315906;
              v194 = (uint64_t)cfd;
              v195 = 2080;
              v196 = "SIPDoKeyExchange";
              v197 = 1024;
              v198 = 2519;
              v199 = 1024;
              *(_DWORD *)v200 = v113;
              v89 = v114;
              v90 = "SIP [%s] %s:%d SKE CopyCert failed (%d)";
LABEL_162:
              v91 = 34;
              goto LABEL_198;
            }
            v115 = v179;
            v116 = VRTraceGetErrorLogLevelForModule();
            if (v115 == 1)
            {
              if (v116 < 7)
                goto LABEL_199;
              v117 = VRTraceErrorLogLevelToCSTR();
              v118 = *MEMORY[0x1E0CF2758];
              v160 = 0;
              if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                goto LABEL_200;
              *(_DWORD *)buf = 136315650;
              v194 = v117;
              v195 = 2080;
              v196 = "SIPDoKeyExchange";
              v197 = 1024;
              v198 = 2522;
              v89 = v118;
              v90 = "SIP [%s] %s:%d SKE CopyCert not yet valid";
              goto LABEL_197;
            }
            if (v116 >= 7)
            {
              v119 = VRTraceErrorLogLevelToCSTR();
              v120 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315650;
                v194 = v119;
                v195 = 2080;
                v196 = "SIPDoKeyExchange";
                v197 = 1024;
                v198 = 2525;
                _os_log_impl(&dword_1D8A54000, v120, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SKE CopyCert succeeded", buf, 0x1Cu);
              }
            }
          }
          v177 = 0;
          (*(void (**)(uint64_t, _QWORD, uint64_t, uint64_t, const char *, int *, CFTypeRef, int *))(v12 + 32))(v8, *(_QWORD *)(v12 + 40), 6, a2, "SKECheckRemoteCert", &v177, v178, &v192);
          if (v178)
            CFRelease(v178);
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v100 = VRTraceErrorLogLevelToCSTR();
            v101 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315906;
              v194 = v100;
              v195 = 2080;
              v196 = "SIPDoKeyExchange";
              v197 = 1024;
              v198 = 2540;
              v199 = 1024;
              *(_DWORD *)v200 = v177;
              _os_log_impl(&dword_1D8A54000, v101, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d ~_~ SIPDoSKE isValid = %d", buf, 0x22u);
            }
          }
          if (v177)
          {
LABEL_193:
            v160 = 1;
            goto LABEL_200;
          }
          if (!v185)
            goto LABEL_192;
          v102 = SecKeyExchangeAbortSession();
          if (v102)
          {
            v103 = v102;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v104 = VRTraceErrorLogLevelToCSTR();
              v105 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315906;
                v194 = v104;
                v195 = 2080;
                v196 = "SIPDoKeyExchange";
                v197 = 1024;
                v198 = 2549;
                v199 = 1024;
                *(_DWORD *)v200 = v103;
                _os_log_impl(&dword_1D8A54000, v105, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SKE abort error %d", buf, 0x22u);
              }
            }
          }
          v13 = SKE_FormMessageS(v187, (void **)&v184, &v182, &v183, &v181);
          if (v187)
            CFRelease(v187);
          if ((v13 & 0x80000000) == 0)
          {
LABEL_192:
            v53 = 52;
            goto LABEL_193;
          }
          v146 = v192;
          v147 = v8;
          v148 = v12;
          v149 = a2;
          v150 = 2555;
        }
        SIPReportSKError(v147, v148, v149, v146, 8, v150, (uint64_t)"Out of Memory");
LABEL_248:
        v135 = ptr;
        goto LABEL_267;
      }
      continue;
    }
    break;
  }
  v161 = v76 + 2000;
  v78 = (char *)malloc_type_malloc(v76 + 2000, 0xA6E6A7C7uLL);
  if (v78)
    goto LABEL_140;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      SIPDoKeyExchange_cold_7();
  }
  LODWORD(v13) = -1073086461;
  SIPReportSKError(v8, v12, a2, v192, 8, 2408, (uint64_t)"Out of Memory");
  v135 = 0;
  v137 = v165;
LABEL_264:
  if ((v164 & 1) != 0)
    v13 = v13;
  else
    v13 = v137;
LABEL_267:
  if (v135)
    free(v135);
LABEL_29:
  if (v184)
    free(v184);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v25 = VRTraceErrorLogLevelToCSTR();
    v26 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      v194 = v25;
      v195 = 2080;
      v196 = "SIPDoKeyExchange";
      v197 = 1024;
      v198 = 2668;
      _os_log_impl(&dword_1D8A54000, v26, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPDoKeyExchange Done:", buf, 0x1Cu);
    }
  }
  if ((DLSetDoingKeyExchange(v189, 0) & 0x80000000) != 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v27 = VRTraceErrorLogLevelToCSTR();
      v28 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        v194 = v27;
        v195 = 2080;
        v196 = "SIPDoKeyExchange";
        v197 = 1024;
        v198 = 2671;
        _os_log_impl(&dword_1D8A54000, v28, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPDoSKE: terminated by remote party", buf, 0x1Cu);
      }
    }
    v13 = 2148139061;
  }
  if (v186)
    SecKeyExchangeNodeRelease();
  if ((v13 & 0x90000000) == 0x80000000)
    TACancel();
  if (v190)
    FreeSipMsg(v190);
  TACloseHandle();
  CheckOutHandleDebug();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v29 = VRTraceErrorLogLevelToCSTR();
    v30 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      v194 = v29;
      v195 = 2080;
      v196 = "SIPDoKeyExchange";
      v197 = 1024;
      v198 = 2693;
      v199 = 1024;
      *(_DWORD *)v200 = v13;
      _os_log_impl(&dword_1D8A54000, v30, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPDoKeyExchange stop(%X)...", buf, 0x22u);
    }
  }
  return v13;
}

uint64_t SIPCancel(uint64_t a1, int a2)
{
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  _DWORD *v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  NSObject *v11;
  const char *v12;
  NSObject *v13;
  uint32_t v14;
  uint64_t v15;
  NSObject *v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v20;
  void *v21;
  uint8_t buf[4];
  uint64_t v23;
  __int16 v24;
  const char *v25;
  __int16 v26;
  int v27;
  __int16 v28;
  int v29;
  __int16 v30;
  int v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v20 = 0xAAAAAAAAAAAAAAAALL;
  v21 = (void *)0xAAAAAAAAAAAAAAAALL;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v3 = VRTraceErrorLogLevelToCSTR();
    v4 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      v23 = v3;
      v24 = 2080;
      v25 = "SIPCancel";
      v26 = 1024;
      v27 = 2717;
      _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPCancel start...", buf, 0x1Cu);
    }
  }
  v5 = 2148139025;
  v6 = (_DWORD *)CheckInHandleDebug();
  if (!v6)
    return 2148139010;
  if (*v6 || v6[1])
  {
    v7 = DLFindWithCallIDAndLock(&v20);
    if ((v7 & 0x80000000) == 0)
    {
      DLUnlock();
      v8 = CreateCancel(&v21, 0);
      if ((v8 & 0x80000000) != 0)
      {
        v5 = v8;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            SIPCancel_cold_1();
        }
      }
      else
      {
        v9 = v21;
        *(_DWORD *)v21 = 1;
        v5 = DLPutMsg(v20, (uint64_t)v9, 0);
        if ((v5 & 0x80000000) != 0)
        {
          FreeSipMsg(v21);
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              SIPCancel_cold_2();
          }
        }
      }
      goto LABEL_24;
    }
    v5 = v7;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v10 = VRTraceErrorLogLevelToCSTR();
      v11 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136316162;
        v23 = v10;
        v24 = 2080;
        v25 = "SIPCancel";
        v26 = 1024;
        v27 = 2732;
        v28 = 1024;
        v29 = 2732;
        v30 = 1024;
        v31 = a2;
        v12 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SIP.c:%"
              "d: Cannot find call ID(%d)";
        v13 = v11;
        v14 = 40;
LABEL_23:
        _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, v12, buf, v14);
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v15 = VRTraceErrorLogLevelToCSTR();
    v16 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      v23 = v15;
      v24 = 2080;
      v25 = "SIPCancel";
      v26 = 1024;
      v27 = 2725;
      v28 = 1024;
      v29 = 2725;
      v12 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SIP.c:%d:"
            " Call SIPStartListen first.";
      v13 = v16;
      v14 = 34;
      goto LABEL_23;
    }
  }
LABEL_24:
  TPDiscardConnectionResult();
  CheckOutHandleDebug();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v17 = VRTraceErrorLogLevelToCSTR();
    v18 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      v23 = v17;
      v24 = 2080;
      v25 = "SIPCancel";
      v26 = 1024;
      v27 = 2756;
      v28 = 1024;
      v29 = v5;
      _os_log_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPCancel stop(%X)...", buf, 0x22u);
    }
  }
  return v5;
}

uint64_t SIPHangup(uint64_t *a1, uint64_t a2, int a3)
{
  return SIPHangupWithTimeout(a1, a2, 0xFFFFFFFFuLL, a3);
}

uint64_t SIPHangupWithTimeout(uint64_t *a1, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  _DWORD *v12;
  _DWORD *v13;
  uint64_t v14;
  uint64_t Bye;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  NSObject *v22;
  uint64_t v23;
  NSObject *v24;
  uint64_t v25;
  NSObject *v26;
  uint64_t v27;
  NSObject *v28;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  void *v33;
  int v34;
  uint8_t buf[4];
  uint64_t v36;
  __int16 v37;
  const char *v38;
  __int16 v39;
  int v40;
  __int16 v41;
  int v42;
  __int16 v43;
  _QWORD v44[2];
  _BYTE __b[904];
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  v34 = -1431655766;
  v32 = (void *)0xAAAAAAAAAAAAAAAALL;
  v33 = (void *)0xAAAAAAAAAAAAAAAALL;
  memset(__b, 170, sizeof(__b));
  v30 = 0xFFFFFFFFLL;
  v31 = 0xFFFFFFFFLL;
  v8 = *a1;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v9 = VRTraceErrorLogLevelToCSTR();
    v10 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136316162;
      v36 = v9;
      v37 = 2080;
      v38 = "SIPHangupWithTimeout";
      v39 = 1024;
      v40 = 2780;
      v41 = 1024;
      v42 = a4;
      v43 = 2080;
      v44[0] = "Remote Hang Up";
      _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPHangup start with detailed code (%u), Reason:(%s)", buf, 0x2Cu);
    }
  }
  v11 = 2148139025;
  v12 = (_DWORD *)CheckInHandleDebug();
  if (!v12)
    return 2148139010;
  v13 = v12;
  if (*v12 || v12[1])
  {
    v14 = DLFindWithCallIDAndLock(&v31);
    if ((v14 & 0x80000000) != 0)
    {
      v20 = v14;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v21 = VRTraceErrorLogLevelToCSTR();
        v22 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316162;
          v36 = v21;
          v37 = 2080;
          v38 = "SIPHangupWithTimeout";
          v39 = 1024;
          v40 = 2795;
          v41 = 1024;
          v42 = 2795;
          v43 = 1024;
          LODWORD(v44[0]) = a2;
          _os_log_impl(&dword_1D8A54000, v22, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SIP.c:%d: Cannot find call ID(%d)", buf, 0x28u);
        }
      }
      v11 = v20;
    }
    else
    {
      DLGetData(v31, (uint64_t)__b);
      DLGetState(v31, &v34);
      if (v34 == 3)
      {
        DLSetState(v31, 5);
        DLUnlock();
        Bye = CreateBye((unint64_t *)&v33, v31, a4, (uint64_t)"Remote Hang Up", v13[4]);
        if ((Bye & 0x80000000) != 0)
        {
          v11 = Bye;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              SIPHangupWithTimeout_cold_1();
          }
        }
        else
        {
          v16 = TACreateHandle(&v30, 1, *((_QWORD *)v13 + 3), (uint64_t)v33, 0xFFFFFFFFLL, (uint64_t)TUMsgCallback, (uint64_t)a1);
          if ((v16 & 0x80000000) != 0)
          {
            v11 = v16;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                SIPHangupWithTimeout_cold_2();
            }
            v18 = v33;
LABEL_39:
            FreeSipMsg(v18);
          }
          else
          {
            v17 = TAStart((void *)v30);
            if ((v17 & 0x80000000) == 0)
            {
              while (1)
              {
                while (1)
                {
                  v11 = DLGetMsg(v31, &v32, a3, 4, (uint64_t)v33, -1);
                  if ((v11 & 0x80000000) != 0)
                  {
                    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                    {
                      VRTraceErrorLogLevelToCSTR();
                      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                        SIPHangupWithTimeout_cold_4();
                    }
                    goto LABEL_46;
                  }
                  v18 = v32;
                  if (*((_DWORD *)v32 + 1) == 2)
                    break;
LABEL_16:
                  FreeSipMsg(v18);
                }
                v19 = *((_DWORD *)v32 + 2);
                if ((v19 - 1) <= 4)
                {
                  (*((void (**)(uint64_t, _QWORD, uint64_t, uint64_t, char *, _QWORD, _QWORD, _QWORD))v13 + 4))(v8, *((_QWORD *)v13 + 5), 4, a2, (char *)v32 + 12, 0, 0, 0);
                  v18 = v32;
                  goto LABEL_16;
                }
                if ((v19 & 0xFFFFFFFE) == 6)
                  goto LABEL_39;
                if ((v19 - 8) <= 0x2C)
                {
                  v11 = v19 | 0x900A0000;
                  goto LABEL_39;
                }
              }
            }
            v11 = v17;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                SIPHangupWithTimeout_cold_3();
            }
          }
        }
      }
      else
      {
        DLUnlock();
        if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          v23 = VRTraceErrorLogLevelToCSTR();
          v24 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136316418;
            v36 = v23;
            v37 = 2080;
            v38 = "SIPHangupWithTimeout";
            v39 = 1024;
            v40 = 2804;
            v41 = 1024;
            v42 = 2804;
            v43 = 1024;
            LODWORD(v44[0]) = a2;
            WORD2(v44[0]) = 1024;
            *(_DWORD *)((char *)v44 + 6) = v34;
            _os_log_impl(&dword_1D8A54000, v24, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SIP.c:%d: Call(%d) is in state %d", buf, 0x2Eu);
          }
        }
        v31 = 0xFFFFFFFFLL;
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v25 = VRTraceErrorLogLevelToCSTR();
    v26 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      v36 = v25;
      v37 = 2080;
      v38 = "SIPHangupWithTimeout";
      v39 = 1024;
      v40 = 2788;
      v41 = 1024;
      v42 = 2788;
      _os_log_impl(&dword_1D8A54000, v26, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SIP.c:%d: Call SIPStartListen first.", buf, 0x22u);
    }
  }
LABEL_46:
  TPDiscardConnectionResult();
  if ((v11 & 0x90000000) == 0x80000000)
    TACancel();
  DLCloseHandle();
  TACloseHandle();
  CheckOutHandleDebug();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v27 = VRTraceErrorLogLevelToCSTR();
    v28 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      v36 = v27;
      v37 = 2080;
      v38 = "SIPHangupWithTimeout";
      v39 = 1024;
      v40 = 2873;
      v41 = 1024;
      v42 = v11;
      _os_log_impl(&dword_1D8A54000, v28, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPHangup stop(%X)...", buf, 0x22u);
    }
  }
  return v11;
}

uint64_t SIPCloseCall(uint64_t a1, int a2)
{
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  _DWORD *v6;
  _DWORD *v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v17;
  int v18;
  uint8_t buf[4];
  uint64_t v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  _BYTE __b[904];
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v18 = -1431655766;
  memset(__b, 170, sizeof(__b));
  v17 = 0xFFFFFFFFLL;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v3 = VRTraceErrorLogLevelToCSTR();
    v4 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      v20 = v3;
      v21 = 2080;
      v22 = "SIPCloseCall";
      v23 = 1024;
      v24 = 2885;
      _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPCloseCall start...", buf, 0x1Cu);
    }
  }
  v5 = 2148139025;
  v6 = (_DWORD *)CheckInHandleDebug();
  if (!v6)
    return 2148139010;
  v7 = v6;
  if (!*v6 && !v6[1])
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 5)
      goto LABEL_21;
    v12 = VRTraceErrorLogLevelToCSTR();
    v13 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      v20 = v12;
      v21 = 2080;
      v22 = "SIPCloseCall";
      v23 = 1024;
      v24 = 2893;
      v25 = 1024;
      v26 = 2893;
      _os_log_impl(&dword_1D8A54000, v13, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SIP.c:%d: Call SIPStartListen first.", buf, 0x22u);
    }
    goto LABEL_13;
  }
  v5 = DLFindWithCallIDAndLock(&v17);
  if ((v5 & 0x80000000) != 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v10 = VRTraceErrorLogLevelToCSTR();
      v11 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136316162;
        v20 = v10;
        v21 = 2080;
        v22 = "SIPCloseCall";
        v23 = 1024;
        v24 = 2900;
        v25 = 1024;
        v26 = 2900;
        v27 = 1024;
        v28 = a2;
        _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SIP.c:%d: Cannot find call ID(%d)", buf, 0x28u);
      }
    }
    goto LABEL_21;
  }
  DLGetState(v17, &v18);
  DLGetData(v17, (uint64_t)__b);
  DLUnlock();
  TPStopHeartbeat(*((_QWORD *)v7 + 3), (uint64_t)&__b[148]);
  if (v18 != 3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v8 = VRTraceErrorLogLevelToCSTR();
      v9 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136316418;
        v20 = v8;
        v21 = 2080;
        v22 = "SIPCloseCall";
        v23 = 1024;
        v24 = 2909;
        v25 = 1024;
        v26 = 2909;
        v27 = 1024;
        v28 = a2;
        v29 = 1024;
        v30 = v18;
        _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SIP.c:%d: Call(%d) is in state %d", buf, 0x2Eu);
      }
    }
    v17 = 0xFFFFFFFFLL;
LABEL_13:
    v5 = 2148139025;
  }
LABEL_21:
  TPDiscardConnectionResult();
  DLCloseHandle();
  CheckOutHandleDebug();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v14 = VRTraceErrorLogLevelToCSTR();
    v15 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      v20 = v14;
      v21 = 2080;
      v22 = "SIPCloseCall";
      v23 = 1024;
      v24 = 2921;
      v25 = 1024;
      v26 = v5;
      _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPCloseCall stop(%X)...", buf, 0x22u);
    }
  }
  return v5;
}

uint64_t SIPSendMessage(uint64_t *a1, uint64_t a2, char *a3, _DWORD *a4)
{
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  _DWORD *v12;
  _DWORD *v13;
  uint64_t v14;
  uint64_t MessageInDialog;
  void *v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  int v22;
  uint64_t v23;
  NSObject *v24;
  uint64_t v25;
  NSObject *v26;
  const char *v27;
  NSObject *v28;
  uint32_t v29;
  uint64_t v30;
  NSObject *v31;
  uint64_t v32;
  NSObject *v33;
  uint64_t v34;
  NSObject *v35;
  _QWORD *v36;
  uint64_t v37;
  NSObject *v38;
  uint64_t v40;
  NSObject *v41;
  int v42;
  char *v43;
  uint64_t v44;
  int v45[2];
  void *v46;
  void *v47;
  int v48;
  uint8_t buf[4];
  uint64_t v50;
  __int16 v51;
  const char *v52;
  __int16 v53;
  int v54;
  __int16 v55;
  _BYTE v56[10];
  _DWORD v57[4];
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  v48 = -1431655766;
  v46 = (void *)0xAAAAAAAAAAAAAAAALL;
  v47 = (void *)0xAAAAAAAAAAAAAAAALL;
  v44 = 0xFFFFFFFFLL;
  *(_QWORD *)v45 = 0xFFFFFFFFLL;
  v8 = *a1;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v9 = VRTraceErrorLogLevelToCSTR();
    v10 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      v50 = v9;
      v51 = 2080;
      v52 = "SIPSendMessage";
      v53 = 1024;
      v54 = 2936;
      _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPSendMessage start...", buf, 0x1Cu);
    }
  }
  v11 = 2148139025;
  v12 = (_DWORD *)CheckInHandleDebug();
  if (!v12)
    return 2148139010;
  v13 = v12;
  if (!*v12 && !v12[1])
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 5)
      goto LABEL_54;
    v34 = VRTraceErrorLogLevelToCSTR();
    v35 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      goto LABEL_54;
    *(_DWORD *)buf = 136315906;
    v50 = v34;
    v51 = 2080;
    v52 = "SIPSendMessage";
    v53 = 1024;
    v54 = 2944;
    v55 = 1024;
    *(_DWORD *)v56 = 2944;
    v27 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SIP.c:%d: C"
          "all SIPStartListen first.";
    v28 = v35;
    v29 = 34;
    goto LABEL_41;
  }
  if (!(_DWORD)a2)
  {
    v11 = 2148139009;
    if ((int)VRTraceGetErrorLogLevelForModule() < 5)
      goto LABEL_54;
    v25 = VRTraceErrorLogLevelToCSTR();
    v26 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      goto LABEL_54;
    *(_DWORD *)buf = 136316162;
    v50 = v25;
    v51 = 2080;
    v52 = "SIPSendMessage";
    v53 = 1024;
    v54 = 2973;
    v55 = 1024;
    *(_DWORD *)v56 = 2973;
    *(_WORD *)&v56[4] = 1024;
    *(_DWORD *)&v56[6] = 0;
    v27 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SIP.c:%d: C"
          "allID(%d) is invalid";
    v28 = v26;
    v29 = 40;
    goto LABEL_41;
  }
  v14 = DLFindWithCallIDAndLock((uint64_t *)v45);
  if ((v14 & 0x80000000) != 0)
  {
    v20 = v14;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v30 = VRTraceErrorLogLevelToCSTR();
      v31 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136316162;
        v50 = v30;
        v51 = 2080;
        v52 = "SIPSendMessage";
        v53 = 1024;
        v54 = 2952;
        v55 = 1024;
        *(_DWORD *)v56 = 2952;
        *(_WORD *)&v56[4] = 1024;
        *(_DWORD *)&v56[6] = a2;
        _os_log_impl(&dword_1D8A54000, v31, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SIP.c:%d: Cannot find call ID(%d)", buf, 0x28u);
      }
    }
    goto LABEL_53;
  }
  DLGetState(*(uint64_t *)v45, &v48);
  DLUnlock();
  if (v48 != 3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 5)
      goto LABEL_54;
    v32 = VRTraceErrorLogLevelToCSTR();
    v33 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      goto LABEL_54;
    *(_DWORD *)buf = 136316418;
    v50 = v32;
    v51 = 2080;
    v52 = "SIPSendMessage";
    v53 = 1024;
    v54 = 2959;
    v55 = 1024;
    *(_DWORD *)v56 = 2959;
    *(_WORD *)&v56[4] = 1024;
    *(_DWORD *)&v56[6] = a2;
    LOWORD(v57[0]) = 1024;
    *(_DWORD *)((char *)v57 + 2) = v48;
    v27 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SIP.c:%d: C"
          "all(%d) is in state %d";
    v28 = v33;
    v29 = 46;
LABEL_41:
    _os_log_impl(&dword_1D8A54000, v28, OS_LOG_TYPE_DEFAULT, v27, buf, v29);
LABEL_54:
    TACancel();
    v20 = v11;
    goto LABEL_55;
  }
  MessageInDialog = CreateMessageInDialog((unint64_t *)&v47, *(uint64_t *)v45, a3, v13[4]);
  if ((MessageInDialog & 0x80000000) != 0)
  {
    v20 = MessageInDialog;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SIPSendMessage_cold_1();
    }
    goto LABEL_53;
  }
  v16 = v47;
  v17 = strstr(*((char **)v47 + 69), "VCHandoverCandidateChange:VCHandoverNewCandidateBlob");
  v18 = TACreateHandle(&v44, 1, *((_QWORD *)v13 + 3), (uint64_t)v16, 0xFFFFFFFFLL, (uint64_t)TUMsgCallback, (uint64_t)a1);
  if ((v18 & 0x80000000) != 0)
  {
    v20 = v18;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SIPSendMessage_cold_2();
    }
    v36 = v47;
LABEL_49:
    FreeSipMsg(v36);
LABEL_53:
    v11 = v20;
    if ((v20 & 0x10000000) != 0)
      goto LABEL_55;
    goto LABEL_54;
  }
  v19 = TAStart((void *)v44);
  if ((v19 & 0x80000000) != 0)
  {
    v20 = v19;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SIPSendMessage_cold_3();
    }
    goto LABEL_53;
  }
  v20 = DLGetMsg(*(uint64_t *)v45, &v46, 0xFFFFFFFFuLL, 7, (uint64_t)v47, -1);
  if ((v20 & 0x80000000) != 0)
  {
LABEL_25:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SIPSendMessage_cold_4();
    }
    goto LABEL_53;
  }
  v43 = v17;
  while (1)
  {
    v21 = v46;
    if (*((_DWORD *)v46 + 1) != 2)
      goto LABEL_21;
    v22 = *((_DWORD *)v46 + 2);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v23 = VRTraceErrorLogLevelToCSTR();
      v24 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        v50 = v23;
        v51 = 2080;
        v52 = "SIPSendMessage";
        v53 = 1024;
        v54 = 3004;
        v55 = 1024;
        *(_DWORD *)v56 = v22;
        _os_log_impl(&dword_1D8A54000, v24, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPSendMessage status(%d)...", buf, 0x22u);
      }
    }
    if ((v22 - 1) <= 4)
    {
      (*((void (**)(uint64_t, _QWORD, uint64_t, uint64_t, char *, _QWORD, _QWORD, _QWORD))v13 + 4))(v8, *((_QWORD *)v13 + 5), 4, a2, (char *)v46 + 12, 0, 0, 0);
      v21 = v46;
LABEL_21:
      FreeSipMsg(v21);
      goto LABEL_24;
    }
    if ((v22 & 0xFFFFFFFE) == 6)
      break;
    if ((v22 - 8) <= 0x2C)
    {
      v20 = v22 | 0x900A0000;
      if (a4 && v22 == 45)
        *a4 = 1;
      v36 = v46;
      goto LABEL_49;
    }
LABEL_24:
    v20 = DLGetMsg(*(uint64_t *)v45, &v46, 0xFFFFFFFFuLL, 7, (uint64_t)v47, -1);
    if ((v20 & 0x80000000) != 0)
      goto LABEL_25;
  }
  if (v43)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v40 = VRTraceErrorLogLevelToCSTR();
      v41 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v42 = *((_DWORD *)v46 + 2);
        *(_DWORD *)buf = 136316162;
        v50 = v40;
        v51 = 2080;
        v52 = "SIPSendMessage";
        v53 = 1024;
        v54 = 3012;
        v55 = 2080;
        *(_QWORD *)v56 = (char *)v46 + 12;
        *(_WORD *)&v56[8] = 1024;
        v57[0] = v42;
        _os_log_impl(&dword_1D8A54000, v41, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d HandoverReport: got %s back for candidateChangeMessage, status: %d", buf, 0x2Cu);
      }
    }
    (*((void (**)(uint64_t, _QWORD, uint64_t, uint64_t, char *, _QWORD, _QWORD, _QWORD))v13 + 4))(v8, *((_QWORD *)v13 + 5), 17, a2, (char *)v46 + 12, 0, 0, 0);
  }
  FreeSipMsg(v46);
LABEL_55:
  TACloseHandle();
  CheckOutHandleDebug();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v37 = VRTraceErrorLogLevelToCSTR();
    v38 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      v50 = v37;
      v51 = 2080;
      v52 = "SIPSendMessage";
      v53 = 1024;
      v54 = 3041;
      v55 = 1024;
      *(_DWORD *)v56 = v20;
      _os_log_impl(&dword_1D8A54000, v38, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPSendMessage stop(%X)...", buf, 0x22u);
    }
  }
  return v20;
}

uint64_t SIPSendMessageAll(uint64_t a1, uint64_t a2, char *a3)
{
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t *v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t MessageInDialog;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t i;
  uint64_t v25;
  uint64_t v26;
  NSObject *v27;
  int v29[2];
  void *v30;
  void *v31;
  int v32;
  int v33;
  uint8_t buf[4];
  uint64_t v35;
  __int16 v36;
  const char *v37;
  __int16 v38;
  int v39;
  __int16 v40;
  int v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v32 = -1431655766;
  v33 = -1431655766;
  v30 = 0;
  v31 = (void *)0xAAAAAAAAAAAAAAAALL;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v5 = VRTraceErrorLogLevelToCSTR();
    v6 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      v35 = v5;
      v36 = 2080;
      v37 = "SIPSendMessageAll";
      v38 = 1024;
      v39 = 3058;
      _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPSendMessageAll start...", buf, 0x1Cu);
    }
  }
  v7 = 2148139011;
  DLFindActiveDialogs(&v33, &v30);
  if (v33 < 1)
    return 2148139030;
  v8 = CheckInHandleDebug();
  if (!v8)
  {
    free(v30);
    return 2148139010;
  }
  v9 = v8;
  v10 = (unint64_t *)malloc_type_calloc(1uLL, 8 * v33, 0x2004093837F09uLL);
  if (!v10)
    goto LABEL_62;
  v11 = v10;
  v12 = (uint64_t *)malloc_type_calloc(1uLL, 8 * v33, 0x2004093837F09uLL);
  if (!v12)
    goto LABEL_61;
  v13 = v12;
  if (v33 < 1)
  {
    v7 = 0;
    goto LABEL_60;
  }
  *(_QWORD *)v29 = v11;
  v14 = 0;
  v7 = 0;
  do
  {
    v13[v14] = 0xFFFFFFFFLL;
    if (!strcmp(a3, "PING"))
    {
      *(_DWORD *)buf = -1431655766;
      v7 = DLGetSIPPing(*((_QWORD *)v30 + v14), buf);
      if ((v7 & 0x80000000) == 0 && !*(_DWORD *)buf)
        *((_QWORD *)v30 + v14) = 0xFFFFFFFFLL;
    }
    DLGetCallID(*((_QWORD *)v30 + v14++), &v32);
    v15 = v33;
  }
  while (v14 < v33);
  if (v33 < 1)
    goto LABEL_39;
  v16 = 0;
  v17 = v13;
  do
  {
    v18 = *((_QWORD *)v30 + v16);
    if (v18 == 0xFFFFFFFFLL)
      goto LABEL_22;
    MessageInDialog = CreateMessageInDialog(v11, v18, a3, *(_DWORD *)(v9 + 16));
    if ((MessageInDialog & 0x80000000) != 0)
    {
      v7 = MessageInDialog;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        v11 = *(unint64_t **)v29;
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          SIPSendMessageAll_cold_2();
        goto LABEL_53;
      }
LABEL_52:
      v11 = *(unint64_t **)v29;
      goto LABEL_53;
    }
    v20 = TACreateHandle(v17, 1, *(_QWORD *)(v9 + 24), *v11, 0xFFFFFFFFLL, (uint64_t)TUMsgCallback, a1);
    if ((v20 & 0x80000000) != 0)
    {
      v7 = v20;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          SIPSendMessageAll_cold_3();
      }
      FreeSipMsg((_QWORD *)*v11);
      goto LABEL_52;
    }
    v7 = TAStart((void *)*v17);
    if ((v7 & 0x80000000) != 0)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        v11 = *(unint64_t **)v29;
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          SIPSendMessageAll_cold_4();
        goto LABEL_53;
      }
      goto LABEL_52;
    }
    v15 = v33;
LABEL_22:
    ++v16;
    ++v17;
    ++v11;
  }
  while (v16 < v15);
  if (v15 >= 1)
  {
    v21 = 0;
    v11 = *(unint64_t **)v29;
    while (1)
    {
      while (1)
      {
        v22 = *((_QWORD *)v30 + v21);
        if (v22 != 0xFFFFFFFFLL)
          break;
LABEL_34:
        ++v21;
        v15 = v33;
        if (v21 >= v33)
          goto LABEL_40;
      }
      v7 = DLGetMsg(v22, &v31, 0xFFFFFFFFuLL, 7, *(_QWORD *)(*(_QWORD *)v29 + 8 * v21), -1);
      if ((v7 & 0x80000000) != 0)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            SIPSendMessageAll_cold_1();
        }
        goto LABEL_53;
      }
      if (*((_DWORD *)v31 + 1) == 2)
      {
        v23 = *((_DWORD *)v31 + 2);
        FreeSipMsg(v31);
        if ((v23 & 0xFFFFFFFE) == 6)
          goto LABEL_34;
        if ((v23 - 8) <= 0x2C)
        {
          if (v23 == 21)
          {
            DLSetState(*((_QWORD *)v30 + v21), 5);
            v7 = 2416574485;
          }
          else
          {
            v7 = v23 | 0x900A0000;
          }
          goto LABEL_34;
        }
      }
      else
      {
        FreeSipMsg(v31);
      }
    }
  }
LABEL_39:
  v11 = *(unint64_t **)v29;
LABEL_40:
  if ((v7 & 0x80000000) != 0)
  {
LABEL_53:
    v15 = v33;
    if ((v7 & 0x10000000) == 0 && v33 >= 1)
    {
      for (i = 0; i < v33; ++i)
      {
        TACancel();
        v15 = v33;
      }
    }
  }
  if (v15 >= 1)
  {
    v25 = 0;
    do
    {
      TACloseHandle();
      ++v25;
    }
    while (v25 < v33);
  }
LABEL_60:
  free(v13);
LABEL_61:
  free(v11);
LABEL_62:
  if (v30)
    free(v30);
  CheckOutHandleDebug();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v26 = VRTraceErrorLogLevelToCSTR();
    v27 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      v35 = v26;
      v36 = 2080;
      v37 = "SIPSendMessageAll";
      v38 = 1024;
      v39 = 3185;
      v40 = 1024;
      v41 = v7;
      _os_log_impl(&dword_1D8A54000, v27, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPSendMessageAll stop(%X)...", buf, 0x22u);
    }
  }
  return v7;
}

uint64_t SIPGetRemoteInfo(uint64_t a1, int a2, char *a3, char *a4)
{
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v11;
  uint8_t buf[4];
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  char __b[904];
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  memset(__b, 170, sizeof(__b));
  v11 = 0xFFFFFFFFLL;
  v7 = DLFindWithCallIDAndLock(&v11);
  if ((v7 & 0x80000000) != 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v8 = VRTraceErrorLogLevelToCSTR();
      v9 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136316162;
        v13 = v8;
        v14 = 2080;
        v15 = "SIPGetRemoteInfo";
        v16 = 1024;
        v17 = 3238;
        v18 = 1024;
        v19 = 3238;
        v20 = 1024;
        v21 = a2;
        _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SIP.c:%d: Cannot find call ID(%d)", buf, 0x28u);
      }
    }
  }
  else
  {
    DLGetData(v11, (uint64_t)__b);
    DLUnlock();
    if (a3)
      strlcpy(a3, &__b[506], 0x2BuLL);
    if (a4)
      CopyRemoteDisplayWithoutQuotes(a4, &__b[331], &__b[669], &__b[724]);
  }
  return v7;
}

uint64_t SIPSetDoKeyExchange(uint64_t a1, int a2, const void *a3)
{
  uint64_t v5;
  uint64_t v6;
  const void *v7;
  CFTypeRef v8;

  v5 = CheckInHandleDebug();
  if (!v5)
    return 2148139010;
  v6 = v5;
  v7 = *(const void **)(v5 + 48);
  if (v7)
    CFRelease(v7);
  if (a3)
    v8 = CFRetain(a3);
  else
    v8 = 0;
  *(_QWORD *)(v6 + 48) = v8;
  *(_DWORD *)(v6 + 56) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t SIPSetEnableCompression(uint64_t a1, int a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2148139010;
  *(_DWORD *)(v3 + 16) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t SIPSetAllowSameSourceDestination(uint64_t a1, char a2)
{
  uint64_t v3;
  uint64_t v4;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2148139010;
  v4 = TPSetAllowSameSourceDestination(*(_QWORD *)(v3 + 24), a2);
  CheckOutHandleDebug();
  return v4;
}

uint64_t SIPNewCallProc(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  pthread_mutex_t *v5;
  pthread_mutex_t *v6;
  pthread_mutex_t *v7;
  int v8;
  char *v9;
  __int128 v10;
  int *v11;
  unsigned int v12;
  uint64_t v13;
  NSObject *v14;
  int v15;
  uint64_t v16;
  NSObject *v17;
  int v18;
  uint64_t v19;
  NSObject *v20;
  int v21;
  int v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  NSObject *v26;
  int v27;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  int v38;
  int v39;
  unint64_t TickCount;
  int v41;
  int ErrorLogLevelForModule;
  uint64_t v43;
  NSObject *v44;
  unint64_t v45;
  int v46;
  int v47;
  unsigned int v48[6];
  int IntStatusCode;
  int v50;
  unsigned int v51;
  int v52[2];
  uint64_t v53;
  void *v54;
  int v55;
  uint8_t v56[4];
  uint64_t v57;
  __int16 v58;
  const char *v59;
  __int16 v60;
  int v61;
  __int16 v62;
  int v63;
  _BYTE buf[200];
  __int128 v65;
  __int128 v66;
  _OWORD v67[6];
  unint64_t v68;
  char __b[2700];
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  v55 = -1;
  memset(__b, 170, sizeof(__b));
  v53 = 0xFFFFFFFFLL;
  v54 = (void *)0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)v52 = 0xFFFFFFFFLL;
  v2 = **(_QWORD **)(a1 + 1000);
  pthread_setname_np("com.apple.avconference.sip.newcallproc");
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v3 = VRTraceErrorLogLevelToCSTR();
    v4 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = v3;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "SIPNewCallProc";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 187;
      _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPNewCallProc Thread start...", buf, 0x1Cu);
    }
  }
  v5 = (pthread_mutex_t *)CheckInHandleDebug();
  if (!v5)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SIPNewCallProc_cold_1();
    }
    FreeSipMsg((_QWORD *)a1);
    return 0;
  }
  v6 = v5;
  v7 = v5 + 1;
  pthread_mutex_lock(v5 + 1);
  if ((DLFindWithSipMsgAndLock(&v53, a1) & 0x80000000) == 0)
  {
    DLUnlock();
    pthread_mutex_unlock(v7);
    v8 = 0;
    v53 = 0xFFFFFFFFLL;
    goto LABEL_63;
  }
  v51 = 0;
  v9 = *(char **)(a1 + 312);
  if (!v9)
  {
    v11 = (int *)(a1 + 572);
    *(_DWORD *)(a1 + 572) = 0;
LABEL_25:
    *v11 = VCUniqueIDGenerator_GenerateID();
    goto LABEL_26;
  }
  *(_QWORD *)&buf[78] = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v10 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&buf[48] = v10;
  *(_OWORD *)&buf[64] = v10;
  *(_OWORD *)&buf[16] = v10;
  *(_OWORD *)&buf[32] = v10;
  *(_OWORD *)buf = v10;
  CopyRemoteDisplayWithoutQuotes(buf, v9, v9 + 49, v9 + 104);
  if ((*(unsigned int (**)(uint64_t, _QWORD, uint64_t, _QWORD, _BYTE *, uint64_t, unsigned int *, _QWORD))&v6->__opaque[24])(v2, *(_QWORD *)&v6->__opaque[32], 13, 0, buf, a1 + 576, &v51, 0) == 3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SIPNewCallProc_cold_7();
    }
    pthread_mutex_unlock(v7);
LABEL_17:
    v8 = 50;
    goto LABEL_59;
  }
  v12 = v51;
  v11 = (int *)(a1 + 572);
  *(_DWORD *)(a1 + 572) = v51;
  if (!v12)
    goto LABEL_25;
  if ((DLFindWithCallIDAndLock(&v53) & 0x80000000) == 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v13 = VRTraceErrorLogLevelToCSTR();
      v14 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v15 = *v11;
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = v13;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "SIPNewCallProc";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 235;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v15;
        _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Found an existing dialog with Call ID %d. Closing.", buf, 0x22u);
      }
    }
    DLGetConfIndex(v53, &v55);
    DLUnlock();
    v53 = 0xFFFFFFFFLL;
  }
LABEL_26:
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v16 = VRTraceErrorLogLevelToCSTR();
    v17 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v18 = *v11;
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = v16;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "SIPNewCallProc";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 243;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = v18;
      _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Incoming call for Call ID %d", buf, 0x22u);
    }
  }
  if (!(*(unsigned int (**)(uint64_t, _QWORD, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))&v6->__opaque[24])(v2, *(_QWORD *)&v6->__opaque[32], 18, v51, 0, 0, 0, 0))
  {
    v22 = DLCreateHandle(&v53, *(_DWORD *)(a1 + 572), a1, 1, 3, -1, (uint64_t)DLIsFinishedCallback, v2);
    if (v22 < 0)
    {
      v24 = v22;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          SIPNewCallProc_cold_2();
      }
      TPRemovePreservedPortBindForCallID(*(_QWORD *)&v6->__opaque[16], *v11);
      if (v24 == -2146697182)
        v8 = 13;
      else
        v8 = 42;
      goto LABEL_59;
    }
    pthread_mutex_unlock(v7);
    if ((TACreateHandle((uint64_t *)v52, 2, *(_QWORD *)&v6->__opaque[16], a1, 0xFFFFFFFFLL, (uint64_t)TUMsgCallback, *(_QWORD *)(a1 + 1000)) & 0x80000000) != 0)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          SIPNewCallProc_cold_3();
      }
    }
    else if ((TAStart(*(void **)v52) & 0x80000000) != 0)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          SIPNewCallProc_cold_4();
      }
    }
    else if ((SendTAStatus(*(uint64_t *)v52, a1, 0xFFFFFFFFLL, 0, 0, 0, *(_DWORD *)v6->__opaque) & 0x80000000) != 0)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          SIPNewCallProc_cold_5();
      }
    }
    else
    {
      v23 = *(_QWORD *)(a1 + 208);
      v50 = 11;
      IntStatusCode = GetIntStatusCode(1);
      if (v23)
        (*(void (**)(uint64_t, _QWORD, uint64_t, _QWORD, uint64_t, _QWORD, int *, int *))&v6->__opaque[24])(v2, *(_QWORD *)&v6->__opaque[32], 15, *v11, v23, 0, &v50, &IntStatusCode);
      if (*(_DWORD *)(a1 + 132))
      {
        v8 = 25;
        goto LABEL_59;
      }
      *(_DWORD *)v6->__opaque = 1;
      if (!LODWORD(v6->__sig) && !HIDWORD(v6->__sig))
      {
LABEL_83:
        v8 = 36;
LABEL_59:
        if ((SendTAStatus(*(uint64_t *)v52, a1, 0xFFFFFFFFLL, v8, 0, 0, *(_DWORD *)v6->__opaque) & 0x80000000) != 0)
        {
          SendTPStatus(*(_QWORD *)&v6->__opaque[16], a1, v8, 0, 0, *(_DWORD *)v6->__opaque);
          TACancel();
        }
        goto LABEL_61;
      }
      *(_QWORD *)&v29 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v29 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v67[4] = v29;
      v67[5] = v29;
      v67[2] = v29;
      v67[3] = v29;
      v68 = 0xAAAAAAAAAAAAAAAALL;
      v67[1] = v29;
      v67[0] = v29;
      v66 = v29;
      v65 = v29;
      *(_OWORD *)&buf[184] = v29;
      *(_OWORD *)&buf[168] = v29;
      *(_OWORD *)&buf[152] = v29;
      *(_OWORD *)&buf[136] = v29;
      *(_OWORD *)&buf[120] = v29;
      *(_OWORD *)&buf[104] = v29;
      *(_OWORD *)&buf[88] = v29;
      *(_OWORD *)&buf[72] = v29;
      *(_OWORD *)&buf[56] = v29;
      *(_OWORD *)&buf[40] = v29;
      *(_OWORD *)&buf[24] = v29;
      *(_OWORD *)&buf[8] = v29;
      memset(v48, 170, 20);
      v30 = *(_OWORD *)(a1 + 712);
      *(_OWORD *)&buf[36] = *(_OWORD *)(a1 + 696);
      *(_OWORD *)&buf[52] = v30;
      *(_QWORD *)&buf[68] = *(_QWORD *)(a1 + 728);
      v31 = *(_OWORD *)(a1 + 752);
      *(_OWORD *)&buf[76] = *(_OWORD *)(a1 + 736);
      *(_OWORD *)&buf[92] = v31;
      *(_QWORD *)&buf[108] = *(_QWORD *)(a1 + 768);
      v32 = *(_OWORD *)(a1 + 776);
      v33 = *(_OWORD *)(a1 + 792);
      *(_QWORD *)&buf[148] = *(_QWORD *)(a1 + 808);
      *(_OWORD *)&buf[132] = v33;
      *(_OWORD *)&buf[116] = v32;
      v34 = *(_OWORD *)(a1 + 816);
      v35 = *(_OWORD *)(a1 + 832);
      *(_QWORD *)&buf[188] = *(_QWORD *)(a1 + 848);
      *(_OWORD *)&buf[172] = v35;
      *(_OWORD *)&buf[156] = v34;
      v36 = *(_OWORD *)(a1 + 856);
      v37 = *(_OWORD *)(a1 + 872);
      *(_QWORD *)((char *)&v67[2] + 4) = *(_QWORD *)(a1 + 888);
      *(_OWORD *)((char *)&v67[1] + 4) = v37;
      *(_OWORD *)((char *)v67 + 4) = v36;
      *(_WORD *)&buf[32] = *(_WORD *)(a1 + 568);
      *(_WORD *)&buf[34] = *(_WORD *)(a1 + 570);
      *(_QWORD *)buf = &v48[1];
      LODWORD(v68) = 0;
      v38 = SendTAStatus(*(uint64_t *)v52, a1, v53, 2, 0, 0, *(_DWORD *)v6->__opaque);
      if ((v38 & 0x80000000) == 0)
      {
        if (v23)
        {
          IntStatusCode = GetIntStatusCode(2);
          (*(void (**)(uint64_t, _QWORD, uint64_t, _QWORD, uint64_t, _QWORD, int *, int *))&v6->__opaque[24])(v2, *(_QWORD *)&v6->__opaque[32], 15, *v11, v23, 0, &v50, &IntStatusCode);
        }
        __b[0] = 0;
        v39 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, _QWORD, _QWORD, char *, _BYTE *, int *))&v6->__opaque[24])(v2, *(_QWORD *)&v6->__opaque[32], 2, *(unsigned int *)(a1 + 572), *(_QWORD *)(a1 + 552), __b, buf, &v55);
        (*(void (**)(uint64_t, _QWORD, uint64_t, _QWORD, _QWORD, _QWORD, unsigned int *, _QWORD))&v6->__opaque[24])(v2, *(_QWORD *)&v6->__opaque[32], 12, *(unsigned int *)(a1 + 572), 0, 0, v48, 0);
        DLSetMediaType(v53, v48[0]);
        v8 = 37;
        switch(v39)
        {
          case 0:
            DLSetConfIndex(v53, v55);
            TickCount = GetTickCount();
            if (GetTickCount() - TickCount > 0x7D00)
              goto LABEL_77;
            v45 = 500;
            break;
          case 1:
            goto LABEL_59;
          case 2:
            goto LABEL_83;
          case 3:
            goto LABEL_17;
          default:
            goto LABEL_58;
        }
        while (1)
        {
          v46 = SendTAStatus(*(uint64_t *)v52, a1, v53, 6, __b, &v48[1], *(_DWORD *)v6->__opaque);
          if (v46 == -2146435037)
          {
            if ((SendTPStatus(*(_QWORD *)&v6->__opaque[16], a1, 6, __b, &v48[1], *(_DWORD *)v6->__opaque) & 0x80000000) != 0)
            {
              __sprintf_chk(__b, 0, 0xA8CuLL, "Transport Error(%08X)");
LABEL_106:
              (*(void (**)(uint64_t, _QWORD, uint64_t, _QWORD, char *, _QWORD, _QWORD, _QWORD))&v6->__opaque[24])(v2, *(_QWORD *)&v6->__opaque[32], 3, *v11, __b, 0, 0, 0);
              goto LABEL_58;
            }
          }
          else if (v46 < 0)
          {
            if (v46 == -2146828258)
            {
              __sprintf_chk(__b, 0, 0xA8CuLL, "Cancelled");
              v8 = 37;
            }
            else
            {
              __sprintf_chk(__b, 0, 0xA8CuLL, "Transport Error(%08X)", v46);
              v8 = 42;
            }
            (*(void (**)(uint64_t, _QWORD, uint64_t, _QWORD, char *, _QWORD, _QWORD, _QWORD))&v6->__opaque[24])(v2, *(_QWORD *)&v6->__opaque[32], 3, *v11, __b, 0, 0, 0);
            goto LABEL_59;
          }
          if (v23)
          {
            IntStatusCode = GetIntStatusCode(6);
            (*(void (**)(uint64_t, _QWORD, uint64_t, _QWORD, uint64_t, _QWORD, int *, int *))&v6->__opaque[24])(v2, *(_QWORD *)&v6->__opaque[32], 15, *v11, v23, 0, &v50, &IntStatusCode);
          }
          v47 = DLGetMsg(v53, &v54, v45, 1, 0, -1);
          if (v47 < 0)
          {
            if ((unsigned __int16)v47 != 23)
            {
              __sprintf_chk(__b, 0, 0xA8CuLL, "Internal Error(%08X)");
              goto LABEL_106;
            }
            if (2 * v45 >= 0xFA0)
              v45 = 4000;
            else
              v45 *= 2;
            IntStatusCode = 6;
            if (v23)
              (*(void (**)(uint64_t, _QWORD, uint64_t, _QWORD, uint64_t, _QWORD, int *, int *))&v6->__opaque[24])(v2, *(_QWORD *)&v6->__opaque[32], 15, *v11, v23, 0, &v50, &IntStatusCode);
          }
          else
          {
            if (*((_DWORD *)v54 + 1) == 1 && *((_DWORD *)v54 + 2) == 2)
            {
              (*(void (**)(uint64_t, _QWORD, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))&v6->__opaque[24])(v2, *(_QWORD *)&v6->__opaque[32], 1, *v11, 0, 0, 0, 0);
              FreeSipMsg(v54);
              v8 = 6;
              goto LABEL_63;
            }
            FreeSipMsg(v54);
          }
          if (GetTickCount() - TickCount > 0x7D00)
          {
LABEL_77:
            SIPHangupWithTimeout(*(uint64_t **)(a1 + 1000), *(unsigned int *)(a1 + 572), 0xFFFFFFFFuLL, 291);
            (*(void (**)(uint64_t, _QWORD, uint64_t, _QWORD, const char *, _QWORD, _QWORD, _QWORD))&v6->__opaque[24])(v2, *(_QWORD *)&v6->__opaque[32], 3, *(unsigned int *)(a1 + 572), "Timeout", 0, 0, 0);
            goto LABEL_34;
          }
        }
      }
      v41 = v38;
      ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
      if (v41 == -2146828258)
      {
        if (ErrorLogLevelForModule >= 5)
        {
          v43 = VRTraceErrorLogLevelToCSTR();
          v44 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)v56 = 136315906;
            v57 = v43;
            v58 = 2080;
            v59 = "SIPNewCallProc";
            v60 = 1024;
            v61 = 335;
            v62 = 1024;
            v63 = 335;
            _os_log_impl(&dword_1D8A54000, v44, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SIP.c:%d: SendTAStatus cancelled", v56, 0x22u);
          }
        }
        v8 = 37;
        goto LABEL_59;
      }
      if (ErrorLogLevelForModule >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          SIPNewCallProc_cold_6();
      }
    }
LABEL_58:
    v8 = 42;
    goto LABEL_59;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v19 = VRTraceErrorLogLevelToCSTR();
    v20 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v21 = *v11;
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = v19;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "SIPNewCallProc";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 248;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = v21;
      _os_log_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Primary connection is not ready, ignore the SIP INVITE for Call ID: %u", buf, 0x22u);
    }
  }
  pthread_mutex_unlock(v7);
LABEL_34:
  v8 = 0;
LABEL_61:
  if (v53 != 0xFFFFFFFFLL)
    DLCloseHandle();
LABEL_63:
  if (*(_QWORD *)v52 == 0xFFFFFFFFLL)
    FreeSipMsg((_QWORD *)a1);
  else
    TACloseHandle();
  CheckOutHandleDebug();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v25 = VRTraceErrorLogLevelToCSTR();
    v26 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v27 = GetIntStatusCode(v8);
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = v25;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "SIPNewCallProc";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 504;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = v27;
      _os_log_impl(&dword_1D8A54000, v26, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPNewCallProc Thread end(%d)...", buf, 0x22u);
    }
  }
  return 0;
}

uint64_t SIPCancelProc(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  int IntStatusCode;
  uint64_t v13;
  NSObject *v14;
  unsigned int v15;
  int v16;
  int v17[2];
  uint64_t v18;
  uint8_t buf[904];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)v17 = 0xFFFFFFFFLL;
  v18 = 0xFFFFFFFFLL;
  v2 = **(_QWORD **)(a1 + 1000);
  pthread_setname_np("com.apple.avconference.sip.cancelproc");
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v3 = VRTraceErrorLogLevelToCSTR();
    v4 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = v3;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "SIPCancelProc";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 1148;
      _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPCancelProc Thread start...", buf, 0x1Cu);
    }
  }
  v5 = CheckInHandleDebug();
  if (v5)
  {
    v6 = v5;
    if (*(_DWORD *)(a1 + 132))
    {
      v7 = 25;
    }
    else
    {
      if ((TACreateHandle((uint64_t *)v17, 3, *(_QWORD *)(v5 + 24), a1, 0xFFFFFFFFLL, (uint64_t)TUMsgCallback, *(_QWORD *)(a1 + 1000)) & 0x80000000) != 0)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            SIPCancelProc_cold_2();
        }
      }
      else
      {
        if ((TAStart(*(void **)v17) & 0x80000000) == 0)
        {
          if ((DLFindWithSipMsgAndLock(&v18, a1) & 0x80000000) != 0)
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
            {
              v13 = VRTraceErrorLogLevelToCSTR();
              v14 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315906;
                *(_QWORD *)&buf[4] = v13;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = "SIPCancelProc";
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&buf[24] = 1180;
                *(_WORD *)&buf[28] = 1024;
                *(_DWORD *)&buf[30] = 1180;
                _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SIP.c:%d: Cannot find a dialog to cancel, sending 481", buf, 0x22u);
              }
            }
            v7 = 31;
          }
          else
          {
            v16 = -1431655766;
            memset(buf, 170, sizeof(buf));
            v8 = *(_QWORD *)(a1 + 480);
            DLGetState(v18, &v16);
            if ((v16 - 1) <= 1)
            {
              v15 = -1431655766;
              DLGetCallID(v18, &v15);
              DLSetState(v18, 4);
              (*(void (**)(uint64_t, _QWORD, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(v6 + 32))(v2, *(_QWORD *)(v6 + 40), 5, v15, 0, 0, 0, 0);
            }
            DLGetData(v18, (uint64_t)buf);
            DLUnlock();
            if (v8)
              strlcpy((char *)(v8 + 156), (const char *)&buf[374], 0x40uLL);
            TPDiscardConnectionResult();
            v7 = 6;
          }
          goto LABEL_26;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            SIPCancelProc_cold_3();
        }
      }
      v7 = 42;
    }
LABEL_26:
    if ((SendTAStatus(*(uint64_t *)v17, a1, 0xFFFFFFFFLL, v7, 0, 0, *(_DWORD *)(v6 + 8)) & 0x80000000) != 0)
    {
      SendTPStatus(*(_QWORD *)(v6 + 24), a1, v7, 0, 0, *(_DWORD *)(v6 + 8));
      TACancel();
    }
    if (*(_QWORD *)v17 == 0xFFFFFFFFLL)
      FreeSipMsg((_QWORD *)a1);
    else
      TACloseHandle();
    CheckOutHandleDebug();
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v9 = VRTraceErrorLogLevelToCSTR();
      v10 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        IntStatusCode = GetIntStatusCode(v7);
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = v9;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "SIPCancelProc";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 1229;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = IntStatusCode;
        _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPCancelProc Thread end(%d)...", buf, 0x22u);
      }
    }
    return 0;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      SIPCancelProc_cold_1();
  }
  FreeSipMsg((_QWORD *)a1);
  return 0;
}

uint64_t SIPHangupProc(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  const char *v13;
  NSObject *v14;
  uint32_t v15;
  uint64_t v16;
  NSObject *v17;
  uint64_t v18;
  NSObject *v19;
  int IntStatusCode;
  int v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint8_t buf[4];
  uint64_t v27;
  __int16 v28;
  const char *v29;
  __int16 v30;
  int v31;
  __int16 v32;
  int v33;
  __int16 v34;
  unsigned int v35;
  __int16 v36;
  int v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v24 = 0xFFFFFFFFLL;
  v25 = 0xFFFFFFFFLL;
  v2 = **(_QWORD **)(a1 + 1000);
  pthread_setname_np("com.apple.avconference.sip.hangupproc");
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v3 = VRTraceErrorLogLevelToCSTR();
    v4 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      v27 = v3;
      v28 = 2080;
      v29 = "SIPHangupProc";
      v30 = 1024;
      v31 = 1259;
      _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPHangupProc Thread start...", buf, 0x1Cu);
    }
  }
  v5 = CheckInHandleDebug();
  if (v5)
  {
    v6 = v5;
    if (*(_DWORD *)(a1 + 132))
    {
      v7 = 25;
LABEL_45:
      if ((SendTAStatus(v24, a1, v25, v7, 0, 0, *(_DWORD *)(v6 + 8)) & 0x80000000) != 0)
      {
        SendTPStatus(*(_QWORD *)(v6 + 24), a1, v7, 0, 0, *(_DWORD *)(v6 + 8));
        TACancel();
      }
      if (v7 == 6)
        DLCloseHandle();
      if (v24 == 0xFFFFFFFFLL)
        FreeSipMsg((_QWORD *)a1);
      else
        TACloseHandle();
      CheckOutHandleDebug();
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v18 = VRTraceErrorLogLevelToCSTR();
        v19 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          IntStatusCode = GetIntStatusCode(v7);
          *(_DWORD *)buf = 136315906;
          v27 = v18;
          v28 = 2080;
          v29 = "SIPHangupProc";
          v30 = 1024;
          v31 = 1348;
          v32 = 1024;
          v33 = IntStatusCode;
          _os_log_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPHangupProc Thread end(%d)...", buf, 0x22u);
        }
      }
      return 0;
    }
    TPStopHeartbeat(*(_QWORD *)(v5 + 24), a1 + 816);
    if ((TACreateHandle(&v24, 3, *(_QWORD *)(v6 + 24), a1, 0xFFFFFFFFLL, (uint64_t)TUMsgCallback, *(_QWORD *)(a1 + 1000)) & 0x80000000) != 0)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          SIPHangupProc_cold_2();
      }
    }
    else
    {
      if ((TAStart((void *)v24) & 0x80000000) == 0)
      {
        if ((DLFindWithSipMsgAndLock(&v25, a1) & 0x80000000) != 0)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() < 5)
            goto LABEL_44;
          v11 = VRTraceErrorLogLevelToCSTR();
          v12 = *MEMORY[0x1E0CF2758];
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            goto LABEL_44;
          *(_DWORD *)buf = 136315906;
          v27 = v11;
          v28 = 2080;
          v29 = "SIPHangupProc";
          v30 = 1024;
          v31 = 1293;
          v32 = 1024;
          v33 = 1293;
          v13 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SIP.c"
                ":%d: Cannot find a dialog to hangup, sending 481";
          v14 = v12;
          v15 = 34;
        }
        else
        {
          v22 = -1431655766;
          v23 = -1431655766;
          v8 = *(_QWORD *)(a1 + 544);
          DLGetCallID(v25, &v23);
          DLGetState(v25, &v22);
          if (v22 == 3)
          {
            DLSetState(v25, 5);
            if ((DLUnlock() & 0x80000000) != 0 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                SIPHangupProc_cold_4();
            }
            if (v8)
              v9 = v8 + 52;
            else
              v9 = 0;
            if (v8)
              v10 = v8 + 48;
            else
              v10 = 0;
            (*(void (**)(uint64_t, _QWORD, _QWORD, _QWORD, uint64_t, _QWORD, uint64_t, _QWORD))(v6 + 32))(v2, *(_QWORD *)(v6 + 40), 0, v23, v9, 0, v10, 0);
            *(_DWORD *)(a1 + 572) = v23;
            TPDiscardConnectionResult();
            v7 = 6;
            goto LABEL_45;
          }
          if ((DLUnlock() & 0x80000000) != 0 && (int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              SIPHangupProc_cold_5();
          }
          if ((int)VRTraceGetErrorLogLevelForModule() < 5)
            goto LABEL_44;
          v16 = VRTraceErrorLogLevelToCSTR();
          v17 = *MEMORY[0x1E0CF2758];
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            goto LABEL_44;
          *(_DWORD *)buf = 136316418;
          v27 = v16;
          v28 = 2080;
          v29 = "SIPHangupProc";
          v30 = 1024;
          v31 = 1307;
          v32 = 1024;
          v33 = 1307;
          v34 = 1024;
          v35 = v23;
          v36 = 1024;
          v37 = v22;
          v13 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SIP.c"
                ":%d: Call(%d) is in state %d";
          v14 = v17;
          v15 = 46;
        }
        _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, v13, buf, v15);
LABEL_44:
        v7 = 31;
        goto LABEL_45;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          SIPHangupProc_cold_3();
      }
    }
    v7 = 42;
    goto LABEL_45;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      SIPHangupProc_cold_1();
  }
  FreeSipMsg((_QWORD *)a1);
  return 0;
}

uint64_t SIPKeyExchangeProc(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  UInt8 *v8;
  unint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  NSObject *v16;
  NSObject *v17;
  const char *v18;
  uint32_t v19;
  int v20;
  uint64_t v21;
  NSObject *v22;
  int ErrorLogLevelForModule;
  uint64_t v24;
  NSObject *v25;
  int v26;
  int v27;
  uint64_t v28;
  NSObject *v29;
  int v30;
  uint64_t v31;
  NSObject *v32;
  uint64_t v33;
  NSObject *v34;
  uint64_t v35;
  int v36;
  UInt8 *v37;
  UInt8 *v38;
  NSObject *v39;
  uint64_t v40;
  char *v41;
  int v42;
  CFDataRef v43;
  int v44;
  int AsResponder;
  uint64_t v46;
  NSObject *v47;
  unsigned int v48;
  int PeerCertStatus;
  int v50;
  uint64_t v51;
  NSObject *v52;
  NSObject *v53;
  const char *v54;
  uint32_t v55;
  uint64_t v56;
  NSObject *v57;
  uint64_t v58;
  NSObject *v59;
  NSObject *v60;
  const char *v61;
  uint64_t v62;
  NSObject *v63;
  CFTypeRef v64;
  uint64_t v65;
  NSObject *v66;
  uint64_t v67;
  NSObject *v68;
  int v69;
  int v70;
  uint64_t v71;
  int v72;
  uint64_t v73;
  NSObject *v74;
  int v75;
  int v76;
  uint64_t v77;
  uint64_t v78;
  NSObject *v79;
  int v80;
  _QWORD *v81;
  uint64_t v82;
  char *v83;
  int v84;
  int v85;
  uint64_t v86;
  NSObject *v87;
  int v88;
  int v89;
  uint64_t v90;
  NSObject *v91;
  uint64_t v92;
  NSObject *v93;
  uint64_t v94;
  NSObject *v95;
  const char *v96;
  NSObject *v97;
  uint32_t v98;
  uint64_t v99;
  int v100;
  const char *v101;
  uint64_t v102;
  uint64_t v103;
  int v104;
  uint64_t v105;
  UInt8 *v106;
  int v107;
  uint64_t v108;
  NSObject *v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  NSObject *v113;
  int IntStatusCode;
  uint64_t v116;
  NSObject *v117;
  uint64_t v118;
  int v119;
  const char *v120;
  uint64_t v121;
  uint64_t v122;
  int v123;
  uint64_t v124;
  int PeerAbortReason;
  uint64_t v126;
  NSObject *v127;
  UInt8 *v128;
  uint64_t v129;
  NSObject *v130;
  int v131;
  int v132;
  uint64_t v133;
  NSObject *v134;
  uint64_t v135;
  int v136;
  const char *v137;
  uint64_t v138;
  uint64_t v139;
  int v140;
  uint64_t v141;
  uint64_t v142;
  int v143;
  const char *v144;
  uint64_t v145;
  uint64_t v146;
  int v147;
  uint64_t v148;
  int v149;
  uint64_t v150;
  NSObject *v151;
  char v152;
  UInt8 *v153;
  const __CFAllocator *bytesDeallocator;
  int v155;
  int v156;
  int v157;
  int v158;
  uint64_t v159;
  int v160;
  int v161;
  CFTypeRef cf;
  int v163;
  int v164;
  int v165;
  int v166;
  uint64_t v167;
  void *v168;
  unsigned int v169;
  int v170;
  unsigned int v171;
  uint64_t v172;
  CFTypeRef v173;
  const __CFData *v174;
  uint64_t v175;
  uint64_t v176;
  _QWORD *v177;
  uint8_t buf[4];
  uint64_t v179;
  __int16 v180;
  const char *v181;
  __int16 v182;
  int v183;
  __int16 v184;
  _BYTE v185[10];
  _BYTE v186[6];
  _BYTE v187[6];
  _BYTE v188[6];
  uint64_t v189;
  uint64_t v190;

  v190 = *MEMORY[0x1E0C80C00];
  v176 = 0xFFFFFFFFLL;
  v177 = (_QWORD *)a1;
  v175 = 0xFFFFFFFFLL;
  v1 = **(_QWORD **)(a1 + 1000);
  v173 = 0;
  v174 = 0;
  v172 = 0;
  v171 = -1;
  v169 = -1431655766;
  v170 = -1431655766;
  v167 = 0;
  v168 = 0;
  v166 = 0;
  pthread_setname_np("com.apple.avconference.sip.keyexchangeproc");
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      v179 = v2;
      v180 = 2080;
      v181 = "SIPKeyExchangeProc";
      v182 = 1024;
      v183 = 625;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d()()()()() SIPKeyExchangeProc Thread start...", buf, 0x1Cu);
    }
  }
  v4 = CheckInHandleDebug();
  if (!v4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SIPKeyExchangeProc_cold_1();
    }
    FreeSipMsg(v177);
    return 0;
  }
  v5 = v4;
  v6 = DLFindWithSipMsgAndLock(&v176, (uint64_t)v177);
  if (v6 < 0)
  {
    v7 = 31;
    goto LABEL_205;
  }
  if (v177 && *((_DWORD *)v177 + 33))
  {
    v7 = 25;
    goto LABEL_205;
  }
  DLSetDoingKeyExchange(v176, 1);
  DLGetConfIndex(v176, &v170);
  DLGetCallID(v176, &v169);
  DLUnlock();
  v158 = 0;
  v156 = 0;
  v157 = 0;
  v8 = 0;
  v9 = 0;
  v155 = 0;
  v160 = 0;
  bytesDeallocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE20];
  v10 = v177;
  while (1)
  {
    if (*((_DWORD *)v10 + 1) != 1)
    {
      v20 = DLPutMsg(v176, (uint64_t)v10, 1);
      if ((v20 & 0x80000000) == 0)
      {
        v177 = 0;
        if ((int)VRTraceGetErrorLogLevelForModule() < 7)
          goto LABEL_52;
        v21 = VRTraceErrorLogLevelToCSTR();
        v22 = *MEMORY[0x1E0CF2758];
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          goto LABEL_52;
        *(_DWORD *)buf = 136315650;
        v179 = v21;
        v180 = 2080;
        v181 = "SIPKeyExchangeProc";
        v182 = 1024;
        v183 = 697;
        v17 = v22;
        v18 = "SIP [%s] %s:%d SKEProc: not request";
LABEL_28:
        v19 = 28;
LABEL_29:
        _os_log_impl(&dword_1D8A54000, v17, OS_LOG_TYPE_DEFAULT, v18, buf, v19);
LABEL_52:
        v14 = v9;
        goto LABEL_53;
      }
      v6 = v20;
      if ((int)VRTraceGetErrorLogLevelForModule() < 7)
        goto LABEL_202;
      v108 = VRTraceErrorLogLevelToCSTR();
      v109 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        goto LABEL_202;
      *(_DWORD *)buf = 136315650;
      v179 = v108;
      v180 = 2080;
      v181 = "SIPKeyExchangeProc";
      v182 = 1024;
      v183 = 692;
      v96 = "SIP [%s] %s:%d SIPDoSKE: terminated by remote party";
LABEL_200:
      v97 = v109;
      v98 = 28;
LABEL_201:
      _os_log_impl(&dword_1D8A54000, v97, OS_LOG_TYPE_DEFAULT, v96, buf, v98);
LABEL_202:
      v160 = 0;
      goto LABEL_203;
    }
    if (*((_DWORD *)v10 + 2) != 7)
    {
      v6 = DLPutMsg(v176, (uint64_t)v10, 1);
      ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
      if ((v6 & 0x80000000) == 0)
      {
        if (ErrorLogLevelForModule >= 7)
        {
          v24 = VRTraceErrorLogLevelToCSTR();
          v25 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            if (v177)
              v26 = *((_DWORD *)v177 + 2);
            else
              v26 = -1;
            *(_DWORD *)buf = 136315906;
            v179 = v24;
            v180 = 2080;
            v181 = "SIPKeyExchangeProc";
            v182 = 1024;
            v183 = 709;
            v184 = 1024;
            *(_DWORD *)v185 = v26;
            _os_log_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SKEProc: not message (%d)", buf, 0x22u);
          }
        }
        v177 = 0;
        goto LABEL_52;
      }
      if (ErrorLogLevelForModule < 7)
        goto LABEL_202;
      v110 = VRTraceErrorLogLevelToCSTR();
      v109 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        goto LABEL_202;
      *(_DWORD *)buf = 136315650;
      v179 = v110;
      v180 = 2080;
      v181 = "SIPKeyExchangeProc";
      v182 = 1024;
      v183 = 705;
      v96 = "SIP [%s] %s:%d SIPDoSKE: terminated by remote party";
      goto LABEL_200;
    }
    if (!v10[66])
    {
      v27 = DLPutMsg(v176, (uint64_t)v10, 1);
      if ((v27 & 0x80000000) == 0)
      {
        v177 = 0;
        if ((int)VRTraceGetErrorLogLevelForModule() < 7)
          goto LABEL_52;
        v28 = VRTraceErrorLogLevelToCSTR();
        v29 = *MEMORY[0x1E0CF2758];
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          goto LABEL_52;
        *(_DWORD *)buf = 136315650;
        v179 = v28;
        v180 = 2080;
        v181 = "SIPKeyExchangeProc";
        v182 = 1024;
        v183 = 723;
        v17 = v29;
        v18 = "SIP [%s] %s:%d SKEProc: message doesn't have SKESeq";
        goto LABEL_28;
      }
      v6 = v27;
      if ((int)VRTraceGetErrorLogLevelForModule() < 7)
        goto LABEL_202;
      v111 = VRTraceErrorLogLevelToCSTR();
      v109 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        goto LABEL_202;
      *(_DWORD *)buf = 136315650;
      v179 = v111;
      v180 = 2080;
      v181 = "SIPKeyExchangeProc";
      v182 = 1024;
      v183 = 718;
      v96 = "SIP [%s] %s:%d SIPDoSKE: terminated by remote party";
      goto LABEL_200;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v11 = VRTraceErrorLogLevelToCSTR();
      v12 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        v179 = v11;
        v180 = 2080;
        v181 = "SIPKeyExchangeProc";
        v182 = 1024;
        v183 = 727;
        v184 = 2048;
        *(_QWORD *)v185 = v177;
        _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SKEProc: got msg %p", buf, 0x26u);
      }
    }
    v13 = v177[66];
    v14 = *(_QWORD *)v13;
    if (*(_QWORD *)v13 < v9 + 1)
    {
      FreeSipMsg(v177);
      v177 = 0;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v15 = VRTraceErrorLogLevelToCSTR();
        v16 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315906;
          v179 = v15;
          v180 = 2080;
          v181 = "SIPKeyExchangeProc";
          v182 = 1024;
          v183 = 734;
          v184 = 1024;
          *(_DWORD *)v185 = v14;
          v17 = v16;
          v18 = "SIP [%s] %s:%d SKEProc: SKESeq (%d) duplicate";
          v19 = 34;
          goto LABEL_29;
        }
      }
      goto LABEL_52;
    }
    if (*(_QWORD *)v13 > v9 + 1)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v116 = VRTraceErrorLogLevelToCSTR();
        v117 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315906;
          v179 = v116;
          v180 = 2080;
          v181 = "SIPKeyExchangeProc";
          v182 = 1024;
          v183 = 739;
          v184 = 1024;
          *(_DWORD *)v185 = v14;
          _os_log_impl(&dword_1D8A54000, v117, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SKEProc: SKESeq (%d) unexpected", buf, 0x22u);
        }
      }
      SIPReportSKError(v1, v5, v169, v170, 6, 741, (uint64_t)"Out Of Sequence");
      v6 = -1073086451;
      goto LABEL_203;
    }
    if (v14 >= 6)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          SIPKeyExchangeProc_cold_4();
      }
      SIPReportSKError(v1, v5, v169, v170, 7, 748, (uint64_t)"Out Of Bounds");
      v6 = -1073086451;
      goto LABEL_203;
    }
    if (!v171 && !*((_DWORD *)v177 + 140))
    {
      v153 = v8;
      v160 = 6;
      (*(void (**)(uint64_t, _QWORD, uint64_t, _QWORD, const char *, _QWORD, CFTypeRef *, int *))(v5 + 32))(v1, *(_QWORD *)(v5 + 40), 6, v169, "SKEComplete", 0, &v173, &v170);
      v167 = 0;
      goto LABEL_134;
    }
    v30 = *(_DWORD *)(v13 + 8);
    if (v30 < 0 || v158 >= 1 && v158 - 1 != v30)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v31 = VRTraceErrorLogLevelToCSTR();
        v32 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316162;
          v179 = v31;
          v180 = 2080;
          v181 = "SIPKeyExchangeProc";
          v182 = 1024;
          v183 = 770;
          v184 = 1024;
          *(_DWORD *)v185 = v14;
          *(_WORD *)&v185[4] = 1024;
          *(_DWORD *)&v185[6] = v30;
          _os_log_impl(&dword_1D8A54000, v32, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SKEProc: SKESeq (%d,%d)", buf, 0x28u);
        }
      }
      goto LABEL_53;
    }
    v35 = *((unsigned int *)v177 + 140);
    if ((int)v35 >= 1)
    {
      if (v177[69])
        break;
    }
LABEL_77:
    v153 = v8;
    if (v30)
    {
      v167 = 0;
      v160 = 6;
      v158 = v30;
      goto LABEL_134;
    }
    if ((int)v167 > 0)
    {
      v158 = 0;
      goto LABEL_134;
    }
    v43 = CFDataCreateWithBytesNoCopy(0, v8, v157, bytesDeallocator);
    if (v172)
    {
      v44 = SecKeyExchangeUpdate();
      if (v44)
      {
        v132 = v44;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v133 = VRTraceErrorLogLevelToCSTR();
          v134 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136316418;
            v179 = v133;
            v180 = 2080;
            v181 = "SIPKeyExchangeProc";
            v182 = 1024;
            v183 = 863;
            v184 = 1024;
            *(_DWORD *)v185 = 863;
            *(_WORD *)&v185[4] = 1024;
            *(_DWORD *)&v185[6] = v132;
            *(_WORD *)v186 = 1024;
            *(_DWORD *)&v186[2] = v171;
            _os_log_error_impl(&dword_1D8A54000, v134, OS_LOG_TYPE_ERROR, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SIP.c:%d: SecKeyExchangeUpdate failed (%d, %d)", buf, 0x2Eu);
          }
        }
        CFRelease(v43);
        SIPReportSKError(v1, v5, v169, v170, 10, 866, (uint64_t)"Update Failed");
        v6 = -1073086430;
        goto LABEL_203;
      }
      CFRelease(v43);
      v6 = SKE_FormMessageS(v174, &v168, &v167, (_DWORD *)&v167 + 1, &v166);
      if (v174)
        CFRelease(v174);
      if (v6 < 0)
      {
        v135 = v169;
        v136 = v170;
        v137 = "Out of Memory";
        v138 = v1;
        v139 = v5;
        v140 = 8;
        v141 = 876;
        goto LABEL_268;
      }
    }
    else
    {
      AsResponder = SecKeyExchangeNodeCreateAsResponder();
      CFRelease(v43);
      if (AsResponder)
      {
        v106 = v8;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            SIPKeyExchangeProc_cold_9();
        }
        v160 = 42;
        goto LABEL_190;
      }
      v6 = SKE_FormMessageS(v174, &v168, &v167, (_DWORD *)&v167 + 1, &v166);
      CFRelease(v174);
      if (v6 < 0)
      {
        SIPReportSKError(v1, v5, v169, v170, 8, 849, (uint64_t)"Out of Memory");
        v160 = 42;
        goto LABEL_203;
      }
      v160 = 6;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v46 = VRTraceErrorLogLevelToCSTR();
      v47 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136316418;
        v179 = v46;
        v180 = 2080;
        v181 = "SIPKeyExchangeProc";
        v182 = 1024;
        v183 = 882;
        v184 = 1024;
        *(_DWORD *)v185 = 0;
        *(_WORD *)&v185[4] = 1024;
        *(_DWORD *)&v185[6] = v171;
        *(_WORD *)v186 = 1024;
        *(_DWORD *)&v186[2] = v167;
        _os_log_impl(&dword_1D8A54000, v47, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SKEProc: u= %d,%d,[%d]", buf, 0x2Eu);
      }
    }
    v48 = v171;
    if (v171 == 2)
    {
      LODWORD(cf) = -1431655766;
      v164 = -1431655766;
      PeerAbortReason = SecKeyExchangeGetPeerAbortReason();
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v126 = VRTraceErrorLogLevelToCSTR();
        v127 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316418;
          v179 = v126;
          v180 = 2080;
          v181 = "SIPKeyExchangeProc";
          v182 = 1024;
          v183 = 889;
          v184 = 1024;
          *(_DWORD *)v185 = v164;
          *(_WORD *)&v185[4] = 1024;
          *(_DWORD *)&v185[6] = (_DWORD)cf;
          *(_WORD *)v186 = 1024;
          *(_DWORD *)&v186[2] = PeerAbortReason;
          _os_log_impl(&dword_1D8A54000, v127, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SKEProc: aborted by remote: %d (%d %d)", buf, 0x2Eu);
        }
      }
      v6 = -1073086460;
      TACloseHandle();
      v175 = 0xFFFFFFFFLL;
      if ((TACreateHandle(&v175, 3, *(_QWORD *)(v5 + 24), (uint64_t)v177, v176, (uint64_t)TUMsgCallback, v177[125]) & 0x80000000) != 0)
      {
        v128 = v8;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            SIPKeyExchangeProc_cold_7();
        }
        v142 = v169;
        v143 = v170;
        v144 = "TA Create Failed";
        v145 = v1;
        v146 = v5;
        v147 = 13;
        v148 = 900;
      }
      else
      {
        v128 = v8;
        if ((TAStart((void *)v175) & 0x80000000) == 0)
        {
          if ((SendTAStatus(v175, (uint64_t)v177, 0xFFFFFFFFLL, 52, 0, 0, *(_DWORD *)(v5 + 8)) & 0x80000000) != 0)
          {
            SendTPStatus(*(_QWORD *)(v5 + 24), (uint64_t)v177, 52, 0, 0, *(_DWORD *)(v5 + 8));
            TACancel();
            v177 = 0;
          }
          (*(void (**)(uint64_t, _QWORD, uint64_t, _QWORD, const char *, _QWORD, _QWORD, int *))(v5 + 32))(v1, *(_QWORD *)(v5 + 40), 6, v169, "SKEComplete", 0, 0, &v170);
          v177 = 0;
          v6 = -1073086434;
LABEL_287:
          v8 = v128;
          v160 = 52;
LABEL_203:
          v7 = v160;
          if (!v8)
            goto LABEL_205;
LABEL_204:
          free(v8);
          goto LABEL_205;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            SIPKeyExchangeProc_cold_8();
        }
        v177 = 0;
        v142 = v169;
        v143 = v170;
        v144 = "TA Start Failed";
        v145 = v1;
        v146 = v5;
        v147 = 14;
        v148 = 908;
      }
      SIPReportSKError(v145, v146, v142, v143, v147, v148, (uint64_t)v144);
      goto LABEL_287;
    }
    if (v171 >= 2)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v129 = VRTraceErrorLogLevelToCSTR();
        v130 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315906;
          v179 = v129;
          v180 = 2080;
          v181 = "SIPKeyExchangeProc";
          v182 = 1024;
          v183 = 930;
          v184 = 1024;
          *(_DWORD *)v185 = v171;
          _os_log_impl(&dword_1D8A54000, v130, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SKEProc: error while SKEUpdate (%d)", buf, 0x22u);
        }
      }
      v6 = -1073086460;
      v135 = v169;
      v136 = v170;
      v137 = "Update Error";
      v138 = v1;
      v139 = v5;
      v140 = 11;
      v141 = 932;
LABEL_268:
      SIPReportSKError(v138, v139, v135, v136, v140, v141, (uint64_t)v137);
      goto LABEL_203;
    }
    if (!*(_QWORD *)(v5 + 48) || v155)
      goto LABEL_131;
    v163 = -1431655766;
    v164 = -1431655766;
    cf = 0;
    PeerCertStatus = SecKeyExchangeGetPeerCertStatus();
    if (PeerCertStatus)
    {
      v50 = PeerCertStatus;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v51 = VRTraceErrorLogLevelToCSTR();
        v52 = *MEMORY[0x1E0CF2758];
        v155 = 0;
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315906;
          v179 = v51;
          v180 = 2080;
          v181 = "SIPKeyExchangeProc";
          v182 = 1024;
          v183 = 947;
          v184 = 1024;
          *(_DWORD *)v185 = v50;
          v53 = v52;
          v54 = "SIP [%s] %s:%d SKE peerCertStatus failed (%d)";
          goto LABEL_101;
        }
LABEL_130:
        v48 = v171;
LABEL_131:
        if (!v48)
        {
          v69 = SecKeyExchangeCopySharedSecret();
          if (v69)
          {
            v149 = v69;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7
              && (v150 = VRTraceErrorLogLevelToCSTR(),
                  v151 = *MEMORY[0x1E0CF2758],
                  os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT)))
            {
              *(_DWORD *)buf = 136315906;
              v179 = v150;
              v180 = 2080;
              v181 = "SIPKeyExchangeProc";
              v182 = 1024;
              v183 = 1023;
              v184 = 1024;
              *(_DWORD *)v185 = v149;
              _os_log_impl(&dword_1D8A54000, v151, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SKE CopySecret failed (%d)", buf, 0x22u);
              v6 = 0;
            }
            else
            {
              v6 = 0;
            }
            goto LABEL_243;
          }
        }
        v158 = 0;
        v157 = 0;
        goto LABEL_134;
      }
LABEL_129:
      v155 = 0;
      goto LABEL_130;
    }
    if (v163)
    {
      if (v163 != 2)
      {
        if (v163 == 1)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() < 7)
            goto LABEL_129;
          v56 = VRTraceErrorLogLevelToCSTR();
          v57 = *MEMORY[0x1E0CF2758];
          v155 = 0;
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            goto LABEL_130;
          *(_DWORD *)buf = 136315650;
          v179 = v56;
          v180 = 2080;
          v181 = "SIPKeyExchangeProc";
          v182 = 1024;
          v183 = 950;
          v53 = v57;
          v54 = "SIP [%s] %s:%d SKE peerCertStatus not yet valid";
        }
        else
        {
          if ((int)VRTraceGetErrorLogLevelForModule() < 7)
            goto LABEL_129;
          v67 = VRTraceErrorLogLevelToCSTR();
          v68 = *MEMORY[0x1E0CF2758];
          v155 = 0;
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            goto LABEL_130;
          *(_DWORD *)buf = 136315650;
          v179 = v67;
          v180 = 2080;
          v181 = "SIPKeyExchangeProc";
          v182 = 1024;
          v183 = 957;
          v53 = v68;
          v54 = "SIP [%s] %s:%d SKE peerCertStatus not ready";
        }
LABEL_127:
        v55 = 28;
LABEL_128:
        _os_log_impl(&dword_1D8A54000, v53, OS_LOG_TYPE_DEFAULT, v54, buf, v55);
        goto LABEL_129;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() < 7)
        goto LABEL_116;
      v62 = VRTraceErrorLogLevelToCSTR();
      v63 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        goto LABEL_116;
      *(_DWORD *)buf = 136315650;
      v179 = v62;
      v180 = 2080;
      v181 = "SIPKeyExchangeProc";
      v182 = 1024;
      v183 = 953;
      v60 = v63;
      v61 = "SIP [%s] %s:%d SKE peerCertStatus no value";
      goto LABEL_115;
    }
    if (v164 != 1)
    {
      v88 = SecKeyExchangeCopyPeerCert();
      if (v88)
      {
        v89 = v88;
        if ((int)VRTraceGetErrorLogLevelForModule() < 7)
          goto LABEL_129;
        v90 = VRTraceErrorLogLevelToCSTR();
        v91 = *MEMORY[0x1E0CF2758];
        v155 = 0;
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          goto LABEL_130;
        *(_DWORD *)buf = 136315906;
        v179 = v90;
        v180 = 2080;
        v181 = "SIPKeyExchangeProc";
        v182 = 1024;
        v183 = 967;
        v184 = 1024;
        *(_DWORD *)v185 = v89;
        v53 = v91;
        v54 = "SIP [%s] %s:%d SKE CopyCert failed (%d)";
LABEL_101:
        v55 = 34;
        goto LABEL_128;
      }
      if (v163 == 1)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() < 7)
          goto LABEL_129;
        v92 = VRTraceErrorLogLevelToCSTR();
        v93 = *MEMORY[0x1E0CF2758];
        v155 = 0;
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          goto LABEL_130;
        *(_DWORD *)buf = 136315650;
        v179 = v92;
        v180 = 2080;
        v181 = "SIPKeyExchangeProc";
        v182 = 1024;
        v183 = 970;
        v53 = v93;
        v54 = "SIP [%s] %s:%d SKE CopyCert not yet valid";
        goto LABEL_127;
      }
      v64 = cf;
      goto LABEL_117;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v58 = VRTraceErrorLogLevelToCSTR();
      v59 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        v179 = v58;
        v180 = 2080;
        v181 = "SIPKeyExchangeProc";
        v182 = 1024;
        v183 = 960;
        v60 = v59;
        v61 = "SIP [%s] %s:%d SKE no cert";
LABEL_115:
        _os_log_impl(&dword_1D8A54000, v60, OS_LOG_TYPE_DEFAULT, v61, buf, 0x1Cu);
      }
    }
LABEL_116:
    v64 = 0;
    cf = 0;
LABEL_117:
    v161 = 0;
    (*(void (**)(uint64_t, _QWORD, uint64_t, _QWORD, const char *, int *, CFTypeRef, int *))(v5 + 32))(v1, *(_QWORD *)(v5 + 40), 6, v169, "SKECheckRemoteCert", &v161, v64, &v170);
    if (cf)
      CFRelease(cf);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v65 = VRTraceErrorLogLevelToCSTR();
      v66 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        v179 = v65;
        v180 = 2080;
        v181 = "SIPKeyExchangeProc";
        v182 = 1024;
        v183 = 986;
        v184 = 1024;
        *(_DWORD *)v185 = v161;
        _os_log_impl(&dword_1D8A54000, v66, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d ~_~ SKEProc isValid = %d", buf, 0x22u);
      }
    }
    if (v161)
    {
      v155 = 1;
      goto LABEL_130;
    }
    if (v171)
    {
      v84 = SecKeyExchangeAbortSession();
      if (v84)
      {
        v85 = v84;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v86 = VRTraceErrorLogLevelToCSTR();
          v87 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315906;
            v179 = v86;
            v180 = 2080;
            v181 = "SIPKeyExchangeProc";
            v182 = 1024;
            v183 = 996;
            v184 = 1024;
            *(_DWORD *)v185 = v85;
            _os_log_impl(&dword_1D8A54000, v87, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SKE abort error %d", buf, 0x22u);
          }
        }
      }
      v6 = SKE_FormMessageS(v174, &v168, &v167, (_DWORD *)&v167 + 1, &v166);
      if (v174)
        CFRelease(v174);
      if (v6 < 0)
      {
        v118 = v169;
        v119 = v170;
        v120 = "Out of Memory";
        v121 = v1;
        v122 = v5;
        v123 = 8;
        v124 = 1002;
        goto LABEL_241;
      }
    }
    (*(void (**)(uint64_t, _QWORD, uint64_t, _QWORD, const char *, _QWORD, _QWORD, int *))(v5 + 32))(v1, *(_QWORD *)(v5 + 40), 6, v169, "SKEComplete", 0, 0, &v170);
    v158 = 0;
    v157 = 0;
    v160 = 52;
    v155 = 1;
LABEL_134:
    v70 = v167;
    v71 = SHIDWORD(v167);
    if ((int)v167 - HIDWORD(v167) >= 900)
      v72 = 900;
    else
      v72 = v167 - HIDWORD(v167);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v73 = VRTraceErrorLogLevelToCSTR();
      v74 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        if (v72)
        {
          v75 = *(unsigned __int8 *)v168;
          v76 = *((char *)v168 + v72 - 1);
        }
        else
        {
          v75 = -1;
          v76 = -1;
        }
        v77 = *(_QWORD *)(v5 + 48);
        *(_DWORD *)buf = 136316930;
        v179 = v73;
        v180 = 2080;
        v181 = "SIPKeyExchangeProc";
        v182 = 1024;
        v183 = 1038;
        v184 = 2048;
        *(_QWORD *)v185 = v14;
        *(_WORD *)&v185[8] = 1024;
        *(_DWORD *)v186 = v72;
        *(_WORD *)&v186[4] = 1024;
        *(_DWORD *)v187 = v75;
        *(_WORD *)&v187[4] = 1024;
        *(_DWORD *)v188 = v76;
        *(_WORD *)&v188[4] = 2048;
        v189 = v77;
        _os_log_impl(&dword_1D8A54000, v74, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SKEProc (%lu) resp with (%d) [%02X..%02X] [ident = %p]", buf, 0x42u);
      }
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v78 = VRTraceErrorLogLevelToCSTR();
      v79 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        v179 = v78;
        v180 = 2080;
        v181 = "SIPKeyExchangeProc";
        v182 = 1024;
        v183 = 1041;
        _os_log_impl(&dword_1D8A54000, v79, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SKEProc: closing TA", buf, 0x1Cu);
      }
    }
    TACloseHandle();
    v175 = 0xFFFFFFFFLL;
    if ((TACreateHandle(&v175, 3, *(_QWORD *)(v5 + 24), (uint64_t)v177, v176, (uint64_t)TUMsgCallback, v177[125]) & 0x80000000) != 0)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          SIPKeyExchangeProc_cold_5();
      }
      v6 = -1073086460;
      SIPReportSKError(v1, v5, v169, v170, 13, 1049, (uint64_t)"TA Create Failed");
      goto LABEL_243;
    }
    if ((TAStart((void *)v175) & 0x80000000) != 0)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          SIPKeyExchangeProc_cold_6();
      }
      v6 = -1073086460;
      v177 = 0;
      v118 = v169;
      v119 = v170;
      v120 = "TA Start Failed";
      v121 = v1;
      v122 = v5;
      v123 = 14;
      v124 = 1057;
LABEL_241:
      SIPReportSKError(v121, v122, v118, v119, v123, v124, (uint64_t)v120);
LABEL_243:
      v8 = v153;
      goto LABEL_203;
    }
    v80 = (v70 + ~(_DWORD)v71) / 900;
    if (!v72)
      v80 = 0;
    v82 = v176;
    v81 = v177;
    *(_DWORD *)(v177[66] + 8) = v80;
    if (v72)
      v83 = (char *)v168 + v71;
    else
      v83 = 0;
    v6 = SendTAStatusGeneric(v175, (uint64_t)v81, v82, v160, v83, v72, 1, 0, *(_DWORD *)(v5 + 8));
    if (v6 < 0)
    {
      SendTPStatus(*(_QWORD *)(v5 + 24), (uint64_t)v177, v160, 0, 0, *(_DWORD *)(v5 + 8));
      TACancel();
      v177 = 0;
      goto LABEL_243;
    }
    if (v72)
    {
      HIDWORD(v167) = v72 + v71;
      if (v72 + (_DWORD)v71 == v70)
        v167 = 0;
    }
    v177 = 0;
    v8 = v153;
    if ((v152 & 1) == 0)
      goto LABEL_203;
LABEL_53:
    v165 = -1431655766;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v33 = VRTraceErrorLogLevelToCSTR();
      v34 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        v179 = v33;
        v180 = 2080;
        v181 = "SIPKeyExchangeProc";
        v182 = 1024;
        v183 = 657;
        v184 = 1024;
        *(_DWORD *)v185 = v14;
        _os_log_impl(&dword_1D8A54000, v34, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SKEProc TOP (%d)", buf, 0x22u);
      }
    }
    if (v177)
    {
      FreeSipMsg(v177);
      v177 = 0;
    }
    v6 = DLGetMsg(v176, &v177, 0x7530uLL, 7, 0, -1);
    if ((DLGetState(v176, &v165) & 0x80000000) != 0 || v165 != 3)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v94 = VRTraceErrorLogLevelToCSTR();
        v95 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315906;
          v179 = v94;
          v180 = 2080;
          v181 = "SIPKeyExchangeProc";
          v182 = 1024;
          v183 = 669;
          v184 = 1024;
          *(_DWORD *)v185 = v165;
          v96 = "SIP [%s] %s:%d SIPDoSKE: terminated by remote party (%d)";
          v97 = v95;
          v98 = 34;
          goto LABEL_201;
        }
      }
      goto LABEL_202;
    }
    if (v6 < 0)
    {
      v106 = v8;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          SIPKeyExchangeProc_cold_2();
      }
      v99 = v169;
      v100 = v170;
      v101 = "Dialog Timeout";
      v102 = v1;
      v103 = v5;
      v104 = 1;
      v105 = 676;
LABEL_189:
      SIPReportSKError(v102, v103, v99, v100, v104, v105, (uint64_t)v101);
LABEL_190:
      v8 = v106;
      goto LABEL_203;
    }
    v10 = v177;
    v9 = v14;
    if (!v177)
    {
      v106 = v8;
      v107 = VRTraceGetErrorLogLevelForModule();
      if (v107 >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          SIPKeyExchangeProc_cold_3();
      }
      v99 = v169;
      v100 = v170;
      v101 = "NULL Message";
      v102 = v1;
      v103 = v5;
      v104 = 2;
      v105 = 682;
      goto LABEL_189;
    }
  }
  if (v8)
  {
    v36 = v35 + v157;
    if (v156 >= v36)
    {
      v37 = v8;
    }
    else
    {
      v37 = (UInt8 *)malloc_type_realloc(v8, v36 + 2000, 0x29AB216FuLL);
      if (!v37)
      {
        v131 = VRTraceGetErrorLogLevelForModule();
        if (v131 >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            SIPKeyExchangeProc_cold_11();
        }
        SIPReportSKError(v1, v5, v169, v170, 8, 795, (uint64_t)"Out of Memory");
        v6 = -1073086461;
        v7 = v160;
        goto LABEL_204;
      }
    }
    goto LABEL_73;
  }
  v156 = v35 + 2000;
  v38 = (UInt8 *)malloc_type_malloc(v35 + 2000, 0xAFDBFC98uLL);
  if (v38)
  {
    v37 = v38;
LABEL_73:
    memcpy(&v37[v157], (const void *)v177[69], *((int *)v177 + 140));
    v157 += *((_DWORD *)v177 + 140);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v159 = VRTraceErrorLogLevelToCSTR();
      v39 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v40 = *((int *)v177 + 140);
        v41 = (char *)v177[69];
        v42 = *v41;
        LODWORD(v41) = v41[v40 - 1];
        *(_DWORD *)buf = 136317186;
        v179 = v159;
        v180 = 2080;
        v181 = "SIPKeyExchangeProc";
        v182 = 1024;
        v183 = 807;
        v184 = 1024;
        *(_DWORD *)v185 = v14;
        *(_WORD *)&v185[4] = 1024;
        *(_DWORD *)&v185[6] = v30;
        *(_WORD *)v186 = 1024;
        *(_DWORD *)&v186[2] = v157;
        *(_WORD *)v187 = 1024;
        *(_DWORD *)&v187[2] = v40;
        *(_WORD *)v188 = 1024;
        *(_DWORD *)&v188[2] = v42;
        LOWORD(v189) = 1024;
        *(_DWORD *)((char *)&v189 + 2) = (_DWORD)v41;
        _os_log_impl(&dword_1D8A54000, v39, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SKEProc: Got msg (%d;%d) into %d - (%d) [%02X...%02X]",
          buf,
          0x40u);
      }
    }
    v8 = v37;
    goto LABEL_77;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      SIPKeyExchangeProc_cold_10();
  }
  SIPReportSKError(v1, v5, v169, v170, 8, 786, (uint64_t)"Out of Memory");
  v6 = -1073086461;
  v7 = v160;
LABEL_205:
  if (v168)
    free(v168);
  if (v175 == 0xFFFFFFFFLL || ((1 << v7) & 0x10000000000041) != 0)
  {
    if (v177)
      FreeSipMsg(v177);
  }
  else
  {
    v6 = SendTAStatus(v175, (uint64_t)v177, 0xFFFFFFFFLL, v7, 0, 0, *(_DWORD *)(v5 + 8));
    if (v6 < 0)
    {
      SendTPStatus(*(_QWORD *)(v5 + 24), (uint64_t)v177, v7, 0, 0, *(_DWORD *)(v5 + 8));
      TACancel();
    }
    (*(void (**)(uint64_t, _QWORD, uint64_t, _QWORD, const char *, _QWORD, _QWORD, int *))(v5 + 32))(v1, *(_QWORD *)(v5 + 40), 6, v169, "SKEComplete", 0, 0, &v170);
    v177 = 0;
  }
  if (v172)
    SecKeyExchangeNodeRelease();
  if (v173)
    CFRelease(v173);
  if (v6 < 0 && v175 != 0xFFFFFFFFLL)
    TACancel();
  DLSetDoingKeyExchange(v176, 0);
  TACloseHandle();
  CheckOutHandleDebug();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v112 = VRTraceErrorLogLevelToCSTR();
    v113 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      IntStatusCode = GetIntStatusCode(v7);
      *(_DWORD *)buf = 136315906;
      v179 = v112;
      v180 = 2080;
      v181 = "SIPKeyExchangeProc";
      v182 = 1024;
      v183 = 1131;
      v184 = 1024;
      *(_DWORD *)v185 = IntStatusCode;
      _os_log_impl(&dword_1D8A54000, v113, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPKeyExchangeProc Thread end(%d)...", buf, 0x22u);
    }
  }
  return 0;
}

uint64_t SIPMessageProc(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  NSObject *v9;
  int v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  void (**v15)(_QWORD, _QWORD, _QWORD);
  CFStringRef v16;
  int v17;
  uint64_t v18;
  NSObject *v19;
  int IntStatusCode;
  uint64_t v22;
  int v23[2];
  uint64_t v24;
  uint8_t buf[4];
  uint64_t v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  __int16 v33;
  uint64_t v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)v23 = 0xFFFFFFFFLL;
  v24 = 0xFFFFFFFFLL;
  v2 = **(_QWORD **)(a1 + 1000);
  v22 = -1;
  pthread_setname_np("com.apple.avconference.sip.messageproc");
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v3 = VRTraceErrorLogLevelToCSTR();
    v4 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      v26 = v3;
      v27 = 2080;
      v28 = "SIPMessageProc";
      v29 = 1024;
      v30 = 1382;
      _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPMessageProc Thread start...", buf, 0x1Cu);
    }
  }
  if (!*(_QWORD *)(a1 + 552))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v8 = VRTraceErrorLogLevelToCSTR();
      v9 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v10 = *(_DWORD *)(a1 + 560);
        v11 = *(_QWORD *)(a1 + 552);
        *(_DWORD *)buf = 136316162;
        v26 = v8;
        v27 = 2080;
        v28 = "SIPMessageProc";
        v29 = 1024;
        v30 = 1385;
        v31 = 1024;
        v32 = v10;
        v33 = 2048;
        v34 = v11;
        _os_log_error_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_ERROR, "SIP [%s] %s:%d SIP MESSAGE is missing a body - length = %d, body = %p", buf, 0x2Cu);
      }
    }
    goto LABEL_14;
  }
  v5 = CheckInHandleDebug();
  if (!v5)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SIPMessageProc_cold_1();
    }
LABEL_14:
    FreeSipMsg((_QWORD *)a1);
    return 0;
  }
  v6 = v5;
  if (*(_DWORD *)(a1 + 132))
  {
    v7 = 25;
  }
  else
  {
    if ((TACreateHandle((uint64_t *)v23, 3, *(_QWORD *)(v5 + 24), a1, 0xFFFFFFFFLL, (uint64_t)TUMsgCallback, *(_QWORD *)(a1 + 1000)) & 0x80000000) != 0)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          SIPMessageProc_cold_2();
      }
    }
    else
    {
      if ((TAStart(*(void **)v23) & 0x80000000) == 0)
      {
        v12 = *(uint64_t **)(a1 + 272);
        if (v12)
        {
          v13 = *v12;
          v22 = *v12;
        }
        else
        {
          v13 = 0xFFFFFFFFLL;
        }
        if ((DLFindWithSipMsgAndLock(&v24, a1) & 0x80000000) != 0)
        {
          v17 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, _QWORD, _QWORD, _QWORD, uint64_t *, _QWORD))(v6 + 32))(v2, *(_QWORD *)(v6 + 40), 6, 0, *(_QWORD *)(a1 + 552), 0, &v22, 0);
        }
        else
        {
          *(_DWORD *)buf = -1431655766;
          DLGetCallID(v24, buf);
          v14 = SIPClientDictionaryCInterface_CopyObjectForKey(*(void **)(v6 + 136), CFSTR("SIPMessageReceivedHandler"), *(unsigned int *)buf);
          if (v14)
          {
            v15 = (void (**)(_QWORD, _QWORD, _QWORD))v14;
            v16 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *(const char **)(a1 + 552), 0x8000100u);
            ((void (**)(_QWORD, CFStringRef, uint64_t))v15)[2](v15, v16, v13);
            if (v16)
              CFRelease(v16);
            _Block_release(v15);
            v17 = 0;
          }
          else
          {
            v17 = 1;
          }
          DLUnlock();
        }
        if (v17)
          v7 = 19;
        else
          v7 = 6;
        goto LABEL_38;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          SIPMessageProc_cold_3();
      }
    }
    v7 = 42;
  }
LABEL_38:
  if ((SendTAStatus(*(uint64_t *)v23, a1, 0xFFFFFFFFLL, v7, 0, 0, *(_DWORD *)(v6 + 8)) & 0x80000000) != 0)
  {
    SendTPStatus(*(_QWORD *)(v6 + 24), a1, v7, 0, 0, *(_DWORD *)(v6 + 8));
    TACancel();
  }
  if (*(_QWORD *)v23 == 0xFFFFFFFFLL)
    FreeSipMsg((_QWORD *)a1);
  else
    TACloseHandle();
  CheckOutHandleDebug();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v18 = VRTraceErrorLogLevelToCSTR();
    v19 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      IntStatusCode = GetIntStatusCode(v7);
      *(_DWORD *)buf = 136315906;
      v26 = v18;
      v27 = 2080;
      v28 = "SIPMessageProc";
      v29 = 1024;
      v30 = 1471;
      v31 = 1024;
      v32 = IntStatusCode;
      _os_log_impl(&dword_1D8A54000, v19, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d SIPMessageProc Thread end(%d)...", buf, 0x22u);
    }
  }
  return 0;
}

uint64_t SendTPStatus(uint64_t a1, uint64_t a2, int a3, char *__s, _OWORD *a5, int a6)
{
  uint64_t Status;
  _OWORD *v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  void *v20[2];

  v20[1] = *(void **)MEMORY[0x1E0C80C00];
  v20[0] = (void *)0xAAAAAAAAAAAAAAAALL;
  Status = CreateStatus((unint64_t *)v20, a2, a3, 0, __s, a6, 0);
  if ((Status & 0x80000000) != 0)
  {
    v18 = Status;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SendTPStatus_cold_1();
    }
  }
  else
  {
    v11 = v20[0];
    if (__s && a5)
      *((_OWORD *)v20[0] + 61) = *a5;
    v12 = *(_OWORD *)(a2 + 576);
    v13 = *(_OWORD *)(a2 + 592);
    v14 = *(_OWORD *)(a2 + 624);
    v11[38] = *(_OWORD *)(a2 + 608);
    v11[39] = v14;
    v11[36] = v12;
    v11[37] = v13;
    v15 = *(_OWORD *)(a2 + 640);
    v16 = *(_OWORD *)(a2 + 656);
    v17 = *(_OWORD *)(a2 + 672);
    *((_QWORD *)v11 + 86) = *(_QWORD *)(a2 + 688);
    v11[41] = v16;
    v11[42] = v17;
    v11[40] = v15;
    v18 = TPSend(a1);
    FreeSipMsg((_QWORD *)v20[0]);
  }
  return v18;
}

uint64_t SendTAStatus(uint64_t a1, uint64_t a2, uint64_t a3, int a4, char *__s, _OWORD *a6, int a7)
{
  int v14;
  uint64_t v15;
  NSObject *v16;
  uint8_t buf[4];
  uint64_t v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (__s)
    v14 = strlen(__s);
  else
    v14 = 0;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v15 = VRTraceErrorLogLevelToCSTR();
    v16 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      v19 = v15;
      v20 = 2080;
      v21 = "SendTAStatus";
      v22 = 1024;
      v23 = 140;
      v24 = 1024;
      v25 = v14;
      _os_log_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d |        |        |        |    --- iBodyLen %d", buf, 0x22u);
    }
  }
  return SendTAStatusGeneric(a1, a2, a3, a4, __s, v14, 0, a6, a7);
}

uint64_t SendTAStatusGeneric(uint64_t a1, uint64_t a2, uint64_t a3, int a4, char *a5, int a6, int a7, _OWORD *a8, int a9)
{
  uint64_t v17;
  uint64_t GenericStatus;
  int v20;
  int v21;
  uint64_t v22;
  NSObject *v23;
  uint64_t v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  int v31;
  uint64_t v32;
  _DWORD __b[228];
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if (!a4)
    return TASend(a1, 0);
  v32 = 0xAAAAAAAAAAAAAAAALL;
  if (a3 == 0xFFFFFFFFLL)
  {
    GenericStatus = CreateGenericStatus((unint64_t *)&v32, a2, a4, 0, a5, a6, a7, a9, 0);
    if ((GenericStatus & 0x80000000) == 0)
    {
LABEL_17:
      v24 = v32;
      if (a5)
      {
        if (a8)
          *(_OWORD *)(v32 + 976) = *a8;
      }
      v25 = *(_OWORD *)(a2 + 576);
      v26 = *(_OWORD *)(a2 + 592);
      v27 = *(_OWORD *)(a2 + 624);
      *(_OWORD *)(v24 + 608) = *(_OWORD *)(a2 + 608);
      *(_OWORD *)(v24 + 624) = v27;
      *(_OWORD *)(v24 + 576) = v25;
      *(_OWORD *)(v24 + 592) = v26;
      v28 = *(_OWORD *)(a2 + 640);
      v29 = *(_OWORD *)(a2 + 656);
      v30 = *(_OWORD *)(a2 + 672);
      *(_QWORD *)(v24 + 688) = *(_QWORD *)(a2 + 688);
      *(_OWORD *)(v24 + 656) = v29;
      *(_OWORD *)(v24 + 672) = v30;
      *(_OWORD *)(v24 + 640) = v28;
      return TASend(a1, (_QWORD *)v24);
    }
LABEL_21:
    v17 = GenericStatus;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        SendTAStatusGeneric_cold_1();
    }
    return v17;
  }
  v31 = -1431655766;
  if ((DLGetState(a3, &v31) & 0x80000000) != 0)
  {
LABEL_12:
    GenericStatus = CreateGenericStatus((unint64_t *)&v32, a2, a4, 0, a5, a6, a7, a9, 0);
    if ((GenericStatus & 0x80000000) == 0)
    {
      v20 = DLUpdate(a3, v32);
      if (v20 < 0)
      {
        v21 = v20;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          v22 = VRTraceErrorLogLevelToCSTR();
          v23 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            __b[0] = 136316162;
            *(_QWORD *)&__b[1] = v22;
            LOWORD(__b[3]) = 2080;
            *(_QWORD *)((char *)&__b[3] + 2) = "SendTAStatusGeneric";
            HIWORD(__b[5]) = 1024;
            __b[6] = 122;
            LOWORD(__b[7]) = 1024;
            *(_DWORD *)((char *)&__b[7] + 2) = 122;
            HIWORD(__b[8]) = 1024;
            __b[9] = v21;
            _os_log_impl(&dword_1D8A54000, v23, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SIP.c:%d: DLUpdate failed(%08X)", (uint8_t *)__b, 0x28u);
          }
        }
      }
      goto LABEL_17;
    }
    goto LABEL_21;
  }
  if (v31 != 4)
  {
    if (!*(_BYTE *)(*(_QWORD *)(a2 + 480) + 156))
    {
      memset(__b, 170, 0x388uLL);
      if ((DLGetData(a3, (uint64_t)__b) & 0x80000000) == 0)
        strlcpy((char *)(*(_QWORD *)(a2 + 480) + 156), (const char *)&__b[93] + 2, 0x40uLL);
    }
    goto LABEL_12;
  }
  return 2148139038;
}

void SIPReportSKError(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, uint64_t a6, uint64_t a7)
{
  CFNumberRef v12;
  CFStringRef v13;
  CFStringRef v14;
  CFStringRef v15;
  CFDictionaryRef v16;
  int valuePtr;
  int v18;
  void *values[4];
  void *keys[2];
  __int128 v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  valuePtr = a5;
  v18 = a4;
  v12 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &valuePtr);
  v13 = CFStringCreateWithFormat(0, 0, CFSTR("%s:%d"), "/Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SIP.c", a6);
  v14 = CFStringCreateWithFormat(0, 0, CFSTR("%s"), "SKE Error");
  v15 = CFStringCreateWithFormat(0, 0, CFSTR("%s"), a7);
  *(_OWORD *)keys = xmmword_1E9E552C0;
  v21 = off_1E9E552D0;
  values[0] = v12;
  values[1] = (void *)v13;
  values[2] = (void *)v14;
  values[3] = (void *)v15;
  v16 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 4, 0, 0);
  (*(void (**)(uint64_t, _QWORD, uint64_t, uint64_t, const char *, _QWORD, CFDictionaryRef, int *))(a2 + 32))(a1, *(_QWORD *)(a2 + 40), 6, a3, "SKEReportError", 0, v16, &v18);
  CFRelease(v16);
  CFRelease(v15);
  CFRelease(v14);
  CFRelease(v13);
  CFRelease(v12);
}

uint64_t SKE_FormMessageS(const __CFData *a1, void **a2, _DWORD *a3, _DWORD *a4, int *a5)
{
  void *v9;
  int v10;
  int Length;
  int v13;
  void *v14;
  uint64_t v15;
  const UInt8 *BytePtr;

  v9 = *a2;
  v10 = *a5;
  if (!a1)
  {
    v13 = 0;
LABEL_12:
    v15 = 0;
    *a2 = v9;
    *a3 = v13;
    *a4 = 0;
    *a5 = v10;
    return v15;
  }
  Length = CFDataGetLength(a1);
  v13 = Length;
  if (v9)
  {
    if (v10 >= Length)
    {
LABEL_11:
      BytePtr = CFDataGetBytePtr(a1);
      memcpy(v9, BytePtr, v13);
      goto LABEL_12;
    }
    v10 = Length + 2000;
    v14 = malloc_type_realloc(v9, Length + 2000, 0x6BBA9FDEuLL);
    if (!v14)
    {
      v15 = 3221880835;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          SKE_FormMessageS_cold_2();
      }
      return v15;
    }
LABEL_10:
    v9 = v14;
    goto LABEL_11;
  }
  v10 = Length + 2000;
  v14 = malloc_type_malloc(Length + 2000, 0x33EFDADCuLL);
  if (v14)
    goto LABEL_10;
  v15 = 3221880835;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      SKE_FormMessageS_cold_1();
  }
  return v15;
}

uint64_t VCMediaWriterUtil_GetMetaDataArrayWithIndentifier(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD v16[2];
  _QWORD v17[2];
  _QWORD v18[2];
  uint64_t v19;
  _QWORD v20[5];
  _QWORD v21[5];
  _QWORD v22[2];
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD v26[7];

  v26[5] = *MEMORY[0x1E0C80C00];
  v2 = *MEMORY[0x1E0CA2498];
  v3 = *MEMORY[0x1E0CC4780];
  v22[0] = *MEMORY[0x1E0CC4778];
  v1 = v22[0];
  v22[1] = v3;
  v4 = *MEMORY[0x1E0CC4738];
  v26[0] = v2;
  v26[1] = v4;
  v6 = *MEMORY[0x1E0CC5C18];
  v7 = *MEMORY[0x1E0CC47B0];
  v23 = *MEMORY[0x1E0CC47A8];
  v5 = v23;
  v24 = v7;
  v8 = *MEMORY[0x1E0CA25A0];
  v26[2] = v6;
  v26[3] = v8;
  v25 = *MEMORY[0x1E0CC47E8];
  v9 = v25;
  v26[4] = a1;
  v10 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v26, v22, 5);
  v20[0] = v1;
  v20[1] = v3;
  v21[0] = v2;
  v21[1] = v4;
  v11 = *MEMORY[0x1E0CC5C20];
  v20[2] = v5;
  v20[3] = v7;
  v21[2] = v11;
  v21[3] = v8;
  v20[4] = v9;
  v21[4] = CFSTR("FaceTime");
  v12 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v21, v20, 5);
  v13 = *MEMORY[0x1E0CC47F0];
  v18[0] = *MEMORY[0x1E0CC4758];
  v14 = *MEMORY[0x1E0CC47F8];
  v17[0] = v13;
  v17[1] = v14;
  v16[0] = v10;
  v16[1] = v12;
  v18[1] = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v16, 2);
  v19 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v18, v17, 2);
  return objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v19, 1);
}

double VCMediaWriterUtil_CalculateImageSizeWithVisibleRect(char a1, int a2, int a3, double a4, double a5, double a6, double a7)
{
  double v7;
  double v8;

  v7 = (double)a2;
  v8 = a6 * (double)a3 / a7;
  if (a6 / a7 >= (double)(a2 / a3))
    v8 = (double)a2;
  if ((a1 & 2) != 0)
    v7 = v8;
  return (double)(int)((int)v7 & 0xFFFFFFFC);
}

VCFigAssetWriter *VCMediaWriterUtil_NewWriter(uint64_t a1, uint64_t a2, uint64_t a3, double a4)
{
  return -[VCFigAssetWriter initWithOutputURL:transactionID:videoCodec:keyFrameIntervalDuration:]([VCFigAssetWriter alloc], "initWithOutputURL:transactionID:videoCodec:keyFrameIntervalDuration:", a1, a2, a3, a4);
}

uint64_t VCMediaWriterUtil_SetUpWriterWithCaptureFormat(void *a1, uint64_t a2, int a3, int a4, uint64_t a5, double a6, double a7, double a8, double a9)
{
  return objc_msgSend(a1, "setupLivePhotoStillImageCameraStatusBit:resize:imageSize:", a2, a5, VCMediaWriterUtil_CalculateImageSizeWithVisibleRect(a2, a3, a4, a6, a7, a8, a9));
}

BOOL VCMediaWriterUtil_IsMediaExpected(int a1, int a2)
{
  _BOOL4 v2;
  _BOOL4 v3;

  v2 = (a1 - 1) < 2;
  v3 = a1 == 1;
  if (a2 != 3)
    v3 = 0;
  if (a2 != 4)
    v2 = v3;
  if ((a2 - 1) >= 2)
    return v2;
  else
    return (a1 - 1) < 4;
}

BOOL VCMediaWriterUtil_IsAudioOnly(int a1)
{
  return (a1 - 3) < 2;
}

uint64_t VCMediaNegotiationBlobVideoSettingsReadFrom(_WORD *a1, uint64_t a2)
{
  __int16 *v2;
  int *v4;
  int *v5;
  int *v6;
  int *v8;
  char v9;
  unsigned int v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char v14;
  BOOL v15;
  int v16;
  char v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char v23;
  __int16 *v24;
  uint64_t result;
  char v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  char v31;
  _WORD *v32;
  VCMediaNegotiationBlobVideoPayloadSettings *v33;
  _WORD *v34;
  char v35;
  unsigned int v36;
  uint64_t v37;
  unint64_t v38;
  char v39;
  char v40;
  unsigned int v41;
  uint64_t v42;
  unint64_t v43;
  char v44;
  char v45;
  unsigned int v46;
  uint64_t v47;
  unint64_t v48;
  char v49;
  char v50;
  unsigned int v51;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;
  char v55;
  char v56;
  unsigned int v57;
  uint64_t v58;
  unint64_t v59;
  char v60;
  char v61;
  unsigned int v62;
  uint64_t v63;
  unint64_t v64;
  char v65;
  char v66;
  unsigned int v67;
  uint64_t v68;
  uint64_t v69;
  unint64_t v70;
  char v71;
  char v72;
  unsigned int v73;
  uint64_t v74;
  uint64_t v75;
  unint64_t v76;
  char v77;
  char v78;
  unsigned int v79;
  uint64_t v80;
  uint64_t v81;
  unint64_t v82;
  char v83;
  uint64_t v84;
  BOOL v85;
  uint64_t v86;

  v4 = (int *)MEMORY[0x1E0D82BF0];
  v5 = (int *)MEMORY[0x1E0D82BD8];
  v6 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) >= *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
    return *(_BYTE *)(a2 + *v6) == 0;
  v8 = (int *)MEMORY[0x1E0D82BB8];
  while (2)
  {
    if (*(_BYTE *)(a2 + *v6))
      return *(_BYTE *)(a2 + *v6) == 0;
    v9 = 0;
    v10 = 0;
    v11 = 0;
    while (1)
    {
      v12 = *v4;
      v13 = *(_QWORD *)(a2 + v12);
      if (v13 == -1 || v13 >= *(_QWORD *)(a2 + *v5))
        break;
      v14 = *(_BYTE *)(*(_QWORD *)(a2 + *v8) + v13);
      *(_QWORD *)(a2 + v12) = v13 + 1;
      v11 |= (unint64_t)(v14 & 0x7F) << v9;
      if ((v14 & 0x80) == 0)
        goto LABEL_12;
      v9 += 7;
      v15 = v10++ >= 9;
      if (v15)
      {
        v11 = 0;
        v16 = *(unsigned __int8 *)(a2 + *v6);
        goto LABEL_14;
      }
    }
    *(_BYTE *)(a2 + *v6) = 1;
LABEL_12:
    v16 = *(unsigned __int8 *)(a2 + *v6);
    if (*(_BYTE *)(a2 + *v6))
      v11 = 0;
LABEL_14:
    if (v16 || (v11 & 7) == 4)
      return *(_BYTE *)(a2 + *v6) == 0;
    switch((v11 >> 3))
    {
      case 1u:
        v18 = 0;
        v19 = 0;
        v20 = 0;
        while (1)
        {
          v21 = *v4;
          v22 = *(_QWORD *)(a2 + v21);
          if (v22 == -1 || v22 >= *(_QWORD *)(a2 + *v5))
            break;
          v23 = *(_BYTE *)(*(_QWORD *)(a2 + *v8) + v22);
          *(_QWORD *)(a2 + v21) = v22 + 1;
          v20 |= (unint64_t)(v23 & 0x7F) << v18;
          if ((v23 & 0x80) == 0)
            goto LABEL_102;
          v18 += 7;
          v15 = v19++ >= 9;
          if (v15)
          {
            LODWORD(v20) = 0;
            goto LABEL_104;
          }
        }
        *(_BYTE *)(a2 + *v6) = 1;
LABEL_102:
        if (*(_BYTE *)(a2 + *v6))
          LODWORD(v20) = 0;
LABEL_104:
        v84 = 12;
        goto LABEL_133;
      case 2u:
        v26 = 0;
        v27 = 0;
        v28 = 0;
        while (2)
        {
          v29 = *v4;
          v30 = *(_QWORD *)(a2 + v29);
          if (v30 == -1 || v30 >= *(_QWORD *)(a2 + *v5))
          {
            *(_BYTE *)(a2 + *v6) = 1;
          }
          else
          {
            v31 = *(_BYTE *)(*(_QWORD *)(a2 + *v8) + v30);
            *(_QWORD *)(a2 + v29) = v30 + 1;
            v28 |= (unint64_t)(v31 & 0x7F) << v26;
            if (v31 < 0)
            {
              v26 += 7;
              v15 = v27++ >= 9;
              if (v15)
              {
                v28 = 0;
                goto LABEL_108;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v6))
          v28 = 0;
LABEL_108:
        v85 = v28 != 0;
        v86 = 40;
        goto LABEL_146;
      case 3u:
        v32 = a1;
        v33 = objc_alloc_init(VCMediaNegotiationBlobVideoPayloadSettings);
        v34 = v32;
        objc_msgSend(v32, "addVideoPayloadCollections:", v33);

        if (PBReaderPlaceMark()
          && (VCMediaNegotiationBlobVideoPayloadSettingsReadFrom((id *)&v33->super.super.isa, a2) & 1) != 0)
        {
          PBReaderRecallMark();
          v2 = &jpt_1D8C6C68C;
          v6 = (int *)MEMORY[0x1E0D82BC8];
          a1 = v34;
LABEL_147:
          if (*(_QWORD *)(a2 + *v4) >= *(_QWORD *)(a2 + *v5))
            return *(_BYTE *)(a2 + *v6) == 0;
          continue;
        }
        return 0;
      case 4u:
        v35 = 0;
        v36 = 0;
        v20 = 0;
        a1[24] |= 2u;
        while (2)
        {
          v37 = *v4;
          v38 = *(_QWORD *)(a2 + v37);
          if (v38 == -1 || v38 >= *(_QWORD *)(a2 + *v5))
          {
            *(_BYTE *)(a2 + *v6) = 1;
          }
          else
          {
            v39 = *(_BYTE *)(*(_QWORD *)(a2 + *v8) + v38);
            *(_QWORD *)(a2 + v37) = v38 + 1;
            v20 |= (unint64_t)(v39 & 0x7F) << v35;
            if (v39 < 0)
            {
              v35 += 7;
              v15 = v36++ >= 9;
              if (v15)
              {
                LODWORD(v20) = 0;
                goto LABEL_112;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v6))
          LODWORD(v20) = 0;
LABEL_112:
        v84 = 6;
        goto LABEL_133;
      case 5u:
        v40 = 0;
        v41 = 0;
        v20 = 0;
        a1[24] |= 1u;
        while (2)
        {
          v42 = *v4;
          v43 = *(_QWORD *)(a2 + v42);
          if (v43 == -1 || v43 >= *(_QWORD *)(a2 + *v5))
          {
            *(_BYTE *)(a2 + *v6) = 1;
          }
          else
          {
            v44 = *(_BYTE *)(*(_QWORD *)(a2 + *v8) + v43);
            *(_QWORD *)(a2 + v42) = v43 + 1;
            v20 |= (unint64_t)(v44 & 0x7F) << v40;
            if (v44 < 0)
            {
              v40 += 7;
              v15 = v41++ >= 9;
              if (v15)
              {
                LODWORD(v20) = 0;
                goto LABEL_116;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v6))
          LODWORD(v20) = 0;
LABEL_116:
        v84 = 4;
        goto LABEL_133;
      case 6u:
        v45 = 0;
        v46 = 0;
        v20 = 0;
        a1[24] |= 0x10u;
        while (2)
        {
          v47 = *v4;
          v48 = *(_QWORD *)(a2 + v47);
          if (v48 == -1 || v48 >= *(_QWORD *)(a2 + *v5))
          {
            *(_BYTE *)(a2 + *v6) = 1;
          }
          else
          {
            v49 = *(_BYTE *)(*(_QWORD *)(a2 + *v8) + v48);
            *(_QWORD *)(a2 + v47) = v48 + 1;
            v20 |= (unint64_t)(v49 & 0x7F) << v45;
            if (v49 < 0)
            {
              v45 += 7;
              v15 = v46++ >= 9;
              if (v15)
              {
                LODWORD(v20) = 0;
                goto LABEL_120;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v6))
          LODWORD(v20) = 0;
LABEL_120:
        v84 = 14;
        goto LABEL_133;
      case 7u:
        v50 = 0;
        v51 = 0;
        v52 = 0;
        a1[24] |= 0x80u;
        while (2)
        {
          v53 = *v4;
          v54 = *(_QWORD *)(a2 + v53);
          if (v54 == -1 || v54 >= *(_QWORD *)(a2 + *v5))
          {
            *(_BYTE *)(a2 + *v6) = 1;
          }
          else
          {
            v55 = *(_BYTE *)(*(_QWORD *)(a2 + *v8) + v54);
            *(_QWORD *)(a2 + v53) = v54 + 1;
            v52 |= (unint64_t)(v55 & 0x7F) << v50;
            if (v55 < 0)
            {
              v50 += 7;
              v15 = v51++ >= 9;
              if (v15)
              {
                v52 = 0;
                goto LABEL_124;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v6))
          v52 = 0;
LABEL_124:
        v85 = v52 != 0;
        v86 = 43;
        goto LABEL_146;
      case 8u:
        v56 = 0;
        v57 = 0;
        v20 = 0;
        a1[24] |= 8u;
        while (2)
        {
          v58 = *v4;
          v59 = *(_QWORD *)(a2 + v58);
          if (v59 == -1 || v59 >= *(_QWORD *)(a2 + *v5))
          {
            *(_BYTE *)(a2 + *v6) = 1;
          }
          else
          {
            v60 = *(_BYTE *)(*(_QWORD *)(a2 + *v8) + v59);
            *(_QWORD *)(a2 + v58) = v59 + 1;
            v20 |= (unint64_t)(v60 & 0x7F) << v56;
            if (v60 < 0)
            {
              v56 += 7;
              v15 = v57++ >= 9;
              if (v15)
              {
                LODWORD(v20) = 0;
                goto LABEL_128;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v6))
          LODWORD(v20) = 0;
LABEL_128:
        v84 = 10;
        goto LABEL_133;
      case 9u:
        v61 = 0;
        v62 = 0;
        v20 = 0;
        a1[24] |= 4u;
        while (2)
        {
          v63 = *v4;
          v64 = *(_QWORD *)(a2 + v63);
          if (v64 == -1 || v64 >= *(_QWORD *)(a2 + *v5))
          {
            *(_BYTE *)(a2 + *v6) = 1;
          }
          else
          {
            v65 = *(_BYTE *)(*(_QWORD *)(a2 + *v8) + v64);
            *(_QWORD *)(a2 + v63) = v64 + 1;
            v20 |= (unint64_t)(v65 & 0x7F) << v61;
            if (v65 < 0)
            {
              v61 += 7;
              v15 = v62++ >= 9;
              if (v15)
              {
                LODWORD(v20) = 0;
                goto LABEL_132;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v6))
          LODWORD(v20) = 0;
LABEL_132:
        v84 = 8;
LABEL_133:
        *(_DWORD *)&a1[v84] = v20;
        goto LABEL_147;
      case 0xAu:
        v66 = 0;
        v67 = 0;
        v68 = 0;
        a1[24] |= 0x40u;
        while (2)
        {
          v69 = *v4;
          v70 = *(_QWORD *)(a2 + v69);
          if (v70 == -1 || v70 >= *(_QWORD *)(a2 + *v5))
          {
            *(_BYTE *)(a2 + *v6) = 1;
          }
          else
          {
            v71 = *(_BYTE *)(*(_QWORD *)(a2 + *v8) + v70);
            *(_QWORD *)(a2 + v69) = v70 + 1;
            v68 |= (unint64_t)(v71 & 0x7F) << v66;
            if (v71 < 0)
            {
              v66 += 7;
              v15 = v67++ >= 9;
              if (v15)
              {
                v68 = 0;
                goto LABEL_137;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v6))
          v68 = 0;
LABEL_137:
        v85 = v68 != 0;
        v86 = 42;
        goto LABEL_146;
      case 0xBu:
        v72 = 0;
        v73 = 0;
        v74 = 0;
        a1[24] |= 0x100u;
        while (2)
        {
          v75 = *v4;
          v76 = *(_QWORD *)(a2 + v75);
          if (v76 == -1 || v76 >= *(_QWORD *)(a2 + *v5))
          {
            *(_BYTE *)(a2 + *v6) = 1;
          }
          else
          {
            v77 = *(_BYTE *)(*(_QWORD *)(a2 + *v8) + v76);
            *(_QWORD *)(a2 + v75) = v76 + 1;
            v74 |= (unint64_t)(v77 & 0x7F) << v72;
            if (v77 < 0)
            {
              v72 += 7;
              v15 = v73++ >= 9;
              if (v15)
              {
                v74 = 0;
                goto LABEL_141;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v6))
          v74 = 0;
LABEL_141:
        v85 = v74 != 0;
        v86 = 44;
        goto LABEL_146;
      case 0xCu:
        v78 = 0;
        v79 = 0;
        v80 = 0;
        a1[24] |= 0x20u;
        while (2)
        {
          v81 = *v4;
          v82 = *(_QWORD *)(a2 + v81);
          if (v82 == -1 || v82 >= *(_QWORD *)(a2 + *v5))
          {
            *(_BYTE *)(a2 + *v6) = 1;
          }
          else
          {
            v83 = *(_BYTE *)(*(_QWORD *)(a2 + *v8) + v82);
            *(_QWORD *)(a2 + v81) = v82 + 1;
            v80 |= (unint64_t)(v83 & 0x7F) << v78;
            if (v83 < 0)
            {
              v78 += 7;
              v15 = v79++ >= 9;
              if (v15)
              {
                v80 = 0;
                goto LABEL_145;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v6))
          v80 = 0;
LABEL_145:
        v85 = v80 != 0;
        v86 = 41;
LABEL_146:
        *((_BYTE *)a1 + v86) = v85;
        goto LABEL_147;
      default:
        v24 = v2;
        result = PBReaderSkipValueWithTag();
        v2 = v24;
        if (!(_DWORD)result)
          return result;
        goto LABEL_147;
    }
  }
}

uint64_t _VCStreamInputVideo_SampleBufferHandler(uint64_t a1, opaqueCMSampleBuffer *a2)
{
  uint64_t v4;
  CMTime v6;
  __int128 v7;
  int v8;
  CMTime v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  VCStreamInput_UpdateReportingStats(a1, a2);
  memset(&v9, 170, sizeof(v9));
  CMSampleBufferGetPresentationTimeStamp(&v9, a2);
  v7 = xmmword_1D910CBB8;
  v8 = 0;
  v4 = *(_QWORD *)(a1 + 296);
  v6 = v9;
  return VCVideoCapture_DistributeVideoFrame(v4, (uint64_t)a2, (__int128 *)&v6.value, (uint64_t)&v7);
}

uint64_t VCCaptionsEncoder_Encode(uint64_t a1, void *a2, _BYTE *a3, size_t *a4)
{
  uint64_t v4;
  size_t v9;
  char v10;
  int v11;
  char v12;
  char v13;
  char v14;
  char v15;
  void *v16;
  unint64_t v17;
  char v18;
  uint64_t v19;
  char v20;
  char RefValue;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t started;
  int v26;
  uint64_t v27;
  _BYTE *v28;
  size_t v29;
  unsigned __int8 *v30;
  uint64_t v31;
  unint64_t v32;
  const char *v33;
  const char *v34;
  size_t v35;
  uint64_t v36;
  void *v37;
  size_t *v39;
  uint64_t *v40;
  void *v41;
  id v42;
  _BYTE *v43;
  size_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  char v48;
  char v49;
  __int16 v50;
  __int16 v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  v4 = 4294967294;
  if (!a1 || !a3 || !a4)
    return v4;
  v46 = 0;
  v47 = 0;
  v9 = *a4;
  v43 = a3;
  v44 = v9;
  v42 = a2;
  v10 = *(_BYTE *)(a1 + 16);
  BYTE4(v46) = v10;
  v11 = objc_msgSend(a2, "isFinal");
  BYTE5(v46) = v11;
  if (v11)
    *(_BYTE *)(a1 + 16) = (*(_BYTE *)(a1 + 16) + 1) & 0xF;
  if (!v9)
    return 4294967293;
  v39 = a4;
  v12 = 16 * v10;
  v13 = (16 * v10) | 8;
  if (v11)
    v14 = 4;
  else
    v14 = 0;
  if (objc_msgSend(a2, "isLocal", v39))
    v15 = v13;
  else
    v15 = v12;
  *a3 = v15 | v14;
  v45 = 1;
  v16 = (void *)objc_msgSend(a2, "formattedText");
  if (!objc_msgSend(v16, "length"))
    goto LABEL_45;
  if (!objc_msgSend(v16, "length"))
  {
LABEL_36:
    BYTE6(v47) = 1;
    started = _VCCaptionsEncoder_StartNewSegmentHeader((uint64_t)&v42, 0, 0);
    if ((_DWORD)started)
    {
      v4 = started;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCCaptionsEncoder_Encode_cold_1();
      }
      return v4;
    }
    v41 = (void *)objc_msgSend(v42, "formattedText");
    v26 = v46;
    if ((_DWORD)v46)
    {
      v27 = 0;
      v28 = v43;
      v29 = v44;
      v30 = v43 + 1;
      v31 = v45;
      while (1)
      {
        v32 = *v30;
        if ((v32 & 2) != 0)
        {
          v33 = (const char *)objc_msgSend((id)objc_msgSend(v41, "substringWithRange:", v27, (v32 >> 3) + 1), "UTF8String");
          if (!v33)
            return 4294967292;
          v34 = v33;
          v35 = strlen(v33);
          v36 = v31 + v35;
          if (v29 < v31 + v35)
            return 4294967293;
          memcpy(&v28[v31], v34, v35);
          LODWORD(v32) = *v30;
          v31 = v36;
        }
        v27 += (v32 >> 3) + 1;
        ++v30;
        if (!--v26)
        {
          v45 = v31;
          break;
        }
      }
    }
LABEL_45:

    *(_QWORD *)a1 = a2;
    if ((unint64_t)objc_msgSend(*(id *)(a1 + 8), "count") >= 4)
      objc_msgSend(*(id *)(a1 + 8), "removeObjectAtIndex:", 0);
    v37 = (void *)objc_msgSend(a2, "copy");
    objc_msgSend(*(id *)(a1 + 8), "addObject:", v37);

    v4 = 0;
    *v40 = v45;
    return v4;
  }
  LODWORD(v17) = 0;
  v18 = 0;
  while (1)
  {
    v51 = -21846;
    v49 = -86;
    if ((_VCCaptionsEncoder_GetValue(a2, v17, &v51, (BOOL *)&v49) & 1) == 0)
      break;
    v50 = -21846;
    v48 = -86;
    if ((_DWORD)v17)
    {
      if (BYTE4(v47) != v49)
      {
        v19 = _VCCaptionsEncoder_StartNewSegmentHeader((uint64_t)&v42, v49 != 0, v18 == 0);
        if ((_DWORD)v19)
        {
          v4 = v19;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VCCaptionsEncoder_Encode_cold_5();
          }
          goto LABEL_55;
        }
      }
      if (v18)
      {
        if (_VCCaptionsEncoder_GetRefValue(a1, v17, &v50, &v48) && v51 == v50)
        {
          v20 = 0;
          v18 = 1;
        }
        else
        {
          v20 = 1;
          v22 = _VCCaptionsEncoder_StartNewSegmentHeader((uint64_t)&v42, v49, 1);
          if ((_DWORD)v22)
          {
            v4 = v22;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                VCCaptionsEncoder_Encode_cold_4();
            }
            goto LABEL_55;
          }
          v18 = 0;
        }
      }
      else
      {
        v18 = 0;
        v20 = 1;
      }
      v23 = v47;
      if ((_DWORD)v47 == 32)
      {
        v24 = _VCCaptionsEncoder_StartNewSegmentHeader((uint64_t)&v42, v49, v20);
        if ((_DWORD)v24)
        {
          v4 = v24;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VCCaptionsEncoder_Encode_cold_3();
          }
          goto LABEL_55;
        }
        v23 = v47;
      }
      LODWORD(v47) = v23 + 1;
    }
    else
    {
      RefValue = _VCCaptionsEncoder_GetRefValue(a1, 0, &v50, &v48);
      if (v51 == v50)
        v18 = RefValue;
      else
        v18 = 0;
      BYTE4(v47) = v49;
      LODWORD(v47) = 1;
      BYTE5(v47) = v18 ^ 1;
    }
    v17 = (v17 + 1);
    if (objc_msgSend(v16, "length") <= v17)
      goto LABEL_36;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCCaptionsEncoder_Encode_cold_6();
  }
  v4 = 4294967292;
LABEL_55:
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCCaptionsEncoder_Encode_cold_2();
  }
  return v4;
}

uint64_t _VCCaptionsEncoder_StartNewSegmentHeader(uint64_t a1, char a2, char a3)
{
  int v3;
  uint64_t v4;
  uint64_t v5;

  v3 = *(_DWORD *)(a1 + 40);
  if (!v3)
    goto LABEL_5;
  v4 = *(_QWORD *)(a1 + 24);
  if (*(_QWORD *)(a1 + 16) >= (unint64_t)(v4 + 1))
  {
    *(_BYTE *)(*(_QWORD *)(a1 + 8) + v4) = (*(_BYTE *)(a1 + 44) | (8 * v3) | (2 * *(_BYTE *)(a1 + 45)) | (4 * *(_BYTE *)(a1 + 46)))
                                         - 8;
    ++*(_QWORD *)(a1 + 24);
    ++*(_DWORD *)(a1 + 32);
LABEL_5:
    v5 = 0;
    *(_BYTE *)(a1 + 44) = a2;
    *(_DWORD *)(a1 + 40) = 0;
    *(_BYTE *)(a1 + 45) = a3;
    return v5;
  }
  return 4294967293;
}

uint64_t VCCaptionsEncoder_Create(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t result;

  if (!a1)
    return 4294967294;
  v2 = malloc_type_calloc(1uLL, 0x18uLL, 0x1080040EA45A630uLL);
  if (!v2)
    return 0xFFFFFFFFLL;
  v3 = v2;
  v4 = objc_msgSend(objc_alloc(MEMORY[0x1E0C99DE8]), "initWithCapacity:", 4);
  result = 0;
  v3[1] = v4;
  *((_BYTE *)v3 + 17) = 0;
  *a1 = v3;
  return result;
}

void VCCaptionsEncoder_Destroy(id **a1)
{
  id *v1;

  if (a1)
  {
    v1 = *a1;
    if (*a1)
    {

      *v1 = 0;
      objc_msgSend(v1[1], "removeAllObjects");

      free(v1);
    }
  }
}

uint64_t _VCCaptionsEncoder_GetValue(void *a1, unsigned int a2, _WORD *a3, BOOL *a4)
{
  uint64_t result;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t i;
  void *v13;
  unint64_t v14;
  uint64_t v15;
  BOOL v16;
  _BYTE v17[128];
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;

  result = 0;
  v22 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a3)
    {
      if (a4)
      {
        *a3 = 0;
        *a4 = 0;
        v18 = 0u;
        v19 = 0u;
        v20 = 0u;
        v21 = 0u;
        v9 = (void *)objc_msgSend(a1, "segments");
        result = objc_msgSend(v9, "countByEnumeratingWithState:objects:count:", &v18, v17, 16);
        if (result)
        {
          v10 = result;
          v11 = *(_QWORD *)v19;
          while (2)
          {
            for (i = 0; i != v10; ++i)
            {
              if (*(_QWORD *)v19 != v11)
                objc_enumerationMutation(v9);
              v13 = *(void **)(*((_QWORD *)&v18 + 1) + 8 * i);
              v14 = objc_msgSend(v13, "range");
              if (v14 + v15 > a2)
              {
                if (a2 >= v14)
                {
                  *a3 = objc_msgSend((id)objc_msgSend(v13, "text"), "characterAtIndex:", a2 - v14);
                  v16 = objc_msgSend(v13, "confidence") > 0x32;
                }
                else
                {
                  *a3 = objc_msgSend((id)objc_msgSend(a1, "formattedText"), "characterAtIndex:", a2);
                  v16 = 1;
                }
                *a4 = v16;
                return 1;
              }
            }
            v10 = objc_msgSend(v9, "countByEnumeratingWithState:objects:count:", &v18, v17, 16);
            result = 0;
            if (v10)
              continue;
            break;
          }
        }
      }
    }
  }
  return result;
}

uint64_t _VCCaptionsEncoder_GetRefValue(uint64_t a1, unsigned int a2, __int16 *a3, char *a4)
{
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  int v15;
  id obj;
  char v17;
  __int16 v18;
  _BYTE v19[128];
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  result = objc_msgSend(*(id *)(a1 + 8), "count");
  if (result)
  {
    v22 = 0u;
    v23 = 0u;
    v20 = 0u;
    v21 = 0u;
    obj = (id)objc_msgSend(*(id *)(a1 + 8), "reverseObjectEnumerator");
    v9 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v20, v19, 16);
    if (v9)
    {
      v10 = v9;
      v11 = 0;
      v12 = *(_QWORD *)v21;
      while (2)
      {
        v13 = 0;
        v15 = v11 + v10;
        do
        {
          if (*(_QWORD *)v21 != v12)
            objc_enumerationMutation(obj);
          v14 = *(void **)(*((_QWORD *)&v20 + 1) + 8 * v13);
          if ((objc_msgSend(v14, "isFinal") & 1) != 0)
            return 0;
          v18 = -21846;
          v17 = -86;
          if (!_VCCaptionsEncoder_GetValue(v14, a2, &v18, (BOOL *)&v17))
            return 0;
          if ((_BYTE)v11)
          {
            if (v18 != *a3 || v17 != *a4)
              return 0;
          }
          else
          {
            *a3 = v18;
            *a4 = v17;
          }
          LOBYTE(v11) = v11 + 1;
          if (*(unsigned __int8 *)(a1 + 17) < v11)
            return *(unsigned __int8 *)(a1 + 17) < v11;
          ++v13;
        }
        while (v10 != v13);
        v10 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v20, v19, 16);
        v11 = v15;
        if (v10)
          continue;
        break;
      }
    }
    else
    {
      LOBYTE(v11) = 0;
    }
    return *(unsigned __int8 *)(a1 + 17) < v11;
  }
  return result;
}

void *videoRulesForFormatList(uint64_t a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  os_log_t *v6;
  VCVideoRule *v7;
  double v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  uint8_t buf[4];
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v4 = (void *)objc_opt_new();
  if (v4)
  {
    v5 = 0;
    v6 = (os_log_t *)MEMORY[0x1E0CF2758];
    do
    {
      v7 = [VCVideoRule alloc];
      *(float *)&v8 = (float)*(unsigned int *)(a1 + v5 + 8);
      v9 = -[VCVideoRule initWithFrameWidth:frameHeight:frameRate:payload:](v7, "initWithFrameWidth:frameHeight:frameRate:payload:", *(unsigned int *)(a1 + v5), *(unsigned int *)(a1 + v5 + 4), a2, v8);
      if (v9)
      {
        v10 = (void *)v9;
        objc_msgSend(v4, "addObject:", v9);

      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v11 = VRTraceErrorLogLevelToCSTR();
        v12 = *v6;
        if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          v15 = v11;
          v16 = 2080;
          v17 = "videoRulesForFormatList";
          v18 = 1024;
          v19 = 68;
          _os_log_error_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_ERROR, " [%s] %s:%d Failed to create video rule for Airplay screen!", buf, 0x1Cu);
        }
      }
      v5 += 12;
    }
    while (v5 != 96);
  }
  return v4;
}

FILE **VRDump_OpenDumpFile(const char *a1, const char *a2, int a3, char a4)
{
  int AppBooleanValue;
  BOOL v9;
  FILE **v10;
  __int128 v11;
  FILE **v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  double tm_hour;
  int v28;
  long double v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  NSObject *v73;
  const char *v74;
  char v76;
  double __y;
  time_t v78;
  char __str[4];
  __int16 v80;
  _BYTE keyExistsAndHasValidFormat[48];
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  unint64_t v91;
  uint64_t v92;

  v92 = *MEMORY[0x1E0C80C00];
  keyExistsAndHasValidFormat[0] = 0;
  AppBooleanValue = CFPreferencesGetAppBooleanValue(CFSTR("enableVRDump"), CFSTR("com.apple.VideoConference"), keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat[0])
    v9 = AppBooleanValue == 0;
  else
    v9 = 1;
  if (v9)
  {
    v10 = 0;
  }
  else
  {
    v91 = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)&v11 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v89 = v11;
    v90 = v11;
    v87 = v11;
    v88 = v11;
    v86 = v11;
    v84 = v11;
    v85 = v11;
    v82 = v11;
    v83 = v11;
    *(_OWORD *)&keyExistsAndHasValidFormat[16] = v11;
    *(_OWORD *)&keyExistsAndHasValidFormat[32] = v11;
    *(_OWORD *)keyExistsAndHasValidFormat = v11;
    snprintf(keyExistsAndHasValidFormat, 0xC8uLL, "participant-%s-groupid_%s-VideoReceiver", a1, a2);
    v12 = VRLogfileAlloc(0, (uint64_t)keyExistsAndHasValidFormat, (uint64_t)"VideoReceiver", (uint64_t)".vrdump", "com.apple.VideoConference.VideoReceiverDump", 44);
    v10 = v12;
    if (v12)
    {
      v13 = (char *)malloc_type_calloc(1uLL, 0x14uLL, 0x582ABE29uLL);
      if (v13)
      {
        v20 = v13;
        VRLogfile_CreateTimeAndDateString(v13, 20);
        VRLogfilePrintSync(v10, "File Create Time = %s\n", v21, v22, v23, v24, v25, v26, (char)v20);
        free(v20);
      }
      else
      {
        VRLogfilePrintSync(v10, "File Create Time = unknown", v14, v15, v16, v17, v18, v19, v76);
      }
      v80 = 0;
      *(_DWORD *)__str = 0;
      v78 = 39600;
      tm_hour = (double)localtime(&v78)->tm_hour;
      v28 = gmtime(&v78)->tm_hour;
      __y = 0.0;
      v29 = modf(tm_hour - (double)v28, &__y);
      snprintf(__str, 6uLL, "%03.0f%02.0f\n", __y, (double)(v29 * -60.0));
      VRLogfilePrintSync(v10, "Timezone Offset = %s\n", v30, v31, v32, v33, v34, v35, (char)__str);
      VRLogfilePrintSync(v10, "File Version = %s\n", v36, v37, v38, v39, v40, v41, (char)"1.0");
      VRLogfilePrintSync(v10, "ParticipantID = %s\n", v42, v43, v44, v45, v46, v47, (char)a1);
      VRLogfilePrintSync(v10, "StreamGroupID = %s\n", v48, v49, v50, v51, v52, v53, (char)a2);
      VRLogfilePrintSync(v10, "SampleRate = %d\n", v54, v55, v56, v57, v58, v59, a3);
      VRLogfilePrintSync(v10, "Initial VPB Instance = %p\n\n", v60, v61, v62, v63, v64, v65, a4);
      VRLogfilePrintSync(v10, "%s\n", v66, v67, v68, v69, v70, v71, (char)"ColumnType,SystemTime,ArrivalTime,SeqNum,FrameTimestamp,Length,IDR,activeStream,VPBFQSize,VPBIQSize,FECProtected,FECLevel,FECRecovered,RTXRecovered,PacketLate,PacketOutOfOrder,PacketRetransmitted,Width,Height,ExpectedPackets,ReceivedPackets,MissingPackets,ParityExpected,ParityReceived,ParityMissing,TemporalLayerID,SubFrameId,AssemblyStatus,ErrorReason,PlayoutTime");
    }
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v72 = VRTraceErrorLogLevelToCSTR();
    v73 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v74 = "Enabled";
      *(_DWORD *)keyExistsAndHasValidFormat = 136316674;
      *(_QWORD *)&keyExistsAndHasValidFormat[4] = v72;
      *(_WORD *)&keyExistsAndHasValidFormat[12] = 2080;
      *(_QWORD *)&keyExistsAndHasValidFormat[14] = "VRDump_OpenDumpFile";
      if (!v10)
        v74 = "Disabled";
      *(_WORD *)&keyExistsAndHasValidFormat[22] = 1024;
      *(_DWORD *)&keyExistsAndHasValidFormat[24] = 130;
      *(_WORD *)&keyExistsAndHasValidFormat[28] = 2080;
      *(_QWORD *)&keyExistsAndHasValidFormat[30] = v74;
      *(_WORD *)&keyExistsAndHasValidFormat[38] = 2080;
      *(_QWORD *)&keyExistsAndHasValidFormat[40] = a1;
      LOWORD(v82) = 2080;
      *(_QWORD *)((char *)&v82 + 2) = a2;
      WORD5(v82) = 1024;
      HIDWORD(v82) = a3;
      _os_log_impl(&dword_1D8A54000, v73, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VRDump=%s - ParticipantID=%s, StreamGroupID=%s, sampleRate=%d", keyExistsAndHasValidFormat, 0x40u);
    }
  }
  return v10;
}

uint64_t *VRDump_CloseDumpFile(uint64_t *result)
{
  if (result)
  {
    VRLogfileFree(result);
    return (uint64_t *)VRLogfileRemoveOldFilesInDefaultLogDumpPath();
  }
  return result;
}

FILE **VRDump_AddPacket(FILE **result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    if (a2)
      return _VRDump_WriteEventLineWithTimestamp(result, (char)"AddPacket", "%.4f,%d,%.3f,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,,,,,,,,,,,,,", *(unsigned int *)(a2 + 64), a5, a6, a7, a8, *(_QWORD *)a2);
  }
  return result;
}

FILE **_VRDump_WriteEventLineWithTimestamp(FILE **a1, char a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  FILE **result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  char __b[1024];
  unint64_t v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v22 = -1431655766;
  v21 = 0xAAAAAAAAAAAAAAAALL;
  memset(__b, 170, sizeof(__b));
  VRLogfileGetTimestamp((char *)&v21, 0xCu);
  result = (FILE **)vsnprintf(__b, 0x400uLL, a3, &a9);
  if ((result & 0x80000000) == 0)
  {
    if ((int)result >= 1023)
      v19 = 1023;
    else
      v19 = (int)result;
    __b[v19] = 0;
    if (*a3)
      return VRLogfilePrintSync(a1, "%s,%s,%s\n", v13, v14, v15, v16, v17, v18, a2);
    else
      return VRLogfilePrintSync(a1, "%s,%s\n", v13, v14, v15, v16, v17, v18, a2);
  }
  return result;
}

FILE **VRDump_AssembleFrame(FILE **result, uint64_t a2)
{
  if (result)
  {
    if (a2)
      return _VRDump_WriteEventLineWithTimestamp(result, (char)"AssembleFrame", "%f,%d,%.3f,%d,%d,%d,%d,%d,,,,,,,,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%f", *(unsigned int *)(a2 + 64), *(unsigned int *)(a2 + 68), *(unsigned int *)(a2 + 72), *(unsigned int *)(a2 + 76), *(unsigned int *)(a2 + 80), *(_QWORD *)a2);
  }
  return result;
}

FILE **VRDump_SwitchMode(FILE **result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v8;

  if (result)
  {
    v8 = "GFT";
    if (a2 == 1)
      v8 = "OneToOne";
    return _VRDump_WriteEventLineWithTimestamp(result, (char)"ModeSwitch", "%s", a4, a5, a6, a7, a8, (char)v8);
  }
  return result;
}

FILE **VRDump_AddEvent(FILE **result, unsigned int a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  const char *v9;
  const char *v10;

  if (result && a3)
  {
    if (a3[1])
    {
      if (a2 > 9)
        v9 = "Unknown";
      else
        v9 = off_1E9E552E0[(char)a2];
      return _VRDump_WriteEventLineWithTimestamp(result, (char)v9, "%d,%dx%d", a4, a5, a6, a7, a8, *a3);
    }
    else
    {
      if (a2 > 9)
        v10 = "Unknown";
      else
        v10 = off_1E9E552E0[(char)a2];
      return _VRDump_WriteEventLineWithTimestamp(result, (char)v10, "", a4, a5, a6, a7, a8, a9);
    }
  }
  return result;
}

void _VCDisplayLinkRunLoopObserverCallBack(int a1, uint64_t a2, dispatch_semaphore_t dsema)
{
  if (a2 == 1)
  {
    dispatch_semaphore_signal(dsema);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCDisplayLinkRunLoopObserverCallBack_cold_1();
  }
}

uint64_t VCStreamOutput_EnqueueAttributes(uint64_t a1, unint64_t a2)
{
  uint64_t v2;
  const void *v5;

  if (a1 | a2)
  {
    VCObject_Lock(a1);
    v5 = *(const void **)(a1 + 200);
    *(_QWORD *)(a1 + 200) = a2;
    if (a2)
      CFRetain((CFTypeRef)a2);
    if (v5)
      CFRelease(v5);
    if (!*(_BYTE *)(a1 + 224)
      && *(_BYTE *)(a1 + 225)
      && VCRemoteImageQueue_EnqueueAttributes(*(_QWORD *)(a1 + 176), a2))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCStreamOutput_EnqueueAttributes_cold_2();
      }
      v2 = 0;
    }
    else
    {
      v2 = 1;
    }
    VCObject_Unlock(a1);
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCStreamOutput_EnqueueAttributes_cold_1();
    }
    return 0;
  }
  return v2;
}

uint64_t VCStreamOutput_EnqueueSampleBuffer(uint64_t a1, CMSampleBufferRef sbuf)
{
  uint64_t v2;
  const __CFDictionary *v5;
  NSObject *v6;
  CMTime *p_time;
  const __CFDictionary *v9;
  void *v10;
  NSObject *v11;
  _QWORD block[6];
  CMTime v13;
  CMTime time;
  void *v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;

  v2 = 0;
  v18 = *MEMORY[0x1E0C80C00];
  if (a1 && sbuf)
  {
    memset(&v13, 170, sizeof(v13));
    CMSampleBufferGetPresentationTimeStamp(&v13, sbuf);
    time = v13;
    CMTimeGetSeconds(&time);
    kdebug_trace();
    VCObject_Lock(a1);
    if (*(_BYTE *)(a1 + 224))
    {
      v5 = *(const __CFDictionary **)(a1 + 200);
      if (v5)
        CMSetAttachments(sbuf, v5, 1u);
      CFRetain(sbuf);
      v6 = *(NSObject **)(a1 + 216);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = __VCStreamOutput_EnqueueSampleBuffer_block_invoke;
      block[3] = &unk_1E9E52960;
      block[4] = a1;
      block[5] = sbuf;
      p_time = (CMTime *)block;
    }
    else
    {
      if (*(_BYTE *)(a1 + 225))
      {
        if (VCRemoteImageQueue_EnqueueFrame(*(_QWORD *)(a1 + 176), (unint64_t)sbuf))
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              VCStreamOutput_EnqueueSampleBuffer_cold_2();
          }
          v2 = 0;
          goto LABEL_9;
        }
LABEL_8:
        v2 = 1;
LABEL_9:
        VCObject_Unlock(a1);
        return v2;
      }
      v9 = *(const __CFDictionary **)(a1 + 200);
      if (v9)
        CMSetAttachments(sbuf, v9, 1u);
      v10 = VCStreamInputUtil_EncodeSampleBuffer(sbuf);
      if (!v10)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCStreamOutput_EnqueueSampleBuffer_cold_1();
        }
        goto LABEL_8;
      }
      v11 = *(NSObject **)(a1 + 184);
      time.value = MEMORY[0x1E0C809B0];
      *(_QWORD *)&time.timescale = 3221225472;
      time.epoch = (CMTimeEpoch)___VCStreamOutput_SendSampleBufferToXPCClient_block_invoke;
      v15 = &unk_1E9E52238;
      v16 = v10;
      v17 = a1;
      p_time = &time;
      v6 = v11;
    }
    dispatch_async(v6, p_time);
    goto LABEL_8;
  }
  return v2;
}

uint64_t ParseUnsupported(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  NSObject *v4;
  int v6;
  uint64_t v7;
  __int16 v8;
  const char *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  int v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v3 = VRTraceErrorLogLevelToCSTR();
    v4 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v6 = 136316162;
      v7 = v3;
      v8 = 2080;
      v9 = "ParseUnsupported";
      v10 = 1024;
      v11 = 162;
      v12 = 1024;
      v13 = 162;
      v14 = 2080;
      v15 = a2;
      _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SipHdr.c:%d: Unsupported header[%s]", (uint8_t *)&v6, 0x2Cu);
    }
  }
  return 0;
}

uint64_t ParseAcceptHdr(char **a1, char *a2)
{
  char *v4;
  char *v5;
  uint64_t i;
  char *v7;
  char *v8;
  int v9;
  uint64_t v11;

  v4 = (char *)malloc_type_calloc(1uLL, 0xA0uLL, 0x1000040B8406A4EuLL);
  if (v4)
  {
    v5 = v4;
    if (a2)
    {
      for (i = 0; i != 5; ++i)
      {
        v7 = strchr(a2, 44);
        v8 = v7;
        if (v7)
          *v7 = 0;
        while (1)
        {
          v9 = *a2;
          if (v9 != 32 && v9 != 9)
            break;
          ++a2;
        }
        strlcpy(&v5[32 * i], a2, 0x20uLL);
        if (!v8)
          break;
        a2 = v8 + 1;
      }
    }
    v11 = 0;
    *a1 = v5;
  }
  else
  {
    v11 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        ParseAcceptHdr_cold_1();
    }
  }
  return v11;
}

uint64_t ParseAllowHdr(_QWORD *a1, char *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  char *v6;
  char *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;

  v4 = malloc_type_calloc(1uLL, 8uLL, 0x100004000313F17uLL);
  if (v4)
  {
    v5 = v4;
    if (a2)
    {
      do
      {
        v6 = strchr(a2, 44);
        v7 = v6;
        if (v6)
          *v6 = 0;
        while (1)
        {
          v8 = *a2;
          if (v8 != 9 && v8 != 32)
            break;
          ++a2;
        }
        v9 = 1;
        while (strcmp(a2, g_apszMethods[v9]))
        {
          if (++v9 == 12)
            goto LABEL_13;
        }
        *v5 |= (1 << v9);
LABEL_13:
        a2 = v7 + 1;
      }
      while (v7);
    }
    v10 = 0;
    *a1 = v5;
  }
  else
  {
    v10 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        ParseAllowHdr_cold_1();
    }
  }
  return v10;
}

uint64_t ParseAllowEventsHdr(_QWORD *a1, char *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  char *v6;
  char *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;

  v4 = malloc_type_calloc(1uLL, 8uLL, 0x100004000313F17uLL);
  if (v4)
  {
    v5 = v4;
    if (a2)
    {
      do
      {
        v6 = strchr(a2, 44);
        v7 = v6;
        if (v6)
          *v6 = 0;
        while (1)
        {
          v8 = *a2;
          if (v8 != 9 && v8 != 32)
            break;
          ++a2;
        }
        v9 = 1;
        while (strcmp(a2, g_apszEvents[v9]))
        {
          if (++v9 == 3)
            goto LABEL_13;
        }
        *v5 |= (1 << v9);
LABEL_13:
        a2 = v7 + 1;
      }
      while (v7);
    }
    v10 = 0;
    *a1 = v5;
  }
  else
  {
    v10 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        ParseAllowEventsHdr_cold_1();
    }
  }
  return v10;
}

uint64_t ParseCallIDHdr(_QWORD *a1)
{
  void *v2;
  void *v3;
  uint64_t v4;

  v2 = malloc_type_calloc(1uLL, 0x3CuLL, 0x1000040C2DCA394uLL);
  if (v2)
  {
    v3 = v2;
    __strlcpy_chk();
    v4 = 0;
    *a1 = v3;
  }
  else
  {
    v4 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        ParseCallIDHdr_cold_1();
    }
  }
  return v4;
}

uint64_t ParseContactHdr(_QWORD *a1, char *a2)
{
  _DWORD *v4;
  _DWORD *v5;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  uint64_t v10;
  char *v11;
  char *v12;
  char *v13;
  int v14;
  const char *v16;
  char *v17;
  int v18;
  int v20;
  _DWORD *v21;
  int v22;
  uint64_t v23;
  NSObject *v24;
  uint8_t buf[4];
  uint64_t v27;
  __int16 v28;
  const char *v29;
  __int16 v30;
  int v31;
  __int16 v32;
  int v33;
  __int16 v34;
  char *v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v4 = malloc_type_calloc(1uLL, 0xA4uLL, 0x10000409BFB62CCuLL);
  if (v4)
  {
    v5 = v4;
    v6 = strchr(a2, 60);
    if (v6)
    {
      v7 = v6;
      *v6 = 0;
      v8 = strchr(a2, 34);
      if (v8)
      {
        v9 = strchr(v8 + 1, 34);
        if (v9)
          *v9 = 0;
        __strlcpy_chk();
        __strlcat_chk();
      }
      else
      {
        if (strlen(a2) >= 0x2B)
          a2[42] = 0;
        sscanf(a2, "%s", v5);
      }
      a2 = v7 + 1;
      v13 = strchr(v7 + 1, 62);
      if (!v13)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
        {
          v23 = VRTraceErrorLogLevelToCSTR();
          v24 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136316162;
            v27 = v23;
            v28 = 2080;
            v29 = "ParseContactHdr";
            v30 = 1024;
            v31 = 338;
            v32 = 1024;
            v33 = 338;
            v34 = 2080;
            v35 = a2;
            _os_log_impl(&dword_1D8A54000, v24, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SipHdr.c:%d: No '>' in SIP URI[%s]", buf, 0x2Cu);
          }
        }
        free(v5);
        return 2148335647;
      }
      *v13 = 0;
      v12 = strchr(v13 + 1, 59);
    }
    else
    {
      v11 = strchr(a2, 59);
      v12 = v11;
      if (v11)
        *v11 = 0;
    }
    while (1)
    {
      v14 = *a2;
      if (v14 != 32 && v14 != 9)
        break;
      ++a2;
    }
    ParseSipUri((uint64_t)(v5 + 11), a2);
    for (; v12; *v21 = 1)
    {
      while (1)
      {
        v16 = v12 + 1;
        v17 = strchr(v12 + 1, 59);
        v12 = v17;
        if (v17)
          *v17 = 0;
        while (1)
        {
          v18 = *(unsigned __int8 *)v16;
          if (v18 != 32 && v18 != 9)
            break;
          ++v16;
        }
        v20 = strncasecmp(v16, "isfocus", 7uLL);
        v21 = v5 + 39;
        if (!v20)
          break;
        v22 = strncasecmp(v16, "ismultiway", 0xAuLL);
        v21 = v5 + 40;
        if (!v22)
          break;
        if (!v12)
          goto LABEL_35;
      }
    }
LABEL_35:
    v10 = 0;
    *a1 = v5;
  }
  else
  {
    v10 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        ParseContactHdr_cold_1();
    }
  }
  return v10;
}

uint64_t ParseContentEncodingHdr(_QWORD *a1)
{
  void *v2;
  void *v3;
  uint64_t v4;

  v2 = malloc_type_calloc(1uLL, 0x20uLL, 0x1000040E0EAB150uLL);
  if (v2)
  {
    v3 = v2;
    __strlcpy_chk();
    v4 = 0;
    *a1 = v3;
  }
  else
  {
    v4 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        ParseContentEncodingHdr_cold_1();
    }
  }
  return v4;
}

uint64_t ParseContentLengthHdr(int **a1, const char *a2)
{
  int *v4;
  int *v5;
  int v6;
  uint64_t v7;

  v4 = (int *)malloc_type_calloc(1uLL, 4uLL, 0x100004052888210uLL);
  if (v4)
  {
    v5 = v4;
    v6 = atoi(a2);
    v7 = 0;
    *v5 = v6;
    *a1 = v5;
  }
  else
  {
    v7 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        ParseContentLengthHdr_cold_1();
    }
  }
  return v7;
}

uint64_t ParseContentTypeHdr(_QWORD *a1)
{
  void *v2;
  void *v3;
  uint64_t v4;

  v2 = malloc_type_calloc(1uLL, 0x20uLL, 0x1000040E0EAB150uLL);
  if (v2)
  {
    v3 = v2;
    __strlcpy_chk();
    v4 = 0;
    *a1 = v3;
  }
  else
  {
    v4 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        ParseContentTypeHdr_cold_1();
    }
  }
  return v4;
}

uint64_t ParseCSeqHdr(_QWORD *a1, const char *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  const char *i;
  int v7;
  uint64_t v8;
  uint64_t v9;
  char *v11[2];

  v11[1] = *(char **)MEMORY[0x1E0C80C00];
  v4 = malloc_type_calloc(1uLL, 0x10uLL, 0x1000040D9A13B51uLL);
  if (v4)
  {
    v5 = v4;
    v11[0] = (char *)0xAAAAAAAAAAAAAAAALL;
    *v4 = strtol(a2, v11, 10);
    for (i = v11[0]; ; ++i)
    {
      v7 = *(unsigned __int8 *)i;
      if (v7 != 9 && v7 != 32)
        break;
    }
    v8 = 1;
    while (strcasecmp(g_apszMethods[v8], i))
    {
      if (++v8 == 12)
        goto LABEL_14;
    }
    *((_DWORD *)v5 + 2) = v8;
LABEL_14:
    v9 = 0;
    *a1 = v5;
  }
  else
  {
    v9 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        ParseCSeqHdr_cold_1();
    }
  }
  return v9;
}

uint64_t ParseEventHdr(_QWORD *a1, char *a2)
{
  _DWORD *v4;
  _DWORD *v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  uint64_t v11;
  char *v12;
  char *v13;
  char *i;
  int v15;
  int v18;
  uint64_t v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  __int16 v26;
  char *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v4 = malloc_type_calloc(1uLL, 0x14uLL, 0x1000040A86A77D5uLL);
  if (v4)
  {
    v5 = v4;
    if (strchr(a2, 44))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v6 = VRTraceErrorLogLevelToCSTR();
        v7 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v18 = 136316162;
          v19 = v6;
          v20 = 2080;
          v21 = "ParseEventHdr";
          v22 = 1024;
          v23 = 471;
          v24 = 1024;
          v25 = 471;
          v26 = 2080;
          v27 = a2;
          _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SipHdr.c:%d: Multiple Event packages in Event header[%s]", (uint8_t *)&v18, 0x2Cu);
        }
      }
      free(v5);
      return 2148335647;
    }
    else
    {
      v9 = strchr(a2, 59);
      v10 = v9;
      if (v9)
        *v9 = 0;
      v11 = 1;
      while (strcasecmp(a2, g_apszEvents[v11]))
      {
        if (++v11 == 3)
        {
          if (!v10)
            goto LABEL_30;
          goto LABEL_18;
        }
      }
      *v5 = v11;
      if (!v10)
        goto LABEL_30;
      do
      {
LABEL_18:
        v12 = strchr(v10 + 1, 59);
        v13 = v12;
        if (v12)
          *v12 = 0;
        for (i = v10 + 4; ; ++i)
        {
          v15 = *(i - 3);
          if (v15 != 32 && v15 != 9)
            break;
        }
        if (!strncasecmp(i - 3, "id=", 3uLL))
          __strlcpy_chk();
        v10 = v13;
      }
      while (v13);
LABEL_30:
      v8 = 0;
      *a1 = v5;
    }
  }
  else
  {
    v8 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        ParseEventHdr_cold_1();
    }
  }
  return v8;
}

uint64_t ParseExpiresHdr(int **a1, const char *a2)
{
  int *v4;
  int *v5;
  int v6;
  uint64_t v7;

  v4 = (int *)malloc_type_calloc(1uLL, 4uLL, 0x100004052888210uLL);
  if (v4)
  {
    v5 = v4;
    v6 = atoi(a2);
    v7 = 0;
    *v5 = v6;
    *a1 = v5;
  }
  else
  {
    v7 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        ParseExpiresHdr_cold_1();
    }
  }
  return v7;
}

uint64_t ParseFromHdr(_QWORD *a1, char *a2)
{
  void *v4;
  void *v5;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  uint64_t v10;
  char *v11;
  char *v12;
  char *v13;
  int v14;
  char *v16;
  char *v17;
  char *i;
  int v19;
  uint64_t v21;
  NSObject *v22;
  uint8_t buf[4];
  uint64_t v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  int v31;
  __int16 v32;
  char *v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v4 = malloc_type_calloc(1uLL, 0xDCuLL, 0x1000040E6B0F26EuLL);
  if (v4)
  {
    v5 = v4;
    v6 = strchr(a2, 60);
    if (!v6)
    {
      v11 = strchr(a2, 59);
      v12 = v11;
      if (v11)
        *v11 = 0;
      goto LABEL_18;
    }
    v7 = v6;
    *v6 = 0;
    v8 = strchr(a2, 34);
    if (v8)
    {
      v9 = strchr(v8 + 1, 34);
      if (v9)
        *v9 = 0;
      __strlcpy_chk();
      __strlcat_chk();
    }
    else
    {
      if (strlen(a2) >= 0x2B)
        a2[42] = 0;
      sscanf(a2, "%s", v5);
    }
    a2 = v7 + 1;
    v13 = strchr(v7 + 1, 62);
    if (v13)
    {
      *v13 = 0;
      v12 = strchr(v13 + 1, 59);
LABEL_18:
      while (1)
      {
        v14 = *a2;
        if (v14 != 32 && v14 != 9)
          break;
        ++a2;
      }
      ParseSipUri((uint64_t)v5 + 44, a2);
      if (v12)
      {
        do
        {
          v16 = strchr(v12 + 1, 59);
          v17 = v16;
          if (v16)
            *v16 = 0;
          for (i = v12 + 5; ; ++i)
          {
            v19 = *(i - 4);
            if (v19 != 32 && v19 != 9)
              break;
          }
          if (!strncasecmp(i - 4, "tag=", 4uLL))
            __strlcpy_chk();
          v12 = v17;
        }
        while (v17);
      }
      v10 = 0;
      *a1 = v5;
      return v10;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v21 = VRTraceErrorLogLevelToCSTR();
      v22 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136316162;
        v25 = v21;
        v26 = 2080;
        v27 = "ParseFromHdr";
        v28 = 1024;
        v29 = 561;
        v30 = 1024;
        v31 = 561;
        v32 = 2080;
        v33 = a2;
        _os_log_impl(&dword_1D8A54000, v22, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SipHdr.c:%d: No '>' in SIP URI[%s]", buf, 0x2Cu);
      }
    }
    free(v5);
    return 2148335647;
  }
  else
  {
    v10 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        ParseFromHdr_cold_1();
    }
  }
  return v10;
}

uint64_t ParseMaxForwardsHdr(int **a1, const char *a2)
{
  int *v4;
  int *v5;
  int v6;
  uint64_t v7;

  v4 = (int *)malloc_type_calloc(1uLL, 4uLL, 0x100004052888210uLL);
  if (v4)
  {
    v5 = v4;
    v6 = atoi(a2);
    v7 = 0;
    *v5 = v6;
    *a1 = v5;
  }
  else
  {
    v7 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        ParseMaxForwardsHdr_cold_1();
    }
  }
  return v7;
}

uint64_t ParseMinExpiresHdr(int **a1, const char *a2)
{
  int *v4;
  int *v5;
  int v6;
  uint64_t v7;

  v4 = (int *)malloc_type_calloc(1uLL, 4uLL, 0x100004052888210uLL);
  if (v4)
  {
    v5 = v4;
    v6 = atoi(a2);
    v7 = 0;
    *v5 = v6;
    *a1 = v5;
  }
  else
  {
    v7 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        ParseMinExpiresHdr_cold_1();
    }
  }
  return v7;
}

uint64_t ParseReferToHdr(_QWORD *a1, char *a2)
{
  void *v4;
  void *v5;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  uint64_t v10;
  char *v11;
  char *v12;
  char *v13;
  int v14;
  unsigned __int8 *v16;
  char *v17;
  int v18;
  uint64_t v20;
  NSObject *v21;
  uint8_t buf[4];
  uint64_t v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  __int16 v31;
  char *v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v4 = malloc_type_calloc(1uLL, 0x7BuLL, 0x1000040D7A3BC59uLL);
  if (v4)
  {
    v5 = v4;
    v6 = strchr(a2, 60);
    if (!v6)
    {
      v11 = strchr(a2, 59);
      v12 = v11;
      if (v11)
        *v11 = 0;
      goto LABEL_18;
    }
    v7 = v6;
    *v6 = 0;
    v8 = strchr(a2, 34);
    if (v8)
    {
      v9 = strchr(v8 + 1, 34);
      if (v9)
        *v9 = 0;
      __strlcpy_chk();
      __strlcat_chk();
    }
    else
    {
      if (strlen(a2) >= 0x2B)
        a2[42] = 0;
      sscanf(a2, "%s", v5);
    }
    a2 = v7 + 1;
    v13 = strchr(v7 + 1, 62);
    if (v13)
    {
      *v13 = 0;
      v12 = strchr(v13 + 1, 59);
LABEL_18:
      while (1)
      {
        v14 = *a2;
        if (v14 != 32 && v14 != 9)
          break;
        ++a2;
      }
      __strlcpy_chk();
      if (v12)
      {
        do
        {
          v16 = (unsigned __int8 *)(v12 + 1);
          v17 = strchr(v12 + 1, 59);
          v12 = v17;
          if (v17)
            *v17 = 0;
          while (1)
          {
            v18 = *v16;
            if (v18 != 32 && v18 != 9)
              break;
            ++v16;
          }
        }
        while (v17);
      }
      v10 = 0;
      *a1 = v5;
      return v10;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v20 = VRTraceErrorLogLevelToCSTR();
      v21 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136316162;
        v24 = v20;
        v25 = 2080;
        v26 = "ParseReferToHdr";
        v27 = 1024;
        v28 = 713;
        v29 = 1024;
        v30 = 713;
        v31 = 2080;
        v32 = a2;
        _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SipHdr.c:%d: No '>' in SIP URI[%s]", buf, 0x2Cu);
      }
    }
    free(v5);
    return 2148335647;
  }
  else
  {
    v10 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        ParseReferToHdr_cold_1();
    }
  }
  return v10;
}

uint64_t ParseSubscriptionStateHdr(_QWORD *a1, char *a2)
{
  _DWORD *v4;
  _DWORD *v5;
  char *v6;
  char *v7;
  uint64_t i;
  uint64_t v9;
  char *v10;
  char *v11;
  const char *j;
  int v13;
  uint64_t v15;

  v4 = malloc_type_calloc(1uLL, 0x10uLL, 0x1000040451B5BE8uLL);
  if (!v4)
  {
    v9 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        ParseSubscriptionStateHdr_cold_1();
    }
    return v9;
  }
  v5 = v4;
  v6 = strchr(a2, 59);
  v7 = v6;
  if (v6)
    *v6 = 0;
  for (i = 1; i != 4; ++i)
  {
    if (!strcasecmp(a2, g_apszSubStates[i]))
    {
      *v5 = i;
      if (!v7)
        goto LABEL_35;
      while (1)
      {
        while (1)
        {
LABEL_13:
          v10 = v7;
          v11 = strchr(v7 + 1, 59);
          v7 = v11;
          if (v11)
            *v11 = 0;
          for (j = v10 + 8; ; ++j)
          {
            v13 = *((unsigned __int8 *)j - 7);
            if (v13 != 32 && v13 != 9)
              break;
          }
          if (strncasecmp(j - 7, "reason=", 7uLL))
            break;
          v15 = 0;
          while (strcasecmp(j, g_apszReasons[v15]))
          {
            if (++v15 == 7)
              goto LABEL_32;
          }
          v5[1] = v15;
          if (!v7)
            goto LABEL_35;
        }
        if (!strncasecmp(j - 7, "expires=", 8uLL))
          break;
        if (!strncasecmp(j - 7, "retry-after=", 0xCuLL))
        {
          v5[3] = atoi(j + 5);
          if (!v7)
            goto LABEL_35;
        }
        else
        {
LABEL_32:
          if (!v7)
            goto LABEL_35;
        }
      }
      v5[2] = atoi(j + 1);
      goto LABEL_32;
    }
  }
  if (v7)
    goto LABEL_13;
LABEL_35:
  v9 = 0;
  *a1 = v5;
  return v9;
}

uint64_t ParseToHdr(_QWORD *a1, char *a2)
{
  void *v4;
  void *v5;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  uint64_t v10;
  char *v11;
  char *v12;
  char *v13;
  int v14;
  char *v16;
  char *v17;
  char *i;
  int v19;
  uint64_t v21;
  NSObject *v22;
  uint8_t buf[4];
  uint64_t v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  int v31;
  __int16 v32;
  char *v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v4 = malloc_type_calloc(1uLL, 0xDCuLL, 0x1000040E6B0F26EuLL);
  if (v4)
  {
    v5 = v4;
    v6 = strchr(a2, 60);
    if (!v6)
    {
      v11 = strchr(a2, 59);
      v12 = v11;
      if (v11)
        *v11 = 0;
      goto LABEL_18;
    }
    v7 = v6;
    *v6 = 0;
    v8 = strchr(a2, 34);
    if (v8)
    {
      v9 = strchr(v8 + 1, 34);
      if (v9)
        *v9 = 0;
      __strlcpy_chk();
      __strlcat_chk();
    }
    else
    {
      if (strlen(a2) >= 0x2B)
        a2[42] = 0;
      sscanf(a2, "%s", v5);
    }
    a2 = v7 + 1;
    v13 = strchr(v7 + 1, 62);
    if (v13)
    {
      *v13 = 0;
      v12 = strchr(v13 + 1, 59);
LABEL_18:
      while (1)
      {
        v14 = *a2;
        if (v14 != 32 && v14 != 9)
          break;
        ++a2;
      }
      ParseSipUri((uint64_t)v5 + 44, a2);
      if (v12)
      {
        do
        {
          v16 = strchr(v12 + 1, 59);
          v17 = v16;
          if (v16)
            *v16 = 0;
          for (i = v12 + 5; ; ++i)
          {
            v19 = *(i - 4);
            if (v19 != 32 && v19 != 9)
              break;
          }
          if (!strncasecmp(i - 4, "tag=", 4uLL))
            __strlcpy_chk();
          v12 = v17;
        }
        while (v17);
      }
      v10 = 0;
      *a1 = v5;
      return v10;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v21 = VRTraceErrorLogLevelToCSTR();
      v22 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136316162;
        v25 = v21;
        v26 = 2080;
        v27 = "ParseToHdr";
        v28 = 1024;
        v29 = 843;
        v30 = 1024;
        v31 = 843;
        v32 = 2080;
        v33 = a2;
        _os_log_impl(&dword_1D8A54000, v22, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SipHdr.c:%d: No '>' in SIP URI[%s]", buf, 0x2Cu);
      }
    }
    free(v5);
    return 2148335647;
  }
  else
  {
    v10 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        ParseToHdr_cold_1();
    }
  }
  return v10;
}

uint64_t ParseUserAgentHdr(_QWORD *a1)
{
  void *v2;
  void *v3;
  uint64_t v4;

  v2 = malloc_type_calloc(1uLL, 0x2BuLL, 0x100004056BB1370uLL);
  if (v2)
  {
    v3 = v2;
    __strlcpy_chk();
    v4 = 0;
    *a1 = v3;
  }
  else
  {
    v4 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        ParseUserAgentHdr_cold_1();
    }
  }
  return v4;
}

uint64_t ParseViaHdr(_QWORD *a1, char *k)
{
  _DWORD *v4;
  _DWORD *v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  unsigned __int8 *v9;
  unsigned int v10;
  char *i;
  unsigned int v13;
  BOOL v14;
  uint64_t v15;
  char *j;
  int v18;
  char *v20;
  int v21;
  char *v23;
  char *v24;
  char *v25;
  char *v26;
  __int16 v27;
  _DWORD *v28;
  _DWORD *v29;
  char *v30;
  char *v31;
  char *v32;
  char *m;
  int v34;
  uint64_t v36;
  NSObject *v37;
  _QWORD *v38;
  uint64_t v39;
  uint64_t v40;
  NSObject *v41;
  const char *v42;
  uint64_t v43;
  _QWORD *v45;
  uint8_t buf[4];
  uint64_t v47;
  __int16 v48;
  const char *v49;
  __int16 v50;
  int v51;
  __int16 v52;
  int v53;
  __int16 v54;
  char *v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v4 = malloc_type_calloc(1uLL, 0x310uLL, 0x1000040F65B4EE0uLL);
  if (v4)
  {
    v5 = v4;
    v45 = a1;
    v6 = 0;
    v7 = (char *)(v4 + 1);
    while (!strncmp(k, "SIP/2.0", 7uLL) && k[7] == 47)
    {
      v8 = 0;
      v9 = (unsigned __int8 *)(k + 8);
      while (1)
      {
        v10 = v9[v8];
        if (v10 <= 0x20 && ((1 << v10) & 0x100000201) != 0)
        {
          i = (char *)&v9[v8];
          goto LABEL_20;
        }
        v7[v8] = v10;
        if (v8 == 2)
          break;
        ++v8;
      }
      for (i = k + 10; ; ++i)
      {
        v13 = *i;
        v14 = v13 > 0x20;
        v15 = (1 << v13) & 0x100000201;
        if (!v14 && v15 != 0)
          break;
      }
      LODWORD(v8) = 3;
LABEL_20:
      *((_BYTE *)&v5[39 * v6 + 1] + (int)v8) = 0;
      for (j = i; ; ++j)
      {
        v18 = *j;
        if (v18 != 32 && v18 != 9)
          break;
        ++i;
      }
      v20 = strchr(j, 44);
      k = v20;
      if (v20)
      {
        *v20 = 0;
        for (k = v20 + 1; ; ++k)
        {
          v21 = *k;
          if (v21 != 32 && v21 != 9)
            break;
        }
        v18 = *j;
      }
      if (v18 == 91)
      {
        v23 = strchr(j + 1, 93);
        if (!v23)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
          {
            v43 = VRTraceErrorLogLevelToCSTR();
            v41 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136316162;
              v47 = v43;
              v48 = 2080;
              v49 = "ParseViaHdr";
              v50 = 1024;
              v51 = 954;
              v52 = 1024;
              v53 = 954;
              v54 = 2080;
              v55 = i;
              v42 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/S"
                    "ipHdr.c:%d: No ']' after '[' for an IPv6 address[%s]";
              goto LABEL_73;
            }
          }
          goto LABEL_80;
        }
        *v23 = 0;
        j = v23 + 1;
        v5[39 * v6 + 2] = 1;
        __strlcpy_chk();
      }
      v24 = strchr(j, 59);
      v25 = v24;
      if (v24)
        *v24 = 0;
      v26 = strchr(j, 58);
      if (v26)
      {
        *v26 = 0;
        v27 = atoi(v26 + 1);
      }
      else
      {
        v27 = 5060;
      }
      v28 = &v5[39 * v6];
      *((_WORD *)v28 + 26) = v27;
      if (!v28[2])
        __strlcpy_chk();
      v29 = v5;
      if (v25)
      {
        v30 = (char *)&v5[39 * v6 + 29] + 2;
        do
        {
          while (1)
          {
            v31 = v25;
            v32 = strchr(v25 + 1, 59);
            v25 = v32;
            if (v32)
              *v32 = 0;
            for (m = v31 + 8; ; ++m)
            {
              v34 = *(m - 7);
              if (v34 != 32 && v34 != 9)
                break;
            }
            if (strncasecmp(m - 7, "branch=", 7uLL))
              break;
            __strlcpy_chk();
            if (!v25)
              goto LABEL_62;
          }
          if (!strncasecmp(m - 7, "received=", 9uLL))
            strlcpy(v30, m + 2, 0x28uLL);
        }
        while (v25);
      }
LABEL_62:
      ++v6;
      if (!k)
      {
        v5 = v29;
LABEL_75:
        v38 = v45;
LABEL_76:
        v39 = 0;
        *v5 = v6;
        *v38 = v5;
        return v39;
      }
      v7 += 156;
      v5 = v29;
      if (v6 == 5)
      {
        LODWORD(v6) = 5;
        if ((int)VRTraceGetErrorLogLevelForModule() < 5)
          goto LABEL_75;
        v36 = VRTraceErrorLogLevelToCSTR();
        v37 = *MEMORY[0x1E0CF2758];
        v38 = v45;
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316162;
          v47 = v36;
          v48 = 2080;
          v49 = "ParseViaHdr";
          v50 = 1024;
          v51 = 1006;
          v52 = 1024;
          v53 = 1006;
          v54 = 1024;
          LODWORD(v55) = 5;
          _os_log_impl(&dword_1D8A54000, v37, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SipHdr.c:%d: More Via than the maximum %d", buf, 0x28u);
        }
        goto LABEL_76;
      }
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v40 = VRTraceErrorLogLevelToCSTR();
      v41 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136316162;
        v47 = v40;
        v48 = 2080;
        v49 = "ParseViaHdr";
        v50 = 1024;
        v51 = 915;
        v52 = 1024;
        v53 = 915;
        v54 = 2080;
        v55 = k;
        v42 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SipHdr."
              "c:%d: Invalid protocol version[%s] in Via";
LABEL_73:
        _os_log_impl(&dword_1D8A54000, v41, OS_LOG_TYPE_DEFAULT, v42, buf, 0x2Cu);
      }
    }
LABEL_80:
    free(v5);
    return 2148335647;
  }
  else
  {
    v39 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        ParseViaHdr_cold_1();
    }
  }
  return v39;
}

uint64_t ParseSKESeqHdr(_QWORD *a1, const char *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  char *v6;
  uint64_t v7;
  char *__s[2];

  __s[1] = *(char **)MEMORY[0x1E0C80C00];
  v4 = malloc_type_calloc(1uLL, 0x10uLL, 0x1000040D9A13B51uLL);
  if (v4)
  {
    v5 = v4;
    __s[0] = (char *)0xAAAAAAAAAAAAAAAALL;
    *v4 = strtol(a2, __s, 10);
    v6 = strchr(__s[0], 59);
    if (v6)
      LODWORD(v6) = atoi(v6 + 1);
    v7 = 0;
    *((_DWORD *)v5 + 2) = (_DWORD)v6;
    *a1 = v5;
  }
  else
  {
    v7 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        ParseSKESeqHdr_cold_1();
    }
  }
  return v7;
}

uint64_t ParseXCallIDHdr(int **a1, const char *a2)
{
  int *v4;
  int *v5;
  int v6;
  uint64_t v7;

  v4 = (int *)malloc_type_calloc(1uLL, 4uLL, 0x100004052888210uLL);
  if (v4)
  {
    v5 = v4;
    v6 = atoi(a2);
    v7 = 0;
    *v5 = v6;
    *a1 = v5;
  }
  else
  {
    v7 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        ParseXCallIDHdr_cold_1();
    }
  }
  return v7;
}

uint64_t ParseReasonHdr(_QWORD *a1, char *a2)
{
  _DWORD *v4;
  _DWORD *v5;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  char *i;
  int v11;
  uint64_t v13;

  v4 = malloc_type_calloc(1uLL, 0x84uLL, 0x10000403AA91CE4uLL);
  if (v4)
  {
    v5 = v4;
    v6 = strchr(a2, 59);
    if (v6)
    {
      v7 = v6;
      *v6 = 0;
      *v5 = 1;
      __strlcpy_chk();
      do
      {
        while (1)
        {
          v8 = v7;
          v9 = strchr(v7 + 1, 59);
          v7 = v9;
          if (v9)
            *v9 = 0;
          for (i = v8 + 6; ; ++i)
          {
            v11 = *(i - 5);
            if (v11 != 32 && v11 != 9)
              break;
          }
          if (strncasecmp(i - 5, "cause=", 6uLL))
            break;
          v5[12] = atoi(i + 1);
          if (!v7)
            goto LABEL_24;
        }
        if (!strncasecmp(i - 5, "text=", 5uLL))
          __strlcpy_chk();
      }
      while (v7);
    }
    else
    {
      *v5 = 1;
      __strlcpy_chk();
    }
LABEL_24:
    v13 = 0;
    *a1 = v5;
  }
  else
  {
    v13 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        ParseReasonHdr_cold_1();
    }
  }
  return v13;
}

uint64_t ParseHeader(_QWORD *a1, unsigned int *a2, char *__s, int a4)
{
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  int v12;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  const char *v19;
  NSObject *v20;
  uint32_t v21;
  uint64_t v22;
  NSObject *v23;
  uint64_t v24;
  const char **v25;
  unsigned int v27;
  unsigned __int8 *i;
  int v30;
  int v32;
  uint64_t v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  int v37;
  __int16 v38;
  int v39;
  __int16 v40;
  _DWORD v41[7];

  *(_QWORD *)&v41[5] = *MEMORY[0x1E0C80C00];
  *a1 = 0;
  v8 = strchr(__s, 58);
  if (!v8)
  {
    v16 = 2148335647;
    if ((int)VRTraceGetErrorLogLevelForModule() < 5)
      return v16;
    v17 = VRTraceErrorLogLevelToCSTR();
    v18 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      return v16;
    v32 = 136316418;
    v33 = v17;
    v34 = 2080;
    v35 = "ParseHeader";
    v36 = 1024;
    v37 = 1070;
    v38 = 1024;
    v39 = 1070;
    v40 = 1024;
    v41[0] = 58;
    LOWORD(v41[1]) = 2080;
    *(_QWORD *)((char *)&v41[1] + 2) = __s;
    v19 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SipHdr.c:%d"
          ": No '%c' in the header[%s]";
    v20 = v18;
    v21 = 50;
LABEL_22:
    _os_log_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_DEFAULT, v19, (uint8_t *)&v32, v21);
    return v16;
  }
  v9 = v8;
  v10 = v8 - 1;
  v11 = v8;
  if (v8 - 1 >= __s)
  {
    do
    {
      v12 = *v10;
      if (v12 != 32 && v12 != 9)
        break;
      --v10;
    }
    while (v10 >= __s);
    v11 = v10 + 1;
  }
  *v11 = 0;
  v14 = strlen(__s);
  if (!v14)
  {
    v16 = 2148335647;
    if ((int)VRTraceGetErrorLogLevelForModule() < 5)
      return v16;
    v22 = VRTraceErrorLogLevelToCSTR();
    v23 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      return v16;
    v32 = 136316162;
    v33 = v22;
    v34 = 2080;
    v35 = "ParseHeader";
    v36 = 1024;
    v37 = 1084;
    v38 = 1024;
    v39 = 1084;
    v40 = 2080;
    *(_QWORD *)v41 = __s;
    v19 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SipHdr.c:%d"
          ": No header field name[%s]";
    v20 = v23;
    v21 = 44;
    goto LABEL_22;
  }
  if (v14 != 1)
  {
    v24 = -51;
    v25 = (const char **)&off_1E9E51468;
    while (strcasecmp(__s, *v25))
    {
      v25 += 3;
      if (__CFADD__(v24++, 1))
      {
LABEL_27:
        v27 = 0;
        if (a2)
          goto LABEL_32;
        goto LABEL_33;
      }
    }
    v27 = v24 + 52;
    if (!a2)
      goto LABEL_33;
    goto LABEL_32;
  }
  v15 = 0;
  while (__tolower(*__s) != g_aCompactHeaders[v15])
  {
    v15 += 8;
    if (v15 == 104)
      goto LABEL_27;
  }
  v27 = *(_DWORD *)&g_aCompactHeaders[v15 + 4];
  if (a2)
LABEL_32:
    *a2 = v27;
LABEL_33:
  if (v27 != a4 && a4 && v27)
    return 2148335648;
  for (i = (unsigned __int8 *)(v9 + 1); ; ++i)
  {
    v30 = *i;
    if (v30 != 32 && v30 != 9)
      break;
  }
  return ((uint64_t (*)(_QWORD *))(&g_aHeaders)[3 * v27 + 1])(a1);
}

uint64_t ConstructAcceptHdr(char *a1, const char *a2, size_t a3)
{
  __int128 v6;
  uint64_t v7;
  const char *v8;
  char __str[16];
  __int128 v11;
  __int16 v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (!a2)
    return 2148335617;
  v12 = -21846;
  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)__str = v6;
  v11 = v6;
  sprintf(a1, "%s: %s", "Accept", a2);
  v7 = 0;
  v8 = a2 + 32;
  do
  {
    if (!v8[v7])
      break;
    snprintf(__str, 0x22uLL, ", %s", &v8[v7]);
    strlcat(a1, __str, a3);
    v7 += 32;
  }
  while (v7 != 128);
  strlcat(a1, "\r\n", a3);
  return 0;
}

uint64_t ConstructAllowHdr(char *a1, _QWORD *a2, size_t a3)
{
  uint64_t v6;
  int v7;

  if (!a2)
    return 2148335617;
  sprintf(a1, "%s: ", "Allow");
  v6 = 1;
  v7 = 1;
  do
  {
    if ((*a2 & (1 << v6)) != 0)
    {
      if (!v7)
        strlcat(a1, ", ", a3);
      strlcat(a1, g_apszMethods[v6], a3);
      v7 = 0;
    }
    ++v6;
  }
  while (v6 != 12);
  strlcat(a1, "\r\n", a3);
  return 0;
}

uint64_t ConstructAllowEventsHdr(char *a1, _QWORD *a2, size_t a3)
{
  uint64_t v6;
  int v7;

  if (!a2)
    return 2148335617;
  sprintf(a1, "%c: ", 117);
  v6 = 1;
  v7 = 1;
  do
  {
    if ((*a2 & (1 << v6)) != 0)
    {
      if (!v7)
        strlcat(a1, ", ", a3);
      strlcat(a1, g_apszEvents[v6], a3);
      v7 = 0;
    }
    ++v6;
  }
  while (v6 != 3);
  strlcat(a1, "\r\n", a3);
  return 0;
}

uint64_t ConstructCallIDHdr(char *a1, const char *a2)
{
  if (!a2)
    return 2148335617;
  sprintf(a1, "%c: %s\r\n", 105, a2);
  return 0;
}

uint64_t ConstructContactHdr(char *a1, char *__s)
{
  __int128 v4;
  char v6[16];
  __int128 v7;
  __int128 v8;
  __int128 v9;
  char v10[16];
  __int128 v11;
  __int128 v12;
  __int128 v13;
  _OWORD v14[5];
  char __str[43];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (!__s)
    return 2148335617;
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v14[3] = v4;
  v14[4] = v4;
  v14[1] = v4;
  v14[2] = v4;
  v13 = v4;
  v14[0] = v4;
  *(_OWORD *)v10 = v4;
  v11 = v4;
  v12 = v4;
  *(_OWORD *)v6 = v4;
  v7 = v4;
  v8 = v4;
  v9 = v4;
  if ((int)strlen(__s) >= 1)
    snprintf(__str, 0x2BuLL, "%s ", __s);
  __s[49] = 0;
  ConstructUri((char *)v14, __s + 44);
  if (*((_DWORD *)__s + 39))
    snprintf(v10, 0x40uLL, ";%s", "isfocus");
  else
    v10[0] = 0;
  if (*((_DWORD *)__s + 40))
    snprintf(v6, 0x40uLL, ";%s", "ismultiway");
  else
    v6[0] = 0;
  sprintf(a1, "%c: %s%s%s\r\n", 109, (const char *)v14, v10, v6);
  return 0;
}

uint64_t ConstructContentEncodingHdr(char *a1, const char *a2)
{
  if (!a2)
    return 2148335617;
  sprintf(a1, "%c: %s\r\n", 101, a2);
  return 0;
}

uint64_t ConstructContentLengthHdr(char *a1, _DWORD *a2)
{
  if (!a2)
    return 2148335617;
  if (*a2 == -1)
    sprintf(a1, "%c: %s\r\n");
  else
    sprintf(a1, "%c: %d\r\n");
  return 0;
}

uint64_t ConstructContentTypeHdr(char *a1, const char *a2)
{
  if (!a2)
    return 2148335617;
  sprintf(a1, "%c: %s\r\n", 99, a2);
  return 0;
}

uint64_t ConstructCSeqHdr(char *a1, uint64_t a2)
{
  if (!a2)
    return 2148335617;
  sprintf(a1, "%s: %lu %s\r\n", "CSeq", *(_QWORD *)a2, g_apszMethods[*(unsigned int *)(a2 + 8)]);
  return 0;
}

uint64_t ConstructEventHdr(char *a1, uint64_t a2)
{
  if (!a2)
    return 2148335617;
  if (*(_BYTE *)(a2 + 4))
    sprintf(a1, "%c: %s;%s\r\n");
  else
    sprintf(a1, "%c: %s\r\n");
  return 0;
}

uint64_t ConstructExpiresHdr(char *a1, _DWORD *a2)
{
  if (!a2)
    return 2148335617;
  sprintf(a1, "%s: %d\r\n", "Expires", *a2);
  return 0;
}

uint64_t ConstructFromHdr(char *a1, char *__s)
{
  __int128 v4;
  const char *v6;
  int v7;
  char v8[16];
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  _OWORD v13[5];
  char __str[16];
  _BYTE v15[27];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (!__s)
    return 2148335617;
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v15[11] = v4;
  *(_OWORD *)__str = v4;
  *(_OWORD *)v15 = v4;
  v13[0] = v4;
  v13[1] = v4;
  v13[2] = v4;
  v13[3] = v4;
  v13[4] = v4;
  *(_OWORD *)v8 = v4;
  v9 = v4;
  v10 = v4;
  v11 = v4;
  v12 = v4;
  if ((int)strlen(__s) < 1)
    __str[0] = 0;
  else
    snprintf(__str, 0x2BuLL, "%s ", __s);
  __s[49] = 0;
  ConstructUri((char *)v13, __s + 44);
  v7 = __s[156];
  v6 = __s + 156;
  if (v7)
    snprintf(v8, 0x50uLL, ";%s%s", "tag=", v6);
  else
    v8[0] = 0;
  sprintf(a1, "%c: %s<%s>%s\r\n", 102, __str, (const char *)v13, v8);
  return 0;
}

uint64_t ConstructMaxForwardsHdr(char *a1, _DWORD *a2)
{
  if (!a2)
    return 2148335617;
  sprintf(a1, "%s: %d\r\n", "Max-Forwards", *a2);
  return 0;
}

uint64_t ConstructReasonHdr(char *a1, uint64_t a2)
{
  if (!a2)
    return 2148335617;
  if (*(_DWORD *)a2)
    sprintf(a1, "%s: %s; cause=%d\r\n", "Reason", (const char *)(a2 + 4), *(_DWORD *)(a2 + 48));
  return 0;
}

uint64_t ConstructMinExpiresHdr(char *a1, _DWORD *a2)
{
  if (!a2)
    return 2148335617;
  sprintf(a1, "%s: %d\r\n", "Min-Expires", *a2);
  return 0;
}

uint64_t ConstructReferToHdr(char *a1, char *__s)
{
  __int128 v4;
  char __str[16];
  _BYTE v7[27];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (!__s)
    return 2148335617;
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v7[11] = v4;
  *(_OWORD *)__str = v4;
  *(_OWORD *)v7 = v4;
  if ((int)strlen(__s) < 1)
    __str[0] = 0;
  else
    snprintf(__str, 0x2BuLL, "%s ", __s);
  sprintf(a1, "%s: %s<%s>\r\n", "Refer-To", __str, __s + 43);
  return 0;
}

uint64_t ConstructSubscriptionStateHdr(char *a1, _DWORD *a2)
{
  uint64_t result;
  int v5;
  uint64_t v6;
  int v7;
  char v8;
  unint64_t v9;
  char v10[15];
  char v11;
  unint64_t v12;
  char v13[11];
  char __str;
  unint64_t v15;
  _BYTE v16[11];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  result = 2148335617;
  memset(v16, 170, sizeof(v16));
  v15 = 0xAAAAAAAAAAAAAAAALL;
  memset(v13, 170, sizeof(v13));
  v12 = 0xAAAAAAAAAAAAAAAALL;
  memset(v10, 170, sizeof(v10));
  v9 = 0xAAAAAAAAAAAAAAAALL;
  if (a2)
  {
    v8 = 0;
    v11 = 0;
    __str = 0;
    if ((*a2 - 1) >= 2)
    {
      if (*a2 != 3)
        return result;
      v6 = a2[1];
      if ((_DWORD)v6)
      {
        snprintf(&v11, 0x14uLL, ";%s%s", "reason=", g_apszReasons[v6]);
        v7 = a2[1];
        if (v7 == 5 || v7 == 2)
          snprintf(&v8, 0x18uLL, ";%s%d", "retry-after=", a2[3]);
      }
      sprintf(a1, "%s: %s%s%s\r\n");
    }
    else
    {
      v5 = a2[2];
      if (v5)
        snprintf(&__str, 0x14uLL, ";%s%d", "expires=", v5);
      sprintf(a1, "%s: %s%s\r\n");
    }
    return 0;
  }
  return result;
}

uint64_t ConstructToHdr(char *a1, char *__s)
{
  __int128 v4;
  const char *v5;
  int v6;
  char v8[16];
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  _OWORD v13[5];
  char __str[43];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (!__s)
    return 2148335617;
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v13[3] = v4;
  v13[4] = v4;
  v13[1] = v4;
  v13[2] = v4;
  v12 = v4;
  v13[0] = v4;
  *(_OWORD *)v8 = v4;
  v9 = v4;
  v10 = v4;
  v11 = v4;
  if ((int)strlen(__s) >= 1)
    snprintf(__str, 0x2BuLL, "%s ", __s);
  __s[49] = 0;
  ConstructUri((char *)v13, __s + 44);
  v6 = __s[156];
  v5 = __s + 156;
  if (v6)
    snprintf(v8, 0x50uLL, ";%s%s", "tag=", v5);
  else
    v8[0] = 0;
  sprintf(a1, "%c: %s%s\r\n", 116, (const char *)v13, v8);
  return 0;
}

uint64_t ConstructUserAgentHdr(char *a1, const char *a2)
{
  if (!a2)
    return 2148335617;
  sprintf(a1, "%s: %s\r\n", "User-Agent", a2);
  return 0;
}

uint64_t ConstructViaHdr(char *a1, int *a2, size_t a3)
{
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  int *v9;
  const char *v10;
  int v11;
  char __str[8];
  char v14[16];
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  _OWORD __source[16];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  memset(__str, 170, 7);
  if (!a2)
    return 2148335617;
  *a1 = 0;
  if (*a2 >= 1)
  {
    v6 = 0;
    v7 = 0;
    *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __source[14] = v8;
    __source[15] = v8;
    __source[12] = v8;
    __source[13] = v8;
    __source[10] = v8;
    __source[11] = v8;
    __source[8] = v8;
    __source[9] = v8;
    __source[6] = v8;
    __source[7] = v8;
    __source[4] = v8;
    __source[5] = v8;
    __source[2] = v8;
    __source[3] = v8;
    __source[0] = v8;
    __source[1] = v8;
    v19 = v8;
    v20 = v8;
    v21 = v8;
    v22 = v8;
    v23 = v8;
    v24 = v8;
    v25 = v8;
    v26 = v8;
    v27 = v8;
    v28 = v8;
    v17 = v8;
    v18 = v8;
    v15 = v8;
    v16 = v8;
    *(_OWORD *)v14 = v8;
    do
    {
      if (LOWORD(a2[v6 + 13]) == 5060)
        __str[0] = 0;
      else
        snprintf(__str, 7uLL, ":%d", LOWORD(a2[v6 + 13]));
      LOBYTE(v19) = 0;
      v9 = &a2[v6];
      if (BYTE2(a2[v6 + 13]))
      {
        snprintf(v14, 0x50uLL, ";%s%s", "branch=", (const char *)&a2[v6 + 13] + 2);
        __strlcat_chk();
      }
      v11 = *((unsigned __int8 *)v9 + 118);
      v10 = (char *)v9 + 118;
      if (v11)
      {
        snprintf(v14, 0x50uLL, ";%s%s", "received=", v10);
        __strlcat_chk();
      }
      if (a2[v6 + 2])
        snprintf((char *)__source, 0x100uLL, "%c: %s/%s [%s]%s%s\r\n", 118);
      else
        snprintf((char *)__source, 0x100uLL, "%c: %s/%s %s%s%s\r\n", 118);
      strlcat(a1, (const char *)__source, a3);
      ++v7;
      v6 += 39;
    }
    while (v7 < *a2);
  }
  return 0;
}

uint64_t ConstructSKESeqHdr(char *a1, uint64_t a2)
{
  if (!a2)
    return 2148335617;
  sprintf(a1, "%s: %lu;%d\r\n", "SKESeq", *(_QWORD *)a2, *(_DWORD *)(a2 + 8));
  return 0;
}

uint64_t CreateAcceptHdr(_QWORD *a1, int a2)
{
  void *v4;
  void *v5;
  uint64_t v6;

  v4 = malloc_type_calloc(1uLL, 0xA0uLL, 0x1000040B8406A4EuLL);
  if (v4)
  {
    v5 = v4;
    __strlcpy_chk();
    __strlcpy_chk();
    if (a2)
      __strlcpy_chk();
    v6 = 0;
    *a1 = v5;
  }
  else
  {
    v6 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateAcceptHdr_cold_1();
    }
  }
  return v6;
}

uint64_t CreateAllowHdr(_QWORD *a1, int a2)
{
  _QWORD *v4;
  int i;
  BOOL v6;
  int v7;
  uint64_t v8;

  v4 = malloc_type_calloc(1uLL, 8uLL, 0x100004000313F17uLL);
  if (v4)
  {
    for (i = 1; i != 12; ++i)
    {
      if (a2)
        v6 = 0;
      else
        v6 = i == 9;
      v7 = !v6;
      if (i != 6 && v7)
        *v4 |= (1 << i);
    }
    v8 = 0;
    *a1 = v4;
  }
  else
  {
    v8 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateAllowHdr_cold_1();
    }
  }
  return v8;
}

uint64_t CreateAllowEventsHdr(_QWORD *a1, int a2)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;

  v4 = malloc_type_calloc(1uLL, 8uLL, 0x100004000313F17uLL);
  if (v4)
  {
    v5 = 0;
    v6 = 0xFFFFFFFFLL;
    if (!a2)
      v6 = 4294967293;
    *v4 = v6;
    *a1 = v4;
  }
  else
  {
    v5 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateAllowEventsHdr_cold_1();
    }
  }
  return v5;
}

uint64_t CreateCallIDHdr(_QWORD *a1)
{
  void *v2;
  void *v3;
  uint64_t v4;

  v2 = malloc_type_calloc(1uLL, 0x3CuLL, 0x1000040C2DCA394uLL);
  if (v2)
  {
    v3 = v2;
    __strlcpy_chk();
    v4 = 0;
    *a1 = v3;
  }
  else
  {
    v4 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateCallIDHdr_cold_1();
    }
  }
  return v4;
}

uint64_t CreateContactHdr(_QWORD *a1, uint64_t a2, __int128 *a3, int a4, int a5)
{
  char *v10;
  char *v11;
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;

  v10 = (char *)malloc_type_calloc(1uLL, 0xA4uLL, 0x10000409BFB62CCuLL);
  if (v10)
  {
    v11 = v10;
    if (a2)
      __strlcpy_chk();
    v12 = 0;
    v13 = *a3;
    v14 = a3[1];
    *(_OWORD *)(v11 + 76) = a3[2];
    *(_OWORD *)(v11 + 60) = v14;
    *(_OWORD *)(v11 + 44) = v13;
    v15 = a3[3];
    v16 = a3[4];
    v17 = a3[5];
    *(_OWORD *)(v11 + 140) = a3[6];
    *(_OWORD *)(v11 + 124) = v17;
    *(_OWORD *)(v11 + 108) = v16;
    *(_OWORD *)(v11 + 92) = v15;
    *((_DWORD *)v11 + 39) = a4;
    *((_DWORD *)v11 + 40) = a5;
    *a1 = v11;
  }
  else
  {
    v12 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateContactHdr_cold_1();
    }
  }
  return v12;
}

uint64_t CreateContentEncodingHdr(_QWORD *a1)
{
  void *v2;
  void *v3;
  uint64_t v4;

  v2 = malloc_type_calloc(1uLL, 0x20uLL, 0x1000040E0EAB150uLL);
  if (v2)
  {
    v3 = v2;
    __strlcpy_chk();
    v4 = 0;
    *a1 = v3;
  }
  else
  {
    v4 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateContentEncodingHdr_cold_1();
    }
  }
  return v4;
}

uint64_t CreateContentLengthHdr(_QWORD *a1, int a2)
{
  _DWORD *v4;
  uint64_t v5;

  v4 = malloc_type_calloc(1uLL, 4uLL, 0x100004052888210uLL);
  if (v4)
  {
    v5 = 0;
    *v4 = a2;
    *a1 = v4;
  }
  else
  {
    v5 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateContentLengthHdr_cold_1();
    }
  }
  return v5;
}

uint64_t CreateContentTypeHdr(_QWORD *a1)
{
  void *v2;
  void *v3;
  uint64_t v4;

  v2 = malloc_type_calloc(1uLL, 0x20uLL, 0x1000040E0EAB150uLL);
  if (v2)
  {
    v3 = v2;
    __strlcpy_chk();
    v4 = 0;
    *a1 = v3;
  }
  else
  {
    v4 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateContentTypeHdr_cold_1();
    }
  }
  return v4;
}

uint64_t CreateCSeqHdr(_QWORD *a1, uint64_t a2, int a3)
{
  _DWORD *v6;
  uint64_t v7;

  v6 = malloc_type_calloc(1uLL, 0x10uLL, 0x1000040D9A13B51uLL);
  if (v6)
  {
    v7 = 0;
    *(_QWORD *)v6 = a2;
    v6[2] = a3;
    *a1 = v6;
  }
  else
  {
    v7 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateCSeqHdr_cold_1();
    }
  }
  return v7;
}

uint64_t CreateExpiresHdr(_QWORD *a1, int a2)
{
  _DWORD *v4;
  uint64_t v5;

  v4 = malloc_type_calloc(1uLL, 4uLL, 0x100004052888210uLL);
  if (v4)
  {
    v5 = 0;
    *v4 = a2;
    *a1 = v4;
  }
  else
  {
    v5 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateExpiresHdr_cold_1();
    }
  }
  return v5;
}

uint64_t CreateFromHdr(_QWORD *a1, uint64_t a2, __int128 *a3)
{
  char *v6;
  char *v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;

  v6 = (char *)malloc_type_calloc(1uLL, 0xDCuLL, 0x1000040E6B0F26EuLL);
  if (v6)
  {
    v7 = v6;
    if (a2)
      __strlcpy_chk();
    v8 = *a3;
    v9 = a3[1];
    *(_OWORD *)(v7 + 76) = a3[2];
    *(_OWORD *)(v7 + 60) = v9;
    *(_OWORD *)(v7 + 44) = v8;
    v10 = a3[3];
    v11 = a3[4];
    v12 = a3[5];
    *(_OWORD *)(v7 + 140) = a3[6];
    *(_OWORD *)(v7 + 124) = v12;
    *(_OWORD *)(v7 + 108) = v11;
    *(_OWORD *)(v7 + 92) = v10;
    __strlcpy_chk();
    v13 = 0;
    *a1 = v7;
  }
  else
  {
    v13 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateFromHdr_cold_1();
    }
  }
  return v13;
}

uint64_t CreateMaxForwardsHdr(_QWORD *a1, int a2)
{
  _DWORD *v4;
  uint64_t v5;

  v4 = malloc_type_calloc(1uLL, 4uLL, 0x100004052888210uLL);
  if (v4)
  {
    v5 = 0;
    *v4 = a2;
    *a1 = v4;
  }
  else
  {
    v5 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateMaxForwardsHdr_cold_1();
    }
  }
  return v5;
}

uint64_t CreateMinExpiresHdr(_QWORD *a1, int a2)
{
  _DWORD *v4;
  uint64_t v5;

  v4 = malloc_type_calloc(1uLL, 4uLL, 0x100004052888210uLL);
  if (v4)
  {
    v5 = 0;
    *v4 = a2;
    *a1 = v4;
  }
  else
  {
    v5 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateMinExpiresHdr_cold_1();
    }
  }
  return v5;
}

uint64_t CreateToHdr(_QWORD *a1, uint64_t a2, __int128 *a3)
{
  char *v6;
  char *v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;

  v6 = (char *)malloc_type_calloc(1uLL, 0xDCuLL, 0x1000040E6B0F26EuLL);
  if (v6)
  {
    v7 = v6;
    if (a2)
      __strlcpy_chk();
    v8 = *a3;
    v9 = a3[1];
    *(_OWORD *)(v7 + 76) = a3[2];
    *(_OWORD *)(v7 + 60) = v9;
    *(_OWORD *)(v7 + 44) = v8;
    v10 = a3[3];
    v11 = a3[4];
    v12 = a3[5];
    *(_OWORD *)(v7 + 140) = a3[6];
    *(_OWORD *)(v7 + 124) = v12;
    *(_OWORD *)(v7 + 108) = v11;
    *(_OWORD *)(v7 + 92) = v10;
    __strlcpy_chk();
    v13 = 0;
    *a1 = v7;
  }
  else
  {
    v13 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateToHdr_cold_1();
    }
  }
  return v13;
}

uint64_t CreateUserAgentHdr(_QWORD *a1)
{
  void *v2;
  void *v3;
  uint64_t v4;

  v2 = malloc_type_calloc(1uLL, 0x2BuLL, 0x100004056BB1370uLL);
  if (v2)
  {
    v3 = v2;
    __strlcpy_chk();
    v4 = 0;
    *a1 = v3;
  }
  else
  {
    v4 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateUserAgentHdr_cold_1();
    }
  }
  return v4;
}

uint64_t CreateViaHdr(_QWORD *a1, uint64_t a2, int a3, uint64_t a4, __int16 a5, uint64_t a6, uint64_t a7)
{
  _DWORD *v11;
  _DWORD *v12;
  uint64_t v13;

  v11 = malloc_type_calloc(1uLL, 0x310uLL, 0x1000040F65B4EE0uLL);
  if (v11)
  {
    v12 = v11;
    *v11 = 1;
    __strlcpy_chk();
    v12[2] = a3;
    __strlcpy_chk();
    *((_WORD *)v12 + 26) = a5;
    __strlcpy_chk();
    if (a7)
      __strlcpy_chk();
    v13 = 0;
    *a1 = v12;
  }
  else
  {
    v13 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateViaHdr_cold_1();
    }
  }
  return v13;
}

uint64_t CreateSKESeqHdr(_QWORD *a1, uint64_t a2, int a3)
{
  _DWORD *v6;
  uint64_t v7;

  v6 = malloc_type_calloc(1uLL, 0x10uLL, 0x1000040D9A13B51uLL);
  if (v6)
  {
    v7 = 0;
    *(_QWORD *)v6 = a2;
    v6[2] = a3;
    *a1 = v6;
  }
  else
  {
    v7 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateSKESeqHdr_cold_1();
    }
  }
  return v7;
}

uint64_t CreateReasonHdr(_QWORD *a1, uint64_t a2, int a3, uint64_t a4)
{
  _DWORD *v8;
  _DWORD *v9;
  uint64_t v10;

  v8 = malloc_type_calloc(1uLL, 0x84uLL, 0x10000403AA91CE4uLL);
  if (v8)
  {
    v9 = v8;
    if (a2)
      __strlcpy_chk();
    if (a4)
      __strlcpy_chk();
    v10 = 0;
    v9[12] = a3;
    *v9 = 1;
    *a1 = v9;
  }
  else
  {
    v10 = 2148335619;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateReasonHdr_cold_1();
    }
  }
  return v10;
}

uint64_t CopySipHeader(_QWORD *a1, const void *a2, unsigned int a3)
{
  uint64_t result;
  size_t v6;
  void *v7;
  void *v8;

  result = 2148335617;
  if (a1 && a2 && ((0x196FDFA8C559DuLL >> a3) & 1) == 0)
  {
    v6 = SLODWORD((&g_aHeaders)[3 * a3 + 2]);
    v7 = malloc_type_malloc(v6, 0x730DBFBCuLL);
    if (v7)
    {
      v8 = v7;
      memcpy(v7, a2, v6);
      result = 0;
      *a1 = v8;
    }
    else
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          CopySipHeader_cold_1();
      }
      return 2148335619;
    }
  }
  return result;
}

uint64_t DirectCopy(uint64_t a1, _DWORD *a2, uint64_t a3, int a4)
{
  *a2 = a4;
  return 0;
}

uint64_t _SipMsg_CompressWithZLib()
{
  return CompressionUtils_CompressWithZLib();
}

uint64_t _SipMsg_DecompressWithZLib()
{
  return CompressionUtils_DecompressWithZlib();
}

uint64_t _SipMsg_CompressWithGZip()
{
  return CompressionUtils_CompressWithGZip();
}

uint64_t _SipMsg_DecompressWithGZip()
{
  return CompressionUtils_DecompressWithGZip();
}

uint64_t ReplaceKeyword(const char *a1, uint64_t a2, char *__s, const char *a4, uint64_t a5)
{
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  int64_t v13;
  int64_t v14;
  uint64_t v15;
  char *v16;
  size_t v17;
  char *v18;
  int v19;
  signed int v20;
  uint64_t v21;
  NSObject *v22;
  const char *v24;
  int64_t v25;
  char *v26;
  char *v27;
  uint64_t v28;
  NSObject *v29;
  const char *v30;
  NSObject *v31;
  uint32_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  const char *v36;
  uint8_t buf[4];
  uint64_t v38;
  __int16 v39;
  const char *v40;
  __int16 v41;
  int v42;
  __int16 v43;
  int v44;
  __int16 v45;
  char *v46;
  __int16 v47;
  const char *v48;
  uint64_t v49;

  v36 = a4;
  v49 = *MEMORY[0x1E0C80C00];
  v9 = strlen(__s);
  v10 = a2 - 1;
  if ((int)a2 >= 1)
  {
    v11 = v9;
    v12 = 0;
    v13 = 0;
    v14 = (int)a2;
    v15 = v9;
    v16 = (char *)a1;
    while (*v16)
    {
      v16 = strnstr(v16, __s, (int)a2 - v13);
      if (!v16)
        break;
      v16 += v15;
      v13 = v16 - a1;
      v12 = (v12 - 1);
      if (v16 - a1 >= (int)a2)
        goto LABEL_8;
    }
    if (!(_DWORD)v12)
      return v12;
LABEL_8:
    v12 = -(int)v12;
    v35 = &v33;
    v33 = a2;
    MEMORY[0x1E0C80A78](v16);
    v18 = (char *)&v33 - ((v17 + 15) & 0x1FFFFFFF0);
    memset(v18, 170, v17);
    v19 = strnlen(v36, a5 - 1);
    if (v19 <= v11)
      v20 = 0;
    else
      v20 = v19 - v11;
    if ((int)(0x7FFFFFFF / v12) > v20 && v10 - v20 * (int)v12 >= (int)strnlen(a1, v10))
    {
      if (!*a1)
        return v12;
      v34 = v19;
      v24 = a1;
      v25 = v14 + v19;
      while (v14 > v24 - a1)
      {
        v26 = strnstr(v24, __s, v14 - (v24 - a1));
        if (v26)
        {
          v27 = v26;
          strlcpy(v18, &v26[v15], v14);
          strlcpy(v27, v36, v14 - (v27 - a1));
          v24 = &v27[v34];
          strlcpy(&v27[v34], v18, v25 - (v27 - a1));
          if (*v24)
            continue;
        }
        return v12;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() < 3)
        return 0;
      v28 = VRTraceErrorLogLevelToCSTR();
      v29 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        return 0;
      *(_DWORD *)buf = 136316162;
      v38 = v28;
      v39 = 2080;
      v40 = "ReplaceKeyword";
      v41 = 1024;
      v42 = 261;
      v43 = 1024;
      v44 = v33;
      v45 = 2048;
      v46 = (char *)(v24 - a1);
      v30 = "SIP [%s] %s:%d Error Replacing Keyword - MaxSize:(%d) < (p - pszStr):(%ld)";
      v31 = v29;
      v32 = 44;
    }
    else
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 3)
        return 0;
      v21 = VRTraceErrorLogLevelToCSTR();
      v22 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        return 0;
      *(_DWORD *)buf = 136316418;
      v38 = v21;
      v39 = 2080;
      v40 = "ReplaceKeyword";
      v41 = 1024;
      v42 = 255;
      v43 = 1024;
      v44 = v33;
      v45 = 2080;
      v46 = __s;
      v47 = 2080;
      v48 = v36;
      v30 = "SIP [%s] %s:%d Destination buffer size '%d' is too small to handle replacement '%s'->'%s'";
      v31 = v22;
      v32 = 54;
    }
    _os_log_error_impl(&dword_1D8A54000, v31, OS_LOG_TYPE_ERROR, v30, buf, v32);
    return 0;
  }
  return 0;
}

uint64_t CreateInvite(unint64_t *a1, int a2, int a3, uint64_t a4, __int128 *a5, __int128 *a6, __int128 *a7, __int128 *a8, unsigned __int16 a9, unsigned __int16 a10, const char *a11, const char *a12, char *__s, int a14, int a15, int a16)
{
  __int128 v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;
  NSObject *v39;
  uint64_t v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  uint64_t v46;
  int v47;
  unint64_t v48;
  __int16 v49;
  __int16 v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unsigned int v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  size_t v63;
  char *v64;
  char *v65;
  size_t v66;
  uint64_t v68;
  NSObject *v69;
  unint64_t *v70;
  unint64_t v71;
  unint64_t v72;
  _BYTE buf[22];
  __int16 v74;
  int v75;
  __int16 v76;
  uint64_t v77;
  __int16 v78;
  int v79;
  __int16 v80;
  int v81;
  __int128 v82;
  __int128 v83;
  _BYTE v84[22];
  __int128 v85[3];
  _OWORD v86[3];
  __int128 v87;
  _BYTE v88[64];
  __int128 v89;
  __int128 v90;
  __int128 v91;
  _BYTE v92[64];
  __int128 v93;
  __int128 v94;
  __int128 v95;
  char v96[16];
  _OWORD v97[2];
  char __str[16];
  _OWORD v99[2];
  _OWORD v100[4];
  char v101[16];
  __int128 v102;
  __int128 v103;
  __int128 v104;
  char v105[16];
  __int128 v106;
  _OWORD v107[2];
  uint64_t v108;

  v108 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v22 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v22 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)((char *)v107 + 12) = v22;
  v106 = v22;
  v107[0] = v22;
  v104 = v22;
  *(_OWORD *)v105 = v22;
  v102 = v22;
  v103 = v22;
  *(_OWORD *)v101 = v22;
  v100[2] = v22;
  v100[3] = v22;
  v100[0] = v22;
  v100[1] = v22;
  *(_OWORD *)((char *)v99 + 11) = v22;
  *(_OWORD *)__str = v22;
  v99[0] = v22;
  *(_OWORD *)((char *)v97 + 11) = v22;
  *(_OWORD *)v96 = v22;
  v97[0] = v22;
  v94 = v22;
  v95 = v22;
  *(_OWORD *)&v92[48] = v22;
  v93 = v22;
  *(_OWORD *)&v92[16] = v22;
  *(_OWORD *)&v92[32] = v22;
  v91 = v22;
  *(_OWORD *)v92 = v22;
  v89 = v22;
  v90 = v22;
  *(_OWORD *)&v88[32] = v22;
  *(_OWORD *)&v88[48] = v22;
  *(_OWORD *)v88 = v22;
  *(_OWORD *)&v88[16] = v22;
  v86[2] = v22;
  v87 = v22;
  v86[0] = v22;
  v86[1] = v22;
  v85[1] = v22;
  v85[2] = v22;
  v85[0] = v22;
  v71 = 0xAAAAAAAAAAAAAAAALL;
  v72 = 0xAAAAAAAAAAAAAAAALL;
  v23 = CreateGenericSIPMsg(&v72, a2, a9, a10, a16 != 0);
  if ((v23 & 0x80000000) != 0)
    return v23;
  v70 = a1;
  v24 = v72;
  v25 = v72 + 696;
  v26 = *(_QWORD *)(a4 + 32);
  v27 = *(_OWORD *)(a4 + 16);
  *(_OWORD *)(v72 + 696) = *(_OWORD *)a4;
  *(_OWORD *)(v25 + 16) = v27;
  *(_QWORD *)(v24 + 728) = v26;
  v29 = *a5;
  v28 = a5[1];
  *(_QWORD *)(v24 + 768) = *((_QWORD *)a5 + 4);
  *(_OWORD *)(v24 + 736) = v29;
  *(_OWORD *)(v24 + 752) = v28;
  v31 = *a6;
  v30 = a6[1];
  *(_QWORD *)(v24 + 808) = *((_QWORD *)a6 + 4);
  *(_OWORD *)(v24 + 776) = v31;
  *(_OWORD *)(v24 + 792) = v30;
  v33 = *a7;
  v32 = a7[1];
  *(_QWORD *)(v24 + 848) = *((_QWORD *)a7 + 4);
  *(_OWORD *)(v24 + 816) = v33;
  *(_OWORD *)(v24 + 832) = v32;
  v35 = *a8;
  v34 = a8[1];
  *(_QWORD *)(v24 + 888) = *((_QWORD *)a8 + 4);
  *(_OWORD *)(v24 + 856) = v35;
  *(_OWORD *)(v24 + 872) = v34;
  if (IsIPPORTValid())
  {
    v36 = *a8;
    v37 = a8[1];
    *(_QWORD *)(v24 + 848) = *((_QWORD *)a8 + 4);
    *(_OWORD *)(v24 + 816) = v36;
    *(_OWORD *)(v24 + 832) = v37;
    *(_QWORD *)&v84[14] = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)&v36 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v36 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v83 = v36;
    *(_OWORD *)v84 = v36;
    v82 = v36;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v38 = VRTraceErrorLogLevelToCSTR();
      v39 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v40 = IPPORTToStringWithSize();
        *(_DWORD *)buf = 136316418;
        *(_QWORD *)&buf[4] = v38;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "CreateInvite";
        v74 = 1024;
        v75 = 304;
        v76 = 2080;
        v77 = v40;
        v78 = 1024;
        v79 = a9;
        v80 = 1024;
        v81 = a10;
        _os_log_impl(&dword_1D8A54000, v39, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Relay external addr [%s] type %u channel %x", buf, 0x32u);
      }
    }
  }
  v92[4] = 0;
  strcpy(v92, "sip");
  *(_OWORD *)&v92[5] = *(_OWORD *)"user";
  memset(&v92[21], 0, 35);
  *(_DWORD *)&v92[56] = *(_DWORD *)a4 & 1;
  IPToString();
  WORD2(v95) = *(_WORD *)(a4 + 36);
  strncpy((char *)&v95 + 6, DEFAULT_TRANSPORT, 4uLL);
  HIDWORD(v95) = 0;
  strcpy(v88, "sip");
  v88[4] = 0;
  *(_OWORD *)&v88[5] = *(_OWORD *)"user";
  memset(&v88[21], 0, 35);
  *(_DWORD *)&v88[56] = *(_DWORD *)a5 & 1;
  IPToString();
  WORD2(v91) = *((_WORD *)a5 + 18);
  strncpy((char *)&v91 + 6, DEFAULT_TRANSPORT, 4uLL);
  HIDWORD(v91) = 0;
  LODWORD(v85[0]) = 7367027;
  BYTE4(v85[0]) = 0;
  __strlcpy_chk();
  DWORD2(v86[0]) = *(_DWORD *)a6 & 1;
  IPToString();
  WORD2(v87) = *((_WORD *)a6 + 18);
  strncpy((char *)&v87 + 6, DEFAULT_TRANSPORT, 4uLL);
  HIDWORD(v87) = 0;
  *(_QWORD *)(v24 + 4) = 0x100000001;
  v41 = *(_OWORD *)v88;
  v42 = *(_OWORD *)&v88[16];
  *(_OWORD *)(v24 + 44) = *(_OWORD *)&v88[32];
  *(_OWORD *)(v24 + 28) = v42;
  *(_OWORD *)(v24 + 12) = v41;
  v43 = *(_OWORD *)&v88[48];
  v44 = v89;
  v45 = v90;
  *(_OWORD *)(v24 + 108) = v91;
  *(_OWORD *)(v24 + 92) = v45;
  *(_OWORD *)(v24 + 76) = v44;
  *(_OWORD *)(v24 + 60) = v43;
  *(_QWORD *)v84 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v43 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v43 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v82 = v43;
  v83 = v43;
  MakeAddressID();
  v47 = *(unsigned __int16 *)(a4 + 36);
  memset(buf, 170, 16);
  gettimeofday((timeval *)buf, 0);
  v48 = 10000000 * *(_QWORD *)buf + 10 * *(int *)&buf[8] + 122192928000000000;
  if (GenerateUUID_oldi)
  {
    v49 = GenerateUUID_wClockSeq;
    if (GenerateUUID_oldi < v48)
      goto LABEL_13;
    v49 = GenerateUUID_wClockSeq + 1;
  }
  else
  {
    v49 = vcvtd_n_s64_f64((double)hwrandom() * 4.65661287e-10, 0x10uLL);
  }
  GenerateUUID_wClockSeq = v49;
LABEL_13:
  GenerateUUID_oldi = v48;
  v50 = v49 | 0x8000;
  v51 = hwrandom();
  __sprintf_chk(v105, 0, 0x3CuLL, "%08x-%04x-%04x-%04x-%08x%04x", v48, WORD2(v48), HIWORD(v48) & 0xFFF | 0x1000, v50 & 0xBFFF, v51 | 0x80000000, v47);
  __strlcat_chk();
  __strlcat_chk();
  v52 = CreateCallIDHdr(&v71);
  if ((v52 & 0x80000000) != 0)
  {
    v46 = v52;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateInvite_cold_1();
    }
    goto LABEL_70;
  }
  *(_QWORD *)(v24 + 208) = v71;
  v53 = CreateContactHdr(&v71, 0, v85, a14, a15);
  if ((v53 & 0x80000000) != 0)
  {
    v46 = v53;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateInvite_cold_2();
    }
    goto LABEL_70;
  }
  *(_QWORD *)(v24 + 224) = v71;
  v54 = CreateContentLengthHdr(&v71, -1);
  if ((v54 & 0x80000000) != 0)
  {
    v46 = v54;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateInvite_cold_3();
    }
    goto LABEL_70;
  }
  *(_QWORD *)(v24 + 256) = v71;
  v55 = CreateContentTypeHdr(&v71);
  if ((v55 & 0x80000000) != 0)
  {
    v46 = v55;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateInvite_cold_4();
    }
    goto LABEL_70;
  }
  *(_QWORD *)(v24 + 264) = v71;
  v56 = CreateCSeqHdr(&v71, 1, 1);
  if ((v56 & 0x80000000) != 0)
  {
    v46 = v56;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateInvite_cold_5();
    }
    goto LABEL_70;
  }
  *(_QWORD *)(v24 + 272) = v71;
  if (a11)
  {
    if (*a11 && *a11 != 34)
      snprintf(__str, 0x2BuLL, "\"%s\"", a11);
    else
      __strlcpy_chk();
  }
  else
  {
    *(_OWORD *)__str = *(_OWORD *)"Anonymous";
    memset(v99, 0, 27);
  }
  v57 = hwrandom();
  __sprintf_chk(v101, 0, 0x40uLL, "%lu", v57);
  v58 = CreateFromHdr(&v71, (uint64_t)__str, (__int128 *)v92);
  if ((v58 & 0x80000000) != 0)
  {
    v46 = v58;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateInvite_cold_6();
    }
    goto LABEL_70;
  }
  *(_QWORD *)(v24 + 312) = v71;
  v59 = CreateMaxForwardsHdr(&v71, 70);
  if ((v59 & 0x80000000) != 0)
  {
    v46 = v59;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateInvite_cold_7();
    }
    goto LABEL_70;
  }
  *(_QWORD *)(v24 + 328) = v71;
  if (a12)
  {
    if (*a12 && *a12 != 34)
      snprintf(v96, 0x2BuLL, "\"%s\"", a12);
    else
      __strlcpy_chk();
  }
  else
  {
    *(_OWORD *)v96 = *(_OWORD *)"Anonymous";
    memset(v97, 0, 27);
  }
  v60 = CreateToHdr(&v71, (uint64_t)v96, (__int128 *)v88);
  if ((v60 & 0x80000000) != 0)
  {
    v46 = v60;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateInvite_cold_8();
    }
    goto LABEL_70;
  }
  *(_QWORD *)(v24 + 480) = v71;
  GenerateBranch((char *)v100);
  v61 = CreateViaHdr(&v71, (uint64_t)DEFAULT_TRANSPORT, SDWORD2(v86[0]), (uint64_t)v86 + 12, SWORD2(v87), (uint64_t)v100, 0);
  if ((v61 & 0x80000000) != 0)
  {
    v46 = v61;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateInvite_cold_9();
    }
    goto LABEL_70;
  }
  *(_QWORD *)(v24 + 504) = v71;
  v62 = CreateUserAgentHdr(&v71);
  if ((v62 & 0x80000000) != 0)
  {
    v46 = v62;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateInvite_cold_10();
    }
LABEL_70:
    FreeSipMsg((_QWORD *)v24);
    return v46;
  }
  *(_QWORD *)(v24 + 496) = v71;
  if (!__s)
    goto LABEL_60;
  v63 = strlen(__s);
  if (!v63)
    goto LABEL_60;
  v64 = (char *)malloc_type_malloc(v63 + 1, 0x5D3EA60AuLL);
  *(_QWORD *)(v24 + 552) = v64;
  if (v64)
  {
    v65 = v64;
    v66 = strlen(__s);
    strncpy(v65, __s, v66 + 1);
LABEL_60:
    v46 = 0;
    *v70 = v24;
    return v46;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v68 = VRTraceErrorLogLevelToCSTR();
    v69 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      CreateInvite_cold_11(v68, __s, v69);
  }
  FreeSipMsg((_QWORD *)v24);
  return 2148401155;
}

uint64_t CreateGenericSIPMsg(_QWORD *a1, int a2, __int16 a3, __int16 a4, int a5)
{
  _DWORD *v10;
  uint64_t v11;

  v10 = malloc_type_calloc(1uLL, 0x400uLL, 0x10B2040CFE7BBC5uLL);
  if (v10)
  {
    v11 = 0;
    v10[143] = a2;
    *((_WORD *)v10 + 284) = a3;
    *((_WORD *)v10 + 285) = a4;
    v10[252] = a5;
    *((_QWORD *)v10 + 127) = SIPCompressCallback;
    *a1 = v10;
  }
  else
  {
    v11 = 2148401155;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateGenericSIPMsg_cold_1();
    }
  }
  return v11;
}

uint64_t SIPCompressCallback(unsigned int a1, uint64_t a2, int *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  const char *v9;
  NSObject *v10;
  uint32_t v11;
  int v12;
  uint64_t v13;
  NSObject *v14;
  char *v17;
  uint64_t ContentEncodingHdr;
  float v19;
  uint64_t v20;
  NSObject *v21;
  int v22;
  _BYTE v24[12];
  __int16 v25;
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(a6 + 240))
  {
    v6 = 2148401196;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v7 = VRTraceErrorLogLevelToCSTR();
      v8 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v24 = 136315650;
        *(_QWORD *)&v24[4] = v7;
        v25 = 2080;
        v26 = "SIPCompressCallback";
        v27 = 1024;
        v28 = 162;
        v9 = "SIP [%s] %s:%d SIPCompressCallback: already compressed.";
        v10 = v8;
        v11 = 28;
LABEL_5:
        _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, v9, v24, v11);
      }
    }
  }
  else
  {
    v6 = 2148401196;
    if (a1 - 3 < 0xFFFFFFFE)
      return 2148401184;
    v12 = a5;
    if ((int)a5 > 100)
    {
      v17 = (char *)&g_aCompressions + 32 * a1;
      ContentEncodingHdr = (*((uint64_t (**)(uint64_t, int *, uint64_t, uint64_t))v17 + 2))(a2, a3, a4, a5);
      if ((ContentEncodingHdr & 0x80000000) == 0)
      {
        v19 = (double)strlen(v17 + 4) + 5.0;
        if ((float)((float)((float)*a3 + v19) / (float)v12) >= 1.0)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v20 = VRTraceErrorLogLevelToCSTR();
            v21 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              v22 = *a3;
              *(_DWORD *)v24 = 136316162;
              *(_QWORD *)&v24[4] = v20;
              v25 = 2080;
              v26 = "SIPCompressCallback";
              v27 = 1024;
              v28 = 182;
              v29 = 1024;
              v30 = v12;
              v31 = 1024;
              v32 = v22;
              v9 = "SIP [%s] %s:%d SIPCompressCallback: Not worth compressing %d --> %d";
              v10 = v21;
              v11 = 40;
              goto LABEL_5;
            }
          }
          return v6;
        }
        *(_QWORD *)v24 = 0xAAAAAAAAAAAAAAAALL;
        ContentEncodingHdr = CreateContentEncodingHdr(v24);
        if ((ContentEncodingHdr & 0x80000000) == 0)
        {
          v6 = 0;
          *(_QWORD *)(a6 + 240) = *(_QWORD *)v24;
          return v6;
        }
      }
      return ContentEncodingHdr;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v13 = VRTraceErrorLogLevelToCSTR();
      v14 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v24 = 136315906;
        *(_QWORD *)&v24[4] = v13;
        v25 = 2080;
        v26 = "SIPCompressCallback";
        v27 = 1024;
        v28 = 171;
        v29 = 1024;
        v30 = v12;
        v9 = "SIP [%s] %s:%d SIPCompressCallback: too small to compress %d";
        v10 = v14;
        v11 = 34;
        goto LABEL_5;
      }
    }
  }
  return v6;
}

void FreeSipMsg(_QWORD *a1)
{
  uint64_t i;
  void *v3;
  void *v4;
  void *v5;

  if (a1)
  {
    for (i = 17; i != 69; ++i)
    {
      v3 = (void *)a1[i];
      if (v3)
        free(v3);
    }
    v4 = (void *)a1[69];
    if (v4)
      free(v4);
    v5 = (void *)a1[124];
    if (v5)
      free(v5);
    free(a1);
  }
}

uint64_t GenerateTag(char *a1)
{
  unsigned int v2;

  v2 = hwrandom();
  return sprintf(a1, "%lu", v2);
}

uint64_t GenerateBranch(char *a1)
{
  int v2;
  int v3;

  v2 = hwrandom();
  v3 = hwrandom();
  return sprintf(a1, "z9hG4bK%08x%08x", v2, v3);
}

uint64_t CreateAck(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  __int128 *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  char *v30;
  int v31;
  uint64_t v32;
  __int128 v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v41;
  unint64_t v42;
  _OWORD v43[4];
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (!a2)
    return 2148401186;
  v41 = 0xAAAAAAAAAAAAAAAALL;
  v42 = 0xAAAAAAAAAAAAAAAALL;
  v6 = CreateGenericSIPMsg(&v41, *(_DWORD *)(a2 + 572), *(_WORD *)(a2 + 568), *(_WORD *)(a2 + 570), *(_DWORD *)(a2 + 1008));
  if ((v6 & 0x80000000) != 0)
    return v6;
  v7 = v41;
  *(_QWORD *)(v41 + 4) = 0x200000001;
  v8 = *(_QWORD *)(a3 + 224);
  if (v8)
    v9 = (__int128 *)(v8 + 44);
  else
    v9 = (__int128 *)(a2 + 12);
  v10 = *v9;
  v11 = v9[1];
  *(_OWORD *)(v7 + 44) = v9[2];
  *(_OWORD *)(v7 + 28) = v11;
  *(_OWORD *)(v7 + 12) = v10;
  v12 = v9[3];
  v13 = v9[4];
  v14 = v9[5];
  *(_OWORD *)(v7 + 108) = v9[6];
  *(_OWORD *)(v7 + 92) = v14;
  *(_OWORD *)(v7 + 76) = v13;
  *(_OWORD *)(v7 + 60) = v12;
  v15 = *(_OWORD *)(a2 + 696);
  v16 = *(_OWORD *)(a2 + 712);
  *(_QWORD *)(v7 + 728) = *(_QWORD *)(a2 + 728);
  *(_OWORD *)(v7 + 696) = v15;
  *(_OWORD *)(v7 + 712) = v16;
  v17 = *(_OWORD *)(a2 + 736);
  v18 = *(_OWORD *)(a2 + 752);
  *(_QWORD *)(v7 + 768) = *(_QWORD *)(a2 + 768);
  *(_OWORD *)(v7 + 736) = v17;
  *(_OWORD *)(v7 + 752) = v18;
  v19 = *(_OWORD *)(a2 + 776);
  v20 = *(_OWORD *)(a2 + 792);
  *(_QWORD *)(v7 + 808) = *(_QWORD *)(a2 + 808);
  *(_OWORD *)(v7 + 776) = v19;
  *(_OWORD *)(v7 + 792) = v20;
  v21 = *(_OWORD *)(a2 + 816);
  v22 = *(_OWORD *)(a2 + 832);
  *(_QWORD *)(v7 + 848) = *(_QWORD *)(a2 + 848);
  *(_OWORD *)(v7 + 816) = v21;
  *(_OWORD *)(v7 + 832) = v22;
  v23 = *(_OWORD *)(a2 + 856);
  v24 = *(_OWORD *)(a2 + 872);
  *(_QWORD *)(v7 + 888) = *(_QWORD *)(a2 + 888);
  *(_OWORD *)(v7 + 856) = v23;
  *(_OWORD *)(v7 + 872) = v24;
  v25 = CopySipHeader(&v42, *(const void **)(a2 + 208), 9u);
  if ((v25 & 0x80000000) != 0)
  {
    v39 = v25;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateAck_cold_1();
    }
    goto LABEL_45;
  }
  *(_QWORD *)(v7 + 208) = v42;
  v26 = CopySipHeader(&v42, *(const void **)(a2 + 312), 0x16u);
  if ((v26 & 0x80000000) != 0)
  {
    v39 = v26;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateAck_cold_2();
    }
    goto LABEL_45;
  }
  *(_QWORD *)(v7 + 312) = v42;
  v27 = CopySipHeader(&v42, *(const void **)(a3 + 480), 0x2Bu);
  if ((v27 & 0x80000000) != 0)
  {
    v39 = v27;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateAck_cold_3();
    }
    goto LABEL_45;
  }
  v28 = v42;
  *(_QWORD *)(v7 + 480) = v42;
  v29 = *(_QWORD *)(a2 + 480);
  v31 = *(unsigned __int8 *)(v29 + 156);
  v30 = (char *)(v29 + 156);
  if (!v31)
    strncpy(v30, (const char *)(v28 + 156), 0x40uLL);
  v32 = CopySipHeader(&v42, *(const void **)(a2 + 504), 0x2Eu);
  if ((v32 & 0x80000000) != 0)
  {
    v39 = v32;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateAck_cold_4();
    }
    goto LABEL_45;
  }
  if ((*(_DWORD *)(a3 + 8) & 0xFFFFFFFE) == 6)
  {
    *(_QWORD *)&v33 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v33 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v43[2] = v33;
    v43[3] = v33;
    v43[0] = v33;
    v43[1] = v33;
    GenerateBranch((char *)v43);
    __strlcpy_chk();
  }
  *(_QWORD *)(v7 + 504) = v42;
  v34 = CopySipHeader(&v42, *(const void **)(a2 + 272), 0x11u);
  if ((v34 & 0x80000000) != 0)
  {
    v39 = v34;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateAck_cold_5();
    }
    goto LABEL_45;
  }
  v35 = v42;
  *(_DWORD *)(v42 + 8) = 2;
  *(_QWORD *)(v7 + 272) = v35;
  v36 = CreateUserAgentHdr(&v42);
  if ((v36 & 0x80000000) != 0)
  {
    v39 = v36;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateAck_cold_6();
    }
    goto LABEL_45;
  }
  *(_QWORD *)(v7 + 496) = v42;
  v37 = CreateContentLengthHdr(&v42, -1);
  if ((v37 & 0x80000000) != 0)
  {
    v39 = v37;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateAck_cold_7();
    }
    goto LABEL_45;
  }
  *(_QWORD *)(v7 + 256) = v42;
  v38 = CreateMaxForwardsHdr(&v42, 70);
  if ((v38 & 0x80000000) != 0)
  {
    v39 = v38;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateAck_cold_8();
    }
LABEL_45:
    FreeSipMsg((_QWORD *)v7);
    return v39;
  }
  v39 = 0;
  *(_QWORD *)(v7 + 328) = v42;
  *a1 = v7;
  return v39;
}

uint64_t CreateCancel(_QWORD *a1, uint64_t a2)
{
  char *v4;
  _QWORD *v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;
  uint64_t CSeqHdr;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t UserAgentHdr;
  uint64_t ContentLengthHdr;
  uint64_t MaxForwardsHdr;
  uint64_t v29;
  _QWORD v31[2];

  v31[1] = *MEMORY[0x1E0C80C00];
  v31[0] = 0xAAAAAAAAAAAAAAAALL;
  v4 = (char *)malloc_type_calloc(1uLL, 0x400uLL, 0x10B2040CFE7BBC5uLL);
  if (v4)
  {
    v5 = v4;
    *(_QWORD *)(v4 + 4) = 0x500000001;
    if (a2)
    {
      *((_DWORD *)v4 + 143) = *(_DWORD *)(a2 + 572);
      *((_DWORD *)v4 + 142) = *(_DWORD *)(a2 + 568);
      *((_DWORD *)v4 + 252) = *(_DWORD *)(a2 + 1008);
      *((_QWORD *)v4 + 127) = SIPCompressCallback;
      v6 = *(_OWORD *)(a2 + 12);
      v7 = *(_OWORD *)(a2 + 28);
      *(_OWORD *)(v4 + 44) = *(_OWORD *)(a2 + 44);
      *(_OWORD *)(v4 + 28) = v7;
      *(_OWORD *)(v4 + 12) = v6;
      v8 = *(_OWORD *)(a2 + 60);
      v9 = *(_OWORD *)(a2 + 76);
      v10 = *(_OWORD *)(a2 + 92);
      *(_OWORD *)(v4 + 108) = *(_OWORD *)(a2 + 108);
      *(_OWORD *)(v4 + 92) = v10;
      *(_OWORD *)(v4 + 76) = v9;
      *(_OWORD *)(v4 + 60) = v8;
      v11 = *(_OWORD *)(a2 + 696);
      v12 = *(_OWORD *)(a2 + 712);
      *((_QWORD *)v4 + 91) = *(_QWORD *)(a2 + 728);
      *(_OWORD *)(v4 + 696) = v11;
      *(_OWORD *)(v4 + 712) = v12;
      v13 = *(_OWORD *)(a2 + 736);
      v14 = *(_OWORD *)(a2 + 752);
      *((_QWORD *)v4 + 96) = *(_QWORD *)(a2 + 768);
      *((_OWORD *)v4 + 46) = v13;
      *((_OWORD *)v4 + 47) = v14;
      v15 = *(_OWORD *)(a2 + 776);
      v16 = *(_OWORD *)(a2 + 792);
      *((_QWORD *)v4 + 101) = *(_QWORD *)(a2 + 808);
      *(_OWORD *)(v4 + 776) = v15;
      *(_OWORD *)(v4 + 792) = v16;
      v17 = *(_OWORD *)(a2 + 816);
      v18 = *(_OWORD *)(a2 + 832);
      *((_QWORD *)v4 + 106) = *(_QWORD *)(a2 + 848);
      *((_OWORD *)v4 + 51) = v17;
      *((_OWORD *)v4 + 52) = v18;
      v19 = *(_OWORD *)(a2 + 856);
      v20 = *(_OWORD *)(a2 + 872);
      *((_QWORD *)v4 + 111) = *(_QWORD *)(a2 + 888);
      *(_OWORD *)(v4 + 856) = v19;
      *(_OWORD *)(v4 + 872) = v20;
      v21 = CopySipHeader(v31, *(const void **)(a2 + 208), 9u);
      if ((v21 & 0x80000000) != 0)
      {
        v29 = v21;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            CreateCancel_cold_2();
        }
      }
      else
      {
        v5[26] = v31[0];
        CSeqHdr = CreateCSeqHdr(v31, **(_QWORD **)(a2 + 272), 5);
        if ((CSeqHdr & 0x80000000) != 0)
        {
          v29 = CSeqHdr;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              CreateCancel_cold_3();
          }
        }
        else
        {
          v5[34] = v31[0];
          v23 = CopySipHeader(v31, *(const void **)(a2 + 312), 0x16u);
          if ((v23 & 0x80000000) != 0)
          {
            v29 = v23;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                CreateCancel_cold_4();
            }
          }
          else
          {
            v5[39] = v31[0];
            v24 = CopySipHeader(v31, *(const void **)(a2 + 480), 0x2Bu);
            if ((v24 & 0x80000000) != 0)
            {
              v29 = v24;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  CreateCancel_cold_5();
              }
            }
            else
            {
              v5[60] = v31[0];
              v25 = CopySipHeader(v31, *(const void **)(a2 + 504), 0x2Eu);
              if ((v25 & 0x80000000) != 0)
              {
                v29 = v25;
                if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                {
                  VRTraceErrorLogLevelToCSTR();
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                    CreateCancel_cold_6();
                }
              }
              else
              {
                v5[63] = v31[0];
                UserAgentHdr = CreateUserAgentHdr(v31);
                if ((UserAgentHdr & 0x80000000) != 0)
                {
                  v29 = UserAgentHdr;
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                  {
                    VRTraceErrorLogLevelToCSTR();
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                      CreateCancel_cold_7();
                  }
                }
                else
                {
                  v5[62] = v31[0];
                  ContentLengthHdr = CreateContentLengthHdr(v31, -1);
                  if ((ContentLengthHdr & 0x80000000) != 0)
                  {
                    v29 = ContentLengthHdr;
                    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                    {
                      VRTraceErrorLogLevelToCSTR();
                      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                        CreateCancel_cold_8();
                    }
                  }
                  else
                  {
                    v5[32] = v31[0];
                    MaxForwardsHdr = CreateMaxForwardsHdr(v31, 70);
                    if ((MaxForwardsHdr & 0x80000000) == 0)
                    {
                      v29 = 0;
                      v5[41] = v31[0];
LABEL_16:
                      *a1 = v5;
                      return v29;
                    }
                    v29 = MaxForwardsHdr;
                    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                    {
                      VRTraceErrorLogLevelToCSTR();
                      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                        CreateCancel_cold_9();
                    }
                  }
                }
              }
            }
          }
        }
      }
      FreeSipMsg(v5);
      return v29;
    }
    v29 = 0;
    goto LABEL_16;
  }
  v29 = 2148401155;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      CreateCancel_cold_1();
  }
  return v29;
}

uint64_t CreateBye(unint64_t *a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  __int128 *v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v40;
  unint64_t v41;
  uint64_t v42;
  _QWORD __b[113];
  _OWORD v44[2];
  unint64_t v45;
  _OWORD v46[4];
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  v42 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v10 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v46[2] = v10;
  v46[3] = v10;
  v46[0] = v10;
  v46[1] = v10;
  v45 = 0xAAAAAAAAAAAAAAAALL;
  v44[0] = v10;
  v44[1] = v10;
  v40 = 0xAAAAAAAAAAAAAAAALL;
  memset(__b, 170, sizeof(__b));
  v11 = DLGetData(a2, (uint64_t)__b);
  if ((v11 & 0x80000000) == 0)
  {
    v41 = 0xAAAAAAAAAAAAAAAALL;
    v12 = CreateGenericSIPMsg(&v41, SHIDWORD(__b[0]), __b[3], SWORD1(__b[3]), a5 != 0);
    if ((v12 & 0x80000000) != 0)
      return v12;
    DLIncreaseLocalSeq(a2, &v42);
    v13 = v41;
    *(_QWORD *)(v41 + 4) = 0x400000001;
    if (*(_DWORD *)((char *)&__b[62] + 6) == 5260116)
      v14 = (__int128 *)&__b[97];
    else
      v14 = (__int128 *)&__b[83];
    v15 = *v14;
    v16 = v14[1];
    *(_OWORD *)(v13 + 44) = v14[2];
    *(_OWORD *)(v13 + 28) = v16;
    *(_OWORD *)(v13 + 12) = v15;
    v17 = v14[3];
    v18 = v14[4];
    v19 = v14[5];
    *(_OWORD *)(v13 + 108) = v14[6];
    *(_OWORD *)(v13 + 92) = v19;
    *(_OWORD *)(v13 + 76) = v18;
    *(_OWORD *)(v13 + 60) = v17;
    v20 = *(_OWORD *)((char *)&__b[5] + 4);
    *(_OWORD *)(v13 + 696) = *(_OWORD *)((char *)&__b[3] + 4);
    *(_OWORD *)(v13 + 712) = v20;
    *(_QWORD *)(v13 + 728) = *(_QWORD *)((char *)&__b[7] + 4);
    v21 = *(_OWORD *)((char *)&__b[8] + 4);
    v22 = *(_OWORD *)((char *)&__b[10] + 4);
    *(_QWORD *)(v13 + 768) = *(_QWORD *)((char *)&__b[12] + 4);
    *(_OWORD *)(v13 + 736) = v21;
    *(_OWORD *)(v13 + 752) = v22;
    v23 = *(_OWORD *)((char *)&__b[13] + 4);
    v24 = *(_OWORD *)((char *)&__b[15] + 4);
    *(_QWORD *)(v13 + 808) = *(_QWORD *)((char *)&__b[17] + 4);
    *(_OWORD *)(v13 + 776) = v23;
    *(_OWORD *)(v13 + 792) = v24;
    v25 = *(_OWORD *)((char *)&__b[18] + 4);
    v26 = *(_OWORD *)((char *)&__b[20] + 4);
    *(_QWORD *)(v13 + 848) = *(_QWORD *)((char *)&__b[22] + 4);
    *(_OWORD *)(v13 + 816) = v25;
    *(_OWORD *)(v13 + 832) = v26;
    v27 = *(_OWORD *)((char *)&__b[23] + 4);
    v28 = *(_OWORD *)((char *)&__b[25] + 4);
    *(_QWORD *)(v13 + 888) = *(_QWORD *)((char *)&__b[27] + 4);
    *(_OWORD *)(v13 + 856) = v27;
    *(_OWORD *)(v13 + 872) = v28;
    v29 = CreateCallIDHdr(&v40);
    if ((v29 & 0x80000000) != 0)
    {
      v38 = v29;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          CreateBye_cold_2();
      }
    }
    else
    {
      *(_QWORD *)(v13 + 208) = v40;
      v30 = CreateCSeqHdr(&v40, v42, 4);
      if ((v30 & 0x80000000) != 0)
      {
        v38 = v30;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            CreateBye_cold_3();
        }
      }
      else
      {
        *(_QWORD *)(v13 + 272) = v40;
        v31 = CreateFromHdr(&v40, (uint64_t)&__b[36], (__int128 *)&__b[69]);
        if ((v31 & 0x80000000) != 0)
        {
          v38 = v31;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              CreateBye_cold_4();
          }
        }
        else
        {
          *(_QWORD *)(v13 + 312) = v40;
          v32 = CreateToHdr(&v40, (uint64_t)&__b[41] + 3, (__int128 *)&__b[83]);
          if ((v32 & 0x80000000) != 0)
          {
            v38 = v32;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                CreateBye_cold_5();
            }
          }
          else
          {
            *(_QWORD *)(v13 + 480) = v40;
            IPToString();
            GenerateBranch((char *)v46);
            v33 = CreateViaHdr(&v40, (uint64_t)DEFAULT_TRANSPORT, BYTE4(__b[13]) & 1, (uint64_t)v44, __b[18], (uint64_t)v46, 0);
            if ((v33 & 0x80000000) != 0)
            {
              v38 = v33;
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                VRTraceErrorLogLevelToCSTR();
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  CreateBye_cold_6();
              }
            }
            else
            {
              *(_QWORD *)(v13 + 504) = v40;
              v34 = CreateUserAgentHdr(&v40);
              if ((v34 & 0x80000000) != 0)
              {
                v38 = v34;
                if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                {
                  VRTraceErrorLogLevelToCSTR();
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                    CreateBye_cold_7();
                }
              }
              else
              {
                *(_QWORD *)(v13 + 496) = v40;
                v35 = CreateReasonHdr(&v40, (uint64_t)"*", a3, a4);
                if ((v35 & 0x80000000) != 0)
                {
                  v38 = v35;
                  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                  {
                    VRTraceErrorLogLevelToCSTR();
                    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                      CreateBye_cold_8();
                  }
                }
                else
                {
                  *(_QWORD *)(v13 + 544) = v40;
                  v36 = CreateContentLengthHdr(&v40, -1);
                  if ((v36 & 0x80000000) != 0)
                  {
                    v38 = v36;
                    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                    {
                      VRTraceErrorLogLevelToCSTR();
                      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                        CreateBye_cold_9();
                    }
                  }
                  else
                  {
                    *(_QWORD *)(v13 + 256) = v40;
                    v37 = CreateMaxForwardsHdr(&v40, 70);
                    if ((v37 & 0x80000000) == 0)
                    {
                      v38 = 0;
                      *(_QWORD *)(v13 + 328) = v40;
                      *a1 = v13;
                      return v38;
                    }
                    v38 = v37;
                    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                    {
                      VRTraceErrorLogLevelToCSTR();
                      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                        CreateBye_cold_10();
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    FreeSipMsg((_QWORD *)v13);
    return v38;
  }
  v38 = v11;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      CreateBye_cold_1();
  }
  return v38;
}

uint64_t CreateMessageInDialog(unint64_t *a1, uint64_t a2, char *__s, int a4)
{
  int v8;

  if (__s)
    v8 = strlen(__s);
  else
    v8 = 0;
  return CreateBinaryMessageInDialog(a1, a2, __s, v8, a4);
}

uint64_t CreateBinaryMessageInDialog(unint64_t *a1, uint64_t a2, const void *a3, int a4, int a5)
{
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  __int128 *v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  _BYTE *v38;
  uint64_t v39;
  unint64_t v41;
  unint64_t v42;
  uint64_t v43;
  _QWORD __b[113];
  _OWORD v45[2];
  unint64_t v46;
  _OWORD v47[4];
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v43 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v10 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v47[2] = v10;
  v47[3] = v10;
  v47[0] = v10;
  v47[1] = v10;
  v46 = 0xAAAAAAAAAAAAAAAALL;
  v45[0] = v10;
  v45[1] = v10;
  v41 = 0xAAAAAAAAAAAAAAAALL;
  memset(__b, 170, sizeof(__b));
  v11 = DLGetData(a2, (uint64_t)__b);
  if ((v11 & 0x80000000) != 0)
  {
    v39 = v11;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateBinaryMessageInDialog_cold_1();
    }
    return v39;
  }
  v42 = 0xAAAAAAAAAAAAAAAALL;
  v12 = CreateGenericSIPMsg(&v42, SHIDWORD(__b[0]), __b[3], SWORD1(__b[3]), a5 != 0);
  if ((v12 & 0x80000000) != 0)
    return v12;
  DLIncreaseLocalSeq(a2, &v43);
  v13 = v42;
  *(_QWORD *)(v42 + 4) = 0x700000001;
  if (*(_DWORD *)((char *)&__b[62] + 6) == 5260116)
    v14 = (__int128 *)&__b[97];
  else
    v14 = (__int128 *)&__b[83];
  v15 = *v14;
  v16 = v14[1];
  *(_OWORD *)(v13 + 44) = v14[2];
  *(_OWORD *)(v13 + 28) = v16;
  *(_OWORD *)(v13 + 12) = v15;
  v17 = v14[3];
  v18 = v14[4];
  v19 = v14[5];
  *(_OWORD *)(v13 + 108) = v14[6];
  *(_OWORD *)(v13 + 92) = v19;
  *(_OWORD *)(v13 + 76) = v18;
  *(_OWORD *)(v13 + 60) = v17;
  v20 = *(_OWORD *)((char *)&__b[5] + 4);
  *(_OWORD *)(v13 + 696) = *(_OWORD *)((char *)&__b[3] + 4);
  *(_OWORD *)(v13 + 712) = v20;
  *(_QWORD *)(v13 + 728) = *(_QWORD *)((char *)&__b[7] + 4);
  v21 = *(_OWORD *)((char *)&__b[8] + 4);
  v22 = *(_OWORD *)((char *)&__b[10] + 4);
  *(_QWORD *)(v13 + 768) = *(_QWORD *)((char *)&__b[12] + 4);
  *(_OWORD *)(v13 + 736) = v21;
  *(_OWORD *)(v13 + 752) = v22;
  v23 = *(_OWORD *)((char *)&__b[13] + 4);
  v24 = *(_OWORD *)((char *)&__b[15] + 4);
  *(_QWORD *)(v13 + 808) = *(_QWORD *)((char *)&__b[17] + 4);
  *(_OWORD *)(v13 + 776) = v23;
  *(_OWORD *)(v13 + 792) = v24;
  v25 = *(_OWORD *)((char *)&__b[18] + 4);
  v26 = *(_OWORD *)((char *)&__b[20] + 4);
  *(_QWORD *)(v13 + 848) = *(_QWORD *)((char *)&__b[22] + 4);
  *(_OWORD *)(v13 + 816) = v25;
  *(_OWORD *)(v13 + 832) = v26;
  v27 = *(_OWORD *)((char *)&__b[23] + 4);
  v28 = *(_OWORD *)((char *)&__b[25] + 4);
  *(_QWORD *)(v13 + 888) = *(_QWORD *)((char *)&__b[27] + 4);
  *(_OWORD *)(v13 + 856) = v27;
  *(_OWORD *)(v13 + 872) = v28;
  v29 = CreateCallIDHdr(&v41);
  if ((v29 & 0x80000000) != 0)
  {
    v39 = v29;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateBinaryMessageInDialog_cold_2();
    }
    goto LABEL_50;
  }
  *(_QWORD *)(v13 + 208) = v41;
  v30 = CreateCSeqHdr(&v41, v43, 7);
  if ((v30 & 0x80000000) != 0)
  {
    v39 = v30;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateBinaryMessageInDialog_cold_3();
    }
    goto LABEL_50;
  }
  *(_QWORD *)(v13 + 272) = v41;
  v31 = CreateFromHdr(&v41, (uint64_t)&__b[36], (__int128 *)&__b[69]);
  if ((v31 & 0x80000000) != 0)
  {
    v39 = v31;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateBinaryMessageInDialog_cold_4();
    }
    goto LABEL_50;
  }
  *(_QWORD *)(v13 + 312) = v41;
  v32 = CreateToHdr(&v41, (uint64_t)&__b[41] + 3, (__int128 *)&__b[83]);
  if ((v32 & 0x80000000) != 0)
  {
    v39 = v32;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateBinaryMessageInDialog_cold_5();
    }
    goto LABEL_50;
  }
  *(_QWORD *)(v13 + 480) = v41;
  IPToString();
  GenerateBranch((char *)v47);
  v33 = CreateViaHdr(&v41, (uint64_t)DEFAULT_TRANSPORT, BYTE4(__b[13]) & 1, (uint64_t)v45, __b[18], (uint64_t)v47, 0);
  if ((v33 & 0x80000000) != 0)
  {
    v39 = v33;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateBinaryMessageInDialog_cold_6();
    }
    goto LABEL_50;
  }
  *(_QWORD *)(v13 + 504) = v41;
  v34 = CreateUserAgentHdr(&v41);
  if ((v34 & 0x80000000) != 0)
  {
    v39 = v34;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateBinaryMessageInDialog_cold_7();
    }
    goto LABEL_50;
  }
  *(_QWORD *)(v13 + 496) = v41;
  v35 = CreateContentTypeHdr(&v41);
  if ((v35 & 0x80000000) != 0)
  {
    v39 = v35;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateBinaryMessageInDialog_cold_8();
    }
    goto LABEL_50;
  }
  *(_QWORD *)(v13 + 264) = v41;
  v36 = CreateContentLengthHdr(&v41, -1);
  if ((v36 & 0x80000000) != 0)
  {
    v39 = v36;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateBinaryMessageInDialog_cold_9();
    }
    goto LABEL_50;
  }
  *(_QWORD *)(v13 + 256) = v41;
  v37 = CreateMaxForwardsHdr(&v41, 70);
  if ((v37 & 0x80000000) != 0)
  {
    v39 = v37;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateBinaryMessageInDialog_cold_10();
    }
LABEL_50:
    FreeSipMsg((_QWORD *)v13);
    return v39;
  }
  *(_QWORD *)(v13 + 328) = v41;
  if (!a3)
  {
LABEL_18:
    v39 = 0;
    *a1 = v13;
    return v39;
  }
  v38 = malloc_type_malloc(a4 + 1, 0x4891D97DuLL);
  *(_QWORD *)(v13 + 552) = v38;
  if (v38)
  {
    *(_DWORD *)(v13 + 560) = a4;
    v38[a4] = 0;
    memcpy(*(void **)(v13 + 552), a3, a4);
    goto LABEL_18;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      CreateBinaryMessageInDialog_cold_11();
  }
  FreeSipMsg((_QWORD *)v13);
  return 2148401155;
}

uint64_t CreateSKEMessageInDialog(unint64_t *a1, uint64_t a2, const void *a3, int a4, uint64_t a5, int a6, int a7)
{
  uint64_t BinaryMessageInDialog;
  uint64_t SKESeqHdr;
  uint64_t ContentTypeHdr;
  uint64_t v13;
  _QWORD v15[2];

  v15[1] = *MEMORY[0x1E0C80C00];
  BinaryMessageInDialog = CreateBinaryMessageInDialog(a1, a2, a3, a4, a7);
  if ((BinaryMessageInDialog & 0x80000000) != 0)
    return BinaryMessageInDialog;
  v15[0] = 0xAAAAAAAAAAAAAAAALL;
  *(_DWORD *)(*a1 + 564) = 1;
  SKESeqHdr = CreateSKESeqHdr(v15, a5, a6);
  if ((SKESeqHdr & 0x80000000) != 0)
  {
    v13 = SKESeqHdr;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateSKEMessageInDialog_cold_1();
    }
    goto LABEL_12;
  }
  *(_QWORD *)(*a1 + 528) = v15[0];
  free(*(void **)(*a1 + 264));
  ContentTypeHdr = CreateContentTypeHdr(v15);
  if ((ContentTypeHdr & 0x80000000) != 0)
  {
    v13 = ContentTypeHdr;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateSKEMessageInDialog_cold_2();
    }
LABEL_12:
    FreeSipMsg((_QWORD *)*a1);
    return v13;
  }
  v13 = 0;
  *(_QWORD *)(*a1 + 264) = v15[0];
  return v13;
}

uint64_t CreateGenericStatus(unint64_t *a1, uint64_t a2, int a3, char *a4, char *a5, int a6, int a7, int a8, int a9)
{
  uint64_t v17;
  unint64_t v18;
  char *v19;
  char *StatusMsg;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const void *v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  const void *v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  __int128 v50;
  __int128 *v51;
  uint64_t v52;
  __int128 v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;
  int v59;
  uint64_t v60;
  _BYTE *v61;
  unint64_t v63;
  unint64_t v64;
  _BYTE v65[112];
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  if (!a2)
    return 2148401186;
  v63 = 0xAAAAAAAAAAAAAAAALL;
  v64 = 0xAAAAAAAAAAAAAAAALL;
  v17 = CreateGenericSIPMsg(&v64, *(_DWORD *)(a2 + 572), *(_WORD *)(a2 + 568), *(_WORD *)(a2 + 570), *(_DWORD *)(a2 + 1008));
  if ((v17 & 0x80000000) != 0)
    return v17;
  v18 = v64;
  *(_DWORD *)(v64 + 4) = 2;
  *(_DWORD *)(v18 + 8) = a3;
  if (a4 && *a4)
  {
    v19 = (char *)(v18 + 12);
    StatusMsg = a4;
  }
  else
  {
    StatusMsg = GetStatusMsg(a3);
    v19 = (char *)(v18 + 12);
  }
  strncpy(v19, StatusMsg, 0x2BuLL);
  v22 = *(_OWORD *)(a2 + 696);
  v23 = *(_OWORD *)(a2 + 712);
  *(_QWORD *)(v18 + 728) = *(_QWORD *)(a2 + 728);
  *(_OWORD *)(v18 + 696) = v22;
  *(_OWORD *)(v18 + 712) = v23;
  v24 = *(_OWORD *)(a2 + 736);
  v25 = *(_OWORD *)(a2 + 752);
  *(_QWORD *)(v18 + 768) = *(_QWORD *)(a2 + 768);
  *(_OWORD *)(v18 + 736) = v24;
  *(_OWORD *)(v18 + 752) = v25;
  v26 = *(_OWORD *)(a2 + 776);
  v27 = *(_OWORD *)(a2 + 792);
  *(_QWORD *)(v18 + 808) = *(_QWORD *)(a2 + 808);
  *(_OWORD *)(v18 + 776) = v26;
  *(_OWORD *)(v18 + 792) = v27;
  v28 = *(_OWORD *)(a2 + 816);
  v29 = *(_OWORD *)(a2 + 832);
  *(_QWORD *)(v18 + 848) = *(_QWORD *)(a2 + 848);
  *(_OWORD *)(v18 + 816) = v28;
  *(_OWORD *)(v18 + 832) = v29;
  v30 = *(_OWORD *)(a2 + 856);
  v31 = *(_OWORD *)(a2 + 872);
  *(_QWORD *)(v18 + 888) = *(_QWORD *)(a2 + 888);
  *(_OWORD *)(v18 + 856) = v30;
  *(_OWORD *)(v18 + 872) = v31;
  v32 = CopySipHeader(&v63, *(const void **)(a2 + 208), 9u);
  if ((v32 & 0x80000000) != 0)
  {
    v21 = v32;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateGenericStatus_cold_1();
    }
    goto LABEL_115;
  }
  *(_QWORD *)(v18 + 208) = v63;
  v33 = CopySipHeader(&v63, *(const void **)(a2 + 312), 0x16u);
  if ((v33 & 0x80000000) != 0)
  {
    v21 = v33;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateGenericStatus_cold_2();
    }
    goto LABEL_115;
  }
  *(_QWORD *)(v18 + 312) = v63;
  v34 = CopySipHeader(&v63, *(const void **)(a2 + 272), 0x11u);
  if ((v34 & 0x80000000) != 0)
  {
    v21 = v34;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateGenericStatus_cold_3();
    }
    goto LABEL_115;
  }
  *(_QWORD *)(v18 + 272) = v63;
  v35 = CopySipHeader(&v63, *(const void **)(a2 + 504), 0x2Eu);
  if ((v35 & 0x80000000) != 0)
  {
    v21 = v35;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateGenericStatus_cold_4();
    }
    goto LABEL_115;
  }
  *(_QWORD *)(v18 + 504) = v63;
  v36 = CopySipHeader(&v63, *(const void **)(a2 + 480), 0x2Bu);
  if ((v36 & 0x80000000) != 0)
  {
    v21 = v36;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateGenericStatus_cold_5();
    }
    goto LABEL_115;
  }
  *(_QWORD *)(v18 + 480) = v63;
  v37 = *(const void **)(a2 + 528);
  if (v37)
  {
    CopySipHeader(&v63, v37, 0x31u);
    *(_QWORD *)(v18 + 528) = v63;
  }
  v38 = CreateUserAgentHdr(&v63);
  if ((v38 & 0x80000000) != 0)
  {
    v21 = v38;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateGenericStatus_cold_6();
    }
    goto LABEL_115;
  }
  *(_QWORD *)(v18 + 496) = v63;
  v39 = CreateContentLengthHdr(&v63, -1);
  if ((v39 & 0x80000000) != 0)
  {
    v21 = v39;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        CreateGenericStatus_cold_7();
    }
    goto LABEL_115;
  }
  *(_QWORD *)(v18 + 256) = v63;
  v40 = *(_DWORD *)(a2 + 8);
  if (v40 == 10)
  {
    if (a3 == 1)
      goto LABEL_62;
    if (a3 != 39)
    {
      v48 = 10;
LABEL_86:
      if ((a3 - 8) > 4 || v48 != 10)
      {
        if ((a3 & 0xFFFFFFFE) != 6 || v48 != 8)
          goto LABEL_101;
        *(_DWORD *)&v65[108] = -1431655766;
        *(_QWORD *)&v53 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v53 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)&v65[92] = v53;
        *(_OWORD *)&v65[76] = v53;
        *(_OWORD *)&v65[60] = v53;
        goto LABEL_93;
      }
LABEL_88:
      *(_QWORD *)&v50 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v50 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)&v65[80] = v50;
      *(_OWORD *)&v65[96] = v50;
      *(_OWORD *)&v65[48] = v50;
      *(_OWORD *)&v65[64] = v50;
      *(_OWORD *)&v65[16] = v50;
      *(_OWORD *)&v65[32] = v50;
      *(_OWORD *)v65 = v50;
      if (a3 == 10)
      {
        v51 = (__int128 *)(a5 + 44);
        a8 = *((_DWORD *)a5 + 39);
        v52 = (uint64_t)a5;
        a5 = 0;
LABEL_94:
        v54 = CreateContactHdr(&v63, v52, v51, a8, a9);
        if ((v54 & 0x80000000) != 0)
        {
          v21 = v54;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              CreateGenericStatus_cold_8();
          }
          goto LABEL_115;
        }
        *(_QWORD *)(v18 + 224) = v63;
        if (a3 == 6 && a5 && *a5)
        {
          v55 = CreateContentTypeHdr(&v63);
          if ((v55 & 0x80000000) != 0)
          {
            v21 = v55;
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                CreateGenericStatus_cold_10();
            }
            goto LABEL_115;
          }
          *(_QWORD *)(v18 + 264) = v63;
        }
        v48 = *(_DWORD *)(a2 + 8);
LABEL_101:
        if (!a5 || v48 != 7 || !*(_QWORD *)(v18 + 528))
        {
LABEL_106:
          v57 = *(_QWORD *)(a2 + 480);
          v59 = *(unsigned __int8 *)(v57 + 156);
          v58 = (char *)(v57 + 156);
          if (!v59)
          {
            v60 = *(_QWORD *)(v18 + 480);
            GenerateTag(v58);
            strncpy((char *)(v60 + 156), v58, 0x40uLL);
          }
          goto LABEL_108;
        }
        v56 = CreateContentTypeHdr(&v63);
        if ((v56 & 0x80000000) == 0)
        {
          *(_QWORD *)(v18 + 264) = v63;
          goto LABEL_106;
        }
        v21 = v56;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            CreateGenericStatus_cold_9();
        }
LABEL_115:
        FreeSipMsg((_QWORD *)v18);
        return v21;
      }
LABEL_93:
      *(_OWORD *)&v65[5] = *(_OWORD *)"user";
      v65[4] = 0;
      strcpy(v65, "sip");
      memset(&v65[21], 0, 35);
      *(_DWORD *)&v65[56] = *(_DWORD *)(a2 + 776) & 1;
      v51 = (__int128 *)v65;
      IPToString();
      *(_WORD *)&v65[100] = *(_WORD *)(a2 + 812);
      strncpy(&v65[102], DEFAULT_TRANSPORT, 4uLL);
      v52 = 0;
      *(_DWORD *)&v65[108] = 0;
      goto LABEL_94;
    }
    v44 = CreateAllowEventsHdr(&v63, a8);
    if ((v44 & 0x80000000) != 0)
    {
      v21 = v44;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          CreateGenericStatus_cold_17();
      }
      goto LABEL_115;
    }
LABEL_61:
    *(_QWORD *)(v18 + 184) = v63;
    goto LABEL_81;
  }
  if (v40 != 9)
  {
    if (v40 == 3)
    {
      v41 = CreateAcceptHdr(&v63, a8);
      if ((v41 & 0x80000000) != 0)
      {
        v21 = v41;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            CreateGenericStatus_cold_11();
        }
        goto LABEL_115;
      }
      *(_QWORD *)(v18 + 144) = v63;
      v42 = CreateAllowHdr(&v63, a8);
      if ((v42 & 0x80000000) != 0)
      {
        v21 = v42;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            CreateGenericStatus_cold_12();
        }
        goto LABEL_115;
      }
      *(_QWORD *)(v18 + 176) = v63;
      v43 = CreateAllowEventsHdr(&v63, a8);
      if ((v43 & 0x80000000) != 0)
      {
        v21 = v43;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            CreateGenericStatus_cold_13();
        }
        goto LABEL_115;
      }
      *(_QWORD *)(v18 + 184) = v63;
    }
    if (a3 != 1)
    {
LABEL_81:
      v48 = *(_DWORD *)(a2 + 8);
      if ((v48 | 2) == 3)
        goto LABEL_88;
LABEL_84:
      if ((a3 - 6) <= 6 && v48 == 9)
        goto LABEL_88;
      goto LABEL_86;
    }
    goto LABEL_62;
  }
  if ((a3 & 0xFFFFFFFE) == 6)
  {
    v45 = *(const void **)(a2 + 304);
    if (v45)
      v46 = CopySipHeader(&v63, v45, 0x15u);
    else
      v46 = CreateExpiresHdr(&v63, 3600);
    v21 = v46;
    if ((v46 & 0x80000000) != 0)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          CreateGenericStatus_cold_14();
      }
      goto LABEL_115;
    }
    *(_QWORD *)(v18 + 304) = v63;
    goto LABEL_81;
  }
  if (a3 != 1)
  {
    if (a3 == 29)
    {
      v49 = CreateMinExpiresHdr(&v63, 600);
      if ((v49 & 0x80000000) != 0)
      {
        v21 = v49;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            CreateGenericStatus_cold_16();
        }
        goto LABEL_115;
      }
      *(_QWORD *)(v18 + 344) = v63;
      goto LABEL_81;
    }
    if (a3 != 39)
    {
      v48 = 9;
      goto LABEL_84;
    }
    v47 = CreateAllowEventsHdr(&v63, a8);
    if ((v47 & 0x80000000) != 0)
    {
      v21 = v47;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          CreateGenericStatus_cold_15();
      }
      goto LABEL_115;
    }
    goto LABEL_61;
  }
LABEL_62:
  *(_BYTE *)(*(_QWORD *)(v18 + 480) + 156) = 0;
LABEL_108:
  if (a5)
  {
    *(_DWORD *)(v18 + 564) = a7;
    v61 = malloc_type_malloc(a6 + 1, 0x39100BCEuLL);
    *(_QWORD *)(v18 + 552) = v61;
    if (!v61)
    {
      FreeSipMsg((_QWORD *)v18);
      return 2148401155;
    }
    *(_DWORD *)(v18 + 560) = a6;
    v61[a6] = 0;
    memcpy(*(void **)(v18 + 552), a5, a6);
  }
  v21 = 0;
  *a1 = v18;
  return v21;
}

uint64_t CreateStatus(unint64_t *a1, uint64_t a2, int a3, char *a4, char *__s, int a6, int a7)
{
  int v14;

  if (__s)
    v14 = strlen(__s);
  else
    v14 = 0;
  return CreateGenericStatus(a1, a2, a3, a4, __s, v14, 0, a6, a7);
}

uint64_t ConstructSipMsg(char *a1, size_t a2, uint64_t a3)
{
  int v6;
  __int128 v7;
  uint64_t v8;
  uint64_t v10;
  NSObject *v11;
  int v12;
  _BYTE buf[48];
  __int128 v14;
  __int128 v15;
  char __b[1280];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  memset(__b, 170, sizeof(__b));
  v6 = *(_DWORD *)(a3 + 4);
  if (v6 == 2)
  {
    GetIntStatusCode(*(_DWORD *)(a3 + 8));
    __sprintf_chk(__b, 0, 0x500uLL, "%s %d %s\r\n");
    goto LABEL_5;
  }
  if (v6 == 1)
  {
    *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v14 = v7;
    v15 = v7;
    *(_OWORD *)&buf[16] = v7;
    *(_OWORD *)&buf[32] = v7;
    *(_OWORD *)buf = v7;
    ConstructUri(buf, (char *)(a3 + 12));
    __sprintf_chk(__b, 0, 0x500uLL, "%s %s %s\r\n");
LABEL_5:
    strncpy(a1, __b, a2);
    if ((ConstructViaHdr(__b, *(int **)(a3 + 504), 0x500uLL) & 0x80000000) == 0)
      strncat(a1, __b, a2);
    if ((ConstructMaxForwardsHdr(__b, *(_DWORD **)(a3 + 328)) & 0x80000000) == 0)
      strncat(a1, __b, a2);
    if ((ConstructToHdr(__b, *(char **)(a3 + 480)) & 0x80000000) == 0)
      strncat(a1, __b, a2);
    if ((ConstructFromHdr(__b, *(char **)(a3 + 312)) & 0x80000000) == 0)
      strncat(a1, __b, a2);
    if ((ConstructCallIDHdr(__b, *(const char **)(a3 + 208)) & 0x80000000) == 0)
      strncat(a1, __b, a2);
    if ((ConstructCSeqHdr(__b, *(_QWORD *)(a3 + 272)) & 0x80000000) == 0)
      strncat(a1, __b, a2);
    if ((ConstructReferToHdr(__b, *(char **)(a3 + 400)) & 0x80000000) == 0)
      strncat(a1, __b, a2);
    if ((ConstructContactHdr(__b, *(char **)(a3 + 224)) & 0x80000000) == 0)
      strncat(a1, __b, a2);
    if ((ConstructAllowHdr(__b, *(_QWORD **)(a3 + 176), 0x500uLL) & 0x80000000) == 0)
      strncat(a1, __b, a2);
    if ((ConstructEventHdr(__b, *(_QWORD *)(a3 + 296)) & 0x80000000) == 0)
      strncat(a1, __b, a2);
    if ((ConstructAllowEventsHdr(__b, *(_QWORD **)(a3 + 184), 0x500uLL) & 0x80000000) == 0)
      strncat(a1, __b, a2);
    if ((ConstructAcceptHdr(__b, *(const char **)(a3 + 144), 0x500uLL) & 0x80000000) == 0)
      strncat(a1, __b, a2);
    if ((ConstructSubscriptionStateHdr(__b, *(_DWORD **)(a3 + 456)) & 0x80000000) == 0)
      strncat(a1, __b, a2);
    if ((ConstructExpiresHdr(__b, *(_DWORD **)(a3 + 304)) & 0x80000000) == 0)
      strncat(a1, __b, a2);
    if ((ConstructMinExpiresHdr(__b, *(_DWORD **)(a3 + 344)) & 0x80000000) == 0)
      strncat(a1, __b, a2);
    if ((ConstructUserAgentHdr(__b, *(const char **)(a3 + 496)) & 0x80000000) == 0)
      strncat(a1, __b, a2);
    if ((ConstructContentTypeHdr(__b, *(const char **)(a3 + 264)) & 0x80000000) == 0)
      strncat(a1, __b, a2);
    if ((ConstructContentEncodingHdr(__b, *(const char **)(a3 + 240)) & 0x80000000) == 0)
      strncat(a1, __b, a2);
    if ((ConstructContentLengthHdr(__b, *(_DWORD **)(a3 + 256)) & 0x80000000) == 0)
      strncat(a1, __b, a2);
    if ((ConstructSKESeqHdr(__b, *(_QWORD *)(a3 + 528)) & 0x80000000) == 0)
      strncat(a1, __b, a2);
    bzero(__b, 0x500uLL);
    if ((ConstructReasonHdr(__b, *(_QWORD *)(a3 + 544)) & 0x80000000) == 0)
      strncat(a1, __b, a2);
    strncat(a1, "\r\n", a2);
    v8 = 0;
    a1[a2 - 1] = 0;
    return v8;
  }
  v8 = 2148401153;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v10 = VRTraceErrorLogLevelToCSTR();
    v11 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v12 = *(_DWORD *)(a3 + 4);
      *(_DWORD *)buf = 136316162;
      *(_QWORD *)&buf[4] = v10;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "ConstructSipMsg";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 1271;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 1271;
      *(_WORD *)&buf[34] = 1024;
      *(_DWORD *)&buf[36] = v12;
      _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SipMsg.c:%d: Invalid SIP Message(%d)", buf, 0x28u);
    }
  }
  return v8;
}

uint64_t AssignHeader(uint64_t a1, unsigned int a2, char *__s2)
{
  uint64_t v3;
  uint64_t v6;
  void *v7;
  _QWORD *v8;
  void *v9;
  int *v10;
  int v11;
  int v12;
  uint64_t v13;
  NSObject *v14;
  int v15;
  int v16;
  uint64_t v17;
  const char *v18;
  int v20;
  uint64_t v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  __int16 v28;
  int v29;
  __int16 v30;
  int v31;
  __int16 v32;
  int v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v3 = 2148401186;
  if (!a1)
    return 2148401153;
  v6 = a1 + 8 * a2;
  v9 = *(void **)(v6 + 136);
  v8 = (_QWORD *)(v6 + 136);
  v7 = v9;
  if (v9)
  {
    switch(a2)
    {
      case 0x14u:
        *(_DWORD *)(a1 + 124) = 1;
        break;
      case 0x21u:
        *(_DWORD *)(a1 + 128) = 1;
        break;
      case 0x2Eu:
        v10 = *(int **)(a1 + 504);
        v11 = *v10;
        v12 = *(_DWORD *)__s2;
        if (*(_DWORD *)__s2 + *v10 >= 6)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
          {
            v13 = VRTraceErrorLogLevelToCSTR();
            v14 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              v15 = *v10;
              v16 = *(_DWORD *)__s2;
              v20 = 136316674;
              v21 = v13;
              v22 = 2080;
              v23 = "AssignHeader";
              v24 = 1024;
              v25 = 1418;
              v26 = 1024;
              v27 = 1418;
              v28 = 1024;
              v29 = 5;
              v30 = 1024;
              v31 = v15;
              v32 = 1024;
              v33 = v16;
              _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SipMsg.c:%d: # of Via exceeded the maximum %d < %d+%d", (uint8_t *)&v20, 0x34u);
            }
          }
          if (*v10 >= 6)
            v12 = 0;
          else
            v12 = 5 - *v10;
          *(_DWORD *)__s2 = v12;
          v11 = *v10;
        }
        memcpy(&v10[39 * v11 + 1], __s2 + 4, 156 * v12);
        *v10 += *(_DWORD *)__s2;
        free(__s2);
        return 0;
      default:
        free(v7);
        v3 = 0;
        *v8 = __s2;
        return v3;
    }
    free(__s2);
    return v3;
  }
  *v8 = __s2;
  if (a2 != 13)
    return 0;
  v17 = 0;
  v18 = "identity";
  do
  {
    if (!strcmp(v18, __s2))
      break;
    ++v17;
    v18 += 32;
  }
  while (v17 != 3);
  v3 = 0;
  *(_DWORD *)(a1 + 1008) = v17;
  *(_QWORD *)(a1 + 1016) = SIPDecompressCallback;
  return v3;
}

uint64_t SIPDecompressCallback(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a1 - 3 >= 0xFFFFFFFE)
    return (*((uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))&g_aCompressions + 4 * a1 + 3))(a2, a3, a4, a5);
  else
    return 2148401184;
}

uint64_t UpdateCompressionMethodForMsg(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1008) = a2 != 0;
  return result;
}

uint64_t ParseSipUri(uint64_t a1, char *__s)
{
  char *v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  __int16 v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  const char *v16;
  char *v17;
  char *v18;
  char *v19;
  const char *i;
  int v21;
  uint64_t v23;
  NSObject *v24;
  uint64_t v25;
  uint64_t v27;
  uint8_t buf[4];
  uint64_t v29;
  __int16 v30;
  const char *v31;
  __int16 v32;
  int v33;
  __int16 v34;
  int v35;
  __int16 v36;
  char *v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v4 = strchr(__s, 58);
  if (!v4)
  {
    v13 = 2148139039;
    if ((int)VRTraceGetErrorLogLevelForModule() < 5)
      return v13;
    v14 = VRTraceErrorLogLevelToCSTR();
    v15 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      return v13;
    *(_DWORD *)buf = 136316162;
    v29 = v14;
    v30 = 2080;
    v31 = "ParseSipUri";
    v32 = 1024;
    v33 = 18;
    v34 = 1024;
    v35 = 18;
    v36 = 2080;
    v37 = __s;
    v16 = " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SipUri.c:%d: N"
          "o colon after sip scheme[%s]";
LABEL_46:
    _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, v16, buf, 0x2Cu);
    return v13;
  }
  *v4 = 0;
  v5 = v4 + 1;
  __strlcpy_chk();
  v6 = strchr(v5, 64);
  if (v6)
  {
    *v6 = 0;
    v7 = v6 + 1;
    __strlcpy_chk();
    v5 = v7;
  }
  if (*v5 != 91)
    goto LABEL_7;
  v8 = strchr(v5 + 1, 93);
  if (!v8)
  {
    v13 = 2148139039;
    if ((int)VRTraceGetErrorLogLevelForModule() < 5)
      return v13;
    v27 = VRTraceErrorLogLevelToCSTR();
    v15 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      return v13;
    *(_DWORD *)buf = 136316162;
    v29 = v27;
    v30 = 2080;
    v31 = "ParseSipUri";
    v32 = 1024;
    v33 = 40;
    v34 = 1024;
    v35 = 40;
    v36 = 2080;
    v37 = __s;
    v16 = " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SipUri.c:%d: N"
          "o ']' after '[' for an IPv6 address[%s]";
    goto LABEL_46;
  }
  *v8 = 0;
  v5 = v8 + 1;
  *(_DWORD *)(a1 + 56) = 1;
  __strlcpy_chk();
LABEL_7:
  v9 = strchr(v5, 59);
  v10 = v9;
  if (v9)
    *v9 = 0;
  v11 = strchr(v5, 58);
  if (v11)
  {
    *v11 = 0;
    v12 = atoi(v11 + 1);
  }
  else
  {
    v12 = 5060;
  }
  *(_WORD *)(a1 + 100) = v12;
  if (!*(_DWORD *)(a1 + 56))
    __strlcpy_chk();
  for (*(_DWORD *)(a1 + 108) = 0; v10; *(_DWORD *)(a1 + 108) = v25)
  {
    while (1)
    {
      while (1)
      {
        v17 = v10;
        v18 = v10 + 1;
        v19 = strchr(v10 + 1, 59);
        v10 = v19;
        if (v19)
          *v19 = 0;
        for (i = v17 + 8; ; ++i)
        {
          v21 = *((unsigned __int8 *)i - 7);
          if (v21 != 32 && v21 != 9)
            break;
          ++v18;
        }
        if (strncasecmp(i - 7, "transport=", 0xAuLL))
          break;
        __strlcpy_chk();
        if (!v10)
          return 0;
      }
      if (!strncasecmp(i - 7, "method=", 7uLL))
        break;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5
        && (v23 = VRTraceErrorLogLevelToCSTR(),
            v24 = *MEMORY[0x1E0CF2758],
            os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT)))
      {
        *(_DWORD *)buf = 136316162;
        v29 = v23;
        v30 = 2080;
        v31 = "ParseSipUri";
        v32 = 1024;
        v33 = 95;
        v34 = 1024;
        v35 = 95;
        v36 = 2080;
        v37 = v18;
        _os_log_impl(&dword_1D8A54000, v24, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/SipUri.c:%d: Unknown URI parameter[%s]", buf, 0x2Cu);
        if (!v10)
          return 0;
      }
      else
      {
LABEL_38:
        if (!v10)
          return 0;
      }
    }
    *(_DWORD *)(a1 + 108) = 0;
    v25 = 1;
    while (strcmp(i, g_apszMethods[v25]))
    {
      if (++v25 == 12)
        goto LABEL_38;
    }
  }
  return 0;
}

uint64_t ConstructUri(char *a1, char *a2)
{
  uint64_t v5;
  char __str[8];
  char v7[24];
  char v8[16];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  memset(__str, 170, 7);
  memset(v8, 170, 15);
  memset(v7, 170, 18);
  if (!a2)
    return 2148139009;
  if (*((_WORD *)a2 + 50) == 5060)
    __str[0] = 0;
  else
    snprintf(__str, 7uLL, ":%d", *((unsigned __int16 *)a2 + 50));
  if (!a2[102] || !strcasecmp(a2 + 102, "UDP"))
    v8[0] = 0;
  else
    snprintf(v8, 0xFuLL, ";%s%s", "transport=", a2 + 102);
  v5 = *((unsigned int *)a2 + 27);
  if ((_DWORD)v5)
    snprintf(v7, 0x12uLL, ";%s%s", "method=", g_apszMethods[v5]);
  else
    v7[0] = 0;
  if (*((_DWORD *)a2 + 14) && a2[60])
    snprintf(a1, 0x50uLL, "%s:%s%s[%s]%s%s%s", a2, a2 + 5);
  else
    snprintf(a1, 0x50uLL, "%s:%s%s%s%s%s%s", a2, a2 + 5);
  return 0;
}

BOOL VCTailspinUtil_GenerateTailspin(uint64_t a1, uint64_t a2)
{
  void *v4;
  _BOOL8 v5;

  v4 = (void *)MEMORY[0x1DF088A10]();
  v5 = +[VCTailspinUtil tailspinDumpOutput:reason:](VCTailspinUtil, "tailspinDumpOutput:reason:", a1, objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", a2, 4));
  objc_autoreleasePoolPop(v4);
  return v5;
}

uint64_t VCRateControlCongestionLevel_BitrateRange(unsigned int a1)
{
  int v1;
  int v2;
  unsigned int v3;

  if (a1 < 0x1DBD49)
    v1 = 3;
  else
    v1 = 4;
  if (a1 >= 0x91C09)
    v2 = v1;
  else
    v2 = 2;
  if (a1 >= 0x37AA1)
    v3 = v2;
  else
    v3 = 1;
  if (a1 >= 0x186A1)
    return v3;
  else
    return 0;
}

double VCRateControlCongestionLevel_RampUpTimeFactor(unsigned int a1)
{
  double result;

  result = 3.0;
  if (a1 <= 3)
    return dbl_1D910CD80[a1];
  return result;
}

double VCRateControlCongestionLevel_PopulateCongestionLevelThresholds@<D0>(_OWORD *a1@<X8>)
{
  double result;

  *a1 = xmmword_1D910CCE0;
  a1[1] = xmmword_1D910CD00;
  a1[2] = xmmword_1D910CD10;
  a1[3] = xmmword_1D910CCF0;
  a1[4] = xmmword_1D910CD20;
  a1[5] = xmmword_1D910CD30;
  result = 7.19999981;
  a1[6] = xmmword_1D910CD50;
  a1[7] = xmmword_1D910CD60;
  a1[8] = xmmword_1D910CD40;
  a1[9] = xmmword_1D910CD70;
  return result;
}

void OUTLINED_FUNCTION_0_4(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x22u);
}

uint64_t OUTLINED_FUNCTION_2_4@<X0>(void *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  *(_QWORD *)(v2 - 24) = a2;
  return objc_msgSend(a1, "intValue");
}

uint64_t VCSimpleQueueCreate(unsigned int a1, _QWORD *a2)
{
  _DWORD *v2;
  uint64_t v3;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  void *v10;
  void *v11;

  v2 = 0;
  v3 = 2150694913;
  if (a1 && a2)
  {
    v2 = malloc_type_calloc(1uLL, 0x50uLL, 0x10A0040825AA732uLL);
    if (v2)
    {
      v6 = malloc_type_calloc(a1, 8uLL, 0x100004000313F17uLL);
      *(_QWORD *)v2 = v6;
      if (v6)
      {
        v7 = 0;
        v2[2] = a1;
        v8 = 8 * a1;
        while (1)
        {
          v9 = malloc_type_calloc(1uLL, 0x10uLL, 0x10C004028F705ECuLL);
          if (!v9)
            break;
          *(_QWORD *)(*(_QWORD *)v2 + v7) = v9;
          v7 += 8;
          if (v8 == v7)
          {
            v10 = malloc_type_calloc(1uLL, 0x10uLL, 0x10C004028F705ECuLL);
            *((_QWORD *)v2 + 4) = v10;
            if (v10)
            {
              v11 = malloc_type_calloc(1uLL, 0x10uLL, 0x10C004028F705ECuLL);
              *((_QWORD *)v2 + 5) = v11;
              if (v11)
              {
                v3 = 0;
                *a2 = v2;
                v2 = 0;
                goto LABEL_11;
              }
            }
            break;
          }
        }
      }
    }
    v3 = 2150694915;
  }
LABEL_11:
  VCSimpleQueueDestroy(v2);
  return v3;
}

void VCSimpleQueueDestroy(_QWORD *a1)
{
  void *v2;
  unint64_t v3;
  _QWORD *v4;
  void (*v5)(_QWORD *, _QWORD);
  void *v6;
  void *v7;

  if (a1)
  {
    v2 = (void *)*a1;
    if (v2)
    {
      if (*((_DWORD *)a1 + 2))
      {
        v3 = 0;
        do
        {
          v4 = (_QWORD *)atomic_load((unint64_t *)(*a1 + 8 * v3));
          v5 = (void (*)(_QWORD *, _QWORD))a1[8];
          if (v5 && *v4)
            v5(a1, a1[9]);
          free(v4);
          ++v3;
        }
        while (v3 < *((unsigned int *)a1 + 2));
        v2 = (void *)*a1;
      }
      free(v2);
    }
    v6 = (void *)a1[4];
    if (v6)
      free(v6);
    v7 = (void *)a1[5];
    if (v7)
      free(v7);
    free(a1);
  }
}

uint64_t VCSimpleQueueSetElementEvictedCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = 2150694913;
  if (a1)
  {
    if (a2)
    {
      result = 0;
      *(_QWORD *)(a1 + 48) = a2;
      *(_QWORD *)(a1 + 56) = a3;
    }
  }
  return result;
}

uint64_t VCSimpleQueueSetWillDestroyElementCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = 2150694913;
  if (a1)
  {
    if (a2)
    {
      result = 0;
      *(_QWORD *)(a1 + 64) = a2;
      *(_QWORD *)(a1 + 72) = a3;
    }
  }
  return result;
}

uint64_t VCSimpleQueueEnqueue(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _QWORD *v4;
  unint64_t v5;
  unint64_t *v6;
  _QWORD *v7;
  void (*v8)(uint64_t, _QWORD);

  result = 2150694913;
  if (a1 && a2)
  {
    v4 = *(_QWORD **)(a1 + 40);
    v5 = *(_QWORD *)(a1 + 16);
    *v4 = a2;
    v4[1] = v5;
    v6 = (unint64_t *)(*(_QWORD *)a1 + 8 * (int)(v5 % *(unsigned int *)(a1 + 8)));
    do
      v7 = (_QWORD *)__ldaxr(v6);
    while (__stlxr((unint64_t)v4, v6));
    if (*v7)
    {
      v8 = *(void (**)(uint64_t, _QWORD))(a1 + 48);
      if (v8)
        v8(a1, *(_QWORD *)(a1 + 56));
      *v7 = 0;
    }
    result = 0;
    *(_QWORD *)(a1 + 40) = v7;
    ++*(_QWORD *)(a1 + 16);
  }
  return result;
}

uint64_t VCSimpleQueueDequeue(uint64_t result)
{
  uint64_t v1;
  unint64_t v2;
  unint64_t *v3;
  uint64_t *v4;
  unint64_t v5;
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  uint64_t v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v1 = result;
    v2 = *(_QWORD *)(result + 32);
    v3 = (unint64_t *)(*(_QWORD *)result
                            + 8 * (int)(*(_QWORD *)(result + 24) % (unint64_t)*(unsigned int *)(result + 8)));
    do
      v4 = (uint64_t *)__ldaxr(v3);
    while (__stlxr(v2, v3));
    *(_QWORD *)(result + 32) = v4;
    result = *v4;
    if (*v4)
    {
      v5 = *(_QWORD *)(v1 + 24);
      if (v4[1] > v5)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
        {
          v6 = VRTraceErrorLogLevelToCSTR();
          v7 = *MEMORY[0x1E0CF2758];
          v8 = *MEMORY[0x1E0CF2758];
          if (*MEMORY[0x1E0CF2748])
          {
            if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
            {
              v9 = *(_QWORD *)(v1 + 24);
              v10 = v4[1];
              v13 = 136316418;
              v14 = v6;
              v15 = 2080;
              v16 = "VCSimpleQueueDequeue";
              v17 = 1024;
              v18 = 170;
              v19 = 2048;
              v20 = v9;
              v21 = 2048;
              v22 = v10;
              v23 = 2048;
              v24 = v10 - v9;
              _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCSimpleQueue looped over (dequeued:%llu sequence:%llu). Skipping %llu elements", (uint8_t *)&v13, 0x3Au);
            }
          }
          else if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
          {
            v11 = *(_QWORD *)(v1 + 24);
            v12 = v4[1];
            v13 = 136316418;
            v14 = v6;
            v15 = 2080;
            v16 = "VCSimpleQueueDequeue";
            v17 = 1024;
            v18 = 170;
            v19 = 2048;
            v20 = v11;
            v21 = 2048;
            v22 = v12;
            v23 = 2048;
            v24 = v12 - v11;
            _os_log_debug_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEBUG, " [%s] %s:%d VCSimpleQueue looped over (dequeued:%llu sequence:%llu). Skipping %llu elements", (uint8_t *)&v13, 0x3Au);
          }
        }
        result = *v4;
        v5 = v4[1];
      }
      *v4 = 0;
      *(_QWORD *)(v1 + 24) = v5 + 1;
    }
  }
  return result;
}

uint64_t GetStatusCode(int a1)
{
  uint64_t result;

  result = 0;
  while (g_aiStatusCodes[result] != a1)
  {
    if (++result == 53)
      return 0;
  }
  return result;
}

uint64_t GetIntStatusCode(int a1)
{
  return g_aiStatusCodes[a1];
}

char *GetStatusMsg(int a1)
{
  return g_apszStatusMsgs[a1];
}

uint64_t VCMediaNegotiationBlobV2GeneralInfoReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  int v15;
  char v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char v22;
  uint64_t result;
  void *String;
  char v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  char v30;
  char v31;
  unsigned int v32;
  uint64_t v33;
  unint64_t v34;
  char v35;
  uint64_t v36;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        v14 = v9++ >= 9;
        if (v14)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      switch((v10 >> 3))
      {
        case 1u:
          v17 = 0;
          v18 = 0;
          v19 = 0;
          *(_BYTE *)(a1 + 36) |= 1u;
          while (1)
          {
            v20 = *v3;
            v21 = *(_QWORD *)(a2 + v20);
            if (v21 == -1 || v21 >= *(_QWORD *)(a2 + *v4))
              break;
            v22 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v21);
            *(_QWORD *)(a2 + v20) = v21 + 1;
            v19 |= (unint64_t)(v22 & 0x7F) << v17;
            if ((v22 & 0x80) == 0)
              goto LABEL_44;
            v17 += 7;
            v14 = v18++ >= 9;
            if (v14)
            {
              v19 = 0;
              goto LABEL_46;
            }
          }
          *(_BYTE *)(a2 + *v5) = 1;
LABEL_44:
          if (*(_BYTE *)(a2 + *v5))
            v19 = 0;
LABEL_46:
          *(_QWORD *)(a1 + 8) = v19;
          continue;
        case 2u:
          String = (void *)PBReaderReadString();

          *(_QWORD *)(a1 + 24) = String;
          continue;
        case 3u:
          v25 = 0;
          v26 = 0;
          v27 = 0;
          *(_BYTE *)(a1 + 36) |= 2u;
          while (2)
          {
            v28 = *v3;
            v29 = *(_QWORD *)(a2 + v28);
            if (v29 == -1 || v29 >= *(_QWORD *)(a2 + *v4))
            {
              *(_BYTE *)(a2 + *v5) = 1;
            }
            else
            {
              v30 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v29);
              *(_QWORD *)(a2 + v28) = v29 + 1;
              v27 |= (unint64_t)(v30 & 0x7F) << v25;
              if (v30 < 0)
              {
                v25 += 7;
                v14 = v26++ >= 9;
                if (v14)
                {
                  LODWORD(v27) = 0;
                  goto LABEL_50;
                }
                continue;
              }
            }
            break;
          }
          if (*(_BYTE *)(a2 + *v5))
            LODWORD(v27) = 0;
LABEL_50:
          v36 = 16;
          goto LABEL_55;
        case 4u:
          v31 = 0;
          v32 = 0;
          v27 = 0;
          *(_BYTE *)(a1 + 36) |= 4u;
          break;
        default:
          result = PBReaderSkipValueWithTag();
          if (!(_DWORD)result)
            return result;
          continue;
      }
      while (1)
      {
        v33 = *v3;
        v34 = *(_QWORD *)(a2 + v33);
        if (v34 == -1 || v34 >= *(_QWORD *)(a2 + *v4))
          break;
        v35 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v34);
        *(_QWORD *)(a2 + v33) = v34 + 1;
        v27 |= (unint64_t)(v35 & 0x7F) << v31;
        if ((v35 & 0x80) == 0)
          goto LABEL_52;
        v31 += 7;
        v14 = v32++ >= 9;
        if (v14)
        {
          LODWORD(v27) = 0;
          goto LABEL_54;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_52:
      if (*(_BYTE *)(a2 + *v5))
        LODWORD(v27) = 0;
LABEL_54:
      v36 = 32;
LABEL_55:
      *(_DWORD *)(a1 + v36) = v27;
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

unint64_t GetTickCount()
{
  return (unint64_t)(micro() * 1000000.0) / 0x3E8;
}

uint64_t TACreateHandle(uint64_t *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  char *v14;
  char *v15;
  pthread_mutex_t *v16;
  uint64_t v17;
  uint64_t Handle;
  uint64_t v19;

  v14 = (char *)malloc_type_calloc(1uLL, 0xE0uLL, 0x10A00408696AC64uLL);
  if (v14)
  {
    v15 = v14;
    *((_DWORD *)v14 + 34) = a2;
    v16 = (pthread_mutex_t *)(v14 + 24);
    pthread_mutex_init((pthread_mutex_t *)(v14 + 24), 0);
    pthread_cond_init((pthread_cond_t *)(v15 + 88), 0);
    *((_QWORD *)v15 + 19) = a3;
    *((_QWORD *)v15 + 20) = a5;
    *((_QWORD *)v15 + 21) = a4;
    *((_QWORD *)v15 + 22) = a6;
    *((_DWORD *)v15 + 2) = 1;
    *((_QWORD *)v15 + 23) = 4000;
    *((_QWORD *)v15 + 24) = a7;
    *((_DWORD *)v15 + 50) = -1;
    *((_QWORD *)v15 + 26) = 0;
    v17 = MQCreateHandle((uint64_t *)v15 + 18);
    if ((v17 & 0x80000000) != 0)
    {
      v19 = v17;
      pthread_mutex_destroy(v16);
      pthread_cond_destroy((pthread_cond_t *)(v15 + 88));
      free(v15);
    }
    else
    {
      Handle = CreateHandle();
      *a1 = Handle;
      if (Handle == 0xFFFFFFFFLL)
      {
        pthread_mutex_destroy(v16);
        pthread_cond_destroy((pthread_cond_t *)(v15 + 88));
        MQCloseHandle();
        free(v15);
        return 2148532229;
      }
      else
      {
        return 0;
      }
    }
  }
  else
  {
    v19 = 2148532227;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        TACreateHandle_cold_1();
    }
  }
  return v19;
}

uint64_t TACloseHandle()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  pthread_mutex_t *v3;
  int v4;
  uint64_t v5;
  uint64_t v6;

  v0 = 2148532226;
  v1 = CheckInHandleDebug();
  if (v1)
  {
    v2 = v1;
    v3 = (pthread_mutex_t *)(v1 + 24);
    pthread_mutex_lock((pthread_mutex_t *)(v1 + 24));
    v4 = *(_DWORD *)(v2 + 8);
    *(_DWORD *)(v2 + 8) = v4 - 1;
    pthread_cond_signal((pthread_cond_t *)(v2 + 88));
    pthread_mutex_unlock(v3);
    CheckOutHandleDebug();
    if (v4 > 1)
      return 0;
    v5 = CheckInHandleDebug();
    if (v5)
    {
      v6 = v5;
      CheckOutHandleDebug();
      pthread_cond_destroy((pthread_cond_t *)(v6 + 88));
      pthread_mutex_destroy((pthread_mutex_t *)(v6 + 24));
      FreeSipMsg(*(_QWORD **)(v6 + 168));
      MQCloseHandle();
      free((void *)v6);
      return 0;
    }
  }
  return v0;
}

uint64_t TASend(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  unsigned int *v5;
  pthread_mutex_t *v6;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;

  v3 = 2148532242;
  v4 = CheckInHandleDebug();
  if (!v4)
    return 2148532226;
  v5 = (unsigned int *)v4;
  v6 = (pthread_mutex_t *)(v4 + 24);
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 24));
  v7 = v5[2];
  if (v7 < 2)
  {
    if (v7 == 1)
      v3 = 2148532259;
    if (a2)
      FreeSipMsg(a2);
LABEL_14:
    pthread_mutex_unlock(v6);
    CheckOutHandleDebug();
    return v3;
  }
  if (!a2 || (*(_DWORD *)a2 = 1, v8 = MQPut(*((_QWORD *)v5 + 18), (uint64_t)a2, 0), (v8 & 0x80000000) == 0))
  {
    if (v5[1])
    {
LABEL_8:
      v5[1] = 0;
      v3 = *v5;
    }
    else
    {
      while (1)
      {
        v9 = v5[2];
        if (v9 < 2)
          break;
        pthread_cond_wait((pthread_cond_t *)(v5 + 22), v6);
        if (v5[1])
          goto LABEL_8;
      }
      if (v9 == 1)
        v3 = 2148532259;
      else
        v3 = 2148532242;
    }
    goto LABEL_14;
  }
  v10 = v8;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      TASend_cold_1();
  }
  FreeSipMsg(a2);
  pthread_mutex_unlock(v6);
  CheckOutHandleDebug();
  return v10;
}

uint64_t TACancel()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t Cancel;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  void *v7[2];

  v7[1] = *(void **)MEMORY[0x1E0C80C00];
  v0 = CheckInHandleDebug();
  if (!v0)
    return 2148532226;
  v1 = v0;
  v7[0] = (void *)0xAAAAAAAAAAAAAAAALL;
  Cancel = CreateCancel(v7, 0);
  if ((Cancel & 0x80000000) != 0)
  {
    v5 = Cancel;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        TACancel_cold_1();
    }
  }
  else
  {
    v3 = v7[0];
    *(_DWORD *)v7[0] = 1;
    v4 = MQPut(*(_QWORD *)(v1 + 144), (uint64_t)v3, 0);
    if ((v4 & 0x80000000) != 0)
    {
      v5 = v4;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          TACancel_cold_2();
      }
      FreeSipMsg((_QWORD *)v7[0]);
    }
    else
    {
      pthread_mutex_lock((pthread_mutex_t *)(v1 + 24));
      if (*(int *)(v1 + 8) >= 2)
      {
        do
          pthread_cond_wait((pthread_cond_t *)(v1 + 88), (pthread_mutex_t *)(v1 + 24));
        while (*(int *)(v1 + 8) > 1);
      }
      pthread_mutex_unlock((pthread_mutex_t *)(v1 + 24));
      v5 = 0;
    }
  }
  CheckOutHandleDebug();
  return v5;
}

uint64_t TASetRetransmitTimeoutCap(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2148532226;
  *(_QWORD *)(v3 + 184) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t RTTAdjustedTimeOut(uint64_t a1, uint64_t a2, int a3)
{
  int v4;
  uint64_t v5;
  unsigned int v6;
  BOOL v7;
  __int128 v8;
  uint64_t v9;
  NSObject *v10;
  uint8_t buf[4];
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  char *v19;
  char __str[16];
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  int v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v4 = *(_DWORD *)(a1 + 200);
  v5 = a2;
  if (a3 == 1)
  {
    v6 = 2 * v4;
    v7 = v4 == -1 || v6 >= a2;
    v5 = a2;
    if (!v7)
    {
      if (v6 <= a2 >> 1)
        v5 = a2 >> 1;
      else
        v5 = v6;
    }
  }
  v26 = -1431655766;
  *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v24 = v8;
  v25 = v8;
  v22 = v8;
  v23 = v8;
  *(_OWORD *)__str = v8;
  v21 = v8;
  snprintf(__str, 0x64uLL, "RTTAdjustedTimeOut(%d): %d -> %d (RTT: %d)", a3, a2, v5, v4);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v9 = VRTraceErrorLogLevelToCSTR();
    v10 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      v13 = v9;
      v14 = 2080;
      v15 = "RTTAdjustedTimeOut";
      v16 = 1024;
      v17 = 288;
      v18 = 2080;
      v19 = __str;
      _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TAInviteClientProc:%s", buf, 0x26u);
    }
  }
  if (*(_DWORD *)(a1 + 200) != -1 && *(_QWORD *)(a1 + 208) && VRTraceIsInternalOSInstalled())
    (*(void (**)(_QWORD, uint64_t, char *))(a1 + 208))(*(_QWORD *)(a1 + 192), a1 + 216, __str);
  return v5;
}

uint64_t TAStart(void *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *(__cdecl *v6)(void *);
  __int128 v7;
  pthread_attr_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v2 = 2148532225;
  v3 = CheckInHandleDebug();
  if (!v3)
    return 2148532226;
  v4 = v3;
  v5 = *(int *)(v3 + 136);
  if (v5 < 4)
  {
    v6 = (void *(__cdecl *)(void *))off_1E9E55580[v5];
    *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&v9.__opaque[24] = v7;
    *(_OWORD *)&v9.__opaque[40] = v7;
    *(_OWORD *)&v9.__sig = v7;
    *(_OWORD *)&v9.__opaque[8] = v7;
    pthread_mutex_lock((pthread_mutex_t *)(v3 + 24));
    ++*(_DWORD *)(v4 + 8);
    pthread_mutex_unlock((pthread_mutex_t *)(v4 + 24));
    pthread_attr_init(&v9);
    pthread_attr_setscope(&v9, 1);
    pthread_attr_setdetachstate(&v9, 2);
    v2 = pthread_create((pthread_t *)(v4 + 16), &v9, v6, a1);
    pthread_attr_destroy(&v9);
    if ((_DWORD)v2)
    {
      v2 = v2 | 0xC0100000;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          TAStart_cold_1();
      }
      pthread_mutex_lock((pthread_mutex_t *)(v4 + 24));
      --*(_DWORD *)(v4 + 8);
      pthread_mutex_unlock((pthread_mutex_t *)(v4 + 24));
    }
  }
  CheckOutHandleDebug();
  return v2;
}

uint64_t TAInviteClientProc(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  int v8;
  unint64_t v9;
  float64x2_t v10;
  uint64x2_t v11;
  unint64_t v12;
  unint64_t v13;
  int v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  int v26;
  double v27;
  _QWORD *v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  int v33;
  char *v34;
  uint64_t v35;
  NSObject *v36;
  int Ack;
  uint64_t v38;
  uint64_t v39;
  const char *v40;
  int v41;
  char *v42;
  NSObject *v43;
  BOOL v44;
  int v45;
  int v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  NSObject *v50;
  uint64_t v52;
  double v53;
  int v54;
  void *v55;
  void *v56;
  int v57;
  uint8_t buf[4];
  uint64_t v59;
  __int16 v60;
  const char *v61;
  __int16 v62;
  int v63;
  __int16 v64;
  const char *v65;
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  v57 = -1431655766;
  v55 = (void *)0xAAAAAAAAAAAAAAAALL;
  v56 = (void *)0xAAAAAAAAAAAAAAAALL;
  pthread_setname_np("com.apple.avconference.transaction.inviteclientproc");
  if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      v59 = v2;
      v60 = 2080;
      v61 = "TAInviteClientProc";
      v62 = 1024;
      v63 = 318;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TAInviteClientProc Thread start...", buf, 0x1Cu);
    }
  }
  v4 = CheckInHandleDebug();
  if (v4)
  {
    v5 = v4;
    v6 = partial apply(*(_QWORD *)(v4 + 152), 0, *(_QWORD *)(v4 + 168), (uint64_t)TAMsgCallback, a1);
    if (v6 < 0)
    {
      v8 = v6;
    }
    else
    {
      v7 = TPGetType(*(_QWORD *)(v5 + 152), &v57);
      if (v7 < 0)
      {
        v8 = v7;
      }
      else
      {
        v8 = TPSend(*(_QWORD *)(v5 + 152));
        if ((v8 & 0x80000000) == 0)
        {
          v53 = micro();
          LODWORD(v9) = RTTAdjustedTimeOut(v5, 500, 1);
          v10.f64[0] = micro();
          v10.f64[1] = v53;
          v11 = vcvtq_u64_f64(vmulq_f64(v10, (float64x2_t)vdupq_n_s64(0x412E848000000000uLL)));
          v12 = v11.i64[0] / 0x3E8uLL - v11.i64[1] / 0x3E8uLL;
          if (v12 >> 5 <= 0x270)
          {
            v13 = 0;
            v14 = 0;
            v54 = 0;
            v15 = v11.i64[1] / 0x3E8uLL;
            v9 = (int)v9;
            v16 = 20000;
            while (1)
            {
              v17 = v16 - v12;
              if (v9 >= v17)
                v18 = v17;
              else
                v18 = v9;
              v19 = 2 * v9;
              if (2 * v9 >= 0x3E8)
                v19 = 1000;
              if (v57 == 1)
                v20 = v17;
              else
                v20 = v18;
              if (v57 == 1)
                v21 = v9;
              else
                v21 = v19;
              if (v57 == 1)
                v22 = v13;
              else
                v22 = v17;
              if (v14)
                v23 = v17;
              else
                v23 = v20;
              if (!v14)
              {
                v9 = v21;
                v13 = v22;
              }
              v24 = *(_QWORD **)(*(_QWORD *)(v5 + 168) + 272);
              v25 = v24 ? *v24 : -1;
              v26 = MQGet(*(_QWORD *)(v5 + 144), &v56, v23, 1, v25);
              v8 = v26;
              if ((v26 & 0x80000000) == 0)
                break;
              if (v26 != -2146762729)
                goto LABEL_114;
              if (v14 == 3)
              {
                v8 = 0;
                goto LABEL_114;
              }
              if (v14 || v57 || v23 == v13)
              {
                v8 = -2146762729;
                goto LABEL_114;
              }
              v8 = TPSend(*(_QWORD *)(v5 + 152));
              if (v8 < 0)
                goto LABEL_114;
              v27 = micro();
              v14 = 0;
LABEL_40:
              v12 = (unint64_t)(v27 * 1000000.0) / 0x3E8 - v15;
              if (v12 >= v16)
                goto LABEL_112;
            }
            v28 = v56;
            if (*(_DWORD *)v56 == 1 && *((_DWORD *)v56 + 1) == 1 && *((_DWORD *)v56 + 2) == 5)
            {
              FreeSipMsg(v56);
              goto LABEL_114;
            }
            v29 = *((_DWORD *)v56 + 2);
            if (v14 == 3)
            {
              if ((v29 - 8) <= 0x2C)
              {
                Ack = CreateAck((unint64_t *)&v55, *(_QWORD *)(v5 + 168), (uint64_t)v56);
                if (Ack < 0)
                {
                  v8 = Ack;
                  goto LABEL_114;
                }
                v8 = TPSend(*(_QWORD *)(v5 + 152));
                FreeSipMsg(v55);
                if (v8 < 0)
                  goto LABEL_114;
                v28 = v56;
              }
              FreeSipMsg(v28);
              v14 = 3;
              goto LABEL_91;
            }
            if (v14 == 2)
            {
              if ((v29 - 1) <= 4)
              {
                v38 = *((_QWORD *)v56 + 60);
                v14 = 2;
                if (v38)
                {
                  v39 = *(_QWORD *)(*(_QWORD *)(v5 + 168) + 480);
                  if (v39)
                  {
                    v41 = *(unsigned __int8 *)(v38 + 156);
                    v40 = (const char *)(v38 + 156);
                    if (v41)
                    {
                      v42 = (char *)(v39 + 156);
                      if (strcmp(v40, (const char *)(v39 + 156)))
                      {
                        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
                        {
                          v52 = VRTraceErrorLogLevelToCSTR();
                          v43 = *MEMORY[0x1E0CF2758];
                          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                          {
                            *(_DWORD *)buf = 136315906;
                            v59 = v52;
                            v60 = 2080;
                            v61 = "TAInviteClientProc";
                            v62 = 1024;
                            v63 = 457;
                            v64 = 2080;
                            v65 = v40;
                            _os_log_impl(&dword_1D8A54000, v43, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Save this ToTag: %s", buf, 0x26u);
                          }
                        }
                        strncpy(v42, v40, 0x40uLL);
                        v14 = 2;
                      }
                    }
                  }
                }
                goto LABEL_90;
              }
              if ((v29 - 8) > 0x2C)
              {
                v44 = (v29 & 0xFFFFFFFE) == 6;
                if ((v29 & 0xFFFFFFFE) == 6)
                  v14 = 5;
                else
                  v14 = 2;
                goto LABEL_86;
              }
            }
            else
            {
              if ((v29 - 1) <= 4)
              {
                v30 = *((_QWORD *)v56 + 60);
                if (v30)
                {
                  v31 = *(_QWORD *)(*(_QWORD *)(v5 + 168) + 480);
                  if (v31)
                  {
                    v33 = *(unsigned __int8 *)(v30 + 156);
                    v32 = (const char *)(v30 + 156);
                    if (v33)
                    {
                      v34 = (char *)(v31 + 156);
                      if (strcmp(v32, (const char *)(v31 + 156)))
                      {
                        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
                        {
                          v35 = VRTraceErrorLogLevelToCSTR();
                          v36 = *MEMORY[0x1E0CF2758];
                          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
                          {
                            *(_DWORD *)buf = 136315906;
                            v59 = v35;
                            v60 = 2080;
                            v61 = "TAInviteClientProc";
                            v62 = 1024;
                            v63 = 415;
                            v64 = 2080;
                            v65 = v32;
                            _os_log_impl(&dword_1D8A54000, v36, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Save this ToTag: %s", buf, 0x26u);
                          }
                        }
                        strncpy(v34, v32, 0x40uLL);
                      }
                    }
                  }
                }
                v15 = (unint64_t)(micro() * 1000000.0) / 0x3E8;
                v14 = 2;
                v16 = 8000;
                goto LABEL_90;
              }
              if ((v29 - 8) > 0x2C)
              {
                v44 = (v29 & 0xFFFFFFFE) == 6;
                if ((v29 & 0xFFFFFFFE) == 6)
                  v14 = 5;
                else
                  v14 = 0;
LABEL_86:
                v46 = v54;
                if (v44)
                  v46 = 1;
                v54 = v46;
                goto LABEL_90;
              }
            }
            if ((CreateAck((unint64_t *)&v55, *(_QWORD *)(v5 + 168), (uint64_t)v56) & 0x80000000) != 0
              || (v45 = TPSend(*(_QWORD *)(v5 + 152)), FreeSipMsg(v55), v45 < 0))
            {
              v54 = 1;
              v14 = 5;
            }
            else
            {
              v15 = (unint64_t)(micro() * 1000000.0) / 0x3E8;
              if (v57)
                v16 = 0;
              else
                v16 = 32000;
              v54 = 1;
              v14 = 3;
            }
LABEL_90:
            v8 = (*(uint64_t (**)(_QWORD, void *))(v5 + 176))(*(_QWORD *)(v5 + 192), v56);
LABEL_91:
            if (v14 == 5)
              goto LABEL_114;
            v27 = micro();
            goto LABEL_40;
          }
          v54 = 0;
          v14 = 0;
LABEL_112:
          if (v14 != 3)
            v8 = -2146435049;
LABEL_114:
          TPRemoveTransaction(*(_QWORD *)(v5 + 152), a1);
          if (v54)
            goto LABEL_107;
          goto LABEL_99;
        }
      }
      TPRemoveTransaction(*(_QWORD *)(v5 + 152), a1);
    }
LABEL_99:
    if ((unsigned __int16)v8 == 40)
    {
      v47 = *(_QWORD *)(v5 + 168);
      v48 = 32;
    }
    else if ((unsigned __int16)v8 == 23)
    {
      v47 = *(_QWORD *)(v5 + 168);
      v48 = 21;
    }
    else
    {
      v47 = *(_QWORD *)(v5 + 168);
      if ((v8 & 0x40000000) != 0)
        v48 = 45;
      else
        v48 = 42;
    }
    CreateStatus((unint64_t *)&v56, v47, v48, 0, 0, 0, 0);
    (*(void (**)(_QWORD, void *))(v5 + 176))(*(_QWORD *)(v5 + 192), v56);
LABEL_107:
    CheckOutHandleDebug();
    TACloseHandle();
    if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      v49 = VRTraceErrorLogLevelToCSTR();
      v50 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        v59 = v49;
        v60 = 2080;
        v61 = "TAInviteClientProc";
        v62 = 1024;
        v63 = 552;
        v64 = 1024;
        LODWORD(v65) = v8;
        _os_log_impl(&dword_1D8A54000, v50, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TAInviteClientProc Thread end(%X)...", buf, 0x22u);
      }
    }
    return 0;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      TAInviteClientProc_cold_1();
  }
  return 0;
}

uint64_t TANonInviteClientProc(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  int v8;
  float64x2_t v9;
  uint64x2_t v10;
  unint64_t v11;
  BOOL v12;
  BOOL v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  int v23;
  _DWORD *v24;
  int v25;
  int v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  NSObject *v30;
  int v32;
  double v33;
  int v34;
  void *v35;
  int v36;
  uint8_t buf[4];
  uint64_t v38;
  __int16 v39;
  const char *v40;
  __int16 v41;
  int v42;
  __int16 v43;
  int v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v36 = -1431655766;
  v35 = (void *)0xAAAAAAAAAAAAAAAALL;
  pthread_setname_np("com.apple.avconference.transaction.noninviteclientproc");
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      v38 = v2;
      v39 = 2080;
      v40 = "TANonInviteClientProc";
      v41 = 1024;
      v42 = 571;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TANonInviteClientProc Thread start...", buf, 0x1Cu);
    }
  }
  v4 = CheckInHandleDebug();
  if (v4)
  {
    v5 = v4;
    v6 = partial apply(*(_QWORD *)(v4 + 152), 0, *(_QWORD *)(v4 + 168), (uint64_t)TAMsgCallback, a1);
    if (v6 < 0)
    {
      v8 = v6;
    }
    else
    {
      v7 = TPGetType(*(_QWORD *)(v5 + 152), &v36);
      if (v7 < 0)
      {
        v8 = v7;
      }
      else
      {
        v8 = TPSend(*(_QWORD *)(v5 + 152));
        if ((v8 & 0x80000000) == 0)
        {
          v33 = micro();
          v9.f64[0] = micro();
          v9.f64[1] = v33;
          v10 = vcvtq_u64_f64(vmulq_f64(v9, (float64x2_t)vdupq_n_s64(0x412E848000000000uLL)));
          v11 = v10.i64[0] / 0x3E8uLL - v10.i64[1] / 0x3E8uLL;
          if (v11 >> 8 <= 0x7C)
          {
            v12 = 0;
            v13 = 0;
            v14 = 0;
            v15 = v10.i64[1] / 0x3E8uLL;
            v32 = 1;
            v34 = 0;
            v16 = 32000;
            v17 = 500;
            while (1)
            {
              v18 = v16 - v11;
              if (v13 || v36 == 1)
              {
                v19 = v18;
              }
              else
              {
                v19 = v17 >= v18 ? v18 : v17;
                if (v12)
                {
                  v17 = *(_QWORD *)(v5 + 184);
                }
                else if (2 * v17 >= *(_QWORD *)(v5 + 184))
                {
                  v17 = *(_QWORD *)(v5 + 184);
                }
                else
                {
                  v17 *= 2;
                }
                v14 = v18;
              }
              v20 = *(_QWORD *)(v5 + 168);
              v21 = *(_QWORD **)(v20 + 272);
              v22 = v21 ? *v21 : -1;
              v23 = MQGet(*(_QWORD *)(v5 + 144), &v35, v19, *(_DWORD *)(v20 + 8), v22);
              v8 = v23;
              if ((v23 & 0x80000000) == 0)
                break;
              if (v23 != -2146762729 || v13)
              {
                if (v23 == -2146762729)
                  v8 = 0;
                else
                  v8 = v23;
                goto LABEL_73;
              }
              if (v36 || v19 == v14)
              {
                v8 = -2146762729;
                goto LABEL_73;
              }
              v24 = *(_DWORD **)(*(_QWORD *)(v5 + 168) + 544);
              if (v24)
                *v24 = *v24 == 0;
              v8 = TPSend(*(_QWORD *)(v5 + 152));
              if (v8 < 0)
                goto LABEL_73;
LABEL_31:
              v11 = (unint64_t)(micro() * 1000000.0) / 0x3E8 - v15;
              if (v11 >= v16)
                goto LABEL_71;
            }
            if (*(_DWORD *)v35 == 1 && *((_DWORD *)v35 + 1) == 1 && *((_DWORD *)v35 + 2) == 5)
            {
              FreeSipMsg(v35);
              goto LABEL_73;
            }
            v25 = v32;
            if (v32 != 3)
            {
              v26 = *((_DWORD *)v35 + 2);
              if (v32 == 2)
              {
                v8 = (*(uint64_t (**)(_QWORD))(v5 + 176))(*(_QWORD *)(v5 + 192));
                if (v8 < 0 || (v26 - 6) > 0x2E)
                  goto LABEL_51;
              }
              else
              {
                v8 = (*(uint64_t (**)(_QWORD))(v5 + 176))(*(_QWORD *)(v5 + 192));
                if (v8 < 0)
                  goto LABEL_50;
                if ((v26 - 1) < 5)
                {
                  v25 = 2;
LABEL_51:
                  v13 = v25 == 3;
                  v32 = v25;
                  v12 = v25 == 2;
                  goto LABEL_31;
                }
                if ((v26 - 6) > 0x2E)
                {
LABEL_50:
                  v25 = 1;
                  goto LABEL_51;
                }
              }
              v15 = (unint64_t)(micro() * 1000000.0) / 0x3E8;
              if (v36)
                v16 = 0;
              else
                v16 = 5000;
              v25 = 3;
              v34 = 1;
              goto LABEL_51;
            }
            FreeSipMsg(v35);
            goto LABEL_51;
          }
          v34 = 0;
          v13 = 0;
LABEL_71:
          if (!v13)
            v8 = -2146435049;
LABEL_73:
          TPRemoveTransaction(*(_QWORD *)(v5 + 152), a1);
          if (v34)
            goto LABEL_66;
          goto LABEL_58;
        }
      }
      TPRemoveTransaction(*(_QWORD *)(v5 + 152), a1);
    }
LABEL_58:
    if ((unsigned __int16)v8 == 40)
    {
      v27 = *(_QWORD *)(v5 + 168);
      v28 = 32;
    }
    else if ((unsigned __int16)v8 == 23)
    {
      v27 = *(_QWORD *)(v5 + 168);
      v28 = 21;
    }
    else
    {
      v27 = *(_QWORD *)(v5 + 168);
      if ((v8 & 0x40000000) != 0)
        v28 = 45;
      else
        v28 = 42;
    }
    CreateStatus((unint64_t *)&v35, v27, v28, 0, 0, 0, 0);
    (*(void (**)(_QWORD, void *))(v5 + 176))(*(_QWORD *)(v5 + 192), v35);
LABEL_66:
    CheckOutHandleDebug();
    TACloseHandle();
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v29 = VRTraceErrorLogLevelToCSTR();
      v30 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        v38 = v29;
        v39 = 2080;
        v40 = "TANonInviteClientProc";
        v41 = 1024;
        v42 = 740;
        v43 = 1024;
        v44 = v8;
        _os_log_impl(&dword_1D8A54000, v30, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TANonInviteClientProc Thread end(%X)...", buf, 0x22u);
      }
    }
    return 0;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      TANonInviteClientProc_cold_1();
  }
  return 0;
}

uint64_t TAInviteServerProc(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  int Status;
  unint64_t v9;
  unint64_t v10;
  int v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  BOOL v16;
  unint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  int v20;
  _QWORD *v21;
  int v22;
  int v24;
  uint64_t v26;
  NSObject *v27;
  pthread_mutex_t *v29;
  void *v30;
  void *v31;
  int v32;
  uint8_t buf[4];
  uint64_t v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  int v38;
  __int16 v39;
  int v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v32 = -1431655766;
  v30 = 0;
  v31 = (void *)0xAAAAAAAAAAAAAAAALL;
  pthread_setname_np("com.apple.avconference.transaction.inviteserverproc");
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      v34 = v2;
      v35 = 2080;
      v36 = "TAInviteServerProc";
      v37 = 1024;
      v38 = 759;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TAInviteServerProc Thread start...", buf, 0x1Cu);
    }
  }
  v4 = CheckInHandleDebug();
  if (!v4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        TAInviteServerProc_cold_1();
    }
    return 0;
  }
  v5 = v4;
  v6 = partial apply(*(_QWORD *)(v4 + 152), 1, *(_QWORD *)(v4 + 168), (uint64_t)TAMsgCallback, a1);
  v7 = v6;
  if (v6 < 0)
    goto LABEL_73;
  Status = TPGetType(*(_QWORD *)(v5 + 152), &v32);
  if (Status < 0
    || (Status = CreateStatus((unint64_t *)&v30, *(_QWORD *)(v5 + 168), 1, 0, 0, 0, 0), Status < 0))
  {
    v7 = Status;
    goto LABEL_73;
  }
  v7 = TPSend(*(_QWORD *)(v5 + 152));
  pthread_mutex_lock((pthread_mutex_t *)(v5 + 24));
  *(_DWORD *)v5 = v7;
  *(_DWORD *)(v5 + 4) = 1;
  pthread_cond_signal((pthread_cond_t *)(v5 + 88));
  pthread_mutex_unlock((pthread_mutex_t *)(v5 + 24));
  if (v7 < 0)
    goto LABEL_73;
  v29 = (pthread_mutex_t *)(v5 + 24);
  v9 = 0;
  v10 = (unint64_t)(micro() * 1000000.0) / 0x3E8;
  v11 = 2;
  v12 = 500;
  v13 = 0xFFFFFFFFLL;
  while (1)
  {
    if (v13 == 0xFFFFFFFF)
    {
      v14 = 0xFFFFFFFFLL;
      goto LABEL_24;
    }
    v15 = (unint64_t)(micro() * 1000000.0) / 0x3E8 - v10;
    v16 = v13 >= v15;
    v17 = v13 - v15;
    if (v17 == 0 || !v16)
      break;
    if (v11 != 3 || v32 == 1)
    {
      v14 = v17;
    }
    else
    {
      if (v12 >= v17)
        v14 = v17;
      else
        v14 = v12;
      if (2 * v12 >= *(_QWORD *)(v5 + 184))
        v12 = *(_QWORD *)(v5 + 184);
      else
        v12 *= 2;
      v9 = v17;
    }
LABEL_24:
    v18 = *(uint64_t **)(*(_QWORD *)(v5 + 168) + 272);
    if (v18)
      v19 = *v18;
    else
      v19 = -1;
    v20 = MQGet(*(_QWORD *)(v5 + 144), &v31, v14, 1, v19);
    v7 = v20;
    if (v20 < 0)
    {
      if ((unsigned __int16)v20 != 23 || v11 == 4)
      {
        if ((unsigned __int16)v20 == 23)
          v7 = 0;
        else
          v7 = v20;
        goto LABEL_73;
      }
      if (v11 != 3 || v32 || v14 == v9)
        goto LABEL_73;
      goto LABEL_59;
    }
    v21 = v31;
    if (*(_DWORD *)v31 == 1)
    {
      v22 = *((_DWORD *)v31 + 1);
      if (v22 == 1)
      {
        if (*((_DWORD *)v31 + 2) == 5)
        {
          FreeSipMsg(v31);
          goto LABEL_73;
        }
LABEL_52:
        FreeSipMsg(v21);
      }
      else
      {
        if (v11 != 2 || v22 != 2)
          goto LABEL_52;
        v24 = *((_DWORD *)v31 + 2);
LABEL_63:
        FreeSipMsg(v30);
        v30 = v31;
        v7 = TPSend(*(_QWORD *)(v5 + 152));
        pthread_mutex_lock(v29);
        *(_DWORD *)v5 = v7;
        *(_DWORD *)(v5 + 4) = 1;
        pthread_cond_signal((pthread_cond_t *)(v5 + 88));
        pthread_mutex_unlock(v29);
        if (v7 < 0 || (v24 & 0xFFFFFFFE) == 6)
          goto LABEL_73;
        if ((v24 - 8) > 0x2C)
        {
          v11 = 2;
        }
        else
        {
          v10 = (unint64_t)(micro() * 1000000.0) / 0x3E8;
          v11 = 3;
          v13 = 32000;
        }
      }
    }
    else
    {
      if (v11 == 4 && *(_DWORD *)v31 == 3)
        goto LABEL_52;
      v24 = *((_DWORD *)v31 + 2);
      if (v11 == 2)
      {
        if (*((_DWORD *)v31 + 1) != 1 || v24 != 1)
          goto LABEL_63;
      }
      else
      {
        if (v11 != 3)
          goto LABEL_52;
        if (v24 != 1)
        {
          if (v24 == 2)
          {
            v10 = (unint64_t)(micro() * 1000000.0) / 0x3E8;
            if (v32)
              v13 = 0;
            else
              v13 = 5000;
            v11 = 4;
            v21 = v31;
          }
          else
          {
            v11 = 3;
          }
          goto LABEL_52;
        }
      }
      FreeSipMsg(v31);
LABEL_59:
      v7 = TPSend(*(_QWORD *)(v5 + 152));
      if (v7 < 0)
        goto LABEL_73;
    }
  }
  if (v11 != 4)
    v7 = -2146435049;
LABEL_73:
  if (v30)
    FreeSipMsg(v30);
  if ((v6 & 0x80000000) == 0)
    TPRemoveTransaction(*(_QWORD *)(v5 + 152), a1);
  CheckOutHandleDebug();
  TACloseHandle();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v26 = VRTraceErrorLogLevelToCSTR();
    v27 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      v34 = v26;
      v35 = 2080;
      v36 = "TAInviteServerProc";
      v37 = 1024;
      v38 = 944;
      v39 = 1024;
      v40 = v7;
      _os_log_impl(&dword_1D8A54000, v27, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TAInviteServerProc Thread end(%X)...", buf, 0x22u);
    }
  }
  return 0;
}

uint64_t TANonInviteServerProc(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  _QWORD *v8;
  unint64_t v9;
  int v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  int v17;
  _QWORD *v18;
  int v19;
  _BOOL4 v20;
  int v21;
  uint64_t v23;
  NSObject *v24;
  pthread_cond_t *v26;
  pthread_mutex_t *v27;
  void *v28;
  int v29;
  uint8_t buf[4];
  uint64_t v31;
  __int16 v32;
  const char *v33;
  __int16 v34;
  int v35;
  __int16 v36;
  int v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v29 = -1431655766;
  v28 = (void *)0xAAAAAAAAAAAAAAAALL;
  pthread_setname_np("com.apple.avconference.transaction.noninviteserverproc");
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      v31 = v2;
      v32 = 2080;
      v33 = "TANonInviteServerProc";
      v34 = 1024;
      v35 = 962;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TANonInviteServerProc Thread start...", buf, 0x1Cu);
    }
  }
  v4 = CheckInHandleDebug();
  if (!v4)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        TANonInviteServerProc_cold_1();
    }
    return 0;
  }
  v5 = v4;
  v6 = partial apply(*(_QWORD *)(v4 + 152), 1, *(_QWORD *)(v4 + 168), (uint64_t)TAMsgCallback, a1);
  if (v6 < 0)
  {
    v7 = v6;
    goto LABEL_72;
  }
  v7 = TPGetType(*(_QWORD *)(v5 + 152), &v29);
  if (v7 < 0)
    goto LABEL_71;
  v8 = 0;
  v9 = (unint64_t)(micro() * 1000000.0) / 0x3E8;
  v26 = (pthread_cond_t *)(v5 + 88);
  v27 = (pthread_mutex_t *)(v5 + 24);
  v10 = 1;
  v11 = 0xFFFFFFFFLL;
  while (1)
  {
    v12 = 0xFFFFFFFFLL;
    if (v11 != 0xFFFFFFFF)
    {
      v13 = (unint64_t)(micro() * 1000000.0) / 0x3E8 - v9;
      v12 = v11 - v13;
      if (v11 <= v13)
      {
        if (v10 != 3)
          v7 = -2146435049;
        if (v8)
          goto LABEL_70;
        goto LABEL_71;
      }
    }
    v14 = *(_QWORD *)(v5 + 168);
    v15 = *(_QWORD **)(v14 + 272);
    v16 = v15 ? *v15 : -1;
    v17 = MQGet(*(_QWORD *)(v5 + 144), &v28, v12, *(_DWORD *)(v14 + 8), v16);
    v7 = v17;
    if (v17 < 0)
      break;
    v18 = v28;
    v19 = *(_DWORD *)v28;
    if (*(_DWORD *)v28 == 1)
    {
      if (*((_DWORD *)v28 + 1) == 1 && *((_DWORD *)v28 + 2) == 5)
      {
        FreeSipMsg(v28);
LABEL_69:
        if (!v8)
          goto LABEL_71;
        goto LABEL_70;
      }
      if (v10 == 3)
        goto LABEL_21;
      v20 = 0;
LABEL_22:
      v21 = *((_DWORD *)v28 + 2);
      if (v10 == 2)
      {
        if (v20 && *((_DWORD *)v28 + 1) == 1)
        {
          FreeSipMsg(v28);
          v7 = TPSend(*(_QWORD *)(v5 + 152));
          v10 = 2;
          if (v7 < 0)
            goto LABEL_69;
        }
        else
        {
          FreeSipMsg(v8);
          v8 = v28;
          v7 = TPSend(*(_QWORD *)(v5 + 152));
          pthread_mutex_lock(v27);
          *(_DWORD *)v5 = v7;
          *(_DWORD *)(v5 + 4) = 1;
          pthread_cond_signal(v26);
          pthread_mutex_unlock(v27);
          if (v7 < 0)
            goto LABEL_69;
          if ((v21 - 6) > 0x2E)
          {
            v10 = 2;
          }
          else
          {
            v9 = (unint64_t)(micro() * 1000000.0) / 0x3E8;
            if (v29)
              v11 = 0;
            else
              v11 = 32000;
LABEL_43:
            v10 = 3;
          }
        }
      }
      else if (v10 == 3)
      {
        if (!v20 || *((_DWORD *)v28 + 1) != 1)
        {
          FreeSipMsg(v28);
          goto LABEL_43;
        }
        FreeSipMsg(v28);
        v7 = TPSend(*(_QWORD *)(v5 + 152));
        v10 = 3;
        if (v7 < 0)
          goto LABEL_69;
      }
      else
      {
        if (v8)
        {
          FreeSipMsg(v8);
          v18 = v28;
        }
        v7 = TPSend(*(_QWORD *)(v5 + 152));
        pthread_mutex_lock(v27);
        *(_DWORD *)v5 = v7;
        *(_DWORD *)(v5 + 4) = 1;
        pthread_cond_signal(v26);
        pthread_mutex_unlock(v27);
        if (v7 < 0)
        {
          v8 = v18;
          if (!v18)
            goto LABEL_71;
LABEL_70:
          FreeSipMsg(v8);
          goto LABEL_71;
        }
        if ((v21 - 1) >= 5)
        {
          if ((v21 - 6) > 0x2E)
          {
            v10 = 1;
          }
          else
          {
            v9 = (unint64_t)(micro() * 1000000.0) / 0x3E8;
            if (v29)
              v11 = 0;
            else
              v11 = 32000;
            v10 = 3;
          }
        }
        else
        {
          v10 = 2;
        }
        v8 = v18;
      }
    }
    else
    {
      v20 = v19 == 3;
      if (v10 != 1 || v19 != 3)
        goto LABEL_22;
LABEL_21:
      FreeSipMsg(v28);
    }
  }
  if ((unsigned __int16)v17 == 23 && v10 == 3)
    v7 = 0;
  else
    v7 = v17;
  if (v8)
    goto LABEL_70;
LABEL_71:
  TPRemoveTransaction(*(_QWORD *)(v5 + 152), a1);
LABEL_72:
  CheckOutHandleDebug();
  TACloseHandle();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v23 = VRTraceErrorLogLevelToCSTR();
    v24 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      v31 = v23;
      v32 = 2080;
      v33 = "TANonInviteServerProc";
      v34 = 1024;
      v35 = 1127;
      v36 = 1024;
      v37 = v7;
      _os_log_impl(&dword_1D8A54000, v24, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TANonInviteServerProc Thread end(%X)...", buf, 0x22u);
    }
  }
  return 0;
}

uint64_t TASetRTT(uint64_t a1, int a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  int v11;
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v7 = CheckInHandleDebug();
  if (!v7)
    return 2148532226;
  *(_DWORD *)(v7 + 200) = a2;
  *(_QWORD *)(v7 + 208) = a3;
  *(_DWORD *)(v7 + 216) = *a4;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v8 = VRTraceErrorLogLevelToCSTR();
    v9 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v11 = 136315906;
      v12 = v8;
      v13 = 2080;
      v14 = "TASetRTT";
      v15 = 1024;
      v16 = 1202;
      v17 = 1024;
      v18 = a2;
      _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TASetRTT: %d ms", (uint8_t *)&v11, 0x22u);
    }
  }
  CheckOutHandleDebug();
  return 0;
}

uint64_t TAMsgCallback(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v4;

  v2 = 2148532225;
  if (a2)
  {
    v4 = CheckInHandleDebug();
    if (v4)
    {
      *(_DWORD *)a2 = 3;
      v2 = MQPut(*(_QWORD *)(v4 + 144), (uint64_t)a2, 0);
      if ((v2 & 0x80000000) != 0)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            TAMsgCallback_cold_1();
        }
        FreeSipMsg(a2);
      }
      CheckOutHandleDebug();
    }
    else
    {
      return 2148532226;
    }
  }
  return v2;
}

void _VCVideoReceiverDefault_SetExternalOutputLatency(uint64_t a1, double a2)
{
  if (a1)
  {
    if (*(_QWORD *)(a1 + 1496) != 0xFFFFFFFFLL)
      VideoReceiver_SetExternalOutputLatency(a2);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCVideoReceiverDefault_SetExternalOutputLatency_cold_1();
  }
}

void _VCVideoReceiverDefault_RemoteFrameCallback(uint64_t a1, __CVBuffer *a2, __int128 *a3, uint64_t a4)
{
  __int128 v4;
  uint64_t v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v4 = *a3;
  v5 = *((_QWORD *)a3 + 2);
  VCVideoReceiverDefault_HandleRemoteFrame(a1, a2, (uint64_t)&v4, a4);
}

void _VCVideoReceiverDefault_SampleBufferCallback(uint64_t a1, uint64_t a2)
{
  const void *v4;
  uint64_t v5;

  v4 = (const void *)MEMORY[0x1DF086F1C](a1 + 40);
  (*(void (**)(const void *, uint64_t, BOOL))(a1 + 24))(v4, a2, *(_BYTE *)(a1 + 1536) == 0);
  CFRelease(v4);
  if (!*(_BYTE *)(a1 + 1536))
  {
    *(_BYTE *)(a1 + 1536) = 1;
    v5 = *(_QWORD *)(a1 + 1560);
    if (v5)
      VCVideoStreamRateAdaptationFeedbackOnly_SetDidReceiveVideo(v5, 1);
  }
}

uint64_t streamSwitchCallback(void *a1, const char *a2, uint64_t a3)
{
  return objc_msgSend(a1, "didSwitchFromStreamID:toStreamID:", a2, a3);
}

uint64_t keyFrameGenerationCallback(void *a1, const char *a2, uint64_t a3)
{
  return objc_msgSend(a1, "handleRequestingKeyFrameGenerationWithStreamID:firType:", a2, a3);
}

uint64_t _VCVideoReceiverDefault_ModeSwitchCallback(void *a1, uint64_t a2)
{
  objc_msgSend(a1, "setMode:", a2);
  objc_msgSend(a1, "setUpRemoteAspectRatios");
  return objc_msgSend(a1, "setShouldUpdateRemoteScreenAttributes:", 1);
}

void VCVideoReceiverDefault_HandleRemoteFrame(uint64_t a1, CVPixelBufferRef pixelBuffer, uint64_t a3, uint64_t a4)
{
  __int128 v7;
  int *v8;
  int v10;
  int v11;
  _BOOL4 v12;
  BOOL v13;
  _BOOL4 v14;
  double v15;
  double v16;
  double v17;
  float v19;
  double v20;
  float v21;
  double v22;
  VideoAttributes *v23;
  double v24;
  double v25;
  VideoAttributes *v26;
  double v27;
  size_t v28;
  double v29;
  __int128 v30;
  const void *v31;
  CFTypeRef v32;
  int ErrorLogLevelForModule;
  os_log_t *v34;
  uint64_t v35;
  NSObject *v36;
  uint64_t v37;
  NSObject *v38;
  uint64_t v39;
  uint64_t v40;
  NSObject *v41;
  double v42;
  double v43;
  double v44;
  double v45;
  double v46;
  double v47;
  uint64_t v48;
  const void *v49;
  void (*v50)(const void *, CVPixelBufferRef, _BYTE *, CFTypeRef, VideoAttributes *, _BOOL8);
  _BOOL8 v51;
  const __CFString *v52;
  uint64_t v53;
  NSObject *v54;
  Float64 Seconds;
  const char *v56;
  NSObject *v57;
  uint32_t v58;
  uint64_t v59;
  NSObject *v60;
  Float64 v61;
  uint64_t v62;
  size_t Width;
  size_t Height;
  __int128 v65;
  __int128 v66;
  VideoAttributes *v67;
  CFTypeRef cf;
  uint8_t buf[4];
  uint64_t v70;
  __int16 v71;
  const char *v72;
  __int16 v73;
  int v74;
  __int16 v75;
  _BYTE v76[10];
  double v77;
  __int16 v78;
  CFTypeRef v79;
  _BYTE time[48];
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  uint64_t v86;

  v86 = *MEMORY[0x1E0C80C00];
  v67 = 0;
  cf = 0;
  v7 = *(_OWORD *)(MEMORY[0x1E0C9D648] + 16);
  v65 = *MEMORY[0x1E0C9D648];
  v66 = v7;
  v8 = &OBJC_IVAR___VCRateControlMediaController__isVideoStoppedByVCRateControl;
  if ((a4 & 0x80) == 0)
    goto LABEL_51;
  v10 = a4 & 0x30;
  if (v10 == 16)
    VideoUtil_GetVisibleRectForScreen(pixelBuffer, (double *)&v65);
  else
    VideoUtil_GetVisibleRect(pixelBuffer, (double *)&v65);
  Width = CVPixelBufferGetWidth(pixelBuffer);
  Height = CVPixelBufferGetHeight(pixelBuffer);
  v11 = *(unsigned __int8 *)(a1 + 1576);
  v12 = *(_BYTE *)(a1 + 1576) != 0;
  if (*(_BYTE *)(a1 + 1665))
  {
    v13 = VCMathUtils_DoubleEqualWithAccuracy(*(double *)&v66, *((double *)&v66 + 1), 1.0);
    if (v11)
    {
      if (v13)
        goto LABEL_15;
    }
    else if (!v13)
    {
      v12 = 1;
      goto LABEL_11;
    }
    *(_BYTE *)(a1 + 1665) = 0;
  }
LABEL_11:
  if (v10 == 16 || !v12)
  {
LABEL_15:
    v15 = (double)Width;
    v16 = (double)Height;
    v17 = *((double *)&v66 + 1) / (double)Height;
    if (*(double *)&v66 > (double)Width || *((double *)&v66 + 1) > v16)
    {
      v21 = *(double *)&v66 / v15;
      v19 = v17;
      v20 = *((double *)&v65 + 1);
      if (v21 <= v19)
      {
        v22 = (float)(v21 / v19);
        v17 = 1.0;
        v21 = v19;
      }
      else
      {
        v17 = (float)(v19 / v21);
        v22 = 1.0;
      }
    }
    else
    {
      v20 = *((double *)&v65 + 1);
      v21 = 1.0;
      v22 = *(double *)&v66 / v15;
    }
    v24 = v20 / v16;
    v25 = *(double *)&v65 / v15;
    if (v10 == 16 && *(_BYTE *)(a1 + 1664))
    {
      v25 = 0.0;
      v24 = 0.0;
    }
    v8 = &OBJC_IVAR___VCRateControlMediaController__isVideoStoppedByVCRateControl;
    v26 = [VideoAttributes alloc];
    v27 = (double)CVPixelBufferGetWidth(pixelBuffer);
    v28 = CVPixelBufferGetHeight(pixelBuffer);
    *(float *)&v29 = v21;
    v23 = -[VideoAttributes initWithCameraStatusBits:aspectRatio:contentsRect:scaleFactor:](v26, "initWithCameraStatusBits:aspectRatio:contentsRect:scaleFactor:", a4, v27, (double)v28, v25, v24, v22, v17, v29);
    cf = v23;
    goto LABEL_29;
  }
  if (*(_BYTE *)(a1 + 1536))
  {
    v8 = &OBJC_IVAR___VCRateControlMediaController__isVideoStoppedByVCRateControl;
    v14 = *(_BYTE *)(a1 + 1538) != 0;
  }
  else
  {
    v14 = 1;
    v8 = &OBJC_IVAR___VCRateControlMediaController__isVideoStoppedByVCRateControl;
  }
  VCCallSession_SetUpRemoteAttributes(pixelBuffer, a4, *(_BYTE *)(a1 + 1648) != 0, v14, *(double *)(a1 + 1616), *(double *)(a1 + 1624), *(double *)(a1 + 1632), *(double *)(a1 + 1640), *(double *)(a1 + 1584), *(double *)(a1 + 1592), *(double *)(a1 + 1600), *(double *)(a1 + 1608), *(unsigned __int8 *)(a1 + 1650), *(_QWORD *)(a1 + 1528), (uint64_t *)&cf, &v67);
  v23 = (VideoAttributes *)cf;
LABEL_29:
  if (VCVideoAttributes_IsEqual(*(_QWORD *)(a1 + 1528), (uint64_t)v23))
  {

    cf = 0;
  }
  else
  {
    *(_QWORD *)&v30 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v30 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v84 = v30;
    v85 = v30;
    v82 = v30;
    v83 = v30;
    *(_OWORD *)&time[32] = v30;
    v81 = v30;
    *(_OWORD *)time = v30;
    *(_OWORD *)&time[16] = v30;
    VideoUtil_StringVisibleRect((double *)&v65, time, 0x80uLL);
    v31 = *(const void **)(a1 + 1528);
    if (v31)
      CFRelease(v31);
    v32 = cf;
    if (cf)
      v32 = CFRetain(cf);
    *(_QWORD *)(a1 + 1528) = v32;
    ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    v34 = (os_log_t *)MEMORY[0x1E0CF2758];
    if (ErrorLogLevelForModule >= 7)
    {
      v35 = VRTraceErrorLogLevelToCSTR();
      v36 = *v34;
      if (os_log_type_enabled(*v34, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136316162;
        v70 = v35;
        v71 = 2080;
        v72 = "VCVideoReceiverDefault_HandleRemoteFrame";
        v73 = 1024;
        v74 = 537;
        v75 = 1024;
        *(_DWORD *)v76 = Width;
        *(_WORD *)&v76[4] = 1024;
        *(_DWORD *)&v76[6] = Height;
        _os_log_impl(&dword_1D8A54000, v36, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d [AR_RX] frameWidth=%d, frameHeight=%d", buf, 0x28u);
      }
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v37 = VRTraceErrorLogLevelToCSTR();
      v38 = *v34;
      if (os_log_type_enabled(*v34, OS_LOG_TYPE_DEFAULT))
      {
        v39 = *(_QWORD *)(a1 + 1344);
        *(_DWORD *)buf = 136316418;
        v70 = v37;
        v71 = 2080;
        v72 = "VCVideoReceiverDefault_HandleRemoteFrame";
        v73 = 1024;
        v74 = 538;
        v75 = 2112;
        *(_QWORD *)v76 = v39;
        *(_WORD *)&v76[8] = 2080;
        v77 = COERCE_DOUBLE(time);
        v78 = 2112;
        v79 = cf;
        _os_log_impl(&dword_1D8A54000, v38, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d [AR_RX] participantUUID=%@ visibleRect=%s remoteVideoAttributes=%@ ", buf, 0x3Au);
      }
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v40 = VRTraceErrorLogLevelToCSTR();
      v41 = *v34;
      if (os_log_type_enabled(*v34, OS_LOG_TYPE_DEFAULT))
      {
        v42 = 0.0;
        v43 = 0.0;
        if (*((double *)&v66 + 1) != 0.0)
          v43 = *(double *)&v66 / *((double *)&v66 + 1);
        if (Height)
        {
          objc_msgSend((id)cf, "contentsRect", *((double *)&v66 + 1));
          if (v44 != 0.0)
          {
            objc_msgSend((id)cf, "contentsRect");
            v46 = v45 * (double)Width;
            objc_msgSend((id)cf, "contentsRect");
            v42 = v46 / (v47 * (double)Height);
          }
        }
        *(_DWORD *)buf = 136316162;
        v70 = v40;
        v71 = 2080;
        v72 = "VCVideoReceiverDefault_HandleRemoteFrame";
        v73 = 1024;
        v74 = 541;
        v75 = 2048;
        *(double *)v76 = v43;
        *(_WORD *)&v76[8] = 2048;
        v77 = v42;
        _os_log_impl(&dword_1D8A54000, v41, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d [AR_RX] AspectRatio fromVisibleRect=%.3f, fromContentRect=%.3f", buf, 0x30u);
      }
    }
    v8 = &OBJC_IVAR___VCRateControlMediaController__isVideoStoppedByVCRateControl;
  }
  *(_DWORD *)(a1 + 16) = a4 & 3;
LABEL_51:
  v48 = *(_QWORD *)(a1 + 1672);
  if (v48)
    VCVideoHardwareDumpCollector_RecordDecodedFrame(v48, pixelBuffer, *(void **)(a1 + 1528));
  v49 = (const void *)MEMORY[0x1DF086F1C](a1 + 40);
  v50 = *(void (**)(const void *, CVPixelBufferRef, _BYTE *, CFTypeRef, VideoAttributes *, _BOOL8))(a1 + 32);
  v51 = *(_BYTE *)(a1 + 1536) == 0;
  *(_OWORD *)time = *(_OWORD *)a3;
  *(_QWORD *)&time[16] = *(_QWORD *)(a3 + 16);
  v50(v49, pixelBuffer, time, cf, v67, v51);
  CFRelease(v49);
  if (!*(_BYTE *)(a1 + 1536))
  {
    if (objc_opt_class() == a1)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 7
        || (v53 = VRTraceErrorLogLevelToCSTR(),
            v54 = *MEMORY[0x1E0CF2758],
            !os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT)))
      {
LABEL_65:
        *(_BYTE *)(a1 + 1536) = 1;
        v62 = *(_QWORD *)(a1 + 1560);
        if (v62)
          VCVideoStreamRateAdaptationFeedbackOnly_SetDidReceiveVideo(v62, 1);
        goto LABEL_67;
      }
      *(_OWORD *)time = *(_OWORD *)a3;
      *(_QWORD *)&time[16] = *(_QWORD *)(a3 + 16);
      Seconds = CMTimeGetSeconds((CMTime *)time);
      *(_DWORD *)time = 136315906;
      *(_QWORD *)&time[4] = v53;
      *(_WORD *)&time[12] = 2080;
      *(_QWORD *)&time[14] = "VCVideoReceiverDefault_HandleRemoteFrame";
      *(_WORD *)&time[22] = 1024;
      *(_DWORD *)&time[24] = 559;
      *(_WORD *)&time[28] = 2048;
      *(Float64 *)&time[30] = Seconds;
      v56 = " [%s] %s:%d frameTime=%f";
      v57 = v54;
      v58 = 38;
    }
    else
    {
      if ((objc_opt_respondsToSelector() & 1) != 0)
        v52 = (const __CFString *)objc_msgSend((id)a1, "performSelector:", sel_logPrefix);
      else
        v52 = &stru_1E9E58EE0;
      if ((int)VRTraceGetErrorLogLevelForModule() < 7)
        goto LABEL_65;
      v59 = VRTraceErrorLogLevelToCSTR();
      v60 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        goto LABEL_65;
      *(_OWORD *)time = *(_OWORD *)a3;
      *(_QWORD *)&time[16] = *(_QWORD *)(a3 + 16);
      v61 = CMTimeGetSeconds((CMTime *)time);
      *(_DWORD *)time = 136316418;
      *(_QWORD *)&time[4] = v59;
      *(_WORD *)&time[12] = 2080;
      *(_QWORD *)&time[14] = "VCVideoReceiverDefault_HandleRemoteFrame";
      *(_WORD *)&time[22] = 1024;
      *(_DWORD *)&time[24] = 559;
      *(_WORD *)&time[28] = 2112;
      *(_QWORD *)&time[30] = v52;
      *(_WORD *)&time[38] = 2048;
      *(_QWORD *)&time[40] = a1;
      LOWORD(v81) = 2048;
      *(Float64 *)((char *)&v81 + 2) = v61;
      v56 = " [%s] %s:%d %@(%p) frameTime=%f";
      v57 = v60;
      v58 = 58;
    }
    _os_log_impl(&dword_1D8A54000, v57, OS_LOG_TYPE_DEFAULT, v56, time, v58);
    goto LABEL_65;
  }
LABEL_67:
  *(_BYTE *)(a1 + v8[560]) = 0;

}

uint64_t OUTLINED_FUNCTION_8_14@<X0>(void *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  *(_QWORD *)(v2 - 24) = a2;
  return objc_msgSend(a1, "integerValue");
}

void sub_1D8C8AA60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1D8C8B294(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void OUTLINED_FUNCTION_2_5(uint64_t a1@<X8>)
{
  uint64_t v1;

  *(_QWORD *)(v1 - 8) = a1;
}

uint64_t VCVideoEncoderVTInitialize(uint64_t result)
{
  *(_QWORD *)result = EncoderVT_VTable;
  *(_DWORD *)(result + 8) = 1;
  *(_QWORD *)(result + 16) = 0xFFFFFFFFLL;
  return result;
}

uint64_t EncoderVTCreateHandle(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  _OWORD *v5;
  VTSessionRef *v6;
  VTCompressionSessionRef *v7;
  const __CFAllocator *v8;
  const CFDictionaryKeyCallBacks *v9;
  const CFDictionaryValueCallBacks *v10;
  __CFDictionary *Mutable;
  CFNumberRef v12;
  CFNumberRef v13;
  CFNumberRef v14;
  const __CFDictionary *v15;
  uint64_t v16;
  NSObject *v17;
  const void *v18;
  const void *v19;
  VTCompressionSessionRef v20;
  const __CFString *v21;
  OSStatus v22;
  OSStatus v23;
  uint64_t v24;
  CFNumberRef v25;
  uint64_t Handle;
  __CFArray *v27;
  CFNumberRef v28;
  CFNumberRef v29;
  uint64_t v31;
  NSObject *log;
  int32_t valuePtr;
  uint8_t buf[4];
  uint64_t v35;
  __int16 v36;
  const char *v37;
  __int16 v38;
  int v39;
  __int16 v40;
  uint64_t v41;
  __int16 v42;
  OSStatus v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v3 = 2148007937;
  if (*(_DWORD *)a2 && *(_DWORD *)(a2 + 4))
  {
    v5 = malloc_type_calloc(1uLL, 0x18uLL, 0xA0040114AFA65uLL);
    if (!v5)
      return 2148007939;
    v6 = (VTSessionRef *)v5;
    *v5 = *(_OWORD *)(a2 + 104);
    v7 = (VTCompressionSessionRef *)(v5 + 1);
    v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v9 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
    v10 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    valuePtr = *(_DWORD *)a2;
    v12 = CFNumberCreate(v8, kCFNumberIntType, &valuePtr);
    CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0CA90E0], v12);
    CFRelease(v12);
    valuePtr = *(_DWORD *)(a2 + 4);
    v13 = CFNumberCreate(v8, kCFNumberIntType, &valuePtr);
    CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0CA8FD8], v13);
    CFRelease(v13);
    valuePtr = 875704438;
    v14 = CFNumberCreate(v8, kCFNumberIntType, &valuePtr);
    CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0CA9040], v14);
    CFRelease(v14);
    v15 = CFDictionaryCreateMutable(v8, 2, v9, v10);
    v3 = VTCompressionSessionCreate(0, *(_DWORD *)a2, *(_DWORD *)(a2 + 4), 0x61766331u, v15, Mutable, 0, *(VTCompressionOutputCallback *)(a2 + 104), *(void **)(a2 + 112), v7);
    if ((_DWORD)v3)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          EncoderVTCreateHandle_cold_4();
      }
LABEL_29:
      if (v15)
        CFRelease(v15);
      if (Mutable)
        CFRelease(Mutable);
      if (*v7)
      {
        VTCompressionSessionInvalidate(*v7);
        CFRelease(*v7);
      }
      free(v6);
      return v3;
    }
    v18 = (const void *)*MEMORY[0x1E0C9AE50];
    VTSessionSetProperty(*v7, (CFStringRef)*MEMORY[0x1E0CED1A0], (CFTypeRef)*MEMORY[0x1E0C9AE50]);
    VTSessionSetProperty(*v7, (CFStringRef)*MEMORY[0x1E0CED000], (CFTypeRef)*MEMORY[0x1E0CED678]);
    VTSessionSetProperty(*v7, (CFStringRef)*MEMORY[0x1E0CECEB0], (CFTypeRef)*MEMORY[0x1E0C9AE40]);
    v19 = *(const void **)(a2 + 136);
    v20 = *v7;
    v21 = (const __CFString *)*MEMORY[0x1E0CED180];
    if (v19)
    {
      v22 = VTSessionSetProperty(v20, v21, v19);
      if (v22)
      {
        v23 = v22;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v31 = VRTraceErrorLogLevelToCSTR();
          log = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            v24 = *(_QWORD *)(a2 + 136);
            *(_DWORD *)buf = 136316162;
            v35 = v31;
            v36 = 2080;
            v37 = "EncoderVTCreateHandle";
            v38 = 1024;
            v39 = 121;
            v40 = 2112;
            v41 = v24;
            v42 = 1024;
            v43 = v23;
            _os_log_error_impl(&dword_1D8A54000, log, OS_LOG_TYPE_ERROR, " [%s] %s:%d Failed to set profile level property to %@ with error status=%d", buf, 0x2Cu);
          }
        }
      }
    }
    else
    {
      VTSessionSetProperty(v20, v21, (CFTypeRef)*MEMORY[0x1E0CED980]);
    }
    VTSessionSetProperty(v6[2], (CFStringRef)*MEMORY[0x1E0CECEC8], v18);
    valuePtr = *(_DWORD *)(a2 + 8);
    v25 = CFNumberCreate(v8, kCFNumberIntType, &valuePtr);
    VTSessionSetProperty(v6[2], (CFStringRef)*MEMORY[0x1E0CED0B0], v25);
    CFRelease(v25);
    Handle = CreateHandle();
    *a1 = Handle;
    if (Handle == 0xFFFFFFFFLL)
      goto LABEL_29;
    v27 = CFArrayCreateMutable(v8, 0, MEMORY[0x1E0C9B378]);
    if (v27)
    {
      v28 = CFNumberCreate(v8, kCFNumberIntType, (const void *)(a2 + 32));
      if (v28)
      {
        v29 = v28;
        CFArrayAppendValue(v27, v28);
        EncoderVTSetBitRate(*a1, v27);
        if (!v15)
        {
LABEL_23:
          if (Mutable)
            CFRelease(Mutable);
          if (v29)
            CFRelease(v29);
          if (v27)
            CFRelease(v27);
          return v3;
        }
LABEL_22:
        CFRelease(v15);
        goto LABEL_23;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          EncoderVTCreateHandle_cold_3();
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        EncoderVTCreateHandle_cold_2();
    }
    v29 = 0;
    if (!v15)
      goto LABEL_23;
    goto LABEL_22;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v16 = VRTraceErrorLogLevelToCSTR();
    v17 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      EncoderVTCreateHandle_cold_1(v16, (int *)a2, v17);
  }
  return v3;
}

uint64_t EncoderVTCloseHandle()
{
  uint64_t v0;
  _QWORD *v1;
  OpaqueVTCompressionSession *v2;
  const void *v3;

  v0 = CheckInHandleDebug();
  if (!v0)
    return 2148007938;
  v1 = (_QWORD *)v0;
  CheckOutHandleDebug();
  v2 = (OpaqueVTCompressionSession *)v1[2];
  if (v2)
  {
    VTCompressionSessionInvalidate(v2);
    v3 = (const void *)v1[2];
    if (v3)
      CFRelease(v3);
  }
  free(v1);
  return 0;
}

uint64_t EncoderVTSetThermalLevel()
{
  uint64_t v0;
  NSObject *v1;
  int v3;
  uint64_t v4;
  __int16 v5;
  const char *v6;
  __int16 v7;
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v0 = VRTraceErrorLogLevelToCSTR();
    v1 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v3 = 136315650;
      v4 = v0;
      v5 = 2080;
      v6 = "EncoderVTSetThermalLevel";
      v7 = 1024;
      v8 = 192;
      _os_log_impl(&dword_1D8A54000, v1, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d not implemented!", (uint8_t *)&v3, 0x1Cu);
    }
  }
  return 0;
}

uint64_t EncoderVTSetBitRate(int a1, CFArrayRef theArray)
{
  uint64_t v2;
  const __CFNumber *ValueAtIndex;
  const __CFNumber *v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  NSObject *v9;
  __CFArray *Mutable;
  const __CFAllocator *v11;
  CFNumberRef v12;
  CFNumberRef v13;
  int v15;
  int v16;
  int valuePtr;
  uint8_t buf[4];
  uint64_t v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  __int16 v28;
  uint64_t v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v2 = 2148007938;
  valuePtr = 0;
  if (!theArray)
    return 2148007937;
  ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(theArray, 0);
  if (!ValueAtIndex)
    return 2148007937;
  v4 = ValueAtIndex;
  CFNumberGetValue(ValueAtIndex, kCFNumberIntType, &valuePtr);
  v5 = CheckInHandleDebug();
  if (v5)
  {
    v6 = v5;
    v7 = valuePtr / 8;
    v15 = 1065353216;
    v16 = valuePtr / 8;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v8 = VRTraceErrorLogLevelToCSTR();
      v9 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136316418;
        v19 = v8;
        v20 = 2080;
        v21 = "EncoderVTSetBitRate";
        v22 = 1024;
        v23 = 217;
        v24 = 1024;
        v25 = valuePtr;
        v26 = 1024;
        v27 = v7;
        v28 = 2048;
        v29 = 0x3FF0000000000000;
        _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d bitrateBps:%d, dataSizeBytes:%d, duration:%f", buf, 0x32u);
      }
    }
    if (VTSessionSetProperty(*(VTSessionRef *)(v6 + 16), (CFStringRef)*MEMORY[0x1E0CECEF0], v4))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          EncoderVTSetBitRate_cold_3();
      }
    }
    Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v12 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &v16);
    CFArrayAppendValue(Mutable, v12);
    CFRelease(v12);
    v13 = CFNumberCreate(v11, kCFNumberFloat32Type, &v15);
    CFArrayAppendValue(Mutable, v13);
    CFRelease(v13);
    if (VTSessionSetProperty(*(VTSessionRef *)(v6 + 16), (CFStringRef)*MEMORY[0x1E0CECF78], Mutable))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          EncoderVTSetBitRate_cold_2();
      }
    }
    CFRelease(Mutable);
    CheckOutHandleDebug();
    return 0;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      EncoderVTSetBitRate_cold_1();
  }
  return v2;
}

uint64_t EncoderVTEncodeFrame(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  OpaqueVTCompressionSession *v4;
  __CVBuffer *v5;
  const __CFDictionary *v6;
  uint64_t v7;
  CMTime v9;
  CMTime presentationTimeStamp;
  VTEncodeInfoFlags infoFlagsOut;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  infoFlagsOut = 0;
  v3 = (_QWORD *)CheckInHandleDebug();
  if (v3)
  {
    if (*v3)
    {
      v4 = (OpaqueVTCompressionSession *)v3[2];
      if (v4)
      {
        v5 = *(__CVBuffer **)(a2 + 88);
        v6 = *(const __CFDictionary **)(a2 + 320);
        presentationTimeStamp = *(CMTime *)(a2 + 292);
        v9 = *(CMTime *)*(_QWORD *)&MEMORY[0x1E0CA2E18];
        v7 = VTCompressionSessionEncodeFrame(v4, v5, &presentationTimeStamp, &v9, v6, (void *)a2, &infoFlagsOut);
        if ((_DWORD)v7)
        {
          if ((_DWORD)v7 == -12912)
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                EncoderVTEncodeFrame_cold_5();
            }
            v7 = 4294954384;
          }
          else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              EncoderVTEncodeFrame_cold_4();
          }
        }
      }
      else
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            EncoderVTEncodeFrame_cold_3();
        }
        v7 = 0;
      }
    }
    else
    {
      v7 = 2148007957;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          EncoderVTEncodeFrame_cold_2();
          v7 = 2148007957;
        }
      }
    }
    CheckOutHandleDebug();
  }
  else
  {
    v7 = 2148007938;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        EncoderVTEncodeFrame_cold_1();
    }
  }
  return v7;
}

uint64_t EncoderVTGenerateKeyFrame()
{
  uint64_t v0;
  NSObject *v1;
  int v3;
  uint64_t v4;
  __int16 v5;
  const char *v6;
  __int16 v7;
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v0 = VRTraceErrorLogLevelToCSTR();
    v1 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v3 = 136315650;
      v4 = v0;
      v5 = 2080;
      v6 = "EncoderVTGenerateKeyFrame";
      v7 = 1024;
      v8 = 285;
      _os_log_impl(&dword_1D8A54000, v1, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d not implemented!", (uint8_t *)&v3, 0x1Cu);
    }
  }
  return 0;
}

uint64_t EncoderVTSendImgDesc()
{
  uint64_t v0;
  NSObject *v1;
  int v3;
  uint64_t v4;
  __int16 v5;
  const char *v6;
  __int16 v7;
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v0 = VRTraceErrorLogLevelToCSTR();
    v1 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v3 = 136315650;
      v4 = v0;
      v5 = 2080;
      v6 = "EncoderVTSendImgDesc";
      v7 = 1024;
      v8 = 290;
      _os_log_impl(&dword_1D8A54000, v1, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d not implemented!", (uint8_t *)&v3, 0x1Cu);
    }
  }
  return 0;
}

uint64_t EncoderVTPixelBufferFromPool()
{
  uint64_t v0;
  NSObject *v1;
  int v3;
  uint64_t v4;
  __int16 v5;
  const char *v6;
  __int16 v7;
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v0 = VRTraceErrorLogLevelToCSTR();
    v1 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v3 = 136315650;
      v4 = v0;
      v5 = 2080;
      v6 = "EncoderVTPixelBufferFromPool";
      v7 = 1024;
      v8 = 295;
      _os_log_impl(&dword_1D8A54000, v1, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d not implemented!", (uint8_t *)&v3, 0x1Cu);
    }
  }
  return 0;
}

uint64_t EncoderVTSetEncodingMode()
{
  uint64_t v0;
  NSObject *v1;
  int v3;
  uint64_t v4;
  __int16 v5;
  const char *v6;
  __int16 v7;
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v0 = VRTraceErrorLogLevelToCSTR();
    v1 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v3 = 136315650;
      v4 = v0;
      v5 = 2080;
      v6 = "EncoderVTSetEncodingMode";
      v7 = 1024;
      v8 = 300;
      _os_log_impl(&dword_1D8A54000, v1, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d not implemented!", (uint8_t *)&v3, 0x1Cu);
    }
  }
  return 0;
}

uint64_t VCConnectionManager_CopyPrimaryConnection(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a1)
    return (*(uint64_t (**)(void))(a1 + 40))();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136315650;
      v5 = v2;
      v6 = 2080;
      v7 = "VCConnectionManager_CopyPrimaryConnection";
      v8 = 1024;
      v9 = 197;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v4, 0x1Cu);
    }
  }
  return 0;
}

void VCConnectionManager_SetPrimaryConnection(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  int v3;
  uint64_t v4;
  __int16 v5;
  const char *v6;
  __int16 v7;
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    (*(void (**)(void))(a1 + 48))();
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v1 = VRTraceErrorLogLevelToCSTR();
    v2 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v3 = 136315650;
      v4 = v1;
      v5 = 2080;
      v6 = "VCConnectionManager_SetPrimaryConnection";
      v7 = 1024;
      v8 = 205;
      _os_log_impl(&dword_1D8A54000, v2, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v3, 0x1Cu);
    }
  }
}

void VCConnectionManager_UseCellPrimaryInterface(uint64_t a1, int a2)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    _classVTable(a1, a2);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136315650;
      v5 = v2;
      v6 = 2080;
      v7 = "VCConnectionManager_UseCellPrimaryInterface";
      v8 = 1024;
      v9 = 2652;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v4, 0x1Cu);
    }
  }
}

void VCConnectionManager_UpdateConnectionForDuplication(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  int v3;
  uint64_t v4;
  __int16 v5;
  const char *v6;
  __int16 v7;
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    (*(void (**)(void))(a1 + 16))();
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v1 = VRTraceErrorLogLevelToCSTR();
    v2 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v3 = 136315650;
      v4 = v1;
      v5 = 2080;
      v6 = "VCConnectionManager_UpdateConnectionForDuplication";
      v7 = 1024;
      v8 = 3125;
      _os_log_impl(&dword_1D8A54000, v2, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v3, 0x1Cu);
    }
  }
}

uint64_t _VCConnectionManager_SetOverlayLinkDetails(uint64_t result, uint64_t a2, int a3, char a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;

  if (result && a2)
  {
    v5 = result;
    if (a3)
    {
      *(_BYTE *)(result + 3467) = a4;
      v6 = 3470;
      v7 = 3469;
      v8 = 3468;
    }
    else
    {
      v6 = 3466;
      v7 = 3465;
      v8 = 3464;
    }
    *(_BYTE *)(result + v8) = VCConnection_IsLocalOnCellular(a2);
    *(_BYTE *)(v5 + v7) = VCConnection_IsRemoteOnCellular(a2);
    *(_BYTE *)(v5 + v6) = VCConnection_IsRelay(a2);
    result = *(_QWORD *)(v5 + 3456);
    if (result)
    {
      v9 = *(_QWORD *)(result + 40);
      if (v9)
      {
        v10 = *(unsigned int *)(v5 + 3464) | ((unint64_t)(*(unsigned __int16 *)(v5 + 3468) | (*(unsigned __int8 *)(v5 + 3470) << 16)) << 32);
        *(_DWORD *)(v9 + 8) = *(_DWORD *)(v5 + 3464);
        *(_BYTE *)(v9 + 14) = BYTE6(v10);
        *(_WORD *)(v9 + 12) = WORD2(v10);
        return VCOverlaySource_Write(result);
      }
    }
  }
  return result;
}

void VCConnectionManager_AddTelemetryForConnection(uint64_t a1, uint64_t a2, void *a3)
{
  void *v5;
  void *v6;
  uint64_t v7;
  NSObject *v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    objc_msgSend(a3, "setObject:forKeyedSubscript:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedChar:", VCConnection_GetDataMode(a2)), CFSTR("connectionDataMode"));
    if (VCConnection_IsLocalOnCellular(a2))
    {
      objc_msgSend(a3, "setObject:forKeyedSubscript:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", VCConnection_LocalCellTech(a2)), CFSTR("LCTCH"));
      objc_msgSend(a3, "setObject:forKeyedSubscript:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", VCConnection_IsLocalExpensive(a2)), CFSTR("LXPNSV"));
    }
    if (VCConnection_IsRemoteOnCellular(a2))
    {
      objc_msgSend(a3, "setObject:forKeyedSubscript:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", VCConnection_RemoteCellTech(a2)), CFSTR("RCTCH"));
      v5 = (void *)objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", VCConnection_IsRemoteExpensive(a2));
      v6 = a3;
    }
    else
    {
      objc_msgSend(a3, "setObject:forKeyedSubscript:", &unk_1E9EF5030, CFSTR("RCTCH"));
      v6 = a3;
      v5 = &unk_1E9EF5030;
    }
    objc_msgSend(v6, "setObject:forKeyedSubscript:", v5, CFSTR("RXPNSV"));
    objc_msgSend(a3, "setObject:forKeyedSubscript:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", VCConnection_ReportingIPVersion(a2)), CFSTR("IPVER"));
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v7 = VRTraceErrorLogLevelToCSTR();
    v8 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315650;
      v10 = v7;
      v11 = 2080;
      v12 = "VCConnectionManager_AddTelemetryForConnection";
      v13 = 1024;
      v14 = 752;
      _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil manager passed", (uint8_t *)&v9, 0x1Cu);
    }
  }
}

uint64_t VCConnectionManager_ConnectionInterfaceType(uint64_t a1, int a2)
{
  __CFString *v3;

  if (a2)
  {
    if ((VCConnection_IsLocalOnWiFiOrWired(a1) & 1) != 0)
    {
      if (VCConnection_IsLocalOnWired(a1))
      {
LABEL_4:
        v3 = CFSTR("Wired");
        return -[__CFString UTF8String](v3, "UTF8String");
      }
LABEL_7:
      v3 = CFSTR("NonCellular");
      return -[__CFString UTF8String](v3, "UTF8String");
    }
    VCConnection_IsLocalOnCellular(a1);
    VCConnection_LocalCellTech(a1);
  }
  else
  {
    if ((VCConnection_IsRemoteOnWiFiOrWired(a1) & 1) != 0)
    {
      if (VCConnection_IsRemoteOnWired(a1))
        goto LABEL_4;
      goto LABEL_7;
    }
    VCConnection_IsRemoteOnCellular(a1);
    VCConnection_RemoteCellTech(a1);
  }
  return CelltechToStr();
}

void VCConnectionManager_AddDuplicationSelectionLogicTelemetryForConnection(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  void *v7;
  const char *v8;
  void *v9;
  const char *v10;
  void *v11;
  const char *v12;
  uint64_t v13;
  NSObject *v14;
  int v15;
  uint64_t v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a2)
    {
      v7 = (void *)MEMORY[0x1E0CB3940];
      if (VCConnection_IsRelay(a2))
        v8 = "relay";
      else
        v8 = "p2p";
      objc_msgSend(a4, "setObject:forKeyedSubscript:", objc_msgSend(v7, "stringWithUTF8String:", v8), CFSTR("ConnectionType"));
      objc_msgSend(a4, "setObject:forKeyedSubscript:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", VCConnectionManager_ConnectionInterfaceType(a2, 1)), CFSTR("LocalInterfaceType"));
      objc_msgSend(a4, "setObject:forKeyedSubscript:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", VCConnectionManager_ConnectionInterfaceType(a2, 0)), CFSTR("RemoteInterfaceType"));
      v9 = (void *)MEMORY[0x1E0CB3940];
      if (VCConnection_IsIPv6(a2))
        v10 = "IPv6";
      else
        v10 = "IPv4";
      objc_msgSend(a4, "setObject:forKeyedSubscript:", objc_msgSend(v9, "stringWithUTF8String:", v10), CFSTR("ConnFmly"));
      v11 = (void *)MEMORY[0x1E0CB3940];
      if (VCConnection_IsEndToEndLink(a2))
        v12 = "1";
      else
        v12 = "0";
      objc_msgSend(a4, "setObject:forKeyedSubscript:", objc_msgSend(v11, "stringWithUTF8String:", v12), CFSTR("EndToEnd"));
      if (a3)
        objc_msgSend(a4, "setObject:forKeyedSubscript:", a3, CFSTR("SLTS"));
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v13 = VRTraceErrorLogLevelToCSTR();
    v14 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v15 = 136315650;
      v16 = v13;
      v17 = 2080;
      v18 = "VCConnectionManager_AddDuplicationSelectionLogicTelemetryForConnection";
      v19 = 1024;
      v20 = 790;
      _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil manager passed", (uint8_t *)&v15, 0x1Cu);
    }
  }
}

void VCConnectionManager_AddTelemetryForPacketHistory(uint64_t a1, uint64_t a2)
{
  pthread_rwlock_t *v4;
  uint64_t v5;
  NSObject *v6;
  int v7;
  uint64_t v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  int v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v4 = (pthread_rwlock_t *)(a1 + 96);
    pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 96));
    objc_msgSend(*(id *)(a1 + 2904), "addConnectionBasedTopPacketCountsTelemetry:reportingKey:mapLinkIDToLinkUUID:isOutgoing:", a2, CFSTR("ULPH"), *(_QWORD *)(a1 + 2912), 1);
    objc_msgSend(*(id *)(a1 + 2904), "addConnectionBasedTopPacketCountsTelemetry:reportingKey:mapLinkIDToLinkUUID:isOutgoing:", a2, CFSTR("DLPH"), *(_QWORD *)(a1 + 2912), 0);
    pthread_rwlock_unlock(v4);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v5 = VRTraceErrorLogLevelToCSTR();
    v6 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v7 = 136315650;
      v8 = v5;
      v9 = 2080;
      v10 = "VCConnectionManager_AddTelemetryForPacketHistory";
      v11 = 1024;
      v12 = 811;
      _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil manager passed", (uint8_t *)&v7, 0x1Cu);
    }
  }
}

void VCConnectionManager_AddTelemetryForPacketHistoryInternal(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  int v6;
  uint64_t v7;
  __int16 v8;
  const char *v9;
  __int16 v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    objc_msgSend(*(id *)(a1 + 2904), "addConnectionBasedTopPacketCountsTelemetry:reportingKey:mapLinkIDToLinkUUID:isOutgoing:", a2, CFSTR("ULPH"), *(_QWORD *)(a1 + 2912), 1);
    objc_msgSend(*(id *)(a1 + 2904), "addConnectionBasedTopPacketCountsTelemetry:reportingKey:mapLinkIDToLinkUUID:isOutgoing:", a2, CFSTR("DLPH"), *(_QWORD *)(a1 + 2912), 0);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v6 = 136315650;
      v7 = v4;
      v8 = 2080;
      v9 = "VCConnectionManager_AddTelemetryForPacketHistoryInternal";
      v10 = 1024;
      v11 = 822;
      _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil manager passed", (uint8_t *)&v6, 0x1Cu);
    }
  }
}

void VCConnectionManager_AddLinkProbingTelemetry(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  int v3;
  uint64_t v4;
  __int16 v5;
  const char *v6;
  __int16 v7;
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    (*(void (**)(void))(a1 + 72))();
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v1 = VRTraceErrorLogLevelToCSTR();
    v2 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v3 = 136315650;
      v4 = v1;
      v5 = 2080;
      v6 = "VCConnectionManager_AddLinkProbingTelemetry";
      v7 = 1024;
      v8 = 837;
      _os_log_impl(&dword_1D8A54000, v2, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v3, 0x1Cu);
    }
  }
}

void VCConnectionManager_SetDuplicationEnabledInternal(uint64_t a1, int a2)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    off_1ED10CD58(a1, a2);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136315650;
      v5 = v2;
      v6 = 2080;
      v7 = "VCConnectionManager_SetDuplicationEnabledInternal";
      v8 = 1024;
      v9 = 845;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v4, 0x1Cu);
    }
  }
}

void VCConnectionManager_SetPreWarmState(uint64_t a1, int a2)
{
  uint64_t v3;
  NSObject *v4;
  int v5;
  const char *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint8_t buf[4];
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  const char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (*(unsigned __int8 *)(a1 + 493) != a2)
    {
      *(_BYTE *)(a1 + 493) = a2;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v3 = VRTraceErrorLogLevelToCSTR();
        v4 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v5 = *(unsigned __int8 *)(a1 + 493);
          v6 = "not";
          v7 = "Start";
          *(_DWORD *)buf = 136316418;
          v11 = v3;
          v13 = "VCConnectionManager_SetPreWarmState";
          v12 = 2080;
          if (v5)
            v6 = "";
          v14 = 1024;
          if (!v5)
            v7 = "Stop";
          v15 = 964;
          v16 = 1024;
          v17 = v5;
          v18 = 2080;
          v19 = v6;
          v20 = 2080;
          v21 = v7;
          _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d HandoverReport: set _isPreWarmStateEnabled state to %d. Do %s duplicate the RTCP packets. %s active probing on links", buf, 0x36u);
        }
      }
      pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 96));
      VCConnectionManager_SetActiveLinkProbingEnabled(a1, *(unsigned __int8 *)(a1 + 493));
      VCConnectionManager_AlertStateUpdated((_QWORD *)a1, *(unsigned __int8 *)(a1 + 493), 1);
      pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 96));
      v9 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", *(unsigned __int8 *)(a1 + 493), CFSTR("WRMLocAlrtUpdate"));
      objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v9, &v8, 1);
      reportingGenericEvent();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCConnectionManager_SetPreWarmState_cold_1();
  }
}

void VCConnectionManager_SetActiveLinkProbingEnabled(uint64_t a1, int a2)
{
  id v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t i;
  uint64_t v10;
  _BYTE v11[128];
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v4 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
    v12 = 0u;
    v13 = 0u;
    v14 = 0u;
    v15 = 0u;
    v5 = *(void **)(a1 + 328);
    v6 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v12, v11, 16);
    if (v6)
    {
      v7 = v6;
      v8 = *(_QWORD *)v13;
      do
      {
        for (i = 0; i != v7; ++i)
        {
          if (*(_QWORD *)v13 != v8)
            objc_enumerationMutation(v5);
          v10 = *(_QWORD *)(*((_QWORD *)&v12 + 1) + 8 * i);
          if (VCConnectionManager_IsDuplicationConnectionCandidate(a1, v10))
            objc_msgSend(v4, "addObject:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", VCConnection_ConnectionID(v10)));
        }
        v7 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v12, v11, 16);
      }
      while (v7);
    }
    if (a2)
    {
      objc_msgSend(*(id *)(a1 + 768), "startActiveProbingOnLinks:", v4);
    }
    else if (!*(_BYTE *)(a1 + 493)
           && !*(_BYTE *)(a1 + 494)
           && !VCDuplicationHandler_IsDuplicationEnabled(*(_QWORD *)(a1 + 624)))
    {
      objc_msgSend(*(id *)(a1 + 768), "stopActiveProbingOnLinks:resetStats:", v4, 1);
    }

  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCConnectionManager_SetActiveLinkProbingEnabled_cold_1();
  }
}

void VCConnectionManager_AlertStateUpdated(_QWORD *a1, int a2, int a3)
{
  _BYTE *v4;
  uint64_t v5;
  uint64_t v6;
  int v7;

  if (a1)
  {
    v4 = (_BYTE *)a1[78];
    v5 = 0x1000000000000;
    if (!a3)
      v5 = 0;
    v6 = 12;
    if (a2)
      v6 = 0x10000000000000CLL;
    if ((VCDuplicationHandler_HandleDuplicationStateUpdateEvent(v4, v6 | v5, 0) & 1) != 0)
    {
      v7 = objc_msgSend(a1, "isDuplicationEnabled");
      off_1ED10CD58((uint64_t)a1, v7);
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCConnectionManager_AlertStateUpdated_cold_1();
  }
}

uint64_t VCConnectionManager_ProcessWRMNotification(uint64_t a1, _DWORD *a2)
{
  int v3;
  int v4;
  double v5;
  int v6;
  uint64_t v7;
  uint64_t v8;

  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCConnectionManager_ProcessWRMNotification_cold_1();
    }
    return 1;
  }
  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCConnectionManager_ProcessWRMNotification_cold_2();
    }
    return 1;
  }
  v3 = VCWRMHandler_ProcessLocalWRMNotification(*(_QWORD *)(a1 + 616), a2, *(unsigned __int8 *)(a1 + 672));
  if (!v3)
    return 2150170625;
  if (v3 != 1)
  {
    v4 = off_1ED10CD68(a1, 1, 1);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 96));
    v5 = micro();
    v6 = objc_msgSend(*(id *)(a1 + 616), "localWRMLinkTypeSuggestion");
    v7 = 256;
    if (!v4)
      v7 = 0;
    v8 = 4;
    if (v6 == 1)
      v8 = 5;
    if (_VCConnectionManager_ProcessDuplicationStateUpdateEvent(a1, v8 | v7, 0, 0, ((v5 - *(double *)(a1 + 520)) * 1000.0), v4 ^ 1u, 1) >> 32 == 2)VCWRMHandler_UpdateWRMNotificationRequestTime(*(_QWORD *)(a1 + 616), v5);
    pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 96));
  }
  return 0;
}

uint64_t VCConnectionManager_SetWRMNotification(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  NSObject *v4;
  int v5;
  uint64_t v6;
  __int16 v7;
  const char *v8;
  __int16 v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (a1)
    return off_1ED10CD60(a1, a2);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v3 = VRTraceErrorLogLevelToCSTR();
    v4 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v5 = 136315650;
      v6 = v3;
      v7 = 2080;
      v8 = "VCConnectionManager_SetWRMNotification";
      v9 = 1024;
      v10 = 1098;
      _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v5, 0x1Cu);
    }
  }
  return 1;
}

uint64_t VCConnectionManager_IsInterfaceOnCellularForActiveConnectionWithQuality(uint64_t a1, int a2, int a3)
{
  uint64_t v4;
  NSObject *v5;
  int v6;
  uint64_t v7;
  __int16 v8;
  const char *v9;
  __int16 v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (a1)
    return off_1ED10CD68(a1, a2, a3);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v6 = 136315650;
      v7 = v4;
      v8 = 2080;
      v9 = "VCConnectionManager_IsInterfaceOnCellularForActiveConnectionWithQuality";
      v10 = 1024;
      v11 = 1227;
      _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v6, 0x1Cu);
    }
  }
  return 0;
}

unint64_t _VCConnectionManager_ProcessDuplicationStateUpdateEvent(uint64_t a1, uint64_t a2, uint64_t a3, char a4, int a5, int a6, char a7)
{
  unint64_t updated;
  int v13;
  char v14;
  int v15;
  NSObject *v16;
  _QWORD block[5];
  char v19;
  int v20;
  __int16 v21;
  char v22;
  int v23;
  int v24;
  int v25;
  char v26;
  char v27;
  char v28;
  char v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  updated = VCDuplicationHandler_HandleDuplicationStateUpdateEvent(*(_BYTE **)(a1 + 624), a2, a3);
  v13 = objc_msgSend((id)a1, "isDuplicationEnabled");
  v14 = objc_msgSend(*(id *)(a1 + 624), "isDuplicationPending");
  v15 = objc_msgSend(*(id *)(a1 + 616), "localWRMLinkTypeSuggestion");
  if ((updated & 1) != 0)
  {
    VCConnectionManager_SetDuplicationEnabledInternal(a1, v13);
    *(_OWORD *)(a1 + 400) = 0u;
    *(_OWORD *)(a1 + 416) = 0u;
    *(_OWORD *)(a1 + 368) = 0u;
    *(_OWORD *)(a1 + 384) = 0u;
    *(_OWORD *)(a1 + 352) = 0u;
  }
  v16 = *(NSObject **)(a1 + 472);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___VCConnectionManager_ProcessDuplicationStateUpdateEvent_block_invoke;
  block[3] = &unk_1E9E556E0;
  block[4] = a1;
  v19 = updated;
  v22 = HIBYTE(updated);
  v21 = HIDWORD(updated) >> 8;
  v20 = updated >> 8;
  v26 = v13;
  v27 = v14;
  v23 = v15;
  v24 = a6;
  v28 = a7;
  v29 = a4;
  v25 = a5;
  dispatch_async(v16, block);
  return updated;
}

uint64_t VCConnectionManager_GetNumberOfConnectionsInternal(uint64_t (**a1)(void))
{
  const void *v2;
  _BOOL4 v3;
  unsigned int v4;
  uint64_t result;

  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      result = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR);
      if (!(_DWORD)result)
        return result;
      VCConnectionManager_GetNumberOfConnectionsInternal_cold_1();
    }
    return 0;
  }
  v2 = (const void *)a1[5]();
  v3 = v2 != 0;
  if (v2)
  {
    CFRelease(v2);
    v4 = 2;
  }
  else
  {
    v4 = 1;
  }
  if (objc_msgSend(a1, "secondaryConnection"))
    return v4;
  else
    return v3;
}

uint64_t VCConnectionManager_CopyConnectionForQuality(uint64_t a1, int a2)
{
  pthread_rwlock_t *v4;
  uint64_t v5;

  if (a1)
  {
    v4 = (pthread_rwlock_t *)(a1 + 96);
    pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 96));
    v5 = _VCConnectionManager_CopyConnectionForQualityInternal((void *)a1, a2);
    pthread_rwlock_unlock(v4);
    return v5;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCConnectionManager_CopyConnectionForQuality_cold_1();
    }
    return 0;
  }
}

void VCConnectionManager_UpdateTransmittedPacketsAndBytes(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, uint64_t a6, uint64_t a7)
{
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  int v17;
  uint64_t v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    _VCConnectionManager_UpdateCellularExcessiveBytes(a1, a2, a3, a4, 1);
    if (*(_DWORD *)a2 == 4)
    {
      v14 = *(unsigned __int8 *)(a2 + 12);
      if (a5)
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 56))(a1, v14, a3, a6, a7, 1);
      if (a4)
        (*(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 64))(a1, v14, 1);
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v15 = VRTraceErrorLogLevelToCSTR();
    v16 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v17 = 136315650;
      v18 = v15;
      v19 = 2080;
      v20 = "VCConnectionManager_UpdateTransmittedPacketsAndBytes";
      v21 = 1024;
      v22 = 1302;
      _os_log_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v17, 0x1Cu);
    }
  }
}

uint64_t _VCConnectionManager_UpdateCellularExcessiveBytes(uint64_t a1, uint64_t a2, int a3, int a4, int a5)
{
  pthread_rwlock_t *v10;
  const void *v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  BOOL v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  int v24;
  __int16 v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v26 = 0;
  v10 = (pthread_rwlock_t *)(a1 + 96);
  if (pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 96)))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCConnectionManager_UpdateCellularExcessiveBytes_cold_1();
    }
  }
  VCConnectionManager_IsSourceOnCellularIPv6(a1, a2, (uint64_t)&v26 + 1, (uint64_t)&v26);
  v11 = (const void *)VCConnectionManager_CopyPrimaryConnection(a1);
  if ((VCConnection_MatchesSourceDestinationInfo((uint64_t)v11, a2) & 1) != 0 || !HIBYTE(v26))
  {
    if (v11)
      CFRelease(v11);
    pthread_rwlock_unlock(v10);
    if (a5)
      goto LABEL_21;
LABEL_30:
    v23 = HIBYTE(v26);
    v24 = v26;
    pthread_rwlock_wrlock(v10);
    if (v24)
      v18 = 48;
    else
      v18 = 28;
    v19 = v23 == 0;
    v20 = 408;
    v21 = 424;
    goto LABEL_34;
  }
  if (v11)
    CFRelease(v11);
  pthread_rwlock_unlock(v10);
  v12 = v26;
  pthread_rwlock_wrlock(v10);
  if (v12)
    v13 = 48;
  else
    v13 = 28;
  v14 = v13 + a3;
  if (!a5)
  {
    v22 = 376;
    if (a4)
      v22 = 360;
    *(_QWORD *)(a1 + v22) += v14;
    if (!VCNetworkAgentCell_CellularAssertionActive())
      *(_QWORD *)(a1 + 392) += v14;
    pthread_rwlock_unlock(v10);
    goto LABEL_30;
  }
  v15 = 368;
  if (a4)
    v15 = 352;
  *(_QWORD *)(a1 + v15) += v14;
  if (!VCNetworkAgentCell_CellularAssertionActive())
    *(_QWORD *)(a1 + 384) += v14;
  pthread_rwlock_unlock(v10);
LABEL_21:
  v16 = HIBYTE(v26);
  v17 = v26;
  pthread_rwlock_wrlock(v10);
  if (v17)
    v18 = 48;
  else
    v18 = 28;
  v19 = v16 == 0;
  v20 = 400;
  v21 = 416;
LABEL_34:
  if (v19)
    v20 = v21;
  *(_QWORD *)(a1 + v20) += v18 + a3;
  return pthread_rwlock_unlock(v10);
}

void VCConnectionManager_UpdateReceivedPacketsAndBytes(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, uint64_t a6, uint64_t a7)
{
  uint64_t v14;
  uint64_t v15;
  const void *v16;
  const __CFString *v17;
  const char *v18;
  const __CFAllocator *v19;
  CFStringRef v20;
  const char *v21;
  CFStringRef v22;
  CFStringRef v23;
  BOOL v24;
  CFDictionaryRef v25;
  CFDictionaryRef v26;
  uint64_t v27;
  NSObject *v28;
  uint64_t v29;
  NSObject *v30;
  int v31;
  uint64_t v32;
  __int16 v33;
  const char *v34;
  __int16 v35;
  int v36;
  __int16 v37;
  CFStringRef v38;
  __int16 v39;
  CFStringRef v40;
  void *values[3];
  void *keys[2];
  const __CFString *v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    _VCConnectionManager_UpdateCellularExcessiveBytes(a1, a2, a3, a4, 0);
    if (*(_DWORD *)a2 == 4)
    {
      v14 = *(unsigned __int8 *)(a2 + 12);
      if (a5)
        (*(void (**)(uint64_t, _QWORD, uint64_t, uint64_t, uint64_t, _QWORD))(a1 + 56))(a1, *(unsigned __int8 *)(a2 + 12), a3, a6, a7, 0);
      if (a4)
        (*(void (**)(uint64_t, uint64_t, _QWORD))(a1 + 64))(a1, v14, 0);
    }
    v15 = (*(uint64_t (**)(uint64_t))(a1 + 40))(a1);
    v16 = (const void *)v15;
    if (*(_QWORD *)(a1 + 3096) == v15 || !VCConnection_MatchesSourceDestinationInfo(v15, a2))
      goto LABEL_22;
    *(_QWORD *)(a1 + 3096) = v16;
    if (VCConnection_IsRelay((uint64_t)v16))
      v17 = CFSTR("relay");
    else
      v17 = CFSTR("p2p");
    *(_OWORD *)keys = xmmword_1E9E55700;
    v43 = CFSTR("RemoteInterfaceType");
    v18 = (const char *)VCConnectionManager_ConnectionInterfaceType(*(_QWORD *)(a1 + 3096), 1);
    v19 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v20 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v18, 0x8000100u);
    v21 = (const char *)VCConnectionManager_ConnectionInterfaceType(*(_QWORD *)(a1 + 3096), 0);
    v22 = CFStringCreateWithCString(v19, v21, 0x8000100u);
    v23 = v22;
    values[0] = (void *)v17;
    values[1] = (void *)v20;
    values[2] = (void *)v22;
    if (v20)
      v24 = v22 == 0;
    else
      v24 = 1;
    if (v24)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        v29 = VRTraceErrorLogLevelToCSTR();
        v30 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        {
          v31 = 136316162;
          v32 = v29;
          v33 = 2080;
          v34 = "_VCConnectionManager_ReportLocalRemoteInterfaces";
          v35 = 1024;
          v36 = 1335;
          v37 = 2048;
          v38 = v20;
          v39 = 2048;
          v40 = v23;
          _os_log_error_impl(&dword_1D8A54000, v30, OS_LOG_TYPE_ERROR, " [%s] %s:%d Failed to allocate localInterfaceType=%p or remoteInterfaceType=%p", (uint8_t *)&v31, 0x30u);
        }
      }
      v25 = 0;
      v26 = 0;
      if (!v20)
        goto LABEL_18;
    }
    else
    {
      v25 = CFDictionaryCreate(v19, (const void **)keys, (const void **)values, 3, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      reportingGenericEvent();
    }
    CFRelease(v20);
    v26 = v25;
LABEL_18:
    if (v23)
      CFRelease(v23);
    if (v26)
      CFRelease(v26);
LABEL_22:
    if (v16)
      CFRelease(v16);
    return;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v27 = VRTraceErrorLogLevelToCSTR();
    v28 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v31 = 136315650;
      v32 = v27;
      v33 = 2080;
      v34 = "VCConnectionManager_UpdateReceivedPacketsAndBytes";
      v35 = 1024;
      v36 = 1347;
      _os_log_impl(&dword_1D8A54000, v28, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v31, 0x1Cu);
    }
  }
}

void VCConnectionManager_SynchronizeParticipantGenerationCounter(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  int v3;
  uint64_t v4;
  __int16 v5;
  const char *v6;
  __int16 v7;
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    (*(void (**)(void))(a1 + 24))();
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v1 = VRTraceErrorLogLevelToCSTR();
    v2 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v3 = 136315650;
      v4 = v1;
      v5 = 2080;
      v6 = "VCConnectionManager_SynchronizeParticipantGenerationCounter";
      v7 = 1024;
      v8 = 1387;
      _os_log_impl(&dword_1D8A54000, v2, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v3, 0x1Cu);
    }
  }
}

CFStringRef VCConnectionManager_CopySuggestedLinkTypeCombo(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;
  NSObject *v5;
  uint8_t buf[4];
  uint64_t v7;
  __int16 v8;
  const char *v9;
  __int16 v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (*(_BYTE *)(a1 + 491))
      v1 = 67;
    else
      v1 = 87;
    if (*(_BYTE *)(a1 + 490))
      v2 = 67;
    else
      v2 = 87;
    return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%c:%c"), v2, v1);
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v4 = VRTraceErrorLogLevelToCSTR();
      v5 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        v7 = v4;
        v8 = 2080;
        v9 = "VCConnectionManager_CopySuggestedLinkTypeCombo";
        v10 = 1024;
        v11 = 1686;
        _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", buf, 0x1Cu);
      }
    }
    return 0;
  }
}

void _VCConnectionManagerNWConnectionStatisticsCallback(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  CFTypeRef v19;
  const void *v20;
  uint64_t IsLocalOnWiFi;
  _OWORD v22[12];
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (!*(_BYTE *)(a1 + 2929))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v4 = VRTraceErrorLogLevelToCSTR();
        v5 = *MEMORY[0x1E0CF2758];
        v6 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
          {
            v7 = *(_QWORD *)(a2 + 8);
            LODWORD(v22[0]) = 136315906;
            *(_QWORD *)((char *)v22 + 4) = v4;
            WORD6(v22[0]) = 2080;
            *(_QWORD *)((char *)v22 + 14) = "_VCConnectionManagerNWConnectionStatisticsCallback";
            WORD3(v22[1]) = 1024;
            DWORD2(v22[1]) = 1731;
            WORD6(v22[1]) = 2048;
            *(_QWORD *)((char *)&v22[1] + 14) = v7;
            _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d VCNWConnectionNotification timestamp=%llu", (uint8_t *)v22, 0x26u);
          }
        }
        else if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
        {
          _VCConnectionManagerNWConnectionStatisticsCallback_cold_2(v4, a2, v5);
        }
      }
      v23 = 0;
      memset(v22, 0, sizeof(v22));
      *((_QWORD *)&v22[0] + 1) = micro();
      LODWORD(v22[0]) = 11;
      v8 = *(_OWORD *)(a2 + 80);
      *(_OWORD *)((char *)&v22[7] + 8) = *(_OWORD *)(a2 + 96);
      v9 = *(_OWORD *)(a2 + 128);
      *(_OWORD *)((char *)&v22[8] + 8) = *(_OWORD *)(a2 + 112);
      *(_OWORD *)((char *)&v22[9] + 8) = v9;
      *((_QWORD *)&v22[10] + 1) = *(_QWORD *)(a2 + 144);
      v10 = *(_OWORD *)(a2 + 16);
      *(_OWORD *)((char *)&v22[3] + 8) = *(_OWORD *)(a2 + 32);
      v11 = *(_OWORD *)(a2 + 64);
      *(_OWORD *)((char *)&v22[4] + 8) = *(_OWORD *)(a2 + 48);
      *(_OWORD *)((char *)&v22[5] + 8) = v11;
      *(_OWORD *)((char *)&v22[6] + 8) = v8;
      *(_OWORD *)((char *)&v22[1] + 8) = *(_OWORD *)a2;
      v12 = *(_OWORD *)a2;
      *(_OWORD *)((char *)&v22[2] + 8) = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(a1 + 2960) = v10;
      *(_OWORD *)(a1 + 2944) = v12;
      v13 = *(_OWORD *)(a2 + 32);
      v14 = *(_OWORD *)(a2 + 48);
      v15 = *(_OWORD *)(a2 + 64);
      *(_OWORD *)(a1 + 3024) = *(_OWORD *)(a2 + 80);
      *(_OWORD *)(a1 + 3008) = v15;
      *(_OWORD *)(a1 + 2992) = v14;
      *(_OWORD *)(a1 + 2976) = v13;
      v16 = *(_OWORD *)(a2 + 96);
      v17 = *(_OWORD *)(a2 + 112);
      v18 = *(_OWORD *)(a2 + 128);
      *(_QWORD *)(a1 + 3088) = *(_QWORD *)(a2 + 144);
      *(_OWORD *)(a1 + 3072) = v18;
      *(_OWORD *)(a1 + 3056) = v17;
      *(_OWORD *)(a1 + 3040) = v16;
      AVCStatisticsCollector_SetVCStatistics(*(_QWORD *)(a1 + 2920), (uint64_t)v22);
      VCNetworkConditionMonitor_SetWiFiChannelQualityScore(*(_QWORD *)(a1 + 808), SBYTE4(v22[6]));
      if (objc_msgSend((id)a1, "useMediaDrivenDuplication"))
      {
        v19 = VCConnectionSelector_CopyPrimaryConnection(*(_QWORD *)(a1 + 632));
        v20 = v19;
        if (*(_BYTE *)(a2 + 65) == 1 && !*(_BYTE *)(a2 + 84))
        {
          IsLocalOnWiFi = 0;
          if (!v19)
          {
LABEL_17:
            if ((_DWORD)IsLocalOnWiFi && (objc_msgSend(*(id *)(a1 + 624), "allowDuplication") & 1) == 0)
            {
              *(_BYTE *)(a1 + 3144) = 1;
              if (*(double *)(a1 + 664) != 0.0)
                *(double *)(a1 + 664) = micro();
            }
            objc_msgSend(*(id *)(a1 + 624), "setAllowDuplication:", IsLocalOnWiFi);
            return;
          }
        }
        else
        {
          IsLocalOnWiFi = VCConnection_IsLocalOnWiFi((uint64_t)v19);
          if (!v20)
            goto LABEL_17;
        }
        CFRelease(v20);
        goto LABEL_17;
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      _VCConnectionManagerNWConnectionStatisticsCallback_cold_1();
  }
}

void VCConnectionManager_DidUpdateNetworkCondition(uint64_t a1, char a2, char a3, char a4)
{
  NSObject *v4;
  _QWORD block[5];
  char v6;
  char v7;
  char v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v4 = *(NSObject **)(a1 + 440);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = __VCConnectionManager_DidUpdateNetworkCondition_block_invoke;
    block[3] = &unk_1E9E55668;
    v6 = a2;
    v7 = a3;
    v8 = a4;
    block[4] = a1;
    dispatch_async(v4, block);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCConnectionManager_DidUpdateNetworkCondition_cold_1();
  }
}

void _VCConnectionManager_ChecklocalRATTypeOverrideDefaultValue(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  _BOOL4 v5;
  int ErrorLogLevelForModule;
  uint64_t v7;
  NSObject *v8;
  const char *v9;
  NSObject *v10;
  uint32_t v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  NSObject *v15;
  _QWORD v16[6];
  uint8_t buf[4];
  uint64_t v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  const char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (!a2)
    return;
  v3 = -[VCDefaults localRATTypeOverride](+[VCDefaults sharedInstance](VCDefaults, "sharedInstance"), "localRATTypeOverride");
  if (*(_DWORD *)(a1 + 748) == (_DWORD)v3)
    return;
  v4 = v3;
  *(_DWORD *)(a1 + 748) = v3;
  v5 = VCConnectionIDSIsCellularRATType(v3);
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (v5)
  {
    if (ErrorLogLevelForModule < 7)
      goto LABEL_11;
    v7 = VRTraceErrorLogLevelToCSTR();
    v8 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      goto LABEL_11;
    *(_DWORD *)buf = 136315906;
    v18 = v7;
    v19 = 2080;
    v20 = "_VCConnectionManager_ChecklocalRATTypeOverrideDefaultValue";
    v21 = 1024;
    v22 = 2349;
    v23 = 2080;
    v24 = VCConnectionIDSRATTypeToStr(v4);
    v9 = " [%s] %s:%d HandoverReport: Defaults settings force local cell tech enabled to be %s";
    v10 = v8;
    v11 = 38;
  }
  else
  {
    if (ErrorLogLevelForModule < 7)
      goto LABEL_11;
    v12 = VRTraceErrorLogLevelToCSTR();
    v13 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      goto LABEL_11;
    *(_DWORD *)buf = 136315650;
    v18 = v12;
    v19 = 2080;
    v20 = "_VCConnectionManager_ChecklocalRATTypeOverrideDefaultValue";
    v21 = 1024;
    v22 = 2351;
    v9 = " [%s] %s:%d HandoverReport: Defaults settings force local cell tech disabled";
    v10 = v13;
    v11 = 28;
  }
  _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, v9, buf, v11);
LABEL_11:
  if ((_DWORD)v4 == -1 || !VCConnectionIDSIsCellularRATType(v4))
    v14 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", *(unsigned int *)(a1 + 756));
  else
    v14 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v4);
  v15 = *(NSObject **)(a1 + 440);
  v16[0] = MEMORY[0x1E0C809B0];
  v16[1] = 3221225472;
  v16[2] = ___VCConnectionManager_ChecklocalRATTypeOverrideDefaultValue_block_invoke;
  v16[3] = &unk_1E9E52238;
  v16[4] = a1;
  v16[5] = v14;
  dispatch_async(v15, v16);
}

uint64_t _VCConnectionManager_CopyConnectionForQualityInternal(void *a1, int a2)
{
  const void *v3;
  const void *v4;

  if (a2 == 1)
  {
    if (objc_msgSend(a1, "isDuplicationEnabled"))
    {
      v4 = (const void *)(objc_msgSend(a1, "connectionForDuplication")
                        ? objc_msgSend(a1, "connectionForDuplication")
                        : objc_msgSend(a1, "secondaryConnection"));
      v3 = v4;
      if (v4)
      {
        CFRetain(v4);
        return (uint64_t)v3;
      }
    }
  }
  else if (a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCConnectionManager_CopyConnectionForQualityInternal_cold_1();
    }
    return 0;
  }
  return VCConnectionManager_CopyPrimaryConnection((uint64_t)a1);
}

void sub_1D8C956F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

_BYTE *VCConnectionManager_CreatePacketRoutingInfoList(uint64_t a1, unsigned __int8 *a2, const __CFAllocator *a3)
{
  double v6;
  int v7;
  int v8;
  int v9;
  int IntValueForKey;
  int v11;
  uint64_t v12;
  int v13;
  int ShouldRequestWRMNotificationWithDuplicationReason;
  uint64_t v15;
  NSObject *v16;
  NSObject *v17;
  double v18;
  NSObject *v19;
  uint64_t v20;
  CFTypeRef v21;
  _BYTE *PacketRoutingInfoListForConnection;
  const void *v23;
  const __CFString *v24;
  uint64_t v25;
  NSObject *v26;
  const char *v27;
  NSObject *v28;
  uint32_t v29;
  uint64_t v30;
  NSObject *v31;
  int v32;
  int v33;
  uint64_t v34;
  _BYTE *v35;
  _BYTE *v36;
  uint64_t v37;
  uint64_t v38;
  const __CFString *v39;
  _BYTE *v40;
  _QWORD *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _BYTE *v45;
  char *v46;
  const __CFString *v48;
  uint64_t v49;
  NSObject *v50;
  uint64_t v51;
  NSObject *v52;
  _QWORD v53[5];
  _BYTE block[24];
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  uint64_t v63;
  uint64_t v64;

  v64 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (*(_BYTE *)(a1 + 489))
    {
      if (*(_BYTE *)(a1 + 3368))
        VCConnectionHealthMonitor_UpdateReceiveStats(*(_QWORD *)(a1 + 512));
      v6 = micro();
      v7 = off_1ED10CD68(a1, 1, 1);
      if (v6 - *(double *)(a1 + 656) >= 1.0)
      {
        v8 = v7;
        if (VCWRMHandler_ShouldForceWRMRecommendationUsingUserDefaults(*(_QWORD *)(a1 + 616)))
        {
          v63 = 0;
          v62 = 0u;
          v61 = 0u;
          v60 = 0u;
          v59 = 0u;
          v58 = 0u;
          v57 = 0u;
          v56 = 0u;
          v55 = 0u;
          *(_OWORD *)&block[8] = 0u;
          if (*(_BYTE *)(a1 + 672))
            v9 = 1;
          else
            v9 = 2;
          *(_DWORD *)block = v9;
          *(_DWORD *)&block[4] = objc_msgSend(*(id *)(a1 + 616), "localWRMLinkTypeSuggestion");
          off_1ED10CD60(a1, (uint64_t)block);
        }
        IntValueForKey = VCDefaults_GetIntValueForKey(CFSTR("localWRMAlert"), 0xFFFFFFFFLL);
        if (IntValueForKey != -1)
        {
          v11 = IntValueForKey;
          if (IntValueForKey != *(_DWORD *)(a1 + 752))
          {
            VCConnectionManager_SetPreWarmState(a1, IntValueForKey != 0);
            *(_DWORD *)(a1 + 752) = v11;
          }
        }
        _VCConnectionManager_ChecklocalRATTypeOverrideDefaultValue(a1, v8);
        pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 96));
        v12 = *(_QWORD *)(a1 + 616);
        v13 = VCDuplicationHandler_DuplicationReason(*(_QWORD *)(a1 + 624));
        ShouldRequestWRMNotificationWithDuplicationReason = VCWRMHandler_ShouldRequestWRMNotificationWithDuplicationReason(v12, v13, objc_msgSend((id)a1, "isDuplicationEnabled"), v8, v6);
        v15 = MEMORY[0x1E0C809B0];
        if (ShouldRequestWRMNotificationWithDuplicationReason)
        {
          v16 = *(NSObject **)(a1 + 472);
          *(_QWORD *)block = MEMORY[0x1E0C809B0];
          *(_QWORD *)&block[8] = 3221225472;
          *(_QWORD *)&block[16] = ___VCConnectionManager_RequestWRMNotification_block_invoke;
          *(_QWORD *)&v55 = &unk_1E9E521C0;
          *((_QWORD *)&v55 + 1) = a1;
          dispatch_async(v16, block);
        }
        pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 96));
        *(double *)(a1 + 656) = v6;
        if (*(_BYTE *)(a1 + 3141))
        {
          v17 = *(NSObject **)(a1 + 440);
          *(_QWORD *)block = v15;
          *(_QWORD *)&block[8] = 3221225472;
          *(_QWORD *)&block[16] = ___VCConnectionManager_GetAndLogSignalStrength_block_invoke;
          *(_QWORD *)&v55 = &unk_1E9E521C0;
          *((_QWORD *)&v55 + 1) = a1;
          dispatch_async(v17, block);
        }
        if (*(_QWORD *)(a1 + 808))
        {
          v18 = *(double *)(a1 + 3440);
          if (v18 > 0.0 && v6 - v18 > *(double *)(a1 + 3432))
          {
            v19 = *(NSObject **)(a1 + 472);
            v53[0] = v15;
            v53[1] = 3221225472;
            v53[2] = __VCConnectionManager_CreatePacketRoutingInfoList_block_invoke;
            v53[3] = &unk_1E9E521C0;
            v53[4] = a1;
            dispatch_async(v19, v53);
          }
        }
      }
    }
    pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 96));
    if (!a2)
    {
      PacketRoutingInfoListForConnection = 0;
LABEL_85:
      pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 96));
      return PacketRoutingInfoListForConnection;
    }
    v20 = (*(uint64_t (**)(uint64_t))(a1 + 40))(a1);
    v21 = (CFTypeRef)v20;
    if (!a2[1]
      && *(_QWORD *)(a1 + 632)
      && VCConnection_IsEndToEndLink(v20)
      && objc_msgSend(*(id *)(a1 + 632), "serverLinks"))
    {
      if (v21)
        CFRelease(v21);
      v23 = (const void *)objc_msgSend(*(id *)(a1 + 632), "serverLinks");
      if (!v23)
        goto LABEL_35;
      v21 = CFRetain(v23);
    }
    if (v21)
    {
      if (*(_BYTE *)(a1 + 3424) || VCConnection_IsRelay((uint64_t)v21))
      {
        PacketRoutingInfoListForConnection = _VCConnectionManager_CreatePacketRoutingInfoListForConnection((uint64_t)v21, a1, (uint64_t)a2, a3);
LABEL_48:
        if (*(_BYTE *)(a1 + 489))
        {
          v32 = *a2;
          if (VCDuplicationHandler_IsDuplicationEnabled(*(_QWORD *)(a1 + 624))
            || (v33 = objc_msgSend(*(id *)(a1 + 496), "isAvailable"), v32) && v33 && *(_BYTE *)(a1 + 739))
          {
            v34 = objc_msgSend((id)a1, "connectionForDuplication");
            if (!v34)
              v34 = objc_msgSend((id)a1, "secondaryConnection");
            if (!a2[1])
            {
              if (*(_QWORD *)(a1 + 632))
              {
                if (VCConnection_IsEndToEndLink(v34))
                {
                  objc_msgSend(*(id *)(a1 + 632), "serverLinks");
                  if (v37)
                  {
                    objc_msgSend(*(id *)(a1 + 632), "serverLinks");
                    v34 = v38;
                  }
                }
              }
            }
            if (v34)
            {
              if (*(_BYTE *)(a1 + 3424) || VCConnection_IsRelay(v34))
              {
                v35 = _VCConnectionManager_CreatePacketRoutingInfoListForConnection(v34, a1, (uint64_t)a2, a3);
                if (PacketRoutingInfoListForConnection)
                {
                  *((_QWORD *)PacketRoutingInfoListForConnection + 16) = v35;
                  v36 = v35 + 8;
                  if (!v35)
                    v36 = 0;
                  *((_QWORD *)PacketRoutingInfoListForConnection + 14) = v36;
                }
                else
                {
                  PacketRoutingInfoListForConnection = v35;
                }
              }
              else if (objc_opt_class() == a1)
              {
                if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                {
                  VRTraceErrorLogLevelToCSTR();
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                    VCConnectionManager_CreatePacketRoutingInfoList_cold_4();
                }
              }
              else
              {
                if ((objc_opt_respondsToSelector() & 1) != 0)
                  v48 = (const __CFString *)objc_msgSend((id)a1, "performSelector:", sel_logPrefix);
                else
                  v48 = &stru_1E9E58EE0;
                if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                {
                  v51 = VRTraceErrorLogLevelToCSTR();
                  v52 = *MEMORY[0x1E0CF2758];
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)block = 136316162;
                    *(_QWORD *)&block[4] = v51;
                    *(_WORD *)&block[12] = 2080;
                    *(_QWORD *)&block[14] = "VCConnectionManager_CreatePacketRoutingInfoList";
                    *(_WORD *)&block[22] = 1024;
                    LODWORD(v55) = 2283;
                    WORD2(v55) = 2112;
                    *(_QWORD *)((char *)&v55 + 6) = v48;
                    HIWORD(v55) = 2048;
                    *(_QWORD *)&v56 = a1;
                    _os_log_error_impl(&dword_1D8A54000, v52, OS_LOG_TYPE_ERROR, " [%s] %s:%d %@(%p) p2p link cannot be used for duplication", block, 0x30u);
                  }
                }
              }
            }
          }
        }
        if (!a2[2] || !a2[1] || !objc_msgSend(*(id *)(a1 + 632), "serverLinks"))
          goto LABEL_83;
        if (PacketRoutingInfoListForConnection)
        {
          if (*((_QWORD *)PacketRoutingInfoListForConnection + 16))
            v40 = (_BYTE *)*((_QWORD *)PacketRoutingInfoListForConnection + 16);
          else
            v40 = PacketRoutingInfoListForConnection;
          v41 = CFAllocatorAllocate(a3, 136, 0);
          *((_QWORD *)v40 + 16) = v41;
          if (!v41)
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                VCConnectionManager_CreatePacketRoutingInfoList_cold_3();
            }
            goto LABEL_83;
          }
          *((_QWORD *)v40 + 14) = v41 + 1;
          v41[16] = 0;
          v42 = *((_QWORD *)v40 + 16);
          *(_QWORD *)(v42 + 112) = 0;
          *(_BYTE *)v42 = 0;
          v43 = objc_msgSend(*(id *)(a1 + 632), "serverLinks");
          v44 = *((_QWORD *)v40 + 16) + 8;
        }
        else
        {
          v45 = CFAllocatorAllocate(a3, 136, 0);
          if (!v45)
          {
            if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                VCConnectionManager_CreatePacketRoutingInfoList_cold_2();
            }
            PacketRoutingInfoListForConnection = 0;
            goto LABEL_83;
          }
          PacketRoutingInfoListForConnection = v45;
          *((_QWORD *)v45 + 16) = 0;
          v46 = v45 + 8;
          *((_QWORD *)v45 + 14) = 0;
          *v45 = 0;
          v43 = objc_msgSend(*(id *)(a1 + 632), "serverLinks");
          v44 = (uint64_t)v46;
        }
        VCConnection_SourceDestinationInfo(v43, v44);
LABEL_83:
        if (v21)
          CFRelease(v21);
        goto LABEL_85;
      }
      if (objc_opt_class() == a1)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VCConnectionManager_CreatePacketRoutingInfoList_cold_5();
        }
      }
      else
      {
        if ((objc_opt_respondsToSelector() & 1) != 0)
          v39 = (const __CFString *)objc_msgSend((id)a1, "performSelector:", sel_logPrefix);
        else
          v39 = &stru_1E9E58EE0;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v49 = VRTraceErrorLogLevelToCSTR();
          v50 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)block = 136316162;
            *(_QWORD *)&block[4] = v49;
            *(_WORD *)&block[12] = 2080;
            *(_QWORD *)&block[14] = "VCConnectionManager_CreatePacketRoutingInfoList";
            *(_WORD *)&block[22] = 1024;
            LODWORD(v55) = 2257;
            WORD2(v55) = 2112;
            *(_QWORD *)((char *)&v55 + 6) = v39;
            HIWORD(v55) = 2048;
            *(_QWORD *)&v56 = a1;
            _os_log_error_impl(&dword_1D8A54000, v50, OS_LOG_TYPE_ERROR, " [%s] %s:%d %@(%p) p2p link cannot be used as primary", block, 0x30u);
          }
        }
      }
LABEL_47:
      PacketRoutingInfoListForConnection = 0;
      goto LABEL_48;
    }
LABEL_35:
    if (objc_opt_class() == a1)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 5)
        goto LABEL_46;
      v25 = VRTraceErrorLogLevelToCSTR();
      v26 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        goto LABEL_46;
      *(_DWORD *)block = 136315650;
      *(_QWORD *)&block[4] = v25;
      *(_WORD *)&block[12] = 2080;
      *(_QWORD *)&block[14] = "VCConnectionManager_CreatePacketRoutingInfoList";
      *(_WORD *)&block[22] = 1024;
      LODWORD(v55) = 2260;
      v27 = " [%s] %s:%d Primary connection should not be nil";
      v28 = v26;
      v29 = 28;
    }
    else
    {
      if ((objc_opt_respondsToSelector() & 1) != 0)
        v24 = (const __CFString *)objc_msgSend((id)a1, "performSelector:", sel_logPrefix);
      else
        v24 = &stru_1E9E58EE0;
      if ((int)VRTraceGetErrorLogLevelForModule() < 5)
        goto LABEL_46;
      v30 = VRTraceErrorLogLevelToCSTR();
      v31 = *MEMORY[0x1E0CF2758];
      if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        goto LABEL_46;
      *(_DWORD *)block = 136316162;
      *(_QWORD *)&block[4] = v30;
      *(_WORD *)&block[12] = 2080;
      *(_QWORD *)&block[14] = "VCConnectionManager_CreatePacketRoutingInfoList";
      *(_WORD *)&block[22] = 1024;
      LODWORD(v55) = 2260;
      WORD2(v55) = 2112;
      *(_QWORD *)((char *)&v55 + 6) = v24;
      HIWORD(v55) = 2048;
      *(_QWORD *)&v56 = a1;
      v27 = " [%s] %s:%d %@(%p) Primary connection should not be nil";
      v28 = v31;
      v29 = 48;
    }
    _os_log_impl(&dword_1D8A54000, v28, OS_LOG_TYPE_DEFAULT, v27, block, v29);
LABEL_46:
    v21 = 0;
    goto LABEL_47;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCConnectionManager_CreatePacketRoutingInfoList_cold_1();
  }
  return 0;
}

void VCConnectionManager_UpdateNetworkOutageStatus(uint64_t a1, int a2)
{
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  NSObject *v7;
  int v8;
  uint64_t v9;
  NSObject *v10;
  int v11;
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if ((a2 - 1) >= 3)
  {
    if (a2)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VCConnectionManager_UpdateNetworkOutageStatus_cold_1();
      }
    }
    else if (!*(_BYTE *)(a1 + 3448))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v9 = VRTraceErrorLogLevelToCSTR();
        v10 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v11 = 136316162;
          v12 = v9;
          v13 = 2080;
          v14 = "VCConnectionManager_UpdateNetworkOutageStatus";
          v15 = 1024;
          v16 = 3136;
          v17 = 1024;
          v18 = 3136;
          v19 = 1024;
          v20 = 0;
          _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/ConnectionManager/VCConnectionManager.m:%d: VCCM: Processing event=%d", (uint8_t *)&v11, 0x28u);
        }
      }
      objc_msgSend((id)a1, "startBrokenNetworkDetection");
    }
  }
  else if (*(_BYTE *)(a1 + 3448))
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v4 = VRTraceErrorLogLevelToCSTR();
      v5 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v11 = 136316162;
        v12 = v4;
        v13 = 2080;
        v14 = "VCConnectionManager_UpdateNetworkOutageStatus";
        v15 = 1024;
        v16 = 3144;
        v17 = 1024;
        v18 = 3144;
        v19 = 1024;
        v20 = a2;
        _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/ConnectionManager/VCConnectionManager.m:%d: VCCM: Processing event=%d", (uint8_t *)&v11, 0x28u);
      }
    }
    objc_msgSend((id)a1, "stopBrokenNetworkDetection");
    VCNetworkConditionMonitor_SetBrokenNetworkStatus(*(_QWORD *)(a1 + 808), 1, a2 == 2);
    VCNetworkConditionMonitor_SetBrokenNetworkStatus(*(_QWORD *)(a1 + 808), 0, a2 == 3);
    if (a2 == 1)
    {
      *(_BYTE *)(a1 + 3448) = 0;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v6 = VRTraceErrorLogLevelToCSTR();
        v7 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v8 = *(unsigned __int8 *)(a1 + 3448);
          v11 = 136316162;
          v12 = v6;
          v13 = 2080;
          v14 = "VCConnectionManager_UpdateNetworkOutageStatus";
          v15 = 1024;
          v16 = 3152;
          v17 = 1024;
          v18 = 3152;
          v19 = 1024;
          v20 = v8;
          _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/ConnectionManager/VCConnectionManager.m:%d: VCCM: brokenBackhaulDetectionStarted=%d ", (uint8_t *)&v11, 0x28u);
        }
      }
    }
  }
}

_BYTE *_VCConnectionManager_CreatePacketRoutingInfoListForConnection(uint64_t a1, uint64_t a2, uint64_t a3, const __CFAllocator *a4)
{
  uint64_t v7;
  char v8;
  char v9;
  char v10;
  char v11;
  char *v12;
  uint64_t (*v13)(uint64_t);
  uint64_t (*v14)(uint64_t);
  BOOL v15;
  char v16;
  int Count;
  CFIndex v18;
  uint64_t v19;
  const void *ValueAtIndex;
  uint64_t v21;
  char v22;
  char v23;
  _BYTE *v24;
  _BYTE *v25;
  uint64_t v26;
  uint64_t v27;
  _BYTE *v29;
  char v30;

  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 1;
  do
  {
    v11 = v10;
    v12 = (char *)&kVCConnectionManagerPacketRoutingCriteriaList + 32 * v7;
    v13 = (uint64_t (*)(uint64_t))*((_QWORD *)v12 + 2);
    v14 = (uint64_t (*)(uint64_t))*((_QWORD *)v12 + 3);
    v15 = (*((BOOL (**)(uint64_t, uint64_t, uint64_t))v12 + 1))(a1, a2, a3);
    v16 = v13(a2);
    if ((v9 & 1) != 0)
      v9 = 1;
    else
      v9 = v14(a3) & (v16 ^ 1);
    v10 = 0;
    v8 |= !v15;
    v7 = 1;
  }
  while ((v11 & 1) != 0);
  if ((v8 & 1) != 0)
  {
    if ((v9 & 1) == 0)
    {
      Count = CFArrayGetCount(*(CFArrayRef *)(a2 + 328));
      if (Count >= 1)
      {
        v18 = 0;
        v19 = Count;
        while (2)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 328), v18);
          v21 = 0;
          v22 = 1;
          do
          {
            v23 = v22;
            if (!(*((BOOL (**)(uint64_t, uint64_t, uint64_t))&kVCConnectionManagerPacketRoutingCriteriaList
                   + 4 * v21
                   + 1))((uint64_t)ValueAtIndex, a2, a3))goto LABEL_14;
            v22 = 0;
            v21 = 1;
          }
          while ((v23 & 1) != 0);
          if ((VCConnection_IsOnSameInterfacesWithConnection((uint64_t)ValueAtIndex) & 1) == 0)
          {
LABEL_14:
            if (++v18 != v19)
              continue;
            return 0;
          }
          break;
        }
        if (!ValueAtIndex)
          return 0;
        v29 = CFAllocatorAllocate(a4, 136, 0);
        if (v29)
        {
          v24 = v29;
          v30 = *(_BYTE *)(a3 + 3);
          if (v30)
            v30 = VCConnection_IsHopByHopEncryptionSupported(a1) ^ 1;
          *v24 = v30;
          v26 = (uint64_t)(v24 + 8);
          v27 = (uint64_t)ValueAtIndex;
          goto LABEL_18;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            _VCConnectionManager_CreatePacketRoutingInfoListForConnection_cold_1();
        }
      }
    }
    return 0;
  }
  v25 = CFAllocatorAllocate(a4, 136, 0);
  if (!v25)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCConnectionManager_CreatePacketRoutingInfoListForConnection_cold_2();
    }
    return 0;
  }
  v24 = v25;
  *v25 = 0;
  v26 = (uint64_t)(v25 + 8);
  v27 = a1;
LABEL_18:
  VCConnection_SourceDestinationInfo(v27, v26);
  *((_QWORD *)v24 + 16) = 0;
  *((_QWORD *)v24 + 14) = 0;
  return v24;
}

void VCConnectionManager_IsSourceOnCellularIPv6(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  NSObject *v5;
  int v6;
  uint64_t v7;
  __int16 v8;
  const char *v9;
  __int16 v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a2 && a3 && a4)
    {
      (*(void (**)(void))(a1 + 32))();
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCConnectionManager_IsSourceOnCellularIPv6_cold_1();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v4 = VRTraceErrorLogLevelToCSTR();
    v5 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v6 = 136315650;
      v7 = v4;
      v8 = 2080;
      v9 = "VCConnectionManager_IsSourceOnCellularIPv6";
      v10 = 1024;
      v11 = 2600;
      _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v6, 0x1Cu);
    }
  }
}

uint64_t VCConnectionManager_CopyConnection(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7;
  NSObject *v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  uint64_t v16;
  __int16 v17;
  uint64_t v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (a1 && a2 && a3)
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, a2, a3);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v7 = VRTraceErrorLogLevelToCSTR();
    v8 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136316418;
      v10 = v7;
      v11 = 2080;
      v12 = "VCConnectionManager_CopyConnection";
      v13 = 1024;
      v14 = 2612;
      v15 = 2048;
      v16 = a1;
      v17 = 2048;
      v18 = a2;
      v19 = 2048;
      v20 = a3;
      _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d NULL instance=%p, sourceDestinationInfo=%p, or isPrimary=%p passed", (uint8_t *)&v9, 0x3Au);
    }
  }
  return 0;
}

void VCConnectionManager_UpdateConnectionHealthWithIndicator(uint64_t a1, int a2, int a3, int a4)
{
  if (*(_BYTE *)(a1 + 3368))
    VCConnectionHealthMonitor_ReceivePacket(*(_QWORD *)(a1 + 512), a2, a3, a4);
}

uint64_t VCConnectionManager_IsDuplicationConnectionCandidate(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  int v5;
  const void *v6;
  int IsLocalOnWiFi;
  int v8;
  int v9;
  int IsRemoteOnWiFi;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  NSObject *v15;
  _BOOL4 v16;
  int v17;
  uint64_t v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v14 = VRTraceErrorLogLevelToCSTR();
      v15 = *MEMORY[0x1E0CF2758];
      v16 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
      result = 0;
      if (!v16)
        return result;
      v17 = 136315650;
      v18 = v14;
      v19 = 2080;
      v20 = "VCConnectionManager_IsDuplicationConnectionCandidate";
      v21 = 1024;
      v22 = 2903;
      _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v17, 0x1Cu);
    }
    return 0;
  }
  if (!*(_BYTE *)(a1 + 3141) || (result = VCConnection_IsEndToEndLink(a2), (_DWORD)result))
  {
    v5 = VCDuplicationHandler_DuplicationReason(*(_QWORD *)(a1 + 624));
    v6 = (const void *)(*(uint64_t (**)(uint64_t))(a1 + 40))(a1);
    IsLocalOnWiFi = VCConnection_IsLocalOnWiFi(a2);
    v8 = IsLocalOnWiFi ^ VCConnection_IsLocalOnWiFi((uint64_t)v6);
    if (v5 == 3)
      v9 = v8 ^ 1;
    else
      v9 = 0;
    IsRemoteOnWiFi = VCConnection_IsRemoteOnWiFi(a2);
    v11 = VCConnection_IsRemoteOnWiFi((uint64_t)v6);
    if (v5 == 4)
    {
      if (*(_BYTE *)(a1 + 491) == 1)
        v12 = IsRemoteOnWiFi ^ v11 ^ 1;
      else
        v12 = 0;
    }
    else
    {
      v12 = 0;
    }
    v13 = v8 | IsRemoteOnWiFi ^ v11;
    if (v6)
      CFRelease(v6);
    return v13 & ~(v9 | v12);
  }
  return result;
}

BOOL VCConnectionManager_AreAllLinkProbingTriggersInactive(uint64_t a1)
{
  _BOOL8 result;
  uint64_t v2;
  NSObject *v3;
  _BOOL4 v4;
  int v5;
  uint64_t v6;
  __int16 v7;
  const char *v8;
  __int16 v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (!*(_BYTE *)(a1 + 493) && !*(_BYTE *)(a1 + 494))
      return !VCDuplicationHandler_IsDuplicationEnabled(*(_QWORD *)(a1 + 624));
    return 0;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() < 5)
    return 0;
  v2 = VRTraceErrorLogLevelToCSTR();
  v3 = *MEMORY[0x1E0CF2758];
  v4 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
  result = 0;
  if (v4)
  {
    v5 = 136315650;
    v6 = v2;
    v7 = 2080;
    v8 = "VCConnectionManager_AreAllLinkProbingTriggersInactive";
    v9 = 1024;
    v10 = 2895;
    _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d nil instance passed", (uint8_t *)&v5, 0x1Cu);
    return 0;
  }
  return result;
}

void VCConnectionManager_UpdatePacketSendStatus(uint64_t a1, int a2)
{
  unsigned int *v2;
  unsigned int v3;
  unsigned int *v4;
  unsigned int v5;

  if (a1)
  {
    if (a2)
    {
      v2 = (unsigned int *)(a1 + 3392);
      do
        v3 = __ldaxr(v2);
      while (__stlxr(v3 + 1, v2));
    }
    else
    {
      v4 = (unsigned int *)(a1 + 3396);
      do
        v5 = __ldaxr(v4);
      while (__stlxr(v5 + 1, v4));
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCConnectionManager_UpdatePacketSendStatus_cold_1();
  }
}

void VCConnectionManager_UpdateOnTheWireBytesSentCount(uint64_t a1, uint64_t a2)
{
  unint64_t *v2;
  unint64_t v3;

  if (a1)
  {
    v2 = (unint64_t *)(a1 + 3400);
    do
      v3 = __ldaxr(v2);
    while (__stlxr(v3 + a2, v2));
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCConnectionManager_UpdateOnTheWireBytesSentCount_cold_1();
  }
}

void VCConnectionManager_UpdateOnTheWireBytesReceivedCount(uint64_t a1, uint64_t a2)
{
  unint64_t *v2;
  unint64_t v3;

  if (a1)
  {
    v2 = (unint64_t *)(a1 + 3408);
    do
      v3 = __ldaxr(v2);
    while (__stlxr(v3 + a2, v2));
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCConnectionManager_UpdateOnTheWireBytesReceivedCount_cold_1();
  }
}

void _VCConnectionManager_UseCellPrimaryInterfaceInternal(uint64_t a1, int a2)
{
  int v4;
  int ErrorLogLevelForModule;
  uint64_t v6;
  NSObject *v7;
  int v8;
  uint64_t v9;
  NSObject *v10;
  const char *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() < 5)
      return;
    v9 = VRTraceErrorLogLevelToCSTR();
    v10 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      return;
    v13 = 136315650;
    v14 = v9;
    v15 = 2080;
    v16 = "_VCConnectionManager_UseCellPrimaryInterfaceInternal";
    v17 = 1024;
    v18 = 2635;
    v11 = " [%s] %s:%d nil instance passed";
LABEL_17:
    _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, v11, (uint8_t *)&v13, 0x1Cu);
    return;
  }
  v4 = *(unsigned __int8 *)(a1 + 738);
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (!v4)
  {
    if (ErrorLogLevelForModule < 7)
      return;
    v12 = VRTraceErrorLogLevelToCSTR();
    v10 = *MEMORY[0x1E0CF2758];
    if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      return;
    v13 = 136315650;
    v14 = v12;
    v15 = 2080;
    v16 = "_VCConnectionManager_UseCellPrimaryInterfaceInternal";
    v17 = 1024;
    v18 = 2636;
    v11 = " [%s] %s:%d Prevent displaying cell as primary interface as directed by storebag settings";
    goto LABEL_17;
  }
  if (ErrorLogLevelForModule >= 6)
  {
    v6 = VRTraceErrorLogLevelToCSTR();
    v7 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v8 = *(_DWORD *)(a1 + 84);
      v13 = 136316162;
      v14 = v6;
      v15 = 2080;
      v16 = "_VCConnectionManager_UseCellPrimaryInterfaceInternal";
      v17 = 1024;
      v18 = 2638;
      v19 = 1024;
      v20 = v8;
      v21 = 1024;
      v22 = a2;
      _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d callID = %u, network status bar request, useCellPrimayInterface = %d", (uint8_t *)&v13, 0x28u);
    }
  }
  if (*(unsigned __int8 *)(a1 + 504) != a2)
  {
    *(_BYTE *)(a1 + 504) = a2;
    if (a2)
      VCNetworkAgentCell_AddCellularAssertion();
    else
      VCNetworkAgentCell_RemoveCellularAssertion();
  }
}

void _VCConnectionManager_SetDuplicationEnabledInternal(uint64_t a1, int a2)
{
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  NSObject *v7;
  const char *v8;
  NSObject *v9;
  uint32_t v10;
  unsigned int NumberOfConnectionsInternal;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  NSObject *v15;
  int v16;
  const char *v17;
  char IsDuplicationEnabled;
  uint64_t v19;
  uint64_t v20;
  CFStringRef v21;
  int IsLocalOnCellular;
  NSObject *v23;
  _QWORD v24[7];
  char v25;
  uint8_t buf[4];
  uint64_t v27;
  __int16 v28;
  const char *v29;
  __int16 v30;
  int v31;
  __int16 v32;
  const char *v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if ((a2 & 1) == 0)
  {
    *(_BYTE *)(a1 + 488) = 0;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v4 = VRTraceErrorLogLevelToCSTR();
      v5 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        v27 = v4;
        v28 = 2080;
        v29 = "_VCConnectionManager_SetDuplicationEnabledInternal";
        v30 = 1024;
        v31 = 856;
        _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d HandoverReport: Reset _duplicationPending state if we stop duplication.", buf, 0x1Cu);
      }
    }
  }
  if (*(unsigned __int8 *)(a1 + 456) == a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v6 = VRTraceErrorLogLevelToCSTR();
      v7 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        v27 = v6;
        v28 = 2080;
        v29 = "_VCConnectionManager_SetDuplicationEnabledInternal";
        v30 = 1024;
        v31 = 860;
        v32 = 1024;
        LODWORD(v33) = a2;
        v8 = " [%s] %s:%d HandoverReport: enable duplication (%d) already applied.";
        v9 = v7;
        v10 = 34;
LABEL_14:
        _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, v8, buf, v10);
      }
    }
  }
  else
  {
    NumberOfConnectionsInternal = VCConnectionManager_GetNumberOfConnectionsInternal((uint64_t (**)(void))a1);
    if (a2 && NumberOfConnectionsInternal <= 1)
    {
      *(_BYTE *)(a1 + 488) = 1;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v12 = VRTraceErrorLogLevelToCSTR();
        v13 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          v27 = v12;
          v28 = 2080;
          v29 = "_VCConnectionManager_SetDuplicationEnabledInternal";
          v30 = 1024;
          v31 = 869;
          v8 = " [%s] %s:%d HandoverReport: can't enable duplication when there is no secondary connection.";
          v9 = v13;
          v10 = 28;
          goto LABEL_14;
        }
      }
    }
    else
    {
      *(_BYTE *)(a1 + 456) = a2;
      *(_BYTE *)(a1 + 488) = 0;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v14 = VRTraceErrorLogLevelToCSTR();
        v15 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v16 = *(unsigned __int8 *)(a1 + 456);
          *(_DWORD *)buf = 136315906;
          if (v16)
            v17 = "Start";
          else
            v17 = "Stop";
          v27 = v14;
          v28 = 2080;
          v29 = "_VCConnectionManager_SetDuplicationEnabledInternal";
          v30 = 1024;
          v31 = 876;
          v32 = 2080;
          v33 = v17;
          _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d HandoverReport: %s duplication and active probing on links", buf, 0x26u);
        }
      }
      objc_msgSend(*(id *)(a1 + 768), "setIsDuplicationEnabled:", *(unsigned __int8 *)(a1 + 456));
      VCConnectionManager_SetActiveLinkProbingEnabled(a1, *(unsigned __int8 *)(a1 + 456));
      IsDuplicationEnabled = VCDuplicationHandler_IsDuplicationEnabled(*(_QWORD *)(a1 + 624));
      if ((IsDuplicationEnabled & 1) == 0)
      {
        *(_QWORD *)(a1 + 544) = 0;
        *(_QWORD *)(a1 + 592) = 0;
      }
      v19 = _VCConnectionManager_CopyConnectionForQualityInternal((void *)a1, 1);
      if (v19)
      {
        v20 = v19;
        v21 = VCConnectionManager_CopySuggestedLinkTypeCombo(a1);
        IsLocalOnCellular = VCConnection_IsLocalOnCellular(v20);
        VCConnectionManager_UseCellPrimaryInterface(a1, IsLocalOnCellular);
        v23 = *(NSObject **)(a1 + 440);
        v24[0] = MEMORY[0x1E0C809B0];
        v24[1] = 3221225472;
        v24[2] = ___VCConnectionManager_SetDuplicationEnabledInternal_block_invoke;
        v24[3] = &unk_1E9E55690;
        v25 = IsDuplicationEnabled;
        v24[4] = a1;
        v24[5] = v20;
        v24[6] = v21;
        dispatch_async(v23, v24);
      }
      _VCConnectionManager_SetOverlayLinkDetails(a1, objc_msgSend((id)a1, "connectionForDuplication"), 1, IsDuplicationEnabled);
    }
  }
}

uint64_t _VCConnectionManager_SetWRMNotification(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  _BOOL4 v6;
  uint64_t result;
  const char *v8;
  NSObject *v9;
  uint32_t v10;
  uint64_t v11;
  NSObject *v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;
  NSObject *v27;
  _BOOL4 v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  _BYTE v36[20];
  int v37;
  __int16 v38;
  int v39;
  __int16 v40;
  int v41;
  __int16 v42;
  int v43;
  __int16 v44;
  int v45;
  __int16 v46;
  int v47;
  __int16 v48;
  int v49;
  _QWORD v50[4];

  v50[3] = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (!*(_DWORD *)(a2 + 4))
    {
      v50[0] = CFSTR("WRMCoexIsLocal");
      v50[1] = CFSTR("WRMLinkType");
      *(_QWORD *)&v36[4] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", 0, MEMORY[0x1E0C9AAB0]);
      v50[2] = CFSTR("WRMReasonCode");
      *(_QWORD *)&v36[12] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", *(_QWORD *)(a2 + 8));
      objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v35, v50, 3);
      reportingGenericEvent();
    }
    if (*(_QWORD *)(a2 + 8) == 2)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() < 7)
        return 0;
      v4 = VRTraceErrorLogLevelToCSTR();
      v5 = *MEMORY[0x1E0CF2758];
      v6 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
      result = 0;
      if (!v6)
        return result;
      v35 = 136315650;
      *(_QWORD *)v36 = v4;
      *(_WORD *)&v36[8] = 2080;
      *(_QWORD *)&v36[10] = "_VCConnectionManager_SetWRMNotification";
      *(_WORD *)&v36[18] = 1024;
      v37 = 1110;
      v8 = " [%s] %s:%d HandoverReport: Ignoring iRAT notification because the reason for recommendation is WiFi link going down";
      v9 = v5;
      v10 = 28;
LABEL_8:
      _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&v35, v10);
      return 0;
    }
    if (!*(_DWORD *)(a2 + 4) && (objc_msgSend((id)a1, "isDuplicationAllowed") & 1) == 0)
    {
      *(_BYTE *)(a1 + 3152) = 1;
      v19 = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(a1 + 3160) = *(_OWORD *)a2;
      *(_OWORD *)(a1 + 3176) = v19;
      v20 = *(_OWORD *)(a2 + 32);
      v21 = *(_OWORD *)(a2 + 48);
      v22 = *(_OWORD *)(a2 + 80);
      *(_OWORD *)(a1 + 3224) = *(_OWORD *)(a2 + 64);
      *(_OWORD *)(a1 + 3240) = v22;
      *(_OWORD *)(a1 + 3192) = v20;
      *(_OWORD *)(a1 + 3208) = v21;
      v23 = *(_OWORD *)(a2 + 96);
      v24 = *(_OWORD *)(a2 + 112);
      v25 = *(_OWORD *)(a2 + 144);
      *(_OWORD *)(a1 + 3288) = *(_OWORD *)(a2 + 128);
      *(_OWORD *)(a1 + 3304) = v25;
      *(_OWORD *)(a1 + 3256) = v23;
      *(_OWORD *)(a1 + 3272) = v24;
      if ((int)VRTraceGetErrorLogLevelForModule() < 7)
        return 0;
      v26 = VRTraceErrorLogLevelToCSTR();
      v27 = *MEMORY[0x1E0CF2758];
      v28 = os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT);
      result = 0;
      if (!v28)
        return result;
      v29 = *(unsigned __int8 *)(a1 + 3129);
      v30 = *(unsigned __int8 *)(a1 + 3369);
      v31 = *(_DWORD *)(a1 + 3320);
      v32 = *(_DWORD *)(a1 + 3324);
      v33 = *(_DWORD *)(a1 + 3148);
      v34 = *(unsigned __int8 *)(a1 + 3449);
      v35 = 136317186;
      *(_QWORD *)v36 = v26;
      *(_WORD *)&v36[8] = 2080;
      *(_QWORD *)&v36[10] = "_VCConnectionManager_SetWRMNotification";
      *(_WORD *)&v36[18] = 1024;
      v37 = 1114;
      v38 = 1024;
      v39 = v29;
      v40 = 1024;
      v41 = v30;
      v42 = 1024;
      v43 = v31;
      v44 = 1024;
      v45 = v32;
      v46 = 1024;
      v47 = v33;
      v48 = 1024;
      v49 = v34;
      v8 = " [%s] %s:%d HandoverReport: Pending iRAT notification isDuplicationAllowedForMediaDegraded=%d isRemoteMediaQu"
           "alityDegraded=%d currentTargetBitrate=%d cellBitrateCap=%d bitrateCapDelta=%d isUserMoving=%d";
      v9 = v27;
      v10 = 64;
      goto LABEL_8;
    }
    *(_BYTE *)(a1 + 3152) = 0;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v11 = VRTraceErrorLogLevelToCSTR();
      v12 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v13 = *(unsigned __int8 *)(a1 + 3129);
        v14 = *(unsigned __int8 *)(a1 + 3369);
        v15 = *(_DWORD *)(a1 + 3320);
        v16 = *(_DWORD *)(a1 + 3324);
        v17 = *(_DWORD *)(a1 + 3148);
        v18 = *(unsigned __int8 *)(a1 + 3449);
        v35 = 136317186;
        *(_QWORD *)v36 = v11;
        *(_WORD *)&v36[8] = 2080;
        *(_QWORD *)&v36[10] = "_VCConnectionManager_SetWRMNotification";
        *(_WORD *)&v36[18] = 1024;
        v37 = 1117;
        v38 = 1024;
        v39 = v13;
        v40 = 1024;
        v41 = v14;
        v42 = 1024;
        v43 = v15;
        v44 = 1024;
        v45 = v16;
        v46 = 1024;
        v47 = v17;
        v48 = 1024;
        v49 = v18;
        _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d HandoverReport: Processing iRAT notification isDuplicationAllowedForMediaDegraded=%d isRemoteMediaQualityDegraded=%d currentTargetBitrate=%d cellBitrateCap=%d bitrateCapDelta=%d isUserMoving=%d", (uint8_t *)&v35, 0x40u);
      }
    }
    return VCConnectionManager_ProcessWRMNotification(a1, (_DWORD *)a2);
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        _VCConnectionManager_SetWRMNotification_cold_1();
    }
    return 1;
  }
}

uint64_t _VCConnectionManager_IsInterfaceOnCellularForActiveConnectionWithQuality(uint64_t a1, int a2, int a3)
{
  uint64_t v4;
  const void *v5;
  uint64_t IsLocalOnCellular;
  uint64_t v7;

  v4 = VCConnectionManager_CopyConnectionForQuality(a1, a2);
  if (!v4)
    return 0;
  v5 = (const void *)v4;
  if (a3)
    IsLocalOnCellular = VCConnection_IsLocalOnCellular(v4);
  else
    IsLocalOnCellular = VCConnection_IsRemoteOnCellular(v4);
  v7 = IsLocalOnCellular;
  CFRelease(v5);
  return v7;
}

BOOL _VCPacketRoutingRTXSupportCriteria_ConnectionMatchesCriteria(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!*(_BYTE *)(a3 + 4))
    return 1;
  if (!*(_BYTE *)(a2 + 817))
    return 0;
  if ((VCConnection_IsRelay(a1) & 1) != 0)
    return 1;
  return *(_BYTE *)(a2 + 3450) != 0;
}

uint64_t _VCPacketRoutingRTXSupportCriteria_AllowsAlternateConnection(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 3450);
}

uint64_t _VCPacketRoutingRTXSupportCriteria_IsCriteriaRequestedInConfig(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 4);
}

uint64_t _VCPacketRoutingHBHEncryptionSupportCriteria_ConnectionMatchesCriteria(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a3 + 3))
    return VCConnection_IsHopByHopEncryptionSupported(a1);
  else
    return 1;
}

uint64_t _VCPacketRoutingHBHEncryptionSupportCriteria_AllowsAlternateConnection()
{
  return 1;
}

uint64_t _VCPacketRoutingHBHEncryptionSupportCriteria_IsCriteriaRequestedInConfig(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 3);
}

void sub_1D8C9A6DC(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1D8C9A81C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1D8C9AE94(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1D8C9B9CC(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1D8C9BB08(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t VCCMWRMStatusUpdateCallback(void *a1, const char *a2)
{
  return objc_msgSend(a1, "sendStatusUpdate:", a2);
}

int8x16_t VCTimescalePSOLA_DSPInit(uint64_t a1, int a2, unsigned int a3, char a4, unsigned int a5, int a6)
{
  __int16 v10;
  int v12;
  uint64_t v13;
  int v14;
  __int16 v15;
  __int16 v16;
  float64x2_t v17;
  float64x2_t v18;
  int8x16_t result;
  double v20;

  v10 = a2;
  if (a2 <= 23999)
  {
    if (a2 != 8000)
    {
      v12 = 16000;
LABEL_7:
      if (a2 != v12)
        return result;
    }
  }
  else if (a2 != 24000 && a2 != 48000)
  {
    v12 = 32000;
    goto LABEL_7;
  }
  v13 = *(_QWORD *)(a1 + 72);
  v14 = *(_DWORD *)(a1 + 68);
  v20 = (double)a3 / (double)a2;
  v15 = VCTimescalePSOLA_DivW32W16ResW16(a2, 8000);
  VCTimescalePSOLA_MemSetW16((_WORD *)a1, 0, 17344);
  *(_WORD *)(a1 + 2) = v10;
  *(_DWORD *)(a1 + 34664) = a3;
  *(_WORD *)(a1 + 56) = 5 * v15;
  *(_DWORD *)(a1 + 60) = 2500;
  *(_WORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 68) = v14;
  *(_BYTE *)(a1 + 80) = a4;
  *(_DWORD *)(a1 + 82) = 0;
  *(_WORD *)(a1 + 88) = VCDefaults_GetIntValueForKey(CFSTR("psolaMaxContiguousCompressions"), 4);
  *(_WORD *)(a1 + 90) = VCDefaults_GetIntValueForKey(CFSTR("psolaAdaptationGap"), 6);
  *(_WORD *)(a1 + 86) = VCDefaults_GetIntValueForKey(CFSTR("psolaMaxContiguousExpansion"), 4);
  *(_BYTE *)(a1 + 92) = 1;
  *(_BYTE *)a1 = a5;
  if (a5 <= 1)
    v16 = 14746;
  else
    v16 = 13926;
  *(_WORD *)(a1 + 54) = v16;
  *(_DWORD *)(a1 + 96) = a6;
  v17.f64[0] = v20 + v20;
  v17.f64[1] = v20;
  v18 = (float64x2_t)vdupq_n_s64(0x3F947AE147AE147BuLL);
  result = vbslq_s8((int8x16_t)vcgtq_f64(v18, v17), (int8x16_t)v18, (int8x16_t)v17);
  *(int8x16_t *)(a1 + 34672) = result;
  *(_QWORD *)(a1 + 72) = v13;
  return result;
}

uint64_t VCTimescalePSOLA_IncFrameScaledGapCount(uint64_t result)
{
  int v1;
  int v2;
  __int16 v3;

  if (*(_BYTE *)(result + 80))
  {
    v1 = *(__int16 *)(result + 88);
    if (v1 <= *(__int16 *)(result + 86))
      v1 = *(__int16 *)(result + 86);
    if (v1 && *(_WORD *)(result + 90))
    {
      v2 = *(__int16 *)(result + 84);
      if (v2 >= *(__int16 *)(result + 90))
      {
        v3 = 0;
        *(_WORD *)(result + 82) = 0;
        *(_BYTE *)(result + 92) = 1;
      }
      else
      {
        v3 = v2 + 1;
      }
      *(_WORD *)(result + 84) = v3;
    }
  }
  return result;
}

uint64_t _VCTimescalePSOLA_ActiveSpeechExpand(unsigned __int8 *a1, uint64_t a2, double a3)
{
  double v5;
  double v6;
  __int128 v7;
  int v8;
  double v9;
  int v10;
  unint64_t v11;
  const void **v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  __int16 v17;
  unint64_t v18;
  uint64_t v19;
  NSObject *v20;
  NSObject *v21;
  int v22;
  int v23;
  int v25;
  int v26;
  uint64_t v27;
  __int16 v28;
  const char *v29;
  __int16 v30;
  int v31;
  __int16 v32;
  int v33;
  __int16 v34;
  int v35;
  _OWORD v36[2];
  _OWORD v37[2];
  unint64_t v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v38 = 0xAAAAAAAAAAAAAAAALL;
  v5 = (double)*(int *)(a2 + 20);
  LOWORD(a3) = *((_WORD *)a1 + 1);
  v6 = (double)*(unint64_t *)&a3;
  if (*((double *)a1 + 4335) * v6 <= v5)
    v5 = *((double *)a1 + 4335) * v6;
  *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v37[0] = v7;
  v37[1] = v7;
  v8 = (int)v5;
  v36[0] = v7;
  v36[1] = v7;
  v9 = (double)*((__int16 *)a1 + 17330);
  if (v6 * 0.01 <= v9)
    v9 = v6 * 0.01;
  v10 = (int)v9;
  if (*a1)
  {
    v11 = 0;
    v12 = (const void **)(a2 + 88);
    v13 = v37;
    v14 = 3940;
    do
    {
      *(v13 - 4) = &a1[v14];
      memcpy(&a1[4 * v10 + v14], *v12, *(int *)(a2 + 40) * (uint64_t)v8);
      *v13++ = *(v12 - 4);
      ++v11;
      v14 += 7680;
      ++v12;
    }
    while (v11 < *a1);
    LOWORD(v15) = *((_WORD *)a1 + 1);
    v6 = (double)v15;
  }
  *((_WORD *)a1 + 2) = (int)(v6 * 0.045);
  WORD1(v38) = v8 + v10;
  LOWORD(v38) = v10;
  v16 = VCTimescalePSOLA_PreEmptiveExpand(a1, (__int16 *)v36);
  v17 = WORD2(v38);
  **(_DWORD **)(a2 + 8) = (SWORD2(v38) - (__int16)v38) & ~((SWORD2(v38) - (__int16)v38) >> 31);
  if (*a1)
  {
    v18 = 0;
    do
    {
      memmove(*(void **)(a2 + 56 + 8 * v18), (const void *)(*(_QWORD *)(a2 + 56 + 8 * v18) + *(int *)(a2 + 40) * (uint64_t)(__int16)v38), **(int **)(a2 + 8) * (uint64_t)*(int *)(a2 + 40));
      ++v18;
    }
    while (v18 < *a1);
    v17 = WORD2(v38);
  }
  if (SWORD1(v38) >= v17 || (v16 & 0x80000000) != 0)
  {
    **(_DWORD **)(a2 + 32) = 7;
    VCTimescalePSOLA_IncFrameScaledGapCount((uint64_t)a1);
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v19 = VRTraceErrorLogLevelToCSTR();
      v20 = *MEMORY[0x1E0CF2758];
      v21 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          v22 = *(_DWORD *)(a2 + 20);
          v26 = 136316162;
          v27 = v19;
          v28 = 2080;
          v29 = "_VCTimescalePSOLA_ActiveSpeechExpand";
          v30 = 1024;
          v31 = 199;
          v32 = 1024;
          v33 = v22;
          v34 = 1024;
          v35 = SWORD2(v38) - SWORD1(v38);
          _os_log_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d PSOLA Expansion samplesToDecode %d Samples Added %d", (uint8_t *)&v26, 0x28u);
        }
      }
      else if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
      {
        v25 = *(_DWORD *)(a2 + 20);
        v26 = 136316162;
        v27 = v19;
        v28 = 2080;
        v29 = "_VCTimescalePSOLA_ActiveSpeechExpand";
        v30 = 1024;
        v31 = 199;
        v32 = 1024;
        v33 = v25;
        v34 = 1024;
        v35 = SWORD2(v38) - SWORD1(v38);
        _os_log_debug_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_DEBUG, " [%s] %s:%d PSOLA Expansion samplesToDecode %d Samples Added %d", (uint8_t *)&v26, 0x28u);
      }
    }
    if (*((_WORD *)a1 + 11))
      v23 = 4;
    else
      v23 = 5;
    **(_DWORD **)(a2 + 32) = v23;
    _VCTimescalePSOLA_IncFrameScaledCount((uint64_t)a1, 1);
  }
  *(_BYTE *)(a2 + 152) = 1;
  return v16;
}

uint64_t _VCTimescalePSOLA_IncFrameScaledCount(uint64_t result, int a2)
{
  uint64_t v2;
  int v3;
  int v4;

  if (*(_BYTE *)(result + 80))
  {
    v2 = 88;
    if (a2 == 1)
      v2 = 86;
    v3 = *(__int16 *)(result + v2);
    if (v3)
    {
      v4 = *(__int16 *)(result + 82);
      if (v4 < v3 && *(_BYTE *)(result + 92))
      {
        LOWORD(v4) = v4 + 1;
        *(_DWORD *)(result + 82) = (unsigned __int16)v4;
      }
      if (v3 <= (__int16)v4)
      {
        *(_DWORD *)(result + 82) = 0;
        *(_BYTE *)(result + 92) = 0;
      }
    }
  }
  return result;
}

uint64_t _VCTimescalePSOLA_ActiveSpeechCompress(unsigned __int8 *a1, uint64_t a2)
{
  __int128 v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  double v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  NSObject *v14;
  NSObject *v15;
  int v16;
  int v18;
  int v19;
  uint64_t v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;
  _OWORD v29[2];
  _OWORD v30[2];
  unint64_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v31 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v30[0] = v4;
  v30[1] = v4;
  v29[0] = v4;
  v29[1] = v4;
  v5 = *a1;
  if (*a1)
  {
    v6 = v30;
    v7 = (_QWORD *)(a2 + 88);
    do
    {
      *(v6 - 4) = *v7;
      *v6++ = *(v7 - 4);
      ++v7;
      --v5;
    }
    while (v5);
  }
  LOWORD(v4) = *((_WORD *)a1 + 1);
  v8 = (double)(unint64_t)v4;
  *((_WORD *)a1 + 2) = (int)(v8 * 0.01);
  *(double *)&v4 = *((double *)a1 + 4334) * v8;
  if (*(double *)&v4 > (double)*(int *)(a2 + 20))
    *(double *)&v4 = (double)*(int *)(a2 + 20);
  WORD1(v31) = (int)*(double *)&v4;
  LOWORD(v31) = 0;
  v9 = VCTimescalePSOLA_Accelerate(a1, (__int16 *)v29);
  v10 = v9;
  v11 = SWORD2(v31);
  **(_DWORD **)(a2 + 8) = SWORD2(v31);
  *(_BYTE *)(a2 + 152) = 1;
  if (*(_DWORD *)(a2 + 20) <= v11 || (v9 & 0x80000000) != 0)
  {
    **(_DWORD **)(a2 + 32) = 7;
    VCTimescalePSOLA_IncFrameScaledGapCount((uint64_t)a1);
  }
  else
  {
    if (*((_WORD *)a1 + 11))
      v12 = 1;
    else
      v12 = 3;
    **(_DWORD **)(a2 + 32) = v12;
    _VCTimescalePSOLA_IncFrameScaledCount((uint64_t)a1, 0);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v13 = VRTraceErrorLogLevelToCSTR();
      v14 = *MEMORY[0x1E0CF2758];
      v15 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          v16 = *(_DWORD *)(a2 + 20);
          v19 = 136316162;
          v20 = v13;
          v21 = 2080;
          v22 = "_VCTimescalePSOLA_ActiveSpeechCompress";
          v23 = 1024;
          v24 = 252;
          v25 = 1024;
          v26 = v16;
          v27 = 1024;
          v28 = v16 - SWORD2(v31);
          _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d PSOLA Compress samplesToDecode %d samples removed %d", (uint8_t *)&v19, 0x28u);
        }
      }
      else if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        v18 = *(_DWORD *)(a2 + 20);
        v19 = 136316162;
        v20 = v13;
        v21 = 2080;
        v22 = "_VCTimescalePSOLA_ActiveSpeechCompress";
        v23 = 1024;
        v24 = 252;
        v25 = 1024;
        v26 = v18;
        v27 = 1024;
        v28 = v18 - SWORD2(v31);
        _os_log_debug_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEBUG, " [%s] %s:%d PSOLA Compress samplesToDecode %d samples removed %d", (uint8_t *)&v19, 0x28u);
      }
    }
  }
  return v10;
}

uint64_t VCTimescalePSOLA_ActiveSpeechAdapt(uint64_t a1, uint64_t a2, double a3)
{
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  _BOOL4 v8;
  char v9;
  int v10;
  int v11;

  v3 = (double)*(int *)(a2 + 20);
  LOWORD(a3) = *(_WORD *)(a1 + 2);
  v4 = (double)*(unint64_t *)&a3;
  v5 = *(double *)(a1 + 34672) * (double)*(unint64_t *)&a3;
  v6 = *(double *)(a2 + 160);
  v7 = *(double *)(a1 + 34680) * v4;
  v8 = v5 <= v3 && v6 > 0.0;
  v9 = v7 <= v3 && v6 < 0.0;
  v10 = *(_DWORD *)(a1 + 96);
  if (v10 != 3)
  {
    if (v10 != 2)
      return 0;
    goto LABEL_16;
  }
  if (v8)
    v8 = *(_DWORD *)(a2 + 16) == 0;
  v11 = *(_DWORD *)(a2 + 172);
  if (v11 == 3)
  {
LABEL_16:
    v9 |= v8;
    goto LABEL_17;
  }
  if (v11 != 2)
  {
    if (v11 != 1)
      return 0;
LABEL_17:
    if ((v9 & 1) == 0)
      return 0;
    goto LABEL_18;
  }
  if (!v8)
    return 0;
LABEL_18:
  if (v6 < 0.0)
    return _VCTimescalePSOLA_ActiveSpeechExpand((unsigned __int8 *)a1, a2, v6);
  if (v6 > 0.0)
    return _VCTimescalePSOLA_ActiveSpeechCompress((unsigned __int8 *)a1, a2);
  return 0;
}

void VCTimescalePSOLA_UpdateHistoryBuffer(unsigned __int8 *a1, uint64_t a2)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  int v9;
  unint64_t v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v3 = *(_DWORD *)(a2 + 40);
  v4 = (int)((double)(v3 * *((unsigned __int16 *)a1 + 1)) * 0.01);
  v5 = (__int16)(v3 * (**(_DWORD **)(a2 + 8) + **(_WORD **)(a2 + 24)));
  if (v5 >= v4)
  {
    if (*a1)
    {
      v11 = 0;
      v12 = 0;
      do
      {
        memcpy(&a1[*(int *)(a2 + 40) * (uint64_t)v12 + 3940], (const void *)(*(_QWORD *)(a2 + 120 + 8 * v11++) + v5 - (uint64_t)v4), v4);
        v12 += 1920;
      }
      while (v11 < *a1);
      v3 = *(_DWORD *)(a2 + 40);
    }
    *((_WORD *)a1 + 17330) = v4 / v3;
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v6 = VRTraceErrorLogLevelToCSTR();
    v7 = *MEMORY[0x1E0CF2758];
    v8 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        v9 = *(_DWORD *)(a2 + 40);
        v14 = 136315906;
        v15 = v6;
        v16 = 2080;
        v17 = "VCTimescalePSOLA_UpdateHistoryBuffer";
        v19 = 310;
        v18 = 1024;
        v20 = 1024;
        v21 = v5 / v9;
        _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Not enough samples to update PSOLA history buffer availableSamples=%d", (uint8_t *)&v14, 0x22u);
      }
    }
    else if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      v13 = *(_DWORD *)(a2 + 40);
      v14 = 136315906;
      v15 = v6;
      v16 = 2080;
      v17 = "VCTimescalePSOLA_UpdateHistoryBuffer";
      v19 = 310;
      v18 = 1024;
      v20 = 1024;
      v21 = v5 / v13;
      _os_log_debug_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Not enough samples to update PSOLA history buffer availableSamples=%d", (uint8_t *)&v14, 0x22u);
    }
  }
}

BOOL VCTimescalePSOLA_CheckCompressionPSOLA(uint64_t a1, int a2, int a3)
{
  return !a2 || a3 == 0;
}

uint64_t VCIDSChannelData_GetIDSAttributeSizeWithChannelDataFormat(uint64_t a1)
{
  __int16 v1;
  unsigned __int16 v2;

  if (a1)
  {
    if (*(_BYTE *)(a1 + 24))
      v1 = (*(_BYTE *)(a1 + 24) != 1) | (unsigned __int16)(2 * *(unsigned __int8 *)(a1 + 24));
    else
      v1 = 0;
    if (*(_BYTE *)(a1 + 30))
      v1 += 8;
    if (*(_BYTE *)(a1 + 28))
      ++v1;
    if (*(_BYTE *)(a1 + 25))
      v1 += 2;
    v2 = v1 + *(unsigned __int8 *)(a1 + 40);
    if (*(_BYTE *)(a1 + 42))
      v2 += 2;
    if (*(_WORD *)(a1 + 52))
      v2 += 10;
  }
  else
  {
    return 0;
  }
  return v2;
}

uint64_t VCIDSChannelData_GetIDSHeaderSizeWithChannelDataFormatArray(uint64_t a1, unsigned int a2)
{
  unsigned __int16 v2;
  __int16 v3;
  uint64_t v4;
  int v5;
  uint64_t v6;

  v2 = 0;
  if (a1)
  {
    v3 = a2;
    if (a2)
    {
      v4 = a1;
      v5 = 0;
      v6 = a2;
      do
      {
        v5 += VCIDSChannelData_GetIDSAttributeSizeWithChannelDataFormat(v4) + 2;
        v4 += 80;
        --v6;
      }
      while (v6);
      return (unsigned __int16)(v5 + 2 * v3 + 2);
    }
  }
  return v2;
}

uint64_t _VCImageQueue_applyLayerTransforms(uint64_t a1, int a2)
{
  uint64_t result;
  _BOOL4 v5;
  BOOL v6;
  int v7;
  void *v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  int v13;
  char v14;
  uint64_t v15;
  NSObject *v16;
  void *v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  CATransform3D v22;
  CATransform3D b;
  uint64_t v24;
  CGRect v25;

  v24 = *MEMORY[0x1E0C80C00];
  result = *(_QWORD *)(a1 + 184);
  if (result)
  {
    objc_msgSend((id)result, "contentsRect");
    v5 = CGRectEqualToRect(v25, *(CGRect *)(a1 + 192));
    v6 = v5;
    v7 = !v5;
    v8 = *(void **)(a1 + 184);
    if (v8)
      objc_msgSend(v8, "transform");
    else
      memset(&v22, 0, sizeof(v22));
    v9 = *(_OWORD *)(a1 + 304);
    *(_OWORD *)&b.m31 = *(_OWORD *)(a1 + 288);
    *(_OWORD *)&b.m33 = v9;
    v10 = *(_OWORD *)(a1 + 336);
    *(_OWORD *)&b.m41 = *(_OWORD *)(a1 + 320);
    *(_OWORD *)&b.m43 = v10;
    v11 = *(_OWORD *)(a1 + 240);
    *(_OWORD *)&b.m11 = *(_OWORD *)(a1 + 224);
    *(_OWORD *)&b.m13 = v11;
    v12 = *(_OWORD *)(a1 + 272);
    *(_OWORD *)&b.m21 = *(_OWORD *)(a1 + 256);
    *(_OWORD *)&b.m23 = v12;
    result = CATransform3DEqualToTransform(&v22, &b);
    v13 = result ^ 1;
    if ((v7 | result ^ 1) == 1)
    {
      v14 = result;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v15 = VRTraceErrorLogLevelToCSTR();
        v16 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(b.m11) = 136316674;
          *(_QWORD *)((char *)&b.m11 + 4) = v15;
          WORD2(b.m12) = 2080;
          *(_QWORD *)((char *)&b.m12 + 6) = "_VCImageQueue_applyLayerTransforms";
          HIWORD(b.m13) = 1024;
          LODWORD(b.m14) = 339;
          WORD2(b.m14) = 1024;
          *(_DWORD *)((char *)&b.m14 + 6) = 339;
          WORD1(b.m21) = 2048;
          *(_QWORD *)((char *)&b.m21 + 4) = a1;
          WORD2(b.m22) = 1024;
          *(_DWORD *)((char *)&b.m22 + 6) = v7;
          WORD1(b.m23) = 1024;
          HIDWORD(b.m23) = v13;
          _os_log_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VCImageQueue.m:%d: Applying layer transforms either on timeout or while we are not waiting for UI layout change, vcImageQueue=%p contentsRectDidChange=%d tranformDidChange=%d", (uint8_t *)&b, 0x38u);
        }
      }
      objc_msgSend(MEMORY[0x1E0CD28B0], "begin", *(_OWORD *)&v22.m11, *(_OWORD *)&v22.m13, *(_OWORD *)&v22.m21, *(_OWORD *)&v22.m23, *(_OWORD *)&v22.m31, *(_OWORD *)&v22.m33, *(_OWORD *)&v22.m41, *(_OWORD *)&v22.m43);
      objc_msgSend(MEMORY[0x1E0CD28B0], "setDisableActions:", 1);
      if (!v6)
        objc_msgSend(*(id *)(a1 + 184), "setContentsRect:", *(double *)(a1 + 192), *(double *)(a1 + 200), *(double *)(a1 + 208), *(double *)(a1 + 216));
      if ((v14 & 1) == 0 && *(_BYTE *)(a1 + 419))
      {
        v17 = *(void **)(a1 + 184);
        v18 = *(_OWORD *)(a1 + 304);
        *(_OWORD *)&b.m31 = *(_OWORD *)(a1 + 288);
        *(_OWORD *)&b.m33 = v18;
        v19 = *(_OWORD *)(a1 + 336);
        *(_OWORD *)&b.m41 = *(_OWORD *)(a1 + 320);
        *(_OWORD *)&b.m43 = v19;
        v20 = *(_OWORD *)(a1 + 240);
        *(_OWORD *)&b.m11 = *(_OWORD *)(a1 + 224);
        *(_OWORD *)&b.m13 = v20;
        v21 = *(_OWORD *)(a1 + 272);
        *(_OWORD *)&b.m21 = *(_OWORD *)(a1 + 256);
        *(_OWORD *)&b.m23 = v21;
        objc_msgSend(v17, "setTransform:", &b);
      }
      if (a2)
        CAImageQueueFlushWithTransaction();
      return objc_msgSend(MEMORY[0x1E0CD28B0], "commit");
    }
  }
  return result;
}

uint64_t VCImageQueue_setCALayerSize(uint64_t a1, uint64_t a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6)
{
  objc_msgSend(MEMORY[0x1E0CD28B0], "begin");
  objc_msgSend(MEMORY[0x1E0CD28B0], "setDisableActions:", 1);
  if (*(_QWORD *)(a1 + 176))
  {
    if (*(_QWORD *)(a1 + 184))
    {
      _VCImageQueue_configureCALayerBounds(a1, a2, a3, a4, a5, a6);
      _VCImageQueue_signalWaitForLayoutChangeCondition(a1);
      objc_msgSend(MEMORY[0x1E0CD28B0], "commit");
      return 1;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCImageQueue_setCALayerSize_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCImageQueue_setCALayerSize_cold_1();
  }
  objc_msgSend(MEMORY[0x1E0CD28B0], "commit");
  return 0;
}

void _VCImageQueue_configureCALayerBounds(uint64_t a1, uint64_t a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6)
{
  void *v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  void *v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  void *v22;
  void *v23;
  CGFloat v24;
  CGFloat v25;
  CGFloat v26;
  CGFloat v27;
  uint64_t v28;
  NSObject *v29;
  NSString *v30;
  uint64_t v31;
  NSObject *v32;
  void *v33;
  CGFloat v34;
  CATransform3D v35;
  CATransform3D b;
  uint64_t v37;
  CGRect v38;
  CGRect v39;
  CGRect v40;
  CGRect v41;
  CGRect v42;
  NSRect v43;
  CGRect v44;

  v37 = *MEMORY[0x1E0C80C00];
  objc_msgSend(*(id *)(a1 + 184), "contentsRect");
  if (!CGRectEqualToRect(v38, *(CGRect *)(a1 + 192)))
    objc_msgSend(*(id *)(a1 + 184), "setContentsRect:", *(double *)(a1 + 192), *(double *)(a1 + 200), *(double *)(a1 + 208), *(double *)(a1 + 216));
  v12 = *(void **)(a1 + 184);
  if (v12)
    objc_msgSend(v12, "transform");
  else
    memset(&v35, 0, sizeof(v35));
  v13 = *(_OWORD *)(a1 + 304);
  *(_OWORD *)&b.m31 = *(_OWORD *)(a1 + 288);
  *(_OWORD *)&b.m33 = v13;
  v14 = *(_OWORD *)(a1 + 336);
  *(_OWORD *)&b.m41 = *(_OWORD *)(a1 + 320);
  *(_OWORD *)&b.m43 = v14;
  v15 = *(_OWORD *)(a1 + 240);
  *(_OWORD *)&b.m11 = *(_OWORD *)(a1 + 224);
  *(_OWORD *)&b.m13 = v15;
  v16 = *(_OWORD *)(a1 + 272);
  *(_OWORD *)&b.m21 = *(_OWORD *)(a1 + 256);
  *(_OWORD *)&b.m23 = v16;
  if (!CATransform3DEqualToTransform(&v35, &b) && *(_BYTE *)(a1 + 419))
  {
    v17 = *(void **)(a1 + 184);
    v18 = *(_OWORD *)(a1 + 304);
    *(_OWORD *)&b.m31 = *(_OWORD *)(a1 + 288);
    *(_OWORD *)&b.m33 = v18;
    v19 = *(_OWORD *)(a1 + 336);
    *(_OWORD *)&b.m41 = *(_OWORD *)(a1 + 320);
    *(_OWORD *)&b.m43 = v19;
    v20 = *(_OWORD *)(a1 + 240);
    *(_OWORD *)&b.m11 = *(_OWORD *)(a1 + 224);
    *(_OWORD *)&b.m13 = v20;
    v21 = *(_OWORD *)(a1 + 272);
    *(_OWORD *)&b.m21 = *(_OWORD *)(a1 + 256);
    *(_OWORD *)&b.m23 = v21;
    objc_msgSend(v17, "setTransform:", &b);
  }
  if (!a2)
    goto LABEL_11;
  v22 = *(void **)(a1 + 184);
  v23 = (void *)objc_msgSend(v22, "context");
  *(_QWORD *)&b.m11 = MEMORY[0x1E0C809B0];
  *(_QWORD *)&b.m12 = 3221225472;
  *(_QWORD *)&b.m13 = ___VCImageQueue_setFenceWithCompletionHandler_block_invoke;
  *(_QWORD *)&b.m14 = &unk_1E9E52238;
  *(_QWORD *)&b.m21 = a2;
  *(_QWORD *)&b.m22 = v22;
  if ((objc_msgSend(v23, "addFence:completionHandler:", a2, &b) & 1) == 0)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v31 = VRTraceErrorLogLevelToCSTR();
      v32 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v33 = *(void **)(a1 + 184);
        v34 = COERCE_DOUBLE(objc_msgSend(v33, "context"));
        LODWORD(b.m11) = 136316674;
        *(_QWORD *)((char *)&b.m11 + 4) = v31;
        WORD2(b.m12) = 2080;
        *(_QWORD *)((char *)&b.m12 + 6) = "_VCImageQueue_configureCALayerBounds";
        HIWORD(b.m13) = 1024;
        LODWORD(b.m14) = 385;
        WORD2(b.m14) = 1024;
        *(_DWORD *)((char *)&b.m14 + 6) = 385;
        WORD1(b.m21) = 2048;
        *(_QWORD *)((char *)&b.m21 + 4) = a2;
        WORD2(b.m22) = 2048;
        *(_QWORD *)((char *)&b.m22 + 6) = v33;
        HIWORD(b.m23) = 2048;
        b.m24 = v34;
        _os_log_error_impl(&dword_1D8A54000, v32, OS_LOG_TYPE_ERROR, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VCImageQueue.m:%d: Failed to add fence=%p for remote layer=%p with context=%p", (uint8_t *)&b, 0x40u);
      }
    }
  }
  else
  {
LABEL_11:
    v39.origin.x = a3;
    v39.origin.y = a4;
    v39.size.width = a5;
    v39.size.height = a6;
    if (!CGRectIsNull(v39))
    {
      v40.origin.x = a3;
      v40.origin.y = a4;
      v40.size.width = a5;
      v40.size.height = a6;
      if (!CGRectIsEmpty(v40))
      {
        v41.origin.x = a3;
        v41.origin.y = a4;
        v41.size.width = a5;
        v41.size.height = a6;
        if (!CGRectEqualToRect(v41, *MEMORY[0x1E0C9D648]))
        {
          objc_msgSend(*(id *)(a1 + 184), "frame");
          v44.origin.x = v24;
          v44.origin.y = v25;
          v44.size.width = v26;
          v44.size.height = v27;
          v42.origin.x = a3;
          v42.origin.y = a4;
          v42.size.width = a5;
          v42.size.height = a6;
          if (!CGRectEqualToRect(v42, v44))
          {
            objc_msgSend(*(id *)(a1 + 184), "setFrame:", a3, a4, a5, a6);
            objc_msgSend(*(id *)(a1 + 184), "setPosition:", a5 * 0.5, a6 * 0.5);
            if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
            {
              v28 = VRTraceErrorLogLevelToCSTR();
              v29 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                v43.origin.x = a3;
                v43.origin.y = a4;
                v43.size.width = a5;
                v43.size.height = a6;
                v30 = NSStringFromRect(v43);
                LODWORD(b.m11) = 136316162;
                *(_QWORD *)((char *)&b.m11 + 4) = v28;
                WORD2(b.m12) = 2080;
                *(_QWORD *)((char *)&b.m12 + 6) = "_VCImageQueue_configureCALayerBounds";
                HIWORD(b.m13) = 1024;
                LODWORD(b.m14) = 390;
                WORD2(b.m14) = 1024;
                *(_DWORD *)((char *)&b.m14 + 6) = 390;
                WORD1(b.m21) = 2112;
                *(_QWORD *)((char *)&b.m21 + 4) = v30;
                _os_log_impl(&dword_1D8A54000, v29, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VCImageQueue.m:%d: configureCALayerBounds: frameRect=%@", (uint8_t *)&b, 0x2Cu);
              }
            }
          }
        }
      }
    }
  }
}

uint64_t _VCImageQueue_signalWaitForLayoutChangeCondition(uint64_t result)
{
  uint64_t v1;
  pthread_mutex_t *v2;

  if (!*(_BYTE *)(result + 408))
  {
    v1 = result;
    v2 = (pthread_mutex_t *)(result + 32);
    pthread_mutex_lock((pthread_mutex_t *)(result + 32));
    if (*(_BYTE *)(v1 + 352))
      pthread_cond_signal((pthread_cond_t *)(v1 + 360));
    return pthread_mutex_unlock(v2);
  }
  return result;
}

CGFloat getScreenTransformForVideoAttributes@<D0>(void *a1@<X0>, _OWORD *a2@<X8>)
{
  _OWORD *v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  unsigned int v8;
  CGFloat v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  CGFloat result;
  __int128 v14;
  CATransform3D v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v3 = (_OWORD *)MEMORY[0x1E0CD2610];
  v4 = *(_OWORD *)(MEMORY[0x1E0CD2610] + 80);
  a2[4] = *(_OWORD *)(MEMORY[0x1E0CD2610] + 64);
  a2[5] = v4;
  v5 = v3[7];
  a2[6] = v3[6];
  a2[7] = v5;
  v6 = v3[1];
  *a2 = *v3;
  a2[1] = v6;
  v7 = v3[3];
  a2[2] = v3[2];
  a2[3] = v7;
  v8 = objc_msgSend(a1, "orientation");
  v9 = 0.0;
  if (v8 <= 2)
    v9 = dbl_1D910CFB0[v8];
  CATransform3DMakeRotation(&v15, v9, 0.0, 0.0, 1.0);
  v10 = *(_OWORD *)&v15.m33;
  a2[4] = *(_OWORD *)&v15.m31;
  a2[5] = v10;
  v11 = *(_OWORD *)&v15.m43;
  a2[6] = *(_OWORD *)&v15.m41;
  a2[7] = v11;
  v12 = *(_OWORD *)&v15.m13;
  *a2 = *(_OWORD *)&v15.m11;
  a2[1] = v12;
  result = v15.m21;
  v14 = *(_OWORD *)&v15.m23;
  a2[2] = *(_OWORD *)&v15.m21;
  a2[3] = v14;
  return result;
}

CATransform3D *getTransformForVideoAttributes@<X0>(void *a1@<X0>, _OWORD *a2@<X8>)
{
  _OWORD *v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  float v9;
  float v10;
  CATransform3D *result;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  CATransform3D v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v4 = (_OWORD *)MEMORY[0x1E0CD2610];
  v5 = *(_OWORD *)(MEMORY[0x1E0CD2610] + 80);
  a2[4] = *(_OWORD *)(MEMORY[0x1E0CD2610] + 64);
  a2[5] = v5;
  v6 = v4[7];
  a2[6] = v4[6];
  a2[7] = v6;
  v7 = v4[1];
  *a2 = *v4;
  a2[1] = v7;
  v8 = v4[3];
  a2[2] = v4[2];
  a2[3] = v8;
  v9 = 0.0;
  if (objc_msgSend(a1, "camera") == 1)
    v10 = 3.1416;
  else
    v10 = 0.0;
  switch(objc_msgSend(a1, "orientation"))
  {
    case 0u:
      v9 = -1.5708;
      break;
    case 1u:
      v9 = 1.5708;
      break;
    case 2u:
    case 3u:
      v9 = v10 + 3.14159265;
      break;
    default:
      break;
  }
  result = CATransform3DMakeRotation(&v16, v9, 0.0, 0.0, 1.0);
  v12 = *(_OWORD *)&v16.m33;
  a2[4] = *(_OWORD *)&v16.m31;
  a2[5] = v12;
  v13 = *(_OWORD *)&v16.m43;
  a2[6] = *(_OWORD *)&v16.m41;
  a2[7] = v13;
  v14 = *(_OWORD *)&v16.m13;
  *a2 = *(_OWORD *)&v16.m11;
  a2[1] = v14;
  v15 = *(_OWORD *)&v16.m23;
  a2[2] = *(_OWORD *)&v16.m21;
  a2[3] = v15;
  return result;
}

void *VCImageQueue_remoteVideoAttributesChanged(void *result, void *a2)
{
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  const char *v6;
  _OWORD *v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  int v12;
  double v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  double v18;
  double v19;
  double v20;
  double v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  CGFloat v29;
  CGFloat v30;
  CGFloat v31;
  CGFloat v32;
  uint64_t v33;
  NSObject *v34;
  int v35;
  NSString *v36;
  NSString *v37;
  __int128 v38;
  _OWORD v39[5];
  CATransform3D a;
  CATransform3D buf;
  uint64_t v42;
  NSRect v43;
  CGRect v44;

  v42 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v3 = (uint64_t)result;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
    {
      v4 = VRTraceErrorLogLevelToCSTR();
      v5 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        if (a2)
          v6 = (const char *)objc_msgSend((id)objc_msgSend(a2, "description"), "UTF8String");
        else
          v6 = "<nil>";
        LODWORD(buf.m11) = 136316162;
        *(_QWORD *)((char *)&buf.m11 + 4) = v4;
        WORD2(buf.m12) = 2080;
        *(_QWORD *)((char *)&buf.m12 + 6) = "VCImageQueue_remoteVideoAttributesChanged";
        HIWORD(buf.m13) = 1024;
        LODWORD(buf.m14) = 704;
        WORD2(buf.m14) = 1024;
        *(_DWORD *)((char *)&buf.m14 + 6) = 704;
        WORD1(buf.m21) = 2080;
        *(_QWORD *)((char *)&buf.m21 + 4) = v6;
        _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VCImageQueue.m:%d: videoAttributes=%s", (uint8_t *)&buf, 0x2Cu);
      }
    }
    v7 = (_OWORD *)(v3 + 224);
    if (objc_msgSend(a2, "videoSourceScreen"))
      getScreenTransformForVideoAttributes(a2, &buf);
    else
      getTransformForVideoAttributes(a2, &buf);
    v8 = *(_OWORD *)&buf.m33;
    *(_OWORD *)(v3 + 288) = *(_OWORD *)&buf.m31;
    *(_OWORD *)(v3 + 304) = v8;
    v9 = *(_OWORD *)&buf.m43;
    *(_OWORD *)(v3 + 320) = *(_OWORD *)&buf.m41;
    *(_OWORD *)(v3 + 336) = v9;
    v10 = *(_OWORD *)&buf.m13;
    *v7 = *(_OWORD *)&buf.m11;
    *(_OWORD *)(v3 + 240) = v10;
    v11 = *(_OWORD *)&buf.m23;
    *(_OWORD *)(v3 + 256) = *(_OWORD *)&buf.m21;
    *(_OWORD *)(v3 + 272) = v11;
    v12 = objc_msgSend(a2, "videoSourceScreen");
    objc_msgSend(a2, "contentsRect");
    v17 = v16;
    if (v12)
    {
      objc_msgSend(a2, "contentsRect");
      v19 = 1.0 - v18;
      objc_msgSend(a2, "contentsRect");
      v21 = v19 - v20;
      objc_msgSend(a2, "contentsRect");
      v23 = v22;
      objc_msgSend(a2, "contentsRect");
    }
    else
    {
      v21 = v13;
      v23 = v14;
    }
    *(_QWORD *)(v3 + 192) = v17;
    *(double *)(v3 + 200) = v21;
    *(_QWORD *)(v3 + 208) = v23;
    *(_QWORD *)(v3 + 216) = v15;
    v24 = *(void **)(v3 + 184);
    if (v24)
    {
      objc_msgSend(v24, "transform");
      v25 = *(_OWORD *)(v3 + 304);
      *(_OWORD *)&a.m31 = *(_OWORD *)(v3 + 288);
      *(_OWORD *)&a.m33 = v25;
      v26 = *(_OWORD *)(v3 + 336);
      *(_OWORD *)&a.m41 = *(_OWORD *)(v3 + 320);
      *(_OWORD *)&a.m43 = v26;
      v27 = *(_OWORD *)(v3 + 240);
      *(_OWORD *)&a.m11 = *v7;
      *(_OWORD *)&a.m13 = v27;
      v28 = *(_OWORD *)(v3 + 272);
      *(_OWORD *)&a.m21 = *(_OWORD *)(v3 + 256);
      *(_OWORD *)&a.m23 = v28;
      if (!CATransform3DEqualToTransform(&a, &buf)
        || (objc_msgSend(*(id *)(v3 + 184), "contentsRect"),
            v44.origin.x = v29,
            v44.origin.y = v30,
            v44.size.width = v31,
            v44.size.height = v32,
            !CGRectEqualToRect(*(CGRect *)(v3 + 192), v44)))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v33 = VRTraceErrorLogLevelToCSTR();
          v34 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v35 = objc_msgSend(a2, "orientation");
            v36 = NSStringFromRect(*(NSRect *)(v3 + 192));
            objc_msgSend(*(id *)(v3 + 184), "contentsRect");
            v37 = NSStringFromRect(v43);
            LODWORD(a.m11) = 136316674;
            *(_QWORD *)((char *)&a.m11 + 4) = v33;
            WORD2(a.m12) = 2080;
            *(_QWORD *)((char *)&a.m12 + 6) = "_VCImageQueue_logLayerAttributes";
            HIWORD(a.m13) = 1024;
            LODWORD(a.m14) = 697;
            WORD2(a.m14) = 1024;
            *(_DWORD *)((char *)&a.m14 + 6) = 697;
            WORD1(a.m21) = 1024;
            HIDWORD(a.m21) = v35;
            LOWORD(a.m22) = 2112;
            *(_QWORD *)((char *)&a.m22 + 2) = v36;
            WORD1(a.m23) = 2112;
            *(_QWORD *)((char *)&a.m23 + 4) = v37;
            _os_log_impl(&dword_1D8A54000, v34, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VCImageQueue.m:%d: Transform updated for orientation=%d or ContentsRect changed to=%@ from=%@", (uint8_t *)&a, 0x3Cu);
          }
        }
      }
    }
    pthread_mutex_lock((pthread_mutex_t *)(v3 + 32));
    if (!*(_BYTE *)(v3 + 352))
      _VCImageQueue_applyLayerTransforms(v3, 0);
    pthread_mutex_unlock((pthread_mutex_t *)(v3 + 32));
    result = *(void **)(v3 + 144);
    if (result)
    {
      *(_OWORD *)&buf.m31 = xmmword_1D910CFA0;
      *(_OWORD *)&buf.m11 = xmmword_1D910CF60;
      memset(&buf.m13, 255, 48);
      objc_msgSend(result, "currentDetails");
      LOBYTE(buf.m11) = 1;
      v38 = *(_OWORD *)(v3 + 208);
      *(_OWORD *)&buf.m13 = *(_OWORD *)(v3 + 192);
      *(_OWORD *)&buf.m21 = v38;
      buf.m31 = *(CGFloat *)(v3 + 24);
      LODWORD(buf.m32) = objc_msgSend(a2, "camera");
      v39[2] = *(_OWORD *)&buf.m21;
      v39[3] = *(_OWORD *)&buf.m23;
      v39[0] = *(_OWORD *)&buf.m11;
      v39[1] = *(_OWORD *)&buf.m13;
      v39[4] = *(_OWORD *)&buf.m31;
      return (void *)objc_msgSend(*(id *)(v3 + 144), "setCurrentDetails:", v39);
    }
  }
  return result;
}

uint64_t _VCImageQueue_ApplyPreviewLayerTransforms(uint64_t result, int a2)
{
  uint64_t v2;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  int v9;
  CGFloat v10;
  CGFloat v11;
  CGFloat v12;
  CGFloat v13;
  CGFloat v14;
  CGFloat v15;
  int v16;
  int v17;
  CGFloat v18;
  int64_t v19;
  int v20;
  double v21;
  double v22;
  double v23;
  uint64_t v24;
  NSObject *v25;
  int v26;
  int v27;
  int64_t v28;
  float v29;
  double v30;
  float v31;
  float v32;
  double v33;
  BOOL v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  CATransform3D v43;
  CATransform3D v44;
  __int16 v45;
  CATransform3D v46;
  CATransform3D m;
  CATransform3D buf;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(result + 184))
  {
    v2 = result;
    if (*(_BYTE *)(result + 408))
    {
      v45 = 0;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
      {
        v4 = VRTraceErrorLogLevelToCSTR();
        v5 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v6 = *(_QWORD *)(v2 + 24);
          LODWORD(buf.m11) = 136316418;
          *(_QWORD *)((char *)&buf.m11 + 4) = v4;
          WORD2(buf.m12) = 2080;
          *(_QWORD *)((char *)&buf.m12 + 6) = "_VCImageQueue_ApplyPreviewLayerTransforms";
          HIWORD(buf.m13) = 1024;
          LODWORD(buf.m14) = 975;
          WORD2(buf.m14) = 1024;
          *(_DWORD *)((char *)&buf.m14 + 6) = 975;
          WORD1(buf.m21) = 2048;
          *(_QWORD *)((char *)&buf.m21 + 4) = v2;
          WORD2(buf.m22) = 2112;
          *(_QWORD *)((char *)&buf.m22 + 6) = v6;
          _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VCImageQueue.m:%d: vcImageQueue=%p LocalVideoAttributes=%@", (uint8_t *)&buf, 0x36u);
        }
      }
      result = FigCFDictionaryGetInt16IfPresent();
      if ((_DWORD)result)
      {
        v7 = v45 & 3;
        *(_QWORD *)&v8 = -1;
        *((_QWORD *)&v8 + 1) = -1;
        *(_OWORD *)&v44.m11 = v8;
        *(_OWORD *)&v44.m13 = v8;
        *(_OWORD *)&v44.m21 = v8;
        *(_OWORD *)&v44.m23 = v8;
        *(_OWORD *)&v44.m31 = v8;
        *(_OWORD *)&v44.m33 = v8;
        *(_OWORD *)&v44.m41 = v8;
        *(_OWORD *)&v44.m43 = v8;
        v9 = *(unsigned __int8 *)(v2 + 418);
        v10 = *MEMORY[0x1E0C9BAA8];
        v11 = *(double *)(MEMORY[0x1E0C9BAA8] + 8);
        v12 = *(double *)(MEMORY[0x1E0C9BAA8] + 16);
        v13 = *(double *)(MEMORY[0x1E0C9BAA8] + 24);
        v14 = *(double *)(MEMORY[0x1E0C9BAA8] + 32);
        v15 = *(double *)(MEMORY[0x1E0C9BAA8] + 40);
        if (-[VCHardwareSettingsEmbedded deviceClass](+[VCHardwareSettingsEmbedded sharedInstance](VCHardwareSettingsEmbedded, "sharedInstance"), "deviceClass") == 1)
        {
          buf.m11 = v10;
          buf.m12 = v11;
          buf.m13 = v12;
          buf.m14 = v13;
          buf.m21 = v14;
          buf.m22 = v15;
        }
        else
        {
          v16 = VCFeatureFlagManager_PreviewMSROptimizationForEmbedded();
          if (!v9
            || (v17 = v16,
                !+[VCHardwareSettings isExternalCameraSupported](VCHardwareSettings, "isExternalCameraSupported")))
          {
            __asm { BR              X9; loc_1D8C9FBB0 }
          }
          if (v17)
            v18 = 3.14159265;
          else
            v18 = -1.57079633;
          CGAffineTransformMakeRotation((CGAffineTransform *)&buf, v18);
        }
        CATransform3DMakeAffineTransform(&v44, (CGAffineTransform *)&buf);
        if (!*(_BYTE *)(v2 + 418))
        {
          v19 = -[VCHardwareSettingsEmbedded deviceClass](+[VCHardwareSettingsEmbedded sharedInstance](VCHardwareSettingsEmbedded, "sharedInstance"), "deviceClass");
          v20 = 0;
          if (v7 >= 2 && v19 == 1)
          {
            objc_msgSend(*(id *)(v2 + 184), "frame");
            v22 = v21;
            objc_msgSend(*(id *)(v2 + 184), "frame");
            if (v22 <= v23)
            {
              v20 = 0;
            }
            else
            {
              if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
              {
                v24 = VRTraceErrorLogLevelToCSTR();
                v25 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                {
                  objc_msgSend(*(id *)(v2 + 184), "frame");
                  v41 = v40;
                  objc_msgSend(*(id *)(v2 + 184), "frame");
                  LODWORD(buf.m11) = 136316674;
                  *(_QWORD *)((char *)&buf.m11 + 4) = v24;
                  WORD2(buf.m12) = 2080;
                  *(_QWORD *)((char *)&buf.m12 + 6) = "_VCImageQueue_IsPhoneInDominoMode";
                  HIWORD(buf.m13) = 1024;
                  LODWORD(buf.m14) = 963;
                  WORD2(buf.m14) = 1024;
                  *(_DWORD *)((char *)&buf.m14 + 6) = 963;
                  WORD1(buf.m21) = 1024;
                  HIDWORD(buf.m21) = v7;
                  LOWORD(buf.m22) = 2048;
                  *(_QWORD *)((char *)&buf.m22 + 2) = v41;
                  WORD1(buf.m23) = 2048;
                  *(_QWORD *)((char *)&buf.m23 + 4) = v42;
                  _os_log_error_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_ERROR, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VCImageQueue.m:%d: Detected iPhone in Domino mode orientation %d width %f height %f", (uint8_t *)&buf, 0x3Cu);
                }
              }
              v20 = 1;
            }
          }
          v26 = *(unsigned __int8 *)(v2 + 409);
          v27 = *(_DWORD *)(v2 + 412);
          v28 = -[VCHardwareSettingsEmbedded deviceClass](+[VCHardwareSettingsEmbedded sharedInstance](VCHardwareSettingsEmbedded, "sharedInstance", *(_QWORD *)&v44.m11, *(_QWORD *)&v44.m12, *(_QWORD *)&v44.m13, *(_QWORD *)&v44.m14, *(_QWORD *)&v44.m21, *(_QWORD *)&v44.m22, *(_QWORD *)&v44.m23, *(_QWORD *)&v44.m24, *(_QWORD *)&v44.m31, *(_QWORD *)&v44.m32, *(_QWORD *)&v44.m33, *(_QWORD *)&v44.m34, *(_QWORD *)&v44.m41, *(_QWORD *)&v44.m42, *(_QWORD *)&v44.m43, *(_QWORD *)&v44.m44),
                  "deviceClass");
          if (VCFeatureFlagManager_PreviewMSROptimizationForEmbedded())
          {
            if (v7 < 2)
            {
              v34 = v27 != 1 && v26 == 0;
              v31 = 1.0;
              if (v34)
                v32 = -1.0;
              else
                v32 = 1.0;
              v30 = 1.57079633;
            }
            else
            {
              if (v26)
                v29 = -1.0;
              else
                v29 = 1.0;
              v30 = dbl_1D910CFD0[v27 == 1];
              if (v27 == 1)
                v31 = 1.0;
              else
                v31 = -1.0;
              if (v27 == 1)
                v32 = 1.0;
              else
                v32 = v29;
              if (v20)
              {
                if ((_DWORD)v7 == 2)
                  v33 = -1.57079633;
                else
                  v33 = 1.57079633;
                v30 = v30 + v33;
              }
            }
            *(_QWORD *)&v35 = -1;
            *((_QWORD *)&v35 + 1) = -1;
            *(_OWORD *)&v46.m41 = v35;
            *(_OWORD *)&v46.m43 = v35;
            *(_OWORD *)&v46.m31 = v35;
            *(_OWORD *)&v46.m33 = v35;
            *(_OWORD *)&v46.m21 = v35;
            *(_OWORD *)&v46.m23 = v35;
            *(_OWORD *)&v46.m11 = v35;
            *(_OWORD *)&v46.m13 = v35;
            buf = v43;
            CATransform3DRotate(&v46, &buf, v30, 0.0, 0.0, 1.0);
            m = v46;
            CATransform3DScale(&buf, &m, v31, v32, 1.0);
            v46 = buf;
            v43 = buf;
          }
          else if (v28 == 4)
          {
            buf = v43;
            if (!(_DWORD)v7)
            {
              CGAffineTransformMakeRotation((CGAffineTransform *)&m, 1.57079633);
              CATransform3DMakeAffineTransform(&buf, (CGAffineTransform *)&m);
            }
            v43 = buf;
          }
          v44 = v43;
        }
        v36 = *(_OWORD *)&v44.m33;
        *(_OWORD *)(v2 + 288) = *(_OWORD *)&v44.m31;
        *(_OWORD *)(v2 + 304) = v36;
        v37 = *(_OWORD *)&v44.m43;
        *(_OWORD *)(v2 + 320) = *(_OWORD *)&v44.m41;
        *(_OWORD *)(v2 + 336) = v37;
        v38 = *(_OWORD *)&v44.m13;
        *(_OWORD *)(v2 + 224) = *(_OWORD *)&v44.m11;
        *(_OWORD *)(v2 + 240) = v38;
        v39 = *(_OWORD *)&v44.m23;
        *(_OWORD *)(v2 + 256) = *(_OWORD *)&v44.m21;
        *(_OWORD *)(v2 + 272) = v39;
        return _VCImageQueue_applyLayerTransforms(v2, a2);
      }
    }
  }
  return result;
}

void VCImageQueue_EffectsEnabledForPreview(uint64_t a1, int a2)
{
  uint64_t v4;
  NSObject *v5;
  int v6;
  uint64_t v7;
  __int16 v8;
  const char *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  int v13;
  __int16 v14;
  int v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v4 = VRTraceErrorLogLevelToCSTR();
      v5 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v6 = 136316162;
        v7 = v4;
        v8 = 2080;
        v9 = "VCImageQueue_EffectsEnabledForPreview";
        v10 = 1024;
        v11 = 1103;
        v12 = 1024;
        v13 = 1103;
        v14 = 1024;
        v15 = a2;
        _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/VCImageQueue.m:%d: effectsEnabled=%d", (uint8_t *)&v6, 0x28u);
      }
    }
    *(_BYTE *)(a1 + 409) = a2;
  }
}

uint64_t VCImageQueue_EnqueueSampleBuffer(uint64_t a1, opaqueCMSampleBuffer *a2)
{
  uint64_t v4;
  CMTimeEpoch epoch;
  __CVBuffer *ImageBuffer;
  uint64_t v7;
  CMTimeValue value;
  CMTimeScale timescale;
  CMTimeFlags flags;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  CMTime v17;
  CMTime time;
  int v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  opaqueCMSampleBuffer *v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v4 = MEMORY[0x1E0CA2E68];
  *(_OWORD *)&v17.value = *MEMORY[0x1E0CA2E68];
  epoch = *(_QWORD *)(MEMORY[0x1E0CA2E68] + 16);
  v17.epoch = epoch;
  if (a1 && a2)
  {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
    ImageBuffer = CMSampleBufferGetImageBuffer(a2);
    if (ImageBuffer)
      _VCImageQueue_DrawOverlayMessage(a1, ImageBuffer);
    v7 = *(_QWORD *)(a1 + 152);
    if (v7 && (VCStreamOutput_EnqueueSampleBuffer(*(_QWORD *)(a1 + 152), a2) & 1) == 0)
    {
      value = *(_QWORD *)v4;
      timescale = *(_DWORD *)(v4 + 8);
      flags = *(_DWORD *)(v4 + 12);
      _VCImageQueue_AverageFrameRate(a1);
    }
    else
    {
      CMSampleBufferGetPresentationTimeStamp(&time, a2);
      value = time.value;
      timescale = time.timescale;
      flags = time.flags;
      epoch = time.epoch;
      if (ImageBuffer)
      {
        v11 = _VCImageQueue_EnqueuePixelBuffer(a1, (uint64_t)ImageBuffer, &time, (uint64_t)&v17);
        v12 = v11;
        if (!v7 && !(_DWORD)v11)
          goto LABEL_11;
        goto LABEL_10;
      }
    }
    v12 = 1;
LABEL_10:
    time.value = value;
    time.timescale = timescale;
    time.flags = flags;
    time.epoch = epoch;
    *(double *)&v13 = CMTimeGetSeconds(&time);
    time = v17;
    _VCImageQueue_EmitFrameEnqueuedSignposts(a1, v13, &time, ImageBuffer);
LABEL_11:
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 32));
    return v12;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    v14 = VRTraceErrorLogLevelToCSTR();
    v15 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
    {
      LODWORD(time.value) = 136316162;
      *(CMTimeValue *)((char *)&time.value + 4) = v14;
      LOWORD(time.flags) = 2080;
      *(_QWORD *)((char *)&time.flags + 2) = "VCImageQueue_EnqueueSampleBuffer";
      HIWORD(time.epoch) = 1024;
      v19 = 1142;
      v20 = 2048;
      v21 = a1;
      v22 = 2048;
      v23 = a2;
      _os_log_error_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_ERROR, " [%s] %s:%d Invalid parameter. imageQueue=%p sampleBuffer=%p", (uint8_t *)&time, 0x30u);
    }
  }
  return 1;
}

CFIndex _VCImageQueue_AverageFrameRate(uint64_t a1)
{
  double v2;
  CFIndex result;
  const __CFArray *ValueAtIndex;
  const __CFNumber *v5;
  const __CFNumber *v6;
  int v7;
  double valuePtr[2];

  valuePtr[1] = *(double *)MEMORY[0x1E0C80C00];
  v2 = micro();
  _VCImageQueue_RemoveExpiredFrameCounts(a1, v2);
  result = CFArrayGetCount(*(CFArrayRef *)(a1 + 136));
  if (result)
  {
    ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 136), 0);
    v5 = (const __CFNumber *)CFArrayGetValueAtIndex(ValueAtIndex, 0);
    valuePtr[0] = 0.0;
    result = CFNumberGetValue(v5, kCFNumberDoubleType, valuePtr);
    if (v2 - valuePtr[0] >= 0.1)
    {
      v6 = (const __CFNumber *)CFArrayGetValueAtIndex(ValueAtIndex, 1);
      v7 = 0;
      return CFNumberGetValue(v6, kCFNumberSInt32Type, &v7);
    }
  }
  return result;
}

float _VCImageQueue_computeVisibleFrameRatio(uint64_t a1, float *a2)
{
  float result;
  float v4;
  __int128 v5;
  double v6[3];

  *(_OWORD *)v6 = *MEMORY[0x1E0C9D820];
  v5 = *(_OWORD *)(MEMORY[0x1E0C9D648] + 16);
  if (FigCFDictionaryGetCGRectIfPresent())
  {
    if (FigCFDictionaryGetCGSizeIfPresent())
    {
      result = v6[0] * *(double *)&v5;
      if (result != 0.0)
      {
        v4 = v6[1] * *((double *)&v5 + 1);
        if (v4 != 0.0)
        {
          result = result / v4;
          *a2 = result;
        }
      }
    }
  }
  return result;
}

void VCImageQueue_CleanupStreamOutput(uint64_t a1)
{
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VCImageQueue_CleanupStreamOutput_cold_1();
  }

  *(_QWORD *)(a1 + 152) = 0;
}

uint64_t _VCImageQueue_RemoveExpiredFrameCounts(uint64_t a1, double a2)
{
  uint64_t result;
  double v5;
  const __CFArray *ValueAtIndex;
  const __CFNumber *v7;
  double v8[2];

  v8[1] = *(double *)MEMORY[0x1E0C80C00];
  result = CFArrayGetCount(*(CFArrayRef *)(a1 + 136));
  if (result >= 1)
  {
    v5 = a2 + -10.0;
    do
    {
      ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 136), 0);
      v7 = (const __CFNumber *)CFArrayGetValueAtIndex(ValueAtIndex, 0);
      v8[0] = 0.0;
      result = CFNumberGetValue(v7, kCFNumberDoubleType, v8);
      if (v8[0] >= v5)
        break;
      CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 136), 0);
      result = CFArrayGetCount(*(CFArrayRef *)(a1 + 136));
    }
    while (result > 0);
  }
  return result;
}

void sub_1D8CA0ED8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1D8CA1268(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25)
{
  _Unwind_Resume(exception_object);
}

void VCAudioStreamSendGroup_PushAudioSamples(uint64_t a1, uint64_t a2)
{
  double v4;
  unsigned __int8 *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  int v14;
  uint64_t v15;
  uint64_t *v16;
  int v17;
  uint64_t v18;
  NSObject *v19;
  unsigned int *v20;
  unsigned int *v21;
  uint64_t **i;
  int Timestamp;
  double *SampleFormat;
  double HostTime;
  int v26;
  int v27;
  double v28;
  double *v29;
  uint64_t *v30;
  double v31;
  char Priority;
  int VoiceActivity;
  int v34;
  double v35;
  int v36;
  uint64_t v37;
  NSObject *v38;
  NSObject *v39;
  uint64_t v40;
  NSObject *v41;
  uint64_t v42;
  const void *v43;
  uint64_t v44;
  uint64_t *j;
  unsigned int *v46;
  _QWORD block[6];
  _BYTE buf[24];
  void *v49;
  uint64_t v50;
  uint64_t v51;
  char v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v4 = 0.0;
  if (VRTraceIsInternalOSInstalled())
    v4 = micro();
  v46 = (unsigned int *)a2;
  v5 = (unsigned __int8 *)CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 776));
  if (v5)
  {
    v13 = v5;
    v14 = 0;
    v15 = MEMORY[0x1E0C809B0];
    do
    {
      if (*v13)
      {
        *(_QWORD *)buf = v15;
        *(_QWORD *)&buf[8] = 3221225472;
        *(_QWORD *)&buf[16] = __VCAudioStreamSendGroup_UpdateActiveAudioStreams_block_invoke;
        v49 = &unk_1E9E55858;
        v50 = a1;
        v51 = (uint64_t)v13;
        _VCAudioStreamSendGroup_ProcessActiveStreams(a1, v13, (uint64_t)buf);
        v16 = *(uint64_t **)(*(_QWORD *)(a1 + 760) + 176);
        if (v16)
        {
          v17 = 0;
          do
          {
            if (*((_BYTE *)v16 + 8))
              v17 += *((_DWORD *)v16 + 12);
            v16 = (uint64_t *)*v16;
          }
          while (v16);
        }
        else
        {
          v17 = 0;
        }
        *(_DWORD *)(a1 + 488) = v17;
        v18 = MEMORY[0x1DF086F1C](a1 + 296);
        if (v18)
        {
          v19 = *(NSObject **)(a1 + 304);
          block[0] = v15;
          block[1] = 3221225472;
          block[2] = __VCAudioStreamSendGroup_UpdateActiveAudioStreams_block_invoke_2;
          block[3] = &unk_1E9E52238;
          block[4] = v18;
          block[5] = a1;
          dispatch_async(v19, block);
        }
      }
      ++v14;
      VCMemoryPool_Free(*(OSQueueHead **)(a1 + 792), v13);
      v13 = (unsigned __int8 *)CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 776));
    }
    while (v13);
  }
  LogProfileTimeOverLimit(v4, 0, v6, v7, v8, v9, v10, v11, v12, (char)"VCAudioStreamSendGroup_ProcessAudioStreamUpdateEvent");
  v20 = (unsigned int *)CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 784));
  if (v20)
  {
    v21 = v20;
    do
    {
      for (i = *(uint64_t ***)(*(_QWORD *)(a1 + 760) + 176); i; i = (uint64_t **)*i)
        objc_msgSend(i[5], "redundancyController:redundancyPercentageDidChange:", *(_QWORD *)(a1 + 480), *v21);
      VCMemoryPool_Free(*(OSQueueHead **)(a1 + 800), v21);
      v21 = (unsigned int *)CMSimpleQueueDequeue(*(CMSimpleQueueRef *)(a1 + 784));
    }
    while (v21);
  }
  Timestamp = VCAudioBufferList_GetTimestamp(a2);
  VCAudioBufferList_GetHostTime(a2);
  kdebug_trace();
  if (*(_BYTE *)(a1 + 492))
  {
    SampleFormat = (double *)VCAudioBufferList_GetSampleFormat(a2);
    HostTime = VCAudioBufferList_GetHostTime(a2);
    v26 = VCMediaStreamSendGroup_ModulateTimestampWithSourceTimestamp(a1, *SampleFormat, HostTime);
    VCAudioBufferList_SetTimestamp(a2, v26);
  }
  v27 = VCAudioBufferList_GetTimestamp(a2);
  v28 = VCAudioBufferList_GetHostTime(a2);
  v29 = (double *)objc_msgSend((id)objc_msgSend(*(id *)(a1 + 760), "audioIO"), "clientFormat");
  v30 = *(uint64_t **)(*(_QWORD *)(a1 + 760) + 192);
  if (v30)
  {
    v31 = *v29;
    do
    {
      VCMediaStreamSendGroup_UpdateSendSampleRTPTimestamp(*v30, v27, v31, v28);
      v30 = (uint64_t *)v30[2];
    }
    while (v30);
  }
  if (*(_BYTE *)(a1 + 312))
  {
    Priority = VCAudioBufferList_GetPriority((uint64_t)v46);
    VoiceActivity = VCAudioBufferList_GetVoiceActivity((uint64_t)v46);
    v34 = VCAudioBufferList_GetPriority((uint64_t)v46);
    if (*(_BYTE *)(a1 + 817))
    {
      v35 = micro();
      if (v35 - *(double *)(a1 + 824) > 1.0)
      {
        *(_BYTE *)(a1 + 818) = -[VCDefaults forceAudioPriorityValue](+[VCDefaults sharedInstance](VCDefaults, "sharedInstance"), "forceAudioPriorityValue");
        *(double *)(a1 + 824) = v35;
      }
      v36 = *(unsigned __int8 *)(a1 + 818);
      if (*(_BYTE *)(a1 + 818))
      {
        VCAudioBufferList_SetPriority((uint64_t)v46, *(_BYTE *)(a1 + 818));
        v34 = v36;
      }
    }
    if (*(_BYTE *)(a1 + 864))
    {
      if (v34)
        goto LABEL_43;
    }
    else if (v34 && (!*(_BYTE *)(*(_QWORD *)(a1 + 760) + 168) || *(_BYTE *)(a1 + 817)))
    {
      goto LABEL_43;
    }
    v34 = VCVoiceDetector_ProcessSampleBuffer(*(_QWORD **)(a1 + 832), (uint64_t)v46, objc_msgSend(*(id *)(a1 + 760), "isMuted"));
LABEL_43:
    if (v34 != *(unsigned __int8 *)(a1 + 816))
    {
      *(_BYTE *)(a1 + 816) = v34;
      v40 = MEMORY[0x1DF086F1C](a1 + 296);
      if (v40)
      {
        v41 = *(NSObject **)(a1 + 304);
        *(_QWORD *)buf = MEMORY[0x1E0C809B0];
        *(_QWORD *)&buf[8] = 3221225472;
        *(_QWORD *)&buf[16] = __VCAudioStreamSendGroup_UpdateAudioPriorityUplink_block_invoke;
        v49 = &unk_1E9E52210;
        v50 = v40;
        v51 = a1;
        v52 = v34;
        dispatch_async(v41, buf);
      }
    }
    *(float *)(a1 + 860) = VCAudioBufferList_GetAveragePower((uint64_t)v46);
    v42 = *(_QWORD *)(a1 + 840);
    if (v42)
    {
      v43 = VCSystemAudioCaptureSession_pullAudioSamples(v42);
      if (v43)
      {
        v44 = (uint64_t)v43;
        VCAudioBufferList_ApplyGain((uint64_t)v43, 0.3162);
        VCAudioDucker_Process(*(_QWORD *)(a1 + 848), (uint64_t)v46, v44);
        VCAudioBufferList_Mix((uint64_t)v46, v44);
        VCAudioBufferList_SetVoiceActivity((uint64_t)v46, 1);
      }
    }
    for (j = *(uint64_t **)(*(_QWORD *)(a1 + 760) + 176); j; j = (uint64_t *)*j)
    {
      if (*((_BYTE *)j + 8))
        VCAudioStream_PushAudioSamples(j[5], v46);
    }
    if (*(_BYTE *)(a1 + 856))
      VCMediaQueue_SchedulePackets(*(_QWORD *)(a1 + 808));
    VCAudioBufferList_SetTimestamp((uint64_t)v46, Timestamp);
    VCAudioBufferList_SetPriority((uint64_t)v46, Priority);
    VCAudioBufferList_SetVoiceActivity((uint64_t)v46, VoiceActivity);
    return;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v37 = VRTraceErrorLogLevelToCSTR();
    v38 = *MEMORY[0x1E0CF2758];
    v39 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = v37;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "VCAudioStreamSendGroup_PushAudioSamples";
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v49) = 837;
        _os_log_impl(&dword_1D8A54000, v38, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d audio no-op no MKM", buf, 0x1Cu);
      }
    }
    else if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
    {
      VCAudioStreamSendGroup_PushAudioSamples_cold_1();
    }
  }
  VCAudioBufferList_SetTimestamp((uint64_t)v46, Timestamp);
}

uint64_t _VCAudioStreamSendGroup_ProcessActiveStreams(uint64_t result, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t *v4;
  unsigned int v7;
  int v8;
  uint64_t *v9;
  int v10;
  _QWORD v11[3];

  v11[2] = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(result + 760);
  v11[0] = 0xAAAAAAAAAAAAAAAALL;
  v11[1] = 0xAAAAAAAAAAAAAAAALL;
  v4 = *(uint64_t **)(v3 + 176);
  if (v4)
  {
    v7 = 0;
    v8 = 0;
    v9 = 0;
    do
    {
      if (v7 < *a2
        && ((v10 = *(unsigned __int16 *)&a2[2 * v7 + 2], *((unsigned __int16 *)v4 + 16) == v10)
         || *((unsigned __int16 *)v4 + 17) == v10))
      {
        if (v9)
          result = (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, _QWORD *, _QWORD))(a3 + 16))(a3, v9, 1, v11, v8);
        v8 = 0;
        ++v7;
        v9 = v4;
      }
      else
      {
        result = (*(uint64_t (**)(uint64_t, uint64_t *, _QWORD, _QWORD, _QWORD))(a3 + 16))(a3, v4, 0, 0, 0);
      }
      if (!a2[18])
        *((_WORD *)v11 + v8++) = *((_WORD *)v4 + 16);
      if (*((_WORD *)v4 + 17))
        *((_WORD *)v11 + v8++) = *((_WORD *)v4 + 17);
      v4 = (uint64_t *)*v4;
    }
    while (v4);
    if (v9)
      return (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, _QWORD *, _QWORD))(a3 + 16))(a3, v9, 1, v11, v8);
  }
  return result;
}

void WriteYuvFrame(__CVBuffer *a1, uint64_t a2, char a3)
{
  NSObject *global_queue;
  _QWORD v7[6];
  char v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  CVPixelBufferRetain(a1);
  global_queue = dispatch_get_global_queue(0, 0);
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 3221225472;
  v7[2] = __WriteYuvFrame_block_invoke;
  v7[3] = &__block_descriptor_49_e5_v8__0l;
  v7[4] = a1;
  v7[5] = a2;
  v8 = a3;
  dispatch_async(global_queue, v7);
}

void DumpFrameYuvWithTimestamp(uint64_t a1, __CVBuffer *a2, int a3)
{
  uint64_t v5;
  NSObject *v6;
  __int128 v7;
  int Width;
  int Height;
  __int128 v10;
  FILE *v11;
  char __str[16];
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  _BYTE buf[32];
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  if (!a2 && (int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v5 = VRTraceErrorLogLevelToCSTR();
    v6 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = v5;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "DumpFrameYuvWithTimestamp";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 195;
      _os_log_impl(&dword_1D8A54000, v6, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d frame is null", buf, 0x1Cu);
    }
  }
  *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v41 = v7;
  v42 = v7;
  v39 = v7;
  v40 = v7;
  v37 = v7;
  v38 = v7;
  v35 = v7;
  v36 = v7;
  v33 = v7;
  v34 = v7;
  v31 = v7;
  v32 = v7;
  v29 = v7;
  v30 = v7;
  *(_OWORD *)buf = v7;
  *(_OWORD *)&buf[16] = v7;
  __strlcpy_chk();
  __strlcat_chk();
  mkdir(buf, 0x1FFu);
  Width = CVPixelBufferGetWidth(a2);
  Height = CVPixelBufferGetHeight(a2);
  *(_QWORD *)&v10 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v26 = v10;
  v27 = v10;
  v24 = v10;
  v25 = v10;
  v22 = v10;
  v23 = v10;
  v20 = v10;
  v21 = v10;
  v18 = v10;
  v19 = v10;
  v16 = v10;
  v17 = v10;
  v14 = v10;
  v15 = v10;
  *(_OWORD *)__str = v10;
  v13 = v10;
  snprintf(__str, 0x100uLL, "%s%dx%d.%08X.yuv", buf, Width, Height, a3);
  v11 = fopen(__str, "wb");
  if (v11)
    WriteYuvFrame(a2, (uint64_t)v11, 1);
}

void DumpFrameYuv(size_t *a1, size_t *a2, FILE **a3, int a4, CVPixelBufferRef pixelBuffer)
{
  size_t v9;
  size_t v10;
  __int128 v11;
  size_t Width;
  size_t Height;
  char __str[16];
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v9 = *a1;
  if (v9 != CVPixelBufferGetHeight(pixelBuffer) || (v10 = *a2, v10 != CVPixelBufferGetWidth(pixelBuffer)))
  {
    if (*a3)
      fclose(*a3);
    *(_QWORD *)&v11 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v28 = v11;
    v29 = v11;
    v26 = v11;
    v27 = v11;
    v24 = v11;
    v25 = v11;
    v22 = v11;
    v23 = v11;
    v20 = v11;
    v21 = v11;
    v18 = v11;
    v19 = v11;
    v16 = v11;
    v17 = v11;
    *(_OWORD *)__str = v11;
    v15 = v11;
    Width = CVPixelBufferGetWidth(pixelBuffer);
    Height = CVPixelBufferGetHeight(pixelBuffer);
    snprintf(__str, 0x100uLL, "%s-txSourceYuv.%zux%zu.%s.yuv", "/tmp/vcp/", Width, Height, "2vuy");
    *a3 = fopen(__str, "wb");
    *a2 = CVPixelBufferGetWidth(pixelBuffer);
    *a1 = CVPixelBufferGetHeight(pixelBuffer);
  }
  WriteYuvFrame(pixelBuffer, (uint64_t)*a3, 0);
}

const opaqueCMFormatDescription *extractAvcCFromFormatDescriptionForLog(const opaqueCMFormatDescription *Extension)
{
  uint64_t v2;
  NSObject *v3;
  CFTypeID TypeID;
  CFTypeID v5;
  int v7;
  uint64_t v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  int v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v7 = 136315650;
      v8 = v2;
      v9 = 2080;
      v10 = "extractAvcCFromFormatDescriptionForLog";
      v11 = 1024;
      v12 = 245;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d SPSPPS-extractAvcCFromFormatDescriptionForLog() was called", (uint8_t *)&v7, 0x1Cu);
    }
  }
  if (Extension)
  {
    Extension = (const opaqueCMFormatDescription *)CMFormatDescriptionGetExtension(Extension, (CFStringRef)*MEMORY[0x1E0CA2240]);
    if (Extension)
    {
      TypeID = CFDictionaryGetTypeID();
      if (TypeID == CFGetTypeID(Extension))
      {
        Extension = (const opaqueCMFormatDescription *)CFDictionaryGetValue(Extension, CFSTR("avcC"));
        if (Extension)
        {
          v5 = CFArrayGetTypeID();
          if (v5 == CFGetTypeID(Extension))
            return (const opaqueCMFormatDescription *)CFArrayGetValueAtIndex(Extension, 0);
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return Extension;
}

uint64_t readAVCCAndEncodeH264SPSPPS(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v7;
  NSObject *v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  uint64_t v19;
  unsigned int v20;
  unsigned int v21;
  int v22;
  int v23;
  int v25;
  uint64_t v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  int v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v7 = VRTraceErrorLogLevelToCSTR();
    v8 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v25 = 136315650;
      v26 = v7;
      v27 = 2080;
      v28 = "readAVCCAndEncodeH264SPSPPS";
      v29 = 1024;
      v30 = 269;
      _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d SPSPPS-readAVCCAndEncodeH264SPSPPS() was called", (uint8_t *)&v25, 0x1Cu);
    }
  }
  v9 = *(_BYTE *)(a1 + 5) & 0x1F;
  if ((*(_BYTE *)(a1 + 5) & 0x1F) != 0)
  {
    v10 = 0;
    v11 = 6;
    do
    {
      v12 = v11;
      v13 = *(unsigned __int16 *)(a1 + v11);
      v14 = bswap32(v13);
      v15 = v12 + 2;
      *(_DWORD *)(a3 + v10) = kVideoUtilStartCode;
      v16 = v10 + 4;
      memcpy((void *)(a3 + v10 + 4), (const void *)(a1 + v12 + 2), __rev16(v13));
      v11 = v15 + HIWORD(v14);
      v10 = v16 + HIWORD(v14);
      --v9;
    }
    while (v9);
  }
  else
  {
    v10 = 0;
    v11 = 6;
  }
  v17 = *(unsigned __int8 *)(a1 + v11);
  if (*(_BYTE *)(a1 + v11))
  {
    v18 = v11 + 1;
    do
    {
      v19 = v18;
      v20 = *(unsigned __int16 *)(a1 + v18);
      v21 = bswap32(v20);
      v22 = v19 + 2;
      *(_DWORD *)(a3 + v10) = kVideoUtilStartCode;
      v23 = v10 + 4;
      memcpy((void *)(a3 + v10 + 4), (const void *)(a1 + v19 + 2), __rev16(v20));
      v18 = v22 + HIWORD(v21);
      v10 = v23 + HIWORD(v21);
      --v17;
    }
    while (v17);
  }
  *a4 = v10;
  return 0;
}

uint64_t gksVCPParseConfigurationRecordAndCreateParameterSets(int a1)
{
  uint64_t v2;
  NSObject *v3;
  int v5;
  uint64_t v6;
  __int16 v7;
  const char *v8;
  __int16 v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v2 = VRTraceErrorLogLevelToCSTR();
    v3 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v5 = 136315650;
      v6 = v2;
      v7 = 2080;
      v8 = "gksVCPParseConfigurationRecordAndCreateParameterSets";
      v9 = 1024;
      v10 = 313;
      _os_log_impl(&dword_1D8A54000, v3, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d SPSPPS-gksVCPParseConfigurationRecordAndCreateParameterSets() was called", (uint8_t *)&v5, 0x1Cu);
    }
  }
  if (a1 == 1752589105)
    return VCPParseConfigurationRecordAndCreateParameterSets();
  else
    return 1061109567;
}

uint64_t gksVCPParseParameterSetsAndCreateConfigurationRecord()
{
  uint64_t v0;
  NSObject *v1;
  int v3;
  uint64_t v4;
  __int16 v5;
  const char *v6;
  __int16 v7;
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v0 = VRTraceErrorLogLevelToCSTR();
    v1 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v3 = 136315650;
      v4 = v0;
      v5 = 2080;
      v6 = "gksVCPParseParameterSetsAndCreateConfigurationRecord";
      v7 = 1024;
      v8 = 330;
      _os_log_impl(&dword_1D8A54000, v1, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d SPSPPS-gksVCPParseParameterSetsAndCreateConfigurationRecord() was called", (uint8_t *)&v3, 0x1Cu);
    }
  }
  return VCPParseParameterSetsAndCreateConfigurationRecord();
}

void VideoUtil_AddFakeLargeFrameData(uint64_t a1, uint64_t a2, int *a3)
{
  int v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  int v11;
  signed int v12;
  uint64_t v13;
  NSObject *v14;
  int v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  __int16 v28;
  signed int v29;
  __int16 v30;
  unsigned int v31;
  __int16 v32;
  unsigned int v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v6 = *a3;
  if (*a3 < 1)
  {
    v8 = 0;
    v9 = 0;
    v7 = 0;
  }
  else
  {
    v7 = 0;
    do
    {
      v8 = bswap32(*(_DWORD *)(a2 + v7));
      v9 = v8 + 4;
      v7 += v8 + 4;
    }
    while (v7 < v6);
  }
  if (v7 == v6)
  {
    v10 = *(_DWORD *)(a1 + 172) - v6;
    if (v10 >= 1)
    {
      if (v10 <= 8)
        v11 = 8;
      else
        v11 = *(_DWORD *)(a1 + 172) - v6;
      v12 = v6 - v9;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v13 = VRTraceErrorLogLevelToCSTR();
        v14 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v15 = *a3;
          v16 = *(_DWORD *)(a1 + 172);
          v18 = 136316930;
          v19 = v13;
          v20 = 2080;
          v21 = "VideoUtil_AddFakeLargeFrameData";
          v22 = 1024;
          v23 = 372;
          v24 = 1024;
          v25 = v15;
          v26 = 1024;
          v27 = v16;
          v28 = 1024;
          v29 = v12;
          v30 = 1024;
          v31 = v8;
          v32 = 1024;
          v33 = v8 + v11;
          _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Fake frame: iLen: %d  LargeFrame: %d  iLastJumpIndex: %d  dwLastGobSize: %d  dwLastGobNewSize: %d \n", (uint8_t *)&v18, 0x3Au);
        }
      }
      *(_DWORD *)(a2 + v12) = bswap32(v8 + v11);
      v17 = *a3 + (uint64_t)v11;
      *a3 = v17;
      *(_DWORD *)(a2 + v17 - 8) = bswap32(v8);
      *(_DWORD *)(a2 + *a3 - 4) = 1357975584;
    }
  }
}

void VideoUtil_PrintFormatDesc(const opaqueCMFormatDescription *a1)
{
  FourCharCode MediaSubType;
  uint64_t v3;
  NSObject *v4;
  CFDictionaryRef Extensions;
  int ErrorLogLevelForModule;
  uint64_t v7;
  NSObject *v8;
  const char *v9;
  NSObject *v10;
  uint32_t v11;
  uint64_t v12;
  NSObject *v13;
  int v14;
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    MediaSubType = CMFormatDescriptionGetMediaSubType(a1);
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v3 = VRTraceErrorLogLevelToCSTR();
      v4 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v14 = 136315906;
        v15 = v3;
        v16 = 2080;
        v17 = "VideoUtil_PrintFormatDesc";
        v18 = 1024;
        v19 = 394;
        v20 = 2080;
        v21 = FourccToCStr(MediaSubType);
        _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Codec Type is %s", (uint8_t *)&v14, 0x26u);
      }
    }
    Extensions = CMFormatDescriptionGetExtensions(a1);
    ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    if (Extensions)
    {
      if (ErrorLogLevelForModule >= 7)
      {
        v7 = VRTraceErrorLogLevelToCSTR();
        v8 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v14 = 136315906;
          v15 = v7;
          v16 = 2080;
          v17 = "VideoUtil_PrintFormatDesc";
          v18 = 1024;
          v19 = 397;
          v20 = 2112;
          v21 = (char *)Extensions;
          v9 = " [%s] %s:%d extensions are %@";
          v10 = v8;
          v11 = 38;
LABEL_15:
          _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v14, v11);
        }
      }
    }
    else if (ErrorLogLevelForModule >= 7)
    {
      v12 = VRTraceErrorLogLevelToCSTR();
      v13 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v14 = 136315650;
        v15 = v12;
        v16 = 2080;
        v17 = "VideoUtil_PrintFormatDesc";
        v18 = 1024;
        v19 = 399;
        v9 = " [%s] %s:%d extensions are NULL";
        v10 = v13;
        v11 = 28;
        goto LABEL_15;
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VideoUtil_PrintFormatDesc_cold_1();
  }
}

size_t VideoUtil_ExtractSPSPPSFromSampleBuffer(opaqueCMSampleBuffer *a1, uint64_t a2, size_t a3)
{
  CMFormatDescriptionRef FormatDescription;
  const opaqueCMFormatDescription *v6;
  char v7;
  size_t v8;
  size_t v9;
  size_t v10;
  size_t v11;
  char v12;
  int NALUnitHeaderLengthOut;
  size_t parameterSetCountOut;
  size_t parameterSetSizeOut;
  uint8_t *parameterSetPointerOut[2];

  parameterSetPointerOut[1] = *(uint8_t **)MEMORY[0x1E0C80C00];
  FormatDescription = CMSampleBufferGetFormatDescription(a1);
  if (FormatDescription)
  {
    v6 = FormatDescription;
    v7 = 0;
    v8 = 0;
    v9 = 0;
    while (1)
    {
      parameterSetSizeOut = 0;
      parameterSetPointerOut[0] = 0;
      parameterSetCountOut = 0;
      NALUnitHeaderLengthOut = 0;
      if (CMVideoFormatDescriptionGetH264ParameterSetAtIndex(v6, v8, (const uint8_t **)parameterSetPointerOut, &parameterSetSizeOut, &parameterSetCountOut, &NALUnitHeaderLengthOut))
      {
        break;
      }
      v10 = parameterSetSizeOut;
      v11 = parameterSetSizeOut + v9 + 4;
      if (v11 > a3)
        break;
      *(_DWORD *)(a2 + v9) = bswap32(parameterSetSizeOut);
      memcpy((void *)(a2 + v9 + 4), parameterSetPointerOut[0], v10);
      v12 = (v8 >= parameterSetCountOut - 1) | v7;
      v7 = 1;
      v8 = 1;
      v9 = v11;
      if ((v12 & 1) != 0)
        return v11;
    }
  }
  return 0;
}

void VideoUtil_PrintBuffer(unsigned __int8 *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v6;
  size_t v7;
  int v8;
  uint64_t v9;
  NSObject *v10;
  const char *v11;
  uint8_t buf[4];
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  uint64_t v19;
  __int16 v20;
  unint64_t v21;
  __int16 v22;
  char *v23;
  __int16 v24;
  const char *v25;
  char v26[601];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  bzero(v26, 0x259uLL);
  if (a2)
  {
    if (a1)
    {
      if (a3)
      {
        if (a3 >= 0xC8)
          v6 = 200;
        else
          v6 = a3;
        v7 = 3 * v6;
        do
        {
          v8 = *a1++;
          __snprintf_chk(v26, v7, 0, 0x259uLL, "%s%02x ", v26, v8);
          --v6;
        }
        while (v6);
        if ((int)VRTraceGetErrorLogLevelForModule() > 6)
        {
          v9 = VRTraceErrorLogLevelToCSTR();
          v10 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v11 = "...|";
            *(_DWORD *)buf = 136316674;
            v13 = v9;
            v15 = "VideoUtil_PrintBuffer";
            v14 = 2080;
            if (a3 > 0xC8)
              v11 = "|";
            v16 = 1024;
            v17 = 461;
            v18 = 2080;
            v19 = a2;
            v20 = 2048;
            v21 = a3;
            v22 = 2080;
            v23 = v26;
            v24 = 2080;
            v25 = v11;
            _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d bufferName='%s': Size=%zu, Buffer=|%s%s", buf, 0x44u);
          }
        }
      }
      else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VideoUtil_PrintBuffer_cold_3();
      }
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoUtil_PrintBuffer_cold_2();
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VideoUtil_PrintBuffer_cold_1();
  }
}

uint64_t VideoUtil_BlockBufferToString(OpaqueCMBlockBuffer *a1, char *a2, uint64_t a3)
{
  size_t v6;
  size_t DataLength;
  char *v8;
  uint64_t result;
  uint64_t v10;

  v6 = (unint64_t)(a3 - 1) >> 1;
  DataLength = CMBlockBufferGetDataLength(a1);
  if (v6 >= DataLength)
    v6 = DataLength;
  v8 = &a2[a3];
  result = CMBlockBufferCopyDataBytes(a1, 0, v6, &v8[-v6]);
  if (v6)
  {
    v10 = -(uint64_t)v6;
    do
    {
      result = sprintf(a2, "%02x", v8[v10]);
      a2 += 2;
    }
    while (!__CFADD__(v10++, 1));
  }
  return result;
}

BOOL VideoUtil_LayerBoundsAreValid(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4)
{
  CGRect v9;
  CGRect v10;

  if (CGRectIsNull(*(CGRect *)&a1))
    return 0;
  v9.origin.x = a1;
  v9.origin.y = a2;
  v9.size.width = a3;
  v9.size.height = a4;
  if (CGRectIsEmpty(v9))
    return 0;
  v10.origin.x = a1;
  v10.origin.y = a2;
  v10.size.width = a3;
  v10.size.height = a4;
  return !CGRectEqualToRect(v10, *MEMORY[0x1E0C9D648]);
}

void VideoUtil_AddImgDescToBitstream(CMSampleBufferRef sbuf, uint64_t a2, int a3, int a4, uint64_t a5, int *a6, size_t a7)
{
  opaqueCMSampleBuffer *v10;
  const opaqueCMFormatDescription *FormatDescription;
  int ErrorLogLevelForModule;
  uint64_t v15;
  NSObject *v16;
  const __CFDictionary *Extension;
  const __CFDictionary *v18;
  CFTypeID TypeID;
  const __CFData *Value;
  const __CFData *ValueAtIndex;
  CFTypeID v22;
  CFIndex Length;
  int v24;
  size_t v25;
  char *v26;
  CFStringEncoding SystemEncoding;
  __int128 v28;
  unint64_t SPSPPSFromSampleBuffer;
  size_t DataLength;
  size_t v31;
  uint64_t v32;
  NSObject *v33;
  int v34;
  uint64_t v35;
  CMBlockBufferRef v36;
  unint64_t v37;
  char *v38;
  _BYTE v39[64];
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  uint64_t v61;

  v10 = sbuf;
  v61 = *MEMORY[0x1E0C80C00];
  if (!sbuf)
    goto LABEL_29;
  v37 = 0;
  v38 = 0;
  FormatDescription = CMSampleBufferGetFormatDescription(sbuf);
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  if (FormatDescription)
  {
    if (ErrorLogLevelForModule >= 7)
    {
      v15 = VRTraceErrorLogLevelToCSTR();
      v16 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v39 = 136315906;
        *(_QWORD *)&v39[4] = v15;
        *(_WORD *)&v39[12] = 2080;
        *(_QWORD *)&v39[14] = "VideoUtil_AddImgDescToBitstream";
        *(_WORD *)&v39[22] = 1024;
        *(_DWORD *)&v39[24] = 505;
        *(_WORD *)&v39[28] = 1024;
        *(_DWORD *)&v39[30] = a3;
        _os_log_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d FigSampleBufferGetFormatDescription: show format desc, %d", v39, 0x22u);
      }
    }
    VideoUtil_PrintFormatDesc(FormatDescription);
    if (a3)
    {
      if (a4 != 1752589105)
      {
        *(_QWORD *)&v28 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v28 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v59 = v28;
        v60 = v28;
        v57 = v28;
        v58 = v28;
        v55 = v28;
        v56 = v28;
        v53 = v28;
        v54 = v28;
        v51 = v28;
        v52 = v28;
        v49 = v28;
        v50 = v28;
        v47 = v28;
        v48 = v28;
        v45 = v28;
        v46 = v28;
        v43 = v28;
        v44 = v28;
        v41 = v28;
        v42 = v28;
        *(_OWORD *)&v39[48] = v28;
        v40 = v28;
        *(_OWORD *)&v39[16] = v28;
        *(_OWORD *)&v39[32] = v28;
        *(_OWORD *)v39 = v28;
        SPSPPSFromSampleBuffer = VideoUtil_ExtractSPSPPSFromSampleBuffer(v10, (uint64_t)v39, 0x190uLL);
        LODWORD(v10) = SPSPPSFromSampleBuffer;
        v37 = SPSPPSFromSampleBuffer;
        if (_VideoUtil_PrependParameterSetsToBuffer(v39, SPSPPSFromSampleBuffer, (char *)a5, *a6, a7))
          return;
LABEL_27:
        if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
          VideoUtil_PrintBuffer((unsigned __int8 *)a5, (uint64_t)"Tx Aggregation Packet", v37);
LABEL_29:
        if (a3)
        {
LABEL_31:
          *a6 += (int)v10;
          return;
        }
LABEL_30:
        *(_DWORD *)a5 = bswap32((_DWORD)v10 - 4);
        *(_DWORD *)(a5 + 4) = -1547639150;
        goto LABEL_31;
      }
      Extension = (const __CFDictionary *)CMFormatDescriptionGetExtension(FormatDescription, (CFStringRef)*MEMORY[0x1E0CA2240]);
      if (Extension)
      {
        v18 = Extension;
        TypeID = CFDictionaryGetTypeID();
        if (TypeID == CFGetTypeID(v18))
        {
          Value = (const __CFData *)CFDictionaryGetValue(v18, CFSTR("hvcC"));
          if (Value)
          {
            ValueAtIndex = Value;
            v22 = CFArrayGetTypeID();
            if (v22 != CFGetTypeID(ValueAtIndex)
              || (ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(ValueAtIndex, 0)) != 0)
            {
              CFDataGetBytePtr(ValueAtIndex);
              Length = CFDataGetLength(ValueAtIndex);
              v24 = Length;
              MEMORY[0x1E0C80A78](Length);
              v26 = (char *)&v35 - ((v25 + 15) & 0x1FFFFFFF0);
              if (v25)
                memset((char *)&v35 - ((v25 + 15) & 0x1FFFFFFF0), 170, v25);
              bzero(v26, v24);
              v37 = v24;
              if ((unsigned __int16)gksVCPParseConfigurationRecordAndCreateParameterSets(1752589105))
              {
                if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
                {
                  VRTraceErrorLogLevelToCSTR();
                  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                    VideoUtil_AddImgDescToBitstream_cold_5();
                }
                return;
              }
              if (_VideoUtil_PrependParameterSetsToBuffer(v26, v37, (char *)a5, *a6, a7))
                return;
              LODWORD(v10) = v37;
              goto LABEL_27;
            }
          }
        }
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VideoUtil_AddImgDescToBitstream_cold_4();
      }
    }
    else
    {
      v36 = 0;
      SystemEncoding = CFStringGetSystemEncoding();
      if (CMVideoFormatDescriptionCopyAsBigEndianImageDescriptionBlockBuffer(0, FormatDescription, SystemEncoding, 0, &v36))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VideoUtil_AddImgDescToBitstream_cold_3();
        }
      }
      else if (CMBlockBufferGetDataPointer(v36, 0, 0, 0, &v38))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VideoUtil_AddImgDescToBitstream_cold_2();
        }
      }
      else
      {
        DataLength = CMBlockBufferGetDataLength(v36);
        LODWORD(v10) = DataLength + 8;
        v31 = *a6;
        if ((int)DataLength + 8 + (int)v31 <= (int)a7)
        {
          memmove((void *)(a5 + (int)v10), (const void *)a5, v31);
          memcpy((void *)(a5 + 8), v38, DataLength);
          FigBlockBufferRelease();
          goto LABEL_30;
        }
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v32 = VRTraceErrorLogLevelToCSTR();
          v33 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            v34 = *a6;
            *(_DWORD *)v39 = 136316418;
            *(_QWORD *)&v39[4] = v32;
            *(_WORD *)&v39[12] = 2080;
            *(_QWORD *)&v39[14] = "VideoUtil_AddImgDescToBitstream";
            *(_WORD *)&v39[22] = 1024;
            *(_DWORD *)&v39[24] = 532;
            *(_WORD *)&v39[28] = 2048;
            *(_QWORD *)&v39[30] = a7;
            *(_WORD *)&v39[38] = 1024;
            *(_DWORD *)&v39[40] = v34;
            *(_WORD *)&v39[44] = 1024;
            *(_DWORD *)&v39[46] = DataLength + 8;
            _os_log_error_impl(&dword_1D8A54000, v33, OS_LOG_TYPE_ERROR, " [%s] %s:%d Buffer too small. allocatedBufferSize=%zu, bufferSize=%d, header_bytes=%d", v39, 0x32u);
          }
        }
      }
      if (v36)
        FigBlockBufferRelease();
    }
  }
  else if (ErrorLogLevelForModule >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VideoUtil_AddImgDescToBitstream_cold_1();
  }
}

uint64_t _VideoUtil_PrependParameterSetsToBuffer(const void *a1, size_t a2, char *__src, size_t __len, size_t a5)
{
  uint64_t v8;
  NSObject *v9;
  int v13;
  uint64_t v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  size_t v20;
  __int16 v21;
  size_t v22;
  __int16 v23;
  size_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (__len + a2 <= a5)
  {
    memmove(&__src[a2], __src, __len);
    memcpy(__src, a1, a2);
    return 0;
  }
  else
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      v8 = VRTraceErrorLogLevelToCSTR();
      v9 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        v13 = 136316418;
        v14 = v8;
        v15 = 2080;
        v16 = "_VideoUtil_PrependParameterSetsToBuffer";
        v17 = 1024;
        v18 = 436;
        v19 = 2048;
        v20 = a5;
        v21 = 2048;
        v22 = __len;
        v23 = 2048;
        v24 = a2;
        _os_log_error_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_ERROR, " [%s] %s:%d Buffer too small. allocatedBufferSize=%zu, bufferSize=%zu, parameterSetSize=%zu", (uint8_t *)&v13, 0x3Au);
      }
    }
    return 0xFFFFFFFFLL;
  }
}

unint64_t VideoUtil_ReseizeFrameForBufferpool(int a1, int a2, int a3, int a4)
{
  const __CFAllocator *v4;
  CFNumberRef v5;
  CFNumberRef v6;
  CFNumberRef v7;
  CFNumberRef v8;
  const CFDictionaryKeyCallBacks *v9;
  const CFDictionaryValueCallBacks *v10;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v12;
  unint64_t v14;
  int v15;
  int v16;
  int v17;
  int valuePtr;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v17 = a2;
  valuePtr = a1;
  v15 = a4;
  v16 = a3;
  v14 = 0xAAAAAAAAAAAAAAAALL;
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &valuePtr);
  v6 = CFNumberCreate(v4, kCFNumberIntType, &v17);
  v7 = CFNumberCreate(v4, kCFNumberIntType, &v16);
  v8 = CFNumberCreate(v4, kCFNumberIntType, &v15);
  v9 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v10 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  Mutable = CFDictionaryCreateMutable(v4, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v12 = CFDictionaryCreateMutable(v4, 0, v9, v10);
  CFDictionarySetValue(v12, (const void *)*MEMORY[0x1E0CA90E0], v5);
  CFDictionarySetValue(v12, (const void *)*MEMORY[0x1E0CA8FD8], v6);
  CFDictionarySetValue(v12, (const void *)*MEMORY[0x1E0CA9040], v7);
  CFDictionarySetValue(v12, (const void *)*MEMORY[0x1E0CBBF00], v8);
  CFDictionarySetValue(v12, (const void *)*MEMORY[0x1E0CA8FF0], Mutable);
  CVPixelBufferPoolCreate(v4, 0, v12, (CVPixelBufferPoolRef *)&v14);
  CFRelease(v5);
  CFRelease(v6);
  CFRelease(v7);
  CFRelease(v8);
  CFRelease(Mutable);
  CFRelease(v12);
  return v14;
}

const __CFDictionary *VideoUtil_GetEncodedFrameSEINaluOverheadBytes(const __CFDictionary *result)
{
  const __CFDictionary *v1;
  unsigned int valuePtr;
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  valuePtr = 0;
  if (result)
  {
    v1 = result;
    result = (const __CFDictionary *)CFDictionaryContainsKey(result, CFSTR("PropagatableAttachmentsNALSize"));
    if ((_DWORD)result)
    {
      result = (const __CFDictionary *)CFDictionaryGetValue(v1, CFSTR("PropagatableAttachmentsNALSize"));
      if (result)
      {
        CFNumberGetValue(result, kCFNumberSInt32Type, &valuePtr);
        return (const __CFDictionary *)valuePtr;
      }
    }
  }
  return result;
}

CFTypeRef VideoUtil_GetDecodedFrameSEINaluOverheadBytes(CFTypeRef result)
{
  unsigned int valuePtr;
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  valuePtr = 0;
  if (result)
  {
    result = CMGetAttachment(result, CFSTR("PropagatableAttachmentsNALSize"), 0);
    if (result)
    {
      CFNumberGetValue((CFNumberRef)result, kCFNumberSInt32Type, &valuePtr);
      return (CFTypeRef)valuePtr;
    }
  }
  return result;
}

void VideoUtil_PropagateSampleBufferAttachmentsToPixelBuffer(const void *a1, __CVBuffer *a2)
{
  CFTypeRef v3;

  if (a1 && a2)
  {
    v3 = CMGetAttachment(a1, CFSTR("TransportLayer"), 0);
    if (v3)
      CVBufferSetAttachment(a2, CFSTR("PropagatableAttachments"), v3, kCVAttachmentMode_ShouldPropagate);
  }
}

BOOL VideoUtil_ParseFeatureListString(uint64_t a1, unsigned int *a2, BOOL *a3)
{
  char *v3;
  char *v4;
  int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  char *v9;
  char *v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  unsigned int v14;
  uint64_t v18;
  char *__lasts;
  char __b[3200];
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  __lasts = (char *)0xAAAAAAAAAAAAAAAALL;
  memset(__b, 170, sizeof(__b));
  __strlcpy_chk();
  v3 = strtok_r(__b, ";", &__lasts);
  if (v3)
  {
    v4 = v3;
    v18 = 0;
    v5 = 0;
    v6 = 0;
    v7 = 0;
    v8 = 0;
    do
    {
      v9 = strchr(v4, 58);
      if (v9)
      {
        v10 = v9;
        v11 = atoi(v9 + 1);
        *v10 = 0;
        if (v11 <= 0x63)
        {
          v12 = v11;
          if (!strcmp(v4, "MVRA") || !strcmp(v4, "VRA"))
          {
            v8 = v12 + 1;
          }
          else if (!strcmp(v4, "RVRA1") || !strcmp(v4, "RVRA2"))
          {
            v6 = v12 + 1;
          }
          else if (!strcmp(v4, "UEP"))
          {
            v7 = v12 + 1;
          }
          else if (!strcmp(v4, "AS"))
          {
            LODWORD(v18) = v12 + 1;
          }
          else
          {
            v13 = strcmp(v4, "CR");
            v14 = HIDWORD(v18);
            if (!v13)
              v14 = v12 + 1;
            HIDWORD(v18) = v14;
          }
        }
      }
      if (!strcmp(v4, "LF"))
        v5 = 1;
      v4 = strtok_r(0, ";", &__lasts);
    }
    while (v4);
  }
  else
  {
    v8 = 0;
    v7 = 0;
    v18 = 0;
    v6 = 0;
    v5 = 0;
  }
  *a2 = v7;
  if (a3)
    *a3 = v5 == 1;
  return (v8 | v7 | v18 | v6 | HIDWORD(v18) | v5) != 0;
}

uint64_t VideoUtil_FeatureListStringOptionExists(uint64_t a1, uint64_t a2)
{
  void *v3;
  uint64_t v4;
  void *v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BYTE v10[128];
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v3 = (void *)objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a1);
  v4 = objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a2);
  v11 = 0u;
  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  v5 = (void *)objc_msgSend(v3, "componentsSeparatedByString:", CFSTR(";"));
  result = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v11, v10, 16);
  if (result)
  {
    v7 = result;
    v8 = *(_QWORD *)v12;
    while (2)
    {
      v9 = 0;
      do
      {
        if (*(_QWORD *)v12 != v8)
          objc_enumerationMutation(v5);
        if (!objc_msgSend((id)objc_msgSend((id)objc_msgSend(*(id *)(*((_QWORD *)&v11 + 1) + 8 * v9), "componentsSeparatedByString:", CFSTR(":")), "firstObject"), "caseInsensitiveCompare:", v4))return 1;
        ++v9;
      }
      while (v7 != v9);
      result = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v11, v10, 16);
      v7 = result;
      if (result)
        continue;
      break;
    }
  }
  return result;
}

uint64_t VideoUtil_StringVisibleRect(double *a1, char *__str, size_t __size)
{
  return snprintf(__str, __size, "[%.2fx%.2f@(%.2f,%.2f)]", a1[2], a1[3], *a1, a1[1]);
}

void VideoUtil_GetVisibleRect(__CVBuffer *a1, double *a2)
{
  double Width;
  double Height;
  const __CFDictionary *Attachment;
  double v7;
  const __CFDictionary *v8;
  CFTypeID v9;
  double v10;
  double v11;
  double v12;
  uint64_t v13;
  NSObject *v14;
  NSObject *v15;
  float v16;
  float v17;
  float v18;
  float v19;
  uint8_t buf[4];
  uint64_t v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  double v27;
  __int16 v28;
  double v29;
  __int16 v30;
  double v31;
  __int16 v32;
  double v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  Width = (double)CVPixelBufferGetWidth(a1);
  Height = (double)CVPixelBufferGetHeight(a1);
  Attachment = (const __CFDictionary *)CVBufferGetAttachment(a1, (CFStringRef)*MEMORY[0x1E0CED6C8], 0);
  v7 = 0.0;
  if (Attachment && (v8 = Attachment, v9 = CFGetTypeID(Attachment), v9 == CFDictionaryGetTypeID()))
  {
    v18 = NAN;
    v19 = NAN;
    v16 = NAN;
    v17 = NAN;
    if (cfDictionaryGetFloat(v8, (const void *)*MEMORY[0x1E0CA8D60], &v17)
      && cfDictionaryGetFloat(v8, (const void *)*MEMORY[0x1E0CA8D40], &v16)
      && cfDictionaryGetFloat(v8, (const void *)*MEMORY[0x1E0CA8D48], &v19)
      && cfDictionaryGetFloat(v8, (const void *)*MEMORY[0x1E0CA8D58], &v18))
    {
      v10 = v17;
      v11 = (Width - v17) * 0.5 + v19;
      v12 = v16;
      v7 = (Height - v16) * 0.5 - v18;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v13 = VRTraceErrorLogLevelToCSTR();
        v14 = *MEMORY[0x1E0CF2758];
        v15 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136316674;
            v21 = v13;
            v22 = 2080;
            v23 = "VideoUtil_GetVisibleRect";
            v24 = 1024;
            v25 = 861;
            v26 = 2048;
            v27 = v10;
            v28 = 2048;
            v29 = v12;
            v30 = 2048;
            v31 = v11;
            v32 = 2048;
            v33 = v7;
            _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d visibleRect=%.2fx%.2f@(%.2f, %.2f)", buf, 0x44u);
          }
        }
        else if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136316674;
          v21 = v13;
          v22 = 2080;
          v23 = "VideoUtil_GetVisibleRect";
          v24 = 1024;
          v25 = 861;
          v26 = 2048;
          v27 = v10;
          v28 = 2048;
          v29 = v12;
          v30 = 2048;
          v31 = v11;
          v32 = 2048;
          v33 = v7;
          _os_log_debug_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEBUG, " [%s] %s:%d visibleRect=%.2fx%.2f@(%.2f, %.2f)", buf, 0x44u);
        }
      }
    }
    else
    {
      v10 = Width;
      v11 = 0.0;
      v12 = Height;
    }
    Width = v10;
    Height = v12;
  }
  else
  {
    v11 = 0.0;
  }
  *a2 = v11;
  a2[1] = v7;
  a2[2] = Width;
  a2[3] = Height;
}

uint64_t cfDictionaryGetFloat(const __CFDictionary *a1, const void *a2, void *a3)
{
  uint64_t result;
  CFTypeID v5;
  CFTypeRef cf[2];

  cf[1] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  cf[0] = 0;
  result = CFDictionaryGetValueIfPresent(a1, a2, cf);
  if ((_DWORD)result)
  {
    v5 = CFGetTypeID(cf[0]);
    if (v5 == CFNumberGetTypeID())
    {
      CFNumberGetValue((CFNumberRef)cf[0], kCFNumberFloatType, a3);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void VideoUtil_GetVisibleRectForScreen(__CVBuffer *a1, double *a2)
{
  double Width;
  double Height;
  const __CFDictionary *Attachment;
  double v7;
  const __CFDictionary *v8;
  CFTypeID v9;
  double v10;
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  float v14;
  float v15;
  float v16;
  float v17;
  uint8_t buf[4];
  uint64_t v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  double v25;
  __int16 v26;
  double v27;
  __int16 v28;
  double v29;
  __int16 v30;
  double v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  Width = (double)CVPixelBufferGetWidth(a1);
  Height = (double)CVPixelBufferGetHeight(a1);
  Attachment = (const __CFDictionary *)CVBufferGetAttachment(a1, (CFStringRef)*MEMORY[0x1E0CED6C8], 0);
  v7 = 0.0;
  if (Attachment
    && (v8 = Attachment, v9 = CFGetTypeID(Attachment), v9 == CFDictionaryGetTypeID())
    && (v16 = NAN,
        v17 = NAN,
        v14 = NAN,
        v15 = NAN,
        cfDictionaryGetFloat(v8, (const void *)*MEMORY[0x1E0CA8D60], &v15))
    && cfDictionaryGetFloat(v8, (const void *)*MEMORY[0x1E0CA8D40], &v14)
    && cfDictionaryGetFloat(v8, (const void *)*MEMORY[0x1E0CA8D48], &v17))
  {
    v10 = 0.0;
    if (cfDictionaryGetFloat(v8, (const void *)*MEMORY[0x1E0CA8D58], &v16))
    {
      v10 = v17;
      v7 = v16;
      Width = v15;
      Height = v14;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v11 = VRTraceErrorLogLevelToCSTR();
        v12 = *MEMORY[0x1E0CF2758];
        v13 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136316674;
            v19 = v11;
            v20 = 2080;
            v21 = "VideoUtil_GetVisibleRectForScreen";
            v22 = 1024;
            v23 = 885;
            v24 = 2048;
            v25 = Width;
            v26 = 2048;
            v27 = Height;
            v28 = 2048;
            v29 = v10;
            v30 = 2048;
            v31 = v7;
            _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d visibleRect=%.2fx%.2f@(%.2f, %.2f)", buf, 0x44u);
          }
        }
        else if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136316674;
          v19 = v11;
          v20 = 2080;
          v21 = "VideoUtil_GetVisibleRectForScreen";
          v22 = 1024;
          v23 = 885;
          v24 = 2048;
          v25 = Width;
          v26 = 2048;
          v27 = Height;
          v28 = 2048;
          v29 = v10;
          v30 = 2048;
          v31 = v7;
          _os_log_debug_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEBUG, " [%s] %s:%d visibleRect=%.2fx%.2f@(%.2f, %.2f)", buf, 0x44u);
        }
      }
    }
  }
  else
  {
    v10 = 0.0;
  }
  *a2 = v10;
  a2[1] = v7;
  a2[2] = Width;
  a2[3] = Height;
}

double VideoUtil_CalculateVisibleRect()
{
  return 0.0;
}

__CFDictionary *VideoUtil_CreateVisibleRectDictionary(double a1, double a2, double a3, double a4)
{
  __CFDictionary *Mutable;
  CFNumberRef v5;
  CFNumberRef v6;
  CFNumberRef v7;
  CFNumberRef v8;
  int v10;
  int v11;
  int v12;
  int valuePtr;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v12 = (int)a2;
  valuePtr = (int)a1;
  v10 = (int)a4;
  v11 = (int)a3;
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v5 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CA8D48], v5);
  CFRelease(v5);
  v6 = CFNumberCreate(0, kCFNumberIntType, &v12);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CA8D58], v6);
  CFRelease(v6);
  v7 = CFNumberCreate(0, kCFNumberIntType, &v11);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CA8D60], v7);
  CFRelease(v7);
  v8 = CFNumberCreate(0, kCFNumberIntType, &v10);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CA8D40], v8);
  CFRelease(v8);
  return Mutable;
}

void VideoUtil_SetVisibleRectAttachment(__CVBuffer *a1, int a2, int a3, int a4)
{
  float v8;
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  double v12;
  double v13;
  double v14;
  double v15;
  __CFDictionary *VisibleRectDictionary;
  int v17;
  uint64_t v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  double v24;
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (a4)
  {
    v8 = (float)a3 / (float)a4;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v9 = VRTraceErrorLogLevelToCSTR();
      v10 = *MEMORY[0x1E0CF2758];
      v11 = *MEMORY[0x1E0CF2758];
      if (*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          v17 = 136316674;
          v18 = v9;
          v19 = 2080;
          v20 = "VideoUtil_SetVisibleRectAttachment";
          v21 = 1024;
          v22 = 959;
          v23 = 2048;
          v24 = v8;
          v25 = 1024;
          v26 = a2;
          v27 = 1024;
          v28 = a3;
          v29 = 1024;
          v30 = a4;
          _os_log_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d aspectRatio=%f, type=%d, %dx%d", (uint8_t *)&v17, 0x38u);
        }
      }
      else if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        v17 = 136316674;
        v18 = v9;
        v19 = 2080;
        v20 = "VideoUtil_SetVisibleRectAttachment";
        v21 = 1024;
        v22 = 959;
        v23 = 2048;
        v24 = v8;
        v25 = 1024;
        v26 = a2;
        v27 = 1024;
        v28 = a3;
        v29 = 1024;
        v30 = a4;
        _os_log_debug_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_DEBUG, " [%s] %s:%d aspectRatio=%f, type=%d, %dx%d", (uint8_t *)&v17, 0x38u);
      }
    }
    v12 = VideoUtil_CalculateVisibleRect();
    VisibleRectDictionary = VideoUtil_CreateVisibleRectDictionary(v12, v13, v14, v15);
    CVBufferSetAttachment(a1, (CFStringRef)*MEMORY[0x1E0CED6C8], VisibleRectDictionary, kCVAttachmentMode_ShouldPropagate);
    CFRelease(VisibleRectDictionary);
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VideoUtil_SetVisibleRectAttachment_cold_1();
  }
}

CMSampleBufferRef VideoUtil_CreateSampleFromBuffer(OpaqueCMBlockBuffer *a1, const CMSampleTimingInfo *a2, uint64_t a3, const opaqueCMFormatDescription *a4)
{
  size_t sampleSizeArray;
  CMSampleBufferRef v9[2];

  v9[1] = *(CMSampleBufferRef *)MEMORY[0x1E0C80C00];
  v9[0] = 0;
  sampleSizeArray = CMBlockBufferGetDataLength(a1);
  CMSampleBufferCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1, 1u, 0, 0, a4, 1, 1, a2, 1, &sampleSizeArray, v9);
  if (!v9[0] && (int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VideoUtil_CreateSampleFromBuffer_cold_1();
  }
  return v9[0];
}

unint64_t VideoUtil_ConstructSubFrameIdentifer(unsigned int a1, uint64_t a2)
{
  return a1 | (unint64_t)(a2 << 32);
}

uint64_t VideoUtil_GetEscapeCountForBuffer(unsigned __int8 *a1, uint64_t a2)
{
  unsigned __int8 *v2;
  uint64_t result;
  unint64_t v4;
  unsigned int v5;
  unsigned int v6;

  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoUtil_GetEscapeCountForBuffer_cold_1();
    }
    return 0;
  }
  if (!a2)
    return 0;
  v2 = a1;
  result = 0;
  v4 = 0;
  do
  {
    v6 = *v2++;
    v5 = v6;
    result += (v6 < 4) & (v4 > 1);
    if (v6 < 4 && v4 > 1)
      v4 = 1;
    else
      ++v4;
    if (v5)
      v4 = 0;
    --a2;
  }
  while (a2);
  return result;
}

uint64_t VideoUtil_PerformEscapingForBuffer(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unsigned int v8;

  if (a1 && a3)
  {
    v4 = 0;
    if (!a2 || !a4)
      return v4;
    v5 = 0;
    v6 = 0;
    v7 = 0;
    while (1)
    {
      v8 = *(unsigned __int8 *)(a1 + v6);
      if (v8 <= 3 && v7 >= 2)
      {
        *(_BYTE *)(a3 + v5) = 3;
        if (v5 + 1 >= a4)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() < 3)
            return 2151743551;
          VRTraceErrorLogLevelToCSTR();
          v4 = 2151743551;
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            VideoUtil_PerformEscapingForBuffer_cold_2();
          return v4;
        }
        v7 = 0;
        LOBYTE(v8) = *(_BYTE *)(a1 + v6);
        ++v5;
      }
      v4 = 0;
      *(_BYTE *)(a3 + v5) = v8;
      if (*(_BYTE *)(a1 + v6))
        v7 = 0;
      else
        ++v7;
      if (++v6 < a2 && ++v5 < a4)
        continue;
      return v4;
    }
  }
  v4 = 2151743489;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VideoUtil_PerformEscapingForBuffer_cold_1();
  }
  return v4;
}

uint64_t VideoUtil_GetEmulationByteCountForBuffer(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t result;
  _BYTE *v5;

  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoUtil_GetEmulationByteCountForBuffer_cold_1();
    }
    return 0;
  }
  v2 = a2 - 3;
  if (a2 == 3)
    return 0;
  result = 0;
  v5 = (_BYTE *)(a1 + 2);
  do
  {
    if (!*(v5 - 2) && !*(v5 - 1) && *v5 == 3)
      ++result;
    ++v5;
    --v2;
  }
  while (v2);
  return result;
}

uint64_t VideoUtil_RemoveEmulationBytesFromBuffer(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v6;
  unint64_t v7;
  char v8;
  uint64_t v9;
  uint64_t v11;
  NSObject *v12;
  unint64_t v13;
  unint64_t v14;
  uint8_t buf[4];
  uint64_t v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  unint64_t v22;
  __int16 v23;
  unint64_t v24;
  __int16 v25;
  unint64_t v26;
  __int16 v27;
  unint64_t v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  if (a1 && a3)
  {
    if (a2 < a4)
    {
      v9 = 2151743489;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VideoUtil_RemoveEmulationBytesFromBuffer_cold_2();
      }
    }
    else
    {
      v6 = 0;
      v7 = 0;
      if (a2 != 3 && a4 != 2)
      {
        v7 = 0;
        v6 = 0;
        do
        {
          v8 = *(_BYTE *)(a1 + v6);
          if (!v8 && !*(_BYTE *)(a1 + v6 + 1) && *(_BYTE *)(a1 + v6 + 2) == 3)
          {
            *(_BYTE *)(a3 + v7++) = 0;
            v8 = *(_BYTE *)(a1 + v6 + 1);
            v6 += 2;
          }
          *(_BYTE *)(a3 + v7) = v8;
          ++v6;
          ++v7;
        }
        while (v6 < a2 - 3 && v7 < a4 - 2);
      }
      while (v6 < a2 && v7 < a4)
        *(_BYTE *)(a3 + v7++) = *(_BYTE *)(a1 + v6++);
      if (v6 == a2 && v7 == a4)
      {
        return 0;
      }
      else
      {
        v9 = 2151743489;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v13 = v6;
          v14 = v7;
          v11 = VRTraceErrorLogLevelToCSTR();
          v12 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136316674;
            v16 = v11;
            v17 = 2080;
            v18 = "VideoUtil_RemoveEmulationBytesFromBuffer";
            v19 = 1024;
            v20 = 1250;
            v21 = 2048;
            v22 = v13;
            v23 = 2048;
            v24 = a2;
            v25 = 2048;
            v26 = v14;
            v27 = 2048;
            v28 = a4;
            _os_log_error_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_ERROR, " [%s] %s:%d VideoUtil_RemoveEmulationBytesFromBuffer failed due to invalid buffer index(source buffer index:%zu, required:%zu) (unescaped buffer index:%zu required:%zu)", buf, 0x44u);
          }
        }
      }
    }
  }
  else
  {
    v9 = 2151743489;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VideoUtil_RemoveEmulationBytesFromBuffer_cold_1();
    }
  }
  return v9;
}

uint64_t VideoUtil_ReplaceStartCodeWithNALLength(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  unsigned int v3;
  unsigned int *v4;
  unint64_t v5;
  unsigned int *v6;
  unsigned int v7;

  if (a2)
  {
    v2 = 0;
    v3 = 0;
    v4 = 0;
    do
    {
      v5 = v2 + 4;
      if (v2 + 4 < a2 && (v6 = (unsigned int *)(a1 + v2), *(_DWORD *)(a1 + v2) == kVideoUtilStartCode))
      {
        if (v4)
        {
          v7 = bswap32(v3);
          v3 = 0;
          *v4 = v7;
        }
        else
        {
          v3 = 0;
        }
        v4 = v6;
      }
      else
      {
        ++v3;
        v5 = v2 + 1;
      }
      v2 = v5;
    }
    while (v5 < a2);
    if (v4)
      *v4 = bswap32(v3);
  }
  return 0;
}

uint64_t VideoUtil_ReplaceNALLengthWithStartCode(uint64_t a1, unint64_t a2)
{
  unint64_t i;
  uint64_t v3;

  if (a2)
  {
    for (i = 0; i < a2; i += v3 + 4)
    {
      v3 = bswap32(*(_DWORD *)(a1 + i));
      *(_DWORD *)(a1 + i) = kVideoUtilStartCode;
    }
  }
  return 0;
}

double VideoUtil_ComputeScreenSizeClosestToNativeAspectRatio(unsigned int a1, double a2, double a3, double a4, double a5)
{
  int v5;
  int v6;
  _BOOL4 v13;
  BOOL v14;
  unsigned int v15;
  unsigned int v16;
  int v17;
  int v18;
  int v19;
  double v20;
  uint64_t v21;
  unsigned int v22;
  int v23;
  int v24;
  int v25;
  uint64_t v26;
  NSObject *v27;
  int v29;
  uint64_t v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  int v34;
  __int16 v35;
  double v36;
  __int16 v37;
  double v38;
  __int16 v39;
  int v40;
  __int16 v41;
  int v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v5 = (int)a2;
  v6 = (int)a3;
  if (a1)
  {
    if (a2 == 0.0)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VideoUtil_ComputeScreenSizeClosestToNativeAspectRatio_cold_2();
      }
    }
    else if (a3 == 0.0)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          VideoUtil_ComputeScreenSizeClosestToNativeAspectRatio_cold_3();
      }
    }
    else if (VCDefaults_GetBoolValueForKey(CFSTR("forceScreenCaptureToMod16"), 0)
           && +[VCHardwareSettings allowScreenShareResolutionModuloAdjustment](VCHardwareSettings, "allowScreenShareResolutionModuloAdjustment"))
    {
      v13 = v5 > (int)a4 || v6 > (int)a5;
      v14 = !v13;
      if (v13)
        v15 = a5;
      else
        v15 = v6;
      if (v14)
        v16 = v5;
      else
        v16 = a4;
      v5 = (v16 + a1 - 1) & -a1;
      v17 = (v15 + a1 - 1) & -a1;
      if (v5 >= (int)((double)v5 * 0.98))
      {
        v18 = 0x7FFFFFFF;
        v19 = (v16 + a1 - 1) & -a1;
        v20 = a4 / a5;
        do
        {
          v21 = 0;
          v22 = 2 * llround((double)v19 / v20 * 0.5);
          v23 = (a1 - 1 + v22) & -a1;
          if (v19 == v5)
            v23 = v22;
          v29 = v22;
          LODWORD(v30) = v23;
          HIDWORD(v30) = v22 / a1 * a1;
          do
          {
            v24 = *(int *)((char *)&v29 + v21);
            if (!(v24 % a1))
            {
              v25 = (int)(v20 * (double)v24) - v19;
              if (v25 < 0)
                v25 = v19 - (int)(v20 * (double)v24);
              if (((v25 < v18) & (fabs((a4 * a5 - (double)(v24 * v19)) / (a4 * a5)) * 100.0 < 1.2)) != 0)
              {
                v18 = v25;
                v17 = *(int *)((char *)&v29 + v21);
                v5 = v19;
              }
            }
            v21 += 4;
          }
          while (v21 != 12);
          v19 -= a1;
        }
        while (v19 >= (int)((double)v5 * 0.98));
      }
      if ((int)VRTraceGetErrorLogLevelForModule() > 6)
      {
        v26 = VRTraceErrorLogLevelToCSTR();
        v27 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v29 = 136316674;
          v30 = v26;
          v31 = 2080;
          v32 = "VideoUtil_ComputeScreenSizeClosestToNativeAspectRatio";
          v33 = 1024;
          v34 = 1405;
          v35 = 2048;
          v36 = a2;
          v37 = 2048;
          v38 = a3;
          v39 = 1024;
          v40 = v5;
          v41 = 1024;
          v42 = v17;
          _os_log_impl(&dword_1D8A54000, v27, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d desiredResolution.width=%lf desiredResolution.height=%lf suggestedResolution.width=%u suggestedResolution.height=%u", (uint8_t *)&v29, 0x3Cu);
        }
      }
    }
  }
  else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
  {
    VRTraceErrorLogLevelToCSTR();
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      VideoUtil_ComputeScreenSizeClosestToNativeAspectRatio_cold_1();
  }
  return (double)v5;
}

double VideoUtil_ComputeScreenSizeForAspectRatio(unint64_t a1, double a2)
{
  return (double)(((unint64_t)sqrt((double)a1 * a2) + 15) & 0xFFFFFFF0);
}

void ReleaseCVPixelBuffer(__CVBuffer *a1)
{
  CVPixelBufferUnlockBaseAddress(a1, 1uLL);
  CVPixelBufferRelease(a1);
}

void VCVideoUtil_AdjustFaceMetadata(__CVBuffer *a1, unint64_t a2, unint64_t a3)
{
  size_t Width;
  size_t Height;
  unint64_t v8;
  const __CFString *v9;
  void *Attachment;
  void *v11;
  uint64_t v12;
  void *v13;
  void *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  double v21;
  double v22;
  uint64_t i;
  void *v24;
  CFDictionaryRef DictionaryRepresentation;
  void *v26;
  void *v27;
  uint64_t v28;
  NSObject *v29;
  NSObject *v30;
  const char *v31;
  uint64_t v32;
  NSObject *v33;
  unint64_t v34;
  const __CFString *key;
  void *v36;
  __CVBuffer *v37;
  CVAttachmentMode attachmentMode;
  CGRect rect;
  _BYTE v40[128];
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  uint64_t v45;
  CGRect v46;

  v45 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCVideoUtil_AdjustFaceMetadata_cold_1();
    }
    goto LABEL_48;
  }
  if (!a2)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCVideoUtil_AdjustFaceMetadata_cold_2();
    }
    goto LABEL_48;
  }
  if (!a3)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCVideoUtil_AdjustFaceMetadata_cold_3();
    }
    goto LABEL_48;
  }
  Width = CVPixelBufferGetWidth(a1);
  Height = CVPixelBufferGetHeight(a1);
  if (!Width)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCVideoUtil_AdjustFaceMetadata_cold_4();
    }
    goto LABEL_48;
  }
  v8 = Height;
  if (!Height)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        VCVideoUtil_AdjustFaceMetadata_cold_5();
    }
    goto LABEL_48;
  }
  attachmentMode = kCVAttachmentMode_ShouldPropagate;
  v9 = (const __CFString *)*MEMORY[0x1E0D04138];
  Attachment = (void *)CVBufferGetAttachment(a1, (CFStringRef)*MEMORY[0x1E0D04138], &attachmentMode);
  if (!Attachment)
  {
    if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
    {
      v28 = VRTraceErrorLogLevelToCSTR();
      v29 = *MEMORY[0x1E0CF2758];
      v30 = *MEMORY[0x1E0CF2758];
      if (!*MEMORY[0x1E0CF2748])
      {
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
          VCVideoUtil_AdjustFaceMetadata_cold_6();
        goto LABEL_48;
      }
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(rect.origin.x) = 136315650;
        *(_QWORD *)((char *)&rect.origin.x + 4) = v28;
        WORD2(rect.origin.y) = 2080;
        *(_QWORD *)((char *)&rect.origin.y + 6) = "VCVideoUtil_AdjustFaceMetadata";
        HIWORD(rect.size.width) = 1024;
        LODWORD(rect.size.height) = 1702;
        v31 = " [%s] %s:%d no metadata dictionary attachment";
LABEL_43:
        _os_log_impl(&dword_1D8A54000, v29, OS_LOG_TYPE_DEFAULT, v31, (uint8_t *)&rect, 0x1Cu);
      }
    }
LABEL_48:
    v15 = 0;
    v27 = 0;
    goto LABEL_19;
  }
  v11 = Attachment;
  v12 = *MEMORY[0x1E0D05350];
  v13 = (void *)objc_msgSend(Attachment, "objectForKeyedSubscript:", *MEMORY[0x1E0D05350]);
  if (!v13)
  {
    v13 = (void *)objc_msgSend((id)objc_msgSend(v11, "objectForKeyedSubscript:", CFSTR("MetadataCVA")), "objectForKeyedSubscript:", CFSTR("DetectedFacesArray"));
    if (!v13)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
      {
        v32 = VRTraceErrorLogLevelToCSTR();
        v29 = *MEMORY[0x1E0CF2758];
        v33 = *MEMORY[0x1E0CF2758];
        if (!*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
            VCVideoUtil_AdjustFaceMetadata_cold_7();
          goto LABEL_48;
        }
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(rect.origin.x) = 136315650;
          *(_QWORD *)((char *)&rect.origin.x + 4) = v32;
          WORD2(rect.origin.y) = 2080;
          *(_QWORD *)((char *)&rect.origin.y + 6) = "VCVideoUtil_AdjustFaceMetadata";
          HIWORD(rect.size.width) = 1024;
          LODWORD(rect.size.height) = 1710;
          v31 = " [%s] %s:%d could not find face metadata array attachment";
          goto LABEL_43;
        }
      }
      goto LABEL_48;
    }
  }
  v34 = Width;
  key = v9;
  v37 = a1;
  v14 = (void *)objc_opt_new();
  v15 = (void *)objc_opt_new();
  objc_msgSend(v14, "setObject:forKeyedSubscript:", v15, v12);
  v36 = v14;
  objc_msgSend(v14, "setObject:forKeyedSubscript:", objc_msgSend(v11, "objectForKeyedSubscript:", CFSTR("MetadataCVA")), CFSTR("MetadataCVA"));
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v16 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v41, v40, 16);
  if (v16)
  {
    v17 = v16;
    v18 = a3;
    v19 = *(_QWORD *)v42;
    v20 = *MEMORY[0x1E0D05360];
    v21 = (double)v18;
    v22 = (double)v8;
    do
    {
      for (i = 0; i != v17; ++i)
      {
        if (*(_QWORD *)v42 != v19)
          objc_enumerationMutation(v13);
        v24 = *(void **)(*((_QWORD *)&v41 + 1) + 8 * i);
        memset(&rect, 0, sizeof(rect));
        if (CGRectMakeWithDictionaryRepresentation((CFDictionaryRef)objc_msgSend(v24, "objectForKeyedSubscript:", v20), &rect))
        {
          v46.origin.x = VCVideoUtil_AdjustFaceBounds(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height, (double)a2, v21, (double)v34, v22);
          rect = v46;
          DictionaryRepresentation = CGRectCreateDictionaryRepresentation(v46);
          v26 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99E08]), "initWithDictionary:", v24);
          objc_msgSend(v26, "setObject:forKeyedSubscript:", DictionaryRepresentation, v20);
          objc_msgSend(v15, "addObject:", v26);

          CFRelease(DictionaryRepresentation);
        }
      }
      v17 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v41, v40, 16);
    }
    while (v17);
  }
  v27 = v36;
  CVBufferSetAttachment(v37, key, v36, kCVAttachmentMode_ShouldPropagate);
LABEL_19:

}

double VCVideoUtil_AdjustFaceBounds(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, double a5, double a6, double a7, double a8)
{
  double v13;
  double v14;
  double v15;
  double v16;
  CGFloat v17;
  CGFloat v18;
  double v19;
  double v20;
  double v21;
  CGFloat v22;
  CGFloat v23;
  uint64_t v24;
  NSObject *v25;
  NSObject *v26;
  CGFloat Height;
  CGFloat v29;
  CGFloat v30;
  CGFloat v31;
  CGFloat Width;
  CGFloat v33;
  double v37;
  uint8_t buf[4];
  uint64_t v39;
  __int16 v40;
  const char *v41;
  __int16 v42;
  int v43;
  __int16 v44;
  double v45;
  __int16 v46;
  double v47;
  __int16 v48;
  CGFloat v49;
  __int16 v50;
  CGFloat v51;
  __int16 v52;
  CGFloat v53;
  __int16 v54;
  CGFloat v55;
  __int16 v56;
  double v57;
  __int16 v58;
  double v59;
  __int16 v60;
  double v61;
  __int16 v62;
  double v63;
  __int16 v64;
  CGFloat v65;
  __int16 v66;
  CGFloat v67;
  uint64_t v68;
  CGRect v69;
  CGRect v70;
  CGRect v71;
  CGRect v72;
  CGRect v73;
  CGRect v74;
  CGRect v75;
  CGRect v76;

  v68 = *MEMORY[0x1E0C80C00];
  v13 = a5 / a6;
  v14 = a7 / a8;
  if (a7 / a8 >= a5 / a6)
  {
    v21 = v13 / v14;
    v19 = (a2 + (1.0 - v13 / v14) * -0.5) / (v13 / v14);
    v22 = a1;
    v23 = a2;
    v16 = a1;
    v37 = a3;
    v20 = CGRectGetHeight(*(CGRect *)(&a3 - 2)) / v21;
  }
  else
  {
    v15 = v14 / v13;
    v16 = (a1 + (1.0 - v14 / v13) * -0.5) / (v14 / v13);
    v17 = a1;
    v18 = a2;
    v19 = a2;
    v37 = CGRectGetWidth(*(CGRect *)(&a3 - 2)) / v15;
    v20 = a4;
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 8)
  {
    v24 = VRTraceErrorLogLevelToCSTR();
    v25 = *MEMORY[0x1E0CF2758];
    v26 = *MEMORY[0x1E0CF2758];
    if (*MEMORY[0x1E0CF2748])
    {
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        v69.origin.x = a1;
        v69.origin.y = a2;
        v69.size.width = a3;
        v69.size.height = a4;
        Width = CGRectGetWidth(v69);
        v70.origin.x = a1;
        v70.origin.y = a2;
        v70.size.width = a3;
        v70.size.height = a4;
        Height = CGRectGetHeight(v70);
        v71.origin.x = v16;
        v71.origin.y = v19;
        v71.size.width = v37;
        v71.size.height = v20;
        v30 = CGRectGetWidth(v71);
        v72.origin.x = v16;
        v72.origin.y = v19;
        v72.size.width = v37;
        v72.size.height = v20;
        *(_DWORD *)buf = 136318722;
        v39 = v24;
        v40 = 2080;
        v41 = "VCVideoUtil_AdjustFaceBounds";
        v42 = 1024;
        v43 = 1765;
        v44 = 2048;
        v45 = a5;
        v46 = 2048;
        v47 = a6;
        v48 = 2048;
        v49 = a1;
        v50 = 2048;
        v51 = a2;
        v52 = 2048;
        v53 = Width;
        v54 = 2048;
        v55 = Height;
        v56 = 2048;
        v57 = a7;
        v58 = 2048;
        v59 = a8;
        v60 = 2048;
        v61 = v16;
        v62 = 2048;
        v63 = v19;
        v64 = 2048;
        v65 = v30;
        v66 = 2048;
        v67 = CGRectGetHeight(v72);
        _os_log_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d Original %fx%f [x=%3f,y=%3f,w=%3f,h=%3f], Cropped %fx%f [x=%3f,y=%3f,w=%3f,h=%3f]", buf, 0x94u);
      }
    }
    else if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
    {
      v73.origin.x = a1;
      v73.origin.y = a2;
      v73.size.width = a3;
      v73.size.height = a4;
      v33 = CGRectGetWidth(v73);
      v74.origin.x = a1;
      v74.origin.y = a2;
      v74.size.width = a3;
      v74.size.height = a4;
      v29 = CGRectGetHeight(v74);
      v75.origin.x = v16;
      v75.origin.y = v19;
      v75.size.width = v37;
      v75.size.height = v20;
      v31 = CGRectGetWidth(v75);
      v76.origin.x = v16;
      v76.origin.y = v19;
      v76.size.width = v37;
      v76.size.height = v20;
      *(_DWORD *)buf = 136318722;
      v39 = v24;
      v40 = 2080;
      v41 = "VCVideoUtil_AdjustFaceBounds";
      v42 = 1024;
      v43 = 1765;
      v44 = 2048;
      v45 = a5;
      v46 = 2048;
      v47 = a6;
      v48 = 2048;
      v49 = a1;
      v50 = 2048;
      v51 = a2;
      v52 = 2048;
      v53 = v33;
      v54 = 2048;
      v55 = v29;
      v56 = 2048;
      v57 = a7;
      v58 = 2048;
      v59 = a8;
      v60 = 2048;
      v61 = v16;
      v62 = 2048;
      v63 = v19;
      v64 = 2048;
      v65 = v31;
      v66 = 2048;
      v67 = CGRectGetHeight(v76);
      _os_log_debug_impl(&dword_1D8A54000, v25, OS_LOG_TYPE_DEBUG, " [%s] %s:%d Original %fx%f [x=%3f,y=%3f,w=%3f,h=%3f], Cropped %fx%f [x=%3f,y=%3f,w=%3f,h=%3f]", buf, 0x94u);
    }
  }
  return v16;
}

uint64_t VCVideoUtil_ShouldUseCompressedPixelFormat()
{
  int v0;
  int ErrorLogLevelForModule;
  os_log_t *v2;
  uint64_t v3;
  NSObject *v4;
  _BOOL4 v5;
  uint64_t v6;
  NSObject *v7;
  int v9;
  uint64_t v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  _BOOL4 v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v0 = _os_feature_enabled_impl();
  ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
  v2 = (os_log_t *)MEMORY[0x1E0CF2758];
  if (ErrorLogLevelForModule >= 7)
  {
    v3 = VRTraceErrorLogLevelToCSTR();
    v4 = *v2;
    if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315906;
      v10 = v3;
      v11 = 2080;
      v12 = "VCVideoUtil_ShouldUseCompressedPixelFormat";
      v13 = 1024;
      v14 = 1773;
      v15 = 1024;
      v16 = v0;
      _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d compressed video buffers enabled=%d", (uint8_t *)&v9, 0x22u);
    }
  }
  v5 = +[VCHardwareSettings supportsCompressedPixelFormat](VCHardwareSettings, "supportsCompressedPixelFormat");
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v6 = VRTraceErrorLogLevelToCSTR();
    v7 = *v2;
    if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315906;
      v10 = v6;
      v11 = 2080;
      v12 = "VCVideoUtil_ShouldUseCompressedPixelFormat";
      v13 = 1024;
      v14 = 1776;
      v15 = 1024;
      v16 = v5;
      _os_log_impl(&dword_1D8A54000, v7, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d compressed pixel format available=%d", (uint8_t *)&v9, 0x22u);
    }
  }
  return v0 & v5;
}

uint64_t VCVideoUtil_DefaultCameraCapturePixelFormat()
{
  uint64_t v0;
  uint64_t v1;
  id v2;
  void *v3;
  uint64_t v4;
  NSObject *v5;
  int v7;
  uint64_t v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  char *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v0 = 875704438;
  if (VCVideoUtil_ShouldUseCompressedPixelFormat())
  {
    v1 = 758674992;
    if (VRTraceIsInternalOSInstalled())
    {
      v2 = +[VCDefaults copyStringValueForKey:](VCDefaults, "copyStringValueForKey:", CFSTR("compressedPixelFormat"));
      v3 = v2;
      if (v2)
        v1 = CStrToFourcc((char *)objc_msgSend(v2, "UTF8String"));

    }
    if (CVIsCompressedPixelFormatAvailable(v1))
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v4 = VRTraceErrorLogLevelToCSTR();
        v5 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v7 = 136315906;
          v8 = v4;
          v9 = 2080;
          v10 = "VCVideoUtil_DefaultCameraCapturePixelFormat";
          v11 = 1024;
          v12 = 1800;
          v13 = 2080;
          v14 = FourccToCStr(v1);
          _os_log_impl(&dword_1D8A54000, v5, OS_LOG_TYPE_DEFAULT, " [%s] %s:%d use compressed pixel format=%s", (uint8_t *)&v7, 0x26u);
        }
      }
      return v1;
    }
  }
  return v0;
}

uint64_t GetCellularMTU(uint64_t a1, int a2)
{
  _QWORD *v3;
  int v4;
  pthread_mutex_t *v5;
  unint64_t v6;
  int v7;
  unint64_t v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  NSObject *v14;
  const char *v15;
  uint64_t v16;
  uint8_t buf[4];
  uint64_t v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  _BYTE v25[10];
  _BYTE v26[6];
  _BOOL4 v27;
  __int16 v28;
  uint64_t v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v3 = (_QWORD *)(a1 + 34456);
  v4 = *(_DWORD *)(a1 + 34512);
  if (v4 && *(_DWORD *)(a1 + 34472))
  {
    v5 = (pthread_mutex_t *)(a1 + 34392);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 34392));
    if (*v3)
    {
      v6 = _CTServerConnectionCopyCurrentMTU();
      v7 = v6;
      v8 = HIDWORD(v6);
      if (v6)
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v9 = VRTraceErrorLogLevelToCSTR();
          v10 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136316162;
            v19 = v9;
            v20 = 2080;
            v21 = "GetCellularMTU";
            v22 = 1024;
            v23 = 356;
            v24 = 1024;
            *(_DWORD *)v25 = v7;
            *(_WORD *)&v25[4] = 1024;
            *(_DWORD *)&v25[6] = v8;
            _os_log_error_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_ERROR, "SIP [%s] %s:%d _CTServerConnectionCopyCurrentMTU failed (%d.%d)", buf, 0x28u);
          }
        }
      }
      if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
      {
        v11 = VRTraceErrorLogLevelToCSTR();
        v12 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316418;
          v19 = v11;
          v20 = 2080;
          v21 = "GetCellularMTU";
          v22 = 1024;
          v23 = 359;
          v24 = 1024;
          *(_DWORD *)v25 = 0;
          *(_WORD *)&v25[4] = 1024;
          *(_DWORD *)&v25[6] = v7;
          *(_WORD *)v26 = 1024;
          *(_DWORD *)&v26[2] = v8;
          _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d \t\t TP:GetCellularMTU MTU: %d (err: %d/%d) ", buf, 0x2Eu);
        }
      }
    }
    pthread_mutex_unlock(v5);
  }
  if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
  {
    v13 = VRTraceErrorLogLevelToCSTR();
    v14 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      if (a2)
        v15 = "TPCellularConditionChangeCallback";
      else
        v15 = "TPConnectedCallback";
      v16 = CelltechToStr();
      *(_DWORD *)buf = 136316674;
      v19 = v13;
      v20 = 2080;
      v21 = "GetCellularMTU";
      v22 = 1024;
      v23 = 376;
      v24 = 2080;
      *(_QWORD *)v25 = v15;
      *(_WORD *)&v25[8] = 1024;
      *(_DWORD *)v26 = 0;
      *(_WORD *)&v26[4] = 1024;
      v27 = v4 != 0;
      v28 = 2080;
      v29 = v16;
      _os_log_impl(&dword_1D8A54000, v14, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d %s CellularMTU: %d  bCellularIsActive: %d  Celltech: %s ", buf, 0x3Cu);
    }
  }
  return 0;
}

uint64_t TPGetSignalStrength(uint64_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t v7;
  _DWORD *v8;
  pthread_mutex_t *v9;
  uint64_t v10;

  v7 = CheckInHandleDebug();
  if (v7)
  {
    if (a2 && a3 && a4)
    {
      v8 = (_DWORD *)(v7 + 34476);
      if (*(_DWORD *)(v7 + 34512))
      {
        v9 = (pthread_mutex_t *)(v7 + 34392);
        pthread_mutex_lock((pthread_mutex_t *)(v7 + 34392));
        if (VCCTServiceMonitor_GetSignalStrength())
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              TPGetSignalStrength_cold_2();
          }
          pthread_mutex_unlock(v9);
          CheckOutHandleDebug();
          return 2148466692;
        }
        *a2 = *v8;
        *a3 = v8[1];
        *a4 = v8[2];
        pthread_mutex_unlock(v9);
      }
      CheckOutHandleDebug();
      return 0;
    }
    v10 = 2148466689;
    CheckOutHandleDebug();
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        TPGetSignalStrength_cold_3();
    }
  }
  else
  {
    v10 = 2148466690;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
      {
        TPGetSignalStrength_cold_1();
        return 2148466690;
      }
    }
  }
  return v10;
}

uint64_t TPGetCellTech()
{
  uint64_t v0;

  if (!CheckInHandleDebug())
    return 2148466690;
  v0 = ICEGetCellTech();
  CheckOutHandleDebug();
  return v0;
}

uint64_t TPUpdateBaseband(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  char v4;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  __int128 v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  pthread_mutex_t *v20;
  CFAllocatorRef *v21;
  unint64_t v22;
  int v23;
  unint64_t v24;
  int v25;
  int ErrorLogLevelForModule;
  NSObject *v27;
  uint64_t v28;
  NSObject *v29;
  int v30;
  const char *v31;
  NSObject *v32;
  uint32_t v33;
  CFMutableDictionaryRef Mutable;
  uint64_t v35;
  NSObject *v36;
  const __CFAllocator *v37;
  CFMutableDictionaryRef v38;
  __CFDictionary *v39;
  CFNumberRef v40;
  CFNumberRef v41;
  CFNumberRef v42;
  CFNumberRef v43;
  CFDataRef v44;
  CFDataRef v45;
  CFDataRef v46;
  CFDataRef v47;
  __CFDictionary *v48;
  const void **v49;
  const void *v50;
  CFDataRef v51;
  CFDataRef v52;
  CFDataRef v53;
  CFDataRef v54;
  unint64_t v55;
  int v56;
  unint64_t v57;
  uint64_t v58;
  NSObject *v59;
  const char *v60;
  NSObject *v61;
  uint64_t v62;
  NSObject *v63;
  int v64;
  int v65;
  uint64_t v66;
  NSObject *v67;
  unint64_t v68;
  int v69;
  unint64_t v70;
  int v71;
  int v72;
  uint64_t v73;
  uint64_t v74;
  NSObject *v75;
  unint64_t v76;
  int v77;
  unint64_t v78;
  int v79;
  int v80;
  uint64_t v81;
  NSObject *v82;
  uint64_t v83;
  NSObject *v84;
  uint64_t v86;
  UInt8 bytes[4];
  unsigned int valuePtr;
  __int16 v89;
  __int16 v90;
  char v91;
  uint8_t buf[4];
  uint64_t v93;
  __int16 v94;
  const char *v95;
  __int16 v96;
  int v97;
  __int16 v98;
  _BYTE v99[10];
  uint64_t v100;
  __int16 v101;
  uint64_t v102;
  __int16 v103;
  int v104;
  __int16 v105;
  int v106;
  __int128 v107;
  __int128 v108;
  _OWORD v109[4];
  _BYTE v110[22];
  uint64_t v111;

  v111 = *MEMORY[0x1E0C80C00];
  if (a4)
  {
    v4 = a4;
    v7 = CheckInHandleDebug();
    if (v7)
    {
      v8 = v7;
      v9 = v7 + 34456;
      if (!*(_DWORD *)(v7 + 34512))
      {
LABEL_85:
        CheckOutHandleDebug();
        return 0;
      }
      if (!a2 || (*(_BYTE *)(a2 + 28) & 4) == 0)
      {
        TPCleanupBasebandNotifications(v7);
        goto LABEL_85;
      }
      v91 = v4;
      v90 = -21846;
      v89 = -21846;
      *(_QWORD *)&v110[14] = 0xAAAAAAAAAAAAAAAALL;
      *(_QWORD *)&v13 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v109[3] = v13;
      *(_OWORD *)v110 = v13;
      v109[2] = v13;
      *(_QWORD *)((char *)v109 + 14) = 0xAAAAAAAAAAAAAAAALL;
      v108 = v13;
      v109[0] = v13;
      v107 = v13;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v14 = VRTraceErrorLogLevelToCSTR();
        v15 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          v16 = IPPORTToStringWithSize();
          v17 = IPPORTToStringWithSize();
          v18 = *(_DWORD *)(a2 + 280);
          v19 = *(_DWORD *)(a2 + 284);
          *(_DWORD *)buf = 136316930;
          v93 = v14;
          v94 = 2080;
          v95 = "TPSetupBasebandNotifications";
          v96 = 1024;
          v97 = 652;
          v98 = 2080;
          *(_QWORD *)v99 = a2 + 32;
          *(_WORD *)&v99[8] = 2080;
          v100 = v16;
          v101 = 2080;
          v102 = v17;
          v103 = 1024;
          v104 = v18;
          v105 = 1024;
          v106 = v19;
          _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d LET US DEAL WITH BASEBAND (if_name:[%s], local:[%s], dst:[%s], local_cell:[%d] remote_cell:[%d])", buf, 0x46u);
        }
      }
      v20 = (pthread_mutex_t *)(v8 + 34392);
      pthread_mutex_lock((pthread_mutex_t *)(v8 + 34392));
      if (*(_DWORD *)(v9 + 56))
      {
        v21 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
        if (*(_QWORD *)(v9 + 8))
        {
          if (*(_DWORD *)(v9 + 32))
          {
            v22 = _CTServerConnectionSetPacketNotificationFilter();
            v23 = v22;
            v24 = HIDWORD(v22);
            v25 = HIDWORD(v22) | v22;
            ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
            if (v25)
            {
              if (ErrorLogLevelForModule >= 3)
              {
                v86 = VRTraceErrorLogLevelToCSTR();
                v27 = *MEMORY[0x1E0CF2758];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136316418;
                  v93 = v86;
                  v94 = 2080;
                  v95 = "TPSetupBasebandNotifications";
                  v96 = 1024;
                  v97 = 671;
                  v98 = 1024;
                  *(_DWORD *)v99 = 671;
                  *(_WORD *)&v99[4] = 1024;
                  *(_DWORD *)&v99[6] = v23;
                  LOWORD(v100) = 1024;
                  *(_DWORD *)((char *)&v100 + 2) = v24;
                  _os_log_error_impl(&dword_1D8A54000, v27, OS_LOG_TYPE_ERROR, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/Transport.c:%d: _CTServerConnectionSetPacketNotificationFilter failed (%d.%d)", buf, 0x2Eu);
                }
              }
            }
            else if (ErrorLogLevelForModule >= 7)
            {
              v35 = VRTraceErrorLogLevelToCSTR();
              v36 = *MEMORY[0x1E0CF2758];
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315650;
                v93 = v35;
                v94 = 2080;
                v95 = "TPSetupBasebandNotifications";
                v96 = 1024;
                v97 = 669;
                _os_log_impl(&dword_1D8A54000, v36, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d De-register existing baseband notification filter.", buf, 0x1Cu);
              }
            }
          }
          CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(v9 + 8));
          Mutable = *(CFMutableDictionaryRef *)(v9 + 8);
        }
        else
        {
          Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          *(_QWORD *)(v9 + 8) = Mutable;
        }
        if (!Mutable)
        {
          pthread_mutex_unlock((pthread_mutex_t *)(v8 + 34392));
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              TPUpdateBaseband_cold_1();
          }
          goto LABEL_85;
        }
        v37 = *v21;
        v38 = CFDictionaryCreateMutable(*v21, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        if (!v38)
        {
          v50 = *(const void **)(v9 + 8);
          if (v50)
          {
            CFRelease(v50);
            *(_QWORD *)(v9 + 8) = 0;
          }
          pthread_mutex_unlock((pthread_mutex_t *)(v8 + 34392));
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              TPUpdateBaseband_cold_2();
          }
          goto LABEL_85;
        }
        v39 = v38;
        v90 = bswap32(*(unsigned __int16 *)(a2 + 64)) >> 16;
        v89 = bswap32(*(unsigned __int16 *)(a2 + 184)) >> 16;
        valuePtr = bswap32(a3);
        v40 = CFNumberCreate(v37, kCFNumberSInt32Type, &valuePtr);
        CFDictionaryAddValue(v39, (const void *)*MEMORY[0x1E0CA7578], v40);
        CFRelease(v40);
        v41 = CFNumberCreate(v37, kCFNumberSInt8Type, &v91);
        CFDictionaryAddValue(v39, (const void *)*MEMORY[0x1E0CA7500], v41);
        CFRelease(v41);
        v42 = CFNumberCreate(v37, kCFNumberSInt16Type, &v90);
        CFDictionaryAddValue(v39, (const void *)*MEMORY[0x1E0CA7510], v42);
        CFRelease(v42);
        v43 = CFNumberCreate(v37, kCFNumberSInt16Type, &v89);
        CFDictionaryAddValue(v39, (const void *)*MEMORY[0x1E0CA7560], v43);
        CFRelease(v43);
        if ((*(_BYTE *)(a2 + 28) & 1) != 0)
        {
          v51 = CFDataCreate(v37, (const UInt8 *)(a2 + 48), 16);
          if (v51)
          {
            v52 = v51;
            CFDictionaryAddValue(v39, (const void *)*MEMORY[0x1E0CA7508], v51);
            CFRelease(v52);
          }
          v53 = CFDataCreate(v37, (const UInt8 *)(a2 + 168), 16);
          if (v53)
          {
            v54 = v53;
            CFDictionaryAddValue(v39, (const void *)*MEMORY[0x1E0CA7558], v53);
            CFRelease(v54);
          }
          v48 = *(__CFDictionary **)(v9 + 8);
          v49 = (const void **)MEMORY[0x1E0CA7530];
        }
        else
        {
          *(_DWORD *)buf = bswap32(*(_DWORD *)(a2 + 48));
          *(_DWORD *)bytes = bswap32(*(_DWORD *)(a2 + 168));
          v44 = CFDataCreate(v37, buf, 4);
          if (v44)
          {
            v45 = v44;
            CFDictionaryAddValue(v39, (const void *)*MEMORY[0x1E0CA7508], v44);
            CFRelease(v45);
          }
          v46 = CFDataCreate(v37, bytes, 4);
          if (v46)
          {
            v47 = v46;
            CFDictionaryAddValue(v39, (const void *)*MEMORY[0x1E0CA7558], v46);
            CFRelease(v47);
          }
          v48 = *(__CFDictionary **)(v9 + 8);
          v49 = (const void **)MEMORY[0x1E0CA7528];
        }
        CFDictionaryAddValue(v48, *v49, v39);
        CFRelease(v39);
        if (!*(_QWORD *)v9)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              TPUpdateBaseband_cold_3();
          }
          goto LABEL_84;
        }
        v55 = _CTServerConnectionSetPacketNotificationFilter();
        v56 = v55;
        v57 = HIDWORD(v55);
        if (v55)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() < 3)
            goto LABEL_84;
          v58 = VRTraceErrorLogLevelToCSTR();
          v59 = *MEMORY[0x1E0CF2758];
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            goto LABEL_84;
          *(_DWORD *)buf = 136316418;
          v93 = v58;
          v94 = 2080;
          v95 = "TPSetupBasebandNotifications";
          v96 = 1024;
          v97 = 759;
          v98 = 1024;
          *(_DWORD *)v99 = 759;
          *(_WORD *)&v99[4] = 1024;
          *(_DWORD *)&v99[6] = v56;
          LOWORD(v100) = 1024;
          *(_DWORD *)((char *)&v100 + 2) = v57;
          v60 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/Trans"
                "port.c:%d: _CTServerConnectionSetPacketNotificationFilter failed (%d.%d)";
          goto LABEL_56;
        }
        *(_DWORD *)(v9 + 32) = 1;
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v62 = VRTraceErrorLogLevelToCSTR();
          v63 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315650;
            v93 = v62;
            v94 = 2080;
            v95 = "TPSetupBasebandNotifications";
            v96 = 1024;
            v97 = 765;
            _os_log_impl(&dword_1D8A54000, v63, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Enabled baseband notification filter.", buf, 0x1Cu);
          }
        }
        v64 = *(_DWORD *)(a2 + 272);
        v65 = *(_DWORD *)(a2 + 276);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v66 = VRTraceErrorLogLevelToCSTR();
          v67 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136316162;
            v93 = v66;
            v94 = 2080;
            v95 = "TPSetupBasebandNotifications";
            v96 = 1024;
            v97 = 770;
            v98 = 1024;
            *(_DWORD *)v99 = v64;
            *(_WORD *)&v99[4] = 1024;
            *(_DWORD *)&v99[6] = v65;
            _os_log_impl(&dword_1D8A54000, v67, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Cellular QoS (Local: %d Remote: %d).", buf, 0x28u);
          }
        }
        if (!*(_DWORD *)(v9 + 60) || !v64 || !v65)
          goto LABEL_84;
        v68 = _CTServerConnectionRegisterForNotification();
        v69 = v68;
        v70 = HIDWORD(v68);
        v71 = HIDWORD(v68) | v68;
        v72 = VRTraceGetErrorLogLevelForModule();
        if (v71)
        {
          if (v72 < 3)
            goto LABEL_84;
          v73 = VRTraceErrorLogLevelToCSTR();
          v59 = *MEMORY[0x1E0CF2758];
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            goto LABEL_84;
          *(_DWORD *)buf = 136316418;
          v93 = v73;
          v94 = 2080;
          v95 = "TPSetupBasebandNotifications";
          v96 = 1024;
          v97 = 775;
          v98 = 1024;
          *(_DWORD *)v99 = 775;
          *(_WORD *)&v99[4] = 1024;
          *(_DWORD *)&v99[6] = v69;
          LOWORD(v100) = 1024;
          *(_DWORD *)((char *)&v100 + 2) = v70;
          v60 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/Trans"
                "port.c:%d: _CTServerConnectionRegisterForNotification failed (%d.%d)";
LABEL_56:
          v61 = v59;
LABEL_57:
          _os_log_error_impl(&dword_1D8A54000, v61, OS_LOG_TYPE_ERROR, v60, buf, 0x2Eu);
          goto LABEL_84;
        }
        if (v72 >= 7)
        {
          v74 = VRTraceErrorLogLevelToCSTR();
          v75 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315650;
            v93 = v74;
            v94 = 2080;
            v95 = "TPSetupBasebandNotifications";
            v96 = 1024;
            v97 = 779;
            _os_log_impl(&dword_1D8A54000, v75, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Registered QoS notification from CommCenter.", buf, 0x1Cu);
          }
        }
        CFDictionaryAddValue(*(CFMutableDictionaryRef *)(v9 + 8), (const void *)*MEMORY[0x1E0CA74F8], (const void *)*MEMORY[0x1E0CA7538]);
        v76 = _CTServerConnectionRequestQOS();
        v77 = v76;
        v78 = HIDWORD(v76);
        v79 = HIDWORD(v76) | v76;
        v80 = VRTraceGetErrorLogLevelForModule();
        if (v79)
        {
          if (v80 < 3)
            goto LABEL_84;
          v81 = VRTraceErrorLogLevelToCSTR();
          v82 = *MEMORY[0x1E0CF2758];
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            goto LABEL_84;
          *(_DWORD *)buf = 136316418;
          v93 = v81;
          v94 = 2080;
          v95 = "TPSetupBasebandNotifications";
          v96 = 1024;
          v97 = 786;
          v98 = 1024;
          *(_DWORD *)v99 = 786;
          *(_WORD *)&v99[4] = 1024;
          *(_DWORD *)&v99[6] = v77;
          LOWORD(v100) = 1024;
          *(_DWORD *)((char *)&v100 + 2) = v78;
          v60 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/Trans"
                "port.c:%d: _CTServerConnectionRegisterForNotification failed (%d.%d)";
          v61 = v82;
          goto LABEL_57;
        }
        if (v80 < 7)
          goto LABEL_84;
        v83 = VRTraceErrorLogLevelToCSTR();
        v84 = *MEMORY[0x1E0CF2758];
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          goto LABEL_84;
        *(_DWORD *)buf = 136315650;
        v93 = v83;
        v94 = 2080;
        v95 = "TPSetupBasebandNotifications";
        v96 = 1024;
        v97 = 790;
        v31 = "SIP [%s] %s:%d Requested QoS from CommCenter.";
        v32 = v84;
        v33 = 28;
      }
      else
      {
        if ((int)VRTraceGetErrorLogLevelForModule() < 5)
          goto LABEL_84;
        v28 = VRTraceErrorLogLevelToCSTR();
        v29 = *MEMORY[0x1E0CF2758];
        if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          goto LABEL_84;
        v30 = *(_DWORD *)(v9 + 56);
        *(_DWORD *)buf = 136316162;
        v93 = v28;
        v94 = 2080;
        v95 = "TPSetupBasebandNotifications";
        v96 = 1024;
        v97 = 657;
        v98 = 1024;
        *(_DWORD *)v99 = 657;
        *(_WORD *)&v99[4] = 1024;
        *(_DWORD *)&v99[6] = v30;
        v31 = "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/Transpo"
              "rt.c:%d: TPSetupBaseband called, but fEnableCellular %d";
        v32 = v29;
        v33 = 40;
      }
      _os_log_impl(&dword_1D8A54000, v32, OS_LOG_TYPE_DEFAULT, v31, buf, v33);
LABEL_84:
      pthread_mutex_unlock(v20);
      goto LABEL_85;
    }
    return 2148466690;
  }
  else
  {
    v10 = 2148466689;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v11 = VRTraceErrorLogLevelToCSTR();
      v12 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        v93 = v11;
        v94 = 2080;
        v95 = "TPUpdateBaseband";
        v96 = 1024;
        v97 = 835;
        _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Invalid call type passed to TPUpdateBaseband", buf, 0x1Cu);
      }
    }
  }
  return v10;
}

uint64_t TPCleanupBasebandNotifications(uint64_t result)
{
  uint64_t v1;
  pthread_mutex_t *v2;
  unint64_t v3;
  int v4;
  unint64_t v5;
  int v6;
  int ErrorLogLevelForModule;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  NSObject *v11;
  unint64_t v12;
  int v13;
  unint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;
  NSObject *v20;
  const void *v21;
  int v22;
  uint64_t v23;
  __int16 v24;
  const char *v25;
  __int16 v26;
  int v27;
  __int16 v28;
  int v29;
  __int16 v30;
  int v31;
  __int16 v32;
  int v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v1 = result + 34456;
  if (*(_DWORD *)(result + 34512))
  {
    v2 = (pthread_mutex_t *)(result + 34392);
    pthread_mutex_lock((pthread_mutex_t *)(result + 34392));
    if (*(_QWORD *)v1)
    {
      if (*(_DWORD *)(v1 + 32) && *(_QWORD *)(v1 + 8))
      {
        v3 = _CTServerConnectionSetPacketNotificationFilter();
        v4 = v3;
        v5 = HIDWORD(v3);
        v6 = HIDWORD(v3) | v3;
        ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
        if (v6)
        {
          if (ErrorLogLevelForModule >= 3)
          {
            v8 = VRTraceErrorLogLevelToCSTR();
            v9 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            {
              v22 = 136316418;
              v23 = v8;
              v24 = 2080;
              v25 = "TPCleanupBasebandNotifications";
              v26 = 1024;
              v27 = 810;
              v28 = 1024;
              v29 = 810;
              v30 = 1024;
              v31 = v4;
              v32 = 1024;
              v33 = v5;
              _os_log_error_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_ERROR, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/Transport.c:%d: _CTServerConnectionSetPacketNotificationFilter failed (%d.%d)", (uint8_t *)&v22, 0x2Eu);
            }
          }
        }
        else if (ErrorLogLevelForModule >= 7)
        {
          v10 = VRTraceErrorLogLevelToCSTR();
          v11 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v22 = 136315650;
            v23 = v10;
            v24 = 2080;
            v25 = "TPCleanupBasebandNotifications";
            v26 = 1024;
            v27 = 808;
            _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Disabled baseband notification filter.", (uint8_t *)&v22, 0x1Cu);
          }
        }
      }
      if (*(_DWORD *)(v1 + 60) && *(_DWORD *)(v1 + 64))
      {
        v12 = _CTServerConnectionReleaseQOS();
        v13 = v12;
        v14 = HIDWORD(v12);
        v15 = HIDWORD(v12) | v12;
        v16 = VRTraceGetErrorLogLevelForModule();
        if (v15)
        {
          if (v16 >= 3)
          {
            v17 = VRTraceErrorLogLevelToCSTR();
            v18 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            {
              v22 = 136316418;
              v23 = v17;
              v24 = 2080;
              v25 = "TPCleanupBasebandNotifications";
              v26 = 1024;
              v27 = 819;
              v28 = 1024;
              v29 = 819;
              v30 = 1024;
              v31 = v13;
              v32 = 1024;
              v33 = v14;
              _os_log_error_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_ERROR, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/Transport.c:%d: _CTServerConnectionReleaseQOS failed (%d.%d)", (uint8_t *)&v22, 0x2Eu);
            }
          }
        }
        else if (v16 >= 7)
        {
          v19 = VRTraceErrorLogLevelToCSTR();
          v20 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v22 = 136315650;
            v23 = v19;
            v24 = 2080;
            v25 = "TPCleanupBasebandNotifications";
            v26 = 1024;
            v27 = 817;
            _os_log_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Stopped QoS from CommCenter.", (uint8_t *)&v22, 0x1Cu);
          }
        }
      }
    }
    v21 = *(const void **)(v1 + 8);
    if (v21)
    {
      CFRelease(v21);
      *(_QWORD *)(v1 + 8) = 0;
    }
    return pthread_mutex_unlock(v2);
  }
  return result;
}

uint64_t TPUpdateQualityIndictor(uint64_t a1, int a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  pthread_mutex_t *v7;
  uint64_t updated;
  int ErrorLogLevelForModule;
  uint64_t v11;
  NSObject *v12;
  int v13;
  uint64_t v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v5 = CheckInHandleDebug();
  if (!v5)
    return 2148466690;
  v6 = v5;
  v7 = (pthread_mutex_t *)(v5 + 34392);
  pthread_mutex_lock((pthread_mutex_t *)(v5 + 34392));
  if (*(_QWORD *)(v6 + 34456))
  {
    updated = _CTServerConnectionUpdateProtocolQualityOfService();
    ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    if (updated)
    {
      if (ErrorLogLevelForModule >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          TPUpdateQualityIndictor_cold_1();
      }
    }
    else if (ErrorLogLevelForModule >= 7)
    {
      v11 = VRTraceErrorLogLevelToCSTR();
      v12 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v13 = 136316162;
        v14 = v11;
        v15 = 2080;
        v16 = "TPUpdateQualityIndictor";
        v17 = 1024;
        v18 = 902;
        v19 = 1024;
        v20 = a2;
        v21 = 1024;
        v22 = a3;
        _os_log_impl(&dword_1D8A54000, v12, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TPUpdateQualityIndictor: (%d), ISIPv6 (%d).", (uint8_t *)&v13, 0x28u);
      }
    }
  }
  pthread_mutex_unlock(v7);
  CheckOutHandleDebug();
  return 0;
}

uint64_t TPFlushBasebandQueue(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  pthread_mutex_t *v5;
  unint64_t v6;
  int v7;
  unint64_t v8;
  uint64_t v9;
  NSObject *v10;
  int v12;
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v2 = 2148466689;
  if (a2)
  {
    v3 = CheckInHandleDebug();
    if (v3)
    {
      v4 = v3;
      v5 = (pthread_mutex_t *)(v3 + 34392);
      pthread_mutex_lock((pthread_mutex_t *)(v3 + 34392));
      if (*(_QWORD *)(v4 + 34456) && (v6 = _CTServerConnectionDropIPPackets(), v7 = v6, v8 = HIDWORD(v6), v6))
      {
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          v9 = VRTraceErrorLogLevelToCSTR();
          v10 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          {
            v12 = 136316418;
            v13 = v9;
            v14 = 2080;
            v15 = "TPFlushBasebandQueue";
            v16 = 1024;
            v17 = 930;
            v18 = 1024;
            v19 = 930;
            v20 = 1024;
            v21 = v7;
            v22 = 1024;
            v23 = v8;
            _os_log_error_impl(&dword_1D8A54000, v10, OS_LOG_TYPE_ERROR, "SIP [%s] %s:%d /Library/Caches/com.apple.xbs/Sources/AVConference/AVConference.subproj/Sources/SIP/Transport.c:%d: _CTServerConnectionSetPacketNotificationFilter failed (%d.%d)", (uint8_t *)&v12, 0x2Eu);
          }
        }
      }
      else
      {
        v2 = 0;
      }
      pthread_mutex_unlock(v5);
      CheckOutHandleDebug();
    }
    else
    {
      return 2148466690;
    }
  }
  return v2;
}

uint64_t TPSendUDPPacketARPL(uint64_t a1, void *a2, int a3, uint64_t a4, int *a5, int a6, char a7, int a8)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;
  NSObject *v20;
  uint64_t v21;
  NSObject *v22;
  int *v23;
  int v24;
  int v25;
  uint64_t v26;
  pthread_rwlock_t *v27;
  uint64_t v28;
  _QWORD *v29;
  int v30;
  int *v31;
  int v32;
  uint64_t v35;
  uint64_t v36;
  NSObject *v37;
  uint64_t v38;
  int v39;
  int v41;
  _OWORD v42[9];
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  uint8_t buf[4];
  uint64_t v55;
  __int16 v56;
  const char *v57;
  __int16 v58;
  int v59;
  uint64_t v60;

  v60 = *MEMORY[0x1E0C80C00];
  v52 = 0u;
  v53 = 0u;
  v50 = 0u;
  v51 = 0u;
  v48 = 0u;
  v49 = 0u;
  v46 = 0u;
  v47 = 0u;
  v44 = 0u;
  v45 = 0u;
  v43 = 0u;
  memset(v42, 0, sizeof(v42));
  v15 = CheckInHandleDebug();
  if (!v15)
    return 2148466690;
  v16 = v15;
  v41 = a3;
  if ((a7 & 1) == 0 && (int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v17 = VRTraceErrorLogLevelToCSTR();
    v18 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      v55 = v17;
      v56 = 2080;
      v57 = "TPSendUDPPacketARPL";
      v58 = 1024;
      v59 = 1039;
      _os_log_impl(&dword_1D8A54000, v18, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d >>>>>  ARPL packet is UNENCRYPTED in TPSendUDPPacketARPL (in Transport) <<<<<", buf, 0x1Cu);
    }
  }
  if (!a2 && (int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v19 = VRTraceErrorLogLevelToCSTR();
    v20 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      v55 = v19;
      v56 = 2080;
      v57 = "TPSendUDPPacketARPL";
      v58 = 1024;
      v59 = 1042;
      _os_log_impl(&dword_1D8A54000, v20, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d >>>>>  ARPL packet pbMsg is NULL in TPSendUDPPacketARPL(in Transport) <<<<<", buf, 0x1Cu);
    }
  }
  if (!v41 && (int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v21 = VRTraceErrorLogLevelToCSTR();
    v22 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      v55 = v21;
      v56 = 2080;
      v57 = "TPSendUDPPacketARPL";
      v58 = 1024;
      v59 = 1045;
      _os_log_impl(&dword_1D8A54000, v22, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d >>>>>  ARPL packet iLen==0 in TPSendUDPPacketARPL(in Transport) <<<<<", buf, 0x1Cu);
    }
  }
  LODWORD(v42[0]) = a6;
  BYTE12(v42[0]) = a7;
  DWORD2(v43) = a8;
  BYTE9(v44) = 1;
  if (a6 == 4)
  {
    v25 = 1;
    v23 = a5;
  }
  else
  {
    v23 = a5;
    if (a6 == 5)
    {
      if ((a7 & 1) == 0
        && (int)VRTraceGetErrorLogLevelForModule() >= 3
        && (VRTraceErrorLogLevelToCSTR(), os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR)))
      {
        TPSendUDPPacketARPL_cold_4();
        if (!a2)
          goto LABEL_20;
      }
      else if (!a2)
      {
LABEL_20:
        if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
        {
          VRTraceErrorLogLevelToCSTR();
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
            TPSendUDPPacketARPL_cold_3();
        }
      }
      v24 = v41;
      if (v41)
      {
        v25 = 0;
        goto LABEL_55;
      }
      if ((int)VRTraceGetErrorLogLevelForModule() < 3)
      {
        v25 = 0;
      }
      else
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          TPSendUDPPacketARPL_cold_2();
        v25 = 0;
        v24 = 0;
      }
      goto LABEL_29;
    }
    v25 = 0;
  }
  v24 = v41;
LABEL_29:
  if (a2 || v24)
  {
LABEL_55:
    v27 = (pthread_rwlock_t *)(v16 + 1064);
    pthread_rwlock_rdlock((pthread_rwlock_t *)(v16 + 1064));
    v35 = SendUDPPacketForCList(*(_QWORD *)(v16 + 1056), a2, v24, a4, v23, (int *)v42);
    v26 = v35;
    if (v25 && (_DWORD)v35 == -2146500586)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
      {
        v36 = VRTraceErrorLogLevelToCSTR();
        v37 = *MEMORY[0x1E0CF2758];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          v55 = v36;
          v56 = 2080;
          v57 = "SendUDPPacket";
          v58 = 1024;
          v59 = 1003;
          _os_log_impl(&dword_1D8A54000, v37, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Retry SIP packet using default result key.", buf, 0x1Cu);
        }
      }
      LODWORD(v44) = 1;
      v38 = SendUDPPacketForCList(*(_QWORD *)(v16 + 1056), a2, v24, a4, v23, (int *)v42);
      if ((v38 & 0x80000000) == 0)
        goto LABEL_61;
      v26 = v38;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          TPSendUDPPacketARPL_cold_1();
        v24 = v41;
      }
    }
    pthread_rwlock_unlock((pthread_rwlock_t *)(v16 + 1064));
    if ((_DWORD)v26 == -2146500586)
    {
      v27 = (pthread_rwlock_t *)(v16 + 1272);
      pthread_rwlock_rdlock((pthread_rwlock_t *)(v16 + 1272));
      LODWORD(v42[0]) = 0;
      BYTE12(v42[0]) = 0;
      DWORD2(v43) = 0;
      v26 = SendUDPPacketForCList(*(_QWORD *)(v16 + 1264), a2, v24, a4, v23, (int *)v42);
      goto LABEL_74;
    }
    goto LABEL_75;
  }
  v27 = (pthread_rwlock_t *)(v16 + 1272);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(v16 + 1272));
  v28 = *(_QWORD *)(v16 + 1264);
  if (!v28)
  {
LABEL_61:
    v26 = 0;
    goto LABEL_74;
  }
  v29 = (_QWORD *)(v16 + 1264);
  v30 = *(_DWORD *)a4 & 1;
  while ((*(_DWORD *)(v28 + 2072) & 1) != v30)
  {
LABEL_44:
    if ((*(_DWORD *)(v28 + 2072) & 1) != 0)
      goto LABEL_47;
    if (!*(_DWORD *)(v28 + 2092))
      goto LABEL_52;
LABEL_53:
    v29 = (_QWORD *)(v28 + 2144);
    v28 = *(_QWORD *)(v28 + 2144);
    if (!v28)
      goto LABEL_73;
  }
  v31 = (int *)(v28 + 2092);
  if (!v30)
  {
    v32 = *v31;
    if (v32 != *(_DWORD *)(a4 + 20))
    {
      if (!v32)
        goto LABEL_52;
      goto LABEL_53;
    }
    goto LABEL_43;
  }
  if (*(_QWORD *)v31 == *(_QWORD *)(a4 + 20) && *(_QWORD *)(v28 + 2100) == *(_QWORD *)(a4 + 28))
  {
LABEL_43:
    if (*(unsigned __int16 *)(v28 + 2108) == *(unsigned __int16 *)(a4 + 36))
      goto LABEL_72;
    goto LABEL_44;
  }
LABEL_47:
  if (*(_QWORD *)(v28 + 2092) != *MEMORY[0x1E0C83920]
    || *(_QWORD *)(v28 + 2100) != *(_QWORD *)(MEMORY[0x1E0C83920] + 8))
  {
    goto LABEL_53;
  }
LABEL_52:
  if (*(unsigned __int16 *)(v28 + 2108) != *(unsigned __int16 *)(a4 + 36))
    goto LABEL_53;
LABEL_72:
  *v29 = *(_QWORD *)(v28 + 2144);
  ICERemoveOneInterface();
  free((void *)v28);
  v39 = *(_DWORD *)(v16 + 12);
  *(_DWORD *)(v16 + 12) = -1;
  VTP_Close(v39);
LABEL_73:
  v26 = 0;
LABEL_74:
  pthread_rwlock_unlock(v27);
LABEL_75:
  CheckOutHandleDebug();
  return v26;
}

uint64_t TPSendUDPDataPacket(uint64_t a1, _OWORD *a2, int a3, int a4, int a5, char a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  _DWORD v16[2];
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v34 = 0u;
  v35 = 0u;
  v33 = 0u;
  v36 = 0;
  v32 = 0u;
  v31 = 0u;
  v30 = 0u;
  v29 = 0u;
  v28 = 0u;
  v27 = 0u;
  v26 = 0u;
  v25 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  if (!CheckInHandleDebug())
    return 2148466690;
  BYTE4(v17) = a6;
  LODWORD(v26) = 0;
  v16[0] = a7;
  v16[1] = a5;
  LODWORD(v17) = a4;
  BYTE1(v27) = 1;
  v13 = VTP_Send(-1, a2, a3, 0, (uint64_t)v16);
  v14 = 0;
  if (v13 == -1)
    v14 = *__error() | 0xC00F0000;
  CheckOutHandleDebug();
  return v14;
}

uint64_t TPCreateHandle(uint64_t *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10, uint64_t a11)
{
  uint64_t v15;
  NSObject *v16;
  _QWORD *v17;
  _QWORD *v18;
  const void *v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(void);
  void (*v25)(uint64_t);
  uint64_t v26;
  NSObject *v27;
  uint64_t v28;
  char *v29;
  char *v30;
  char *v31;
  uint64_t i;
  uint64_t v33;
  void (*v34)(void);
  uint64_t v35;
  NSObject *v36;
  uint64_t v37;
  uint64_t v38;
  NSObject *v39;
  uint64_t v40;
  NSObject *CustomRootQueue;
  int v42;
  uint64_t v43;
  NSObject *v44;
  uint64_t v45;
  uint64_t v46;
  NSObject *v47;
  uint64_t j;
  const void *v49;
  void (*v50)(void);
  pthread_rwlock_t *v52;
  uint8_t v57[4];
  uint64_t v58;
  __int16 v59;
  const char *v60;
  __int16 v61;
  int v62;
  __int16 v63;
  _BYTE v64[18];
  _BYTE buf[24];
  _BYTE v66[24];
  uint64_t (*v67)(uint64_t, int, const void *, int, __int16);
  uint64_t (*v68)(uint64_t, int, uint64_t, int, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v69)(uint64_t, int, __int128 *, int);
  pthread_mutexattr_t v70;
  uint64_t v71;

  v71 = *MEMORY[0x1E0C80C00];
  pthread_mutex_lock(&g_xTPHandle);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v15 = VRTraceErrorLogLevelToCSTR();
    v16 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136316162;
      *(_QWORD *)&buf[4] = v15;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "TPCreateHandle";
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)v66 = 1913;
      *(_WORD *)&v66[4] = 1024;
      *(_DWORD *)&v66[6] = g_iHandleRefCount;
      *(_WORD *)&v66[10] = 2048;
      *(_QWORD *)&v66[12] = g_hActualTPHandle;
      _os_log_impl(&dword_1D8A54000, v16, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d ((((( In TPCreateHandle with g_iHandleRefCount = %d and g_hActualTPHandle = %p)))))", buf, 0x2Cu);
    }
  }
  if (g_iHandleRefCount)
  {
    v17 = (_QWORD *)CheckInHandleDebug();
    if (!v17)
    {
      pthread_mutex_unlock(&g_xTPHandle);
      return 2148466690;
    }
    v18 = v17 + 4289;
    if (a3)
      *v18 = a3;
    if (a4)
      v17[4290] = a4;
    if (a5)
      v17[4292] = a5;
    if (a6)
      v17[4293] = a6;
    if (a7)
      v17[4294] = a7;
    if (a8)
      v17[4295] = a8;
    if (a9)
    {
      v19 = (const void *)v17[4297];
      v17[4297] = a9;
      CFRetain(a9);
      if (v19)
        CFRelease(v19);
    }
    if (a10)
      v18[30] = a10;
    if (a11)
    {
      v22 = v18[31];
      v21 = v18 + 31;
      v20 = v22;
      v23 = *(_QWORD *)(a11 + 16);
      *(_OWORD *)v21 = *(_OWORD *)a11;
      v24 = (void (*)(void))v21[1];
      v25 = (void (*)(uint64_t))v21[2];
      v21[2] = v23;
      if (v24 && *v21)
        v24();
      if (v25 && v20)
        v25(v20);
    }
    *a1 = g_hActualTPHandle;
    ++g_iHandleRefCount;
    CheckOutHandleDebug();
  }
  else
  {
    v29 = (char *)malloc_type_calloc(1uLL, 0x8760uLL, 0x10E0040F635D44DuLL);
    if (!v29)
    {
      v28 = 2148466691;
      pthread_mutex_unlock(&g_xTPHandle);
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          TPCreateHandle_cold_1();
      }
      return v28;
    }
    v30 = v29;
    v31 = v29 + 34312;
    *(_DWORD *)v29 = a2;
    *((_QWORD *)v29 + 1) = 0xFFFFFFFF00000000;
    v52 = (pthread_rwlock_t *)(v29 + 1064);
    pthread_rwlock_init((pthread_rwlock_t *)(v29 + 1064), 0);
    pthread_rwlock_init((pthread_rwlock_t *)(v30 + 1272), 0);
    pthread_mutex_init((pthread_mutex_t *)(v30 + 992), 0);
    pthread_mutex_init((pthread_mutex_t *)(v30 + 1480), 0);
    pthread_mutex_init((pthread_mutex_t *)(v30 + 34584), 0);
    pthread_mutex_init((pthread_mutex_t *)(v30 + 34392), 0);
    v70.__sig = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)v70.__opaque = 0xAAAAAAAAAAAAAAAALL;
    if (!pthread_mutexattr_init(&v70))
    {
      for (i = 0; i != 0x8000; i += 128)
      {
        pthread_mutexattr_settype(&v70, 2);
        pthread_mutex_init((pthread_mutex_t *)&v30[i + 1560], &v70);
        pthread_cond_init((pthread_cond_t *)&v30[i + 1624], 0);
      }
      pthread_mutexattr_destroy(&v70);
    }
    *((_QWORD *)v31 + 2) = 0xFFFFFFFFLL;
    *(_QWORD *)v31 = a3;
    *((_QWORD *)v31 + 1) = a4;
    *((_QWORD *)v31 + 3) = a5;
    *((_QWORD *)v31 + 4) = a6;
    *((_QWORD *)v31 + 5) = a7;
    *((_QWORD *)v31 + 6) = a8;
    *((_QWORD *)v31 + 8) = a9;
    if (a9)
      CFRetain(a9);
    *((_DWORD *)v31 + 18) = VCTestMonitorManager_GetEnableLoopbackInterface();
    if (a10)
      *((_QWORD *)v31 + 30) = a10;
    if (a11)
    {
      v33 = *(_QWORD *)(a11 + 16);
      *(_OWORD *)(v31 + 248) = *(_OWORD *)a11;
      *((_QWORD *)v31 + 33) = v33;
      v34 = (void (*)(void))*((_QWORD *)v31 + 32);
      if (v34)
      {
        if (*((_QWORD *)v31 + 31))
          v34();
      }
    }
    *((_QWORD *)v31 + 27) = 0;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v35 = VRTraceErrorLogLevelToCSTR();
      v36 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v37 = *a1;
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)&buf[4] = v35;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "TPCreateHandle";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)v66 = 1968;
        *(_WORD *)&v66[4] = 2048;
        *(_QWORD *)&v66[6] = a1;
        *(_WORD *)&v66[14] = 2048;
        *(_QWORD *)&v66[16] = v37;
        _os_log_impl(&dword_1D8A54000, v36, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d ((((( In TPCreateHandle [A] phTP = %p and *phTP = %ld)))))", buf, 0x30u);
      }
    }
    *a1 = CreateHandle();
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v38 = VRTraceErrorLogLevelToCSTR();
      v39 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v40 = *a1;
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)&buf[4] = v38;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "TPCreateHandle";
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)v66 = 1972;
        *(_WORD *)&v66[4] = 2048;
        *(_QWORD *)&v66[6] = a1;
        *(_WORD *)&v66[14] = 2048;
        *(_QWORD *)&v66[16] = v40;
        _os_log_impl(&dword_1D8A54000, v39, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d ((((( In TPCreateHandle [B] phTP = %p and *phTP = %ld)))))", buf, 0x30u);
      }
    }
    if (*a1 == 0xFFFFFFFFLL)
    {
      pthread_rwlock_destroy(v52);
      pthread_rwlock_destroy((pthread_rwlock_t *)(v30 + 1272));
      pthread_mutex_destroy((pthread_mutex_t *)(v30 + 992));
      pthread_mutex_destroy((pthread_mutex_t *)(v30 + 1480));
      pthread_mutex_destroy((pthread_mutex_t *)(v30 + 34584));
      for (j = 0; j != 0x8000; j += 128)
      {
        pthread_mutex_destroy((pthread_mutex_t *)&v30[j + 1560]);
        pthread_cond_destroy((pthread_cond_t *)&v30[j + 1624]);
      }
      v49 = (const void *)*((_QWORD *)v31 + 8);
      if (v49)
        CFRelease(v49);
      v50 = (void (*)(void))*((_QWORD *)v31 + 33);
      if (v50 && *((_QWORD *)v31 + 31))
        v50();
      free(v30);
      pthread_mutex_unlock(&g_xTPHandle);
      return 2148466693;
    }
    CustomRootQueue = VCDispatchQueue_GetCustomRootQueue(37);
    *((_QWORD *)v31 + 7) = dispatch_queue_create_with_target_V2("com.apple.AVConference.Transport.ICEConnectivityCallbackQueue", 0, CustomRootQueue);
    *(_QWORD *)buf = TPSendUDPPacket;
    *(_QWORD *)&buf[8] = TPRecvUDPPacketWithTimeout;
    *(_QWORD *)&buf[16] = TPConnectedCallback;
    *(_QWORD *)v66 = TPCancelRecvUDP;
    *(_QWORD *)&v66[8] = TPProcessICENomination;
    *(_QWORD *)&v66[16] = 0;
    v67 = TPNewCandidatesCallback;
    v68 = TPShouldNominateICECandidatePair;
    v69 = TPRemoveIPPort;
    v42 = ICECreateHandleWithCallback();
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v43 = VRTraceErrorLogLevelToCSTR();
      v44 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v45 = *a1;
        *(_DWORD *)v57 = 136316162;
        v58 = v43;
        v59 = 2080;
        v60 = "TPCreateHandle";
        v61 = 1024;
        v62 = 2006;
        v63 = 2048;
        *(_QWORD *)v64 = a1;
        *(_WORD *)&v64[8] = 2048;
        *(_QWORD *)&v64[10] = v45;
        _os_log_impl(&dword_1D8A54000, v44, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d ((((( In TPCreateHandle [C] phTP = %p and *phTP = %ld)))))", v57, 0x30u);
      }
    }
    g_hActualTPHandle = *a1;
    g_iHandleRefCount = 1;
    if (v42 < 0)
    {
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          TPCreateHandle_cold_2();
      }
      TPCloseHandle();
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v46 = VRTraceErrorLogLevelToCSTR();
      v47 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v57 = 136316162;
        v58 = v46;
        v59 = 2080;
        v60 = "TPCreateHandle";
        v61 = 1024;
        v62 = 2016;
        v63 = 1024;
        *(_DWORD *)v64 = g_iHandleRefCount;
        *(_WORD *)&v64[4] = 2048;
        *(_QWORD *)&v64[6] = g_hActualTPHandle;
        _os_log_impl(&dword_1D8A54000, v47, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d ((((( In TPCreateHandle AREA 1 with g_iHandleRefCount = %d and g_hActualTPHandle = %p)))))", v57, 0x2Cu);
      }
    }
  }
  pthread_mutex_unlock(&g_xTPHandle);
  if ((int)VRTraceGetErrorLogLevelForModule() < 7)
    return 0;
  v26 = VRTraceErrorLogLevelToCSTR();
  v27 = *MEMORY[0x1E0CF2758];
  v28 = 0;
  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136316162;
    *(_QWORD *)&buf[4] = v26;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = "TPCreateHandle";
    *(_WORD *)&buf[22] = 1024;
    *(_DWORD *)v66 = 2066;
    *(_WORD *)&v66[4] = 1024;
    *(_DWORD *)&v66[6] = g_iHandleRefCount;
    *(_WORD *)&v66[10] = 2048;
    *(_QWORD *)&v66[12] = g_hActualTPHandle;
    _os_log_impl(&dword_1D8A54000, v27, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d ((((( Leaving TPCreateHandle successfully with g_iHandleRefCount = %d and g_hActualTPHandle = %p)))))", buf, 0x2Cu);
    return 0;
  }
  return v28;
}

uint64_t TPSendUDPPacket(uint64_t a1, int a2, _OWORD *a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, char a8)
{
  uint64_t v14;
  _OWORD v16[9];
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  v14 = 2148466690;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  v17 = 0u;
  memset(v16, 0, sizeof(v16));
  if (CheckInHandleDebug())
  {
    LODWORD(v16[0]) = 0;
    DWORD2(v16[0]) = a2;
    BYTE12(v16[0]) = a8;
    *((_QWORD *)&v17 + 1) = 0x100000000;
    BYTE9(v18) = 1;
    if (VTP_SendWithSourceDestinationIP(a5, a6, a3, a4, 0, (unsigned int *)v16) == -1)
      v14 = 2148466721;
    else
      v14 = 0;
    CheckOutHandleDebug();
  }
  return v14;
}

uint64_t TPRecvUDPPacketWithTimeout(uint64_t a1, uint64_t a2, void *a3, _DWORD *a4, uint64_t a5, uint64_t a6, _QWORD *a7, int a8, unsigned int a9)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v16;
  uint64_t v17;
  double v18;
  uint64_t v19;
  int v20;
  double v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  int v26;
  int *v27;
  int v28;
  uint64_t v31;
  double v32;
  __darwin_time_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  size_t v37;
  uint64_t v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  _DWORD *v42;
  uint64_t v43;
  uint64_t v44;
  _QWORD *v45;
  size_t v46;
  uint64_t v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  void *__dst;
  uint64_t v53;
  _QWORD *v54;
  timespec v56;
  uint64_t v57;

  v9 = a9;
  v57 = *MEMORY[0x1E0C80C00];
  v10 = 2148466710;
  if (a9 > 0xFF)
    return v10;
  v16 = CheckInHandleDebug();
  if (!v16)
    return 2148466690;
  v17 = v16;
  __dst = a3;
  v53 = a6;
  v54 = a7;
  v18 = micro();
  pthread_mutex_lock((pthread_mutex_t *)(v17 + 1560 + ((unint64_t)a9 << 7)));
  v19 = 0;
  v20 = *(unsigned __int16 *)(a5 + 36);
  v21 = (double)a8 / 1000.0;
  v22 = (_QWORD *)MEMORY[0x1E0C83920];
  while (1)
  {
    v23 = v17 + (v9 << 7);
    v24 = (uint64_t *)(v23 + 1552);
    if (!v20)
    {
      if (*v24)
      {
        v10 = v19;
      }
      else
      {
        v31 = v17 + (v9 << 7);
        if (*(_DWORD *)(v31 + 1544))
        {
          v42 = (_DWORD *)(v31 + 1544);
LABEL_57:
          *v42 = 0;
LABEL_58:
          v43 = v17 + (v9 << 7);
          v44 = *(_QWORD *)(v43 + 1552);
          if (v44)
          {
            v45 = (_QWORD *)(v43 + 1552);
            v46 = *(int *)(v44 + 2052);
            *a4 = v46;
            memcpy(__dst, (const void *)v44, v46);
            v47 = *(_QWORD *)(v44 + 2088);
            v48 = *(_OWORD *)(v44 + 2072);
            *(_OWORD *)a5 = *(_OWORD *)(v44 + 2056);
            *(_OWORD *)(a5 + 16) = v48;
            *(_QWORD *)(a5 + 32) = v47;
            v49 = *(_OWORD *)(v44 + 2112);
            v50 = *(_OWORD *)(v44 + 2096);
            *(_QWORD *)(v53 + 32) = *(_QWORD *)(v44 + 2128);
            *(_OWORD *)v53 = v50;
            *(_OWORD *)(v53 + 16) = v49;
            if (v54)
              *v54 = *(_QWORD *)(v44 + 2136);
            *v45 = *(_QWORD *)(v44 + 2144);
            free((void *)v44);
            v19 = 0;
          }
          goto LABEL_62;
        }
        pthread_mutex_unlock((pthread_mutex_t *)(v31 + 1560));
        pthread_mutex_lock((pthread_mutex_t *)(v17 + 1560));
        if (*(_QWORD *)(v17 + 1552))
        {
          v9 = 0;
        }
        else
        {
          v9 = 0;
          if (!*(_DWORD *)(v17 + 1544))
          {
            LODWORD(v19) = -2146500586;
            goto LABEL_35;
          }
          v10 = 2148466718;
        }
      }
      v42 = (_DWORD *)(v17 + (v9 << 7) + 1544);
      v19 = v10;
      goto LABEL_57;
    }
    if (*(_DWORD *)(v23 + 1544))
      goto LABEL_44;
    v25 = *v24;
    if (*v24)
      break;
LABEL_35:
    v32 = v21 - (micro() - v18);
    if (v32 < 0.0)
    {
      *(_DWORD *)(v17 + (v9 << 7) + 1544) = 0;
      v19 = 2148466711;
      goto LABEL_50;
    }
    v56.tv_sec = 0xAAAAAAAAAAAAAAAALL;
    v56.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    convertTimeoutToRelativeTimespec(v32);
    v56.tv_sec = v33;
    v56.tv_nsec = v34;
    v35 = v17 + (v9 << 7);
    v36 = pthread_cond_timedwait_relative_np((pthread_cond_t *)(v35 + 1624), (pthread_mutex_t *)(v35 + 1560), &v56);
    if (v36)
    {
      if (v36 == 60)
        v19 = 2148466711;
      else
        v19 = v36 | 0xC00F0000;
      *(_DWORD *)(v35 + 1544) = 0;
LABEL_50:
      if (v20)
        goto LABEL_62;
      goto LABEL_58;
    }
    if (*(_DWORD *)(v35 + 1544))
      v19 = 2148466718;
    else
      v19 = v19;
  }
  v26 = *(_DWORD *)a5 & 1;
  while ((*(_DWORD *)(v25 + 2056) & 1) != v26)
  {
LABEL_19:
    if ((*(_DWORD *)(v25 + 2056) & 1) != 0)
      goto LABEL_22;
    if (!*(_DWORD *)(v25 + 2076))
      goto LABEL_27;
LABEL_28:
    v24 = (uint64_t *)(v25 + 2144);
    v25 = *(_QWORD *)(v25 + 2144);
    if (!v25)
      goto LABEL_35;
  }
  v27 = (int *)(v25 + 2076);
  if (!v26)
  {
    v28 = *v27;
    if (v28 != *(_DWORD *)(a5 + 20))
    {
      if (!v28)
        goto LABEL_27;
      goto LABEL_28;
    }
    goto LABEL_18;
  }
  if (*(_QWORD *)v27 == *(_QWORD *)(a5 + 20) && *(_QWORD *)(v25 + 2084) == *(_QWORD *)(a5 + 28))
  {
LABEL_18:
    if (*(unsigned __int16 *)(v25 + 2092) == *(unsigned __int16 *)(a5 + 36))
      goto LABEL_41;
    goto LABEL_19;
  }
LABEL_22:
  if (*(_QWORD *)(v25 + 2076) != *v22 || *(_QWORD *)(v25 + 2084) != v22[1])
    goto LABEL_28;
LABEL_27:
  if (*(unsigned __int16 *)(v25 + 2092) != *(unsigned __int16 *)(a5 + 36))
    goto LABEL_28;
LABEL_41:
  v37 = *(int *)(v25 + 2052);
  *a4 = v37;
  memcpy(__dst, (const void *)v25, v37);
  v38 = *(_QWORD *)(v25 + 2088);
  v39 = *(_OWORD *)(v25 + 2072);
  *(_OWORD *)a5 = *(_OWORD *)(v25 + 2056);
  *(_OWORD *)(a5 + 16) = v39;
  *(_QWORD *)(a5 + 32) = v38;
  v40 = *(_OWORD *)(v25 + 2112);
  v41 = *(_OWORD *)(v25 + 2096);
  *(_QWORD *)(v53 + 32) = *(_QWORD *)(v25 + 2128);
  *(_OWORD *)v53 = v41;
  *(_OWORD *)(v53 + 16) = v40;
  if (v54)
    *v54 = *(_QWORD *)(v25 + 2136);
  *v24 = *(_QWORD *)(v25 + 2144);
  free((void *)v25);
LABEL_44:
  *(_DWORD *)(v23 + 1544) = 0;
LABEL_62:
  pthread_mutex_unlock((pthread_mutex_t *)(v17 + (v9 << 7) + 1560));
  CheckOutHandleDebug();
  return v19;
}

uint64_t TPConnectedCallback(uint64_t a1, int a2, const void *a3, int *a4, int a5, uint64_t a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  _QWORD *v17;
  _QWORD *v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  NSObject *v22;
  NSObject *v23;
  int v24;
  uint64_t v25;
  _QWORD block[8];
  int v27;
  int v28;
  int v29;
  int v30;
  uint8_t buf[4];
  uint64_t v32;
  __int16 v33;
  const char *v34;
  __int16 v35;
  int v36;
  __int16 v37;
  int v38;
  __int16 v39;
  int v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v14 = CheckInHandleDebug();
  if (!v14)
    return 2148466690;
  v15 = v14 + 34368;
  if (a4)
    v24 = *a4;
  else
    v24 = 0;
  v25 = a6;
  if (a3)
  {
    v17 = malloc_type_calloc(1uLL, 0x140uLL, 0x1020040A6FBA1A4uLL);
    v18 = v17;
    v19 = a7;
    if (v17)
    {
      memcpy(v17, a3, 0x140uLL);
      v18[38] = 0;
    }
  }
  else
  {
    v19 = a7;
    v18 = 0;
  }
  v20 = *(_QWORD *)(v15 + 8);
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v21 = VRTraceErrorLogLevelToCSTR();
    v22 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136316162;
      v32 = v21;
      v33 = 2080;
      v34 = "TPConnectedCallback";
      v35 = 1024;
      v36 = 4500;
      v37 = 1024;
      v38 = (int)a3;
      v39 = 1024;
      v40 = a5;
      _os_log_impl(&dword_1D8A54000, v22, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TPConnectedCallback: pCCResult == %08X, fUseRelay = %d ...", buf, 0x28u);
    }
  }
  v23 = *(NSObject **)v15;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __TPConnectedCallback_block_invoke;
  block[3] = &__block_descriptor_tmp_37;
  block[4] = a1;
  block[5] = v18;
  v27 = v24;
  v28 = a5;
  block[6] = v20;
  block[7] = v25;
  v29 = a2;
  v30 = v19;
  dispatch_async(v23, block);
  CheckOutHandleDebug();
  return 0;
}

uint64_t TPCancelRecvUDP(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2148466690;
  v4 = v3 + ((uint64_t)a2 << 7);
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 1560));
  *(_DWORD *)(v4 + 1544) = 1;
  pthread_cond_signal((pthread_cond_t *)(v4 + 1624));
  pthread_mutex_unlock((pthread_mutex_t *)(v4 + 1560));
  CheckOutHandleDebug();
  return 0;
}

uint64_t TPProcessICENomination(uint64_t a1, int a2, uint64_t a3, _BYTE *a4)
{
  __int128 v7;
  uint64_t v8;
  NSObject *v9;
  int v11;
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  __int16 v19;
  uint64_t v20;
  __int16 v21;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  _OWORD v25[4];
  _BYTE v26[22];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (!CheckInHandleDebug())
    return 2148466690;
  *(_QWORD *)&v26[14] = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v25[3] = v7;
  *(_OWORD *)v26 = v7;
  v25[2] = v7;
  v23 = v7;
  v24 = v7;
  v25[0] = v7;
  *(_QWORD *)((char *)v25 + 14) = 0xAAAAAAAAAAAAAAAALL;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v8 = VRTraceErrorLogLevelToCSTR();
    v9 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v11 = 136316418;
      v12 = v8;
      v13 = 2080;
      v14 = "TPProcessICENomination";
      v15 = 1024;
      v16 = 4593;
      v17 = 1024;
      v18 = a2;
      v19 = 2080;
      v20 = IPPORTToStringWithSize();
      v21 = 2080;
      v22 = IPPORTToStringWithSize();
      _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TPProcessICENomination Callback: callID[%08X] local[%s] dst[%s].", (uint8_t *)&v11, 0x36u);
    }
  }
  VTP_SetRTPSrc(a2, a3, a4);
  CheckOutHandleDebug();
  return 0;
}

uint64_t TPNewCandidatesCallback(uint64_t a1, int a2, const void *a3, int a4, __int16 a5)
{
  uint64_t v10;
  NSObject **v11;
  uint64_t v12;
  void *v13;
  void *v14;
  NSObject *v16;
  _QWORD v17[7];
  int v18;
  int v19;
  __int16 v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v10 = CheckInHandleDebug();
  if (!v10)
    return 2148466690;
  v11 = (NSObject **)(v10 + 34368);
  v12 = *(_QWORD *)(v10 + 34376);
  if (a3)
  {
    v13 = malloc_type_malloc(a4, 0x393E6477uLL);
    v14 = v13;
    if (v13)
      memcpy(v13, a3, a4);
  }
  else
  {
    v14 = 0;
  }
  v16 = *v11;
  v17[0] = MEMORY[0x1E0C809B0];
  v17[1] = 0x40000000;
  v17[2] = __TPNewCandidatesCallback_block_invoke;
  v17[3] = &__block_descriptor_tmp_38;
  v17[4] = a1;
  v17[5] = v12;
  v18 = a4;
  v19 = a2;
  v17[6] = v14;
  v20 = a5;
  dispatch_async(v16, v17);
  CheckOutHandleDebug();
  return 0;
}

uint64_t TPShouldNominateICECandidatePair(uint64_t a1, int a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v15;
  NSObject *v16;
  _QWORD v18[10];
  int v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v15 = CheckInHandleDebug();
  if (!v15)
    return 2148466690;
  v16 = *(NSObject **)(v15 + 34368);
  v18[0] = MEMORY[0x1E0C809B0];
  v18[1] = 0x40000000;
  v18[2] = __TPShouldNominateICECandidatePair_block_invoke;
  v18[3] = &__block_descriptor_tmp_39_0;
  v18[4] = v15;
  v18[5] = a3;
  v19 = a2;
  v20 = a4;
  v18[6] = a5;
  v18[7] = a6;
  v18[8] = a7;
  v18[9] = a8;
  dispatch_sync(v16, v18);
  CheckOutHandleDebug();
  return 0;
}

uint64_t TPRemoveIPPort(uint64_t a1, int a2, __int128 *a3, int a4)
{
  __int128 v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  _QWORD v12[6];
  int v13;
  int v14;
  _QWORD v15[3];
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v15[2] = 0x4000000000;
  v7 = a3[1];
  v16 = *a3;
  v17 = v7;
  v15[0] = 0;
  v15[1] = v15;
  v18 = *((_QWORD *)a3 + 4);
  v8 = CheckInHandleDebug();
  if (v8)
  {
    v9 = *(NSObject **)(v8 + 34368);
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 0x40000000;
    v12[2] = __TPRemoveIPPort_block_invoke;
    v12[3] = &unk_1E9E55990;
    v12[4] = v15;
    v12[5] = a1;
    v13 = a2;
    v14 = a4;
    dispatch_async(v9, v12);
    CheckOutHandleDebug();
    v10 = 0;
  }
  else
  {
    v10 = 2148466690;
  }
  _Block_object_dispose(v15, 8);
  return v10;
}

uint64_t TPCloseHandle()
{
  uint64_t v0;
  NSObject *v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  pthread_rwlock_t *v6;
  int v7;
  uint64_t i;
  uint64_t v9;
  uint64_t j;
  _opaque_pthread_t *v11;
  uint64_t k;
  const void *v13;
  const void *v14;
  void (*v15)(void);
  NSObject *v16;
  _QWORD *v17;
  _QWORD *v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  uint64_t m;
  uint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  NSObject *v30;
  _BYTE v32[12];
  __int16 v33;
  const char *v34;
  __int16 v35;
  int v36;
  __int16 v37;
  int v38;
  __int16 v39;
  uint64_t v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v0 = VRTraceErrorLogLevelToCSTR();
    v1 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v32 = 136316162;
      *(_QWORD *)&v32[4] = v0;
      v33 = 2080;
      v34 = "TPCloseHandle";
      v35 = 1024;
      v36 = 2077;
      v37 = 1024;
      v38 = g_iHandleRefCount;
      v39 = 2048;
      v40 = g_hActualTPHandle;
      _os_log_impl(&dword_1D8A54000, v1, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d ((((( In TPCloseHandle with g_iHandleRefCount = %d and g_hActualTPHandle = %p)))))", v32, 0x2Cu);
    }
  }
  pthread_mutex_lock(&g_xTPHandle);
  v2 = g_iHandleRefCount;
  if (g_iHandleRefCount <= 0)
  {
    v28 = 2148466692;
    if ((int)VRTraceGetErrorLogLevelForModule() >= 5)
    {
      v29 = VRTraceErrorLogLevelToCSTR();
      v30 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v32 = 136315650;
        *(_QWORD *)&v32[4] = v29;
        v33 = 2080;
        v34 = "TPCloseHandle";
        v35 = 1024;
        v36 = 2082;
        _os_log_impl(&dword_1D8A54000, v30, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Unmatched call to TPCreateHandle, TPCloseHandle called with non-positive ref count", v32, 0x1Cu);
      }
    }
  }
  else
  {
    --g_iHandleRefCount;
    if (v2 == 1)
    {
      g_iHandleRefCount = 0;
      v3 = CheckInHandleDebug();
      if (!v3)
      {
        v28 = 2148466690;
        goto LABEL_52;
      }
      v4 = v3;
      v5 = (_QWORD *)(v3 + 34328);
      v6 = (pthread_rwlock_t *)(v3 + 1064);
      pthread_rwlock_wrlock((pthread_rwlock_t *)(v3 + 1064));
      *(_DWORD *)(v4 + 8) = 1;
      v7 = *(_DWORD *)(v4 + 12);
      if (v7 != -1)
        VTP_Close(v7);
      *(_DWORD *)(v4 + 12) = -1;
      for (i = *(_QWORD *)(v4 + 1056); i; i = *(_QWORD *)(i + 2144))
      {
        ICERemoveOneInterface();
        if (!*(_DWORD *)(i + 2068))
          VTP_Close(*(_DWORD *)i);
        v9 = *(_QWORD *)(i + 2128);
        if (v9 != 0xFFFFFFFFLL)
        {
          if (*(_QWORD *)(i + 2136) != 0xFFFFFFFFLL)
          {
            ARPLSessionRelease();
            *(_QWORD *)(i + 2136) = 0xFFFFFFFFLL;
            v9 = *(_QWORD *)(i + 2128);
          }
          DTLS_Cleanup(v9);
          *(_QWORD *)(i + 2128) = 0xFFFFFFFFLL;
        }
      }
      pthread_rwlock_unlock(v6);
      pthread_rwlock_wrlock((pthread_rwlock_t *)(v4 + 1272));
      for (j = *(_QWORD *)(v4 + 1264); j; j = *(_QWORD *)(j + 2144))
        ICERemoveOneInterface();
      pthread_rwlock_unlock((pthread_rwlock_t *)(v4 + 1272));
      v11 = *(_opaque_pthread_t **)(v4 + 24);
      if (v11)
      {
        *(_QWORD *)v32 = 0xAAAAAAAAAAAAAAAALL;
        pthread_join(v11, (void **)v32);
      }
      for (k = 0; k != 0x8000; k += 128)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v4 + k + 1560));
        *(_DWORD *)(v4 + k + 1544) = 1;
        pthread_cond_broadcast((pthread_cond_t *)(v4 + k + 1624));
        pthread_mutex_unlock((pthread_mutex_t *)(v4 + k + 1560));
      }
      CheckOutHandleDebug();
      TPCleanupBaseband(v4);
      v13 = (const void *)v5[25];
      if (v13)
        CFRelease(v13);
      ICECloseHandle();
      *(_OWORD *)(v4 + 34336) = 0u;
      *(_OWORD *)(v4 + 34352) = 0u;
      v14 = (const void *)v5[6];
      if (v14)
        CFRelease(v14);
      v15 = (void (*)(void))v5[31];
      if (v15 && v5[29])
        v15();
      v16 = v5[5];
      if (v16)
        dispatch_release(v16);
      pthread_rwlock_wrlock(v6);
      v17 = *(_QWORD **)(v4 + 1056);
      if (v17)
      {
        do
        {
          v18 = (_QWORD *)v17[268];
          v19 = v17[266];
          if (v19 != 0xFFFFFFFFLL)
          {
            if (v17[267] != 0xFFFFFFFFLL)
            {
              ARPLSessionRelease();
              v17[267] = 0xFFFFFFFFLL;
              v19 = v17[266];
            }
            DTLS_Cleanup(v19);
          }
          free(v17);
          v17 = v18;
        }
        while (v18);
      }
      pthread_rwlock_unlock(v6);
      pthread_rwlock_wrlock((pthread_rwlock_t *)(v4 + 1272));
      v20 = *(_QWORD **)(v4 + 1264);
      if (v20)
      {
        do
        {
          v21 = (_QWORD *)v20[268];
          free(v20);
          v20 = v21;
        }
        while (v21);
      }
      pthread_rwlock_unlock((pthread_rwlock_t *)(v4 + 1272));
      pthread_mutex_lock((pthread_mutex_t *)(v4 + 1480));
      v22 = *(_QWORD **)(v4 + 1472);
      if (v22)
      {
        do
        {
          v23 = (_QWORD *)v22[17];
          free(v22);
          v22 = v23;
        }
        while (v23);
      }
      pthread_mutex_unlock((pthread_mutex_t *)(v4 + 1480));
      for (m = 0; m != 256; ++m)
      {
        v25 = v4 + (m << 7);
        pthread_mutex_lock((pthread_mutex_t *)(v25 + 1560));
        v26 = *(_QWORD **)(v25 + 1552);
        if (v26)
        {
          do
          {
            v27 = (_QWORD *)v26[268];
            free(v26);
            v26 = v27;
          }
          while (v27);
        }
        pthread_mutex_unlock((pthread_mutex_t *)(v25 + 1560));
        pthread_mutex_destroy((pthread_mutex_t *)(v25 + 1560));
        pthread_cond_destroy((pthread_cond_t *)(v25 + 1624));
      }
      pthread_rwlock_destroy(v6);
      pthread_rwlock_destroy((pthread_rwlock_t *)(v4 + 1272));
      pthread_mutex_destroy((pthread_mutex_t *)(v4 + 992));
      pthread_mutex_destroy((pthread_mutex_t *)(v4 + 1480));
      pthread_mutex_destroy((pthread_mutex_t *)(v4 + 34584));
      pthread_mutex_destroy((pthread_mutex_t *)(v4 + 34392));
      free((void *)v4);
    }
    v28 = 0;
  }
LABEL_52:
  pthread_mutex_unlock(&g_xTPHandle);
  return v28;
}

uint64_t TPCleanupBaseband(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  uint64_t result;
  pthread_mutex_t *v6;
  uint64_t v7;
  NSObject *v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v2 = a1 + 34456;
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v3 = VRTraceErrorLogLevelToCSTR();
    v4 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315650;
      v10 = v3;
      v11 = 2080;
      v12 = "TPCleanupBaseband";
      v13 = 1024;
      v14 = 857;
      _os_log_impl(&dword_1D8A54000, v4, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d LET US CLEANUP BASEBAND.", (uint8_t *)&v9, 0x1Cu);
    }
  }
  result = TPCleanupBasebandNotifications(a1);
  if (*(_DWORD *)(v2 + 56))
  {
    v6 = (pthread_mutex_t *)(a1 + 34392);
    pthread_mutex_lock(v6);
    if (*(_QWORD *)v2)
    {
      if (*(_DWORD *)(v2 + 68))
      {
        if (_CTServerConnectionUnregisterForNotification())
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
          {
            VRTraceErrorLogLevelToCSTR();
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
              TPCleanupBaseband_cold_1();
          }
        }
        else
        {
          *(_DWORD *)(v2 + 68) = 0;
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v7 = VRTraceErrorLogLevelToCSTR();
            v8 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              v9 = 136315650;
              v10 = v7;
              v11 = 2080;
              v12 = "TPCleanupBaseband";
              v13 = 1024;
              v14 = 874;
              _os_log_impl(&dword_1D8A54000, v8, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Deregistered kCTRegistrationDataStatusChangedNotification.", (uint8_t *)&v9, 0x1Cu);
            }
          }
        }
      }
      CFRelease(*(CFTypeRef *)v2);
      *(_QWORD *)v2 = 0;
    }
    return pthread_mutex_unlock(v6);
  }
  return result;
}

uint64_t TPSetPacketMultiplexMode(uint64_t a1, int a2)
{
  uint64_t v3;

  v3 = CheckInHandleDebug();
  if (!v3)
    return 2148466690;
  *(_DWORD *)(v3 + 4) = a2;
  CheckOutHandleDebug();
  return 0;
}

uint64_t TPSetupOpenFaceTimeSecurity(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;

  v7 = CheckInHandleDebug();
  if (!v7)
    return 2148466690;
  v8 = dtls(a2, a3, v7, a4);
  CheckOutHandleDebug();
  return v8;
}

uint64_t dtls(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  pthread_rwlock_t *v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  int v15;
  int *v16;
  int v17;
  uint64_t v20;
  NSObject *v21;
  uint64_t v23;
  NSObject *v24;
  int v25;
  uint64_t v26;
  NSObject *v27;
  int v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  NSObject *v32;
  int ErrorLogLevelForModule;
  uint64_t v34;
  NSObject *v35;
  NSObject *v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  NSObject *v40;
  const __CFString *v41;
  const char *CStringPtr;
  CFIndex Length;
  CFIndex MaximumSizeForEncoding;
  uint64_t v45;
  uint64_t v46;
  char *v47;
  uint64_t v48;
  CFErrorRef v49;
  uint8_t buf[4];
  uint64_t v51;
  __int16 v52;
  const char *v53;
  __int16 v54;
  int v55;
  __int16 v56;
  int v57;
  __int16 v58;
  void *v59;
  uint64_t v60;

  v60 = *MEMORY[0x1E0C80C00];
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v8 = VRTraceErrorLogLevelToCSTR();
    v9 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      v51 = v8;
      v52 = 2080;
      v53 = "dtls";
      v54 = 1024;
      v55 = 512;
      v56 = 1024;
      v57 = a1;
      _os_log_impl(&dword_1D8A54000, v9, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d DTLS: entering (dwCallID == %08X)...", buf, 0x22u);
    }
  }
  v10 = 2149777460;
  if (!a2)
    goto LABEL_29;
  v11 = (pthread_rwlock_t *)(a3 + 1064);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(a3 + 1064));
  v12 = *(_QWORD *)(a3 + 1056);
  if (!v12)
  {
LABEL_28:
    pthread_rwlock_unlock(v11);
    goto LABEL_29;
  }
  v13 = a3 + 34528;
  v14 = (_QWORD *)MEMORY[0x1E0C83920];
  while (1)
  {
    IPPORTToStringWithSize();
    v15 = *(_DWORD *)(v12 + 2072) & 1;
    if (v15 == (*(_DWORD *)(a2 + 28) & 1))
      break;
LABEL_18:
    if (v15)
      goto LABEL_21;
    if (!*(_DWORD *)(v12 + 2092))
      goto LABEL_26;
LABEL_27:
    v12 = *(_QWORD *)(v12 + 2144);
    if (!v12)
      goto LABEL_28;
  }
  v16 = (int *)(v12 + 2092);
  if (!v15)
  {
    v17 = *v16;
    if (v17 != *(_DWORD *)(a2 + 48))
    {
      if (!v17)
        goto LABEL_26;
      goto LABEL_27;
    }
    goto LABEL_17;
  }
  if (*(_QWORD *)v16 == *(_QWORD *)(a2 + 48) && *(_QWORD *)(v12 + 2100) == *(_QWORD *)(a2 + 56))
  {
LABEL_17:
    if (*(unsigned __int16 *)(v12 + 2108) == *(unsigned __int16 *)(a2 + 64))
      goto LABEL_33;
    goto LABEL_18;
  }
LABEL_21:
  if (*(_QWORD *)(v12 + 2092) != *v14 || *(_QWORD *)(v12 + 2100) != v14[1])
    goto LABEL_27;
LABEL_26:
  if (*(unsigned __int16 *)(v12 + 2108) != *(unsigned __int16 *)(a2 + 64))
    goto LABEL_27;
LABEL_33:
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v23 = VRTraceErrorLogLevelToCSTR();
    v24 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v25 = *(_DWORD *)(v12 + 2064);
      *(_DWORD *)buf = 136316162;
      v51 = v23;
      v52 = 2080;
      v53 = "dtls";
      v54 = 1024;
      v55 = 528;
      v56 = 1024;
      v57 = v25;
      v58 = 2080;
      v59 = &dtls_ip;
      _os_log_impl(&dword_1D8A54000, v24, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d DTLS:: (dwCallID == %08X) found clist local IP == %s", buf, 0x2Cu);
    }
  }
  IPPORTToStringWithSize();
  if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
  {
    v26 = VRTraceErrorLogLevelToCSTR();
    v27 = *MEMORY[0x1E0CF2758];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
    {
      v28 = *(_DWORD *)(v12 + 2120);
      *(_DWORD *)buf = 136316162;
      v51 = v26;
      v52 = 2080;
      v53 = "dtls";
      v54 = 1024;
      v55 = 530;
      v56 = 1024;
      v57 = v28;
      v58 = 2080;
      v59 = &dtls_ip;
      _os_log_impl(&dword_1D8A54000, v27, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d DTLS:: (dwRemoteCallID == %08X) dtls to remote == %s", buf, 0x2Cu);
    }
  }
  pthread_rwlock_unlock(v11);
  v29 = (_QWORD *)(v12 + 2128);
  v30 = *(_QWORD *)(v12 + 2128);
  if (*(_QWORD *)v13)
  {
    if (v30 != 0xFFFFFFFFLL)
    {
      VTP_SetDTLS(*(_DWORD *)v12, 0xFFFFFFFFLL);
      if (*(_QWORD *)(v12 + 2136) != 0xFFFFFFFFLL)
      {
        ARPLSessionRelease();
        *(_QWORD *)(v12 + 2136) = 0xFFFFFFFFLL;
      }
      DTLS_Cleanup(*v29);
      *v29 = 0xFFFFFFFFLL;
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v31 = VRTraceErrorLogLevelToCSTR();
      v32 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        v51 = v31;
        v52 = 2080;
        v53 = "dtls";
        v54 = 1024;
        v55 = 553;
        _os_log_impl(&dword_1D8A54000, v32, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d DTLS: initialize and perform handshake...", buf, 0x1Cu);
      }
    }
    v10 = DTLS_Create((uint64_t *)(v12 + 2128), *(_DWORD *)v12, *(_DWORD *)(v13 + 8) == 1, a1, *(_DWORD *)(v12 + 2120), *(const void **)v13, (const void *)a2);
    ErrorLogLevelForModule = VRTraceGetErrorLogLevelForModule();
    if ((v10 & 0x80000000) != 0)
    {
      if (ErrorLogLevelForModule >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          dtls_cold_1();
      }
      DTLS_Cleanup(*v29);
      *v29 = 0xFFFFFFFFLL;
    }
    else
    {
      if (ErrorLogLevelForModule >= 8)
      {
        v34 = VRTraceErrorLogLevelToCSTR();
        v35 = *MEMORY[0x1E0CF2758];
        v36 = *MEMORY[0x1E0CF2758];
        if (*MEMORY[0x1E0CF2748])
        {
          if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315906;
            v51 = v34;
            v52 = 2080;
            v53 = "dtls";
            v54 = 1024;
            v55 = 564;
            v56 = 1024;
            v57 = a1;
            _os_log_impl(&dword_1D8A54000, v35, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d dtls: ARPLSessionCreate(p2pID == %08X) ...", buf, 0x22u);
          }
        }
        else if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
        {
          dtls_cold_4();
        }
      }
      v37 = (_QWORD *)(v12 + 2136);
      v38 = ARPLSessionCreate(a1, (uint64_t *)(v12 + 2136));
      if ((v38 & 0x80000000) == 0)
      {
        VTP_SetDTLS(*(_DWORD *)v12, *(_QWORD *)(v12 + 2128));
        v49 = 0;
        v10 = DTLS_Handshake(*(_QWORD *)(v12 + 2128), &v49, a4);
        if ((v10 & 0x80000000) != 0)
        {
          if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
          {
            v39 = VRTraceErrorLogLevelToCSTR();
            v40 = *MEMORY[0x1E0CF2758];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315906;
              v51 = v39;
              v52 = 2080;
              v53 = "dtls";
              v54 = 1024;
              v55 = 579;
              v56 = 1024;
              v57 = v10;
              _os_log_impl(&dword_1D8A54000, v40, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d DTLS: handshake result == %08X ...", buf, 0x22u);
            }
          }
          if (v49)
          {
            v41 = CFErrorCopyDescription(v49);
            CStringPtr = CFStringGetCStringPtr(v41, 0x8000100u);
            Length = CFStringGetLength(v41);
            MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
            v45 = MEMORY[0x1E0C80A78](MaximumSizeForEncoding);
            v47 = (char *)&v48 - v46;
            if (v45)
              memset((char *)&v48 - v46, 170, MaximumSizeForEncoding);
            if ((CStringPtr || CFStringGetCString(v41, v47, MaximumSizeForEncoding, 0x8000100u))
              && (int)VRTraceGetErrorLogLevelForModule() >= 3)
            {
              VRTraceErrorLogLevelToCSTR();
              if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
                dtls_cold_3();
            }
            CFRelease(v41);
            if (v49)
            {
              CFRelease(v49);
              v49 = 0;
            }
          }
          VTP_SetDTLS(*(_DWORD *)v12, 0xFFFFFFFFLL);
          if (*(_QWORD *)(v12 + 2136) != 0xFFFFFFFFLL)
          {
            ARPLSessionRelease();
            *v37 = 0xFFFFFFFFLL;
          }
          goto LABEL_78;
        }
        goto LABEL_29;
      }
      v10 = v38;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          dtls_cold_2();
      }
      *v37 = 0xFFFFFFFFLL;
    }
  }
  else
  {
    if (v30 != 0xFFFFFFFFLL)
    {
      VTP_SetDTLS(*(_DWORD *)v12, 0xFFFFFFFFLL);
      if (*(_QWORD *)(v12 + 2136) != 0xFFFFFFFFLL)
      {
        ARPLSessionRelease();
        *(_QWORD *)(v12 + 2136) = 0xFFFFFFFFLL;
      }
LABEL_78:
      DTLS_Cleanup(*v29);
      *v29 = 0xFFFFFFFFLL;
    }
LABEL_29:
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v20 = VRTraceErrorLogLevelToCSTR();
      v21 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        v51 = v20;
        v52 = 2080;
        v53 = "dtls";
        v54 = 1024;
        v55 = 620;
        v56 = 1024;
        v57 = v10;
        _os_log_impl(&dword_1D8A54000, v21, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d DTLS: exiting (hResult == %08X)...", buf, 0x22u);
      }
    }
  }
  return v10;
}

uint64_t TPGetLoopbackIP(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  __int128 v6;
  unsigned int LocalIFIndexForDstIPPort;
  pthread_rwlock_t *v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  NSObject *v15;
  int v17;
  uint64_t v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  void *v24;
  __int128 v25;
  __int128 v26;
  unint64_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v3 = 2148466689;
  v4 = CheckInHandleDebug();
  if (v4)
  {
    v5 = v4;
    v27 = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v25 = v6;
    v26 = v6;
    MakeIPPORT();
    if (a2)
    {
      LocalIFIndexForDstIPPort = GetLocalIFIndexForDstIPPort();
      if_indextoname(LocalIFIndexForDstIPPort, (char *)(a2 + 4));
      v8 = (pthread_rwlock_t *)(v5 + 1064);
      pthread_rwlock_rdlock((pthread_rwlock_t *)(v5 + 1064));
      v9 = *(_QWORD *)(v5 + 1056);
      if (v9)
      {
        while (((*(_DWORD *)(v9 + 2072) ^ v25) & 1) != 0
             || strcmp((const char *)(v9 + 2076), (const char *)(a2 + 4)))
        {
          v9 = *(_QWORD *)(v9 + 2144);
          if (!v9)
            goto LABEL_7;
        }
        v12 = *(_OWORD *)(v9 + 2072);
        v13 = *(_OWORD *)(v9 + 2088);
        *(_QWORD *)(a2 + 32) = *(_QWORD *)(v9 + 2104);
        *(_OWORD *)a2 = v12;
        *(_OWORD *)(a2 + 16) = v13;
        pthread_rwlock_unlock(v8);
        IPPORTToStringWithSize();
        if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
        {
          v14 = VRTraceErrorLogLevelToCSTR();
          v15 = *MEMORY[0x1E0CF2758];
          v3 = 0;
          if (!os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
LABEL_16:
            CheckOutHandleDebug();
            return v3;
          }
          v17 = 136315906;
          v18 = v14;
          v19 = 2080;
          v20 = "TPGetLoopbackIP";
          v21 = 1024;
          v22 = 2487;
          v23 = 2080;
          v24 = &TPGetLoopbackIP_ip;
          _os_log_impl(&dword_1D8A54000, v15, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TPGetLoopbackIP:: found loopbackIP = %s", (uint8_t *)&v17, 0x26u);
        }
        v3 = 0;
        goto LABEL_16;
      }
LABEL_7:
      pthread_rwlock_unlock(v8);
      v3 = 2148466710;
    }
    IPPORTToStringWithSize();
    if ((int)VRTraceGetErrorLogLevelForModule() >= 7)
    {
      v10 = VRTraceErrorLogLevelToCSTR();
      v11 = *MEMORY[0x1E0CF2758];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
      {
        v17 = 136315906;
        v18 = v10;
        v19 = 2080;
        v20 = "TPGetLoopbackIP";
        v21 = 1024;
        v22 = 2491;
        v23 = 2080;
        v24 = &TPGetLoopbackIP_ip_5;
        _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d TPGetLoopbackIP:: error loopbackIP = %s", (uint8_t *)&v17, 0x26u);
      }
    }
    goto LABEL_16;
  }
  return 2148466690;
}

uint64_t TPListenVirtualInterface(void *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  pthread_rwlock_t *v5;
  _BOOL4 v6;
  int *v7;
  int *v8;
  int v9;
  uint64_t v10;
  NSObject *v11;
  int v12;
  int **v13;
  int **v14;
  int *v15;
  int v17;
  uint64_t v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v2 = 2148466691;
  v3 = CheckInHandleDebug();
  if (v3)
  {
    v4 = v3;
    if (*(_DWORD *)v3)
    {
      v2 = 2148466704;
LABEL_24:
      CheckOutHandleDebug();
      return v2;
    }
    v5 = (pthread_rwlock_t *)(v3 + 1064);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v3 + 1064));
    v6 = TransportMapPacketMultiplexModeToVTPMode(*(unsigned int *)(v4 + 4));
    v7 = (int *)malloc_type_calloc(1uLL, 0x868uLL, 0x10200406FE3F67FuLL);
    if (v7)
    {
      v8 = v7;
      *((_BYTE *)v7 + 4) = 1;
      *((_QWORD *)v7 + 258) = 0;
      *((_QWORD *)v7 + 266) = 0xFFFFFFFFLL;
      *((_QWORD *)v7 + 267) = 0xFFFFFFFFLL;
      v9 = VTP_SocketForIDS();
      *v8 = v9;
      if (v9 != -1)
      {
        VTP_SetSocketMode(v9, v6);
        VTP_SetPktType(*v8, 48142);
        if ((int)VRTraceGetErrorLogLevelForModule() >= 6)
        {
          v10 = VRTraceErrorLogLevelToCSTR();
          v11 = *MEMORY[0x1E0CF2758];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_DEFAULT))
          {
            v12 = *v8;
            v17 = 136315906;
            v18 = v10;
            v19 = 2080;
            v20 = "CreateSocketForIDS";
            v21 = 1024;
            v22 = 2289;
            v23 = 1024;
            v24 = v12;
            _os_log_impl(&dword_1D8A54000, v11, OS_LOG_TYPE_DEFAULT, "SIP [%s] %s:%d Start listening on IDS interface vfd %d", (uint8_t *)&v17, 0x22u);
          }
        }
        v8[2] = 2048;
        v13 = (int **)(v4 + 1056);
        do
        {
          v14 = v13;
          v15 = *v13;
          v13 = (int **)(*v13 + 536);
        }
        while (v15);
        *v14 = v8;
        pthread_rwlock_unlock((pthread_rwlock_t *)(v4 + 1064));
        v2 = TPEnsureRecvProcStarted(a1, v4);
        goto LABEL_24;
      }
      v2 = *__error() | 0xC00F0000;
      if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
      {
        VRTraceErrorLogLevelToCSTR();
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
          TPListenVirtualInterface_cold_3();
      }
      free(v8);
    }
    else if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        TPListenVirtualInterface_cold_2();
    }
    if ((int)VRTraceGetErrorLogLevelForModule() >= 3)
    {
      VRTraceErrorLogLevelToCSTR();
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CF2758], OS_LOG_TYPE_ERROR))
        TPListenVirtualInterface_cold_1();
    }
    pthread_rwlock_unlock(v5);
    goto LABEL_24;
  }
  return 2148466690;
}

