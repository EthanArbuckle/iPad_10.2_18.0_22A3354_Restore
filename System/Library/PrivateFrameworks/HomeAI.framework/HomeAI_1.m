void sub_219E465BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,char a29)
{
  cv::Exception::~Exception((cv::Exception *)&a29);
  if (a16 < 0)
    operator delete(__p);
  if (a22 < 0)
    operator delete(a17);
  if (a28 < 0)
    operator delete(a23);
  _Unwind_Resume(a1);
}

uint64_t cv::ColumnSum<int,float>::reset(uint64_t result)
{
  *(_DWORD *)(result + 24) = 0;
  return result;
}

void cv::ColumnSum<double,float>::~ColumnSum(cv::BaseRowFilter *this)
{
  void *v2;

  *(_QWORD *)this = &off_24DBEFBB8;
  v2 = (void *)*((_QWORD *)this + 4);
  if (v2)
  {
    *((_QWORD *)this + 5) = v2;
    operator delete(v2);
  }
  cv::BaseRowFilter::~BaseRowFilter(this);
}

{
  void *v2;

  *(_QWORD *)this = &off_24DBEFBB8;
  v2 = (void *)*((_QWORD *)this + 4);
  if (v2)
  {
    *((_QWORD *)this + 5) = v2;
    operator delete(v2);
  }
  cv::BaseRowFilter::~BaseRowFilter(this);
  JUMPOUT(0x2207351BCLL);
}

void cv::ColumnSum<double,float>::operator()(uint64_t a1, float64x2_t **a2, float32x2_t *a3, int a4, int a5, int a6)
{
  float64x2_t **v10;
  uint64_t v12;
  float64x2_t *v13;
  float64x2_t *v14;
  double v15;
  int v16;
  int v17;
  const cv::Exception *v18;
  int v19;
  int v20;
  float64x2_t *v21;
  uint64_t v22;
  uint64_t v23;
  float64x2_t *v24;
  float64x2_t *v25;
  float64x2_t v26;
  double *v27;
  uint64_t v28;
  double *v29;
  double v30;
  uint64_t v31;
  uint64_t v32;
  float64x2_t *v33;
  float64x2_t *v34;
  uint64_t v35;
  uint64_t v36;
  float64x2_t *v37;
  float64x2_t *v38;
  float32x2_t *v39;
  float64x2_t *v40;
  float64x2_t v41;
  float64x2_t v42;
  float64x2_t v43;
  float64_t v44;
  float32_t v45;
  float64x2_t *v46;
  float64x2_t *v47;
  float32x2_t *v48;
  float64x2_t *v49;
  float64x2_t v50;
  float64x2_t v51;
  float64x2_t v52;
  float64_t v53;
  float32_t v54;
  double v55;
  void *__p[2];
  void *v57[2];
  void *v58[2];
  _BYTE v59[120];

  v10 = a2;
  v14 = *(float64x2_t **)(a1 + 32);
  v12 = a1 + 32;
  v13 = v14;
  v15 = *(double *)(v12 - 16);
  v55 = v15;
  if (((*(_QWORD *)(v12 + 8) - (_QWORD)v14) >> 3) == a6)
  {
    v16 = *(_DWORD *)(a1 + 24);
    if (v16)
    {
      v17 = *(_DWORD *)(a1 + 8);
      if (v16 != v17 - 1)
      {
        std::string::basic_string[abi:ne180100]<0>(v58, "sumCount == ksize-1");
        std::string::basic_string[abi:ne180100]<0>(v57, "operator()");
        std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/imgproc/smooth.cpp");
        cv::Exception::Exception(v59, 4294967081, v58, v57, __p, 145);
        cv::error((cv *)v59, v18);
      }
      v10 = &a2[v17 - 1];
      goto LABEL_21;
    }
  }
  else
  {
    std::vector<cv::Point_<int>>::resize(v12, a6);
    v15 = v55;
    *(_DWORD *)(a1 + 24) = 0;
    v13 = *(float64x2_t **)(a1 + 32);
  }
  if (a6 >= 1)
  {
    bzero(v13, 8 * a6);
    v15 = v55;
  }
  v17 = *(_DWORD *)(a1 + 8);
  v19 = v17 - 1;
  if (v17 > 1)
  {
    v20 = 0;
    do
    {
      v21 = *v10;
      if (a6 >= 2)
      {
        v23 = 0;
        v24 = v13;
        v25 = *v10;
        do
        {
          v26 = *v25++;
          *v24 = vaddq_f64(*v24, v26);
          ++v24;
          v23 += 2;
        }
        while (v23 <= a6 - 2);
        v22 = v23;
      }
      else
      {
        v22 = 0;
      }
      if ((int)v22 < a6)
      {
        v27 = &v13->f64[v22];
        v28 = a6 - v22;
        v29 = &v21->f64[v22];
        do
        {
          v30 = *v29++;
          *v27 = v30 + *v27;
          ++v27;
          --v28;
        }
        while (v28);
      }
      ++v20;
      ++v10;
    }
    while (v20 != v19);
    *(_DWORD *)(a1 + 24) = v19;
  }
LABEL_21:
  if (a5)
  {
    v31 = 1 - v17;
    v32 = a6 - 2;
    do
    {
      v33 = *v10;
      v34 = v10[v31];
      if (v15 == 1.0)
      {
        if (a6 >= 2)
        {
          v36 = 0;
          v46 = v13;
          v47 = *v10;
          v48 = a3;
          v49 = v10[v31];
          do
          {
            v50 = *v47++;
            v51 = vaddq_f64(*v46, v50);
            *v48++ = vcvt_f32_f64(v51);
            v52 = *v49++;
            *v46++ = vsubq_f64(v51, v52);
            v36 += 2;
          }
          while (v36 <= v32);
          v36 = v36;
        }
        else
        {
          v36 = 0;
        }
        if ((int)v36 < a6)
        {
          do
          {
            v53 = v13->f64[v36] + v33->f64[v36];
            v54 = v53;
            a3->f32[v36] = v54;
            v13->f64[v36] = v53 - v34->f64[v36];
            ++v36;
          }
          while (a6 != v36);
        }
      }
      else
      {
        if (a6 >= 2)
        {
          v35 = 0;
          v37 = v13;
          v38 = *v10;
          v39 = a3;
          v40 = v10[v31];
          do
          {
            v41 = *v38++;
            v42 = vaddq_f64(*v37, v41);
            *v39++ = vcvt_f32_f64(vmulq_n_f64(v42, v15));
            v43 = *v40++;
            *v37++ = vsubq_f64(v42, v43);
            v35 += 2;
          }
          while (v35 <= v32);
          v35 = v35;
        }
        else
        {
          v35 = 0;
        }
        if ((int)v35 < a6)
        {
          do
          {
            v44 = v13->f64[v35] + v33->f64[v35];
            v45 = v15 * v44;
            a3->f32[v35] = v45;
            v13->f64[v35] = v44 - v34->f64[v35];
            ++v35;
          }
          while (a6 != v35);
        }
      }
      a3 = (float32x2_t *)((char *)a3 + a4);
      ++v10;
      --a5;
    }
    while (a5);
  }
}

void sub_219E46A00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,char a29)
{
  cv::Exception::~Exception((cv::Exception *)&a29);
  if (a16 < 0)
    operator delete(__p);
  if (a22 < 0)
    operator delete(a17);
  if (a28 < 0)
    operator delete(a23);
  _Unwind_Resume(a1);
}

uint64_t cv::ColumnSum<double,float>::reset(uint64_t result)
{
  *(_DWORD *)(result + 24) = 0;
  return result;
}

void cv::ColumnSum<int,double>::~ColumnSum(cv::BaseRowFilter *this)
{
  void *v2;

  *(_QWORD *)this = &off_24DBEFC00;
  v2 = (void *)*((_QWORD *)this + 4);
  if (v2)
  {
    *((_QWORD *)this + 5) = v2;
    operator delete(v2);
  }
  cv::BaseRowFilter::~BaseRowFilter(this);
}

{
  void *v2;

  *(_QWORD *)this = &off_24DBEFC00;
  v2 = (void *)*((_QWORD *)this + 4);
  if (v2)
  {
    *((_QWORD *)this + 5) = v2;
    operator delete(v2);
  }
  cv::BaseRowFilter::~BaseRowFilter(this);
  JUMPOUT(0x2207351BCLL);
}

void cv::ColumnSum<int,double>::operator()(uint64_t a1, int32x2_t **a2, float64x2_t *a3, int a4, int a5, int a6)
{
  int32x2_t **v10;
  std::vector<int> *v12;
  int32x2_t *v13;
  int32x2_t *v14;
  double v15;
  int v16;
  int v17;
  const cv::Exception *v18;
  int v19;
  int32x2_t *v20;
  uint64_t v21;
  uint64_t v22;
  int32x2_t *v23;
  int32x2_t *v24;
  int32x2_t v25;
  _DWORD *v26;
  uint64_t v27;
  int *v28;
  int v29;
  int v30;
  uint64_t v31;
  int32x2_t *v32;
  int32x2_t *v33;
  uint64_t v34;
  uint64_t v35;
  int32x2_t *v36;
  int32x2_t *v37;
  float64x2_t *v38;
  int32x2_t *v39;
  int32x2_t v40;
  int32x2_t v41;
  int64x2_t v42;
  int32x2_t v43;
  int v44;
  int32x2_t *v45;
  int32x2_t *v46;
  float64x2_t *v47;
  int32x2_t *v48;
  int32x2_t v49;
  int32x2_t v50;
  int64x2_t v51;
  int32x2_t v52;
  int v53;
  std::vector<int>::pointer end;
  void *__p[2];
  void *v56[2];
  void *v57[2];
  _BYTE v58[120];

  v10 = a2;
  v14 = *(int32x2_t **)(a1 + 32);
  v12 = (std::vector<int> *)(a1 + 32);
  v13 = v14;
  v15 = *(double *)&v12[-1].__end_;
  if (((unint64_t)((char *)v12->__end_ - (char *)v14) >> 2) == a6)
  {
    v16 = *(_DWORD *)(a1 + 24);
    if (v16)
    {
      v17 = *(_DWORD *)(a1 + 8) - 1;
      if (v16 != v17)
      {
        std::string::basic_string[abi:ne180100]<0>(v57, "sumCount == ksize-1");
        std::string::basic_string[abi:ne180100]<0>(v56, "operator()");
        std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/imgproc/smooth.cpp");
        cv::Exception::Exception(v58, 4294967081, v57, v56, __p, 145);
        cv::error((cv *)v58, v18);
      }
      v10 = &a2[v17];
      goto LABEL_21;
    }
    end = v12[-1].__end_;
  }
  else
  {
    end = v12[-1].__end_;
    std::vector<int>::resize(v12, a6);
    *(_DWORD *)(a1 + 24) = 0;
    v13 = *(int32x2_t **)(a1 + 32);
  }
  if (a6 < 1)
  {
    v19 = 0;
  }
  else
  {
    bzero(v13, 4 * a6);
    v19 = *(_DWORD *)(a1 + 24);
  }
  v15 = *(double *)&end;
  if (v19 < *(_DWORD *)(a1 + 8) - 1)
  {
    do
    {
      v20 = *v10;
      if (a6 >= 2)
      {
        v22 = 0;
        v23 = v13;
        v24 = *v10;
        do
        {
          v25 = *v24++;
          *v23 = vadd_s32(v25, *v23);
          ++v23;
          v22 += 2;
        }
        while (v22 <= a6 - 2);
        v21 = v22;
      }
      else
      {
        v21 = 0;
      }
      if ((int)v21 < a6)
      {
        v26 = (_DWORD *)v13 + v21;
        v27 = a6 - v21;
        v28 = (int *)v20 + v21;
        do
        {
          v29 = *v28++;
          *v26++ += v29;
          --v27;
        }
        while (v27);
      }
      v30 = *(_DWORD *)(a1 + 24) + 1;
      *(_DWORD *)(a1 + 24) = v30;
      ++v10;
    }
    while (v30 < *(_DWORD *)(a1 + 8) - 1);
  }
LABEL_21:
  if (a5)
  {
    v31 = a6 - 2;
    do
    {
      v32 = *v10;
      v33 = v10[1 - *(int *)(a1 + 8)];
      if (v15 == 1.0)
      {
        if (a6 >= 2)
        {
          v35 = 0;
          v45 = v13;
          v46 = *v10;
          v47 = a3;
          v48 = v10[1 - *(int *)(a1 + 8)];
          do
          {
            v49 = *v46++;
            v50 = vadd_s32(v49, *v45);
            v51.i64[0] = v50.i32[0];
            v51.i64[1] = v50.i32[1];
            *v47++ = vcvtq_f64_s64(v51);
            v52 = *v48++;
            *v45++ = vsub_s32(v50, v52);
            v35 += 2;
          }
          while (v35 <= v31);
          v35 = v35;
        }
        else
        {
          v35 = 0;
        }
        if ((int)v35 < a6)
        {
          do
          {
            v53 = v32->i32[v35] + v13->i32[v35];
            a3->f64[v35] = (double)v53;
            v13->i32[v35] = v53 - v33->i32[v35];
            ++v35;
          }
          while (a6 != v35);
        }
      }
      else
      {
        if (a6 >= 2)
        {
          v34 = 0;
          v36 = v13;
          v37 = *v10;
          v38 = a3;
          v39 = v10[1 - *(int *)(a1 + 8)];
          do
          {
            v40 = *v37++;
            v41 = vadd_s32(v40, *v36);
            v42.i64[0] = v41.i32[0];
            v42.i64[1] = v41.i32[1];
            *v38++ = vmulq_n_f64(vcvtq_f64_s64(v42), v15);
            v43 = *v39++;
            *v36++ = vsub_s32(v41, v43);
            v34 += 2;
          }
          while (v34 <= v31);
          v34 = v34;
        }
        else
        {
          v34 = 0;
        }
        if ((int)v34 < a6)
        {
          do
          {
            v44 = v32->i32[v34] + v13->i32[v34];
            a3->f64[v34] = v15 * (double)v44;
            v13->i32[v34] = v44 - v33->i32[v34];
            ++v34;
          }
          while (a6 != v34);
        }
      }
      a3 = (float64x2_t *)((char *)a3 + a4);
      ++v10;
      --a5;
    }
    while (a5);
  }
}

void sub_219E46E6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,char a29)
{
  cv::Exception::~Exception((cv::Exception *)&a29);
  if (a16 < 0)
    operator delete(__p);
  if (a22 < 0)
    operator delete(a17);
  if (a28 < 0)
    operator delete(a23);
  _Unwind_Resume(a1);
}

uint64_t cv::ColumnSum<int,double>::reset(uint64_t result)
{
  *(_DWORD *)(result + 24) = 0;
  return result;
}

void cv::ColumnSum<double,double>::~ColumnSum(cv::BaseRowFilter *this)
{
  void *v2;

  *(_QWORD *)this = &off_24DBEFC48;
  v2 = (void *)*((_QWORD *)this + 4);
  if (v2)
  {
    *((_QWORD *)this + 5) = v2;
    operator delete(v2);
  }
  cv::BaseRowFilter::~BaseRowFilter(this);
}

{
  void *v2;

  *(_QWORD *)this = &off_24DBEFC48;
  v2 = (void *)*((_QWORD *)this + 4);
  if (v2)
  {
    *((_QWORD *)this + 5) = v2;
    operator delete(v2);
  }
  cv::BaseRowFilter::~BaseRowFilter(this);
  JUMPOUT(0x2207351BCLL);
}

void cv::ColumnSum<double,double>::operator()(uint64_t a1, float64x2_t **a2, uint64_t a3, int a4, int a5, int a6)
{
  float64x2_t **v10;
  uint64_t v12;
  float64x2_t *v13;
  float64x2_t *v14;
  double v15;
  int v16;
  int v17;
  const cv::Exception *v18;
  int v19;
  int v20;
  float64x2_t *v21;
  uint64_t v22;
  uint64_t v23;
  float64x2_t *v24;
  float64x2_t *v25;
  float64x2_t v26;
  double *v27;
  uint64_t v28;
  double *v29;
  double v30;
  uint64_t v31;
  uint64_t v32;
  float64x2_t *v33;
  float64x2_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  float64x2_t v38;
  float64_t v39;
  uint64_t v40;
  float64x2_t v41;
  float64_t v42;
  double v43;
  void *__p[2];
  void *v45[2];
  void *v46[2];
  _BYTE v47[120];

  v10 = a2;
  v14 = *(float64x2_t **)(a1 + 32);
  v12 = a1 + 32;
  v13 = v14;
  v15 = *(double *)(v12 - 16);
  v43 = v15;
  if (((*(_QWORD *)(v12 + 8) - (_QWORD)v14) >> 3) == a6)
  {
    v16 = *(_DWORD *)(a1 + 24);
    if (v16)
    {
      v17 = *(_DWORD *)(a1 + 8);
      if (v16 != v17 - 1)
      {
        std::string::basic_string[abi:ne180100]<0>(v46, "sumCount == ksize-1");
        std::string::basic_string[abi:ne180100]<0>(v45, "operator()");
        std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/imgproc/smooth.cpp");
        cv::Exception::Exception(v47, 4294967081, v46, v45, __p, 145);
        cv::error((cv *)v47, v18);
      }
      v10 = &a2[v17 - 1];
      goto LABEL_21;
    }
  }
  else
  {
    std::vector<cv::Point_<int>>::resize(v12, a6);
    v15 = v43;
    *(_DWORD *)(a1 + 24) = 0;
    v13 = *(float64x2_t **)(a1 + 32);
  }
  if (a6 >= 1)
  {
    bzero(v13, 8 * a6);
    v15 = v43;
  }
  v17 = *(_DWORD *)(a1 + 8);
  v19 = v17 - 1;
  if (v17 > 1)
  {
    v20 = 0;
    do
    {
      v21 = *v10;
      if (a6 >= 2)
      {
        v23 = 0;
        v24 = v13;
        v25 = *v10;
        do
        {
          v26 = *v25++;
          *v24 = vaddq_f64(*v24, v26);
          ++v24;
          v23 += 2;
        }
        while (v23 <= a6 - 2);
        v22 = v23;
      }
      else
      {
        v22 = 0;
      }
      if ((int)v22 < a6)
      {
        v27 = &v13->f64[v22];
        v28 = a6 - v22;
        v29 = &v21->f64[v22];
        do
        {
          v30 = *v29++;
          *v27 = v30 + *v27;
          ++v27;
          --v28;
        }
        while (v28);
      }
      ++v20;
      ++v10;
    }
    while (v20 != v19);
    *(_DWORD *)(a1 + 24) = v19;
  }
LABEL_21:
  if (a5)
  {
    v31 = 1 - v17;
    v32 = a6 - 2;
    do
    {
      v33 = *v10;
      v34 = v10[v31];
      if (v15 == 1.0)
      {
        if (a6 >= 2)
        {
          v40 = 0;
          v36 = 0;
          do
          {
            v41 = vaddq_f64(v13[v40], v33[v40]);
            *(float64x2_t *)(a3 + v40 * 16) = v41;
            v13[v40] = vsubq_f64(v41, v34[v40]);
            v36 += 2;
            ++v40;
          }
          while (v36 <= v32);
          v36 = v36;
        }
        else
        {
          v36 = 0;
        }
        if ((int)v36 < a6)
        {
          do
          {
            v42 = v13->f64[v36] + v33->f64[v36];
            *(float64_t *)(a3 + 8 * v36) = v42;
            v13->f64[v36] = v42 - v34->f64[v36];
            ++v36;
          }
          while (a6 != v36);
        }
      }
      else
      {
        if (a6 >= 2)
        {
          v37 = 0;
          v35 = 0;
          do
          {
            v38 = vaddq_f64(v13[v37], v33[v37]);
            *(float64x2_t *)(a3 + v37 * 16) = vmulq_n_f64(v38, v15);
            v13[v37] = vsubq_f64(v38, v34[v37]);
            v35 += 2;
            ++v37;
          }
          while (v35 <= v32);
          v35 = v35;
        }
        else
        {
          v35 = 0;
        }
        if ((int)v35 < a6)
        {
          do
          {
            v39 = v13->f64[v35] + v33->f64[v35];
            *(double *)(a3 + 8 * v35) = v15 * v39;
            v13->f64[v35] = v39 - v34->f64[v35];
            ++v35;
          }
          while (a6 != v35);
        }
      }
      a3 += a4;
      ++v10;
      --a5;
    }
    while (a5);
  }
}

void sub_219E47290(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,char a29)
{
  cv::Exception::~Exception((cv::Exception *)&a29);
  if (a16 < 0)
    operator delete(__p);
  if (a22 < 0)
    operator delete(a17);
  if (a28 < 0)
    operator delete(a23);
  _Unwind_Resume(a1);
}

uint64_t cv::ColumnSum<double,double>::reset(uint64_t result)
{
  *(_DWORD *)(result + 24) = 0;
  return result;
}

void cv::copyMakeBorder(uint64_t a1, uint64_t a2)
{
  void (***v2)(uint64_t *__return_ptr, _QWORD, uint64_t);
  double *v3;
  double *v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  const cv::Exception *v17;
  __int16 v18;
  double *v19;
  int v20;
  int v21;
  int v22;
  int v23;
  void *v24;
  char *v25;
  int v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  unsigned int v30;
  int v31;
  double v32;
  int v33;
  int v34;
  uint64_t v35;
  unsigned int v36;
  char *v37;
  uint64_t v38;
  char *v39;
  int v40;
  int v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int *v46;
  int v47;
  int v48;
  int *v49;
  uint64_t v50;
  uint64_t v51;
  int *v52;
  int v53;
  uint64_t v54;
  char *v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  char *v60;
  char *v61;
  char *v62;
  int *v63;
  char *v64;
  uint64_t v65;
  uint64_t v66;
  int *v67;
  char *v68;
  uint64_t v69;
  uint64_t v70;
  int *v71;
  char *v72;
  uint64_t v73;
  uint64_t v74;
  int *v75;
  char *v76;
  uint64_t v77;
  uint64_t v78;
  int v79;
  char *v80;
  unint64_t v81;
  uint64_t v82;
  int v83;
  uint64_t v84;
  uint64_t v85;
  char *v86;
  int v87;
  const cv::Exception *v89;
  uint64_t v90;
  uint64_t v91;
  char *v92;
  uint64_t v93;
  int v94;
  uint64_t v95;
  char *v96;
  _QWORD *v97;
  uint64_t v98;
  _BYTE *v99;
  char *v100;
  _BYTE *v101;
  uint64_t v102;
  char v103;
  int v104;
  int v105;
  char *v106;
  size_t v107;
  int v108;
  size_t v109;
  size_t v110;
  size_t v111;
  int v112;
  uint64_t v113;
  char *v114;
  uint64_t v115;
  char *v116;
  unsigned int *v119;
  unsigned int v120;
  unsigned int v121;
  uint64_t v122;
  _DWORD *v123;
  unsigned int *v124;
  unsigned int v125;
  unsigned int v126;
  uint64_t v127;
  int *v128;
  int v129;
  int v130;
  char v131;
  char *v132;
  int v133;
  char *v134;
  int v135;
  int v136;
  size_t __n;
  int __na;
  int *v139;
  int v140[2];
  uint64_t v141;
  int v142;
  uint64_t v143;
  char *v144;
  int v145;
  unsigned int v146;
  int v147;
  void *v148[2];
  void *v149[2];
  char *v150;
  uint64_t v151;
  _BYTE v152[4176];
  void *v153[2];
  char *v154;
  unsigned int *v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  _DWORD *v159;
  cv *v160;
  uint64_t v161;
  void *__p[3];
  uint64_t v163;
  int v164;
  int v165;
  void *__src;
  unsigned int *v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  int *v171;
  cv *v172;
  uint64_t v173;
  void *v174;
  uint64_t v175;
  _QWORD v176[517];

  v2 = (void (***)(uint64_t *__return_ptr, _QWORD, uint64_t))MEMORY[0x24BDAC7A8](a1, a2);
  v4 = v3;
  v6 = v5;
  v8 = v7;
  v10 = v9;
  v12 = v11;
  v14 = v13;
  v16 = v15;
  v176[515] = *MEMORY[0x24BDAC8D0];
  (**v2)(&v163, v2, 0xFFFFFFFFLL);
  if ((v12 | v14 | v10 | v8) < 0)
  {
    std::string::basic_string[abi:ne180100]<0>(&v174, "top >= 0 && bottom >= 0 && left >= 0 && right >= 0");
    std::string::basic_string[abi:ne180100]<0>(v153, "copyMakeBorder");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/imgproc/utils.cpp");
    cv::Exception::Exception(&v150, 4294967081, &v174, v153, __p, 208);
    cv::error((cv *)&v150, v17);
  }
  v18 = v163;
  if ((v6 & 0x10) == 0 && (v163 & 0x8000) != 0)
  {
    v145 = v6;
    v19 = v4;
    v150 = 0;
    v174 = 0;
    cv::Mat::locateROI((uint64_t)&v163, &v150, &v174);
    if (SHIDWORD(v174) >= v14)
      v20 = v14;
    else
      v20 = HIDWORD(v174);
    if (HIDWORD(v150) - (HIDWORD(v174) + v164) >= v12)
      v21 = v12;
    else
      v21 = HIDWORD(v150) - (HIDWORD(v174) + v164);
    if ((int)v174 >= v10)
      v22 = v10;
    else
      v22 = (int)v174;
    if ((int)v150 - ((int)v174 + v165) >= v8)
      v23 = v8;
    else
      v23 = (_DWORD)v150 - ((_DWORD)v174 + v165);
    cv::Mat::adjustROI((cv::Mat *)&v163, v20, v21, v22, v23);
    v14 -= v20;
    v10 -= v22;
    v12 -= v21;
    v8 -= v23;
    v18 = v163;
    v4 = v19;
    v6 = v145;
  }
  (*(void (**)(uint64_t, _QWORD, _QWORD, _QWORD, uint64_t, _QWORD, _QWORD))(*(_QWORD *)v16 + 136))(v16, (v14 + v12 + v164), (v10 + v8 + v165), v18 & 0xFFF, 0xFFFFFFFFLL, 0, 0);
  (**(void (***)(void **__return_ptr, uint64_t, uint64_t))v16)(v153, v16, 0xFFFFFFFFLL);
  if (v10 | v8 | v12 | v14)
  {
    v146 = v6 & 0xFFFFFFEF;
    v136 = v14;
    if ((v6 & 0xFFFFFFEF) != 0)
    {
      v143 = v173;
      v25 = (char *)__src;
      v26 = v171[1];
      v27 = v161;
      v134 = v154;
      v28 = v159[1];
      if (SHIDWORD(v163) < 1)
        LODWORD(v29) = 0;
      else
        v29 = *((_QWORD *)v172 + (HIDWORD(v163) - 1));
      v34 = *v171;
      v130 = *v159;
      v141 = ((__src | v154 | v173 | v161) | v29) & 3;
      if ((((__src | v154 | v173 | v161) | v29) & 3) != 0)
        v35 = v29;
      else
        v35 = ((int)v29 / 4);
      v36 = v35 * (v28 - v26);
      v150 = v152;
      v151 = 1032;
      v37 = v152;
      if (v36 >= 0x409)
      {
        v151 = (int)v36;
        v37 = (char *)operator new[]();
        v150 = v37;
      }
      v139 = (int *)v37;
      v133 = v34;
      if (v10 >= 1)
      {
        v38 = 0;
        v39 = v37;
        do
        {
          v40 = cv::borderInterpolate((cv *)(v38 - v10), v26, v146);
          if ((int)v35 >= 1)
          {
            v41 = v40 * v35;
            v42 = v39;
            v43 = v35;
            do
            {
              *v42++ = v41++;
              --v43;
            }
            while (v43);
          }
          ++v38;
          v39 += 4 * (int)v35;
        }
        while (v38 != v10);
      }
      v44 = (v28 - (v26 + v10));
      if ((int)v44 >= 1)
      {
        v45 = 0;
        v46 = &v139[(int)v35 * (uint64_t)v10];
        do
        {
          v47 = cv::borderInterpolate((cv *)(v26 + v45), v26, v146);
          if ((int)v35 >= 1)
          {
            v48 = v47 * v35;
            v49 = v46;
            v50 = v35;
            do
            {
              *v49++ = v48++;
              --v50;
            }
            while (v50);
          }
          ++v45;
          v46 += (int)v35;
        }
        while (v45 != v44);
      }
      v129 = v35 * v28;
      v51 = v27 * v136;
      v132 = &v134[v51];
      v131 = 2 * (v141 == 0);
      v52 = v139;
      if (v133 >= 1)
      {
        v53 = 0;
        v54 = (v35 * v10);
        v55 = &v132[(_DWORD)v54 << v131];
        v56 = v35 * v26;
        __n = ((int)v35 * v26) << v131;
        v57 = (v35 * v44);
        v58 = v51 + (int)((_DWORD)v54 << v131);
        v59 = &v134[v58 - (int)v54];
        v60 = &v134[v58 + v56];
        v61 = &v134[v58 - 4 * (int)v54];
        v62 = &v134[4 * v56 + v58];
        do
        {
          if (v55 != v25)
          {
            memcpy(v55, v25, __n);
            v52 = v139;
          }
          if (v141)
          {
            v63 = v52;
            v64 = v59;
            v65 = v54;
            if ((int)v54 >= 1)
            {
              do
              {
                v66 = *v63++;
                *v64++ = v25[v66];
                --v65;
              }
              while (v65);
            }
            v67 = &v139[(int)v54];
            v68 = v60;
            v69 = v57;
            if ((int)v57 >= 1)
            {
              do
              {
                v70 = *v67++;
                *v68++ = v25[v70];
                --v69;
              }
              while (v69);
            }
          }
          else
          {
            v71 = v52;
            v72 = v61;
            v73 = v54;
            if ((int)v54 >= 1)
            {
              do
              {
                v74 = *v71++;
                *(_DWORD *)v72 = *(_DWORD *)&v25[4 * v74];
                v72 += 4;
                --v73;
              }
              while (v73);
            }
            v75 = &v139[(int)v54];
            v76 = v62;
            v77 = v57;
            if ((int)v57 >= 1)
            {
              do
              {
                v78 = *v75++;
                *(_DWORD *)v76 = *(_DWORD *)&v25[4 * v78];
                v76 += 4;
                --v77;
              }
              while (v77);
            }
          }
          ++v53;
          v55 += v27;
          v25 += v143;
          v59 += v27;
          v60 += v27;
          v61 += v27;
          v62 += v27;
        }
        while (v53 != v133);
      }
      v79 = v129 << v131;
      if (v136 >= 1)
      {
        v80 = v134;
        v81 = -v136;
        v82 = v136;
        do
        {
          v83 = cv::borderInterpolate((cv *)v81, v133, v146);
          memcpy(v80, &v132[v27 * v83], v79);
          v80 += v27;
          v81 = (v81 + 1);
          --v82;
        }
        while (v82);
      }
      v84 = (v130 - v136 - v133);
      if ((int)v84 >= 1)
      {
        v85 = 0;
        v86 = &v134[v27 * (v136 + (uint64_t)v133)];
        do
        {
          v87 = cv::borderInterpolate((cv *)(v133 + v85), v133, v146);
          memcpy(v86, &v132[v27 * v87], v79);
          ++v85;
          v86 += v27;
        }
        while (v84 != v85);
      }
      if (v150 != v152 && v150 != 0)
LABEL_107:
        MEMORY[0x2207351A4]();
    }
    else
    {
      v30 = (v163 >> 3) & 0x1FF;
      v31 = v30 + 1;
      v150 = v152;
      v151 = 520;
      if (v30 < 4)
      {
        v33 = v30 + 1;
      }
      else
      {
        v32 = *v4;
        if (*v4 != v4[1] || v32 != v4[2] || v32 != v4[3])
        {
          std::string::basic_string[abi:ne180100]<0>(__p, "value[0] == value[1] && value[0] == value[2] && value[0] == value[3]");
          std::string::basic_string[abi:ne180100]<0>(v149, "copyMakeBorder");
          std::string::basic_string[abi:ne180100]<0>(v148, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/imgproc/utils.cpp");
          cv::Exception::Exception(&v174, 4294967081, __p, v149, v148, 248);
          cv::error((cv *)&v174, v89);
        }
        v33 = 1;
      }
      cv::scalarToRawData((uint64_t)v4, (uint64_t)v152, (v163 & 7 | (8 * v33)) - 8, v31);
      v90 = v159[1];
      if (SHIDWORD(v163) < 1)
        v91 = 0;
      else
        v91 = *((unsigned int *)v172 + 2 * (HIDWORD(v163) - 1));
      v92 = (char *)__src;
      v93 = v173;
      v94 = v171[1];
      v144 = v154;
      v147 = *v171;
      v95 = v161;
      __na = *v159;
      v96 = v150;
      v97 = v176;
      v174 = v176;
      v175 = 4104;
      v142 = v90 * v91;
      if ((v90 * v91) >= 0x1009)
      {
        v175 = v142;
        v97 = (_QWORD *)operator new[]();
        v174 = v97;
      }
      if ((int)v90 >= 1)
      {
        v98 = 0;
        v99 = v97;
        do
        {
          if ((int)v91 >= 1)
          {
            v100 = v96;
            v101 = v99;
            v102 = v91;
            do
            {
              v103 = *v100++;
              *v101++ = v103;
              --v102;
            }
            while (v102);
          }
          ++v98;
          v99 += (int)v91;
        }
        while (v98 != v90);
      }
      v135 = v147 + v14;
      *(_QWORD *)v140 = v14;
      if (v147 >= 1)
      {
        v104 = v90 - (v94 + v10);
        v105 = v10 * v91;
        v106 = &v144[v95 * v14];
        v107 = v105;
        v108 = v94 * v91;
        v109 = v104 * (int)v91;
        v110 = v108;
        v111 = v107 + v108;
        v112 = v147;
        do
        {
          if (v92 != &v106[v107])
            memcpy(&v106[v107], v92, v110);
          memcpy(v106, v97, v107);
          memcpy(&v106[v111], v97, v109);
          v92 += v93;
          v106 += v95;
          --v112;
        }
        while (v112);
      }
      v113 = (__na - v135);
      if (v136 >= 1)
      {
        v114 = v144;
        v115 = v136;
        do
        {
          memcpy(v114, v97, v142);
          v114 += v95;
          --v115;
        }
        while (v115);
      }
      if ((int)v113 >= 1)
      {
        v116 = &v144[v95 * (*(_QWORD *)v140 + v147)];
        do
        {
          memcpy(v116, v97, v142);
          v116 += v95;
          --v113;
        }
        while (v113);
      }
      if (v174 != v176 && v174 != 0)
        MEMORY[0x2207351A4]();
      if (v150 != v152 && v150 != 0)
        goto LABEL_107;
    }
  }
  else if (__src != v154 || v173 != v161)
  {
    cv::_OutputArray::_OutputArray((uint64_t)&v150, (cv::Mat *)v153);
    cv::Mat::copyTo((cv::Mat *)&v163, (const cv::_OutputArray *)&v150);
  }
  v119 = v155;
  if (v155)
  {
    do
    {
      v120 = __ldaxr(v119);
      v121 = v120 - 1;
    }
    while (__stlxr(v121, v119));
    if (!v121)
      cv::Mat::deallocate((cv::Mat *)v153, v24);
  }
  v154 = 0;
  v156 = 0;
  v158 = 0;
  v157 = 0;
  if (SHIDWORD(v153[0]) >= 1)
  {
    v122 = 0;
    v123 = v159;
    do
      v123[v122++] = 0;
    while (v122 < SHIDWORD(v153[0]));
  }
  v155 = 0;
  if (v160 != (cv *)&v161)
    cv::fastFree((void **)v160, v24);
  v124 = v167;
  if (v167)
  {
    do
    {
      v125 = __ldaxr(v124);
      v126 = v125 - 1;
    }
    while (__stlxr(v126, v124));
    if (!v126)
      cv::Mat::deallocate((cv::Mat *)&v163, v24);
  }
  __src = 0;
  v168 = 0;
  v170 = 0;
  v169 = 0;
  if (SHIDWORD(v163) >= 1)
  {
    v127 = 0;
    v128 = v171;
    do
      v128[v127++] = 0;
    while (v127 < SHIDWORD(v163));
  }
  v167 = 0;
  if (v172 != (cv *)&v173)
    cv::fastFree((void **)v172, v24);
}

void sub_219E47E90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37)
{
  void *v38;
  void *v39;

  cv::Exception::~Exception((cv::Exception *)&STACK[0x11E8]);
  if (a30 < 0)
    operator delete(__p);
  if (a36 < 0)
    operator delete(a31);
  if (SLOBYTE(STACK[0x1187]) < 0)
    operator delete((void *)STACK[0x1170]);
  if (a37 != a20)
  {
    if (a37)
      MEMORY[0x2207351A4]();
  }
  cv::Mat::~Mat((cv::Mat *)&STACK[0x1110], v38);
  cv::Mat::~Mat((cv::Mat *)&STACK[0x1188], v39);
  _Unwind_Resume(a1);
}

void cv::getDerivKernels(cv *this, const cv::_OutputArray *a2, const cv::_OutputArray *a3, int a4, int a5, char a6, unsigned int a7)
{
  if (a5 <= 0)
    cv::getScharrKernels(this, a2, a3, a4, a6, a7);
  else
    cv::getSobelKernels(this, a2, a3, a4, a5, a6, a7);
}

void cv::getScharrKernels(cv *this, const cv::_OutputArray *a2, const cv::_OutputArray *a3, int a4, unsigned __int8 a5, unsigned int a6)
{
  const cv::Exception *v8;
  const cv::Exception *v9;
  char v10;
  char v11;
  void **v12;
  int v13;
  uint64_t v14;
  int v15;
  __int128 *v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  double v20;
  void *v21;
  unsigned int *v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t v25;
  _DWORD *v26;
  unsigned int *v27;
  unsigned int v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int *v32;
  unsigned int v33;
  unsigned int v34;
  uint64_t v35;
  uint64_t v36;
  int v38;
  void *__p[2];
  void *v42[2];
  void *v43;
  __int128 v44;
  unsigned int *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  cv *v50;
  uint64_t v51;
  void *v52;
  __int128 v53;
  unsigned int *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  cv *v59;
  uint64_t v60;
  uint64_t v61;
  _DWORD v62[2];
  uint64_t *v63;
  unsigned int *v64;
  uint64_t *v65;
  char *v66;
  char *v67;
  uint64_t v68;
  _DWORD *v69;
  cv *v70;
  _QWORD v71[5];
  uint64_t v72;
  int v73;
  uint64_t v74;

  v38 = (int)a3;
  v74 = *MEMORY[0x24BDAC8D0];
  if (a6 - 5 >= 2)
  {
    std::string::basic_string[abi:ne180100]<0>(&v52, "ktype == CV_32F || ktype == CV_64F");
    std::string::basic_string[abi:ne180100]<0>(&v43, "getScharrKernels");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/imgproc/deriv.cpp");
    cv::Exception::Exception(&v61, 4294967081, &v52, &v43, __p, 136);
    cv::error((cv *)&v61, v8);
  }
  (*(void (**)(cv *, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, _QWORD))(*(_QWORD *)this + 136))(this, 3, 1, a6, 0xFFFFFFFFLL, 1, 0);
  (*(void (**)(const cv::_OutputArray *, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, _QWORD))(*(_QWORD *)a2 + 136))(a2, 3, 1, a6, 0xFFFFFFFFLL, 1, 0);
  (**(void (***)(void **__return_ptr, cv *, uint64_t))this)(&v52, this, 0xFFFFFFFFLL);
  (**(void (***)(void **__return_ptr, const cv::_OutputArray *, uint64_t))a2)(&v43, a2, 0xFFFFFFFFLL);
  if ((a4 | v38) < 0 || a4 + v38 != 1)
  {
    std::string::basic_string[abi:ne180100]<0>(__p, "dx >= 0 && dy >= 0 && dx+dy == 1");
    std::string::basic_string[abi:ne180100]<0>(&v72, "getScharrKernels");
    std::string::basic_string[abi:ne180100]<0>(v42, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/imgproc/deriv.cpp");
    cv::Exception::Exception(&v61, 4294967081, __p, &v72, v42, 142);
    cv::error((cv *)&v61, v9);
  }
  v10 = 1;
  do
  {
    v11 = v10;
    if ((v10 & 1) != 0)
      v12 = &v52;
    else
      v12 = &v43;
    if ((v10 & 1) != 0)
      v13 = v38;
    else
      v13 = a4;
    if (v13)
    {
      if (v13 != 1)
        goto LABEL_18;
      v14 = 0xFFFFFFFFLL;
      v15 = 1;
    }
    else
    {
      v15 = 3;
      v14 = 0xA00000003;
    }
    v72 = v14;
    v73 = v15;
LABEL_18:
    v16 = &v53;
    if ((v11 & 1) == 0)
      v16 = &v44;
    v17 = *(int *)v16;
    v18 = (char *)&v53 + 4;
    if ((v11 & 1) == 0)
      v18 = (char *)&v44 + 4;
    v19 = *(int *)v18;
    v62[0] = v17;
    v62[1] = v19;
    v63 = &v72;
    v64 = 0;
    v69 = v62;
    v70 = (cv *)v71;
    v61 = 0x242FF4004;
    v71[0] = 4 * v19;
    v71[1] = 4;
    v67 = (char *)&v72 + 4 * v19 * v17;
    v68 = 0;
    v65 = &v72;
    v66 = v67;
    cv::_OutputArray::_OutputArray((uint64_t)__p, (cv::Mat *)v12);
    v20 = 0.03125;
    if (((v13 != 1) & a5) == 0)
      v20 = 1.0;
    cv::Mat::convertTo((cv::Mat *)&v61, (const cv::_OutputArray *)__p, a6, v20, 0.0);
    v22 = v64;
    if (v64)
    {
      do
      {
        v23 = __ldaxr(v22);
        v24 = v23 - 1;
      }
      while (__stlxr(v24, v22));
      if (!v24)
        cv::Mat::deallocate((cv::Mat *)&v61, v21);
    }
    v63 = 0;
    v66 = 0;
    v67 = 0;
    v65 = 0;
    if (SHIDWORD(v61) >= 1)
    {
      v25 = 0;
      v26 = v69;
      do
        v26[v25++] = 0;
      while (v25 < SHIDWORD(v61));
    }
    v64 = 0;
    if (v70 != (cv *)v71)
      cv::fastFree((void **)v70, v21);
    v10 = 0;
  }
  while ((v11 & 1) != 0);
  v27 = v45;
  if (v45)
  {
    do
    {
      v28 = __ldaxr(v27);
      v29 = v28 - 1;
    }
    while (__stlxr(v29, v27));
    if (!v29)
      cv::Mat::deallocate((cv::Mat *)&v43, v21);
  }
  *((_QWORD *)&v44 + 1) = 0;
  v46 = 0;
  v47 = 0;
  v48 = 0;
  if (SHIDWORD(v43) >= 1)
  {
    v30 = 0;
    v31 = v49;
    do
      *(_DWORD *)(v31 + 4 * v30++) = 0;
    while (v30 < SHIDWORD(v43));
  }
  v45 = 0;
  if (v50 != (cv *)&v51)
    cv::fastFree((void **)v50, v21);
  v32 = v54;
  if (v54)
  {
    do
    {
      v33 = __ldaxr(v32);
      v34 = v33 - 1;
    }
    while (__stlxr(v34, v32));
    if (!v34)
      cv::Mat::deallocate((cv::Mat *)&v52, v21);
  }
  *((_QWORD *)&v53 + 1) = 0;
  v55 = 0;
  v56 = 0;
  v57 = 0;
  if (SHIDWORD(v52) >= 1)
  {
    v35 = 0;
    v36 = v58;
    do
      *(_DWORD *)(v36 + 4 * v35++) = 0;
    while (v35 < SHIDWORD(v52));
  }
  v54 = 0;
  if (v59 != (cv *)&v60)
    cv::fastFree((void **)v59, v21);
}

void sub_219E48500(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55)
{
  uint64_t v55;
  void *v57;
  void *v58;

  cv::Exception::~Exception((cv::Exception *)&a55);
  if (a24 < 0)
    operator delete(__p);
  if (*(char *)(v55 - 129) < 0)
    operator delete(*(void **)(v55 - 152));
  if (a17 < 0)
    operator delete(a12);
  cv::Mat::~Mat((cv::Mat *)&a25, v57);
  cv::Mat::~Mat((cv::Mat *)&a40, v58);
  _Unwind_Resume(a1);
}

void cv::getSobelKernels(cv *this, const cv::_OutputArray *a2, const cv::_OutputArray *a3, int a4, int a5, int a6, unsigned int a7)
{
  unsigned int v10;
  int v11;
  cv *v12;
  const cv::Exception *v13;
  cv *v14;
  const cv::Exception *v15;
  signed int v16;
  cv *v17;
  const cv::Exception *v18;
  char v19;
  char v20;
  void **v21;
  int v22;
  int v23;
  cv *v24;
  const cv::Exception *v25;
  std::vector<int>::pointer v26;
  std::vector<int>::pointer begin;
  std::vector<int>::pointer v28;
  int v29;
  int i;
  int v31;
  uint64_t v32;
  int *v33;
  int v34;
  int v35;
  int j;
  int v37;
  int v38;
  uint64_t v39;
  int *v40;
  int v41;
  std::vector<int>::pointer v42;
  __int128 *v43;
  uint64_t v44;
  char *v45;
  uint64_t v46;
  double v47;
  void *v48;
  unsigned int *v49;
  unsigned int v50;
  unsigned int v51;
  uint64_t v52;
  _DWORD *v53;
  unsigned int *v54;
  unsigned int v55;
  unsigned int v56;
  uint64_t v57;
  uint64_t v58;
  unsigned int *v59;
  unsigned int v60;
  unsigned int v61;
  uint64_t v62;
  uint64_t v63;
  int v66;
  int v68;
  signed int v69;
  void *__p[2];
  void *v71[2];
  void *v72[2];
  std::vector<int> v73;
  void *v74;
  __int128 v75;
  unsigned int *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  cv *v81;
  uint64_t v82;
  void *v83;
  __int128 v84;
  unsigned int *v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  cv *v90;
  uint64_t v91;
  uint64_t v92;
  _DWORD v93[2];
  std::vector<int>::pointer v94;
  unsigned int *v95;
  std::vector<int>::pointer v96;
  char *v97;
  char *v98;
  uint64_t v99;
  _DWORD *v100;
  void **v101;
  _QWORD v102[6];

  v66 = (int)a3;
  if ((int)a3 > 0 && a5 == 1)
    v10 = 3;
  else
    v10 = a5;
  if (a4 > 0 && a5 == 1)
    v11 = 3;
  else
    v11 = a5;
  v68 = v11;
  v69 = v10;
  if (a7 - 5 >= 2)
  {
    std::string::basic_string[abi:ne180100]<0>(&v83, "ktype == CV_32F || ktype == CV_64F");
    std::string::basic_string[abi:ne180100]<0>(&v74, "getSobelKernels");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/imgproc/deriv.cpp");
    v12 = (cv *)cv::Exception::Exception(&v92, 4294967081, &v83, &v74, __p, 171);
    cv::error(v12, v13);
  }
  (*(void (**)(cv *, _QWORD, uint64_t, _QWORD, uint64_t, uint64_t, _QWORD))(*(_QWORD *)this + 136))(this, v10, 1, a7, 0xFFFFFFFFLL, 1, 0);
  (*(void (**)(const cv::_OutputArray *, _QWORD, uint64_t, _QWORD, uint64_t, uint64_t, _QWORD))(*(_QWORD *)a2 + 136))(a2, v68, 1, a7, 0xFFFFFFFFLL, 1, 0);
  (**(void (***)(void **__return_ptr, cv *, uint64_t))this)(&v83, this, 0xFFFFFFFFLL);
  (**(void (***)(void **__return_ptr, const cv::_OutputArray *, uint64_t))a2)(&v74, a2, 0xFFFFFFFFLL);
  if (a5 > 31 || (a5 & 1) == 0)
  {
    std::string::basic_string[abi:ne180100]<0>(__p, "The kernel size must be odd and not larger than 31");
    std::string::basic_string[abi:ne180100]<0>(&v73, "getSobelKernels");
    std::string::basic_string[abi:ne180100]<0>(v72, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/imgproc/deriv.cpp");
    v14 = (cv *)cv::Exception::Exception(&v92, 4294967085, __p, &v73, v72, 179);
    cv::error(v14, v15);
  }
  v16 = v69;
  if (v69 <= v68)
    v16 = v68;
  std::vector<int>::vector(&v73, v16 + 1);
  if ((a4 | v66) < 0 || (a4 + v66 < 0) ^ __OFADD__(a4, v66) | (a4 + v66 == 0))
  {
    std::string::basic_string[abi:ne180100]<0>(__p, "dx >= 0 && dy >= 0 && dx+dy > 0");
    std::string::basic_string[abi:ne180100]<0>(v72, "getSobelKernels");
    std::string::basic_string[abi:ne180100]<0>(v71, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/imgproc/deriv.cpp");
    v17 = (cv *)cv::Exception::Exception(&v92, 4294967081, __p, v72, v71, 182);
    cv::error(v17, v18);
  }
  v19 = 1;
  do
  {
    v20 = v19;
    if ((v19 & 1) != 0)
      v21 = &v83;
    else
      v21 = &v74;
    if ((v19 & 1) != 0)
      v22 = v66;
    else
      v22 = a4;
    if ((v19 & 1) != 0)
      v23 = v69;
    else
      v23 = v68;
    if (v23 <= v22)
    {
      std::string::basic_string[abi:ne180100]<0>(__p, "ksize > order");
      std::string::basic_string[abi:ne180100]<0>(v72, "getSobelKernels");
      std::string::basic_string[abi:ne180100]<0>(v71, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/imgproc/deriv.cpp");
      v24 = (cv *)cv::Exception::Exception(&v92, 4294967081, __p, v72, v71, 190);
      cv::error(v24, v25);
    }
    if (v23 == 3)
    {
      if (v22 == 1)
      {
        begin = v73.__begin_;
        v42 = v73.__begin_;
        *(_QWORD *)v73.__begin_ = 0xFFFFFFFFLL;
        v26 = v42 + 2;
      }
      else
      {
        begin = v73.__begin_;
        v28 = v73.__begin_;
        if (v22)
          *(_QWORD *)v73.__begin_ = 0xFFFFFFFE00000001;
        else
          *(_QWORD *)v73.__begin_ = 0x200000001;
        v26 = v28 + 2;
      }
      goto LABEL_53;
    }
    if (v23 == 1)
    {
      v26 = v73.__begin_;
      begin = v73.__begin_;
LABEL_53:
      *v26 = 1;
      goto LABEL_54;
    }
    begin = v73.__begin_;
    *v73.__begin_ = 1;
    if (v23 >= 1)
      bzero(begin + 1, 4 * v23);
    v29 = v23 + ~v22;
    if (v29 >= 1)
    {
      for (i = 0; i != v29; ++i)
      {
        if (v23 >= 1)
        {
          v31 = *begin;
          v32 = (v23 + 1) - 1;
          v33 = begin + 1;
          v34 = *begin;
          do
          {
            v35 = *v33;
            *(v33 - 1) = v34;
            v34 = v31 + v35;
            ++v33;
            v31 = v35;
            --v32;
          }
          while (v32);
        }
      }
    }
    if (v22 >= 1)
    {
      for (j = 0; j != v22; ++j)
      {
        if (v23 >= 1)
        {
          v37 = *begin;
          v38 = -*begin;
          v39 = (v23 + 1) - 1;
          v40 = begin + 1;
          do
          {
            v41 = *v40;
            *(v40 - 1) = v38;
            v38 = v37 - v41;
            ++v40;
            v37 = v41;
            --v39;
          }
          while (v39);
        }
      }
    }
LABEL_54:
    v43 = &v84;
    if ((v20 & 1) == 0)
      v43 = &v75;
    v44 = *(int *)v43;
    v45 = (char *)&v84 + 4;
    if ((v20 & 1) == 0)
      v45 = (char *)&v75 + 4;
    v46 = *(int *)v45;
    v93[0] = v44;
    v93[1] = v46;
    v94 = begin;
    v95 = 0;
    v100 = v93;
    v101 = (void **)v102;
    v92 = 0x242FF4004;
    v102[0] = 4 * v46;
    v102[1] = 4;
    v98 = (char *)begin + 4 * v46 * v44;
    v99 = 0;
    v96 = begin;
    v97 = v98;
    v47 = 1.0;
    if (a6)
      v47 = 1.0 / (double)(1 << (v23 + ~(_BYTE)v22));
    cv::_OutputArray::_OutputArray((uint64_t)__p, (cv::Mat *)v21);
    cv::Mat::convertTo((cv::Mat *)&v92, (const cv::_OutputArray *)__p, a7, v47, 0.0);
    v49 = v95;
    if (v95)
    {
      do
      {
        v50 = __ldaxr(v49);
        v51 = v50 - 1;
      }
      while (__stlxr(v51, v49));
      if (!v51)
        cv::Mat::deallocate((cv::Mat *)&v92, v48);
    }
    v94 = 0;
    v97 = 0;
    v98 = 0;
    v96 = 0;
    if (SHIDWORD(v92) >= 1)
    {
      v52 = 0;
      v53 = v100;
      do
        v53[v52++] = 0;
      while (v52 < SHIDWORD(v92));
    }
    v95 = 0;
    if (v101 != v102)
      cv::fastFree(v101, v48);
    v19 = 0;
  }
  while ((v20 & 1) != 0);
  if (v73.__begin_)
  {
    v73.__end_ = v73.__begin_;
    operator delete(v73.__begin_);
  }
  v54 = v76;
  if (v76)
  {
    do
    {
      v55 = __ldaxr(v54);
      v56 = v55 - 1;
    }
    while (__stlxr(v56, v54));
    if (!v56)
      cv::Mat::deallocate((cv::Mat *)&v74, v48);
  }
  *((_QWORD *)&v75 + 1) = 0;
  v77 = 0;
  v78 = 0;
  v79 = 0;
  if (SHIDWORD(v74) >= 1)
  {
    v57 = 0;
    v58 = v80;
    do
      *(_DWORD *)(v58 + 4 * v57++) = 0;
    while (v57 < SHIDWORD(v74));
  }
  v76 = 0;
  if (v81 != (cv *)&v82)
    cv::fastFree((void **)v81, v48);
  v59 = v85;
  if (v85)
  {
    do
    {
      v60 = __ldaxr(v59);
      v61 = v60 - 1;
    }
    while (__stlxr(v61, v59));
    if (!v61)
      cv::Mat::deallocate((cv::Mat *)&v83, v48);
  }
  *((_QWORD *)&v84 + 1) = 0;
  v86 = 0;
  v87 = 0;
  v88 = 0;
  if (SHIDWORD(v83) >= 1)
  {
    v62 = 0;
    v63 = v89;
    do
      *(_DWORD *)(v63 + 4 * v62++) = 0;
    while (v62 < SHIDWORD(v83));
  }
  v85 = 0;
  if (v90 != (cv *)&v91)
    cv::fastFree((void **)v90, v48);
}

void sub_219E48D28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,void *a52,uint64_t a53,int a54,__int16 a55,char a56,char a57)
{
  uint64_t v57;
  void *v59;
  void *v60;

  cv::Exception::~Exception((cv::Exception *)(v57 - 256));
  if (a24 < 0)
    operator delete(__p);
  if (a30 < 0)
    operator delete(a25);
  if (a17 < 0)
    operator delete(a12);
  if (a31)
    operator delete(a31);
  cv::Mat::~Mat((cv::Mat *)&a37, v59);
  cv::Mat::~Mat((cv::Mat *)&a52, v60);
  _Unwind_Resume(a1);
}

void cv::Sobel(cv *this, const cv::_InputArray *a2, const cv::_OutputArray *a3, const cv::_OutputArray *a4, int a5, int a6, unsigned int a7, double a8, double a9)
{
  int v15;
  unsigned int v17;
  unsigned int v18;
  void *v19;
  unsigned int *v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  char *v24;
  unsigned int *v25;
  unsigned int v26;
  unsigned int v27;
  uint64_t v28;
  char *v29;
  unsigned int *v30;
  unsigned int v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int *v35;
  unsigned int v36;
  unsigned int v37;
  uint64_t v38;
  int32x2_t *v39;
  uint64_t v40;
  void (**v41[4])(_QWORD *__return_ptr, _QWORD, uint64_t);
  void (**v42[4])(_QWORD *__return_ptr, _QWORD, uint64_t);
  _BYTE v43[32];
  _OWORD v44[4];
  char *v45;
  cv *v46;
  _QWORD v47[2];
  _OWORD v48[4];
  char *v49;
  cv *v50;
  _QWORD v51[2];
  _QWORD v52[3];
  unsigned int *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  cv *v58;
  uint64_t v59;
  int32x2_t v60;
  _QWORD v61[3];
  unsigned int *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  int32x2_t *v66;
  void **v67;
  uint64_t v68;
  void (**v69[4])(_QWORD *__return_ptr, _QWORD, uint64_t);

  v15 = (int)a3;
  (**(void (***)(_QWORD *__return_ptr, cv *, uint64_t))this)(v61, this, 0xFFFFFFFFLL);
  if (v15 < 0)
    v15 = v61[0] & 7;
  v60 = vrev64_s32(*v66);
  (*(void (**)(const cv::_InputArray *, int32x2_t *, _QWORD, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 128))(a2, &v60, v61[0] & 0xFF8 | v15 & 7u, 0xFFFFFFFFLL, 0, 0);
  (**(void (***)(_QWORD *__return_ptr, const cv::_InputArray *, uint64_t))a2)(v52, a2, 0xFFFFFFFFLL);
  v17 = v61[0] & 7;
  v49 = (char *)v48 + 8;
  v50 = (cv *)v51;
  if (v15 > v17)
    v17 = v15;
  v51[0] = 0;
  v51[1] = 0;
  if (v17 <= 5)
    v18 = 5;
  else
    v18 = v17;
  LODWORD(v48[0]) = 1124007936;
  memset((char *)v48 + 4, 0, 48);
  v48[3] = 0u;
  v45 = (char *)v44 + 8;
  v46 = (cv *)v47;
  v47[0] = 0;
  v47[1] = 0;
  LODWORD(v44[0]) = 1124007936;
  memset((char *)v44 + 4, 0, 48);
  v44[3] = 0u;
  cv::_OutputArray::_OutputArray((uint64_t)v69, (cv::Mat *)v48);
  cv::_OutputArray::_OutputArray((uint64_t)v43, (cv::Mat *)v44);
  cv::getDerivKernels((cv *)v69, (const cv::_OutputArray *)v43, a4, a5, a6, 0, v18);
  if (a8 != 1.0)
  {
    if ((_DWORD)a4)
    {
      cv::_OutputArray::_OutputArray((uint64_t)v69, (cv::Mat *)v44);
      cv::Mat::convertTo((cv::Mat *)v44, (const cv::_OutputArray *)v69, -1, a8, 0.0);
    }
    else
    {
      cv::_OutputArray::_OutputArray((uint64_t)v69, (cv::Mat *)v48);
      cv::Mat::convertTo((cv::Mat *)v48, (const cv::_OutputArray *)v69, -1, a8, 0.0);
    }
  }
  cv::_InputArray::_InputArray((uint64_t)v69, (const cv::Mat *)v61);
  cv::_OutputArray::_OutputArray((uint64_t)v43, (cv::Mat *)v52);
  cv::_InputArray::_InputArray((uint64_t)v42, (const cv::Mat *)v48);
  cv::_InputArray::_InputArray((uint64_t)v41, (const cv::Mat *)v44);
  v40 = -1;
  cv::sepFilter2D(v69, (uint64_t)v43, v15, v42, v41, &v40, a7, a9);
  v20 = (unsigned int *)*((_QWORD *)&v44[1] + 1);
  if (*((_QWORD *)&v44[1] + 1))
  {
    do
    {
      v21 = __ldaxr(v20);
      v22 = v21 - 1;
    }
    while (__stlxr(v22, v20));
    if (!v22)
      cv::Mat::deallocate((cv::Mat *)v44, v19);
  }
  *(_QWORD *)&v44[1] = 0;
  memset(&v44[2], 0, 24);
  if (SDWORD1(v44[0]) >= 1)
  {
    v23 = 0;
    v24 = v45;
    do
      *(_DWORD *)&v24[4 * v23++] = 0;
    while (v23 < SDWORD1(v44[0]));
  }
  *((_QWORD *)&v44[1] + 1) = 0;
  if (v46 != (cv *)v47)
    cv::fastFree((void **)v46, v19);
  v25 = (unsigned int *)*((_QWORD *)&v48[1] + 1);
  if (*((_QWORD *)&v48[1] + 1))
  {
    do
    {
      v26 = __ldaxr(v25);
      v27 = v26 - 1;
    }
    while (__stlxr(v27, v25));
    if (!v27)
      cv::Mat::deallocate((cv::Mat *)v48, v19);
  }
  *(_QWORD *)&v48[1] = 0;
  memset(&v48[2], 0, 24);
  if (SDWORD1(v48[0]) >= 1)
  {
    v28 = 0;
    v29 = v49;
    do
      *(_DWORD *)&v29[4 * v28++] = 0;
    while (v28 < SDWORD1(v48[0]));
  }
  *((_QWORD *)&v48[1] + 1) = 0;
  if (v50 != (cv *)v51)
    cv::fastFree((void **)v50, v19);
  v30 = v53;
  if (v53)
  {
    do
    {
      v31 = __ldaxr(v30);
      v32 = v31 - 1;
    }
    while (__stlxr(v32, v30));
    if (!v32)
      cv::Mat::deallocate((cv::Mat *)v52, v19);
  }
  v52[2] = 0;
  v54 = 0;
  v55 = 0;
  v56 = 0;
  if (SHIDWORD(v52[0]) >= 1)
  {
    v33 = 0;
    v34 = v57;
    do
      *(_DWORD *)(v34 + 4 * v33++) = 0;
    while (v33 < SHIDWORD(v52[0]));
  }
  v53 = 0;
  if (v58 != (cv *)&v59)
    cv::fastFree((void **)v58, v19);
  v35 = v62;
  if (v62)
  {
    do
    {
      v36 = __ldaxr(v35);
      v37 = v36 - 1;
    }
    while (__stlxr(v37, v35));
    if (!v37)
      cv::Mat::deallocate((cv::Mat *)v61, v19);
  }
  v61[2] = 0;
  v63 = 0;
  v64 = 0;
  v65 = 0;
  if (SHIDWORD(v61[0]) >= 1)
  {
    v38 = 0;
    v39 = v66;
    do
      v39->i32[v38++] = 0;
    while (v38 < SHIDWORD(v61[0]));
  }
  v62 = 0;
  if (v67 != (void **)&v68)
    cv::fastFree(v67, v19);
}

void sub_219E492B0(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46)
{
  uint64_t v46;
  void *v48;
  void *v49;
  void *v50;

  cv::Mat::~Mat((cv::Mat *)&a22, a2);
  cv::Mat::~Mat((cv::Mat *)&a34, v48);
  cv::Mat::~Mat((cv::Mat *)&a46, v49);
  cv::Mat::~Mat((cv::Mat *)(v46 - 224), v50);
  _Unwind_Resume(a1);
}

void cv::Scharr(cv *this, const cv::_InputArray *a2, const cv::_OutputArray *a3, const cv::_OutputArray *a4, int a5, unsigned int a6, double a7, double a8)
{
  int v13;
  unsigned int v15;
  unsigned int v16;
  void *v17;
  unsigned int *v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  char *v22;
  unsigned int *v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t v26;
  char *v27;
  unsigned int *v28;
  unsigned int v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int *v33;
  unsigned int v34;
  unsigned int v35;
  uint64_t v36;
  int32x2_t *v37;
  uint64_t v38;
  void (**v39[4])(_QWORD *__return_ptr, _QWORD, uint64_t);
  void (**v40[4])(_QWORD *__return_ptr, _QWORD, uint64_t);
  _BYTE v41[32];
  _OWORD v42[4];
  char *v43;
  cv *v44;
  _QWORD v45[2];
  _OWORD v46[4];
  char *v47;
  cv *v48;
  _QWORD v49[2];
  _QWORD v50[3];
  unsigned int *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  cv *v56;
  uint64_t v57;
  int32x2_t v58;
  _QWORD v59[3];
  unsigned int *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  int32x2_t *v64;
  void **v65;
  uint64_t v66;
  void (**v67[4])(_QWORD *__return_ptr, _QWORD, uint64_t);

  v13 = (int)a3;
  (**(void (***)(_QWORD *__return_ptr, cv *, uint64_t))this)(v59, this, 0xFFFFFFFFLL);
  if (v13 < 0)
    v13 = v59[0] & 7;
  v58 = vrev64_s32(*v64);
  (*(void (**)(const cv::_InputArray *, int32x2_t *, _QWORD, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 128))(a2, &v58, v59[0] & 0xFF8 | v13 & 7u, 0xFFFFFFFFLL, 0, 0);
  (**(void (***)(_QWORD *__return_ptr, const cv::_InputArray *, uint64_t))a2)(v50, a2, 0xFFFFFFFFLL);
  v15 = v59[0] & 7;
  v47 = (char *)v46 + 8;
  v48 = (cv *)v49;
  if (v13 > v15)
    v15 = v13;
  v49[0] = 0;
  v49[1] = 0;
  if (v15 <= 5)
    v16 = 5;
  else
    v16 = v15;
  LODWORD(v46[0]) = 1124007936;
  memset((char *)v46 + 4, 0, 48);
  v46[3] = 0u;
  v43 = (char *)v42 + 8;
  v44 = (cv *)v45;
  v45[0] = 0;
  v45[1] = 0;
  LODWORD(v42[0]) = 1124007936;
  memset((char *)v42 + 4, 0, 48);
  v42[3] = 0u;
  cv::_OutputArray::_OutputArray((uint64_t)v67, (cv::Mat *)v46);
  cv::_OutputArray::_OutputArray((uint64_t)v41, (cv::Mat *)v42);
  cv::getScharrKernels((cv *)v67, (const cv::_OutputArray *)v41, a4, a5, 0, v16);
  if (a7 != 1.0)
  {
    if ((_DWORD)a4)
    {
      cv::_OutputArray::_OutputArray((uint64_t)v67, (cv::Mat *)v42);
      cv::Mat::convertTo((cv::Mat *)v42, (const cv::_OutputArray *)v67, -1, a7, 0.0);
    }
    else
    {
      cv::_OutputArray::_OutputArray((uint64_t)v67, (cv::Mat *)v46);
      cv::Mat::convertTo((cv::Mat *)v46, (const cv::_OutputArray *)v67, -1, a7, 0.0);
    }
  }
  cv::_InputArray::_InputArray((uint64_t)v67, (const cv::Mat *)v59);
  cv::_OutputArray::_OutputArray((uint64_t)v41, (cv::Mat *)v50);
  cv::_InputArray::_InputArray((uint64_t)v40, (const cv::Mat *)v46);
  cv::_InputArray::_InputArray((uint64_t)v39, (const cv::Mat *)v42);
  v38 = -1;
  cv::sepFilter2D(v67, (uint64_t)v41, v13, v40, v39, &v38, a6, a8);
  v18 = (unsigned int *)*((_QWORD *)&v42[1] + 1);
  if (*((_QWORD *)&v42[1] + 1))
  {
    do
    {
      v19 = __ldaxr(v18);
      v20 = v19 - 1;
    }
    while (__stlxr(v20, v18));
    if (!v20)
      cv::Mat::deallocate((cv::Mat *)v42, v17);
  }
  *(_QWORD *)&v42[1] = 0;
  memset(&v42[2], 0, 24);
  if (SDWORD1(v42[0]) >= 1)
  {
    v21 = 0;
    v22 = v43;
    do
      *(_DWORD *)&v22[4 * v21++] = 0;
    while (v21 < SDWORD1(v42[0]));
  }
  *((_QWORD *)&v42[1] + 1) = 0;
  if (v44 != (cv *)v45)
    cv::fastFree((void **)v44, v17);
  v23 = (unsigned int *)*((_QWORD *)&v46[1] + 1);
  if (*((_QWORD *)&v46[1] + 1))
  {
    do
    {
      v24 = __ldaxr(v23);
      v25 = v24 - 1;
    }
    while (__stlxr(v25, v23));
    if (!v25)
      cv::Mat::deallocate((cv::Mat *)v46, v17);
  }
  *(_QWORD *)&v46[1] = 0;
  memset(&v46[2], 0, 24);
  if (SDWORD1(v46[0]) >= 1)
  {
    v26 = 0;
    v27 = v47;
    do
      *(_DWORD *)&v27[4 * v26++] = 0;
    while (v26 < SDWORD1(v46[0]));
  }
  *((_QWORD *)&v46[1] + 1) = 0;
  if (v48 != (cv *)v49)
    cv::fastFree((void **)v48, v17);
  v28 = v51;
  if (v51)
  {
    do
    {
      v29 = __ldaxr(v28);
      v30 = v29 - 1;
    }
    while (__stlxr(v30, v28));
    if (!v30)
      cv::Mat::deallocate((cv::Mat *)v50, v17);
  }
  v50[2] = 0;
  v52 = 0;
  v53 = 0;
  v54 = 0;
  if (SHIDWORD(v50[0]) >= 1)
  {
    v31 = 0;
    v32 = v55;
    do
      *(_DWORD *)(v32 + 4 * v31++) = 0;
    while (v31 < SHIDWORD(v50[0]));
  }
  v51 = 0;
  if (v56 != (cv *)&v57)
    cv::fastFree((void **)v56, v17);
  v33 = v60;
  if (v60)
  {
    do
    {
      v34 = __ldaxr(v33);
      v35 = v34 - 1;
    }
    while (__stlxr(v35, v33));
    if (!v35)
      cv::Mat::deallocate((cv::Mat *)v59, v17);
  }
  v59[2] = 0;
  v61 = 0;
  v62 = 0;
  v63 = 0;
  if (SHIDWORD(v59[0]) >= 1)
  {
    v36 = 0;
    v37 = v64;
    do
      v37->i32[v36++] = 0;
    while (v36 < SHIDWORD(v59[0]));
  }
  v60 = 0;
  if (v65 != (void **)&v66)
    cv::fastFree(v65, v17);
}

void sub_219E49704(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46)
{
  uint64_t v46;
  void *v48;
  void *v49;
  void *v50;

  cv::Mat::~Mat((cv::Mat *)&a22, a2);
  cv::Mat::~Mat((cv::Mat *)&a34, v48);
  cv::Mat::~Mat((cv::Mat *)&a46, v49);
  cv::Mat::~Mat((cv::Mat *)(v46 - 208), v50);
  _Unwind_Resume(a1);
}

void cv::Laplacian(cv *this, const cv::_InputArray *a2, const cv::_OutputArray *a3, int a4, unsigned int a5, double a6, double a7)
{
  int v11;
  void *v13;
  unsigned int *v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  _BYTE *v18;
  void **v19;
  __int16 v20;
  int v21;
  BOOL v22;
  int v23;
  unsigned int v24;
  unsigned int v25;
  __int16 v26;
  unint64_t v27;
  uint64_t v28;
  int v29;
  __int16 v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  int v39;
  cv *v40;
  uint64_t (***v41)(cv::_InputArray *__hidden, int);
  unsigned int *v42;
  unsigned int v43;
  unsigned int v44;
  uint64_t v45;
  uint64_t v46;
  unsigned int *v47;
  unsigned int v48;
  unsigned int v49;
  uint64_t v50;
  int *v51;
  unsigned int *v52;
  unsigned int v53;
  unsigned int v54;
  uint64_t v55;
  _BYTE *v56;
  unsigned int *v57;
  unsigned int v58;
  unsigned int v59;
  unsigned int *v60;
  unsigned int v61;
  unsigned int v62;
  unsigned int *v63;
  unsigned int v64;
  unsigned int v65;
  uint64_t v66;
  uint64_t v67;
  unsigned int *v68;
  unsigned int v69;
  unsigned int v70;
  uint64_t v71;
  _BYTE *v72;
  unsigned int *v73;
  unsigned int v74;
  unsigned int v75;
  uint64_t v76;
  uint64_t v77;
  unsigned int *v78;
  unsigned int v79;
  unsigned int v80;
  uint64_t v81;
  int32x2_t *v82;
  _BYTE v83[64];
  _BYTE *v84;
  cv *v85;
  _QWORD v86[3];
  uint64_t v87;
  uint64_t v88;
  cv *v89;
  uint64_t v90;
  uint64_t v91;
  cv *v92;
  uint64_t v93;
  _BYTE v94[64];
  _BYTE *v95;
  cv *v96;
  __int128 v97;
  _QWORD v98[3];
  unsigned int *v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  cv *v104;
  uint64_t v105;
  int32x2_t v106;
  uint64_t v107;
  int v108;
  int v109;
  uint64_t v110;
  unsigned int *v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  int32x2_t *v115;
  cv *v116;
  uint64_t v117;
  _BYTE v118[32];
  _QWORD v119[4];
  _DWORD v120[8];
  int v121[4];
  __int128 v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  cv *v127;
  uint64_t v128;
  int v129[16];
  int *v130;
  cv *v131;
  _QWORD v132[2];
  _OWORD v133[4];
  uint64_t v134;
  void **v135;
  _QWORD v136[6];

  v11 = (int)a3;
  v136[3] = *MEMORY[0x24BDAC8D0];
  (**(void (***)(uint64_t *__return_ptr, cv *, uint64_t))this)(&v107, this, 0xFFFFFFFFLL);
  if (v11 < 0)
    v11 = v107 & 7;
  v106 = vrev64_s32(*v115);
  (*(void (**)(const cv::_InputArray *, int32x2_t *, uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 128))(a2, &v106, v107 & 0xFF8 | v11 & 7, 0xFFFFFFFFLL, 0, 0);
  (**(void (***)(_QWORD *__return_ptr, const cv::_InputArray *, uint64_t))a2)(v98, a2, 0xFFFFFFFFLL);
  if ((a4 | 2) == 3)
  {
    v134 = 0x4000000000000000;
    v133[0] = xmmword_219EA0AA0;
    v133[1] = unk_219EA0AB0;
    v133[2] = xmmword_219EA0AC0;
    v133[3] = unk_219EA0AD0;
    *(_QWORD *)&v94[16] = (char *)v133 + 36 * (a4 == 3);
    *(_QWORD *)&v94[24] = 0;
    v95 = &v94[8];
    v96 = (cv *)&v97;
    *(_OWORD *)v94 = xmmword_219EA0A80;
    v97 = xmmword_219EA0A90;
    *(_OWORD *)&v94[48] = (unint64_t)(*(_QWORD *)&v94[16] + 36);
    *(_QWORD *)&v94[32] = *(_QWORD *)&v94[16];
    *(_QWORD *)&v94[40] = *(_QWORD *)&v94[16] + 36;
    if (a6 != 1.0)
    {
      cv::_OutputArray::_OutputArray((uint64_t)v83, (cv::Mat *)v94);
      cv::Mat::convertTo((cv::Mat *)v94, (const cv::_OutputArray *)v83, -1, a6, 0.0);
    }
    cv::_InputArray::_InputArray((uint64_t)v83, (const cv::Mat *)&v107);
    cv::_OutputArray::_OutputArray((uint64_t)v129, (cv::Mat *)v98);
    cv::_InputArray::_InputArray((uint64_t)v121, (const cv::Mat *)v94);
    v93 = -1;
    cv::filter2D((void (***)(_QWORD *__return_ptr, _QWORD, uint64_t))v83, (uint64_t)v129, v11, (void (***)(uint64_t *__return_ptr, _QWORD, uint64_t))v121, &v93, a5, a7);
    v14 = *(unsigned int **)&v94[24];
    if (*(_QWORD *)&v94[24])
    {
      do
      {
        v15 = __ldaxr(v14);
        v16 = v15 - 1;
      }
      while (__stlxr(v16, v14));
      if (!v16)
        cv::Mat::deallocate((cv::Mat *)v94, v13);
    }
    *(_QWORD *)&v94[16] = 0;
    memset(&v94[32], 0, 24);
    if (*(int *)&v94[4] >= 1)
    {
      v17 = 0;
      v18 = v95;
      do
        *(_DWORD *)&v18[4 * v17++] = 0;
      while (v17 < *(int *)&v94[4]);
    }
    *(_QWORD *)&v94[24] = 0;
    v19 = (void **)v96;
    if (v96 != (cv *)&v97)
LABEL_97:
      cv::fastFree(v19, v13);
  }
  else
  {
    v20 = v107;
    v95 = &v94[8];
    v96 = (cv *)&v97;
    if ((v107 & 7u) < 6)
      v21 = 5;
    else
      v21 = 6;
    v97 = 0uLL;
    v22 = (v107 & 7) == 0 && a4 < 6;
    *(_DWORD *)v94 = 1124007936;
    *(_OWORD *)&v94[4] = 0u;
    if (v22)
      v23 = 3;
    else
      v23 = v21;
    *(_OWORD *)&v94[20] = 0uLL;
    if (v11 <= (v107 & 7))
      v24 = v107 & 7;
    else
      v24 = v11;
    *(_OWORD *)&v94[36] = 0uLL;
    if (v24 <= 5)
      v25 = 5;
    else
      v25 = v24;
    *(_OWORD *)&v94[48] = 0uLL;
    v134 = (uint64_t)v133 + 8;
    v135 = (void **)v136;
    v136[0] = 0;
    v136[1] = 0;
    LODWORD(v133[0]) = 1124007936;
    memset((char *)v133 + 4, 0, 60);
    cv::_OutputArray::_OutputArray((uint64_t)v83, (cv::Mat *)v94);
    cv::_OutputArray::_OutputArray((uint64_t)v129, (cv::Mat *)v133);
    cv::getSobelKernels((cv *)v83, (const cv::_OutputArray *)v129, (const cv::_OutputArray *)2, 0, a4, 0, v25);
    v26 = v107;
    v27 = 0x4000uLL
        / ((int)((((v107 >> 3) & 0x1FF) + 1) << ((0xFA50u >> (2 * (v107 & 7))) & 3))
         * (uint64_t)v109);
    if (v27 <= 1)
      LODWORD(v27) = 1;
    if (v108 >= (int)v27)
      v28 = v27;
    else
      v28 = v108;
    cv::_InputArray::_InputArray((uint64_t)v83, (const cv::Mat *)v94);
    cv::_InputArray::_InputArray((uint64_t)v129, (const cv::Mat *)v133);
    v29 = v23 | v20 & 0xFF8;
    v90 = -1;
    *(_OWORD *)v121 = 0u;
    v122 = 0u;
    cv::createSeparableLinearFilter(v26 & 0xFFF, v29, (void (***)(uint64_t *__return_ptr, _QWORD, uint64_t))v83, (void (***)(uint64_t *__return_ptr, _QWORD, uint64_t))v129, (int *)&v90, a5, a5, (uint64_t)v121, &v91, 0.0);
    v30 = v107;
    cv::_InputArray::_InputArray((uint64_t)v83, (const cv::Mat *)v133);
    cv::_InputArray::_InputArray((uint64_t)v129, (const cv::Mat *)v94);
    v87 = -1;
    *(_OWORD *)v121 = 0u;
    v122 = 0u;
    cv::createSeparableLinearFilter(v30 & 0xFFF, v29, (void (***)(uint64_t *__return_ptr, _QWORD, uint64_t))v83, (void (***)(uint64_t *__return_ptr, _QWORD, uint64_t))v129, (int *)&v87, a5, a5, (uint64_t)v121, &v88, 0.0);
    *(_OWORD *)v83 = xmmword_219E9E130;
    v31 = (*(uint64_t (**)(uint64_t, uint64_t *, _BYTE *, _QWORD, uint64_t))(*(_QWORD *)v91 + 24))(v91, &v107, v83, 0, 0xFFFFFFFFLL);
    *(_OWORD *)v83 = xmmword_219E9E130;
    (*(void (**)(uint64_t, uint64_t *, _BYTE *, _QWORD, uint64_t))(*(_QWORD *)v88 + 24))(v88, &v107, v83, 0, 0xFFFFFFFFLL);
    v32 = v110;
    v33 = v117;
    v84 = &v83[8];
    v85 = (cv *)v86;
    v86[0] = 0;
    v86[1] = 0;
    *(_DWORD *)v83 = 1124007936;
    memset(&v83[4], 0, 60);
    v129[0] = v28 - 1 + *(_DWORD *)&v94[8];
    v129[1] = v109;
    cv::Mat::create((cv::Mat *)v83, (cv::Mat *)2, v129, v29);
    v130 = &v129[2];
    v131 = (cv *)v132;
    v132[1] = 0;
    v132[0] = 0;
    v129[0] = 1124007936;
    memset(&v129[1], 0, 60);
    v121[0] = v28 - 1 + *(_DWORD *)&v94[8];
    v121[1] = v109;
    cv::Mat::create((cv::Mat *)v129, (cv::Mat *)2, v121, v29);
    if (v108 >= 1)
    {
      v34 = 0;
      v35 = v26 & 0xFF8 | v11 & 7;
      v36 = v32 + v33 * v31;
      v37 = v117;
      do
      {
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)v91 + 32))(v91, v36, v37, v28, *(_QWORD *)&v83[16], LODWORD(v86[0]));
        v38 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, _QWORD, _QWORD))(*(_QWORD *)v88 + 32))(v88, v36, v117, v28, *(_QWORD *)&v129[4], LODWORD(v132[0]));
        v39 = v38;
        if (v38 <= 0)
        {
          v34 += v38;
        }
        else
        {
          v120[0] = v34;
          v120[1] = v38 + v34;
          v119[0] = 0x7FFFFFFF80000000;
          cv::Mat::Mat(v121, v98, v120, v119);
          v129[2] = v39;
          *(_DWORD *)&v83[8] = v39;
          cv::_InputArray::_InputArray((uint64_t)v120, (const cv::Mat *)v83);
          cv::_InputArray::_InputArray((uint64_t)v119, (const cv::Mat *)v129);
          v40 = (cv *)cv::_OutputArray::_OutputArray((uint64_t)v118, (cv::Mat *)v83);
          v41 = cv::noArray(v40);
          cv::add((uint64_t)v120, (uint64_t)v119, (const cv::_InputArray *)v118, (const cv::_OutputArray *)v41, (const cv::_InputArray *)0xFFFFFFFFLL);
          cv::_OutputArray::_OutputArray((uint64_t)v120, (cv::Mat *)v121);
          cv::Mat::convertTo((cv::Mat *)v83, (const cv::_OutputArray *)v120, v35, a6, a7);
          v42 = (unsigned int *)*((_QWORD *)&v122 + 1);
          if (*((_QWORD *)&v122 + 1))
          {
            do
            {
              v43 = __ldaxr(v42);
              v44 = v43 - 1;
            }
            while (__stlxr(v44, v42));
            if (!v44)
              cv::Mat::deallocate((cv::Mat *)v121, v13);
          }
          *(_QWORD *)&v122 = 0;
          v124 = 0;
          v125 = 0;
          v123 = 0;
          if (v121[1] >= 1)
          {
            v45 = 0;
            v46 = v126;
            do
              *(_DWORD *)(v46 + 4 * v45++) = 0;
            while (v45 < v121[1]);
          }
          *((_QWORD *)&v122 + 1) = 0;
          if (v127 != (cv *)&v128)
            cv::fastFree((void **)v127, v13);
          v34 += v39;
        }
        v37 = v117;
        v36 += v117 * (int)v28;
      }
      while (v34 < v108);
    }
    v47 = *(unsigned int **)&v129[6];
    if (*(_QWORD *)&v129[6])
    {
      do
      {
        v48 = __ldaxr(v47);
        v49 = v48 - 1;
      }
      while (__stlxr(v49, v47));
      if (!v49)
        cv::Mat::deallocate((cv::Mat *)v129, v13);
    }
    *(_QWORD *)&v129[4] = 0;
    memset(&v129[8], 0, 24);
    if (v129[1] >= 1)
    {
      v50 = 0;
      v51 = v130;
      do
        v51[v50++] = 0;
      while (v50 < v129[1]);
    }
    *(_QWORD *)&v129[6] = 0;
    if (v131 != (cv *)v132)
      cv::fastFree((void **)v131, v13);
    v52 = *(unsigned int **)&v83[24];
    if (*(_QWORD *)&v83[24])
    {
      do
      {
        v53 = __ldaxr(v52);
        v54 = v53 - 1;
      }
      while (__stlxr(v54, v52));
      if (!v54)
        cv::Mat::deallocate((cv::Mat *)v83, v13);
    }
    *(_QWORD *)&v83[16] = 0;
    memset(&v83[32], 0, 24);
    if (*(int *)&v83[4] >= 1)
    {
      v55 = 0;
      v56 = v84;
      do
        *(_DWORD *)&v56[4 * v55++] = 0;
      while (v55 < *(int *)&v83[4]);
    }
    *(_QWORD *)&v83[24] = 0;
    if (v85 != (cv *)v86)
      cv::fastFree((void **)v85, v13);
    v57 = (unsigned int *)v89;
    if (v89)
    {
      do
      {
        v58 = __ldaxr(v57);
        v59 = v58 - 1;
      }
      while (__stlxr(v59, v57));
      if (!v59)
      {
        if (v88)
          (*(void (**)(uint64_t))(*(_QWORD *)v88 + 8))(v88);
        cv::fastFree((void **)v89, v13);
      }
    }
    v60 = (unsigned int *)v92;
    if (v92)
    {
      do
      {
        v61 = __ldaxr(v60);
        v62 = v61 - 1;
      }
      while (__stlxr(v62, v60));
      if (!v62)
      {
        if (v91)
          (*(void (**)(uint64_t))(*(_QWORD *)v91 + 8))(v91);
        cv::fastFree((void **)v92, v13);
      }
    }
    v63 = (unsigned int *)*((_QWORD *)&v133[1] + 1);
    if (*((_QWORD *)&v133[1] + 1))
    {
      do
      {
        v64 = __ldaxr(v63);
        v65 = v64 - 1;
      }
      while (__stlxr(v65, v63));
      if (!v65)
        cv::Mat::deallocate((cv::Mat *)v133, v13);
    }
    *(_QWORD *)&v133[1] = 0;
    memset(&v133[2], 0, 24);
    if (SDWORD1(v133[0]) >= 1)
    {
      v66 = 0;
      v67 = v134;
      do
        *(_DWORD *)(v67 + 4 * v66++) = 0;
      while (v66 < SDWORD1(v133[0]));
    }
    *((_QWORD *)&v133[1] + 1) = 0;
    if (v135 != v136)
      cv::fastFree(v135, v13);
    v68 = *(unsigned int **)&v94[24];
    if (*(_QWORD *)&v94[24])
    {
      do
      {
        v69 = __ldaxr(v68);
        v70 = v69 - 1;
      }
      while (__stlxr(v70, v68));
      if (!v70)
        cv::Mat::deallocate((cv::Mat *)v94, v13);
    }
    *(_QWORD *)&v94[16] = 0;
    memset(&v94[32], 0, 24);
    if (*(int *)&v94[4] >= 1)
    {
      v71 = 0;
      v72 = v95;
      do
        *(_DWORD *)&v72[4 * v71++] = 0;
      while (v71 < *(int *)&v94[4]);
    }
    *(_QWORD *)&v94[24] = 0;
    v19 = (void **)v96;
    if (v96 != (cv *)&v97)
      goto LABEL_97;
  }
  v73 = v99;
  if (v99)
  {
    do
    {
      v74 = __ldaxr(v73);
      v75 = v74 - 1;
    }
    while (__stlxr(v75, v73));
    if (!v75)
      cv::Mat::deallocate((cv::Mat *)v98, v13);
  }
  v98[2] = 0;
  v100 = 0;
  v101 = 0;
  v102 = 0;
  if (SHIDWORD(v98[0]) >= 1)
  {
    v76 = 0;
    v77 = v103;
    do
      *(_DWORD *)(v77 + 4 * v76++) = 0;
    while (v76 < SHIDWORD(v98[0]));
  }
  v99 = 0;
  if (v104 != (cv *)&v105)
    cv::fastFree((void **)v104, v13);
  v78 = v111;
  if (v111)
  {
    do
    {
      v79 = __ldaxr(v78);
      v80 = v79 - 1;
    }
    while (__stlxr(v80, v78));
    if (!v80)
      cv::Mat::deallocate((cv::Mat *)&v107, v13);
  }
  v110 = 0;
  v112 = 0;
  v113 = 0;
  v114 = 0;
  if (SHIDWORD(v107) >= 1)
  {
    v81 = 0;
    v82 = v115;
    do
      v82->i32[v81++] = 0;
    while (v81 < SHIDWORD(v107));
  }
  v111 = 0;
  if (v116 != (cv *)&v117)
    cv::fastFree((void **)v116, v13);
}

void sub_219E4A168(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

const cv::Mat **cv::mixChannels(cv *this, const cv::Mat *a2, unint64_t a3, cv::Mat *a4, unint64_t a5, const int *a6)
{
  const cv::Mat **result;
  uint64_t v7;
  const cv::Mat *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const cv::Exception *v14;
  int v15;
  const cv::Mat **v16;
  unint64_t v17;
  const cv::Mat **v18;
  unsigned __int8 **v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  const cv::Mat **v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  const cv::Mat *v28;
  uint64_t v29;
  uint64_t v30;
  int *v31;
  int v32;
  int v33;
  uint64_t v34;
  unsigned int *v35;
  char v36;
  unsigned int v37;
  int v38;
  int v39;
  _DWORD *v40;
  const cv::Exception *v41;
  _DWORD *v42;
  uint64_t v43;
  uint64_t v44;
  unsigned int *v45;
  char v46;
  unsigned int v47;
  int v48;
  const cv::Exception *v49;
  unint64_t v50;
  int v51;
  int v52;
  unint64_t v53;
  char *v54;
  int *v55;
  _QWORD *v56;
  unint64_t v57;
  int v58;
  uint64_t v59;
  uint64_t i;
  cv::Mat **v62;
  int v63[2];
  uint64_t v64;
  uint64_t v65;
  unsigned int *v66;
  uint64_t v67;
  const cv::Mat *v68;
  unint64_t v69;
  uint64_t v70;
  uint64_t v71;
  char *v72;
  uint64_t v73;
  uint64_t (*v74)(cv *__hidden, const unsigned __int8 **, const int *, unsigned __int8 **, const int *, int, int);
  unint64_t v75;
  void *v76[2];
  void *v77[5];
  int v78;
  void *__p[2];
  void *v80[2];
  const cv::Mat **v81;
  uint64_t v82;
  _QWORD v83[517];

  result = (const cv::Mat **)MEMORY[0x24BDAC7A8](this, a2);
  v67 = v10;
  v68 = v8;
  v71 = v7;
  v83[515] = *MEMORY[0x24BDAC8D0];
  if (v11)
  {
    v12 = v11;
    v13 = (uint64_t)result;
    v65 = v9;
    if (!result || !v7 || !v8 || !v9 || !v10)
    {
      std::string::basic_string[abi:ne180100]<0>(v77, "src && nsrcs > 0 && dst && ndsts > 0 && fromTo && npairs > 0");
      std::string::basic_string[abi:ne180100]<0>(v80, "mixChannels");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/convert.cpp");
      cv::Exception::Exception(&v81, 4294967081, v77, v80, __p, 460);
      cv::error((cv *)&v81, v14);
    }
    v15 = *(_DWORD *)v8;
    *(_QWORD *)v63 = v9 + v7;
    v81 = (const cv::Mat **)v83;
    v82 = 4104;
    v16 = (const cv::Mat **)v83;
    if (40 * v11 + 16 * (v9 + v7) + 16 >= 0x1009)
    {
      v82 = 40 * v11 + 16 * (v9 + v7) + 16;
      v16 = (const cv::Mat **)operator new[]();
      v81 = v16;
    }
    v17 = (0x88442211uLL >> (4 * (v15 & 7u))) & 0xF;
    v18 = &v16[v71];
    v19 = (unsigned __int8 **)&v18[v65];
    v20 = (uint64_t)&(&v19[v71])[v65];
    v21 = v20 + 8 + 8 * v12;
    v69 = v21 + 8 * v12;
    v22 = v69 + 16 * v12;
    v23 = v13;
    v24 = v16;
    v25 = v71;
    do
    {
      *v24++ = (const cv::Mat *)v23;
      v23 += 96;
      --v25;
    }
    while (v25);
    v62 = v16;
    v66 = (unsigned int *)v13;
    v64 = v15 & 7;
    v26 = v22 + 4 * v12;
    v27 = v65;
    if (v65)
    {
      v28 = v68;
      v29 = v65;
      do
      {
        *v18++ = v28;
        v28 = (const cv::Mat *)((char *)v28 + 96);
        --v29;
      }
      while (v29);
    }
    v30 = 0;
    v19[*(_QWORD *)v63] = 0;
    v75 = v12;
    if (v12 <= 1)
      v12 = 1;
    do
    {
      v31 = (int *)(v67 + 8 * v30);
      v32 = *v31;
      v33 = v31[1];
      v73 = v30;
      if (*v31 < 0)
      {
        v39 = 0;
        v40 = (_DWORD *)(v69 + 16 * v30);
        *v40 = v63[0];
        v40[1] = 0;
      }
      else
      {
        v34 = 0;
        v35 = v66;
        while (1)
        {
          v37 = *v35;
          v35 += 24;
          v36 = v37;
          v38 = (v37 >> 3) & 0x1FF;
          if (v32 <= v38)
            break;
          v32 += ~v38;
          if (v71 == ++v34)
            goto LABEL_24;
        }
        if ((v36 & 7) != (_DWORD)v64)
        {
LABEL_24:
          std::string::basic_string[abi:ne180100]<0>(v80, "j < nsrcs && src[j].depth() == depth");
          std::string::basic_string[abi:ne180100]<0>(__p, "mixChannels");
          std::string::basic_string[abi:ne180100]<0>(v76, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/convert.cpp");
          cv::Exception::Exception(v77, 4294967081, v80, __p, v76, 487);
          cv::error((cv *)v77, v41);
        }
        v30 = v73;
        v42 = (_DWORD *)(v69 + 16 * v73);
        *v42 = v34;
        v42[1] = v32 * v17;
        v43 = 24 * v34;
        v27 = v65;
        v39 = ((v66[v43] >> 3) & 0x1FF) + 1;
      }
      *(_DWORD *)(v22 + 4 * v30) = v39;
      v44 = 0;
      if (!v27)
        goto LABEL_33;
      v45 = (unsigned int *)v68;
      while (1)
      {
        v47 = *v45;
        v45 += 24;
        v46 = v47;
        v48 = (v47 >> 3) & 0x1FF;
        if (v33 <= v48)
          break;
        v33 += ~v48;
        if (v27 == ++v44)
          goto LABEL_33;
      }
      if (v33 < 0 || (v46 & 7) != (_DWORD)v64)
      {
LABEL_33:
        std::string::basic_string[abi:ne180100]<0>(v80, "i1 >= 0 && j < ndsts && dst[j].depth() == depth");
        std::string::basic_string[abi:ne180100]<0>(__p, "mixChannels");
        std::string::basic_string[abi:ne180100]<0>(v76, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/convert.cpp");
        cv::Exception::Exception(v77, 4294967081, v80, __p, v76, 500);
        cv::error((cv *)v77, v49);
      }
      v50 = v69 + 16 * v73;
      *(_DWORD *)(v50 + 8) = v44 + v71;
      *(_DWORD *)(v50 + 12) = v33 * v17;
      *(_DWORD *)(v26 + 4 * v73) = ((*((_DWORD *)v68 + 24 * v44) >> 3) & 0x1FF) + 1;
      v30 = v73 + 1;
    }
    while (v73 + 1 != v12);
    cv::NAryMatIterator::NAryMatIterator((cv::NAryMatIterator *)v77, v16, v19, v63[0]);
    v51 = v78;
    v74 = cv::getMixchFunc(int)::mixchTab[v64];
    if ((int)((v17 + 1023) / v17) >= v78)
      v52 = v78;
    else
      v52 = (v17 + 1023) / v17;
    v53 = v75;
    v54 = 0;
    v70 = (uint64_t)&v62[2 * v65 + 1] + 16 * v71 + 16 * v75 + 4;
    while (1)
    {
      v55 = (int *)v70;
      v56 = (_QWORD *)(v20 + 8);
      v57 = v12;
      if (v54 >= v77[4])
        break;
      do
      {
        *v56 = &v19[*(v55 - 1)][*v55];
        v56[v53] = &v19[v55[1]][v55[2]];
        ++v56;
        v55 += 4;
        --v57;
      }
      while (v57);
      v72 = v54;
      if (v51 >= 1)
      {
        v58 = 0;
        do
        {
          if (v52 >= v51 - v58)
            v59 = (v51 - v58);
          else
            v59 = v52;
          ((void (*)(uint64_t, unint64_t, uint64_t, unint64_t, uint64_t, unint64_t))v74)(v20 + 8, v22, v21, v26, v59, v75);
          v58 += v52;
          if (v58 >= v51)
            break;
          for (i = 0; i != v12; ++i)
          {
            *(_QWORD *)(v20 + 8 * i + 8) += v17 * *(int *)(v22 + 4 * i) * (uint64_t)v52;
            *(_QWORD *)(v21 + 8 * i) += v17 * *(int *)(v26 + 4 * i) * (uint64_t)v52;
          }
        }
        while (v58 < v51);
      }
      v54 = v72 + 1;
      cv::NAryMatIterator::operator++((uint64_t)v77);
      v53 = v75;
    }
    result = v81;
    if (v81 != v83 && v81 != 0)
      return (const cv::Mat **)MEMORY[0x2207351A4]();
  }
  return result;
}

void sub_219E4A8B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,void *__p,uint64_t a47,int a48,__int16 a49,char a50,char a51,void *a52,uint64_t a53,int a54,__int16 a55,char a56,char a57,uint64_t a58)
{
  cv::Exception::~Exception((cv::Exception *)&a58);
  if (a51 < 0)
    operator delete(__p);
  if (a57 < 0)
    operator delete(a52);
  if (a33 < 0)
    operator delete(a28);
  _Unwind_Resume(a1);
}

uint64_t cv::getConvertFunc(cv *this, char a2)
{
  return (uint64_t)*(&cv::getConvertFunc(int,int)::cvtTab + 8 * (unint64_t)(a2 & 7) + (this & 7));
}

char *cv::cvt8u(char *__src, uint64_t a2, int a3, int a4, char *__dst, uint64_t a6, int *a7)
{
  int v7;
  char *v11;
  size_t v12;

  v7 = a7[1];
  if (v7)
  {
    v11 = __src;
    v12 = *a7;
    do
    {
      --v7;
      __src = (char *)memcpy(__dst, v11, v12);
      v11 += a2;
      __dst += a6;
    }
    while (v7);
  }
  return __src;
}

uint64_t cv::cvt8s8u(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  _BYTE *v11;
  int v12;

  v7 = a7[1];
  if (v7)
  {
    v8 = *a7;
    do
    {
      if ((int)v8 >= 4)
      {
        v9 = 0;
        do
        {
          v10 = *(char *)(result + v9 + 1) & ~(*(char *)(result + v9 + 1) >> 31);
          v11 = (_BYTE *)(a5 + v9);
          *v11 = *(_BYTE *)(result + v9) & ~(*(char *)(result + v9) >> 7);
          v11[1] = v10;
          v12 = *(char *)(result + v9 + 3) & ~(*(char *)(result + v9 + 3) >> 31);
          v11[2] = *(_BYTE *)(result + v9 + 2) & ~(*(char *)(result + v9 + 2) >> 31);
          v11[3] = v12;
          v9 += 4;
        }
        while (v9 <= v8 - 4);
        v9 = v9;
      }
      else
      {
        v9 = 0;
      }
      if ((int)v9 < (int)v8)
      {
        do
        {
          *(_BYTE *)(a5 + v9) = *(_BYTE *)(result + v9) & ~(*(char *)(result + v9) >> 31);
          ++v9;
        }
        while (v9 < v8);
      }
      result += a2;
      a5 += a6;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t cv::cvt16u8u(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7)
{
  int v7;
  uint64_t v8;
  unsigned __int16 *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int16 *v12;
  unsigned int v13;
  unsigned int v14;
  _BYTE *v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;

  v7 = a7[1];
  if (v7)
  {
    v8 = *a7;
    v9 = (unsigned __int16 *)(result + 4);
    v10 = 2 * (a2 >> 1);
    do
    {
      if ((int)v8 >= 4)
      {
        v11 = 0;
        v12 = v9;
        do
        {
          v13 = *(v12 - 2);
          if (v13 >= 0xFF)
            LOBYTE(v13) = -1;
          v14 = *(v12 - 1);
          if (v14 >= 0xFF)
            LOBYTE(v14) = -1;
          v15 = (_BYTE *)(a5 + v11);
          *v15 = v13;
          v15[1] = v14;
          v16 = *v12;
          if (v16 >= 0xFF)
            LOBYTE(v16) = -1;
          v17 = v12[1];
          if (v17 >= 0xFF)
            LOBYTE(v17) = -1;
          v15[2] = v16;
          v15[3] = v17;
          v11 += 4;
          v12 += 4;
        }
        while (v11 <= v8 - 4);
        v11 = v11;
      }
      else
      {
        v11 = 0;
      }
      if ((int)v11 < (int)v8)
      {
        do
        {
          v18 = *(unsigned __int16 *)(result + 2 * v11);
          if (v18 >= 0xFF)
            LOBYTE(v18) = -1;
          *(_BYTE *)(a5 + v11++) = v18;
        }
        while (v11 < v8);
      }
      a5 += a6;
      v9 = (unsigned __int16 *)((char *)v9 + v10);
      result += v10;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t cv::cvt16s8u(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7)
{
  int v7;
  uint64_t v8;
  __int16 *v9;
  uint64_t v10;
  uint64_t v11;
  __int16 *v12;
  _BYTE *v13;
  int32x2_t v14;
  int32x2_t v15;
  int32x2_t v16;
  int v17;

  v7 = a7[1];
  if (v7)
  {
    v8 = *a7;
    v9 = (__int16 *)(result + 4);
    v10 = 2 * (a2 >> 1);
    do
    {
      if ((int)v8 >= 4)
      {
        v11 = 0;
        v12 = v9;
        do
        {
          v13 = (_BYTE *)(a5 + v11);
          v14.i32[0] = *(v12 - 2);
          v14.i32[1] = *(v12 - 1);
          v15 = vmin_s32(vmax_s32(v14, 0), (int32x2_t)0xFF000000FFLL);
          v13[1] = v15.i8[4];
          *v13 = v15.i8[0];
          v15.i32[0] = *v12;
          v15.i32[1] = v12[1];
          v16 = vmin_s32(vmax_s32(v15, 0), (int32x2_t)0xFF000000FFLL);
          v13[3] = v16.i8[4];
          v13[2] = v16.i8[0];
          v11 += 4;
          v12 += 4;
        }
        while (v11 <= v8 - 4);
        v11 = v11;
      }
      else
      {
        v11 = 0;
      }
      if ((int)v11 < (int)v8)
      {
        do
        {
          v17 = *(__int16 *)(result + 2 * v11) & ~(*(__int16 *)(result + 2 * v11) >> 31);
          if (v17 >= 255)
            LOBYTE(v17) = -1;
          *(_BYTE *)(a5 + v11++) = v17;
        }
        while (v11 < v8);
      }
      a5 += a6;
      v9 = (__int16 *)((char *)v9 + v10);
      result += v10;
      --v7;
    }
    while (v7);
  }
  return result;
}

int32x2_t *cv::cvt32s8u(int32x2_t *result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7)
{
  int v7;
  uint64_t v8;
  int32x2_t *v9;
  uint64_t v10;
  uint64_t v11;
  int32x2_t *v12;
  _BYTE *v13;
  int32x2_t v14;
  int32x2_t v15;
  int32x2_t v16;
  int v17;

  v7 = a7[1];
  if (v7)
  {
    v8 = *a7;
    v9 = result + 1;
    v10 = 4 * (a2 >> 2);
    do
    {
      if ((int)v8 >= 4)
      {
        v11 = 0;
        v12 = v9;
        do
        {
          v13 = (_BYTE *)(a5 + v11);
          v14 = vmin_s32(vmax_s32(v12[-1], 0), (int32x2_t)0xFF000000FFLL);
          v13[1] = v14.i8[4];
          *v13 = v14.i8[0];
          v15 = *v12;
          v12 += 2;
          v16 = vmin_s32(vmax_s32(v15, 0), (int32x2_t)0xFF000000FFLL);
          v13[3] = v16.i8[4];
          v13[2] = v16.i8[0];
          v11 += 4;
        }
        while (v11 <= v8 - 4);
        v11 = v11;
      }
      else
      {
        v11 = 0;
      }
      if ((int)v11 < (int)v8)
      {
        do
        {
          v17 = result->i32[v11] & ~(result->i32[v11] >> 31);
          if (v17 >= 255)
            LOBYTE(v17) = -1;
          *(_BYTE *)(a5 + v11++) = v17;
        }
        while (v11 < v8);
      }
      a5 += a6;
      v9 = (int32x2_t *)((char *)v9 + v10);
      result = (int32x2_t *)((char *)result + v10);
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t cv::cvt32f8u(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE *v13;
  int32x2_t v14;
  float v15;
  int32x2_t v16;
  double v17;
  int v18;

  v7 = a7[1];
  if (v7)
  {
    v8 = *a7;
    v9 = result + 8;
    v10 = 4 * (a2 >> 2);
    do
    {
      if ((int)v8 >= 4)
      {
        v11 = 0;
        v12 = v9;
        do
        {
          v13 = (_BYTE *)(a5 + v11);
          v14 = vmin_s32(vmax_s32((int32x2_t)__PAIR64__((uint64_t)rint(*(float *)(v12 - 4)), (uint64_t)rint(*(float *)(v12 - 8))), 0), (int32x2_t)0xFF000000FFLL);
          v13[1] = v14.i8[4];
          *v13 = v14.i8[0];
          v14.i32[0] = *(_DWORD *)v12;
          v15 = *(float *)(v12 + 4);
          v12 += 16;
          v16 = vmin_s32(vmax_s32((int32x2_t)__PAIR64__((uint64_t)rint(v15), (uint64_t)rint(*(float *)v14.i32)), 0), (int32x2_t)0xFF000000FFLL);
          v13[3] = v16.i8[4];
          v13[2] = v16.i8[0];
          v11 += 4;
        }
        while (v11 <= v8 - 4);
        v11 = v11;
      }
      else
      {
        v11 = 0;
      }
      if ((int)v11 < (int)v8)
      {
        do
        {
          v17 = rint(*(float *)(result + 4 * v11));
          v18 = (uint64_t)v17 & ~((int)(uint64_t)v17 >> 31);
          if (v18 >= 255)
            LOBYTE(v18) = -1;
          *(_BYTE *)(a5 + v11++) = v18;
        }
        while (v11 < v8);
      }
      a5 += a6;
      v9 += v10;
      result += v10;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t cv::cvt64f8u(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7)
{
  int v7;
  uint64_t v8;
  double *v9;
  uint64_t v10;
  uint64_t v11;
  double *v12;
  _BYTE *v13;
  int32x2_t v14;
  double v15;
  double v16;
  int32x2_t v17;
  double v18;
  int v19;

  v7 = a7[1];
  if (v7)
  {
    v8 = *a7;
    v9 = (double *)(result + 16);
    v10 = 8 * (a2 >> 3);
    do
    {
      if ((int)v8 >= 4)
      {
        v11 = 0;
        v12 = v9;
        do
        {
          v13 = (_BYTE *)(a5 + v11);
          v14 = vmin_s32(vmax_s32((int32x2_t)__PAIR64__((uint64_t)rint(*(v12 - 1)), (uint64_t)rint(*(v12 - 2))), 0), (int32x2_t)0xFF000000FFLL);
          v13[1] = v14.i8[4];
          *v13 = v14.i8[0];
          v15 = *v12;
          v16 = v12[1];
          v12 += 4;
          v17 = vmin_s32(vmax_s32((int32x2_t)__PAIR64__((uint64_t)rint(v16), (uint64_t)rint(v15)), 0), (int32x2_t)0xFF000000FFLL);
          v13[3] = v17.i8[4];
          v13[2] = v17.i8[0];
          v11 += 4;
        }
        while (v11 <= v8 - 4);
        v11 = v11;
      }
      else
      {
        v11 = 0;
      }
      if ((int)v11 < (int)v8)
      {
        do
        {
          v18 = rint(*(double *)(result + 8 * v11));
          v19 = (uint64_t)v18 & ~((int)(uint64_t)v18 >> 31);
          if (v19 >= 255)
            LOBYTE(v19) = -1;
          *(_BYTE *)(a5 + v11++) = v19;
        }
        while (v11 < v8);
      }
      a5 += a6;
      v9 = (double *)((char *)v9 + v10);
      result += v10;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t cv::cvt8u8s(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int8 *v10;
  unsigned int v11;
  unsigned int v12;
  _BYTE *v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;

  v7 = a7[1];
  if (v7)
  {
    v8 = *a7;
    do
    {
      if ((int)v8 >= 4)
      {
        v9 = 0;
        do
        {
          v10 = (unsigned __int8 *)(result + v9);
          v11 = *(unsigned __int8 *)(result + v9);
          if (v11 >= 0x7F)
            LOBYTE(v11) = 127;
          v12 = v10[1];
          if (v12 >= 0x7F)
            LOBYTE(v12) = 127;
          v13 = (_BYTE *)(a5 + v9);
          *v13 = v11;
          v13[1] = v12;
          v14 = v10[2];
          if (v14 >= 0x7F)
            LOBYTE(v14) = 127;
          v15 = v10[3];
          if (v15 >= 0x7F)
            LOBYTE(v15) = 127;
          v13[2] = v14;
          v13[3] = v15;
          v9 += 4;
        }
        while (v9 <= v8 - 4);
        v9 = v9;
      }
      else
      {
        v9 = 0;
      }
      if ((int)v9 < (int)v8)
      {
        do
        {
          v16 = *(unsigned __int8 *)(result + v9);
          if (v16 >= 0x7F)
            LOBYTE(v16) = 127;
          *(_BYTE *)(a5 + v9++) = v16;
        }
        while (v9 < v8);
      }
      result += a2;
      a5 += a6;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t cv::cvt16u8s(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7)
{
  int v7;
  uint64_t v8;
  unsigned __int16 *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int16 *v12;
  unsigned int v13;
  unsigned int v14;
  _BYTE *v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;

  v7 = a7[1];
  if (v7)
  {
    v8 = *a7;
    v9 = (unsigned __int16 *)(result + 4);
    v10 = 2 * (a2 >> 1);
    do
    {
      if ((int)v8 >= 4)
      {
        v11 = 0;
        v12 = v9;
        do
        {
          v13 = *(v12 - 2);
          if (v13 >= 0x7F)
            LOBYTE(v13) = 127;
          v14 = *(v12 - 1);
          if (v14 >= 0x7F)
            LOBYTE(v14) = 127;
          v15 = (_BYTE *)(a5 + v11);
          *v15 = v13;
          v15[1] = v14;
          v16 = *v12;
          if (v16 >= 0x7F)
            LOBYTE(v16) = 127;
          v17 = v12[1];
          if (v17 >= 0x7F)
            LOBYTE(v17) = 127;
          v15[2] = v16;
          v15[3] = v17;
          v11 += 4;
          v12 += 4;
        }
        while (v11 <= v8 - 4);
        v11 = v11;
      }
      else
      {
        v11 = 0;
      }
      if ((int)v11 < (int)v8)
      {
        do
        {
          v18 = *(unsigned __int16 *)(result + 2 * v11);
          if (v18 >= 0x7F)
            LOBYTE(v18) = 127;
          *(_BYTE *)(a5 + v11++) = v18;
        }
        while (v11 < v8);
      }
      a5 += a6;
      v9 = (unsigned __int16 *)((char *)v9 + v10);
      result += v10;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t cv::cvt16s8s(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7)
{
  int v7;
  uint64_t v8;
  __int16 *v9;
  uint64_t v10;
  uint64_t v11;
  __int16 *v12;
  int v13;
  int v14;
  _BYTE *v15;
  int v16;
  int v17;
  int v18;

  v7 = a7[1];
  if (v7)
  {
    v8 = *a7;
    v9 = (__int16 *)(result + 4);
    v10 = 2 * (a2 >> 1);
    do
    {
      if ((int)v8 >= 4)
      {
        v11 = 0;
        v12 = v9;
        do
        {
          v13 = *(v12 - 2);
          if (v13 <= -128)
            v13 = -128;
          if (v13 >= 127)
            LOBYTE(v13) = 127;
          v14 = *(v12 - 1);
          if (v14 <= -128)
            v14 = -128;
          if (v14 >= 127)
            LOBYTE(v14) = 127;
          v15 = (_BYTE *)(a5 + v11);
          *v15 = v13;
          v15[1] = v14;
          v16 = *v12;
          if (v16 <= -128)
            v16 = -128;
          if (v16 >= 127)
            LOBYTE(v16) = 127;
          v17 = v12[1];
          if (v17 <= -128)
            v17 = -128;
          if (v17 >= 127)
            LOBYTE(v17) = 127;
          v15[2] = v16;
          v15[3] = v17;
          v11 += 4;
          v12 += 4;
        }
        while (v11 <= v8 - 4);
        v11 = v11;
      }
      else
      {
        v11 = 0;
      }
      if ((int)v11 < (int)v8)
      {
        do
        {
          v18 = *(__int16 *)(result + 2 * v11);
          if (v18 <= -128)
            v18 = -128;
          if (v18 >= 127)
            LOBYTE(v18) = 127;
          *(_BYTE *)(a5 + v11++) = v18;
        }
        while (v11 < v8);
      }
      a5 += a6;
      v9 = (__int16 *)((char *)v9 + v10);
      result += v10;
      --v7;
    }
    while (v7);
  }
  return result;
}

int32x2_t *cv::cvt32s8s(int32x2_t *result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7)
{
  int v7;
  uint64_t v8;
  int32x2_t *v9;
  uint64_t v10;
  uint64_t v11;
  int32x2_t *v12;
  _BYTE *v13;
  int32x2_t v14;
  int32x2_t v15;
  int32x2_t v16;
  int v17;

  v7 = a7[1];
  if (v7)
  {
    v8 = *a7;
    v9 = result + 1;
    v10 = 4 * (a2 >> 2);
    do
    {
      if ((int)v8 >= 4)
      {
        v11 = 0;
        v12 = v9;
        do
        {
          v13 = (_BYTE *)(a5 + v11);
          v14 = vmin_s32(vmax_s32(v12[-1], (int32x2_t)0x7F0000007FLL), (int32x2_t)0x7F0000007FLL);
          v13[1] = v14.i8[4];
          *v13 = v14.i8[0];
          v15 = *v12;
          v12 += 2;
          v16 = vmin_s32(vmax_s32(v15, (int32x2_t)0x7F0000007FLL), (int32x2_t)0x7F0000007FLL);
          v13[3] = v16.i8[4];
          v13[2] = v16.i8[0];
          v11 += 4;
        }
        while (v11 <= v8 - 4);
        v11 = v11;
      }
      else
      {
        v11 = 0;
      }
      if ((int)v11 < (int)v8)
      {
        do
        {
          v17 = result->i32[v11];
          if (v17 <= -128)
            v17 = -128;
          if (v17 >= 127)
            LOBYTE(v17) = 127;
          *(_BYTE *)(a5 + v11++) = v17;
        }
        while (v11 < v8);
      }
      a5 += a6;
      v9 = (int32x2_t *)((char *)v9 + v10);
      result = (int32x2_t *)((char *)result + v10);
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t cv::cvt32f8s(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE *v13;
  int32x2_t v14;
  float v15;
  int32x2_t v16;
  uint64_t v17;

  v7 = a7[1];
  if (v7)
  {
    v8 = *a7;
    v9 = result + 8;
    v10 = 4 * (a2 >> 2);
    do
    {
      if ((int)v8 >= 4)
      {
        v11 = 0;
        v12 = v9;
        do
        {
          v13 = (_BYTE *)(a5 + v11);
          v14 = vmin_s32(vmax_s32((int32x2_t)__PAIR64__((uint64_t)rint(*(float *)(v12 - 4)), (uint64_t)rint(*(float *)(v12 - 8))), (int32x2_t)0x7F0000007FLL), (int32x2_t)0x7F0000007FLL);
          v13[1] = v14.i8[4];
          *v13 = v14.i8[0];
          v14.i32[0] = *(_DWORD *)v12;
          v15 = *(float *)(v12 + 4);
          v12 += 16;
          v16 = vmin_s32(vmax_s32((int32x2_t)__PAIR64__((uint64_t)rint(v15), (uint64_t)rint(*(float *)v14.i32)), (int32x2_t)0x7F0000007FLL), (int32x2_t)0x7F0000007FLL);
          v13[3] = v16.i8[4];
          v13[2] = v16.i8[0];
          v11 += 4;
        }
        while (v11 <= v8 - 4);
        v11 = v11;
      }
      else
      {
        v11 = 0;
      }
      if ((int)v11 < (int)v8)
      {
        do
        {
          v17 = (uint64_t)rint(*(float *)(result + 4 * v11));
          if ((int)v17 <= -128)
            LODWORD(v17) = -128;
          if ((int)v17 >= 127)
            LOBYTE(v17) = 127;
          *(_BYTE *)(a5 + v11++) = v17;
        }
        while (v11 < v8);
      }
      a5 += a6;
      v9 += v10;
      result += v10;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t cv::cvt64f8s(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7)
{
  int v7;
  uint64_t v8;
  double *v9;
  uint64_t v10;
  uint64_t v11;
  double *v12;
  _BYTE *v13;
  int32x2_t v14;
  double v15;
  double v16;
  int32x2_t v17;
  uint64_t v18;

  v7 = a7[1];
  if (v7)
  {
    v8 = *a7;
    v9 = (double *)(result + 16);
    v10 = 8 * (a2 >> 3);
    do
    {
      if ((int)v8 >= 4)
      {
        v11 = 0;
        v12 = v9;
        do
        {
          v13 = (_BYTE *)(a5 + v11);
          v14 = vmin_s32(vmax_s32((int32x2_t)__PAIR64__((uint64_t)rint(*(v12 - 1)), (uint64_t)rint(*(v12 - 2))), (int32x2_t)0x7F0000007FLL), (int32x2_t)0x7F0000007FLL);
          v13[1] = v14.i8[4];
          *v13 = v14.i8[0];
          v15 = *v12;
          v16 = v12[1];
          v12 += 4;
          v17 = vmin_s32(vmax_s32((int32x2_t)__PAIR64__((uint64_t)rint(v16), (uint64_t)rint(v15)), (int32x2_t)0x7F0000007FLL), (int32x2_t)0x7F0000007FLL);
          v13[3] = v17.i8[4];
          v13[2] = v17.i8[0];
          v11 += 4;
        }
        while (v11 <= v8 - 4);
        v11 = v11;
      }
      else
      {
        v11 = 0;
      }
      if ((int)v11 < (int)v8)
      {
        do
        {
          v18 = (uint64_t)rint(*(double *)(result + 8 * v11));
          if ((int)v18 <= -128)
            LODWORD(v18) = -128;
          if ((int)v18 >= 127)
            LOBYTE(v18) = 127;
          *(_BYTE *)(a5 + v11++) = v18;
        }
        while (v11 < v8);
      }
      a5 += a6;
      v9 = (double *)((char *)v9 + v10);
      result += v10;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t cv::cvt8u16u(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, unsigned int *a7)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  _WORD *v10;
  uint64_t v11;
  uint64_t v12;
  _WORD *v13;
  __int16 v14;
  __int16 v15;

  v7 = a7[1];
  if (v7)
  {
    v8 = (int)*a7;
    v9 = *a7;
    v10 = (_WORD *)(a5 + 4);
    v11 = 2 * (a6 >> 1);
    do
    {
      if ((int)v8 >= 4)
      {
        v12 = 0;
        v13 = v10;
        do
        {
          v14 = *(unsigned __int8 *)(result + v12 + 1);
          *(v13 - 2) = *(unsigned __int8 *)(result + v12);
          *(v13 - 1) = v14;
          v15 = *(unsigned __int8 *)(result + v12 + 3);
          *v13 = *(unsigned __int8 *)(result + v12 + 2);
          v13[1] = v15;
          v12 += 4;
          v13 += 4;
        }
        while (v12 <= v8 - 4);
        v12 = v12;
      }
      else
      {
        v12 = 0;
      }
      if ((int)v12 < (int)v9)
      {
        do
        {
          *(_WORD *)(a5 + 2 * v12) = *(unsigned __int8 *)(result + v12);
          ++v12;
        }
        while (v9 != v12);
      }
      result += a2;
      v10 = (_WORD *)((char *)v10 + v11);
      a5 += v11;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t cv::cvt8s16u(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, unsigned int *a7)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  _WORD *v10;
  uint64_t v11;
  uint64_t v12;
  _WORD *v13;
  int v14;
  int v15;

  v7 = a7[1];
  if (v7)
  {
    v8 = (int)*a7;
    v9 = *a7;
    v10 = (_WORD *)(a5 + 4);
    v11 = 2 * (a6 >> 1);
    do
    {
      if ((int)v8 >= 4)
      {
        v12 = 0;
        v13 = v10;
        do
        {
          v14 = *(char *)(result + v12 + 1) & ~(*(char *)(result + v12 + 1) >> 31);
          *(v13 - 2) = *(char *)(result + v12) & (unsigned __int16)~(unsigned __int16)(*(char *)(result + v12) >> 31);
          *(v13 - 1) = v14;
          v15 = *(char *)(result + v12 + 3) & ~(*(char *)(result + v12 + 3) >> 31);
          *v13 = *(char *)(result + v12 + 2) & (unsigned __int16)~(unsigned __int16)(*(char *)(result + v12 + 2) >> 31);
          v13[1] = v15;
          v12 += 4;
          v13 += 4;
        }
        while (v12 <= v8 - 4);
        v12 = v12;
      }
      else
      {
        v12 = 0;
      }
      if ((int)v12 < (int)v9)
      {
        do
        {
          *(_WORD *)(a5 + 2 * v12) = *(char *)(result + v12) & (unsigned __int16)~(unsigned __int16)(*(char *)(result + v12) >> 31);
          ++v12;
        }
        while (v9 != v12);
      }
      result += a2;
      v10 = (_WORD *)((char *)v10 + v11);
      a5 += v11;
      --v7;
    }
    while (v7);
  }
  return result;
}

char *cv::cvt16u(char *__src, unint64_t a2, int a3, int a4, char *__dst, unint64_t a6, int *a7)
{
  int v7;
  char *v9;
  size_t v10;
  uint64_t v11;
  uint64_t v12;

  v7 = a7[1];
  if (v7)
  {
    v9 = __src;
    v10 = 2 * *a7;
    v11 = 2 * (a2 >> 1);
    v12 = 2 * (a6 >> 1);
    do
    {
      --v7;
      __src = (char *)memcpy(__dst, v9, v10);
      v9 += v11;
      __dst += v12;
    }
    while (v7);
  }
  return __src;
}

uint64_t cv::cvt16s16u(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, unsigned int *a7)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  _WORD *v14;
  int v15;

  v7 = a7[1];
  if (v7)
  {
    v8 = (int)*a7;
    v9 = *a7;
    v10 = 2 * (a2 >> 1);
    do
    {
      if ((int)v8 >= 4)
      {
        v12 = 0;
        v11 = 0;
        do
        {
          v13 = *(__int16 *)(result + v12 + 2) & ~(*(__int16 *)(result + v12 + 2) >> 31);
          v14 = (_WORD *)(a5 + v12);
          *v14 = *(_WORD *)(result + v12) & ~(*(__int16 *)(result + v12) >> 15);
          v14[1] = v13;
          v15 = *(__int16 *)(result + v12 + 6) & ~(*(__int16 *)(result + v12 + 6) >> 31);
          v14[2] = *(_WORD *)(result + v12 + 4) & ~(*(__int16 *)(result + v12 + 4) >> 15);
          v14[3] = v15;
          v11 += 4;
          v12 += 8;
        }
        while (v11 <= v8 - 4);
        v11 = v11;
      }
      else
      {
        v11 = 0;
      }
      if ((int)v11 < (int)v9)
      {
        do
        {
          *(_WORD *)(a5 + 2 * v11) = *(_WORD *)(result + 2 * v11) & ~(*(__int16 *)(result + 2 * v11) >> 15);
          ++v11;
        }
        while (v9 != v11);
      }
      a5 += 2 * (a6 >> 1);
      result += v10;
      --v7;
    }
    while (v7);
  }
  return result;
}

int32x4_t *cv::cvt32s16u(int32x4_t *result, unint64_t a2, uint64_t a3, uint64_t a4, int16x4_t *a5, unint64_t a6, unsigned int *a7)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  int32x4_t v10;
  uint64_t v11;
  int32x4_t *v12;
  int16x4_t *v13;
  int32x4_t v14;
  int v15;

  v7 = a7[1];
  if (v7)
  {
    v8 = (int)*a7;
    v9 = *a7;
    v10.i64[0] = 0xFFFF0000FFFFLL;
    v10.i64[1] = 0xFFFF0000FFFFLL;
    do
    {
      if ((int)v8 >= 4)
      {
        v11 = 0;
        v12 = result;
        v13 = a5;
        do
        {
          v14 = *v12++;
          *v13++ = vmovn_s32(vminq_s32(vmaxq_s32(v14, (int32x4_t)0), v10));
          v11 += 4;
        }
        while (v11 <= v8 - 4);
        v11 = v11;
      }
      else
      {
        v11 = 0;
      }
      if ((int)v11 < (int)v9)
      {
        do
        {
          v15 = result->i32[v11] & ~(result->i32[v11] >> 31);
          if (v15 >= 0xFFFF)
            LOWORD(v15) = -1;
          a5->i16[v11++] = v15;
        }
        while (v9 != v11);
      }
      a5 = (int16x4_t *)((char *)a5 + 2 * (a6 >> 1));
      result = (int32x4_t *)((char *)result + 4 * (a2 >> 2));
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t cv::cvt32f16u(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, int16x4_t *a5, unint64_t a6, unsigned int *a7)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float *v11;
  uint64_t v12;
  int32x4_t v13;
  uint64_t v14;
  float *v15;
  int16x4_t *v16;
  uint64_t v17;
  uint64_t v18;
  float v19;
  float v20;
  uint64_t v21;
  int32x4_t v22;
  double v23;
  int v24;

  v7 = a7[1];
  if (v7)
  {
    v8 = (int)*a7;
    v9 = *a7;
    v10 = 2 * (a6 >> 1);
    v11 = (float *)(result + 8);
    v12 = 4 * (a2 >> 2);
    v13.i64[0] = 0xFFFF0000FFFFLL;
    v13.i64[1] = 0xFFFF0000FFFFLL;
    do
    {
      if ((int)v8 >= 4)
      {
        v14 = 0;
        v15 = v11;
        v16 = a5;
        do
        {
          v17 = (uint64_t)rint(*(v15 - 2));
          v18 = (uint64_t)rint(*(v15 - 1));
          v20 = *v15;
          v19 = v15[1];
          v15 += 4;
          v21 = (uint64_t)rint(v20);
          v22.i64[0] = __PAIR64__(v18, v17);
          v22.i32[2] = v21;
          v22.i32[3] = (uint64_t)rint(v19);
          *v16++ = vmovn_s32(vminq_s32(vmaxq_s32(v22, (int32x4_t)0), v13));
          v14 += 4;
        }
        while (v14 <= v8 - 4);
        v14 = v14;
      }
      else
      {
        v14 = 0;
      }
      if ((int)v14 < (int)v9)
      {
        do
        {
          v23 = rint(*(float *)(result + 4 * v14));
          v24 = (uint64_t)v23 & ~((int)(uint64_t)v23 >> 31);
          if (v24 >= 0xFFFF)
            LOWORD(v24) = -1;
          a5->i16[v14++] = v24;
        }
        while (v9 != v14);
      }
      a5 = (int16x4_t *)((char *)a5 + v10);
      v11 = (float *)((char *)v11 + v12);
      result += v12;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t cv::cvt64f16u(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, int16x4_t *a5, unint64_t a6, unsigned int *a7)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  double *v11;
  uint64_t v12;
  int32x4_t v13;
  uint64_t v14;
  double *v15;
  int16x4_t *v16;
  uint64_t v17;
  uint64_t v18;
  double v19;
  double v20;
  uint64_t v21;
  double v22;
  int32x4_t v23;
  double v24;
  int v25;

  v7 = a7[1];
  if (v7)
  {
    v8 = (int)*a7;
    v9 = *a7;
    v10 = 2 * (a6 >> 1);
    v11 = (double *)(result + 16);
    v12 = 8 * (a2 >> 3);
    v13.i64[0] = 0xFFFF0000FFFFLL;
    v13.i64[1] = 0xFFFF0000FFFFLL;
    do
    {
      if ((int)v8 >= 4)
      {
        v14 = 0;
        v15 = v11;
        v16 = a5;
        do
        {
          v17 = (uint64_t)rint(*(v15 - 2));
          v18 = (uint64_t)rint(*(v15 - 1));
          v19 = *v15;
          v20 = v15[1];
          v15 += 4;
          v21 = (uint64_t)rint(v19);
          v22 = rint(v20);
          v23.i64[0] = __PAIR64__(v18, v17);
          v23.i32[2] = v21;
          v23.i32[3] = (uint64_t)v22;
          *v16++ = vmovn_s32(vminq_s32(vmaxq_s32(v23, (int32x4_t)0), v13));
          v14 += 4;
        }
        while (v14 <= v8 - 4);
        v14 = v14;
      }
      else
      {
        v14 = 0;
      }
      if ((int)v14 < (int)v9)
      {
        do
        {
          v24 = rint(*(double *)(result + 8 * v14));
          v25 = (uint64_t)v24 & ~((int)(uint64_t)v24 >> 31);
          if (v25 >= 0xFFFF)
            LOWORD(v25) = -1;
          a5->i16[v14++] = v25;
        }
        while (v9 != v14);
      }
      a5 = (int16x4_t *)((char *)a5 + v10);
      v11 = (double *)((char *)v11 + v12);
      result += v12;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t cv::cvt8u16s(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, unsigned int *a7)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  _WORD *v10;
  uint64_t v11;
  uint64_t v12;
  _WORD *v13;
  __int16 v14;
  __int16 v15;

  v7 = a7[1];
  if (v7)
  {
    v8 = (int)*a7;
    v9 = *a7;
    v10 = (_WORD *)(a5 + 4);
    v11 = 2 * (a6 >> 1);
    do
    {
      if ((int)v8 >= 4)
      {
        v12 = 0;
        v13 = v10;
        do
        {
          v14 = *(unsigned __int8 *)(result + v12 + 1);
          *(v13 - 2) = *(unsigned __int8 *)(result + v12);
          *(v13 - 1) = v14;
          v15 = *(unsigned __int8 *)(result + v12 + 3);
          *v13 = *(unsigned __int8 *)(result + v12 + 2);
          v13[1] = v15;
          v12 += 4;
          v13 += 4;
        }
        while (v12 <= v8 - 4);
        v12 = v12;
      }
      else
      {
        v12 = 0;
      }
      if ((int)v12 < (int)v9)
      {
        do
        {
          *(_WORD *)(a5 + 2 * v12) = *(unsigned __int8 *)(result + v12);
          ++v12;
        }
        while (v9 != v12);
      }
      result += a2;
      v10 = (_WORD *)((char *)v10 + v11);
      a5 += v11;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t cv::cvt8s16s(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, unsigned int *a7)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  _WORD *v10;
  uint64_t v11;
  uint64_t v12;
  _WORD *v13;
  __int16 v14;
  __int16 v15;

  v7 = a7[1];
  if (v7)
  {
    v8 = (int)*a7;
    v9 = *a7;
    v10 = (_WORD *)(a5 + 4);
    v11 = 2 * (a6 >> 1);
    do
    {
      if ((int)v8 >= 4)
      {
        v12 = 0;
        v13 = v10;
        do
        {
          v14 = *(char *)(result + v12 + 1);
          *(v13 - 2) = *(char *)(result + v12);
          *(v13 - 1) = v14;
          v15 = *(char *)(result + v12 + 3);
          *v13 = *(char *)(result + v12 + 2);
          v13[1] = v15;
          v12 += 4;
          v13 += 4;
        }
        while (v12 <= v8 - 4);
        v12 = v12;
      }
      else
      {
        v12 = 0;
      }
      if ((int)v12 < (int)v9)
      {
        do
        {
          *(_WORD *)(a5 + 2 * v12) = *(char *)(result + v12);
          ++v12;
        }
        while (v9 != v12);
      }
      result += a2;
      v10 = (_WORD *)((char *)v10 + v11);
      a5 += v11;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t cv::cvt16u16s(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, unsigned int *a7)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int16 *v13;
  unsigned int v14;
  unsigned int v15;
  _WORD *v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;

  v7 = a7[1];
  if (v7)
  {
    v8 = (int)*a7;
    v9 = *a7;
    v10 = 2 * (a2 >> 1);
    do
    {
      if ((int)v8 >= 4)
      {
        v12 = 0;
        v11 = 0;
        do
        {
          v13 = (unsigned __int16 *)(result + v12);
          v14 = *(unsigned __int16 *)(result + v12);
          if (v14 >= 0x7FFF)
            LOWORD(v14) = 0x7FFF;
          v15 = v13[1];
          if (v15 >= 0x7FFF)
            LOWORD(v15) = 0x7FFF;
          v16 = (_WORD *)(a5 + v12);
          *v16 = v14;
          v16[1] = v15;
          v17 = v13[2];
          if (v17 >= 0x7FFF)
            LOWORD(v17) = 0x7FFF;
          v18 = v13[3];
          if (v18 >= 0x7FFF)
            LOWORD(v18) = 0x7FFF;
          v16[2] = v17;
          v16[3] = v18;
          v11 += 4;
          v12 += 8;
        }
        while (v11 <= v8 - 4);
        v11 = v11;
      }
      else
      {
        v11 = 0;
      }
      if ((int)v11 < (int)v9)
      {
        do
        {
          v19 = *(unsigned __int16 *)(result + 2 * v11);
          if (v19 >= 0x7FFF)
            LOWORD(v19) = 0x7FFF;
          *(_WORD *)(a5 + 2 * v11++) = v19;
        }
        while (v9 != v11);
      }
      a5 += 2 * (a6 >> 1);
      result += v10;
      --v7;
    }
    while (v7);
  }
  return result;
}

int32x4_t *cv::cvt32s16s(int32x4_t *result, unint64_t a2, uint64_t a3, uint64_t a4, int16x4_t *a5, unint64_t a6, unsigned int *a7)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int32x4_t *v12;
  int16x4_t *v13;
  int32x4_t v14;
  int v15;

  v7 = a7[1];
  if (v7)
  {
    v8 = (int)*a7;
    v9 = *a7;
    v10 = 4 * (a2 >> 2);
    do
    {
      if ((int)v8 >= 4)
      {
        v11 = 0;
        v12 = result;
        v13 = a5;
        do
        {
          v14 = *v12++;
          *v13++ = vqmovn_s32(v14);
          v11 += 4;
        }
        while (v11 <= v8 - 4);
        v11 = v11;
      }
      else
      {
        v11 = 0;
      }
      if ((int)v11 < (int)v9)
      {
        do
        {
          v15 = result->i32[v11];
          if (v15 <= -32768)
            v15 = -32768;
          if (v15 >= 0x7FFF)
            LOWORD(v15) = 0x7FFF;
          a5->i16[v11++] = v15;
        }
        while (v9 != v11);
      }
      a5 = (int16x4_t *)((char *)a5 + 2 * (a6 >> 1));
      result = (int32x4_t *)((char *)result + v10);
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t cv::cvt32f16s(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, unsigned int *a7)
{
  unsigned int v7;
  uint64_t v8;
  uint64_t i;
  uint64_t v10;

  v7 = a7[1];
  if (v7)
  {
    v8 = *a7;
    do
    {
      if ((int)v8 >= 1)
      {
        for (i = 0; i != v8; ++i)
        {
          v10 = (uint64_t)rint(*(float *)(result + 4 * i));
          if ((int)v10 <= -32768)
            LODWORD(v10) = -32768;
          if ((int)v10 >= 0x7FFF)
            LOWORD(v10) = 0x7FFF;
          *(_WORD *)(a5 + 2 * i) = v10;
        }
      }
      a5 += 2 * (a6 >> 1);
      result += 4 * (a2 >> 2);
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t cv::cvt64f16s(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, int16x4_t *a5, unint64_t a6, unsigned int *a7)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  double *v11;
  uint64_t v12;
  uint64_t v13;
  double *v14;
  int16x4_t *v15;
  uint64_t v16;
  uint64_t v17;
  double v18;
  double v19;
  uint64_t v20;
  double v21;
  int32x4_t v22;
  uint64_t v23;

  v7 = a7[1];
  if (v7)
  {
    v8 = (int)*a7;
    v9 = *a7;
    v10 = 2 * (a6 >> 1);
    v11 = (double *)(result + 16);
    v12 = 8 * (a2 >> 3);
    do
    {
      if ((int)v8 >= 4)
      {
        v13 = 0;
        v14 = v11;
        v15 = a5;
        do
        {
          v16 = (uint64_t)rint(*(v14 - 2));
          v17 = (uint64_t)rint(*(v14 - 1));
          v18 = *v14;
          v19 = v14[1];
          v14 += 4;
          v20 = (uint64_t)rint(v18);
          v21 = rint(v19);
          v22.i64[0] = __PAIR64__(v17, v16);
          v22.i32[2] = v20;
          v22.i32[3] = (uint64_t)v21;
          *v15++ = vqmovn_s32(v22);
          v13 += 4;
        }
        while (v13 <= v8 - 4);
        v13 = v13;
      }
      else
      {
        v13 = 0;
      }
      if ((int)v13 < (int)v9)
      {
        do
        {
          v23 = (uint64_t)rint(*(double *)(result + 8 * v13));
          if ((int)v23 <= -32768)
            LODWORD(v23) = -32768;
          if ((int)v23 >= 0x7FFF)
            LOWORD(v23) = 0x7FFF;
          a5->i16[v13++] = v23;
        }
        while (v9 != v13);
      }
      a5 = (int16x4_t *)((char *)a5 + v10);
      v11 = (double *)((char *)v11 + v12);
      result += v12;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t cv::cvt8u32s(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, int *a7)
{
  int v7;
  uint64_t v8;
  _DWORD *v9;
  uint64_t v10;
  uint64_t v11;
  _DWORD *v12;
  int v13;
  int v14;

  v7 = a7[1];
  if (v7)
  {
    v8 = *a7;
    v9 = (_DWORD *)(a5 + 8);
    v10 = 4 * (a6 >> 2);
    do
    {
      if ((int)v8 >= 4)
      {
        v11 = 0;
        v12 = v9;
        do
        {
          v13 = *(unsigned __int8 *)(result + v11 + 1);
          *(v12 - 2) = *(unsigned __int8 *)(result + v11);
          *(v12 - 1) = v13;
          v14 = *(unsigned __int8 *)(result + v11 + 3);
          *v12 = *(unsigned __int8 *)(result + v11 + 2);
          v12[1] = v14;
          v12 += 4;
          v11 += 4;
        }
        while (v11 <= v8 - 4);
        v11 = v11;
      }
      else
      {
        v11 = 0;
      }
      if ((int)v11 < (int)v8)
      {
        do
        {
          *(_DWORD *)(a5 + 4 * v11) = *(unsigned __int8 *)(result + v11);
          ++v11;
        }
        while (v11 < v8);
      }
      result += a2;
      v9 = (_DWORD *)((char *)v9 + v10);
      a5 += v10;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t cv::cvt8s32s(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, int *a7)
{
  int v7;
  uint64_t v8;
  _DWORD *v9;
  uint64_t v10;
  uint64_t v11;
  _DWORD *v12;
  int v13;
  int v14;

  v7 = a7[1];
  if (v7)
  {
    v8 = *a7;
    v9 = (_DWORD *)(a5 + 8);
    v10 = 4 * (a6 >> 2);
    do
    {
      if ((int)v8 >= 4)
      {
        v11 = 0;
        v12 = v9;
        do
        {
          v13 = *(char *)(result + v11 + 1);
          *(v12 - 2) = *(char *)(result + v11);
          *(v12 - 1) = v13;
          v14 = *(char *)(result + v11 + 3);
          *v12 = *(char *)(result + v11 + 2);
          v12[1] = v14;
          v12 += 4;
          v11 += 4;
        }
        while (v11 <= v8 - 4);
        v11 = v11;
      }
      else
      {
        v11 = 0;
      }
      if ((int)v11 < (int)v8)
      {
        do
        {
          *(_DWORD *)(a5 + 4 * v11) = *(char *)(result + v11);
          ++v11;
        }
        while (v11 < v8);
      }
      result += a2;
      v9 = (_DWORD *)((char *)v9 + v10);
      a5 += v10;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint16x4_t *cv::cvt16u32s(uint16x4_t *result, unint64_t a2, uint64_t a3, uint64_t a4, uint32x4_t *a5, unint64_t a6, int *a7)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint16x4_t *v10;
  uint32x4_t *v11;
  uint16x4_t v12;

  v7 = a7[1];
  if (v7)
  {
    v8 = *a7;
    do
    {
      if ((int)v8 >= 4)
      {
        v9 = 0;
        v10 = result;
        v11 = a5;
        do
        {
          v12 = *v10++;
          *v11++ = vmovl_u16(v12);
          v9 += 4;
        }
        while (v9 <= v8 - 4);
        v9 = v9;
      }
      else
      {
        v9 = 0;
      }
      if ((int)v9 < (int)v8)
      {
        do
        {
          a5->i32[v9] = result->u16[v9];
          ++v9;
        }
        while (v9 < v8);
      }
      a5 = (uint32x4_t *)((char *)a5 + 4 * (a6 >> 2));
      result = (uint16x4_t *)((char *)result + 2 * (a2 >> 1));
      --v7;
    }
    while (v7);
  }
  return result;
}

int16x4_t *cv::cvt16s32s(int16x4_t *result, unint64_t a2, uint64_t a3, uint64_t a4, int32x4_t *a5, unint64_t a6, int *a7)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  int16x4_t *v10;
  int32x4_t *v11;
  int16x4_t v12;

  v7 = a7[1];
  if (v7)
  {
    v8 = *a7;
    do
    {
      if ((int)v8 >= 4)
      {
        v9 = 0;
        v10 = result;
        v11 = a5;
        do
        {
          v12 = *v10++;
          *v11++ = vmovl_s16(v12);
          v9 += 4;
        }
        while (v9 <= v8 - 4);
        v9 = v9;
      }
      else
      {
        v9 = 0;
      }
      if ((int)v9 < (int)v8)
      {
        do
        {
          a5->i32[v9] = result->i16[v9];
          ++v9;
        }
        while (v9 < v8);
      }
      a5 = (int32x4_t *)((char *)a5 + 4 * (a6 >> 2));
      result = (int16x4_t *)((char *)result + 2 * (a2 >> 1));
      --v7;
    }
    while (v7);
  }
  return result;
}

char *cv::cvt32s(char *__src, unint64_t a2, int a3, int a4, char *__dst, unint64_t a6, int *a7)
{
  int v7;
  char *v9;
  size_t v10;
  uint64_t v11;
  uint64_t v12;

  v7 = a7[1];
  if (v7)
  {
    v9 = __src;
    v10 = 4 * *a7;
    v11 = 4 * (a2 >> 2);
    v12 = 4 * (a6 >> 2);
    do
    {
      --v7;
      __src = (char *)memcpy(__dst, v9, v10);
      v9 += v11;
      __dst += v12;
    }
    while (v7);
  }
  return __src;
}

uint64_t cv::cvt32f32s(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, int *a7)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _DWORD *v14;
  double v15;

  v7 = a7[1];
  if (v7)
  {
    v8 = *a7;
    v9 = 4 * (a2 >> 2);
    do
    {
      if ((int)v8 >= 4)
      {
        v11 = 0;
        v10 = 0;
        do
        {
          v12 = (uint64_t)rint(*(float *)(result + v11 + 4));
          v13 = (uint64_t)rint(*(float *)(result + v11 + 8));
          v14 = (_DWORD *)(a5 + v11);
          v15 = rint(*(float *)(result + v11 + 12));
          *v14 = (uint64_t)rint(*(float *)(result + v11));
          v14[1] = v12;
          v14[2] = v13;
          v14[3] = (uint64_t)v15;
          v10 += 4;
          v11 += 16;
        }
        while (v10 <= v8 - 4);
        v10 = v10;
      }
      else
      {
        v10 = 0;
      }
      if ((int)v10 < (int)v8)
      {
        do
        {
          *(_DWORD *)(a5 + 4 * v10) = (uint64_t)rint(*(float *)(result + 4 * v10));
          ++v10;
        }
        while (v10 < v8);
      }
      a5 += 4 * (a6 >> 2);
      result += v9;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t cv::cvt64f32s(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, int *a7)
{
  int v7;
  uint64_t v8;
  _DWORD *v9;
  uint64_t v10;
  double *v11;
  uint64_t v12;
  uint64_t v13;
  double *v14;
  _DWORD *v15;
  uint64_t v16;
  uint64_t v17;
  double v18;
  double v19;

  v7 = a7[1];
  if (v7)
  {
    v8 = *a7;
    v9 = (_DWORD *)(a5 + 8);
    v10 = 4 * (a6 >> 2);
    v11 = (double *)(result + 16);
    v12 = 8 * (a2 >> 3);
    do
    {
      if ((int)v8 >= 4)
      {
        v13 = 0;
        v14 = v11;
        v15 = v9;
        do
        {
          v16 = (uint64_t)rint(*(v14 - 2));
          v17 = (uint64_t)rint(*(v14 - 1));
          v18 = *v14;
          v19 = v14[1];
          v14 += 4;
          *(v15 - 2) = v16;
          *(v15 - 1) = v17;
          *v15 = (uint64_t)rint(v18);
          v15[1] = (uint64_t)rint(v19);
          v15 += 4;
          v13 += 4;
        }
        while (v13 <= v8 - 4);
        v13 = v13;
      }
      else
      {
        v13 = 0;
      }
      if ((int)v13 < (int)v8)
      {
        do
        {
          *(_DWORD *)(a5 + 4 * v13) = (uint64_t)rint(*(double *)(result + 8 * v13));
          ++v13;
        }
        while (v13 < v8);
      }
      v9 = (_DWORD *)((char *)v9 + v10);
      v11 = (double *)((char *)v11 + v12);
      a5 += v10;
      result += v12;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t cv::cvt8u32f(uint64_t result, uint64_t a2, float a3, float a4, uint64_t a5, uint64_t a6, uint64_t a7, unint64_t a8, unsigned int *a9)
{
  int v9;
  uint64_t v10;
  uint64_t v11;
  float *v12;
  uint64_t v13;
  uint64_t v14;
  float *v15;
  float v16;
  float v17;

  v9 = a9[1];
  if (v9)
  {
    v10 = (int)*a9;
    v11 = *a9;
    v12 = (float *)(a7 + 8);
    v13 = 4 * (a8 >> 2);
    do
    {
      if ((int)v10 >= 4)
      {
        v14 = 0;
        v15 = v12;
        do
        {
          LOBYTE(a3) = *(_BYTE *)(result + v14);
          v16 = (float)LODWORD(a3);
          LOBYTE(a4) = *(_BYTE *)(result + v14 + 1);
          v17 = (float)LODWORD(a4);
          *(v15 - 2) = v16;
          *(v15 - 1) = v17;
          LOBYTE(v16) = *(_BYTE *)(result + v14 + 2);
          a3 = (float)LODWORD(v16);
          LOBYTE(v17) = *(_BYTE *)(result + v14 + 3);
          a4 = (float)LODWORD(v17);
          *v15 = a3;
          v15[1] = a4;
          v15 += 4;
          v14 += 4;
        }
        while (v14 <= v10 - 4);
        v14 = v14;
      }
      else
      {
        v14 = 0;
      }
      if ((int)v14 < (int)v11)
      {
        do
        {
          LOBYTE(a3) = *(_BYTE *)(result + v14);
          a3 = (float)LODWORD(a3);
          *(float *)(a7 + 4 * v14++) = a3;
        }
        while (v11 != v14);
      }
      result += a2;
      v12 = (float *)((char *)v12 + v13);
      a7 += v13;
      --v9;
    }
    while (v9);
  }
  return result;
}

uint64_t cv::cvt8s32f(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, unsigned int *a7)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  float *v10;
  uint64_t v11;
  uint64_t v12;
  float *v13;
  float v14;
  float v15;

  v7 = a7[1];
  if (v7)
  {
    v8 = (int)*a7;
    v9 = *a7;
    v10 = (float *)(a5 + 8);
    v11 = 4 * (a6 >> 2);
    do
    {
      if ((int)v8 >= 4)
      {
        v12 = 0;
        v13 = v10;
        do
        {
          v14 = (float)*(char *)(result + v12 + 1);
          *(v13 - 2) = (float)*(char *)(result + v12);
          *(v13 - 1) = v14;
          v15 = (float)*(char *)(result + v12 + 3);
          *v13 = (float)*(char *)(result + v12 + 2);
          v13[1] = v15;
          v13 += 4;
          v12 += 4;
        }
        while (v12 <= v8 - 4);
        v12 = v12;
      }
      else
      {
        v12 = 0;
      }
      if ((int)v12 < (int)v9)
      {
        do
        {
          *(float *)(a5 + 4 * v12) = (float)*(char *)(result + v12);
          ++v12;
        }
        while (v9 != v12);
      }
      result += a2;
      v10 = (float *)((char *)v10 + v11);
      a5 += v11;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint16x4_t *cv::cvt16u32f(uint16x4_t *result, unint64_t a2, __n128 a3, uint64_t a4, uint64_t a5, __n128 *a6, unint64_t a7, unsigned int *a8)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint16x4_t *v12;
  __n128 *v13;
  uint16x4_t v14;

  v8 = a8[1];
  if (v8)
  {
    v9 = (int)*a8;
    v10 = *a8;
    do
    {
      if ((int)v9 >= 4)
      {
        v11 = 0;
        v12 = result;
        v13 = a6;
        do
        {
          v14 = *v12++;
          a3 = (__n128)vcvtq_f32_u32(vmovl_u16(v14));
          *v13++ = a3;
          v11 += 4;
        }
        while (v11 <= v9 - 4);
        v11 = v11;
      }
      else
      {
        v11 = 0;
      }
      if ((int)v11 < (int)v10)
      {
        do
        {
          a3.n128_u16[0] = result->u16[v11];
          a3.n128_f32[0] = (float)a3.n128_u32[0];
          a6->n128_u32[v11++] = a3.n128_u32[0];
        }
        while (v10 != v11);
      }
      a6 = (__n128 *)((char *)a6 + 4 * (a7 >> 2));
      result = (uint16x4_t *)((char *)result + 2 * (a2 >> 1));
      --v8;
    }
    while (v8);
  }
  return result;
}

int16x4_t *cv::cvt16s32f(int16x4_t *result, unint64_t a2, uint64_t a3, uint64_t a4, float32x4_t *a5, unint64_t a6, unsigned int *a7)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int16x4_t *v11;
  float32x4_t *v12;
  int16x4_t v13;

  v7 = a7[1];
  if (v7)
  {
    v8 = (int)*a7;
    v9 = *a7;
    do
    {
      if ((int)v8 >= 4)
      {
        v10 = 0;
        v11 = result;
        v12 = a5;
        do
        {
          v13 = *v11++;
          *v12++ = vcvtq_f32_s32(vmovl_s16(v13));
          v10 += 4;
        }
        while (v10 <= v8 - 4);
        v10 = v10;
      }
      else
      {
        v10 = 0;
      }
      if ((int)v10 < (int)v9)
      {
        do
        {
          a5->f32[v10] = (float)result->i16[v10];
          ++v10;
        }
        while (v9 != v10);
      }
      a5 = (float32x4_t *)((char *)a5 + 4 * (a6 >> 2));
      result = (int16x4_t *)((char *)result + 2 * (a2 >> 1));
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t cv::cvt32s32f(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, unsigned int *a7)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v7 = a7[1];
  if (v7)
  {
    v8 = (int)*a7;
    v9 = *a7;
    do
    {
      if ((int)v8 >= 4)
      {
        v11 = 0;
        v10 = 0;
        do
        {
          *(float32x4_t *)(a5 + v11) = vcvtq_f32_s32(*(int32x4_t *)(result + v11));
          v10 += 4;
          v11 += 16;
        }
        while (v10 <= v8 - 4);
        v10 = v10;
      }
      else
      {
        v10 = 0;
      }
      if ((int)v10 < (int)v9)
      {
        do
        {
          *(float *)(a5 + 4 * v10) = (float)*(int *)(result + 4 * v10);
          ++v10;
        }
        while (v9 != v10);
      }
      a5 += 4 * (a6 >> 2);
      result += 4 * (a2 >> 2);
      --v7;
    }
    while (v7);
  }
  return result;
}

float64x2_t *cv::cvt64f32f(float64x2_t *result, unint64_t a2, uint64_t a3, uint64_t a4, float32x4_t *a5, unint64_t a6, unsigned int *a7)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float64x2_t *v11;
  float32x4_t *v12;
  float64x2_t v13;
  float64x2_t v14;
  float32_t v15;

  v7 = a7[1];
  if (v7)
  {
    v8 = (int)*a7;
    v9 = *a7;
    do
    {
      if ((int)v8 >= 4)
      {
        v10 = 0;
        v11 = result;
        v12 = a5;
        do
        {
          v14 = *v11;
          v13 = v11[1];
          v11 += 2;
          *v12++ = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v14), v13);
          v10 += 4;
        }
        while (v10 <= v8 - 4);
        v10 = v10;
      }
      else
      {
        v10 = 0;
      }
      if ((int)v10 < (int)v9)
      {
        do
        {
          v15 = result->f64[v10];
          a5->f32[v10++] = v15;
        }
        while (v9 != v10);
      }
      a5 = (float32x4_t *)((char *)a5 + 4 * (a6 >> 2));
      result = (float64x2_t *)((char *)result + 8 * (a2 >> 3));
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t cv::cvt8u64f(uint64_t result, uint64_t a2, double a3, double a4, uint64_t a5, uint64_t a6, uint64_t a7, unint64_t a8, unsigned int *a9)
{
  int v9;
  uint64_t v10;
  uint64_t v11;
  double *v12;
  uint64_t v13;
  uint64_t v14;
  double *v15;
  double v16;
  double v17;

  v9 = a9[1];
  if (v9)
  {
    v10 = (int)*a9;
    v11 = *a9;
    v12 = (double *)(a7 + 16);
    v13 = 8 * (a8 >> 3);
    do
    {
      if ((int)v10 >= 4)
      {
        v14 = 0;
        v15 = v12;
        do
        {
          LOBYTE(a3) = *(_BYTE *)(result + v14);
          v16 = (double)*(unint64_t *)&a3;
          LOBYTE(a4) = *(_BYTE *)(result + v14 + 1);
          v17 = (double)*(unint64_t *)&a4;
          *(v15 - 2) = v16;
          *(v15 - 1) = v17;
          LOBYTE(v16) = *(_BYTE *)(result + v14 + 2);
          a3 = (double)*(unint64_t *)&v16;
          LOBYTE(v17) = *(_BYTE *)(result + v14 + 3);
          a4 = (double)*(unint64_t *)&v17;
          *v15 = a3;
          v15[1] = a4;
          v15 += 4;
          v14 += 4;
        }
        while (v14 <= v10 - 4);
        v14 = v14;
      }
      else
      {
        v14 = 0;
      }
      if ((int)v14 < (int)v11)
      {
        do
        {
          LOBYTE(a3) = *(_BYTE *)(result + v14);
          a3 = (double)*(unint64_t *)&a3;
          *(double *)(a7 + 8 * v14++) = a3;
        }
        while (v11 != v14);
      }
      result += a2;
      v12 = (double *)((char *)v12 + v13);
      a7 += v13;
      --v9;
    }
    while (v9);
  }
  return result;
}

uint64_t cv::cvt8s64f(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, unsigned int *a7)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  double *v10;
  uint64_t v11;
  uint64_t v12;
  double *v13;
  double v14;
  double v15;

  v7 = a7[1];
  if (v7)
  {
    v8 = (int)*a7;
    v9 = *a7;
    v10 = (double *)(a5 + 16);
    v11 = 8 * (a6 >> 3);
    do
    {
      if ((int)v8 >= 4)
      {
        v12 = 0;
        v13 = v10;
        do
        {
          v14 = (double)*(char *)(result + v12 + 1);
          *(v13 - 2) = (double)*(char *)(result + v12);
          *(v13 - 1) = v14;
          v15 = (double)*(char *)(result + v12 + 3);
          *v13 = (double)*(char *)(result + v12 + 2);
          v13[1] = v15;
          v13 += 4;
          v12 += 4;
        }
        while (v12 <= v8 - 4);
        v12 = v12;
      }
      else
      {
        v12 = 0;
      }
      if ((int)v12 < (int)v9)
      {
        do
        {
          *(double *)(a5 + 8 * v12) = (double)*(char *)(result + v12);
          ++v12;
        }
        while (v9 != v12);
      }
      result += a2;
      v10 = (double *)((char *)v10 + v11);
      a5 += v11;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t cv::cvt16u64f(uint64_t result, unint64_t a2, double a3, double a4, uint64_t a5, uint64_t a6, uint64_t a7, unint64_t a8, unsigned int *a9)
{
  int v9;
  uint64_t v10;
  uint64_t v11;
  double *v12;
  uint64_t v13;
  _WORD *v14;
  uint64_t v15;
  uint64_t v16;
  _WORD *v17;
  double *v18;
  double v19;
  double v20;

  v9 = a9[1];
  if (v9)
  {
    v10 = (int)*a9;
    v11 = *a9;
    v12 = (double *)(a7 + 16);
    v13 = 8 * (a8 >> 3);
    v14 = (_WORD *)(result + 4);
    v15 = 2 * (a2 >> 1);
    do
    {
      if ((int)v10 >= 4)
      {
        v16 = 0;
        v17 = v14;
        v18 = v12;
        do
        {
          LOWORD(a3) = *(v17 - 2);
          v19 = (double)*(unint64_t *)&a3;
          LOWORD(a4) = *(v17 - 1);
          v20 = (double)*(unint64_t *)&a4;
          *(v18 - 2) = v19;
          *(v18 - 1) = v20;
          LOWORD(v19) = *v17;
          a3 = (double)*(unint64_t *)&v19;
          LOWORD(v20) = v17[1];
          a4 = (double)*(unint64_t *)&v20;
          *v18 = a3;
          v18[1] = a4;
          v18 += 4;
          v16 += 4;
          v17 += 4;
        }
        while (v16 <= v10 - 4);
        v16 = v16;
      }
      else
      {
        v16 = 0;
      }
      if ((int)v16 < (int)v11)
      {
        do
        {
          LOWORD(a3) = *(_WORD *)(result + 2 * v16);
          a3 = (double)*(unint64_t *)&a3;
          *(double *)(a7 + 8 * v16++) = a3;
        }
        while (v11 != v16);
      }
      v12 = (double *)((char *)v12 + v13);
      v14 = (_WORD *)((char *)v14 + v15);
      a7 += v13;
      result += v15;
      --v9;
    }
    while (v9);
  }
  return result;
}

uint64_t cv::cvt16s64f(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, unsigned int *a7)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  double *v10;
  uint64_t v11;
  __int16 *v12;
  uint64_t v13;
  uint64_t v14;
  __int16 *v15;
  double *v16;
  double v17;
  double v18;

  v7 = a7[1];
  if (v7)
  {
    v8 = (int)*a7;
    v9 = *a7;
    v10 = (double *)(a5 + 16);
    v11 = 8 * (a6 >> 3);
    v12 = (__int16 *)(result + 4);
    v13 = 2 * (a2 >> 1);
    do
    {
      if ((int)v8 >= 4)
      {
        v14 = 0;
        v15 = v12;
        v16 = v10;
        do
        {
          v17 = (double)*(v15 - 1);
          *(v16 - 2) = (double)*(v15 - 2);
          *(v16 - 1) = v17;
          v18 = (double)v15[1];
          *v16 = (double)*v15;
          v16[1] = v18;
          v16 += 4;
          v14 += 4;
          v15 += 4;
        }
        while (v14 <= v8 - 4);
        v14 = v14;
      }
      else
      {
        v14 = 0;
      }
      if ((int)v14 < (int)v9)
      {
        do
        {
          *(double *)(a5 + 8 * v14) = (double)*(__int16 *)(result + 2 * v14);
          ++v14;
        }
        while (v9 != v14);
      }
      v10 = (double *)((char *)v10 + v11);
      v12 = (__int16 *)((char *)v12 + v13);
      a5 += v11;
      result += v13;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t cv::cvt32s64f(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, float64x2_t *a5, unint64_t a6, unsigned int *a7)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  float64x2_t *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  float64x2_t *v16;
  uint64_t v17;
  int64x2_t v18;
  uint64_t v19;

  v7 = a7[1];
  if (v7)
  {
    v8 = (int)*a7;
    v9 = *a7;
    v10 = a5 + 1;
    v11 = 8 * (a6 >> 3);
    v12 = (uint64_t *)(result + 8);
    v13 = 4 * (a2 >> 2);
    do
    {
      if ((int)v8 >= 4)
      {
        v14 = 0;
        v15 = v12;
        v16 = v10;
        do
        {
          v17 = *(v15 - 1);
          v18.i64[0] = (int)v17;
          v18.i64[1] = SHIDWORD(v17);
          v16[-1] = vcvtq_f64_s64(v18);
          v19 = *v15;
          v15 += 2;
          v18.i64[0] = (int)v19;
          v18.i64[1] = SHIDWORD(v19);
          *v16 = vcvtq_f64_s64(v18);
          v16 += 2;
          v14 += 4;
        }
        while (v14 <= v8 - 4);
        v14 = v14;
      }
      else
      {
        v14 = 0;
      }
      if ((int)v14 < (int)v9)
      {
        do
        {
          a5->f64[v14] = (double)*(int *)(result + 4 * v14);
          ++v14;
        }
        while (v9 != v14);
      }
      v10 = (float64x2_t *)((char *)v10 + v11);
      v12 = (uint64_t *)((char *)v12 + v13);
      a5 = (float64x2_t *)((char *)a5 + v11);
      result += v13;
      --v7;
    }
    while (v7);
  }
  return result;
}

float32x2_t *cv::cvt32f64f(float32x2_t *result, unint64_t a2, uint64_t a3, uint64_t a4, float64x2_t *a5, unint64_t a6, unsigned int *a7)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  float64x2_t *v10;
  uint64_t v11;
  float32x2_t *v12;
  uint64_t v13;
  uint64_t v14;
  float32x2_t *v15;
  float64x2_t *v16;
  float32x2_t v17;

  v7 = a7[1];
  if (v7)
  {
    v8 = (int)*a7;
    v9 = *a7;
    v10 = a5 + 1;
    v11 = 8 * (a6 >> 3);
    v12 = result + 1;
    v13 = 4 * (a2 >> 2);
    do
    {
      if ((int)v8 >= 4)
      {
        v14 = 0;
        v15 = v12;
        v16 = v10;
        do
        {
          v16[-1] = vcvtq_f64_f32(v15[-1]);
          v17 = *v15;
          v15 += 2;
          *v16 = vcvtq_f64_f32(v17);
          v16 += 2;
          v14 += 4;
        }
        while (v14 <= v8 - 4);
        v14 = v14;
      }
      else
      {
        v14 = 0;
      }
      if ((int)v14 < (int)v9)
      {
        do
        {
          a5->f64[v14] = result->f32[v14];
          ++v14;
        }
        while (v9 != v14);
      }
      v10 = (float64x2_t *)((char *)v10 + v11);
      v12 = (float32x2_t *)((char *)v12 + v13);
      a5 = (float64x2_t *)((char *)a5 + v11);
      result = (float32x2_t *)((char *)result + v13);
      --v7;
    }
    while (v7);
  }
  return result;
}

char *cv::cvt64s(char *__src, unint64_t a2, int a3, int a4, char *__dst, unint64_t a6, int *a7)
{
  int v7;
  char *v9;
  size_t v10;
  uint64_t v11;
  uint64_t v12;

  v7 = a7[1];
  if (v7)
  {
    v9 = __src;
    v10 = 8 * *a7;
    v11 = 8 * (a2 >> 3);
    v12 = 8 * (a6 >> 3);
    do
    {
      --v7;
      __src = (char *)memcpy(__dst, v9, v10);
      v9 += v11;
      __dst += v12;
    }
    while (v7);
  }
  return __src;
}

uint64_t cv::cvtScale8u(uint64_t result, uint64_t a2, double a3, double a4, double a5, double a6, double a7, float a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int *a13, double *a14)
{
  int v14;
  uint64_t v15;
  float v16;
  float v17;
  uint64_t v18;
  double v19;
  int32x2_t v20;
  _BYTE *v21;
  int v22;

  v14 = a13[1];
  if (v14)
  {
    v15 = *a13;
    v16 = *a14;
    v17 = a14[1];
    do
    {
      if ((int)v15 >= 4)
      {
        v18 = 0;
        do
        {
          LOBYTE(a7) = *(_BYTE *)(result + v18);
          LOBYTE(a8) = *(_BYTE *)(result + v18 + 1);
          v19 = (float)(v17 + (float)((float)LODWORD(a8) * v16));
          v20 = vmin_s32(vmax_s32((int32x2_t)__PAIR64__((uint64_t)rint(v19), (uint64_t)rint((float)(v17 + (float)((float)LODWORD(a7) * v16)))), 0), (int32x2_t)0xFF000000FFLL);
          v21 = (_BYTE *)(a11 + v18);
          v21[1] = v20.i8[4];
          *v21 = v20.i8[0];
          v20.i8[0] = *(_BYTE *)(result + v18 + 2);
          LOBYTE(v19) = *(_BYTE *)(result + v18 + 3);
          a8 = (float)LODWORD(v19);
          a7 = COERCE_DOUBLE(vmin_s32(vmax_s32((int32x2_t)__PAIR64__((uint64_t)rint((float)(v17 + (float)(a8 * v16))), (uint64_t)rint((float)(v17 + (float)((float)v20.u32[0] * v16)))), 0), (int32x2_t)0xFF000000FFLL));
          v21[3] = BYTE4(a7);
          v21[2] = LOBYTE(a7);
          v18 += 4;
        }
        while (v18 <= v15 - 4);
        v18 = v18;
      }
      else
      {
        v18 = 0;
      }
      if ((int)v18 < (int)v15)
      {
        do
        {
          LOBYTE(a7) = *(_BYTE *)(result + v18);
          a7 = rint((float)(v17 + (float)((float)LODWORD(a7) * v16)));
          v22 = (uint64_t)a7 & ~((int)(uint64_t)a7 >> 31);
          if (v22 >= 255)
            LOBYTE(v22) = -1;
          *(_BYTE *)(a11 + v18++) = v22;
        }
        while (v18 < v15);
      }
      result += a2;
      a11 += a12;
      --v14;
    }
    while (v14);
  }
  return result;
}

uint64_t cv::cvtScale8s8u(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7, double *a8)
{
  int v8;
  uint64_t v9;
  float v10;
  float v11;
  uint64_t v12;
  int32x2_t v13;
  _BYTE *v14;
  int32x2_t v15;
  int32x2_t v16;
  double v17;
  int v18;

  v8 = a7[1];
  if (v8)
  {
    v9 = *a7;
    v10 = *a8;
    v11 = a8[1];
    do
    {
      if ((int)v9 >= 4)
      {
        v12 = 0;
        do
        {
          v13.i32[0] = (uint64_t)rint((float)(v11 + (float)((float)*(char *)(result + v12) * v10)));
          v13.i32[1] = (uint64_t)rint((float)(v11 + (float)((float)*(char *)(result + v12 + 1) * v10)));
          v14 = (_BYTE *)(a5 + v12);
          v15 = vmin_s32(vmax_s32(v13, 0), (int32x2_t)0xFF000000FFLL);
          v14[1] = v15.i8[4];
          *v14 = v15.i8[0];
          v16 = vmin_s32(vmax_s32((int32x2_t)__PAIR64__((uint64_t)rint((float)(v11 + (float)((float)*(char *)(result + v12 + 3) * v10))), (uint64_t)rint((float)(v11 + (float)((float)*(char *)(result + v12 + 2) * v10)))), 0), (int32x2_t)0xFF000000FFLL);
          v14[3] = v16.i8[4];
          v14[2] = v16.i8[0];
          v12 += 4;
        }
        while (v12 <= v9 - 4);
        v12 = v12;
      }
      else
      {
        v12 = 0;
      }
      if ((int)v12 < (int)v9)
      {
        do
        {
          v17 = rint((float)(v11 + (float)((float)*(char *)(result + v12) * v10)));
          v18 = (uint64_t)v17 & ~((int)(uint64_t)v17 >> 31);
          if (v18 >= 255)
            LOBYTE(v18) = -1;
          *(_BYTE *)(a5 + v12++) = v18;
        }
        while (v12 < v9);
      }
      result += a2;
      a5 += a6;
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t cv::cvtScale16u8u(uint64_t result, unint64_t a2, double a3, double a4, double a5, double a6, double a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int *a12, double *a13)
{
  int v13;
  uint64_t v14;
  float v15;
  float v16;
  __int16 *v17;
  uint64_t v18;
  uint64_t v19;
  __int16 *v20;
  double v21;
  uint64_t v22;
  _BYTE *v23;
  int32x2_t v24;
  double v25;
  uint64_t v26;
  int v27;

  v13 = a12[1];
  if (v13)
  {
    v14 = *a12;
    v15 = *a13;
    v16 = a13[1];
    v17 = (__int16 *)(result + 4);
    v18 = 2 * (a2 >> 1);
    do
    {
      if ((int)v14 >= 4)
      {
        v19 = 0;
        v20 = v17;
        do
        {
          LOWORD(a7) = *(v20 - 2);
          v21 = rint((float)(v16 + (float)((float)LODWORD(a7) * v15)));
          v22 = (uint64_t)v21;
          LOWORD(v21) = *(v20 - 1);
          v23 = (_BYTE *)(a10 + v19);
          v24 = vmin_s32(vmax_s32((int32x2_t)__PAIR64__((uint64_t)rint((float)(v16 + (float)((float)LODWORD(v21) * v15))), v22), 0), (int32x2_t)0xFF000000FFLL);
          v23[1] = v24.i8[4];
          *v23 = v24.i8[0];
          v24.i16[0] = *v20;
          v25 = rint((float)(v16 + (float)((float)v24.u32[0] * v15)));
          v26 = (uint64_t)v25;
          LOWORD(v25) = v20[1];
          a7 = COERCE_DOUBLE(vmin_s32(vmax_s32((int32x2_t)__PAIR64__((uint64_t)rint((float)(v16 + (float)((float)LODWORD(v25) * v15))), v26), 0), (int32x2_t)0xFF000000FFLL));
          v23[3] = BYTE4(a7);
          v23[2] = LOBYTE(a7);
          v19 += 4;
          v20 += 4;
        }
        while (v19 <= v14 - 4);
        v19 = v19;
      }
      else
      {
        v19 = 0;
      }
      if ((int)v19 < (int)v14)
      {
        do
        {
          LOWORD(a7) = *(_WORD *)(result + 2 * v19);
          a7 = rint((float)(v16 + (float)((float)LODWORD(a7) * v15)));
          v27 = (uint64_t)a7 & ~((int)(uint64_t)a7 >> 31);
          if (v27 >= 255)
            LOBYTE(v27) = -1;
          *(_BYTE *)(a10 + v19++) = v27;
        }
        while (v19 < v14);
      }
      a10 += a11;
      v17 = (__int16 *)((char *)v17 + v18);
      result += v18;
      --v13;
    }
    while (v13);
  }
  return result;
}

uint64_t cv::cvtScale16s8u(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7, double *a8)
{
  int v8;
  uint64_t v9;
  float v10;
  float v11;
  __int16 *v12;
  uint64_t v13;
  uint64_t v14;
  __int16 *v15;
  _BYTE *v16;
  int32x2_t v17;
  int32x2_t v18;
  double v19;
  int v20;

  v8 = a7[1];
  if (v8)
  {
    v9 = *a7;
    v10 = *a8;
    v11 = a8[1];
    v12 = (__int16 *)(result + 4);
    v13 = 2 * (a2 >> 1);
    do
    {
      if ((int)v9 >= 4)
      {
        v14 = 0;
        v15 = v12;
        do
        {
          v16 = (_BYTE *)(a5 + v14);
          v17 = vmin_s32(vmax_s32((int32x2_t)__PAIR64__((uint64_t)rint((float)(v11 + (float)((float)*(v15 - 1) * v10))), (uint64_t)rint((float)(v11 + (float)((float)*(v15 - 2) * v10)))), 0), (int32x2_t)0xFF000000FFLL);
          v16[1] = v17.i8[4];
          *v16 = v17.i8[0];
          v18 = vmin_s32(vmax_s32((int32x2_t)__PAIR64__((uint64_t)rint((float)(v11 + (float)((float)v15[1] * v10))), (uint64_t)rint((float)(v11 + (float)((float)*v15 * v10)))), 0), (int32x2_t)0xFF000000FFLL);
          v16[3] = v18.i8[4];
          v16[2] = v18.i8[0];
          v14 += 4;
          v15 += 4;
        }
        while (v14 <= v9 - 4);
        v14 = v14;
      }
      else
      {
        v14 = 0;
      }
      if ((int)v14 < (int)v9)
      {
        do
        {
          v19 = rint((float)(v11 + (float)((float)*(__int16 *)(result + 2 * v14) * v10)));
          v20 = (uint64_t)v19 & ~((int)(uint64_t)v19 >> 31);
          if (v20 >= 255)
            LOBYTE(v20) = -1;
          *(_BYTE *)(a5 + v14++) = v20;
        }
        while (v14 < v9);
      }
      a5 += a6;
      v12 = (__int16 *)((char *)v12 + v13);
      result += v13;
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t cv::cvtScale32s8u(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7, double *a8)
{
  int v8;
  uint64_t v9;
  float v10;
  float v11;
  __int32 *v12;
  uint64_t v13;
  uint64_t v14;
  __int32 *v15;
  _BYTE *v16;
  int32x2_t v17;
  int v18;
  int32x2_t v19;
  double v20;
  int v21;

  v8 = a7[1];
  if (v8)
  {
    v9 = *a7;
    v10 = *a8;
    v11 = a8[1];
    v12 = (__int32 *)(result + 8);
    v13 = 4 * (a2 >> 2);
    do
    {
      if ((int)v9 >= 4)
      {
        v14 = 0;
        v15 = v12;
        do
        {
          v16 = (_BYTE *)(a5 + v14);
          v17 = vmin_s32(vmax_s32((int32x2_t)__PAIR64__((uint64_t)rint((float)(v11 + (float)((float)*(v15 - 1) * v10))), (uint64_t)rint((float)(v11 + (float)((float)*(v15 - 2) * v10)))), 0), (int32x2_t)0xFF000000FFLL);
          v16[1] = v17.i8[4];
          *v16 = v17.i8[0];
          v17.i32[0] = *v15;
          v18 = v15[1];
          v15 += 4;
          v19 = vmin_s32(vmax_s32((int32x2_t)__PAIR64__((uint64_t)rint((float)(v11 + (float)((float)v18 * v10))), (uint64_t)rint((float)(v11 + (float)((float)v17.i32[0] * v10)))), 0), (int32x2_t)0xFF000000FFLL);
          v16[3] = v19.i8[4];
          v16[2] = v19.i8[0];
          v14 += 4;
        }
        while (v14 <= v9 - 4);
        v14 = v14;
      }
      else
      {
        v14 = 0;
      }
      if ((int)v14 < (int)v9)
      {
        do
        {
          v20 = rint((float)(v11 + (float)((float)*(int *)(result + 4 * v14) * v10)));
          v21 = (uint64_t)v20 & ~((int)(uint64_t)v20 >> 31);
          if (v21 >= 255)
            LOBYTE(v21) = -1;
          *(_BYTE *)(a5 + v14++) = v21;
        }
        while (v14 < v9);
      }
      a5 += a6;
      v12 = (__int32 *)((char *)v12 + v13);
      result += v13;
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t cv::cvtScale32f8u(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7, double *a8)
{
  int v8;
  uint64_t v9;
  float v10;
  float v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _BYTE *v16;
  int32x2_t v17;
  float v18;
  int32x2_t v19;
  double v20;
  int v21;

  v8 = a7[1];
  if (v8)
  {
    v9 = *a7;
    v10 = *a8;
    v11 = a8[1];
    v12 = result + 8;
    v13 = 4 * (a2 >> 2);
    do
    {
      if ((int)v9 >= 4)
      {
        v14 = 0;
        v15 = v12;
        do
        {
          v16 = (_BYTE *)(a5 + v14);
          v17 = vmin_s32(vmax_s32((int32x2_t)__PAIR64__((uint64_t)rint((float)(v11 + (float)(*(float *)(v15 - 4) * v10))), (uint64_t)rint((float)(v11 + (float)(*(float *)(v15 - 8) * v10)))), 0), (int32x2_t)0xFF000000FFLL);
          v16[1] = v17.i8[4];
          *v16 = v17.i8[0];
          v17.i32[0] = *(_DWORD *)v15;
          v18 = *(float *)(v15 + 4);
          v15 += 16;
          v19 = vmin_s32(vmax_s32((int32x2_t)__PAIR64__((uint64_t)rint((float)(v11 + (float)(v18 * v10))), (uint64_t)rint((float)(v11 + (float)(*(float *)v17.i32 * v10)))), 0), (int32x2_t)0xFF000000FFLL);
          v16[3] = v19.i8[4];
          v16[2] = v19.i8[0];
          v14 += 4;
        }
        while (v14 <= v9 - 4);
        v14 = v14;
      }
      else
      {
        v14 = 0;
      }
      if ((int)v14 < (int)v9)
      {
        do
        {
          v20 = rint((float)(v11 + (float)(*(float *)(result + 4 * v14) * v10)));
          v21 = (uint64_t)v20 & ~((int)(uint64_t)v20 >> 31);
          if (v21 >= 255)
            LOBYTE(v21) = -1;
          *(_BYTE *)(a5 + v14++) = v21;
        }
        while (v14 < v9);
      }
      a5 += a6;
      v12 += v13;
      result += v13;
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t cv::cvtScale64f8u(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7, double *a8)
{
  int v8;
  uint64_t v9;
  float v10;
  float v11;
  double v12;
  double v13;
  double *v14;
  uint64_t v15;
  uint64_t v16;
  double *v17;
  _BYTE *v18;
  int32x2_t v19;
  double v20;
  double v21;
  int32x2_t v22;
  double v23;
  int v24;

  v8 = a7[1];
  if (v8)
  {
    v9 = *a7;
    v10 = a8[1];
    v11 = *a8;
    v12 = v11;
    v13 = v10;
    v14 = (double *)(result + 16);
    v15 = 8 * (a2 >> 3);
    do
    {
      if ((int)v9 >= 4)
      {
        v16 = 0;
        v17 = v14;
        do
        {
          v18 = (_BYTE *)(a5 + v16);
          v19 = vmin_s32(vmax_s32((int32x2_t)__PAIR64__((uint64_t)rint(v13 + *(v17 - 1) * v12), (uint64_t)rint(v13 + *(v17 - 2) * v12)), 0), (int32x2_t)0xFF000000FFLL);
          v18[1] = v19.i8[4];
          *v18 = v19.i8[0];
          v20 = *v17;
          v21 = v17[1];
          v17 += 4;
          v22 = vmin_s32(vmax_s32((int32x2_t)__PAIR64__((uint64_t)rint(v13 + v21 * v12), (uint64_t)rint(v13 + v20 * v12)), 0), (int32x2_t)0xFF000000FFLL);
          v18[3] = v22.i8[4];
          v18[2] = v22.i8[0];
          v16 += 4;
        }
        while (v16 <= v9 - 4);
        v16 = v16;
      }
      else
      {
        v16 = 0;
      }
      if ((int)v16 < (int)v9)
      {
        do
        {
          v23 = rint(v13 + *(double *)(result + 8 * v16) * v12);
          v24 = (uint64_t)v23 & ~((int)(uint64_t)v23 >> 31);
          if (v24 >= 255)
            LOBYTE(v24) = -1;
          *(_BYTE *)(a5 + v16++) = v24;
        }
        while (v16 < v9);
      }
      a5 += a6;
      v14 = (double *)((char *)v14 + v15);
      result += v15;
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t cv::cvtScale8u8s(uint64_t result, uint64_t a2, double a3, double a4, double a5, double a6, double a7, float a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int *a13, double *a14)
{
  int v14;
  uint64_t v15;
  float v16;
  float v17;
  uint64_t v18;
  double v19;
  int32x2_t v20;
  _BYTE *v21;
  uint64_t v22;

  v14 = a13[1];
  if (v14)
  {
    v15 = *a13;
    v16 = *a14;
    v17 = a14[1];
    do
    {
      if ((int)v15 >= 4)
      {
        v18 = 0;
        do
        {
          LOBYTE(a7) = *(_BYTE *)(result + v18);
          LOBYTE(a8) = *(_BYTE *)(result + v18 + 1);
          v19 = (float)(v17 + (float)((float)LODWORD(a8) * v16));
          v20 = vmin_s32(vmax_s32((int32x2_t)__PAIR64__((uint64_t)rint(v19), (uint64_t)rint((float)(v17 + (float)((float)LODWORD(a7) * v16)))), (int32x2_t)0x7F0000007FLL), (int32x2_t)0x7F0000007FLL);
          v21 = (_BYTE *)(a11 + v18);
          v21[1] = v20.i8[4];
          *v21 = v20.i8[0];
          v20.i8[0] = *(_BYTE *)(result + v18 + 2);
          LOBYTE(v19) = *(_BYTE *)(result + v18 + 3);
          a8 = (float)LODWORD(v19);
          a7 = COERCE_DOUBLE(vmin_s32(vmax_s32((int32x2_t)__PAIR64__((uint64_t)rint((float)(v17 + (float)(a8 * v16))), (uint64_t)rint((float)(v17 + (float)((float)v20.u32[0] * v16)))), (int32x2_t)0x7F0000007FLL), (int32x2_t)0x7F0000007FLL));
          v21[3] = BYTE4(a7);
          v21[2] = LOBYTE(a7);
          v18 += 4;
        }
        while (v18 <= v15 - 4);
        v18 = v18;
      }
      else
      {
        v18 = 0;
      }
      if ((int)v18 < (int)v15)
      {
        do
        {
          LOBYTE(a7) = *(_BYTE *)(result + v18);
          a7 = rint((float)(v17 + (float)((float)LODWORD(a7) * v16)));
          v22 = (uint64_t)a7;
          if ((int)(uint64_t)a7 <= -128)
            LODWORD(v22) = -128;
          if ((int)v22 >= 127)
            LOBYTE(v22) = 127;
          *(_BYTE *)(a11 + v18++) = v22;
        }
        while (v18 < v15);
      }
      result += a2;
      a11 += a12;
      --v14;
    }
    while (v14);
  }
  return result;
}

uint64_t cv::cvtScale8s(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7, double *a8)
{
  int v8;
  uint64_t v9;
  float v10;
  float v11;
  uint64_t v12;
  int32x2_t v13;
  _BYTE *v14;
  int32x2_t v15;
  int32x2_t v16;
  uint64_t v17;

  v8 = a7[1];
  if (v8)
  {
    v9 = *a7;
    v10 = *a8;
    v11 = a8[1];
    do
    {
      if ((int)v9 >= 4)
      {
        v12 = 0;
        do
        {
          v13.i32[0] = (uint64_t)rint((float)(v11 + (float)((float)*(char *)(result + v12) * v10)));
          v13.i32[1] = (uint64_t)rint((float)(v11 + (float)((float)*(char *)(result + v12 + 1) * v10)));
          v14 = (_BYTE *)(a5 + v12);
          v15 = vmin_s32(vmax_s32(v13, (int32x2_t)0x7F0000007FLL), (int32x2_t)0x7F0000007FLL);
          v14[1] = v15.i8[4];
          *v14 = v15.i8[0];
          v16 = vmin_s32(vmax_s32((int32x2_t)__PAIR64__((uint64_t)rint((float)(v11 + (float)((float)*(char *)(result + v12 + 3) * v10))), (uint64_t)rint((float)(v11 + (float)((float)*(char *)(result + v12 + 2) * v10)))), (int32x2_t)0x7F0000007FLL), (int32x2_t)0x7F0000007FLL);
          v14[3] = v16.i8[4];
          v14[2] = v16.i8[0];
          v12 += 4;
        }
        while (v12 <= v9 - 4);
        v12 = v12;
      }
      else
      {
        v12 = 0;
      }
      if ((int)v12 < (int)v9)
      {
        do
        {
          v17 = (uint64_t)rint((float)(v11 + (float)((float)*(char *)(result + v12) * v10)));
          if ((int)v17 <= -128)
            LODWORD(v17) = -128;
          if ((int)v17 >= 127)
            LOBYTE(v17) = 127;
          *(_BYTE *)(a5 + v12++) = v17;
        }
        while (v12 < v9);
      }
      result += a2;
      a5 += a6;
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t cv::cvtScale16u8s(uint64_t result, unint64_t a2, double a3, double a4, double a5, double a6, double a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int *a12, double *a13)
{
  int v13;
  uint64_t v14;
  float v15;
  float v16;
  __int16 *v17;
  uint64_t v18;
  uint64_t v19;
  __int16 *v20;
  double v21;
  uint64_t v22;
  _BYTE *v23;
  int32x2_t v24;
  double v25;
  uint64_t v26;
  uint64_t v27;

  v13 = a12[1];
  if (v13)
  {
    v14 = *a12;
    v15 = *a13;
    v16 = a13[1];
    v17 = (__int16 *)(result + 4);
    v18 = 2 * (a2 >> 1);
    do
    {
      if ((int)v14 >= 4)
      {
        v19 = 0;
        v20 = v17;
        do
        {
          LOWORD(a7) = *(v20 - 2);
          v21 = rint((float)(v16 + (float)((float)LODWORD(a7) * v15)));
          v22 = (uint64_t)v21;
          LOWORD(v21) = *(v20 - 1);
          v23 = (_BYTE *)(a10 + v19);
          v24 = vmin_s32(vmax_s32((int32x2_t)__PAIR64__((uint64_t)rint((float)(v16 + (float)((float)LODWORD(v21) * v15))), v22), (int32x2_t)0x7F0000007FLL), (int32x2_t)0x7F0000007FLL);
          v23[1] = v24.i8[4];
          *v23 = v24.i8[0];
          v24.i16[0] = *v20;
          v25 = rint((float)(v16 + (float)((float)v24.u32[0] * v15)));
          v26 = (uint64_t)v25;
          LOWORD(v25) = v20[1];
          a7 = COERCE_DOUBLE(vmin_s32(vmax_s32((int32x2_t)__PAIR64__((uint64_t)rint((float)(v16 + (float)((float)LODWORD(v25) * v15))), v26), (int32x2_t)0x7F0000007FLL), (int32x2_t)0x7F0000007FLL));
          v23[3] = BYTE4(a7);
          v23[2] = LOBYTE(a7);
          v19 += 4;
          v20 += 4;
        }
        while (v19 <= v14 - 4);
        v19 = v19;
      }
      else
      {
        v19 = 0;
      }
      if ((int)v19 < (int)v14)
      {
        do
        {
          LOWORD(a7) = *(_WORD *)(result + 2 * v19);
          a7 = rint((float)(v16 + (float)((float)LODWORD(a7) * v15)));
          v27 = (uint64_t)a7;
          if ((int)(uint64_t)a7 <= -128)
            LODWORD(v27) = -128;
          if ((int)v27 >= 127)
            LOBYTE(v27) = 127;
          *(_BYTE *)(a10 + v19++) = v27;
        }
        while (v19 < v14);
      }
      a10 += a11;
      v17 = (__int16 *)((char *)v17 + v18);
      result += v18;
      --v13;
    }
    while (v13);
  }
  return result;
}

uint64_t cv::cvtScale16s8s(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7, double *a8)
{
  int v8;
  uint64_t v9;
  float v10;
  float v11;
  __int16 *v12;
  uint64_t v13;
  uint64_t v14;
  __int16 *v15;
  _BYTE *v16;
  int32x2_t v17;
  int32x2_t v18;
  uint64_t v19;

  v8 = a7[1];
  if (v8)
  {
    v9 = *a7;
    v10 = *a8;
    v11 = a8[1];
    v12 = (__int16 *)(result + 4);
    v13 = 2 * (a2 >> 1);
    do
    {
      if ((int)v9 >= 4)
      {
        v14 = 0;
        v15 = v12;
        do
        {
          v16 = (_BYTE *)(a5 + v14);
          v17 = vmin_s32(vmax_s32((int32x2_t)__PAIR64__((uint64_t)rint((float)(v11 + (float)((float)*(v15 - 1) * v10))), (uint64_t)rint((float)(v11 + (float)((float)*(v15 - 2) * v10)))), (int32x2_t)0x7F0000007FLL), (int32x2_t)0x7F0000007FLL);
          v16[1] = v17.i8[4];
          *v16 = v17.i8[0];
          v18 = vmin_s32(vmax_s32((int32x2_t)__PAIR64__((uint64_t)rint((float)(v11 + (float)((float)v15[1] * v10))), (uint64_t)rint((float)(v11 + (float)((float)*v15 * v10)))), (int32x2_t)0x7F0000007FLL), (int32x2_t)0x7F0000007FLL);
          v16[3] = v18.i8[4];
          v16[2] = v18.i8[0];
          v14 += 4;
          v15 += 4;
        }
        while (v14 <= v9 - 4);
        v14 = v14;
      }
      else
      {
        v14 = 0;
      }
      if ((int)v14 < (int)v9)
      {
        do
        {
          v19 = (uint64_t)rint((float)(v11 + (float)((float)*(__int16 *)(result + 2 * v14) * v10)));
          if ((int)v19 <= -128)
            LODWORD(v19) = -128;
          if ((int)v19 >= 127)
            LOBYTE(v19) = 127;
          *(_BYTE *)(a5 + v14++) = v19;
        }
        while (v14 < v9);
      }
      a5 += a6;
      v12 = (__int16 *)((char *)v12 + v13);
      result += v13;
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t cv::cvtScale32s8s(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7, double *a8)
{
  int v8;
  uint64_t v9;
  float v10;
  float v11;
  __int32 *v12;
  uint64_t v13;
  uint64_t v14;
  __int32 *v15;
  _BYTE *v16;
  int32x2_t v17;
  int v18;
  int32x2_t v19;
  uint64_t v20;

  v8 = a7[1];
  if (v8)
  {
    v9 = *a7;
    v10 = *a8;
    v11 = a8[1];
    v12 = (__int32 *)(result + 8);
    v13 = 4 * (a2 >> 2);
    do
    {
      if ((int)v9 >= 4)
      {
        v14 = 0;
        v15 = v12;
        do
        {
          v16 = (_BYTE *)(a5 + v14);
          v17 = vmin_s32(vmax_s32((int32x2_t)__PAIR64__((uint64_t)rint((float)(v11 + (float)((float)*(v15 - 1) * v10))), (uint64_t)rint((float)(v11 + (float)((float)*(v15 - 2) * v10)))), (int32x2_t)0x7F0000007FLL), (int32x2_t)0x7F0000007FLL);
          v16[1] = v17.i8[4];
          *v16 = v17.i8[0];
          v17.i32[0] = *v15;
          v18 = v15[1];
          v15 += 4;
          v19 = vmin_s32(vmax_s32((int32x2_t)__PAIR64__((uint64_t)rint((float)(v11 + (float)((float)v18 * v10))), (uint64_t)rint((float)(v11 + (float)((float)v17.i32[0] * v10)))), (int32x2_t)0x7F0000007FLL), (int32x2_t)0x7F0000007FLL);
          v16[3] = v19.i8[4];
          v16[2] = v19.i8[0];
          v14 += 4;
        }
        while (v14 <= v9 - 4);
        v14 = v14;
      }
      else
      {
        v14 = 0;
      }
      if ((int)v14 < (int)v9)
      {
        do
        {
          v20 = (uint64_t)rint((float)(v11 + (float)((float)*(int *)(result + 4 * v14) * v10)));
          if ((int)v20 <= -128)
            LODWORD(v20) = -128;
          if ((int)v20 >= 127)
            LOBYTE(v20) = 127;
          *(_BYTE *)(a5 + v14++) = v20;
        }
        while (v14 < v9);
      }
      a5 += a6;
      v12 = (__int32 *)((char *)v12 + v13);
      result += v13;
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t cv::cvtScale32f8s(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7, double *a8)
{
  int v8;
  uint64_t v9;
  float v10;
  float v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _BYTE *v16;
  int32x2_t v17;
  float v18;
  int32x2_t v19;
  uint64_t v20;

  v8 = a7[1];
  if (v8)
  {
    v9 = *a7;
    v10 = *a8;
    v11 = a8[1];
    v12 = result + 8;
    v13 = 4 * (a2 >> 2);
    do
    {
      if ((int)v9 >= 4)
      {
        v14 = 0;
        v15 = v12;
        do
        {
          v16 = (_BYTE *)(a5 + v14);
          v17 = vmin_s32(vmax_s32((int32x2_t)__PAIR64__((uint64_t)rint((float)(v11 + (float)(*(float *)(v15 - 4) * v10))), (uint64_t)rint((float)(v11 + (float)(*(float *)(v15 - 8) * v10)))), (int32x2_t)0x7F0000007FLL), (int32x2_t)0x7F0000007FLL);
          v16[1] = v17.i8[4];
          *v16 = v17.i8[0];
          v17.i32[0] = *(_DWORD *)v15;
          v18 = *(float *)(v15 + 4);
          v15 += 16;
          v19 = vmin_s32(vmax_s32((int32x2_t)__PAIR64__((uint64_t)rint((float)(v11 + (float)(v18 * v10))), (uint64_t)rint((float)(v11 + (float)(*(float *)v17.i32 * v10)))), (int32x2_t)0x7F0000007FLL), (int32x2_t)0x7F0000007FLL);
          v16[3] = v19.i8[4];
          v16[2] = v19.i8[0];
          v14 += 4;
        }
        while (v14 <= v9 - 4);
        v14 = v14;
      }
      else
      {
        v14 = 0;
      }
      if ((int)v14 < (int)v9)
      {
        do
        {
          v20 = (uint64_t)rint((float)(v11 + (float)(*(float *)(result + 4 * v14) * v10)));
          if ((int)v20 <= -128)
            LODWORD(v20) = -128;
          if ((int)v20 >= 127)
            LOBYTE(v20) = 127;
          *(_BYTE *)(a5 + v14++) = v20;
        }
        while (v14 < v9);
      }
      a5 += a6;
      v12 += v13;
      result += v13;
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t cv::cvtScale64f8s(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7, double *a8)
{
  int v8;
  uint64_t v9;
  float v10;
  float v11;
  double v12;
  double v13;
  double *v14;
  uint64_t v15;
  uint64_t v16;
  double *v17;
  _BYTE *v18;
  int32x2_t v19;
  double v20;
  double v21;
  int32x2_t v22;
  uint64_t v23;

  v8 = a7[1];
  if (v8)
  {
    v9 = *a7;
    v10 = a8[1];
    v11 = *a8;
    v12 = v11;
    v13 = v10;
    v14 = (double *)(result + 16);
    v15 = 8 * (a2 >> 3);
    do
    {
      if ((int)v9 >= 4)
      {
        v16 = 0;
        v17 = v14;
        do
        {
          v18 = (_BYTE *)(a5 + v16);
          v19 = vmin_s32(vmax_s32((int32x2_t)__PAIR64__((uint64_t)rint(v13 + *(v17 - 1) * v12), (uint64_t)rint(v13 + *(v17 - 2) * v12)), (int32x2_t)0x7F0000007FLL), (int32x2_t)0x7F0000007FLL);
          v18[1] = v19.i8[4];
          *v18 = v19.i8[0];
          v20 = *v17;
          v21 = v17[1];
          v17 += 4;
          v22 = vmin_s32(vmax_s32((int32x2_t)__PAIR64__((uint64_t)rint(v13 + v21 * v12), (uint64_t)rint(v13 + v20 * v12)), (int32x2_t)0x7F0000007FLL), (int32x2_t)0x7F0000007FLL);
          v18[3] = v22.i8[4];
          v18[2] = v22.i8[0];
          v16 += 4;
        }
        while (v16 <= v9 - 4);
        v16 = v16;
      }
      else
      {
        v16 = 0;
      }
      if ((int)v16 < (int)v9)
      {
        do
        {
          v23 = (uint64_t)rint(v13 + *(double *)(result + 8 * v16) * v12);
          if ((int)v23 <= -128)
            LODWORD(v23) = -128;
          if ((int)v23 >= 127)
            LOBYTE(v23) = 127;
          *(_BYTE *)(a5 + v16++) = v23;
        }
        while (v16 < v9);
      }
      a5 += a6;
      v14 = (double *)((char *)v14 + v15);
      result += v15;
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t cv::cvtScale8u16u(uint64_t result, uint64_t a2, double a3, double a4, double a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int *a10, double *a11)
{
  int v11;
  uint64_t v12;
  uint64_t v13;
  float v14;
  float v15;
  _WORD *v16;
  uint64_t v17;
  uint64_t v18;
  _WORD *v19;
  _BYTE *v20;
  double v21;
  int v22;
  double v23;
  int v24;
  double v25;
  int v26;
  int v27;
  int v28;

  v11 = a10[1];
  if (v11)
  {
    v12 = (int)*a10;
    v13 = *a10;
    v14 = *a11;
    v15 = a11[1];
    v16 = (_WORD *)(a8 + 4);
    v17 = 2 * (a9 >> 1);
    do
    {
      if ((int)v12 >= 4)
      {
        v18 = 0;
        v19 = v16;
        do
        {
          v20 = (_BYTE *)(result + v18);
          LOBYTE(a5) = *(_BYTE *)(result + v18);
          v21 = rint((float)(v15 + (float)((float)LODWORD(a5) * v14)));
          v22 = (uint64_t)v21 & ~((int)(uint64_t)v21 >> 31);
          if (v22 >= 0xFFFF)
            LOWORD(v22) = -1;
          LOBYTE(v21) = v20[1];
          v23 = rint((float)(v15 + (float)((float)LODWORD(v21) * v14)));
          v24 = (uint64_t)v23 & ~((int)(uint64_t)v23 >> 31);
          if (v24 >= 0xFFFF)
            LOWORD(v24) = -1;
          *(v19 - 2) = v22;
          *(v19 - 1) = v24;
          LOBYTE(v23) = v20[2];
          v25 = rint((float)(v15 + (float)((float)LODWORD(v23) * v14)));
          v26 = (uint64_t)v25 & ~((int)(uint64_t)v25 >> 31);
          if (v26 >= 0xFFFF)
            LOWORD(v26) = -1;
          LOBYTE(v25) = v20[3];
          a5 = rint((float)(v15 + (float)((float)LODWORD(v25) * v14)));
          v27 = (uint64_t)a5 & ~((int)(uint64_t)a5 >> 31);
          if (v27 >= 0xFFFF)
            LOWORD(v27) = -1;
          *v19 = v26;
          v19[1] = v27;
          v18 += 4;
          v19 += 4;
        }
        while (v18 <= v12 - 4);
        v18 = v18;
      }
      else
      {
        v18 = 0;
      }
      if ((int)v18 < (int)v13)
      {
        do
        {
          LOBYTE(a5) = *(_BYTE *)(result + v18);
          a5 = rint((float)(v15 + (float)((float)LODWORD(a5) * v14)));
          v28 = (uint64_t)a5 & ~((int)(uint64_t)a5 >> 31);
          if (v28 >= 0xFFFF)
            LOWORD(v28) = -1;
          *(_WORD *)(a8 + 2 * v18++) = v28;
        }
        while (v13 != v18);
      }
      result += a2;
      v16 = (_WORD *)((char *)v16 + v17);
      a8 += v17;
      --v11;
    }
    while (v11);
  }
  return result;
}

uint64_t cv::cvtScale8s16u(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, unsigned int *a7, double *a8)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  float v11;
  float v12;
  _WORD *v13;
  uint64_t v14;
  uint64_t v15;
  _WORD *v16;
  char *v17;
  double v18;
  int v19;
  double v20;
  int v21;
  double v22;
  int v23;
  double v24;
  int v25;
  double v26;
  int v27;

  v8 = a7[1];
  if (v8)
  {
    v9 = (int)*a7;
    v10 = *a7;
    v11 = *a8;
    v12 = a8[1];
    v13 = (_WORD *)(a5 + 4);
    v14 = 2 * (a6 >> 1);
    do
    {
      if ((int)v9 >= 4)
      {
        v15 = 0;
        v16 = v13;
        do
        {
          v17 = (char *)(result + v15);
          v18 = rint((float)(v12 + (float)((float)*(char *)(result + v15) * v11)));
          v19 = (uint64_t)v18 & ~((int)(uint64_t)v18 >> 31);
          if (v19 >= 0xFFFF)
            LOWORD(v19) = -1;
          v20 = rint((float)(v12 + (float)((float)v17[1] * v11)));
          v21 = (uint64_t)v20 & ~((int)(uint64_t)v20 >> 31);
          if (v21 >= 0xFFFF)
            LOWORD(v21) = -1;
          *(v16 - 2) = v19;
          *(v16 - 1) = v21;
          v22 = rint((float)(v12 + (float)((float)v17[2] * v11)));
          v23 = (uint64_t)v22 & ~((int)(uint64_t)v22 >> 31);
          if (v23 >= 0xFFFF)
            LOWORD(v23) = -1;
          v24 = rint((float)(v12 + (float)((float)v17[3] * v11)));
          v25 = (uint64_t)v24 & ~((int)(uint64_t)v24 >> 31);
          if (v25 >= 0xFFFF)
            LOWORD(v25) = -1;
          *v16 = v23;
          v16[1] = v25;
          v15 += 4;
          v16 += 4;
        }
        while (v15 <= v9 - 4);
        v15 = v15;
      }
      else
      {
        v15 = 0;
      }
      if ((int)v15 < (int)v10)
      {
        do
        {
          v26 = rint((float)(v12 + (float)((float)*(char *)(result + v15) * v11)));
          v27 = (uint64_t)v26 & ~((int)(uint64_t)v26 >> 31);
          if (v27 >= 0xFFFF)
            LOWORD(v27) = -1;
          *(_WORD *)(a5 + 2 * v15++) = v27;
        }
        while (v10 != v15);
      }
      result += a2;
      v13 = (_WORD *)((char *)v13 + v14);
      a5 += v14;
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t cv::cvtScale16u(uint64_t result, unint64_t a2, double a3, double a4, double a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int *a10, double *a11)
{
  int v11;
  uint64_t v12;
  uint64_t v13;
  float v14;
  float v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  double v20;
  int v21;
  double v22;
  int v23;
  _WORD *v24;
  double v25;
  int v26;
  float v27;
  __int16 v28;
  int v29;
  int v30;

  v11 = a10[1];
  if (v11)
  {
    v12 = (int)*a10;
    v13 = *a10;
    v14 = *a11;
    v15 = a11[1];
    v16 = 2 * (a2 >> 1);
    do
    {
      if ((int)v12 >= 4)
      {
        v18 = 0;
        v17 = 0;
        do
        {
          v19 = result + v18;
          LOWORD(a5) = *(_WORD *)(result + v18);
          v20 = rint((float)(v15 + (float)((float)LODWORD(a5) * v14)));
          v21 = (uint64_t)v20 & ~((int)(uint64_t)v20 >> 31);
          LOWORD(v20) = *(_WORD *)(result + v18 + 2);
          v22 = rint((float)(v15 + (float)((float)LODWORD(v20) * v14)));
          v23 = (uint64_t)v22 & ~((int)(uint64_t)v22 >> 31);
          if (v21 >= 0xFFFF)
            LOWORD(v21) = -1;
          if (v23 >= 0xFFFF)
            LOWORD(v23) = -1;
          v24 = (_WORD *)(a8 + v18);
          *v24 = v21;
          v24[1] = v23;
          LOWORD(v22) = *(_WORD *)(v19 + 4);
          v25 = rint((float)(v15 + (float)((float)LODWORD(v22) * v14)));
          v26 = (uint64_t)v25 & ~((int)(uint64_t)v25 >> 31);
          LOWORD(v25) = *(_WORD *)(v19 + 6);
          v27 = v15 + (float)((float)LODWORD(v25) * v14);
          if (v26 >= 0xFFFF)
            v28 = -1;
          else
            v28 = v26;
          a5 = rint(v27);
          v29 = (uint64_t)a5 & ~((int)(uint64_t)a5 >> 31);
          if (v29 >= 0xFFFF)
            LOWORD(v29) = -1;
          v24[2] = v28;
          v24[3] = v29;
          v17 += 4;
          v18 += 8;
        }
        while (v17 <= v12 - 4);
        v17 = v17;
      }
      else
      {
        v17 = 0;
      }
      if ((int)v17 < (int)v13)
      {
        do
        {
          LOWORD(a5) = *(_WORD *)(result + 2 * v17);
          a5 = rint((float)(v15 + (float)((float)LODWORD(a5) * v14)));
          v30 = (uint64_t)a5 & ~((int)(uint64_t)a5 >> 31);
          if (v30 >= 0xFFFF)
            LOWORD(v30) = -1;
          *(_WORD *)(a8 + 2 * v17++) = v30;
        }
        while (v13 != v17);
      }
      a8 += 2 * (a9 >> 1);
      result += v16;
      --v11;
    }
    while (v11);
  }
  return result;
}

uint64_t cv::cvtScale16s16u(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, unsigned int *a7, double *a8)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  float v11;
  float v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  double v17;
  int v18;
  double v19;
  int v20;
  _WORD *v21;
  double v22;
  int v23;
  float v24;
  __int16 v25;
  double v26;
  int v27;
  double v28;
  int v29;

  v8 = a7[1];
  if (v8)
  {
    v9 = (int)*a7;
    v10 = *a7;
    v11 = *a8;
    v12 = a8[1];
    v13 = 2 * (a2 >> 1);
    do
    {
      if ((int)v9 >= 4)
      {
        v15 = 0;
        v14 = 0;
        do
        {
          v16 = result + v15;
          v17 = rint((float)(v12 + (float)((float)*(__int16 *)(result + v15) * v11)));
          v18 = (uint64_t)v17 & ~((int)(uint64_t)v17 >> 31);
          if (v18 >= 0xFFFF)
            LOWORD(v18) = -1;
          v19 = rint((float)(v12 + (float)((float)*(__int16 *)(result + v15 + 2) * v11)));
          v20 = (uint64_t)v19 & ~((int)(uint64_t)v19 >> 31);
          if (v20 >= 0xFFFF)
            LOWORD(v20) = -1;
          v21 = (_WORD *)(a5 + v15);
          *v21 = v18;
          v21[1] = v20;
          v22 = rint((float)(v12 + (float)((float)*(__int16 *)(v16 + 4) * v11)));
          v23 = (uint64_t)v22 & ~((int)(uint64_t)v22 >> 31);
          v24 = v12 + (float)((float)*(__int16 *)(v16 + 6) * v11);
          if (v23 >= 0xFFFF)
            v25 = -1;
          else
            v25 = v23;
          v26 = rint(v24);
          v27 = (uint64_t)v26 & ~((int)(uint64_t)v26 >> 31);
          if (v27 >= 0xFFFF)
            LOWORD(v27) = -1;
          v21[2] = v25;
          v21[3] = v27;
          v14 += 4;
          v15 += 8;
        }
        while (v14 <= v9 - 4);
        v14 = v14;
      }
      else
      {
        v14 = 0;
      }
      if ((int)v14 < (int)v10)
      {
        do
        {
          v28 = rint((float)(v12 + (float)((float)*(__int16 *)(result + 2 * v14) * v11)));
          v29 = (uint64_t)v28 & ~((int)(uint64_t)v28 >> 31);
          if (v29 >= 0xFFFF)
            LOWORD(v29) = -1;
          *(_WORD *)(a5 + 2 * v14++) = v29;
        }
        while (v10 != v14);
      }
      a5 += 2 * (a6 >> 1);
      result += v13;
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t cv::cvtScale32s16u(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, int16x4_t *a5, unint64_t a6, unsigned int *a7, double *a8)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  float v11;
  float v12;
  int *v13;
  uint64_t v14;
  int32x4_t v15;
  uint64_t v16;
  int *v17;
  int16x4_t *v18;
  double v19;
  uint64_t v20;
  int v21;
  int v22;
  int32x4_t v23;
  double v24;
  int v25;

  v8 = a7[1];
  if (v8)
  {
    v9 = (int)*a7;
    v10 = *a7;
    v11 = *a8;
    v12 = a8[1];
    v13 = (int *)(result + 8);
    v14 = 4 * (a2 >> 2);
    v15.i64[0] = 0xFFFF0000FFFFLL;
    v15.i64[1] = 0xFFFF0000FFFFLL;
    do
    {
      if ((int)v9 >= 4)
      {
        v16 = 0;
        v17 = v13;
        v18 = a5;
        do
        {
          v19 = rint((float)(v12 + (float)((float)*(v17 - 1) * v11)));
          v20 = (uint64_t)rint((float)(v12 + (float)((float)*(v17 - 2) * v11)));
          v22 = *v17;
          v21 = v17[1];
          v17 += 4;
          v23.i64[0] = __PAIR64__((uint64_t)v19, v20);
          v23.i32[2] = (uint64_t)rint((float)(v12 + (float)((float)v22 * v11)));
          v23.i32[3] = (uint64_t)rint((float)(v12 + (float)((float)v21 * v11)));
          *v18++ = vmovn_s32(vminq_s32(vmaxq_s32(v23, (int32x4_t)0), v15));
          v16 += 4;
        }
        while (v16 <= v9 - 4);
        v16 = v16;
      }
      else
      {
        v16 = 0;
      }
      if ((int)v16 < (int)v10)
      {
        do
        {
          v24 = rint((float)(v12 + (float)((float)*(int *)(result + 4 * v16) * v11)));
          v25 = (uint64_t)v24 & ~((int)(uint64_t)v24 >> 31);
          if (v25 >= 0xFFFF)
            LOWORD(v25) = -1;
          a5->i16[v16++] = v25;
        }
        while (v10 != v16);
      }
      a5 = (int16x4_t *)((char *)a5 + 2 * (a6 >> 1));
      v13 = (int *)((char *)v13 + v14);
      result += v14;
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t cv::cvtScale32f16u(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, int16x4_t *a5, unint64_t a6, unsigned int *a7, double *a8)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  float v11;
  float v12;
  uint64_t v13;
  float *v14;
  uint64_t v15;
  int32x4_t v16;
  uint64_t v17;
  float *v18;
  int16x4_t *v19;
  uint64_t v20;
  double v21;
  float v22;
  float v23;
  uint64_t v24;
  int32x4_t v25;
  double v26;
  int v27;

  v8 = a7[1];
  if (v8)
  {
    v9 = (int)*a7;
    v10 = *a7;
    v11 = *a8;
    v12 = a8[1];
    v13 = 2 * (a6 >> 1);
    v14 = (float *)(result + 8);
    v15 = 4 * (a2 >> 2);
    v16.i64[0] = 0xFFFF0000FFFFLL;
    v16.i64[1] = 0xFFFF0000FFFFLL;
    do
    {
      if ((int)v9 >= 4)
      {
        v17 = 0;
        v18 = v14;
        v19 = a5;
        do
        {
          v20 = (uint64_t)rint((float)(v12 + (float)(*(v18 - 2) * v11)));
          v21 = rint((float)(v12 + (float)(*(v18 - 1) * v11)));
          v22 = *v18;
          v23 = v18[1];
          v18 += 4;
          v24 = (uint64_t)rint((float)(v12 + (float)(v22 * v11)));
          v25.i32[0] = v20;
          v25.i32[1] = (uint64_t)v21;
          v25.i32[2] = v24;
          v25.i32[3] = (uint64_t)rint((float)(v12 + (float)(v23 * v11)));
          *v19++ = vmovn_s32(vminq_s32(vmaxq_s32(v25, (int32x4_t)0), v16));
          v17 += 4;
        }
        while (v17 <= v9 - 4);
        v17 = v17;
      }
      else
      {
        v17 = 0;
      }
      if ((int)v17 < (int)v10)
      {
        do
        {
          v26 = rint((float)(v12 + (float)(*(float *)(result + 4 * v17) * v11)));
          v27 = (uint64_t)v26 & ~((int)(uint64_t)v26 >> 31);
          if (v27 >= 0xFFFF)
            LOWORD(v27) = -1;
          a5->i16[v17++] = v27;
        }
        while (v10 != v17);
      }
      a5 = (int16x4_t *)((char *)a5 + v13);
      v14 = (float *)((char *)v14 + v15);
      result += v15;
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t cv::cvtScale64f16u(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, int16x4_t *a5, unint64_t a6, unsigned int *a7, double *a8)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  float v11;
  float v12;
  double v13;
  double v14;
  uint64_t v15;
  double *v16;
  uint64_t v17;
  int32x4_t v18;
  uint64_t v19;
  double *v20;
  int16x4_t *v21;
  uint64_t v22;
  uint64_t v23;
  double v24;
  double v25;
  uint64_t v26;
  int32x4_t v27;
  double v28;
  int v29;

  v8 = a7[1];
  if (v8)
  {
    v9 = (int)*a7;
    v10 = *a7;
    v11 = a8[1];
    v12 = *a8;
    v13 = v12;
    v14 = v11;
    v15 = 2 * (a6 >> 1);
    v16 = (double *)(result + 16);
    v17 = 8 * (a2 >> 3);
    v18.i64[0] = 0xFFFF0000FFFFLL;
    v18.i64[1] = 0xFFFF0000FFFFLL;
    do
    {
      if ((int)v9 >= 4)
      {
        v19 = 0;
        v20 = v16;
        v21 = a5;
        do
        {
          v22 = (uint64_t)rint(v14 + *(v20 - 2) * v13);
          v23 = (uint64_t)rint(v14 + *(v20 - 1) * v13);
          v25 = *v20;
          v24 = v20[1];
          v20 += 4;
          v26 = (uint64_t)rint(v14 + v25 * v13);
          v27.i64[0] = __PAIR64__(v23, v22);
          v27.i32[2] = v26;
          v27.i32[3] = (uint64_t)rint(v14 + v24 * v13);
          *v21++ = vmovn_s32(vminq_s32(vmaxq_s32(v27, (int32x4_t)0), v18));
          v19 += 4;
        }
        while (v19 <= v9 - 4);
        v19 = v19;
      }
      else
      {
        v19 = 0;
      }
      if ((int)v19 < (int)v10)
      {
        do
        {
          v28 = rint(v14 + *(double *)(result + 8 * v19) * v13);
          v29 = (uint64_t)v28 & ~((int)(uint64_t)v28 >> 31);
          if (v29 >= 0xFFFF)
            LOWORD(v29) = -1;
          a5->i16[v19++] = v29;
        }
        while (v10 != v19);
      }
      a5 = (int16x4_t *)((char *)a5 + v15);
      v16 = (double *)((char *)v16 + v17);
      result += v17;
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t cv::cvtScale8u16s(uint64_t result, uint64_t a2, double a3, double a4, double a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int *a10, double *a11)
{
  int v11;
  uint64_t v12;
  uint64_t v13;
  float v14;
  float v15;
  _WORD *v16;
  uint64_t v17;
  uint64_t v18;
  _WORD *v19;
  _BYTE *v20;
  double v21;
  uint64_t v22;
  double v23;
  uint64_t v24;
  double v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  v11 = a10[1];
  if (v11)
  {
    v12 = (int)*a10;
    v13 = *a10;
    v14 = *a11;
    v15 = a11[1];
    v16 = (_WORD *)(a8 + 4);
    v17 = 2 * (a9 >> 1);
    do
    {
      if ((int)v12 >= 4)
      {
        v18 = 0;
        v19 = v16;
        do
        {
          v20 = (_BYTE *)(result + v18);
          LOBYTE(a5) = *(_BYTE *)(result + v18);
          v21 = rint((float)(v15 + (float)((float)LODWORD(a5) * v14)));
          v22 = (uint64_t)v21;
          if ((int)(uint64_t)v21 <= -32768)
            LODWORD(v22) = -32768;
          if ((int)v22 >= 0x7FFF)
            LOWORD(v22) = 0x7FFF;
          LOBYTE(v21) = v20[1];
          v23 = rint((float)(v15 + (float)((float)LODWORD(v21) * v14)));
          v24 = (uint64_t)v23;
          if ((int)(uint64_t)v23 <= -32768)
            LODWORD(v24) = -32768;
          if ((int)v24 >= 0x7FFF)
            LOWORD(v24) = 0x7FFF;
          *(v19 - 2) = v22;
          *(v19 - 1) = v24;
          LOBYTE(v23) = v20[2];
          v25 = rint((float)(v15 + (float)((float)LODWORD(v23) * v14)));
          v26 = (uint64_t)v25;
          if ((int)(uint64_t)v25 <= -32768)
            LODWORD(v26) = -32768;
          if ((int)v26 >= 0x7FFF)
            LOWORD(v26) = 0x7FFF;
          LOBYTE(v25) = v20[3];
          a5 = rint((float)(v15 + (float)((float)LODWORD(v25) * v14)));
          v27 = (uint64_t)a5;
          if ((int)(uint64_t)a5 <= -32768)
            LODWORD(v27) = -32768;
          if ((int)v27 >= 0x7FFF)
            LOWORD(v27) = 0x7FFF;
          *v19 = v26;
          v19[1] = v27;
          v18 += 4;
          v19 += 4;
        }
        while (v18 <= v12 - 4);
        v18 = v18;
      }
      else
      {
        v18 = 0;
      }
      if ((int)v18 < (int)v13)
      {
        do
        {
          LOBYTE(a5) = *(_BYTE *)(result + v18);
          a5 = rint((float)(v15 + (float)((float)LODWORD(a5) * v14)));
          v28 = (uint64_t)a5;
          if ((int)(uint64_t)a5 <= -32768)
            LODWORD(v28) = -32768;
          if ((int)v28 >= 0x7FFF)
            LOWORD(v28) = 0x7FFF;
          *(_WORD *)(a8 + 2 * v18++) = v28;
        }
        while (v13 != v18);
      }
      result += a2;
      v16 = (_WORD *)((char *)v16 + v17);
      a8 += v17;
      --v11;
    }
    while (v11);
  }
  return result;
}

uint64_t cv::cvtScale8s16s(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, unsigned int *a7, double *a8)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  float v11;
  float v12;
  _WORD *v13;
  uint64_t v14;
  uint64_t v15;
  _WORD *v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v8 = a7[1];
  if (v8)
  {
    v9 = (int)*a7;
    v10 = *a7;
    v11 = *a8;
    v12 = a8[1];
    v13 = (_WORD *)(a5 + 4);
    v14 = 2 * (a6 >> 1);
    do
    {
      if ((int)v9 >= 4)
      {
        v15 = 0;
        v16 = v13;
        do
        {
          v17 = (char *)(result + v15);
          v18 = (uint64_t)rint((float)(v12 + (float)((float)*(char *)(result + v15) * v11)));
          if ((int)v18 <= -32768)
            LODWORD(v18) = -32768;
          v19 = (uint64_t)rint((float)(v12 + (float)((float)v17[1] * v11)));
          if ((int)v18 >= 0x7FFF)
            LOWORD(v18) = 0x7FFF;
          if ((int)v19 <= -32768)
            LODWORD(v19) = -32768;
          if ((int)v19 >= 0x7FFF)
            LOWORD(v19) = 0x7FFF;
          *(v16 - 2) = v18;
          *(v16 - 1) = v19;
          v20 = (uint64_t)rint((float)(v12 + (float)((float)v17[2] * v11)));
          if ((int)v20 <= -32768)
            LODWORD(v20) = -32768;
          if ((int)v20 >= 0x7FFF)
            LOWORD(v20) = 0x7FFF;
          v21 = (uint64_t)rint((float)(v12 + (float)((float)v17[3] * v11)));
          if ((int)v21 <= -32768)
            LODWORD(v21) = -32768;
          if ((int)v21 >= 0x7FFF)
            LOWORD(v21) = 0x7FFF;
          *v16 = v20;
          v16[1] = v21;
          v15 += 4;
          v16 += 4;
        }
        while (v15 <= v9 - 4);
        v15 = v15;
      }
      else
      {
        v15 = 0;
      }
      if ((int)v15 < (int)v10)
      {
        do
        {
          v22 = (uint64_t)rint((float)(v12 + (float)((float)*(char *)(result + v15) * v11)));
          if ((int)v22 <= -32768)
            LODWORD(v22) = -32768;
          if ((int)v22 >= 0x7FFF)
            LOWORD(v22) = 0x7FFF;
          *(_WORD *)(a5 + 2 * v15++) = v22;
        }
        while (v10 != v15);
      }
      result += a2;
      v13 = (_WORD *)((char *)v13 + v14);
      a5 += v14;
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t cv::cvtScale16u16s(uint64_t result, unint64_t a2, double a3, double a4, double a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unsigned int *a10, double *a11)
{
  int v11;
  uint64_t v12;
  uint64_t v13;
  float v14;
  float v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _WORD *v20;
  double v21;
  uint64_t v22;
  double v23;
  uint64_t v24;
  _WORD *v25;
  double v26;
  uint64_t v27;
  double v28;
  __int16 v29;
  uint64_t v30;
  uint64_t v31;

  v11 = a10[1];
  if (v11)
  {
    v12 = (int)*a10;
    v13 = *a10;
    v14 = *a11;
    v15 = a11[1];
    v16 = 2 * (a9 >> 1);
    v17 = 2 * (a2 >> 1);
    do
    {
      if ((int)v12 >= 4)
      {
        v19 = 0;
        v18 = 0;
        do
        {
          v20 = (_WORD *)(result + v19);
          LOWORD(a5) = *(_WORD *)(result + v19);
          v21 = rint((float)(v15 + (float)((float)LODWORD(a5) * v14)));
          v22 = (uint64_t)v21;
          if ((int)(uint64_t)v21 <= -32768)
            LODWORD(v22) = -32768;
          LOWORD(v21) = v20[1];
          v23 = rint((float)(v15 + (float)((float)LODWORD(v21) * v14)));
          if ((int)v22 >= 0x7FFF)
            LOWORD(v22) = 0x7FFF;
          v24 = (uint64_t)v23;
          if ((int)(uint64_t)v23 <= -32768)
            LODWORD(v24) = -32768;
          if ((int)v24 >= 0x7FFF)
            LOWORD(v24) = 0x7FFF;
          v25 = (_WORD *)(a8 + v19);
          *v25 = v22;
          v25[1] = v24;
          LOWORD(v23) = v20[2];
          v26 = rint((float)(v15 + (float)((float)LODWORD(v23) * v14)));
          v27 = (uint64_t)v26;
          if ((int)(uint64_t)v26 <= -32768)
            LODWORD(v27) = -32768;
          LOWORD(v26) = v20[3];
          v28 = (float)(v15 + (float)((float)LODWORD(v26) * v14));
          if ((int)v27 >= 0x7FFF)
            v29 = 0x7FFF;
          else
            v29 = v27;
          a5 = rint(v28);
          v30 = (uint64_t)a5;
          if ((int)(uint64_t)a5 <= -32768)
            LODWORD(v30) = -32768;
          if ((int)v30 >= 0x7FFF)
            LOWORD(v30) = 0x7FFF;
          v25[2] = v29;
          v25[3] = v30;
          v18 += 4;
          v19 += 8;
        }
        while (v18 <= v12 - 4);
        v18 = v18;
      }
      else
      {
        v18 = 0;
      }
      if ((int)v18 < (int)v13)
      {
        do
        {
          LOWORD(a5) = *(_WORD *)(result + 2 * v18);
          a5 = rint((float)(v15 + (float)((float)LODWORD(a5) * v14)));
          v31 = (uint64_t)a5;
          if ((int)(uint64_t)a5 <= -32768)
            LODWORD(v31) = -32768;
          if ((int)v31 >= 0x7FFF)
            LOWORD(v31) = 0x7FFF;
          *(_WORD *)(a8 + 2 * v18++) = v31;
        }
        while (v13 != v18);
      }
      a8 += v16;
      result += v17;
      --v11;
    }
    while (v11);
  }
  return result;
}

uint64_t cv::cvtScale16s(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, unsigned int *a7, double *a8)
{
  unsigned int v8;
  float v9;
  uint64_t v10;
  float v11;
  uint64_t v12;
  uint64_t v13;

  v8 = a7[1];
  if (v8)
  {
    v9 = *a8;
    v10 = *a7;
    v11 = a8[1];
    do
    {
      if ((int)v10 >= 1)
      {
        v12 = 0;
        do
        {
          v13 = (uint64_t)rint((float)(v11 + (float)((float)*(__int16 *)(result + v12) * v9)));
          if ((int)v13 <= -32768)
            LODWORD(v13) = -32768;
          if ((int)v13 >= 0x7FFF)
            LOWORD(v13) = 0x7FFF;
          *(_WORD *)(a5 + v12) = v13;
          v12 += 2;
        }
        while (2 * v10 != v12);
      }
      a5 += 2 * (a6 >> 1);
      result += 2 * (a2 >> 1);
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t cv::cvtScale32s16s(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, int16x4_t *a5, unint64_t a6, unsigned int *a7, double *a8)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  float v11;
  float v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;
  int *v16;
  int16x4_t *v17;
  uint64_t v18;
  double v19;
  int v20;
  int v21;
  uint64_t v22;
  int32x4_t v23;
  uint64_t v24;

  v8 = a7[1];
  if (v8)
  {
    v9 = (int)*a7;
    v10 = *a7;
    v11 = *a8;
    v12 = a8[1];
    v13 = (int *)(result + 8);
    v14 = 4 * (a2 >> 2);
    do
    {
      if ((int)v9 >= 4)
      {
        v15 = 0;
        v16 = v13;
        v17 = a5;
        do
        {
          v18 = (uint64_t)rint((float)(v12 + (float)((float)*(v16 - 2) * v11)));
          v19 = rint((float)(v12 + (float)((float)*(v16 - 1) * v11)));
          v20 = *v16;
          v21 = v16[1];
          v16 += 4;
          v22 = (uint64_t)rint((float)(v12 + (float)((float)v20 * v11)));
          v23.i32[0] = v18;
          v23.i32[1] = (uint64_t)v19;
          v23.i32[2] = v22;
          v23.i32[3] = (uint64_t)rint((float)(v12 + (float)((float)v21 * v11)));
          *v17++ = vqmovn_s32(v23);
          v15 += 4;
        }
        while (v15 <= v9 - 4);
        v15 = v15;
      }
      else
      {
        v15 = 0;
      }
      if ((int)v15 < (int)v10)
      {
        do
        {
          v24 = (uint64_t)rint((float)(v12 + (float)((float)*(int *)(result + 4 * v15) * v11)));
          if ((int)v24 <= -32768)
            LODWORD(v24) = -32768;
          if ((int)v24 >= 0x7FFF)
            LOWORD(v24) = 0x7FFF;
          a5->i16[v15++] = v24;
        }
        while (v10 != v15);
      }
      a5 = (int16x4_t *)((char *)a5 + 2 * (a6 >> 1));
      v13 = (int *)((char *)v13 + v14);
      result += v14;
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t cv::cvtScale32f16s(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, int16x4_t *a5, unint64_t a6, unsigned int *a7, double *a8)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  float v11;
  uint64_t v12;
  float v13;
  float *v14;
  uint64_t v15;
  uint64_t v16;
  float *v17;
  int16x4_t *v18;
  uint64_t v19;
  uint64_t v20;
  float v21;
  float v22;
  uint64_t v23;
  int32x4_t v24;
  uint64_t v25;

  v8 = a7[1];
  if (v8)
  {
    v9 = (int)*a7;
    v10 = *a7;
    v11 = *a8;
    v12 = 2 * (a6 >> 1);
    v13 = a8[1];
    v14 = (float *)(result + 8);
    v15 = 4 * (a2 >> 2);
    do
    {
      if ((int)v9 >= 4)
      {
        v16 = 0;
        v17 = v14;
        v18 = a5;
        do
        {
          v19 = (uint64_t)rint((float)(v13 + (float)(*(v17 - 2) * v11)));
          v20 = (uint64_t)rint((float)(v13 + (float)(*(v17 - 1) * v11)));
          v22 = *v17;
          v21 = v17[1];
          v17 += 4;
          v23 = (uint64_t)rint((float)(v13 + (float)(v22 * v11)));
          v24.i64[0] = __PAIR64__(v20, v19);
          v24.i32[2] = v23;
          v24.i32[3] = (uint64_t)rint((float)(v13 + (float)(v21 * v11)));
          *v18++ = vqmovn_s32(v24);
          v16 += 4;
        }
        while (v16 <= v9 - 4);
        v16 = v16;
      }
      else
      {
        v16 = 0;
      }
      if ((int)v16 < (int)v10)
      {
        do
        {
          v25 = (uint64_t)rint((float)(v13 + (float)(*(float *)(result + 4 * v16) * v11)));
          if ((int)v25 <= -32768)
            LODWORD(v25) = -32768;
          if ((int)v25 >= 0x7FFF)
            LOWORD(v25) = 0x7FFF;
          a5->i16[v16++] = v25;
        }
        while (v10 != v16);
      }
      a5 = (int16x4_t *)((char *)a5 + v12);
      v14 = (float *)((char *)v14 + v15);
      result += v15;
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t cv::cvtScale64f16s(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, int16x4_t *a5, unint64_t a6, unsigned int *a7, double *a8)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  float v11;
  float v12;
  double v13;
  uint64_t v14;
  double v15;
  double *v16;
  uint64_t v17;
  uint64_t v18;
  double *v19;
  int16x4_t *v20;
  uint64_t v21;
  uint64_t v22;
  double v23;
  double v24;
  uint64_t v25;
  double v26;
  int32x4_t v27;
  uint64_t v28;

  v8 = a7[1];
  if (v8)
  {
    v9 = (int)*a7;
    v10 = *a7;
    v11 = a8[1];
    v12 = *a8;
    v13 = v12;
    v14 = 2 * (a6 >> 1);
    v15 = v11;
    v16 = (double *)(result + 16);
    v17 = 8 * (a2 >> 3);
    do
    {
      if ((int)v9 >= 4)
      {
        v18 = 0;
        v19 = v16;
        v20 = a5;
        do
        {
          v21 = (uint64_t)rint(v15 + *(v19 - 2) * v13);
          v22 = (uint64_t)rint(v15 + *(v19 - 1) * v13);
          v23 = *v19;
          v24 = v19[1];
          v19 += 4;
          v25 = (uint64_t)rint(v15 + v23 * v13);
          v26 = rint(v15 + v24 * v13);
          v27.i64[0] = __PAIR64__(v22, v21);
          v27.i32[2] = v25;
          v27.i32[3] = (uint64_t)v26;
          *v20++ = vqmovn_s32(v27);
          v18 += 4;
        }
        while (v18 <= v9 - 4);
        v18 = v18;
      }
      else
      {
        v18 = 0;
      }
      if ((int)v18 < (int)v10)
      {
        do
        {
          v28 = (uint64_t)rint(v15 + *(double *)(result + 8 * v18) * v13);
          if ((int)v28 <= -32768)
            LODWORD(v28) = -32768;
          if ((int)v28 >= 0x7FFF)
            LOWORD(v28) = 0x7FFF;
          a5->i16[v18++] = v28;
        }
        while (v10 != v18);
      }
      a5 = (int16x4_t *)((char *)a5 + v14);
      v16 = (double *)((char *)v16 + v17);
      result += v17;
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t cv::cvtScale8u32s(uint64_t result, uint64_t a2, double a3, double a4, double a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, int *a10, double *a11)
{
  int v11;
  uint64_t v12;
  float v13;
  float v14;
  _DWORD *v15;
  uint64_t v16;
  uint64_t v17;
  _DWORD *v18;
  double v19;
  uint64_t v20;
  double v21;
  double v22;
  uint64_t v23;

  v11 = a10[1];
  if (v11)
  {
    v12 = *a10;
    v13 = *a11;
    v14 = a11[1];
    v15 = (_DWORD *)(a8 + 8);
    v16 = 4 * (a9 >> 2);
    do
    {
      if ((int)v12 >= 4)
      {
        v17 = 0;
        v18 = v15;
        do
        {
          LOBYTE(a5) = *(_BYTE *)(result + v17);
          v19 = rint((float)(v14 + (float)((float)LODWORD(a5) * v13)));
          v20 = (uint64_t)v19;
          LOBYTE(v19) = *(_BYTE *)(result + v17 + 1);
          v21 = rint((float)(v14 + (float)((float)LODWORD(v19) * v13)));
          *(v18 - 2) = v20;
          *(v18 - 1) = (uint64_t)v21;
          LOBYTE(v21) = *(_BYTE *)(result + v17 + 2);
          v22 = rint((float)(v14 + (float)((float)LODWORD(v21) * v13)));
          v23 = (uint64_t)v22;
          LOBYTE(v22) = *(_BYTE *)(result + v17 + 3);
          a5 = rint((float)(v14 + (float)((float)LODWORD(v22) * v13)));
          *v18 = v23;
          v18[1] = (uint64_t)a5;
          v18 += 4;
          v17 += 4;
        }
        while (v17 <= v12 - 4);
        v17 = v17;
      }
      else
      {
        v17 = 0;
      }
      if ((int)v17 < (int)v12)
      {
        do
        {
          LOBYTE(a5) = *(_BYTE *)(result + v17);
          a5 = rint((float)(v14 + (float)((float)LODWORD(a5) * v13)));
          *(_DWORD *)(a8 + 4 * v17++) = (uint64_t)a5;
        }
        while (v17 < v12);
      }
      result += a2;
      v15 = (_DWORD *)((char *)v15 + v16);
      a8 += v16;
      --v11;
    }
    while (v11);
  }
  return result;
}

uint64_t cv::cvtScale8s32s(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, int *a7, double *a8)
{
  int v8;
  uint64_t v9;
  float v10;
  float v11;
  _DWORD *v12;
  uint64_t v13;
  uint64_t v14;
  _DWORD *v15;
  uint64_t v16;
  uint64_t v17;

  v8 = a7[1];
  if (v8)
  {
    v9 = *a7;
    v10 = *a8;
    v11 = a8[1];
    v12 = (_DWORD *)(a5 + 8);
    v13 = 4 * (a6 >> 2);
    do
    {
      if ((int)v9 >= 4)
      {
        v14 = 0;
        v15 = v12;
        do
        {
          v16 = (uint64_t)rint((float)(v11 + (float)((float)*(char *)(result + v14 + 1) * v10)));
          *(v15 - 2) = (uint64_t)rint((float)(v11 + (float)((float)*(char *)(result + v14) * v10)));
          *(v15 - 1) = v16;
          v17 = (uint64_t)rint((float)(v11 + (float)((float)*(char *)(result + v14 + 3) * v10)));
          *v15 = (uint64_t)rint((float)(v11 + (float)((float)*(char *)(result + v14 + 2) * v10)));
          v15[1] = v17;
          v15 += 4;
          v14 += 4;
        }
        while (v14 <= v9 - 4);
        v14 = v14;
      }
      else
      {
        v14 = 0;
      }
      if ((int)v14 < (int)v9)
      {
        do
        {
          *(_DWORD *)(a5 + 4 * v14) = (uint64_t)rint((float)(v11 + (float)((float)*(char *)(result + v14) * v10)));
          ++v14;
        }
        while (v14 < v9);
      }
      result += a2;
      v12 = (_DWORD *)((char *)v12 + v13);
      a5 += v13;
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t cv::cvtScale16u32s(uint64_t result, unint64_t a2, double a3, double a4, double a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, int *a10, double *a11)
{
  int v11;
  uint64_t v12;
  float v13;
  float v14;
  _DWORD *v15;
  uint64_t v16;
  _WORD *v17;
  uint64_t v18;
  uint64_t v19;
  _WORD *v20;
  _DWORD *v21;
  double v22;
  uint64_t v23;
  double v24;
  double v25;
  uint64_t v26;

  v11 = a10[1];
  if (v11)
  {
    v12 = *a10;
    v13 = *a11;
    v14 = a11[1];
    v15 = (_DWORD *)(a8 + 8);
    v16 = 4 * (a9 >> 2);
    v17 = (_WORD *)(result + 4);
    v18 = 2 * (a2 >> 1);
    do
    {
      if ((int)v12 >= 4)
      {
        v19 = 0;
        v20 = v17;
        v21 = v15;
        do
        {
          LOWORD(a5) = *(v20 - 2);
          v22 = rint((float)(v14 + (float)((float)LODWORD(a5) * v13)));
          v23 = (uint64_t)v22;
          LOWORD(v22) = *(v20 - 1);
          v24 = rint((float)(v14 + (float)((float)LODWORD(v22) * v13)));
          *(v21 - 2) = v23;
          *(v21 - 1) = (uint64_t)v24;
          LOWORD(v24) = *v20;
          v25 = rint((float)(v14 + (float)((float)LODWORD(v24) * v13)));
          v26 = (uint64_t)v25;
          LOWORD(v25) = v20[1];
          a5 = rint((float)(v14 + (float)((float)LODWORD(v25) * v13)));
          *v21 = v26;
          v21[1] = (uint64_t)a5;
          v21 += 4;
          v19 += 4;
          v20 += 4;
        }
        while (v19 <= v12 - 4);
        v19 = v19;
      }
      else
      {
        v19 = 0;
      }
      if ((int)v19 < (int)v12)
      {
        do
        {
          LOWORD(a5) = *(_WORD *)(result + 2 * v19);
          a5 = rint((float)(v14 + (float)((float)LODWORD(a5) * v13)));
          *(_DWORD *)(a8 + 4 * v19++) = (uint64_t)a5;
        }
        while (v19 < v12);
      }
      v15 = (_DWORD *)((char *)v15 + v16);
      v17 = (_WORD *)((char *)v17 + v18);
      a8 += v16;
      result += v18;
      --v11;
    }
    while (v11);
  }
  return result;
}

uint64_t cv::cvtScale16s32s(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, int *a7, double *a8)
{
  int v8;
  float v9;
  float v10;
  uint64_t v11;
  uint64_t i;

  v8 = a7[1];
  if (v8)
  {
    v9 = *a8;
    v10 = a8[1];
    v11 = *a7;
    do
    {
      if ((int)v11 >= 1)
      {
        for (i = 0; i != v11; ++i)
          *(_DWORD *)(a5 + 4 * i) = (uint64_t)rint((float)(v10 + (float)((float)*(__int16 *)(result + 2 * i) * v9)));
      }
      a5 += 4 * (a6 >> 2);
      result += 2 * (a2 >> 1);
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t cv::cvtScale32s(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, int *a7, double *a8)
{
  int v8;
  uint64_t v9;
  double v10;
  double v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _DWORD *v16;
  uint64_t v17;

  v8 = a7[1];
  if (v8)
  {
    v9 = *a7;
    v10 = *a8;
    v11 = a8[1];
    v12 = 4 * (a2 >> 2);
    do
    {
      if ((int)v9 >= 4)
      {
        v14 = 0;
        v13 = 0;
        do
        {
          v15 = (uint64_t)rint(v11 + (double)*(int *)(result + v14 + 4) * v10);
          v16 = (_DWORD *)(a5 + v14);
          *v16 = (uint64_t)rint(v11 + (double)*(int *)(result + v14) * v10);
          v16[1] = v15;
          v17 = (uint64_t)rint(v11 + (double)*(int *)(result + v14 + 12) * v10);
          v16[2] = (uint64_t)rint(v11 + (double)*(int *)(result + v14 + 8) * v10);
          v16[3] = v17;
          v13 += 4;
          v14 += 16;
        }
        while (v13 <= v9 - 4);
        v13 = v13;
      }
      else
      {
        v13 = 0;
      }
      if ((int)v13 < (int)v9)
      {
        do
        {
          *(_DWORD *)(a5 + 4 * v13) = (uint64_t)rint(v11 + (double)*(int *)(result + 4 * v13) * v10);
          ++v13;
        }
        while (v13 < v9);
      }
      a5 += 4 * (a6 >> 2);
      result += v12;
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t cv::cvtScale32f32s(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, int *a7, double *a8)
{
  int v8;
  uint64_t v9;
  float v10;
  float v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _DWORD *v18;

  v8 = a7[1];
  if (v8)
  {
    v9 = *a7;
    v10 = *a8;
    v11 = a8[1];
    v12 = 4 * (a2 >> 2);
    do
    {
      if ((int)v9 >= 4)
      {
        v14 = 0;
        v13 = 0;
        do
        {
          v15 = (uint64_t)rint((float)(v11 + (float)(*(float *)(result + v14 + 4) * v10)));
          v16 = (uint64_t)rint((float)(v11 + (float)(*(float *)(result + v14 + 8) * v10)));
          v17 = (uint64_t)rint((float)(v11 + (float)(*(float *)(result + v14 + 12) * v10)));
          v18 = (_DWORD *)(a5 + v14);
          *v18 = (uint64_t)rint((float)(v11 + (float)(*(float *)(result + v14) * v10)));
          v18[1] = v15;
          v18[2] = v16;
          v18[3] = v17;
          v13 += 4;
          v14 += 16;
        }
        while (v13 <= v9 - 4);
        v13 = v13;
      }
      else
      {
        v13 = 0;
      }
      if ((int)v13 < (int)v9)
      {
        do
        {
          *(_DWORD *)(a5 + 4 * v13) = (uint64_t)rint((float)(v11 + (float)(*(float *)(result + 4 * v13) * v10)));
          ++v13;
        }
        while (v13 < v9);
      }
      a5 += 4 * (a6 >> 2);
      result += v12;
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t cv::cvtScale64f32s(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, int *a7, double *a8)
{
  int v8;
  uint64_t v9;
  double v10;
  double v11;
  _DWORD *v12;
  uint64_t v13;
  double *v14;
  uint64_t v15;
  uint64_t v16;
  double *v17;
  _DWORD *v18;
  uint64_t v19;
  uint64_t v20;
  double v21;
  double v22;

  v8 = a7[1];
  if (v8)
  {
    v9 = *a7;
    v10 = *a8;
    v11 = a8[1];
    v12 = (_DWORD *)(a5 + 8);
    v13 = 4 * (a6 >> 2);
    v14 = (double *)(result + 16);
    v15 = 8 * (a2 >> 3);
    do
    {
      if ((int)v9 >= 4)
      {
        v16 = 0;
        v17 = v14;
        v18 = v12;
        do
        {
          v19 = (uint64_t)rint(v11 + *(v17 - 2) * v10);
          v20 = (uint64_t)rint(v11 + *(v17 - 1) * v10);
          v21 = *v17;
          v22 = v17[1];
          v17 += 4;
          *(v18 - 2) = v19;
          *(v18 - 1) = v20;
          *v18 = (uint64_t)rint(v11 + v21 * v10);
          v18[1] = (uint64_t)rint(v11 + v22 * v10);
          v18 += 4;
          v16 += 4;
        }
        while (v16 <= v9 - 4);
        v16 = v16;
      }
      else
      {
        v16 = 0;
      }
      if ((int)v16 < (int)v9)
      {
        do
        {
          *(_DWORD *)(a5 + 4 * v16) = (uint64_t)rint(v11 + *(double *)(result + 8 * v16) * v10);
          ++v16;
        }
        while (v16 < v9);
      }
      v12 = (_DWORD *)((char *)v12 + v13);
      v14 = (double *)((char *)v14 + v15);
      a5 += v13;
      result += v15;
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t cv::cvtScale8u32f(uint64_t result, uint64_t a2, double a3, double a4, float a5, float a6, uint64_t a7, uint64_t a8, uint64_t a9, unint64_t a10, unsigned int *a11, double *a12)
{
  int v12;
  uint64_t v13;
  uint64_t v14;
  float v15;
  float v16;
  float *v17;
  uint64_t v18;
  uint64_t v19;
  float *v20;
  unsigned int v21;
  unsigned int v22;

  v12 = a11[1];
  if (v12)
  {
    v13 = (int)*a11;
    v14 = *a11;
    v15 = *a12;
    v16 = a12[1];
    v17 = (float *)(a9 + 8);
    v18 = 4 * (a10 >> 2);
    do
    {
      if ((int)v13 >= 4)
      {
        v19 = 0;
        v20 = v17;
        do
        {
          LOBYTE(a5) = *(_BYTE *)(result + v19);
          *(float *)&v21 = v16 + (float)((float)LODWORD(a5) * v15);
          LOBYTE(a6) = *(_BYTE *)(result + v19 + 1);
          *(float *)&v22 = v16 + (float)((float)LODWORD(a6) * v15);
          *(v20 - 2) = *(float *)&v21;
          *(v20 - 1) = *(float *)&v22;
          LOBYTE(v21) = *(_BYTE *)(result + v19 + 2);
          a5 = v16 + (float)((float)v21 * v15);
          LOBYTE(v22) = *(_BYTE *)(result + v19 + 3);
          a6 = v16 + (float)((float)v22 * v15);
          *v20 = a5;
          v20[1] = a6;
          v20 += 4;
          v19 += 4;
        }
        while (v19 <= v13 - 4);
        v19 = v19;
      }
      else
      {
        v19 = 0;
      }
      if ((int)v19 < (int)v14)
      {
        do
        {
          LOBYTE(a5) = *(_BYTE *)(result + v19);
          a5 = v16 + (float)((float)LODWORD(a5) * v15);
          *(float *)(a9 + 4 * v19++) = a5;
        }
        while (v14 != v19);
      }
      result += a2;
      v17 = (float *)((char *)v17 + v18);
      a9 += v18;
      --v12;
    }
    while (v12);
  }
  return result;
}

uint64_t cv::cvtScale8s32f(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, unsigned int *a7, double *a8)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  float v11;
  float v12;
  float *v13;
  uint64_t v14;
  uint64_t v15;
  float *v16;
  float v17;
  float v18;

  v8 = a7[1];
  if (v8)
  {
    v9 = (int)*a7;
    v10 = *a7;
    v11 = *a8;
    v12 = a8[1];
    v13 = (float *)(a5 + 8);
    v14 = 4 * (a6 >> 2);
    do
    {
      if ((int)v9 >= 4)
      {
        v15 = 0;
        v16 = v13;
        do
        {
          v17 = v12 + (float)((float)*(char *)(result + v15 + 1) * v11);
          *(v16 - 2) = v12 + (float)((float)*(char *)(result + v15) * v11);
          *(v16 - 1) = v17;
          v18 = v12 + (float)((float)*(char *)(result + v15 + 3) * v11);
          *v16 = v12 + (float)((float)*(char *)(result + v15 + 2) * v11);
          v16[1] = v18;
          v16 += 4;
          v15 += 4;
        }
        while (v15 <= v9 - 4);
        v15 = v15;
      }
      else
      {
        v15 = 0;
      }
      if ((int)v15 < (int)v10)
      {
        do
        {
          *(float *)(a5 + 4 * v15) = v12 + (float)((float)*(char *)(result + v15) * v11);
          ++v15;
        }
        while (v10 != v15);
      }
      result += a2;
      v13 = (float *)((char *)v13 + v14);
      a5 += v14;
      --v8;
    }
    while (v8);
  }
  return result;
}

uint16x4_t *cv::cvtScale16u32f(uint16x4_t *result, unint64_t a2, double a3, double a4, double a5, double a6, float32x4_t a7, uint64_t a8, uint64_t a9, float32x4_t *a10, unint64_t a11, unsigned int *a12, uint64_t a13)
{
  int v13;
  uint64_t v14;
  uint64_t v15;
  int32x2_t v16;
  double v17;
  float32x4_t v18;
  float32x4_t v19;
  uint64_t v20;
  uint16x4_t *v21;
  float32x4_t *v22;
  uint16x4_t v23;

  v13 = a12[1];
  if (v13)
  {
    v14 = (int)*a12;
    v15 = *a12;
    v16 = *(int32x2_t *)a13;
    v17 = *(double *)(a13 + 8);
    *(float *)v16.i32 = *(double *)a13;
    *(float *)&v17 = v17;
    v18 = (float32x4_t)vdupq_lane_s32(v16, 0);
    v19 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v17, 0);
    do
    {
      if ((int)v14 >= 4)
      {
        v20 = 0;
        v21 = result;
        v22 = a10;
        do
        {
          v23 = *v21++;
          a7 = vcvtq_f32_u32(vmovl_u16(v23));
          *v22++ = vmlaq_f32(v19, v18, a7);
          v20 += 4;
        }
        while (v20 <= v14 - 4);
        v20 = v20;
      }
      else
      {
        v20 = 0;
      }
      if ((int)v20 < (int)v15)
      {
        do
        {
          a7.i16[0] = result->i16[v20];
          a7.f32[0] = *(float *)&v17 + (float)((float)a7.u32[0] * *(float *)v16.i32);
          a10->i32[v20++] = a7.i32[0];
        }
        while (v15 != v20);
      }
      a10 = (float32x4_t *)((char *)a10 + 4 * (a11 >> 2));
      result = (uint16x4_t *)((char *)result + 2 * (a2 >> 1));
      --v13;
    }
    while (v13);
  }
  return result;
}

int16x4_t *cv::cvtScale16s32f(int16x4_t *result, unint64_t a2, uint64_t a3, uint64_t a4, float32x4_t *a5, unint64_t a6, unsigned int *a7, uint64_t a8)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  int32x2_t v11;
  double v12;
  float32x4_t v13;
  float32x4_t v14;
  uint64_t v15;
  int16x4_t *v16;
  float32x4_t *v17;
  int16x4_t v18;

  v8 = a7[1];
  if (v8)
  {
    v9 = (int)*a7;
    v10 = *a7;
    v11 = *(int32x2_t *)a8;
    v12 = *(double *)(a8 + 8);
    *(float *)v11.i32 = *(double *)a8;
    *(float *)&v12 = v12;
    v13 = (float32x4_t)vdupq_lane_s32(v11, 0);
    v14 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v12, 0);
    do
    {
      if ((int)v9 >= 4)
      {
        v15 = 0;
        v16 = result;
        v17 = a5;
        do
        {
          v18 = *v16++;
          *v17++ = vmlaq_f32(v14, v13, vcvtq_f32_s32(vmovl_s16(v18)));
          v15 += 4;
        }
        while (v15 <= v9 - 4);
        v15 = v15;
      }
      else
      {
        v15 = 0;
      }
      if ((int)v15 < (int)v10)
      {
        do
        {
          a5->f32[v15] = *(float *)&v12 + (float)((float)result->i16[v15] * *(float *)v11.i32);
          ++v15;
        }
        while (v10 != v15);
      }
      a5 = (float32x4_t *)((char *)a5 + 4 * (a6 >> 2));
      result = (int16x4_t *)((char *)result + 2 * (a2 >> 1));
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t cv::cvtScale32s32f(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, unsigned int *a7, uint64_t a8)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  double v11;
  uint64_t v12;
  float64x2_t v13;
  float64x2_t v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  int64x2_t v18;
  float64x2_t v19;
  float v20;

  v8 = a7[1];
  if (v8)
  {
    v9 = (int)*a7;
    v10 = *a7;
    v11 = *(double *)a8;
    v12 = *(uint64_t *)(a8 + 8);
    v13 = (float64x2_t)vdupq_lane_s64(*(_QWORD *)a8, 0);
    v14 = (float64x2_t)vdupq_lane_s64(v12, 0);
    do
    {
      if ((int)v9 >= 4)
      {
        v16 = 0;
        v15 = 0;
        do
        {
          v17 = *(_OWORD *)(result + v16);
          v18.i64[0] = (int)v17;
          v18.i64[1] = SDWORD1(v17);
          v19 = vcvtq_f64_s64(v18);
          v18.i64[0] = SDWORD2(v17);
          v18.i64[1] = SHIDWORD(v17);
          *(float32x4_t *)(a5 + v16) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmlaq_f64(v14, v13, v19)), vmlaq_f64(v14, v13, vcvtq_f64_s64(v18)));
          v15 += 4;
          v16 += 16;
        }
        while (v15 <= v9 - 4);
        v15 = v15;
      }
      else
      {
        v15 = 0;
      }
      if ((int)v15 < (int)v10)
      {
        do
        {
          v20 = *(double *)&v12 + (double)*(int *)(result + 4 * v15) * v11;
          *(float *)(a5 + 4 * v15++) = v20;
        }
        while (v10 != v15);
      }
      a5 += 4 * (a6 >> 2);
      result += 4 * (a2 >> 2);
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t cv::cvtScale32f(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, unsigned int *a7, uint64_t a8)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  int32x2_t v11;
  double v12;
  float32x2_t v13;
  float32x2_t v14;
  uint64_t v15;
  uint64_t v16;
  float32x2_t *v17;

  v8 = a7[1];
  if (v8)
  {
    v9 = (int)*a7;
    v10 = *a7;
    v11 = *(int32x2_t *)a8;
    v12 = *(double *)(a8 + 8);
    *(float *)v11.i32 = *(double *)a8;
    *(float *)&v12 = v12;
    v13 = (float32x2_t)vdup_lane_s32(v11, 0);
    v14 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v12, 0);
    do
    {
      if ((int)v9 >= 4)
      {
        v16 = 0;
        v15 = 0;
        do
        {
          v17 = (float32x2_t *)(a5 + v16);
          *v17 = vmla_f32(v14, v13, *(float32x2_t *)(result + v16));
          v17[1] = vmla_f32(v14, v13, *(float32x2_t *)(result + v16 + 8));
          v15 += 4;
          v16 += 16;
        }
        while (v15 <= v9 - 4);
        v15 = v15;
      }
      else
      {
        v15 = 0;
      }
      if ((int)v15 < (int)v10)
      {
        do
        {
          *(float *)(a5 + 4 * v15) = *(float *)&v12 + (float)(*(float *)(result + 4 * v15) * *(float *)v11.i32);
          ++v15;
        }
        while (v10 != v15);
      }
      a5 += 4 * (a6 >> 2);
      result += 4 * (a2 >> 2);
      --v8;
    }
    while (v8);
  }
  return result;
}

float64x2_t *cv::cvtScale64f32f(float64x2_t *result, unint64_t a2, uint64_t a3, uint64_t a4, float32x4_t *a5, unint64_t a6, unsigned int *a7, uint64_t a8)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  double v11;
  uint64_t v12;
  float64x2_t v13;
  float64x2_t v14;
  uint64_t v15;
  float64x2_t *v16;
  float32x4_t *v17;
  float64x2_t v18;
  float64x2_t v19;
  float32_t v20;

  v8 = a7[1];
  if (v8)
  {
    v9 = (int)*a7;
    v10 = *a7;
    v11 = *(double *)a8;
    v12 = *(uint64_t *)(a8 + 8);
    v13 = (float64x2_t)vdupq_lane_s64(*(_QWORD *)a8, 0);
    v14 = (float64x2_t)vdupq_lane_s64(v12, 0);
    do
    {
      if ((int)v9 >= 4)
      {
        v15 = 0;
        v16 = result;
        v17 = a5;
        do
        {
          v18 = *v16;
          v19 = v16[1];
          v16 += 2;
          *v17++ = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmlaq_f64(v14, v13, v18)), vmlaq_f64(v14, v13, v19));
          v15 += 4;
        }
        while (v15 <= v9 - 4);
        v15 = v15;
      }
      else
      {
        v15 = 0;
      }
      if ((int)v15 < (int)v10)
      {
        do
        {
          v20 = *(double *)&v12 + result->f64[v15] * v11;
          a5->f32[v15++] = v20;
        }
        while (v10 != v15);
      }
      a5 = (float32x4_t *)((char *)a5 + 4 * (a6 >> 2));
      result = (float64x2_t *)((char *)result + 8 * (a2 >> 3));
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t cv::cvtScale8u64f(uint64_t result, uint64_t a2, double a3, double a4, double a5, double a6, uint64_t a7, uint64_t a8, uint64_t a9, unint64_t a10, unsigned int *a11, double *a12)
{
  int v12;
  uint64_t v13;
  uint64_t v14;
  double v15;
  double v16;
  double *v17;
  uint64_t v18;
  uint64_t v19;
  double *v20;
  double v21;
  double v22;

  v12 = a11[1];
  if (v12)
  {
    v13 = (int)*a11;
    v14 = *a11;
    v15 = *a12;
    v16 = a12[1];
    v17 = (double *)(a9 + 16);
    v18 = 8 * (a10 >> 3);
    do
    {
      if ((int)v13 >= 4)
      {
        v19 = 0;
        v20 = v17;
        do
        {
          LOBYTE(a5) = *(_BYTE *)(result + v19);
          v21 = v16 + (double)*(unint64_t *)&a5 * v15;
          LOBYTE(a6) = *(_BYTE *)(result + v19 + 1);
          v22 = v16 + (double)*(unint64_t *)&a6 * v15;
          *(v20 - 2) = v21;
          *(v20 - 1) = v22;
          LOBYTE(v21) = *(_BYTE *)(result + v19 + 2);
          a5 = v16 + (double)*(unint64_t *)&v21 * v15;
          LOBYTE(v22) = *(_BYTE *)(result + v19 + 3);
          a6 = v16 + (double)*(unint64_t *)&v22 * v15;
          *v20 = a5;
          v20[1] = a6;
          v20 += 4;
          v19 += 4;
        }
        while (v19 <= v13 - 4);
        v19 = v19;
      }
      else
      {
        v19 = 0;
      }
      if ((int)v19 < (int)v14)
      {
        do
        {
          LOBYTE(a5) = *(_BYTE *)(result + v19);
          a5 = v16 + (double)*(unint64_t *)&a5 * v15;
          *(double *)(a9 + 8 * v19++) = a5;
        }
        while (v14 != v19);
      }
      result += a2;
      v17 = (double *)((char *)v17 + v18);
      a9 += v18;
      --v12;
    }
    while (v12);
  }
  return result;
}

uint64_t cv::cvtScale8s64f(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, unsigned int *a7, double *a8)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  double v11;
  double v12;
  double *v13;
  uint64_t v14;
  uint64_t v15;
  double *v16;
  double v17;
  double v18;

  v8 = a7[1];
  if (v8)
  {
    v9 = (int)*a7;
    v10 = *a7;
    v11 = *a8;
    v12 = a8[1];
    v13 = (double *)(a5 + 16);
    v14 = 8 * (a6 >> 3);
    do
    {
      if ((int)v9 >= 4)
      {
        v15 = 0;
        v16 = v13;
        do
        {
          v17 = v12 + (double)*(char *)(result + v15 + 1) * v11;
          *(v16 - 2) = v12 + (double)*(char *)(result + v15) * v11;
          *(v16 - 1) = v17;
          v18 = v12 + (double)*(char *)(result + v15 + 3) * v11;
          *v16 = v12 + (double)*(char *)(result + v15 + 2) * v11;
          v16[1] = v18;
          v16 += 4;
          v15 += 4;
        }
        while (v15 <= v9 - 4);
        v15 = v15;
      }
      else
      {
        v15 = 0;
      }
      if ((int)v15 < (int)v10)
      {
        do
        {
          *(double *)(a5 + 8 * v15) = v12 + (double)*(char *)(result + v15) * v11;
          ++v15;
        }
        while (v10 != v15);
      }
      result += a2;
      v13 = (double *)((char *)v13 + v14);
      a5 += v14;
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t cv::cvtScale16u64f(uint64_t result, unint64_t a2, double a3, double a4, double a5, double a6, uint64_t a7, uint64_t a8, uint64_t a9, unint64_t a10, unsigned int *a11, double *a12)
{
  int v12;
  uint64_t v13;
  uint64_t v14;
  double v15;
  double v16;
  double *v17;
  uint64_t v18;
  _WORD *v19;
  uint64_t v20;
  uint64_t v21;
  _WORD *v22;
  double *v23;
  double v24;
  double v25;

  v12 = a11[1];
  if (v12)
  {
    v13 = (int)*a11;
    v14 = *a11;
    v15 = *a12;
    v16 = a12[1];
    v17 = (double *)(a9 + 16);
    v18 = 8 * (a10 >> 3);
    v19 = (_WORD *)(result + 4);
    v20 = 2 * (a2 >> 1);
    do
    {
      if ((int)v13 >= 4)
      {
        v21 = 0;
        v22 = v19;
        v23 = v17;
        do
        {
          LOWORD(a5) = *(v22 - 2);
          v24 = v16 + (double)*(unint64_t *)&a5 * v15;
          LOWORD(a6) = *(v22 - 1);
          v25 = v16 + (double)*(unint64_t *)&a6 * v15;
          *(v23 - 2) = v24;
          *(v23 - 1) = v25;
          LOWORD(v24) = *v22;
          a5 = v16 + (double)*(unint64_t *)&v24 * v15;
          LOWORD(v25) = v22[1];
          a6 = v16 + (double)*(unint64_t *)&v25 * v15;
          *v23 = a5;
          v23[1] = a6;
          v23 += 4;
          v21 += 4;
          v22 += 4;
        }
        while (v21 <= v13 - 4);
        v21 = v21;
      }
      else
      {
        v21 = 0;
      }
      if ((int)v21 < (int)v14)
      {
        do
        {
          LOWORD(a5) = *(_WORD *)(result + 2 * v21);
          a5 = v16 + (double)*(unint64_t *)&a5 * v15;
          *(double *)(a9 + 8 * v21++) = a5;
        }
        while (v14 != v21);
      }
      v17 = (double *)((char *)v17 + v18);
      v19 = (_WORD *)((char *)v19 + v20);
      a9 += v18;
      result += v20;
      --v12;
    }
    while (v12);
  }
  return result;
}

uint64_t cv::cvtScale16s64f(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, unsigned int *a7, double *a8)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  double v11;
  double v12;
  double *v13;
  uint64_t v14;
  __int16 *v15;
  uint64_t v16;
  uint64_t v17;
  __int16 *v18;
  double *v19;
  double v20;
  double v21;
  double v22;

  v8 = a7[1];
  if (v8)
  {
    v9 = (int)*a7;
    v10 = *a7;
    v11 = *a8;
    v12 = a8[1];
    v13 = (double *)(a5 + 16);
    v14 = 8 * (a6 >> 3);
    v15 = (__int16 *)(result + 4);
    v16 = 2 * (a2 >> 1);
    do
    {
      if ((int)v9 >= 4)
      {
        v17 = 0;
        v18 = v15;
        v19 = v13;
        do
        {
          v20 = v12 + (double)*(v18 - 1) * v11;
          v21 = (double)*v18;
          *(v19 - 2) = v12 + (double)*(v18 - 2) * v11;
          *(v19 - 1) = v20;
          v22 = v12 + (double)v18[1] * v11;
          *v19 = v12 + v21 * v11;
          v19[1] = v22;
          v19 += 4;
          v17 += 4;
          v18 += 4;
        }
        while (v17 <= v9 - 4);
        v17 = v17;
      }
      else
      {
        v17 = 0;
      }
      if ((int)v17 < (int)v10)
      {
        do
        {
          *(double *)(a5 + 8 * v17) = v12 + (double)*(__int16 *)(result + 2 * v17) * v11;
          ++v17;
        }
        while (v10 != v17);
      }
      v13 = (double *)((char *)v13 + v14);
      v15 = (__int16 *)((char *)v15 + v16);
      a5 += v14;
      result += v16;
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t cv::cvtScale32s64f(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, float64x2_t *a5, unint64_t a6, unsigned int *a7, uint64_t a8)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  double v11;
  uint64_t v12;
  float64x2_t v13;
  float64x2_t v14;
  float64x2_t *v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  float64x2_t *v21;
  uint64_t v22;
  int64x2_t v23;
  uint64_t v24;

  v8 = a7[1];
  if (v8)
  {
    v9 = (int)*a7;
    v10 = *a7;
    v11 = *(double *)a8;
    v12 = *(uint64_t *)(a8 + 8);
    v13 = (float64x2_t)vdupq_lane_s64(*(_QWORD *)a8, 0);
    v14 = (float64x2_t)vdupq_lane_s64(v12, 0);
    v15 = a5 + 1;
    v16 = 8 * (a6 >> 3);
    v17 = (uint64_t *)(result + 8);
    v18 = 4 * (a2 >> 2);
    do
    {
      if ((int)v9 >= 4)
      {
        v19 = 0;
        v20 = v17;
        v21 = v15;
        do
        {
          v22 = *(v20 - 1);
          v23.i64[0] = (int)v22;
          v23.i64[1] = SHIDWORD(v22);
          v21[-1] = vmlaq_f64(v14, v13, vcvtq_f64_s64(v23));
          v24 = *v20;
          v20 += 2;
          v23.i64[0] = (int)v24;
          v23.i64[1] = SHIDWORD(v24);
          *v21 = vmlaq_f64(v14, v13, vcvtq_f64_s64(v23));
          v21 += 2;
          v19 += 4;
        }
        while (v19 <= v9 - 4);
        v19 = v19;
      }
      else
      {
        v19 = 0;
      }
      if ((int)v19 < (int)v10)
      {
        do
        {
          a5->f64[v19] = *(double *)&v12 + (double)*(int *)(result + 4 * v19) * v11;
          ++v19;
        }
        while (v10 != v19);
      }
      v15 = (float64x2_t *)((char *)v15 + v16);
      v17 = (uint64_t *)((char *)v17 + v18);
      a5 = (float64x2_t *)((char *)a5 + v16);
      result += v18;
      --v8;
    }
    while (v8);
  }
  return result;
}

float32x2_t *cv::cvtScale32f64f(float32x2_t *result, unint64_t a2, uint64_t a3, uint64_t a4, float64x2_t *a5, unint64_t a6, unsigned int *a7, uint64_t a8)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  double v11;
  uint64_t v12;
  float64x2_t v13;
  float64x2_t v14;
  float64x2_t *v15;
  uint64_t v16;
  float32x2_t *v17;
  uint64_t v18;
  uint64_t v19;
  float32x2_t *v20;
  float64x2_t *v21;
  float32x2_t v22;

  v8 = a7[1];
  if (v8)
  {
    v9 = (int)*a7;
    v10 = *a7;
    v11 = *(double *)a8;
    v12 = *(uint64_t *)(a8 + 8);
    v13 = (float64x2_t)vdupq_lane_s64(*(_QWORD *)a8, 0);
    v14 = (float64x2_t)vdupq_lane_s64(v12, 0);
    v15 = a5 + 1;
    v16 = 8 * (a6 >> 3);
    v17 = result + 1;
    v18 = 4 * (a2 >> 2);
    do
    {
      if ((int)v9 >= 4)
      {
        v19 = 0;
        v20 = v17;
        v21 = v15;
        do
        {
          v21[-1] = vmlaq_f64(v14, v13, vcvtq_f64_f32(v20[-1]));
          v22 = *v20;
          v20 += 2;
          *v21 = vmlaq_f64(v14, v13, vcvtq_f64_f32(v22));
          v21 += 2;
          v19 += 4;
        }
        while (v19 <= v9 - 4);
        v19 = v19;
      }
      else
      {
        v19 = 0;
      }
      if ((int)v19 < (int)v10)
      {
        do
        {
          a5->f64[v19] = *(double *)&v12 + result->f32[v19] * v11;
          ++v19;
        }
        while (v10 != v19);
      }
      v15 = (float64x2_t *)((char *)v15 + v16);
      v17 = (float32x2_t *)((char *)v17 + v18);
      a5 = (float64x2_t *)((char *)a5 + v16);
      result = (float32x2_t *)((char *)result + v18);
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t cv::cvtScale64f(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, unsigned int *a7, uint64_t a8)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  double v11;
  uint64_t v12;
  float64x2_t v13;
  float64x2_t v14;
  uint64_t v15;
  uint64_t v16;
  float64x2_t *v17;

  v8 = a7[1];
  if (v8)
  {
    v9 = (int)*a7;
    v10 = *a7;
    v11 = *(double *)a8;
    v12 = *(uint64_t *)(a8 + 8);
    v13 = (float64x2_t)vdupq_lane_s64(*(_QWORD *)a8, 0);
    v14 = (float64x2_t)vdupq_lane_s64(v12, 0);
    do
    {
      if ((int)v9 >= 4)
      {
        v16 = 0;
        v15 = 0;
        do
        {
          v17 = (float64x2_t *)(a5 + v16);
          *v17 = vmlaq_f64(v14, v13, *(float64x2_t *)(result + v16));
          v17[1] = vmlaq_f64(v14, v13, *(float64x2_t *)(result + v16 + 16));
          v15 += 4;
          v16 += 32;
        }
        while (v15 <= v9 - 4);
        v15 = v15;
      }
      else
      {
        v15 = 0;
      }
      if ((int)v15 < (int)v10)
      {
        do
        {
          *(double *)(a5 + 8 * v15) = *(double *)&v12 + *(double *)(result + 8 * v15) * v11;
          ++v15;
        }
        while (v10 != v15);
      }
      a5 += 8 * (a6 >> 3);
      result += 8 * (a2 >> 3);
      --v8;
    }
    while (v8);
  }
  return result;
}

void cv::Mat::convertTo(cv::Mat *this, const cv::_OutputArray *a2, int a3, double a4, double a5)
{
  _BOOL4 v9;
  int v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  char v15;
  uint64_t v16;
  int v17;
  unsigned __int8 *v18;
  __int128 v19;
  uint64_t v20;
  unsigned int v21;
  int v22;
  _QWORD *v23;
  cv *v24;
  uint64_t (**v25)();
  void (*v26)(unsigned __int8 *, _QWORD, _QWORD, _QWORD, uint64_t, _QWORD, _DWORD *, _QWORD *);
  const cv::Exception *v27;
  unint64_t v28;
  int v29;
  uint64_t v30;
  void *v31;
  int v32;
  uint64_t v33;
  unsigned int *v34;
  unsigned int v35;
  unsigned int v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int *v39;
  unsigned int v40;
  unsigned int v41;
  uint64_t v42;
  uint64_t v43;
  unsigned int *v44;
  unsigned int v45;
  unsigned int v46;
  uint64_t v47;
  char *v48;
  _DWORD v49[2];
  void *__p[5];
  int v51;
  _DWORD v52[2];
  int32x2_t v53;
  _QWORD v54[2];
  uint64_t v55;
  unsigned int *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  cv *v61;
  _QWORD v62[5];
  int v63;
  uint64_t v64;
  int v65;
  unsigned __int8 *v66;
  __int128 v67;
  __int128 v68;
  uint64_t v69;
  char *v70;
  cv *v71;
  _QWORD v72[2];
  unsigned __int8 *v73;
  uint64_t v74;
  cv::Mat *v75[3];
  _QWORD v76[3];

  v76[2] = *MEMORY[0x24BDAC8D0];
  v9 = fabs(a4 + -1.0) >= 2.22044605e-16;
  v10 = fabs(a5) >= 2.22044605e-16 || v9;
  if (a3 < 0)
  {
    if ((*(unsigned int (**)(const cv::_OutputArray *))(*(_QWORD *)a2 + 104))(a2))
    {
      v12 = (*(uint64_t (**)(const cv::_OutputArray *, uint64_t))(*(_QWORD *)a2 + 64))(a2, 0xFFFFFFFFLL);
      v11 = *(_DWORD *)this;
    }
    else
    {
      v11 = *(_DWORD *)this;
      v12 = *(_DWORD *)this & 0xFFF;
    }
  }
  else
  {
    v11 = *(_DWORD *)this;
    v12 = *(_DWORD *)this & 0xFF8 | a3 & 7u;
  }
  v13 = v11 & 7;
  v14 = v12 & 7;
  if (v13 == (_DWORD)v14)
    v15 = v10;
  else
    v15 = 1;
  if ((v15 & 1) != 0)
  {
    v16 = *(_QWORD *)((char *)this + 4);
    v64 = v16;
    v17 = *((_DWORD *)this + 3);
    v63 = v11;
    v65 = v17;
    v18 = (unsigned __int8 *)*((_QWORD *)this + 2);
    v19 = *(_OWORD *)((char *)this + 24);
    v67 = v19;
    v68 = *(_OWORD *)((char *)this + 40);
    v20 = *((_QWORD *)this + 7);
    v66 = v18;
    v69 = v20;
    v70 = (char *)&v64 + 4;
    v71 = (cv *)v72;
    v72[0] = 0;
    v72[1] = 0;
    if ((_QWORD)v19)
    {
      do
        v21 = __ldaxr((unsigned int *)v19);
      while (__stlxr(v21 + 1, (unsigned int *)v19));
      v22 = *((_DWORD *)this + 1);
    }
    else
    {
      v22 = v16;
    }
    if (v22 > 2)
    {
      LODWORD(v64) = 0;
      cv::Mat::copySize((cv::Mat *)&v63, this);
    }
    else
    {
      v23 = (_QWORD *)*((_QWORD *)this + 9);
      v24 = v71;
      *(_QWORD *)v71 = *v23;
      *((_QWORD *)v24 + 1) = v23[1];
    }
    v25 = (uint64_t (**)())&cv::getConvertFunc(int,int)::cvtTab;
    if (v10)
      v25 = cv::getConvertScaleFunc(int,int)::cvtScaleTab;
    v26 = (void (*)(unsigned __int8 *, _QWORD, _QWORD, _QWORD, uint64_t, _QWORD, _DWORD *, _QWORD *))*(&v25[8 * v14] + v13);
    *(double *)v76 = a4;
    *(double *)&v76[1] = a5;
    if (!v26)
    {
      std::string::basic_string[abi:ne180100]<0>(__p, "func != 0");
      std::string::basic_string[abi:ne180100]<0>(v75, "convertTo");
      std::string::basic_string[abi:ne180100]<0>(&v73, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/convert.cpp");
      cv::Exception::Exception(v54, 4294967081, __p, v75, &v73, 1115);
      cv::error((cv *)v54, v27);
    }
    v28 = (((unint64_t)*(unsigned int *)this >> 3) & 0x1FF) + 1;
    if (*((int *)this + 1) > 2)
    {
      (*(void (**)(const cv::_OutputArray *))(*(_QWORD *)a2 + 144))(a2);
      (**(void (***)(_QWORD *__return_ptr, const cv::_OutputArray *, uint64_t))a2)(v54, a2, 0xFFFFFFFFLL);
      v75[0] = (cv::Mat *)&v63;
      v75[1] = (cv::Mat *)v54;
      v75[2] = 0;
      v73 = 0;
      v74 = 0;
      cv::NAryMatIterator::NAryMatIterator((cv::NAryMatIterator *)__p, v75, &v73, -1);
      v32 = v28 * v51;
      v33 = -1;
      while ((void *)++v33 < __p[4])
      {
        v49[0] = v32;
        v49[1] = 1;
        v26(v73, 0, 0, 0, v74, 0, v49, v76);
        cv::NAryMatIterator::operator++((uint64_t)__p);
      }
      v34 = v56;
      if (v56)
      {
        do
        {
          v35 = __ldaxr(v34);
          v36 = v35 - 1;
        }
        while (__stlxr(v36, v34));
        if (!v36)
          cv::Mat::deallocate((cv::Mat *)v54, v31);
      }
      v55 = 0;
      v57 = 0;
      v58 = 0;
      v59 = 0;
      if (SHIDWORD(v54[0]) >= 1)
      {
        v37 = 0;
        v38 = v60;
        do
          *(_DWORD *)(v38 + 4 * v37++) = 0;
        while (v37 < SHIDWORD(v54[0]));
      }
      v56 = 0;
      if (v61 != (cv *)v62)
        cv::fastFree((void **)v61, v31);
    }
    else
    {
      v53 = vrev64_s32(**((int32x2_t **)this + 8));
      (*(void (**)(const cv::_OutputArray *, int32x2_t *, uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 128))(a2, &v53, v12, 0xFFFFFFFFLL, 0, 0);
      (**(void (***)(_QWORD *__return_ptr, const cv::_OutputArray *, uint64_t))a2)(v54, a2, 0xFFFFFFFFLL);
      v29 = HIDWORD(v64);
      if ((v63 & v54[0] & 0x4000) != 0 && (v30 = v65 * (uint64_t)(int)v28 * SHIDWORD(v64), v30 == (int)v30))
        v29 = 1;
      else
        LODWORD(v30) = v65 * v28;
      v52[0] = v30;
      v52[1] = v29;
      v26(v66, v72[0], 0, 0, v55, v62[0], v52, v76);
      v39 = v56;
      if (v56)
      {
        do
        {
          v40 = __ldaxr(v39);
          v41 = v40 - 1;
        }
        while (__stlxr(v41, v39));
        if (!v41)
          cv::Mat::deallocate((cv::Mat *)v54, v31);
      }
      v55 = 0;
      v57 = 0;
      v58 = 0;
      v59 = 0;
      if (SHIDWORD(v54[0]) >= 1)
      {
        v42 = 0;
        v43 = v60;
        do
          *(_DWORD *)(v43 + 4 * v42++) = 0;
        while (v42 < SHIDWORD(v54[0]));
      }
      v56 = 0;
      if (v61 != (cv *)v62)
        cv::fastFree((void **)v61, v31);
    }
    v44 = (unsigned int *)v67;
    if ((_QWORD)v67)
    {
      do
      {
        v45 = __ldaxr(v44);
        v46 = v45 - 1;
      }
      while (__stlxr(v46, v44));
      if (!v46)
        cv::Mat::deallocate((cv::Mat *)&v63, v31);
    }
    v66 = 0;
    v68 = 0uLL;
    *((_QWORD *)&v67 + 1) = 0;
    if ((int)v64 >= 1)
    {
      v47 = 0;
      v48 = v70;
      do
        *(_DWORD *)&v48[4 * v47++] = 0;
      while (v47 < (int)v64);
    }
    *(_QWORD *)&v67 = 0;
    if (v71 != (cv *)v72)
      cv::fastFree((void **)v71, v31);
  }
  else
  {
    cv::Mat::copyTo(this, a2);
  }
}

void sub_219E50454(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
  uint64_t v39;
  void *v41;

  cv::Exception::~Exception((cv::Exception *)&a24);
  if (*(char *)(v39 - 145) < 0)
    operator delete(*(void **)(v39 - 168));
  if (*(char *)(v39 - 121) < 0)
    operator delete(*(void **)(v39 - 144));
  if (a16 < 0)
    operator delete(__p);
  cv::Mat::~Mat((cv::Mat *)&a39, v41);
  _Unwind_Resume(a1);
}

uint64_t cv::mixChannels8u(uint64_t this, const unsigned __int8 **a2, const int *a3, unsigned __int8 **a4, const int *a5, int a6)
{
  uint64_t v6;
  int v7;
  _BYTE *v8;
  _BYTE *v9;
  uint64_t v10;
  signed int v11;
  signed int v12;
  int v13;
  uint64_t v14;
  char v15;
  int v16;

  if (a6 >= 1)
  {
    v6 = 0;
    v7 = (_DWORD)a5 - 2;
    do
    {
      v8 = *(_BYTE **)(this + 8 * v6);
      v9 = *(_BYTE **)&a3[2 * v6];
      v10 = *((int *)a4 + v6);
      if (v8)
      {
        if ((int)a5 < 2)
        {
          v11 = 0;
        }
        else
        {
          v13 = 0;
          v14 = *((int *)a2 + v6);
          do
          {
            v15 = v8[v14];
            *v9 = *v8;
            v9[v10] = v15;
            v13 += 2;
            v8 += 2 * (int)v14;
            v9 += 2 * v10;
          }
          while (v13 <= v7);
          v11 = (v7 & 0xFFFFFFFE) + 2;
        }
        if (v11 < (int)a5)
          *v9 = *v8;
      }
      else
      {
        if ((int)a5 < 2)
        {
          v12 = 0;
        }
        else
        {
          v16 = 0;
          do
          {
            v9[v10] = 0;
            *v9 = 0;
            v16 += 2;
            v9 += 2 * (int)v10;
          }
          while (v16 <= v7);
          v12 = (v7 & 0xFFFFFFFE) + 2;
        }
        if (v12 < (int)a5)
          *v9 = 0;
      }
      ++v6;
    }
    while (v6 != a6);
  }
  return this;
}

uint64_t cv::mixChannels16u(uint64_t this, const unsigned __int16 **a2, const int *a3, unsigned __int16 **a4, const int *a5, int a6)
{
  uint64_t v6;
  int v7;
  _WORD *v8;
  _WORD *v9;
  uint64_t v10;
  signed int v11;
  signed int v12;
  int v13;
  uint64_t v14;
  __int16 v15;
  int v16;

  if (a6 >= 1)
  {
    v6 = 0;
    v7 = (_DWORD)a5 - 2;
    do
    {
      v8 = *(_WORD **)(this + 8 * v6);
      v9 = *(_WORD **)&a3[2 * v6];
      v10 = *((int *)a4 + v6);
      if (v8)
      {
        if ((int)a5 < 2)
        {
          v11 = 0;
        }
        else
        {
          v13 = 0;
          v14 = *((int *)a2 + v6);
          do
          {
            v15 = v8[v14];
            *v9 = *v8;
            v9[v10] = v15;
            v13 += 2;
            v9 += 2 * v10;
            v8 += 2 * (int)v14;
          }
          while (v13 <= v7);
          v11 = (v7 & 0xFFFFFFFE) + 2;
        }
        if (v11 < (int)a5)
          *v9 = *v8;
      }
      else
      {
        if ((int)a5 < 2)
        {
          v12 = 0;
        }
        else
        {
          v16 = 0;
          do
          {
            v9[v10] = 0;
            *v9 = 0;
            v16 += 2;
            v9 += 2 * (int)v10;
          }
          while (v16 <= v7);
          v12 = (v7 & 0xFFFFFFFE) + 2;
        }
        if (v12 < (int)a5)
          *v9 = 0;
      }
      ++v6;
    }
    while (v6 != a6);
  }
  return this;
}

uint64_t cv::mixChannels32s(uint64_t this, const int **a2, const int *a3, int **a4, const int *a5, int a6)
{
  uint64_t v6;
  int v7;
  _DWORD *v8;
  _DWORD *v9;
  uint64_t v10;
  signed int v11;
  signed int v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;

  if (a6 >= 1)
  {
    v6 = 0;
    v7 = (_DWORD)a5 - 2;
    do
    {
      v8 = *(_DWORD **)(this + 8 * v6);
      v9 = *(_DWORD **)&a3[2 * v6];
      v10 = *((int *)a4 + v6);
      if (v8)
      {
        if ((int)a5 < 2)
        {
          v11 = 0;
        }
        else
        {
          v13 = 0;
          v14 = *((int *)a2 + v6);
          do
          {
            v15 = v8[v14];
            *v9 = *v8;
            v9[v10] = v15;
            v13 += 2;
            v9 += 2 * v10;
            v8 += 2 * (int)v14;
          }
          while (v13 <= v7);
          v11 = (v7 & 0xFFFFFFFE) + 2;
        }
        if (v11 < (int)a5)
          *v9 = *v8;
      }
      else
      {
        if ((int)a5 < 2)
        {
          v12 = 0;
        }
        else
        {
          v16 = 0;
          do
          {
            v9[v10] = 0;
            *v9 = 0;
            v16 += 2;
            v9 += 2 * (int)v10;
          }
          while (v16 <= v7);
          v12 = (v7 & 0xFFFFFFFE) + 2;
        }
        if (v12 < (int)a5)
          *v9 = 0;
      }
      ++v6;
    }
    while (v6 != a6);
  }
  return this;
}

uint64_t cv::mixChannels64s(uint64_t this, const uint64_t **a2, const int *a3, uint64_t **a4, const int *a5, int a6)
{
  uint64_t v6;
  int v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  signed int v11;
  signed int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;

  if (a6 >= 1)
  {
    v6 = 0;
    v7 = (_DWORD)a5 - 2;
    do
    {
      v8 = *(_QWORD **)(this + 8 * v6);
      v9 = *(_QWORD **)&a3[2 * v6];
      v10 = *((int *)a4 + v6);
      if (v8)
      {
        if ((int)a5 < 2)
        {
          v11 = 0;
        }
        else
        {
          v13 = 0;
          v14 = *((int *)a2 + v6);
          do
          {
            v15 = v8[v14];
            *v9 = *v8;
            v9[v10] = v15;
            v13 += 2;
            v9 += 2 * v10;
            v8 += 2 * (int)v14;
          }
          while (v13 <= v7);
          v11 = (v7 & 0xFFFFFFFE) + 2;
        }
        if (v11 < (int)a5)
          *v9 = *v8;
      }
      else
      {
        if ((int)a5 < 2)
        {
          v12 = 0;
        }
        else
        {
          v16 = 0;
          do
          {
            v9[v10] = 0;
            *v9 = 0;
            v16 += 2;
            v9 += 2 * (int)v10;
          }
          while (v16 <= v7);
          v12 = (v7 & 0xFFFFFFFE) + 2;
        }
        if (v12 < (int)a5)
          *v9 = 0;
      }
      ++v6;
    }
    while (v6 != a6);
  }
  return this;
}

void cv::gemm(cv *this, const cv::_InputArray *a2, const cv::_InputArray *a3, double a4, const cv::_InputArray *a5, double a6, const cv::_OutputArray *a7)
{
  void (***v7)(uint64_t *__return_ptr, _QWORD, uint64_t);
  char v8;
  char v9;
  double v10;
  double v11;
  void (***v12)(_DWORD *__return_ptr, _QWORD, uint64_t);
  void (***v13)(_DWORD *__return_ptr, _QWORD, uint64_t);
  void (***v14)(uint64_t *__return_ptr, _QWORD, uint64_t);
  void (***v15)(uint64_t *__return_ptr, _QWORD, uint64_t);
  const cv::Exception *v16;
  void *v17[2];
  void *__p[2];
  void *v19[2];
  _DWORD v20[16];
  _DWORD *v21;
  _QWORD *v22;
  _QWORD v23[2];
  uint64_t v24[12];
  uint64_t v25[8];
  _BYTE v26[4136];
  uint64_t v27;

  v7 = (void (***)(uint64_t *__return_ptr, _QWORD, uint64_t))MEMORY[0x24BDAC7A8](this, a2);
  v9 = v8;
  v11 = v10;
  v13 = v12;
  v15 = v14;
  v27 = *MEMORY[0x24BDAC8D0];
  (**v7)(v25, v7, 0xFFFFFFFFLL);
  (**v15)(v24, v15, 0xFFFFFFFFLL);
  if (v11 == 0.0)
  {
    v21 = &v20[2];
    v22 = v23;
    v23[1] = 0;
    v23[0] = 0;
    v20[0] = 1124007936;
    memset(&v20[1], 0, 60);
  }
  else
  {
    (**v13)(v20, v13, 0xFFFFFFFFLL);
  }
  if ((v25[0] & 0xFFF) == (v24[0] & 0xFFF) && (unint64_t)((v25[0] & 0xFF7) - 5) < 2)
    __asm { BR              X10 }
  std::string::basic_string[abi:ne180100]<0>(v17, "type == B.type() && (type == CV_32FC1 || type == CV_64FC1 || type == CV_32FC2 || type == CV_64FC2)");
  std::string::basic_string[abi:ne180100]<0>(v19, "gemm");
  std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matmul.cpp");
  cv::Exception::Exception(v26, 4294967081, v17, v19, __p, 711);
  cv::error((cv *)v26, v16);
}

void sub_219E50A40()
{
  uint64_t v0;
  int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  char v5;
  int v6;
  double v7;
  double v8;
  int v9;
  const cv::Exception *v10;
  int v11;
  const cv::Exception *v12;
  uint64_t v13;
  const cv::_OutputArray *v14;
  float *v15;
  unint64_t v16;
  float *v17;
  unint64_t v18;
  float *v19;
  unint64_t v20;
  float *v21;
  uint64_t v22;
  uint64_t v23;
  float *v24;
  float *v25;
  uint64_t v26;
  float *v27;
  uint64_t v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  double *v34;
  unint64_t v35;
  double *v36;
  unint64_t v37;
  double *v38;
  unint64_t v39;
  double *v40;
  uint64_t v41;
  uint64_t v42;
  double *v43;
  double *v44;
  uint64_t v45;
  double *v46;
  uint64_t v47;
  double v48;
  double v49;
  double v50;
  uint64_t v51;
  float *v52;
  float *v53;
  uint64_t v54;
  float *v55;
  uint64_t v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  uint64_t v65;
  double *v66;
  double *v67;
  uint64_t v68;
  double *v69;
  uint64_t v70;
  double v71;
  double v72;
  double v73;
  double v74;
  double v75;
  uint64_t v76;
  float *v77;
  float *v78;
  uint64_t v79;
  float *v80;
  uint64_t v81;
  float v82;
  float v83;
  float v84;
  float v85;
  float v86;
  float v87;
  float v88;
  float v89;
  float v90;
  float v91;
  float v92;
  uint64_t v93;
  double *v94;
  double *v95;
  uint64_t v96;
  double *v97;
  uint64_t v98;
  double v99;
  double v100;
  double v101;
  double v102;
  double v103;
  double v104;
  double v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  char *v109;
  uint64_t v110;
  double *v111;
  float v112;
  float v113;
  float v114;
  float v115;
  float v116;
  float v117;
  float v118;
  float v119;
  float v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  double *v125;
  double *v126;
  double v127;
  double v128;
  double v129;
  double v130;
  double v131;
  double v132;
  uint64_t v133;
  int v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  char *v138;
  uint64_t v139;
  char *v140;
  double *v141;
  float v142;
  float v143;
  float v144;
  float v145;
  float v146;
  float v147;
  float v148;
  float v149;
  float v150;
  float v151;
  float v152;
  float v153;
  uint64_t v154;
  float v155;
  float v156;
  float v157;
  float v158;
  uint64_t v159;
  uint64_t v160;
  int v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  double *v165;
  double *v166;
  double *v167;
  double v168;
  double v169;
  double v170;
  double v171;
  double v172;
  double v173;
  double v174;
  double v175;
  uint64_t v176;
  double v177;
  double v178;
  char v179;
  int v180;
  uint64_t v181;
  unint64_t v182;
  int v183;
  const cv::Exception *v184;
  unint64_t v185;
  uint64_t *v186;
  BOOL v187;
  unsigned int v188;
  BOOL v191;
  _BYTE *v192;
  unsigned int *v193;
  unsigned int v194;
  unsigned int v195;
  uint64_t v196;
  unint64_t *v197;
  unsigned int v198;
  unint64_t v199;
  unint64_t v200;
  unint64_t v201;
  uint64_t v202;
  uint64_t v203;
  unint64_t v204;
  unint64_t v205;
  void **v206;
  void **v207;
  unsigned int *v208;
  unsigned int v209;
  unsigned int v210;
  uint64_t v211;
  unint64_t *v212;
  unsigned int *v213;
  unsigned int v214;
  unsigned int v215;
  uint64_t v216;
  unint64_t *v217;
  unsigned int *v218;
  unsigned int v219;
  unsigned int v220;
  uint64_t v221;
  uint64_t v222;
  unsigned int *v223;
  unsigned int v224;
  unsigned int v225;
  uint64_t v226;
  uint64_t v227;
  unsigned int *v228;
  unsigned int v229;
  unsigned int v230;
  uint64_t v231;
  uint64_t v232;
  unsigned int *v233;
  unsigned int v234;
  unsigned int v235;
  uint64_t v236;
  uint64_t v237;
  int v238;
  int v239;
  int v240;
  int v241;
  int v242;
  int v243;
  int v244;
  uint64_t v245;
  unint64_t v246;
  uint64_t v247;
  uint64_t v248;
  unint64_t v249;
  _BYTE *v250;
  _BYTE *v251;
  int v252;
  unsigned int *v253;
  unsigned int v254;
  unsigned int v255;
  uint64_t v256;
  unint64_t *v257;
  void **v258;
  void **v259;
  unsigned int *v260;
  unsigned int v261;
  unsigned int v262;
  uint64_t v263;
  unint64_t *v264;
  int v265;
  int v266;
  int v267;
  int v268;
  uint64_t v269;
  int v270;
  uint64_t v271;
  int v272;
  int v273;
  int v274;
  uint64_t v275;
  int v276;
  int v277;
  unint64_t v278;
  uint64_t v279;
  _BYTE *v280;
  double *v281;
  int v282;
  int v283;
  uint64_t v284;
  int v285;
  uint64_t v286;
  _QWORD *v287;
  _BYTE *v288;
  uint64_t v289;
  uint64_t v290;
  uint64_t v291;
  uint64_t v292;
  uint64_t v293;
  uint64_t v294;
  _QWORD *v295;
  _QWORD *v296;
  _BYTE *v297;
  int v298;
  int v299;
  uint64_t v300;
  signed int v301;
  _BYTE *v302;
  uint64_t v303;
  uint64_t v304;
  _QWORD *v305;
  unint64_t v306;
  unint64_t v307;
  double *v308;
  int v309;
  int v310;
  int v311;
  uint64_t (*v312)();
  int v313;
  unint64_t v314;
  uint64_t v315;
  uint64_t v316;
  uint64_t v317;
  uint64_t v318;
  uint64_t v319;
  uint64_t *v320;
  int v321;
  uint64_t v322;
  _BYTE *v323;
  _BYTE *v324;
  uint64_t (*v325)(int, int, int, int, int, int, int, int, int);
  void (*v326)(double, double);
  unint64_t v327;
  uint64_t v328;
  uint64_t v329;
  int v330;
  uint64_t v331;
  signed int v332;
  uint64_t v333;
  _BYTE *v334;
  int v335;
  uint64_t v336;
  unint64_t v337;
  _BYTE *v338;
  int v339;
  int v340;
  char v341;
  int v342;
  _DWORD v343[2];
  _DWORD v344[2];
  _DWORD v345[2];
  _DWORD v346[6];
  _QWORD v347[3];
  _QWORD v348[3];
  _QWORD v349[3];
  uint64_t v350;
  unint64_t v351;
  _BYTE *v352;
  __int128 v353;
  __int128 v354;
  uint64_t v355;
  unint64_t *v356;
  void **v357;
  uint64_t v358;
  uint64_t v359;
  uint64_t v360;
  unint64_t v361;
  _BYTE *v362;
  __int128 v363;
  __int128 v364;
  uint64_t v365;
  unint64_t *v366;
  void **v367;
  _QWORD v368[2];
  _QWORD v369[2];
  uint64_t v370;
  unsigned int *v371;
  uint64_t v372;
  uint64_t v373;
  uint64_t v374;
  uint64_t v375;
  void **v376;
  unint64_t v377;
  _WORD v378[2];
  int v379;
  int v380;
  int v381;
  double *v382;
  unsigned int *v383;
  uint64_t v384;
  uint64_t v385;
  uint64_t v386;
  uint64_t v387;
  void **v388;
  unint64_t v389;
  _BYTE v390[4];
  int v391;
  int v392;
  unsigned int v393;
  double *v394;
  unsigned int *v395;
  uint64_t v396;
  uint64_t v397;
  uint64_t v398;
  uint64_t v399;
  void **v400;
  unint64_t v401;
  uint64_t v402;
  uint64_t v403;
  unsigned int *v404;
  uint64_t v405;
  uint64_t v406;
  uint64_t v407;
  uint64_t v408;
  void **v409;
  unint64_t v410;
  _BYTE *v411;
  unint64_t v412;
  _BYTE v413[4248];

  v9 = v393;
  if (v6 != v392)
  {
    std::string::basic_string[abi:ne180100]<0>(&v350, "a_size.width == len");
    std::string::basic_string[abi:ne180100]<0>(v369, "gemm");
    std::string::basic_string[abi:ne180100]<0>(&v360, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matmul.cpp");
    cv::Exception::Exception(&v411, 4294967081, &v350, v369, &v360, 718);
    cv::error((cv *)&v411, v10);
  }
  v342 = v6;
  v11 = v4;
  if (v382)
  {
    if ((v378[0] & 0xFFF) != (_DWORD)v2)
      goto LABEL_11;
    if ((v1 & 4) != 0)
    {
      if (v380 != v393 || v381 != (_DWORD)v4)
      {
LABEL_11:
        std::string::basic_string[abi:ne180100]<0>(&v350, "C.type() == type && (((flags&GEMM_3_T) == 0 && C.rows == d_size.height && C.cols == d_size.width) || ((flags&GEMM_3_T) != 0 && C.rows == d_size.width && C.cols == d_size.height))");
        std::string::basic_string[abi:ne180100]<0>(v369, "gemm");
        std::string::basic_string[abi:ne180100]<0>(&v360, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matmul.cpp");
        cv::Exception::Exception(&v411, 4294967081, &v350, v369, &v360, 741);
        cv::error((cv *)&v411, v12);
      }
    }
    else if (v380 != (_DWORD)v4 || v381 != v393)
    {
      goto LABEL_11;
    }
  }
  (*(void (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)v3 + 136))(v3, v4, v393, v2, 0xFFFFFFFFLL, 0, 0);
  (**(void (***)(_QWORD *__return_ptr, uint64_t, uint64_t))v3)(v369, v3, 0xFFFFFFFFLL);
  if ((v1 & 4) != 0)
  {
    if (v382 != (double *)v370)
      goto LABEL_111;
    cv::_InputArray::_InputArray((uint64_t)&v411, (const cv::Mat *)v378);
    cv::_OutputArray::_OutputArray((uint64_t)&v350, (cv::Mat *)v378);
    cv::transpose((cv *)&v411, (const cv::_InputArray *)&v350, v14);
    v1 &= ~4u;
  }
  if ((v6 - 2) > 2 || v1)
    goto LABEL_111;
  if (v6 != v9 && v6 != (_DWORD)v4)
    goto LABEL_110;
  if ((_DWORD)v2 == 6)
  {
    v34 = (double *)v370;
    v35 = v377 >> 3;
    v36 = (double *)v403;
    v37 = v410 >> 3;
    v38 = v394;
    v39 = v401 >> 3;
    v40 = v382;
    v41 = v389 >> 3;
    if (!v382)
    {
      v41 = 0;
      v40 = (double *)&cv::gemm(cv::_InputArray const&,cv::_InputArray const&,double,cv::_InputArray const&,double,cv::_OutputArray const&,int)::zero;
    }
    if (v6 != 4)
    {
      if (v6 == 3)
      {
        if (v9 != 3 || v394 == (double *)v370)
        {
          if (v403 == v370)
            goto LABEL_110;
          if (v40 == (double *)&cv::gemm(cv::_InputArray const&,cv::_InputArray const&,double,cv::_InputArray const&,double,cv::_OutputArray const&,int)::zero)
            v41 = 1;
          if (v9 >= 1)
          {
            v121 = 0;
            v13 = v37 + 1;
            v122 = v370 + 8 * v35;
            v123 = v370 + 16 * v35;
            v124 = 8
                 * (v40 != (double *)&cv::gemm(cv::_InputArray const&,cv::_InputArray const&,double,cv::_InputArray const&,double,cv::_OutputArray const&,int)::zero);
            v125 = &v394[v39];
            v126 = &v394[2 * v39];
            do
            {
              v127 = v38[v121];
              v128 = v125[v121];
              v129 = v126[v121];
              v130 = v36[1] * v128 + *v36 * v127 + v36[2] * v129;
              v131 = v128 * v36[v13] + v36[v37] * v127 + v36[v37 + 2] * v129;
              v132 = v128 * v36[(2 * (v37 & 0x1FFFFFFFFFFFFFFFLL)) | 1] + v36[2 * v37] * v127 + v36[2 * v37 + 2] * v129;
              v34[v121] = *v40 * v7 + v130 * v8;
              *(double *)(v122 + 8 * v121) = v40[v41] * v7 + v131 * v8;
              *(double *)(v123 + 8 * v121++) = v40[2 * v41] * v7 + v132 * v8;
              v40 = (double *)((char *)v40 + v124);
            }
            while (v9 != (_DWORD)v121);
          }
        }
        else if ((int)v4 >= 1)
        {
          v13 = v39 + 2;
          v65 = 8 * v37;
          v66 = (double *)(v403 + 8);
          v67 = v40 + 1;
          v68 = 8 * v41;
          v69 = (double *)(v370 + 16);
          v70 = 8 * v35;
          do
          {
            v71 = *(v66 - 1);
            v72 = v66[1];
            v73 = *v66 * v38[v39] + v71 * *v38 + v72 * v38[2 * v39];
            v74 = *v66 * v38[v39 + 1] + v71 * v38[1] + v72 * v38[(2 * (v39 & 0x1FFFFFFFFFFFFFFFLL)) | 1];
            v75 = *v66 * v38[v13] + v71 * v38[2] + v72 * v38[2 * v39 + 2];
            *(v69 - 2) = *(v67 - 1) * v7 + v73 * v8;
            *(v69 - 1) = *v67 * v7 + v74 * v8;
            *v69 = v67[1] * v7 + v75 * v8;
            v66 = (double *)((char *)v66 + v65);
            v67 = (double *)((char *)v67 + v68);
            v69 = (double *)((char *)v69 + v70);
            --v11;
          }
          while (v11);
        }
      }
      else
      {
        if (v6 != 2)
          goto LABEL_110;
        if (v9 != 2 || v394 == (double *)v370)
        {
          if (v403 == v370)
            goto LABEL_110;
          if (v40 == (double *)&cv::gemm(cv::_InputArray const&,cv::_InputArray const&,double,cv::_InputArray const&,double,cv::_OutputArray const&,int)::zero)
            v41 = 1;
          if (v9 >= 1)
          {
            v176 = 8
                 * (v40 != (double *)&cv::gemm(cv::_InputArray const&,cv::_InputArray const&,double,cv::_InputArray const&,double,cv::_OutputArray const&,int)::zero);
            do
            {
              v177 = v38[v39];
              v178 = v177 * v36[v37 + 1] + v36[v37] * *v38;
              *v34 = *v40 * v7 + (v36[1] * v177 + *v36 * *v38) * v8;
              v34[v35] = v40[v41] * v7 + v178 * v8;
              ++v34;
              ++v38;
              v40 = (double *)((char *)v40 + v176);
              --v9;
            }
            while (v9);
          }
        }
        else if ((int)v4 >= 1)
        {
          v42 = 8 * v35;
          v43 = (double *)(v370 + 8);
          v44 = v40 + 1;
          v45 = 8 * v41;
          v46 = (double *)(v403 + 8);
          v47 = 8 * v37;
          do
          {
            v48 = *(v46 - 1);
            v49 = *v46 * v38[v39] + v48 * *v38;
            v50 = *v46 * v38[v39 + 1] + v48 * v38[1];
            *(v43 - 1) = *(v44 - 1) * v7 + v49 * v8;
            *v43 = *v44 * v7 + v50 * v8;
            v43 = (double *)((char *)v43 + v42);
            v44 = (double *)((char *)v44 + v45);
            v46 = (double *)((char *)v46 + v47);
            --v11;
          }
          while (v11);
        }
      }
      goto LABEL_209;
    }
    if (v9 == 4 && v394 != (double *)v370)
    {
      if ((int)v4 >= 1)
      {
        v13 = (2 * (v401 >> 3)) | 1;
        v93 = 8 * v37;
        v94 = (double *)(v403 + 16);
        v95 = v40 + 2;
        v96 = 8 * v41;
        v97 = (double *)(v370 + 16);
        v98 = 8 * v35;
        do
        {
          v99 = *(v94 - 2);
          v100 = *(v94 - 1);
          v101 = v94[1];
          v102 = v100 * v38[v39] + v99 * *v38 + *v94 * v38[2 * v39] + v101 * v38[3 * v39];
          v103 = v100 * v38[v39 + 1] + v99 * v38[1] + *v94 * v38[v13] + v101 * v38[3 * v39 + 1];
          v104 = v100 * v38[v39 + 2] + v99 * v38[2] + *v94 * v38[2 * v39 + 2] + v101 * v38[3 * v39 + 2];
          v105 = v100 * v38[v39 + 3] + v99 * v38[3] + *v94 * v38[2 * v39 + 3] + v101 * v38[3 * v39 + 3];
          *(v97 - 2) = *(v95 - 2) * v7 + v102 * v8;
          *(v97 - 1) = *(v95 - 1) * v7 + v103 * v8;
          *v97 = *v95 * v7 + v104 * v8;
          v97[1] = v95[1] * v7 + v105 * v8;
          v94 = (double *)((char *)v94 + v93);
          v95 = (double *)((char *)v95 + v96);
          v97 = (double *)((char *)v97 + v98);
          --v11;
        }
        while (v11);
      }
      goto LABEL_209;
    }
    LOBYTE(v1) = 0;
    if (v9 <= 16 && v403 != v370)
    {
      if (v40 == (double *)&cv::gemm(cv::_InputArray const&,cv::_InputArray const&,double,cv::_InputArray const&,double,cv::_OutputArray const&,int)::zero)
        v41 = 1;
      if (v9 >= 1)
      {
        v159 = 0;
        v13 = v37 + 1;
        v160 = 8
             * (v40 != (double *)&cv::gemm(cv::_InputArray const&,cv::_InputArray const&,double,cv::_InputArray const&,double,cv::_OutputArray const&,int)::zero);
        v161 = v9;
        v162 = v370 + 24 * v35;
        v163 = v370 + 8 * v35;
        v164 = v370 + 16 * v35;
        v165 = &v394[v39];
        v166 = &v394[3 * v39];
        v167 = &v394[2 * v39];
        do
        {
          v168 = v38[v159];
          v169 = v165[v159];
          v170 = v167[v159];
          v171 = v166[v159];
          v172 = v36[1] * v169 + *v36 * v168 + v36[2] * v170 + v36[3] * v171;
          v173 = v169 * v36[v13] + v36[v37] * v168 + v36[v37 + 2] * v170 + v36[v37 + 3] * v171;
          v174 = v169 * v36[(2 * (v37 & 0x1FFFFFFFFFFFFFFFLL)) | 1]
               + v36[2 * v37] * v168
               + v36[2 * v37 + 2] * v170
               + v36[2 * v37 + 3] * v171;
          v175 = v169 * v36[3 * v37 + 1] + v36[3 * v37] * v168 + v36[3 * v37 + 2] * v170 + v36[3 * v37 + 3] * v171;
          v34[v159] = *v40 * v7 + v172 * v8;
          *(double *)(v163 + 8 * v159) = v40[v41] * v7 + v173 * v8;
          *(double *)(v164 + 8 * v159) = v40[2 * v41] * v7 + v174 * v8;
          *(double *)(v162 + 8 * v159++) = v40[3 * v41] * v7 + v175 * v8;
          v40 = (double *)((char *)v40 + v160);
        }
        while (v161 != (_DWORD)v159);
      }
      goto LABEL_209;
    }
LABEL_111:
    v179 = v5;
    v180 = v4;
    v181 = v401;
    v366 = &v361;
    v367 = (void **)v368;
    v368[1] = 0;
    v368[0] = 0;
    LODWORD(v360) = 1124007936;
    *(_OWORD *)(v0 + 124) = 0u;
    *(_OWORD *)(v0 + 140) = 0u;
    *(_OWORD *)(v0 + 156) = 0u;
    v182 = v389;
    v308 = v382;
    if (!v382)
      v182 = 0;
    v327 = v182;
    v411 = v413;
    v412 = 4104;
    v183 = v2 - 5;
    *(_OWORD *)(v0 + 168) = 0uLL;
    if ((v2 - 5) >= 0xA || ((0x303u >> v183) & 1) == 0)
    {
      std::string::basic_string[abi:ne180100]<0>(v349, "type == CV_64FC2");
      std::string::basic_string[abi:ne180100]<0>(v348, "gemm");
      std::string::basic_string[abi:ne180100]<0>(v347, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matmul.cpp");
      cv::Exception::Exception(&v350, 4294967081, v349, v348, v347, 1041);
      cv::error((cv *)&v350, v184);
    }
    v325 = off_24DBF0110[v183];
    v326 = (void (*)(double, double))off_24DBF00C0[v183];
    v312 = off_24DBF0160[v183];
    if (v370 == v403 || (double *)v370 == v394)
    {
      v185 = (int)(((v2 >> 3) + 1) << ((0xFA50u >> (2 * (v2 & 7))) & 3)) * (uint64_t)v11 * v9;
      v186 = &v360;
    }
    else
    {
      v185 = 0;
      v186 = v369;
    }
    v320 = v186;
    v187 = v9 == 1 || v6 == 1;
    if (v187 && (v1 & 2) == 0 && (v390[1] & 0x40) != 0)
    {
      if (v9 == 1)
        v188 = 0;
      else
        v188 = ((v2 >> 3) + 1) << ((0xFA50u >> (2 * (v2 & 7))) & 3);
      v181 = v188;
      LOBYTE(v1) = v1 | 2;
    }
    v191 = (v11 < 65 || v9 < 65) && v6 < 10001;
    if (v6 < 11 || v191 || v6 <= 0x80 && v11 <= 128 && v9 <= 128)
    {
      if (!v185)
      {
LABEL_194:
        v346[4] = v6;
        v346[5] = v180;
        v346[2] = v9;
        v346[3] = v11;
        v326(v8, v7);
        goto LABEL_195;
      }
      v192 = v411;
      if (v412 < v185)
      {
        if (v411 != v413)
        {
          if (v411)
            MEMORY[0x2207351A4](v411, 0x1000C8077774924, v394);
          v411 = v413;
        }
        v412 = v185;
        v192 = v413;
        if (v185 >= 0x1009)
        {
          v192 = (_BYTE *)operator new[]();
          v411 = v192;
        }
      }
      v351 = __PAIR64__(v9, v11);
      v352 = v192;
      *(_QWORD *)&v353 = 0;
      v356 = &v351;
      v357 = (void **)&v358;
      HIDWORD(v350) = 2;
      LODWORD(v350) = v2 | 0x42FF4000;
      v358 = (int)(((v2 >> 3) + 1) << ((0xFA50u >> (2 * (v2 & 7))) & 3)) * (uint64_t)v9;
      v359 = ((v2 >> 3) + 1) << ((0xFA50u >> (2 * (v2 & 7))) & 3);
      v355 = 0;
      *((_QWORD *)&v354 + 1) = &v192[v358 * v11];
      *((_QWORD *)&v353 + 1) = v192;
      *(_QWORD *)&v354 = *((_QWORD *)&v354 + 1);
      v193 = (unsigned int *)v363;
      if ((_QWORD)v363)
      {
        do
        {
          v194 = __ldaxr(v193);
          v195 = v194 - 1;
        }
        while (__stlxr(v195, v193));
        if (!v195)
          cv::Mat::deallocate((cv::Mat *)&v360, (void *)v13);
      }
      v362 = 0;
      *((_QWORD *)&v363 + 1) = 0;
      v364 = 0uLL;
      if (v360 <= 0)
      {
        *(_QWORD *)&v363 = 0;
        LODWORD(v360) = v350;
      }
      else
      {
        v196 = 0;
        v197 = v366;
        do
          *((_DWORD *)v197 + v196++) = 0;
        while (v196 < SHIDWORD(v360));
        *(_QWORD *)&v363 = 0;
        LODWORD(v360) = v350;
        if (SHIDWORD(v360) > 2)
          goto LABEL_184;
      }
      if (SHIDWORD(v350) <= 2)
      {
        HIDWORD(v360) = HIDWORD(v350);
        v361 = v351;
        v206 = v357;
        v207 = v367;
        *v367 = *v357;
        v207[1] = v206[1];
        goto LABEL_185;
      }
LABEL_184:
      cv::Mat::copySize((cv::Mat *)&v360, (const cv::Mat *)&v350);
LABEL_185:
      v363 = v353;
      v364 = v354;
      v362 = v352;
      v365 = v355;
      v208 = (unsigned int *)v353;
      if ((_QWORD)v353)
      {
        do
        {
          v209 = __ldaxr(v208);
          v210 = v209 - 1;
        }
        while (__stlxr(v210, v208));
        if (!v210)
          cv::Mat::deallocate((cv::Mat *)&v350, (void *)v13);
      }
      v352 = 0;
      v354 = 0uLL;
      *((_QWORD *)&v353 + 1) = 0;
      if (SHIDWORD(v350) >= 1)
      {
        v211 = 0;
        v212 = v356;
        do
          *((_DWORD *)v212 + v211++) = 0;
        while (v211 < SHIDWORD(v350));
      }
      *(_QWORD *)&v353 = 0;
      if (v357 != (void **)&v358)
        cv::fastFree(v357, (void *)v13);
      goto LABEL_194;
    }
    v198 = (v2 >> 3) + 1;
    v199 = v198 << ((0xFA50u >> (2 * (v179 & 7))) & 3);
    if ((v1 & 1) != 0)
      v200 = v198 << ((0xFA50u >> (2 * (v179 & 7))) & 3);
    else
      v200 = v410;
    v307 = v200;
    if ((v1 & 1) != 0)
      v201 = v410;
    else
      v201 = v198 << ((0xFA50u >> (2 * (v179 & 7))) & 3);
    if ((v1 & 2) != 0)
      v202 = v198 << ((0xFA50u >> (2 * (v179 & 7))) & 3);
    else
      v202 = v181;
    v336 = v202;
    v337 = v201;
    if ((v1 & 2) != 0)
      v203 = v181;
    else
      v203 = v198 << ((0xFA50u >> (2 * (v179 & 7))) & 3);
    v315 = v203;
    v341 = v1;
    if (v382)
    {
      v204 = v389;
      if ((v1 & 4) != 0)
        v205 = v198 << ((0xFA50u >> (2 * (v179 & 7))) & 3);
      else
        v205 = v389;
      v306 = v205;
      if ((v1 & 4) == 0)
        v204 = v198 << ((0xFA50u >> (2 * (v179 & 7))) & 3);
      v314 = v204;
      LOBYTE(v340) = v1;
    }
    else
    {
      v306 = 0;
      v314 = 0;
      LOBYTE(v340) = v1 & 0xFB;
    }
    if (v11 >= 128)
      v238 = 128;
    else
      v238 = v11;
    if (v9 >= 128)
      v239 = 128;
    else
      v239 = v9;
    v240 = v239;
    v241 = 0x4000 / v239;
    if (v241 >= 0x4000 / v238)
      v241 = 0x4000 / v238;
    v335 = v241;
    if (v342 >= v241)
      v242 = v241;
    else
      v242 = v342;
    v310 = v238;
    if (v242 * v238 > 0x4000)
      v310 = (__int16)(0x4000 / (__int16)v242);
    v339 = v9;
    v316 = ((_DWORD)v199 << ((v179 & 7) == 5));
    v243 = v240;
    if (v242 * v240 > 0x4000)
      v243 = (__int16)(0x4000 / (__int16)v242);
    v313 = v243;
    v309 = v11;
    v244 = v242 + ((__int16)(v242 + (((__int16)v242 >> 28) & 7)) >> 3);
    v330 = v244 + 1;
    v332 = ((v243 + v243 / 8) & 0xFFFFFFFE) + 2;
    v245 = v332 * (uint64_t)(v244 + 1);
    v246 = v245 * v199;
    v247 = v245 * v316;
    if ((v341 & 1) != 0)
    {
      v248 = (int)(((v244 & 0xFFFFFFFE) + 2) * v199 + ((v244 & 0xFFFFFFFE) + 2) * v199 * (v310 + v310 / 8));
      LOBYTE(v340) = v340 & 0xFE;
    }
    else
    {
      v248 = 0;
    }
    v249 = v246 + v185 + v247 + v248;
    v250 = v411;
    if (v412 < v249)
    {
      if (v411 != v413)
      {
        if (v411)
          MEMORY[0x2207351A4](v411, 0x1000C8077774924, v394);
        v411 = v413;
      }
      v412 = v246 + v185 + v247 + v248;
      v250 = v413;
      if (v249 >= 0x1009)
      {
        v250 = (_BYTE *)operator new[]();
        v411 = v250;
      }
    }
    v338 = v250;
    v334 = &v250[v247];
    v324 = &v250[v247 + v246];
    if ((v341 & 1) != 0)
      v251 = &v250[v247 + v246];
    else
      v251 = 0;
    v323 = v251;
    v252 = v339;
    if (!v185)
      goto LABEL_298;
    v351 = __PAIR64__(v339, v309);
    v352 = &v324[v248];
    *(_QWORD *)&v353 = 0;
    v356 = &v351;
    v357 = (void **)&v358;
    HIDWORD(v350) = 2;
    LODWORD(v350) = v2 | 0x42FF4000;
    v358 = (int)(v198 << ((0xFA50u >> (2 * (v2 & 7))) & 3)) * (uint64_t)v339;
    v359 = v198 << ((0xFA50u >> (2 * (v2 & 7))) & 3);
    v355 = 0;
    *((_QWORD *)&v354 + 1) = &v324[v248 + v358 * v309];
    *((_QWORD *)&v353 + 1) = &v324[v248];
    *(_QWORD *)&v354 = *((_QWORD *)&v354 + 1);
    v253 = (unsigned int *)v363;
    if ((_QWORD)v363)
    {
      do
      {
        v254 = __ldaxr(v253);
        v255 = v254 - 1;
      }
      while (__stlxr(v255, v253));
      if (!v255)
        cv::Mat::deallocate((cv::Mat *)&v360, (void *)v13);
    }
    v362 = 0;
    *((_QWORD *)&v363 + 1) = 0;
    v364 = 0uLL;
    if (v360 <= 0)
    {
      *(_QWORD *)&v363 = 0;
      LODWORD(v360) = v350;
    }
    else
    {
      v256 = 0;
      v257 = v366;
      do
        *((_DWORD *)v257 + v256++) = 0;
      while (v256 < SHIDWORD(v360));
      *(_QWORD *)&v363 = 0;
      LODWORD(v360) = v350;
      if (SHIDWORD(v360) > 2)
        goto LABEL_288;
    }
    if (SHIDWORD(v350) <= 2)
    {
      HIDWORD(v360) = HIDWORD(v350);
      v361 = v351;
      v258 = v357;
      v259 = v367;
      *v367 = *v357;
      v259[1] = v258[1];
      goto LABEL_289;
    }
LABEL_288:
    cv::Mat::copySize((cv::Mat *)&v360, (const cv::Mat *)&v350);
LABEL_289:
    v363 = v353;
    v364 = v354;
    v362 = v352;
    v365 = v355;
    v260 = (unsigned int *)v353;
    if ((_QWORD)v353)
    {
      do
      {
        v261 = __ldaxr(v260);
        v262 = v261 - 1;
      }
      while (__stlxr(v262, v260));
      if (!v262)
        cv::Mat::deallocate((cv::Mat *)&v350, (void *)v13);
    }
    v352 = 0;
    v354 = 0uLL;
    *((_QWORD *)&v353 + 1) = 0;
    if (SHIDWORD(v350) >= 1)
    {
      v263 = 0;
      v264 = v356;
      do
        *((_DWORD *)v264 + v263++) = 0;
      while (v263 < SHIDWORD(v350));
    }
    *(_QWORD *)&v353 = 0;
    if (v357 != (void **)&v358)
      cv::fastFree(v357, (void *)v13);
LABEL_298:
    v265 = v309;
    if (v309 < 1)
      goto LABEL_195;
    v266 = 0;
    v322 = (uint64_t)&v338[((int)v316 + (int)v199) * (uint64_t)v330 * v332 + 8];
    while (1)
    {
      if (v266 + v310 >= v265 || (v267 = v310, v310 + 8 * (v266 + v310) > 8 * v309))
        v267 = v265 - v266;
      v311 = v266;
      if (v252 < 1)
        goto LABEL_364;
      v268 = 0;
      v317 = (uint64_t)v308 + v306 * v266;
      v319 = v266;
      v269 = v307 * v266;
      if (v267 <= 1)
        v270 = 1;
      else
        v270 = v267;
      do
      {
        v271 = v268;
        v272 = v313;
        if (v268 + v313 >= v252 || v313 + 8 * (v268 + v313) > 8 * v339)
          v272 = v252 - v268;
        v273 = 0;
        v318 = v268 * (int)v199;
        v328 = v320[2] + v320[10] * v319 + v318;
        v329 = v320[10];
        v333 = v317 + v314 * v268;
        v274 = v340 & 0xF;
        v331 = v272 * (int)v316;
        v321 = v271;
        v275 = v315 * v271;
        v340 = v274 | 0x10;
        v276 = v342;
        do
        {
          while (1)
          {
            if (v273 + v242 >= v276 || (v277 = v242, v242 + 8 * (v273 + v242) > 8 * v342))
              v277 = v342 - v273;
            v278 = v410;
            v279 = v337 * v273;
            v280 = (_BYTE *)(v403 + v269 + v279);
            v281 = v394;
            if ((v341 & 1) == 0)
            {
              v282 = v267;
              v283 = v277;
LABEL_337:
              v284 = v410;
              goto LABEL_338;
            }
            if (!v338)
            {
              v282 = v277;
              v283 = v267;
              goto LABEL_337;
            }
            v284 = (int)v199 * (uint64_t)v277;
            if (v267 < 1)
            {
              v282 = v267;
              v283 = v277;
              v280 = v324;
            }
            else
            {
              if (v199 > 0x10 || ((1 << v199) & 0x10110) == 0)
                __assert_rtn("GEMM_TransposeBlock", "matmul.cpp", 124, "0");
              v285 = 0;
              v286 = v403 + v269 + v279 + 8;
              v287 = (_QWORD *)v322;
              v288 = v324;
              do
              {
                if (v199 == 4)
                {
                  if (v277 >= 1)
                  {
                    v292 = 0;
                    v293 = 0;
                    do
                    {
                      *(_DWORD *)&v288[4 * v293++] = *(_DWORD *)&v280[v292];
                      v292 += v278;
                    }
                    while (v277 != v293);
                  }
                }
                else if (v199 == 8)
                {
                  if (v277 >= 1)
                  {
                    v289 = 0;
                    v290 = 0;
                    v291 = 0;
                    do
                    {
                      *(_QWORD *)&v288[v290] = *(_QWORD *)&v280[v289];
                      v291 += 2;
                      v290 += 8;
                      v289 += v278;
                    }
                    while (v291 < 2 * v277);
                  }
                }
                else if (v277 >= 1)
                {
                  v294 = 0;
                  v295 = v287;
                  v296 = (_QWORD *)v286;
                  do
                  {
                    *(v295 - 1) = *(v296 - 1);
                    *v295 = *v296;
                    v295 += 2;
                    v294 += 4;
                    v296 = (_QWORD *)((char *)v296 + v278);
                  }
                  while (v294 < 4 * v277);
                }
                ++v285;
                v288 += v284;
                v280 += v199;
                v286 += v199;
                v287 = (_QWORD *)((char *)v287 + v284);
              }
              while (v285 != v270);
              v282 = v267;
              v283 = v277;
              v280 = v323;
            }
LABEL_338:
            v297 = (char *)v281 + v336 * v273 + v275;
            if (v272 >= v339)
            {
              v300 = v181;
            }
            else
            {
              if ((v341 & 2) != 0)
                v298 = v272;
              else
                v298 = v277;
              if ((v341 & 2) != 0)
                v299 = v277;
              else
                v299 = v272;
              v300 = (int)v199 * (uint64_t)v299;
              if (v298)
              {
                v301 = v299 * (v199 >> 2);
                v302 = v334;
                do
                {
                  if (v301 >= 4)
                  {
                    v304 = 0;
                    v303 = 0;
                    do
                    {
                      v305 = &v302[v304];
                      *v305 = *(_QWORD *)&v297[v304];
                      v305[1] = *(_QWORD *)&v297[v304 + 8];
                      v303 += 4;
                      v304 += 16;
                    }
                    while (v303 <= v301 - 4);
                    v303 = v303;
                  }
                  else
                  {
                    v303 = 0;
                  }
                  if ((int)v303 < v301)
                  {
                    do
                    {
                      *(_DWORD *)&v302[4 * v303] = *(_DWORD *)&v297[4 * v303];
                      ++v303;
                    }
                    while (v303 < v301);
                  }
                  v297 += v181;
                  v302 += v300;
                  --v298;
                }
                while (v298);
              }
              v297 = v334;
            }
            if (v342 > v335)
              break;
            v344[0] = v283;
            v344[1] = v282;
            v343[0] = v272;
            v343[1] = v267;
            ((void (*)(_BYTE *, uint64_t, _BYTE *, uint64_t, uint64_t, unint64_t, uint64_t, uint64_t, double, double, _DWORD *, _DWORD *, int))v326)(v280, v284, v297, v300, v333, v327, v328, v329, v8, v7, v344, v343, v274);
            v273 += v277;
            v274 = v340;
            v276 = v342;
            if (v273 >= v342)
              goto LABEL_363;
          }
          v346[0] = v283;
          v346[1] = v282;
          v345[0] = v272;
          v345[1] = v267;
          v325((int)v280, v284, (int)v297, v300, (int)v338, v331, (int)v346, (int)v345, v274);
          v273 += v277;
          v274 = v340;
          v276 = v342;
        }
        while (v273 < v342);
        ((void (*)(uint64_t, unint64_t, _BYTE *, uint64_t, uint64_t, double, double))v312)(v333, v327, v338, v331, v320[2] + v320[10] * v319 + v318, v8, v7);
LABEL_363:
        v268 = v272 + v321;
        v252 = v339;
      }
      while (v272 + v321 < v339);
LABEL_364:
      v266 = v267 + v311;
      v265 = v309;
      if (v267 + v311 >= v309)
      {
LABEL_195:
        if (v320 != v369)
        {
          cv::_OutputArray::_OutputArray((uint64_t)&v350, (cv::Mat *)v369);
          cv::Mat::copyTo((cv::Mat *)v320, (const cv::_OutputArray *)&v350);
        }
        if (v411 != v413 && v411)
          MEMORY[0x2207351A4]();
        v213 = (unsigned int *)v363;
        if ((_QWORD)v363)
        {
          do
          {
            v214 = __ldaxr(v213);
            v215 = v214 - 1;
          }
          while (__stlxr(v215, v213));
          if (!v215)
            cv::Mat::deallocate((cv::Mat *)&v360, (void *)v13);
        }
        v362 = 0;
        *((_QWORD *)&v363 + 1) = 0;
        v364 = 0uLL;
        if (SHIDWORD(v360) >= 1)
        {
          v216 = 0;
          v217 = v366;
          do
            *((_DWORD *)v217 + v216++) = 0;
          while (v216 < SHIDWORD(v360));
        }
        *(_QWORD *)&v363 = 0;
        if (v367 != v368)
          cv::fastFree(v367, (void *)v13);
        goto LABEL_209;
      }
    }
  }
  if ((_DWORD)v2 != 5)
    goto LABEL_110;
  v15 = (float *)v370;
  v16 = v377 >> 2;
  v17 = (float *)v403;
  v18 = v410 >> 2;
  v19 = (float *)v394;
  v20 = v401 >> 2;
  v21 = (float *)v382;
  v22 = v389 >> 2;
  if (!v382)
  {
    v22 = 0;
    v21 = (float *)&cv::gemm(cv::_InputArray const&,cv::_InputArray const&,double,cv::_InputArray const&,double,cv::_OutputArray const&,int)::zerof;
  }
  if (v6 != 4)
  {
    if (v6 != 3)
    {
      if (v6 == 2)
      {
        if (v9 == 2 && v394 != (double *)v370)
        {
          if ((int)v4 >= 1)
          {
            v23 = 4 * v16;
            v24 = (float *)(v370 + 4);
            v25 = (float *)(v403 + 4);
            v26 = 4 * v18;
            v27 = v21 + 1;
            v28 = 4 * v22;
            do
            {
              v29 = *(v25 - 1);
              v30 = (float)(*v25 * v19[v20]) + (float)(v29 * *v19);
              v31 = (float)(*v25 * v19[v20 + 1]) + (float)(v29 * v19[1]);
              v32 = *(v27 - 1) * v7 + v30 * v8;
              *(v24 - 1) = v32;
              v33 = *v27 * v7 + v31 * v8;
              *v24 = v33;
              v24 = (float *)((char *)v24 + v23);
              v25 = (float *)((char *)v25 + v26);
              v27 = (float *)((char *)v27 + v28);
              --v11;
            }
            while (v11);
          }
          goto LABEL_209;
        }
        if (v403 != v370)
        {
          if (v21 == (float *)&cv::gemm(cv::_InputArray const&,cv::_InputArray const&,double,cv::_InputArray const&,double,cv::_OutputArray const&,int)::zerof)
            v22 = 1;
          if (v9 >= 1)
          {
            v154 = 4
                 * (v21 != (float *)&cv::gemm(cv::_InputArray const&,cv::_InputArray const&,double,cv::_InputArray const&,double,cv::_OutputArray const&,int)::zerof);
            do
            {
              v155 = v19[v20];
              v156 = (float)(v155 * v17[v18 + 1]) + (float)(v17[v18] * *v19);
              v157 = *v21 * v7 + (float)((float)(v17[1] * v155) + (float)(*v17 * *v19)) * v8;
              *v15 = v157;
              v158 = v21[v22] * v7 + v156 * v8;
              v15[v16] = v158;
              ++v15;
              ++v19;
              v21 = (float *)((char *)v21 + v154);
              --v9;
            }
            while (v9);
          }
          goto LABEL_209;
        }
      }
      goto LABEL_110;
    }
    if (v9 == 3 && v394 != (double *)v370)
    {
      if ((int)v4 >= 1)
      {
        v13 = v20 + 2;
        v51 = 4 * v22;
        v52 = v21 + 1;
        v53 = (float *)(v403 + 4);
        v54 = 4 * v18;
        v55 = (float *)(v370 + 8);
        v56 = 4 * v16;
        do
        {
          v57 = *(v53 - 1);
          v58 = v53[1];
          v59 = (float)((float)(*v53 * v19[v20]) + (float)(v57 * *v19)) + (float)(v58 * v19[2 * v20]);
          v60 = (float)((float)(*v53 * v19[v20 + 1]) + (float)(v57 * v19[1]))
              + (float)(v58 * v19[(2 * (v20 & 0x3FFFFFFFFFFFFFFFLL)) | 1]);
          v61 = (float)((float)(*v53 * v19[v13]) + (float)(v57 * v19[2])) + (float)(v58 * v19[2 * v20 + 2]);
          v62 = *(v52 - 1) * v7 + v59 * v8;
          *(v55 - 2) = v62;
          v63 = *v52 * v7 + v60 * v8;
          *(v55 - 1) = v63;
          v64 = v52[1] * v7 + v61 * v8;
          *v55 = v64;
          v52 = (float *)((char *)v52 + v51);
          v53 = (float *)((char *)v53 + v54);
          v55 = (float *)((char *)v55 + v56);
          --v11;
        }
        while (v11);
      }
      goto LABEL_209;
    }
    if (v403 != v370)
    {
      if (v21 == (float *)&cv::gemm(cv::_InputArray const&,cv::_InputArray const&,double,cv::_InputArray const&,double,cv::_OutputArray const&,int)::zerof)
        v22 = 1;
      if (v9 >= 1)
      {
        v106 = 0;
        v13 = v18 + 1;
        v107 = v370 + 4 * v16;
        v108 = v370 + 8 * v16;
        v109 = (char *)v394 + 4 * v20;
        v110 = 4
             * (v21 != (float *)&cv::gemm(cv::_InputArray const&,cv::_InputArray const&,double,cv::_InputArray const&,double,cv::_OutputArray const&,int)::zerof);
        v111 = &v394[v20];
        do
        {
          v112 = v19[v106];
          v113 = *(float *)&v109[4 * v106];
          v114 = *((float *)v111 + v106);
          v115 = (float)((float)(v17[1] * v113) + (float)(*v17 * v112)) + (float)(v17[2] * v114);
          v116 = (float)((float)(v113 * v17[v13]) + (float)(v17[v18] * v112)) + (float)(v17[v18 + 2] * v114);
          v117 = (float)((float)(v113 * v17[(2 * (v18 & 0x3FFFFFFFFFFFFFFFLL)) | 1]) + (float)(v17[2 * v18] * v112))
               + (float)(v17[2 * v18 + 2] * v114);
          v118 = *v21 * v7 + v115 * v8;
          v15[v106] = v118;
          v119 = v21[v22] * v7 + v116 * v8;
          *(float *)(v107 + 4 * v106) = v119;
          v120 = v21[2 * v22] * v7 + v117 * v8;
          *(float *)(v108 + 4 * v106++) = v120;
          v21 = (float *)((char *)v21 + v110);
        }
        while (v9 != (_DWORD)v106);
      }
      goto LABEL_209;
    }
LABEL_110:
    LOBYTE(v1) = 0;
    goto LABEL_111;
  }
  if (v9 != 4 || v394 == (double *)v370)
  {
    if (v403 == v370)
      goto LABEL_110;
    if (v21 == (float *)&cv::gemm(cv::_InputArray const&,cv::_InputArray const&,double,cv::_InputArray const&,double,cv::_OutputArray const&,int)::zerof)
      v22 = 1;
    if (v9 >= 1)
    {
      v133 = 0;
      v13 = v18 + 1;
      v134 = v9;
      v135 = v370 + 4 * v16;
      v136 = v370 + 12 * v16;
      v137 = v370 + 8 * v16;
      v138 = (char *)v394 + 4 * v20;
      v139 = 4
           * (v21 != (float *)&cv::gemm(cv::_InputArray const&,cv::_InputArray const&,double,cv::_InputArray const&,double,cv::_OutputArray const&,int)::zerof);
      v140 = (char *)v394 + 12 * v20;
      v141 = &v394[v20];
      do
      {
        v142 = v19[v133];
        v143 = *(float *)&v138[4 * v133];
        v144 = *((float *)v141 + v133);
        v145 = *(float *)&v140[4 * v133];
        v146 = (float)((float)((float)(v17[1] * v143) + (float)(*v17 * v142)) + (float)(v17[2] * v144))
             + (float)(v17[3] * v145);
        v147 = (float)((float)((float)(v143 * v17[v13]) + (float)(v17[v18] * v142)) + (float)(v17[v18 + 2] * v144))
             + (float)(v17[v18 + 3] * v145);
        v148 = (float)((float)((float)(v143 * v17[(2 * (v18 & 0x3FFFFFFFFFFFFFFFLL)) | 1]) + (float)(v17[2 * v18] * v142))
                     + (float)(v17[2 * v18 + 2] * v144))
             + (float)(v17[2 * v18 + 3] * v145);
        v149 = (float)((float)((float)(v143 * v17[3 * v18 + 1]) + (float)(v17[3 * v18] * v142))
                     + (float)(v17[3 * v18 + 2] * v144))
             + (float)(v17[3 * v18 + 3] * v145);
        v150 = *v21 * v7 + v146 * v8;
        v15[v133] = v150;
        v151 = v21[v22] * v7 + v147 * v8;
        *(float *)(v135 + 4 * v133) = v151;
        v152 = v21[2 * v22] * v7 + v148 * v8;
        *(float *)(v137 + 4 * v133) = v152;
        v153 = v21[3 * v22] * v7 + v149 * v8;
        *(float *)(v136 + 4 * v133++) = v153;
        v21 = (float *)((char *)v21 + v139);
      }
      while (v134 != (_DWORD)v133);
    }
  }
  else if ((int)v4 >= 1)
  {
    v13 = (2 * (v401 >> 2)) | 1;
    v76 = 4 * v22;
    v77 = v21 + 2;
    v78 = (float *)(v403 + 8);
    v79 = 4 * v18;
    v80 = (float *)(v370 + 8);
    v81 = 4 * v16;
    do
    {
      v82 = *(v78 - 2);
      v83 = *(v78 - 1);
      v84 = v78[1];
      v85 = (float)((float)((float)(v83 * v19[v20]) + (float)(v82 * *v19)) + (float)(*v78 * v19[2 * v20]))
          + (float)(v84 * v19[3 * v20]);
      v86 = (float)((float)((float)(v83 * v19[v20 + 1]) + (float)(v82 * v19[1])) + (float)(*v78 * v19[v13]))
          + (float)(v84 * v19[3 * v20 + 1]);
      v87 = (float)((float)((float)(v83 * v19[v20 + 2]) + (float)(v82 * v19[2])) + (float)(*v78 * v19[2 * v20 + 2]))
          + (float)(v84 * v19[3 * v20 + 2]);
      v88 = (float)((float)((float)(v83 * v19[v20 + 3]) + (float)(v82 * v19[3])) + (float)(*v78 * v19[2 * v20 + 3]))
          + (float)(v84 * v19[3 * v20 + 3]);
      v89 = *(v77 - 2) * v7 + v85 * v8;
      *(v80 - 2) = v89;
      v90 = *(v77 - 1) * v7 + v86 * v8;
      *(v80 - 1) = v90;
      v91 = *v77 * v7 + v87 * v8;
      *v80 = v91;
      v92 = v77[1] * v7 + v88 * v8;
      v80[1] = v92;
      v77 = (float *)((char *)v77 + v76);
      v78 = (float *)((char *)v78 + v79);
      v80 = (float *)((char *)v80 + v81);
      --v11;
    }
    while (v11);
  }
LABEL_209:
  v218 = v371;
  if (v371)
  {
    do
    {
      v219 = __ldaxr(v218);
      v220 = v219 - 1;
    }
    while (__stlxr(v220, v218));
    if (!v220)
      cv::Mat::deallocate((cv::Mat *)v369, (void *)v13);
  }
  v370 = 0;
  v372 = 0;
  v374 = 0;
  v373 = 0;
  if (SHIDWORD(v369[0]) >= 1)
  {
    v221 = 0;
    v222 = v375;
    do
      *(_DWORD *)(v222 + 4 * v221++) = 0;
    while (v221 < SHIDWORD(v369[0]));
  }
  v371 = 0;
  if (v376 != (void **)&v377)
    cv::fastFree(v376, (void *)v13);
  v223 = v383;
  if (v383)
  {
    do
    {
      v224 = __ldaxr(v223);
      v225 = v224 - 1;
    }
    while (__stlxr(v225, v223));
    if (!v225)
      cv::Mat::deallocate((cv::Mat *)v378, (void *)v13);
  }
  v382 = 0;
  v384 = 0;
  v386 = 0;
  v385 = 0;
  if (v379 >= 1)
  {
    v226 = 0;
    v227 = v387;
    do
      *(_DWORD *)(v227 + 4 * v226++) = 0;
    while (v226 < v379);
  }
  v383 = 0;
  if (v388 != (void **)&v389)
    cv::fastFree(v388, (void *)v13);
  v228 = v395;
  if (v395)
  {
    do
    {
      v229 = __ldaxr(v228);
      v230 = v229 - 1;
    }
    while (__stlxr(v230, v228));
    if (!v230)
      cv::Mat::deallocate((cv::Mat *)v390, (void *)v13);
  }
  v394 = 0;
  v396 = 0;
  v398 = 0;
  v397 = 0;
  if (v391 >= 1)
  {
    v231 = 0;
    v232 = v399;
    do
      *(_DWORD *)(v232 + 4 * v231++) = 0;
    while (v231 < v391);
  }
  v395 = 0;
  if (v400 != (void **)&v401)
    cv::fastFree(v400, (void *)v13);
  v233 = v404;
  if (v404)
  {
    do
    {
      v234 = __ldaxr(v233);
      v235 = v234 - 1;
    }
    while (__stlxr(v235, v233));
    if (!v235)
      cv::Mat::deallocate((cv::Mat *)&v402, (void *)v13);
  }
  v403 = 0;
  v405 = 0;
  v407 = 0;
  v406 = 0;
  if (SHIDWORD(v402) >= 1)
  {
    v236 = 0;
    v237 = v408;
    do
      *(_DWORD *)(v237 + 4 * v236++) = 0;
    while (v236 < SHIDWORD(v402));
  }
  v404 = 0;
  if (v409 != (void **)&v410)
    cv::fastFree(v409, (void *)v13);
}

void sub_219E52B48(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  unint64_t v16;
  unsigned int *v17;
  unsigned int v18;
  unsigned int v19;
  uint64_t v20;
  unint64_t v21;
  unsigned int *v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t v25;
  unint64_t v26;
  unsigned int *v27;
  unsigned int v28;
  unsigned int v29;
  uint64_t v30;
  unint64_t v31;
  unsigned int *v32;
  unsigned int v33;
  unsigned int v34;
  uint64_t v35;
  unint64_t v36;
  unsigned int *v37;
  unsigned int v38;
  unsigned int v39;
  uint64_t v40;
  unint64_t v41;

  v16 = STACK[0x438];
  if (STACK[0x438] != a15 && v16)
    MEMORY[0x2207351A4](v16, 0x1000C8077774924);
  v17 = (unsigned int *)STACK[0x270];
  if (STACK[0x270])
  {
    do
    {
      v18 = __ldaxr(v17);
      v19 = v18 - 1;
    }
    while (__stlxr(v19, v17));
    if (!v19)
      cv::Mat::deallocate((cv::Mat *)&STACK[0x258], a2);
  }
  STACK[0x268] = 0;
  STACK[0x278] = 0;
  STACK[0x288] = 0;
  STACK[0x280] = 0;
  if (SLODWORD(STACK[0x25C]) >= 1)
  {
    v20 = 0;
    v21 = STACK[0x298];
    do
      *(_DWORD *)(v21 + 4 * v20++) = 0;
    while (v20 < SLODWORD(STACK[0x25C]));
  }
  STACK[0x270] = 0;
  if (STACK[0x2A0] != a13)
    cv::fastFree((void **)STACK[0x2A0], a2);
  v22 = (unsigned int *)STACK[0x2D0];
  if (STACK[0x2D0])
  {
    do
    {
      v23 = __ldaxr(v22);
      v24 = v23 - 1;
    }
    while (__stlxr(v24, v22));
    if (!v24)
      cv::Mat::deallocate((cv::Mat *)&STACK[0x2B8], a2);
  }
  STACK[0x2C8] = 0;
  STACK[0x2D8] = 0;
  STACK[0x2E8] = 0;
  STACK[0x2E0] = 0;
  if (SLODWORD(STACK[0x2BC]) >= 1)
  {
    v25 = 0;
    v26 = STACK[0x2F8];
    do
      *(_DWORD *)(v26 + 4 * v25++) = 0;
    while (v25 < SLODWORD(STACK[0x2BC]));
  }
  STACK[0x2D0] = 0;
  if ((unint64_t *)STACK[0x300] != &STACK[0x308])
    cv::fastFree((void **)STACK[0x300], a2);
  v27 = (unsigned int *)STACK[0x330];
  if (STACK[0x330])
  {
    do
    {
      v28 = __ldaxr(v27);
      v29 = v28 - 1;
    }
    while (__stlxr(v29, v27));
    if (!v29)
      cv::Mat::deallocate((cv::Mat *)&STACK[0x318], a2);
  }
  STACK[0x328] = 0;
  STACK[0x338] = 0;
  STACK[0x348] = 0;
  STACK[0x340] = 0;
  if (SLODWORD(STACK[0x31C]) >= 1)
  {
    v30 = 0;
    v31 = STACK[0x358];
    do
      *(_DWORD *)(v31 + 4 * v30++) = 0;
    while (v30 < SLODWORD(STACK[0x31C]));
  }
  STACK[0x330] = 0;
  if ((unint64_t *)STACK[0x360] != &STACK[0x368])
    cv::fastFree((void **)STACK[0x360], a2);
  v32 = (unsigned int *)STACK[0x390];
  if (STACK[0x390])
  {
    do
    {
      v33 = __ldaxr(v32);
      v34 = v33 - 1;
    }
    while (__stlxr(v34, v32));
    if (!v34)
      cv::Mat::deallocate((cv::Mat *)&STACK[0x378], a2);
  }
  STACK[0x388] = 0;
  STACK[0x398] = 0;
  STACK[0x3A8] = 0;
  STACK[0x3A0] = 0;
  if (SLODWORD(STACK[0x37C]) >= 1)
  {
    v35 = 0;
    v36 = STACK[0x3B8];
    do
      *(_DWORD *)(v36 + 4 * v35++) = 0;
    while (v35 < SLODWORD(STACK[0x37C]));
  }
  STACK[0x390] = 0;
  if ((unint64_t *)STACK[0x3C0] != &STACK[0x3C8])
    cv::fastFree((void **)STACK[0x3C0], a2);
  v37 = (unsigned int *)STACK[0x3F0];
  if (STACK[0x3F0])
  {
    do
    {
      v38 = __ldaxr(v37);
      v39 = v38 - 1;
    }
    while (__stlxr(v39, v37));
    if (!v39)
      cv::Mat::deallocate((cv::Mat *)&STACK[0x3D8], a2);
  }
  STACK[0x3E8] = 0;
  STACK[0x3F8] = 0;
  STACK[0x408] = 0;
  STACK[0x400] = 0;
  if (SLODWORD(STACK[0x3DC]) >= 1)
  {
    v40 = 0;
    v41 = STACK[0x418];
    do
      *(_DWORD *)(v41 + 4 * v40++) = 0;
    while (v40 < SLODWORD(STACK[0x3DC]));
  }
  STACK[0x3F0] = 0;
  if ((unint64_t *)STACK[0x420] != &STACK[0x428])
    cv::fastFree((void **)STACK[0x420], a2);
  _Unwind_Resume(a1);
}

uint64_t cv::GEMMSingleMul_32f(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int *a9, unsigned int *a10, char a11)
{
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  float *v14;
  unint64_t v15;
  unint64_t v16;
  double v17;
  uint64_t v18;
  uint64_t v19;
  float32x2_t *v20;
  float32x2_t *v21;
  double v22;
  double v23;
  double v24;
  _DWORD *v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  float *v29;
  int v30;
  uint64_t v31;
  _BYTE *v32;
  unint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  float *v42;
  uint64_t v43;
  int v44;
  int64_t v45;
  BOOL v46;
  uint64_t v47;
  char v48;
  uint64_t v49;
  uint64_t v50;
  float *v51;
  uint64_t v52;
  _DWORD *v53;
  int64_t v54;
  float *v55;
  float32x2_t *v56;
  float64x2_t v57;
  double v58;
  float32x2_t *v59;
  float *v60;
  uint64_t v61;
  double v62;
  float v63;
  double v64;
  uint64_t v65;
  float v66;
  float v67;
  float v68;
  double v69;
  float v70;
  float v71;
  float *v72;
  double v73;
  float *v74;
  float *v75;
  uint64_t v76;
  float v77;
  double v78;
  float v79;
  float64x2_t *v80;
  float *v81;
  int v82;
  uint64_t v83;
  uint64_t v84;
  int64_t v85;
  uint64_t v86;
  uint64_t v87;
  BOOL v88;
  char v89;
  float64x2_t *v90;
  uint64_t v91;
  _BYTE *v92;
  uint64_t v93;
  _DWORD *v94;
  uint64_t v95;
  float32x2_t *v96;
  float32x2_t *v97;
  uint64_t v98;
  int64_t v99;
  float64x2_t v100;
  float64x2_t *v101;
  float32x2_t *v102;
  float32x2_t v103;
  uint64_t v104;
  float *v105;
  float v106;
  uint64_t i;
  float v108;
  float64x2_t *v109;
  unsigned int v110;
  int v111;
  BOOL v112;
  char v113;
  uint64_t v114;
  uint64_t v115;
  _BYTE *v116;
  uint64_t v117;
  _DWORD *v118;
  uint64_t v119;
  float32x2_t *v120;
  float *v121;
  int v122;
  float64x2_t v123;
  float64x2_t v124;
  uint64_t v125;
  uint64_t v126;
  float32x4_t v127;
  float32x4_t v128;
  uint64_t v129;
  double v130;
  double v131;
  float v132;
  unint64_t v133;
  float *v134;
  float32x2_t *v135;
  uint64_t v136;
  float *v137;
  uint64_t v138;
  double v139;
  int64_t v140;
  float *v141;
  uint64_t v142;
  double v143;
  double v144;
  float v145;
  float v146;
  float v147;
  double v148;
  float v149;
  uint64_t result;
  uint64_t v152;
  uint64_t v153;
  char v154;
  unint64_t v155;
  unint64_t v156;
  unint64_t v157;
  uint64_t v158;
  unint64_t v159;
  unint64_t v160;
  unint64_t v161;
  uint64_t v162;
  double v163;
  int v164;
  int v165;
  unint64_t v166;
  int v167;
  _DWORD *v168;
  uint64_t v169;
  float *v170;
  float64x2_t *v171;
  _BYTE v172[4176];
  _BYTE *v173;
  uint64_t v174;
  _BYTE v175[4152];

  v11 = MEMORY[0x24BDAC7A8](a1, a2);
  v19 = v18;
  v21 = v20;
  v23 = v22;
  v24 = v17;
  v25 = (_DWORD *)v11;
  v26 = *a10;
  v27 = (int)a10[1];
  v28 = (int)v26;
  v29 = (float *)a10[1];
  v30 = *a9;
  v31 = a9[1];
  v32 = v175;
  v173 = v175;
  v174 = 1032;
  v33 = v12 >> 2;
  v34 = v13 >> 2;
  v35 = v15 >> 2;
  v166 = v16 >> 2;
  if ((a11 & 4) != 0)
    v36 = 1;
  else
    v36 = v15 >> 2;
  if ((a11 & 4) == 0)
    v35 = 1;
  if (!v14)
    v36 = 0;
  v169 = v36;
  if (v14)
    v37 = v35;
  else
    v37 = 0;
  v163 = v17;
  if ((a11 & 1) != 0)
  {
    v39 = 1;
    if (v12 >= 8 && (int)v31 >= 2)
    {
      if (v31 < 0x409)
      {
        v39 = 1;
        if ((a11 & 2) == 0)
          goto LABEL_29;
      }
      else
      {
        v155 = v13 >> 2;
        v159 = v12 >> 2;
        v164 = (int)v29;
        v168 = (_DWORD *)v11;
        v29 = v14;
        v174 = v31;
        v32 = (_BYTE *)operator new[]();
        v173 = v32;
        v39 = 1;
        v14 = v29;
        v24 = v163;
        v25 = v168;
        v28 = (int)v26;
        LODWORD(v29) = v164;
        v34 = v155;
        v33 = v159;
        if ((a11 & 2) == 0)
          goto LABEL_29;
      }
LABEL_109:
      if ((int)v29 >= 1)
      {
        v111 = 0;
        if (v32)
          v112 = (int)v31 < 1;
        else
          v112 = 1;
        v113 = v112;
        v114 = 4 * v33;
        v115 = 4 * v34;
        do
        {
          if (v32)
            v116 = v32;
          else
            v116 = v25;
          if ((v113 & 1) == 0)
          {
            v117 = 0;
            v118 = v25;
            do
            {
              *(_DWORD *)&v32[v117] = *v118;
              v117 += 4;
              v118 = (_DWORD *)((char *)v118 + v114);
            }
            while (4 * v31 != v117);
            v116 = v32;
          }
          if ((int)v26 >= 1)
          {
            v119 = 0;
            v120 = v21;
            v121 = v14;
            do
            {
              if ((int)v31 >= 4)
              {
                v125 = 0;
                v126 = 0;
                v123 = 0uLL;
                v124 = 0uLL;
                do
                {
                  v127 = *(float32x4_t *)&v116[v125 * 8];
                  v128 = *(float32x4_t *)v120[v125].f32;
                  v124 = vmlaq_f64(v124, vcvt_hight_f64_f32(v128), vcvt_hight_f64_f32(v127));
                  v123 = vmlaq_f64(v123, vcvtq_f64_f32(*(float32x2_t *)v128.f32), vcvtq_f64_f32(*(float32x2_t *)v127.f32));
                  v126 += 4;
                  v125 += 2;
                }
                while (v126 <= (int)v31 - 4);
                v122 = ((v31 - 4) & 0xFFFFFFFC) + 4;
              }
              else
              {
                v122 = 0;
                v123 = 0uLL;
                v124 = 0uLL;
              }
              if (v122 >= (int)v31)
              {
                v130 = v123.f64[0];
              }
              else
              {
                v129 = v122;
                v130 = v123.f64[0];
                do
                {
                  v130 = v130 + *(float *)&v116[v129 * 4] * v120->f32[v129];
                  ++v122;
                  ++v129;
                }
                while ((int)v31 > v122);
              }
              v131 = (v124.f64[1] + v124.f64[0] + v123.f64[1] + v130) * v24;
              if (v121)
                v131 = v131 + *v121 * v23;
              v132 = v131;
              *(float *)(v19 + 4 * v119++) = v132;
              v121 += v37;
              v120 = (float32x2_t *)((char *)v120 + v115);
            }
            while (v119 != v26);
          }
          ++v111;
          v25 += v39;
          v14 += v169;
          v19 += 4 * v166;
        }
        while (v111 != (_DWORD)v27);
      }
      goto LABEL_171;
    }
    v30 = v31;
    v38 = v12 >> 2;
  }
  else
  {
    v38 = 1;
    v39 = v12 >> 2;
  }
  if (v30 == 1)
  {
    v171 = (float64x2_t *)v172;
    if (v12 < 8)
    {
      v40 = v16 >> 2;
    }
    else
    {
      v40 = v16 >> 2;
      if ((int)v31 >= 2)
      {
        if (v29 >= 0x409)
        {
          v156 = v13;
          v160 = v12 >> 2;
          v41 = v13 >> 2;
          v42 = v14;
          v174 = v27;
          v32 = (_BYTE *)operator new[]();
          v173 = v32;
          v14 = v42;
          v24 = v163;
          v28 = (int)v26;
          v40 = v166;
          v34 = v41;
          v13 = v156;
          v33 = v160;
        }
        if ((int)v29 >= 1)
        {
          v43 = 0;
          do
          {
            *(_DWORD *)&v32[v43] = *v25;
            v43 += 4;
            v25 += v33;
          }
          while (4 * (_QWORD)v29 != v43);
        }
        v25 = v32;
      }
    }
    if (v13 >= 8)
    {
      if (v28 <= 0x408)
      {
        v135 = (float32x2_t *)v172;
      }
      else
      {
        v133 = v34;
        v134 = v14;
        v135 = (float32x2_t *)operator new[]();
        v171 = (float64x2_t *)v135;
        v14 = v134;
        v24 = v163;
        v28 = (int)v26;
        v34 = v133;
      }
      if ((int)v28 >= 1)
      {
        v136 = 0;
        do
        {
          v135->i32[v136++] = v21->i32[0];
          v21 = (float32x2_t *)((char *)v21 + 4 * v34);
        }
        while (v26 != v136);
      }
      v21 = v135;
      v40 = v166;
    }
    if ((int)v29 >= 1)
    {
      v137 = 0;
      v138 = 4 * v40;
      do
      {
        v139 = *(float *)&v25[(_QWORD)v137] * v24;
        if ((int)v28 >= 2)
        {
          v142 = 0;
          v140 = 0;
          v141 = v14;
          do
          {
            v143 = v139 * v21[v142].f32[0];
            v144 = v139 * v21[v142].f32[1];
            if (v141)
            {
              v145 = v143 + *v141 * v23;
              *(float *)(v19 + v142 * 8) = v145;
              v144 = v144 + v141[v37] * v23;
            }
            else
            {
              v146 = v143;
              *(float *)(v19 + v142 * 8) = v146;
            }
            v147 = v144;
            *(float *)(v19 + v142 * 8 + 4) = v147;
            v140 += 2;
            v141 += 2 * v37;
            ++v142;
          }
          while (v140 <= (uint64_t)(v28 - 2));
          v140 = v140;
        }
        else
        {
          v140 = 0;
          v141 = v14;
        }
        if ((int)v140 < (int)v26)
        {
          do
          {
            v148 = v139 * v21->f32[v140];
            if (v141)
              v148 = v148 + *v141 * v23;
            v149 = v148;
            *(float *)(v19 + 4 * v140++) = v149;
            v141 += v37;
          }
          while (v26 != v140);
        }
        v137 = (float *)((char *)v137 + 1);
        v14 += v169;
        v19 += v138;
      }
      while (v137 != v29);
    }
    v109 = v171;
    if (v171 != (float64x2_t *)v172 && v171 != 0)
    {
      v110 = 1384677904;
      goto LABEL_170;
    }
    goto LABEL_171;
  }
  v32 = 0;
  v33 = v38;
  LODWORD(v31) = v30;
  if ((a11 & 2) != 0)
    goto LABEL_109;
LABEL_29:
  if (4 * v28 > 0x640)
  {
    v80 = (float64x2_t *)v172;
    v165 = (int)v29;
    if (v28 >= 0x209)
    {
      v157 = v34;
      v161 = v33;
      v81 = v14;
      v80 = (float64x2_t *)operator new[]();
      v14 = v81;
      v24 = v163;
      v28 = (int)v26;
      v34 = v157;
      v33 = v161;
    }
    if ((int)v29 >= 1)
    {
      v82 = 0;
      v83 = 4 * v31;
      v84 = 4 * v39;
      v85 = v28 - 4;
      v86 = 4 * v33;
      v87 = 4 * v34;
      if (v32)
        v88 = (int)v31 < 1;
      else
        v88 = 1;
      v158 = 4 * v166;
      v162 = v84;
      v89 = v88;
      v154 = v89;
      v152 = v86;
      v90 = v80 + 1;
      v153 = v169;
      v91 = 4 * v37;
      do
      {
        if (v32)
          v92 = v32;
        else
          v92 = v25;
        v170 = v14;
        if ((v154 & 1) == 0)
        {
          v93 = 0;
          v94 = v25;
          do
          {
            *(_DWORD *)&v32[v93] = *v94;
            v93 += 4;
            v94 = (_DWORD *)((char *)v94 + v86);
          }
          while (v83 != v93);
          v92 = v32;
        }
        if ((int)v28 >= 1)
        {
          v167 = v82;
          bzero(v80, 8 * v26);
          v91 = 4 * v37;
          v90 = v80 + 1;
          v86 = v152;
          v83 = 4 * v31;
          v82 = v167;
          LODWORD(v28) = v26;
          v24 = v163;
        }
        if ((int)v31 >= 1)
        {
          v95 = 0;
          v96 = v21;
          v97 = v21 + 1;
          do
          {
            *(double *)&v98 = *(float *)&v92[4 * v95];
            if ((int)v26 >= 4)
            {
              v99 = 0;
              v100 = (float64x2_t)vdupq_lane_s64(v98, 0);
              v101 = v90;
              v102 = v97;
              do
              {
                v101[-1] = vmlaq_f64(v101[-1], v100, vcvtq_f64_f32(v102[-1]));
                v103 = *v102;
                v102 += 2;
                *v101 = vmlaq_f64(*v101, v100, vcvtq_f64_f32(v103));
                v101 += 2;
                v99 += 4;
              }
              while (v99 <= v85);
              v99 = v99;
            }
            else
            {
              v99 = 0;
            }
            if ((int)v99 < (int)v28)
            {
              do
              {
                v80->f64[v99] = v80->f64[v99] + v96->f32[v99] * *(double *)&v98;
                ++v99;
              }
              while (v26 != v99);
            }
            ++v95;
            v97 = (float32x2_t *)((char *)v97 + v87);
            v96 = (float32x2_t *)((char *)v96 + v87);
          }
          while (v95 != v31);
        }
        if (v170)
        {
          if ((int)v28 >= 1)
          {
            v104 = 0;
            v105 = v170;
            do
            {
              v106 = v80->f64[v104] * v24 + *v105 * v23;
              *(float *)(v19 + 4 * v104++) = v106;
              v105 = (float *)((char *)v105 + v91);
            }
            while (v26 != v104);
          }
        }
        else if ((int)v26 >= 1)
        {
          for (i = 0; i != v26; ++i)
          {
            v108 = v80->f64[i] * v24;
            *(float *)(v19 + 4 * i) = v108;
          }
        }
        ++v82;
        v25 = (_DWORD *)((char *)v25 + v162);
        v14 = &v170[v153];
        v19 += v158;
      }
      while (v82 != v165);
    }
    if (v80 != (float64x2_t *)v172)
    {
      v109 = v80;
      v110 = 3227415;
LABEL_170:
      MEMORY[0x2207351A4](v109, v110 | 0x1000C8000000000);
    }
  }
  else if ((int)v27 >= 1)
  {
    v44 = 0;
    v45 = v28 - 4;
    if (v32)
      v46 = (int)v31 < 1;
    else
      v46 = 1;
    v47 = 4 * v39;
    v48 = v46;
    v49 = 4 * v33;
    v50 = 4 * v34;
    do
    {
      if (v32)
        v51 = (float *)v32;
      else
        v51 = (float *)v25;
      if ((v48 & 1) == 0)
      {
        v52 = 0;
        v53 = v25;
        do
        {
          *(_DWORD *)&v32[v52] = *v53;
          v52 += 4;
          v53 = (_DWORD *)((char *)v53 + v49);
        }
        while (4 * v31 != v52);
        v51 = (float *)v32;
      }
      if ((int)v28 >= 4)
      {
        v54 = 0;
        v56 = v21;
        v55 = v14;
        do
        {
          v57 = 0uLL;
          if ((int)v31 < 1)
          {
            v62 = 0.0;
            v58 = 0.0;
          }
          else
          {
            v58 = 0.0;
            v59 = v56;
            v60 = v51;
            v61 = v31;
            v62 = 0.0;
            do
            {
              v63 = *v60++;
              v62 = v62 + v63 * v59->f32[0];
              v57 = vmlaq_n_f64(v57, vcvtq_f64_f32(*(float32x2_t *)((char *)v59 + 4)), v63);
              v58 = v58 + v63 * v59[1].f32[1];
              v59 = (float32x2_t *)((char *)v59 + v50);
              --v61;
            }
            while (v61);
          }
          v64 = v62 * v24;
          v65 = 4 * v54;
          if (v55)
          {
            v66 = v64 + *v55 * v23;
            *(float *)(v19 + 4 * v54) = v66;
            v67 = v24 * v57.f64[0] + v55[v37] * v23;
            *(float *)(v19 + (v65 | 4)) = v67;
            v68 = vmuld_lane_f64(v24, v57, 1) + v55[2 * v37] * v23;
            *(float *)(v19 + (v65 | 8)) = v68;
            v69 = v58 * v24 + v55[3 * v37] * v23;
          }
          else
          {
            v70 = v64;
            *(float *)(v19 + 4 * v54) = v70;
            *(float32x2_t *)(v19 + (v65 | 4)) = vcvt_f32_f64(vmulq_n_f64(v57, v24));
            v69 = v58 * v24;
          }
          v71 = v69;
          *(float *)(v19 + (v65 | 0xC)) = v71;
          v54 += 4;
          v55 += 4 * v37;
          v56 += 2;
        }
        while (v54 <= v45);
        v54 = v54;
      }
      else
      {
        v54 = 0;
        v55 = v14;
      }
      if ((int)v54 < (int)v26)
      {
        v72 = (float *)v21 + v54;
        do
        {
          v73 = 0.0;
          if ((int)v31 >= 1)
          {
            v74 = v72;
            v75 = v51;
            v76 = v31;
            do
            {
              v77 = *v75++;
              v73 = v73 + v77 * *v74;
              v74 = (float *)((char *)v74 + v50);
              --v76;
            }
            while (v76);
          }
          v78 = v73 * v24;
          if (v55)
            v78 = v78 + *v55 * v23;
          v79 = v78;
          *(float *)(v19 + 4 * v54++) = v79;
          v55 += v37;
          ++v72;
        }
        while (v54 != v26);
      }
      ++v44;
      v25 = (_DWORD *)((char *)v25 + v47);
      LODWORD(v28) = v26;
      v14 += v169;
      v19 += 4 * v166;
    }
    while (v44 != (_DWORD)v29);
  }
LABEL_171:
  result = (uint64_t)v173;
  if (v173 != v175)
  {
    if (v173)
      return MEMORY[0x2207351A4]();
  }
  return result;
}

void sub_219E53A9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  unint64_t v11;

  v11 = STACK[0x10F8];
  if (STACK[0x10F8] != a10)
  {
    if (v11)
      MEMORY[0x2207351A4](v11, 0x1000C8052888210);
  }
  _Unwind_Resume(a1);
}

_BYTE *cv::GEMMBlockMul_32f(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  int *v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  float32x2_t *v19;
  _DWORD *v20;
  int v21;
  int *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  _BYTE *v26;
  _BYTE *result;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  int v31;
  uint64_t v32;
  BOOL v33;
  char v34;
  uint64_t v35;
  uint64_t v36;
  _DWORD *v37;
  uint64_t v38;
  float32x2_t *v39;
  float64x2_t v40;
  uint64_t v41;
  float64x2_t v42;
  float32x2_t *v43;
  float *v44;
  uint64_t v45;
  float v46;
  float *v47;
  double v48;
  float *v49;
  float *v50;
  uint64_t v51;
  float v52;
  int v53;
  uint64_t v54;
  BOOL v55;
  char v56;
  uint64_t v57;
  uint64_t v58;
  float32x2_t *v59;
  unint64_t v60;
  float64x2_t v61;
  signed int v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  double v66;
  _BYTE v67[4152];

  v9 = MEMORY[0x24BDAC7A8](a1, a2);
  v15 = v14;
  v17 = v16;
  v18 = v12;
  v19 = (float32x2_t *)v11;
  v20 = (_DWORD *)v9;
  v21 = v13[1];
  v23 = v22[1];
  v24 = *v22;
  v25 = v10 >> 2;
  if ((a9 & 1) != 0)
  {
    if (v21 < 0x409)
    {
      v28 = 1;
      result = v67;
      v26 = v67;
    }
    else
    {
      result = (_BYTE *)operator new[]();
      v28 = 1;
      v26 = result;
    }
  }
  else
  {
    v26 = 0;
    result = v67;
    v21 = *v13;
    v28 = v10 >> 2;
    v25 = 1;
  }
  v29 = v18 >> 2;
  v30 = v15 >> 3;
  if ((a9 & 2) != 0)
  {
    if (v23 >= 1)
    {
      v53 = 0;
      v54 = 4 * v28;
      if (v26)
        v55 = v21 < 1;
      else
        v55 = 1;
      v56 = v55;
      v57 = 4 * v29;
      do
      {
        if (v26)
          v11 = (unint64_t)v26;
        else
          v11 = (unint64_t)v20;
        if ((v56 & 1) == 0)
        {
          v58 = 0;
          v12 = (unint64_t)v20;
          do
          {
            *(_DWORD *)&v26[v58] = *(_DWORD *)v12;
            v58 += 4;
            v12 += 4 * v25;
          }
          while (4 * v21 != v58);
          v11 = (unint64_t)v26;
        }
        if ((int)v24 >= 1)
        {
          v12 = 0;
          v59 = v19;
          do
          {
            v60 = 0;
            if ((a9 & 0x10) != 0)
              v60 = *(_QWORD *)(v17 + 8 * v12);
            v61 = (float64x2_t)v60;
            if (v21 >= 2)
            {
              v63 = 0;
              v64 = 0;
              do
              {
                v61 = vmlaq_f64(v61, vcvtq_f64_f32(v59[v63]), vcvtq_f64_f32(*(float32x2_t *)(v11 + v63 * 8)));
                v64 += 2;
                ++v63;
              }
              while (v64 <= v21 - 2);
              v62 = ((v21 - 2) & 0xFFFFFFFE) + 2;
            }
            else
            {
              v62 = 0;
            }
            if (v62 >= v21)
            {
              v66 = v61.f64[0];
            }
            else
            {
              v65 = v62;
              v66 = v61.f64[0];
              do
              {
                v66 = v66 + *(float *)(v11 + v65 * 4) * v59->f32[v65];
                ++v62;
                ++v65;
              }
              while (v21 > v62);
            }
            *(double *)(v17 + 8 * v12++) = v61.f64[1] + v66;
            v59 = (float32x2_t *)((char *)v59 + v57);
          }
          while (v12 != v24);
        }
        ++v53;
        v20 = (_DWORD *)((char *)v20 + v54);
        v17 += 8 * v30;
      }
      while (v53 != v23);
    }
  }
  else if (v23 >= 1)
  {
    v31 = 0;
    v32 = 4 * v28;
    if (v26)
      v33 = v21 < 1;
    else
      v33 = 1;
    v34 = v33;
    v35 = 4 * v29;
    v11 = v21;
    do
    {
      if (v26)
        v12 = (unint64_t)v26;
      else
        v12 = (unint64_t)v20;
      if ((v34 & 1) == 0)
      {
        v36 = 0;
        v37 = v20;
        do
        {
          *(_DWORD *)&v26[v36] = *v37;
          v36 += 4;
          v37 += v25;
        }
        while (4 * v21 != v36);
        v12 = (unint64_t)v26;
      }
      if ((int)v24 >= 4)
      {
        v38 = 0;
        v39 = v19 + 1;
        do
        {
          v40 = 0uLL;
          v41 = 8 * v38;
          v42 = 0uLL;
          if ((a9 & 0x10) != 0)
          {
            v40 = *(float64x2_t *)(v17 + 8 * v38);
            v42 = *(float64x2_t *)(v17 + (v41 | 0x10));
          }
          if (v21 >= 1)
          {
            v43 = v39;
            v44 = (float *)v12;
            v45 = v21;
            do
            {
              v46 = *v44++;
              v40 = vmlaq_n_f64(v40, vcvtq_f64_f32(v43[-1]), v46);
              v42 = vmlaq_n_f64(v42, vcvtq_f64_f32(*v43), v46);
              v43 = (float32x2_t *)((char *)v43 + v35);
              --v45;
            }
            while (v45);
          }
          *(float64x2_t *)(v17 + 8 * v38) = v40;
          *(float64x2_t *)(v17 + (v41 | 0x10)) = v42;
          v38 += 4;
          v39 += 2;
        }
        while (v38 <= v24 - 4);
        v38 = v38;
      }
      else
      {
        v38 = 0;
      }
      if ((int)v38 < (int)v24)
      {
        v47 = (float *)v19 + v38;
        do
        {
          v48 = 0.0;
          if ((a9 & 0x10) != 0)
            v48 = *(double *)(v17 + 8 * v38);
          if (v21 >= 1)
          {
            v49 = v47;
            v50 = (float *)v12;
            v51 = v21;
            do
            {
              v52 = *v50++;
              v48 = v48 + v52 * *v49;
              v49 = (float *)((char *)v49 + v35);
              --v51;
            }
            while (v51);
          }
          *(double *)(v17 + 8 * v38++) = v48;
          ++v47;
        }
        while (v38 != v24);
      }
      ++v31;
      v20 = (_DWORD *)((char *)v20 + v32);
      v17 += 8 * v30;
    }
    while (v31 != v23);
  }
  if (result != v67)
    return (_BYTE *)MEMORY[0x2207351A4](result, 0x1000C8052888210, v11, v12);
  return result;
}

void sub_219E53EE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10 != a9)
  {
    if (a10)
      MEMORY[0x2207351A4]();
  }
  _Unwind_Resume(exception_object);
}

float *cv::GEMMStore_32f(float *result, unint64_t a2, float64x2_t *a3, unint64_t a4, float32x4_t *a5, unint64_t a6, unsigned int *a7, char a8, double a9, double a10)
{
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  float64x2_t v18;
  uint64_t v19;
  uint64_t v20;
  float32x2_t *v21;
  uint64_t v22;
  float64x2_t *v23;
  uint64_t v24;
  unint64_t v25;
  float *v26;
  float64x2_t *v27;
  float32x4_t *v28;
  float64x2_t v29;
  float64x2_t v30;
  float32_t v31;
  float64x2_t *v32;
  float32x2_t *v33;
  __int32 *v34;
  __int32 *v35;
  float32x2_t v36;
  __int32 *v37;
  __int32 *v38;
  __int32 *v39;
  float64x2_t v40;
  float32_t v41;

  v10 = a7[1];
  v11 = a2 >> 2;
  if ((a8 & 4) != 0)
    v12 = 1;
  else
    v12 = a2 >> 2;
  if ((a8 & 4) == 0)
    v11 = 1;
  if (result)
    v13 = v12;
  else
    v13 = 0;
  if (result)
    v14 = v11;
  else
    v14 = 0;
  if (v10)
  {
    v15 = *a7;
    v16 = v14;
    v17 = (v15 - 4);
    v18 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&a10, 0);
    v19 = 4 * v13;
    v20 = 4 * v14;
    v21 = (float32x2_t *)&a5->u32[2];
    v22 = 4 * (a6 >> 2);
    v23 = a3 + 1;
    v24 = 8 * (a4 >> 3);
    do
    {
      v25 = 0;
      if (result)
      {
        if ((int)v15 < 4)
        {
          v26 = result;
        }
        else
        {
          v32 = v23;
          v33 = v21;
          v34 = (__int32 *)result;
          do
          {
            v35 = v34;
            v36.i32[0] = *v34;
            v37 = &v34[v16];
            v36.i32[1] = *v37;
            v38 = &v37[v16];
            v33[-1] = vcvt_f32_f64(vmlaq_f64(vmulq_n_f64(v32[-1], a9), vcvtq_f64_f32(v36), v18));
            v36.i32[0] = *v38;
            v39 = &v38[v16];
            v40 = *v32;
            v32 += 2;
            v36.i32[1] = *v39;
            v34 = &v39[v16];
            *v33 = vcvt_f32_f64(vmlaq_f64(vmulq_n_f64(v40, a9), vcvtq_f64_f32(v36), v18));
            v33 += 2;
            v25 += 4;
          }
          while (v25 <= v17);
          v26 = (float *)&v35[v20];
          v25 = v25;
        }
        if ((int)v25 < (int)v15)
        {
          do
          {
            v41 = a3->f64[v25] * a9 + *v26 * a10;
            a5->f32[v25++] = v41;
            v26 = (float *)((char *)v26 + v16 * 4);
          }
          while (v15 != v25);
        }
      }
      else
      {
        if ((int)v15 >= 4)
        {
          v27 = a3;
          v28 = a5;
          do
          {
            v29 = *v27;
            v30 = v27[1];
            v27 += 2;
            *v28++ = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmulq_n_f64(v29, a9)), vmulq_n_f64(v30, a9));
            v25 += 4;
          }
          while (v25 <= v17);
          v25 = v25;
        }
        if ((int)v25 < (int)v15)
        {
          do
          {
            v31 = a3->f64[v25] * a9;
            a5->f32[v25++] = v31;
          }
          while (v15 != v25);
        }
      }
      result = (float *)((char *)result + v19);
      v21 = (float32x2_t *)((char *)v21 + v22);
      v23 = (float64x2_t *)((char *)v23 + v24);
      a5 = (float32x4_t *)((char *)a5 + v22);
      a3 = (float64x2_t *)((char *)a3 + v24);
      --v10;
    }
    while (v10);
  }
  return result;
}

uint64_t cv::GEMMSingleMul_64f(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int *a9, unsigned int *a10, char a11)
{
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  double *v18;
  double *v19;
  unint64_t v20;
  _QWORD *v21;
  double v22;
  double v23;
  double v24;
  double v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  int v29;
  uint64_t v30;
  _BYTE *v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  double *v39;
  int v40;
  BOOL v41;
  char v42;
  uint64_t v43;
  uint64_t v44;
  double *v45;
  uint64_t v46;
  double *v47;
  uint64_t v48;
  _QWORD *v49;
  double *v50;
  int v51;
  float64x2_t v52;
  float64x2_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  double v57;
  double v58;
  _QWORD *v59;
  unint64_t v60;
  unint64_t v61;
  uint64_t v62;
  uint64_t v63;
  _QWORD *v64;
  int v65;
  int64_t v66;
  uint64_t v67;
  uint64_t v68;
  BOOL v69;
  char v70;
  uint64_t v71;
  double *v72;
  uint64_t v73;
  double *v74;
  int64_t v75;
  double *v76;
  double *v77;
  double v78;
  double *v79;
  double *v80;
  uint64_t v81;
  double v82;
  double v83;
  double v84;
  double v85;
  double v86;
  uint64_t v87;
  double v88;
  double v89;
  double *v90;
  double v91;
  double *v92;
  double *v93;
  uint64_t v94;
  double v95;
  double v96;
  _BYTE *v97;
  unint64_t v98;
  _QWORD *v99;
  int v100;
  uint64_t v101;
  uint64_t v102;
  int64_t v103;
  uint64_t v104;
  BOOL v105;
  char v106;
  uint64_t v107;
  _BYTE *v108;
  uint64_t v109;
  uint64_t v110;
  _QWORD *v111;
  uint64_t v112;
  int64_t v113;
  uint64_t v114;
  float64x2_t v115;
  float64x2_t *v116;
  float64x2_t v117;
  uint64_t v118;
  double *v119;
  uint64_t v120;
  double *v121;
  _QWORD *v122;
  unint64_t v123;
  _BYTE *v124;
  uint64_t v125;
  uint64_t i;
  double v127;
  int64_t v128;
  double *v129;
  uint64_t v130;
  double v131;
  double v132;
  double v133;
  uint64_t result;
  uint64_t v136;
  uint64_t v137;
  char v138;
  unint64_t v139;
  uint64_t v140;
  unint64_t v141;
  unint64_t v142;
  uint64_t v143;
  _QWORD *v144;
  uint64_t v145;
  _QWORD *v146;
  _QWORD *v147;
  uint64_t v148;
  int v149;
  unint64_t v150;
  double *v151;
  _BYTE *v152;
  _BYTE v153[4176];
  _BYTE *v154;
  uint64_t v155;
  _BYTE v156[4184];

  v11 = MEMORY[0x24BDAC7A8](a1, a2);
  v17 = v16;
  v19 = v18;
  v20 = v13;
  v144 = v21;
  v23 = v22;
  v25 = v24;
  v146 = (_QWORD *)v11;
  v26 = *a10;
  v27 = (int)a10[1];
  v28 = (int)v26;
  v145 = a10[1];
  v29 = *a9;
  v30 = a9[1];
  v31 = v156;
  v154 = v156;
  v155 = 520;
  v32 = v12 >> 3;
  v33 = v13 >> 3;
  v34 = v14 >> 3;
  if ((a11 & 4) != 0)
    v35 = 1;
  else
    v35 = v14 >> 3;
  if ((a11 & 4) == 0)
    v34 = 1;
  if (!v19)
    v35 = 0;
  v148 = v35;
  v150 = v15 >> 3;
  if (v19)
    v36 = v34;
  else
    v36 = 0;
  if ((a11 & 1) == 0)
  {
    v37 = 1;
    v38 = v12 >> 3;
LABEL_50:
    if (v29 == 1)
    {
      v152 = v153;
      if (v12 < 0x10)
      {
        v59 = v144;
      }
      else
      {
        v59 = v144;
        if ((int)v30 >= 2)
        {
          if (v145 >= 0x209)
          {
            v60 = v12 >> 3;
            v61 = v13 >> 3;
            v155 = v27;
            v31 = (_BYTE *)operator new[]();
            v154 = v31;
            v28 = (int)v26;
            v33 = v61;
            v32 = v60;
          }
          v62 = v145;
          if ((int)v145 >= 1)
          {
            v63 = 0;
            v64 = v146;
            do
            {
              *(_QWORD *)&v31[v63] = *v64;
              v63 += 8;
              v64 += v32;
            }
            while (8 * v145 != v63);
          }
          v146 = v31;
          goto LABEL_144;
        }
      }
      v62 = v145;
LABEL_144:
      if (v20 < 0x10)
      {
        v122 = v146;
      }
      else
      {
        v121 = v19;
        v122 = v146;
        if (v28 <= 0x208)
        {
          v124 = v153;
        }
        else
        {
          v123 = v33;
          v124 = (_BYTE *)operator new[]();
          v152 = v124;
          v28 = (int)v26;
          v122 = v146;
          v62 = v145;
          v33 = v123;
        }
        if ((int)v28 >= 1)
        {
          v125 = 0;
          do
          {
            *(_QWORD *)&v124[v125] = *v59;
            v125 += 8;
            v59 += v33;
          }
          while (8 * v26 != v125);
        }
        v59 = v124;
        v19 = v121;
      }
      if ((int)v62 >= 1)
      {
        for (i = 0; i != v62; ++i)
        {
          v127 = *(double *)&v122[i] * v25;
          if ((int)v28 >= 2)
          {
            v130 = 0;
            v128 = 0;
            v129 = v19;
            do
            {
              v131 = v127 * *(double *)&v59[v130];
              v132 = v127 * *(double *)&v59[v130 + 1];
              if (v129)
              {
                *(double *)(v17 + v130 * 8) = v131 + *v129 * v23;
                v132 = v132 + v129[v36] * v23;
              }
              else
              {
                *(double *)(v17 + v130 * 8) = v131;
              }
              *(double *)(v17 + v130 * 8 + 8) = v132;
              v128 += 2;
              v129 += 2 * v36;
              v130 += 2;
            }
            while (v128 <= (uint64_t)(v28 - 2));
            v128 = v128;
          }
          else
          {
            v128 = 0;
            v129 = v19;
          }
          if ((int)v128 < (int)v26)
          {
            do
            {
              v133 = v127 * *(double *)&v59[v128];
              if (v129)
                v133 = v133 + *v129 * v23;
              *(double *)(v17 + 8 * v128++) = v133;
              v129 += v36;
            }
            while (v26 != v128);
          }
          v19 += v148;
          v17 += 8 * v150;
        }
      }
      if (v152 != v153 && v152 != 0)
        MEMORY[0x2207351A4]();
      goto LABEL_173;
    }
    v31 = 0;
    v32 = v37;
    LODWORD(v30) = v29;
    goto LABEL_61;
  }
  v38 = 1;
  if (v12 < 0x10 || (int)v30 < 2)
  {
    v29 = v30;
    v37 = v12 >> 3;
    goto LABEL_50;
  }
  if (v30 >= 0x209)
  {
    v139 = v13 >> 3;
    v141 = v12 >> 3;
    v155 = v30;
    v39 = (double *)v11;
    v31 = (_BYTE *)operator new[]();
    v154 = v31;
    v38 = 1;
    v28 = (int)v26;
    v33 = v139;
    v32 = v141;
    if ((a11 & 2) == 0)
      goto LABEL_62;
    goto LABEL_17;
  }
  v38 = 1;
LABEL_61:
  v39 = (double *)v11;
  if ((a11 & 2) == 0)
  {
LABEL_62:
    if (8 * v28 > 0x640)
    {
      v97 = v153;
      if (v28 >= 0x209)
      {
        v142 = v32;
        v98 = v33;
        v97 = (_BYTE *)operator new[]();
        v28 = (int)v26;
        v33 = v98;
        v32 = v142;
      }
      v99 = v146;
      if ((int)v145 >= 1)
      {
        v100 = 0;
        v101 = 8 * v26;
        v102 = 8 * v38;
        v103 = v28 - 4;
        v136 = 8 * v32;
        v104 = 8 * v33;
        if (v31)
          v105 = (int)v30 < 1;
        else
          v105 = 1;
        v140 = 8 * v150;
        v143 = v102;
        v106 = v105;
        v138 = v106;
        v107 = 8 * v36;
        v137 = v148;
        do
        {
          v151 = v19;
          if (v31)
            v108 = v31;
          else
            v108 = v99;
          v147 = v99;
          if ((v138 & 1) == 0)
          {
            v109 = 0;
            do
            {
              *(_QWORD *)&v31[v109] = *v99;
              v109 += 8;
              v99 = (_QWORD *)((char *)v99 + v136);
            }
            while (8 * v30 != v109);
            v108 = v31;
          }
          if ((int)v28 >= 1)
          {
            v149 = v100;
            bzero(v97, 8 * v26);
            v107 = 8 * v36;
            v100 = v149;
            LODWORD(v28) = v26;
          }
          if ((int)v30 >= 1)
          {
            v110 = 0;
            v111 = v144;
            do
            {
              v112 = *(uint64_t *)&v108[8 * v110];
              if ((int)v26 >= 4)
              {
                v114 = 0;
                v113 = 0;
                v115 = (float64x2_t)vdupq_lane_s64(v112, 0);
                do
                {
                  v116 = (float64x2_t *)&v97[v114 * 8];
                  v117 = vmlaq_f64(*(float64x2_t *)&v97[v114 * 8 + 16], v115, *(float64x2_t *)&v111[v114 + 2]);
                  *v116 = vmlaq_f64(*(float64x2_t *)&v97[v114 * 8], v115, *(float64x2_t *)&v111[v114]);
                  v116[1] = v117;
                  v113 += 4;
                  v114 += 4;
                }
                while (v113 <= v103);
                v113 = v113;
              }
              else
              {
                v113 = 0;
              }
              if ((int)v113 < (int)v28)
              {
                do
                {
                  *(double *)&v97[8 * v113] = *(double *)&v97[8 * v113] + *(double *)&v111[v113] * *(double *)&v112;
                  ++v113;
                }
                while (v26 != v113);
              }
              ++v110;
              v111 = (_QWORD *)((char *)v111 + v104);
            }
            while (v110 != v30);
          }
          if (v151)
          {
            if ((int)v28 >= 1)
            {
              v118 = 0;
              v119 = v151;
              do
              {
                *(double *)(v17 + v118) = *(double *)&v97[v118] * v25 + *v119 * v23;
                v118 += 8;
                v119 = (double *)((char *)v119 + v107);
              }
              while (v101 != v118);
            }
          }
          else if ((int)v26 >= 1)
          {
            v120 = 0;
            do
            {
              *(double *)(v17 + v120) = *(double *)&v97[v120] * v25;
              v120 += 8;
            }
            while (v101 != v120);
          }
          ++v100;
          v99 = (_QWORD *)((char *)v147 + v143);
          v19 = &v151[v137];
          v17 += v140;
        }
        while (v100 != (_DWORD)v145);
      }
      if (v97 != v153)
        MEMORY[0x2207351A4](v97, 0x1000C8000313F17, v33);
    }
    else if ((int)v27 >= 1)
    {
      v65 = 0;
      v66 = v28 - 4;
      v67 = 8 * v38;
      v68 = 8 * v32;
      if (v31)
        v69 = (int)v30 < 1;
      else
        v69 = 1;
      v70 = v69;
      v71 = 8 * v33;
      do
      {
        if (v31)
          v72 = (double *)v31;
        else
          v72 = v39;
        if ((v70 & 1) == 0)
        {
          v73 = 0;
          v74 = v39;
          do
          {
            *(double *)&v31[v73] = *v74;
            v73 += 8;
            v74 = (double *)((char *)v74 + v68);
          }
          while (8 * v30 != v73);
          v72 = (double *)v31;
        }
        if ((int)v28 >= 4)
        {
          v75 = 0;
          v77 = (double *)(v144 + 2);
          v76 = v19;
          do
          {
            if ((int)v30 < 1)
            {
              v84 = 0.0;
              v83 = 0.0;
              v82 = 0.0;
              v78 = 0.0;
            }
            else
            {
              v78 = 0.0;
              v79 = v77;
              v80 = v72;
              v81 = v30;
              v82 = 0.0;
              v83 = 0.0;
              v84 = 0.0;
              do
              {
                v85 = *v80++;
                v84 = v84 + v85 * *(v79 - 2);
                v83 = v83 + v85 * *(v79 - 1);
                v82 = v82 + v85 * *v79;
                v78 = v78 + v85 * v79[1];
                v79 = (double *)((char *)v79 + v71);
                --v81;
              }
              while (v81);
            }
            v86 = v84 * v25;
            v87 = 8 * v75;
            v88 = v83 * v25;
            if (v76)
            {
              *(double *)(v17 + 8 * v75) = v86 + *v76 * v23;
              *(double *)(v17 + (v87 | 8)) = v88 + v76[v36] * v23;
              *(double *)(v17 + (v87 | 0x10)) = v82 * v25 + v76[2 * v36] * v23;
              v89 = v78 * v25 + v76[3 * v36] * v23;
            }
            else
            {
              *(double *)(v17 + 8 * v75) = v86;
              *(double *)(v17 + (v87 | 8)) = v88;
              *(double *)(v17 + (v87 | 0x10)) = v82 * v25;
              v89 = v78 * v25;
            }
            *(double *)(v17 + (v87 | 0x18)) = v89;
            v75 += 4;
            v76 += 4 * v36;
            v77 += 4;
          }
          while (v75 <= v66);
          v75 = v75;
        }
        else
        {
          v75 = 0;
          v76 = v19;
        }
        if ((int)v75 < (int)v26)
        {
          v90 = (double *)&v144[v75];
          do
          {
            v91 = 0.0;
            if ((int)v30 >= 1)
            {
              v92 = v90;
              v93 = v72;
              v94 = v30;
              do
              {
                v95 = *v93++;
                v91 = v91 + v95 * *v92;
                v92 = (double *)((char *)v92 + v71);
                --v94;
              }
              while (v94);
            }
            v96 = v91 * v25;
            if (v76)
              v96 = v96 + *v76 * v23;
            *(double *)(v17 + 8 * v75++) = v96;
            v76 += v36;
            ++v90;
          }
          while (v75 != v26);
        }
        ++v65;
        v39 = (double *)((char *)v39 + v67);
        v19 += v148;
        v17 += 8 * v150;
        LODWORD(v28) = v26;
      }
      while (v65 != (_DWORD)v145);
    }
    goto LABEL_173;
  }
LABEL_17:
  if ((int)v145 >= 1)
  {
    v40 = 0;
    if (v31)
      v41 = (int)v30 < 1;
    else
      v41 = 1;
    v42 = v41;
    v43 = 8 * v32;
    v44 = 8 * v33;
    do
    {
      if (v31)
        v45 = (double *)v31;
      else
        v45 = v39;
      if ((v42 & 1) == 0)
      {
        v46 = 0;
        v47 = v39;
        do
        {
          *(double *)&v31[v46] = *v47;
          v46 += 8;
          v47 = (double *)((char *)v47 + v43);
        }
        while (8 * v30 != v46);
        v45 = (double *)v31;
      }
      if ((int)v26 >= 1)
      {
        v48 = 0;
        v49 = v144;
        v50 = v19;
        do
        {
          if ((int)v30 >= 4)
          {
            v54 = 0;
            v55 = 0;
            v52 = 0uLL;
            v53 = 0uLL;
            do
            {
              v53 = vmlaq_f64(v53, *(float64x2_t *)&v49[v54 + 2], *(float64x2_t *)&v45[v54 + 2]);
              v52 = vmlaq_f64(v52, *(float64x2_t *)&v49[v54], *(float64x2_t *)&v45[v54]);
              v55 += 4;
              v54 += 4;
            }
            while (v55 <= (int)v30 - 4);
            v51 = ((v30 - 4) & 0xFFFFFFFC) + 4;
          }
          else
          {
            v51 = 0;
            v52 = 0uLL;
            v53 = 0uLL;
          }
          if (v51 >= (int)v30)
          {
            v57 = v52.f64[0];
          }
          else
          {
            v56 = v51;
            v57 = v52.f64[0];
            do
            {
              v57 = v57 + v45[v56] * *(double *)&v49[v56];
              ++v51;
              ++v56;
            }
            while ((int)v30 > v51);
          }
          v58 = (v53.f64[1] + v53.f64[0] + v52.f64[1] + v57) * v25;
          if (v50)
            v58 = v58 + *v50 * v23;
          *(double *)(v17 + 8 * v48++) = v58;
          v50 += v36;
          v49 = (_QWORD *)((char *)v49 + v44);
        }
        while (v48 != v26);
      }
      ++v40;
      v39 += v38;
      v19 += v148;
      v17 += 8 * v150;
    }
    while (v40 != (_DWORD)v27);
  }
LABEL_173:
  result = (uint64_t)v154;
  if (v154 != v156)
  {
    if (v154)
      return MEMORY[0x2207351A4]();
  }
  return result;
}

void sub_219E54AFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  unint64_t v11;

  v11 = STACK[0x10D8];
  if (STACK[0x10D8] != a10)
  {
    if (v11)
      MEMORY[0x2207351A4](v11, 0x1000C8000313F17);
  }
  _Unwind_Resume(a1);
}

_BYTE *cv::GEMMBlockMul_64f(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  int *v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  float64x2_t *v19;
  _QWORD *v20;
  int v21;
  int *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  _BYTE *v26;
  _BYTE *result;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  int v31;
  uint64_t v32;
  BOOL v33;
  char v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD *v37;
  uint64_t v38;
  float64x2_t *v39;
  float64x2_t v40;
  uint64_t v41;
  float64x2_t v42;
  float64x2_t *v43;
  const double *v44;
  uint64_t v45;
  float64x2_t v46;
  double *v47;
  double v48;
  double *v49;
  double *v50;
  uint64_t v51;
  double v52;
  int v53;
  uint64_t v54;
  BOOL v55;
  char v56;
  uint64_t v57;
  uint64_t v58;
  float64x2_t *v59;
  double v60;
  double v61;
  signed int v62;
  unint64_t v63;
  double *v64;
  double *f64;
  uint64_t v66;
  _BYTE v67[4184];

  v9 = MEMORY[0x24BDAC7A8](a1, a2);
  v15 = v14;
  v17 = v16;
  v18 = v12;
  v19 = (float64x2_t *)v11;
  v20 = (_QWORD *)v9;
  v21 = v13[1];
  v23 = v22[1];
  v24 = *v22;
  v25 = v10 >> 3;
  if ((a9 & 1) != 0)
  {
    if (v21 < 0x209)
    {
      v28 = 1;
      result = v67;
      v26 = v67;
    }
    else
    {
      result = (_BYTE *)operator new[]();
      v28 = 1;
      v26 = result;
    }
  }
  else
  {
    v26 = 0;
    result = v67;
    v21 = *v13;
    v28 = v10 >> 3;
    v25 = 1;
  }
  v29 = v18 >> 3;
  v30 = v15 >> 3;
  if ((a9 & 2) != 0)
  {
    if (v23 >= 1)
    {
      v53 = 0;
      v54 = 8 * v28;
      if (v26)
        v55 = v21 < 1;
      else
        v55 = 1;
      v56 = v55;
      v57 = 8 * v29;
      do
      {
        if (v26)
          v11 = (unint64_t)v26;
        else
          v11 = (unint64_t)v20;
        if ((v56 & 1) == 0)
        {
          v58 = 0;
          v12 = (unint64_t)v20;
          do
          {
            *(_QWORD *)&v26[v58] = *(_QWORD *)v12;
            v58 += 8;
            v12 += 8 * v25;
          }
          while (8 * v21 != v58);
          v11 = (unint64_t)v26;
        }
        if ((int)v24 >= 1)
        {
          v12 = 0;
          v59 = v19;
          do
          {
            v60 = 0.0;
            v61 = 0.0;
            if ((a9 & 0x10) != 0)
              v61 = *(double *)(v17 + 8 * v12);
            if (v21 >= 2)
            {
              v63 = 0;
              do
              {
                v64 = (double *)(v11 + 8 * v63);
                f64 = v59[v63 / 2].f64;
                v61 = v61 + *v64 * *f64;
                v60 = v60 + v64[1] * f64[1];
                v63 += 2;
              }
              while ((uint64_t)v63 <= v21 - 2);
              v62 = ((v21 - 2) & 0xFFFFFFFE) + 2;
            }
            else
            {
              v62 = 0;
            }
            if (v62 < v21)
            {
              v66 = v62;
              do
              {
                v61 = v61 + *(double *)(v11 + v66 * 8) * v59->f64[v66];
                ++v62;
                ++v66;
              }
              while (v21 > v62);
            }
            *(double *)(v17 + 8 * v12++) = v60 + v61;
            v59 = (float64x2_t *)((char *)v59 + v57);
          }
          while (v12 != v24);
        }
        ++v53;
        v20 = (_QWORD *)((char *)v20 + v54);
        v17 += 8 * v30;
      }
      while (v53 != v23);
    }
  }
  else if (v23 >= 1)
  {
    v31 = 0;
    v32 = 8 * v28;
    if (v26)
      v33 = v21 < 1;
    else
      v33 = 1;
    v34 = v33;
    v35 = 8 * v29;
    v11 = v21;
    do
    {
      if (v26)
        v12 = (unint64_t)v26;
      else
        v12 = (unint64_t)v20;
      if ((v34 & 1) == 0)
      {
        v36 = 0;
        v37 = v20;
        do
        {
          *(_QWORD *)&v26[v36] = *v37;
          v36 += 8;
          v37 += v25;
        }
        while (8 * v21 != v36);
        v12 = (unint64_t)v26;
      }
      if ((int)v24 >= 4)
      {
        v38 = 0;
        v39 = v19 + 1;
        do
        {
          v40 = 0uLL;
          v41 = 8 * v38;
          v42 = 0uLL;
          if ((a9 & 0x10) != 0)
          {
            v40 = *(float64x2_t *)(v17 + 8 * v38);
            v42 = *(float64x2_t *)(v17 + (v41 | 0x10));
          }
          if (v21 >= 1)
          {
            v43 = v39;
            v44 = (const double *)v12;
            v45 = v21;
            do
            {
              v46 = vld1q_dup_f64(v44++);
              v40 = vmlaq_f64(v40, v43[-1], v46);
              v42 = vmlaq_f64(v42, *v43, v46);
              v43 = (float64x2_t *)((char *)v43 + v35);
              --v45;
            }
            while (v45);
          }
          *(float64x2_t *)(v17 + 8 * v38) = v40;
          *(float64x2_t *)(v17 + (v41 | 0x10)) = v42;
          v38 += 4;
          v39 += 2;
        }
        while (v38 <= v24 - 4);
        v38 = v38;
      }
      else
      {
        v38 = 0;
      }
      if ((int)v38 < (int)v24)
      {
        v47 = &v19->f64[v38];
        do
        {
          v48 = 0.0;
          if ((a9 & 0x10) != 0)
            v48 = *(double *)(v17 + 8 * v38);
          if (v21 >= 1)
          {
            v49 = v47;
            v50 = (double *)v12;
            v51 = v21;
            do
            {
              v52 = *v50++;
              v48 = v48 + v52 * *v49;
              v49 = (double *)((char *)v49 + v35);
              --v51;
            }
            while (v51);
          }
          *(double *)(v17 + 8 * v38++) = v48;
          ++v47;
        }
        while (v38 != v24);
      }
      ++v31;
      v20 = (_QWORD *)((char *)v20 + v32);
      v17 += 8 * v30;
    }
    while (v31 != v23);
  }
  if (result != v67)
    return (_BYTE *)MEMORY[0x2207351A4](result, 0x1000C8000313F17, v11, v12);
  return result;
}

void sub_219E54F08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10 != a9)
  {
    if (a10)
      MEMORY[0x2207351A4]();
  }
  _Unwind_Resume(exception_object);
}

double *cv::GEMMStore_64f(double *result, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6, unsigned int *a7, char a8, double a9, double a10)
{
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  double *v21;
  uint64_t v22;
  unint64_t v23;
  double *v24;
  double *v25;
  double v26;
  double *v27;
  double *v28;
  double v29;
  double *v30;
  double v31;
  uint64_t v32;
  unint64_t i;
  float64x2_t *v34;

  v10 = a7[1];
  v11 = a2 >> 3;
  if ((a8 & 4) != 0)
    v12 = 1;
  else
    v12 = a2 >> 3;
  if ((a8 & 4) == 0)
    v11 = 1;
  if (result)
    v13 = v12;
  else
    v13 = 0;
  if (result)
    v14 = v11;
  else
    v14 = 0;
  if (v10)
  {
    v15 = *a7;
    v16 = (v15 - 4);
    v17 = 8 * v13;
    v18 = 4 * v14;
    v19 = 8 * (a4 >> 3);
    v20 = v14;
    do
    {
      if (result)
      {
        if ((int)v15 < 4)
        {
          v23 = 0;
          v21 = result;
        }
        else
        {
          v22 = 0;
          v23 = 0;
          v24 = result;
          do
          {
            v25 = v24;
            v26 = *(double *)(a3 + v22 + 8) * a9 + a10 * v24[v20];
            v27 = (double *)(a5 + v22);
            *v27 = *(double *)(a3 + v22) * a9 + a10 * *v24;
            v27[1] = v26;
            v28 = &v24[v20 + v20];
            v29 = *(double *)(a3 + v22 + 16) * a9 + a10 * *v28;
            v30 = &v28[v20];
            v31 = *(double *)(a3 + v22 + 24) * a9 + a10 * *v30;
            v27[2] = v29;
            v27[3] = v31;
            v23 += 4;
            v22 += 32;
            v24 = &v30[v20];
          }
          while (v23 <= v16);
          v21 = &v25[v18];
          v23 = v23;
        }
        if ((int)v23 < (int)v15)
        {
          do
          {
            *(double *)(a5 + 8 * v23) = *(double *)(a3 + 8 * v23) * a9 + *v21 * a10;
            ++v23;
            v21 = (double *)((char *)v21 + v20 * 8);
          }
          while (v15 != v23);
        }
      }
      else
      {
        if ((int)v15 < 4)
        {
          i = 0;
        }
        else
        {
          v32 = 0;
          for (i = 0; i <= v16; i += 4)
          {
            v34 = (float64x2_t *)(a5 + v32);
            *v34 = vmulq_n_f64(*(float64x2_t *)(a3 + v32), a9);
            v34[1] = vmulq_n_f64(*(float64x2_t *)(a3 + v32 + 16), a9);
            v32 += 32;
          }
          i = i;
        }
        if ((int)i < (int)v15)
        {
          do
          {
            *(double *)(a5 + 8 * i) = *(double *)(a3 + 8 * i) * a9;
            ++i;
          }
          while (v15 != i);
        }
      }
      result = (double *)((char *)result + v17);
      a5 += 8 * (a6 >> 3);
      a3 += v19;
      --v10;
    }
    while (v10);
  }
  return result;
}

uint64_t cv::GEMMSingleMul_32fc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int *a9, unsigned int *a10, char a11)
{
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  float32x2_t *v16;
  float32x2_t *v17;
  unint64_t v18;
  unint64_t v19;
  float32x2_t *v20;
  float32x2_t *v21;
  double v22;
  double v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _BYTE *v28;
  unint64_t v29;
  float32x2_t *v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  double v38;
  _QWORD *v39;
  int v40;
  uint64_t v41;
  double v42;
  unint64_t v43;
  double v44;
  uint64_t v45;
  unint64_t v46;
  float32x2_t *v47;
  double v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  BOOL v53;
  uint64_t v54;
  char v55;
  _BYTE *v56;
  uint64_t v57;
  _QWORD *v58;
  uint64_t v59;
  float32x2_t *v60;
  float32x2_t *v61;
  float64x2_t v62;
  float *v63;
  float32x2_t *v64;
  uint64_t v65;
  float64x2_t v66;
  float64x2_t v67;
  float64x2_t v68;
  double v69;
  float64x2_t v70;
  float64x2_t v71;
  float64x2_t v72;
  float64x2_t v73;
  float64x2_t v74;
  float64x2_t v75;
  float64x2_t v76;
  float64x2_t v77;
  float64x2_t v78;
  uint64_t v79;
  float64x2_t v80;
  float64x2_t v81;
  float *v82;
  float32x2_t *v83;
  float64x2_t v84;
  float32x2_t *v85;
  float *v86;
  uint64_t v87;
  float64x2_t v88;
  float64x2_t v89;
  float64x2_t v90;
  int v91;
  uint64_t v92;
  BOOL v93;
  char v94;
  uint64_t v95;
  uint64_t v96;
  _BYTE *v97;
  uint64_t v98;
  _QWORD *v99;
  uint64_t v100;
  _BYTE *v101;
  float32x2_t *v102;
  float32x2_t *v103;
  int v104;
  float64x2_t v105;
  float64x2_t v106;
  float64x2_t v107;
  float64x2_t v108;
  unint64_t v109;
  uint64_t v110;
  float64x2_t v111;
  float64x2_t v112;
  float64x2_t v113;
  float64x2_t v114;
  int8x16_t v115;
  float64x2_t v116;
  float64x2_t v117;
  float64x2_t v118;
  float64x2_t v119;
  float64x2_t v120;
  uint64_t v121;
  float64x2_t v122;
  float64x2_t v123;
  float64x2_t v124;
  float64x2_t *v125;
  int v126;
  int v127;
  double v128;
  double v129;
  float32x2_t *v130;
  _QWORD *v131;
  int v132;
  uint64_t v133;
  uint64_t v134;
  BOOL v135;
  char v136;
  float64x2_t *v137;
  uint64_t v138;
  _BYTE *v139;
  uint64_t v140;
  uint64_t v141;
  float32x2_t *v142;
  float *v143;
  float64x2_t v144;
  uint64_t v145;
  uint64_t v146;
  float64x2_t *v147;
  float *v148;
  float64x2_t v149;
  float64x2_t v150;
  int8x16_t v151;
  int8x16_t v152;
  float64x2_t v153;
  float64x2_t v154;
  int8x16_t v155;
  float64x2_t v156;
  float64x2_t v157;
  int8x16_t v158;
  float64x2_t v159;
  float64x2_t v160;
  uint64_t v161;
  uint64_t v162;
  float64x2_t *v163;
  float64x2_t v164;
  uint64_t v165;
  float32x2_t *v166;
  uint64_t k;
  float64x2_t *v168;
  unsigned int v169;
  size_t v170;
  float32x2_t *v171;
  uint64_t i;
  uint64_t j;
  float *v174;
  double v175;
  double v176;
  float64x2_t v177;
  int64_t v178;
  float32x2_t *v179;
  uint64_t v180;
  float64x2_t v181;
  float64x2_t v182;
  float64x2_t v183;
  float64x2_t v184;
  float64x2_t v185;
  float64x2_t v186;
  float64x2_t v187;
  float64x2_t v188;
  float64x2_t v189;
  uint64_t result;
  uint64_t v192;
  char v193;
  unint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  double v198;
  double v199;
  int v200;
  uint64_t v201;
  float32x2_t *v202;
  uint64_t v203;
  int v204;
  _QWORD *v205;
  uint64_t v206;
  uint64_t v207;
  _QWORD *v208;
  unint64_t v209;
  uint64_t v210;
  uint64_t v211;
  unint64_t v212;
  unint64_t v213;
  int v214;
  float32x2_t *v215;
  _BYTE v216[4240];
  _BYTE *v217;
  uint64_t v218;
  _BYTE v219[4184];

  v11 = MEMORY[0x24BDAC7A8](a1, a2);
  v209 = v12;
  v212 = v13;
  v15 = v14;
  v17 = v16;
  v19 = v18;
  v21 = v20;
  v198 = v23;
  v199 = v22;
  v25 = v24;
  v205 = (_QWORD *)v11;
  v26 = a9[1];
  v200 = *a9;
  v27 = *a10;
  v196 = (int)a10[1];
  v203 = a10[1];
  v204 = *a10;
  v28 = v219;
  bzero(v219, 0x1050uLL);
  v29 = v25;
  v30 = v17;
  v217 = v219;
  v218 = 520;
  v31 = v25 >> 3;
  v32 = v19 >> 3;
  v33 = v209 >> 3;
  if ((a11 & 4) != 0)
    v34 = v209 >> 3;
  else
    v34 = 1;
  if ((a11 & 4) != 0)
    v33 = 1;
  if (v17)
    v35 = v34;
  else
    v35 = 0;
  if (!v17)
    v33 = 0;
  v210 = v33;
  v213 = v212 >> 3;
  if ((a11 & 1) == 0)
  {
    v36 = 1;
    v37 = v31;
    v38 = v199;
    v39 = v205;
    v40 = v200;
LABEL_19:
    if (v40 == 1)
    {
      v206 = v31;
      v43 = v29;
      bzero(v216, 0x1050uLL);
      v215 = (float32x2_t *)v216;
      if (v43 < 0x10)
      {
        v47 = v30;
        v45 = v203;
        v48 = v198;
        v44 = v199;
        v46 = (int)v27;
      }
      else
      {
        v44 = v199;
        v45 = v203;
        v46 = (int)v27;
        if ((int)v26 < 2)
        {
          v47 = v30;
          v48 = v198;
        }
        else
        {
          if (v203 >= 0x209)
          {
            v218 = v196;
            v28 = (_BYTE *)operator new[]();
            bzero(v28, 8 * v196);
            v217 = v28;
            v44 = v199;
            v45 = v203;
            v46 = (int)v27;
          }
          v47 = v30;
          v48 = v198;
          if ((int)v45 >= 1)
          {
            v49 = 0;
            do
            {
              *(_QWORD *)&v28[v49] = *v39;
              v49 += 8;
              v39 += v206;
            }
            while (8 * v45 != v49);
          }
          v39 = v28;
        }
      }
      if (v19 >= 0x10)
      {
        if (v46 <= 0x208)
        {
          v171 = (float32x2_t *)v216;
        }
        else
        {
          v170 = 8 * v46;
          v171 = (float32x2_t *)operator new[]();
          bzero(v171, v170);
          v215 = v171;
          v47 = v30;
          v45 = v203;
          v48 = v198;
          v44 = v199;
          v46 = (int)v27;
        }
        if ((int)v46 >= 1)
        {
          for (i = 0; i != v46; ++i)
          {
            v171[i] = *v21;
            v21 += v19 >> 3;
          }
        }
        v21 = v171;
      }
      if ((int)v45 >= 1)
      {
        for (j = 0; j != v45; ++j)
        {
          v174 = (float *)&v39[j];
          v175 = *v174 * v44;
          v176 = v174[1] * v44;
          v177.f64[0] = -v176;
          if ((int)v46 >= 2)
          {
            v180 = 0;
            v178 = 0;
            v181 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v175, 0);
            v182.f64[0] = -v176;
            v182.f64[1] = v174[1] * v44;
            v179 = v47;
            do
            {
              v183 = vcvtq_f64_f32(v21[v180]);
              v184 = vmlaq_f64(vmulq_f64(v182, (float64x2_t)vextq_s8((int8x16_t)v183, (int8x16_t)v183, 8uLL)), v183, v181);
              v185 = vcvtq_f64_f32(v21[v180 + 1]);
              v186 = vmlaq_f64(vmulq_f64(v182, (float64x2_t)vextq_s8((int8x16_t)v185, (int8x16_t)v185, 8uLL)), v185, v181);
              if (v179)
              {
                *(float32x2_t *)(v15 + v180 * 8) = vcvt_f32_f64(vaddq_f64(v184, vmulq_n_f64(vcvtq_f64_f32(*v179), v48)));
                v186 = vaddq_f64(v186, vmulq_n_f64(vcvtq_f64_f32(v179[v35]), v48));
              }
              else
              {
                *(float32x2_t *)(v15 + v180 * 8) = vcvt_f32_f64(v184);
              }
              *(float32x2_t *)(v15 + v180 * 8 + 8) = vcvt_f32_f64(v186);
              v178 += 2;
              v179 += 2 * v35;
              v180 += 2;
            }
            while (v178 <= (uint64_t)(v46 - 2));
            v178 = v178;
          }
          else
          {
            v178 = 0;
            v179 = v47;
          }
          if ((int)v178 < (int)v27)
          {
            v187 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v175, 0);
            v177.f64[1] = v176;
            do
            {
              v188 = vcvtq_f64_f32(v21[v178]);
              v189 = vmlaq_f64(vmulq_f64(v177, (float64x2_t)vextq_s8((int8x16_t)v188, (int8x16_t)v188, 8uLL)), v188, v187);
              if (v179)
                v189 = vaddq_f64(v189, vmulq_n_f64(vcvtq_f64_f32(*v179), v48));
              *(float32x2_t *)(v15 + 8 * v178++) = vcvt_f32_f64(v189);
              v179 += v35;
            }
            while (v27 != v178);
          }
          v47 += v210;
          v15 += 8 * v213;
        }
      }
      v168 = (float64x2_t *)v215;
      if (v215 != (float32x2_t *)v216 && v215 != 0)
      {
        v169 = 3227415;
        goto LABEL_172;
      }
      goto LABEL_173;
    }
    v28 = 0;
    LODWORD(v26) = v40;
    v31 = v36;
    goto LABEL_30;
  }
  v37 = 1;
  if (v29 < 0x10)
  {
    v36 = v31;
    v40 = v26;
    v38 = v199;
    v39 = v205;
    goto LABEL_19;
  }
  v38 = v199;
  v39 = v205;
  if ((int)v26 < 2)
  {
    v36 = v31;
    v40 = v26;
    goto LABEL_19;
  }
  if (v26 >= 0x209)
  {
    v41 = v31;
    v218 = v26;
    v28 = (_BYTE *)operator new[]();
    bzero(v28, 8 * v26);
    v217 = v28;
    v37 = 1;
    v42 = v198;
    v38 = v199;
    v32 = v19 >> 3;
    v31 = v41;
    goto LABEL_31;
  }
  v37 = 1;
LABEL_30:
  v42 = v198;
LABEL_31:
  if ((a11 & 2) != 0)
  {
    if ((int)v203 >= 1)
    {
      v91 = 0;
      v92 = 8 * v37;
      if (v28)
        v93 = (int)v26 < 1;
      else
        v93 = 1;
      v94 = v93;
      v95 = 8 * v31;
      v96 = 8 * v32;
      do
      {
        if (v28)
          v97 = v28;
        else
          v97 = v39;
        if ((v94 & 1) == 0)
        {
          v98 = 0;
          v99 = v39;
          do
          {
            *(_QWORD *)&v28[v98] = *v99;
            v98 += 8;
            v99 = (_QWORD *)((char *)v99 + v95);
          }
          while (8 * v26 != v98);
          v97 = v28;
        }
        if ((int)v27 >= 1)
        {
          v100 = 0;
          v101 = v97 + 28;
          v102 = v21;
          v103 = v30;
          do
          {
            if ((int)v26 >= 4)
            {
              v109 = 0;
              v110 = 0;
              v105 = 0uLL;
              v106 = 0uLL;
              v107 = 0uLL;
              v108 = 0uLL;
              do
              {
                v111.f64[0] = *(float *)&v101[v109 - 24];
                v112 = vcvtq_f64_f32(v102[v109 / 8]);
                v113.f64[0] = -*(float *)&v101[v109 - 16];
                v111.f64[1] = -v111.f64[0];
                v114.f64[0] = -*(float *)&v101[v109 - 8];
                v115 = (int8x16_t)vmulq_f64(v111, v112);
                v116.f64[0] = -*(float *)&v101[v109];
                v117 = vcvtq_f64_f32(v102[v109 / 8 + 1]);
                v113.f64[1] = *(float *)&v101[v109 - 16];
                v118 = vmlaq_n_f64(vmulq_f64(v113, (float64x2_t)vextq_s8((int8x16_t)v117, (int8x16_t)v117, 8uLL)), v117, *(float *)&v101[v109 - 20]);
                v119 = vcvtq_f64_f32(v102[v109 / 8 + 2]);
                v114.f64[1] = *(float *)&v101[v109 - 8];
                v107 = vaddq_f64(v107, v118);
                v106 = vaddq_f64(v106, vmlaq_n_f64(vmulq_f64(v114, (float64x2_t)vextq_s8((int8x16_t)v119, (int8x16_t)v119, 8uLL)), v119, *(float *)&v101[v109 - 12]));
                v120 = vcvtq_f64_f32(v102[v109 / 8 + 3]);
                v116.f64[1] = *(float *)&v101[v109];
                v108 = vaddq_f64(v108, vmlaq_n_f64((float64x2_t)vextq_s8(v115, v115, 8uLL), v112, *(float *)&v97[v109]));
                v105 = vaddq_f64(v105, vmlaq_n_f64(vmulq_f64(v116, (float64x2_t)vextq_s8((int8x16_t)v120, (int8x16_t)v120, 8uLL)), v120, *(float *)&v101[v109 - 4]));
                v110 += 4;
                v109 += 32;
              }
              while (v110 <= (int)v26 - 4);
              v104 = ((v26 - 4) & 0xFFFFFFFC) + 4;
            }
            else
            {
              v104 = 0;
              v105 = 0uLL;
              v106 = 0uLL;
              v107 = 0uLL;
              v108 = 0uLL;
            }
            if (v104 < (int)v26)
            {
              v121 = 8 * v104;
              do
              {
                v122.f64[0] = -*(float *)&v97[v121 + 4];
                v123 = vcvtq_f64_f32(v102[(unint64_t)v121 / 8]);
                v122.f64[1] = *(float *)&v97[v121 + 4];
                v108 = vaddq_f64(v108, vmlaq_n_f64(vmulq_f64(v122, (float64x2_t)vextq_s8((int8x16_t)v123, (int8x16_t)v123, 8uLL)), v123, *(float *)&v97[v121]));
                ++v104;
                v121 += 8;
              }
              while ((int)v26 > v104);
            }
            v124 = vmulq_n_f64(vaddq_f64(v105, vaddq_f64(v106, vaddq_f64(v107, v108))), v38);
            if (v103)
              v124 = vaddq_f64(v124, vmulq_n_f64(vcvtq_f64_f32(*v103), v42));
            *(float32x2_t *)(v15 + 8 * v100++) = vcvt_f32_f64(v124);
            v103 += v35;
            v102 = (float32x2_t *)((char *)v102 + v96);
          }
          while (v100 != v27);
        }
        ++v91;
        v39 = (_QWORD *)((char *)v39 + v92);
        v30 += v210;
        v15 += 8 * v213;
      }
      while (v91 != (_DWORD)v196);
    }
  }
  else if ((unint64_t)(8 * (int)v27) > 0x640)
  {
    v201 = v37;
    v207 = v31;
    v194 = v32;
    v125 = (float64x2_t *)v216;
    bzero(v216, 0x1090uLL);
    if (v27 >= 0x109)
    {
      v125 = (float64x2_t *)operator new[]();
      bzero(v125, 16 * (int)v27);
    }
    v126 = v203;
    v127 = v27;
    v128 = v198;
    v129 = v199;
    if ((int)v203 >= 1)
    {
      v130 = v30;
      v131 = v39;
      v132 = 0;
      v133 = 8 * v207;
      v134 = 8 * v194;
      if (v28)
        v135 = (int)v26 < 1;
      else
        v135 = 1;
      v195 = 8 * v213;
      v197 = v201;
      v136 = v135;
      v193 = v136;
      v192 = 8 * v207;
      v137 = v125 + 2;
      v211 = v210;
      v138 = 8 * v35;
      do
      {
        if (v28)
          v139 = v28;
        else
          v139 = v131;
        v202 = v130;
        v208 = v131;
        if ((v193 & 1) == 0)
        {
          v140 = 0;
          do
          {
            *(_QWORD *)&v28[v140] = *v131;
            v140 += 8;
            v131 = (_QWORD *)((char *)v131 + v133);
          }
          while (8 * v26 != v140);
          v139 = v28;
        }
        if (v127 >= 1)
        {
          v214 = v132;
          bzero(v125, 16 * v27);
          v138 = 8 * v35;
          v137 = v125 + 2;
          v133 = v192;
          v132 = v214;
          v126 = v203;
          v127 = v27;
          v128 = v198;
          v129 = v199;
        }
        if ((int)v26 >= 1)
        {
          v141 = 0;
          v142 = v21;
          v143 = (float *)&v21[2];
          do
          {
            v144 = vcvtq_f64_f32(*(float32x2_t *)&v139[8 * v141]);
            if ((int)v27 >= 4)
            {
              v146 = 0;
              v147 = v137;
              v148 = v143;
              do
              {
                v149.f64[0] = *(v148 - 3);
                v150.f64[0] = *(v148 - 1);
                v149.f64[1] = -v149.f64[0];
                v151 = (int8x16_t)vmulq_f64(v149, v144);
                v150.f64[1] = -v150.f64[0];
                v152 = (int8x16_t)vmulq_f64(v150, v144);
                v153.f64[0] = v148[1];
                v154.f64[0] = v148[3];
                v153.f64[1] = -v153.f64[0];
                v155 = (int8x16_t)vmulq_f64(v153, v144);
                v156 = vaddq_f64(v147[-1], vmlaq_n_f64((float64x2_t)vextq_s8(v152, v152, 8uLL), v144, *(v148 - 2)));
                v154.f64[1] = -v154.f64[0];
                v157 = vaddq_f64(*v147, vmlaq_n_f64((float64x2_t)vextq_s8(v155, v155, 8uLL), v144, *v148));
                v158 = (int8x16_t)vmulq_f64(v154, v144);
                v159 = vaddq_f64(v147[1], vmlaq_n_f64((float64x2_t)vextq_s8(v158, v158, 8uLL), v144, v148[2]));
                v147[-2] = vaddq_f64(v147[-2], vmlaq_n_f64((float64x2_t)vextq_s8(v151, v151, 8uLL), v144, *(v148 - 4)));
                v147[-1] = v156;
                *v147 = v157;
                v147[1] = v159;
                v147 += 4;
                v146 += 4;
                v148 += 8;
              }
              while (v146 <= (int)v27 - 4);
              v145 = v146;
            }
            else
            {
              v145 = 0;
            }
            if ((int)v145 < v127)
            {
              v160 = (float64x2_t)vextq_s8((int8x16_t)v144, (int8x16_t)v144, 8uLL);
              v161 = v27 - v145;
              v162 = v145;
              v163 = &v125[v145];
              do
              {
                v164.f64[0] = -v142[v162].f32[1];
                v164.f64[1] = v142[v162].f32[1];
                *v163 = vaddq_f64(*v163, vmlaq_n_f64(vmulq_f64(v160, v164), v144, v142[v162].f32[0]));
                ++v163;
                ++v162;
                --v161;
              }
              while (v161);
            }
            ++v141;
            v143 = (float *)((char *)v143 + v134);
            v142 = (float32x2_t *)((char *)v142 + v134);
          }
          while (v141 != v26);
        }
        if (v202)
        {
          if (v127 >= 1)
          {
            v165 = 0;
            v166 = v202;
            do
            {
              *(float32x2_t *)(v15 + 8 * v165) = vcvt_f32_f64(vaddq_f64(vmulq_n_f64(v125[v165], v129), vmulq_n_f64(vcvtq_f64_f32(*v166), v128)));
              ++v165;
              v166 = (float32x2_t *)((char *)v166 + v138);
            }
            while (v27 != v165);
          }
        }
        else if ((int)v27 >= 1)
        {
          for (k = 0; k != v27; ++k)
            *(float32x2_t *)(v15 + 8 * k) = vcvt_f32_f64(vmulq_n_f64(v125[k], v129));
        }
        ++v132;
        v131 = &v208[v197];
        v130 = &v202[v211];
        v15 += v195;
      }
      while (v132 != v126);
    }
    if (v125 != (float64x2_t *)v216)
    {
      v168 = v125;
      v169 = 1159420904;
LABEL_172:
      MEMORY[0x2207351A4](v168, v169 | 0x1000C8000000000);
    }
  }
  else if ((int)v196 >= 1)
  {
    v50 = 0;
    v51 = 8 * v37;
    v52 = 8 * v31;
    if (v28)
      v53 = (int)v26 < 1;
    else
      v53 = 1;
    v54 = 8 * v32;
    v55 = v53;
    do
    {
      if (v28)
        v56 = v28;
      else
        v56 = v39;
      if ((v55 & 1) == 0)
      {
        v57 = 0;
        v58 = v39;
        do
        {
          *(_QWORD *)&v28[v57] = *v58;
          v57 += 8;
          v58 = (_QWORD *)((char *)v58 + v52);
        }
        while (8 * v26 != v57);
        v56 = v28;
      }
      if ((int)v27 >= 4)
      {
        v59 = 0;
        v61 = v21 + 2;
        v60 = v30;
        do
        {
          v62 = 0uLL;
          if ((int)v26 < 1)
          {
            v66 = 0uLL;
            v67 = 0uLL;
            v68 = 0uLL;
          }
          else
          {
            v63 = (float *)(v56 + 4);
            v64 = v61;
            v65 = v26;
            v66 = 0uLL;
            v67 = 0uLL;
            v68 = 0uLL;
            do
            {
              v69 = *(v63 - 1);
              v70.f64[0] = -*v63;
              v71 = vcvtq_f64_f32(v64[-2]);
              v70.f64[1] = *v63;
              v72 = vmlaq_n_f64(vmulq_f64(v70, (float64x2_t)vextq_s8((int8x16_t)v71, (int8x16_t)v71, 8uLL)), v71, v69);
              v73 = vcvtq_f64_f32(v64[-1]);
              v66 = vaddq_f64(v66, v72);
              v74 = vmlaq_n_f64(vmulq_f64(v70, (float64x2_t)vextq_s8((int8x16_t)v73, (int8x16_t)v73, 8uLL)), v73, v69);
              v75 = vcvtq_f64_f32(*v64);
              v67 = vaddq_f64(v67, v74);
              v76 = vmlaq_n_f64(vmulq_f64(v70, (float64x2_t)vextq_s8((int8x16_t)v75, (int8x16_t)v75, 8uLL)), v75, v69);
              v77 = vcvtq_f64_f32(v64[1]);
              v68 = vaddq_f64(v68, v76);
              v62 = vaddq_f64(v62, vmlaq_n_f64(vmulq_f64(v70, (float64x2_t)vextq_s8((int8x16_t)v77, (int8x16_t)v77, 8uLL)), v77, v69));
              v64 = (float32x2_t *)((char *)v64 + v54);
              v63 += 2;
              --v65;
            }
            while (v65);
          }
          v78 = vmulq_n_f64(v66, v38);
          v79 = 8 * v59;
          v80 = vmulq_n_f64(v67, v38);
          if (v60)
          {
            *(float32x2_t *)(v15 + 8 * v59) = vcvt_f32_f64(vaddq_f64(v78, vmulq_n_f64(vcvtq_f64_f32(*v60), v42)));
            *(float32x2_t *)(v15 + (v79 | 8)) = vcvt_f32_f64(vaddq_f64(v80, vmulq_n_f64(vcvtq_f64_f32(v60[v35]), v42)));
            *(float32x2_t *)(v15 + (v79 | 0x10)) = vcvt_f32_f64(vaddq_f64(vmulq_n_f64(v68, v38), vmulq_n_f64(vcvtq_f64_f32(v60[2 * v35]), v42)));
            v81 = vaddq_f64(vmulq_n_f64(v62, v38), vmulq_n_f64(vcvtq_f64_f32(v60[3 * v35]), v42));
          }
          else
          {
            *(float32x2_t *)(v15 + 8 * v59) = vcvt_f32_f64(v78);
            *(float32x2_t *)(v15 + (v79 | 8)) = vcvt_f32_f64(v80);
            *(float32x2_t *)(v15 + (v79 | 0x10)) = vcvt_f32_f64(vmulq_n_f64(v68, v38));
            v81 = vmulq_n_f64(v62, v38);
          }
          *(float32x2_t *)(v15 + (v79 | 0x18)) = vcvt_f32_f64(v81);
          v59 += 4;
          v60 += 4 * v35;
          v61 += 4;
        }
        while (v59 <= (int)v27 - 4);
        v59 = v59;
      }
      else
      {
        v59 = 0;
        v60 = v30;
      }
      if ((int)v59 < (int)v27)
      {
        v82 = (float *)(v56 + 4);
        v83 = &v21[v59];
        do
        {
          v84 = 0uLL;
          if ((int)v26 >= 1)
          {
            v85 = v83;
            v86 = v82;
            v87 = v26;
            do
            {
              v88.f64[0] = -*v86;
              v89 = vcvtq_f64_f32(*v85);
              v88.f64[1] = *v86;
              v84 = vaddq_f64(v84, vmlaq_n_f64(vmulq_f64(v88, (float64x2_t)vextq_s8((int8x16_t)v89, (int8x16_t)v89, 8uLL)), v89, *(v86 - 1)));
              v86 += 2;
              v85 = (float32x2_t *)((char *)v85 + v54);
              --v87;
            }
            while (v87);
          }
          v90 = vmulq_n_f64(v84, v38);
          if (v60)
            v90 = vaddq_f64(v90, vmulq_n_f64(vcvtq_f64_f32(*v60), v42));
          *(float32x2_t *)(v15 + 8 * v59++) = vcvt_f32_f64(v90);
          v60 += v35;
          ++v83;
        }
        while (v59 != v204);
      }
      ++v50;
      v39 = (_QWORD *)((char *)v39 + v51);
      v30 += v210;
      v15 += 8 * v213;
    }
    while (v50 != (_DWORD)v203);
  }
LABEL_173:
  result = (uint64_t)v217;
  if (v217 != v219)
  {
    if (v217)
      return MEMORY[0x2207351A4]();
  }
  return result;
}

void sub_219E55E8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  unint64_t v13;

  v13 = STACK[0x1158];
  if (STACK[0x1158] != a12)
  {
    if (v13)
      MEMORY[0x2207351A4](v13, 0x1000C8000313F17);
  }
  _Unwind_Resume(a1);
}

uint64_t cv::GEMMBlockMul_32fc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float32x2_t *v14;
  float32x2_t *v15;
  unint64_t v16;
  unint64_t v17;
  _QWORD *v18;
  int *v19;
  int v20;
  int v21;
  int *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  _BYTE *v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  int v30;
  uint64_t v31;
  BOOL v32;
  char v33;
  uint64_t v34;
  uint64_t v35;
  _BYTE *v36;
  uint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  float32x2_t *v40;
  float64x2_t v41;
  uint64_t v42;
  float64x2_t v43;
  float64x2_t v44;
  float64x2_t v45;
  float *v46;
  float32x2_t *v47;
  uint64_t v48;
  double v49;
  float64x2_t v50;
  float64x2_t v51;
  float64x2_t v52;
  float64x2_t v53;
  float64x2_t v54;
  float64x2_t v55;
  float64x2_t v56;
  float64x2_t v57;
  float *v58;
  float32x2_t *v59;
  float64x2_t v60;
  float32x2_t *v61;
  float *v62;
  uint64_t v63;
  float64x2_t v64;
  float64x2_t v65;
  int v66;
  uint64_t v67;
  BOOL v68;
  char v69;
  uint64_t v70;
  _BYTE *v71;
  uint64_t v72;
  _QWORD *v73;
  uint64_t v74;
  _BYTE *v75;
  float32x2_t *v76;
  float64x2_t v77;
  float64x2_t v78;
  signed int v79;
  unint64_t v80;
  uint64_t v81;
  float64x2_t v82;
  float64x2_t v83;
  float64x2_t v84;
  float64x2_t v85;
  uint64_t v86;
  float64x2_t v87;
  float64x2_t v88;
  uint64_t result;
  unint64_t v91;
  unint64_t v92;
  _BYTE *v93;
  _BYTE v94[4184];

  v9 = MEMORY[0x24BDAC7A8](a1, a2);
  v91 = v10;
  v92 = v11;
  v13 = v12;
  v15 = v14;
  v17 = v16;
  v18 = (_QWORD *)v9;
  v21 = *v19;
  v20 = v19[1];
  v23 = v22[1];
  v24 = *v22;
  bzero(v94, 0x1050uLL);
  v93 = v94;
  v25 = v17 >> 3;
  if ((a9 & 1) != 0)
  {
    if (v20 < 0x209)
    {
      v27 = 1;
      v26 = v94;
    }
    else
    {
      v26 = (_BYTE *)operator new[]();
      bzero(v26, 8 * v20);
      v93 = v26;
      v27 = 1;
    }
  }
  else
  {
    v26 = 0;
    v20 = v21;
    v27 = v25;
    v25 = 1;
  }
  v28 = v91 >> 3;
  v29 = v92 >> 4;
  if ((a9 & 2) != 0)
  {
    if (v23 >= 1)
    {
      v66 = 0;
      v67 = 8 * v27;
      if (v26)
        v68 = v20 < 1;
      else
        v68 = 1;
      v69 = v68;
      v70 = 8 * v28;
      do
      {
        if (v26)
          v71 = v26;
        else
          v71 = v18;
        if ((v69 & 1) == 0)
        {
          v72 = 0;
          v73 = v18;
          do
          {
            *(_QWORD *)&v26[v72] = *v73;
            v72 += 8;
            v73 += v25;
          }
          while (8 * v20 != v72);
          v71 = v26;
        }
        if ((int)v24 >= 1)
        {
          v74 = 0;
          v75 = v71 + 8;
          v76 = v15;
          do
          {
            v77 = 0uLL;
            v78 = 0uLL;
            if ((a9 & 0x10) != 0)
              v78 = *(float64x2_t *)(v13 + 16 * v74);
            if (v20 >= 2)
            {
              v80 = 0;
              v81 = 0;
              do
              {
                v82.f64[0] = -*(float *)&v75[v80 - 4];
                v83.f64[0] = -*(float *)&v75[v80 + 4];
                v84 = vcvtq_f64_f32(v76[v80 / 8]);
                v82.f64[1] = *(float *)&v75[v80 - 4];
                v85 = vcvtq_f64_f32(v76[v80 / 8 + 1]);
                v83.f64[1] = *(float *)&v75[v80 + 4];
                v78 = vaddq_f64(v78, vmlaq_n_f64(vmulq_f64(v82, (float64x2_t)vextq_s8((int8x16_t)v84, (int8x16_t)v84, 8uLL)), v84, *(float *)&v71[v80]));
                v77 = vaddq_f64(v77, vmlaq_n_f64(vmulq_f64(v83, (float64x2_t)vextq_s8((int8x16_t)v85, (int8x16_t)v85, 8uLL)), v85, *(float *)&v75[v80]));
                v81 += 2;
                v80 += 16;
              }
              while (v81 <= v20 - 2);
              v79 = ((v20 - 2) & 0xFFFFFFFE) + 2;
            }
            else
            {
              v79 = 0;
            }
            if (v79 < v20)
            {
              v86 = 8 * v79;
              do
              {
                v87.f64[0] = -*(float *)&v71[v86 + 4];
                v88 = vcvtq_f64_f32(v76[(unint64_t)v86 / 8]);
                v87.f64[1] = *(float *)&v71[v86 + 4];
                v78 = vaddq_f64(v78, vmlaq_n_f64(vmulq_f64(v87, (float64x2_t)vextq_s8((int8x16_t)v88, (int8x16_t)v88, 8uLL)), v88, *(float *)&v71[v86]));
                ++v79;
                v86 += 8;
              }
              while (v20 > v79);
            }
            *(float64x2_t *)(v13 + 16 * v74++) = vaddq_f64(v77, v78);
            v76 = (float32x2_t *)((char *)v76 + v70);
          }
          while (v74 != v24);
        }
        ++v66;
        v18 = (_QWORD *)((char *)v18 + v67);
        v13 += 16 * v29;
      }
      while (v66 != v23);
    }
  }
  else if (v23 >= 1)
  {
    v30 = 0;
    v31 = 8 * v27;
    if (v26)
      v32 = v20 < 1;
    else
      v32 = 1;
    v33 = v32;
    v34 = 8 * v25;
    v35 = 8 * v28;
    do
    {
      if (v26)
        v36 = v26;
      else
        v36 = v18;
      if ((v33 & 1) == 0)
      {
        v37 = 0;
        v38 = v18;
        do
        {
          *(_QWORD *)&v26[v37] = *v38;
          v37 += 8;
          v38 = (_QWORD *)((char *)v38 + v34);
        }
        while (8 * v20 != v37);
        v36 = v26;
      }
      if ((int)v24 >= 4)
      {
        v39 = 0;
        v40 = v15 + 2;
        do
        {
          v41 = 0uLL;
          v42 = 16 * v39;
          v43 = 0uLL;
          v44 = 0uLL;
          v45 = 0uLL;
          if ((a9 & 0x10) != 0)
          {
            v41 = *(float64x2_t *)(v13 + 16 * v39);
            v43 = *(float64x2_t *)(v13 + (v42 | 0x10));
            v44 = *(float64x2_t *)(v13 + (v42 | 0x20));
            v45 = *(float64x2_t *)(v13 + (v42 | 0x30));
          }
          if (v20 >= 1)
          {
            v46 = (float *)(v36 + 4);
            v47 = v40;
            v48 = v20;
            do
            {
              v49 = *(v46 - 1);
              v50.f64[0] = -*v46;
              v51 = vcvtq_f64_f32(v47[-2]);
              v50.f64[1] = *v46;
              v52 = vmlaq_n_f64(vmulq_f64(v50, (float64x2_t)vextq_s8((int8x16_t)v51, (int8x16_t)v51, 8uLL)), v51, v49);
              v53 = vcvtq_f64_f32(v47[-1]);
              v41 = vaddq_f64(v41, v52);
              v54 = vmlaq_n_f64(vmulq_f64(v50, (float64x2_t)vextq_s8((int8x16_t)v53, (int8x16_t)v53, 8uLL)), v53, v49);
              v55 = vcvtq_f64_f32(*v47);
              v43 = vaddq_f64(v43, v54);
              v56 = vmlaq_n_f64(vmulq_f64(v50, (float64x2_t)vextq_s8((int8x16_t)v55, (int8x16_t)v55, 8uLL)), v55, v49);
              v57 = vcvtq_f64_f32(v47[1]);
              v44 = vaddq_f64(v44, v56);
              v45 = vaddq_f64(v45, vmlaq_n_f64(vmulq_f64(v50, (float64x2_t)vextq_s8((int8x16_t)v57, (int8x16_t)v57, 8uLL)), v57, v49));
              v47 = (float32x2_t *)((char *)v47 + v35);
              v46 += 2;
              --v48;
            }
            while (v48);
          }
          *(float64x2_t *)(v13 + 16 * v39) = v41;
          *(float64x2_t *)(v13 + (v42 | 0x10)) = v43;
          *(float64x2_t *)(v13 + (v42 | 0x20)) = v44;
          *(float64x2_t *)(v13 + (v42 | 0x30)) = v45;
          v39 += 4;
          v40 += 4;
        }
        while (v39 <= v24 - 4);
        v39 = v39;
      }
      else
      {
        v39 = 0;
      }
      if ((int)v39 < (int)v24)
      {
        v58 = (float *)(v36 + 4);
        v59 = &v15[v39];
        do
        {
          v60 = 0uLL;
          if ((a9 & 0x10) != 0)
            v60 = *(float64x2_t *)(v13 + 16 * v39);
          if (v20 >= 1)
          {
            v61 = v59;
            v62 = v58;
            v63 = v20;
            do
            {
              v64.f64[0] = -*v62;
              v65 = vcvtq_f64_f32(*v61);
              v64.f64[1] = *v62;
              v60 = vaddq_f64(v60, vmlaq_n_f64(vmulq_f64(v64, (float64x2_t)vextq_s8((int8x16_t)v65, (int8x16_t)v65, 8uLL)), v65, *(v62 - 1)));
              v62 += 2;
              v61 = (float32x2_t *)((char *)v61 + v35);
              --v63;
            }
            while (v63);
          }
          *(float64x2_t *)(v13 + 16 * v39++) = v60;
          ++v59;
        }
        while (v39 != v24);
      }
      ++v30;
      v18 = (_QWORD *)((char *)v18 + v31);
      v13 += 16 * v29;
    }
    while (v30 != v23);
  }
  result = (uint64_t)v93;
  if (v93 != v94 && v93 != 0)
    return MEMORY[0x2207351A4]();
  return result;
}

void sub_219E563D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12 != a9)
  {
    if (a12)
      MEMORY[0x2207351A4]();
  }
  _Unwind_Resume(exception_object);
}

float32x2_t *cv::GEMMStore_32fc(float32x2_t *result, unint64_t a2, float64x2_t *a3, unint64_t a4, float32x4_t *a5, unint64_t a6, unsigned int *a7, char a8, double a9, double a10)
{
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  float32x4_t *v19;
  uint64_t v20;
  float64x2_t *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  float32x2_t *v25;
  uint64_t v26;
  unint64_t i;
  float64x2_t *v28;
  float32x4_t *v29;
  float32x2_t *v30;
  float32x2_t *v31;
  float32x2_t v32;
  float32x2_t *v33;
  float32x2_t *v34;
  float32x2_t v35;
  float32x2_t *v36;
  float64x2_t v37;
  float64x2_t v38;

  v10 = a7[1];
  v11 = a2 >> 3;
  if ((a8 & 4) != 0)
    v12 = a2 >> 3;
  else
    v12 = 1;
  if ((a8 & 4) != 0)
    v11 = 1;
  if (result)
    v13 = v12;
  else
    v13 = 0;
  if (result)
    v14 = v11;
  else
    v14 = 0;
  if (v10)
  {
    v15 = *a7;
    v16 = (v15 - 4);
    v17 = 8 * v14;
    v18 = 4 * v13;
    v19 = a5 + 1;
    v20 = 8 * (a6 >> 3);
    v21 = a3 + 2;
    v22 = 16 * (a4 >> 4);
    v23 = v13;
    do
    {
      v24 = 0;
      if (result)
      {
        if ((int)v15 < 4)
        {
          v25 = result;
        }
        else
        {
          v28 = v21;
          v29 = v19;
          v30 = result;
          do
          {
            v31 = v30;
            v32 = *v30;
            v33 = &v30[v23];
            v29[-1] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vaddq_f64(vmulq_n_f64(v28[-2], a9), vmulq_n_f64(vcvtq_f64_f32(v32), a10))), vaddq_f64(vmulq_n_f64(v28[-1], a9), vmulq_n_f64(vcvtq_f64_f32(*v33), a10)));
            v34 = &v33[v23];
            v35 = *v34;
            v36 = &v34[v23];
            v38 = *v28;
            v37 = v28[1];
            v28 += 4;
            v24 += 4;
            *v29 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vaddq_f64(vmulq_n_f64(v38, a9), vmulq_n_f64(vcvtq_f64_f32(v35), a10))), vaddq_f64(vmulq_n_f64(v37, a9), vmulq_n_f64(vcvtq_f64_f32(*v36), a10)));
            v29 += 2;
            v30 = &v36[v23];
          }
          while (v24 <= v16);
          v25 = &v31[v18];
          v24 = v24;
        }
        if ((int)v24 < (int)v15)
        {
          do
          {
            *(float32x2_t *)&a5->f32[2 * v24] = vcvt_f32_f64(vaddq_f64(vmulq_n_f64(a3[v24], a9), vmulq_n_f64(vcvtq_f64_f32(*v25), a10)));
            ++v24;
            v25 = (float32x2_t *)((char *)v25 + v23 * 8);
          }
          while (v15 != v24);
        }
      }
      else
      {
        if ((int)v15 >= 4)
        {
          v26 = 0;
          for (i = 0; i <= v16; i += 4)
          {
            a5[v26] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmulq_n_f64(*(float64x2_t *)((char *)a3 + v24), a9)), vmulq_n_f64(*(float64x2_t *)((char *)a3 + v24 + 16), a9));
            v19[v26] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmulq_n_f64(*(float64x2_t *)((char *)v21 + v24), a9)), vmulq_n_f64(*(float64x2_t *)((char *)v21 + v24 + 16), a9));
            v26 += 2;
            v24 += 64;
          }
          v24 = i;
        }
        if ((int)v24 < (int)v15)
        {
          do
          {
            *(float32x2_t *)&a5->f32[2 * v24] = vcvt_f32_f64(vmulq_n_f64(a3[v24], a9));
            ++v24;
          }
          while (v15 != v24);
        }
      }
      result = (float32x2_t *)((char *)result + v17);
      v19 = (float32x4_t *)((char *)v19 + v20);
      v21 = (float64x2_t *)((char *)v21 + v22);
      a5 = (float32x4_t *)((char *)a5 + v20);
      a3 = (float64x2_t *)((char *)a3 + v22);
      --v10;
    }
    while (v10);
  }
  return result;
}

uint64_t cv::GEMMSingleMul_64fc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int *a9, unsigned int *a10, char a11)
{
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  float64x2_t *v18;
  float64x2_t *v19;
  unint64_t v20;
  unint64_t v21;
  _OWORD *v22;
  double v23;
  double v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  float64x2_t *v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  double v38;
  int v39;
  _BYTE *v40;
  int v41;
  void *v42;
  double v43;
  double v44;
  _OWORD *v45;
  unint64_t v46;
  _OWORD *v47;
  uint64_t v48;
  _BYTE *v49;
  void *v50;
  float64x2_t *v51;
  double v52;
  uint64_t v53;
  _OWORD *v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  BOOL v58;
  uint64_t v59;
  char v60;
  _BYTE *v61;
  uint64_t v62;
  _OWORD *v63;
  uint64_t v64;
  float64x2_t *v65;
  float64x2_t *v66;
  float64x2_t v67;
  float64_t *v68;
  float64x2_t *v69;
  uint64_t v70;
  float64x2_t v71;
  float64x2_t v72;
  float64x2_t v73;
  float64x2_t v74;
  double v75;
  float64x2_t v76;
  float64x2_t v77;
  int8x16_t v78;
  int8x16_t v79;
  float64x2_t v80;
  int8x16_t v81;
  int8x16_t v82;
  float64x2_t v83;
  uint64_t v84;
  float64x2_t v85;
  double *v86;
  double *v87;
  float64_t *v88;
  float64x2_t *v89;
  float64x2_t v90;
  float64x2_t *v91;
  float64_t *v92;
  uint64_t v93;
  float64x2_t v94;
  int8x16_t v95;
  float64x2_t v96;
  _OWORD *v97;
  int v98;
  uint64_t v99;
  BOOL v100;
  char v101;
  uint64_t v102;
  _BYTE *v103;
  uint64_t v104;
  _OWORD *v105;
  uint64_t v106;
  _BYTE *v107;
  _OWORD *v108;
  float64x2_t *v109;
  int v110;
  float64x2_t v111;
  float64x2_t v112;
  float64x2_t v113;
  float64x2_t v114;
  unint64_t v115;
  uint64_t v116;
  float64x2_t v117;
  float64x2_t v118;
  float64x2_t v119;
  float64x2_t v120;
  float64x2_t v121;
  float64x2_t v122;
  int8x16_t v123;
  int8x16_t v124;
  float64x2_t v125;
  float64x2_t v126;
  int8x16_t v127;
  float64x2_t v128;
  int8x16_t v129;
  uint64_t v130;
  float64x2_t v131;
  float64x2_t v132;
  int8x16_t v133;
  float64x2_t v134;
  uint64_t v135;
  unint64_t v136;
  _BYTE *v137;
  int v138;
  double v139;
  double v140;
  _OWORD *v141;
  _OWORD *v142;
  float64x2_t *v143;
  int v144;
  uint64_t v145;
  uint64_t v146;
  BOOL v147;
  char v148;
  _BYTE *v149;
  uint64_t v150;
  _OWORD *v151;
  uint64_t v152;
  uint64_t v153;
  _OWORD *v154;
  float64x2_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  float64x2_t *v159;
  float64x2_t v160;
  float64x2_t v161;
  int8x16_t v162;
  int8x16_t v163;
  float64x2_t v164;
  float64x2_t v165;
  float64x2_t v166;
  int8x16_t v167;
  float64x2_t v168;
  float64x2_t v169;
  int8x16_t v170;
  float64x2_t v171;
  uint64_t v172;
  uint64_t v173;
  double v174;
  double v175;
  double v176;
  double *v177;
  float64_t v178;
  uint64_t v179;
  float64x2_t *v180;
  uint64_t v181;
  _BYTE *v182;
  size_t v183;
  _BYTE *v184;
  _OWORD *v185;
  unint64_t v186;
  uint64_t i;
  double *v188;
  double v189;
  float64x2_t v190;
  int64_t v191;
  float64x2_t *v192;
  uint64_t v193;
  float64x2_t v194;
  float64x2_t v195;
  float64x2_t v196;
  float64x2_t v197;
  int8x16_t v198;
  float64x2_t v199;
  int8x16_t v200;
  float64x2_t v201;
  float64x2_t v202;
  float64x2_t v203;
  int8x16_t v204;
  float64x2_t v205;
  uint64_t result;
  uint64_t v208;
  uint64_t v209;
  char v210;
  int v211;
  unint64_t v212;
  uint64_t v213;
  uint64_t v214;
  _OWORD *v215;
  double v216;
  double v217;
  uint64_t v218;
  int v219;
  _OWORD *v220;
  _OWORD *v221;
  uint64_t v222;
  int v223;
  unint64_t v224;
  float64x2_t *v225;
  _BYTE *v226;
  _BYTE *v227;
  _BYTE v228[4240];
  _BYTE *v229;
  uint64_t v230;
  _BYTE v231[4248];

  v11 = MEMORY[0x24BDAC7A8](a1, a2);
  v13 = v12;
  v15 = v14;
  v17 = v16;
  v19 = v18;
  v21 = v20;
  v215 = v22;
  v216 = v24;
  v217 = v23;
  v26 = v25;
  v220 = (_OWORD *)v11;
  v27 = a9[1];
  v211 = *a9;
  v28 = *a10;
  v214 = (int)a10[1];
  v218 = a10[1];
  v219 = *a10;
  bzero(v231, 0x1090uLL);
  v29 = v19;
  v229 = v231;
  v230 = 264;
  v30 = v26 >> 4;
  v31 = v21;
  v32 = v21 >> 4;
  v33 = v17 >> 4;
  if ((a11 & 4) != 0)
    v34 = v17 >> 4;
  else
    v34 = 1;
  if ((a11 & 4) != 0)
    v33 = 1;
  if (v29)
    v35 = v34;
  else
    v35 = 0;
  if (!v29)
    v33 = 0;
  v222 = v33;
  v224 = v13 >> 4;
  if ((a11 & 1) == 0)
  {
    v36 = 1;
    v37 = v26 >> 4;
    v38 = v217;
    v39 = v211;
LABEL_19:
    if (v39 == 1)
    {
      v212 = v21 >> 4;
      bzero(v228, 0x1090uLL);
      v227 = v228;
      if (v26 < 0x20)
      {
        v51 = v29;
        v52 = v216;
        v44 = v217;
        v45 = v215;
        v46 = (int)v28;
        v47 = v220;
        v48 = v218;
      }
      else
      {
        v58 = (int)v27 < 2;
        v44 = v217;
        v45 = v215;
        v46 = (int)v28;
        v47 = v220;
        v48 = v218;
        if (v58)
        {
          v51 = v29;
          v52 = v216;
        }
        else
        {
          v49 = v231;
          if (v218 >= 0x109)
          {
            v230 = v214;
            v50 = (void *)operator new[]();
            bzero(v50, 16 * v214);
            v49 = v50;
            v229 = v50;
            v44 = v217;
            v45 = v215;
            v46 = (int)v28;
            v47 = v220;
            v48 = v218;
          }
          v51 = v29;
          v52 = v216;
          if ((int)v48 >= 1)
          {
            v53 = 0;
            do
            {
              *(_OWORD *)&v49[v53] = *v47;
              v53 += 16;
              v47 += v30;
            }
            while (16 * v48 != v53);
          }
          v47 = v49;
        }
      }
      if (v31 >= 0x20)
      {
        if (v46 <= 0x108)
        {
          v184 = v228;
        }
        else
        {
          v183 = 16 * v46;
          v184 = (_BYTE *)operator new[]();
          bzero(v184, v183);
          v227 = v184;
          v51 = v29;
          v52 = v216;
          v44 = v217;
          v45 = v215;
          v48 = v218;
          v46 = (int)v28;
        }
        if ((int)v46 >= 1)
        {
          v185 = v184;
          v186 = v46;
          do
          {
            *v185++ = *v45;
            v45 += v212;
            --v186;
          }
          while (v186);
        }
        v45 = v184;
      }
      if ((int)v48 >= 1)
      {
        for (i = 0; i != v48; ++i)
        {
          v188 = (double *)&v47[i];
          v189 = *v188 * v44;
          v190.f64[0] = v188[1] * v44;
          if ((int)v46 >= 2)
          {
            v193 = 0;
            v191 = 0;
            v194 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v189, 0);
            v195.f64[0] = v188[1] * v44;
            v195.f64[1] = -v190.f64[0];
            v192 = v51;
            do
            {
              v196 = (float64x2_t)v45[v193];
              v197 = (float64x2_t)v45[v193 + 1];
              v198 = (int8x16_t)vmulq_f64(v196, v195);
              v199 = vmlaq_f64((float64x2_t)vextq_s8(v198, v198, 8uLL), v196, v194);
              v200 = (int8x16_t)vmulq_f64(v197, v195);
              v201 = vmlaq_f64((float64x2_t)vextq_s8(v200, v200, 8uLL), v197, v194);
              if (v192)
              {
                *(float64x2_t *)(v15 + v193 * 16) = vaddq_f64(v199, vmulq_n_f64(*v192, v52));
                v201 = vaddq_f64(v201, vmulq_n_f64(v192[v35], v52));
              }
              else
              {
                *(float64x2_t *)(v15 + v193 * 16) = v199;
              }
              *(float64x2_t *)(v15 + v193 * 16 + 16) = v201;
              v191 += 2;
              v193 += 2;
              v192 += 2 * v35;
            }
            while (v191 <= (uint64_t)(v46 - 2));
            v191 = v191;
          }
          else
          {
            v191 = 0;
            v192 = v51;
          }
          if ((int)v191 < (int)v28)
          {
            v202 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v189, 0);
            do
            {
              v203 = (float64x2_t)v45[v191];
              v190.f64[1] = -v190.f64[0];
              v204 = (int8x16_t)vmulq_f64(v203, v190);
              v205 = vmlaq_f64((float64x2_t)vextq_s8(v204, v204, 8uLL), v203, v202);
              if (v192)
                v205 = vaddq_f64(v205, vmulq_n_f64(*v192, v52));
              *(float64x2_t *)(v15 + 16 * v191++) = v205;
              v192 += v35;
            }
            while (v28 != v191);
          }
          v51 += v222;
          v15 += 16 * v224;
        }
      }
      v182 = v227;
      if (v227 != v228 && v227 != 0)
        goto LABEL_171;
      goto LABEL_172;
    }
    v40 = 0;
    LODWORD(v27) = v39;
    v30 = v36;
    goto LABEL_30;
  }
  v37 = 1;
  if (v26 < 0x20)
  {
    v36 = v26 >> 4;
    v39 = v27;
    v38 = v217;
    goto LABEL_19;
  }
  v38 = v217;
  v40 = v231;
  if ((int)v27 < 2)
  {
    v36 = v26 >> 4;
    v39 = v27;
    goto LABEL_19;
  }
  if (v27 >= 0x109)
  {
    v230 = v27;
    v41 = v218;
    v42 = (void *)operator new[]();
    bzero(v42, 16 * v27);
    v40 = v42;
    v229 = v42;
    v37 = 1;
    v43 = v216;
    v38 = v217;
    v32 = v21 >> 4;
    goto LABEL_31;
  }
  v37 = 1;
LABEL_30:
  v43 = v216;
  v41 = v218;
LABEL_31:
  v226 = v40;
  if ((a11 & 2) != 0)
  {
    v97 = v220;
    if (v41 >= 1)
    {
      v98 = 0;
      v99 = 16 * v37;
      if (v40)
        v100 = (int)v27 < 1;
      else
        v100 = 1;
      v101 = v100;
      v102 = 16 * v32;
      do
      {
        if (v40)
          v103 = v40;
        else
          v103 = v97;
        if ((v101 & 1) == 0)
        {
          v104 = 0;
          v105 = v97;
          do
          {
            *(_OWORD *)&v40[v104] = *v105;
            v104 += 16;
            v105 += v30;
          }
          while (16 * v27 != v104);
          v103 = v40;
        }
        if ((int)v28 >= 1)
        {
          v106 = 0;
          v107 = v103 + 56;
          v108 = v215;
          v109 = v29;
          do
          {
            if ((int)v27 >= 4)
            {
              v115 = 0;
              v116 = 0;
              v111 = 0uLL;
              v112 = 0uLL;
              v113 = 0uLL;
              v114 = 0uLL;
              do
              {
                v117.f64[0] = *(float64_t *)&v107[v115 - 48];
                v118.f64[0] = *(float64_t *)&v107[v115 - 32];
                v119.f64[0] = *(float64_t *)&v107[v115 - 16];
                v120.f64[0] = *(float64_t *)&v107[v115];
                v117.f64[1] = -v117.f64[0];
                v121 = (float64x2_t)v108[v115 / 0x10];
                v122 = (float64x2_t)v108[v115 / 0x10 + 1];
                v123 = (int8x16_t)vmulq_f64(v121, v117);
                v118.f64[1] = -v118.f64[0];
                v124 = (int8x16_t)vmulq_f64(v122, v118);
                v114 = vaddq_f64(v114, vmlaq_n_f64((float64x2_t)vextq_s8(v123, v123, 8uLL), v121, *(double *)&v103[v115]));
                v119.f64[1] = -v119.f64[0];
                v125 = (float64x2_t)v108[v115 / 0x10 + 2];
                v126 = (float64x2_t)v108[v115 / 0x10 + 3];
                v127 = (int8x16_t)vmulq_f64(v125, v119);
                v113 = vaddq_f64(v113, vmlaq_n_f64((float64x2_t)vextq_s8(v124, v124, 8uLL), v122, *(double *)&v107[v115 - 40]));
                v128 = vmlaq_n_f64((float64x2_t)vextq_s8(v127, v127, 8uLL), v125, *(double *)&v107[v115 - 24]);
                v120.f64[1] = -v120.f64[0];
                v129 = (int8x16_t)vmulq_f64(v126, v120);
                v112 = vaddq_f64(v112, v128);
                v111 = vaddq_f64(v111, vmlaq_n_f64((float64x2_t)vextq_s8(v129, v129, 8uLL), v126, *(double *)&v107[v115 - 8]));
                v116 += 4;
                v115 += 64;
              }
              while (v116 <= (int)v27 - 4);
              v110 = ((v27 - 4) & 0xFFFFFFFC) + 4;
            }
            else
            {
              v110 = 0;
              v111 = 0uLL;
              v112 = 0uLL;
              v113 = 0uLL;
              v114 = 0uLL;
            }
            if (v110 < (int)v27)
            {
              v130 = v110;
              do
              {
                v131.f64[0] = *(float64_t *)&v103[v130 * 16 + 8];
                v132 = (float64x2_t)v108[v130];
                v131.f64[1] = -v131.f64[0];
                v133 = (int8x16_t)vmulq_f64(v132, v131);
                v114 = vaddq_f64(v114, vmlaq_n_f64((float64x2_t)vextq_s8(v133, v133, 8uLL), v132, *(double *)&v103[v130 * 16]));
                ++v110;
                ++v130;
              }
              while ((int)v27 > v110);
            }
            v134 = vmulq_n_f64(vaddq_f64(v111, vaddq_f64(v112, vaddq_f64(v113, v114))), v38);
            if (v109)
              v134 = vaddq_f64(v134, vmulq_n_f64(*v109, v43));
            *(float64x2_t *)(v15 + 16 * v106++) = v134;
            v109 += v35;
            v108 = (_OWORD *)((char *)v108 + v102);
          }
          while (v106 != v28);
        }
        ++v98;
        v97 = (_OWORD *)((char *)v97 + v99);
        v29 += v222;
        v15 += 16 * v224;
      }
      while (v98 != (_DWORD)v214);
    }
  }
  else if ((unint64_t)(16 * (int)v28) > 0x640)
  {
    v135 = v37;
    v136 = v32;
    v137 = v228;
    bzero(v228, 0x1090uLL);
    if (v28 >= 0x109)
    {
      v137 = (_BYTE *)operator new[]();
      bzero(v137, 16 * (int)v28);
    }
    v138 = v28;
    v139 = v216;
    v140 = v217;
    v141 = v220;
    v142 = v226;
    if ((int)v218 >= 1)
    {
      v143 = v29;
      v144 = 0;
      v145 = 16 * v28;
      v208 = 16 * v30;
      v146 = 16 * v136;
      if (v226)
        v147 = (int)v27 < 1;
      else
        v147 = 1;
      v213 = 16 * v224;
      v148 = v147;
      v210 = v148;
      v149 = v137 + 48;
      v150 = 16 * v35;
      v209 = v222;
      do
      {
        if (v142)
          v151 = v142;
        else
          v151 = v141;
        v225 = v143;
        v221 = v141;
        if ((v210 & 1) == 0)
        {
          v152 = 0;
          do
          {
            v142[v152++] = *v141;
            v141 = (_OWORD *)((char *)v141 + v208);
          }
          while (v27 != v152);
          v151 = v142;
        }
        if (v138 >= 1)
        {
          v223 = v144;
          bzero(v137, 16 * v28);
          v150 = 16 * v35;
          v144 = v223;
          v142 = v226;
          v138 = v28;
          v139 = v216;
          v140 = v217;
        }
        if ((int)v27 >= 1)
        {
          v153 = 0;
          v154 = v215;
          do
          {
            v155 = (float64x2_t)v151[v153];
            if ((int)v28 >= 4)
            {
              v157 = 0;
              v158 = 0;
              do
              {
                v159 = (float64x2_t *)&v149[v157 * 16];
                v160.f64[0] = *((float64_t *)&v154[v157] + 1);
                v161.f64[0] = *((float64_t *)&v154[v157 + 1] + 1);
                v160.f64[1] = -v160.f64[0];
                v161.f64[1] = -v161.f64[0];
                v162 = (int8x16_t)vmulq_f64(v155, v160);
                v163 = (int8x16_t)vmulq_f64(v155, v161);
                v164.f64[0] = *((float64_t *)&v154[v157 + 2] + 1);
                v164.f64[1] = -v164.f64[0];
                v165 = vaddq_f64(*(float64x2_t *)&v137[v157 * 16], vmlaq_n_f64((float64x2_t)vextq_s8(v162, v162, 8uLL), v155, *(double *)&v154[v157]));
                v162.i64[0] = *(_QWORD *)&v154[v157 + 3];
                v166.f64[0] = *((float64_t *)&v154[v157 + 3] + 1);
                v167 = (int8x16_t)vmulq_f64(v155, v164);
                v168 = vaddq_f64(*(float64x2_t *)&v149[v157 * 16 - 32], vmlaq_n_f64((float64x2_t)vextq_s8(v163, v163, 8uLL), v155, *(double *)&v154[v157 + 1]));
                v169 = vaddq_f64(*(float64x2_t *)&v149[v157 * 16 - 16], vmlaq_n_f64((float64x2_t)vextq_s8(v167, v167, 8uLL), v155, *(double *)&v154[v157 + 2]));
                v159[-3] = v165;
                v159[-2] = v168;
                v166.f64[1] = -v166.f64[0];
                v170 = (int8x16_t)vmulq_f64(v155, v166);
                v171 = vaddq_f64(*(float64x2_t *)&v149[v157 * 16], vmlaq_n_f64((float64x2_t)vextq_s8(v170, v170, 8uLL), v155, *(double *)v162.i64));
                v159[-1] = v169;
                *v159 = v171;
                v158 += 4;
                v157 += 4;
              }
              while (v158 <= (int)v28 - 4);
              v156 = v158;
            }
            else
            {
              v156 = 0;
            }
            if ((int)v156 < v138)
            {
              v172 = v28 - v156;
              v173 = v156;
              do
              {
                v174 = *(double *)&v154[v173];
                v175 = *((double *)&v154[v173] + 1);
                v176 = v174 * v155.f64[0] - v175 * v155.f64[1];
                v177 = (double *)&v137[v173 * 16];
                v178 = v155.f64[0] * v175 + v174 * v155.f64[1] + *(double *)&v137[v173 * 16 + 8];
                *v177 = *(double *)&v137[v173 * 16] + v176;
                v177[1] = v178;
                ++v173;
                --v172;
              }
              while (v172);
            }
            ++v153;
            v154 = (_OWORD *)((char *)v154 + v146);
          }
          while (v153 != v27);
        }
        if (v225)
        {
          if (v138 >= 1)
          {
            v179 = 0;
            v180 = v225;
            do
            {
              *(float64x2_t *)(v15 + v179) = vaddq_f64(vmulq_n_f64(*(float64x2_t *)&v137[v179], v140), vmulq_n_f64(*v180, v139));
              v179 += 16;
              v180 = (float64x2_t *)((char *)v180 + v150);
            }
            while (v145 != v179);
          }
        }
        else if ((int)v28 >= 1)
        {
          v181 = 0;
          do
          {
            *(float64x2_t *)(v15 + v181) = vmulq_n_f64(*(float64x2_t *)&v137[v181], v140);
            v181 += 16;
          }
          while (v145 != v181);
        }
        ++v144;
        v141 = &v221[v135];
        v143 = &v225[v209];
        v15 += v213;
      }
      while (v144 != (_DWORD)v218);
    }
    if (v137 != v228)
    {
      v182 = v137;
LABEL_171:
      MEMORY[0x2207351A4](v182, 0x1000C80451B5BE8);
    }
  }
  else
  {
    v54 = v220;
    if ((int)v214 >= 1)
    {
      v55 = 0;
      v56 = 16 * v37;
      v57 = 16 * v30;
      if (v40)
        v58 = (int)v27 < 1;
      else
        v58 = 1;
      v59 = 16 * v32;
      v60 = v58;
      do
      {
        if (v40)
          v61 = v40;
        else
          v61 = v54;
        if ((v60 & 1) == 0)
        {
          v62 = 0;
          v63 = v54;
          do
          {
            *(_OWORD *)&v40[v62] = *v63;
            v62 += 16;
            v63 = (_OWORD *)((char *)v63 + v57);
          }
          while (16 * v27 != v62);
          v61 = v40;
        }
        if ((int)v28 >= 4)
        {
          v64 = 0;
          v66 = (float64x2_t *)(v215 + 2);
          v65 = v29;
          do
          {
            v67 = 0uLL;
            if ((int)v27 < 1)
            {
              v71 = 0uLL;
              v72 = 0uLL;
              v73 = 0uLL;
            }
            else
            {
              v68 = (float64_t *)(v61 + 8);
              v69 = v66;
              v70 = v27;
              v71 = 0uLL;
              v72 = 0uLL;
              v73 = 0uLL;
              do
              {
                v74.f64[0] = *v68;
                v74.f64[1] = -*v68;
                v75 = *(v68 - 1);
                v76 = v69[-2];
                v77 = v69[-1];
                v78 = (int8x16_t)vmulq_f64(v76, v74);
                v71 = vaddq_f64(v71, vmlaq_n_f64((float64x2_t)vextq_s8(v78, v78, 8uLL), v76, v75));
                v79 = (int8x16_t)vmulq_f64(v77, v74);
                v72 = vaddq_f64(v72, vmlaq_n_f64((float64x2_t)vextq_s8(v79, v79, 8uLL), v77, v75));
                v80 = v69[1];
                v81 = (int8x16_t)vmulq_f64(*v69, v74);
                v73 = vaddq_f64(v73, vmlaq_n_f64((float64x2_t)vextq_s8(v81, v81, 8uLL), *v69, v75));
                v82 = (int8x16_t)vmulq_f64(v80, v74);
                v67 = vaddq_f64(v67, vmlaq_n_f64((float64x2_t)vextq_s8(v82, v82, 8uLL), v80, v75));
                v69 = (float64x2_t *)((char *)v69 + v59);
                v68 += 2;
                --v70;
              }
              while (v70);
            }
            v83 = vmulq_n_f64(v71, v38);
            v84 = 16 * v64;
            if (v65)
            {
              *(float64x2_t *)(v15 + 16 * v64) = vaddq_f64(v83, vmulq_n_f64(*v65, v43));
              *(float64x2_t *)(v15 + (v84 | 0x10)) = vaddq_f64(vmulq_n_f64(v72, v38), vmulq_n_f64(v65[v35], v43));
              *(float64x2_t *)(v15 + (v84 | 0x20)) = vaddq_f64(vmulq_n_f64(v73, v38), vmulq_n_f64(v65[2 * v35], v43));
              v85 = vaddq_f64(vmulq_n_f64(v67, v38), vmulq_n_f64(v65[3 * v35], v43));
            }
            else
            {
              *(float64x2_t *)(v15 + 16 * v64) = v83;
              v86 = (double *)(v15 + (v84 | 0x10));
              *v86 = v38 * v72.f64[0];
              v86[1] = vmuld_lane_f64(v38, v72, 1);
              v87 = (double *)(v15 + (v84 | 0x20));
              *v87 = v38 * v73.f64[0];
              v87[1] = vmuld_lane_f64(v38, v73, 1);
              v85 = vmulq_n_f64(v67, v38);
            }
            *(float64x2_t *)(v15 + (v84 | 0x30)) = v85;
            v64 += 4;
            v65 += 4 * v35;
            v66 += 4;
          }
          while (v64 <= (int)v28 - 4);
          v64 = v64;
        }
        else
        {
          v64 = 0;
          v65 = v29;
        }
        if ((int)v64 < (int)v28)
        {
          v88 = (float64_t *)(v61 + 8);
          v89 = (float64x2_t *)&v215[v64];
          do
          {
            v90 = 0uLL;
            if ((int)v27 >= 1)
            {
              v91 = v89;
              v92 = v88;
              v93 = v27;
              do
              {
                v94.f64[0] = *v92;
                v94.f64[1] = -*v92;
                v95 = (int8x16_t)vmulq_f64(*v91, v94);
                v90 = vaddq_f64(v90, vmlaq_n_f64((float64x2_t)vextq_s8(v95, v95, 8uLL), *v91, *(v92 - 1)));
                v92 += 2;
                v91 = (float64x2_t *)((char *)v91 + v59);
                --v93;
              }
              while (v93);
            }
            v96 = vmulq_n_f64(v90, v38);
            if (v65)
              v96 = vaddq_f64(v96, vmulq_n_f64(*v65, v43));
            *(float64x2_t *)(v15 + 16 * v64++) = v96;
            v65 += v35;
            ++v89;
          }
          while (v64 != v219);
        }
        ++v55;
        v54 = (_OWORD *)((char *)v54 + v56);
        v29 += v222;
        v15 += 16 * v224;
      }
      while (v55 != (_DWORD)v218);
    }
  }
LABEL_172:
  result = (uint64_t)v229;
  if (v229 != v231)
  {
    if (v229)
      return MEMORY[0x2207351A4]();
  }
  return result;
}

void sub_219E572EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  unint64_t v13;

  v13 = STACK[0x1148];
  if (STACK[0x1148] != a12)
  {
    if (v13)
      MEMORY[0x2207351A4](v13, 0x1000C80451B5BE8);
  }
  _Unwind_Resume(a1);
}

uint64_t cv::GEMMBlockMul_64fc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float64x2_t *v14;
  float64x2_t *v15;
  unint64_t v16;
  unint64_t v17;
  _OWORD *v18;
  int *v19;
  int v20;
  int v21;
  int *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  _BYTE *v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  int v30;
  uint64_t v31;
  BOOL v32;
  char v33;
  uint64_t v34;
  uint64_t v35;
  _BYTE *v36;
  uint64_t v37;
  _OWORD *v38;
  uint64_t v39;
  float64x2_t *v40;
  float64x2_t v41;
  uint64_t v42;
  float64x2_t v43;
  float64x2_t v44;
  float64x2_t v45;
  float64_t *v46;
  float64x2_t *v47;
  uint64_t v48;
  float64x2_t v49;
  double v50;
  float64x2_t v51;
  float64x2_t v52;
  int8x16_t v53;
  int8x16_t v54;
  float64x2_t v55;
  int8x16_t v56;
  int8x16_t v57;
  float64_t *v58;
  float64x2_t *v59;
  float64x2_t v60;
  float64x2_t *v61;
  float64_t *v62;
  uint64_t v63;
  float64x2_t v64;
  int8x16_t v65;
  int v66;
  uint64_t v67;
  BOOL v68;
  char v69;
  uint64_t v70;
  _BYTE *v71;
  uint64_t v72;
  _OWORD *v73;
  uint64_t v74;
  _BYTE *v75;
  float64x2_t *v76;
  float64x2_t v77;
  float64x2_t v78;
  signed int v79;
  unint64_t v80;
  uint64_t v81;
  float64x2_t v82;
  float64x2_t v83;
  float64x2_t v84;
  float64x2_t v85;
  int8x16_t v86;
  int8x16_t v87;
  uint64_t v88;
  float64x2_t v89;
  float64x2_t v90;
  int8x16_t v91;
  uint64_t result;
  unint64_t v94;
  unint64_t v95;
  _BYTE *v96;
  _BYTE v97[4248];

  v9 = MEMORY[0x24BDAC7A8](a1, a2);
  v94 = v10;
  v95 = v11;
  v13 = v12;
  v15 = v14;
  v17 = v16;
  v18 = (_OWORD *)v9;
  v21 = *v19;
  v20 = v19[1];
  v23 = v22[1];
  v24 = *v22;
  bzero(v97, 0x1090uLL);
  v96 = v97;
  v25 = v17 >> 4;
  if ((a9 & 1) != 0)
  {
    if (v20 < 0x109)
    {
      v27 = 1;
      v26 = v97;
    }
    else
    {
      v26 = (_BYTE *)operator new[]();
      bzero(v26, 16 * v20);
      v96 = v26;
      v27 = 1;
    }
  }
  else
  {
    v26 = 0;
    v20 = v21;
    v27 = v25;
    v25 = 1;
  }
  v28 = v94 >> 4;
  v29 = v95 >> 4;
  if ((a9 & 2) != 0)
  {
    if (v23 >= 1)
    {
      v66 = 0;
      v67 = 16 * v27;
      if (v26)
        v68 = v20 < 1;
      else
        v68 = 1;
      v69 = v68;
      v70 = 16 * v28;
      do
      {
        if (v26)
          v71 = v26;
        else
          v71 = v18;
        if ((v69 & 1) == 0)
        {
          v72 = 0;
          v73 = v18;
          do
          {
            *(_OWORD *)&v26[v72] = *v73;
            v72 += 16;
            v73 += v25;
          }
          while (16 * v20 != v72);
          v71 = v26;
        }
        if ((int)v24 >= 1)
        {
          v74 = 0;
          v75 = v71 + 16;
          v76 = v15;
          do
          {
            v77 = 0uLL;
            v78 = 0uLL;
            if ((a9 & 0x10) != 0)
              v78 = *(float64x2_t *)(v13 + 16 * v74);
            if (v20 >= 2)
            {
              v80 = 0;
              v81 = 0;
              do
              {
                v82.f64[0] = *(float64_t *)&v75[v80 - 8];
                v83.f64[0] = *(float64_t *)&v75[v80 + 8];
                v82.f64[1] = -v82.f64[0];
                v84 = v76[v80 / 0x10];
                v85 = v76[v80 / 0x10 + 1];
                v86 = (int8x16_t)vmulq_f64(v84, v82);
                v78 = vaddq_f64(v78, vmlaq_n_f64((float64x2_t)vextq_s8(v86, v86, 8uLL), v84, *(double *)&v71[v80]));
                v83.f64[1] = -v83.f64[0];
                v87 = (int8x16_t)vmulq_f64(v85, v83);
                v77 = vaddq_f64(v77, vmlaq_n_f64((float64x2_t)vextq_s8(v87, v87, 8uLL), v85, *(double *)&v75[v80]));
                v81 += 2;
                v80 += 32;
              }
              while (v81 <= v20 - 2);
              v79 = ((v20 - 2) & 0xFFFFFFFE) + 2;
            }
            else
            {
              v79 = 0;
            }
            if (v79 < v20)
            {
              v88 = v79;
              do
              {
                v89.f64[0] = *(float64_t *)&v71[v88 * 16 + 8];
                v90 = v76[v88];
                v89.f64[1] = -v89.f64[0];
                v91 = (int8x16_t)vmulq_f64(v90, v89);
                v78 = vaddq_f64(v78, vmlaq_n_f64((float64x2_t)vextq_s8(v91, v91, 8uLL), v90, *(double *)&v71[v88 * 16]));
                ++v79;
                ++v88;
              }
              while (v20 > v79);
            }
            *(float64x2_t *)(v13 + 16 * v74++) = vaddq_f64(v77, v78);
            v76 = (float64x2_t *)((char *)v76 + v70);
          }
          while (v74 != v24);
        }
        ++v66;
        v18 = (_OWORD *)((char *)v18 + v67);
        v13 += 16 * v29;
      }
      while (v66 != v23);
    }
  }
  else if (v23 >= 1)
  {
    v30 = 0;
    v31 = 16 * v27;
    if (v26)
      v32 = v20 < 1;
    else
      v32 = 1;
    v33 = v32;
    v34 = 16 * v25;
    v35 = 16 * v28;
    do
    {
      if (v26)
        v36 = v26;
      else
        v36 = v18;
      if ((v33 & 1) == 0)
      {
        v37 = 0;
        v38 = v18;
        do
        {
          *(_OWORD *)&v26[v37] = *v38;
          v37 += 16;
          v38 = (_OWORD *)((char *)v38 + v34);
        }
        while (16 * v20 != v37);
        v36 = v26;
      }
      if ((int)v24 >= 4)
      {
        v39 = 0;
        v40 = v15 + 2;
        do
        {
          v41 = 0uLL;
          v42 = 16 * v39;
          v43 = 0uLL;
          v44 = 0uLL;
          v45 = 0uLL;
          if ((a9 & 0x10) != 0)
          {
            v41 = *(float64x2_t *)(v13 + 16 * v39);
            v43 = *(float64x2_t *)(v13 + (v42 | 0x10));
            v44 = *(float64x2_t *)(v13 + (v42 | 0x20));
            v45 = *(float64x2_t *)(v13 + (v42 | 0x30));
          }
          if (v20 >= 1)
          {
            v46 = (float64_t *)(v36 + 8);
            v47 = v40;
            v48 = v20;
            do
            {
              v49.f64[0] = *v46;
              v49.f64[1] = -*v46;
              v50 = *(v46 - 1);
              v51 = v47[-2];
              v52 = v47[-1];
              v53 = (int8x16_t)vmulq_f64(v51, v49);
              v41 = vaddq_f64(v41, vmlaq_n_f64((float64x2_t)vextq_s8(v53, v53, 8uLL), v51, v50));
              v54 = (int8x16_t)vmulq_f64(v52, v49);
              v43 = vaddq_f64(v43, vmlaq_n_f64((float64x2_t)vextq_s8(v54, v54, 8uLL), v52, v50));
              v55 = v47[1];
              v56 = (int8x16_t)vmulq_f64(*v47, v49);
              v44 = vaddq_f64(v44, vmlaq_n_f64((float64x2_t)vextq_s8(v56, v56, 8uLL), *v47, v50));
              v57 = (int8x16_t)vmulq_f64(v55, v49);
              v45 = vaddq_f64(v45, vmlaq_n_f64((float64x2_t)vextq_s8(v57, v57, 8uLL), v55, v50));
              v47 = (float64x2_t *)((char *)v47 + v35);
              v46 += 2;
              --v48;
            }
            while (v48);
          }
          *(float64x2_t *)(v13 + 16 * v39) = v41;
          *(float64x2_t *)(v13 + (v42 | 0x10)) = v43;
          *(float64x2_t *)(v13 + (v42 | 0x20)) = v44;
          *(float64x2_t *)(v13 + (v42 | 0x30)) = v45;
          v39 += 4;
          v40 += 4;
        }
        while (v39 <= v24 - 4);
        v39 = v39;
      }
      else
      {
        v39 = 0;
      }
      if ((int)v39 < (int)v24)
      {
        v58 = (float64_t *)(v36 + 8);
        v59 = &v15[v39];
        do
        {
          v60 = 0uLL;
          if ((a9 & 0x10) != 0)
            v60 = *(float64x2_t *)(v13 + 16 * v39);
          if (v20 >= 1)
          {
            v61 = v59;
            v62 = v58;
            v63 = v20;
            do
            {
              v64.f64[0] = *v62;
              v64.f64[1] = -*v62;
              v65 = (int8x16_t)vmulq_f64(*v61, v64);
              v60 = vaddq_f64(v60, vmlaq_n_f64((float64x2_t)vextq_s8(v65, v65, 8uLL), *v61, *(v62 - 1)));
              v62 += 2;
              v61 = (float64x2_t *)((char *)v61 + v35);
              --v63;
            }
            while (v63);
          }
          *(float64x2_t *)(v13 + 16 * v39++) = v60;
          ++v59;
        }
        while (v39 != v24);
      }
      ++v30;
      v18 = (_OWORD *)((char *)v18 + v31);
      v13 += 16 * v29;
    }
    while (v30 != v23);
  }
  result = (uint64_t)v96;
  if (v96 != v97 && v96 != 0)
    return MEMORY[0x2207351A4]();
  return result;
}

void sub_219E577F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12 != a9)
  {
    if (a12)
      MEMORY[0x2207351A4]();
  }
  _Unwind_Resume(exception_object);
}

float64x2_t *cv::GEMMStore_64fc(float64x2_t *result, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6, unsigned int *a7, char a8, double a9, double a10)
{
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  float64x2_t *v22;
  uint64_t v23;
  unint64_t v24;
  float64x2_t *v25;
  float64x2_t *v26;
  float64x2_t *v27;
  float64x2_t v28;
  float64x2_t *v29;
  float64x2_t v30;
  float64x2_t *v31;
  float64x2_t v32;
  uint64_t v33;
  unint64_t i;
  float64x2_t *v35;
  float64x2_t v36;
  float64x2_t v37;

  v10 = a7[1];
  v11 = a2 >> 4;
  if ((a8 & 4) != 0)
    v12 = a2 >> 4;
  else
    v12 = 1;
  if ((a8 & 4) != 0)
    v11 = 1;
  if (result)
    v13 = v12;
  else
    v13 = 0;
  if (result)
    v14 = v11;
  else
    v14 = 0;
  if (v10)
  {
    v15 = *a7;
    v16 = (v15 - 4);
    v17 = 16 * v14;
    v18 = v13 << 6;
    v19 = 16 * (a6 >> 4);
    v20 = 16 * (a4 >> 4);
    v21 = v13;
    do
    {
      if (result)
      {
        if ((int)v15 < 4)
        {
          v24 = 0;
          v22 = result;
        }
        else
        {
          v23 = 0;
          v24 = 0;
          v25 = result;
          do
          {
            v26 = v25;
            v27 = (float64x2_t *)(a5 + v23);
            v28 = vaddq_f64(vmulq_n_f64(*(float64x2_t *)(a3 + v23 + 16), a9), vmulq_n_f64(v25[v21], a10));
            *v27 = vaddq_f64(vmulq_n_f64(*(float64x2_t *)(a3 + v23), a9), vmulq_n_f64(*v25, a10));
            v27[1] = v28;
            v29 = &v25[v21 + v21];
            v30 = vaddq_f64(vmulq_n_f64(*(float64x2_t *)(a3 + v23 + 32), a9), vmulq_n_f64(*v29, a10));
            v31 = &v29[v21];
            v32 = vaddq_f64(vmulq_n_f64(*(float64x2_t *)(a3 + v23 + 48), a9), vmulq_n_f64(*v31, a10));
            v27[2] = v30;
            v27[3] = v32;
            v24 += 4;
            v23 += 64;
            v25 = &v31[v21];
          }
          while (v24 <= v16);
          v22 = (float64x2_t *)((char *)v26 + v18);
          v24 = v24;
        }
        if ((int)v24 < (int)v15)
        {
          do
          {
            *(float64x2_t *)(a5 + 16 * v24) = vaddq_f64(vmulq_n_f64(*(float64x2_t *)(a3 + 16 * v24), a9), vmulq_n_f64(*v22, a10));
            ++v24;
            v22 = (float64x2_t *)((char *)v22 + v21 * 16);
          }
          while (v15 != v24);
        }
      }
      else
      {
        if ((int)v15 < 4)
        {
          i = 0;
        }
        else
        {
          v33 = 0;
          for (i = 0; i <= v16; i += 4)
          {
            v35 = (float64x2_t *)(a5 + v33);
            v36 = vmulq_n_f64(*(float64x2_t *)(a3 + v33 + 16), a9);
            *v35 = vmulq_n_f64(*(float64x2_t *)(a3 + v33), a9);
            v35[1] = v36;
            v37 = vmulq_n_f64(*(float64x2_t *)(a3 + v33 + 48), a9);
            v35[2] = vmulq_n_f64(*(float64x2_t *)(a3 + v33 + 32), a9);
            v35[3] = v37;
            v33 += 64;
          }
          i = i;
        }
        if ((int)i < (int)v15)
        {
          do
          {
            *(float64x2_t *)(a5 + 16 * i) = vmulq_n_f64(*(float64x2_t *)(a3 + 16 * i), a9);
            ++i;
          }
          while (v15 != i);
        }
      }
      result = (float64x2_t *)((char *)result + v17);
      a5 += v19;
      a3 += v20;
      --v10;
    }
    while (v10);
  }
  return result;
}

void cv::scaleAdd(cv *this, const cv::_InputArray *a2, double a3, const cv::_InputArray *a4, const cv::_OutputArray *a5)
{
  unsigned int v8;
  const cv::Exception *v9;
  unsigned int v10;
  void *v11;
  int v12;
  float v13;
  double *v14;
  void (*v15)(uint64_t, uint64_t, uint64_t, uint64_t, double *);
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int *v20;
  int v21;
  unsigned int *v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int *v27;
  unsigned int v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int *v32;
  unsigned int v33;
  unsigned int v34;
  uint64_t v35;
  int *v36;
  void *__p[5];
  int v38;
  float v39;
  _QWORD v40[2];
  uint64_t v41;
  unsigned int *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  cv *v47;
  uint64_t v48;
  _QWORD v49[2];
  uint64_t v50;
  unsigned int *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  cv *v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  int v60;
  uint64_t v61;
  unsigned int *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  int *v66;
  void **v67;
  uint64_t v68;
  double v69;
  cv::Mat *v70[4];
  unsigned __int8 *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;

  v74 = *MEMORY[0x24BDAC8D0];
  v69 = a3;
  (**(void (***)(uint64_t *__return_ptr, cv *, uint64_t, const cv::_InputArray *, const cv::_OutputArray *))this)(&v58, this, 0xFFFFFFFFLL, a4, a5);
  (**(void (***)(_QWORD *__return_ptr, const cv::_InputArray *, uint64_t))a2)(v49, a2, 0xFFFFFFFFLL);
  v8 = v58;
  if (((LOWORD(v49[0]) ^ (unsigned __int16)v58) & 0xFFF) != 0)
  {
    std::string::basic_string[abi:ne180100]<0>(__p, "src1.type() == src2.type()");
    std::string::basic_string[abi:ne180100]<0>(v70, "scaleAdd");
    std::string::basic_string[abi:ne180100]<0>(&v71, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matmul.cpp");
    cv::Exception::Exception(v40, 4294967081, __p, v70, &v71, 2079);
    cv::error((cv *)v40, v9);
  }
  v10 = v58 & 7;
  if (v10 > 4)
  {
    (*(void (**)(const cv::_InputArray *, _QWORD, int *, uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a4 + 144))(a4, HIDWORD(v58), v66, v58 & 0xFFF, 0xFFFFFFFFLL, 0, 0);
    (**(void (***)(_QWORD *__return_ptr, const cv::_InputArray *, uint64_t))a4)(v40, a4, 0xFFFFFFFFLL);
    v12 = ((v8 >> 3) & 0x1FF) + 1;
    v13 = v69;
    v39 = v13;
    if (v10 == 5)
      v14 = (double *)&v39;
    else
      v14 = &v69;
    if (v10 == 5)
      v15 = (void (*)(uint64_t, uint64_t, uint64_t, uint64_t, double *))cv::scaleAdd_32f;
    else
      v15 = (void (*)(uint64_t, uint64_t, uint64_t, uint64_t, double *))cv::scaleAdd_64f;
    if ((v58 & 0x4000) != 0 && (v49[0] & 0x4000) != 0 && (v40[0] & 0x4000) != 0)
    {
      v18 = HIDWORD(v58);
      if (SHIDWORD(v58) >= 3)
      {
        v19 = 1;
        v20 = v66;
        do
        {
          v21 = *v20++;
          v19 *= v21;
          --v18;
        }
        while (v18);
      }
      else
      {
        v19 = v60 * v59;
      }
      v15(v61, v50, v41, (v19 * v12), v14);
    }
    else
    {
      v70[0] = (cv::Mat *)&v58;
      v70[1] = (cv::Mat *)v49;
      v70[2] = (cv::Mat *)v40;
      v70[3] = 0;
      v71 = 0;
      v72 = 0;
      v73 = 0;
      cv::NAryMatIterator::NAryMatIterator((cv::NAryMatIterator *)__p, v70, &v71, -1);
      v16 = (v12 * v38);
      v17 = -1;
      while ((void *)++v17 < __p[4])
      {
        v15((uint64_t)v71, v72, v73, v16, v14);
        cv::NAryMatIterator::operator++((uint64_t)__p);
      }
    }
    v22 = v42;
    if (v42)
    {
      do
      {
        v23 = __ldaxr(v22);
        v24 = v23 - 1;
      }
      while (__stlxr(v24, v22));
      if (!v24)
        cv::Mat::deallocate((cv::Mat *)v40, v11);
    }
    v41 = 0;
    v43 = 0;
    v44 = 0;
    v45 = 0;
    if (SHIDWORD(v40[0]) >= 1)
    {
      v25 = 0;
      v26 = v46;
      do
        *(_DWORD *)(v26 + 4 * v25++) = 0;
      while (v25 < SHIDWORD(v40[0]));
    }
    v42 = 0;
    if (v47 != (cv *)&v48)
      cv::fastFree((void **)v47, v11);
  }
  else
  {
    cv::addWeighted(this, a2, v69, a4, 1.0, 0.0, (const cv::_OutputArray *)(v58 & 7));
  }
  v27 = v51;
  if (v51)
  {
    do
    {
      v28 = __ldaxr(v27);
      v29 = v28 - 1;
    }
    while (__stlxr(v29, v27));
    if (!v29)
      cv::Mat::deallocate((cv::Mat *)v49, v11);
  }
  v50 = 0;
  v52 = 0;
  v53 = 0;
  v54 = 0;
  if (SHIDWORD(v49[0]) >= 1)
  {
    v30 = 0;
    v31 = v55;
    do
      *(_DWORD *)(v31 + 4 * v30++) = 0;
    while (v30 < SHIDWORD(v49[0]));
  }
  v51 = 0;
  if (v56 != (cv *)&v57)
    cv::fastFree((void **)v56, v11);
  v32 = v62;
  if (v62)
  {
    do
    {
      v33 = __ldaxr(v32);
      v34 = v33 - 1;
    }
    while (__stlxr(v34, v32));
    if (!v34)
      cv::Mat::deallocate((cv::Mat *)&v58, v11);
  }
  v61 = 0;
  v63 = 0;
  v64 = 0;
  v65 = 0;
  if (SHIDWORD(v58) >= 1)
  {
    v35 = 0;
    v36 = v66;
    do
      v36[v35++] = 0;
    while (v35 < SHIDWORD(v58));
  }
  v62 = 0;
  if (v67 != (void **)&v68)
    cv::fastFree(v67, v11);
}

void sub_219E57DE0(_Unwind_Exception *a1, void *a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  uint64_t v37;
  void *v39;
  void *v40;

  cv::Mat::~Mat((cv::Mat *)&a22, a2);
  cv::Mat::~Mat((cv::Mat *)&a37, v39);
  cv::Mat::~Mat((cv::Mat *)(v37 - 216), v40);
  _Unwind_Resume(a1);
}

float32x2_t *cv::scaleAdd_32f(float32x2_t *this, const float *a2, float32x2_t *a3, float *a4, _DWORD *a5, float *a6, double a7)
{
  unint64_t v7;
  float32x2_t v8;
  float32x2_t *v9;
  const float *v10;
  float32x2_t *v11;
  float32x2_t v12;
  float32x2_t v13;
  float32x2_t v14;
  float *v15;
  float *v16;
  float *v17;
  unint64_t v18;
  float v19;
  float v20;
  float v21;

  LODWORD(a7) = *a5;
  if ((int)a4 >= 4)
  {
    v7 = 0;
    v8 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a7, 0);
    v9 = a3 + 1;
    v10 = a2 + 2;
    v11 = this + 1;
    do
    {
      v9[-1] = vmla_f32(*(float32x2_t *)(v10 - 2), v8, v11[-1]);
      v12 = *v11;
      v11 += 2;
      v13 = v12;
      v14 = *(float32x2_t *)v10;
      v10 += 4;
      v7 += 4;
      *v9 = vmla_f32(v14, v8, v13);
      v9 += 2;
    }
    while (v7 <= ((_DWORD)a4 - 4));
  }
  else
  {
    LODWORD(v7) = 0;
  }
  if ((int)v7 < (int)a4)
  {
    v15 = (float *)a3 + v7;
    v16 = (float *)&a2[v7];
    v17 = (float *)this + v7;
    v18 = a4 - (unint64_t)v7;
    do
    {
      v19 = *v17++;
      v20 = v19;
      v21 = *v16++;
      *v15++ = v21 + (float)(v20 * *(float *)&a7);
      --v18;
    }
    while (v18);
  }
  return this;
}

float64x2_t *cv::scaleAdd_64f(float64x2_t *this, const double *a2, float64x2_t *a3, double *a4, double *a5, double *a6)
{
  uint64_t v6;
  unint64_t v7;
  float64x2_t v8;
  float64x2_t *v9;
  const double *v10;
  float64x2_t *v11;
  float64x2_t v12;
  float64x2_t v13;
  float64x2_t v14;
  double *v15;
  double *v16;
  double *v17;
  unint64_t v18;
  double v19;
  double v20;
  double v21;

  v6 = *(uint64_t *)a5;
  if ((int)a4 >= 4)
  {
    v7 = 0;
    v8 = (float64x2_t)vdupq_lane_s64(v6, 0);
    v9 = a3 + 1;
    v10 = a2 + 2;
    v11 = this + 1;
    do
    {
      v9[-1] = vmlaq_f64(*(float64x2_t *)(v10 - 2), v8, v11[-1]);
      v12 = *v11;
      v11 += 2;
      v13 = v12;
      v14 = *(float64x2_t *)v10;
      v10 += 4;
      v7 += 4;
      *v9 = vmlaq_f64(v14, v8, v13);
      v9 += 2;
    }
    while (v7 <= ((_DWORD)a4 - 4));
  }
  else
  {
    LODWORD(v7) = 0;
  }
  if ((int)v7 < (int)a4)
  {
    v15 = &a3->f64[v7];
    v16 = (double *)&a2[v7];
    v17 = &this->f64[v7];
    v18 = a4 - (unint64_t)v7;
    do
    {
      v19 = *v17++;
      v20 = v19;
      v21 = *v16++;
      *v15++ = v21 + v20 * *(double *)&v6;
      --v18;
    }
    while (v18);
  }
  return this;
}

void cv::mulTransposed(cv *this, const cv::_InputArray *a2, const cv::_OutputArray *a3, void (***a4)(uint64_t *__return_ptr, _QWORD, uint64_t), const cv::_InputArray *a5, double a6)
{
  int v6;
  int v9;
  __int16 v11;
  char v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  const cv::Exception *v16;
  const cv::Exception *v17;
  uint64_t v18;
  int32x4_t v19;
  int v20;
  int32x4_t v21;
  cv *v22;
  uint64_t (***v23)(cv::_InputArray *__hidden, int);
  void (*v24)(uint64_t *, void **, uint64_t *, double);
  void (*v25)(uint64_t *, void **, uint64_t *, double);
  const cv::Mat *v26;
  int v27;
  int v28;
  int v29;
  int v30;
  const cv::_OutputArray *v31;
  cv *v32;
  uint64_t (***v33)(cv::_InputArray *__hidden, int);
  uint64_t v34;
  void *v35;
  unsigned int *v36;
  unsigned int v37;
  unsigned int v38;
  uint64_t v39;
  char *v40;
  unsigned int *v41;
  unsigned int v42;
  unsigned int v43;
  uint64_t v44;
  char *v45;
  unsigned int *v46;
  unsigned int v47;
  unsigned int v48;
  uint64_t v49;
  uint64_t v50;
  unsigned int *v51;
  unsigned int v52;
  unsigned int v53;
  uint64_t v54;
  _DWORD *v55;
  unsigned int *v56;
  unsigned int v57;
  unsigned int v58;
  uint64_t v59;
  _DWORD *v60;
  const cv::Exception *v61;
  _BYTE v62[32];
  _OWORD v63[4];
  char *v64;
  cv *v65;
  _QWORD v66[2];
  _BYTE v67[32];
  void *v68[2];
  void *__p[2];
  void *v70[2];
  uint64_t v71;
  unsigned int *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  cv *v77;
  uint64_t v78;
  _OWORD v79[4];
  char *v80;
  cv *v81;
  _QWORD v82[5];
  uint64_t v83;
  int v84;
  int v85;
  uint64_t v86;
  unsigned int *v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  _DWORD *v91;
  cv *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  unsigned int *v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  _DWORD *v101;
  void **v102;
  uint64_t v103;

  v6 = (int)a5;
  v9 = (int)a3;
  (**(void (***)(uint64_t *__return_ptr, cv *, uint64_t))this)(&v94, this, 0xFFFFFFFFLL);
  (**a4)(&v83, a4, 0xFFFFFFFFLL);
  v11 = v94;
  if (v6 >= 0)
    v12 = v6;
  else
    v12 = v94;
  v13 = v12 & 7;
  if (v13 <= (v83 & 7u))
    v14 = v83 & 7;
  else
    v14 = v13;
  if (v14 <= 5)
    v15 = 5;
  else
    v15 = v14;
  if ((v94 & 0xFF8) != 0)
  {
    std::string::basic_string[abi:ne180100]<0>(v70, "src.channels() == 1");
    std::string::basic_string[abi:ne180100]<0>(v63, "mulTransposed");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matmul.cpp");
    cv::Exception::Exception(v79, 4294967081, v70, v63, __p, 2542);
    cv::error((cv *)v79, v16);
  }
  if (v86)
  {
    if ((v83 & 0xFF8) != 0 || v84 != 1 && v84 != (_DWORD)v95 || v85 != 1 && v85 != HIDWORD(v95))
    {
      std::string::basic_string[abi:ne180100]<0>(v70, "delta.channels() == 1 && (delta.rows == src.rows || delta.rows == 1) && (delta.cols == src.cols || delta.cols == 1)");
      std::string::basic_string[abi:ne180100]<0>(v63, "mulTransposed");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matmul.cpp");
      cv::Exception::Exception(v79, 4294967081, v70, v63, __p, 2548);
      cv::error((cv *)v79, v17);
    }
    if ((v83 & 0xFFF) != (_DWORD)v15)
    {
      cv::_OutputArray::_OutputArray((uint64_t)v79, (cv::Mat *)&v83);
      cv::Mat::convertTo((cv::Mat *)&v83, (const cv::_OutputArray *)v79, v15, 1.0, 0.0);
    }
  }
  v18 = 8;
  if (v9)
    v18 = 12;
  (*(void (**)(const cv::_InputArray *, _QWORD, _QWORD, uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 136))(a2, *(unsigned int *)((char *)&v94 + v18), *(unsigned int *)((char *)&v94 + v18), v15, 0xFFFFFFFFLL, 0, 0);
  (**(void (***)(void **__return_ptr, const cv::_InputArray *, uint64_t))a2)(v70, a2, 0xFFFFFFFFLL);
  if (v96 != v71)
  {
    v19.i64[0] = (uint64_t)v70[1];
    v19.i64[1] = v95;
    v20 = v11 & 0xFFF;
    v21.i64[0] = 0x6400000064;
    v21.i64[1] = 0x6400000064;
    if ((vmaxv_u16((uint16x4_t)vmovn_s32(vcgtq_s32(v21, v19))) & 1) != 0 || v20 != (_DWORD)v15)
    {
      if ((v11 & 0xFFF) != 0 || v14 > 5)
      {
        if ((v11 & 0xFFF) != 0 || (_DWORD)v15 != 6)
        {
          if (v20 == 2 && v14 <= 5)
          {
            v24 = (void (*)(uint64_t *, void **, uint64_t *, double))cv::MulTransposedL<unsigned short,float>;
            v25 = (void (*)(uint64_t *, void **, uint64_t *, double))cv::MulTransposedR<unsigned short,float>;
          }
          else if (v20 == 2 && (_DWORD)v15 == 6)
          {
            v24 = (void (*)(uint64_t *, void **, uint64_t *, double))cv::MulTransposedL<unsigned short,double>;
            v25 = (void (*)(uint64_t *, void **, uint64_t *, double))cv::MulTransposedR<unsigned short,double>;
          }
          else if (v20 == 3 && v14 <= 5)
          {
            v24 = (void (*)(uint64_t *, void **, uint64_t *, double))cv::MulTransposedL<short,float>;
            v25 = (void (*)(uint64_t *, void **, uint64_t *, double))cv::MulTransposedR<short,float>;
          }
          else if (v20 == 3 && (_DWORD)v15 == 6)
          {
            v24 = (void (*)(uint64_t *, void **, uint64_t *, double))cv::MulTransposedL<short,double>;
            v25 = (void (*)(uint64_t *, void **, uint64_t *, double))cv::MulTransposedR<short,double>;
          }
          else if (v20 == 5 && v14 <= 5)
          {
            v24 = (void (*)(uint64_t *, void **, uint64_t *, double))cv::MulTransposedL<float,float>;
            v25 = (void (*)(uint64_t *, void **, uint64_t *, double))cv::MulTransposedR<float,float>;
          }
          else
          {
            if (v20 != 5 || (_DWORD)v15 != 6)
            {
              v25 = (void (*)(uint64_t *, void **, uint64_t *, double))cv::MulTransposedL<double,double>;
              if (v9)
                v25 = (void (*)(uint64_t *, void **, uint64_t *, double))cv::MulTransposedR<double,double>;
              if (v20 != 6 || (_DWORD)v15 != 6)
              {
                std::string::basic_string[abi:ne180100]<0>(v63, "");
                std::string::basic_string[abi:ne180100]<0>(__p, "mulTransposed");
                std::string::basic_string[abi:ne180100]<0>(v68, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matmul.cpp");
                cv::Exception::Exception(v79, 4294967086, v63, __p, v68, 2643);
                cv::error((cv *)v79, v61);
              }
              goto LABEL_80;
            }
            v24 = (void (*)(uint64_t *, void **, uint64_t *, double))cv::MulTransposedL<float,double>;
            v25 = (void (*)(uint64_t *, void **, uint64_t *, double))cv::MulTransposedR<float,double>;
          }
        }
        else
        {
          v24 = (void (*)(uint64_t *, void **, uint64_t *, double))cv::MulTransposedL<unsigned char,double>;
          v25 = (void (*)(uint64_t *, void **, uint64_t *, double))cv::MulTransposedR<unsigned char,double>;
        }
      }
      else
      {
        v24 = (void (*)(uint64_t *, void **, uint64_t *, double))cv::MulTransposedL<unsigned char,float>;
        v25 = (void (*)(uint64_t *, void **, uint64_t *, double))cv::MulTransposedR<unsigned char,float>;
      }
      if (!v9)
        v25 = v24;
LABEL_80:
      v25(&v94, v70, &v83, a6);
      cv::_OutputArray::_OutputArray((uint64_t)v79, (cv::Mat *)v70);
      cv::completeSymm((cv *)v79, 0);
      goto LABEL_81;
    }
  }
  v80 = (char *)v79 + 8;
  v81 = (cv *)v82;
  v82[0] = 0;
  v82[1] = 0;
  LODWORD(v79[0]) = 1124007936;
  memset((char *)v79 + 4, 0, 48);
  v79[3] = 0u;
  if (v86)
  {
    if (v91[1] == v101[1] && *v91 == *v101)
    {
      cv::_InputArray::_InputArray((uint64_t)v63, (const cv::Mat *)&v94);
      cv::_InputArray::_InputArray((uint64_t)__p, (const cv::Mat *)&v83);
      v22 = (cv *)cv::_OutputArray::_OutputArray((uint64_t)v68, (cv::Mat *)v79);
      v23 = cv::noArray(v22);
      cv::subtract((uint64_t)v63, (uint64_t)__p, (const cv::_InputArray *)v68, (const cv::_OutputArray *)v23, (const cv::_InputArray *)0xFFFFFFFFLL);
    }
    else
    {
      cv::_InputArray::_InputArray((uint64_t)v63, (const cv::Mat *)&v83);
      v27 = v95;
      v28 = HIDWORD(v95);
      v29 = v84;
      v30 = v85;
      cv::_OutputArray::_OutputArray((uint64_t)__p, (cv::Mat *)v79);
      cv::repeat((cv *)v63, (const cv::_InputArray *)(v27 / v29), (v28 / v30), (uint64_t)__p, v31);
      cv::_InputArray::_InputArray((uint64_t)v63, (const cv::Mat *)&v94);
      cv::_InputArray::_InputArray((uint64_t)__p, (const cv::Mat *)v79);
      v32 = (cv *)cv::_OutputArray::_OutputArray((uint64_t)v68, (cv::Mat *)v79);
      v33 = cv::noArray(v32);
      cv::subtract((uint64_t)v63, (uint64_t)__p, (const cv::_InputArray *)v68, (const cv::_OutputArray *)v33, (const cv::_InputArray *)0xFFFFFFFFLL);
    }
    v26 = (const cv::Mat *)v79;
  }
  else
  {
    v26 = (const cv::Mat *)&v94;
  }
  cv::_InputArray::_InputArray((uint64_t)__p, v26);
  cv::_InputArray::_InputArray((uint64_t)v68, v26);
  v64 = (char *)v63 + 8;
  v65 = (cv *)v66;
  v66[0] = 0;
  v66[1] = 0;
  LODWORD(v63[0]) = 1124007936;
  memset((char *)v63 + 4, 0, 48);
  v63[3] = 0u;
  cv::_InputArray::_InputArray((uint64_t)v67, (const cv::Mat *)v63);
  cv::_OutputArray::_OutputArray((uint64_t)v62, (cv::Mat *)v70);
  if (v9)
    v34 = 1;
  else
    v34 = 2;
  cv::gemm((cv *)__p, (const cv::_InputArray *)v68, (const cv::_InputArray *)v67, a6, (const cv::_InputArray *)v62, 0.0, (const cv::_OutputArray *)v34);
  v36 = (unsigned int *)*((_QWORD *)&v63[1] + 1);
  if (*((_QWORD *)&v63[1] + 1))
  {
    do
    {
      v37 = __ldaxr(v36);
      v38 = v37 - 1;
    }
    while (__stlxr(v38, v36));
    if (!v38)
      cv::Mat::deallocate((cv::Mat *)v63, v35);
  }
  *(_QWORD *)&v63[1] = 0;
  memset(&v63[2], 0, 24);
  if (SDWORD1(v63[0]) >= 1)
  {
    v39 = 0;
    v40 = v64;
    do
      *(_DWORD *)&v40[4 * v39++] = 0;
    while (v39 < SDWORD1(v63[0]));
  }
  *((_QWORD *)&v63[1] + 1) = 0;
  if (v65 != (cv *)v66)
    cv::fastFree((void **)v65, v35);
  v41 = (unsigned int *)*((_QWORD *)&v79[1] + 1);
  if (*((_QWORD *)&v79[1] + 1))
  {
    do
    {
      v42 = __ldaxr(v41);
      v43 = v42 - 1;
    }
    while (__stlxr(v43, v41));
    if (!v43)
      cv::Mat::deallocate((cv::Mat *)v79, v35);
  }
  *(_QWORD *)&v79[1] = 0;
  memset(&v79[2], 0, 24);
  if (SDWORD1(v79[0]) >= 1)
  {
    v44 = 0;
    v45 = v80;
    do
      *(_DWORD *)&v45[4 * v44++] = 0;
    while (v44 < SDWORD1(v79[0]));
  }
  *((_QWORD *)&v79[1] + 1) = 0;
  if (v81 != (cv *)v82)
    cv::fastFree((void **)v81, v35);
LABEL_81:
  v46 = v72;
  if (v72)
  {
    do
    {
      v47 = __ldaxr(v46);
      v48 = v47 - 1;
    }
    while (__stlxr(v48, v46));
    if (!v48)
      cv::Mat::deallocate((cv::Mat *)v70, v35);
  }
  v71 = 0;
  v73 = 0;
  v74 = 0;
  v75 = 0;
  if (SHIDWORD(v70[0]) >= 1)
  {
    v49 = 0;
    v50 = v76;
    do
      *(_DWORD *)(v50 + 4 * v49++) = 0;
    while (v49 < SHIDWORD(v70[0]));
  }
  v72 = 0;
  if (v77 != (cv *)&v78)
    cv::fastFree((void **)v77, v35);
  v51 = v87;
  if (v87)
  {
    do
    {
      v52 = __ldaxr(v51);
      v53 = v52 - 1;
    }
    while (__stlxr(v53, v51));
    if (!v53)
      cv::Mat::deallocate((cv::Mat *)&v83, v35);
  }
  v86 = 0;
  v88 = 0;
  v89 = 0;
  v90 = 0;
  if (SHIDWORD(v83) >= 1)
  {
    v54 = 0;
    v55 = v91;
    do
      v55[v54++] = 0;
    while (v54 < SHIDWORD(v83));
  }
  v87 = 0;
  if (v92 != (cv *)&v93)
    cv::fastFree((void **)v92, v35);
  v56 = v97;
  if (v97)
  {
    do
    {
      v57 = __ldaxr(v56);
      v58 = v57 - 1;
    }
    while (__stlxr(v58, v56));
    if (!v58)
      cv::Mat::deallocate((cv::Mat *)&v94, v35);
  }
  v96 = 0;
  v98 = 0;
  v99 = 0;
  v100 = 0;
  if (SHIDWORD(v94) >= 1)
  {
    v59 = 0;
    v60 = v101;
    do
      v60[v59++] = 0;
    while (v59 < SHIDWORD(v94));
  }
  v97 = 0;
  if (v102 != (void **)&v103)
    cv::fastFree(v102, v35);
}

_QWORD *cv::MulTransposedR<unsigned char,float>(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  uint64_t v3;
  float32x4_t v4;
  float32x4_t v5;
  double v6;
  float64x2_t v7;
  float64x2_t v8;
  double v9;
  __int8 *v10;
  uint64_t v11;
  uint64_t v12;
  const float *v13;
  uint64_t v14;
  unint64_t v15;
  int v16;
  uint64_t v17;
  unsigned int *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  char v23;
  unsigned int v24;
  _QWORD *result;
  unint64_t v26;
  float32x4_t *v27;
  uint64_t v28;
  uint64_t v29;
  float32x4_t *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  float *v34;
  __int8 *v35;
  uint64_t v36;
  __int8 *v37;
  float *v38;
  _DWORD *v39;
  uint64_t v40;
  __int8 *v41;
  float *v42;
  _DWORD *v43;
  uint64_t v44;
  float32x4_t *v45;
  __int8 *v46;
  float64x2_t v47;
  uint64_t v48;
  float *v49;
  float64x2_t v50;
  float v51;
  float32x4_t v52;
  float64x2_t v53;
  float *v54;
  double v55;
  __int8 *v56;
  uint64_t v57;
  float *v58;
  float v59;
  uint64_t v60;
  uint64_t v61;
  __int8 *v62;
  uint64_t v63;
  __int8 *v64;
  _DWORD *v65;
  uint64_t v66;
  __int8 *v67;
  float64x2_t v68;
  uint64_t v69;
  float *v70;
  float64x2_t v71;
  float v72;
  int8x16_t v73;
  int8x8_t v74;
  uint64x2_t v75;
  float64x2_t v76;
  double v77;
  __int8 *v78;
  uint64_t v79;
  float *v80;
  float v81;
  double v82;
  _QWORD v83[517];

  v2 = (_QWORD *)MEMORY[0x24BDAC7A8](a1, a2);
  v9 = *(double *)v4.i64;
  v83[515] = *MEMORY[0x24BDAC8D0];
  v10 = (__int8 *)v2[2];
  v12 = *(_QWORD *)(v11 + 16);
  v13 = *(const float **)(v3 + 16);
  v14 = v2[10];
  v15 = *(_QWORD *)(v11 + 80);
  v16 = *(_DWORD *)(v3 + 12);
  if (*(int *)(v3 + 8) <= 1)
    v17 = 0;
  else
    v17 = *(_QWORD *)(v3 + 80) >> 2;
  v18 = (unsigned int *)v2[8];
  v20 = (int)*v18;
  v19 = (int)v18[1];
  v21 = *v18;
  if (v13)
    v22 = v16 < (int)v19;
  else
    v22 = 0;
  v23 = !v22;
  if (v22)
  {
    if (v16 != 1)
      __assert_rtn("MulTransposedR", "matmul.cpp", 2360, "delta_cols == 1");
    v24 = 20 * v21;
  }
  else
  {
    v24 = 4 * v20;
  }
  result = v83;
  if (v24 >= 0x1009)
  {
    v82 = *(double *)v4.i64;
    result = (_QWORD *)operator new[]();
    v9 = v82;
  }
  v26 = v15 >> 2;
  if ((v23 & 1) == 0)
  {
    v27 = (float32x4_t *)((char *)result + 4 * v20);
    if ((int)v20 >= 1)
    {
      v29 = v21;
      v30 = (float32x4_t *)((char *)result + 4 * v20);
      do
      {
        v4 = vld1q_dup_f32(v13);
        v28 = 4 * v17;
        v13 = (const float *)((char *)v13 + v28);
        *v30++ = v4;
        --v29;
      }
      while (v29);
    }
    v17 = 4 * (v17 != 0);
    v13 = (const float *)result + v20;
    goto LABEL_23;
  }
  if (v13)
  {
    v27 = 0;
LABEL_23:
    if ((int)v19 >= 1)
    {
      v31 = 0;
      v32 = v19 - 4;
      v33 = 4 * v17;
      v34 = (float *)v13;
      v35 = v10;
      do
      {
        if (v27)
        {
          v36 = v21;
          v37 = v35;
          v38 = (float *)v27;
          v39 = result;
          if ((int)v20 >= 1)
          {
            do
            {
              v4.i8[0] = *v37;
              v4.f32[0] = (float)v4.u32[0] - *v38;
              *v39++ = v4.i32[0];
              v38 = (float *)((char *)v38 + v33);
              v37 += v14;
              --v36;
            }
            while (v36);
          }
        }
        else if ((int)v21 >= 1)
        {
          v40 = v21;
          v41 = v35;
          v42 = v34;
          v43 = result;
          do
          {
            v4.i8[0] = *v41;
            v4.f32[0] = (float)v4.u32[0] - *v42;
            *v43++ = v4.i32[0];
            v42 = (float *)((char *)v42 + v33);
            v41 += v14;
            --v40;
          }
          while (v40);
        }
        v44 = v31;
        if (v31 <= v32)
        {
          do
          {
            if ((int)v20 < 1)
            {
              v47 = 0uLL;
              v50 = 0uLL;
            }
            else
            {
              v45 = (float32x4_t *)&v13[v44];
              if (v27)
                v45 = v27;
              v46 = &v10[v44];
              v47 = 0uLL;
              v48 = v21;
              v49 = (float *)result;
              v50 = 0uLL;
              do
              {
                v51 = *v49++;
                v6 = v51;
                LODWORD(v7.f64[0]) = *(_DWORD *)v46;
                v52 = vsubq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)&v7.f64[0]))), *v45);
                v53 = vcvtq_f64_f32(*(float32x2_t *)v52.f32);
                v7 = vcvt_hight_f64_f32(v52);
                v50 = vmlaq_n_f64(v50, v7, v51);
                v47 = vmlaq_n_f64(v47, v53, v51);
                v46 += v14;
                v45 = (float32x4_t *)((char *)v45 + v33);
                --v48;
              }
              while (v48);
            }
            v4 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmulq_n_f64(v47, v9)), vmulq_n_f64(v50, v9));
            *(float32x4_t *)(v12 + 4 * v44) = v4;
            v44 += 4;
          }
          while ((int)v32 >= (int)v44);
          v44 = v44;
        }
        else
        {
          v44 = v31;
        }
        for (; (int)v19 > (int)v44; ++v44)
        {
          if ((int)v21 < 1)
          {
            v55 = 0.0;
          }
          else
          {
            v54 = (float *)&v13[v44];
            if (v27)
              v54 = (float *)v27;
            v55 = 0.0;
            v56 = v10;
            v57 = v21;
            v58 = (float *)result;
            do
            {
              v59 = *v58++;
              LOBYTE(v6) = v56[v44];
              v6 = (float)((float)LODWORD(v6) - *v54);
              v55 = v55 + v59 * v6;
              v54 = (float *)((char *)v54 + v33);
              v56 += v14;
              --v57;
            }
            while (v57);
          }
          v4.f32[0] = v55 * v9;
          *(_DWORD *)(v12 + 4 * v44) = v4.i32[0];
        }
        ++v31;
        v12 += 4 * v26;
        ++v35;
        ++v34;
      }
      while (v31 != v19);
    }
    goto LABEL_53;
  }
  if ((int)v19 >= 1)
  {
    v60 = 0;
    v61 = v19 - 4;
    v62 = v10;
    do
    {
      v63 = v20;
      v64 = v62;
      v65 = result;
      if ((int)v21 >= 1)
      {
        do
        {
          v5.i8[0] = *v64;
          v5.f32[0] = (float)v5.u32[0];
          *v65++ = v5.i32[0];
          v64 += v14;
          --v63;
        }
        while (v63);
      }
      v66 = v60;
      if (v60 <= v61)
      {
        do
        {
          if ((int)v20 < 1)
          {
            v68 = 0uLL;
            v71 = 0uLL;
          }
          else
          {
            v67 = &v10[v66];
            v68 = 0uLL;
            v69 = v20;
            v70 = (float *)result;
            v71 = 0uLL;
            do
            {
              v72 = *v70++;
              v7.f64[0] = v72;
              LODWORD(v8.f64[0]) = *(_DWORD *)v67;
              v73 = (int8x16_t)vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)&v8.f64[0]));
              v74 = vand_s8((int8x8_t)*(_OWORD *)&vextq_s8(v73, v73, 8uLL), (int8x8_t)0xFF000000FFLL);
              v75.i64[0] = v74.u32[0];
              v75.i64[1] = v74.u32[1];
              v76 = vcvtq_f64_u64(v75);
              *(int8x8_t *)v73.i8 = vand_s8(*(int8x8_t *)v73.i8, (int8x8_t)0xFF000000FFLL);
              v75.i64[0] = v73.u32[0];
              v75.i64[1] = v73.u32[1];
              v8 = vcvtq_f64_u64(v75);
              v68 = vmlaq_n_f64(v68, v8, v72);
              v71 = vmlaq_n_f64(v71, v76, v72);
              v67 += v14;
              --v69;
            }
            while (v69);
          }
          v5 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmulq_n_f64(v68, v9)), vmulq_n_f64(v71, v9));
          *(float32x4_t *)(v12 + 4 * v66) = v5;
          v66 += 4;
        }
        while ((int)v61 >= (int)v66);
        v66 = v66;
      }
      else
      {
        v66 = v60;
      }
      for (; (int)v19 > (int)v66; ++v66)
      {
        v77 = 0.0;
        if ((int)v21 >= 1)
        {
          v78 = v10;
          v79 = v20;
          v80 = (float *)result;
          do
          {
            v81 = *v80++;
            LOBYTE(v7.f64[0]) = v78[v66];
            v7.f64[0] = (double)*(unint64_t *)&v7.f64[0];
            v77 = v77 + v81 * v7.f64[0];
            v78 += v14;
            --v79;
          }
          while (v79);
        }
        v5.f32[0] = v77 * v9;
        *(_DWORD *)(v12 + 4 * v66) = v5.i32[0];
      }
      ++v60;
      v12 += 4 * v26;
      ++v62;
    }
    while (v60 != v19);
  }
LABEL_53:
  if (result != v83)
    return (_QWORD *)MEMORY[0x2207351A4](result, 0x1000C8077774924);
  return result;
}

uint64_t cv::MulTransposedL<unsigned char,float>(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  unsigned __int8 *v10;
  uint64_t v11;
  uint64_t v12;
  float *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int *v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  _BOOL4 v22;
  uint64_t v23;
  unsigned __int8 *v24;
  float *v25;
  uint64_t v26;
  float v27;
  uint64_t v28;
  unsigned __int8 *v29;
  float *v30;
  float *v31;
  unsigned int v32;
  float v33;
  float v34;
  unsigned __int8 *v35;
  unsigned __int8 *v36;
  uint64_t v37;
  float32x4_t *v38;
  float32x4_t v39;
  int v40;
  double v41;
  uint64_t v42;
  float *v43;
  float v44;
  double v45;
  double v46;
  float v47;
  float v48;
  double v49;
  double v50;
  unsigned __int8 *v51;
  float *v52;
  float v53;
  float v54;
  unsigned int v55;
  float v56;
  float v57;
  float v58;
  unint64_t v59;
  unsigned __int8 *v60;
  unsigned __int8 *v61;
  unsigned __int8 *v62;
  unint64_t v63;
  int v64;
  double v65;
  uint64_t v66;
  unint64_t v67;
  unint64_t v68;
  double v69;
  unint64_t v70;
  unint64_t v71;
  double v72;
  unsigned __int8 *v73;
  unsigned __int8 *v74;
  unsigned int v75;
  unsigned int v76;
  float v77;
  _BYTE v78[4120];
  float32x4_t v79;
  uint64_t v80;

  result = MEMORY[0x24BDAC7A8](a1, a2);
  v9 = v8;
  v80 = *MEMORY[0x24BDAC8D0];
  v10 = *(unsigned __int8 **)(result + 16);
  v12 = *(_QWORD *)(v11 + 16);
  v13 = *(float **)(v3 + 16);
  v14 = *(_QWORD *)(result + 80);
  v15 = *(_QWORD *)(v11 + 80) >> 2;
  if (*(int *)(v3 + 8) <= 1)
    v16 = 0;
  else
    v16 = *(_QWORD *)(v3 + 80) >> 2;
  v17 = *(unsigned int **)(result + 64);
  v18 = *v17;
  v19 = (int)v17[1];
  v20 = v17[1];
  if (v13)
  {
    v21 = *(_DWORD *)(v3 + 12);
    v22 = v21 == v19;
    result = (uint64_t)v78;
    if ((unint64_t)(4 * v19) >= 0x1009)
    {
      result = operator new[]();
      v22 = v21 == v19;
    }
    if ((int)v18 >= 1)
    {
      v23 = 0;
      v24 = v10 + 3;
      v25 = v13;
      do
      {
        if (v21 >= (int)v20)
        {
          v28 = v20;
          v29 = v10;
          v30 = v25;
          v31 = (float *)result;
          if ((int)v20 >= 1)
          {
            do
            {
              v32 = *v29++;
              v33 = (float)v32;
              v34 = *v30++;
              *(float *)&v4 = v34;
              *v31++ = v33 - v34;
              --v28;
            }
            while (v28);
          }
        }
        else if ((int)v19 >= 1)
        {
          v26 = 0;
          v27 = v13[v16 * v23];
          do
          {
            LOBYTE(v4) = v10[v26];
            *(float *)&v4 = (float)LODWORD(v4) - v27;
            *(_DWORD *)(result + 4 * v26++) = LODWORD(v4);
          }
          while (v20 != v26);
        }
        v35 = v10;
        v36 = v24;
        v37 = v23;
        do
        {
          v38 = (float32x4_t *)&v13[v16 * v37];
          if (v21 < (int)v19)
          {
            v39 = vld1q_dup_f32(v38->f32);
            v79 = v39;
            v38 = &v79;
          }
          if ((int)v20 >= 4)
          {
            v42 = 0;
            v41 = 0.0;
            v43 = (float *)(result + 8);
            do
            {
              LOBYTE(v6) = v36[v42 - 3];
              v44 = v38->f32[0];
              LOBYTE(v44) = v36[v42 - 2];
              v45 = *(v43 - 1) * (float)((float)LODWORD(v44) - v38->f32[1]);
              v46 = v45 + *(v43 - 2) * (float)((float)LODWORD(v6) - v38->f32[0]);
              LOBYTE(v45) = v36[v42 - 1];
              v47 = *v43;
              v48 = v43[1];
              v43 += 4;
              v49 = v47;
              v50 = v46 + v49 * (float)((float)LODWORD(v45) - v38->f32[2]);
              LOBYTE(v49) = v36[v42];
              v6 = (float)((float)LODWORD(v49) - v38->f32[3]);
              v4 = v50 + v48 * v6;
              v41 = v41 + v4;
              v42 += 4;
              v38 += v22;
            }
            while (v42 <= (int)v20 - 4);
            v40 = ((v20 - 4) & 0xFFFFFFFC) + 4;
          }
          else
          {
            v40 = 0;
            v41 = 0.0;
          }
          if (v40 < (int)v19)
          {
            v51 = &v35[v40];
            v52 = (float *)(result + 4 * v40);
            do
            {
              v53 = *v52++;
              v54 = v53;
              v55 = *v51++;
              v56 = (float)v55;
              v57 = v38->f32[0];
              v38 = (float32x4_t *)((char *)v38 + 4);
              *(float *)&v6 = v57;
              v4 = v54;
              v41 = v41 + v4 * (float)(v56 - v57);
              ++v40;
            }
            while ((int)v19 > v40);
          }
          v58 = v41 * v9;
          *(float *)(v12 + 4 * v37++) = v58;
          v36 += v14;
          v35 += v14;
        }
        while (v37 != v18);
        v12 += 4 * v15;
        ++v23;
        v25 += v16;
        v10 += v14;
        v24 += v14;
      }
      while (v23 != v18);
    }
    if ((_BYTE *)result != v78)
      return MEMORY[0x2207351A4](result, 0x1000C8077774924);
  }
  else if ((int)v18 >= 1)
  {
    v59 = 0;
    v60 = v10 + 1;
    do
    {
      v61 = v10;
      v62 = v60;
      v63 = v59;
      do
      {
        if ((int)v19 >= 4)
        {
          v66 = 0;
          v65 = 0.0;
          do
          {
            LOBYTE(v4) = v60[v66 - 1];
            LOBYTE(v5) = v62[v66 - 1];
            LOBYTE(v6) = v60[v66];
            *(double *)&v67 = (double)*(unint64_t *)&v5;
            LOBYTE(v7) = v62[v66];
            v7 = (double)*(unint64_t *)&v7;
            *(double *)&v68 = (double)*(unint64_t *)&v6 * v7;
            v69 = *(double *)&v68 + (double)*(unint64_t *)&v4 * *(double *)&v67;
            LOBYTE(v67) = v60[v66 + 1];
            *(double *)&v70 = (double)v67;
            LOBYTE(v68) = v62[v66 + 1];
            *(double *)&v71 = (double)v68;
            v72 = v69 + *(double *)&v70 * *(double *)&v71;
            LOBYTE(v70) = v60[v66 + 2];
            v5 = (double)v70;
            LOBYTE(v71) = v62[v66 + 2];
            v6 = (double)v71;
            v4 = v72 + v5 * v6;
            v65 = v65 + v4;
            v66 += 4;
          }
          while (v66 <= (int)v20 - 4);
          v64 = ((v20 - 4) & 0xFFFFFFFC) + 4;
        }
        else
        {
          v64 = 0;
          v65 = 0.0;
        }
        if (v64 < (int)v20)
        {
          v73 = &v61[v64];
          v74 = &v10[v64];
          do
          {
            v75 = *v74++;
            v4 = (double)v75;
            v76 = *v73++;
            result = v76;
            v5 = (double)v76;
            v65 = v65 + v4 * (double)v76;
            ++v64;
          }
          while ((int)v20 > v64);
        }
        v77 = v65 * v9;
        *(float *)(v12 + 4 * v63++) = v77;
        v62 += v14;
        v61 += v14;
      }
      while (v63 < v18);
      ++v59;
      v12 += 4 * v15;
      v60 += v14;
      v10 += v14;
    }
    while (v59 != v18);
  }
  return result;
}

double *cv::MulTransposedR<unsigned char,double>(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  uint64_t v3;
  double v4;
  double v5;
  double v6;
  double v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  double *v11;
  uint64_t v12;
  unint64_t v13;
  int v14;
  uint64_t v15;
  unsigned int *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  BOOL v20;
  char v21;
  unsigned int v22;
  double *result;
  unint64_t v24;
  double *v25;
  double *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _BYTE *v31;
  double *v32;
  _BYTE *v33;
  uint64_t v34;
  _BYTE *v35;
  double *v36;
  double *v37;
  uint64_t v38;
  _BYTE *v39;
  double *v40;
  double *v41;
  _BYTE *v42;
  uint64_t v43;
  double *v44;
  double *v45;
  double v46;
  _BYTE *v47;
  uint64_t v48;
  double *v49;
  double v50;
  double v51;
  double v52;
  double v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  double *v57;
  double *v58;
  double v59;
  _BYTE *v60;
  uint64_t v61;
  double *v62;
  double v63;
  uint64_t v64;
  uint64_t v65;
  _BYTE *v66;
  _BYTE *v67;
  uint64_t v68;
  _BYTE *v69;
  double *v70;
  _BYTE *v71;
  uint64_t v72;
  double v73;
  _BYTE *v74;
  uint64_t v75;
  double *v76;
  double v77;
  double v78;
  double v79;
  double v80;
  unint64_t v81;
  unint64_t v82;
  unint64_t v83;
  double *v84;
  double v85;
  _BYTE *v86;
  uint64_t v87;
  double *v88;
  double v89;
  _QWORD v90[517];

  v2 = (_QWORD *)MEMORY[0x24BDAC7A8](a1, a2);
  v7 = v4;
  v90[515] = *MEMORY[0x24BDAC8D0];
  v8 = (_BYTE *)v2[2];
  v10 = *(_QWORD *)(v9 + 16);
  v11 = *(double **)(v3 + 16);
  v12 = v2[10];
  v13 = *(_QWORD *)(v9 + 80);
  v14 = *(_DWORD *)(v3 + 12);
  if (*(int *)(v3 + 8) <= 1)
    v15 = 0;
  else
    v15 = *(_QWORD *)(v3 + 80) >> 3;
  v16 = (unsigned int *)v2[8];
  v18 = (int)*v16;
  v17 = (int)v16[1];
  v19 = *v16;
  if (v11)
    v20 = v14 < (int)v17;
  else
    v20 = 0;
  v21 = !v20;
  if (v20)
  {
    if (v14 != 1)
      __assert_rtn("MulTransposedR", "matmul.cpp", 2360, "delta_cols == 1");
    v22 = 40 * v19;
  }
  else
  {
    v22 = 8 * v18;
  }
  result = (double *)v90;
  if (v22 >= 0x1009)
    result = (double *)operator new[]();
  v24 = v13 >> 3;
  if ((v21 & 1) == 0)
  {
    v25 = &result[v18];
    if ((int)v18 >= 1)
    {
      v26 = v25 + 2;
      v27 = v19;
      do
      {
        v4 = *v11;
        *v26 = *v11;
        v26[1] = v4;
        *(v26 - 2) = v4;
        *(v26 - 1) = v4;
        v11 += v15;
        v26 += 4;
        --v27;
      }
      while (v27);
    }
    v15 = 4 * (v15 != 0);
    v11 = &result[v18];
    goto LABEL_23;
  }
  if (v11)
  {
    v25 = 0;
LABEL_23:
    if ((int)v17 >= 1)
    {
      v28 = 0;
      v29 = v17 - 4;
      v30 = 8 * v15;
      v31 = v8 + 1;
      v32 = v11;
      v33 = v8;
      do
      {
        if (v25)
        {
          v34 = v19;
          v35 = v33;
          v36 = v25;
          v37 = result;
          if ((int)v18 >= 1)
          {
            do
            {
              LOBYTE(v4) = *v35;
              v4 = (double)*(unint64_t *)&v4 - *v36;
              *v37++ = v4;
              v36 = (double *)((char *)v36 + v30);
              v35 += v12;
              --v34;
            }
            while (v34);
          }
        }
        else if ((int)v19 >= 1)
        {
          v38 = v19;
          v39 = v33;
          v40 = v32;
          v41 = result;
          do
          {
            LOBYTE(v4) = *v39;
            v4 = (double)*(unint64_t *)&v4 - *v40;
            *v41++ = v4;
            v40 = (double *)((char *)v40 + v30);
            v39 += v12;
            --v38;
          }
          while (v38);
        }
        v42 = v31;
        v43 = v28;
        if (v28 <= v29)
        {
          do
          {
            if ((int)v18 < 1)
            {
              v52 = 0.0;
              v51 = 0.0;
              v50 = 0.0;
              v46 = 0.0;
            }
            else
            {
              v44 = &v11[v43];
              if (v25)
                v44 = v25;
              v45 = v44 + 2;
              v46 = 0.0;
              v47 = v42;
              v48 = v19;
              v49 = result;
              v50 = 0.0;
              v51 = 0.0;
              v52 = 0.0;
              do
              {
                v53 = *v49++;
                LOBYTE(v6) = *(v47 - 1);
                *(double *)&v54 = (double)*(unint64_t *)&v6 - *(v45 - 2);
                v52 = v52 + v53 * *(double *)&v54;
                LOBYTE(v54) = *v47;
                *(double *)&v55 = (double)v54 - *(v45 - 1);
                v51 = v51 + v53 * *(double *)&v55;
                LOBYTE(v55) = v47[1];
                *(double *)&v56 = (double)v55 - *v45;
                v50 = v50 + v53 * *(double *)&v56;
                LOBYTE(v56) = v47[2];
                v6 = (double)v56 - v45[1];
                v46 = v46 + v53 * v6;
                v47 += v12;
                v45 = (double *)((char *)v45 + v30);
                --v48;
              }
              while (v48);
            }
            v57 = (double *)(v10 + 8 * v43);
            v5 = v51 * v7;
            *v57 = v52 * v7;
            v57[1] = v5;
            v4 = v46 * v7;
            v57[2] = v50 * v7;
            v57[3] = v4;
            v43 += 4;
            v42 += 4;
          }
          while ((int)v29 >= (int)v43);
          v43 = v43;
        }
        else
        {
          v43 = v28;
        }
        for (; (int)v17 > (int)v43; ++v43)
        {
          if ((int)v19 < 1)
          {
            v59 = 0.0;
          }
          else
          {
            v58 = &v11[v43];
            if (v25)
              v58 = v25;
            v59 = 0.0;
            v60 = v8;
            v61 = v19;
            v62 = result;
            do
            {
              v63 = *v62++;
              LOBYTE(v5) = v60[v43];
              v5 = (double)*(unint64_t *)&v5 - *v58;
              v59 = v59 + v63 * v5;
              v58 = (double *)((char *)v58 + v30);
              v60 += v12;
              --v61;
            }
            while (v61);
          }
          v4 = v59 * v7;
          *(double *)(v10 + 8 * v43) = v4;
        }
        v10 += 8 * v24;
        ++v28;
        ++v33;
        ++v32;
        ++v31;
      }
      while (v28 != v17);
    }
    goto LABEL_53;
  }
  if ((int)v17 >= 1)
  {
    v64 = 0;
    v65 = v17 - 4;
    v66 = v8 + 3;
    v67 = v8;
    do
    {
      v68 = v18;
      v69 = v67;
      v70 = result;
      if ((int)v19 >= 1)
      {
        do
        {
          LOBYTE(v4) = *v69;
          v4 = (double)*(unint64_t *)&v4;
          *v70++ = v4;
          v69 += v12;
          --v68;
        }
        while (v68);
      }
      v71 = v66;
      v72 = v64;
      if (v64 <= v65)
      {
        do
        {
          if ((int)v18 < 1)
          {
            v79 = 0.0;
            v78 = 0.0;
            v77 = 0.0;
            v73 = 0.0;
          }
          else
          {
            v73 = 0.0;
            v74 = v71;
            v75 = v18;
            v76 = result;
            v77 = 0.0;
            v78 = 0.0;
            v79 = 0.0;
            do
            {
              v80 = *v76++;
              LOBYTE(v6) = *(v74 - 3);
              *(double *)&v81 = (double)*(unint64_t *)&v6;
              v79 = v79 + v80 * *(double *)&v81;
              LOBYTE(v81) = *(v74 - 2);
              *(double *)&v82 = (double)v81;
              v78 = v78 + v80 * *(double *)&v82;
              LOBYTE(v82) = *(v74 - 1);
              *(double *)&v83 = (double)v82;
              v77 = v77 + v80 * *(double *)&v83;
              LOBYTE(v83) = *v74;
              v6 = (double)v83;
              v73 = v73 + v80 * v6;
              v74 += v12;
              --v75;
            }
            while (v75);
          }
          v84 = (double *)(v10 + 8 * v72);
          v5 = v78 * v7;
          *v84 = v79 * v7;
          v84[1] = v5;
          v4 = v73 * v7;
          v84[2] = v77 * v7;
          v84[3] = v4;
          v72 += 4;
          v71 += 4;
        }
        while ((int)v65 >= (int)v72);
        v72 = v72;
      }
      else
      {
        v72 = v64;
      }
      for (; (int)v17 > (int)v72; ++v72)
      {
        v85 = 0.0;
        if ((int)v19 >= 1)
        {
          v86 = v8;
          v87 = v18;
          v88 = result;
          do
          {
            v89 = *v88++;
            LOBYTE(v5) = v86[v72];
            v5 = (double)*(unint64_t *)&v5;
            v85 = v85 + v89 * v5;
            v86 += v12;
            --v87;
          }
          while (v87);
        }
        v4 = v85 * v7;
        *(double *)(v10 + 8 * v72) = v4;
      }
      ++v64;
      v10 += 8 * v24;
      ++v67;
      ++v66;
    }
    while (v64 != v17);
  }
LABEL_53:
  if (result != (double *)v90)
    return (double *)MEMORY[0x2207351A4](result, 0x1000C8077774924);
  return result;
}

uint64_t cv::MulTransposedL<unsigned char,double>(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  unsigned __int8 *v11;
  uint64_t v12;
  uint64_t v13;
  double *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  _BOOL4 v23;
  uint64_t v24;
  unsigned __int8 *v25;
  double *v26;
  uint64_t v27;
  double v28;
  uint64_t v29;
  unsigned __int8 *v30;
  double *v31;
  double *v32;
  unsigned int v33;
  double v34;
  double v35;
  unsigned __int8 *v36;
  unsigned __int8 *v37;
  uint64_t v38;
  double *v39;
  int v40;
  double v41;
  uint64_t v42;
  double *v43;
  double v44;
  double v45;
  unint64_t v46;
  double v47;
  double v48;
  unsigned __int8 *v49;
  double *v50;
  double v51;
  double v52;
  double v53;
  unint64_t v54;
  unsigned __int8 *v55;
  unsigned __int8 *v56;
  unsigned __int8 *v57;
  unint64_t v58;
  int v59;
  double v60;
  uint64_t v61;
  unint64_t v62;
  unint64_t v63;
  double v64;
  unint64_t v65;
  unint64_t v66;
  double v67;
  unsigned __int8 *v68;
  unsigned __int8 *v69;
  unsigned int v70;
  unsigned int v71;
  _BYTE v72[4120];
  _QWORD v73[2];
  double v74;
  double v75;
  uint64_t v76;

  result = MEMORY[0x24BDAC7A8](a1, a2);
  v10 = v9;
  v76 = *MEMORY[0x24BDAC8D0];
  v11 = *(unsigned __int8 **)(result + 16);
  v13 = *(_QWORD *)(v12 + 16);
  v14 = *(double **)(v3 + 16);
  v15 = *(_QWORD *)(result + 80);
  v16 = *(_QWORD *)(v12 + 80) >> 3;
  if (*(int *)(v3 + 8) <= 1)
    v17 = 0;
  else
    v17 = *(_QWORD *)(v3 + 80) >> 3;
  v18 = *(unsigned int **)(result + 64);
  v19 = *v18;
  v20 = (int)v18[1];
  v21 = v18[1];
  if (v14)
  {
    v22 = *(_DWORD *)(v3 + 12);
    v23 = v22 == v20;
    result = (uint64_t)v72;
    if ((unint64_t)(8 * v20) >= 0x1009)
    {
      result = operator new[]();
      v23 = v22 == v20;
    }
    if ((int)v19 >= 1)
    {
      v24 = 0;
      v25 = v11 + 3;
      v26 = v14;
      do
      {
        if (v22 >= (int)v21)
        {
          v29 = v21;
          v30 = v11;
          v31 = v26;
          v32 = (double *)result;
          if ((int)v21 >= 1)
          {
            do
            {
              v33 = *v30++;
              v34 = (double)v33;
              v35 = *v31++;
              v4 = v35;
              *v32++ = v34 - v35;
              --v29;
            }
            while (v29);
          }
        }
        else if ((int)v20 >= 1)
        {
          v27 = 0;
          v28 = v14[v17 * v24];
          do
          {
            LOBYTE(v4) = v11[v27];
            v4 = (double)*(unint64_t *)&v4 - v28;
            *(double *)(result + 8 * v27++) = v4;
          }
          while (v21 != v27);
        }
        v36 = v11;
        v37 = v25;
        v38 = v24;
        do
        {
          v39 = &v14[v17 * v38];
          if (v22 < (int)v20)
          {
            v74 = *v39;
            v75 = v74;
            *(double *)v73 = v74;
            *(double *)&v73[1] = v74;
            v39 = (double *)v73;
          }
          if ((int)v21 >= 4)
          {
            v42 = 0;
            v41 = 0.0;
            v43 = (double *)(result + 16);
            do
            {
              LOBYTE(v4) = v37[v42 - 3];
              v44 = *(v43 - 2);
              LOBYTE(v8) = v37[v42 - 2];
              v45 = *(v43 - 1) * ((double)*(unint64_t *)&v8 - v39[1])
                  + v44 * ((double)*(unint64_t *)&v4 - *v39);
              LOBYTE(v44) = v37[v42 - 1];
              *(double *)&v46 = (double)*(unint64_t *)&v44 - v39[2];
              v47 = *v43;
              v8 = v43[1];
              v43 += 4;
              v48 = v45 + v47 * *(double *)&v46;
              LOBYTE(v46) = v37[v42];
              v4 = v48 + v8 * ((double)v46 - v39[3]);
              v41 = v41 + v4;
              v42 += 4;
              v39 += 4 * v23;
            }
            while (v42 <= (int)v21 - 4);
            v40 = ((v21 - 4) & 0xFFFFFFFC) + 4;
          }
          else
          {
            v40 = 0;
            v41 = 0.0;
          }
          if (v40 < (int)v20)
          {
            v49 = &v36[v40];
            v50 = (double *)(result + 8 * v40);
            do
            {
              v51 = *v50++;
              v4 = v51;
              LODWORD(v51) = *v49++;
              v52 = (double)LODWORD(v51);
              v53 = *v39++;
              v41 = v41 + v4 * (v52 - v53);
              ++v40;
            }
            while ((int)v20 > v40);
          }
          *(double *)(v13 + 8 * v38++) = v41 * v10;
          v37 += v15;
          v36 += v15;
        }
        while (v38 != v19);
        v13 += 8 * v16;
        ++v24;
        v26 += v17;
        v11 += v15;
        v25 += v15;
      }
      while (v24 != v19);
    }
    if ((_BYTE *)result != v72)
      return MEMORY[0x2207351A4](result, 0x1000C8077774924);
  }
  else if ((int)v19 >= 1)
  {
    v54 = 0;
    v55 = v11 + 1;
    do
    {
      v56 = v11;
      v57 = v55;
      v58 = v54;
      do
      {
        if ((int)v20 >= 4)
        {
          v61 = 0;
          v60 = 0.0;
          do
          {
            LOBYTE(v4) = v55[v61 - 1];
            LOBYTE(v5) = v57[v61 - 1];
            LOBYTE(v6) = v55[v61];
            *(double *)&v62 = (double)*(unint64_t *)&v5;
            LOBYTE(v7) = v57[v61];
            v7 = (double)*(unint64_t *)&v7;
            *(double *)&v63 = (double)*(unint64_t *)&v6 * v7;
            v64 = *(double *)&v63 + (double)*(unint64_t *)&v4 * *(double *)&v62;
            LOBYTE(v62) = v55[v61 + 1];
            *(double *)&v65 = (double)v62;
            LOBYTE(v63) = v57[v61 + 1];
            *(double *)&v66 = (double)v63;
            v67 = v64 + *(double *)&v65 * *(double *)&v66;
            LOBYTE(v65) = v55[v61 + 2];
            v5 = (double)v65;
            LOBYTE(v66) = v57[v61 + 2];
            v6 = (double)v66;
            v4 = v67 + v5 * v6;
            v60 = v60 + v4;
            v61 += 4;
          }
          while (v61 <= (int)v21 - 4);
          v59 = ((v21 - 4) & 0xFFFFFFFC) + 4;
        }
        else
        {
          v59 = 0;
          v60 = 0.0;
        }
        if (v59 < (int)v21)
        {
          v68 = &v56[v59];
          v69 = &v11[v59];
          do
          {
            v70 = *v69++;
            v4 = (double)v70;
            v71 = *v68++;
            result = v71;
            v5 = (double)v71;
            v60 = v60 + v4 * (double)v71;
            ++v59;
          }
          while ((int)v21 > v59);
        }
        *(double *)(v13 + 8 * v58++) = v60 * v10;
        v57 += v15;
        v56 += v15;
      }
      while (v58 < v19);
      ++v54;
      v13 += 8 * v16;
      v55 += v15;
      v11 += v15;
    }
    while (v54 != v19);
  }
  return result;
}

_QWORD *cv::MulTransposedR<unsigned short,float>(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  uint64_t v3;
  float32x4_t v4;
  double v5;
  double v6;
  uint16x4_t *v7;
  uint64_t v8;
  uint64_t v9;
  const float *v10;
  unint64_t v11;
  unint64_t v12;
  int v13;
  uint64_t v14;
  unsigned int *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  char v20;
  unsigned int v21;
  _QWORD *result;
  unint64_t v23;
  unint64_t v24;
  float32x4_t *v25;
  uint64_t v26;
  uint64_t v27;
  float32x4_t *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  float *v33;
  uint16x4_t *v34;
  uint64_t v35;
  __int16 *v36;
  float *v37;
  _DWORD *v38;
  uint64_t v39;
  __int16 *v40;
  float *v41;
  _DWORD *v42;
  uint16x4_t *v43;
  uint64_t v44;
  float32x4_t *v45;
  float64x2_t v46;
  uint16x4_t *v47;
  uint64_t v48;
  float *v49;
  float64x2_t v50;
  float v51;
  float32x4_t v52;
  _WORD *v53;
  float *v54;
  double v55;
  _WORD *v56;
  uint64_t v57;
  float *v58;
  float v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint16x4_t *v63;
  uint64_t v64;
  __int16 *v65;
  _DWORD *v66;
  uint16x4_t *v67;
  uint64_t v68;
  float64x2_t v69;
  uint16x4_t *v70;
  uint64_t v71;
  float *v72;
  float64x2_t v73;
  float v74;
  uint32x4_t v75;
  uint64x2_t v76;
  float64x2_t v77;
  _WORD *v78;
  double v79;
  _WORD *v80;
  uint64_t v81;
  float *v82;
  float v83;
  double v84;
  _QWORD v85[517];

  v2 = (_QWORD *)MEMORY[0x24BDAC7A8](a1, a2);
  v6 = *(double *)v4.i64;
  v85[515] = *MEMORY[0x24BDAC8D0];
  v7 = (uint16x4_t *)v2[2];
  v9 = *(_QWORD *)(v8 + 16);
  v10 = *(const float **)(v3 + 16);
  v11 = v2[10];
  v12 = *(_QWORD *)(v8 + 80);
  v13 = *(_DWORD *)(v3 + 12);
  if (*(int *)(v3 + 8) <= 1)
    v14 = 0;
  else
    v14 = *(_QWORD *)(v3 + 80) >> 2;
  v15 = (unsigned int *)v2[8];
  v17 = (int)*v15;
  v16 = (int)v15[1];
  v18 = *v15;
  if (v10)
    v19 = v13 < (int)v16;
  else
    v19 = 0;
  v20 = !v19;
  if (v19)
  {
    if (v13 != 1)
      __assert_rtn("MulTransposedR", "matmul.cpp", 2360, "delta_cols == 1");
    v21 = 20 * v18;
  }
  else
  {
    v21 = 4 * v17;
  }
  result = v85;
  if (v21 >= 0x1009)
  {
    v84 = *(double *)v4.i64;
    result = (_QWORD *)operator new[]();
    v6 = v84;
  }
  v23 = v11 >> 1;
  v24 = v12 >> 2;
  if ((v20 & 1) == 0)
  {
    v25 = (float32x4_t *)((char *)result + 4 * v17);
    if ((int)v17 >= 1)
    {
      v27 = v18;
      v28 = (float32x4_t *)((char *)result + 4 * v17);
      do
      {
        v4 = vld1q_dup_f32(v10);
        v26 = 4 * v14;
        v10 = (const float *)((char *)v10 + v26);
        *v28++ = v4;
        --v27;
      }
      while (v27);
    }
    v14 = 4 * (v14 != 0);
    v10 = (const float *)result + v17;
    goto LABEL_23;
  }
  if (v10)
  {
    v25 = 0;
LABEL_23:
    if ((int)v16 >= 1)
    {
      v29 = 0;
      v30 = v16 - 4;
      v31 = 4 * v14;
      v32 = 2 * v23;
      v33 = (float *)v10;
      v34 = v7;
      do
      {
        if (v25)
        {
          v35 = v18;
          v36 = (__int16 *)v34;
          v37 = (float *)v25;
          v38 = result;
          if ((int)v17 >= 1)
          {
            do
            {
              v4.i16[0] = *v36;
              v4.f32[0] = (float)v4.u32[0] - *v37;
              *v38++ = v4.i32[0];
              v37 = (float *)((char *)v37 + v31);
              v36 = (__int16 *)((char *)v36 + v32);
              --v35;
            }
            while (v35);
          }
        }
        else if ((int)v18 >= 1)
        {
          v39 = v18;
          v40 = (__int16 *)v34;
          v41 = v33;
          v42 = result;
          do
          {
            v4.i16[0] = *v40;
            v4.f32[0] = (float)v4.u32[0] - *v41;
            *v42++ = v4.i32[0];
            v41 = (float *)((char *)v41 + v31);
            v40 = (__int16 *)((char *)v40 + v32);
            --v39;
          }
          while (v39);
        }
        v43 = v34;
        v44 = v29;
        if (v29 <= v30)
        {
          do
          {
            if ((int)v17 < 1)
            {
              v46 = 0uLL;
              v50 = 0uLL;
            }
            else
            {
              v45 = (float32x4_t *)&v10[v44];
              if (v25)
                v45 = v25;
              v46 = 0uLL;
              v47 = v43;
              v48 = v18;
              v49 = (float *)result;
              v50 = 0uLL;
              do
              {
                v51 = *v49++;
                v5 = v51;
                v52 = vsubq_f32(vcvtq_f32_u32(vmovl_u16(*v47)), *v45);
                v50 = vmlaq_n_f64(v50, vcvt_hight_f64_f32(v52), v51);
                v46 = vmlaq_n_f64(v46, vcvtq_f64_f32(*(float32x2_t *)v52.f32), v51);
                v45 = (float32x4_t *)((char *)v45 + v31);
                v47 = (uint16x4_t *)((char *)v47 + v32);
                --v48;
              }
              while (v48);
            }
            v4 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmulq_n_f64(v46, v6)), vmulq_n_f64(v50, v6));
            *(float32x4_t *)(v9 + 4 * v44) = v4;
            v44 += 4;
            ++v43;
          }
          while ((int)v30 >= (int)v44);
          v44 = v44;
        }
        else
        {
          v44 = v29;
        }
        if ((int)v44 < (int)v16)
        {
          v53 = (_WORD *)v7 + v44;
          do
          {
            if ((int)v18 < 1)
            {
              v55 = 0.0;
            }
            else
            {
              v54 = (float *)&v10[v44];
              if (v25)
                v54 = (float *)v25;
              v55 = 0.0;
              v56 = v53;
              v57 = v18;
              v58 = (float *)result;
              do
              {
                v59 = *v58++;
                LOWORD(v5) = *v56;
                v5 = (float)((float)LODWORD(v5) - *v54);
                v55 = v55 + v59 * v5;
                v54 = (float *)((char *)v54 + v31);
                v56 = (_WORD *)((char *)v56 + v32);
                --v57;
              }
              while (v57);
            }
            v4.f32[0] = v55 * v6;
            *(_DWORD *)(v9 + 4 * v44++) = v4.i32[0];
            ++v53;
          }
          while ((int)v16 > (int)v44);
        }
        ++v29;
        v9 += 4 * v24;
        v34 = (uint16x4_t *)((char *)v34 + 2);
        ++v33;
      }
      while (v29 != v16);
    }
    goto LABEL_54;
  }
  if ((int)v16 >= 1)
  {
    v60 = 0;
    v61 = v16 - 4;
    v62 = 2 * v23;
    v63 = v7;
    do
    {
      v64 = v17;
      v65 = (__int16 *)v63;
      v66 = result;
      if ((int)v18 >= 1)
      {
        do
        {
          v4.i16[0] = *v65;
          v4.f32[0] = (float)v4.u32[0];
          *v66++ = v4.i32[0];
          v65 = (__int16 *)((char *)v65 + v62);
          --v64;
        }
        while (v64);
      }
      v67 = v63;
      v68 = v60;
      if (v60 <= v61)
      {
        do
        {
          v69 = 0uLL;
          if ((int)v17 < 1)
          {
            v73 = 0uLL;
          }
          else
          {
            v70 = v67;
            v71 = v17;
            v72 = (float *)result;
            v73 = 0uLL;
            do
            {
              v74 = *v72++;
              v5 = v74;
              v75 = vmovl_u16(*v70);
              v76.i64[0] = v75.u32[0];
              v76.i64[1] = v75.u32[1];
              v77 = vcvtq_f64_u64(v76);
              v76.i64[0] = v75.u32[2];
              v76.i64[1] = v75.u32[3];
              v73 = vmlaq_n_f64(v73, vcvtq_f64_u64(v76), v74);
              v69 = vmlaq_n_f64(v69, v77, v74);
              v70 = (uint16x4_t *)((char *)v70 + v62);
              --v71;
            }
            while (v71);
          }
          v4 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmulq_n_f64(v69, v6)), vmulq_n_f64(v73, v6));
          *(float32x4_t *)(v9 + 4 * v68) = v4;
          v68 += 4;
          ++v67;
        }
        while ((int)v61 >= (int)v68);
        v68 = v68;
      }
      else
      {
        v68 = v60;
      }
      if ((int)v68 < (int)v16)
      {
        v78 = (_WORD *)v7 + v68;
        do
        {
          v79 = 0.0;
          if ((int)v18 >= 1)
          {
            v80 = v78;
            v81 = v17;
            v82 = (float *)result;
            do
            {
              v83 = *v82++;
              LOWORD(v5) = *v80;
              v5 = (double)*(unint64_t *)&v5;
              v79 = v79 + v83 * v5;
              v80 = (_WORD *)((char *)v80 + v62);
              --v81;
            }
            while (v81);
          }
          v4.f32[0] = v79 * v6;
          *(_DWORD *)(v9 + 4 * v68++) = v4.i32[0];
          ++v78;
        }
        while ((int)v16 > (int)v68);
      }
      ++v60;
      v9 += 4 * v24;
      v63 = (uint16x4_t *)((char *)v63 + 2);
    }
    while (v60 != v16);
  }
LABEL_54:
  if (result != v85)
    return (_QWORD *)MEMORY[0x2207351A4](result, 0x1000C8077774924);
  return result;
}

unsigned __int16 *cv::MulTransposedL<unsigned short,float>(uint64_t a1, uint64_t a2)
{
  unsigned __int16 *result;
  uint64_t v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  unsigned __int16 *v10;
  uint64_t v11;
  uint64_t v12;
  float *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int *v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  _BOOL4 v22;
  uint64_t v23;
  uint64_t v24;
  unsigned __int16 *v25;
  float *v26;
  uint64_t v27;
  float v28;
  uint64_t v29;
  unsigned __int16 *v30;
  float *v31;
  float *v32;
  unsigned int v33;
  float v34;
  float v35;
  unsigned __int16 *v36;
  unsigned __int16 *v37;
  uint64_t v38;
  float32x4_t *v39;
  float32x4_t v40;
  int v41;
  double v42;
  uint64_t v43;
  unsigned __int16 *v44;
  float *v45;
  float v46;
  double v47;
  double v48;
  float v49;
  float v50;
  double v51;
  double v52;
  unsigned __int16 *v53;
  float *v54;
  float v55;
  float v56;
  unsigned int v57;
  float v58;
  float v59;
  float v60;
  unint64_t v61;
  unsigned __int16 *v62;
  uint64_t v63;
  unsigned __int16 *v64;
  _WORD *v65;
  unint64_t v66;
  int v67;
  double v68;
  uint64_t v69;
  _WORD *v70;
  unint64_t v71;
  unint64_t v72;
  double v73;
  unint64_t v74;
  unint64_t v75;
  double v76;
  unsigned __int16 *v77;
  unsigned int v78;
  unsigned int v79;
  float v80;
  uint64_t v81;
  _BYTE v82[4120];
  float32x4_t v83;
  uint64_t v84;

  result = (unsigned __int16 *)MEMORY[0x24BDAC7A8](a1, a2);
  v9 = v8;
  v84 = *MEMORY[0x24BDAC8D0];
  v10 = (unsigned __int16 *)*((_QWORD *)result + 2);
  v12 = *(_QWORD *)(v11 + 16);
  v13 = *(float **)(v3 + 16);
  v14 = *((_QWORD *)result + 10) >> 1;
  v15 = *(_QWORD *)(v11 + 80) >> 2;
  if (*(int *)(v3 + 8) <= 1)
    v16 = 0;
  else
    v16 = *(_QWORD *)(v3 + 80) >> 2;
  v17 = (unsigned int *)*((_QWORD *)result + 8);
  v18 = *v17;
  v19 = (int)v17[1];
  v20 = v17[1];
  if (v13)
  {
    v21 = *(_DWORD *)(v3 + 12);
    v22 = v21 == v19;
    result = (unsigned __int16 *)v82;
    if ((unint64_t)(4 * v19) >= 0x1009)
    {
      v81 = v14;
      result = (unsigned __int16 *)operator new[]();
      v22 = v21 == v19;
      v14 = v81;
    }
    if ((int)v18 >= 1)
    {
      v23 = 0;
      v24 = 2 * v14;
      v25 = v10 + 2;
      v26 = v13;
      do
      {
        if (v21 >= (int)v20)
        {
          v29 = v20;
          v30 = v10;
          v31 = v26;
          v32 = (float *)result;
          if ((int)v20 >= 1)
          {
            do
            {
              v33 = *v30++;
              v34 = (float)v33;
              v35 = *v31++;
              WORD1(v4) = HIWORD(v35);
              *v32++ = v34 - v35;
              --v29;
            }
            while (v29);
          }
        }
        else if ((int)v19 >= 1)
        {
          v27 = 0;
          v28 = v13[v16 * v23];
          do
          {
            LOWORD(v4) = v10[v27];
            *(float *)&v4 = (float)LODWORD(v4) - v28;
            *(_DWORD *)&result[2 * v27++] = LODWORD(v4);
          }
          while (v20 != v27);
        }
        v36 = v10;
        v37 = v25;
        v38 = v23;
        do
        {
          v39 = (float32x4_t *)&v13[v16 * v38];
          if (v21 < (int)v19)
          {
            v40 = vld1q_dup_f32(v39->f32);
            v83 = v40;
            v39 = &v83;
          }
          if ((int)v20 >= 4)
          {
            v43 = 0;
            v42 = 0.0;
            v44 = v37;
            v45 = (float *)(result + 4);
            do
            {
              LOWORD(v6) = *(v44 - 2);
              v46 = v39->f32[0];
              LOWORD(v46) = *(v44 - 1);
              v47 = *(v45 - 1) * (float)((float)LODWORD(v46) - v39->f32[1]);
              v48 = v47 + *(v45 - 2) * (float)((float)LODWORD(v6) - v39->f32[0]);
              LOWORD(v47) = *v44;
              v49 = *v45;
              v50 = v45[1];
              v45 += 4;
              v51 = v49;
              v52 = v48 + v51 * (float)((float)LODWORD(v47) - v39->f32[2]);
              LOWORD(v51) = v44[1];
              v6 = (float)((float)LODWORD(v51) - v39->f32[3]);
              v4 = v52 + v50 * v6;
              v43 += 4;
              v42 = v42 + v4;
              v39 += v22;
              v44 += 4;
            }
            while (v43 <= (int)v20 - 4);
            v41 = ((v20 - 4) & 0xFFFFFFFC) + 4;
          }
          else
          {
            v41 = 0;
            v42 = 0.0;
          }
          if (v41 < (int)v19)
          {
            v53 = &v36[v41];
            v54 = (float *)&result[2 * v41];
            do
            {
              v55 = *v54++;
              v56 = v55;
              v57 = *v53++;
              v58 = (float)v57;
              v59 = v39->f32[0];
              v39 = (float32x4_t *)((char *)v39 + 4);
              WORD1(v6) = HIWORD(v59);
              v4 = v56;
              v42 = v42 + v4 * (float)(v58 - v59);
              ++v41;
            }
            while ((int)v19 > v41);
          }
          v60 = v42 * v9;
          *(float *)(v12 + 4 * v38++) = v60;
          v37 = (unsigned __int16 *)((char *)v37 + v24);
          v36 = (unsigned __int16 *)((char *)v36 + v24);
        }
        while (v38 != v18);
        v12 += 4 * v15;
        ++v23;
        v26 += v16;
        v10 = (unsigned __int16 *)((char *)v10 + v24);
        v25 = (unsigned __int16 *)((char *)v25 + v24);
      }
      while (v23 != v18);
    }
    if (result != (unsigned __int16 *)v82)
      return (unsigned __int16 *)MEMORY[0x2207351A4](result, 0x1000C8077774924);
  }
  else if ((int)v18 >= 1)
  {
    v61 = 0;
    v62 = v10 + 2;
    v63 = 2 * v14;
    do
    {
      v64 = v10;
      v65 = v62;
      v66 = v61;
      do
      {
        if ((int)v19 >= 4)
        {
          v69 = 0;
          v68 = 0.0;
          v70 = v65;
          result = v62;
          do
          {
            LOWORD(v4) = *(result - 2);
            LOWORD(v5) = *(v70 - 2);
            *(double *)&v71 = (double)*(unint64_t *)&v5;
            LOWORD(v6) = *(result - 1);
            LOWORD(v7) = *(v70 - 1);
            v7 = (double)*(unint64_t *)&v7;
            *(double *)&v72 = (double)*(unint64_t *)&v6 * v7;
            v73 = *(double *)&v72 + (double)*(unint64_t *)&v4 * *(double *)&v71;
            LOWORD(v71) = *result;
            LOWORD(v72) = *v70;
            *(double *)&v74 = (double)v71;
            *(double *)&v75 = (double)v72;
            v76 = v73 + *(double *)&v74 * *(double *)&v75;
            LOWORD(v74) = result[1];
            v5 = (double)v74;
            LOWORD(v75) = v70[1];
            v6 = (double)v75;
            v4 = v76 + v5 * v6;
            v68 = v68 + v4;
            v69 += 4;
            result += 4;
            v70 += 4;
          }
          while (v69 <= (int)v20 - 4);
          v67 = ((v20 - 4) & 0xFFFFFFFC) + 4;
        }
        else
        {
          v67 = 0;
          v68 = 0.0;
        }
        if (v67 < (int)v20)
        {
          v77 = &v64[v67];
          result = &v10[v67];
          do
          {
            v78 = *result++;
            v4 = (double)v78;
            v79 = *v77++;
            v5 = (double)v79;
            v68 = v68 + v4 * (double)v79;
            ++v67;
          }
          while ((int)v20 > v67);
        }
        v80 = v68 * v9;
        *(float *)(v12 + 4 * v66++) = v80;
        v65 = (_WORD *)((char *)v65 + v63);
        v64 = (unsigned __int16 *)((char *)v64 + v63);
      }
      while (v66 < v18);
      ++v61;
      v12 += 4 * v15;
      v62 = (unsigned __int16 *)((char *)v62 + v63);
      v10 = (unsigned __int16 *)((char *)v10 + v63);
    }
    while (v61 != v18);
  }
  return result;
}

double *cv::MulTransposedR<unsigned short,double>(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  uint64_t v3;
  double v4;
  double v5;
  double v6;
  double v7;
  _WORD *v8;
  uint64_t v9;
  uint64_t v10;
  double *v11;
  unint64_t v12;
  unint64_t v13;
  int v14;
  uint64_t v15;
  unsigned int *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  BOOL v20;
  char v21;
  unsigned int v22;
  double *result;
  unint64_t v24;
  unint64_t v25;
  double *v26;
  double *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _WORD *v33;
  double *v34;
  _WORD *v35;
  uint64_t v36;
  _WORD *v37;
  double *v38;
  double *v39;
  uint64_t v40;
  _WORD *v41;
  double *v42;
  double *v43;
  _WORD *v44;
  uint64_t v45;
  double *v46;
  double *v47;
  double v48;
  _WORD *v49;
  uint64_t v50;
  double *v51;
  double v52;
  double v53;
  double v54;
  double v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  double *v59;
  _WORD *v60;
  double *v61;
  double v62;
  _WORD *v63;
  uint64_t v64;
  double *v65;
  double v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  _WORD *v70;
  _WORD *v71;
  uint64_t v72;
  _WORD *v73;
  double *v74;
  _WORD *v75;
  uint64_t v76;
  double v77;
  _WORD *v78;
  uint64_t v79;
  double *v80;
  double v81;
  double v82;
  double v83;
  double v84;
  unint64_t v85;
  unint64_t v86;
  unint64_t v87;
  double *v88;
  _WORD *v89;
  double v90;
  _WORD *v91;
  uint64_t v92;
  double *v93;
  double v94;
  _QWORD v95[517];

  v2 = (_QWORD *)MEMORY[0x24BDAC7A8](a1, a2);
  v7 = v4;
  v95[515] = *MEMORY[0x24BDAC8D0];
  v8 = (_WORD *)v2[2];
  v10 = *(_QWORD *)(v9 + 16);
  v11 = *(double **)(v3 + 16);
  v12 = v2[10];
  v13 = *(_QWORD *)(v9 + 80);
  v14 = *(_DWORD *)(v3 + 12);
  if (*(int *)(v3 + 8) <= 1)
    v15 = 0;
  else
    v15 = *(_QWORD *)(v3 + 80) >> 3;
  v16 = (unsigned int *)v2[8];
  v18 = (int)*v16;
  v17 = (int)v16[1];
  v19 = *v16;
  if (v11)
    v20 = v14 < (int)v17;
  else
    v20 = 0;
  v21 = !v20;
  if (v20)
  {
    if (v14 != 1)
      __assert_rtn("MulTransposedR", "matmul.cpp", 2360, "delta_cols == 1");
    v22 = 40 * v19;
  }
  else
  {
    v22 = 8 * v18;
  }
  result = (double *)v95;
  if (v22 >= 0x1009)
    result = (double *)operator new[]();
  v24 = v12 >> 1;
  v25 = v13 >> 3;
  if ((v21 & 1) == 0)
  {
    v26 = &result[v18];
    if ((int)v18 >= 1)
    {
      v27 = v26 + 2;
      v28 = v19;
      do
      {
        v4 = *v11;
        *v27 = *v11;
        v27[1] = v4;
        *(v27 - 2) = v4;
        *(v27 - 1) = v4;
        v11 += v15;
        v27 += 4;
        --v28;
      }
      while (v28);
    }
    v15 = 4 * (v15 != 0);
    v11 = &result[v18];
    goto LABEL_23;
  }
  if (v11)
  {
    v26 = 0;
LABEL_23:
    if ((int)v17 >= 1)
    {
      v29 = 0;
      v30 = v17 - 4;
      v31 = 8 * v15;
      v32 = 2 * v24;
      v33 = v8 + 2;
      v34 = v11;
      v35 = v8;
      do
      {
        if (v26)
        {
          v36 = v19;
          v37 = v35;
          v38 = v26;
          v39 = result;
          if ((int)v18 >= 1)
          {
            do
            {
              LOWORD(v4) = *v37;
              v4 = (double)*(unint64_t *)&v4 - *v38;
              *v39++ = v4;
              v38 = (double *)((char *)v38 + v31);
              v37 = (_WORD *)((char *)v37 + v32);
              --v36;
            }
            while (v36);
          }
        }
        else if ((int)v19 >= 1)
        {
          v40 = v19;
          v41 = v35;
          v42 = v34;
          v43 = result;
          do
          {
            LOWORD(v4) = *v41;
            v4 = (double)*(unint64_t *)&v4 - *v42;
            *v43++ = v4;
            v42 = (double *)((char *)v42 + v31);
            v41 = (_WORD *)((char *)v41 + v32);
            --v40;
          }
          while (v40);
        }
        v44 = v33;
        v45 = v29;
        if (v29 <= v30)
        {
          do
          {
            if ((int)v18 < 1)
            {
              v54 = 0.0;
              v53 = 0.0;
              v52 = 0.0;
              v48 = 0.0;
            }
            else
            {
              v46 = &v11[v45];
              if (v26)
                v46 = v26;
              v47 = v46 + 2;
              v48 = 0.0;
              v49 = v44;
              v50 = v19;
              v51 = result;
              v52 = 0.0;
              v53 = 0.0;
              v54 = 0.0;
              do
              {
                v55 = *v51++;
                LOWORD(v6) = *(v49 - 2);
                *(double *)&v56 = (double)*(unint64_t *)&v6 - *(v47 - 2);
                v54 = v54 + v55 * *(double *)&v56;
                LOWORD(v56) = *(v49 - 1);
                *(double *)&v57 = (double)v56 - *(v47 - 1);
                v53 = v53 + v55 * *(double *)&v57;
                LOWORD(v57) = *v49;
                *(double *)&v58 = (double)v57 - *v47;
                v52 = v52 + v55 * *(double *)&v58;
                LOWORD(v58) = v49[1];
                v6 = (double)v58 - v47[1];
                v48 = v48 + v55 * v6;
                v49 = (_WORD *)((char *)v49 + v32);
                v47 = (double *)((char *)v47 + v31);
                --v50;
              }
              while (v50);
            }
            v59 = (double *)(v10 + 8 * v45);
            v5 = v53 * v7;
            *v59 = v54 * v7;
            v59[1] = v5;
            v4 = v48 * v7;
            v59[2] = v52 * v7;
            v59[3] = v4;
            v45 += 4;
            v44 += 4;
          }
          while ((int)v30 >= (int)v45);
          v45 = v45;
        }
        else
        {
          v45 = v29;
        }
        if ((int)v45 < (int)v17)
        {
          v60 = &v8[v45];
          do
          {
            if ((int)v19 < 1)
            {
              v62 = 0.0;
            }
            else
            {
              v61 = &v11[v45];
              if (v26)
                v61 = v26;
              v62 = 0.0;
              v63 = v60;
              v64 = v19;
              v65 = result;
              do
              {
                v66 = *v65++;
                LOWORD(v5) = *v63;
                v5 = (double)*(unint64_t *)&v5 - *v61;
                v62 = v62 + v66 * v5;
                v61 = (double *)((char *)v61 + v31);
                v63 = (_WORD *)((char *)v63 + v32);
                --v64;
              }
              while (v64);
            }
            v4 = v62 * v7;
            *(double *)(v10 + 8 * v45++) = v4;
            ++v60;
          }
          while ((int)v17 > (int)v45);
        }
        v10 += 8 * v25;
        ++v29;
        ++v35;
        ++v34;
        ++v33;
      }
      while (v29 != v17);
    }
    goto LABEL_54;
  }
  if ((int)v17 >= 1)
  {
    v67 = 0;
    v68 = v17 - 4;
    v69 = 2 * v24;
    v70 = v8 + 2;
    v71 = v8;
    do
    {
      v72 = v18;
      v73 = v71;
      v74 = result;
      if ((int)v19 >= 1)
      {
        do
        {
          LOWORD(v4) = *v73;
          v4 = (double)*(unint64_t *)&v4;
          *v74++ = v4;
          v73 = (_WORD *)((char *)v73 + v69);
          --v72;
        }
        while (v72);
      }
      v75 = v70;
      v76 = v67;
      if (v67 <= v68)
      {
        do
        {
          if ((int)v18 < 1)
          {
            v83 = 0.0;
            v82 = 0.0;
            v81 = 0.0;
            v77 = 0.0;
          }
          else
          {
            v77 = 0.0;
            v78 = v75;
            v79 = v18;
            v80 = result;
            v81 = 0.0;
            v82 = 0.0;
            v83 = 0.0;
            do
            {
              v84 = *v80++;
              LOWORD(v6) = *(v78 - 2);
              *(double *)&v85 = (double)*(unint64_t *)&v6;
              v83 = v83 + v84 * *(double *)&v85;
              LOWORD(v85) = *(v78 - 1);
              *(double *)&v86 = (double)v85;
              v82 = v82 + v84 * *(double *)&v86;
              LOWORD(v86) = *v78;
              *(double *)&v87 = (double)v86;
              v81 = v81 + v84 * *(double *)&v87;
              LOWORD(v87) = v78[1];
              v6 = (double)v87;
              v77 = v77 + v84 * v6;
              v78 = (_WORD *)((char *)v78 + v69);
              --v79;
            }
            while (v79);
          }
          v88 = (double *)(v10 + 8 * v76);
          v5 = v82 * v7;
          *v88 = v83 * v7;
          v88[1] = v5;
          v4 = v77 * v7;
          v88[2] = v81 * v7;
          v88[3] = v4;
          v76 += 4;
          v75 += 4;
        }
        while ((int)v68 >= (int)v76);
        v76 = v76;
      }
      else
      {
        v76 = v67;
      }
      if ((int)v76 < (int)v17)
      {
        v89 = &v8[v76];
        do
        {
          v90 = 0.0;
          if ((int)v19 >= 1)
          {
            v91 = v89;
            v92 = v18;
            v93 = result;
            do
            {
              v94 = *v93++;
              LOWORD(v5) = *v91;
              v5 = (double)*(unint64_t *)&v5;
              v90 = v90 + v94 * v5;
              v91 = (_WORD *)((char *)v91 + v69);
              --v92;
            }
            while (v92);
          }
          v4 = v90 * v7;
          *(double *)(v10 + 8 * v76++) = v4;
          ++v89;
        }
        while ((int)v17 > (int)v76);
      }
      ++v67;
      v10 += 8 * v25;
      ++v71;
      ++v70;
    }
    while (v67 != v17);
  }
LABEL_54:
  if (result != (double *)v95)
    return (double *)MEMORY[0x2207351A4](result, 0x1000C8077774924);
  return result;
}

unsigned __int16 *cv::MulTransposedL<unsigned short,double>(uint64_t a1, uint64_t a2)
{
  unsigned __int16 *result;
  uint64_t v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  unsigned __int16 *v11;
  uint64_t v12;
  uint64_t v13;
  double *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  _BOOL4 v23;
  uint64_t v24;
  uint64_t v25;
  unsigned __int16 *v26;
  double *v27;
  uint64_t v28;
  double v29;
  uint64_t v30;
  unsigned __int16 *v31;
  double *v32;
  double *v33;
  unsigned int v34;
  double v35;
  double v36;
  unsigned __int16 *v37;
  unsigned __int16 *v38;
  uint64_t v39;
  double *v40;
  int v41;
  double v42;
  uint64_t v43;
  unsigned __int16 *v44;
  double *v45;
  unint64_t v46;
  double v47;
  unint64_t v48;
  double v49;
  double v50;
  unsigned __int16 *v51;
  double *v52;
  double v53;
  double v54;
  double v55;
  unint64_t v56;
  unsigned __int16 *v57;
  uint64_t v58;
  unsigned __int16 *v59;
  _WORD *v60;
  unint64_t v61;
  int v62;
  double v63;
  uint64_t v64;
  _WORD *v65;
  unint64_t v66;
  unint64_t v67;
  double v68;
  unint64_t v69;
  unint64_t v70;
  double v71;
  unsigned __int16 *v72;
  unsigned int v73;
  unsigned int v74;
  uint64_t v75;
  _BYTE v76[4120];
  _QWORD v77[2];
  double v78;
  double v79;
  uint64_t v80;

  result = (unsigned __int16 *)MEMORY[0x24BDAC7A8](a1, a2);
  v10 = v9;
  v80 = *MEMORY[0x24BDAC8D0];
  v11 = (unsigned __int16 *)*((_QWORD *)result + 2);
  v13 = *(_QWORD *)(v12 + 16);
  v14 = *(double **)(v3 + 16);
  v15 = *((_QWORD *)result + 10) >> 1;
  v16 = *(_QWORD *)(v12 + 80) >> 3;
  if (*(int *)(v3 + 8) <= 1)
    v17 = 0;
  else
    v17 = *(_QWORD *)(v3 + 80) >> 3;
  v18 = (unsigned int *)*((_QWORD *)result + 8);
  v19 = *v18;
  v20 = (int)v18[1];
  v21 = v18[1];
  if (v14)
  {
    v22 = *(_DWORD *)(v3 + 12);
    v23 = v22 == v20;
    result = (unsigned __int16 *)v76;
    if ((unint64_t)(8 * v20) >= 0x1009)
    {
      v75 = v15;
      result = (unsigned __int16 *)operator new[]();
      v23 = v22 == v20;
      v15 = v75;
    }
    if ((int)v19 >= 1)
    {
      v24 = 0;
      v25 = 2 * v15;
      v26 = v11 + 2;
      v27 = v14;
      do
      {
        if (v22 >= (int)v21)
        {
          v30 = v21;
          v31 = v11;
          v32 = v27;
          v33 = (double *)result;
          if ((int)v21 >= 1)
          {
            do
            {
              v34 = *v31++;
              v35 = (double)v34;
              v36 = *v32++;
              v4 = v36;
              *v33++ = v35 - v36;
              --v30;
            }
            while (v30);
          }
        }
        else if ((int)v20 >= 1)
        {
          v28 = 0;
          v29 = v14[v17 * v24];
          do
          {
            LOWORD(v4) = v11[v28];
            v4 = (double)*(unint64_t *)&v4 - v29;
            *(double *)&result[4 * v28++] = v4;
          }
          while (v21 != v28);
        }
        v37 = v11;
        v38 = v26;
        v39 = v24;
        do
        {
          v40 = &v14[v17 * v39];
          if (v22 < (int)v20)
          {
            v78 = *v40;
            v79 = v78;
            *(double *)v77 = v78;
            *(double *)&v77[1] = v78;
            v40 = (double *)v77;
          }
          if ((int)v21 >= 4)
          {
            v43 = 0;
            v42 = 0.0;
            v44 = v38;
            v45 = (double *)(result + 8);
            do
            {
              LOWORD(v4) = *(v44 - 2);
              LOWORD(v8) = *(v44 - 1);
              *(double *)&v46 = *(v45 - 1) * ((double)*(unint64_t *)&v8 - v40[1]);
              v47 = *(double *)&v46 + *(v45 - 2) * ((double)*(unint64_t *)&v4 - *v40);
              LOWORD(v46) = *v44;
              *(double *)&v48 = (double)v46 - v40[2];
              v49 = *v45;
              v8 = v45[1];
              v45 += 4;
              v50 = v47 + v49 * *(double *)&v48;
              LOWORD(v48) = v44[1];
              v4 = v50 + v8 * ((double)v48 - v40[3]);
              v43 += 4;
              v42 = v42 + v4;
              v40 += 4 * v23;
              v44 += 4;
            }
            while (v43 <= (int)v21 - 4);
            v41 = ((v21 - 4) & 0xFFFFFFFC) + 4;
          }
          else
          {
            v41 = 0;
            v42 = 0.0;
          }
          if (v41 < (int)v20)
          {
            v51 = &v37[v41];
            v52 = (double *)&result[4 * v41];
            do
            {
              v53 = *v52++;
              v4 = v53;
              LODWORD(v53) = *v51++;
              v54 = (double)LODWORD(v53);
              v55 = *v40++;
              v42 = v42 + v4 * (v54 - v55);
              ++v41;
            }
            while ((int)v20 > v41);
          }
          *(double *)(v13 + 8 * v39++) = v42 * v10;
          v38 = (unsigned __int16 *)((char *)v38 + v25);
          v37 = (unsigned __int16 *)((char *)v37 + v25);
        }
        while (v39 != v19);
        v13 += 8 * v16;
        ++v24;
        v27 += v17;
        v11 = (unsigned __int16 *)((char *)v11 + v25);
        v26 = (unsigned __int16 *)((char *)v26 + v25);
      }
      while (v24 != v19);
    }
    if (result != (unsigned __int16 *)v76)
      return (unsigned __int16 *)MEMORY[0x2207351A4](result, 0x1000C8077774924);
  }
  else if ((int)v19 >= 1)
  {
    v56 = 0;
    v57 = v11 + 2;
    v58 = 2 * v15;
    do
    {
      v59 = v11;
      v60 = v57;
      v61 = v56;
      do
      {
        if ((int)v20 >= 4)
        {
          v64 = 0;
          v63 = 0.0;
          v65 = v60;
          result = v57;
          do
          {
            LOWORD(v4) = *(result - 2);
            LOWORD(v5) = *(v65 - 2);
            *(double *)&v66 = (double)*(unint64_t *)&v5;
            LOWORD(v6) = *(result - 1);
            LOWORD(v7) = *(v65 - 1);
            v7 = (double)*(unint64_t *)&v7;
            *(double *)&v67 = (double)*(unint64_t *)&v6 * v7;
            v68 = *(double *)&v67 + (double)*(unint64_t *)&v4 * *(double *)&v66;
            LOWORD(v66) = *result;
            LOWORD(v67) = *v65;
            *(double *)&v69 = (double)v66;
            *(double *)&v70 = (double)v67;
            v71 = v68 + *(double *)&v69 * *(double *)&v70;
            LOWORD(v69) = result[1];
            v5 = (double)v69;
            LOWORD(v70) = v65[1];
            v6 = (double)v70;
            v4 = v71 + v5 * v6;
            v63 = v63 + v4;
            v64 += 4;
            result += 4;
            v65 += 4;
          }
          while (v64 <= (int)v21 - 4);
          v62 = ((v21 - 4) & 0xFFFFFFFC) + 4;
        }
        else
        {
          v62 = 0;
          v63 = 0.0;
        }
        if (v62 < (int)v21)
        {
          v72 = &v59[v62];
          result = &v11[v62];
          do
          {
            v73 = *result++;
            v4 = (double)v73;
            v74 = *v72++;
            v5 = (double)v74;
            v63 = v63 + v4 * (double)v74;
            ++v62;
          }
          while ((int)v21 > v62);
        }
        *(double *)(v13 + 8 * v61++) = v63 * v10;
        v60 = (_WORD *)((char *)v60 + v58);
        v59 = (unsigned __int16 *)((char *)v59 + v58);
      }
      while (v61 < v19);
      ++v56;
      v13 += 8 * v16;
      v57 = (unsigned __int16 *)((char *)v57 + v58);
      v11 = (unsigned __int16 *)((char *)v11 + v58);
    }
    while (v56 != v19);
  }
  return result;
}

float *cv::MulTransposedR<short,float>(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  uint64_t v3;
  double v4;
  double v5;
  int16x4_t *v6;
  uint64_t v7;
  uint64_t v8;
  const float *v9;
  unint64_t v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  unsigned int *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  char v19;
  unsigned int v20;
  float *result;
  unint64_t v22;
  unint64_t v23;
  float32x4_t *v24;
  uint64_t v25;
  uint64_t v26;
  float32x4_t *v27;
  float32x4_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  float *v33;
  int16x4_t *v34;
  uint64_t v35;
  int16x4_t *v36;
  float *v37;
  float *v38;
  uint64_t v39;
  int16x4_t *v40;
  float *v41;
  float *v42;
  int16x4_t *v43;
  uint64_t v44;
  float32x4_t *v45;
  float64x2_t v46;
  int16x4_t *v47;
  uint64_t v48;
  float *v49;
  float64x2_t v50;
  float v51;
  float32x4_t v52;
  __int16 *v53;
  float *v54;
  double v55;
  __int16 *v56;
  uint64_t v57;
  float *v58;
  float v59;
  float v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  int16x4_t *v64;
  uint64_t v65;
  int16x4_t *v66;
  float *v67;
  int16x4_t *v68;
  uint64_t v69;
  float64x2_t v70;
  int16x4_t *v71;
  uint64_t v72;
  float *v73;
  float64x2_t v74;
  float v75;
  int32x4_t v76;
  int64x2_t v77;
  float64x2_t v78;
  __int16 *v79;
  double v80;
  __int16 *v81;
  uint64_t v82;
  float *v83;
  float v84;
  float v85;
  double v86;
  _QWORD v87[517];

  v2 = (_QWORD *)MEMORY[0x24BDAC7A8](a1, a2);
  v5 = v4;
  v87[515] = *MEMORY[0x24BDAC8D0];
  v6 = (int16x4_t *)v2[2];
  v8 = *(_QWORD *)(v7 + 16);
  v9 = *(const float **)(v3 + 16);
  v10 = v2[10];
  v11 = *(_QWORD *)(v7 + 80);
  v12 = *(_DWORD *)(v3 + 12);
  if (*(int *)(v3 + 8) <= 1)
    v13 = 0;
  else
    v13 = *(_QWORD *)(v3 + 80) >> 2;
  v14 = (unsigned int *)v2[8];
  v16 = (int)*v14;
  v15 = (int)v14[1];
  v17 = *v14;
  if (v9)
    v18 = v12 < (int)v15;
  else
    v18 = 0;
  v19 = !v18;
  if (v18)
  {
    if (v12 != 1)
      __assert_rtn("MulTransposedR", "matmul.cpp", 2360, "delta_cols == 1");
    v20 = 20 * v17;
  }
  else
  {
    v20 = 4 * v16;
  }
  result = (float *)v87;
  if (v20 >= 0x1009)
  {
    v86 = v4;
    result = (float *)operator new[]();
    v5 = v86;
  }
  v22 = v10 >> 1;
  v23 = v11 >> 2;
  if ((v19 & 1) == 0)
  {
    v24 = (float32x4_t *)&result[v16];
    if ((int)v16 >= 1)
    {
      v26 = v17;
      v27 = (float32x4_t *)&result[v16];
      do
      {
        v28 = vld1q_dup_f32(v9);
        v25 = 4 * v13;
        v9 = (const float *)((char *)v9 + v25);
        *v27++ = v28;
        --v26;
      }
      while (v26);
    }
    v13 = 4 * (v13 != 0);
    v9 = &result[v16];
    goto LABEL_23;
  }
  if (v9)
  {
    v24 = 0;
LABEL_23:
    if ((int)v15 >= 1)
    {
      v29 = 0;
      v30 = v15 - 4;
      v31 = 4 * v13;
      v32 = 2 * v22;
      v33 = (float *)v9;
      v34 = v6;
      do
      {
        if (v24)
        {
          v35 = v17;
          v36 = v34;
          v37 = (float *)v24;
          v38 = result;
          if ((int)v16 >= 1)
          {
            do
            {
              *v38++ = (float)v36->i16[0] - *v37;
              v37 = (float *)((char *)v37 + v31);
              v36 = (int16x4_t *)((char *)v36 + v32);
              --v35;
            }
            while (v35);
          }
        }
        else if ((int)v17 >= 1)
        {
          v39 = v17;
          v40 = v34;
          v41 = v33;
          v42 = result;
          do
          {
            *v42++ = (float)v40->i16[0] - *v41;
            v41 = (float *)((char *)v41 + v31);
            v40 = (int16x4_t *)((char *)v40 + v32);
            --v39;
          }
          while (v39);
        }
        v43 = v34;
        v44 = v29;
        if (v29 <= v30)
        {
          do
          {
            if ((int)v16 < 1)
            {
              v46 = 0uLL;
              v50 = 0uLL;
            }
            else
            {
              v45 = (float32x4_t *)&v9[v44];
              if (v24)
                v45 = v24;
              v46 = 0uLL;
              v47 = v43;
              v48 = v17;
              v49 = result;
              v50 = 0uLL;
              do
              {
                v51 = *v49++;
                v52 = vsubq_f32(vcvtq_f32_s32(vmovl_s16(*v47)), *v45);
                v50 = vmlaq_n_f64(v50, vcvt_hight_f64_f32(v52), v51);
                v46 = vmlaq_n_f64(v46, vcvtq_f64_f32(*(float32x2_t *)v52.f32), v51);
                v45 = (float32x4_t *)((char *)v45 + v31);
                v47 = (int16x4_t *)((char *)v47 + v32);
                --v48;
              }
              while (v48);
            }
            *(float32x4_t *)(v8 + 4 * v44) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmulq_n_f64(v46, v5)), vmulq_n_f64(v50, v5));
            v44 += 4;
            ++v43;
          }
          while ((int)v30 >= (int)v44);
          v44 = v44;
        }
        else
        {
          v44 = v29;
        }
        if ((int)v44 < (int)v15)
        {
          v53 = (__int16 *)v6 + v44;
          do
          {
            if ((int)v17 < 1)
            {
              v55 = 0.0;
            }
            else
            {
              v54 = (float *)&v9[v44];
              if (v24)
                v54 = (float *)v24;
              v55 = 0.0;
              v56 = v53;
              v57 = v17;
              v58 = result;
              do
              {
                v59 = *v58++;
                v55 = v55 + v59 * (float)((float)*v56 - *v54);
                v54 = (float *)((char *)v54 + v31);
                v56 = (__int16 *)((char *)v56 + v32);
                --v57;
              }
              while (v57);
            }
            v60 = v55 * v5;
            *(float *)(v8 + 4 * v44++) = v60;
            ++v53;
          }
          while ((int)v15 > (int)v44);
        }
        ++v29;
        v8 += 4 * v23;
        v34 = (int16x4_t *)((char *)v34 + 2);
        ++v33;
      }
      while (v29 != v15);
    }
    goto LABEL_54;
  }
  if ((int)v15 >= 1)
  {
    v61 = 0;
    v62 = v15 - 4;
    v63 = 2 * v22;
    v64 = v6;
    do
    {
      v65 = v16;
      v66 = v64;
      v67 = result;
      if ((int)v17 >= 1)
      {
        do
        {
          *v67++ = (float)v66->i16[0];
          v66 = (int16x4_t *)((char *)v66 + v63);
          --v65;
        }
        while (v65);
      }
      v68 = v64;
      v69 = v61;
      if (v61 <= v62)
      {
        do
        {
          v70 = 0uLL;
          if ((int)v16 < 1)
          {
            v74 = 0uLL;
          }
          else
          {
            v71 = v68;
            v72 = v16;
            v73 = result;
            v74 = 0uLL;
            do
            {
              v75 = *v73++;
              v76 = vmovl_s16(*v71);
              v77.i64[0] = v76.i32[0];
              v77.i64[1] = v76.i32[1];
              v78 = vcvtq_f64_s64(v77);
              v77.i64[0] = v76.i32[2];
              v77.i64[1] = v76.i32[3];
              v74 = vmlaq_n_f64(v74, vcvtq_f64_s64(v77), v75);
              v70 = vmlaq_n_f64(v70, v78, v75);
              v71 = (int16x4_t *)((char *)v71 + v63);
              --v72;
            }
            while (v72);
          }
          *(float32x4_t *)(v8 + 4 * v69) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmulq_n_f64(v70, v5)), vmulq_n_f64(v74, v5));
          v69 += 4;
          ++v68;
        }
        while ((int)v62 >= (int)v69);
        v69 = v69;
      }
      else
      {
        v69 = v61;
      }
      if ((int)v69 < (int)v15)
      {
        v79 = (__int16 *)v6 + v69;
        do
        {
          v80 = 0.0;
          if ((int)v17 >= 1)
          {
            v81 = v79;
            v82 = v16;
            v83 = result;
            do
            {
              v84 = *v83++;
              v80 = v80 + v84 * (double)*v81;
              v81 = (__int16 *)((char *)v81 + v63);
              --v82;
            }
            while (v82);
          }
          v85 = v80 * v5;
          *(float *)(v8 + 4 * v69++) = v85;
          ++v79;
        }
        while ((int)v15 > (int)v69);
      }
      ++v61;
      v8 += 4 * v23;
      v64 = (int16x4_t *)((char *)v64 + 2);
    }
    while (v61 != v15);
  }
LABEL_54:
  if (result != (float *)v87)
    return (float *)MEMORY[0x2207351A4](result, 0x1000C8077774924);
  return result;
}

__int16 *cv::MulTransposedL<short,float>(uint64_t a1, uint64_t a2)
{
  __int16 *result;
  uint64_t v3;
  double v4;
  double v5;
  __int16 *v6;
  uint64_t v7;
  uint64_t v8;
  float *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  _BOOL4 v18;
  uint64_t v19;
  uint64_t v20;
  __int16 *v21;
  float *v22;
  uint64_t v23;
  float v24;
  uint64_t v25;
  __int16 *v26;
  float *v27;
  float *v28;
  int v29;
  float v30;
  float v31;
  __int16 *v32;
  __int16 *v33;
  uint64_t v34;
  float32x4_t *v35;
  float32x4_t v36;
  int v37;
  double v38;
  uint64_t v39;
  __int16 *v40;
  float *v41;
  double v42;
  float v43;
  float v44;
  __int16 *v45;
  float *v46;
  float v47;
  float v48;
  int v49;
  float v50;
  float v51;
  float v52;
  unint64_t v53;
  __int16 *v54;
  uint64_t v55;
  __int16 *v56;
  __int16 *v57;
  unint64_t v58;
  int v59;
  double v60;
  uint64_t v61;
  __int16 *v62;
  __int16 *v63;
  int v64;
  double v65;
  int v66;
  float v67;
  uint64_t v68;
  _BYTE v69[4120];
  float32x4_t v70;
  uint64_t v71;

  result = (__int16 *)MEMORY[0x24BDAC7A8](a1, a2);
  v5 = v4;
  v71 = *MEMORY[0x24BDAC8D0];
  v6 = (__int16 *)*((_QWORD *)result + 2);
  v8 = *(_QWORD *)(v7 + 16);
  v9 = *(float **)(v3 + 16);
  v10 = *((_QWORD *)result + 10) >> 1;
  v11 = *(_QWORD *)(v7 + 80) >> 2;
  if (*(int *)(v3 + 8) <= 1)
    v12 = 0;
  else
    v12 = *(_QWORD *)(v3 + 80) >> 2;
  v13 = (unsigned int *)*((_QWORD *)result + 8);
  v14 = *v13;
  v15 = (int)v13[1];
  v16 = v13[1];
  if (v9)
  {
    v17 = *(_DWORD *)(v3 + 12);
    v18 = v17 == v15;
    result = (__int16 *)v69;
    if ((unint64_t)(4 * v15) >= 0x1009)
    {
      v68 = v10;
      result = (__int16 *)operator new[]();
      v18 = v17 == v15;
      v10 = v68;
    }
    if ((int)v14 >= 1)
    {
      v19 = 0;
      v20 = 2 * v10;
      v21 = v6 + 2;
      v22 = v9;
      do
      {
        if (v17 >= (int)v16)
        {
          v25 = v16;
          v26 = v6;
          v27 = v22;
          v28 = (float *)result;
          if ((int)v16 >= 1)
          {
            do
            {
              v29 = *v26++;
              v30 = (float)v29;
              v31 = *v27++;
              *v28++ = v30 - v31;
              --v25;
            }
            while (v25);
          }
        }
        else if ((int)v15 >= 1)
        {
          v23 = 0;
          v24 = v9[v12 * v19];
          do
          {
            *(float *)&result[2 * v23] = (float)v6[v23] - v24;
            ++v23;
          }
          while (v16 != v23);
        }
        v32 = v6;
        v33 = v21;
        v34 = v19;
        do
        {
          v35 = (float32x4_t *)&v9[v12 * v34];
          if (v17 < (int)v15)
          {
            v36 = vld1q_dup_f32(v35->f32);
            v70 = v36;
            v35 = &v70;
          }
          if ((int)v16 >= 4)
          {
            v39 = 0;
            v38 = 0.0;
            v40 = v33;
            v41 = (float *)(result + 4);
            do
            {
              v42 = *(v41 - 1) * (float)((float)*(v40 - 1) - v35->f32[1])
                  + *(v41 - 2) * (float)((float)*(v40 - 2) - v35->f32[0]);
              v43 = *v41;
              v44 = v41[1];
              v41 += 4;
              v39 += 4;
              v38 = v38 + v42 + v43 * (float)((float)*v40 - v35->f32[2]) + v44 * (float)((float)v40[1] - v35->f32[3]);
              v35 += v18;
              v40 += 4;
            }
            while (v39 <= (int)v16 - 4);
            v37 = ((v16 - 4) & 0xFFFFFFFC) + 4;
          }
          else
          {
            v37 = 0;
            v38 = 0.0;
          }
          if (v37 < (int)v15)
          {
            v45 = &v32[v37];
            v46 = (float *)&result[2 * v37];
            do
            {
              v47 = *v46++;
              v48 = v47;
              v49 = *v45++;
              v50 = (float)v49;
              v51 = v35->f32[0];
              v35 = (float32x4_t *)((char *)v35 + 4);
              v38 = v38 + v48 * (float)(v50 - v51);
              ++v37;
            }
            while ((int)v15 > v37);
          }
          v52 = v38 * v5;
          *(float *)(v8 + 4 * v34++) = v52;
          v33 = (__int16 *)((char *)v33 + v20);
          v32 = (__int16 *)((char *)v32 + v20);
        }
        while (v34 != v14);
        v8 += 4 * v11;
        ++v19;
        v22 += v12;
        v6 = (__int16 *)((char *)v6 + v20);
        v21 = (__int16 *)((char *)v21 + v20);
      }
      while (v19 != v14);
    }
    if (result != (__int16 *)v69)
      return (__int16 *)MEMORY[0x2207351A4](result, 0x1000C8077774924);
  }
  else if ((int)v14 >= 1)
  {
    v53 = 0;
    v54 = v6 + 2;
    v55 = 2 * v10;
    do
    {
      v56 = v6;
      v57 = v54;
      v58 = v53;
      do
      {
        if ((int)v15 >= 4)
        {
          v61 = 0;
          v60 = 0.0;
          v62 = v57;
          result = v54;
          do
          {
            v60 = v60
                + (double)*(result - 1) * (double)*(v62 - 1)
                + (double)*(result - 2) * (double)*(v62 - 2)
                + (double)*result * (double)*v62
                + (double)result[1] * (double)v62[1];
            v61 += 4;
            result += 4;
            v62 += 4;
          }
          while (v61 <= (int)v16 - 4);
          v59 = ((v16 - 4) & 0xFFFFFFFC) + 4;
        }
        else
        {
          v59 = 0;
          v60 = 0.0;
        }
        if (v59 < (int)v16)
        {
          v63 = &v56[v59];
          result = &v6[v59];
          do
          {
            v64 = *result++;
            v65 = (double)v64;
            v66 = *v63++;
            v60 = v60 + v65 * (double)v66;
            ++v59;
          }
          while ((int)v16 > v59);
        }
        v67 = v60 * v5;
        *(float *)(v8 + 4 * v58++) = v67;
        v57 = (__int16 *)((char *)v57 + v55);
        v56 = (__int16 *)((char *)v56 + v55);
      }
      while (v58 < v14);
      ++v53;
      v8 += 4 * v11;
      v54 = (__int16 *)((char *)v54 + v55);
      v6 = (__int16 *)((char *)v6 + v55);
    }
    while (v53 != v14);
  }
  return result;
}

double *cv::MulTransposedR<short,double>(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  uint64_t v3;
  double v4;
  double v5;
  __int16 *v6;
  uint64_t v7;
  uint64_t v8;
  double *v9;
  unint64_t v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  unsigned int *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  char v19;
  unsigned int v20;
  double *result;
  unint64_t v22;
  unint64_t v23;
  double *v24;
  double *v25;
  uint64_t v26;
  double v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  __int16 *v32;
  double *v33;
  __int16 *v34;
  uint64_t v35;
  __int16 *v36;
  double *v37;
  double *v38;
  uint64_t v39;
  __int16 *v40;
  double *v41;
  double *v42;
  __int16 *v43;
  uint64_t v44;
  double *v45;
  double *v46;
  double v47;
  __int16 *v48;
  uint64_t v49;
  double *v50;
  double v51;
  double v52;
  double v53;
  double v54;
  double *v55;
  __int16 *v56;
  double *v57;
  double v58;
  __int16 *v59;
  uint64_t v60;
  double *v61;
  double v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  __int16 *v66;
  __int16 *v67;
  uint64_t v68;
  __int16 *v69;
  double *v70;
  __int16 *v71;
  uint64_t v72;
  double v73;
  __int16 *v74;
  uint64_t v75;
  double *v76;
  double v77;
  double v78;
  double v79;
  double v80;
  double *v81;
  __int16 *v82;
  double v83;
  __int16 *v84;
  uint64_t v85;
  double *v86;
  double v87;
  _QWORD v88[517];

  v2 = (_QWORD *)MEMORY[0x24BDAC7A8](a1, a2);
  v5 = v4;
  v88[515] = *MEMORY[0x24BDAC8D0];
  v6 = (__int16 *)v2[2];
  v8 = *(_QWORD *)(v7 + 16);
  v9 = *(double **)(v3 + 16);
  v10 = v2[10];
  v11 = *(_QWORD *)(v7 + 80);
  v12 = *(_DWORD *)(v3 + 12);
  if (*(int *)(v3 + 8) <= 1)
    v13 = 0;
  else
    v13 = *(_QWORD *)(v3 + 80) >> 3;
  v14 = (unsigned int *)v2[8];
  v16 = (int)*v14;
  v15 = (int)v14[1];
  v17 = *v14;
  if (v9)
    v18 = v12 < (int)v15;
  else
    v18 = 0;
  v19 = !v18;
  if (v18)
  {
    if (v12 != 1)
      __assert_rtn("MulTransposedR", "matmul.cpp", 2360, "delta_cols == 1");
    v20 = 40 * v17;
  }
  else
  {
    v20 = 8 * v16;
  }
  result = (double *)v88;
  if (v20 >= 0x1009)
    result = (double *)operator new[]();
  v22 = v10 >> 1;
  v23 = v11 >> 3;
  if ((v19 & 1) == 0)
  {
    v24 = &result[v16];
    if ((int)v16 >= 1)
    {
      v25 = v24 + 2;
      v26 = v17;
      do
      {
        v27 = *v9;
        *v25 = *v9;
        v25[1] = v27;
        *(v25 - 2) = v27;
        *(v25 - 1) = v27;
        v9 += v13;
        v25 += 4;
        --v26;
      }
      while (v26);
    }
    v13 = 4 * (v13 != 0);
    v9 = &result[v16];
    goto LABEL_23;
  }
  if (v9)
  {
    v24 = 0;
LABEL_23:
    if ((int)v15 >= 1)
    {
      v28 = 0;
      v29 = v15 - 4;
      v30 = 8 * v13;
      v31 = 2 * v22;
      v32 = v6 + 2;
      v33 = v9;
      v34 = v6;
      do
      {
        if (v24)
        {
          v35 = v17;
          v36 = v34;
          v37 = v24;
          v38 = result;
          if ((int)v16 >= 1)
          {
            do
            {
              *v38++ = (double)*v36 - *v37;
              v37 = (double *)((char *)v37 + v30);
              v36 = (__int16 *)((char *)v36 + v31);
              --v35;
            }
            while (v35);
          }
        }
        else if ((int)v17 >= 1)
        {
          v39 = v17;
          v40 = v34;
          v41 = v33;
          v42 = result;
          do
          {
            *v42++ = (double)*v40 - *v41;
            v41 = (double *)((char *)v41 + v30);
            v40 = (__int16 *)((char *)v40 + v31);
            --v39;
          }
          while (v39);
        }
        v43 = v32;
        v44 = v28;
        if (v28 <= v29)
        {
          do
          {
            if ((int)v16 < 1)
            {
              v53 = 0.0;
              v52 = 0.0;
              v51 = 0.0;
              v47 = 0.0;
            }
            else
            {
              v45 = &v9[v44];
              if (v24)
                v45 = v24;
              v46 = v45 + 2;
              v47 = 0.0;
              v48 = v43;
              v49 = v17;
              v50 = result;
              v51 = 0.0;
              v52 = 0.0;
              v53 = 0.0;
              do
              {
                v54 = *v50++;
                v53 = v53 + v54 * ((double)*(v48 - 2) - *(v46 - 2));
                v52 = v52 + v54 * ((double)*(v48 - 1) - *(v46 - 1));
                v51 = v51 + v54 * ((double)*v48 - *v46);
                v47 = v47 + v54 * ((double)v48[1] - v46[1]);
                v48 = (__int16 *)((char *)v48 + v31);
                v46 = (double *)((char *)v46 + v30);
                --v49;
              }
              while (v49);
            }
            v55 = (double *)(v8 + 8 * v44);
            *v55 = v53 * v5;
            v55[1] = v52 * v5;
            v55[2] = v51 * v5;
            v55[3] = v47 * v5;
            v44 += 4;
            v43 += 4;
          }
          while ((int)v29 >= (int)v44);
          v44 = v44;
        }
        else
        {
          v44 = v28;
        }
        if ((int)v44 < (int)v15)
        {
          v56 = &v6[v44];
          do
          {
            if ((int)v17 < 1)
            {
              v58 = 0.0;
            }
            else
            {
              v57 = &v9[v44];
              if (v24)
                v57 = v24;
              v58 = 0.0;
              v59 = v56;
              v60 = v17;
              v61 = result;
              do
              {
                v62 = *v61++;
                v58 = v58 + v62 * ((double)*v59 - *v57);
                v57 = (double *)((char *)v57 + v30);
                v59 = (__int16 *)((char *)v59 + v31);
                --v60;
              }
              while (v60);
            }
            *(double *)(v8 + 8 * v44++) = v58 * v5;
            ++v56;
          }
          while ((int)v15 > (int)v44);
        }
        v8 += 8 * v23;
        ++v28;
        ++v34;
        ++v33;
        ++v32;
      }
      while (v28 != v15);
    }
    goto LABEL_54;
  }
  if ((int)v15 >= 1)
  {
    v63 = 0;
    v64 = v15 - 4;
    v65 = 2 * v22;
    v66 = v6 + 2;
    v67 = v6;
    do
    {
      v68 = v16;
      v69 = v67;
      v70 = result;
      if ((int)v17 >= 1)
      {
        do
        {
          *v70++ = (double)*v69;
          v69 = (__int16 *)((char *)v69 + v65);
          --v68;
        }
        while (v68);
      }
      v71 = v66;
      v72 = v63;
      if (v63 <= v64)
      {
        do
        {
          if ((int)v16 < 1)
          {
            v79 = 0.0;
            v78 = 0.0;
            v77 = 0.0;
            v73 = 0.0;
          }
          else
          {
            v73 = 0.0;
            v74 = v71;
            v75 = v16;
            v76 = result;
            v77 = 0.0;
            v78 = 0.0;
            v79 = 0.0;
            do
            {
              v80 = *v76++;
              v79 = v79 + v80 * (double)*(v74 - 2);
              v78 = v78 + v80 * (double)*(v74 - 1);
              v77 = v77 + v80 * (double)*v74;
              v73 = v73 + v80 * (double)v74[1];
              v74 = (__int16 *)((char *)v74 + v65);
              --v75;
            }
            while (v75);
          }
          v81 = (double *)(v8 + 8 * v72);
          *v81 = v79 * v5;
          v81[1] = v78 * v5;
          v81[2] = v77 * v5;
          v81[3] = v73 * v5;
          v72 += 4;
          v71 += 4;
        }
        while ((int)v64 >= (int)v72);
        v72 = v72;
      }
      else
      {
        v72 = v63;
      }
      if ((int)v72 < (int)v15)
      {
        v82 = &v6[v72];
        do
        {
          v83 = 0.0;
          if ((int)v17 >= 1)
          {
            v84 = v82;
            v85 = v16;
            v86 = result;
            do
            {
              v87 = *v86++;
              v83 = v83 + v87 * (double)*v84;
              v84 = (__int16 *)((char *)v84 + v65);
              --v85;
            }
            while (v85);
          }
          *(double *)(v8 + 8 * v72++) = v83 * v5;
          ++v82;
        }
        while ((int)v15 > (int)v72);
      }
      ++v63;
      v8 += 8 * v23;
      ++v67;
      ++v66;
    }
    while (v63 != v15);
  }
LABEL_54:
  if (result != (double *)v88)
    return (double *)MEMORY[0x2207351A4](result, 0x1000C8077774924);
  return result;
}

__int16 *cv::MulTransposedL<short,double>(uint64_t a1, uint64_t a2)
{
  __int16 *result;
  uint64_t v3;
  double v4;
  double v5;
  __int16 *v6;
  uint64_t v7;
  uint64_t v8;
  double *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  _BOOL4 v18;
  uint64_t v19;
  uint64_t v20;
  __int16 *v21;
  double *v22;
  uint64_t v23;
  double v24;
  uint64_t v25;
  __int16 *v26;
  double *v27;
  double *v28;
  int v29;
  double v30;
  double v31;
  __int16 *v32;
  __int16 *v33;
  uint64_t v34;
  double *v35;
  int v36;
  double v37;
  uint64_t v38;
  __int16 *v39;
  double *v40;
  double v41;
  double v42;
  double v43;
  __int16 *v44;
  double *v45;
  double v46;
  double v47;
  double v48;
  double v49;
  unint64_t v50;
  __int16 *v51;
  uint64_t v52;
  __int16 *v53;
  __int16 *v54;
  unint64_t v55;
  int v56;
  double v57;
  uint64_t v58;
  __int16 *v59;
  __int16 *v60;
  int v61;
  double v62;
  int v63;
  uint64_t v64;
  _BYTE v65[4120];
  _QWORD v66[2];
  double v67;
  double v68;
  uint64_t v69;

  result = (__int16 *)MEMORY[0x24BDAC7A8](a1, a2);
  v5 = v4;
  v69 = *MEMORY[0x24BDAC8D0];
  v6 = (__int16 *)*((_QWORD *)result + 2);
  v8 = *(_QWORD *)(v7 + 16);
  v9 = *(double **)(v3 + 16);
  v10 = *((_QWORD *)result + 10) >> 1;
  v11 = *(_QWORD *)(v7 + 80) >> 3;
  if (*(int *)(v3 + 8) <= 1)
    v12 = 0;
  else
    v12 = *(_QWORD *)(v3 + 80) >> 3;
  v13 = (unsigned int *)*((_QWORD *)result + 8);
  v14 = *v13;
  v15 = (int)v13[1];
  v16 = v13[1];
  if (v9)
  {
    v17 = *(_DWORD *)(v3 + 12);
    v18 = v17 == v15;
    result = (__int16 *)v65;
    if ((unint64_t)(8 * v15) >= 0x1009)
    {
      v64 = v10;
      result = (__int16 *)operator new[]();
      v18 = v17 == v15;
      v10 = v64;
    }
    if ((int)v14 >= 1)
    {
      v19 = 0;
      v20 = 2 * v10;
      v21 = v6 + 2;
      v22 = v9;
      do
      {
        if (v17 >= (int)v16)
        {
          v25 = v16;
          v26 = v6;
          v27 = v22;
          v28 = (double *)result;
          if ((int)v16 >= 1)
          {
            do
            {
              v29 = *v26++;
              v30 = (double)v29;
              v31 = *v27++;
              *v28++ = v30 - v31;
              --v25;
            }
            while (v25);
          }
        }
        else if ((int)v15 >= 1)
        {
          v23 = 0;
          v24 = v9[v12 * v19];
          do
          {
            *(double *)&result[4 * v23] = (double)v6[v23] - v24;
            ++v23;
          }
          while (v16 != v23);
        }
        v32 = v6;
        v33 = v21;
        v34 = v19;
        do
        {
          v35 = &v9[v12 * v34];
          if (v17 < (int)v15)
          {
            v67 = *v35;
            v68 = v67;
            *(double *)v66 = v67;
            *(double *)&v66[1] = v67;
            v35 = (double *)v66;
          }
          if ((int)v16 >= 4)
          {
            v38 = 0;
            v37 = 0.0;
            v39 = v33;
            v40 = (double *)(result + 8);
            do
            {
              v41 = *(v40 - 1) * ((double)*(v39 - 1) - v35[1]) + *(v40 - 2) * ((double)*(v39 - 2) - *v35);
              v42 = *v40;
              v43 = v40[1];
              v40 += 4;
              v38 += 4;
              v37 = v37 + v41 + v42 * ((double)*v39 - v35[2]) + v43 * ((double)v39[1] - v35[3]);
              v35 += 4 * v18;
              v39 += 4;
            }
            while (v38 <= (int)v16 - 4);
            v36 = ((v16 - 4) & 0xFFFFFFFC) + 4;
          }
          else
          {
            v36 = 0;
            v37 = 0.0;
          }
          if (v36 < (int)v15)
          {
            v44 = &v32[v36];
            v45 = (double *)&result[4 * v36];
            do
            {
              v46 = *v45++;
              v47 = v46;
              LODWORD(v46) = *v44++;
              v48 = (double)SLODWORD(v46);
              v49 = *v35++;
              v37 = v37 + v47 * (v48 - v49);
              ++v36;
            }
            while ((int)v15 > v36);
          }
          *(double *)(v8 + 8 * v34++) = v37 * v5;
          v33 = (__int16 *)((char *)v33 + v20);
          v32 = (__int16 *)((char *)v32 + v20);
        }
        while (v34 != v14);
        v8 += 8 * v11;
        ++v19;
        v22 += v12;
        v6 = (__int16 *)((char *)v6 + v20);
        v21 = (__int16 *)((char *)v21 + v20);
      }
      while (v19 != v14);
    }
    if (result != (__int16 *)v65)
      return (__int16 *)MEMORY[0x2207351A4](result, 0x1000C8077774924);
  }
  else if ((int)v14 >= 1)
  {
    v50 = 0;
    v51 = v6 + 2;
    v52 = 2 * v10;
    do
    {
      v53 = v6;
      v54 = v51;
      v55 = v50;
      do
      {
        if ((int)v15 >= 4)
        {
          v58 = 0;
          v57 = 0.0;
          v59 = v54;
          result = v51;
          do
          {
            v57 = v57
                + (double)*(result - 1) * (double)*(v59 - 1)
                + (double)*(result - 2) * (double)*(v59 - 2)
                + (double)*result * (double)*v59
                + (double)result[1] * (double)v59[1];
            v58 += 4;
            result += 4;
            v59 += 4;
          }
          while (v58 <= (int)v16 - 4);
          v56 = ((v16 - 4) & 0xFFFFFFFC) + 4;
        }
        else
        {
          v56 = 0;
          v57 = 0.0;
        }
        if (v56 < (int)v16)
        {
          v60 = &v53[v56];
          result = &v6[v56];
          do
          {
            v61 = *result++;
            v62 = (double)v61;
            v63 = *v60++;
            v57 = v57 + v62 * (double)v63;
            ++v56;
          }
          while ((int)v16 > v56);
        }
        *(double *)(v8 + 8 * v55++) = v57 * v5;
        v54 = (__int16 *)((char *)v54 + v52);
        v53 = (__int16 *)((char *)v53 + v52);
      }
      while (v55 < v14);
      ++v50;
      v8 += 8 * v11;
      v51 = (__int16 *)((char *)v51 + v52);
      v6 = (__int16 *)((char *)v6 + v52);
    }
    while (v50 != v14);
  }
  return result;
}

float *cv::MulTransposedR<float,float>(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  uint64_t v3;
  double v4;
  double v5;
  float *v6;
  uint64_t v7;
  uint64_t v8;
  const float *v9;
  unint64_t v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  unsigned int *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  char v19;
  unsigned int v20;
  float *result;
  unint64_t v22;
  unint64_t v23;
  float32x4_t *v24;
  uint64_t v25;
  uint64_t v26;
  float32x4_t *v27;
  float32x4_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  float *v33;
  float *v34;
  uint64_t v35;
  float *v36;
  float *v37;
  float *v38;
  uint64_t v39;
  float *v40;
  float *v41;
  float *v42;
  float32x4_t *v43;
  uint64_t v44;
  float32x4_t *v45;
  float64x2_t v46;
  float32x4_t *v47;
  uint64_t v48;
  float *v49;
  float64x2_t v50;
  float v51;
  float32x4_t v52;
  float *v53;
  float *v54;
  double v55;
  float *v56;
  uint64_t v57;
  float *v58;
  float v59;
  float v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  float32x4_t *v64;
  uint64_t v65;
  float32x4_t *v66;
  float *v67;
  float32x4_t *v68;
  uint64_t v69;
  float64x2_t v70;
  float32x4_t *v71;
  uint64_t v72;
  float *v73;
  float64x2_t v74;
  float v75;
  float *v76;
  double v77;
  float *v78;
  uint64_t v79;
  float *v80;
  float v81;
  float v82;
  double v83;
  _QWORD v84[517];

  v2 = (_QWORD *)MEMORY[0x24BDAC7A8](a1, a2);
  v5 = v4;
  v84[515] = *MEMORY[0x24BDAC8D0];
  v6 = (float *)v2[2];
  v8 = *(_QWORD *)(v7 + 16);
  v9 = *(const float **)(v3 + 16);
  v10 = v2[10];
  v11 = *(_QWORD *)(v7 + 80);
  v12 = *(_DWORD *)(v3 + 12);
  if (*(int *)(v3 + 8) <= 1)
    v13 = 0;
  else
    v13 = *(_QWORD *)(v3 + 80) >> 2;
  v14 = (unsigned int *)v2[8];
  v16 = (int)*v14;
  v15 = (int)v14[1];
  v17 = *v14;
  if (v9)
    v18 = v12 < (int)v15;
  else
    v18 = 0;
  v19 = !v18;
  if (v18)
  {
    if (v12 != 1)
      __assert_rtn("MulTransposedR", "matmul.cpp", 2360, "delta_cols == 1");
    v20 = 20 * v17;
  }
  else
  {
    v20 = 4 * v16;
  }
  result = (float *)v84;
  if (v20 >= 0x1009)
  {
    v83 = v4;
    result = (float *)operator new[]();
    v5 = v83;
  }
  v22 = v10 >> 2;
  v23 = v11 >> 2;
  if ((v19 & 1) == 0)
  {
    v24 = (float32x4_t *)&result[v16];
    if ((int)v16 >= 1)
    {
      v26 = v17;
      v27 = (float32x4_t *)&result[v16];
      do
      {
        v28 = vld1q_dup_f32(v9);
        v25 = 4 * v13;
        v9 = (const float *)((char *)v9 + v25);
        *v27++ = v28;
        --v26;
      }
      while (v26);
    }
    v13 = 4 * (v13 != 0);
    v9 = &result[v16];
    goto LABEL_23;
  }
  if (v9)
  {
    v24 = 0;
LABEL_23:
    if ((int)v15 >= 1)
    {
      v29 = 0;
      v30 = v15 - 4;
      v31 = 4 * v13;
      v32 = 4 * v22;
      v33 = (float *)v9;
      v34 = v6;
      do
      {
        if (v24)
        {
          v35 = v17;
          v36 = v34;
          v37 = (float *)v24;
          v38 = result;
          if ((int)v16 >= 1)
          {
            do
            {
              *v38++ = *v36 - *v37;
              v37 = (float *)((char *)v37 + v31);
              v36 = (float *)((char *)v36 + v32);
              --v35;
            }
            while (v35);
          }
        }
        else if ((int)v17 >= 1)
        {
          v39 = v17;
          v40 = v34;
          v41 = v33;
          v42 = result;
          do
          {
            *v42++ = *v40 - *v41;
            v41 = (float *)((char *)v41 + v31);
            v40 = (float *)((char *)v40 + v32);
            --v39;
          }
          while (v39);
        }
        v43 = (float32x4_t *)v34;
        v44 = v29;
        if (v29 <= v30)
        {
          do
          {
            if ((int)v16 < 1)
            {
              v46 = 0uLL;
              v50 = 0uLL;
            }
            else
            {
              v45 = (float32x4_t *)&v9[v44];
              if (v24)
                v45 = v24;
              v46 = 0uLL;
              v47 = v43;
              v48 = v17;
              v49 = result;
              v50 = 0uLL;
              do
              {
                v51 = *v49++;
                v52 = vsubq_f32(*v47, *v45);
                v50 = vmlaq_n_f64(v50, vcvt_hight_f64_f32(v52), v51);
                v46 = vmlaq_n_f64(v46, vcvtq_f64_f32(*(float32x2_t *)v52.f32), v51);
                v45 = (float32x4_t *)((char *)v45 + v31);
                v47 = (float32x4_t *)((char *)v47 + v32);
                --v48;
              }
              while (v48);
            }
            *(float32x4_t *)(v8 + 4 * v44) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmulq_n_f64(v46, v5)), vmulq_n_f64(v50, v5));
            v44 += 4;
            ++v43;
          }
          while ((int)v30 >= (int)v44);
          v44 = v44;
        }
        else
        {
          v44 = v29;
        }
        if ((int)v44 < (int)v15)
        {
          v53 = &v6[v44];
          do
          {
            if ((int)v17 < 1)
            {
              v55 = 0.0;
            }
            else
            {
              v54 = (float *)&v9[v44];
              if (v24)
                v54 = (float *)v24;
              v55 = 0.0;
              v56 = v53;
              v57 = v17;
              v58 = result;
              do
              {
                v59 = *v58++;
                v55 = v55 + v59 * (float)(*v56 - *v54);
                v54 = (float *)((char *)v54 + v31);
                v56 = (float *)((char *)v56 + v32);
                --v57;
              }
              while (v57);
            }
            v60 = v55 * v5;
            *(float *)(v8 + 4 * v44++) = v60;
            ++v53;
          }
          while ((int)v15 > (int)v44);
        }
        ++v29;
        v8 += 4 * v23;
        ++v34;
        ++v33;
      }
      while (v29 != v15);
    }
    goto LABEL_54;
  }
  if ((int)v15 >= 1)
  {
    v61 = 0;
    v62 = v15 - 4;
    v63 = 4 * v22;
    v64 = (float32x4_t *)v6;
    do
    {
      v65 = v16;
      v66 = v64;
      v67 = result;
      if ((int)v17 >= 1)
      {
        do
        {
          *v67++ = v66->f32[0];
          v66 = (float32x4_t *)((char *)v66 + v63);
          --v65;
        }
        while (v65);
      }
      v68 = v64;
      v69 = v61;
      if (v61 <= v62)
      {
        do
        {
          v70 = 0uLL;
          if ((int)v16 < 1)
          {
            v74 = 0uLL;
          }
          else
          {
            v71 = v68;
            v72 = v16;
            v73 = result;
            v74 = 0uLL;
            do
            {
              v75 = *v73++;
              v74 = vmlaq_n_f64(v74, vcvt_hight_f64_f32(*v71), v75);
              v70 = vmlaq_n_f64(v70, vcvtq_f64_f32(*(float32x2_t *)v71->f32), v75);
              v71 = (float32x4_t *)((char *)v71 + v63);
              --v72;
            }
            while (v72);
          }
          *(float32x4_t *)(v8 + 4 * v69) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmulq_n_f64(v70, v5)), vmulq_n_f64(v74, v5));
          v69 += 4;
          ++v68;
        }
        while ((int)v62 >= (int)v69);
        v69 = v69;
      }
      else
      {
        v69 = v61;
      }
      if ((int)v69 < (int)v15)
      {
        v76 = &v6[v69];
        do
        {
          v77 = 0.0;
          if ((int)v17 >= 1)
          {
            v78 = v76;
            v79 = v16;
            v80 = result;
            do
            {
              v81 = *v80++;
              v77 = v77 + v81 * *v78;
              v78 = (float *)((char *)v78 + v63);
              --v79;
            }
            while (v79);
          }
          v82 = v77 * v5;
          *(float *)(v8 + 4 * v69++) = v82;
          ++v76;
        }
        while ((int)v15 > (int)v69);
      }
      ++v61;
      v8 += 4 * v23;
      v64 = (float32x4_t *)((char *)v64 + 4);
    }
    while (v61 != v15);
  }
LABEL_54:
  if (result != (float *)v84)
    return (float *)MEMORY[0x2207351A4](result, 0x1000C8077774924);
  return result;
}

float *cv::MulTransposedL<float,float>(uint64_t a1, uint64_t a2)
{
  float *result;
  uint64_t v3;
  double v4;
  double v5;
  float *v6;
  uint64_t v7;
  uint64_t v8;
  float *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  _BOOL4 v18;
  uint64_t v19;
  uint64_t v20;
  float *v21;
  float *v22;
  uint64_t v23;
  float v24;
  uint64_t v25;
  float *v26;
  float *v27;
  float *v28;
  float v29;
  float v30;
  float v31;
  float *v32;
  float *v33;
  uint64_t v34;
  float32x4_t *v35;
  float32x4_t v36;
  int v37;
  double v38;
  uint64_t v39;
  float *v40;
  float *v41;
  double v42;
  double v43;
  float v44;
  float v45;
  double v46;
  float v47;
  float v48;
  float *v49;
  float *v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  unint64_t v57;
  float *v58;
  uint64_t v59;
  float *v60;
  float *v61;
  unint64_t v62;
  int v63;
  double v64;
  uint64_t v65;
  float *v66;
  double v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float *v72;
  float v73;
  double v74;
  float v75;
  float v76;
  uint64_t v77;
  _BYTE v78[4120];
  float32x4_t v79;
  uint64_t v80;

  result = (float *)MEMORY[0x24BDAC7A8](a1, a2);
  v5 = v4;
  v80 = *MEMORY[0x24BDAC8D0];
  v6 = (float *)*((_QWORD *)result + 2);
  v8 = *(_QWORD *)(v7 + 16);
  v9 = *(float **)(v3 + 16);
  v10 = *((_QWORD *)result + 10) >> 2;
  v11 = *(_QWORD *)(v7 + 80) >> 2;
  if (*(int *)(v3 + 8) <= 1)
    v12 = 0;
  else
    v12 = *(_QWORD *)(v3 + 80) >> 2;
  v13 = (unsigned int *)*((_QWORD *)result + 8);
  v14 = *v13;
  v15 = (int)v13[1];
  v16 = v13[1];
  if (v9)
  {
    v17 = *(_DWORD *)(v3 + 12);
    v18 = v17 == v15;
    result = (float *)v78;
    if ((unint64_t)(4 * v15) >= 0x1009)
    {
      v77 = v10;
      result = (float *)operator new[]();
      v18 = v17 == v15;
      v10 = v77;
    }
    if ((int)v14 >= 1)
    {
      v19 = 0;
      v20 = 4 * v10;
      v21 = v6 + 2;
      v22 = v9;
      do
      {
        if (v17 >= (int)v16)
        {
          v25 = v16;
          v26 = v6;
          v27 = v22;
          v28 = result;
          if ((int)v16 >= 1)
          {
            do
            {
              v29 = *v26++;
              v30 = v29;
              v31 = *v27++;
              *v28++ = v30 - v31;
              --v25;
            }
            while (v25);
          }
        }
        else if ((int)v15 >= 1)
        {
          v23 = 0;
          v24 = v9[v12 * v19];
          do
          {
            result[v23] = v6[v23] - v24;
            ++v23;
          }
          while (v16 != v23);
        }
        v32 = v6;
        v33 = v21;
        v34 = v19;
        do
        {
          v35 = (float32x4_t *)&v9[v12 * v34];
          if (v17 < (int)v15)
          {
            v36 = vld1q_dup_f32(v35->f32);
            v79 = v36;
            v35 = &v79;
          }
          if ((int)v16 >= 4)
          {
            v39 = 0;
            v38 = 0.0;
            v40 = v33;
            v41 = result + 2;
            do
            {
              v42 = (float)(*(v40 - 2) - v35->f32[0]);
              v43 = *(v41 - 1) * (float)(*(v40 - 1) - v35->f32[1]);
              v44 = *v40;
              v45 = v40[1];
              v40 += 4;
              v46 = v43 + *(v41 - 2) * v42;
              *(float *)&v43 = v44 - v35->f32[2];
              v47 = *v41;
              v48 = v41[1];
              v41 += 4;
              v39 += 4;
              v38 = v38 + v46 + v47 * *(float *)&v43 + v48 * (float)(v45 - v35->f32[3]);
              v35 += v18;
            }
            while (v39 <= (int)v16 - 4);
            v37 = ((v16 - 4) & 0xFFFFFFFC) + 4;
          }
          else
          {
            v37 = 0;
            v38 = 0.0;
          }
          if (v37 < (int)v15)
          {
            v49 = &v32[v37];
            v50 = &result[v37];
            do
            {
              v51 = *v50++;
              v52 = v51;
              v53 = *v49++;
              v54 = v53;
              v55 = v35->f32[0];
              v35 = (float32x4_t *)((char *)v35 + 4);
              v38 = v38 + v52 * (float)(v54 - v55);
              ++v37;
            }
            while ((int)v15 > v37);
          }
          v56 = v38 * v5;
          *(float *)(v8 + 4 * v34++) = v56;
          v33 = (float *)((char *)v33 + v20);
          v32 = (float *)((char *)v32 + v20);
        }
        while (v34 != v14);
        v8 += 4 * v11;
        ++v19;
        v22 += v12;
        v6 = (float *)((char *)v6 + v20);
        v21 = (float *)((char *)v21 + v20);
      }
      while (v19 != v14);
    }
    if (result != (float *)v78)
      return (float *)MEMORY[0x2207351A4](result, 0x1000C8077774924);
  }
  else if ((int)v14 >= 1)
  {
    v57 = 0;
    v58 = v6 + 2;
    v59 = 4 * v10;
    do
    {
      v60 = v6;
      v61 = v58;
      v62 = v57;
      do
      {
        if ((int)v15 >= 4)
        {
          v65 = 0;
          v64 = 0.0;
          v66 = v61;
          result = v58;
          do
          {
            v67 = *(result - 1) * *(v66 - 1) + *(result - 2) * *(v66 - 2);
            v68 = *result;
            v69 = result[1];
            result += 4;
            v70 = *v66;
            v71 = v66[1];
            v66 += 4;
            v64 = v64 + v67 + v68 * v70 + v69 * v71;
            v65 += 4;
          }
          while (v65 <= (int)v16 - 4);
          v63 = ((v16 - 4) & 0xFFFFFFFC) + 4;
        }
        else
        {
          v63 = 0;
          v64 = 0.0;
        }
        if (v63 < (int)v16)
        {
          v72 = &v60[v63];
          result = &v6[v63];
          do
          {
            v73 = *result++;
            v74 = v73;
            v75 = *v72++;
            v64 = v64 + v74 * v75;
            ++v63;
          }
          while ((int)v16 > v63);
        }
        v76 = v64 * v5;
        *(float *)(v8 + 4 * v62++) = v76;
        v61 = (float *)((char *)v61 + v59);
        v60 = (float *)((char *)v60 + v59);
      }
      while (v62 < v14);
      ++v57;
      v8 += 4 * v11;
      v58 = (float *)((char *)v58 + v59);
      v6 = (float *)((char *)v6 + v59);
    }
    while (v57 != v14);
  }
  return result;
}

double *cv::MulTransposedR<float,double>(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  uint64_t v3;
  double v4;
  double v5;
  float *v6;
  uint64_t v7;
  uint64_t v8;
  double *v9;
  unint64_t v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  unsigned int *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  char v19;
  unsigned int v20;
  double *result;
  unint64_t v22;
  unint64_t v23;
  double *v24;
  double *v25;
  uint64_t v26;
  double v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  float32x2_t *v32;
  double *v33;
  float *v34;
  uint64_t v35;
  float *v36;
  double *v37;
  double *v38;
  uint64_t v39;
  float *v40;
  double *v41;
  double *v42;
  float32x2_t *v43;
  uint64_t v44;
  float64x2_t *v45;
  float64x2_t *v46;
  float64x2_t v47;
  float32x2_t *v48;
  uint64_t v49;
  const double *v50;
  float64x2_t v51;
  float64x2_t v52;
  float64x2_t *v53;
  float *v54;
  double *v55;
  double v56;
  float *v57;
  uint64_t v58;
  double *v59;
  double v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  float32x2_t *v64;
  float *v65;
  uint64_t v66;
  float *v67;
  double *v68;
  float32x2_t *v69;
  uint64_t v70;
  float64x2_t v71;
  float32x2_t *v72;
  uint64_t v73;
  const double *v74;
  float64x2_t v75;
  float64x2_t v76;
  float64x2_t *v77;
  float *v78;
  double v79;
  float *v80;
  uint64_t v81;
  double *v82;
  double v83;
  double v84;
  _QWORD v85[517];

  v2 = (_QWORD *)MEMORY[0x24BDAC7A8](a1, a2);
  v5 = v4;
  v85[515] = *MEMORY[0x24BDAC8D0];
  v6 = (float *)v2[2];
  v8 = *(_QWORD *)(v7 + 16);
  v9 = *(double **)(v3 + 16);
  v10 = v2[10];
  v11 = *(_QWORD *)(v7 + 80);
  v12 = *(_DWORD *)(v3 + 12);
  if (*(int *)(v3 + 8) <= 1)
    v13 = 0;
  else
    v13 = *(_QWORD *)(v3 + 80) >> 3;
  v14 = (unsigned int *)v2[8];
  v16 = (int)*v14;
  v15 = (int)v14[1];
  v17 = *v14;
  if (v9)
    v18 = v12 < (int)v15;
  else
    v18 = 0;
  v19 = !v18;
  if (v18)
  {
    if (v12 != 1)
      __assert_rtn("MulTransposedR", "matmul.cpp", 2360, "delta_cols == 1");
    v20 = 40 * v17;
  }
  else
  {
    v20 = 8 * v16;
  }
  result = (double *)v85;
  if (v20 >= 0x1009)
  {
    v84 = v4;
    result = (double *)operator new[]();
    v5 = v84;
  }
  v22 = v10 >> 2;
  v23 = v11 >> 3;
  if ((v19 & 1) == 0)
  {
    v24 = &result[v16];
    if ((int)v16 >= 1)
    {
      v25 = v24 + 2;
      v26 = v17;
      do
      {
        v27 = *v9;
        *v25 = *v9;
        v25[1] = v27;
        *(v25 - 2) = v27;
        *(v25 - 1) = v27;
        v9 += v13;
        v25 += 4;
        --v26;
      }
      while (v26);
    }
    v13 = 4 * (v13 != 0);
    v9 = &result[v16];
    goto LABEL_23;
  }
  if (v9)
  {
    v24 = 0;
LABEL_23:
    if ((int)v15 >= 1)
    {
      v28 = 0;
      v29 = v15 - 4;
      v30 = 8 * v13;
      v31 = 4 * v22;
      v32 = (float32x2_t *)(v6 + 2);
      v33 = v9;
      v34 = v6;
      do
      {
        if (v24)
        {
          v35 = v17;
          v36 = v34;
          v37 = v24;
          v38 = result;
          if ((int)v16 >= 1)
          {
            do
            {
              *v38++ = *v36 - *v37;
              v37 = (double *)((char *)v37 + v30);
              v36 = (float *)((char *)v36 + v31);
              --v35;
            }
            while (v35);
          }
        }
        else if ((int)v17 >= 1)
        {
          v39 = v17;
          v40 = v34;
          v41 = v33;
          v42 = result;
          do
          {
            *v42++ = *v40 - *v41;
            v41 = (double *)((char *)v41 + v30);
            v40 = (float *)((char *)v40 + v31);
            --v39;
          }
          while (v39);
        }
        v43 = v32;
        v44 = v28;
        if (v28 <= v29)
        {
          do
          {
            if ((int)v16 < 1)
            {
              v47 = 0uLL;
              v51 = 0uLL;
            }
            else
            {
              v45 = (float64x2_t *)&v9[v44];
              if (v24)
                v45 = (float64x2_t *)v24;
              v46 = v45 + 1;
              v47 = 0uLL;
              v48 = v43;
              v49 = v17;
              v50 = result;
              v51 = 0uLL;
              do
              {
                v52 = vld1q_dup_f64(v50++);
                v47 = vmlaq_f64(v47, vsubq_f64(vcvtq_f64_f32(v48[-1]), v46[-1]), v52);
                v51 = vmlaq_f64(v51, vsubq_f64(vcvtq_f64_f32(*v48), *v46), v52);
                v46 = (float64x2_t *)((char *)v46 + v30);
                v48 = (float32x2_t *)((char *)v48 + v31);
                --v49;
              }
              while (v49);
            }
            v53 = (float64x2_t *)(v8 + 8 * v44);
            *v53 = vmulq_n_f64(v47, v5);
            v53[1] = vmulq_n_f64(v51, v5);
            v44 += 4;
            v43 += 2;
          }
          while ((int)v29 >= (int)v44);
          v44 = v44;
        }
        else
        {
          v44 = v28;
        }
        if ((int)v44 < (int)v15)
        {
          v54 = &v6[v44];
          do
          {
            if ((int)v17 < 1)
            {
              v56 = 0.0;
            }
            else
            {
              v55 = &v9[v44];
              if (v24)
                v55 = v24;
              v56 = 0.0;
              v57 = v54;
              v58 = v17;
              v59 = result;
              do
              {
                v60 = *v59++;
                v56 = v56 + v60 * (*v57 - *v55);
                v55 = (double *)((char *)v55 + v30);
                v57 = (float *)((char *)v57 + v31);
                --v58;
              }
              while (v58);
            }
            *(double *)(v8 + 8 * v44++) = v56 * v5;
            ++v54;
          }
          while ((int)v15 > (int)v44);
        }
        v8 += 8 * v23;
        ++v28;
        ++v34;
        ++v33;
        v32 = (float32x2_t *)((char *)v32 + 4);
      }
      while (v28 != v15);
    }
    goto LABEL_54;
  }
  if ((int)v15 >= 1)
  {
    v61 = 0;
    v62 = v15 - 4;
    v63 = 4 * v22;
    v64 = (float32x2_t *)(v6 + 2);
    v65 = v6;
    do
    {
      v66 = v16;
      v67 = v65;
      v68 = result;
      if ((int)v17 >= 1)
      {
        do
        {
          *v68++ = *v67;
          v67 = (float *)((char *)v67 + v63);
          --v66;
        }
        while (v66);
      }
      v69 = v64;
      v70 = v61;
      if (v61 <= v62)
      {
        do
        {
          v71 = 0uLL;
          if ((int)v16 < 1)
          {
            v75 = 0uLL;
          }
          else
          {
            v72 = v69;
            v73 = v16;
            v74 = result;
            v75 = 0uLL;
            do
            {
              v76 = vld1q_dup_f64(v74++);
              v71 = vmlaq_f64(v71, vcvtq_f64_f32(v72[-1]), v76);
              v75 = vmlaq_f64(v75, vcvtq_f64_f32(*v72), v76);
              v72 = (float32x2_t *)((char *)v72 + v63);
              --v73;
            }
            while (v73);
          }
          v77 = (float64x2_t *)(v8 + 8 * v70);
          *v77 = vmulq_n_f64(v71, v5);
          v77[1] = vmulq_n_f64(v75, v5);
          v70 += 4;
          v69 += 2;
        }
        while ((int)v62 >= (int)v70);
        v70 = v70;
      }
      else
      {
        v70 = v61;
      }
      if ((int)v70 < (int)v15)
      {
        v78 = &v6[v70];
        do
        {
          v79 = 0.0;
          if ((int)v17 >= 1)
          {
            v80 = v78;
            v81 = v16;
            v82 = result;
            do
            {
              v83 = *v82++;
              v79 = v79 + v83 * *v80;
              v80 = (float *)((char *)v80 + v63);
              --v81;
            }
            while (v81);
          }
          *(double *)(v8 + 8 * v70++) = v79 * v5;
          ++v78;
        }
        while ((int)v15 > (int)v70);
      }
      ++v61;
      v8 += 8 * v23;
      ++v65;
      v64 = (float32x2_t *)((char *)v64 + 4);
    }
    while (v61 != v15);
  }
LABEL_54:
  if (result != (double *)v85)
    return (double *)MEMORY[0x2207351A4](result, 0x1000C8077774924);
  return result;
}

float *cv::MulTransposedL<float,double>(uint64_t a1, uint64_t a2)
{
  float *result;
  uint64_t v3;
  double v4;
  double v5;
  float *v6;
  uint64_t v7;
  uint64_t v8;
  double *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  _BOOL4 v18;
  uint64_t v19;
  uint64_t v20;
  float *v21;
  double *v22;
  uint64_t v23;
  double v24;
  uint64_t v25;
  float *v26;
  double *v27;
  double *v28;
  float v29;
  double v30;
  double v31;
  float *v32;
  float *v33;
  uint64_t v34;
  double *v35;
  int v36;
  double v37;
  uint64_t v38;
  float *v39;
  double *v40;
  double v41;
  float v42;
  float v43;
  double v44;
  double v45;
  float *v46;
  double *v47;
  double v48;
  double v49;
  double v50;
  double v51;
  unint64_t v52;
  float *v53;
  uint64_t v54;
  float *v55;
  float *v56;
  unint64_t v57;
  int v58;
  double v59;
  uint64_t v60;
  float *v61;
  double v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float *v67;
  float v68;
  double v69;
  float v70;
  uint64_t v71;
  _BYTE v72[4120];
  _QWORD v73[2];
  double v74;
  double v75;
  uint64_t v76;

  result = (float *)MEMORY[0x24BDAC7A8](a1, a2);
  v5 = v4;
  v76 = *MEMORY[0x24BDAC8D0];
  v6 = (float *)*((_QWORD *)result + 2);
  v8 = *(_QWORD *)(v7 + 16);
  v9 = *(double **)(v3 + 16);
  v10 = *((_QWORD *)result + 10) >> 2;
  v11 = *(_QWORD *)(v7 + 80) >> 3;
  if (*(int *)(v3 + 8) <= 1)
    v12 = 0;
  else
    v12 = *(_QWORD *)(v3 + 80) >> 3;
  v13 = (unsigned int *)*((_QWORD *)result + 8);
  v14 = *v13;
  v15 = (int)v13[1];
  v16 = v13[1];
  if (v9)
  {
    v17 = *(_DWORD *)(v3 + 12);
    v18 = v17 == v15;
    result = (float *)v72;
    if ((unint64_t)(8 * v15) >= 0x1009)
    {
      v71 = v10;
      result = (float *)operator new[]();
      v18 = v17 == v15;
      v10 = v71;
    }
    if ((int)v14 >= 1)
    {
      v19 = 0;
      v20 = 4 * v10;
      v21 = v6 + 2;
      v22 = v9;
      do
      {
        if (v17 >= (int)v16)
        {
          v25 = v16;
          v26 = v6;
          v27 = v22;
          v28 = (double *)result;
          if ((int)v16 >= 1)
          {
            do
            {
              v29 = *v26++;
              v30 = v29;
              v31 = *v27++;
              *v28++ = v30 - v31;
              --v25;
            }
            while (v25);
          }
        }
        else if ((int)v15 >= 1)
        {
          v23 = 0;
          v24 = v9[v12 * v19];
          do
          {
            *(double *)&result[2 * v23] = v6[v23] - v24;
            ++v23;
          }
          while (v16 != v23);
        }
        v32 = v6;
        v33 = v21;
        v34 = v19;
        do
        {
          v35 = &v9[v12 * v34];
          if (v17 < (int)v15)
          {
            v74 = *v35;
            v75 = v74;
            *(double *)v73 = v74;
            *(double *)&v73[1] = v74;
            v35 = (double *)v73;
          }
          if ((int)v16 >= 4)
          {
            v38 = 0;
            v37 = 0.0;
            v39 = v33;
            v40 = (double *)(result + 4);
            do
            {
              v41 = *(v40 - 1) * (*(v39 - 1) - v35[1]) + *(v40 - 2) * (*(v39 - 2) - *v35);
              v42 = *v39;
              v43 = v39[1];
              v39 += 4;
              v44 = *v40;
              v45 = v40[1];
              v40 += 4;
              v38 += 4;
              v37 = v37 + v41 + v44 * (v42 - v35[2]) + v45 * (v43 - v35[3]);
              v35 += 4 * v18;
            }
            while (v38 <= (int)v16 - 4);
            v36 = ((v16 - 4) & 0xFFFFFFFC) + 4;
          }
          else
          {
            v36 = 0;
            v37 = 0.0;
          }
          if (v36 < (int)v15)
          {
            v46 = &v32[v36];
            v47 = (double *)&result[2 * v36];
            do
            {
              v48 = *v47++;
              v49 = v48;
              *(float *)&v48 = *v46++;
              v50 = *(float *)&v48;
              v51 = *v35++;
              v37 = v37 + v49 * (v50 - v51);
              ++v36;
            }
            while ((int)v15 > v36);
          }
          *(double *)(v8 + 8 * v34++) = v37 * v5;
          v33 = (float *)((char *)v33 + v20);
          v32 = (float *)((char *)v32 + v20);
        }
        while (v34 != v14);
        v8 += 8 * v11;
        ++v19;
        v22 += v12;
        v6 = (float *)((char *)v6 + v20);
        v21 = (float *)((char *)v21 + v20);
      }
      while (v19 != v14);
    }
    if (result != (float *)v72)
      return (float *)MEMORY[0x2207351A4](result, 0x1000C8077774924);
  }
  else if ((int)v14 >= 1)
  {
    v52 = 0;
    v53 = v6 + 2;
    v54 = 4 * v10;
    do
    {
      v55 = v6;
      v56 = v53;
      v57 = v52;
      do
      {
        if ((int)v15 >= 4)
        {
          v60 = 0;
          v59 = 0.0;
          v61 = v56;
          result = v53;
          do
          {
            v62 = *(result - 1) * *(v61 - 1) + *(result - 2) * *(v61 - 2);
            v63 = *result;
            v64 = result[1];
            result += 4;
            v65 = *v61;
            v66 = v61[1];
            v61 += 4;
            v59 = v59 + v62 + v63 * v65 + v64 * v66;
            v60 += 4;
          }
          while (v60 <= (int)v16 - 4);
          v58 = ((v16 - 4) & 0xFFFFFFFC) + 4;
        }
        else
        {
          v58 = 0;
          v59 = 0.0;
        }
        if (v58 < (int)v16)
        {
          v67 = &v55[v58];
          result = &v6[v58];
          do
          {
            v68 = *result++;
            v69 = v68;
            v70 = *v67++;
            v59 = v59 + v69 * v70;
            ++v58;
          }
          while ((int)v16 > v58);
        }
        *(double *)(v8 + 8 * v57++) = v59 * v5;
        v56 = (float *)((char *)v56 + v54);
        v55 = (float *)((char *)v55 + v54);
      }
      while (v57 < v14);
      ++v52;
      v8 += 8 * v11;
      v53 = (float *)((char *)v53 + v54);
      v6 = (float *)((char *)v6 + v54);
    }
    while (v52 != v14);
  }
  return result;
}

double *cv::MulTransposedR<double,double>(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  uint64_t v3;
  double v4;
  double v5;
  double *v6;
  uint64_t v7;
  uint64_t v8;
  double *v9;
  unint64_t v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  unsigned int *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  char v19;
  unsigned int v20;
  double *result;
  unint64_t v22;
  unint64_t v23;
  double *v24;
  double *v25;
  uint64_t v26;
  double v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  float64x2_t *v32;
  double *v33;
  double *v34;
  uint64_t v35;
  double *v36;
  double *v37;
  double *v38;
  uint64_t v39;
  double *v40;
  double *v41;
  double *v42;
  float64x2_t *v43;
  uint64_t v44;
  float64x2_t *v45;
  float64x2_t *v46;
  float64x2_t v47;
  float64x2_t *v48;
  uint64_t v49;
  const double *v50;
  float64x2_t v51;
  float64x2_t v52;
  float64x2_t *v53;
  double *v54;
  double *v55;
  double v56;
  double *v57;
  uint64_t v58;
  double *v59;
  double v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  float64x2_t *v64;
  double *v65;
  uint64_t v66;
  double *v67;
  double *v68;
  float64x2_t *v69;
  uint64_t v70;
  float64x2_t v71;
  float64x2_t *v72;
  uint64_t v73;
  const double *v74;
  float64x2_t v75;
  float64x2_t v76;
  float64x2_t *v77;
  double *v78;
  double v79;
  double *v80;
  uint64_t v81;
  double *v82;
  double v83;
  double v84;
  _QWORD v85[517];

  v2 = (_QWORD *)MEMORY[0x24BDAC7A8](a1, a2);
  v5 = v4;
  v85[515] = *MEMORY[0x24BDAC8D0];
  v6 = (double *)v2[2];
  v8 = *(_QWORD *)(v7 + 16);
  v9 = *(double **)(v3 + 16);
  v10 = v2[10];
  v11 = *(_QWORD *)(v7 + 80);
  v12 = *(_DWORD *)(v3 + 12);
  if (*(int *)(v3 + 8) <= 1)
    v13 = 0;
  else
    v13 = *(_QWORD *)(v3 + 80) >> 3;
  v14 = (unsigned int *)v2[8];
  v16 = (int)*v14;
  v15 = (int)v14[1];
  v17 = *v14;
  if (v9)
    v18 = v12 < (int)v15;
  else
    v18 = 0;
  v19 = !v18;
  if (v18)
  {
    if (v12 != 1)
      __assert_rtn("MulTransposedR", "matmul.cpp", 2360, "delta_cols == 1");
    v20 = 40 * v17;
  }
  else
  {
    v20 = 8 * v16;
  }
  result = (double *)v85;
  if (v20 >= 0x1009)
  {
    v84 = v4;
    result = (double *)operator new[]();
    v5 = v84;
  }
  v22 = v10 >> 3;
  v23 = v11 >> 3;
  if ((v19 & 1) == 0)
  {
    v24 = &result[v16];
    if ((int)v16 >= 1)
    {
      v25 = v24 + 2;
      v26 = v17;
      do
      {
        v27 = *v9;
        *v25 = *v9;
        v25[1] = v27;
        *(v25 - 2) = v27;
        *(v25 - 1) = v27;
        v9 += v13;
        v25 += 4;
        --v26;
      }
      while (v26);
    }
    v13 = 4 * (v13 != 0);
    v9 = &result[v16];
    goto LABEL_23;
  }
  if (v9)
  {
    v24 = 0;
LABEL_23:
    if ((int)v15 >= 1)
    {
      v28 = 0;
      v29 = v15 - 4;
      v30 = 8 * v13;
      v31 = 8 * v22;
      v32 = (float64x2_t *)(v6 + 2);
      v33 = v9;
      v34 = v6;
      do
      {
        if (v24)
        {
          v35 = v17;
          v36 = v34;
          v37 = v24;
          v38 = result;
          if ((int)v16 >= 1)
          {
            do
            {
              *v38++ = *v36 - *v37;
              v37 = (double *)((char *)v37 + v30);
              v36 = (double *)((char *)v36 + v31);
              --v35;
            }
            while (v35);
          }
        }
        else if ((int)v17 >= 1)
        {
          v39 = v17;
          v40 = v34;
          v41 = v33;
          v42 = result;
          do
          {
            *v42++ = *v40 - *v41;
            v41 = (double *)((char *)v41 + v30);
            v40 = (double *)((char *)v40 + v31);
            --v39;
          }
          while (v39);
        }
        v43 = v32;
        v44 = v28;
        if (v28 <= v29)
        {
          do
          {
            if ((int)v16 < 1)
            {
              v47 = 0uLL;
              v51 = 0uLL;
            }
            else
            {
              v45 = (float64x2_t *)&v9[v44];
              if (v24)
                v45 = (float64x2_t *)v24;
              v46 = v45 + 1;
              v47 = 0uLL;
              v48 = v43;
              v49 = v17;
              v50 = result;
              v51 = 0uLL;
              do
              {
                v52 = vld1q_dup_f64(v50++);
                v47 = vmlaq_f64(v47, vsubq_f64(v48[-1], v46[-1]), v52);
                v51 = vmlaq_f64(v51, vsubq_f64(*v48, *v46), v52);
                v46 = (float64x2_t *)((char *)v46 + v30);
                v48 = (float64x2_t *)((char *)v48 + v31);
                --v49;
              }
              while (v49);
            }
            v53 = (float64x2_t *)(v8 + 8 * v44);
            *v53 = vmulq_n_f64(v47, v5);
            v53[1] = vmulq_n_f64(v51, v5);
            v44 += 4;
            v43 += 2;
          }
          while ((int)v29 >= (int)v44);
          v44 = v44;
        }
        else
        {
          v44 = v28;
        }
        if ((int)v44 < (int)v15)
        {
          v54 = &v6[v44];
          do
          {
            if ((int)v17 < 1)
            {
              v56 = 0.0;
            }
            else
            {
              v55 = &v9[v44];
              if (v24)
                v55 = v24;
              v56 = 0.0;
              v57 = v54;
              v58 = v17;
              v59 = result;
              do
              {
                v60 = *v59++;
                v56 = v56 + v60 * (*v57 - *v55);
                v55 = (double *)((char *)v55 + v30);
                v57 = (double *)((char *)v57 + v31);
                --v58;
              }
              while (v58);
            }
            *(double *)(v8 + 8 * v44++) = v56 * v5;
            ++v54;
          }
          while ((int)v15 > (int)v44);
        }
        v8 += 8 * v23;
        ++v28;
        ++v34;
        ++v33;
        v32 = (float64x2_t *)((char *)v32 + 8);
      }
      while (v28 != v15);
    }
    goto LABEL_54;
  }
  if ((int)v15 >= 1)
  {
    v61 = 0;
    v62 = v15 - 4;
    v63 = 8 * v22;
    v64 = (float64x2_t *)(v6 + 2);
    v65 = v6;
    do
    {
      v66 = v16;
      v67 = v65;
      v68 = result;
      if ((int)v17 >= 1)
      {
        do
        {
          *v68++ = *v67;
          v67 = (double *)((char *)v67 + v63);
          --v66;
        }
        while (v66);
      }
      v69 = v64;
      v70 = v61;
      if (v61 <= v62)
      {
        do
        {
          v71 = 0uLL;
          if ((int)v16 < 1)
          {
            v75 = 0uLL;
          }
          else
          {
            v72 = v69;
            v73 = v16;
            v74 = result;
            v75 = 0uLL;
            do
            {
              v76 = vld1q_dup_f64(v74++);
              v71 = vmlaq_f64(v71, v72[-1], v76);
              v75 = vmlaq_f64(v75, *v72, v76);
              v72 = (float64x2_t *)((char *)v72 + v63);
              --v73;
            }
            while (v73);
          }
          v77 = (float64x2_t *)(v8 + 8 * v70);
          *v77 = vmulq_n_f64(v71, v5);
          v77[1] = vmulq_n_f64(v75, v5);
          v70 += 4;
          v69 += 2;
        }
        while ((int)v62 >= (int)v70);
        v70 = v70;
      }
      else
      {
        v70 = v61;
      }
      if ((int)v70 < (int)v15)
      {
        v78 = &v6[v70];
        do
        {
          v79 = 0.0;
          if ((int)v17 >= 1)
          {
            v80 = v78;
            v81 = v16;
            v82 = result;
            do
            {
              v83 = *v82++;
              v79 = v79 + v83 * *v80;
              v80 = (double *)((char *)v80 + v63);
              --v81;
            }
            while (v81);
          }
          *(double *)(v8 + 8 * v70++) = v79 * v5;
          ++v78;
        }
        while ((int)v15 > (int)v70);
      }
      ++v61;
      v8 += 8 * v23;
      ++v65;
      v64 = (float64x2_t *)((char *)v64 + 8);
    }
    while (v61 != v15);
  }
LABEL_54:
  if (result != (double *)v85)
    return (double *)MEMORY[0x2207351A4](result, 0x1000C8077774924);
  return result;
}

double *cv::MulTransposedL<double,double>(uint64_t a1, uint64_t a2)
{
  double *result;
  uint64_t v3;
  double v4;
  double v5;
  double *v6;
  uint64_t v7;
  uint64_t v8;
  double *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  _BOOL4 v18;
  uint64_t v19;
  uint64_t v20;
  double *v21;
  double *v22;
  uint64_t v23;
  double v24;
  uint64_t v25;
  double *v26;
  double *v27;
  double *v28;
  double v29;
  double v30;
  double v31;
  double *v32;
  double *v33;
  uint64_t v34;
  double *v35;
  int v36;
  double v37;
  uint64_t v38;
  double *v39;
  double *v40;
  double v41;
  double v42;
  double v43;
  double v44;
  double v45;
  double *v46;
  double *v47;
  double v48;
  double v49;
  double v50;
  double v51;
  double v52;
  unint64_t v53;
  double *v54;
  uint64_t v55;
  double *v56;
  double *v57;
  unint64_t v58;
  int v59;
  double v60;
  uint64_t v61;
  double *v62;
  double v63;
  double v64;
  double v65;
  double v66;
  double v67;
  double *v68;
  double v69;
  double v70;
  double v71;
  uint64_t v72;
  _BYTE v73[4120];
  _QWORD v74[2];
  double v75;
  double v76;
  uint64_t v77;

  result = (double *)MEMORY[0x24BDAC7A8](a1, a2);
  v5 = v4;
  v77 = *MEMORY[0x24BDAC8D0];
  v6 = (double *)*((_QWORD *)result + 2);
  v8 = *(_QWORD *)(v7 + 16);
  v9 = *(double **)(v3 + 16);
  v10 = *((_QWORD *)result + 10) >> 3;
  v11 = *(_QWORD *)(v7 + 80) >> 3;
  if (*(int *)(v3 + 8) <= 1)
    v12 = 0;
  else
    v12 = *(_QWORD *)(v3 + 80) >> 3;
  v13 = (unsigned int *)*((_QWORD *)result + 8);
  v14 = *v13;
  v15 = (int)v13[1];
  v16 = v13[1];
  if (v9)
  {
    v17 = *(_DWORD *)(v3 + 12);
    v18 = v17 == v15;
    result = (double *)v73;
    if ((unint64_t)(8 * v15) >= 0x1009)
    {
      v72 = v10;
      result = (double *)operator new[]();
      v18 = v17 == v15;
      v10 = v72;
    }
    if ((int)v14 >= 1)
    {
      v19 = 0;
      v20 = 8 * v10;
      v21 = v6 + 2;
      v22 = v9;
      do
      {
        if (v17 >= (int)v16)
        {
          v25 = v16;
          v26 = v6;
          v27 = v22;
          v28 = result;
          if ((int)v16 >= 1)
          {
            do
            {
              v29 = *v26++;
              v30 = v29;
              v31 = *v27++;
              *v28++ = v30 - v31;
              --v25;
            }
            while (v25);
          }
        }
        else if ((int)v15 >= 1)
        {
          v23 = 0;
          v24 = v9[v12 * v19];
          do
          {
            result[v23] = v6[v23] - v24;
            ++v23;
          }
          while (v16 != v23);
        }
        v32 = v6;
        v33 = v21;
        v34 = v19;
        do
        {
          v35 = &v9[v12 * v34];
          if (v17 < (int)v15)
          {
            v75 = *v35;
            v76 = v75;
            *(double *)v74 = v75;
            *(double *)&v74[1] = v75;
            v35 = (double *)v74;
          }
          if ((int)v16 >= 4)
          {
            v38 = 0;
            v37 = 0.0;
            v39 = v33;
            v40 = result + 2;
            do
            {
              v41 = *(v40 - 1) * (*(v39 - 1) - v35[1]) + *(v40 - 2) * (*(v39 - 2) - *v35);
              v42 = *v39;
              v43 = v39[1];
              v39 += 4;
              v44 = *v40;
              v45 = v40[1];
              v40 += 4;
              v38 += 4;
              v37 = v37 + v41 + v44 * (v42 - v35[2]) + v45 * (v43 - v35[3]);
              v35 += 4 * v18;
            }
            while (v38 <= (int)v16 - 4);
            v36 = ((v16 - 4) & 0xFFFFFFFC) + 4;
          }
          else
          {
            v36 = 0;
            v37 = 0.0;
          }
          if (v36 < (int)v15)
          {
            v46 = &v32[v36];
            v47 = &result[v36];
            do
            {
              v48 = *v47++;
              v49 = v48;
              v50 = *v46++;
              v51 = v50;
              v52 = *v35++;
              v37 = v37 + v49 * (v51 - v52);
              ++v36;
            }
            while ((int)v15 > v36);
          }
          *(double *)(v8 + 8 * v34++) = v37 * v5;
          v33 = (double *)((char *)v33 + v20);
          v32 = (double *)((char *)v32 + v20);
        }
        while (v34 != v14);
        v8 += 8 * v11;
        ++v19;
        v22 += v12;
        v6 = (double *)((char *)v6 + v20);
        v21 = (double *)((char *)v21 + v20);
      }
      while (v19 != v14);
    }
    if (result != (double *)v73)
      return (double *)MEMORY[0x2207351A4](result, 0x1000C8077774924);
  }
  else if ((int)v14 >= 1)
  {
    v53 = 0;
    v54 = v6 + 2;
    v55 = 8 * v10;
    do
    {
      v56 = v6;
      v57 = v54;
      v58 = v53;
      do
      {
        if ((int)v15 >= 4)
        {
          v61 = 0;
          v60 = 0.0;
          v62 = v57;
          result = v54;
          do
          {
            v63 = *(result - 1) * *(v62 - 1) + *(result - 2) * *(v62 - 2);
            v64 = *result;
            v65 = result[1];
            result += 4;
            v66 = *v62;
            v67 = v62[1];
            v62 += 4;
            v60 = v60 + v63 + v64 * v66 + v65 * v67;
            v61 += 4;
          }
          while (v61 <= (int)v16 - 4);
          v59 = ((v16 - 4) & 0xFFFFFFFC) + 4;
        }
        else
        {
          v59 = 0;
          v60 = 0.0;
        }
        if (v59 < (int)v16)
        {
          v68 = &v56[v59];
          result = &v6[v59];
          do
          {
            v69 = *result++;
            v70 = v69;
            v71 = *v68++;
            v60 = v60 + v70 * v71;
            ++v59;
          }
          while ((int)v16 > v59);
        }
        *(double *)(v8 + 8 * v58++) = v60 * v5;
        v57 = (double *)((char *)v57 + v55);
        v56 = (double *)((char *)v56 + v55);
      }
      while (v58 < v14);
      ++v53;
      v8 += 8 * v11;
      v54 = (double *)((char *)v54 + v55);
      v6 = (double *)((char *)v6 + v55);
    }
    while (v53 != v14);
  }
  return result;
}

void cv::mulTransposed(cv::Exception *a1, uint64_t a2, uint64_t a3, void **a4)
{
  cv::Exception::~Exception(a1);
  if (*(char *)(a2 + 23) < 0)
    operator delete(*(void **)a2);
  if (*(char *)(a3 + 23) < 0)
    operator delete(*(void **)a3);
  operator delete(*a4);
  __break(1u);
}

uint64_t cv::countNonZero(cv *this, const cv::_InputArray *a2)
{
  uint64_t v2;
  uint64_t (*v3)(cv *__hidden, const unsigned __int8 *, int);
  const cv::Exception *v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int *v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  void *__p[2];
  _BYTE v17[32];
  unint64_t v18;
  unsigned int v19;
  _QWORD v20[3];
  unsigned int *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  cv *v26;
  uint64_t v27;
  unsigned __int8 *v28[2];
  cv::Mat *v29[4];

  v29[3] = *(cv::Mat **)MEMORY[0x24BDAC8D0];
  (**(void (***)(_QWORD *__return_ptr, cv *, uint64_t))this)(v20, this, 0xFFFFFFFFLL);
  v2 = v20[0] & 7;
  v3 = cv::getCountNonZeroTab(int)::countNonZeroTab[v2];
  if ((v20[0] & 0xFF8) != 0 || (_DWORD)v2 == 7)
  {
    std::string::basic_string[abi:ne180100]<0>(v29, "src.channels() == 1 && func != 0");
    std::string::basic_string[abi:ne180100]<0>(v28, "countNonZero");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/stat.cpp");
    cv::Exception::Exception(v17, 4294967081, v29, v28, __p, 549);
    cv::error((cv *)v17, v5);
  }
  v29[0] = (cv::Mat *)v20;
  v29[1] = 0;
  v28[0] = 0;
  cv::NAryMatIterator::NAryMatIterator((cv::NAryMatIterator *)v17, v29, v28, -1);
  v7 = 0;
  v8 = v19;
  v9 = -1;
  while (++v9 < v18)
  {
    v7 = ((unsigned int (*)(unsigned __int8 *, uint64_t))v3)(v28[0], v8) + v7;
    cv::NAryMatIterator::operator++((uint64_t)v17);
  }
  v10 = v21;
  if (v21)
  {
    do
    {
      v11 = __ldaxr(v10);
      v12 = v11 - 1;
    }
    while (__stlxr(v12, v10));
    if (!v12)
      cv::Mat::deallocate((cv::Mat *)v20, v6);
  }
  v20[2] = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  if (SHIDWORD(v20[0]) >= 1)
  {
    v13 = 0;
    v14 = v25;
    do
      *(_DWORD *)(v14 + 4 * v13++) = 0;
    while (v13 < SHIDWORD(v20[0]));
  }
  v21 = 0;
  if (v26 != (cv *)&v27)
    cv::fastFree((void **)v26, v6);
  return v7;
}

void sub_219E5E25C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  uint64_t v31;
  void *v33;

  cv::Exception::~Exception((cv::Exception *)&a16);
  if (a15 < 0)
    operator delete(__p);
  if (*(char *)(v31 - 81) < 0)
    operator delete(*(void **)(v31 - 104));
  if (*(char *)(v31 - 57) < 0)
    operator delete(*(void **)(v31 - 80));
  cv::Mat::~Mat((cv::Mat *)&a31, v33);
  _Unwind_Resume(a1);
}

void cv::mean(cv *this, const cv::_InputArray *a2, const cv::_InputArray *a3)
{
  void (***v3)(_QWORD *__return_ptr, _QWORD, uint64_t);
  void (***v4)(uint64_t *__return_ptr, _QWORD, uint64_t);
  void (***v5)(uint64_t *__return_ptr, _QWORD, uint64_t);
  float64x2_t *v6;
  float64x2_t *v7;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  uint64_t v11;
  const cv::Exception *v12;
  unint64_t v13;
  unint64_t v14;
  unsigned int v15;
  const cv::Exception *v17;
  void *v18;
  uint64_t v19;
  int v20;
  unint64_t v21;
  int v22;
  int v23;
  void *v24;
  void **v25;
  int v26;
  unint64_t v27;
  unint64_t i;
  int v29;
  uint64_t v30;
  unsigned __int8 *v31;
  uint64_t v32;
  int v33;
  void **v34;
  uint64_t v35;
  int *v36;
  double v37;
  float64x2_t v38;
  float64x2_t v39;
  unsigned int *v41;
  unsigned int v42;
  unsigned int v43;
  uint64_t v44;
  int *v45;
  unsigned int *v46;
  unsigned int v47;
  unsigned int v48;
  uint64_t v49;
  uint64_t v50;
  float64x2_t *v51;
  unint64_t v52;
  int v53;
  uint64_t (*v54)(unsigned __int8 *, uint64_t, void **, uint64_t, uint64_t);
  _QWORD v55[2];
  _BYTE v56[4144];
  void *__p[2];
  float64x2_t v58;
  void *v59[4];
  unint64_t v60;
  int v61;
  uint64_t v62;
  int v63;
  int v64;
  uint64_t v65;
  unsigned int *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  int *v70;
  cv *v71;
  uint64_t v72;
  _QWORD v73[3];
  unsigned int *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  void **v79;
  uint64_t v80;
  unsigned __int8 *v81;
  uint64_t v82;
  cv::Mat *v83[6];

  v3 = (void (***)(_QWORD *__return_ptr, _QWORD, uint64_t))MEMORY[0x24BDAC7A8](this, a2);
  v5 = v4;
  v7 = v6;
  v83[3] = *(cv::Mat **)MEMORY[0x24BDAC8D0];
  (**v3)(v73, v3, 0xFFFFFFFFLL);
  (**v5)(&v62, v5, 0xFFFFFFFFLL);
  if (v65)
  {
    v8 = HIDWORD(v62);
    if (SHIDWORD(v62) >= 3)
    {
      v10 = v70;
      v9 = 1;
      do
      {
        v11 = *v10++;
        v9 *= v11;
        --v8;
      }
      while (v8);
    }
    else
    {
      v9 = v64 * (uint64_t)v63;
    }
    if (v9 && (v62 & 0xFFF) != 0)
    {
      std::string::basic_string[abi:ne180100]<0>(v59, "mask.empty() || mask.type() == CV_8U");
      std::string::basic_string[abi:ne180100]<0>(__p, "mean");
      std::string::basic_string[abi:ne180100]<0>(v83, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/stat.cpp");
      cv::Exception::Exception(v55, 4294967081, v59, __p, v83, 565);
      cv::error((cv *)v55, v12);
    }
  }
  v13 = LODWORD(v73[0]);
  v14 = ((unint64_t)LODWORD(v73[0]) >> 3) & 0x1FF;
  v15 = v73[0] & 7;
  v54 = (uint64_t (*)(unsigned __int8 *, uint64_t, void **, uint64_t, uint64_t))*(&cv::getSumFunc(int)::sumTab
                                                                                       + (v73[0] & 7));
  if (v15 == 7 || v14 >= 4)
  {
    std::string::basic_string[abi:ne180100]<0>(v59, "cn <= 4 && func != 0");
    std::string::basic_string[abi:ne180100]<0>(__p, "mean");
    std::string::basic_string[abi:ne180100]<0>(v83, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/stat.cpp");
    cv::Exception::Exception(v55, 4294967081, v59, __p, v83, 645);
    cv::error((cv *)v55, v17);
  }
  v83[0] = (cv::Mat *)v73;
  v83[1] = (cv::Mat *)&v62;
  v83[2] = 0;
  v81 = 0;
  v82 = 0;
  cv::NAryMatIterator::NAryMatIterator((cv::NAryMatIterator *)v59, v83, &v81, -1);
  v19 = (v14 + 1);
  v58 = 0u;
  *(_OWORD *)__p = 0u;
  v20 = v61;
  v55[0] = v56;
  v55[1] = 1032;
  v51 = v7;
  if (v15 > 3)
  {
    v53 = 0;
    v24 = 0;
    v25 = __p;
    v23 = v61;
  }
  else
  {
    v21 = v13 >> 3;
    if (v15 >= 2)
      v22 = 0x8000;
    else
      v22 = 0x800000;
    bzero(v56, 4 * (v21 & 0x1FF) + 4);
    v53 = v22;
    if (v22 >= v20)
      v23 = v20;
    else
      v23 = v22;
    if (v73[0] <= 0)
      v24 = 0;
    else
      v24 = v79[HIDWORD(v73[0]) - 1];
    v25 = (void **)v56;
  }
  v26 = 0;
  v27 = 0;
  for (i = 0; i < v60; i = v52)
  {
    v52 = i + 1;
    if (v20 >= 1)
    {
      v29 = 0;
      v31 = v81;
      v30 = v82;
      do
      {
        if (v23 >= v20 - v29)
          v32 = (v20 - v29);
        else
          v32 = v23;
        v33 = v54(v31, v30, v25, v32, v19);
        v26 += v33;
        if (v15 <= 3 && (v26 + v23 >= v53 || v52 >= v60 && (int)v32 + v29 >= v20))
        {
          v34 = __p;
          v35 = v19;
          v36 = (int *)v25;
          do
          {
            *(double *)v34 = *(double *)v34 + (double)*v36;
            ++v34;
            *v36++ = 0;
            --v35;
          }
          while (v35);
          v26 = 0;
        }
        v31 = &v81[(_QWORD)v24 * (int)v32];
        v81 = v31;
        if (v82)
        {
          v30 = v82 + (int)v32;
          v82 = v30;
        }
        else
        {
          v30 = 0;
        }
        v27 += v33;
        v29 += v23;
      }
      while (v29 < v20);
    }
    cv::NAryMatIterator::operator++((uint64_t)v59);
  }
  if (v27)
    v37 = 1.0 / (double)v27;
  else
    v37 = 0.0;
  v38 = vmulq_n_f64(*(float64x2_t *)__p, v37);
  v39 = vmulq_n_f64(v58, v37);
  *v51 = v38;
  v51[1] = v39;
  if ((_BYTE *)v55[0] != v56 && v55[0] != 0)
    MEMORY[0x2207351A4]();
  v41 = v66;
  if (v66)
  {
    do
    {
      v42 = __ldaxr(v41);
      v43 = v42 - 1;
    }
    while (__stlxr(v43, v41));
    if (!v43)
      cv::Mat::deallocate((cv::Mat *)&v62, v18);
  }
  v65 = 0;
  v67 = 0;
  v69 = 0;
  v68 = 0;
  if (SHIDWORD(v62) >= 1)
  {
    v44 = 0;
    v45 = v70;
    do
      v45[v44++] = 0;
    while (v44 < SHIDWORD(v62));
  }
  v66 = 0;
  if (v71 != (cv *)&v72)
    cv::fastFree((void **)v71, v18);
  v46 = v74;
  if (v74)
  {
    do
    {
      v47 = __ldaxr(v46);
      v48 = v47 - 1;
    }
    while (__stlxr(v48, v46));
    if (!v48)
      cv::Mat::deallocate((cv::Mat *)v73, v18);
  }
  v73[2] = 0;
  v75 = 0;
  v76 = 0;
  v77 = 0;
  if (SHIDWORD(v73[0]) >= 1)
  {
    v49 = 0;
    v50 = v78;
    do
      *(_DWORD *)(v50 + 4 * v49++) = 0;
    while (v49 < SHIDWORD(v73[0]));
  }
  v74 = 0;
  if (v79 != (void **)&v80)
    cv::fastFree(v79, v18);
}

void sub_219E5E874(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  char *v7;
  uint64_t v8;
  void *v10;
  void *v11;
  va_list va;

  va_start(va, a7);
  cv::Exception::~Exception((cv::Exception *)va);
  if (v7[327] < 0)
    operator delete(*(void **)(v8 - 128));
  if (v7[23] < 0)
    operator delete((void *)STACK[0x1070]);
  if (v7[55] < 0)
    operator delete((void *)STACK[0x1090]);
  cv::Mat::~Mat((cv::Mat *)&STACK[0x10D0], v10);
  cv::Mat::~Mat((cv::Mat *)(v8 - 240), v11);
  _Unwind_Resume(a1);
}

void cv::minMaxIdx(cv *this, const cv::_InputArray *a2, double *a3, double *a4, int *a5, int *a6, const cv::_InputArray *a7)
{
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _BOOL4 v17;
  int *v18;
  uint64_t v19;
  const cv::Exception *v20;
  int *v21;
  uint64_t v22;
  unsigned int v23;
  void (*v24)(unsigned __int8 *, uint64_t, float *, float *, void **, uint64_t *, uint64_t, uint64_t);
  const cv::Exception *v25;
  double *v26;
  void *v27;
  double *v28;
  unint64_t *v29;
  float *v30;
  float *v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD *v35;
  uint64_t v36;
  uint64_t v37;
  int *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int *v42;
  uint64_t v43;
  char *v44;
  int *v45;
  double v46;
  unint64_t v47;
  int *v48;
  unint64_t v49;
  int v50;
  unint64_t v51;
  int *v52;
  unint64_t v53;
  int v54;
  unsigned int *v55;
  unsigned int v56;
  unsigned int v57;
  uint64_t v58;
  int *v59;
  unsigned int *v60;
  unsigned int v61;
  unsigned int v62;
  uint64_t v63;
  int *v64;
  int *__b;
  unint64_t v66;
  double v67;
  float v68;
  float v69;
  int v70;
  int v71;
  uint64_t v72;
  void *__p[2];
  _BYTE v74[32];
  unint64_t v75;
  int v76;
  uint64_t v77;
  int v78;
  int v79;
  uint64_t v80;
  unsigned int *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  int *v85;
  cv *v86;
  uint64_t v87;
  uint64_t v88;
  int v89;
  int v90;
  uint64_t v91;
  unsigned int *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  int *v96;
  void **v97;
  uint64_t v98;
  unsigned __int8 *v99;
  uint64_t v100;
  cv::Mat *v101[5];

  v101[3] = *(cv::Mat **)MEMORY[0x24BDAC8D0];
  (**(void (***)(uint64_t *__return_ptr, cv *, uint64_t, double *, double *, int *, int *, const cv::_InputArray *))this)(&v88, this, 0xFFFFFFFFLL, a3, a4, a5, a6, a7);
  (**(void (***)(uint64_t *__return_ptr, int *, uint64_t))a6)(&v77, a6, 0xFFFFFFFFLL);
  v12 = (v88 >> 3) & 0x1FF;
  if (v12)
    goto LABEL_2;
  if (v80)
  {
    v15 = HIDWORD(v77);
    if (SHIDWORD(v77) >= 3)
    {
      v21 = v85;
      v16 = 1;
      do
      {
        v22 = *v21++;
        v16 *= v22;
        --v15;
      }
      while (v15);
    }
    else
    {
      v16 = v79 * (uint64_t)v78;
    }
    if (v16 && (v77 & 0xFFF) != 0)
    {
LABEL_2:
      if (v80)
      {
        v13 = HIDWORD(v77);
        if (SHIDWORD(v77) >= 3)
        {
          v18 = v85;
          v14 = 1;
          do
          {
            v19 = *v18++;
            v14 *= v19;
            --v13;
          }
          while (v13);
        }
        else
        {
          v14 = v79 * (uint64_t)v78;
        }
        v17 = v14 == 0;
        if (a5)
          goto LABEL_15;
      }
      else
      {
        v17 = 1;
        if (a5)
          goto LABEL_15;
      }
      if (!a4 && v17)
        goto LABEL_20;
LABEL_15:
      std::string::basic_string[abi:ne180100]<0>(v101, "(cn == 1 && (mask.empty() || mask.type() == CV_8U)) || (cn >= 1 && mask.empty() && !minIdx && !maxIdx)");
      std::string::basic_string[abi:ne180100]<0>(&v99, "minMaxIdx");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/stat.cpp");
      cv::Exception::Exception(v74, 4294967081, v101, &v99, __p, 1013);
      cv::error((cv *)v74, v20);
    }
  }
LABEL_20:
  v23 = v88 & 7;
  v24 = (void (*)(unsigned __int8 *, uint64_t, float *, float *, void **, uint64_t *, uint64_t, uint64_t))*(&cv::getMinmaxTab(int)::minmaxTab + (v88 & 7));
  if (v23 == 7)
  {
    std::string::basic_string[abi:ne180100]<0>(v101, "func != 0");
    std::string::basic_string[abi:ne180100]<0>(&v99, "minMaxIdx");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/stat.cpp");
    cv::Exception::Exception(v74, 4294967081, v101, &v99, __p, 1092);
    cv::error((cv *)v74, v25);
  }
  __b = a5;
  v26 = a3;
  v101[0] = (cv::Mat *)&v88;
  v101[1] = (cv::Mat *)&v77;
  v101[2] = 0;
  v99 = 0;
  v100 = 0;
  cv::NAryMatIterator::NAryMatIterator((cv::NAryMatIterator *)v74, v101, &v99, -1);
  v70 = 0x80000000;
  v71 = 0x7FFFFFFF;
  v68 = -INFINITY;
  v69 = INFINITY;
  v28 = (double *)&v71;
  if (v23 == 6)
    v28 = &v67;
  v29 = (unint64_t *)&v70;
  v72 = 0;
  __p[0] = 0;
  if (v23 == 6)
    v29 = &v66;
  v66 = 0xFFF0000000000000;
  v67 = INFINITY;
  if (v23 == 5)
    v30 = &v69;
  else
    v30 = (float *)v28;
  if (v23 == 5)
    v31 = &v68;
  else
    v31 = (float *)v29;
  if (v75)
  {
    v32 = 0;
    v33 = (v12 + 1) * v76;
    v34 = 1;
    do
    {
      v24(v99, v100, v30, v31, __p, &v72, v33, v34);
      cv::NAryMatIterator::operator++((uint64_t)v74);
      ++v32;
      v34 += (int)v33;
    }
    while (v32 < v75);
  }
  v35 = v26;
  if (v91)
  {
    v36 = HIDWORD(v88);
    if (SHIDWORD(v88) >= 3)
    {
      v38 = v96;
      v37 = 1;
      do
      {
        v39 = *v38++;
        v37 *= v39;
        --v36;
      }
      while (v36);
    }
    else
    {
      v37 = v90 * (uint64_t)v89;
    }
    if (v37)
    {
      if (!v80)
        goto LABEL_47;
      v40 = HIDWORD(v77);
      if (SHIDWORD(v77) >= 3)
      {
        v42 = v85;
        v41 = 1;
        do
        {
          v43 = *v42++;
          v41 *= v43;
          --v40;
        }
        while (v40);
      }
      else
      {
        v41 = v79 * (uint64_t)v78;
      }
      if (!v41)
      {
LABEL_47:
        if (!__p[0])
          __p[0] = (void *)1;
        if (!v72)
          v72 = 1;
      }
    }
  }
  v44 = (char *)__p[0];
  if (!__p[0])
  {
    v66 = 0;
    v67 = 0.0;
    v45 = __b;
    goto LABEL_58;
  }
  v45 = __b;
  if (v23 == 5)
  {
    v67 = v69;
    v46 = v68;
  }
  else
  {
    if (v23 > 4)
      goto LABEL_58;
    v67 = (double)v71;
    v46 = (double)v70;
  }
  v66 = *(_QWORD *)&v46;
LABEL_58:
  if (a2)
    *(double *)a2 = v67;
  if (v35)
    *v35 = v66;
  if (a4)
  {
    if (v44)
    {
      if (SHIDWORD(v88) >= 1)
      {
        v47 = (unint64_t)(v44 - 1);
        v48 = v96;
        v49 = HIDWORD(v88) + 1;
        do
        {
          v50 = v48[(v49 - 2)];
          *((_DWORD *)a4 + (v49-- - 2)) = v47 % v50;
          v47 /= (unint64_t)v50;
        }
        while (v49 > 1);
      }
    }
    else if (SHIDWORD(v88) >= 1)
    {
      memset(a4, 255, 4 * HIDWORD(v88));
    }
  }
  if (v45)
  {
    if (v72)
    {
      if (SHIDWORD(v88) >= 1)
      {
        v51 = v72 - 1;
        v52 = v96;
        v53 = HIDWORD(v88) + 1;
        do
        {
          v54 = v52[(v53 - 2)];
          v45[(v53-- - 2)] = v51 % v54;
          v51 /= (unint64_t)v54;
        }
        while (v53 > 1);
      }
    }
    else if (SHIDWORD(v88) >= 1)
    {
      memset(v45, 255, 4 * HIDWORD(v88));
    }
  }
  v55 = v81;
  if (v81)
  {
    do
    {
      v56 = __ldaxr(v55);
      v57 = v56 - 1;
    }
    while (__stlxr(v57, v55));
    if (!v57)
      cv::Mat::deallocate((cv::Mat *)&v77, v27);
  }
  v80 = 0;
  v82 = 0;
  v83 = 0;
  v84 = 0;
  if (SHIDWORD(v77) >= 1)
  {
    v58 = 0;
    v59 = v85;
    do
      v59[v58++] = 0;
    while (v58 < SHIDWORD(v77));
  }
  v81 = 0;
  if (v86 != (cv *)&v87)
    cv::fastFree((void **)v86, v27);
  v60 = v92;
  if (v92)
  {
    do
    {
      v61 = __ldaxr(v60);
      v62 = v61 - 1;
    }
    while (__stlxr(v62, v60));
    if (!v62)
      cv::Mat::deallocate((cv::Mat *)&v88, v27);
  }
  v91 = 0;
  v93 = 0;
  v94 = 0;
  v95 = 0;
  if (SHIDWORD(v88) >= 1)
  {
    v63 = 0;
    v64 = v96;
    do
      v64[v63++] = 0;
    while (v63 < SHIDWORD(v88));
  }
  v92 = 0;
  if (v97 != (void **)&v98)
    cv::fastFree(v97, v27);
}

void sub_219E5EF84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
  uint64_t v38;
  void *v40;
  void *v41;

  cv::Exception::~Exception((cv::Exception *)&a23);
  if (a22 < 0)
    operator delete(__p);
  if (*(char *)(v38 - 121) < 0)
    operator delete(*(void **)(v38 - 144));
  if (*(char *)(v38 - 97) < 0)
    operator delete(*(void **)(v38 - 120));
  cv::Mat::~Mat((cv::Mat *)&a38, v40);
  cv::Mat::~Mat((cv::Mat *)(v38 - 240), v41);
  _Unwind_Resume(a1);
}

void cv::minMaxLoc(cv *a1, const cv::_InputArray *a2, double *a3, double *a4, int32x2_t *a5, int *a6)
{
  const cv::_InputArray *v12;
  const cv::Exception *v13;
  void *v14;
  unsigned int *v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  void *__p[2];
  void *v21[2];
  void *v22[2];
  _BYTE v23[120];
  _QWORD v24[3];
  unsigned int *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  void **v30;
  uint64_t v31;

  (**(void (***)(_QWORD *__return_ptr, cv *, uint64_t))a1)(v24, a1, 0xFFFFFFFFLL);
  if (SHIDWORD(v24[0]) >= 3)
  {
    std::string::basic_string[abi:ne180100]<0>(v22, "img.dims <= 2");
    std::string::basic_string[abi:ne180100]<0>(v21, "minMaxLoc");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/stat.cpp");
    cv::Exception::Exception(v23, 4294967081, v22, v21, __p, 1144);
    cv::error((cv *)v23, v13);
  }
  cv::minMaxIdx(a1, a2, a3, a4, (int *)a5, a6, v12);
  if (a4)
    *(int32x2_t *)a4 = vrev64_s32(*(int32x2_t *)a4);
  if (a5)
    *a5 = vrev64_s32(*a5);
  v15 = v25;
  if (v25)
  {
    do
    {
      v16 = __ldaxr(v15);
      v17 = v16 - 1;
    }
    while (__stlxr(v17, v15));
    if (!v17)
      cv::Mat::deallocate((cv::Mat *)v24, v14);
  }
  v24[2] = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0;
  if (SHIDWORD(v24[0]) >= 1)
  {
    v18 = 0;
    v19 = v29;
    do
      *(_DWORD *)(v19 + 4 * v18++) = 0;
    while (v18 < SHIDWORD(v24[0]));
  }
  v25 = 0;
  if (v30 != (void **)&v31)
    cv::fastFree(v30, v14);
}

void sub_219E5F1E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  uint64_t v27;
  void *v29;

  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  cv::Mat::~Mat((cv::Mat *)(v27 - 160), v29);
  _Unwind_Resume(a1);
}

unint64_t cv::sum8u(cv *this, const unsigned __int8 *a2, int32x2_t *a3, unint64_t a4, int a5, double a6, uint8x8_t a7)
{
  __int32 v7;
  __int32 v8;
  __int32 v9;
  uint64_t v10;
  unsigned __int8 *v11;
  uint64_t v13;
  __int32 v14;
  signed int v15;
  int v16;
  cv *v17;
  __int32 v18;
  uint64_t v19;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int32x2_t *v24;
  int32x2_t v25;
  int32x2_t v26;
  __int32 v27;
  __int32 v28;
  __int32 v29;
  unsigned __int8 *v30;
  int v31;
  __int32 v32;
  __int32 v33;
  unsigned __int8 *v34;
  int v35;
  uint64_t v36;
  cv *v37;
  BOOL v38;
  int v39;
  unsigned __int8 *v40;
  uint32x4_t v41;
  int v42;
  cv *v43;

  if (a2)
  {
    if (a5 == 1)
    {
      v18 = a3->i32[0];
      if ((int)a4 < 1)
      {
        a4 = 0;
      }
      else
      {
        v19 = a4;
        a4 = 0;
        do
        {
          if (*a2++)
          {
            v18 += *(unsigned __int8 *)this;
            a4 = (a4 + 1);
          }
          this = (cv *)((char *)this + 1);
          --v19;
        }
        while (v19);
      }
      a3->i32[0] = v18;
    }
    else if (a5 == 3)
    {
      v7 = a3->i32[0];
      v8 = a3->i32[1];
      v9 = a3[1].i32[0];
      if ((int)a4 < 1)
      {
        a4 = 0;
      }
      else
      {
        v10 = a4;
        v11 = (unsigned __int8 *)this + 2;
        a4 = 0;
        do
        {
          if (*a2++)
          {
            v7 += *(v11 - 2);
            v8 += *(v11 - 1);
            v9 += *v11;
            a4 = (a4 + 1);
          }
          v11 += 3;
          --v10;
        }
        while (v10);
      }
      a3->i32[0] = v7;
      a3->i32[1] = v8;
      a3[1].i32[0] = v9;
    }
    else if ((int)a4 < 1)
    {
      return 0;
    }
    else
    {
      v21 = 0;
      v22 = a4;
      a4 = 0;
      do
      {
        if (a2[v21])
        {
          if (a5 >= 4)
          {
            v23 = 0;
            v24 = a3 + 1;
            do
            {
              v25.i32[0] = *((unsigned __int8 *)this + v23);
              v25.i32[1] = *((unsigned __int8 *)this + v23 + 1);
              v24[-1] = vadd_s32(v24[-1], v25);
              v26.i32[0] = *((unsigned __int8 *)this + v23 + 2);
              v26.i32[1] = *((unsigned __int8 *)this + v23 + 3);
              *v24 = vadd_s32(*v24, v26);
              v24 += 2;
              v23 += 4;
            }
            while (v23 <= a5 - 4);
            v23 = v23;
          }
          else
          {
            v23 = 0;
          }
          if ((int)v23 < a5)
          {
            do
            {
              a3->i32[v23] += *((unsigned __int8 *)this + v23);
              ++v23;
            }
            while (a5 != v23);
          }
          a4 = (a4 + 1);
        }
        ++v21;
        this = (cv *)((char *)this + a5);
      }
      while (v21 != v22);
    }
  }
  else
  {
    if (a5 <= 0)
      LODWORD(v13) = -(-a5 & 3);
    else
      LODWORD(v13) = a5 & 3;
    switch((_DWORD)v13)
    {
      case 3:
        v27 = a3->i32[0];
        v28 = a3->i32[1];
        v29 = a3[1].i32[0];
        if ((int)a4 >= 1)
        {
          v30 = (unsigned __int8 *)this + 2;
          v31 = a4;
          do
          {
            v27 += *(v30 - 2);
            v28 += *(v30 - 1);
            v29 += *v30;
            v30 += a5;
            --v31;
          }
          while (v31);
        }
        a3->i32[0] = v27;
        a3->i32[1] = v28;
        a3[1].i32[0] = v29;
        break;
      case 2:
        v32 = a3->i32[0];
        v33 = a3->i32[1];
        if ((int)a4 >= 1)
        {
          v34 = (unsigned __int8 *)this + 1;
          v35 = a4;
          do
          {
            v32 += *(v34 - 1);
            v33 += *v34;
            v34 += a5;
            --v35;
          }
          while (v35);
        }
        a3->i32[0] = v32;
        a3->i32[1] = v33;
        break;
      case 1:
        v14 = a3->i32[0];
        v15 = 0;
        v16 = a4 - 4;
        if ((int)a4 >= 4)
        {
          v36 = 4 * a5;
          v37 = this;
          do
          {
            v14 += *(unsigned __int8 *)v37
                 + *((unsigned __int8 *)v37 + a5)
                 + *((unsigned __int8 *)v37 + 2 * a5)
                 + *((unsigned __int8 *)v37 + 3 * a5);
            v15 += 4;
            v37 = (cv *)((char *)v37 + v36);
          }
          while (v15 <= v16);
          v15 = (v16 & 0xFFFFFFFC) + 4;
          v17 = (cv *)((char *)this + ((v16 >> 2) + 1) * v36);
        }
        else
        {
          v17 = this;
        }
        v38 = __OFSUB__((_DWORD)a4, v15);
        v39 = a4 - v15;
        if (!((v39 < 0) ^ v38 | (v39 == 0)))
        {
          do
          {
            v14 += *(unsigned __int8 *)v17;
            v17 = (cv *)((char *)v17 + a5);
            --v39;
          }
          while (v39);
        }
        a3->i32[0] = v14;
        break;
    }
    if ((int)v13 < a5)
    {
      v13 = (int)v13;
      do
      {
        v40 = (unsigned __int8 *)a3 + 4 * v13;
        v41 = *(uint32x4_t *)v40;
        if ((int)a4 >= 1)
        {
          v42 = a4;
          v43 = this;
          do
          {
            a7.i32[0] = *(_DWORD *)((char *)v43 + v13);
            a7 = (uint8x8_t)vmovl_u8(a7).u64[0];
            v41 = vaddw_u16(v41, (uint16x4_t)a7);
            v43 = (cv *)((char *)v43 + a5);
            --v42;
          }
          while (v42);
        }
        *(uint32x4_t *)v40 = v41;
        v13 += 4;
      }
      while (v13 < a5);
    }
  }
  return a4;
}

unint64_t cv::sum8s(cv *this, const signed __int8 *a2, int32x2_t *a3, unint64_t a4, int a5, double a6, int8x8_t a7)
{
  __int32 v7;
  __int32 v8;
  __int32 v9;
  uint64_t v10;
  char *v11;
  uint64_t v13;
  __int32 v14;
  signed int v15;
  int v16;
  cv *v17;
  __int32 v18;
  uint64_t v19;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int32x2_t *v24;
  int32x2_t v25;
  int32x2_t v26;
  __int32 v27;
  __int32 v28;
  __int32 v29;
  char *v30;
  int v31;
  __int32 v32;
  __int32 v33;
  char *v34;
  int v35;
  uint64_t v36;
  cv *v37;
  BOOL v38;
  int v39;
  unsigned __int8 *v40;
  int32x4_t v41;
  int v42;
  cv *v43;

  if (a2)
  {
    if (a5 == 1)
    {
      v18 = a3->i32[0];
      if ((int)a4 < 1)
      {
        a4 = 0;
      }
      else
      {
        v19 = a4;
        a4 = 0;
        do
        {
          if (*(unsigned __int8 *)a2++)
          {
            v18 += *(char *)this;
            a4 = (a4 + 1);
          }
          this = (cv *)((char *)this + 1);
          --v19;
        }
        while (v19);
      }
      a3->i32[0] = v18;
    }
    else if (a5 == 3)
    {
      v7 = a3->i32[0];
      v8 = a3->i32[1];
      v9 = a3[1].i32[0];
      if ((int)a4 < 1)
      {
        a4 = 0;
      }
      else
      {
        v10 = a4;
        v11 = (char *)this + 2;
        a4 = 0;
        do
        {
          if (*(unsigned __int8 *)a2++)
          {
            v7 += *(v11 - 2);
            v8 += *(v11 - 1);
            v9 += *v11;
            a4 = (a4 + 1);
          }
          v11 += 3;
          --v10;
        }
        while (v10);
      }
      a3->i32[0] = v7;
      a3->i32[1] = v8;
      a3[1].i32[0] = v9;
    }
    else if ((int)a4 < 1)
    {
      return 0;
    }
    else
    {
      v21 = 0;
      v22 = a4;
      a4 = 0;
      do
      {
        if (a2[v21])
        {
          if (a5 >= 4)
          {
            v23 = 0;
            v24 = a3 + 1;
            do
            {
              v25.i32[0] = *((char *)this + v23);
              v25.i32[1] = *((char *)this + v23 + 1);
              v24[-1] = vadd_s32(v24[-1], v25);
              v26.i32[0] = *((char *)this + v23 + 2);
              v26.i32[1] = *((char *)this + v23 + 3);
              *v24 = vadd_s32(*v24, v26);
              v24 += 2;
              v23 += 4;
            }
            while (v23 <= a5 - 4);
            v23 = v23;
          }
          else
          {
            v23 = 0;
          }
          if ((int)v23 < a5)
          {
            do
            {
              a3->i32[v23] += *((char *)this + v23);
              ++v23;
            }
            while (a5 != v23);
          }
          a4 = (a4 + 1);
        }
        ++v21;
        this = (cv *)((char *)this + a5);
      }
      while (v21 != v22);
    }
  }
  else
  {
    if (a5 <= 0)
      LODWORD(v13) = -(-a5 & 3);
    else
      LODWORD(v13) = a5 & 3;
    switch((_DWORD)v13)
    {
      case 3:
        v27 = a3->i32[0];
        v28 = a3->i32[1];
        v29 = a3[1].i32[0];
        if ((int)a4 >= 1)
        {
          v30 = (char *)this + 2;
          v31 = a4;
          do
          {
            v27 += *(v30 - 2);
            v28 += *(v30 - 1);
            v29 += *v30;
            v30 += a5;
            --v31;
          }
          while (v31);
        }
        a3->i32[0] = v27;
        a3->i32[1] = v28;
        a3[1].i32[0] = v29;
        break;
      case 2:
        v32 = a3->i32[0];
        v33 = a3->i32[1];
        if ((int)a4 >= 1)
        {
          v34 = (char *)this + 1;
          v35 = a4;
          do
          {
            v32 += *(v34 - 1);
            v33 += *v34;
            v34 += a5;
            --v35;
          }
          while (v35);
        }
        a3->i32[0] = v32;
        a3->i32[1] = v33;
        break;
      case 1:
        v14 = a3->i32[0];
        v15 = 0;
        v16 = a4 - 4;
        if ((int)a4 >= 4)
        {
          v36 = 4 * a5;
          v37 = this;
          do
          {
            v14 += *(char *)v37 + *((char *)v37 + a5) + *((char *)v37 + 2 * a5) + *((char *)v37 + 3 * a5);
            v15 += 4;
            v37 = (cv *)((char *)v37 + v36);
          }
          while (v15 <= v16);
          v15 = (v16 & 0xFFFFFFFC) + 4;
          v17 = (cv *)((char *)this + ((v16 >> 2) + 1) * v36);
        }
        else
        {
          v17 = this;
        }
        v38 = __OFSUB__((_DWORD)a4, v15);
        v39 = a4 - v15;
        if (!((v39 < 0) ^ v38 | (v39 == 0)))
        {
          do
          {
            v14 += *(char *)v17;
            v17 = (cv *)((char *)v17 + a5);
            --v39;
          }
          while (v39);
        }
        a3->i32[0] = v14;
        break;
    }
    if ((int)v13 < a5)
    {
      v13 = (int)v13;
      do
      {
        v40 = (unsigned __int8 *)a3 + 4 * v13;
        v41 = *(int32x4_t *)v40;
        if ((int)a4 >= 1)
        {
          v42 = a4;
          v43 = this;
          do
          {
            a7.i32[0] = *(_DWORD *)((char *)v43 + v13);
            a7 = (int8x8_t)vmovl_s8(a7).u64[0];
            v41 = vaddw_s16(v41, (int16x4_t)a7);
            v43 = (cv *)((char *)v43 + a5);
            --v42;
          }
          while (v42);
        }
        *(int32x4_t *)v40 = v41;
        v13 += 4;
      }
      while (v13 < a5);
    }
  }
  return a4;
}

unint64_t cv::sum16u(cv *this, const unsigned __int16 *a2, uint32x4_t *a3, unint64_t a4, int a5)
{
  __int32 v5;
  __int32 v6;
  __int32 v7;
  uint64_t v8;
  unsigned __int16 *v9;
  int v10;
  int v11;
  __int32 v12;
  int v13;
  unsigned int v14;
  cv *v15;
  __int32 v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint32x4_t *v22;
  cv *v23;
  uint16x4_t v24;
  __int32 v25;
  __int32 v26;
  __int32 v27;
  unsigned __int16 *v28;
  int v29;
  __int32 v30;
  __int32 v31;
  unsigned __int16 *v32;
  int v33;
  int v34;
  BOOL v35;
  int v36;
  uint64_t v37;
  uint16x4_t *v38;
  unsigned __int8 *v39;
  uint32x4_t v40;
  int v41;
  uint16x4_t *v42;

  if (a2)
  {
    if (a5 == 1)
    {
      v16 = a3->i32[0];
      if ((int)a4 < 1)
      {
        a4 = 0;
      }
      else
      {
        v17 = a4;
        a4 = 0;
        do
        {
          v18 = *(unsigned __int8 *)a2;
          a2 = (const unsigned __int16 *)((char *)a2 + 1);
          if (v18)
          {
            v16 += *(unsigned __int16 *)this;
            a4 = (a4 + 1);
          }
          this = (cv *)((char *)this + 2);
          --v17;
        }
        while (v17);
      }
      a3->i32[0] = v16;
    }
    else if (a5 == 3)
    {
      v5 = a3->i32[0];
      v6 = a3->i32[1];
      v7 = a3->i32[2];
      if ((int)a4 < 1)
      {
        a4 = 0;
      }
      else
      {
        v8 = a4;
        v9 = (unsigned __int16 *)((char *)this + 4);
        a4 = 0;
        do
        {
          v10 = *(unsigned __int8 *)a2;
          a2 = (const unsigned __int16 *)((char *)a2 + 1);
          if (v10)
          {
            v5 += *(v9 - 2);
            v6 += *(v9 - 1);
            v7 += *v9;
            a4 = (a4 + 1);
          }
          v9 += 3;
          --v8;
        }
        while (v8);
      }
      a3->i32[0] = v5;
      a3->i32[1] = v6;
      a3->i32[2] = v7;
    }
    else if ((int)a4 < 1)
    {
      return 0;
    }
    else
    {
      v19 = 0;
      v20 = a4;
      a4 = 0;
      do
      {
        if (*((_BYTE *)a2 + v19))
        {
          if (a5 >= 4)
          {
            v21 = 0;
            v22 = a3;
            v23 = this;
            do
            {
              v24 = *(uint16x4_t *)v23;
              v23 = (cv *)((char *)v23 + 8);
              *v22 = vaddw_u16(*v22, v24);
              ++v22;
              v21 += 4;
            }
            while (v21 <= a5 - 4);
            v21 = v21;
          }
          else
          {
            v21 = 0;
          }
          if ((int)v21 < a5)
          {
            do
            {
              a3->i32[v21] += *((unsigned __int16 *)this + v21);
              ++v21;
            }
            while (a5 != v21);
          }
          a4 = (a4 + 1);
        }
        ++v19;
        this = (cv *)((char *)this + 2 * a5);
      }
      while (v19 != v20);
    }
  }
  else
  {
    if (a5 <= 0)
      v11 = -(-a5 & 3);
    else
      v11 = a5 & 3;
    switch(v11)
    {
      case 3:
        v25 = a3->i32[0];
        v26 = a3->i32[1];
        v27 = a3->i32[2];
        if ((int)a4 >= 1)
        {
          v28 = (unsigned __int16 *)((char *)this + 4);
          v29 = a4;
          do
          {
            v25 += *(v28 - 2);
            v26 += *(v28 - 1);
            v27 += *v28;
            v28 += a5;
            --v29;
          }
          while (v29);
        }
        a3->i32[0] = v25;
        a3->i32[1] = v26;
        a3->i32[2] = v27;
        break;
      case 2:
        v30 = a3->i32[0];
        v31 = a3->i32[1];
        if ((int)a4 >= 1)
        {
          v32 = (unsigned __int16 *)((char *)this + 2);
          v33 = a4;
          do
          {
            v30 += *(v32 - 1);
            v31 += *v32;
            v32 += a5;
            --v33;
          }
          while (v33);
        }
        a3->i32[0] = v30;
        a3->i32[1] = v31;
        break;
      case 1:
        v12 = a3->i32[0];
        v13 = a4 - 4;
        if ((int)a4 >= 4)
        {
          v34 = 0;
          v15 = this;
          do
          {
            v12 += *(unsigned __int16 *)v15
                 + *((unsigned __int16 *)v15 + a5)
                 + *((unsigned __int16 *)v15 + 2 * a5)
                 + *((unsigned __int16 *)v15 + 3 * a5);
            v34 += 4;
            v15 = (cv *)((char *)v15 + 8 * a5);
          }
          while (v34 <= v13);
          v14 = (v13 & 0xFFFFFFFC) + 4;
        }
        else
        {
          v14 = 0;
          v15 = this;
        }
        v35 = __OFSUB__((_DWORD)a4, v14);
        v36 = a4 - v14;
        if (!((v36 < 0) ^ v35 | (v36 == 0)))
        {
          do
          {
            v12 += *(unsigned __int16 *)v15;
            v15 = (cv *)((char *)v15 + 2 * a5);
            --v36;
          }
          while (v36);
        }
        a3->i32[0] = v12;
        break;
    }
    if (v11 < a5)
    {
      v37 = v11;
      v38 = (uint16x4_t *)((char *)this + 2 * v11);
      do
      {
        v39 = (unsigned __int8 *)a3 + 4 * v37;
        v40 = *(uint32x4_t *)v39;
        if ((int)a4 >= 1)
        {
          v41 = a4;
          v42 = v38;
          do
          {
            v40 = vaddw_u16(v40, *v42);
            v42 = (uint16x4_t *)((char *)v42 + 2 * a5);
            --v41;
          }
          while (v41);
        }
        *(uint32x4_t *)v39 = v40;
        v37 += 4;
        ++v38;
      }
      while (v37 < a5);
    }
  }
  return a4;
}

unint64_t cv::sum16s(cv *this, const __int16 *a2, int32x4_t *a3, unint64_t a4, int a5)
{
  __int32 v5;
  __int32 v6;
  __int32 v7;
  uint64_t v8;
  __int16 *v9;
  int v10;
  int v11;
  __int32 v12;
  int v13;
  unsigned int v14;
  cv *v15;
  __int32 v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int32x4_t *v22;
  cv *v23;
  int16x4_t v24;
  __int32 v25;
  __int32 v26;
  __int32 v27;
  __int16 *v28;
  int v29;
  __int32 v30;
  __int32 v31;
  __int16 *v32;
  int v33;
  int v34;
  BOOL v35;
  int v36;
  uint64_t v37;
  int16x4_t *v38;
  unsigned __int8 *v39;
  int32x4_t v40;
  int v41;
  int16x4_t *v42;

  if (a2)
  {
    if (a5 == 1)
    {
      v16 = a3->i32[0];
      if ((int)a4 < 1)
      {
        a4 = 0;
      }
      else
      {
        v17 = a4;
        a4 = 0;
        do
        {
          v18 = *(unsigned __int8 *)a2;
          a2 = (const __int16 *)((char *)a2 + 1);
          if (v18)
          {
            v16 += *(__int16 *)this;
            a4 = (a4 + 1);
          }
          this = (cv *)((char *)this + 2);
          --v17;
        }
        while (v17);
      }
      a3->i32[0] = v16;
    }
    else if (a5 == 3)
    {
      v5 = a3->i32[0];
      v6 = a3->i32[1];
      v7 = a3->i32[2];
      if ((int)a4 < 1)
      {
        a4 = 0;
      }
      else
      {
        v8 = a4;
        v9 = (__int16 *)((char *)this + 4);
        a4 = 0;
        do
        {
          v10 = *(unsigned __int8 *)a2;
          a2 = (const __int16 *)((char *)a2 + 1);
          if (v10)
          {
            v5 += *(v9 - 2);
            v6 += *(v9 - 1);
            v7 += *v9;
            a4 = (a4 + 1);
          }
          v9 += 3;
          --v8;
        }
        while (v8);
      }
      a3->i32[0] = v5;
      a3->i32[1] = v6;
      a3->i32[2] = v7;
    }
    else if ((int)a4 < 1)
    {
      return 0;
    }
    else
    {
      v19 = 0;
      v20 = a4;
      a4 = 0;
      do
      {
        if (*((_BYTE *)a2 + v19))
        {
          if (a5 >= 4)
          {
            v21 = 0;
            v22 = a3;
            v23 = this;
            do
            {
              v24 = *(int16x4_t *)v23;
              v23 = (cv *)((char *)v23 + 8);
              *v22 = vaddw_s16(*v22, v24);
              ++v22;
              v21 += 4;
            }
            while (v21 <= a5 - 4);
            v21 = v21;
          }
          else
          {
            v21 = 0;
          }
          if ((int)v21 < a5)
          {
            do
            {
              a3->i32[v21] += *((__int16 *)this + v21);
              ++v21;
            }
            while (a5 != v21);
          }
          a4 = (a4 + 1);
        }
        ++v19;
        this = (cv *)((char *)this + 2 * a5);
      }
      while (v19 != v20);
    }
  }
  else
  {
    if (a5 <= 0)
      v11 = -(-a5 & 3);
    else
      v11 = a5 & 3;
    switch(v11)
    {
      case 3:
        v25 = a3->i32[0];
        v26 = a3->i32[1];
        v27 = a3->i32[2];
        if ((int)a4 >= 1)
        {
          v28 = (__int16 *)((char *)this + 4);
          v29 = a4;
          do
          {
            v25 += *(v28 - 2);
            v26 += *(v28 - 1);
            v27 += *v28;
            v28 += a5;
            --v29;
          }
          while (v29);
        }
        a3->i32[0] = v25;
        a3->i32[1] = v26;
        a3->i32[2] = v27;
        break;
      case 2:
        v30 = a3->i32[0];
        v31 = a3->i32[1];
        if ((int)a4 >= 1)
        {
          v32 = (__int16 *)((char *)this + 2);
          v33 = a4;
          do
          {
            v30 += *(v32 - 1);
            v31 += *v32;
            v32 += a5;
            --v33;
          }
          while (v33);
        }
        a3->i32[0] = v30;
        a3->i32[1] = v31;
        break;
      case 1:
        v12 = a3->i32[0];
        v13 = a4 - 4;
        if ((int)a4 >= 4)
        {
          v34 = 0;
          v15 = this;
          do
          {
            v12 += *(__int16 *)v15 + *((__int16 *)v15 + a5) + *((__int16 *)v15 + 2 * a5) + *((__int16 *)v15 + 3 * a5);
            v34 += 4;
            v15 = (cv *)((char *)v15 + 8 * a5);
          }
          while (v34 <= v13);
          v14 = (v13 & 0xFFFFFFFC) + 4;
        }
        else
        {
          v14 = 0;
          v15 = this;
        }
        v35 = __OFSUB__((_DWORD)a4, v14);
        v36 = a4 - v14;
        if (!((v36 < 0) ^ v35 | (v36 == 0)))
        {
          do
          {
            v12 += *(__int16 *)v15;
            v15 = (cv *)((char *)v15 + 2 * a5);
            --v36;
          }
          while (v36);
        }
        a3->i32[0] = v12;
        break;
    }
    if (v11 < a5)
    {
      v37 = v11;
      v38 = (int16x4_t *)((char *)this + 2 * v11);
      do
      {
        v39 = (unsigned __int8 *)a3 + 4 * v37;
        v40 = *(int32x4_t *)v39;
        if ((int)a4 >= 1)
        {
          v41 = a4;
          v42 = v38;
          do
          {
            v40 = vaddw_s16(v40, *v42);
            v42 = (int16x4_t *)((char *)v42 + 2 * a5);
            --v41;
          }
          while (v41);
        }
        *(int32x4_t *)v39 = v40;
        v37 += 4;
        ++v38;
      }
      while (v37 < a5);
    }
  }
  return a4;
}

unint64_t cv::sum32s(cv *this, const int *a2, double *a3, unint64_t a4, int a5)
{
  float64x2_t v5;
  double v6;
  uint64_t v7;
  int *v8;
  int v9;
  uint64_t v10;
  int64x2_t v11;
  int v12;
  double v13;
  int v14;
  unsigned int v15;
  cv *v16;
  double v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  float64x2_t *v25;
  uint64_t *v26;
  uint64_t v27;
  int64x2_t v28;
  uint64_t v29;
  float64x2_t v30;
  double v31;
  int *v32;
  int v33;
  uint64_t v34;
  int64x2_t v35;
  float64x2_t v36;
  int v37;
  cv *v38;
  int64x2_t v39;
  int v40;
  BOOL v41;
  int v42;
  uint64_t v43;
  char *v44;
  unsigned __int8 *v45;
  float64x2_t v46;
  float64x2_t v47;
  int v48;
  _QWORD *v49;
  uint64_t v50;
  int64x2_t v51;

  if (a2)
  {
    if (a5 == 1)
    {
      v17 = *a3;
      if ((int)a4 < 1)
      {
        a4 = 0;
      }
      else
      {
        v18 = a4;
        a4 = 0;
        do
        {
          v19 = *(unsigned __int8 *)a2;
          a2 = (const int *)((char *)a2 + 1);
          if (v19)
          {
            v17 = v17 + (double)*(int *)this;
            a4 = (a4 + 1);
          }
          this = (cv *)((char *)this + 4);
          --v18;
        }
        while (v18);
      }
      *a3 = v17;
    }
    else if (a5 == 3)
    {
      v5 = *(float64x2_t *)a3;
      v6 = a3[2];
      if ((int)a4 < 1)
      {
        a4 = 0;
      }
      else
      {
        v7 = a4;
        v8 = (int *)((char *)this + 8);
        a4 = 0;
        do
        {
          v9 = *(unsigned __int8 *)a2;
          a2 = (const int *)((char *)a2 + 1);
          if (v9)
          {
            v10 = *((_QWORD *)v8 - 1);
            v11.i64[0] = (int)v10;
            v11.i64[1] = SHIDWORD(v10);
            v5 = vaddq_f64(v5, vcvtq_f64_s64(v11));
            v6 = v6 + (double)*v8;
            a4 = (a4 + 1);
          }
          v8 += 3;
          --v7;
        }
        while (v7);
      }
      *(float64x2_t *)a3 = v5;
      a3[2] = v6;
    }
    else if ((int)a4 < 1)
    {
      return 0;
    }
    else
    {
      v20 = 0;
      v21 = 4 * a5;
      v22 = (char *)this + 8;
      v23 = a4;
      a4 = 0;
      do
      {
        if (*((_BYTE *)a2 + v20))
        {
          if (a5 >= 4)
          {
            v24 = 0;
            v25 = (float64x2_t *)(a3 + 2);
            v26 = (uint64_t *)v22;
            do
            {
              v27 = *(v26 - 1);
              v28.i64[0] = (int)v27;
              v28.i64[1] = SHIDWORD(v27);
              v25[-1] = vaddq_f64(v25[-1], vcvtq_f64_s64(v28));
              v29 = *v26;
              v26 += 2;
              v28.i64[0] = (int)v29;
              v28.i64[1] = SHIDWORD(v29);
              *v25 = vaddq_f64(*v25, vcvtq_f64_s64(v28));
              v25 += 2;
              v24 += 4;
            }
            while (v24 <= a5 - 4);
            v24 = v24;
          }
          else
          {
            v24 = 0;
          }
          if ((int)v24 < a5)
          {
            do
            {
              a3[v24] = a3[v24] + (double)*((int *)this + v24);
              ++v24;
            }
            while (a5 != v24);
          }
          a4 = (a4 + 1);
        }
        ++v20;
        v22 += v21;
        this = (cv *)((char *)this + v21);
      }
      while (v20 != v23);
    }
  }
  else
  {
    if (a5 <= 0)
      v12 = -(-a5 & 3);
    else
      v12 = a5 & 3;
    switch(v12)
    {
      case 3:
        v30 = *(float64x2_t *)a3;
        v31 = a3[2];
        if ((int)a4 >= 1)
        {
          v32 = (int *)((char *)this + 8);
          v33 = a4;
          do
          {
            v34 = *((_QWORD *)v32 - 1);
            v35.i64[0] = (int)v34;
            v35.i64[1] = SHIDWORD(v34);
            v30 = vaddq_f64(v30, vcvtq_f64_s64(v35));
            v31 = v31 + (double)*v32;
            v32 += a5;
            --v33;
          }
          while (v33);
        }
        *(float64x2_t *)a3 = v30;
        a3[2] = v31;
        break;
      case 2:
        v36 = *(float64x2_t *)a3;
        if ((int)a4 >= 1)
        {
          v37 = a4;
          v38 = this;
          do
          {
            v39.i64[0] = (int)*(_QWORD *)v38;
            v39.i64[1] = (int)HIDWORD(*(_QWORD *)v38);
            v36 = vaddq_f64(v36, vcvtq_f64_s64(v39));
            v38 = (cv *)((char *)v38 + 4 * a5);
            --v37;
          }
          while (v37);
        }
        *(float64x2_t *)a3 = v36;
        break;
      case 1:
        v13 = *a3;
        v14 = a4 - 4;
        if ((int)a4 >= 4)
        {
          v40 = 0;
          v16 = this;
          do
          {
            v13 = v13
                + (double)(*((_DWORD *)v16 + a5) + *(_DWORD *)v16 + *((_DWORD *)v16 + 2 * a5)
                                                                  + *((_DWORD *)v16 + 3 * a5));
            v40 += 4;
            v16 = (cv *)((char *)v16 + 16 * a5);
          }
          while (v40 <= v14);
          v15 = (v14 & 0xFFFFFFFC) + 4;
        }
        else
        {
          v15 = 0;
          v16 = this;
        }
        v41 = __OFSUB__((_DWORD)a4, v15);
        v42 = a4 - v15;
        if (!((v42 < 0) ^ v41 | (v42 == 0)))
        {
          do
          {
            v13 = v13 + (double)*(int *)v16;
            v16 = (cv *)((char *)v16 + 4 * a5);
            --v42;
          }
          while (v42);
        }
        *a3 = v13;
        break;
    }
    if (v12 < a5)
    {
      v43 = v12;
      v44 = (char *)this + 4 * v12 + 8;
      do
      {
        v45 = (unsigned __int8 *)&a3[v43];
        v46 = *(float64x2_t *)v45;
        v47 = *((float64x2_t *)v45 + 1);
        if ((int)a4 >= 1)
        {
          v48 = a4;
          v49 = v44;
          do
          {
            v50 = *(v49 - 1);
            v51.i64[0] = (int)v50;
            v51.i64[1] = SHIDWORD(v50);
            v46 = vaddq_f64(v46, vcvtq_f64_s64(v51));
            v51.i64[0] = (int)*v49;
            v51.i64[1] = (int)HIDWORD(*v49);
            v47 = vaddq_f64(v47, vcvtq_f64_s64(v51));
            v49 = (_QWORD *)((char *)v49 + 4 * a5);
            --v48;
          }
          while (v48);
        }
        *(float64x2_t *)v45 = v46;
        *((float64x2_t *)v45 + 1) = v47;
        v43 += 4;
        v44 += 16;
      }
      while (v43 < a5);
    }
  }
  return a4;
}

unint64_t cv::sum32f(float32x2_t *this, const float *a2, double *a3, unint64_t a4, int a5)
{
  float64x2_t v5;
  double v6;
  uint64_t v7;
  float *v8;
  int v9;
  int v10;
  double v11;
  int v12;
  unsigned int v13;
  float *v14;
  double v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  float32x2_t *v20;
  uint64_t v21;
  uint64_t v22;
  float64x2_t *v23;
  float32x2_t *v24;
  float32x2_t v25;
  float64x2_t v26;
  double v27;
  float *v28;
  int v29;
  float64x2_t v30;
  int v31;
  float32x2_t *v32;
  int v33;
  BOOL v34;
  int v35;
  uint64_t v36;
  float32x2_t *v37;
  unsigned __int8 *v38;
  float64x2_t v39;
  float64x2_t v40;
  int v41;
  float32x2_t *v42;

  if (a2)
  {
    if (a5 == 1)
    {
      v15 = *a3;
      if ((int)a4 < 1)
      {
        a4 = 0;
      }
      else
      {
        v16 = a4;
        a4 = 0;
        do
        {
          v17 = *(unsigned __int8 *)a2;
          a2 = (const float *)((char *)a2 + 1);
          if (v17)
          {
            v15 = v15 + this->f32[0];
            a4 = (a4 + 1);
          }
          this = (float32x2_t *)((char *)this + 4);
          --v16;
        }
        while (v16);
      }
      *a3 = v15;
    }
    else if (a5 == 3)
    {
      v5 = *(float64x2_t *)a3;
      v6 = a3[2];
      if ((int)a4 < 1)
      {
        a4 = 0;
      }
      else
      {
        v7 = a4;
        v8 = (float *)&this[1];
        a4 = 0;
        do
        {
          v9 = *(unsigned __int8 *)a2;
          a2 = (const float *)((char *)a2 + 1);
          if (v9)
          {
            v5 = vaddq_f64(v5, vcvtq_f64_f32(*(float32x2_t *)(v8 - 2)));
            v6 = v6 + *v8;
            a4 = (a4 + 1);
          }
          v8 += 3;
          --v7;
        }
        while (v7);
      }
      *(float64x2_t *)a3 = v5;
      a3[2] = v6;
    }
    else if ((int)a4 < 1)
    {
      return 0;
    }
    else
    {
      v18 = 0;
      v19 = 4 * a5;
      v20 = this + 1;
      v21 = a4;
      a4 = 0;
      do
      {
        if (*((_BYTE *)a2 + v18))
        {
          if (a5 >= 4)
          {
            v22 = 0;
            v23 = (float64x2_t *)(a3 + 2);
            v24 = v20;
            do
            {
              v23[-1] = vaddq_f64(v23[-1], vcvtq_f64_f32(v24[-1]));
              v25 = *v24;
              v24 += 2;
              *v23 = vaddq_f64(*v23, vcvtq_f64_f32(v25));
              v23 += 2;
              v22 += 4;
            }
            while (v22 <= a5 - 4);
            v22 = v22;
          }
          else
          {
            v22 = 0;
          }
          if ((int)v22 < a5)
          {
            do
            {
              a3[v22] = a3[v22] + this->f32[v22];
              ++v22;
            }
            while (a5 != v22);
          }
          a4 = (a4 + 1);
        }
        ++v18;
        v20 = (float32x2_t *)((char *)v20 + v19);
        this = (float32x2_t *)((char *)this + v19);
      }
      while (v18 != v21);
    }
  }
  else
  {
    if (a5 <= 0)
      v10 = -(-a5 & 3);
    else
      v10 = a5 & 3;
    switch(v10)
    {
      case 3:
        v26 = *(float64x2_t *)a3;
        v27 = a3[2];
        if ((int)a4 >= 1)
        {
          v28 = (float *)&this[1];
          v29 = a4;
          do
          {
            v26 = vaddq_f64(v26, vcvtq_f64_f32(*(float32x2_t *)(v28 - 2)));
            v27 = v27 + *v28;
            v28 += a5;
            --v29;
          }
          while (v29);
        }
        *(float64x2_t *)a3 = v26;
        a3[2] = v27;
        break;
      case 2:
        v30 = *(float64x2_t *)a3;
        if ((int)a4 >= 1)
        {
          v31 = a4;
          v32 = this;
          do
          {
            v30 = vaddq_f64(v30, vcvtq_f64_f32(*v32));
            v32 = (float32x2_t *)((char *)v32 + 4 * a5);
            --v31;
          }
          while (v31);
        }
        *(float64x2_t *)a3 = v30;
        break;
      case 1:
        v11 = *a3;
        v12 = a4 - 4;
        if ((int)a4 >= 4)
        {
          v33 = 0;
          v14 = (float *)this;
          do
          {
            v11 = v11 + (float)((float)((float)(*v14 + v14[a5]) + v14[2 * a5]) + v14[3 * a5]);
            v33 += 4;
            v14 += 4 * a5;
          }
          while (v33 <= v12);
          v13 = (v12 & 0xFFFFFFFC) + 4;
        }
        else
        {
          v13 = 0;
          v14 = (float *)this;
        }
        v34 = __OFSUB__((_DWORD)a4, v13);
        v35 = a4 - v13;
        if (!((v35 < 0) ^ v34 | (v35 == 0)))
        {
          do
          {
            v11 = v11 + *v14;
            v14 += a5;
            --v35;
          }
          while (v35);
        }
        *a3 = v11;
        break;
    }
    if (v10 < a5)
    {
      v36 = v10;
      v37 = (float32x2_t *)((char *)this + 4 * v10 + 8);
      do
      {
        v38 = (unsigned __int8 *)&a3[v36];
        v39 = *(float64x2_t *)v38;
        v40 = *((float64x2_t *)v38 + 1);
        if ((int)a4 >= 1)
        {
          v41 = a4;
          v42 = v37;
          do
          {
            v39 = vaddq_f64(v39, vcvtq_f64_f32(v42[-1]));
            v40 = vaddq_f64(v40, vcvtq_f64_f32(*v42));
            v42 = (float32x2_t *)((char *)v42 + 4 * a5);
            --v41;
          }
          while (v41);
        }
        *(float64x2_t *)v38 = v39;
        *((float64x2_t *)v38 + 1) = v40;
        v36 += 4;
        v37 += 2;
      }
      while (v36 < a5);
    }
  }
  return a4;
}

unint64_t cv::sum64f(float64x2_t *this, const double *a2, double *a3, unint64_t a4, int a5)
{
  float64x2_t v5;
  double v6;
  uint64_t v7;
  double *f64;
  int v9;
  int v10;
  double v11;
  int v12;
  unsigned int v13;
  double *v14;
  double v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  float64x2_t *v22;
  float64x2_t v23;
  float64x2_t v24;
  double v25;
  double *v26;
  int v27;
  float64x2_t v28;
  int v29;
  float64x2_t *v30;
  int v31;
  BOOL v32;
  int v33;
  uint64_t v34;
  float64x2_t *v35;
  unsigned __int8 *v36;
  float64x2_t v37;
  float64x2_t v38;
  int v39;
  float64x2_t *v40;

  if (a2)
  {
    if (a5 == 1)
    {
      v15 = *a3;
      if ((int)a4 < 1)
      {
        a4 = 0;
      }
      else
      {
        v16 = a4;
        a4 = 0;
        do
        {
          v17 = *(unsigned __int8 *)a2;
          a2 = (const double *)((char *)a2 + 1);
          if (v17)
          {
            v15 = v15 + this->f64[0];
            a4 = (a4 + 1);
          }
          this = (float64x2_t *)((char *)this + 8);
          --v16;
        }
        while (v16);
      }
      *a3 = v15;
    }
    else if (a5 == 3)
    {
      v5 = *(float64x2_t *)a3;
      v6 = a3[2];
      if ((int)a4 < 1)
      {
        a4 = 0;
      }
      else
      {
        v7 = a4;
        f64 = this[1].f64;
        a4 = 0;
        do
        {
          v9 = *(unsigned __int8 *)a2;
          a2 = (const double *)((char *)a2 + 1);
          if (v9)
          {
            v5 = vaddq_f64(v5, *(float64x2_t *)(f64 - 2));
            v6 = v6 + *f64;
            a4 = (a4 + 1);
          }
          f64 += 3;
          --v7;
        }
        while (v7);
      }
      *(float64x2_t *)a3 = v5;
      a3[2] = v6;
    }
    else if ((int)a4 < 1)
    {
      return 0;
    }
    else
    {
      v18 = 0;
      v19 = a4;
      a4 = 0;
      do
      {
        if (*((_BYTE *)a2 + v18))
        {
          if (a5 >= 4)
          {
            v21 = 0;
            v20 = 0;
            do
            {
              v22 = (float64x2_t *)&a3[v21 / 8];
              v23 = *(float64x2_t *)&a3[v21 / 8 + 2];
              *v22 = vaddq_f64(*(float64x2_t *)&a3[v21 / 8], this[v21 / 0x10]);
              v22[1] = vaddq_f64(v23, this[v21 / 0x10 + 1]);
              v20 += 4;
              v21 += 32;
            }
            while (v20 <= a5 - 4);
            v20 = v20;
          }
          else
          {
            v20 = 0;
          }
          if ((int)v20 < a5)
          {
            do
            {
              a3[v20] = this->f64[v20] + a3[v20];
              ++v20;
            }
            while (a5 != v20);
          }
          a4 = (a4 + 1);
        }
        ++v18;
        this = (float64x2_t *)((char *)this + 8 * a5);
      }
      while (v18 != v19);
    }
  }
  else
  {
    if (a5 <= 0)
      v10 = -(-a5 & 3);
    else
      v10 = a5 & 3;
    switch(v10)
    {
      case 3:
        v24 = *(float64x2_t *)a3;
        v25 = a3[2];
        if ((int)a4 >= 1)
        {
          v26 = this[1].f64;
          v27 = a4;
          do
          {
            v24 = vaddq_f64(v24, *(float64x2_t *)(v26 - 2));
            v25 = v25 + *v26;
            v26 += a5;
            --v27;
          }
          while (v27);
        }
        *(float64x2_t *)a3 = v24;
        a3[2] = v25;
        break;
      case 2:
        v28 = *(float64x2_t *)a3;
        if ((int)a4 >= 1)
        {
          v29 = a4;
          v30 = this;
          do
          {
            v28 = vaddq_f64(v28, *v30);
            v30 = (float64x2_t *)((char *)v30 + 8 * a5);
            --v29;
          }
          while (v29);
        }
        *(float64x2_t *)a3 = v28;
        break;
      case 1:
        v11 = *a3;
        v12 = a4 - 4;
        if ((int)a4 >= 4)
        {
          v31 = 0;
          v14 = (double *)this;
          do
          {
            v11 = v11 + *v14 + v14[a5] + v14[2 * a5] + v14[3 * a5];
            v31 += 4;
            v14 += 4 * a5;
          }
          while (v31 <= v12);
          v13 = (v12 & 0xFFFFFFFC) + 4;
        }
        else
        {
          v13 = 0;
          v14 = (double *)this;
        }
        v32 = __OFSUB__((_DWORD)a4, v13);
        v33 = a4 - v13;
        if (!((v33 < 0) ^ v32 | (v33 == 0)))
        {
          do
          {
            v11 = v11 + *v14;
            v14 += a5;
            --v33;
          }
          while (v33);
        }
        *a3 = v11;
        break;
    }
    if (v10 < a5)
    {
      v34 = v10;
      v35 = (float64x2_t *)((char *)this + 8 * v10 + 16);
      do
      {
        v36 = (unsigned __int8 *)&a3[v34];
        v37 = *(float64x2_t *)v36;
        v38 = *((float64x2_t *)v36 + 1);
        if ((int)a4 >= 1)
        {
          v39 = a4;
          v40 = v35;
          do
          {
            v37 = vaddq_f64(v37, v40[-1]);
            v38 = vaddq_f64(v38, *v40);
            v40 = (float64x2_t *)((char *)v40 + 8 * a5);
            --v39;
          }
          while (v39);
        }
        *(float64x2_t *)v36 = v37;
        *((float64x2_t *)v36 + 1) = v38;
        v34 += 4;
        v35 += 2;
      }
      while (v34 < a5);
    }
  }
  return a4;
}

unsigned __int8 *cv::countNonZero8u(unsigned __int8 *this, const unsigned __int8 *a2)
{
  unsigned __int8 *v2;
  uint64_t v3;

  if ((int)a2 < 1)
    return 0;
  v2 = this;
  LODWORD(this) = 0;
  v3 = a2;
  do
  {
    if (*v2++)
      this = (unsigned __int8 *)((_DWORD)this + 1);
    else
      this = (unsigned __int8 *)this;
    --v3;
  }
  while (v3);
  return this;
}

uint64_t cv::countNonZero16u(cv *this, const unsigned __int16 *a2)
{
  unint64_t v3;
  int v4;
  uint64_t result;
  unint64_t v6;
  cv *v7;
  int16x4_t v8;
  int16x4_t v9;
  uint8x8_t v10;
  unsigned __int16 *v11;

  v3 = ((_DWORD)a2 - 4);
  if ((int)a2 >= 4)
  {
    v6 = 0;
    LODWORD(result) = 0;
    v7 = this;
    do
    {
      v8 = *(int16x4_t *)v7;
      v7 = (cv *)((char *)v7 + 8);
      v9 = (int16x4_t)vbic_s8((int8x8_t)0x8000400020001, (int8x8_t)vceqz_s16(v8));
      v9.i32[0] = vaddv_s16(v9) & 0xF;
      v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
      v10.i16[0] = vaddlv_u8(v10);
      result = (result + v10.i32[0]);
      v6 += 4;
    }
    while (v6 <= v3);
    v4 = (v3 & 0xFFFFFFFC) + 4;
  }
  else
  {
    v4 = 0;
    result = 0;
  }
  if (v4 < (int)a2)
  {
    v11 = (unsigned __int16 *)((char *)this + 2 * v4);
    do
    {
      if (*v11++)
        result = (result + 1);
      else
        result = result;
      ++v4;
    }
    while (v4 < (int)a2);
  }
  return result;
}

uint64_t cv::countNonZero32s(cv *this, const int *a2)
{
  unint64_t v3;
  int v4;
  uint64_t result;
  unint64_t v6;
  cv *v7;
  int32x4_t v8;
  int32x4_t v9;
  _DWORD *v10;

  v3 = ((_DWORD)a2 - 4);
  if ((int)a2 >= 4)
  {
    v6 = 0;
    LODWORD(result) = 0;
    v7 = this;
    do
    {
      v8 = *(int32x4_t *)v7;
      v7 = (cv *)((char *)v7 + 16);
      v9 = (int32x4_t)vbicq_s8((int8x16_t)xmmword_219EA0AF0, (int8x16_t)vceqzq_s32(v8));
      v9.i32[0] = vaddvq_s32(v9) & 0xF;
      *(int8x8_t *)v9.i8 = vcnt_s8(*(int8x8_t *)v9.i8);
      v9.i16[0] = vaddlv_u8(*(uint8x8_t *)v9.i8);
      result = (result + v9.i32[0]);
      v6 += 4;
    }
    while (v6 <= v3);
    v4 = (v3 & 0xFFFFFFFC) + 4;
  }
  else
  {
    v4 = 0;
    result = 0;
  }
  if (v4 < (int)a2)
  {
    v10 = (_DWORD *)((char *)this + 4 * v4);
    do
    {
      if (*v10++)
        result = (result + 1);
      else
        result = result;
      ++v4;
    }
    while (v4 < (int)a2);
  }
  return result;
}

uint64_t cv::countNonZero32f(cv *this, const float *a2)
{
  unint64_t v3;
  int v4;
  uint64_t result;
  unint64_t v6;
  cv *v7;
  float32x4_t v8;
  int32x4_t v9;
  float *v10;
  float v11;

  v3 = ((_DWORD)a2 - 4);
  if ((int)a2 >= 4)
  {
    v6 = 0;
    LODWORD(result) = 0;
    v7 = this;
    do
    {
      v8 = *(float32x4_t *)v7;
      v7 = (cv *)((char *)v7 + 16);
      v9 = (int32x4_t)vbicq_s8((int8x16_t)xmmword_219EA0AF0, (int8x16_t)vceqzq_f32(v8));
      v9.i32[0] = vaddvq_s32(v9) & 0xF;
      *(int8x8_t *)v9.i8 = vcnt_s8(*(int8x8_t *)v9.i8);
      v9.i16[0] = vaddlv_u8(*(uint8x8_t *)v9.i8);
      result = (result + v9.i32[0]);
      v6 += 4;
    }
    while (v6 <= v3);
    v4 = (v3 & 0xFFFFFFFC) + 4;
  }
  else
  {
    v4 = 0;
    result = 0;
  }
  if (v4 < (int)a2)
  {
    v10 = (float *)((char *)this + 4 * v4);
    do
    {
      v11 = *v10++;
      if (v11 == 0.0)
        result = result;
      else
        result = (result + 1);
      ++v4;
    }
    while (v4 < (int)a2);
  }
  return result;
}

uint64_t cv::countNonZero64f(cv *this, const double *a2)
{
  unint64_t v3;
  int v4;
  uint64_t result;
  unint64_t v6;
  cv *v7;
  float64x2_t v8;
  float64x2_t v9;
  int32x4_t v10;
  double *v11;
  double v12;

  v3 = ((_DWORD)a2 - 4);
  if ((int)a2 >= 4)
  {
    v6 = 0;
    LODWORD(result) = 0;
    v7 = this;
    do
    {
      v8 = *(float64x2_t *)v7;
      v9 = *((float64x2_t *)v7 + 1);
      v7 = (cv *)((char *)v7 + 32);
      v10 = (int32x4_t)vbicq_s8((int8x16_t)xmmword_219EA0AF0, (int8x16_t)vuzp1q_s32((int32x4_t)vceqzq_f64(v8), (int32x4_t)vceqzq_f64(v9)));
      v10.i32[0] = vaddvq_s32(v10);
      *(int8x8_t *)v10.i8 = vcnt_s8(*(int8x8_t *)v10.i8);
      v10.i16[0] = vaddlv_u8(*(uint8x8_t *)v10.i8);
      result = (result + v10.i32[0]);
      v6 += 4;
    }
    while (v6 <= v3);
    v4 = (v3 & 0xFFFFFFFC) + 4;
  }
  else
  {
    v4 = 0;
    result = 0;
  }
  if (v4 < (int)a2)
  {
    v11 = (double *)((char *)this + 8 * v4);
    do
    {
      v12 = *v11++;
      if (v12 == 0.0)
        result = result;
      else
        result = (result + 1);
      ++v4;
    }
    while (v4 < (int)a2);
  }
  return result;
}

unsigned __int8 *cv::minMaxIdx_8u(unsigned __int8 *this, const unsigned __int8 *a2, unsigned __int8 *a3, int *a4, int *a5, unint64_t *a6, unint64_t *a7, unint64_t a8, unint64_t a9)
{
  int v9;
  int v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  unint64_t v19;
  BOOL v20;
  BOOL v21;
  unint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  BOOL v26;
  BOOL v27;
  BOOL v28;
  BOOL v29;
  BOOL v30;

  v9 = *(_DWORD *)a3;
  v10 = *a4;
  v11 = *(_QWORD *)a5;
  v12 = *a6;
  if (a2)
  {
    if ((int)a7 >= 1)
    {
      v13 = a7;
      do
      {
        v15 = *this++;
        v14 = v15;
        v17 = *a2++;
        v16 = v17;
        if (v9 >= v14)
          v18 = v14;
        else
          v18 = v9;
        if (v9 <= v14)
          v19 = v11;
        else
          v19 = a8;
        v21 = __OFSUB__(v10, v14);
        v20 = v10 - v14 < 0;
        if (v10 > v14)
          v14 = v10;
        if (v20 != v21)
          v22 = a8;
        else
          v22 = v12;
        if (v16)
        {
          v9 = v18;
          v11 = v19;
          v10 = v14;
          v12 = v22;
        }
        ++a8;
        --v13;
      }
      while (v13);
    }
  }
  else if ((int)a7 >= 1)
  {
    v23 = a7;
    do
    {
      v25 = *this++;
      v24 = v25;
      v28 = __OFSUB__(v9, v25);
      v26 = v9 == v25;
      v27 = v9 - v25 < 0;
      if (v9 >= v25)
        v9 = v24;
      if (!(v27 ^ v28 | v26))
        v11 = a8;
      v30 = __OFSUB__(v10, v24);
      v29 = v10 - v24 < 0;
      if (v10 <= v24)
        v10 = v24;
      if (v29 != v30)
        v12 = a8;
      ++a8;
      --v23;
    }
    while (v23);
  }
  *(_QWORD *)a5 = v11;
  *a6 = v12;
  *(_DWORD *)a3 = v9;
  *a4 = v10;
  return this;
}

char *cv::minMaxIdx_8s(char *this, const signed __int8 *a2, unsigned __int8 *a3, int *a4, int *a5, unint64_t *a6, unint64_t *a7, unint64_t a8, unint64_t a9)
{
  int v9;
  int v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  unint64_t v19;
  BOOL v20;
  BOOL v21;
  unint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  BOOL v26;
  BOOL v27;
  BOOL v28;
  BOOL v29;
  BOOL v30;

  v9 = *(_DWORD *)a3;
  v10 = *a4;
  v11 = *(_QWORD *)a5;
  v12 = *a6;
  if (a2)
  {
    if ((int)a7 >= 1)
    {
      v13 = a7;
      do
      {
        v15 = *this++;
        v14 = v15;
        v17 = *(unsigned __int8 *)a2++;
        v16 = v17;
        if (v9 >= v14)
          v18 = v14;
        else
          v18 = v9;
        if (v9 <= v14)
          v19 = v11;
        else
          v19 = a8;
        v21 = __OFSUB__(v10, v14);
        v20 = v10 - v14 < 0;
        if (v10 > v14)
          v14 = v10;
        if (v20 != v21)
          v22 = a8;
        else
          v22 = v12;
        if (v16)
        {
          v9 = v18;
          v11 = v19;
          v10 = v14;
          v12 = v22;
        }
        ++a8;
        --v13;
      }
      while (v13);
    }
  }
  else if ((int)a7 >= 1)
  {
    v23 = a7;
    do
    {
      v25 = *this++;
      v24 = v25;
      v28 = __OFSUB__(v9, v25);
      v26 = v9 == v25;
      v27 = v9 - v25 < 0;
      if (v9 >= v25)
        v9 = v24;
      if (!(v27 ^ v28 | v26))
        v11 = a8;
      v30 = __OFSUB__(v10, v24);
      v29 = v10 - v24 < 0;
      if (v10 <= v24)
        v10 = v24;
      if (v29 != v30)
        v12 = a8;
      ++a8;
      --v23;
    }
    while (v23);
  }
  *(_QWORD *)a5 = v11;
  *a6 = v12;
  *(_DWORD *)a3 = v9;
  *a4 = v10;
  return this;
}

unsigned __int16 *cv::minMaxIdx_16u(unsigned __int16 *this, const unsigned __int16 *a2, unsigned __int8 *a3, int *a4, int *a5, unint64_t *a6, unint64_t *a7, unint64_t a8, unint64_t a9)
{
  int v9;
  int v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  unint64_t v19;
  BOOL v20;
  BOOL v21;
  unint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  BOOL v26;
  BOOL v27;
  BOOL v28;
  BOOL v29;
  BOOL v30;

  v9 = *(_DWORD *)a3;
  v10 = *a4;
  v11 = *(_QWORD *)a5;
  v12 = *a6;
  if (a2)
  {
    if ((int)a7 >= 1)
    {
      v13 = a7;
      do
      {
        v15 = *this++;
        v14 = v15;
        v17 = *(unsigned __int8 *)a2;
        a2 = (const unsigned __int16 *)((char *)a2 + 1);
        v16 = v17;
        if (v9 >= v14)
          v18 = v14;
        else
          v18 = v9;
        if (v9 <= v14)
          v19 = v11;
        else
          v19 = a8;
        v21 = __OFSUB__(v10, v14);
        v20 = v10 - v14 < 0;
        if (v10 > v14)
          v14 = v10;
        if (v20 != v21)
          v22 = a8;
        else
          v22 = v12;
        if (v16)
        {
          v9 = v18;
          v11 = v19;
          v10 = v14;
          v12 = v22;
        }
        ++a8;
        --v13;
      }
      while (v13);
    }
  }
  else if ((int)a7 >= 1)
  {
    v23 = a7;
    do
    {
      v25 = *this++;
      v24 = v25;
      v28 = __OFSUB__(v9, v25);
      v26 = v9 == v25;
      v27 = v9 - v25 < 0;
      if (v9 >= v25)
        v9 = v24;
      if (!(v27 ^ v28 | v26))
        v11 = a8;
      v30 = __OFSUB__(v10, v24);
      v29 = v10 - v24 < 0;
      if (v10 <= v24)
        v10 = v24;
      if (v29 != v30)
        v12 = a8;
      ++a8;
      --v23;
    }
    while (v23);
  }
  *(_QWORD *)a5 = v11;
  *a6 = v12;
  *(_DWORD *)a3 = v9;
  *a4 = v10;
  return this;
}

__int16 *cv::minMaxIdx_16s(__int16 *this, const __int16 *a2, unsigned __int8 *a3, int *a4, int *a5, unint64_t *a6, unint64_t *a7, unint64_t a8, unint64_t a9)
{
  int v9;
  int v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  unint64_t v19;
  BOOL v20;
  BOOL v21;
  unint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  BOOL v26;
  BOOL v27;
  BOOL v28;
  BOOL v29;
  BOOL v30;

  v9 = *(_DWORD *)a3;
  v10 = *a4;
  v11 = *(_QWORD *)a5;
  v12 = *a6;
  if (a2)
  {
    if ((int)a7 >= 1)
    {
      v13 = a7;
      do
      {
        v15 = *this++;
        v14 = v15;
        v17 = *(unsigned __int8 *)a2;
        a2 = (const __int16 *)((char *)a2 + 1);
        v16 = v17;
        if (v9 >= v14)
          v18 = v14;
        else
          v18 = v9;
        if (v9 <= v14)
          v19 = v11;
        else
          v19 = a8;
        v21 = __OFSUB__(v10, v14);
        v20 = v10 - v14 < 0;
        if (v10 > v14)
          v14 = v10;
        if (v20 != v21)
          v22 = a8;
        else
          v22 = v12;
        if (v16)
        {
          v9 = v18;
          v11 = v19;
          v10 = v14;
          v12 = v22;
        }
        ++a8;
        --v13;
      }
      while (v13);
    }
  }
  else if ((int)a7 >= 1)
  {
    v23 = a7;
    do
    {
      v25 = *this++;
      v24 = v25;
      v28 = __OFSUB__(v9, v25);
      v26 = v9 == v25;
      v27 = v9 - v25 < 0;
      if (v9 >= v25)
        v9 = v24;
      if (!(v27 ^ v28 | v26))
        v11 = a8;
      v30 = __OFSUB__(v10, v24);
      v29 = v10 - v24 < 0;
      if (v10 <= v24)
        v10 = v24;
      if (v29 != v30)
        v12 = a8;
      ++a8;
      --v23;
    }
    while (v23);
  }
  *(_QWORD *)a5 = v11;
  *a6 = v12;
  *(_DWORD *)a3 = v9;
  *a4 = v10;
  return this;
}

int *cv::minMaxIdx_32s(int *this, const int *a2, unsigned __int8 *a3, int *a4, int *a5, unint64_t *a6, unint64_t *a7, unint64_t a8, unint64_t a9)
{
  int v9;
  int v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  BOOL v17;
  uint64_t v18;
  int v19;
  int v20;

  v9 = *(_DWORD *)a3;
  v10 = *a4;
  v11 = *(_QWORD *)a5;
  v12 = *a6;
  if (a2)
  {
    if ((int)a7 >= 1)
    {
      v13 = a7;
      do
      {
        v15 = *this++;
        v14 = v15;
        v16 = *(unsigned __int8 *)a2;
        a2 = (const int *)((char *)a2 + 1);
        v17 = v16 != 0;
        if (v16 != 0 && v14 < v9)
        {
          v9 = v14;
          v11 = a8;
        }
        if (v17 && v14 > v10)
        {
          v10 = v14;
          v12 = a8;
        }
        ++a8;
        --v13;
      }
      while (v13);
    }
  }
  else if ((int)a7 >= 1)
  {
    v18 = a7;
    do
    {
      v20 = *this++;
      v19 = v20;
      if (v20 < v9)
      {
        v9 = v19;
        v11 = a8;
      }
      if (v19 > v10)
      {
        v10 = v19;
        v12 = a8;
      }
      ++a8;
      --v18;
    }
    while (v18);
  }
  *(_QWORD *)a5 = v11;
  *a6 = v12;
  *(_DWORD *)a3 = v9;
  *a4 = v10;
  return this;
}

float *cv::minMaxIdx_32f(float *this, const float *a2, float *a3, float *a4, float *a5, unint64_t *a6, unint64_t *a7, unint64_t a8, unint64_t a9)
{
  float v9;
  float v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  float v14;
  float v15;
  int v16;
  BOOL v17;
  uint64_t v18;
  float v19;
  float v20;

  v9 = *a3;
  v10 = *a4;
  v11 = *(_QWORD *)a5;
  v12 = *a6;
  if (a2)
  {
    if ((int)a7 >= 1)
    {
      v13 = a7;
      do
      {
        v14 = *this++;
        v15 = v14;
        v16 = *(unsigned __int8 *)a2;
        a2 = (const float *)((char *)a2 + 1);
        v17 = v16 != 0;
        if (v16 != 0 && v15 < v9)
        {
          v9 = v15;
          v11 = a8;
        }
        if (v17 && v15 > v10)
        {
          v10 = v15;
          v12 = a8;
        }
        ++a8;
        --v13;
      }
      while (v13);
    }
  }
  else if ((int)a7 >= 1)
  {
    v18 = a7;
    do
    {
      v19 = *this++;
      v20 = v19;
      if (v19 < v9)
      {
        v9 = v20;
        v11 = a8;
      }
      if (v20 > v10)
      {
        v10 = v20;
        v12 = a8;
      }
      ++a8;
      --v18;
    }
    while (v18);
  }
  *(_QWORD *)a5 = v11;
  *a6 = v12;
  *a3 = v9;
  *a4 = v10;
  return this;
}

double *cv::minMaxIdx_64f(double *this, const double *a2, double *a3, double *a4, double *a5, unint64_t *a6, unint64_t *a7, unint64_t a8, unint64_t a9)
{
  double v9;
  double v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  double v14;
  double v15;
  BOOL v16;
  uint64_t v17;
  double v18;
  double v19;

  v9 = *a3;
  v10 = *a4;
  v11 = *(_QWORD *)a5;
  v12 = *a6;
  if (a2)
  {
    if ((int)a7 >= 1)
    {
      v13 = a7;
      do
      {
        v14 = *this++;
        v15 = v14;
        LODWORD(v14) = *(unsigned __int8 *)a2;
        a2 = (const double *)((char *)a2 + 1);
        v16 = LODWORD(v14) != 0;
        if (LODWORD(v14) != 0 && v15 < v9)
        {
          v9 = v15;
          v11 = a8;
        }
        if (v16 && v15 > v10)
        {
          v10 = v15;
          v12 = a8;
        }
        ++a8;
        --v13;
      }
      while (v13);
    }
  }
  else if ((int)a7 >= 1)
  {
    v17 = a7;
    do
    {
      v18 = *this++;
      v19 = v18;
      if (v18 < v9)
      {
        v9 = v19;
        v11 = a8;
      }
      if (v19 > v10)
      {
        v10 = v19;
        v12 = a8;
      }
      ++a8;
      --v17;
    }
    while (v17);
  }
  *(_QWORD *)a5 = v11;
  *a6 = v12;
  *a3 = v9;
  *a4 = v10;
  return this;
}

uint64_t cv::LU(cv *this, unint64_t a2, int a3, int *a4, unint64_t a5, int a6)
{
  unsigned int v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  BOOL v11;
  char v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int *v17;
  float *v18;
  cv *v19;
  unint64_t v20;
  uint64_t v21;
  char *v22;
  unint64_t v23;
  float *v24;
  uint64_t v25;
  int v26;
  unint64_t v27;
  _DWORD *v28;
  cv *v29;
  unint64_t v30;
  int v31;
  int *v32;
  int *v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  float v37;
  char *v38;
  float *v39;
  uint64_t v40;
  float v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  float *v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  float *v50;
  float v51;
  float *v52;
  uint64_t v53;

  v6 = a3 - 1;
  if (a3 < 1)
    return 1;
  v7 = 0;
  v8 = a2 >> 2;
  v9 = a5 >> 2;
  v10 = a3;
  if (a4)
    v11 = a6 < 1;
  else
    v11 = 1;
  v12 = v11;
  v13 = 4 * v8;
  v14 = 4 * v8 + 4;
  v15 = 4 * v9;
  v16 = 1;
  v17 = a4;
  v18 = (float *)((char *)this + 4 * v8);
  v19 = this;
  v20 = v10;
  v21 = 1;
  v22 = (char *)&a4[v9];
  do
  {
    v23 = v7 + 1;
    if (v7 + 1 >= v10)
    {
      v26 = v7;
    }
    else
    {
      v24 = v18;
      v25 = v16;
      v26 = v7;
      do
      {
        if (fabsf(*v24) > fabsf(*((float *)this + v7 + v8 * v26)))
          v26 = v25;
        ++v25;
        v24 = (float *)((char *)v24 + v13);
      }
      while (v10 != v25);
    }
    v27 = v8 * v26;
    if (fabsf(*((float *)this + v27 + v7)) < 0.00000011921)
      return 0;
    if (v7 != v26)
    {
      v28 = (_DWORD *)((char *)this + 4 * v7 + 4 * v27);
      v29 = v19;
      v30 = v20;
      do
      {
        v31 = *(_DWORD *)v29;
        *(_DWORD *)v29 = *v28;
        v29 = (cv *)((char *)v29 + 4);
        *v28++ = v31;
        --v30;
      }
      while (v30);
      if ((v12 & 1) == 0)
      {
        v32 = (int *)((char *)a4 + v15 * v26);
        v33 = v17;
        v34 = a6;
        do
        {
          v35 = *v33;
          *v33++ = *v32;
          *v32++ = v35;
          --v34;
        }
        while (v34);
      }
      v21 = -(int)v21;
    }
    v36 = v7 * v8 + v7;
    v37 = -1.0 / *((float *)this + v36);
    if (v23 < v10)
    {
      v38 = v22;
      v39 = v18;
      v40 = v16;
      do
      {
        v41 = v37 * *((float *)this + v7 + v40 * v8);
        v42 = 1;
        do
        {
          v39[v42] = v39[v42] + (float)(v41 * *((float *)v19 + v42));
          ++v42;
        }
        while (v20 != v42);
        if ((v12 & 1) == 0)
        {
          v43 = 0;
          do
          {
            *(float *)&v38[v43 * 4] = *(float *)&v38[v43 * 4] + (float)(v41 * *(float *)&v17[v43]);
            ++v43;
          }
          while (a6 != v43);
        }
        ++v40;
        v39 = (float *)((char *)v39 + v13);
        v38 += v15;
      }
      while (v40 != v10);
    }
    *((float *)this + v36) = -v37;
    ++v16;
    v18 = (float *)((char *)v18 + v14);
    --v20;
    v19 = (cv *)((char *)v19 + v14);
    v17 = (int *)((char *)v17 + v15);
    v22 += v15;
    ++v7;
  }
  while (v23 != v10);
  if (a4)
  {
    v44 = 0;
    v45 = (float *)&a4[v9 * v10];
    v46 = v8 + 1;
    v47 = v10;
    do
    {
      if (a6 >= 1)
      {
        v48 = 0;
        v49 = (v47 - 1) * v9;
        v50 = v45;
        do
        {
          v51 = *(float *)&a4[v48 + v49];
          if (v47 < (uint64_t)v10)
          {
            v52 = v50;
            v53 = v44;
            do
            {
              v51 = v51 - (float)(*(float *)((char *)this + 4 * v10 + 4 * v53 + v13 * v6) * *v52);
              v52 = (float *)((char *)v52 + v15);
              ++v53;
            }
            while ((_DWORD)v53);
          }
          *(float *)&a4[v48 + v49] = v51 * *((float *)this + (v47 - 1) * v46);
          ++v48;
          ++v50;
        }
        while (v48 != a6);
      }
      --v44;
      v45 -= v9;
      --v6;
      v11 = v47-- < 2;
    }
    while (!v11);
  }
  return v21;
}

uint64_t cv::LU(cv *this, unint64_t a2, unsigned int a3, uint64_t *a4, unint64_t a5, int a6)
{
  unsigned int v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  BOOL v10;
  char v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  cv *v17;
  uint64_t v18;
  uint64_t v19;
  double *v20;
  char *v21;
  unint64_t v22;
  double *v23;
  uint64_t v24;
  int v25;
  unint64_t v26;
  _QWORD *v27;
  cv *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  double v36;
  char *v37;
  double *v38;
  uint64_t v39;
  double v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  double *v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  double *v49;
  double v50;
  double *v51;
  uint64_t v52;

  v6 = a3 - 1;
  if ((int)a3 < 1)
    return 1;
  v7 = 0;
  v8 = a2 >> 3;
  v9 = a5 >> 3;
  if (a4)
    v10 = a6 < 1;
  else
    v10 = 1;
  v11 = v10;
  v12 = 8 * v8;
  v13 = 8 * v8 + 8;
  v14 = 1;
  v15 = 8 * v9;
  v16 = a4;
  v17 = this;
  v18 = a3;
  v19 = 1;
  v20 = (double *)((char *)this + 8 * v8);
  v21 = (char *)&a4[v9];
  do
  {
    v22 = v7 + 1;
    if (v7 + 1 >= (unint64_t)a3)
    {
      v25 = v7;
    }
    else
    {
      v23 = v20;
      v24 = v14;
      v25 = v7;
      do
      {
        if (fabs(*v23) > fabs(*((double *)this + v7 + v8 * v25)))
          v25 = v24;
        ++v24;
        v23 = (double *)((char *)v23 + v12);
      }
      while (a3 != v24);
    }
    v26 = v8 * v25;
    if (fabs(*((double *)this + v26 + v7)) < 2.22044605e-16)
      return 0;
    if (v7 != v25)
    {
      v27 = (_QWORD *)((char *)this + 8 * v7 + 8 * v26);
      v28 = v17;
      v29 = v18;
      do
      {
        v30 = *(_QWORD *)v28;
        *(_QWORD *)v28 = *v27;
        v28 = (cv *)((char *)v28 + 8);
        *v27++ = v30;
        --v29;
      }
      while (v29);
      if ((v11 & 1) == 0)
      {
        v31 = (uint64_t *)((char *)a4 + v15 * v25);
        v32 = v16;
        v33 = a6;
        do
        {
          v34 = *v32;
          *v32++ = *v31;
          *v31++ = v34;
          --v33;
        }
        while (v33);
      }
      v19 = -(int)v19;
    }
    v35 = v7 * v8 + v7;
    v36 = -1.0 / *((double *)this + v35);
    if (v22 < a3)
    {
      v37 = v21;
      v38 = v20;
      v39 = v14;
      do
      {
        v40 = v36 * *((double *)this + v7 + v39 * v8);
        v41 = 1;
        do
        {
          v38[v41] = v38[v41] + v40 * *((double *)v17 + v41);
          ++v41;
        }
        while (v18 != v41);
        if ((v11 & 1) == 0)
        {
          v42 = 0;
          do
          {
            *(double *)&v37[v42 * 8] = *(double *)&v37[v42 * 8] + v40 * *(double *)&v16[v42];
            ++v42;
          }
          while (a6 != v42);
        }
        ++v39;
        v38 = (double *)((char *)v38 + v12);
        v37 += v15;
      }
      while (v39 != a3);
    }
    *((double *)this + v35) = -v36;
    ++v14;
    v20 = (double *)((char *)v20 + v13);
    --v18;
    v17 = (cv *)((char *)v17 + v13);
    v16 = (uint64_t *)((char *)v16 + v15);
    v21 += v15;
    ++v7;
  }
  while (v22 != a3);
  if (a4)
  {
    v43 = 0;
    v44 = (double *)&a4[v9 * a3];
    v45 = v8 + 1;
    v46 = a3;
    do
    {
      if (a6 >= 1)
      {
        v47 = 0;
        v48 = (v46 - 1) * v9;
        v49 = v44;
        do
        {
          v50 = *(double *)&a4[v47 + v48];
          if (v46 < a3)
          {
            v51 = v49;
            v52 = v43;
            do
            {
              v50 = v50 - *(double *)((char *)this + 8 * a3 + 8 * v52 + v12 * v6) * *v51;
              v51 = (double *)((char *)v51 + v15);
              ++v52;
            }
            while ((_DWORD)v52);
          }
          *(double *)&a4[v47 + v48] = v50 * *((double *)this + (v46 - 1) * v45);
          ++v47;
          ++v49;
        }
        while (v47 != a6);
      }
      --v43;
      v44 -= v9;
      --v6;
      v10 = v46-- < 2;
    }
    while (!v10);
  }
  return v19;
}

BOOL cv::Cholesky(cv *this, unint64_t a2, int a3, float *a4, unint64_t a5, int a6)
{
  unint64_t v6;
  BOOL v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  cv *v12;
  unint64_t v13;
  uint64_t v14;
  cv *v15;
  double v16;
  uint64_t i;
  float v18;
  uint64_t v19;
  float *v20;
  double v21;
  float v22;
  uint64_t v23;
  uint64_t v24;
  cv *v25;
  uint64_t v26;
  unint64_t v27;
  float *v28;
  double v29;
  uint64_t v30;
  float *v31;
  float v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  double v37;
  uint64_t v38;
  float v39;

  if (a3 < 1)
  {
    return 1;
  }
  else
  {
    v6 = 0;
    v7 = 0;
    v8 = a2 >> 2;
    v9 = a5 >> 2;
    v10 = (a2 >> 2) + 1;
    v11 = 4 * (a2 >> 2);
    v12 = this;
    while (1)
    {
      v13 = v6 * v8;
      if (v6)
      {
        v14 = 0;
        v15 = this;
        do
        {
          v16 = *((float *)this + v14 + v13);
          if (v14)
          {
            for (i = 0; i != v14; ++i)
              v16 = v16 - (float)(*((float *)v12 + i) * *((float *)v15 + i));
          }
          v18 = v16 * *((float *)this + v14 * v10);
          *((float *)this + v14 + v13) = v18;
          ++v14;
          v15 = (cv *)((char *)v15 + v11);
        }
        while (v14 != v6);
        v19 = 0;
        v20 = (float *)((char *)this + 4 * v13 + 4 * v6);
        v21 = *v20;
        do
        {
          v21 = v21 - *((float *)v12 + v19) * *((float *)v12 + v19);
          ++v19;
        }
        while (v6 != v19);
      }
      else
      {
        v20 = (float *)((char *)this + 4 * v13);
        v21 = *v20;
      }
      if (v21 < 0.00000011920929)
        break;
      v22 = 1.0 / sqrt(v21);
      *v20 = v22;
      ++v6;
      v12 = (cv *)((char *)v12 + v11);
      v7 = v6 >= a3;
      if (v6 == a3)
      {
        v7 = 1;
        v23 = (a3 - 1);
        if (a4)
        {
          v24 = 0;
          v25 = this;
          do
          {
            if (a6 >= 1)
            {
              v26 = 0;
              v27 = v24 * v9;
              v28 = a4;
              do
              {
                v29 = a4[v26 + v27];
                if (v24)
                {
                  v30 = 0;
                  v31 = v28;
                  do
                  {
                    v29 = v29 - (float)(*((float *)v25 + v30++) * *v31);
                    v31 += v9;
                  }
                  while (v24 != v30);
                }
                v32 = v29 * *((float *)this + v24 * v10);
                a4[v26 + v27] = v32;
                ++v26;
                ++v28;
              }
              while (v26 != a6);
            }
            ++v24;
            v25 = (cv *)((char *)v25 + v11);
          }
          while (v24 != a3);
          v33 = a3 - 1;
          v34 = (a3 - 1);
          do
          {
            if (a6 >= 1)
            {
              v35 = 0;
              v36 = v34 * v9;
              do
              {
                v37 = a4[v35 + v36];
                if (v34 < v23)
                {
                  v38 = v33;
                  do
                  {
                    v37 = v37
                        - (float)(*((float *)this + v34 + v8 * v38) * a4[v35 + v9 * v38]);
                    --v38;
                  }
                  while (v34 < v38);
                }
                v39 = v37 * *((float *)this + v34 * v10);
                a4[v35 + v36] = v39;
                ++v35;
              }
              while (v35 != a6);
            }
          }
          while (v34-- > 0);
          return 1;
        }
        return v7;
      }
    }
  }
  return v7;
}

BOOL cv::Cholesky(cv *this, unint64_t a2, int a3, double *a4, unint64_t a5, int a6)
{
  unint64_t v6;
  BOOL v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  cv *v12;
  unint64_t v13;
  uint64_t v14;
  cv *v15;
  double v16;
  uint64_t i;
  uint64_t v18;
  double *v19;
  double v20;
  uint64_t v21;
  uint64_t v22;
  cv *v23;
  uint64_t v24;
  unint64_t v25;
  double *v26;
  double v27;
  uint64_t v28;
  double *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  double v34;
  uint64_t v35;

  if (a3 < 1)
  {
    return 1;
  }
  else
  {
    v6 = 0;
    v7 = 0;
    v8 = a2 >> 3;
    v9 = a5 >> 3;
    v10 = (a2 >> 3) + 1;
    v11 = 8 * (a2 >> 3);
    v12 = this;
    while (1)
    {
      v13 = v6 * v8;
      if (v6)
      {
        v14 = 0;
        v15 = this;
        do
        {
          v16 = *((double *)this + v14 + v13);
          if (v14)
          {
            for (i = 0; i != v14; ++i)
              v16 = v16 - *((double *)v12 + i) * *((double *)v15 + i);
          }
          *((double *)this + v14 + v13) = v16 * *((double *)this + v14 * v10);
          ++v14;
          v15 = (cv *)((char *)v15 + v11);
        }
        while (v14 != v6);
        v18 = 0;
        v19 = (double *)((char *)this + 8 * v13 + 8 * v6);
        v20 = *v19;
        do
        {
          v20 = v20 - *((double *)v12 + v18) * *((double *)v12 + v18);
          ++v18;
        }
        while (v6 != v18);
      }
      else
      {
        v19 = (double *)((char *)this + 8 * v13);
        v20 = *v19;
      }
      if (v20 < 2.22044605e-16)
        break;
      *v19 = 1.0 / sqrt(v20);
      ++v6;
      v12 = (cv *)((char *)v12 + v11);
      v7 = v6 >= a3;
      if (v6 == a3)
      {
        v7 = 1;
        v21 = (a3 - 1);
        if (a4)
        {
          v22 = 0;
          v23 = this;
          do
          {
            if (a6 >= 1)
            {
              v24 = 0;
              v25 = v22 * v9;
              v26 = a4;
              do
              {
                v27 = a4[v24 + v25];
                if (v22)
                {
                  v28 = 0;
                  v29 = v26;
                  do
                  {
                    v27 = v27 - *((double *)v23 + v28++) * *v29;
                    v29 += v9;
                  }
                  while (v22 != v28);
                }
                a4[v24 + v25] = v27 * *((double *)this + v22 * v10);
                ++v24;
                ++v26;
              }
              while (v24 != a6);
            }
            ++v22;
            v23 = (cv *)((char *)v23 + v11);
          }
          while (v22 != a3);
          v30 = a3 - 1;
          v31 = (a3 - 1);
          do
          {
            if (a6 >= 1)
            {
              v32 = 0;
              v33 = v31 * v9;
              do
              {
                v34 = a4[v32 + v33];
                if (v31 < v21)
                {
                  v35 = v30;
                  do
                  {
                    v34 = v34 - *((double *)this + v31 + v8 * v35) * a4[v32 + v9 * v35];
                    --v35;
                  }
                  while (v31 < v35);
                }
                a4[v32 + v33] = v34 * *((double *)this + v31 * v10);
                ++v32;
              }
              while (v32 != a6);
            }
          }
          while (v31-- > 0);
          return 1;
        }
        return v7;
      }
    }
  }
  return v7;
}

double cv::invert(cv *this, const cv::_InputArray *a2, const cv::_OutputArray *a3)
{
  void (***v3)(uint64_t *__return_ptr, _QWORD, uint64_t);
  int v4;
  int v5;
  const cv::_InputArray *v6;
  const cv::_InputArray *v7;
  uint64_t v8;
  const cv::Exception *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  _OWORD *v15;
  const cv::_OutputArray *v16;
  void *v17;
  unsigned int *v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  _BYTE *v22;
  double v23;
  const cv::Exception *v24;
  unsigned int v25;
  _OWORD *v26;
  const cv::_OutputArray *v27;
  const cv::_OutputArray *v28;
  const cv::_OutputArray *v29;
  unsigned int *v30;
  unsigned int v31;
  unsigned int v32;
  uint64_t v33;
  _BYTE *v34;
  const cv::Exception *v35;
  uint64_t v36;
  float *v37;
  double *v38;
  double v39;
  double v40;
  float *v41;
  double v42;
  double v43;
  double v44;
  double v45;
  double v46;
  double v47;
  double v48;
  double v49;
  double v50;
  double v51;
  double v52;
  double v53;
  double v54;
  double v55;
  double v56;
  double v57;
  double v58;
  double v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float *v64;
  float v65;
  float v66;
  float v67;
  float *v68;
  float v69;
  unsigned int *v70;
  unsigned int v71;
  unsigned int v72;
  uint64_t v73;
  void **v74;
  unsigned int *v75;
  unsigned int v76;
  unsigned int v77;
  uint64_t v78;
  int *v79;
  unsigned int *v80;
  unsigned int v81;
  unsigned int v82;
  uint64_t v83;
  int *v84;
  void **v85;
  cv *v86;
  unsigned int v87;
  unsigned int *v88;
  unsigned int v89;
  unsigned int v90;
  uint64_t v91;
  void **v92;
  unsigned int *v93;
  unsigned int v94;
  unsigned int v95;
  uint64_t v96;
  int *v97;
  unsigned int *v98;
  unsigned int v99;
  unsigned int v100;
  uint64_t v101;
  int *v102;
  unsigned int *v104;
  unsigned int v105;
  unsigned int v106;
  uint64_t v107;
  int *v108;
  double v110;
  float *v111;
  double v112;
  double v113;
  double v114;
  float v115;
  float *v116;
  float v117;
  double v118;
  float v119;
  float v120;
  double *v121;
  double v122;
  double v123;
  double v124;
  double v125;
  double v126;
  double v127;
  double v128;
  double v129;
  double v130;
  double v131;
  double v132;
  double v133;
  double v134;
  double *v135;
  double *v136;
  double *v137;
  double v138;
  double v139;
  double v140;
  double *v141;
  double v142;
  unsigned int *v143;
  unsigned int v144;
  unsigned int v145;
  uint64_t v146;
  int *v147;
  unsigned int *v148;
  unsigned int v149;
  unsigned int v150;
  uint64_t v151;
  uint64_t v152;
  _BYTE v154[64];
  _BYTE *v155;
  cv *v156;
  uint64_t v157;
  uint64_t v158;
  _BYTE v159[32];
  _BYTE v160[32];
  _BYTE v161[32];
  _BYTE v162[32];
  void *__p[2];
  __int128 v164;
  char *v165;
  char *v166;
  char *v167;
  uint64_t v168;
  void **v169;
  cv *v170;
  double *v171;
  double *v172;
  void *v173;
  unsigned int v174;
  int v175;
  cv *v176;
  unsigned int *v177;
  cv *v178;
  char *v179;
  char *v180;
  uint64_t v181;
  int *v182;
  cv *v183;
  double *v184;
  unint64_t v185;
  void *v186;
  int v187;
  unsigned int v188;
  float *v189;
  unsigned int *v190;
  float *v191;
  char *v192;
  char *v193;
  uint64_t v194;
  int *v195;
  cv *v196;
  double *v197;
  unint64_t v198;
  uint64_t v199;
  int v200;
  unsigned int v201;
  uint64_t v202;
  unsigned int *v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  cv *v208;
  uint64_t v209;
  int64x2_t v210;
  _OWORD v211[258];
  uint64_t v212;

  v3 = (void (***)(uint64_t *__return_ptr, _QWORD, uint64_t))MEMORY[0x24BDAC7A8](this, a2);
  v5 = v4;
  v7 = v6;
  v212 = *MEMORY[0x24BDAC8D0];
  (**v3)(&v199, v3, 0xFFFFFFFFLL);
  v8 = v199 & 0xFFF;
  if ((v8 - 5) >= 2)
  {
    std::string::basic_string[abi:ne180100]<0>(&v186, "type == CV_32F || type == CV_64F");
    std::string::basic_string[abi:ne180100]<0>(&v173, "invert");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/lapack.cpp");
    cv::Exception::Exception(&v210, 4294967081, &v186, &v173, __p, 938);
    cv::error((cv *)&v210, v9);
  }
  v10 = (((unsigned __int16)(v199 & 0xFFF) >> 3) + 1) << ((0xFA50u >> (2 * (v199 & 7))) & 3);
  v11 = v200;
  v12 = v201;
  v13 = (int)v201;
  if (v5 == 1)
  {
    if ((int)v201 >= v200)
      v14 = v200;
    else
      v14 = v201;
    v210.i64[0] = (uint64_t)v211;
    v210.i64[1] = 4104;
    v15 = v211;
    if ((unint64_t)((int)v10 * (uint64_t)(int)(v14 + v14 * (v200 + v201)) + 8) >= 0x1009)
    {
      v210.i64[1] = (int)v10 * (uint64_t)(int)(v14 + v14 * (v200 + v201)) + 8;
      v15 = (_OWORD *)operator new[]();
      v210.i64[0] = (uint64_t)v15;
    }
    v187 = v11;
    v188 = v14;
    v189 = (float *)(((unint64_t)v15 + v10 - 1) & -(int)v10);
    v190 = 0;
    v195 = &v187;
    v196 = (cv *)&v197;
    HIDWORD(v186) = 2;
    LODWORD(v186) = v8 | 0x42FF4000;
    v197 = (double *)((int)v10 * (uint64_t)(int)v14);
    v198 = ((v8 >> 3) + 1) << ((0xFA50u >> (2 * (v8 & 7))) & 3);
    v193 = (char *)v189 + (_QWORD)v197 * v11;
    v194 = 0;
    v191 = v189;
    v192 = v193;
    v174 = v14;
    v175 = 1;
    v176 = (cv *)((char *)v189 + (int)v10 * (uint64_t)(int)(v14 * v11));
    v177 = 0;
    v182 = (int *)&v174;
    v183 = (cv *)&v184;
    HIDWORD(v173) = 2;
    LODWORD(v173) = v8 | 0x42FF4000;
    v184 = (double *)v198;
    v185 = v198;
    v180 = (char *)v197 + (_QWORD)v176;
    v181 = 0;
    v178 = v176;
    v179 = (char *)v197 + (_QWORD)v176;
    __p[1] = (void *)__PAIR64__(v12, v14);
    v164 = (unint64_t)v197 + (unint64_t)v176;
    v169 = &__p[1];
    v170 = (cv *)&v171;
    __p[0] = (void *)(v8 | 0x242FF4000);
    v171 = (double *)((int)v13 * (uint64_t)(int)v10);
    v172 = (double *)v198;
    v167 = (char *)v197 + (_QWORD)v176 + (_QWORD)v171 * (int)v14;
    v168 = 0;
    v165 = (char *)v197 + (_QWORD)v176;
    v166 = v167;
    cv::_InputArray::_InputArray((uint64_t)v154, (const cv::Mat *)&v199);
    cv::_OutputArray::_OutputArray((uint64_t)v162, (cv::Mat *)&v173);
    cv::_OutputArray::_OutputArray((uint64_t)v161, (cv::Mat *)&v186);
    cv::_OutputArray::_OutputArray((uint64_t)v160, (cv::Mat *)__p);
    cv::_SVDcompute((cv *)v154, (const cv::_InputArray *)v162, (const cv::_OutputArray *)v161, (const cv::_OutputArray *)v160, 0);
    cv::_InputArray::_InputArray((uint64_t)v162, (const cv::Mat *)&v173);
    cv::_InputArray::_InputArray((uint64_t)v161, (const cv::Mat *)&v186);
    cv::_InputArray::_InputArray((uint64_t)v160, (const cv::Mat *)__p);
    v155 = &v154[8];
    v156 = (cv *)&v157;
    v157 = 0;
    v158 = 0;
    *(_DWORD *)v154 = 1124007936;
    memset(&v154[4], 0, 60);
    cv::_InputArray::_InputArray((uint64_t)v159, (const cv::Mat *)v154);
    cv::SVD::backSubst((cv::SVD *)v162, (const cv::_InputArray *)v161, (const cv::_InputArray *)v160, (const cv::_InputArray *)v159, v7, v16);
    v18 = *(unsigned int **)&v154[24];
    if (*(_QWORD *)&v154[24])
    {
      do
      {
        v19 = __ldaxr(v18);
        v20 = v19 - 1;
      }
      while (__stlxr(v20, v18));
      if (!v20)
        cv::Mat::deallocate((cv::Mat *)v154, v17);
    }
    *(_QWORD *)&v154[16] = 0;
    memset(&v154[32], 0, 24);
    if (*(int *)&v154[4] >= 1)
    {
      v21 = 0;
      v22 = v155;
      do
        *(_DWORD *)&v22[4 * v21++] = 0;
      while (v21 < *(int *)&v154[4]);
    }
    *(_QWORD *)&v154[24] = 0;
    if (v156 != (cv *)&v157)
      cv::fastFree((void **)v156, v17);
    if ((_DWORD)v8 == 5)
    {
      v23 = 0.0;
      if (*(float *)v176 >= 0.00000011921)
        v23 = (float)(*((float *)v176 + (int)v12 - 1) / *(float *)v176);
    }
    else
    {
      v23 = 0.0;
      if (*(double *)v176 >= 2.22044605e-16)
        v23 = *((double *)v176 + (int)v12 - 1) / *(double *)v176;
    }
    v70 = (unsigned int *)*((_QWORD *)&v164 + 1);
    if (*((_QWORD *)&v164 + 1))
    {
      do
      {
        v71 = __ldaxr(v70);
        v72 = v71 - 1;
      }
      while (__stlxr(v72, v70));
      if (!v72)
        cv::Mat::deallocate((cv::Mat *)__p, v17);
    }
    *(_QWORD *)&v164 = 0;
    v166 = 0;
    v167 = 0;
    v165 = 0;
    if (SHIDWORD(__p[0]) >= 1)
    {
      v73 = 0;
      v74 = v169;
      do
        *((_DWORD *)v74 + v73++) = 0;
      while (v73 < SHIDWORD(__p[0]));
    }
    *((_QWORD *)&v164 + 1) = 0;
    if (v170 != (cv *)&v171)
      cv::fastFree((void **)v170, v17);
    v75 = v177;
    if (v177)
    {
      do
      {
        v76 = __ldaxr(v75);
        v77 = v76 - 1;
      }
      while (__stlxr(v77, v75));
      if (!v77)
        cv::Mat::deallocate((cv::Mat *)&v173, v17);
    }
    v176 = 0;
    v179 = 0;
    v180 = 0;
    v178 = 0;
    if (SHIDWORD(v173) >= 1)
    {
      v78 = 0;
      v79 = v182;
      do
        v79[v78++] = 0;
      while (v78 < SHIDWORD(v173));
    }
    v177 = 0;
    if (v183 != (cv *)&v184)
      cv::fastFree((void **)v183, v17);
    v80 = v190;
    if (v190)
    {
      do
      {
        v81 = __ldaxr(v80);
        v82 = v81 - 1;
      }
      while (__stlxr(v82, v80));
      if (!v82)
        cv::Mat::deallocate((cv::Mat *)&v186, v17);
    }
    v189 = 0;
    v192 = 0;
    v193 = 0;
    v191 = 0;
    if (SHIDWORD(v186) >= 1)
    {
      v83 = 0;
      v84 = v195;
      do
        v84[v83++] = 0;
      while (v83 < SHIDWORD(v186));
    }
    v190 = 0;
    v85 = (void **)v196;
    if (v196 == (cv *)&v197)
      goto LABEL_111;
    goto LABEL_110;
  }
  if (v200 != v201)
  {
    std::string::basic_string[abi:ne180100]<0>(&v186, "m == n");
    std::string::basic_string[abi:ne180100]<0>(&v173, "invert");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/lapack.cpp");
    cv::Exception::Exception(&v210, 4294967081, &v186, &v173, __p, 962);
    cv::error((cv *)&v210, v24);
  }
  if (v5 == 2)
  {
    v25 = v201 * v201;
    v210.i64[0] = (uint64_t)v211;
    v210.i64[1] = 4104;
    v26 = v211;
    if ((unint64_t)((int)v10 * (uint64_t)(int)(v201 + 2 * v201 * v201) + 8) >= 0x1009)
    {
      v210.i64[1] = (int)v10 * (uint64_t)(int)(v201 + 2 * v25) + 8;
      v26 = (_OWORD *)operator new[]();
      v210.i64[0] = (uint64_t)v26;
    }
    v187 = v12;
    v188 = v12;
    v189 = (float *)(((unint64_t)v26 + v10 - 1) & -(int)v10);
    v190 = 0;
    v195 = &v187;
    v196 = (cv *)&v197;
    HIDWORD(v186) = 2;
    LODWORD(v186) = v8 | 0x42FF4000;
    v197 = (double *)((int)v13 * (uint64_t)(int)v10);
    v198 = ((v8 >> 3) + 1) << ((0xFA50u >> (2 * (v8 & 7))) & 3);
    v193 = (char *)v189 + (_QWORD)v197 * v13;
    v194 = 0;
    v191 = v189;
    v192 = v193;
    v174 = v12;
    v175 = 1;
    v176 = (cv *)((char *)v189 + v10 * (unint64_t)v25);
    v177 = 0;
    v182 = (int *)&v174;
    v183 = (cv *)&v184;
    HIDWORD(v173) = 2;
    LODWORD(v173) = v8 | 0x42FF4000;
    v184 = (double *)v198;
    v185 = v198;
    v180 = (char *)v197 + (_QWORD)v176;
    v181 = 0;
    v178 = v176;
    v179 = (char *)v197 + (_QWORD)v176;
    LODWORD(__p[1]) = v12;
    HIDWORD(__p[1]) = v12;
    v164 = (unint64_t)v197 + (unint64_t)v176;
    v169 = &__p[1];
    v170 = (cv *)&v171;
    __p[0] = (void *)(v8 | 0x242FF4000);
    v171 = v197;
    v172 = (double *)v198;
    v167 = (char *)v197 + (_QWORD)v176 + (_QWORD)v197 * v13;
    v168 = 0;
    v165 = (char *)v197 + (_QWORD)v176;
    v166 = v167;
    cv::_InputArray::_InputArray((uint64_t)v154, (const cv::Mat *)&v199);
    cv::_OutputArray::_OutputArray((uint64_t)v162, (cv::Mat *)&v173);
    cv::_OutputArray::_OutputArray((uint64_t)v161, (cv::Mat *)__p);
    cv::eigen((cv *)v154, (const cv::_InputArray *)1, (BOOL)v162, (const cv::_OutputArray *)v161, v27);
    cv::_InputArray::_InputArray((uint64_t)v154, (const cv::Mat *)__p);
    cv::_OutputArray::_OutputArray((uint64_t)v162, (cv::Mat *)&v186);
    cv::transpose((cv *)v154, (const cv::_InputArray *)v162, v28);
    cv::_InputArray::_InputArray((uint64_t)v162, (const cv::Mat *)&v173);
    cv::_InputArray::_InputArray((uint64_t)v161, (const cv::Mat *)&v186);
    cv::_InputArray::_InputArray((uint64_t)v160, (const cv::Mat *)__p);
    v155 = &v154[8];
    v156 = (cv *)&v157;
    v157 = 0;
    v158 = 0;
    *(_DWORD *)v154 = 1124007936;
    memset(&v154[4], 0, 60);
    cv::_InputArray::_InputArray((uint64_t)v159, (const cv::Mat *)v154);
    cv::SVD::backSubst((cv::SVD *)v162, (const cv::_InputArray *)v161, (const cv::_InputArray *)v160, (const cv::_InputArray *)v159, v7, v29);
    v30 = *(unsigned int **)&v154[24];
    if (*(_QWORD *)&v154[24])
    {
      do
      {
        v31 = __ldaxr(v30);
        v32 = v31 - 1;
      }
      while (__stlxr(v32, v30));
      if (!v32)
        cv::Mat::deallocate((cv::Mat *)v154, v17);
    }
    *(_QWORD *)&v154[16] = 0;
    memset(&v154[32], 0, 24);
    if (*(int *)&v154[4] >= 1)
    {
      v33 = 0;
      v34 = v155;
      do
        *(_DWORD *)&v34[4 * v33++] = 0;
      while (v33 < *(int *)&v154[4]);
    }
    *(_QWORD *)&v154[24] = 0;
    if (v156 != (cv *)&v157)
      cv::fastFree((void **)v156, v17);
    if ((_DWORD)v8 == 5)
    {
      v23 = 0.0;
      if (*(float *)v176 >= 0.00000011921)
        v23 = (float)(*((float *)v176 + (int)v12 - 1) / *(float *)v176);
    }
    else
    {
      v23 = 0.0;
      if (*(double *)v176 >= 2.22044605e-16)
        v23 = *((double *)v176 + (int)v12 - 1) / *(double *)v176;
    }
    v88 = (unsigned int *)*((_QWORD *)&v164 + 1);
    if (*((_QWORD *)&v164 + 1))
    {
      do
      {
        v89 = __ldaxr(v88);
        v90 = v89 - 1;
      }
      while (__stlxr(v90, v88));
      if (!v90)
        cv::Mat::deallocate((cv::Mat *)__p, v17);
    }
    *(_QWORD *)&v164 = 0;
    v166 = 0;
    v167 = 0;
    v165 = 0;
    if (SHIDWORD(__p[0]) >= 1)
    {
      v91 = 0;
      v92 = v169;
      do
        *((_DWORD *)v92 + v91++) = 0;
      while (v91 < SHIDWORD(__p[0]));
    }
    *((_QWORD *)&v164 + 1) = 0;
    if (v170 != (cv *)&v171)
      cv::fastFree((void **)v170, v17);
    v93 = v177;
    if (v177)
    {
      do
      {
        v94 = __ldaxr(v93);
        v95 = v94 - 1;
      }
      while (__stlxr(v95, v93));
      if (!v95)
        cv::Mat::deallocate((cv::Mat *)&v173, v17);
    }
    v176 = 0;
    v179 = 0;
    v180 = 0;
    v178 = 0;
    if (SHIDWORD(v173) >= 1)
    {
      v96 = 0;
      v97 = v182;
      do
        v97[v96++] = 0;
      while (v96 < SHIDWORD(v173));
    }
    v177 = 0;
    if (v183 != (cv *)&v184)
      cv::fastFree((void **)v183, v17);
    v98 = v190;
    if (v190)
    {
      do
      {
        v99 = __ldaxr(v98);
        v100 = v99 - 1;
      }
      while (__stlxr(v100, v98));
      if (!v100)
        cv::Mat::deallocate((cv::Mat *)&v186, v17);
    }
    v189 = 0;
    v192 = 0;
    v193 = 0;
    v191 = 0;
    if (SHIDWORD(v186) >= 1)
    {
      v101 = 0;
      v102 = v195;
      do
        v102[v101++] = 0;
      while (v101 < SHIDWORD(v186));
    }
    v190 = 0;
    v85 = (void **)v196;
    if (v196 == (cv *)&v197)
      goto LABEL_111;
LABEL_110:
    cv::fastFree(v85, v17);
LABEL_111:
    if ((_OWORD *)v210.i64[0] != v211 && v210.i64[0] != 0)
      MEMORY[0x2207351A4]();
    goto LABEL_163;
  }
  if (v5 && v5 != 3)
  {
    std::string::basic_string[abi:ne180100]<0>(&v186, "method == DECOMP_LU || method == DECOMP_CHOLESKY");
    std::string::basic_string[abi:ne180100]<0>(&v173, "invert");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/lapack.cpp");
    cv::Exception::Exception(&v210, 4294967081, &v186, &v173, __p, 982);
    cv::error((cv *)&v210, v35);
  }
  (*(void (**)(const cv::_InputArray *, _QWORD, _QWORD, uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)v7 + 136))(v7, v201, v201, v8, 0xFFFFFFFFLL, 0, 0);
  (**(void (***)(void **__return_ptr, const cv::_InputArray *, uint64_t))v7)(&v186, v7, 0xFFFFFFFFLL);
  if ((int)v12 > 3)
  {
    v210.i64[0] = (uint64_t)v211;
    v210.i64[1] = 4104;
    v86 = (cv *)v211;
    if ((v12 * v12 * v10) >= 0x1009)
    {
      v210.i64[1] = (v12 * v12 * v10);
      v86 = (cv *)operator new[]();
      v210.i64[0] = (uint64_t)v86;
    }
    v174 = v12;
    v175 = v12;
    v176 = v86;
    v177 = 0;
    v182 = (int *)&v174;
    v183 = (cv *)&v184;
    HIDWORD(v173) = 2;
    LODWORD(v173) = v8 | 0x42FF4000;
    v184 = (double *)(v12 * (unint64_t)v10);
    v185 = ((v8 >> 3) + 1) << ((0xFA50u >> (2 * (v8 & 7))) & 3);
    v180 = (char *)v86 + (_QWORD)v184 * v12;
    v181 = 0;
    v178 = v86;
    v179 = v180;
    cv::_OutputArray::_OutputArray((uint64_t)__p, (cv::Mat *)&v173);
    cv::Mat::copyTo((cv::Mat *)&v199, (const cv::_OutputArray *)__p);
    cv::_OutputArray::_OutputArray((uint64_t)__p, (cv::Mat *)&v186);
    *(_QWORD *)v154 = 0x3FF0000000000000;
    memset(&v154[8], 0, 24);
    cv::setIdentity((void (***)(uint64_t *__return_ptr, _QWORD, uint64_t))__p, (int64x2_t *)v154);
    if (v5 || (_DWORD)v8 != 5)
    {
      if (v5 || (_DWORD)v8 != 6)
      {
        if (v5 == 3 && (_DWORD)v8 == 5)
        {
          if (cv::Cholesky(v176, (unint64_t)v184, v12, v189, (unint64_t)v197, v12))
            goto LABEL_81;
        }
        else if (cv::Cholesky(v176, (unint64_t)v184, v12, (double *)v189, (unint64_t)v197, v12))
        {
          goto LABEL_81;
        }
      }
      else if (cv::LU(v176, (unint64_t)v184, v12, (uint64_t *)v189, (unint64_t)v197, v12))
      {
        goto LABEL_81;
      }
    }
    else if (cv::LU(v176, (unint64_t)v184, v12, (int *)v189, (unint64_t)v197, v12))
    {
LABEL_81:
      v87 = 1;
      goto LABEL_120;
    }
    *(_OWORD *)__p = 0u;
    v164 = 0u;
    cv::Mat::operator=((uint64_t)&v186, (int64x2_t *)__p);
    v87 = 0;
LABEL_120:
    v104 = v177;
    if (v177)
    {
      do
      {
        v105 = __ldaxr(v104);
        v106 = v105 - 1;
      }
      while (__stlxr(v106, v104));
      if (!v106)
        cv::Mat::deallocate((cv::Mat *)&v173, v17);
    }
    v176 = 0;
    v179 = 0;
    v180 = 0;
    v178 = 0;
    if (SHIDWORD(v173) >= 1)
    {
      v107 = 0;
      v108 = v182;
      do
        v108[v107++] = 0;
      while (v107 < SHIDWORD(v173));
    }
    v177 = 0;
    if (v183 != (cv *)&v184)
      cv::fastFree((void **)v183, v17);
    if ((_OWORD *)v210.i64[0] != v211 && v210.i64[0] != 0)
      MEMORY[0x2207351A4]();
    goto LABEL_153;
  }
  v36 = v202;
  v37 = v189;
  v38 = v197;
  switch((_DWORD)v12)
  {
    case 2:
      if ((_DWORD)v8 == 5)
      {
        v110 = *(float *)v202;
        v111 = (float *)(v202 + v209);
        v112 = *(float *)(v202 + v209 + 4);
        v113 = v110 * v112 - *(float *)(v202 + 4) * *(float *)(v202 + v209);
        if (v113 != 0.0)
        {
          v114 = 1.0 / v113;
          v115 = v114 * v110;
          v116 = (float *)((char *)v197 + (_QWORD)v189);
          v116[1] = v115;
          v117 = v114 * v112;
          *v37 = v117;
          v118 = v114 * (float)-*v111;
          v119 = v114 * (float)-*(float *)(v36 + 4);
          v37[1] = v119;
          v120 = v118;
          *v116 = v120;
          goto LABEL_151;
        }
      }
      else
      {
        v137 = (double *)(v202 + v209);
        v138 = *(double *)(v202 + v209 + 8);
        v139 = *(double *)v202 * v138 - *(double *)(v202 + 8) * *(double *)(v202 + v209);
        if (v139 != 0.0)
        {
          v140 = 1.0 / v139;
          v141 = (double *)((char *)v197 + (_QWORD)v189);
          v141[1] = *(double *)v202 * v140;
          *(double *)v37 = v138 * v140;
          v142 = -(*v137 * v140);
          *((double *)v37 + 1) = -(*(double *)(v36 + 8) * v140);
          *v141 = v142;
          goto LABEL_151;
        }
      }
      break;
    case 3:
      if ((_DWORD)v8 == 5)
      {
        v39 = *(float *)v202;
        v40 = *(float *)(v202 + v209 + 4);
        v41 = (float *)(v202 + 2 * v209);
        v42 = v41[2];
        v43 = *(float *)(v202 + v209 + 8);
        v44 = v41[1];
        v45 = v40 * v42 - v43 * v44;
        v46 = *(float *)(v202 + 4);
        v47 = *(float *)(v202 + v209);
        v48 = *v41;
        v49 = *(float *)(v202 + 8);
        v50 = v47 * v44 - v40 * v48;
        v51 = v39 * v45 - (v47 * v42 - v43 * v48) * v46 + v49 * v50;
        if (v51 != 0.0)
        {
          v52 = 1.0 / v51;
          v53 = (v49 * v44 - v46 * v42) * v52;
          v54 = (v46 * v43 - v49 * v40) * v52;
          v55 = (v43 * v48 - v47 * v42) * v52;
          v56 = (v39 * v42 - v49 * v48) * v52;
          v57 = (v49 * v47 - v39 * v43) * v52;
          v58 = (v46 * v48 - v39 * v44) * v52;
          v59 = (v39 * v40 - v46 * v47) * v52;
          v60 = v45 * v52;
          v61 = v53;
          *v189 = v60;
          v37[1] = v61;
          v62 = v54;
          v37[2] = v62;
          v63 = v55;
          v64 = (float *)((char *)v38 + (_QWORD)v37);
          v65 = v56;
          *v64 = v63;
          v64[1] = v65;
          v66 = v57;
          v64[2] = v66;
          v67 = v50 * v52;
          v68 = (float *)((char *)v37 + 2 * (_QWORD)v38);
          v69 = v58;
          *v68 = v67;
          v68[1] = v69;
          *(float *)&v59 = v59;
          v68[2] = *(float *)&v59;
LABEL_151:
          v87 = 1;
          goto LABEL_153;
        }
      }
      else
      {
        v121 = (double *)(v202 + 2 * v209);
        v122 = v121[1];
        v123 = v121[2];
        v124 = *(double *)(v202 + v209 + 8);
        v125 = *(double *)(v202 + v209 + 16);
        v126 = *v121;
        v127 = *(double *)(v202 + v209);
        v128 = v124 * v123 - v125 * v122;
        v129 = *(double *)v202;
        v130 = *(double *)(v202 + 8);
        v131 = *(double *)(v202 + 16);
        v132 = v127 * v122 - v124 * *v121;
        v133 = *(double *)v202 * v128 - v130 * (v127 * v123 - v125 * *v121) + v131 * v132;
        if (v133 != 0.0)
        {
          v134 = 1.0 / v133;
          *(double *)v189 = v128 * v134;
          *((double *)v37 + 1) = (v123 * -v130 + v131 * v122) * v134;
          *((double *)v37 + 2) = (v130 * v125 - v131 * v124) * v134;
          v135 = (double *)((char *)v38 + (_QWORD)v37);
          *v135 = (v125 * v126 - v127 * v123) * v134;
          v135[1] = (v129 * v123 - v131 * v126) * v134;
          v135[2] = (v131 * v127 - v129 * v125) * v134;
          v136 = (double *)((char *)v37 + 2 * (_QWORD)v38);
          *v136 = v132 * v134;
          v136[1] = (v130 * v126 - v129 * v122) * v134;
          v136[2] = (v127 * -v130 + v129 * v124) * v134;
          goto LABEL_151;
        }
      }
      break;
    case 1:
      if ((_DWORD)v8 == 5)
      {
        if (*(float *)v202 != 0.0)
        {
          *v189 = 1.0 / *(float *)v202;
          goto LABEL_151;
        }
      }
      else if (*(double *)v202 != 0.0)
      {
        *(double *)v189 = 1.0 / *(double *)v202;
        goto LABEL_151;
      }
      break;
    default:
      __assert_rtn("invert", "lapack.cpp", 1137, "n == 1");
  }
  v210 = 0u;
  v211[0] = 0u;
  cv::Mat::operator=((uint64_t)&v186, &v210);
  v87 = 0;
LABEL_153:
  v143 = v190;
  if (v190)
  {
    do
    {
      v144 = __ldaxr(v143);
      v145 = v144 - 1;
    }
    while (__stlxr(v145, v143));
    if (!v145)
      cv::Mat::deallocate((cv::Mat *)&v186, v17);
  }
  v189 = 0;
  v191 = 0;
  v192 = 0;
  v193 = 0;
  if (SHIDWORD(v186) >= 1)
  {
    v146 = 0;
    v147 = v195;
    do
      v147[v146++] = 0;
    while (v146 < SHIDWORD(v186));
  }
  v190 = 0;
  if (v196 != (cv *)&v197)
    cv::fastFree((void **)v196, v17);
  v23 = (double)v87;
LABEL_163:
  v148 = v203;
  if (v203)
  {
    do
    {
      v149 = __ldaxr(v148);
      v150 = v149 - 1;
    }
    while (__stlxr(v150, v148));
    if (!v150)
      cv::Mat::deallocate((cv::Mat *)&v199, v17);
  }
  v202 = 0;
  v204 = 0;
  v206 = 0;
  v205 = 0;
  if (SHIDWORD(v199) >= 1)
  {
    v151 = 0;
    v152 = v207;
    do
      *(_DWORD *)(v152 + 4 * v151++) = 0;
    while (v151 < SHIDWORD(v199));
  }
  v203 = 0;
  if (v208 != (cv *)&v209)
    cv::fastFree((void **)v208, v17);
  return v23;
}

void sub_219E62C48(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *__p,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,void *a61)
{
  void *v62;

  cv::Mat::~Mat((cv::Mat *)&a61, a2);
  cv::Mat::~Mat((cv::Mat *)&STACK[0x200], v62);
  _Unwind_Resume(a1);
}

void cv::SVD::backSubst(cv::SVD *this, const cv::_InputArray *a2, const cv::_InputArray *a3, const cv::_InputArray *a4, const cv::_InputArray *a5, const cv::_OutputArray *a6)
{
  void (***v6)(uint64_t *__return_ptr, _QWORD, uint64_t);
  uint64_t v7;
  uint64_t v8;
  void (***v9)(uint64_t *__return_ptr, _QWORD, uint64_t);
  void (***v10)(uint64_t *__return_ptr, _QWORD, uint64_t);
  void (***v11)(uint64_t *__return_ptr, _QWORD, uint64_t);
  void (***v12)(uint64_t *__return_ptr, _QWORD, uint64_t);
  void (***v13)(uint64_t *__return_ptr, _QWORD, uint64_t);
  void (***v14)(uint64_t *__return_ptr, _QWORD, uint64_t);
  uint64_t v15;
  uint64_t v16;
  cv *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  const cv::Exception *v23;
  const cv::Exception *v24;
  int v25;
  int v26;
  const cv::Exception *v27;
  void *v28;
  const cv::Exception *v29;
  unsigned int *v30;
  unsigned int v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int *v36;
  unsigned int v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  unsigned int *v41;
  unsigned int v42;
  unsigned int v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int *v46;
  unsigned int v47;
  unsigned int v48;
  uint64_t v49;
  uint64_t v50;
  unsigned int *v51;
  unsigned int v52;
  unsigned int v53;
  uint64_t v54;
  _DWORD *v55;
  double *v56;
  unint64_t v57;
  void *v58[2];
  void *v59[2];
  double *v60;
  unsigned int *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  cv *v66;
  uint64_t v67;
  void *__p[2];
  void *v69[2];
  _BYTE v70[120];
  uint64_t v71;
  int v72;
  unsigned int v73;
  unint64_t v74;
  unsigned int *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  cv *v80;
  unint64_t v81;
  uint64_t v82;
  int v83;
  unsigned int v84;
  BOOL v85[8];
  unsigned int *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  cv *v91;
  double *v92;
  uint64_t v93;
  unsigned int v94;
  int v95;
  unint64_t v96;
  unsigned int *v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  cv *v102;
  double *v103;
  uint64_t v104;
  int v105;
  int v106;
  int v107[2];
  unsigned int *v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  _DWORD *v112;
  cv *v113;
  uint64_t v114;
  double *v115;
  uint64_t v116;
  _QWORD v117[516];

  v6 = (void (***)(uint64_t *__return_ptr, _QWORD, uint64_t))MEMORY[0x24BDAC7A8](this, a2);
  v8 = v7;
  v10 = v9;
  v12 = v11;
  v14 = v13;
  v117[515] = *MEMORY[0x24BDAC8D0];
  (**v6)(&v104, v6, 0xFFFFFFFFLL);
  (**v14)(&v93, v14, 0xFFFFFFFFLL);
  (**v12)(&v82, v12, 0xFFFFFFFFLL);
  (**v10)(&v71, v10, 0xFFFFFFFFLL);
  if (SHIDWORD(v104) < 1)
    LODWORD(v15) = 0;
  else
    v15 = *((_QWORD *)v113 + (HIDWORD(v104) - 1));
  v16 = v104 & 0xFFF;
  v17 = (cv *)v94;
  v18 = v84;
  if (v74)
    v19 = v73;
  else
    v19 = v94;
  if ((int)v84 >= (int)v94)
    v20 = v94;
  else
    v20 = v84;
  if (v105 == 1)
  {
    v21 = (int)v15;
  }
  else
  {
    v21 = v114;
    if (v106 != 1)
      v21 = v114 + (int)v15;
  }
  v115 = (double *)v117;
  v116 = 4104;
  v22 = v104 & 0xFFF;
  if ((unint64_t)(8 * (int)v19 + 16) >= 0x1009)
  {
    v116 = 8 * (int)v19 + 16;
    v115 = (double *)operator new[]();
    v22 = v104 & 0xFFF;
  }
  if (v22 != (v93 & 0xFFF) || v22 != (v82 & 0xFFF) || !v96 || !*(_QWORD *)v85 || !*(_QWORD *)v107)
  {
    std::string::basic_string[abi:ne180100]<0>(v59, "w.type() == u.type() && u.type() == vt.type() && u.data && vt.data && w.data");
    std::string::basic_string[abi:ne180100]<0>(v69, "backSubst");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/lapack.cpp");
    cv::Exception::Exception(v70, 4294967081, v59, v69, __p, 1598);
    cv::error((cv *)v70, v23);
  }
  if (v95 < v20
    || v83 < v20
    || ((v25 = *v112, v26 = v112[1], v26 != v20) || v25 != 1) && (v26 != 1 || v25 != v20) && (v26 != v83 || v25 != v95))
  {
    std::string::basic_string[abi:ne180100]<0>(v59, "u.cols >= nm && vt.rows >= nm && (w.size() == Size(nm, 1) || w.size() == Size(1, nm) || w.size() == Size(vt.rows, u.cols))");
    std::string::basic_string[abi:ne180100]<0>(v69, "backSubst");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/lapack.cpp");
    cv::Exception::Exception(v70, 4294967081, v59, v69, __p, 1600);
    cv::error((cv *)v70, v24);
  }
  if (v74 && ((v71 & 0xFFF) != (_DWORD)v16 || v72 != (_DWORD)v17))
  {
    std::string::basic_string[abi:ne180100]<0>(v59, "rhs.data == 0 || (rhs.type() == type && rhs.rows == m)");
    std::string::basic_string[abi:ne180100]<0>(v69, "backSubst");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/lapack.cpp");
    cv::Exception::Exception(v70, 4294967081, v59, v69, __p, 1601);
    cv::error((cv *)v70, v27);
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)v8 + 136))(v8, v18, v19, v16, 0xFFFFFFFFLL, 0, 0);
  (**(void (***)(void **__return_ptr, uint64_t, uint64_t))v8)(v59, v8, 0xFFFFFFFFLL);
  if ((_DWORD)v16 == 6)
  {
    LODWORD(v56) = v19;
    cv::SVBkSb(v17, v18, *(double **)v107, v21, (double *)v96, (uint64_t)v103, 0, *(uint64_t *)v85, v92, v74, v81, v56, v60, v67, v115, v57, (unsigned __int8 *)v58[0]);
  }
  else
  {
    if ((_DWORD)v16 != 5)
    {
      std::string::basic_string[abi:ne180100]<0>(v69, "");
      std::string::basic_string[abi:ne180100]<0>(__p, "backSubst");
      std::string::basic_string[abi:ne180100]<0>(v58, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/lapack.cpp");
      cv::Exception::Exception(v70, 4294967086, v69, __p, v58, 1614);
      cv::error((cv *)v70, v29);
    }
    LODWORD(v56) = v19;
    cv::SVBkSb(v17, v18, *(float **)v107, v21, (float *)v96, (uint64_t)v103, 0, *(uint64_t *)v85, (const float *)v92, v74, v81, (const float *)v56, (float *)v60, v67, (float *)v115, v57, (unsigned __int8 *)v58[0]);
  }
  v30 = v61;
  if (v61)
  {
    do
    {
      v31 = __ldaxr(v30);
      v32 = v31 - 1;
    }
    while (__stlxr(v32, v30));
    if (!v32)
      cv::Mat::deallocate((cv::Mat *)v59, v28);
  }
  v60 = 0;
  v62 = 0;
  v63 = 0;
  v64 = 0;
  if (SHIDWORD(v59[0]) >= 1)
  {
    v33 = 0;
    v34 = v65;
    do
      *(_DWORD *)(v34 + 4 * v33++) = 0;
    while (v33 < SHIDWORD(v59[0]));
  }
  v61 = 0;
  if (v66 != (cv *)&v67)
    cv::fastFree((void **)v66, v28);
  if (v115 != (double *)v117 && v115 != 0)
    MEMORY[0x2207351A4]();
  v36 = v75;
  if (v75)
  {
    do
    {
      v37 = __ldaxr(v36);
      v38 = v37 - 1;
    }
    while (__stlxr(v38, v36));
    if (!v38)
      cv::Mat::deallocate((cv::Mat *)&v71, v28);
  }
  v74 = 0;
  v76 = 0;
  v77 = 0;
  v78 = 0;
  if (SHIDWORD(v71) >= 1)
  {
    v39 = 0;
    v40 = v79;
    do
      *(_DWORD *)(v40 + 4 * v39++) = 0;
    while (v39 < SHIDWORD(v71));
  }
  v75 = 0;
  if (v80 != (cv *)&v81)
    cv::fastFree((void **)v80, v28);
  v41 = v86;
  if (v86)
  {
    do
    {
      v42 = __ldaxr(v41);
      v43 = v42 - 1;
    }
    while (__stlxr(v43, v41));
    if (!v43)
      cv::Mat::deallocate((cv::Mat *)&v82, v28);
  }
  *(_QWORD *)v85 = 0;
  v87 = 0;
  v88 = 0;
  v89 = 0;
  if (SHIDWORD(v82) >= 1)
  {
    v44 = 0;
    v45 = v90;
    do
      *(_DWORD *)(v45 + 4 * v44++) = 0;
    while (v44 < SHIDWORD(v82));
  }
  v86 = 0;
  if (v91 != (cv *)&v92)
    cv::fastFree((void **)v91, v28);
  v46 = v97;
  if (v97)
  {
    do
    {
      v47 = __ldaxr(v46);
      v48 = v47 - 1;
    }
    while (__stlxr(v48, v46));
    if (!v48)
      cv::Mat::deallocate((cv::Mat *)&v93, v28);
  }
  v96 = 0;
  v98 = 0;
  v100 = 0;
  v99 = 0;
  if (SHIDWORD(v93) >= 1)
  {
    v49 = 0;
    v50 = v101;
    do
      *(_DWORD *)(v50 + 4 * v49++) = 0;
    while (v49 < SHIDWORD(v93));
  }
  v97 = 0;
  if (v102 != (cv *)&v103)
    cv::fastFree((void **)v102, v28);
  v51 = v108;
  if (v108)
  {
    do
    {
      v52 = __ldaxr(v51);
      v53 = v52 - 1;
    }
    while (__stlxr(v53, v51));
    if (!v53)
      cv::Mat::deallocate((cv::Mat *)&v104, v28);
  }
  *(_QWORD *)v107 = 0;
  v109 = 0;
  v111 = 0;
  v110 = 0;
  if (SHIDWORD(v104) >= 1)
  {
    v54 = 0;
    v55 = v112;
    do
      v55[v54++] = 0;
    while (v54 < SHIDWORD(v104));
  }
  v108 = 0;
  if (v113 != (cv *)&v114)
    cv::fastFree((void **)v113, v28);
}

void sub_219E63608(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,void *a41,uint64_t a42,int a43,__int16 a44,char a45,char a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,char a62,uint64_t a63)
{
  char a72;
  uint64_t v72;
  void *v74;
  void *v75;
  unint64_t v76;
  void *v77;
  void *v78;
  void *v79;

  cv::Exception::~Exception((cv::Exception *)&a47);
  if (a22 < 0)
    operator delete(__p);
  if (a40 < 0)
    operator delete(a35);
  if (a46 < 0)
    operator delete(a41);
  cv::Mat::~Mat((cv::Mat *)&a23, v74);
  v76 = STACK[0x2E0];
  if (STACK[0x2E0] != v72)
  {
    if (v76)
      MEMORY[0x2207351A4](v76, 0x1000C8077774924);
  }
  cv::Mat::~Mat((cv::Mat *)&a62, v75);
  cv::Mat::~Mat((cv::Mat *)&a72, v77);
  cv::Mat::~Mat((cv::Mat *)&STACK[0x220], v78);
  cv::Mat::~Mat((cv::Mat *)&STACK[0x280], v79);
  _Unwind_Resume(a1);
}

void sub_219E63770()
{
  JUMPOUT(0x219E63750);
}

void sub_219E63778()
{
  JUMPOUT(0x219E63758);
}

void sub_219E63780()
{
  JUMPOUT(0x219E63760);
}

void sub_219E63788()
{
  JUMPOUT(0x219E63768);
}

uint64_t cv::solve(cv *this, const cv::_InputArray *a2, const cv::_InputArray *a3, const cv::_OutputArray *a4)
{
  void (***v4)(uint64_t *__return_ptr, _QWORD, uint64_t);
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  void (***v9)(int *__return_ptr, _QWORD, uint64_t);
  void (***v10)(int *__return_ptr, _QWORD, uint64_t);
  int v11;
  const cv::Exception *v13;
  const cv::Exception *v14;
  void *v15;
  float *v16;
  uint64_t v17;
  double v18;
  double v19;
  float *v20;
  float v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  float v37;
  double v38;
  float v39;
  double v40;
  float v41;
  float v42;
  unsigned int v43;
  BOOL v44;
  int v45;
  uint64_t v46;
  int v47;
  unsigned int *v48;
  unint64_t v49;
  unsigned int v50;
  int v51;
  cv *v52;
  cv *v53;
  uint64_t v54;
  const cv::Exception *v55;
  int v56;
  int v57;
  int v58;
  unsigned int v59;
  int v60;
  unint64_t v61;
  int v62;
  int v63;
  unint64_t v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t v67;
  float **v68;
  cv *v69;
  unint64_t v70;
  int v72;
  unsigned int v73;
  cv *v74;
  uint64_t (***v75)(cv::_InputArray *__hidden, int);
  unsigned __int8 *v76;
  void *v77;
  unsigned int *v78;
  unsigned int v79;
  unsigned int v80;
  uint64_t v81;
  _BYTE *v82;
  uint64_t v83;
  uint64_t v84;
  BOOL v85;
  int v86;
  unsigned int v87;
  char *v88;
  const cv::_OutputArray *v89;
  void *v90;
  unsigned int *v91;
  unsigned int v92;
  unsigned int v93;
  uint64_t v94;
  char *v95;
  unsigned int *v96;
  unsigned int v97;
  unsigned int *v98;
  unsigned int v99;
  unsigned int v100;
  uint64_t v101;
  int *v102;
  double v103;
  double v104;
  double v105;
  double v106;
  double v107;
  double v108;
  double v109;
  double v110;
  float v111;
  float v112;
  cv *v113;
  cv *v114;
  unsigned int *v115;
  unsigned int v116;
  unsigned int v117;
  uint64_t v118;
  _BYTE *v119;
  char *v120;
  unint64_t v121;
  int v123;
  unint64_t v124;
  uint64_t v125;
  float *v126;
  void *v127;
  uint64_t v128;
  void *v129;
  unsigned int *v130;
  unsigned int v131;
  unsigned int *v132;
  unsigned int v133;
  unsigned int v134;
  uint64_t v135;
  _BYTE *v136;
  unsigned int *v137;
  unsigned int v138;
  unsigned int *v139;
  unsigned int v140;
  unsigned int v141;
  uint64_t v142;
  _BYTE *v143;
  cv *v144;
  cv *v145;
  unsigned int **v146;
  uint64_t *v147;
  char **v148;
  uint64_t *v149;
  float *v150;
  cv **v151;
  cv *v152;
  cv *v153;
  cv *v154;
  char *v155;
  unsigned int *v156;
  unsigned int v157;
  unsigned int v158;
  uint64_t v159;
  _BYTE *v160;
  unsigned int *v161;
  unsigned int v162;
  unsigned int v163;
  uint64_t v164;
  char *v165;
  unsigned int *v166;
  unsigned int v167;
  unsigned int v168;
  uint64_t v169;
  _BYTE *v170;
  unsigned int *v171;
  unsigned int v172;
  unsigned int v173;
  uint64_t v174;
  unint64_t *v175;
  unsigned int *v176;
  unsigned int v177;
  unsigned int v178;
  uint64_t v179;
  uint64_t v180;
  unsigned int *v181;
  unsigned int v182;
  unsigned int v183;
  uint64_t v184;
  int *v185;
  unsigned int *v187;
  unsigned int v188;
  unsigned int v189;
  uint64_t v190;
  uint64_t v191;
  unsigned int *v192;
  unsigned int v193;
  unsigned int v194;
  uint64_t v195;
  uint64_t v196;
  double *v198;
  double v199;
  double v200;
  double v201;
  double v202;
  double v203;
  double v204;
  double v205;
  double v206;
  double v207;
  double v208;
  double v209;
  double v210;
  double v211;
  double v212;
  double v213;
  double v214;
  double v215;
  double v216;
  double v217;
  double v218;
  double v219;
  double v220;
  double v221;
  double v222;
  unsigned int *v223;
  unsigned int v224;
  unsigned int v225;
  uint64_t v226;
  uint64_t v227;
  double *v228;
  cv *v229;
  unsigned __int8 *v230;
  unsigned __int8 *v231;
  uint64_t v232;
  unint64_t v233;
  cv *v234;
  int v235;
  unint64_t v236;
  _BYTE v237[64];
  _BYTE *v238;
  cv *v239;
  double *v240[2];
  _BYTE v241[32];
  _OWORD v242[4];
  char *v243;
  cv *v244;
  unint64_t v245;
  unint64_t v246;
  _BYTE v247[32];
  _BYTE v248[32];
  _BYTE v249[64];
  _BYTE *v250;
  cv *v251;
  double *v252;
  unint64_t v253;
  void *v254;
  unint64_t v255;
  cv *v256;
  unsigned int *v257;
  cv *v258;
  uint64_t v259;
  char *v260;
  uint64_t v261;
  unint64_t *v262;
  cv *v263;
  double *v264;
  unint64_t v265;
  void *__p[2];
  float *v267;
  unsigned int *v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  cv *v273;
  double *v274;
  int v275;
  int v276[3];
  float *v277;
  __int128 v278;
  __int128 v279;
  uint64_t v280;
  int *v281;
  cv *v282;
  uint64_t v283[2];
  int v284;
  uint64_t v285;
  int v286;
  float *v287;
  __int128 v288;
  __int128 v289;
  uint64_t v290;
  uint64_t v291;
  cv *v292;
  uint64_t v293;
  uint64_t v294;
  int v295;
  unsigned int v296;
  uint64_t v297;
  unsigned int *v298;
  uint64_t v299;
  uint64_t v300;
  uint64_t v301;
  uint64_t v302;
  cv *v303;
  uint64_t v304;
  float **v305;
  unint64_t v306;
  float *v307;
  unsigned int *v308;
  uint64_t v309;
  uint64_t v310;
  uint64_t v311;
  uint64_t v312;
  cv *v313;
  _QWORD v314[510];

  v4 = (void (***)(uint64_t *__return_ptr, _QWORD, uint64_t))MEMORY[0x24BDAC7A8](this, a2);
  v6 = v5;
  v8 = v7;
  v10 = v9;
  v314[507] = *MEMORY[0x24BDAC8D0];
  (**v4)(&v294, v4, 0xFFFFFFFFLL);
  (**v10)(&v284, v10, 0xFFFFFFFFLL);
  v11 = v294 & 0xFFF;
  if (v11 != (v284 & 0xFFF) || (v11 - 5) >= 2)
  {
    std::string::basic_string[abi:ne180100]<0>(&v254, "type == _src2.type() && (type == CV_32F || type == CV_64F)");
    std::string::basic_string[abi:ne180100]<0>(&v275, "solve");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/lapack.cpp");
    cv::Exception::Exception(&v305, 4294967081, &v254, &v275, __p, 1197);
    cv::error((cv *)&v305, v13);
  }
  if (v6 <= 0x13 && ((1 << v6) & 0x90009) != 0)
  {
    if ((v6 & 0x10) == 0 && v295 != v296)
    {
      std::string::basic_string[abi:ne180100]<0>(&v254, "(method != DECOMP_LU && method != DECOMP_CHOLESKY) || is_normal || src.rows == src.cols");
      std::string::basic_string[abi:ne180100]<0>(&v275, "solve");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/lapack.cpp");
      cv::Exception::Exception(&v305, 4294967081, &v254, &v275, __p, 1201);
      cv::error((cv *)&v305, v14);
    }
    if (((1 << v6) & 0x90009) != 0 && (v6 & 0x10) == 0 && v295 <= 3 && v295 == v296 && v286 == 1)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v8 + 136))(v8);
      (**(void (***)(float ***__return_ptr, uint64_t, uint64_t))v8)(&v305, v8, 0xFFFFFFFFLL);
      v16 = v307;
      v17 = v314[0];
      switch(v295)
      {
        case 2:
          if (v11 == 5)
          {
            v103 = *(float *)v297;
            v104 = *(float *)(v297 + v304 + 4);
            v105 = *(float *)(v297 + 4);
            v106 = *(float *)(v297 + v304);
            v107 = v103 * v104 - v105 * v106;
            if (v107 != 0.0)
            {
              v108 = 1.0 / v107;
              v109 = *v287;
              v110 = *(float *)((char *)v287 + v293);
              v111 = v108 * (v109 * v104 - v110 * v105);
              v112 = v108 * (v110 * v103 - v109 * v106);
              *(float *)((char *)v307 + v314[0]) = v112;
              *v16 = v111;
              goto LABEL_306;
            }
          }
          else
          {
            v217 = *(double *)(v297 + 8);
            v218 = *(double *)(v297 + v304 + 8);
            v219 = *(double *)v297 * v218 - v217 * *(double *)(v297 + v304);
            if (v219 != 0.0)
            {
              v220 = 1.0 / v219;
              v221 = *(double *)((char *)v287 + v293);
              v222 = v220 * (*(double *)v287 * v218 - v221 * v217);
              *(double *)((char *)v307 + v314[0]) = v220
                                                  * (v221 * *(double *)v297 - *(double *)v287 * *(double *)(v297 + v304));
              *(double *)v16 = v222;
              goto LABEL_306;
            }
          }
          break;
        case 3:
          if (v11 == 5)
          {
            v18 = *(float *)v297;
            v19 = *(float *)(v297 + v304 + 4);
            v20 = (float *)(v297 + 2 * v304);
            v21 = v20[2];
            v22 = v21;
            v23 = *(float *)(v297 + v304 + 8);
            v24 = v20[1];
            v25 = v19 * v21 - v23 * v24;
            v26 = *(float *)(v297 + 4);
            v27 = *(float *)(v297 + v304);
            v28 = *v20;
            v29 = -(v23 * v28);
            v30 = *(float *)(v297 + 8);
            v31 = v27 * v24 - v19 * v28;
            v32 = v18 * v25 - (v27 * v21 - v23 * v28) * v26 + v30 * v31;
            if (v32 != 0.0)
            {
              v33 = -v23;
              v34 = -(v29 + v27 * v22);
              v35 = 1.0 / v32;
              v36 = *v287;
              v37 = *(float *)((char *)v287 + v293);
              v38 = *(float *)((char *)v287 + 2 * v293);
              v39 = v35 * (v36 * v25 - (v33 * v38 + v37 * v22) * v26 + v30 * (-v19 * v38 + v37 * v24));
              v40 = v27 * v38 - v37 * v28;
              v41 = v35 * (v34 * v36 + v18 * ((float)(v21 * v37) + v33 * v38) + v30 * v40);
              v42 = v35 * (v18 * (v19 * v38 - v37 * v24) - v40 * v26 + v36 * v31);
              *v307 = v39;
              *(float *)((char *)v16 + v17) = v41;
              *(float *)((char *)v16 + 2 * v17) = v42;
LABEL_306:
              v128 = 1;
              goto LABEL_308;
            }
          }
          else
          {
            v198 = (double *)(v297 + 2 * v304);
            v199 = v198[1];
            v200 = v198[2];
            v201 = *(double *)(v297 + v304 + 8);
            v202 = *(double *)(v297 + v304 + 16);
            v203 = *v198;
            v204 = *(double *)(v297 + v304);
            v205 = v201 * v200 - v202 * v199;
            v206 = *(double *)v297;
            v207 = *(double *)(v297 + 8);
            v208 = *(double *)(v297 + 16);
            v209 = v204 * v199 - v201 * *v198;
            v210 = *(double *)v297 * v205 - v207 * (v204 * v200 - v202 * *v198) + v208 * v209;
            if (v210 != 0.0)
            {
              v211 = 1.0 / v210;
              v212 = *(double *)((char *)v287 + v293);
              v213 = *(double *)((char *)v287 + 2 * v293);
              v214 = v211
                   * ((v200 * -v207 + v208 * v199) * v212 + v205 * *(double *)v287 + (v207 * v202 - v208 * v201) * v213);
              v215 = v211
                   * ((v206 * v200 - v208 * v203) * v212
                    + (v202 * v203 - v204 * v200) * *(double *)v287
                    + (v208 * v204 - v206 * v202) * v213);
              v216 = v211
                   * ((v207 * v203 - v206 * v199) * v212 + v209 * *(double *)v287 + (v204 * -v207 + v206 * v201) * v213);
              *(double *)v307 = v214;
              *(double *)((char *)v16 + v17) = v215;
              *(double *)((char *)v16 + 2 * v17) = v216;
              goto LABEL_306;
            }
          }
          break;
        case 1:
          if (v11 == 5)
          {
            if (*(float *)v297 != 0.0)
            {
              *v307 = *v287 / *(float *)v297;
              goto LABEL_306;
            }
          }
          else if (*(double *)v297 != 0.0)
          {
            *(double *)v307 = *(double *)v287 / *(double *)v297;
            goto LABEL_306;
          }
          break;
        default:
          __assert_rtn("solve", "lapack.cpp", 1314, "src.rows == 1");
      }
      v128 = 0;
LABEL_308:
      v223 = v308;
      if (v308)
      {
        do
        {
          v224 = __ldaxr(v223);
          v225 = v224 - 1;
        }
        while (__stlxr(v225, v223));
        if (!v225)
          cv::Mat::deallocate((cv::Mat *)&v305, v15);
      }
      v307 = 0;
      v309 = 0;
      v311 = 0;
      v310 = 0;
      if (SHIDWORD(v305) >= 1)
      {
        v226 = 0;
        v227 = v312;
        do
          *(_DWORD *)(v227 + 4 * v226++) = 0;
        while (v226 < SHIDWORD(v305));
      }
      v308 = 0;
      if (v313 != (cv *)v314)
        cv::fastFree((void **)v313, v15);
      goto LABEL_281;
    }
  }
  if ((v6 & 0xFFFFFFEF) == 4)
    v43 = 1;
  else
    v43 = v6 & 0xFFFFFFEF;
  v44 = v43 == 1 && (v6 & 0x10) == 0;
  v45 = v295;
  v46 = v296;
  v305 = &v307;
  v306 = 4104;
  *(_QWORD *)v276 = v285;
  v47 = (((unsigned __int16)(v294 & 0xFFF) >> 3) + 1) << ((0xFA50u >> (2 * (v294 & 7))) & 3);
  v232 = v47 * (uint64_t)(int)v296;
  v275 = v284;
  v235 = v286;
  v236 = v47;
  v276[2] = v286;
  v48 = (unsigned int *)v288;
  v278 = v288;
  v233 = (v232 + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v44)
    v49 = (v295 * (uint64_t)v47 + 15) & 0xFFFFFFFFFFFFFFF0;
  else
    v49 = (v232 + 15) & 0xFFFFFFFFFFFFFFF0;
  v279 = v289;
  v277 = v287;
  v280 = v290;
  v281 = &v276[1];
  v282 = (cv *)v283;
  v283[1] = 0;
  v283[0] = 0;
  if ((_QWORD)v288)
  {
    do
      v50 = __ldaxr(v48);
    while (__stlxr(v50 + 1, v48));
    v51 = v285;
  }
  else
  {
    v51 = v285;
  }
  if (v51 > 2)
  {
    v276[0] = 0;
    cv::Mat::copySize((cv::Mat *)&v275, (const cv::Mat *)&v284);
  }
  else
  {
    v52 = v292;
    v53 = v282;
    *(_QWORD *)v282 = *(_QWORD *)v292;
    *((_QWORD *)v53 + 1) = *((_QWORD *)v52 + 1);
  }
  (*(void (**)(uint64_t, _QWORD, _QWORD, uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)v8 + 136))(v8, v296, v276[2], v294 & 0xFFF, 0xFFFFFFFFLL, 0, 0);
  (**(void (***)(void **__return_ptr, uint64_t, uint64_t))v8)(__p, v8, 0xFFFFFFFFLL);
  v54 = v46;
  if (v45 < (int)v46)
  {
    std::string::basic_string[abi:ne180100]<0>(v249, "The function can not solve under-determined linear systems");
    std::string::basic_string[abi:ne180100]<0>(v242, "solve");
    std::string::basic_string[abi:ne180100]<0>(v237, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/lapack.cpp");
    cv::Exception::Exception(&v254, 4294967291, v249, v242, v237, 1350);
    cv::error((cv *)&v254, v55);
  }
  v56 = v11;
  v57 = (v6 >> 4) & 1;
  if (v43 == 1)
    v58 = 2;
  else
    v58 = v43;
  if ((v6 & 0x10) != 0)
    v57 = 1;
  else
    v58 = v43;
  if ((v6 & 0x10) != 0)
    v59 = v54;
  else
    v59 = v45;
  if (v45 == (_DWORD)v54)
    v60 = 0;
  else
    v60 = v57;
  if (v45 == (_DWORD)v54)
  {
    v61 = v45;
  }
  else
  {
    v43 = v58;
    v61 = v59;
  }
  v234 = (cv *)v61;
  if (v43 == 1)
    v62 = 1;
  else
    v62 = v60;
  if (v62)
    v63 = v54;
  else
    v63 = v45;
  v64 = v49 * v63;
  v230 = (unsigned __int8 *)((int)v236 * (uint64_t)(v235 * (int)v54));
  v65 = (uint64_t)(v230 + 32);
  if (!v60)
    v65 = 32;
  v66 = v65 + v64;
  if (v43 - 1 <= 1)
    v67 = 5 * (int)v54 * (uint64_t)(int)v236 + 8 * v235 + v233 * (int)v54 + v66 + 32;
  else
    v67 = v66;
  if (v306 >= v67)
  {
    v68 = v305;
  }
  else
  {
    v68 = &v307;
    if (v305 != &v307)
    {
      if (v305)
        MEMORY[0x2207351A4](v305, 0x1000C8077774924);
      v305 = &v307;
    }
    v306 = v67;
    if (v67 >= 0x1009)
    {
      v68 = (float **)operator new[]();
      v305 = v68;
    }
  }
  v69 = (cv *)(((unint64_t)v68 + 15) & 0xFFFFFFFFFFFFFFF0);
  v255 = __PAIR64__(v54, v234);
  v256 = v69;
  v257 = 0;
  if ((_DWORD)v234 == 1)
    v70 = v232;
  else
    v70 = v49;
  if (v70 == v232 || v49 == 0)
    v72 = 0x4000;
  else
    v72 = 0;
  v73 = v56 | v72 | 0x42FF0000;
  v262 = &v255;
  v263 = (cv *)&v264;
  if (!v49)
    v70 = v232;
  v254 = (void *)(v73 | 0x200000000);
  v264 = (double *)v70;
  v265 = v236;
  v261 = 0;
  v260 = (char *)v69 + v70 * (int)v234;
  v258 = v69;
  v259 = (uint64_t)&v260[v232 - v70];
  if (v60)
  {
    cv::_InputArray::_InputArray((uint64_t)v249, (const cv::Mat *)&v294);
    v74 = (cv *)cv::_OutputArray::_OutputArray((uint64_t)v242, (cv::Mat *)&v254);
    v75 = cv::noArray(v74);
    cv::mulTransposed((cv *)v249, (const cv::_InputArray *)v242, (const cv::_OutputArray *)1, (void (***)(uint64_t *__return_ptr, _QWORD, uint64_t))v75, (const cv::_InputArray *)0xFFFFFFFFLL, 1.0);
    v76 = (unsigned __int8 *)v69 + v64;
    if (v43 == 3 || !v43)
    {
      cv::_InputArray::_InputArray((uint64_t)v242, (const cv::Mat *)&v294);
      cv::_InputArray::_InputArray((uint64_t)v237, (const cv::Mat *)&v275);
      v250 = &v249[8];
      v251 = (cv *)&v252;
      v253 = 0;
      v252 = 0;
      *(_DWORD *)v249 = 1124007936;
      memset(&v249[4], 0, 60);
      cv::_InputArray::_InputArray((uint64_t)v248, (const cv::Mat *)v249);
      cv::_OutputArray::_OutputArray((uint64_t)v247, (cv::Mat *)__p);
      cv::gemm((cv *)v242, (const cv::_InputArray *)v237, (const cv::_InputArray *)v248, 1.0, (const cv::_InputArray *)v247, 0.0, (const cv::_OutputArray *)1);
      v78 = *(unsigned int **)&v249[24];
      if (*(_QWORD *)&v249[24])
      {
        do
        {
          v79 = __ldaxr(v78);
          v80 = v79 - 1;
        }
        while (__stlxr(v80, v78));
        if (!v80)
          cv::Mat::deallocate((cv::Mat *)v249, v77);
      }
      *(_QWORD *)&v249[16] = 0;
      memset(&v249[32], 0, 24);
      if (*(int *)&v249[4] >= 1)
      {
        v81 = 0;
        v82 = v250;
        do
          *(_DWORD *)&v82[4 * v81++] = 0;
        while (v81 < *(int *)&v249[4]);
      }
      *(_QWORD *)&v249[24] = 0;
      if (v251 != (cv *)&v252)
        cv::fastFree((void **)v251, v77);
      goto LABEL_155;
    }
    *(_DWORD *)&v249[8] = v54;
    *(_DWORD *)&v249[12] = v235;
    *(_QWORD *)&v249[16] = (char *)v69 + v64;
    *(_QWORD *)&v249[24] = 0;
    v250 = &v249[8];
    v251 = (cv *)&v252;
    *(_DWORD *)&v249[4] = 2;
    *(_DWORD *)v249 = v56 | 0x42FF4000;
    v252 = (double *)(v235 * (uint64_t)(int)v236);
    v253 = v236;
    *(_OWORD *)&v249[48] = (unint64_t)&v76[(_QWORD)v252 * (int)v54];
    *(_QWORD *)&v249[32] = (char *)v69 + v64;
    *(_QWORD *)&v249[40] = &v76[(_QWORD)v252 * (int)v54];
    cv::_InputArray::_InputArray((uint64_t)v237, (const cv::Mat *)&v294);
    cv::_InputArray::_InputArray((uint64_t)v248, (const cv::Mat *)&v275);
    v243 = (char *)v242 + 8;
    v244 = (cv *)&v245;
    v245 = 0;
    v246 = 0;
    LODWORD(v242[0]) = 1124007936;
    memset((char *)v242 + 4, 0, 48);
    v242[3] = 0u;
    cv::_InputArray::_InputArray((uint64_t)v247, (const cv::Mat *)v242);
    cv::_OutputArray::_OutputArray((uint64_t)v241, (cv::Mat *)v249);
    cv::gemm((cv *)v237, (const cv::_InputArray *)v248, (const cv::_InputArray *)v247, 1.0, (const cv::_InputArray *)v241, 0.0, (const cv::_OutputArray *)1);
    v91 = (unsigned int *)*((_QWORD *)&v242[1] + 1);
    if (*((_QWORD *)&v242[1] + 1))
    {
      do
      {
        v92 = __ldaxr(v91);
        v93 = v92 - 1;
      }
      while (__stlxr(v93, v91));
      if (!v93)
        cv::Mat::deallocate((cv::Mat *)v242, v90);
    }
    *(_QWORD *)&v242[1] = 0;
    memset(&v242[2], 0, 24);
    if (SDWORD1(v242[0]) >= 1)
    {
      v94 = 0;
      v95 = v243;
      do
        *(_DWORD *)&v95[4 * v94++] = 0;
      while (v94 < SDWORD1(v242[0]));
    }
    *((_QWORD *)&v242[1] + 1) = 0;
    if (v244 != (cv *)&v245)
      cv::fastFree((void **)v244, v90);
    v96 = *(unsigned int **)&v249[24];
    if (*(_QWORD *)&v249[24])
    {
      do
        v97 = __ldaxr(v96);
      while (__stlxr(v97 + 1, v96));
    }
    v98 = (unsigned int *)v278;
    if ((_QWORD)v278)
    {
      do
      {
        v99 = __ldaxr(v98);
        v100 = v99 - 1;
      }
      while (__stlxr(v100, v98));
      if (!v100)
        cv::Mat::deallocate((cv::Mat *)&v275, v90);
    }
    v277 = 0;
    v279 = 0uLL;
    *((_QWORD *)&v278 + 1) = 0;
    if (v276[0] <= 0)
    {
      *(_QWORD *)&v278 = 0;
      v275 = *(_DWORD *)v249;
    }
    else
    {
      v101 = 0;
      v102 = v281;
      do
        v102[v101++] = 0;
      while (v101 < v276[0]);
      *(_QWORD *)&v278 = 0;
      v275 = *(_DWORD *)v249;
      if (v276[0] > 2)
        goto LABEL_144;
    }
    if (*(int *)&v249[4] <= 2)
    {
      v276[0] = *(_DWORD *)&v249[4];
      *(_QWORD *)&v276[1] = *(_QWORD *)&v249[8];
      v113 = v251;
      v114 = v282;
      *(_QWORD *)v282 = *(_QWORD *)v251;
      *((_QWORD *)v114 + 1) = *((_QWORD *)v113 + 1);
      goto LABEL_145;
    }
LABEL_144:
    cv::Mat::copySize((cv::Mat *)&v275, (const cv::Mat *)v249);
LABEL_145:
    v279 = *(_OWORD *)&v249[40];
    v115 = *(unsigned int **)&v249[24];
    v278 = *(_OWORD *)&v249[24];
    v277 = *(float **)&v249[16];
    v280 = *(_QWORD *)&v249[56];
    if (*(_QWORD *)&v249[24])
    {
      do
      {
        v116 = __ldaxr(v115);
        v117 = v116 - 1;
      }
      while (__stlxr(v117, v115));
      if (!v117)
        cv::Mat::deallocate((cv::Mat *)v249, v90);
    }
    *(_QWORD *)&v249[16] = 0;
    memset(&v249[32], 0, 24);
    if (*(int *)&v249[4] >= 1)
    {
      v118 = 0;
      v119 = v250;
      do
        *(_DWORD *)&v119[4 * v118++] = 0;
      while (v118 < *(int *)&v249[4]);
    }
    *(_QWORD *)&v249[24] = 0;
    if (v251 != (cv *)&v252)
      cv::fastFree((void **)v251, v90);
    v76 = &v230[(_QWORD)v76];
    goto LABEL_155;
  }
  if (v43 == 1)
  {
    v83 = (int)v234 * (uint64_t)(int)v236;
    if ((_DWORD)v54 == 1)
      v84 = (int)v234 * (uint64_t)(int)v236;
    else
      v84 = v49;
    v85 = v84 == v83 || v49 == 0;
    *(_DWORD *)&v249[12] = (_DWORD)v234;
    *(_QWORD *)&v249[16] = v69;
    *(_QWORD *)&v249[24] = 0;
    v250 = &v249[8];
    v251 = (cv *)&v252;
    if (v85)
      v86 = 0x4000;
    else
      v86 = 0;
    if (v49)
      v83 = v84;
    v87 = v56 | 0x42FF0000 | v86;
    *(_DWORD *)&v249[8] = v54;
    *(_DWORD *)v249 = v87;
    v252 = (double *)v83;
    v253 = v236;
    v88 = (char *)v69 + v83 * (int)v54;
    *(_OWORD *)&v249[48] = (unint64_t)v88;
    *(_QWORD *)&v249[32] = v69;
    *(_QWORD *)&v249[40] = &v88[(int)v234 * (uint64_t)(int)v236 - v83];
    v254 = (void *)(v87 | 0x200000000);
    v255 = __PAIR64__(v234, v54);
    v264 = (double *)v83;
    v265 = v236;
    v258 = v69;
    v259 = *(_QWORD *)&v249[40];
    v256 = v69;
    v257 = 0;
    v260 = v88;
    v261 = 0;
    cv::_InputArray::_InputArray((uint64_t)v249, (const cv::Mat *)&v294);
    cv::_OutputArray::_OutputArray((uint64_t)v242, (cv::Mat *)&v254);
    cv::transpose((cv *)v249, (const cv::_InputArray *)v242, v89);
  }
  else
  {
    cv::_OutputArray::_OutputArray((uint64_t)v249, (cv::Mat *)&v254);
    cv::Mat::copyTo((cv::Mat *)&v294, (const cv::_OutputArray *)v249);
  }
  v76 = (unsigned __int8 *)v69 + v64;
  if (v43 == 3 || !v43)
  {
    cv::_OutputArray::_OutputArray((uint64_t)v249, (cv::Mat *)__p);
    cv::Mat::copyTo((cv::Mat *)&v275, (const cv::_OutputArray *)v249);
  }
LABEL_155:
  if (v43 == 3)
  {
    if (v56 == 5)
    {
      if (cv::Cholesky(v256, (unint64_t)v264, v54, v267, (unint64_t)v274, v235))
        goto LABEL_248;
    }
    else if (cv::Cholesky(v256, (unint64_t)v264, v54, (double *)v267, (unint64_t)v274, v235))
    {
      goto LABEL_248;
    }
LABEL_181:
    memset(v249, 0, 32);
    cv::Mat::operator=((uint64_t)__p, (int64x2_t *)v249);
    v128 = 0;
    goto LABEL_249;
  }
  if (v43)
  {
    v120 = (char *)((unint64_t)(v76 + 15) & 0xFFFFFFFFFFFFFFF0);
    *(_DWORD *)&v249[8] = v54;
    *(_DWORD *)&v249[12] = v54;
    *(_QWORD *)&v249[16] = v120;
    *(_QWORD *)&v249[24] = 0;
    v250 = &v249[8];
    v251 = (cv *)&v252;
    if ((_DWORD)v54 == 1)
      v121 = v236;
    else
      v121 = (v232 + 15) & 0xFFFFFFFFFFFFFFF0;
    if (v121 == v232 || v233 == 0)
      v123 = 0x4000;
    else
      v123 = 0;
    *(_DWORD *)&v249[4] = 2;
    *(_DWORD *)v249 = v56 | v123 | 0x42FF0000;
    if (v233)
      v124 = v121;
    else
      v124 = v232;
    v252 = (double *)v124;
    v253 = v236;
    *(_OWORD *)&v249[48] = (unint64_t)&v120[v124 * (int)v54];
    *(_QWORD *)&v249[32] = (unint64_t)(v76 + 15) & 0xFFFFFFFFFFFFFFF0;
    *(_QWORD *)&v249[40] = *(_QWORD *)&v249[48] - v124 + v232;
    v125 = (uint64_t)&v120[v233 * (int)v54];
    *((_QWORD *)&v242[0] + 1) = v54 | 0x100000000;
    v242[1] = (unint64_t)v125;
    v243 = (char *)v242 + 8;
    v244 = (cv *)&v245;
    DWORD1(v242[0]) = 2;
    LODWORD(v242[0]) = v56 | 0x42FF4000;
    v245 = v236;
    v246 = v236;
    v242[3] = (unint64_t)(v125 + v232);
    *(_QWORD *)&v242[2] = v125;
    *((_QWORD *)&v242[2] + 1) = v125 + v232;
    v238 = &v237[8];
    v239 = (cv *)v240;
    v240[0] = 0;
    v240[1] = 0;
    *(_DWORD *)v237 = 1124007936;
    memset(&v237[4], 0, 60);
    v126 = (float *)&v120[(v233 + v236) * (int)v54];
    if (v43 == 2)
    {
      if (v56 == 5)
        cv::JacobiImpl_<float>((uint64_t)v256, (unint64_t)v264, v125, v120, v124, v54, (uint64_t)&v120[(v233 + v236) * (int)v54]);
      else
        cv::JacobiImpl_<double>((uint64_t)v256, (unint64_t)v264, v125, v120, v124, v54, (uint64_t)&v120[(v233 + v236) * (int)v54]);
      v130 = *(unsigned int **)&v249[24];
      if (*(_QWORD *)&v249[24])
      {
        do
          v131 = __ldaxr(v130);
        while (__stlxr(v131 + 1, v130));
      }
      v132 = *(unsigned int **)&v237[24];
      if (*(_QWORD *)&v237[24])
      {
        do
        {
          v133 = __ldaxr(v132);
          v134 = v133 - 1;
        }
        while (__stlxr(v134, v132));
        if (!v134)
          cv::Mat::deallocate((cv::Mat *)v237, v127);
      }
      *(_QWORD *)&v237[16] = 0;
      memset(&v237[32], 0, 24);
      if (*(uint64_t *)v237 <= 0)
      {
        *(_QWORD *)&v237[24] = 0;
        *(_DWORD *)v237 = *(_DWORD *)v249;
      }
      else
      {
        v135 = 0;
        v136 = v238;
        do
          *(_DWORD *)&v136[4 * v135++] = 0;
        while (v135 < *(int *)&v237[4]);
        *(_QWORD *)&v237[24] = 0;
        *(_DWORD *)v237 = *(_DWORD *)v249;
        if (*(int *)&v237[4] > 2)
          goto LABEL_211;
      }
      if (*(int *)&v249[4] <= 2)
      {
        *(_DWORD *)&v237[4] = *(_DWORD *)&v249[4];
        *(_QWORD *)&v237[8] = *(_QWORD *)&v249[8];
        v144 = v251;
        v145 = v239;
        *(_QWORD *)v239 = *(_QWORD *)v251;
        *((_QWORD *)v145 + 1) = *((_QWORD *)v144 + 1);
LABEL_212:
        v146 = (unsigned int **)&v249[24];
        v147 = (uint64_t *)&v249[40];
        v148 = (char **)&v249[48];
        v149 = (uint64_t *)&v249[56];
        v150 = *(float **)&v249[16];
        *(_QWORD *)&v237[16] = *(_QWORD *)&v249[16];
        v151 = (cv **)&v249[32];
LABEL_218:
        v154 = *v151;
        v155 = *v148;
        *(_QWORD *)&v237[40] = *v147;
        *(_QWORD *)&v237[48] = v155;
        *(_QWORD *)&v237[24] = *v146;
        *(_QWORD *)&v237[32] = v154;
        *(_QWORD *)&v237[56] = *v149;
        LODWORD(v228) = v235;
        if (v56 == 5)
          cv::SVBkSb(v234, v54, *(float **)&v242[1], 0, v150, (uint64_t)v240[0], 1, *(uint64_t *)&v249[16], (const float *)v252, (unint64_t)v277, v283[0], (const float *)v228, v267, (unint64_t)v274, v126, (unint64_t)&v252, (unsigned __int8 *)&v245);
        else
          cv::SVBkSb(v234, v54, *(double **)&v242[1], 0, (double *)v150, (uint64_t)v240[0], 1, *(uint64_t *)&v249[16], v252, (unint64_t)v277, v283[0], v228, (double *)v267, (unint64_t)v274, (double *)v126, (unint64_t)&v252, (unsigned __int8 *)&v245);
        v156 = *(unsigned int **)&v237[24];
        if (*(_QWORD *)&v237[24])
        {
          do
          {
            v157 = __ldaxr(v156);
            v158 = v157 - 1;
          }
          while (__stlxr(v158, v156));
          if (!v158)
            cv::Mat::deallocate((cv::Mat *)v237, v15);
        }
        *(_QWORD *)&v237[16] = 0;
        memset(&v237[32], 0, 24);
        if (*(int *)&v237[4] >= 1)
        {
          v159 = 0;
          v160 = v238;
          do
            *(_DWORD *)&v160[4 * v159++] = 0;
          while (v159 < *(int *)&v237[4]);
        }
        *(_QWORD *)&v237[24] = 0;
        if (v239 != (cv *)v240)
          cv::fastFree((void **)v239, v15);
        v161 = (unsigned int *)*((_QWORD *)&v242[1] + 1);
        if (*((_QWORD *)&v242[1] + 1))
        {
          do
          {
            v162 = __ldaxr(v161);
            v163 = v162 - 1;
          }
          while (__stlxr(v163, v161));
          if (!v163)
            cv::Mat::deallocate((cv::Mat *)v242, v15);
        }
        *(_QWORD *)&v242[1] = 0;
        memset(&v242[2], 0, 24);
        if (SDWORD1(v242[0]) >= 1)
        {
          v164 = 0;
          v165 = v243;
          do
            *(_DWORD *)&v165[4 * v164++] = 0;
          while (v164 < SDWORD1(v242[0]));
        }
        *((_QWORD *)&v242[1] + 1) = 0;
        if (v244 != (cv *)v231)
          cv::fastFree((void **)v244, v15);
        v166 = *(unsigned int **)&v249[24];
        if (*(_QWORD *)&v249[24])
        {
          do
          {
            v167 = __ldaxr(v166);
            v168 = v167 - 1;
          }
          while (__stlxr(v168, v166));
          if (!v168)
            cv::Mat::deallocate((cv::Mat *)v249, v15);
        }
        *(_QWORD *)&v249[16] = 0;
        memset(&v249[32], 0, 24);
        if (*(int *)&v249[4] >= 1)
        {
          v169 = 0;
          v170 = v250;
          do
            *(_DWORD *)&v170[4 * v169++] = 0;
          while (v169 < *(int *)&v249[4]);
        }
        *(_QWORD *)&v249[24] = 0;
        if (v251 != v229)
          cv::fastFree((void **)v251, v15);
        goto LABEL_248;
      }
LABEL_211:
      cv::Mat::copySize((cv::Mat *)v237, (const cv::Mat *)v249);
      goto LABEL_212;
    }
    if (v56 == 5)
      cv::JacobiSVDImpl_<float>((uint64_t)v256, (uint64_t)v264);
    else
      cv::JacobiSVDImpl_<double>((uint64_t)v256, (uint64_t)v264);
    v137 = v257;
    if (v257)
    {
      do
        v138 = __ldaxr(v137);
      while (__stlxr(v138 + 1, v137));
    }
    v139 = *(unsigned int **)&v237[24];
    if (*(_QWORD *)&v237[24])
    {
      do
      {
        v140 = __ldaxr(v139);
        v141 = v140 - 1;
      }
      while (__stlxr(v141, v139));
      if (!v141)
        cv::Mat::deallocate((cv::Mat *)v237, v129);
    }
    *(_QWORD *)&v237[16] = 0;
    memset(&v237[32], 0, 24);
    if (*(uint64_t *)v237 <= 0)
    {
      *(_QWORD *)&v237[24] = 0;
      *(_DWORD *)v237 = (_DWORD)v254;
    }
    else
    {
      v142 = 0;
      v143 = v238;
      do
        *(_DWORD *)&v143[4 * v142++] = 0;
      while (v142 < *(int *)&v237[4]);
      *(_QWORD *)&v237[24] = 0;
      *(_DWORD *)v237 = (_DWORD)v254;
      if (*(int *)&v237[4] > 2)
        goto LABEL_216;
    }
    if (SHIDWORD(v254) <= 2)
    {
      *(_DWORD *)&v237[4] = HIDWORD(v254);
      *(_QWORD *)&v237[8] = v255;
      v152 = v263;
      v153 = v239;
      *(_QWORD *)v239 = *(_QWORD *)v263;
      *((_QWORD *)v153 + 1) = *((_QWORD *)v152 + 1);
LABEL_217:
      v146 = &v257;
      v147 = &v259;
      v148 = &v260;
      v149 = &v261;
      v150 = (float *)v256;
      *(_QWORD *)&v237[16] = v256;
      v151 = &v258;
      goto LABEL_218;
    }
LABEL_216:
    cv::Mat::copySize((cv::Mat *)v237, (const cv::Mat *)&v254);
    goto LABEL_217;
  }
  if (v56 == 5)
  {
    if (!cv::LU(v256, (unint64_t)v264, v54, (int *)v267, (unint64_t)v274, v235))
      goto LABEL_181;
  }
  else if (!cv::LU(v256, (unint64_t)v264, v54, (uint64_t *)v267, (unint64_t)v274, v235))
  {
    goto LABEL_181;
  }
LABEL_248:
  v128 = 1;
LABEL_249:
  v171 = v257;
  if (v257)
  {
    do
    {
      v172 = __ldaxr(v171);
      v173 = v172 - 1;
    }
    while (__stlxr(v173, v171));
    if (!v173)
      cv::Mat::deallocate((cv::Mat *)&v254, v15);
  }
  v256 = 0;
  v259 = 0;
  v260 = 0;
  v258 = 0;
  if (SHIDWORD(v254) >= 1)
  {
    v174 = 0;
    v175 = v262;
    do
      *((_DWORD *)v175 + v174++) = 0;
    while (v174 < SHIDWORD(v254));
  }
  v257 = 0;
  if (v263 != (cv *)&v264)
    cv::fastFree((void **)v263, v15);
  v176 = v268;
  if (v268)
  {
    do
    {
      v177 = __ldaxr(v176);
      v178 = v177 - 1;
    }
    while (__stlxr(v178, v176));
    if (!v178)
      cv::Mat::deallocate((cv::Mat *)__p, v15);
  }
  v267 = 0;
  v269 = 0;
  v271 = 0;
  v270 = 0;
  if (SHIDWORD(__p[0]) >= 1)
  {
    v179 = 0;
    v180 = v272;
    do
      *(_DWORD *)(v180 + 4 * v179++) = 0;
    while (v179 < SHIDWORD(__p[0]));
  }
  v268 = 0;
  if (v273 != (cv *)&v274)
    cv::fastFree((void **)v273, v15);
  v181 = (unsigned int *)v278;
  if ((_QWORD)v278)
  {
    do
    {
      v182 = __ldaxr(v181);
      v183 = v182 - 1;
    }
    while (__stlxr(v183, v181));
    if (!v183)
      cv::Mat::deallocate((cv::Mat *)&v275, v15);
  }
  v277 = 0;
  v279 = 0uLL;
  *((_QWORD *)&v278 + 1) = 0;
  if (v276[0] >= 1)
  {
    v184 = 0;
    v185 = v281;
    do
      v185[v184++] = 0;
    while (v184 < v276[0]);
  }
  *(_QWORD *)&v278 = 0;
  if (v282 != (cv *)v283)
    cv::fastFree((void **)v282, v15);
  if (v305 != &v307 && v305 != 0)
    MEMORY[0x2207351A4]();
LABEL_281:
  v187 = (unsigned int *)v288;
  if ((_QWORD)v288)
  {
    do
    {
      v188 = __ldaxr(v187);
      v189 = v188 - 1;
    }
    while (__stlxr(v189, v187));
    if (!v189)
      cv::Mat::deallocate((cv::Mat *)&v284, v15);
  }
  v287 = 0;
  *((_QWORD *)&v288 + 1) = 0;
  v289 = 0uLL;
  if ((int)v285 >= 1)
  {
    v190 = 0;
    v191 = v291;
    do
      *(_DWORD *)(v191 + 4 * v190++) = 0;
    while (v190 < (int)v285);
  }
  *(_QWORD *)&v288 = 0;
  if (v292 != (cv *)&v293)
    cv::fastFree((void **)v292, v15);
  v192 = v298;
  if (v298)
  {
    do
    {
      v193 = __ldaxr(v192);
      v194 = v193 - 1;
    }
    while (__stlxr(v194, v192));
    if (!v194)
      cv::Mat::deallocate((cv::Mat *)&v294, v15);
  }
  v297 = 0;
  v299 = 0;
  v301 = 0;
  v300 = 0;
  if (SHIDWORD(v294) >= 1)
  {
    v195 = 0;
    v196 = v302;
    do
      *(_DWORD *)(v196 + 4 * v195++) = 0;
    while (v195 < SHIDWORD(v294));
  }
  v298 = 0;
  if (v303 != (cv *)&v304)
    cv::fastFree((void **)v303, v15);
  return v128;
}

void sub_219E64FB8(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

void cv::SVBkSb(cv *this, int a2, float *a3, uint64_t a4, float *a5, uint64_t a6, int a7, uint64_t a8, const float *a9, unint64_t a10, uint64_t a11, const float *a12, float *a13, unint64_t a14, float *a15, unint64_t a16, unsigned __int8 *a17)
{
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  float *v26;
  unsigned int v27;
  float64x2_t *v28;
  uint64_t v29;
  uint64_t v30;
  double v31;
  float *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  double v37;
  uint64_t v38;
  BOOL v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  float64x2_t *v44;
  uint64_t v45;
  uint64_t v46;
  unsigned int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  double v51;
  double v52;
  double v53;
  float *v54;
  float *v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  float32x2_t *v59;
  float v60;
  uint64_t v61;
  float64x2_t *v62;
  float32x2_t *v63;
  float32x2_t v64;
  double *v65;
  uint64_t v66;
  uint64_t v67;
  double v68;
  float *v69;
  float v70;
  float *v71;
  double *v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  float v76;
  uint64_t v77;
  float64x2_t v78;
  float32x2_t *v79;
  float64x2_t *v80;
  float64x2_t v81;
  float64x2_t v82;
  double v83;
  float v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v89;
  unsigned int v90;
  uint64_t v92;
  unint64_t v93;
  unint64_t v94;
  uint64_t v96;

  v21 = a10;
  v93 = a14 >> 2;
  if (a2 >= (int)this)
    v22 = this;
  else
    v22 = a2;
  v96 = v22;
  v90 = this;
  if (a10)
    v23 = a12;
  else
    v23 = this;
  if (a2 >= 1)
  {
    v24 = 0;
    v25 = a2;
    do
    {
      if ((int)v23 >= 1)
      {
        bzero((char *)a13 + (v24 >> 30), 4 * v23);
        v21 = a10;
      }
      v24 += v93 << 32;
      --v25;
    }
    while (v25);
  }
  v26 = a3;
  if ((int)v96 >= 1)
  {
    v27 = a2;
    v28 = (float64x2_t *)(((unint64_t)a15 + 7) & 0xFFFFFFFFFFFFFFF8);
    v29 = (int)(a6 >> 2);
    if (a4)
      v30 = (int)(a4 >> 2);
    else
      v30 = 1;
    v31 = 0.0;
    v32 = a3;
    v33 = v96;
    do
    {
      v31 = v31 + *v32;
      v32 += v30;
      --v33;
    }
    while (v33);
    v34 = 0;
    v35 = (int)v23 - 4;
    v36 = v90;
    v37 = v31 * 4.4408921e-16;
    v38 = (int)v93;
    v39 = a7 == 0;
    v40 = (int)((uint64_t)a9 >> 2);
    if (a7)
      v41 = 1;
    else
      v41 = (int)(a6 >> 2);
    v89 = v41;
    if (v39)
      v29 = 1;
    v42 = 4 * (int)(a11 >> 2);
    v92 = v30;
    v94 = v21 + 8;
    v43 = 4 * v29;
    v44 = v28 + 1;
    v45 = 4 * v41;
    v46 = 4 * v38;
    v47 = v27;
    v48 = 4 * v27;
    v49 = 4 * v40;
    v50 = v47;
    v87 = v43;
    v85 = 4 * v40;
    v86 = 4 * v41;
    do
    {
      v51 = v26[v34 * v30];
      if (fabs(v51) > v37)
      {
        v52 = 1.0 / v51;
        if ((_DWORD)v23 == 1)
        {
          if (v21)
          {
            v53 = 0.0;
            v54 = a5;
            v55 = (float *)v21;
            v56 = v36;
            do
            {
              v53 = v53 + (float)(*v54 * *v55);
              v55 = (float *)((char *)v55 + v42);
              v54 = (float *)((char *)v54 + v45);
              --v56;
            }
            while (v56);
          }
          else
          {
            v53 = *a5;
          }
          v67 = 0;
          v68 = v52 * v53;
          v69 = a13;
          do
          {
            v70 = *v69 + v68 * *(float *)(a8 + v67);
            *v69 = v70;
            v67 += 4;
            v69 = (float *)((char *)v69 + v46);
          }
          while (v48 != v67);
        }
        else
        {
          if (v21)
          {
            if ((int)v23 > 0)
            {
              bzero(v28, 8 * v23);
              v49 = v85;
              v45 = v86;
              v44 = v28 + 1;
              v43 = v87;
              v41 = v89;
              v36 = v90;
              v30 = v92;
              v21 = a10;
              v26 = a3;
            }
            v57 = 0;
            v58 = v21;
            v59 = (float32x2_t *)v94;
            do
            {
              v60 = a5[v57 * v41];
              if ((int)v23 >= 4)
              {
                v61 = 0;
                v62 = v44;
                v63 = v59;
                do
                {
                  v62[-1] = vaddq_f64(v62[-1], vcvtq_f64_f32(vmul_n_f32(v63[-1], v60)));
                  v64 = *v63;
                  v63 += 2;
                  *v62 = vaddq_f64(*v62, vcvtq_f64_f32(vmul_n_f32(v64, v60)));
                  v62 += 2;
                  v61 += 4;
                }
                while (v61 <= v35);
                v61 = v61;
              }
              else
              {
                v61 = 0;
              }
              if ((int)v61 < (int)v23)
              {
                do
                {
                  v28->f64[v61] = v28->f64[v61] + (float)(v60 * *(float *)(v58 + 4 * v61));
                  ++v61;
                }
                while (v23 != v61);
              }
              ++v57;
              v59 = (float32x2_t *)((char *)v59 + v42);
              v58 += v42;
            }
            while (v57 != v36);
            if ((int)v23 >= 1)
            {
              v65 = (double *)(((unint64_t)a15 + 7) & 0xFFFFFFFFFFFFFFF8);
              v66 = v23;
              do
              {
                *v65 = v52 * *v65;
                ++v65;
                --v66;
              }
              while (v66);
            }
          }
          else if ((int)v23 >= 1)
          {
            v71 = a5;
            v72 = (double *)(((unint64_t)a15 + 7) & 0xFFFFFFFFFFFFFFF8);
            v73 = v23;
            do
            {
              *v72++ = v52 * *v71;
              v71 = (float *)((char *)v71 + v45);
              --v73;
            }
            while (v73);
          }
          v74 = 0;
          v75 = (unint64_t)a13;
          do
          {
            v76 = *(float *)(a8 + 4 * v74);
            if ((int)v23 >= 4)
            {
              v77 = 0;
              v78 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(v76), 0);
              v79 = (float32x2_t *)v75;
              v80 = (float64x2_t *)(((unint64_t)a15 + 7) & 0xFFFFFFFFFFFFFFF8);
              do
              {
                v81 = *v80;
                v82 = v80[1];
                v80 += 2;
                *(float32x4_t *)v79->f32 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmlaq_f64(vcvtq_f64_f32(*v79), v81, v78)), vmlaq_f64(vcvt_hight_f64_f32(*(float32x4_t *)v79->f32), v82, v78));
                v79 += 2;
                v77 += 4;
              }
              while (v77 <= v35);
              v77 = v77;
            }
            else
            {
              v77 = 0;
            }
            if ((int)v77 < (int)v23)
            {
              v83 = v76;
              do
              {
                v84 = *(float *)(v75 + 4 * v77) + v83 * v28->f64[v77];
                *(float *)(v75 + 4 * v77++) = v84;
              }
              while (v23 != v77);
            }
            ++v74;
            v75 += v46;
          }
          while (v74 != v50);
        }
      }
      ++v34;
      a5 = (float *)((char *)a5 + v43);
      a8 += v49;
    }
    while (v34 != v96);
  }
}

void cv::SVBkSb(cv *this, uint64_t a2, double *a3, uint64_t a4, double *a5, uint64_t a6, int a7, uint64_t a8, const double *a9, unint64_t a10, unint64_t a11, const double *a12, double *a13, unint64_t a14, double *a15, unint64_t a16, unsigned __int8 *a17)
{
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  double *v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  double v32;
  double *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  double v37;
  uint64_t v38;
  uint64_t v39;
  double v40;
  double v41;
  double v42;
  double *v43;
  double *v44;
  uint64_t v45;
  double *v46;
  uint64_t v47;
  uint64_t v48;
  double v49;
  double *v50;
  double *v51;
  double *v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  int v56;
  unsigned int v57;
  uint64_t v59;
  uint64_t v60;
  unint64_t v62;
  void *v64;

  v62 = a14 >> 3;
  if (a7)
    v21 = 1;
  else
    v21 = (unint64_t)a6 >> 3;
  v56 = v21;
  if ((int)a2 >= (int)this)
    v22 = this;
  else
    v22 = a2;
  v60 = v22;
  v57 = this;
  if (a10)
    v23 = a12;
  else
    v23 = this;
  if ((int)a2 >= 1)
  {
    v24 = 0;
    v25 = a2;
    do
    {
      if ((int)v23 >= 1)
        bzero((char *)a13 + (v24 >> 29), 8 * v23);
      v24 += v62 << 32;
      --v25;
    }
    while (v25);
  }
  v26 = v60;
  v27 = a10;
  v28 = a3;
  if ((int)v60 >= 1)
  {
    v29 = a7;
    v55 = a11 >> 3;
    v64 = (void *)(((unint64_t)a15 + 7) & 0xFFFFFFFFFFFFFFF8);
    v30 = (int)(a6 >> 3);
    if (a4)
      v31 = (int)(a4 >> 3);
    else
      v31 = 1;
    v32 = 0.0;
    v33 = a3;
    v34 = v60;
    do
    {
      v32 = v32 + *v33;
      v33 += v31;
      --v34;
    }
    while (v34);
    v35 = 0;
    if (!v29)
      v30 = 1;
    v36 = 8 * v30;
    v37 = v32 * 4.4408921e-16;
    v38 = 8 * v56;
    v39 = 8 * (int)((uint64_t)a9 >> 3);
    v54 = v31;
    v59 = 8 * v30;
    do
    {
      v40 = v28[v35 * v31];
      if (fabs(v40) > v37)
      {
        v41 = 1.0 / v40;
        if ((_DWORD)v23 == 1)
        {
          if (v27)
          {
            v42 = 0.0;
            v43 = a5;
            v44 = (double *)v27;
            v45 = v57;
            do
            {
              v42 = v42 + *v43 * *v44;
              v44 += (int)v55;
              v43 = (double *)((char *)v43 + v38);
              --v45;
            }
            while (v45);
          }
          else
          {
            v42 = *a5;
          }
          v48 = 0;
          v49 = v41 * v42;
          v50 = a13;
          do
          {
            *v50 = *v50 + v49 * *(double *)(a8 + v48);
            v48 += 8;
            v50 += (int)v62;
          }
          while (8 * a2 != v48);
        }
        else
        {
          if (v27)
          {
            if ((int)v23 <= 0)
            {
              cv::MatrAXPY<double,double,double>(v57, (int)a12, v27, v55, (uint64_t)a5, v56, (uint64_t)v64, 0);
            }
            else
            {
              bzero(v64, 8 * v23);
              cv::MatrAXPY<double,double,double>(v57, (int)a12, v27, v55, (uint64_t)a5, v56, (uint64_t)v64, 0);
              v46 = (double *)(((unint64_t)a15 + 7) & 0xFFFFFFFFFFFFFFF8);
              v31 = v54;
              v47 = v23;
              do
              {
                *v46 = v41 * *v46;
                ++v46;
                --v47;
              }
              while (v47);
            }
          }
          else if ((int)v23 >= 1)
          {
            v51 = a5;
            v52 = (double *)(((unint64_t)a15 + 7) & 0xFFFFFFFFFFFFFFF8);
            v53 = v23;
            do
            {
              *v52++ = v41 * *v51;
              v51 = (double *)((char *)v51 + v38);
              --v53;
            }
            while (v53);
          }
          cv::MatrAXPY<double,double,double>(a2, v23, (uint64_t)v64, 0, a8, 1, (uint64_t)a13, v62);
          v27 = a10;
          v28 = a3;
          v36 = v59;
          v26 = v60;
          v39 = 8 * (int)((uint64_t)a9 >> 3);
        }
      }
      ++v35;
      a5 = (double *)((char *)a5 + v36);
      a8 += v39;
    }
    while (v35 != v26);
  }
}

uint64_t cv::eigen(cv *this, const cv::_InputArray *a2, BOOL a3, const cv::_OutputArray *a4, const cv::_OutputArray *a5)
{
  void (***v5)(uint64_t *__return_ptr, _QWORD, uint64_t);
  uint64_t v6;
  uint64_t v7;
  cv::_OutputArray *v8;
  cv::_OutputArray *v9;
  int v10;
  int v11;
  unsigned int v12;
  int v13;
  const cv::Exception *v14;
  int v15;
  const cv::Exception *v16;
  void *v17;
  unsigned int *v18;
  unsigned int v19;
  unsigned int *v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  _BYTE *v24;
  cv *v25;
  cv *v26;
  unsigned int *v27;
  unsigned int v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  uint64_t *v36;
  unint64_t v37;
  int v38;
  uint64_t v39;
  unint64_t v40;
  int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int *v47;
  unsigned int v48;
  unsigned int v49;
  uint64_t v50;
  _DWORD *v51;
  unsigned int *v52;
  unsigned int v53;
  unsigned int v54;
  uint64_t v55;
  _DWORD *v56;
  unsigned int *v58;
  unsigned int v59;
  unsigned int v60;
  uint64_t v61;
  _BYTE *v62;
  unsigned int *v63;
  unsigned int v64;
  unsigned int v65;
  uint64_t v66;
  uint64_t v67;
  cv::_OutputArray *v69;
  _BYTE v70[17];
  void *__p;
  _DWORD v72[2];
  uint64_t v73;
  unsigned int *v74;
  unint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  _DWORD *v79;
  cv *v80;
  _QWORD v81[2];
  void *v82;
  _DWORD v83[2];
  unint64_t v84;
  unsigned int *v85;
  unint64_t v86;
  uint64_t v87;
  unint64_t v88;
  uint64_t v89;
  _DWORD *v90;
  cv *v91;
  int v92[2];
  uint64_t v93;
  _BYTE v94[64];
  _BYTE *v95;
  cv *v96;
  unint64_t v97[2];
  uint64_t v98;
  unsigned int v99;
  int v100;
  uint64_t v101;
  unsigned int *v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  cv *v107;
  uint64_t v108;
  uint64_t *v109;
  uint64_t v110;
  uint64_t v111;
  __int128 v112;
  __int128 v113;
  uint64_t v114;
  uint64_t v115;
  cv *v116;
  _QWORD v117[509];

  v5 = (void (***)(uint64_t *__return_ptr, _QWORD, uint64_t))MEMORY[0x24BDAC7A8](this, a2);
  v7 = v6;
  v9 = v8;
  v11 = v10;
  v117[507] = *MEMORY[0x24BDAC8D0];
  (**v5)(&v98, v5, 0xFFFFFFFFLL);
  v12 = v98;
  v13 = v99;
  if (v99 != v100)
  {
    std::string::basic_string[abi:ne180100]<0>(v94, "src.rows == src.cols");
    std::string::basic_string[abi:ne180100]<0>(&v82, "eigen");
    std::string::basic_string[abi:ne180100]<0>(&__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/lapack.cpp");
    cv::Exception::Exception(&v109, 4294967081, v94, &v82, &__p, 1472);
    cv::error((cv *)&v109, v14);
  }
  v15 = v98 & 0xFFF;
  if ((v15 - 5) >= 2)
  {
    std::string::basic_string[abi:ne180100]<0>(v94, "type == CV_32F || type == CV_64F");
    std::string::basic_string[abi:ne180100]<0>(&v82, "eigen");
    std::string::basic_string[abi:ne180100]<0>(&__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/lapack.cpp");
    cv::Exception::Exception(&v109, 4294967081, v94, &v82, &__p, 1473);
    cv::error((cv *)&v109, v16);
  }
  v95 = &v94[8];
  v96 = (cv *)v97;
  v97[0] = 0;
  v97[1] = 0;
  *(_DWORD *)v94 = 1124007936;
  memset(&v94[4], 0, 60);
  if (v11)
  {
    (*(void (**)(uint64_t, _QWORD, _QWORD, uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)v7 + 136))(v7, v99, v99, v98 & 0xFFF, 0xFFFFFFFFLL, 0, 0);
    (**(void (***)(uint64_t **__return_ptr, uint64_t, uint64_t))v7)(&v109, v7, 0xFFFFFFFFLL);
    v18 = (unsigned int *)v112;
    if ((_QWORD)v112)
    {
      do
        v19 = __ldaxr(v18);
      while (__stlxr(v19 + 1, v18));
    }
    v20 = *(unsigned int **)&v94[24];
    if (*(_QWORD *)&v94[24])
    {
      do
      {
        v21 = __ldaxr(v20);
        v22 = v21 - 1;
      }
      while (__stlxr(v22, v20));
      if (!v22)
        cv::Mat::deallocate((cv::Mat *)v94, v17);
    }
    *(_QWORD *)&v94[16] = 0;
    memset(&v94[32], 0, 24);
    if (*(uint64_t *)v94 <= 0)
    {
      *(_QWORD *)&v94[24] = 0;
      *(_DWORD *)v94 = (_DWORD)v109;
    }
    else
    {
      v23 = 0;
      v24 = v95;
      do
        *(_DWORD *)&v24[4 * v23++] = 0;
      while (v23 < *(int *)&v94[4]);
      *(_QWORD *)&v94[24] = 0;
      *(_DWORD *)v94 = (_DWORD)v109;
      if (*(int *)&v94[4] > 2)
        goto LABEL_20;
    }
    if (SHIDWORD(v109) <= 2)
    {
      *(_DWORD *)&v94[4] = HIDWORD(v109);
      *(_QWORD *)&v94[8] = v110;
      v25 = v116;
      v26 = v96;
      *(_QWORD *)v96 = *(_QWORD *)v116;
      *((_QWORD *)v26 + 1) = *((_QWORD *)v25 + 1);
      goto LABEL_21;
    }
LABEL_20:
    cv::Mat::copySize((cv::Mat *)v94, (const cv::Mat *)&v109);
LABEL_21:
    *(_OWORD *)&v94[40] = v113;
    v27 = (unsigned int *)v112;
    *(_OWORD *)&v94[24] = v112;
    *(_QWORD *)&v94[16] = v111;
    *(_QWORD *)&v94[56] = v114;
    if ((_QWORD)v112)
    {
      do
      {
        v28 = __ldaxr(v27);
        v29 = v28 - 1;
      }
      while (__stlxr(v29, v27));
      if (!v29)
        cv::Mat::deallocate((cv::Mat *)&v109, v17);
    }
    v111 = 0;
    v113 = 0uLL;
    *((_QWORD *)&v112 + 1) = 0;
    if (SHIDWORD(v109) >= 1)
    {
      v30 = 0;
      v31 = v115;
      do
        *(_DWORD *)(v31 + 4 * v30++) = 0;
      while (v30 < SHIDWORD(v109));
    }
    *(_QWORD *)&v112 = 0;
    if (v116 != (cv *)v117)
      cv::fastFree((void **)v116, v17);
  }
  v69 = v9;
  if (SHIDWORD(v98) < 1)
    v32 = 0;
  else
    v32 = *((_QWORD *)v107 + (HIDWORD(v98) - 1));
  v33 = v32 * v13;
  v34 = (v33 + 15) & 0xFFFFFFFFFFFFFFF0;
  v35 = v34 * v13;
  v109 = &v111;
  v110 = 4104;
  v36 = &v111;
  if (5 * v33 + v35 + 32 >= 0x1009)
  {
    v110 = 5 * v33 + v35 + 32;
    v36 = (uint64_t *)operator new[]();
    v109 = v36;
  }
  v37 = ((unint64_t)v36 + 15) & 0xFFFFFFFFFFFFFFF0;
  v83[0] = v13;
  v83[1] = v13;
  v84 = v37;
  v85 = 0;
  v90 = v83;
  v91 = (cv *)v92;
  v38 = (((v12 >> 3) & 0x1FF) + 1) << ((0xFA50u >> (2 * (v15 & 7))) & 3);
  v39 = v38 * (uint64_t)v13;
  if (v13 == 1)
    v40 = (((v12 >> 3) & 0x1FF) + 1) << ((0xFA50u >> (2 * (v15 & 7))) & 3);
  else
    v40 = (v33 + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v40 == v39 || v34 == 0)
    v42 = 0x4000;
  else
    v42 = 0;
  if (v34)
    v39 = v40;
  LODWORD(v82) = v15 | 0x42FF0000 | v42;
  HIDWORD(v82) = 2;
  *(_QWORD *)v92 = v39;
  v93 = (((v12 >> 3) & 0x1FF) + 1) << ((0xFA50u >> (2 * (v15 & 7))) & 3);
  v88 = v37 + v39 * v13;
  v89 = 0;
  v86 = ((unint64_t)v36 + 15) & 0xFFFFFFFFFFFFFFF0;
  v87 = v88 - v39 + v38 * (uint64_t)v13;
  v72[0] = v13;
  v72[1] = 1;
  v73 = v37 + v35;
  v74 = 0;
  v79 = v72;
  v80 = (cv *)v81;
  LODWORD(__p) = v15 | 0x42FF4000;
  HIDWORD(__p) = 2;
  v81[0] = v93;
  v81[1] = v93;
  v77 = v37 + v35 + v38 * (uint64_t)v13;
  v78 = 0;
  v75 = v37 + v35;
  v76 = v77;
  cv::_OutputArray::_OutputArray((uint64_t)v70, (cv::Mat *)&v82);
  cv::Mat::copyTo((cv::Mat *)&v98, (const cv::_OutputArray *)v70);
  v43 = v37 + v35 + v33;
  if (v15 == 5)
    v44 = cv::JacobiImpl_<float>(v84, *(unint64_t *)v92, v73, *(char **)&v94[16], v97[0], v13, v43);
  else
    v44 = cv::JacobiImpl_<double>(v84, *(unint64_t *)v92, v73, *(char **)&v94[16], v97[0], v13, v43);
  v45 = v44;
  cv::Mat::copyTo((cv::Mat *)&__p, v69);
  v47 = v74;
  if (v74)
  {
    do
    {
      v48 = __ldaxr(v47);
      v49 = v48 - 1;
    }
    while (__stlxr(v49, v47));
    if (!v49)
      cv::Mat::deallocate((cv::Mat *)&__p, v46);
  }
  v73 = 0;
  v76 = 0;
  v77 = 0;
  v75 = 0;
  if (SHIDWORD(__p) >= 1)
  {
    v50 = 0;
    v51 = v79;
    do
      v51[v50++] = 0;
    while (v50 < SHIDWORD(__p));
  }
  v74 = 0;
  if (v80 != (cv *)v81)
    cv::fastFree((void **)v80, v46);
  v52 = v85;
  if (v85)
  {
    do
    {
      v53 = __ldaxr(v52);
      v54 = v53 - 1;
    }
    while (__stlxr(v54, v52));
    if (!v54)
      cv::Mat::deallocate((cv::Mat *)&v82, v46);
  }
  v84 = 0;
  v87 = 0;
  v88 = 0;
  v86 = 0;
  if (SHIDWORD(v82) >= 1)
  {
    v55 = 0;
    v56 = v90;
    do
      v56[v55++] = 0;
    while (v55 < SHIDWORD(v82));
  }
  v85 = 0;
  if (v91 != (cv *)v92)
    cv::fastFree((void **)v91, v46);
  if (v109 != &v111 && v109 != 0)
    MEMORY[0x2207351A4]();
  v58 = *(unsigned int **)&v94[24];
  if (*(_QWORD *)&v94[24])
  {
    do
    {
      v59 = __ldaxr(v58);
      v60 = v59 - 1;
    }
    while (__stlxr(v60, v58));
    if (!v60)
      cv::Mat::deallocate((cv::Mat *)v94, v46);
  }
  *(_QWORD *)&v94[16] = 0;
  memset(&v94[32], 0, 24);
  if (*(int *)&v94[4] >= 1)
  {
    v61 = 0;
    v62 = v95;
    do
      *(_DWORD *)&v62[4 * v61++] = 0;
    while (v61 < *(int *)&v94[4]);
  }
  *(_QWORD *)&v94[24] = 0;
  if (v96 != (cv *)v97)
    cv::fastFree((void **)v96, v46);
  v63 = v102;
  if (v102)
  {
    do
    {
      v64 = __ldaxr(v63);
      v65 = v64 - 1;
    }
    while (__stlxr(v65, v63));
    if (!v65)
      cv::Mat::deallocate((cv::Mat *)&v98, v46);
  }
  v101 = 0;
  v103 = 0;
  v104 = 0;
  v105 = 0;
  if (SHIDWORD(v98) >= 1)
  {
    v66 = 0;
    v67 = v106;
    do
      *(_DWORD *)(v67 + 4 * v66++) = 0;
    while (v66 < SHIDWORD(v98));
  }
  v102 = 0;
  if (v107 != (cv *)&v108)
    cv::fastFree((void **)v107, v46);
  return v45;
}

void sub_219E660CC(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,char a52)
{
  void *v53;

  cv::Mat::~Mat((cv::Mat *)&a40, a2);
  cv::Mat::~Mat((cv::Mat *)&a52, v53);
  _Unwind_Resume(a1);
}

void cv::_SVDcompute(cv *this, const cv::_InputArray *a2, const cv::_OutputArray *a3, const cv::_OutputArray *a4, const cv::_OutputArray *a5)
{
  void (***v5)(uint64_t *__return_ptr, _QWORD, uint64_t);
  char v6;
  char v7;
  const cv::_OutputArray *v8;
  const cv::_OutputArray *v9;
  const cv::_InputArray *v10;
  const cv::_InputArray *v11;
  const cv::_OutputArray *v12;
  const cv::_OutputArray *v13;
  __int32 v14;
  __int32 v15;
  __int16 v16;
  int v17;
  const cv::Exception *v18;
  __int32 v19;
  __int32 v20;
  __int32 v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  _QWORD *v27;
  unint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v36;
  int v37;
  unint64_t v38;
  int v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  int v45;
  unsigned int v46;
  uint64_t v47;
  const cv::_OutputArray *v48;
  void *v49;
  unsigned int (*v50)(const cv::_InputArray *);
  const cv::_OutputArray *v51;
  cv::Mat *p_p;
  const cv::_OutputArray *v53;
  unsigned int *v54;
  unsigned int v55;
  unsigned int v56;
  uint64_t v57;
  _BYTE *v58;
  unsigned int *v59;
  unsigned int v60;
  unsigned int v61;
  uint64_t v62;
  _DWORD *v63;
  unsigned int *v64;
  unsigned int v65;
  unsigned int v66;
  uint64_t v67;
  _DWORD *v68;
  unsigned int *v69;
  unsigned int v70;
  unsigned int v71;
  uint64_t v72;
  _DWORD *v73;
  unsigned int *v75;
  unsigned int v76;
  unsigned int v77;
  uint64_t v78;
  uint64_t v79;
  __int32 v80;
  __int32 v81;
  const cv::_InputArray *v82;
  const cv::_OutputArray *v83;
  unsigned int v84;
  _BYTE v85[32];
  int64x2_t v86;
  __int128 v87;
  __int128 v88;
  unint64_t v89;
  uint64_t v90;
  uint64_t *v91;
  uint64_t *v92;
  uint64_t v93;
  uint64_t v94;
  _BYTE v95[64];
  _BYTE *v96;
  cv *v97;
  uint64_t v98;
  uint64_t v99;
  void *__p;
  _DWORD v101[2];
  unint64_t v102;
  unsigned int *v103;
  unint64_t v104;
  uint64_t v105;
  unint64_t v106;
  uint64_t v107;
  _DWORD *v108;
  cv *v109;
  uint64_t v110[2];
  void *v111;
  _DWORD v112[2];
  unint64_t v113;
  unsigned int *v114;
  unint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  _DWORD *v119;
  cv *v120;
  _QWORD v121[2];
  void *v122;
  _DWORD v123[2];
  unint64_t v124;
  unsigned int *v125;
  unint64_t v126;
  uint64_t v127;
  unint64_t v128;
  uint64_t v129;
  _DWORD *v130;
  cv *v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  __int32 v135;
  __int32 v136;
  uint64_t v137;
  unsigned int *v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  cv *v143;
  uint64_t v144;
  _QWORD *v145;
  uint64_t v146;
  _QWORD v147[518];

  v5 = (void (***)(uint64_t *__return_ptr, _QWORD, uint64_t))MEMORY[0x24BDAC7A8](this, a2);
  v7 = v6;
  v9 = v8;
  v11 = v10;
  v13 = v12;
  v147[515] = *MEMORY[0x24BDAC8D0];
  (**v5)(&v134, v5, 0xFFFFFFFFLL);
  v14 = v136;
  v15 = v135;
  v16 = v134;
  if (((*(uint64_t (**)(const cv::_InputArray *))(*(_QWORD *)v11 + 112))(v11) & 1) != 0)
    v17 = 1;
  else
    v17 = (*(uint64_t (**)(const cv::_OutputArray *))(*(_QWORD *)v9 + 112))(v9);
  v84 = v16 & 0xFFF;
  if (v84 - 5 >= 2)
  {
    std::string::basic_string[abi:ne180100]<0>(&v122, "type == CV_32F || type == CV_64F");
    std::string::basic_string[abi:ne180100]<0>(&v111, "_SVDcompute");
    std::string::basic_string[abi:ne180100]<0>(&__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/lapack.cpp");
    cv::Exception::Exception(&v145, 4294967081, &v122, &v111, &__p, 1518);
    cv::error((cv *)&v145, v18);
  }
  if ((v7 & 2) != 0)
  {
    (*(void (**)(const cv::_InputArray *))(*(_QWORD *)v11 + 152))(v11);
    (*(void (**)(const cv::_OutputArray *))(*(_QWORD *)v9 + 152))(v9);
    v17 = 0;
    if (v15 <= v14)
      v19 = v14;
    else
      v19 = v15;
    if (v15 >= v14)
      v20 = v14;
    else
      v20 = v15;
    v21 = v20;
  }
  else
  {
    if (v15 <= v14)
      v19 = v14;
    else
      v19 = v15;
    if (v15 >= v14)
      v20 = v14;
    else
      v20 = v15;
    if ((v7 & 4) != 0)
      v21 = v19;
    else
      v21 = v20;
  }
  v82 = v11;
  v83 = v9;
  v80 = v15;
  v81 = v14;
  if (SHIDWORD(v134) < 1)
    v22 = 0;
  else
    v22 = *((_QWORD *)v143 + (HIDWORD(v134) - 1));
  v23 = (v22 * v19 + 15) & 0xFFFFFFFFFFFFFFF0;
  v24 = v22 * v20;
  v25 = (v24 + 15) & 0xFFFFFFFFFFFFFFF0;
  v26 = v23 * v21;
  v145 = v147;
  v146 = 4104;
  v27 = v147;
  if (v24 + v25 * v20 + v26 + 32 >= 0x1009)
  {
    v146 = v24 + v25 * v20 + v26 + 32;
    v27 = (_QWORD *)operator new[]();
    v145 = v27;
  }
  v28 = ((unint64_t)v27 + 15) & 0xFFFFFFFFFFFFFFF0;
  v123[0] = v20;
  v123[1] = v19;
  v124 = v28;
  v125 = 0;
  v130 = v123;
  v131 = (cv *)&v132;
  v29 = ((v84 >> 3) + 1) << ((0xFA50u >> (2 * (v84 & 7))) & 3);
  v30 = v29 * (uint64_t)v19;
  if (v20 == 1)
    v31 = v29 * (uint64_t)v19;
  else
    v31 = v23;
  if (v21 == 1)
    v32 = v29 * (uint64_t)v19;
  else
    v32 = v23;
  if (v23)
    v33 = v31;
  else
    v33 = v29 * (uint64_t)v19;
  if (v23)
    v34 = v32;
  else
    v34 = v29 * (uint64_t)v19;
  if (v31 == v30 || v23 == 0)
    v36 = 0x4000;
  else
    v36 = 0;
  v37 = v84 | 0x42FF0000;
  HIDWORD(v122) = 2;
  LODWORD(v122) = v84 | 0x42FF0000 | v36;
  v132 = v33;
  v133 = ((v84 >> 3) + 1) << ((0xFA50u >> (2 * (v84 & 7))) & 3);
  v129 = 0;
  v128 = v28 + v33 * v20;
  v126 = ((unint64_t)v27 + 15) & 0xFFFFFFFFFFFFFFF0;
  v127 = v128 - v33 + v29 * (uint64_t)v19;
  v112[0] = v20;
  v112[1] = 1;
  v38 = v28 + v26;
  v113 = v28 + v26;
  v114 = 0;
  v119 = v112;
  v120 = (cv *)v121;
  HIDWORD(v111) = 2;
  LODWORD(v111) = v84 | 0x42FF4000;
  v121[0] = v133;
  v121[1] = v133;
  v117 = v28 + v26 + v29 * (uint64_t)v20;
  v118 = 0;
  v115 = v28 + v26;
  v116 = v117;
  v101[0] = v21;
  v101[1] = v19;
  v102 = v126;
  v103 = 0;
  v108 = v101;
  v109 = (cv *)v110;
  if (v32 == v30 || v23 == 0)
    v40 = 0x4000;
  else
    v40 = 0;
  HIDWORD(__p) = 2;
  LODWORD(__p) = v37 | v40;
  v110[0] = v34;
  v110[1] = ((v84 >> 3) + 1) << ((0xFA50u >> (2 * (v84 & 7))) & 3);
  v106 = v28 + v34 * v21;
  v107 = 0;
  v104 = ((unint64_t)v27 + 15) & 0xFFFFFFFFFFFFFFF0;
  v105 = v106 - v34 + v29 * (uint64_t)v19;
  v96 = &v95[8];
  v97 = (cv *)&v98;
  v98 = 0;
  v99 = 0;
  *(_DWORD *)v95 = 1124007936;
  memset(&v95[4], 0, 60);
  if (v17)
  {
    v41 = v29 * (uint64_t)v20;
    v42 = (v38 + v24 + 15) & 0xFFFFFFFFFFFFFFF0;
    v86.i32[2] = v20;
    v86.i32[3] = v20;
    v87 = v42;
    v91 = &v86.i64[1];
    v92 = &v93;
    if (v20 == 1)
      v43 = ((v84 >> 3) + 1) << ((0xFA50u >> (2 * (v84 & 7))) & 3);
    else
      v43 = (v24 + 15) & 0xFFFFFFFFFFFFFFF0;
    if (v43 == v41 || v25 == 0)
      v45 = 0x4000;
    else
      v45 = 0;
    v46 = v37 | v45;
    v86.i32[0] = v46;
    if (v25)
      v47 = v43;
    else
      v47 = v29 * (uint64_t)v20;
    v93 = v47;
    v94 = ((v84 >> 3) + 1) << ((0xFA50u >> (2 * (v84 & 7))) & 3);
    v89 = v42 + v47 * v20;
    v90 = 0;
    *(_QWORD *)&v88 = (v38 + v24 + 15) & 0xFFFFFFFFFFFFFFF0;
    *((_QWORD *)&v88 + 1) = v89 - v47 + v41;
    *(_QWORD *)v95 = v46 | 0x200000000;
    *(_DWORD *)&v95[8] = v20;
    *(_DWORD *)&v95[12] = v20;
    v98 = v47;
    v99 = v94;
    *(_OWORD *)&v95[32] = v88;
    *(_OWORD *)&v95[16] = (unint64_t)v88;
    *(_OWORD *)&v95[48] = v89;
  }
  if (v21 > v20)
  {
    v86 = 0uLL;
    v87 = 0uLL;
    cv::Mat::operator=((uint64_t)&__p, &v86);
  }
  if (v80 >= v81)
  {
    cv::_InputArray::_InputArray((uint64_t)&v86, (const cv::Mat *)&v134);
    cv::_OutputArray::_OutputArray((uint64_t)v85, (cv::Mat *)&v122);
    cv::transpose((cv *)&v86, (const cv::_InputArray *)v85, v48);
  }
  else
  {
    cv::_OutputArray::_OutputArray((uint64_t)&v86, (cv::Mat *)&v122);
    cv::Mat::copyTo((cv::Mat *)&v134, (const cv::_OutputArray *)&v86);
  }
  if (v84 == 5)
    cv::JacobiSVDImpl_<float>(v124, v110[0]);
  else
    cv::JacobiSVDImpl_<double>(v124, v110[0]);
  if ((*(unsigned int (**)(const cv::_OutputArray *))(*(_QWORD *)v13 + 112))(v13))
    cv::Mat::copyTo((cv::Mat *)&v111, v13);
  if (v17)
  {
    v50 = *(unsigned int (**)(const cv::_InputArray *))(*(_QWORD *)v82 + 112);
    if (v80 >= v81)
    {
      if (v50(v82))
      {
        cv::_InputArray::_InputArray((uint64_t)&v86, (const cv::Mat *)&__p);
        cv::transpose((cv *)&v86, v82, v53);
      }
      if (((*(uint64_t (**)(const cv::_OutputArray *))(*(_QWORD *)v83 + 112))(v83) & 1) != 0)
      {
        p_p = (cv::Mat *)v95;
        goto LABEL_86;
      }
    }
    else
    {
      if (v50(v82))
      {
        cv::_InputArray::_InputArray((uint64_t)&v86, (const cv::Mat *)v95);
        cv::transpose((cv *)&v86, v82, v51);
      }
      if ((*(unsigned int (**)(const cv::_OutputArray *))(*(_QWORD *)v83 + 112))(v83))
      {
        p_p = (cv::Mat *)&__p;
LABEL_86:
        cv::Mat::copyTo(p_p, v83);
      }
    }
  }
  v54 = *(unsigned int **)&v95[24];
  if (*(_QWORD *)&v95[24])
  {
    do
    {
      v55 = __ldaxr(v54);
      v56 = v55 - 1;
    }
    while (__stlxr(v56, v54));
    if (!v56)
      cv::Mat::deallocate((cv::Mat *)v95, v49);
  }
  *(_QWORD *)&v95[16] = 0;
  memset(&v95[32], 0, 24);
  if (*(int *)&v95[4] >= 1)
  {
    v57 = 0;
    v58 = v96;
    do
      *(_DWORD *)&v58[4 * v57++] = 0;
    while (v57 < *(int *)&v95[4]);
  }
  *(_QWORD *)&v95[24] = 0;
  if (v97 != (cv *)&v98)
    cv::fastFree((void **)v97, v49);
  v59 = v103;
  if (v103)
  {
    do
    {
      v60 = __ldaxr(v59);
      v61 = v60 - 1;
    }
    while (__stlxr(v61, v59));
    if (!v61)
      cv::Mat::deallocate((cv::Mat *)&__p, v49);
  }
  v102 = 0;
  v105 = 0;
  v106 = 0;
  v104 = 0;
  if (SHIDWORD(__p) >= 1)
  {
    v62 = 0;
    v63 = v108;
    do
      v63[v62++] = 0;
    while (v62 < SHIDWORD(__p));
  }
  v103 = 0;
  if (v109 != (cv *)v110)
    cv::fastFree((void **)v109, v49);
  v64 = v114;
  if (v114)
  {
    do
    {
      v65 = __ldaxr(v64);
      v66 = v65 - 1;
    }
    while (__stlxr(v66, v64));
    if (!v66)
      cv::Mat::deallocate((cv::Mat *)&v111, v49);
  }
  v113 = 0;
  v116 = 0;
  v117 = 0;
  v115 = 0;
  if (SHIDWORD(v111) >= 1)
  {
    v67 = 0;
    v68 = v119;
    do
      v68[v67++] = 0;
    while (v67 < SHIDWORD(v111));
  }
  v114 = 0;
  if (v120 != (cv *)v121)
    cv::fastFree((void **)v120, v49);
  v69 = v125;
  if (v125)
  {
    do
    {
      v70 = __ldaxr(v69);
      v71 = v70 - 1;
    }
    while (__stlxr(v71, v69));
    if (!v71)
      cv::Mat::deallocate((cv::Mat *)&v122, v49);
  }
  v124 = 0;
  v127 = 0;
  v128 = 0;
  v126 = 0;
  if (SHIDWORD(v122) >= 1)
  {
    v72 = 0;
    v73 = v130;
    do
      v73[v72++] = 0;
    while (v72 < SHIDWORD(v122));
  }
  v125 = 0;
  if (v131 != (cv *)&v132)
    cv::fastFree((void **)v131, v49);
  if (v145 != v147 && v145 != 0)
    MEMORY[0x2207351A4]();
  v75 = v138;
  if (v138)
  {
    do
    {
      v76 = __ldaxr(v75);
      v77 = v76 - 1;
    }
    while (__stlxr(v77, v75));
    if (!v77)
      cv::Mat::deallocate((cv::Mat *)&v134, v49);
  }
  v137 = 0;
  v139 = 0;
  v141 = 0;
  v140 = 0;
  if (SHIDWORD(v134) >= 1)
  {
    v78 = 0;
    v79 = v142;
    do
      *(_DWORD *)(v79 + 4 * v78++) = 0;
    while (v78 < SHIDWORD(v134));
  }
  v138 = 0;
  if (v143 != (cv *)&v144)
    cv::fastFree((void **)v143, v49);
}

void sub_219E66A88(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,void *__p,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,void *a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  void *a71;
  void *v72;
  void *v73;
  void *v74;
  void *v75;
  unint64_t v76;

  cv::Mat::~Mat((cv::Mat *)&a35, a2);
  cv::Mat::~Mat((cv::Mat *)&__p, v72);
  cv::Mat::~Mat((cv::Mat *)&a59, v73);
  cv::Mat::~Mat((cv::Mat *)&a71, v74);
  v76 = STACK[0x2B0];
  if (STACK[0x2B0] != a12)
  {
    if (v76)
      MEMORY[0x2207351A4](v76, 0x1000C8077774924);
  }
  cv::Mat::~Mat((cv::Mat *)&STACK[0x250], v75);
  _Unwind_Resume(a1);
}

uint64_t cv::JacobiImpl_<float>(uint64_t a1, unint64_t a2, uint64_t a3, char *a4, unint64_t a5, int a6, uint64_t a7)
{
  unint64_t v10;
  unint64_t v11;
  char *v12;
  _DWORD *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  int v18;
  int *v19;
  int *v20;
  uint64_t v21;
  uint64_t v22;
  float *v23;
  unint64_t v24;
  float v25;
  uint64_t v26;
  float v27;
  int v28;
  float v29;
  float *v30;
  uint64_t i;
  float v32;
  uint64_t v33;
  int j;
  uint64_t v35;
  float v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  float v40;
  uint64_t v41;
  uint64_t v42;
  float v43;
  uint64_t v44;
  uint64_t v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  BOOL v55;
  float v56;
  float v57;
  uint64_t v58;
  uint64_t v59;
  float v60;
  float v61;
  int v62;
  uint64_t v63;
  float *v64;
  float *v65;
  int v66;
  float v67;
  float v68;
  int v69;
  float *v70;
  float *v71;
  int v72;
  float v73;
  float v74;
  float *v75;
  uint64_t v76;
  float *v77;
  float v78;
  float v79;
  char v80;
  char v81;
  uint64_t v82;
  int v83;
  int v84;
  float v85;
  float *v86;
  float v87;
  float v88;
  int v89;
  float v90;
  float *v91;
  uint64_t k;
  float v93;
  uint64_t v94;
  uint64_t v95;
  char *v96;
  uint64_t v97;
  uint64_t v98;
  int v99;
  int v100;
  char *v101;
  uint64_t v102;
  _DWORD *v103;
  int v104;
  unint64_t v106;
  unint64_t v107;
  uint64_t v108;
  char *v109;

  if (a4)
  {
    if (a6 < 1)
      return 1;
    v107 = a2;
    v108 = a7;
    v106 = a5 >> 2;
    v10 = a5 & 0xFFFFFFFFFFFFFFFCLL;
    v11 = (a5 & 0xFFFFFFFFFFFFFFFCLL) + 4;
    v12 = a4;
    v109 = a4;
    v13 = a4;
    v14 = a6;
    do
    {
      bzero(v12, 4 * a6);
      *v13 = 1065353216;
      v13 = (_DWORD *)((char *)v13 + v11);
      v12 += v10;
      --v14;
    }
    while (v14);
    a5 = v106;
    a2 = v107;
    a7 = v108;
    a4 = v109;
  }
  v15 = (a6 - 1);
  if (a6 >= 1)
  {
    v16 = 0;
    v17 = a2 >> 2;
    v18 = 30 * a6 * a6;
    v19 = (int *)((a7 + 3) & 0xFFFFFFFFFFFFFFFCLL);
    v20 = &v19[a6];
    v21 = 4 * (a2 >> 2);
    v22 = a1;
    v23 = (float *)(a1 + v21);
    do
    {
      *(_DWORD *)(a3 + 4 * v16) = *(_DWORD *)(a1 + 4 * ((a2 >> 2) + 1) * v16);
      if (v16 < v15)
      {
        v24 = v16 + 1;
        if ((int)v16 + 2 < a6)
        {
          v25 = fabsf(*(float *)(a1 + 4 * (v17 * v16 + v24)));
          v26 = 2;
          do
          {
            v27 = fabsf(*(float *)(v22 + 4 * v26));
            if (v25 < v27)
            {
              LODWORD(v24) = v16 + v26;
              v25 = v27;
            }
            ++v26;
          }
          while (v16 - a6 + v26);
        }
        v19[v16] = v24;
      }
      if (v16)
      {
        if (v16 == 1)
        {
          v28 = 0;
        }
        else
        {
          v28 = 0;
          v29 = fabsf(*(float *)(a1 + 4 * v16));
          v30 = v23;
          for (i = 1; i != v16; ++i)
          {
            v32 = fabsf(*v30);
            if (v29 < v32)
            {
              v28 = i;
              v29 = v32;
            }
            v30 = (float *)((char *)v30 + v21);
          }
        }
        v20[v16] = v28;
      }
      ++v16;
      v22 += v21 + 4;
      ++v23;
    }
    while (v16 != a6);
    v33 = 4 * a5;
    if (a6 >= 2 && v18)
    {
      for (j = 0; j != v18; ++j)
      {
        v35 = *v19;
        v36 = fabsf(*(float *)(a1 + 4 * v35));
        if (a6 < 3)
        {
          LODWORD(v37) = 0;
        }
        else
        {
          LODWORD(v37) = 0;
          v38 = v17;
          v39 = 1;
          do
          {
            v40 = fabsf(*(float *)(a1 + 4 * (v38 + v19[v39])));
            if (v36 < v40)
            {
              LODWORD(v37) = v39;
              v36 = v40;
            }
            ++v39;
            v38 += v17;
          }
          while (v15 != v39);
          LODWORD(v35) = v19[(int)v37];
        }
        v41 = 1;
        do
        {
          v42 = v20[v41];
          v43 = fabsf(*(float *)(a1 + 4 * (v41 + v17 * v42)));
          if (v36 >= v43)
            v37 = v37;
          else
            v37 = v42;
          if (v36 < v43)
          {
            v36 = v43;
            LODWORD(v35) = v41;
          }
          ++v41;
        }
        while (a6 != v41);
        v44 = v17 * (int)v37;
        v45 = v44 + (int)v35;
        v46 = *(float *)(a1 + 4 * v45);
        v47 = fabsf(v46);
        if (v47 <= 0.00000011921)
          break;
        v48 = (float)(*(float *)(a3 + 4 * (int)v35) - *(float *)(a3 + 4 * (int)v37)) * 0.5;
        v49 = fabsf(v48);
        if (v47 <= v49)
        {
          v50 = 0.0;
          if (v48 != 0.0)
            v50 = v49 * sqrtf((float)((float)(v47 / v49) * (float)(v47 / v49)) + 1.0);
        }
        else
        {
          v50 = v47 * sqrtf((float)((float)(v49 / v47) * (float)(v49 / v47)) + 1.0);
        }
        v51 = v49 + v50;
        v52 = fabsf(v51);
        if (v47 <= v52)
        {
          v53 = 0.0;
          if (v51 != 0.0)
            v53 = v52 * sqrtf((float)((float)(v47 / v52) * (float)(v47 / v52)) + 1.0);
        }
        else
        {
          v53 = v47 * sqrtf((float)((float)(v52 / v47) * (float)(v52 / v47)) + 1.0);
        }
        v54 = v51 / v53;
        v55 = v48 < 0.0;
        if (v48 >= 0.0)
          v56 = v46 * (float)(v46 / v51);
        else
          v56 = -(float)(v46 * (float)(v46 / v51));
        *(_DWORD *)(a1 + 4 * v45) = 0;
        if (v55)
          v57 = -(float)(v46 / v53);
        else
          v57 = v46 / v53;
        *(float *)(a3 + 4 * (int)v37) = *(float *)(a3 + 4 * (int)v37) - v56;
        *(float *)(a3 + 4 * (int)v35) = v56 + *(float *)(a3 + 4 * (int)v35);
        if ((int)v37 >= 1)
        {
          v58 = v37;
          v59 = a1;
          do
          {
            v60 = *(float *)(v59 + 4 * (int)v37);
            v61 = *(float *)(v59 + 4 * (int)v35);
            *(float *)(v59 + 4 * (int)v37) = (float)(v60 * v54) - (float)(v61 * v57);
            *(float *)(v59 + 4 * (int)v35) = (float)(v54 * v61) + (float)(v60 * v57);
            v59 += v21;
            --v58;
          }
          while (v58);
        }
        v62 = v37 + 1;
        if ((int)v37 + 1 < (int)v35)
        {
          v63 = v62;
          v64 = (float *)(a1 + 4 * (v44 + v62));
          v65 = (float *)(a1 + 4 * ((int)v35 + v17 * v63));
          v66 = ~(_DWORD)v37 + v35;
          do
          {
            v67 = *v64;
            v68 = *v65;
            *v64 = (float)(*v64 * v54) - (float)(*v65 * v57);
            ++v64;
            *v65 = (float)(v54 * v68) + (float)(v67 * v57);
            v65 = (float *)((char *)v65 + v21);
            --v66;
          }
          while (v66);
        }
        v69 = v35 + 1;
        if ((int)v35 + 1 < a6)
        {
          v70 = (float *)(a1 + 4 * (v44 + v69));
          v71 = (float *)(a1 + 4 * (v17 * (int)v35 + v69));
          v72 = v15 - v35;
          do
          {
            v73 = *v70;
            v74 = *v71;
            *v70 = (float)(*v70 * v54) - (float)(*v71 * v57);
            ++v70;
            *v71++ = (float)(v54 * v74) + (float)(v73 * v57);
            --v72;
          }
          while (v72);
        }
        if (a4)
        {
          v75 = (float *)&a4[v33 * (int)v35];
          v76 = a6;
          v77 = (float *)&a4[v33 * (int)v37];
          do
          {
            v78 = *v77;
            v79 = *v75;
            *v77 = (float)(*v77 * v54) - (float)(*v75 * v57);
            ++v77;
            *v75++ = (float)(v54 * v79) + (float)(v78 * v57);
            --v76;
          }
          while (v76);
        }
        v80 = 1;
        do
        {
          v81 = v80;
          if ((v80 & 1) != 0)
            v82 = v37;
          else
            v82 = v35;
          if ((int)v82 < (int)v15)
          {
            v83 = v82 + 1;
            v84 = v82 + 2;
            if ((int)v82 + 2 < a6)
            {
              v85 = fabsf(*(float *)(a1 + 4 * (v17 * (int)v82 + v83)));
              v86 = (float *)(a1 + 4 * (v17 * (int)v82 + v84));
              do
              {
                v87 = *v86++;
                v88 = fabsf(v87);
                if (v85 < v88)
                {
                  v83 = v84;
                  v85 = v88;
                }
                ++v84;
              }
              while (a6 != v84);
            }
            v19[(int)v82] = v83;
          }
          if ((int)v82 >= 1)
          {
            if ((_DWORD)v82 == 1)
            {
              v89 = 0;
            }
            else
            {
              v89 = 0;
              v90 = fabsf(*(float *)(a1 + 4 * v82));
              v91 = (float *)(a1 + 4 * (v17 + v82));
              for (k = 1; k != v82; ++k)
              {
                v93 = fabsf(*v91);
                if (v90 < v93)
                {
                  v89 = k;
                  v90 = v93;
                }
                v91 = (float *)((char *)v91 + v21);
              }
            }
            v20[v82] = v89;
          }
          v80 = 0;
        }
        while ((v81 & 1) != 0);
      }
    }
    else if (a6 <= 1)
    {
      return 1;
    }
    v94 = 0;
    v95 = 1;
    v96 = a4;
    do
    {
      v97 = v94 + 1;
      if (v94 + 1 >= a6)
      {
        v99 = v94;
      }
      else
      {
        v98 = v95;
        v99 = v94;
        do
        {
          if (*(float *)(a3 + 4 * v99) < *(float *)(a3 + 4 * v98))
            v99 = v98;
          ++v98;
        }
        while (a6 != v98);
      }
      if (v94 != v99)
      {
        v100 = *(_DWORD *)(a3 + 4 * v99);
        *(_DWORD *)(a3 + 4 * v99) = *(_DWORD *)(a3 + 4 * v94);
        *(_DWORD *)(a3 + 4 * v94) = v100;
        if (a4)
        {
          v101 = &a4[v33 * v99];
          v102 = a6;
          v103 = v96;
          do
          {
            v104 = *(_DWORD *)v101;
            *(_DWORD *)v101 = *v103;
            v101 += 4;
            *v103++ = v104;
            --v102;
          }
          while (v102);
        }
      }
      ++v95;
      v96 += v33;
      v94 = v97;
    }
    while (v97 != v15);
  }
  return 1;
}

uint64_t cv::JacobiImpl_<double>(uint64_t a1, unint64_t a2, uint64_t a3, char *a4, unint64_t a5, int a6, uint64_t a7)
{
  unint64_t v10;
  unint64_t v11;
  char *v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  int v18;
  int *v19;
  int *v20;
  uint64_t v21;
  uint64_t v22;
  double *v23;
  unint64_t v24;
  double v25;
  uint64_t v26;
  double v27;
  int v28;
  double v29;
  double *v30;
  uint64_t i;
  double v32;
  uint64_t v33;
  int j;
  uint64_t v35;
  double v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  double v40;
  uint64_t v41;
  uint64_t v42;
  double v43;
  uint64_t v44;
  uint64_t v45;
  double v46;
  double v47;
  double v48;
  double v49;
  double v50;
  double v51;
  double v52;
  double v53;
  double v54;
  BOOL v55;
  double v56;
  double v57;
  uint64_t v58;
  uint64_t v59;
  double v60;
  double v61;
  int v62;
  uint64_t v63;
  double *v64;
  double *v65;
  int v66;
  double v67;
  double v68;
  int v69;
  double *v70;
  double *v71;
  int v72;
  double v73;
  double v74;
  double *v75;
  uint64_t v76;
  double *v77;
  double v78;
  double v79;
  char v80;
  char v81;
  uint64_t v82;
  int v83;
  int v84;
  double v85;
  double *v86;
  double v87;
  double v88;
  int v89;
  double v90;
  double *v91;
  uint64_t k;
  double v93;
  uint64_t v94;
  uint64_t v95;
  char *v96;
  uint64_t v97;
  uint64_t v98;
  int v99;
  uint64_t v100;
  char *v101;
  uint64_t v102;
  _QWORD *v103;
  uint64_t v104;
  unint64_t v106;
  unint64_t v107;
  uint64_t v108;
  char *v109;

  if (a4)
  {
    if (a6 < 1)
      return 1;
    v107 = a2;
    v108 = a7;
    v106 = a5 >> 3;
    v10 = a5 & 0xFFFFFFFFFFFFFFF8;
    v11 = (a5 & 0xFFFFFFFFFFFFFFF8) + 8;
    v12 = a4;
    v109 = a4;
    v13 = a4;
    v14 = a6;
    do
    {
      bzero(v12, 8 * a6);
      *v13 = 0x3FF0000000000000;
      v13 = (_QWORD *)((char *)v13 + v11);
      v12 += v10;
      --v14;
    }
    while (v14);
    a5 = v106;
    a2 = v107;
    a7 = v108;
    a4 = v109;
  }
  v15 = (a6 - 1);
  if (a6 >= 1)
  {
    v16 = 0;
    v17 = a2 >> 3;
    v18 = 30 * a6 * a6;
    v19 = (int *)((a7 + 3) & 0xFFFFFFFFFFFFFFFCLL);
    v20 = &v19[a6];
    v21 = 8 * (a2 >> 3);
    v22 = a1;
    v23 = (double *)(a1 + v21);
    do
    {
      *(_QWORD *)(a3 + 8 * v16) = *(_QWORD *)(a1 + 8 * ((a2 >> 3) + 1) * v16);
      if (v16 < v15)
      {
        v24 = v16 + 1;
        if ((int)v16 + 2 < a6)
        {
          v25 = fabs(*(double *)(a1 + 8 * (v17 * v16 + v24)));
          v26 = 2;
          do
          {
            v27 = fabs(*(double *)(v22 + 8 * v26));
            if (v25 < v27)
            {
              LODWORD(v24) = v16 + v26;
              v25 = v27;
            }
            ++v26;
          }
          while (v16 - a6 + v26);
        }
        v19[v16] = v24;
      }
      if (v16)
      {
        if (v16 == 1)
        {
          v28 = 0;
        }
        else
        {
          v28 = 0;
          v29 = fabs(*(double *)(a1 + 8 * v16));
          v30 = v23;
          for (i = 1; i != v16; ++i)
          {
            v32 = fabs(*v30);
            if (v29 < v32)
            {
              v28 = i;
              v29 = v32;
            }
            v30 = (double *)((char *)v30 + v21);
          }
        }
        v20[v16] = v28;
      }
      ++v16;
      v22 += v21 + 8;
      ++v23;
    }
    while (v16 != a6);
    v33 = 8 * a5;
    if (a6 >= 2 && v18)
    {
      for (j = 0; j != v18; ++j)
      {
        v35 = *v19;
        v36 = fabs(*(double *)(a1 + 8 * v35));
        if (a6 < 3)
        {
          LODWORD(v37) = 0;
        }
        else
        {
          LODWORD(v37) = 0;
          v38 = v17;
          v39 = 1;
          do
          {
            v40 = fabs(*(double *)(a1 + 8 * (v38 + v19[v39])));
            if (v36 < v40)
            {
              LODWORD(v37) = v39;
              v36 = v40;
            }
            ++v39;
            v38 += v17;
          }
          while (v15 != v39);
          LODWORD(v35) = v19[(int)v37];
        }
        v41 = 1;
        do
        {
          v42 = v20[v41];
          v43 = fabs(*(double *)(a1 + 8 * (v41 + v17 * v42)));
          if (v36 >= v43)
            v37 = v37;
          else
            v37 = v42;
          if (v36 < v43)
          {
            v36 = v43;
            LODWORD(v35) = v41;
          }
          ++v41;
        }
        while (a6 != v41);
        v44 = v17 * (int)v37;
        v45 = v44 + (int)v35;
        v46 = *(double *)(a1 + 8 * v45);
        v47 = fabs(v46);
        if (v47 <= 2.22044605e-16)
          break;
        v48 = (*(double *)(a3 + 8 * (int)v35) - *(double *)(a3 + 8 * (int)v37)) * 0.5;
        v49 = fabs(v48);
        if (v47 <= v49)
        {
          v50 = 0.0;
          if (v48 != 0.0)
            v50 = v49 * sqrt(v47 / v49 * (v47 / v49) + 1.0);
        }
        else
        {
          v50 = v47 * sqrt(v49 / v47 * (v49 / v47) + 1.0);
        }
        v51 = v49 + v50;
        v52 = fabs(v51);
        if (v47 <= v52)
        {
          v53 = 0.0;
          if (v51 != 0.0)
            v53 = v52 * sqrt(v47 / v52 * (v47 / v52) + 1.0);
        }
        else
        {
          v53 = v47 * sqrt(v52 / v47 * (v52 / v47) + 1.0);
        }
        v54 = v51 / v53;
        v55 = v48 < 0.0;
        if (v48 >= 0.0)
          v56 = v46 * (v46 / v51);
        else
          v56 = -(v46 * (v46 / v51));
        *(_QWORD *)(a1 + 8 * v45) = 0;
        if (v55)
          v57 = -(v46 / v53);
        else
          v57 = v46 / v53;
        *(double *)(a3 + 8 * (int)v37) = *(double *)(a3 + 8 * (int)v37) - v56;
        *(double *)(a3 + 8 * (int)v35) = v56 + *(double *)(a3 + 8 * (int)v35);
        if ((int)v37 >= 1)
        {
          v58 = v37;
          v59 = a1;
          do
          {
            v60 = *(double *)(v59 + 8 * (int)v37);
            v61 = *(double *)(v59 + 8 * (int)v35);
            *(double *)(v59 + 8 * (int)v37) = v60 * v54 - v61 * v57;
            *(double *)(v59 + 8 * (int)v35) = v54 * v61 + v60 * v57;
            v59 += v21;
            --v58;
          }
          while (v58);
        }
        v62 = v37 + 1;
        if ((int)v37 + 1 < (int)v35)
        {
          v63 = v62;
          v64 = (double *)(a1 + 8 * (v44 + v62));
          v65 = (double *)(a1 + 8 * ((int)v35 + v17 * v63));
          v66 = ~(_DWORD)v37 + v35;
          do
          {
            v67 = *v64;
            v68 = *v65;
            *v64 = *v64 * v54 - *v65 * v57;
            ++v64;
            *v65 = v54 * v68 + v67 * v57;
            v65 = (double *)((char *)v65 + v21);
            --v66;
          }
          while (v66);
        }
        v69 = v35 + 1;
        if ((int)v35 + 1 < a6)
        {
          v70 = (double *)(a1 + 8 * (v44 + v69));
          v71 = (double *)(a1 + 8 * (v17 * (int)v35 + v69));
          v72 = v15 - v35;
          do
          {
            v73 = *v70;
            v74 = *v71;
            *v70 = *v70 * v54 - *v71 * v57;
            ++v70;
            *v71++ = v54 * v74 + v73 * v57;
            --v72;
          }
          while (v72);
        }
        if (a4)
        {
          v75 = (double *)&a4[v33 * (int)v35];
          v76 = a6;
          v77 = (double *)&a4[v33 * (int)v37];
          do
          {
            v78 = *v77;
            v79 = *v75;
            *v77 = *v77 * v54 - *v75 * v57;
            ++v77;
            *v75++ = v54 * v79 + v78 * v57;
            --v76;
          }
          while (v76);
        }
        v80 = 1;
        do
        {
          v81 = v80;
          if ((v80 & 1) != 0)
            v82 = v37;
          else
            v82 = v35;
          if ((int)v82 < (int)v15)
          {
            v83 = v82 + 1;
            v84 = v82 + 2;
            if ((int)v82 + 2 < a6)
            {
              v85 = fabs(*(double *)(a1 + 8 * (v17 * (int)v82 + v83)));
              v86 = (double *)(a1 + 8 * (v17 * (int)v82 + v84));
              do
              {
                v87 = *v86++;
                v88 = fabs(v87);
                if (v85 < v88)
                {
                  v83 = v84;
                  v85 = v88;
                }
                ++v84;
              }
              while (a6 != v84);
            }
            v19[(int)v82] = v83;
          }
          if ((int)v82 >= 1)
          {
            if ((_DWORD)v82 == 1)
            {
              v89 = 0;
            }
            else
            {
              v89 = 0;
              v90 = fabs(*(double *)(a1 + 8 * v82));
              v91 = (double *)(a1 + 8 * (v17 + v82));
              for (k = 1; k != v82; ++k)
              {
                v93 = fabs(*v91);
                if (v90 < v93)
                {
                  v89 = k;
                  v90 = v93;
                }
                v91 = (double *)((char *)v91 + v21);
              }
            }
            v20[v82] = v89;
          }
          v80 = 0;
        }
        while ((v81 & 1) != 0);
      }
    }
    else if (a6 <= 1)
    {
      return 1;
    }
    v94 = 0;
    v95 = 1;
    v96 = a4;
    do
    {
      v97 = v94 + 1;
      if (v94 + 1 >= a6)
      {
        v99 = v94;
      }
      else
      {
        v98 = v95;
        v99 = v94;
        do
        {
          if (*(double *)(a3 + 8 * v99) < *(double *)(a3 + 8 * v98))
            v99 = v98;
          ++v98;
        }
        while (a6 != v98);
      }
      if (v94 != v99)
      {
        v100 = *(_QWORD *)(a3 + 8 * v99);
        *(_QWORD *)(a3 + 8 * v99) = *(_QWORD *)(a3 + 8 * v94);
        *(_QWORD *)(a3 + 8 * v94) = v100;
        if (a4)
        {
          v101 = &a4[v33 * v99];
          v102 = a6;
          v103 = v96;
          do
          {
            v104 = *(_QWORD *)v101;
            *(_QWORD *)v101 = *v103;
            v101 += 8;
            *v103++ = v104;
            --v102;
          }
          while (v102);
        }
      }
      ++v95;
      v96 += v33;
      v94 = v97;
    }
    while (v97 != v15);
  }
  return 1;
}

void cv::JacobiSVDImpl_<float>(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  float *v3;
  unint64_t v4;
  __n128 v5;
  __n128 v6;
  __n128 v7;
  int v8;
  unsigned int v9;
  int v10;
  int v11;
  int v12;
  float *v13;
  _DWORD *v14;
  _DWORD *v15;
  float v16;
  double v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  double *v21;
  unint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  float *v28;
  double v29;
  uint64_t v30;
  float *v31;
  float v32;
  int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  char v37;
  float *v38;
  float *v39;
  float *v40;
  float *v41;
  uint64_t v42;
  uint64_t v43;
  float *v44;
  float *v45;
  uint64_t v46;
  double v47;
  uint64_t v48;
  float *v49;
  float *v50;
  float v51;
  double v52;
  float v53;
  double v54;
  double v55;
  double v56;
  double v57;
  double v58;
  double v59;
  double v60;
  BOOL v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  uint64_t v67;
  double v68;
  double v69;
  float v70;
  float v71;
  float v72;
  float v73;
  uint64_t v74;
  float *v75;
  float *v76;
  float v77;
  uint64_t v78;
  float *v79;
  double v80;
  uint64_t v81;
  float *v82;
  float v83;
  uint64_t v84;
  uint64_t v85;
  float *v86;
  int *v87;
  uint64_t v88;
  uint64_t v89;
  int v90;
  double v91;
  uint64_t v92;
  int *v93;
  uint64_t v94;
  int *v95;
  int v96;
  unsigned __int32 *v97;
  uint64_t v98;
  unsigned __int32 *v99;
  unsigned __int32 v100;
  double *v101;
  double v102;
  uint64_t v103;
  uint64_t v104;
  unint64_t v105;
  float *v106;
  double v107;
  uint64_t v108;
  float *v109;
  float v110;
  char v111;
  char v112;
  uint64_t v113;
  uint64_t v114;
  unint64_t v115;
  double v116;
  unint64_t v117;
  double v118;
  float v119;
  float v120;
  unint64_t v121;
  float v122;
  unint64_t v123;
  double v124;
  unint64_t v125;
  float v126;
  unint64_t v127;
  int v128;
  unint64_t v129;
  unint64_t v130;
  uint64_t v131;
  int v132;
  int v133;
  _BYTE v134[4184];

  v2 = MEMORY[0x24BDAC7A8](a1, a2);
  v128 = v8;
  v10 = v9;
  v12 = v11;
  v13 = v3;
  v15 = v14;
  v16 = v6.n128_f32[0];
  v17 = v5.n128_f64[0];
  v19 = v18;
  v20 = v2;
  v21 = (double *)v134;
  if (v9 >= 0x209)
  {
    v22 = v4;
    v23 = operator new[]();
    v4 = v22;
    v21 = (double *)v23;
  }
  if (v12 <= 30)
    v24 = 30;
  else
    v24 = v12;
  v132 = v24;
  v129 = v4 >> 2;
  v127 = v19 >> 2;
  v25 = 4 * (v19 >> 2);
  v133 = v10;
  v26 = (v10 - 1);
  if (v10 >= 1)
  {
    v27 = 0;
    v131 = 4 * v10;
    v28 = (float *)v20;
    v130 = v4 & 0xFFFFFFFFFFFFFFFCLL;
    do
    {
      v29 = 0.0;
      if (v12 >= 1)
      {
        v30 = v12;
        v31 = v28;
        do
        {
          v32 = *v31++;
          v29 = v29 + v32 * v32;
          --v30;
        }
        while (v30);
      }
      v21[v27] = v29;
      if (v13)
      {
        bzero((char *)v13 + v130 * v27, v131);
        v13[(v129 + 1) * v27] = 1.0;
      }
      ++v27;
      v28 = (float *)((char *)v28 + v25);
    }
    while (v27 != v133);
  }
  v33 = 0;
  v34 = v133;
  v5.n128_f64[0] = v16;
  v35 = v133;
  v36 = 4 * v129;
  v6.n128_u64[0] = 1.0;
  v7.n128_u64[0] = 0.5;
  do
  {
    if (v34 <= 1)
      break;
    v3 = 0;
    v37 = 0;
    v38 = v13;
    v39 = &v13[v129];
    v40 = (float *)v20;
    v41 = (float *)(v20 + 4 * v127);
    v42 = 1;
    do
    {
      v43 = (uint64_t)v3 + 1;
      if ((uint64_t)v3 + 1 < v133)
      {
        v44 = v39;
        v45 = v41;
        v46 = v42;
        do
        {
          v47 = 0.0;
          if (v12 >= 1)
          {
            v48 = v12;
            v49 = v40;
            v50 = v45;
            do
            {
              v51 = *v49++;
              v52 = v51;
              v53 = *v50++;
              v47 = v47 + v52 * v53;
              --v48;
            }
            while (v48);
          }
          v54 = v21[(_QWORD)v3];
          v55 = v21[v46];
          if (fabs(v47) > sqrt(v54 * v55) * v5.n128_f64[0])
          {
            v56 = v47 + v47;
            v57 = v54 - v55;
            v58 = fabs(v56);
            v59 = vabdd_f64(v54, v55);
            if (v58 <= v59)
            {
              v60 = 0.0;
              if (v57 != 0.0)
                v60 = v59 * sqrt(v58 / v59 * (v58 / v59) + 1.0);
            }
            else
            {
              v60 = v58 * sqrt(v59 / v58 * (v59 / v58) + 1.0);
            }
            v61 = v57 < 0.0;
            v62 = sqrt((v57 + v60) / (v60 + v60));
            v63 = v56 / (v60 * v62 + v60 * v62);
            v64 = sqrt((v60 - v57) * 0.5 / v60);
            v65 = v56 / (v60 * v64 + v60 * v64);
            if (!v61)
            {
              v65 = v62;
              v64 = v63;
            }
            v66 = -v64;
            if (v12 < 1)
            {
              v69 = 0.0;
              v68 = 0.0;
            }
            else
            {
              v67 = 0;
              v68 = 0.0;
              v69 = 0.0;
              do
              {
                v70 = v40[v67];
                v71 = v45[v67];
                v72 = (float)(v64 * v71) + (float)(v65 * v70);
                v73 = (float)(v65 * v71) + (float)(v66 * v70);
                v40[v67] = v72;
                v45[v67] = v73;
                v69 = v69 + v72 * v72;
                v68 = v68 + v73 * v73;
                ++v67;
              }
              while (v12 != v67);
            }
            v21[(_QWORD)v3] = v69;
            v21[v46] = v68;
            if (v13)
            {
              v74 = v133;
              v75 = v38;
              v76 = v44;
              do
              {
                v77 = (float)(v65 * *v76) + (float)(v66 * *v75);
                *v75 = (float)(v64 * *v76) + (float)(v65 * *v75);
                ++v75;
                *v76++ = v77;
                --v74;
              }
              while (v74);
            }
            v37 = 1;
          }
          ++v46;
          v45 = (float *)((char *)v45 + v25);
          v44 = (float *)((char *)v44 + v36);
        }
        while (v46 != v133);
      }
      ++v42;
      v41 = (float *)((char *)v41 + v25);
      v40 = (float *)((char *)v40 + v25);
      v39 = (float *)((char *)v39 + v36);
      v38 = (float *)((char *)v38 + v36);
      v3 = (float *)((char *)v3 + 1);
    }
    while (v43 != v26);
    ++v33;
    v34 = v133;
  }
  while ((v37 & (v33 != v132)) != 0);
  if (v34 >= 1)
  {
    v78 = 0;
    v79 = (float *)v20;
    do
    {
      v80 = 0.0;
      if (v12 >= 1)
      {
        v81 = v12;
        v82 = v79;
        do
        {
          v83 = *v82++;
          v6.n128_f64[0] = v83;
          v80 = v80 + v6.n128_f64[0] * v6.n128_f64[0];
          --v81;
        }
        while (v81);
      }
      v21[v78++] = sqrt(v80);
      v79 = (float *)((char *)v79 + v25);
    }
    while (v78 != v133);
    if (v34 >= 2)
    {
      v84 = 0;
      v85 = 1;
      v86 = v13;
      v87 = (int *)v20;
      do
      {
        v88 = v84 + 1;
        if (v84 + 1 >= v133)
        {
          v90 = v84;
        }
        else
        {
          v89 = v85;
          v90 = v84;
          do
          {
            v6.n128_f64[0] = v21[v89];
            if (v21[v90] < v6.n128_f64[0])
              v90 = v89;
            ++v89;
          }
          while (v133 != v89);
        }
        if (v84 != v90)
        {
          v91 = v21[v84];
          v6.n128_f64[0] = v21[v90];
          v21[v84] = v6.n128_f64[0];
          v21[v90] = v91;
          if (v13)
          {
            v92 = v90;
            if (v12 >= 1)
            {
              v93 = (int *)(v20 + v25 * v90);
              v94 = v12;
              v95 = v87;
              do
              {
                v96 = *v95;
                *v95++ = *v93;
                *v93++ = v96;
                --v94;
              }
              while (v94);
            }
            v97 = (unsigned __int32 *)((char *)v13 + v36 * v92);
            v98 = v133;
            v99 = (unsigned __int32 *)v86;
            do
            {
              v100 = *v99;
              v6.n128_u32[0] = *v97;
              *v99++ = *v97;
              *v97++ = v100;
              --v98;
            }
            while (v98);
          }
        }
        ++v85;
        v87 = (int *)((char *)v87 + v25);
        v86 = (float *)((char *)v86 + v36);
        v84 = v88;
      }
      while (v88 != v26);
    }
    v101 = v21;
    do
    {
      v102 = *v101++;
      v5.n128_u32[1] = HIDWORD(v102);
      v5.n128_f32[0] = v102;
      *v15++ = v5.n128_u32[0];
      --v35;
    }
    while (v35);
  }
  if (v13 && v128 >= 1)
  {
    v103 = 0;
    v5.n128_u64[0] = 1.0;
    v6.n128_f64[0] = 1.0 / (double)v12;
    v6.n128_f32[0] = v6.n128_f64[0];
    v7.n128_f32[0] = -v6.n128_f32[0];
    v104 = 4 * v12;
    v105 = 305419896;
    v106 = (float *)v20;
    do
    {
      v107 = 0.0;
      if (v103 < v133)
        v107 = v21[v103];
      while (v107 <= v17)
      {
        v108 = v12;
        v109 = v106;
        if (v12 >= 1)
        {
          do
          {
            v105 = HIDWORD(v105) + 4164903690 * v105;
            if ((v105 & 0x100) != 0)
              v110 = v6.n128_f32[0];
            else
              v110 = -v6.n128_f32[0];
            *v109++ = v110;
            --v108;
          }
          while (v108);
        }
        v111 = 1;
        do
        {
          v112 = v111;
          if (v103)
          {
            v113 = 0;
            v114 = v20;
            do
            {
              if (v12 >= 1)
              {
                v115 = 0;
                v116 = 0.0;
                do
                {
                  v116 = v116 + (float)(v106[v115 / 4] * *(float *)(v114 + v115));
                  v115 += 4;
                }
                while (v104 != v115);
                v117 = 0;
                v118 = -v116;
                v119 = 0.0;
                do
                {
                  v120 = v106[v117 / 4] + v118 * *(float *)(v114 + v117);
                  v106[v117 / 4] = v120;
                  v119 = v119 + fabsf(v120);
                  v117 += 4;
                }
                while (v104 != v117);
                v121 = 0;
                if (v119 <= (float)(v16 * 100.0))
                  v122 = 0.0;
                else
                  v122 = 1.0 / v119;
                do
                {
                  v106[v121 / 4] = v122 * v106[v121 / 4];
                  v121 += 4;
                }
                while (v104 != v121);
              }
              ++v113;
              v114 += v25;
            }
            while (v113 != v103);
          }
          v111 = 0;
        }
        while ((v112 & 1) != 0);
        if (v12 < 1)
        {
          v124 = 0.0;
        }
        else
        {
          v123 = 0;
          v124 = 0.0;
          do
          {
            v124 = v124 + v106[v123 / 4] * v106[v123 / 4];
            v123 += 4;
          }
          while (v104 != v123);
        }
        v107 = sqrt(v124);
      }
      if (v12 >= 1)
      {
        v125 = 0;
        v126 = 1.0 / v107;
        do
        {
          v106[v125 / 4] = v106[v125 / 4] * v126;
          v125 += 4;
        }
        while (v104 != v125);
      }
      ++v103;
      v106 = (float *)((char *)v106 + v25);
    }
    while (v103 != v128);
  }
  if (v21 != (double *)v134)
    MEMORY[0x2207351A4](v21, 0x1000C8000313F17, v128, v3, v5, v6, v7);
}

void cv::JacobiSVDImpl_<double>(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unsigned int v4;
  unsigned int v5;
  int v6;
  int v7;
  unint64_t v8;
  unint64_t v9;
  double *v10;
  double *v11;
  void *v12;
  double v13;
  double v14;
  double v15;
  double v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  _BYTE *v20;
  int v21;
  uint64_t v22;
  BOOL v23;
  uint64_t v24;
  uint64_t v25;
  double *v26;
  double v27;
  uint64_t v28;
  double *v29;
  double v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  char v34;
  double *v35;
  double *v36;
  double *v37;
  double *v38;
  uint64_t v39;
  uint64_t v40;
  double *v41;
  double *v42;
  uint64_t v43;
  double v44;
  uint64_t v45;
  double *v46;
  double *v47;
  double v48;
  double v49;
  double v50;
  double v51;
  double v52;
  double v53;
  double v54;
  double v55;
  double v56;
  double v57;
  BOOL v58;
  double v59;
  double v60;
  double v61;
  double v62;
  double v63;
  uint64_t v64;
  double v65;
  double v66;
  double v67;
  double v68;
  double v69;
  double v70;
  uint64_t v71;
  double *v72;
  double *v73;
  double v74;
  uint64_t v75;
  double *v76;
  double v77;
  uint64_t v78;
  double *v79;
  double v80;
  uint64_t v81;
  uint64_t v82;
  double *v83;
  uint64_t *v84;
  uint64_t v85;
  uint64_t v86;
  int v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t *v90;
  uint64_t v91;
  uint64_t *v92;
  uint64_t v93;
  double *v94;
  uint64_t v95;
  double *v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  unint64_t v100;
  double *v101;
  double v102;
  uint64_t v103;
  double *v104;
  double v105;
  char v106;
  char v107;
  uint64_t v108;
  uint64_t v109;
  unint64_t v110;
  double v111;
  unint64_t v112;
  double v113;
  double v114;
  double v115;
  unint64_t v116;
  double v117;
  unint64_t v118;
  double v119;
  unint64_t v120;
  double v121;
  void *__dst;
  int v123;
  unint64_t v124;
  int v125;
  int v126;
  _BYTE v127[4184];

  v2 = MEMORY[0x24BDAC7A8](a1, a2);
  v123 = v3;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v11 = v10;
  __dst = v12;
  v14 = v13;
  v16 = v15;
  v18 = v17;
  v19 = v2;
  v20 = v127;
  if (v4 >= 0x209)
    v20 = (_BYTE *)operator new[]();
  if (v7 <= 30)
    v21 = 30;
  else
    v21 = v7;
  v125 = v21;
  v124 = v9 >> 3;
  v22 = 8 * (v18 >> 3);
  v126 = v5;
  v23 = __OFSUB__(v5, 1);
  v24 = v5 - 1;
  if ((int)v24 < 0 == v23)
  {
    v25 = 0;
    v26 = (double *)v19;
    do
    {
      v27 = 0.0;
      if (v7 >= 1)
      {
        v28 = v7;
        v29 = v26;
        do
        {
          v30 = *v29++;
          v27 = v27 + v30 * v30;
          --v28;
        }
        while (v28);
      }
      *(double *)&v20[8 * v25] = v27;
      if (v11)
      {
        bzero((char *)v11 + (v9 & 0xFFFFFFFFFFFFFFF8) * v25, 8 * v126);
        v11[(v124 + 1) * v25] = 1.0;
      }
      ++v25;
      v26 = (double *)((char *)v26 + v22);
    }
    while (v25 != v126);
  }
  v31 = 0;
  v32 = 8 * v124;
  do
  {
    if (v126 <= 1)
      break;
    v33 = 0;
    v34 = 0;
    v35 = v11;
    v36 = &v11[v124];
    v37 = (double *)v19;
    v38 = (double *)(v19 + 8 * (v18 >> 3));
    v39 = 1;
    do
    {
      v40 = v33 + 1;
      if (v33 + 1 < v126)
      {
        v41 = v36;
        v42 = v38;
        v43 = v39;
        do
        {
          v44 = 0.0;
          if (v7 >= 1)
          {
            v45 = v7;
            v46 = v37;
            v47 = v42;
            do
            {
              v48 = *v46++;
              v49 = v48;
              v50 = *v47++;
              v44 = v44 + v49 * v50;
              --v45;
            }
            while (v45);
          }
          v51 = *(double *)&v20[8 * v33];
          v52 = *(double *)&v20[8 * v43];
          if (fabs(v44) > sqrt(v51 * v52) * v14)
          {
            v53 = v44 + v44;
            v54 = v51 - v52;
            v55 = fabs(v53);
            v56 = vabdd_f64(v51, v52);
            if (v55 <= v56)
            {
              v57 = 0.0;
              if (v54 != 0.0)
                v57 = v56 * sqrt(v55 / v56 * (v55 / v56) + 1.0);
            }
            else
            {
              v57 = v55 * sqrt(v56 / v55 * (v56 / v55) + 1.0);
            }
            v58 = v54 < 0.0;
            v59 = sqrt((v54 + v57) / (v57 + v57));
            v60 = v53 / (v57 * v59 + v57 * v59);
            v61 = sqrt((v57 - v54) * 0.5 / v57);
            v62 = v53 / (v57 * v61 + v57 * v61);
            if (!v58)
            {
              v62 = v59;
              v61 = v60;
            }
            v63 = -v61;
            if (v7 < 1)
            {
              v66 = 0.0;
              v65 = 0.0;
            }
            else
            {
              v64 = 0;
              v65 = 0.0;
              v66 = 0.0;
              do
              {
                v67 = v37[v64];
                v68 = v42[v64];
                v69 = v61 * v68 + v62 * v67;
                v70 = v62 * v68 + v63 * v67;
                v37[v64] = v69;
                v42[v64] = v70;
                v66 = v66 + v69 * v69;
                v65 = v65 + v70 * v70;
                ++v64;
              }
              while (v7 != v64);
            }
            *(double *)&v20[8 * v33] = v66;
            *(double *)&v20[8 * v43] = v65;
            if (v11)
            {
              v71 = v126;
              v72 = v35;
              v73 = v41;
              do
              {
                v74 = v62 * *v73 + v63 * *v72;
                *v72 = v61 * *v73 + v62 * *v72;
                ++v72;
                *v73++ = v74;
                --v71;
              }
              while (v71);
            }
            v34 = 1;
          }
          ++v43;
          v42 = (double *)((char *)v42 + v22);
          v41 = (double *)((char *)v41 + v32);
        }
        while (v43 != v126);
      }
      ++v39;
      v38 = (double *)((char *)v38 + v22);
      v37 = (double *)((char *)v37 + v22);
      v36 = (double *)((char *)v36 + v32);
      v35 = (double *)((char *)v35 + v32);
      ++v33;
    }
    while (v40 != v24);
    ++v31;
  }
  while ((v34 & (v31 != v125)) != 0);
  if (v126 >= 1)
  {
    v75 = 0;
    v76 = (double *)v19;
    do
    {
      v77 = 0.0;
      if (v7 >= 1)
      {
        v78 = v7;
        v79 = v76;
        do
        {
          v80 = *v79++;
          v77 = v77 + v80 * v80;
          --v78;
        }
        while (v78);
      }
      *(double *)&v20[8 * v75++] = sqrt(v77);
      v76 = (double *)((char *)v76 + v22);
    }
    while (v75 != v126);
    if (v126 >= 2)
    {
      v81 = 0;
      v82 = 1;
      v83 = v11;
      v84 = (uint64_t *)v19;
      do
      {
        v85 = v81 + 1;
        if (v81 + 1 >= v126)
        {
          v87 = v81;
        }
        else
        {
          v86 = v82;
          v87 = v81;
          do
          {
            if (*(double *)&v20[8 * v87] < *(double *)&v20[8 * v86])
              v87 = v86;
            ++v86;
          }
          while (v126 != v86);
        }
        if (v81 != v87)
        {
          v88 = *(_QWORD *)&v20[8 * v81];
          *(_QWORD *)&v20[8 * v81] = *(_QWORD *)&v20[8 * v87];
          *(_QWORD *)&v20[8 * v87] = v88;
          if (v11)
          {
            v89 = v87;
            if (v7 >= 1)
            {
              v90 = (uint64_t *)(v19 + v22 * v87);
              v91 = v7;
              v92 = v84;
              do
              {
                v93 = *v92;
                *v92++ = *v90;
                *v90++ = v93;
                --v91;
              }
              while (v91);
            }
            v94 = (double *)((char *)v11 + v32 * v89);
            v95 = v126;
            v96 = v83;
            do
            {
              v97 = *(_QWORD *)v96;
              *v96++ = *v94;
              *(_QWORD *)v94++ = v97;
              --v95;
            }
            while (v95);
          }
        }
        ++v82;
        v84 = (uint64_t *)((char *)v84 + v22);
        v83 = (double *)((char *)v83 + v32);
        v81 = v85;
      }
      while (v85 != v24);
    }
    memcpy(__dst, v20, 8 * v126);
  }
  if (v11 && v123 >= 1)
  {
    v98 = 0;
    v99 = 8 * v7;
    v100 = 305419896;
    v101 = (double *)v19;
    do
    {
      v102 = 0.0;
      if (v98 < v126)
        v102 = *(double *)&v20[8 * v98];
      while (v102 <= v16)
      {
        v103 = v7;
        v104 = v101;
        if (v7 >= 1)
        {
          do
          {
            v100 = HIDWORD(v100) + 4164903690 * v100;
            if ((v100 & 0x100) != 0)
              v105 = 1.0 / (double)v7;
            else
              v105 = -(1.0 / (double)v7);
            *v104++ = v105;
            --v103;
          }
          while (v103);
        }
        v106 = 1;
        do
        {
          v107 = v106;
          if (v98)
          {
            v108 = 0;
            v109 = v19;
            do
            {
              if (v7 >= 1)
              {
                v110 = 0;
                v111 = 0.0;
                do
                {
                  v111 = v111 + v101[v110 / 8] * *(double *)(v109 + v110);
                  v110 += 8;
                }
                while (v99 != v110);
                v112 = 0;
                v113 = -v111;
                v114 = 0.0;
                do
                {
                  v115 = v101[v112 / 8] + v113 * *(double *)(v109 + v112);
                  v101[v112 / 8] = v115;
                  v114 = v114 + fabs(v115);
                  v112 += 8;
                }
                while (v99 != v112);
                v116 = 0;
                if (v114 <= v14 * 100.0)
                  v117 = 0.0;
                else
                  v117 = 1.0 / v114;
                do
                {
                  v101[v116 / 8] = v117 * v101[v116 / 8];
                  v116 += 8;
                }
                while (v99 != v116);
              }
              ++v108;
              v109 += v22;
            }
            while (v108 != v98);
          }
          v106 = 0;
        }
        while ((v107 & 1) != 0);
        if (v7 < 1)
        {
          v119 = 0.0;
        }
        else
        {
          v118 = 0;
          v119 = 0.0;
          do
          {
            v119 = v119 + v101[v118 / 8] * v101[v118 / 8];
            v118 += 8;
          }
          while (v99 != v118);
        }
        v102 = sqrt(v119);
      }
      if (v7 >= 1)
      {
        v120 = 0;
        v121 = 1.0 / v102;
        do
        {
          v101[v120 / 8] = v121 * v101[v120 / 8];
          v120 += 8;
        }
        while (v99 != v120);
      }
      ++v98;
      v101 = (double *)((char *)v101 + v22);
    }
    while (v98 != v123);
  }
  if (v20 != v127)
    MEMORY[0x2207351A4](v20, 0x1000C8000313F17);
}

uint64_t cv::MatrAXPY<double,double,double>(uint64_t result, int a2, uint64_t a3, int a4, uint64_t a5, int a6, uint64_t a7, int a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  float64x2_t v13;
  float64x2_t *v14;
  float64x2_t v15;

  if ((int)result >= 1)
  {
    v8 = 0;
    v9 = result;
    do
    {
      v10 = *(uint64_t *)(a5 + 8 * v8 * a6);
      if (a2 >= 4)
      {
        v12 = 0;
        v11 = 0;
        v13 = (float64x2_t)vdupq_lane_s64(v10, 0);
        do
        {
          v14 = (float64x2_t *)(a7 + v12);
          result = a3 + v12;
          v15 = *(float64x2_t *)(a7 + v12 + 16);
          *v14 = vmlaq_f64(*(float64x2_t *)(a7 + v12), *(float64x2_t *)(a3 + v12), v13);
          v14[1] = vmlaq_f64(v15, *(float64x2_t *)(a3 + v12 + 16), v13);
          v11 += 4;
          v12 += 32;
        }
        while (v11 <= a2 - 4);
        v11 = v11;
      }
      else
      {
        v11 = 0;
      }
      if ((int)v11 < a2)
      {
        do
        {
          *(double *)(a7 + 8 * v11) = *(double *)(a7 + 8 * v11) + *(double *)&v10 * *(double *)(a3 + 8 * v11);
          ++v11;
        }
        while (a2 != v11);
      }
      ++v8;
      a3 += 8 * a4;
      a7 += 8 * a8;
    }
    while (v8 != v9);
  }
  return result;
}

int *cv::swap(int *this, Mat *a2, Mat *a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int *v14;
  int *v15;
  uint64_t v16;
  uint64_t v17;

  v3 = *this;
  *this = *(_DWORD *)a2;
  *(_DWORD *)a2 = v3;
  v4 = this[1];
  this[1] = *((_DWORD *)a2 + 1);
  *((_DWORD *)a2 + 1) = v4;
  v5 = this[2];
  this[2] = *((_DWORD *)a2 + 2);
  *((_DWORD *)a2 + 2) = v5;
  v6 = this[3];
  this[3] = *((_DWORD *)a2 + 3);
  *((_DWORD *)a2 + 3) = v6;
  v7 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = *((_QWORD *)a2 + 2);
  *((_QWORD *)a2 + 2) = v7;
  v8 = *((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = *((_QWORD *)a2 + 3);
  *((_QWORD *)a2 + 3) = v8;
  v9 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = *((_QWORD *)a2 + 4);
  *((_QWORD *)a2 + 4) = v9;
  v10 = *((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = *((_QWORD *)a2 + 5);
  *((_QWORD *)a2 + 5) = v10;
  v11 = *((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = *((_QWORD *)a2 + 6);
  *((_QWORD *)a2 + 6) = v11;
  v12 = *((_QWORD *)this + 7);
  *((_QWORD *)this + 7) = *((_QWORD *)a2 + 7);
  *((_QWORD *)a2 + 7) = v12;
  v13 = *((_QWORD *)this + 8);
  *((_QWORD *)this + 8) = *((_QWORD *)a2 + 8);
  *((_QWORD *)a2 + 8) = v13;
  v14 = (int *)*((_QWORD *)this + 9);
  *((_QWORD *)this + 9) = *((_QWORD *)a2 + 9);
  v15 = this + 20;
  v16 = *((_QWORD *)this + 10);
  *((_QWORD *)a2 + 9) = v14;
  *((_QWORD *)this + 10) = *((_QWORD *)a2 + 10);
  *((_QWORD *)a2 + 10) = v16;
  v17 = *((_QWORD *)this + 11);
  *((_QWORD *)this + 11) = *((_QWORD *)a2 + 11);
  *((_QWORD *)a2 + 11) = v17;
  if (*((Mat **)this + 9) == (Mat *)((char *)a2 + 80))
  {
    *((_QWORD *)this + 8) = this + 2;
    *((_QWORD *)this + 9) = v15;
    v14 = (int *)*((_QWORD *)a2 + 9);
  }
  if (v14 == v15)
  {
    *((_QWORD *)a2 + 8) = (char *)a2 + 8;
    *((_QWORD *)a2 + 9) = (char *)a2 + 80;
  }
  return this;
}

void cv::Mat::create(cv::Mat *this, cv::Mat *a2, const int *a3, __int16 a4)
{
  const cv::Exception *v7;
  int v8;
  int v9;
  uint64_t v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  cv::Mat *v16;
  uint64_t v17;
  int *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const cv::Exception *v22;
  unint64_t v23;
  unint64_t v24;
  void *__p[2];
  void *v26[2];
  void *v27[2];
  _BYTE v28[120];

  if (a2 > 0x20 || !a3)
  {
    std::string::basic_string[abi:ne180100]<0>(v27, "0 <= d && d <= CV_MAX_DIM && _sizes");
    std::string::basic_string[abi:ne180100]<0>(v26, "create");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
    cv::Exception::Exception(v28, 4294967081, v27, v26, __p, 187);
    cv::error((cv *)v28, v7);
  }
  v8 = a4 & 0xFFF;
  if (*((_QWORD *)this + 2))
  {
    v9 = *((_DWORD *)this + 1);
    if (v9 == (_DWORD)a2)
    {
      if (v8 == (*(_DWORD *)this & 0xFFF))
      {
        if ((_DWORD)a2 == 2)
        {
          if (*((_DWORD *)this + 2) == *a3 && *((_DWORD *)this + 3) == a3[1])
            return;
        }
        else if ((int)a2 < 1)
        {
          LODWORD(v10) = 0;
          goto LABEL_21;
        }
LABEL_16:
        v10 = 0;
        while (*(_DWORD *)(*((_QWORD *)this + 8) + 4 * v10) == a3[v10])
        {
          if (a2 == ++v10)
            goto LABEL_22;
        }
LABEL_21:
        if ((_DWORD)v10 == (_DWORD)a2)
        {
LABEL_22:
          if ((int)a2 > 1 || *(_DWORD *)(*((_QWORD *)this + 8) + 4) == 1)
            return;
        }
      }
    }
    else if ((_DWORD)a2 == 1 && v9 < 3 && v8 == (*(_DWORD *)this & 0xFFF))
    {
      goto LABEL_16;
    }
  }
  v11 = (unsigned int *)*((_QWORD *)this + 3);
  if (v11)
  {
    do
    {
      v12 = __ldaxr(v11);
      v13 = v12 - 1;
    }
    while (__stlxr(v13, v11));
    if (!v13)
      cv::Mat::deallocate(this, a2);
  }
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  if (*((int *)this + 1) >= 1)
  {
    v14 = 0;
    v15 = *((_QWORD *)this + 8);
    do
      *(_DWORD *)(v15 + 4 * v14++) = 0;
    while (v14 < *((int *)this + 1));
  }
  *((_QWORD *)this + 3) = 0;
  if ((_DWORD)a2)
  {
    *(_DWORD *)this = v8 | 0x42FF0000;
    cv::setSize(this, a2, (uint64_t)a3, 0, (const unint64_t *)1);
    v16 = (cv::Mat *)*((unsigned int *)this + 1);
    if ((int)v16 >= 3)
    {
      v18 = (int *)*((_QWORD *)this + 8);
      v17 = 1;
      v19 = *((unsigned int *)this + 1);
      do
      {
        v20 = *v18++;
        v17 *= v20;
        --v19;
      }
      while (v19);
    }
    else
    {
      v17 = *((int *)this + 3) * (uint64_t)*((int *)this + 2);
    }
    if (v17)
    {
      v21 = *((_QWORD *)this + 7);
      if (v21)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v21 + 16))(v21);
        if (*(_QWORD *)(*((_QWORD *)this + 9) + 8 * *((int *)this + 1) - 8) != (((*(_DWORD *)this >> 3) & 0x1FF) + 1) << ((0xFA50u >> (2 * (*(_BYTE *)this & 7))) & 3))
        {
          std::string::basic_string[abi:ne180100]<0>(v27, "step[dims-1] == (size_t)CV_ELEM_SIZE(flags)");
          std::string::basic_string[abi:ne180100]<0>(v26, "create");
          std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
          cv::Exception::Exception(v28, 4294967081, v27, v26, __p, 236);
          cv::error((cv *)v28, v22);
        }
      }
      else
      {
        v23 = (**((_QWORD **)this + 9) * **((int **)this + 8) + 3) & 0xFFFFFFFFFFFFFFFCLL;
        v24 = cv::fastMalloc((cv *)(v23 + 4));
        *((_QWORD *)this + 2) = v24;
        *((_QWORD *)this + 3) = v24 + v23;
        *((_QWORD *)this + 4) = v24;
        *(_DWORD *)(v24 + v23) = 1;
      }
    }
    cv::finalizeHdr(this, v16);
  }
}

void sub_219E68B04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

void cv::Mat::release(cv::Mat *this, void *a2)
{
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;

  v3 = (unsigned int *)*((_QWORD *)this + 3);
  if (v3)
  {
    do
    {
      v4 = __ldaxr(v3);
      v5 = v4 - 1;
    }
    while (__stlxr(v5, v3));
    if (!v5)
      cv::Mat::deallocate(this, a2);
  }
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 4) = 0;
  if (*((int *)this + 1) >= 1)
  {
    v6 = 0;
    v7 = *((_QWORD *)this + 8);
    do
      *(_DWORD *)(v7 + 4 * v6++) = 0;
    while (v6 < *((int *)this + 1));
  }
  *((_QWORD *)this + 3) = 0;
}

void cv::setSize(cv *this, cv::Mat *a2, uint64_t a3, const int *a4, const unint64_t *a5)
{
  int v5;
  int v8;
  const cv::Exception *v10;
  void **v11;
  unint64_t v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  const cv::Exception *v18;
  uint64_t v19;
  void *__p[2];
  void *v22[2];
  void *v23[2];
  _BYTE v24[128];

  v5 = (int)a5;
  v8 = (int)a2;
  if (a2 >= 0x21)
  {
    std::string::basic_string[abi:ne180100]<0>(v23, "0 <= _dims && _dims <= CV_MAX_DIM");
    std::string::basic_string[abi:ne180100]<0>(v22, "setSize");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
    cv::Exception::Exception(v24, 4294967081, v23, v22, __p, 89);
    cv::error((cv *)v24, v10);
  }
  if (*((_DWORD *)this + 1) != (_DWORD)a2)
  {
    v11 = (void **)*((_QWORD *)this + 9);
    if (v11 != (void **)((char *)this + 80))
    {
      cv::fastFree(v11, a2);
      *((_QWORD *)this + 8) = (char *)this + 8;
      *((_QWORD *)this + 9) = (char *)this + 80;
    }
    if (v8 >= 3)
    {
      v12 = cv::fastMalloc((cv *)(4 * (v8 + 1) + 8 * v8));
      *((_QWORD *)this + 9) = v12;
      v13 = (int *)(v12 + 8 * v8);
      *v13 = v8;
      *((_QWORD *)this + 8) = v13 + 1;
      *((_QWORD *)this + 1) = -1;
    }
  }
  *((_DWORD *)this + 1) = v8;
  if (a3 && v8 >= 1)
  {
    v14 = (((*(_DWORD *)this >> 3) & 0x1FFu) + 1) << ((0xFA50u >> (2 * (*(_BYTE *)this & 7))) & 3);
    v15 = (v8 - 1);
    v16 = v14;
    do
    {
      v17 = *(_DWORD *)(a3 + 4 * v15);
      if (v17 < 0)
      {
        std::string::basic_string[abi:ne180100]<0>(v23, "s >= 0");
        std::string::basic_string[abi:ne180100]<0>(v22, "setSize");
        std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
        cv::Exception::Exception(v24, 4294967081, v23, v22, __p, 116);
        cv::error((cv *)v24, v18);
      }
      *(_DWORD *)(*((_QWORD *)this + 8) + 4 * v15) = v17;
      if (a4)
      {
        v19 = v14;
        if (v15 < (v8 - 1))
          v19 = *(_QWORD *)&a4[2 * v15];
        *(_QWORD *)(*((_QWORD *)this + 9) + 8 * v15) = v19;
      }
      else if (v5)
      {
        *(_QWORD *)(*((_QWORD *)this + 9) + 8 * v15) = v16;
        v16 *= v17;
      }
    }
    while (v15-- > 0);
    if (v8 == 1)
    {
      *((_DWORD *)this + 1) = 2;
      *((_DWORD *)this + 3) = 1;
      *(_QWORD *)(*((_QWORD *)this + 9) + 8) = v14;
    }
  }
}

void sub_219E68E60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,char a28)
{
  cv::Exception::~Exception((cv::Exception *)&a28);
  if (a15 < 0)
    operator delete(__p);
  if (a21 < 0)
    operator delete(a16);
  if (a27 < 0)
    operator delete(a22);
  _Unwind_Resume(a1);
}

uint64_t cv::finalizeHdr(cv *this, cv::Mat *a2)
{
  uint64_t result;
  int v4;
  uint64_t v5;
  int *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  result = cv::updateContinuityFlag((uint64_t)this, a2);
  v4 = *((_DWORD *)this + 1);
  if (v4 >= 3)
    *((_QWORD *)this + 1) = -1;
  v5 = *((_QWORD *)this + 2);
  if (v5)
  {
    v6 = (int *)*((_QWORD *)this + 8);
    v7 = (uint64_t *)*((_QWORD *)this + 9);
    v8 = *v6;
    v9 = *((_QWORD *)this + 4) + *v7 * v8;
    *((_QWORD *)this + 6) = v9;
    if ((int)v8 < 1)
    {
      *((_QWORD *)this + 5) = v9;
    }
    else
    {
      v10 = (v4 - 1);
      v11 = v5 + v7[(int)v10] * v6[(int)v10];
      *((_QWORD *)this + 5) = v11;
      if (v4 >= 2)
      {
        do
        {
          v12 = *v6++;
          v13 = v12 - 1;
          v14 = *v7++;
          v11 += v14 * v13;
          --v10;
        }
        while (v10);
        *((_QWORD *)this + 5) = v11;
      }
    }
  }
  else
  {
    *((_QWORD *)this + 5) = 0;
    *((_QWORD *)this + 6) = 0;
  }
  return result;
}

void cv::Mat::copySize(cv::Mat *this, const cv::Mat *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  cv::setSize(this, (cv::Mat *)*((unsigned int *)a2 + 1), 0, 0, 0);
  if (*((int *)this + 1) >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)a2 + 8);
    v6 = *((_QWORD *)a2 + 9);
    v7 = *((_QWORD *)this + 8);
    v8 = *((_QWORD *)this + 9);
    do
    {
      *(_DWORD *)(v7 + 4 * v4) = *(_DWORD *)(v5 + 4 * v4);
      *(_QWORD *)(v8 + 8 * v4) = *(_QWORD *)(v6 + 8 * v4);
      ++v4;
    }
    while (v4 < *((int *)this + 1));
  }
}

void cv::Mat::deallocate(cv::Mat *this, void *a2)
{
  uint64_t v3;

  v3 = *((_QWORD *)this + 7);
  if (v3)
    (*(void (**)(uint64_t, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v3 + 24))(v3, *((_QWORD *)this + 3), *((_QWORD *)this + 4), *((_QWORD *)this + 2));
  else
    cv::fastFree(*((void ***)this + 4), a2);
}

uint64_t cv::Mat::Mat(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t *v5;
  int *v6;
  int *v7;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  int *v11;
  int v12;
  const cv::Exception *v13;
  _QWORD *v14;
  int v15;
  uint64_t v16;
  unsigned int *v17;
  unsigned int v18;
  unsigned int *v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  unsigned int *v28;
  unsigned int v29;
  unsigned int *v30;
  unsigned int v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unsigned int *v36;
  int v37;
  _QWORD *v38;
  _QWORD *v39;
  int v40;
  int v41;
  const cv::Exception *v42;
  int v43;
  int v44;
  const cv::Exception *v45;
  int v46;
  int v47;
  BOOL v48;
  int v49;
  uint64_t v50;
  cv *v51;
  _QWORD *v52;
  cv *v53;
  unsigned int v54;
  unsigned int v55;
  uint64_t v56;
  uint64_t v57;
  int v59;
  unsigned int *v60;
  unsigned int v61;
  unsigned int v62;
  uint64_t v63;
  uint64_t v64;
  _QWORD __p[2];
  uint64_t v67;
  cv *v68[2];
  __int128 v69;
  uint64_t v70;
  uint64_t v71;
  cv *v72;
  uint64_t v73;
  _QWORD *v74;
  uint64_t v75;
  _QWORD v76[522];
  _QWORD v77[3];
  _QWORD v78[3];

  v2 = MEMORY[0x24BDAC7A8](a1, a2);
  v5 = v4;
  v7 = v6;
  v8 = v3;
  v9 = v2;
  v10 = (int *)(v2 + 8);
  *(_QWORD *)(v2 + 80) = 0;
  *(_QWORD *)(v2 + 64) = v2 + 8;
  *(_QWORD *)(v2 + 72) = v2 + 80;
  *(_QWORD *)(v2 + 88) = 0;
  *(_OWORD *)(v2 + 4) = 0u;
  v11 = (int *)(v2 + 4);
  *(_DWORD *)v2 = 1124007936;
  *(_OWORD *)(v2 + 20) = 0u;
  *(_OWORD *)(v2 + 36) = 0u;
  *(_OWORD *)(v2 + 48) = 0u;
  v12 = *(_DWORD *)(v3 + 4);
  if (v12 < 2)
  {
    std::string::basic_string[abi:ne180100]<0>(__p, "m.dims >= 2");
    std::string::basic_string[abi:ne180100]<0>(v78, "Mat");
    std::string::basic_string[abi:ne180100]<0>(v77, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
    cv::Exception::Exception(&v74, 4294967081, __p, v78, v77, 269);
    cv::error((cv *)&v74, v13);
  }
  if (v12 > 2)
  {
    bzero(v76, 0x1050uLL);
    v74 = v76;
    v75 = 520;
    if (v12 <= 0x208)
    {
      v25 = *v5;
      v76[0] = *(_QWORD *)v7;
      v76[1] = v25;
    }
    else
    {
      v75 = v12;
      v14 = (_QWORD *)operator new[]();
      bzero(v14, 8 * v12);
      v74 = v14;
      v15 = *(_DWORD *)(v8 + 4);
      v16 = *v5;
      *v14 = *(_QWORD *)v7;
      v14[1] = v16;
      if (v15 < 3)
        goto LABEL_23;
    }
    v26 = 2;
    do
      v74[v26++] = 0x7FFFFFFF80000000;
    while (v26 < *(int *)(v8 + 4));
    v14 = v74;
LABEL_23:
    cv::Mat::Mat((cv::Mat *)__p, (cv::Mat *)v8, (uint64_t)v14);
    if (__p == (_QWORD *)v9)
    {
      v36 = *(unsigned int **)(v9 + 24);
      if (v36)
        goto LABEL_66;
      goto LABEL_71;
    }
    v28 = (unsigned int *)v68[0];
    if (v68[0])
    {
      do
        v29 = __ldaxr(v28);
      while (__stlxr(v29 + 1, v28));
    }
    v30 = *(unsigned int **)(v9 + 24);
    if (v30)
    {
      do
      {
        v31 = __ldaxr(v30);
        v32 = v31 - 1;
      }
      while (__stlxr(v32, v30));
      if (!v32)
        cv::Mat::deallocate((cv::Mat *)v9, v27);
    }
    *(_QWORD *)(v9 + 16) = 0;
    *(_QWORD *)(v9 + 40) = 0;
    *(_QWORD *)(v9 + 48) = 0;
    *(_QWORD *)(v9 + 32) = 0;
    if (*(int *)(v9 + 4) <= 0)
    {
      *(_QWORD *)(v9 + 24) = 0;
      *(_DWORD *)v9 = __p[0];
    }
    else
    {
      v33 = 0;
      v34 = *(_QWORD *)(v9 + 64);
      do
      {
        *(_DWORD *)(v34 + 4 * v33++) = 0;
        v35 = *v11;
      }
      while (v33 < v35);
      *(_QWORD *)(v9 + 24) = 0;
      *(_DWORD *)v9 = __p[0];
      if ((int)v35 > 2)
        goto LABEL_64;
    }
    if (SHIDWORD(__p[0]) <= 2)
    {
      *(_DWORD *)(v9 + 4) = HIDWORD(__p[0]);
      *(_QWORD *)(v9 + 8) = __p[1];
      v51 = v72;
      v52 = *(_QWORD **)(v9 + 72);
      *v52 = *(_QWORD *)v72;
      v52[1] = *((_QWORD *)v51 + 1);
      goto LABEL_65;
    }
LABEL_64:
    cv::Mat::copySize((cv::Mat *)v9, (const cv::Mat *)__p);
LABEL_65:
    *(_QWORD *)(v9 + 16) = v67;
    *(_OWORD *)(v9 + 40) = v69;
    v53 = v68[0];
    *(_OWORD *)(v9 + 24) = *(_OWORD *)v68;
    *(_QWORD *)(v9 + 56) = v70;
    v36 = (unsigned int *)v53;
    if (v53)
    {
      do
      {
LABEL_66:
        v54 = __ldaxr(v36);
        v55 = v54 - 1;
      }
      while (__stlxr(v55, v36));
      if (!v55)
      {
        if (v70)
          (*(void (**)(uint64_t, cv *, cv *, uint64_t))(*(_QWORD *)v70 + 24))(v70, v68[0], v68[1], v67);
        else
          cv::fastFree((void **)v68[1], v27);
      }
    }
LABEL_71:
    v67 = 0;
    v68[1] = 0;
    v69 = 0uLL;
    if (SHIDWORD(__p[0]) >= 1)
    {
      v56 = 0;
      v57 = v71;
      do
        *(_DWORD *)(v57 + 4 * v56++) = 0;
      while (v56 < SHIDWORD(__p[0]));
    }
    v68[0] = 0;
    if (v72 != (cv *)&v73)
      cv::fastFree((void **)v72, v27);
    if (v74 != v76 && v74 != 0)
      MEMORY[0x2207351A4]();
    return v9;
  }
  if (v2 != v3)
  {
    v17 = *(unsigned int **)(v3 + 24);
    if (v17)
    {
      do
        v18 = __ldaxr(v17);
      while (__stlxr(v18 + 1, v17));
    }
    v19 = *(unsigned int **)(v2 + 24);
    if (v19)
    {
      do
      {
        v20 = __ldaxr(v19);
        v21 = v20 - 1;
      }
      while (__stlxr(v21, v19));
      if (!v21)
        cv::Mat::deallocate((cv::Mat *)v2, (void *)v3);
    }
    *(_QWORD *)(v9 + 16) = 0;
    *(_QWORD *)(v9 + 40) = 0;
    *(_QWORD *)(v9 + 48) = 0;
    *(_QWORD *)(v9 + 32) = 0;
    if (*(int *)(v9 + 4) <= 0)
    {
      *(_QWORD *)(v9 + 24) = 0;
      *(_DWORD *)v9 = *(_DWORD *)v8;
    }
    else
    {
      v22 = 0;
      v23 = *(_QWORD *)(v9 + 64);
      do
      {
        *(_DWORD *)(v23 + 4 * v22++) = 0;
        v24 = *v11;
      }
      while (v22 < v24);
      *(_QWORD *)(v9 + 24) = 0;
      *(_DWORD *)v9 = *(_DWORD *)v8;
      if ((int)v24 > 2)
        goto LABEL_40;
    }
    v37 = *(_DWORD *)(v8 + 4);
    if (v37 <= 2)
    {
      *(_DWORD *)(v9 + 4) = v37;
      *(_QWORD *)(v9 + 8) = *(_QWORD *)(v8 + 8);
      v38 = *(_QWORD **)(v8 + 72);
      v39 = *(_QWORD **)(v9 + 72);
      *v39 = *v38;
      v39[1] = v38[1];
LABEL_41:
      *(_OWORD *)(v9 + 32) = *(_OWORD *)(v8 + 32);
      *(_QWORD *)(v9 + 48) = *(_QWORD *)(v8 + 48);
      *(_OWORD *)(v9 + 16) = *(_OWORD *)(v8 + 16);
      *(_QWORD *)(v9 + 56) = *(_QWORD *)(v8 + 56);
      goto LABEL_42;
    }
LABEL_40:
    cv::Mat::copySize((cv::Mat *)v9, (const cv::Mat *)v8);
    goto LABEL_41;
  }
LABEL_42:
  v40 = *v7;
  v41 = v7[1];
  if ((*v7 != 0x80000000 || v41 != 0x7FFFFFFF) && (v40 || v41 != *v10))
  {
    if (v40 < 0 || v40 > v41 || v41 > *(_DWORD *)(v8 + 8))
    {
      std::string::basic_string[abi:ne180100]<0>(__p, "0 <= _rowRange.start && _rowRange.start <= _rowRange.end && _rowRange.end <= m.rows");
      std::string::basic_string[abi:ne180100]<0>(v78, "Mat");
      std::string::basic_string[abi:ne180100]<0>(v77, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
      cv::Exception::Exception(&v74, 4294967081, __p, v78, v77, 287);
      cv::error((cv *)&v74, v42);
    }
    *(_DWORD *)(v9 + 8) = v41 - v40;
    *(_QWORD *)(v9 + 16) += *(_QWORD *)(v9 + 80) * v40;
    *(_DWORD *)v9 |= 0x8000u;
  }
  v43 = *(_DWORD *)v5;
  v44 = *((_DWORD *)v5 + 1);
  if ((*(_DWORD *)v5 != 0x80000000 || v44 != 0x7FFFFFFF) && (v43 || v44 != *(_DWORD *)(v9 + 12)))
  {
    if (v43 < 0 || v43 > v44 || v44 > *(_DWORD *)(v8 + 12))
    {
      std::string::basic_string[abi:ne180100]<0>(__p, "0 <= _colRange.start && _colRange.start <= _colRange.end && _colRange.end <= m.cols");
      std::string::basic_string[abi:ne180100]<0>(v78, "Mat");
      std::string::basic_string[abi:ne180100]<0>(v77, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
      cv::Exception::Exception(&v74, 4294967081, __p, v78, v77, 296);
      cv::error((cv *)&v74, v45);
    }
    v46 = v44 - v43;
    *(_DWORD *)(v9 + 12) = v46;
    v47 = *(_DWORD *)(v9 + 4);
    v48 = __OFSUB__(v47, 1);
    v49 = v47 - 1;
    if (v49 < 0 != v48)
      v50 = 0;
    else
      v50 = *(_QWORD *)(*(_QWORD *)(v9 + 72) + 8 * v49);
    *(_QWORD *)(v9 + 16) += v50 * v43;
    if (v46 >= *(_DWORD *)(v8 + 12))
      v59 = -32769;
    else
      v59 = -49153;
    *(_DWORD *)v9 = v59 & *(_DWORD *)v9 | 0x8000;
  }
  if (*v10 == 1)
  {
    *(_DWORD *)v9 |= 0x4000u;
    goto LABEL_89;
  }
  if (*v10 >= 1)
  {
LABEL_89:
    if (*(int *)(v9 + 12) > 0)
      return v9;
  }
  v60 = *(unsigned int **)(v9 + 24);
  if (v60)
  {
    do
    {
      v61 = __ldaxr(v60);
      v62 = v61 - 1;
    }
    while (__stlxr(v62, v60));
    if (!v62)
      cv::Mat::deallocate((cv::Mat *)v9, (void *)v3);
  }
  *(_QWORD *)(v9 + 16) = 0;
  *(_QWORD *)(v9 + 40) = 0;
  *(_QWORD *)(v9 + 48) = 0;
  *(_QWORD *)(v9 + 32) = 0;
  if (*(int *)(v9 + 4) >= 1)
  {
    v63 = 0;
    v64 = *(_QWORD *)(v9 + 64);
    do
      *(_DWORD *)(v64 + 4 * v63++) = 0;
    while (v63 < *v11);
  }
  *(_QWORD *)(v9 + 24) = 0;
  *(_QWORD *)(v9 + 8) = 0;
  return v9;
}

void sub_219E69778(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24)
{
  cv::Mat *v24;
  uint64_t v25;
  uint64_t v26;
  void *v28;

  cv::Exception::~Exception((cv::Exception *)&a24);
  if (*(char *)(v25 + 23) < 0)
    operator delete(*(void **)(v26 - 128));
  if (*(char *)(v25 + 47) < 0)
    operator delete(*(void **)(v26 - 104));
  if (a14 < 0)
    operator delete(__p);
  __cxa_begin_catch(a1);
  cv::Mat::release(v24, v28);
  __cxa_rethrow();
}

void sub_219E69800(_Unwind_Exception *a1, void *a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  uint64_t v24;

  cv::Mat::~Mat((cv::Mat *)&__p, a2);
  if (a24 != v24)
  {
    if (a24)
      MEMORY[0x2207351A4]();
  }
  _Unwind_Resume(a1);
}

cv::Mat *cv::Mat::Mat(cv::Mat *this, char *a2, int32x2_t *a3)
{
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  const cv::Exception *v8;
  __int32 v9;
  __int32 v10;
  __int32 v11;
  int v12;
  uint64_t v13;
  __int32 v14;
  __int32 v15;
  const cv::Exception *v16;
  unsigned int *v17;
  unsigned int v18;
  _QWORD *v19;
  unsigned int *v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  void *__p[2];
  void *v27[2];
  void *v28[2];
  _BYTE v29[120];

  v4 = *(_DWORD *)a2;
  *(_DWORD *)this = *(_DWORD *)a2;
  *((_DWORD *)this + 1) = 2;
  *((int32x2_t *)this + 1) = vrev64_s32(a3[1]);
  v5 = *((_QWORD *)a2 + 2) + **((_QWORD **)a2 + 9) * a3->i32[1];
  *((_QWORD *)this + 2) = v5;
  *(_OWORD *)((char *)this + 24) = *(_OWORD *)(a2 + 24);
  *(_OWORD *)((char *)this + 40) = *(_OWORD *)(a2 + 40);
  v6 = *((_QWORD *)a2 + 7);
  *((_QWORD *)this + 10) = 0;
  v7 = (char *)this + 80;
  *((_QWORD *)this + 7) = v6;
  *((_QWORD *)this + 8) = (char *)this + 8;
  *((_QWORD *)this + 9) = (char *)this + 80;
  *((_QWORD *)this + 11) = 0;
  if (*((int *)a2 + 1) >= 3)
  {
    std::string::basic_string[abi:ne180100]<0>(v28, "m.dims <= 2");
    std::string::basic_string[abi:ne180100]<0>(v27, "Mat");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
    cv::Exception::Exception(v29, 4294967081, v28, v27, __p, 326);
    cv::error((cv *)v29, v8);
  }
  v9 = *((_DWORD *)a2 + 3);
  v11 = a3[1].i32[0];
  v10 = a3[1].i32[1];
  if (v11 >= v9)
    v12 = -1;
  else
    v12 = -16385;
  *(_DWORD *)this = v12 & v4 | ((v10 == 1) << 14);
  v13 = (((v4 >> 3) & 0x1FF) + 1) << ((0xFA50u >> (2 * (v4 & 7))) & 3);
  v14 = a3->i32[0];
  *((_QWORD *)this + 2) = v5 + (int)v13 * (uint64_t)a3->i32[0];
  if (v14 < 0 || v11 < 0 || v14 + v11 > v9 || (v15 = a3->i32[1], v15 < 0) || v10 < 0 || v15 + v10 > *((_DWORD *)a2 + 2))
  {
    std::string::basic_string[abi:ne180100]<0>(v28, "0 <= roi.x && 0 <= roi.width && roi.x + roi.width <= m.cols && 0 <= roi.y && 0 <= roi.height && roi.y + roi.height <= m.rows");
    std::string::basic_string[abi:ne180100]<0>(v27, "Mat");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
    cv::Exception::Exception(v29, 4294967081, v28, v27, __p, 333);
    cv::error((cv *)v29, v16);
  }
  v17 = (unsigned int *)*((_QWORD *)this + 3);
  if (v17)
  {
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 + 1, v17));
  }
  if (a3[1].i32[0] < *((_DWORD *)a2 + 3) || a3[1].i32[1] < *((_DWORD *)a2 + 2))
    *(_DWORD *)this |= 0x8000u;
  v19 = (_QWORD *)*((_QWORD *)this + 9);
  *v19 = **((_QWORD **)a2 + 9);
  v19[1] = v13;
  if (*((int *)this + 2) < 1 || *((int *)this + 3) <= 0)
  {
    v20 = (unsigned int *)*((_QWORD *)this + 3);
    if (v20)
    {
      do
      {
        v21 = __ldaxr(v20);
        v22 = v21 - 1;
      }
      while (__stlxr(v22, v20));
      if (!v22)
        cv::Mat::deallocate(this, a2);
    }
    *((_QWORD *)this + 2) = 0;
    *((_QWORD *)v7 - 5) = 0;
    *((_QWORD *)v7 - 4) = 0;
    *((_QWORD *)v7 - 6) = 0;
    if (*((int *)this + 1) >= 1)
    {
      v23 = 0;
      v24 = *((_QWORD *)this + 8);
      do
        *(_DWORD *)(v24 + 4 * v23++) = 0;
      while (v23 < *((int *)this + 1));
    }
    *((_QWORD *)this + 3) = 0;
    *((_QWORD *)this + 1) = 0;
  }
  return this;
}

void sub_219E69BC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

cv::Mat *cv::Mat::Mat(cv::Mat *this, cv::Mat *a2, const int *a3, __int16 a4, void *a5, const unint64_t *a6)
{
  cv::Mat *v7;

  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 8) = (char *)this + 8;
  *((_QWORD *)this + 9) = (char *)this + 80;
  *((_QWORD *)this + 11) = 0;
  *(_OWORD *)((char *)this + 20) = 0u;
  *(_OWORD *)((char *)this + 36) = 0u;
  *(_OWORD *)((char *)this + 4) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_DWORD *)this = a4 & 0xFFF | 0x42FF0000;
  *((_QWORD *)this + 4) = a5;
  *((_QWORD *)this + 2) = a5;
  cv::setSize(this, a2, (uint64_t)a3, (const int *)a6, (const unint64_t *)1);
  cv::finalizeHdr(this, v7);
  return this;
}

cv::Mat *cv::Mat::Mat(cv::Mat *this, cv::Mat *a2, uint64_t a3)
{
  int *v6;
  uint64_t v7;
  const cv::Exception *v8;
  uint64_t i;
  int v10;
  int v11;
  BOOL v12;
  const cv::Exception *v13;
  unsigned int *v14;
  unsigned int v15;
  unsigned int *v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  _QWORD *v23;
  _QWORD *v24;
  uint64_t j;
  uint64_t v26;
  uint64_t v28;
  BOOL v29;
  void *__p[2];
  void *v32[2];
  void *v33[2];
  _BYTE v34[128];

  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 8) = (char *)this + 8;
  *((_QWORD *)this + 9) = (char *)this + 80;
  *((_QWORD *)this + 11) = 0;
  *(_DWORD *)this = 1124007936;
  *(_OWORD *)((char *)this + 4) = 0u;
  v6 = (int *)((char *)this + 4);
  *(_OWORD *)((char *)this + 20) = 0u;
  *(_OWORD *)((char *)this + 36) = 0u;
  *((_OWORD *)this + 3) = 0u;
  v7 = *((unsigned int *)a2 + 1);
  if (!a3)
  {
    std::string::basic_string[abi:ne180100]<0>(v33, "ranges");
    std::string::basic_string[abi:ne180100]<0>(v32, "Mat");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
    cv::Exception::Exception(v34, 4294967081, v33, v32, __p, 364);
    cv::error((cv *)v34, v8);
  }
  if ((int)v7 >= 1)
  {
    for (i = 0; i != v7; ++i)
    {
      v11 = *(_DWORD *)(a3 + 8 * i);
      v10 = *(_DWORD *)(a3 + 8 * i + 4);
      v12 = v11 == 0x80000000 && v10 == 0x7FFFFFFF;
      if (!v12 && (v11 < 0 || v11 >= v10 || *(_DWORD *)(*((_QWORD *)a2 + 8) + 4 * i) < v10))
      {
        std::string::basic_string[abi:ne180100]<0>(v33, "r == Range::all() || (0 <= r.start && r.start < r.end && r.end <= m.size[i])");
        std::string::basic_string[abi:ne180100]<0>(v32, "Mat");
        std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
        cv::Exception::Exception(v34, 4294967081, v33, v32, __p, 368);
        cv::error((cv *)v34, v13);
      }
    }
  }
  if (this != a2)
  {
    v14 = (unsigned int *)*((_QWORD *)a2 + 3);
    if (v14)
    {
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 + 1, v14));
    }
    v16 = (unsigned int *)*((_QWORD *)this + 3);
    if (v16)
    {
      do
      {
        v17 = __ldaxr(v16);
        v18 = v17 - 1;
      }
      while (__stlxr(v18, v16));
      if (!v18)
        cv::Mat::deallocate(this, a2);
    }
    *((_QWORD *)this + 2) = 0;
    *((_QWORD *)this + 5) = 0;
    *((_QWORD *)this + 6) = 0;
    *((_QWORD *)this + 4) = 0;
    if (*((int *)this + 1) <= 0)
    {
      *((_QWORD *)this + 3) = 0;
      *(_DWORD *)this = *(_DWORD *)a2;
    }
    else
    {
      v19 = 0;
      v20 = *((_QWORD *)this + 8);
      do
      {
        *(_DWORD *)(v20 + 4 * v19++) = 0;
        v21 = *v6;
      }
      while (v19 < v21);
      *((_QWORD *)this + 3) = 0;
      *(_DWORD *)this = *(_DWORD *)a2;
      if ((int)v21 > 2)
        goto LABEL_29;
    }
    v22 = *((_DWORD *)a2 + 1);
    if (v22 <= 2)
    {
      *((_DWORD *)this + 1) = v22;
      *((_QWORD *)this + 1) = *((_QWORD *)a2 + 1);
      v23 = (_QWORD *)*((_QWORD *)a2 + 9);
      v24 = (_QWORD *)*((_QWORD *)this + 9);
      *v24 = *v23;
      v24[1] = v23[1];
LABEL_30:
      *((_OWORD *)this + 2) = *((_OWORD *)a2 + 2);
      *((_QWORD *)this + 6) = *((_QWORD *)a2 + 6);
      *((_OWORD *)this + 1) = *((_OWORD *)a2 + 1);
      *((_QWORD *)this + 7) = *((_QWORD *)a2 + 7);
      goto LABEL_31;
    }
LABEL_29:
    cv::Mat::copySize(this, a2);
    goto LABEL_30;
  }
LABEL_31:
  if ((int)v7 >= 1)
  {
    for (j = 0; j != v7; ++j)
    {
      v26 = *(_QWORD *)(a3 + 8 * j);
      if ((_DWORD)v26 != 0x80000000 || HIDWORD(v26) != 0x7FFFFFFF)
      {
        v28 = *((_QWORD *)this + 8);
        if ((_DWORD)v26)
          v29 = 0;
        else
          v29 = *(_DWORD *)(v28 + 4 * j) == HIDWORD(v26);
        if (!v29)
        {
          *(_DWORD *)(v28 + 4 * j) = HIDWORD(v26) - v26;
          *((_QWORD *)this + 2) += *(_QWORD *)(*((_QWORD *)this + 9) + 8 * j) * (int)v26;
          *(_DWORD *)this |= 0x8000u;
        }
      }
    }
  }
  cv::updateContinuityFlag((uint64_t)this, a2);
  return this;
}

void sub_219E6A01C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,char a28)
{
  cv::Exception::~Exception((cv::Exception *)&a28);
  if (a15 < 0)
    operator delete(__p);
  if (a21 < 0)
    operator delete(a16);
  if (a27 < 0)
    operator delete(a22);
  _Unwind_Resume(a1);
}

uint64_t cv::updateContinuityFlag(uint64_t this, cv::Mat *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  int v14;

  v2 = *(unsigned int *)(this + 4);
  v3 = *(_QWORD *)(this + 64);
  if ((int)v2 < 1)
  {
    v5 = 0;
  }
  else
  {
    v4 = 0;
    while (*(int *)(v3 + 4 * v4) <= 1)
    {
      if (v2 == ++v4)
      {
        v5 = *(_DWORD *)(this + 4);
        goto LABEL_8;
      }
    }
    v5 = v4;
  }
LABEL_8:
  v6 = (int)v2;
  v7 = v5;
  v8 = v3 - 4;
  while (1)
  {
    v9 = v6 - 1;
    if (v6 - 1 <= v7)
      break;
    v10 = *(int *)(v8 + 4 * v6);
    v11 = *(_QWORD *)(this + 72) + 8 * v6;
    v12 = *(_QWORD *)(v11 - 16);
    v13 = *(_QWORD *)(v11 - 8) * v10;
    v6 = v9;
    if (v13 < v12)
    {
      v14 = 0;
      goto LABEL_13;
    }
  }
  v14 = 0x4000;
LABEL_13:
  *(_DWORD *)this = *(_DWORD *)this & 0xFFFFBFFF | v14;
  return this;
}

cv *cv::Mat::Mat(cv *this, uint64_t a2, int a3)
{
  int *v4;
  uint64_t v7;
  cv::Mat *v8;
  int *v9;
  int *v10;
  _DWORD *v11;
  cv::Mat *v12;
  uint64_t v13;
  cv::Mat *v14;
  __int128 v15;
  __int128 v16;
  unsigned int v17;
  int v18;
  _QWORD *v19;
  cv *v20;
  void *v21;
  unsigned int *v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t v25;
  char *v26;
  uint64_t (**v28)(cv::_InputArray *__hidden, int);
  int v29;
  cv *v30;
  uint64_t v31;
  __int128 v32;
  uint64_t v33;
  cv *v34[2];
  __int128 v35;
  uint64_t v36;
  char *v37;
  cv *v38;
  _QWORD v39[3];
  int v40[64];
  _BYTE v41[128];
  uint64_t v42;

  v42 = *MEMORY[0x24BDAC8D0];
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 8) = (char *)this + 8;
  *((_QWORD *)this + 9) = (char *)this + 80;
  *((_QWORD *)this + 11) = 0;
  *(_DWORD *)this = 1124007936;
  *(_OWORD *)((char *)this + 4) = 0u;
  v4 = (int *)((char *)this + 4);
  *(_OWORD *)((char *)this + 20) = 0u;
  *(_OWORD *)((char *)this + 36) = 0u;
  *((_OWORD *)this + 3) = 0u;
  if (a2)
  {
    v7 = *(_QWORD *)(a2 + 24);
    *((_QWORD *)this + 4) = v7;
    *((_QWORD *)this + 2) = v7;
    *(_DWORD *)this = *(_DWORD *)a2 & 0xFFF | 0x42FF0000;
    v8 = (cv::Mat *)*(unsigned int *)(a2 + 4);
    if ((int)v8 >= 1)
    {
      v9 = (int *)(a2 + 36);
      v10 = v40;
      v11 = v41;
      v12 = v8;
      do
      {
        v13 = *v9;
        *v11++ = *(v9 - 1);
        *(_QWORD *)v10 = v13;
        v10 += 2;
        v9 += 2;
        v12 = (cv::Mat *)((char *)v12 - 1);
      }
      while (v12);
    }
    cv::setSize(this, v8, (uint64_t)v41, v40, 0);
    cv::finalizeHdr(this, v14);
    if (a3)
    {
      v15 = *(_OWORD *)this;
      v32 = *(_OWORD *)this;
      v33 = *((_QWORD *)this + 2);
      v16 = *(_OWORD *)((char *)this + 24);
      *(_OWORD *)v34 = v16;
      v35 = *(_OWORD *)((char *)this + 40);
      v36 = *((_QWORD *)this + 7);
      v37 = (char *)&v32 + 8;
      v39[0] = 0;
      v39[1] = 0;
      v38 = (cv *)v39;
      if ((_QWORD)v16)
      {
        do
          v17 = __ldaxr((unsigned int *)v16);
        while (__stlxr(v17 + 1, (unsigned int *)v16));
        v18 = *v4;
      }
      else
      {
        v18 = DWORD1(v15);
      }
      if (v18 > 2)
      {
        DWORD1(v32) = 0;
        cv::Mat::copySize((cv::Mat *)&v32, this);
      }
      else
      {
        v19 = (_QWORD *)*((_QWORD *)this + 9);
        v20 = v38;
        *(_QWORD *)v38 = *v19;
        *((_QWORD *)v20 + 1) = v19[1];
      }
      v29 = 0x10000;
      v30 = this;
      v31 = 0;
      v28 = &off_24DBF02F0;
      cv::Mat::copyTo((cv::Mat *)&v32, (const cv::_OutputArray *)&v28);
      v22 = (unsigned int *)v34[0];
      if (v34[0])
      {
        do
        {
          v23 = __ldaxr(v22);
          v24 = v23 - 1;
        }
        while (__stlxr(v24, v22));
        if (!v24)
        {
          if (v36)
            (*(void (**)(uint64_t, cv *, cv *, uint64_t))(*(_QWORD *)v36 + 24))(v36, v34[0], v34[1], v33);
          else
            cv::fastFree((void **)v34[1], v21);
        }
      }
      v33 = 0;
      v35 = 0uLL;
      v34[1] = 0;
      if (SDWORD1(v32) >= 1)
      {
        v25 = 0;
        v26 = v37;
        do
          *(_DWORD *)&v26[4 * v25++] = 0;
        while (v25 < SDWORD1(v32));
      }
      v34[0] = 0;
      if (v38 != (cv *)v39)
        cv::fastFree((void **)v38, v21);
    }
  }
  return this;
}

void sub_219E6A37C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t cv::_OutputArray::_OutputArray(uint64_t this, cv::Mat *a2)
{
  *(_DWORD *)(this + 8) = 0x10000;
  *(_QWORD *)(this + 16) = a2;
  *(_QWORD *)(this + 24) = 0;
  *(_QWORD *)this = &off_24DBF02F0;
  return this;
}

void cv::Mat::diag(cv::Mat *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  int v6;
  const cv::Exception *v7;
  __int128 v8;
  unsigned int v9;
  _QWORD *v10;
  _QWORD *v11;
  BOOL v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int *v17;
  unsigned int v18;
  _DWORD *v19;
  void *__p[2];
  void *v21[2];
  void *v22[2];
  _BYTE v23[120];

  v6 = *((_DWORD *)this + 1);
  if (v6 >= 3)
  {
    std::string::basic_string[abi:ne180100]<0>(v22, "dims <= 2");
    std::string::basic_string[abi:ne180100]<0>(v21, "diag");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
    cv::Exception::Exception(v23, 4294967081, v22, v21, __p, 415);
    cv::error((cv *)v23, v7);
  }
  *(_DWORD *)a3 = *(_DWORD *)this;
  *(_DWORD *)(a3 + 4) = v6;
  *(_QWORD *)(a3 + 8) = *((_QWORD *)this + 1);
  *(_QWORD *)(a3 + 16) = *((_QWORD *)this + 2);
  v8 = *(_OWORD *)((char *)this + 24);
  *(_OWORD *)(a3 + 24) = v8;
  *(_OWORD *)(a3 + 40) = *(_OWORD *)((char *)this + 40);
  *(_QWORD *)(a3 + 56) = *((_QWORD *)this + 7);
  *(_QWORD *)(a3 + 64) = a3 + 8;
  *(_QWORD *)(a3 + 80) = 0;
  *(_QWORD *)(a3 + 72) = a3 + 80;
  *(_QWORD *)(a3 + 88) = 0;
  if ((_QWORD)v8)
  {
    do
      v9 = __ldaxr((unsigned int *)v8);
    while (__stlxr(v9 + 1, (unsigned int *)v8));
    v6 = *((_DWORD *)this + 1);
  }
  if (v6 > 2)
  {
    *(_DWORD *)(a3 + 4) = 0;
    cv::Mat::copySize((cv::Mat *)a3, this);
    v6 = *((_DWORD *)this + 1);
  }
  else
  {
    v10 = (_QWORD *)*((_QWORD *)this + 9);
    v11 = *(_QWORD **)(a3 + 72);
    *v11 = *v10;
    v11[1] = v10[1];
  }
  v12 = __OFSUB__(v6, 1);
  v13 = v6 - 1;
  if (v13 < 0 != v12)
  {
    v14 = 0;
    if ((a2 & 0x80000000) == 0)
      goto LABEL_11;
  }
  else
  {
    v14 = *(_QWORD *)(*((_QWORD *)this + 9) + 8 * v13);
    if ((a2 & 0x80000000) == 0)
    {
LABEL_11:
      v15 = *((_DWORD *)this + 3) - a2;
      if (*((_DWORD *)this + 2) < v15)
        v15 = *((_DWORD *)this + 2);
      v16 = *(_QWORD *)(a3 + 16) + v14 * a2;
      goto LABEL_18;
    }
  }
  v15 = *((_DWORD *)this + 2) + a2;
  if (*((_DWORD *)this + 3) < v15)
    v15 = *((_DWORD *)this + 3);
  v16 = *(_QWORD *)(a3 + 16) - **((_QWORD **)this + 9) * (int)a2;
LABEL_18:
  *(_QWORD *)(a3 + 16) = v16;
  *(_DWORD *)(a3 + 8) = v15;
  v17 = *(int **)(a3 + 64);
  *v17 = v15;
  *(_DWORD *)(a3 + 12) = 1;
  v17[1] = 1;
  if (v15 <= 1)
    v14 = 0;
  **(_QWORD **)(a3 + 72) += v14;
  v18 = *(_DWORD *)a3 & 0xFFFFBFFF | ((*(_DWORD *)(a3 + 8) < 2) << 14);
  *(_DWORD *)a3 = v18;
  v19 = (_DWORD *)*((_QWORD *)this + 8);
  if (v19[1] != 1 || *v19 != 1)
    *(_DWORD *)a3 = v18 | 0x8000;
}

void sub_219E6A600(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

uint64_t cv::Mat::Mat(uint64_t a1, int *a2, char a3)
{
  uint64_t v4;
  int v5;
  cv *v6;
  unsigned int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  BOOL v11;
  int v12;
  uint64_t v13;
  void *v14;
  unsigned int *v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _DWORD *v26;
  uint64_t (**v28)(cv::_InputArray *__hidden, int);
  int v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  int v33;
  _DWORD v34[2];
  cv *v35;
  unsigned int *v36;
  cv *v37;
  uint64_t v38;
  char *v39;
  uint64_t v40;
  _DWORD *v41;
  cv *v42;
  _QWORD v43[2];

  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 64) = a1 + 8;
  *(_QWORD *)(a1 + 72) = a1 + 80;
  *(_QWORD *)(a1 + 88) = 0;
  *(_DWORD *)a1 = 1124007936;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_OWORD *)(a1 + 20) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  if (a2)
  {
    if ((a3 & 1) != 0)
    {
      *(_QWORD *)(a1 + 32) = 0;
      *(_QWORD *)(a1 + 40) = 0;
      v4 = a2[8];
      v5 = a2[9];
      v6 = (cv *)*((_QWORD *)a2 + 3);
      v7 = *a2;
      v8 = a2[1];
      v9 = (((v7 >> 3) & 0x1FF) + 1) << ((0xFA50u >> (2 * (v7 & 7))) & 3);
      if (v4 == 1)
        v10 = v9 * (uint64_t)v5;
      else
        v10 = a2[1];
      v11 = v10 == v9 * (uint64_t)v5 || v8 == 0;
      v34[0] = a2[8];
      v34[1] = v5;
      v35 = v6;
      v36 = 0;
      if (v11)
        v12 = 0x4000;
      else
        v12 = 0;
      v41 = v34;
      v42 = (cv *)v43;
      if ((_DWORD)v8)
        v13 = v10;
      else
        v13 = v9 * (uint64_t)v5;
      v32 = v12 & 0xFFFFF000 | v7 & 0xFFF | 0x42FF0000;
      v33 = 2;
      v43[0] = v13;
      v43[1] = (((v7 >> 3) & 0x1FF) + 1) << ((0xFA50u >> (2 * (v7 & 7))) & 3);
      v39 = (char *)v6 + v13 * v4;
      v40 = 0;
      v37 = v6;
      v38 = (uint64_t)&v39[v9 * (uint64_t)v5 - v13];
      v29 = 0x10000;
      v30 = a1;
      v31 = 0;
      v28 = &off_24DBF02F0;
      cv::Mat::copyTo((cv::Mat *)&v32, (const cv::_OutputArray *)&v28);
      v15 = v36;
      if (v36)
      {
        do
        {
          v16 = __ldaxr(v15);
          v17 = v16 - 1;
        }
        while (__stlxr(v17, v15));
        if (!v17)
        {
          if (v40)
            (*(void (**)(uint64_t, unsigned int *, cv *, cv *))(*(_QWORD *)v40 + 24))(v40, v36, v37, v35);
          else
            cv::fastFree((void **)v37, v14);
        }
      }
      v35 = 0;
      v38 = 0;
      v39 = 0;
      v37 = 0;
      if (v33 >= 1)
      {
        v25 = 0;
        v26 = v41;
        do
          v26[v25++] = 0;
        while (v25 < v33);
      }
      v36 = 0;
      if (v42 != (cv *)v43)
        cv::fastFree((void **)v42, v14);
    }
    else
    {
      v18 = *a2;
      *(_DWORD *)a1 = *a2 & 0x4FFF | 0x42FF0000;
      *(_DWORD *)(a1 + 4) = 2;
      v19 = a2[8];
      *(_DWORD *)(a1 + 8) = v19;
      v20 = a2[9];
      *(_DWORD *)(a1 + 12) = v20;
      v21 = *((_QWORD *)a2 + 3);
      *(_QWORD *)(a1 + 32) = v21;
      *(_QWORD *)(a1 + 16) = v21;
      v22 = (((v18 >> 3) & 0x1FF) + 1) << ((0xFA50u >> (2 * (v18 & 7))) & 3);
      v23 = v20 * (uint64_t)(int)v22;
      if (a2[1])
        v23 = a2[1];
      v24 = v21 + v23 * v19;
      *(_QWORD *)(a1 + 40) = v24 - v23 + v20 * (uint64_t)(int)v22;
      *(_QWORD *)(a1 + 48) = v24;
      *(_QWORD *)(a1 + 80) = v23;
      *(_QWORD *)(a1 + 88) = v22;
    }
  }
  return a1;
}

void sub_219E6A890(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  cv::Mat::~Mat((cv::Mat *)va, a2);
  _Unwind_Resume(a1);
}

cv::Mat *cv::Mat::Mat(cv::Mat *this, uint64_t a2, int a3)
{
  uint64_t *v4;
  int *v5;
  unsigned int v7;
  uint64_t v8;
  int *v9;
  int v10;
  int v11;
  const cv::Exception *v12;
  int v13;
  int v14;
  unsigned int v15;
  int v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  const cv::Exception *v21;
  unsigned int v22;
  cv *v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  int v28;
  int v29;
  int v30;
  unsigned int *v31;
  uint64_t v32;
  unsigned int v33;
  _QWORD *v34;
  cv *v35;
  unsigned int *v36;
  unsigned int v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  int *v41;
  int v42;
  void *v43;
  unsigned int *v44;
  unsigned int v45;
  unsigned int v46;
  uint64_t v47;
  unint64_t *v48;
  void *__p[2];
  int v51;
  int v52;
  unint64_t v53;
  cv *v54;
  unsigned int *v55;
  cv *v56;
  uint64_t v57;
  char *v58;
  uint64_t v59;
  unint64_t *v60;
  cv *v61;
  _QWORD v62[5];
  int v63[2];
  int v64;
  cv::Mat *v65;
  uint64_t v66;
  _QWORD v67[4];

  v67[3] = *MEMORY[0x24BDAC8D0];
  *((_QWORD *)this + 10) = 0;
  v4 = (uint64_t *)((char *)this + 80);
  *((_QWORD *)this + 8) = (char *)this + 8;
  *((_QWORD *)this + 9) = (char *)this + 80;
  *((_QWORD *)this + 11) = 0;
  *(_DWORD *)this = 1124007936;
  *(_OWORD *)((char *)this + 4) = 0u;
  v5 = (int *)((char *)this + 4);
  *(_OWORD *)((char *)this + 20) = 0u;
  *(_OWORD *)((char *)this + 36) = 0u;
  *((_OWORD *)this + 3) = 0u;
  if (!a2)
    return this;
  *v5 = 2;
  v7 = (0x43160520u >> (((*(_DWORD *)(a2 + 16) >> 2) & 0x3C) + ((*(int *)(a2 + 16) >> 31) & 0x14))) & 7;
  v8 = *(int *)(a2 + 96);
  *v4 = v8;
  v9 = *(int **)(a2 + 48);
  v10 = *(_DWORD *)(a2 + 28);
  if (!v9)
  {
    if (v10)
    {
      std::string::basic_string[abi:ne180100]<0>(v63, "img->dataOrder == IPL_DATA_ORDER_PIXEL");
      std::string::basic_string[abi:ne180100]<0>(v67, "Mat");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
      cv::Exception::Exception(&v51, 4294967081, v63, v67, __p, 493);
      cv::error((cv *)&v51, v21);
    }
    v22 = 8 * *(_DWORD *)(a2 + 8) - 8;
    v16 = (v22 | v7) + 1124007936;
    *(_DWORD *)this = v16;
    v17 = *(_DWORD *)(a2 + 44);
    *((_DWORD *)this + 2) = v17;
    v18 = *(_DWORD *)(a2 + 40);
    *((_DWORD *)this + 3) = v18;
    v23 = *(cv **)(a2 + 88);
    *((_QWORD *)this + 2) = v23;
    *((_QWORD *)this + 4) = v23;
    v19 = (((v22 >> 3) & 0x1FF) + 1) << ((0xFA50u >> (2 * v7)) & 3);
    goto LABEL_18;
  }
  if (v10)
  {
    v11 = *v9;
    if (!*v9)
    {
      std::string::basic_string[abi:ne180100]<0>(v63, "img->dataOrder == IPL_DATA_ORDER_PIXEL || img->roi->coi != 0");
      std::string::basic_string[abi:ne180100]<0>(v67, "Mat");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
      cv::Exception::Exception(&v51, 4294967081, v63, v67, __p, 501);
      cv::error((cv *)&v51, v12);
    }
  }
  else
  {
    v11 = *v9;
    if (!*v9)
    {
LABEL_10:
      v14 = 0;
      v13 = 8 * *(_DWORD *)(a2 + 8) - 8;
      goto LABEL_11;
    }
    v10 = *(_DWORD *)(a2 + 28);
  }
  if (v10 != 1)
    goto LABEL_10;
  v13 = 0;
  v14 = 1;
LABEL_11:
  v15 = v13 + v7;
  v16 = v13 + v7 + 1124007936;
  *(_DWORD *)this = v16;
  v17 = v9[4];
  *((_DWORD *)this + 2) = v17;
  v18 = v9[3];
  *((_DWORD *)this + 3) = v18;
  v19 = (((v15 >> 3) & 0x1FF) + 1) << ((0xFA50u >> (2 * (v15 & 7))) & 3);
  if (v14)
    v20 = *v4 * (v11 - 1) * *(int *)(a2 + 44);
  else
    v20 = 0;
  v24 = *(_QWORD *)(a2 + 88) + v20;
  v4 = (uint64_t *)*((_QWORD *)this + 9);
  v8 = *v4;
  v23 = (cv *)(v24 + *v4 * v9[2] + v9[1] * (uint64_t)(int)v19);
  *((_QWORD *)this + 4) = v23;
  *((_QWORD *)this + 2) = v23;
LABEL_18:
  v25 = (char *)v23 + v8 * (int)v17;
  v26 = (uint64_t)v23 + v8 * (int)(v17 - 1) + (int)v19 * (uint64_t)(int)v18;
  *((_QWORD *)this + 5) = v26;
  *((_QWORD *)this + 6) = v25;
  if (v17 == 1 || (int)v19 * (uint64_t)(int)v18 == v8)
    v28 = 0x4000;
  else
    v28 = 0;
  v29 = v28 | v16;
  *(_DWORD *)this = v29;
  v4[1] = v19;
  if (a3)
  {
    v30 = *((_DWORD *)this + 1);
    v51 = v29;
    v52 = v30;
    v53 = __PAIR64__(v18, v17);
    v31 = (unsigned int *)*((_QWORD *)this + 3);
    v54 = v23;
    v55 = v31;
    v56 = v23;
    v57 = v26;
    v32 = *((_QWORD *)this + 7);
    v58 = v25;
    v59 = v32;
    v60 = &v53;
    v61 = (cv *)v62;
    v62[0] = 0;
    v62[1] = 0;
    if (v31)
    {
      do
        v33 = __ldaxr(v31);
      while (__stlxr(v33 + 1, v31));
      v30 = *v5;
    }
    if (v30 > 2)
    {
      v52 = 0;
      cv::Mat::copySize((cv::Mat *)&v51, this);
    }
    else
    {
      v34 = (_QWORD *)*((_QWORD *)this + 9);
      v35 = v61;
      *(_QWORD *)v61 = *v34;
      *((_QWORD *)v35 + 1) = v34[1];
    }
    v36 = (unsigned int *)*((_QWORD *)this + 3);
    if (v36)
    {
      do
      {
        v37 = __ldaxr(v36);
        v38 = v37 - 1;
      }
      while (__stlxr(v38, v36));
      if (!v38)
        cv::Mat::deallocate(this, (void *)a2);
    }
    *((_QWORD *)this + 2) = 0;
    *((_QWORD *)this + 5) = 0;
    *((_QWORD *)this + 6) = 0;
    *((_QWORD *)this + 4) = 0;
    if (*((int *)this + 1) >= 1)
    {
      v39 = 0;
      v40 = *((_QWORD *)this + 8);
      do
        *(_DWORD *)(v40 + 4 * v39++) = 0;
      while (v39 < *v5);
    }
    *((_QWORD *)this + 3) = 0;
    v41 = *(int **)(a2 + 48);
    if (v41 && (v42 = *v41) != 0 && *(_DWORD *)(a2 + 28) != 1)
    {
      v67[0] = (v42 - 1);
      *(_QWORD *)v63 = v53;
      cv::Mat::create(this, (cv::Mat *)2, v63, v51 & 0xFFF);
      cv::mixChannels((cv *)&v51, (const cv::Mat *)1, (unint64_t)this, (cv::Mat *)1, (unint64_t)v67, (const int *)1);
    }
    else
    {
      v64 = 0x10000;
      v65 = this;
      v66 = 0;
      *(_QWORD *)v63 = &off_24DBF02F0;
      cv::Mat::copyTo((cv::Mat *)&v51, (const cv::_OutputArray *)v63);
    }
    v44 = v55;
    if (v55)
    {
      do
      {
        v45 = __ldaxr(v44);
        v46 = v45 - 1;
      }
      while (__stlxr(v46, v44));
      if (!v46)
      {
        if (v59)
          (*(void (**)(uint64_t, unsigned int *, cv *, cv *))(*(_QWORD *)v59 + 24))(v59, v55, v56, v54);
        else
          cv::fastFree((void **)v56, v43);
      }
    }
    v54 = 0;
    v57 = 0;
    v58 = 0;
    v56 = 0;
    if (v52 >= 1)
    {
      v47 = 0;
      v48 = v60;
      do
        *((_DWORD *)v48 + v47++) = 0;
      while (v47 < v52);
    }
    v55 = 0;
    if (v61 != (cv *)v62)
      cv::fastFree((void **)v61, v43);
  }
  return this;
}

void sub_219E6AE08(_Unwind_Exception *a1, void *a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  cv::Mat::~Mat((cv::Mat *)&a15, a2);
  _Unwind_Resume(a1);
}

void cv::Mat::reserve(cv::Mat *this, unint64_t a2)
{
  const cv::Exception *v4;
  int *v5;
  int v6;
  int v7;
  cv::Mat *v8;
  uint64_t v9;
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  __int16 v15;
  void *v16;
  unsigned int *v17;
  unsigned int v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int *v22;
  unsigned int v23;
  unsigned int *v24;
  unsigned int v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int *v30;
  uint64_t v31;
  cv *v32;
  _QWORD *v33;
  uint64_t v34;
  unsigned int *v35;
  unsigned int v36;
  unsigned int v37;
  uint64_t v38;
  char *v39;
  void *v40;
  int v41;
  void **v42;
  uint64_t v43;
  void *v44[2];
  uint64_t v45;
  unsigned int *v46;
  cv *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  cv *v52;
  uint64_t v53;
  void *__p[2];
  _OWORD v55[4];
  char *v56;
  cv *v57;
  _QWORD v58[5];

  if ((a2 & 0x80000000) != 0)
  {
    std::string::basic_string[abi:ne180100]<0>(v44, "(int)nelems >= 0");
    std::string::basic_string[abi:ne180100]<0>(&v40, "reserve");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
    cv::Exception::Exception(v55, 4294967081, v44, &v40, __p, 581);
    cv::error((cv *)v55, v4);
  }
  if ((*((_BYTE *)this + 1) & 0x80) != 0
    || *((_QWORD *)this + 2) + **((_QWORD **)this + 9) * a2 > *((_QWORD *)this + 6))
  {
    v5 = (int *)*((_QWORD *)this + 8);
    v6 = *v5;
    if (*v5 < a2)
    {
      if ((int)a2 <= 1)
        v7 = 1;
      else
        v7 = a2;
      *v5 = v7;
      v8 = (cv::Mat *)*((unsigned int *)this + 1);
      if ((int)v8 >= 3)
      {
        v9 = 1;
        v10 = v5;
        v11 = *((unsigned int *)this + 1);
        do
        {
          v12 = *v10++;
          v9 *= v12;
          --v11;
        }
        while (v11);
      }
      else
      {
        v9 = *((int *)this + 3) * (uint64_t)*((int *)this + 2);
      }
      if ((int)v8 < 1)
        v13 = 0;
      else
        v13 = *(_QWORD *)(*((_QWORD *)this + 9) + 8 * ((_DWORD)v8 - 1));
      v14 = v13 * v9;
      if (v14 <= 0x3F)
      {
        *v5 = (v14 + 63) * a2 / v14;
        v8 = (cv::Mat *)*((unsigned int *)this + 1);
      }
      v15 = *(_DWORD *)this & 0xFFF;
      v56 = (char *)v55 + 8;
      v57 = (cv *)v58;
      v58[0] = 0;
      v58[1] = 0;
      LODWORD(v55[0]) = 1124007936;
      memset((char *)v55 + 4, 0, 48);
      v55[3] = 0u;
      cv::Mat::create((cv::Mat *)v55, v8, v5, v15);
      **((_DWORD **)this + 8) = v6;
      if (v6 >= 1)
      {
        __p[0] = (void *)0x7FFFFFFF80000000;
        cv::Mat::Mat((uint64_t)v44, (uint64_t)v55);
        v41 = 0x10000;
        v42 = v44;
        v43 = 0;
        v40 = &off_24DBF02F0;
        cv::Mat::copyTo(this, (const cv::_OutputArray *)&v40);
        v17 = v46;
        if (v46)
        {
          do
          {
            v18 = __ldaxr(v17);
            v19 = v18 - 1;
          }
          while (__stlxr(v19, v17));
          if (!v19)
          {
            if (v50)
              (*(void (**)(uint64_t, unsigned int *, cv *, uint64_t))(*(_QWORD *)v50 + 24))(v50, v46, v47, v45);
            else
              cv::fastFree((void **)v47, v16);
          }
        }
        v45 = 0;
        v47 = 0;
        v48 = 0;
        v49 = 0;
        if (SHIDWORD(v44[0]) >= 1)
        {
          v20 = 0;
          v21 = v51;
          do
            *(_DWORD *)(v21 + 4 * v20++) = 0;
          while (v20 < SHIDWORD(v44[0]));
        }
        v46 = 0;
        if (v52 != (cv *)&v53)
          cv::fastFree((void **)v52, v16);
      }
      if (v55 == (_OWORD *)this)
      {
        v31 = *((_QWORD *)this + 2);
        v30 = (unsigned int *)*((_QWORD *)this + 3);
        goto LABEL_48;
      }
      v22 = (unsigned int *)*((_QWORD *)&v55[1] + 1);
      if (*((_QWORD *)&v55[1] + 1))
      {
        do
          v23 = __ldaxr(v22);
        while (__stlxr(v23 + 1, v22));
      }
      v24 = (unsigned int *)*((_QWORD *)this + 3);
      if (v24)
      {
        do
        {
          v25 = __ldaxr(v24);
          v26 = v25 - 1;
        }
        while (__stlxr(v26, v24));
        if (!v26)
          cv::Mat::deallocate(this, v16);
      }
      *((_QWORD *)this + 2) = 0;
      *((_QWORD *)this + 5) = 0;
      *((_QWORD *)this + 6) = 0;
      *((_QWORD *)this + 4) = 0;
      if (*((int *)this + 1) <= 0)
      {
        *((_QWORD *)this + 3) = 0;
        *(_DWORD *)this = v55[0];
      }
      else
      {
        v27 = 0;
        v28 = *((_QWORD *)this + 8);
        do
        {
          *(_DWORD *)(v28 + 4 * v27++) = 0;
          v29 = *((int *)this + 1);
        }
        while (v27 < v29);
        *((_QWORD *)this + 3) = 0;
        *(_DWORD *)this = v55[0];
        if ((int)v29 > 2)
          goto LABEL_46;
      }
      if (SDWORD1(v55[0]) <= 2)
      {
        *((_DWORD *)this + 1) = DWORD1(v55[0]);
        *((_QWORD *)this + 1) = *((_QWORD *)&v55[0] + 1);
        v32 = v57;
        v33 = (_QWORD *)*((_QWORD *)this + 9);
        *v33 = *(_QWORD *)v57;
        v33[1] = *((_QWORD *)v32 + 1);
LABEL_47:
        v31 = *(_QWORD *)&v55[1];
        v34 = *((_QWORD *)&v55[3] + 1);
        *((_QWORD *)this + 2) = *(_QWORD *)&v55[1];
        *(_OWORD *)((char *)this + 40) = *(_OWORD *)((char *)&v55[2] + 8);
        v35 = (unsigned int *)*((_QWORD *)&v55[1] + 1);
        *(_OWORD *)((char *)this + 24) = *(_OWORD *)((char *)&v55[1] + 8);
        *((_QWORD *)this + 7) = v34;
        v30 = v35;
LABEL_48:
        **((_DWORD **)this + 8) = v6;
        *((_QWORD *)this + 5) = v31 + **((_QWORD **)this + 9) * v6;
        if (v30)
        {
          do
          {
            v36 = __ldaxr(v30);
            v37 = v36 - 1;
          }
          while (__stlxr(v37, v30));
          if (!v37)
          {
            if (*((_QWORD *)&v55[3] + 1))
              (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD))(**((_QWORD **)&v55[3] + 1) + 24))(*((_QWORD *)&v55[3] + 1), *((_QWORD *)&v55[1] + 1), *(_QWORD *)&v55[2], *(_QWORD *)&v55[1]);
            else
              cv::fastFree(*(void ***)&v55[2], v16);
          }
        }
        *(_QWORD *)&v55[1] = 0;
        memset(&v55[2], 0, 24);
        if (SDWORD1(v55[0]) >= 1)
        {
          v38 = 0;
          v39 = v56;
          do
            *(_DWORD *)&v39[4 * v38++] = 0;
          while (v38 < SDWORD1(v55[0]));
        }
        *((_QWORD *)&v55[1] + 1) = 0;
        if (v57 != (cv *)v58)
          cv::fastFree((void **)v57, v16);
        return;
      }
LABEL_46:
      cv::Mat::copySize(this, (const cv::Mat *)v55);
      goto LABEL_47;
    }
  }
}

void sub_219E6B2FC(_Unwind_Exception *a1, void *a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,char a37)
{
  cv::Mat::~Mat((cv::Mat *)&a37, a2);
  _Unwind_Resume(a1);
}

void cv::Mat::resize(cv::Mat *this, unint64_t a2)
{
  int v2;
  int v3;
  int v4;
  const cv::Exception *v6;
  uint64_t v7;
  void *__p[2];
  void *v9[2];
  void *v10[2];
  _BYTE v11[120];

  v2 = a2;
  v3 = **((_DWORD **)this + 8);
  v4 = a2 - v3;
  if ((_DWORD)a2 != v3)
  {
    if ((a2 & 0x80000000) != 0)
    {
      std::string::basic_string[abi:ne180100]<0>(v10, "(int)nelems >= 0");
      std::string::basic_string[abi:ne180100]<0>(v9, "resize");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
      cv::Exception::Exception(v11, 4294967081, v10, v9, __p, 615);
      cv::error((cv *)v11, v6);
    }
    if ((*((_BYTE *)this + 1) & 0x80) != 0
      || (v7 = **((_QWORD **)this + 9), *((_QWORD *)this + 2) + v7 * a2 > *((_QWORD *)this + 6)))
    {
      cv::Mat::reserve(this, a2);
      v7 = **((_QWORD **)this + 9);
    }
    **((_DWORD **)this + 8) = v2;
    *((_QWORD *)this + 5) += v7 * v4;
  }
}

void sub_219E6B4A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

cv *cv::cvarrToMat@<X0>(cv *this@<X0>, const void *a2@<X1>, int a3@<W3>, uint64_t a4@<X8>)
{
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  const cv::Exception *v8;
  int v9;
  unsigned int v10;
  const cv::Exception *v11;
  uint64_t v12;
  int *v13;
  const cv::Exception *v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *__p[2];
  void *v20[2];
  void *v21[2];
  int v22[30];
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  if (!this)
  {
    *(_QWORD *)(a4 + 80) = 0;
    *(_QWORD *)(a4 + 64) = a4 + 8;
    *(_QWORD *)(a4 + 72) = a4 + 80;
    *(_QWORD *)(a4 + 88) = 0;
    *(_DWORD *)a4 = 1124007936;
    *(_OWORD *)(a4 + 4) = 0u;
    *(_OWORD *)(a4 + 20) = 0u;
    *(_OWORD *)(a4 + 36) = 0u;
    *(_OWORD *)(a4 + 48) = 0u;
    return this;
  }
  v5 = (uint64_t)this;
  v6 = *(_DWORD *)this;
  v7 = *(_DWORD *)this & 0xFFFF0000;
  if (v7 == 1111687168)
  {
    if (!*((_QWORD *)this + 3))
      goto LABEL_21;
    return cv::Mat::Mat((cv *)a4, (uint64_t)this, (int)a2);
  }
  else
  {
    if (v7 == 1111621632)
    {
      if (*((int *)this + 9) >= 1 && *((int *)this + 8) >= 1 && *((_QWORD *)this + 3))
        return (cv *)cv::Mat::Mat(a4, (int *)this, (char)a2);
LABEL_21:
      std::string::basic_string[abi:ne180100]<0>(v21, "Unknown array type");
      std::string::basic_string[abi:ne180100]<0>(v20, "cvarrToMat");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
      cv::Exception::Exception(v22, 4294967291, v21, v20, __p, 708);
      cv::error((cv *)v22, v11);
    }
    if (v6 != 144)
    {
      if (v7 != 1117323264)
        goto LABEL_21;
      if (*((int *)this + 10) < 1
        || (((v6 >> 3) & 0x1FF) + 1) << ((0xFA50u >> (2 * (v6 & 7))) & 3) != *((_DWORD *)this + 11))
      {
        std::string::basic_string[abi:ne180100]<0>(v21, "seq->total > 0 && CV_ELEM_SIZE(seq->flags) == seq->elem_size");
        std::string::basic_string[abi:ne180100]<0>(v20, "cvarrToMat");
        std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
        cv::Exception::Exception(v22, 4294967081, v21, v20, __p, 701);
        cv::error((cv *)v22, v8);
      }
      if ((_DWORD)a2)
      {
        v9 = *((_DWORD *)this + 10);
        v10 = *(_DWORD *)this;
      }
      else
      {
        v12 = *((_QWORD *)this + 11);
        v9 = *((_DWORD *)this + 10);
        v10 = *(_DWORD *)this;
        if (*(_QWORD *)(v12 + 8) == v12)
        {
          v15 = *((_DWORD *)this + 10);
          v16 = *(_QWORD *)(v12 + 24);
          *(_DWORD *)(a4 + 8) = v9;
          *(_DWORD *)(a4 + 12) = 1;
          *(_QWORD *)(a4 + 16) = v16;
          *(_QWORD *)(a4 + 24) = 0;
          v17 = (((v10 >> 3) & 0x1FF) + 1) << ((0xFA50u >> (2 * (v10 & 7))) & 3);
          *(_QWORD *)(a4 + 80) = v17;
          *(_QWORD *)(a4 + 64) = a4 + 8;
          *(_QWORD *)(a4 + 72) = a4 + 80;
          *(_DWORD *)a4 = v10 & 0xFFF | 0x42FF4000;
          *(_DWORD *)(a4 + 4) = 2;
          *(_QWORD *)(a4 + 88) = v17;
          v18 = v16 + (int)v17 * (uint64_t)v15;
          *(_QWORD *)(a4 + 48) = v18;
          *(_QWORD *)(a4 + 56) = 0;
          *(_QWORD *)(a4 + 32) = v16;
          *(_QWORD *)(a4 + 40) = v18;
          return this;
        }
      }
      *(_QWORD *)(a4 + 80) = 0;
      *(_QWORD *)(a4 + 64) = a4 + 8;
      *(_QWORD *)(a4 + 72) = a4 + 80;
      *(_QWORD *)(a4 + 88) = 0;
      *(_DWORD *)a4 = 1124007936;
      *(_OWORD *)(a4 + 4) = 0u;
      *(_OWORD *)(a4 + 20) = 0u;
      *(_OWORD *)(a4 + 36) = 0u;
      *(_OWORD *)(a4 + 48) = 0u;
      v22[0] = v9;
      v22[1] = 1;
      cv::Mat::create((cv::Mat *)a4, (cv::Mat *)2, v22, v10 & 0xFFF);
      return (cv *)cvCvtSeqToArray(v5, *(char **)(a4 + 16), 0x3FFFFFFF00000000);
    }
    if (!*((_QWORD *)this + 11))
      goto LABEL_21;
    if (!a3)
    {
      v13 = (int *)*((_QWORD *)this + 6);
      if (v13)
      {
        if (*v13 >= 1)
        {
          std::string::basic_string[abi:ne180100]<0>(v21, "COI is not supported by the function");
          std::string::basic_string[abi:ne180100]<0>(v20, "cvarrToMat");
          std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
          cv::Exception::Exception(v22, 4294967272, v21, v20, __p, 695);
          cv::error((cv *)v22, v14);
        }
      }
    }
    return cv::Mat::Mat((cv::Mat *)a4, (uint64_t)this, (int)a2);
  }
}

void sub_219E6B978(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,char a28)
{
  cv::Exception::~Exception((cv::Exception *)&a28);
  if (a15 < 0)
    operator delete(__p);
  if (a21 < 0)
    operator delete(a16);
  if (a27 < 0)
    operator delete(a22);
  _Unwind_Resume(a1);
}

uint64_t cv::Mat::locateROI(uint64_t result, _DWORD *a2, _DWORD *a3)
{
  int v3;
  const cv::Exception *v4;
  BOOL v5;
  int v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  int v17;
  unint64_t v18;
  void *__p[2];
  void *v20[2];
  void *v21[2];
  _BYTE v22[120];

  v3 = *(_DWORD *)(result + 4);
  if (v3 > 2 || !**(_QWORD **)(result + 72))
  {
    std::string::basic_string[abi:ne180100]<0>(v21, "dims <= 2 && step[0] > 0");
    std::string::basic_string[abi:ne180100]<0>(v20, "locateROI");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
    cv::Exception::Exception(v22, 4294967081, v21, v20, __p, 714);
    cv::error((cv *)v22, v4);
  }
  v5 = __OFSUB__(v3, 1);
  v6 = v3 - 1;
  if (v6 < 0 != v5)
    v7 = 0;
  else
    v7 = *(_QWORD *)(*(_QWORD *)(result + 72) + 8 * v6);
  v8 = *(_QWORD *)(result + 16);
  v9 = *(_QWORD *)(result + 32);
  v10 = *(_QWORD *)(result + 40);
  v11 = v8 - v9;
  if (v8 == v9)
  {
    LODWORD(v13) = 0;
  }
  else
  {
    v12 = **(_QWORD **)(result + 72);
    v13 = v11 / v12;
    v11 = (v11 - (int)(v11 / v12) * v12) / v7;
  }
  *a3 = v11;
  a3[1] = v13;
  v14 = v10 - v9;
  v15 = *(int *)(result + 12) + (uint64_t)(int)v11;
  v16 = (v14 - v7 * v15) / **(_QWORD **)(result + 72);
  v17 = *(_DWORD *)(result + 8) + v13;
  if ((int)v16 + 1 > v17)
    v17 = v16 + 1;
  a2[1] = v17;
  v18 = (v14 - *(_QWORD *)(result + 80) * (v17 - 1)) / v7;
  if ((int)v15 > (int)v18)
    LODWORD(v18) = v15;
  *a2 = v18;
  return result;
}

void sub_219E6BB88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

cv::Mat *cv::Mat::adjustROI(cv::Mat *this, int a2, int a3, int a4, int a5)
{
  int v10;
  const cv::Exception *v11;
  BOOL v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  _DWORD *v19;
  unsigned int v20;
  void *__p[2];
  void *v23[2];
  void *v24[2];
  int v25[30];

  v10 = *((_DWORD *)this + 1);
  if (v10 > 2 || !**((_QWORD **)this + 9))
  {
    std::string::basic_string[abi:ne180100]<0>(v24, "dims <= 2 && step[0] > 0");
    std::string::basic_string[abi:ne180100]<0>(v23, "adjustROI");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
    cv::Exception::Exception(v25, 4294967081, v24, v23, __p, 735);
    cv::error((cv *)v25, v11);
  }
  *(_QWORD *)v25 = 0;
  v24[0] = 0;
  v12 = __OFSUB__(v10, 1);
  v13 = v10 - 1;
  if (v13 < 0 != v12)
    v14 = 0;
  else
    v14 = *(_QWORD *)(*((_QWORD *)this + 9) + 8 * v13);
  cv::Mat::locateROI((uint64_t)this, v25, v24);
  v15 = HIDWORD(v24[0]) + a3 + *((_DWORD *)this + 2);
  if (v25[1] < v15)
    v15 = v25[1];
  v16 = LODWORD(v24[0]) + a5 + *((_DWORD *)this + 3);
  v17 = (HIDWORD(v24[0]) - a2) & ~((HIDWORD(v24[0]) - a2) >> 31);
  v18 = (LODWORD(v24[0]) - a4) & ~((LODWORD(v24[0]) - a4) >> 31);
  if (v25[0] < v16)
    v16 = v25[0];
  *((_QWORD *)this + 2) += *((_QWORD *)this + 10) * (v17 - HIDWORD(v24[0])) + v14 * (v18 - LODWORD(v24[0]));
  *((_DWORD *)this + 2) = v15 - v17;
  *((_DWORD *)this + 3) = v16 - v18;
  v19 = (_DWORD *)*((_QWORD *)this + 8);
  *v19 = v15 - v17;
  v19[1] = *((_DWORD *)this + 3);
  if (v14 * *((int *)this + 3) == **((_QWORD **)this + 9) || *((_DWORD *)this + 2) == 1)
    v20 = *(_DWORD *)this | 0x4000;
  else
    v20 = *(_DWORD *)this & 0xFFFFBFFF;
  *(_DWORD *)this = v20;
  return this;
}

void sub_219E6BDCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

void cv::Mat::reshape(cv::Mat *this@<X0>, signed int a2@<W1>, int a3@<W2>, unsigned int *a4@<X8>)
{
  int v4;
  __int128 v8;
  __int128 v9;
  unsigned int v10;
  int v11;
  unsigned int v12;
  _QWORD *v13;
  _QWORD *v14;
  _BOOL4 v15;
  int v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  const cv::Exception *v20;
  int v21;
  BOOL v22;
  int v23;
  const cv::Exception *v24;
  int v25;
  const cv::Exception *v26;
  const cv::Exception *v27;
  const cv::Exception *v28;
  unsigned int v29;
  unsigned int v30;
  void *__p[2];
  void *v32[2];
  void *v33[2];
  _BYTE v34[120];

  v4 = a3;
  v8 = *(_OWORD *)this;
  *(_OWORD *)a4 = *(_OWORD *)this;
  *((_QWORD *)a4 + 2) = *((_QWORD *)this + 2);
  v9 = *(_OWORD *)((char *)this + 24);
  *(_OWORD *)(a4 + 6) = v9;
  *(_OWORD *)(a4 + 10) = *(_OWORD *)((char *)this + 40);
  *((_QWORD *)a4 + 7) = *((_QWORD *)this + 7);
  *((_QWORD *)a4 + 8) = a4 + 2;
  *((_QWORD *)a4 + 10) = 0;
  *((_QWORD *)a4 + 9) = a4 + 20;
  *((_QWORD *)a4 + 11) = 0;
  if ((_QWORD)v9)
  {
    do
      v10 = __ldaxr((unsigned int *)v9);
    while (__stlxr(v10 + 1, (unsigned int *)v9));
    v11 = *((_DWORD *)this + 1);
  }
  else
  {
    v11 = DWORD1(v8);
  }
  v12 = ((v8 >> 3) & 0x1FF) + 1;
  if (v11 <= 2)
  {
    v13 = (_QWORD *)*((_QWORD *)this + 9);
    v14 = (_QWORD *)*((_QWORD *)a4 + 9);
    *v14 = *v13;
    v14[1] = v13[1];
    v15 = a3 == 0;
    goto LABEL_14;
  }
  a4[1] = 0;
  cv::Mat::copySize((cv::Mat *)a4, this);
  v16 = *((_DWORD *)this + 1);
  v15 = v4 == 0;
  if (!v4 && a2 && v16 >= 3)
  {
    v17 = (v16 - 1);
    if (!((int)(*(_DWORD *)(*((_QWORD *)this + 8) + 4 * v17) * v12) % a2))
    {
      v18 = *a4;
      v19 = 8 * a2 - 8;
      *a4 = *a4 & 0xFFFFF007 | v19;
      *(_QWORD *)(*((_QWORD *)a4 + 9) + 8 * v17) = (((v19 >> 3) & 0x1FF) + 1) << ((0xFA50u >> (2 * (v18 & 7))) & 3);
      *(_DWORD *)(*((_QWORD *)a4 + 8) + 4 * v17) = (int)(*(_DWORD *)(*((_QWORD *)a4 + 8) + 4 * v17) * v12) / a2;
      return;
    }
LABEL_13:
    std::string::basic_string[abi:ne180100]<0>(v33, "dims <= 2");
    std::string::basic_string[abi:ne180100]<0>(v32, "reshape");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
    cv::Exception::Exception(v34, 4294967081, v33, v32, __p, 797);
    cv::error((cv *)v34, v20);
  }
  if (v16 >= 3)
    goto LABEL_13;
LABEL_14:
  if (!a2)
    a2 = v12;
  v21 = *((_DWORD *)this + 3) * v12;
  if (a2 > v21)
  {
    if (!v15)
    {
LABEL_25:
      v23 = *((_DWORD *)this + 2);
      if (v4 != v23)
      {
        if ((*((_BYTE *)this + 1) & 0x40) == 0)
        {
          std::string::basic_string[abi:ne180100]<0>(v33, "The matrix is not continuous, thus its number of rows can not be changed");
          std::string::basic_string[abi:ne180100]<0>(v32, "reshape");
          std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
          cv::Exception::Exception(v34, 4294967283, v33, v32, __p, 812);
          cv::error((cv *)v34, v24);
        }
        v25 = v23 * v21;
        if (v4 > v25)
        {
          std::string::basic_string[abi:ne180100]<0>(v33, "Bad new number of rows");
          std::string::basic_string[abi:ne180100]<0>(v32, "reshape");
          std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
          cv::Exception::Exception(v34, 4294967085, v33, v32, __p, 815);
          cv::error((cv *)v34, v26);
        }
        v21 = v25 / v4;
        if (v25 / v4 * v4 != v25)
        {
          std::string::basic_string[abi:ne180100]<0>(v33, "The total number of matrix elements is not divisible by the new number of rows");
          std::string::basic_string[abi:ne180100]<0>(v32, "reshape");
          std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
          cv::Exception::Exception(v34, 4294967291, v33, v32, __p, 821);
          cv::error((cv *)v34, v27);
        }
        a4[2] = v4;
        **((_QWORD **)a4 + 9) = ((0x88442211uLL >> (4 * (*(_DWORD *)this & 7u))) & 0xF) * v21;
      }
      goto LABEL_33;
    }
    goto LABEL_23;
  }
  if (v21 % a2)
    v22 = v15;
  else
    v22 = 0;
  if (v22)
LABEL_23:
    v4 = *((_DWORD *)this + 2) * v21 / a2;
  if (v4)
    goto LABEL_25;
LABEL_33:
  if (v21 / a2 * a2 != v21)
  {
    std::string::basic_string[abi:ne180100]<0>(v33, "The total width is not divisible by the new number of channels");
    std::string::basic_string[abi:ne180100]<0>(v32, "reshape");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
    cv::Exception::Exception(v34, 4294967281, v33, v32, __p, 831);
    cv::error((cv *)v34, v28);
  }
  a4[3] = v21 / a2;
  v29 = *a4;
  v30 = 8 * a2 - 8;
  *a4 = *a4 & 0xFFFFF007 | v30;
  *(_QWORD *)(*((_QWORD *)a4 + 9) + 8) = (((v30 >> 3) & 0x1FF) + 1) << ((0xFA50u >> (2 * (v29 & 7))) & 3);
}

void sub_219E6C354(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Mat *v27;
  void *v29;

  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  cv::Mat::~Mat(v27, v29);
  _Unwind_Resume(a1);
}

uint64_t cv::Mat::checkVector(cv::Mat *this, int a2, int a3, char a4)
{
  unint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  BOOL v9;
  int *v10;

  v4 = *(unsigned int *)this;
  if (a3 >= 1 && (*(_DWORD *)this & 7) != a3 || (v4 & 0x4000) == 0 && (a4 & 1) != 0)
    return 0xFFFFFFFFLL;
  v5 = *((_DWORD *)this + 1);
  if (v5 == 3)
  {
    if ((v4 & 0xFF8) == 0)
    {
      v10 = (int *)*((_QWORD *)this + 8);
      if (v10[2] == a2
        && (*v10 == 1 || v10[1] == 1)
        && ((v4 & 0x4000) != 0
         || *(_QWORD *)(*((_QWORD *)this + 9) + 8) == *(_QWORD *)(*((_QWORD *)this + 9) + 16) * a2))
      {
        v7 = *v10 * (uint64_t)v10[1];
        v6 = v10[2];
        return (v7 * v6 + v7 * v6 * ((v4 >> 3) & 0x1FF)) / a2;
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (v5 != 2)
    return 0xFFFFFFFFLL;
  v6 = *((int *)this + 2);
  if (((_DWORD)v6 == 1 || (LODWORD(v7) = *((_DWORD *)this + 3), (_DWORD)v7 == 1))
    && (LODWORD(v7) = *((_DWORD *)this + 3), ((v4 >> 3) & 0x1FF) + 1 == a2)
    || (result = 0xFFFFFFFFLL, (v4 & 0xFF8) == 0) && (v9 = (_DWORD)v7 == a2, LODWORD(v7) = a2, v9))
  {
    v7 = (int)v7;
    return (v7 * v6 + v7 * v6 * ((v4 >> 3) & 0x1FF)) / a2;
  }
  return result;
}

double cv::scalarToRawData(uint64_t a1, uint64_t a2, unint64_t a3, int a4)
{
  unsigned int v4;
  const cv::Exception *v5;
  uint64_t v6;
  uint64_t v7;
  double result;
  int v9;
  const cv::Exception *v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *__p[2];
  void *v21[2];
  void *v22[2];
  _BYTE v23[120];

  v4 = (a3 >> 3) & 0x1FF;
  if (v4 >= 4)
  {
    std::string::basic_string[abi:ne180100]<0>(v22, "cn <= 4");
    std::string::basic_string[abi:ne180100]<0>(v21, "scalarToRawData");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
    cv::Exception::Exception(v23, 4294967081, v22, v21, __p, 855);
    cv::error((cv *)v23, v5);
  }
  v6 = v4 + 1;
  switch(a3 & 7)
  {
    case 0uLL:
      v7 = 0;
      do
      {
        result = rint(*(double *)(a1 + 8 * v7));
        v9 = (uint64_t)result & ~((int)(uint64_t)result >> 31);
        if (v9 >= 255)
          LOBYTE(v9) = -1;
        *(_BYTE *)(a2 + v7++) = v9;
      }
      while (v6 != v7);
      if ((int)v6 < a4)
      {
        do
        {
          *(_BYTE *)(a2 + v7) = *(_BYTE *)((~(a3 >> 3) | 0xFFFFFFFFFFFFFE00) + a2 + v7);
          ++v7;
        }
        while (v7 < a4);
      }
      break;
    case 1uLL:
      v16 = 0;
      do
      {
        result = rint(*(double *)(a1 + 8 * v16));
        v17 = (uint64_t)result;
        if ((int)(uint64_t)result <= -128)
          LODWORD(v17) = -128;
        if ((int)v17 >= 127)
          LOBYTE(v17) = 127;
        *(_BYTE *)(a2 + v16++) = v17;
      }
      while (v6 != v16);
      if ((int)v6 < a4)
      {
        do
        {
          *(_BYTE *)(a2 + v16) = *(_BYTE *)((~(a3 >> 3) | 0xFFFFFFFFFFFFFE00) + a2 + v16);
          ++v16;
        }
        while (v16 < a4);
      }
      break;
    case 2uLL:
      v11 = 0;
      do
      {
        result = rint(*(double *)(a1 + 8 * v11));
        v12 = (uint64_t)result & ~((int)(uint64_t)result >> 31);
        if (v12 >= 0xFFFF)
          LOWORD(v12) = -1;
        *(_WORD *)(a2 + 2 * v11++) = v12;
      }
      while (v6 != v11);
      if ((int)v6 < a4)
      {
        do
        {
          *(_WORD *)(a2 + 2 * v11) = *(_WORD *)(a2 - 2 * ((a3 >> 3) & 0x1FF) - 2 + 2 * v11);
          ++v11;
        }
        while (v11 < a4);
      }
      break;
    case 3uLL:
      v13 = 0;
      do
      {
        result = rint(*(double *)(a1 + 8 * v13));
        v14 = (uint64_t)result;
        if ((int)(uint64_t)result <= -32768)
          LODWORD(v14) = -32768;
        if ((int)v14 >= 0x7FFF)
          LOWORD(v14) = 0x7FFF;
        *(_WORD *)(a2 + 2 * v13++) = v14;
      }
      while (v6 != v13);
      if ((int)v6 < a4)
      {
        do
        {
          *(_WORD *)(a2 + 2 * v13) = *(_WORD *)(a2 - 2 * ((a3 >> 3) & 0x1FF) - 2 + 2 * v13);
          ++v13;
        }
        while (v13 < a4);
      }
      break;
    case 4uLL:
      v15 = 0;
      do
      {
        result = rint(*(double *)(a1 + 8 * v15));
        *(_DWORD *)(a2 + 4 * v15++) = (uint64_t)result;
      }
      while (v6 != v15);
      if ((int)v6 < a4)
      {
        do
        {
          *(_DWORD *)(a2 + 4 * v15) = *(_DWORD *)(a2 - 4 * ((a3 >> 3) & 0x1FF) - 4 + 4 * v15);
          ++v15;
        }
        while (v15 < a4);
      }
      break;
    case 5uLL:
      v18 = 0;
      do
      {
        result = *(double *)(a1 + 8 * v18);
        *(float *)&result = result;
        *(_DWORD *)(a2 + 4 * v18++) = LODWORD(result);
      }
      while (v6 != v18);
      if ((int)v6 < a4)
      {
        do
        {
          LODWORD(result) = *(_DWORD *)(a2 - 4 * ((a3 >> 3) & 0x1FF) - 4 + 4 * v18);
          *(_DWORD *)(a2 + 4 * v18++) = LODWORD(result);
        }
        while (v18 < a4);
      }
      break;
    case 6uLL:
      v19 = 0;
      do
      {
        result = *(double *)(a1 + 8 * v19);
        *(double *)(a2 + 8 * v19++) = result;
      }
      while (v6 != v19);
      if ((int)v6 < a4)
      {
        do
        {
          result = *(double *)(a2 - 8 * ((a3 >> 3) & 0x1FF) - 8 + 8 * v19);
          *(double *)(a2 + 8 * v19++) = result;
        }
        while (v19 < a4);
      }
      break;
    default:
      std::string::basic_string[abi:ne180100]<0>(v22, "");
      std::string::basic_string[abi:ne180100]<0>(v21, "scalarToRawData");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
      cv::Exception::Exception(v23, 4294967086, v22, v21, __p, 922);
      cv::error((cv *)v23, v10);
  }
  return result;
}

void sub_219E6C910(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

uint64_t cv::_InputArray::_InputArray(uint64_t this, const cv::Mat *a2)
{
  *(_QWORD *)this = &off_24DBF0280;
  *(_DWORD *)(this + 8) = 0x10000;
  *(_QWORD *)(this + 16) = a2;
  *(_QWORD *)(this + 24) = 0;
  return this;
}

uint64_t cv::_InputArray::_InputArray(uint64_t result, uint64_t a2)
{
  *(_QWORD *)result = &off_24DBF0280;
  *(_DWORD *)(result + 8) = 327680;
  *(_QWORD *)(result + 16) = a2;
  *(_QWORD *)(result + 24) = 0;
  return result;
}

double cv::_InputArray::_InputArray(cv::_InputArray *this, const double *a2)
{
  double result;

  *(_QWORD *)this = &off_24DBF0280;
  *((_DWORD *)this + 2) = -1073610746;
  *((_QWORD *)this + 2) = a2;
  *(_QWORD *)&result = 0x100000001;
  *((_QWORD *)this + 3) = 0x100000001;
  return result;
}

void cv::_InputArray::getMat(cv::_InputArray *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v6;
  uint64_t v7;
  const cv::Exception *v8;
  int v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const cv::Exception *v16;
  uint64_t *v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  _QWORD *v23;
  const cv::Exception *v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const cv::Exception *v29;
  const cv::Exception *v30;
  const cv::Exception *v31;
  uint64_t *v32;
  uint64_t v33;
  const cv::Exception *v34;
  __int128 v35;
  unsigned int v36;
  _QWORD *v37;
  _QWORD *v38;
  __int128 v39;
  unsigned int v40;
  uint64_t v41;
  uint64_t v42;
  void *__p[2];
  void *v44[2];
  void *v45[2];
  _DWORD v46[30];

  HIDWORD(v6) = (*(uint64_t (**)(cv::_InputArray *))(*(_QWORD *)this + 40))(this);
  LODWORD(v6) = HIDWORD(v6);
  switch((v6 >> 16))
  {
    case 0u:
      goto LABEL_36;
    case 1u:
      v7 = *((_QWORD *)this + 2);
      if ((a2 & 0x80000000) != 0)
      {
        *(_OWORD *)a3 = *(_OWORD *)v7;
        *(_QWORD *)(a3 + 16) = *(_QWORD *)(v7 + 16);
        v39 = *(_OWORD *)(v7 + 24);
        *(_OWORD *)(a3 + 24) = v39;
        *(_OWORD *)(a3 + 40) = *(_OWORD *)(v7 + 40);
        *(_QWORD *)(a3 + 56) = *(_QWORD *)(v7 + 56);
        *(_QWORD *)(a3 + 64) = a3 + 8;
        *(_QWORD *)(a3 + 80) = 0;
        *(_QWORD *)(a3 + 72) = a3 + 80;
        *(_QWORD *)(a3 + 88) = 0;
        if ((_QWORD)v39)
        {
          do
            v40 = __ldaxr((unsigned int *)v39);
          while (__stlxr(v40 + 1, (unsigned int *)v39));
        }
        if (*(int *)(v7 + 4) > 2)
        {
LABEL_37:
          *(_DWORD *)(a3 + 4) = 0;
          cv::Mat::copySize((cv::Mat *)a3, (const cv::Mat *)v7);
        }
        else
        {
          v37 = *(_QWORD **)(v7 + 72);
LABEL_30:
          v38 = *(_QWORD **)(a3 + 72);
          *v38 = *v37;
          v38[1] = v37[1];
        }
      }
      else
      {
        v46[0] = a2;
        v46[1] = a2 + 1;
        v45[0] = (void *)0x7FFFFFFF80000000;
        cv::Mat::Mat(a3, v7);
      }
      return;
    case 2u:
      if ((a2 & 0x80000000) == 0)
      {
        std::string::basic_string[abi:ne180100]<0>(v45, "i < 0");
        std::string::basic_string[abi:ne180100]<0>(v44, "getMat");
        std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
        cv::Exception::Exception(v46, 4294967081, v45, v44, __p, 967);
        cv::error((cv *)v46, v8);
      }
      v9 = *((_DWORD *)this + 6);
      v10 = *((int *)this + 7);
      v11 = *((_DWORD *)this + 2);
      v12 = *((_QWORD *)this + 2);
      *(_DWORD *)(a3 + 8) = v10;
      *(_DWORD *)(a3 + 12) = v9;
      *(_QWORD *)(a3 + 16) = v12;
      *(_QWORD *)(a3 + 24) = 0;
      v13 = (((v11 >> 3) & 0x1FF) + 1) << ((0xFA50u >> (2 * (v11 & 7))) & 3);
      v14 = (int)v13 * (uint64_t)v9;
      *(_QWORD *)(a3 + 80) = v14;
      *(_QWORD *)(a3 + 64) = a3 + 8;
      *(_QWORD *)(a3 + 72) = a3 + 80;
      *(_DWORD *)a3 = v11 & 0xFFF | 0x42FF4000;
      *(_DWORD *)(a3 + 4) = 2;
      *(_QWORD *)(a3 + 88) = v13;
      v15 = v12 + v14 * v10;
      *(_QWORD *)(a3 + 48) = v15;
      *(_QWORD *)(a3 + 56) = 0;
      *(_QWORD *)(a3 + 32) = v12;
      *(_QWORD *)(a3 + 40) = v15;
      return;
    case 3u:
      if ((a2 & 0x80000000) == 0)
      {
        std::string::basic_string[abi:ne180100]<0>(v45, "i < 0");
        std::string::basic_string[abi:ne180100]<0>(v44, "getMat");
        std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
        cv::Exception::Exception(v46, 4294967081, v45, v44, __p, 973);
        cv::error((cv *)v46, v16);
      }
      v17 = (uint64_t *)*((_QWORD *)this + 2);
      if (*v17 == v17[1])
        goto LABEL_36;
      v18 = *((_DWORD *)this + 2);
      (*(void (**)(uint64_t *__return_ptr, cv::_InputArray *, uint64_t))(*(_QWORD *)this + 48))(&v42, this, 0xFFFFFFFFLL);
      v19 = *v17;
      v20 = a3;
      v22 = v42;
      v21 = SHIDWORD(v42);
      goto LABEL_16;
    case 4u:
      v18 = (*(uint64_t (**)(cv::_InputArray *, uint64_t))(*(_QWORD *)this + 64))(this, a2);
      v23 = (_QWORD *)*((_QWORD *)this + 2);
      if ((a2 & 0x80000000) != 0 || (int)(-1431655765 * ((v23[1] - *v23) >> 3)) <= (int)a2)
      {
        std::string::basic_string[abi:ne180100]<0>(v45, "0 <= i && i < (int)vv.size()");
        std::string::basic_string[abi:ne180100]<0>(v44, "getMat");
        std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
        cv::Exception::Exception(v46, 4294967081, v45, v44, __p, 987);
        cv::error((cv *)v46, v24);
      }
      v25 = (uint64_t *)(*v23 + 24 * (int)a2);
      if (*v25 == v25[1])
      {
LABEL_36:
        *(_QWORD *)(a3 + 80) = 0;
        *(_QWORD *)(a3 + 64) = a3 + 8;
        *(_QWORD *)(a3 + 72) = a3 + 80;
        *(_QWORD *)(a3 + 88) = 0;
        *(_DWORD *)a3 = 1124007936;
        *(_OWORD *)(a3 + 4) = 0u;
        *(_OWORD *)(a3 + 20) = 0u;
        *(_OWORD *)(a3 + 36) = 0u;
        *(_OWORD *)(a3 + 48) = 0u;
      }
      else
      {
        (*(void (**)(uint64_t *__return_ptr, cv::_InputArray *, uint64_t))(*(_QWORD *)this + 48))(&v41, this, a2);
        v19 = *v25;
        v20 = a3;
        v22 = v41;
        v21 = SHIDWORD(v41);
LABEL_16:
        *(_DWORD *)(v20 + 8) = v21;
        *(_DWORD *)(a3 + 12) = v22;
        *(_QWORD *)(a3 + 16) = v19;
        *(_QWORD *)(a3 + 24) = 0;
        v26 = (((v18 >> 3) & 0x1FF) + 1) << ((0xFA50u >> (2 * (v18 & 7))) & 3);
        v27 = v22 * (uint64_t)(int)v26;
        *(_QWORD *)(a3 + 80) = v27;
        *(_QWORD *)(a3 + 64) = v20 + 8;
        *(_QWORD *)(a3 + 72) = a3 + 80;
        *(_DWORD *)a3 = v18 & 0xFFF | 0x42FF4000;
        *(_DWORD *)(a3 + 4) = 2;
        *(_QWORD *)(a3 + 88) = v26;
        v28 = v19 + v27 * v21;
        *(_QWORD *)(a3 + 48) = v28;
        *(_QWORD *)(a3 + 56) = 0;
        *(_QWORD *)(a3 + 32) = v19;
        *(_QWORD *)(a3 + 40) = v28;
      }
      return;
    case 5u:
      v32 = (uint64_t *)*((_QWORD *)this + 2);
      if ((a2 & 0x80000000) != 0
        || (v33 = *v32, (int)(-1431655765 * ((unint64_t)(v32[1] - *v32) >> 5)) <= (int)a2))
      {
        std::string::basic_string[abi:ne180100]<0>(v45, "0 <= i && i < (int)v.size()");
        std::string::basic_string[abi:ne180100]<0>(v44, "getMat");
        std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
        cv::Exception::Exception(v46, 4294967081, v45, v44, __p, 1002);
        cv::error((cv *)v46, v34);
      }
      v7 = v33 + 96 * (int)a2;
      *(_OWORD *)a3 = *(_OWORD *)v7;
      *(_QWORD *)(a3 + 16) = *(_QWORD *)(v7 + 16);
      v35 = *(_OWORD *)(v7 + 24);
      *(_OWORD *)(a3 + 24) = v35;
      *(_OWORD *)(a3 + 40) = *(_OWORD *)(v7 + 40);
      *(_QWORD *)(a3 + 56) = *(_QWORD *)(v7 + 56);
      *(_QWORD *)(a3 + 64) = a3 + 8;
      *(_QWORD *)(a3 + 80) = 0;
      *(_QWORD *)(a3 + 72) = a3 + 80;
      *(_QWORD *)(a3 + 88) = 0;
      if ((_QWORD)v35)
      {
        do
          v36 = __ldaxr((unsigned int *)v35);
        while (__stlxr(v36 + 1, (unsigned int *)v35));
      }
      if (*(int *)(v7 + 4) > 2)
        goto LABEL_37;
      v37 = *(_QWORD **)(v33 + 96 * (int)a2 + 72);
      goto LABEL_30;
    case 6u:
      if ((a2 & 0x80000000) == 0)
      {
        std::string::basic_string[abi:ne180100]<0>(v45, "i < 0");
        std::string::basic_string[abi:ne180100]<0>(v44, "getMat");
        std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
        cv::Exception::Exception(v46, 4294967081, v45, v44, __p, 961);
        cv::error((cv *)v46, v29);
      }
      cv::MatExpr::operator cv::Mat(*((_QWORD **)this + 2), a3);
      return;
    case 0xAu:
      std::string::basic_string[abi:ne180100]<0>(v45, "This method is not implemented for oclMat yet");
      std::string::basic_string[abi:ne180100]<0>(v44, "getMat");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
      cv::Exception::Exception(v46, 4294967083, v45, v44, __p, 995);
      cv::error((cv *)v46, v30);
    default:
      std::string::basic_string[abi:ne180100]<0>(v45, "k == STD_VECTOR_MAT");
      std::string::basic_string[abi:ne180100]<0>(v44, "getMat");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
      cv::Exception::Exception(v46, 4294967081, v45, v44, __p, 998);
      cv::error((cv *)v46, v31);
  }
}

void sub_219E6D1B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,char a29)
{
  cv::Exception::~Exception((cv::Exception *)&a29);
  if (a16 < 0)
    operator delete(__p);
  if (a22 < 0)
    operator delete(a17);
  if (a28 < 0)
    operator delete(a23);
  _Unwind_Resume(a1);
}

void cv::_InputArray::getMatVector(uint64_t a1, uint64_t *a2)
{
  unint64_t v3;
  uint64_t v4;
  cv::Mat *v5;
  unsigned int *v6;
  unint64_t v7;
  void *v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  cv *v14;
  uint64_t v15;
  uint64_t v16;
  int *v17;
  unsigned int *v18;
  unsigned int v19;
  uint64_t v20;
  unsigned int *v21;
  _QWORD *v22;
  unsigned int *v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  int *v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  cv *v34;
  _QWORD *v35;
  uint64_t v36;
  unsigned int v37;
  unsigned int v38;
  uint64_t v39;
  int *v40;
  unint64_t v41;
  unsigned int v42;
  void *v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int v46;
  int v47;
  cv *v48;
  uint64_t v49;
  uint64_t v50;
  int *v51;
  uint64_t v52;
  unsigned int *v53;
  _QWORD *v54;
  unsigned int *v55;
  unsigned int v56;
  unsigned int v57;
  uint64_t v58;
  uint64_t v59;
  int *v60;
  int v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  cv *v66;
  _QWORD *v67;
  uint64_t v68;
  unsigned int *v69;
  unsigned int v70;
  unsigned int v71;
  uint64_t v72;
  int *v73;
  _QWORD *v74;
  uint64_t v75;
  uint64_t v76;
  unsigned int v77;
  void *v78;
  unint64_t v79;
  uint64_t v80;
  char v81;
  uint64_t v82;
  cv *v83;
  uint64_t v84;
  int *v85;
  uint64_t v86;
  unsigned int *v87;
  _QWORD *v88;
  unsigned int *v89;
  unsigned int v90;
  unsigned int v91;
  uint64_t v92;
  uint64_t v93;
  int *v94;
  int v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  cv *v100;
  _QWORD *v101;
  uint64_t v102;
  unsigned int *v103;
  unsigned int v104;
  unsigned int v105;
  uint64_t v106;
  int *v107;
  int v108;
  unsigned int v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  void *v113;
  cv *v114;
  uint64_t v115;
  int *v116;
  uint64_t v117;
  unsigned int *v118;
  _QWORD *v119;
  unsigned int *v120;
  unsigned int v121;
  unsigned int v122;
  uint64_t v123;
  uint64_t v124;
  int *v125;
  int v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  cv *v131;
  _QWORD *v132;
  uint64_t v133;
  unsigned int *v134;
  unsigned int v135;
  unsigned int v136;
  uint64_t v137;
  int *v138;
  int v139;
  void *v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  cv::Mat *v145;
  unsigned int *v146;
  unsigned int v147;
  uint64_t v148;
  unsigned int *v149;
  _QWORD *v150;
  unsigned int *v151;
  unsigned int v152;
  unsigned int v153;
  uint64_t v154;
  uint64_t v155;
  int *v156;
  int v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  void **v162;
  _QWORD *v163;
  uint64_t v164;
  unsigned int *v165;
  unsigned int v166;
  unsigned int v167;
  uint64_t v168;
  uint64_t v169;
  unsigned int *v170;
  unsigned int v171;
  unsigned int v172;
  const cv::Exception *v173;
  const cv::Exception *v174;
  cv::Mat **v175;
  uint64_t v176;
  int *v177;
  unint64_t v178;
  uint64_t v179;
  uint64_t v180;
  int v181;
  uint64_t v182;
  unint64_t v183;
  _QWORD *v184;
  uint64_t *v185;
  void *__p[2];
  _QWORD v188[2];
  int v189;
  _BYTE v190[12];
  __int128 v191;
  cv *v192[2];
  cv *v193;
  uint64_t v194;
  int *v195;
  cv *v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  _QWORD v200[2];
  __int128 v201;
  __int128 v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  void **v206;
  uint64_t v207;

  HIDWORD(v3) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  LODWORD(v3) = HIDWORD(v3);
  switch((v3 >> 16))
  {
    case 0u:
      v4 = *a2;
      v5 = (cv::Mat *)a2[1];
      if (v5 != (cv::Mat *)*a2)
      {
        do
        {
          v5 = (cv::Mat *)((char *)v5 - 96);
          std::allocator<cv::Mat>::destroy[abi:ne180100]((_DWORD)a2 + 16, v5);
        }
        while (v5 != (cv::Mat *)v4);
      }
      a2[1] = v4;
      return;
    case 1u:
      v6 = *(unsigned int **)(a1 + 16);
      v7 = **((int **)v6 + 8);
      std::vector<cv::Mat>::resize(a2, v7);
      if ((int)v7 < 1)
        return;
      v9 = 0;
      v182 = v7;
      while (1)
      {
        v10 = v6[1];
        if (v10 != 2)
          break;
        v11 = v6[3];
        v12 = *v6;
        v13 = *v6 & 0xFFF;
        v14 = (cv *)(*((_QWORD *)v6 + 2) + **((_QWORD **)v6 + 9) * v9);
        *(_QWORD *)v190 = 0x100000002;
        *(_DWORD *)&v190[8] = v11;
        v191 = (unint64_t)v14;
        v195 = (int *)&v190[4];
        v196 = (cv *)&v197;
        v15 = (((v12 >> 3) & 0x1FF) + 1) << ((0xFA50u >> (2 * (v12 & 7))) & 3);
        v189 = v13 | 0x42FF4000;
        v197 = (int)v15 * (uint64_t)(int)v11;
        v198 = v15;
        v193 = (cv *)((char *)v14 + v197);
        v194 = 0;
        v192[0] = v14;
        v192[1] = (cv *)((char *)v14 + v197);
        v16 = *a2;
        v17 = (int *)(*a2 + 96 * v9);
        if (v17 != &v189)
          goto LABEL_13;
LABEL_33:
        *(_QWORD *)&v191 = 0;
        v192[1] = 0;
        v193 = 0;
        v192[0] = 0;
        if (*(int *)v190 >= 1)
        {
          v39 = 0;
          v40 = v195;
          do
            v40[v39++] = 0;
          while (v39 < *(int *)v190);
        }
        *((_QWORD *)&v191 + 1) = 0;
        if (v196 != (cv *)&v197)
          cv::fastFree((void **)v196, v8);
        if (++v9 == v182)
          return;
      }
      cv::Mat::Mat((cv::Mat *)&v189, (cv::Mat *)(v10 - 1), (const int *)(*((_QWORD *)v6 + 8) + 4), *v6 & 0xFFF, (void *)(*((_QWORD *)v6 + 2) + **((_QWORD **)v6 + 9) * v9), (const unint64_t *)(*((_QWORD *)v6 + 9) + 8));
      v18 = (unsigned int *)*((_QWORD *)&v191 + 1);
      v16 = *a2;
      v17 = (int *)(*a2 + 96 * v9);
      if (v17 == &v189)
        goto LABEL_27;
      if (*((_QWORD *)&v191 + 1))
      {
        do
          v19 = __ldaxr(v18);
        while (__stlxr(v19 + 1, v18));
      }
LABEL_13:
      v20 = v16 + 96 * v9;
      v23 = *(unsigned int **)(v20 + 24);
      v22 = (_QWORD *)(v20 + 24);
      v21 = v23;
      if (v23)
      {
        do
        {
          v24 = __ldaxr(v21);
          v25 = v24 - 1;
        }
        while (__stlxr(v25, v21));
        if (!v25)
          cv::Mat::deallocate((cv::Mat *)v17, v8);
      }
      v26 = v16 + 96 * v9;
      *(_QWORD *)(v26 + 32) = 0;
      v27 = v26 + 32;
      *(_QWORD *)(v27 - 16) = 0;
      v28 = (int *)(v27 - 28);
      v29 = *(_DWORD *)(v27 - 28);
      *(_QWORD *)(v27 + 8) = 0;
      *(_QWORD *)(v27 + 16) = 0;
      if (v29 <= 0)
      {
        *v22 = 0;
        *v17 = v189;
      }
      else
      {
        v30 = 0;
        v31 = *(_QWORD *)(v16 + 96 * v9 + 64);
        do
        {
          *(_DWORD *)(v31 + 4 * v30++) = 0;
          v32 = *v28;
        }
        while (v30 < v32);
        *v22 = 0;
        *v17 = v189;
        if ((int)v32 > 2)
          goto LABEL_25;
      }
      if (*(int *)v190 <= 2)
      {
        *v28 = *(_DWORD *)v190;
        v33 = v16 + 96 * v9;
        *(_QWORD *)(v33 + 8) = *(_QWORD *)&v190[4];
        v34 = v196;
        v35 = *(_QWORD **)(v33 + 72);
        *v35 = *(_QWORD *)v196;
        v35[1] = *((_QWORD *)v34 + 1);
LABEL_26:
        *(_OWORD *)v27 = *(_OWORD *)v192;
        v36 = v16 + 96 * v9;
        *(_QWORD *)(v36 + 48) = v193;
        *(_OWORD *)(v27 - 16) = v191;
        *(_QWORD *)(v36 + 56) = v194;
        v18 = (unsigned int *)*((_QWORD *)&v191 + 1);
LABEL_27:
        if (v18)
        {
          do
          {
            v37 = __ldaxr(v18);
            v38 = v37 - 1;
          }
          while (__stlxr(v38, v18));
          if (!v38)
          {
            if (v194)
              (*(void (**)(uint64_t, _QWORD, cv *, _QWORD))(*(_QWORD *)v194 + 24))(v194, *((_QWORD *)&v191 + 1), v192[0], v191);
            else
              cv::fastFree((void **)v192[0], v8);
          }
        }
        goto LABEL_33;
      }
LABEL_25:
      cv::Mat::copySize((cv::Mat *)v17, (const cv::Mat *)&v189);
      goto LABEL_26;
    case 2u:
      v41 = *(int *)(a1 + 28);
      v42 = *(_DWORD *)(a1 + 8);
      std::vector<cv::Mat>::resize(a2, v41);
      v183 = v41;
      if (!(_DWORD)v41)
        return;
      v44 = 0;
      while (1)
      {
        v45 = *(int *)(a1 + 24);
        v46 = *(_DWORD *)(a1 + 8);
        v47 = v46 & 0xFFF;
        v48 = (cv *)(*(_QWORD *)(a1 + 16)
                   + v44 * ((((v42 >> 3) & 0x1FF) + 1) << ((0xFA50u >> (2 * (v42 & 7))) & 3)) * v45);
        *(_QWORD *)v190 = 0x100000002;
        *(_DWORD *)&v190[8] = v45;
        v191 = (unint64_t)v48;
        v195 = (int *)&v190[4];
        v196 = (cv *)&v197;
        v49 = (((v46 >> 3) & 0x1FF) + 1) << ((0xFA50u >> (2 * (v46 & 7))) & 3);
        v189 = v47 | 0x42FF4000;
        v197 = (int)v49 * (uint64_t)(int)v45;
        v198 = v49;
        v193 = (cv *)((char *)v48 + v197);
        v194 = 0;
        v192[0] = v48;
        v192[1] = (cv *)((char *)v48 + v197);
        v50 = *a2;
        v51 = (int *)(*a2 + 96 * v44);
        if (v51 != &v189)
          break;
LABEL_62:
        *(_QWORD *)&v191 = 0;
        v192[1] = 0;
        v193 = 0;
        v192[0] = 0;
        if (*(int *)v190 >= 1)
        {
          v72 = 0;
          v73 = v195;
          do
            v73[v72++] = 0;
          while (v72 < *(int *)v190);
        }
        *((_QWORD *)&v191 + 1) = 0;
        if (v196 != (cv *)&v197)
          cv::fastFree((void **)v196, v43);
        if (++v44 == v183)
          return;
      }
      v52 = v50 + 96 * v44;
      v55 = *(unsigned int **)(v52 + 24);
      v54 = (_QWORD *)(v52 + 24);
      v53 = v55;
      if (v55)
      {
        do
        {
          v56 = __ldaxr(v53);
          v57 = v56 - 1;
        }
        while (__stlxr(v57, v53));
        if (!v57)
          cv::Mat::deallocate((cv::Mat *)v51, v43);
      }
      v58 = v50 + 96 * v44;
      *(_QWORD *)(v58 + 32) = 0;
      v59 = v58 + 32;
      *(_QWORD *)(v59 - 16) = 0;
      v60 = (int *)(v59 - 28);
      v61 = *(_DWORD *)(v59 - 28);
      *(_QWORD *)(v59 + 8) = 0;
      *(_QWORD *)(v59 + 16) = 0;
      if (v61 <= 0)
      {
        *v54 = 0;
        *v51 = v189;
      }
      else
      {
        v62 = 0;
        v63 = *(_QWORD *)(v50 + 96 * v44 + 64);
        do
        {
          *(_DWORD *)(v63 + 4 * v62++) = 0;
          v64 = *v60;
        }
        while (v62 < v64);
        *v54 = 0;
        *v51 = v189;
        if ((int)v64 > 2)
          goto LABEL_55;
      }
      if (*(int *)v190 <= 2)
      {
        *v60 = *(_DWORD *)v190;
        v65 = v50 + 96 * v44;
        *(_QWORD *)(v65 + 8) = *(_QWORD *)&v190[4];
        v66 = v196;
        v67 = *(_QWORD **)(v65 + 72);
        *v67 = *(_QWORD *)v196;
        v67[1] = *((_QWORD *)v66 + 1);
LABEL_56:
        *(_OWORD *)v59 = *(_OWORD *)v192;
        v68 = v50 + 96 * v44;
        *(_QWORD *)(v68 + 48) = v193;
        *(_OWORD *)(v59 - 16) = v191;
        *(_QWORD *)(v68 + 56) = v194;
        v69 = (unsigned int *)*((_QWORD *)&v191 + 1);
        if (*((_QWORD *)&v191 + 1))
        {
          do
          {
            v70 = __ldaxr(v69);
            v71 = v70 - 1;
          }
          while (__stlxr(v71, v69));
          if (!v71)
          {
            if (v194)
              (*(void (**)(uint64_t, _QWORD, cv *, _QWORD))(*(_QWORD *)v194 + 24))(v194, *((_QWORD *)&v191 + 1), v192[0], v191);
            else
              cv::fastFree((void **)v192[0], v43);
          }
        }
        goto LABEL_62;
      }
LABEL_55:
      cv::Mat::copySize((cv::Mat *)v51, (const cv::Mat *)&v189);
      goto LABEL_56;
    case 3u:
      v74 = *(_QWORD **)(a1 + 16);
      v76 = *v74;
      v75 = v74[1];
      v184 = v74;
      v77 = *(_DWORD *)(a1 + 8);
      std::vector<cv::Mat>::resize(a2, v75 - *v74);
      v79 = v75 - v76;
      if (v75 == v76)
        return;
      v80 = 0;
      v81 = (0xFA50uLL >> (2 * (v77 & 7))) & 3;
      v82 = (((v77 >> 3) & 0x1FF) + 1) << v81;
      v179 = 1 << v81;
      if (v79 <= 1)
        v79 = 1;
      v178 = v79;
      while (1)
      {
        v83 = (cv *)(*v184 + v80 * v82);
        *(_QWORD *)v190 = 0x100000002;
        *(_DWORD *)&v190[8] = ((v77 >> 3) & 0x1FF) + 1;
        v191 = (unint64_t)v83;
        v195 = (int *)&v190[4];
        v196 = (cv *)&v197;
        v189 = v77 & 7 | 0x42FF4000;
        v197 = v82;
        v198 = v179;
        v193 = (cv *)((char *)v83 + v82);
        v194 = 0;
        v192[0] = v83;
        v192[1] = (cv *)((char *)v83 + v82);
        v84 = *a2;
        v85 = (int *)(*a2 + 96 * v80);
        if (v85 != &v189)
          break;
LABEL_93:
        *(_QWORD *)&v191 = 0;
        v192[1] = 0;
        v193 = 0;
        v192[0] = 0;
        if (*(int *)v190 >= 1)
        {
          v106 = 0;
          v107 = v195;
          do
            v107[v106++] = 0;
          while (v106 < *(int *)v190);
        }
        *((_QWORD *)&v191 + 1) = 0;
        if (v196 != (cv *)&v197)
          cv::fastFree((void **)v196, v78);
        if (++v80 == v178)
          return;
      }
      v86 = v84 + 96 * v80;
      v89 = *(unsigned int **)(v86 + 24);
      v88 = (_QWORD *)(v86 + 24);
      v87 = v89;
      if (v89)
      {
        do
        {
          v90 = __ldaxr(v87);
          v91 = v90 - 1;
        }
        while (__stlxr(v91, v87));
        if (!v91)
          cv::Mat::deallocate((cv::Mat *)v85, v78);
      }
      v92 = v84 + 96 * v80;
      *(_QWORD *)(v92 + 32) = 0;
      v93 = v92 + 32;
      *(_QWORD *)(v93 - 16) = 0;
      v94 = (int *)(v93 - 28);
      v95 = *(_DWORD *)(v93 - 28);
      *(_QWORD *)(v93 + 8) = 0;
      *(_QWORD *)(v93 + 16) = 0;
      if (v95 <= 0)
      {
        *v88 = 0;
        *v85 = v189;
      }
      else
      {
        v96 = 0;
        v97 = *(_QWORD *)(v84 + 96 * v80 + 64);
        do
        {
          *(_DWORD *)(v97 + 4 * v96++) = 0;
          v98 = *v94;
        }
        while (v96 < v98);
        *v88 = 0;
        *v85 = v189;
        if ((int)v98 > 2)
          goto LABEL_86;
      }
      if (*(int *)v190 <= 2)
      {
        *v94 = *(_DWORD *)v190;
        v99 = v84 + 96 * v80;
        *(_QWORD *)(v99 + 8) = *(_QWORD *)&v190[4];
        v100 = v196;
        v101 = *(_QWORD **)(v99 + 72);
        *v101 = *(_QWORD *)v196;
        v101[1] = *((_QWORD *)v100 + 1);
LABEL_87:
        *(_OWORD *)v93 = *(_OWORD *)v192;
        v102 = v84 + 96 * v80;
        *(_QWORD *)(v102 + 48) = v193;
        *(_OWORD *)(v93 - 16) = v191;
        *(_QWORD *)(v102 + 56) = v194;
        v103 = (unsigned int *)*((_QWORD *)&v191 + 1);
        if (*((_QWORD *)&v191 + 1))
        {
          do
          {
            v104 = __ldaxr(v103);
            v105 = v104 - 1;
          }
          while (__stlxr(v105, v103));
          if (!v105)
          {
            if (v194)
              (*(void (**)(uint64_t, _QWORD, cv *, _QWORD))(*(_QWORD *)v194 + 24))(v194, *((_QWORD *)&v191 + 1), v192[0], v191);
            else
              cv::fastFree((void **)v192[0], v78);
          }
        }
        goto LABEL_93;
      }
LABEL_86:
      cv::Mat::copySize((cv::Mat *)v85, (const cv::Mat *)&v189);
      goto LABEL_87;
    case 4u:
      v185 = *(uint64_t **)(a1 + 16);
      v108 = -1431655765 * ((v185[1] - *v185) >> 3);
      v109 = *(_DWORD *)(a1 + 8);
      std::vector<cv::Mat>::resize(a2, v108);
      if (v108 < 1)
        return;
      v110 = 0;
      v111 = (((v109 >> 3) & 0x1FF) + 1) << ((0xFA50u >> (2 * (v109 & 7))) & 3);
      v181 = v109 & 0xFFF | 0x42FF4000;
      v180 = v108;
      while (1)
      {
        v112 = *v185;
        (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(_QWORD *)a1 + 48))(&v199, a1, v110);
        v114 = *(cv **)(v112 + 24 * v110);
        *(_DWORD *)&v190[4] = HIDWORD(v199);
        *(_DWORD *)&v190[8] = v199;
        v191 = (unint64_t)v114;
        v195 = (int *)&v190[4];
        v196 = (cv *)&v197;
        *(_DWORD *)v190 = 2;
        v189 = v181;
        v197 = (int)v199 * (uint64_t)(int)v111;
        v198 = v111;
        v193 = (cv *)((char *)v114 + v197 * SHIDWORD(v199));
        v194 = 0;
        v192[0] = v114;
        v192[1] = v193;
        v115 = *a2;
        v116 = (int *)(*a2 + 96 * v110);
        if (v116 != &v189)
          break;
LABEL_122:
        *(_QWORD *)&v191 = 0;
        v192[1] = 0;
        v193 = 0;
        v192[0] = 0;
        if (*(int *)v190 >= 1)
        {
          v137 = 0;
          v138 = v195;
          do
            v138[v137++] = 0;
          while (v137 < *(int *)v190);
        }
        *((_QWORD *)&v191 + 1) = 0;
        if (v196 != (cv *)&v197)
          cv::fastFree((void **)v196, v113);
        if (++v110 == v180)
          return;
      }
      v117 = v115 + 96 * v110;
      v120 = *(unsigned int **)(v117 + 24);
      v119 = (_QWORD *)(v117 + 24);
      v118 = v120;
      if (v120)
      {
        do
        {
          v121 = __ldaxr(v118);
          v122 = v121 - 1;
        }
        while (__stlxr(v122, v118));
        if (!v122)
          cv::Mat::deallocate((cv::Mat *)v116, v113);
      }
      v123 = v115 + 96 * v110;
      *(_QWORD *)(v123 + 32) = 0;
      v124 = v123 + 32;
      *(_QWORD *)(v124 - 16) = 0;
      v125 = (int *)(v124 - 28);
      v126 = *(_DWORD *)(v124 - 28);
      *(_QWORD *)(v124 + 8) = 0;
      *(_QWORD *)(v124 + 16) = 0;
      if (v126 <= 0)
      {
        *v119 = 0;
        *v116 = v189;
      }
      else
      {
        v127 = 0;
        v128 = *(_QWORD *)(v115 + 96 * v110 + 64);
        do
        {
          *(_DWORD *)(v128 + 4 * v127++) = 0;
          v129 = *v125;
        }
        while (v127 < v129);
        *v119 = 0;
        *v116 = v189;
        if ((int)v129 > 2)
          goto LABEL_115;
      }
      if (*(int *)v190 <= 2)
      {
        *v125 = *(_DWORD *)v190;
        v130 = v115 + 96 * v110;
        *(_QWORD *)(v130 + 8) = *(_QWORD *)&v190[4];
        v131 = v196;
        v132 = *(_QWORD **)(v130 + 72);
        *v132 = *(_QWORD *)v196;
        v132[1] = *((_QWORD *)v131 + 1);
LABEL_116:
        *(_OWORD *)v124 = *(_OWORD *)v192;
        v133 = v115 + 96 * v110;
        *(_QWORD *)(v133 + 48) = v193;
        *(_OWORD *)(v124 - 16) = v191;
        *(_QWORD *)(v133 + 56) = v194;
        v134 = (unsigned int *)*((_QWORD *)&v191 + 1);
        if (*((_QWORD *)&v191 + 1))
        {
          do
          {
            v135 = __ldaxr(v134);
            v136 = v135 - 1;
          }
          while (__stlxr(v136, v134));
          if (!v136)
          {
            if (v194)
              (*(void (**)(uint64_t, _QWORD, cv *, _QWORD))(*(_QWORD *)v194 + 24))(v194, *((_QWORD *)&v191 + 1), v192[0], v191);
            else
              cv::fastFree((void **)v192[0], v113);
          }
        }
        goto LABEL_122;
      }
LABEL_115:
      cv::Mat::copySize((cv::Mat *)v116, (const cv::Mat *)&v189);
      goto LABEL_116;
    case 5u:
      v175 = *(cv::Mat ***)(a1 + 16);
      std::vector<cv::Mat>::resize(a2, 0xAAAAAAAAAAAAAAABLL * ((v175[1] - *v175) >> 5));
      std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<cv::Mat const*,cv::Mat const*,cv::Mat*>((int)&v189, *v175, v175[1], (cv::Mat *)*a2);
      return;
    case 6u:
      cv::MatExpr::operator cv::Mat(*(_QWORD **)(a1 + 16), (uint64_t)&v189);
      v139 = *v195;
      std::vector<cv::Mat>::resize(a2, *v195);
      v141 = v139;
      if (v139 < 1)
        goto LABEL_160;
      v142 = 0;
      break;
    case 0xAu:
      std::string::basic_string[abi:ne180100]<0>(v200, "This method is not implemented for oclMat yet");
      std::string::basic_string[abi:ne180100]<0>(v188, "getMatVector");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
      cv::Exception::Exception(&v189, 4294967083, v200, v188, __p, 1082);
      cv::error((cv *)&v189, v173);
    default:
      std::string::basic_string[abi:ne180100]<0>(v200, "k == STD_VECTOR_MAT");
      std::string::basic_string[abi:ne180100]<0>(v188, "getMatVector");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
      cv::Exception::Exception(&v189, 4294967081, v200, v188, __p, 1085);
      cv::error((cv *)&v189, v174);
  }
  do
  {
    v143 = v142 + 1;
    LODWORD(v188[0]) = v142;
    HIDWORD(v188[0]) = v142 + 1;
    __p[0] = (void *)0x7FFFFFFF80000000;
    cv::Mat::Mat((uint64_t)v200, (uint64_t)&v189);
    v144 = *a2;
    v145 = (cv::Mat *)(*a2 + 96 * v142);
    if (v145 != (cv::Mat *)v200)
    {
      v146 = (unsigned int *)*((_QWORD *)&v201 + 1);
      if (*((_QWORD *)&v201 + 1))
      {
        do
          v147 = __ldaxr(v146);
        while (__stlxr(v147 + 1, v146));
      }
      v148 = v144 + 96 * v142;
      v151 = *(unsigned int **)(v148 + 24);
      v150 = (_QWORD *)(v148 + 24);
      v149 = v151;
      if (v151)
      {
        do
        {
          v152 = __ldaxr(v149);
          v153 = v152 - 1;
        }
        while (__stlxr(v153, v149));
        if (!v153)
          cv::Mat::deallocate(v145, v140);
      }
      v154 = v144 + 96 * v142;
      *(_QWORD *)(v154 + 32) = 0;
      v155 = v154 + 32;
      *(_QWORD *)(v155 - 16) = 0;
      v156 = (int *)(v155 - 28);
      v157 = *(_DWORD *)(v155 - 28);
      *(_QWORD *)(v155 + 8) = 0;
      *(_QWORD *)(v155 + 16) = 0;
      if (v157 <= 0)
      {
        *v150 = 0;
        *(_DWORD *)v145 = v200[0];
      }
      else
      {
        v158 = 0;
        v159 = *(_QWORD *)(v144 + 96 * v142 + 64);
        do
        {
          *(_DWORD *)(v159 + 4 * v158++) = 0;
          v160 = *v156;
        }
        while (v158 < v160);
        *v150 = 0;
        *(_DWORD *)v145 = v200[0];
        if ((int)v160 > 2)
          goto LABEL_146;
      }
      if (SHIDWORD(v200[0]) <= 2)
      {
        *v156 = HIDWORD(v200[0]);
        v161 = v144 + 96 * v142;
        *(_QWORD *)(v161 + 8) = v200[1];
        v162 = v206;
        v163 = *(_QWORD **)(v161 + 72);
        *v163 = *v206;
        v163[1] = v162[1];
LABEL_147:
        *(_OWORD *)v155 = v202;
        v164 = v144 + 96 * v142;
        *(_QWORD *)(v164 + 48) = v203;
        *(_OWORD *)(v155 - 16) = v201;
        *(_QWORD *)(v164 + 56) = v204;
        goto LABEL_148;
      }
LABEL_146:
      cv::Mat::copySize(v145, (const cv::Mat *)v200);
      goto LABEL_147;
    }
LABEL_148:
    v165 = (unsigned int *)*((_QWORD *)&v201 + 1);
    if (*((_QWORD *)&v201 + 1))
    {
      do
      {
        v166 = __ldaxr(v165);
        v167 = v166 - 1;
      }
      while (__stlxr(v167, v165));
      if (!v167)
      {
        if (v204)
          (*(void (**)(uint64_t, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v204 + 24))(v204, *((_QWORD *)&v201 + 1), v202, v201);
        else
          cv::fastFree((void **)v202, v140);
      }
    }
    *(_QWORD *)&v201 = 0;
    v203 = 0;
    v202 = 0uLL;
    if (SHIDWORD(v200[0]) >= 1)
    {
      v168 = 0;
      v169 = v205;
      do
        *(_DWORD *)(v169 + 4 * v168++) = 0;
      while (v168 < SHIDWORD(v200[0]));
    }
    *((_QWORD *)&v201 + 1) = 0;
    if (v206 != (void **)&v207)
      cv::fastFree(v206, v140);
    ++v142;
  }
  while (v143 != v141);
LABEL_160:
  v170 = (unsigned int *)*((_QWORD *)&v191 + 1);
  if (*((_QWORD *)&v191 + 1))
  {
    do
    {
      v171 = __ldaxr(v170);
      v172 = v171 - 1;
    }
    while (__stlxr(v172, v170));
    if (!v172)
    {
      if (v194)
        (*(void (**)(uint64_t, _QWORD, cv *, _QWORD))(*(_QWORD *)v194 + 24))(v194, *((_QWORD *)&v191 + 1), v192[0], v191);
      else
        cv::fastFree((void **)v192[0], v140);
    }
  }
  *(_QWORD *)&v191 = 0;
  v192[0] = 0;
  v192[1] = 0;
  v193 = 0;
  if (*(int *)v190 >= 1)
  {
    v176 = 0;
    v177 = v195;
    do
      v177[v176++] = 0;
    while (v176 < *(int *)v190);
  }
  *((_QWORD *)&v191 + 1) = 0;
  if (v196 != (cv *)&v197)
    cv::fastFree((void **)v196, v140);
}

void sub_219E6E1D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,char a28)
{
  uint64_t v28;

  cv::Exception::~Exception((cv::Exception *)&a28);
  if (a21 < 0)
    operator delete(__p);
  if (a27 < 0)
    operator delete(a22);
  if (*(char *)(v28 - 177) < 0)
    operator delete(*(void **)(v28 - 200));
  _Unwind_Resume(a1);
}

void std::vector<cv::Mat>::resize(uint64_t *a1, unint64_t a2)
{
  cv::Mat *v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;

  v3 = (cv::Mat *)a1[1];
  v4 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v3 - *a1) >> 5);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<cv::Mat>::__append(a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 96 * a2;
    while (v3 != (cv::Mat *)v7)
    {
      v3 = (cv::Mat *)((char *)v3 - 96);
      std::allocator<cv::Mat>::destroy[abi:ne180100]((_DWORD)a1 + 16, v3);
    }
    a1[1] = v7;
  }
}

void cv::_InputArray::getGlBuffer(cv::_InputArray *this)
{
  const cv::Exception *v1;
  void *__p[2];
  void *v3[2];
  void *v4[2];
  _BYTE v5[120];

  std::string::basic_string[abi:ne180100]<0>(v4, "This function in deprecated, do not use it");
  std::string::basic_string[abi:ne180100]<0>(v3, "getGlBuffer");
  std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
  cv::Exception::Exception(v5, 4294967083, v4, v3, __p, 1097);
  cv::error((cv *)v5, v1);
}

void sub_219E6E3D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

void cv::_InputArray::getGlTexture(cv::_InputArray *this)
{
  const cv::Exception *v1;
  void *__p[2];
  void *v3[2];
  void *v4[2];
  _BYTE v5[120];

  std::string::basic_string[abi:ne180100]<0>(v4, "This function in deprecated, do not use it");
  std::string::basic_string[abi:ne180100]<0>(v3, "getGlTexture");
  std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
  cv::Exception::Exception(v5, 4294967083, v4, v3, __p, 1103);
  cv::error((cv *)v5, v1);
}

void sub_219E6E4E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

uint64_t cv::_InputArray::getGpuMat@<X0>(const cv::gpu::GpuMat **this@<X0>, cv::gpu::GpuMat *a2@<X8>)
{
  const cv::Exception *v4;
  void *__p[2];
  void *v7[2];
  void *v8[2];
  _BYTE v9[120];

  if ((*((unsigned int (**)(const cv::gpu::GpuMat **))*this + 5))(this) != 589824)
  {
    std::string::basic_string[abi:ne180100]<0>(v8, "k == GPU_MAT");
    std::string::basic_string[abi:ne180100]<0>(v7, "getGpuMat");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
    cv::Exception::Exception(v9, 4294967081, v8, v7, __p, 1111);
    cv::error((cv *)v9, v4);
  }
  return cv::gpu::GpuMat::GpuMat(a2, this[2]);
}

void sub_219E6E614(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

uint64_t cv::_InputArray::kind(cv::_InputArray *this)
{
  return *((_DWORD *)this + 2) & 0x3FFF0000;
}

void cv::_InputArray::size(cv::_InputArray *this@<X0>, unsigned int a2@<W1>, int32x2_t *a3@<X8>)
{
  unint64_t v6;
  const cv::Exception *v7;
  uint64_t v8;
  const cv::Exception *v9;
  int32x2_t v10;
  const cv::Exception *v11;
  int64_t v12;
  _QWORD *v13;
  const cv::Exception *v14;
  uint64_t v15;
  _QWORD *v16;
  const cv::Exception *v17;
  int32x2_t v18;
  const cv::Exception *v19;
  const cv::Exception *v20;
  const cv::Exception *v21;
  const cv::Exception *v22;
  const cv::Exception *v23;
  const cv::Exception *v24;
  uint64_t v25;
  uint64_t v26;
  void *__p[2];
  void *v28[2];
  void *v29[2];
  _BYTE v30[120];

  HIDWORD(v6) = (*(uint64_t (**)(cv::_InputArray *))(*(_QWORD *)this + 40))(this);
  LODWORD(v6) = HIDWORD(v6);
  switch((v6 >> 16))
  {
    case 0u:
      goto LABEL_2;
    case 1u:
      if ((a2 & 0x80000000) == 0)
      {
        std::string::basic_string[abi:ne180100]<0>(v29, "i < 0");
        std::string::basic_string[abi:ne180100]<0>(v28, "size");
        std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
        cv::Exception::Exception(v30, 4294967081, v29, v28, __p, 1148);
        cv::error((cv *)v30, v7);
      }
      v8 = *((_QWORD *)this + 2);
      goto LABEL_22;
    case 2u:
      if ((a2 & 0x80000000) == 0)
      {
        std::string::basic_string[abi:ne180100]<0>(v29, "i < 0");
        std::string::basic_string[abi:ne180100]<0>(v28, "size");
        std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
        cv::Exception::Exception(v30, 4294967081, v29, v28, __p, 1160);
        cv::error((cv *)v30, v9);
      }
      v10 = *(int32x2_t *)((char *)this + 24);
      goto LABEL_37;
    case 3u:
      if ((a2 & 0x80000000) == 0)
      {
        std::string::basic_string[abi:ne180100]<0>(v29, "i < 0");
        std::string::basic_string[abi:ne180100]<0>(v28, "size");
        std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
        cv::Exception::Exception(v30, 4294967081, v29, v28, __p, 1166);
        cv::error((cv *)v30, v11);
      }
      v12 = *(_QWORD *)(*((_QWORD *)this + 2) + 8) - **((_QWORD **)this + 2);
      if (v12 != v12 >> 2)
        v12 /= (unint64_t)((((*((_DWORD *)this + 2) >> 3) & 0x1FFu) + 1) << ((0xFA50u >> (2
                                                                                               * (*((_DWORD *)this + 2) & 7))) & 3));
      goto LABEL_45;
    case 4u:
      v13 = (_QWORD *)*((_QWORD *)this + 2);
      if ((a2 & 0x80000000) == 0)
      {
        if ((int)(-1431655765 * ((v13[1] - *v13) >> 3)) <= (int)a2)
        {
          std::string::basic_string[abi:ne180100]<0>(v29, "i < (int)vv.size()");
          std::string::basic_string[abi:ne180100]<0>(v28, "size");
          std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
          cv::Exception::Exception(v30, 4294967081, v29, v28, __p, 1181);
          cv::error((cv *)v30, v14);
        }
        v15 = *(_QWORD *)(*v13 + 24 * a2 + 8) - *(_QWORD *)(*v13 + 24 * a2);
        if (v15 == v15 >> 2)
        {
          a3->i32[0] = v15;
          a3->i32[1] = 1;
          return;
        }
        v12 = v15
            / (unint64_t)((((*((_DWORD *)this + 2) >> 3) & 0x1FFu) + 1) << ((0xFA50u >> (2
                                                                                              * (*((_DWORD *)this + 2) & 7))) & 3));
        goto LABEL_45;
      }
      v25 = v13[1];
      if (*v13 == v25)
        goto LABEL_2;
      v12 = (unint64_t)(v25 - *v13) >> 3;
      goto LABEL_43;
    case 5u:
      v16 = (_QWORD *)*((_QWORD *)this + 2);
      if ((a2 & 0x80000000) != 0)
      {
        v26 = v16[1];
        if (*v16 == v26)
        {
LABEL_2:
          *a3 = 0;
        }
        else
        {
          v12 = (unint64_t)(v26 - *v16) >> 5;
LABEL_43:
          LODWORD(v12) = -1431655765 * v12;
LABEL_45:
          a3->i32[0] = v12;
          a3->i32[1] = 1;
        }
      }
      else
      {
        if ((int)(-1431655765 * ((v16[1] - *v16) >> 5)) <= (int)a2)
        {
          std::string::basic_string[abi:ne180100]<0>(v29, "i < (int)vv.size()");
          std::string::basic_string[abi:ne180100]<0>(v28, "size");
          std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
          cv::Exception::Exception(v30, 4294967081, v29, v28, __p, 1193);
          cv::error((cv *)v30, v17);
        }
        v8 = *v16 + 96 * a2;
LABEL_22:
        v18 = **(int32x2_t **)(v8 + 64);
LABEL_36:
        v10 = vrev64_s32(v18);
LABEL_37:
        *a3 = v10;
      }
      return;
    case 6u:
      if ((a2 & 0x80000000) == 0)
      {
        std::string::basic_string[abi:ne180100]<0>(v29, "i < 0");
        std::string::basic_string[abi:ne180100]<0>(v28, "size");
        std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
        cv::Exception::Exception(v30, 4294967081, v29, v28, __p, 1154);
        cv::error((cv *)v30, v19);
      }
      cv::MatExpr::size(*((cv::MatExpr **)this + 2), a3);
      return;
    case 7u:
      if ((a2 & 0x80000000) == 0)
      {
        std::string::basic_string[abi:ne180100]<0>(v29, "i < 0");
        std::string::basic_string[abi:ne180100]<0>(v28, "size");
        std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
        cv::Exception::Exception(v30, 4294967081, v29, v28, __p, 1200);
        cv::error((cv *)v30, v20);
      }
      goto LABEL_30;
    case 8u:
      if ((a2 & 0x80000000) == 0)
      {
        std::string::basic_string[abi:ne180100]<0>(v29, "i < 0");
        std::string::basic_string[abi:ne180100]<0>(v28, "size");
        std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
        cv::Exception::Exception(v30, 4294967081, v29, v28, __p, 1207);
        cv::error((cv *)v30, v21);
      }
LABEL_30:
      v18 = *(int32x2_t *)(*((_QWORD *)this + 2) + 16);
      goto LABEL_36;
    case 9u:
      if ((a2 & 0x80000000) == 0)
      {
        std::string::basic_string[abi:ne180100]<0>(v29, "i < 0");
        std::string::basic_string[abi:ne180100]<0>(v28, "size");
        std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
        cv::Exception::Exception(v30, 4294967081, v29, v28, __p, 1220);
        cv::error((cv *)v30, v24);
      }
      v18 = *(int32x2_t *)(*((_QWORD *)this + 2) + 4);
      goto LABEL_36;
    case 0xAu:
      std::string::basic_string[abi:ne180100]<0>(v29, "This method is not implemented for oclMat yet");
      std::string::basic_string[abi:ne180100]<0>(v28, "size");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
      cv::Exception::Exception(v30, 4294967083, v29, v28, __p, 1214);
      cv::error((cv *)v30, v22);
    default:
      std::string::basic_string[abi:ne180100]<0>(v29, "k == GPU_MAT");
      std::string::basic_string[abi:ne180100]<0>(v28, "size");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
      cv::Exception::Exception(v30, 4294967081, v29, v28, __p, 1217);
      cv::error((cv *)v30, v23);
  }
}

void sub_219E6EE6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

uint64_t cv::_InputArray::total(cv::_InputArray *this, uint64_t a2)
{
  int v4;
  const cv::Exception *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t result;
  const cv::Exception *v13;
  uint64_t v14;
  int *v15;
  uint64_t v16;
  int *v17;
  uint64_t v18;
  void *__p[2];
  void *v20[2];
  void *v21[2];
  _QWORD v22[15];

  v4 = (*(uint64_t (**)(cv::_InputArray *))(*(_QWORD *)this + 40))(this);
  if (v4 == 327680)
  {
    v10 = (uint64_t *)*((_QWORD *)this + 2);
    v11 = *v10;
    result = 0xAAAAAAAAAAAAAAABLL * ((v10[1] - *v10) >> 5);
    if ((a2 & 0x80000000) == 0)
    {
      if ((int)result <= (int)a2)
      {
        std::string::basic_string[abi:ne180100]<0>(v21, "i < (int)vv.size()");
        std::string::basic_string[abi:ne180100]<0>(v20, "total");
        std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
        cv::Exception::Exception(v22, 4294967081, v21, v20, __p, 1242);
        cv::error((cv *)v22, v13);
      }
      v14 = *(unsigned int *)(v11 + 96 * a2 + 4);
      if ((int)v14 >= 3)
      {
        v17 = *(int **)(v11 + 96 * a2 + 64);
        result = 1;
        do
        {
          v18 = *v17++;
          result *= v18;
          --v14;
        }
        while (v14);
      }
      else
      {
        return *(int *)(v11 + 96 * a2 + 12) * (uint64_t)*(int *)(v11 + 96 * a2 + 8);
      }
    }
  }
  else
  {
    if (v4 != 0x10000)
    {
      (*(void (**)(_QWORD *__return_ptr, cv::_InputArray *, uint64_t))(*(_QWORD *)this + 48))(v22, this, a2);
      v8 = v22[0];
      v9 = HIDWORD(v22[0]);
      return v9 * (uint64_t)v8;
    }
    if ((a2 & 0x80000000) == 0)
    {
      std::string::basic_string[abi:ne180100]<0>(v21, "i < 0");
      std::string::basic_string[abi:ne180100]<0>(v20, "total");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
      cv::Exception::Exception(v22, 4294967081, v21, v20, __p, 1232);
      cv::error((cv *)v22, v5);
    }
    v6 = *((_QWORD *)this + 2);
    v7 = *(unsigned int *)(v6 + 4);
    if ((int)v7 < 3)
    {
      v8 = *(_DWORD *)(v6 + 8);
      v9 = *(_DWORD *)(v6 + 12);
      return v9 * (uint64_t)v8;
    }
    v15 = *(int **)(v6 + 64);
    result = 1;
    do
    {
      v16 = *v15++;
      result *= v16;
      --v7;
    }
    while (v7);
  }
  return result;
}

void sub_219E6F198(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

uint64_t cv::_InputArray::type(cv::_InputArray *this, int a2)
{
  unint64_t v4;
  uint64_t result;
  int v6;
  _QWORD *v7;
  const cv::Exception *v8;
  const cv::Exception *v9;
  void *__p[2];
  void *v11[2];
  void *v12[2];
  _BYTE v13[120];

  HIDWORD(v4) = (*(uint64_t (**)(cv::_InputArray *))(*(_QWORD *)this + 40))(this);
  LODWORD(v4) = HIDWORD(v4);
  result = 0xFFFFFFFFLL;
  switch((v4 >> 16))
  {
    case 0u:
      return result;
    case 1u:
    case 9u:
      v6 = **((_DWORD **)this + 2);
      goto LABEL_10;
    case 2u:
    case 3u:
    case 4u:
      v6 = *((_DWORD *)this + 2);
      goto LABEL_10;
    case 5u:
      v7 = (_QWORD *)*((_QWORD *)this + 2);
      if ((int)(-1431655765 * ((v7[1] - *v7) >> 5)) <= a2)
      {
        std::string::basic_string[abi:ne180100]<0>(v12, "i < (int)vv.size()");
        std::string::basic_string[abi:ne180100]<0>(v11, "type");
        std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
        cv::Exception::Exception(v13, 4294967081, v12, v11, __p, 1268);
        cv::error((cv *)v13, v8);
      }
      v6 = *(_DWORD *)(*v7 + 96 * (a2 & ~(a2 >> 31)));
LABEL_10:
      result = v6 & 0xFFF;
      break;
    case 6u:
      result = cv::MatExpr::type(*((uint64_t ***)this + 2));
      break;
    case 7u:
      result = *(unsigned int *)(*((_QWORD *)this + 2) + 24);
      break;
    default:
      std::string::basic_string[abi:ne180100]<0>(v12, "k == GPU_MAT");
      std::string::basic_string[abi:ne180100]<0>(v11, "type");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
      cv::Exception::Exception(v13, 4294967081, v12, v11, __p, 1276);
      cv::error((cv *)v13, v9);
  }
  return result;
}

void sub_219E6F3E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

uint64_t cv::_InputArray::depth(cv::_InputArray *this)
{
  return (*(uint64_t (**)(cv::_InputArray *))(*(_QWORD *)this + 64))(this) & 7;
}

uint64_t cv::_InputArray::channels(cv::_InputArray *this)
{
  return (((*(unsigned int (**)(cv::_InputArray *))(*(_QWORD *)this + 64))(this) >> 3) & 0x1FF) + 1;
}

BOOL cv::_InputArray::empty(cv::_InputArray *this)
{
  unint64_t v2;
  _BOOL8 result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const cv::Exception *v9;
  const cv::Exception *v10;
  int *v11;
  uint64_t v12;
  void *__p[2];
  void *v14[2];
  void *v15[2];
  _BYTE v16[120];

  HIDWORD(v2) = (*(uint64_t (**)(cv::_InputArray *))(*(_QWORD *)this + 40))(this);
  LODWORD(v2) = HIDWORD(v2);
  result = 0;
  switch((v2 >> 16))
  {
    case 0u:
      return 1;
    case 1u:
      v6 = *((_QWORD *)this + 2);
      if (!*(_QWORD *)(v6 + 16))
        return 1;
      v7 = *(unsigned int *)(v6 + 4);
      if ((int)v7 >= 3)
      {
        v11 = *(int **)(v6 + 64);
        v8 = 1;
        do
        {
          v12 = *v11++;
          v8 *= v12;
          --v7;
        }
        while (v7);
      }
      else
      {
        v8 = *(int *)(v6 + 12) * (uint64_t)*(int *)(v6 + 8);
      }
      return v8 == 0;
    case 2u:
    case 6u:
      return result;
    case 3u:
    case 4u:
    case 5u:
      return **((_QWORD **)this + 2) == *(_QWORD *)(*((_QWORD *)this + 2) + 8);
    case 7u:
    case 8u:
      v5 = *((_QWORD *)this + 2);
      if (!*(_DWORD *)(v5 + 16))
        return 1;
      return *(_DWORD *)(v5 + 20) == 0;
    case 9u:
      return *(_QWORD *)(*((_QWORD *)this + 2) + 24) == 0;
    case 0xAu:
      std::string::basic_string[abi:ne180100]<0>(v15, "This method is not implemented for oclMat yet");
      std::string::basic_string[abi:ne180100]<0>(v14, "empty");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
      cv::Exception::Exception(v16, 4294967083, v15, v14, __p, 1333);
      cv::error((cv *)v16, v9);
    default:
      std::string::basic_string[abi:ne180100]<0>(v15, "k == GPU_MAT");
      std::string::basic_string[abi:ne180100]<0>(v14, "empty");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
      cv::Exception::Exception(v16, 4294967081, v15, v14, __p, 1336);
      cv::error((cv *)v16, v10);
  }
}

void sub_219E6F698(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

uint64_t cv::_OutputArray::_OutputArray(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 8) = 327680;
  *(_QWORD *)(result + 16) = a2;
  *(_QWORD *)(result + 24) = 0;
  *(_QWORD *)result = &off_24DBF02F0;
  return result;
}

uint64_t cv::_OutputArray::_OutputArray(uint64_t this, const cv::Mat *a2)
{
  *(_QWORD *)(this + 16) = a2;
  *(_QWORD *)(this + 24) = 0;
  *(_QWORD *)this = &off_24DBF02F0;
  *(_DWORD *)(this + 8) = -1073676288;
  return this;
}

uint64_t cv::_OutputArray::fixedSize(cv::_OutputArray *this)
{
  return (*((unsigned __int8 *)this + 11) >> 6) & 1;
}

uint64_t cv::_OutputArray::fixedType(cv::_OutputArray *this)
{
  return *((_DWORD *)this + 2) >> 31;
}

void cv::_OutputArray::create(cv::gpu::GpuMat **a1, int32x2_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v12;
  char v13;
  const cv::Exception *v15;
  const cv::Exception *v16;
  cv::gpu::GpuMat *v17;
  int v18;
  int v19;
  char v21;
  const cv::Exception *v24;
  const cv::Exception *v25;
  const cv::Exception *v27;
  const cv::Exception *v28;
  void *__p[2];
  void *v30[2];
  void *v31[2];
  int32x2_t v32;
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  v12 = (*((uint64_t (**)(cv::gpu::GpuMat **))*a1 + 5))(a1);
  if ((_DWORD)a6)
    v13 = 1;
  else
    v13 = a5;
  if ((v13 & 1) == 0 && (a4 & 0x80000000) != 0 && v12 == 0x10000)
  {
    if ((*((unsigned int (**)(cv::gpu::GpuMat **))*a1 + 12))(a1))
    {
      if (*(_DWORD *)(*((_QWORD *)a1[2] + 8) + 4) != a2->i32[0] || **((_DWORD **)a1[2] + 8) != a2->i32[1])
      {
        std::string::basic_string[abi:ne180100]<0>(v31, "!fixedSize() || ((Mat*)obj)->size.operator()() == _sz");
        std::string::basic_string[abi:ne180100]<0>(v30, "create");
        std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
        cv::Exception::Exception(&v32, 4294967081, v31, v30, __p, 1374);
        cv::error((cv *)&v32, v15);
      }
    }
    if ((*((unsigned int (**)(cv::gpu::GpuMat **))*a1 + 13))(a1) && (*(_DWORD *)a1[2] & 0xFFF) != (_DWORD)a3)
    {
      std::string::basic_string[abi:ne180100]<0>(v31, "!fixedType() || ((Mat*)obj)->type() == mtype");
      std::string::basic_string[abi:ne180100]<0>(v30, "create");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
      cv::Exception::Exception(&v32, 4294967081, v31, v30, __p, 1375);
      cv::error((cv *)&v32, v16);
    }
    v17 = a1[2];
    v18 = a2->i32[0];
    v19 = a3 & 0xFFF;
    if (*((int *)v17 + 1) > 2
      || *((_DWORD *)v17 + 2) != a2->i32[1]
      || *((_DWORD *)v17 + 3) != v18
      || (*(_DWORD *)v17 & 0xFFF) != v19
      || !*((_QWORD *)v17 + 2))
    {
      v32.i32[0] = a2->i32[1];
      v32.i32[1] = v18;
      cv::Mat::create(v17, (cv::Mat *)2, (const int *)&v32, v19);
    }
  }
  else
  {
    if ((int)a4 < 0 && v12 == 589824)
      v21 = v13;
    else
      v21 = 1;
    if ((v21 & 1) != 0)
    {
      if ((int)a4 >= 0 || v12 != 458752)
        v13 = 1;
      if ((v13 & 1) != 0)
      {
        v32 = vrev64_s32(*a2);
        (*((void (**)(cv::gpu::GpuMat **, uint64_t, int32x2_t *, uint64_t, uint64_t, uint64_t, uint64_t))*a1 + 18))(a1, 2, &v32, a3, a4, a5, a6);
      }
      else
      {
        if ((*((unsigned int (**)(cv::gpu::GpuMat **))*a1 + 12))(a1))
        {
          if (*((_DWORD *)a1[2] + 5) != a2->i32[0] || *((_DWORD *)a1[2] + 4) != a2->i32[1])
          {
            std::string::basic_string[abi:ne180100]<0>(v31, "!fixedSize() || ((ogl::Buffer*)obj)->size() == _sz");
            std::string::basic_string[abi:ne180100]<0>(v30, "create");
            std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
            cv::Exception::Exception(&v32, 4294967081, v31, v30, __p, 1388);
            cv::error((cv *)&v32, v27);
          }
        }
        if ((*((unsigned int (**)(cv::gpu::GpuMat **))*a1 + 13))(a1) && *((_DWORD *)a1[2] + 6) != (_DWORD)a3)
        {
          std::string::basic_string[abi:ne180100]<0>(v31, "!fixedType() || ((ogl::Buffer*)obj)->type() == mtype");
          std::string::basic_string[abi:ne180100]<0>(v30, "create");
          std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
          cv::Exception::Exception(&v32, 4294967081, v31, v30, __p, 1389);
          cv::error((cv *)&v32, v28);
        }
        cv::ogl::Buffer::create(a1[2], a2->u32[1], a2->u32[0], a3, 34962, 0);
      }
    }
    else
    {
      if ((*((unsigned int (**)(cv::gpu::GpuMat **))*a1 + 12))(a1))
      {
        if (*((_DWORD *)a1[2] + 2) != a2->i32[0] || *((_DWORD *)a1[2] + 1) != a2->i32[1])
        {
          std::string::basic_string[abi:ne180100]<0>(v31, "!fixedSize() || ((gpu::GpuMat*)obj)->size() == _sz");
          std::string::basic_string[abi:ne180100]<0>(v30, "create");
          std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
          cv::Exception::Exception(&v32, 4294967081, v31, v30, __p, 1381);
          cv::error((cv *)&v32, v24);
        }
      }
      if ((*((unsigned int (**)(cv::gpu::GpuMat **))*a1 + 13))(a1)
        && (*(_DWORD *)a1[2] & 0xFFF) != (_DWORD)a3)
      {
        std::string::basic_string[abi:ne180100]<0>(v31, "!fixedType() || ((gpu::GpuMat*)obj)->type() == mtype");
        std::string::basic_string[abi:ne180100]<0>(v30, "create");
        std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
        cv::Exception::Exception(&v32, 4294967081, v31, v30, __p, 1382);
        cv::error((cv *)&v32, v25);
      }
      cv::gpu::GpuMat::create(a1[2], (void *)a2->u32[1], a2->i32[0], a3);
    }
  }
}

void sub_219E6FD20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,char a28)
{
  cv::Exception::~Exception((cv::Exception *)&a28);
  if (a15 < 0)
    operator delete(__p);
  if (a21 < 0)
    operator delete(a16);
  if (a27 < 0)
    operator delete(a22);
  _Unwind_Resume(a1);
}

void cv::_OutputArray::create(cv::_OutputArray *this, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int v14;
  char v15;
  const cv::Exception *v17;
  const cv::Exception *v18;
  uint64_t v19;
  int v20;
  char v22;
  const cv::Exception *v25;
  const cv::Exception *v26;
  const cv::Exception *v28;
  const cv::Exception *v29;
  void *__p[2];
  void *v31[2];
  void *v32[2];
  int v33;
  int v34;
  uint64_t v35;

  v35 = *MEMORY[0x24BDAC8D0];
  v14 = (*(uint64_t (**)(cv::_OutputArray *))(*(_QWORD *)this + 40))(this);
  if ((_DWORD)a7)
    v15 = 1;
  else
    v15 = a6;
  if ((v15 & 1) == 0 && (a5 & 0x80000000) != 0 && v14 == 0x10000)
  {
    if ((*(unsigned int (**)(cv::_OutputArray *))(*(_QWORD *)this + 96))(this))
    {
      if (*(_DWORD *)(*(_QWORD *)(*((_QWORD *)this + 2) + 64) + 4) != (_DWORD)a3
        || **(_DWORD **)(*((_QWORD *)this + 2) + 64) != (_DWORD)a2)
      {
        std::string::basic_string[abi:ne180100]<0>(v32, "!fixedSize() || ((Mat*)obj)->size.operator()() == Size(cols, rows)");
        std::string::basic_string[abi:ne180100]<0>(v31, "create");
        std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
        cv::Exception::Exception(&v33, 4294967081, v32, v31, __p, 1402);
        cv::error((cv *)&v33, v17);
      }
    }
    if ((*(unsigned int (**)(cv::_OutputArray *))(*(_QWORD *)this + 104))(this)
      && (**((_DWORD **)this + 2) & 0xFFF) != (_DWORD)a4)
    {
      std::string::basic_string[abi:ne180100]<0>(v32, "!fixedType() || ((Mat*)obj)->type() == mtype");
      std::string::basic_string[abi:ne180100]<0>(v31, "create");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
      cv::Exception::Exception(&v33, 4294967081, v32, v31, __p, 1403);
      cv::error((cv *)&v33, v18);
    }
    v19 = *((_QWORD *)this + 2);
    v20 = a4 & 0xFFF;
    if (*(int *)(v19 + 4) > 2
      || *(_DWORD *)(v19 + 8) != (_DWORD)a2
      || *(_DWORD *)(v19 + 12) != (_DWORD)a3
      || (*(_DWORD *)v19 & 0xFFF) != v20
      || !*(_QWORD *)(v19 + 16))
    {
      v33 = (int)a2;
      v34 = a3;
      cv::Mat::create((cv::Mat *)v19, (cv::Mat *)2, &v33, v20);
    }
  }
  else
  {
    if ((int)a5 < 0 && v14 == 589824)
      v22 = v15;
    else
      v22 = 1;
    if ((v22 & 1) != 0)
    {
      if ((int)a5 >= 0 || v14 != 458752)
        v15 = 1;
      if ((v15 & 1) != 0)
      {
        v33 = (int)a2;
        v34 = a3;
        (*(void (**)(cv::_OutputArray *, uint64_t, int *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)this + 144))(this, 2, &v33, a4, a5, a6, a7);
      }
      else
      {
        if ((*(unsigned int (**)(cv::_OutputArray *))(*(_QWORD *)this + 96))(this))
        {
          if (*(_DWORD *)(*((_QWORD *)this + 2) + 20) != (_DWORD)a3
            || *(_DWORD *)(*((_QWORD *)this + 2) + 16) != (_DWORD)a2)
          {
            std::string::basic_string[abi:ne180100]<0>(v32, "!fixedSize() || ((ogl::Buffer*)obj)->size() == Size(cols, rows)");
            std::string::basic_string[abi:ne180100]<0>(v31, "create");
            std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
            cv::Exception::Exception(&v33, 4294967081, v32, v31, __p, 1416);
            cv::error((cv *)&v33, v28);
          }
        }
        if ((*(unsigned int (**)(cv::_OutputArray *))(*(_QWORD *)this + 104))(this)
          && *(_DWORD *)(*((_QWORD *)this + 2) + 24) != (_DWORD)a4)
        {
          std::string::basic_string[abi:ne180100]<0>(v32, "!fixedType() || ((ogl::Buffer*)obj)->type() == mtype");
          std::string::basic_string[abi:ne180100]<0>(v31, "create");
          std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
          cv::Exception::Exception(&v33, 4294967081, v32, v31, __p, 1417);
          cv::error((cv *)&v33, v29);
        }
        cv::ogl::Buffer::create(*((_QWORD *)this + 2), a2, a3, a4, 34962, 0);
      }
    }
    else
    {
      if ((*(unsigned int (**)(cv::_OutputArray *))(*(_QWORD *)this + 96))(this))
      {
        if (*(_DWORD *)(*((_QWORD *)this + 2) + 8) != (_DWORD)a3
          || *(_DWORD *)(*((_QWORD *)this + 2) + 4) != (_DWORD)a2)
        {
          std::string::basic_string[abi:ne180100]<0>(v32, "!fixedSize() || ((gpu::GpuMat*)obj)->size() == Size(cols, rows)");
          std::string::basic_string[abi:ne180100]<0>(v31, "create");
          std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
          cv::Exception::Exception(&v33, 4294967081, v32, v31, __p, 1409);
          cv::error((cv *)&v33, v25);
        }
      }
      if ((*(unsigned int (**)(cv::_OutputArray *))(*(_QWORD *)this + 104))(this)
        && (**((_DWORD **)this + 2) & 0xFFF) != (_DWORD)a4)
      {
        std::string::basic_string[abi:ne180100]<0>(v32, "!fixedType() || ((gpu::GpuMat*)obj)->type() == mtype");
        std::string::basic_string[abi:ne180100]<0>(v31, "create");
        std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
        cv::Exception::Exception(&v33, 4294967081, v32, v31, __p, 1410);
        cv::error((cv *)&v33, v26);
      }
      cv::gpu::GpuMat::create(*((cv::gpu::GpuMat **)this + 2), a2, a3, a4);
    }
  }
}

void sub_219E70394(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,char a28)
{
  cv::Exception::~Exception((cv::Exception *)&a28);
  if (a15 < 0)
    operator delete(__p);
  if (a21 < 0)
    operator delete(a16);
  if (a27 < 0)
    operator delete(a22);
  _Unwind_Resume(a1);
}

void cv::_OutputArray::create(cv::_OutputArray *this, cv::Mat *a2, int *a3, unsigned int a4, signed int a5, int a6, unsigned int a7)
{
  int v14;
  int v15;
  const cv::Exception *v16;
  uint64_t v17;
  void *v18;
  const cv::Exception *v19;
  unsigned int *v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  const cv::Exception *v25;
  const cv::Exception *v26;
  const cv::Exception *v27;
  unint64_t v28;
  int v29;
  int v30;
  const cv::Exception *v31;
  int v32;
  int v33;
  int v34;
  unint64_t v35;
  uint64_t *v36;
  const cv::Exception *v37;
  int v38;
  const cv::Exception *v39;
  const cv::Exception *v40;
  uint64_t v41;
  const cv::Exception *v42;
  const cv::Exception *v43;
  const cv::Exception *v44;
  uint64_t *v45;
  uint64_t v46;
  const cv::Exception *v47;
  unsigned int v48;
  void *v49;
  const cv::Exception *v50;
  uint64_t v51;
  unsigned int *v52;
  _QWORD *v53;
  unsigned int *v54;
  unsigned int v55;
  unsigned int v56;
  uint64_t v57;
  uint64_t v58;
  int *v59;
  int v60;
  uint64_t v61;
  uint64_t v62;
  const cv::Exception *v63;
  const cv::Exception *v64;
  unsigned int v65;
  const cv::Exception *v66;
  int v67;
  int v68;
  const cv::Exception *v69;
  int v70;
  int v71;
  int v72;
  unint64_t v73;
  unint64_t v74;
  const cv::Exception *v75;
  int v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  int *v80;
  uint64_t v81;
  const cv::Exception *v82;
  BOOL v83;
  int v84;
  const cv::Exception *v85;
  const cv::Exception *v86;
  uint64_t v87;
  _QWORD *v88;
  const cv::Exception *v89;
  const cv::Exception *v90;
  unint64_t v91;
  const cv::Exception *v92;
  const cv::Exception *v93;
  void *__p[2];
  void *v95[2];
  void *v96[2];
  _BYTE v97[128];

  v14 = (*(uint64_t (**)(cv::_OutputArray *))(*(_QWORD *)this + 40))(this);
  v15 = a4 & 0xFFF;
  if (v14 == 0x20000)
  {
    if ((a5 & 0x80000000) == 0)
    {
      std::string::basic_string[abi:ne180100]<0>(v96, "i < 0");
      std::string::basic_string[abi:ne180100]<0>(v95, "create");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
      cv::Exception::Exception(v97, 4294967081, v96, v95, __p, 1466);
      cv::error((cv *)v97, v26);
    }
    if (v15 != (*((_DWORD *)this + 2) & 0xFFF) && ((a4 & 0xFF8) != 0 || ((a7 >> *((_DWORD *)this + 2)) & 1) == 0))
    {
      std::string::basic_string[abi:ne180100]<0>(v96, "mtype == type0 || (CV_MAT_CN(mtype) == 1 && ((1 << type0) & fixedDepthMask) != 0)");
      std::string::basic_string[abi:ne180100]<0>(v95, "create");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
      cv::Exception::Exception(v97, 4294967081, v96, v95, __p, 1468);
      cv::error((cv *)v97, v27);
    }
    if ((_DWORD)a2 != 2
      || ((v38 = *((_DWORD *)this + 7), *a3 != v38) || a3[1] != *((_DWORD *)this + 6))
      && (!a6 || *a3 != *((_DWORD *)this + 6) || a3[1] != v38))
    {
      std::string::basic_string[abi:ne180100]<0>(v96, "dims == 2 && ((sizes[0] == sz.height && sizes[1] == sz.width) || (allowTransposed && sizes[0] == sz.width && sizes[1] == sz.height))");
      std::string::basic_string[abi:ne180100]<0>(v95, "create");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
      cv::Exception::Exception(v97, 4294967081, v96, v95, __p, 1470);
      cv::error((cv *)v97, v39);
    }
  }
  else
  {
    if (v14 != 0x10000)
    {
      HIDWORD(v28) = v14;
      LODWORD(v28) = v14;
      switch((v28 >> 16))
      {
        case 0u:
          std::string::basic_string[abi:ne180100]<0>(v96, "create() called for the missing output array");
          std::string::basic_string[abi:ne180100]<0>(v95, "create");
          std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
          cv::Exception::Exception(v97, 4294967269, v96, v95, __p, 1563);
          cv::error((cv *)v97, v63);
        case 3u:
        case 4u:
          if ((_DWORD)a2 != 2 || (v29 = *a3, *a3 != 1) && (v30 = a3[1], v30 != 1) && v30 * v29)
          {
            std::string::basic_string[abi:ne180100]<0>(v96, "dims == 2 && (sizes[0] == 1 || sizes[1] == 1 || sizes[0]*sizes[1] == 0)");
            std::string::basic_string[abi:ne180100]<0>(v95, "create");
            std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
            cv::Exception::Exception(v97, 4294967081, v96, v95, __p, 1476);
            cv::error((cv *)v97, v31);
          }
          v32 = a3[1];
          v33 = v32 * v29;
          v34 = v29 + v32 - 1;
          if (v33 <= 0)
            v34 = 0;
          v35 = v34;
          v36 = (uint64_t *)*((_QWORD *)this + 2);
          if (v14 == 0x40000)
          {
            if (a5 < 0)
            {
              if ((*(unsigned int (**)(cv::_OutputArray *))(*(_QWORD *)this + 96))(this)
                && 0xAAAAAAAAAAAAAAABLL * ((v36[1] - *v36) >> 3) != v35)
              {
                std::string::basic_string[abi:ne180100]<0>(v96, "!fixedSize() || len == vv.size()");
                std::string::basic_string[abi:ne180100]<0>(v95, "create");
                std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
                cv::Exception::Exception(v97, 4294967081, v96, v95, __p, 1485);
                cv::error((cv *)v97, v90);
              }
              std::vector<std::vector<unsigned char>>::resize(v36, v35);
              return;
            }
            if ((int)(-1431655765 * ((unint64_t)(v36[1] - *v36) >> 3)) <= a5)
            {
              std::string::basic_string[abi:ne180100]<0>(v96, "i < (int)vv.size()");
              std::string::basic_string[abi:ne180100]<0>(v95, "create");
              std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
              cv::Exception::Exception(v97, 4294967081, v96, v95, __p, 1489);
              cv::error((cv *)v97, v37);
            }
            v36 = (uint64_t *)(*v36 + 24 * a5);
          }
          else if ((a5 & 0x80000000) == 0)
          {
            std::string::basic_string[abi:ne180100]<0>(v96, "i < 0");
            std::string::basic_string[abi:ne180100]<0>(v95, "create");
            std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
            cv::Exception::Exception(v97, 4294967081, v96, v95, __p, 1493);
            cv::error((cv *)v97, v64);
          }
          v65 = *((_DWORD *)this + 2);
          if (v15 != (v65 & 0xFFF)
            && ((((unsigned __int16)v65 ^ (unsigned __int16)a4) & 0xFF8) != 0 || ((a7 >> *((_DWORD *)this + 2)) & 1) == 0))
          {
            std::string::basic_string[abi:ne180100]<0>(v96, "mtype == type0 || (CV_MAT_CN(mtype) == CV_MAT_CN(type0) && ((1 << type0) & fixedDepthMask) != 0)");
            std::string::basic_string[abi:ne180100]<0>(v95, "create");
            std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
            cv::Exception::Exception(v97, 4294967081, v96, v95, __p, 1496);
            cv::error((cv *)v97, v66);
          }
          v91 = (((v65 >> 3) & 0x1FF) + 1) << ((0xFA50u >> (2 * (v65 & 7))) & 3);
          if ((*(unsigned int (**)(cv::_OutputArray *))(*(_QWORD *)this + 96))(this)
            && (v36[1] - *v36) / v91 != v35)
          {
            std::string::basic_string[abi:ne180100]<0>(v96, "!fixedSize() || len == ((vector<uchar>*)v)->size() / esz");
            std::string::basic_string[abi:ne180100]<0>(v95, "create");
            std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
            cv::Exception::Exception(v97, 4294967081, v96, v95, __p, 1499);
            cv::error((cv *)v97, v92);
          }
          if ((int)v91 <= 23)
          {
            switch((int)v91)
            {
              case 1:
                std::vector<unsigned char>::resize((unint64_t *)v36, v35);
                return;
              case 2:
                std::vector<cv::Vec<unsigned char,2>>::resize((uint64_t)v36, v35);
                return;
              case 3:
                std::vector<cv::Vec<unsigned char,3>>::resize((uint64_t)v36, v35);
                return;
              case 4:
                std::vector<int>::resize((std::vector<int> *)v36, v35);
                return;
              case 6:
                std::vector<cv::Vec<short,3>>::resize((uint64_t)v36, v35);
                return;
              case 8:
                std::vector<cv::Vec<int,2>>::resize((uint64_t)v36, v35);
                return;
              case 12:
                std::vector<cv::Vec<int,3>>::resize((uint64_t)v36, v35);
                return;
              case 16:
                std::vector<cv::Vec<int,4>>::resize((uint64_t)v36, v35);
                return;
              default:
                goto LABEL_177;
            }
          }
          if ((int)v91 > 63)
          {
            if ((int)v91 > 255)
            {
              if ((_DWORD)v91 == 256)
              {
                std::vector<cv::Vec<int,64>>::resize((uint64_t)v36, v35);
                return;
              }
              if ((_DWORD)v91 == 512)
              {
                std::vector<cv::Vec<int,128>>::resize((uint64_t)v36, v35);
                return;
              }
            }
            else
            {
              if ((_DWORD)v91 == 64)
              {
                std::vector<cv::Vec<int,16>>::resize((uint64_t)v36, v35);
                return;
              }
              if ((_DWORD)v91 == 128)
              {
                std::vector<cv::Vec<int,32>>::resize((uint64_t)v36, v35);
                return;
              }
            }
          }
          else if ((int)v91 > 35)
          {
            if ((_DWORD)v91 == 36)
            {
              std::vector<cv::Vec<int,9>>::resize((uint64_t)v36, v35);
              return;
            }
            if ((_DWORD)v91 == 48)
            {
              std::vector<cv::Vec<int,12>>::resize((uint64_t)v36, v35);
              return;
            }
          }
          else
          {
            if ((_DWORD)v91 == 24)
            {
              std::vector<cv::Vec<int,6>>::resize((uint64_t)v36, v35);
              return;
            }
            if ((_DWORD)v91 == 32)
            {
              std::vector<cv::Vec<int,8>>::resize((uint64_t)v36, v35);
              return;
            }
          }
LABEL_177:
          cv::format(v96, (((v65 >> 3) & 0x1FF) + 1) << ((0xFA50u >> (2 * (v65 & 7))) & 3));
          std::string::basic_string[abi:ne180100]<0>(v95, "create");
          std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
          cv::Exception::Exception(v97, 4294967291, v96, v95, __p, 1551);
          cv::error((cv *)v97, v93);
        case 5u:
          v45 = (uint64_t *)*((_QWORD *)this + 2);
          if (a5 < 0)
          {
            if ((_DWORD)a2 != 2 || (v67 = *a3, *a3 != 1) && (v68 = a3[1], v68 != 1) && v68 * v67)
            {
              std::string::basic_string[abi:ne180100]<0>(v96, "dims == 2 && (sizes[0] == 1 || sizes[1] == 1 || sizes[0]*sizes[1] == 0)");
              std::string::basic_string[abi:ne180100]<0>(v95, "create");
              std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
              cv::Exception::Exception(v97, 4294967081, v96, v95, __p, 1574);
              cv::error((cv *)v97, v69);
            }
            v70 = a3[1];
            v71 = v70 * v67;
            v72 = v67 + v70 - 1;
            if (v71 <= 0)
              v72 = 0;
            v73 = v72;
            v74 = 0xAAAAAAAAAAAAAAABLL * ((v45[1] - *v45) >> 5);
            if ((*(unsigned int (**)(cv::_OutputArray *))(*(_QWORD *)this + 96))(this) && v74 != v73)
            {
              std::string::basic_string[abi:ne180100]<0>(v96, "!fixedSize() || len == len0");
              std::string::basic_string[abi:ne180100]<0>(v95, "create");
              std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
              cv::Exception::Exception(v97, 4294967081, v96, v95, __p, 1577);
              cv::error((cv *)v97, v75);
            }
            std::vector<cv::Mat>::resize(v45, v73);
            if ((*(unsigned int (**)(cv::_OutputArray *))(*(_QWORD *)this + 104))(this) && v74 < v73)
            {
              v76 = *((_DWORD *)this + 2) & 0xFFF;
              v77 = *v45;
              do
              {
                if ((*(_DWORD *)(v77 + 96 * v74) & 0xFFF) != v76)
                {
                  if (*(_QWORD *)(v77 + 96 * v74 + 16))
                  {
                    v78 = *(unsigned int *)(v77 + 96 * v74 + 4);
                    if ((int)v78 >= 3)
                    {
                      v80 = *(int **)(v77 + 96 * v74 + 64);
                      v79 = 1;
                      do
                      {
                        v81 = *v80++;
                        v79 *= v81;
                        --v78;
                      }
                      while (v78);
                    }
                    else
                    {
                      v79 = *(int *)(v77 + 96 * v74 + 12) * (uint64_t)*(int *)(v77 + 96 * v74 + 8);
                    }
                    if (v79)
                    {
                      std::string::basic_string[abi:ne180100]<0>(v96, "v[j].empty()");
                      std::string::basic_string[abi:ne180100]<0>(v95, "create");
                      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
                      cv::Exception::Exception(v97, 4294967081, v96, v95, __p, 1586);
                      cv::error((cv *)v97, v82);
                    }
                  }
                  *(_DWORD *)(v77 + 96 * v74) = *(_DWORD *)(v77 + 96 * v74) & 0xFFFFF000 | v76;
                }
                ++v74;
              }
              while (v74 != v73);
            }
          }
          else
          {
            v46 = *v45;
            if ((int)(-1431655765 * ((unint64_t)(v45[1] - *v45) >> 5)) <= a5)
            {
              std::string::basic_string[abi:ne180100]<0>(v96, "i < (int)v.size()");
              std::string::basic_string[abi:ne180100]<0>(v95, "create");
              std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
              cv::Exception::Exception(v97, 4294967081, v96, v95, __p, 1593);
              cv::error((cv *)v97, v47);
            }
            v48 = a5;
            v17 = v46 + 96 * a5;
            if (!a6)
              goto LABEL_180;
            if ((*(_BYTE *)(v17 + 1) & 0x40) != 0)
            {
              LODWORD(v58) = *(_DWORD *)(v46 + 96 * v48 + 4);
            }
            else
            {
              if (((*(uint64_t (**)(cv::_OutputArray *))(*(_QWORD *)this + 104))(this) & 1) != 0
                || (*(unsigned int (**)(cv::_OutputArray *))(*(_QWORD *)this + 96))(this))
              {
                std::string::basic_string[abi:ne180100]<0>(v96, "!fixedType() && !fixedSize()");
                std::string::basic_string[abi:ne180100]<0>(v95, "create");
                std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
                cv::Exception::Exception(v97, 4294967081, v96, v95, __p, 1600);
                cv::error((cv *)v97, v50);
              }
              v51 = v46 + 96 * v48;
              v54 = *(unsigned int **)(v51 + 24);
              v53 = (_QWORD *)(v51 + 24);
              v52 = v54;
              if (v54)
              {
                do
                {
                  v55 = __ldaxr(v52);
                  v56 = v55 - 1;
                }
                while (__stlxr(v56, v52));
                if (!v56)
                  cv::Mat::deallocate((cv::Mat *)v17, v49);
              }
              v57 = v46 + 96 * v48;
              v60 = *(_DWORD *)(v57 + 4);
              v59 = (int *)(v57 + 4);
              LODWORD(v58) = v60;
              *(_QWORD *)(v59 + 3) = 0;
              *(_QWORD *)(v59 + 7) = 0;
              *(_QWORD *)(v59 + 11) = 0;
              *(_QWORD *)(v59 + 9) = 0;
              if (v60 >= 1)
              {
                v61 = 0;
                v62 = *(_QWORD *)(v46 + 96 * v48 + 64);
                do
                {
                  *(_DWORD *)(v62 + 4 * v61++) = 0;
                  v58 = *v59;
                }
                while (v61 < v58);
              }
              *v53 = 0;
            }
            if ((_DWORD)a2 != 2
              || ((_DWORD)v58 == 2 ? (v83 = *(_QWORD *)(v46 + 96 * v48 + 16) == 0) : (v83 = 1),
                  v83
               || (*(_DWORD *)v17 & 0xFFF) != v15
               || *(_DWORD *)(v46 + 96 * v48 + 8) != a3[1]
               || *(_DWORD *)(v46 + 96 * v48 + 12) != *a3))
            {
LABEL_180:
              if ((*(unsigned int (**)(cv::_OutputArray *))(*(_QWORD *)this + 104))(this))
              {
                v84 = (a4 >> 3) & 0x1FF;
                if (v84 == ((*(_DWORD *)v17 >> 3) & 0x1FF) && ((a7 >> *((_DWORD *)this + 2)) & 1) != 0)
                {
                  LOWORD(v15) = *(_DWORD *)v17 & 0xFFF;
                }
                else if ((*(unsigned int (**)(cv::_OutputArray *))(*(_QWORD *)this + 104))(this)
                       && (v84 != ((*(_DWORD *)v17 >> 3) & 0x1FF) || ((a7 >> *((_DWORD *)this + 2)) & 1) == 0))
                {
                  std::string::basic_string[abi:ne180100]<0>(v96, "!fixedType() || (CV_MAT_CN(mtype) == m.channels() && ((1 << CV_MAT_TYPE(flags)) & fixedDepthMask) != 0)");
                  std::string::basic_string[abi:ne180100]<0>(v95, "create");
                  std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
                  cv::Exception::Exception(v97, 4294967081, v96, v95, __p, 1614);
                  cv::error((cv *)v97, v85);
                }
              }
              if ((*(unsigned int (**)(cv::_OutputArray *))(*(_QWORD *)this + 96))(this))
              {
                if (*(_DWORD *)(v46 + 96 * v48 + 4) != (_DWORD)a2)
                {
                  std::string::basic_string[abi:ne180100]<0>(v96, "m.dims == dims");
                  std::string::basic_string[abi:ne180100]<0>(v95, "create");
                  std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
                  cv::Exception::Exception(v97, 4294967081, v96, v95, __p, 1618);
                  cv::error((cv *)v97, v86);
                }
                if ((int)a2 >= 1)
                {
                  v87 = 0;
                  v88 = (_QWORD *)(v46 + 96 * v48 + 64);
                  do
                  {
                    if (*(_DWORD *)(*v88 + v87 * 4) != a3[v87])
                    {
                      std::string::basic_string[abi:ne180100]<0>(v96, "m.size[j] == sizes[j]");
                      std::string::basic_string[abi:ne180100]<0>(v95, "create");
                      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
                      cv::Exception::Exception(v97, 4294967081, v96, v95, __p, 1620);
                      cv::error((cv *)v97, v89);
                    }
                    ++v87;
                  }
                  while (a2 != v87);
                }
              }
              goto LABEL_138;
            }
          }
          return;
        case 0xAu:
          std::string::basic_string[abi:ne180100]<0>(v96, "This method is not implemented for oclMat yet");
          std::string::basic_string[abi:ne180100]<0>(v95, "create");
          std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
          cv::Exception::Exception(v97, 4294967083, v96, v95, __p, 1558);
          cv::error((cv *)v97, v43);
        default:
          std::string::basic_string[abi:ne180100]<0>(v96, "k == STD_VECTOR_MAT");
          std::string::basic_string[abi:ne180100]<0>(v95, "create");
          std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
          cv::Exception::Exception(v97, 4294967081, v96, v95, __p, 1567);
          cv::error((cv *)v97, v44);
      }
    }
    if ((a5 & 0x80000000) == 0)
    {
      std::string::basic_string[abi:ne180100]<0>(v96, "i < 0");
      std::string::basic_string[abi:ne180100]<0>(v95, "create");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
      cv::Exception::Exception(v97, 4294967081, v96, v95, __p, 1432);
      cv::error((cv *)v97, v16);
    }
    v17 = *((_QWORD *)this + 2);
    if (!a6)
      goto LABEL_181;
    if ((*(_BYTE *)(v17 + 1) & 0x40) == 0)
    {
      if (((*(uint64_t (**)(cv::_OutputArray *))(*(_QWORD *)this + 104))(this) & 1) != 0
        || (*(unsigned int (**)(cv::_OutputArray *))(*(_QWORD *)this + 96))(this))
      {
        std::string::basic_string[abi:ne180100]<0>(v96, "!fixedType() && !fixedSize()");
        std::string::basic_string[abi:ne180100]<0>(v95, "create");
        std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
        cv::Exception::Exception(v97, 4294967081, v96, v95, __p, 1438);
        cv::error((cv *)v97, v19);
      }
      v20 = *(unsigned int **)(v17 + 24);
      if (v20)
      {
        do
        {
          v21 = __ldaxr(v20);
          v22 = v21 - 1;
        }
        while (__stlxr(v22, v20));
        if (!v22)
          cv::Mat::deallocate((cv::Mat *)v17, v18);
      }
      *(_QWORD *)(v17 + 16) = 0;
      *(_QWORD *)(v17 + 40) = 0;
      *(_QWORD *)(v17 + 48) = 0;
      *(_QWORD *)(v17 + 32) = 0;
      if (*(int *)(v17 + 4) >= 1)
      {
        v23 = 0;
        v24 = *(_QWORD *)(v17 + 64);
        do
          *(_DWORD *)(v24 + 4 * v23++) = 0;
        while (v23 < *(int *)(v17 + 4));
      }
      *(_QWORD *)(v17 + 24) = 0;
    }
    if ((_DWORD)a2 != 2
      || *(_DWORD *)(v17 + 4) != 2
      || !*(_QWORD *)(v17 + 16)
      || (*(_DWORD *)v17 & 0xFFF) != v15
      || *(_DWORD *)(v17 + 8) != a3[1]
      || *(_DWORD *)(v17 + 12) != *a3)
    {
LABEL_181:
      if ((*(unsigned int (**)(cv::_OutputArray *))(*(_QWORD *)this + 104))(this))
      {
        if ((((unsigned __int16)*(_DWORD *)v17 ^ (unsigned __int16)a4) & 0xFF8) != 0
          || ((a7 >> *((_DWORD *)this + 2)) & 1) == 0)
        {
          if (v15 != (*(_DWORD *)v17 & 0xFFF))
          {
            std::string::basic_string[abi:ne180100]<0>(v96, "CV_MAT_TYPE(mtype) == m.type()");
            std::string::basic_string[abi:ne180100]<0>(v95, "create");
            std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
            cv::Exception::Exception(v97, 4294967081, v96, v95, __p, 1452);
            cv::error((cv *)v97, v25);
          }
        }
        else
        {
          LOWORD(v15) = *(_DWORD *)v17 & 0xFFF;
        }
      }
      if ((*(unsigned int (**)(cv::_OutputArray *))(*(_QWORD *)this + 96))(this))
      {
        if (*(_DWORD *)(v17 + 4) != (_DWORD)a2)
        {
          std::string::basic_string[abi:ne180100]<0>(v96, "m.dims == dims");
          std::string::basic_string[abi:ne180100]<0>(v95, "create");
          std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
          cv::Exception::Exception(v97, 4294967081, v96, v95, __p, 1456);
          cv::error((cv *)v97, v40);
        }
        if ((int)a2 >= 1)
        {
          v41 = 0;
          do
          {
            if (*(_DWORD *)(*(_QWORD *)(v17 + 64) + v41 * 4) != a3[v41])
            {
              std::string::basic_string[abi:ne180100]<0>(v96, "m.size[j] == sizes[j]");
              std::string::basic_string[abi:ne180100]<0>(v95, "create");
              std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
              cv::Exception::Exception(v97, 4294967081, v96, v95, __p, 1458);
              cv::error((cv *)v97, v42);
            }
            ++v41;
          }
          while (a2 != v41);
        }
      }
LABEL_138:
      cv::Mat::create((cv::Mat *)v17, a2, a3, v15);
    }
  }
}

void sub_219E71B14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,char a28)
{
  cv::Exception::~Exception((cv::Exception *)&a28);
  if (a15 < 0)
    operator delete(__p);
  if (a21 < 0)
    operator delete(a16);
  if (a27 < 0)
    operator delete(a22);
  _Unwind_Resume(a1);
}

void std::vector<std::vector<unsigned char>>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  void *v10;

  v3 = a1[1];
  v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<std::vector<unsigned char>>::__append(a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 24 * a2;
    if (v3 != v7)
    {
      v8 = a1[1];
      do
      {
        v10 = *(void **)(v8 - 24);
        v8 -= 24;
        v9 = v10;
        if (v10)
        {
          *(_QWORD *)(v3 - 16) = v9;
          operator delete(v9);
        }
        v3 = v8;
      }
      while (v8 != v7);
    }
    a1[1] = v7;
  }
}

void std::vector<unsigned char>::resize(unint64_t *a1, unint64_t a2)
{
  unint64_t v2;
  BOOL v3;
  size_t v4;

  v2 = a1[1] - *a1;
  v3 = a2 >= v2;
  v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<unsigned char>::__append(a1, v4);
  }
  else if (!v3)
  {
    a1[1] = *a1 + a2;
  }
}

void std::vector<cv::Vec<unsigned char,2>>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 1;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 2 * a2;
  }
  else
  {
    std::vector<cv::Vec<unsigned char,2>>::__append((char **)a1, a2 - v2);
  }
}

void std::vector<cv::Vec<unsigned char,3>>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;

  v2 = 0xAAAAAAAAAAAAAAABLL * (*(_QWORD *)(a1 + 8) - *(_QWORD *)a1);
  v3 = a2 >= v2;
  v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<cv::Vec<unsigned char,3>>::__append((char **)a1, v4);
  }
  else if (!v3)
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 3 * a2;
  }
}

void std::vector<cv::Vec<short,3>>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;

  v2 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 1);
  v3 = a2 >= v2;
  v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<cv::Vec<short,3>>::__append((char **)a1, v4);
  }
  else if (!v3)
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 6 * a2;
  }
}

void std::vector<cv::Vec<int,2>>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 8 * a2;
  }
  else
  {
    std::vector<cv::Vec<int,2>>::__append((void **)a1, a2 - v2);
  }
}

void std::vector<cv::Vec<int,3>>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;

  v2 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2);
  v3 = a2 >= v2;
  v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<cv::Vec<int,3>>::__append((char **)a1, v4);
  }
  else if (!v3)
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 12 * a2;
  }
}

void std::vector<cv::Vec<int,4>>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 4;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 16 * a2;
  }
  else
  {
    std::vector<cv::Vec<int,4>>::__append((char **)a1, a2 - v2);
  }
}

void std::vector<cv::Vec<int,6>>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;

  v2 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3);
  v3 = a2 >= v2;
  v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<cv::Vec<int,6>>::__append((char **)a1, v4);
  }
  else if (!v3)
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 24 * a2;
  }
}

void std::vector<cv::Vec<int,8>>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 5;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 32 * a2;
  }
  else
  {
    std::vector<cv::Vec<int,8>>::__append((char **)a1, a2 - v2);
  }
}

void std::vector<cv::Vec<int,9>>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;

  v2 = 0x8E38E38E38E38E39 * ((uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2);
  v3 = a2 >= v2;
  v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<cv::Vec<int,9>>::__append((char **)a1, v4);
  }
  else if (!v3)
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 36 * a2;
  }
}

void std::vector<cv::Vec<int,12>>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;

  v2 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 4);
  v3 = a2 >= v2;
  v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<cv::Vec<int,12>>::__append((char **)a1, v4);
  }
  else if (!v3)
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 48 * a2;
  }
}

void std::vector<cv::Vec<int,16>>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 6;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + (a2 << 6);
  }
  else
  {
    std::vector<cv::Vec<int,16>>::__append((char **)a1, a2 - v2);
  }
}

void std::vector<cv::Vec<int,32>>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 7;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + (a2 << 7);
  }
  else
  {
    std::vector<cv::Vec<int,32>>::__append((char **)a1, a2 - v2);
  }
}

void std::vector<cv::Vec<int,64>>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 8;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + (a2 << 8);
  }
  else
  {
    std::vector<cv::Vec<int,64>>::__append((char **)a1, a2 - v2);
  }
}

void std::vector<cv::Vec<int,128>>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 9;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + (a2 << 9);
  }
  else
  {
    std::vector<cv::Vec<int,128>>::__append((char **)a1, a2 - v2);
  }
}

void cv::_OutputArray::release(cv::_OutputArray *this)
{
  const cv::Exception *v2;
  void *v3;
  unint64_t v4;
  uint64_t v5;
  unsigned int *v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  const cv::Exception *v11;
  const cv::Exception *v12;
  cv::Mat **v13;
  cv::Mat *v14;
  cv::Mat *v15;
  uint64_t v16;
  void *__p[2];
  void *v18[2];
  void *v19[2];
  _BYTE v20[120];

  if ((*(unsigned int (**)(cv::_OutputArray *))(*(_QWORD *)this + 96))(this))
  {
    std::string::basic_string[abi:ne180100]<0>(v19, "!fixedSize()");
    std::string::basic_string[abi:ne180100]<0>(v18, "release");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
    cv::Exception::Exception(v20, 4294967081, v19, v18, __p, 1629);
    cv::error((cv *)v20, v2);
  }
  HIDWORD(v4) = (*(uint64_t (**)(cv::_OutputArray *))(*(_QWORD *)this + 40))(this);
  LODWORD(v4) = HIDWORD(v4);
  switch((v4 >> 16))
  {
    case 0u:
      return;
    case 1u:
      v5 = *((_QWORD *)this + 2);
      v6 = *(unsigned int **)(v5 + 24);
      if (v6)
      {
        do
        {
          v7 = __ldaxr(v6);
          v8 = v7 - 1;
        }
        while (__stlxr(v8, v6));
        if (!v8)
          cv::Mat::deallocate((cv::Mat *)v5, v3);
      }
      *(_QWORD *)(v5 + 16) = 0;
      *(_QWORD *)(v5 + 40) = 0;
      *(_QWORD *)(v5 + 48) = 0;
      *(_QWORD *)(v5 + 32) = 0;
      if (*(int *)(v5 + 4) >= 1)
      {
        v9 = 0;
        v10 = *(_QWORD *)(v5 + 64);
        do
          *(_DWORD *)(v10 + 4 * v9++) = 0;
        while (v9 < *(int *)(v5 + 4));
      }
      *(_QWORD *)(v5 + 24) = 0;
      break;
    case 3u:
      v16 = 0;
      (*(void (**)(cv::_OutputArray *, uint64_t *, _QWORD, uint64_t, _QWORD, _QWORD))(*(_QWORD *)this + 128))(this, &v16, *((_DWORD *)this + 2) & 0xFFF, 0xFFFFFFFFLL, 0, 0);
      break;
    case 4u:
      std::vector<std::vector<long long>>::__clear[abi:ne180100](*((uint64_t **)this + 2));
      break;
    case 5u:
      v13 = (cv::Mat **)*((_QWORD *)this + 2);
      v15 = *v13;
      v14 = v13[1];
      if (v14 != *v13)
      {
        do
        {
          v14 = (cv::Mat *)((char *)v14 - 96);
          std::allocator<cv::Mat>::destroy[abi:ne180100]((_DWORD)v13 + 16, v14);
        }
        while (v14 != v15);
      }
      v13[1] = v15;
      break;
    case 7u:
    case 8u:
      cv::BaseRowFilter::~BaseRowFilter(*((cv::BaseRowFilter **)this + 2));
      break;
    case 9u:
      cv::gpu::GpuMat::release(*((cv::gpu::GpuMat **)this + 2), v3);
      break;
    case 0xAu:
      std::string::basic_string[abi:ne180100]<0>(v19, "This method is not implemented for oclMat yet");
      std::string::basic_string[abi:ne180100]<0>(v18, "release");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
      cv::Exception::Exception(v20, 4294967083, v19, v18, __p, 1674);
      cv::error((cv *)v20, v11);
    default:
      std::string::basic_string[abi:ne180100]<0>(v19, "k == STD_VECTOR_MAT");
      std::string::basic_string[abi:ne180100]<0>(v18, "release");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
      cv::Exception::Exception(v20, 4294967081, v19, v18, __p, 1677);
      cv::error((cv *)v20, v12);
  }
}

void sub_219E723C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,char a29)
{
  cv::Exception::~Exception((cv::Exception *)&a29);
  if (a16 < 0)
    operator delete(__p);
  if (a22 < 0)
    operator delete(a17);
  if (a28 < 0)
    operator delete(a23);
  _Unwind_Resume(a1);
}

void cv::_OutputArray::clear(cv::Mat **this)
{
  int v2;
  cv::Mat *v3;
  const cv::Exception *v4;
  void *__p[2];
  void *v6[2];
  void *v7[2];
  _BYTE v8[120];

  v2 = (*((uint64_t (**)(cv::Mat **))*this + 5))(this);
  v3 = *this;
  if (v2 == 0x10000)
  {
    if ((*((unsigned int (**)(cv::Mat **))v3 + 12))(this))
    {
      std::string::basic_string[abi:ne180100]<0>(v7, "!fixedSize()");
      std::string::basic_string[abi:ne180100]<0>(v6, "clear");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
      cv::Exception::Exception(v8, 4294967081, v7, v6, __p, 1690);
      cv::error((cv *)v8, v4);
    }
    cv::Mat::resize(this[2], 0);
  }
  else
  {
    (*((void (**)(cv::Mat **))v3 + 19))(this);
  }
}

void sub_219E7253C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

BOOL cv::_OutputArray::needed(cv::_OutputArray *this)
{
  return (*(unsigned int (**)(cv::_OutputArray *))(*(_QWORD *)this + 40))(this) != 0;
}

uint64_t cv::_OutputArray::getMatRef(cv::_OutputArray *this, signed int a2)
{
  int v4;
  const cv::Exception *v5;
  _QWORD *v6;
  const cv::Exception *v7;
  const cv::Exception *v9;
  void *__p[2];
  void *v11[2];
  void *v12[2];
  _BYTE v13[120];

  v4 = (*(uint64_t (**)(cv::_OutputArray *))(*(_QWORD *)this + 40))(this);
  if (a2 < 0)
  {
    if (v4 != 0x10000)
    {
      std::string::basic_string[abi:ne180100]<0>(v12, "k == MAT");
      std::string::basic_string[abi:ne180100]<0>(v11, "getMatRef");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
      cv::Exception::Exception(v13, 4294967081, v12, v11, __p, 1708);
      cv::error((cv *)v13, v9);
    }
    return *((_QWORD *)this + 2);
  }
  else
  {
    if (v4 != 327680)
    {
      std::string::basic_string[abi:ne180100]<0>(v12, "k == STD_VECTOR_MAT");
      std::string::basic_string[abi:ne180100]<0>(v11, "getMatRef");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
      cv::Exception::Exception(v13, 4294967081, v12, v11, __p, 1713);
      cv::error((cv *)v13, v5);
    }
    v6 = (_QWORD *)*((_QWORD *)this + 2);
    if ((int)(-1431655765 * ((v6[1] - *v6) >> 5)) <= a2)
    {
      std::string::basic_string[abi:ne180100]<0>(v12, "i < (int)v.size()");
      std::string::basic_string[abi:ne180100]<0>(v11, "getMatRef");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
      cv::Exception::Exception(v13, 4294967081, v12, v11, __p, 1715);
      cv::error((cv *)v13, v7);
    }
    return *v6 + 96 * a2;
  }
}

void sub_219E727E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

uint64_t (***cv::noArray(cv *this))(cv::_InputArray *__hidden this, int)
{
  return &cv::_none;
}

void cv::setIdentity(void (***a1)(uint64_t *__return_ptr, _QWORD, uint64_t), int64x2_t *a2)
{
  void *v3;
  const cv::Exception *v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  float v9;
  float *v10;
  uint64_t v11;
  float *v12;
  uint64_t v13;
  uint64_t v14;
  double v15;
  uint64x2_t v16;
  int64x2_t v17;
  float *v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  int64x2_t v22;
  int32x2_t v23;
  double v24;
  double v25;
  unsigned int *v26;
  unsigned int v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int *v31;
  unsigned int v32;
  unsigned int v33;
  uint64_t v34;
  uint64_t v35;
  void *__p[2];
  void *v37[2];
  void *v38[2];
  int64x2_t v39;
  __int128 v40;
  cv *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  cv *v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  unsigned int v50;
  float *v51;
  unsigned int *v52;
  void **v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  void **v58;
  unint64_t v59;

  (**a1)(&v48, a1, 0xFFFFFFFFLL);
  if (SHIDWORD(v48) >= 3)
  {
    std::string::basic_string[abi:ne180100]<0>(v38, "m.dims <= 2");
    std::string::basic_string[abi:ne180100]<0>(v37, "setIdentity");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
    cv::Exception::Exception(&v39, 4294967081, v38, v37, __p, 1834);
    cv::error((cv *)&v39, v4);
  }
  v5 = v49;
  v6 = v50;
  v7 = v50;
  if ((v48 & 0xFFF) == 6)
  {
    if (v49 >= 1)
    {
      v13 = 0;
      v14 = 0;
      v15 = *(double *)a2->i64;
      v16 = (uint64x2_t)vdupq_n_s64((unint64_t)v50 - 1);
      v17 = vdupq_n_s64(2uLL);
      v18 = v51;
      v19 = (8 * v50 + 8) & 0xFFFFFFFF0;
      v20 = 8 * (v59 >> 3);
      do
      {
        if (v7 >= 1)
        {
          v21 = 0;
          v22 = (int64x2_t)xmmword_219EA07C0;
          do
          {
            v23 = vmovn_s64((int64x2_t)vcgeq_u64(v16, (uint64x2_t)v22));
            if ((v23.i8[0] & 1) != 0)
            {
              if (v13 == v21)
                v24 = v15;
              else
                v24 = 0.0;
              *(double *)&v18[v21 / 4] = v24;
            }
            if ((v23.i8[4] & 1) != 0)
            {
              if (v13 - 8 == v21)
                v25 = v15;
              else
                v25 = 0.0;
              *(double *)&v18[v21 / 4 + 2] = v25;
            }
            v22 = vaddq_s64(v22, v17);
            v21 += 16;
          }
          while (v19 != v21);
        }
        ++v14;
        v13 += 8;
        v18 = (float *)((char *)v18 + v20);
      }
      while (v14 != v5);
    }
  }
  else if ((v48 & 0xFFF) == 5)
  {
    if (v49 >= 1)
    {
      v8 = 0;
      v9 = *(double *)a2->i64;
      v10 = v51;
      v11 = 4 * (v59 >> 2);
      v12 = v51;
      do
      {
        if ((int)v6 >= 1)
          bzero(v10, 4 * v6);
        if (v8 < (int)v6)
          *v12 = v9;
        ++v8;
        v12 = (float *)((char *)v12 + v11 + 4);
        v10 = (float *)((char *)v10 + v11);
      }
      while (v5 != v8);
    }
  }
  else
  {
    v39 = 0u;
    v40 = 0u;
    cv::Mat::operator=((uint64_t)&v48, &v39);
    cv::Mat::diag((cv::Mat *)&v48, 0, (uint64_t)&v39);
    cv::Mat::operator=((uint64_t)&v39, a2);
    v26 = (unsigned int *)*((_QWORD *)&v40 + 1);
    if (*((_QWORD *)&v40 + 1))
    {
      do
      {
        v27 = __ldaxr(v26);
        v28 = v27 - 1;
      }
      while (__stlxr(v28, v26));
      if (!v28)
      {
        if (v44)
          (*(void (**)(uint64_t, _QWORD, cv *, _QWORD))(*(_QWORD *)v44 + 24))(v44, *((_QWORD *)&v40 + 1), v41, v40);
        else
          cv::fastFree((void **)v41, v3);
      }
    }
    *(_QWORD *)&v40 = 0;
    v41 = 0;
    v42 = 0;
    v43 = 0;
    if (v39.i32[1] >= 1)
    {
      v29 = 0;
      v30 = v45;
      do
        *(_DWORD *)(v30 + 4 * v29++) = 0;
      while (v29 < v39.i32[1]);
    }
    *((_QWORD *)&v40 + 1) = 0;
    if (v46 != (cv *)&v47)
      cv::fastFree((void **)v46, v3);
  }
  v31 = v52;
  if (v52)
  {
    do
    {
      v32 = __ldaxr(v31);
      v33 = v32 - 1;
    }
    while (__stlxr(v33, v31));
    if (!v33)
    {
      if (v56)
        (*(void (**)(uint64_t, unsigned int *, void **, float *))(*(_QWORD *)v56 + 24))(v56, v52, v53, v51);
      else
        cv::fastFree(v53, v3);
    }
  }
  v51 = 0;
  v53 = 0;
  v54 = 0;
  v55 = 0;
  if (SHIDWORD(v48) >= 1)
  {
    v34 = 0;
    v35 = v57;
    do
      *(_DWORD *)(v35 + 4 * v34++) = 0;
    while (v34 < SHIDWORD(v48));
  }
  v52 = 0;
  if (v58 != (void **)&v59)
    cv::fastFree(v58, v3);
}

void sub_219E72C04(_Unwind_Exception *a1, void *a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,char a28)
{
  uint64_t v28;
  void *v30;

  cv::Mat::~Mat((cv::Mat *)&a28, a2);
  cv::Mat::~Mat((cv::Mat *)(v28 - 192), v30);
  _Unwind_Resume(a1);
}

void cv::transpose(cv *this, const cv::_InputArray *a2, const cv::_OutputArray *a3)
{
  unint64_t v4;
  const cv::Exception *v5;
  unint64_t v6;
  const cv::Exception *v7;
  void *v8;
  BOOL v9;
  const cv::Exception *v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  _DWORD *v15;
  unsigned int *v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  _DWORD *v20;
  const cv::Exception *v21;
  void *v22[2];
  void *v23;
  int v24;
  int v25;
  uint64_t v26;
  unsigned int *v27;
  cv *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _DWORD *v32;
  cv *v33;
  uint64_t v34;
  void *__p[2];
  void *v36[2];
  uint64_t (**v37)(cv::_InputArray *__hidden, int);
  int v38;
  void **v39;
  uint64_t v40;
  uint64_t v41;
  unsigned int v42;
  unsigned int v43;
  uint64_t v44;
  unsigned int *v45;
  void **v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  _DWORD *v50;
  void **v51;
  uint64_t v52;

  (**(void (***)(uint64_t *__return_ptr, cv *, uint64_t, const cv::_OutputArray *))this)(&v41, this, 0xFFFFFFFFLL, a3);
  if (SHIDWORD(v41) < 1)
    v4 = 0;
  else
    v4 = (unint64_t)v51[HIDWORD(v41) - 1];
  if (SHIDWORD(v41) > 2 || v4 >= 0x21)
  {
    std::string::basic_string[abi:ne180100]<0>(&v23, "src.dims <= 2 && esz <= (size_t)32");
    std::string::basic_string[abi:ne180100]<0>(v36, "transpose");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
    cv::Exception::Exception(&v37, 4294967081, &v23, v36, __p, 2017);
    cv::error((cv *)&v37, v5);
  }
  (*(void (**)(const cv::_InputArray *, _QWORD, _QWORD, uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 136))(a2, v43, v42, v41 & 0xFFF, 0xFFFFFFFFLL, 0, 0);
  (**(void (***)(void **__return_ptr, const cv::_InputArray *, uint64_t))a2)(&v23, a2, 0xFFFFFFFFLL);
  if (v42 == v25 && v43 == v24)
  {
    v6 = 0xFEFEEEA1uLL >> v4;
    if (v26 == v44)
    {
      if ((v6 & 1) != 0)
      {
        std::string::basic_string[abi:ne180100]<0>(v36, "func != 0");
        std::string::basic_string[abi:ne180100]<0>(__p, "transpose");
        std::string::basic_string[abi:ne180100]<0>(v22, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
        cv::Exception::Exception(&v37, 4294967081, v36, __p, v22, 2033);
        cv::error((cv *)&v37, v21);
      }
      cv::transposeInplaceTab[v4](v26, v34, v43);
    }
    else
    {
      if ((v6 & 1) != 0)
      {
        std::string::basic_string[abi:ne180100]<0>(v36, "func != 0");
        std::string::basic_string[abi:ne180100]<0>(__p, "transpose");
        std::string::basic_string[abi:ne180100]<0>(v22, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
        cv::Exception::Exception(&v37, 4294967081, v36, __p, v22, 2039);
        cv::error((cv *)&v37, v7);
      }
      cv::transposeTab[v4]();
    }
  }
  else
  {
    v9 = v50[1] == v32[1] && *v50 == *v32;
    if (!v9 || v42 != 1 && v43 != 1)
    {
      std::string::basic_string[abi:ne180100]<0>(v36, "src.size() == dst.size() && (src.cols == 1 || src.rows == 1)");
      std::string::basic_string[abi:ne180100]<0>(__p, "transpose");
      std::string::basic_string[abi:ne180100]<0>(v22, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
      cv::Exception::Exception(&v37, 4294967081, v36, __p, v22, 2025);
      cv::error((cv *)&v37, v10);
    }
    v38 = 0x10000;
    v39 = &v23;
    v40 = 0;
    v37 = &off_24DBF02F0;
    cv::Mat::copyTo((cv::Mat *)&v41, (const cv::_OutputArray *)&v37);
  }
  v11 = v27;
  if (v27)
  {
    do
    {
      v12 = __ldaxr(v11);
      v13 = v12 - 1;
    }
    while (__stlxr(v13, v11));
    if (!v13)
    {
      if (v31)
        (*(void (**)(uint64_t, unsigned int *, cv *, uint64_t))(*(_QWORD *)v31 + 24))(v31, v27, v28, v26);
      else
        cv::fastFree((void **)v28, v8);
    }
  }
  v26 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  if (SHIDWORD(v23) >= 1)
  {
    v14 = 0;
    v15 = v32;
    do
      v15[v14++] = 0;
    while (v14 < SHIDWORD(v23));
  }
  v27 = 0;
  if (v33 != (cv *)&v34)
    cv::fastFree((void **)v33, v8);
  v16 = v45;
  if (v45)
  {
    do
    {
      v17 = __ldaxr(v16);
      v18 = v17 - 1;
    }
    while (__stlxr(v18, v16));
    if (!v18)
    {
      if (v49)
        (*(void (**)(uint64_t, unsigned int *, void **, uint64_t))(*(_QWORD *)v49 + 24))(v49, v45, v46, v44);
      else
        cv::fastFree(v46, v8);
    }
  }
  v44 = 0;
  v46 = 0;
  v47 = 0;
  v48 = 0;
  if (SHIDWORD(v41) >= 1)
  {
    v19 = 0;
    v20 = v50;
    do
      v20[v19++] = 0;
    while (v19 < SHIDWORD(v41));
  }
  v45 = 0;
  if (v51 != (void **)&v52)
    cv::fastFree(v51, v8);
}

void sub_219E7318C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,char a44)
{
  uint64_t v44;
  void *v46;
  void *v47;

  cv::Exception::~Exception((cv::Exception *)&a44);
  if (a16 < 0)
    operator delete(__p);
  if (a37 < 0)
    operator delete(a32);
  if (a43 < 0)
    operator delete(a38);
  cv::Mat::~Mat((cv::Mat *)&a17, v46);
  cv::Mat::~Mat((cv::Mat *)(v44 - 128), v47);
  _Unwind_Resume(a1);
}

void cv::completeSymm(cv *this, const cv::_OutputArray *a2)
{
  void *v2;
  uint64_t v3;
  size_t v4;
  int v5;
  const cv::Exception *v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  char *v12;
  uint64_t v13;
  unsigned int *v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  void *__p[2];
  void *v22[2];
  void *v23[2];
  _BYTE v24[120];
  uint64_t v25;
  int v26;
  int v27;
  uint64_t v28;
  unsigned int *v29;
  void **v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void **v35;
  uint64_t v36;

  v20 = (int)a2;
  (**(void (***)(uint64_t *__return_ptr, cv *, uint64_t))this)(&v25, this, 0xFFFFFFFFLL);
  v3 = v36;
  if (SHIDWORD(v25) < 1)
  {
    v4 = 0;
  }
  else
  {
    v4 = (size_t)v35[HIDWORD(v25) - 1];
    if (HIDWORD(v25) > 2)
    {
LABEL_6:
      std::string::basic_string[abi:ne180100]<0>(v23, "m.dims <= 2 && m.rows == m.cols");
      std::string::basic_string[abi:ne180100]<0>(v22, "completeSymm");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
      cv::Exception::Exception(v24, 4294967081, v23, v22, __p, 2051);
      cv::error((cv *)v24, v6);
    }
  }
  v5 = v26;
  if (v26 != v27)
    goto LABEL_6;
  if (v26 >= 1)
  {
    v7 = 0;
    v8 = 0;
    v9 = v28;
    v19 = v26;
    v10 = v28;
    do
    {
      if (!v20)
        v5 = v7;
      ++v7;
      if (v20)
        v8 = v7;
      if (v8 < v5)
      {
        v11 = (char *)(v10 + v4 * v8);
        v12 = (char *)(v9 + v3 * v8);
        v13 = v5 - (uint64_t)v8;
        do
        {
          memcpy(v11, v12, v4);
          v11 += v4;
          v12 += v3;
          --v13;
        }
        while (v13);
      }
      v10 += v3;
      v9 += v4;
    }
    while (v7 != v19);
  }
  v14 = v29;
  if (v29)
  {
    do
    {
      v15 = __ldaxr(v14);
      v16 = v15 - 1;
    }
    while (__stlxr(v16, v14));
    if (!v16)
    {
      if (v33)
        (*(void (**)(uint64_t, unsigned int *, void **, uint64_t))(*(_QWORD *)v33 + 24))(v33, v29, v30, v28);
      else
        cv::fastFree(v30, v2);
    }
  }
  v28 = 0;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  if (SHIDWORD(v25) >= 1)
  {
    v17 = 0;
    v18 = v34;
    do
      *(_DWORD *)(v18 + 4 * v17++) = 0;
    while (v17 < SHIDWORD(v25));
  }
  v29 = 0;
  if (v35 != (void **)&v36)
    cv::fastFree(v35, v2);
}

void sub_219E734D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,char a30)
{
  uint64_t v30;
  void *v32;

  cv::Exception::~Exception((cv::Exception *)&a30);
  if (a17 < 0)
    operator delete(__p);
  if (a23 < 0)
    operator delete(a18);
  if (a29 < 0)
    operator delete(a24);
  cv::Mat::~Mat((cv::Mat *)(v30 - 184), v32);
  _Unwind_Resume(a1);
}

void cv::NAryMatIterator::init(cv::NAryMatIterator *this, const cv::Mat **a2, unint64_t a3, unint64_t a4, int a5)
{
  uint64_t v5;
  const cv::Mat **v6;
  const cv::Exception *v8;
  uint64_t v9;
  const cv::Exception *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  const cv::Exception *v16;
  uint64_t v17;
  _DWORD *v18;
  unint64_t v19;
  _DWORD *v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  int v24;
  int v25;
  const cv::Exception *v26;
  uint64_t v27;
  int v28;
  BOOL v29;
  int v30;
  uint64_t v31;
  int v32;
  const cv::Exception *v33;
  uint64_t v34;
  int v35;
  int v36;
  unint64_t v37;
  unint64_t v38;
  int v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t *v51;
  BOOL v52;
  uint64_t i;
  int *v54;
  const cv::Exception *v55;
  unint64_t v56;
  uint64_t v57;
  unsigned int v58;
  uint64_t v59;
  _OWORD *v60;
  uint64_t v61;
  unsigned int *v62;
  _QWORD *v63;
  unsigned int *v64;
  unsigned int v65;
  unsigned int v66;
  uint64_t v67;
  uint64_t v68;
  int *v69;
  int v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  _OWORD *v75;
  uint64_t v76;
  unsigned int *v77;
  _QWORD *v78;
  unsigned int *v79;
  unsigned int v80;
  unsigned int v81;
  uint64_t v82;
  uint64_t v83;
  int *v84;
  int v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  cv *v90;
  _QWORD *v91;
  uint64_t v92;
  unsigned int *v93;
  unsigned int v94;
  unsigned int v95;
  uint64_t v96;
  cv *v97;
  _QWORD *v98;
  uint64_t v99;
  unsigned int *v100;
  unsigned int v101;
  unsigned int v102;
  uint64_t v103;
  char *v104;
  void **v105;
  uint64_t v106;
  char *v107;
  void *__p[2];
  void *v109[2];
  void *v110[2];
  _OWORD v111[4];
  char *v112;
  cv *v113;
  uint64_t v114;
  uint64_t v115;

  LODWORD(v5) = a5;
  v6 = a2;
  if (!a2 || !(a3 | a4))
  {
    std::string::basic_string[abi:ne180100]<0>(v110, "_arrays && (_ptrs || _planes)");
    std::string::basic_string[abi:ne180100]<0>(v109, "init");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
    cv::Exception::Exception(v111, 4294967081, v110, v109, __p, 3165);
    cv::error((cv *)v111, v8);
  }
  *((_QWORD *)this + 1) = a3;
  *((_QWORD *)this + 2) = a4;
  *(_QWORD *)this = a2;
  *((_DWORD *)this + 6) = a5;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  if (a5 < 0)
  {
    LODWORD(v5) = -1;
    do
    {
      v9 = (uint64_t)*v6++;
      LODWORD(v5) = v5 + 1;
    }
    while (v9);
    *((_DWORD *)this + 6) = v5;
    if (v5 >= 0x3E9)
    {
      std::string::basic_string[abi:ne180100]<0>(v110, "narrays <= 1000");
      std::string::basic_string[abi:ne180100]<0>(v109, "init");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
      cv::Exception::Exception(v111, 4294967081, v110, v109, __p, 3180);
      cv::error((cv *)v111, v10);
    }
  }
  *((_DWORD *)this + 12) = 0;
  if ((int)v5 < 1)
    goto LABEL_60;
  v11 = 0;
  LODWORD(v12) = 0;
  v13 = -1;
  v14 = 0xFFFFFFFFLL;
  do
  {
    v15 = *(_QWORD *)(*(_QWORD *)this + 8 * v11);
    if (!v15)
    {
      std::string::basic_string[abi:ne180100]<0>(v110, "arrays[i] != 0");
      std::string::basic_string[abi:ne180100]<0>(v109, "init");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
      cv::Exception::Exception(v111, 4294967081, v110, v109, __p, 3187);
      cv::error((cv *)v111, v16);
    }
    v17 = *((_QWORD *)this + 2);
    if (v17)
      *(_QWORD *)(v17 + 8 * v11) = *(_QWORD *)(v15 + 16);
    if (*(_QWORD *)(v15 + 16))
    {
      if ((v14 & 0x80000000) != 0)
      {
        v12 = *(unsigned int *)(v15 + 4);
        v14 = v11;
        if ((int)v12 <= 0)
        {
          v13 = *(_DWORD *)(v15 + 4);
          LODWORD(v12) = 0;
        }
        else
        {
          v21 = 0;
          while (*(int *)(*(_QWORD *)(v15 + 64) + 4 * v21) <= 1)
          {
            if (v12 == ++v21)
            {
              v13 = *(_DWORD *)(v15 + 4);
              goto LABEL_36;
            }
          }
          v13 = *(_DWORD *)(v15 + 4);
          LODWORD(v12) = v21;
        }
      }
      else
      {
        v18 = *(_DWORD **)(v15 + 64);
        v19 = *(v18 - 1);
        v20 = *(_DWORD **)(*(_QWORD *)(*(_QWORD *)this + 8 * v14) + 64);
        if ((_DWORD)v19 != *(v20 - 1))
          goto LABEL_33;
        if ((_DWORD)v19 == 2)
        {
          if (*v18 != *v20 || v18[1] != v20[1])
            goto LABEL_33;
        }
        else if ((int)v19 >= 1)
        {
          if (*v18 != *v20)
            goto LABEL_33;
          v22 = 1;
          do
          {
            v23 = v22;
            if (v19 == v22)
              break;
            v24 = v18[v22];
            v25 = v20[v22++];
          }
          while (v24 == v25);
          if (v23 < v19)
          {
LABEL_33:
            std::string::basic_string[abi:ne180100]<0>(v110, "A.size == arrays[i0]->size");
            std::string::basic_string[abi:ne180100]<0>(v109, "init");
            std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
            cv::Exception::Exception(v111, 4294967081, v110, v109, __p, 3207);
            cv::error((cv *)v111, v26);
          }
        }
      }
LABEL_36:
      if ((*(_BYTE *)(v15 + 1) & 0x40) == 0)
      {
        v27 = *(_QWORD *)(v15 + 72);
        v28 = *(_DWORD *)(v15 + 4);
        v29 = __OFSUB__(v28, 1);
        v30 = v28 - 1;
        if (v30 < 0 != v29)
          v31 = 0;
        else
          v31 = *(_QWORD *)(v27 + 8 * v30);
        v32 = v13 - 1;
        if (*(_QWORD *)(v27 + 8 * (v13 - 1)) != v31)
        {
          std::string::basic_string[abi:ne180100]<0>(v110, "A.step[d-1] == A.elemSize()");
          std::string::basic_string[abi:ne180100]<0>(v109, "init");
          std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
          cv::Exception::Exception(v111, 4294967081, v110, v109, __p, 3211);
          cv::error((cv *)v111, v33);
        }
        v34 = v32;
        if ((int)v12 >= v32)
          v35 = v13 - 1;
        else
          v35 = v12;
        v36 = v13;
        while (v34 > (int)v12)
        {
          v37 = *(_QWORD *)(*(_QWORD *)(v15 + 72) + 8 * v34 - 8);
          v38 = *(_QWORD *)(*(_QWORD *)(v15 + 72) + 8 * v34) * *(int *)(*(_QWORD *)(v15 + 64) + 4 * v34);
          --v34;
          --v36;
          if (v38 < v37)
            goto LABEL_50;
        }
        v36 = v35;
LABEL_50:
        v39 = *((_DWORD *)this + 12);
        if (v39 <= v36)
          v39 = v36;
        *((_DWORD *)this + 12) = v39;
      }
    }
    ++v11;
    v5 = *((int *)this + 6);
  }
  while (v11 < v5);
  if ((v14 & 0x80000000) != 0)
  {
LABEL_60:
    *((_DWORD *)this + 12) = 0;
  }
  else
  {
    v40 = v13 - 1;
    v41 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 8 * v14) + 64);
    v42 = v13 - 1;
    v43 = *(int *)(v41 + 4 * v42);
    v44 = *((int *)this + 12);
    if ((int)v44 < v13 - 1)
      v40 = *((_DWORD *)this + 12);
    while (1)
    {
      v45 = v43;
      if (v42 <= v44)
        break;
      v46 = *(int *)(v41 - 4 + 4 * v42--);
      v43 = v45 * v46;
      --v13;
      if (v43 != (int)v43)
        goto LABEL_62;
    }
    v13 = v40;
LABEL_62:
    *((_QWORD *)this + 5) = v45;
    if (v13 == (_DWORD)v12)
      v47 = 0;
    else
      v47 = v13;
    *((_DWORD *)this + 12) = v47;
    v29 = __OFSUB__(v47, 1);
    v48 = v47 - 1;
    if (v48 < 0 != v29)
    {
      v50 = 1;
      v51 = (uint64_t *)((char *)this + 32);
    }
    else
    {
      v49 = 4 * v48;
      v50 = 1;
      v51 = (uint64_t *)((char *)this + 32);
      do
      {
        v50 *= *(int *)(v41 + v49);
        v49 -= 4;
      }
      while (v49 != -4);
    }
    *v51 = v50;
  }
  *((_QWORD *)this + 7) = 0;
  if (*((_QWORD *)this + 1))
    v52 = (int)v5 < 1;
  else
    v52 = 1;
  if (!v52)
  {
    for (i = 0; i < *((int *)this + 6); ++i)
    {
      v54 = *(int **)(*(_QWORD *)this + 8 * i);
      if (!v54)
      {
        std::string::basic_string[abi:ne180100]<0>(v110, "arrays[i] != 0");
        std::string::basic_string[abi:ne180100]<0>(v109, "init");
        std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matrix.cpp");
        cv::Exception::Exception(v111, 4294967081, v110, v109, __p, 3248);
        cv::error((cv *)v111, v55);
      }
      v56 = *((_QWORD *)v54 + 2);
      if (v56)
      {
        v57 = *((_QWORD *)this + 5);
        v58 = *v54;
        *(_QWORD *)((char *)v111 + 4) = 0x100000002;
        HIDWORD(v111[0]) = v57;
        v111[1] = v56;
        v112 = (char *)v111 + 8;
        v113 = (cv *)&v114;
        LODWORD(v111[0]) = v58 & 0xFFF | 0x42FF4000;
        v114 = (int)v57 * (uint64_t)(int)((((v58 >> 3) & 0x1FF) + 1) << ((0xFA50u >> (2 * (v58 & 7))) & 3));
        v115 = (((v58 >> 3) & 0x1FF) + 1) << ((0xFA50u >> (2 * (v58 & 7))) & 3);
        v111[3] = v56 + v114;
        *(_QWORD *)&v111[2] = v56;
        *((_QWORD *)&v111[2] + 1) = v56 + v114;
        v59 = *((_QWORD *)this + 1);
        v60 = (_OWORD *)(v59 + 96 * i);
        if (v60 != v111)
        {
          v61 = v59 + 96 * i;
          v64 = *(unsigned int **)(v61 + 24);
          v63 = (_QWORD *)(v61 + 24);
          v62 = v64;
          if (v64)
          {
            do
            {
              v65 = __ldaxr(v62);
              v66 = v65 - 1;
            }
            while (__stlxr(v66, v62));
            if (!v66)
              cv::Mat::deallocate((cv::Mat *)(v59 + 96 * i), a2);
          }
          v67 = v59 + 96 * i;
          *(_QWORD *)(v67 + 32) = 0;
          v68 = v67 + 32;
          *(_QWORD *)(v68 - 16) = 0;
          v69 = (int *)(v68 - 28);
          v70 = *(_DWORD *)(v68 - 28);
          *(_QWORD *)(v68 + 8) = 0;
          *(_QWORD *)(v68 + 16) = 0;
          if (v70 <= 0)
          {
            *v63 = 0;
            *(_DWORD *)v60 = v111[0];
          }
          else
          {
            v71 = 0;
            v72 = *(_QWORD *)(v59 + 96 * i + 64);
            do
            {
              *(_DWORD *)(v72 + 4 * v71++) = 0;
              v73 = *v69;
            }
            while (v71 < v73);
            *v63 = 0;
            *(_DWORD *)v60 = v111[0];
            if ((int)v73 > 2)
            {
LABEL_102:
              cv::Mat::copySize((cv::Mat *)(v59 + 96 * i), (const cv::Mat *)v111);
              goto LABEL_103;
            }
          }
          if (SDWORD1(v111[0]) > 2)
            goto LABEL_102;
          *v69 = DWORD1(v111[0]);
          v89 = v59 + 96 * i;
          *(_QWORD *)(v89 + 8) = *((_QWORD *)&v111[0] + 1);
          v90 = v113;
          v91 = *(_QWORD **)(v89 + 72);
          *v91 = *(_QWORD *)v113;
          v91[1] = *((_QWORD *)v90 + 1);
LABEL_103:
          *(_OWORD *)v68 = v111[2];
          v92 = v59 + 96 * i;
          *(_QWORD *)(v92 + 48) = *(_QWORD *)&v111[3];
          *(_OWORD *)(v68 - 16) = v111[1];
          *(_QWORD *)(v92 + 56) = *((_QWORD *)&v111[3] + 1);
          v93 = (unsigned int *)*((_QWORD *)&v111[1] + 1);
          if (*((_QWORD *)&v111[1] + 1))
          {
            do
            {
              v94 = __ldaxr(v93);
              v95 = v94 - 1;
            }
            while (__stlxr(v95, v93));
            if (!v95)
            {
              if (*((_QWORD *)&v111[3] + 1))
                (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD))(**((_QWORD **)&v111[3] + 1) + 24))(*((_QWORD *)&v111[3] + 1), *((_QWORD *)&v111[1] + 1), *(_QWORD *)&v111[2], *(_QWORD *)&v111[1]);
              else
                cv::fastFree(*(void ***)&v111[2], a2);
            }
          }
        }
        *(_QWORD *)&v111[1] = 0;
        memset(&v111[2], 0, 24);
        if (SDWORD1(v111[0]) >= 1)
        {
          v103 = 0;
          v104 = v112;
          do
            *(_DWORD *)&v104[4 * v103++] = 0;
          while (v103 < SDWORD1(v111[0]));
        }
        *((_QWORD *)&v111[1] + 1) = 0;
        v105 = (void **)v113;
        if (v113 == (cv *)&v114)
          continue;
LABEL_129:
        cv::fastFree(v105, a2);
        continue;
      }
      v112 = (char *)v111 + 8;
      v113 = (cv *)&v114;
      v114 = 0;
      v115 = 0;
      LODWORD(v111[0]) = 1124007936;
      memset((char *)v111 + 4, 0, 48);
      v111[3] = 0u;
      v74 = *((_QWORD *)this + 1);
      v75 = (_OWORD *)(v74 + 96 * i);
      if (v75 == v111)
      {
        memset(&v111[2], 0, 24);
        goto LABEL_128;
      }
      v76 = v74 + 96 * i;
      v79 = *(unsigned int **)(v76 + 24);
      v78 = (_QWORD *)(v76 + 24);
      v77 = v79;
      if (v79)
      {
        do
        {
          v80 = __ldaxr(v77);
          v81 = v80 - 1;
        }
        while (__stlxr(v81, v77));
        if (!v81)
          cv::Mat::deallocate((cv::Mat *)(v74 + 96 * i), a2);
      }
      v82 = v74 + 96 * i;
      *(_QWORD *)(v82 + 32) = 0;
      v83 = v82 + 32;
      *(_QWORD *)(v83 - 16) = 0;
      v84 = (int *)(v83 - 28);
      v85 = *(_DWORD *)(v83 - 28);
      *(_QWORD *)(v83 + 8) = 0;
      *(_QWORD *)(v83 + 16) = 0;
      if (v85 <= 0)
      {
        *v78 = 0;
        *(_DWORD *)v75 = v111[0];
      }
      else
      {
        v86 = 0;
        v87 = *(_QWORD *)(v74 + 96 * i + 64);
        do
        {
          *(_DWORD *)(v87 + 4 * v86++) = 0;
          v88 = *v84;
        }
        while (v86 < v88);
        *v78 = 0;
        *(_DWORD *)v75 = v111[0];
        if ((int)v88 > 2)
          goto LABEL_112;
      }
      if (SDWORD1(v111[0]) <= 2)
      {
        *v84 = DWORD1(v111[0]);
        v96 = v74 + 96 * i;
        *(_QWORD *)(v96 + 8) = *((_QWORD *)&v111[0] + 1);
        v97 = v113;
        v98 = *(_QWORD **)(v96 + 72);
        *v98 = *(_QWORD *)v113;
        v98[1] = *((_QWORD *)v97 + 1);
        goto LABEL_113;
      }
LABEL_112:
      cv::Mat::copySize((cv::Mat *)(v74 + 96 * i), (const cv::Mat *)v111);
LABEL_113:
      *(_OWORD *)v83 = v111[2];
      v99 = v74 + 96 * i;
      *(_QWORD *)(v99 + 48) = *(_QWORD *)&v111[3];
      *(_OWORD *)(v83 - 16) = v111[1];
      *(_QWORD *)(v99 + 56) = *((_QWORD *)&v111[3] + 1);
      v100 = (unsigned int *)*((_QWORD *)&v111[1] + 1);
      if (*((_QWORD *)&v111[1] + 1))
      {
        do
        {
          v101 = __ldaxr(v100);
          v102 = v101 - 1;
        }
        while (__stlxr(v102, v100));
        if (!v102)
        {
          if (*((_QWORD *)&v111[3] + 1))
            (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD))(**((_QWORD **)&v111[3] + 1) + 24))(*((_QWORD *)&v111[3] + 1), *((_QWORD *)&v111[1] + 1), *(_QWORD *)&v111[2], *(_QWORD *)&v111[1]);
          else
            cv::fastFree(*(void ***)&v111[2], a2);
        }
      }
      *(_QWORD *)&v111[1] = 0;
      memset(&v111[2], 0, 24);
      if (SDWORD1(v111[0]) >= 1)
      {
        v106 = 0;
        v107 = v112;
        do
          *(_DWORD *)&v107[4 * v106++] = 0;
        while (v106 < SDWORD1(v111[0]));
      }
LABEL_128:
      *((_QWORD *)&v111[1] + 1) = 0;
      v105 = (void **)v113;
      if (v113 != (cv *)&v114)
        goto LABEL_129;
    }
  }
}

void sub_219E73FD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,char a30)
{
  cv::Exception::~Exception((cv::Exception *)&a30);
  if (a17 < 0)
    operator delete(__p);
  if (a23 < 0)
    operator delete(a18);
  if (a29 < 0)
    operator delete(a24);
  _Unwind_Resume(a1);
}

cv::NAryMatIterator *cv::NAryMatIterator::NAryMatIterator(cv::NAryMatIterator *this, const cv::Mat **a2, unsigned __int8 **a3, int a4)
{
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = 0;
  *((_DWORD *)this + 6) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_DWORD *)this + 12) = 0;
  cv::NAryMatIterator::init(this, a2, 0, (unint64_t)a3, a4);
  return this;
}

uint64_t cv::NAryMatIterator::operator++(uint64_t result)
{
  unint64_t v1;
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _BOOL4 v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;

  v1 = *(_QWORD *)(result + 56);
  if (v1 < *(_QWORD *)(result + 32) - 1)
  {
    v2 = v1 + 1;
    *(_QWORD *)(result + 56) = v2;
    v3 = *(unsigned int *)(result + 48);
    if ((_DWORD)v3 == 1)
    {
      if (*(_QWORD *)(result + 16))
      {
        v4 = *(unsigned int *)(result + 24);
        if ((int)v4 >= 1)
        {
          v5 = 0;
          v6 = 8 * v4;
          do
          {
            v7 = *(_QWORD *)(result + 16);
            if (*(_QWORD *)(v7 + v5))
              *(_QWORD *)(v7 + v5) = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)result + v5) + 16)
                                   + **(_QWORD **)(*(_QWORD *)(*(_QWORD *)result + v5) + 72) * v2;
            v5 += 8;
          }
          while (v6 != v5);
        }
      }
      v8 = *(_QWORD *)(result + 8);
      if (v8)
      {
        v9 = *(unsigned int *)(result + 24);
        if ((int)v9 >= 1)
        {
          v10 = 0;
          v11 = (_QWORD *)(v8 + 16);
          v12 = 8 * v9;
          do
          {
            if (*v11)
              *v11 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)result + v10) + 16)
                   + **(_QWORD **)(*(_QWORD *)(*(_QWORD *)result + v10) + 72) * v2;
            v10 += 8;
            v11 += 12;
          }
          while (v12 != v10);
        }
      }
    }
    else
    {
      v13 = *(unsigned int *)(result + 24);
      if ((int)v13 >= 1)
      {
        v14 = 0;
        v16 = (int)v3 > 0 && (int)v2 > 0;
        do
        {
          v17 = *(_QWORD **)(*(_QWORD *)result + 8 * v14);
          v18 = v17[2];
          if (v18)
          {
            if (v16)
            {
              v19 = v17[8];
              v20 = v17[9];
              v21 = v3;
              v22 = v2;
              do
              {
                v23 = *(_DWORD *)(v19 + 4 * (v21 - 1));
                v24 = v22 / v23;
                v18 += *(_QWORD *)(v20 + 8 * (v21 - 1)) * (v22 % v23);
                if (v21 < 2)
                  break;
                --v21;
                v22 /= v23;
              }
              while (v24 > 0);
            }
            v25 = *(_QWORD *)(result + 16);
            if (v25)
              *(_QWORD *)(v25 + 8 * v14) = v18;
            v26 = *(_QWORD *)(result + 8);
            if (v26)
              *(_QWORD *)(v26 + 96 * v14 + 16) = v18;
          }
          ++v14;
        }
        while (v14 != v13);
      }
    }
  }
  return result;
}

uint64_t cv::transposeI_8u(uint64_t this, unsigned __int8 *a2, int a3)
{
  uint64_t v3;
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  uint64_t v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  uint64_t v10;
  unsigned __int8 v11;

  if (a3 >= 1)
  {
    v3 = 0;
    v4 = &a2[this];
    v5 = a2 + 1;
    v6 = (unsigned __int8 *)(this + 1);
    v7 = 1;
    do
    {
      if (++v3 < (unint64_t)a3)
      {
        v8 = v6;
        v9 = v4;
        v10 = a3;
        do
        {
          v11 = *v8;
          this = *v9;
          *v8++ = this;
          *v9 = v11;
          --v10;
          v9 = &a2[(_QWORD)v9];
        }
        while (v7 != v10);
      }
      ++v7;
      v4 = &v5[(_QWORD)v4];
      v6 = &v5[(_QWORD)v6];
    }
    while (v3 != a3);
  }
  return this;
}

uint64_t cv::transposeI_16u(uint64_t this, unsigned __int8 *a2, int a3)
{
  uint64_t v3;
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  uint64_t v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  uint64_t v10;
  __int16 v11;

  if (a3 >= 1)
  {
    v3 = 0;
    v4 = &a2[this];
    v5 = a2 + 2;
    v6 = (unsigned __int8 *)(this + 2);
    v7 = 1;
    do
    {
      if (++v3 < (unint64_t)a3)
      {
        v8 = v6;
        v9 = v4;
        v10 = a3;
        do
        {
          v11 = *(_WORD *)v8;
          this = *(unsigned __int16 *)v9;
          *(_WORD *)v8 = this;
          v8 += 2;
          *(_WORD *)v9 = v11;
          --v10;
          v9 = &a2[(_QWORD)v9];
        }
        while (v7 != v10);
      }
      ++v7;
      v4 = &v5[(_QWORD)v4];
      v6 = &v5[(_QWORD)v6];
    }
    while (v3 != a3);
  }
  return this;
}

uint64_t cv::transposeI_8uC3(uint64_t this, unsigned __int8 *a2, int a3)
{
  uint64_t v3;
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  uint64_t v7;
  unint64_t v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  unint64_t v11;
  unsigned __int8 v12;
  unsigned __int8 v13;

  if (a3 >= 1)
  {
    v3 = 0;
    v4 = &a2[this];
    v5 = a2 + 3;
    v6 = (unsigned __int8 *)(this + 3);
    v7 = 1;
    v8 = a3;
    do
    {
      if (++v3 < v8)
      {
        v9 = v6;
        v10 = v4;
        v11 = v8;
        do
        {
          v12 = v9[2];
          this = *(unsigned __int16 *)v9;
          v13 = v10[2];
          *(_WORD *)v9 = *(_WORD *)v10;
          v9[2] = v13;
          *(_WORD *)v10 = this;
          v10[2] = v12;
          --v11;
          v10 = &a2[(_QWORD)v10];
          v9 += 3;
        }
        while (v7 != v11);
      }
      ++v7;
      v4 = &v5[(_QWORD)v4];
      v6 = &v5[(_QWORD)v6];
    }
    while (v3 != v8);
  }
  return this;
}

uint64_t cv::transposeI_32s(uint64_t this, unsigned __int8 *a2, int a3)
{
  uint64_t v3;
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  uint64_t v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  uint64_t v10;
  int v11;

  if (a3 >= 1)
  {
    v3 = 0;
    v4 = &a2[this];
    v5 = a2 + 4;
    v6 = (unsigned __int8 *)(this + 4);
    v7 = 1;
    do
    {
      if (++v3 < (unint64_t)a3)
      {
        v8 = v6;
        v9 = v4;
        v10 = a3;
        do
        {
          v11 = *(_DWORD *)v8;
          this = *(unsigned int *)v9;
          *(_DWORD *)v8 = this;
          v8 += 4;
          *(_DWORD *)v9 = v11;
          --v10;
          v9 = &a2[(_QWORD)v9];
        }
        while (v7 != v10);
      }
      ++v7;
      v4 = &v5[(_QWORD)v4];
      v6 = &v5[(_QWORD)v6];
    }
    while (v3 != a3);
  }
  return this;
}

uint64_t cv::transposeI_16uC3(uint64_t this, unsigned __int8 *a2, int a3)
{
  uint64_t v3;
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  uint64_t v7;
  unint64_t v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  unint64_t v11;
  __int16 v12;
  __int16 v13;

  if (a3 >= 1)
  {
    v3 = 0;
    v4 = &a2[this];
    v5 = a2 + 6;
    v6 = (unsigned __int8 *)(this + 6);
    v7 = 1;
    v8 = a3;
    do
    {
      if (++v3 < v8)
      {
        v9 = v6;
        v10 = v4;
        v11 = v8;
        do
        {
          v12 = *((_WORD *)v9 + 2);
          this = *(unsigned int *)v9;
          v13 = *((_WORD *)v10 + 2);
          *(_DWORD *)v9 = *(_DWORD *)v10;
          *((_WORD *)v9 + 2) = v13;
          *(_DWORD *)v10 = this;
          *((_WORD *)v10 + 2) = v12;
          --v11;
          v10 = &a2[(_QWORD)v10];
          v9 += 6;
        }
        while (v7 != v11);
      }
      ++v7;
      v4 = &v5[(_QWORD)v4];
      v6 = &v5[(_QWORD)v6];
    }
    while (v3 != v8);
  }
  return this;
}

uint64_t cv::transposeI_32sC2(uint64_t this, unsigned __int8 *a2, int a3)
{
  uint64_t v3;
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;

  if (a3 >= 1)
  {
    v3 = 0;
    v4 = &a2[this];
    v5 = a2 + 8;
    v6 = (uint64_t *)(this + 8);
    v7 = 1;
    do
    {
      if (++v3 < (unint64_t)a3)
      {
        v8 = v6;
        v9 = (uint64_t *)v4;
        v10 = a3;
        do
        {
          v11 = *v8;
          this = *v9;
          *v8++ = *v9;
          *v9 = v11;
          --v10;
          v9 = (uint64_t *)&a2[(_QWORD)v9];
        }
        while (v7 != v10);
      }
      ++v7;
      v4 = &v5[(_QWORD)v4];
      v6 = (uint64_t *)&v5[(_QWORD)v6];
    }
    while (v3 != a3);
  }
  return this;
}

uint64_t cv::transposeI_32sC3(uint64_t this, unsigned __int8 *a2, int a3)
{
  uint64_t v3;
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unsigned __int8 *v10;
  unint64_t v11;
  int v12;
  int v13;

  if (a3 >= 1)
  {
    v3 = 0;
    v4 = &a2[this];
    v5 = a2 + 12;
    v6 = this + 12;
    v7 = 1;
    v8 = a3;
    do
    {
      if (++v3 < v8)
      {
        v9 = v6;
        v10 = v4;
        v11 = v8;
        do
        {
          v12 = *(_DWORD *)(v9 + 8);
          this = *(_QWORD *)v9;
          v13 = *((_DWORD *)v10 + 2);
          *(_QWORD *)v9 = *(_QWORD *)v10;
          *(_DWORD *)(v9 + 8) = v13;
          *(_QWORD *)v10 = this;
          *((_DWORD *)v10 + 2) = v12;
          --v11;
          v10 = &a2[(_QWORD)v10];
          v9 += 12;
        }
        while (v7 != v11);
      }
      ++v7;
      v4 = &v5[(_QWORD)v4];
      v6 += (uint64_t)v5;
    }
    while (v3 != v8);
  }
  return this;
}

uint64_t cv::transposeI_32sC4(uint64_t this, unsigned __int8 *a2, int a3)
{
  uint64_t v3;
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  uint64_t v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  uint64_t v10;
  __int128 v11;

  if (a3 >= 1)
  {
    v3 = 0;
    v4 = &a2[this];
    v5 = a2 + 16;
    v6 = (unsigned __int8 *)(this + 16);
    v7 = 1;
    do
    {
      if (++v3 < (unint64_t)a3)
      {
        v8 = v6;
        v9 = v4;
        v10 = a3;
        do
        {
          v11 = *(_OWORD *)v8;
          *(_OWORD *)v8 = *(_OWORD *)v9;
          v8 += 16;
          *(_OWORD *)v9 = v11;
          --v10;
          v9 = &a2[(_QWORD)v9];
        }
        while (v7 != v10);
      }
      ++v7;
      v4 = &v5[(_QWORD)v4];
      v6 = &v5[(_QWORD)v6];
    }
    while (v3 != a3);
  }
  return this;
}

uint64_t cv::transposeI_32sC6(uint64_t this, unsigned __int8 *a2, int a3)
{
  uint64_t v3;
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  uint64_t v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;

  if (a3 >= 1)
  {
    v3 = 0;
    v4 = &a2[this];
    v5 = a2 + 24;
    v6 = (unsigned __int8 *)(this + 24);
    v7 = 1;
    do
    {
      if (++v3 < (unint64_t)a3)
      {
        v8 = v6;
        v9 = v4;
        v10 = a3;
        do
        {
          v11 = *((_QWORD *)v8 + 2);
          v12 = *(_OWORD *)v8;
          this = *((_QWORD *)v9 + 2);
          *(_OWORD *)v8 = *(_OWORD *)v9;
          *((_QWORD *)v8 + 2) = this;
          *(_OWORD *)v9 = v12;
          *((_QWORD *)v9 + 2) = v11;
          --v10;
          v9 = &a2[(_QWORD)v9];
          v8 += 24;
        }
        while (v7 != v10);
      }
      ++v7;
      v4 = &v5[(_QWORD)v4];
      v6 = &v5[(_QWORD)v6];
    }
    while (v3 != a3);
  }
  return this;
}

uint64_t cv::transposeI_32sC8(uint64_t this, unsigned __int8 *a2, int a3)
{
  uint64_t v3;
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  uint64_t v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  uint64_t v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;

  if (a3 >= 1)
  {
    v3 = 0;
    v4 = &a2[this];
    v5 = a2 + 32;
    v6 = (unsigned __int8 *)(this + 32);
    v7 = 1;
    do
    {
      if (++v3 < (unint64_t)a3)
      {
        v8 = v6;
        v9 = v4;
        v10 = a3;
        do
        {
          v12 = *(_OWORD *)v8;
          v11 = *((_OWORD *)v8 + 1);
          v13 = *((_OWORD *)v9 + 1);
          *(_OWORD *)v8 = *(_OWORD *)v9;
          *((_OWORD *)v8 + 1) = v13;
          v8 += 32;
          *(_OWORD *)v9 = v12;
          *((_OWORD *)v9 + 1) = v11;
          --v10;
          v9 = &a2[(_QWORD)v9];
        }
        while (v7 != v10);
      }
      ++v7;
      v4 = &v5[(_QWORD)v4];
      v6 = &v5[(_QWORD)v6];
    }
    while (v3 != a3);
  }
  return this;
}

_BYTE *cv::transpose_8u(_BYTE *result, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int *a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _BYTE *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _BYTE *v21;
  _BYTE *v22;
  _BYTE *v23;
  _BYTE *v24;
  _BYTE *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _BYTE *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  _BYTE *v37;
  _BYTE *v38;
  uint64_t v39;
  _BYTE *v40;
  uint64_t v41;
  uint64_t v42;

  v5 = *a5;
  v6 = (int)a5[1];
  v7 = a5[1];
  v8 = 4 * a2;
  if ((int)v5 >= 4)
  {
    v9 = 0;
    v42 = *a5;
    v10 = (v5 - 4);
    v11 = 4 * a4;
    v12 = a2 + 3;
    v13 = 2 * a2 + 3;
    v14 = a3 + 3 * a4;
    v15 = a3 + a4;
    v16 = result;
    v17 = a3;
    v18 = 3 * a2;
    v19 = a3 + 2 * a4;
    do
    {
      if ((int)v6 >= 4)
      {
        v20 = 0;
        v21 = v16;
        do
        {
          v22 = (_BYTE *)(v17 + v20);
          *v22 = *v21;
          v22[1] = v21[a2];
          v22[2] = v21[2 * a2];
          v22[3] = v21[3 * a2];
          v23 = (_BYTE *)(v17 + v20 + a4);
          *v23 = v21[1];
          v23[1] = v21[v12 - 2];
          v23[2] = v21[v13 - 2];
          v23[3] = v21[v18 + 1];
          v24 = &v23[a4];
          *v24 = v21[2];
          v24[1] = v21[v12 - 1];
          v24[2] = v21[v13 - 1];
          v24[3] = v21[v18 + 2];
          v25 = &v24[a4];
          *v25 = v21[3];
          v25[1] = v21[v12];
          v25[2] = v21[v13];
          v25[3] = v21[v18 + 3];
          v20 += 4;
          v21 += v8;
        }
        while (v20 <= v6 - 4);
        v20 = v20;
      }
      else
      {
        v20 = 0;
      }
      if ((int)v20 < (int)v7)
      {
        v26 = a2 * v20;
        v27 = v17;
        v28 = v15;
        v29 = v19;
        v30 = v14;
        v31 = v7;
        do
        {
          *(_BYTE *)(v27 + v20) = v16[v26];
          *(_BYTE *)(v28 + v20) = v16[v26 + 1];
          *(_BYTE *)(v29 + v20) = v16[v26 + 2];
          *(_BYTE *)(v30 + v20) = v16[v26 + 3];
          --v31;
          ++v30;
          ++v29;
          ++v28;
          ++v27;
          v26 += a2;
        }
        while (v20 != v31);
      }
      v9 += 4;
      v17 += v11;
      v16 += 4;
      v14 += v11;
      v19 += v11;
      v15 += v11;
    }
    while (v9 <= v10);
    v5 = v42;
  }
  else
  {
    LODWORD(v9) = 0;
  }
  if ((int)v9 < (int)v5)
  {
    v32 = v9;
    v33 = &result[v9];
    v34 = a3 + a4 * v32;
    result = (_BYTE *)(v34 + 1);
    do
    {
      if ((int)v6 >= 4)
      {
        v36 = 0;
        v37 = v33;
        do
        {
          v38 = &result[v36];
          *(v38 - 1) = *v37;
          *v38 = v37[a2];
          v38[1] = v37[2 * a2];
          v38[2] = v37[3 * a2];
          v36 += 4;
          v37 += v8;
        }
        while (v36 <= v6 - 4);
        v35 = v36;
      }
      else
      {
        v35 = 0;
      }
      if ((int)v35 < (int)v7)
      {
        v39 = v7 - v35;
        v40 = (_BYTE *)(v34 + v35);
        v41 = a2 * v35;
        do
        {
          *v40++ = v33[v41];
          v41 += a2;
          --v39;
        }
        while (v39);
      }
      ++v32;
      ++v33;
      result += a4;
      v34 += a4;
    }
    while (v32 != v5);
  }
  return result;
}

_WORD *cv::transpose_16u(_WORD *result, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int *a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _WORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _WORD *v20;
  _WORD *v21;
  _WORD *v22;
  _WORD *v23;
  _WORD *v24;
  uint64_t v25;
  uint64_t v26;
  _WORD *v27;
  uint64_t v28;
  _WORD *v29;
  uint64_t v30;
  _WORD *v31;
  _WORD *v32;
  _WORD *v33;
  uint64_t v34;

  v5 = *a5;
  v6 = (int)a5[1];
  v7 = a5[1];
  v8 = 4 * a2;
  if ((int)v5 >= 4)
  {
    v9 = 0;
    v10 = 4 * a4;
    v11 = a2 + 6;
    v12 = 2 * a2 + 6;
    v13 = a3 + 3 * a4;
    v14 = a3 + a4;
    v15 = result;
    v16 = a3;
    v17 = 3 * a2;
    v18 = a3 + 2 * a4;
    do
    {
      if ((int)v6 >= 4)
      {
        v19 = 0;
        v20 = v15;
        do
        {
          v21 = (_WORD *)(v16 + 2 * v19);
          *v21 = *v20;
          v21[1] = *(_WORD *)((char *)v20 + a2);
          v21[2] = v20[a2];
          v21[3] = *(_WORD *)((char *)v20 + 3 * a2);
          v22 = (_WORD *)((char *)v21 + a4);
          *v22 = v20[1];
          v22[1] = *(_WORD *)((char *)v20 + v11 - 4);
          v22[2] = *(_WORD *)((char *)v20 + v12 - 4);
          v22[3] = *(_WORD *)((char *)v20 + v17 + 2);
          v23 = (_WORD *)((char *)v22 + a4);
          *v23 = v20[2];
          v23[1] = *(_WORD *)((char *)v20 + v11 - 2);
          v23[2] = *(_WORD *)((char *)v20 + v12 - 2);
          v23[3] = *(_WORD *)((char *)v20 + v17 + 4);
          v24 = (_WORD *)((char *)v23 + a4);
          *v24 = v20[3];
          v24[1] = *(_WORD *)((char *)v20 + v11);
          v24[2] = *(_WORD *)((char *)v20 + v12);
          v24[3] = *(_WORD *)((char *)v20 + v17 + 6);
          v19 += 4;
          v20 = (_WORD *)((char *)v20 + v8);
        }
        while (v19 <= v6 - 4);
        v19 = v19;
      }
      else
      {
        v19 = 0;
      }
      if ((int)v19 < (int)v7)
      {
        v25 = a2 * v19;
        do
        {
          *(_WORD *)(v16 + 2 * v19) = *(_WORD *)((char *)v15 + v25);
          *(_WORD *)(v14 + 2 * v19) = *(_WORD *)((char *)v15 + v25 + 2);
          *(_WORD *)(v18 + 2 * v19) = *(_WORD *)((char *)v15 + v25 + 4);
          *(_WORD *)(v13 + 2 * v19++) = *(_WORD *)((char *)v15 + v25 + 6);
          v25 += a2;
        }
        while (v7 != v19);
      }
      v9 += 4;
      v16 += v10;
      v15 += 4;
      v13 += v10;
      v18 += v10;
      v14 += v10;
    }
    while (v9 <= (v5 - 4));
  }
  else
  {
    LODWORD(v9) = 0;
  }
  if ((int)v9 < (int)v5)
  {
    v26 = v9;
    v27 = &result[v9];
    v28 = a3 + a4 * v26;
    v29 = (_WORD *)(v28 + 4);
    do
    {
      if ((int)v6 >= 4)
      {
        result = 0;
        v31 = v29;
        v32 = v27;
        do
        {
          *(v31 - 2) = *v32;
          *(v31 - 1) = *(_WORD *)((char *)v32 + a2);
          *v31 = v32[a2];
          v31[1] = *(_WORD *)((char *)v32 + 3 * a2);
          result += 2;
          v32 = (_WORD *)((char *)v32 + v8);
          v31 += 4;
        }
        while ((uint64_t)result <= v6 - 4);
        v30 = result;
      }
      else
      {
        v30 = 0;
      }
      if ((int)v30 < (int)v7)
      {
        result = (_WORD *)(v7 - v30);
        v33 = (_WORD *)(v28 + 2 * v30);
        v34 = a2 * v30;
        do
        {
          *v33++ = *(_WORD *)((char *)v27 + v34);
          v34 += a2;
          result = (_WORD *)((char *)result - 1);
        }
        while (result);
      }
      ++v26;
      ++v27;
      v29 = (_WORD *)((char *)v29 + a4);
      v28 += a4;
    }
    while (v26 != v5);
  }
  return result;
}

__int16 *cv::transpose_8uC3(__int16 *result, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int *a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int16 *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __int16 *v24;
  uint64_t v25;
  __int16 v26;
  __int16 v27;
  __int16 v28;
  __int16 v29;
  uint64_t v30;
  __int16 v31;
  __int16 v32;
  __int16 v33;
  __int16 v34;
  uint64_t v35;
  uint64_t v36;
  __int16 v37;
  __int16 v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  __int16 v47;
  uint64_t v48;
  __int16 v49;
  uint64_t v50;
  __int16 v51;
  uint64_t v52;
  __int16 v53;
  uint64_t v54;
  __int16 *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  __int16 *v59;
  __int16 *v60;
  __int16 v61;
  __int16 v62;
  __int16 v63;
  __int16 v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  __int16 v68;
  __int16 *v69;
  uint64_t v70;
  uint64_t v71;

  v5 = *a5;
  v6 = (int)a5[1];
  v7 = a5[1];
  v8 = 4 * a2;
  v9 = a2;
  if ((int)v5 >= 4)
  {
    v10 = 0;
    v70 = a3;
    v71 = *a5;
    v11 = (v5 - 4);
    v12 = 4 * a4;
    v13 = a2 + 9;
    v14 = v9 * 2 + 9;
    v15 = a3 + 3 * a4;
    v16 = a3 + a4;
    v69 = result;
    v17 = result;
    v18 = a3;
    v19 = 3 * a2;
    v20 = a3 + 2 * a4;
    v21 = v11;
    do
    {
      if ((int)v6 >= 4)
      {
        v23 = 0;
        v24 = v17;
        v25 = v18;
        do
        {
          v26 = *v24;
          *(_BYTE *)(v25 + 2) = *((_BYTE *)v24 + 2);
          *(_WORD *)v25 = v26;
          v27 = *(__int16 *)((char *)v24 + a2);
          *(_BYTE *)(v25 + 5) = *((_BYTE *)v24 + v13 - 7);
          *(_WORD *)(v25 + 3) = v27;
          v28 = v24[a2];
          *(_BYTE *)(v25 + 8) = *((_BYTE *)v24 + v14 - 7);
          *(_WORD *)(v25 + 6) = v28;
          v29 = *(__int16 *)((char *)v24 + 3 * a2);
          *(_BYTE *)(v25 + 11) = *((_BYTE *)v24 + v19 + 2);
          *(_WORD *)(v25 + 9) = v29;
          v30 = v25 + a4;
          v31 = *(__int16 *)((char *)v24 + 3);
          *(_BYTE *)(v30 + 2) = *((_BYTE *)v24 + 5);
          *(_WORD *)v30 = v31;
          v32 = *(__int16 *)((char *)v24 + v13 - 6);
          *(_BYTE *)(v30 + 5) = *((_BYTE *)v24 + v13 - 4);
          *(_WORD *)(v30 + 3) = v32;
          v33 = *(__int16 *)((char *)v24 + v14 - 6);
          *(_BYTE *)(v30 + 8) = *((_BYTE *)v24 + v14 - 4);
          *(_WORD *)(v30 + 6) = v33;
          v34 = *(__int16 *)((char *)v24 + v19 + 3);
          *(_BYTE *)(v30 + 11) = *((_BYTE *)v24 + v19 + 5);
          *(_WORD *)(v30 + 9) = v34;
          v35 = v25 + a4 + a4;
          LOWORD(v30) = v24[3];
          *(_BYTE *)(v35 + 2) = *((_BYTE *)v24 + 8);
          *(_WORD *)v35 = v30;
          LOWORD(v30) = *(__int16 *)((char *)v24 + v13 - 3);
          *(_BYTE *)(v35 + 5) = *((_BYTE *)v24 + v13 - 1);
          *(_WORD *)(v35 + 3) = v30;
          LOWORD(v30) = *(__int16 *)((char *)v24 + v14 - 3);
          *(_BYTE *)(v35 + 8) = *((_BYTE *)v24 + v14 - 1);
          *(_WORD *)(v35 + 6) = v30;
          LOWORD(v30) = *(__int16 *)((char *)v24 + v19 + 6);
          *(_BYTE *)(v35 + 11) = *((_BYTE *)v24 + v19 + 8);
          *(_WORD *)(v35 + 9) = v30;
          v36 = v35 + a4;
          LOWORD(v30) = *(__int16 *)((char *)v24 + 9);
          *(_BYTE *)(v36 + 2) = *((_BYTE *)v24 + 11);
          *(_WORD *)v36 = v30;
          LOWORD(v30) = *(__int16 *)((char *)v24 + v13);
          *(_BYTE *)(v36 + 5) = *((_BYTE *)v24 + v13 + 2);
          *(_WORD *)(v36 + 3) = v30;
          v37 = *(__int16 *)((char *)v24 + v14);
          *(_BYTE *)(v36 + 8) = *((_BYTE *)v24 + v14 + 2);
          *(_WORD *)(v36 + 6) = v37;
          v38 = *(__int16 *)((char *)v24 + v19 + 9);
          *(_BYTE *)(v36 + 11) = *((_BYTE *)v24 + v19 + 11);
          *(_WORD *)(v36 + 9) = v38;
          v23 += 4;
          v25 += 12;
          v24 = (__int16 *)((char *)v24 + v8);
        }
        while (v23 <= v6 - 4);
        v22 = v23;
      }
      else
      {
        v22 = 0;
      }
      if ((int)v22 < (int)v7)
      {
        v39 = v7 - v22;
        v40 = a2 * v22;
        v41 = v18;
        v42 = v16;
        v43 = v20;
        v44 = v15;
        v45 = 3 * v22;
        do
        {
          v46 = v41 + v45;
          v47 = *(__int16 *)((char *)v17 + v40);
          *(_BYTE *)(v46 + 2) = *((_BYTE *)v17 + v40 + 2);
          *(_WORD *)v46 = v47;
          v48 = v42 + v45;
          v49 = *(__int16 *)((char *)v17 + v40 + 3);
          *(_BYTE *)(v48 + 2) = *((_BYTE *)v17 + v40 + 5);
          *(_WORD *)v48 = v49;
          v50 = v43 + v45;
          v51 = *(__int16 *)((char *)v17 + v40 + 6);
          *(_BYTE *)(v50 + 2) = *((_BYTE *)v17 + v40 + 8);
          *(_WORD *)v50 = v51;
          v52 = v44 + v45;
          v53 = *(__int16 *)((char *)v17 + v40 + 9);
          v44 += 3;
          v43 += 3;
          *(_BYTE *)(v52 + 2) = *((_BYTE *)v17 + v40 + 11);
          *(_WORD *)v52 = v53;
          v42 += 3;
          v41 += 3;
          v40 += a2;
          --v39;
        }
        while (v39);
      }
      v10 += 4;
      v18 += v12;
      v17 += 6;
      v15 += v12;
      v20 += v12;
      v16 += v12;
    }
    while (v10 <= v21);
    a3 = v70;
    v5 = v71;
    result = v69;
  }
  else
  {
    LODWORD(v10) = 0;
  }
  if ((int)v10 < (int)v5)
  {
    v54 = v10;
    v55 = (__int16 *)((char *)result + 3 * v10);
    v56 = a3 + a4 * v54;
    result = (__int16 *)(v56 + 6);
    do
    {
      if ((int)v6 >= 4)
      {
        v58 = 0;
        v59 = result;
        v60 = v55;
        do
        {
          v61 = *v60;
          *((_BYTE *)v59 - 4) = *((_BYTE *)v60 + 2);
          *(v59 - 3) = v61;
          v62 = *(__int16 *)((char *)v60 + a2);
          *((_BYTE *)v59 - 1) = *((_BYTE *)v60 + a2 + 2);
          *(__int16 *)((char *)v59 - 3) = v62;
          v63 = v60[a2];
          *((_BYTE *)v59 + 2) = v60[v9 + 1];
          *v59 = v63;
          v64 = *(__int16 *)((char *)v60 + 3 * a2);
          *((_BYTE *)v59 + 5) = *((_BYTE *)v60 + 3 * a2 + 2);
          *(__int16 *)((char *)v59 + 3) = v64;
          v58 += 4;
          v60 = (__int16 *)((char *)v60 + v8);
          v59 += 6;
        }
        while (v58 <= v6 - 4);
        v57 = v58;
      }
      else
      {
        v57 = 0;
      }
      if ((int)v57 < (int)v7)
      {
        v65 = v7 - v57;
        v66 = v56 + 3 * v57;
        v67 = a2 * v57;
        do
        {
          v68 = *(__int16 *)((char *)v55 + v67);
          *(_BYTE *)(v66 + 2) = *((_BYTE *)v55 + v67 + 2);
          *(_WORD *)v66 = v68;
          v66 += 3;
          v67 += a2;
          --v65;
        }
        while (v65);
      }
      ++v54;
      v55 = (__int16 *)((char *)v55 + 3);
      result = (__int16 *)((char *)result + a4);
      v56 += a4;
    }
    while (v54 != v5);
  }
  return result;
}

_DWORD *cv::transpose_32s(_DWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int *a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _DWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _DWORD *v20;
  _DWORD *v21;
  _DWORD *v22;
  _DWORD *v23;
  _DWORD *v24;
  uint64_t v25;
  uint64_t v26;
  _DWORD *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _DWORD *v31;
  _DWORD *v32;
  uint64_t v33;
  _DWORD *v34;
  uint64_t v35;

  v5 = *a5;
  v6 = (int)a5[1];
  v7 = a5[1];
  v8 = 4 * a2;
  if ((int)v5 >= 4)
  {
    v9 = 0;
    v10 = 4 * a4;
    v11 = a2 + 12;
    v12 = 2 * a2 + 12;
    v13 = a3 + 3 * a4;
    v14 = a3 + a4;
    v15 = result;
    v16 = a3;
    v17 = 3 * a2;
    v18 = a3 + 2 * a4;
    do
    {
      if ((int)v6 >= 4)
      {
        v19 = 0;
        v20 = v15;
        do
        {
          v21 = (_DWORD *)(v16 + 4 * v19);
          *v21 = *v20;
          v21[1] = *(_DWORD *)((char *)v20 + a2);
          v21[2] = *(_DWORD *)((char *)v20 + 2 * a2);
          v21[3] = *(_DWORD *)((char *)v20 + 3 * a2);
          v22 = (_DWORD *)((char *)v21 + a4);
          *v22 = v20[1];
          v22[1] = *(_DWORD *)((char *)v20 + v11 - 8);
          v22[2] = *(_DWORD *)((char *)v20 + v12 - 8);
          v22[3] = *(_DWORD *)((char *)v20 + v17 + 4);
          v23 = (_DWORD *)((char *)v22 + a4);
          *v23 = v20[2];
          v23[1] = *(_DWORD *)((char *)v20 + v11 - 4);
          v23[2] = *(_DWORD *)((char *)v20 + v12 - 4);
          v23[3] = *(_DWORD *)((char *)v20 + v17 + 8);
          v24 = (_DWORD *)((char *)v23 + a4);
          *v24 = v20[3];
          v24[1] = *(_DWORD *)((char *)v20 + v11);
          v24[2] = *(_DWORD *)((char *)v20 + v12);
          v24[3] = *(_DWORD *)((char *)v20 + v17 + 12);
          v19 += 4;
          v20 = (_DWORD *)((char *)v20 + v8);
        }
        while (v19 <= v6 - 4);
        v19 = v19;
      }
      else
      {
        v19 = 0;
      }
      if ((int)v19 < (int)v7)
      {
        v25 = a2 * v19;
        do
        {
          *(_DWORD *)(v16 + 4 * v19) = *(_DWORD *)((char *)v15 + v25);
          *(_DWORD *)(v14 + 4 * v19) = *(_DWORD *)((char *)v15 + v25 + 4);
          *(_DWORD *)(v18 + 4 * v19) = *(_DWORD *)((char *)v15 + v25 + 8);
          *(_DWORD *)(v13 + 4 * v19++) = *(_DWORD *)((char *)v15 + v25 + 12);
          v25 += a2;
        }
        while (v7 != v19);
      }
      v9 += 4;
      v16 += v10;
      v15 += 4;
      v13 += v10;
      v18 += v10;
      v14 += v10;
    }
    while (v9 <= (v5 - 4));
  }
  else
  {
    LODWORD(v9) = 0;
  }
  if ((int)v9 < (int)v5)
  {
    v26 = v9;
    v27 = &result[v9];
    v28 = a3 + a4 * v26;
    result = (_DWORD *)(v28 + 8);
    do
    {
      if ((int)v6 >= 4)
      {
        v30 = 0;
        v31 = result;
        v32 = v27;
        do
        {
          *(v31 - 2) = *v32;
          *(v31 - 1) = *(_DWORD *)((char *)v32 + a2);
          *v31 = *(_DWORD *)((char *)v32 + 2 * a2);
          v31[1] = *(_DWORD *)((char *)v32 + 3 * a2);
          v30 += 4;
          v32 = (_DWORD *)((char *)v32 + v8);
          v31 += 4;
        }
        while (v30 <= v6 - 4);
        v29 = v30;
      }
      else
      {
        v29 = 0;
      }
      if ((int)v29 < (int)v7)
      {
        v33 = v7 - v29;
        v34 = (_DWORD *)(v28 + 4 * v29);
        v35 = a2 * v29;
        do
        {
          *v34++ = *(_DWORD *)((char *)v27 + v35);
          v35 += a2;
          --v33;
        }
        while (v33);
      }
      ++v26;
      ++v27;
      result = (_DWORD *)((char *)result + a4);
      v28 += a4;
    }
    while (v26 != v5);
  }
  return result;
}

int *cv::transpose_16uC3(int *result, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int *a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int *v24;
  uint64_t v25;
  int v26;
  int v27;
  int v28;
  int v29;
  uint64_t v30;
  int v31;
  int v32;
  int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  int v53;
  uint64_t v54;
  int *v55;
  int *v56;
  uint64_t v57;
  uint64_t v58;
  int *v59;
  int *v60;
  int v61;
  int v62;
  int v63;
  int v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  int v68;
  int *v69;
  uint64_t v70;
  uint64_t v71;

  v5 = *a5;
  v6 = (int)a5[1];
  v7 = a5[1];
  v8 = 4 * a2;
  v9 = 2 * a2;
  v71 = v5;
  if ((int)v5 >= 4)
  {
    v10 = 0;
    v11 = (v5 - 4);
    v12 = 4 * a4;
    v13 = a2 + 18;
    v14 = v9 + 18;
    v15 = a3 + 3 * a4;
    v16 = a3 + a4;
    v69 = result;
    v70 = a3;
    v17 = result;
    v18 = a3;
    v19 = 3 * a2;
    v20 = a3 + 2 * a4;
    v21 = v11;
    do
    {
      if ((int)v6 >= 4)
      {
        v23 = 0;
        v24 = v17;
        v25 = v18;
        do
        {
          v26 = *v24;
          *(_WORD *)(v25 + 4) = *((_WORD *)v24 + 2);
          *(_DWORD *)v25 = v26;
          v27 = *(int *)((char *)v24 + a2);
          *(_WORD *)(v25 + 10) = *(_WORD *)((char *)v24 + v13 - 14);
          *(_DWORD *)(v25 + 6) = v27;
          v28 = *(int *)((char *)v24 + 2 * a2);
          *(_WORD *)(v25 + 16) = *(_WORD *)((char *)v24 + v14 - 14);
          *(_DWORD *)(v25 + 12) = v28;
          v29 = *(int *)((char *)v24 + 3 * a2);
          *(_WORD *)(v25 + 22) = *(_WORD *)((char *)v24 + v19 + 4);
          *(_DWORD *)(v25 + 18) = v29;
          v30 = v25 + a4;
          v31 = *(int *)((char *)v24 + 6);
          *(_WORD *)(v30 + 4) = *((_WORD *)v24 + 5);
          *(_DWORD *)v30 = v31;
          v32 = *(int *)((char *)v24 + v13 - 12);
          *(_WORD *)(v30 + 10) = *(_WORD *)((char *)v24 + v13 - 8);
          *(_DWORD *)(v30 + 6) = v32;
          v33 = *(int *)((char *)v24 + v14 - 12);
          *(_WORD *)(v30 + 16) = *(_WORD *)((char *)v24 + v14 - 8);
          *(_DWORD *)(v30 + 12) = v33;
          v34 = *(int *)((char *)v24 + v19 + 6);
          *(_WORD *)(v30 + 22) = *(_WORD *)((char *)v24 + v19 + 10);
          *(_DWORD *)(v30 + 18) = v34;
          v35 = v25 + a4 + a4;
          LODWORD(v30) = v24[3];
          *(_WORD *)(v35 + 4) = *((_WORD *)v24 + 8);
          *(_DWORD *)v35 = v30;
          LODWORD(v30) = *(int *)((char *)v24 + v13 - 6);
          *(_WORD *)(v35 + 10) = *(_WORD *)((char *)v24 + v13 - 2);
          *(_DWORD *)(v35 + 6) = v30;
          LODWORD(v30) = *(int *)((char *)v24 + v14 - 6);
          *(_WORD *)(v35 + 16) = *(_WORD *)((char *)v24 + v14 - 2);
          *(_DWORD *)(v35 + 12) = v30;
          LODWORD(v30) = *(int *)((char *)v24 + v19 + 12);
          *(_WORD *)(v35 + 22) = *(_WORD *)((char *)v24 + v19 + 16);
          *(_DWORD *)(v35 + 18) = v30;
          v36 = v35 + a4;
          LODWORD(v30) = *(int *)((char *)v24 + 18);
          *(_WORD *)(v36 + 4) = *((_WORD *)v24 + 11);
          *(_DWORD *)v36 = v30;
          LODWORD(v30) = *(int *)((char *)v24 + v13);
          *(_WORD *)(v36 + 10) = *(_WORD *)((char *)v24 + v13 + 4);
          *(_DWORD *)(v36 + 6) = v30;
          v37 = *(int *)((char *)v24 + v14);
          *(_WORD *)(v36 + 16) = *(_WORD *)((char *)v24 + v14 + 4);
          *(_DWORD *)(v36 + 12) = v37;
          v38 = *(int *)((char *)v24 + v19 + 18);
          *(_WORD *)(v36 + 22) = *(_WORD *)((char *)v24 + v19 + 22);
          *(_DWORD *)(v36 + 18) = v38;
          v23 += 4;
          v25 += 24;
          v24 = (int *)((char *)v24 + v8);
        }
        while (v23 <= v6 - 4);
        v22 = v23;
      }
      else
      {
        v22 = 0;
      }
      if ((int)v22 < (int)v7)
      {
        v39 = v7 - v22;
        v40 = 6 * v22;
        v41 = a2 * v22;
        v42 = v18;
        v43 = v16;
        v44 = v20;
        v45 = v15;
        do
        {
          v46 = v42 + v40;
          v47 = *(int *)((char *)v17 + v41);
          *(_WORD *)(v46 + 4) = *(_WORD *)((char *)v17 + v41 + 4);
          *(_DWORD *)v46 = v47;
          v48 = v43 + v40;
          v49 = *(int *)((char *)v17 + v41 + 6);
          *(_WORD *)(v48 + 4) = *(_WORD *)((char *)v17 + v41 + 10);
          *(_DWORD *)v48 = v49;
          v50 = v44 + v40;
          v51 = *(int *)((char *)v17 + v41 + 12);
          *(_WORD *)(v50 + 4) = *(_WORD *)((char *)v17 + v41 + 16);
          *(_DWORD *)v50 = v51;
          v52 = v45 + v40;
          v53 = *(int *)((char *)v17 + v41 + 18);
          v45 += 6;
          v44 += 6;
          *(_WORD *)(v52 + 4) = *(_WORD *)((char *)v17 + v41 + 22);
          *(_DWORD *)v52 = v53;
          v43 += 6;
          v42 += 6;
          v41 += a2;
          --v39;
        }
        while (v39);
      }
      v10 += 4;
      v18 += v12;
      v17 += 6;
      v15 += v12;
      v20 += v12;
      v16 += v12;
    }
    while (v10 <= v21);
    a3 = v70;
    v5 = v71;
    result = v69;
  }
  else
  {
    LODWORD(v10) = 0;
  }
  if ((int)v10 < (int)v5)
  {
    v54 = v10;
    v55 = (int *)((char *)result + 6 * v10);
    result = (int *)(a3 + a4 * v54);
    v56 = result + 3;
    do
    {
      if ((int)v6 >= 4)
      {
        v58 = 0;
        v59 = v56;
        v60 = v55;
        do
        {
          v61 = *v60;
          *((_WORD *)v59 - 4) = *((_WORD *)v60 + 2);
          *(v59 - 3) = v61;
          v62 = *(int *)((char *)v60 + a2);
          *((_WORD *)v59 - 1) = *(_WORD *)((char *)v60 + a2 + 4);
          *(int *)((char *)v59 - 6) = v62;
          v63 = *(int *)((char *)v60 + 2 * a2);
          *((_WORD *)v59 + 2) = *(_WORD *)((char *)v60 + v9 + 4);
          *v59 = v63;
          v64 = *(int *)((char *)v60 + 3 * a2);
          *((_WORD *)v59 + 5) = *(_WORD *)((char *)v60 + 3 * a2 + 4);
          *(int *)((char *)v59 + 6) = v64;
          v58 += 4;
          v60 = (int *)((char *)v60 + v8);
          v59 += 6;
        }
        while (v58 <= v6 - 4);
        v57 = v58;
        v5 = v71;
      }
      else
      {
        v57 = 0;
      }
      if ((int)v57 < (int)v7)
      {
        v65 = v7 - v57;
        v66 = (uint64_t)result + 6 * v57;
        v67 = a2 * v57;
        do
        {
          v68 = *(int *)((char *)v55 + v67);
          *(_WORD *)(v66 + 4) = *(_WORD *)((char *)v55 + v67 + 4);
          *(_DWORD *)v66 = v68;
          v66 += 6;
          v67 += a2;
          --v65;
        }
        while (v65);
      }
      ++v54;
      v55 = (int *)((char *)v55 + 6);
      v56 = (int *)((char *)v56 + a4);
      result = (int *)((char *)result + a4);
    }
    while (v54 != v5);
  }
  return result;
}

_QWORD *cv::transpose_32sC2(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int *a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  uint64_t v33;
  _QWORD *v34;
  uint64_t v35;

  v5 = *a5;
  v6 = (int)a5[1];
  v7 = a5[1];
  v8 = 4 * a2;
  if ((int)v5 >= 4)
  {
    v9 = 0;
    v10 = 4 * a4;
    v11 = a2 + 24;
    v12 = 2 * a2 + 24;
    v13 = a3 + 3 * a4;
    v14 = a3 + a4;
    v15 = result;
    v16 = a3;
    v17 = 3 * a2;
    v18 = a3 + 2 * a4;
    do
    {
      if ((int)v6 >= 4)
      {
        v19 = 0;
        v20 = v15;
        do
        {
          v21 = (_QWORD *)(v16 + 8 * v19);
          *v21 = *v20;
          v21[1] = *(_QWORD *)((char *)v20 + a2);
          v21[2] = *(_QWORD *)((char *)v20 + 2 * a2);
          v21[3] = *(_QWORD *)((char *)v20 + 3 * a2);
          v22 = (_QWORD *)((char *)v21 + a4);
          *v22 = v20[1];
          v22[1] = *(_QWORD *)((char *)v20 + v11 - 16);
          v22[2] = *(_QWORD *)((char *)v20 + v12 - 16);
          v22[3] = *(_QWORD *)((char *)v20 + v17 + 8);
          v23 = (_QWORD *)((char *)v22 + a4);
          *v23 = v20[2];
          v23[1] = *(_QWORD *)((char *)v20 + v11 - 8);
          v23[2] = *(_QWORD *)((char *)v20 + v12 - 8);
          v23[3] = *(_QWORD *)((char *)v20 + v17 + 16);
          v24 = (_QWORD *)((char *)v23 + a4);
          *v24 = v20[3];
          v24[1] = *(_QWORD *)((char *)v20 + v11);
          v24[2] = *(_QWORD *)((char *)v20 + v12);
          v24[3] = *(_QWORD *)((char *)v20 + v17 + 24);
          v19 += 4;
          v20 = (_QWORD *)((char *)v20 + v8);
        }
        while (v19 <= v6 - 4);
        v19 = v19;
      }
      else
      {
        v19 = 0;
      }
      if ((int)v19 < (int)v7)
      {
        v25 = a2 * v19;
        do
        {
          *(_QWORD *)(v16 + 8 * v19) = *(_QWORD *)((char *)v15 + v25);
          *(_QWORD *)(v14 + 8 * v19) = *(_QWORD *)((char *)v15 + v25 + 8);
          *(_QWORD *)(v18 + 8 * v19) = *(_QWORD *)((char *)v15 + v25 + 16);
          *(_QWORD *)(v13 + 8 * v19++) = *(_QWORD *)((char *)v15 + v25 + 24);
          v25 += a2;
        }
        while (v7 != v19);
      }
      v9 += 4;
      v16 += v10;
      v15 += 4;
      v13 += v10;
      v18 += v10;
      v14 += v10;
    }
    while (v9 <= (v5 - 4));
  }
  else
  {
    LODWORD(v9) = 0;
  }
  if ((int)v9 < (int)v5)
  {
    v26 = v9;
    v27 = &result[v9];
    v28 = a3 + a4 * v26;
    result = (_QWORD *)(v28 + 16);
    do
    {
      if ((int)v6 >= 4)
      {
        v30 = 0;
        v31 = result;
        v32 = v27;
        do
        {
          *(v31 - 2) = *v32;
          *(v31 - 1) = *(_QWORD *)((char *)v32 + a2);
          *v31 = *(_QWORD *)((char *)v32 + 2 * a2);
          v31[1] = *(_QWORD *)((char *)v32 + 3 * a2);
          v30 += 4;
          v32 = (_QWORD *)((char *)v32 + v8);
          v31 += 4;
        }
        while (v30 <= v6 - 4);
        v29 = v30;
      }
      else
      {
        v29 = 0;
      }
      if ((int)v29 < (int)v7)
      {
        v33 = v7 - v29;
        v34 = (_QWORD *)(v28 + 8 * v29);
        v35 = a2 * v29;
        do
        {
          *v34++ = *(_QWORD *)((char *)v27 + v35);
          v35 += a2;
          --v33;
        }
        while (v33);
      }
      ++v26;
      ++v27;
      result = (_QWORD *)((char *)result + a4);
      v28 += a4;
    }
    while (v26 != v5);
  }
  return result;
}

uint64_t *cv::transpose_32sC3(uint64_t *result, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int *a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t *v61;
  uint64_t *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t *v65;
  uint64_t *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t *v75;
  uint64_t v76;
  uint64_t v77;

  v5 = *a5;
  v6 = (int)a5[1];
  v7 = a5[1];
  v8 = 4 * a2;
  v9 = 2 * a2;
  v77 = v5;
  if ((int)v5 >= 4)
  {
    v10 = 0;
    v11 = (v5 - 4);
    v12 = 4 * a4;
    v13 = a2 + 36;
    v14 = v9 + 36;
    v15 = a3 + 3 * a4;
    v16 = a3 + a4;
    v75 = result;
    v76 = a3;
    v17 = result;
    v18 = a3;
    v19 = 3 * a2;
    v20 = a3 + 2 * a4;
    v21 = v11;
    do
    {
      if ((int)v6 >= 4)
      {
        v23 = 0;
        v24 = v17;
        v25 = v18;
        do
        {
          v26 = *v24;
          *(_DWORD *)(v25 + 8) = *((_DWORD *)v24 + 2);
          *(_QWORD *)v25 = v26;
          v27 = *(uint64_t *)((char *)v24 + a2);
          *(_DWORD *)(v25 + 20) = *(_DWORD *)((char *)v24 + v13 - 28);
          *(_QWORD *)(v25 + 12) = v27;
          v28 = *(uint64_t *)((char *)v24 + 2 * a2);
          *(_DWORD *)(v25 + 32) = *(_DWORD *)((char *)v24 + v14 - 28);
          *(_QWORD *)(v25 + 24) = v28;
          v29 = *(uint64_t *)((char *)v24 + 3 * a2);
          *(_DWORD *)(v25 + 44) = *(_DWORD *)((char *)v24 + v19 + 8);
          *(_QWORD *)(v25 + 36) = v29;
          v30 = v25 + a4;
          v31 = *(uint64_t *)((char *)v24 + 12);
          *(_DWORD *)(v30 + 8) = *((_DWORD *)v24 + 5);
          *(_QWORD *)v30 = v31;
          v32 = *(uint64_t *)((char *)v24 + v13 - 24);
          *(_DWORD *)(v30 + 20) = *(_DWORD *)((char *)v24 + v13 - 16);
          *(_QWORD *)(v30 + 12) = v32;
          v33 = *(uint64_t *)((char *)v24 + v14 - 24);
          *(_DWORD *)(v30 + 32) = *(_DWORD *)((char *)v24 + v14 - 16);
          *(_QWORD *)(v30 + 24) = v33;
          v34 = *(uint64_t *)((char *)v24 + v19 + 12);
          *(_DWORD *)(v30 + 44) = *(_DWORD *)((char *)v24 + v19 + 20);
          *(_QWORD *)(v30 + 36) = v34;
          v35 = v25 + a4 + a4;
          v36 = v24[3];
          *(_DWORD *)(v35 + 8) = *((_DWORD *)v24 + 8);
          *(_QWORD *)v35 = v36;
          v37 = *(uint64_t *)((char *)v24 + v13 - 12);
          *(_DWORD *)(v35 + 20) = *(_DWORD *)((char *)v24 + v13 - 4);
          *(_QWORD *)(v35 + 12) = v37;
          v38 = *(uint64_t *)((char *)v24 + v14 - 12);
          *(_DWORD *)(v35 + 32) = *(_DWORD *)((char *)v24 + v14 - 4);
          *(_QWORD *)(v35 + 24) = v38;
          v39 = *(uint64_t *)((char *)v24 + v19 + 24);
          *(_DWORD *)(v35 + 44) = *(_DWORD *)((char *)v24 + v19 + 32);
          *(_QWORD *)(v35 + 36) = v39;
          v40 = v35 + a4;
          v41 = *(uint64_t *)((char *)v24 + 36);
          *(_DWORD *)(v40 + 8) = *((_DWORD *)v24 + 11);
          *(_QWORD *)v40 = v41;
          v42 = *(uint64_t *)((char *)v24 + v13);
          *(_DWORD *)(v40 + 20) = *(_DWORD *)((char *)v24 + v13 + 8);
          *(_QWORD *)(v40 + 12) = v42;
          v43 = *(uint64_t *)((char *)v24 + v14);
          *(_DWORD *)(v40 + 32) = *(_DWORD *)((char *)v24 + v14 + 8);
          *(_QWORD *)(v40 + 24) = v43;
          v44 = *(uint64_t *)((char *)v24 + v19 + 36);
          *(_DWORD *)(v40 + 44) = *(_DWORD *)((char *)v24 + v19 + 44);
          *(_QWORD *)(v40 + 36) = v44;
          v23 += 4;
          v25 += 48;
          v24 = (uint64_t *)((char *)v24 + v8);
        }
        while (v23 <= v6 - 4);
        v22 = v23;
      }
      else
      {
        v22 = 0;
      }
      if ((int)v22 < (int)v7)
      {
        v45 = v7 - v22;
        v46 = 12 * v22;
        v47 = a2 * v22;
        v48 = v18;
        v49 = v16;
        v50 = v20;
        v51 = v15;
        do
        {
          v52 = v48 + v46;
          v53 = *(uint64_t *)((char *)v17 + v47);
          *(_DWORD *)(v52 + 8) = *(_DWORD *)((char *)v17 + v47 + 8);
          *(_QWORD *)v52 = v53;
          v54 = v49 + v46;
          v55 = *(uint64_t *)((char *)v17 + v47 + 12);
          *(_DWORD *)(v54 + 8) = *(_DWORD *)((char *)v17 + v47 + 20);
          *(_QWORD *)v54 = v55;
          v56 = v50 + v46;
          v57 = *(uint64_t *)((char *)v17 + v47 + 24);
          *(_DWORD *)(v56 + 8) = *(_DWORD *)((char *)v17 + v47 + 32);
          *(_QWORD *)v56 = v57;
          v58 = v51 + v46;
          v59 = *(uint64_t *)((char *)v17 + v47 + 36);
          v51 += 12;
          v50 += 12;
          *(_DWORD *)(v58 + 8) = *(_DWORD *)((char *)v17 + v47 + 44);
          *(_QWORD *)v58 = v59;
          v49 += 12;
          v48 += 12;
          v47 += a2;
          --v45;
        }
        while (v45);
      }
      v10 += 4;
      v18 += v12;
      v17 += 6;
      v15 += v12;
      v20 += v12;
      v16 += v12;
    }
    while (v10 <= v21);
    a3 = v76;
    v5 = v77;
    result = v75;
  }
  else
  {
    LODWORD(v10) = 0;
  }
  if ((int)v10 < (int)v5)
  {
    v60 = v10;
    v61 = (uint64_t *)((char *)result + 12 * v10);
    result = (uint64_t *)(a3 + a4 * v60);
    v62 = result + 3;
    do
    {
      if ((int)v6 >= 4)
      {
        v64 = 0;
        v65 = v62;
        v66 = v61;
        do
        {
          v67 = *v66;
          *((_DWORD *)v65 - 4) = *((_DWORD *)v66 + 2);
          *(v65 - 3) = v67;
          v68 = *(uint64_t *)((char *)v66 + a2);
          *((_DWORD *)v65 - 1) = *(_DWORD *)((char *)v66 + a2 + 8);
          *(uint64_t *)((char *)v65 - 12) = v68;
          v69 = *(uint64_t *)((char *)v66 + 2 * a2);
          *((_DWORD *)v65 + 2) = *(_DWORD *)((char *)v66 + v9 + 8);
          *v65 = v69;
          v70 = *(uint64_t *)((char *)v66 + 3 * a2);
          *((_DWORD *)v65 + 5) = *(_DWORD *)((char *)v66 + 3 * a2 + 8);
          *(uint64_t *)((char *)v65 + 12) = v70;
          v64 += 4;
          v66 = (uint64_t *)((char *)v66 + v8);
          v65 += 6;
        }
        while (v64 <= v6 - 4);
        v63 = v64;
        v5 = v77;
      }
      else
      {
        v63 = 0;
      }
      if ((int)v63 < (int)v7)
      {
        v71 = v7 - v63;
        v72 = (uint64_t)result + 12 * v63;
        v73 = a2 * v63;
        do
        {
          v74 = *(uint64_t *)((char *)v61 + v73);
          *(_DWORD *)(v72 + 8) = *(_DWORD *)((char *)v61 + v73 + 8);
          *(_QWORD *)v72 = v74;
          v72 += 12;
          v73 += a2;
          --v71;
        }
        while (v71);
      }
      ++v60;
      v61 = (uint64_t *)((char *)v61 + 12);
      v62 = (uint64_t *)((char *)v62 + a4);
      result = (uint64_t *)((char *)result + a4);
    }
    while (v60 != v5);
  }
  return result;
}

_OWORD *cv::transpose_32sC4(_OWORD *result, uint64_t a2, _OWORD *a3, uint64_t a4, unsigned int *a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _OWORD *v15;
  _OWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _OWORD *v21;
  _OWORD *v22;
  _OWORD *v23;
  _OWORD *v24;
  _OWORD *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _OWORD *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  _OWORD *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  _OWORD *v38;
  _OWORD *v39;
  uint64_t v40;
  _OWORD *v41;
  uint64_t v42;

  v5 = *a5;
  v6 = (int)a5[1];
  v7 = a5[1];
  v8 = 4 * a2;
  if ((int)v5 >= 4)
  {
    v9 = 0;
    v10 = 4 * a4;
    v11 = a2 + 48;
    v12 = 2 * a2 + 48;
    v13 = (uint64_t)a3 + 3 * a4;
    v14 = (uint64_t)a3 + a4;
    v15 = result;
    v16 = a3;
    v17 = 3 * a2;
    v18 = (uint64_t)a3 + 2 * a4;
    do
    {
      if ((int)v6 >= 4)
      {
        v20 = 0;
        v21 = v15;
        v22 = v16;
        do
        {
          *v22 = *v21;
          v22[1] = *(_OWORD *)((char *)v21 + a2);
          v22[2] = *(_OWORD *)((char *)v21 + 2 * a2);
          v22[3] = *(_OWORD *)((char *)v21 + 3 * a2);
          v23 = (_OWORD *)((char *)v22 + a4);
          *v23 = v21[1];
          v23[1] = *(_OWORD *)((char *)v21 + v11 - 32);
          v23[2] = *(_OWORD *)((char *)v21 + v12 - 32);
          v23[3] = *(_OWORD *)((char *)v21 + v17 + 16);
          v24 = (_OWORD *)((char *)v22 + a4 + a4);
          *v24 = v21[2];
          v24[1] = *(_OWORD *)((char *)v21 + v11 - 16);
          v24[2] = *(_OWORD *)((char *)v21 + v12 - 16);
          v24[3] = *(_OWORD *)((char *)v21 + v17 + 32);
          v25 = (_OWORD *)((char *)v24 + a4);
          *v25 = v21[3];
          v25[1] = *(_OWORD *)((char *)v21 + v11);
          v25[2] = *(_OWORD *)((char *)v21 + v12);
          v25[3] = *(_OWORD *)((char *)v21 + v17 + 48);
          v20 += 4;
          v22 += 4;
          v21 = (_OWORD *)((char *)v21 + v8);
        }
        while (v20 <= v6 - 4);
        v19 = v20;
      }
      else
      {
        v19 = 0;
      }
      if ((int)v19 < (int)v7)
      {
        v26 = v7 - v19;
        v27 = 16 * v19;
        v28 = a2 * v19;
        v29 = v16;
        v30 = v14;
        v31 = v18;
        v32 = v13;
        do
        {
          v29[(unint64_t)v27 / 0x10] = *(_OWORD *)((char *)v15 + v28);
          *(_OWORD *)(v30 + v27) = *(_OWORD *)((char *)v15 + v28 + 16);
          *(_OWORD *)(v31 + v27) = *(_OWORD *)((char *)v15 + v28 + 32);
          *(_OWORD *)(v32 + v27) = *(_OWORD *)((char *)v15 + v28 + 48);
          v32 += 16;
          v31 += 16;
          v30 += 16;
          ++v29;
          v28 += a2;
          --v26;
        }
        while (v26);
      }
      v9 += 4;
      v16 = (_OWORD *)((char *)v16 + v10);
      v15 += 4;
      v13 += v10;
      v18 += v10;
      v14 += v10;
    }
    while (v9 <= (v5 - 4));
  }
  else
  {
    LODWORD(v9) = 0;
  }
  if ((int)v9 < (int)v5)
  {
    v33 = v9;
    v34 = &result[v9];
    v35 = (uint64_t)a3 + a4 * v33;
    result = (_OWORD *)(v35 + 32);
    do
    {
      if ((int)v6 >= 4)
      {
        v37 = 0;
        v38 = result;
        v39 = v34;
        do
        {
          *(v38 - 2) = *v39;
          *(v38 - 1) = *(_OWORD *)((char *)v39 + a2);
          *v38 = *(_OWORD *)((char *)v39 + 2 * a2);
          v38[1] = *(_OWORD *)((char *)v39 + 3 * a2);
          v37 += 4;
          v39 = (_OWORD *)((char *)v39 + v8);
          v38 += 4;
        }
        while (v37 <= v6 - 4);
        v36 = v37;
      }
      else
      {
        v36 = 0;
      }
      if ((int)v36 < (int)v7)
      {
        v40 = v7 - v36;
        v41 = (_OWORD *)(v35 + 16 * v36);
        v42 = a2 * v36;
        do
        {
          *v41++ = *(_OWORD *)((char *)v34 + v42);
          v42 += a2;
          --v40;
        }
        while (v40);
      }
      ++v33;
      ++v34;
      result = (_OWORD *)((char *)result + a4);
      v35 += a4;
    }
    while (v33 != v5);
  }
  return result;
}

unint64_t cv::transpose_32sC6(unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int *a5)
{
  __int128 *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __int128 *v22;
  uint64_t v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  __int128 v51;
  uint64_t v52;
  __int128 v53;
  uint64_t v54;
  __int128 v55;
  uint64_t v56;
  __int128 v57;
  uint64_t v58;
  __int128 *v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  __int128 *v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  uint64_t v69;
  unint64_t v70;
  uint64_t v71;
  __int128 v72;
  __int128 *v73;
  uint64_t v74;

  v5 = (__int128 *)result;
  v6 = *a5;
  v7 = (int)a5[1];
  v8 = a5[1];
  v9 = 4 * a2;
  v10 = 2 * a2;
  if ((int)v6 >= 4)
  {
    v11 = 0;
    v73 = (__int128 *)result;
    v74 = *a5;
    result = (v6 - 4);
    v12 = 4 * a4;
    v13 = a2 + 72;
    v14 = v10 + 72;
    v15 = a3 + 3 * a4;
    v16 = a3 + a4;
    v17 = a3;
    v18 = 3 * a2;
    v19 = a3 + 2 * a4;
    do
    {
      if ((int)v7 >= 4)
      {
        v21 = 0;
        v22 = v5;
        v23 = v17;
        do
        {
          v24 = *v22;
          *(_QWORD *)(v23 + 16) = *((_QWORD *)v22 + 2);
          *(_OWORD *)v23 = v24;
          v25 = *(__int128 *)((char *)v22 + a2);
          *(_QWORD *)(v23 + 40) = *(_QWORD *)((char *)v22 + v13 - 56);
          *(_OWORD *)(v23 + 24) = v25;
          v26 = *(__int128 *)((char *)v22 + 2 * a2);
          *(_QWORD *)(v23 + 64) = *(_QWORD *)((char *)v22 + v14 - 56);
          *(_OWORD *)(v23 + 48) = v26;
          v27 = *(__int128 *)((char *)v22 + 3 * a2);
          *(_QWORD *)(v23 + 88) = *(_QWORD *)((char *)v22 + v18 + 16);
          *(_OWORD *)(v23 + 72) = v27;
          v28 = v23 + a4;
          v29 = *(__int128 *)((char *)v22 + 24);
          *(_QWORD *)(v28 + 16) = *((_QWORD *)v22 + 5);
          *(_OWORD *)v28 = v29;
          v30 = *(__int128 *)((char *)v22 + v13 - 48);
          *(_QWORD *)(v28 + 40) = *(_QWORD *)((char *)v22 + v13 - 32);
          *(_OWORD *)(v28 + 24) = v30;
          v31 = *(__int128 *)((char *)v22 + v14 - 48);
          *(_QWORD *)(v28 + 64) = *(_QWORD *)((char *)v22 + v14 - 32);
          *(_OWORD *)(v28 + 48) = v31;
          v32 = *(__int128 *)((char *)v22 + v18 + 24);
          *(_QWORD *)(v28 + 88) = *(_QWORD *)((char *)v22 + v18 + 40);
          *(_OWORD *)(v28 + 72) = v32;
          v33 = v23 + a4 + a4;
          v34 = v22[3];
          *(_QWORD *)(v33 + 16) = *((_QWORD *)v22 + 8);
          *(_OWORD *)v33 = v34;
          v35 = *(__int128 *)((char *)v22 + v13 - 24);
          *(_QWORD *)(v33 + 40) = *(_QWORD *)((char *)v22 + v13 - 8);
          *(_OWORD *)(v33 + 24) = v35;
          v36 = *(__int128 *)((char *)v22 + v14 - 24);
          *(_QWORD *)(v33 + 64) = *(_QWORD *)((char *)v22 + v14 - 8);
          *(_OWORD *)(v33 + 48) = v36;
          v37 = *(__int128 *)((char *)v22 + v18 + 48);
          *(_QWORD *)(v33 + 88) = *(_QWORD *)((char *)v22 + v18 + 64);
          *(_OWORD *)(v33 + 72) = v37;
          v38 = v33 + a4;
          v39 = *(__int128 *)((char *)v22 + 72);
          *(_QWORD *)(v38 + 16) = *((_QWORD *)v22 + 11);
          *(_OWORD *)v38 = v39;
          v40 = *(__int128 *)((char *)v22 + v13);
          *(_QWORD *)(v38 + 40) = *(_QWORD *)((char *)v22 + v13 + 16);
          *(_OWORD *)(v38 + 24) = v40;
          v41 = *(__int128 *)((char *)v22 + v14);
          *(_QWORD *)(v38 + 64) = *(_QWORD *)((char *)v22 + v14 + 16);
          *(_OWORD *)(v38 + 48) = v41;
          v42 = *(__int128 *)((char *)v22 + v18 + 72);
          *(_QWORD *)(v38 + 88) = *(_QWORD *)((char *)v22 + v18 + 88);
          *(_OWORD *)(v38 + 72) = v42;
          v21 += 4;
          v23 += 96;
          v22 = (__int128 *)((char *)v22 + v9);
        }
        while (v21 <= v7 - 4);
        v20 = v21;
      }
      else
      {
        v20 = 0;
      }
      if ((int)v20 < (int)v8)
      {
        v43 = v8 - v20;
        v44 = 24 * v20;
        v45 = a2 * v20;
        v46 = v17;
        v47 = v16;
        v48 = v19;
        v49 = v15;
        do
        {
          v50 = v46 + v44;
          v51 = *(__int128 *)((char *)v5 + v45);
          *(_QWORD *)(v50 + 16) = *(_QWORD *)((char *)v5 + v45 + 16);
          *(_OWORD *)v50 = v51;
          v52 = v47 + v44;
          v53 = *(__int128 *)((char *)v5 + v45 + 24);
          *(_QWORD *)(v52 + 16) = *(_QWORD *)((char *)v5 + v45 + 40);
          *(_OWORD *)v52 = v53;
          v54 = v48 + v44;
          v55 = *(__int128 *)((char *)v5 + v45 + 48);
          *(_QWORD *)(v54 + 16) = *(_QWORD *)((char *)v5 + v45 + 64);
          *(_OWORD *)v54 = v55;
          v56 = v49 + v44;
          v57 = *(__int128 *)((char *)v5 + v45 + 72);
          v49 += 24;
          v48 += 24;
          *(_QWORD *)(v56 + 16) = *(_QWORD *)((char *)v5 + v45 + 88);
          *(_OWORD *)v56 = v57;
          v47 += 24;
          v46 += 24;
          v45 += a2;
          --v43;
        }
        while (v43);
      }
      v11 += 4;
      v17 += v12;
      v5 += 6;
      v15 += v12;
      v19 += v12;
      v16 += v12;
    }
    while (v11 <= result);
    v5 = v73;
    v6 = v74;
  }
  else
  {
    LODWORD(v11) = 0;
  }
  if ((int)v11 < (int)v6)
  {
    v58 = v11;
    v59 = (__int128 *)((char *)v5 + 24 * v11);
    result = a3 + a4 * v58;
    v60 = result + 48;
    do
    {
      if ((int)v7 >= 4)
      {
        v62 = 0;
        v63 = v60;
        v64 = v59;
        do
        {
          v65 = *v64;
          *(_QWORD *)(v63 - 32) = *((_QWORD *)v64 + 2);
          *(_OWORD *)(v63 - 48) = v65;
          v66 = *(__int128 *)((char *)v64 + a2);
          *(_QWORD *)(v63 - 8) = *(_QWORD *)((char *)v64 + a2 + 16);
          *(_OWORD *)(v63 - 24) = v66;
          v67 = *(__int128 *)((char *)v64 + 2 * a2);
          *(_QWORD *)(v63 + 16) = *(_QWORD *)((char *)v64 + v10 + 16);
          *(_OWORD *)v63 = v67;
          v68 = *(__int128 *)((char *)v64 + 3 * a2);
          *(_QWORD *)(v63 + 40) = *(_QWORD *)((char *)v64 + 3 * a2 + 16);
          *(_OWORD *)(v63 + 24) = v68;
          v62 += 4;
          v64 = (__int128 *)((char *)v64 + v9);
          v63 += 96;
        }
        while (v62 <= v7 - 4);
        v61 = v62;
      }
      else
      {
        v61 = 0;
      }
      if ((int)v61 < (int)v8)
      {
        v69 = v8 - v61;
        v70 = result + 24 * v61;
        v71 = a2 * v61;
        do
        {
          v72 = *(__int128 *)((char *)v59 + v71);
          *(_QWORD *)(v70 + 16) = *(_QWORD *)((char *)v59 + v71 + 16);
          *(_OWORD *)v70 = v72;
          v70 += 24;
          v71 += a2;
          --v69;
        }
        while (v69);
      }
      ++v58;
      v59 = (__int128 *)((char *)v59 + 24);
      v60 += a4;
      result += a4;
    }
    while (v58 != v6);
  }
  return result;
}

_OWORD *cv::transpose_32sC8(_OWORD *result, uint64_t a2, _OWORD *a3, uint64_t a4, unsigned int *a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _OWORD *v17;
  _OWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _OWORD *v23;
  _OWORD *v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  _OWORD *v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  _OWORD *v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  _OWORD *v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  _OWORD *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  _OWORD *v51;
  __int128 v52;
  _OWORD *v53;
  __int128 v54;
  _OWORD *v55;
  __int128 v56;
  _OWORD *v57;
  __int128 v58;
  _OWORD *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  _OWORD *v63;
  _OWORD *v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  uint64_t v69;
  _OWORD *v70;
  uint64_t v71;
  __int128 v72;
  uint64_t v73;

  v5 = *a5;
  v6 = (int)a5[1];
  v7 = a5[1];
  v8 = 4 * a2;
  v9 = 2 * a2;
  if ((int)v5 >= 4)
  {
    v10 = 0;
    v73 = *a5;
    v11 = (v5 - 4);
    v12 = 4 * a4;
    v13 = a2 + 96;
    v14 = v9 + 96;
    v15 = (uint64_t)a3 + 3 * a4;
    v16 = (uint64_t)a3 + a4;
    v17 = result;
    v18 = a3;
    v19 = 3 * a2;
    v20 = (uint64_t)a3 + 2 * a4;
    do
    {
      if ((int)v6 >= 4)
      {
        v22 = 0;
        v23 = v17;
        v24 = v18;
        do
        {
          v25 = v23[1];
          *v24 = *v23;
          v24[1] = v25;
          v26 = *(_OWORD *)((char *)v23 + v13 - 80);
          v24[2] = *(_OWORD *)((char *)v23 + a2);
          v24[3] = v26;
          v27 = *(_OWORD *)((char *)v23 + v14 - 80);
          v24[4] = *(_OWORD *)((char *)v23 + 2 * a2);
          v24[5] = v27;
          v28 = *(_OWORD *)((char *)v23 + v19 + 16);
          v24[6] = *(_OWORD *)((char *)v23 + 3 * a2);
          v24[7] = v28;
          v29 = (_OWORD *)((char *)v24 + a4);
          v30 = v23[3];
          *v29 = v23[2];
          v29[1] = v30;
          v31 = *(_OWORD *)((char *)v23 + v13 - 48);
          v29[2] = *(_OWORD *)((char *)v23 + v13 - 64);
          v29[3] = v31;
          v32 = *(_OWORD *)((char *)v23 + v14 - 48);
          v29[4] = *(_OWORD *)((char *)v23 + v14 - 64);
          v29[5] = v32;
          v33 = *(_OWORD *)((char *)v23 + v19 + 48);
          v29[6] = *(_OWORD *)((char *)v23 + v19 + 32);
          v29[7] = v33;
          v34 = (_OWORD *)((char *)v24 + a4 + a4);
          v35 = v23[5];
          *v34 = v23[4];
          v34[1] = v35;
          v36 = *(_OWORD *)((char *)v23 + v13 - 16);
          v34[2] = *(_OWORD *)((char *)v23 + v13 - 32);
          v34[3] = v36;
          v37 = *(_OWORD *)((char *)v23 + v14 - 16);
          v34[4] = *(_OWORD *)((char *)v23 + v14 - 32);
          v34[5] = v37;
          v38 = *(_OWORD *)((char *)v23 + v19 + 80);
          v34[6] = *(_OWORD *)((char *)v23 + v19 + 64);
          v34[7] = v38;
          v39 = (_OWORD *)((char *)v34 + a4);
          v40 = v23[7];
          *v39 = v23[6];
          v39[1] = v40;
          v41 = *(_OWORD *)((char *)v23 + v13 + 16);
          v39[2] = *(_OWORD *)((char *)v23 + v13);
          v39[3] = v41;
          v42 = *(_OWORD *)((char *)v23 + v14 + 16);
          v39[4] = *(_OWORD *)((char *)v23 + v14);
          v39[5] = v42;
          v43 = *(_OWORD *)((char *)v23 + v19 + 112);
          v39[6] = *(_OWORD *)((char *)v23 + v19 + 96);
          v39[7] = v43;
          v22 += 4;
          v24 += 8;
          v23 = (_OWORD *)((char *)v23 + v8);
        }
        while (v22 <= v6 - 4);
        v21 = v22;
      }
      else
      {
        v21 = 0;
      }
      if ((int)v21 < (int)v7)
      {
        v44 = v7 - v21;
        v45 = 32 * v21;
        v46 = a2 * v21;
        v47 = v18;
        v48 = v16;
        v49 = v20;
        v50 = v15;
        do
        {
          v51 = &v47[(unint64_t)v45 / 0x10];
          v52 = *(_OWORD *)((char *)v17 + v46 + 16);
          *v51 = *(_OWORD *)((char *)v17 + v46);
          v51[1] = v52;
          v53 = (_OWORD *)(v48 + v45);
          v54 = *(_OWORD *)((char *)v17 + v46 + 48);
          *v53 = *(_OWORD *)((char *)v17 + v46 + 32);
          v53[1] = v54;
          v55 = (_OWORD *)(v49 + v45);
          v56 = *(_OWORD *)((char *)v17 + v46 + 80);
          *v55 = *(_OWORD *)((char *)v17 + v46 + 64);
          v55[1] = v56;
          v57 = (_OWORD *)(v50 + v45);
          v58 = *(_OWORD *)((char *)v17 + v46 + 112);
          v50 += 32;
          v49 += 32;
          *v57 = *(_OWORD *)((char *)v17 + v46 + 96);
          v57[1] = v58;
          v48 += 32;
          v47 += 2;
          v46 += a2;
          --v44;
        }
        while (v44);
      }
      v10 += 4;
      v18 = (_OWORD *)((char *)v18 + v12);
      v17 += 8;
      v15 += v12;
      v20 += v12;
      v16 += v12;
    }
    while (v10 <= v11);
    v5 = v73;
  }
  else
  {
    LODWORD(v10) = 0;
  }
  if ((int)v10 < (int)v5)
  {
    v10 = v10;
    v59 = &result[2 * v10];
    v60 = (uint64_t)a3 + a4 * v10;
    result = (_OWORD *)(v60 + 64);
    do
    {
      if ((int)v6 >= 4)
      {
        v62 = 0;
        v63 = result;
        v64 = v59;
        do
        {
          v65 = v64[1];
          *(v63 - 4) = *v64;
          *(v63 - 3) = v65;
          v66 = *(_OWORD *)((char *)v64 + a2 + 16);
          *(v63 - 2) = *(_OWORD *)((char *)v64 + a2);
          *(v63 - 1) = v66;
          v67 = *(_OWORD *)((char *)v64 + v9 + 16);
          *v63 = *(_OWORD *)((char *)v64 + 2 * a2);
          v63[1] = v67;
          v68 = *(_OWORD *)((char *)v64 + 3 * a2 + 16);
          v63[2] = *(_OWORD *)((char *)v64 + 3 * a2);
          v63[3] = v68;
          v62 += 4;
          v64 = (_OWORD *)((char *)v64 + v8);
          v63 += 8;
        }
        while (v62 <= v6 - 4);
        v61 = v62;
      }
      else
      {
        v61 = 0;
      }
      if ((int)v61 < (int)v7)
      {
        v69 = v7 - v61;
        v70 = (_OWORD *)(v60 + 32 * v61);
        v71 = a2 * v61;
        do
        {
          v72 = *(_OWORD *)((char *)v59 + v71 + 16);
          *v70 = *(_OWORD *)((char *)v59 + v71);
          v70[1] = v72;
          v70 += 2;
          v71 += a2;
          --v69;
        }
        while (v69);
      }
      ++v10;
      v59 += 2;
      result = (_OWORD *)((char *)result + a4);
      v60 += a4;
    }
    while (v10 != v5);
  }
  return result;
}

void **std::vector<cv::Mat>::__append(uint64_t *a1, unint64_t a2)
{
  void **result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  char *v16;
  uint64_t v17;
  _QWORD *v18;
  void *v19;
  char *v20;
  char *v21;
  char *v22;
  void **v23;

  v6 = a1[2];
  result = (void **)(a1 + 2);
  v5 = v6;
  v7 = (uint64_t)*(result - 1);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 5) >= a2)
  {
    if (a2)
    {
      v13 = v7 + 96 * a2;
      v14 = 96 * a2;
      v15 = (_QWORD *)(v7 + 80);
      do
      {
        *(v15 - 2) = v15 - 9;
        *(v15 - 1) = v15;
        *v15 = 0;
        v15[1] = 0;
        *((_DWORD *)v15 - 20) = 1124007936;
        *(_OWORD *)((char *)v15 - 76) = 0uLL;
        *(_OWORD *)((char *)v15 - 60) = 0uLL;
        *(_OWORD *)((char *)v15 - 44) = 0uLL;
        *((_OWORD *)v15 - 2) = 0uLL;
        v15 += 12;
        v14 -= 96;
      }
      while (v14);
    }
    else
    {
      v13 = (uint64_t)*(result - 1);
    }
    a1[1] = v13;
  }
  else
  {
    v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 5);
    v9 = v8 + a2;
    if (v8 + a2 > 0x2AAAAAAAAAAAAAALL)
      std::vector<int>::__throw_length_error[abi:ne180100]();
    v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 5);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x155555555555555)
      v11 = 0x2AAAAAAAAAAAAAALL;
    else
      v11 = v9;
    v23 = result;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cv::Mat>>((uint64_t)result, v11);
    else
      v12 = 0;
    v19 = v12;
    v20 = &v12[96 * v8];
    v22 = &v12[96 * v11];
    v16 = &v20[96 * a2];
    v17 = 96 * a2;
    v18 = v20 + 80;
    do
    {
      *(v18 - 2) = v18 - 9;
      *(v18 - 1) = v18;
      *v18 = 0;
      v18[1] = 0;
      *((_DWORD *)v18 - 20) = 1124007936;
      *(_OWORD *)((char *)v18 - 76) = 0uLL;
      *(_OWORD *)((char *)v18 - 60) = 0uLL;
      *(_OWORD *)((char *)v18 - 44) = 0uLL;
      *((_OWORD *)v18 - 2) = 0uLL;
      v18 += 12;
      v17 -= 96;
    }
    while (v17);
    v21 = v16;
    std::vector<cv::Mat>::__swap_out_circular_buffer(a1, &v19);
    return std::__split_buffer<cv::Mat>::~__split_buffer(&v19);
  }
  return result;
}

void sub_219E76724(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<cv::Mat>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<cv::Mat>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<cv::Mat>,std::reverse_iterator<cv::Mat*>,std::reverse_iterator<cv::Mat*>,std::reverse_iterator<cv::Mat*>>((uint64_t)(a1 + 2), a1[1], (cv::Mat *)a1[1], *a1, (cv::Mat *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<cv::Mat>,std::reverse_iterator<cv::Mat*>,std::reverse_iterator<cv::Mat*>,std::reverse_iterator<cv::Mat*>>(uint64_t a1, uint64_t a2, cv::Mat *a3, uint64_t a4, cv::Mat *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  cv::Mat *v9;
  int v10;
  uint64_t v11;
  _QWORD v13[3];
  char v14;
  __int128 v15;
  __int128 v16;

  v7 = a7;
  *(_QWORD *)&v16 = a6;
  *((_QWORD *)&v16 + 1) = a7;
  v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  v14 = 0;
  if (a3 == a5)
  {
    v11 = a6;
  }
  else
  {
    v9 = a3;
    v10 = a1;
    do
    {
      v9 = (cv::Mat *)((char *)v9 - 96);
      std::allocator<cv::Mat>::construct[abi:ne180100]<cv::Mat,cv::Mat&>(v10, (cv::Mat *)(v7 - 96), v9);
      v7 = *((_QWORD *)&v16 + 1) - 96;
      *((_QWORD *)&v16 + 1) -= 96;
    }
    while (v9 != a5);
    v11 = v16;
  }
  v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<cv::Mat>,std::reverse_iterator<cv::Mat*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

void sub_219E76860(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<cv::Mat>,std::reverse_iterator<cv::Mat*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<cv::Mat>,std::reverse_iterator<cv::Mat*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<cv::Mat>,std::reverse_iterator<cv::Mat*>>::operator()[abi:ne180100]((uint64_t *)a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<cv::Mat>,std::reverse_iterator<cv::Mat*>>::operator()[abi:ne180100](uint64_t *a1)
{
  cv::Mat *v1;
  cv::Mat *v2;
  uint64_t v3;

  v1 = *(cv::Mat **)(a1[2] + 8);
  v2 = *(cv::Mat **)(a1[1] + 8);
  if (v1 != v2)
  {
    v3 = *a1;
    do
    {
      std::allocator<cv::Mat>::destroy[abi:ne180100](v3, v1);
      v1 = (cv::Mat *)((char *)v1 + 96);
    }
    while (v1 != v2);
  }
}

void **std::__split_buffer<cv::Mat>::~__split_buffer(void **a1)
{
  std::__split_buffer<cv::Mat>::clear[abi:ne180100](a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void std::__split_buffer<cv::Mat>::clear[abi:ne180100](_QWORD *a1)
{
  uint64_t i;
  uint64_t v2;
  uint64_t v4;

  v2 = a1[1];
  for (i = a1[2]; i != v2; i = a1[2])
  {
    v4 = a1[4];
    a1[2] = i - 96;
    std::allocator<cv::Mat>::destroy[abi:ne180100](v4, (cv::Mat *)(i - 96));
  }
}

cv::Mat *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<cv::Mat const*,cv::Mat const*,cv::Mat*>(int a1, cv::Mat *a2, cv::Mat *a3, cv::Mat *this)
{
  cv::Mat *v5;
  unsigned int *v7;
  unsigned int v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  _QWORD *v16;
  _QWORD *v17;

  v5 = a2;
  if (a2 != a3)
  {
    while (this == v5)
    {
LABEL_19:
      v5 = (cv::Mat *)((char *)v5 + 96);
      this = (cv::Mat *)((char *)this + 96);
      if (v5 == a3)
        return a3;
    }
    v7 = (unsigned int *)*((_QWORD *)v5 + 3);
    if (v7)
    {
      do
        v8 = __ldaxr(v7);
      while (__stlxr(v8 + 1, v7));
    }
    v9 = (unsigned int *)*((_QWORD *)this + 3);
    if (v9)
    {
      do
      {
        v10 = __ldaxr(v9);
        v11 = v10 - 1;
      }
      while (__stlxr(v11, v9));
      if (!v11)
        cv::Mat::deallocate(this, a2);
    }
    *((_QWORD *)this + 2) = 0;
    *((_QWORD *)this + 5) = 0;
    *((_QWORD *)this + 6) = 0;
    *((_QWORD *)this + 4) = 0;
    if (*((int *)this + 1) <= 0)
    {
      *((_QWORD *)this + 3) = 0;
      *(_DWORD *)this = *(_DWORD *)v5;
    }
    else
    {
      v12 = 0;
      v13 = *((_QWORD *)this + 8);
      do
      {
        *(_DWORD *)(v13 + 4 * v12++) = 0;
        v14 = *((int *)this + 1);
      }
      while (v12 < v14);
      *((_QWORD *)this + 3) = 0;
      *(_DWORD *)this = *(_DWORD *)v5;
      if ((int)v14 > 2)
        goto LABEL_17;
    }
    v15 = *((_DWORD *)v5 + 1);
    if (v15 <= 2)
    {
      *((_DWORD *)this + 1) = v15;
      *((_QWORD *)this + 1) = *((_QWORD *)v5 + 1);
      v16 = (_QWORD *)*((_QWORD *)v5 + 9);
      v17 = (_QWORD *)*((_QWORD *)this + 9);
      *v17 = *v16;
      v17[1] = v16[1];
LABEL_18:
      *((_OWORD *)this + 2) = *((_OWORD *)v5 + 2);
      *((_QWORD *)this + 6) = *((_QWORD *)v5 + 6);
      *((_OWORD *)this + 1) = *((_OWORD *)v5 + 1);
      *((_QWORD *)this + 7) = *((_QWORD *)v5 + 7);
      goto LABEL_19;
    }
LABEL_17:
    cv::Mat::copySize(this, v5);
    goto LABEL_18;
  }
  return v5;
}

void std::vector<std::vector<unsigned char>>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  size_t v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      v13 = 24 * ((24 * a2 - 24) / 0x18) + 24;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 3);
    v9 = v8 + a2;
    if (v8 + a2 > 0xAAAAAAAAAAAAAAALL)
      std::vector<int>::__throw_length_error[abi:ne180100]();
    v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x555555555555555)
      v11 = 0xAAAAAAAAAAAAAAALL;
    else
      v11 = v9;
    v19 = v4;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<long long,long long,float>>>(v4, v11);
    else
      v12 = 0;
    v15 = v12;
    v16 = &v12[24 * v8];
    v18 = &v12[24 * v11];
    v14 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v16, v14);
    v17 = &v16[v14];
    std::vector<std::vector<unsigned char>>::__swap_out_circular_buffer(a1, &v15);
    std::__split_buffer<std::vector<long long>>::~__split_buffer((uint64_t)&v15);
  }
}

void sub_219E76C08(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<std::vector<long long>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::vector<unsigned char>>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<unsigned char>>,std::reverse_iterator<std::vector<unsigned char>*>,std::reverse_iterator<std::vector<unsigned char>*>,std::reverse_iterator<std::vector<unsigned char>*>>((uint64_t)(a1 + 2), a1[1], (_QWORD *)a1[1], *a1, (_QWORD *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<unsigned char>>,std::reverse_iterator<std::vector<unsigned char>*>,std::reverse_iterator<std::vector<unsigned char>*>,std::reverse_iterator<std::vector<unsigned char>*>>(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, _QWORD *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  _QWORD v11[3];
  char v12;
  __int128 v13;
  __int128 v14;

  v7 = a7;
  *(_QWORD *)&v14 = a6;
  *((_QWORD *)&v14 + 1) = a7;
  v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    v9 = a6;
  }
  else
  {
    do
    {
      *(_QWORD *)(v7 - 24) = 0;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v7 - 8) = 0;
      v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(_QWORD *)(v7 - 8) = a3[2];
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      v7 = *((_QWORD *)&v14 + 1) - 24;
      *((_QWORD *)&v14 + 1) -= 24;
    }
    while (a3 != a5);
    v9 = v14;
  }
  v12 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<unsigned char>>,std::reverse_iterator<std::vector<unsigned char>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<unsigned char>>,std::reverse_iterator<std::vector<unsigned char>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<long long>>,std::reverse_iterator<std::vector<long long>*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::vector<cv::Vec<unsigned char,2>>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  char v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 1)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 2 * a2);
      v7 += 2 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - *a1;
    if ((uint64_t)(a2 + (v8 >> 1)) < 0)
      std::vector<int>::__throw_length_error[abi:ne180100]();
    v9 = v8 >> 1;
    v10 = v5 - *a1;
    if (v10 <= a2 + (v8 >> 1))
      v11 = a2 + (v8 >> 1);
    else
      v11 = v10;
    if (v10 >= 0x7FFFFFFFFFFFFFFELL)
      v12 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cv::Vec<unsigned char,2>>>(v4, v12);
    else
      v13 = 0;
    v14 = &v13[2 * v9];
    v15 = &v13[2 * v12];
    bzero(v14, 2 * a2);
    v16 = &v14[2 * a2];
    v18 = *a1;
    v17 = a1[1];
    if (v17 != *a1)
    {
      do
      {
        v19 = *(v17 - 2);
        v17 -= 2;
        *(v14 - 2) = v19;
        v14 -= 2;
        v14[1] = v17[1];
      }
      while (v17 != v18);
      v17 = *a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
      operator delete(v17);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<cv::Vec<unsigned char,2>>>(uint64_t a1, uint64_t a2)
{
  if (a2 < 0)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(2 * a2);
}

void std::vector<cv::Vec<unsigned char,3>>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  char *v14;
  char *v15;
  size_t v16;
  char *v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  uint64_t v22;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * (v6 - v7) >= a2)
  {
    if (a2)
    {
      v13 = 3 * ((3 * a2 - 3) / 3) + 3;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0xAAAAAAAAAAAAAAABLL * (v7 - *a1);
    v9 = v8 + a2;
    if (v8 + a2 >= 0x5555555555555556)
      std::vector<int>::__throw_length_error[abi:ne180100]();
    v10 = 0xAAAAAAAAAAAAAAABLL * (v5 - *a1);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x2AAAAAAAAAAAAAAALL)
      v11 = 0x5555555555555555;
    else
      v11 = v9;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cv::Vec<unsigned char,3>>>(v4, v11);
    else
      v12 = 0;
    v14 = &v12[3 * v8];
    v15 = &v12[3 * v11];
    v16 = 3 * ((3 * a2 - 3) / 3) + 3;
    bzero(v14, v16);
    v17 = &v14[v16];
    v19 = *a1;
    v18 = a1[1];
    if (v18 == *a1)
    {
      v20 = v14;
    }
    else
    {
      do
      {
        v20 = v14 - 3;
        v21 = v18 - 3;
        v22 = -3;
        do
          v14[v22] = v18[v22];
        while (!__CFADD__(v22++, 1));
        v18 -= 3;
        v14 -= 3;
      }
      while (v21 != v19);
      v18 = *a1;
    }
    *a1 = v20;
    a1[1] = v17;
    a1[2] = v15;
    if (v18)
      operator delete(v18);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<cv::Vec<unsigned char,3>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x5555555555555556)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(3 * a2);
}

void std::vector<cv::Vec<short,3>>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  size_t v14;
  char *v15;
  char *v16;
  size_t v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 1) >= a2)
  {
    if (a2)
    {
      v14 = 6 * ((6 * a2 - 6) / 6) + 6;
      bzero(*(void **)(v4 - 8), v14);
      v7 += v14;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = *a1;
    v9 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 1);
    v10 = v9 + a2;
    if (v9 + a2 > 0x2AAAAAAAAAAAAAAALL)
      std::vector<int>::__throw_length_error[abi:ne180100]();
    v11 = 0xAAAAAAAAAAAAAAABLL * ((v5 - v8) >> 1);
    if (2 * v11 > v10)
      v10 = 2 * v11;
    if (v11 >= 0x1555555555555555)
      v12 = 0x2AAAAAAAAAAAAAAALL;
    else
      v12 = v10;
    if (v12)
    {
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cv::Vec<short,3>>>(v4, v12);
      v8 = *a1;
      v7 = a1[1];
    }
    else
    {
      v13 = 0;
    }
    v15 = &v13[6 * v9];
    v16 = &v13[6 * v12];
    v17 = 6 * ((6 * a2 - 6) / 6) + 6;
    bzero(v15, v17);
    v18 = &v15[v17];
    if (v7 == v8)
    {
      v19 = v15;
    }
    else
    {
      do
      {
        v19 = v15 - 6;
        v20 = v7 - 6;
        v21 = -6;
        do
        {
          *(_WORD *)&v15[v21] = *(_WORD *)&v7[v21];
          v21 += 2;
        }
        while (v21);
        v7 -= 6;
        v15 -= 6;
      }
      while (v20 != v8);
    }
    *a1 = v19;
    a1[1] = v18;
    a1[2] = v16;
    if (v8)
      operator delete(v8);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<cv::Vec<short,3>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x2AAAAAAAAAAAAAABLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(6 * a2);
}

void std::vector<cv::Vec<int,2>>::__append(void **a1, unint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  _DWORD *v17;
  _DWORD *i;
  int v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - (_BYTE *)*a1;
    v9 = a2 + (v8 >> 3);
    if (v9 >> 61)
      std::vector<int>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 3;
    v11 = v5 - (_BYTE *)*a1;
    if (v11 >> 2 > v9)
      v9 = v11 >> 2;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CGPoint *>>(v4, v12);
    else
      v13 = 0;
    v14 = &v13[8 * v10];
    v15 = &v13[8 * v12];
    bzero(v14, 8 * a2);
    v16 = &v14[8 * a2];
    v17 = *a1;
    for (i = a1[1]; i != v17; *((_DWORD *)v14 + 1) = i[1])
    {
      v19 = *(i - 2);
      i -= 2;
      *((_DWORD *)v14 - 2) = v19;
      v14 -= 8;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
      operator delete(v17);
  }
}

void std::vector<cv::Vec<int,3>>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  size_t v14;
  char *v15;
  char *v16;
  size_t v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 2) >= a2)
  {
    if (a2)
    {
      v14 = 12 * ((12 * a2 - 12) / 0xC) + 12;
      bzero(*(void **)(v4 - 8), v14);
      v7 += v14;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = *a1;
    v9 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 2);
    v10 = v9 + a2;
    if (v9 + a2 > 0x1555555555555555)
      std::vector<int>::__throw_length_error[abi:ne180100]();
    v11 = 0xAAAAAAAAAAAAAAABLL * ((v5 - v8) >> 2);
    if (2 * v11 > v10)
      v10 = 2 * v11;
    if (v11 >= 0xAAAAAAAAAAAAAAALL)
      v12 = 0x1555555555555555;
    else
      v12 = v10;
    if (v12)
    {
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cv::Vec<int,3>>>(v4, v12);
      v8 = *a1;
      v7 = a1[1];
    }
    else
    {
      v13 = 0;
    }
    v15 = &v13[12 * v9];
    v16 = &v13[12 * v12];
    v17 = 12 * ((12 * a2 - 12) / 0xC) + 12;
    bzero(v15, v17);
    v18 = &v15[v17];
    if (v7 == v8)
    {
      v19 = v15;
    }
    else
    {
      do
      {
        v19 = v15 - 12;
        v20 = v7 - 12;
        v21 = -12;
        do
        {
          *(_DWORD *)&v15[v21] = *(_DWORD *)&v7[v21];
          v21 += 4;
        }
        while (v21);
        v7 -= 12;
        v15 -= 12;
      }
      while (v20 != v8);
    }
    *a1 = v19;
    a1[1] = v18;
    a1[2] = v16;
    if (v8)
      operator delete(v8);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<cv::Vec<int,3>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x1555555555555556)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(12 * a2);
}

void std::vector<cv::Vec<int,4>>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 4)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 16 * a2);
      v7 += 16 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = *a1;
    v9 = v7 - *a1;
    v10 = a2 + (v9 >> 4);
    if (v10 >> 60)
      std::vector<int>::__throw_length_error[abi:ne180100]();
    v11 = v9 >> 4;
    v12 = v5 - v8;
    if (v12 >> 3 > v10)
      v10 = v12 >> 3;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0)
      v13 = 0xFFFFFFFFFFFFFFFLL;
    else
      v13 = v10;
    if (v13)
    {
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CGPoint>>(v4, v13);
      v8 = *a1;
      v7 = a1[1];
    }
    else
    {
      v14 = 0;
    }
    v15 = &v14[16 * v11];
    v16 = &v14[16 * v13];
    bzero(v15, 16 * a2);
    v17 = &v15[16 * a2];
    if (v7 == v8)
    {
      v18 = v15;
    }
    else
    {
      do
      {
        v18 = v15 - 16;
        v19 = v7 - 16;
        v20 = -16;
        do
        {
          *(_DWORD *)&v15[v20] = *(_DWORD *)&v7[v20];
          v20 += 4;
        }
        while (v20);
        v7 -= 16;
        v15 -= 16;
      }
      while (v19 != v8);
    }
    *a1 = v18;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
      operator delete(v8);
  }
}

void std::vector<cv::Vec<int,6>>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  size_t v14;
  char *v15;
  char *v16;
  size_t v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      v14 = 24 * ((24 * a2 - 24) / 0x18) + 24;
      bzero(*(void **)(v4 - 8), v14);
      v7 += v14;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = *a1;
    v9 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 3);
    v10 = v9 + a2;
    if (v9 + a2 > 0xAAAAAAAAAAAAAAALL)
      std::vector<int>::__throw_length_error[abi:ne180100]();
    v11 = 0xAAAAAAAAAAAAAAABLL * ((v5 - v8) >> 3);
    if (2 * v11 > v10)
      v10 = 2 * v11;
    if (v11 >= 0x555555555555555)
      v12 = 0xAAAAAAAAAAAAAAALL;
    else
      v12 = v10;
    if (v12)
    {
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<long long,long long,float>>>(v4, v12);
      v8 = *a1;
      v7 = a1[1];
    }
    else
    {
      v13 = 0;
    }
    v15 = &v13[24 * v9];
    v16 = &v13[24 * v12];
    v17 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v15, v17);
    v18 = &v15[v17];
    if (v7 == v8)
    {
      v19 = v15;
    }
    else
    {
      do
      {
        v19 = v15 - 24;
        v20 = v7 - 24;
        v21 = -24;
        do
        {
          *(_DWORD *)&v15[v21] = *(_DWORD *)&v7[v21];
          v21 += 4;
        }
        while (v21);
        v7 -= 24;
        v15 -= 24;
      }
      while (v20 != v8);
    }
    *a1 = v19;
    a1[1] = v18;
    a1[2] = v16;
    if (v8)
      operator delete(v8);
  }
}

void std::vector<cv::Vec<int,8>>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 5)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 32 * a2);
      v7 += 32 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = *a1;
    v9 = v7 - *a1;
    v10 = a2 + (v9 >> 5);
    if (v10 >> 59)
      std::vector<int>::__throw_length_error[abi:ne180100]();
    v11 = v9 >> 5;
    v12 = v5 - v8;
    if (v12 >> 4 > v10)
      v10 = v12 >> 4;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFE0)
      v13 = 0x7FFFFFFFFFFFFFFLL;
    else
      v13 = v10;
    if (v13)
    {
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cv::Vec<int,8>>>(v4, v13);
      v8 = *a1;
      v7 = a1[1];
    }
    else
    {
      v14 = 0;
    }
    v15 = &v14[32 * v11];
    v16 = &v14[32 * v13];
    bzero(v15, 32 * a2);
    v17 = &v15[32 * a2];
    if (v7 == v8)
    {
      v18 = v15;
    }
    else
    {
      do
      {
        v18 = v15 - 32;
        v19 = v7 - 32;
        v20 = -32;
        do
        {
          *(_DWORD *)&v15[v20] = *(_DWORD *)&v7[v20];
          v20 += 4;
        }
        while (v20);
        v7 -= 32;
        v15 -= 32;
      }
      while (v19 != v8);
    }
    *a1 = v18;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
      operator delete(v8);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<cv::Vec<int,8>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 59)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(32 * a2);
}

void std::vector<cv::Vec<int,9>>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  size_t v14;
  char *v15;
  char *v16;
  size_t v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (0x8E38E38E38E38E39 * ((v6 - v7) >> 2) >= a2)
  {
    if (a2)
    {
      v14 = 36 * ((36 * a2 - 36) / 0x24) + 36;
      bzero(*(void **)(v4 - 8), v14);
      v7 += v14;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = *a1;
    v9 = 0x8E38E38E38E38E39 * ((v7 - *a1) >> 2);
    v10 = v9 + a2;
    if (v9 + a2 > 0x71C71C71C71C71CLL)
      std::vector<int>::__throw_length_error[abi:ne180100]();
    v11 = 0x8E38E38E38E38E39 * ((v5 - v8) >> 2);
    if (2 * v11 > v10)
      v10 = 2 * v11;
    if (v11 >= 0x38E38E38E38E38ELL)
      v12 = 0x71C71C71C71C71CLL;
    else
      v12 = v10;
    if (v12)
    {
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cv::Vec<int,9>>>(v4, v12);
      v8 = *a1;
      v7 = a1[1];
    }
    else
    {
      v13 = 0;
    }
    v15 = &v13[36 * v9];
    v16 = &v13[36 * v12];
    v17 = 36 * ((36 * a2 - 36) / 0x24) + 36;
    bzero(v15, v17);
    v18 = &v15[v17];
    if (v7 == v8)
    {
      v19 = v15;
    }
    else
    {
      do
      {
        v19 = v15 - 36;
        v20 = v7 - 36;
        v21 = -36;
        do
        {
          *(_DWORD *)&v15[v21] = *(_DWORD *)&v7[v21];
          v21 += 4;
        }
        while (v21);
        v7 -= 36;
        v15 -= 36;
      }
      while (v20 != v8);
    }
    *a1 = v19;
    a1[1] = v18;
    a1[2] = v16;
    if (v8)
      operator delete(v8);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<cv::Vec<int,9>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x71C71C71C71C71DLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(36 * a2);
}

void std::vector<cv::Vec<int,12>>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  size_t v14;
  char *v15;
  char *v16;
  size_t v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 4) >= a2)
  {
    if (a2)
    {
      v14 = 48 * ((48 * a2 - 48) / 0x30) + 48;
      bzero(*(void **)(v4 - 8), v14);
      v7 += v14;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = *a1;
    v9 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 4);
    v10 = v9 + a2;
    if (v9 + a2 > 0x555555555555555)
      std::vector<int>::__throw_length_error[abi:ne180100]();
    v11 = 0xAAAAAAAAAAAAAAABLL * ((v5 - v8) >> 4);
    if (2 * v11 > v10)
      v10 = 2 * v11;
    if (v11 >= 0x2AAAAAAAAAAAAAALL)
      v12 = 0x555555555555555;
    else
      v12 = v10;
    if (v12)
    {
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cv::Vec<int,12>>>(v4, v12);
      v8 = *a1;
      v7 = a1[1];
    }
    else
    {
      v13 = 0;
    }
    v15 = &v13[48 * v9];
    v16 = &v13[48 * v12];
    v17 = 48 * ((48 * a2 - 48) / 0x30) + 48;
    bzero(v15, v17);
    v18 = &v15[v17];
    if (v7 == v8)
    {
      v19 = v15;
    }
    else
    {
      do
      {
        v19 = v15 - 48;
        v20 = v7 - 48;
        v21 = -48;
        do
        {
          *(_DWORD *)&v15[v21] = *(_DWORD *)&v7[v21];
          v21 += 4;
        }
        while (v21);
        v7 -= 48;
        v15 -= 48;
      }
      while (v20 != v8);
    }
    *a1 = v19;
    a1[1] = v18;
    a1[2] = v16;
    if (v8)
      operator delete(v8);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<cv::Vec<int,12>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(48 * a2);
}

void std::vector<cv::Vec<int,16>>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 6)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), a2 << 6);
      v7 += 64 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = *a1;
    v9 = v7 - *a1;
    v10 = a2 + (v9 >> 6);
    if (v10 >> 58)
      std::vector<int>::__throw_length_error[abi:ne180100]();
    v11 = v9 >> 6;
    v12 = v5 - v8;
    if (v12 >> 5 > v10)
      v10 = v12 >> 5;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFC0)
      v13 = 0x3FFFFFFFFFFFFFFLL;
    else
      v13 = v10;
    if (v13)
    {
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cv::Vec<int,16>>>(v4, v13);
      v8 = *a1;
      v7 = a1[1];
    }
    else
    {
      v14 = 0;
    }
    v15 = &v14[64 * v11];
    v16 = &v14[64 * v13];
    bzero(v15, a2 << 6);
    v17 = &v15[64 * a2];
    if (v7 == v8)
    {
      v18 = v15;
    }
    else
    {
      do
      {
        v18 = v15 - 64;
        v19 = v7 - 64;
        v20 = -64;
        do
        {
          *(_DWORD *)&v15[v20] = *(_DWORD *)&v7[v20];
          v20 += 4;
        }
        while (v20);
        v7 -= 64;
        v15 -= 64;
      }
      while (v19 != v8);
    }
    *a1 = v18;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
      operator delete(v8);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<cv::Vec<int,16>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 58)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(a2 << 6);
}

void std::vector<cv::Vec<int,32>>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 7)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), a2 << 7);
      v7 += 128 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = *a1;
    v9 = v7 - *a1;
    v10 = a2 + (v9 >> 7);
    if (v10 >> 57)
      std::vector<int>::__throw_length_error[abi:ne180100]();
    v11 = v9 >> 7;
    v12 = v5 - v8;
    if (v12 >> 6 > v10)
      v10 = v12 >> 6;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFF80)
      v13 = 0x1FFFFFFFFFFFFFFLL;
    else
      v13 = v10;
    if (v13)
    {
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cv::Vec<int,32>>>(v4, v13);
      v8 = *a1;
      v7 = a1[1];
    }
    else
    {
      v14 = 0;
    }
    v15 = &v14[128 * v11];
    v16 = &v14[128 * v13];
    bzero(v15, a2 << 7);
    v17 = &v15[128 * a2];
    if (v7 == v8)
    {
      v18 = v15;
    }
    else
    {
      do
      {
        v18 = v15 - 128;
        v19 = v7 - 128;
        v20 = -128;
        do
        {
          *(_DWORD *)&v15[v20] = *(_DWORD *)&v7[v20];
          v20 += 4;
        }
        while (v20);
        v7 -= 128;
        v15 -= 128;
      }
      while (v19 != v8);
    }
    *a1 = v18;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
      operator delete(v8);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<cv::Vec<int,32>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 57)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(a2 << 7);
}

void std::vector<cv::Vec<int,64>>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 8)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), a2 << 8);
      v7 += 256 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = *a1;
    v9 = v7 - *a1;
    v10 = a2 + (v9 >> 8);
    if (HIBYTE(v10))
      std::vector<int>::__throw_length_error[abi:ne180100]();
    v11 = v9 >> 8;
    v12 = v5 - v8;
    if (v12 >> 7 > v10)
      v10 = v12 >> 7;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFF00)
      v13 = 0xFFFFFFFFFFFFFFLL;
    else
      v13 = v10;
    if (v13)
    {
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cv::Vec<int,64>>>(v4, v13);
      v8 = *a1;
      v7 = a1[1];
    }
    else
    {
      v14 = 0;
    }
    v15 = &v14[256 * v11];
    v16 = &v14[256 * v13];
    bzero(v15, a2 << 8);
    v17 = &v15[256 * a2];
    if (v7 == v8)
    {
      v18 = v15;
    }
    else
    {
      do
      {
        v18 = v15 - 256;
        v19 = v7 - 256;
        v20 = -256;
        do
        {
          *(_DWORD *)&v15[v20] = *(_DWORD *)&v7[v20];
          v20 += 4;
        }
        while (v20);
        v7 -= 256;
        v15 -= 256;
      }
      while (v19 != v8);
    }
    *a1 = v18;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
      operator delete(v8);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<cv::Vec<int,64>>>(uint64_t a1, unint64_t a2)
{
  if (HIBYTE(a2))
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(a2 << 8);
}

void std::vector<cv::Vec<int,128>>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 9)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), a2 << 9);
      v7 += 512 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = *a1;
    v9 = v7 - *a1;
    v10 = a2 + (v9 >> 9);
    if (v10 >> 55)
      std::vector<int>::__throw_length_error[abi:ne180100]();
    v11 = v9 >> 9;
    v12 = v5 - v8;
    if (v12 >> 8 > v10)
      v10 = v12 >> 8;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFE00)
      v13 = 0x7FFFFFFFFFFFFFLL;
    else
      v13 = v10;
    if (v13)
    {
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cv::Vec<int,128>>>(v4, v13);
      v8 = *a1;
      v7 = a1[1];
    }
    else
    {
      v14 = 0;
    }
    v15 = &v14[512 * v11];
    v16 = &v14[512 * v13];
    bzero(v15, a2 << 9);
    v17 = &v15[512 * a2];
    if (v7 == v8)
    {
      v18 = v15;
    }
    else
    {
      do
      {
        v18 = v15 - 512;
        v19 = v7 - 512;
        v20 = -512;
        do
        {
          *(_DWORD *)&v15[v20] = *(_DWORD *)&v7[v20];
          v20 += 4;
        }
        while (v20);
        v7 -= 512;
        v15 -= 512;
      }
      while (v19 != v8);
    }
    *a1 = v18;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
      operator delete(v8);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<cv::Vec<int,128>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 55)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(a2 << 9);
}

cv::Exception *cv::Exception::Exception(cv::Exception *this, int a2, __int128 *a3, __int128 *a4, __int128 *a5, int a6)
{
  __int128 v10;
  __int128 v11;
  __int128 v12;

  *((_QWORD *)this + 1) = 0;
  *(_QWORD *)this = &off_24DBF05E0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_DWORD *)this + 8) = a2;
  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)((char *)this + 40), *(const std::string::value_type **)a3, *((_QWORD *)a3 + 1));
  }
  else
  {
    v10 = *a3;
    *((_QWORD *)this + 7) = *((_QWORD *)a3 + 2);
    *(_OWORD *)((char *)this + 40) = v10;
  }
  if (*((char *)a4 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)((char *)this + 64), *(const std::string::value_type **)a4, *((_QWORD *)a4 + 1));
  }
  else
  {
    v11 = *a4;
    *((_QWORD *)this + 10) = *((_QWORD *)a4 + 2);
    *((_OWORD *)this + 4) = v11;
  }
  if (*((char *)a5 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)((char *)this + 88), *(const std::string::value_type **)a5, *((_QWORD *)a5 + 1));
  }
  else
  {
    v12 = *a5;
    *((_QWORD *)this + 13) = *((_QWORD *)a5 + 2);
    *(_OWORD *)((char *)this + 88) = v12;
  }
  *((_DWORD *)this + 28) = a6;
  cv::Exception::formatMessage(this);
  return this;
}

void sub_219E783C8(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;
  void **v3;
  void **v4;

  if (*(char *)(v1 + 87) < 0)
    operator delete(*v3);
  if (*(char *)(v1 + 63) < 0)
    operator delete(*v2);
  if (*(char *)(v1 + 31) < 0)
    operator delete(*v4);
  std::exception::~exception((std::exception *)v1);
  _Unwind_Resume(a1);
}

double cv::Exception::formatMessage(cv::Exception *this)
{
  void **v2;
  double result;
  __int128 v4;
  uint64_t v5;

  v2 = (void **)((char *)this + 8);
  std::string::basic_string[abi:ne180100]<0>(&v4, "N/A");
  if (*((char *)this + 31) < 0)
    operator delete(*v2);
  result = *(double *)&v4;
  *(_OWORD *)v2 = v4;
  *((_QWORD *)this + 3) = v5;
  return result;
}

void cv::Exception::~Exception(std::exception *this)
{
  this->__vftable = (std::exception_vtbl *)&off_24DBF05E0;
  if (SHIBYTE(this[13].__vftable) < 0)
    operator delete(this[11].__vftable);
  if (SHIBYTE(this[10].__vftable) < 0)
    operator delete(this[8].__vftable);
  if (SHIBYTE(this[7].__vftable) < 0)
    operator delete(this[5].__vftable);
  if (SHIBYTE(this[3].__vftable) < 0)
    operator delete(this[1].__vftable);
  std::exception::~exception(this);
}

{
  cv::Exception::~Exception(this);
  JUMPOUT(0x2207351BCLL);
}

uint64_t cv::Exception::what(cv::Exception *this)
{
  uint64_t result;

  result = (uint64_t)this + 8;
  if (*((char *)this + 31) < 0)
    return *(_QWORD *)result;
  return result;
}

_QWORD *cv::format@<X0>(_QWORD *a1@<X8>, ...)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "N/A");
}

uint64_t cv::checkHardwareSupport(cv *this)
{
  return *(unsigned __int8 *)(cv::currentFeatures + (int)this + 4);
}

void cv::error(cv *this, const cv::Exception *a2)
{
  uint64_t v2;
  uint64_t v3;
  const char *v4;
  const char *v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  FILE **v11;
  cv::Exception *exception;
  char v13[65536];
  uint64_t v14;

  v2 = MEMORY[0x24BDAC7A8](this, a2);
  v14 = *MEMORY[0x24BDAC8D0];
  v3 = *(unsigned int *)(v2 + 32);
  if (cv::customErrorCallback)
  {
    if (*(char *)(v2 + 87) >= 0)
      v7 = v2 + 64;
    else
      v7 = *(_QWORD *)(v2 + 64);
    if (*(char *)(v2 + 63) >= 0)
      v8 = v2 + 40;
    else
      v8 = *(_QWORD *)(v2 + 40);
    if (*(char *)(v2 + 111) >= 0)
      v9 = v2 + 88;
    else
      v9 = *(_QWORD *)(v2 + 88);
    cv::customErrorCallback(v3, v7, v8, v9, *(unsigned int *)(v2 + 112), cv::customErrorCallbackData);
  }
  else
  {
    v4 = cvErrorStr(v3);
    v5 = *(const char **)(v2 + 40);
    if (*(char *)(v2 + 63) >= 0)
      v5 = (const char *)(v2 + 40);
    if (*(char *)(v2 + 87) < 0)
    {
      if (*(_QWORD *)(v2 + 72))
        v6 = *(const char **)(v2 + 64);
      else
        v6 = "unknown function";
    }
    else
    {
      v6 = (const char *)(v2 + 64);
      if (!*(_BYTE *)(v2 + 87))
        v6 = "unknown function";
    }
    v10 = *(const char **)(v2 + 88);
    if (*(char *)(v2 + 111) >= 0)
      v10 = (const char *)(v2 + 88);
    sprintf(v13, "OpenCV Error: %s (%s) in %s, file %s, line %d", v4, v5, v6, v10, *(_DWORD *)(v2 + 112));
    v11 = (FILE **)MEMORY[0x24BDAC8D8];
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s\n", v13);
    fflush(*v11);
  }
  if (cv::breakOnError)
    MEMORY[0] = 0;
  exception = (cv::Exception *)__cxa_allocate_exception(0x78uLL);
  cv::Exception::Exception(exception, (const cv::Exception *)v2);
}

void sub_219E78700(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

const char *cvErrorStr(int a1)
{
  const char *v1;
  const char *v2;

  switch(a1)
  {
    case -219:
      v1 = "OpenGL API call";
      break;
    case -218:
      v1 = "No OpenGL support";
      break;
    case -217:
      v1 = "Gpu API call";
      break;
    case -216:
      v1 = "No GPU support";
      break;
    case -215:
      v1 = "Assertion failed";
      break;
    case -214:
      v1 = "Memory block has been corrupted";
      break;
    case -213:
      v1 = "The function/feature is not implemented";
      break;
    case -212:
      v1 = "Parsing error";
      break;
    case -211:
      v1 = "One of arguments' values is out of range";
      break;
    case -210:
      v1 = "Unsupported format or combination of formats";
      break;
    case -209:
      v1 = "Sizes of input arguments do not match";
      break;
    case -208:
      v1 = "Bad type of mask argument";
      break;
    case -207:
      v1 = "Bad parameter of type CvPoint";
      break;
    case -206:
      v1 = "Bad flag (parameter or structure field)";
      break;
    case -205:
      v1 = "Formats of input arguments do not match";
      break;
    case -204:
      v1 = "Requested object was not found";
      break;
    case -203:
      v1 = "Inplace operation is not supported";
      break;
    case -202:
      v1 = "Division by zero occured";
      break;
    case -201:
      v1 = "Incorrect size of input array";
      break;
    default:
      v1 = "No Error";
      switch(a1)
      {
        case -27:
          v1 = "Null pointer";
          break;
        case -24:
          v1 = "Input COI is not supported";
          break;
        case -17:
          v1 = "Input image depth is not supported by function";
          break;
        case -15:
          v1 = "Bad number of channels";
          break;
        case -13:
          v1 = "Image step is wrong";
          break;
        case -8:
          v1 = "Autotrace call";
          break;
        case -7:
          v1 = "Iterations do not converge";
          break;
        case -5:
          v1 = "Bad argument";
          break;
        case -4:
          v1 = "Insufficient memory";
          break;
        case -3:
          v1 = "Internal error";
          break;
        case -2:
          v1 = "Unspecified error";
          break;
        case -1:
          v1 = "Backtrace";
          break;
        case 0:
          return v1;
        default:
          v2 = "error";
          if (a1 >= 0)
            v2 = "status";
          v1 = cvErrorStr::buf;
          sprintf(cvErrorStr::buf, "Unknown %s code %d", v2, a1);
          break;
      }
      break;
  }
  return v1;
}

uint64_t cvGetErrStatus()
{
  return 0;
}

uint64_t cvRegisterModule(uint64_t a1)
{
  const char *v2;
  const char *v3;
  size_t v4;
  size_t v5;
  _OWORD *v6;
  __int128 v7;
  size_t v8;
  char *v9;
  uint64_t *v10;
  const cv::Exception *v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  _BYTE v16[120];

  if (!a1 || (v2 = *(const char **)(a1 + 8)) == 0 || (v3 = *(const char **)(a1 + 16)) == 0)
  {
    std::string::basic_string[abi:ne180100]<0>(&v15, "module != 0 && module->name != 0 && module->version != 0");
    std::string::basic_string[abi:ne180100]<0>(&v14, "cvRegisterModule");
    std::string::basic_string[abi:ne180100]<0>(&v13, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/system.cpp");
    cv::Exception::Exception((cv::Exception *)v16, -215, &v15, &v14, &v13, 782);
    cv::error((cv *)v16, v12);
  }
  v4 = strlen(v2);
  v5 = strlen(v3);
  v6 = malloc_type_malloc(v4 + v5 + 34, 0x876E47A1uLL);
  v7 = *(_OWORD *)(a1 + 16);
  *v6 = *(_OWORD *)a1;
  v6[1] = v7;
  v8 = v4 + 1;
  v9 = (char *)v6 + v4 + 33;
  *((_QWORD *)v6 + 1) = v6 + 2;
  *((_QWORD *)v6 + 2) = v9;
  memcpy(v6 + 2, *(const void **)(a1 + 8), v8);
  memcpy(v9, *(const void **)(a1 + 16), v5 + 1);
  *(_QWORD *)v6 = 0;
  v10 = &CvModule::first;
  if (CvModule::first)
    v10 = (uint64_t *)CvModule::last;
  *v10 = (uint64_t)v6;
  CvModule::last = (uint64_t)v6;
  return 0;
}

void sub_219E78A60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,std::exception a27)
{
  cv::Exception::~Exception(&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

cv::Exception *cv::Exception::Exception(cv::Exception *this, const cv::Exception *a2)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  std::string *v7;
  __int128 v8;

  *(_QWORD *)this = &off_24DBF05E0;
  if (*((char *)a2 + 31) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)((char *)this + 8), *((const std::string::value_type **)a2 + 1), *((_QWORD *)a2 + 2));
  }
  else
  {
    v4 = *(_OWORD *)((char *)a2 + 8);
    *((_QWORD *)this + 3) = *((_QWORD *)a2 + 3);
    *(_OWORD *)((char *)this + 8) = v4;
  }
  *((_DWORD *)this + 8) = *((_DWORD *)a2 + 8);
  if (*((char *)a2 + 63) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)((char *)this + 40), *((const std::string::value_type **)a2 + 5), *((_QWORD *)a2 + 6));
  }
  else
  {
    v5 = *(_OWORD *)((char *)a2 + 40);
    *((_QWORD *)this + 7) = *((_QWORD *)a2 + 7);
    *(_OWORD *)((char *)this + 40) = v5;
  }
  if (*((char *)a2 + 87) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)((char *)this + 64), *((const std::string::value_type **)a2 + 8), *((_QWORD *)a2 + 9));
  }
  else
  {
    v6 = *((_OWORD *)a2 + 4);
    *((_QWORD *)this + 10) = *((_QWORD *)a2 + 10);
    *((_OWORD *)this + 4) = v6;
  }
  v7 = (std::string *)((char *)this + 88);
  if (*((char *)a2 + 111) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *((const std::string::value_type **)a2 + 11), *((_QWORD *)a2 + 12));
  }
  else
  {
    v8 = *(_OWORD *)((char *)a2 + 88);
    *((_QWORD *)this + 13) = *((_QWORD *)a2 + 13);
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v8;
  }
  *((_DWORD *)this + 28) = *((_DWORD *)a2 + 28);
  return this;
}

void sub_219E78BC8(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;
  void **v3;
  void **v4;

  if (*(char *)(v1 + 87) < 0)
    operator delete(*v4);
  if (*(char *)(v1 + 63) < 0)
    operator delete(*v3);
  if (*(char *)(v1 + 31) < 0)
    operator delete(*v2);
  std::exception::~exception((std::exception *)v1);
  _Unwind_Resume(a1);
}

uint64_t _GLOBAL__sub_I_system_cpp()
{
  uint64_t result;

  dword_253E6CD18 = 0;
  xmmword_253E6CCF8 = 0u;
  unk_253E6CD08 = 0u;
  xmmword_253E6CCD8 = 0u;
  unk_253E6CCE8 = 0u;
  xmmword_253E6CCB8 = 0u;
  unk_253E6CCC8 = 0u;
  xmmword_253E6CC98 = 0u;
  unk_253E6CCA8 = 0u;
  xmmword_253E6CC78 = 0u;
  unk_253E6CC88 = 0u;
  xmmword_253E6CC58 = 0u;
  unk_253E6CC68 = 0u;
  xmmword_253E6CC38 = 0u;
  unk_253E6CC48 = 0u;
  cv::featuresEnabled = 0u;
  unk_253E6CC28 = 0u;
  dword_253E6CC14 = 0;
  xmmword_253E6CBF4 = 0u;
  unk_253E6CC04 = 0u;
  xmmword_253E6CBD4 = 0u;
  unk_253E6CBE4 = 0u;
  xmmword_253E6CBB4 = 0u;
  unk_253E6CBC4 = 0u;
  xmmword_253E6CB94 = 0u;
  unk_253E6CBA4 = 0u;
  xmmword_253E6CB74 = 0u;
  unk_253E6CB84 = 0u;
  xmmword_253E6CB54 = 0u;
  unk_253E6CB64 = 0u;
  xmmword_253E6CB34 = 0u;
  unk_253E6CB44 = 0u;
  cv::featuresDisabled = 0u;
  unk_253E6CB24 = 0u;
  cv::USE_SSE2 = 0;
  cv::USE_SSE4_2 = 0;
  cv::USE_AVX = 0;
  result = cvRegisterModule((uint64_t)&cxcore_info);
  cxcore_module = CvModule::last;
  return result;
}

uint64_t cv::gpu::GpuMat::GpuMat(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  __int128 v3;
  unsigned int v4;

  *(_QWORD *)result = *(_QWORD *)a2;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  v2 = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(result + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(result + 24) = v2;
  v3 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(result + 32) = v3;
  *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
  if ((_QWORD)v3)
  {
    do
      v4 = __ldaxr((unsigned int *)v3);
    while (__stlxr(v4 + 1, (unsigned int *)v3));
  }
  return result;
}

double cv::gpu::GpuMat::create(cv::gpu::GpuMat *this, void *a2, int a3, __int16 a4)
{
  int v5;
  int v7;
  double result;
  void *v9;

  v5 = (int)a2;
  v7 = a4 & 0xFFF;
  if (*((_DWORD *)this + 1) != (_DWORD)a2
    || *((_DWORD *)this + 2) != a3
    || (*(_DWORD *)this & 0xFFF) != v7
    || !*((_QWORD *)this + 3))
  {
    if (*((_QWORD *)this + 3))
      result = cv::gpu::GpuMat::release(this, a2);
    if (v5 >= 1 && a3 >= 1)
    {
      *(_DWORD *)this = v7 | 0x42FF0000;
      *((_DWORD *)this + 1) = v5;
      *((_DWORD *)this + 2) = a3;
      v9 = 0;
      gpuFuncTable(void)::stub[7]((EmptyFuncTable *)&gpuFuncTable(void)::stub, (const cv::Mat *)&v9, (cv::gpu::GpuMat *)((char *)this + 16));
    }
  }
  return result;
}

double cv::gpu::GpuMat::release(cv::gpu::GpuMat *this, void *a2)
{
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;
  double result;

  v3 = (unsigned int *)*((_QWORD *)this + 4);
  if (v3)
  {
    do
    {
      v4 = __ldaxr(v3);
      v5 = v4 - 1;
    }
    while (__stlxr(v5, v3));
    if (!v5)
    {
      cv::fastFree(*((void ***)this + 4), a2);
      ((void (*)(EmptyFuncTable *__hidden, void *))gpuFuncTable(void)::stub[8])((EmptyFuncTable *)&gpuFuncTable(void)::stub, *((void **)this + 5));
    }
  }
  *((_DWORD *)this + 1) = 0;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_QWORD *)this + 6) = 0;
  return result;
}

void EmptyFuncTable::copy(EmptyFuncTable *this, const cv::Mat *a2, cv::gpu::GpuMat *a3)
{
  const cv::Exception *v3;
  void *__p[2];
  void *v5[2];
  void *v6[2];
  _BYTE v7[120];

  std::string::basic_string[abi:ne180100]<0>(v6, "The library is compiled without CUDA support");
  std::string::basic_string[abi:ne180100]<0>(v5, "copy");
  std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/include/opencv2/dynamicuda/dynamicuda.hpp");
  cv::Exception::Exception(v7, 4294967080, v6, v5, __p, 115);
  cv::error((cv *)v7, v3);
}

void sub_219E78F64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

void EmptyFuncTable::copy(EmptyFuncTable *this, const cv::gpu::GpuMat *a2, cv::Mat *a3)
{
  const cv::Exception *v3;
  void *__p[2];
  void *v5[2];
  void *v6[2];
  _BYTE v7[120];

  std::string::basic_string[abi:ne180100]<0>(v6, "The library is compiled without CUDA support");
  std::string::basic_string[abi:ne180100]<0>(v5, "copy");
  std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/include/opencv2/dynamicuda/dynamicuda.hpp");
  cv::Exception::Exception(v7, 4294967080, v6, v5, __p, 116);
  cv::error((cv *)v7, v3);
}

void sub_219E7906C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

void EmptyFuncTable::copy(EmptyFuncTable *this, const cv::gpu::GpuMat *a2, cv::gpu::GpuMat *a3)
{
  const cv::Exception *v3;
  void *__p[2];
  void *v5[2];
  void *v6[2];
  _BYTE v7[120];

  std::string::basic_string[abi:ne180100]<0>(v6, "The library is compiled without CUDA support");
  std::string::basic_string[abi:ne180100]<0>(v5, "copy");
  std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/include/opencv2/dynamicuda/dynamicuda.hpp");
  cv::Exception::Exception(v7, 4294967080, v6, v5, __p, 117);
  cv::error((cv *)v7, v3);
}

void sub_219E79174(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

void EmptyFuncTable::copyWithMask(EmptyFuncTable *this, const cv::gpu::GpuMat *a2, cv::gpu::GpuMat *a3, const cv::gpu::GpuMat *a4)
{
  const cv::Exception *v4;
  void *__p[2];
  void *v6[2];
  void *v7[2];
  _BYTE v8[120];

  std::string::basic_string[abi:ne180100]<0>(v7, "The library is compiled without CUDA support");
  std::string::basic_string[abi:ne180100]<0>(v6, "copyWithMask");
  std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/include/opencv2/dynamicuda/dynamicuda.hpp");
  cv::Exception::Exception(v8, 4294967080, v7, v6, __p, 119);
  cv::error((cv *)v8, v4);
}

void sub_219E7927C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

void EmptyFuncTable::convert(EmptyFuncTable *this, const cv::gpu::GpuMat *a2, cv::gpu::GpuMat *a3, double a4, double a5, void *a6)
{
  const cv::Exception *v6;
  void *__p[2];
  void *v8[2];
  void *v9[2];
  _BYTE v10[120];

  std::string::basic_string[abi:ne180100]<0>(v9, "The library is compiled without CUDA support");
  std::string::basic_string[abi:ne180100]<0>(v8, "convert");
  std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/include/opencv2/dynamicuda/dynamicuda.hpp");
  cv::Exception::Exception(v10, 4294967080, v9, v8, __p, 122);
  cv::error((cv *)v10, v6);
}

void sub_219E79384(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

void EmptyFuncTable::convert(EmptyFuncTable *this, const cv::gpu::GpuMat *a2, cv::gpu::GpuMat *a3)
{
  const cv::Exception *v3;
  void *__p[2];
  void *v5[2];
  void *v6[2];
  _BYTE v7[120];

  std::string::basic_string[abi:ne180100]<0>(v6, "The library is compiled without CUDA support");
  std::string::basic_string[abi:ne180100]<0>(v5, "convert");
  std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/include/opencv2/dynamicuda/dynamicuda.hpp");
  cv::Exception::Exception(v7, 4294967080, v6, v5, __p, 121);
  cv::error((cv *)v7, v3);
}

void sub_219E7948C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

void EmptyFuncTable::setTo()
{
  const cv::Exception *v0;
  void *__p[2];
  void *v2[2];
  void *v3[2];
  _BYTE v4[120];

  std::string::basic_string[abi:ne180100]<0>(v3, "The library is compiled without CUDA support");
  std::string::basic_string[abi:ne180100]<0>(v2, "setTo");
  std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/include/opencv2/dynamicuda/dynamicuda.hpp");
  cv::Exception::Exception(v4, 4294967080, v3, v2, __p, 124);
  cv::error((cv *)v4, v0);
}

void sub_219E79594(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

void EmptyFuncTable::mallocPitch(EmptyFuncTable *this, void **a2, unint64_t *a3)
{
  const cv::Exception *v3;
  void *__p[2];
  void *v5[2];
  void *v6[2];
  _BYTE v7[120];

  std::string::basic_string[abi:ne180100]<0>(v6, "The library is compiled without CUDA support");
  std::string::basic_string[abi:ne180100]<0>(v5, "mallocPitch");
  std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/include/opencv2/dynamicuda/dynamicuda.hpp");
  cv::Exception::Exception(v7, 4294967080, v6, v5, __p, 126);
  cv::error((cv *)v7, v3);
}

void sub_219E7969C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

void EmptyFuncTable::~EmptyFuncTable(EmptyFuncTable *this)
{
  JUMPOUT(0x2207351BCLL);
}

void cv::parallel_for_(uint64_t *a1, uint64_t a2, double a3)
{
  uint64_t v3;
  double v4;
  double v5;
  NSObject *global_queue;
  _QWORD context[2];
  int v8;

  {
    v3 = *a1;
    context[0] = a2;
    context[1] = v3;
    v4 = 1.0;
    if (a3 >= 1.0)
      v4 = a3;
    if (v4 > (double)(HIDWORD(v3) - (int)v3))
      v4 = (double)(HIDWORD(v3) - (int)v3);
    if (a3 <= 0.0)
      v5 = (double)(HIDWORD(v3) - (int)v3);
    else
      v5 = v4;
    v8 = (uint64_t)rint(v5);
    global_queue = dispatch_get_global_queue(0, 0);
  }
  else
  {
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)a2 + 16))(a2, a1);
  }
}

uint64_t `anonymous namespace'::block_function(_anonymous_namespace_ *this, void *a2)
{
  int v2;
  int v3;
  int v4;
  int v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  _DWORD v10[2];

  v2 = (_DWORD)a2 + 1;
  v3 = *((_DWORD *)this + 2);
  v4 = *((_DWORD *)this + 3);
  v5 = v4 - v3;
  v6 = *((int *)this + 4);
  if ((v6 & 0x80000000) == 0)
    v7 = *((_DWORD *)this + 4);
  else
    v7 = v6 + 1;
  v8 = (uint64_t)v7 >> 1;
  v10[0] = v3 + (v8 + (int)a2 * (uint64_t)v5) / v6;
  if (v2 < (int)v6)
    v4 = v3 + (v8 + v5 * (uint64_t)v2) / v6;
  v10[1] = v4;
  return (*(uint64_t (**)(_QWORD, _DWORD *))(**(_QWORD **)this + 16))(*(_QWORD *)this, v10);
}

void cv::goodFeaturesToTrack(cv *this, const cv::_InputArray *a2, const cv::_OutputArray *a3, void (***a4)(uint64_t *__return_ptr, _QWORD, uint64_t), double a5, double a6, const cv::_InputArray *a7, int a8, double a9)
{
  int v15;
  const cv::Exception *v17;
  uint64_t v18;
  uint64_t v19;
  int *v20;
  uint64_t v21;
  BOOL v22;
  const cv::Exception *v23;
  void *v24;
  unsigned int *v25;
  unsigned int v26;
  unsigned int v27;
  uint64_t v28;
  _BYTE *v29;
  int v30;
  float **v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  float *v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  char *v41;
  float **v42;
  char *v43;
  char *v44;
  float *v45;
  float **v46;
  float **v47;
  unint64_t v48;
  float *v49;
  uint64_t v50;
  unint64_t v51;
  float v52;
  float v53;
  uint64_t v54;
  unint64_t v55;
  unint64_t v56;
  uint64_t v57;
  char *v58;
  float *v59;
  float *v60;
  float *v61;
  float *v62;
  uint64_t v63;
  BOOL v64;
  uint64_t v65;
  uint64_t v66;
  int v67;
  int v68;
  uint64_t v69;
  double v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  int v78;
  unsigned int v79;
  uint64_t v80;
  int v81;
  float v82;
  float v83;
  float **v84;
  float *v85;
  void **v86;
  unint64_t v87;
  _QWORD *v88;
  float *v89;
  int v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t *v95;
  uint64_t v96;
  uint64_t v97;
  unint64_t v98;
  float *v99;
  int v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  unint64_t v107;
  uint64_t v108;
  char *v109;
  float *v110;
  float *v111;
  float *v112;
  float *v113;
  uint64_t v114;
  float *v115;
  float *v116;
  uint64_t v117;
  unint64_t v118;
  uint64_t v119;
  unint64_t v120;
  uint64_t v121;
  char *v122;
  float *v123;
  float *v124;
  float *v125;
  float *v126;
  uint64_t v127;
  int v128;
  void *v129;
  unsigned int *v130;
  unsigned int v131;
  unsigned int v132;
  uint64_t v133;
  _BYTE *v134;
  unsigned int *v135;
  unsigned int v136;
  unsigned int v137;
  uint64_t v138;
  char *v139;
  unsigned int *v140;
  unsigned int v141;
  unsigned int v142;
  uint64_t v143;
  char *v144;
  unsigned int *v145;
  unsigned int v146;
  unsigned int v147;
  uint64_t v148;
  int *v149;
  unsigned int *v150;
  unsigned int v151;
  unsigned int v152;
  uint64_t v153;
  int *v154;
  const cv::_OutputArray *v155;
  int v156;
  int v157;
  uint64_t v158;
  int v159;
  uint64_t v160;
  _OWORD v161[2];
  uint64_t v162;
  _BYTE v163[64];
  _BYTE *v164;
  cv *v165;
  int64x2_t v166;
  void **v167[4];
  void *v168;
  float *v169;
  _QWORD v170[2];
  double v171;
  void *__p;
  float **v173;
  float **v174;
  _OWORD v175[4];
  char *v176;
  cv *v177;
  _QWORD v178[2];
  _OWORD v179[4];
  char *v180;
  cv *v181;
  _QWORD v182[5];
  uint64_t v183;
  int v184;
  int v185;
  uint64_t v186;
  unsigned int *v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  int *v191;
  cv *v192;
  uint64_t v193;
  uint64_t v194;
  int v195;
  int v196;
  uint64_t v197;
  unsigned int *v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  int *v202;
  void **v203;
  uint64_t v204;

  v15 = (int)a3;
  (**(void (***)(uint64_t *__return_ptr, cv *, uint64_t))this)(&v194, this, 0xFFFFFFFFLL);
  (**a4)(&v183, a4, 0xFFFFFFFFLL);
  if (v15 < 0 || a5 <= 0.0 || a6 < 0.0)
  {
    std::string::basic_string[abi:ne180100]<0>(v175, "qualityLevel > 0 && minDistance >= 0 && maxCorners >= 0");
    std::string::basic_string[abi:ne180100]<0>(v163, "goodFeaturesToTrack");
    std::string::basic_string[abi:ne180100]<0>(&__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/imgproc/featureselect.cpp");
    cv::Exception::Exception(v179, 4294967081, v175, v163, &__p, 62);
    cv::error((cv *)v179, v17);
  }
  if (v186)
  {
    v18 = HIDWORD(v183);
    if (SHIDWORD(v183) >= 3)
    {
      v20 = v191;
      v19 = 1;
      do
      {
        v21 = *v20++;
        v19 *= v21;
        --v18;
      }
      while (v18);
    }
    else
    {
      v19 = v185 * (uint64_t)v184;
    }
    if (v19)
    {
      if ((v183 & 0xFFF) != 0 || (v191[1] == v202[1] ? (v22 = *v191 == *v202) : (v22 = 0), !v22))
      {
        std::string::basic_string[abi:ne180100]<0>(v175, "mask.empty() || (mask.type() == CV_8UC1 && mask.size() == image.size())");
        std::string::basic_string[abi:ne180100]<0>(v163, "goodFeaturesToTrack");
        std::string::basic_string[abi:ne180100]<0>(&__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/imgproc/featureselect.cpp");
        cv::Exception::Exception(v179, 4294967081, v175, v163, &__p, 63);
        cv::error((cv *)v179, v23);
      }
    }
  }
  v180 = (char *)v179 + 8;
  v181 = (cv *)v182;
  v182[0] = 0;
  v182[1] = 0;
  LODWORD(v179[0]) = 1124007936;
  memset((char *)v179 + 4, 0, 48);
  v179[3] = 0u;
  v176 = (char *)v175 + 8;
  v177 = (cv *)v178;
  v178[0] = 0;
  v178[1] = 0;
  LODWORD(v175[0]) = 1124007936;
  memset((char *)v175 + 4, 0, 48);
  v175[3] = 0u;
  cv::_InputArray::_InputArray((uint64_t)v163, (const cv::Mat *)&v194);
  cv::_OutputArray::_OutputArray((uint64_t)&__p, (cv::Mat *)v179);
  if (a8)
    cv::cornerHarris((cv *)v163, (const cv::_InputArray *)&__p, a7, 3, 4u, a9);
  else
    cv::cornerMinEigenVal((cv *)v163, (const cv::_InputArray *)&__p, a7, 3, 4u);
  v171 = 0.0;
  cv::_InputArray::_InputArray((uint64_t)v163, (const cv::Mat *)v179);
  cv::_InputArray::_InputArray((uint64_t)&__p, (const cv::Mat *)&v183);
  cv::minMaxLoc((cv *)v163, 0, &v171, 0, 0, (int *)&__p);
  cv::_InputArray::_InputArray((uint64_t)v163, (const cv::Mat *)v179);
  cv::_OutputArray::_OutputArray((uint64_t)&__p, (cv::Mat *)v179);
  cv::threshold((cv *)v163, (const cv::_InputArray *)&__p, (const cv::_OutputArray *)3, v171 * a5, 0.0);
  cv::_InputArray::_InputArray((uint64_t)&__p, (const cv::Mat *)v179);
  cv::_OutputArray::_OutputArray((uint64_t)&v168, (cv::Mat *)v175);
  v164 = &v163[8];
  v165 = (cv *)&v166;
  v166 = 0uLL;
  *(_DWORD *)v163 = 1124007936;
  memset(&v163[4], 0, 60);
  cv::_InputArray::_InputArray((uint64_t)v167, (const cv::Mat *)v163);
  v162 = -1;
  v161[0] = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  v161[1] = v161[0];
  cv::dilate((void (***)(__int128 *__return_ptr, _QWORD, uint64_t))&__p, (uint64_t)&v168, (void (***)(__int128 *__return_ptr, _QWORD, uint64_t))v167, &v162, 1, 0, (uint64_t)v161);
  v25 = *(unsigned int **)&v163[24];
  if (*(_QWORD *)&v163[24])
  {
    do
    {
      v26 = __ldaxr(v25);
      v27 = v26 - 1;
    }
    while (__stlxr(v27, v25));
    if (!v27)
      cv::Mat::deallocate((cv::Mat *)v163, v24);
  }
  *(_QWORD *)&v163[16] = 0;
  memset(&v163[32], 0, 24);
  if (*(int *)&v163[4] >= 1)
  {
    v28 = 0;
    v29 = v164;
    do
      *(_DWORD *)&v29[4 * v28++] = 0;
    while (v28 < *(int *)&v163[4]);
  }
  *(_QWORD *)&v163[24] = 0;
  if (v165 != (cv *)&v166)
    cv::fastFree((void **)v165, v24);
  v157 = v15;
  v155 = a2;
  v30 = *v202;
  v159 = v202[1];
  __p = 0;
  v173 = 0;
  v174 = 0;
  if (v30 >= 3)
  {
    v31 = 0;
    v158 = (v30 - 1);
    v32 = 1;
    do
    {
      if (v186)
        v33 = v186 + *(_QWORD *)v192 * v32;
      else
        v33 = 0;
      if (v159 >= 3)
      {
        v34 = *(_QWORD *)&v179[1] + *(_QWORD *)v181 * v32;
        v35 = *(_QWORD *)&v175[1] + *(_QWORD *)v177 * v32;
        v36 = 1;
        do
        {
          v37 = (float *)(v34 + 4 * v36);
          if (*v37 != 0.0 && *v37 == *(float *)(v35 + 4 * v36) && (!v33 || *(_BYTE *)(v33 + v36)))
          {
            if (v31 >= v174)
            {
              v38 = ((char *)v31 - (_BYTE *)__p) >> 3;
              if ((unint64_t)(v38 + 1) >> 61)
                std::vector<int>::__throw_length_error[abi:ne180100]();
              v39 = ((char *)v174 - (_BYTE *)__p) >> 2;
              if (v39 <= v38 + 1)
                v39 = v38 + 1;
              if ((unint64_t)((char *)v174 - (_BYTE *)__p) >= 0x7FFFFFFFFFFFFFF8)
                v40 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v40 = v39;
              if (v40)
                v41 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CGPoint *>>((uint64_t)&v174, v40);
              else
                v41 = 0;
              v42 = (float **)&v41[8 * v38];
              *v42 = v37;
              v31 = v42 + 1;
              v44 = (char *)__p;
              v43 = (char *)v173;
              if (v173 != __p)
              {
                do
                {
                  v45 = (float *)*((_QWORD *)v43 - 1);
                  v43 -= 8;
                  *--v42 = v45;
                }
                while (v43 != v44);
                v43 = (char *)__p;
              }
              __p = v42;
              v173 = v31;
              v174 = (float **)&v41[8 * v40];
              if (v43)
                operator delete(v43);
            }
            else
            {
              *v31++ = v37;
            }
            v173 = v31;
          }
          ++v36;
        }
        while (v36 != v159 - 1);
      }
      ++v32;
    }
    while (v32 != v158);
  }
  cv::sort<float const*,cv::greaterThanPtr<float>>((unint64_t)&__p);
  v168 = 0;
  v169 = 0;
  v170[0] = 0;
  v47 = (float **)__p;
  v46 = v173;
  v48 = ((char *)v173 - (_BYTE *)__p) >> 3;
  if (a6 >= 1.0)
  {
    v65 = (uint64_t)rint(a6);
    v66 = (((int)v65 - 1 + v196) / (int)v65);
    v67 = ((int)v65 - 1 + v195) / (int)v65;
    std::vector<std::vector<cv::Point_<float>>>::vector(v163, v67 * (int)v66);
    if (v46 != v47)
    {
      v68 = 0;
      v69 = 0;
      v70 = a6 * a6;
      v71 = (v66 - 1);
      v72 = (v67 - 1);
      v73 = (int)v66;
      if (v48 <= 1)
        v74 = 1;
      else
        v74 = v48;
      v160 = v74;
      v156 = v65;
      do
      {
        v75 = (int)(*((_QWORD *)__p + v69) - LODWORD(v179[1]));
        v76 = v75 / v182[0];
        v77 = (v75 - (int)(v75 / v182[0]) * v182[0]) >> 2;
        v78 = (int)v77 / (int)v65;
        v79 = (int)v76 / (int)v65;
        if ((int)v76 / (int)v65 <= 1)
          v80 = 1;
        else
          v80 = v79;
        if ((int)v76 / (int)v65 + 1 < (int)v72)
          v81 = v79 + 1;
        else
          v81 = v72;
        if ((int)v80 - 1 <= v81)
        {
          if (v78 + 1 < (int)v71)
            v90 = v78 + 1;
          else
            v90 = v71;
          if (v78 <= 1)
            v91 = 1;
          else
            v91 = v78;
          v82 = (float)(int)v77;
          v83 = (float)(int)v76;
          v92 = v80 - 1;
          v93 = (v81 + 1);
          while ((int)v91 - 1 > v90)
          {
LABEL_106:
            if (++v92 == v93)
              goto LABEL_96;
          }
          v94 = v91 - 1;
          while (1)
          {
            v95 = (uint64_t *)(*(_QWORD *)v163 + 24 * (v94 + v92 * v73));
            v96 = *v95;
            v97 = v95[1] - *v95;
            if (v97)
              break;
LABEL_115:
            if (++v94 == v90 + 1)
              goto LABEL_106;
          }
          v98 = v97 >> 3;
          if (v98 <= 1)
            v98 = 1;
          v99 = (float *)(v96 + 4);
          while (v70 <= (float)((float)((float)(v83 - *v99) * (float)(v83 - *v99))
                               + (float)((float)(v82 - *(v99 - 1)) * (float)(v82 - *(v99 - 1)))))
          {
            v99 += 2;
            if (!--v98)
              goto LABEL_115;
          }
        }
        else
        {
          v82 = (float)(int)v77;
          v83 = (float)(int)v76;
LABEL_96:
          v84 = (float **)(*(_QWORD *)v163 + 24 * (int)(v78 + v79 * v66));
          v86 = (void **)(v84 + 1);
          v85 = v84[1];
          v88 = v84 + 2;
          v87 = (unint64_t)v84[2];
          if ((unint64_t)v85 >= v87)
          {
            v65 = v72;
            v100 = v68;
            v101 = v73;
            v102 = v71;
            v103 = v66;
            v104 = ((char *)v85 - (char *)*v84) >> 3;
            v105 = v104 + 1;
            if ((unint64_t)(v104 + 1) >> 61)
              std::vector<int>::__throw_length_error[abi:ne180100]();
            v106 = v87 - (_QWORD)*v84;
            if (v106 >> 2 > v105)
              v105 = v106 >> 2;
            if ((unint64_t)v106 >= 0x7FFFFFFFFFFFFFF8)
              v107 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v107 = v105;
            v109 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CGPoint *>>((uint64_t)(v84 + 2), v107);
            v110 = (float *)&v109[8 * v104];
            *v110 = v82;
            v110[1] = v83;
            v111 = (float *)*v86;
            v112 = *v84;
            v113 = v110;
            v66 = v103;
            while (v111 != v112)
            {
              v114 = *((_QWORD *)v111 - 1);
              v111 -= 2;
              *((_QWORD *)v113 - 1) = v114;
              v113 -= 2;
            }
            *v84 = v113;
            v89 = v110 + 2;
            *v86 = v110 + 2;
            *v88 = &v109[8 * v108];
            v71 = v102;
            if (v112)
              operator delete(v112);
            v73 = v101;
            v68 = v100;
            v72 = v65;
            LODWORD(v65) = v156;
          }
          else
          {
            *v85 = v82;
            v85[1] = v83;
            v89 = v85 + 2;
          }
          *v86 = v89;
          v115 = v169;
          if ((unint64_t)v169 >= v170[0])
          {
            v117 = ((char *)v169 - (_BYTE *)v168) >> 3;
            v118 = v117 + 1;
            if ((unint64_t)(v117 + 1) >> 61)
              std::vector<int>::__throw_length_error[abi:ne180100]();
            v119 = v170[0] - (_QWORD)v168;
            if ((uint64_t)(v170[0] - (_QWORD)v168) >> 2 > v118)
              v118 = v119 >> 2;
            if ((unint64_t)v119 >= 0x7FFFFFFFFFFFFFF8)
              v120 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v120 = v118;
            v122 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CGPoint *>>((uint64_t)v170, v120);
            v123 = (float *)&v122[8 * v117];
            *v123 = v82;
            v123[1] = v83;
            v124 = (float *)v168;
            v125 = v169;
            v126 = v123;
            while (v125 != v124)
            {
              v127 = *((_QWORD *)v125 - 1);
              v125 -= 2;
              *((_QWORD *)v126 - 1) = v127;
              v126 -= 2;
            }
            v116 = v123 + 2;
            v168 = v126;
            v169 = v123 + 2;
            v170[0] = &v122[8 * v121];
            if (v124)
              operator delete(v124);
          }
          else
          {
            *v169 = v82;
            v115[1] = v83;
            v116 = v115 + 2;
          }
          v169 = v116;
          ++v68;
          if (v157 >= 1 && v68 == v157)
            break;
        }
        ++v69;
      }
      while (v69 != v160);
    }
    v167[0] = (void **)v163;
    std::vector<std::vector<long long>>::__destroy_vector::operator()[abi:ne180100](v167);
    v49 = v169;
  }
  else
  {
    v49 = 0;
    if (v173 != __p)
    {
      v50 = 0;
      if (v48 <= 1)
        v48 = 1;
      do
      {
        v51 = (int)(*((_QWORD *)__p + v50) - LODWORD(v179[1]));
        v52 = (float)(int)((v51 - (int)(v51 / v182[0]) * v182[0]) >> 2);
        v53 = (float)(int)(v51 / v182[0]);
        if ((unint64_t)v49 >= v170[0])
        {
          v54 = ((char *)v49 - (_BYTE *)v168) >> 3;
          if ((unint64_t)(v54 + 1) >> 61)
            std::vector<int>::__throw_length_error[abi:ne180100]();
          v55 = (uint64_t)(v170[0] - (_QWORD)v168) >> 2;
          if (v55 <= v54 + 1)
            v55 = v54 + 1;
          if (v170[0] - (_QWORD)v168 >= 0x7FFFFFFFFFFFFFF8uLL)
            v56 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v56 = v55;
          v58 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CGPoint *>>((uint64_t)v170, v56);
          v59 = (float *)&v58[8 * v54];
          *v59 = v52;
          v59[1] = v53;
          v60 = (float *)v168;
          v61 = v169;
          v62 = v59;
          while (v61 != v60)
          {
            v63 = *((_QWORD *)v61 - 1);
            v61 -= 2;
            *((_QWORD *)v62 - 1) = v63;
            v62 -= 2;
          }
          v49 = v59 + 2;
          v168 = v62;
          v169 = v59 + 2;
          v170[0] = &v58[8 * v57];
          if (v60)
            operator delete(v60);
        }
        else
        {
          *v49 = v52;
          v49[1] = v53;
          v49 += 2;
        }
        v64 = (_DWORD)++v50 != v157 || v157 <= 0;
        v169 = v49;
      }
      while (v64 && v50 != v48);
    }
  }
  *(_QWORD *)v163 = 0x242FF400DLL;
  memset(&v163[16], 0, 32);
  *(_QWORD *)&v163[56] = 0;
  v164 = &v163[8];
  v166 = 0uLL;
  v165 = (cv *)&v166;
  *(_DWORD *)&v163[8] = (unint64_t)((char *)v49 - (_BYTE *)v168) >> 3;
  *(_DWORD *)&v163[12] = 1;
  if (v49 != v168)
  {
    v166 = vdupq_n_s64(8uLL);
    *(_QWORD *)&v163[32] = v168;
    *(_QWORD *)&v163[16] = v168;
    *(_QWORD *)&v163[40] = (char *)v168 + 8 * (int)(((char *)v49 - (_BYTE *)v168) >> 3);
    *(_QWORD *)&v163[48] = *(_QWORD *)&v163[40];
  }
  if ((*(unsigned int (**)(const cv::_OutputArray *))(*(_QWORD *)v155 + 104))(v155))
    v128 = (*(uint64_t (**)(const cv::_OutputArray *, uint64_t))(*(_QWORD *)v155 + 64))(v155, 0xFFFFFFFFLL);
  else
    v128 = 5;
  cv::Mat::convertTo((cv::Mat *)v163, v155, v128, 1.0, 0.0);
  v130 = *(unsigned int **)&v163[24];
  if (*(_QWORD *)&v163[24])
  {
    do
    {
      v131 = __ldaxr(v130);
      v132 = v131 - 1;
    }
    while (__stlxr(v132, v130));
    if (!v132)
      cv::Mat::deallocate((cv::Mat *)v163, v129);
  }
  *(_QWORD *)&v163[16] = 0;
  memset(&v163[32], 0, 24);
  if (*(int *)&v163[4] >= 1)
  {
    v133 = 0;
    v134 = v164;
    do
      *(_DWORD *)&v134[4 * v133++] = 0;
    while (v133 < *(int *)&v163[4]);
  }
  *(_QWORD *)&v163[24] = 0;
  if (v165 != (cv *)&v166)
    cv::fastFree((void **)v165, v129);
  if (v168)
  {
    v169 = (float *)v168;
    operator delete(v168);
  }
  if (__p)
  {
    v173 = (float **)__p;
    operator delete(__p);
  }
  v135 = (unsigned int *)*((_QWORD *)&v175[1] + 1);
  if (*((_QWORD *)&v175[1] + 1))
  {
    do
    {
      v136 = __ldaxr(v135);
      v137 = v136 - 1;
    }
    while (__stlxr(v137, v135));
    if (!v137)
      cv::Mat::deallocate((cv::Mat *)v175, v129);
  }
  *(_QWORD *)&v175[1] = 0;
  memset(&v175[2], 0, 24);
  if (SDWORD1(v175[0]) >= 1)
  {
    v138 = 0;
    v139 = v176;
    do
      *(_DWORD *)&v139[4 * v138++] = 0;
    while (v138 < SDWORD1(v175[0]));
  }
  *((_QWORD *)&v175[1] + 1) = 0;
  if (v177 != (cv *)v178)
    cv::fastFree((void **)v177, v129);
  v140 = (unsigned int *)*((_QWORD *)&v179[1] + 1);
  if (*((_QWORD *)&v179[1] + 1))
  {
    do
    {
      v141 = __ldaxr(v140);
      v142 = v141 - 1;
    }
    while (__stlxr(v142, v140));
    if (!v142)
      cv::Mat::deallocate((cv::Mat *)v179, v129);
  }
  *(_QWORD *)&v179[1] = 0;
  memset(&v179[2], 0, 24);
  if (SDWORD1(v179[0]) >= 1)
  {
    v143 = 0;
    v144 = v180;
    do
      *(_DWORD *)&v144[4 * v143++] = 0;
    while (v143 < SDWORD1(v179[0]));
  }
  *((_QWORD *)&v179[1] + 1) = 0;
  if (v181 != (cv *)v182)
    cv::fastFree((void **)v181, v129);
  v145 = v187;
  if (v187)
  {
    do
    {
      v146 = __ldaxr(v145);
      v147 = v146 - 1;
    }
    while (__stlxr(v147, v145));
    if (!v147)
      cv::Mat::deallocate((cv::Mat *)&v183, v129);
  }
  v186 = 0;
  v188 = 0;
  v190 = 0;
  v189 = 0;
  if (SHIDWORD(v183) >= 1)
  {
    v148 = 0;
    v149 = v191;
    do
      v149[v148++] = 0;
    while (v148 < SHIDWORD(v183));
  }
  v187 = 0;
  if (v192 != (cv *)&v193)
    cv::fastFree((void **)v192, v129);
  v150 = v198;
  if (v198)
  {
    do
    {
      v151 = __ldaxr(v150);
      v152 = v151 - 1;
    }
    while (__stlxr(v152, v150));
    if (!v152)
      cv::Mat::deallocate((cv::Mat *)&v194, v129);
  }
  v197 = 0;
  v199 = 0;
  v200 = 0;
  v201 = 0;
  if (SHIDWORD(v194) >= 1)
  {
    v153 = 0;
    v154 = v202;
    do
      v154[v153++] = 0;
    while (v153 < SHIDWORD(v194));
  }
  v198 = 0;
  if (v203 != (void **)&v204)
    cv::fastFree(v203, v129);
}

void sub_219E7A5C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,void *a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,void *__p,uint64_t a48,int a49,__int16 a50,char a51,char a52,uint64_t a53,void *a54,uint64_t a55,int a56,__int16 a57,char a58,char a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  char a69;
  uint64_t v69;
  void *v71;
  void *v72;

  cv::Exception::~Exception((cv::Exception *)&a69);
  if (a52 < 0)
    operator delete(__p);
  if (a28 < 0)
    operator delete(a23);
  if (a59 < 0)
    operator delete(a54);
  cv::Mat::~Mat((cv::Mat *)&STACK[0x210], v71);
  cv::Mat::~Mat((cv::Mat *)(v69 - 224), v72);
  _Unwind_Resume(a1);
}

unint64_t cv::sort<float const*,cv::greaterThanPtr<float>>(unint64_t result)
{
  uint64_t v1;
  unint64_t v2;
  uint64_t v3;
  float ***v4;
  char *v5;
  float **v6;
  unint64_t i;
  float **v8;
  uint64_t v9;
  float **v10;
  uint64_t v11;
  float **v12;
  float *v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float **v18;
  float v19;
  BOOL v20;
  float v21;
  BOOL v22;
  float v23;
  uint64_t v24;
  float **v25;
  float **v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float **v31;
  float v32;
  BOOL v33;
  float v34;
  BOOL v35;
  float v36;
  float **v37;
  float **v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float *v43;
  int v44;
  float **v45;
  float **v46;
  char *v47;
  char *v48;
  float v49;
  float v50;
  float *v51;
  float *v52;
  float v53;
  float v54;
  float *v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  uint64_t v59;
  float **v60;
  float *v61;
  unint64_t v63;
  unint64_t v64;
  int v65;
  uint64_t v66;
  float *v67;
  float ***v68;
  uint64_t v69;
  uint64_t *v70;
  float **j;
  float *v72;
  float v73;
  float **v74;
  float **v75;
  float *v76;
  float *v77;
  _QWORD v78[97];

  v78[96] = *MEMORY[0x24BDAC8D0];
  v1 = *(_QWORD *)result;
  v2 = *(_QWORD *)(result + 8) - *(_QWORD *)result;
  if (v2 >= 0x10)
  {
    LODWORD(v3) = 0;
    v78[0] = *(_QWORD *)result;
    v78[1] = v2 + v1 - 8;
    do
    {
      v4 = (float ***)&v78[2 * v3];
      LODWORD(v3) = v3 - 1;
      v6 = *v4;
      v5 = (char *)v4[1];
      for (i = (unint64_t)(v5 - (char *)v6) >> 3; (int)i >= 7; i = (unint64_t)(v5 - (char *)v6) >> 3)
      {
        v8 = &v6[(i + 1) >> 1];
        if (i <= 0x27)
        {
          v13 = *v6;
          v23 = **v6;
          v36 = **v8;
          v10 = v6;
          v38 = (float **)v5;
        }
        else
        {
          v9 = (i + 1) >> 3;
          v10 = &v6[v9];
          v11 = (2 * v9);
          v12 = &v6[v11];
          v13 = *v6;
          v14 = **v6;
          v15 = **v10;
          v16 = **v12;
          if (v14 <= v16)
            v17 = **v12;
          else
            v17 = **v6;
          if (v14 <= v16)
            v18 = &v6[v11];
          else
            v18 = v6;
          if (v16 > v15)
          {
            v17 = **v10;
            v18 = &v6[v9];
          }
          if (v14 <= v16)
            v19 = **v6;
          else
            v19 = **v12;
          if (v14 <= v16)
            v12 = v6;
          v20 = v15 <= v16;
          if (v15 <= v16)
            v21 = v19;
          else
            v21 = **v10;
          if (v20)
            v10 = v12;
          v22 = v14 <= v15;
          if (v14 > v15)
            v23 = v21;
          else
            v23 = v17;
          if (v22)
            v10 = v18;
          v24 = -v9;
          v25 = &v8[-v9];
          v26 = &v8[v9];
          v27 = **v25;
          v28 = **v8;
          v29 = **v26;
          if (v27 <= v29)
            v30 = **v26;
          else
            v30 = **v25;
          if (v27 <= v29)
            v31 = v26;
          else
            v31 = v25;
          if (v29 > v28)
          {
            v30 = **v8;
            v31 = v8;
          }
          if (v27 <= v29)
            v32 = **v25;
          else
            v32 = **v26;
          if (v27 <= v29)
            v26 = v25;
          v33 = v28 <= v29;
          if (v28 <= v29)
            v34 = v32;
          else
            v34 = **v8;
          if (v33)
            v8 = v26;
          v35 = v27 <= v28;
          if (v27 > v28)
            v36 = v34;
          else
            v36 = v30;
          if (v35)
            v8 = v31;
          v37 = (float **)&v5[-8 * v11];
          v38 = (float **)&v5[8 * v24];
          v39 = **v37;
          v40 = **v38;
          result = *(_QWORD *)v5;
          v41 = **(float **)v5;
          if (v39 <= v40)
          {
            if (v41 <= v40)
            {
              if (v39 <= v41)
                v38 = (float **)v5;
              else
                v38 = v37;
            }
          }
          else if (v40 <= v41)
          {
            if (v39 <= v41)
              v38 = v37;
            else
              v38 = (float **)v5;
          }
        }
        v42 = **v38;
        if (v23 <= v36)
        {
          if (v42 <= v36)
          {
            if (v23 <= v42)
              v8 = v38;
            else
              v8 = v10;
          }
        }
        else
        {
          if (v23 > v42)
            v10 = v38;
          if (v36 <= v42)
            v8 = v10;
        }
        if (v8 != v6)
        {
          v43 = *v8;
          *v8 = v13;
          *v6 = v43;
        }
        v44 = 0;
        v45 = v6 + 1;
        v46 = (float **)v5;
        v47 = (char *)(v6 + 1);
        v48 = v5;
LABEL_73:
        while (v45 <= v46)
        {
          result = (unint64_t)*v45;
          v49 = **v6;
          v50 = **v45;
          if (v49 > v50)
            break;
          if (v50 <= v49)
          {
            if (v45 > (float **)v47)
            {
              v51 = *(float **)v47;
              *(_QWORD *)v47 = result;
              *v45 = v51;
            }
            v47 += 8;
            v44 = 1;
          }
          ++v45;
        }
        while (v45 <= v46)
        {
          result = (unint64_t)*v46;
          v53 = **v46;
          v54 = **v6;
          if (v53 > v54)
          {
            v55 = *v45;
            *v45++ = (float *)result;
            *v46-- = v55;
            v44 = 1;
            goto LABEL_73;
          }
          if (v54 <= v53)
          {
            if (v46 < (float **)v48)
            {
              v52 = *(float **)v48;
              *(_QWORD *)v48 = result;
              *v46 = v52;
            }
            v48 -= 8;
            v44 = 1;
          }
          --v46;
        }
        if (!v44)
          break;
        v56 = (unint64_t)(v47 - (char *)v6) >> 3;
        v57 = (char *)v45 - v47;
        v58 = v57 >> 3;
        if ((int)(v57 >> 3) < (int)v56)
          LODWORD(v56) = v57 >> 3;
        if ((int)v56 >= 1)
        {
          v59 = -(uint64_t)v56;
          v60 = v6;
          do
          {
            v61 = *v60;
            *v60++ = v45[v59];
            v45[v59] = v61;
          }
          while (!__CFADD__(v59++, 1));
        }
        result = (unint64_t)(v5 - v48) >> 3;
        v63 = v48 - (char *)v46;
        v64 = v63 >> 3;
        if ((int)(v63 >> 3) >= (int)result)
          v65 = result;
        else
          v65 = v63 >> 3;
        if (v65 >= 1)
        {
          LODWORD(result) = 1 - v65;
          v66 = 8 * v65;
          do
          {
            v67 = *v45;
            *v45++ = *(float **)&v5[8 * (int)result];
            *(_QWORD *)&v5[8 * (int)result] = v67;
            result = (result + 1);
            v66 -= 8;
          }
          while (v66);
        }
        if ((int)v58 <= 1)
        {
          if ((int)v64 < 2)
            goto LABEL_121;
          v6 = (float **)&v5[-(v63 & 0x7FFFFFFF8) + 8];
        }
        else if ((int)v64 < 2)
        {
          v5 = (char *)v6 + (v57 & 0x7FFFFFFF8) - 8;
        }
        else if (v58 <= v64)
        {
          v69 = (uint64_t)&v5[-(v63 & 0x7FFFFFFF8) + 8];
          v3 = (int)v3 + 1;
          v70 = &v78[2 * v3];
          *v70 = v69;
          v70[1] = (uint64_t)v5;
          v5 = (char *)v6 + (v57 & 0x7FFFFFFF8) - 8;
        }
        else
        {
          v3 = (int)v3 + 1;
          v68 = (float ***)&v78[2 * v3];
          *v68 = v6;
          v68[1] = (float **)((char *)v6 + (v57 & 0x7FFFFFFF8) - 8);
          v6 = (float **)&v5[-(v63 & 0x7FFFFFFF8) + 8];
        }
      }
      for (j = v6 + 1; j <= (float **)v5; ++j)
      {
        if (j > v6)
        {
          v72 = *j;
          v73 = **j;
          v74 = j;
          v75 = j;
          do
          {
            v77 = *--v75;
            v76 = v77;
            if (v73 <= *v77)
              break;
            *(v74 - 1) = v72;
            *v74 = v76;
            v74 = v75;
          }
          while (v75 > v6);
        }
      }
LABEL_121:
      ;
    }
    while ((v3 & 0x80000000) == 0);
  }
  return result;
}

_QWORD *std::vector<std::vector<cv::Point_<float>>>::vector(_QWORD *a1, unint64_t a2)
{
  char *v4;
  size_t v5;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::vector<long long>>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    v5 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v4, v5);
    a1[1] = &v4[v5];
  }
  return a1;
}

void sub_219E7AC08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<std::vector<long long>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t cvCreateMat(int a1, int a2, unsigned int a3)
{
  uint64_t MatHeader;

  MatHeader = cvCreateMatHeader(a1, a2, a3);
  cvCreateData(MatHeader);
  return MatHeader;
}

uint64_t cvCreateMatHeader(int a1, int a2, unsigned int a3)
{
  __int16 v3;
  const cv::Exception *v6;
  int v7;
  const cv::Exception *v8;
  uint64_t result;
  void *__p[2];
  void *v11[2];
  void *v12[2];
  _BYTE v13[120];

  v3 = a3;
  if (a1 < 0 || a2 <= 0)
  {
    std::string::basic_string[abi:ne180100]<0>(v12, "Non-positive width or height");
    std::string::basic_string[abi:ne180100]<0>(v11, "cvCreateMatHeader");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v13, 4294967095, v12, v11, __p, 113);
    cv::error((cv *)v13, v6);
  }
  v7 = ((((a3 >> 3) & 0x1FF) + 1) << ((0xFA50u >> (2 * (a3 & 7))) & 3)) * a2;
  if (v7 <= 0)
  {
    std::string::basic_string[abi:ne180100]<0>(v12, "Invalid matrix type");
    std::string::basic_string[abi:ne180100]<0>(v11, "cvCreateMatHeader");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v13, 4294967086, v12, v11, __p, 117);
    cv::error((cv *)v13, v8);
  }
  result = cvAlloc(40);
  *(_DWORD *)result = v3 & 0xFFF | 0x42424000;
  *(_DWORD *)(result + 4) = v7;
  *(_DWORD *)(result + 32) = a1;
  *(_DWORD *)(result + 36) = a2;
  *(_QWORD *)(result + 24) = 0;
  *(_QWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = 1;
  if (v7 * (uint64_t)a1 >= 0x80000000)
    *(_DWORD *)result = v3 & 0xFFF | 0x42420000;
  return result;
}

void sub_219E7AE10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

uint64_t cvCreateData(uint64_t result)
{
  uint64_t v1;
  unsigned int v2;
  unsigned int v3;
  int v4;
  int v5;
  int v6;
  const cv::Exception *v7;
  unint64_t v8;
  const cv::Exception *v9;
  void *v10;
  int v11;
  int v12;
  char v13;
  const cv::Exception *v14;
  const cv::Exception *v15;
  uint64_t v16;
  unint64_t v17;
  void *__p[2];
  void *v19[2];
  void *v20[2];
  _BYTE v21[120];

  if (!result)
    goto LABEL_27;
  v1 = result;
  v2 = *(_DWORD *)result;
  v3 = *(_DWORD *)result & 0xFFFF0000;
  if (v3 != 1111621632)
  {
    if (v2 == 144)
    {
      if (*(_QWORD *)(result + 88))
      {
        std::string::basic_string[abi:ne180100]<0>(v20, "Data is already allocated");
        std::string::basic_string[abi:ne180100]<0>(v19, "cvCreateData");
        std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
        cv::Exception::Exception(v21, 4294967294, v20, v19, __p, 825);
        cv::error((cv *)v21, v9);
      }
      v10 = CvIPL;
      if (CvIPL)
      {
        v11 = *(_DWORD *)(result + 16);
        v12 = *(_DWORD *)(result + 40);
        if (v11 == 64 || v11 == 32)
        {
          if (v11 == 32)
            v13 = 2;
          else
            v13 = 3;
          *(_DWORD *)(result + 40) = v12 << v13;
          *(_DWORD *)(result + 16) = 8;
        }
        result = ((uint64_t (*)(uint64_t, _QWORD, _QWORD))v10)(result, 0, 0);
        *(_DWORD *)(v1 + 40) = v12;
        *(_DWORD *)(v1 + 16) = v11;
      }
      else
      {
        result = cvAlloc(*(int *)(result + 80));
        *(_QWORD *)(v1 + 136) = result;
        *(_QWORD *)(v1 + 88) = result;
      }
      return result;
    }
    if (v3 == 1111687168)
    {
      if (!*(_DWORD *)(result + 32))
        return result;
      if (*(_QWORD *)(result + 24))
      {
        std::string::basic_string[abi:ne180100]<0>(v20, "Data is already allocated");
        std::string::basic_string[abi:ne180100]<0>(v19, "cvCreateData");
        std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
        cv::Exception::Exception(v21, 4294967294, v20, v19, __p, 859);
        cv::error((cv *)v21, v14);
      }
      v8 = (((v2 >> 3) & 0x1FF) + 1) << ((0xFA50u >> (2 * (v2 & 7))) & 3);
      if ((*(_DWORD *)result & 0x4000) != 0)
      {
        if (*(_DWORD *)(result + 36))
          v8 = *(int *)(result + 36);
        v8 *= *(int *)(result + 32);
      }
      else
      {
        v16 = *(unsigned int *)(result + 4);
        if ((int)v16 >= 1)
        {
          v17 = v16 + 1;
          do
          {
            if (v8 <= *(int *)(result + 8 * (v17 - 2) + 32)
                     * (uint64_t)*(int *)(result + 8 * (v17 - 2) + 36))
              v8 = *(int *)(result + 8 * (v17 - 2) + 32)
                 * (uint64_t)*(int *)(result + 8 * (v17 - 2) + 36);
            --v17;
          }
          while (v17 > 1);
        }
      }
      goto LABEL_39;
    }
LABEL_27:
    std::string::basic_string[abi:ne180100]<0>(v20, "unrecognized or unsupported array type");
    std::string::basic_string[abi:ne180100]<0>(v19, "cvCreateData");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v21, 4294967291, v20, v19, __p, 883);
    cv::error((cv *)v21, v15);
  }
  v4 = *(_DWORD *)(result + 36);
  if (v4 < 0)
    goto LABEL_27;
  v5 = *(_DWORD *)(result + 32);
  if (v5 < 0)
    goto LABEL_27;
  if (v4 && v5)
  {
    v6 = *(_DWORD *)(result + 4);
    if (*(_QWORD *)(result + 24))
    {
      std::string::basic_string[abi:ne180100]<0>(v20, "Data is already allocated");
      std::string::basic_string[abi:ne180100]<0>(v19, "cvCreateData");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
      cv::Exception::Exception(v21, 4294967294, v20, v19, __p, 807);
      cv::error((cv *)v21, v7);
    }
    if (!v6)
      v6 = ((((*(_DWORD *)result >> 3) & 0x1FF) + 1) << ((0xFA50u >> (2 * (*(_BYTE *)result & 7))) & 3))
         * *(_DWORD *)(result + 36);
    v8 = *(int *)(result + 32) * (uint64_t)v6;
LABEL_39:
    result = cvAlloc(v8 + 20);
    *(_QWORD *)(v1 + 8) = result;
    *(_QWORD *)(v1 + 24) = (result + 19) & 0xFFFFFFFFFFFFFFF0;
    *(_DWORD *)result = 1;
  }
  return result;
}

void sub_219E7B280(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

uint64_t cvInitMatHeader(uint64_t result, int a2, int a3, unsigned int a4, uint64_t a5, int a6)
{
  int v6;
  const cv::Exception *v7;
  const cv::Exception *v8;
  int v9;
  int v10;
  const cv::Exception *v11;
  int v13;
  void *__p[2];
  void *v15[2];
  void *v16[2];
  _BYTE v17[120];

  v6 = a6;
  if (!result)
  {
    std::string::basic_string[abi:ne180100]<0>(v16, "");
    std::string::basic_string[abi:ne180100]<0>(v15, "cvInitMatHeader");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v17, 4294967269, v16, v15, __p, 140);
    cv::error((cv *)v17, v7);
  }
  if (a2 < 0 || a3 <= 0)
  {
    std::string::basic_string[abi:ne180100]<0>(v16, "Non-positive cols or rows");
    std::string::basic_string[abi:ne180100]<0>(v15, "cvInitMatHeader");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v17, 4294967095, v16, v15, __p, 146);
    cv::error((cv *)v17, v8);
  }
  v9 = a4 & 0xFFF | 0x42420000;
  *(_DWORD *)result = v9;
  *(_DWORD *)(result + 32) = a2;
  *(_DWORD *)(result + 36) = a3;
  *(_QWORD *)(result + 24) = a5;
  *(_QWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = 0;
  v10 = ((((a4 >> 3) & 0x1FF) + 1) << ((0xFA50u >> (2 * (a4 & 7))) & 3)) * a3;
  if (a6 && a6 != 0x7FFFFFFF)
  {
    if (v10 > a6)
    {
      std::string::basic_string[abi:ne180100]<0>(v16, "");
      std::string::basic_string[abi:ne180100]<0>(v15, "cvInitMatHeader");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
      cv::Exception::Exception(v17, 4294967283, v16, v15, __p, 162);
      cv::error((cv *)v17, v11);
    }
  }
  else
  {
    v6 = ((((a4 >> 3) & 0x1FF) + 1) << ((0xFA50u >> (2 * (a4 & 7))) & 3)) * a3;
  }
  if (v6 == v10 || a2 == 1)
    v13 = 0x4000;
  else
    v13 = 0;
  if (v6 * (uint64_t)a2 > 0x7FFFFFFF)
    v13 = 0;
  *(_DWORD *)result = v9 | v13;
  *(_DWORD *)(result + 4) = v6;
  return result;
}

void sub_219E7B5A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

void cvReleaseMat(int **a1, void *a2)
{
  const cv::Exception *v2;
  int *v3;
  int v4;
  unsigned int v5;
  const cv::Exception *v6;
  unsigned int v7;
  void **v8;
  void *__p[2];
  void *v11[2];
  void *v12[2];
  _BYTE v13[120];

  if (!a1)
  {
    std::string::basic_string[abi:ne180100]<0>(v12, "");
    std::string::basic_string[abi:ne180100]<0>(v11, "cvReleaseMat");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v13, 4294967287, v12, v11, __p, 183);
    cv::error((cv *)v13, v2);
  }
  v3 = *a1;
  if (*a1)
  {
    v4 = *v3;
    v5 = *v3 & 0xFFFF0000;
    if (v5 != 1111687168 && (v5 != 1111621632 || v3[9] < 0 || v3[8] < 0))
    {
      std::string::basic_string[abi:ne180100]<0>(v12, "");
      std::string::basic_string[abi:ne180100]<0>(v11, "cvReleaseMat");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
      cv::Exception::Exception(v13, 4294967090, v12, v11, __p, 190);
      cv::error((cv *)v13, v6);
    }
    *a1 = 0;
    v7 = v4 & 0xFFFF0000;
    if ((v7 == 1111687168 || v7 == 1111621632 && v3[9] >= 1 && v3[8] >= 1) && *((_QWORD *)v3 + 3))
    {
      v8 = (void **)*((_QWORD *)v3 + 1);
      *((_QWORD *)v3 + 3) = 0;
      if (v8)
      {
        if ((*(_DWORD *)v8)-- == 1)
          cv::fastFree(v8, a2);
      }
      *((_QWORD *)v3 + 1) = 0;
    }
    cv::fastFree((void **)v3, a2);
  }
}

void sub_219E7B810(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

uint64_t cvCloneMat(uint64_t a1)
{
  unsigned int v2;
  int v3;
  int v4;
  const cv::Exception *v5;
  uint64_t MatHeader;
  uint64_t v7;
  void *__p[2];
  void *v10[2];
  void *v11[2];
  _BYTE v12[120];

  if (!a1
    || (v2 = *(_DWORD *)a1, HIWORD(*(_DWORD *)a1) != 16962)
    || (v3 = *(_DWORD *)(a1 + 36), v3 < 1)
    || (v4 = *(_DWORD *)(a1 + 32), v4 <= 0))
  {
    std::string::basic_string[abi:ne180100]<0>(v11, "Bad CvMat header");
    std::string::basic_string[abi:ne180100]<0>(v10, "cvCloneMat");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v12, 4294967291, v11, v10, __p, 205);
    cv::error((cv *)v12, v5);
  }
  MatHeader = cvCreateMatHeader(v4, v3, v2);
  v7 = MatHeader;
  if (*(_QWORD *)(a1 + 24))
  {
    cvCreateData(MatHeader);
    cvCopy(a1, v7, 0);
  }
  return v7;
}

void sub_219E7B98C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

uint64_t cvInitMatNDHeader(uint64_t result, unsigned int a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  const cv::Exception *v5;
  const cv::Exception *v6;
  uint64_t v7;
  const cv::Exception *v8;
  unint64_t v9;
  uint64_t v10;
  int v11;
  const cv::Exception *v12;
  uint64_t v13;
  const cv::Exception *v14;
  int v15;
  void *__p[2];
  void *v17[2];
  void *v18[2];
  _BYTE v19[128];

  if (!result)
  {
    std::string::basic_string[abi:ne180100]<0>(v18, "NULL matrix header pointer");
    std::string::basic_string[abi:ne180100]<0>(v17, "cvInitMatNDHeader");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v19, 4294967269, v18, v17, __p, 231);
    cv::error((cv *)v19, v5);
  }
  if (!a3)
  {
    std::string::basic_string[abi:ne180100]<0>(v18, "NULL <sizes> pointer");
    std::string::basic_string[abi:ne180100]<0>(v17, "cvInitMatNDHeader");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v19, 4294967269, v18, v17, __p, 237);
    cv::error((cv *)v19, v6);
  }
  v7 = (((a4 >> 3) & 0x1FF) + 1) << ((0xFA50u >> (2 * (a4 & 7))) & 3);
  if (a2 - 33 <= 0xFFFFFFDF)
  {
    std::string::basic_string[abi:ne180100]<0>(v18, "non-positive or too large number of dimensions");
    std::string::basic_string[abi:ne180100]<0>(v17, "cvInitMatNDHeader");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v19, 4294967085, v18, v17, __p, 241);
    cv::error((cv *)v19, v8);
  }
  v9 = a2 + 1;
  do
  {
    v10 = (v9 - 2);
    v11 = *(_DWORD *)(a3 + 4 * v10);
    if (v11 < 0)
    {
      std::string::basic_string[abi:ne180100]<0>(v18, "one of dimesion sizes is non-positive");
      std::string::basic_string[abi:ne180100]<0>(v17, "cvInitMatNDHeader");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
      cv::Exception::Exception(v19, 4294967095, v18, v17, __p, 246);
      cv::error((cv *)v19, v12);
    }
    v13 = result + 8 * v10;
    *(_DWORD *)(v13 + 32) = v11;
    if (v7 >= 0x80000000)
    {
      std::string::basic_string[abi:ne180100]<0>(v18, "The array is too big");
      std::string::basic_string[abi:ne180100]<0>(v17, "cvInitMatNDHeader");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
      cv::Exception::Exception(v19, 4294967085, v18, v17, __p, 249);
      cv::error((cv *)v19, v14);
    }
    *(_DWORD *)(v13 + 36) = v7;
    v7 *= *(int *)(a3 + 4 * v10);
    --v9;
  }
  while (v9 > 1);
  if (v7 >= 0x80000000)
    v15 = 1111687168;
  else
    v15 = 1111703552;
  *(_DWORD *)result = v15 & 0xFFFFF000 | a4 & 0xFFF;
  *(_DWORD *)(result + 4) = a2;
  *(_QWORD *)(result + 24) = a5;
  *(_QWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = 0;
  return result;
}

void sub_219E7BDC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,char a30)
{
  cv::Exception::~Exception((cv::Exception *)&a30);
  if (a17 < 0)
    operator delete(__p);
  if (a23 < 0)
    operator delete(a18);
  if (a29 < 0)
    operator delete(a24);
  _Unwind_Resume(a1);
}

uint64_t cvCreateMatND(unsigned int a1, uint64_t a2, unsigned int a3)
{
  uint64_t MatNDHeader;

  MatNDHeader = cvCreateMatNDHeader(a1, a2, a3);
  cvCreateData(MatNDHeader);
  return MatNDHeader;
}

uint64_t cvCreateMatNDHeader(unsigned int a1, uint64_t a2, unsigned int a3)
{
  const cv::Exception *v6;
  uint64_t v7;
  uint64_t result;
  void *__p[2];
  void *v10[2];
  void *v11[2];
  _BYTE v12[120];

  if (a1 - 33 <= 0xFFFFFFDF)
  {
    std::string::basic_string[abi:ne180100]<0>(v11, "non-positive or too large number of dimensions");
    std::string::basic_string[abi:ne180100]<0>(v10, "cvCreateMatNDHeader");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v12, 4294967085, v11, v10, __p, 280);
    cv::error((cv *)v12, v6);
  }
  v7 = cvAlloc(288);
  result = cvInitMatNDHeader(v7, a1, a2, a3, 0);
  *(_DWORD *)(result + 16) = 1;
  return result;
}

void sub_219E7BF7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

uint64_t cvCloneMatND(uint64_t a1)
{
  cv *v2;
  const cv::Exception *v3;
  signed int v4;
  cv *v5;
  const cv::Exception *v6;
  uint64_t v7;
  int *v8;
  _DWORD *v9;
  int v10;
  uint64_t MatNDHeader;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  const cv::Exception *v15;
  unsigned int *v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int *v21;
  unsigned int v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  void *v27[2];
  void *v28[2];
  void *v29[2];
  void *v30[2];
  void *__p[2];
  uint64_t v32;
  unsigned int *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  cv *v38;
  uint64_t v39;
  void *v40[3];
  unsigned int *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  cv *v46;
  uint64_t v47;
  _BYTE v48[128];
  uint64_t v49;

  v49 = *MEMORY[0x24BDAC8D0];
  if (!a1 || *(_WORD *)(a1 + 2) != 16963)
  {
    std::string::basic_string[abi:ne180100]<0>(v30, "Bad CvMatND header");
    std::string::basic_string[abi:ne180100]<0>(v40, "cvCloneMatND");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    v2 = (cv *)cv::Exception::Exception(v48, 4294967291, v30, v40, __p, 295);
    cv::error(v2, v3);
  }
  v4 = *(_DWORD *)(a1 + 4);
  if (v4 >= 33)
  {
    std::string::basic_string[abi:ne180100]<0>(v30, "src->dims <= CV_MAX_DIM");
    std::string::basic_string[abi:ne180100]<0>(v40, "cvCloneMatND");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    v5 = (cv *)cv::Exception::Exception(v48, 4294967081, v30, v40, __p, 297);
    cv::error(v5, v6);
  }
  if (v4 >= 1)
  {
    v7 = v4;
    v8 = (int *)(a1 + 32);
    v9 = v48;
    do
    {
      v10 = *v8;
      v8 += 2;
      *v9++ = v10;
      --v7;
    }
    while (v7);
  }
  MatNDHeader = cvCreateMatNDHeader(v4, (uint64_t)v48, *(_DWORD *)a1);
  v12 = MatNDHeader;
  if (*(_QWORD *)(a1 + 24))
  {
    cvCreateData(MatNDHeader);
    cv::Mat::Mat(v40, a1, 0);
    cv::Mat::Mat(__p, v12, 0);
    v13 = *(_QWORD *)(v12 + 24);
    cv::_OutputArray::_OutputArray((uint64_t)v30, (cv::Mat *)__p);
    cv::Mat::copyTo((cv::Mat *)v40, (const cv::_OutputArray *)v30);
    if (v32 != v13)
    {
      std::string::basic_string[abi:ne180100]<0>(v29, "_dst.data == data0");
      std::string::basic_string[abi:ne180100]<0>(v28, "cvCloneMatND");
      std::string::basic_string[abi:ne180100]<0>(v27, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
      cv::Exception::Exception(v30, 4294967081, v29, v28, v27, 311);
      cv::error((cv *)v30, v15);
    }
    v16 = v33;
    if (v33)
    {
      do
      {
        v17 = __ldaxr(v16);
        v18 = v17 - 1;
      }
      while (__stlxr(v18, v16));
      if (!v18)
        cv::Mat::deallocate((cv::Mat *)__p, v14);
    }
    v32 = 0;
    v34 = 0;
    v35 = 0;
    v36 = 0;
    if (SHIDWORD(__p[0]) >= 1)
    {
      v19 = 0;
      v20 = v37;
      do
        *(_DWORD *)(v20 + 4 * v19++) = 0;
      while (v19 < SHIDWORD(__p[0]));
    }
    v33 = 0;
    if (v38 != (cv *)&v39)
      cv::fastFree((void **)v38, v14);
    v21 = v41;
    if (v41)
    {
      do
      {
        v22 = __ldaxr(v21);
        v23 = v22 - 1;
      }
      while (__stlxr(v23, v21));
      if (!v23)
        cv::Mat::deallocate((cv::Mat *)v40, v14);
    }
    v40[2] = 0;
    v42 = 0;
    v43 = 0;
    v44 = 0;
    if (SHIDWORD(v40[0]) >= 1)
    {
      v24 = 0;
      v25 = v45;
      do
        *(_DWORD *)(v25 + 4 * v24++) = 0;
      while (v24 < SHIDWORD(v40[0]));
    }
    v41 = 0;
    if (v46 != (cv *)&v47)
      cv::fastFree((void **)v46, v14);
  }
  return v12;
}

void sub_219E7C368(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,void *a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,void *a55)
{
  void *v56;
  void *v57;

  cv::Exception::~Exception((cv::Exception *)&a28);
  if (a15 < 0)
    operator delete(__p);
  if (a21 < 0)
    operator delete(a16);
  if (a27 < 0)
    operator delete(a22);
  cv::Mat::~Mat((cv::Mat *)&a43, v56);
  cv::Mat::~Mat((cv::Mat *)&a55, v57);
  _Unwind_Resume(a1);
}

uint64_t cvInitNArrayIterator(unsigned int a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _DWORD *v9;
  uint64_t v10;
  const cv::Exception *v11;
  const cv::Exception *v12;
  const cv::Exception *v13;
  unint64_t v14;
  _DWORD *v15;
  int v16;
  _DWORD *v17;
  _DWORD *MatND;
  const cv::Exception *v19;
  uint64_t v20;
  _QWORD *v21;
  const cv::Exception *v22;
  const cv::Exception *v23;
  const cv::Exception *v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  const cv::Exception *v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  const cv::Exception *v36;
  const cv::Exception *v37;
  const cv::Exception *v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t result;
  int *v43;
  _DWORD *v44;
  uint64_t v45;
  int v46;
  int v50;
  uint64_t v51;
  unint64_t v52;
  int v53;
  void *__p[2];
  void *v55[2];
  void *v56[2];
  _BYTE v57[128];

  v6 = a6;
  v7 = a5;
  v8 = a4;
  v9 = a3;
  v10 = a2;
  if (a1 - 11 <= 0xFFFFFFF5)
  {
    std::string::basic_string[abi:ne180100]<0>(v56, "Incorrect number of arrays");
    std::string::basic_string[abi:ne180100]<0>(v55, "cvInitNArrayIterator");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v57, 4294967085, v56, v55, __p, 386);
    cv::error((cv *)v57, v11);
  }
  if (!a2 || !a4)
  {
    std::string::basic_string[abi:ne180100]<0>(v56, "Some of required array pointers is NULL");
    std::string::basic_string[abi:ne180100]<0>(v55, "cvInitNArrayIterator");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v57, 4294967269, v56, v55, __p, 389);
    cv::error((cv *)v57, v12);
  }
  if (!a5)
  {
    std::string::basic_string[abi:ne180100]<0>(v56, "Iterator pointer is NULL");
    std::string::basic_string[abi:ne180100]<0>(v55, "cvInitNArrayIterator");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v57, 4294967269, v56, v55, __p, 392);
    cv::error((cv *)v57, v13);
  }
  if ((a1 & 0x80000000) != 0)
  {
    v15 = 0;
    v16 = -1;
  }
  else
  {
    v14 = 0;
    v15 = 0;
    v50 = a6 & 3;
    v51 = a1 + 1;
    v52 = a1;
    v16 = -1;
    do
    {
      v17 = v15;
      if (v14 >= v52)
      {
        MatND = v9;
        if (!v9)
          break;
      }
      else
      {
        MatND = *(_DWORD **)(v10 + 8 * v14);
        if (!MatND)
        {
          std::string::basic_string[abi:ne180100]<0>(v56, "Some of required array pointers is NULL");
          std::string::basic_string[abi:ne180100]<0>(v55, "cvInitNArrayIterator");
          std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
          cv::Exception::Exception(v57, 4294967269, v56, v55, __p, 402);
          cv::error((cv *)v57, v38);
        }
      }
      if (*((_WORD *)MatND + 1) != 16963 || !*((_QWORD *)MatND + 3))
      {
        v53 = 0;
        MatND = cvGetMatND((uint64_t)MatND, v8 + 288 * v14, &v53);
        if (v53)
        {
          std::string::basic_string[abi:ne180100]<0>(v56, "COI set is not allowed here");
          std::string::basic_string[abi:ne180100]<0>(v55, "cvInitNArrayIterator");
          std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
          cv::Exception::Exception(v57, 4294967272, v56, v55, __p, 413);
          cv::error((cv *)v57, v19);
        }
      }
      v20 = v7 + 8 * v14;
      *(_QWORD *)(v20 + 224) = MatND;
      v21 = (_QWORD *)(v20 + 224);
      v15 = MatND;
      if (v14)
      {
        if (MatND[1] != v17[1])
        {
          std::string::basic_string[abi:ne180100]<0>(v56, "Number of dimensions is the same for all arrays");
          std::string::basic_string[abi:ne180100]<0>(v55, "cvInitNArrayIterator");
          std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
          cv::Exception::Exception(v57, 4294967087, v56, v55, __p, 422);
          cv::error((cv *)v57, v22);
        }
        if (v14 >= v52)
        {
          if ((*(_WORD *)MatND & 0xFFE) != 0)
          {
            std::string::basic_string[abi:ne180100]<0>(v56, "Mask should have 8uC1 or 8sC1 data type");
            std::string::basic_string[abi:ne180100]<0>(v55, "cvInitNArrayIterator");
            std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
            cv::Exception::Exception(v57, 4294967088, v56, v55, __p, 448);
            cv::error((cv *)v57, v24);
          }
        }
        else if (v50 == 2)
        {
          if (((*v17 ^ *MatND) & 0xFF8) != 0)
          {
            std::string::basic_string[abi:ne180100]<0>(v56, "Depth is not the same for all arrays");
            std::string::basic_string[abi:ne180100]<0>(v55, "cvInitNArrayIterator");
            std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
            cv::Exception::Exception(v57, 4294967091, v56, v55, __p, 441);
            cv::error((cv *)v57, v36);
          }
        }
        else if (v50 == 1)
        {
          if (((*v17 ^ *MatND) & 0xFF8) != 0)
          {
            std::string::basic_string[abi:ne180100]<0>(v56, "Number of channels is not the same for all arrays");
            std::string::basic_string[abi:ne180100]<0>(v55, "cvInitNArrayIterator");
            std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
            cv::Exception::Exception(v57, 4294967091, v56, v55, __p, 436);
            cv::error((cv *)v57, v37);
          }
        }
        else if (!v50 && ((*v17 ^ *MatND) & 0xFFF) != 0)
        {
          std::string::basic_string[abi:ne180100]<0>(v56, "Data type is not the same for all arrays");
          std::string::basic_string[abi:ne180100]<0>(v55, "cvInitNArrayIterator");
          std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
          cv::Exception::Exception(v57, 4294967091, v56, v55, __p, 431);
          cv::error((cv *)v57, v23);
        }
        if ((v6 & 4) != 0 || (v25 = MatND[1], v25 < 1))
        {
          v15 = v17;
        }
        else
        {
          v26 = v8;
          v27 = v6;
          v28 = v7;
          v29 = 0;
          v30 = 8;
          do
          {
            if (MatND[v30] != v17[v30])
            {
              std::string::basic_string[abi:ne180100]<0>(v56, "Dimension sizes are the same for all arrays");
              std::string::basic_string[abi:ne180100]<0>(v55, "cvInitNArrayIterator");
              std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
              cv::Exception::Exception(v57, 4294967087, v56, v55, __p, 456);
              cv::error((cv *)v57, v31);
            }
            ++v29;
            v30 += 2;
          }
          while (v29 < v25);
          v15 = v17;
          v7 = v28;
          v6 = v27;
          v8 = v26;
          v10 = a2;
          v9 = a3;
        }
      }
      v32 = MatND[1];
      v33 = (((*MatND >> 3) & 0x1FFu) + 1) << ((0xFA50u >> (2 * (*(_BYTE *)MatND & 7))) & 3);
      v34 = (v32 - 1);
      if ((int)v34 > v16 && (_DWORD)v33 == MatND[2 * v34 + 9])
      {
        while (1)
        {
          v33 *= (int)MatND[2 * v34 + 8];
          v34 = (v32 - 2);
          if ((int)v34 <= v16)
            break;
          --v32;
          if (v33 != MatND[2 * v34 + 9])
          {
            LODWORD(v34) = v32 - 1;
            goto LABEL_43;
          }
        }
        v32 = v16 + 1;
        LODWORD(v34) = v16;
      }
LABEL_43:
      if (v33 <= 0x7FFFFFFF || (_DWORD)v34 != v16)
        v32 = v34;
      if (v32 > v16)
        v16 = v32;
      *v21 = MatND;
      *(_QWORD *)(v7 + 8 * v14++ + 16) = *((_QWORD *)MatND + 3);
    }
    while (v14 != v51);
  }
  v39 = v15[1] - 1;
  if (v39 <= v16)
  {
    v41 = 0x100000001;
  }
  else
  {
    LODWORD(v40) = 1;
    do
      v40 = (v15[2 * v39-- + 8] * v40);
    while (v39 > v16);
    v41 = v40 | 0x100000000;
  }
  result = (v16 + 1);
  *(_DWORD *)v7 = a1;
  *(_DWORD *)(v7 + 4) = result;
  *(_QWORD *)(v7 + 8) = v41;
  if ((v16 & 0x80000000) == 0)
  {
    v43 = v15 + 8;
    v44 = (_DWORD *)(v7 + 96);
    v45 = (v16 + 1);
    do
    {
      v46 = *v43;
      v43 += 2;
      *v44++ = v46;
      --v45;
    }
    while (v45);
  }
  return result;
}

void sub_219E7CD00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,char a34)
{
  cv::Exception::~Exception((cv::Exception *)&a34);
  if (a21 < 0)
    operator delete(__p);
  if (a27 < 0)
    operator delete(a22);
  if (a33 < 0)
    operator delete(a28);
  _Unwind_Resume(a1);
}

_DWORD *cvGetMatND(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  _DWORD *v4;
  const cv::Exception *v5;
  unsigned int v6;
  const cv::Exception *v7;
  _DWORD *Mat;
  const cv::Exception *v9;
  uint64_t v10;
  const cv::Exception *v11;
  unsigned int v12;
  void *v14[2];
  void *v15[2];
  void *__p[2];
  void *v17[2];
  _BYTE v18[120];

  v4 = (_DWORD *)a1;
  if (a3)
    *a3 = 0;
  if (!a1 || !a2)
  {
    std::string::basic_string[abi:ne180100]<0>(v15, "NULL array pointer is passed");
    std::string::basic_string[abi:ne180100]<0>(v17, "cvGetMatND");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v18, 4294967269, v15, v17, __p, 328);
    cv::error((cv *)v18, v5);
  }
  v6 = *(_DWORD *)a1;
  if (HIWORD(*(_DWORD *)a1) == 16963)
  {
    if (!*(_QWORD *)(a1 + 24))
    {
      std::string::basic_string[abi:ne180100]<0>(v15, "The matrix has NULL data pointer");
      std::string::basic_string[abi:ne180100]<0>(v17, "cvGetMatND");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
      cv::Exception::Exception(v18, 4294967269, v15, v17, __p, 333);
      cv::error((cv *)v18, v7);
    }
    return v4;
  }
  if (v6 == 144)
  {
    Mat = (_DWORD *)cvGetMat(a1, (uint64_t)v15, a3, 0);
    v4 = Mat;
    if (!Mat)
      goto LABEL_15;
    v6 = *Mat;
  }
  if (HIWORD(v6) != 16962 || (int)v4[9] < 1 || (int)v4[8] <= 0)
  {
LABEL_15:
    std::string::basic_string[abi:ne180100]<0>(v17, "Unrecognized or unsupported array type");
    std::string::basic_string[abi:ne180100]<0>(__p, "cvGetMatND");
    std::string::basic_string[abi:ne180100]<0>(v14, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v18, 4294967291, v17, __p, v14, 345);
    cv::error((cv *)v18, v9);
  }
  v10 = *((_QWORD *)v4 + 3);
  if (!v10)
  {
    std::string::basic_string[abi:ne180100]<0>(v17, "Input array has NULL data pointer");
    std::string::basic_string[abi:ne180100]<0>(__p, "cvGetMatND");
    std::string::basic_string[abi:ne180100]<0>(v14, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v18, 4294967269, v17, __p, v14, 348);
    cv::error((cv *)v18, v11);
  }
  *(_QWORD *)(a2 + 24) = v10;
  *(_QWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  v12 = *v4;
  *(_DWORD *)a2 = *v4;
  *(_DWORD *)(a2 + 4) = 2;
  *(_DWORD *)(a2 + 32) = v4[8];
  *(_DWORD *)(a2 + 36) = v4[1];
  *(_DWORD *)(a2 + 40) = v4[9];
  *(_DWORD *)(a2 + 44) = (((v12 >> 3) & 0x1FF) + 1) << ((0xFA50u >> (2 * (v12 & 7))) & 3);
  return (_DWORD *)a2;
}

void sub_219E7D144(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,char a36)
{
  cv::Exception::~Exception((cv::Exception *)&a36);
  if (a29 < 0)
    operator delete(__p);
  if (a35 < 0)
    operator delete(a30);
  if (a21 < 0)
    operator delete(a16);
  _Unwind_Resume(a1);
}

uint64_t cvNextNArraySlice(unsigned int *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  unsigned int *v6;
  _DWORD *v7;
  int v8;
  int v9;
  uint64_t v10;
  _QWORD *v11;

  if (!a1)
    cvNextNArraySlice_cold_1();
  v1 = a1[1];
  if ((int)v1 < 1)
    return 0;
  v2 = *a1;
  while (1)
  {
    v3 = (v1 - 1);
    if ((int)v2 >= 1)
    {
      v4 = v2;
      v5 = a1 + 56;
      do
      {
        *(v5 - 26) += *(int *)(*v5 + 8 * v3 + 36);
        ++v5;
        --v4;
      }
      while (v4);
    }
    v6 = &a1[v3];
    v8 = v6[24];
    v7 = v6 + 24;
    *v7 = v8 - 1;
    if (v8 > 1)
      break;
    v9 = *(_DWORD *)(*((_QWORD *)a1 + 28) + 8 * v3 + 32);
    if ((int)v2 >= 1)
    {
      v10 = v2;
      v11 = a1 + 56;
      do
      {
        *(v11 - 26) -= v9 * (uint64_t)*(int *)(*v11 + 8 * v3 + 36);
        ++v11;
        --v10;
      }
      while (v10);
    }
    *v7 = v9;
    if (v1-- <= 1)
      return 0;
  }
  return 1;
}

uint64_t cvCreateSparseMat(int a1, int *a2, unsigned int a3)
{
  unsigned int v6;
  const cv::Exception *v7;
  const cv::Exception *v8;
  const cv::Exception *v9;
  uint64_t v10;
  int *v11;
  int v12;
  const cv::Exception *v13;
  int v14;
  uint64_t v15;
  size_t v16;
  int v17;
  int v18;
  uint64_t MemStorage;
  void *v20;
  void *__p[2];
  void *v23[2];
  void *v24[2];
  _BYTE v25[120];

  v6 = (0x88442211 >> (4 * (a3 & 7))) & 0xF;
  if (!v6)
  {
    std::string::basic_string[abi:ne180100]<0>(v24, "invalid array data type");
    std::string::basic_string[abi:ne180100]<0>(v23, "cvCreateSparseMat");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v25, 4294967086, v24, v23, __p, 538);
    cv::error((cv *)v25, v7);
  }
  if ((a1 - 1025) <= 0xFFFFFBFF)
  {
    std::string::basic_string[abi:ne180100]<0>(v24, "bad number of dimensions");
    std::string::basic_string[abi:ne180100]<0>(v23, "cvCreateSparseMat");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v25, 4294967085, v24, v23, __p, 541);
    cv::error((cv *)v25, v8);
  }
  if (!a2)
  {
    std::string::basic_string[abi:ne180100]<0>(v24, "NULL <sizes> pointer");
    std::string::basic_string[abi:ne180100]<0>(v23, "cvCreateSparseMat");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v25, 4294967269, v24, v23, __p, 544);
    cv::error((cv *)v25, v9);
  }
  if (a1 >= 1)
  {
    v10 = a1;
    v11 = a2;
    do
    {
      v12 = *v11++;
      if (v12 <= 0)
      {
        std::string::basic_string[abi:ne180100]<0>(v24, "one of dimesion sizes is non-positive");
        std::string::basic_string[abi:ne180100]<0>(v23, "cvCreateSparseMat");
        std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
        cv::Exception::Exception(v25, 4294967095, v24, v23, __p, 549);
        cv::error((cv *)v25, v13);
      }
      --v10;
    }
    while (v10);
  }
  if (a1 <= 32)
    v14 = 32;
  else
    v14 = a1;
  v15 = cvAlloc(4 * (v14 - 32) + 184);
  *(_DWORD *)v15 = a3 & 0xFFF | 0x42440000;
  *(_DWORD *)(v15 + 4) = a1;
  *(_QWORD *)(v15 + 8) = 0;
  *(_DWORD *)(v15 + 16) = 1;
  v16 = 4 * a1;
  memcpy((void *)(v15 + 52), a2, v16);
  if ((v6 & (v6 - 1)) != 0)
    cvCreateMemStorage_cold_1();
  v17 = ((_WORD)v6 + (_WORD)v6 * ((a3 >> 3) & 0x1FF) + ((unsigned __int16)(v6 + 15) & (unsigned __int16)-(__int16)v6) + 3) & 0xFFFC;
  *(_DWORD *)(v15 + 44) = (v6 + 15) & -v6;
  *(_DWORD *)(v15 + 48) = v17;
  v18 = (v16 + v17 + 15) & 0xFFFFFFF0;
  MemStorage = cvCreateMemStorage(4096);
  *(_QWORD *)(v15 + 24) = cvCreateSet(0, 112, v18, MemStorage);
  *(_DWORD *)(v15 + 40) = 1024;
  v20 = (void *)cvAlloc(0x2000);
  *(_QWORD *)(v15 + 32) = v20;
  bzero(v20, 0x2000uLL);
  return v15;
}

void sub_219E7D698(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

void cvReleaseSparseMat(uint64_t *a1, void *a2)
{
  const cv::Exception *v2;
  uint64_t v3;
  const cv::Exception *v4;
  void *v5;
  void *v6;
  void *__p[2];
  void *v8[2];
  void *v9[2];
  void **v10[15];

  if (!a1)
  {
    std::string::basic_string[abi:ne180100]<0>(v9, "");
    std::string::basic_string[abi:ne180100]<0>(v8, "cvReleaseSparseMat");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v10, 4294967287, v9, v8, __p, 582);
    cv::error((cv *)v10, v2);
  }
  v3 = *a1;
  if (*a1)
  {
    if (*(_WORD *)(v3 + 2) != 16964)
    {
      std::string::basic_string[abi:ne180100]<0>(v9, "");
      std::string::basic_string[abi:ne180100]<0>(v8, "cvReleaseSparseMat");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
      cv::Exception::Exception(v10, 4294967090, v9, v8, __p, 589);
      cv::error((cv *)v10, v4);
    }
    *a1 = 0;
    v10[0] = *(void ***)(*(_QWORD *)(v3 + 24) + 72);
    cvReleaseMemStorage(v10, a2);
    cv::fastFree(*(void ***)(v3 + 32), v5);
    *(_QWORD *)(v3 + 32) = 0;
    cv::fastFree((void **)v3, v6);
  }
}

void sub_219E7D8A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

uint64_t cvCloneSparseMat(uint64_t a1)
{
  const cv::Exception *v2;
  uint64_t SparseMat;
  void *__p[2];
  void *v6[2];
  void *v7[2];
  _BYTE v8[120];

  if (!a1 || HIWORD(*(_DWORD *)a1) != 16964)
  {
    std::string::basic_string[abi:ne180100]<0>(v7, "Invalid sparse array header");
    std::string::basic_string[abi:ne180100]<0>(v6, "cvCloneSparseMat");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v8, 4294967291, v7, v6, __p, 606);
    cv::error((cv *)v8, v2);
  }
  SparseMat = cvCreateSparseMat(*(_DWORD *)(a1 + 4), (int *)(a1 + 52), *(_DWORD *)a1);
  cvCopy(a1, SparseMat, 0);
  return SparseMat;
}

void sub_219E7DA00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

uint64_t cvInitSparseMatIterator(uint64_t a1, uint64_t a2)
{
  const cv::Exception *v3;
  const cv::Exception *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  void *__p[2];
  void *v9[2];
  void *v10[2];
  _BYTE v11[120];

  if (!a1 || *(_WORD *)(a1 + 2) != 16964)
  {
    std::string::basic_string[abi:ne180100]<0>(v10, "Invalid sparse matrix header");
    std::string::basic_string[abi:ne180100]<0>(v9, "cvInitSparseMatIterator");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v11, 4294967291, v10, v9, __p, 621);
    cv::error((cv *)v11, v3);
  }
  if (!a2)
  {
    std::string::basic_string[abi:ne180100]<0>(v10, "NULL iterator pointer");
    std::string::basic_string[abi:ne180100]<0>(v9, "cvInitSparseMatIterator");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v11, 4294967269, v10, v9, __p, 624);
    cv::error((cv *)v11, v4);
  }
  *(_QWORD *)a2 = a1;
  *(_QWORD *)(a2 + 8) = 0;
  v5 = *(unsigned int *)(a1 + 40);
  if ((int)v5 < 1)
  {
    LODWORD(v6) = 0;
    result = 0;
  }
  else
  {
    v6 = 0;
    while (1)
    {
      result = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v6);
      if (result)
        break;
      if (v5 == ++v6)
      {
        result = 0;
        LODWORD(v6) = *(_DWORD *)(a1 + 40);
        goto LABEL_13;
      }
    }
    *(_QWORD *)(a2 + 8) = result;
  }
LABEL_13:
  *(_DWORD *)(a2 + 16) = v6;
  return result;
}

void sub_219E7DC08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

void cvReleaseData(uint64_t a1, void *a2)
{
  unsigned int v3;
  void **v4;
  _QWORD *v5;
  const cv::Exception *v7;
  void **v8;
  void *__p[2];
  void *v10[2];
  void *v11[2];
  _BYTE v12[120];

  if (!a1)
    goto LABEL_15;
  v3 = *(_DWORD *)a1 & 0xFFFF0000;
  if (v3 == 1111687168)
    goto LABEL_6;
  if (v3 != 1111621632)
  {
    if (*(_DWORD *)a1 == 144)
    {
      if (CvIPL)
      {
        CvIPL(a1, 2);
      }
      else
      {
        v8 = *(void ***)(a1 + 136);
        *(_QWORD *)(a1 + 136) = 0;
        *(_QWORD *)(a1 + 88) = 0;
        cv::fastFree(v8, a2);
      }
      return;
    }
LABEL_15:
    std::string::basic_string[abi:ne180100]<0>(v11, "unrecognized or unsupported array type");
    std::string::basic_string[abi:ne180100]<0>(v10, "cvReleaseData");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v12, 4294967291, v11, v10, __p, 996);
    cv::error((cv *)v12, v7);
  }
  if (*(int *)(a1 + 36) < 1 || *(int *)(a1 + 32) < 1)
    goto LABEL_15;
LABEL_6:
  if (*(_QWORD *)(a1 + 24))
  {
    v5 = (_QWORD *)(a1 + 8);
    v4 = *(void ***)(a1 + 8);
    v5[2] = 0;
    if (v4)
    {
      if ((*(_DWORD *)v4)-- == 1)
        cv::fastFree(v4, a2);
    }
    *v5 = 0;
  }
}

void sub_219E7DDD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

uint64_t cvPtr2D(uint64_t a1, unsigned int a2, unsigned int a3, int *a4)
{
  unsigned int v4;
  unsigned int v5;
  int v6;
  int v7;
  const cv::Exception *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  int *v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  const cv::Exception *v17;
  uint64_t v18;
  const cv::Exception *v19;
  int v20;
  const cv::Exception *v21;
  const cv::Exception *v23;
  int v24;
  const cv::Exception *v25;
  void *__p[2];
  void *v27[2];
  void *v28[2];
  _DWORD __src[30];
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  if (!a1)
    goto LABEL_30;
  v4 = *(_DWORD *)a1;
  v5 = *(_DWORD *)a1 & 0xFFFF0000;
  if (v5 == 1111621632)
  {
    v6 = *(_DWORD *)(a1 + 36);
    if (v6 >= 1)
    {
      v7 = *(_DWORD *)(a1 + 32);
      if (v7 >= 1)
      {
        if (*(_QWORD *)(a1 + 24))
        {
          if (v6 <= a3 || v7 <= a2)
          {
            std::string::basic_string[abi:ne180100]<0>(v28, "index is out of range");
            std::string::basic_string[abi:ne180100]<0>(v27, "cvPtr2D");
            std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
            cv::Exception::Exception(__src, 4294967085, v28, v27, __p, 1754);
            cv::error((cv *)__src, v8);
          }
          if (a4)
            *a4 = *(_DWORD *)a1 & 0xFFF;
          return *(_QWORD *)(a1 + 24)
               + *(int *)(a1 + 4) * (uint64_t)(int)a2
               + (int)(((((v4 >> 3) & 0x1FF) + 1) << ((0xFA50u >> (2 * (v4 & 7))) & 3)) * a3);
        }
      }
    }
LABEL_30:
    std::string::basic_string[abi:ne180100]<0>(v28, "unrecognized or unsupported array type");
    std::string::basic_string[abi:ne180100]<0>(v27, "cvPtr2D");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(__src, 4294967291, v28, v27, __p, 1830);
    cv::error((cv *)__src, v21);
  }
  if (v4 == 144)
  {
    v10 = *(_QWORD *)(a1 + 88);
    if (!v10)
      goto LABEL_30;
    v11 = *(_DWORD *)(a1 + 16) >> 3;
    v12 = *(_DWORD *)(a1 + 28);
    if (!v12)
      v11 *= *(_DWORD *)(a1 + 8);
    v13 = *(int **)(a1 + 48);
    if (v13)
    {
      v14 = v13[3];
      v15 = v13[4];
      v10 += *(_DWORD *)(a1 + 96) * v13[2] + v13[1] * v11;
      if (v12)
      {
        v16 = *v13;
        if (!(_DWORD)v16)
        {
          std::string::basic_string[abi:ne180100]<0>(v28, "COI must be non-null in case of planar images");
          std::string::basic_string[abi:ne180100]<0>(v27, "cvPtr2D");
          std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
          cv::Exception::Exception(__src, 4294967272, v28, v27, __p, 1785);
          cv::error((cv *)__src, v17);
        }
        v10 += *(int *)(a1 + 80) * (v16 - 1);
      }
    }
    else
    {
      v14 = *(_DWORD *)(a1 + 40);
      v15 = *(_DWORD *)(a1 + 44);
    }
    if (v15 <= a2 || v14 <= a3)
    {
      std::string::basic_string[abi:ne180100]<0>(v28, "index is out of range");
      std::string::basic_string[abi:ne180100]<0>(v27, "cvPtr2D");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
      cv::Exception::Exception(__src, 4294967085, v28, v27, __p, 1797);
      cv::error((cv *)__src, v23);
    }
    v9 = v10 + (int)(v11 * a3 + *(_DWORD *)(a1 + 96) * a2);
    if (a4)
    {
      v24 = *(_DWORD *)(a1 + 8);
      if ((v24 - 5) <= 0xFFFFFFFB)
      {
        std::string::basic_string[abi:ne180100]<0>(v28, "");
        std::string::basic_string[abi:ne180100]<0>(v27, "cvPtr2D");
        std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
        cv::Exception::Exception(__src, 4294967086, v28, v27, __p, 1805);
        cv::error((cv *)__src, v25);
      }
      v20 = ((0x43160520u >> (((*(_DWORD *)(a1 + 16) >> 2) & 0x3C) + ((*(int *)(a1 + 16) >> 31) & 0x14))) & 7 | (8 * v24))
          - 8;
      goto LABEL_41;
    }
  }
  else
  {
    if (v5 == 1111752704)
    {
      __src[0] = a2;
      __src[1] = a3;
      return icvGetNodePtr(a1, __src, a4, 1, 0);
    }
    if (v5 != 1111687168)
      goto LABEL_30;
    v18 = *(_QWORD *)(a1 + 24);
    if (!v18)
      goto LABEL_30;
    if (*(_DWORD *)(a1 + 4) != 2 || *(_DWORD *)(a1 + 32) <= a2 || *(_DWORD *)(a1 + 40) <= a3)
    {
      std::string::basic_string[abi:ne180100]<0>(v28, "index is out of range");
      std::string::basic_string[abi:ne180100]<0>(v27, "cvPtr2D");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
      cv::Exception::Exception(__src, 4294967085, v28, v27, __p, 1817);
      cv::error((cv *)__src, v19);
    }
    v9 = v18 + *(int *)(a1 + 36) * (uint64_t)(int)a2 + *(int *)(a1 + 44) * (uint64_t)(int)a3;
    if (a4)
    {
      v20 = *(_DWORD *)a1 & 0xFFF;
LABEL_41:
      *a4 = v20;
    }
  }
  return v9;
}

void sub_219E7E3F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,char a28)
{
  cv::Exception::~Exception((cv::Exception *)&a28);
  if (a15 < 0)
    operator delete(__p);
  if (a21 < 0)
    operator delete(a16);
  if (a27 < 0)
    operator delete(a22);
  _Unwind_Resume(a1);
}

uint64_t cvGetElemType(int *a1)
{
  int v1;
  unsigned int v2;
  const cv::Exception *v5;
  void *__p[2];
  void *v7[2];
  void *v8[2];
  _BYTE v9[120];

  if (!a1)
    goto LABEL_15;
  v1 = *a1;
  v2 = *a1 & 0xFFFF0000;
  if (v2 == 1111752704 || v2 == 1111687168)
    return v1 & 0xFFF;
  if (v2 == 1111621632)
  {
    if (a1[9] < 1 || a1[8] < 1)
      goto LABEL_15;
    return v1 & 0xFFF;
  }
  if (v1 != 144 || !*((_QWORD *)a1 + 11))
  {
LABEL_15:
    std::string::basic_string[abi:ne180100]<0>(v8, "unrecognized or unsupported array type");
    std::string::basic_string[abi:ne180100]<0>(v7, "cvGetElemType");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v9, 4294967291, v8, v7, __p, 1086);
    cv::error((cv *)v9, v5);
  }
  return ((0x43160520u >> (((a1[4] >> 2) & 0x3C) + ((a1[4] >> 31) & 0x14))) & 7 | (8 * a1[2])) - 8;
}

void sub_219E7E5E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

uint64_t cvGetDims(uint64_t a1, int *__dst)
{
  unsigned int v2;
  int v3;
  int v4;
  uint64_t v5;
  int *v6;
  uint64_t v7;
  int v8;
  const cv::Exception *v9;
  void *__p[2];
  void *v12[2];
  void *v13[2];
  _BYTE v14[120];

  if (!a1)
    goto LABEL_20;
  v2 = *(_DWORD *)a1 & 0xFFFF0000;
  if (v2 == 1111621632)
  {
    if (*(int *)(a1 + 36) >= 1)
    {
      v3 = *(_DWORD *)(a1 + 32);
      if (v3 >= 1)
      {
        if (__dst)
        {
          *__dst = v3;
          v4 = *(_DWORD *)(a1 + 36);
LABEL_11:
          __dst[1] = v4;
          return 2;
        }
        return 2;
      }
    }
    goto LABEL_20;
  }
  if (*(_DWORD *)a1 == 144)
  {
    if (*(_QWORD *)(a1 + 88))
    {
      if (__dst)
      {
        *__dst = *(_DWORD *)(a1 + 44);
        v4 = *(_DWORD *)(a1 + 40);
        goto LABEL_11;
      }
      return 2;
    }
LABEL_20:
    std::string::basic_string[abi:ne180100]<0>(v13, "unrecognized or unsupported array type");
    std::string::basic_string[abi:ne180100]<0>(v12, "cvGetDims");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v14, 4294967291, v13, v12, __p, 1140);
    cv::error((cv *)v14, v9);
  }
  if (v2 == 1111752704)
  {
    v5 = *(unsigned int *)(a1 + 4);
    if (__dst)
      memcpy(__dst, (const void *)(a1 + 52), 4 * (int)v5);
  }
  else
  {
    if (v2 != 1111687168)
      goto LABEL_20;
    v5 = *(unsigned int *)(a1 + 4);
    if (__dst && (int)v5 >= 1)
    {
      v6 = (int *)(a1 + 32);
      v7 = *(unsigned int *)(a1 + 4);
      do
      {
        v8 = *v6;
        v6 += 2;
        *__dst++ = v8;
        --v7;
      }
      while (v7);
    }
  }
  return v5;
}

void sub_219E7E7CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

unint64_t cvGetSize(uint64_t a1)
{
  unsigned int v1;
  uint64_t v2;
  uint64_t v3;
  unsigned int *v4;
  unsigned int *v5;
  const cv::Exception *v6;
  void *__p[2];
  void *v9[2];
  void *v10[2];
  _BYTE v11[120];

  if (!a1)
  {
LABEL_11:
    std::string::basic_string[abi:ne180100]<0>(v10, "Array should be CvMat or IplImage");
    std::string::basic_string[abi:ne180100]<0>(v9, "cvGetSize");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v11, 4294967291, v10, v9, __p, 1238);
    cv::error((cv *)v11, v6);
  }
  if (HIWORD(*(_DWORD *)a1) == 16962)
  {
    v1 = *(_DWORD *)(a1 + 36);
    if ((v1 & 0x80000000) != 0)
      goto LABEL_11;
    v2 = *(unsigned int *)(a1 + 32);
    if ((v2 & 0x80000000) != 0)
      goto LABEL_11;
  }
  else
  {
    if (*(_DWORD *)a1 != 144)
      goto LABEL_11;
    v3 = *(_QWORD *)(a1 + 48);
    v4 = (unsigned int *)(v3 + 16);
    if (v3)
    {
      v5 = (unsigned int *)(v3 + 12);
    }
    else
    {
      v4 = (unsigned int *)(a1 + 44);
      v5 = (unsigned int *)(a1 + 40);
    }
    v1 = *v5;
    v2 = *v4;
  }
  return v1 | (unint64_t)(v2 << 32);
}

void sub_219E7E940(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

uint64_t cvGetMat(uint64_t a1, uint64_t a2, _DWORD *a3, int a4)
{
  uint64_t v6;
  const cv::Exception *v7;
  unsigned int v8;
  unsigned int v9;
  const cv::Exception *v10;
  const cv::Exception *v11;
  unsigned int v12;
  int v13;
  int v14;
  int *v15;
  const cv::Exception *v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  int v23;
  const cv::Exception *v24;
  int v25;
  const cv::Exception *v27;
  const cv::Exception *v28;
  uint64_t v29;
  int *v30;
  uint64_t v31;
  int v32;
  unsigned int v33;
  int v34;
  const cv::Exception *v35;
  const cv::Exception *v36;
  void *__p[2];
  void *v38[2];
  void *v39[2];
  _BYTE v40[120];

  v6 = a1;
  if (!a1 || !a2)
  {
    std::string::basic_string[abi:ne180100]<0>(v39, "NULL array pointer is passed");
    std::string::basic_string[abi:ne180100]<0>(v38, "cvGetMat");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v40, 4294967269, v39, v38, __p, 2382);
    cv::error((cv *)v40, v7);
  }
  v8 = *(_DWORD *)a1;
  v9 = *(_DWORD *)a1 & 0xFFFF0000;
  if (v9 != 1111621632)
  {
    if (v8 == 144)
    {
      if (!*(_QWORD *)(a1 + 88))
      {
        std::string::basic_string[abi:ne180100]<0>(v39, "The image has NULL data pointer");
        std::string::basic_string[abi:ne180100]<0>(v38, "cvGetMat");
        std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
        cv::Exception::Exception(v40, 4294967269, v39, v38, __p, 2397);
        cv::error((cv *)v40, v11);
      }
      v12 = (0x43160520u >> (((*(_DWORD *)(a1 + 16) >> 2) & 0x3C) + ((*(int *)(a1 + 16) >> 31) & 0x14))) & 7;
      v13 = *(_DWORD *)(a1 + 8);
      if (v13 <= 1)
        v14 = 0;
      else
        v14 = *(_DWORD *)(a1 + 28);
      v15 = *(int **)(a1 + 48);
      if (v15)
      {
        if (v14 != 1)
        {
          v25 = *v15;
          if (v13 >= 513)
          {
            std::string::basic_string[abi:ne180100]<0>(v39, "The image is interleaved and has over CV_CN_MAX channels");
            std::string::basic_string[abi:ne180100]<0>(v38, "cvGetMat");
            std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
            cv::Exception::Exception(v40, 4294967281, v39, v38, __p, 2429);
            cv::error((cv *)v40, v36);
          }
          cvInitMatHeader(a2, v15[4], v15[3], v12 | (8 * v13 - 8), *(_QWORD *)(a1 + 88)+ *(int *)(a1 + 96) * (uint64_t)v15[2]+ v15[1] * (uint64_t)(int)(((((8 * v13 - 8) >> 3) & 0x1FF) + 1) << ((0xFA50u >> (2 * v12)) & 3)), *(_DWORD *)(a1 + 96));
LABEL_49:
          v6 = a2;
          if (!a3)
            return v6;
          goto LABEL_27;
        }
        if (!*v15)
        {
          std::string::basic_string[abi:ne180100]<0>(v39, "Images with planar data layout should be used with COI selected");
          std::string::basic_string[abi:ne180100]<0>(v38, "cvGetMat");
          std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
          cv::Exception::Exception(v40, 4294967090, v39, v38, __p, 2413);
          cv::error((cv *)v40, v16);
        }
        v18 = v15[3];
        v17 = v15[4];
        v19 = *(_DWORD *)(a1 + 96);
        v20 = *(_QWORD *)(a1 + 88)
            + (*v15 - 1) * *(int *)(a1 + 80)
            + v19 * (uint64_t)v15[2]
            + ((uint64_t)v15[1] << ((0xFA50u >> (2 * v12)) & 3));
        v21 = a2;
        v22 = v12;
      }
      else
      {
        if (v14)
        {
          std::string::basic_string[abi:ne180100]<0>(v39, "Pixel order should be used with coi == 0");
          std::string::basic_string[abi:ne180100]<0>(v38, "cvGetMat");
          std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
          cv::Exception::Exception(v40, 4294967090, v39, v38, __p, 2443);
          cv::error((cv *)v40, v35);
        }
        v22 = (v12 | (8 * v13)) - 8;
        v18 = *(_DWORD *)(a1 + 40);
        v17 = *(_DWORD *)(a1 + 44);
        v20 = *(_QWORD *)(a1 + 88);
        v19 = *(_DWORD *)(a1 + 96);
        v21 = a2;
      }
      cvInitMatHeader(v21, v17, v18, v22, v20, v19);
LABEL_45:
      v25 = 0;
      goto LABEL_49;
    }
LABEL_20:
    if (!a4 || v9 != 1111687168)
    {
      std::string::basic_string[abi:ne180100]<0>(v39, "Unrecognized or unsupported array type");
      std::string::basic_string[abi:ne180100]<0>(v38, "cvGetMat");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
      cv::Exception::Exception(v40, 4294967090, v39, v38, __p, 2482);
      cv::error((cv *)v40, v24);
    }
    v23 = *(_DWORD *)(a1 + 32);
    if (!*(_QWORD *)(a1 + 24))
    {
      std::string::basic_string[abi:ne180100]<0>(v39, "Input array has NULL data pointer");
      std::string::basic_string[abi:ne180100]<0>(v38, "cvGetMat");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
      cv::Exception::Exception(v40, 4294967269, v39, v38, __p, 2458);
      cv::error((cv *)v40, v27);
    }
    if ((v8 & 0x4000) == 0)
    {
      std::string::basic_string[abi:ne180100]<0>(v39, "Only continuous nD arrays are supported here");
      std::string::basic_string[abi:ne180100]<0>(v38, "cvGetMat");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
      cv::Exception::Exception(v40, 4294967291, v39, v38, __p, 2461);
      cv::error((cv *)v40, v28);
    }
    v29 = *(unsigned int *)(a1 + 4);
    if ((int)v29 < 3)
    {
      if ((_DWORD)v29 != 1)
        LODWORD(v29) = *(_DWORD *)(a1 + 40);
    }
    else
    {
      v30 = (int *)(a1 + 40);
      v31 = v29 - 1;
      LODWORD(v29) = 1;
      do
      {
        v32 = *v30;
        v30 += 2;
        LODWORD(v29) = v32 * v29;
        --v31;
      }
      while (v31);
    }
    *(_QWORD *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 16) = 0;
    *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
    *(_DWORD *)(a2 + 32) = v23;
    *(_DWORD *)(a2 + 36) = v29;
    v33 = *(_DWORD *)a1;
    v34 = ((((v33 >> 3) & 0x1FF) + 1) << ((0xFA50u >> (2 * (v33 & 7))) & 3)) * v29;
    if (v23 <= 1)
      v34 = 0;
    *(_DWORD *)a2 = *(_DWORD *)a1 & 0xFFF | 0x42424000;
    *(_DWORD *)(a2 + 4) = v34;
    if (v23 * (uint64_t)v34 >= 0x80000000)
    {
      v25 = 0;
      *(_DWORD *)a2 = v33 & 0xFFF | 0x42420000;
      goto LABEL_49;
    }
    goto LABEL_45;
  }
  if (*(int *)(a1 + 36) < 1 || *(int *)(a1 + 32) < 1)
    goto LABEL_20;
  if (!*(_QWORD *)(a1 + 24))
  {
    std::string::basic_string[abi:ne180100]<0>(v39, "The matrix has NULL data pointer");
    std::string::basic_string[abi:ne180100]<0>(v38, "cvGetMat");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v40, 4294967269, v39, v38, __p, 2387);
    cv::error((cv *)v40, v10);
  }
  v25 = 0;
  if (a3)
LABEL_27:
    *a3 = v25;
  return v6;
}

void sub_219E7F150(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

uint64_t icvGetNodePtr(uint64_t a1, _DWORD *__src, int *a3, int a4, int *a5)
{
  unsigned int v7;
  int v8;
  uint64_t v9;
  unsigned int v10;
  const cv::Exception *v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  void *v22;
  uint64_t inited;
  void *v24;
  int v25;
  uint64_t i;
  unsigned int v27;
  int v28;
  int v29;
  uint64_t *v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  void *__p[2];
  void *v38[2];
  void *v39[2];
  uint64_t v40;
  uint64_t v41;
  int v42;

  if (*(_WORD *)(a1 + 2) != 16964)
    icvGetNodePtr();
  if (a5)
  {
    v7 = *a5;
  }
  else
  {
    v8 = *(_DWORD *)(a1 + 4);
    if (v8 < 1)
    {
      v7 = 0;
    }
    else
    {
      v9 = 0;
      v7 = 0;
      do
      {
        v10 = __src[v9];
        if (v10 >= *(_DWORD *)(a1 + 52 + 4 * v9))
        {
          std::string::basic_string[abi:ne180100]<0>(v39, "One of indices is out of range");
          std::string::basic_string[abi:ne180100]<0>(v38, "icvGetNodePtr");
          std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
          cv::Exception::Exception(&v40, 4294967085, v39, v38, __p, 658);
          cv::error((cv *)&v40, v11);
        }
        v7 = v10 + 1540483477 * v7;
        ++v9;
      }
      while (v9 < v8);
    }
  }
  v12 = *(_DWORD *)(a1 + 40);
  v13 = (v12 - 1) & v7;
  v14 = v7 & 0x7FFFFFFF;
  if (a4 < -1 || (v15 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v13)) == 0)
  {
LABEL_22:
    v18 = 0;
    if (!a4)
      goto LABEL_46;
    goto LABEL_25;
  }
  while (1)
  {
    if (*(_DWORD *)v15 == v14)
    {
      v16 = *(unsigned int *)(a1 + 4);
      if ((int)v16 < 1)
      {
        LODWORD(v17) = 0;
      }
      else
      {
        v17 = 0;
        while (__src[v17] == *(_DWORD *)(v15 + *(int *)(a1 + 48) + 4 * v17))
        {
          if (v16 == ++v17)
            goto LABEL_24;
        }
      }
      if ((_DWORD)v17 == (_DWORD)v16)
        break;
    }
    v15 = *(_QWORD *)(v15 + 8);
    if (!v15)
      goto LABEL_22;
  }
LABEL_24:
  v18 = v15 + *(int *)(a1 + 44);
  if (a4)
  {
LABEL_25:
    if (!v18)
    {
      v19 = *(_QWORD *)(a1 + 24);
      if (*(_DWORD *)(v19 + 104) >= 3 * v12)
      {
        if (v12 >= 512)
          v20 = 2 * v12;
        else
          v20 = 1024;
        v21 = v20 - 1;
        if ((v20 & (v20 - 1)) != 0)
          icvGetNodePtr();
        v22 = (void *)cvAlloc(8 * v20);
        bzero(v22, 8 * v20);
        inited = cvInitSparseMatIterator(a1, (uint64_t)&v40);
        if (inited)
        {
          v25 = v42;
          for (i = v41; ; inited = i)
          {
            i = *(_QWORD *)(i + 8);
            if (!i)
            {
              v28 = v25 + 1;
              v29 = *(_DWORD *)(v40 + 40);
              if (v25 + 1 >= v29)
              {
LABEL_39:
                v42 = v28;
                v31 = *(_DWORD *)inited & v21;
                *(_QWORD *)(inited + 8) = *((_QWORD *)v22 + v31);
                *((_QWORD *)v22 + v31) = inited;
                break;
              }
              v30 = (uint64_t *)(*(_QWORD *)(v40 + 32) + 8 * v25++ + 8);
              while (1)
              {
                i = *v30;
                if (*v30)
                  break;
                ++v25;
                ++v30;
                if (v29 == v25)
                  goto LABEL_39;
              }
            }
            v41 = i;
            v27 = *(_DWORD *)inited & v21;
            *(_QWORD *)(inited + 8) = *((_QWORD *)v22 + v27);
            *((_QWORD *)v22 + v27) = inited;
          }
        }
        cv::fastFree(*(void ***)(a1 + 32), v24);
        *(_QWORD *)(a1 + 32) = v22;
        *(_DWORD *)(a1 + 40) = v20;
        v13 = v21 & v14;
        v19 = *(_QWORD *)(a1 + 24);
      }
      v32 = *(_QWORD *)(v19 + 96);
      v40 = v32;
      if (v32)
      {
        *(_QWORD *)(v19 + 96) = *(_QWORD *)(v32 + 8);
        *(_DWORD *)v32 &= 0x3FFFFFFu;
        ++*(_DWORD *)(v19 + 104);
      }
      else
      {
        cvSetAdd(v19, 0, &v40);
        v32 = v40;
      }
      *(_DWORD *)v32 = v14;
      v33 = *(_QWORD *)(a1 + 32);
      *(_QWORD *)(v32 + 8) = *(_QWORD *)(v33 + 8 * v13);
      *(_QWORD *)(v33 + 8 * v13) = v32;
      memcpy((void *)(v32 + *(int *)(a1 + 48)), __src, 4 * *(int *)(a1 + 4));
      v18 = v32 + *(int *)(a1 + 44);
      if (a4 >= 1)
        bzero((void *)(v32 + *(int *)(a1 + 44)), (((*(_DWORD *)a1 >> 3) & 0x1FFu) + 1) << ((0xFA50u >> (2 * (*(_BYTE *)a1 & 7))) & 3));
    }
  }
LABEL_46:
  if (a3)
    *a3 = *(_DWORD *)a1 & 0xFFF;
  return v18;
}

void sub_219E7F5D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,char a30)
{
  cv::Exception::~Exception((cv::Exception *)&a30);
  if (a17 < 0)
    operator delete(__p);
  if (a23 < 0)
    operator delete(a18);
  if (a29 < 0)
    operator delete(a24);
  _Unwind_Resume(a1);
}

uint64_t cvPtrND(uint64_t a1, unsigned int *__src, int *a3, int a4, int *a5)
{
  const cv::Exception *v5;
  unsigned int v6;
  uint64_t v8;
  int v9;
  uint64_t v10;
  int *v11;
  unsigned int v12;
  const cv::Exception *v13;
  int v14;
  const cv::Exception *v15;
  void *__p[2];
  void *v18[2];
  void *v19[2];
  _BYTE v20[120];

  if (!__src)
  {
    std::string::basic_string[abi:ne180100]<0>(v19, "NULL pointer to indices");
    std::string::basic_string[abi:ne180100]<0>(v18, "cvPtrND");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v20, 4294967269, v19, v18, __p, 1879);
    cv::error((cv *)v20, v5);
  }
  if (!a1)
    goto LABEL_22;
  v6 = *(_DWORD *)a1 & 0xFFFF0000;
  if (v6 == 1111621632)
  {
    if (*(int *)(a1 + 36) >= 1 && *(int *)(a1 + 32) > 0)
      return cvPtr2D(a1, *__src, __src[1], a3);
    goto LABEL_22;
  }
  if (v6 != 1111687168)
  {
    if (v6 == 1111752704)
      return icvGetNodePtr(a1, __src, a3, a4, a5);
    if (*(_DWORD *)a1 == 144)
      return cvPtr2D(a1, *__src, __src[1], a3);
LABEL_22:
    std::string::basic_string[abi:ne180100]<0>(v19, "unrecognized or unsupported array type");
    std::string::basic_string[abi:ne180100]<0>(v18, "cvPtrND");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v20, 4294967291, v19, v18, __p, 1903);
    cv::error((cv *)v20, v15);
  }
  v8 = *(_QWORD *)(a1 + 24);
  if (!v8)
    goto LABEL_22;
  v9 = *(_DWORD *)(a1 + 4);
  if (v9 >= 1)
  {
    v10 = 0;
    v11 = (int *)(a1 + 36);
    do
    {
      v12 = __src[v10];
      if (v12 >= *(v11 - 1))
      {
        std::string::basic_string[abi:ne180100]<0>(v19, "index is out of range");
        std::string::basic_string[abi:ne180100]<0>(v18, "cvPtrND");
        std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
        cv::Exception::Exception(v20, 4294967085, v19, v18, __p, 1893);
        cv::error((cv *)v20, v13);
      }
      v14 = *v11;
      v11 += 2;
      v8 += v14 * (uint64_t)(int)v12;
      ++v10;
    }
    while (v10 < v9);
  }
  if (a3)
    *a3 = *(_DWORD *)a1 & 0xFFF;
  return v8;
}

void sub_219E7F92C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

uint64_t cvInitImageHeader(uint64_t a1, uint64_t a2, int a3, int a4, unsigned int a5, int a6)
{
  const cv::Exception *v12;
  char **v13;
  const char *v14;
  const char *v15;
  const cv::Exception *v16;
  int v17;
  _BOOL4 v22;
  const cv::Exception *v23;
  const cv::Exception *v24;
  const cv::Exception *v25;
  uint64_t v26;
  int v27;
  unsigned int v28;
  void *__p[2];
  void *v31[2];
  void *v32[2];
  _BYTE v33[120];

  if (!a1)
  {
    std::string::basic_string[abi:ne180100]<0>(v32, "null pointer to header");
    std::string::basic_string[abi:ne180100]<0>(v31, "cvInitImageHeader");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v33, 4294967287, v32, v31, __p, 2908);
    cv::error((cv *)v33, v12);
  }
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_DWORD *)a1 = 144;
  if ((a4 - 1) > 3)
  {
    v14 = "";
    v15 = "";
  }
  else
  {
    v13 = &icvGetColorModel(int,char const**,char const**)::tab[2 * (a4 - 1)];
    v14 = *v13;
    v15 = v13[1];
  }
  strncpy((char *)(a1 + 20), v14, 4uLL);
  strncpy((char *)(a1 + 24), v15, 4uLL);
  if ((a2 & 0x8000000080000000) != 0)
  {
    std::string::basic_string[abi:ne180100]<0>(v32, "Bad input roi");
    std::string::basic_string[abi:ne180100]<0>(v31, "cvInitImageHeader");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v33, 4294967271, v32, v31, __p, 2918);
    cv::error((cv *)v33, v16);
  }
  v17 = a3 & 0x7FFFFFFF;
  v22 = a3 != 1 && v17 != 8 && v17 != 16 && v17 != 32 && a3 != 64;
  if (a4 < 0 || v22)
  {
    std::string::basic_string[abi:ne180100]<0>(v32, "Unsupported format");
    std::string::basic_string[abi:ne180100]<0>(v31, "cvInitImageHeader");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v33, 4294967279, v32, v31, __p, 2925);
    cv::error((cv *)v33, v23);
  }
  if (a5 >= 2)
  {
    std::string::basic_string[abi:ne180100]<0>(v32, "Bad input origin");
    std::string::basic_string[abi:ne180100]<0>(v31, "cvInitImageHeader");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v33, 4294967276, v32, v31, __p, 2927);
    cv::error((cv *)v33, v24);
  }
  if (a6 != 4 && a6 != 8)
  {
    std::string::basic_string[abi:ne180100]<0>(v32, "Bad input align");
    std::string::basic_string[abi:ne180100]<0>(v31, "cvInitImageHeader");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v33, 4294967275, v32, v31, __p, 2930);
    cv::error((cv *)v33, v25);
  }
  *(_QWORD *)(a1 + 40) = a2;
  v26 = *(_QWORD *)(a1 + 48);
  if (v26)
  {
    *(_QWORD *)v26 = 0;
    *(_DWORD *)(v26 + 8) = 0;
    *(_QWORD *)(v26 + 12) = a2;
  }
  if (a4 <= 1)
    v27 = 1;
  else
    v27 = a4;
  *(_DWORD *)(a1 + 8) = v27;
  *(_DWORD *)(a1 + 16) = a3;
  v28 = (a6 + ((v17 * a2 * v27 + 7) >> 3) - 1) & -a6;
  *(_DWORD *)(a1 + 96) = v28;
  *(_DWORD *)(a1 + 32) = a5;
  *(_DWORD *)(a1 + 36) = a6;
  *(_DWORD *)(a1 + 80) = v28 * HIDWORD(a2);
  return a1;
}

void sub_219E7FDC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

uint64_t cvCreateImageHeader(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3;
  int v4;
  char **v6;
  const char *v7;
  const char *v8;
  uint64_t v9;

  v3 = a3;
  v4 = a2;
  if (CvIPL)
  {
    if ((a3 - 1) > 3)
    {
      v7 = "";
      v8 = "";
    }
    else
    {
      v6 = &icvGetColorModel(int,char const**,char const**)::tab[2 * (a3 - 1)];
      v7 = *v6;
      v8 = v6[1];
    }
    return CvIPL(a3, 0, a2, v7, v8, 0, 0, 4, a1, 0, 0, 0, 0);
  }
  else
  {
    v9 = cvAlloc(144);
    return cvInitImageHeader(v9, a1, v4, v3, 0, 4);
  }
}

uint64_t cvCreateImage(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t ImageHeader;
  uint64_t v4;

  ImageHeader = cvCreateImageHeader(a1, a2, a3);
  if (!ImageHeader)
    cvCreateImage_cold_1();
  v4 = ImageHeader;
  cvCreateData(ImageHeader);
  return v4;
}

void cvReleaseImageHeader(uint64_t *a1, void *a2)
{
  const cv::Exception *v2;
  uint64_t v3;
  void *v4;
  void *__p[2];
  void *v6[2];
  void *v7[2];
  _BYTE v8[120];

  if (!a1)
  {
    std::string::basic_string[abi:ne180100]<0>(v7, "");
    std::string::basic_string[abi:ne180100]<0>(v6, "cvReleaseImageHeader");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v8, 4294967269, v7, v6, __p, 2959);
    cv::error((cv *)v8, v2);
  }
  v3 = *a1;
  if (*a1)
  {
    *a1 = 0;
    if (CvIPL)
    {
      CvIPL(v3, 5);
    }
    else
    {
      cv::fastFree(*(void ***)(v3 + 48), a2);
      *(_QWORD *)(v3 + 48) = 0;
      cv::fastFree((void **)v3, v4);
    }
  }
}

void sub_219E80050(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

void cvReleaseImage(uint64_t *a1, void *a2)
{
  const cv::Exception *v3;
  uint64_t v4;
  void *v5;
  void *__p[2];
  void *v7[2];
  void *v8[2];
  uint64_t v9[15];

  if (!a1)
  {
    std::string::basic_string[abi:ne180100]<0>(v8, "");
    std::string::basic_string[abi:ne180100]<0>(v7, "cvReleaseImage");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v9, 4294967269, v8, v7, __p, 2983);
    cv::error((cv *)v9, v3);
  }
  v4 = *a1;
  if (*a1)
  {
    v9[0] = *a1;
    *a1 = 0;
    cvReleaseData(v4, a2);
    cvReleaseImageHeader(v9, v5);
  }
}

void sub_219E8017C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

_DWORD *cvSetImageROI(_DWORD *result, unint64_t a2, unint64_t a3)
{
  _DWORD *v3;
  const cv::Exception *v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  int v8;
  int v9;
  const cv::Exception *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _DWORD *v15;
  void *__p[2];
  void *v17[2];
  void *v18[2];
  _BYTE v19[120];

  v3 = result;
  if (!result)
  {
    std::string::basic_string[abi:ne180100]<0>(v18, "");
    std::string::basic_string[abi:ne180100]<0>(v17, "cvSetImageROI");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v19, 4294967287, v18, v17, __p, 3000);
    cv::error((cv *)v19, v4);
  }
  v5 = HIDWORD(a2);
  v6 = HIDWORD(a3);
  if ((a3 & 0x8000000080000000) != 0
    || (v7 = result[10], v7 <= (int)a2)
    || (v8 = result[11], v8 <= SHIDWORD(a2))
    || (v9 = a2 + a3, (int)a2 + (int)a3 < ((_DWORD)a3 != 0))
    || HIDWORD(a2) + HIDWORD(a3) < (HIDWORD(a3) != 0))
  {
    std::string::basic_string[abi:ne180100]<0>(v18, "rect.width >= 0 && rect.height >= 0 && rect.x < image->width && rect.y < image->height && rect.x + rect.width >= (int)(rect.width > 0) && rect.y + rect.height >= (int)(rect.height > 0)");
    std::string::basic_string[abi:ne180100]<0>(v17, "cvSetImageROI");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v19, 4294967081, v18, v17, __p, 3006);
    cv::error((cv *)v19, v10);
  }
  v11 = a2 & ~((int)a2 >> 31);
  v12 = v5 & ~((int)v5 >> 31);
  if (v7 >= v9)
    v7 = v9;
  if (v8 >= (int)v5 + (int)v6)
    v8 = v5 + v6;
  v13 = (v7 - v11);
  v14 = (v8 - v12);
  v15 = (_DWORD *)*((_QWORD *)result + 6);
  if (v15)
  {
    v15[1] = v11;
    v15[2] = v12;
    v15[3] = v13;
    v15[4] = v14;
  }
  else
  {
    result = icvCreateROI(0, v11, v12, v13, v14);
    *((_QWORD *)v3 + 6) = result;
  }
  return result;
}

void sub_219E803CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

_DWORD *icvCreateROI(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  _DWORD *result;

  v5 = a5;
  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  if (CvIPL)
    return (_DWORD *)CvIPL(a1, a2, a3, a4, a5);
  result = (_DWORD *)cvAlloc(20);
  *result = v9;
  result[1] = v8;
  result[2] = v7;
  result[3] = v6;
  result[4] = v5;
  return result;
}

_DWORD *cvSetImageCOI(_DWORD *result, uint64_t a2)
{
  _DWORD *v2;
  const cv::Exception *v3;
  const cv::Exception *v4;
  _DWORD *v5;
  void *__p[2];
  void *v7[2];
  void *v8[2];
  _BYTE v9[120];

  v2 = result;
  if (!result)
  {
    std::string::basic_string[abi:ne180100]<0>(v8, "");
    std::string::basic_string[abi:ne180100]<0>(v7, "cvSetImageCOI");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v9, 4294967287, v8, v7, __p, 3073);
    cv::error((cv *)v9, v3);
  }
  if (result[2] < a2)
  {
    std::string::basic_string[abi:ne180100]<0>(v8, "");
    std::string::basic_string[abi:ne180100]<0>(v7, "cvSetImageCOI");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v9, 4294967272, v8, v7, __p, 3076);
    cv::error((cv *)v9, v4);
  }
  v5 = (_DWORD *)*((_QWORD *)result + 6);
  if ((_DWORD)a2 || v5)
  {
    if (v5)
    {
      *v5 = a2;
    }
    else
    {
      result = icvCreateROI(a2, 0, 0, result[10], result[11]);
      *((_QWORD *)v2 + 6) = result;
    }
  }
  return result;
}

void sub_219E80644(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

uint64_t cvGetImageCOI(uint64_t a1)
{
  const cv::Exception *v1;
  unsigned int *v2;
  void *__p[2];
  void *v5[2];
  void *v6[2];
  _BYTE v7[120];

  if (!a1)
  {
    std::string::basic_string[abi:ne180100]<0>(v6, "");
    std::string::basic_string[abi:ne180100]<0>(v5, "cvGetImageCOI");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v7, 4294967287, v6, v5, __p, 3096);
    cv::error((cv *)v7, v1);
  }
  v2 = *(unsigned int **)(a1 + 48);
  if (v2)
    return *v2;
  else
    return 0;
}

void sub_219E80778(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

uint64_t cvCloneImage(__int128 *a1)
{
  const cv::Exception *v2;
  uint64_t v3;
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  unsigned int *v11;
  size_t v12;
  void *__p[2];
  void *v15[2];
  void *v16[2];
  _BYTE v17[120];

  if (!a1 || *(_DWORD *)a1 != 144)
  {
    std::string::basic_string[abi:ne180100]<0>(v16, "Bad image header");
    std::string::basic_string[abi:ne180100]<0>(v15, "cvCloneImage");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/array.cpp");
    cv::Exception::Exception(v17, 4294967291, v16, v15, __p, 3108);
    cv::error((cv *)v17, v2);
  }
  if (CvIPL)
    return CvIPL(a1);
  v3 = cvAlloc(144);
  v4 = *((_QWORD *)a1 + 16);
  v6 = a1[6];
  v5 = a1[7];
  *(_OWORD *)(v3 + 80) = a1[5];
  v7 = a1[1];
  v8 = a1[2];
  v9 = a1[4];
  *(_OWORD *)(v3 + 48) = a1[3];
  *(_OWORD *)(v3 + 96) = v6;
  *(_OWORD *)(v3 + 112) = v5;
  *(_QWORD *)(v3 + 128) = v4;
  v10 = *a1;
  *(_OWORD *)(v3 + 64) = v9;
  *(_OWORD *)(v3 + 16) = v7;
  *(_OWORD *)(v3 + 32) = v8;
  *(_OWORD *)v3 = v10;
  *(_QWORD *)(v3 + 136) = 0;
  *(_QWORD *)(v3 + 88) = 0;
  *(_QWORD *)(v3 + 48) = 0;
  v11 = (unsigned int *)*((_QWORD *)a1 + 6);
  if (v11)
    *(_QWORD *)(v3 + 48) = icvCreateROI(*v11, v11[1], v11[2], v11[3], v11[4]);
  if (*((_QWORD *)a1 + 11))
  {
    v12 = *((int *)a1 + 20);
    cvCreateData(v3);
    memcpy(*(void **)(v3 + 88), *((const void **)a1 + 11), v12);
  }
  return v3;
}

void sub_219E80948(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

void cvNextNArraySlice_cold_1()
{
  __assert_rtn("cvNextNArraySlice", "array.cpp", 499, "iterator != 0");
}

void icvGetNodePtr()
{
  __assert_rtn("icvGetNodePtr", "array.cpp", 699, "(newsize & (newsize - 1)) == 0");
}

{
  __assert_rtn("icvGetNodePtr", "array.cpp", 650, "CV_IS_SPARSE_MAT( mat)");
}

void cvCreateImage_cold_1()
{
  __assert_rtn("cvCreateImage", "array.cpp", 2893, "img");
}

cv::BaseRowFilter *cv::getMorphologyRowFilter@<X0>(cv *this@<X0>, uint64_t a2@<X1>, int a3@<W2>, int a4@<W3>, cv::BaseRowFilter **a5@<X8>)
{
  int v7;
  int v8;
  int v9;
  cv::BaseRowFilter *v10;
  uint64_t (**v11)();
  const cv::Exception *v12;
  const cv::Exception *v13;
  cv::BaseRowFilter *result;
  void *__p[2];
  void *v16[2];
  void *v17[2];
  _BYTE v18[120];

  if (a3 >= 0)
    v7 = a3;
  else
    v7 = a3 + 1;
  v8 = v7 >> 1;
  if (a4 >= 0)
    v9 = a4;
  else
    v9 = v8;
  if (this >= 2)
  {
    std::string::basic_string[abi:ne180100]<0>(v17, "op == MORPH_ERODE || op == MORPH_DILATE");
    std::string::basic_string[abi:ne180100]<0>(v16, "getMorphologyRowFilter");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/imgproc/morph.cpp");
    cv::Exception::Exception(v18, 4294967081, v17, v16, __p, 848);
    cv::error((cv *)v18, v12);
  }
  if (!(_DWORD)this)
  {
    switch(a2 & 7)
    {
      case 0:
        v10 = (cv::BaseRowFilter *)operator new();
        cv::BaseRowFilter::BaseRowFilter(v10);
        v11 = &off_24DBF0740;
        goto LABEL_19;
      case 2:
        v10 = (cv::BaseRowFilter *)operator new();
        cv::BaseRowFilter::BaseRowFilter(v10);
        v11 = &off_24DBF0780;
        goto LABEL_19;
      case 3:
        v10 = (cv::BaseRowFilter *)operator new();
        cv::BaseRowFilter::BaseRowFilter(v10);
        v11 = &off_24DBF07C0;
        goto LABEL_19;
      case 5:
        v10 = (cv::BaseRowFilter *)operator new();
        cv::BaseRowFilter::BaseRowFilter(v10);
        v11 = &off_24DBF0800;
        goto LABEL_19;
      case 6:
        v10 = (cv::BaseRowFilter *)operator new();
        cv::BaseRowFilter::BaseRowFilter(v10);
        v11 = &off_24DBF0840;
        goto LABEL_19;
      default:
        goto LABEL_14;
    }
  }
  switch(a2 & 7)
  {
    case 0:
      v10 = (cv::BaseRowFilter *)operator new();
      cv::BaseRowFilter::BaseRowFilter(v10);
      v11 = &off_24DBF0880;
      break;
    case 2:
      v10 = (cv::BaseRowFilter *)operator new();
      cv::BaseRowFilter::BaseRowFilter(v10);
      v11 = &off_24DBF08C0;
      break;
    case 3:
      v10 = (cv::BaseRowFilter *)operator new();
      cv::BaseRowFilter::BaseRowFilter(v10);
      v11 = &off_24DBF0900;
      break;
    case 5:
      v10 = (cv::BaseRowFilter *)operator new();
      cv::BaseRowFilter::BaseRowFilter(v10);
      v11 = &off_24DBF0940;
      break;
    case 6:
      v10 = (cv::BaseRowFilter *)operator new();
      cv::BaseRowFilter::BaseRowFilter(v10);
      v11 = &off_24DBF0980;
      break;
    default:
LABEL_14:
      cv::format(v17, a2);
      std::string::basic_string[abi:ne180100]<0>(v16, "getMorphologyRowFilter");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/imgproc/morph.cpp");
      cv::Exception::Exception(v18, 4294967083, v17, v16, __p, 886);
      cv::error((cv *)v18, v13);
  }
LABEL_19:
  *(_QWORD *)v10 = v11;
  *((_DWORD *)v10 + 2) = a3;
  *((_DWORD *)v10 + 3) = v9;
  *a5 = v10;
  result = (cv::BaseRowFilter *)cv::fastMalloc((cv *)4);
  *(_DWORD *)result = 1;
  a5[1] = result;
  return result;
}

void sub_219E80DDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,char a29)
{
  uint64_t v29;

  MEMORY[0x2207351BC](v29, 0x1081C408CA3AA07);
  _Unwind_Resume(a1);
}

cv::BaseColumnFilter *cv::getMorphologyColumnFilter@<X0>(cv *this@<X0>, uint64_t a2@<X1>, int a3@<W2>, int a4@<W3>, cv::BaseColumnFilter **a5@<X8>)
{
  int v7;
  int v8;
  int v9;
  cv::BaseColumnFilter *v10;
  uint64_t (**v11)();
  const cv::Exception *v12;
  const cv::Exception *v13;
  cv::BaseColumnFilter *result;
  void *__p[2];
  void *v16[2];
  void *v17[2];
  _BYTE v18[120];

  if (a3 >= 0)
    v7 = a3;
  else
    v7 = a3 + 1;
  v8 = v7 >> 1;
  if (a4 >= 0)
    v9 = a4;
  else
    v9 = v8;
  if (this >= 2)
  {
    std::string::basic_string[abi:ne180100]<0>(v17, "op == MORPH_ERODE || op == MORPH_DILATE");
    std::string::basic_string[abi:ne180100]<0>(v16, "getMorphologyColumnFilter");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/imgproc/morph.cpp");
    cv::Exception::Exception(v18, 4294967081, v17, v16, __p, 895);
    cv::error((cv *)v18, v12);
  }
  if (!(_DWORD)this)
  {
    switch(a2 & 7)
    {
      case 0:
        v10 = (cv::BaseColumnFilter *)operator new();
        cv::BaseColumnFilter::BaseColumnFilter(v10);
        v11 = &off_24DBF09C0;
        goto LABEL_19;
      case 2:
        v10 = (cv::BaseColumnFilter *)operator new();
        cv::BaseColumnFilter::BaseColumnFilter(v10);
        v11 = &off_24DBF0A08;
        goto LABEL_19;
      case 3:
        v10 = (cv::BaseColumnFilter *)operator new();
        cv::BaseColumnFilter::BaseColumnFilter(v10);
        v11 = &off_24DBF0A50;
        goto LABEL_19;
      case 5:
        v10 = (cv::BaseColumnFilter *)operator new();
        cv::BaseColumnFilter::BaseColumnFilter(v10);
        v11 = &off_24DBF0A98;
        goto LABEL_19;
      case 6:
        v10 = (cv::BaseColumnFilter *)operator new();
        cv::BaseColumnFilter::BaseColumnFilter(v10);
        v11 = &off_24DBF0AE0;
        goto LABEL_19;
      default:
        goto LABEL_14;
    }
  }
  switch(a2 & 7)
  {
    case 0:
      v10 = (cv::BaseColumnFilter *)operator new();
      cv::BaseColumnFilter::BaseColumnFilter(v10);
      v11 = &off_24DBF0B28;
      break;
    case 2:
      v10 = (cv::BaseColumnFilter *)operator new();
      cv::BaseColumnFilter::BaseColumnFilter(v10);
      v11 = &off_24DBF0B70;
      break;
    case 3:
      v10 = (cv::BaseColumnFilter *)operator new();
      cv::BaseColumnFilter::BaseColumnFilter(v10);
      v11 = &off_24DBF0BB8;
      break;
    case 5:
      v10 = (cv::BaseColumnFilter *)operator new();
      cv::BaseColumnFilter::BaseColumnFilter(v10);
      v11 = &off_24DBF0C00;
      break;
    case 6:
      v10 = (cv::BaseColumnFilter *)operator new();
      cv::BaseColumnFilter::BaseColumnFilter(v10);
      v11 = &off_24DBF0C48;
      break;
    default:
LABEL_14:
      cv::format(v17, a2);
      std::string::basic_string[abi:ne180100]<0>(v16, "getMorphologyColumnFilter");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/imgproc/morph.cpp");
      cv::Exception::Exception(v18, 4294967083, v17, v16, __p, 933);
      cv::error((cv *)v18, v13);
  }
LABEL_19:
  *(_QWORD *)v10 = v11;
  *((_DWORD *)v10 + 2) = a3;
  *((_DWORD *)v10 + 3) = v9;
  *a5 = v10;
  result = (cv::BaseColumnFilter *)cv::fastMalloc((cv *)4);
  *(_DWORD *)result = 1;
  a5[1] = result;
  return result;
}

void sub_219E81224(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,char a29)
{
  uint64_t v29;

  MEMORY[0x2207351BC](v29, 0x1081C408CA3AA07);
  _Unwind_Resume(a1);
}

void cv::getMorphologyFilter(unsigned int a1@<W0>, uint64_t a2@<X1>, void (***a3)(int32x2_t **__return_ptr, _QWORD, uint64_t)@<X2>, uint64_t *a4@<X3>, _QWORD *a5@<X8>)
{
  uint64_t v9;
  _QWORD *v10;
  _DWORD *v11;
  void *v12;
  const cv::Exception *v13;
  _QWORD *v14;
  const cv::Exception *v15;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  _QWORD *v19;
  unsigned int *v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  int32x2_t *v24;
  _QWORD *v25;
  _QWORD *v26;
  _QWORD *v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  void *__p[2];
  void *v40[2];
  void *v41[2];
  int v42[30];
  int32x2_t v43;
  uint64_t v44;
  int32x2_t *v45[3];
  unsigned int *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  int32x2_t *v50;
  void **v51;
  uint64_t v52;

  (**a3)(v45, a3, 0xFFFFFFFFLL);
  v9 = *a4;
  v43 = vrev64_s32(*v50);
  v44 = v9;
  cv::normalizeAnchor((int *)&v44, (int *)&v43, v42);
  *a4 = *(_QWORD *)v42;
  if (a1 >= 2)
  {
    std::string::basic_string[abi:ne180100]<0>(v41, "op == MORPH_ERODE || op == MORPH_DILATE");
    std::string::basic_string[abi:ne180100]<0>(v40, "getMorphologyFilter");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/imgproc/morph.cpp");
    cv::Exception::Exception(v42, 4294967081, v41, v40, __p, 943);
    cv::error((cv *)v42, v13);
  }
  if (!a1)
  {
    switch(a2 & 7)
    {
      case 0:
        v10 = (_QWORD *)operator new();
        v38 = *a4;
        cv::MorphFilter<cv::MinOp<unsigned char>,cv::MorphNoVec>::MorphFilter(v10, v45, &v38);
        *a5 = v10;
        v11 = (_DWORD *)cv::fastMalloc((cv *)4);
        goto LABEL_13;
      case 2:
        v25 = (_QWORD *)operator new();
        v37 = *a4;
        cv::MorphFilter<cv::MinOp<unsigned short>,cv::MorphNoVec>::MorphFilter(v25, v45, &v37);
        *a5 = v25;
        v11 = (_DWORD *)cv::fastMalloc((cv *)4);
        goto LABEL_13;
      case 3:
        v26 = (_QWORD *)operator new();
        v36 = *a4;
        cv::MorphFilter<cv::MinOp<short>,cv::MorphNoVec>::MorphFilter(v26, v45, &v36);
        *a5 = v26;
        v11 = (_DWORD *)cv::fastMalloc((cv *)4);
        goto LABEL_13;
      case 5:
        v27 = (_QWORD *)operator new();
        v35 = *a4;
        cv::MorphFilter<cv::MinOp<float>,cv::MorphNoVec>::MorphFilter(v27, v45, &v35);
        *a5 = v27;
        v11 = (_DWORD *)cv::fastMalloc((cv *)4);
        goto LABEL_13;
      case 6:
        v28 = (_QWORD *)operator new();
        v34 = *a4;
        cv::MorphFilter<cv::MinOp<double>,cv::MorphNoVec>::MorphFilter(v28, v45, &v34);
        *a5 = v28;
        v11 = (_DWORD *)cv::fastMalloc((cv *)4);
        goto LABEL_13;
      default:
        goto LABEL_8;
    }
  }
  switch(a2 & 7)
  {
    case 0:
      v14 = (_QWORD *)operator new();
      v33 = *a4;
      cv::MorphFilter<cv::MaxOp<unsigned char>,cv::MorphNoVec>::MorphFilter(v14, v45, &v33);
      *a5 = v14;
      v11 = (_DWORD *)cv::fastMalloc((cv *)4);
      break;
    case 2:
      v16 = (_QWORD *)operator new();
      v32 = *a4;
      cv::MorphFilter<cv::MaxOp<unsigned short>,cv::MorphNoVec>::MorphFilter(v16, v45, &v32);
      *a5 = v16;
      v11 = (_DWORD *)cv::fastMalloc((cv *)4);
      break;
    case 3:
      v17 = (_QWORD *)operator new();
      v31 = *a4;
      cv::MorphFilter<cv::MaxOp<short>,cv::MorphNoVec>::MorphFilter(v17, v45, &v31);
      *a5 = v17;
      v11 = (_DWORD *)cv::fastMalloc((cv *)4);
      break;
    case 5:
      v18 = (_QWORD *)operator new();
      v30 = *a4;
      cv::MorphFilter<cv::MaxOp<float>,cv::MorphNoVec>::MorphFilter(v18, v45, &v30);
      *a5 = v18;
      v11 = (_DWORD *)cv::fastMalloc((cv *)4);
      break;
    case 6:
      v19 = (_QWORD *)operator new();
      v29 = *a4;
      cv::MorphFilter<cv::MaxOp<double>,cv::MorphNoVec>::MorphFilter(v19, v45, &v29);
      *a5 = v19;
      v11 = (_DWORD *)cv::fastMalloc((cv *)4);
      break;
    default:
LABEL_8:
      cv::format(v41, a2);
      std::string::basic_string[abi:ne180100]<0>(v40, "getMorphologyFilter");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/imgproc/morph.cpp");
      cv::Exception::Exception(v42, 4294967083, v41, v40, __p, 971);
      cv::error((cv *)v42, v15);
  }
LABEL_13:
  *v11 = 1;
  a5[1] = v11;
  v20 = v46;
  if (v46)
  {
    do
    {
      v21 = __ldaxr(v20);
      v22 = v21 - 1;
    }
    while (__stlxr(v22, v20));
    if (!v22)
      cv::Mat::deallocate((cv::Mat *)v45, v12);
  }
  v45[2] = 0;
  v47 = 0;
  v48 = 0;
  v49 = 0;
  if (SHIDWORD(v45[0]) >= 1)
  {
    v23 = 0;
    v24 = v50;
    do
      v24->i32[v23++] = 0;
    while (v23 < SHIDWORD(v45[0]));
  }
  v46 = 0;
  if (v51 != (void **)&v52)
    cv::fastFree(v51, v12);
}

void sub_219E817C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,char a39)
{
  uint64_t v39;
  uint64_t v40;
  void *v42;

  MEMORY[0x2207351BC](v39, 0x10A1C407469E563);
  cv::Mat::~Mat((cv::Mat *)(v40 - 144), v42);
  _Unwind_Resume(a1);
}

void sub_219E819BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

void cv::createMorphologyFilter(cv *a1@<X0>, uint64_t a2@<X1>, void (***a3)(uint64_t *__return_ptr, _QWORD, uint64_t)@<X2>, int *a4@<X3>, int a5@<W4>, int a6@<W5>, float64x2_t *a7@<X6>, uint64_t *a8@<X8>)
{
  uint64_t v15;
  const cv::_InputArray *v16;
  int v17;
  void *v18;
  unsigned int *v19;
  unsigned int v20;
  unsigned int *v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int *v24;
  unsigned int v25;
  unsigned int v26;
  void *v27;
  unsigned int *v28;
  unsigned int v29;
  unsigned int *v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int *v33;
  unsigned int v34;
  unsigned int v35;
  void *v36;
  unsigned int *v37;
  unsigned int v38;
  unsigned int *v39;
  unsigned int v40;
  unsigned int v41;
  unsigned int *v42;
  unsigned int v43;
  unsigned int v44;
  float64x2_t v45;
  float64x2_t v46;
  int v47;
  double v48;
  BOOL v49;
  double v50;
  const cv::Exception *v51;
  uint64_t v52;
  _DWORD *v53;
  void *v54;
  unsigned int *v55;
  unsigned int v56;
  unsigned int v57;
  unsigned int *v58;
  unsigned int v59;
  unsigned int v60;
  unsigned int *v61;
  unsigned int v62;
  unsigned int v63;
  unsigned int *v64;
  unsigned int v65;
  unsigned int v66;
  uint64_t v67;
  int32x2_t *v68;
  void *__p[2];
  void *v70[2];
  void *v71[2];
  void (**v72)(int32x2_t **__return_ptr, _QWORD, uint64_t);
  cv *v73;
  cv *v74[2];
  float64x2_t v75;
  uint64_t v76;
  cv *v77;
  void **v78;
  void (**v79)(int32x2_t **__return_ptr, _QWORD, uint64_t);
  void **v80;
  void (**v81)(int32x2_t **__return_ptr, _QWORD, uint64_t);
  void **v82;
  int32x2_t v83;
  uint64_t v84;
  uint64_t v85;
  int v86;
  int v87;
  uint64_t v88;
  unsigned int *v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  int32x2_t *v93;
  void **v94;
  uint64_t v95;

  (**a3)(&v85, a3, 0xFFFFFFFFLL);
  v15 = *(_QWORD *)a4;
  v83 = vrev64_s32(*v93);
  v84 = v15;
  cv::normalizeAnchor((int *)&v84, (int *)&v83, (int *)&v72);
  *(_QWORD *)a4 = v72;
  v81 = 0;
  v82 = 0;
  v79 = 0;
  v80 = 0;
  v77 = 0;
  v78 = 0;
  cv::_InputArray::_InputArray((uint64_t)&v72, (const cv::Mat *)&v85);
  v17 = cv::countNonZero((cv *)&v72, v16);
  if (v17 == v87 * v86)
  {
    cv::getMorphologyRowFilter(a1, a2, v87, *a4, (cv::BaseRowFilter **)&v72);
    v19 = (unsigned int *)v73;
    if (v73)
    {
      do
        v20 = __ldaxr(v19);
      while (__stlxr(v20 + 1, v19));
    }
    v21 = (unsigned int *)v82;
    if (v82)
    {
      do
      {
        v22 = __ldaxr(v21);
        v23 = v22 - 1;
      }
      while (__stlxr(v23, v21));
      if (!v23)
      {
        if (v81)
          (*((void (**)(void (**)(int32x2_t **__return_ptr, _QWORD, uint64_t)))*v81 + 1))(v81);
        cv::fastFree(v82, v18);
      }
    }
    v24 = (unsigned int *)v73;
    v81 = v72;
    v82 = (void **)v19;
    if (v73)
    {
      do
      {
        v25 = __ldaxr(v24);
        v26 = v25 - 1;
      }
      while (__stlxr(v26, v24));
      if (!v26)
      {
        if (v72)
          (*((void (**)(void (**)(int32x2_t **__return_ptr, _QWORD, uint64_t)))*v72 + 1))(v72);
        cv::fastFree((void **)v73, v18);
      }
    }
    cv::getMorphologyColumnFilter(a1, a2, v86, a4[1], (cv::BaseColumnFilter **)&v72);
    v28 = (unsigned int *)v73;
    if (v73)
    {
      do
        v29 = __ldaxr(v28);
      while (__stlxr(v29 + 1, v28));
    }
    v30 = (unsigned int *)v80;
    if (v80)
    {
      do
      {
        v31 = __ldaxr(v30);
        v32 = v31 - 1;
      }
      while (__stlxr(v32, v30));
      if (!v32)
      {
        if (v79)
          (*((void (**)(void (**)(int32x2_t **__return_ptr, _QWORD, uint64_t)))*v79 + 1))(v79);
        cv::fastFree(v80, v27);
      }
    }
    v33 = (unsigned int *)v73;
    v79 = v72;
    v80 = (void **)v28;
    if (v73)
    {
      do
      {
        v34 = __ldaxr(v33);
        v35 = v34 - 1;
      }
      while (__stlxr(v35, v33));
      if (!v35)
      {
        if (v72)
          (*((void (**)(void (**)(int32x2_t **__return_ptr, _QWORD, uint64_t)))*v72 + 1))(v72);
        cv::fastFree((void **)v73, v27);
      }
    }
  }
  else
  {
    cv::_InputArray::_InputArray((uint64_t)&v72, (const cv::Mat *)&v85);
    v76 = *(_QWORD *)a4;
    cv::getMorphologyFilter(a1, a2, &v72, &v76, v74);
    v37 = (unsigned int *)v74[1];
    if (v74[1])
    {
      do
        v38 = __ldaxr(v37);
      while (__stlxr(v38 + 1, v37));
    }
    v39 = (unsigned int *)v78;
    if (v78)
    {
      do
      {
        v40 = __ldaxr(v39);
        v41 = v40 - 1;
      }
      while (__stlxr(v41, v39));
      if (!v41)
      {
        if (v77)
          (*(void (**)(cv *))(*(_QWORD *)v77 + 8))(v77);
        cv::fastFree(v78, v36);
      }
    }
    v42 = (unsigned int *)v74[1];
    v77 = v74[0];
    v78 = (void **)v37;
    if (v74[1])
    {
      do
      {
        v43 = __ldaxr(v42);
        v44 = v43 - 1;
      }
      while (__stlxr(v44, v42));
      if (!v44)
      {
        if (v74[0])
          (*(void (**)(cv *))(*(_QWORD *)v74[0] + 8))(v74[0]);
        cv::fastFree((void **)v74[1], v36);
      }
    }
  }
  v45 = a7[1];
  *(float64x2_t *)v74 = *a7;
  v75 = v45;
  if (!a5 || !a6)
  {
    v46 = (float64x2_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqq_f64(*(float64x2_t *)v74, v46), (int32x4_t)vceqq_f64(v75, v46))))) & 1) == 0)
    {
      v47 = a2 & 7;
      if (v47 == 7 || ((1 << v47) & 0x6D) == 0)
      {
        std::string::basic_string[abi:ne180100]<0>(v71, "depth == CV_8U || depth == CV_16U || depth == CV_16S || depth == CV_32F || depth == CV_64F");
        std::string::basic_string[abi:ne180100]<0>(v70, "createMorphologyFilter");
        std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/imgproc/morph.cpp");
        cv::Exception::Exception(&v72, 4294967081, v71, v70, __p, 1002);
        cv::error((cv *)&v72, v51);
      }
      if ((_DWORD)a1)
      {
        v48 = 0.0;
        if ((a2 & 5 | 2) != 2)
        {
          v48 = -1.79769313e308;
          if (v47 == 5)
            v48 = -3.40282347e38;
          v49 = v47 == 3;
          v50 = -32768.0;
LABEL_60:
          if (v49)
            v48 = v50;
        }
      }
      else
      {
        if ((a2 & 5 | 2) != 2)
        {
          v48 = 1.79769313e308;
          if (v47 == 5)
            v48 = 3.40282347e38;
          v49 = v47 == 3;
          v50 = 32767.0;
          goto LABEL_60;
        }
        v48 = dbl_219EA1680[v47 == 0];
      }
      v74[0] = *(cv **)&v48;
      v74[1] = *(cv **)&v48;
      v75.f64[0] = v48;
      v75.f64[1] = v48;
    }
  }
  v52 = operator new();
  cv::FilterEngine::FilterEngine(v52, &v77, &v81, &v79, a2, a2, a2, a5, a6, (uint64_t)v74);
  *a8 = v52;
  v53 = (_DWORD *)cv::fastMalloc((cv *)4);
  *v53 = 1;
  a8[1] = (uint64_t)v53;
  v55 = (unsigned int *)v78;
  if (v78)
  {
    do
    {
      v56 = __ldaxr(v55);
      v57 = v56 - 1;
    }
    while (__stlxr(v57, v55));
    if (!v57)
    {
      if (v77)
        (*(void (**)(cv *))(*(_QWORD *)v77 + 8))(v77);
      cv::fastFree(v78, v54);
    }
  }
  v58 = (unsigned int *)v80;
  if (v80)
  {
    do
    {
      v59 = __ldaxr(v58);
      v60 = v59 - 1;
    }
    while (__stlxr(v60, v58));
    if (!v60)
    {
      if (v79)
        (*((void (**)(void (**)(int32x2_t **__return_ptr, _QWORD, uint64_t)))*v79 + 1))(v79);
      cv::fastFree(v80, v54);
    }
  }
  v61 = (unsigned int *)v82;
  if (v82)
  {
    do
    {
      v62 = __ldaxr(v61);
      v63 = v62 - 1;
    }
    while (__stlxr(v63, v61));
    if (!v63)
    {
      if (v81)
        (*((void (**)(void (**)(int32x2_t **__return_ptr, _QWORD, uint64_t)))*v81 + 1))(v81);
      cv::fastFree(v82, v54);
    }
  }
  v64 = v89;
  if (v89)
  {
    do
    {
      v65 = __ldaxr(v64);
      v66 = v65 - 1;
    }
    while (__stlxr(v66, v64));
    if (!v66)
      cv::Mat::deallocate((cv::Mat *)&v85, v54);
  }
  v88 = 0;
  v90 = 0;
  v91 = 0;
  v92 = 0;
  if (SHIDWORD(v85) >= 1)
  {
    v67 = 0;
    v68 = v93;
    do
      v68->i32[v67++] = 0;
    while (v67 < SHIDWORD(v85));
  }
  v89 = 0;
  if (v94 != (void **)&v95)
    cv::fastFree(v94, v54);
}

void sub_219E81FE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44)
{
  uint64_t v44;
  void *v46;
  void *v47;
  void *v48;
  void *v49;

  cv::Exception::~Exception((cv::Exception *)&a29);
  if (a16 < 0)
    operator delete(__p);
  if (a22 < 0)
    operator delete(a17);
  if (a28 < 0)
    operator delete(a23);
  cv::Ptr<cv::BaseFilter>::~Ptr((uint64_t *)(v44 - 240), v46);
  cv::Ptr<cv::BaseColumnFilter>::~Ptr((uint64_t *)(v44 - 224), v47);
  cv::Ptr<cv::BaseRowFilter>::~Ptr((uint64_t *)(v44 - 208), v48);
  cv::Mat::~Mat((cv::Mat *)(v44 - 176), v49);
  _Unwind_Resume(a1);
}

void cv::getStructuringElement(unsigned int a1@<W0>, int *a2@<X1>, int *a3@<X2>, uint64_t a4@<X8>)
{
  unsigned int v6;
  const cv::Exception *v8;
  uint64_t v9;
  int v10;
  int v11;
  double v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;
  double v23;
  _BYTE *v24;
  int v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  void *__p[2];
  void *v30[2];
  void *v31[2];
  int v32[30];
  uint64_t v33;

  v6 = a1;
  v33 = *MEMORY[0x24BDAC8D0];
  if (a1 >= 3)
  {
    std::string::basic_string[abi:ne180100]<0>(v31, "shape == MORPH_RECT || shape == MORPH_CROSS || shape == MORPH_ELLIPSE");
    std::string::basic_string[abi:ne180100]<0>(v30, "getStructuringElement");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/imgproc/morph.cpp");
    cv::Exception::Exception(v32, 4294967081, v31, v30, __p, 1026);
    cv::error((cv *)v32, v8);
  }
  v9 = *(_QWORD *)a3;
  v27 = *(_QWORD *)a2;
  v28 = v9;
  cv::normalizeAnchor((int *)&v28, (int *)&v27, v32);
  *(_QWORD *)a3 = *(_QWORD *)v32;
  v10 = *a2;
  v11 = a2[1];
  if (v11 == 1 && v10 == 1)
    v6 = 0;
  v13 = 0.0;
  if (v6 == 2)
  {
    if (v11 >= 0)
      v14 = a2[1];
    else
      v14 = v11 + 1;
    v15 = v14 >> 1;
    if (v10 >= 0)
      v16 = *a2;
    else
      v16 = v10 + 1;
    v26 = v16 >> 1;
    if ((v11 + 1) >= 3)
      v13 = 1.0 / ((double)v15 * (double)v15);
  }
  else
  {
    v15 = 0;
    v26 = 0;
  }
  *(_QWORD *)(a4 + 80) = 0;
  *(_QWORD *)(a4 + 64) = a4 + 8;
  *(_QWORD *)(a4 + 72) = a4 + 80;
  *(_QWORD *)(a4 + 88) = 0;
  *(_DWORD *)a4 = 1124007936;
  *(_OWORD *)(a4 + 4) = 0u;
  *(_OWORD *)(a4 + 20) = 0u;
  *(_OWORD *)(a4 + 36) = 0u;
  *(_OWORD *)(a4 + 48) = 0u;
  v32[0] = v11;
  v32[1] = v10;
  cv::Mat::create((cv::Mat *)a4, (cv::Mat *)2, v32, 0);
  if (a2[1] >= 1)
  {
    v17 = 0;
    v25 = v26 + 1;
    while (1)
    {
      v18 = *(_QWORD *)(a4 + 16);
      v19 = *(_QWORD *)(a4 + 80) * v17;
      if (!v6)
        goto LABEL_23;
      if (v6 == 1)
        break;
      if ((int)v17 - v15 >= 0)
        v22 = v17 - v15;
      else
        v22 = v15 - v17;
      if (v22 <= v15)
      {
        v23 = rint(sqrt(v13 * (double)((v15 - ((int)v17 - v15)) * (int)v17)) * (double)v26);
        v20 = (v26 - (uint64_t)v23) & ~((int)(v26 - (uint64_t)v23) >> 31);
        if (*a2 >= (int)(v25 + (uint64_t)v23))
          v21 = v25 + (uint64_t)v23;
        else
          v21 = *a2;
LABEL_33:
        if (v20 < 1)
          v20 = 0;
        else
          bzero((void *)(v18 + v19), v20);
        goto LABEL_36;
      }
      v21 = 0;
LABEL_39:
      if (v21 < *a2)
      {
        v24 = (_BYTE *)(v18 + v19 + v21);
        do
        {
          *v24++ = 0;
          ++v21;
        }
        while (*a2 > v21);
      }
      if (++v17 >= a2[1])
        return;
    }
    if (v17 != a3[1])
    {
      v20 = *a3;
      v21 = *a3 + 1;
      goto LABEL_33;
    }
LABEL_23:
    v20 = 0;
    v21 = *a2;
LABEL_36:
    if (v20 >= v21)
      v21 = v20;
    else
      memset((void *)(v18 + v19 + v20), 1, (v21 + ~v20) + 1);
    goto LABEL_39;
  }
}

void sub_219E8240C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,char a31)
{
  cv::Exception::~Exception((cv::Exception *)&a31);
  if (a18 < 0)
    operator delete(__p);
  if (a24 < 0)
    operator delete(a19);
  if (a30 < 0)
    operator delete(a25);
  _Unwind_Resume(a1);
}

void cv::morphOp(int a1, void (***a2)(__int128 *__return_ptr, _QWORD, uint64_t), uint64_t a3, void (***a4)(__int128 *__return_ptr, _QWORD, uint64_t), uint64_t *a5, int a6, int a7, uint64_t a8)
{
  int v15;
  int v16;
  int v17;
  int v18;
  const cv::Exception *v19;
  void *v20;
  const cv::_InputArray *v21;
  int v22;
  int v23;
  int v24;
  void *v25;
  unsigned int *v26;
  unsigned int v27;
  unsigned int *v28;
  unsigned int v29;
  unsigned int v30;
  uint64_t v31;
  int *v32;
  void *v33;
  unsigned int *v34;
  unsigned int v35;
  unsigned int *v36;
  unsigned int v37;
  unsigned int v38;
  uint64_t v39;
  int *v40;
  cv *v41;
  void **v42;
  unsigned int *v43;
  unsigned int v44;
  unsigned int v45;
  uint64_t v46;
  uint64_t v47;
  cv *v48;
  void **v49;
  unsigned int *v50;
  unsigned int v51;
  unsigned int v52;
  uint64_t v53;
  uint64_t v54;
  unsigned int *v55;
  unsigned int v56;
  int v57;
  cv *v58;
  cv *v59;
  unsigned int *v60;
  unsigned int v61;
  int v62;
  cv *v63;
  cv *v64;
  unsigned int *v65;
  unsigned int v66;
  int v67;
  void **v68;
  cv *v69;
  void *v70;
  unsigned int *v71;
  unsigned int v72;
  unsigned int v73;
  uint64_t v74;
  char *v75;
  unsigned int *v76;
  unsigned int v77;
  unsigned int v78;
  uint64_t v79;
  char *v80;
  unsigned int *v81;
  unsigned int v82;
  unsigned int v83;
  uint64_t v84;
  char *v85;
  unsigned int *v86;
  unsigned int v87;
  unsigned int v88;
  uint64_t v89;
  uint64_t v90;
  unsigned int *v91;
  unsigned int v92;
  unsigned int v93;
  uint64_t v94;
  int32x2_t *v95;
  unsigned int *v96;
  unsigned int v97;
  unsigned int v98;
  uint64_t v99;
  int *v100;
  uint64_t v101;
  __int128 v102;
  uint64_t v103;
  __int128 v104;
  __int128 v105;
  uint64_t v106;
  char *v107;
  cv *v108;
  _QWORD v109[2];
  __int128 v110;
  uint64_t v111;
  __int128 v112;
  __int128 v113;
  uint64_t v114;
  char *v115;
  cv *v116;
  _QWORD v117[2];
  __int128 v118;
  uint64_t v119;
  __int128 v120;
  __int128 v121;
  uint64_t v122;
  char *v123;
  cv *v124;
  _QWORD v125[3];
  int v126;
  int v127;
  uint64_t v128;
  uint64_t v129;
  __int128 v130;
  __int128 v131;
  uint64_t v132;
  uint64_t v133;
  cv *v134;
  _BYTE v135[280];
  int v136[2];
  int v137[2];
  uint64_t v138;
  int v139[2];
  __int128 __p;
  uint64_t v141;
  __int128 v142;
  __int128 v143;
  uint64_t v144;
  uint64_t v145;
  cv *v146;
  uint64_t v147;
  int32x2_t v148;
  __int128 v149;
  uint64_t v150;
  __int128 v151;
  __int128 v152;
  uint64_t v153;
  int32x2_t *v154;
  cv *v155;
  uint64_t v156;
  uint64_t v157[2];
  int v158[2];
  uint64_t v159;
  __int128 v160;
  uint64_t v161;
  __int128 v162;
  __int128 v163;
  uint64_t v164;
  int *v165;
  void **v166;
  uint64_t v167;

  (**a4)(&v160, a4, 0xFFFFFFFFLL);
  if (v161)
  {
    v16 = *v165;
    v15 = v165[1];
  }
  else
  {
    v15 = 3;
    v16 = 3;
  }
  v159 = *a5;
  v158[0] = v15;
  v158[1] = v16;
  cv::normalizeAnchor((int *)&v159, v158, &v126);
  v17 = v126;
  v18 = v127;
  *(_DWORD *)a5 = v126;
  *((_DWORD *)a5 + 1) = v18;
  if (v17 < 0 || v17 >= v15 || v18 < 0 || v18 >= v16)
  {
    std::string::basic_string[abi:ne180100]<0>(&v149, "anchor.inside(Rect(0, 0, ksize.width, ksize.height))");
    std::string::basic_string[abi:ne180100]<0>(&__p, "morphOp");
    std::string::basic_string[abi:ne180100]<0>(v157, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/imgproc/morph.cpp");
    cv::Exception::Exception(&v126, 4294967081, &v149, &__p, v157, 1298);
    cv::error((cv *)&v126, v19);
  }
  (**a2)(&v149, a2, 0xFFFFFFFFLL);
  v148 = vrev64_s32(*v154);
  (*(void (**)(uint64_t, int32x2_t *, _QWORD, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a3 + 128))(a3, &v148, v149 & 0xFFF, 0xFFFFFFFFLL, 0, 0);
  (**(void (***)(__int128 *__return_ptr, uint64_t, uint64_t))a3)(&__p, a3, 0xFFFFFFFFLL);
  if (!a6 || HIDWORD(v160) * DWORD2(v160) == 1)
  {
    cv::_OutputArray::_OutputArray((uint64_t)&v126, (cv::Mat *)&__p);
    cv::Mat::copyTo((cv::Mat *)&v149, (const cv::_OutputArray *)&v126);
    goto LABEL_113;
  }
  if (!v161)
  {
    v139[0] = (2 * a6) | 1;
    v139[1] = v139[0];
    v138 = -1;
    cv::getStructuringElement(0, v139, (int *)&v138, (uint64_t)&v126);
    v34 = (unsigned int *)v130;
    if ((_QWORD)v130)
    {
      do
        v35 = __ldaxr(v34);
      while (__stlxr(v35 + 1, v34));
    }
    v36 = (unsigned int *)v162;
    if ((_QWORD)v162)
    {
      do
      {
        v37 = __ldaxr(v36);
        v38 = v37 - 1;
      }
      while (__stlxr(v38, v36));
      if (!v38)
        cv::Mat::deallocate((cv::Mat *)&v160, v33);
    }
    v161 = 0;
    *((_QWORD *)&v162 + 1) = 0;
    v163 = 0uLL;
    if ((uint64_t)v160 <= 0)
    {
      *(_QWORD *)&v162 = 0;
      LODWORD(v160) = v126;
    }
    else
    {
      v39 = 0;
      v40 = v165;
      do
        v40[v39++] = 0;
      while (v39 < SDWORD1(v160));
      *(_QWORD *)&v162 = 0;
      LODWORD(v160) = v126;
      if (SDWORD1(v160) > 2)
        goto LABEL_40;
    }
    if (v127 <= 2)
    {
      DWORD1(v160) = v127;
      *((_QWORD *)&v160 + 1) = v128;
      v41 = v134;
      v42 = v166;
      *v166 = *(void **)v134;
      v42[1] = (void *)*((_QWORD *)v41 + 1);
      goto LABEL_41;
    }
LABEL_40:
    cv::Mat::copySize((cv::Mat *)&v160, (const cv::Mat *)&v126);
LABEL_41:
    v43 = (unsigned int *)v130;
    v163 = v131;
    v162 = v130;
    v161 = v129;
    v164 = v132;
    if ((_QWORD)v130)
    {
      do
      {
        v44 = __ldaxr(v43);
        v45 = v44 - 1;
      }
      while (__stlxr(v45, v43));
      if (!v45)
        cv::Mat::deallocate((cv::Mat *)&v126, v33);
    }
    v129 = 0;
    v131 = 0uLL;
    *((_QWORD *)&v130 + 1) = 0;
    if (v127 >= 1)
    {
      v46 = 0;
      v47 = v133;
      do
        *(_DWORD *)(v47 + 4 * v46++) = 0;
      while (v46 < v127);
    }
    *(_QWORD *)&v130 = 0;
    if (v134 != (cv *)v135)
      cv::fastFree((void **)v134, v33);
    *(_DWORD *)a5 = a6;
    *((_DWORD *)a5 + 1) = a6;
    goto LABEL_64;
  }
  if (a6 < 2)
    goto LABEL_65;
  cv::_InputArray::_InputArray((uint64_t)&v126, (const cv::Mat *)&v160);
  v22 = cv::countNonZero((cv *)&v126, v21);
  if (v22 != HIDWORD(v160) * DWORD2(v160))
    goto LABEL_65;
  v23 = *(_DWORD *)a5 * a6;
  v24 = *((_DWORD *)a5 + 1) * a6;
  *(_DWORD *)a5 = v23;
  *((_DWORD *)a5 + 1) = v24;
  v137[0] = v15 + (v15 - 1) * (a6 - 1);
  v137[1] = v16 + (v16 - 1) * (a6 - 1);
  v136[0] = v23;
  v136[1] = v24;
  cv::getStructuringElement(0, v137, v136, (uint64_t)&v126);
  v26 = (unsigned int *)v130;
  if ((_QWORD)v130)
  {
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 + 1, v26));
  }
  v28 = (unsigned int *)v162;
  if ((_QWORD)v162)
  {
    do
    {
      v29 = __ldaxr(v28);
      v30 = v29 - 1;
    }
    while (__stlxr(v30, v28));
    if (!v30)
      cv::Mat::deallocate((cv::Mat *)&v160, v25);
  }
  v161 = 0;
  *((_QWORD *)&v162 + 1) = 0;
  v163 = 0uLL;
  if ((uint64_t)v160 <= 0)
  {
    *(_QWORD *)&v162 = 0;
    LODWORD(v160) = v126;
  }
  else
  {
    v31 = 0;
    v32 = v165;
    do
      v32[v31++] = 0;
    while (v31 < SDWORD1(v160));
    *(_QWORD *)&v162 = 0;
    LODWORD(v160) = v126;
    if (SDWORD1(v160) > 2)
      goto LABEL_54;
  }
  if (v127 <= 2)
  {
    DWORD1(v160) = v127;
    *((_QWORD *)&v160 + 1) = v128;
    v48 = v134;
    v49 = v166;
    *v166 = *(void **)v134;
    v49[1] = (void *)*((_QWORD *)v48 + 1);
    goto LABEL_55;
  }
LABEL_54:
  cv::Mat::copySize((cv::Mat *)&v160, (const cv::Mat *)&v126);
LABEL_55:
  v50 = (unsigned int *)v130;
  v163 = v131;
  v162 = v130;
  v161 = v129;
  v164 = v132;
  if ((_QWORD)v130)
  {
    do
    {
      v51 = __ldaxr(v50);
      v52 = v51 - 1;
    }
    while (__stlxr(v52, v50));
    if (!v52)
      cv::Mat::deallocate((cv::Mat *)&v126, v25);
  }
  v129 = 0;
  v131 = 0uLL;
  *((_QWORD *)&v130 + 1) = 0;
  if (v127 >= 1)
  {
    v53 = 0;
    v54 = v133;
    do
      *(_DWORD *)(v54 + 4 * v53++) = 0;
    while (v53 < v127);
  }
  *(_QWORD *)&v130 = 0;
  if (v134 != (cv *)v135)
    cv::fastFree((void **)v134, v25);
LABEL_64:
  a6 = 1;
LABEL_65:
  v157[0] = 0x100000000;
  v118 = v149;
  v55 = (unsigned int *)v151;
  v120 = v151;
  v121 = v152;
  v119 = v150;
  v122 = v153;
  v123 = (char *)&v118 + 8;
  v124 = (cv *)v125;
  v125[0] = 0;
  v125[1] = 0;
  if ((_QWORD)v151)
  {
    do
      v56 = __ldaxr(v55);
    while (__stlxr(v56 + 1, v55));
    v57 = DWORD1(v149);
  }
  else
  {
    v57 = DWORD1(v149);
  }
  if (v57 > 2)
  {
    DWORD1(v118) = 0;
    cv::Mat::copySize((cv::Mat *)&v118, (const cv::Mat *)&v149);
  }
  else
  {
    v58 = v155;
    v59 = v124;
    *(_QWORD *)v124 = *(_QWORD *)v155;
    *((_QWORD *)v59 + 1) = *((_QWORD *)v58 + 1);
  }
  v110 = __p;
  v60 = (unsigned int *)v142;
  v112 = v142;
  v113 = v143;
  v111 = v141;
  v114 = v144;
  v115 = (char *)&v110 + 8;
  v116 = (cv *)v117;
  v117[0] = 0;
  v117[1] = 0;
  if ((_QWORD)v142)
  {
    do
      v61 = __ldaxr(v60);
    while (__stlxr(v61 + 1, v60));
    v62 = DWORD1(__p);
  }
  else
  {
    v62 = DWORD1(__p);
  }
  if (v62 > 2)
  {
    DWORD1(v110) = 0;
    cv::Mat::copySize((cv::Mat *)&v110, (const cv::Mat *)&__p);
  }
  else
  {
    v63 = v146;
    v64 = v116;
    *(_QWORD *)v116 = *(_QWORD *)v146;
    *((_QWORD *)v64 + 1) = *((_QWORD *)v63 + 1);
  }
  v103 = v161;
  v102 = v160;
  v65 = (unsigned int *)v162;
  v104 = v162;
  v105 = v163;
  v106 = v164;
  v107 = (char *)&v102 + 8;
  v109[0] = 0;
  v109[1] = 0;
  v108 = (cv *)v109;
  if ((_QWORD)v162)
  {
    do
      v66 = __ldaxr(v65);
    while (__stlxr(v66 + 1, v65));
    v67 = DWORD1(v160);
  }
  else
  {
    v67 = DWORD1(v160);
  }
  if (v67 > 2)
  {
    DWORD1(v102) = 0;
    cv::Mat::copySize((cv::Mat *)&v102, (const cv::Mat *)&v160);
  }
  else
  {
    v68 = v166;
    v69 = v108;
    *(_QWORD *)v108 = *v166;
    *((_QWORD *)v69 + 1) = v68[1];
  }
  v101 = *a5;
  cv::MorphologyRunner::MorphologyRunner((uint64_t)&v126, (cv::Mat *)&v118, (cv::Mat *)&v110, 1, a6, a1, (cv::Mat *)&v102, &v101, a7, a7, a8);
  cv::parallel_for_(v157, (uint64_t)&v126, -1.0);
  cv::MorphologyRunner::~MorphologyRunner((cv::MorphologyRunner *)&v126, v70);
  v71 = (unsigned int *)v104;
  if ((_QWORD)v104)
  {
    do
    {
      v72 = __ldaxr(v71);
      v73 = v72 - 1;
    }
    while (__stlxr(v73, v71));
    if (!v73)
      cv::Mat::deallocate((cv::Mat *)&v102, v20);
  }
  v103 = 0;
  v105 = 0uLL;
  *((_QWORD *)&v104 + 1) = 0;
  if (SDWORD1(v102) >= 1)
  {
    v74 = 0;
    v75 = v107;
    do
      *(_DWORD *)&v75[4 * v74++] = 0;
    while (v74 < SDWORD1(v102));
  }
  *(_QWORD *)&v104 = 0;
  if (v108 != (cv *)v109)
    cv::fastFree((void **)v108, v20);
  v76 = (unsigned int *)v112;
  if ((_QWORD)v112)
  {
    do
    {
      v77 = __ldaxr(v76);
      v78 = v77 - 1;
    }
    while (__stlxr(v78, v76));
    if (!v78)
      cv::Mat::deallocate((cv::Mat *)&v110, v20);
  }
  v111 = 0;
  v113 = 0uLL;
  *((_QWORD *)&v112 + 1) = 0;
  if (SDWORD1(v110) >= 1)
  {
    v79 = 0;
    v80 = v115;
    do
      *(_DWORD *)&v80[4 * v79++] = 0;
    while (v79 < SDWORD1(v110));
  }
  *(_QWORD *)&v112 = 0;
  if (v116 != (cv *)v117)
    cv::fastFree((void **)v116, v20);
  v81 = (unsigned int *)v120;
  if ((_QWORD)v120)
  {
    do
    {
      v82 = __ldaxr(v81);
      v83 = v82 - 1;
    }
    while (__stlxr(v83, v81));
    if (!v83)
      cv::Mat::deallocate((cv::Mat *)&v118, v20);
  }
  v119 = 0;
  v121 = 0uLL;
  *((_QWORD *)&v120 + 1) = 0;
  if (SDWORD1(v118) >= 1)
  {
    v84 = 0;
    v85 = v123;
    do
      *(_DWORD *)&v85[4 * v84++] = 0;
    while (v84 < SDWORD1(v118));
  }
  *(_QWORD *)&v120 = 0;
  if (v124 != (cv *)v125)
    cv::fastFree((void **)v124, v20);
LABEL_113:
  v86 = (unsigned int *)v142;
  if ((_QWORD)v142)
  {
    do
    {
      v87 = __ldaxr(v86);
      v88 = v87 - 1;
    }
    while (__stlxr(v88, v86));
    if (!v88)
      cv::Mat::deallocate((cv::Mat *)&__p, v20);
  }
  v141 = 0;
  *((_QWORD *)&v142 + 1) = 0;
  v143 = 0uLL;
  if (SDWORD1(__p) >= 1)
  {
    v89 = 0;
    v90 = v145;
    do
      *(_DWORD *)(v90 + 4 * v89++) = 0;
    while (v89 < SDWORD1(__p));
  }
  *(_QWORD *)&v142 = 0;
  if (v146 != (cv *)&v147)
    cv::fastFree((void **)v146, v20);
  v91 = (unsigned int *)v151;
  if ((_QWORD)v151)
  {
    do
    {
      v92 = __ldaxr(v91);
      v93 = v92 - 1;
    }
    while (__stlxr(v93, v91));
    if (!v93)
      cv::Mat::deallocate((cv::Mat *)&v149, v20);
  }
  v150 = 0;
  *((_QWORD *)&v151 + 1) = 0;
  v152 = 0uLL;
  if (SDWORD1(v149) >= 1)
  {
    v94 = 0;
    v95 = v154;
    do
      v95->i32[v94++] = 0;
    while (v94 < SDWORD1(v149));
  }
  *(_QWORD *)&v151 = 0;
  if (v155 != (cv *)&v156)
    cv::fastFree((void **)v155, v20);
  v96 = (unsigned int *)v162;
  if ((_QWORD)v162)
  {
    do
    {
      v97 = __ldaxr(v96);
      v98 = v97 - 1;
    }
    while (__stlxr(v98, v96));
    if (!v98)
      cv::Mat::deallocate((cv::Mat *)&v160, v20);
  }
  v161 = 0;
  *((_QWORD *)&v162 + 1) = 0;
  v163 = 0uLL;
  if (SDWORD1(v160) >= 1)
  {
    v99 = 0;
    v100 = v165;
    do
      v100[v99++] = 0;
    while (v99 < SDWORD1(v160));
  }
  *(_QWORD *)&v162 = 0;
  if (v166 != (void **)&v167)
    cv::fastFree(v166, v20);
}

void sub_219E82ECC(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,char a50)
{
  uint64_t v50;
  void *v52;
  void *v53;
  void *v54;

  cv::Mat::~Mat((cv::Mat *)&a50, a2);
  cv::Mat::~Mat((cv::Mat *)&STACK[0x2D0], v52);
  cv::Mat::~Mat((cv::Mat *)&STACK[0x340], v53);
  cv::Mat::~Mat((cv::Mat *)(v50 - 192), v54);
  _Unwind_Resume(a1);
}

void cv::dilate(void (***a1)(__int128 *__return_ptr, _QWORD, uint64_t), uint64_t a2, void (***a3)(__int128 *__return_ptr, _QWORD, uint64_t), uint64_t *a4, int a5, int a6, uint64_t a7)
{
  uint64_t v7;

  v7 = *a4;
  cv::morphOp(1, a1, a2, a3, &v7, a5, a6, a7);
}

uint64_t cv::MorphologyRunner::MorphologyRunner(uint64_t a1, cv::Mat *a2, cv::Mat *a3, int a4, int a5, int a6, cv::Mat *a7, _QWORD *a8, int a9, int a10, uint64_t a11)
{
  uint64_t v15;
  cv::Mat *v16;
  int *v17;
  cv::Mat *v18;
  int *v19;
  cv::Mat *v20;
  int *v21;
  unsigned int *v22;
  unsigned int v23;
  unsigned int *v24;
  unsigned int v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  _QWORD *v31;
  _QWORD *v32;
  unsigned int *v33;
  unsigned int v34;
  unsigned int *v35;
  unsigned int v36;
  unsigned int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  _QWORD *v42;
  _QWORD *v43;
  unsigned int *v44;
  unsigned int v45;
  unsigned int *v46;
  unsigned int v47;
  unsigned int v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  _QWORD *v53;
  _QWORD *v54;

  v15 = 0;
  *(_QWORD *)a1 = &off_24DBF0700;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 72) = a1 + 16;
  *(_QWORD *)(a1 + 80) = a1 + 88;
  *(_DWORD *)(a1 + 8) = 1124007936;
  v16 = (cv::Mat *)(a1 + 8);
  *(_QWORD *)(a1 + 96) = 0;
  *(_OWORD *)(a1 + 12) = 0u;
  v17 = (int *)(a1 + 12);
  *(_OWORD *)(a1 + 28) = 0u;
  *(_OWORD *)(a1 + 44) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_DWORD *)(a1 + 104) = 1124007936;
  v18 = (cv::Mat *)(a1 + 104);
  *(_QWORD *)(a1 + 184) = 0;
  *(_QWORD *)(a1 + 168) = a1 + 112;
  *(_QWORD *)(a1 + 176) = a1 + 184;
  *(_QWORD *)(a1 + 192) = 0;
  *(_OWORD *)(a1 + 220) = 0u;
  v19 = (int *)(a1 + 220);
  *(_DWORD *)(a1 + 216) = 1124007936;
  v20 = (cv::Mat *)(a1 + 216);
  *(_QWORD *)(a1 + 280) = a1 + 224;
  *(_QWORD *)(a1 + 296) = 0;
  *(_QWORD *)(a1 + 288) = a1 + 296;
  *(_OWORD *)(a1 + 108) = 0u;
  v21 = (int *)(a1 + 108);
  *(_OWORD *)(a1 + 124) = 0u;
  *(_OWORD *)(a1 + 140) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_QWORD *)(a1 + 304) = 0;
  *(_OWORD *)(a1 + 236) = 0u;
  *(_OWORD *)(a1 + 252) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_DWORD *)(a1 + 312) = 0;
  *(_DWORD *)(a1 + 316) = 0;
  do
  {
    *(_QWORD *)(a1 + v15 + 328) = *(_QWORD *)(a11 + v15);
    v15 += 8;
  }
  while (v15 != 32);
  if (v16 != a2)
  {
    v22 = (unsigned int *)*((_QWORD *)a2 + 3);
    if (v22)
    {
      do
        v23 = __ldaxr(v22);
      while (__stlxr(v23 + 1, v22));
      v24 = *(unsigned int **)(a1 + 32);
      if (v24)
      {
        do
        {
          v25 = __ldaxr(v24);
          v26 = v25 - 1;
        }
        while (__stlxr(v26, v24));
        if (!v26)
          cv::Mat::deallocate((cv::Mat *)(a1 + 8), a2);
      }
    }
    *(_QWORD *)(a1 + 24) = 0;
    *(_QWORD *)(a1 + 48) = 0;
    *(_QWORD *)(a1 + 56) = 0;
    *(_QWORD *)(a1 + 40) = 0;
    if (*(int *)(a1 + 12) <= 0)
    {
      *(_QWORD *)(a1 + 32) = 0;
      *(_DWORD *)(a1 + 8) = *(_DWORD *)a2;
    }
    else
    {
      v27 = 0;
      v28 = *(_QWORD *)(a1 + 72);
      do
      {
        *(_DWORD *)(v28 + 4 * v27++) = 0;
        v29 = *v17;
      }
      while (v27 < v29);
      *(_QWORD *)(a1 + 32) = 0;
      *(_DWORD *)(a1 + 8) = *(_DWORD *)a2;
      if ((int)v29 > 2)
        goto LABEL_18;
    }
    v30 = *((_DWORD *)a2 + 1);
    if (v30 <= 2)
    {
      *(_DWORD *)(a1 + 12) = v30;
      *(_QWORD *)(a1 + 16) = *((_QWORD *)a2 + 1);
      v31 = (_QWORD *)*((_QWORD *)a2 + 9);
      v32 = *(_QWORD **)(a1 + 80);
      *v32 = *v31;
      v32[1] = v31[1];
LABEL_19:
      *(_OWORD *)(a1 + 40) = *((_OWORD *)a2 + 2);
      *(_QWORD *)(a1 + 56) = *((_QWORD *)a2 + 6);
      *(_OWORD *)(a1 + 24) = *((_OWORD *)a2 + 1);
      *(_QWORD *)(a1 + 64) = *((_QWORD *)a2 + 7);
      goto LABEL_20;
    }
LABEL_18:
    cv::Mat::copySize(v16, a2);
    goto LABEL_19;
  }
LABEL_20:
  if (v18 == a3)
    goto LABEL_37;
  v33 = (unsigned int *)*((_QWORD *)a3 + 3);
  if (v33)
  {
    do
      v34 = __ldaxr(v33);
    while (__stlxr(v34 + 1, v33));
  }
  v35 = *(unsigned int **)(a1 + 128);
  if (v35)
  {
    do
    {
      v36 = __ldaxr(v35);
      v37 = v36 - 1;
    }
    while (__stlxr(v37, v35));
    if (!v37)
      cv::Mat::deallocate(v18, a2);
  }
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 136) = 0;
  if (*(int *)(a1 + 108) <= 0)
  {
    *(_QWORD *)(a1 + 128) = 0;
    *(_DWORD *)(a1 + 104) = *(_DWORD *)a3;
  }
  else
  {
    v38 = 0;
    v39 = *(_QWORD *)(a1 + 168);
    do
    {
      *(_DWORD *)(v39 + 4 * v38++) = 0;
      v40 = *v21;
    }
    while (v38 < v40);
    *(_QWORD *)(a1 + 128) = 0;
    *(_DWORD *)(a1 + 104) = *(_DWORD *)a3;
    if ((int)v40 > 2)
      goto LABEL_35;
  }
  v41 = *((_DWORD *)a3 + 1);
  if (v41 > 2)
  {
LABEL_35:
    cv::Mat::copySize(v18, a3);
    goto LABEL_36;
  }
  *(_DWORD *)(a1 + 108) = v41;
  *(_QWORD *)(a1 + 112) = *((_QWORD *)a3 + 1);
  v42 = (_QWORD *)*((_QWORD *)a3 + 9);
  v43 = *(_QWORD **)(a1 + 176);
  *v43 = *v42;
  v43[1] = v42[1];
LABEL_36:
  *(_OWORD *)(a1 + 136) = *((_OWORD *)a3 + 2);
  *(_QWORD *)(a1 + 152) = *((_QWORD *)a3 + 6);
  *(_OWORD *)(a1 + 120) = *((_OWORD *)a3 + 1);
  *(_QWORD *)(a1 + 160) = *((_QWORD *)a3 + 7);
LABEL_37:
  *(_DWORD *)(a1 + 200) = a4;
  *(_DWORD *)(a1 + 204) = a5;
  *(_DWORD *)(a1 + 208) = a6;
  if (v20 != a7)
  {
    v44 = (unsigned int *)*((_QWORD *)a7 + 3);
    if (v44)
    {
      do
        v45 = __ldaxr(v44);
      while (__stlxr(v45 + 1, v44));
    }
    v46 = *(unsigned int **)(a1 + 240);
    if (v46)
    {
      do
      {
        v47 = __ldaxr(v46);
        v48 = v47 - 1;
      }
      while (__stlxr(v48, v46));
      if (!v48)
        cv::Mat::deallocate(v20, a2);
    }
    *(_QWORD *)(a1 + 232) = 0;
    *(_QWORD *)(a1 + 256) = 0;
    *(_QWORD *)(a1 + 264) = 0;
    *(_QWORD *)(a1 + 248) = 0;
    if (*(int *)(a1 + 220) <= 0)
    {
      *(_QWORD *)(a1 + 240) = 0;
      *(_DWORD *)(a1 + 216) = *(_DWORD *)a7;
    }
    else
    {
      v49 = 0;
      v50 = *(_QWORD *)(a1 + 280);
      do
      {
        *(_DWORD *)(v50 + 4 * v49++) = 0;
        v51 = *v19;
      }
      while (v49 < v51);
      *(_QWORD *)(a1 + 240) = 0;
      *(_DWORD *)(a1 + 216) = *(_DWORD *)a7;
      if ((int)v51 > 2)
        goto LABEL_52;
    }
    v52 = *((_DWORD *)a7 + 1);
    if (v52 <= 2)
    {
      *(_DWORD *)(a1 + 220) = v52;
      *(_QWORD *)(a1 + 224) = *((_QWORD *)a7 + 1);
      v53 = (_QWORD *)*((_QWORD *)a7 + 9);
      v54 = *(_QWORD **)(a1 + 288);
      *v54 = *v53;
      v54[1] = v53[1];
LABEL_53:
      *(_OWORD *)(a1 + 248) = *((_OWORD *)a7 + 2);
      *(_QWORD *)(a1 + 264) = *((_QWORD *)a7 + 6);
      *(_OWORD *)(a1 + 232) = *((_OWORD *)a7 + 1);
      *(_QWORD *)(a1 + 272) = *((_QWORD *)a7 + 7);
      goto LABEL_54;
    }
LABEL_52:
    cv::Mat::copySize(v20, a7);
    goto LABEL_53;
  }
LABEL_54:
  *(_QWORD *)(a1 + 312) = *a8;
  *(_DWORD *)(a1 + 320) = a9;
  *(_DWORD *)(a1 + 324) = a10;
  return a1;
}

void sub_219E83488(_Unwind_Exception *a1, void *a2)
{
  cv::BaseRowFilter *v2;
  cv::Mat *v3;
  cv::Mat *v4;
  cv::Mat *v5;
  void *v7;
  void *v8;

  cv::Mat::~Mat(v5, a2);
  cv::Mat::~Mat(v4, v7);
  cv::Mat::~Mat(v3, v8);
  cv::BaseRowFilter::~BaseRowFilter(v2);
  _Unwind_Resume(a1);
}

void cv::MorphologyRunner::~MorphologyRunner(cv::MorphologyRunner *this, void *a2)
{
  cv::MorphologyRunner::~MorphologyRunner(this, a2);
  JUMPOUT(0x2207351BCLL);
}

{
  unsigned int *v3;
  cv::Mat *v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  void **v9;
  unsigned int *v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  void **v15;
  unsigned int *v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  void **v21;

  *(_QWORD *)this = &off_24DBF0700;
  v3 = (unsigned int *)*((_QWORD *)this + 30);
  if (v3)
  {
    v4 = (cv::MorphologyRunner *)((char *)this + 216);
    do
    {
      v5 = __ldaxr(v3);
      v6 = v5 - 1;
    }
    while (__stlxr(v6, v3));
    if (!v6)
      cv::Mat::deallocate(v4, a2);
  }
  *((_QWORD *)this + 29) = 0;
  *((_QWORD *)this + 32) = 0;
  *((_QWORD *)this + 33) = 0;
  *((_QWORD *)this + 31) = 0;
  if (*((int *)this + 55) >= 1)
  {
    v7 = 0;
    v8 = *((_QWORD *)this + 35);
    do
      *(_DWORD *)(v8 + 4 * v7++) = 0;
    while (v7 < *((int *)this + 55));
  }
  *((_QWORD *)this + 30) = 0;
  v9 = (void **)*((_QWORD *)this + 36);
  if (v9 != (void **)((char *)this + 296))
    cv::fastFree(v9, a2);
  v10 = (unsigned int *)*((_QWORD *)this + 16);
  if (v10)
  {
    do
    {
      v11 = __ldaxr(v10);
      v12 = v11 - 1;
    }
    while (__stlxr(v12, v10));
    if (!v12)
      cv::Mat::deallocate((cv::MorphologyRunner *)((char *)this + 104), a2);
  }
  *((_QWORD *)this + 15) = 0;
  *((_QWORD *)this + 18) = 0;
  *((_QWORD *)this + 19) = 0;
  *((_QWORD *)this + 17) = 0;
  if (*((int *)this + 27) >= 1)
  {
    v13 = 0;
    v14 = *((_QWORD *)this + 21);
    do
      *(_DWORD *)(v14 + 4 * v13++) = 0;
    while (v13 < *((int *)this + 27));
  }
  *((_QWORD *)this + 16) = 0;
  v15 = (void **)*((_QWORD *)this + 22);
  if (v15 != (void **)((char *)this + 184))
    cv::fastFree(v15, a2);
  v16 = (unsigned int *)*((_QWORD *)this + 4);
  if (v16)
  {
    do
    {
      v17 = __ldaxr(v16);
      v18 = v17 - 1;
    }
    while (__stlxr(v18, v16));
    if (!v18)
      cv::Mat::deallocate((cv::MorphologyRunner *)((char *)this + 8), a2);
  }
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 5) = 0;
  if (*((int *)this + 3) >= 1)
  {
    v19 = 0;
    v20 = *((_QWORD *)this + 9);
    do
      *(_DWORD *)(v20 + 4 * v19++) = 0;
    while (v19 < *((int *)this + 3));
  }
  *((_QWORD *)this + 4) = 0;
  v21 = (void **)*((_QWORD *)this + 10);
  if (v21 != (void **)((char *)this + 88))
    cv::fastFree(v21, a2);
  cv::BaseRowFilter::~BaseRowFilter(this);
}

void cv::MorphologyRunner::operator()(uint64_t a1, _DWORD *a2)
{
  int v3;
  int v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  int v8;
  cv *v9;
  int v10;
  uint64_t v11;
  void *v12;
  int v13;
  unsigned int *v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int *v17;
  unsigned int v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int *v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _OWORD v30[2];
  uint64_t v31;
  cv *v32;
  unsigned int v33;
  int v34;
  uint64_t v35;
  unsigned int *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  cv *v41;
  uint64_t v42;
  _BYTE v43[4];
  int v44;
  uint64_t v45;
  unsigned int *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  void **v51;
  uint64_t v52;

  v3 = *(_DWORD *)(a1 + 16);
  v4 = *(_DWORD *)(a1 + 200);
  v5 = (uint64_t)rint((double)(v3 * *a2 / v4));
  if (v3 >= (int)v5)
    v6 = v5;
  else
    v6 = *(_DWORD *)(a1 + 16);
  v7 = (uint64_t)rint((double)(a2[1] * v3 / v4));
  if (v3 >= (int)v7)
    v8 = v7;
  else
    v8 = *(_DWORD *)(a1 + 16);
  v33 = v6;
  v34 = v8;
  *(_QWORD *)&v30[0] = 0x7FFFFFFF80000000;
  cv::Mat::Mat(v43, a1 + 8, &v33, v30);
  *(_QWORD *)&v30[0] = __PAIR64__(v8, v6);
  v31 = 0x7FFFFFFF80000000;
  cv::Mat::Mat(&v33, a1 + 104, v30, &v31);
  v9 = (cv *)*(unsigned int *)(a1 + 208);
  v10 = *(_DWORD *)(a1 + 8);
  cv::_InputArray::_InputArray((uint64_t)v30, (const cv::Mat *)(a1 + 216));
  v29 = *(_QWORD *)(a1 + 312);
  cv::createMorphologyFilter(v9, v10 & 0xFFF, (void (***)(uint64_t *__return_ptr, _QWORD, uint64_t))v30, (int *)&v29, *(_DWORD *)(a1 + 320), *(_DWORD *)(a1 + 324), (float64x2_t *)(a1 + 328), &v31);
  v11 = v31;
  v30[0] = xmmword_219E9E130;
  v28 = 0;
  (*(void (**)(uint64_t, _BYTE *, unsigned int *, _OWORD *, uint64_t *, _QWORD))(*(_QWORD *)v31 + 40))(v31, v43, &v33, v30, &v28, 0);
  if (*(int *)(a1 + 204) >= 2)
  {
    v13 = 1;
    do
    {
      v30[0] = xmmword_219E9E130;
      v27 = 0;
      (*(void (**)(uint64_t, unsigned int *, unsigned int *, _OWORD *, uint64_t *, _QWORD))(*(_QWORD *)v11 + 40))(v11, &v33, &v33, v30, &v27, 0);
      ++v13;
    }
    while (v13 < *(_DWORD *)(a1 + 204));
  }
  v14 = (unsigned int *)v32;
  if (v32)
  {
    do
    {
      v15 = __ldaxr(v14);
      v16 = v15 - 1;
    }
    while (__stlxr(v16, v14));
    if (!v16)
    {
      if (v31)
        (*(void (**)(uint64_t))(*(_QWORD *)v31 + 8))(v31);
      cv::fastFree((void **)v32, v12);
    }
  }
  v17 = v36;
  if (v36)
  {
    do
    {
      v18 = __ldaxr(v17);
      v19 = v18 - 1;
    }
    while (__stlxr(v19, v17));
    if (!v19)
      cv::Mat::deallocate((cv::Mat *)&v33, v12);
  }
  v35 = 0;
  v37 = 0;
  v38 = 0;
  v39 = 0;
  if (v34 >= 1)
  {
    v20 = 0;
    v21 = v40;
    do
      *(_DWORD *)(v21 + 4 * v20++) = 0;
    while (v20 < v34);
  }
  v36 = 0;
  if (v41 != (cv *)&v42)
    cv::fastFree((void **)v41, v12);
  v22 = v46;
  if (v46)
  {
    do
    {
      v23 = __ldaxr(v22);
      v24 = v23 - 1;
    }
    while (__stlxr(v24, v22));
    if (!v24)
      cv::Mat::deallocate((cv::Mat *)v43, v12);
  }
  v45 = 0;
  v47 = 0;
  v48 = 0;
  v49 = 0;
  if (v44 >= 1)
  {
    v25 = 0;
    v26 = v50;
    do
      *(_DWORD *)(v26 + 4 * v25++) = 0;
    while (v25 < v44);
  }
  v46 = 0;
  if (v51 != (void **)&v52)
    cv::fastFree(v51, v12);
}

void sub_219E83788(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  uint64_t v12;
  void *v14;
  void *v15;
  uint64_t v16;
  va_list va;
  uint64_t v18;
  va_list va1;

  va_start(va1, a12);
  va_start(va, a12);
  v16 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  cv::Ptr<cv::FilterEngine>::~Ptr((uint64_t *)va, a2);
  cv::Mat::~Mat((cv::Mat *)va1, v14);
  cv::Mat::~Mat((cv::Mat *)(v12 - 144), v15);
  _Unwind_Resume(a1);
}

void cv::MorphRowFilter<cv::MinOp<unsigned char>,cv::MorphRowNoVec>::~MorphRowFilter(cv::BaseRowFilter *a1)
{
  cv::BaseRowFilter::~BaseRowFilter(a1);
  JUMPOUT(0x2207351BCLL);
}

uint64_t cv::MorphRowFilter<cv::MinOp<unsigned char>,cv::MorphRowNoVec>::operator()(uint64_t result, char *a2, _BYTE *a3, int a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;
  char v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  char *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;

  v5 = *(int *)(result + 8) * (uint64_t)(int)a5;
  v6 = a5 * a4;
  if ((_DWORD)v5 == a5)
  {
    if ((int)v6 >= 1)
    {
      do
      {
        v7 = *a2++;
        *a3++ = v7;
        --v6;
      }
      while (v6);
    }
  }
  else if ((int)a5 >= 1)
  {
    v8 = 0;
    v9 = 2 * a5;
    v10 = (int)(v6 - 2 * a5);
    do
    {
      if ((v10 & 0x80000000) != 0)
      {
        LODWORD(v11) = 0;
      }
      else
      {
        v11 = 0;
        v12 = a2;
        do
        {
          v13 = &a2[v11];
          v14 = a2[v11 + a5];
          v15 = 2 * a5;
          if ((int)v9 < (int)v5)
          {
            do
            {
              v14 -= icvSaturate8u_cv[(v14 | 0x100) - v12[v15]];
              v15 += a5;
            }
            while (v15 < v5);
            v15 = (int)v15;
          }
          v16 = v14 | 0x100;
          a3[v11] = v14 - icvSaturate8u_cv[v16 - *v13];
          result = v14 - icvSaturate8u_cv[v16 - v13[v15]];
          a3[v11 + a5] = result;
          v11 += v9;
          v12 += v9;
        }
        while (v11 <= v10);
      }
      if ((int)v11 < (int)v6)
      {
        v17 = (int)v11;
        v18 = &a2[(int)v11];
        do
        {
          result = a2[v17];
          if ((int)v5 > (int)a5)
          {
            v19 = a5;
            do
            {
              result = result
                     - icvSaturate8u_cv[(result | 0x100) - v18[v19]];
              v19 += a5;
            }
            while (v19 < v5);
          }
          a3[v17] = result;
          v17 += a5;
          v18 += a5;
        }
        while (v17 < (int)v6);
      }
      ++v8;
      ++a2;
      ++a3;
    }
    while (v8 != a5);
  }
  return result;
}

void cv::MorphRowFilter<cv::MinOp<unsigned short>,cv::MorphRowNoVec>::~MorphRowFilter(cv::BaseRowFilter *a1)
{
  cv::BaseRowFilter::~BaseRowFilter(a1);
  JUMPOUT(0x2207351BCLL);
}

uint64_t cv::MorphRowFilter<cv::MinOp<unsigned short>,cv::MorphRowNoVec>::operator()(uint64_t result, __int16 *a2, _WORD *a3, int a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;
  __int16 v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int16 *v12;
  unsigned int v13;
  uint64_t v14;
  unsigned int v15;
  unsigned int v16;
  __int16 *v17;
  unsigned __int16 v18;
  uint64_t v19;

  v5 = *(int *)(result + 8) * (uint64_t)(int)a5;
  v6 = a5 * a4;
  if ((_DWORD)v5 == a5)
  {
    if ((int)v6 >= 1)
    {
      do
      {
        v7 = *a2++;
        *a3++ = v7;
        --v6;
      }
      while (v6);
    }
  }
  else if ((int)a5 >= 1)
  {
    v8 = 0;
    v9 = 2 * a5;
    v10 = (int)(v6 - 2 * a5);
    do
    {
      if ((v10 & 0x80000000) != 0)
      {
        LODWORD(v11) = 0;
      }
      else
      {
        v11 = 0;
        result = (uint64_t)a2;
        do
        {
          v12 = (unsigned __int16 *)&a2[v11];
          v13 = v12[a5];
          v14 = 2 * a5;
          if ((int)v9 < (int)v5)
          {
            do
            {
              if (*(unsigned __int16 *)(result + 2 * v14) >= (unsigned __int16)v13)
                v13 = (unsigned __int16)v13;
              else
                v13 = *(unsigned __int16 *)(result + 2 * v14);
              v14 += a5;
            }
            while (v14 < v5);
            v14 = (int)v14;
          }
          v15 = *v12;
          if (v15 >= v13)
            LOWORD(v15) = v13;
          a3[v11] = v15;
          v16 = v12[v14];
          if (v16 >= v13)
            LOWORD(v16) = v13;
          a3[v11 + a5] = v16;
          v11 += v9;
          result += 4 * a5;
        }
        while (v11 <= v10);
      }
      if ((int)v11 < (int)v6)
      {
        result = (int)v11;
        v17 = &a2[(int)v11];
        do
        {
          v18 = a2[result];
          if ((int)v5 > (int)a5)
          {
            v19 = a5;
            do
            {
              if ((unsigned __int16)v17[v19] < v18)
                v18 = v17[v19];
              v19 += a5;
            }
            while (v19 < v5);
          }
          a3[result] = v18;
          result += a5;
          v17 += a5;
        }
        while (result < (int)v6);
      }
      ++v8;
      ++a2;
      ++a3;
    }
    while (v8 != a5);
  }
  return result;
}

void cv::MorphRowFilter<cv::MinOp<short>,cv::MorphRowNoVec>::~MorphRowFilter(cv::BaseRowFilter *a1)
{
  cv::BaseRowFilter::~BaseRowFilter(a1);
  JUMPOUT(0x2207351BCLL);
}

uint64_t cv::MorphRowFilter<cv::MinOp<short>,cv::MorphRowNoVec>::operator()(uint64_t result, __int16 *a2, _WORD *a3, int a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;
  __int16 v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int16 *v12;
  __int16 v13;
  uint64_t v14;
  int v15;
  int v16;
  __int16 *v17;
  __int16 v18;
  uint64_t v19;

  v5 = *(int *)(result + 8) * (uint64_t)(int)a5;
  v6 = a5 * a4;
  if ((_DWORD)v5 == a5)
  {
    if ((int)v6 >= 1)
    {
      do
      {
        v7 = *a2++;
        *a3++ = v7;
        --v6;
      }
      while (v6);
    }
  }
  else if ((int)a5 >= 1)
  {
    v8 = 0;
    v9 = 2 * a5;
    v10 = (int)(v6 - 2 * a5);
    do
    {
      if ((v10 & 0x80000000) != 0)
      {
        LODWORD(v11) = 0;
      }
      else
      {
        v11 = 0;
        result = (uint64_t)a2;
        do
        {
          v12 = &a2[v11];
          v13 = v12[a5];
          v14 = 2 * a5;
          if ((int)v9 < (int)v5)
          {
            do
            {
              if (*(__int16 *)(result + 2 * v14) < v13)
                v13 = *(_WORD *)(result + 2 * v14);
              v14 += a5;
            }
            while (v14 < v5);
            v14 = (int)v14;
          }
          v15 = *v12;
          if (v15 >= v13)
            LOWORD(v15) = v13;
          a3[v11] = v15;
          v16 = v12[v14];
          if (v16 >= v13)
            LOWORD(v16) = v13;
          a3[v11 + a5] = v16;
          v11 += v9;
          result += 4 * a5;
        }
        while (v11 <= v10);
      }
      if ((int)v11 < (int)v6)
      {
        result = (int)v11;
        v17 = &a2[(int)v11];
        do
        {
          v18 = a2[result];
          if ((int)v5 > (int)a5)
          {
            v19 = a5;
            do
            {
              if (v17[v19] < v18)
                v18 = v17[v19];
              v19 += a5;
            }
            while (v19 < v5);
          }
          a3[result] = v18;
          result += a5;
          v17 += a5;
        }
        while (result < (int)v6);
      }
      ++v8;
      ++a2;
      ++a3;
    }
    while (v8 != a5);
  }
  return result;
}

void cv::MorphRowFilter<cv::MinOp<float>,cv::MorphRowNoVec>::~MorphRowFilter(cv::BaseRowFilter *a1)
{
  cv::BaseRowFilter::~BaseRowFilter(a1);
  JUMPOUT(0x2207351BCLL);
}

uint64_t cv::MorphRowFilter<cv::MinOp<float>,cv::MorphRowNoVec>::operator()(uint64_t result, int *a2, _DWORD *a3, int a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float *v12;
  float v13;
  uint64_t v14;
  float v15;
  int *v16;
  float v17;
  uint64_t v18;

  v5 = *(int *)(result + 8) * (uint64_t)(int)a5;
  v6 = a5 * a4;
  if ((_DWORD)v5 == a5)
  {
    if ((int)v6 >= 1)
    {
      do
      {
        v7 = *a2++;
        *a3++ = v7;
        --v6;
      }
      while (v6);
    }
  }
  else if ((int)a5 >= 1)
  {
    v8 = 0;
    v9 = 2 * a5;
    v10 = (int)(v6 - 2 * a5);
    do
    {
      if ((v10 & 0x80000000) != 0)
      {
        LODWORD(v11) = 0;
      }
      else
      {
        v11 = 0;
        result = (uint64_t)a2;
        do
        {
          v12 = (float *)&a2[v11];
          v13 = v12[a5];
          v14 = 2 * a5;
          if ((int)v9 < (int)v5)
          {
            do
            {
              if (*(float *)(result + 4 * v14) < v13)
                v13 = *(float *)(result + 4 * v14);
              v14 += a5;
            }
            while (v14 < v5);
            v14 = (int)v14;
          }
          v15 = *v12;
          if (*v12 >= v13)
            v15 = v13;
          *(float *)&a3[v11] = v15;
          if (v12[v14] < v13)
            v13 = v12[v14];
          *(float *)&a3[v11 + a5] = v13;
          v11 += v9;
          result += 8 * a5;
        }
        while (v11 <= v10);
      }
      if ((int)v11 < (int)v6)
      {
        result = (int)v11;
        v16 = &a2[(int)v11];
        do
        {
          v17 = *(float *)&a2[result];
          if ((int)v5 > (int)a5)
          {
            v18 = a5;
            do
            {
              if (*(float *)&v16[v18] < v17)
                v17 = *(float *)&v16[v18];
              v18 += a5;
            }
            while (v18 < v5);
          }
          *(float *)&a3[result] = v17;
          result += a5;
          v16 += a5;
        }
        while (result < (int)v6);
      }
      ++v8;
      ++a2;
      ++a3;
    }
    while (v8 != a5);
  }
  return result;
}

void cv::MorphRowFilter<cv::MinOp<double>,cv::MorphRowNoVec>::~MorphRowFilter(cv::BaseRowFilter *a1)
{
  cv::BaseRowFilter::~BaseRowFilter(a1);
  JUMPOUT(0x2207351BCLL);
}

uint64_t cv::MorphRowFilter<cv::MinOp<double>,cv::MorphRowNoVec>::operator()(uint64_t result, uint64_t *a2, _QWORD *a3, int a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  double *v12;
  double v13;
  uint64_t v14;
  double v15;
  uint64_t *v16;
  double v17;
  uint64_t v18;

  v5 = *(int *)(result + 8) * (uint64_t)(int)a5;
  v6 = a5 * a4;
  if ((_DWORD)v5 == a5)
  {
    if ((int)v6 >= 1)
    {
      do
      {
        v7 = *a2++;
        *a3++ = v7;
        --v6;
      }
      while (v6);
    }
  }
  else if ((int)a5 >= 1)
  {
    v8 = 0;
    v9 = 2 * a5;
    v10 = (int)(v6 - 2 * a5);
    do
    {
      if ((v10 & 0x80000000) != 0)
      {
        LODWORD(v11) = 0;
      }
      else
      {
        v11 = 0;
        result = (uint64_t)a2;
        do
        {
          v12 = (double *)&a2[v11];
          v13 = v12[a5];
          v14 = 2 * a5;
          if ((int)v9 < (int)v5)
          {
            do
            {
              if (*(double *)(result + 8 * v14) < v13)
                v13 = *(double *)(result + 8 * v14);
              v14 += a5;
            }
            while (v14 < v5);
            v14 = (int)v14;
          }
          v15 = *v12;
          if (*v12 >= v13)
            v15 = v13;
          *(double *)&a3[v11] = v15;
          if (v12[v14] < v13)
            v13 = v12[v14];
          *(double *)&a3[v11 + a5] = v13;
          v11 += v9;
          result += 16 * a5;
        }
        while (v11 <= v10);
      }
      if ((int)v11 < (int)v6)
      {
        result = (int)v11;
        v16 = &a2[(int)v11];
        do
        {
          v17 = *(double *)&a2[result];
          if ((int)v5 > (int)a5)
          {
            v18 = a5;
            do
            {
              if (*(double *)&v16[v18] < v17)
                v17 = *(double *)&v16[v18];
              v18 += a5;
            }
            while (v18 < v5);
          }
          *(double *)&a3[result] = v17;
          result += a5;
          v16 += a5;
        }
        while (result < (int)v6);
      }
      ++v8;
      ++a2;
      ++a3;
    }
    while (v8 != a5);
  }
  return result;
}

void cv::MorphRowFilter<cv::MaxOp<unsigned char>,cv::MorphRowNoVec>::~MorphRowFilter(cv::BaseRowFilter *a1)
{
  cv::BaseRowFilter::~BaseRowFilter(a1);
  JUMPOUT(0x2207351BCLL);
}

uint64_t cv::MorphRowFilter<cv::MaxOp<unsigned char>,cv::MorphRowNoVec>::operator()(uint64_t result, char *a2, _BYTE *a3, int a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;
  char v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  char *v13;
  int v14;
  uint64_t v15;
  unsigned __int8 *v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;

  v5 = *(int *)(result + 8) * (uint64_t)(int)a5;
  v6 = a5 * a4;
  if ((_DWORD)v5 == a5)
  {
    if ((int)v6 >= 1)
    {
      do
      {
        v7 = *a2++;
        *a3++ = v7;
        --v6;
      }
      while (v6);
    }
  }
  else if ((int)a5 >= 1)
  {
    v8 = 0;
    v9 = 2 * a5;
    v10 = (int)(v6 - 2 * a5);
    do
    {
      if ((v10 & 0x80000000) != 0)
      {
        LODWORD(v11) = 0;
      }
      else
      {
        v11 = 0;
        v12 = a2;
        do
        {
          v13 = &a2[v11];
          v14 = a2[v11 + a5];
          v15 = 2 * a5;
          if ((int)v9 < (int)v5)
          {
            do
            {
              v14 += icvSaturate8u_cv[v12[v15] - v14 + 256];
              v15 += a5;
            }
            while (v15 < v5);
            v15 = (int)v15;
          }
          v16 = &icvSaturate8u_cv[-v14];
          a3[v11] = v16[*v13 + 256] + v14;
          result = v16[v13[v15] + 256] + v14;
          a3[v11 + a5] = result;
          v11 += v9;
          v12 += v9;
        }
        while (v11 <= v10);
      }
      if ((int)v11 < (int)v6)
      {
        v17 = (int)v11;
        v18 = &a2[(int)v11];
        do
        {
          result = a2[v17];
          if ((int)v5 > (int)a5)
          {
            v19 = a5;
            do
            {
              result = icvSaturate8u_cv[v18[v19] - result + 256]
                     + result;
              v19 += a5;
            }
            while (v19 < v5);
          }
          a3[v17] = result;
          v17 += a5;
          v18 += a5;
        }
        while (v17 < (int)v6);
      }
      ++v8;
      ++a2;
      ++a3;
    }
    while (v8 != a5);
  }
  return result;
}

void cv::MorphRowFilter<cv::MaxOp<unsigned short>,cv::MorphRowNoVec>::~MorphRowFilter(cv::BaseRowFilter *a1)
{
  cv::BaseRowFilter::~BaseRowFilter(a1);
  JUMPOUT(0x2207351BCLL);
}

uint64_t cv::MorphRowFilter<cv::MaxOp<unsigned short>,cv::MorphRowNoVec>::operator()(uint64_t result, __int16 *a2, _WORD *a3, int a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;
  __int16 v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int16 *v12;
  unsigned int v13;
  uint64_t v14;
  unsigned int v15;
  unsigned int v16;
  __int16 *v17;
  unsigned __int16 v18;
  uint64_t v19;

  v5 = *(int *)(result + 8) * (uint64_t)(int)a5;
  v6 = a5 * a4;
  if ((_DWORD)v5 == a5)
  {
    if ((int)v6 >= 1)
    {
      do
      {
        v7 = *a2++;
        *a3++ = v7;
        --v6;
      }
      while (v6);
    }
  }
  else if ((int)a5 >= 1)
  {
    v8 = 0;
    v9 = 2 * a5;
    v10 = (int)(v6 - 2 * a5);
    do
    {
      if ((v10 & 0x80000000) != 0)
      {
        LODWORD(v11) = 0;
      }
      else
      {
        v11 = 0;
        result = (uint64_t)a2;
        do
        {
          v12 = (unsigned __int16 *)&a2[v11];
          v13 = v12[a5];
          v14 = 2 * a5;
          if ((int)v9 < (int)v5)
          {
            do
            {
              v13 = (unsigned __int16)v13;
              if ((unsigned __int16)v13 <= *(unsigned __int16 *)(result + 2 * v14))
                v13 = *(unsigned __int16 *)(result + 2 * v14);
              v14 += a5;
            }
            while (v14 < v5);
            v14 = (int)v14;
          }
          v15 = *v12;
          if (v13 > v15)
            LOWORD(v15) = v13;
          a3[v11] = v15;
          v16 = v12[v14];
          if (v13 > v16)
            LOWORD(v16) = v13;
          a3[v11 + a5] = v16;
          v11 += v9;
          result += 4 * a5;
        }
        while (v11 <= v10);
      }
      if ((int)v11 < (int)v6)
      {
        result = (int)v11;
        v17 = &a2[(int)v11];
        do
        {
          v18 = a2[result];
          if ((int)v5 > (int)a5)
          {
            v19 = a5;
            do
            {
              if (v18 <= (unsigned __int16)v17[v19])
                v18 = v17[v19];
              v19 += a5;
            }
            while (v19 < v5);
          }
          a3[result] = v18;
          result += a5;
          v17 += a5;
        }
        while (result < (int)v6);
      }
      ++v8;
      ++a2;
      ++a3;
    }
    while (v8 != a5);
  }
  return result;
}

void cv::MorphRowFilter<cv::MaxOp<short>,cv::MorphRowNoVec>::~MorphRowFilter(cv::BaseRowFilter *a1)
{
  cv::BaseRowFilter::~BaseRowFilter(a1);
  JUMPOUT(0x2207351BCLL);
}

uint64_t cv::MorphRowFilter<cv::MaxOp<short>,cv::MorphRowNoVec>::operator()(uint64_t result, __int16 *a2, _WORD *a3, int a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;
  __int16 v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int16 *v12;
  __int16 v13;
  uint64_t v14;
  int v15;
  int v16;
  __int16 *v17;
  __int16 v18;
  uint64_t v19;

  v5 = *(int *)(result + 8) * (uint64_t)(int)a5;
  v6 = a5 * a4;
  if ((_DWORD)v5 == a5)
  {
    if ((int)v6 >= 1)
    {
      do
      {
        v7 = *a2++;
        *a3++ = v7;
        --v6;
      }
      while (v6);
    }
  }
  else if ((int)a5 >= 1)
  {
    v8 = 0;
    v9 = 2 * a5;
    v10 = (int)(v6 - 2 * a5);
    do
    {
      if ((v10 & 0x80000000) != 0)
      {
        LODWORD(v11) = 0;
      }
      else
      {
        v11 = 0;
        result = (uint64_t)a2;
        do
        {
          v12 = &a2[v11];
          v13 = v12[a5];
          v14 = 2 * a5;
          if ((int)v9 < (int)v5)
          {
            do
            {
              if (v13 <= *(__int16 *)(result + 2 * v14))
                v13 = *(_WORD *)(result + 2 * v14);
              v14 += a5;
            }
            while (v14 < v5);
            v14 = (int)v14;
          }
          v15 = *v12;
          if (v13 > v15)
            LOWORD(v15) = v13;
          a3[v11] = v15;
          v16 = v12[v14];
          if (v13 > v16)
            LOWORD(v16) = v13;
          a3[v11 + a5] = v16;
          v11 += v9;
          result += 4 * a5;
        }
        while (v11 <= v10);
      }
      if ((int)v11 < (int)v6)
      {
        result = (int)v11;
        v17 = &a2[(int)v11];
        do
        {
          v18 = a2[result];
          if ((int)v5 > (int)a5)
          {
            v19 = a5;
            do
            {
              if (v18 <= v17[v19])
                v18 = v17[v19];
              v19 += a5;
            }
            while (v19 < v5);
          }
          a3[result] = v18;
          result += a5;
          v17 += a5;
        }
        while (result < (int)v6);
      }
      ++v8;
      ++a2;
      ++a3;
    }
    while (v8 != a5);
  }
  return result;
}

void cv::MorphRowFilter<cv::MaxOp<float>,cv::MorphRowNoVec>::~MorphRowFilter(cv::BaseRowFilter *a1)
{
  cv::BaseRowFilter::~BaseRowFilter(a1);
  JUMPOUT(0x2207351BCLL);
}

uint64_t cv::MorphRowFilter<cv::MaxOp<float>,cv::MorphRowNoVec>::operator()(uint64_t result, int *a2, _DWORD *a3, int a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float *v12;
  float v13;
  uint64_t v14;
  float v15;
  int *v16;
  float v17;
  uint64_t v18;

  v5 = *(int *)(result + 8) * (uint64_t)(int)a5;
  v6 = a5 * a4;
  if ((_DWORD)v5 == a5)
  {
    if ((int)v6 >= 1)
    {
      do
      {
        v7 = *a2++;
        *a3++ = v7;
        --v6;
      }
      while (v6);
    }
  }
  else if ((int)a5 >= 1)
  {
    v8 = 0;
    v9 = 2 * a5;
    v10 = (int)(v6 - 2 * a5);
    do
    {
      if ((v10 & 0x80000000) != 0)
      {
        LODWORD(v11) = 0;
      }
      else
      {
        v11 = 0;
        result = (uint64_t)a2;
        do
        {
          v12 = (float *)&a2[v11];
          v13 = v12[a5];
          v14 = 2 * a5;
          if ((int)v9 < (int)v5)
          {
            do
            {
              if (v13 < *(float *)(result + 4 * v14))
                v13 = *(float *)(result + 4 * v14);
              v14 += a5;
            }
            while (v14 < v5);
            v14 = (int)v14;
          }
          v15 = *v12;
          if (v13 >= *v12)
            v15 = v13;
          *(float *)&a3[v11] = v15;
          if (v13 < v12[v14])
            v13 = v12[v14];
          *(float *)&a3[v11 + a5] = v13;
          v11 += v9;
          result += 8 * a5;
        }
        while (v11 <= v10);
      }
      if ((int)v11 < (int)v6)
      {
        result = (int)v11;
        v16 = &a2[(int)v11];
        do
        {
          v17 = *(float *)&a2[result];
          if ((int)v5 > (int)a5)
          {
            v18 = a5;
            do
            {
              if (v17 < *(float *)&v16[v18])
                v17 = *(float *)&v16[v18];
              v18 += a5;
            }
            while (v18 < v5);
          }
          *(float *)&a3[result] = v17;
          result += a5;
          v16 += a5;
        }
        while (result < (int)v6);
      }
      ++v8;
      ++a2;
      ++a3;
    }
    while (v8 != a5);
  }
  return result;
}

void cv::MorphRowFilter<cv::MaxOp<double>,cv::MorphRowNoVec>::~MorphRowFilter(cv::BaseRowFilter *a1)
{
  cv::BaseRowFilter::~BaseRowFilter(a1);
  JUMPOUT(0x2207351BCLL);
}

uint64_t cv::MorphRowFilter<cv::MaxOp<double>,cv::MorphRowNoVec>::operator()(uint64_t result, uint64_t *a2, _QWORD *a3, int a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  double *v12;
  double v13;
  uint64_t v14;
  double v15;
  uint64_t *v16;
  double v17;
  uint64_t v18;

  v5 = *(int *)(result + 8) * (uint64_t)(int)a5;
  v6 = a5 * a4;
  if ((_DWORD)v5 == a5)
  {
    if ((int)v6 >= 1)
    {
      do
      {
        v7 = *a2++;
        *a3++ = v7;
        --v6;
      }
      while (v6);
    }
  }
  else if ((int)a5 >= 1)
  {
    v8 = 0;
    v9 = 2 * a5;
    v10 = (int)(v6 - 2 * a5);
    do
    {
      if ((v10 & 0x80000000) != 0)
      {
        LODWORD(v11) = 0;
      }
      else
      {
        v11 = 0;
        result = (uint64_t)a2;
        do
        {
          v12 = (double *)&a2[v11];
          v13 = v12[a5];
          v14 = 2 * a5;
          if ((int)v9 < (int)v5)
          {
            do
            {
              if (v13 < *(double *)(result + 8 * v14))
                v13 = *(double *)(result + 8 * v14);
              v14 += a5;
            }
            while (v14 < v5);
            v14 = (int)v14;
          }
          v15 = *v12;
          if (v13 >= *v12)
            v15 = v13;
          *(double *)&a3[v11] = v15;
          if (v13 < v12[v14])
            v13 = v12[v14];
          *(double *)&a3[v11 + a5] = v13;
          v11 += v9;
          result += 16 * a5;
        }
        while (v11 <= v10);
      }
      if ((int)v11 < (int)v6)
      {
        result = (int)v11;
        v16 = &a2[(int)v11];
        do
        {
          v17 = *(double *)&a2[result];
          if ((int)v5 > (int)a5)
          {
            v18 = a5;
            do
            {
              if (v17 < *(double *)&v16[v18])
                v17 = *(double *)&v16[v18];
              v18 += a5;
            }
            while (v18 < v5);
          }
          *(double *)&a3[result] = v17;
          result += a5;
          v16 += a5;
        }
        while (result < (int)v6);
      }
      ++v8;
      ++a2;
      ++a3;
    }
    while (v8 != a5);
  }
  return result;
}

void cv::MorphColumnFilter<cv::MinOp<unsigned char>,cv::MorphColumnNoVec>::~MorphColumnFilter(cv::BaseRowFilter *a1)
{
  cv::BaseRowFilter::~BaseRowFilter(a1);
  JUMPOUT(0x2207351BCLL);
}

uint64_t cv::MorphColumnFilter<cv::MinOp<unsigned char>,cv::MorphColumnNoVec>::operator()(uint64_t result, _QWORD *a2, uint64_t a3, int a4, int a5, int a6)
{
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 *v12;
  unsigned __int8 v13;
  unsigned __int8 v14;
  unsigned __int8 v15;
  unsigned __int8 v16;
  uint64_t v17;
  unsigned __int8 *v18;
  unsigned int v19;
  unsigned __int8 *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned __int8 *v25;
  _BYTE *v26;
  unsigned __int8 v27;
  uint64_t v28;
  unsigned int v29;
  uint64_t v30;
  char v31;
  uint64_t v32;
  uint64_t v33;
  unsigned __int8 *v34;
  unsigned __int8 v35;
  unsigned __int8 v36;
  unsigned __int8 v37;
  uint64_t v38;
  unsigned __int8 *v39;
  unsigned __int8 v40;
  uint64_t v41;
  BOOL v42;

  v6 = *(unsigned int *)(result + 8);
  v7 = a4;
  v8 = (int)v6 <= 1 || a5 <= 1;
  if (v8)
  {
    v9 = a5;
  }
  else
  {
    v10 = 8 * v6;
    do
    {
      if (a6 >= 4)
      {
        v11 = 0;
        do
        {
          v12 = (unsigned __int8 *)(a2[1] + v11);
          v13 = *v12;
          v14 = v12[1];
          v15 = v12[2];
          v16 = v12[3];
          if (v6 < 3)
          {
            v19 = 2;
          }
          else
          {
            v17 = 16;
            do
            {
              v18 = (unsigned __int8 *)(a2[(unint64_t)v17 / 8] + v11);
              v13 -= icvSaturate8u_cv[(v13 | 0x100) - *v18];
              v14 -= icvSaturate8u_cv[(v14 | 0x100) - v18[1]];
              v15 -= icvSaturate8u_cv[(v15 | 0x100) - v18[2]];
              v16 -= icvSaturate8u_cv[(v16 | 0x100) - v18[3]];
              v17 += 8;
            }
            while (v10 != v17);
            v19 = v6;
          }
          v20 = (unsigned __int8 *)(*a2 + v11);
          v21 = v13 | 0x100;
          *(_BYTE *)(a3 + v11) = v13 - icvSaturate8u_cv[v21 - *v20];
          v22 = v14 | 0x100;
          *(_BYTE *)(a3 + (v11 | 1)) = v14 - icvSaturate8u_cv[v22 - v20[1]];
          v23 = v15 | 0x100;
          *(_BYTE *)(a3 + (v11 | 2)) = v15 - icvSaturate8u_cv[v23 - v20[2]];
          v24 = v16 | 0x100;
          *(_BYTE *)(a3 + (v11 | 3)) = v16 - icvSaturate8u_cv[v24 - v20[3]];
          v25 = (unsigned __int8 *)(a2[v19] + v11);
          v26 = (_BYTE *)(a3 + v11 + v7);
          *v26 = v13 - icvSaturate8u_cv[v21 - *v25];
          v26[1] = v14 - icvSaturate8u_cv[v22 - v25[1]];
          v26[2] = v15 - icvSaturate8u_cv[v23 - v25[2]];
          result = icvSaturate8u_cv[v24 - v25[3]];
          v26[3] = v16 - result;
          v11 += 4;
        }
        while (v11 <= a6 - 4);
        v11 = v11;
      }
      else
      {
        v11 = 0;
      }
      if ((int)v11 < a6)
      {
        do
        {
          v27 = *(_BYTE *)(a2[1] + v11);
          if (v6 < 3)
          {
            v29 = 2;
          }
          else
          {
            v28 = 16;
            do
            {
              v27 -= icvSaturate8u_cv[(v27 | 0x100) - *(unsigned __int8 *)(a2[(unint64_t)v28 / 8] + v11)];
              v28 += 8;
            }
            while (v10 != v28);
            v29 = v6;
          }
          v30 = v27 | 0x100;
          *(_BYTE *)(a3 + v11) = v27 - icvSaturate8u_cv[v30 - *(unsigned __int8 *)(*a2 + v11)];
          v31 = v27 - icvSaturate8u_cv[v30 - *(unsigned __int8 *)(a2[v29] + v11)];
          result = v11 + v7;
          *(_BYTE *)(a3 + v11 + v7) = v31;
          ++v11;
        }
        while (v11 != a6);
      }
      v9 = a5 - 2;
      a3 += 2 * v7;
      a2 += 2;
      v8 = a5 <= 3;
      a5 -= 2;
    }
    while (!v8);
  }
  if (v9 >= 1)
  {
    v32 = 8 * v6;
    do
    {
      if (a6 >= 4)
      {
        v33 = 0;
        do
        {
          v34 = (unsigned __int8 *)(*a2 + v33);
          v35 = *v34;
          v36 = v34[1];
          result = v34[2];
          v37 = v34[3];
          if ((int)v6 >= 2)
          {
            v38 = 8;
            do
            {
              v39 = (unsigned __int8 *)(a2[(unint64_t)v38 / 8] + v33);
              v35 -= icvSaturate8u_cv[(v35 | 0x100) - *v39];
              v36 -= icvSaturate8u_cv[(v36 | 0x100) - v39[1]];
              result = result - icvSaturate8u_cv[(result | 0x100) - v39[2]];
              v37 -= icvSaturate8u_cv[(v37 | 0x100) - v39[3]];
              v38 += 8;
            }
            while (v32 != v38);
          }
          *(_BYTE *)(a3 + v33) = v35;
          *(_BYTE *)(a3 + (v33 | 1)) = v36;
          *(_BYTE *)(a3 + (v33 | 2)) = result;
          *(_BYTE *)(a3 + (v33 | 3)) = v37;
          v33 += 4;
        }
        while (v33 <= a6 - 4);
        v33 = v33;
      }
      else
      {
        v33 = 0;
      }
      if ((int)v33 < a6)
      {
        do
        {
          v40 = *(_BYTE *)(*a2 + v33);
          if ((int)v6 >= 2)
          {
            v41 = 8;
            do
            {
              result = icvSaturate8u_cv[(v40 | 0x100) - *(unsigned __int8 *)(a2[(unint64_t)v41 / 8] + v33)];
              v40 -= result;
              v41 += 8;
            }
            while (v32 != v41);
          }
          *(_BYTE *)(a3 + v33++) = v40;
        }
        while (v33 != a6);
      }
      a3 += v7;
      ++a2;
      v42 = __OFSUB__(v9--, 1);
    }
    while (!((v9 < 0) ^ v42 | (v9 == 0)));
  }
  return result;
}

void cv::MorphColumnFilter<cv::MinOp<unsigned short>,cv::MorphColumnNoVec>::~MorphColumnFilter(cv::BaseRowFilter *a1)
{
  cv::BaseRowFilter::~BaseRowFilter(a1);
  JUMPOUT(0x2207351BCLL);
}

uint64_t cv::MorphColumnFilter<cv::MinOp<unsigned short>,cv::MorphColumnNoVec>::operator()(uint64_t result, uint64_t *a2, uint64_t a3, int a4, int a5, int a6)
{
  uint64_t v6;
  int v7;
  BOOL v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint16x4_t v15;
  uint64_t v16;
  unsigned int v17;
  unsigned __int16 *v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned __int16 *v23;
  unsigned int v24;
  _WORD *v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint16x4_t v38;
  uint64_t v39;
  uint64_t v40;
  unsigned __int16 v41;
  uint64_t v42;
  BOOL v43;

  v6 = *(unsigned int *)(result + 8);
  v7 = a4 >> 1;
  v8 = (int)v6 <= 1 || a5 <= 1;
  if (v8)
  {
    v9 = a5;
  }
  else
  {
    v10 = (int)(a4 & 0xFFFFFFFE);
    v11 = 8 * v6;
    do
    {
      if (a6 >= 4)
      {
        v12 = 0;
        result = *a2;
        v13 = a2[1];
        do
        {
          v14 = 2 * v12;
          v15 = *(uint16x4_t *)(v13 + 2 * v12);
          if (v6 < 3)
          {
            v17 = 2;
          }
          else
          {
            v16 = 16;
            do
            {
              v15 = vmin_u16(*(uint16x4_t *)(a2[(unint64_t)v16 / 8] + 2 * v12), v15);
              v16 += 8;
            }
            while (v11 != v16);
            v17 = v6;
          }
          v18 = (unsigned __int16 *)(result + 2 * v12);
          v19 = *v18;
          if (v19 >= v15.u16[0])
            LOWORD(v19) = v15.i16[0];
          *(_WORD *)(a3 + 2 * v12) = v19;
          v20 = v18[1];
          if (v20 >= v15.u16[1])
            LOWORD(v20) = v15.i16[1];
          *(_WORD *)(a3 + (v14 | 2)) = v20;
          v21 = v18[2];
          if (v21 >= v15.u16[2])
            LOWORD(v21) = v15.i16[2];
          *(_WORD *)(a3 + (v14 | 4)) = v21;
          v22 = v18[3];
          if (v22 >= v15.u16[3])
            LOWORD(v22) = v15.i16[3];
          *(_WORD *)(a3 + (v14 | 6)) = v22;
          v23 = (unsigned __int16 *)(a2[v17] + 2 * v12);
          v24 = *v23;
          if (v24 >= v15.u16[0])
            LOWORD(v24) = v15.i16[0];
          v25 = (_WORD *)(a3 + 2 * (v12 + v7));
          *v25 = v24;
          v26 = v23[1];
          if (v26 >= v15.u16[1])
            LOWORD(v26) = v15.i16[1];
          v25[1] = v26;
          v27 = v23[2];
          if (v27 >= v15.u16[2])
            LOWORD(v27) = v15.i16[2];
          v25[2] = v27;
          v28 = v23[3];
          if (v28 >= v15.u16[3])
            LOWORD(v28) = v15.i16[3];
          v25[3] = v28;
          v12 += 4;
        }
        while (v12 <= a6 - 4);
        v12 = v12;
      }
      else
      {
        v12 = 0;
      }
      if ((int)v12 < a6)
      {
        result = *a2;
        v29 = a2[1];
        do
        {
          v30 = *(unsigned __int16 *)(v29 + 2 * v12);
          if (v6 < 3)
          {
            v32 = 2;
          }
          else
          {
            v31 = 16;
            do
            {
              if (*(unsigned __int16 *)(a2[(unint64_t)v31 / 8] + 2 * v12) >= (unsigned __int16)v30)
                v30 = (unsigned __int16)v30;
              else
                v30 = *(unsigned __int16 *)(a2[(unint64_t)v31 / 8] + 2 * v12);
              v31 += 8;
            }
            while (v11 != v31);
            v32 = v6;
          }
          v33 = *(unsigned __int16 *)(result + 2 * v12);
          if (v33 >= v30)
            LOWORD(v33) = v30;
          *(_WORD *)(a3 + 2 * v12) = v33;
          v34 = *(unsigned __int16 *)(a2[v32] + 2 * v12);
          if (v34 < v30)
            LOWORD(v30) = v34;
          *(_WORD *)(a3 + 2 * (v12 + v7)) = v30;
          ++v12;
        }
        while (v12 != a6);
      }
      v9 = a5 - 2;
      a3 += 2 * v10;
      a2 += 2;
      v8 = a5 <= 3;
      a5 -= 2;
    }
    while (!v8);
  }
  if (v9 >= 1)
  {
    v35 = 8 * v6;
    do
    {
      if (a6 >= 4)
      {
        v36 = 0;
        v37 = *a2;
        do
        {
          v38 = *(uint16x4_t *)(v37 + 2 * v36);
          if ((int)v6 >= 2)
          {
            v39 = 8;
            do
            {
              result = a2[(unint64_t)v39 / 8];
              v38 = vmin_u16(*(uint16x4_t *)(result + 2 * v36), v38);
              v39 += 8;
            }
            while (v35 != v39);
          }
          *(uint16x4_t *)(a3 + 2 * v36) = v38;
          v36 += 4;
        }
        while (v36 <= a6 - 4);
        v36 = v36;
      }
      else
      {
        v36 = 0;
      }
      if ((int)v36 < a6)
      {
        v40 = *a2;
        do
        {
          v41 = *(_WORD *)(v40 + 2 * v36);
          if ((int)v6 >= 2)
          {
            v42 = 8;
            do
            {
              result = *(unsigned __int16 *)(a2[(unint64_t)v42 / 8] + 2 * v36);
              if (result < v41)
                v41 = *(_WORD *)(a2[(unint64_t)v42 / 8] + 2 * v36);
              v42 += 8;
            }
            while (v35 != v42);
          }
          *(_WORD *)(a3 + 2 * v36++) = v41;
        }
        while (v36 != a6);
      }
      a3 += 2 * v7;
      ++a2;
      v43 = __OFSUB__(v9--, 1);
    }
    while (!((v9 < 0) ^ v43 | (v9 == 0)));
  }
  return result;
}

void cv::MorphColumnFilter<cv::MinOp<short>,cv::MorphColumnNoVec>::~MorphColumnFilter(cv::BaseRowFilter *a1)
{
  cv::BaseRowFilter::~BaseRowFilter(a1);
  JUMPOUT(0x2207351BCLL);
}

uint64_t cv::MorphColumnFilter<cv::MinOp<short>,cv::MorphColumnNoVec>::operator()(uint64_t result, uint64_t *a2, uint64_t a3, int a4, int a5, int a6)
{
  uint64_t v6;
  int v7;
  BOOL v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int16x4_t v15;
  uint64_t v16;
  unsigned int v17;
  __int16 *v18;
  int v19;
  int v20;
  int v21;
  int v22;
  __int16 *v23;
  int v24;
  _WORD *v25;
  int v26;
  int v27;
  int v28;
  uint64_t v29;
  __int16 v30;
  uint64_t v31;
  unsigned int v32;
  int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int16x4_t v38;
  uint64_t v39;
  uint64_t v40;
  __int16 v41;
  uint64_t v42;
  BOOL v43;

  v6 = *(unsigned int *)(result + 8);
  v7 = a4 >> 1;
  v8 = (int)v6 <= 1 || a5 <= 1;
  if (v8)
  {
    v9 = a5;
  }
  else
  {
    v10 = (int)(a4 & 0xFFFFFFFE);
    v11 = 8 * v6;
    do
    {
      if (a6 >= 4)
      {
        v12 = 0;
        result = *a2;
        v13 = a2[1];
        do
        {
          v14 = 2 * v12;
          v15 = *(int16x4_t *)(v13 + 2 * v12);
          if (v6 < 3)
          {
            v17 = 2;
          }
          else
          {
            v16 = 16;
            do
            {
              v15 = vmin_s16(*(int16x4_t *)(a2[(unint64_t)v16 / 8] + 2 * v12), v15);
              v16 += 8;
            }
            while (v11 != v16);
            v17 = v6;
          }
          v18 = (__int16 *)(result + 2 * v12);
          v19 = *v18;
          if (v19 >= v15.i16[0])
            LOWORD(v19) = v15.i16[0];
          *(_WORD *)(a3 + 2 * v12) = v19;
          v20 = v18[1];
          if (v20 >= v15.i16[1])
            LOWORD(v20) = v15.i16[1];
          *(_WORD *)(a3 + (v14 | 2)) = v20;
          v21 = v18[2];
          if (v21 >= v15.i16[2])
            LOWORD(v21) = v15.i16[2];
          *(_WORD *)(a3 + (v14 | 4)) = v21;
          v22 = v18[3];
          if (v22 >= v15.i16[3])
            LOWORD(v22) = v15.i16[3];
          *(_WORD *)(a3 + (v14 | 6)) = v22;
          v23 = (__int16 *)(a2[v17] + 2 * v12);
          v24 = *v23;
          if (v24 >= v15.i16[0])
            LOWORD(v24) = v15.i16[0];
          v25 = (_WORD *)(a3 + 2 * (v12 + v7));
          *v25 = v24;
          v26 = v23[1];
          if (v26 >= v15.i16[1])
            LOWORD(v26) = v15.i16[1];
          v25[1] = v26;
          v27 = v23[2];
          if (v27 >= v15.i16[2])
            LOWORD(v27) = v15.i16[2];
          v25[2] = v27;
          v28 = v23[3];
          if (v28 >= v15.i16[3])
            LOWORD(v28) = v15.i16[3];
          v25[3] = v28;
          v12 += 4;
        }
        while (v12 <= a6 - 4);
        v12 = v12;
      }
      else
      {
        v12 = 0;
      }
      if ((int)v12 < a6)
      {
        result = *a2;
        v29 = a2[1];
        do
        {
          v30 = *(_WORD *)(v29 + 2 * v12);
          if (v6 < 3)
          {
            v32 = 2;
          }
          else
          {
            v31 = 16;
            do
            {
              if (*(__int16 *)(a2[(unint64_t)v31 / 8] + 2 * v12) < v30)
                v30 = *(_WORD *)(a2[(unint64_t)v31 / 8] + 2 * v12);
              v31 += 8;
            }
            while (v11 != v31);
            v32 = v6;
          }
          v33 = *(__int16 *)(result + 2 * v12);
          if (v33 >= v30)
            LOWORD(v33) = v30;
          *(_WORD *)(a3 + 2 * v12) = v33;
          v34 = *(__int16 *)(a2[v32] + 2 * v12);
          if (v34 < v30)
            v30 = v34;
          *(_WORD *)(a3 + 2 * (v12 + v7)) = v30;
          ++v12;
        }
        while (v12 != a6);
      }
      v9 = a5 - 2;
      a3 += 2 * v10;
      a2 += 2;
      v8 = a5 <= 3;
      a5 -= 2;
    }
    while (!v8);
  }
  if (v9 >= 1)
  {
    v35 = 8 * v6;
    do
    {
      if (a6 >= 4)
      {
        v36 = 0;
        v37 = *a2;
        do
        {
          v38 = *(int16x4_t *)(v37 + 2 * v36);
          if ((int)v6 >= 2)
          {
            v39 = 8;
            do
            {
              result = a2[(unint64_t)v39 / 8];
              v38 = vmin_s16(*(int16x4_t *)(result + 2 * v36), v38);
              v39 += 8;
            }
            while (v35 != v39);
          }
          *(int16x4_t *)(a3 + 2 * v36) = v38;
          v36 += 4;
        }
        while (v36 <= a6 - 4);
        v36 = v36;
      }
      else
      {
        v36 = 0;
      }
      if ((int)v36 < a6)
      {
        v40 = *a2;
        do
        {
          v41 = *(_WORD *)(v40 + 2 * v36);
          if ((int)v6 >= 2)
          {
            v42 = 8;
            do
            {
              result = *(__int16 *)(a2[(unint64_t)v42 / 8] + 2 * v36);
              if ((int)result < v41)
                v41 = *(_WORD *)(a2[(unint64_t)v42 / 8] + 2 * v36);
              v42 += 8;
            }
            while (v35 != v42);
          }
          *(_WORD *)(a3 + 2 * v36++) = v41;
        }
        while (v36 != a6);
      }
      a3 += 2 * v7;
      ++a2;
      v43 = __OFSUB__(v9--, 1);
    }
    while (!((v9 < 0) ^ v43 | (v9 == 0)));
  }
  return result;
}

void cv::MorphColumnFilter<cv::MinOp<float>,cv::MorphColumnNoVec>::~MorphColumnFilter(cv::BaseRowFilter *a1)
{
  cv::BaseRowFilter::~BaseRowFilter(a1);
  JUMPOUT(0x2207351BCLL);
}

uint64_t cv::MorphColumnFilter<cv::MinOp<float>,cv::MorphColumnNoVec>::operator()(uint64_t result, uint64_t *a2, uint64_t a3, int a4, int a5, int a6)
{
  uint64_t v6;
  int v7;
  BOOL v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float32x4_t v14;
  uint64_t v15;
  float32x4_t v16;
  unsigned int v17;
  float *v18;
  float v19;
  float v20;
  float v21;
  float v22;
  __int32 *v23;
  _DWORD *v24;
  uint64_t v25;
  float v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  float v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  float32x4_t v35;
  uint64_t v36;
  uint64_t v37;
  float v38;
  uint64_t v39;
  uint64_t v40;
  BOOL v41;

  v6 = *(unsigned int *)(result + 8);
  v7 = a4 >> 2;
  v8 = (int)v6 <= 1 || a5 <= 1;
  if (v8)
  {
    v9 = a5;
  }
  else
  {
    v10 = 8 * v6;
    do
    {
      if (a6 >= 4)
      {
        v11 = 0;
        result = *a2;
        v12 = a2[1];
        do
        {
          v13 = 4 * v11;
          v14 = *(float32x4_t *)(v12 + 4 * v11);
          if (v6 < 3)
          {
            v17 = 2;
          }
          else
          {
            v15 = 16;
            do
            {
              v16 = *(float32x4_t *)(a2[(unint64_t)v15 / 8] + 4 * v11);
              v14 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v14, v16), (int8x16_t)v16, (int8x16_t)v14);
              v15 += 8;
            }
            while (v10 != v15);
            v17 = v6;
          }
          v18 = (float *)(result + 4 * v11);
          v19 = *v18;
          if (*v18 >= v14.f32[0])
            v19 = v14.f32[0];
          *(float *)(a3 + 4 * v11) = v19;
          v20 = v18[1];
          if (v20 >= v14.f32[1])
            v20 = v14.f32[1];
          *(float *)(a3 + (v13 | 4)) = v20;
          v21 = v18[2];
          if (v21 >= v14.f32[2])
            v21 = v14.f32[2];
          *(float *)(a3 + (v13 | 8)) = v21;
          v22 = v18[3];
          if (v22 >= v14.f32[3])
            v22 = v14.f32[3];
          *(float *)(a3 + (v13 | 0xC)) = v22;
          v23 = (__int32 *)(a2[v17] + 4 * v11);
          if (*(float *)v23 < v14.f32[0])
            v14.i32[0] = *v23;
          v24 = (_DWORD *)(a3 + 4 * (v11 + v7));
          *v24 = v14.i32[0];
          v14.i32[0] = v23[1];
          if (v14.f32[0] >= v14.f32[1])
            v14.f32[0] = v14.f32[1];
          v24[1] = v14.i32[0];
          v14.i32[0] = v23[2];
          if (v14.f32[0] >= v14.f32[2])
            v14.f32[0] = v14.f32[2];
          v24[2] = v14.i32[0];
          v14.i32[0] = v23[3];
          if (v14.f32[0] >= v14.f32[3])
            v14.f32[0] = v14.f32[3];
          v24[3] = v14.i32[0];
          v11 += 4;
        }
        while (v11 <= a6 - 4);
        v11 = v11;
      }
      else
      {
        v11 = 0;
      }
      if ((int)v11 < a6)
      {
        result = *a2;
        v25 = a2[1];
        do
        {
          v26 = *(float *)(v25 + 4 * v11);
          if (v6 < 3)
          {
            v29 = 2;
          }
          else
          {
            v27 = 16;
            do
            {
              v28 = a2[(unint64_t)v27 / 8];
              if (*(float *)(v28 + 4 * v11) < v26)
                v26 = *(float *)(v28 + 4 * v11);
              v27 += 8;
            }
            while (v10 != v27);
            v29 = v6;
          }
          v30 = *(float *)(result + 4 * v11);
          if (v30 >= v26)
            v30 = v26;
          *(float *)(a3 + 4 * v11) = v30;
          v31 = a2[v29];
          if (*(float *)(v31 + 4 * v11) < v26)
            v26 = *(float *)(v31 + 4 * v11);
          *(float *)(a3 + 4 * (v11 + v7)) = v26;
          ++v11;
        }
        while (v11 != a6);
      }
      v9 = a5 - 2;
      a3 += 8 * v7;
      a2 += 2;
      v8 = a5 <= 3;
      a5 -= 2;
    }
    while (!v8);
  }
  if (v9 >= 1)
  {
    v32 = 8 * v6;
    do
    {
      if (a6 >= 4)
      {
        v33 = 0;
        v34 = *a2;
        do
        {
          v35 = *(float32x4_t *)(v34 + 4 * v33);
          if ((int)v6 >= 2)
          {
            v36 = 8;
            do
            {
              result = a2[(unint64_t)v36 / 8];
              v35 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v35, *(float32x4_t *)(result + 4 * v33)), *(int8x16_t *)(result + 4 * v33), (int8x16_t)v35);
              v36 += 8;
            }
            while (v32 != v36);
          }
          *(float32x4_t *)(a3 + 4 * v33) = v35;
          v33 += 4;
        }
        while (v33 <= a6 - 4);
        v33 = v33;
      }
      else
      {
        v33 = 0;
      }
      if ((int)v33 < a6)
      {
        v37 = *a2;
        do
        {
          v38 = *(float *)(v37 + 4 * v33);
          if ((int)v6 >= 2)
          {
            v39 = 8;
            do
            {
              v40 = a2[(unint64_t)v39 / 8];
              if (*(float *)(v40 + 4 * v33) < v38)
                v38 = *(float *)(v40 + 4 * v33);
              v39 += 8;
            }
            while (v32 != v39);
          }
          *(float *)(a3 + 4 * v33++) = v38;
        }
        while (v33 != a6);
      }
      a3 += 4 * v7;
      ++a2;
      v41 = __OFSUB__(v9--, 1);
    }
    while (!((v9 < 0) ^ v41 | (v9 == 0)));
  }
  return result;
}

void cv::MorphColumnFilter<cv::MinOp<double>,cv::MorphColumnNoVec>::~MorphColumnFilter(cv::BaseRowFilter *a1)
{
  cv::BaseRowFilter::~BaseRowFilter(a1);
  JUMPOUT(0x2207351BCLL);
}

uint64_t cv::MorphColumnFilter<cv::MinOp<double>,cv::MorphColumnNoVec>::operator()(uint64_t result, uint64_t *a2, uint64_t a3, int a4, int a5, int a6)
{
  uint64_t v6;
  int v7;
  BOOL v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  double *v13;
  double v14;
  double v15;
  double v16;
  double v17;
  uint64_t v18;
  double *v19;
  unsigned int v20;
  double *v21;
  uint64_t v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double *v27;
  double *v28;
  uint64_t v29;
  double v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  double v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  float64x2_t *v39;
  float64x2_t v40;
  float64x2_t v41;
  uint64_t v42;
  float64x2_t *v43;
  uint64_t v44;
  double v45;
  uint64_t v46;
  uint64_t v47;
  BOOL v48;

  v6 = *(unsigned int *)(result + 8);
  v7 = a4 >> 3;
  v8 = (int)v6 <= 1 || a5 <= 1;
  if (v8)
  {
    v9 = a5;
  }
  else
  {
    v10 = 8 * v6;
    do
    {
      if (a6 >= 4)
      {
        v11 = 0;
        result = *a2;
        v12 = a2[1];
        do
        {
          v13 = (double *)(v12 + 8 * v11);
          v15 = *v13;
          v14 = v13[1];
          v17 = v13[2];
          v16 = v13[3];
          if (v6 < 3)
          {
            v20 = 2;
          }
          else
          {
            v18 = 16;
            do
            {
              v19 = (double *)(a2[(unint64_t)v18 / 8] + 8 * v11);
              if (*v19 < v15)
                v15 = *v19;
              if (v19[1] < v14)
                v14 = v19[1];
              if (v19[2] < v17)
                v17 = v19[2];
              if (v19[3] < v16)
                v16 = v19[3];
              v18 += 8;
            }
            while (v10 != v18);
            v20 = v6;
          }
          v21 = (double *)(result + 8 * v11);
          v22 = 8 * v11;
          v23 = *v21;
          if (*v21 >= v15)
            v23 = v15;
          *(double *)(a3 + 8 * v11) = v23;
          v24 = v21[1];
          if (v24 >= v14)
            v24 = v14;
          *(double *)(a3 + (v22 | 8)) = v24;
          v25 = v21[2];
          if (v25 >= v17)
            v25 = v17;
          *(double *)(a3 + (v22 | 0x10)) = v25;
          v26 = v21[3];
          if (v26 >= v16)
            v26 = v16;
          *(double *)(a3 + (v22 | 0x18)) = v26;
          v27 = (double *)(a2[v20] + 8 * v11);
          if (*v27 < v15)
            v15 = *v27;
          v28 = (double *)(a3 + 8 * (v11 + v7));
          *v28 = v15;
          if (v27[1] < v14)
            v14 = v27[1];
          v28[1] = v14;
          if (v27[2] < v17)
            v17 = v27[2];
          v28[2] = v17;
          if (v27[3] < v16)
            v16 = v27[3];
          v28[3] = v16;
          v11 += 4;
        }
        while (v11 <= a6 - 4);
        v11 = v11;
      }
      else
      {
        v11 = 0;
      }
      if ((int)v11 < a6)
      {
        result = *a2;
        v29 = a2[1];
        do
        {
          v30 = *(double *)(v29 + 8 * v11);
          if (v6 < 3)
          {
            v33 = 2;
          }
          else
          {
            v31 = 16;
            do
            {
              v32 = a2[(unint64_t)v31 / 8];
              if (*(double *)(v32 + 8 * v11) < v30)
                v30 = *(double *)(v32 + 8 * v11);
              v31 += 8;
            }
            while (v10 != v31);
            v33 = v6;
          }
          v34 = *(double *)(result + 8 * v11);
          if (v34 >= v30)
            v34 = v30;
          *(double *)(a3 + 8 * v11) = v34;
          v35 = a2[v33];
          if (*(double *)(v35 + 8 * v11) < v30)
            v30 = *(double *)(v35 + 8 * v11);
          *(double *)(a3 + 8 * (v11 + v7)) = v30;
          ++v11;
        }
        while (v11 != a6);
      }
      v9 = a5 - 2;
      a3 += 16 * v7;
      a2 += 2;
      v8 = a5 <= 3;
      a5 -= 2;
    }
    while (!v8);
  }
  if (v9 >= 1)
  {
    v36 = 8 * v6;
    do
    {
      if (a6 >= 4)
      {
        v37 = 0;
        v38 = *a2;
        do
        {
          v39 = (float64x2_t *)(v38 + 8 * v37);
          v41 = *v39;
          v40 = v39[1];
          if ((int)v6 >= 2)
          {
            v42 = 8;
            do
            {
              v43 = (float64x2_t *)(a2[(unint64_t)v42 / 8] + 8 * v37);
              v41 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v41, *v43), *(int8x16_t *)v43, (int8x16_t)v41);
              v40 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v40, v43[1]), (int8x16_t)v43[1], (int8x16_t)v40);
              v42 += 8;
            }
            while (v36 != v42);
          }
          *(float64x2_t *)(a3 + 8 * v37) = v41;
          *(float64x2_t *)(a3 + ((8 * v37) | 0x10)) = v40;
          v37 += 4;
        }
        while (v37 <= a6 - 4);
        v37 = v37;
      }
      else
      {
        v37 = 0;
      }
      if ((int)v37 < a6)
      {
        v44 = *a2;
        do
        {
          v45 = *(double *)(v44 + 8 * v37);
          if ((int)v6 >= 2)
          {
            v46 = 8;
            do
            {
              v47 = a2[(unint64_t)v46 / 8];
              if (*(double *)(v47 + 8 * v37) < v45)
                v45 = *(double *)(v47 + 8 * v37);
              v46 += 8;
            }
            while (v36 != v46);
          }
          *(double *)(a3 + 8 * v37++) = v45;
        }
        while (v37 != a6);
      }
      a3 += 8 * v7;
      ++a2;
      v48 = __OFSUB__(v9--, 1);
    }
    while (!((v9 < 0) ^ v48 | (v9 == 0)));
  }
  return result;
}

void cv::MorphColumnFilter<cv::MaxOp<unsigned char>,cv::MorphColumnNoVec>::~MorphColumnFilter(cv::BaseRowFilter *a1)
{
  cv::BaseRowFilter::~BaseRowFilter(a1);
  JUMPOUT(0x2207351BCLL);
}

uint64_t cv::MorphColumnFilter<cv::MaxOp<unsigned char>,cv::MorphColumnNoVec>::operator()(uint64_t result, _QWORD *a2, uint64_t a3, int a4, int a5, int a6)
{
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 *v12;
  unsigned __int8 v13;
  unsigned __int8 v14;
  unsigned __int8 v15;
  unsigned __int8 v16;
  uint64_t v17;
  unsigned __int8 *v18;
  unsigned int v19;
  unsigned __int8 *v20;
  unsigned __int8 *v21;
  unsigned __int8 *v22;
  unsigned __int8 *v23;
  unsigned __int8 *v24;
  unsigned __int8 *v25;
  _BYTE *v26;
  unsigned __int8 v27;
  uint64_t v28;
  unsigned int v29;
  unsigned __int8 *v30;
  char v31;
  uint64_t v32;
  uint64_t v33;
  unsigned __int8 *v34;
  unsigned __int8 v35;
  unsigned __int8 v36;
  unsigned __int8 v37;
  uint64_t v38;
  unsigned __int8 *v39;
  unsigned __int8 v40;
  uint64_t v41;
  BOOL v42;

  v6 = *(unsigned int *)(result + 8);
  v7 = a4;
  v8 = (int)v6 <= 1 || a5 <= 1;
  if (v8)
  {
    v9 = a5;
  }
  else
  {
    v10 = 8 * v6;
    do
    {
      if (a6 >= 4)
      {
        v11 = 0;
        do
        {
          v12 = (unsigned __int8 *)(a2[1] + v11);
          v13 = *v12;
          v14 = v12[1];
          v15 = v12[2];
          v16 = v12[3];
          if (v6 < 3)
          {
            v19 = 2;
          }
          else
          {
            v17 = 16;
            do
            {
              v18 = (unsigned __int8 *)(a2[(unint64_t)v17 / 8] + v11);
              v13 += icvSaturate8u_cv[*v18 - v13 + 256];
              v14 += icvSaturate8u_cv[v18[1] - v14 + 256];
              v15 += icvSaturate8u_cv[v18[2] - v15 + 256];
              v16 += icvSaturate8u_cv[v18[3] - v16 + 256];
              v17 += 8;
            }
            while (v10 != v17);
            v19 = v6;
          }
          v20 = (unsigned __int8 *)(*a2 + v11);
          v21 = &icvSaturate8u_cv[-v13];
          *(_BYTE *)(a3 + v11) = v21[*v20 + 256] + v13;
          v22 = &icvSaturate8u_cv[-v14];
          *(_BYTE *)(a3 + (v11 | 1)) = v22[v20[1] + 256] + v14;
          v23 = &icvSaturate8u_cv[-v15];
          *(_BYTE *)(a3 + (v11 | 2)) = v23[v20[2] + 256] + v15;
          v24 = &icvSaturate8u_cv[-v16];
          *(_BYTE *)(a3 + (v11 | 3)) = v24[v20[3] + 256] + v16;
          v25 = (unsigned __int8 *)(a2[v19] + v11);
          v26 = (_BYTE *)(a3 + v11 + v7);
          *v26 = v21[*v25 + 256] + v13;
          v26[1] = v22[v25[1] + 256] + v14;
          v26[2] = v23[v25[2] + 256] + v15;
          result = v24[v25[3] + 256];
          v26[3] = result + v16;
          v11 += 4;
        }
        while (v11 <= a6 - 4);
        v11 = v11;
      }
      else
      {
        v11 = 0;
      }
      if ((int)v11 < a6)
      {
        do
        {
          v27 = *(_BYTE *)(a2[1] + v11);
          if (v6 < 3)
          {
            v29 = 2;
          }
          else
          {
            v28 = 16;
            do
            {
              v27 += icvSaturate8u_cv[*(unsigned __int8 *)(a2[(unint64_t)v28 / 8] + v11) - v27 + 256];
              v28 += 8;
            }
            while (v10 != v28);
            v29 = v6;
          }
          v30 = &icvSaturate8u_cv[-v27];
          *(_BYTE *)(a3 + v11) = v30[*(unsigned __int8 *)(*a2 + v11) + 256] + v27;
          v31 = v30[*(unsigned __int8 *)(a2[v29] + v11) + 256] + v27;
          result = v11 + v7;
          *(_BYTE *)(a3 + v11 + v7) = v31;
          ++v11;
        }
        while (v11 != a6);
      }
      v9 = a5 - 2;
      a3 += 2 * v7;
      a2 += 2;
      v8 = a5 <= 3;
      a5 -= 2;
    }
    while (!v8);
  }
  if (v9 >= 1)
  {
    v32 = 8 * v6;
    do
    {
      if (a6 >= 4)
      {
        v33 = 0;
        do
        {
          v34 = (unsigned __int8 *)(*a2 + v33);
          v35 = *v34;
          v36 = v34[1];
          result = v34[2];
          v37 = v34[3];
          if ((int)v6 >= 2)
          {
            v38 = 8;
            do
            {
              v39 = (unsigned __int8 *)(a2[(unint64_t)v38 / 8] + v33);
              v35 += icvSaturate8u_cv[*v39 - v35 + 256];
              v36 += icvSaturate8u_cv[v39[1] - v36 + 256];
              result = icvSaturate8u_cv[v39[2] - result + 256] + result;
              v37 += icvSaturate8u_cv[v39[3] - v37 + 256];
              v38 += 8;
            }
            while (v32 != v38);
          }
          *(_BYTE *)(a3 + v33) = v35;
          *(_BYTE *)(a3 + (v33 | 1)) = v36;
          *(_BYTE *)(a3 + (v33 | 2)) = result;
          *(_BYTE *)(a3 + (v33 | 3)) = v37;
          v33 += 4;
        }
        while (v33 <= a6 - 4);
        v33 = v33;
      }
      else
      {
        v33 = 0;
      }
      if ((int)v33 < a6)
      {
        do
        {
          v40 = *(_BYTE *)(*a2 + v33);
          if ((int)v6 >= 2)
          {
            v41 = 8;
            do
            {
              result = icvSaturate8u_cv[*(unsigned __int8 *)(a2[(unint64_t)v41 / 8] + v33) - v40 + 256];
              v40 += result;
              v41 += 8;
            }
            while (v32 != v41);
          }
          *(_BYTE *)(a3 + v33++) = v40;
        }
        while (v33 != a6);
      }
      a3 += v7;
      ++a2;
      v42 = __OFSUB__(v9--, 1);
    }
    while (!((v9 < 0) ^ v42 | (v9 == 0)));
  }
  return result;
}

void cv::MorphColumnFilter<cv::MaxOp<unsigned short>,cv::MorphColumnNoVec>::~MorphColumnFilter(cv::BaseRowFilter *a1)
{
  cv::BaseRowFilter::~BaseRowFilter(a1);
  JUMPOUT(0x2207351BCLL);
}

uint64_t cv::MorphColumnFilter<cv::MaxOp<unsigned short>,cv::MorphColumnNoVec>::operator()(uint64_t result, uint64_t *a2, uint64_t a3, int a4, int a5, int a6)
{
  uint64_t v6;
  int v7;
  BOOL v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint16x4_t v15;
  uint64_t v16;
  unsigned int v17;
  unsigned __int16 *v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned __int16 *v23;
  unsigned int v24;
  _WORD *v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint16x4_t v38;
  uint64_t v39;
  uint64_t v40;
  unsigned __int16 v41;
  uint64_t v42;
  BOOL v43;

  v6 = *(unsigned int *)(result + 8);
  v7 = a4 >> 1;
  v8 = (int)v6 <= 1 || a5 <= 1;
  if (v8)
  {
    v9 = a5;
  }
  else
  {
    v10 = (int)(a4 & 0xFFFFFFFE);
    v11 = 8 * v6;
    do
    {
      if (a6 >= 4)
      {
        v12 = 0;
        result = *a2;
        v13 = a2[1];
        do
        {
          v14 = 2 * v12;
          v15 = *(uint16x4_t *)(v13 + 2 * v12);
          if (v6 < 3)
          {
            v17 = 2;
          }
          else
          {
            v16 = 16;
            do
            {
              v15 = vmax_u16(v15, *(uint16x4_t *)(a2[(unint64_t)v16 / 8] + 2 * v12));
              v16 += 8;
            }
            while (v11 != v16);
            v17 = v6;
          }
          v18 = (unsigned __int16 *)(result + 2 * v12);
          v19 = *v18;
          if (v15.u16[0] > v19)
            LOWORD(v19) = v15.i16[0];
          *(_WORD *)(a3 + 2 * v12) = v19;
          v20 = v18[1];
          if (v15.u16[1] > v20)
            LOWORD(v20) = v15.i16[1];
          *(_WORD *)(a3 + (v14 | 2)) = v20;
          v21 = v18[2];
          if (v15.u16[2] > v21)
            LOWORD(v21) = v15.i16[2];
          *(_WORD *)(a3 + (v14 | 4)) = v21;
          v22 = v18[3];
          if (v15.u16[3] > v22)
            LOWORD(v22) = v15.i16[3];
          *(_WORD *)(a3 + (v14 | 6)) = v22;
          v23 = (unsigned __int16 *)(a2[v17] + 2 * v12);
          v24 = *v23;
          if (v15.u16[0] > v24)
            LOWORD(v24) = v15.i16[0];
          v25 = (_WORD *)(a3 + 2 * (v12 + v7));
          *v25 = v24;
          v26 = v23[1];
          if (v15.u16[1] > v26)
            LOWORD(v26) = v15.i16[1];
          v25[1] = v26;
          v27 = v23[2];
          if (v15.u16[2] > v27)
            LOWORD(v27) = v15.i16[2];
          v25[2] = v27;
          v28 = v23[3];
          if (v15.u16[3] > v28)
            LOWORD(v28) = v15.i16[3];
          v25[3] = v28;
          v12 += 4;
        }
        while (v12 <= a6 - 4);
        v12 = v12;
      }
      else
      {
        v12 = 0;
      }
      if ((int)v12 < a6)
      {
        result = *a2;
        v29 = a2[1];
        do
        {
          v30 = *(unsigned __int16 *)(v29 + 2 * v12);
          if (v6 < 3)
          {
            v32 = 2;
          }
          else
          {
            v31 = 16;
            do
            {
              v30 = (unsigned __int16)v30;
              if ((unsigned __int16)v30 <= *(unsigned __int16 *)(a2[(unint64_t)v31 / 8] + 2 * v12))
                v30 = *(unsigned __int16 *)(a2[(unint64_t)v31 / 8] + 2 * v12);
              v31 += 8;
            }
            while (v11 != v31);
            v32 = v6;
          }
          v33 = *(unsigned __int16 *)(result + 2 * v12);
          if (v30 > v33)
            LOWORD(v33) = v30;
          *(_WORD *)(a3 + 2 * v12) = v33;
          v34 = *(unsigned __int16 *)(a2[v32] + 2 * v12);
          if (v30 <= v34)
            LOWORD(v30) = v34;
          *(_WORD *)(a3 + 2 * (v12 + v7)) = v30;
          ++v12;
        }
        while (v12 != a6);
      }
      v9 = a5 - 2;
      a3 += 2 * v10;
      a2 += 2;
      v8 = a5 <= 3;
      a5 -= 2;
    }
    while (!v8);
  }
  if (v9 >= 1)
  {
    v35 = 8 * v6;
    do
    {
      if (a6 >= 4)
      {
        v36 = 0;
        v37 = *a2;
        do
        {
          v38 = *(uint16x4_t *)(v37 + 2 * v36);
          if ((int)v6 >= 2)
          {
            v39 = 8;
            do
            {
              result = a2[(unint64_t)v39 / 8];
              v38 = vmax_u16(v38, *(uint16x4_t *)(result + 2 * v36));
              v39 += 8;
            }
            while (v35 != v39);
          }
          *(uint16x4_t *)(a3 + 2 * v36) = v38;
          v36 += 4;
        }
        while (v36 <= a6 - 4);
        v36 = v36;
      }
      else
      {
        v36 = 0;
      }
      if ((int)v36 < a6)
      {
        v40 = *a2;
        do
        {
          v41 = *(_WORD *)(v40 + 2 * v36);
          if ((int)v6 >= 2)
          {
            v42 = 8;
            do
            {
              result = *(unsigned __int16 *)(a2[(unint64_t)v42 / 8] + 2 * v36);
              if (v41 <= result)
                v41 = *(_WORD *)(a2[(unint64_t)v42 / 8] + 2 * v36);
              v42 += 8;
            }
            while (v35 != v42);
          }
          *(_WORD *)(a3 + 2 * v36++) = v41;
        }
        while (v36 != a6);
      }
      a3 += 2 * v7;
      ++a2;
      v43 = __OFSUB__(v9--, 1);
    }
    while (!((v9 < 0) ^ v43 | (v9 == 0)));
  }
  return result;
}

void cv::MorphColumnFilter<cv::MaxOp<short>,cv::MorphColumnNoVec>::~MorphColumnFilter(cv::BaseRowFilter *a1)
{
  cv::BaseRowFilter::~BaseRowFilter(a1);
  JUMPOUT(0x2207351BCLL);
}

uint64_t cv::MorphColumnFilter<cv::MaxOp<short>,cv::MorphColumnNoVec>::operator()(uint64_t result, uint64_t *a2, uint64_t a3, int a4, int a5, int a6)
{
  uint64_t v6;
  int v7;
  BOOL v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int16x4_t v15;
  uint64_t v16;
  unsigned int v17;
  __int16 *v18;
  int v19;
  int v20;
  int v21;
  int v22;
  __int16 *v23;
  int v24;
  _WORD *v25;
  int v26;
  int v27;
  int v28;
  uint64_t v29;
  __int16 v30;
  uint64_t v31;
  unsigned int v32;
  int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int16x4_t v38;
  uint64_t v39;
  uint64_t v40;
  __int16 v41;
  uint64_t v42;
  BOOL v43;

  v6 = *(unsigned int *)(result + 8);
  v7 = a4 >> 1;
  v8 = (int)v6 <= 1 || a5 <= 1;
  if (v8)
  {
    v9 = a5;
  }
  else
  {
    v10 = (int)(a4 & 0xFFFFFFFE);
    v11 = 8 * v6;
    do
    {
      if (a6 >= 4)
      {
        v12 = 0;
        result = *a2;
        v13 = a2[1];
        do
        {
          v14 = 2 * v12;
          v15 = *(int16x4_t *)(v13 + 2 * v12);
          if (v6 < 3)
          {
            v17 = 2;
          }
          else
          {
            v16 = 16;
            do
            {
              v15 = vmax_s16(v15, *(int16x4_t *)(a2[(unint64_t)v16 / 8] + 2 * v12));
              v16 += 8;
            }
            while (v11 != v16);
            v17 = v6;
          }
          v18 = (__int16 *)(result + 2 * v12);
          v19 = *v18;
          if (v15.i16[0] > v19)
            LOWORD(v19) = v15.i16[0];
          *(_WORD *)(a3 + 2 * v12) = v19;
          v20 = v18[1];
          if (v15.i16[1] > v20)
            LOWORD(v20) = v15.i16[1];
          *(_WORD *)(a3 + (v14 | 2)) = v20;
          v21 = v18[2];
          if (v15.i16[2] > v21)
            LOWORD(v21) = v15.i16[2];
          *(_WORD *)(a3 + (v14 | 4)) = v21;
          v22 = v18[3];
          if (v15.i16[3] > v22)
            LOWORD(v22) = v15.i16[3];
          *(_WORD *)(a3 + (v14 | 6)) = v22;
          v23 = (__int16 *)(a2[v17] + 2 * v12);
          v24 = *v23;
          if (v15.i16[0] > v24)
            LOWORD(v24) = v15.i16[0];
          v25 = (_WORD *)(a3 + 2 * (v12 + v7));
          *v25 = v24;
          v26 = v23[1];
          if (v15.i16[1] > v26)
            LOWORD(v26) = v15.i16[1];
          v25[1] = v26;
          v27 = v23[2];
          if (v15.i16[2] > v27)
            LOWORD(v27) = v15.i16[2];
          v25[2] = v27;
          v28 = v23[3];
          if (v15.i16[3] > v28)
            LOWORD(v28) = v15.i16[3];
          v25[3] = v28;
          v12 += 4;
        }
        while (v12 <= a6 - 4);
        v12 = v12;
      }
      else
      {
        v12 = 0;
      }
      if ((int)v12 < a6)
      {
        result = *a2;
        v29 = a2[1];
        do
        {
          v30 = *(_WORD *)(v29 + 2 * v12);
          if (v6 < 3)
          {
            v32 = 2;
          }
          else
          {
            v31 = 16;
            do
            {
              if (v30 <= *(__int16 *)(a2[(unint64_t)v31 / 8] + 2 * v12))
                v30 = *(_WORD *)(a2[(unint64_t)v31 / 8] + 2 * v12);
              v31 += 8;
            }
            while (v11 != v31);
            v32 = v6;
          }
          v33 = *(__int16 *)(result + 2 * v12);
          if (v30 > v33)
            LOWORD(v33) = v30;
          *(_WORD *)(a3 + 2 * v12) = v33;
          v34 = *(__int16 *)(a2[v32] + 2 * v12);
          if (v30 <= v34)
            v30 = v34;
          *(_WORD *)(a3 + 2 * (v12 + v7)) = v30;
          ++v12;
        }
        while (v12 != a6);
      }
      v9 = a5 - 2;
      a3 += 2 * v10;
      a2 += 2;
      v8 = a5 <= 3;
      a5 -= 2;
    }
    while (!v8);
  }
  if (v9 >= 1)
  {
    v35 = 8 * v6;
    do
    {
      if (a6 >= 4)
      {
        v36 = 0;
        v37 = *a2;
        do
        {
          v38 = *(int16x4_t *)(v37 + 2 * v36);
          if ((int)v6 >= 2)
          {
            v39 = 8;
            do
            {
              result = a2[(unint64_t)v39 / 8];
              v38 = vmax_s16(v38, *(int16x4_t *)(result + 2 * v36));
              v39 += 8;
            }
            while (v35 != v39);
          }
          *(int16x4_t *)(a3 + 2 * v36) = v38;
          v36 += 4;
        }
        while (v36 <= a6 - 4);
        v36 = v36;
      }
      else
      {
        v36 = 0;
      }
      if ((int)v36 < a6)
      {
        v40 = *a2;
        do
        {
          v41 = *(_WORD *)(v40 + 2 * v36);
          if ((int)v6 >= 2)
          {
            v42 = 8;
            do
            {
              result = *(__int16 *)(a2[(unint64_t)v42 / 8] + 2 * v36);
              if (v41 <= (int)result)
                v41 = *(_WORD *)(a2[(unint64_t)v42 / 8] + 2 * v36);
              v42 += 8;
            }
            while (v35 != v42);
          }
          *(_WORD *)(a3 + 2 * v36++) = v41;
        }
        while (v36 != a6);
      }
      a3 += 2 * v7;
      ++a2;
      v43 = __OFSUB__(v9--, 1);
    }
    while (!((v9 < 0) ^ v43 | (v9 == 0)));
  }
  return result;
}

void cv::MorphColumnFilter<cv::MaxOp<float>,cv::MorphColumnNoVec>::~MorphColumnFilter(cv::BaseRowFilter *a1)
{
  cv::BaseRowFilter::~BaseRowFilter(a1);
  JUMPOUT(0x2207351BCLL);
}

uint64_t cv::MorphColumnFilter<cv::MaxOp<float>,cv::MorphColumnNoVec>::operator()(uint64_t result, uint64_t *a2, uint64_t a3, int a4, int a5, int a6)
{
  uint64_t v6;
  int v7;
  BOOL v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float32x4_t v14;
  uint64_t v15;
  float32x4_t v16;
  unsigned int v17;
  float *v18;
  float v19;
  float v20;
  float v21;
  float v22;
  __int32 *v23;
  _DWORD *v24;
  uint64_t v25;
  float v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  float v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  float32x4_t v35;
  uint64_t v36;
  uint64_t v37;
  float v38;
  uint64_t v39;
  uint64_t v40;
  BOOL v41;

  v6 = *(unsigned int *)(result + 8);
  v7 = a4 >> 2;
  v8 = (int)v6 <= 1 || a5 <= 1;
  if (v8)
  {
    v9 = a5;
  }
  else
  {
    v10 = 8 * v6;
    do
    {
      if (a6 >= 4)
      {
        v11 = 0;
        result = *a2;
        v12 = a2[1];
        do
        {
          v13 = 4 * v11;
          v14 = *(float32x4_t *)(v12 + 4 * v11);
          if (v6 < 3)
          {
            v17 = 2;
          }
          else
          {
            v15 = 16;
            do
            {
              v16 = *(float32x4_t *)(a2[(unint64_t)v15 / 8] + 4 * v11);
              v14 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v16, v14), (int8x16_t)v16, (int8x16_t)v14);
              v15 += 8;
            }
            while (v10 != v15);
            v17 = v6;
          }
          v18 = (float *)(result + 4 * v11);
          v19 = *v18;
          if (v14.f32[0] >= *v18)
            v19 = v14.f32[0];
          *(float *)(a3 + 4 * v11) = v19;
          v20 = v18[1];
          if (v14.f32[1] >= v20)
            v20 = v14.f32[1];
          *(float *)(a3 + (v13 | 4)) = v20;
          v21 = v18[2];
          if (v14.f32[2] >= v21)
            v21 = v14.f32[2];
          *(float *)(a3 + (v13 | 8)) = v21;
          v22 = v18[3];
          if (v14.f32[3] >= v22)
            v22 = v14.f32[3];
          *(float *)(a3 + (v13 | 0xC)) = v22;
          v23 = (__int32 *)(a2[v17] + 4 * v11);
          if (v14.f32[0] < *(float *)v23)
            v14.i32[0] = *v23;
          v24 = (_DWORD *)(a3 + 4 * (v11 + v7));
          *v24 = v14.i32[0];
          v14.i32[0] = v23[1];
          if (v14.f32[1] >= v14.f32[0])
            v14.f32[0] = v14.f32[1];
          v24[1] = v14.i32[0];
          v14.i32[0] = v23[2];
          if (v14.f32[2] >= v14.f32[0])
            v14.f32[0] = v14.f32[2];
          v24[2] = v14.i32[0];
          v14.i32[0] = v23[3];
          if (v14.f32[3] >= v14.f32[0])
            v14.f32[0] = v14.f32[3];
          v24[3] = v14.i32[0];
          v11 += 4;
        }
        while (v11 <= a6 - 4);
        v11 = v11;
      }
      else
      {
        v11 = 0;
      }
      if ((int)v11 < a6)
      {
        result = *a2;
        v25 = a2[1];
        do
        {
          v26 = *(float *)(v25 + 4 * v11);
          if (v6 < 3)
          {
            v29 = 2;
          }
          else
          {
            v27 = 16;
            do
            {
              v28 = a2[(unint64_t)v27 / 8];
              if (v26 < *(float *)(v28 + 4 * v11))
                v26 = *(float *)(v28 + 4 * v11);
              v27 += 8;
            }
            while (v10 != v27);
            v29 = v6;
          }
          v30 = *(float *)(result + 4 * v11);
          if (v26 >= v30)
            v30 = v26;
          *(float *)(a3 + 4 * v11) = v30;
          v31 = a2[v29];
          if (v26 < *(float *)(v31 + 4 * v11))
            v26 = *(float *)(v31 + 4 * v11);
          *(float *)(a3 + 4 * (v11 + v7)) = v26;
          ++v11;
        }
        while (v11 != a6);
      }
      v9 = a5 - 2;
      a3 += 8 * v7;
      a2 += 2;
      v8 = a5 <= 3;
      a5 -= 2;
    }
    while (!v8);
  }
  if (v9 >= 1)
  {
    v32 = 8 * v6;
    do
    {
      if (a6 >= 4)
      {
        v33 = 0;
        v34 = *a2;
        do
        {
          v35 = *(float32x4_t *)(v34 + 4 * v33);
          if ((int)v6 >= 2)
          {
            v36 = 8;
            do
            {
              result = a2[(unint64_t)v36 / 8];
              v35 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)(result + 4 * v33), v35), *(int8x16_t *)(result + 4 * v33), (int8x16_t)v35);
              v36 += 8;
            }
            while (v32 != v36);
          }
          *(float32x4_t *)(a3 + 4 * v33) = v35;
          v33 += 4;
        }
        while (v33 <= a6 - 4);
        v33 = v33;
      }
      else
      {
        v33 = 0;
      }
      if ((int)v33 < a6)
      {
        v37 = *a2;
        do
        {
          v38 = *(float *)(v37 + 4 * v33);
          if ((int)v6 >= 2)
          {
            v39 = 8;
            do
            {
              v40 = a2[(unint64_t)v39 / 8];
              if (v38 < *(float *)(v40 + 4 * v33))
                v38 = *(float *)(v40 + 4 * v33);
              v39 += 8;
            }
            while (v32 != v39);
          }
          *(float *)(a3 + 4 * v33++) = v38;
        }
        while (v33 != a6);
      }
      a3 += 4 * v7;
      ++a2;
      v41 = __OFSUB__(v9--, 1);
    }
    while (!((v9 < 0) ^ v41 | (v9 == 0)));
  }
  return result;
}

void cv::MorphColumnFilter<cv::MaxOp<double>,cv::MorphColumnNoVec>::~MorphColumnFilter(cv::BaseRowFilter *a1)
{
  cv::BaseRowFilter::~BaseRowFilter(a1);
  JUMPOUT(0x2207351BCLL);
}

uint64_t cv::MorphColumnFilter<cv::MaxOp<double>,cv::MorphColumnNoVec>::operator()(uint64_t result, uint64_t *a2, uint64_t a3, int a4, int a5, int a6)
{
  uint64_t v6;
  int v7;
  BOOL v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  double *v13;
  double v14;
  double v15;
  double v16;
  double v17;
  uint64_t v18;
  double *v19;
  unsigned int v20;
  double *v21;
  uint64_t v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double *v27;
  double *v28;
  uint64_t v29;
  double v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  double v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  float64x2_t *v39;
  float64x2_t v40;
  float64x2_t v41;
  uint64_t v42;
  float64x2_t *v43;
  uint64_t v44;
  double v45;
  uint64_t v46;
  uint64_t v47;
  BOOL v48;

  v6 = *(unsigned int *)(result + 8);
  v7 = a4 >> 3;
  v8 = (int)v6 <= 1 || a5 <= 1;
  if (v8)
  {
    v9 = a5;
  }
  else
  {
    v10 = 8 * v6;
    do
    {
      if (a6 >= 4)
      {
        v11 = 0;
        result = *a2;
        v12 = a2[1];
        do
        {
          v13 = (double *)(v12 + 8 * v11);
          v15 = *v13;
          v14 = v13[1];
          v17 = v13[2];
          v16 = v13[3];
          if (v6 < 3)
          {
            v20 = 2;
          }
          else
          {
            v18 = 16;
            do
            {
              v19 = (double *)(a2[(unint64_t)v18 / 8] + 8 * v11);
              if (v15 < *v19)
                v15 = *v19;
              if (v14 < v19[1])
                v14 = v19[1];
              if (v17 < v19[2])
                v17 = v19[2];
              if (v16 < v19[3])
                v16 = v19[3];
              v18 += 8;
            }
            while (v10 != v18);
            v20 = v6;
          }
          v21 = (double *)(result + 8 * v11);
          v22 = 8 * v11;
          v23 = *v21;
          if (v15 >= *v21)
            v23 = v15;
          *(double *)(a3 + 8 * v11) = v23;
          v24 = v21[1];
          if (v14 >= v24)
            v24 = v14;
          *(double *)(a3 + (v22 | 8)) = v24;
          v25 = v21[2];
          if (v17 >= v25)
            v25 = v17;
          *(double *)(a3 + (v22 | 0x10)) = v25;
          v26 = v21[3];
          if (v16 >= v26)
            v26 = v16;
          *(double *)(a3 + (v22 | 0x18)) = v26;
          v27 = (double *)(a2[v20] + 8 * v11);
          if (v15 < *v27)
            v15 = *v27;
          v28 = (double *)(a3 + 8 * (v11 + v7));
          *v28 = v15;
          if (v14 < v27[1])
            v14 = v27[1];
          v28[1] = v14;
          if (v17 < v27[2])
            v17 = v27[2];
          v28[2] = v17;
          if (v16 < v27[3])
            v16 = v27[3];
          v28[3] = v16;
          v11 += 4;
        }
        while (v11 <= a6 - 4);
        v11 = v11;
      }
      else
      {
        v11 = 0;
      }
      if ((int)v11 < a6)
      {
        result = *a2;
        v29 = a2[1];
        do
        {
          v30 = *(double *)(v29 + 8 * v11);
          if (v6 < 3)
          {
            v33 = 2;
          }
          else
          {
            v31 = 16;
            do
            {
              v32 = a2[(unint64_t)v31 / 8];
              if (v30 < *(double *)(v32 + 8 * v11))
                v30 = *(double *)(v32 + 8 * v11);
              v31 += 8;
            }
            while (v10 != v31);
            v33 = v6;
          }
          v34 = *(double *)(result + 8 * v11);
          if (v30 >= v34)
            v34 = v30;
          *(double *)(a3 + 8 * v11) = v34;
          v35 = a2[v33];
          if (v30 < *(double *)(v35 + 8 * v11))
            v30 = *(double *)(v35 + 8 * v11);
          *(double *)(a3 + 8 * (v11 + v7)) = v30;
          ++v11;
        }
        while (v11 != a6);
      }
      v9 = a5 - 2;
      a3 += 16 * v7;
      a2 += 2;
      v8 = a5 <= 3;
      a5 -= 2;
    }
    while (!v8);
  }
  if (v9 >= 1)
  {
    v36 = 8 * v6;
    do
    {
      if (a6 >= 4)
      {
        v37 = 0;
        v38 = *a2;
        do
        {
          v39 = (float64x2_t *)(v38 + 8 * v37);
          v41 = *v39;
          v40 = v39[1];
          if ((int)v6 >= 2)
          {
            v42 = 8;
            do
            {
              v43 = (float64x2_t *)(a2[(unint64_t)v42 / 8] + 8 * v37);
              v41 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(*v43, v41), *(int8x16_t *)v43, (int8x16_t)v41);
              v40 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v43[1], v40), (int8x16_t)v43[1], (int8x16_t)v40);
              v42 += 8;
            }
            while (v36 != v42);
          }
          *(float64x2_t *)(a3 + 8 * v37) = v41;
          *(float64x2_t *)(a3 + ((8 * v37) | 0x10)) = v40;
          v37 += 4;
        }
        while (v37 <= a6 - 4);
        v37 = v37;
      }
      else
      {
        v37 = 0;
      }
      if ((int)v37 < a6)
      {
        v44 = *a2;
        do
        {
          v45 = *(double *)(v44 + 8 * v37);
          if ((int)v6 >= 2)
          {
            v46 = 8;
            do
            {
              v47 = a2[(unint64_t)v46 / 8];
              if (v45 < *(double *)(v47 + 8 * v37))
                v45 = *(double *)(v47 + 8 * v37);
              v46 += 8;
            }
            while (v36 != v46);
          }
          *(double *)(a3 + 8 * v37++) = v45;
        }
        while (v37 != a6);
      }
      a3 += 8 * v7;
      ++a2;
      v48 = __OFSUB__(v9--, 1);
    }
    while (!((v9 < 0) ^ v48 | (v9 == 0)));
  }
  return result;
}

_QWORD *cv::MorphFilter<cv::MinOp<unsigned char>,cv::MorphNoVec>::MorphFilter(_QWORD *a1, int32x2_t **a2, _QWORD *a3)
{
  _QWORD *v6;
  uint64_t v7;
  const cv::Exception *v8;
  void *__p[2];
  void *v11[2];
  void *v12[2];
  void *v13;
  void *v14;
  uint64_t v15;

  v6 = cv::BaseFilter::BaseFilter(a1);
  *(_OWORD *)(v6 + 3) = 0u;
  *v6 = &off_24DBF0C90;
  v7 = (uint64_t)(v6 + 6);
  *(_OWORD *)(v6 + 5) = 0u;
  *(_OWORD *)(v6 + 7) = 0u;
  v6[2] = *a3;
  v6[1] = vrev64_s32(*a2[8]);
  if ((*(_WORD *)a2 & 0xFFF) != 0)
  {
    std::string::basic_string[abi:ne180100]<0>(v12, "_kernel.type() == CV_8U");
    std::string::basic_string[abi:ne180100]<0>(v11, "MorphFilter");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/imgproc/morph.cpp");
    cv::Exception::Exception(&v13, 4294967081, v12, v11, __p, 783);
    cv::error((cv *)&v13, v8);
  }
  v13 = 0;
  v14 = 0;
  v15 = 0;
  cv::preprocess2DKernel((cv::Mat *)a2, v6 + 3, (unint64_t *)&v13);
  std::vector<unsigned char *>::resize(v7, (uint64_t)(a1[4] - a1[3]) >> 3);
  if (v13)
  {
    v14 = v13;
    operator delete(v13);
  }
  return a1;
}

void sub_219E86910(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28)
{
  cv::BaseRowFilter *v28;
  void **v29;
  void **v30;
  void *v32;
  void *v33;

  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  v32 = *v30;
  if (*v30)
  {
    *((_QWORD *)v28 + 7) = v32;
    operator delete(v32);
  }
  v33 = *v29;
  if (*v29)
  {
    *((_QWORD *)v28 + 4) = v33;
    operator delete(v33);
  }
  cv::BaseRowFilter::~BaseRowFilter(v28);
  _Unwind_Resume(a1);
}

void cv::MorphFilter<cv::MinOp<unsigned char>,cv::MorphNoVec>::~MorphFilter(cv::BaseRowFilter *this)
{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_24DBF0C90;
  v2 = (void *)*((_QWORD *)this + 6);
  if (v2)
  {
    *((_QWORD *)this + 7) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 3);
  if (v3)
  {
    *((_QWORD *)this + 4) = v3;
    operator delete(v3);
  }
  cv::BaseRowFilter::~BaseRowFilter(this);
}

{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_24DBF0C90;
  v2 = (void *)*((_QWORD *)this + 6);
  if (v2)
  {
    *((_QWORD *)this + 7) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 3);
  if (v3)
  {
    *((_QWORD *)this + 4) = v3;
    operator delete(v3);
  }
  cv::BaseRowFilter::~BaseRowFilter(this);
  JUMPOUT(0x2207351BCLL);
}

uint64_t cv::MorphFilter<cv::MinOp<unsigned char>,cv::MorphNoVec>::operator()(uint64_t result, uint64_t a2, uint64_t a3, int a4, int a5, int a6, int a7)
{
  _QWORD *v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  int *v12;
  uint64_t v13;
  int *v14;
  _QWORD *v15;
  unsigned __int8 *v16;
  unsigned __int8 v17;
  unsigned __int8 v18;
  unsigned __int8 v19;
  unsigned __int8 v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  unsigned __int8 v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  BOOL v28;

  if (a5 >= 1)
  {
    v7 = *(_QWORD **)(result + 48);
    v8 = (a7 * a6);
    v9 = *(_QWORD *)(result + 24);
    v10 = (unint64_t)(*(_QWORD *)(result + 32) - v9) >> 3;
    v11 = a4;
    v12 = (int *)(v9 + 4);
    do
    {
      v13 = v10;
      v14 = v12;
      v15 = v7;
      if ((int)v10 >= 1)
      {
        do
        {
          *v15++ = *(_QWORD *)(a2 + 8 * *v14) + *(v14 - 1) * (uint64_t)a7;
          v14 += 2;
          --v13;
        }
        while (v13);
      }
      if ((int)v8 >= 4)
      {
        result = 0;
        do
        {
          v16 = (unsigned __int8 *)(*v7 + result);
          v17 = *v16;
          v18 = v16[1];
          v19 = v16[2];
          v20 = v16[3];
          if ((int)v10 >= 2)
          {
            v21 = v10 - 1;
            v22 = v7 + 1;
            do
            {
              v23 = *v22++;
              v17 -= icvSaturate8u_cv[(v17 | 0x100) - *(unsigned __int8 *)(v23 + result)];
              v18 -= icvSaturate8u_cv[(v18 | 0x100) - *(unsigned __int8 *)(v23 + result + 1)];
              v19 -= icvSaturate8u_cv[(v19 | 0x100) - *(unsigned __int8 *)(v23 + result + 2)];
              v20 -= icvSaturate8u_cv[(v20 | 0x100) - *(unsigned __int8 *)(v23 + result + 3)];
              --v21;
            }
            while (v21);
          }
          *(_BYTE *)(a3 + result) = v17;
          *(_BYTE *)(a3 + (result | 1)) = v18;
          *(_BYTE *)(a3 + (result | 2)) = v19;
          *(_BYTE *)(a3 + (result | 3)) = v20;
          result += 4;
        }
        while (result <= (int)v8 - 4);
        result = result;
      }
      else
      {
        result = 0;
      }
      if ((int)result < (int)v8)
      {
        do
        {
          v24 = *(_BYTE *)(*v7 + result);
          if ((int)v10 >= 2)
          {
            v25 = v10 - 1;
            v26 = v7 + 1;
            do
            {
              v27 = *v26++;
              v24 -= icvSaturate8u_cv[(v24 | 0x100) - *(unsigned __int8 *)(v27 + result)];
              --v25;
            }
            while (v25);
          }
          *(_BYTE *)(a3 + result++) = v24;
        }
        while (result != v8);
      }
      a3 += v11;
      a2 += 8;
      v28 = __OFSUB__(a5--, 1);
    }
    while (!((a5 < 0) ^ v28 | (a5 == 0)));
  }
  return result;
}

_QWORD *cv::MorphFilter<cv::MinOp<unsigned short>,cv::MorphNoVec>::MorphFilter(_QWORD *a1, int32x2_t **a2, _QWORD *a3)
{
  _QWORD *v6;
  uint64_t v7;
  const cv::Exception *v8;
  void *__p[2];
  void *v11[2];
  void *v12[2];
  void *v13;
  void *v14;
  uint64_t v15;

  v6 = cv::BaseFilter::BaseFilter(a1);
  *(_OWORD *)(v6 + 3) = 0u;
  *v6 = &off_24DBF0CD8;
  v7 = (uint64_t)(v6 + 6);
  *(_OWORD *)(v6 + 5) = 0u;
  *(_OWORD *)(v6 + 7) = 0u;
  v6[2] = *a3;
  v6[1] = vrev64_s32(*a2[8]);
  if ((*(_WORD *)a2 & 0xFFF) != 0)
  {
    std::string::basic_string[abi:ne180100]<0>(v12, "_kernel.type() == CV_8U");
    std::string::basic_string[abi:ne180100]<0>(v11, "MorphFilter");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/imgproc/morph.cpp");
    cv::Exception::Exception(&v13, 4294967081, v12, v11, __p, 783);
    cv::error((cv *)&v13, v8);
  }
  v13 = 0;
  v14 = 0;
  v15 = 0;
  cv::preprocess2DKernel((cv::Mat *)a2, v6 + 3, (unint64_t *)&v13);
  std::vector<unsigned char *>::resize(v7, (uint64_t)(a1[4] - a1[3]) >> 3);
  if (v13)
  {
    v14 = v13;
    operator delete(v13);
  }
  return a1;
}

void sub_219E86D78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28)
{
  cv::BaseRowFilter *v28;
  void **v29;
  void **v30;
  void *v32;
  void *v33;

  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  v32 = *v30;
  if (*v30)
  {
    *((_QWORD *)v28 + 7) = v32;
    operator delete(v32);
  }
  v33 = *v29;
  if (*v29)
  {
    *((_QWORD *)v28 + 4) = v33;
    operator delete(v33);
  }
  cv::BaseRowFilter::~BaseRowFilter(v28);
  _Unwind_Resume(a1);
}

void cv::MorphFilter<cv::MinOp<unsigned short>,cv::MorphNoVec>::~MorphFilter(cv::BaseRowFilter *this)
{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_24DBF0CD8;
  v2 = (void *)*((_QWORD *)this + 6);
  if (v2)
  {
    *((_QWORD *)this + 7) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 3);
  if (v3)
  {
    *((_QWORD *)this + 4) = v3;
    operator delete(v3);
  }
  cv::BaseRowFilter::~BaseRowFilter(this);
}

{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_24DBF0CD8;
  v2 = (void *)*((_QWORD *)this + 6);
  if (v2)
  {
    *((_QWORD *)this + 7) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 3);
  if (v3)
  {
    *((_QWORD *)this + 4) = v3;
    operator delete(v3);
  }
  cv::BaseRowFilter::~BaseRowFilter(this);
  JUMPOUT(0x2207351BCLL);
}

_QWORD *cv::MorphFilter<cv::MinOp<unsigned short>,cv::MorphNoVec>::operator()(_QWORD *result, uint64_t a2, uint64_t a3, int a4, int a5, int a6, int a7)
{
  uint64_t v7;
  uint64_t v8;
  _QWORD **v9;
  unint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint16x4_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  unsigned __int16 v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  unsigned int v24;
  BOOL v25;

  if (a5 >= 1)
  {
    v7 = (a7 * a6);
    v8 = result[3];
    v9 = (_QWORD **)result[6];
    v10 = (unint64_t)(result[4] - v8) >> 3;
    v11 = a4;
    v12 = (_QWORD *)(v8 + 4);
    do
    {
      v13 = v10;
      result = v12;
      v14 = v9;
      if ((int)v10 >= 1)
      {
        do
        {
          *v14++ = *(_QWORD *)(a2 + 8 * *(int *)result) + 2 * *((_DWORD *)result - 1) * a7;
          ++result;
          --v13;
        }
        while (v13);
      }
      if ((int)v7 >= 4)
      {
        v15 = 0;
        result = *v9;
        do
        {
          v16 = *(uint16x4_t *)((char *)result + 2 * v15);
          if ((int)v10 >= 2)
          {
            v17 = v10 - 1;
            v18 = (uint64_t *)(v9 + 1);
            do
            {
              v19 = *v18++;
              v16 = vmin_u16(*(uint16x4_t *)(v19 + 2 * v15), v16);
              --v17;
            }
            while (v17);
          }
          *(uint16x4_t *)(a3 + 2 * v15) = v16;
          v15 += 4;
        }
        while (v15 <= (int)v7 - 4);
        v15 = v15;
      }
      else
      {
        v15 = 0;
      }
      if ((int)v15 < (int)v7)
      {
        result = *v9;
        do
        {
          v20 = *((_WORD *)result + v15);
          if ((int)v10 >= 2)
          {
            v21 = v10 - 1;
            v22 = (uint64_t *)(v9 + 1);
            do
            {
              v23 = *v22++;
              v24 = *(unsigned __int16 *)(v23 + 2 * v15);
              if (v24 < v20)
                v20 = v24;
              --v21;
            }
            while (v21);
          }
          *(_WORD *)(a3 + 2 * v15++) = v20;
        }
        while (v15 != v7);
      }
      a3 += v11;
      a2 += 8;
      v25 = __OFSUB__(a5--, 1);
    }
    while (!((a5 < 0) ^ v25 | (a5 == 0)));
  }
  return result;
}

_QWORD *cv::MorphFilter<cv::MinOp<short>,cv::MorphNoVec>::MorphFilter(_QWORD *a1, int32x2_t **a2, _QWORD *a3)
{
  _QWORD *v6;
  uint64_t v7;
  const cv::Exception *v8;
  void *__p[2];
  void *v11[2];
  void *v12[2];
  void *v13;
  void *v14;
  uint64_t v15;

  v6 = cv::BaseFilter::BaseFilter(a1);
  *(_OWORD *)(v6 + 3) = 0u;
  *v6 = &off_24DBF0D20;
  v7 = (uint64_t)(v6 + 6);
  *(_OWORD *)(v6 + 5) = 0u;
  *(_OWORD *)(v6 + 7) = 0u;
  v6[2] = *a3;
  v6[1] = vrev64_s32(*a2[8]);
  if ((*(_WORD *)a2 & 0xFFF) != 0)
  {
    std::string::basic_string[abi:ne180100]<0>(v12, "_kernel.type() == CV_8U");
    std::string::basic_string[abi:ne180100]<0>(v11, "MorphFilter");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/imgproc/morph.cpp");
    cv::Exception::Exception(&v13, 4294967081, v12, v11, __p, 783);
    cv::error((cv *)&v13, v8);
  }
  v13 = 0;
  v14 = 0;
  v15 = 0;
  cv::preprocess2DKernel((cv::Mat *)a2, v6 + 3, (unint64_t *)&v13);
  std::vector<unsigned char *>::resize(v7, (uint64_t)(a1[4] - a1[3]) >> 3);
  if (v13)
  {
    v14 = v13;
    operator delete(v13);
  }
  return a1;
}

void sub_219E87148(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28)
{
  cv::BaseRowFilter *v28;
  void **v29;
  void **v30;
  void *v32;
  void *v33;

  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  v32 = *v30;
  if (*v30)
  {
    *((_QWORD *)v28 + 7) = v32;
    operator delete(v32);
  }
  v33 = *v29;
  if (*v29)
  {
    *((_QWORD *)v28 + 4) = v33;
    operator delete(v33);
  }
  cv::BaseRowFilter::~BaseRowFilter(v28);
  _Unwind_Resume(a1);
}

void cv::MorphFilter<cv::MinOp<short>,cv::MorphNoVec>::~MorphFilter(cv::BaseRowFilter *this)
{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_24DBF0D20;
  v2 = (void *)*((_QWORD *)this + 6);
  if (v2)
  {
    *((_QWORD *)this + 7) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 3);
  if (v3)
  {
    *((_QWORD *)this + 4) = v3;
    operator delete(v3);
  }
  cv::BaseRowFilter::~BaseRowFilter(this);
}

{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_24DBF0D20;
  v2 = (void *)*((_QWORD *)this + 6);
  if (v2)
  {
    *((_QWORD *)this + 7) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 3);
  if (v3)
  {
    *((_QWORD *)this + 4) = v3;
    operator delete(v3);
  }
  cv::BaseRowFilter::~BaseRowFilter(this);
  JUMPOUT(0x2207351BCLL);
}

_QWORD *cv::MorphFilter<cv::MinOp<short>,cv::MorphNoVec>::operator()(_QWORD *result, uint64_t a2, uint64_t a3, int a4, int a5, int a6, int a7)
{
  uint64_t v7;
  uint64_t v8;
  _QWORD **v9;
  unint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  int16x4_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  __int16 v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  int v24;
  BOOL v25;

  if (a5 >= 1)
  {
    v7 = (a7 * a6);
    v8 = result[3];
    v9 = (_QWORD **)result[6];
    v10 = (unint64_t)(result[4] - v8) >> 3;
    v11 = a4;
    v12 = (_QWORD *)(v8 + 4);
    do
    {
      v13 = v10;
      result = v12;
      v14 = v9;
      if ((int)v10 >= 1)
      {
        do
        {
          *v14++ = *(_QWORD *)(a2 + 8 * *(int *)result) + 2 * *((_DWORD *)result - 1) * a7;
          ++result;
          --v13;
        }
        while (v13);
      }
      if ((int)v7 >= 4)
      {
        v15 = 0;
        result = *v9;
        do
        {
          v16 = *(int16x4_t *)((char *)result + 2 * v15);
          if ((int)v10 >= 2)
          {
            v17 = v10 - 1;
            v18 = (uint64_t *)(v9 + 1);
            do
            {
              v19 = *v18++;
              v16 = vmin_s16(*(int16x4_t *)(v19 + 2 * v15), v16);
              --v17;
            }
            while (v17);
          }
          *(int16x4_t *)(a3 + 2 * v15) = v16;
          v15 += 4;
        }
        while (v15 <= (int)v7 - 4);
        v15 = v15;
      }
      else
      {
        v15 = 0;
      }
      if ((int)v15 < (int)v7)
      {
        result = *v9;
        do
        {
          v20 = *((_WORD *)result + v15);
          if ((int)v10 >= 2)
          {
            v21 = v10 - 1;
            v22 = (uint64_t *)(v9 + 1);
            do
            {
              v23 = *v22++;
              v24 = *(__int16 *)(v23 + 2 * v15);
              if (v24 < v20)
                v20 = v24;
              --v21;
            }
            while (v21);
          }
          *(_WORD *)(a3 + 2 * v15++) = v20;
        }
        while (v15 != v7);
      }
      a3 += v11;
      a2 += 8;
      v25 = __OFSUB__(a5--, 1);
    }
    while (!((a5 < 0) ^ v25 | (a5 == 0)));
  }
  return result;
}

_QWORD *cv::MorphFilter<cv::MinOp<float>,cv::MorphNoVec>::MorphFilter(_QWORD *a1, int32x2_t **a2, _QWORD *a3)
{
  _QWORD *v6;
  uint64_t v7;
  const cv::Exception *v8;
  void *__p[2];
  void *v11[2];
  void *v12[2];
  void *v13;
  void *v14;
  uint64_t v15;

  v6 = cv::BaseFilter::BaseFilter(a1);
  *(_OWORD *)(v6 + 3) = 0u;
  *v6 = &off_24DBF0D68;
  v7 = (uint64_t)(v6 + 6);
  *(_OWORD *)(v6 + 5) = 0u;
  *(_OWORD *)(v6 + 7) = 0u;
  v6[2] = *a3;
  v6[1] = vrev64_s32(*a2[8]);
  if ((*(_WORD *)a2 & 0xFFF) != 0)
  {
    std::string::basic_string[abi:ne180100]<0>(v12, "_kernel.type() == CV_8U");
    std::string::basic_string[abi:ne180100]<0>(v11, "MorphFilter");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/imgproc/morph.cpp");
    cv::Exception::Exception(&v13, 4294967081, v12, v11, __p, 783);
    cv::error((cv *)&v13, v8);
  }
  v13 = 0;
  v14 = 0;
  v15 = 0;
  cv::preprocess2DKernel((cv::Mat *)a2, v6 + 3, (unint64_t *)&v13);
  std::vector<unsigned char *>::resize(v7, (uint64_t)(a1[4] - a1[3]) >> 3);
  if (v13)
  {
    v14 = v13;
    operator delete(v13);
  }
  return a1;
}

void sub_219E87518(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28)
{
  cv::BaseRowFilter *v28;
  void **v29;
  void **v30;
  void *v32;
  void *v33;

  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  v32 = *v30;
  if (*v30)
  {
    *((_QWORD *)v28 + 7) = v32;
    operator delete(v32);
  }
  v33 = *v29;
  if (*v29)
  {
    *((_QWORD *)v28 + 4) = v33;
    operator delete(v33);
  }
  cv::BaseRowFilter::~BaseRowFilter(v28);
  _Unwind_Resume(a1);
}

void cv::MorphFilter<cv::MinOp<float>,cv::MorphNoVec>::~MorphFilter(cv::BaseRowFilter *this)
{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_24DBF0D68;
  v2 = (void *)*((_QWORD *)this + 6);
  if (v2)
  {
    *((_QWORD *)this + 7) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 3);
  if (v3)
  {
    *((_QWORD *)this + 4) = v3;
    operator delete(v3);
  }
  cv::BaseRowFilter::~BaseRowFilter(this);
}

{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_24DBF0D68;
  v2 = (void *)*((_QWORD *)this + 6);
  if (v2)
  {
    *((_QWORD *)this + 7) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 3);
  if (v3)
  {
    *((_QWORD *)this + 4) = v3;
    operator delete(v3);
  }
  cv::BaseRowFilter::~BaseRowFilter(this);
  JUMPOUT(0x2207351BCLL);
}

_QWORD *cv::MorphFilter<cv::MinOp<float>,cv::MorphNoVec>::operator()(_QWORD *result, uint64_t a2, uint64_t a3, int a4, int a5, int a6, int a7)
{
  uint64_t v7;
  uint64_t v8;
  _QWORD **v9;
  unint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  float32x4_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  float v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  float v24;
  BOOL v25;

  if (a5 >= 1)
  {
    v7 = (a7 * a6);
    v8 = result[3];
    v9 = (_QWORD **)result[6];
    v10 = (unint64_t)(result[4] - v8) >> 3;
    v11 = a4;
    v12 = (_QWORD *)(v8 + 4);
    do
    {
      v13 = v10;
      result = v12;
      v14 = v9;
      if ((int)v10 >= 1)
      {
        do
        {
          *v14++ = *(_QWORD *)(a2 + 8 * *(int *)result) + 4 * *((_DWORD *)result - 1) * a7;
          ++result;
          --v13;
        }
        while (v13);
      }
      if ((int)v7 >= 4)
      {
        v15 = 0;
        result = *v9;
        do
        {
          v16 = *(float32x4_t *)((char *)result + 4 * v15);
          if ((int)v10 >= 2)
          {
            v17 = v10 - 1;
            v18 = (uint64_t *)(v9 + 1);
            do
            {
              v19 = *v18++;
              v16 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v16, *(float32x4_t *)(v19 + 4 * v15)), *(int8x16_t *)(v19 + 4 * v15), (int8x16_t)v16);
              --v17;
            }
            while (v17);
          }
          *(float32x4_t *)(a3 + 4 * v15) = v16;
          v15 += 4;
        }
        while (v15 <= (int)v7 - 4);
        v15 = v15;
      }
      else
      {
        v15 = 0;
      }
      if ((int)v15 < (int)v7)
      {
        result = *v9;
        do
        {
          v20 = *((float *)result + v15);
          if ((int)v10 >= 2)
          {
            v21 = v10 - 1;
            v22 = (uint64_t *)(v9 + 1);
            do
            {
              v23 = *v22++;
              v24 = *(float *)(v23 + 4 * v15);
              if (v24 < v20)
                v20 = v24;
              --v21;
            }
            while (v21);
          }
          *(float *)(a3 + 4 * v15++) = v20;
        }
        while (v15 != v7);
      }
      a3 += v11;
      a2 += 8;
      v25 = __OFSUB__(a5--, 1);
    }
    while (!((a5 < 0) ^ v25 | (a5 == 0)));
  }
  return result;
}

_QWORD *cv::MorphFilter<cv::MinOp<double>,cv::MorphNoVec>::MorphFilter(_QWORD *a1, int32x2_t **a2, _QWORD *a3)
{
  _QWORD *v6;
  uint64_t v7;
  const cv::Exception *v8;
  void *__p[2];
  void *v11[2];
  void *v12[2];
  void *v13;
  void *v14;
  uint64_t v15;

  v6 = cv::BaseFilter::BaseFilter(a1);
  *(_OWORD *)(v6 + 3) = 0u;
  *v6 = &off_24DBF0DB0;
  v7 = (uint64_t)(v6 + 6);
  *(_OWORD *)(v6 + 5) = 0u;
  *(_OWORD *)(v6 + 7) = 0u;
  v6[2] = *a3;
  v6[1] = vrev64_s32(*a2[8]);
  if ((*(_WORD *)a2 & 0xFFF) != 0)
  {
    std::string::basic_string[abi:ne180100]<0>(v12, "_kernel.type() == CV_8U");
    std::string::basic_string[abi:ne180100]<0>(v11, "MorphFilter");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/imgproc/morph.cpp");
    cv::Exception::Exception(&v13, 4294967081, v12, v11, __p, 783);
    cv::error((cv *)&v13, v8);
  }
  v13 = 0;
  v14 = 0;
  v15 = 0;
  cv::preprocess2DKernel((cv::Mat *)a2, v6 + 3, (unint64_t *)&v13);
  std::vector<unsigned char *>::resize(v7, (uint64_t)(a1[4] - a1[3]) >> 3);
  if (v13)
  {
    v14 = v13;
    operator delete(v13);
  }
  return a1;
}

void sub_219E878E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28)
{
  cv::BaseRowFilter *v28;
  void **v29;
  void **v30;
  void *v32;
  void *v33;

  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  v32 = *v30;
  if (*v30)
  {
    *((_QWORD *)v28 + 7) = v32;
    operator delete(v32);
  }
  v33 = *v29;
  if (*v29)
  {
    *((_QWORD *)v28 + 4) = v33;
    operator delete(v33);
  }
  cv::BaseRowFilter::~BaseRowFilter(v28);
  _Unwind_Resume(a1);
}

void cv::MorphFilter<cv::MinOp<double>,cv::MorphNoVec>::~MorphFilter(cv::BaseRowFilter *this)
{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_24DBF0DB0;
  v2 = (void *)*((_QWORD *)this + 6);
  if (v2)
  {
    *((_QWORD *)this + 7) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 3);
  if (v3)
  {
    *((_QWORD *)this + 4) = v3;
    operator delete(v3);
  }
  cv::BaseRowFilter::~BaseRowFilter(this);
}

{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_24DBF0DB0;
  v2 = (void *)*((_QWORD *)this + 6);
  if (v2)
  {
    *((_QWORD *)this + 7) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 3);
  if (v3)
  {
    *((_QWORD *)this + 4) = v3;
    operator delete(v3);
  }
  cv::BaseRowFilter::~BaseRowFilter(this);
  JUMPOUT(0x2207351BCLL);
}

_QWORD *cv::MorphFilter<cv::MinOp<double>,cv::MorphNoVec>::operator()(_QWORD *result, uint64_t a2, uint64_t a3, int a4, int a5, int a6, int a7)
{
  uint64_t v7;
  uint64_t v8;
  _QWORD **v9;
  unint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  float64x2_t *v16;
  float64x2_t v17;
  float64x2_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  float64x2_t *v22;
  double v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  double v27;
  BOOL v28;

  if (a5 >= 1)
  {
    v7 = (a7 * a6);
    v8 = result[3];
    v9 = (_QWORD **)result[6];
    v10 = (unint64_t)(result[4] - v8) >> 3;
    v11 = a4;
    v12 = (_QWORD *)(v8 + 4);
    do
    {
      v13 = v10;
      result = v12;
      v14 = v9;
      if ((int)v10 >= 1)
      {
        do
        {
          *v14++ = *(_QWORD *)(a2 + 8 * *(int *)result) + 8 * *((_DWORD *)result - 1) * a7;
          ++result;
          --v13;
        }
        while (v13);
      }
      if ((int)v7 >= 4)
      {
        v15 = 0;
        result = *v9;
        do
        {
          v16 = (float64x2_t *)&result[v15];
          v18 = *v16;
          v17 = v16[1];
          if ((int)v10 >= 2)
          {
            v19 = v10 - 1;
            v20 = (uint64_t *)(v9 + 1);
            do
            {
              v21 = *v20++;
              v22 = (float64x2_t *)(v21 + 8 * v15);
              v18 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v18, *v22), *(int8x16_t *)v22, (int8x16_t)v18);
              v17 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v17, v22[1]), (int8x16_t)v22[1], (int8x16_t)v17);
              --v19;
            }
            while (v19);
          }
          *(float64x2_t *)(a3 + 8 * v15) = v18;
          *(float64x2_t *)(a3 + ((8 * v15) | 0x10)) = v17;
          v15 += 4;
        }
        while (v15 <= (int)v7 - 4);
        v15 = v15;
      }
      else
      {
        v15 = 0;
      }
      if ((int)v15 < (int)v7)
      {
        result = *v9;
        do
        {
          v23 = *(double *)&result[v15];
          if ((int)v10 >= 2)
          {
            v24 = v10 - 1;
            v25 = (uint64_t *)(v9 + 1);
            do
            {
              v26 = *v25++;
              v27 = *(double *)(v26 + 8 * v15);
              if (v27 < v23)
                v23 = v27;
              --v24;
            }
            while (v24);
          }
          *(double *)(a3 + 8 * v15++) = v23;
        }
        while (v15 != v7);
      }
      a3 += v11;
      a2 += 8;
      v28 = __OFSUB__(a5--, 1);
    }
    while (!((a5 < 0) ^ v28 | (a5 == 0)));
  }
  return result;
}

_QWORD *cv::MorphFilter<cv::MaxOp<unsigned char>,cv::MorphNoVec>::MorphFilter(_QWORD *a1, int32x2_t **a2, _QWORD *a3)
{
  _QWORD *v6;
  uint64_t v7;
  const cv::Exception *v8;
  void *__p[2];
  void *v11[2];
  void *v12[2];
  void *v13;
  void *v14;
  uint64_t v15;

  v6 = cv::BaseFilter::BaseFilter(a1);
  *(_OWORD *)(v6 + 3) = 0u;
  *v6 = &off_24DBF0DF8;
  v7 = (uint64_t)(v6 + 6);
  *(_OWORD *)(v6 + 5) = 0u;
  *(_OWORD *)(v6 + 7) = 0u;
  v6[2] = *a3;
  v6[1] = vrev64_s32(*a2[8]);
  if ((*(_WORD *)a2 & 0xFFF) != 0)
  {
    std::string::basic_string[abi:ne180100]<0>(v12, "_kernel.type() == CV_8U");
    std::string::basic_string[abi:ne180100]<0>(v11, "MorphFilter");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/imgproc/morph.cpp");
    cv::Exception::Exception(&v13, 4294967081, v12, v11, __p, 783);
    cv::error((cv *)&v13, v8);
  }
  v13 = 0;
  v14 = 0;
  v15 = 0;
  cv::preprocess2DKernel((cv::Mat *)a2, v6 + 3, (unint64_t *)&v13);
  std::vector<unsigned char *>::resize(v7, (uint64_t)(a1[4] - a1[3]) >> 3);
  if (v13)
  {
    v14 = v13;
    operator delete(v13);
  }
  return a1;
}

void sub_219E87CC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28)
{
  cv::BaseRowFilter *v28;
  void **v29;
  void **v30;
  void *v32;
  void *v33;

  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  v32 = *v30;
  if (*v30)
  {
    *((_QWORD *)v28 + 7) = v32;
    operator delete(v32);
  }
  v33 = *v29;
  if (*v29)
  {
    *((_QWORD *)v28 + 4) = v33;
    operator delete(v33);
  }
  cv::BaseRowFilter::~BaseRowFilter(v28);
  _Unwind_Resume(a1);
}

void cv::MorphFilter<cv::MaxOp<unsigned char>,cv::MorphNoVec>::~MorphFilter(cv::BaseRowFilter *this)
{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_24DBF0DF8;
  v2 = (void *)*((_QWORD *)this + 6);
  if (v2)
  {
    *((_QWORD *)this + 7) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 3);
  if (v3)
  {
    *((_QWORD *)this + 4) = v3;
    operator delete(v3);
  }
  cv::BaseRowFilter::~BaseRowFilter(this);
}

{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_24DBF0DF8;
  v2 = (void *)*((_QWORD *)this + 6);
  if (v2)
  {
    *((_QWORD *)this + 7) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 3);
  if (v3)
  {
    *((_QWORD *)this + 4) = v3;
    operator delete(v3);
  }
  cv::BaseRowFilter::~BaseRowFilter(this);
  JUMPOUT(0x2207351BCLL);
}

uint64_t cv::MorphFilter<cv::MaxOp<unsigned char>,cv::MorphNoVec>::operator()(uint64_t result, uint64_t a2, uint64_t a3, int a4, int a5, int a6, int a7)
{
  _QWORD *v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  int *v12;
  uint64_t v13;
  int *v14;
  _QWORD *v15;
  unsigned __int8 *v16;
  unsigned __int8 v17;
  unsigned __int8 v18;
  unsigned __int8 v19;
  unsigned __int8 v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  unsigned __int8 v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  BOOL v28;

  if (a5 >= 1)
  {
    v7 = *(_QWORD **)(result + 48);
    v8 = (a7 * a6);
    v9 = *(_QWORD *)(result + 24);
    v10 = (unint64_t)(*(_QWORD *)(result + 32) - v9) >> 3;
    v11 = a4;
    v12 = (int *)(v9 + 4);
    do
    {
      v13 = v10;
      v14 = v12;
      v15 = v7;
      if ((int)v10 >= 1)
      {
        do
        {
          *v15++ = *(_QWORD *)(a2 + 8 * *v14) + *(v14 - 1) * (uint64_t)a7;
          v14 += 2;
          --v13;
        }
        while (v13);
      }
      if ((int)v8 >= 4)
      {
        result = 0;
        do
        {
          v16 = (unsigned __int8 *)(*v7 + result);
          v17 = *v16;
          v18 = v16[1];
          v19 = v16[2];
          v20 = v16[3];
          if ((int)v10 >= 2)
          {
            v21 = v10 - 1;
            v22 = v7 + 1;
            do
            {
              v23 = *v22++;
              v17 += icvSaturate8u_cv[*(unsigned __int8 *)(v23 + result) - v17 + 256];
              v18 += icvSaturate8u_cv[*(unsigned __int8 *)(v23 + result + 1) - v18 + 256];
              v19 += icvSaturate8u_cv[*(unsigned __int8 *)(v23 + result + 2) - v19 + 256];
              v20 += icvSaturate8u_cv[*(unsigned __int8 *)(v23 + result + 3) - v20 + 256];
              --v21;
            }
            while (v21);
          }
          *(_BYTE *)(a3 + result) = v17;
          *(_BYTE *)(a3 + (result | 1)) = v18;
          *(_BYTE *)(a3 + (result | 2)) = v19;
          *(_BYTE *)(a3 + (result | 3)) = v20;
          result += 4;
        }
        while (result <= (int)v8 - 4);
        result = result;
      }
      else
      {
        result = 0;
      }
      if ((int)result < (int)v8)
      {
        do
        {
          v24 = *(_BYTE *)(*v7 + result);
          if ((int)v10 >= 2)
          {
            v25 = v10 - 1;
            v26 = v7 + 1;
            do
            {
              v27 = *v26++;
              v24 += icvSaturate8u_cv[*(unsigned __int8 *)(v27 + result) - v24 + 256];
              --v25;
            }
            while (v25);
          }
          *(_BYTE *)(a3 + result++) = v24;
        }
        while (result != v8);
      }
      a3 += v11;
      a2 += 8;
      v28 = __OFSUB__(a5--, 1);
    }
    while (!((a5 < 0) ^ v28 | (a5 == 0)));
  }
  return result;
}

_QWORD *cv::MorphFilter<cv::MaxOp<unsigned short>,cv::MorphNoVec>::MorphFilter(_QWORD *a1, int32x2_t **a2, _QWORD *a3)
{
  _QWORD *v6;
  uint64_t v7;
  const cv::Exception *v8;
  void *__p[2];
  void *v11[2];
  void *v12[2];
  void *v13;
  void *v14;
  uint64_t v15;

  v6 = cv::BaseFilter::BaseFilter(a1);
  *(_OWORD *)(v6 + 3) = 0u;
  *v6 = &off_24DBF0E40;
  v7 = (uint64_t)(v6 + 6);
  *(_OWORD *)(v6 + 5) = 0u;
  *(_OWORD *)(v6 + 7) = 0u;
  v6[2] = *a3;
  v6[1] = vrev64_s32(*a2[8]);
  if ((*(_WORD *)a2 & 0xFFF) != 0)
  {
    std::string::basic_string[abi:ne180100]<0>(v12, "_kernel.type() == CV_8U");
    std::string::basic_string[abi:ne180100]<0>(v11, "MorphFilter");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/imgproc/morph.cpp");
    cv::Exception::Exception(&v13, 4294967081, v12, v11, __p, 783);
    cv::error((cv *)&v13, v8);
  }
  v13 = 0;
  v14 = 0;
  v15 = 0;
  cv::preprocess2DKernel((cv::Mat *)a2, v6 + 3, (unint64_t *)&v13);
  std::vector<unsigned char *>::resize(v7, (uint64_t)(a1[4] - a1[3]) >> 3);
  if (v13)
  {
    v14 = v13;
    operator delete(v13);
  }
  return a1;
}

void sub_219E8811C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28)
{
  cv::BaseRowFilter *v28;
  void **v29;
  void **v30;
  void *v32;
  void *v33;

  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  v32 = *v30;
  if (*v30)
  {
    *((_QWORD *)v28 + 7) = v32;
    operator delete(v32);
  }
  v33 = *v29;
  if (*v29)
  {
    *((_QWORD *)v28 + 4) = v33;
    operator delete(v33);
  }
  cv::BaseRowFilter::~BaseRowFilter(v28);
  _Unwind_Resume(a1);
}

void cv::MorphFilter<cv::MaxOp<unsigned short>,cv::MorphNoVec>::~MorphFilter(cv::BaseRowFilter *this)
{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_24DBF0E40;
  v2 = (void *)*((_QWORD *)this + 6);
  if (v2)
  {
    *((_QWORD *)this + 7) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 3);
  if (v3)
  {
    *((_QWORD *)this + 4) = v3;
    operator delete(v3);
  }
  cv::BaseRowFilter::~BaseRowFilter(this);
}

{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_24DBF0E40;
  v2 = (void *)*((_QWORD *)this + 6);
  if (v2)
  {
    *((_QWORD *)this + 7) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 3);
  if (v3)
  {
    *((_QWORD *)this + 4) = v3;
    operator delete(v3);
  }
  cv::BaseRowFilter::~BaseRowFilter(this);
  JUMPOUT(0x2207351BCLL);
}

_QWORD *cv::MorphFilter<cv::MaxOp<unsigned short>,cv::MorphNoVec>::operator()(_QWORD *result, uint64_t a2, uint64_t a3, int a4, int a5, int a6, int a7)
{
  uint64_t v7;
  uint64_t v8;
  _QWORD **v9;
  unint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint16x4_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  unsigned __int16 v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  unsigned int v24;
  BOOL v25;

  if (a5 >= 1)
  {
    v7 = (a7 * a6);
    v8 = result[3];
    v9 = (_QWORD **)result[6];
    v10 = (unint64_t)(result[4] - v8) >> 3;
    v11 = a4;
    v12 = (_QWORD *)(v8 + 4);
    do
    {
      v13 = v10;
      result = v12;
      v14 = v9;
      if ((int)v10 >= 1)
      {
        do
        {
          *v14++ = *(_QWORD *)(a2 + 8 * *(int *)result) + 2 * *((_DWORD *)result - 1) * a7;
          ++result;
          --v13;
        }
        while (v13);
      }
      if ((int)v7 >= 4)
      {
        v15 = 0;
        result = *v9;
        do
        {
          v16 = *(uint16x4_t *)((char *)result + 2 * v15);
          if ((int)v10 >= 2)
          {
            v17 = v10 - 1;
            v18 = (uint64_t *)(v9 + 1);
            do
            {
              v19 = *v18++;
              v16 = vmax_u16(v16, *(uint16x4_t *)(v19 + 2 * v15));
              --v17;
            }
            while (v17);
          }
          *(uint16x4_t *)(a3 + 2 * v15) = v16;
          v15 += 4;
        }
        while (v15 <= (int)v7 - 4);
        v15 = v15;
      }
      else
      {
        v15 = 0;
      }
      if ((int)v15 < (int)v7)
      {
        result = *v9;
        do
        {
          v20 = *((_WORD *)result + v15);
          if ((int)v10 >= 2)
          {
            v21 = v10 - 1;
            v22 = (uint64_t *)(v9 + 1);
            do
            {
              v23 = *v22++;
              v24 = *(unsigned __int16 *)(v23 + 2 * v15);
              if (v20 <= v24)
                v20 = v24;
              --v21;
            }
            while (v21);
          }
          *(_WORD *)(a3 + 2 * v15++) = v20;
        }
        while (v15 != v7);
      }
      a3 += v11;
      a2 += 8;
      v25 = __OFSUB__(a5--, 1);
    }
    while (!((a5 < 0) ^ v25 | (a5 == 0)));
  }
  return result;
}

_QWORD *cv::MorphFilter<cv::MaxOp<short>,cv::MorphNoVec>::MorphFilter(_QWORD *a1, int32x2_t **a2, _QWORD *a3)
{
  _QWORD *v6;
  uint64_t v7;
  const cv::Exception *v8;
  void *__p[2];
  void *v11[2];
  void *v12[2];
  void *v13;
  void *v14;
  uint64_t v15;

  v6 = cv::BaseFilter::BaseFilter(a1);
  *(_OWORD *)(v6 + 3) = 0u;
  *v6 = &off_24DBF0E88;
  v7 = (uint64_t)(v6 + 6);
  *(_OWORD *)(v6 + 5) = 0u;
  *(_OWORD *)(v6 + 7) = 0u;
  v6[2] = *a3;
  v6[1] = vrev64_s32(*a2[8]);
  if ((*(_WORD *)a2 & 0xFFF) != 0)
  {
    std::string::basic_string[abi:ne180100]<0>(v12, "_kernel.type() == CV_8U");
    std::string::basic_string[abi:ne180100]<0>(v11, "MorphFilter");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/imgproc/morph.cpp");
    cv::Exception::Exception(&v13, 4294967081, v12, v11, __p, 783);
    cv::error((cv *)&v13, v8);
  }
  v13 = 0;
  v14 = 0;
  v15 = 0;
  cv::preprocess2DKernel((cv::Mat *)a2, v6 + 3, (unint64_t *)&v13);
  std::vector<unsigned char *>::resize(v7, (uint64_t)(a1[4] - a1[3]) >> 3);
  if (v13)
  {
    v14 = v13;
    operator delete(v13);
  }
  return a1;
}

void sub_219E884EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28)
{
  cv::BaseRowFilter *v28;
  void **v29;
  void **v30;
  void *v32;
  void *v33;

  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  v32 = *v30;
  if (*v30)
  {
    *((_QWORD *)v28 + 7) = v32;
    operator delete(v32);
  }
  v33 = *v29;
  if (*v29)
  {
    *((_QWORD *)v28 + 4) = v33;
    operator delete(v33);
  }
  cv::BaseRowFilter::~BaseRowFilter(v28);
  _Unwind_Resume(a1);
}

void cv::MorphFilter<cv::MaxOp<short>,cv::MorphNoVec>::~MorphFilter(cv::BaseRowFilter *this)
{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_24DBF0E88;
  v2 = (void *)*((_QWORD *)this + 6);
  if (v2)
  {
    *((_QWORD *)this + 7) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 3);
  if (v3)
  {
    *((_QWORD *)this + 4) = v3;
    operator delete(v3);
  }
  cv::BaseRowFilter::~BaseRowFilter(this);
}

{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_24DBF0E88;
  v2 = (void *)*((_QWORD *)this + 6);
  if (v2)
  {
    *((_QWORD *)this + 7) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 3);
  if (v3)
  {
    *((_QWORD *)this + 4) = v3;
    operator delete(v3);
  }
  cv::BaseRowFilter::~BaseRowFilter(this);
  JUMPOUT(0x2207351BCLL);
}

_QWORD *cv::MorphFilter<cv::MaxOp<short>,cv::MorphNoVec>::operator()(_QWORD *result, uint64_t a2, uint64_t a3, int a4, int a5, int a6, int a7)
{
  uint64_t v7;
  uint64_t v8;
  _QWORD **v9;
  unint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  int16x4_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  __int16 v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  int v24;
  BOOL v25;

  if (a5 >= 1)
  {
    v7 = (a7 * a6);
    v8 = result[3];
    v9 = (_QWORD **)result[6];
    v10 = (unint64_t)(result[4] - v8) >> 3;
    v11 = a4;
    v12 = (_QWORD *)(v8 + 4);
    do
    {
      v13 = v10;
      result = v12;
      v14 = v9;
      if ((int)v10 >= 1)
      {
        do
        {
          *v14++ = *(_QWORD *)(a2 + 8 * *(int *)result) + 2 * *((_DWORD *)result - 1) * a7;
          ++result;
          --v13;
        }
        while (v13);
      }
      if ((int)v7 >= 4)
      {
        v15 = 0;
        result = *v9;
        do
        {
          v16 = *(int16x4_t *)((char *)result + 2 * v15);
          if ((int)v10 >= 2)
          {
            v17 = v10 - 1;
            v18 = (uint64_t *)(v9 + 1);
            do
            {
              v19 = *v18++;
              v16 = vmax_s16(v16, *(int16x4_t *)(v19 + 2 * v15));
              --v17;
            }
            while (v17);
          }
          *(int16x4_t *)(a3 + 2 * v15) = v16;
          v15 += 4;
        }
        while (v15 <= (int)v7 - 4);
        v15 = v15;
      }
      else
      {
        v15 = 0;
      }
      if ((int)v15 < (int)v7)
      {
        result = *v9;
        do
        {
          v20 = *((_WORD *)result + v15);
          if ((int)v10 >= 2)
          {
            v21 = v10 - 1;
            v22 = (uint64_t *)(v9 + 1);
            do
            {
              v23 = *v22++;
              v24 = *(__int16 *)(v23 + 2 * v15);
              if (v20 <= v24)
                v20 = v24;
              --v21;
            }
            while (v21);
          }
          *(_WORD *)(a3 + 2 * v15++) = v20;
        }
        while (v15 != v7);
      }
      a3 += v11;
      a2 += 8;
      v25 = __OFSUB__(a5--, 1);
    }
    while (!((a5 < 0) ^ v25 | (a5 == 0)));
  }
  return result;
}

_QWORD *cv::MorphFilter<cv::MaxOp<float>,cv::MorphNoVec>::MorphFilter(_QWORD *a1, int32x2_t **a2, _QWORD *a3)
{
  _QWORD *v6;
  uint64_t v7;
  const cv::Exception *v8;
  void *__p[2];
  void *v11[2];
  void *v12[2];
  void *v13;
  void *v14;
  uint64_t v15;

  v6 = cv::BaseFilter::BaseFilter(a1);
  *(_OWORD *)(v6 + 3) = 0u;
  *v6 = &off_24DBF0ED0;
  v7 = (uint64_t)(v6 + 6);
  *(_OWORD *)(v6 + 5) = 0u;
  *(_OWORD *)(v6 + 7) = 0u;
  v6[2] = *a3;
  v6[1] = vrev64_s32(*a2[8]);
  if ((*(_WORD *)a2 & 0xFFF) != 0)
  {
    std::string::basic_string[abi:ne180100]<0>(v12, "_kernel.type() == CV_8U");
    std::string::basic_string[abi:ne180100]<0>(v11, "MorphFilter");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/imgproc/morph.cpp");
    cv::Exception::Exception(&v13, 4294967081, v12, v11, __p, 783);
    cv::error((cv *)&v13, v8);
  }
  v13 = 0;
  v14 = 0;
  v15 = 0;
  cv::preprocess2DKernel((cv::Mat *)a2, v6 + 3, (unint64_t *)&v13);
  std::vector<unsigned char *>::resize(v7, (uint64_t)(a1[4] - a1[3]) >> 3);
  if (v13)
  {
    v14 = v13;
    operator delete(v13);
  }
  return a1;
}

void sub_219E888BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28)
{
  cv::BaseRowFilter *v28;
  void **v29;
  void **v30;
  void *v32;
  void *v33;

  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  v32 = *v30;
  if (*v30)
  {
    *((_QWORD *)v28 + 7) = v32;
    operator delete(v32);
  }
  v33 = *v29;
  if (*v29)
  {
    *((_QWORD *)v28 + 4) = v33;
    operator delete(v33);
  }
  cv::BaseRowFilter::~BaseRowFilter(v28);
  _Unwind_Resume(a1);
}

void cv::MorphFilter<cv::MaxOp<float>,cv::MorphNoVec>::~MorphFilter(cv::BaseRowFilter *this)
{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_24DBF0ED0;
  v2 = (void *)*((_QWORD *)this + 6);
  if (v2)
  {
    *((_QWORD *)this + 7) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 3);
  if (v3)
  {
    *((_QWORD *)this + 4) = v3;
    operator delete(v3);
  }
  cv::BaseRowFilter::~BaseRowFilter(this);
}

{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_24DBF0ED0;
  v2 = (void *)*((_QWORD *)this + 6);
  if (v2)
  {
    *((_QWORD *)this + 7) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 3);
  if (v3)
  {
    *((_QWORD *)this + 4) = v3;
    operator delete(v3);
  }
  cv::BaseRowFilter::~BaseRowFilter(this);
  JUMPOUT(0x2207351BCLL);
}

_QWORD *cv::MorphFilter<cv::MaxOp<float>,cv::MorphNoVec>::operator()(_QWORD *result, uint64_t a2, uint64_t a3, int a4, int a5, int a6, int a7)
{
  uint64_t v7;
  uint64_t v8;
  _QWORD **v9;
  unint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  float32x4_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  float v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  float v24;
  BOOL v25;

  if (a5 >= 1)
  {
    v7 = (a7 * a6);
    v8 = result[3];
    v9 = (_QWORD **)result[6];
    v10 = (unint64_t)(result[4] - v8) >> 3;
    v11 = a4;
    v12 = (_QWORD *)(v8 + 4);
    do
    {
      v13 = v10;
      result = v12;
      v14 = v9;
      if ((int)v10 >= 1)
      {
        do
        {
          *v14++ = *(_QWORD *)(a2 + 8 * *(int *)result) + 4 * *((_DWORD *)result - 1) * a7;
          ++result;
          --v13;
        }
        while (v13);
      }
      if ((int)v7 >= 4)
      {
        v15 = 0;
        result = *v9;
        do
        {
          v16 = *(float32x4_t *)((char *)result + 4 * v15);
          if ((int)v10 >= 2)
          {
            v17 = v10 - 1;
            v18 = (uint64_t *)(v9 + 1);
            do
            {
              v19 = *v18++;
              v16 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)(v19 + 4 * v15), v16), *(int8x16_t *)(v19 + 4 * v15), (int8x16_t)v16);
              --v17;
            }
            while (v17);
          }
          *(float32x4_t *)(a3 + 4 * v15) = v16;
          v15 += 4;
        }
        while (v15 <= (int)v7 - 4);
        v15 = v15;
      }
      else
      {
        v15 = 0;
      }
      if ((int)v15 < (int)v7)
      {
        result = *v9;
        do
        {
          v20 = *((float *)result + v15);
          if ((int)v10 >= 2)
          {
            v21 = v10 - 1;
            v22 = (uint64_t *)(v9 + 1);
            do
            {
              v23 = *v22++;
              v24 = *(float *)(v23 + 4 * v15);
              if (v20 < v24)
                v20 = v24;
              --v21;
            }
            while (v21);
          }
          *(float *)(a3 + 4 * v15++) = v20;
        }
        while (v15 != v7);
      }
      a3 += v11;
      a2 += 8;
      v25 = __OFSUB__(a5--, 1);
    }
    while (!((a5 < 0) ^ v25 | (a5 == 0)));
  }
  return result;
}

_QWORD *cv::MorphFilter<cv::MaxOp<double>,cv::MorphNoVec>::MorphFilter(_QWORD *a1, int32x2_t **a2, _QWORD *a3)
{
  _QWORD *v6;
  uint64_t v7;
  const cv::Exception *v8;
  void *__p[2];
  void *v11[2];
  void *v12[2];
  void *v13;
  void *v14;
  uint64_t v15;

  v6 = cv::BaseFilter::BaseFilter(a1);
  *(_OWORD *)(v6 + 3) = 0u;
  *v6 = &off_24DBF0F18;
  v7 = (uint64_t)(v6 + 6);
  *(_OWORD *)(v6 + 5) = 0u;
  *(_OWORD *)(v6 + 7) = 0u;
  v6[2] = *a3;
  v6[1] = vrev64_s32(*a2[8]);
  if ((*(_WORD *)a2 & 0xFFF) != 0)
  {
    std::string::basic_string[abi:ne180100]<0>(v12, "_kernel.type() == CV_8U");
    std::string::basic_string[abi:ne180100]<0>(v11, "MorphFilter");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/imgproc/morph.cpp");
    cv::Exception::Exception(&v13, 4294967081, v12, v11, __p, 783);
    cv::error((cv *)&v13, v8);
  }
  v13 = 0;
  v14 = 0;
  v15 = 0;
  cv::preprocess2DKernel((cv::Mat *)a2, v6 + 3, (unint64_t *)&v13);
  std::vector<unsigned char *>::resize(v7, (uint64_t)(a1[4] - a1[3]) >> 3);
  if (v13)
  {
    v14 = v13;
    operator delete(v13);
  }
  return a1;
}

void sub_219E88C8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28)
{
  cv::BaseRowFilter *v28;
  void **v29;
  void **v30;
  void *v32;
  void *v33;

  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  v32 = *v30;
  if (*v30)
  {
    *((_QWORD *)v28 + 7) = v32;
    operator delete(v32);
  }
  v33 = *v29;
  if (*v29)
  {
    *((_QWORD *)v28 + 4) = v33;
    operator delete(v33);
  }
  cv::BaseRowFilter::~BaseRowFilter(v28);
  _Unwind_Resume(a1);
}

void cv::MorphFilter<cv::MaxOp<double>,cv::MorphNoVec>::~MorphFilter(cv::BaseRowFilter *this)
{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_24DBF0F18;
  v2 = (void *)*((_QWORD *)this + 6);
  if (v2)
  {
    *((_QWORD *)this + 7) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 3);
  if (v3)
  {
    *((_QWORD *)this + 4) = v3;
    operator delete(v3);
  }
  cv::BaseRowFilter::~BaseRowFilter(this);
}

{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_24DBF0F18;
  v2 = (void *)*((_QWORD *)this + 6);
  if (v2)
  {
    *((_QWORD *)this + 7) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 3);
  if (v3)
  {
    *((_QWORD *)this + 4) = v3;
    operator delete(v3);
  }
  cv::BaseRowFilter::~BaseRowFilter(this);
  JUMPOUT(0x2207351BCLL);
}

_QWORD *cv::MorphFilter<cv::MaxOp<double>,cv::MorphNoVec>::operator()(_QWORD *result, uint64_t a2, uint64_t a3, int a4, int a5, int a6, int a7)
{
  uint64_t v7;
  uint64_t v8;
  _QWORD **v9;
  unint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  float64x2_t *v16;
  float64x2_t v17;
  float64x2_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  float64x2_t *v22;
  double v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  double v27;
  BOOL v28;

  if (a5 >= 1)
  {
    v7 = (a7 * a6);
    v8 = result[3];
    v9 = (_QWORD **)result[6];
    v10 = (unint64_t)(result[4] - v8) >> 3;
    v11 = a4;
    v12 = (_QWORD *)(v8 + 4);
    do
    {
      v13 = v10;
      result = v12;
      v14 = v9;
      if ((int)v10 >= 1)
      {
        do
        {
          *v14++ = *(_QWORD *)(a2 + 8 * *(int *)result) + 8 * *((_DWORD *)result - 1) * a7;
          ++result;
          --v13;
        }
        while (v13);
      }
      if ((int)v7 >= 4)
      {
        v15 = 0;
        result = *v9;
        do
        {
          v16 = (float64x2_t *)&result[v15];
          v18 = *v16;
          v17 = v16[1];
          if ((int)v10 >= 2)
          {
            v19 = v10 - 1;
            v20 = (uint64_t *)(v9 + 1);
            do
            {
              v21 = *v20++;
              v22 = (float64x2_t *)(v21 + 8 * v15);
              v18 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(*v22, v18), *(int8x16_t *)v22, (int8x16_t)v18);
              v17 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v22[1], v17), (int8x16_t)v22[1], (int8x16_t)v17);
              --v19;
            }
            while (v19);
          }
          *(float64x2_t *)(a3 + 8 * v15) = v18;
          *(float64x2_t *)(a3 + ((8 * v15) | 0x10)) = v17;
          v15 += 4;
        }
        while (v15 <= (int)v7 - 4);
        v15 = v15;
      }
      else
      {
        v15 = 0;
      }
      if ((int)v15 < (int)v7)
      {
        result = *v9;
        do
        {
          v23 = *(double *)&result[v15];
          if ((int)v10 >= 2)
          {
            v24 = v10 - 1;
            v25 = (uint64_t *)(v9 + 1);
            do
            {
              v26 = *v25++;
              v27 = *(double *)(v26 + 8 * v15);
              if (v23 < v27)
                v23 = v27;
              --v24;
            }
            while (v24);
          }
          *(double *)(a3 + 8 * v15++) = v23;
        }
        while (v15 != v7);
      }
      a3 += v11;
      a2 += 8;
      v28 = __OFSUB__(a5--, 1);
    }
    while (!((a5 < 0) ^ v28 | (a5 == 0)));
  }
  return result;
}

double cv::eigen2x2(cv *this, const float *a2, float *a3)
{
  uint64_t v3;
  float *v4;
  double result;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  float v19;
  float v20;
  float v21;
  double v22;
  double v23;
  double v24;
  double v25;
  float v26;
  float v27;
  float v28;

  if ((int)a3 >= 1)
  {
    v3 = 0;
    v4 = (float *)((char *)this + 4);
    result = 0.5;
    do
    {
      v6 = *(v4 - 1);
      v7 = *v4;
      v8 = v4[1];
      v9 = (v6 + v8) * 0.5;
      v10 = sqrt(v7 * v7 + (v6 - v8) * (v6 - v8) * 0.25);
      v11 = v9 + v10;
      v12 = fabs(v7);
      if (v12 + vabdd_f64(v9 + v10, v6) >= 0.0001)
      {
        v16 = v11 - v6;
        v13 = *v4;
      }
      else
      {
        v13 = v11 - v8;
        v14 = v12 + vabdd_f64(v11, v8);
        if (v14 >= 0.0001)
        {
          v16 = *v4;
        }
        else
        {
          v15 = 1.0 / (v14 + 0.00000011920929);
          v13 = v13 * v15;
          v16 = v15 * v7;
        }
      }
      v17 = v9 - v10;
      v18 = 1.0 / sqrt(v16 * v16 + v13 * v13 + 2.22044605e-16);
      v19 = v11;
      a2[v3] = v19;
      v20 = v13 * v18;
      a2[(v3 + 2)] = v20;
      v21 = v16 * v18;
      a2[(v3 + 3)] = v21;
      if (v12 + vabdd_f64(v17, v6) >= 0.0001)
      {
        v22 = v7;
        v7 = v17 - v6;
      }
      else
      {
        v22 = v17 - v8;
        v23 = v12 + vabdd_f64(v17, v8);
        if (v23 < 0.0001)
        {
          v24 = 1.0 / (v23 + 0.00000011920929);
          v22 = v22 * v24;
          v7 = v24 * v7;
        }
      }
      v25 = 1.0 / sqrt(v7 * v7 + v22 * v22 + 2.22044605e-16);
      v26 = v17;
      a2[(v3 + 1)] = v26;
      v27 = v22 * v25;
      a2[(v3 + 4)] = v27;
      v28 = v7 * v25;
      a2[(v3 + 5)] = v28;
      v3 += 6;
      v4 += 3;
    }
    while (6 * a3 != v3);
  }
  return result;
}

void cv::cornerMinEigenVal(cv *this, const cv::_InputArray *a2, const cv::_OutputArray *a3, int a4, unsigned int a5)
{
  void *v9;
  unsigned int *v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  int32x2_t *v19;
  _QWORD v20[3];
  unsigned int *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  cv *v26;
  uint64_t v27;
  int32x2_t v28;
  _QWORD v29[3];
  unsigned int *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int32x2_t *v34;
  cv *v35;
  uint64_t v36;

  (**(void (***)(_QWORD *__return_ptr, cv *, uint64_t))this)(v29, this, 0xFFFFFFFFLL);
  v28 = vrev64_s32(*v34);
  (*(void (**)(const cv::_InputArray *, int32x2_t *, uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 128))(a2, &v28, 5, 0xFFFFFFFFLL, 0, 0);
  (**(void (***)(_QWORD *__return_ptr, const cv::_InputArray *, uint64_t))a2)(v20, a2, 0xFFFFFFFFLL);
  cv::cornerEigenValsVecs((cv *)v29, (const cv::Mat *)v20, a3, a4, 0, a5, 0.0);
  v10 = v21;
  if (v21)
  {
    do
    {
      v11 = __ldaxr(v10);
      v12 = v11 - 1;
    }
    while (__stlxr(v12, v10));
    if (!v12)
      cv::Mat::deallocate((cv::Mat *)v20, v9);
  }
  v20[2] = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  if (SHIDWORD(v20[0]) >= 1)
  {
    v13 = 0;
    v14 = v25;
    do
      *(_DWORD *)(v14 + 4 * v13++) = 0;
    while (v13 < SHIDWORD(v20[0]));
  }
  v21 = 0;
  if (v26 != (cv *)&v27)
    cv::fastFree((void **)v26, v9);
  v15 = v30;
  if (v30)
  {
    do
    {
      v16 = __ldaxr(v15);
      v17 = v16 - 1;
    }
    while (__stlxr(v17, v15));
    if (!v17)
      cv::Mat::deallocate((cv::Mat *)v29, v9);
  }
  v29[2] = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  if (SHIDWORD(v29[0]) >= 1)
  {
    v18 = 0;
    v19 = v34;
    do
      v19->i32[v18++] = 0;
    while (v18 < SHIDWORD(v29[0]));
  }
  v30 = 0;
  if (v35 != (cv *)&v36)
    cv::fastFree((void **)v35, v9);
}

void sub_219E89260(_Unwind_Exception *a1, void *a2, uint64_t a3, ...)
{
  void *v4;
  uint64_t v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  cv::Mat::~Mat((cv::Mat *)va, a2);
  cv::Mat::~Mat((cv::Mat *)va1, v4);
  _Unwind_Resume(a1);
}

void cv::cornerEigenValsVecs(cv *this, const cv::Mat *a2, cv::Mat *a3, int a4, int a5, unsigned int a6, double a7)
{
  int v10;
  int v14;
  double v15;
  double v16;
  int v17;
  const cv::Exception *v18;
  double v19;
  unsigned int *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  float *v25;
  uint64_t v26;
  float *v27;
  uint64_t v28;
  uint64_t v29;
  float *v30;
  float *v31;
  float *v32;
  uint64_t v33;
  float v34;
  float v35;
  float v36;
  void *v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  unint64_t v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  float *v49;
  uint64_t v50;
  uint64_t v51;
  float *v52;
  float *v53;
  uint64_t v54;
  float v55;
  float v56;
  float v57;
  uint64_t v58;
  uint64_t v59;
  float *v60;
  uint64_t v61;
  uint64_t v62;
  float *v63;
  float *v64;
  uint64_t v65;
  float v66;
  float v67;
  float v68;
  float v69;
  uint64_t v70;
  uint64_t v71;
  unsigned int *v72;
  unsigned int v73;
  unsigned int v74;
  uint64_t v75;
  int *v76;
  unsigned int *v77;
  unsigned int v78;
  unsigned int v79;
  uint64_t v80;
  char *v81;
  unsigned int *v82;
  unsigned int v83;
  unsigned int v84;
  uint64_t v85;
  char *v86;
  uint64_t v87;
  _DWORD v88[2];
  _BYTE v89[32];
  _OWORD __p[4];
  int *v91;
  cv *v92;
  _QWORD v93[2];
  _OWORD v94[4];
  char *v95;
  cv *v96;
  _QWORD v97[2];
  _OWORD v98[4];
  char *v99;
  cv *v100;
  _QWORD v101[5];
  int v102[5];
  uint64_t v103;

  v10 = (int)a3;
  v103 = *MEMORY[0x24BDAC8D0];
  v14 = 1 << (a4 - 1);
  if (a4 <= 0)
    v14 = 4;
  v15 = (double)(int)a3 * (double)v14;
  if (a4 < 0)
    v15 = v15 + v15;
  if ((*(_DWORD *)this & 7) != 0)
    v16 = v15;
  else
    v16 = v15 * 255.0;
  v17 = *(_DWORD *)this & 0xFFF;
  if (v17 && v17 != 5)
  {
    std::string::basic_string[abi:ne180100]<0>(v94, "src.type() == CV_8UC1 || src.type() == CV_32FC1");
    std::string::basic_string[abi:ne180100]<0>(__p, "cornerEigenValsVecs");
    std::string::basic_string[abi:ne180100]<0>(v102, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/imgproc/corner.cpp");
    cv::Exception::Exception(v98, 4294967081, v94, __p, v102, 263);
    cv::error((cv *)v98, v18);
  }
  v99 = (char *)v98 + 8;
  v100 = (cv *)v101;
  v101[0] = 0;
  v101[1] = 0;
  LODWORD(v98[0]) = 1124007936;
  v19 = 1.0 / v16;
  memset((char *)v98 + 4, 0, 48);
  v98[3] = 0u;
  v95 = (char *)v94 + 8;
  v96 = (cv *)v97;
  v97[0] = 0;
  v97[1] = 0;
  LODWORD(v94[0]) = 1124007936;
  memset((char *)v94 + 4, 0, 48);
  v94[3] = 0u;
  cv::_InputArray::_InputArray((uint64_t)__p, this);
  cv::_OutputArray::_OutputArray((uint64_t)v102, (cv::Mat *)v98);
  if (a4 < 1)
  {
    cv::Scharr((cv *)__p, (const cv::_InputArray *)v102, (const cv::_OutputArray *)5, (const cv::_OutputArray *)1, 0, a6, v19, 0.0);
    cv::_InputArray::_InputArray((uint64_t)__p, this);
    cv::_OutputArray::_OutputArray((uint64_t)v102, (cv::Mat *)v94);
    cv::Scharr((cv *)__p, (const cv::_InputArray *)v102, (const cv::_OutputArray *)5, 0, 1, a6, v19, 0.0);
  }
  else
  {
    cv::Sobel((cv *)__p, (const cv::_InputArray *)v102, (const cv::_OutputArray *)5, (const cv::_OutputArray *)1, 0, a4, a6, v19, 0.0);
    cv::_InputArray::_InputArray((uint64_t)__p, this);
    cv::_OutputArray::_OutputArray((uint64_t)v102, (cv::Mat *)v94);
    cv::Sobel((cv *)__p, (const cv::_InputArray *)v102, (const cv::_OutputArray *)5, 0, 1, a4, a6, v19, 0.0);
  }
  v20 = (unsigned int *)*((_QWORD *)this + 8);
  v22 = *v20;
  v21 = v20[1];
  v91 = (int *)__p + 2;
  v92 = (cv *)v93;
  v93[0] = 0;
  v93[1] = 0;
  LODWORD(__p[0]) = 1124007936;
  memset((char *)__p + 4, 0, 48);
  __p[3] = 0u;
  v102[0] = v22;
  v102[1] = v21;
  cv::Mat::create((cv::Mat *)__p, (cv::Mat *)2, v102, 21);
  if ((int)v22 >= 1)
  {
    v23 = 0;
    v24 = v93[0];
    v25 = *(float **)&v98[1];
    v26 = v101[0];
    v27 = *(float **)&v94[1];
    v28 = v97[0];
    v29 = *(_QWORD *)&__p[1] + 4;
    do
    {
      if ((int)v21 >= 1)
      {
        v30 = v27;
        v31 = (float *)v29;
        v32 = v25;
        v33 = v21;
        do
        {
          v34 = *v32++;
          v35 = v34;
          v36 = *v30++;
          *(v31 - 1) = v35 * v35;
          *v31 = v35 * v36;
          v31[1] = v36 * v36;
          v31 += 3;
          --v33;
        }
        while (v33);
      }
      ++v23;
      v25 = (float *)((char *)v25 + v26);
      v29 += v24;
      v27 = (float *)((char *)v27 + v28);
    }
    while (v23 != v22);
  }
  cv::_InputArray::_InputArray((uint64_t)v102, (const cv::Mat *)__p);
  cv::_OutputArray::_OutputArray((uint64_t)v89, (cv::Mat *)__p);
  v88[0] = v10;
  v88[1] = v10;
  v87 = -1;
  cv::boxFilter((void (***)(uint64_t *__return_ptr, _QWORD, uint64_t))v102, (uint64_t)v89, __p[0] & 7, v88, &v87, 0, a6);
  if (a5 == 1)
  {
    v41 = *v91;
    v42 = v91[1];
    if ((BYTE1(__p[0]) & 0x40) != 0
      && ((*(_DWORD *)a2 & 0x4000) == 0 ? (v43 = 1) : (v43 = *v91), v42 *= v43, (*(_DWORD *)a2 & 0x4000) != 0))
    {
      v41 = 1;
    }
    else if (v41 < 1)
    {
      goto LABEL_60;
    }
    v58 = 0;
    v59 = v93[0];
    v60 = (float *)*((_QWORD *)a2 + 2);
    v61 = *((_QWORD *)a2 + 10);
    v62 = *(_QWORD *)&__p[1] + 8;
    do
    {
      if (v42 >= 1)
      {
        v63 = (float *)v62;
        v64 = v60;
        v65 = v42;
        do
        {
          v66 = *(v63 - 2);
          v67 = *(v63 - 1);
          v68 = *v63;
          v63 += 3;
          v69 = (float)((float)(v66 * v68) - (float)(v67 * v67)) + -((float)(v66 + v68) * a7) * (float)(v66 + v68);
          *v64++ = v69;
          --v65;
        }
        while (v65);
      }
      ++v58;
      v60 = (float *)((char *)v60 + v61);
      v62 += v59;
    }
    while (v58 != v41);
  }
  else
  {
    if (a5)
    {
      v44 = *v91;
      v45 = v91[1];
      if ((BYTE1(__p[0]) & 0x40) != 0
        && ((*(_DWORD *)a2 & 0x4000) == 0 ? (v46 = 1) : (v46 = *v91),
            v45 = (v46 * v45),
            (*(_DWORD *)a2 & 0x4000) != 0))
      {
        v44 = 1;
      }
      else if (v44 < 1)
      {
        goto LABEL_60;
      }
      v70 = 0;
      v71 = v44;
      do
      {
        cv::eigen2x2((cv *)(*(_QWORD *)&__p[1] + v93[0] * v70), (const float *)(*((_QWORD *)a2 + 2) + *((_QWORD *)a2 + 10) * v70), (float *)v45);
        ++v70;
      }
      while (v71 != v70);
      goto LABEL_60;
    }
    v38 = *v91;
    v39 = v91[1];
    if ((BYTE1(__p[0]) & 0x40) != 0
      && ((*(_DWORD *)a2 & 0x4000) == 0 ? (v40 = 1) : (v40 = *v91), v39 *= v40, (*(_DWORD *)a2 & 0x4000) != 0))
    {
      v38 = 1;
    }
    else if (v38 < 1)
    {
      goto LABEL_60;
    }
    v47 = 0;
    v48 = v93[0];
    v49 = (float *)*((_QWORD *)a2 + 2);
    v50 = *((_QWORD *)a2 + 10);
    v51 = *(_QWORD *)&__p[1] + 8;
    do
    {
      if (v39 >= 1)
      {
        v52 = (float *)v51;
        v53 = v49;
        v54 = v39;
        do
        {
          v55 = *(v52 - 1);
          v56 = *(v52 - 2) * 0.5;
          v57 = *v52;
          v52 += 3;
          *v53++ = (float)(v56 + (float)(v57 * 0.5))
                 - sqrtf((float)(v55 * v55) + (float)((float)(v56 - (float)(v57 * 0.5))
                                                    * (float)(v56 - (float)(v57 * 0.5))));
          --v54;
        }
        while (v54);
      }
      ++v47;
      v49 = (float *)((char *)v49 + v50);
      v51 += v48;
    }
    while (v47 != v38);
  }
LABEL_60:
  v72 = (unsigned int *)*((_QWORD *)&__p[1] + 1);
  if (*((_QWORD *)&__p[1] + 1))
  {
    do
    {
      v73 = __ldaxr(v72);
      v74 = v73 - 1;
    }
    while (__stlxr(v74, v72));
    if (!v74)
      cv::Mat::deallocate((cv::Mat *)__p, v37);
  }
  *(_QWORD *)&__p[1] = 0;
  memset(&__p[2], 0, 24);
  if (SDWORD1(__p[0]) >= 1)
  {
    v75 = 0;
    v76 = v91;
    do
      v76[v75++] = 0;
    while (v75 < SDWORD1(__p[0]));
  }
  *((_QWORD *)&__p[1] + 1) = 0;
  if (v92 != (cv *)v93)
    cv::fastFree((void **)v92, v37);
  v77 = (unsigned int *)*((_QWORD *)&v94[1] + 1);
  if (*((_QWORD *)&v94[1] + 1))
  {
    do
    {
      v78 = __ldaxr(v77);
      v79 = v78 - 1;
    }
    while (__stlxr(v79, v77));
    if (!v79)
      cv::Mat::deallocate((cv::Mat *)v94, v37);
  }
  *(_QWORD *)&v94[1] = 0;
  memset(&v94[2], 0, 24);
  if (SDWORD1(v94[0]) >= 1)
  {
    v80 = 0;
    v81 = v95;
    do
      *(_DWORD *)&v81[4 * v80++] = 0;
    while (v80 < SDWORD1(v94[0]));
  }
  *((_QWORD *)&v94[1] + 1) = 0;
  if (v96 != (cv *)v97)
    cv::fastFree((void **)v96, v37);
  v82 = (unsigned int *)*((_QWORD *)&v98[1] + 1);
  if (*((_QWORD *)&v98[1] + 1))
  {
    do
    {
      v83 = __ldaxr(v82);
      v84 = v83 - 1;
    }
    while (__stlxr(v84, v82));
    if (!v84)
      cv::Mat::deallocate((cv::Mat *)v98, v37);
  }
  *(_QWORD *)&v98[1] = 0;
  memset(&v98[2], 0, 24);
  if (SDWORD1(v98[0]) >= 1)
  {
    v85 = 0;
    v86 = v99;
    do
      *(_DWORD *)&v86[4 * v85++] = 0;
    while (v85 < SDWORD1(v98[0]));
  }
  *((_QWORD *)&v98[1] + 1) = 0;
  if (v100 != (cv *)v101)
    cv::fastFree((void **)v100, v37);
}

void sub_219E89998(_Unwind_Exception *a1, void *a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45)
{
  void *v46;

  cv::Mat::~Mat((cv::Mat *)&a30, a2);
  cv::Mat::~Mat((cv::Mat *)&a45, v46);
  _Unwind_Resume(a1);
}

void cv::cornerHarris(cv *this, const cv::_InputArray *a2, const cv::_OutputArray *a3, int a4, unsigned int a5, double a6)
{
  void *v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int *v17;
  unsigned int v18;
  unsigned int v19;
  uint64_t v20;
  int32x2_t *v21;
  _QWORD v22[3];
  unsigned int *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  cv *v28;
  uint64_t v29;
  int32x2_t v30;
  _QWORD v31[3];
  unsigned int *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int32x2_t *v36;
  cv *v37;
  uint64_t v38;

  (**(void (***)(_QWORD *__return_ptr, cv *, uint64_t))this)(v31, this, 0xFFFFFFFFLL);
  v30 = vrev64_s32(*v36);
  (*(void (**)(const cv::_InputArray *, int32x2_t *, uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 128))(a2, &v30, 5, 0xFFFFFFFFLL, 0, 0);
  (**(void (***)(_QWORD *__return_ptr, const cv::_InputArray *, uint64_t))a2)(v22, a2, 0xFFFFFFFFLL);
  cv::cornerEigenValsVecs((cv *)v31, (const cv::Mat *)v22, a3, a4, 1, a5, a6);
  v12 = v23;
  if (v23)
  {
    do
    {
      v13 = __ldaxr(v12);
      v14 = v13 - 1;
    }
    while (__stlxr(v14, v12));
    if (!v14)
      cv::Mat::deallocate((cv::Mat *)v22, v11);
  }
  v22[2] = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  if (SHIDWORD(v22[0]) >= 1)
  {
    v15 = 0;
    v16 = v27;
    do
      *(_DWORD *)(v16 + 4 * v15++) = 0;
    while (v15 < SHIDWORD(v22[0]));
  }
  v23 = 0;
  if (v28 != (cv *)&v29)
    cv::fastFree((void **)v28, v11);
  v17 = v32;
  if (v32)
  {
    do
    {
      v18 = __ldaxr(v17);
      v19 = v18 - 1;
    }
    while (__stlxr(v19, v17));
    if (!v19)
      cv::Mat::deallocate((cv::Mat *)v31, v11);
  }
  v31[2] = 0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  if (SHIDWORD(v31[0]) >= 1)
  {
    v20 = 0;
    v21 = v36;
    do
      v21->i32[v20++] = 0;
    while (v20 < SHIDWORD(v31[0]));
  }
  v32 = 0;
  if (v37 != (cv *)&v38)
    cv::fastFree((void **)v37, v11);
}

void sub_219E89C1C(_Unwind_Exception *a1, void *a2, uint64_t a3, ...)
{
  void *v4;
  uint64_t v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  cv::Mat::~Mat((cv::Mat *)va, a2);
  cv::Mat::~Mat((cv::Mat *)va1, v4);
  _Unwind_Resume(a1);
}

void cv::MatOp::roi(uint64_t a1, _QWORD *a2, _QWORD *a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v9;
  int v10;
  void *v11;
  void *v12;
  unsigned int *v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  _BYTE *v17;
  unsigned int *v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  _BYTE *v22;
  unsigned int *v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t v26;
  _BYTE *v27;
  uint64_t v28;
  void *v29;
  unsigned int *v30;
  unsigned int v31;
  unsigned int *v32;
  unsigned int v33;
  unsigned int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  void *v39;
  void *v40;
  unsigned int *v41;
  unsigned int v42;
  unsigned int v43;
  uint64_t v44;
  _BYTE *v45;
  unsigned int *v46;
  unsigned int v47;
  unsigned int v48;
  uint64_t v49;
  _BYTE *v50;
  unsigned int *v51;
  unsigned int v52;
  unsigned int v53;
  uint64_t v54;
  _BYTE *v55;
  unsigned int *v56;
  unsigned int v57;
  unsigned int v58;
  uint64_t v59;
  _BYTE *v60;
  cv *v61;
  _QWORD *v62;
  uint64_t v63;
  unsigned int *v64;
  unsigned int v65;
  unsigned int v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  void *v70;
  unsigned int *v71;
  unsigned int v72;
  unsigned int *v73;
  unsigned int v74;
  unsigned int v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  cv *v79;
  _QWORD *v80;
  uint64_t v81;
  unsigned int *v82;
  unsigned int v83;
  unsigned int v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  void *v88;
  unsigned int *v89;
  unsigned int v90;
  unsigned int *v91;
  unsigned int v92;
  unsigned int v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  cv *v97;
  _QWORD *v98;
  uint64_t v99;
  unsigned int *v100;
  unsigned int v101;
  unsigned int v102;
  uint64_t v103;
  uint64_t v104;
  _OWORD v105[2];
  _BYTE v106[64];
  _BYTE *v107;
  cv *v108;
  _QWORD v109[2];
  _BYTE v110[64];
  _BYTE *v111;
  cv *v112;
  uint64_t v113;
  uint64_t v114;
  _BYTE v115[64];
  _BYTE *v116;
  cv *v117;
  _QWORD v118[2];
  _BYTE v119[64];
  _BYTE *v120;
  cv *v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  __int128 v127;
  __int128 v128;
  uint64_t v129;
  uint64_t v130;
  cv *v131;
  _BYTE v132[272];

  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1))
  {
    v9 = *a2;
    v10 = *((_DWORD *)a2 + 2);
    v120 = &v119[8];
    v121 = (cv *)&v122;
    v122 = 0;
    v123 = 0;
    *(_DWORD *)v119 = 1124007936;
    memset(&v119[4], 0, 60);
    v116 = &v115[8];
    v117 = (cv *)v118;
    v118[0] = 0;
    v118[1] = 0;
    *(_DWORD *)v115 = 1124007936;
    memset(&v115[4], 0, 60);
    v111 = &v110[8];
    v112 = (cv *)&v113;
    v113 = 0;
    v114 = 0;
    *(_DWORD *)v110 = 1124007936;
    memset(&v110[4], 0, 60);
    cv::MatExpr::MatExpr((uint64_t)&v124, v9, v10, (cv::Mat *)v119, (cv::Mat *)v115, (cv::Mat *)v110, (uint64_t)(a2 + 40), *((double *)a2 + 38), *((double *)a2 + 39));
    cv::MatExpr::operator=(a5, &v124);
    cv::MatExpr::~MatExpr((cv::MatExpr *)&v124, v11);
    v13 = *(unsigned int **)&v110[24];
    if (*(_QWORD *)&v110[24])
    {
      do
      {
        v14 = __ldaxr(v13);
        v15 = v14 - 1;
      }
      while (__stlxr(v15, v13));
      if (!v15)
        cv::Mat::deallocate((cv::Mat *)v110, v12);
    }
    *(_QWORD *)&v110[16] = 0;
    memset(&v110[32], 0, 24);
    if (*(int *)&v110[4] >= 1)
    {
      v16 = 0;
      v17 = v111;
      do
        *(_DWORD *)&v17[4 * v16++] = 0;
      while (v16 < *(int *)&v110[4]);
    }
    *(_QWORD *)&v110[24] = 0;
    if (v112 != (cv *)&v113)
      cv::fastFree((void **)v112, v12);
    v18 = *(unsigned int **)&v115[24];
    if (*(_QWORD *)&v115[24])
    {
      do
      {
        v19 = __ldaxr(v18);
        v20 = v19 - 1;
      }
      while (__stlxr(v20, v18));
      if (!v20)
        cv::Mat::deallocate((cv::Mat *)v115, v12);
    }
    *(_QWORD *)&v115[16] = 0;
    memset(&v115[32], 0, 24);
    if (*(int *)&v115[4] >= 1)
    {
      v21 = 0;
      v22 = v116;
      do
        *(_DWORD *)&v22[4 * v21++] = 0;
      while (v21 < *(int *)&v115[4]);
    }
    *(_QWORD *)&v115[24] = 0;
    if (v117 != (cv *)v118)
      cv::fastFree((void **)v117, v12);
    v23 = *(unsigned int **)&v119[24];
    if (*(_QWORD *)&v119[24])
    {
      do
      {
        v24 = __ldaxr(v23);
        v25 = v24 - 1;
      }
      while (__stlxr(v25, v23));
      if (!v25)
        cv::Mat::deallocate((cv::Mat *)v119, v12);
    }
    *(_QWORD *)&v119[16] = 0;
    memset(&v119[32], 0, 24);
    if (*(int *)&v119[4] >= 1)
    {
      v26 = 0;
      v27 = v120;
      do
        *(_DWORD *)&v27[4 * v26++] = 0;
      while (v26 < *(int *)&v119[4]);
    }
    *(_QWORD *)&v119[24] = 0;
    if (v121 != (cv *)&v122)
      cv::fastFree((void **)v121, v12);
    if (!a2[4])
    {
LABEL_92:
      if (!a2[16])
        goto LABEL_119;
      v69 = *a4;
      *(_QWORD *)v119 = *a3;
      *(_QWORD *)v115 = v69;
      cv::Mat::Mat(&v124, a2 + 14, v119, v115);
      v71 = (unsigned int *)v127;
      if ((uint64_t *)(a5 + 112) == &v124)
      {
LABEL_110:
        if (v71)
        {
          do
          {
            v83 = __ldaxr(v71);
            v84 = v83 - 1;
          }
          while (__stlxr(v84, v71));
          if (!v84)
            cv::Mat::deallocate((cv::Mat *)&v124, v70);
        }
        v126 = 0;
        *((_QWORD *)&v127 + 1) = 0;
        v128 = 0uLL;
        if (SHIDWORD(v124) >= 1)
        {
          v85 = 0;
          v86 = v130;
          do
            *(_DWORD *)(v86 + 4 * v85++) = 0;
          while (v85 < SHIDWORD(v124));
        }
        *(_QWORD *)&v127 = 0;
        if (v131 != (cv *)v132)
          cv::fastFree((void **)v131, v70);
LABEL_119:
        if (!a2[28])
          return;
        v87 = *a4;
        *(_QWORD *)v119 = *a3;
        *(_QWORD *)v115 = v87;
        cv::Mat::Mat(&v124, a2 + 26, v119, v115);
        v89 = (unsigned int *)v127;
        if ((uint64_t *)(a5 + 208) == &v124)
          goto LABEL_137;
        if ((_QWORD)v127)
        {
          do
            v90 = __ldaxr(v89);
          while (__stlxr(v90 + 1, v89));
        }
        v91 = *(unsigned int **)(a5 + 232);
        if (v91)
        {
          do
          {
            v92 = __ldaxr(v91);
            v93 = v92 - 1;
          }
          while (__stlxr(v93, v91));
          if (!v93)
            cv::Mat::deallocate((cv::Mat *)(a5 + 208), v88);
        }
        *(_QWORD *)(a5 + 224) = 0;
        *(_QWORD *)(a5 + 248) = 0;
        *(_QWORD *)(a5 + 256) = 0;
        *(_QWORD *)(a5 + 240) = 0;
        if (*(int *)(a5 + 212) <= 0)
        {
          *(_QWORD *)(a5 + 232) = 0;
          *(_DWORD *)(a5 + 208) = v124;
        }
        else
        {
          v94 = 0;
          v95 = *(_QWORD *)(a5 + 272);
          do
          {
            *(_DWORD *)(v95 + 4 * v94++) = 0;
            v96 = *(int *)(a5 + 212);
          }
          while (v94 < v96);
          *(_QWORD *)(a5 + 232) = 0;
          *(_DWORD *)(a5 + 208) = v124;
          if ((int)v96 > 2)
            goto LABEL_135;
        }
        if (SHIDWORD(v124) <= 2)
        {
          *(_DWORD *)(a5 + 212) = HIDWORD(v124);
          *(_QWORD *)(a5 + 216) = v125;
          v97 = v131;
          v98 = *(_QWORD **)(a5 + 280);
          *v98 = *(_QWORD *)v131;
          v98[1] = *((_QWORD *)v97 + 1);
LABEL_136:
          v99 = v129;
          *(_QWORD *)(a5 + 224) = v126;
          *(_OWORD *)(a5 + 248) = v128;
          v100 = (unsigned int *)v127;
          *(_OWORD *)(a5 + 232) = v127;
          *(_QWORD *)(a5 + 264) = v99;
          v89 = v100;
LABEL_137:
          if (v89)
          {
            do
            {
              v101 = __ldaxr(v89);
              v102 = v101 - 1;
            }
            while (__stlxr(v102, v89));
            if (!v102)
              cv::Mat::deallocate((cv::Mat *)&v124, v88);
          }
          v126 = 0;
          *((_QWORD *)&v127 + 1) = 0;
          v128 = 0uLL;
          if (SHIDWORD(v124) >= 1)
          {
            v103 = 0;
            v104 = v130;
            do
              *(_DWORD *)(v104 + 4 * v103++) = 0;
            while (v103 < SHIDWORD(v124));
          }
          *(_QWORD *)&v127 = 0;
          if (v131 != (cv *)v132)
            cv::fastFree((void **)v131, v88);
          return;
        }
LABEL_135:
        cv::Mat::copySize((cv::Mat *)(a5 + 208), (const cv::Mat *)&v124);
        goto LABEL_136;
      }
      if ((_QWORD)v127)
      {
        do
          v72 = __ldaxr(v71);
        while (__stlxr(v72 + 1, v71));
      }
      v73 = *(unsigned int **)(a5 + 136);
      if (v73)
      {
        do
        {
          v74 = __ldaxr(v73);
          v75 = v74 - 1;
        }
        while (__stlxr(v75, v73));
        if (!v75)
          cv::Mat::deallocate((cv::Mat *)(a5 + 112), v70);
      }
      *(_QWORD *)(a5 + 128) = 0;
      *(_QWORD *)(a5 + 152) = 0;
      *(_QWORD *)(a5 + 160) = 0;
      *(_QWORD *)(a5 + 144) = 0;
      if (*(int *)(a5 + 116) <= 0)
      {
        *(_QWORD *)(a5 + 136) = 0;
        *(_DWORD *)(a5 + 112) = v124;
      }
      else
      {
        v76 = 0;
        v77 = *(_QWORD *)(a5 + 176);
        do
        {
          *(_DWORD *)(v77 + 4 * v76++) = 0;
          v78 = *(int *)(a5 + 116);
        }
        while (v76 < v78);
        *(_QWORD *)(a5 + 136) = 0;
        *(_DWORD *)(a5 + 112) = v124;
        if ((int)v78 > 2)
          goto LABEL_108;
      }
      if (SHIDWORD(v124) <= 2)
      {
        *(_DWORD *)(a5 + 116) = HIDWORD(v124);
        *(_QWORD *)(a5 + 120) = v125;
        v79 = v131;
        v80 = *(_QWORD **)(a5 + 184);
        *v80 = *(_QWORD *)v131;
        v80[1] = *((_QWORD *)v79 + 1);
LABEL_109:
        v81 = v129;
        *(_QWORD *)(a5 + 128) = v126;
        *(_OWORD *)(a5 + 152) = v128;
        v82 = (unsigned int *)v127;
        *(_OWORD *)(a5 + 136) = v127;
        *(_QWORD *)(a5 + 168) = v81;
        v71 = v82;
        goto LABEL_110;
      }
LABEL_108:
      cv::Mat::copySize((cv::Mat *)(a5 + 112), (const cv::Mat *)&v124);
      goto LABEL_109;
    }
    v28 = *a4;
    *(_QWORD *)v119 = *a3;
    *(_QWORD *)v115 = v28;
    cv::Mat::Mat(&v124, a2 + 2, v119, v115);
    v30 = (unsigned int *)v127;
    if ((uint64_t *)(a5 + 16) == &v124)
    {
LABEL_83:
      if (v30)
      {
        do
        {
          v65 = __ldaxr(v30);
          v66 = v65 - 1;
        }
        while (__stlxr(v66, v30));
        if (!v66)
          cv::Mat::deallocate((cv::Mat *)&v124, v29);
      }
      v126 = 0;
      *((_QWORD *)&v127 + 1) = 0;
      v128 = 0uLL;
      if (SHIDWORD(v124) >= 1)
      {
        v67 = 0;
        v68 = v130;
        do
          *(_DWORD *)(v68 + 4 * v67++) = 0;
        while (v67 < SHIDWORD(v124));
      }
      *(_QWORD *)&v127 = 0;
      if (v131 != (cv *)v132)
        cv::fastFree((void **)v131, v29);
      goto LABEL_92;
    }
    if ((_QWORD)v127)
    {
      do
        v31 = __ldaxr(v30);
      while (__stlxr(v31 + 1, v30));
    }
    v32 = *(unsigned int **)(a5 + 40);
    if (v32)
    {
      do
      {
        v33 = __ldaxr(v32);
        v34 = v33 - 1;
      }
      while (__stlxr(v34, v32));
      if (!v34)
        cv::Mat::deallocate((cv::Mat *)(a5 + 16), v29);
    }
    *(_QWORD *)(a5 + 32) = 0;
    *(_QWORD *)(a5 + 56) = 0;
    *(_QWORD *)(a5 + 64) = 0;
    *(_QWORD *)(a5 + 48) = 0;
    if (*(int *)(a5 + 20) <= 0)
    {
      *(_QWORD *)(a5 + 40) = 0;
      *(_DWORD *)(a5 + 16) = v124;
    }
    else
    {
      v35 = 0;
      v36 = *(_QWORD *)(a5 + 80);
      do
      {
        *(_DWORD *)(v36 + 4 * v35++) = 0;
        v37 = *(int *)(a5 + 20);
      }
      while (v35 < v37);
      *(_QWORD *)(a5 + 40) = 0;
      *(_DWORD *)(a5 + 16) = v124;
      if ((int)v37 > 2)
        goto LABEL_81;
    }
    if (SHIDWORD(v124) <= 2)
    {
      *(_DWORD *)(a5 + 20) = HIDWORD(v124);
      *(_QWORD *)(a5 + 24) = v125;
      v61 = v131;
      v62 = *(_QWORD **)(a5 + 88);
      *v62 = *(_QWORD *)v131;
      v62[1] = *((_QWORD *)v61 + 1);
LABEL_82:
      v63 = v129;
      *(_QWORD *)(a5 + 32) = v126;
      *(_OWORD *)(a5 + 56) = v128;
      v64 = (unsigned int *)v127;
      *(_OWORD *)(a5 + 40) = v127;
      *(_QWORD *)(a5 + 72) = v63;
      v30 = v64;
      goto LABEL_83;
    }
LABEL_81:
    cv::Mat::copySize((cv::Mat *)(a5 + 16), (const cv::Mat *)&v124);
    goto LABEL_82;
  }
  v120 = &v119[8];
  v121 = (cv *)&v122;
  v122 = 0;
  v123 = 0;
  *(_DWORD *)v119 = 1124007936;
  memset(&v119[4], 0, 60);
  (*(void (**)(_QWORD, _QWORD *, _BYTE *, uint64_t))(*(_QWORD *)*a2 + 24))(*a2, a2, v119, 0xFFFFFFFFLL);
  v38 = *a4;
  *(_QWORD *)v110 = *a3;
  *(_QWORD *)v106 = v38;
  cv::Mat::Mat(v115, v119, v110, v106);
  v111 = &v110[8];
  v112 = (cv *)&v113;
  v113 = 0;
  v114 = 0;
  *(_DWORD *)v110 = 1124007936;
  memset(&v110[4], 0, 60);
  v107 = &v106[8];
  v108 = (cv *)v109;
  v109[0] = 0;
  v109[1] = 0;
  *(_DWORD *)v106 = 1124007936;
  memset(&v106[4], 0, 60);
  memset(v105, 0, sizeof(v105));
  cv::MatExpr::MatExpr((uint64_t)&v124, (uint64_t)&cv::g_MatOp_Identity, 0, (cv::Mat *)v115, (cv::Mat *)v110, (cv::Mat *)v106, (uint64_t)v105, 1.0, 1.0);
  cv::MatExpr::operator=(a5, &v124);
  cv::MatExpr::~MatExpr((cv::MatExpr *)&v124, v39);
  v41 = *(unsigned int **)&v106[24];
  if (*(_QWORD *)&v106[24])
  {
    do
    {
      v42 = __ldaxr(v41);
      v43 = v42 - 1;
    }
    while (__stlxr(v43, v41));
    if (!v43)
      cv::Mat::deallocate((cv::Mat *)v106, v40);
  }
  *(_QWORD *)&v106[16] = 0;
  memset(&v106[32], 0, 24);
  if (*(int *)&v106[4] >= 1)
  {
    v44 = 0;
    v45 = v107;
    do
      *(_DWORD *)&v45[4 * v44++] = 0;
    while (v44 < *(int *)&v106[4]);
  }
  *(_QWORD *)&v106[24] = 0;
  if (v108 != (cv *)v109)
    cv::fastFree((void **)v108, v40);
  v46 = *(unsigned int **)&v110[24];
  if (*(_QWORD *)&v110[24])
  {
    do
    {
      v47 = __ldaxr(v46);
      v48 = v47 - 1;
    }
    while (__stlxr(v48, v46));
    if (!v48)
      cv::Mat::deallocate((cv::Mat *)v110, v40);
  }
  *(_QWORD *)&v110[16] = 0;
  memset(&v110[32], 0, 24);
  if (*(int *)&v110[4] >= 1)
  {
    v49 = 0;
    v50 = v111;
    do
      *(_DWORD *)&v50[4 * v49++] = 0;
    while (v49 < *(int *)&v110[4]);
  }
  *(_QWORD *)&v110[24] = 0;
  if (v112 != (cv *)&v113)
    cv::fastFree((void **)v112, v40);
  v51 = *(unsigned int **)&v115[24];
  if (*(_QWORD *)&v115[24])
  {
    do
    {
      v52 = __ldaxr(v51);
      v53 = v52 - 1;
    }
    while (__stlxr(v53, v51));
    if (!v53)
      cv::Mat::deallocate((cv::Mat *)v115, v40);
  }
  *(_QWORD *)&v115[16] = 0;
  memset(&v115[32], 0, 24);
  if (*(int *)&v115[4] >= 1)
  {
    v54 = 0;
    v55 = v116;
    do
      *(_DWORD *)&v55[4 * v54++] = 0;
    while (v54 < *(int *)&v115[4]);
  }
  *(_QWORD *)&v115[24] = 0;
  if (v117 != (cv *)v118)
    cv::fastFree((void **)v117, v40);
  v56 = *(unsigned int **)&v119[24];
  if (*(_QWORD *)&v119[24])
  {
    do
    {
      v57 = __ldaxr(v56);
      v58 = v57 - 1;
    }
    while (__stlxr(v58, v56));
    if (!v58)
      cv::Mat::deallocate((cv::Mat *)v119, v40);
  }
  *(_QWORD *)&v119[16] = 0;
  memset(&v119[32], 0, 24);
  if (*(int *)&v119[4] >= 1)
  {
    v59 = 0;
    v60 = v120;
    do
      *(_DWORD *)&v60[4 * v59++] = 0;
    while (v59 < *(int *)&v119[4]);
  }
  *(_QWORD *)&v119[24] = 0;
  if (v121 != (cv *)&v122)
    cv::fastFree((void **)v121, v40);
}

void sub_219E8A658(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61)
{
  cv::Mat::~Mat((cv::Mat *)&a61, a2);
  _Unwind_Resume(a1);
}

uint64_t cv::MatExpr::operator=(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;
  const cv::Mat *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  _QWORD *v15;
  _QWORD *v16;
  unsigned int *v17;
  unsigned int v18;
  unsigned int *v19;
  unsigned int v20;
  unsigned int v21;
  const cv::Mat *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  _QWORD *v27;
  _QWORD *v28;
  unsigned int *v29;
  unsigned int v30;
  unsigned int *v31;
  unsigned int v32;
  unsigned int v33;
  const cv::Mat *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  _QWORD *v39;
  _QWORD *v40;
  __int128 v41;
  __int128 v42;

  v4 = *a2;
  *(_DWORD *)(a1 + 8) = *((_DWORD *)a2 + 2);
  *(_QWORD *)a1 = v4;
  if ((uint64_t *)a1 != a2)
  {
    v5 = (unsigned int *)a2[5];
    if (v5)
    {
      do
        v6 = __ldaxr(v5);
      while (__stlxr(v6 + 1, v5));
    }
    v7 = *(unsigned int **)(a1 + 40);
    if (v7)
    {
      do
      {
        v8 = __ldaxr(v7);
        v9 = v8 - 1;
      }
      while (__stlxr(v9, v7));
      if (!v9)
        cv::Mat::deallocate((cv::Mat *)(a1 + 16), a2);
    }
    v10 = (const cv::Mat *)(a2 + 2);
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 56) = 0;
    *(_QWORD *)(a1 + 64) = 0;
    *(_QWORD *)(a1 + 48) = 0;
    if (*(int *)(a1 + 20) <= 0)
    {
      *(_QWORD *)(a1 + 40) = 0;
      *(_DWORD *)(a1 + 16) = *(_DWORD *)v10;
    }
    else
    {
      v11 = 0;
      v12 = *(_QWORD *)(a1 + 80);
      do
      {
        *(_DWORD *)(v12 + 4 * v11++) = 0;
        v13 = *(int *)(a1 + 20);
      }
      while (v11 < v13);
      *(_QWORD *)(a1 + 40) = 0;
      *(_DWORD *)(a1 + 16) = *(_DWORD *)v10;
      if ((int)v13 > 2)
        goto LABEL_16;
    }
    v14 = *((_DWORD *)a2 + 5);
    if (v14 <= 2)
    {
      *(_DWORD *)(a1 + 20) = v14;
      *(_QWORD *)(a1 + 24) = a2[3];
      v15 = (_QWORD *)a2[11];
      v16 = *(_QWORD **)(a1 + 88);
      *v16 = *v15;
      v16[1] = v15[1];
      goto LABEL_17;
    }
LABEL_16:
    cv::Mat::copySize((cv::Mat *)(a1 + 16), v10);
LABEL_17:
    *(_OWORD *)(a1 + 48) = *((_OWORD *)a2 + 3);
    *(_QWORD *)(a1 + 64) = a2[8];
    *(_OWORD *)(a1 + 32) = *((_OWORD *)a2 + 2);
    *(_QWORD *)(a1 + 72) = a2[9];
    v17 = (unsigned int *)a2[17];
    if (v17)
    {
      do
        v18 = __ldaxr(v17);
      while (__stlxr(v18 + 1, v17));
    }
    v19 = *(unsigned int **)(a1 + 136);
    if (v19)
    {
      do
      {
        v20 = __ldaxr(v19);
        v21 = v20 - 1;
      }
      while (__stlxr(v21, v19));
      if (!v21)
        cv::Mat::deallocate((cv::Mat *)(a1 + 112), v10);
    }
    v22 = (const cv::Mat *)(a2 + 14);
    *(_QWORD *)(a1 + 128) = 0;
    *(_QWORD *)(a1 + 152) = 0;
    *(_QWORD *)(a1 + 160) = 0;
    *(_QWORD *)(a1 + 144) = 0;
    if (*(int *)(a1 + 116) <= 0)
    {
      *(_QWORD *)(a1 + 136) = 0;
      *(_DWORD *)(a1 + 112) = *(_DWORD *)v22;
    }
    else
    {
      v23 = 0;
      v24 = *(_QWORD *)(a1 + 176);
      do
      {
        *(_DWORD *)(v24 + 4 * v23++) = 0;
        v25 = *(int *)(a1 + 116);
      }
      while (v23 < v25);
      *(_QWORD *)(a1 + 136) = 0;
      *(_DWORD *)(a1 + 112) = *(_DWORD *)v22;
      if ((int)v25 > 2)
        goto LABEL_31;
    }
    v26 = *((_DWORD *)a2 + 29);
    if (v26 <= 2)
    {
      *(_DWORD *)(a1 + 116) = v26;
      *(_QWORD *)(a1 + 120) = a2[15];
      v27 = (_QWORD *)a2[23];
      v28 = *(_QWORD **)(a1 + 184);
      *v28 = *v27;
      v28[1] = v27[1];
      goto LABEL_32;
    }
LABEL_31:
    cv::Mat::copySize((cv::Mat *)(a1 + 112), v22);
LABEL_32:
    *(_OWORD *)(a1 + 144) = *((_OWORD *)a2 + 9);
    *(_QWORD *)(a1 + 160) = a2[20];
    *(_OWORD *)(a1 + 128) = *((_OWORD *)a2 + 8);
    *(_QWORD *)(a1 + 168) = a2[21];
    v29 = (unsigned int *)a2[29];
    if (v29)
    {
      do
        v30 = __ldaxr(v29);
      while (__stlxr(v30 + 1, v29));
    }
    v31 = *(unsigned int **)(a1 + 232);
    if (v31)
    {
      do
      {
        v32 = __ldaxr(v31);
        v33 = v32 - 1;
      }
      while (__stlxr(v33, v31));
      if (!v33)
        cv::Mat::deallocate((cv::Mat *)(a1 + 208), v22);
    }
    v34 = (const cv::Mat *)(a2 + 26);
    *(_QWORD *)(a1 + 224) = 0;
    *(_QWORD *)(a1 + 248) = 0;
    *(_QWORD *)(a1 + 256) = 0;
    *(_QWORD *)(a1 + 240) = 0;
    if (*(int *)(a1 + 212) <= 0)
    {
      *(_QWORD *)(a1 + 232) = 0;
      *(_DWORD *)(a1 + 208) = *(_DWORD *)v34;
    }
    else
    {
      v35 = 0;
      v36 = *(_QWORD *)(a1 + 272);
      do
      {
        *(_DWORD *)(v36 + 4 * v35++) = 0;
        v37 = *(int *)(a1 + 212);
      }
      while (v35 < v37);
      *(_QWORD *)(a1 + 232) = 0;
      *(_DWORD *)(a1 + 208) = *(_DWORD *)v34;
      if ((int)v37 > 2)
        goto LABEL_46;
    }
    v38 = *((_DWORD *)a2 + 53);
    if (v38 <= 2)
    {
      *(_DWORD *)(a1 + 212) = v38;
      *(_QWORD *)(a1 + 216) = a2[27];
      v39 = (_QWORD *)a2[35];
      v40 = *(_QWORD **)(a1 + 280);
      *v40 = *v39;
      v40[1] = v39[1];
LABEL_47:
      *(_OWORD *)(a1 + 240) = *((_OWORD *)a2 + 15);
      *(_QWORD *)(a1 + 256) = a2[32];
      *(_OWORD *)(a1 + 224) = *((_OWORD *)a2 + 14);
      *(_QWORD *)(a1 + 264) = a2[33];
      goto LABEL_48;
    }
LABEL_46:
    cv::Mat::copySize((cv::Mat *)(a1 + 208), v34);
    goto LABEL_47;
  }
LABEL_48:
  v41 = *((_OWORD *)a2 + 19);
  v42 = *((_OWORD *)a2 + 21);
  *(_OWORD *)(a1 + 320) = *((_OWORD *)a2 + 20);
  *(_OWORD *)(a1 + 336) = v42;
  *(_OWORD *)(a1 + 304) = v41;
  return a1;
}

void cv::MatOp::diag(cv::MatOp *this, const cv::MatExpr *a2, unsigned int a3, cv::MatExpr *a4)
{
  uint64_t v7;
  int v8;
  void *v9;
  void *v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  _DWORD *v15;
  unsigned int *v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  char *v20;
  unsigned int *v21;
  unsigned int v22;
  unsigned int v23;
  uint64_t v24;
  _DWORD *v25;
  void *v26;
  unsigned int *v27;
  unsigned int v28;
  unsigned int *v29;
  unsigned int v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  void *v36;
  unsigned int *v37;
  unsigned int v38;
  unsigned int v39;
  uint64_t v40;
  char *v41;
  unsigned int *v42;
  unsigned int v43;
  unsigned int v44;
  uint64_t v45;
  _DWORD *v46;
  unsigned int *v47;
  unsigned int v48;
  unsigned int v49;
  uint64_t v50;
  char *v51;
  unsigned int *v52;
  unsigned int v53;
  unsigned int v54;
  uint64_t v55;
  _DWORD *v56;
  cv *v57;
  _QWORD *v58;
  uint64_t v59;
  unsigned int *v60;
  unsigned int v61;
  unsigned int v62;
  uint64_t v63;
  uint64_t v64;
  void *v65;
  unsigned int *v66;
  unsigned int v67;
  unsigned int *v68;
  unsigned int v69;
  unsigned int v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  cv *v74;
  _QWORD *v75;
  uint64_t v76;
  unsigned int *v77;
  unsigned int v78;
  unsigned int v79;
  uint64_t v80;
  uint64_t v81;
  void *v82;
  unsigned int *v83;
  unsigned int v84;
  unsigned int *v85;
  unsigned int v86;
  unsigned int v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  cv *v91;
  _QWORD *v92;
  uint64_t v93;
  unsigned int *v94;
  unsigned int v95;
  unsigned int v96;
  uint64_t v97;
  uint64_t v98;
  _OWORD v99[2];
  _OWORD v100[4];
  char *v101;
  cv *v102;
  _QWORD v103[2];
  int v104;
  _DWORD v105[15];
  _DWORD *v106;
  cv *v107;
  uint64_t v108;
  uint64_t v109;
  _OWORD v110[4];
  char *v111;
  cv *v112;
  _QWORD v113[2];
  int v114;
  _DWORD v115[15];
  _DWORD *v116;
  cv *v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  __int128 v123;
  __int128 v124;
  uint64_t v125;
  uint64_t v126;
  cv *v127;
  _BYTE v128[272];

  if ((*(unsigned int (**)(cv::MatOp *))(*(_QWORD *)this + 16))(this))
  {
    v7 = *(_QWORD *)a2;
    v8 = *((_DWORD *)a2 + 2);
    v116 = &v115[1];
    v117 = (cv *)&v118;
    v118 = 0;
    v119 = 0;
    v114 = 1124007936;
    memset(v115, 0, sizeof(v115));
    v111 = (char *)v110 + 8;
    v112 = (cv *)v113;
    v113[0] = 0;
    v113[1] = 0;
    LODWORD(v110[0]) = 1124007936;
    memset((char *)v110 + 4, 0, 48);
    v110[3] = 0u;
    v106 = &v105[1];
    v107 = (cv *)&v108;
    v108 = 0;
    v109 = 0;
    v104 = 1124007936;
    memset(v105, 0, sizeof(v105));
    cv::MatExpr::MatExpr((uint64_t)&v120, v7, v8, (cv::Mat *)&v114, (cv::Mat *)v110, (cv::Mat *)&v104, (uint64_t)a2 + 320, *((double *)a2 + 38), *((double *)a2 + 39));
    cv::MatExpr::operator=((uint64_t)a4, &v120);
    cv::MatExpr::~MatExpr((cv::MatExpr *)&v120, v9);
    v11 = *(unsigned int **)&v105[5];
    if (*(_QWORD *)&v105[5])
    {
      do
      {
        v12 = __ldaxr(v11);
        v13 = v12 - 1;
      }
      while (__stlxr(v13, v11));
      if (!v13)
        cv::Mat::deallocate((cv::Mat *)&v104, v10);
    }
    *(_QWORD *)&v105[3] = 0;
    memset(&v105[7], 0, 24);
    if (v105[0] >= 1)
    {
      v14 = 0;
      v15 = v106;
      do
        v15[v14++] = 0;
      while (v14 < v105[0]);
    }
    *(_QWORD *)&v105[5] = 0;
    if (v107 != (cv *)&v108)
      cv::fastFree((void **)v107, v10);
    v16 = (unsigned int *)*((_QWORD *)&v110[1] + 1);
    if (*((_QWORD *)&v110[1] + 1))
    {
      do
      {
        v17 = __ldaxr(v16);
        v18 = v17 - 1;
      }
      while (__stlxr(v18, v16));
      if (!v18)
        cv::Mat::deallocate((cv::Mat *)v110, v10);
    }
    *(_QWORD *)&v110[1] = 0;
    memset(&v110[2], 0, 24);
    if (SDWORD1(v110[0]) >= 1)
    {
      v19 = 0;
      v20 = v111;
      do
        *(_DWORD *)&v20[4 * v19++] = 0;
      while (v19 < SDWORD1(v110[0]));
    }
    *((_QWORD *)&v110[1] + 1) = 0;
    if (v112 != (cv *)v113)
      cv::fastFree((void **)v112, v10);
    v21 = *(unsigned int **)&v115[5];
    if (*(_QWORD *)&v115[5])
    {
      do
      {
        v22 = __ldaxr(v21);
        v23 = v22 - 1;
      }
      while (__stlxr(v23, v21));
      if (!v23)
        cv::Mat::deallocate((cv::Mat *)&v114, v10);
    }
    *(_QWORD *)&v115[3] = 0;
    memset(&v115[7], 0, 24);
    if (v115[0] >= 1)
    {
      v24 = 0;
      v25 = v116;
      do
        v25[v24++] = 0;
      while (v24 < v115[0]);
    }
    *(_QWORD *)&v115[5] = 0;
    if (v117 != (cv *)&v118)
      cv::fastFree((void **)v117, v10);
    if (!*((_QWORD *)a2 + 4))
    {
LABEL_92:
      if (!*((_QWORD *)a2 + 16))
        goto LABEL_119;
      cv::Mat::diag((const cv::MatExpr *)((char *)a2 + 112), a3, (uint64_t)&v120);
      v66 = (unsigned int *)v123;
      if ((uint64_t *)((char *)a4 + 112) == &v120)
      {
LABEL_110:
        if (v66)
        {
          do
          {
            v78 = __ldaxr(v66);
            v79 = v78 - 1;
          }
          while (__stlxr(v79, v66));
          if (!v79)
            cv::Mat::deallocate((cv::Mat *)&v120, v65);
        }
        v122 = 0;
        *((_QWORD *)&v123 + 1) = 0;
        v124 = 0uLL;
        if (SHIDWORD(v120) >= 1)
        {
          v80 = 0;
          v81 = v126;
          do
            *(_DWORD *)(v81 + 4 * v80++) = 0;
          while (v80 < SHIDWORD(v120));
        }
        *(_QWORD *)&v123 = 0;
        if (v127 != (cv *)v128)
          cv::fastFree((void **)v127, v65);
LABEL_119:
        if (!*((_QWORD *)a2 + 28))
          return;
        cv::Mat::diag((const cv::MatExpr *)((char *)a2 + 208), a3, (uint64_t)&v120);
        v83 = (unsigned int *)v123;
        if ((uint64_t *)((char *)a4 + 208) == &v120)
          goto LABEL_137;
        if ((_QWORD)v123)
        {
          do
            v84 = __ldaxr(v83);
          while (__stlxr(v84 + 1, v83));
        }
        v85 = (unsigned int *)*((_QWORD *)a4 + 29);
        if (v85)
        {
          do
          {
            v86 = __ldaxr(v85);
            v87 = v86 - 1;
          }
          while (__stlxr(v87, v85));
          if (!v87)
            cv::Mat::deallocate((cv::MatExpr *)((char *)a4 + 208), v82);
        }
        *((_QWORD *)a4 + 28) = 0;
        *((_QWORD *)a4 + 31) = 0;
        *((_QWORD *)a4 + 32) = 0;
        *((_QWORD *)a4 + 30) = 0;
        if (*((int *)a4 + 53) <= 0)
        {
          *((_QWORD *)a4 + 29) = 0;
          *((_DWORD *)a4 + 52) = v120;
        }
        else
        {
          v88 = 0;
          v89 = *((_QWORD *)a4 + 34);
          do
          {
            *(_DWORD *)(v89 + 4 * v88++) = 0;
            v90 = *((int *)a4 + 53);
          }
          while (v88 < v90);
          *((_QWORD *)a4 + 29) = 0;
          *((_DWORD *)a4 + 52) = v120;
          if ((int)v90 > 2)
            goto LABEL_135;
        }
        if (SHIDWORD(v120) <= 2)
        {
          *((_DWORD *)a4 + 53) = HIDWORD(v120);
          *((_QWORD *)a4 + 27) = v121;
          v91 = v127;
          v92 = (_QWORD *)*((_QWORD *)a4 + 35);
          *v92 = *(_QWORD *)v127;
          v92[1] = *((_QWORD *)v91 + 1);
LABEL_136:
          v93 = v125;
          *((_QWORD *)a4 + 28) = v122;
          *(_OWORD *)((char *)a4 + 248) = v124;
          v94 = (unsigned int *)v123;
          *(_OWORD *)((char *)a4 + 232) = v123;
          *((_QWORD *)a4 + 33) = v93;
          v83 = v94;
LABEL_137:
          if (v83)
          {
            do
            {
              v95 = __ldaxr(v83);
              v96 = v95 - 1;
            }
            while (__stlxr(v96, v83));
            if (!v96)
              cv::Mat::deallocate((cv::Mat *)&v120, v82);
          }
          v122 = 0;
          *((_QWORD *)&v123 + 1) = 0;
          v124 = 0uLL;
          if (SHIDWORD(v120) >= 1)
          {
            v97 = 0;
            v98 = v126;
            do
              *(_DWORD *)(v98 + 4 * v97++) = 0;
            while (v97 < SHIDWORD(v120));
          }
          *(_QWORD *)&v123 = 0;
          if (v127 != (cv *)v128)
            cv::fastFree((void **)v127, v82);
          return;
        }
LABEL_135:
        cv::Mat::copySize((cv::MatExpr *)((char *)a4 + 208), (const cv::Mat *)&v120);
        goto LABEL_136;
      }
      if ((_QWORD)v123)
      {
        do
          v67 = __ldaxr(v66);
        while (__stlxr(v67 + 1, v66));
      }
      v68 = (unsigned int *)*((_QWORD *)a4 + 17);
      if (v68)
      {
        do
        {
          v69 = __ldaxr(v68);
          v70 = v69 - 1;
        }
        while (__stlxr(v70, v68));
        if (!v70)
          cv::Mat::deallocate((cv::MatExpr *)((char *)a4 + 112), v65);
      }
      *((_QWORD *)a4 + 16) = 0;
      *((_QWORD *)a4 + 19) = 0;
      *((_QWORD *)a4 + 20) = 0;
      *((_QWORD *)a4 + 18) = 0;
      if (*((int *)a4 + 29) <= 0)
      {
        *((_QWORD *)a4 + 17) = 0;
        *((_DWORD *)a4 + 28) = v120;
      }
      else
      {
        v71 = 0;
        v72 = *((_QWORD *)a4 + 22);
        do
        {
          *(_DWORD *)(v72 + 4 * v71++) = 0;
          v73 = *((int *)a4 + 29);
        }
        while (v71 < v73);
        *((_QWORD *)a4 + 17) = 0;
        *((_DWORD *)a4 + 28) = v120;
        if ((int)v73 > 2)
          goto LABEL_108;
      }
      if (SHIDWORD(v120) <= 2)
      {
        *((_DWORD *)a4 + 29) = HIDWORD(v120);
        *((_QWORD *)a4 + 15) = v121;
        v74 = v127;
        v75 = (_QWORD *)*((_QWORD *)a4 + 23);
        *v75 = *(_QWORD *)v127;
        v75[1] = *((_QWORD *)v74 + 1);
LABEL_109:
        v76 = v125;
        *((_QWORD *)a4 + 16) = v122;
        *(_OWORD *)((char *)a4 + 152) = v124;
        v77 = (unsigned int *)v123;
        *(_OWORD *)((char *)a4 + 136) = v123;
        *((_QWORD *)a4 + 21) = v76;
        v66 = v77;
        goto LABEL_110;
      }
LABEL_108:
      cv::Mat::copySize((cv::MatExpr *)((char *)a4 + 112), (const cv::Mat *)&v120);
      goto LABEL_109;
    }
    cv::Mat::diag((const cv::MatExpr *)((char *)a2 + 16), a3, (uint64_t)&v120);
    v27 = (unsigned int *)v123;
    if ((uint64_t *)((char *)a4 + 16) == &v120)
    {
LABEL_83:
      if (v27)
      {
        do
        {
          v61 = __ldaxr(v27);
          v62 = v61 - 1;
        }
        while (__stlxr(v62, v27));
        if (!v62)
          cv::Mat::deallocate((cv::Mat *)&v120, v26);
      }
      v122 = 0;
      *((_QWORD *)&v123 + 1) = 0;
      v124 = 0uLL;
      if (SHIDWORD(v120) >= 1)
      {
        v63 = 0;
        v64 = v126;
        do
          *(_DWORD *)(v64 + 4 * v63++) = 0;
        while (v63 < SHIDWORD(v120));
      }
      *(_QWORD *)&v123 = 0;
      if (v127 != (cv *)v128)
        cv::fastFree((void **)v127, v26);
      goto LABEL_92;
    }
    if ((_QWORD)v123)
    {
      do
        v28 = __ldaxr(v27);
      while (__stlxr(v28 + 1, v27));
    }
    v29 = (unsigned int *)*((_QWORD *)a4 + 5);
    if (v29)
    {
      do
      {
        v30 = __ldaxr(v29);
        v31 = v30 - 1;
      }
      while (__stlxr(v31, v29));
      if (!v31)
        cv::Mat::deallocate((cv::MatExpr *)((char *)a4 + 16), v26);
    }
    *((_QWORD *)a4 + 4) = 0;
    *((_QWORD *)a4 + 7) = 0;
    *((_QWORD *)a4 + 8) = 0;
    *((_QWORD *)a4 + 6) = 0;
    if (*((int *)a4 + 5) <= 0)
    {
      *((_QWORD *)a4 + 5) = 0;
      *((_DWORD *)a4 + 4) = v120;
    }
    else
    {
      v32 = 0;
      v33 = *((_QWORD *)a4 + 10);
      do
      {
        *(_DWORD *)(v33 + 4 * v32++) = 0;
        v34 = *((int *)a4 + 5);
      }
      while (v32 < v34);
      *((_QWORD *)a4 + 5) = 0;
      *((_DWORD *)a4 + 4) = v120;
      if ((int)v34 > 2)
        goto LABEL_81;
    }
    if (SHIDWORD(v120) <= 2)
    {
      *((_DWORD *)a4 + 5) = HIDWORD(v120);
      *((_QWORD *)a4 + 3) = v121;
      v57 = v127;
      v58 = (_QWORD *)*((_QWORD *)a4 + 11);
      *v58 = *(_QWORD *)v127;
      v58[1] = *((_QWORD *)v57 + 1);
LABEL_82:
      v59 = v125;
      *((_QWORD *)a4 + 4) = v122;
      *(_OWORD *)((char *)a4 + 56) = v124;
      v60 = (unsigned int *)v123;
      *(_OWORD *)((char *)a4 + 40) = v123;
      *((_QWORD *)a4 + 9) = v59;
      v27 = v60;
      goto LABEL_83;
    }
LABEL_81:
    cv::Mat::copySize((cv::MatExpr *)((char *)a4 + 16), (const cv::Mat *)&v120);
    goto LABEL_82;
  }
  v116 = &v115[1];
  v117 = (cv *)&v118;
  v118 = 0;
  v119 = 0;
  v114 = 1124007936;
  memset(v115, 0, sizeof(v115));
  (*(void (**)(_QWORD, const cv::MatExpr *, int *, uint64_t))(**(_QWORD **)a2 + 24))(*(_QWORD *)a2, a2, &v114, 0xFFFFFFFFLL);
  cv::Mat::diag((cv::Mat *)&v114, a3, (uint64_t)v110);
  v106 = &v105[1];
  v107 = (cv *)&v108;
  v108 = 0;
  v109 = 0;
  v104 = 1124007936;
  memset(v105, 0, sizeof(v105));
  v101 = (char *)v100 + 8;
  v102 = (cv *)v103;
  v103[0] = 0;
  v103[1] = 0;
  LODWORD(v100[0]) = 1124007936;
  memset((char *)v100 + 4, 0, 48);
  v100[3] = 0u;
  memset(v99, 0, sizeof(v99));
  cv::MatExpr::MatExpr((uint64_t)&v120, (uint64_t)&cv::g_MatOp_Identity, 0, (cv::Mat *)v110, (cv::Mat *)&v104, (cv::Mat *)v100, (uint64_t)v99, 1.0, 1.0);
  cv::MatExpr::operator=((uint64_t)a4, &v120);
  cv::MatExpr::~MatExpr((cv::MatExpr *)&v120, v35);
  v37 = (unsigned int *)*((_QWORD *)&v100[1] + 1);
  if (*((_QWORD *)&v100[1] + 1))
  {
    do
    {
      v38 = __ldaxr(v37);
      v39 = v38 - 1;
    }
    while (__stlxr(v39, v37));
    if (!v39)
      cv::Mat::deallocate((cv::Mat *)v100, v36);
  }
  *(_QWORD *)&v100[1] = 0;
  memset(&v100[2], 0, 24);
  if (SDWORD1(v100[0]) >= 1)
  {
    v40 = 0;
    v41 = v101;
    do
      *(_DWORD *)&v41[4 * v40++] = 0;
    while (v40 < SDWORD1(v100[0]));
  }
  *((_QWORD *)&v100[1] + 1) = 0;
  if (v102 != (cv *)v103)
    cv::fastFree((void **)v102, v36);
  v42 = *(unsigned int **)&v105[5];
  if (*(_QWORD *)&v105[5])
  {
    do
    {
      v43 = __ldaxr(v42);
      v44 = v43 - 1;
    }
    while (__stlxr(v44, v42));
    if (!v44)
      cv::Mat::deallocate((cv::Mat *)&v104, v36);
  }
  *(_QWORD *)&v105[3] = 0;
  memset(&v105[7], 0, 24);
  if (v105[0] >= 1)
  {
    v45 = 0;
    v46 = v106;
    do
      v46[v45++] = 0;
    while (v45 < v105[0]);
  }
  *(_QWORD *)&v105[5] = 0;
  if (v107 != (cv *)&v108)
    cv::fastFree((void **)v107, v36);
  v47 = (unsigned int *)*((_QWORD *)&v110[1] + 1);
  if (*((_QWORD *)&v110[1] + 1))
  {
    do
    {
      v48 = __ldaxr(v47);
      v49 = v48 - 1;
    }
    while (__stlxr(v49, v47));
    if (!v49)
      cv::Mat::deallocate((cv::Mat *)v110, v36);
  }
  *(_QWORD *)&v110[1] = 0;
  memset(&v110[2], 0, 24);
  if (SDWORD1(v110[0]) >= 1)
  {
    v50 = 0;
    v51 = v111;
    do
      *(_DWORD *)&v51[4 * v50++] = 0;
    while (v50 < SDWORD1(v110[0]));
  }
  *((_QWORD *)&v110[1] + 1) = 0;
  if (v112 != (cv *)v113)
    cv::fastFree((void **)v112, v36);
  v52 = *(unsigned int **)&v115[5];
  if (*(_QWORD *)&v115[5])
  {
    do
    {
      v53 = __ldaxr(v52);
      v54 = v53 - 1;
    }
    while (__stlxr(v54, v52));
    if (!v54)
      cv::Mat::deallocate((cv::Mat *)&v114, v36);
  }
  *(_QWORD *)&v115[3] = 0;
  memset(&v115[7], 0, 24);
  if (v115[0] >= 1)
  {
    v55 = 0;
    v56 = v116;
    do
      v56[v55++] = 0;
    while (v55 < v115[0]);
  }
  *(_QWORD *)&v115[5] = 0;
  if (v117 != (cv *)&v118)
    cv::fastFree((void **)v117, v36);
}

void sub_219E8B3E8(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61)
{
  cv::Mat::~Mat((cv::Mat *)&a61, a2);
  _Unwind_Resume(a1);
}

void cv::MatOp::augAssignAdd(cv::MatOp *this, const cv::MatExpr *a2, cv::Mat *a3)
{
  cv *v4;
  uint64_t (***v5)(cv::_InputArray *__hidden, int);
  void *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD v12[8];
  _QWORD *v13;
  cv *v14;
  _QWORD v15[2];
  _BYTE v16[32];
  _BYTE v17[32];
  _BYTE v18[32];

  v13 = &v12[1];
  v14 = (cv *)v15;
  v15[0] = 0;
  v15[1] = 0;
  LODWORD(v12[0]) = 1124007936;
  memset((char *)v12 + 4, 0, 32);
  memset((char *)&v12[4] + 4, 0, 28);
  (*(void (**)(_QWORD, const cv::MatExpr *, _QWORD *, uint64_t))(**(_QWORD **)a2 + 24))(*(_QWORD *)a2, a2, v12, 0xFFFFFFFFLL);
  cv::_InputArray::_InputArray((uint64_t)v18, a3);
  cv::_InputArray::_InputArray((uint64_t)v17, (const cv::Mat *)v12);
  v4 = (cv *)cv::_OutputArray::_OutputArray((uint64_t)v16, a3);
  v5 = cv::noArray(v4);
  cv::add((uint64_t)v18, (uint64_t)v17, (const cv::_InputArray *)v16, (const cv::_OutputArray *)v5, (const cv::_InputArray *)0xFFFFFFFFLL);
  v7 = (unsigned int *)v12[3];
  if (v12[3])
  {
    do
    {
      v8 = __ldaxr(v7);
      v9 = v8 - 1;
    }
    while (__stlxr(v9, v7));
    if (!v9)
      cv::Mat::deallocate((cv::Mat *)v12, v6);
  }
  v12[2] = 0;
  memset(&v12[4], 0, 24);
  if (SHIDWORD(v12[0]) >= 1)
  {
    v10 = 0;
    v11 = v13;
    do
      *((_DWORD *)v11 + v10++) = 0;
    while (v10 < SHIDWORD(v12[0]));
  }
  v12[3] = 0;
  if (v14 != (cv *)v15)
    cv::fastFree((void **)v14, v6);
}

void sub_219E8B5A0(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  cv::Mat::~Mat((cv::Mat *)&a9, a2);
  _Unwind_Resume(a1);
}

void cv::MatOp::augAssignSubtract(cv::MatOp *this, const cv::MatExpr *a2, cv::Mat *a3)
{
  cv *v4;
  uint64_t (***v5)(cv::_InputArray *__hidden, int);
  void *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD v12[8];
  _QWORD *v13;
  cv *v14;
  _QWORD v15[2];
  _BYTE v16[32];
  _BYTE v17[32];
  _BYTE v18[32];

  v13 = &v12[1];
  v14 = (cv *)v15;
  v15[0] = 0;
  v15[1] = 0;
  LODWORD(v12[0]) = 1124007936;
  memset((char *)v12 + 4, 0, 32);
  memset((char *)&v12[4] + 4, 0, 28);
  (*(void (**)(_QWORD, const cv::MatExpr *, _QWORD *, uint64_t))(**(_QWORD **)a2 + 24))(*(_QWORD *)a2, a2, v12, 0xFFFFFFFFLL);
  cv::_InputArray::_InputArray((uint64_t)v18, a3);
  cv::_InputArray::_InputArray((uint64_t)v17, (const cv::Mat *)v12);
  v4 = (cv *)cv::_OutputArray::_OutputArray((uint64_t)v16, a3);
  v5 = cv::noArray(v4);
  cv::subtract((uint64_t)v18, (uint64_t)v17, (const cv::_InputArray *)v16, (const cv::_OutputArray *)v5, (const cv::_InputArray *)0xFFFFFFFFLL);
  v7 = (unsigned int *)v12[3];
  if (v12[3])
  {
    do
    {
      v8 = __ldaxr(v7);
      v9 = v8 - 1;
    }
    while (__stlxr(v9, v7));
    if (!v9)
      cv::Mat::deallocate((cv::Mat *)v12, v6);
  }
  v12[2] = 0;
  memset(&v12[4], 0, 24);
  if (SHIDWORD(v12[0]) >= 1)
  {
    v10 = 0;
    v11 = v13;
    do
      *((_DWORD *)v11 + v10++) = 0;
    while (v10 < SHIDWORD(v12[0]));
  }
  v12[3] = 0;
  if (v14 != (cv *)v15)
    cv::fastFree((void **)v14, v6);
}

void sub_219E8B6D0(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  cv::Mat::~Mat((cv::Mat *)&a9, a2);
  _Unwind_Resume(a1);
}

void cv::MatOp::augAssignMultiply(cv::MatOp *this, const cv::MatExpr *a2, cv::Mat *a3)
{
  void *v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  char *v9;
  unsigned int *v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD v15[8];
  _QWORD *v16;
  cv *v17;
  _QWORD v18[2];
  _BYTE v19[32];
  _OWORD v20[4];
  char *v21;
  cv *v22;
  _QWORD v23[2];
  _BYTE v24[32];
  _BYTE v25[32];
  _BYTE v26[32];

  v16 = &v15[1];
  v17 = (cv *)v18;
  v18[0] = 0;
  v18[1] = 0;
  LODWORD(v15[0]) = 1124007936;
  memset((char *)v15 + 4, 0, 32);
  memset((char *)&v15[4] + 4, 0, 28);
  (*(void (**)(_QWORD, const cv::MatExpr *, _QWORD *, uint64_t))(**(_QWORD **)a2 + 24))(*(_QWORD *)a2, a2, v15, 0xFFFFFFFFLL);
  cv::_InputArray::_InputArray((uint64_t)v26, a3);
  cv::_InputArray::_InputArray((uint64_t)v25, (const cv::Mat *)v15);
  v21 = (char *)v20 + 8;
  v22 = (cv *)v23;
  v23[0] = 0;
  v23[1] = 0;
  LODWORD(v20[0]) = 1124007936;
  memset((char *)v20 + 4, 0, 48);
  v20[3] = 0u;
  cv::_InputArray::_InputArray((uint64_t)v24, (const cv::Mat *)v20);
  cv::_OutputArray::_OutputArray((uint64_t)v19, a3);
  cv::gemm((cv *)v26, (const cv::_InputArray *)v25, (const cv::_InputArray *)v24, 1.0, (const cv::_InputArray *)v19, 0.0, 0);
  v5 = (unsigned int *)*((_QWORD *)&v20[1] + 1);
  if (*((_QWORD *)&v20[1] + 1))
  {
    do
    {
      v6 = __ldaxr(v5);
      v7 = v6 - 1;
    }
    while (__stlxr(v7, v5));
    if (!v7)
      cv::Mat::deallocate((cv::Mat *)v20, v4);
  }
  *(_QWORD *)&v20[1] = 0;
  memset(&v20[2], 0, 24);
  if (SDWORD1(v20[0]) >= 1)
  {
    v8 = 0;
    v9 = v21;
    do
      *(_DWORD *)&v9[4 * v8++] = 0;
    while (v8 < SDWORD1(v20[0]));
  }
  *((_QWORD *)&v20[1] + 1) = 0;
  if (v22 != (cv *)v23)
    cv::fastFree((void **)v22, v4);
  v10 = (unsigned int *)v15[3];
  if (v15[3])
  {
    do
    {
      v11 = __ldaxr(v10);
      v12 = v11 - 1;
    }
    while (__stlxr(v12, v10));
    if (!v12)
      cv::Mat::deallocate((cv::Mat *)v15, v4);
  }
  v15[2] = 0;
  memset(&v15[4], 0, 24);
  if (SHIDWORD(v15[0]) >= 1)
  {
    v13 = 0;
    v14 = v16;
    do
      *((_DWORD *)v14 + v13++) = 0;
    while (v13 < SHIDWORD(v15[0]));
  }
  v15[3] = 0;
  if (v17 != (cv *)v18)
    cv::fastFree((void **)v17, v4);
}

void sub_219E8B8BC(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25)
{
  void *v26;

  cv::Mat::~Mat((cv::Mat *)&a25, a2);
  cv::Mat::~Mat((cv::Mat *)&a9, v26);
  _Unwind_Resume(a1);
}

void cv::MatOp::augAssignDivide(cv::MatOp *this, const cv::MatExpr *a2, cv::Mat *a3)
{
  void *v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD v10[8];
  _QWORD *v11;
  cv *v12;
  _QWORD v13[2];
  _BYTE v14[32];
  _BYTE v15[32];
  _BYTE v16[32];

  v11 = &v10[1];
  v12 = (cv *)v13;
  v13[0] = 0;
  v13[1] = 0;
  LODWORD(v10[0]) = 1124007936;
  memset((char *)v10 + 4, 0, 32);
  memset((char *)&v10[4] + 4, 0, 28);
  (*(void (**)(_QWORD, const cv::MatExpr *, _QWORD *, uint64_t))(**(_QWORD **)a2 + 24))(*(_QWORD *)a2, a2, v10, 0xFFFFFFFFLL);
  cv::_InputArray::_InputArray((uint64_t)v16, a3);
  cv::_InputArray::_InputArray((uint64_t)v15, (const cv::Mat *)v10);
  cv::_OutputArray::_OutputArray((uint64_t)v14, a3);
  cv::divide((cv *)v16, (const cv::_InputArray *)v15, (const cv::_InputArray *)v14, (const cv::_OutputArray *)0xFFFFFFFFLL, 1.0);
  v5 = (unsigned int *)v10[3];
  if (v10[3])
  {
    do
    {
      v6 = __ldaxr(v5);
      v7 = v6 - 1;
    }
    while (__stlxr(v7, v5));
    if (!v7)
      cv::Mat::deallocate((cv::Mat *)v10, v4);
  }
  v10[2] = 0;
  memset(&v10[4], 0, 24);
  if (SHIDWORD(v10[0]) >= 1)
  {
    v8 = 0;
    v9 = v11;
    do
      *((_DWORD *)v9 + v8++) = 0;
    while (v8 < SHIDWORD(v10[0]));
  }
  v10[3] = 0;
  if (v12 != (cv *)v13)
    cv::fastFree((void **)v12, v4);
}

void sub_219E8B9FC(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  cv::Mat::~Mat((cv::Mat *)&a9, a2);
  _Unwind_Resume(a1);
}

void cv::MatOp::augAssignAnd(cv::MatOp *this, const cv::MatExpr *a2, cv::Mat *a3)
{
  cv *v4;
  uint64_t (***v5)(cv::_InputArray *__hidden, int);
  const cv::_InputArray *v6;
  void *v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD v13[8];
  _QWORD *v14;
  cv *v15;
  _QWORD v16[2];
  _BYTE v17[32];
  _BYTE v18[32];
  _BYTE v19[32];

  v14 = &v13[1];
  v15 = (cv *)v16;
  v16[0] = 0;
  v16[1] = 0;
  LODWORD(v13[0]) = 1124007936;
  memset((char *)v13 + 4, 0, 32);
  memset((char *)&v13[4] + 4, 0, 28);
  (*(void (**)(_QWORD, const cv::MatExpr *, _QWORD *, uint64_t))(**(_QWORD **)a2 + 24))(*(_QWORD *)a2, a2, v13, 0xFFFFFFFFLL);
  cv::_InputArray::_InputArray((uint64_t)v19, a3);
  cv::_InputArray::_InputArray((uint64_t)v18, (const cv::Mat *)v13);
  v4 = (cv *)cv::_OutputArray::_OutputArray((uint64_t)v17, a3);
  v5 = cv::noArray(v4);
  cv::bitwise_and((cv *)v19, (const cv::_InputArray *)v18, (const cv::_InputArray *)v17, (const cv::_OutputArray *)v5, v6);
  v8 = (unsigned int *)v13[3];
  if (v13[3])
  {
    do
    {
      v9 = __ldaxr(v8);
      v10 = v9 - 1;
    }
    while (__stlxr(v10, v8));
    if (!v10)
      cv::Mat::deallocate((cv::Mat *)v13, v7);
  }
  v13[2] = 0;
  memset(&v13[4], 0, 24);
  if (SHIDWORD(v13[0]) >= 1)
  {
    v11 = 0;
    v12 = v14;
    do
      *((_DWORD *)v12 + v11++) = 0;
    while (v11 < SHIDWORD(v13[0]));
  }
  v13[3] = 0;
  if (v15 != (cv *)v16)
    cv::fastFree((void **)v15, v7);
}

void sub_219E8BB28(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  cv::Mat::~Mat((cv::Mat *)&a9, a2);
  _Unwind_Resume(a1);
}

void cv::MatOp::augAssignOr(cv::MatOp *this, const cv::MatExpr *a2, cv::Mat *a3)
{
  cv *v4;
  uint64_t (***v5)(cv::_InputArray *__hidden, int);
  const cv::_InputArray *v6;
  void *v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD v13[8];
  _QWORD *v14;
  cv *v15;
  _QWORD v16[2];
  _BYTE v17[32];
  _BYTE v18[32];
  _BYTE v19[32];

  v14 = &v13[1];
  v15 = (cv *)v16;
  v16[0] = 0;
  v16[1] = 0;
  LODWORD(v13[0]) = 1124007936;
  memset((char *)v13 + 4, 0, 32);
  memset((char *)&v13[4] + 4, 0, 28);
  (*(void (**)(_QWORD, const cv::MatExpr *, _QWORD *, uint64_t))(**(_QWORD **)a2 + 24))(*(_QWORD *)a2, a2, v13, 0xFFFFFFFFLL);
  cv::_InputArray::_InputArray((uint64_t)v19, a3);
  cv::_InputArray::_InputArray((uint64_t)v18, (const cv::Mat *)v13);
  v4 = (cv *)cv::_OutputArray::_OutputArray((uint64_t)v17, a3);
  v5 = cv::noArray(v4);
  cv::bitwise_or((cv *)v19, (const cv::_InputArray *)v18, (const cv::_InputArray *)v17, (const cv::_OutputArray *)v5, v6);
  v8 = (unsigned int *)v13[3];
  if (v13[3])
  {
    do
    {
      v9 = __ldaxr(v8);
      v10 = v9 - 1;
    }
    while (__stlxr(v10, v8));
    if (!v10)
      cv::Mat::deallocate((cv::Mat *)v13, v7);
  }
  v13[2] = 0;
  memset(&v13[4], 0, 24);
  if (SHIDWORD(v13[0]) >= 1)
  {
    v11 = 0;
    v12 = v14;
    do
      *((_DWORD *)v12 + v11++) = 0;
    while (v11 < SHIDWORD(v13[0]));
  }
  v13[3] = 0;
  if (v15 != (cv *)v16)
    cv::fastFree((void **)v15, v7);
}

void sub_219E8BC54(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  cv::Mat::~Mat((cv::Mat *)&a9, a2);
  _Unwind_Resume(a1);
}

void cv::MatOp::augAssignXor(cv::MatOp *this, const cv::MatExpr *a2, cv::Mat *a3)
{
  cv *v4;
  uint64_t (***v5)(cv::_InputArray *__hidden, int);
  const cv::_InputArray *v6;
  void *v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD v13[8];
  _QWORD *v14;
  cv *v15;
  _QWORD v16[2];
  _BYTE v17[32];
  _BYTE v18[32];
  _BYTE v19[32];

  v14 = &v13[1];
  v15 = (cv *)v16;
  v16[0] = 0;
  v16[1] = 0;
  LODWORD(v13[0]) = 1124007936;
  memset((char *)v13 + 4, 0, 32);
  memset((char *)&v13[4] + 4, 0, 28);
  (*(void (**)(_QWORD, const cv::MatExpr *, _QWORD *, uint64_t))(**(_QWORD **)a2 + 24))(*(_QWORD *)a2, a2, v13, 0xFFFFFFFFLL);
  cv::_InputArray::_InputArray((uint64_t)v19, a3);
  cv::_InputArray::_InputArray((uint64_t)v18, (const cv::Mat *)v13);
  v4 = (cv *)cv::_OutputArray::_OutputArray((uint64_t)v17, a3);
  v5 = cv::noArray(v4);
  cv::bitwise_xor((cv *)v19, (const cv::_InputArray *)v18, (const cv::_InputArray *)v17, (const cv::_OutputArray *)v5, v6);
  v8 = (unsigned int *)v13[3];
  if (v13[3])
  {
    do
    {
      v9 = __ldaxr(v8);
      v10 = v9 - 1;
    }
    while (__stlxr(v10, v8));
    if (!v10)
      cv::Mat::deallocate((cv::Mat *)v13, v7);
  }
  v13[2] = 0;
  memset(&v13[4], 0, 24);
  if (SHIDWORD(v13[0]) >= 1)
  {
    v11 = 0;
    v12 = v14;
    do
      *((_DWORD *)v12 + v11++) = 0;
    while (v11 < SHIDWORD(v13[0]));
  }
  v13[3] = 0;
  if (v15 != (cv *)v16)
    cv::fastFree((void **)v15, v7);
}

void sub_219E8BD80(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  cv::Mat::~Mat((cv::Mat *)&a9, a2);
  _Unwind_Resume(a1);
}

void cv::MatOp::add(cv::MatOp *this, const cv::MatExpr *a2, const cv::MatExpr *a3, cv::MatExpr *a4)
{
  double v7;
  double v8;
  void *v9;
  unsigned int *v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  _BYTE *v14;
  unsigned int *v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  _BYTE *v19;
  _DWORD *v20;
  unsigned int *v21;
  unsigned int v22;
  unsigned int *v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t v26;
  _BYTE *v27;
  _DWORD *v28;
  unsigned int *v29;
  unsigned int v30;
  unsigned int *v31;
  unsigned int v32;
  unsigned int v33;
  uint64_t v34;
  _BYTE *v35;
  _QWORD *v36;
  cv *v37;
  uint64_t v38;
  __int128 v39;
  float64x2_t v40;
  _QWORD *v41;
  cv *v42;
  __int128 v43;
  float64x2_t v44;
  _BYTE v45[64];
  _BYTE *v46;
  cv *v47;
  _QWORD v48[2];
  _BYTE v49[64];
  _BYTE *v50;
  cv *v51;
  _QWORD v52[2];
  float64x2_t v53;
  float64x2_t v54;

  if (*(cv::MatOp **)a3 != this)
  {
    (*(void (**)(_QWORD, const cv::MatExpr *, const cv::MatExpr *, cv::MatExpr *))(**(_QWORD **)a3 + 104))(*(_QWORD *)a3, a2, a3, a4);
    return;
  }
  v53 = 0u;
  v54 = 0u;
  v50 = &v49[8];
  v51 = (cv *)v52;
  v52[0] = 0;
  v52[1] = 0;
  *(_DWORD *)v49 = 1124007936;
  memset(&v49[4], 0, 60);
  v46 = &v45[8];
  v47 = (cv *)v48;
  v48[0] = 0;
  v48[1] = 0;
  *(_DWORD *)v45 = 1124007936;
  memset(&v45[4], 0, 60);
  if (*(_UNKNOWN ***)a2 == &cv::g_MatOp_AddEx && (!*((_QWORD *)a2 + 16) || *((double *)a2 + 39) == 0.0))
  {
    v20 = (_DWORD *)((char *)a2 + 16);
    if (v49 == (char *)a2 + 16)
    {
LABEL_59:
      v7 = *((double *)a2 + 38);
      v40 = *((float64x2_t *)a2 + 21);
      v53 = *((float64x2_t *)a2 + 20);
      v54 = v40;
      goto LABEL_7;
    }
    v21 = (unsigned int *)*((_QWORD *)a2 + 5);
    if (v21)
    {
      do
        v22 = __ldaxr(v21);
      while (__stlxr(v22 + 1, v21));
      v23 = *(unsigned int **)&v49[24];
      if (*(_QWORD *)&v49[24])
      {
        do
        {
          v24 = __ldaxr(v23);
          v25 = v24 - 1;
        }
        while (__stlxr(v25, v23));
        if (!v25)
          cv::Mat::deallocate((cv::Mat *)v49, a2);
      }
    }
    *(_QWORD *)&v49[16] = 0;
    memset(&v49[32], 0, 24);
    if (*(uint64_t *)v49 <= 0)
    {
      *(_QWORD *)&v49[24] = 0;
      *(_DWORD *)v49 = *v20;
    }
    else
    {
      v26 = 0;
      v27 = v50;
      do
        *(_DWORD *)&v27[4 * v26++] = 0;
      while (v26 < *(int *)&v49[4]);
      *(_QWORD *)&v49[24] = 0;
      *(_DWORD *)v49 = *v20;
      if (*(int *)&v49[4] > 2)
        goto LABEL_57;
    }
    if (*((int *)a2 + 5) <= 2)
    {
      *(_DWORD *)&v49[4] = *((_DWORD *)a2 + 5);
      *(_QWORD *)&v49[8] = *((_QWORD *)a2 + 3);
      v36 = (_QWORD *)*((_QWORD *)a2 + 11);
      v37 = v51;
      *(_QWORD *)v51 = *v36;
      *((_QWORD *)v37 + 1) = v36[1];
LABEL_58:
      v38 = *((_QWORD *)a2 + 5);
      *(_QWORD *)&v49[16] = *((_QWORD *)a2 + 4);
      *(_QWORD *)&v49[24] = v38;
      v39 = *((_OWORD *)a2 + 4);
      *(_OWORD *)&v49[32] = *((_OWORD *)a2 + 3);
      *(_OWORD *)&v49[48] = v39;
      goto LABEL_59;
    }
LABEL_57:
    cv::Mat::copySize((cv::Mat *)v49, (const cv::MatExpr *)((char *)a2 + 16));
    goto LABEL_58;
  }
  v7 = 1.0;
  (*(void (**)(_QWORD, const cv::MatExpr *, _BYTE *, uint64_t))(**(_QWORD **)a2 + 24))(*(_QWORD *)a2, a2, v49, 0xFFFFFFFFLL);
LABEL_7:
  if (*(_UNKNOWN ***)a3 != &cv::g_MatOp_AddEx || *((_QWORD *)a3 + 16) && *((double *)a3 + 39) != 0.0)
  {
    v8 = 1.0;
    (*(void (**)(_QWORD, const cv::MatExpr *, _BYTE *, uint64_t))(**(_QWORD **)a3 + 24))(*(_QWORD *)a3, a3, v45, 0xFFFFFFFFLL);
    goto LABEL_11;
  }
  v28 = (_DWORD *)((char *)a3 + 16);
  if (v45 != (char *)a3 + 16)
  {
    v29 = (unsigned int *)*((_QWORD *)a3 + 5);
    if (v29)
    {
      do
        v30 = __ldaxr(v29);
      while (__stlxr(v30 + 1, v29));
    }
    v31 = *(unsigned int **)&v45[24];
    if (*(_QWORD *)&v45[24])
    {
      do
      {
        v32 = __ldaxr(v31);
        v33 = v32 - 1;
      }
      while (__stlxr(v33, v31));
      if (!v33)
        cv::Mat::deallocate((cv::Mat *)v45, a2);
    }
    *(_QWORD *)&v45[16] = 0;
    memset(&v45[32], 0, 24);
    if (*(uint64_t *)v45 <= 0)
    {
      *(_QWORD *)&v45[24] = 0;
      *(_DWORD *)v45 = *v28;
    }
    else
    {
      v34 = 0;
      v35 = v46;
      do
        *(_DWORD *)&v35[4 * v34++] = 0;
      while (v34 < *(int *)&v45[4]);
      *(_QWORD *)&v45[24] = 0;
      *(_DWORD *)v45 = *v28;
      if (*(int *)&v45[4] > 2)
        goto LABEL_63;
    }
    if (*((int *)a3 + 5) <= 2)
    {
      *(_DWORD *)&v45[4] = *((_DWORD *)a3 + 5);
      *(_QWORD *)&v45[8] = *((_QWORD *)a3 + 3);
      v41 = (_QWORD *)*((_QWORD *)a3 + 11);
      v42 = v47;
      *(_QWORD *)v47 = *v41;
      *((_QWORD *)v42 + 1) = v41[1];
LABEL_64:
      v43 = *((_OWORD *)a3 + 3);
      *(_OWORD *)&v45[16] = *((_OWORD *)a3 + 2);
      *(_OWORD *)&v45[32] = v43;
      *(_OWORD *)&v45[48] = *((_OWORD *)a3 + 4);
      goto LABEL_65;
    }
LABEL_63:
    cv::Mat::copySize((cv::Mat *)v45, (const cv::MatExpr *)((char *)a3 + 16));
    goto LABEL_64;
  }
LABEL_65:
  v8 = *((double *)a3 + 38);
  v44 = vaddq_f64(v54, *((float64x2_t *)a3 + 21));
  v53 = vaddq_f64(v53, *((float64x2_t *)a3 + 20));
  v54 = v44;
LABEL_11:
  cv::MatOp_AddEx::makeExpr((uint64_t)a4, (cv::Mat *)v49, (cv::Mat *)v45, (uint64_t)&v53, v7, v8);
  v10 = *(unsigned int **)&v45[24];
  if (*(_QWORD *)&v45[24])
  {
    do
    {
      v11 = __ldaxr(v10);
      v12 = v11 - 1;
    }
    while (__stlxr(v12, v10));
    if (!v12)
      cv::Mat::deallocate((cv::Mat *)v45, v9);
  }
  *(_QWORD *)&v45[16] = 0;
  memset(&v45[32], 0, 24);
  if (*(int *)&v45[4] >= 1)
  {
    v13 = 0;
    v14 = v46;
    do
      *(_DWORD *)&v14[4 * v13++] = 0;
    while (v13 < *(int *)&v45[4]);
  }
  *(_QWORD *)&v45[24] = 0;
  if (v47 != (cv *)v48)
    cv::fastFree((void **)v47, v9);
  v15 = *(unsigned int **)&v49[24];
  if (*(_QWORD *)&v49[24])
  {
    do
    {
      v16 = __ldaxr(v15);
      v17 = v16 - 1;
    }
    while (__stlxr(v17, v15));
    if (!v17)
      cv::Mat::deallocate((cv::Mat *)v49, v9);
  }
  *(_QWORD *)&v49[16] = 0;
  memset(&v49[32], 0, 24);
  if (*(int *)&v49[4] >= 1)
  {
    v18 = 0;
    v19 = v50;
    do
      *(_DWORD *)&v19[4 * v18++] = 0;
    while (v18 < *(int *)&v49[4]);
  }
  *(_QWORD *)&v49[24] = 0;
  if (v51 != (cv *)v52)
    cv::fastFree((void **)v51, v9);
}

void sub_219E8C210(_Unwind_Exception *a1, void *a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  void *v22;

  cv::Mat::~Mat((cv::Mat *)&a9, a2);
  cv::Mat::~Mat((cv::Mat *)&a21, v22);
  _Unwind_Resume(a1);
}

void cv::MatOp_AddEx::makeExpr(uint64_t a1, cv::Mat *a2, cv::Mat *a3, uint64_t a4, double a5, double a6)
{
  void *v7;
  void *v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  char *v13;
  _OWORD v14[4];
  char *v15;
  cv *v16;
  _QWORD v17[2];
  uint64_t v18[44];

  v15 = (char *)v14 + 8;
  v16 = (cv *)v17;
  v17[0] = 0;
  v17[1] = 0;
  LODWORD(v14[0]) = 1124007936;
  memset((char *)v14 + 4, 0, 48);
  v14[3] = 0u;
  cv::MatExpr::MatExpr((uint64_t)v18, (uint64_t)&cv::g_MatOp_AddEx, 0, a2, a3, (cv::Mat *)v14, a4, a5, a6);
  cv::MatExpr::operator=(a1, v18);
  cv::MatExpr::~MatExpr((cv::MatExpr *)v18, v7);
  v9 = (unsigned int *)*((_QWORD *)&v14[1] + 1);
  if (*((_QWORD *)&v14[1] + 1))
  {
    do
    {
      v10 = __ldaxr(v9);
      v11 = v10 - 1;
    }
    while (__stlxr(v11, v9));
    if (!v11)
      cv::Mat::deallocate((cv::Mat *)v14, v8);
  }
  *(_QWORD *)&v14[1] = 0;
  memset(&v14[2], 0, 24);
  if (SDWORD1(v14[0]) >= 1)
  {
    v12 = 0;
    v13 = v15;
    do
      *(_DWORD *)&v13[4 * v12++] = 0;
    while (v12 < SDWORD1(v14[0]));
  }
  *((_QWORD *)&v14[1] + 1) = 0;
  if (v16 != (cv *)v17)
    cv::fastFree((void **)v16, v8);
}

void sub_219E8C330(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  void *v22;

  cv::MatExpr::~MatExpr((cv::MatExpr *)&a21, a2);
  cv::Mat::~Mat((cv::Mat *)&a9, v22);
  _Unwind_Resume(a1);
}

void cv::MatOp::add(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  void *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  char *v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  _QWORD *v16;
  _OWORD v17[4];
  char *v18;
  cv *v19;
  _QWORD v20[2];
  _QWORD v21[8];
  _QWORD *v22;
  cv *v23;
  _QWORD v24[2];

  v22 = &v21[1];
  v23 = (cv *)v24;
  v24[0] = 0;
  v24[1] = 0;
  LODWORD(v21[0]) = 1124007936;
  memset((char *)v21 + 4, 0, 32);
  memset((char *)&v21[4] + 4, 0, 28);
  (*(void (**)(_QWORD, _QWORD *, _QWORD *, uint64_t))(*(_QWORD *)*a2 + 24))(*a2, a2, v21, 0xFFFFFFFFLL);
  v18 = (char *)v17 + 8;
  v19 = (cv *)v20;
  v20[0] = 0;
  v20[1] = 0;
  LODWORD(v17[0]) = 1124007936;
  memset((char *)v17 + 4, 0, 48);
  v17[3] = 0u;
  cv::MatOp_AddEx::makeExpr(a4, (cv::Mat *)v21, (cv::Mat *)v17, a3, 1.0, 0.0);
  v7 = (unsigned int *)*((_QWORD *)&v17[1] + 1);
  if (*((_QWORD *)&v17[1] + 1))
  {
    do
    {
      v8 = __ldaxr(v7);
      v9 = v8 - 1;
    }
    while (__stlxr(v9, v7));
    if (!v9)
      cv::Mat::deallocate((cv::Mat *)v17, v6);
  }
  *(_QWORD *)&v17[1] = 0;
  memset(&v17[2], 0, 24);
  if (SDWORD1(v17[0]) >= 1)
  {
    v10 = 0;
    v11 = v18;
    do
      *(_DWORD *)&v11[4 * v10++] = 0;
    while (v10 < SDWORD1(v17[0]));
  }
  *((_QWORD *)&v17[1] + 1) = 0;
  if (v19 != (cv *)v20)
    cv::fastFree((void **)v19, v6);
  v12 = (unsigned int *)v21[3];
  if (v21[3])
  {
    do
    {
      v13 = __ldaxr(v12);
      v14 = v13 - 1;
    }
    while (__stlxr(v14, v12));
    if (!v14)
      cv::Mat::deallocate((cv::Mat *)v21, v6);
  }
  v21[2] = 0;
  memset(&v21[4], 0, 24);
  if (SHIDWORD(v21[0]) >= 1)
  {
    v15 = 0;
    v16 = v22;
    do
      *((_DWORD *)v16 + v15++) = 0;
    while (v15 < SHIDWORD(v21[0]));
  }
  v21[3] = 0;
  if (v23 != (cv *)v24)
    cv::fastFree((void **)v23, v6);
}

void sub_219E8C4FC(_Unwind_Exception *a1, void *a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  void *v22;

  cv::Mat::~Mat((cv::Mat *)&a9, a2);
  cv::Mat::~Mat((cv::Mat *)&a21, v22);
  _Unwind_Resume(a1);
}

void cv::MatOp::subtract(cv::MatOp *this, const cv::MatExpr *a2, const cv::MatExpr *a3, cv::MatExpr *a4)
{
  double v7;
  double v8;
  void *v9;
  unsigned int *v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  _BYTE *v14;
  unsigned int *v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  _BYTE *v19;
  _DWORD *v20;
  unsigned int *v21;
  unsigned int v22;
  unsigned int *v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t v26;
  _BYTE *v27;
  _DWORD *v28;
  unsigned int *v29;
  unsigned int v30;
  unsigned int *v31;
  unsigned int v32;
  unsigned int v33;
  uint64_t v34;
  _BYTE *v35;
  _QWORD *v36;
  cv *v37;
  uint64_t v38;
  __int128 v39;
  float64x2_t v40;
  _QWORD *v41;
  cv *v42;
  __int128 v43;
  float64x2_t v44;
  _BYTE v45[64];
  _BYTE *v46;
  cv *v47;
  _QWORD v48[2];
  _BYTE v49[64];
  _BYTE *v50;
  cv *v51;
  _QWORD v52[2];
  float64x2_t v53;
  float64x2_t v54;

  if (*(cv::MatOp **)a3 != this)
  {
    (*(void (**)(_QWORD, const cv::MatExpr *, const cv::MatExpr *, cv::MatExpr *))(**(_QWORD **)a3 + 120))(*(_QWORD *)a3, a2, a3, a4);
    return;
  }
  v53 = 0u;
  v54 = 0u;
  v50 = &v49[8];
  v51 = (cv *)v52;
  v52[0] = 0;
  v52[1] = 0;
  *(_DWORD *)v49 = 1124007936;
  memset(&v49[4], 0, 60);
  v46 = &v45[8];
  v47 = (cv *)v48;
  v48[0] = 0;
  v48[1] = 0;
  *(_DWORD *)v45 = 1124007936;
  memset(&v45[4], 0, 60);
  if (*(_UNKNOWN ***)a2 == &cv::g_MatOp_AddEx && (!*((_QWORD *)a2 + 16) || *((double *)a2 + 39) == 0.0))
  {
    v20 = (_DWORD *)((char *)a2 + 16);
    if (v49 == (char *)a2 + 16)
    {
LABEL_59:
      v7 = *((double *)a2 + 38);
      v40 = *((float64x2_t *)a2 + 21);
      v53 = *((float64x2_t *)a2 + 20);
      v54 = v40;
      goto LABEL_7;
    }
    v21 = (unsigned int *)*((_QWORD *)a2 + 5);
    if (v21)
    {
      do
        v22 = __ldaxr(v21);
      while (__stlxr(v22 + 1, v21));
      v23 = *(unsigned int **)&v49[24];
      if (*(_QWORD *)&v49[24])
      {
        do
        {
          v24 = __ldaxr(v23);
          v25 = v24 - 1;
        }
        while (__stlxr(v25, v23));
        if (!v25)
          cv::Mat::deallocate((cv::Mat *)v49, a2);
      }
    }
    *(_QWORD *)&v49[16] = 0;
    memset(&v49[32], 0, 24);
    if (*(uint64_t *)v49 <= 0)
    {
      *(_QWORD *)&v49[24] = 0;
      *(_DWORD *)v49 = *v20;
    }
    else
    {
      v26 = 0;
      v27 = v50;
      do
        *(_DWORD *)&v27[4 * v26++] = 0;
      while (v26 < *(int *)&v49[4]);
      *(_QWORD *)&v49[24] = 0;
      *(_DWORD *)v49 = *v20;
      if (*(int *)&v49[4] > 2)
        goto LABEL_57;
    }
    if (*((int *)a2 + 5) <= 2)
    {
      *(_DWORD *)&v49[4] = *((_DWORD *)a2 + 5);
      *(_QWORD *)&v49[8] = *((_QWORD *)a2 + 3);
      v36 = (_QWORD *)*((_QWORD *)a2 + 11);
      v37 = v51;
      *(_QWORD *)v51 = *v36;
      *((_QWORD *)v37 + 1) = v36[1];
LABEL_58:
      v38 = *((_QWORD *)a2 + 5);
      *(_QWORD *)&v49[16] = *((_QWORD *)a2 + 4);
      *(_QWORD *)&v49[24] = v38;
      v39 = *((_OWORD *)a2 + 4);
      *(_OWORD *)&v49[32] = *((_OWORD *)a2 + 3);
      *(_OWORD *)&v49[48] = v39;
      goto LABEL_59;
    }
LABEL_57:
    cv::Mat::copySize((cv::Mat *)v49, (const cv::MatExpr *)((char *)a2 + 16));
    goto LABEL_58;
  }
  v7 = 1.0;
  (*(void (**)(_QWORD, const cv::MatExpr *, _BYTE *, uint64_t))(**(_QWORD **)a2 + 24))(*(_QWORD *)a2, a2, v49, 0xFFFFFFFFLL);
LABEL_7:
  if (*(_UNKNOWN ***)a3 != &cv::g_MatOp_AddEx || *((_QWORD *)a3 + 16) && *((double *)a3 + 39) != 0.0)
  {
    v8 = -1.0;
    (*(void (**)(_QWORD, const cv::MatExpr *, _BYTE *, uint64_t))(**(_QWORD **)a3 + 24))(*(_QWORD *)a3, a3, v45, 0xFFFFFFFFLL);
    goto LABEL_11;
  }
  v28 = (_DWORD *)((char *)a3 + 16);
  if (v45 != (char *)a3 + 16)
  {
    v29 = (unsigned int *)*((_QWORD *)a3 + 5);
    if (v29)
    {
      do
        v30 = __ldaxr(v29);
      while (__stlxr(v30 + 1, v29));
    }
    v31 = *(unsigned int **)&v45[24];
    if (*(_QWORD *)&v45[24])
    {
      do
      {
        v32 = __ldaxr(v31);
        v33 = v32 - 1;
      }
      while (__stlxr(v33, v31));
      if (!v33)
        cv::Mat::deallocate((cv::Mat *)v45, a2);
    }
    *(_QWORD *)&v45[16] = 0;
    memset(&v45[32], 0, 24);
    if (*(uint64_t *)v45 <= 0)
    {
      *(_QWORD *)&v45[24] = 0;
      *(_DWORD *)v45 = *v28;
    }
    else
    {
      v34 = 0;
      v35 = v46;
      do
        *(_DWORD *)&v35[4 * v34++] = 0;
      while (v34 < *(int *)&v45[4]);
      *(_QWORD *)&v45[24] = 0;
      *(_DWORD *)v45 = *v28;
      if (*(int *)&v45[4] > 2)
        goto LABEL_63;
    }
    if (*((int *)a3 + 5) <= 2)
    {
      *(_DWORD *)&v45[4] = *((_DWORD *)a3 + 5);
      *(_QWORD *)&v45[8] = *((_QWORD *)a3 + 3);
      v41 = (_QWORD *)*((_QWORD *)a3 + 11);
      v42 = v47;
      *(_QWORD *)v47 = *v41;
      *((_QWORD *)v42 + 1) = v41[1];
LABEL_64:
      v43 = *((_OWORD *)a3 + 3);
      *(_OWORD *)&v45[16] = *((_OWORD *)a3 + 2);
      *(_OWORD *)&v45[32] = v43;
      *(_OWORD *)&v45[48] = *((_OWORD *)a3 + 4);
      goto LABEL_65;
    }
LABEL_63:
    cv::Mat::copySize((cv::Mat *)v45, (const cv::MatExpr *)((char *)a3 + 16));
    goto LABEL_64;
  }
LABEL_65:
  v8 = -*((double *)a3 + 38);
  v44 = vsubq_f64(v54, *((float64x2_t *)a3 + 21));
  v53 = vsubq_f64(v53, *((float64x2_t *)a3 + 20));
  v54 = v44;
LABEL_11:
  cv::MatOp_AddEx::makeExpr((uint64_t)a4, (cv::Mat *)v49, (cv::Mat *)v45, (uint64_t)&v53, v7, v8);
  v10 = *(unsigned int **)&v45[24];
  if (*(_QWORD *)&v45[24])
  {
    do
    {
      v11 = __ldaxr(v10);
      v12 = v11 - 1;
    }
    while (__stlxr(v12, v10));
    if (!v12)
      cv::Mat::deallocate((cv::Mat *)v45, v9);
  }
  *(_QWORD *)&v45[16] = 0;
  memset(&v45[32], 0, 24);
  if (*(int *)&v45[4] >= 1)
  {
    v13 = 0;
    v14 = v46;
    do
      *(_DWORD *)&v14[4 * v13++] = 0;
    while (v13 < *(int *)&v45[4]);
  }
  *(_QWORD *)&v45[24] = 0;
  if (v47 != (cv *)v48)
    cv::fastFree((void **)v47, v9);
  v15 = *(unsigned int **)&v49[24];
  if (*(_QWORD *)&v49[24])
  {
    do
    {
      v16 = __ldaxr(v15);
      v17 = v16 - 1;
    }
    while (__stlxr(v17, v15));
    if (!v17)
      cv::Mat::deallocate((cv::Mat *)v49, v9);
  }
  *(_QWORD *)&v49[16] = 0;
  memset(&v49[32], 0, 24);
  if (*(int *)&v49[4] >= 1)
  {
    v18 = 0;
    v19 = v50;
    do
      *(_DWORD *)&v19[4 * v18++] = 0;
    while (v18 < *(int *)&v49[4]);
  }
  *(_QWORD *)&v49[24] = 0;
  if (v51 != (cv *)v52)
    cv::fastFree((void **)v51, v9);
}

void sub_219E8C9A0(_Unwind_Exception *a1, void *a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  void *v22;

  cv::Mat::~Mat((cv::Mat *)&a9, a2);
  cv::Mat::~Mat((cv::Mat *)&a21, v22);
  _Unwind_Resume(a1);
}

void cv::MatOp::subtract(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  void *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  char *v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  _QWORD *v16;
  _OWORD v17[4];
  char *v18;
  cv *v19;
  _QWORD v20[2];
  _QWORD v21[8];
  _QWORD *v22;
  cv *v23;
  _QWORD v24[2];

  v22 = &v21[1];
  v23 = (cv *)v24;
  v24[0] = 0;
  v24[1] = 0;
  LODWORD(v21[0]) = 1124007936;
  memset((char *)v21 + 4, 0, 32);
  memset((char *)&v21[4] + 4, 0, 28);
  (*(void (**)(_QWORD, _QWORD *, _QWORD *, uint64_t))(*(_QWORD *)*a3 + 24))(*a3, a3, v21, 0xFFFFFFFFLL);
  v18 = (char *)v17 + 8;
  v19 = (cv *)v20;
  v20[0] = 0;
  v20[1] = 0;
  LODWORD(v17[0]) = 1124007936;
  memset((char *)v17 + 4, 0, 48);
  v17[3] = 0u;
  cv::MatOp_AddEx::makeExpr(a4, (cv::Mat *)v21, (cv::Mat *)v17, a2, -1.0, 0.0);
  v7 = (unsigned int *)*((_QWORD *)&v17[1] + 1);
  if (*((_QWORD *)&v17[1] + 1))
  {
    do
    {
      v8 = __ldaxr(v7);
      v9 = v8 - 1;
    }
    while (__stlxr(v9, v7));
    if (!v9)
      cv::Mat::deallocate((cv::Mat *)v17, v6);
  }
  *(_QWORD *)&v17[1] = 0;
  memset(&v17[2], 0, 24);
  if (SDWORD1(v17[0]) >= 1)
  {
    v10 = 0;
    v11 = v18;
    do
      *(_DWORD *)&v11[4 * v10++] = 0;
    while (v10 < SDWORD1(v17[0]));
  }
  *((_QWORD *)&v17[1] + 1) = 0;
  if (v19 != (cv *)v20)
    cv::fastFree((void **)v19, v6);
  v12 = (unsigned int *)v21[3];
  if (v21[3])
  {
    do
    {
      v13 = __ldaxr(v12);
      v14 = v13 - 1;
    }
    while (__stlxr(v14, v12));
    if (!v14)
      cv::Mat::deallocate((cv::Mat *)v21, v6);
  }
  v21[2] = 0;
  memset(&v21[4], 0, 24);
  if (SHIDWORD(v21[0]) >= 1)
  {
    v15 = 0;
    v16 = v22;
    do
      *((_DWORD *)v16 + v15++) = 0;
    while (v15 < SHIDWORD(v21[0]));
  }
  v21[3] = 0;
  if (v23 != (cv *)v24)
    cv::fastFree((void **)v23, v6);
}

void sub_219E8CB6C(_Unwind_Exception *a1, void *a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  void *v22;

  cv::Mat::~Mat((cv::Mat *)&a9, a2);
  cv::Mat::~Mat((cv::Mat *)&a21, v22);
  _Unwind_Resume(a1);
}

void cv::MatOp::multiply(cv::MatOp *this, float64x2_t *a2, const cv::MatExpr *a3, cv::MatExpr *a4, double a5, const cv::Mat *a6)
{
  double v6;
  float64_t v10;
  void *v11;
  _UNKNOWN **v12;
  _DWORD *v13;
  unsigned int *v14;
  unsigned int v15;
  unsigned int *v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  _BYTE *v20;
  uint64_t v21;
  unsigned int *v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t v25;
  _BYTE *v26;
  unsigned int *v27;
  unsigned int v28;
  unsigned int v29;
  uint64_t v30;
  _BYTE *v31;
  _DWORD *v32;
  unsigned int *v33;
  unsigned int v34;
  unsigned int *v35;
  unsigned int v36;
  unsigned int v37;
  uint64_t v38;
  _BYTE *v39;
  float64x2_t *v40;
  unsigned int *v41;
  unsigned int v42;
  unsigned int *v43;
  unsigned int v44;
  unsigned int v45;
  uint64_t v46;
  _BYTE *v47;
  _QWORD *v48;
  cv *v49;
  __int128 v50;
  _DWORD *v51;
  unsigned int *v52;
  unsigned int v53;
  unsigned int *v54;
  unsigned int v55;
  unsigned int v56;
  uint64_t v57;
  _BYTE *v58;
  _QWORD *v59;
  cv *v60;
  __int128 v61;
  float64_t v62;
  cv *v63;
  float64_t v64;
  float64x2_t v65;
  _QWORD *v66;
  cv *v67;
  uint64_t v68;
  __int128 v69;
  _BYTE v70[64];
  _BYTE *v71;
  cv *v72;
  _QWORD v73[2];
  _BYTE v74[64];
  _BYTE *v75;
  cv *v76;
  _QWORD v77[2];

  v6 = a5;
  if (*(cv::MatOp **)a3 != this)
  {
    (*(void (**)(_QWORD, float64x2_t *, const cv::MatExpr *, cv::MatExpr *, double))(**(_QWORD **)a3 + 136))(*(_QWORD *)a3, a2, a3, a4, a5);
    return;
  }
  v75 = &v74[8];
  v76 = (cv *)v77;
  v77[0] = 0;
  v77[1] = 0;
  *(_DWORD *)v74 = 1124007936;
  memset(&v74[4], 0, 60);
  v71 = &v70[8];
  v72 = (cv *)v73;
  v73[0] = 0;
  v73[1] = 0;
  *(_DWORD *)v70 = 1124007936;
  memset(&v70[4], 0, 60);
  v10 = a2->f64[0];
  if (*(_UNKNOWN ***)&a2->f64[0] == &cv::g_MatOp_Bin && LODWORD(a2->f64[1]) == 47)
  {
    if (!*(_QWORD *)&a2[8].f64[0] || a2[19].f64[1] == 0.0)
    {
      if (this != (cv::MatOp *)&cv::g_MatOp_AddEx
        || *((_QWORD *)a3 + 16) && *((double *)a3 + 39) != 0.0
        || (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqzq_f64(*((float64x2_t *)a3 + 20)), (int32x4_t)vceqzq_f64(*((float64x2_t *)a3 + 21)))))) & 1) != 0)
      {
        (*(void (**)(cv::MatOp *, const cv::MatExpr *, _BYTE *, uint64_t))(*(_QWORD *)this + 24))(this, a3, v70, 0xFFFFFFFFLL);
LABEL_12:
        cv::MatOp_Bin::makeExpr(a4, (cv::MatExpr *)0x2F, (cv::Mat *)v70, (const cv::Mat *)&a2[1], a6, v6 / a2[19].f64[0]);
        goto LABEL_41;
      }
      v6 = *((double *)a3 + 38) * a5;
      v51 = (_DWORD *)((char *)a3 + 16);
      if (v70 == (char *)a3 + 16)
        goto LABEL_12;
      v52 = (unsigned int *)*((_QWORD *)a3 + 5);
      if (v52)
      {
        do
          v53 = __ldaxr(v52);
        while (__stlxr(v53 + 1, v52));
        v54 = *(unsigned int **)&v70[24];
        if (*(_QWORD *)&v70[24])
        {
          do
          {
            v55 = __ldaxr(v54);
            v56 = v55 - 1;
          }
          while (__stlxr(v56, v54));
          if (!v56)
            cv::Mat::deallocate((cv::Mat *)v70, a2);
        }
      }
      *(_QWORD *)&v70[16] = 0;
      memset(&v70[32], 0, 24);
      if (*(uint64_t *)v70 <= 0)
      {
        *(_QWORD *)&v70[24] = 0;
        *(_DWORD *)v70 = *v51;
      }
      else
      {
        v57 = 0;
        v58 = v71;
        do
          *(_DWORD *)&v58[4 * v57++] = 0;
        while (v57 < *(int *)&v70[4]);
        *(_QWORD *)&v70[24] = 0;
        *(_DWORD *)v70 = *v51;
        if (*(int *)&v70[4] > 2)
          goto LABEL_117;
      }
      if (*((int *)a3 + 5) <= 2)
      {
        *(_DWORD *)&v70[4] = *((_DWORD *)a3 + 5);
        *(_QWORD *)&v70[8] = *((_QWORD *)a3 + 3);
        v66 = (_QWORD *)*((_QWORD *)a3 + 11);
        v67 = v72;
        *(_QWORD *)v72 = *v66;
        *((_QWORD *)v67 + 1) = v66[1];
LABEL_118:
        v68 = *((_QWORD *)a3 + 5);
        *(_QWORD *)&v70[16] = *((_QWORD *)a3 + 4);
        *(_QWORD *)&v70[24] = v68;
        v69 = *((_OWORD *)a3 + 4);
        *(_OWORD *)&v70[32] = *((_OWORD *)a3 + 3);
        *(_OWORD *)&v70[48] = v69;
        goto LABEL_12;
      }
LABEL_117:
      cv::Mat::copySize((cv::Mat *)v70, (const cv::MatExpr *)((char *)a3 + 16));
      goto LABEL_118;
    }
    goto LABEL_17;
  }
  if (*(_UNKNOWN ***)&v10 != &cv::g_MatOp_AddEx
    || *(_QWORD *)&a2[8].f64[0] && a2[19].f64[1] != 0.0
    || (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqzq_f64(a2[20]), (int32x4_t)vceqzq_f64(a2[21]))))) & 1) != 0)
  {
LABEL_17:
    (*(void (**)(_QWORD, float64x2_t *, _BYTE *, uint64_t))(**(_QWORD **)&v10 + 24))(*(_QWORD *)&a2->f64[0], a2, v74, 0xFFFFFFFFLL);
    goto LABEL_18;
  }
  v40 = a2 + 1;
  if (v74 != (_BYTE *)&a2[1])
  {
    v41 = *(unsigned int **)&a2[2].f64[1];
    if (v41)
    {
      do
        v42 = __ldaxr(v41);
      while (__stlxr(v42 + 1, v41));
      v43 = *(unsigned int **)&v74[24];
      if (*(_QWORD *)&v74[24])
      {
        do
        {
          v44 = __ldaxr(v43);
          v45 = v44 - 1;
        }
        while (__stlxr(v45, v43));
        if (!v45)
          cv::Mat::deallocate((cv::Mat *)v74, a2);
      }
    }
    *(_QWORD *)&v74[16] = 0;
    memset(&v74[32], 0, 24);
    if (*(uint64_t *)v74 <= 0)
    {
      *(_QWORD *)&v74[24] = 0;
      *(_DWORD *)v74 = LODWORD(v40->f64[0]);
    }
    else
    {
      v46 = 0;
      v47 = v75;
      do
        *(_DWORD *)&v47[4 * v46++] = 0;
      while (v46 < *(int *)&v74[4]);
      *(_QWORD *)&v74[24] = 0;
      *(_DWORD *)v74 = LODWORD(v40->f64[0]);
      if (*(int *)&v74[4] > 2)
        goto LABEL_111;
    }
    if (SHIDWORD(a2[1].f64[0]) <= 2)
    {
      *(_DWORD *)&v74[4] = HIDWORD(a2[1].f64[0]);
      *(float64_t *)&v74[8] = a2[1].f64[1];
      v62 = a2[5].f64[1];
      v63 = v76;
      *(_QWORD *)v76 = **(_QWORD **)&v62;
      *((_QWORD *)v63 + 1) = *(_QWORD *)(*(_QWORD *)&v62 + 8);
LABEL_112:
      v64 = a2[2].f64[1];
      *(float64_t *)&v74[16] = a2[2].f64[0];
      *(float64_t *)&v74[24] = v64;
      v65 = a2[4];
      *(float64x2_t *)&v74[32] = a2[3];
      *(float64x2_t *)&v74[48] = v65;
      goto LABEL_113;
    }
LABEL_111:
    cv::Mat::copySize((cv::Mat *)v74, (const cv::Mat *)&a2[1]);
    goto LABEL_112;
  }
LABEL_113:
  v6 = a2[19].f64[0] * v6;
LABEL_18:
  v12 = *(_UNKNOWN ***)a3;
  if (*(_UNKNOWN ***)a3 != &cv::g_MatOp_AddEx)
  {
    if (v12 == &cv::g_MatOp_Bin && *((_DWORD *)a3 + 2) == 47 && (!*((_QWORD *)a3 + 16) || *((double *)a3 + 39) == 0.0))
    {
      v13 = (_DWORD *)((char *)a3 + 16);
      if (v70 == (char *)a3 + 16)
      {
LABEL_89:
        v21 = 47;
        v6 = v6 / *((double *)a3 + 38);
        goto LABEL_40;
      }
      v14 = (unsigned int *)*((_QWORD *)a3 + 5);
      if (v14)
      {
        do
          v15 = __ldaxr(v14);
        while (__stlxr(v15 + 1, v14));
      }
      v16 = *(unsigned int **)&v70[24];
      if (*(_QWORD *)&v70[24])
      {
        do
        {
          v17 = __ldaxr(v16);
          v18 = v17 - 1;
        }
        while (__stlxr(v18, v16));
        if (!v18)
          cv::Mat::deallocate((cv::Mat *)v70, a2);
      }
      *(_QWORD *)&v70[16] = 0;
      memset(&v70[32], 0, 24);
      if (*(uint64_t *)v70 <= 0)
      {
        *(_QWORD *)&v70[24] = 0;
        *(_DWORD *)v70 = *v13;
      }
      else
      {
        v19 = 0;
        v20 = v71;
        do
          *(_DWORD *)&v20[4 * v19++] = 0;
        while (v19 < *(int *)&v70[4]);
        *(_QWORD *)&v70[24] = 0;
        *(_DWORD *)v70 = *v13;
        if (*(int *)&v70[4] > 2)
          goto LABEL_87;
      }
      if (*((int *)a3 + 5) <= 2)
      {
        *(_DWORD *)&v70[4] = *((_DWORD *)a3 + 5);
        *(_QWORD *)&v70[8] = *((_QWORD *)a3 + 3);
        v48 = (_QWORD *)*((_QWORD *)a3 + 11);
        v49 = v72;
        *(_QWORD *)v72 = *v48;
        *((_QWORD *)v49 + 1) = v48[1];
LABEL_88:
        v50 = *((_OWORD *)a3 + 3);
        *(_OWORD *)&v70[16] = *((_OWORD *)a3 + 2);
        *(_OWORD *)&v70[32] = v50;
        *(_OWORD *)&v70[48] = *((_OWORD *)a3 + 4);
        goto LABEL_89;
      }
LABEL_87:
      cv::Mat::copySize((cv::Mat *)v70, (const cv::MatExpr *)((char *)a3 + 16));
      goto LABEL_88;
    }
    goto LABEL_38;
  }
  if ((!*((_QWORD *)a3 + 16) || *((double *)a3 + 39) == 0.0)
    && (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqzq_f64(*((float64x2_t *)a3 + 20)), (int32x4_t)vceqzq_f64(*((float64x2_t *)a3 + 21)))))) & 1) == 0)
  {
    v32 = (_DWORD *)((char *)a3 + 16);
    if (v70 == (char *)a3 + 16)
    {
LABEL_107:
      v6 = v6 * *((double *)a3 + 38);
      goto LABEL_39;
    }
    v33 = (unsigned int *)*((_QWORD *)a3 + 5);
    if (v33)
    {
      do
        v34 = __ldaxr(v33);
      while (__stlxr(v34 + 1, v33));
    }
    v35 = *(unsigned int **)&v70[24];
    if (*(_QWORD *)&v70[24])
    {
      do
      {
        v36 = __ldaxr(v35);
        v37 = v36 - 1;
      }
      while (__stlxr(v37, v35));
      if (!v37)
        cv::Mat::deallocate((cv::Mat *)v70, a2);
    }
    *(_QWORD *)&v70[16] = 0;
    memset(&v70[32], 0, 24);
    if (*(uint64_t *)v70 <= 0)
    {
      *(_QWORD *)&v70[24] = 0;
      *(_DWORD *)v70 = *v32;
    }
    else
    {
      v38 = 0;
      v39 = v71;
      do
        *(_DWORD *)&v39[4 * v38++] = 0;
      while (v38 < *(int *)&v70[4]);
      *(_QWORD *)&v70[24] = 0;
      *(_DWORD *)v70 = *v32;
      if (*(int *)&v70[4] > 2)
        goto LABEL_105;
    }
    if (*((int *)a3 + 5) <= 2)
    {
      *(_DWORD *)&v70[4] = *((_DWORD *)a3 + 5);
      *(_QWORD *)&v70[8] = *((_QWORD *)a3 + 3);
      v59 = (_QWORD *)*((_QWORD *)a3 + 11);
      v60 = v72;
      *(_QWORD *)v72 = *v59;
      *((_QWORD *)v60 + 1) = v59[1];
LABEL_106:
      v61 = *((_OWORD *)a3 + 3);
      *(_OWORD *)&v70[16] = *((_OWORD *)a3 + 2);
      *(_OWORD *)&v70[32] = v61;
      *(_OWORD *)&v70[48] = *((_OWORD *)a3 + 4);
      goto LABEL_107;
    }
LABEL_105:
    cv::Mat::copySize((cv::Mat *)v70, (const cv::MatExpr *)((char *)a3 + 16));
    goto LABEL_106;
  }
LABEL_38:
  (*((void (**)(_UNKNOWN **, const cv::MatExpr *, _BYTE *, uint64_t))*v12 + 3))(v12, a3, v70, 0xFFFFFFFFLL);
LABEL_39:
  v21 = 42;
LABEL_40:
  cv::MatOp_Bin::makeExpr(a4, (cv::MatExpr *)v21, (cv::Mat *)v74, (const cv::Mat *)v70, a6, v6);
LABEL_41:
  v22 = *(unsigned int **)&v70[24];
  if (*(_QWORD *)&v70[24])
  {
    do
    {
      v23 = __ldaxr(v22);
      v24 = v23 - 1;
    }
    while (__stlxr(v24, v22));
    if (!v24)
      cv::Mat::deallocate((cv::Mat *)v70, v11);
  }
  *(_QWORD *)&v70[16] = 0;
  memset(&v70[32], 0, 24);
  if (*(int *)&v70[4] >= 1)
  {
    v25 = 0;
    v26 = v71;
    do
      *(_DWORD *)&v26[4 * v25++] = 0;
    while (v25 < *(int *)&v70[4]);
  }
  *(_QWORD *)&v70[24] = 0;
  if (v72 != (cv *)v73)
    cv::fastFree((void **)v72, v11);
  v27 = *(unsigned int **)&v74[24];
  if (*(_QWORD *)&v74[24])
  {
    do
    {
      v28 = __ldaxr(v27);
      v29 = v28 - 1;
    }
    while (__stlxr(v29, v27));
    if (!v29)
      cv::Mat::deallocate((cv::Mat *)v74, v11);
  }
  *(_QWORD *)&v74[16] = 0;
  memset(&v74[32], 0, 24);
  if (*(int *)&v74[4] >= 1)
  {
    v30 = 0;
    v31 = v75;
    do
      *(_DWORD *)&v31[4 * v30++] = 0;
    while (v30 < *(int *)&v74[4]);
  }
  *(_QWORD *)&v74[24] = 0;
  if (v76 != (cv *)v77)
    cv::fastFree((void **)v76, v11);
}

void sub_219E8D314(_Unwind_Exception *a1, void *a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  void *v22;

  cv::Mat::~Mat((cv::Mat *)&a9, a2);
  cv::Mat::~Mat((cv::Mat *)&a21, v22);
  _Unwind_Resume(a1);
}

void cv::MatOp_Bin::makeExpr(cv::MatOp_Bin *this, cv::MatExpr *a2, cv::Mat *a3, const cv::Mat *a4, const cv::Mat *a5, double a6)
{
  uint64_t v7;
  double v8;
  void *v9;
  void *v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  char *v15;
  _OWORD v16[2];
  _OWORD v17[4];
  char *v18;
  cv *v19;
  _QWORD v20[2];
  uint64_t v21[44];

  v18 = (char *)v17 + 8;
  v19 = (cv *)v20;
  v20[0] = 0;
  v20[1] = 0;
  LODWORD(v17[0]) = 1124007936;
  memset((char *)v17 + 4, 0, 48);
  v17[3] = 0u;
  v7 = *((_QWORD *)a4 + 2);
  memset(v16, 0, sizeof(v16));
  v8 = 0.0;
  if (v7)
    v8 = 1.0;
  cv::MatExpr::MatExpr((uint64_t)v21, (uint64_t)&cv::g_MatOp_Bin, (int)a2, a3, a4, (cv::Mat *)v17, (uint64_t)v16, a6, v8);
  cv::MatExpr::operator=((uint64_t)this, v21);
  cv::MatExpr::~MatExpr((cv::MatExpr *)v21, v9);
  v11 = (unsigned int *)*((_QWORD *)&v17[1] + 1);
  if (*((_QWORD *)&v17[1] + 1))
  {
    do
    {
      v12 = __ldaxr(v11);
      v13 = v12 - 1;
    }
    while (__stlxr(v13, v11));
    if (!v13)
      cv::Mat::deallocate((cv::Mat *)v17, v10);
  }
  *(_QWORD *)&v17[1] = 0;
  memset(&v17[2], 0, 24);
  if (SDWORD1(v17[0]) >= 1)
  {
    v14 = 0;
    v15 = v18;
    do
      *(_DWORD *)&v15[4 * v14++] = 0;
    while (v14 < SDWORD1(v17[0]));
  }
  *((_QWORD *)&v17[1] + 1) = 0;
  if (v19 != (cv *)v20)
    cv::fastFree((void **)v19, v10);
}

void sub_219E8D458(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  void *v7;
  uint64_t v8;
  va_list va;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  v19 = va_arg(va1, _QWORD);
  v20 = va_arg(va1, _QWORD);
  cv::MatExpr::~MatExpr((cv::MatExpr *)va1, a2);
  cv::Mat::~Mat((cv::Mat *)va, v7);
  _Unwind_Resume(a1);
}

void cv::MatOp::multiply(cv::MatOp *this, const cv::MatExpr *a2, double a3, cv::MatExpr *a4)
{
  void *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  char *v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  _QWORD *v16;
  _OWORD v17[2];
  _OWORD v18[4];
  char *v19;
  cv *v20;
  _QWORD v21[2];
  _QWORD v22[8];
  _QWORD *v23;
  cv *v24;
  _QWORD v25[2];

  v23 = &v22[1];
  v24 = (cv *)v25;
  v25[0] = 0;
  v25[1] = 0;
  LODWORD(v22[0]) = 1124007936;
  memset((char *)v22 + 4, 0, 32);
  memset((char *)&v22[4] + 4, 0, 28);
  (*(void (**)(_QWORD, const cv::MatExpr *, _QWORD *, uint64_t))(**(_QWORD **)a2 + 24))(*(_QWORD *)a2, a2, v22, 0xFFFFFFFFLL);
  v19 = (char *)v18 + 8;
  v20 = (cv *)v21;
  v21[0] = 0;
  v21[1] = 0;
  LODWORD(v18[0]) = 1124007936;
  memset((char *)v18 + 4, 0, 48);
  v18[3] = 0u;
  memset(v17, 0, sizeof(v17));
  cv::MatOp_AddEx::makeExpr((uint64_t)a4, (cv::Mat *)v22, (cv::Mat *)v18, (uint64_t)v17, a3, 0.0);
  v7 = (unsigned int *)*((_QWORD *)&v18[1] + 1);
  if (*((_QWORD *)&v18[1] + 1))
  {
    do
    {
      v8 = __ldaxr(v7);
      v9 = v8 - 1;
    }
    while (__stlxr(v9, v7));
    if (!v9)
      cv::Mat::deallocate((cv::Mat *)v18, v6);
  }
  *(_QWORD *)&v18[1] = 0;
  memset(&v18[2], 0, 24);
  if (SDWORD1(v18[0]) >= 1)
  {
    v10 = 0;
    v11 = v19;
    do
      *(_DWORD *)&v11[4 * v10++] = 0;
    while (v10 < SDWORD1(v18[0]));
  }
  *((_QWORD *)&v18[1] + 1) = 0;
  if (v20 != (cv *)v21)
    cv::fastFree((void **)v20, v6);
  v12 = (unsigned int *)v22[3];
  if (v22[3])
  {
    do
    {
      v13 = __ldaxr(v12);
      v14 = v13 - 1;
    }
    while (__stlxr(v14, v12));
    if (!v14)
      cv::Mat::deallocate((cv::Mat *)v22, v6);
  }
  v22[2] = 0;
  memset(&v22[4], 0, 24);
  if (SHIDWORD(v22[0]) >= 1)
  {
    v15 = 0;
    v16 = v23;
    do
      *((_DWORD *)v16 + v15++) = 0;
    while (v15 < SHIDWORD(v22[0]));
  }
  v22[3] = 0;
  if (v24 != (cv *)v25)
    cv::fastFree((void **)v24, v6);
}

void sub_219E8D630(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  void *v7;
  uint64_t v8;
  va_list va;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  v19 = va_arg(va1, _QWORD);
  v20 = va_arg(va1, _QWORD);
  cv::Mat::~Mat((cv::Mat *)va, a2);
  cv::Mat::~Mat((cv::Mat *)va1, v7);
  _Unwind_Resume(a1);
}

void cv::MatOp::divide(cv::MatOp *this, float64x2_t *a2, float64x2_t *a3, cv::MatExpr *a4, double a5, const cv::Mat *a6)
{
  double v6;
  float64_t v11;
  float64_t v12;
  float64x2_t *v13;
  unsigned int *v14;
  unsigned int v15;
  unsigned int *v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  _BYTE *v20;
  uint64_t v21;
  float64x2_t *v22;
  unsigned int *v23;
  unsigned int v24;
  unsigned int *v25;
  unsigned int v26;
  unsigned int v27;
  uint64_t v28;
  _BYTE *v29;
  float64x2_t *v30;
  unsigned int *v31;
  unsigned int v32;
  unsigned int *v33;
  unsigned int v34;
  unsigned int v35;
  uint64_t v36;
  _BYTE *v37;
  float64_t v38;
  cv *v39;
  float64x2_t v40;
  double v41;
  float64_t v42;
  cv *v43;
  float64_t v44;
  float64x2_t v45;
  float64_t v46;
  cv *v47;
  float64x2_t v48;
  void *v49;
  unsigned int *v50;
  unsigned int v51;
  unsigned int v52;
  uint64_t v53;
  _BYTE *v54;
  unsigned int *v55;
  unsigned int v56;
  unsigned int v57;
  uint64_t v58;
  _BYTE *v59;
  _BYTE v60[64];
  _BYTE *v61;
  cv *v62;
  _QWORD v63[2];
  _BYTE v64[64];
  _BYTE *v65;
  cv *v66;
  _QWORD v67[2];

  v6 = a5;
  if (*(cv::MatOp **)&a3->f64[0] != this)
  {
    (*(void (**)(_QWORD, float64x2_t *, float64x2_t *, cv::MatExpr *, double))(**(_QWORD **)&a3->f64[0]
                                                                                        + 152))(*(_QWORD *)&a3->f64[0], a2, a3, a4, a5);
    return;
  }
  v11 = a2->f64[0];
  if (*(_UNKNOWN ***)&a2->f64[0] == &cv::g_MatOp_Bin
    && LODWORD(a2->f64[1]) == 47
    && (!*(_QWORD *)&a2[8].f64[0] || a2[19].f64[1] == 0.0)
    && this == (cv::MatOp *)&cv::g_MatOp_Bin
    && LODWORD(a3->f64[1]) == 47
    && (!*(_QWORD *)&a3[8].f64[0] || a3[19].f64[1] == 0.0))
  {
    cv::MatOp_Bin::makeExpr(a4, (cv::MatExpr *)0x2F, (cv::Mat *)&a3[1], (const cv::Mat *)&a2[1], a6, a2[19].f64[0] / a3[19].f64[0]);
    return;
  }
  v65 = &v64[8];
  v66 = (cv *)v67;
  v67[0] = 0;
  v67[1] = 0;
  *(_DWORD *)v64 = 1124007936;
  memset(&v64[4], 0, 60);
  v61 = &v60[8];
  v62 = (cv *)v63;
  v63[0] = 0;
  v63[1] = 0;
  *(_DWORD *)v60 = 1124007936;
  memset(&v60[4], 0, 60);
  if (*(_UNKNOWN ***)&v11 != &cv::g_MatOp_AddEx
    || *(_QWORD *)&a2[8].f64[0] && a2[19].f64[1] != 0.0
    || (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqzq_f64(a2[20]), (int32x4_t)vceqzq_f64(a2[21]))))) & 1) != 0)
  {
    (*(void (**)(float64_t, float64x2_t *, _BYTE *, uint64_t))(**(_QWORD **)&v11 + 24))(COERCE_FLOAT64_T(*(_QWORD *)&v11), a2, v64, 0xFFFFFFFFLL);
    goto LABEL_12;
  }
  v22 = a2 + 1;
  if (v64 != (_BYTE *)&a2[1])
  {
    v23 = *(unsigned int **)&a2[2].f64[1];
    if (v23)
    {
      do
        v24 = __ldaxr(v23);
      while (__stlxr(v24 + 1, v23));
      v25 = *(unsigned int **)&v64[24];
      if (*(_QWORD *)&v64[24])
      {
        do
        {
          v26 = __ldaxr(v25);
          v27 = v26 - 1;
        }
        while (__stlxr(v27, v25));
        if (!v27)
          cv::Mat::deallocate((cv::Mat *)v64, a2);
      }
    }
    *(_QWORD *)&v64[16] = 0;
    memset(&v64[32], 0, 24);
    if (*(uint64_t *)v64 <= 0)
    {
      *(_QWORD *)&v64[24] = 0;
      *(_DWORD *)v64 = LODWORD(v22->f64[0]);
    }
    else
    {
      v28 = 0;
      v29 = v65;
      do
        *(_DWORD *)&v29[4 * v28++] = 0;
      while (v28 < *(int *)&v64[4]);
      *(_QWORD *)&v64[24] = 0;
      *(_DWORD *)v64 = LODWORD(v22->f64[0]);
      if (*(int *)&v64[4] > 2)
        goto LABEL_71;
    }
    if (SHIDWORD(a2[1].f64[0]) <= 2)
    {
      *(_DWORD *)&v64[4] = HIDWORD(a2[1].f64[0]);
      *(float64_t *)&v64[8] = a2[1].f64[1];
      v42 = a2[5].f64[1];
      v43 = v66;
      *(_QWORD *)v66 = **(_QWORD **)&v42;
      *((_QWORD *)v43 + 1) = *(_QWORD *)(*(_QWORD *)&v42 + 8);
LABEL_72:
      v44 = a2[2].f64[1];
      *(float64_t *)&v64[16] = a2[2].f64[0];
      *(float64_t *)&v64[24] = v44;
      v45 = a2[4];
      *(float64x2_t *)&v64[32] = a2[3];
      *(float64x2_t *)&v64[48] = v45;
      goto LABEL_73;
    }
LABEL_71:
    cv::Mat::copySize((cv::Mat *)v64, (const cv::Mat *)&a2[1]);
    goto LABEL_72;
  }
LABEL_73:
  v6 = a2[19].f64[0] * v6;
LABEL_12:
  v12 = a3->f64[0];
  if (*(_UNKNOWN ***)&a3->f64[0] == &cv::g_MatOp_AddEx)
  {
    if (*(_QWORD *)&a3[8].f64[0] && a3[19].f64[1] != 0.0
      || (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqzq_f64(a3[20]), (int32x4_t)vceqzq_f64(a3[21]))))) & 1) != 0)
    {
      goto LABEL_32;
    }
    v30 = a3 + 1;
    if (v60 == (_BYTE *)&a3[1])
    {
LABEL_79:
      v41 = a3[19].f64[0];
      v21 = 47;
      goto LABEL_80;
    }
    v31 = *(unsigned int **)&a3[2].f64[1];
    if (v31)
    {
      do
        v32 = __ldaxr(v31);
      while (__stlxr(v32 + 1, v31));
    }
    v33 = *(unsigned int **)&v60[24];
    if (*(_QWORD *)&v60[24])
    {
      do
      {
        v34 = __ldaxr(v33);
        v35 = v34 - 1;
      }
      while (__stlxr(v35, v33));
      if (!v35)
        cv::Mat::deallocate((cv::Mat *)v60, a2);
    }
    *(_QWORD *)&v60[16] = 0;
    memset(&v60[32], 0, 24);
    if (*(uint64_t *)v60 <= 0)
    {
      *(_QWORD *)&v60[24] = 0;
      *(_DWORD *)v60 = LODWORD(v30->f64[0]);
    }
    else
    {
      v36 = 0;
      v37 = v61;
      do
        *(_DWORD *)&v37[4 * v36++] = 0;
      while (v36 < *(int *)&v60[4]);
      *(_QWORD *)&v60[24] = 0;
      *(_DWORD *)v60 = LODWORD(v30->f64[0]);
      if (*(int *)&v60[4] > 2)
        goto LABEL_77;
    }
    if (SHIDWORD(a3[1].f64[0]) <= 2)
    {
      *(_DWORD *)&v60[4] = HIDWORD(a3[1].f64[0]);
      *(float64_t *)&v60[8] = a3[1].f64[1];
      v46 = a3[5].f64[1];
      v47 = v62;
      *(_QWORD *)v62 = **(_QWORD **)&v46;
      *((_QWORD *)v47 + 1) = *(_QWORD *)(*(_QWORD *)&v46 + 8);
LABEL_78:
      v48 = a3[3];
      *(float64x2_t *)&v60[16] = a3[2];
      *(float64x2_t *)&v60[32] = v48;
      *(float64x2_t *)&v60[48] = a3[4];
      goto LABEL_79;
    }
LABEL_77:
    cv::Mat::copySize((cv::Mat *)v60, (const cv::Mat *)&a3[1]);
    goto LABEL_78;
  }
  if (*(_UNKNOWN ***)&v12 != &cv::g_MatOp_Bin
    || LODWORD(a3->f64[1]) != 47
    || *(_QWORD *)&a3[8].f64[0] && a3[19].f64[1] != 0.0)
  {
LABEL_32:
    (*(void (**)(float64_t, float64x2_t *, _BYTE *, uint64_t))(**(_QWORD **)&v12 + 24))(COERCE_FLOAT64_T(*(_QWORD *)&v12), a3, v60, 0xFFFFFFFFLL);
    v21 = 47;
    goto LABEL_81;
  }
  v13 = a3 + 1;
  if (v60 != (_BYTE *)&a3[1])
  {
    v14 = *(unsigned int **)&a3[2].f64[1];
    if (v14)
    {
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 + 1, v14));
    }
    v16 = *(unsigned int **)&v60[24];
    if (*(_QWORD *)&v60[24])
    {
      do
      {
        v17 = __ldaxr(v16);
        v18 = v17 - 1;
      }
      while (__stlxr(v18, v16));
      if (!v18)
        cv::Mat::deallocate((cv::Mat *)v60, a2);
    }
    *(_QWORD *)&v60[16] = 0;
    memset(&v60[32], 0, 24);
    if (*(uint64_t *)v60 <= 0)
    {
      *(_QWORD *)&v60[24] = 0;
      *(_DWORD *)v60 = LODWORD(v13->f64[0]);
    }
    else
    {
      v19 = 0;
      v20 = v61;
      do
        *(_DWORD *)&v20[4 * v19++] = 0;
      while (v19 < *(int *)&v60[4]);
      *(_QWORD *)&v60[24] = 0;
      *(_DWORD *)v60 = LODWORD(v13->f64[0]);
      if (*(int *)&v60[4] > 2)
        goto LABEL_65;
    }
    if (SHIDWORD(a3[1].f64[0]) <= 2)
    {
      *(_DWORD *)&v60[4] = HIDWORD(a3[1].f64[0]);
      *(float64_t *)&v60[8] = a3[1].f64[1];
      v38 = a3[5].f64[1];
      v39 = v62;
      *(_QWORD *)v62 = **(_QWORD **)&v38;
      *((_QWORD *)v39 + 1) = *(_QWORD *)(*(_QWORD *)&v38 + 8);
LABEL_66:
      v40 = a3[3];
      *(float64x2_t *)&v60[16] = a3[2];
      *(float64x2_t *)&v60[32] = v40;
      *(float64x2_t *)&v60[48] = a3[4];
      goto LABEL_67;
    }
LABEL_65:
    cv::Mat::copySize((cv::Mat *)v60, (const cv::Mat *)&a3[1]);
    goto LABEL_66;
  }
LABEL_67:
  v41 = a3[19].f64[0];
  v21 = 42;
LABEL_80:
  v6 = v6 / v41;
LABEL_81:
  cv::MatOp_Bin::makeExpr(a4, (cv::MatExpr *)v21, (cv::Mat *)v64, (const cv::Mat *)v60, a6, v6);
  v50 = *(unsigned int **)&v60[24];
  if (*(_QWORD *)&v60[24])
  {
    do
    {
      v51 = __ldaxr(v50);
      v52 = v51 - 1;
    }
    while (__stlxr(v52, v50));
    if (!v52)
      cv::Mat::deallocate((cv::Mat *)v60, v49);
  }
  *(_QWORD *)&v60[16] = 0;
  memset(&v60[32], 0, 24);
  if (*(int *)&v60[4] >= 1)
  {
    v53 = 0;
    v54 = v61;
    do
      *(_DWORD *)&v54[4 * v53++] = 0;
    while (v53 < *(int *)&v60[4]);
  }
  *(_QWORD *)&v60[24] = 0;
  if (v62 != (cv *)v63)
    cv::fastFree((void **)v62, v49);
  v55 = *(unsigned int **)&v64[24];
  if (*(_QWORD *)&v64[24])
  {
    do
    {
      v56 = __ldaxr(v55);
      v57 = v56 - 1;
    }
    while (__stlxr(v57, v55));
    if (!v57)
      cv::Mat::deallocate((cv::Mat *)v64, v49);
  }
  *(_QWORD *)&v64[16] = 0;
  memset(&v64[32], 0, 24);
  if (*(int *)&v64[4] >= 1)
  {
    v58 = 0;
    v59 = v65;
    do
      *(_DWORD *)&v59[4 * v58++] = 0;
    while (v58 < *(int *)&v64[4]);
  }
  *(_QWORD *)&v64[24] = 0;
  if (v66 != (cv *)v67)
    cv::fastFree((void **)v66, v49);
}

void sub_219E8DCCC(_Unwind_Exception *a1, void *a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  void *v22;

  cv::Mat::~Mat((cv::Mat *)&a9, a2);
  cv::Mat::~Mat((cv::Mat *)&a21, v22);
  _Unwind_Resume(a1);
}

void cv::MatOp::divide(cv::MatOp *this, double a2, const cv::MatExpr *a3, cv::MatExpr *a4)
{
  const cv::Mat *v6;
  void *v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  char *v12;
  unsigned int *v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  _QWORD *v17;
  _OWORD v18[4];
  char *v19;
  cv *v20;
  _QWORD v21[2];
  _QWORD v22[8];
  _QWORD *v23;
  cv *v24;
  _QWORD v25[2];

  v23 = &v22[1];
  v24 = (cv *)v25;
  v25[0] = 0;
  v25[1] = 0;
  LODWORD(v22[0]) = 1124007936;
  memset((char *)v22 + 4, 0, 32);
  memset((char *)&v22[4] + 4, 0, 28);
  (*(void (**)(_QWORD, const cv::MatExpr *, _QWORD *, uint64_t))(**(_QWORD **)a3 + 24))(*(_QWORD *)a3, a3, v22, 0xFFFFFFFFLL);
  v19 = (char *)v18 + 8;
  v20 = (cv *)v21;
  v21[0] = 0;
  v21[1] = 0;
  LODWORD(v18[0]) = 1124007936;
  memset((char *)v18 + 4, 0, 48);
  v18[3] = 0u;
  cv::MatOp_Bin::makeExpr(a4, (cv::MatExpr *)0x2F, (cv::Mat *)v22, (const cv::Mat *)v18, v6, a2);
  v8 = (unsigned int *)*((_QWORD *)&v18[1] + 1);
  if (*((_QWORD *)&v18[1] + 1))
  {
    do
    {
      v9 = __ldaxr(v8);
      v10 = v9 - 1;
    }
    while (__stlxr(v10, v8));
    if (!v10)
      cv::Mat::deallocate((cv::Mat *)v18, v7);
  }
  *(_QWORD *)&v18[1] = 0;
  memset(&v18[2], 0, 24);
  if (SDWORD1(v18[0]) >= 1)
  {
    v11 = 0;
    v12 = v19;
    do
      *(_DWORD *)&v12[4 * v11++] = 0;
    while (v11 < SDWORD1(v18[0]));
  }
  *((_QWORD *)&v18[1] + 1) = 0;
  if (v20 != (cv *)v21)
    cv::fastFree((void **)v20, v7);
  v13 = (unsigned int *)v22[3];
  if (v22[3])
  {
    do
    {
      v14 = __ldaxr(v13);
      v15 = v14 - 1;
    }
    while (__stlxr(v15, v13));
    if (!v15)
      cv::Mat::deallocate((cv::Mat *)v22, v7);
  }
  v22[2] = 0;
  memset(&v22[4], 0, 24);
  if (SHIDWORD(v22[0]) >= 1)
  {
    v16 = 0;
    v17 = v23;
    do
      *((_DWORD *)v17 + v16++) = 0;
    while (v16 < SHIDWORD(v22[0]));
  }
  v22[3] = 0;
  if (v24 != (cv *)v25)
    cv::fastFree((void **)v24, v7);
}

void sub_219E8DE94(_Unwind_Exception *a1, void *a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  void *v22;

  cv::Mat::~Mat((cv::Mat *)&a9, a2);
  cv::Mat::~Mat((cv::Mat *)&a21, v22);
  _Unwind_Resume(a1);
}

void cv::MatOp::abs(cv::MatOp *this, const cv::MatExpr *a2, cv::MatExpr *a3)
{
  const cv::Mat *v4;
  void *v5;
  unsigned int *v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  char *v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  _QWORD *v15;
  _OWORD v16[4];
  char *v17;
  cv *v18;
  _QWORD v19[2];
  _QWORD v20[8];
  _QWORD *v21;
  cv *v22;
  _QWORD v23[2];

  v21 = &v20[1];
  v22 = (cv *)v23;
  v23[0] = 0;
  v23[1] = 0;
  LODWORD(v20[0]) = 1124007936;
  memset((char *)v20 + 4, 0, 32);
  memset((char *)&v20[4] + 4, 0, 28);
  (*(void (**)(_QWORD, const cv::MatExpr *, _QWORD *, uint64_t))(**(_QWORD **)a2 + 24))(*(_QWORD *)a2, a2, v20, 0xFFFFFFFFLL);
  v17 = (char *)v16 + 8;
  v18 = (cv *)v19;
  v19[0] = 0;
  v19[1] = 0;
  LODWORD(v16[0]) = 1124007936;
  memset((char *)v16 + 4, 0, 48);
  v16[3] = 0u;
  cv::MatOp_Bin::makeExpr(a3, (cv::MatExpr *)0x61, (cv::Mat *)v20, (const cv::Mat *)v16, v4, 1.0);
  v6 = (unsigned int *)*((_QWORD *)&v16[1] + 1);
  if (*((_QWORD *)&v16[1] + 1))
  {
    do
    {
      v7 = __ldaxr(v6);
      v8 = v7 - 1;
    }
    while (__stlxr(v8, v6));
    if (!v8)
      cv::Mat::deallocate((cv::Mat *)v16, v5);
  }
  *(_QWORD *)&v16[1] = 0;
  memset(&v16[2], 0, 24);
  if (SDWORD1(v16[0]) >= 1)
  {
    v9 = 0;
    v10 = v17;
    do
      *(_DWORD *)&v10[4 * v9++] = 0;
    while (v9 < SDWORD1(v16[0]));
  }
  *((_QWORD *)&v16[1] + 1) = 0;
  if (v18 != (cv *)v19)
    cv::fastFree((void **)v18, v5);
  v11 = (unsigned int *)v20[3];
  if (v20[3])
  {
    do
    {
      v12 = __ldaxr(v11);
      v13 = v12 - 1;
    }
    while (__stlxr(v13, v11));
    if (!v13)
      cv::Mat::deallocate((cv::Mat *)v20, v5);
  }
  v20[2] = 0;
  memset(&v20[4], 0, 24);
  if (SHIDWORD(v20[0]) >= 1)
  {
    v14 = 0;
    v15 = v21;
    do
      *((_DWORD *)v15 + v14++) = 0;
    while (v14 < SHIDWORD(v20[0]));
  }
  v20[3] = 0;
  if (v22 != (cv *)v23)
    cv::fastFree((void **)v22, v5);
}

void sub_219E8E050(_Unwind_Exception *a1, void *a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  void *v22;

  cv::Mat::~Mat((cv::Mat *)&a9, a2);
  cv::Mat::~Mat((cv::Mat *)&a21, v22);
  _Unwind_Resume(a1);
}

void cv::MatOp::transpose(cv::MatOp *this, const cv::MatExpr *a2, cv::MatExpr *a3)
{
  const cv::Mat *v4;
  void *v5;
  unsigned int *v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD v11[8];
  _QWORD *v12;
  cv *v13;
  _QWORD v14[2];

  v12 = &v11[1];
  v13 = (cv *)v14;
  v14[0] = 0;
  v14[1] = 0;
  LODWORD(v11[0]) = 1124007936;
  memset((char *)v11 + 4, 0, 32);
  memset((char *)&v11[4] + 4, 0, 28);
  (*(void (**)(_QWORD, const cv::MatExpr *, _QWORD *, uint64_t))(**(_QWORD **)a2 + 24))(*(_QWORD *)a2, a2, v11, 0xFFFFFFFFLL);
  cv::MatOp_T::makeExpr(a3, (cv::MatExpr *)v11, v4, 1.0);
  v6 = (unsigned int *)v11[3];
  if (v11[3])
  {
    do
    {
      v7 = __ldaxr(v6);
      v8 = v7 - 1;
    }
    while (__stlxr(v8, v6));
    if (!v8)
      cv::Mat::deallocate((cv::Mat *)v11, v5);
  }
  v11[2] = 0;
  memset(&v11[4], 0, 24);
  if (SHIDWORD(v11[0]) >= 1)
  {
    v9 = 0;
    v10 = v12;
    do
      *((_DWORD *)v10 + v9++) = 0;
    while (v9 < SHIDWORD(v11[0]));
  }
  v11[3] = 0;
  if (v13 != (cv *)v14)
    cv::fastFree((void **)v13, v5);
}

void sub_219E8E160(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  cv::Mat::~Mat((cv::Mat *)&a9, a2);
  _Unwind_Resume(a1);
}

void cv::MatOp_T::makeExpr(cv::MatOp_T *this, cv::MatExpr *a2, const cv::Mat *a3, double a4)
{
  void *v5;
  void *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  char *v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  char *v16;
  _OWORD v17[2];
  _OWORD v18[4];
  char *v19;
  cv *v20;
  _QWORD v21[2];
  _OWORD v22[4];
  char *v23;
  cv *v24;
  _QWORD v25[2];
  uint64_t v26[44];

  v23 = (char *)v22 + 8;
  v24 = (cv *)v25;
  v25[0] = 0;
  v25[1] = 0;
  LODWORD(v22[0]) = 1124007936;
  memset((char *)v22 + 4, 0, 48);
  v22[3] = 0u;
  v19 = (char *)v18 + 8;
  v20 = (cv *)v21;
  v21[0] = 0;
  v21[1] = 0;
  LODWORD(v18[0]) = 1124007936;
  memset((char *)v18 + 4, 0, 48);
  v18[3] = 0u;
  memset(v17, 0, sizeof(v17));
  cv::MatExpr::MatExpr((uint64_t)v26, (uint64_t)&cv::g_MatOp_T, 0, a2, (cv::Mat *)v22, (cv::Mat *)v18, (uint64_t)v17, a4, 0.0);
  cv::MatExpr::operator=((uint64_t)this, v26);
  cv::MatExpr::~MatExpr((cv::MatExpr *)v26, v5);
  v7 = (unsigned int *)*((_QWORD *)&v18[1] + 1);
  if (*((_QWORD *)&v18[1] + 1))
  {
    do
    {
      v8 = __ldaxr(v7);
      v9 = v8 - 1;
    }
    while (__stlxr(v9, v7));
    if (!v9)
      cv::Mat::deallocate((cv::Mat *)v18, v6);
  }
  *(_QWORD *)&v18[1] = 0;
  memset(&v18[2], 0, 24);
  if (SDWORD1(v18[0]) >= 1)
  {
    v10 = 0;
    v11 = v19;
    do
      *(_DWORD *)&v11[4 * v10++] = 0;
    while (v10 < SDWORD1(v18[0]));
  }
  *((_QWORD *)&v18[1] + 1) = 0;
  if (v20 != (cv *)v21)
    cv::fastFree((void **)v20, v6);
  v12 = (unsigned int *)*((_QWORD *)&v22[1] + 1);
  if (*((_QWORD *)&v22[1] + 1))
  {
    do
    {
      v13 = __ldaxr(v12);
      v14 = v13 - 1;
    }
    while (__stlxr(v14, v12));
    if (!v14)
      cv::Mat::deallocate((cv::Mat *)v22, v6);
  }
  *(_QWORD *)&v22[1] = 0;
  memset(&v22[2], 0, 24);
  if (SDWORD1(v22[0]) >= 1)
  {
    v15 = 0;
    v16 = v23;
    do
      *(_DWORD *)&v16[4 * v15++] = 0;
    while (v15 < SDWORD1(v22[0]));
  }
  *((_QWORD *)&v22[1] + 1) = 0;
  if (v24 != (cv *)v25)
    cv::fastFree((void **)v24, v6);
}

void sub_219E8E318(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  void *v38;
  void *v39;

  cv::MatExpr::~MatExpr((cv::MatExpr *)&a37, a2);
  cv::Mat::~Mat((cv::Mat *)&a13, v38);
  cv::Mat::~Mat((cv::Mat *)&a25, v39);
  _Unwind_Resume(a1);
}

void cv::MatOp::matmul(cv::MatOp *this, const cv::MatExpr *a2, const cv::MatExpr *a3, cv::MatExpr *a4)
{
  _UNKNOWN **v7;
  int v8;
  double v9;
  _DWORD *v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int *v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  _BYTE *v17;
  _QWORD *v18;
  cv *v19;
  uint64_t v20;
  uint64_t v21;
  _UNKNOWN **v22;
  _DWORD *v23;
  unsigned int *v24;
  unsigned int v25;
  unsigned int *v26;
  unsigned int v27;
  unsigned int v28;
  uint64_t v29;
  _BYTE *v30;
  int v31;
  _QWORD *v32;
  cv *v33;
  uint64_t v34;
  uint64_t v35;
  void *v36;
  void *v37;
  unsigned int *v38;
  unsigned int v39;
  unsigned int v40;
  uint64_t v41;
  char *v42;
  unsigned int *v43;
  unsigned int v44;
  unsigned int v45;
  uint64_t v46;
  _BYTE *v47;
  unsigned int *v48;
  unsigned int v49;
  unsigned int v50;
  uint64_t v51;
  _BYTE *v52;
  _DWORD *v53;
  unsigned int *v54;
  unsigned int v55;
  unsigned int *v56;
  unsigned int v57;
  unsigned int v58;
  uint64_t v59;
  _BYTE *v60;
  _DWORD *v61;
  unsigned int *v62;
  unsigned int v63;
  unsigned int *v64;
  unsigned int v65;
  unsigned int v66;
  uint64_t v67;
  _BYTE *v68;
  _OWORD v69[4];
  char *v70;
  cv *v71;
  _QWORD v72[2];
  _BYTE v73[64];
  _BYTE *v74;
  cv *v75;
  _QWORD v76[2];
  _BYTE v77[64];
  _BYTE *v78;
  cv *v79;
  _QWORD v80[2];
  _OWORD v81[2];
  uint64_t v82[44];

  if (*(cv::MatOp **)a3 != this)
  {
    (*(void (**)(_QWORD, const cv::MatExpr *, const cv::MatExpr *, cv::MatExpr *))(**(_QWORD **)a3 + 184))(*(_QWORD *)a3, a2, a3, a4);
    return;
  }
  v78 = &v77[8];
  v79 = (cv *)v80;
  v80[0] = 0;
  v80[1] = 0;
  *(_DWORD *)v77 = 1124007936;
  memset(&v77[4], 0, 60);
  v74 = &v73[8];
  v75 = (cv *)v76;
  v76[0] = 0;
  v76[1] = 0;
  *(_DWORD *)v73 = 1124007936;
  memset(&v73[4], 0, 60);
  v7 = *(_UNKNOWN ***)a2;
  if (*(_UNKNOWN ***)a2 == &cv::g_MatOp_T)
  {
    v9 = *((double *)a2 + 38);
    v10 = (_DWORD *)((char *)a2 + 16);
    if (v77 == (char *)a2 + 16)
    {
      v8 = 1;
      goto LABEL_28;
    }
    v11 = (unsigned int *)*((_QWORD *)a2 + 5);
    if (v11)
    {
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 + 1, v11));
      v13 = *(unsigned int **)&v77[24];
      if (*(_QWORD *)&v77[24])
      {
        do
        {
          v14 = __ldaxr(v13);
          v15 = v14 - 1;
        }
        while (__stlxr(v15, v13));
        if (!v15)
          cv::Mat::deallocate((cv::Mat *)v77, a2);
      }
    }
    *(_QWORD *)&v77[16] = 0;
    memset(&v77[32], 0, 24);
    if (*(uint64_t *)v77 <= 0)
    {
      *(_QWORD *)&v77[24] = 0;
      *(_DWORD *)v77 = *v10;
    }
    else
    {
      v16 = 0;
      v17 = v78;
      do
        *(_DWORD *)&v17[4 * v16++] = 0;
      while (v16 < *(int *)&v77[4]);
      *(_QWORD *)&v77[24] = 0;
      *(_DWORD *)v77 = *v10;
      if (*(int *)&v77[4] > 2)
        goto LABEL_26;
    }
    if (*((int *)a2 + 5) <= 2)
    {
      *(_DWORD *)&v77[4] = *((_DWORD *)a2 + 5);
      *(_QWORD *)&v77[8] = *((_QWORD *)a2 + 3);
      v18 = (_QWORD *)*((_QWORD *)a2 + 11);
      v19 = v79;
      *(_QWORD *)v79 = *v18;
      v8 = 1;
LABEL_25:
      *((_QWORD *)v19 + 1) = v18[1];
LABEL_27:
      *(_OWORD *)&v77[16] = *((_OWORD *)a2 + 2);
      v20 = *((_QWORD *)a2 + 6);
      *(_OWORD *)&v77[40] = *(_OWORD *)((char *)a2 + 56);
      v21 = *((_QWORD *)a2 + 9);
      *(_QWORD *)&v77[32] = v20;
      *(_QWORD *)&v77[56] = v21;
      goto LABEL_28;
    }
LABEL_26:
    cv::Mat::copySize((cv::Mat *)v77, (const cv::MatExpr *)((char *)a2 + 16));
    v8 = 1;
    goto LABEL_27;
  }
  if (v7 != &cv::g_MatOp_AddEx
    || *((_QWORD *)a2 + 16) && *((double *)a2 + 39) != 0.0
    || (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqzq_f64(*((float64x2_t *)a2 + 20)), (int32x4_t)vceqzq_f64(*((float64x2_t *)a2 + 21)))))) & 1) != 0)
  {
    (*((void (**)(_UNKNOWN **, const cv::MatExpr *, _BYTE *, uint64_t))*v7 + 3))(v7, a2, v77, 0xFFFFFFFFLL);
    v8 = 0;
    v9 = 1.0;
    goto LABEL_28;
  }
  v9 = *((double *)a2 + 38);
  v53 = (_DWORD *)((char *)a2 + 16);
  if (v77 != (char *)a2 + 16)
  {
    v54 = (unsigned int *)*((_QWORD *)a2 + 5);
    if (v54)
    {
      do
        v55 = __ldaxr(v54);
      while (__stlxr(v55 + 1, v54));
      v56 = *(unsigned int **)&v77[24];
      if (*(_QWORD *)&v77[24])
      {
        do
        {
          v57 = __ldaxr(v56);
          v58 = v57 - 1;
        }
        while (__stlxr(v58, v56));
        if (!v58)
          cv::Mat::deallocate((cv::Mat *)v77, a2);
      }
    }
    *(_QWORD *)&v77[16] = 0;
    memset(&v77[32], 0, 24);
    if (*(uint64_t *)v77 <= 0)
    {
      *(_QWORD *)&v77[24] = 0;
      *(_DWORD *)v77 = *v53;
    }
    else
    {
      v59 = 0;
      v60 = v78;
      do
        *(_DWORD *)&v60[4 * v59++] = 0;
      while (v59 < *(int *)&v77[4]);
      *(_QWORD *)&v77[24] = 0;
      *(_DWORD *)v77 = *v53;
      if (*(int *)&v77[4] > 2)
        goto LABEL_107;
    }
    if (*((int *)a2 + 5) > 2)
    {
LABEL_107:
      cv::Mat::copySize((cv::Mat *)v77, (const cv::MatExpr *)((char *)a2 + 16));
      v8 = 0;
      goto LABEL_27;
    }
    v8 = 0;
    *(_DWORD *)&v77[4] = *((_DWORD *)a2 + 5);
    *(_QWORD *)&v77[8] = *((_QWORD *)a2 + 3);
    v18 = (_QWORD *)*((_QWORD *)a2 + 11);
    v19 = v79;
    *(_QWORD *)v79 = *v18;
    goto LABEL_25;
  }
  v8 = 0;
LABEL_28:
  v22 = *(_UNKNOWN ***)a3;
  if (*(_UNKNOWN ***)a3 == &cv::g_MatOp_T)
  {
    v8 |= 2u;
    v9 = v9 * *((double *)a3 + 38);
    v23 = (_DWORD *)((char *)a3 + 16);
    if (v73 == (char *)a3 + 16)
      goto LABEL_51;
    v24 = (unsigned int *)*((_QWORD *)a3 + 5);
    if (v24)
    {
      do
        v25 = __ldaxr(v24);
      while (__stlxr(v25 + 1, v24));
    }
    v26 = *(unsigned int **)&v73[24];
    if (*(_QWORD *)&v73[24])
    {
      do
      {
        v27 = __ldaxr(v26);
        v28 = v27 - 1;
      }
      while (__stlxr(v28, v26));
      if (!v28)
        cv::Mat::deallocate((cv::Mat *)v73, a2);
    }
    *(_QWORD *)&v73[16] = 0;
    memset(&v73[32], 0, 24);
    if (*(uint64_t *)v73 <= 0)
    {
      *(_QWORD *)&v73[24] = 0;
      *(_DWORD *)v73 = *v23;
    }
    else
    {
      v29 = 0;
      v30 = v74;
      do
        *(_DWORD *)&v30[4 * v29++] = 0;
      while (v29 < *(int *)&v73[4]);
      *(_QWORD *)&v73[24] = 0;
      *(_DWORD *)v73 = *v23;
      if (*(int *)&v73[4] > 2)
        goto LABEL_49;
    }
    v31 = *((_DWORD *)a3 + 5);
    if (v31 > 2)
      goto LABEL_49;
    goto LABEL_48;
  }
  if (v22 != &cv::g_MatOp_AddEx
    || *((_QWORD *)a3 + 16) && *((double *)a3 + 39) != 0.0
    || (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqzq_f64(*((float64x2_t *)a3 + 20)), (int32x4_t)vceqzq_f64(*((float64x2_t *)a3 + 21)))))) & 1) != 0)
  {
    (*((void (**)(_UNKNOWN **, const cv::MatExpr *, _BYTE *, uint64_t))*v22 + 3))(v22, a3, v73, 0xFFFFFFFFLL);
    goto LABEL_51;
  }
  v9 = v9 * *((double *)a3 + 38);
  v61 = (_DWORD *)((char *)a3 + 16);
  if (v73 != (char *)a3 + 16)
  {
    v62 = (unsigned int *)*((_QWORD *)a3 + 5);
    if (v62)
    {
      do
        v63 = __ldaxr(v62);
      while (__stlxr(v63 + 1, v62));
    }
    v64 = *(unsigned int **)&v73[24];
    if (*(_QWORD *)&v73[24])
    {
      do
      {
        v65 = __ldaxr(v64);
        v66 = v65 - 1;
      }
      while (__stlxr(v66, v64));
      if (!v66)
        cv::Mat::deallocate((cv::Mat *)v73, a2);
    }
    *(_QWORD *)&v73[16] = 0;
    memset(&v73[32], 0, 24);
    if (*(uint64_t *)v73 <= 0)
    {
      *(_QWORD *)&v73[24] = 0;
      *(_DWORD *)v73 = *v61;
    }
    else
    {
      v67 = 0;
      v68 = v74;
      do
        *(_DWORD *)&v68[4 * v67++] = 0;
      while (v67 < *(int *)&v73[4]);
      *(_QWORD *)&v73[24] = 0;
      *(_DWORD *)v73 = *v61;
      if (*(int *)&v73[4] > 2)
        goto LABEL_49;
    }
    v31 = *((_DWORD *)a3 + 5);
    if (v31 > 2)
    {
LABEL_49:
      cv::Mat::copySize((cv::Mat *)v73, (const cv::MatExpr *)((char *)a3 + 16));
      goto LABEL_50;
    }
LABEL_48:
    *(_DWORD *)&v73[4] = v31;
    *(_QWORD *)&v73[8] = *((_QWORD *)a3 + 3);
    v32 = (_QWORD *)*((_QWORD *)a3 + 11);
    v33 = v75;
    *(_QWORD *)v75 = *v32;
    *((_QWORD *)v33 + 1) = v32[1];
LABEL_50:
    *(_OWORD *)&v73[16] = *((_OWORD *)a3 + 2);
    v34 = *((_QWORD *)a3 + 6);
    *(_OWORD *)&v73[40] = *(_OWORD *)((char *)a3 + 56);
    v35 = *((_QWORD *)a3 + 9);
    *(_QWORD *)&v73[32] = v34;
    *(_QWORD *)&v73[56] = v35;
  }
LABEL_51:
  v70 = (char *)v69 + 8;
  v71 = (cv *)v72;
  v72[0] = 0;
  v72[1] = 0;
  LODWORD(v69[0]) = 1124007936;
  memset((char *)v69 + 4, 0, 48);
  v69[3] = 0u;
  memset(v81, 0, sizeof(v81));
  cv::MatExpr::MatExpr((uint64_t)v82, (uint64_t)&cv::g_MatOp_GEMM, v8, (cv::Mat *)v77, (cv::Mat *)v73, (cv::Mat *)v69, (uint64_t)v81, v9, 1.0);
  cv::MatExpr::operator=((uint64_t)a4, v82);
  cv::MatExpr::~MatExpr((cv::MatExpr *)v82, v36);
  v38 = (unsigned int *)*((_QWORD *)&v69[1] + 1);
  if (*((_QWORD *)&v69[1] + 1))
  {
    do
    {
      v39 = __ldaxr(v38);
      v40 = v39 - 1;
    }
    while (__stlxr(v40, v38));
    if (!v40)
      cv::Mat::deallocate((cv::Mat *)v69, v37);
  }
  *(_QWORD *)&v69[1] = 0;
  memset(&v69[2], 0, 24);
  if (SDWORD1(v69[0]) >= 1)
  {
    v41 = 0;
    v42 = v70;
    do
      *(_DWORD *)&v42[4 * v41++] = 0;
    while (v41 < SDWORD1(v69[0]));
  }
  *((_QWORD *)&v69[1] + 1) = 0;
  if (v71 != (cv *)v72)
    cv::fastFree((void **)v71, v37);
  v43 = *(unsigned int **)&v73[24];
  if (*(_QWORD *)&v73[24])
  {
    do
    {
      v44 = __ldaxr(v43);
      v45 = v44 - 1;
    }
    while (__stlxr(v45, v43));
    if (!v45)
      cv::Mat::deallocate((cv::Mat *)v73, v37);
  }
  *(_QWORD *)&v73[16] = 0;
  memset(&v73[32], 0, 24);
  if (*(int *)&v73[4] >= 1)
  {
    v46 = 0;
    v47 = v74;
    do
      *(_DWORD *)&v47[4 * v46++] = 0;
    while (v46 < *(int *)&v73[4]);
  }
  *(_QWORD *)&v73[24] = 0;
  if (v75 != (cv *)v76)
    cv::fastFree((void **)v75, v37);
  v48 = *(unsigned int **)&v77[24];
  if (*(_QWORD *)&v77[24])
  {
    do
    {
      v49 = __ldaxr(v48);
      v50 = v49 - 1;
    }
    while (__stlxr(v50, v48));
    if (!v50)
      cv::Mat::deallocate((cv::Mat *)v77, v37);
  }
  *(_QWORD *)&v77[16] = 0;
  memset(&v77[32], 0, 24);
  if (*(int *)&v77[4] >= 1)
  {
    v51 = 0;
    v52 = v78;
    do
      *(_DWORD *)&v52[4 * v51++] = 0;
    while (v51 < *(int *)&v77[4]);
  }
  *(_QWORD *)&v77[24] = 0;
  if (v79 != (cv *)v80)
    cv::fastFree((void **)v79, v37);
}

void sub_219E8EAC4(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49)
{
  void *v50;
  void *v51;
  void *v52;

  cv::MatExpr::~MatExpr((cv::MatExpr *)&a49, a2);
  cv::Mat::~Mat((cv::Mat *)&a9, v50);
  cv::Mat::~Mat((cv::Mat *)&a21, v51);
  cv::Mat::~Mat((cv::Mat *)&a33, v52);
  _Unwind_Resume(a1);
}

void cv::MatOp::invert(cv::MatOp *this, const cv::MatExpr *a2, cv::MatExpr *a3, cv::MatExpr *a4)
{
  const cv::Mat *v6;
  void *v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD v13[8];
  _QWORD *v14;
  cv *v15;
  _QWORD v16[2];

  v14 = &v13[1];
  v15 = (cv *)v16;
  v16[0] = 0;
  v16[1] = 0;
  LODWORD(v13[0]) = 1124007936;
  memset((char *)v13 + 4, 0, 32);
  memset((char *)&v13[4] + 4, 0, 28);
  (*(void (**)(_QWORD, const cv::MatExpr *, _QWORD *, uint64_t))(**(_QWORD **)a2 + 24))(*(_QWORD *)a2, a2, v13, 0xFFFFFFFFLL);
  cv::MatOp_Invert::makeExpr(a4, a3, (cv::Mat *)v13, v6);
  v8 = (unsigned int *)v13[3];
  if (v13[3])
  {
    do
    {
      v9 = __ldaxr(v8);
      v10 = v9 - 1;
    }
    while (__stlxr(v10, v8));
    if (!v10)
      cv::Mat::deallocate((cv::Mat *)v13, v7);
  }
  v13[2] = 0;
  memset(&v13[4], 0, 24);
  if (SHIDWORD(v13[0]) >= 1)
  {
    v11 = 0;
    v12 = v14;
    do
      *((_DWORD *)v12 + v11++) = 0;
    while (v11 < SHIDWORD(v13[0]));
  }
  v13[3] = 0;
  if (v15 != (cv *)v16)
    cv::fastFree((void **)v15, v7);
}

void sub_219E8EBF8(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  cv::Mat::~Mat((cv::Mat *)&a9, a2);
  _Unwind_Resume(a1);
}

void cv::MatOp_Invert::makeExpr(cv::MatOp_Invert *this, cv::MatExpr *a2, cv::Mat *a3, const cv::Mat *a4)
{
  void *v5;
  void *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  char *v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  char *v16;
  _OWORD v17[2];
  _OWORD v18[4];
  char *v19;
  cv *v20;
  _QWORD v21[2];
  _OWORD v22[4];
  char *v23;
  cv *v24;
  _QWORD v25[2];
  uint64_t v26[44];

  v23 = (char *)v22 + 8;
  v24 = (cv *)v25;
  v25[0] = 0;
  v25[1] = 0;
  LODWORD(v22[0]) = 1124007936;
  memset((char *)v22 + 4, 0, 48);
  v22[3] = 0u;
  v19 = (char *)v18 + 8;
  v20 = (cv *)v21;
  v21[0] = 0;
  v21[1] = 0;
  LODWORD(v18[0]) = 1124007936;
  memset((char *)v18 + 4, 0, 48);
  v18[3] = 0u;
  memset(v17, 0, sizeof(v17));
  cv::MatExpr::MatExpr((uint64_t)v26, (uint64_t)&cv::g_MatOp_Invert, (int)a2, a3, (cv::Mat *)v22, (cv::Mat *)v18, (uint64_t)v17, 1.0, 0.0);
  cv::MatExpr::operator=((uint64_t)this, v26);
  cv::MatExpr::~MatExpr((cv::MatExpr *)v26, v5);
  v7 = (unsigned int *)*((_QWORD *)&v18[1] + 1);
  if (*((_QWORD *)&v18[1] + 1))
  {
    do
    {
      v8 = __ldaxr(v7);
      v9 = v8 - 1;
    }
    while (__stlxr(v9, v7));
    if (!v9)
      cv::Mat::deallocate((cv::Mat *)v18, v6);
  }
  *(_QWORD *)&v18[1] = 0;
  memset(&v18[2], 0, 24);
  if (SDWORD1(v18[0]) >= 1)
  {
    v10 = 0;
    v11 = v19;
    do
      *(_DWORD *)&v11[4 * v10++] = 0;
    while (v10 < SDWORD1(v18[0]));
  }
  *((_QWORD *)&v18[1] + 1) = 0;
  if (v20 != (cv *)v21)
    cv::fastFree((void **)v20, v6);
  v12 = (unsigned int *)*((_QWORD *)&v22[1] + 1);
  if (*((_QWORD *)&v22[1] + 1))
  {
    do
    {
      v13 = __ldaxr(v12);
      v14 = v13 - 1;
    }
    while (__stlxr(v14, v12));
    if (!v14)
      cv::Mat::deallocate((cv::Mat *)v22, v6);
  }
  *(_QWORD *)&v22[1] = 0;
  memset(&v22[2], 0, 24);
  if (SDWORD1(v22[0]) >= 1)
  {
    v15 = 0;
    v16 = v23;
    do
      *(_DWORD *)&v16[4 * v15++] = 0;
    while (v15 < SDWORD1(v22[0]));
  }
  *((_QWORD *)&v22[1] + 1) = 0;
  if (v24 != (cv *)v25)
    cv::fastFree((void **)v24, v6);
}

void sub_219E8EDB4(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  void *v38;
  void *v39;

  cv::MatExpr::~MatExpr((cv::MatExpr *)&a37, a2);
  cv::Mat::~Mat((cv::Mat *)&a13, v38);
  cv::Mat::~Mat((cv::Mat *)&a25, v39);
  _Unwind_Resume(a1);
}

int32x2_t cv::MatOp::size@<D0>(uint64_t a1@<X1>, int32x2_t *a2@<X8>)
{
  uint64_t v2;
  uint64_t v3;
  int *v4;
  uint64_t v5;
  int32x2_t **v6;
  uint64_t v7;
  uint64_t v8;
  int *v9;
  uint64_t v10;
  int32x2_t result;

  if (!*(_QWORD *)(a1 + 32))
    goto LABEL_13;
  v2 = *(unsigned int *)(a1 + 20);
  if ((int)v2 >= 3)
  {
    v4 = *(int **)(a1 + 80);
    v3 = 1;
    do
    {
      v5 = *v4++;
      v3 *= v5;
      --v2;
    }
    while (v2);
  }
  else
  {
    v3 = *(int *)(a1 + 28) * (uint64_t)*(int *)(a1 + 24);
  }
  if (v3)
  {
    v6 = (int32x2_t **)(a1 + 80);
  }
  else
  {
    if (!*(_QWORD *)(a1 + 128))
      goto LABEL_15;
LABEL_13:
    v7 = *(unsigned int *)(a1 + 116);
    if ((int)v7 >= 3)
    {
      v9 = *(int **)(a1 + 176);
      v8 = 1;
      do
      {
        v10 = *v9++;
        v8 *= v10;
        --v7;
      }
      while (v7);
    }
    else
    {
      v8 = *(int *)(a1 + 124) * (uint64_t)*(int *)(a1 + 120);
    }
    if (v8)
      v6 = (int32x2_t **)(a1 + 272);
    else
LABEL_15:
      v6 = (int32x2_t **)(a1 + 176);
  }
  result = vrev64_s32(**v6);
  *a2 = result;
  return result;
}

uint64_t cv::MatOp::type(uint64_t a1, uint64_t a2)
{
  _DWORD *v2;
  uint64_t v3;
  uint64_t v4;
  int *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int *v9;
  uint64_t v10;

  if (!*(_QWORD *)(a2 + 32))
    goto LABEL_7;
  v2 = (_DWORD *)(a2 + 16);
  v3 = *(unsigned int *)(a2 + 20);
  if ((int)v3 >= 3)
  {
    v5 = *(int **)(a2 + 80);
    v4 = 1;
    do
    {
      v6 = *v5++;
      v4 *= v6;
      --v3;
    }
    while (v3);
  }
  else
  {
    v4 = *(int *)(a2 + 28) * (uint64_t)*(int *)(a2 + 24);
  }
  if (!v4)
  {
LABEL_7:
    v2 = (_DWORD *)(a2 + 112);
    if (*(_QWORD *)(a2 + 128))
    {
      v7 = *(unsigned int *)(a2 + 116);
      if ((int)v7 >= 3)
      {
        v9 = *(int **)(a2 + 176);
        v8 = 1;
        do
        {
          v10 = *v9++;
          v8 *= v10;
          --v7;
        }
        while (v7);
      }
      else
      {
        v8 = *(int *)(a2 + 124) * (uint64_t)*(int *)(a2 + 120);
      }
      if (v8)
        v2 = (_DWORD *)(a2 + 208);
    }
  }
  return *v2 & 0xFFF;
}

void cv::MatOp_Bin::makeExpr(uint64_t a1, int a2, cv::Mat *a3, uint64_t a4)
{
  void *v5;
  void *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  char *v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  char *v16;
  _OWORD v17[4];
  char *v18;
  cv *v19;
  _QWORD v20[2];
  _OWORD v21[4];
  char *v22;
  cv *v23;
  _QWORD v24[2];
  uint64_t v25[44];

  v22 = (char *)v21 + 8;
  v23 = (cv *)v24;
  v24[0] = 0;
  v24[1] = 0;
  LODWORD(v21[0]) = 1124007936;
  memset((char *)v21 + 4, 0, 48);
  v21[3] = 0u;
  v18 = (char *)v17 + 8;
  v19 = (cv *)v20;
  v20[0] = 0;
  v20[1] = 0;
  LODWORD(v17[0]) = 1124007936;
  memset((char *)v17 + 4, 0, 48);
  v17[3] = 0u;
  cv::MatExpr::MatExpr((uint64_t)v25, (uint64_t)&cv::g_MatOp_Bin, a2, a3, (cv::Mat *)v21, (cv::Mat *)v17, a4, 1.0, 0.0);
  cv::MatExpr::operator=(a1, v25);
  cv::MatExpr::~MatExpr((cv::MatExpr *)v25, v5);
  v7 = (unsigned int *)*((_QWORD *)&v17[1] + 1);
  if (*((_QWORD *)&v17[1] + 1))
  {
    do
    {
      v8 = __ldaxr(v7);
      v9 = v8 - 1;
    }
    while (__stlxr(v9, v7));
    if (!v9)
      cv::Mat::deallocate((cv::Mat *)v17, v6);
  }
  *(_QWORD *)&v17[1] = 0;
  memset(&v17[2], 0, 24);
  if (SDWORD1(v17[0]) >= 1)
  {
    v10 = 0;
    v11 = v18;
    do
      *(_DWORD *)&v11[4 * v10++] = 0;
    while (v10 < SDWORD1(v17[0]));
  }
  *((_QWORD *)&v17[1] + 1) = 0;
  if (v19 != (cv *)v20)
    cv::fastFree((void **)v19, v6);
  v12 = (unsigned int *)*((_QWORD *)&v21[1] + 1);
  if (*((_QWORD *)&v21[1] + 1))
  {
    do
    {
      v13 = __ldaxr(v12);
      v14 = v13 - 1;
    }
    while (__stlxr(v14, v12));
    if (!v14)
      cv::Mat::deallocate((cv::Mat *)v21, v6);
  }
  *(_QWORD *)&v21[1] = 0;
  memset(&v21[2], 0, 24);
  if (SDWORD1(v21[0]) >= 1)
  {
    v15 = 0;
    v16 = v22;
    do
      *(_DWORD *)&v16[4 * v15++] = 0;
    while (v15 < SDWORD1(v21[0]));
  }
  *((_QWORD *)&v21[1] + 1) = 0;
  if (v23 != (cv *)v24)
    cv::fastFree((void **)v23, v6);
}

void sub_219E8F0B8(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  void *v34;
  void *v35;

  cv::MatExpr::~MatExpr((cv::MatExpr *)&a33, a2);
  cv::Mat::~Mat((cv::Mat *)&a9, v34);
  cv::Mat::~Mat((cv::Mat *)&a21, v35);
  _Unwind_Resume(a1);
}

void cv::MatExpr::size(cv::MatExpr *this@<X0>, int32x2_t *a2@<X8>)
{
  uint64_t *v4;
  int32x2_t v6;
  __int32 v7;
  __int32 v8;

  v4 = *(uint64_t **)this;
  if (*(_UNKNOWN ***)this == &cv::g_MatOp_T || v4 == (uint64_t *)&cv::g_MatOp_Invert)
  {
    v6 = *(int32x2_t *)((char *)this + 24);
LABEL_7:
    *a2 = v6;
    return;
  }
  if (v4 == (uint64_t *)&cv::g_MatOp_GEMM)
  {
    v7 = *((_DWORD *)this + 31);
    v8 = *((_DWORD *)this + 6);
LABEL_15:
    a2->i32[0] = v7;
    a2->i32[1] = v8;
    return;
  }
  if (v4 == (uint64_t *)&cv::g_MatOp_Solve)
  {
    v7 = *((_DWORD *)this + 31);
    v8 = *((_DWORD *)this + 7);
    goto LABEL_15;
  }
  cv::getGlobalMatOpInitializer(this);
  if (v4 == &cv::getGlobalMatOpInitializer(void)::initializer)
  {
    v6 = vrev64_s32(**((int32x2_t **)this + 10));
    goto LABEL_7;
  }
  if (*(_QWORD *)this)
    (*(void (**)(_QWORD, cv::MatExpr *))(**(_QWORD **)this + 200))(*(_QWORD *)this, this);
  else
    *a2 = 0;
}

uint64_t cv::MatExpr::type(uint64_t **this)
{
  uint64_t *v2;
  uint64_t *v3;

  v2 = *this;
  cv::getGlobalMatOpInitializer((cv *)this);
  if (v2 == &cv::getGlobalMatOpInitializer(void)::initializer)
    return (_DWORD)this[2] & 0xFFF;
  v3 = *this;
  if (*this == (uint64_t *)&cv::g_MatOp_Cmp)
    return 0;
  if (v3)
    return (*(uint64_t (**)(uint64_t *, uint64_t **))(*v3 + 208))(v3, this);
  return 0xFFFFFFFFLL;
}

__n128 cv::MatOp_Identity::assign(cv::MatOp_Identity *this, __n128 *a2, __n128 *a3, int a4)
{
  unsigned __int32 v7;
  __n128 *v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  const cv::Exception *v17;
  __n128 result;
  int v19;
  _QWORD *v20;
  _QWORD *v21;
  void *__p[2];
  void *v23[2];
  void *v24[2];
  _BYTE v25[120];

  if (a4 == -1 || (v7 = a2[1].n128_u32[0], (v7 & 0xFFF) == a4))
  {
    v8 = a2 + 1;
    if (&a2[1] == a3)
      return result;
    v9 = (unsigned int *)a2[2].n128_u64[1];
    if (v9)
    {
      do
        v10 = __ldaxr(v9);
      while (__stlxr(v10 + 1, v9));
    }
    v11 = (unsigned int *)a3[1].n128_u64[1];
    if (v11)
    {
      do
      {
        v12 = __ldaxr(v11);
        v13 = v12 - 1;
      }
      while (__stlxr(v13, v11));
      if (!v13)
        cv::Mat::deallocate((cv::Mat *)a3, a2);
    }
    a3[1].n128_u64[0] = 0;
    a3[2].n128_u64[1] = 0;
    a3[3].n128_u64[0] = 0;
    a3[2].n128_u64[0] = 0;
    if (a3->n128_i32[1] <= 0)
    {
      a3[1].n128_u64[1] = 0;
      a3->n128_u32[0] = v8->n128_u32[0];
    }
    else
    {
      v14 = 0;
      v15 = a3[4].n128_u64[0];
      do
      {
        *(_DWORD *)(v15 + 4 * v14++) = 0;
        v16 = a3->n128_i32[1];
      }
      while (v14 < v16);
      a3[1].n128_u64[1] = 0;
      a3->n128_u32[0] = v8->n128_u32[0];
      if ((int)v16 > 2)
        goto LABEL_21;
    }
    v19 = a2[1].n128_i32[1];
    if (v19 <= 2)
    {
      a3->n128_u32[1] = v19;
      a3->n128_u64[1] = a2[1].n128_u64[1];
      v20 = (_QWORD *)a2[5].n128_u64[1];
      v21 = (_QWORD *)a3[4].n128_u64[1];
      *v21 = *v20;
      v21[1] = v20[1];
LABEL_22:
      a3[2] = a2[3];
      a3[3].n128_u64[0] = a2[4].n128_u64[0];
      result = a2[2];
      a3[1] = result;
      a3[3].n128_u64[1] = a2[4].n128_u64[1];
      return result;
    }
LABEL_21:
    cv::Mat::copySize((cv::Mat *)a3, (const cv::Mat *)&a2[1]);
    goto LABEL_22;
  }
  if ((((unsigned __int16)v7 ^ (unsigned __int16)a4) & 0xFF8) != 0)
  {
    std::string::basic_string[abi:ne180100]<0>(v24, "CV_MAT_CN(_type) == e.a.channels()");
    std::string::basic_string[abi:ne180100]<0>(v23, "assign");
    std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matop.cpp");
    cv::Exception::Exception(v25, 4294967081, v24, v23, __p, 1195);
    cv::error((cv *)v25, v17);
  }
  cv::_OutputArray::_OutputArray((uint64_t)v25, (cv::Mat *)a3);
  cv::Mat::convertTo((cv::Mat *)&a2[1], (const cv::_OutputArray *)v25, a4, 1.0, 0.0);
  return result;
}

void sub_219E8F450(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  cv::Exception::~Exception((cv::Exception *)&a27);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

void cv::MatOp_AddEx::assign(cv::MatOp_AddEx *this, const cv::MatExpr *a2, cv::Mat *a3, int a4)
{
  cv::Mat *v7;
  char *v8;
  double v9;
  double v10;
  double v11;
  BOOL v14;
  double v15;
  double v16;
  double v17;
  void *v18;
  double v19;
  double v20;
  double v21;
  cv *v22;
  uint64_t (***v23)(cv::_InputArray *__hidden, int);
  cv *v24;
  uint64_t (***v25)(cv::_InputArray *__hidden, int);
  cv *v26;
  uint64_t (***v27)(cv::_InputArray *__hidden, int);
  cv *v28;
  uint64_t (***v29)(cv::_InputArray *__hidden, int);
  cv *v30;
  uint64_t (***v31)(cv::_InputArray *__hidden, int);
  double v32;
  double v33;
  cv *v34;
  uint64_t (***v35)(cv::_InputArray *__hidden, int);
  double v36;
  const cv::_OutputArray *v37;
  double v38;
  const cv::_OutputArray *v39;
  cv *v40;
  uint64_t (***v41)(cv::_InputArray *__hidden, int);
  unsigned int *v42;
  unsigned int v43;
  unsigned int v44;
  uint64_t v45;
  char *v46;
  _BYTE v47[32];
  uint64_t (**v48)(cv::_InputArray *__hidden, int);
  int v49;
  char *v50;
  uint64_t v51;
  uint64_t (**v52)(cv::_InputArray *__hidden, int);
  int v53;
  char *v54;
  uint64_t v55;
  _OWORD v56[4];
  char *v57;
  cv *v58;
  _QWORD v59[2];

  v57 = (char *)v56 + 8;
  v58 = (cv *)v59;
  v59[0] = 0;
  v59[1] = 0;
  LODWORD(v56[0]) = 1124007936;
  memset((char *)v56 + 4, 0, 48);
  v56[3] = 0u;
  if (a4 == -1 || (*((_DWORD *)a2 + 4) & 0xFFF) == a4)
    v7 = a3;
  else
    v7 = (cv::Mat *)v56;
  v8 = (char *)a2 + 320;
  if (*((_QWORD *)a2 + 16))
  {
    v9 = *((double *)a2 + 41);
    v11 = *((double *)a2 + 42);
    v10 = *((double *)a2 + 43);
    v14 = v10 == 0.0 && v11 == 0.0 && v9 == 0.0 && *((double *)a2 + 40) == 0.0;
    if (!v14 && v9 == 0.0 && v11 == 0.0 && v10 == 0.0)
    {
      cv::_InputArray::_InputArray((uint64_t)&v52, (const cv::MatExpr *)((char *)a2 + 16));
      v15 = *((double *)a2 + 38);
      cv::_InputArray::_InputArray((uint64_t)&v48, (const cv::MatExpr *)((char *)a2 + 112));
      v16 = *((double *)a2 + 39);
      v17 = *((double *)a2 + 40);
      cv::_OutputArray::_OutputArray((uint64_t)v47, v7);
      cv::addWeighted((cv *)&v52, (const cv::_InputArray *)&v48, v15, (const cv::_InputArray *)v47, v16, v17, (const cv::_OutputArray *)0xFFFFFFFFLL);
    }
    else
    {
      v21 = *((double *)a2 + 38);
      v20 = *((double *)a2 + 39);
      if (v21 == 1.0)
      {
        if (v20 == 1.0)
        {
          cv::_InputArray::_InputArray((uint64_t)&v52, (const cv::MatExpr *)((char *)a2 + 16));
          cv::_InputArray::_InputArray((uint64_t)&v48, (const cv::MatExpr *)((char *)a2 + 112));
          v22 = (cv *)cv::_OutputArray::_OutputArray((uint64_t)v47, v7);
          v23 = cv::noArray(v22);
          cv::add((uint64_t)&v52, (uint64_t)&v48, (const cv::_InputArray *)v47, (const cv::_OutputArray *)v23, (const cv::_InputArray *)0xFFFFFFFFLL);
        }
        else if (v20 == -1.0)
        {
          cv::_InputArray::_InputArray((uint64_t)&v52, (const cv::MatExpr *)((char *)a2 + 16));
          cv::_InputArray::_InputArray((uint64_t)&v48, (const cv::MatExpr *)((char *)a2 + 112));
          v30 = (cv *)cv::_OutputArray::_OutputArray((uint64_t)v47, v7);
          v31 = cv::noArray(v30);
          cv::subtract((uint64_t)&v52, (uint64_t)&v48, (const cv::_InputArray *)v47, (const cv::_OutputArray *)v31, (const cv::_InputArray *)0xFFFFFFFFLL);
        }
        else
        {
          cv::_InputArray::_InputArray((uint64_t)&v52, (const cv::MatExpr *)((char *)a2 + 112));
          v38 = *((double *)a2 + 39);
          cv::_InputArray::_InputArray((uint64_t)&v48, (const cv::MatExpr *)((char *)a2 + 16));
          cv::_OutputArray::_OutputArray((uint64_t)v47, v7);
          cv::scaleAdd((cv *)&v52, (const cv::_InputArray *)&v48, v38, (const cv::_InputArray *)v47, v39);
        }
      }
      else if (v20 == 1.0)
      {
        if (v21 == -1.0)
        {
          cv::_InputArray::_InputArray((uint64_t)&v52, (const cv::MatExpr *)((char *)a2 + 112));
          cv::_InputArray::_InputArray((uint64_t)&v48, (const cv::MatExpr *)((char *)a2 + 16));
          v26 = (cv *)cv::_OutputArray::_OutputArray((uint64_t)v47, v7);
          v27 = cv::noArray(v26);
          cv::subtract((uint64_t)&v52, (uint64_t)&v48, (const cv::_InputArray *)v47, (const cv::_OutputArray *)v27, (const cv::_InputArray *)0xFFFFFFFFLL);
        }
        else
        {
          cv::_InputArray::_InputArray((uint64_t)&v52, (const cv::MatExpr *)((char *)a2 + 16));
          v36 = *((double *)a2 + 38);
          cv::_InputArray::_InputArray((uint64_t)&v48, (const cv::MatExpr *)((char *)a2 + 112));
          cv::_OutputArray::_OutputArray((uint64_t)v47, v7);
          cv::scaleAdd((cv *)&v52, (const cv::_InputArray *)&v48, v36, (const cv::_InputArray *)v47, v37);
        }
      }
      else
      {
        cv::_InputArray::_InputArray((uint64_t)&v52, (const cv::MatExpr *)((char *)a2 + 16));
        v32 = *((double *)a2 + 38);
        cv::_InputArray::_InputArray((uint64_t)&v48, (const cv::MatExpr *)((char *)a2 + 112));
        v33 = *((double *)a2 + 39);
        cv::_OutputArray::_OutputArray((uint64_t)v47, v7);
        cv::addWeighted((cv *)&v52, (const cv::_InputArray *)&v48, v32, (const cv::_InputArray *)v47, v33, 0.0, (const cv::_OutputArray *)0xFFFFFFFFLL);
      }
      if (*((double *)a2 + 41) != 0.0 || *((double *)a2 + 42) != 0.0 || *((double *)a2 + 43) != 0.0)
      {
        cv::_InputArray::_InputArray((uint64_t)&v52, v7);
        v48 = &off_24DBF0280;
        v49 = -1073610746;
        v50 = (char *)a2 + 320;
        v51 = 0x400000001;
        v40 = (cv *)cv::_OutputArray::_OutputArray((uint64_t)v47, v7);
        v41 = cv::noArray(v40);
        cv::add((uint64_t)&v52, (uint64_t)&v48, (const cv::_InputArray *)v47, (const cv::_OutputArray *)v41, (const cv::_InputArray *)0xFFFFFFFFLL);
      }
    }
  }
  else
  {
    if (*((double *)a2 + 41) == 0.0 && *((double *)a2 + 42) == 0.0 && *((double *)a2 + 43) == 0.0)
    {
      if (*((_QWORD *)v7 + 2) != *((_QWORD *)a3 + 2) || (v19 = *((double *)a2 + 38), fabs(v19) != 1.0))
      {
        cv::_OutputArray::_OutputArray((uint64_t)&v52, a3);
        cv::Mat::convertTo((const cv::MatExpr *)((char *)a2 + 16), (const cv::_OutputArray *)&v52, a4, *((double *)a2 + 38), *((double *)a2 + 40));
        goto LABEL_49;
      }
    }
    else
    {
      v19 = *((double *)a2 + 38);
    }
    if (v19 == 1.0)
    {
      cv::_InputArray::_InputArray((uint64_t)&v52, (const cv::MatExpr *)((char *)a2 + 16));
      v48 = &off_24DBF0280;
      v49 = -1073610746;
      v50 = (char *)a2 + 320;
      v51 = 0x400000001;
      v24 = (cv *)cv::_OutputArray::_OutputArray((uint64_t)v47, v7);
      v25 = cv::noArray(v24);
      cv::add((uint64_t)&v52, (uint64_t)&v48, (const cv::_InputArray *)v47, (const cv::_OutputArray *)v25, (const cv::_InputArray *)0xFFFFFFFFLL);
    }
    else if (v19 == -1.0)
    {
      v52 = &off_24DBF0280;
      v53 = -1073610746;
      v54 = (char *)a2 + 320;
      v55 = 0x400000001;
      cv::_InputArray::_InputArray((uint64_t)&v48, (const cv::MatExpr *)((char *)a2 + 16));
      v28 = (cv *)cv::_OutputArray::_OutputArray((uint64_t)v47, v7);
      v29 = cv::noArray(v28);
      cv::subtract((uint64_t)&v52, (uint64_t)&v48, (const cv::_InputArray *)v47, (const cv::_OutputArray *)v29, (const cv::_InputArray *)0xFFFFFFFFLL);
    }
    else
    {
      cv::_OutputArray::_OutputArray((uint64_t)&v52, v7);
      cv::Mat::convertTo((const cv::MatExpr *)((char *)a2 + 16), (const cv::_OutputArray *)&v52, *((_DWORD *)a2 + 4) & 0xFFF, *((double *)a2 + 38), 0.0);
      cv::_InputArray::_InputArray((uint64_t)&v52, v7);
      v48 = &off_24DBF0280;
      v49 = -1073610746;
      v50 = v8;
      v51 = 0x400000001;
      v34 = (cv *)cv::_OutputArray::_OutputArray((uint64_t)v47, v7);
      v35 = cv::noArray(v34);
      cv::add((uint64_t)&v52, (uint64_t)&v48, (const cv::_InputArray *)v47, (const cv::_OutputArray *)v35, (const cv::_InputArray *)0xFFFFFFFFLL);
    }
  }
  if (*((_QWORD *)v7 + 2) != *((_QWORD *)a3 + 2))
  {
    cv::_OutputArray::_OutputArray((uint64_t)&v52, a3);
    cv::Mat::convertTo(v7, (const cv::_OutputArray *)&v52, *(_DWORD *)a3 & 0xFFF, 1.0, 0.0);
  }
LABEL_49:
  v42 = (unsigned int *)*((_QWORD *)&v56[1] + 1);
  if (*((_QWORD *)&v56[1] + 1))
  {
    do
    {
      v43 = __ldaxr(v42);
      v44 = v43 - 1;
    }
    while (__stlxr(v44, v42));
    if (!v44)
      cv::Mat::deallocate((cv::Mat *)v56, v18);
  }
  *(_QWORD *)&v56[1] = 0;
  memset(&v56[2], 0, 24);
  if (SDWORD1(v56[0]) >= 1)
  {
    v45 = 0;
    v46 = v57;
    do
      *(_DWORD *)&v46[4 * v45++] = 0;
    while (v45 < SDWORD1(v56[0]));
  }
  *((_QWORD *)&v56[1] + 1) = 0;
  if (v58 != (cv *)v59)
    cv::fastFree((void **)v58, v18);
}

void sub_219E8FAC4(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_list va;

  va_start(va, a14);
  cv::Mat::~Mat((cv::Mat *)va, a2);
  _Unwind_Resume(a1);
}

double cv::MatOp_AddEx::add(uint64_t a1, uint64_t *a2, double *a3, double *a4)
{
  double v6;
  double v7;
  double result;

  cv::MatExpr::operator=((uint64_t)a4, a2);
  v6 = a4[41];
  a4[40] = a4[40] + *a3;
  a4[41] = v6 + a3[1];
  v7 = a4[43];
  a4[42] = a4[42] + a3[2];
  result = v7 + a3[3];
  a4[43] = result;
  return result;
}

float64x2_t cv::MatOp_AddEx::subtract(uint64_t a1, float64x2_t *a2, uint64_t *a3, uint64_t a4)
{
  float64x2_t v6;
  float64x2_t result;
  float64x2_t v8;

  cv::MatExpr::operator=(a4, a3);
  v6 = *(float64x2_t *)(a4 + 320);
  *(float64x2_t *)(a4 + 304) = vnegq_f64(*(float64x2_t *)(a4 + 304));
  result = vsubq_f64(*a2, v6);
  v8 = vsubq_f64(a2[1], *(float64x2_t *)(a4 + 336));
  *(float64x2_t *)(a4 + 320) = result;
  *(float64x2_t *)(a4 + 336) = v8;
  return result;
}

float64x2_t cv::MatOp_AddEx::multiply(cv::MatOp_AddEx *this, const cv::MatExpr *a2, double a3, float64x2_t *a4)
{
  float64x2_t v5;
  float64x2_t result;

  cv::MatExpr::operator=((uint64_t)a4, (uint64_t *)a2);
  v5 = vmulq_n_f64(a4[20], a3);
  a4[19] = vmulq_n_f64(a4[19], a3);
  a4[20] = v5;
  result = vmulq_n_f64(a4[21], a3);
  a4[21] = result;
  return result;
}

void cv::MatOp_AddEx::divide(cv::MatOp_AddEx *this, double a2, float64x2_t *a3, cv::MatExpr *a4, uint64_t a5, const cv::Mat *a6)
{
  void *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  char *v11;
  _OWORD v12[4];
  char *v13;
  cv *v14;
  _QWORD v15[2];

  if (*(_UNKNOWN ***)&a3->f64[0] == &cv::g_MatOp_AddEx
    && (!*(_QWORD *)&a3[8].f64[0] || a3[19].f64[1] == 0.0)
    && (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqzq_f64(a3[20]), (int32x4_t)vceqzq_f64(a3[21]))))) & 1) == 0)
  {
    v13 = (char *)v12 + 8;
    v14 = (cv *)v15;
    v15[0] = 0;
    v15[1] = 0;
    LODWORD(v12[0]) = 1124007936;
    memset((char *)v12 + 4, 0, 48);
    v12[3] = 0u;
    cv::MatOp_Bin::makeExpr(a4, (cv::MatExpr *)0x2F, (cv::Mat *)&a3[1], (const cv::Mat *)v12, a6, a2 / a3[19].f64[0]);
    v7 = (unsigned int *)*((_QWORD *)&v12[1] + 1);
    if (*((_QWORD *)&v12[1] + 1))
    {
      do
      {
        v8 = __ldaxr(v7);
        v9 = v8 - 1;
      }
      while (__stlxr(v9, v7));
      if (!v9)
        cv::Mat::deallocate((cv::Mat *)v12, v6);
    }
    *(_QWORD *)&v12[1] = 0;
    memset(&v12[2], 0, 24);
    if (SDWORD1(v12[0]) >= 1)
    {
      v10 = 0;
      v11 = v13;
      do
        *(_DWORD *)&v11[4 * v10++] = 0;
      while (v10 < SDWORD1(v12[0]));
    }
    *((_QWORD *)&v12[1] + 1) = 0;
    if (v14 != (cv *)v15)
      cv::fastFree((void **)v14, v6);
  }
  else
  {
    cv::MatOp::divide(this, a2, (const cv::MatExpr *)a3, a4);
  }
}

void sub_219E8FD90(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  cv::Mat::~Mat((cv::Mat *)&a9, a2);
  _Unwind_Resume(a1);
}

void cv::MatOp_AddEx::transpose(cv::MatOp_AddEx *this, float64x2_t *a2, cv::MatExpr *a3)
{
  if (*(_UNKNOWN ***)&a2->f64[0] == &cv::g_MatOp_AddEx
    && (!*(_QWORD *)&a2[8].f64[0] || a2[19].f64[1] == 0.0)
    && (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqzq_f64(a2[20]), (int32x4_t)vceqzq_f64(a2[21]))))) & 1) == 0)
  {
    cv::MatOp_T::makeExpr(a3, (cv::MatExpr *)&a2[1], a3, a2[19].f64[0]);
  }
  else
  {
    cv::MatOp::transpose(this, (const cv::MatExpr *)a2, a3);
  }
}

void cv::MatOp_AddEx::abs(cv::MatOp_AddEx *this, const cv::MatExpr *a2, cv::MatExpr *a3, uint64_t a4, const cv::Mat *a5)
{
  uint64_t v5;
  double v6;
  double v7;
  double v8;
  double v9;
  float64x2_t v11;
  float64x2_t v12;
  _OWORD v13[2];

  v5 = *((_QWORD *)a2 + 16);
  v6 = *((double *)a2 + 38);
  v7 = *((double *)a2 + 39);
  if (v5 && v7 != 0.0)
    goto LABEL_3;
  if (fabs(v6) == 1.0)
  {
    v11 = vmulq_n_f64(vnegq_f64(*((float64x2_t *)a2 + 20)), v6);
    v12 = vmulq_n_f64(vnegq_f64(*((float64x2_t *)a2 + 21)), v6);
    v13[0] = v11;
    v13[1] = v12;
    cv::MatOp_Bin::makeExpr((uint64_t)a3, 97, (const cv::MatExpr *)((char *)a2 + 16), (uint64_t)v13);
    return;
  }
  if (v5)
  {
LABEL_3:
    v8 = v7 + v6;
    v9 = v7 * v6;
    if (v8 == 0.0 && v9 == -1.0)
    {
      cv::MatOp_Bin::makeExpr(a3, (cv::MatExpr *)0x61, (const cv::MatExpr *)((char *)a2 + 16), (const cv::MatExpr *)((char *)a2 + 112), a5, 1.0);
      return;
    }
  }
  cv::MatOp::abs(this, a2, a3);
}

void cv::MatOp_Bin::assign(cv::MatOp_Bin *this, const cv::MatExpr *a2, cv::Mat *a3, cv::Mat *a4)
{
  int v4;
  cv::Mat *v7;
  int v8;
  void *v9;
  uint64_t v10;
  const cv::Mat *v11;
  cv *v12;
  uint64_t (***v13)(cv::_InputArray *__hidden, int);
  const cv::_InputArray *v14;
  double v15;
  const cv::Mat *v16;
  cv *v17;
  uint64_t (***v18)(cv::_InputArray *__hidden, int);
  const cv::_InputArray *v19;
  const cv::Mat *v20;
  cv *v21;
  uint64_t (***v22)(cv::_InputArray *__hidden, int);
  const cv::_InputArray *v23;
  cv *v24;
  uint64_t (***v25)(cv::_InputArray *__hidden, int);
  const cv::_InputArray *v26;
  unsigned int *v27;
  unsigned int v28;
  unsigned int v29;
  uint64_t v30;
  char *v31;
  const cv::_OutputArray *v32;
  const cv::_OutputArray *v33;
  const cv::Exception *v34;
  void *__p[2];
  _BYTE v36[120];
  void *v37[2];
  void *v38;
  int v39;
  char *v40;
  uint64_t v41;
  _OWORD v42[4];
  char *v43;
  void **v44;
  _QWORD v45[2];

  v4 = (int)a4;
  v43 = (char *)v42 + 8;
  v44 = (void **)v45;
  v45[0] = 0;
  v45[1] = 0;
  LODWORD(v42[0]) = 1124007936;
  memset((char *)v42 + 4, 0, 48);
  v42[3] = 0u;
  if ((_DWORD)a4 == -1 || (*((_DWORD *)a2 + 4) & 0xFFF) == (_DWORD)a4)
    v7 = a3;
  else
    v7 = (cv::Mat *)v42;
  v8 = *((_DWORD *)a2 + 2);
  if (v8 == 47)
  {
    if (*((_QWORD *)a2 + 16))
    {
      cv::_InputArray::_InputArray((uint64_t)v36, (const cv::MatExpr *)((char *)a2 + 16));
      cv::_InputArray::_InputArray((uint64_t)&v38, (const cv::MatExpr *)((char *)a2 + 112));
      cv::_OutputArray::_OutputArray((uint64_t)v37, v7);
      cv::divide((cv *)v36, (const cv::_InputArray *)&v38, (const cv::_InputArray *)v37, (const cv::_OutputArray *)0xFFFFFFFFLL, *((double *)a2 + 38));
    }
    else
    {
      v15 = *((double *)a2 + 38);
      cv::_InputArray::_InputArray((uint64_t)v36, (const cv::MatExpr *)((char *)a2 + 16));
      cv::_OutputArray::_OutputArray((uint64_t)&v38, v7);
      cv::divide((cv *)v36, v15, (const cv::_InputArray *)&v38, (const cv::_OutputArray *)0xFFFFFFFFLL);
    }
  }
  else
  {
    if (v8 == 42)
    {
      cv::_InputArray::_InputArray((uint64_t)v36, (const cv::MatExpr *)((char *)a2 + 16));
      cv::_InputArray::_InputArray((uint64_t)&v38, (const cv::MatExpr *)((char *)a2 + 112));
      cv::_OutputArray::_OutputArray((uint64_t)v37, v7);
      cv::multiply((cv *)v36, (const cv::_InputArray *)&v38, (const cv::_InputArray *)v37, (const cv::_OutputArray *)0xFFFFFFFFLL, *((double *)a2 + 38));
      goto LABEL_34;
    }
    v10 = *((_QWORD *)a2 + 16);
    switch(v8)
    {
      case '|':
        v16 = (const cv::MatExpr *)((char *)a2 + 16);
        if (v10)
        {
          cv::_InputArray::_InputArray((uint64_t)v36, v16);
          cv::_InputArray::_InputArray((uint64_t)&v38, (const cv::MatExpr *)((char *)a2 + 112));
        }
        else
        {
          cv::_InputArray::_InputArray((uint64_t)v36, v16);
          v38 = &off_24DBF0280;
          v39 = -1073610746;
          v40 = (char *)a2 + 320;
          v41 = 0x400000001;
        }
        v17 = (cv *)cv::_OutputArray::_OutputArray((uint64_t)v37, v7);
        v18 = cv::noArray(v17);
        cv::bitwise_or((cv *)v36, (const cv::_InputArray *)&v38, (const cv::_InputArray *)v37, (const cv::_OutputArray *)v18, v19);
        break;
      case '^':
        v20 = (const cv::MatExpr *)((char *)a2 + 16);
        if (v10)
        {
          cv::_InputArray::_InputArray((uint64_t)v36, v20);
          cv::_InputArray::_InputArray((uint64_t)&v38, (const cv::MatExpr *)((char *)a2 + 112));
        }
        else
        {
          cv::_InputArray::_InputArray((uint64_t)v36, v20);
          v38 = &off_24DBF0280;
          v39 = -1073610746;
          v40 = (char *)a2 + 320;
          v41 = 0x400000001;
        }
        v21 = (cv *)cv::_OutputArray::_OutputArray((uint64_t)v37, v7);
        v22 = cv::noArray(v21);
        cv::bitwise_xor((cv *)v36, (const cv::_InputArray *)&v38, (const cv::_InputArray *)v37, (const cv::_OutputArray *)v22, v23);
        break;
      case '&':
        v11 = (const cv::MatExpr *)((char *)a2 + 16);
        if (v10)
        {
          cv::_InputArray::_InputArray((uint64_t)v36, v11);
          cv::_InputArray::_InputArray((uint64_t)&v38, (const cv::MatExpr *)((char *)a2 + 112));
        }
        else
        {
          cv::_InputArray::_InputArray((uint64_t)v36, v11);
          v38 = &off_24DBF0280;
          v39 = -1073610746;
          v40 = (char *)a2 + 320;
          v41 = 0x400000001;
        }
        v12 = (cv *)cv::_OutputArray::_OutputArray((uint64_t)v37, v7);
        v13 = cv::noArray(v12);
        cv::bitwise_and((cv *)v36, (const cv::_InputArray *)&v38, (const cv::_InputArray *)v37, (const cv::_OutputArray *)v13, v14);
        break;
      default:
        if (v8 == 126 && !v10)
        {
          cv::_InputArray::_InputArray((uint64_t)v36, (const cv::MatExpr *)((char *)a2 + 16));
          v24 = (cv *)cv::_OutputArray::_OutputArray((uint64_t)&v38, v7);
          v25 = cv::noArray(v24);
          cv::bitwise_not((cv *)v36, (const cv::_InputArray *)&v38, (const cv::_OutputArray *)v25, v26);
          break;
        }
        if (v8 <= 96)
        {
          if (v8 == 77)
          {
            cv::max((const cv::MatExpr *)((char *)a2 + 16), (const cv::MatExpr *)((char *)a2 + 112), v7, a4);
            break;
          }
          if (v8 == 78)
          {
            cv::max((const cv::MatExpr *)((char *)a2 + 16), v7, *((double *)a2 + 40), a3);
            break;
          }
        }
        else
        {
          switch(v8)
          {
            case 'a':
              if (v10)
              {
                cv::_InputArray::_InputArray((uint64_t)v36, (const cv::MatExpr *)((char *)a2 + 16));
                cv::_InputArray::_InputArray((uint64_t)&v38, (const cv::MatExpr *)((char *)a2 + 112));
                cv::_OutputArray::_OutputArray((uint64_t)v37, v7);
                cv::absdiff((cv *)v36, (const cv::_InputArray *)&v38, (const cv::_InputArray *)v37, v32);
                goto LABEL_34;
              }
              break;
            case 'n':
              cv::min((const cv::MatExpr *)((char *)a2 + 16), v7, *((double *)a2 + 40), a3);
              goto LABEL_34;
            case 'm':
              cv::min((const cv::MatExpr *)((char *)a2 + 16), (const cv::MatExpr *)((char *)a2 + 112), v7, a4);
              goto LABEL_34;
          }
        }
        if (v8 != 97 || v10)
        {
          std::string::basic_string[abi:ne180100]<0>(&v38, "Unknown operation");
          std::string::basic_string[abi:ne180100]<0>(v37, "assign");
          std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matop.cpp");
          cv::Exception::Exception(v36, 4294967294, &v38, v37, __p, 1353);
          cv::error((cv *)v36, v34);
        }
        cv::_InputArray::_InputArray((uint64_t)v36, (const cv::MatExpr *)((char *)a2 + 16));
        v38 = &off_24DBF0280;
        v39 = -1073610746;
        v40 = (char *)a2 + 320;
        v41 = 0x400000001;
        cv::_OutputArray::_OutputArray((uint64_t)v37, v7);
        cv::absdiff((cv *)v36, (const cv::_InputArray *)&v38, (const cv::_InputArray *)v37, v33);
        break;
    }
  }
LABEL_34:
  if (*((_QWORD *)v7 + 2) != *((_QWORD *)a3 + 2))
  {
    cv::_OutputArray::_OutputArray((uint64_t)v36, a3);
    cv::Mat::convertTo(v7, (const cv::_OutputArray *)v36, v4, 1.0, 0.0);
  }
  v27 = (unsigned int *)*((_QWORD *)&v42[1] + 1);
  if (*((_QWORD *)&v42[1] + 1))
  {
    do
    {
      v28 = __ldaxr(v27);
      v29 = v28 - 1;
    }
    while (__stlxr(v29, v27));
    if (!v29)
      cv::Mat::deallocate((cv::Mat *)v42, v9);
  }
  *(_QWORD *)&v42[1] = 0;
  memset(&v42[2], 0, 24);
  if (SDWORD1(v42[0]) >= 1)
  {
    v30 = 0;
    v31 = v43;
    do
      *(_DWORD *)&v31[4 * v30++] = 0;
    while (v30 < SDWORD1(v42[0]));
  }
  *((_QWORD *)&v42[1] + 1) = 0;
  if (v44 != v45)
    cv::fastFree(v44, v9);
}

void sub_219E904BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  uint64_t v42;
  void *v44;

  cv::Exception::~Exception((cv::Exception *)&a15);
  if (a14 < 0)
    operator delete(__p);
  if (a35 < 0)
    operator delete(a30);
  if (a42 < 0)
    operator delete(a37);
  cv::Mat::~Mat((cv::Mat *)(v42 - 160), v44);
  _Unwind_Resume(a1);
}

void cv::MatOp_Bin::multiply(cv::MatOp_Bin *this, const cv::MatExpr *a2, double a3, cv::MatExpr *a4)
{
  int v6;

  v6 = *((_DWORD *)a2 + 2);
  if (v6 == 47 || v6 == 42)
  {
    cv::MatExpr::operator=((uint64_t)a4, (uint64_t *)a2);
    *((double *)a4 + 38) = *((double *)a4 + 38) * a3;
  }
  else
  {
    cv::MatOp::multiply(this, a2, a3, a4);
  }
}

void cv::MatOp_Bin::divide(cv::MatOp_Bin *this, double a2, const cv::MatExpr *a3, cv::MatExpr *a4)
{
  double v4;
  void *v5;
  unsigned int *v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  char *v10;
  _OWORD v11[2];
  _OWORD v12[4];
  char *v13;
  cv *v14;
  _QWORD v15[2];

  if (*((_DWORD *)a3 + 2) == 47 && (!*((_QWORD *)a3 + 16) || *((double *)a3 + 39) == 0.0))
  {
    v13 = (char *)v12 + 8;
    v14 = (cv *)v15;
    v15[0] = 0;
    v15[1] = 0;
    LODWORD(v12[0]) = 1124007936;
    memset((char *)v12 + 4, 0, 48);
    v12[3] = 0u;
    v4 = *((double *)a3 + 38);
    memset(v11, 0, sizeof(v11));
    cv::MatOp_AddEx::makeExpr((uint64_t)a4, (const cv::MatExpr *)((char *)a3 + 16), (cv::Mat *)v12, (uint64_t)v11, a2 / v4, 0.0);
    v6 = (unsigned int *)*((_QWORD *)&v12[1] + 1);
    if (*((_QWORD *)&v12[1] + 1))
    {
      do
      {
        v7 = __ldaxr(v6);
        v8 = v7 - 1;
      }
      while (__stlxr(v8, v6));
      if (!v8)
        cv::Mat::deallocate((cv::Mat *)v12, v5);
    }
    *(_QWORD *)&v12[1] = 0;
    memset(&v12[2], 0, 24);
    if (SDWORD1(v12[0]) >= 1)
    {
      v9 = 0;
      v10 = v13;
      do
        *(_DWORD *)&v10[4 * v9++] = 0;
      while (v9 < SDWORD1(v12[0]));
    }
    *((_QWORD *)&v12[1] + 1) = 0;
    if (v14 != (cv *)v15)
      cv::fastFree((void **)v14, v5);
  }
  else
  {
    cv::MatOp::divide(a4, a2, a3, a4);
  }
}

void sub_219E9072C(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  cv::Mat::~Mat((cv::Mat *)va, a2);
  _Unwind_Resume(a1);
}

void cv::MatOp_Cmp::assign(cv::MatOp_Cmp *this, const cv::MatExpr *a2, cv::Mat *a3, int a4)
{
  unsigned int v7;
  cv::Mat *v8;
  const cv::Mat *v9;
  void *v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  char *v15;
  _BYTE v16[32];
  _BYTE v17[32];
  _BYTE v18[32];
  _OWORD v19[4];
  char *v20;
  cv *v21;
  _QWORD v22[2];

  v20 = (char *)v19 + 8;
  v21 = (cv *)v22;
  v22[0] = 0;
  v22[1] = 0;
  LODWORD(v19[0]) = 1124007936;
  memset((char *)v19 + 4, 0, 48);
  v7 = a4 + 1;
  v19[3] = 0u;
  if ((a4 + 1) >= 2)
    v8 = (cv::Mat *)v19;
  else
    v8 = a3;
  v9 = (const cv::MatExpr *)((char *)a2 + 16);
  if (*((_QWORD *)a2 + 16))
  {
    cv::_InputArray::_InputArray((uint64_t)v18, v9);
    cv::_InputArray::_InputArray((uint64_t)v17, (const cv::MatExpr *)((char *)a2 + 112));
  }
  else
  {
    cv::_InputArray::_InputArray((uint64_t)v18, v9);
    cv::_InputArray::_InputArray((cv::_InputArray *)v17, (const double *)a2 + 38);
  }
  cv::_OutputArray::_OutputArray((uint64_t)v16, v8);
  cv::compare((cv *)v18, (const cv::_InputArray *)v17, (const cv::_InputArray *)v16, (const cv::_OutputArray *)*((unsigned int *)a2 + 2));
  if (v7 >= 2 && *(_QWORD *)&v19[1] != *((_QWORD *)a3 + 2))
  {
    cv::_OutputArray::_OutputArray((uint64_t)v18, a3);
    cv::Mat::convertTo(v8, (const cv::_OutputArray *)v18, a4, 1.0, 0.0);
  }
  v11 = (unsigned int *)*((_QWORD *)&v19[1] + 1);
  if (*((_QWORD *)&v19[1] + 1))
  {
    do
    {
      v12 = __ldaxr(v11);
      v13 = v12 - 1;
    }
    while (__stlxr(v13, v11));
    if (!v13)
      cv::Mat::deallocate((cv::Mat *)v19, v10);
  }
  *(_QWORD *)&v19[1] = 0;
  memset(&v19[2], 0, 24);
  if (SDWORD1(v19[0]) >= 1)
  {
    v14 = 0;
    v15 = v20;
    do
      *(_DWORD *)&v15[4 * v14++] = 0;
    while (v14 < SDWORD1(v19[0]));
  }
  *((_QWORD *)&v19[1] + 1) = 0;
  if (v21 != (cv *)v22)
    cv::fastFree((void **)v21, v10);
}

void sub_219E908E0(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_list va;

  va_start(va, a14);
  cv::Mat::~Mat((cv::Mat *)va, a2);
  _Unwind_Resume(a1);
}

void cv::MatOp_T::assign(cv::MatOp_T *this, const cv::MatExpr *a2, cv::Mat *a3, int a4)
{
  cv::Mat *v7;
  const cv::_OutputArray *v8;
  void *v9;
  unsigned int *v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  char *v14;
  _BYTE v15[32];
  _BYTE v16[32];
  _OWORD v17[4];
  char *v18;
  cv *v19;
  _QWORD v20[2];

  v18 = (char *)v17 + 8;
  v19 = (cv *)v20;
  v20[0] = 0;
  v20[1] = 0;
  LODWORD(v17[0]) = 1124007936;
  memset((char *)v17 + 4, 0, 48);
  v17[3] = 0u;
  if (a4 == -1 || (*((_DWORD *)a2 + 4) & 0xFFF) == a4)
    v7 = a3;
  else
    v7 = (cv::Mat *)v17;
  cv::_InputArray::_InputArray((uint64_t)v16, (const cv::MatExpr *)((char *)a2 + 16));
  cv::_OutputArray::_OutputArray((uint64_t)v15, v7);
  cv::transpose((cv *)v16, (const cv::_InputArray *)v15, v8);
  if (*((_QWORD *)v7 + 2) != *((_QWORD *)a3 + 2) || *((double *)a2 + 38) != 1.0)
  {
    cv::_OutputArray::_OutputArray((uint64_t)v16, a3);
    cv::Mat::convertTo(v7, (const cv::_OutputArray *)v16, a4, *((double *)a2 + 38), 0.0);
  }
  v10 = (unsigned int *)*((_QWORD *)&v17[1] + 1);
  if (*((_QWORD *)&v17[1] + 1))
  {
    do
    {
      v11 = __ldaxr(v10);
      v12 = v11 - 1;
    }
    while (__stlxr(v12, v10));
    if (!v12)
      cv::Mat::deallocate((cv::Mat *)v17, v9);
  }
  *(_QWORD *)&v17[1] = 0;
  memset(&v17[2], 0, 24);
  if (SDWORD1(v17[0]) >= 1)
  {
    v13 = 0;
    v14 = v18;
    do
      *(_DWORD *)&v14[4 * v13++] = 0;
    while (v13 < SDWORD1(v17[0]));
  }
  *((_QWORD *)&v17[1] + 1) = 0;
  if (v19 != (cv *)v20)
    cv::fastFree((void **)v19, v9);
}

void sub_219E90A78(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_list va;

  va_start(va, a10);
  cv::Mat::~Mat((cv::Mat *)va, a2);
  _Unwind_Resume(a1);
}

double cv::MatOp_T::multiply(cv::MatOp_T *this, const cv::MatExpr *a2, double a3, cv::MatExpr *a4)
{
  double result;

  cv::MatExpr::operator=((uint64_t)a4, (uint64_t *)a2);
  result = *((double *)a4 + 38) * a3;
  *((double *)a4 + 38) = result;
  return result;
}

void cv::MatOp_T::transpose(cv::MatOp_T *this, const cv::MatExpr *a2, cv::MatExpr *a3)
{
  double v3;
  void *v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  char *v9;
  _OWORD v10[2];
  _OWORD v11[4];
  char *v12;
  cv *v13;
  _QWORD v14[2];

  v3 = *((double *)a2 + 38);
  if (v3 == 1.0)
  {
    cv::MatOp_Identity::makeExpr(a3, (const cv::MatExpr *)((char *)a2 + 16), a3);
  }
  else
  {
    v12 = (char *)v11 + 8;
    v13 = (cv *)v14;
    v14[0] = 0;
    v14[1] = 0;
    LODWORD(v11[0]) = 1124007936;
    memset((char *)v11 + 4, 0, 48);
    v11[3] = 0u;
    memset(v10, 0, sizeof(v10));
    cv::MatOp_AddEx::makeExpr((uint64_t)a3, (const cv::MatExpr *)((char *)a2 + 16), (cv::Mat *)v11, (uint64_t)v10, v3, 0.0);
    v5 = (unsigned int *)*((_QWORD *)&v11[1] + 1);
    if (*((_QWORD *)&v11[1] + 1))
    {
      do
      {
        v6 = __ldaxr(v5);
        v7 = v6 - 1;
      }
      while (__stlxr(v7, v5));
      if (!v7)
        cv::Mat::deallocate((cv::Mat *)v11, v4);
    }
    *(_QWORD *)&v11[1] = 0;
    memset(&v11[2], 0, 24);
    if (SDWORD1(v11[0]) >= 1)
    {
      v8 = 0;
      v9 = v12;
      do
        *(_DWORD *)&v9[4 * v8++] = 0;
      while (v8 < SDWORD1(v11[0]));
    }
    *((_QWORD *)&v11[1] + 1) = 0;
    if (v13 != (cv *)v14)
      cv::fastFree((void **)v13, v4);
  }
}

void sub_219E90BD0(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  cv::Mat::~Mat((cv::Mat *)va, a2);
  _Unwind_Resume(a1);
}

void cv::MatOp_Identity::makeExpr(cv::MatOp_Identity *this, cv::MatExpr *a2, const cv::Mat *a3)
{
  void *v4;
  void *v5;
  unsigned int *v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  char *v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  char *v15;
  _OWORD v16[2];
  _OWORD v17[4];
  char *v18;
  cv *v19;
  _QWORD v20[2];
  _OWORD v21[4];
  char *v22;
  cv *v23;
  _QWORD v24[2];
  uint64_t v25[44];

  v22 = (char *)v21 + 8;
  v23 = (cv *)v24;
  v24[0] = 0;
  v24[1] = 0;
  LODWORD(v21[0]) = 1124007936;
  memset((char *)v21 + 4, 0, 48);
  v21[3] = 0u;
  v18 = (char *)v17 + 8;
  v19 = (cv *)v20;
  v20[0] = 0;
  v20[1] = 0;
  LODWORD(v17[0]) = 1124007936;
  memset((char *)v17 + 4, 0, 48);
  v17[3] = 0u;
  memset(v16, 0, sizeof(v16));
  cv::MatExpr::MatExpr((uint64_t)v25, (uint64_t)&cv::g_MatOp_Identity, 0, a2, (cv::Mat *)v21, (cv::Mat *)v17, (uint64_t)v16, 1.0, 0.0);
  cv::MatExpr::operator=((uint64_t)this, v25);
  cv::MatExpr::~MatExpr((cv::MatExpr *)v25, v4);
  v6 = (unsigned int *)*((_QWORD *)&v17[1] + 1);
  if (*((_QWORD *)&v17[1] + 1))
  {
    do
    {
      v7 = __ldaxr(v6);
      v8 = v7 - 1;
    }
    while (__stlxr(v8, v6));
    if (!v8)
      cv::Mat::deallocate((cv::Mat *)v17, v5);
  }
  *(_QWORD *)&v17[1] = 0;
  memset(&v17[2], 0, 24);
  if (SDWORD1(v17[0]) >= 1)
  {
    v9 = 0;
    v10 = v18;
    do
      *(_DWORD *)&v10[4 * v9++] = 0;
    while (v9 < SDWORD1(v17[0]));
  }
  *((_QWORD *)&v17[1] + 1) = 0;
  if (v19 != (cv *)v20)
    cv::fastFree((void **)v19, v5);
  v11 = (unsigned int *)*((_QWORD *)&v21[1] + 1);
  if (*((_QWORD *)&v21[1] + 1))
  {
    do
    {
      v12 = __ldaxr(v11);
      v13 = v12 - 1;
    }
    while (__stlxr(v13, v11));
    if (!v13)
      cv::Mat::deallocate((cv::Mat *)v21, v5);
  }
  *(_QWORD *)&v21[1] = 0;
  memset(&v21[2], 0, 24);
  if (SDWORD1(v21[0]) >= 1)
  {
    v14 = 0;
    v15 = v22;
    do
      *(_DWORD *)&v15[4 * v14++] = 0;
    while (v14 < SDWORD1(v21[0]));
  }
  *((_QWORD *)&v21[1] + 1) = 0;
  if (v23 != (cv *)v24)
    cv::fastFree((void **)v23, v5);
}

void sub_219E90D8C(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  void *v38;
  void *v39;

  cv::MatExpr::~MatExpr((cv::MatExpr *)&a37, a2);
  cv::Mat::~Mat((cv::Mat *)&a13, v38);
  cv::Mat::~Mat((cv::Mat *)&a25, v39);
  _Unwind_Resume(a1);
}

void cv::MatOp_GEMM::assign(cv::MatOp_GEMM *this, const cv::MatExpr *a2, cv::Mat *a3, int a4)
{
  cv::Mat *v7;
  double v8;
  double v9;
  void *v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  char *v15;
  _BYTE v16[32];
  _BYTE v17[32];
  _BYTE v18[32];
  _BYTE v19[32];
  _OWORD v20[4];
  char *v21;
  cv *v22;
  _QWORD v23[2];

  v21 = (char *)v20 + 8;
  v22 = (cv *)v23;
  v23[0] = 0;
  v23[1] = 0;
  LODWORD(v20[0]) = 1124007936;
  memset((char *)v20 + 4, 0, 48);
  v20[3] = 0u;
  if (a4 == -1 || (*((_DWORD *)a2 + 4) & 0xFFF) == a4)
    v7 = a3;
  else
    v7 = (cv::Mat *)v20;
  cv::_InputArray::_InputArray((uint64_t)v19, (const cv::MatExpr *)((char *)a2 + 16));
  cv::_InputArray::_InputArray((uint64_t)v18, (const cv::MatExpr *)((char *)a2 + 112));
  v8 = *((double *)a2 + 38);
  cv::_InputArray::_InputArray((uint64_t)v17, (const cv::MatExpr *)((char *)a2 + 208));
  v9 = *((double *)a2 + 39);
  cv::_OutputArray::_OutputArray((uint64_t)v16, v7);
  cv::gemm((cv *)v19, (const cv::_InputArray *)v18, (const cv::_InputArray *)v17, v8, (const cv::_InputArray *)v16, v9, (const cv::_OutputArray *)*((unsigned int *)a2 + 2));
  if (*((_QWORD *)v7 + 2) != *((_QWORD *)a3 + 2))
  {
    cv::_OutputArray::_OutputArray((uint64_t)v19, a3);
    cv::Mat::convertTo(v7, (const cv::_OutputArray *)v19, a4, 1.0, 0.0);
  }
  v11 = (unsigned int *)*((_QWORD *)&v20[1] + 1);
  if (*((_QWORD *)&v20[1] + 1))
  {
    do
    {
      v12 = __ldaxr(v11);
      v13 = v12 - 1;
    }
    while (__stlxr(v13, v11));
    if (!v13)
      cv::Mat::deallocate((cv::Mat *)v20, v10);
  }
  *(_QWORD *)&v20[1] = 0;
  memset(&v20[2], 0, 24);
  if (SDWORD1(v20[0]) >= 1)
  {
    v14 = 0;
    v15 = v21;
    do
      *(_DWORD *)&v15[4 * v14++] = 0;
    while (v14 < SDWORD1(v20[0]));
  }
  *((_QWORD *)&v20[1] + 1) = 0;
  if (v22 != (cv *)v23)
    cv::fastFree((void **)v22, v10);
}

void sub_219E90F4C(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, ...)
{
  va_list va;

  va_start(va, a18);
  cv::Mat::~Mat((cv::Mat *)va, a2);
  _Unwind_Resume(a1);
}

void cv::MatOp_GEMM::add(cv::MatOp_GEMM *this, float64x2_t *a2, float64x2_t *a3, cv::MatExpr *a4)
{
  float64_t v6;
  cv::MatOp_GEMM *v7;
  double v8;
  double v9;
  int v10;
  void *v11;
  int v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15[44];

  v6 = a2->f64[0];
  v7 = *(cv::MatOp_GEMM **)&a3->f64[0];
  v8 = 1.0;
  if (*(_UNKNOWN ***)&a2->f64[0] == &cv::g_MatOp_Identity)
    v9 = 1.0;
  else
    v9 = a2[19].f64[0];
  if (v7 != (cv::MatOp_GEMM *)&cv::g_MatOp_Identity)
    v8 = a3[19].f64[0];
  if (*(_UNKNOWN ***)&v6 == &cv::g_MatOp_GEMM && (!*(_QWORD *)&a2[14].f64[0] || a2[19].f64[1] == 0.0))
  {
    if (v7 != (cv::MatOp_GEMM *)&cv::g_MatOp_Identity)
    {
      if (v7 == (cv::MatOp_GEMM *)&cv::g_MatOp_AddEx)
      {
        if (*(_QWORD *)&a3[8].f64[0] && a3[19].f64[1] != 0.0
          || (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqzq_f64(a3[20]), (int32x4_t)vceqzq_f64(a3[21]))))) & 1) != 0)
        {
          goto LABEL_12;
        }
      }
      else if (v7 != (cv::MatOp_GEMM *)&cv::g_MatOp_T)
      {
        goto LABEL_9;
      }
    }
    v10 = LODWORD(a2->f64[1]);
    v13 = 0u;
    v14 = 0u;
    cv::MatExpr::MatExpr((uint64_t)v15, (uint64_t)&cv::g_MatOp_GEMM, v10 & 0xFFFFFFFB | (4 * (v7 == (cv::MatOp_GEMM *)&cv::g_MatOp_T)), (cv::Mat *)&a2[1], (cv::Mat *)&a2[7], (cv::Mat *)&a3[1], (uint64_t)&v13, v9, v8);
    cv::MatExpr::operator=((uint64_t)a4, v15);
LABEL_31:
    cv::MatExpr::~MatExpr((cv::MatExpr *)v15, v11);
    return;
  }
LABEL_9:
  if (v7 != (cv::MatOp_GEMM *)&cv::g_MatOp_GEMM || *(_QWORD *)&a3[14].f64[0] && a3[19].f64[1] != 0.0)
    goto LABEL_12;
  if (*(_UNKNOWN ***)&v6 == &cv::g_MatOp_Identity)
    goto LABEL_30;
  if (*(_UNKNOWN ***)&v6 == &cv::g_MatOp_AddEx)
  {
    if (*(_QWORD *)&a2[8].f64[0] && a2[19].f64[1] != 0.0
      || (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqzq_f64(a2[20]), (int32x4_t)vceqzq_f64(a2[21]))))) & 1) != 0)
    {
      goto LABEL_12;
    }
    goto LABEL_30;
  }
  if (*(_UNKNOWN ***)&v6 == &cv::g_MatOp_T)
  {
LABEL_30:
    v12 = LODWORD(a3->f64[1]);
    v13 = 0u;
    v14 = 0u;
    cv::MatExpr::MatExpr((uint64_t)v15, (uint64_t)&cv::g_MatOp_GEMM, v12 & 0xFFFFFFFB | (4 * (*(_QWORD *)&v6 == (_QWORD)&cv::g_MatOp_T)), (cv::Mat *)&a3[1], (cv::Mat *)&a3[7], (cv::Mat *)&a2[1], (uint64_t)&v13, v8, v9);
    cv::MatExpr::operator=((uint64_t)a4, v15);
    goto LABEL_31;
  }
LABEL_12:
  if (v7 == this)
    cv::MatOp::add(this, (const cv::MatExpr *)a2, (const cv::MatExpr *)a3, a4);
  else
    (*(void (**)(cv::MatOp_GEMM *))(*(_QWORD *)v7 + 104))(v7);
}

void sub_219E911C0(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  cv::MatExpr::~MatExpr((cv::MatExpr *)va, a2);
  _Unwind_Resume(a1);
}

void cv::MatOp_GEMM::subtract(cv::MatOp_GEMM *this, float64x2_t *a2, float64x2_t *a3, cv::MatExpr *a4)
{
  float64_t v6;
  float64_t v7;
  double v8;
  double v9;
  int v10;
  void *v11;
  int v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15[44];

  v6 = a2->f64[0];
  v7 = a3->f64[0];
  if (*(_UNKNOWN ***)&a2->f64[0] == &cv::g_MatOp_Identity)
    v8 = 1.0;
  else
    v8 = a2[19].f64[0];
  v9 = a3[19].f64[0];
  if (*(_UNKNOWN ***)&v7 == &cv::g_MatOp_Identity)
    v9 = 1.0;
  if (*(_UNKNOWN ***)&v6 == &cv::g_MatOp_GEMM && (!*(_QWORD *)&a2[14].f64[0] || a2[19].f64[1] == 0.0))
  {
    if (*(_UNKNOWN ***)&v7 != &cv::g_MatOp_Identity)
    {
      if (*(_UNKNOWN ***)&v7 == &cv::g_MatOp_AddEx)
      {
        if (*(_QWORD *)&a3[8].f64[0] && a3[19].f64[1] != 0.0
          || (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqzq_f64(a3[20]), (int32x4_t)vceqzq_f64(a3[21]))))) & 1) != 0)
        {
          goto LABEL_12;
        }
      }
      else if (*(_UNKNOWN ***)&v7 != &cv::g_MatOp_T)
      {
        goto LABEL_9;
      }
    }
    v10 = LODWORD(a2->f64[1]);
    v13 = 0u;
    v14 = 0u;
    cv::MatExpr::MatExpr((uint64_t)v15, (uint64_t)&cv::g_MatOp_GEMM, v10 & 0xFFFFFFFB | (4 * (*(_QWORD *)&v7 == (_QWORD)&cv::g_MatOp_T)), (cv::Mat *)&a2[1], (cv::Mat *)&a2[7], (cv::Mat *)&a3[1], (uint64_t)&v13, v8, -v9);
    cv::MatExpr::operator=((uint64_t)a4, v15);
LABEL_31:
    cv::MatExpr::~MatExpr((cv::MatExpr *)v15, v11);
    return;
  }
LABEL_9:
  if (*(_UNKNOWN ***)&v7 != &cv::g_MatOp_GEMM || *(_QWORD *)&a3[14].f64[0] && a3[19].f64[1] != 0.0)
    goto LABEL_12;
  if (*(_UNKNOWN ***)&v6 == &cv::g_MatOp_Identity)
    goto LABEL_30;
  if (*(_UNKNOWN ***)&v6 == &cv::g_MatOp_AddEx)
  {
    if (*(_QWORD *)&a2[8].f64[0] && a2[19].f64[1] != 0.0
      || (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqzq_f64(a2[20]), (int32x4_t)vceqzq_f64(a2[21]))))) & 1) != 0)
    {
      goto LABEL_12;
    }
    goto LABEL_30;
  }
  if (*(_UNKNOWN ***)&v6 == &cv::g_MatOp_T)
  {
LABEL_30:
    v12 = LODWORD(a3->f64[1]);
    v13 = 0u;
    v14 = 0u;
    cv::MatExpr::MatExpr((uint64_t)v15, (uint64_t)&cv::g_MatOp_GEMM, v12 & 0xFFFFFFFB | (4 * (*(_QWORD *)&v6 == (_QWORD)&cv::g_MatOp_T)), (cv::Mat *)&a3[1], (cv::Mat *)&a3[7], (cv::Mat *)&a2[1], (uint64_t)&v13, -v9, v8);
    cv::MatExpr::operator=((uint64_t)a4, v15);
    goto LABEL_31;
  }
LABEL_12:
  if (*(cv::MatOp_GEMM **)&v7 == this)
    cv::MatOp::subtract(this, (const cv::MatExpr *)a2, (const cv::MatExpr *)a3, a4);
  else
    (*(void (**)(float64_t))(**(_QWORD **)&v7 + 120))(COERCE_FLOAT64_T(*(_QWORD *)&v7));
}

void sub_219E9142C(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  cv::MatExpr::~MatExpr((cv::MatExpr *)va, a2);
  _Unwind_Resume(a1);
}

float64x2_t cv::MatOp_GEMM::multiply(cv::MatOp_GEMM *this, const cv::MatExpr *a2, double a3, float64x2_t *a4)
{
  float64x2_t result;

  cv::MatExpr::operator=((uint64_t)a4, (uint64_t *)a2);
  result = vmulq_n_f64(a4[19], a3);
  a4[19] = result;
  return result;
}

int *cv::MatOp_GEMM::transpose(cv::MatOp_GEMM *this, const cv::MatExpr *a2, cv::MatExpr *a3)
{
  Mat *v5;

  cv::MatExpr::operator=((uint64_t)a3, (uint64_t *)a2);
  *((_DWORD *)a3 + 2) = (*((_DWORD *)a2 + 2) & 4 | (~__rbit32(*((_DWORD *)a2 + 2)) >> 30)) ^ 4;
  return cv::swap((int *)a3 + 4, (Mat *)((char *)a3 + 112), v5);
}

void cv::MatOp_Invert::assign(cv::MatOp_Invert *this, const cv::MatExpr *a2, cv::Mat *a3, int a4)
{
  cv::Mat *v7;
  void *v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  char *v13;
  _BYTE v14[32];
  _BYTE v15[32];
  _OWORD v16[4];
  char *v17;
  cv *v18;
  _QWORD v19[2];

  v17 = (char *)v16 + 8;
  v18 = (cv *)v19;
  v19[0] = 0;
  v19[1] = 0;
  LODWORD(v16[0]) = 1124007936;
  memset((char *)v16 + 4, 0, 48);
  v16[3] = 0u;
  if (a4 == -1 || (*((_DWORD *)a2 + 4) & 0xFFF) == a4)
    v7 = a3;
  else
    v7 = (cv::Mat *)v16;
  cv::_InputArray::_InputArray((uint64_t)v15, (const cv::MatExpr *)((char *)a2 + 16));
  cv::_OutputArray::_OutputArray((uint64_t)v14, v7);
  cv::invert((cv *)v15, (const cv::_InputArray *)v14, (const cv::_OutputArray *)*((unsigned int *)a2 + 2));
  if (*((_QWORD *)v7 + 2) != *((_QWORD *)a3 + 2))
  {
    cv::_OutputArray::_OutputArray((uint64_t)v15, a3);
    cv::Mat::convertTo(v7, (const cv::_OutputArray *)v15, a4, 1.0, 0.0);
  }
  v9 = (unsigned int *)*((_QWORD *)&v16[1] + 1);
  if (*((_QWORD *)&v16[1] + 1))
  {
    do
    {
      v10 = __ldaxr(v9);
      v11 = v10 - 1;
    }
    while (__stlxr(v11, v9));
    if (!v11)
      cv::Mat::deallocate((cv::Mat *)v16, v8);
  }
  *(_QWORD *)&v16[1] = 0;
  memset(&v16[2], 0, 24);
  if (SDWORD1(v16[0]) >= 1)
  {
    v12 = 0;
    v13 = v17;
    do
      *(_DWORD *)&v13[4 * v12++] = 0;
    while (v12 < SDWORD1(v16[0]));
  }
  *((_QWORD *)&v16[1] + 1) = 0;
  if (v18 != (cv *)v19)
    cv::fastFree((void **)v18, v8);
}

void sub_219E9162C(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_list va;

  va_start(va, a10);
  cv::Mat::~Mat((cv::Mat *)va, a2);
  _Unwind_Resume(a1);
}

void cv::MatOp_Invert::matmul(cv::MatOp_Invert *this, const cv::MatExpr *a2, cv::MatOp_Invert **a3, cv::MatExpr *a4, const cv::Mat *a5)
{
  cv::MatOp_Invert *v5;

  v5 = *a3;
  if (*(_UNKNOWN ***)a2 == &cv::g_MatOp_Invert && v5 == (cv::MatOp_Invert *)&cv::g_MatOp_Identity)
  {
    cv::MatOp_Solve::makeExpr(a4, (cv::MatExpr *)*((unsigned int *)a2 + 2), (const cv::MatExpr *)((char *)a2 + 16), (const cv::Mat *)(a3 + 2), a5);
  }
  else if (v5 == this)
  {
    cv::MatOp::matmul(this, a2, (const cv::MatExpr *)a3, a4);
  }
  else
  {
    (*(void (**)(cv::MatOp_Invert *))(*(_QWORD *)v5 + 184))(*a3);
  }
}

void cv::MatOp_Solve::makeExpr(cv::MatOp_Solve *this, cv::MatExpr *a2, cv::Mat *a3, const cv::Mat *a4, const cv::Mat *a5)
{
  void *v6;
  void *v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  char *v12;
  _OWORD v13[2];
  _OWORD v14[4];
  char *v15;
  cv *v16;
  _QWORD v17[2];
  uint64_t v18[44];

  v15 = (char *)v14 + 8;
  v16 = (cv *)v17;
  v17[0] = 0;
  v17[1] = 0;
  LODWORD(v14[0]) = 1124007936;
  memset((char *)v14 + 4, 0, 48);
  v14[3] = 0u;
  memset(v13, 0, sizeof(v13));
  cv::MatExpr::MatExpr((uint64_t)v18, (uint64_t)&cv::g_MatOp_Solve, (int)a2, a3, a4, (cv::Mat *)v14, (uint64_t)v13, 1.0, 1.0);
  cv::MatExpr::operator=((uint64_t)this, v18);
  cv::MatExpr::~MatExpr((cv::MatExpr *)v18, v6);
  v8 = (unsigned int *)*((_QWORD *)&v14[1] + 1);
  if (*((_QWORD *)&v14[1] + 1))
  {
    do
    {
      v9 = __ldaxr(v8);
      v10 = v9 - 1;
    }
    while (__stlxr(v10, v8));
    if (!v10)
      cv::Mat::deallocate((cv::Mat *)v14, v7);
  }
  *(_QWORD *)&v14[1] = 0;
  memset(&v14[2], 0, 24);
  if (SDWORD1(v14[0]) >= 1)
  {
    v11 = 0;
    v12 = v15;
    do
      *(_DWORD *)&v12[4 * v11++] = 0;
    while (v11 < SDWORD1(v14[0]));
  }
  *((_QWORD *)&v14[1] + 1) = 0;
  if (v16 != (cv *)v17)
    cv::fastFree((void **)v16, v7);
}

void sub_219E917B8(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  void *v7;
  uint64_t v8;
  va_list va;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  v19 = va_arg(va1, _QWORD);
  v20 = va_arg(va1, _QWORD);
  cv::MatExpr::~MatExpr((cv::MatExpr *)va1, a2);
  cv::Mat::~Mat((cv::Mat *)va, v7);
  _Unwind_Resume(a1);
}

void cv::MatOp_Solve::assign(cv::MatOp_Solve *this, const cv::MatExpr *a2, cv::Mat *a3, int a4)
{
  cv::Mat *v7;
  void *v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  char *v13;
  _BYTE v14[32];
  _BYTE v15[32];
  _BYTE v16[32];
  _OWORD v17[4];
  char *v18;
  cv *v19;
  _QWORD v20[2];

  v18 = (char *)v17 + 8;
  v19 = (cv *)v20;
  v20[0] = 0;
  v20[1] = 0;
  LODWORD(v17[0]) = 1124007936;
  memset((char *)v17 + 4, 0, 48);
  v17[3] = 0u;
  if (a4 == -1 || (*((_DWORD *)a2 + 4) & 0xFFF) == a4)
    v7 = a3;
  else
    v7 = (cv::Mat *)v17;
  cv::_InputArray::_InputArray((uint64_t)v16, (const cv::MatExpr *)((char *)a2 + 16));
  cv::_InputArray::_InputArray((uint64_t)v15, (const cv::MatExpr *)((char *)a2 + 112));
  cv::_OutputArray::_OutputArray((uint64_t)v14, v7);
  cv::solve((cv *)v16, (const cv::_InputArray *)v15, (const cv::_InputArray *)v14, (const cv::_OutputArray *)*((unsigned int *)a2 + 2));
  if (*((_QWORD *)v7 + 2) != *((_QWORD *)a3 + 2))
  {
    cv::_OutputArray::_OutputArray((uint64_t)v16, a3);
    cv::Mat::convertTo(v7, (const cv::_OutputArray *)v16, a4, 1.0, 0.0);
  }
  v9 = (unsigned int *)*((_QWORD *)&v17[1] + 1);
  if (*((_QWORD *)&v17[1] + 1))
  {
    do
    {
      v10 = __ldaxr(v9);
      v11 = v10 - 1;
    }
    while (__stlxr(v11, v9));
    if (!v11)
      cv::Mat::deallocate((cv::Mat *)v17, v8);
  }
  *(_QWORD *)&v17[1] = 0;
  memset(&v17[2], 0, 24);
  if (SDWORD1(v17[0]) >= 1)
  {
    v12 = 0;
    v13 = v18;
    do
      *(_DWORD *)&v13[4 * v12++] = 0;
    while (v12 < SDWORD1(v17[0]));
  }
  *((_QWORD *)&v17[1] + 1) = 0;
  if (v19 != (cv *)v20)
    cv::fastFree((void **)v19, v8);
}

void sub_219E91948(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_list va;

  va_start(va, a14);
  cv::Mat::~Mat((cv::Mat *)va, a2);
  _Unwind_Resume(a1);
}

void cv::MatOp_Initializer::assign(cv::MatOp_Initializer *this, const cv::MatExpr *a2, cv::Mat *a3, int a4)
{
  cv::Mat *v6;
  int v7;
  __int16 v8;
  uint64_t v9;
  int v10;
  int v11;
  BOOL v13;
  BOOL v14;
  int v15;
  const cv::Exception *v17;
  void *__p[2];
  void *v19[2];
  int64x2_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23[4];
  __int128 v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v7 = *((_DWORD *)a2 + 4);
  v6 = (cv::Mat *)*((unsigned int *)a2 + 5);
  v8 = v7 & 0xFFF;
  if (a4 == -1)
    LOWORD(a4) = v8;
  v9 = *((_QWORD *)a2 + 10);
  if ((int)v6 > 2)
  {
    cv::Mat::create(a3, v6, (const int *)v9, a4);
  }
  else
  {
    v10 = *(_DWORD *)(v9 + 4);
    v11 = a4 & 0xFFF;
    v13 = *((int *)a3 + 1) <= 2 && *((_DWORD *)a3 + 2) == *(_DWORD *)v9 && *((_DWORD *)a3 + 3) == v10;
    if (!v13 || ((*(_DWORD *)a3 & 0xFFF) == v11 ? (v14 = *((_QWORD *)a3 + 2) == 0) : (v14 = 1), v14))
    {
      v23[0] = *(_DWORD *)v9;
      v23[1] = v10;
      cv::Mat::create(a3, (cv::Mat *)2, v23, v11);
    }
  }
  v15 = *((_DWORD *)a2 + 2);
  if (v15 == 73 && *((_DWORD *)a2 + 5) <= 2)
  {
    cv::_OutputArray::_OutputArray((uint64_t)v23, a3);
    v20 = (int64x2_t)*((unint64_t *)a2 + 38);
    v21 = 0;
    v22 = 0;
    cv::setIdentity((void (***)(uint64_t *__return_ptr, _QWORD, uint64_t))v23, &v20);
  }
  else if (v15 == 49)
  {
    *(_QWORD *)v23 = *((_QWORD *)a2 + 38);
    v24 = 0uLL;
    *(_QWORD *)&v23[2] = 0;
    cv::Mat::operator=((uint64_t)a3, (int64x2_t *)v23);
  }
  else
  {
    if (v15 != 48)
    {
      std::string::basic_string[abi:ne180100]<0>(&v20, "Invalid matrix initializer type");
      std::string::basic_string[abi:ne180100]<0>(v19, "assign");
      std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/HomeAI/OpenCV/src/core/matop.cpp");
      cv::Exception::Exception(v23, 4294967294, &v20, v19, __p, 1572);
      cv::error((cv *)v23, v17);
    }
    *(_OWORD *)v23 = 0u;
    v24 = 0u;
    cv::Mat::operator=((uint64_t)a3, (int64x2_t *)v23);
  }
}

void sub_219E91B44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,char a28)
{
  cv::Exception::~Exception((cv::Exception *)&a28);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  _Unwind_Resume(a1);
}

double cv::MatOp_Initializer::multiply(cv::MatOp_Initializer *this, const cv::MatExpr *a2, double a3, cv::MatExpr *a4)
{
  double result;

  cv::MatExpr::operator=((uint64_t)a4, (uint64_t *)a2);
  result = *((double *)a4 + 38) * a3;
  *((double *)a4 + 38) = result;
  return result;
}

void cv::MatOp_Initializer::makeExpr(cv *a1, int a2, int *a3, unsigned int a4, double a5)
{
  int v10;
  void *v11;
  void *v12;
  unsigned int *v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  char *v17;
  unsigned int *v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  char *v22;
  unsigned int *v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t v26;
  _DWORD *v27;
  _OWORD v28[2];
  _OWORD v29[4];
  char *v30;
  cv *v31;
  _QWORD v32[2];
  _OWORD v33[4];
  char *v34;
  cv *v35;
  _QWORD v36[2];
  int v37;
  int v38;
  _DWORD v39[2];
  uint64_t v40;
  unsigned int *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  _DWORD *v46;
  cv *v47;
  _QWORD v48[2];
  uint64_t v49[44];

  cv::getGlobalMatOpInitializer(a1);
  v10 = *a3;
  v39[0] = a3[1];
  v39[1] = v10;
  v40 = 0;
  v41 = 0;
  v46 = v39;
  v47 = (cv *)v48;
  v37 = a4 & 0xFFF | 0x42FF4000;
  v38 = 2;
  v48[0] = v10 * (uint64_t)(int)((((a4 >> 3) & 0x1FF) + 1) << ((0xFA50u >> (2 * (a4 & 7))) & 3));
  v48[1] = (((a4 >> 3) & 0x1FF) + 1) << ((0xFA50u >> (2 * (a4 & 7))) & 3);
  v44 = v48[0] * v39[0];
  v45 = 0;
  v42 = 0;
  v43 = v44;
  v34 = (char *)v33 + 8;
  v35 = (cv *)v36;
  v36[0] = 0;
  v36[1] = 0;
  LODWORD(v33[0]) = 1124007936;
  memset((char *)v33 + 4, 0, 48);
  v33[3] = 0u;
  v30 = (char *)v29 + 8;
  v31 = (cv *)v32;
  v32[0] = 0;
  v32[1] = 0;
  LODWORD(v29[0]) = 1124007936;
  memset((char *)v29 + 4, 0, 48);
  v29[3] = 0u;
  memset(v28, 0, sizeof(v28));
  cv::MatExpr::MatExpr((uint64_t)v49, (uint64_t)&cv::getGlobalMatOpInitializer(void)::initializer, a2, (cv::Mat *)&v37, (cv::Mat *)v33, (cv::Mat *)v29, (uint64_t)v28, a5, 0.0);
  cv::MatExpr::operator=((uint64_t)a1, v49);
  cv::MatExpr::~MatExpr((cv::MatExpr *)v49, v11);
  v13 = (unsigned int *)*((_QWORD *)&v29[1] + 1);
  if (*((_QWORD *)&v29[1] + 1))
  {
    do
    {
      v14 = __ldaxr(v13);
      v15 = v14 - 1;
    }
    while (__stlxr(v15, v13));
    if (!v15)
      cv::Mat::deallocate((cv::Mat *)v29, v12);
  }
  *(_QWORD *)&v29[1] = 0;
  memset(&v29[2], 0, 24);
  if (SDWORD1(v29[0]) >= 1)
  {
    v16 = 0;
    v17 = v30;
    do
      *(_DWORD *)&v17[4 * v16++] = 0;
    while (v16 < SDWORD1(v29[0]));
  }
  *((_QWORD *)&v29[1] + 1) = 0;
  if (v31 != (cv *)v32)
    cv::fastFree((void **)v31, v12);
  v18 = (unsigned int *)*((_QWORD *)&v33[1] + 1);
  if (*((_QWORD *)&v33[1] + 1))
  {
    do
    {
      v19 = __ldaxr(v18);
      v20 = v19 - 1;
    }
    while (__stlxr(v20, v18));
    if (!v20)
      cv::Mat::deallocate((cv::Mat *)v33, v12);
  }
  *(_QWORD *)&v33[1] = 0;
  memset(&v33[2], 0, 24);
  if (SDWORD1(v33[0]) >= 1)
  {
    v21 = 0;
    v22 = v34;
    do
      *(_DWORD *)&v22[4 * v21++] = 0;
    while (v21 < SDWORD1(v33[0]));
  }
  *((_QWORD *)&v33[1] + 1) = 0;
  if (v35 != (cv *)v36)
    cv::fastFree((void **)v35, v12);
  v23 = v41;
  if (v41)
  {
    do
    {
      v24 = __ldaxr(v23);
      v25 = v24 - 1;
    }
    while (__stlxr(v25, v23));
    if (!v25)
      cv::Mat::deallocate((cv::Mat *)&v37, v12);
  }
  v40 = 0;
  v43 = 0;
  v44 = 0;
  v42 = 0;
  if (v38 >= 1)
  {
    v26 = 0;
    v27 = v46;
    do
      v27[v26++] = 0;
    while (v26 < v38);
  }
  v41 = 0;
  if (v47 != (cv *)v48)
    cv::fastFree((void **)v47, v12);
}

void sub_219E91E8C(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49)
{
  void *v50;
  void *v51;
  void *v52;

  cv::MatExpr::~MatExpr((cv::MatExpr *)&a49, a2);
  cv::Mat::~Mat((cv::Mat *)&a13, v50);
  cv::Mat::~Mat((cv::Mat *)&a25, v51);
  cv::Mat::~Mat((cv::Mat *)&a37, v52);
  _Unwind_Resume(a1);
}

void cv::Mat::zeros(uint64_t *a1@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v3;

  *(_QWORD *)a3 = 0;
  *(_DWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 96) = 0;
  *(_QWORD *)(a3 + 80) = a3 + 24;
  *(_QWORD *)(a3 + 88) = a3 + 96;
  *(_QWORD *)(a3 + 104) = 0;
  *(_DWORD *)(a3 + 16) = 1124007936;
  *(_OWORD *)(a3 + 20) = 0u;
  *(_OWORD *)(a3 + 36) = 0u;
  *(_OWORD *)(a3 + 52) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_QWORD *)(a3 + 192) = 0;
  *(_QWORD *)(a3 + 176) = a3 + 120;
  *(_QWORD *)(a3 + 184) = a3 + 192;
  *(_QWORD *)(a3 + 200) = 0;
  *(_DWORD *)(a3 + 112) = 1124007936;
  *(_OWORD *)(a3 + 160) = 0u;
  *(_OWORD *)(a3 + 148) = 0u;
  *(_OWORD *)(a3 + 132) = 0u;
  *(_OWORD *)(a3 + 116) = 0u;
  *(_QWORD *)(a3 + 272) = a3 + 216;
  *(_QWORD *)(a3 + 280) = a3 + 288;
  *(_QWORD *)(a3 + 288) = 0;
  *(_QWORD *)(a3 + 296) = 0;
  *(_DWORD *)(a3 + 208) = 1124007936;
  *(_OWORD *)(a3 + 256) = 0u;
  *(_OWORD *)(a3 + 244) = 0u;
  *(_OWORD *)(a3 + 228) = 0u;
  *(_OWORD *)(a3 + 212) = 0u;
  *(_OWORD *)(a3 + 320) = 0u;
  *(_OWORD *)(a3 + 336) = 0u;
  *(_OWORD *)(a3 + 304) = 0u;
  v3 = *a1;
  cv::MatOp_Initializer::makeExpr((cv *)a3, 48, (int *)&v3, a2, 1.0);
}

void sub_219E91F8C(_Unwind_Exception *a1, void *a2)
{
  cv::MatExpr *v2;

  cv::MatExpr::~MatExpr(v2, a2);
  _Unwind_Resume(a1);
}

void cv::MatOp_Identity::~MatOp_Identity(cv::MatOp_Identity *this)
{
  JUMPOUT(0x2207351BCLL);
}

uint64_t cv::MatOp_Identity::elementWise()
{
  return 1;
}

void cv::MatOp_AddEx::~MatOp_AddEx(cv::MatOp_AddEx *this)
{
  JUMPOUT(0x2207351BCLL);
}

uint64_t cv::MatOp_AddEx::elementWise()
{
  return 1;
}

void cv::MatOp_Bin::~MatOp_Bin(cv::MatOp_Bin *this)
{
  JUMPOUT(0x2207351BCLL);
}

uint64_t cv::MatOp_Bin::elementWise()
{
  return 1;
}

void cv::MatOp_Cmp::~MatOp_Cmp(cv::MatOp_Cmp *this)
{
  JUMPOUT(0x2207351BCLL);
}

uint64_t cv::MatOp_Cmp::elementWise()
{
  return 1;
}

void cv::MatOp_GEMM::~MatOp_GEMM(cv::MatOp_GEMM *this)
{
  JUMPOUT(0x2207351BCLL);
}

uint64_t cv::MatOp_GEMM::elementWise()
{
  return 0;
}

void cv::MatOp_Invert::~MatOp_Invert(cv::MatOp_Invert *this)
{
  JUMPOUT(0x2207351BCLL);
}

uint64_t cv::MatOp_Invert::elementWise()
{
  return 0;
}

void cv::MatOp_T::~MatOp_T(cv::MatOp_T *this)
{
  JUMPOUT(0x2207351BCLL);
}

uint64_t cv::MatOp_T::elementWise()
{
  return 0;
}

void cv::MatOp_Solve::~MatOp_Solve(cv::MatOp_Solve *this)
{
  JUMPOUT(0x2207351BCLL);
}

uint64_t cv::MatOp_Solve::elementWise()
{
  return 0;
}

void cv::MatOp_Initializer::~MatOp_Initializer(cv::MatOp_Initializer *this)
{
  JUMPOUT(0x2207351BCLL);
}

uint64_t cv::MatOp_Initializer::elementWise()
{
  return 0;
}

uint64_t cv::MatExpr::MatExpr(uint64_t a1, uint64_t a2, int a3, cv::Mat *a4, cv::Mat *a5, cv::Mat *a6, uint64_t a7, double a8, double a9)
{
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  unsigned int v18;
  _QWORD *v19;
  _QWORD *v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  unsigned int v24;
  _QWORD *v25;
  _QWORD *v26;
  __int128 v27;
  unsigned int v28;
  _QWORD *v29;
  _QWORD *v30;
  uint64_t v31;

  *(_QWORD *)a1 = a2;
  *(_DWORD *)(a1 + 8) = a3;
  v15 = *(_OWORD *)a4;
  *(_QWORD *)(a1 + 32) = *((_QWORD *)a4 + 2);
  v16 = *(_OWORD *)((char *)a4 + 24);
  *(_OWORD *)(a1 + 40) = v16;
  *(_OWORD *)(a1 + 56) = *(_OWORD *)((char *)a4 + 40);
  v17 = *((_QWORD *)a4 + 7);
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 72) = v17;
  *(_QWORD *)(a1 + 80) = a1 + 24;
  *(_QWORD *)(a1 + 88) = a1 + 96;
  *(_QWORD *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 16) = v15;
  if ((_QWORD)v16)
  {
    do
      v18 = __ldaxr((unsigned int *)v16);
    while (__stlxr(v18 + 1, (unsigned int *)v16));
  }
  if (*((int *)a4 + 1) > 2)
  {
    *(_DWORD *)(a1 + 20) = 0;
    cv::Mat::copySize((cv::Mat *)(a1 + 16), a4);
  }
  else
  {
    v19 = (_QWORD *)*((_QWORD *)a4 + 9);
    v20 = *(_QWORD **)(a1 + 88);
    *v20 = *v19;
    v20[1] = v19[1];
  }
  v21 = *(_OWORD *)a5;
  *(_QWORD *)(a1 + 128) = *((_QWORD *)a5 + 2);
  v22 = *(_OWORD *)((char *)a5 + 24);
  *(_OWORD *)(a1 + 136) = v22;
  *(_OWORD *)(a1 + 152) = *(_OWORD *)((char *)a5 + 40);
  v23 = *((_QWORD *)a5 + 7);
  *(_QWORD *)(a1 + 192) = 0;
  *(_QWORD *)(a1 + 168) = v23;
  *(_QWORD *)(a1 + 176) = a1 + 120;
  *(_QWORD *)(a1 + 184) = a1 + 192;
  *(_QWORD *)(a1 + 200) = 0;
  *(_OWORD *)(a1 + 112) = v21;
  if ((_QWORD)v22)
  {
    do
      v24 = __ldaxr((unsigned int *)v22);
    while (__stlxr(v24 + 1, (unsigned int *)v22));
  }
  if (*((int *)a5 + 1) > 2)
  {
    *(_DWORD *)(a1 + 116) = 0;
    cv::Mat::copySize((cv::Mat *)(a1 + 112), a5);
  }
  else
  {
    v25 = (_QWORD *)*((_QWORD *)a5 + 9);
    v26 = *(_QWORD **)(a1 + 184);
    *v26 = *v25;
    v26[1] = v25[1];
  }
  *(_OWORD *)(a1 + 208) = *(_OWORD *)a6;
  *(_QWORD *)(a1 + 224) = *((_QWORD *)a6 + 2);
  v27 = *(_OWORD *)((char *)a6 + 24);
  *(_OWORD *)(a1 + 232) = v27;
  *(_OWORD *)(a1 + 248) = *(_OWORD *)((char *)a6 + 40);
  *(_QWORD *)(a1 + 264) = *((_QWORD *)a6 + 7);
  *(_QWORD *)(a1 + 272) = a1 + 216;
  *(_QWORD *)(a1 + 280) = a1 + 288;
  *(_QWORD *)(a1 + 288) = 0;
  *(_QWORD *)(a1 + 296) = 0;
  if ((_QWORD)v27)
  {
    do
      v28 = __ldaxr((unsigned int *)v27);
    while (__stlxr(v28 + 1, (unsigned int *)v27));
  }
  if (*((int *)a6 + 1) > 2)
  {
    *(_DWORD *)(a1 + 212) = 0;
    cv::Mat::copySize((cv::Mat *)(a1 + 208), a6);
  }
  else
  {
    v29 = (_QWORD *)*((_QWORD *)a6 + 9);
    v30 = *(_QWORD **)(a1 + 280);
    *v30 = *v29;
    v30[1] = v29[1];
  }
  v31 = 0;
  *(double *)(a1 + 304) = a8;
  *(double *)(a1 + 312) = a9;
  do
  {
    *(_QWORD *)(a1 + v31 + 320) = *(_QWORD *)(a7 + v31);
    v31 += 8;
  }
  while (v31 != 32);
  return a1;
}

void sub_219E922D4(_Unwind_Exception *a1, void *a2)
{
  cv::Mat *v2;
  cv::Mat *v3;
  void *v5;

  cv::Mat::~Mat(v3, a2);
  cv::Mat::~Mat(v2, v5);
  _Unwind_Resume(a1);
}

void cv::getGlobalMatOpInitializer(cv *this)
{
  unsigned __int8 v1;

  if ((v1 & 1) == 0)
  {
    {
      cv::getGlobalMatOpInitializer(void)::initializer = (uint64_t)&off_24DBF1770;
    }
  }
}

void HMISimulateCrash_cold_1()
{
  homeai::mod::ImageDescriptorBufferAbstract *v0;

  dlerror();
  v0 = (homeai::mod::ImageDescriptorBufferAbstract *)abort_report_np();
  homeai::mod::ImageDescriptorBufferAbstract::~ImageDescriptorBufferAbstract(v0);
}

uint64_t __getVCPHomeKitAnalysisServiceClass_block_invoke_cold_1()
{
  uint64_t v0;

  v0 = abort_report_np();
  return __getVCPHomeKitAnalysisSessionClass_block_invoke_cold_1(v0);
}

uint64_t __getVCPHomeKitAnalysisSessionClass_block_invoke_cold_1()
{
  uint64_t v0;

  v0 = abort_report_np();
  return +[FaceRecognizabilityFilterSVM URLOfModelInThisBundle].cold.1(v0);
}

uint64_t AnalyticsSendEvent()
{
  return MEMORY[0x24BE1A1B0]();
}

uint64_t AnalyticsSendEventLazy()
{
  return MEMORY[0x24BE1A1C8]();
}

uint64_t CCCryptorGCMOneshotEncrypt()
{
  return MEMORY[0x24BDAC160]();
}

CCRNGStatus CCRandomGenerateBytes(void *bytes, size_t count)
{
  return MEMORY[0x24BDAC2D0](bytes, count);
}

unsigned __int8 *__cdecl CC_SHA1(const void *data, CC_LONG len, unsigned __int8 *md)
{
  return (unsigned __int8 *)MEMORY[0x24BDAC320](data, *(_QWORD *)&len, md);
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
  MEMORY[0x24BDBB7C8](theArray, value);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x24BDBB808](allocator, capacity, callBacks);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x24BDBB820](theArray);
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x24BDBB860](theArray, idx);
}

void CFArrayRemoveAllValues(CFMutableArrayRef theArray)
{
  MEMORY[0x24BDBB878](theArray);
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
  MEMORY[0x24BDBB880](theArray, idx);
}

void CFArraySetValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
  MEMORY[0x24BDBB898](theArray, idx, value);
}

void CFArraySortValues(CFMutableArrayRef theArray, CFRange range, CFComparatorFunction comparator, void *context)
{
  MEMORY[0x24BDBB8A0](theArray, range.location, range.length, comparator, context);
}

CFMutableBitVectorRef CFBitVectorCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return (CFMutableBitVectorRef)MEMORY[0x24BDBB9E0](allocator, capacity);
}

CFBit CFBitVectorGetBitAtIndex(CFBitVectorRef bv, CFIndex idx)
{
  return MEMORY[0x24BDBB9E8](bv, idx);
}

void CFBitVectorSetAllBits(CFMutableBitVectorRef bv, CFBit value)
{
  MEMORY[0x24BDBBA00](bv, *(_QWORD *)&value);
}

void CFBitVectorSetBitAtIndex(CFMutableBitVectorRef bv, CFIndex idx, CFBit value)
{
  MEMORY[0x24BDBBA08](bv, idx, *(_QWORD *)&value);
}

void CFBitVectorSetCount(CFMutableBitVectorRef bv, CFIndex count)
{
  MEMORY[0x24BDBBA10](bv, count);
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x24BDBBA20](BOOLean);
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x24BDBBDB0](theDict, key, value);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x24BDBBDD8](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x24BDBBDF0](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x24BDBBE18]();
}

Boolean CFDictionaryGetValueIfPresent(CFDictionaryRef theDict, const void *key, const void **value)
{
  return MEMORY[0x24BDBBE38](theDict, key, value);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x24BDBBE60](theDict, key, value);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x24BDBBEF8](cf);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x24BDBC0A0](allocator, theType, valuePtr);
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x24BDBC130](number, theType, valuePtr);
}

void CFRelease(CFTypeRef cf)
{
  MEMORY[0x24BDBC298](cf);
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x24BDBC2A8](cf);
}

CGAffineTransform *__cdecl CGAffineTransformConcat(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t1, CGAffineTransform *t2)
{
  return (CGAffineTransform *)MEMORY[0x24BDBD8A0](retstr, t1, t2);
}

CGAffineTransform *__cdecl CGAffineTransformMakeRotation(CGAffineTransform *__return_ptr retstr, CGFloat angle)
{
  return (CGAffineTransform *)MEMORY[0x24BDBD8D8](retstr, angle);
}

CGAffineTransform *__cdecl CGAffineTransformMakeScale(CGAffineTransform *__return_ptr retstr, CGFloat sx, CGFloat sy)
{
  return (CGAffineTransform *)MEMORY[0x24BDBD8E0](retstr, sx, sy);
}

CGAffineTransform *__cdecl CGAffineTransformMakeTranslation(CGAffineTransform *__return_ptr retstr, CGFloat tx, CGFloat ty)
{
  return (CGAffineTransform *)MEMORY[0x24BDBD8E8](retstr, tx, ty);
}

CGAffineTransform *__cdecl CGAffineTransformScale(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t, CGFloat sx, CGFloat sy)
{
  return (CGAffineTransform *)MEMORY[0x24BDBD900](retstr, t, sx, sy);
}

CGAffineTransform *__cdecl CGAffineTransformTranslate(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t, CGFloat tx, CGFloat ty)
{
  return (CGAffineTransform *)MEMORY[0x24BDBD908](retstr, t, tx, ty);
}

CGContextRef CGBitmapContextCreate(void *data, size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow, CGColorSpaceRef space, uint32_t bitmapInfo)
{
  return (CGContextRef)MEMORY[0x24BDBD918](data, width, height, bitsPerComponent, bytesPerRow, space, *(_QWORD *)&bitmapInfo);
}

CGColorRef CGColorCreate(CGColorSpaceRef space, const CGFloat *components)
{
  return (CGColorRef)MEMORY[0x24BDBDA78](space, components);
}

void CGColorRelease(CGColorRef color)
{
  MEMORY[0x24BDBDB40](color);
}

CGColorSpaceRef CGColorSpaceCreateDeviceGray(void)
{
  return (CGColorSpaceRef)MEMORY[0x24BDBDB80]();
}

CGColorSpaceRef CGColorSpaceCreateDeviceRGB(void)
{
  return (CGColorSpaceRef)MEMORY[0x24BDBDB88]();
}

void CGColorSpaceRelease(CGColorSpaceRef space)
{
  MEMORY[0x24BDBDC60](space);
}

CGColorSpaceRef CGColorSpaceRetain(CGColorSpaceRef space)
{
  return (CGColorSpaceRef)MEMORY[0x24BDBDC68](space);
}

void CGContextAddLineToPoint(CGContextRef c, CGFloat x, CGFloat y)
{
  MEMORY[0x24BDBDCD0](c, x, y);
}

void CGContextBeginPath(CGContextRef c)
{
  MEMORY[0x24BDBDD00](c);
}

void CGContextDrawImage(CGContextRef c, CGRect rect, CGImageRef image)
{
  MEMORY[0x24BDBDDD8](c, image, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGContextFillRect(CGContextRef c, CGRect rect)
{
  MEMORY[0x24BDBDE70](c, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGContextMoveToPoint(CGContextRef c, CGFloat x, CGFloat y)
{
  MEMORY[0x24BDBDF20](c, x, y);
}

void CGContextRelease(CGContextRef c)
{
  MEMORY[0x24BDBDF30](c);
}

void CGContextRestoreGState(CGContextRef c)
{
  MEMORY[0x24BDBDF58](c);
}

void CGContextSaveGState(CGContextRef c)
{
  MEMORY[0x24BDBDF70](c);
}

void CGContextScaleCTM(CGContextRef c, CGFloat sx, CGFloat sy)
{
  MEMORY[0x24BDBDF78](c, sx, sy);
}

void CGContextSetLineWidth(CGContextRef c, CGFloat width)
{
  MEMORY[0x24BDBE038](c, width);
}

void CGContextSetRGBFillColor(CGContextRef c, CGFloat red, CGFloat green, CGFloat blue, CGFloat alpha)
{
  MEMORY[0x24BDBE060](c, red, green, blue, alpha);
}

void CGContextSetRGBStrokeColor(CGContextRef c, CGFloat red, CGFloat green, CGFloat blue, CGFloat alpha)
{
  MEMORY[0x24BDBE068](c, red, green, blue, alpha);
}

void CGContextSetStrokeColor(CGContextRef c, const CGFloat *components)
{
  MEMORY[0x24BDBE0C0](c, components);
}

void CGContextSetTextPosition(CGContextRef c, CGFloat x, CGFloat y)
{
  MEMORY[0x24BDBE0F8](c, x, y);
}

void CGContextStrokePath(CGContextRef c)
{
  MEMORY[0x24BDBE118](c);
}

void CGContextStrokeRect(CGContextRef c, CGRect rect)
{
  MEMORY[0x24BDBE120](c, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGContextTranslateCTM(CGContextRef c, CGFloat tx, CGFloat ty)
{
  MEMORY[0x24BDBE130](c, tx, ty);
}

CGDataProviderRef CGDataProviderCreateWithCFData(CFDataRef data)
{
  return (CGDataProviderRef)MEMORY[0x24BDBE180](data);
}

CGDataProviderRef CGDataProviderCreateWithFilename(const char *filename)
{
  return (CGDataProviderRef)MEMORY[0x24BDBE198](filename);
}

void CGDataProviderRelease(CGDataProviderRef provider)
{
  MEMORY[0x24BDBE1C8](provider);
}

CGImageRef CGImageCreateWithJPEGDataProvider(CGDataProviderRef source, const CGFloat *decode, BOOL shouldInterpolate, CGColorRenderingIntent intent)
{
  return (CGImageRef)MEMORY[0x24BDBE608](source, decode, shouldInterpolate, *(_QWORD *)&intent);
}

CGColorSpaceRef CGImageGetColorSpace(CGImageRef image)
{
  return (CGColorSpaceRef)MEMORY[0x24BDBE658](image);
}

size_t CGImageGetHeight(CGImageRef image)
{
  return MEMORY[0x24BDBE680](image);
}

size_t CGImageGetWidth(CGImageRef image)
{
  return MEMORY[0x24BDBE6E0](image);
}

CFStringRef CGImageMetadataCopyStringValueWithPath(CGImageMetadataRef metadata, CGImageMetadataTagRef parent, CFStringRef path)
{
  return (CFStringRef)MEMORY[0x24BDD90A8](metadata, parent, path);
}

void CGImageRelease(CGImageRef image)
{
  MEMORY[0x24BDBE770](image);
}

CGImageMetadataRef CGImageSourceCopyMetadataAtIndex(CGImageSourceRef isrc, size_t index, CFDictionaryRef options)
{
  return (CGImageMetadataRef)MEMORY[0x24BDD9138](isrc, index, options);
}

CFDictionaryRef CGImageSourceCopyPropertiesAtIndex(CGImageSourceRef isrc, size_t index, CFDictionaryRef options)
{
  return (CFDictionaryRef)MEMORY[0x24BDD9148](isrc, index, options);
}

CGImageRef CGImageSourceCreateImageAtIndex(CGImageSourceRef isrc, size_t index, CFDictionaryRef options)
{
  return (CGImageRef)MEMORY[0x24BDD9158](isrc, index, options);
}

CGImageSourceRef CGImageSourceCreateWithData(CFDataRef data, CFDictionaryRef options)
{
  return (CGImageSourceRef)MEMORY[0x24BDD9170](data, options);
}

void CGPathAddLineToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat x, CGFloat y)
{
  MEMORY[0x24BDBEDC8](path, m, x, y);
}

BOOL CGPathContainsPoint(CGPathRef path, const CGAffineTransform *m, CGPoint point, BOOL eoFill)
{
  return MEMORY[0x24BDBEE28](path, m, eoFill, (__n128)point, *(__n128 *)&point.y);
}

CGMutablePathRef CGPathCreateMutable(void)
{
  return (CGMutablePathRef)MEMORY[0x24BDBEE80]();
}

CGPathRef CGPathCreateWithRect(CGRect rect, const CGAffineTransform *transform)
{
  return (CGPathRef)MEMORY[0x24BDBEEA8](transform, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGPathMoveToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat x, CGFloat y)
{
  MEMORY[0x24BDBEF40](path, m, x, y);
}

void CGPathRelease(CGPathRef path)
{
  MEMORY[0x24BDBEF48](path);
}

CFDictionaryRef CGPointCreateDictionaryRepresentation(CGPoint point)
{
  return (CFDictionaryRef)MEMORY[0x24BDBEF98]((__n128)point, *(__n128 *)&point.y);
}

CGRect CGRectApplyAffineTransform(CGRect rect, CGAffineTransform *t)
{
  double v2;
  double v3;
  double v4;
  double v5;
  CGRect result;

  MEMORY[0x24BDBEFB8](t, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  result.size.height = v5;
  result.size.width = v4;
  result.origin.y = v3;
  result.origin.x = v2;
  return result;
}

BOOL CGRectContainsPoint(CGRect rect, CGPoint point)
{
  return MEMORY[0x24BDBEFC0]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height, (__n128)point, *(__n128 *)&point.y);
}

CFDictionaryRef CGRectCreateDictionaryRepresentation(CGRect a1)
{
  return (CFDictionaryRef)MEMORY[0x24BDBEFD0]((__n128)a1.origin, *(__n128 *)&a1.origin.y, (__n128)a1.size, *(__n128 *)&a1.size.height);
}

void CGRectDivide(CGRect rect, CGRect *slice, CGRect *remainder, CGFloat amount, CGRectEdge edge)
{
  MEMORY[0x24BDBEFD8](slice, remainder, *(_QWORD *)&edge, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height, amount);
}

BOOL CGRectEqualToRect(CGRect rect1, CGRect rect2)
{
  return MEMORY[0x24BDBEFE0]((__n128)rect1.origin, *(__n128 *)&rect1.origin.y, (__n128)rect1.size, *(__n128 *)&rect1.size.height, (__n128)rect2.origin, *(__n128 *)&rect2.origin.y, (__n128)rect2.size, *(__n128 *)&rect2.size.height);
}

CGFloat CGRectGetHeight(CGRect rect)
{
  CGFloat result;

  MEMORY[0x24BDBEFE8]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMaxX(CGRect rect)
{
  CGFloat result;

  MEMORY[0x24BDBEFF0]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMaxY(CGRect rect)
{
  CGFloat result;

  MEMORY[0x24BDBEFF8]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMidX(CGRect rect)
{
  CGFloat result;

  MEMORY[0x24BDBF000]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMidY(CGRect rect)
{
  CGFloat result;

  MEMORY[0x24BDBF008]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMinX(CGRect rect)
{
  CGFloat result;

  MEMORY[0x24BDBF010]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMinY(CGRect rect)
{
  CGFloat result;

  MEMORY[0x24BDBF018]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetWidth(CGRect rect)
{
  CGFloat result;

  MEMORY[0x24BDBF020]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGRect CGRectInset(CGRect rect, CGFloat dx, CGFloat dy)
{
  double v3;
  double v4;
  double v5;
  double v6;
  CGRect result;

  MEMORY[0x24BDBF030]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height, dx, dy);
  result.size.height = v6;
  result.size.width = v5;
  result.origin.y = v4;
  result.origin.x = v3;
  return result;
}

CGRect CGRectIntegral(CGRect rect)
{
  double v1;
  double v2;
  double v3;
  double v4;
  CGRect result;

  MEMORY[0x24BDBF038]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  result.size.height = v4;
  result.size.width = v3;
  result.origin.y = v2;
  result.origin.x = v1;
  return result;
}

CGRect CGRectIntersection(CGRect r1, CGRect r2)
{
  double v2;
  double v3;
  double v4;
  double v5;
  CGRect result;

  MEMORY[0x24BDBF040]((__n128)r1.origin, *(__n128 *)&r1.origin.y, (__n128)r1.size, *(__n128 *)&r1.size.height, (__n128)r2.origin, *(__n128 *)&r2.origin.y, (__n128)r2.size, *(__n128 *)&r2.size.height);
  result.size.height = v5;
  result.size.width = v4;
  result.origin.y = v3;
  result.origin.x = v2;
  return result;
}

BOOL CGRectIntersectsRect(CGRect rect1, CGRect rect2)
{
  return MEMORY[0x24BDBF048]((__n128)rect1.origin, *(__n128 *)&rect1.origin.y, (__n128)rect1.size, *(__n128 *)&rect1.size.height, (__n128)rect2.origin, *(__n128 *)&rect2.origin.y, (__n128)rect2.size, *(__n128 *)&rect2.size.height);
}

BOOL CGRectIsEmpty(CGRect rect)
{
  return MEMORY[0x24BDBF050]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

BOOL CGRectIsInfinite(CGRect rect)
{
  return MEMORY[0x24BDBF058]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

BOOL CGRectIsNull(CGRect rect)
{
  return MEMORY[0x24BDBF060]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

BOOL CGRectMakeWithDictionaryRepresentation(CFDictionaryRef dict, CGRect *rect)
{
  return MEMORY[0x24BDBF068](dict, rect);
}

CGRect CGRectStandardize(CGRect rect)
{
  double v1;
  double v2;
  double v3;
  double v4;
  CGRect result;

  MEMORY[0x24BDBF080]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  result.size.height = v4;
  result.size.width = v3;
  result.origin.y = v2;
  result.origin.x = v1;
  return result;
}

CGRect CGRectUnion(CGRect r1, CGRect r2)
{
  double v2;
  double v3;
  double v4;
  double v5;
  CGRect result;

  MEMORY[0x24BDBF088]((__n128)r1.origin, *(__n128 *)&r1.origin.y, (__n128)r1.size, *(__n128 *)&r1.size.height, (__n128)r2.origin, *(__n128 *)&r2.origin.y, (__n128)r2.size, *(__n128 *)&r2.size.height);
  result.size.height = v5;
  result.size.width = v4;
  result.origin.y = v3;
  result.origin.x = v2;
  return result;
}

const AudioStreamBasicDescription *__cdecl CMAudioFormatDescriptionGetStreamBasicDescription(CMAudioFormatDescriptionRef desc)
{
  return (const AudioStreamBasicDescription *)MEMORY[0x24BDC0058](desc);
}

uint64_t CMBaseObjectGetVTable()
{
  return MEMORY[0x24BDC0090]();
}

OSStatus CMBlockBufferCopyDataBytes(CMBlockBufferRef theSourceBuffer, size_t offsetToData, size_t dataLength, void *destination)
{
  return MEMORY[0x24BDC00B0](theSourceBuffer, offsetToData, dataLength, destination);
}

OSStatus CMBlockBufferCreateWithMemoryBlock(CFAllocatorRef structureAllocator, void *memoryBlock, size_t blockLength, CFAllocatorRef blockAllocator, const CMBlockBufferCustomBlockSource *customBlockSource, size_t offsetToData, size_t dataLength, CMBlockBufferFlags flags, CMBlockBufferRef *blockBufferOut)
{
  return MEMORY[0x24BDC00C0](structureAllocator, memoryBlock, blockLength, blockAllocator, customBlockSource, offsetToData, dataLength, *(_QWORD *)&flags);
}

size_t CMBlockBufferGetDataLength(CMBlockBufferRef theBuffer)
{
  return MEMORY[0x24BDC00D0](theBuffer);
}

OSStatus CMBufferQueueCreate(CFAllocatorRef allocator, CMItemCount capacity, const CMBufferCallbacks *callbacks, CMBufferQueueRef *queueOut)
{
  return MEMORY[0x24BDC0100](allocator, capacity, callbacks, queueOut);
}

CMBufferRef CMBufferQueueDequeueAndRetain(CMBufferQueueRef queue)
{
  return (CMBufferRef)MEMORY[0x24BDC0108](queue);
}

OSStatus CMBufferQueueEnqueue(CMBufferQueueRef queue, CMBufferRef buf)
{
  return MEMORY[0x24BDC0110](queue, buf);
}

CMItemCount CMBufferQueueGetBufferCount(CMBufferQueueRef queue)
{
  return MEMORY[0x24BDC0118](queue);
}

const CMBufferCallbacks *CMBufferQueueGetCallbacksForSampleBuffersSortedByOutputPTS(void)
{
  return (const CMBufferCallbacks *)MEMORY[0x24BDC0120]();
}

Boolean CMBufferQueueIsEmpty(CMBufferQueueRef queue)
{
  return MEMORY[0x24BDC0130](queue);
}

uint64_t CMByteStreamCreateForBlockBuffer()
{
  return MEMORY[0x24BDC0140]();
}

Boolean CMFormatDescriptionEqual(CMFormatDescriptionRef formatDescription, CMFormatDescriptionRef otherFormatDescription)
{
  return MEMORY[0x24BDC0190](formatDescription, otherFormatDescription);
}

CMMediaType CMFormatDescriptionGetMediaType(CMFormatDescriptionRef desc)
{
  return MEMORY[0x24BDC01D0](desc);
}

CFTypeRef CMGetAttachment(CMAttachmentBearerRef target, CFStringRef key, CMAttachmentMode *attachmentModeOut)
{
  return (CFTypeRef)MEMORY[0x24BDC01E0](target, key, attachmentModeOut);
}

uint64_t CMPhotoCompressionSessionAddImage()
{
  return MEMORY[0x24BE11E80]();
}

uint64_t CMPhotoCompressionSessionCloseContainerAndCopyBacking()
{
  return MEMORY[0x24BE11EB0]();
}

uint64_t CMPhotoCompressionSessionCreate()
{
  return MEMORY[0x24BE11EB8]();
}

uint64_t CMPhotoCompressionSessionDiscardCaches()
{
  return MEMORY[0x24BE11EC0]();
}

uint64_t CMPhotoCompressionSessionInvalidate()
{
  return MEMORY[0x24BE11ED0]();
}

uint64_t CMPhotoCompressionSessionOpenEmptyContainer()
{
  return MEMORY[0x24BE11EE0]();
}

uint64_t CMPhotoCompressionSessionReleaseHardwareResources()
{
  return MEMORY[0x24BE11EF0]();
}

void CMRemoveAttachment(CMAttachmentBearerRef target, CFStringRef key)
{
  MEMORY[0x24BDC0260](target, key);
}

OSStatus CMSampleBufferCreateCopyWithNewTiming(CFAllocatorRef allocator, CMSampleBufferRef originalSBuf, CMItemCount numSampleTimingEntries, const CMSampleTimingInfo *sampleTimingArray, CMSampleBufferRef *sampleBufferOut)
{
  return MEMORY[0x24BDC0280](allocator, originalSBuf, numSampleTimingEntries, sampleTimingArray, sampleBufferOut);
}

OSStatus CMSampleBufferCreateForImageBuffer(CFAllocatorRef allocator, CVImageBufferRef imageBuffer, Boolean dataReady, CMSampleBufferMakeDataReadyCallback makeDataReadyCallback, void *makeDataReadyRefcon, CMVideoFormatDescriptionRef formatDescription, const CMSampleTimingInfo *sampleTiming, CMSampleBufferRef *sampleBufferOut)
{
  return MEMORY[0x24BDC0290](allocator, imageBuffer, dataReady, makeDataReadyCallback, makeDataReadyRefcon, formatDescription, sampleTiming, sampleBufferOut);
}

OSStatus CMSampleBufferCreateReadyWithImageBuffer(CFAllocatorRef allocator, CVImageBufferRef imageBuffer, CMVideoFormatDescriptionRef formatDescription, const CMSampleTimingInfo *sampleTiming, CMSampleBufferRef *sampleBufferOut)
{
  return MEMORY[0x24BDC02A0](allocator, imageBuffer, formatDescription, sampleTiming, sampleBufferOut);
}

CMTime *__cdecl CMSampleBufferGetDecodeTimeStamp(CMTime *__return_ptr retstr, CMSampleBufferRef sbuf)
{
  return (CMTime *)MEMORY[0x24BDC02C8](retstr, sbuf);
}

CMTime *__cdecl CMSampleBufferGetDuration(CMTime *__return_ptr retstr, CMSampleBufferRef sbuf)
{
  return (CMTime *)MEMORY[0x24BDC02D0](retstr, sbuf);
}

CMFormatDescriptionRef CMSampleBufferGetFormatDescription(CMSampleBufferRef sbuf)
{
  return (CMFormatDescriptionRef)MEMORY[0x24BDC02E0](sbuf);
}

CVImageBufferRef CMSampleBufferGetImageBuffer(CMSampleBufferRef sbuf)
{
  return (CVImageBufferRef)MEMORY[0x24BDC02E8](sbuf);
}

CMItemCount CMSampleBufferGetNumSamples(CMSampleBufferRef sbuf)
{
  return MEMORY[0x24BDC0300](sbuf);
}

CMTime *__cdecl CMSampleBufferGetPresentationTimeStamp(CMTime *__return_ptr retstr, CMSampleBufferRef sbuf)
{
  return (CMTime *)MEMORY[0x24BDC0320](retstr, sbuf);
}

CFArrayRef CMSampleBufferGetSampleAttachmentsArray(CMSampleBufferRef sbuf, Boolean createIfNecessary)
{
  return (CFArrayRef)MEMORY[0x24BDC0330](sbuf, createIfNecessary);
}

OSStatus CMSampleBufferGetSampleTimingInfoArray(CMSampleBufferRef sbuf, CMItemCount numSampleTimingEntries, CMSampleTimingInfo *timingArrayOut, CMItemCount *timingArrayEntriesNeededOut)
{
  return MEMORY[0x24BDC0348](sbuf, numSampleTimingEntries, timingArrayOut, timingArrayEntriesNeededOut);
}

size_t CMSampleBufferGetTotalSampleSize(CMSampleBufferRef sbuf)
{
  return MEMORY[0x24BDC0358](sbuf);
}

void CMSetAttachment(CMAttachmentBearerRef target, CFStringRef key, CFTypeRef value, CMAttachmentMode attachmentMode)
{
  MEMORY[0x24BDC0380](target, key, value, *(_QWORD *)&attachmentMode);
}

CMTime *__cdecl CMTimeAbsoluteValue(CMTime *__return_ptr retstr, CMTime *time)
{
  return (CMTime *)MEMORY[0x24BDC0418](retstr, time);
}

CMTime *__cdecl CMTimeAdd(CMTime *__return_ptr retstr, CMTime *lhs, CMTime *rhs)
{
  return (CMTime *)MEMORY[0x24BDC0420](retstr, lhs, rhs);
}

int32_t CMTimeCompare(CMTime *time1, CMTime *time2)
{
  return MEMORY[0x24BDC0450](time1, time2);
}

CMTime *__cdecl CMTimeConvertScale(CMTime *__return_ptr retstr, CMTime *time, int32_t newTimescale, CMTimeRoundingMethod method)
{
  return (CMTime *)MEMORY[0x24BDC0460](retstr, time, *(_QWORD *)&newTimescale, *(_QWORD *)&method);
}

CFDictionaryRef CMTimeCopyAsDictionary(CMTime *time, CFAllocatorRef allocator)
{
  return (CFDictionaryRef)MEMORY[0x24BDC0468](time, allocator);
}

CFStringRef CMTimeCopyDescription(CFAllocatorRef allocator, CMTime *time)
{
  return (CFStringRef)MEMORY[0x24BDC0478](allocator, time);
}

uint64_t CMTimeDivide()
{
  return MEMORY[0x24BDC0480]();
}

Float64 CMTimeGetSeconds(CMTime *time)
{
  Float64 result;

  MEMORY[0x24BDC0490](time);
  return result;
}

CMTime *__cdecl CMTimeMake(CMTime *__return_ptr retstr, int64_t value, int32_t timescale)
{
  return (CMTime *)MEMORY[0x24BDC0498](retstr, value, *(_QWORD *)&timescale);
}

CMTime *__cdecl CMTimeMakeFromDictionary(CMTime *__return_ptr retstr, CFDictionaryRef dictionaryRepresentation)
{
  return (CMTime *)MEMORY[0x24BDC04A8](retstr, dictionaryRepresentation);
}

CMTime *__cdecl CMTimeMakeWithSeconds(CMTime *__return_ptr retstr, Float64 seconds, int32_t preferredTimescale)
{
  return (CMTime *)MEMORY[0x24BDC04C0](retstr, *(_QWORD *)&preferredTimescale, seconds);
}

CMTime *__cdecl CMTimeMaximum(CMTime *__return_ptr retstr, CMTime *time1, CMTime *time2)
{
  return (CMTime *)MEMORY[0x24BDC04D8](retstr, time1, time2);
}

CMTime *__cdecl CMTimeMinimum(CMTime *__return_ptr retstr, CMTime *time1, CMTime *time2)
{
  return (CMTime *)MEMORY[0x24BDC04E0](retstr, time1, time2);
}

CMTime *__cdecl CMTimeMultiplyByRatio(CMTime *__return_ptr retstr, CMTime *time, int32_t multiplier, int32_t divisor)
{
  return (CMTime *)MEMORY[0x24BDC04F8](retstr, time, *(_QWORD *)&multiplier, *(_QWORD *)&divisor);
}

Boolean CMTimeRangeContainsTime(CMTimeRange *range, CMTime *time)
{
  return MEMORY[0x24BDC0508](range, time);
}

CFStringRef CMTimeRangeCopyDescription(CFAllocatorRef allocator, CMTimeRange *range)
{
  return (CFStringRef)MEMORY[0x24BDC0530](allocator, range);
}

CMTimeRange *__cdecl CMTimeRangeFromTimeToTime(CMTimeRange *__return_ptr retstr, CMTime *start, CMTime *end)
{
  return (CMTimeRange *)MEMORY[0x24BDC0550](retstr, start, end);
}

CMTime *__cdecl CMTimeRangeGetEnd(CMTime *__return_ptr retstr, CMTimeRange *range)
{
  return (CMTime *)MEMORY[0x24BDC0558](retstr, range);
}

CMTimeRange *__cdecl CMTimeRangeGetUnion(CMTimeRange *__return_ptr retstr, CMTimeRange *range, CMTimeRange *otherRange)
{
  return (CMTimeRange *)MEMORY[0x24BDC0570](retstr, range, otherRange);
}

CMTimeRange *__cdecl CMTimeRangeMake(CMTimeRange *__return_ptr retstr, CMTime *start, CMTime *duration)
{
  return (CMTimeRange *)MEMORY[0x24BDC0580](retstr, start, duration);
}

CMTime *__cdecl CMTimeSubtract(CMTime *__return_ptr retstr, CMTime *lhs, CMTime *rhs)
{
  return (CMTime *)MEMORY[0x24BDC05A0](retstr, lhs, rhs);
}

OSStatus CMVideoFormatDescriptionCreateForImageBuffer(CFAllocatorRef allocator, CVImageBufferRef imageBuffer, CMVideoFormatDescriptionRef *formatDescriptionOut)
{
  return MEMORY[0x24BDC0648](allocator, imageBuffer, formatDescriptionOut);
}

CMVideoDimensions CMVideoFormatDescriptionGetDimensions(CMVideoFormatDescriptionRef videoDesc)
{
  return (CMVideoDimensions)MEMORY[0x24BDC0668](videoDesc);
}

CTFontRef CTFontCreateCopyWithAttributes(CTFontRef font, CGFloat size, const CGAffineTransform *matrix, CTFontDescriptorRef attributes)
{
  return (CTFontRef)MEMORY[0x24BDC4788](font, matrix, attributes, size);
}

CTFontRef CTFontCreateUIFontForLanguage(CTFontUIFontType uiType, CGFloat size, CFStringRef language)
{
  return (CTFontRef)MEMORY[0x24BDC47A8](*(_QWORD *)&uiType, language, size);
}

CTFontDescriptorRef CTFontDescriptorCreateWithAttributes(CFDictionaryRef attributes)
{
  return (CTFontDescriptorRef)MEMORY[0x24BDC4830](attributes);
}

CTLineRef CTLineCreateWithAttributedString(CFAttributedStringRef attrString)
{
  return (CTLineRef)MEMORY[0x24BDC4A30](attrString);
}

void CTLineDraw(CTLineRef line, CGContextRef context)
{
  MEMORY[0x24BDC4A68](line, context);
}

void CVBufferRelease(CVBufferRef buffer)
{
  MEMORY[0x24BDC5168](buffer);
}

CVReturn CVPixelBufferCreate(CFAllocatorRef allocator, size_t width, size_t height, OSType pixelFormatType, CFDictionaryRef pixelBufferAttributes, CVPixelBufferRef *pixelBufferOut)
{
  return MEMORY[0x24BDC5248](allocator, width, height, *(_QWORD *)&pixelFormatType, pixelBufferAttributes, pixelBufferOut);
}

CVReturn CVPixelBufferCreateWithIOSurface(CFAllocatorRef allocator, IOSurfaceRef surface, CFDictionaryRef pixelBufferAttributes, CVPixelBufferRef *pixelBufferOut)
{
  return MEMORY[0x24BDC5258](allocator, surface, pixelBufferAttributes, pixelBufferOut);
}

void *__cdecl CVPixelBufferGetBaseAddress(CVPixelBufferRef pixelBuffer)
{
  return (void *)MEMORY[0x24BDC5278](pixelBuffer);
}

void *__cdecl CVPixelBufferGetBaseAddressOfPlane(CVPixelBufferRef pixelBuffer, size_t planeIndex)
{
  return (void *)MEMORY[0x24BDC5288](pixelBuffer, planeIndex);
}

size_t CVPixelBufferGetBytesPerRow(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x24BDC5290](pixelBuffer);
}

size_t CVPixelBufferGetBytesPerRowOfPlane(CVPixelBufferRef pixelBuffer, size_t planeIndex)
{
  return MEMORY[0x24BDC5298](pixelBuffer, planeIndex);
}

size_t CVPixelBufferGetHeight(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x24BDC52B0](pixelBuffer);
}

size_t CVPixelBufferGetHeightOfPlane(CVPixelBufferRef pixelBuffer, size_t planeIndex)
{
  return MEMORY[0x24BDC52B8](pixelBuffer, planeIndex);
}

IOSurfaceRef CVPixelBufferGetIOSurface(CVPixelBufferRef pixelBuffer)
{
  return (IOSurfaceRef)MEMORY[0x24BDC52C0](pixelBuffer);
}

OSType CVPixelBufferGetPixelFormatType(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x24BDC52D0](pixelBuffer);
}

size_t CVPixelBufferGetPlaneCount(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x24BDC52D8](pixelBuffer);
}

size_t CVPixelBufferGetWidth(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x24BDC52E8](pixelBuffer);
}

size_t CVPixelBufferGetWidthOfPlane(CVPixelBufferRef pixelBuffer, size_t planeIndex)
{
  return MEMORY[0x24BDC52F0](pixelBuffer, planeIndex);
}

Boolean CVPixelBufferIsPlanar(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x24BDC52F8](pixelBuffer);
}

CVReturn CVPixelBufferLockBaseAddress(CVPixelBufferRef pixelBuffer, CVPixelBufferLockFlags lockFlags)
{
  return MEMORY[0x24BDC5308](pixelBuffer, lockFlags);
}

void CVPixelBufferRelease(CVPixelBufferRef texture)
{
  MEMORY[0x24BDC5398](texture);
}

CVPixelBufferRef CVPixelBufferRetain(CVPixelBufferRef texture)
{
  return (CVPixelBufferRef)MEMORY[0x24BDC53A0](texture);
}

CVReturn CVPixelBufferUnlockBaseAddress(CVPixelBufferRef pixelBuffer, CVPixelBufferLockFlags unlockFlags)
{
  return MEMORY[0x24BDC53B0](pixelBuffer, unlockFlags);
}

uint64_t CacheDeleteCopyAvailableSpaceForVolume()
{
  return MEMORY[0x24BE12308]();
}

uint64_t FigCFNumberCreateFloat64()
{
  return MEMORY[0x24BDC0760]();
}

uint64_t FigCFNumberCreateSInt32()
{
  return MEMORY[0x24BDC0768]();
}

uint64_t FigFormatReaderCreateForStreamReturningResults()
{
  return MEMORY[0x24BDDCDC0]();
}

uint64_t FigFormatReaderGetFigBaseObject()
{
  return MEMORY[0x24BDDCDC8]();
}

uint64_t FigTrackReaderGetFigBaseObject()
{
  return MEMORY[0x24BDDCE20]();
}

uint64_t HMFBooleanToString()
{
  return MEMORY[0x24BE3EA00]();
}

uint64_t HMFCreateOSLogHandle()
{
  return MEMORY[0x24BE3EA08]();
}

uint64_t HMFEqualObjects()
{
  return MEMORY[0x24BE3EBA8]();
}

uint64_t HMFGetLogIdentifier()
{
  return MEMORY[0x24BE3EBB8]();
}

uint64_t HMFGetOSLogHandle()
{
  return MEMORY[0x24BE3EBC0]();
}

uint64_t HMFGetOsLogHandle()
{
  return MEMORY[0x24BE3EBC8]();
}

uint64_t HMFObjectDescription()
{
  return MEMORY[0x24BE3EC10]();
}

uint64_t HMFProductClassToString()
{
  return MEMORY[0x24BE3EC60]();
}

uint64_t HMStringFromCameraClipQuality()
{
  return MEMORY[0x24BDD6F10]();
}

uint64_t HMStringFromCameraSignificantEventConfidenceLevel()
{
  return MEMORY[0x24BDD6F18]();
}

uint64_t HMStringFromCameraSignificantEventReason()
{
  return MEMORY[0x24BDD6F20]();
}

uint64_t IOHIDEventGetFloatValue()
{
  return MEMORY[0x24BDD8290]();
}

CFArrayRef IOHIDEventSystemClientCopyServices(IOHIDEventSystemClientRef client)
{
  return (CFArrayRef)MEMORY[0x24BDD8360](client);
}

uint64_t IOHIDEventSystemClientCreate()
{
  return MEMORY[0x24BDD8368]();
}

uint64_t IOHIDEventSystemClientSetMatching()
{
  return MEMORY[0x24BDD83D8]();
}

uint64_t IOHIDServiceClientCopyEvent()
{
  return MEMORY[0x24BDD8528]();
}

uint64_t MGCopyAnswer()
{
  return MEMORY[0x24BED8448]();
}

uint64_t MGGetBoolAnswer()
{
  return MEMORY[0x24BED8470]();
}

uint64_t MGGetProductType()
{
  return MEMORY[0x24BED8488]();
}

Class NSClassFromString(NSString *aClassName)
{
  return (Class)MEMORY[0x24BDD0B80](aClassName);
}

uint64_t NSLocalizedFileSizeDescription()
{
  return MEMORY[0x24BDD0FE0]();
}

void NSLog(NSString *format, ...)
{
  MEMORY[0x24BDD1000](format);
}

uint64_t NSPrintF()
{
  return MEMORY[0x24BE296C0]();
}

uint64_t NSRandomData()
{
  return MEMORY[0x24BE296E0]();
}

NSRange NSRangeFromString(NSString *aString)
{
  NSUInteger v1;
  NSUInteger v2;
  NSRange result;

  v1 = MEMORY[0x24BDD11C8](aString);
  result.length = v2;
  result.location = v1;
  return result;
}

SEL NSSelectorFromString(NSString *aSelectorName)
{
  return (SEL)MEMORY[0x24BDD1218](aSelectorName);
}

NSString *__cdecl NSStringFromClass(Class aClass)
{
  return (NSString *)MEMORY[0x24BDD1240](aClass);
}

NSString *__cdecl NSStringFromRange(NSRange range)
{
  return (NSString *)MEMORY[0x24BDD1258](range.location, range.length);
}

NSString *__cdecl NSStringFromRect(NSRect aRect)
{
  return (NSString *)MEMORY[0x24BDD1260]((__n128)aRect.origin, *(__n128 *)&aRect.origin.y, (__n128)aRect.size, *(__n128 *)&aRect.size.height);
}

NSString *__cdecl NSStringFromSelector(SEL aSelector)
{
  return (NSString *)MEMORY[0x24BDD1268](aSelector);
}

NSString *NSTemporaryDirectory(void)
{
  return (NSString *)MEMORY[0x24BDD1280]();
}

int32_t NSVersionOfRunTimeLibrary(const char *libraryName)
{
  return MEMORY[0x24BDAC4B0](libraryName);
}

uint64_t SecPolicyCreateAppleSSLPinned()
{
  return MEMORY[0x24BDE8C20]();
}

BOOL SecTrustEvaluateWithError(SecTrustRef trust, CFErrorRef *error)
{
  return MEMORY[0x24BDE8DF0](trust, error);
}

OSStatus SecTrustSetPolicies(SecTrustRef trust, CFTypeRef policies)
{
  return MEMORY[0x24BDE8E50](trust, policies);
}

OSStatus VTCompressionSessionCompleteFrames(VTCompressionSessionRef session, CMTime *completeUntilPresentationTimeStamp)
{
  return MEMORY[0x24BDF8FD0](session, completeUntilPresentationTimeStamp);
}

OSStatus VTCompressionSessionCreate(CFAllocatorRef allocator, int32_t width, int32_t height, CMVideoCodecType codecType, CFDictionaryRef encoderSpecification, CFDictionaryRef sourceImageBufferAttributes, CFAllocatorRef compressedDataAllocator, VTCompressionOutputCallback outputCallback, void *outputCallbackRefCon, VTCompressionSessionRef *compressionSessionOut)
{
  return MEMORY[0x24BDF8FD8](allocator, *(_QWORD *)&width, *(_QWORD *)&height, *(_QWORD *)&codecType, encoderSpecification, sourceImageBufferAttributes, compressedDataAllocator, outputCallback);
}

OSStatus VTCompressionSessionEncodeFrameWithOutputHandler(VTCompressionSessionRef session, CVImageBufferRef imageBuffer, CMTime *presentationTimeStamp, CMTime *duration, CFDictionaryRef frameProperties, VTEncodeInfoFlags *infoFlagsOut, VTCompressionOutputHandler outputHandler)
{
  return MEMORY[0x24BDF8FF0](session, imageBuffer, presentationTimeStamp, duration, frameProperties, infoFlagsOut, outputHandler);
}

void VTCompressionSessionInvalidate(VTCompressionSessionRef session)
{
  MEMORY[0x24BDF9008](session);
}

OSStatus VTCompressionSessionPrepareToEncodeFrames(VTCompressionSessionRef session)
{
  return MEMORY[0x24BDF9010](session);
}

Boolean VTDecompressionSessionCanAcceptFormatDescription(VTDecompressionSessionRef session, CMFormatDescriptionRef newFormatDesc)
{
  return MEMORY[0x24BDF9058](session, newFormatDesc);
}

OSStatus VTDecompressionSessionCreate(CFAllocatorRef allocator, CMVideoFormatDescriptionRef videoFormatDescription, CFDictionaryRef videoDecoderSpecification, CFDictionaryRef destinationImageBufferAttributes, const VTDecompressionOutputCallbackRecord *outputCallback, VTDecompressionSessionRef *decompressionSessionOut)
{
  return MEMORY[0x24BDF9060](allocator, videoFormatDescription, videoDecoderSpecification, destinationImageBufferAttributes, outputCallback, decompressionSessionOut);
}

OSStatus VTDecompressionSessionDecodeFrame(VTDecompressionSessionRef session, CMSampleBufferRef sampleBuffer, VTDecodeFrameFlags decodeFlags, void *sourceFrameRefCon, VTDecodeInfoFlags *infoFlagsOut)
{
  return MEMORY[0x24BDF9068](session, sampleBuffer, *(_QWORD *)&decodeFlags, sourceFrameRefCon, infoFlagsOut);
}

void VTDecompressionSessionInvalidate(VTDecompressionSessionRef session)
{
  MEMORY[0x24BDF9088](session);
}

OSStatus VTDecompressionSessionWaitForAsynchronousFrames(VTDecompressionSessionRef session)
{
  return MEMORY[0x24BDF9090](session);
}

OSStatus VTPixelTransferSessionCreate(CFAllocatorRef allocator, VTPixelTransferSessionRef *pixelTransferSessionOut)
{
  return MEMORY[0x24BDF9168](allocator, pixelTransferSessionOut);
}

void VTPixelTransferSessionInvalidate(VTPixelTransferSessionRef session)
{
  MEMORY[0x24BDF9170](session);
}

OSStatus VTPixelTransferSessionTransferImage(VTPixelTransferSessionRef session, CVPixelBufferRef sourceBuffer, CVPixelBufferRef destinationBuffer)
{
  return MEMORY[0x24BDF9178](session, sourceBuffer, destinationBuffer);
}

OSStatus VTSessionCopyProperty(VTSessionRef session, CFStringRef propertyKey, CFAllocatorRef allocator, void *propertyValueOut)
{
  return MEMORY[0x24BDF9198](session, propertyKey, allocator, propertyValueOut);
}

OSStatus VTSessionSetProperty(VTSessionRef session, CFStringRef propertyKey, CFTypeRef propertyValue)
{
  return MEMORY[0x24BDF91A8](session, propertyKey, propertyValue);
}

void _Block_object_dispose(const void *a1, const int a2)
{
  MEMORY[0x24BDAC730](a1, *(_QWORD *)&a2);
}

uint64_t _HMFPreconditionFailure()
{
  return MEMORY[0x24BE3F2D0]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
  MEMORY[0x24BDAC780](exception_object);
}

uint64_t std::stringbuf::str()
{
  return MEMORY[0x24BEDA9E0]();
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x24BEDAA60](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x24BEDAA70](this);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x24BEDAAA8](this, a2);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const char *a2)
{
  return (std::runtime_error *)MEMORY[0x24BEDAB30](this, a2);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x24BEDABB0](this);
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x24BEDABE8](__n);
}

void std::string::~string(std::string *this)
{
  MEMORY[0x24BEDACF0](this);
}

uint64_t std::ostream::put()
{
  return MEMORY[0x24BEDAEE0]();
}

uint64_t std::ostream::flush()
{
  return MEMORY[0x24BEDAEE8]();
}

uint64_t std::ostream::sentry::sentry()
{
  return MEMORY[0x24BEDAEF8]();
}

uint64_t std::ostream::sentry::~sentry()
{
  return MEMORY[0x24BEDAF00]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x24BEDAF40]();
}

{
  return MEMORY[0x24BEDAF60]();
}

uint64_t std::iostream::~basic_iostream()
{
  return MEMORY[0x24BEDB010]();
}

uint64_t std::streambuf::basic_streambuf()
{
  return MEMORY[0x24BEDB048]();
}

uint64_t std::streambuf::~streambuf()
{
  return MEMORY[0x24BEDB050]();
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
  MEMORY[0x24BEDB180](this);
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
  MEMORY[0x24BEDB190](this);
}

void std::locale::~locale(std::locale *this)
{
  MEMORY[0x24BEDB448](this);
}

void std::ios_base::__set_badbit_and_consider_rethrow(std::ios_base *this)
{
  MEMORY[0x24BEDB500](this);
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
  MEMORY[0x24BEDB518](this, __sb);
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
  MEMORY[0x24BEDB530](this, *(_QWORD *)&__state);
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x24BEDB5E8]();
}

void std::exception::~exception(std::exception *this)
{
  MEMORY[0x24BEDB688](this);
}

void std::terminate(void)
{
  MEMORY[0x24BEDB6C0]();
}

uint64_t operator delete[]()
{
  return off_24DBE9218();
}

void operator delete(void *__p)
{
  off_24DBE9220(__p);
}

uint64_t operator delete()
{
  return off_24DBE9228();
}

uint64_t operator new[]()
{
  return off_24DBE9230();
}

void *__cdecl operator new(size_t __sz)
{
  return (void *)off_24DBE9238(__sz);
}

uint64_t operator new()
{
  return off_24DBE9240();
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
  MEMORY[0x24BDAC7A0](a1, a2, *(_QWORD *)&a3, a4);
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x24BEDB8F8](thrown_size);
}

void __cxa_bad_cast(void)
{
  MEMORY[0x24BEDB900]();
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x24BEDB910](a1);
}

void __cxa_end_catch(void)
{
  MEMORY[0x24BEDB928]();
}

void __cxa_free_exception(void *a1)
{
  MEMORY[0x24BEDB930](a1);
}

void __cxa_guard_abort(__guard *a1)
{
  MEMORY[0x24BEDB940](a1);
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x24BEDB948](a1);
}

void __cxa_guard_release(__guard *a1)
{
  MEMORY[0x24BEDB950](a1);
}

void __cxa_rethrow(void)
{
  MEMORY[0x24BEDB958]();
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
  MEMORY[0x24BEDB960](a1, lptinfo, a3);
}

void *__dynamic_cast(const void *lpsrc, const struct __class_type_info *lpstype, const struct __class_type_info *lpdtype, ptrdiff_t s2d)
{
  return (void *)MEMORY[0x24BEDB968](lpsrc, lpstype, lpdtype, s2d);
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x24BDACB80](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x24BDACB90](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_signpost_emit_with_name_impl(void *dso, os_log_t log, os_signpost_type_t type, os_signpost_id_t spid, const char *name, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x24BDACC10](dso, log, type, spid, name, format, buf, *(_QWORD *)&size);
}

uint64_t _sl_dlopen()
{
  return MEMORY[0x24BEAE670]();
}

uint64_t abort_report_np()
{
  return MEMORY[0x24BDAD010]();
}

uint32_t arc4random(void)
{
  return MEMORY[0x24BDAD158]();
}

uint32_t arc4random_uniform(uint32_t __upper_bound)
{
  return MEMORY[0x24BDAD170](*(_QWORD *)&__upper_bound);
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x24BDAD320](a1, a2);
}

void cblas_sgemv(const CBLAS_ORDER __Order, const CBLAS_TRANSPOSE __TransA, const int __M, const int __N, const float __alpha, const float *__A, const int __lda, const float *__X, const int __incX, const float __beta, float *__Y, const int __incY)
{
  MEMORY[0x24BDB2BE0](*(_QWORD *)&__Order, *(_QWORD *)&__TransA, *(_QWORD *)&__M, *(_QWORD *)&__N, __A, *(_QWORD *)&__lda, __X, *(_QWORD *)&__incX, __alpha, __beta);
}

void dispatch_apply_f(size_t iterations, dispatch_queue_t queue, void *context, void (__cdecl *work)(void *, size_t))
{
  MEMORY[0x24BDADC98](iterations, queue, context, work);
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
  MEMORY[0x24BDADCA8](queue);
}

void dispatch_assert_queue_not_V2(dispatch_queue_t queue)
{
  MEMORY[0x24BDADCB8](queue);
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADCC0](queue, block);
}

dispatch_block_t dispatch_block_create(dispatch_block_flags_t flags, dispatch_block_t block)
{
  return (dispatch_block_t)MEMORY[0x24BDADD18](flags, block);
}

intptr_t dispatch_block_wait(dispatch_block_t block, dispatch_time_t timeout)
{
  return MEMORY[0x24BDADD40](block, timeout);
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x24BDADDA8](identifier, flags);
}

dispatch_group_t dispatch_group_create(void)
{
  return (dispatch_group_t)MEMORY[0x24BDADDC8]();
}

void dispatch_group_enter(dispatch_group_t group)
{
  MEMORY[0x24BDADDD0](group);
}

void dispatch_group_leave(dispatch_group_t group)
{
  MEMORY[0x24BDADDD8](group);
}

intptr_t dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
{
  return MEMORY[0x24BDADDF0](group, timeout);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
  MEMORY[0x24BDADE98](predicate, block);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(dispatch_queue_attr_t attr, dispatch_autorelease_frequency_t frequency)
{
  return (dispatch_queue_attr_t)MEMORY[0x24BDADEB8](attr, frequency);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return (dispatch_queue_attr_t)MEMORY[0x24BDADEC8](attr, *(_QWORD *)&qos_class, *(_QWORD *)&relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x24BDADED0](label, attr);
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x24BDADF28](value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x24BDADF30](dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x24BDADF38](dsema, timeout);
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADFE8](queue, block);
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x24BDADFF8](when, delta);
}

char *dlerror(void)
{
  return (char *)MEMORY[0x24BDAE068]();
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x24BDAE088](__handle, __symbol);
}

float expf(float a1)
{
  float result;

  MEMORY[0x24BDAE288](a1);
  return result;
}

int fflush(FILE *a1)
{
  return MEMORY[0x24BDAE350](a1);
}

long double fmod(long double __x, long double __y)
{
  long double result;

  MEMORY[0x24BDAE3F0](__x, __y);
  return result;
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x24BDAE428](a1, a2);
}

int fputs(const char *a1, FILE *a2)
{
  return MEMORY[0x24BDAE440](a1, a2);
}

void free(void *a1)
{
  MEMORY[0x24BDAE450](a1);
}

pid_t getpid(void)
{
  return MEMORY[0x24BDAE6D0]();
}

kern_return_t host_page_size(host_t a1, vm_size_t *a2)
{
  return MEMORY[0x24BDAE800](*(_QWORD *)&a1, a2);
}

kern_return_t host_statistics(host_t host_priv, host_flavor_t flavor, host_info_t host_info_out, mach_msg_type_number_t *host_info_outCnt)
{
  return MEMORY[0x24BDAE820](*(_QWORD *)&host_priv, *(_QWORD *)&flavor, host_info_out, host_info_outCnt);
}

long double hypot(long double __x, long double __y)
{
  long double result;

  MEMORY[0x24BDAE838](__x, __y);
  return result;
}

float hypotf(float a1, float a2)
{
  float result;

  MEMORY[0x24BDAE840](a1, a2);
  return result;
}

float logf(float a1)
{
  float result;

  MEMORY[0x24BDAEAF8](a1);
  return result;
}

mach_port_t mach_host_self(void)
{
  return MEMORY[0x24BDAEB68]();
}

kern_return_t mach_port_deallocate(ipc_space_t task, mach_port_name_t name)
{
  return MEMORY[0x24BDAEBB0](*(_QWORD *)&task, *(_QWORD *)&name);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAED70](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAED78](size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAED88](ptr, size, type_id);
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x24BDAEE70](__s, *(_QWORD *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x24BDAEE78](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x24BDAEE80](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x24BDAEE98](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x24BDAEEA8](__b, *(_QWORD *)&__c, __len);
}

long double modf(long double __x, long double *__y)
{
  long double result;

  MEMORY[0x24BDAEFB0](__y, __x);
  return result;
}

uint32_t notify_cancel(int token)
{
  return MEMORY[0x24BDAF138](*(_QWORD *)&token);
}

uint32_t notify_get_state(int token, uint64_t *state64)
{
  return MEMORY[0x24BDAF148](*(_QWORD *)&token, state64);
}

uint32_t notify_register_check(const char *name, int *out_token)
{
  return MEMORY[0x24BDAF168](name, out_token);
}

uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return MEMORY[0x24BDAF170](name, out_token, queue, handler);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x24BEDCF68](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x24BEDCF88]();
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x24BEDCFA8](a1);
}

void objc_autoreleasePoolPop(void *context)
{
  MEMORY[0x24BEDCFB0](context);
}

void *objc_autoreleasePoolPush(void)
{
  return (void *)MEMORY[0x24BEDCFC0]();
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x24BEDCFD0](a1);
}

id objc_begin_catch(void *exc_buf)
{
  return (id)MEMORY[0x24BEDCFD8](exc_buf);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x24BEDCFE8]();
}

void objc_copyStruct(void *dest, const void *src, ptrdiff_t size, BOOL atomic, BOOL hasStrong)
{
  MEMORY[0x24BEDD020](dest, src, size, atomic, hasStrong);
}

void objc_copyWeak(id *to, id *from)
{
  MEMORY[0x24BEDD030](to, from);
}

void objc_destroyWeak(id *location)
{
  MEMORY[0x24BEDD038](location);
}

void objc_end_catch(void)
{
  MEMORY[0x24BEDD050]();
}

void objc_enumerationMutation(id obj)
{
  MEMORY[0x24BEDD068](obj);
}

void objc_exception_rethrow(void)
{
  MEMORY[0x24BEDD070]();
}

void objc_exception_throw(id exception)
{
  MEMORY[0x24BEDD078](exception);
}

Class objc_getClass(const char *name)
{
  return (Class)MEMORY[0x24BEDD088](name);
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return (id)MEMORY[0x24BEDD0B0](self, _cmd, offset, atomic);
}

id objc_initWeak(id *location, id val)
{
  return (id)MEMORY[0x24BEDD0C0](location, val);
}

id objc_loadWeakRetained(id *location)
{
  return (id)MEMORY[0x24BEDD0E8](location);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x24BEDD120](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x24BEDD130]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x24BEDD138]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x24BEDD148]();
}

uint64_t objc_opt_respondsToSelector()
{
  return MEMORY[0x24BEDD160]();
}

void objc_release(id a1)
{
  MEMORY[0x24BEDD188](a1);
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x24BEDD2A0](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x24BEDD2A8](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x24BEDD2B0](a1);
}

id objc_retainAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x24BEDD2B8](a1);
}

id objc_retainBlock(id a1)
{
  return (id)MEMORY[0x24BEDD2C0](a1);
}

void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  MEMORY[0x24BEDD3D0](self, _cmd, newValue, offset);
}

void objc_setProperty_atomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  MEMORY[0x24BEDD3E0](self, _cmd, newValue, offset);
}

void objc_storeStrong(id *location, id obj)
{
  MEMORY[0x24BEDD410](location, obj);
}

id objc_storeWeak(id *location, id obj)
{
  return (id)MEMORY[0x24BEDD420](location, obj);
}

void objc_terminate(void)
{
  MEMORY[0x24BEDD450]();
}

id objc_unsafeClaimAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x24BEDD458](a1);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x24BDAF398](oslog, type);
}

BOOL os_signpost_enabled(os_log_t log)
{
  return MEMORY[0x24BDAF400](log);
}

uint64_t os_unfair_lock_lock_with_options()
{
  return MEMORY[0x24BDAF470]();
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
  MEMORY[0x24BDAF488](lock);
}

long double pow(long double __x, long double __y)
{
  long double result;

  MEMORY[0x24BDAF688](__x, __y);
  return result;
}

int proc_listallpids(void *buffer, int buffersize)
{
  return MEMORY[0x24BDAF6C8](buffer, *(_QWORD *)&buffersize);
}

int proc_pid_rusage(int pid, int flavor, rusage_info_t *buffer)
{
  return MEMORY[0x24BDAF6E8](*(_QWORD *)&pid, *(_QWORD *)&flavor, buffer);
}

int proc_pidinfo(int pid, int flavor, uint64_t arg, void *buffer, int buffersize)
{
  return MEMORY[0x24BDAF6F8](*(_QWORD *)&pid, *(_QWORD *)&flavor, arg, buffer, *(_QWORD *)&buffersize);
}

int rand(void)
{
  return MEMORY[0x24BDAFA38]();
}

long double sin(long double __x)
{
  long double result;

  MEMORY[0x24BDAFE18](__x);
  return result;
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x24BDAFE40](__str, __size, __format);
}

int sprintf(char *a1, const char *a2, ...)
{
  return MEMORY[0x24BDAFE60](a1, a2);
}

void srand(unsigned int a1)
{
  MEMORY[0x24BDAFE80](*(_QWORD *)&a1);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x24BDAFEF0](__s1, __s2);
}

char *__cdecl strcpy(char *__dst, const char *__src)
{
  return (char *)MEMORY[0x24BDAFF00](__dst, __src);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x24BDAFF40](__s);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return (char *)MEMORY[0x24BDAFF70](__dst, __src, __n);
}

char *__cdecl strstr(char *__s1, const char *__s2)
{
  return (char *)MEMORY[0x24BDAFFC8](__s1, __s2);
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x24BDB0000](__str, __endptr, *(_QWORD *)&__base);
}

kern_return_t task_generate_corpse(task_read_t task, mach_port_t *corpse_task_port)
{
  return MEMORY[0x24BDB0168](*(_QWORD *)&task, corpse_task_port);
}

kern_return_t task_info(task_name_t target_task, task_flavor_t flavor, task_info_t task_info_out, mach_msg_type_number_t *task_info_outCnt)
{
  return MEMORY[0x24BDB0180](*(_QWORD *)&target_task, *(_QWORD *)&flavor, task_info_out, task_info_outCnt);
}

void vDSP_distancesq(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Length __N)
{
  MEMORY[0x24BDB31C8](__A, __IA, __B, __IB, __C, __N);
}

void vDSP_dotpr(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Length __N)
{
  MEMORY[0x24BDB31D0](__A, __IA, __B, __IB, __C, __N);
}

void vDSP_meanv(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length __N)
{
  MEMORY[0x24BDB3248](__A, __IA, __C, __N);
}

void vDSP_svesq(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length __N)
{
  MEMORY[0x24BDB32F0](__A, __IA, __C, __N);
}

void vDSP_vadd(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x24BDB3308](__A, __IA, __B, __IB, __C, __IC, __N);
}

void vDSP_vfill(const float *__A, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x24BDB3368](__A, __C, __IC, __N);
}

void vDSP_vfixru8(const float *__A, vDSP_Stride __IA, unsigned __int8 *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x24BDB3388](__A, __IA, __C, __IC, __N);
}

void vDSP_vfltu8(const unsigned __int8 *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x24BDB33E8](__A, __IA, __C, __IC, __N);
}

void vDSP_vma(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, const float *__C, vDSP_Stride __IC, float *__D, vDSP_Stride __ID, vDSP_Length __N)
{
  MEMORY[0x24BDB3408](__A, __IA, __B, __IB, __C, __IC, __D, __ID);
}

void vDSP_vsmsma(const float *__A, vDSP_Stride __IA, const float *__B, const float *__C, vDSP_Stride __IC, const float *__D, float *__E, vDSP_Stride __IE, vDSP_Length __N)
{
  MEMORY[0x24BDB34E8](__A, __IA, __B, __C, __IC, __D, __E, __IE);
}

void vDSP_vsmul(const float *__A, vDSP_Stride __IA, const float *__B, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x24BDB34F0](__A, __IA, __B, __C, __IC, __N);
}

void vDSP_vsort(float *__C, vDSP_Length __N, int __Order)
{
  MEMORY[0x24BDB3500](__C, __N, *(_QWORD *)&__Order);
}

void vDSP_vsq(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x24BDB3528](__A, __IA, __C, __IC, __N);
}

void vDSP_vsub(const float *__B, vDSP_Stride __IB, const float *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x24BDB3530](__B, __IB, __A, __IA, __C, __IC, __N);
}

void vDSP_vthr(const float *__A, vDSP_Stride __IA, const float *__B, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x24BDB3548](__A, __IA, __B, __C, __IC, __N);
}

vImage_Error vImageAffineWarpCG_ARGB8888(const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, const vImage_CGAffineTransform *transform, const Pixel_8888 backColor, vImage_Flags flags)
{
  return MEMORY[0x24BDB35F0](src, dest, tempBuffer, transform, backColor, *(_QWORD *)&flags);
}

vImage_Error vImageConvert_RGBA8888toRGB888(const vImage_Buffer *a1, const vImage_Buffer *a2, vImage_Flags a3)
{
  return MEMORY[0x24BDB3830](a1, a2, *(_QWORD *)&a3);
}

vImage_Error vImageCopyBuffer(const vImage_Buffer *src, const vImage_Buffer *dest, size_t pixelSize, vImage_Flags flags)
{
  return MEMORY[0x24BDB38A8](src, dest, pixelSize, *(_QWORD *)&flags);
}

vImage_Error vImageTentConvolve_ARGB8888(const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImagePixelCount srcOffsetToROI_X, vImagePixelCount srcOffsetToROI_Y, uint32_t kernel_height, uint32_t kernel_width, const Pixel_8888 backgroundColor, vImage_Flags flags)
{
  return MEMORY[0x24BDB3A98](src, dest, tempBuffer, srcOffsetToROI_X, srcOffsetToROI_Y, *(_QWORD *)&kernel_height, *(_QWORD *)&kernel_width, backgroundColor);
}

void vvsqrtf(float *a1, const float *a2, const int *a3)
{
  MEMORY[0x24BDB3B90](a1, a2, a3);
}

